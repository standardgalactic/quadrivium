
Modern Fortran
Style and Usage
Fortran is one of the oldest high-level languages and remains the premier
language for writing code for science and engineering applications. Modern
Fortran: Style and Usage is a book for anyone who uses Fortran, from the novice
learner to the advanced expert. It describes best practices for programmers,
scientists, engineers, computer scientists, and researchers who want to apply
good style and incorporate rigorous usage in their own Fortran code or to
establish guidelines for a team project. The presentation concentrates primarily
on the characteristics of Fortran 2003, while also describing methods in Fortran
90/95 and valuable new features in Fortran 2008.
The authors draw on more than a half century of experience writing produc-
tion Fortran code to present clear succinct guidelines on formatting, naming,
documenting, programming, and packaging conventions and various pro-
gramming paradigms such as parallel processing (including OpenMP, MPI,
and coarrays), OOP, generic programming, and C language interoperability.
Programmers working with legacy code will especially appreciate the section
on updating old programs.
Norman S. Clerman is currently a private consultant. He was formerly the
Chief Computer Scientist at Opcon Design Associates, LLC, a small company
engaged in lens design.
Walter Spector has been employed by Silicon Graphics International’s Profes-
sional Services organization (formerly Cray Research Inc.) since 1984.
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

Reproduced with permission of IBM Corporate Archives
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

Modern Fortran
Style and Usage
Norman S. Clerman
Walter Spector
Silicon Graphics, Inc., Fremont, California
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

cambridge university press
Cambridge, New York, Melbourne, Madrid, Cape Town,
Singapore, S˜ao Paulo, Delhi, Tokyo, Mexico City
Cambridge University Press
32 Avenue of the Americas, New York, NY 10013-2473, USA
www.cambridge.org
Information on this title: www.cambridge.org/9780521730525
c⃝Norman S. Clerman and Walter Spector 2012
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.
First published 2012
Printed in the United States of America
A catalog record for this publication is available from the British Library.
Library of Congress Cataloging in Publication data
Clerman, Norman S., 1946–
Modern Fortran : style and usage / Norman S. Clerman, Walter Spector.
p.
cm.
Includes bibliographical references and index.
ISBN 978-0-521-51453-8 (hardback)
1. FORTRAN (Computer program language)
I. Spector, Walter, 1956–
II. Title.
QA76.73.F25C56
2012
005.13′3 – dc23
2011026625
ISBN 978-0-521-51453-8 Hardback
ISBN 978-0-521-73052-5 Paperback
Cambridge University Press has no responsibility for the persistence or accuracy of URLs for
external or third-party Internet Web sites referred to in this publication and does not guarantee
that any content on such Web sites is, or will remain, accurate or appropriate.
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

To Miriam for all her love and endless encouragement.
Norman S. Clerman
To Irene, Nyssa, Simon, and Sammy with love.
Walter Spector
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

Contents
Source Code Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . page xi
Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
Audience . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii
General Considerations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xiii
Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiv
1. Introduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.2 Typographical Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.3 Source Code Listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
2. General Principles. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
3. Formatting Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.1 Source Form . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.2 Case . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
3.3 Indentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.4 White Space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
3.5 Statements and Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
3.6 Symbols and Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22
4. Naming Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.1 Modules, Procedures, and Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
4.2 Supplemental Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.3 Data Objects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
4.4 Construct Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
5. Documentation Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38
6. Programming Principles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
6.1 Standards Conformance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
6.2 Module Design. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .44
6.3 Procedure Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
6.4 Argument Veriﬁcation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
6.5 Recursive Procedure Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86
6.6 State, Side Effects, and Thread Safety. . . . . . . . . . . . . . . . . . . . . . . . . . .90
vii
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

viii
CONTENTS
7. Programming Conventions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
7.1 Declaration and Initialization of Data Objects . . . . . . . . . . . . . . . . . . . 98
7.2 Allocatable and Pointer Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
7.3 Dynamic Data Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
7.4 Control Flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
7.5 Character String Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
8. Input and Output. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
8.1 General I/O Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140
8.2 Formatted, Unformatted, and Stream I/O. . . . . . . . . . . . . . . . . . . . . .155
8.3 Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
9. Packaging Conventions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
9.1 Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
9.2 External Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
9.3 Submodules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
10. Generic Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
10.1 Generic Code Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 172
10.2 Preprocessor Replication. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .179
11. Object Orientation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
11.1 Type and Class Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
11.2 Creation, Construction, Initialization, and Assignment . . . . . . . . . 189
11.3 Type-Bound Procedures and Procedure Pointer Components . . . . 197
11.4 Inheritance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208
11.5 Polymorphism . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212
12. Parallel Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 216
12.1 Preliminary Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
12.2 Parallel Program Patterns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
12.3 Fortran 2008 Parallel Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242
13. Numerical Types, Kinds, and Operations . . . . . . . . . . . . . . . 247
13.1 The Concept of KIND. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .247
13.2 Floating-Point Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
13.3 Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
13.4 Bit Manipulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258
14. C Interoperability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262
15. Updating Old Programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 271
15.1 Statements. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .271
15.2 Techniques . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
15.3 Nonstandard Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 284
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

CONTENTS
ix
A. Source Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
A.1 Type bound demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
A.2 Unlimited demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
B. Rule List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 308
Bibliography. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .321
Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

Source Code Listings
6.1 Program Intent exp imp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .50
6.2 Program Intent out test
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
6.3 Program Point intent in out
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
6.4 Program Arg par test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .83
7.1 Program Return string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .111
7.2 Module Global target mod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
7.3 Program Proc point test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .126
7.4 Function To lower . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
8.1 Module Lun mod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .141
8.2 Subroutine Process elev ﬁle
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
8.3 Program DTIO demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
8.4 Program Dbuf example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .152
8.5 Program Read sensor ﬁle
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .157
8.6 Program Stream demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
10.1 Module My type mod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .176
10.2 Module Scan mod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .181
11.1 Program Comp name . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
11.2 Program Transaction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .201
12.1 Program Shift demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224
12.2 Program MPI hello . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234
12.3 Program Comm random . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .236
12.4 Module Comm mod . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
12.5 Program Coarray random . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .244
13.1 Function Near0 dp . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250
xi
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

xii
SOURCE CODE LISTINGS
13.2 Function Divide DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
14.1 Program Pid printer
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .263
14.2 Subroutine Fortran FFT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .264
14.3 Program c f pointer test
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .265
14.4 Program Char test
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
A.1 Program Type bound demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 289
A.2 Program Unlimited demo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

Preface
Audience
We wrote this book for anyone who writes programs using Fortran. We think it
will be useful for the following categories of programmers:
■Those who are learning Fortran from scratch and want to start on the right
foot.
■Those who are familiar with pre-modern FORTRAN (up to FORTAN 77)
and would like to learn some of the new concepts and techniques of modern
Fortran (Fortran 90 to Fortran 2008).
■Those who have advanced knowledge of Fortran, have experimented with
various styles, and are open to new ways to improve their programs.
■Those who have experience with other languages, who know the importance
of good coding style and who want to apply it to their Fortran code.
■Those who want to create coding guidelines for teams of programmers, or
establish a good style for a project.
General Considerations
The past four revisions of the Fortran Standard comprise alternating major and
minor revisions, Fortran 90 and Fortran 2003 being the former, Fortran 95 and
Fortran 2008 the latter. This book concentrates primarily on Fortran 2003. We
present Fortran 90/95 methods and note where the techniques and methods of
Fortran 2003 supercede them. Fortran 2008 capabilities are described, but to a
lesser extent.
Each programmer will judge the importance of the new features of the language
based on his or her experience and needs. The new C Interoperability may be very
important to a programmer who often needs to build an application written in
both languages. To another, the new object orientation may be more important,
and for a third, the new parallel programming features in Fortran 2008 will be of
great value.
This book is not a textbook, nor is it an exhaustive guide to the language. For
those needs, in addition to the standard itself, we refer the reader to References
[55] and [1], both with long publishing histories. This book is, instead, a book
of guidelines, or rules, that a reader may want to adopt when writing code. We
attempt to explain what we consider to be good coding techniques. Some of these
are general – they apply to all languages – others are speciﬁc to Fortran. We
xiii
Cambridge Books Online © Cambridge University Press, 2012

xiv
PREFACE
concentrate on characteristics of the language, especially those of Fortran 2003,
that we feel require careful and detailed explanation. Others we discuss only brieﬂy
or do not discuss at all. We have striven to write each guideline in a clear and
succinct manner, brevity being a key goal. We advocate strict adherence to some
of the rules. It serves no purpose, for example, not to include an implicit none
statement in every program unit, and the advantages of doing so are enormous.
Our approach to other rules, though, is more to suggest coding or style guidelines
than to dictate them, and, in some instances, simply to offer alternatives. In each
rule, we make frequent references to other rules, while at the same time trying
to make each independent so the reader does not have to constantly jump from
one to another. All the same, those guidelines that present new and somewhat
complicated aspects of the language, by necessity, require more space. We have
taken “typographical license” and somewhat violated our own formatting rules. For
instance, we use more end-of-line comments than we recommend for your code.
The next section outlines the organization of the book, listing the subjects covered
in each chapter. The earlier chapters cover basic topics that apply to all languages;
the later chapters deal more speciﬁcally with Fortran. In the examples and the
sample code, there is no natural progression from simple to more complex code.
The assumption is that the reader is at least somewhat familiar with Fortran.
The book contains code utilizing new language features that are explained later
in the book. We believe that cross references to other sections and other rules will
sufﬁce to make these clear.
Organization
Chapter 1 deﬁnes the typographical conventions used throughout our book.
The next several chapters take a “top-down” approach to organizing and coding
Fortran applications. Several design objectives that constitute goals for the writing
of excellent code are presented in Chapter 2.
Chapter 3 discusses source form and layout. Chapter 4 is dedicated to the naming
of various entities. Chapter 5 discusses comments and internal program documen-
tation.
Chapter 6 begins to discuss speciﬁcs of using modules as a key to organizing code,
the use of derived types, and organization of procedures and their argument lists.
Chapter 7 discusses data in more detail, and control ﬂow through procedures.
Chapter 8 presents input/output (I/O). Chapter 9 provides more on the organi-
zation of modules and program units and their packaging in ﬁles. Its ﬁnal section
covers an important new Fortran 2008 feature for large programs – submodules.
Submodules offer a solution to the well-known problem of “compilation cascades.”
The remaining chapters are a potpourri of special topics.
Chapter 10 explains several techniques for writing generic code. Chapter 11 forms
an introduction to object-oriented programming, a major feature of Fortran 2003.
Cambridge Books Online © Cambridge University Press, 2012

PREFACE
xv
Chapter 12 is an introduction to several forms of parallel processing that are com-
monly found in programs. Chapter 13 contains guidelines about the considera-
tions the programmer must make when writing code that performs ﬂoating-point
numerical operations. Chapter 14 is an introduction to C Interoperability.
The ﬁnal chapter, Chapter 15, contains recommendations on updating programs
that pre-date Fortran 90.
These serve as starting points for the interested programmer. Far more extensive
and detailed references are available for most of the topics (References [1], [55],
and [39]).
Appendix A contains the source code listing of programs Type bound demo and
Unlimited demo, two complete programs that are referenced from several different
chapters in the book, and Appendix B collects all the rules in a list with the page
reference to their location.
References to the Fortran Standard refer to Fortran 2003, unless otherwise speciﬁed
(see Reference [39]).
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

1.
Introduction
1.1 Acknowledgments
The authors thank the Numerical Algorithms Group Ltd. (NAG) who
provided us with copies of their excellent compiler with which we could
test our code. In particular, thanks go to Mr. Malcolm Cohen, Mr. Rob
Holmes, Mr. Ian Hounam, Mr. Rob Meyer, Mr. Mike Modica, and Mr. John
Morrissey.
The Portland Group provided us with a copy of their compiler. Special thanks
go to Ms. Laura Gibon for arranging that.
We thank Mr. Art Lazanoff for the use of his network server system for our
CVS repository.
We thank Mr. Dan Nagle who offered vigorous criticism and some good
suggestions.
The following persons read over the manuscript; to them we owe our grati-
tude: Dr. Greg Brown, Dr. Charles Crawford, Mr. Ryan O’Kuinghttons, and
Dr. James Hlavka.
Thanks go to Ms. Stacy L. Castillo at the IBM Corporate Archives for arranging
permission to use the material for the frontispiece.
It was a great pleasure to work with our editors at Cambridge University Press:
Ms. Heather Bergman, Ms. Lauren Cowles and Mr. David Jou.
1.2 Typographical Conventions
The following typographical conventions are used in this book:
■medium-weight serif font – normal text
This sentence is written in the font used for normal text.
■bold italicized serif font – rules
■medium-weight sans serif font – computer code
■bold sans serif font – Fortran keywords
Examples are the words “null,” “associated,” and “save” in Rule 74. Note
that the font for keywords and for names from the computer code is used
in the body of the normal text, not just in the code segment.
■medium-weight italicized serif font – terms from the either
the Fortran 2003 or the Fortran 2008 Standard, References [39]
and [43]
1
Cambridge Books Online © Cambridge University Press, 2012

2
MODERN FORTRAN
In source code listings, points of ellipsis (. . .) are used to indicate missing
code – nonessential code that is left out for brevity and clarity.
1.3 Source Code Listings
For the most part the code examples in the book are short sections of code. As
such, they cannot be compiled. In some instances, however, complete programs
are presented as numbered listings. In both cases, comments explaining the
key points are embedded in the code and then referred to in the text. These are
marked and numbered, in both places, by “*Cmnt-i:,” where i is the comment
number. Here, for example, is one such comment and the following two lines
of code, and then the explanation referring to it in the text:
!
*Cmnt−1: Check
arguments
f o r
s a n i t y
s e l e c t
case
( d i r e c t i o n )
case
( ’ forward ’ ,
’FORWARD’ ,
’ r e v e r s e ’ ,
’REVERSE ’ )
Using Rule 63, the ﬁrst argument check (*Cmnt-1) can be entirely elimi-
nated . . .
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

2.
General Principles
“The purpose of computing is not numbers. The purpose of computing is understanding.”
– Hamming
1. Write programs that are clear to both the reader and the compiler.
The ﬁrst and foremost general principle of programming is clarity. From clarity
comes the ability to test, to reuse, and to audit. One simple test is whether you
believe you will be able to understand the code if you come back to it a year
later.
Of course, you write programs to have the computer calculate something for
you. And you know that the computer must be told exactly what to compute.
Your program must completely and correctly specify what is to be computed.
If you are making a numerical calculation, you likely have some consideration
for the efﬁciency of your calculation. The best way to gain efﬁciency is to ﬁrst
choose an efﬁcient algorithm and then to write simple, clear, and logical code
to implement it. Compared with more complex code, it is easier to understand
and easier for the compiler to optimize.
In addition to writing code for the computer, you are also writing code for
humans, yourself included. The purpose of the calculations and the methods
used to do so must be clear.
To achieve these goals, write code that is as simple as possible. Use white
space to aid your eye in following the calculation speciﬁed by the source
code. Comment what cannot be understood from the code itself. The rules
in this book follow from these ideas. Using them will promote consistency of
visual layout, documentation, programming logic, and the naming of program
entities. This consistency, in turn, increases clarity; the program is clear to a
programmer, whether he or she is familiar with it or not, or experienced or not.
Moreover, for the programmer who is charged with learning and modifying
it, a program written in a consistent manner reduces the time required to get
“up to speed.”
Ways to document a program are described in Chapter 5. The term “self-
documenting” is often used to describe code that conveys its design without
excessive commentary. The names of both variables and named constants
should indicate what they represent. The algorithms used in the program
3
Cambridge Books Online © Cambridge University Press, 2012

4
MODERN FORTRAN
should be familiar to anyone educated in the ﬁeld for which the program has
been written. We recommend the naming conventions in Chapter 4.
Clarity for the compiler is aided by simplicity and the use of language-deﬁned
structured constructs (e.g., rather than go to statements) to achieve program
ﬂow. Excessive branching, especially inside do loops, can often thwart opti-
mization.
Avoid “cute tricks.” They are often found in code that may conform to the
standard, but take advantage of things like internal data representations, which
are not standardized. These tricks have two problems: They obscure what you
are trying to compute, from both the compiler and you, and they are very
likely not portable, even among different compilers on the same hardware.
Many uses of the intrinsic function transfer and bit manipulation intrinsic
functions fall into this category.
A simple test for whether a program unit is clearly expressed is the Telephone
Test (see Reference [45]). If the program can be read over the telephone, and
completely understood by the listener, it is likely clear.
2. Write programs that can be efﬁciently tested.
A program must produce correct results when provided valid input. Key to
this is to emphasize error detection and correction as early as possible in the
development and testing process. The earlier a problem is detected, the less it
costs to ﬁx it.
Several techniques can be used to help produce quality code with reduced
debugging times. First, when writing code, take advantage of modern features
that allow the compiler to detect errors at compile time. Two key items for
Fortran programmers are the use of implicit none, for avoiding typograph-
ical mistakes, and the use of modules for packaging and, doing so, ensuring
interface checking. The use of these two features is highly recommended for
all code.
Second, it is desirable to modularize and code individual algorithms into
procedures in a way that they can be independently tested and veriﬁed. Testing
procedures independent of the entire application is called “unit testing,” and
the individual tests are called “unit tests.” Unit tests are a fundamental tool for
validating a procedure (see Reference [47]).
To be easily unit tested, a procedure should use a minimal number of variables
outside its local scope. A test driver can then be written to present the target
procedure with different combinations of arguments, and compare the actual
returned results with known good results.
Each test driver should indicate in some manner, for example in a log ﬁle,
each of the tests it has run, and a PASS or FAIL ﬂag. Simple scripts can then
be written to run each of the unit test drivers, and to summarize the results.
Cambridge Books Online © Cambridge University Press, 2012

GENERAL PRINCIPLES
5
Regressions, code that worked previously but, after some changes have been
made, no longer does, can be quickly spotted and repaired.
A third aspect of reliability is the rejection of inputs that are invalid. For
example, it is often possible to include non-time-consuming tests of the input
arguments for validity, such as ensuring that arrays have compatible sizes. The
routine can then return an error code back to the caller instead of producing
incorrect results. This is discussed in more detail in Section 6.4. By returning
an error code, instead of aborting, unit tests may be written to test for bad
inputs, as well as good inputs.
Finally, once individual components of an application have been tested, tests
on complete problems can be made to verify the application as a whole. Inputs
representing typical end-user problems can be provided that produce known
good results. Tests should encompass the full range of allowable inputs. Tests
of numerical algorithms should include very large and small values; decision
algorithms should be tested with as many combinations, such as true or false
conditions, as practical. For numerical algorithms that will break down with
very large arguments, such as computing cos(1010), the documentation should
specify to what degree it has been tested and the results of the tests. As an
application is developed and maintained, the test base provides a valuable
feedback mechanism to look for regressions.
3. Write programs that will scale to different problem sizes.
Scalability is the property of a program to accommodate a wide range of
problem sizes. In other words, a program should be able to handle small test
cases using minimal computer resources, and, ideally, it should also be able
to handle the largest problems that a given machine is capable of processing
without changing any of the source code. Arrays and other data structures
should be able to adjust themselves to any reasonable problem size. This can
also result in greater efﬁciency through better use of cache memory.
Since Fortran 90, Fortran has supported various techniques – pointers, and
allocatable variables, assumed shape and automatic arrays – for dynamically
allocating memory based on problem size. These should be used instead of
ﬁxed dimensions wherever an array size may vary (instead of the earlier practice
of hard-coding maximum sizes).
Scalability is also often used to describe how well a program takes advantage
of multiple processors and the multiple cores of modern processors. Many
schemes for executing portions of a code in parallel have been implemented by
the Fortran community, including OpenMP and MPI. Section 12.2.2 covers
OpenMP in more detail; Section 12.2.3 does the same for MPI. Fortran 2008
introduces the do concurrent variant of the do construct for shared memory
parallelism (that is, all the processors share a common memory address space).
It also introduces the coarray, which allows multiple copies of a program to
Cambridge Books Online © Cambridge University Press, 2012

6
MODERN FORTRAN
run in both shared and distributed memory environments. These are covered
in more detail in Section 12.3.
4. Write code that can be reused.
Human time is expensive. Computer hardware and software is cheap in com-
parison. It is therefore advantageous to write code in such a way that it can be
reused in new applications and in new environments with minimal change.
Some well-known techniques that aid reuse include:
■Following the current Fortran standard. The standard is the contract
between the compiler writer and the application developer. When non-
standard code is used, there are no guarantees that the code will run with
future hardware or software.
■Maximizing the use of local variables. Generally, low-level procedures
should both accept their inputs and return their results through the dummy
argument list of subroutines and function return values. Use of variables
outside the procedure’s local scope often creates application-speciﬁc depen-
dencies, which can limit reuse.
■Using derived types, and their type-bound procedures and procedure com-
ponents. These allow code to be reused and even extended, using object-
oriented techniques. Components within objects can be added, changed,
or removed while limiting the scope of changes in existing code to places
that actually use the changed components.
5. Document all code changes, keeping a history of all code revisions.
Auditability refers mostly to the commentary within the code and to its
revision history. It is quite useful to understand how and why a particular area
changed and to verify that the correct version of a routine is in use. In some
environments, such as in organizations that need to conform to Sarbanes-Oxley
standards (see Reference [68]), it is critical to maintain a revision history. It is
also useful for a program to be able to indicate its own version to a user upon
demand.
Source code control systems are very useful for inserting version numbers into
source code on a per ﬁle basis. For example, in one such system, CVS (see
Reference [16]), one can embed the string $Id: $ into a comment line in the
source:
!
F i l e
v e r s i o n :
$Id :
$
The sentinel “Id” is a keyword. When CVS encounters it surrounded by dollar
signs, it expands the line by adding a header when extracting the source ﬁle.
The previous line would expand to something like:
!
F i l e
v e r s i o n :
$Id :
version mod . f90 , v
1.4
2009/02/02
!
02:55:10 wws Exp $
Cambridge Books Online © Cambridge University Press, 2012

GENERAL PRINCIPLES
7
In addition, each change to the ﬁle via the source code control system allows
the insertion of commentary describing the change. The text is maintained
for future review.
A version numbering scheme should also be maintained for the program or
library as a whole. Typically these version numbers will use digits separated
by periods indicating major, minor, and bug-ﬁx levels. A major release is one
where the new features are of such signiﬁcance that a shift in how a user uses
the code may occur. A minor release may signify that features with little impact
to existing use have been added and that a large number of bugs have been
ﬁxed. Sometimes developers release a very small number of changes purely to
ﬁx speciﬁc bugs that have been discovered since the previous major or minor
releases.
A common convention is to allow a user to specify an option on the command
line, such as -V or --version, that causes the program to print out its version.
Programs might also print their version on one of the output ﬁles or on the
screen. Note that programs can read arguments from the command line with
the get command argument intrinsic procedure.
$ prog1−−v e r s i o n
prog1
( Elements
u t i l i t i e s )
3 . 1 . 4 $
Additionally, especially in the case of libraries that are used by a number of
applications, it is useful to maintain a module variable within the library
containing the version string. A module procedure can be written to return
the string so that a caller can determine which version of the library is in use.
Likewise, the CVS Id can be placed into a character string that can be extracted
with tools such as the Unix strings command. By doing this you can ensure
that the source ﬁle and the object ﬁle match.
! wws Exp $
module Version mod
i m p l i c i t
none
private
public
: :
C h e c k v e r s i o n o p t i o n ,
G e t v e r s i o n
!
Because
of
space
requirements ,
l i t e r a l
constant
!
CVS ID
i s
shown on 2
l i n e s . CVS
w i l l
w r i t e
i t
on
!
one
l i n e .
character (*) ,
parameter
: :
CVS ID = &
’ $Id :
P r o g F o r A u d i t a b i l i t y . tex , v
1.16 2010−12−18 &
&23:26:02
clerman Exp $ ’
character (*) ,
parameter
: :
VERSION STRING = ’3.1.4 ’
contains
Cambridge Books Online © Cambridge University Press, 2012

8
MODERN FORTRAN
function
G e t v e r s i o n
()
r e s u l t
( r e t u r n v a l u e )
character ( len
(VERSION STRING ))
: :
r e t u r n v a l u e
r e t u r n v a l u e = VERSION STRING
end
function
G e t v e r s i o n
subroutine
C h e c k v e r s i o n o p t i o n
()
character (128)
: :
a r g s t r i n g
integer
: :
i
do ,
i =1, command argument count
()
c a l l
get command argument (number=i , &
value=a r g s t r i n g )
i f
( a r g s t r i n g == ’−−v e r s i o n’) then
p r i n t
* ,
’ Version :
’ ,
G e t v e r s i o n
()
e x i t
end
i f
end do
end subroutine
C h e c k v e r s i o n o p t i o n
end module Version mod
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

3.
Formatting Conventions
3.1 Source Form
6. Always use free source form.
Fortran 90 introduced free source form. We recommend that it always be used
in new code. Free source form offers a number of advantages over the older
ﬁxed source form code:
■Free source form is more compatible with modern interactive input devices
than ﬁxed form. The maximum line length is 132 characters, compared to
the older limit of 72 characters. This reduces the possibility of text exceeding
the limit, which could lead the compiler to misinterpret names.
■Line continuations in free form are performed by using a trailing ampersand
character, &, rather than entering a character in column 6 of the following
line. As an additional visual reminder and safeguard, a leading ampersand,
placed in any column, is also allowed to precede the remaining source code.
■In ﬁxed source form, the ﬁrst six columns are reserved for statement labels,
with column 1 also used to indicate comment lines. In modern code,
using structured control statements, statement labels are rare. The ﬁrst ﬁve
columns are therefore wasted because they are rarely used. These last two
features, combined with the next, provide much greater ﬂexibility laying
out the code.
■In free source form, any statement can begin in column 1. Free source form
always uses the “in-line” comment style, indicated by using an exclamation
mark. In-line comments can begin in any column. Here is the same code
in ﬁxed format and in free format:
C FIXED SOURCE FORM COMMENT
DO 10 ,
I = 1 , SIZE (DTARR)
. . .
10 CONTINUE
!
Free
format comment
do ,
i =1,
s i z e
( d t a r r )
!
comments
begin
i n
any column
. . .
end do
■With free source form, the concept of “signiﬁcant blanks” was introduced.
In ﬁxed form source, blanks were insigniﬁcant in most contexts. This
could lead to code that was very difﬁcult to read. For example, statement
9
Cambridge Books Online © Cambridge University Press, 2012

10
MODERN FORTRAN
or variable names might be split across line continuations. By requiring
blanks to be signiﬁcant in free form code, code becomes more uniform
and readable, leading to better clarity and reliability. Here is a sample of a
ﬁxed form statement showing what are now considered signiﬁcant blanks
followed by an equivalent statement without the blanks:
DO ITER = 1 , MAX ITER S
. . .
DO ITER = 1 , MAXITERS
3.2 Case
7. Adopt and use a consistent set of rules for case.
It is essential when discussing case in Fortran to emphasize that it is a case-
insensitive language. The following variations all represent the same variable:
VORTICITY, vorticity , Vorticity , VortiCity. Compilers that, as an optional
feature, permit distinguishing entities based solely on case are not standard;
you should not use this option.
Strictly speaking, prior to Fortran 90, standard-conforming code had to be
written in uppercase letters. The Fortran character set described in the older
standards speciﬁed only the 26 uppercase letters.
Beginning with Fortran 90, lowercase letters have been formally permitted,
and all known compiler vendors supported them. However, because so much
old code is still in use, it is still common to encounter code that conforms to
the original restriction. Here is a snippet of code from the LINPACK Users’
Guide (see Reference [20]):
20 M = MOD (N,
4)
IF
(M .EQ.
0) GO TO 40
DO 30
I = 1 , M
DY( I ) = DY( I ) + DA * DX( I )
30 CONTINUE
IF
(N .LT.
4) RETURN
40 MP1 = M + 1
Nowadays, programmers can use lowercase letters, and the underscore is part
of the character set. The maximum number of characters that can be used
to form a name has grown from the original number of 6, to 31 in Fortran
90/95, to 63 in Fortran 2003. It is now common to see a variable such as
molecular weight.
Even though the language is case-insensitive, you will often see that programs,
especially large ones, are written with speciﬁc case conventions. Using different
combinations of case, such as using all one case for certain types of program
entities and the opposite case for others, capitalizing certain types of entities,
or using a consistent set of combinations of uppercase letters and underscores,
Cambridge Books Online © Cambridge University Press, 2012

FORMATTING CONVENTIONS
11
helps differentiate between the different types of entities. On the other hand,
modern text editors have greatly obviated this; they automatically recognize
different types of entities, and the programmer can conﬁgure the editor to
highlight them by using different fonts and colors, both foreground and
background, and by using underlining. Furthermore, the careful naming of
all entities, as described in Chapter 4, decreases the need to use different case
rules for different program entities.
A wide range of opinion exists on this subject. A survey of professional lit-
erature reveals the use of many different conventions. Rather than strictly
prescribing a particular set of case rules, we suggest here, in several subrules,
some alternatives. They are only a few of the many possibilities. The important
point is that whatever rule you choose, you should use it consistently.
7.1
Use lowercase throughout.
As implied earlier, writing all entities using solely lowercase characters is being
widely adopted. Words spelled with all lowercase letters tend to be more
legible than those spelled using only uppercase ones. Furthermore, there is
little chance of confusing the letter “i” with the numeral “1,” the letter “B”
with the numeral “8,” etc., which can be a problem with some fonts.
Because case is not used to distinguish between types of program entities, the
importance of using a clear naming scheme, as described in Chapter 4, grows.
It also encourages the use of underscores in names, which some programmers
prefer not to use. If underscores are used, the editor should not be conﬁgured
to underline entities that contain them; the underscore would then be difﬁcult
to see. Most, but not all, of the entities in this book are written using lowercase
letters.
7.2
Capitalize the names of all user-written procedures.
Capitalizing the ﬁrst character of the names of all subroutines and functions
makes them stand out in the code. For the most part, this isn’t a problem with
subroutines because they are normally preceded by the keyword call . Their
names can, however, be passed as arguments to procedures. With functions,
capitalizing the names is more useful; it helps distinguish them from array
references in expressions. So, in the following two lines of code, the ﬁrst is a
reference to a function, the second to an element of an array:
a name = Employee name
( i )
items = i t e m l i s t ( i ,
j )
You may prefer to not use underscores. If this is the case, consider writing the
function name using what is commonly called UpperCamelCase, where each
word has the ﬁrst letter capitalized, like this:
a name = EmployeeName ( i )
Cambridge Books Online © Cambridge University Press, 2012

12
MODERN FORTRAN
Capitalizing procedure names has the additional advantage of helping to dis-
tinguish between derived-type components that are data objects and those that
are functions referenced using the notation new to Fortran 2003.
Here are two snippets of code: in the ﬁrst, the assignment statement is to an
element of component protein codes of derived type cell t, identiﬁable by the
lowercase component name protein codes; the second is a function reference,
identiﬁable by the capitalized function name, to the type-bound function Next
whose ﬁrst argument is a data object of type cell t (see Section 11.3):
type
c e l l
t
integer ,
a l l o c a t a b l e
: :
p r o t e i n c o d e s ( : )
type
( c e l l
t ) ,
pointer
: :
neighbor => n u l l
()
contains
procedure
: :
Next => Next neighbor
end type
c e l l
t
type
( c e l l
t )
: :
t h i s ,
n e x t c e l l
integer
: :
p r o t e i n
!
component
r e f e r e n c e
p r o t e i n = t h i s%neighbor%p r o t e i n c o d e s ( i p )
. . .
!
f u n c t i o n
r e f e r e n c e
n e x t c e l l = t h i s%neighbor%Next
()
You can use two other schemes to emphasize that a name is a function: one
is to name the function using a verb. So, a better name for the function
Employee name would be Get employee name. The second, as in the example,
is to separate the name of the function from the opening parentheses by a
space and to not do so when referencing an array. In this book, we capitalize
all procedure names. We also separate the name of the procedure from the
opening parentheses with at least one space. (See also Rules 26 and 16.)
7.3
Write all named constants using uppercase letters.
Named constants (entities declared using parameter) stand out in your code if
you write them using all uppercase characters. The use of all uppercase differ-
entiates them from, say, variables read in from a ﬁle. All uppercase characters
are used in the code in this book when writing named constants:
integer ,
parameter
: : MAX ELEMENTS = 200
. . .
read
( unit =10, fmt=*) max elements
7.4
Begin the name of all data entities using a lowercase letter.
To set off data entities from the other entities discussed so far, begin them
with a lowercase letter. If you are using underscores, the entire name can be
Cambridge Books Online © Cambridge University Press, 2012

FORMATTING CONVENTIONS
13
lowercase like this: loop voltage, or, if underscores are not used, write the
name using lowerCamelCase like this: loopVoltage. In this book, we employ
all lowercase characters when writing data entities, separating words using
underscores.
3.3 Indentation
8. Use a consistent number of spaces when indenting code.
The next few rules discuss the indentation of code: the use of two or three spaces
is recommended. Be consistent. A single space is not large enough for clarity.
More than three may result in code being pushed to the right when various
code constructs are nested, for example, an if −else−end if construct nested
inside a do−end do construct, nested inside a case statement in an internal
subprogram of a module procedure. If you use a four-space indentation in
such an instance and follow the guidelines in this chapter, the most-nested
statements would begin in column 20.
9. Increase the indentation of the source code every time the data scope
changes.
A typical example of such indentation would be to indent module procedures
in modules and internal subprograms from their host, like this:
module Element mod
!
indent
a l l
e n t i t i e s
whose
scope
i s
module .
type
element t
r e a l
: :
d r a g v e c t o r (3)
. . . more components
end type
element t
integer ,
parameter
: : MAX ELEMENTS = 10000
contains
!
indent
module
procedures
a f t e r
the
c o n t a i n s
!
statement .
pure
subroutine
Compute drag vector
( t h i s ,
e r r o r f l a g )
!
indent
code
w i t h i n
procedures .
type
( element t ) ,
intent
( in
out )
: :
t h i s
integer ,
intent
( out )
: :
e r r o r f l a g
r e a l
: :
v o r t i c i t y
e r r o r f l a g = NO ERROR
v o r t i c i t y
= C o m p u t e v o r t i c i t y
( t h i s )
contains
!
indent
i n t e r n a l
subprograms
that
f o l l o w
the
!
c o n t a i n s
statement .
Cambridge Books Online © Cambridge University Press, 2012

14
MODERN FORTRAN
pure
function
C o m p u t e v o r t i c i t y
( t h i s ) &
r e s u l t
( r e t v a l )
type
( element t ) ,
intent
( in )
: :
t h i s
r e a l
(WORKING PREC)
: :
r e t v a l
. . .
end
function
C o m p u t e v o r t i c i t y
end subroutine
Compute drag vector
end module Element mod
10. Indent the block of code statements within all control constructs.
Structured control constructs comprise an initial and a terminal statement
between which is a block of executable statements. Some may also include
intermediate statements with statements following them. They include the
do, if , select case, select type, associate, where, and forall constructs. In
Fortran 2008, the interior of the block construct may also be indented. Align
the statements that deﬁne the bounds of the block and indent the interior
statements:
i c o d e = b i s e c t f i r s t e n t r y
t r y b i s e c t :
do
i = 1 , MAX ITERS
c a l l
B i s e c t
( z ,
zst ,
zf ,
i c o d e )
x = z
i f
( i c o d e == BISECT EVAL REQD)
then
i f
( func1
( x ) > 0 . 0 )
then
i c o d e = BISECT POS EVAL
e l s e
i c o d e = BISECT NEG EVAL
end
i f
e l s e
e x i t
t r y b i s e c t
end
i f
end do
t r y b i s e c t
type
( element t )
: :
elems ( : ,
: )
. . .
h i l i t e
:
where ( Get temp
( elems ) >= melt pt )
c a l l
H i g h l i g h t
( elems , RED)
e l s e
where ( Get temp
( elems ) >= p l a s t i c p t )
h i l i t e
c a l l
H i g h l i g h t
( elems , MAGENTA)
e l s e
where
h i l i t e
c a l l
H i g h l i g h t
( elems , GREEN)
end where
h i l i t e
choose shape
:
s e l e c t
case
( shape )
case
(SHP CIRCLE)
choose shape
x d i s t = 2.0
*
dimensions (1)
Cambridge Books Online © Cambridge University Press, 2012

FORMATTING CONVENTIONS
15
y d i s t = x d i s t
case
(SHP RECTANGLE, SHP SQUARE)
choose shape
x d i s t = dimensions (1)
y d i s t = dimensions (2)
case
default
choose shape
x d i s t = 0.0
y d i s t = 0.0
end
s e l e c t
choose shape
11. Indent all the code after a named construct so the name stands out.
For short names, maintain the initial construct statement on the same line as
the name and align all other block construct statements with the ﬁrst letter of
the initial statement:
each pt :
do
i = 1 ,
max points
. . .
i f
( x <= 0 . 0 )
cycle
each pt
. . .
i f
( x > x max )
e x i t
each pt
end do each pt
In order that the indentation not be excessive when using longer names,
consider the block label to be part of the construct:
u n t i l c o n v e r g e d :
do
i = 1 ,
max points
. . .
i f
( x <= 0 . 0 )
cycle
u n t i l c o n v e r g e d
. . .
i f
( x > x max )
e x i t
u n t i l c o n v e r g e d
. . .
end do
u n t i l c o n v e r g e d
12. Consider using one indentation for block constructs and a different
one for statement continuation.
You may wish to differentiate between the code contained in block constructs
and continuation lines by using a different number of spaces for each. One
simple rule is that continuation lines are doubly indented, that is, their inden-
tation is four or six spaces if, respectively, two or three spaces is the regular
indentation. In the following code, two spaces are used for an if −else−end if
block construct and four for a single-line if statement:
i f
( present
( arg 1 )
)
then
a r g 1 l o c a l = arg 1
e l s e
a r g 1 l o c a l = DEFAULT ARG 1
end
i f
. . .
Cambridge Books Online © Cambridge University Press, 2012

16
MODERN FORTRAN
i f
( present
( r e t u r n s t a t )
) &
r e t u r n s t a t = r e t u r n s t a t l o c a l
13. Left-justify major documentation blocks; indent short comments the
same as the code it describes or one additional indentation level.
You may choose to use the following guidelines to indent comments:
Reference [53] strongly recommends indenting comments at the same level
as the code it describes and not left-justifying it. In general, indenting to the
level of the code is clearer. For major documentation blocks, however, such as
the one Rule 43 prescribes for every ﬁle unit and procedure, left-justifying the
block may make more sense. It clearly segregates the documentation from the
code, and you can extract the block as a whole to be included in a program
user’s guide. Here is the beginning of the example from that rule:
subroutine
B i s e c t
( x ,
xP , xN ,
mode ,
max attempts , &
z e r o c r i t )
r e a l
(WORKING PREC) ,
&
intent
( in
out )
: :
x ,
xP , xN
integer ,
intent
( in
out )
: :
mode
integer ,
intent
( in ) ,
optional
: :
max attempts
r e a l
(WORKING PREC) ,
&
intent
( in ) ,
optional
: :
z e r o c r i t
!−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
!
Purpose :
determine
the
next
point
at
which a
f u n c t i o n
!
should
be
evaluated
by
b i s e c t i n g
xN and xP .
!
Author : N.
S .
Clerman ,
Dec .
1983
Three forms for indenting short comments are shown in the following code:
(1) Indentation to the level of the code. (2) Indentation to one extra level.
(3) Indentation to one extra level without a following blank line. This last
compresses all the code vertically and may make the code logic easier to
follow:
!
i n d e n t a t i o n
form
1:
at
the
code
l e v e l .
!
s t a r t
timing
c a l l
cpu time
( t1 )
!
i n d e n t a t i o n
form
2:
one
a d d i t i o n a l
l e v e l .
!
s t a r t
timing
c a l l
cpu time
( t1 )
Cambridge Books Online © Cambridge University Press, 2012

FORMATTING CONVENTIONS
17
Table 3.1. Using optional separating blanks
Use
Instead of
Use
Instead of
block data
blockdata
double precision
doubleprecision
else if
elseif
else where
elsewhere
end associate
endassociate
end block data
endblockdata
end do
enddo
end enum
endenum
end ﬁle
endﬁle
end forall
endforall
end function
endfunction
end if
endif
end interface
endinterface
end module
endmodule
end procedure
endprocedure
end program
endprogram
end select
endselect
end subroutine
endsubroutine
end type
endtype
end where
endwhere
go to
goto
in out
inout
select case
selectcase
select type
selecttype
!
i n d e n t a t i o n
form
3:
one
a d d i t i o n a l
l e v e l
!
without
blank
l i n e .
!
s t a r t
timing
c a l l
cpu time
( t1 )
3.4 White Space
14. Use all optional white space in keywords.
The Fortran standard allows optional blanks between some keywords; you
should take advantage of this to improve readability. For example, the endif
and the elseif statements may have a blank before the if :
i f
( f l a g == ITERATE)
then
do ,
i = 1 , MAX COUNT
. . .
end do
e l s e
i f
( f l a g == COMPUTE)
then
. . .
e l s e
. . .
end
i f
Table 3.1 shows statements and keywords that may have separating blanks for
better readability.
15. Align similar code.
You can make your program easier to read by paying attention to the alignment
of the code. To assist in doing this, when declaring the dummy arguments
of procedures, always specify their attributes in the following order so they
Cambridge Books Online © Cambridge University Press, 2012

18
MODERN FORTRAN
can be aligned. First, specify the type, either intrinsic or derived, and kind of
the argument. Second, indicate the argument’s intent. A dummy argument’s
intent is not required in its declaration. Its default value if you do not specify
it is intent (in out) as long as the actual argument is deﬁnable (see Rule
50). But you should always include it so that the compiler can check for
the proper usage and to provide additional documentation. Follow this with
the arguments that are required only as needed. These are the dimension
attribute for arrays, and the target, pointer,
allocatable, and optional
attributes. Always place these in a consistent order so they may be aligned
as shown here:
subroutine
Sub a
( arg 1 ,
arg 2 ,
arg 3 ,
e r r o r f l a g )
real ,
intent
( in ) ,
pointer
: :
arg 1
integer ,
intent
( in
out ) ,
dimension ( : )
: :
arg 2
real ,
intent
( out )
: :
arg 3
l o g i c a l ,
intent
( out ) ,
optional
: :
e r r o r f l a g
. . .
end subroutine
Sub a
In some situations, the type speciﬁcation of the arguments may be of greatly
different lengths, and strict adherence to this rule may push the code far to
the right and cause long blank spaces. This is the case for argument arg 3. You
may prefer this format:
integer ,
intent
( in
out )
: :
arg 2 ( : )
real ,
intent
( out )
: :
arg 3
l o g i c a l ,
intent
( out ) ,
optional
: :
e r r o r f l a g
In the same manner, align the beginning and ending keywords of all constructs,
program units, and other code elements that have beginning and ending
keywords. Here is an example:
type ,
public
: :
node t
type
( node t ) ,
pointer
: :
p t n e x t => n u l l
()
. . .
end type
n o t e t
In the next example, the symbols => used in an associate construct are
aligned, as are the equal signs in the assignment statements:
associate
( cv => t h i s%elements ( elem num)%curv ,
&
cc => t h i s%elements ( elem num)%con con , &
ht => ray ( ray number)% y h e i g h t )
y2
= ht * ht
ecc = 1.0 + cc
cv2 = cv * cv
. . .
end
associate
Cambridge Books Online © Cambridge University Press, 2012

FORMATTING CONVENTIONS
19
The following example shows the alignment of relational and logical operators.
Notice here that the keyword then of the if statement is put on a separate line
so the end of this particularly long statement is clearly indicated:
i f
(
G e t v e l o c i t y
( element ) > v e l o c i t y l i m i t
&
. or .
Comp turbul
( element )
> u p p e r t u r b l i m i t &
. and .
(
G r a p h i s a c t i v e
( g r a p h i d )
&
. and .
H i g h l i g h t i n g i s o n
()
)
)
&
then
c a l l
Graph element
( element ,
g r a p h i d )
. . .
end
i f
Rule 21 advises against placing comments at the end of lines except under a
limited number of conditions. Here are three lines of code from that rule. In
such multiline instances, the code and comments will be clearer if you align
the comments as shown:
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r o r )
!
s k i p
t i t l e
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r o r 1 )
!
s k i p
c o l .
t i t l e
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r o r 2 )
!
s k i p
hyphens
16. Consider using white space to differentiate between the use of paren-
theses to enclose the argument list in calls to subprograms and their use to
enclose the index list of arrays.
To make your code clearer, you or your program team may wish to adopt one
form of using parentheses with arrays and a different one with subprogram
calls. In this example, a space is placed between the end of the procedure name
and the opening parenthesis, and no space is placed after an array name:
c a l l
C a l c l u m i n o s i t y
( t r a c e r e s u l t ,
viewport , &
e r r o r f l a g )
x ( i ,
j ,
k ) = c o e f s ( i ,
j ,
k ) *
C a l c d e n s i t y
( elems , &
i ,
j ,
k )
An alternative way to distinguish the procedure call is to place the space
between the opening parenthesis and the ﬁrst argument and to leave a space
between the end of the last argument and the closing parenthesis:
c a l l
C a l c l u m i n o s i t y (
t r a c e r e s u l t ,
viewport , &
e r r o r f l a g
)
17. Place a space after all commas.
There are many places in Fortran where lists of entities are separated by
commas. Placing a space after each comma makes the lists easier to read:
use element m ,
only
:
add elem ,
create elem ,
r e a l v a r 1
subroutine
B i s e c t
( x ,
xp ,
xn ,
mode ,
max tries , &
z e r o c r i t )
Cambridge Books Online © Cambridge University Press, 2012

20
MODERN FORTRAN
18. Do not use “hard” tabs.
Tabulation characters, “tabs,” can be a convenient way to insert multiple
columns of white space into source code with a single keystroke. However, the
use of tabs is not speciﬁed by the Fortran standard. Different environments
and editors display and compile tab characters in different manners. Code
that appears well laid out in one editor may appear skewed in a second. Some
compilers may treat a tab as a single character, while others might treat it as
representing multiple blank characters. This is a problem when calculating
line length limits and when tabs appear in character literals. Use spaces instead
of tabs or set the editor to replace tabs with an equivalent number of spaces
when the tab key is pressed.
3.5 Statements and Expressions
19. Consider using leading ampersands (&) to mark continuation lines.
Some programmers may prefer to place the optional leading ampersand on
continuation lines; doing so highlights them when reading down the left
margin. At least one text editor known to the authors automatically places
leading ampersands when wrapping code lines:
character ( len =20) , parameter
: :
l i n e s t r i n g s (3) = &
& [
” f i r s t
l i n e
of
t e x t
” , &
&
” second
l i n e
of
t e x t
” , &
&
” t h i r d
l i n e
of
t e x t
”
]
One use for leading ampersands occurs when you must include the same text
in old ﬁxed format code as well as more modern free format code. Then, the
leading ampersand allows you to embed new code in old ﬁxed format code,
either directly or by using the include statement. Place the leading ampersand
in column 6 and the trailing ampersand after column 72 like this:
character ( len =20) , parameter
: :
LINE STRS (3) = . . . &
& [
” f i r s t
l i n e
of
t e x t
” ,
. . . &
&
” second
l i n e
of
t e x t
” ,
. . . &
&
” t h i r d
l i n e
of
t e x t
”
]
The points of ellipsis (...) indicate blank spaces to column 72. This code will
compile both as ﬁxed source form and as free source form code.
You should also be aware that leading ampersands are required when breaking
a long character literal constant into several lines:
error mes s age = ”The
v e l o c i t y
exceeds
the
t u r b u l e n c e&
& l i m i t
on
the
f o l l o w i n g
blade
s e c t i o n s : ”
Neither the blanks that follow the trailing ampersand nor the blanks that
precede the leading ampersand are part of the character literal. In both examples
there is only one blank between the word “turbulence” and the word “limit.”
Cambridge Books Online © Cambridge University Press, 2012

FORMATTING CONVENTIONS
21
As an alternative you can use a concatenation operator (//):
error mes s age = ”The
v e l o c i t y
exceeds
the
t u r b u l e n c e ” &
// ”
l i m i t
on
the
f o l l o w i n g
blade
s e c t i o n s : ”
20. Place each program statement on its own line.
You can now place more than a single line of code on a line by separating them
by semicolons. In general, this is not recommended. Placing each coding state-
ment, especially an executable statement, on a separate line aids you in seeing
the code logic. Placing more than one on a line makes modifying the code more
difﬁcult. You might make an exception to this in the case of a data structure,
such as a matrix, where placing several lines of code on one line, separated by
semicolons, actually promotes clarity, as in the following rotation matrix:
real ,
dimension (2 ,
2)
: :
a ,
an
! . . .
a (1 ,
1) = cos
( an ) ;
a (1 ,
2) = −s i n
( an )
a (2 ,
1) = s i n
( an ) ;
a (2 ,
2) =
cos
( an )
21. In general, avoid putting comments at the end of lines containing
source code.
In general, the best location for comments is immediately before the code
being described. Comments at the end of lines may not be visible in the editor
or they may cause line-wrapping when the code is printed, thereby ruining
the code’s logical typographical layout. Comments placed at the end of the
line, even though annotating only one line, sometimes form part of a group
of similarly commented lines, like this:
r e a l
( kind=double ) ,
intent
( in )
: :
r e a l 1
!
input
args
character
( len =*) ,
intent
( in )
: :
char1
!
w i l l
not
be
integer ,
intent
( in ) ,
optional
: :
i n t 1
!
modified .
integer ,
intent
( in
out )
: :
i n t 2
!
input
arg
!
w i l l
be
!
modified .
If the intents of either argument int1 or int2 are changed, the comments at
the end of line need to be moved.
However, for very short lines of code that require a brief comment, placing
the comment at the end of the line may be appropriate. For example, in
Rule 109, the code includes the following three lines. Even if these three lines
need to be moved as a block, the three end-of-line comments logically move
with them:
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r o r )
!
s k i p
t i t l e
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r o r 1 )
!
s k i p
c o l .
t i t l e
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r o r 2 )
!
s k i p
hyphens
Cambridge Books Online © Cambridge University Press, 2012

22
MODERN FORTRAN
3.6 Symbols and Numbers
22. Use the symbolic relational operators, <, <=, /=, ==, >=, >.
It is ﬁtting in the computer language of math and science to use symbols
expressing the relationship between numbers in place of the older letter abbre-
viations delineated by periods. The code then more closely resembles the
mathematics. Use the ﬁrst set of three lines of code here instead of the second
set of three:
i f
( a <= b )
. . .
f i r s t q u a d = x > 0.0
. and .
y > 0.0
n e a r a x i s
= abs
( z ) <= EPSILON
. . .
i f
( a
. l e .
b )
. . .
f i r s t q u a d = x
. gt .
0.0
. and .
y
. gt .
0.0
n e a r a x i s
= abs
( z )
. l e . EPSILON
Be aware, however, that the proper relational operators for the logical data
type are .eqv. and .neqv. These operators did not exist prior to FORTRAN
77. So it is not unusual to ﬁnd compilers that have extended the use of .eq. and
.ne. for logical data, often by treating the logicals as integers. The result is a
program that inadvertently uses the wrong operator. This can cause portability
problems because different compilers use different internal representations of
values for .true. and . false .:
l o g i c a l
: :
a ,
b ,
c
. . .
c = a
. eqv .
b
i f
( a
. neqv .
c )
. . .
23. Use the square bracket notation, [ ], introduced in Fortran 2003, for
array constructors.
Parentheses are used for many purposes in Fortran. For example, they enclose
the argument list of procedures; they enclose format speciﬁcations; and they
are used in the declarations of arrays, characters, and types. They are also used
as part of the notation for array constructors.
In Fortran 2003, square brackets can be used to specify array constructors. Use
the ﬁrst two assignment statements instead of the last two:
integer ,
parameter
: :
NO OF ELEMS = 3
integer ,
dimension (NO OF ELEMS)
: :
array a ,
a r r a y b
integer
: :
i
!
use
these
two
assignments
i n s t e a d
of
the
l a s t
two
a r r a y a = [ 0 ,
1 ,
5]
a r r a y b = [
( i ,
i =1,
s i z e
( a r r a y b ))
]
. . .
a r r a y a = (/
0 ,
1 , 5 /)
a r r a y b = (/
( i ,
i =1,
s i z e
( a r r a y b ))
/)
Cambridge Books Online © Cambridge University Press, 2012

FORMATTING CONVENTIONS
23
Use of square bracket array constructors adds clarity to the code by reducing
the appearance of multiple uses of parentheses. Visually, this makes the code
easier to read. Note, though, that the coarray data entities in Fortran 2008
also use square brackets as part of their notation (see Rule 169).
24. Write at least one digit on each side of the decimal point of ﬂoating-
point literal constants.
real ,
save
: :
a = 0.0
The advantage is that the dot will be seen and cannot be confused with any
other token, for example, with an operator.
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

4.
Naming Conventions
4.1 Modules, Procedures, and Types
25. Use detailed names for data objects whose scope is global, less detailed
names for those whose scope is a module, and simple but clear names for
those whose scope is a single procedure.
Symbolic names are used in many places. At the outermost level are the names
of modules, the main program, and external procedure program units. Within
the conﬁnes of a program unit are derived-type deﬁnitions, named constants,
and variables. In addition, there are also internal procedures and interface
blocks.
Within individual procedures, there are statement labels for control ﬂow and
I/O purposes.
Generally, the more global the name, the longer and more descriptive it should
be. And, likewise, the more limited the scope of a name is, the shorter it should
be. For example, a module name should indicate the use of the deﬁnitions and
related procedures it contains, for example: Triangular solver mod, whereas a
simple loop index variable may be called i or j.
26. Name user-written procedures using verbs.
Almost all procedures perform some task. Name them using one or more verbs
that succinctly describe the operation carried out. If appropriate, follow each
verb with a speciﬁc noun that describes the object being used. This method
is especially useful when you name functions; it aids in distinguishing them
from arrays. (See also Rules 7.2 and 16.)
subroutine
P e r f o r m a l p h a s o r t
( l i s t )
function
C a l c d i r c o s i n e s
( ray )
r e s u l t
( d i r c o s i n e s )
Be as speciﬁc as possible without making the function name overly long. And
be mindful that a procedure speciﬁc to a certain data type has a speciﬁc name.
Write:
subroutine
Read temperature data
( i n p u t p o r t )
And, likewise, for a generic procedure or for a type-bound procedure that
might be used in an extended type, a more generic name should be used (see
Rule 149):
subroutine
Read data
( i n p u t p o r t )
24
Cambridge Books Online © Cambridge University Press, 2012

NAMING CONVENTIONS
25
27. Use a consistent set of verbs throughout to name common procedures.
Many categories of subprograms are used throughout programs. The following
subrules suggest naming guidelines for some of them.
27.1
Name accessor procedures using either the verb “Set” or “Put” and
the verb “Get” followed by the component name.
In the following example, a parameterized derived type is deﬁned; the two
accessor procedures are type-bound.
module Polynomial mod
use Kinds mod ,
only : WORK PREC
i m p l i c i t
none
private
type ,
public
: :
p o l y t
( degree )
integer ,
len
: :
degree = 2
r e a l
(WORK PREC)
: :
c o e f s ( degree ) = 0.0 WORK PREC
contains
procedure
: :
Get coef
procedure
: :
S e t c o e f
end type
p o l y t
contains
elemental
function
Get coef
( t h i s ,
power ) &
r e s u l t
( r e t u r n v a l u e )
c l a s s
( p o l y t ) ,
intent
( in )
: :
t h i s
integer
( kind
( t h i s%degree ) ) ,
&
intent
( in )
: :
power
r e a l
( kind
( t h i s%c o e f s ))
: :
r e t u r n v a l u e
r e t u r n v a l u e = 0.0
i f
(0 < power
. and .
power <= t h i s%degree ) &
r e t u r n v a l u e = t h i s%c o e f s ( power )
end
function
Get coef
subroutine
S e t c o e f
( t h i s ,
power ,
coef )
c l a s s
( p o l y t ) ,
intent
( in
out )
: :
t h i s
integer
( kind
( t h i s%degree ) ) ,
&
intent
( in )
: :
power
r e a l
( kind
( t h i s%c o e f s ) ) ,
intent
( in )
: :
coef
i f
(0 < power
. and .
power <= t h i s%degree ) &
t h i s%c o e f s ( power ) = coef
end subroutine
S e t c o e f
end module Polynomial mod
Cambridge Books Online © Cambridge University Press, 2012

26
MODERN FORTRAN
27.2
Name procedures that traverse data structures using the verbs that
are commonly used – “Next, Previous, Pop, Push,” and so on.
Your code will be clearer to anyone reading it if you name the procedures
operating on data structures using names such as these:
function
Next element
( t h i s )
r e s u l t
( r e t u r n v a l u e )
function
Previous element
( t h i s )
r e s u l t
( r e t u r n v a l u e )
function
Pop node
( t h i s )
r e s u l t
( r e t u r n v a l u e )
27.3
Use the same verb for all ﬁnal procedures followed by the name of
the derived type.
For clarity, use verbs like “Finalize,” “Destroy,” “Remove,” or “Clean” for
all ﬁnal routines (see Rule 147). Whichever the word chosen, use it solely
throughout the program so as not to cause confusion.
module Node mod
i m p l i c i t
none
private
type ,
public
: :
node t
integer
: :
id
type
( node t ) ,
pointer
: :
next node => n u l l
()
contains
f i n a l
: :
Clean => Clean node
end type
node t
contains
subroutine
Clean node
( t h i s )
type
( node t ) ,
intent
( in
out )
: :
t h i s
integer
: :
a l l o c s t a t
i f
( associated
( t h i s%next node )
) &
deallocate
( t h i s%next node ,
stat=a l l o c s t a t )
end subroutine
Clean node
end module Node mod
27.4
Name functions that return a logical result using verbs such as
“Is,” or “Has.”
module Data packet mod
i m p l i c i t
none
private
type ,
public
: :
d a t a p a c k e t t
private
l o g i c a l
: :
i n i t = . f a l s e .
. . .
more components
Cambridge Books Online © Cambridge University Press, 2012

NAMING CONVENTIONS
27
contains
procedure
: :
I s
i n i t i a l i z e d
end type
d a t a p a c k e t t
contains
function
I s
i n i t i a l i z e d
( t h i s )
r e s u l t
( r e t v a l )
c l a s s
( d a t a p a c k e t t ) ,
intent
( in )
: :
t h i s
l o g i c a l
: :
r e t v a l
r e t v a l = t h i s%i n i t == . true .
end
function
I s
i n i t i a l i z e d
. . .
end module Data packet mod
4.2 Supplemental Notation
In this section we set forth guidelines for adding preﬁxes and sufﬁxes to data
object names to assist the person reading the code in identifying the type of
an object and its function. The motivation is that at one glance the reader
can do this; he or she does not have to refer to the data declarations at the
beginning of a module or procedure or to search through other program units
to determine its characteristics.
28. Add an identifying tag to all module names.
The names of modules are used in only a few contexts. One is the module and
bracketing end module statements; another is in use statements. They should
rarely be a point of confusion. On the other hand, if you follow this rule as
well as the next one of adding a tag to the names of derived types, one possible
system of naming is to append mod as a sufﬁx to the module name,
t as
the type name, and then to name objects of the derived type using the base
name. In the following code outline, the local variable element in subroutine
Calculate evaporation is such an object.
module Element mod
i m p l i c i t
none
private
type ,
public
: :
element t
. . .
components
contains
procedure
: :
C a l c u l a t e e v a p o r a t i o n
. . . other
type−bound
procedures
end type
element t
contains
subroutine
C a l c u l a t e e v a p o r a t i o n
( t h i s ,
temperature )
Cambridge Books Online © Cambridge University Press, 2012

28
MODERN FORTRAN
c l a s s
( element t ) ,
intent
( in
out )
: :
t h i s
real ,
intent
( in )
: :
temperature
type
( element t )
: :
element
!
copy
to temp .
v a r i a b l e
i n
the
event
of
an
!
e x c e p t i o n .
element = t h i s
. . . code
c a l c u l a t i n g
the
e v a p o r a t i o n
f o r
element .
end subroutine
C a l c u l a t e e v a p o r a t i o n
end module Element mod
29. Add an identifying tag to all derived type names.
Type names can appear in several different contexts in a program. In some, the
fact that they are derived types is obvious because the keyword type appears
in the statement. One example is the deﬁnition of the type; a second is the
declaration of a dummy argument that is a derived type. Here, there is no
question that particle is the name of a derived type.
type
p a r t i c l e
r e a l
(WORKING PREC)
: :
weight , momentum
end type
p a r t i c l e
elemental
function
C a l c f o r c e
( t h i s )
r e s u l t
( r e t u r n v a l u e )
type
( p a r t i c l e ) ,
intent
( in )
: :
t h i s
r e a l
(WORKING PREC)
: :
r e t u r n v a l u e
end
function
C a l c f o r c e
In other situations, however, this may not be clear. For example, structure
constructors have the same appearance as functions. Here is an assignment:
new command = command ( i n i t =. f a l s e . ,
n o o f p a r s =0)
There is no way to know just by reading this line if it is a normal function
call or an initialization of a variable of derived type command with a structure
constructor. Adding a sufﬁx to form the name makes this clear.
new command = command t ( i n i t =. f a l s e . ,
n o o f p a r s =0)
An additional situation where the use of a type name is not obvious and adding
a sufﬁx assists in identiﬁcation is their inclusion in a list of objects following
the only option in use statements.
use element mod ,
only
:
Add ,
element t ,
Print
Extended derived data types present another instance where adding a sufﬁx
clariﬁes code. Here are two derived types:
type ,
public
: :
p l a n e p o i n t t
r e a l
(WORKING PREC)
: :
x ,
y
end type
p l a n e p o i n t t
Cambridge Books Online © Cambridge University Press, 2012

NAMING CONVENTIONS
29
type ,
public ,
extends
( p l a n e p o i n t t )
: :
s p a c e p o i n t t
r e a l
(WORKING PREC)
: :
z
end type
s p a c e p o i n t t
You can refer to the inherited x component of an object of derived type
space point t in this manner:
type
( s p a c e p o i n t t )
: :
r o t a t i o n p t
. . .
r o t a t i o n p t%x = 3.2 WORKING PREC
It can also be referred to in this manner:
r o t a t i o n p t%p l a n e p o i n t t%x = 3.2 WORKING PREC
Even though the latter is longer, you may prefer to use this nomenclature.
The presence of the intermediate component plane point t , identiﬁable as
a type by its
t sufﬁx, draws your attention to the fact that the variable
rotation pt is of a derived type extended from type plane point t , and that the
component x is inherited from it (Rule 149).
30. Consider adding an identifying tag to all pointers.
When a data object that is a pointer appears in a pointer assignment, there is
no confusion.
real ,
target
: :
matrix ( : , : )
real ,
pointer
: :
row ( : )
. . .
row => matrix ( i ,
: )
However, this is also a valid assignment:
real ,
pointer
: :
row ( : )
. . .
row = matrix ( i ,
: )
In the ﬁrst case, the pointer row is pointing to a row of matrix, serving as an
alias to it; it need not have been previously allocated. The opposite is true
in the second case – where the data is copied. To immediately identify the
context, and to emphasize that the variable row is a pointer and not an array,
it helps to name the pointer using a sufﬁx.
real ,
pointer
: :
row p ( : )
. . .
row p = matrix ( i ,
: )
This supplemental notation also can be helpful in indicating if a pointer or an
allocatable object is being allocated in an allocate statement.
Cambridge Books Online © Cambridge University Press, 2012

30
MODERN FORTRAN
type
( element t ) ,
pointer
: :
elements p ( : )
integer
: :
a l l o c s t a t ,
n o o f e l e m e n t s
. . .
a l l o c a t e
( element t
: :
elements p ( n o o f e l e m e n t s ) , &
stat=a l l o c s t a t )
4.3 Data Objects
31. Use plural nouns to differentiate arrays from scalars.
Name individual objects using a singular noun
type
( atom t )
: :
carbon
and name arrays using a plural noun
type
( atom t )
: :
carbons (4)
An exception to this rule would be the naming of arrays using terms commonly
associated with aggregates, such as “vector” and “matrix.”
r e a l
(WORKING PREC)
: :
v e l o c i t y v e c t o r (3)
This manner of naming objects is especially useful whenever you refer to
an entire array by its name only. Here is a call to a routine where a single
oxygen atom and arrays of both carbon and hydrogen atoms are passed as
arguments:
c a l l
Combine atoms
( oxygen ,
carbons ,
hydrogens , &
r e t u r n v a l )
32. In modules in which a derived type is deﬁned, use either the name
“this” or the name “self” for the pass argument in all type-bound proce-
dures and procedure pointer components and for the dummy argument of
the type in all module procedures.
In many object-oriented programming languages, names such as “this” and
“self” are used within a procedure to refer to the object by which the procedure
was invoked. These names may even be reserved for the purpose.
In Fortran, the object passed to a type-bound procedure is the argument that
has the pass attribute. By default, this is the ﬁrst argument. (See Rule 142.)
There is no default naming requirement. However, if you use either “this” or
“self,” your code will be clearer to someone who is not familiar with Fortran
but is knowledgeable in other languages. Here is an accessor subroutine that
sets the component of a type:
module Node mod
use
Numerical kinds mod ,
only : WORKING PREC
i m p l i c i t
none
Cambridge Books Online © Cambridge University Press, 2012

NAMING CONVENTIONS
31
private
type ,
public
: :
node t
r e a l
(WORKING PREC)
: :
temperature
contains
procedure
: :
Set temp => Set temp node
end type
node t
contains
subroutine
Set temp node
( t h i s ,
temperature )
c l a s s
( node t ) ,
intent
( in
out )
: :
t h i s
r e a l
( kind
( t h i s%temperature ) ) ,
&
intent
( in )
: :
temp
t h i s%temperature = temperature
end subroutine
Set temp node
end module Node mod
33. Establish pairs of logical named constants to replace the values of
.true. and . false . in cases where this will clarify the code.
There are situations where using the logical values .true. and . false . in your
code can lead to ambiguity. For example, in the following code, the Fortran
ﬂoating-point exception handling halting mode is turned off, a division is
performed, after which, the Fortran underﬂow ﬂag is tested. If an underﬂow
has occurred, the result is set to 0.0. Finally, the ﬂag is reset:
use ,
i n t r i n s i c
: :
IEEE Exceptions
use ,
i n t r i n s i c
: :
IEEE Features ,
only
: &
I E E E i n v a l i d f l a g ,
IEEE underflow flag
l o g i c a l
: :
f l a g
r e a l
: :
x ,
a ,
b
c a l l
IEEE Set halting mode
(IEEE UNDERFLOW, &
h a l t i n g = . f a l s e . )
x = a / b
c a l l
IEEE Get flag
(IEEE UNDERFLOW,
f l a g )
i f
( f l a g ) x = 0.0
c a l l
IEEE Set flag
(IEEE UNDERFLOW, &
f l a g v a l u e = . f a l s e . )
One may question if the ﬁnal line is setting the ﬂag to be signaling or quiet, its
two possible values. Here, four logical named constants are deﬁned and used:
use ,
i n t r i n s i c
: :
IEEE Exceptions
use ,
i n t r i n s i c
: :
IEEE Features ,
only
: &
I E E E i n v a l i d f l a g ,
IEEE underflow flag
Cambridge Books Online © Cambridge University Press, 2012

32
MODERN FORTRAN
l o g i c a l
: :
f l a g
r e a l
: :
x ,
a ,
b
l o g i c a l ,
parameter
: :
SIGNALING = . true . , &
QUIET = . f a l s e .
l o g i c a l ,
parameter
: : ON = . true . , OFF = . f a l s e .
c a l l
IEEE Set halting mode
(IEEE UNDERFLOW, &
h a l t i n g = OFF)
x = a / b
c a l l
IEEE Get flag
(IEEE UNDERFLOW,
f l a g )
i f
( f l a g == SIGNALING) x = 0.0
c a l l
IEEE Set flag
(IEEE UNDERFLOW,
f l a g v a l u e = QUIET)
34. Consider using a unique name or a limited number of names through-
out a program as the names of the value returned by a function.
In a large program, containing hundreds or even thousands of functions, you
or your programming team may ﬁnd it useful to always use a single name
or one of just a few names for the result variable in the result clause. This
can assist, especially in long procedures, in immediately identifying the object
returned when reviewing your own code or the code of a fellow programmer.
Use the term regardless of the type, be it intrinsic or derived, or the kind of
value returned. (An obvious disadvantage of doing this is that the name is less
descriptive than may be desirable [see Rule 129].)
function
C a l c v o r t i c i t y
( t h i s ,
method flag ) &
r e s u l t
( r e t u r n v a l u e )
type
( element t ) ,
intent
( in )
: :
t h i s
integer ,
intent
( in ) ,
optional
: :
method flag
r e a l
(WORKING PREC)
: :
r e t u r n v a l u e
. . .
end
function
C a l c v o r t i c i t y
function
S t a t e i s a c t i v e
()
r e s u l t
( r e t u r n v a l u e )
l o g i c a l
: :
r e t u r n v a l u e
end
function
S t a t e i s a c t i v e
function
Get employee
( employee name ) &
r e s u l t
( r e t u r n v a l u e )
character
(*) ,
intent
( in )
: :
employee name
type
( employee t )
: :
r e t u r n v a l u e
. . .
end
function
Get employee
Cambridge Books Online © Cambridge University Press, 2012

NAMING CONVENTIONS
33
When returning an array, consider using a plural name like return values .
function
G e t s a l a r i e d e m p l o y e e s
( t h i s ) &
r e s u l t
( r e t u r n v a l u e s )
type
( employee t ) ,
intent ( in )
: :
t h i s ( : )
type
( employee t ) ,
a l l o c a t a b l e
: :
r e t u r n v a l u e s ( : )
. . .
end
function
G e t s a l a r i e d e m p l o y e e s
A third suggestion is to remove the verb from the function name,
salaried employees or vorticity , for example.
35. Use common names for variables that represent accepted mathematic,
scientiﬁc, and engineering terms. Spell out the names of quantities whose
symbol is not part of the Fortran character set.
Programmers with the appropriate expertise will more easily be able to read
your code if you adhere to this rule. Those who are less familiar with the
subject will more easily be able to follow the code while referring to reference
material.
For example, in structural engineering the stress σ at a point along a loaded
beam is
σ = M z
I
(4.1)
where M is the bending moment, z is the distance from the neutral axis, and
I is the moment of inertia with respect to this axis (see Reference [65]). In
Fortran write this as
sigma = M * z /
I
Recall that you don’t want to try to distinguish names by case. Here the symbol
for the bending moment, M, is capitalized because that is the standard notation
used in structural engineering.
36. Consider beginning the names of all do, index, and subscript variables
using the letters “i” through “n.”
It is often the practice for Fortran programmers to begin the names of do
variables with the letters “i” through “n.” This is logical for a language used for
writing scientiﬁc and engineering software. The subscripts used in mathematics
for many operations such as summations are written using these letters, and
these subscripts become the do variable in loops.
As a legacy of premodern Fortran, if the implicit none statement is not
present in a program unit, the typing of entities is determined by what is
called “implicit typing.” In this method, all entities that begin with the letters
“i” through “n” are of type default integer; all others are of type default real.
Cambridge Books Online © Cambridge University Press, 2012

34
MODERN FORTRAN
As Rule 72 states, every program unit you write should contain an
implicit none statement. In modules, a single implicit none sufﬁces at the
beginning of the module for the procedures contained within it.
Beginning with Fortran 2003, as Rule 194 explains, do loop variables may not
be of type real or double precision. If you conﬁgure your compiler to conform
to the standard, it should detect any instances of nonconformance. If not so
conﬁgured, the compiler may not report this. In any case, if you begin all do
variables with the letters “i” through “n,” your program will always be correct
even if you ignore our implicit none recommendation. So, instead of writing:
do
c o l = 1 , ubound ( element grid ,
dim=2)
do row = 1 , ubound ( element grid ,
dim=1)
c a l l
Calc average temp
( e l e m e n t g r i d ( row ,
c o l )
)
end do
end do
write:
do
j c o l = 1 , ubound ( element grid ,
dim=2)
do
i r o w = 1 , ubound ( element grid ,
dim=1)
c a l l
Calc average temp
( e l e m e n t g r i d ( i row ,
j c o l )
)
end do
end do
4.4 Construct Blocks
37. Name all executable construct blocks with a name describing the pur-
pose of the construct.
To all block constructs that are more than a few lines long, names
should be added to all that allow them. These constructs are associate,
select case, do, if , select type, forall , and where. This is especially true
of nested do constructs. They are required if you wish to use either the
exit do-construct-name statement to exit from a speciﬁc do construct or
the cycle do-construct-name statement to loop to its beginning. Further-
more, Fortran 2008 allows exit from block constructs other than do constructs.
As with any name you provide, use the name to convey some information about
the program to the reader. Choose a name that describes the purpose of the
construct in the same manner that you choose a procedure name to describe
the purpose of a procedure (see Rule 11).
each column :
do k column = 1 ,
c o l u m n l i m i t
each row :
do
i r o w = 1 ,
r o w l i m i t
c a l l
Proc1
( i row ,
k e r r )
i f
( k e r r < 0)
then
e x i t
each column
e l s e
i f
( k e r r > 0)
then
Cambridge Books Online © Cambridge University Press, 2012

NAMING CONVENTIONS
35
cycle
each column
e l s e
. . .
end
i f
end do each row
end do each column
Also, where constructs may be nested, a compiler can give better diagnostics
if construct names appear at the end of the construct.
38. Always use optional names on end statements.
Several Fortran syntax forms in addition to constructs allow names on the
ﬁnal statement as an option. For example, you can write the type name at the
end of an end type statement, and when there are many components, doing
so better delineates them.
type ,
extends
( genus t ) ,
public
: :
s p e c i e t
! . . .
components
end type
s p e c i e t
39. Make liberal use of the associate construct.
In sections of code that include extensive use of both data and procedure
components, you can clarify your code to a great extent by using the associate
construct to assign them one-word names. For example, if you had this type
deﬁnition
type ,
public
: :
pt2d t
r e a l
: :
x ,
y
contains
procedure
: :
Get => G e t x c o o r d i n a t e
end type
pt2d t
and you had a long section of code in a subroutine with the following interface
subroutine
C a l c u l a t e v a l
( t h i s )
type
( pt2d t ) ,
intent
( in )
: :
t h i s
end subroutine
C a l c u l a t e v a l
the code will read much better if it is enclosed in an associate construct block
if there’s a long section of code in which there are numerous reference to the
x and y components of argument this, that is,
a = t h i s%x + b
e = t h i s%y + d
. . .
many more
r e f e r e n c e s
comp assign :
associate
( x=>t h i s%x ,
y=>t h i s%y )
a = x + b
e = y + d
. . .
many more
r e f e r e n c e s
end
associate
comp assign
Cambridge Books Online © Cambridge University Press, 2012

36
MODERN FORTRAN
In object-oriented code (see Chapter 11) this rule is even more applicable.
Here a new type pt3d t extends type pt2d t
type ,
public ,
extends ( pt2d t )
: :
pt3d t
r e a l
: :
z
end type
pt3d t
In code where the variable this is one of type pt3d t, you can easily have code
that is calling the type-bound binding Get of type pt2d t that looks like this:
coords = t h i s%pt2d t%Get
()
This is especially confusing. The entity this is a variable of type pt3d t; because
type pt3d t is extended from type pt2d t, the entity pt2d t is a component of
this; and Get is a type-bound procedure. Even if this is used only once, the
following nomenclature makes the code clearer:
associate
( comp 2d => t h i s%pt2d t )
coords = comp 2d%Get
()
end
associate
The following code snippet, taken from a program manipulating pieces on a
chess board, uses the associate construct advantageously:
comp assoc :
associate
( row => t h i s%row , &
column => t h i s%column )
i f
( row == t e s t r o w )
then
r e t u r n v a l u e = . true .
e l s e
!
t e s t
d i a g o n a l s .
c o l u m n d i f f e r e n c e = test column −column
i f
(
( row + c o l u m n d i f f e r e n c e == t e s t r o w ) &
. or .
( row −c o l u m n d i f f e r e n c e == t e s t r o w )
) &
r e t u r n v a l u e = . true .
end
i f
!
t h i s
queen
cannot
attack
a queen
at
t e s t r o w
/
!
test column ;
i n v e s t i g a t e
i f
i t s
neighbor
can .
i f
( . not .
r e t u r n v a l u e )
then
n e i g h b o r p o i n t e r => t h i s%neighbor
i f
(
associated
( n e i g h b o r p o i n t e r )
) &
r e t u r n v a l u e = n e i g h b o r p o i n t e r% &
Can attack
( test row ,
test column )
end
i f
end
associate
comp assoc
In the standard, the speciﬁcation for the aliasing is
associate-name=>selector
Cambridge Books Online © Cambridge University Press, 2012

NAMING CONVENTIONS
37
Be especially aware that, even though the => operator is used in both the
associate statement and in pointer assignments, the name assigned is not a
pointer; rather, it is an alias.
The selector can be a variable or an expression, such as a function. It can be
an array. It cannot be the name of a subroutine. Furthermore, the selector
can be allocatable, but, in this case, the associate name is not allocatable. The
same applies if the selector is a pointer; the associate-name does not acquire
the pointer attribute. This means that if you have the following derived type:
type ,
public
: :
element t
real ,
a l l o c a t a b l e
: :
r e a l a r r a y ( : )
end type
element t
you can use the following associate construct:
type
( element t )
: :
o b j e c t
. . .
associate
( r e a l i t e m => o b j e c t%r e a l a r r a y ( i ))
. . .
code
using
r e a l i t e m
end
associate
But the following code is not valid because real item is not allocatable:
type
( element t )
: :
o b j e c t
. . .
associate
( r e a l i t e m => o b j e c t%r e a l a r r a y ( i ))
i f
( allocated
( r e a l i t e m )
)
then
. . .
code
using
r e a l i t e m
end
i f
end
associate
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

5.
Documentation
Conventions
40. Write self-documenting code.
Well-written code, that which is written following the rules in Chapter 4,
documents itself. A person reading it can understand the operations the code
performs with little or no supplemental code documentation. It also passes the
“telephone test.” (See Rule 1.)
Here is an instructive example, one that uses an old graphics standard, the
Graphical Kernal System (GKS) from the 1980s that was used for creating two-
dimensional graphics (see Reference [34]). It demonstrates how the appropriate
naming of data entities and procedures produces code that documents itself.
The original language binding for GKS was FORTRAN 77. The members of
the standards committee that created it, constrained by the limitations of the
FORTRAN standard, were forced to develop a set of procedure names of six
characters or fewer in length. A further constraint was that the ﬁrst letter of all
procedures be the letter “G” and that the second letter represented a particular
action. The letter “S,” for example, was used for procedures that set the value
of an entity.
Here is a short section of code.
CALL GSWN (TRNNUM,XMINW,YPOSW+8.0 ,XMIN WINDOW,
+
YPOSW+8.0)
CALL GSVP (TRNNUM,XMINVP,XMAXVP,YMINVP,YMAXVP)
CALL GSELNT (TRNNUM)
CALL GSTXI (TXTIDX)
CALL GSCHH (0.8*CHH)
CALL GSTXP (RGTXP)
CALL GSCHUP (CHUX,CHUY)
CALL GSPLI ( LINIDX )
Only a person familiar with GKS or one who refers frequently to a GKS manual
would be able to understand this without supplemental documentation in the
form of comments.
Had modern Fortran been available when the standard was written, the code
might have looked like this:
c a l l
GKS Set window
( transform num ,
w i n d o w l i m i t d a t a )
38
Cambridge Books Online © Cambridge University Press, 2012

DOCUMENTATION CONVENTIONS
39
c a l l
GKS Set viewport
( transform num ,
v w p o r t l i m i t d a t a )
c a l l
GKS Set element trans matrix
( transform num )
c a l l
GKS Set text index
( t e x t i n d e x )
c a l l
GKS Set char height
(0.8* c h a r h e i g h t )
c a l l
GKS Set text path
(TEXT PATH RIGHT)
c a l l
GKS Set char up vector
( c h a r u p v e c t o r )
c a l l
G K S S e t p o l y l i n e i n d e x
( l i n e i n d e x )
where window limit data and vwport limit data are data objects of the follow-
ing type:
type
GKS limit
r e a l
: :
x min ,
x max ,
y min ,
y max
end type
GKS limit
and char up vector is one of this following type:
type
GKS vector
r e a l
: :
d e l t a x ,
d e l t a y
end type
GKS vector
The longer names clarify the purpose of the code. Additionally, the GKS
preﬁxes make it clear that the derived types and calls are intended for the GKS
library.
41. Add comments to your code to allow other programmers to understand
its purpose. It is especially important to explain what cannot be read from
the source text itself.
Writing code in adherence with the precepts of the previous rule makes its
operation clear. However, it does not necessarily explain the purpose of the
code; for this, you need to add supplementary documentation. Here is a code
example:
y sqrd
= y ht
** 2
eccen
= 1.0 + t h i s%con const
c u r v s q r d = ( t h i s%curv ) ** 2
d i s = 1.0 −eccen *
y sqrd
*
c u r v s q r d
i f
( d i s < 0 . 0 )
then
max radius = sqrt
( 1 . 0
/ ( eccen *
c u r v s q r d )
)
sag data
= s a g v a l u e s t
( y ht ,
max radius ,
0.0 , &
0.0 ,
0.0 ,
SAG YgtR )
e l s e
denom
= 1.0 DOUB PREC + sqrt
( d i s )
sag
= t h i s%curv *
y sqrd
/ denom
denom
= 1.0 DOUB PREC −t h i s%curv * eccen * sag
sag1By = Divide
( t h i s%curv ,
denom)
sag prime
= sag1by *
y ht
sag doub prime
= sag1by * &
( 1 . 0 DOUB PREC + sagP **2 * eccen )
Cambridge Books Online © Cambridge University Press, 2012

40
MODERN FORTRAN
max radius = HUGE DP
sag data
= s a g v a l u e s t
( y ht ,
max radius ,
sag , &
sag prime ,
sag doub prime , SAG SUCCESS)
end
i f
This code may or may not be clear to someone reading it – it would depend on
his or her familiarity with the program. Here is the same code with explanatory
comments added.
!
determine
the
p e r p e n d i c u l a r
d i s t a n c e
from
the
!
tangent
plane
to
the
conic
s u r f a c e
at
y ht
from
the
!
tangent
point .
( t h i s%con const = 0
f o r
sphere )
y sqrd
= y ht
*
y ht
eccen
= 1.0 + t h i s%con const
c u r v s q r d = ( t h i s%curv ) ** 2
d i s
= 1.0 −eccen *
y sqrd
*
c u r v s q r d
!
two
p o s s i b i l i t i e s :
!
SAG YgtR :
y ht > maximum h e i g h t
at
which
t h e r e
i s
an
!
i n t e r s e c t i o n −s e t
the
sag
and
the
f i r s t
!
and
second
d e r i v a t i v e s
to
0.0
! SAG SUCCESS :
o t h e r w i s e .
i f
( d i s < 0 . 0 )
then
max radius = sqrt
( 1 . 0
/ ( eccen *
c u r v s q r d )
)
sag data
= s a g v a l u e s t
( y ht ,
max radius ,
0.0 , &
0.0 ,
0.0 ,
SAG YgtR )
e l s e
!
compute
d i s t a n c e
( sag ) and 1 s t & 2nd
d e r i v a t i v e s
!
( sag prime ,
sag doub prime )
!
( use
l i b .
f u n c t i o n
Divide
to
trap
f l o a t i n g −point
!
problems . )
denom
= 1.0 + sqrt
( d i s )
sag
= t h i s%curv *
y sqrd
/ denom
denom
= 1.0 −t h i s%curv * eccen * sag
sag1By = Divide
( t h i s%curv ,
denom)
sag prime
= sag1by *
y ht
sag doub prime
= sag1by *
( 1 . 0 + sagP **2 * eccen )
max radius
= HUGE DP
sag data = s a g v a l u e s t
( y ht , HUGE DP,
sag , &
sag prime ,
sag doub prime , SAG SUCCESS)
end
i f
Cambridge Books Online © Cambridge University Press, 2012

DOCUMENTATION CONVENTIONS
41
42. Always synchronize the documentation with the code.
As you make changes to your code, an important, even crucial task is to update
any explanatory comments that describe it. Comments that do not agree with
the code, or even worse, contradict it, are extremely confusing.
43. Write a documentation block for every program unit.
You should include a general documentation section with every program,
module, submodule, and subprogram. It should comprise at least the following
items:
■A brief description of the function of the unit. This should be a few
sentences, at most, describing the purpose of the unit.
■The author.
■The date.
■A dated list of brief explanations of code revisions and their authors.
This explanation should be a general one. More speciﬁc descriptions, if
necessary, are better embedded in the code.
You also may want to include the following items:
■A description of the interface to the subprogram.
If you have chosen good names for the arguments, you need not list them;
they are self-documenting. Because the type and kind of arguments may
change, as may other attributes assigned to them, such as intent, optional, or
pointer, you need not document these here. Let their declarations, carefully
laid out, be the documentation.
■A version number.
This number would be a version number you or your project team have
adopted.
■A number used by the version control system used to maintain ﬁle updates.
This number would be the version number assigned by whatever program
you are using (such as CVS), if any, to synchronize and manage changes
to your code. You may want to include this as part of the revision list (see
Rule 5).
■The names of any references.
Mention here any texts, papers, or articles you are using as a basis for your
code. These might be the source of the algorithm, engineering or scientiﬁc
calculations, or a data structure you are using. List the chapters or sections
here, if applicable, but embed references to speciﬁc equations or calculations
in the code.
Here is an example:
subroutine
B i s e c t
( x ,
xP , xN ,
mode ,
max tries , &
z e r o c r i t )
r e a l
(WORK PREC) ,
intent
( in
out )
: :
x ,
xP , xN
integer ,
intent
( in
out )
: :
mode
integer ,
intent
( in ) ,
optional
: :
m a x t r i e s
r e a l
(WORK PREC) ,
intent
( in ) ,
optional
: :
z e r o c r i t
Cambridge Books Online © Cambridge University Press, 2012

42
MODERN FORTRAN
!−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
!
Purpose :
determine
the
next
point
at
which a
f u n c t i o n
!
should
be
evaluated
by
b i s e c t i n g
xN and xP .
!
Author : N.
S .
Clerman ,
Dec .
1983
!
R e v i s i o n s :
!
1) N.
S .
Clerman ,
Nov .
1984:
e r r o r
l o g g i n g
added
!
2) C. R.
Crawford ,
June
1987:
add
arguments
!
m a x t r i e s
and
z e r o C r i t .
save
i .
Add the
n e c e s s a r y
!
code .
!
Release :
5 2 . 4 . 3 i n t
!
Line
wrapped
because
of
space
l i m i t a t i o n s . CVS
w i l l
!
w r i t e
i t
on one
l i n e .
!
F i l e
Version :
$Id :
B i s e c t . f90 , v
1.26
2008/12/22
!
03:01:42
!
clerman Exp $
!
Args :
!
x −on
input :
the
c u r r e n t
point
at
which
the
f u n c t i o n
!
was
evaluated .
!
on
output :
the
next
point
at
which
the
f u n c t i o n
!
should
be
evaluated .
! xP , xN −x−v a l u e s
where
the
f u n c t i o n
i s
p o s i t i v e
and
!
negative ,
r e s p e c t i v e l y .
s e t
to
x on
entry
!
based on
the
value
of mode .
! mode −c o n t r o l
value
!
on
input :
!
mode = BISECT FIRST ENTRY
!
mode = BISECT NEG EVAL
!
−the
f u n c t i o n
at
x was
n e g a t i v e .
!
mode = BISECT POS EVAL
!
−the
f u n c t i o n
at
x was
p o s i t i v e .
!
on
output :
!
mode = BISECT FAILS
!
−max .
number
of
i t e r a t i o n s
exceeded .
!
mode = BISECT EVAL REQD
!
−e v a l u a t e
f u n c t i o n
at
x .
Cambridge Books Online © Cambridge University Press, 2012

DOCUMENTATION CONVENTIONS
43
!
mode = BISECT FINISHED
!
−convergence
!−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
!
. . .
type
d e c l a r a t i o n
and
s p e c i f i c a t i o n
statements
!
. . .
e x c u t a b l e
statements
end subroutine
B i s e c t
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

6.
Programming Principles
6.1 Standards Conformance
44. Always write standard-conforming code.
Adherence to no other guideline in this book will make your code more
portable than adhering to this one. Over the years, compiler vendors and
others have added numerous nonstandard extensions to the language. There is
no guarantee that every compiler will support them or that any given compiler
will continue to do so in the future.
When you write code that conforms to the standard, you can expect and
demand that a “standard-conforming” compiler will successfully compile it. If
it cannot, you have a good indication that either your code is in error, that it
does not conform to the standard, or that there is a problem with the compiler
itself. Most compilers can provide warning messages when encountering
nonstandard code. If possible, do not depend on a single compiler as a refer-
ence. Compiling code through several different vendors’ compilers can often
expose additional errors. (See also Rule 4 and Section 15.3.)
45. Do not rely on compiler switches that change code semantics.
Many compiler vendors have added switches to their compiler directives that
provide a capability that the programmer must otherwise provide by writing
code. Some compilers, for example, have a switch that will automatically
initialize all variables or change the default kinds of variables. Others have
switches that remove the necessity for explicitly including the implicit none
statement in every program unit. You should not use these; they make your
code nonportable.
6.2 Module Design
46. Order the statements in modules in a ﬁxed and consistent manner.
The standard dictates a speciﬁc ordering of statements in all program units.
(See Reference [39].) For consistency, it is best to further arrange the order of
the various elements. A general scheme is:
module module-name
alphabetical sequence of use statements of the following form:
use module-name , only : only-list
implicit none
44
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
45
private
protected :: access-id-list
public :: access-id-list
declaration of named constants
derived type deﬁnitions
interfaces
variables whose scope is the entire module
contains
alphabetical ordering of all module procedures, both public and private.
end module module-name
Here is an example:
module Rect mod
use Object mod ,
only
:
o b j e c t t
use Point mod ,
only
:
p o i n t t
use
Sys kinds mod
i m p l i c i t
none
private
public
: :
Comp area ,
I n i t
c a l l s
type ,
extends
( o b j e c t t ) ,
public
: :
r e c t t
private
r e a l
(WORKING PREC)
: :
dimensions (2)
type
( p o i n t t )
: :
c e n t e r
contains
procedure
: :
Comp area => Comp area rect
end type
r e c t t
i n t e r f a c e
I n i t C a l l s
module procedure
I n i t
c a l l s
r e c t
end
i n t e r f a c e
!
monitor
the
number
of
c a l l s .
integer ,
protected
: :
n u m b e r o f a r e a c a l l s = 0
contains
elemental
function
Comp area rect
( t h i s ) &
r e s u l t
( r e t u r n v a l u e )
c l a s s
( r e c t t ) ,
intent
( in )
: :
t h i s
r e a l
(WORKING PREC)
: :
r e t u r n v a l u e
r e t u r n v a l u e = t h i s%dimensions (1)
* &
t h i s%dimensions (2)
n u m b e r o f a r e a c a l l s = n u m b e r o f a r e a c a l l s + 1
end
function
Comp area rect
Cambridge Books Online © Cambridge University Press, 2012

46
MODERN FORTRAN
subroutine
I n i t
c a l l s
r e c t
()
n u m b e r o f a r e a c a l l s = 0
end subroutine
I n i t
c a l l s
r e c t
end module Rect mod
47. Place data objects that require global accessibility in modules.
Module-scope variables have the public attribute by default. They can be both
read and updated by any user of the module. While convenient, numerous
problems can result: The variables are visible outside the module, thus violating
the concept of “information hiding.” The names may conﬂict with those from
other modules. And ﬁnally, an errant user of a module variable may update
it in unexpected manner, potentially causing unexpected program behavior.
Alternatively, variables may be given the private attribute, and public accessor
procedures may be written, similar to those that allow access to the private
components of public derived types (see Rule 135).
Using the protected attribute, you can give public “read only” access to a
module variable, allowing only procedures within the module to actually
update the variable. A public accessor procedure can be written to provide
uniﬁed services such as assigning values, verifying data correctness, and logging
updates for debugging purposes. Here is a module that sets state variables for
program debugging:
module Debug state mod
use
state mod ,
only
:
FAILURE , FATAL, INFO , &
NO LEVEL , OFF, ON, SUCCESS , WARN
i m p l i c i t
none
private
public
: :
S e t d e b u g s t a t e
integer ,
protected
: :
debug state = OFF, &
d e b u g l e v e l = NO LEVEL
contains
subroutine
S e t d e b u g s t a t e
( new state ,
r e t u r n s t a t )
integer ,
intent
( in )
: :
new state
integer ,
intent
( out )
: :
r e t u r n s t a t
i f
( new state == ON . or .
new state == OFF)
then
debug state = new state
r e t u r n s t a t = SUCCESS
e l s e
r e t u r n s t a t = FAILURE
end
i f
end subroutine
S e t d e b u g s t a t e
. . .
end module Debug state mod
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
47
Note that the save attribute was not explicitly speciﬁed; the variables
debug state and debug level both possess this attribute by virtue of their
being initialized in their declarations.
A stipulation in the standard pertaining to modules is that the module-scope
variables within them are allowed to become undeﬁned when no module or
procedure using their containing module (for example, via a use statement) is
active. To ensure that the contents of such a module does not inadvertently go
out of scope, the module should either be used in the main program, or the
save attribute should be speciﬁed for the entire module, accomplished using a
simple save statement. The Fortran 2008 standard speciﬁes that module-scope
variables possess the save attribute by default (see Rule 75).
48. Include a default private statement in the speciﬁcation section of all
modules. Provide either public or read-only access to module entities on
an as-needed basis.
The default access for entities in modules is public. It is preferable to limit
access to only those items that other program units need via use association.
This is done by either listing them in public or protected statements or
by specifying one of these two attributes in deﬁnitions such as derived-type
deﬁnitions. Provide this access solely to those entities that are deﬁned in the
module. This reduces the possibilities of naming conﬂicts with items in other
modules. Use this rule and the rule for using the only option to maintain strict
control over access to all module entities (see Rules 49 and 135).
Here are skeleton outlines of three modules:
module A mod
i m p l i c i t
none
private
public
: :
Proc a1
contains
subroutine
Proc a1
( arg a1 )
real ,
intent
( in
out )
: :
arg a1
. . .
end subroutine
Proc a1
end module A mod
module B mod
use A mod ,
only
:
Proc a1
i m p l i c i t
none
private
public
: :
Proc b1
contains
subroutine
Proc b1
( arg b1 )
real ,
intent
( in
out )
: :
arg b1
. . .
c a l l
Proc a1
( arg b1 )
Cambridge Books Online © Cambridge University Press, 2012

48
MODERN FORTRAN
. . .
end subroutine
Proc b1
end module B mod
module C mod
use B mod ,
only
:
Proc b1
i m p l i c i t
none
private
public
: :
Proc c1
contains
subroutine
Proc c1
( arg c1 ,
arg c2 )
integer ,
intent
( in
out )
: :
arg c1
real ,
intent
( out )
: :
arg c2
. . .
c a l l
Proc b1
( arg c2 )
. . .
end subroutine
Proc c1
end module C mod
Note that the subroutine Proc a1 is not made public in module B mod. If
in module C mod it was necessary to call it from subroutine Proc c1, C mod
should explicitly use it as shown here:
module C mod
use A mod ,
only
:
Proc a1
use B mod ,
only
:
Proc b1
i m p l i c i t
none
private
public
: :
Proc c1
contains
subroutine
Proc c1
( arg c1 ,
arg c2 )
integer ,
intent
( in
out )
: :
arg c1
real ,
intent
( out )
: :
arg c2
. . .
c a l l
Proc b1
( arg c2 )
. . .
c a l l
Proc a1
( arg c2 )
. . .
end subroutine
Proc c1
end module C mod
The contents of some categories of modules make the inclusion of the private
statement optional. One example is a module that contains only named con-
stants. The program cannot modify the values of named constants, so it is
logical to allow all items in a module such as this to have the default public
attribute.
module
Global par mod
i m p l i c i t
none
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
49
integer ,
parameter
: : MAX EMPLOYEES = 20000
real ,
parameter
: :
MAX PAY RATE
= 75.00
end module
Global par mod
A second category is a module whose sole purpose is to provide the interface
to procedures, such as this example (see Rule 122):
module
Interface mod
i m p l i c i t
none
i n t e r f a c e
subroutine
Sub a
( arg a1 ,
arg a2 ,
arg a3 )
real ,
intent
( in )
: :
arg a1
real ,
intent
( in
out )
: :
arg a2
l o g i c a l ,
intent
( in ) ,
optional
: :
arg a3
end subroutine
Sub a
function
Func b
( arg b1 )
r e s u l t
( r e t u r n v a l u e )
integer ,
intent
( in )
: :
arg b1
integer
: :
r e t u r n v a l u e
end
function
Func b
end
i n t e r f a c e
end module
Interface mod
In this case, the module’s purpose is to provide the interface information to
those program units that need it, and there is no reason to make any of this
information private. Bear in mind, however, that there could be a naming
conﬂict in program units where modules such as these are used. In that case,
if the accessibility of all entities in the module is public, the only option may
be needed, or the public entity may have to be renamed.
use
interface mod ,
Comp Func b => Func b
49. Use the only option in use statements.
Application of this guideline in conjunction with the use of the private
attribute, as explained in Rule 48, provides complete control over the access to
module entities. Each module then has a directory of the references made to
entities in other modules along with their location. Except for possible naming
conﬂicts, there is no reason to use the only option with modules whose default
access is public. As explained in the Rule 48, these would be modules that
contain only named constants or interfaces.
One drawback of applying this rule is that its use could possibly increase the
work involved in maintaining a program. Here is a use statement that provides
access in B mod to entity var a in module A mod. If, for some reason, you
have to move variable var a from module A mod to another module, every
use statement like this in the program needs to be changed:
Cambridge Books Online © Cambridge University Press, 2012

50
MODERN FORTRAN
module B mod
. . .
use A mod ,
only
:
v a r a
. . .
end module B mod
6.3 Procedure Arguments
50. Indicate the intent of all dummy arguments.
Indicating the intent of all the dummy arguments of a procedure aids the com-
piler in discovering errors in your program. The compiler can verify that values
are not assigned to arguments that have the intent (in) attribute. Further-
more, if a dummy argument with intent (in) is used as an actual argument
to another subprogram, and if the code provides access to that subprogram’s
interface, the compiler can issue an error message if the corresponding dummy
argument in the called procedure is not also intent (in). Similarly, the com-
piler can warn if no value is assigned to a dummy argument of intent (out),
or if the calling procedure passed a constant value, an expression result, or a
procedure reference as the actual argument.
When the dummy argument has attribute intent (out) and it is a derived type,
the program will initialize all components as speciﬁed in the type deﬁnition.
Note that when the procedure is called, the actual argument will be ﬁnalized
before the call if it is a derived type for which a ﬁnal procedure exists. In a
like manner, if the actual argument is an allocatable variable or a derived type
containing allocatable components, the allocatable entities will be deallocated
before the procedure is called (see Rules 53, 136, and 147 and Section 7.2.1).
When the intent attribute of a dummy argument is not speciﬁed, the implied
intent is similar to intent (in out) with an important difference: When
intent (in out) is speciﬁed, the actual argument must be “deﬁnable,” mean-
ing it could appear on the left side of an assignment statement. The program
that follows demonstrates this. In module Mod a mod, at location *Cmnt-1
in subroutine Set all good calls, there are alternative declarations of the argu-
ment calls, one with an intent (in out) and one without, which also bestows
the attribute intent (in out). There is a call to this subroutine in the main
program Intent exp imp at the location marked *Cmnt-2. The actual argument
is a reference to function Get good calls ; it is not deﬁnable.
Listing 6.1: Program Intent exp imp
module Mod a mod
i m p l i c i t
none
private
public
: :
S e t a l l g o o d c a l l s
integer
: :
a l l g o o d c a l l s = 0
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
51
contains
subroutine
S e t a l l g o o d c a l l s
( c a l l s )
!
*Cmnt−1
!
with
i n t e n t :
the
a c t u a l
argument must be
!
d e f i n a b l e .
!
i n t e g e r ,
i n t e n t
( i n
out )
: :
c a l l s
!
without
i n t e n t :
the
a c t u a l
argument
need
not
be
!
d e f i n a b l e .
integer
: :
c a l l s
a l l g o o d c a l l s = a l l g o o d c a l l s + c a l l s
c a l l s = 0
end subroutine
S e t a l l g o o d c a l l s
end module Mod a mod
module Mod b mod
i m p l i c i t
none
private
public
: :
Get probe reading ,
G e t g o o d c a l l s
enum ,
bind (C)
enumerator
: : GOOD PROBE=0, BAD PROBE
end enum
integer ,
save
: :
s e r i e s g o o d c a l l s
contains
subroutine
G e t p r o b e r e a d i n g
( probe reading , &
n e w s e r i e s )
real ,
intent
( out )
: :
p r o b e r e a d i n g
l o g i c a l ,
intent
( in )
: :
n e w s e r i e s
integer
: :
i s t a t = GOOD PROBE
!
f o r
demonstration ,
r e t u r n
a
f i x e d
number .
i f
( n e w s e r i e s ) &
s e r i e s g o o d c a l l s = 0
p r o b e r e a d i n g = 6.5
i f
( i s t a t == GOOD PROBE) &
s e r i e s g o o d c a l l s = s e r i e s g o o d c a l l s + 1
end subroutine
G e t p r o b e r e a d i n g
function
G e t g o o d c a l l s
()
r e s u l t
( r e t v a l )
integer
: :
r e t v a l
r e t v a l = s e r i e s g o o d c a l l s
end
function
G e t g o o d c a l l s
end module Mod b mod
Cambridge Books Online © Cambridge University Press, 2012

52
MODERN FORTRAN
program
I n t e n t e x p i m p
use Mod a mod ,
only : S e t a l l g o o d c a l l s
use Mod b mod ,
only : Get probe reading ,
G e t g o o d c a l l s
i m p l i c i t
none
!
f o r
demonstration ,
s e t
a
f i x e d
number
of
c a l l s
integer ,
parameter
: :
NUMBER OF CALLS = 5
integer
: :
i t o t c n t
r e a l
: :
p r o b e r e a d i n g
c a l l
G e t p r o b e r e a d i n g
( probe reading ,
. true . )
do
i t o t c n t = 2 , NUMBER OF CALLS
c a l l
G e t p r o b e r e a d i n g
( probe reading ,
. f a l s e . )
end do
!
*Cmnt−2
!
a c t u a l
argument
i s
u n d e f i n a b l e
c a l l
S e t a l l g o o d c a l l s
( G e t g o o d c a l l s
()
)
write
(* , ” (2(A,
I0 )) ” ) ”Good
c a l l s :
” , &
G e t g o o d c a l l s
( ) ,
”
t o t a l
c a l l s :
” ,
i t o t c n t −1
end program
I n t e n t e x p i m p
A good compiler will spot these differences. As an example, version 5.3 of the
Numerical Algorithm Group’s (NAG) compiler generates the following error
message when the intent is explicitly speciﬁed:
Error: intent_exp_impP.f90, line 68: Argument CALLS (no. 1)
of SET_ALL_GOOD_CALLS is INTENT(OUT) or INTENT(INOUT) but
is not a variable
When the intent is not explicitly speciﬁed, the compiler builds the program,
not issuing any error messages, but it generates the following runtime error
message when executed:
Runtime Error: intent_exp_impP.f90, line 18: Dummy argument
CALLS is associated with an expression - cannot assign Program
terminated by fatal error
Another point arises in the following instance, one connected to deﬁnable
objects: When you enclose parentheses around a simple variable, constant
value, or named constant, you are creating an expression; as such, it’s not
deﬁnable. In its simplest form, you can place just a single variable inside
parentheses. Here are two calls to a subroutine. In the ﬁrst, the argument is a
variable called int arg ; in the second, the argument is an expression.
c a l l
Sub c
( i n t a r g )
. . .
c a l l
Sub c
(
( i n t a r g )
)
The ﬁrst call to Sub c is correct. If the interface to procedure Sub c is available,
and the intent assigned to the dummy argument is intent (in out), a good
compiler will ﬂag the second call as an error, which it is according to the
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
53
standard. If the interface does not specify an intent, the standard states the call
to Sub c is correct. However, if the procedure attempts to redeﬁne the
argument, an error at runtime is likely to occur.
Be aware that Fortran 2003, unlike Fortran 90 and Fortran 95, allows the
intent attribute to be speciﬁed for dummy arguments that are pointers (see
Rule 55). The intent refers to the association status of the pointer, not to its
target. A ﬁnal point on intent is that if the argument is a derived type with
pointer components, the intent applies to the type object itself, not the targets
of the pointers. That is, if, for example, intent (in) is used, the data area that
the pointer is targeted at can be modiﬁed:
module Mytype mod
i m p l i c i t
none
type
mytype t
integer ,
pointer
: :
i n t p ( : )
contains
procedure
: :
Sub => Mytype sub
end type
mytype t
contains
subroutine
Mytype sub
( t h i s )
c l a s s
( mytype t ) ,
intent ( in )
: :
t h i s
!
Legal
assignment
to
p o i n t e r
target ,
even
though
!
i n t e n t ( i n ) was
s p e c i f i e d .
t h i s%i n t p = 42
end subroutine
Mytype sub
end module Mytype mod
program Mytype
use Mytype mod
i m p l i c i t
none
type ( mytype t )
: :
my mytype
integer
: :
a l s t a t
a l l o c a t e
( integer
: :
my mytype%i n t p (100) , &
stat=a l s t a t )
c a l l
my mytype%Sub
()
end program Mytype
Even though not required, in a case such as the previous example, it is better
to state intent (in out) to indicate to the reader that modiﬁcation of data is
taking place.
51. In functions, specify the intent of all dummy arguments as
intent (in).
The purpose of Fortran functions is to return a value based on the value of
its arguments (if there are any). The function should not cause side effects
Cambridge Books Online © Cambridge University Press, 2012

54
MODERN FORTRAN
by altering their value. You can ensure this will not occur by declaring all
dummy arguments intent (in). Use a subroutine instead of a function if
an argument needs to be modiﬁed. The standard mandates that you declare
all dummy arguments of a pure function to be intent (in). Otherwise, a
standard-conforming compiler will not compile it (see Section 6.6 and Rule
52). Here is an example of a routine written counter to this rule. It calls a
function that returns a value in one of its arguments. Following it is code that
calls the function:
module Calc mod
i m p l i c i t
none
private
public
: :
C a l c r e s u l t ,
CALL FOO 1 ,
CALL FOO 2 , &
CALL FUNC 1 ,
CALL FUNC 2 , TERMINATE
integer ,
parameter
: :
CALL FOO 1 = 1 , &
CALL FOO 2 = −1, CALL FUNC 1 = 1 , &
CALL FUNC 2 = −1, TERMINATE = 0
contains
function
C a l c r e s u l t
( i s t a t e ,
a ) &
r e s u l t
( r e t u r n v a l u e )
integer ,
intent
( in
out )
: :
i s t a t e
real ,
intent
( in )
: :
a
r e a l
: :
r e t u r n v a l u e
r e a l
: :
o l d a
real ,
parameter
: :
EPS = 5.0
*
tiny
( 1 . 0 )
o l d a = a
i f
( i s t a t e == CALL FOO 1)
then
r e t u r n v a l u e = Foo 1
( a )
e l s e
i f
( i s t a t e == CALL FOO 2)
then
r e t u r n v a l u e = Foo 2
( a )
end
i f
i f
( abs
( o l d a −r e t u r n v a l u e ) < eps )
then
i r e t = TERMINATE
e l s e
i f
(
( r e t u r n v a l u e > 0.0
. and .
o l d a > 0 . 0 ) &
. or .
( r e t u r n v a l u e < 0.0
. and .
o l d a < 0 . 0 ) )
then
i s t a t e = CALL FUNC 2
e l s e
i s t a t e = CALL FUNC 1
end
i f
end
function
C a l c r e s u l t
end module Calc mod
. . .
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
55
use Calc mod ,
only
:
C a l c r e s u l t ,
CALL FOO 1 , &
CALL FOO 2 ,
CALL FUNC 1 ,
CALL FUNC 2
integer ,
parameter
: :
NO OF VALS = 10
r e a l
: :
new val ,
x (NO OF VALS)
integer
: :
i f l a g ,
j
i t e r
x = 0.0
e a c h v a l :
do
j
i t e r = 1 , NO OF VALS
new val = 0.0
i
f l a g
= CALL FOO 1
make val :
do
new val = C a l c r e s u l t
( x ( j
i t e r ) ,
i
f l a g )
s e l e c t
case
( i
f l a g )
case
(CALL FUNC 1)
x ( j
i t e r ) = Func 1
( new val )
i
f l a g
= CALL FOO 1
case
(CALL FUNC 2)
x ( j
i t e r ) = Func 2
( new val )
i
f l a g
= CALL FOO 2
case
default
e x i t
e a c h v a l
end
s e l e c t
end do make val
end do
e a c h v a l
This should not be done. Two possible methods can be used to change this:
The ﬁrst is to change the function Calc result to a subroutine. Its interface
and a call would then be:
subroutine
C a l c r e s u l t
( i s t a t e ,
a ,
new a )
integer ,
intent
( in
out )
: :
i s t a t e
real ,
intent
( in )
: :
a
real ,
intent
( out )
: :
new a
end subroutine
C a l c r e s u l t
. . .
c a l l
C a l c r e s u l t
( i s t a t e ,
x ( j
i t e r ) ,
new val )
If you wish to retain the use of a function call, which is very suited to use
of forall and where statements and constructs, you can deﬁne a derived data
type that contains both the returned value and the ﬂag (see Rule 59):
type
r e s u l t t
r e a l
: :
new a
integer
: :
i s t a t e
end type
r e s u l t t
The interface to the procedure Calc result and the code in the calling proce-
dure would be:
Cambridge Books Online © Cambridge University Press, 2012

56
MODERN FORTRAN
function
C a l c r e s u l t
( a )
r e s u l t
( r e t u r n v a l u e )
real ,
intent
( in )
: :
a
type
( r e s u l t t )
: :
r e t u r n v a l u e
end
function
C a l c r e s u l t
. . .
type
( r e s u l t t )
: :
new res
new res = C a l c r e s u l t
( x ( j
i t e r ))
!
branch
based on
the
value
returned
in
!
new res%i s t a t e
52. Whenever possible, write procedures such that they can be preﬁxed by
the pure preﬁx.
The Fortran 95 standard introduced the pure preﬁx that can be attached to
subprograms (see Reference [42]). The constraints attached to a pure subpro-
gram ensure that the subprogram will not have side effects. They do this by
requiring the intent of all function dummy arguments to be intent (in) (see
Rule 51); by stipulating that a pure subprogram not make any assignments to
any entities whose scope is not the subprogram itself (but could be accessed by
it via host or use association, either directly or via arguments that are pointers or
have pointer components); and by dictating that the subprogram not perform
any external input/output operations or the stop operation. Furthermore, the
standard also states that local variables shall not have the save attribute (see
Rule 128). (Elemental procedures are a special case of pure procedures [see Rule
128].) Here is a pure function that calculates the distance between two points:
type
p o i n t t
r e a l
: :
x ,
y
end type
p o i n t t
pure
function
C a l c d i s t
( pt 1 ,
pt 2 ) &
r e s u l t
( r e t u r n v a l u e )
type
( p o i n t t ) ,
intent
( in )
: :
pt 1 ,
pt 2
r e a l
( kind
( pt 1%x ))
: :
r e t u r n v a l u e
r e t u r n v a l u e = sqrt
(
( pt 2%y −pt 1%y ) ** 2 + &
( pt 2%x −pt 1%x ) ** 2)
end
function
C a l c d i s t
Many compilers provide optimization switches that will optimize your code
or permit it to run in parallel on multiple processors and processors that have
multiple processing cores. The pure attribute assists the compiler in doing this.
This is especially so in forall statements and constructs. In the following code
snippet, knowledge that the function Calc dist is pure will allow the compiler
to distribute the assignments to multiple processors or processor cores.
integer ,
parameter
: :
NO OF POINTS = 20
type
( p o i n t t )
: :
p t a r r a y (NO OF POINTS) ,
b a s e p o i n t
r e a l
: :
d i s t s (NO OF POINTS)
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
57
integer
: :
i
f o r a l l
( i = 1:
ubound ( pt array ,
dim=1)) &
d i s t s ( i ) = C a l c d i s t
( base point ,
p t a r r a y ( i ))
In Fortran 2008, pure subprograms become especially useful in the
do concurrent construct. Designed for parallel processing, this construct is
similar to forall : It speciﬁcally permits the program to execute a loop in
any order, but adds the restriction, among others, that all procedure refer-
ences within the construct be to pure procedures (see Reference [43] and
Rule 168).
The Fortran 2008 standard introduces impure subprograms, relaxing the
restriction that they be pure. In subprograms so deﬁned, input and output is
permitted. You use the keyword impure in the subprogram speciﬁcation.
53. Use caution when specifying derived-type dummy arguments with the
intent (out) attribute.
If derived-type components are initialized in the type deﬁnition, and a dummy
argument of that type is speciﬁed to have the intent (out) attribute, the
non-pointer components of the derived type are initialized upon entry to
the procedure. Conversely, the components of dummy arguments with the
intent (out) attribute are not initialized if no such initialization is speciﬁed in
the component deﬁnition; they become undeﬁned on entry to the procedure.
If care is not taken, both of these situations can cause problems.
Here, in very abbreviated form, are two modules and a main program that
make up part of an investment portfolio program:
Listing 6.2: Program Intent out test
module Equity mod
i m p l i c i t
none
private
public
: :
Calculate ,
Get active ,
Get quote ,
Print
type ,
public
: :
e q u i t y t
!
a c t i v e :
i n d i c a t e
i f
stock
i s
v o l a t i l e .
l o g i c a l
: :
a c t i v e = . f a l s e .
r e a l
: :
c u r r e n t p r i c e = 1.0
integer
: :
n o o f s h a r e s
= 0
end type
e q u i t y t
i n t e r f a c e
C a l c u l a t e
module procedure
C a l c e q u i t y
end
i n t e r f a c e
C a l c u l a t e
Cambridge Books Online © Cambridge University Press, 2012

58
MODERN FORTRAN
i n t e r f a c e
Print
module procedure
P r i n t e q u i t y
end
i n t e r f a c e
Print
contains
elemental
function
C a l c e q u i t y
( t h i s ) &
r e s u l t
( r e t u r n v a l )
type
( e q u i t y t ) ,
intent
( in )
: :
t h i s
r e a l
: :
r e t u r n v a l
r e t u r n v a l = t h i s%c u r r e n t p r i c e
*
t h i s%n o o f s h a r e s
end
function
C a l c e q u i t y
elemental
function
G e t a c t i v e
( t h i s ) &
r e s u l t
( r e t u r n v a l )
type
( e q u i t y t ) ,
intent
( in )
: :
t h i s
l o g i c a l
: :
r e t u r n v a l
r e t u r n v a l = t h i s%a c t i v e
end
function
G e t a c t i v e
subroutine
Get quote
( t h i s )
!
c a l l
code
to
obtain
o n l i n e
quotation .
!
s e t
a c t i v e
t r u e
i f
no .
of
s h a r e s
traded
exceeds
a
!
t h r e s h o l d .
type
( e q u i t y t ) ,
intent
( out )
: :
t h i s
!
s i m p l i f i e d
code
to show
i n t e n t
( out )
problem
t h i s%a c t i v e = . true .
t h i s%c u r r e n t p r i c e = 10.0
end subroutine
Get quote
subroutine
P r i n t e q u i t y
( t h i s )
type
( e q u i t y t ) ,
intent
( in )
: :
t h i s
write
(* , ” (A,
L1 ) ” ) ” Active
i s
” ,
t h i s%a c t i v e
end subroutine
P r i n t e q u i t y
end module Equity mod
module Account mod
use
equity mod ,
only
:
Calculate ,
e q u i t y t ,
Get quote
i m p l i c i t
none
private
public
: :
Calc account ,
Get quotes
integer ,
parameter
: :
MAX EQUITIES = 3
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
59
type ,
public
: :
account t
type
( e q u i t y t )
: :
e q u i t i e s (MAX EQUITIES)
! . . . components
with
other
account
i n f o r m a t i o n
end type
account t
contains
subroutine
Calc account
( t h i s )
!
i n t e n t
( out )
causes
problems .
type
( account t ) ,
intent
( out )
: :
t h i s
r e a l
: :
temp value
integer
: :
i e q u i t y
do
i e q u i t y = 1 ,
s i z e
( t h i s%e q u i t i e s )
temp value = C a l c u l a t e
( t h i s%e q u i t i e s ( i e q u i t y )
)
end do
end subroutine
Calc account
subroutine
Get quotes
( t h i s )
type
( account t ) ,
intent
( in
out )
: :
t h i s
integer
: :
i e q u i t y
do
i e q u i t y = 1 ,
s i z e
( t h i s%e q u i t i e s )
c a l l
Get quote
( t h i s%e q u i t i e s ( i e q u i t y )
)
end do
end subroutine
Get quotes
end module Account mod
program
I n t e n t o u t t e s t
use account mod ,
only
:
account t ,
Calc account , &
Get quotes
use
Equity mod ,
only
:
Get active ,
Print
i m p l i c i t
none
type
( account t )
: :
account
integer
: :
i e q u i t y
c a l l
Get quotes
( account )
do
i e q u i t y = 1 ,
s i z e
( account%e q u i t i e s )
i f
( G e t a c t i v e
( account%e q u i t i e s ( i e q u i t y )
)
) &
c a l l
Print
( account%e q u i t i e s ( i e q u i t y )
)
end do
!
does
not
work .
c a l l
Calc account
( account )
do
i e q u i t y = 1 ,
s i z e
( account%e q u i t i e s )
i f
( G e t a c t i v e
( account%e q u i t i e s ( i e q u i t y )
)
) &
Cambridge Books Online © Cambridge University Press, 2012

60
MODERN FORTRAN
c a l l
Print
( account%e q u i t i e s ( i e q u i t y )
)
end do
end program
I n t e n t o u t t e s t
In the main program, the loop following the reference to function Calculate
will not work correctly. Here is the output of the program:
Active is T
Active is T
Active is T
Only the values of the ﬁrst loop, not the second, appear. The culprit
is the intent (out) of subprogram Calc account in Account mod. This
attribute forces component active of all the elements of component array
account%equities to acquire their initialization value of . false ..
A programmer most likely would ﬁnd this error easily because the program
simply would not operate as required. A more insidious error could occur if
component active were not initialized in the type declaration of derived type
equity t . In this case, according to the standard, the component active would
become undeﬁned when Calculate was called, and you could not rely on its
maintaining the correct value in the second set of loops. However, it would be
likely that it would retain the value set in Get quotes; the compiler would not
generate code that would change it, and, therefore, subroutine Print would
be called as expected. But this may not be the case for all compilers or, for a
particular compiler, the behavior may vary according to the compiler options
set. The easiest way to avoid such problems is to assign the intent (in out)
attribute to the dummy argument in place of intent (out) (see Reference [17]
and Rule 86).
54. When appropriate, assign the value attribute to dummy arguments
to allow their values to change without affecting the value of the actual
argument.
The value attribute forces the compiler to pass an actual argument “by value”
and not, as is usually done in Fortran, “as if by reference.” The primary motiva-
tion for the addition of this feature is for interoperability with C (see Chapter
14). This capability, however, can be effectively used for other purposes. The
following code is a simple example. It is the skeleton of a subroutine that moves
a cutting tool to a part. The increment by which the tool is moved is dummy
argument inc, and the value of the actual argument should not change. This
is achieved using the value attribute.
module Tool mod
use
Error codes mod ,
only
: SUCCESS ,
FAIL
use Part mod ,
only
:
p a r t t
i m p l i c i t
none
private
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
61
type ,
public
: :
t o o l t
r e a l
: :
l o c a t i o n (3) = 0.0
integer
: :
move status = FAIL
contains
procedure
: :
M o v e t o o l t o p a r t
procedure
: :
Move tool
end type
t o o l t
contains
subroutine
M o v e t o o l t o p a r t
( t h i s ,
part ,
inc ,
tol , &
m a x i t e r s )
c l a s s
( t o o l t ) ,
intent
( in
out )
: :
t h i s
type
( p a r t t ) ,
intent
( in )
: :
part
real ,
intent
( in ) ,
value
: :
i n c (3)
real ,
intent
( in )
: :
t o l
integer ,
intent
( in )
: :
m a x i t e r s
!
i t e r −i t e r a t i o n
counter
!
d i s t a n c e −c u r r e n t
d i s t a n c e
of
t o o l
from
the
!
part
t o o l −working
copy
of
t h i s
integer
: :
i t e r
r e a l
: :
d i s t a n c e (3)
r e a l
: :
hypot sqrd ,
t o t a l d i s t
type
( t o o l t )
: :
t o o l
i n t e r f a c e
subroutine
Change inc
( inc ,
d i s t a n c e )
real ,
intent
( in
out ) ,
value
: :
i n c (3)
real ,
intent
( in ) ,
: :
d i s t a n c e (3)
end subroutine
Change inc
end
i n t e r f a c e
t o o l%l o c a t i o n = t h i s%l o c a t i o n
l o o p t o s o l u t i o n :
do
i t e r = 1 ,
m a x i t e r s
c a l l
Move tool
( t h i s ,
i n c )
d i s t a n c e
= C a l c t o o l p a r t d i s t a n c e
( tool ,
part )
hypot sqrd = dot product
( distance ,
d i s t a n c e )
t o t a l d i s t = sqrt
( hypot sqrd )
i f
( abs
( t o t a l d i s t ) <= t o l )
then
t o o l%move status = SUCCESS
t h i s%l o c a t i o n
= t o o l%l o c a t i o n
e x i t
l o o p t o s o l u t i o n
e l s e
i f
( i t e r >= m a x i t e r s )
then
t h i s%move status = FAIL
e x i t
l o o p t o s o l u t i o n
end
i f
Cambridge Books Online © Cambridge University Press, 2012

62
MODERN FORTRAN
c a l l
Change inc
( inc ,
d i s t a n c e )
end do
l o o p t o s o l u t i o n
end subroutine
M o v e t o o l t o p a r t
subroutine
Move tool
( t h i s ,
i n c )
c l a s s
( t o o l t ) ,
intent
( in
out )
: :
t h i s
real ,
intent
( in )
: :
i n c (3)
t h i s%l o c a t i o n = t h i s%l o c a t i o n + i n c
end subroutine
Move tool
end module Tool mod
55. Be attentive to the particular standard speciﬁcations regarding argu-
ments possessing either the pointer or the target attribute.
Using dummy and actual arguments that possess either the pointer or target
attribute can be confusing. To clarify their use, this rule explains the program
behavior when a dummy argument possesses the pointer attribute, and Rule
56 details the behavior when it possesses the target attribute.
The explanation is ﬁrst divided into two major sections: the ﬁrst when the
dummy argument has the pointer attribute, the second when it is assigned
solely to the actual argument. In several instances, the behavior the standard
prescribes for arguments that are pointers apply to those that are allocatable
too. This is pointed out in the text. Short code sections provide examples.
Dummy Pointer Argument An explicit interface to a subprogram must be
provided if one or more of its arguments is either a pointer or has the
allocatable attribute assigned to it. The actual argument must also be a
pointer and all its non-deferred type parameters and ranks shall agree with
those of the dummy argument.
In the following code, a parameterized derived type is deﬁned (see Rule 125);
two pointers of this type are declared; and the interfaces of two subroutines,
each having two dummy pointer arguments of this type, are given. The explicit
interfaces are speciﬁed using interface blocks. However, it is normally preferable
to have the explicit interface speciﬁcations come directly from the procedures
themselves – either by residing in the same module as the caller, or from “use
association” from another module. Three calls to these routines are shown,
and comments within the code explain which are legal calls and which are not.
integer ,
parameter
: :
MAX LEN = 100
type ,
public
: :
my typ t
( a r r l e n )
integer ,
len
: :
a r r l e n = MAX LEN
integer
: :
i n t a r r a y ( a r r l e n )
end type
my typ t
!
d e f i n e
t h r e e
v a r i a b l e s
of
type
my typ t .
one
with
a
!
d e f e r r e d
type
parameter
and two
without .
type
( my typ t ,
a r r l e n =:) ,
pointer
: :
d e f v a r
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
63
type
( my typ t ,
a r r l e n =50) ,
pointer
: :
n o n d e f v a r 5 0
type
( my typ t ,
a r r l e n =20) ,
pointer
: :
n o n d e f v a r 2 0
i n t e r f a c e
subroutine
Sub a
( arg a1 ,
arg a2 )
import
: :
my typ t
type
( my typ t ,
a r r l e n =50) ,
intent
( in
out ) , &
pointer
: :
arg a1
type
( my typ t ,
a r r l e n =:) ,
intent
( in
out ) , &
pointer
: :
arg a2
end subroutine
Sub a
end
i n t e r f a c e
!
t h i s
c a l l
i s
l e g a l :
!
the
type
parameter
of
the
f i r s t
a c t u a l
argument
!
i s
not
d e f e r r e d
and
i t
agrees
with
that
of
the dummy
!
argument .
the
second
a c t u a l
argument
has a
d e f e r r e d
!
type
parameter ,
as
does
the dummy argument .
c a l l
Sub a
( non def var 50 ,
d e f v a r )
!
t h i s
c a l l
i s
i l l e g a l :
!
the
f i r s t
a c t u a l
argument
has a
d e f e r r e d
type
!
parameter
but
the
f i r s t
dummy argument
does
not ,
!
and
the
second
a c t u a l
argument
does
not
have a
!
d e f e r r e d
type
parameter
but
the
second dummy
!
argument
does .
c a l l
Sub a
( def var ,
n o n d e f v a r 5 0 )
!
t h i s
c a l l
i s
i l l e g a l :
!
the non−d e f e r r e d
type
parameter
of
the
f i r s t
!
a c t u a l
argument
does
not
agree
with
the
type
!
parameter
of
the
f i r s t
dummy argument .
c a l l
Sub a
( non def var 20 ,
d e f v a r )
Attention must be paid to the intent of the dummy argument when it is a
pointer; the intent affects the behavior as explained in the next three sections
covering intent (out), intent (in ), and intent (in out).
■intent (out)
If the dummy argument has this attribute, the pointer association of the
actual argument becomes undeﬁned when the procedure is invoked. After
the procedure has completed, the association status of the actual argument
acquires that given the dummy argument during execution of the procedure
(see Rule 53). The behavior on invocation is a potential source of memory
leaks, a situation where the program loses access to memory without deal-
locating it, so you must be cautious in this case. Here is the interface of a
subroutine with such a dummy argument:
Cambridge Books Online © Cambridge University Press, 2012

64
MODERN FORTRAN
!
on
i n v o c a t i o n
of
t h i s
procedure ,
the
a c t u a l
!
argument
a s s o c i a t e d
with dummy argument
!
i n t a r g 1
a c q u i r e s
a
s t a t u s
of
undefined . To use
!
i t ,
the
procedure
f i r s t
needs
to
a l l o c a t e
i t
!
( or
i t
may be
n u l l i f i e d ) .
i n t e r f a c e
subroutine
Sub a
( i n t a r g 1 )
integer ,
intent
( out ) ,
pointer
: :
i n t a r g 1 ( : )
end subroutine
Sub a
end
i n t e r f a c e
Here is a code that includes a call to the procedure. It will cause a memory
leak.
integer ,
pointer
: :
i n t p t r ( : )
integer
: :
a l l o c s t a t ,
num elems
! a l l o c a t e
memory
f o r
the
i n t e g e r
p o i n t e r
a l l o c a t e
( integer
: :
i n t p t r ( num elems ) , &
stat = a l l o c s t a t )
!
I f
the
a l l o c a t i o n
i s
s u c c e s s f u l ,
c a l l
Sub a .
!
access
to
the memory
j u s t
a l l o c a t e d
i s
l o s t .
i f
( a l l o c s t a t == 0)
c a l l
Sub a
( i n t p t r )
Assigning a pointer dummy argument could be an alternative to returning
a pointer as a function result. For example, you may have a linked list of a
derived type, and you wish to create a new node in the list (the deﬁnition
of type my type t is not shown).
type
node t
type
( my type t )
: :
my type value
type
( node t ) ,
pointer
: :
n e x t n o d e p t r
end type
node t
subroutine
Create node
( t h i s ,
my type object )
type
( node t ) ,
intent
( out ) ,
pointer
: :
t h i s
type
( my type t ) ,
intent
( in )
: :
my type object
integer
: :
a l l o c s t a t
!
the
n u l l i f i e d
s t a t u s
of
t h i s
on
r e t u r n
!
i n d i c a t e s
an
e r r o r .
n u l l i f y
( t h i s )
!
check
v a l u e s
of
the
components
of
t h i s ;
!
proceed
i f
c o r r e c t .
i f
( Check components
( my type object ) == 0)
then
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
65
a l l o c a t e
( node t
: :
t h i s ,
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
t h i s%my type value = my type object
e l s e
! . . .
handle
e r r o r
c o n d i t i o n
end
i f
end
i f
end subroutine
Create node
A “dangling” pointer is the result of deallocating the target of a pointer
without directly using the pointer itself. To prevent a dangling pointer in
the previous calling procedure, you would want to make sure the actual
argument that corresponds with argument this is not already associated
with a target. (It is too late to do so in Create node because the actual
argument has acquired a status of undeﬁned on entry.) In the sample code
here, this is accomplished by a call to a procedure named Destroy (not
shown).
type
( my type t )
: :
my type object
type
( node t ) ,
pointer
: :
new node
n u l l i f y
( new node )
!
code
to
s e t
components
of
my type object .
!
code
that
p o s s i b l y
could
a l l o c a t e ,
assign ,
!
and
use
new node .
i f
( associated
( new node )
)
c a l l
Destroy
( new node )
c a l l
Create node
( new node ,
my type object )
■intent (in)
The procedure cannot change the association of the pointer to its target
during execution. It can, however, change the value of the pointer’s target.
Here is an example:
subroutine
Calc temp
( t h i s ,
temp pointer )
type
( temp t ) ,
intent
( in
out )
: :
t h i s
real ,
intent
( in ) ,
pointer
: :
temp pointer
real ,
target
: :
l o c a l t a r g e t
!
The
f o l l o w i n g
code
i s
l e g a l :
temp pointer = 5.2
!
but
the
f o l l o w i n g
two
l i n e s
of
code
are
not :
n u l l i f y
( temp pointer )
temp pointer => l o c a l t a r g e t
end subroutine
Calc temp
Cambridge Books Online © Cambridge University Press, 2012

66
MODERN FORTRAN
This applies not only to dummy arguments that are pointers, but also to
dummy arguments of derived type that are not pointers but have pointer
components.
type ,
public
: :
element t
real ,
pointer
: :
i n t e n s i t y
end type
element t
subroutine
Process element
( t h i s )
type
( element t ) ,
intent ( in )
: :
t h i s
!
The
f o l l o w i n g
code
i s
c o r r e c t :
i f
( associated
( t h i s%i n t e n s i t y )
) &
t h i s%i n t e n s i t y = 0.0
!
but
t h i s
i s
not :
i f
( associated
( t h i s%i n t e n s i t y )
) &
n u l l i f y
( t h i s%i n t e n s i t y )
end subroutine
Process element
A further restriction is that the actual argument in a call to a procedure
where the corresponding dummy argument is a pointer with intent (in) (or
intent (in out)) must be a pointer and not the result of a call to a function
that returns a pointer. The following code snippet shows the interface of
two calls followed by an illegal reference to the second:
i n t e r f a c e
function
Clone element
( t h i s )
r e s u l t
( r e t u r n v a l u e )
type
( element t ) ,
intent
( in )
: :
t h i s
type
( element t ) ,
pointer
: :
r e t u r n v a l u e
end
function
Clone element
end
i n t e r f a c e
. . .
i n t e r f a c e
subroutine
Assemble element
( t h i s )
type
( element t ) ,
pointer ,
intent
( in
out )
: :
t h i s
end subroutine
Assemble element
end
i n t e r f a c e
. . .
type
( element t )
: :
element 1
!
i l l e g a l
c a l l !
c a l l
Assemble element
( Clone element
( element 1 ))
■intent (in out)
When the pointer dummy argument has the intent of intent (in out), both
the value and the association of the dummy argument can be changed. On
entry to the called subprogram, the dummy pointer argument becomes
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
67
associated with the target of the actual pointer argument if it has one. If the
dummy pointer becomes associated with a different target during execution,
the actual target will be associated with it when control is returned to the
invoking routine. Care must be taken, however, if the dummy argument is
associated with a local target that ceases to exist on exit. In that case, the
actual argument is undeﬁned when execution returns to the calling routine.
The following program demonstrates how this works. It contains a module
with a subroutine that has two pointer arguments with intent (in out). In
it, one of the arguments, i arg a , is associated with a module variable that
has the save attribute. Argument int arg b , the second dummy argument,
is associated with a variable local to the subroutine that does not have
this attribute. The code in the main program that follows shows a call
to subroutine Point arg . Comments embedded in the code point out the
program behavior.
Listing 6.3:
Program Point intent in out
module Proc mod
i m p l i c i t
none
private
public
: :
P o i n t a r g
integer ,
target ,
save
: :
module saved int
contains
subroutine
P o i n t a r g
( i a r g a ,
i n t a r g b )
integer ,
intent
( in
out ) ,
pointer
: :
i a r g a
integer ,
intent
( in
out ) ,
pointer
: :
i a r g b
integer ,
target
: :
l o c a l n o n s a v e d i n t
module saved int
= 50
l o c a l n o n s a v e d i n t = 60
i a r g a
=> module saved int
i n t a r g b => l o c a l n o n s a v e d i n t
end subroutine
P o i n t a r g
end module Proc mod
program
P o i n t i n t e n t i n o u t
use Proc mod ,
only
:
P o i n t a r g
i m p l i c i t
none
integer ,
target
: :
i n t a ,
i n t b
integer ,
pointer
: :
i n t p o i n t a ,
i n t p o i n t b
i n t a = 5
i n t b = 8
Cambridge Books Online © Cambridge University Press, 2012

68
MODERN FORTRAN
i n t p o i n t a => i n t a
i n t p o i n t b => i n t b
c a l l
P o i n t a r g
( i n t p o i n t a ,
i n t p o i n t b )
!
i n t p o i n t a
i s
now
a s s o c i a t e d
with
saved
module
!
v a r i a b l e
module saved int
i n
module proc mod .
!
I t s
value
i s
50 ( the
value
of
i n t a
remains
5 ) .
i f
( associated
( i n t p o i n t a )
)
p r i n t
* , &
” i n t p o i n t a :
” ,
i n t p o i n t a
!
Even though
i n t p o i n t b
appears
a s s o c i a t e d ,
!
i t s
t a r g e t
i s
undefined ;
any
r e f e r e n c e
to
i t
i s
!
i l l e g a l .
i f
( associated
( i n t p o i n t b )
)
p r i n t
* , &
” i n t p o i n t b :
” ,
i n t p o i n t b
end program
P o i n t i n t e n t i n o u t
When this program was built using version 5.3 of the Numerical Algorithm
Group compiler, the results of executing the program are:
int_point_a:
50
Runtime Error: point-intent-in-outP.f90, line 42: Dangling
pointer INT_POINT_B used as argument to intrinsic function
ASSOCIATED Target was RETURNed from procedure
PROC_MOD:POINT_ARG
Program terminated by fatal error
Actual Pointer Argument An actual argument may be a pointer even if the
dummy argument is not. In this case, the actual argument must be allocated
prior to the procedure reference; you can regard this as if the associated target
were the actual argument and not the pointer. (An actual argument that has
the allocatable attribute must also be allocated if the dummy argument is not
also allocatable.) In the following code, the two calls to Sub a have the same
effect on the values of both int ptr and int targ ; either could be used.
integer ,
pointer
: :
i n t p t r
integer ,
target
: :
i n t t a r g
i n t e r f a c e
Sub a
( i n t a r g )
integer ,
intent
( in
out )
: :
i n t a r g
end
i n t e r f a c e
Sub a
i n t t a r g = 5.2
i n t p t r
=> i n t t a r g
!
e i t h e r
of
the
f o l l o w i n g
two
c a l l s
could
be made .
c a l l
Sub a
( i n t p t r )
c a l l
Sub a
( i n t t a r g )
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
69
56. Be attentive to the particular standard speciﬁcations regarding argu-
ments possessing the target attribute; do not rely on pointers that become
associated with dummy arguments possessing this attribute to retain their
value or their association status.
This rule explains the behavior of programs where either a dummy or an actual
argument, or both, have the target attribute (see Rule 55).
An explicit interface to a subprogram must be provided if one or more of its
dummy arguments is a target. As opposed to dummy pointer arguments, the
actual argument corresponding to a dummy target argument may or may not
be a pointer or a target. Furthermore, an actual argument may be a target even
though its corresponding dummy argument is not one.
With target actual and dummy arguments, it is important to understand the
behavior of pointers that are pointer associated with them. The following
sections explain this. In each, the assumption is that the dummy argument
has the target attribute; each section discusses the behavior based on the
characteristics of either the actual or the dummy argument. One behavior
common to all occurs when the dummy argument possesses the value attribute
as well as the target one. In this case, any pointers that become assigned to
the dummy argument become undeﬁned when program execution exits the
invoked procedure. In the following routine, the pointer int point a becomes
undeﬁned on procedure exit (see Rule 54).
subroutine
Targ a
( i n t t a r g )
integer ,
intent
( in
out ) ,
target ,
value
: :
i n t t a r g
integer ,
pointer
: :
i n t p o i n t
i n t p o i n t a => i n t t a r g
. . .
end subroutine
Targ a
actual argument: neither pointer nor target If an entity is neither a target
nor a pointer, no pointer can be associated with it. The standard explicitly
states that if any pointers become associated with the dummy target argument
in the referenced subprogram, they become undeﬁned on return to the calling
routine; they cannot become associated with the actual argument (see Refer-
ence [39]). This is true regardless of the intent of the dummy argument and
the possession of the save attribute of any pointers that become associated
with the target argument. This behavior is identical to that described above
when the dummy argument has the value attribute assigned to it.
The following skeleton code shows a module with a subroutine, Sub a, that has
a target integer argument. When invoked, it associates a pointer whose scope is
the entire module with it. This pointer is referenced by two other subroutines
in the module. When the program exits Sub a, the pointer data ptr in module
Cambridge Books Online © Cambridge University Press, 2012

70
MODERN FORTRAN
Sample mod becomes undeﬁned because the variable int 1, the actual dummy
argument, is not a target.
Sample mod
i m p l i c i t
none
private
public
: :
Sub a
integer ,
pointer ,
save
: :
d a t a p t r :
contains
subroutine
Sub a
( i t a r g )
integer ,
intent
( in
out ) ,
target
: :
i t a r g :
. . .
d a t a p t r => i t a r g
. . .
c a l l
Sub b
()
c a l l
Sub c
()
end subroutine
Sub a
subroutine
Sub b
()
!
code
that
a c c e s s e s
d a t a p t r
end subroutine
Sub b
subroutine
Sub c
()
!
code
that
a c c e s s e s
d a t a p t r
end subroutine
Sub c
end module Sample mod
Here is code showing a call to Sub a:
. . .
use Sample mod
i m p l i c i t
none
integer
: :
i
integer ,
parameter
: :
ARR SIZE = 1000
. . .
integer
: :
i n t 1 ( ARR SIZE )
i n t 1 = [ ( i ,
i =1,
s i z e ( i n t 1 ) ) ]
c a l l
Sub a
( i n t 1 )
actual argument: target With respect to pointers associated with the actual
argument and those associated with the dummy argument, the situation where
both arguments possess the target attribute present the programmer with the
most difﬁculties. Here are the possibilities:
■dummy argument is a scalar or assumed-shape array
When a procedure is invoked, pointers associated with the target actual
argument become associated with the target dummy argument. When con-
trol returns to the calling procedure, any pointers that become associated
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
71
with the target dummy argument become associated with the actual target
argument, but only if these pointers do not become undeﬁned on comple-
tion of the subprogram called (as would be the case, for instance, of a pointer
that is local to the subprogram and that does not have the save attribute).
Here is the interface to a subroutine with both a scalar and an assumed-
shape target dummy argument. Any pointers in it that become associated
with the dummy arguments and that do not become undeﬁned will
become associated with the actual target argument.
i n t e r f a c e
subroutine
Targ b
( s c a l a r t a r g ,
assum shape targ )
integer ,
intent
( in
out ) ,
target
: :
s c a l a r t a r g
integer ,
intent
( in
out ) ,
target
: : &
assum shape targ ( : , : )
end subroutine
Targ b
end
i n t e r f a c e
None of this applies if the actual argument is an array section with a vector
subscript. If this is the case, the standard speciﬁes that any pointers that
become associated with a target dummy argument become undeﬁned on
subprogram exit. The following code shows an example:
integer
: :
vect sub (3)
integer
: :
a r r a y 1 (100 ,
100)
i n t e r f a c e
subroutine
Sub a
( i n t t a r g )
integer ,
intent
( in ) ,
target
: :
i n t t a r g ( : ,
: )
end subroutine
Sub a
end
i n t e r f a c e
vect s ub = [10 ,
20 ,
30]
!
i f
any
p o i n t e r s
are
a s s o c i a t e d
with dummy argument
!
i n t t a r g
i n
s u b r o u t i n e
Sub a ,
they
w i l l
become
!
undefined
a f t e r
the
f o l l o w i n g
c a l l
e x i t s .
c a l l
Sub a
( a r r a y 1 ( : ,
vect sub )
)
■dummy argument is an explicit-shape array or an assumed-size array
The standard dictates that in this situation it is processor-dependent
whether pointers associated with the actual argument become associated
with the target dummy argument, and that, on return from the subpro-
gram, the association status of any pointers that become associated with the
target dummy argument is also processor-dependent. That would be the
case with both of the arguments in the subprogram interface shown here.
i n t e r f a c e
subroutine
Target a
( exp targ ,
a s s u m s i z e t a r g , &
t a r g a s i z e )
Cambridge Books Online © Cambridge University Press, 2012

72
MODERN FORTRAN
integer ,
intent
( in
out ) ,
target
: : &
e x p t a r g (20 ,
40)
integer ,
intent
( in
out ) ,
target
: : &
a s s u m s i z e t a r g ( t a r g a s i z e ,
*)
integer ,
intent
( in )
: :
t a r g a s i z e
end subroutine
Target a
end
i n t e r f a c e
The same qualiﬁcation pertaining to actual arguments that are array
sections with a vector subscript that was noted previously for target dummy
arguments that are either scalars or assumed-shape arrays applies here
as well: Any pointers that become pointer associated with them become
undeﬁned on exit.
A further complication exists when there is a dummy argument that is not
a target and it is associated with an actual argument that is a target, and
that dummy argument, in turn, becomes the actual argument to a call to
a routine where the dummy argument does possess the target attribute.
That would be the situation shown here:
subroutine
Targ a
integer ,
target
: :
targ
. . .
c a l l
Sub b
( targ )
end subroutine
Targ a
subroutine
Sub b
( i n t a r g b )
integer ,
intent
( in
out )
: :
i n t a r g b
. . .
c a l l
Targ c
( i n t a r g b )
end subroutine
Sub b
subroutine
Targ c
( t a r g a r g c )
integer ,
intent
( in
out ) ,
target
: :
t a r g a r g c
integer ,
pointer
: :
i n t p o i n t c
. . .
i n t p o i n t c => t a r g a r c c
end subroutine
Targ c
The standard states that the association of int point c in subroutine Targ c
with variable targ a in subroutine Targ a is processor-dependent.
This multitude of possibilities make the use of pointers associated with
dummy arguments having the target attribute problematical. The code
that follows demonstrate one of the potential difﬁculties. This one is
especially egregious because the behavior of one call in some cases depends
on the argument characteristics of the previous one.
module Proc mod
i m p l i c i t
none
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
73
private
public
: :
Target arg
!
s a v e d i n t p t r
has
the
save
a t t r i b u t e
because
!
i t
i s
i n i t i a l i z e d
i n
i t s
d e c l a r a t i o n ;
!
n o n s a v e d i n t p t r
does
not .
!
Fortran
2008
s t i p u l a t e s
that
module
v a r i a b l e s
!
have
the
save
a t t r i b u t e .
integer ,
pointer
: :
s a v e d i n t p t r => n u l l
()
integer ,
pointer
: :
n o n s a v e d i n t p t r
contains
subroutine
Target arg
( i t a r g )
integer ,
intent
( in
out ) ,
target
: :
i t a r g
!
l o c s a v e d p t r
has
the
save
a t t r i b u t e
because
!
i t
i s
i n i t i a l i z e d
i n
i t s
d e c l a r a t i o n ;
!
l o c n o n s a v e d p t r
does
not .
integer ,
pointer
: :
l o c s a v e d p t r => n u l l
()
integer ,
pointer
: :
l o c n o n s a v e d p t r
!
In
the
f i r s t
c a l l
to
Target arg ,
these
!
r e f e r e n c e s
to
the
i n t r i n s i c
f u n c t i o n
!
a s s o c i a t e d
w i l l
work
because
both
!
l o c s a v e d p t r
and
s a v e d i n t p t r
are
!
i n i t i a l i z e d
i n
the
d e c l a r a t i o n s
as
n u l l i f i e d .
! On subsequent
c a l l s ,
the
r e f e r e n c e s
w i l l
not
!
work
i f
the
a c t u a l
argument
of
the
most
r e c e n t
!
c a l l
did
not
have
the
t a r g e t
a t t r i b u t e .
i f
( associated
( l o c s a v e d p t r )
)
then
p r i n t
* , ” l o c s a v e d p t r
i s
” ,
l o c s a v e d p t r
e l s e
p r i n t
* , ” l o c s a v e d p t r
i s
not
a s s o c i a t e d ”
end
i f
i f
( associated
( s a v e d i n t p t r )
)
then
p r i n t
* , ” s a v e d i n t p t r
i s
” ,
l o c s a v e d p t r
e l s e
p r i n t
* , ” s a v e d i n t p t r
i s
not
a s s o c i a t e d ”
end
i f
!
t h i s
c a l l
to
i n t r i n s i c
f u n c t i o n
a s s o c i a t e d
!
w i l l
always
cause
a problem .
The
v a r i a b l e
!
l o c n o n s a v e d p t r
has a
processor −dependent
!
s t a t e
on
entry
and ,
t h e r e f o r e ,
i t s
use
i s
!
u n r e l i a b l e .
Cambridge Books Online © Cambridge University Press, 2012

74
MODERN FORTRAN
i f
( associated
( l o c n o n s a v e d p t r )
)
then
p r i n t
* , ” l o c n o n s a v e d p t r
i s
” , &
l o c n o n s a v e d p t r
e l s e
p r i n t
* , ” l o c n o n s a v e d p t r
i s
not
a s s o c i a t e d ”
end
i f
!
t h i s
r e f e r e n c e
to
a s s o c i a t e d
w i l l
cause
a
!
problem
i n
the
f i r s t
c a l l
to
Target arg
!
because
i t
i s
not
i n i t i a l i z e d
i n
i t s
!
d e c l a r a t i o n .
!
v a r i a b l e
n o n s a v e d i n t p t r
does
not
p o s s e s s
!
the
save
a t t r i b u t e ,
but
i t
i s
a module
!
v a r i a b l e .
!
Subsequent
c a l l s
to
a s s o c i a t e d
w i l l
cause
!
a problem
i f
i t
becomes
undefined ,
by ,
!
f o r
example ,
going
out
of
scope ,
or
i f
!
the
a c t u a l
argument
i n
the
most
r e c e n t
!
c a l l
did
not
p o s s e s s
the
t a r g e t
!
a t t r i b u t e .
i f
( associated
( n o n s a v e d i n t p t r )
)
then
p r i n t
* , ” n o n s a v e d i n t p t r
i s
” ,
l o c s a v e d p t r
e l s e
p r i n t
* , ” n o n s a v e d i n t p t r
i s
not
a s s o c i a t e d ”
end
i f
s a v e d i n t p t r
=> i t a r g
n o n s a v e d i n t p t r => i t a r g
i t a r g = 98
l o c s a v e d p t r
=> i t a r g
l o c n o n s a v e d p t r => i t a r g
end subroutine
Target arg
end module Proc mod
57. Consistently place subprogram arguments in the following order:
the pass argument, intent (in out) arguments, intent (in) arguments,
intent (out) arguments, optional arguments.
By default, the ﬁrst argument of both procedure pointer components and
type-bound procedures is an object of a class. The actual argument passed
must be one of the types of the class, either the base type or one extended from
it (see Rule 149). It makes sense, therefore, that such an argument be made
the ﬁrst one whenever possible (see Rule 152). Here is part of a module for a
structural beam:
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
75
module Beam mod
type
beam t
. . .
components
d e s c r i b i n g
geometry ,
s t r u c t u r a l
. . .
p r o p e r t i e s ,
material ,
etc .
contains
procedure
: :
Compute deflection
end type
beam t
subroutine
Compute deflection
( t h i s ,
load ,
d e f l e c t i o n )
c l a s s
( beam t ) , intent
( in )
: :
t h i s
type
( l o a d t ) ,
intent
( in )
: :
load
type
( d e f l e c t i o n t ) ,
intent
( out )
: :
d e f l e c t i o n
! . . . code
to
compute beam
d e f l e c t i o n .
end subroutine
Compute deflection
end module Beam mod
The ﬁrst argument, this, possesses the pass attribute by default. The type-
bound procedure Compute deﬂection would be called as shown in this code:
type
( beam t )
: :
a beam
type
( l o a d t )
: :
load 1
type
( d e f l e c t i o n t )
: :
d e f l e c t i o n 1
c a l l
a beam%Compute deflection
( load 1 ,
d e f l e c t i o n 1 )
Regarding the placing of optional arguments at the end, here’s the interface of
a subroutine with one optional argument:
subroutine
Put a
( r arg ,
i a r g 1 ,
i a r g o p )
real ,
intent
( in
out )
: :
r a r g
integer ,
intent
( in )
: :
i a r g 1
integer ,
intent
( in ) ,
optional
: :
i a r g o p
end subroutine
Put a
Calls to this subroutine, both with and without the optional argument, would
appear as follows:
integer
: :
int1 ,
i n t 2
r e a l
: :
r e a l 1
c a l l
Put a
( real1 ,
i n t 1 )
. . .
c a l l
Put a
( r a r g=real1 ,
i a r g 1=int1 ,
i a r g o p=i n t 2 )
If during program development you need to add an optional argument to the
argument list, you should add one to the end. Then only the calls that need
to pass the new argument need be modiﬁed.
subroutine
Put a
( r arg ,
i a r g 1 ,
i a r g o p ,
k arg op )
real ,
intent
( in
out )
: :
r a r g
integer ,
intent
( in )
: :
i a r g 1
integer ,
intent
( in ) ,
optional
: :
i a r g o p ,
k arg op
end subroutine
Put a
Cambridge Books Online © Cambridge University Press, 2012

76
MODERN FORTRAN
!
a new
c a l l
to
Put a
c a l l
Put a
( r a r g=real1 ,
i a r g 1=int1 ,
k arg op=i n t 3 )
!
an
old
c a l l
to
Put a ,
which
s t i l l
works
c a l l
Put a
( real1 ,
i n t 1 )
Note that if keywords are always used for all optional arguments in all pro-
cedure calls, new optional arguments can be placed in any position after
the non-optional arguments. But if there are cases where keywords are not
used, it would be possible for an actual argument to be passed to an unin-
tended dummy argument. If the previous new call was written without key-
words, the argument int3 would mistakenly be passed to dummy argument
i arg op :
c a l l
Put a
( real1 ,
int1 ,
i n t 3 )
One technique that can assist in avoiding this problem is shown in the follow-
ing code segments taken from the Earth System Modeling Framework (ESMF)
(see Reference [23]). The ﬁrst segment of code shows the deﬁnition in a utility
module of a derived type having public access:
module ESMF UtilMod
. . .
!
d e f i n e
a
d e r i v e d
type
of
p u b l i c
access
type
ESMF KeywordEnforcer
private
integer
: :
q u i e t
end type
ESMF KeywordEnforcer
. . .
end module ESMF UtilMod
In all subprograms containing optional arguments, a dummy argument of
this type separates the required arguments from the optional ones. The next
segment presents the interface to such a subprogram:
use ESMF UtilMod
. . .
subroutine
ESMF FieldRedistStore
( s r c F i e l d ,
d s t F i e l d , &
routehandle ,
factor ,
keywordEnforcer , &
srcToDstTransposeMap ,
rc )
!
input
arguments
type
( ESMF Field ) ,
intent
( in )
: :
s r c F i e l d
type
( ESMF Field ) ,
intent
( inout )
: :
d s t F i e l d
type
( ESMF RouteHandle ) ,
intent
( inout )
: : &
routehandle
integer
(ESMF KIND 14 ) ,
intent
( in )
: :
f a c t o r
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
77
!
must
use
keywords
below
type
( ESMF KeywordEnforcer ) ,
optional
: : &
keywordEnforcer
integer ,
intent
( in ) ,
optional
: : &
srcToDstTransposeMap ( : )
integer ,
intent ( out ) ,
optional
: :
rc
end subroutine
ESMF FieldRedistStore
Even though it is possible to declare and pass a variable of type
ESMF KeywordEnforcer to this routine (because the type possesses the public
attribute), as policy, this is never done, and, therefore, keywords must be used
for all the arguments that follow the argument keywordEnforcer in the interface.
Here is one such call:
c a l l
ESMF FieldRedistStore14
( s r c f i e l d ,
d s t f i e l d , &
route handle ,
factor , &
srcToDstTransposeMap = transpose map ,
rc = r c o u t )
58. Assign a default value to all dummy arguments possessing the optional
attribute.
Rather than using the intrinsic procedure present to test throughout a subpro-
gram for the presence of an optional argument with the attribute intent (in)
or intent (in out), declare a local variable of a type and kind compatible with
it. Then, at the beginning of the procedure, assign it the value of the optional
argument if it is present, or a default value if it is not, and use it in its place in
the remainder of the routine.
function
C a l c v a l
( t h i s ,
arg 1 ,
o f l g 1 ) &
r e s u l t
( r e t v a l )
type
( o b j e c t t ) ,
intent
( in )
: :
t h i s
real ,
intent
( in )
: :
arg 1
integer ,
intent
( in ) ,
optional
: :
o f l g 1
r e a l
: :
r e t v a l
integer
( kind
( o f l g 1 ) ) ,
parameter
: : &
DEFAULT FLAG 1 = 0
integer
( kind
( o f l g 1 ))
: :
l o c a l f l a g 1
i f
( present
( o f l g 1 ))
then
l o c a l f l a g 1 = o f l g 1
e l s e
l o c a l f l a g 1 = DEFAULT FLAG 1
end
i f
! . . .
code
that may use
l o c a l f l a g 1
end
function
C a l c v a l
Had this been a subroutine instead of a function, and had the argument
o ﬂg 1 been assigned an intent of in out instead of in, you would also test
Cambridge Books Online © Cambridge University Press, 2012

78
MODERN FORTRAN
for its presence at the function exit and set its value to the local variable as
explained next for the case of intent (out).
For optional, intent (out) dummy arguments, declare a local variable and
set it to a default value at the beginning of the subprogram. In the case of
a derived-type object, component initializations may be used to perform this
automatically. Set the local variable as needed throughout the procedure and
then set the optional argument, if present, at program exit (see Rule 127).
subroutine
Sub a
( t h i s ,
arg 1 ,
e r r o r f l a g )
type
( o b j e c t t ) ,
intent
( in
out )
: :
t h i s
real ,
intent
( in )
: :
arg 1
integer ,
intent
( out ) ,
optional
: :
e r r o r f l a g
integer ,
parameter
: :
DEFAULT ERROR FLAG = 0
integer
: :
l o c a l e r r o r f l a g
l o c a l e r r o r f l a g = DEFAULT ERROR FLAG
. . .
code
that may s e t
l o c a l e r r o r f l a g
i f
( present
( e r r o r f l a g )) &
e r r o r f l a g = l o c a l e r r o r f l a g
end
function
Sub a
59. Reduce long argument lists by placing arguments in derived types.
Before Fortran 90 introduced derived types, you would often see procedures
with long argument lists. This made them difﬁcult to maintain and test. As
new pieces of information needed to be maintained, extra arguments would
have to be added to every related routine – tedious and error-prone work.
Alternatively, common blocks might have been used, but this also had negative
ramiﬁcations with regard to testability and reusability. When derived-type
objects are passed between procedures, additional information can be included
within the derived-type object and no modiﬁcations are needed to procedures
that pass the object around.
Here, as a simple example, is the interface to the subroutine GSVP (SET
VIEWPORT) in the Graphical Kernel System (GKS). The Fortran language
binding was for FORTRAN 77 (see Reference [34]).
SUBROUTINE GSVP (TRNUM, X MIN ,X MAX, Y MIN ,Y MAX)
INTEGER TRNUM
REAL X MIN ,X MAX, Y MIN ,Y MAX
END
The argument TRNUM is the transformation number, and the arguments
XMIN, XMAX, YMIN, and YMAX are the viewport limits in normalized device
coordinates. They are all input arguments. In the GKS speciﬁcation for the C
language binding, the prototype for the same function is:
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
79
void
g s e t v p ( Gint
tran num ,
const
G l i m i t
*vp ) ;
where Glimit is deﬁned as follows:
typedef
struct
{
G f l o a t
x min ;
G f l o a t
x max ;
G f l o a t
y min ;
G f l o a t
y max ;
}
G l i m i t ;
(See Reference [36].)
If you were writing a Fortran 2003 version of GKS, you would most likely
mimic the C struct with a derived type and create a new interface to the
routine:
type
g l i m i t t
r e a l
: :
x min ,
x max ,
y min ,
y max
end type
g l i m i t t
. . .
subroutine
GKS svp ( trnum ,
vp )
integer
( kind=g i n t ) ,
intent
( in )
: :
trnum
type
( g l i m i t t ) ,
intent
( in )
: :
vp
end subroutine
GKS svp
Where appropriate, organize arguments to all procedures in this manner.
This rule is especially pertinent when the arguments are arrays. For example,
had the original interface in FORTRAN 77 been written like this:
SUBROUTINE GSVP (TRNUM, XLIM , YLIM)
INTEGER TRNUM
REAL XLIM (2) , YLIM(2)
END
This subroutine, as written, could not be preﬁxed by elemental (although it
could be made pure). However, when it is rewritten using argument vp of
derived type glimit t , it can be an elemental routine because all the arguments
are scalars (see Rule 128).
60. In all calls to subprograms, use the form dummy-argument-name =
actual-argument-name with all optional arguments.
Using keywords for all optional arguments clearly distinguishes between
required arguments and those that are optional. Strictly speaking, however,
keywords are required for optional arguments in only two situations: in a pro-
cedure reference where you do not place the optional arguments in the order
that conforms to the procedure’s interface; or where you skip some optional
arguments when calling it. In the following example, keywords are required in
the ﬁrst call to subroutine Calc energy because the optional actual arguments
Cambridge Books Online © Cambridge University Press, 2012

80
MODERN FORTRAN
are out of order; in the second call because the ﬁrst optional dummy argument,
o ﬂg 1 , is skipped, that is, there is no corresponding actual argument. The
third call does not require keywords; they are included to distinguish between
the required arguments and the optional ones (see Rule 57).
subroutine
Calc energy
( t h i s ,
arg 1 ,
arg 2 ,
o f l g 1 , &
o p e r r 2 )
type
( o b j e c t t ) ,
intent
( in
out )
: :
t h i s
real ,
intent
( in )
: :
arg 1
real ,
intent
( out )
: :
arg 2
integer ,
intent
( in ) ,
optional
: :
o f l g 1
integer ,
intent
( out ) ,
optional
: :
o p e r r 2
end subroutine
Calc energy
c a l l
Calc energy
( a object ,
in arg ,
out arg , &
o p e r r 2=e r r i n d ,
o f l g 1=switch )
c a l l
Calc energy
( a object ,
in arg ,
out arg , &
o p e r r 2=e r r I n d )
c a l l
Calc energy
( a object ,
in arg ,
out arg , &
o f l g 1=switch ,
o p e r r 2=e r r i n d )
Using keywords offers some additional beneﬁts: They enhance the clarity of
your code; when you choose good names for dummy arguments, a reader
can quickly determine the purpose of passing the various variables to the
procedure. Using keywords also forces the compiler to look for an explicit
interface to the called routine, which the standard requires when there are
optional arguments. The availability of the interface can be either via use
association of public procedures in other modules, or through an explicit
interface block to an external subprogram, or use association with a module
whose sole purpose is to provide interface information (see Rule 48).
And, ﬁnally, as arguments are added to the procedure over time, keywords
prevent you from inadvertently passing an actual argument to an unintended
dummy argument. With this in mind, a more stringent rule you may wish to
adopt for references to external subprograms, but not necessarily to module
procedures, is to always specify keywords to arguments, whether they are
optional or not, thereby forcing the compiler to require access to an explicit
interface.
61. Use assumed-shape arrays as dummy array arguments in
subprograms.
The Fortran 90 standard (see Reference [40]) introduced assumed-shape arrays
as a new method of passing arrays of different shapes to subprograms, improv-
ing on and supplanting both explicit-shape and assumed-size arrays. The pre-
ferred method to pass arrays is to use these assumed-shape arrays. An explicit
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
81
interface must be provided for subprograms that have assumed-shape array
dummy arguments. Either they must be module subprograms with the public
attribute or an interface block must be be provided to the calling routine.
These assumed-shape arrays help prevent array violations that result when
there is a mismatch between the actual array shape and the dummy argument
array boundaries when using the older-style array-passing methods. You should
note, however, that assumed-size arrays need to be used when inter-operating
with a C array of unspeciﬁed size (see Chapter 14). Here is an example of a
subprogram with an assumed-shape array dummy argument:
subroutine
P r o c e s s a r r a y
( array dum )
real ,
intent
( in
out )
: :
array dum ( : ,
: )
. . .
end subroutine
P r o c e s s a r r a y
In this case, any rank 2 array of default intrinsic type real can be passed to
subroutine Process array, and the shape of the dummy array takes on the
shape of the actual array argument. For example:
r e a l
: :
a r r a y a c t 1 (15 ,
22)
. . .
c a l l
P r o c e s s a r r a y
( a r r a y a c t 1 )
Note that if, for some reason, you need to maintain the lower and upper bounds
of the actual array argument in the called subprogram, the lower bound can
be explicitly speciﬁed in the called subprogram or passed to it as an argument.
Otherwise it defaults to a value of 1. For example, in this call:
r e a l
: :
a r r a y a c t 2 ( −15:
15 ,
22)
. . .
c a l l
P r o c e s s a r r a y
( a r r a y a c t 2 )
the lower and upper bounds of the ﬁrst dimension of array dum will be 1 and
31, respectively. If, however, the interface to Process array and a call to it are
modiﬁed as shown here, the lower and upper bounds of the ﬁrst dimension of
array dum will be -15 and 15, respectively (see Rule 84).
subroutine
P r o c e s s a r r a y
( array dum ,
lower bound 1 )
real ,
intent
( in
out )
: :
array dum ( lower bound 1 : ,
: )
integer ,
intent
( in )
: :
lower bound 1
. . .
end subroutine
P r o c e s s a r r a y
. . .
r e a l
: :
a r r a c t 2 ( −15:
15 ,
22)
. . .
c a l l
P r o c e s s a r r a y
( a r r a c t 2 ,
lbound
( a r r a c t 2 , &
dim=1))
Cambridge Books Online © Cambridge University Press, 2012

82
MODERN FORTRAN
62. Use assumed-length or deferred-length allocatable character dummy
arguments.
When passing character arguments, it is far better to use either of two meth-
ods that allow strings of varying length instead of declaring a ﬁxed-length
value that is “big enough.” One method is to declare assumed-length argu-
ments of subprograms that are of intrinsic type character as shown in this
example:
subroutine
P r o c e s s a r r a y
( s t r i n g )
character
( len =*) ,
intent
( in )
: :
s t r i n g
When you do so, an actual character argument of any length, including
length 0, can be passed to the subprogram, and the dummy argument takes
on the length of the actual argument. In the subprogram, you can pass the
dummy argument to all the intrinsic character functions if necessary. Use
the intrinsic function len to determine the length of the dummy argument
character variable if needed.
Another possibility is assigning the argument the allocatable attribute and
using a deferred-length parameter speciﬁcation of len=:. In this case, the
string length can be changed within the routine either by using the allocate
statement or by assignment. As with any allocatable argument, the actual
argument in the calling procedure must also have the allocatable attribute:
subroutine
P r o c e s s a r r a y
( s t r )
character
( len =:) ,
intent
( in
out ) ,
a l l o c a t a b l e
: :
s t r
. . .
s t r = ” Fortran ”
!
I f
not
p r e v i o u s l y
a l l o c a t e d
with
an
a l l o c a t e
!
statement ,
s t r
now has a
l e n g t h
of
7.
deallocate
( s t r )
a l l o c a t e
( character (5)
: :
s t r )
!
s t r
now has a
l e n g t h
of
5.
6.4 Argument Veriﬁcation
63. Provide simple runtime argument checking at the beginning of proce-
dures.
The use of explicit interfaces provides a great deal of compile time check-
ing to ensure that procedures are called with the correct number and type
actual arguments. Yet there are often ways that procedures can still be called
incorrectly. These could include, but are not limited to, passing arrays with
incompatible sizes, providing bad argument values, specifying incompatible
optional arguments, and so on. Simple argument checking, performed on
entry to procedures, ensure that the arguments are valid.
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
83
In the case of array sizing, most Fortran compilers offer options to check array
bounds. This is a very useful option for debugging code, but can signiﬁcantly
slow down production code. A single quick test at the beginning of the
procedure will usually sufﬁce and offers the opportunity to provide better
problem-speciﬁc error messages.
As an example of argument veriﬁcation, the following code implements a
Fast Fourier Transform (FFT) with an optional work array. It checks the
direction argument for validity. If the caller provides the work array to avoid
the overhead of allocating and deallocating internal work space, it must have a
certain minimum size. The code contains a simple check that executes quickly,
and will immediately detect problems (*Cmnt-1).
Listing 6.4: Program Arg par test
module FFT mod
i m p l i c i t
none
private
public
: :
FFT ALLOC ERR , FFT BAD WRKSPACE, &
FFT SUCCESS , FFT UNKNOWN DIR,
FFT 1d
enum ,
bind (C)
enumerator
: :
FFT SUCCESS = 0 , FFT UNKNOWN DIR, &
FFT BAD WRKSPACE, FFT ALLOC ERR
end enum
contains
subroutine
FFT 1d ( s i g d a t a ,
d i r e c t i o n , &
work ,
r e t s t a t )
complex ,
intent ( in
out )
: :
s i g d a t a ( : )
character (*) ,
intent ( in )
: :
d i r e c t i o n
real ,
intent ( in ) ,
optional ,
target
: :
work ( : )
integer ,
intent ( out ) ,
optional
: :
r e t s t a t
integer
: :
a l l o c s t a t ,
min size ,
i e x i t ,
e r r f l g
real ,
allocatable ,
target
: :
w o r k l o c a l ( : )
real ,
pointer
: :
workp ( : )
integer ,
parameter
: : MAX FACTORS = 256
e r r f l g = FFT SUCCESS
!
Single −pass
loop
p r o v i d e s
s t r u c t u r e d
e r r o r
e x i t
!
( A l t e r n a t i v e :
use
F2008
checks :
block
statement )
checks :
do
i
e x i t = 1 , 1
!
*Cmnt−1: Check
arguments
f o r
s a n i t y .
Cambridge Books Online © Cambridge University Press, 2012

84
MODERN FORTRAN
s e l e c t
case
( d i r e c t i o n )
case
( ’ forward ’ ,
’FORWARD’ ,
’ r e v e r s e ’ ,
’REVERSE ’ )
case
default
p r i n t
* , ” i n v a l i d
d i r e c t i o n ”
e r r f l g = FFT UNKNOWN DIR
e x i t
checks
end
s e l e c t
m i n s i z e = 2 *
s i z e
( s i g d a t a ) + MAX FACTORS
i f
( present
( work ))
then
i f
( s i z e
( work ) >= m i n s i z e )
then
workp => work
e l s e
e r r f l g = FFT BAD WRKSPACE
p r i n t
* , ” i n s u f f i c i e n t
workspace ”
e x i t
checks
end
i f
e l s e
a l l o c a t e
( r e a l
: :
w o r k l o c a l ( m i n s i z e ) , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
workp => w o r k l o c a l
e l s e
e r r f l g = FFT ALLOC ERR
p r i n t
* , ” a l l o c a t i o n
problem ”
e x i t
checks
end
i f
end
i f
!
( A l t e r n a t i v e :
use
F2008 end
block
checks
!
statement )
end do checks
i f
( e r r f l g
/= FFT SUCCESS)
then
i f
( present
( r e t s t a t ))
then
r e t s t a t = e r r f l g
return
e l s e
stop 1
end
i f
end
i f
!
compute FFT using
workp
f o r
s c r a t c h
space .
p r i n t
* , ”Computing FFT”
end subroutine
FFT 1d
end module FFT mod
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
85
program
A r g p a r t e s t
use FFT mod ,
only
:
FFT 1d
i m p l i c i t
none
integer ,
parameter
: :
ARR SIZ = 3 , &
WORKSPACE SIZE = 300
complex
: :
d a t a r r ( ARR SIZ )
r e a l
: :
work space (WORKSPACE SIZE)
integer
: :
c a l l s t a t
d a t a r r = [ ( 2 . 0 ,
3 . 0 ) ,
( 3 . 0 ,
4 . 0 ) ,
( 4 . 0 ,
5 . 0 ) ]
c a l l
FFT 1d ( d a t a r r ,
” forward ” ,
work space , &
c a l l s t a t )
c a l l
FFT 1d ( d a t a r r ,
”backward ” ,
work space , &
c a l l s t a t )
end program
A r g p a r t e s t
The results from running this program are:
Computing FFT
invalid direction
64. Create private “argument parameter” types for better compile-time
checking of valid values.
It is often useful to create private derived types speciﬁcally for the purpose
of providing better compile-time diagnostics and avoiding the need to write
runtime validity checks. An example of this is the case of procedures that
have a dummy argument that indicates which of several options need to be
performed. We saw an example of this in Rule 63, the FFT example, with the
argument direction .
To prevent a caller from entering an incorrect argument value, the derived
type itself is made private, yet named constants of the type can be public.
The caller of the routine uses the parameterized values that are legal for the
procedure. Because the type itself is private, a caller cannot deﬁne new variants
of the argument.
Using the program from Rule 63, the ﬁrst argument check (*Cmnt-1) can be
entirely eliminated if the following code is added to module FFT mod:
integer ,
parameter
: :
LEN DIRECTION = 7
type
FFT dir t
character ( len=LEN DIRECTION)
: :
d i r e c t i o n
end type
FFT dir t
type
( FFT dir t ) ,
public ,
parameter
: : &
DIR FOR
= FFT dir t
( ”FORWARD” ) , &
DIR REV
= FFT dir t
( ”REVERSE” )
Cambridge Books Online © Cambridge University Press, 2012

86
MODERN FORTRAN
and the main program Arg par test is rewritten:
program
A r g p a r t e s t
use FFT mod ,
only
: DIR FORWARD,
DIR REVERSE ,
FFT 1d
i m p l i c i t
none
integer ,
parameter
: :
ARR SIZ = 3 , &
WORKSPACE SIZE = 300
complex
: :
d a t a r r ( ARR SIZ )
r e a l
: :
work space (WORKSPACE SIZE)
integer
: :
c a l l s t a t
d a t a r r = [ ( 2 . 0 ,
3 . 0 ) ,
( 3 . 0 ,
4 . 0 ) ,
( 4 . 0 ,
5 . 0 ) ]
c a l l
FFT 1d ( d a t a r r , DIR FORWARD,
work space , &
c a l l s t a t )
end program
A r g p a r t e s t
Any call to subroutine FFT 1d whose second actual argument is not one of
the named constants made available in the use statement will be ﬂagged by
the compiler as an error instead of requiring detection at runtime (see also
*Cmnt-1 in program Type bound demo, Listing A.1).
6.5 Recursive Procedure Design
Recursive procedures (see Reference [66]) are analogous to mathematical
induction. In mathematical induction, the result for a simple-to-specify initial
case is deﬁned. Then, for a larger problem, a rule is then deﬁned to break the
problem into two portions – a simple case, and a smaller remaining problem.
The latter rule is repeatedly applied until the end of the problem has been
reached.
In a recursive procedure, steps similar to mathematical induction are followed;
however, steps also can be applied in reverse. The rule can be repeatedly applied
until the simple end case is found, and additional steps can be performed as
the procedure unwinds itself.
When using data structures that are more complicated than simple arrays, such
as lists and trees, it is common to use recursion to walk through the structure
while processing the elements. Clarity can be achieved by abstracting away
some of the local data management and focusing on the steps needed to solve
the problem (see *Cmnt-1 in Program Unlimited demo in Listing A.2).
65. Write recursive procedures so they have a beginning, a middle, and an
end.
The following code illustrates one way to write a simple factorial function. The
function Factorial provides the public interface to the caller, and performs
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
87
sanity checks for bad inputs. It then calls the private function Factorial worker
to apply the rules to solve the problem.
module Math function mod
i m p l i c i t
none
private
public
: :
F a c t o r i a l
contains
function
F a c t o r i a l
( n )
r e s u l t
( r e s )
integer ,
intent ( in )
: :
n
integer
: :
r e s
!
I n i t i a l
s a n i t y
check .
i f
( n <= 0)
then
r e s = 0
return
e l s e
r e s = F a c t o r i a l w o r k e r
( n )
end
i f
end
function
F a c t o r i a l
In the worker routine, a test is made to determine whether it is time to
terminate the recursion and unwind the instances of it, or to apply the rule
and call itself again.
r e c u r s i v e
function
F a c t o r i a l w o r k e r
( n )
r e s u l t
( r e s )
!
Worker
f u n c t i o n
implements
the
r e c u r s i v e
!
algorithm
integer ,
intent ( in )
: :
n
integer
: :
r e s
!
Define
the
p r o c e s s i n g
step
f o r
t h i s
case ,
!
a l s o
i d e n t i f y
case
that
ends
the
r e c u r s i o n .
i f
( n == 1)
then
r e s = 1
e l s e
r e s = n *
F a c t o r i a l w o r k e r
(n−1)
end
i f
end
function
F a c t o r i a l w o r k e r
end module Math function mod
66. Use recursion to simplify locally scoped data.
Each invocation of a recursive procedure provides a fresh set of automatic
data objects. This allows the processing step to be simpliﬁed because storage
management can be automated to a great degree. Where code might have
needed to declare and allocate arrays or perform other data management tasks,
Cambridge Books Online © Cambridge University Press, 2012

88
MODERN FORTRAN
with recursion much of this work can be automatically performed as part of
the procedure call mechanism.
One example is reading in a ﬁle with an unknown amount of data in it. The
program described here uses recursion to create a linked list to hold the data.
type
d a t a l i s t t
character ( len =:) ,
a l l o c a t a b l e
: :
d a t a s t r i n g
type
( d a t a l i s t t ) ,
pointer
: :
next => n u l l
()
end type
d a t a l i s t t
. . .
contains
subroutine
R e a d
f i l e
l i s t
( t h i s ,
unit num )
type ( d a t a l i s t t ) ,
intent ( in
out )
: :
t h i s
integer ,
intent ( in )
: :
unit num
l o g i c a l
: :
i s o p e n e d
l o g i c a l
: :
i a m l a s t
i n q u i r e
( unit num ,
opened=i s o p e n e d )
i f
( . not .
i s o p e n e d )
then
t h i s%next => n u l l
()
return
e l s e
c a l l
Read worker
( t h i s ,
unit num ,
i a m l a s t )
end
i f
end subroutine
R e a d f i l e
l i s t
r e c u r s i v e
subroutine
Read worker
( t h i s ,
unit num , &
i a m l a s t )
type
( d a t a l i s t t ) ,
intent
( in
out )
: :
t h i s
integer ,
intent
( in )
: :
unit num
l o g i c a l ,
intent
( out )
: :
i a m l a s t
integer ,
parameter
: :
MAX DATA LENGTH = 80
integer
: :
a l l o c s t a t ,
i o e r r ,
i o n e p a s s
character (MAX DATA LENGTH) ,
save
: :
d a t a s t r i n g
!
( F2008
A l t e r n a t i v e :
use
r o u t i n e
:
block
statement )
r o u t i n e :
do
i o n e p a s s = 1 , 1
i a m l a s t = . f a l s e .
read
( unit num ,
’( a ) ’ ,
i o s t a t=i o e r r )
d a t a s t r i n g
i f
( i o e r r /= 0)
then
i a m l a s t = . true .
e x i t
r o u t i n e
e l s e
t h i s%d a t a s t r i n g = d a t a s t r i n g
end
i f
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
89
a l l o c a t e
( d a t a l i s t t
: :
t h i s%next , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t /= 0)
then
i a m l a s t = . true .
e x i t
r o u t i n e
end
i f
c a l l
Read worker
( t h i s%next ,
unit num ,
i a m l a s t )
i f
( i a m l a s t )
then
deallocate
( t h i s%next ,
stat=a l l o c s t a t )
t h i s%next => n u l l
()
end
i f
!
( F2008
A l t e r n a t i v e
:
end
block
r o u t i n e
statement )
end do
r o u t i n e
end subroutine
Read worker
You do not need a separate copy for each instance of data string : Once it is
assigned to this %data string, it is no longer needed. Only the copy current to a
particular call in the chain of recursive calls is required, and this is accomplished
by giving it the save attribute. Also, a ﬂag is passed from the ﬁnal instance
of the procedure to the next previous invocation to allow deallocation of
the node with no data attached to it. Note that the stat= option is used
in all references to the allocate and deallocate statements. In the ﬁrst two
instances, the program processes an allocation problem as if the read statement
had returned a nonzero reply in the iostat= option, thereby terminating the
recursion. In the last case, the recursion has terminated; the stat= option is
included, but not processed, so the program will not abnormally terminate if
there is a problem with deallocation (see Rule 95).
67. Take advantage of tail recursion when possible.
As recursion depth increases, the memory used by the active instances can add
up to a signiﬁcant amount. Also, the procedure call mechanism is costlier in
time than the branching in a simple do loop. Some compilers can recognize an
optimization called “tail recursion,” which allows the generation of an iterative
loop, rather than a recursive one.
A tail recursive procedure is one where the only call to itself is the ﬁnal
statement in the procedure. Since no local storage is being modiﬁed after the
call, it is safe to compile the code as if it has a simple branch to the top of the
routine. Each instance reuses the memory allocated by the very ﬁrst instance.
Here is a tail recursive version of the factorial function. A second argument,
current product is added to keep track of the accumulated product:
r e c u r s i v e
function
F a c t o r i a l w o r k e r &
(n ,
c u r r e n t p r o d u c t )
r e s u l t
( r e t v a l u e )
integer ,
intent ( in )
: :
n ,
c u r r e n t p r o d u c t
integer
: :
r e t v a l u e
Cambridge Books Online © Cambridge University Press, 2012

90
MODERN FORTRAN
i f
( n == 1)
then
r e t v a l u e = 1
return
end
i f
r e s = F a c t o r i a l w o r k e r
(n−1, n* c u r r e n t p r o d u c t )
end
function
F a c t o r i a l w o r k e r
6.6 State, Side Effects, and Thread Safety
One of the characteristics of a procedure is whether or not it maintains visible
internal “state.” Given a set of inputs, does the procedure return the exact same
results each time or can the results vary from call to call? A simple example
of a stateless procedure is the intrinsic trigonometric function sin. It may be
invoked many times with many different argument values. Yet the results will
always be consistent and identical given identical input values.
A common example of a routine that maintains visible state is a pseudo-
random number generator, such as the random number intrinsic subroutine.
Every time the routine returns a value, it updates its internal state so that the
next call will return a different value.
68. Write code that avoids side effects.
Side effects may occur when a procedure modiﬁes global variables, such as
those at module scope (or in common blocks in older code), when variables
have the save attribute, and, in the case of functions, when a function modiﬁes
its arguments.
Consider the ﬁrst line of the following code, where multiple function calls
and usages of an actual argument exist within a single expression. There are
no parenthesis being used to control the order of evaluation, and Fortran
does not prescribe strict left to right evaluation of the expression. The order of
operations are limited to operator precedence; for example, the multiplications
will be performed before the additions. If it is known that the function is visibly
stateless (for example, pure) and that it has no other side effects, a compiler
might optimize this code to either of these two statements that follow it:
r e t u r n v a l u e = My func
( arg ) * My func
( arg ) + arg + 2
!
two
p o s s i b l e
o p t i m i z a t i o n s :
r e t u r n v a l u e = ( My func
( arg ) ** 2) + ( arg + 2)
r e t u r n v a l u e = ( arg + 2) + ( My func
( arg ) ** 2)
Semantically, the compiler generates only a single call to the function. And
because it knows that arg is not changed by the call, the program can compute
arg + 2 before or after the call. Optimizations such as this are often performed
as a result of inlining, which eliminates the call altogether, and subsequent
common subexpression elimination optimization.
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
91
According to the Fortran standard, if an actual argument in a call to a function
is modiﬁed by the function and it is also used elsewhere within the same
expression, the result is undeﬁned. This would be the case if function My func
alters the value of the dummy argument corresponding to the actual argument
arg. Therefore, it is an error to write such code.
The use of procedures possessing the pure attribute is a good way to ensure
there will be no side effect. Pure procedures are written with a speciﬁc set of
restrictions that guarantee this (see Rule 52).
69. Separate initialization from computation to maintain computational
purity.
Some procedures require initialization and need to keep track of whether they
have been initialized or not. For example, the procedure may need to read in
some data from a ﬁle and populate a lookup table. It only needs to be done
once, after which the data is available for the remainder of the run. However,
this is enough to render a procedure as not pure. Such is the case in the
following code, where the save attribute precludes assigning the the function
the pure attribute.
module
Trig function mod
i m p l i c i t
none
private
public
: :
Trig compute
contains
. . .
function
Trig compute
( arg )
r e s u l t
( r e t v a l u e s )
real ,
intent ( in )
: :
arg ( : )
r e a l
: :
r e t v a l u e s ( s i z e
( arg ))
real ,
allocatable ,
save
: :
d a t a t a b l e ( : )
l o g i c a l
: :
i n i t i a l i z e d = . f a l s e .
i f
( . not .
i n i t i a l i z e d )
then
!
. . .
I n i t i a l i z e
d a t a t a b l e
here
i n i t i a l i z e d = . true .
end
i f
!
. . . C a l u l a t e
f u n c t i o n
here
end
function
Trig compute
. . .
end module
Trig function mod
To avoid this problem, you can either use a separate initialization call, com-
bined with a module-scope state variable; or you can carry the state in a
derived-type object.
The ﬁrst technique, using a separate call for initialization, is made possible by
the fact that pure procedures are allowed to access module-scope data; they
Cambridge Books Online © Cambridge University Press, 2012

92
MODERN FORTRAN
simply must not modify it. In this example, the state is maintained implicitly
within the allocated status of the allocatable array data table:
module
Trig function mod
i m p l i c i t
none
private
public
: :
Trig compute ,
T r i g f u n c t i o n i n i t
real ,
allocatable ,
save
: :
d a t a t a b l e ( : )
contains
subroutine
T r i g f u n c t i o n i n i t
( d a t a f i l e )
character (*) ,
intent ( in )
: :
d a t a f i l e
integer
: :
data unit ,
t a b l e s i z e ,
a l l o c s t a t
i f
( allocated
( d a t a t a b l e )) &
deallocate
( d a t a t a b l e ,
stat=a l l o c s t a t )
!
Use F2008
newunit
to
a s s i g n
temporary
!
u n i t
number
open ( newunit=data unit ,
f i l e=d a t a f i l e ,
&
status =’ old ’ ,
access =’read ’ ,
form=’unformatted ’ )
read
( d a t a u n i t )
t a b l e s i z e
a l l o c a t e
( r e a l
: :
d a t a t a b l e ( t a b l e s i z e ) , &
stat=a l l o c s t a t )
read
( d a t a u n i t )
d a t a t a b l e
close
( d a t a u n i t )
end subroutine
T r i g f u n c t i o n i n i t
pure
function
Trig compute
( arg ) &
r e s u l t
( r e t v a l u e s )
real ,
intent ( in )
: :
arg ( : )
r e a l
: :
r e t v a l u e s ( s i z e
( arg ))
. . .
end
function
Trig compute
end module
Trig function mod
You need to ﬁrst call Trig function init. Then Trig compute can be called.
c a l l
T r i g f u n c t i o n i n i t
( f i l e =’ data1 . dat ’ )
. . .
r = Trig compute
( a )
The second technique involves using derived-type objects to maintain their
own state data. Consider the case where multiple calls to Trig compute need
to be made, yet each may need to have a different set of initializations.
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
93
module
Trig function mod
i m p l i c i t
none
private
type ,
public
: :
t r i g s t a t e t
real ,
a l l o c a t a b l e
: :
d a t a t a b l e ( : )
contains
procedure
: :
I n i t
=> T r i g f u n c t i o n i n i t
procedure
: :
Compute => Trig compute
end type
t r i g s t a t e t
contains
subroutine
T r i g f u n c t i o n i n i t
( t h i s ,
d a t a f i l e )
c l a s s ( t r i g s t a t e t ) ,
intent ( in
out )
: :
t h i s
character (*) ,
intent ( in )
: :
d a t a f i l e
integer
: :
a l l o c s t a t
i f
( allocated
( t h i s%d a t a t a b l e )) &
deallocate
( t h i s%d a t a t a b l e ,
stat=a l l o c s t a t )
. . .
!
I n i t i a l i z e
d a t a t a b l e
from
the
f i l e
end subroutine
T r i g f u n c t i o n i n i t
pure
function
Trig compute
( t h i s ,
arg ) &
r e s u l t
( r e t v a l u e s )
c l a s s ( t r i g s t a t e t ) ,
intent ( in )
: :
t h i s
real ,
intent ( in )
: :
arg ( : )
r e a l
: :
r e t v a l u e s ( s i z e
( arg ))
. . .
end
function
Trig compute
end module
t r i g f u n c t i o n m o d
The caller of this code would need a trig state t object for each case that
it needs to keep track of. Each object may be initialized with its own state
as needed. Type-bound procedure names are used to simplify the calls (see
Section 11.3).
type
( t r i g s t a t e t )
: :
t r i g 1 ,
t r i g 2
real ,
dimension ( : )
: :
a ,
b ,
r ,
s
c a l l
t r i g 1%I n i t
( d a t a f i l e =’ data1 . dat ’ )
c a l l
t r i g 2%I n i t
( d a t a f i l e =’ data2 . dat ’ )
r = t r i g 1%Compute ( a )
s = t r i g 2%Compute ( b )
Cambridge Books Online © Cambridge University Press, 2012

94
MODERN FORTRAN
70. Use subroutines instead of functions when returning results through
the argument list.
When a function is written in such a way that it must return values through
its argument list, it is almost always better to use a subroutine instead. This
avoids ambiguous cases where multiple calls and usages of the output variables
are used within a single expression. Consider the following example, keeping
in mind that addition is associative, and that Fortran does not mandate left-
to-right processing of expressions:
r e t u r n v a l u e = Trig compute
( x ) + x + Trig compute
( x )
If the actual argument x is modiﬁed in the Trig compute routine, the result of
the above statement is undeﬁned. If the function were recoded as a subroutine,
the problem could not exist in the ﬁrst place. The revised interface and calling
code are shown next. If a function really does need to return multiple values,
consider coding it to return a derived type containing all the data items that
need to be returned as described in Rule 59.
subroutine
Trig compute
( arg ,
r e t v a l )
real ,
intent
( in
out )
: :
arg ( : )
real ,
intent
( out )
: :
r e t v a l
end subroutine
Trig compute
c a l l
Trig compute
( x ,
r e t v a l=temp )
r e t u r n v a l u e = x + temp
c a l l
Trig compute
( x ,
r e t v a l=temp )
r e t u r n v a l u e = r e t u r n v a l u e + temp
71. Avoid unintentional aliasing.
Aliasing refers to the case where a single data item is known under multiple
symbolic names, called aliases. Fortran only allows aliasing when the pro-
grammer speciﬁcally states that it is possible, such as when using pointers to
objects, the target attribute, the associate construct, and, in older programs,
the equivalence statement. Otherwise, the compiler is allowed to assume that
there is no aliasing. While this may sound obvious, it is one of the key assump-
tions that allow Fortran compilers to optimize code that executes faster than
code written in most other computer languages. Consider the following simple
procedure. Note that the programmer did not specify intent attributes for the
dummy arguments:
subroutine
Compute 42
( a ,
b ,
d )
r e a l
: :
a ( : )
r e a l
: :
b ( : )
r e a l
: :
d ( : )
integer
: :
i
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
95
do ,
i =1,
s i z e
( a )
b ( i ) = a ( i ) + 42.0
d ( i ) = a ( i ) −42.0
end do
end subroutine
Compute 42
A compiler with limited optimization capabilities, or perhaps a more advanced
one with its optimization capabilities disabled, may compile the loop as written,
that is, the variable a(i) is loaded from memory twice per loop iteration.
However, in most computers, references to memory can be costly compared
to arithmetic operations. By taking advantage of Fortran’s aliasing rules, a
good compiler might perform an optimization, called common sub-expression
elimination, and compile the above loop to use a high-speed processor register
to avoid loading a(i) from memory a second time:
do ,
i =1,
s i z e
( a )
r e g i s t e r t e m p = a ( i )
b ( i ) = r e g i s t e r t e m p + 42.0
d ( i ) = r e g i s t e r t e m p −42.0
end do
If the caller of the above routine happened to use the same array for
both input and output arguments, thereby creating an illegal, but per-
haps undiagnosed, aliasing situation, you would likely get different results
depending on the particular compiler in use, and even on the optimization
level.
Many other languages require the compiler to assume that aliasing is always
possible unless told otherwise. The compiler would be required to reload a(i)
from memory, and the code would not run as fast as a program written in
Fortran.
Many cases of illegal aliasing can be devised that are unintended and undiag-
nosed by compilers. As just a single example, here is one where the procedure
reads a variable via the argument list, yet through use association, the same
variable is also modiﬁed under the name used at module scope.
module Compute mod
i m p l i c i t
none
private
public
: :
Compute 42 ,
d
real ,
a l l o c a t a b l e
: :
d ( : )
contains
subroutine
Compute 42
(a ,
b )
real ,
intent ( in )
: :
a ( : )
real ,
intent ( out )
: :
b ( : )
Cambridge Books Online © Cambridge University Press, 2012

96
MODERN FORTRAN
integer
: :
i
do ,
i =1,
s i z e
( a )
b ( i ) = a ( i ) + 42.0
d ( i ) = a ( i ) −42.0
!
updates
module
scope
data
end do
end subroutine
Compute 42
end module Compute mod
program Main
use Compute mod ,
only :
d ,
Compute 42
i m p l i c i t
none
real ,
a l l o c a t a b l e
: :
b ( : )
. . .
!
ILLEGAL
c a l l
Compute 42
( a=d ,
b=b )
. . .
end program Main
If you require that the integrity of particular variables be rigorously preserved
during program execution, the volatile attribute may be used. The standard
states that an object possessing this attribute may be referenced, deﬁned, or
become undeﬁned, by means not speciﬁed by the program. When confronted
with an object having this attribute, the compiler should generate code that
guarantees its value and state. Such a requirement could possibly arise, for
example, in the situation in which a shared-memory parallel processing con-
struct depends on the memory references to take place in a coherent fashion
between threads.
subroutine
Spin wait
( s h a r e d l o c k )
integer ,
v o l a t i l e
: :
s h a r e d l o c k
!
Loop
u n t i l
some
other
p r o c e s s
changes
the
lock
!
value .
do
i f
( s h a r e d l o c k )
e x i t
end do
end subroutine
Spin wait
In this example, if volatile were not used, there are several optimizations a
compiler might perform that would render the code problematic.
The volatile attribute is often stronger than needed because it accommodates
situations not deﬁned by the Fortran standard. Most likely its use will decrease
the speed of the program. The target and asynchronous attributes cover cases
that are deﬁned within the standard. Because they cover deﬁned cases, they
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING PRINCIPLES
97
can be implemented in a weaker fashion than volatile , potentially leading to
better performance. Their use also documents the intended use of the variable.
The target attribute is required for variables that are to be associated with one
or more pointers. And the asynchronous attribute is required for buffers that
are used as part of asynchronous I/O (see Rule 111).
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

7.
Programming
Conventions
7.1 Declaration and Initialization of Data Objects
This section contains guidelines that pertain to all types of data objects, both
of intrinsic type and derived type. Section 11.2 is reserved for the same topic
as it applies to objects of derived type.
72. Declare all variables. To enforce this rule, always include the statement
implicit none in all program units.
The original FORTRAN implicit data typing scheme, where names beginning
with the letters I through N were considered integers, and all others were
considered reals, has proven to be a major source of errors (see Rule 36). All
variables should be explicitly declared.
When an implicit none statement is present in a program unit, the compiler
will require an explicit declaration of the type and kind of every data entity. In
modules, it is most convenient to place the implicit none statement once, at
module scope.
Note that procedure speciﬁcations deﬁned within interface blocks require
their own implicit none statements. By default, they do not import anything
from the surrounding module or procedure. When access to an entity in the
surrounding scope is required, the import statement may be used.
module My mod
!
use
statements
precede
i m p l i c i t
none
use Kinds mod ,
only
: WORK PREC
i m p l i c i t
none
i n t e r f a c e
subroutine
Sub 1
( a )
import
: : WORK PREC
i m p l i c i t
none
r e a l (WORK PREC) ,
intent
( in
out )
: :
a
end subroutine
Sub 1
end
i n t e r f a c e
contains
. . .
end module My mod
98
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
99
73. Assign data objects attributes on the same statement as their
declaration.
Most attributes that can be assigned to a variable or to a constant can be made
in its declaration or deﬁnition. Here are several examples:
integer ,
private ,
save
: :
i n t 1
real ,
public ,
a l l o c a t a b l e
: :
r e a l 1 ( : )
integer ,
public ,
parameter
: :
IPAR 1 = 5
complex ,
private ,
pointer
: :
pt 1 ( : ) => n u l l
()
integer ,
public ,
target
: :
i n t 2 ( IPAR 1 )
character (64) ,
dimension (100)
: :
i n p u t b u f f e r , &
o u t p u t b u f f e r
type ,
public
: :
a t y p e t
!
. . .
components
end type
a t y p e t
As an alternative, and for compatibility with old codes, Fortran allows separate
statements for assigning attributes to data objects. However, for clarity and
simplicity, always use the previous form to keep all the information about an
object in one place.
In the case of the dimension attribute, we generally use the traditional notation
of placing the array speciﬁcation as a sufﬁx on the variable name. However, in
some places, using an explicit dimension attribute can make the code clearer
when several variables of identical shape are declared in the same statement.
74. Initialize all pointers to have an initial association status of disasso-
ciated using the intrinsic function null.
Unless pointers are initialized in their declaration, their initial association status
is undeﬁned. In this undeﬁned state, their status cannot be reliably queried
using the instrinsic function associated. Likewise, pointers cannot be reliably
referenced until they are nulliﬁed or associated with a target by using either the
allocate statement or pointer assignment =>. Here are examples of a pointer
to an array being initialized using null () and pointer components of a derived
data type being similarly initialized in the type deﬁnition (see Rules 136 and
144):
real ,
pointer
: :
a r r a y p t r ( : ) => n u l l
()
type
n o d e t y p e t
type
( node type ) ,
pointer
: :
n e x t p t r => n u l l
()
end type
n o d e t y p e t
Note that the ﬁrst example causes the program to assign the save attribute to
the variable array ptr . It is the association status, not the value, of the pointer
that is saved. This can have serious ramiﬁcations: The user cannot rely on
the value of the target to which the pointer is pointer assigned to be retained.
Much worse, the target can be deallocated and the pointer become dangling.
Cambridge Books Online © Cambridge University Press, 2012

100
MODERN FORTRAN
The standard does not permit this type of initialization for dummy arguments
that are pointers or for functions that return pointers. There are other situ-
ations, a local pointer in a recursive procedure, for example, where this save
attribute may not be desired. In all these cases, the pointer should be nulliﬁed
in the initial stages of the routine in the following manner:
integer ,
pointer
: :
a r r a y p t r ( : )
. . .
n u l l i f y
( a r r a y p t r )
!
A l t e r n a t i v e
a r r a y p t r => n u l l ()
75. Do not initialize variables in their declaration unless necessary.
Variables that are initialized in their declarations acquire the save attribute. If
you initialize r array as shown in the ﬁrst line of the following code, it acquires
the save attribute; and the program must retain its value, or in the case of a
pointer, its association status, during the entire execution of the program. With
local variables, this is wasteful of memory and can cause inefﬁciencies, so it
should be avoided. (In Fortran 2008, all variables whose scope is the module
acquire the save attribute by default.) However, an example of a situation
where variable initialization could be useful is a counter in a procedure (see
Rule 74 and Section 6.6).
r e a l
: :
r a r r a y (MAX ELEMENTS) = 0.0
subroutine
Calc x
( x ,
y )
real ,
intent ( in
out )
: :
x
real ,
intent ( in )
: :
y
integer
: :
i c o u n t e r = 0
i c o u n t e r = i c o u n t e r + 1
! . . .
code
to
c a l c u l a t e
x
end subroutine
Calc x
A second example could be a state variable declared in a module as shown in
this code:
module System state mod
i m p l i c i t
none
private
public
: :
I s s y s t e m I n i t e d ,
I n i t s y s t e m
l o g i c a l
: :
s y s t e m i n i t e d = . f a l s e .
contains
subroutine
I n i t s y s t e m
()
s y s t e m i n i t e d = . true .
! . . .
other
i n i t i a l i z a t i o n
o p e r a t i o n s
end subroutine
I n i t s y s t e m
end module System state mod
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
101
76. Use assumed-length character notation when declaring named con-
stants of intrinsic type character.
To avoid having to count characters, use a declaration such as the following one
to declare scalar named constants of instrinsic type character. In the following
statement, the compiler will assign a length to named constant STR according
to the length of the literal constant to which it is assigned:
character
( len =*) , parameter
: :
STR = ” s t r i n g 1 ”
You can use assumed-length character notation when declaring named con-
stants that are arrays. The array constructor requires that a speciﬁc string length
be speciﬁed if the elements are of different lengths. The length must be equal
to or greater than the length of the longest element.
integer ,
parameter
: :
NO OF CMNDS = 3
character ( len =*) ,
parameter
: : CMND NAMES(NO OF CMNDS) = &
[ character ( len =8)
: :
”REPLACE” ,
”CONTINUE” ,
”QUIT” ]
77. Use named constants instead of “magic numbers” and frequently used
character strings.
Good programming practice encourages that named constants be used for
ﬁxed values and character strings. These may be scientiﬁc constants, array
bounds, character string lengths, and so forth. For example, the energy per
unit area radiated from a body is expressed by the Stefan-Boltzmann equation,
P
A = eσ T 4
(7.1)
where e is the emissivity of the object, σ is the Stefan constant and is 5.6703 ×
10−8 when expressed in units of watts
m2K 4 , and T is the absolute temperature. In
your program, specify the constant as a parameter (see Rule 35):
real ,
parameter
: :
STEFAN CONST = 5.6703E−8
P = e * STEFAN CONST * A * T**4
Whenever possible, use named constants that you have already deﬁned to
deﬁne new ones. This applies to integer constants, where there is no possibility
of losing precision (see Rule 78). For example:
integer ,
parameter
: :
MAX HORIZ PIXELS = 1600 , &
MAX VERT PIXELS = 900 , &
MAX TOTAL PIXELS = MAX HORIZ PIXELS * MAX VERT PIXELS
Here’s an example of a named constant used for an upper bound of an array
(see Rule 92):
integer ,
parameter
: :
MAX SAMPLING UNITS = 5000
r e a l
: :
p o p d e n s i t i e s (MAX SAMPLING UNITS)
Cambridge Books Online © Cambridge University Press, 2012

102
MODERN FORTRAN
Named constants of intrinsic type character can also be used for format speci-
ﬁcations. For example, if your program often prints a character string followed
by an integer, create a well-named named constant for the format speciﬁcation
and use it throughout.
character
( len =*) , parameter
: :
FRMT STR INT = ” (a ,
i 0 ) ”
integer ,
a l l o c a t a b l e
: :
atoms ( : )
write
(* , FRMT STR INT) ”Atoms :
” ,
s i z e
( atoms ,
dim=1)
Note that using named constants is more ﬂexible than using format statements.
A named constant may be placed at module scope, so it can be shared by many
customers.
78. Set mathematical constants using known precise values.
Obtain the value of mathematical constants from trusted sources, rather than
an intrinsic function result.
For example, ﬁnd π in the CRC Handbook (Reference [78]), rather than
using an expression such as 4.0 ∗tan−1(1). By using two digits more than
the precision of your variables in the literal, you can guarantee a “last bit” ﬁt,
modulo the compiler’s rounding mode.
r e a l
(DBL K) ,
parameter
: :
PI = 3.14159265358979324 DBL K
7.2 Allocatable and Pointer Attributes
Allocatable arrays were introduced in Fortran 90. The need for enhancing
their capabilities was the impetus for Technical Report TR 15581 (Reference
[31]). This report added the capability of assigning the allocatable attribute
to components of derived type, to function results, and to dummy arguments.
Fortran 2003 incorporates these capabilities and adds some additional ones.
This section comprises two subsections: The ﬁrst contains a list and accompa-
nying explanation of the characteristics of allocatable arrays and scalars that in
most cases makes them superior to pointers in both their behavior and mem-
ory management capabilities. There are some situations where either pointers
must be used or they are useful; they are listed in the second subsection along
with some rules pertaining to cautions about using pointers.
7.2.1 Allocatable Data Objects
Allocatable variables have a single owner of an allocation – the procedure or
module in which the variable is declared. When the owner of the allocated
space goes out of scope, the allocation is automatically deallocated. Association
with a pointer does not change ownership. In fact, it is illegal to attempt to
deallocate an allocatable variable through a pointer to it. Ownership of the
allocated space can change by using the move alloc intrinsic subroutine. In
this case, only the new owner may explicitly deallocate the space.
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
103
79. Wherever possible, use allocatable variables rather than data
pointers.
Automatic Deallocation of Local Allocatable Variables An allocatable vari-
able local to a subprogram is automatically deallocated when the program exits
the subprogram unless the variable possesses the save attribute. This prevents
“memory leakage.” Here is a type deﬁnition whose components represent the
initial conditions of a particle:
type ,
public
: :
s t a r t c o n d s t
real ,
dimension (3)
: :
coords ,
d i r c o s i n e s
end type
s t a r t c o n d s t
In the following code, the program allocates an allocatable array of type
start conds t as well as an allocatable array of real variables, random nums. The
program populates the latter with random numbers, and then calls a function
called
Init particles (not shown) to initialize the components of the array of
particles. When the program exits the function, it will automatically deallocate
both allocatable variables.
function
Comp disp
( n o o f p a r t i c l e s ) &
r e s u l t
( r e t u r n v a l u e )
integer ,
intent
( in )
: :
n o o f p a r t i c l e s
r e a l
: :
r e t u r n v a l u e
type
( s t a r t c o n d s t ) ,
a l l o c a t a b l e
: :
p a r t i c l e s ( : )
real ,
a l l o c a t a b l e
: :
random nums ( : , : )
integer
: :
a l l o c s t a t
integer ,
parameter
: :
RAND NUMS PER TYPE = 6
a l l o c a t e
( s t a r t c o n d s t
: : &
p a r t i c l e s ( n o o f p a r t i c l e s ) ,
stat=a l l o c s t a t )
a l l o c 1 :
i f
( a l l o c s t a t == 0)
then
a l l o c a t e
( r e a l
: :
random nums (RAND NUMS PER TYPE, &
n o o f p a r t i c l e s ) ,
stat=a l l o c s t a t )
a l l o c c h e c k :
i f
( a l l o c s t a t == 0)
then
c a l l
random seed
()
c a l l
random number ( random nums )
p a r t i c l e s = I n i t
p a r t i c l e s
( random nums )
e l s e
a l l o c c h e c k
!
. . . code
to
handle
a l l o c a t i o n
e r r o r
end
i f
a l l o c c h e c k
e l s e
a l l o c 1
!
. . . code
to
handle
a l l o c a t i o n
e r r o r
end
i f
a l l o c 1
!
. . . code
to
compute
r e t u r n v a l u e
Cambridge Books Online © Cambridge University Press, 2012

104
MODERN FORTRAN
!
arrays ,
p a r t i c l e s ,
and random nums
a u t o m a t i c a l l y
!
d e a l l o c a t e
on
procedure
e x i t .
end
function
Comp disp
Allocatable variables whose scope is an entire module, that is, their declara-
tions precede the contains statement separating the speciﬁcation part from
the module procedures, are not necessarily deallocated in this manner when
the module goes out of scope. The standard stipulates that this behavior is
dependent on the processor (see Reference [39]). The burden is upon the
programmer to ensure this array is deallocated when it goes out of scope if that
is the behavior desired. An example might be an allocatable module variable
that is used by several of the module’s subprograms. In Fortran 2008, all such
variables acquire the save attribute by default.
In the next example, a module has an allocatable array of a derived type
that contains information about employees. It might be populated by one
of the module’s subprograms, sorted by a second, and statistical information
calculated from it by a third. The pertinent parts of the module may look like
this:
module Employee mod
i m p l i c i t
none
private
public
: :
!
. . . l i s t
of
p u b l i c
e n t i t i e s
integer ,
parameter
: :
MAX NAME LEN = 100
type ,
public
: :
employee t
character
(MAX NAME LEN)
: :
f u l l n a m e
integer
: :
id numb
r e a l
: :
s a l a r y
end type
employee t
type
( employee t ) ,
save ,
a l l o c a t a b l e
: :
work data ( : )
contains
. . . subprograms
that
r e f e r e n c e
work data
end module Employee mod
Automatic Deallocation of Allocatable Derived-Type Components In
Fortran 90 and Fortran 95, the only method for dynamically sizing com-
ponents of derived types was to use pointers. With the development of TR
15581 (see Reference [31]) and its inclusion into Fortran 2003, derived-type
components may alternatively be declared as allocatable.
Allocatable components enjoy the usual advantages of allocatable variables.
That is, when you deallocate an allocatable variable of derived type, and that
type contains allocatable components at any level, all such components will be
automatically deallocated. So, if you have an allocatable array of type screen t
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
105
that is currently allocated, the following program will also deallocate the pixels
component when the array is deallocated.
type ,
public
: :
p i x e l t
private
integer
: :
rgb (3) = 0.0
!
. . .
other
components
contains
!
. . .
type−bound
procedures
end type
p i x e l t
type ,
public
: :
s c r e e n t
type
( p i x e l t ) ,
a l l o c a t a b l e
: :
p i x e l s ( : , : )
integer
: :
r e s o l u t i o n s (2) = [1024 ,
768]
r e a l
: :
dimensions (2)
= [ 0 . 1 ,
0 . 1 ]
contains
!
. . .
type−bound
procedures
end type
s c r e e n t
type
( s c r e e n t ) ,
a l l o c a t a b l e
: :
s c r e e n s ( : )
integer
: :
a l l o c s t a t ,
num scrns
a l l o c a t e
( s c r e e n t
: :
s c r e e n s ( num srcns ) , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0) &
a l l o c a t e
( p i x e l t
: : &
s c r e e n s%p i x e l s ( v e r t r e s o l ,
h o r i z r e s o l ) , &
stat=a l l o c s t a t )
!
. . .
Code
o p e r a t i n g
on
v a r i a b l e
s c r e e n s
and
!
. . .
i t s
components
!
. . .
Then
d e a l l o c a t e
screens ,
which
a l s o
d e a l l o c a t e s
!
. . .
s c r e e n s%p i x e l s .
deallocate
( screens ,
stat=a l l o c s t a t )
Allocatable Scalars and Character String Lengths Scalar variables may be
declared allocatable. Allocatable scalars are useful for scalar derived-type vari-
ables, which might be used only part of the time, yet take up a signiﬁcant
amount of memory.
type
( h u g e t y p e t ) ,
a l l o c a t a b l e
: :
s c a l a r h u g e o b j
Character string lengths may also be allocatable (see Rule 80). In the employee t
derived type used in the previous example, the following declaration could be
used for the full name component to remove the ﬁxed-length restrictions:
type ,
public
: :
employee t
character ( len =:) ,
a l l o c a t a b l e
: :
f u l l n a m e
. . .
end type
employee t
Cambridge Books Online © Cambridge University Press, 2012

106
MODERN FORTRAN
Allocatable Function Results Fortran 2003 permits function results to be
declared allocatable. Any allocation that occurs is automatically deallocated
after the execution of an expression in which the function reference occurs.
For example, in the following code, the program retrieves the number of
temperature samples from an instrumentation port.
type ,
public
: :
p o r t t
integer
: :
port number
r e a l
: :
avg temp
r e a l
: :
l o c a t i o n s (3)
. . .
other
components
contains
procedure
Get port temps
end type
p o r t t
contains
pure
function
Get port temps
( t h i s )
r e s u l t
( r e t v a l s )
c l a s s
( p o r t t ) ,
intent
( in )
: :
t h i s
real ,
a l l o c a t a b l e
: :
r e t v a l s ( : )
integer
: :
num samps ,
a l l o c s t a t
associate
( port no => t h i s%port number )
num samps = Get no of samples
( port no )
a l l o c a t e
( r e a l
: :
r e t v a l s ( num samps ) , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
r e t v a l s = Get temp samples
( port no )
e l s e
. . .
code
handling
the
a l l o c a t i o n
e r r o r
end
i f
end
associate
end
function
Get port temps
The next example shows code that calls a pure function, Calc avg temp (code
not shown) that computes the average temperature at a port. The allocatable
array created by a call to function Get port temps is the second actual argument
in the call. First, there is the interface to the function Calc avg temp, followed
by the code that calls both it and the function Get port temps. When this code
executes, there will be no of ports calls to the function Get port temps and, as
a result, no of ports allocations. After completion of the forall statement, all
of these allocations will have been automatically deallocated.
i n t e r f a c e
pure
function
Calc avg temp
( t h i s ,
temps ) &
r e s u l t
( r e t v a l )
i m p l i c i t
none
import
: :
p o r t t
type
( p o r t t ) ,
intent
( in )
: :
t h i s
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
107
real ,
intent
( in )
: :
temps ( : )
r e a l
( kind
( temps ))
: :
r e t v a l
end
function
Calc avg temp
end
i n t e r f a c e
type
( p o r t t )
: :
p o r t s ( n o o f p o r t s )
r e a l
: :
temps ( n o o f p o r t s )
integer
: :
i p o r t
f o r a l l
( i p o r t = 1:
n o o f p o r t s )
&
temps ( i p o r t ) = Calc avg temp
( p o r t s ( i p o r t ) , &
p o r t s ( i p o r t )%Get port temps
()
)
Automatic Deallocation of Temporary Expressions Allocations of allocat-
able variables that are done during the calculations of intermediate temporary
expressions are automatically deallocated.
In the following example the functions Get probe temps and Calc wts are both
functions that return a rank 2 allocatable array of default type real.
real ,
a l l o c a t a b l e
: :
crnt tmps ( : , : )
r e a l
: :
amb temp
integer
: :
g r i d b n d s (2) ,
p l a t e n o
g r i d b n d s = Get bnds
( p l a t e n o )
crnt tmps = amb temp + Calc wts
( plate no ,
g r i d b n d s ) &
* Get probe temps
( plate no ,
g r i d b n d s )
The program will form a temporary variable to hold the result of the mul-
tiplication and will automatically deallocate it after it computes the array
crnt tmps.
Contiguous Storage of Allocatable Arrays Storage of allocatable arrays is
contiguous in memory, whereas pointer targets may or may not be contiguous.
When a pointer is used in an operation, the compiler cannot assume that the
data is stored in contiguous memory when it generates the executable code.
Here a pointer points to every second element in row i of a rank-2 array.
real ,
pointer
: :
ptr row ( : )
ptr row => r e a l a r r a y ( i ,
1:
n c o l s :
2)
If an allocatable array is used instead, the program will store it in a contiguous
manner, resulting in more efﬁcient code in most cases (see Rule 97).
Automatic Adjustment of the Size of Allocatable Arrays in Assignments
Allocatable variables automatically adjust size in assignments when the entire
array is referenced on the left hand side. This includes both allocatable variables
as well as those of derived types containing allocatable components. Here is a
Cambridge Books Online © Cambridge University Press, 2012

108
MODERN FORTRAN
derived type containing an allocatable component followed by two variables
of type screen t, with one assigned to the other:
type ,
public
: :
s c r e e n t
type
( p i x e l t ) ,
a l l o c a t a b l e
: :
p i x e l s ( : ,
: )
integer
: :
r e s o l u t i o n s (2) = [1024 ,
768]
r e a l
: :
dimensions (2)
= [ 0 . 1 ,
0 . 1 ]
end type
s c r e e n t
. . .
type
( s c r e e n t )
: :
screen a ,
s c r e e n b
. . .
!
r e a l l o c a t i o n
of
p i x e l s
component may occur
s c r e e n a = s c r e e n b
!
no
r e a l l o c a t i o n
of
p i x e l s
s c r e e n a%p i x e l s ( : ) = s c r e e n b%p i x e l s ( : )
When the program executes the assignment, the allocatable component pixels
of variable screen a will be deallocated if it is allocated. Then, if the pixels
component of screen b is allocated, the pixels component of screen a will be
allocated to the same shape as the pixels of screen b and the copy will take
place. If, on the other hand, the pixels component of screen b is not currently
allocated, the same component of screen a will acquire the status of being not
currently allocated.
Fortran 2003 uses this procedure for all levels of nesting of derived types,
and it uses the same mechanism when assigning allocatable variables, not just
variables of derived type containing allocatable components.
Here we have mentioned just the shape of the expression. However, not
only is the shape of the variable set to that of the expression when it is
allocated, or reallocated; the lower bounds of the variable are set equal to
those of the expression, and, moreover, deferred type parameters also are set to
conform to the values of the expression. The type parameters must be deferred.
The following allocatable intrinsic variable can appear on the left side of an
assignment statement (see Rule 125):
character ( len =:) ,
a l l o c a t a b l e
: :
temp var ( : )
The length type parameters of parameterized derived-type variables can also
be deferred. Here is a derived type with length type parameters:
type
t e m p g r i d t
( rows ,
c o l s )
integer ,
len
: :
rows ,
c o l s
r e a l
: :
nodes ( rows ,
c o l s )
. . .
end type
t e m p g r i d t
and here’s a declaration of an allocatable variable of type temp grid t where the
length type parameters rows and cols are deferred, as indicated by the colons:
type
( t e m p g r i d t ( rows =: ,
c o l s =:)) ,
a l l o c a t a b l e
: :
p l a t e
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
109
The variable plate can appear on the left side of an intrinsic assignment
statement. In the assignment, the program will deallocate plate if it is allocated.
The variable will be allocated, and the value of the type parameters rows and
cols will be set to those of the expression. In the following assignment, the
values of rows and cols in plate will both be set to 20.
type
( temp grid t ,
rows =20,
c o l s =20)
: :
t e m p l a t e p l a t e
p l a t e = t e m p l a t e p l a t e
Automatic Deallocation of Allocatable Actual Arguments That Corre-
spond to intent (out) Dummy Arguments When calling procedures, allo-
catable variables and the allocatable components of variables of derived types
will automatically be deallocated when the variables are the actual arguments
of dummy arguments having the intent (out) attribute. The called procedure
must reallocate the allocatable dummy arguments to the desired size.
In the following code, variables hd screen and crt screen are of the derived
type screen t deﬁned in the previous point. Before the call to procedure Clone,
whose interface is shown, the the program will deallocate component pixels
of variable crt screen if it is allocated (see Rule 53).
subroutine
Clone
( s c r e e n i n ,
s c r e e n o u t )
type
( s c r e e n t ) ,
intent
( in )
: :
s c r e e n i n
type
( s c r e e n t ) ,
intent
( out ) ,
a l l o c a t a b l e
: : &
s c r e e n o u t
end subroutine
Clone
type
( s c r e e n t ) ,
a l l o c a t a b l e
: :
hd screen ,
c r t s c r e e n
. . .
c a l l
Clone
( hd screen ,
c r t s c r e e n )
Reallocation Using the move alloc Intrinsic Subroutine The intrinsic sub-
routine move alloc provides a simple capability for reallocation and memory
management using allocatable arrays. Fortran 2003 introduces this subroutine
as a simple method to transfer ownership of an allocation from one allocatable
variable to another. Its general form is:
subroutine
move alloc
( from ,
to )
where the argument from is allocatable, is of any type, and has an intent of
in out, and the argument to is the same type and rank as argument from, is also
allocatable, and has an intent of out. After execution, the program deallocates
the actual argument corresponding to the dummy argument from.
This subroutine will be most useful in changing the size of an allocation, as
the following example demonstrates. The allocation of the variable node id
is changed to n rows by n cols . After execution of move alloc, the size of
Cambridge Books Online © Cambridge University Press, 2012

110
MODERN FORTRAN
variable node id will be n rows by n cols, and the allocatable array hold id will
be automatically deallocated.
integer ,
a l l o c a t a b l e
: :
node id ( : ,
: ) ,
h o l d i d ( : ,
: )
integer
: :
n rows ,
n cols ,
num move rows , &
num move cols
integer
: :
a l l o c s t a t
! . . . code
i n
which
node id
i s
a l l o c a t e d
and
i t s
elements
! . . . are
a s s i g n e d
v a l u e s .
! . . . code
to
a s s i g n
v a l u e s
to
both n Rows and
n Cols
num move rows = min ( n rows ,
ubound ( node id ,
dim=1))
num move cols = min ( n cols ,
ubound ( node id ,
dim=2))
a l l o c a t e
( integer
: :
h o l d i d ( n rows ,
n c o l s ) , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
h o l d i d ( 1 :
num move rows ,
1:
num move cols ) = node id
c a l l
move alloc
( from=hold id ,
to=node id )
e l s e
! . . . code
to
handle
the
a l l o c a t i o n
e r r o r
end
i f
Sourced Allocation of Variables For variables, sourced allocation provides
a simple method of copying the values of one object to an allocatable one
during the allocation process. The allocatable object may be either allocatable
variables or pointers. When a program executes a sourced allocation, it makes
all necessary allocations and copies data from the source variable to the allocated
variable. The form of the statement can be seen in the following code. (Here,
both the allocatable object and the source object are polymorphic variables;
this is not a requirement of sourced allocation):
subroutine
Compute density
( crnt elems ,
. . . )
c l a s s
( elem t ) ,
intent
( in )
: :
c r n t e l e m s ( : )
c l a s s
( elem t ) ,
a l l o c a t a b l e
: :
tmp elems ( : )
integer
: :
a l l o c s t a t
!
a l l o c a t e
the
temporary
a r r a y
f o r
the
computation .
a l l o c a t e
( tmp elems ,
source=crnt elems , &
stat=a l l o c s t a t )
! . . .
code
to
p r o c e s s
a l l o c s t a t
end subroutine
Compute density
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
111
Fortran 2008 adds some additional features to sourced allocation: First, the
bounds of the allocate object are set to the bounds of the source expression.
You have to set this explicitly in Fortran 2003. Second, if you wish to allocate
without performing the copy, you can use the keyword mold in lieu of source
(see Rule 153):
a l l o c a t e
( tmp elems ,
mold=crnt elems ,
stat=a l l o c s t a t )
80. Use allocatable deferred-length character strings wherever possible.
Fortran 2003 allows the length speciﬁcation of allocatable character strings to
be deferred until their assignment. This makes them in essence variable-length
strings. To specify this, use a length parameter speciﬁcation of len=: and give
the string the allocatable attribute. In the following example, after the ﬁrst
assignment, the variable error message will have a length of 18, and after the
second, one of 43. An allocate statement was not necessary. Moreover, on
exit, the program will automatically deallocate error message if it is a local
variable in a subprogram and also if it does not possess the save attribute.
These allocatable characters can also be used as derived-type components (see
Rule 62).
character ( len =:) ,
a l l o c a t a b l e
: :
error message
error mes s age = ” a l l o c a t i o n
f a i l u r e ”
. . .
error mes s age = ” f i l e
u n i t
number
i s
a l r e a d y
a l l o c a t e d . ”
Functions can return variable length strings using the same mechanism. Here
is a short program that demonstrates this:
Listing 7.1: Program Return string
module
S t r i n g u t i l s m o d
i m p l i c i t
none
private
public
: :
ASCII BLANK ,
E x t r a c t p r i n t a b l e s
integer ,
parameter
: :
ASCII BLANK
= iachar
( ” ” ) , &
ASCII LOWERZ = iachar
( ”z” )
contains
function
E x t r a c t p r i n t a b l e s
( s t r i n g ) &
r e s u l t
( n e w s t r i n g )
character (*) ,
intent ( in )
: :
s t r i n g
character ( : ) ,
a l l o c a t a b l e
: :
n e w s t r i n g
character
: :
c
character
( len
( s t r i n g ))
: :
s t r i n g t e m p
integer
: :
i ,
new len
Cambridge Books Online © Cambridge University Press, 2012

112
MODERN FORTRAN
new len = 0
do ,
i =1,
len trim
( s t r i n g )
c = s t r i n g ( i : i )
i f
(
ASCII BLANK <= iachar
( c ) &
. and .
iachar
( c )
<= ASCII LOWERZ)
then
new len = new len+1
s t r i n g t e m p ( new len : new len ) = c
end
i f
end do
n e w s t r i n g = s t r i n g t e m p ( : new len )
end
function
E x t r a c t p r i n t a b l e s
end module
S t r i n g u t i l s m o d
program
R e t u r n s t r i n g
use
S t r i n g u t i l s m o d ,
only
:
ASCII BLANK , &
E x t r a c t p r i n t a b l e s
i m p l i c i t
none
character ( len =:) ,
a l l o c a t a b l e
: :
t e s t s t r , &
p r i n t s t r i n g
t e s t s t r = char
( ASCII BLANK −1) // ”12 bB45 ) ”
p r i n t
* , ” t e s t s t r
l e n g t h :
” ,
len
( t e s t s t r )
p r i n t s t r i n g = E x t r a c t p r i n t a b l e s
( t e s t s t r )
p r i n t
* , ”new
s t r i n g :
” //
p r i n t s t r i n g
// &
” ,
l e n g t h :
” ,
len
( p r i n t s t r i n g )
end program
R e t u r n s t r i n g
The program output is:
test_str length:
9
new string: 12_bB45), length:
8
Assignment to a character variable as an entity can cause the length to change;
however, assignment to a substring of the variable will not. Neither would
assignment to an individual element of a character array. In the following code,
the character variable text is allocated to a length of 6 by virtue of an intrinsic
assignment. The next two lines will replace, respectively, the second through
fourth characters and the ﬁrst through fourth characters in the variable, but
neither will reallocate the length, which will remain 6.
character ( : ) ,
a l l o c a t a b l e
: :
t e x t
t e x t
= ”123456”
!
l e n g t h
becomes
6.
t e x t ( 2 : 4 ) = ” pqr ”
!
l e n g t h
does
not
change .
t e x t ( : )
= ”mnop”
!
l e n g t h
does
not
change .
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
113
There are situations in which deferred-length character strings do not automat-
ically allocate: a read statement; the iomsg string that Fortran 2003 introduces
to many I/O routines such as open, close, and so on; and an internal write
statement. The length of the string must be speciﬁed in advance, either in the
declaration, by having been assigned in advance to a character string, or in an
allocate statement. Here is an example that uses a ﬁxed-length string set to a
length that is “large enough” for use by the read statement, then copies just
the needed characters into the ﬁnal resultant string.
integer ,
parameter
: :
STR LEN = 64
character (STR LEN)
: :
i o s t r i n g
character ( : ) ,
a l l o c a t a b l e
: :
f i n a l
s t r i n g
integer
: :
i o e r r
. . .
read
(* ,
’( a ) ’ ,
i o s t a t=i o e r r )
i o s t r i n g
i f
( i o e r r /= 0)
then
!
. . .
code
to
handle
the
I /O e r r o r
e l s e
f i n a l
s t r i n g = trim
( i o s t r i n g )
end
i f
81. Create simple data structures using derived types with allocatable
components.
Fortran 2008 extends the advantages of allocatable components over pointers
by allowing self-referential data structures to be built using derived types that
contain allocatable components in lieu of pointers. Doing so provides the
advantages of allocatable variables: Arrays are contiguous, there is no danger
of aliasing unless the target attribute is assigned, and there is no danger of
memory leaks.
The following code shows a derived type for a node on a stack of part purchase
orders:
type
o r d e r t
integer
: :
purchase order number = 0 ,
part number = 0
end type
o r d e r t
type
node t
type
( o r d e r t )
: :
p u r c h a s e o r d e r
type
( node t ) ,
a l l o c a t a b l e
: :
next node
end type
node t
A stack, a subroutine to push a node onto it, and a call to do so would be:
type
( node t ) ,
a l l o c a t a b l e
: :
o r d e r s s t a c k
subroutine
Push node
( t h i s ,
p u r o r d e r )
type
( node t ) ,
intent
( in
out ) ,
a l l o c a t a b l e
: :
t h i s
Cambridge Books Online © Cambridge University Press, 2012

114
MODERN FORTRAN
type
( o r d e r t ) ,
intent
( in )
: :
p u r o r d e r
type
( node t ) ,
a l l o c a t a b l e
: :
new node
new node = node t
( pur order ,
new node )
c a l l
move alloc
( from=t h i s ,
to=new node%next node )
c a l l
move alloc
( from=new node ,
to=t h i s )
end subroutine
Push node
type
( o r d e r t )
: :
o r d e r o b j
c a l l
Push ( o r d e r s s t a c k ,
o r d e r o b j )
A cautionary note is in order here: It would have been possible to write the three
executable lines of code in subroutine Push node in the following manner:
t h i s = node t
( pur order ,
t h i s )
The danger here is that the program may execute what is known as a “deep
copy.” This means that the assignment will generate the copying of every node
on the stack, not just the top one. This could be extremely time-consuming.
The code in the procedure uses a single node of type node t and then, employ-
ing two calls to move alloc places it at the top.
For more complex data structures, such as those that require the structure to
be traversed, it may be best to use pointers; otherwise, many time-consuming
copy operations would have to be performed.
7.2.2 Pointers
Pointers are used for a variety of purposes, some of which are shown in the
next few rules. Pointers associate names with “targets,” and often multiple
pointers can point to a single target. Thus, “ownership” of the target data can
move at the programmer’s discretion. Pointers may also point to strided data,
such as every other element in an array or the diagonal of a matrix. Pointers
can also allow a simple name to be used instead of specifying a component
of a deeply nested derived type. Finally, pointers are a key requirement when
interoperating with code written in C (see Chapter 14).
As pointers are a very general mechanism, they can place a burden on program-
mers to manage them. In particular, there are the issues of memory “leakage,”
where ownership of target data is lost and the data is never freed. A second
problem is “dangling pointers,” where a pointer might point to an area of
memory that is in an unknown state. As Fortran has advanced, several of the
original uses of pointers have been supplanted with safer language features,
such as an increasing number of places where allocatable arrays may be used,
and with the associate construct (see Section 7.2.1).
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
115
82. Use pointers to create dynamic data structures.
You should use pointers to create standard, possibly self-referential, dynamic
data structures such as linked lists, trees, and queues. Here, for example, are
two derived types that can be used to create a linked list of integers (see Rule
85):
type ,
private
: :
i n t n o d e t
integer
: :
i n t v a l u e
type
( i n t n o d e t ) ,
pointer
: :
p t r n e x t n o d e => n u l l
()
end type
i n t n o d e t
type ,
public
: :
i n t
l i n k e d
l i s t
t
private
type
( i n t n o d e t ) ,
pointer
: :
f i r s t n o d e => n u l l
()
end type
i n t
l i n k e d
l i s t
t
83. Use pointers to access array sections and to form arrays of components
of nested derived types.
Numerous numerical methods use sections of arrays to perform algebraic
manipulations. You may ﬁnd it useful to use pointers to point to these sections.
Here is part of the code to solve a system of linear equations using Gauss
elimination (see Reference [77]). Not all the code is shown here, and neither
is the checking that you would want to include.
subroutine
G a u s s s o l v e
( c mat ,
rhs ,
x )
real ,
intent
( in ) ,
: :
c mat ( : , : )
real ,
intent
( in ) ,
: :
rhs ( : )
real ,
intent
( out ) ,
: :
x ( : )
integer
: :
n eqns ,
i p i v ,
j t a r g
r e a l
: :
f a c t o r
r e a l
( kind=kind
( c mat ) ) ,
pointer
: :
p i v p t r ( : ) , &
t a r g p t r ( : )
n eqns = ubound ( c mat ,
dim=1)
!
loop
through
the
p i v o t
equations
eqn loop :
do
i p i v = 1 ,
n eqns −1
!
f o r
a l l
rows
below
the
p i v o t
equation :
!
1)
determine
the
m u l t i p l i c a t i o n
f a c t o r .
!
2)
point
at
a
s e c t i o n
of
p i v o t
row
!
and a
s e c t i o n
of
the
t a r g e t
row .
!
3)
s u b t r a c t .
do
j t a r g = i p i v + 1 ,
n eqns
f a c t o r
= c mat ( j t a r g ,
i p i v ) / c mat ( i p i v , &
i p i v )
p i v p t r
=> c mat ( i p i v ,
i p i v + 1:
n eqns )
t a r g p t r => c mat ( j t a r g ,
i p i v + 1:
n eqns )
Cambridge Books Online © Cambridge University Press, 2012

116
MODERN FORTRAN
t a r g p t r = t a r g p t r −f a c t o r
*
p i v p t r
rhs ( j t a r g ) = rhs ( j t a r g ) −f a c t o r
*
rhs ( i p i v )
end do
end do eqn loop
end subroutine
G a u s s s o l v e
Pointers can also be used to create shortcuts to components of derived types,
especially when they are deeply nested. Here is a segment of code where a
pointer to an array of integer postal codes is formed:
subroutine
S o r t m a i l i n g
( employees )
type
( employee t ) ,
intent
( in ) ,
target
: :
employees ( : )
integer ,
pointer
: :
c o d e s p t r ( : )
c o d e s p t r => employees%address%post code
. . .
end subroutine
S o r t m a i l i n g
Note that the associate construct could also be used (see Rule 39).
84. Use pointers to arrays as dummy arguments when it is necessary to
maintain the array bounds of the actual argument.
When you pass arrays as arguments to subprograms, the upper and lower
bounds of the actual argument are not maintained in the call unless the lower
bound is 1. However, when passing pointers, the lower and upper bounds
are maintained. The following code shows the interface to a subroutine and a
reference to it; the lower and upper bounds of the dummy argument array 1
in the subroutine will be 1 and 21, respectively.
i n t e r f a c e
subroutine
Sub a
( t h i s ,
a r r a y 1 )
type
( element t ) ,
intent
( in
out )
: :
t h i s
real ,
dimension ( : ) ,
intent
( in )
: :
a r r a y 1
end subroutine
Sub a
end
i n t e r f a c e
. . .
type
( element t )
: :
elem 1
r e a l
: :
v e l o c i t i e s ( −10:
10)
c a l l
Sub a
( elem 1 ,
v e l o c i t i e s )
If you change the interface to Sub a so the second argument is a pointer to an
array, the code and reference are as follows:
i n t e r f a c e
subroutine
Sub a
( t h i s ,
a r r a y 1 )
type
( element t ) ,
intent
( in
out )
: :
t h i s
real ,
pointer ,
intent
( in )
: :
a r r a y 1 ( : )
end subroutine
Sub a
end
i n t e r f a c e
. . .
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
117
type
( element t )
: :
elem 1
real ,
target
: :
v e l o c i t i e s ( −10:
10)
real ,
pointer
: :
v e l o c i t i e s p t r
v e l o c i t i e s p t r => v e l o c i t i e s
c a l l
Sub a
( elem 1 ,
v e l o c i t i e s p t r )
The dummy argument array 1 will retain the bounds of the actual variable
velocities ptr, that is, the lower bound will be −10 and the upper bound will
be 10 (see Rule 61).
85. When needed, create an array of pointers by deﬁning a supplemental
derived type with a single component.
In some types of data structures, tree structures for example, operations can
be more efﬁciently performed if you use an array of pointers. Fortran does not
possess the ability to form such an array; you can only declare a pointer to an
array as in the following statement:
integer ,
pointer
: :
p t r i n t ( : )
To create an array of pointers, deﬁne a derived type comprising a single
component of the type you wish to point to. Here is a derived type that might
be used for a binary tree:
type ,
public
: :
node t
type
( node t ) ,
pointer
: :
l e f t
c h i l d
=> n u l l ()
type
( node t ) ,
pointer
: :
r i g h t c h i l d => n u l l ()
type
( node t ) ,
pointer
: :
parent
=> n u l l ()
end type
node t
To create an array of pointers of type node t, ﬁrst deﬁne a new type. Then
deﬁne an array of pointers of type node t in this manner:
type ,
public
: :
p node
type
( node t ) ,
pointer
: :
a node
end type
p node
. . .
type
( p node )
: :
n o d e p t r a r r a y (NUM OF ARRAYS)
86. Avoid assigning an intent (out) attribute to a dummy argument that
is a derived type containing pointer components.
This rule is a more restrictive form of Rule 53. This owes to the fact that
assigning intent (out) to a dummy argument that is a derived type that
contains pointer components at any level can easily cause a memory leak if the
pointer component is nulliﬁed in its component deﬁnition.
The following code outlines two derived types, each in its own module.
The ﬁrst deﬁnes type photograph t, whose components are the name of the
ﬁle containing a photograph and a type-bound procedure for performing a
deﬁned assignment of the name. The second is a module describing an animal.
Cambridge Books Online © Cambridge University Press, 2012

118
MODERN FORTRAN
One of its components is a pointer to an object of type photograph t. It also
contains a type-bound procedure for a deﬁned assignment of the ﬁle name of
the photograph (see Section 11.3).
module Photograph mod
i m p l i c i t
none
private
type ,
public
: :
photograph t
private
character ( : ) ,
a l l o c a t a b l e
: :
f i l e n a m e
contains
procedure
: :
Photo assign name
generic
: :
assignment (=) => Photo assign name
end type
photograph t
contains
subroutine
Photo assign name
( t h i s ,
f i l e n a m e )
c l a s s
( photograph t ) ,
intent
( out )
: :
t h i s
character ( len =*) ,
intent
( in )
: :
f i l e n a m e
t h i s%f i l e n a m e = f i l e n a m e
end subroutine
Photo assign name
end module Photograph mod
module Organism mod
use Photograph mod ,
only
:
photograph t
i m p l i c i t
none
private
type ,
public
: :
organism t
private
r e a l
: :
a v e r a g e l i f e = 0.0
r e a l
: :
average mass = 0.0
l o g i c a l
: :
can move
= . true .
l o g i c a l
: :
i s e x t i n c t
= . f a l s e .
character ( : ) ,
a l l o c a t a b l e
: :
name organism
type ( photograph t ) ,
pointer
: :
image => n u l l
()
contains
procedure
: :
Organism assign name
generic
: :
assignment (=) => Organism assign name
end type
organism t
contains
subroutine
Organism assign name
( t h i s ,
f i l e n a m e )
c l a s s
( organism t ) ,
intent ( out )
: :
t h i s
character ( len =*) ,
intent ( in )
: :
f i l e n a m e
integer
: :
a l l o c s t a t
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
119
i f
( . not .
associated
( t h i s%image ))
then
a l l o c a t e
( photograph t
t h i s%image , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
t h i s%image = f i l e n a m e
e l s e
p r i n t
* , ” a l l o c a t i o n
problem ”
end
i f
end
i f
end subroutine
Organism assign name
end module Organism mod
The following snippet of code will cause Organism assign name to be called.
type
( organism t )
: :
aardvark
aardvark = ” aardvark . bmp”
The problematic code is the intent (out) attribute assigned to the dummy
argument this in subroutine Organism assign name. The program will invoke
this procedure in assignment statements. If this is not the ﬁrst such call for
variable aardvark, execution of this assignment will cause a memory leak. On
entry to subroutine Organism assign name, the pointer component image will
be nulliﬁed as speciﬁed in the deﬁnition of type organism t because the intent
of argument this is intent (out). If no other pointer is associated with the
photograph t object to which image was associated at entry, all reference to it
will be lost. To avoid this problem, the intent needs to be intent (in out).
A better technique is to write a ﬁnal procedure that automatically deallocates
the pointer components. If a dummy argument possesses the intent (out)
attribute, and the corresponding actual argument of a subprogram is a variable
of a derived type that has a ﬁnal subroutine, the ﬁnal subroutine will execute
prior to the call to the subprogram (see Rule 147).
87. Do not use deﬁned assignments for pointer assignment.
It is possible to overload a pointer assignment (=>) using a deﬁned assignment.
The following code is a slight modiﬁcation of the code from the previous rule.
Here, we show the differences.
In subroutine Photo assign name, the intent of argument
ﬁle name is
intent (in out), in accordance with the previous guideline.
subroutine
Photo assign name
( t h i s ,
f i l e n a m e )
c l a s s
( photograph t ) ,
intent
( in
out )
: :
t h i s
character ( len =*) ,
intent
( in )
: :
f i l e n a m e
t h i s%f i l e n a m e = f i l e n a m e
end subroutine
Photo assign name
Cambridge Books Online © Cambridge University Press, 2012

120
MODERN FORTRAN
The procedure Organism assign name is rewritten as Organism assign image.
Its second dummy argument is now of type photograph t.
subroutine
Organism assign image
( t h i s ,
image )
type
( organism t ) ,
intent ( in
out )
: :
t h i s
type
( photograph t ) ,
intent ( in ) ,
target
: :
image
t h i s%image => image
end subroutine
Organism assign image
. . .
end module Organism mod
In the following code, a photograph t object, aardvark photo, is created using
a structure constructor. Execution of the second assignment will invoke sub-
routine Organism assign image.
type
( photograph t )
: :
aardvark photo
type
( organism t )
: :
aardvark
aardvark photo = photograph t
( ” aardvark . bmp” )
aardvark = aardvark photo
The potential problem here is the use of the assignment operator. The Fortran
standard stipulates that the right-hand side of an assignment statement need
only exist for the duration of the call (see Reference [39]). So, as written,
aardvark%image may point to a transitory object, one that disappears as soon
as the program moves to the next executable statement. In this case, its intended
association with aardvark photo is not accomplished. Instead of the assignment,
the correct way to do this is to call the subroutine.
c a l l
Organism assign image
( aardvark ,
aardvark%photo )
88. In a hierarchy of derived types containing allocatable components,
begin allocation with the component of the parent type and proceed through
the hierarchy; deallocate in the reverse order.
The following code sketches an outline of three modules. The ﬁrst,
Widget mod, deﬁnes a type called widget t; the second, Widget list mod, cre-
ates a linked list of widget t objects by deﬁning derived type widget node t;
and the ﬁnal module, assembly mod, deﬁnes type assembly t, one of whose
components is an allocatable array of such linked lists.
module Widget mod
i m p l i c i t
none
private
type ,
public
: :
w i d g e t t
private
character ( len =:) ,
a l l o c a t a b l e
: :
widget name
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
121
. . .
other
components
contains
!
. . .
procedure
binding
statements
end type
w i d g e t t
. . .
contains
!
module
procedures
end module Widget mod
module
Widget list mod
use Widget mod ,
only
:
w i d g e t t
i m p l i c i t
none
private
type ,
public
: :
widget node t
private
type
( w i d g e t t )
: :
widget
type
( widget node t ) ,
pointer
: : &
n e x t w i d g e t p t r => n u l l ()
!
. . .
other
components
contains
!
. . .
procedure
binding
statements
end type
widget node t
. . .
contains
!
module
procedures
end module
Widget list mod
module Assembly mod
use
Widget list mod ,
only
:
widget node t
i m p l i c i t
none
private
type ,
public
: :
assembly t
private
type
( widget node t ) ,
a l l o c a t a b l e
: :
w i d g e t l i s t s ( : )
!
. . .
other
components
contains
procedure
: :
G e t n o o f l i s t s
!
. . .
other
procedure
binding
statements
end type
assemble t
. . .
contains
elemental
function
G e t n o o f l i s t s
( t h i s ) &
r e s u l t
( r e t v a l )
c l a s s
( assembly t ) ,
intent
( in )
: :
t h i s
Cambridge Books Online © Cambridge University Press, 2012

122
MODERN FORTRAN
integer
: :
r e t v a l
. . .
end
function
G e t n o o f l i s t s
!
other
module
procedures
end module Assembly mod
When you wish to populate a linked list of widget t objects and assign it
to an element of the component widget lists of type assembly t, you need
to allocate the components beginning with the most inclusive component,
which in this case is component widget lists, and proceed to the least inclusive,
which here would be the component next widget ptr of type widget node t.
Therefore, the ﬁrst allocation must be:
type
( assembly t )
: :
wing
. . .
a l l o c a t e
( widget node t
: : &
wing%w i d g e t l i s t s ( wing%G e t n o o f l i s t s
( ) ) , &
stat=a l l o c s t a t )
Now, in the following code, the the ﬁrst element of the widget lists array that
was allocated is populated with a list of two widgets, aileron and ﬂap . Here
you can see the second, inner, allocation, which is the pointer to the next node
in the widget list.
type
( w i d g e t t )
: :
a i l e r o n ,
f l a p
associate
( c r n t
l i s t => wing%w i d g e t l i s t s ( 1 ) )
c r n t
l i s t%widget = a i l e r o n
a l l o c a t e
( widget node t
: : &
c r n t
l i s t%n e x t w i d g e t p t r ,
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0) &
c r n t
l i s t%n e x t w i d g e t p t r%widget = f l a p
end
associate
When deallocating, you need to proceed in the reverse order: First, you would
deallocate all nodes in each element of the allocatable array widget lists of
object wing, and then deallocate the array itself.
If it was possible to construct this data structure using allocatable variables
instead, one simple deallocation statement, of the most inclusive object, would
deallocate all components throughout the hierarchy. If, therefore, the pointer
components of types Widget list t and assembly t can be changed to allocat-
able arrays, all components of variable wing would be deallocated by the last
of the following statements:
type ,
public
: :
w i d g e t l i s t t
. . .
type
( w i d g e t t ) ,
a l l o c a t a b l e
: :
widgets ( : )
. . .
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
123
end type
w i d g e t l i s t t
type ,
public
: :
assembly t
. . .
type
( w i d g e t l i s t t ) ,
a l l o c a t a b l e
: :
w i d g e t l i s t s ( : )
. . .
end type
assembly t
deallocate
( wing ,
stat=a l l o c s t a t )
89. Establish a convention for tracking the owner of a pointer target.
Multiple pointers can be associated to a single pointer target. In the case
where the pointer target was originally allocated via an allocate statement, the
standard does not specify any “reference counting” or any other mechanism
to ensure that when all of the pointers are disassociated, the target memory
will be released. There is no “garbage collection” in Fortran. In order to avoid
memory leakage, a programmer must establish a convention for which area of
the code is responsible for deallocating the target.
In areas of code where the lifetime of the target is fairly short, for example,
within a few lines, it may be very obvious that the target is both allocated and
deallocated through the same pointer. The ownership is clear.
In contrast, a common situation is when a target is allocated in some subpro-
gram, then passed up the call chain to a different routine. Ownership of the
target might be considered the uppermost pointer with access to the target.
real ,
pointer
: :
i n p u t d a t a ( : )
. . .
c a l l
r e a d r o u t i n e
( i n p u t d a t a )
c a l l
compute routine
( i n p u t d a t a )
deallocate
( input data ,
stat=a l l o c s t a t )
One possibility of handling more complicated cases where there really are mul-
tiple pointers with simultaneous association with a target is to make the target
a private module variable and to deﬁne an accompanying module variable that
keeps track of the number of pointers associated with the target. User-written
routines, used with discipline, can then be used to control association.
Listing 7.2: Module Global target mod
module
Global target mod
i m p l i c i t
none
private
public
: :
Deallocate ,
N u l l i f y ,
P n t a t g l o b t a r g
!
t a r g e t & a s s o c i a t i o n
counter .
Neither
p u b l i c .
Cambridge Books Online © Cambridge University Press, 2012

124
MODERN FORTRAN
integer ,
pointer
: :
g l o b t a r g ( : ) => n u l l
()
integer ,
protected
: :
i r e f c n t = 0
i n t e r f a c e
Deallocate
module procedure
D e a l l o c a t e p n t r
end
i n t e r f a c e
i n t e r f a c e
N u l l i f y
module procedure
N u l l i f y p n t r
end
i n t e r f a c e
contains
subroutine
D e a l l o c a t e p n t r
( p n t r t o t a r g ,
r e t u r n s t a t )
integer
( kind=kind
( g l o b t a r g ) ) ,
intent
( in
out ) , &
pointer
: :
p n t r t o t a r g ( : )
integer ,
intent
( out )
: :
r e t u r n s t a t
enum ,
bind (C)
enumerator
: :
DEALLOC ERR = 1 , NO ASSOC, BAD ASSOC
end enum
integer
: :
a l l o c s t a t ,
i o n e p a s s
r e t u r n s t a t = 0
! ( A l t e r n a t i v e :
F2008 ,
one pass :
block
statement )
one pass :
do
i o n e p a s s = 1 , 1
!
check
a s s o c i a t i o n
i f
( i r e f c n t == 0
. or . &
. not .
associated
( g l o b t a r g ))
then
r e t u r n s t a t = NO ASSOC
e x i t
one pass
e l s e
i f
( . not .
associated
( p n t r t o t a r g , &
g l o b t a r g ))
then
r e t u r n s t a t = BAD ASSOC
e x i t
one pass
end
i f
i f
( i r e f c n t > 1)
then
!
f u r t h e r
a s s o c i a t i o n s
remain ,
only
n u l l i f y
c a l l
N u l l i f y
( p n t r t o t a r g )
e l s e
i f
( i r e f c n t == 1)
then
!
f i n a l
a s s o c i a t i o n
c a l l
n u l l i f y
( p n t r t o t a r g )
deallocate
( glob targ ,
stat=a l l o c s t a t )
i f
( a l l o c s t a t /= 0)
r e t u r n s t a t = DEALLOC ERR
end
i f
! ( A l t e r n a t i v e :
F2008 ,
end
block
one pass
statement )
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
125
end do one pass
end subroutine
D e a l l o c a t e p n t r
subroutine
N u l l i f y p n t r
( p n t r t o t a r g )
integer
( kind=kind
( g l o b t a r g ) ) ,
intent
( in
out ) , &
pointer
: :
p n t r t o t a r g ( : )
n u l l i f y
( p n t r t o t a r g )
i r e f c n t = i r e f c n t −1
end subroutine
N u l l i f y p n t r
function
P n t a t g l o b t a r g
()
r e s u l t
( p n t r t o t a r g )
integer
( kind=kind
( g l o b t a r g ) ) ,
pointer
: : &
p n t r t o t a r g ( : )
i r e f c n t = i r e f c n t + 1
p n t r t o t a r g => g l o b t a r g
end
function
P n t a t g l o b t a r g
end module
Global target mod
90. Use procedure pointers to invoke different subprograms possessing
identical interfaces.
Beginning with Fortran 2003, programmers can use procedure pointers. You
use them to choose between two or more subprograms that have identical
interfaces. In this rule, we discuss general procedure pointers and reserve that
for derived-type procedure pointer components to Rule 144.
The language has long possessed a restrictive and unchecked method for
accomplishing this task: You could pass the name of subprogram as an actual
argument and then invoke the dummy argument in the called procedure. In
the following snippet of code, written in FORTRAN 77 style, SUB1 and SUB2
are two different subroutines with the same interface, a single REAL dummy
argument. The name of the subroutine passed as an argument to subrou-
tine CALPRC depends of the value of an integer variable ICALL. Subroutine
CALPRC invokes the subroutine whose name was passed to it in dummy
argument SUBARG.
SUBROUTINE TOPPRC ( ICALL )
IMPLICIT NONE
INTEGER ICALL
EXTERNAL SUB1 , SUB2
IF
( ICALL
.LT.
0) THEN
CALL CALPRC (SUB1)
ELSE
CALL CALPRC (SUB2)
ENDIF
END
Cambridge Books Online © Cambridge University Press, 2012

126
MODERN FORTRAN
SUBROUTINE CALPRC (SUBARG)
IMPLICIT NONE
EXTERNAL SUBARG
REAL A
. . .
CALL SUBARG(A)
. . .
END
In the following code, procedure pointers are used to choose between two pos-
sible versions of a subprogram based on the value of a state variable debug on.
The standard permits the use of optional arguments in the interface; hence,
the calls can be different even though the interfaces must be identical, and this
is demonstrated.
Listing 7.3: Program Proc point test
module Calc mod
i m p l i c i t
none
private
public
: :
Calc debug ,
Calc normal ,
Calc proc
!
s e t
up an
i n t e r f a c e
to
be
used
by
the
procedure
!
statement
that
d e c l a r e s
the
procedure
p o i n t e r s .
i n t e r f a c e
function
Calc proc
( r e a l a r g ,
opt format ) &
r e s u l t
( r e t v a l )
real ,
intent
( in )
: :
r e a l a r g
character
(*) ,
intent
( in ) ,
optional
: :
opt format
r e a l
: :
r e t v a l
end
function
Calc proc
end
i n t e r f a c e
contains
!
two
f u n c t i o n s
whose
i n t e r f a c e s
conform
to
the
!
i n t e r f a c e
to
Calc proc .
function
Calc debug
( arg1 ,
opt format ) &
r e s u l t
( r e t v a l )
real ,
intent
( in )
: :
arg1
character
(*) ,
intent
( in ) ,
optional
: :
opt format
r e a l
: :
r e t v a l
r e t v a l = 0.0
p r i n t
* , ” with
debug”
. . .
end
function
Calc debug
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
127
function
Calc normal
( arg1 ,
opt format ) &
r e s u l t
( r e t v a l )
real ,
intent
( in )
: :
arg1
!
not
used ,
but must be
p r e s e n t .
character
(*) ,
intent
( in ) ,
optional
: :
opt format
r e a l
: :
r e t v a l
r e t v a l = 0.0
p r i n t
* , ” normal ”
. . .
end
function
Calc normal
end module Calc mod
program
P r o c p o i n t t e s t
use Calc mod ,
only
:
Calc debug ,
Calc normal , &
Calc proc
i m p l i c i t
none
!
d e c l a r e
procedure
p o i n t e r
that
p o i n t s
to
!
procedures
whose
i n t e r f a c e
conforms
to
the
!
i n t e r f a c e
of
Calc proc .
procedure
( Calc proc ) ,
pointer
: : &
c a l c f u n c p t r => n u l l
()
r e a l
: :
f u n c v a l u e = 0.0 ,
r e a l a r g = 0.0
integer
: :
i t w o p a s s
l o g i c a l
: :
debug on = . f a l s e .
do
i t w o p a s s = 1 , 2
i f
( debug on )
then
c a l c f u n c p t r => Calc debug
e l s e
c a l c f u n c p t r => Calc normal
end
i f
s e l e c t
case
( i t w o p a s s )
case
(1)
f u n c v a l u e = C a l c f u n c p t r
( r e a l a r g )
debug on
= . not .
debug on
case
(2)
f u n c v a l u e = C a l c f u n c p t r
( r e a l a r g ,
” (G15 . 8 ) ” )
end
s e l e c t
end do
end program
P r o c p o i n t t e s t
The program output is:
normal
with debug
Cambridge Books Online © Cambridge University Press, 2012

128
MODERN FORTRAN
7.3 Dynamic Data Attributes
91. Where possible and appropriate, use the intrinsic function kind in
conjuction with the instrinsic conversion functions int , real , and cmplx
when converting types.
Several situations exist where it may be useful to use the kind intrinsic function
in conjunction with intrinsic functions such as int, real, and cmplx. This can
help clarify potential portability, scalability, or accuracy problems inherent in
the default type conversion rules.
In arithmetic expressions involving mixed data types, the basic rule is that
less precise types, meaning those with less precision or those requiring fewer
storage units, are converted to the more precise type; they are “promoted.” The
following code assumes that both the default integer kind and default real kind
occupy four bytes of memory. The code deﬁnes two named constants using
the intrinsic functions selected int kind and selected real kind . The integer
kind corresponds to a single-byte integer; the real kind to double precision,
requiring eight bytes of storage. The declaration of four variables, two integers,
and two reals follow.
!
e s t a b l i s h
named
constants
f o r
two non−d e f a u l t
i n t e g e r s
!
and one non−d e f a u l t
r e a l .
integer ,
parameter
: :
BYTE 1 INT = s e l e c t e d i n t k i n d
(2)
integer ,
parameter
: :
D PREC = &
s e l e c t e d r e a l k i n d
(15 ,
307)
r e a l
: :
x d e f r e a l
r e a l
(D PREC)
: :
y doub
integer
: :
i d e f i n t
integer
( BYTE 1 INT )
: :
j b y t e i n t
The next section of code presents four mixed arithmetic expressions, with
comments describing the promotions.
!
Promote
i d e f i n t
to
d e f a u l t
r e a l
x d e f r e a l + i d e f i n t
!
Promote
j b y t e i n t
to
d e f a u l t
i n t e g e r
j b y t e i n t
*
i d e f i n t
! Two e x p r e s s i o n s ,
each
i n
parentheses ,
!
Promote
r e s u l t
of
the
second
to
d e f a u l t
r e a l .
( x d e f r e a l + i d e f i n t ) * ( i d e f i n t −j b y t e i n t )
!
Promote
r e s u l t
from
d e f a u l t
r e a l
to D PREC .
y doub = x d e f r e a l + i d e f i n t
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
129
When kind type parameters were introduced in Fortran 90, an optional kind
argument was introduced to the intrinsic functions that convert data types.
It is possible to think of the conversions the program is performing in the
previous expressions as implicit use of these conversion functions. Using them,
the last expression would be:
y doub = r e a l
( x d e f r e a l + &
r e a l
( i d e f i n t ,
kind=kind
( x d e f r e a l )
) , &
kind=kind
( y doub ))
You can override the default conversion behavior by using these conversion
functions; when you do, use the kind function. Here, for example, the require-
ment is to add the truncated value of a real number to whole number m int.
! No change
r e q u i r e d
i f
kind
of
m int
i s
changed .
i d e f i n t = m int + i n t
( x d e f r e a l ,
kind
( m int )
)
There exists one type of conversion where you do not use the kind function: You
may need to convert the type or the kind of an actual subprogram argument.
In the following two lines, the real kinds WORK PREC and SING PREC are
not the same:
r e a l
(WORK PREC)
: :
temperature
. . .
c a l l
Sub 1
( r e a l
( temperature ,
kind=SING PREC)
)
Another opportunity for using the kind function occurs in the case construct.
Here is an example where the execution branches based on the type of line
being processed.
subroutine
P r o c e s s l i n e
( t h i s )
. . .
type
( l i n e t ) ,
intent
( in )
: :
t h i s
. . .
s e l e c t
case
( t h i s%l i n e t y p e )
case
(SOLID)
. . .
case
(DASHED)
. . .
case
default
end
s e l e c t
. . .
end subroutine
P r o c e s s l i n e
Here,
line type
is an integer component of type
line t , and SOLID
and DASHED are named constants. The standard requires that all the
case-selector entities, such as SOLID, be of the same type and kind
as the case-expression , this %line type. To ensure this, the case construct
may be written:
Cambridge Books Online © Cambridge University Press, 2012

130
MODERN FORTRAN
s e l e c t
case
( t h i s%l i n e t y p e ,
kind=kind
(SOLID ))
case
( i n t
(SOLID ))
. . .
case
( i n t
(DASHED))
. . .
case
default
end
s e l e c t
which allows for subsequent changes in the kind of the component line type
without requiring modiﬁcation to the statements of the construct.
There are several situations where explicitly using the conversion functions,
even though they are not required, are worthwhile because they mark potential
problem spots.
The ﬁrst occurs when the program converts from a higher precision number
to a lower precision one, that is, the data is “narrowed.” With ﬂoating-point
numbers, the danger is, at best, a loss of precision; at worst, the generation of a
ﬂoating-point overﬂow exception. Using the variables x def real and y doub
that were declared in the previous code, the following code will generate such
an exception (see Section 13.3):
r e a l
(D PREC) ,
parameter
: :
HUGE DP = huge &
( 1 . 0 D PREC)
y doub
= HUGE DP
x d e f r e a l = y doub
It is best to signal to the reader that the program is executing a mixed-precision
operation requiring converting a ﬂoating-point number, with the danger of
raising an exception or losing precision, and to explicitly use the conversion
function with the kind argument.
x d e f r e a l = r e a l
( y doub ,
kind
( x d e f r e a l )
)
A more egregious problem can occur when converting integer values. Using the
variable j byte int that uses one byte of storage, the following code will not
work, meaning the expected assignment will not be correct because the number
on the right-hand side is too large to be expressed by a single-byte integer.
i d e f i n t = 20000
. . .
j b y t e i n t = i d e f i n t
Making the problem worse, Fortran is silent with integers; no warning will be
issued or exception raised, but the number will not be correct. To point out
the potential problem, write this using the conversion function using the kind
argument.
j b y t e i n t = i n t
( i d e f i n t ,
kind
( j b y t e i n t )
)
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
131
The second situation where the use of the conversion function with the
optional kind argument clariﬁes the code is with all the intrinsic functions
that return information about the size of an array or an index to an array
element as a default integer. These functions include size, ubound, maxloc,
and so on. If the size of the array exceeds the value that can be stored in a
default integer, use of these functions can result in an incorrect value being
returned. This is especially the case with large multi-dimensional arrays. So,
if the size of the following array my array exceeds the largest number that
can be stored in a default integer, the ﬁrst line of the following code pro-
duces an incorrect result; the second line at least points out the potential
problem.
i d e f i n t = s i z e
( my array )
. . .
i d e f i n t = i n t
( s i z e
( my array ) ,
kind
( i d e f i n t )
)
The ﬁnal situation involves the numeric instrinsic functions real, which con-
verts numbers to a real type, and cmplx, which converts one or two real
numbers to a complex one. The problem here is that these functions always
return a number of default kind, regardless of the kinds of the input arguments.
This can result in a silent loss of precision or a ﬂoating-point exception. To
override this behavior, you must specify the kind of the result as shown in the
second assignment in the following code:
! WORK PREC i s
not
d e f a u l t
r e a l .
integer ,
parameter
: : WORK PREC = &
s e l e c t e d r e a l k i n d
(14 ,
300)
complex ( kind=WORK PREC)
: :
c complex
r e a l
( kind=WORK PREC)
: :
x ,
y
. . .
c complex = cmplx ( x ,
y )
. . .
c complex = cmplx ( x ,
y ,
kind=WORK PREC)
92. Use the Fortran intrinsic functions lbound and ubound to determine
both the lower and upper limits of iterations performed using the do
construct and both the lower and upper limits of array assignments accom-
plished using both the forall and where statements and the forall and the
where constructs.
If this rule is followed, changes to both the dimensions and the bounds
of arrays require only minor modiﬁcations to the code. It also helps avoid
inadvertently referencing out-of-bound array elements and makes the loop
more self-contained. In cases where the lower bound is known to be 1, the
size intrinsic function may also be used for the upper bound.
In the ﬁrst example next, a loop is performed over a three-dimensional array
of volume elements, one of whose components (not all are shown) is the ﬂuid
Cambridge Books Online © Cambridge University Press, 2012

132
MODERN FORTRAN
ﬂow velocity vector at the center of the element. The program calls a function
that computes the Reynold’s number of an element, and the section then is
highlighted if its value exceeds a certain limit. The second example shows an
assignment that employs a forall statement:
type ,
public
: :
v o l e l e m e n t t
r e a l
: :
v e l o c i t y (3)
. .
other
components
contains
procedure
: :
Comp rey no
procedure
: :
H i g h l i g h t s e c t i o n
end type
v o l e l e m e n t t
integer
: :
jstrm ,
jxstrm ,
jdepth
!
loop
s u r f a c e
to
bottom ,
l e f t
bank
to
r i g h t
bank ,
!
upstream
to
downstream
do
jdepth = lbound
( vols ,
dim=3) , ubound ( vols ,
dim=3)
do
jxstrm = lbound
( vols ,
dim=2) , ubound ( vols ,
dim=2)
do
jstrm = lbound
( vols ,
dim=1) , ubound ( vols , dim=1)
i f
( v o l s ( jstrm ,
jxstrm ,
jdepth)%Comp rey no
() &
>= t u r b l i m )
c a l l
v o l s ( jstrm ,
jxstrm , &
jdepth)% H i g h l i g h t s e c t i o n
()
end do
end do
end do
f o r a l l
( i = lbound
(amps ,
dim=1): ubound (amps ,
dim=1) , &
j = lbound
(amps ,
dim=2): ubound (amps ,
dim=2) , &
amps ( i ,
j ) /= 0 . 0 ) &
y ( i ,
j ) = 1.0
/ amps ( i ,
j )
93. Use the intrinsic functions shape and reshape when initializing arrays
of rank 2 or larger.
The following example illustrates assigning a 2-by-2 array from a vector:
r e a l
: :
bounds (2 ,
2)
bounds = reshape
( [ 1 0 . 0 ,
−10.0 ,
20.0 ,
−20.0] , &
shape
( bounds ))
94. When specifying the kind of both subprogram dummy arguments and
function results, take advantage of the fact that Fortran knows the kind of
a data type.
The kind function permits you to determine the kind of data types. You
can exploit this when declaring the kinds of dummy arguments and function
results. This is especially useful when writing accessor subprograms that set and
retrieve the values of components: You do not need to make any modiﬁcation
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
133
to the following two subprograms if you need to change the kind of the real a
to a real number with a different precision.
module Mod a
i m p l i c i t
none
private
type ,
public
: :
t y p e a t
r e a l
( s e l e c t e d r e a l k i n d
(15 ,
307)) ,
private
: : &
r e a l a
contains
procedure
: :
G e t r e a l a
procedure
: :
S e t r e a l a
end type
t y p e a t
contains
function
G e t r e a l a
( t h i s ) ,
r e s u l t
( r e t u r n v a l u e )
c l a s s
( t y p e a t ) ,
intent
( in )
: :
t h i s
r e a l
( kind
( t h i s%r e a l a ))
: :
r e t u r n v a l u e
r e t u r n v a l u e = t h i s%r e a l a
end
function
G e t r e a l a
subroutine
S e t r e a l a
( t h i s ,
s e t v a l u e )
c l a s s
( t y p e a t ) ,
intent
( in
out )
: :
t h i s
r e a l
( kind
( t h i s%r e a l a ) ) ,
intent
( in )
: :
s e t v a l u e
t h i s%r e a l a = s e t v a l u e
end subroutine
S e t r e a l a
end module Mod a
7.4 Control Flow
95. Always include the stat= option in all allocate and deallocate state-
ments; always check its value.
The standard speciﬁes that a program will stop if it encounters a problem
allocating memory for a pointer or an allocatable data entity using the allocate
statement, or deallocating memory using the deallocate statement if the stat=
option is not included in the statements. From the point of view of the user,
this is the same as the program crashing. Use the stat= option to fail gracefully.
Starting with Fortran 2003, you can also use the errmsg= option with both
of these statements to obtain an explanatory message when an error occurs.
use
i so fortran env ,
only
: ERROR UNIT
integer ,
parameter
: :
ERR MSG LEN = 200
character (*) ,
parameter
: : PROC NAME = ” Calc temp :
”
integer ,
a l l o c a t a b l e
: :
i n t a r y ( : )
character
(ERR MSG LEN)
: :
a l l o c e r r m s g
Cambridge Books Online © Cambridge University Press, 2012

134
MODERN FORTRAN
integer
: :
a l l o c s t a t ,
a r y s i z e
. . .
a r y s i z e = 10
i f
( . not .
allocated
( i n t a r y ))
then
a l l o c a t e
( integer
: :
i n t a r y ( a r y s i z e ) , &
stat=a l l o c s t a t ,
errmsg=a l l o c e r r m s g )
i f
( a l l o c s t a t /= 0)
then
write
(ERROR UNIT,
” (A) ” ) PROC NAME // &
trim
( a l l o c e r r m s g )
. .
code
handling
the
f a i l e d
a l l o c a t i o n
end
i f
end
i f
Handling error situations and returning control back to the caller with an
indication of the error status also assists when writing unit tests, so that both
normal and erroneous situations can be tested.
96. Check the status of allocatable entities using the allocated intrinsic
function before allocating or deallocating them.
It is an error to allocate an allocatable entity that is already allocated or to
deallocate an entity that is not allocated. Use of the allocated function permits
you to avoid this error by testing the allocation status of the variable (see also
Rules 79, 80, and 95).
integer ,
a l l o c a t a b l e
: :
f l o w g r i d ( : ,
: )
integer
: :
a l l o c s t a t
. . .
i f
( allocated
( f l o w g r i d ))
then
deallocate
( f l o w g r i d ,
stat=a l l o c s t a t )
. . .
end
i f
97. Write all loops that index arrays of rank 2 or greater such that the
innermost (ﬁrst) rank varies ﬁrst, then the next most inner loop, and
so on.
To perform calculations, data is transferred between a computer’s main mem-
ory and its central processing unit (CPU). The speed the processor works is
far faster than the data transfer rate between memory and the CPU, by as
much as two orders of magnitude or more. To mitigate this problem, cache
memory units are placed in the data pipeline between the CPU and main
memory. The data transfer rate between them and the CPU is faster than from
main memory; if data can be kept in cache memory, the overall computing
speed increases. One way to achieve this is to transfer data that is contiguous,
meaning data that occupies consecutive memory addresses (see Rule 98).
Fortran stores arrays in memory such that the ﬁrst subscript runs through
all its possible values, then the second, the third, and so on. This is the
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
135
opposite of C/C++. For rank 2 arrays this is column order. To avoid large
jumps in memory references, which cause poor use of cache memory, and the
accompanying increase in execution time, arrange loops to vary the indices in
the appropriate order as shown in this example:
do
j c o l = 1 , ubound (a ,
dim=2)
do
i r o w = 1 , ubound (a ,
dim=1)
a ( i row ,
j c o l ) = i r o w
* a ( i row ,
j c o l ) + j c o l
end do
end do
98. Where possible, assign the contiguous attribute to assumed-shape
arrays and array pointers to improve performance.
The contiguous attribute, new in Fortran 2008, allows the programmer to assist
the compiler (see Reference [43]). Assumed-shape array dummy arguments
assigned this attribute can be argument associated only with a contiguous
actual argument and pointers thus assigned can be pointer associated with
solely contiguous targets.
Contiguous arrays occupy consecutive locations in memory. If the compiler
knows that an array is contiguous, it can generate optimized code and avoid
unnecessary copying of data when invoking subprograms. So, whenever pos-
sible, assign this attribute as shown here:
real ,
intent
( in ) ,
contiguous
: :
c o n t i g a r r a y a r g ( : )
integer ,
pointer ,
contiguous
: :
i n t p t r ( : )
You could, for example, create two subroutines, identical except for their
interfaces: The ﬁrst would use the argument contig array arg shown in the
previous example; the second would use an argument not possessing the
contiguous attribute.
subroutine
C a l c v o r t f a s t
( vort ,
c o n t i g a r r a y a r g )
real ,
intent
( in
out )
: :
v o r t ( : )
real ,
intent
( in ) ,
contiguous
: :
c o n t i g a r r a y a r g ( : )
end subroutine
C a l c v o r t f a s t
subroutine
C a l c v o r t s l o w
( vort ,
n o n c o n t i g a r r a y a r g )
real ,
intent
( in
out )
: :
v o r t ( : )
real ,
intent
( in ) ,
: :
n o n c o n t i g a r r a y a r g ( : )
end subroutine
C a l c v o r t s l o w
You would call the ﬁrst subroutine with contiguous arrays and the second with
noncontiguous ones. This can easily be determined using the new-to-Fortran
2008 intrinsic function is contiguous that returns a logical scalar indicating if
an array is contiguous:
i f
( is contiguous
( a r r a y 1 ))
then
c a l l
C a l c v o r t f a s t
( v o r t v a l s ,
a r r a y 1 )
Cambridge Books Online © Cambridge University Press, 2012

136
MODERN FORTRAN
e l s e
c a l l
C a l c v o r t s l o w
( array 1 ,
v o r t v a l s )
end
i f
99. Code all logical tests that make up the scalar logical expressions of an
if construct such that they can always be successfully executed.
Unlike some other languages, such as C, Fortran is not required to “short
circuit” when testing logical expressions in if constructs and statements. In
some cases this requires nesting if blocks. A program containing the code
below with the ﬁrst block if construct will most likely crash when Sub a is
called without the optional argument. The if construct needs to be divided
into two as shown in the nested blocks.
subroutine
Sub a
( arg 1 ,
switch )
real ,
intent
( in
out )
: :
arg 1
integer ,
intent
( in ) ,
optional
: :
switch
!
I n c o r r e c t
code :
i f
( present
( switch )
. and .
switch > 0)
then
. . .
end
i f
!
Correct
code :
i f
( present
( switch ))
then
i f
( switch > 0)
then
. . .
end
i f
end
i f
In the next example, the square root of the difference of two numbers is tested
in the same logical expression that the sign of the difference is tested to see if
it is positive. This also needs to be separated into nested blocks:
r e a l
: :
a ,
b
!
I n c o r r e c t
i f
( a > b
. and .
sqrt
( a −b ) > 1 . 0 )
then
!
Correct
i f
( a > b )
then
i f
( sqrt
( a −b ) > 1 . 0 )
then
100. Use a single-pass loop to avoid deeply nested constructs.
Often a situation arises in which a series of checks must be performed. At each
step, one of two conditions exist: There is no error and the execution may
continue; or some type of error condition exists, and the execution ﬂow of the
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
137
program branches from the normal, error-free, ﬂow. This can lead to code that
looks, in skeleton form, like this:
i f
( e r r o r f l a g 1 /= 0)
then
c a l l
L o g e r r o r
( e r r o r t a b l e ,
e r r o r f l a g 1 )
e l s e
. . .
i f
( e r r o r f l a g 2 /= 0)
then
c a l l
L o g e r r o r
( e r r o r t a b l e ,
e r r o r f l a g 2 )
e l s e
. . .
i f
( e r r o r f l a g 3 /= 0)
then
c a l l
L o g e r r o r
( e r r o r t a b l e ,
e r r o r f l a g 3 )
e l s e
!
normal
e r r o r −f r e e
program
flow
. . .
end
i f
end
i f
end
i f
This leads to excessive indentation and the logic is convoluted. One possible
alternative is to employ a labeled loop that only iterates once and to use exit
statements to branch out of it:
t h i s b l o c k :
do ,
i m u l t i e x i t = 1 , 1
i f
( e r r o r f l a g 1 /= 0)
then
c a l l
L o g e r r o r
( e r r o r t a b l e ,
e r r o r f l a g 1 )
e x i t
t h i s b l o c k
end
i f
. . .
i f
( e r r o r f l a g 2 /= 0)
then
c a l l
L o g e r r o r
( e r r o r t a b l e ,
e r r o r f l a g 2 )
e x i t
t h i s b l o c k
end
i f
. . .
i f
( e r r o r f l a g 3 /= 0)
then
c a l l
L o g e r r o r
( e r r o r t a b l e ,
e r r o r f l a g 3 )
e x i t
t h i s b l o c k
end
i f
!
normal
program
flow
. . .
end do
t h i s b l o c k
Fortran 2008 introduces the ideal solution, the block construct that provides
the programmer with a more elegant alternative: Instead of enclosing the code
above with the single-pass loop, use the block construct. Variables may also
be declared within a block costruct, in which case their scope is limited to the
construct.
Cambridge Books Online © Cambridge University Press, 2012

138
MODERN FORTRAN
t h i s b l o c k :
block
!
scope
of
i s t a g e
l i m i t e d
to
block
integer
: :
i s t a g e
!
. . .
code
with
m u l t i p l e
e x i t
p o i n t s
e x i t
t h i s b l o c k
!
. . .
normal
program
flow
end block
t h i s b l o c k
7.5 Character String Expressions
101. For portability, use the lexical comparison functions llt , lle , lge, and
lgt to compare character strings.
If there is any chance your program will be used on more than one platform,
where the default character set may be different than the one the program is
developed on, write:
i f
( l l t
( s t r i n g 1 ,
s t r i n g 2 ))
. . .
and not the relational operator < as in
i f
( s t r i n g 1 < s t r i n g 2 )
. . .
The reason for this is that the “collating sequence,” the ordering of the letters,
digits, and special characters, differs between character sets, but “alphabetical
order” is required by the standard, so A < B <... < Z. The relational operators
use the ordering of the native character set. When that ordering changes, such
as when a program that was developed on a machine using the ASCII character
set is run on a machine that uses the EBCDIC character set, the results of the
program may differ from the intended results.
The same issue occurs with the char and ichar intrinsic functions. These
convert characters to the numeric ordinal of the machine’s default character
set and back. Since the ordinals can vary between character sets, it is usually
best to specify them directly in terms of the ASCII character set. The achar
and iachar intrinsic functions are used to internally convert between ASCII
numerical values and whatever character set is in use.
The following is a simple function to convert a string to lowercase. It is written
in terms of the ASCII character set. For portability, it uses achar and iachar to
ensure it will work on other character sets.
Listing 7.4: Function To lower
elemental
function
To lower
( s t r i n g )
r e s u l t &
( r e t u r n s t r i n g )
character ( len =*) ,
intent
( in )
: :
s t r i n g
character ( len=len
( s t r i n g ))
: :
r e t u r n s t r i n g
Cambridge Books Online © Cambridge University Press, 2012

PROGRAMMING CONVENTIONS
139
integer ,
parameter
: :
UPPER A = iachar
( ’A’ ) , &
UPPER Z = iachar
( ’Z ’ )
integer ,
parameter
: :
DELTA LOWER UPPER = &
iachar
( ’ a ’ ) −iachar
( ’A’ )
integer
: :
c
integer
: :
i
do ,
i =1,
len
( s t r i n g )
c = iachar
( s t r i n g ( i : i ))
i f
( c >= UPPER A . and .
c <= UPPER Z) &
c = c + DELTA LOWER UPPER
r e t u r n s t r i n g ( i : i ) = achar
( c )
end do
end
function
t o l o w e r
It should be noted that while most computers at the time of this writing use the
ASCII character set, newer encodings, such as Unicode, are being developed.
Fortran allows for non-default character kinds. As with numeric kinds, the
support for non-default kinds varies from compiler to compiler.
character ( kind=UNICODE K ,
len =:) ,
a l l o c a t a b l e
: : &
u n i c o d e s t r i n g
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

8.
Input and Output
Reading data and writing results are fundamental operations that are common
to almost all programs. Fortran provides a built-in set of input/output (I/O)
statements. These statements generally operate on data ﬁles residing on disk
drives, and with devices, such as keyboards and console displays, which can be
presented to a program by the operating system in a ﬁle-like manner. Different
devices have different capabilities, so not all operations are supported on each
one. The executable I/O statements, divided into two groups, are shown in
Table 8.1.
Fortran has always structured its I/O capabilities around the read and write
statements. These statements operate on Fortran “units,” which are represented
by simple cardinal numbers called “unit numbers.” A unit that is connected
to a data ﬁle typically occupies system resources, such as buffers and ﬁle
descriptors, from the time it is connected, when the ﬁle is opened, until the
time it is disconnected using the close statement.
8.1 General I/O Operations
102. Use the named constants in the intrinsic module iso fortran env.
The intrinsic module
iso fortran env provides named constants to help
make applications portable. These named constants include values for
standard input, output, and error unit numbers, such as INPUT UNIT,
OUTPUT UNIT, and various values returned by the iostat speciﬁer, such
as IOSTAT END, an argument common to many of the I/O statements that
return an integer indicating the success or the failure of the I/O operation (see
Rules 104 and 105).
These named constants should always be used instead of hard coding constants
such as the numbers 5 and 6 for units.
use
i s o f o r t r a n e n v
. . .
r e a d p o i n t s :
do
read
(INPUT UNIT,
* ,
i o s t a t=i o e r r o r ) x ,
y ,
z
s e l e c t
case
( i o e r r o r )
case
(IOSTAT END)
e x i t
case
default
write
(ERROR UNIT,
*) ” input
e r r o r
encountered ”
140
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
141
Table 8.1. Executable I/O statements
Statement
Purpose
Main Statements
close
Release a ﬁle from a unit number
inquire
Obtain information about ﬁles and units
open
Associate a ﬁle to a unit number
print
Write formatted data to the default output unit
read
Read formatted and unformatted data from a unit
write
Write formatted and unformatted data to a unit
Auxliliary Statements
backspace
Position a sequential access unit back one record
endfile
Write a sequential “end-of-ﬁle” record (obsolete)
flush
Ensure coherency between any buffering and the unit
rewind
Position a sequential access unit to its beginning
wait
Wait for an asynchronous I/O operation to complete
stop 1
end
s e l e c t
. . .
end do
r e a d p o i n t s
103. Manage unit numbers as a resource.
All user-deﬁned unit numbers should be centrally managed. A module is a
convenient place for this purpose. At a minimum, named constants should
be provided for each unit number, such as GRID UNIT, TEMP UNIT, and so
forth, as shown at the beginning of the following module Lun mod. Fortran
processors typically predeﬁne single digit unit numbers such as 5 and 6, and
implementations vary. So the code starts with unit 10 to avoid them:
Listing 8.1: Module Lun mod
module Lun mod
i m p l i c i t
none
!
Use
enumerators
to
p r o v i d e
unique
o r d i n a l s .
enum ,
bind
(C)
enumerator
: :
NO UNIT = −1, &
GRID UNIT = 10 , TEMP UNIT, PRESSURE UNIT , &
LU LOWER, LU UPPER = 99
end enum
private
public
: :
GRID UNIT ,
Get LUN , PRESSURE UNIT , TEMP UNIT
integer ,
parameter
: :
PRESET ERROR = 1
Cambridge Books Online © Cambridge University Press, 2012

142
MODERN FORTRAN
contains
subroutine
Get LUN ( lun ,
i o s t a t )
integer ,
intent
( out )
: :
lun
integer ,
intent
( out )
: :
i o s t a t
integer
: :
i
l o g i c a l
: :
i s o p e n
!
Preset
e r r o r
c o n d i t i o n .
i o s t a t = PRESET ERROR
lun
= NO UNIT
do ,
i=LU LOWER, LU UPPER
i n q u i r e
( unit=i ,
opened=i s o p e n )
i f
( . not .
i s o p e n )
e x i t
end do
i f
( i <= LU UPPER)
then
!
Found an unused
u n i t .
i o s t a t = 0
lun
= i
end
i f
end subroutine
Get LUN
end module Lun mod
In applications where many unit numbers are opened and closed, or in the
case of a library routine that might be mixed with any number of applications,
it may be better to develop a routine to dole out unit numbers on an as-needed
basis. Before an open statement, a routine can be called to search a range of
unit numbers for one that is currently unused. The inquire statement may be
used for this purpose. Subroutine Get LUN in the previous module performs
this task.
This code had two potential problems: The named constants may need to be
adjusted for different processors; and the Get LUN is not atomic and could fail
in a concurrent programming environment such as OpenMP.
To at least partially ﬁx the latter problem, the Get LUN procedure would need
to remember which unit numbers it has doled out, perhaps via a private array
at module scope. A companion Free LUN routine would need to be used to
mark the unit number as unused after a close statement was used.
To avoid these problems altogether, Fortran 2008 allows an open statement to
issue a unique unit number and return it for use in later I/O statements such as
read and write. This capability is speciﬁed via the newunit speciﬁer. The unit
number returned has a negative value, so as to not conﬂict with user-deﬁned
unit numbers, which must, by the standard, be nonnegative integers.
open ( newunit=e l e v u n i t ,
f i l e =’ e l e v a t i o n d a t a . txt ’ , . . . )
read
( unit=e l e v u n i t ,
i o s t a t=i o e r r )
e l e v a t i o n s
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
143
104. Use the optional iostat= speciﬁer in all input/output statements to
verify that the operation was successful and to control the program ﬂow.
Always consider checking the success or failure of input/output (I/O) opera-
tions. The statements read, write, open, close , backspace, endﬁle , rewind,
and inquire all accept the optional speciﬁer iostat=. The alternative, letting
the program abort on an error, can prevent proper unit testing. It also does
not lead to “user-friendly” applications (see Rule 118).
Generally open statements and the ﬁrst read or write statements on a unit
are the most susceptible to ﬁle access errors. Read statements are especially
vulnerable to bad input ﬁles created by other programs. On output, checking
iostat may not be very important on small ﬁles. However, when writing
voluminous output, the operation can be affected by available disk space or
other device restrictions, so it should be checked.
The iso fortran env intrinsic module contains two named constants that can
be used in conjunction with the iostat= speciﬁer. These are IOSTAT END,
the value returned by iostat when an end-of-ﬁle condition is encountered,
and IOSTAT EOR, the value when an end-of-record condition is encoun-
tered. (IOSTAT EOR is used when performing partial record processing with
advance=’no’.) Also, the iomsg= speciﬁer may be used to obtain the error
message associated with the iostat=value (see Rule 102).
Here is an example demonstrating the use of these named constants and
iomsg= with the read statement when reading from a ﬁle that contains an
unknown number of records. You can use the value returned by the iostat=
speciﬁer to terminate reading (see Rule 80).
use
i so fortran env ,
only
: :
IOSTAT END, IOSTAT EOR
integer ,
parameter
: :
READ UNIT = 10 , IOMSG LEN = 200 , &
NAME LEN = 50
character
(IOMSG LEN)
: :
io mess
character
(NAME LEN)
: :
emp name
integer
: :
i o s t a t ,
emp id ,
n o r e c s
r e a l
: :
s a l a r y
!
read
and
count
input
r e c o r d s .
n o r e c s = 0
r e a d i n p u t :
do
!
t r y
to
read
a
record .
read
( unit=READ UNIT ,
fmt=” ( i9 ,
a ,
f10 . 3 ) ” , &
i o s t a t=i o s t a t ,
iomsg=io mess )
emp id , &
emp name ,
s a l a r y
!
p r o c e s s
read :
( end−of−record
c o n s t i t u t e s
an
e r r o r )
s e l e c t
case
( i o s t a t )
case
(: −1 , IOSTAT EOR)
Cambridge Books Online © Cambridge University Press, 2012

144
MODERN FORTRAN
c a l l
P r o c e s s e r r
( r e a d u n i t ,
i o s t a t ,
io mess )
case
(IOSTAT END)
c a l l
P r o c e s s e n d o f i n p u t
( n o r e c s )
case
default
end
s e l e c t
!
have a
record ,
so
count
i t
and
p r o c e s s
i t .
n o r e c s = n o r e c s + 1
c a l l
Process name
( emp id ,
trim
( emp name ) ,
s a l a r y , &
n o r e c s )
end do
r e a d i n p u t
105. Use open and close statements for all data ﬁles.
All data ﬁles should have associated open statements to dynamically open
the ﬁle. The open statement also serves to document the ﬁle, its access,
and usage. Preconnected unit numbers, with the exception of INPUT UNIT,
OUTPUT UNIT, and ERROR UNIT should be avoided for two reasons: They
are not self-documenting, and implementation varies considerably between
Fortran environments. Although the only required speciﬁer in an open state-
ment is unit for the unit number, more speciﬁers should be used for their
documentation value. Especially recommended for all ﬁles are the following
speciﬁers:
■ﬁle (the ﬁle name)
■access (“sequential,” “direct,” “stream”)
■status (“new,” “old,” “unknown,” “replace,” “scratch”)
■action (“read,” “write,” “readwrite”)
■
iostat (to handle errors)
■iomsg (to provide error message text)
The status and action speciﬁers allow the runtime library to check for the
expected state of the ﬁle as early as possible.
Here is code that demonstrates opening and reading from a ﬁle. It uses the
iomsg and the F2008 newunit speciﬁers as well as some of the familiar ones
previously described.
Listing 8.2: Subroutine Process elev ﬁle
subroutine
P r o c e s s e l e v f i l e ()
use
i so fortran env ,
only
: ERROR UNIT
integer ,
parameter
: :
IOMSG LEN = 200
character (*) ,
parameter
: :
ELEV FILE = ’ e l e v d a t a . txt ’
character ( len=IOMSG LEN)
: :
i o t x t
integer
: :
i o e r r ,
e l e v u n i t
open ( newunit=e l e v u n i t ,
f i l e=ELEV FILE , &
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
145
status =’old ’ ,
action =’read ’ ,
i o s t a t=i o e r r , &
iomsg=i o t x t )
i f
( i o e r r /= 0)
then
write
(ERROR UNIT,
*)
’ problem
opening :
’ , &
ELEV FILE ,
’ f o r
reading . ’
write
(ERROR UNIT,
*)
’
message
:
’ , &
trim
( i o t x t )
stop 1
!
Or
r e t u r n
an
e r r o r
to
the
c a l l e r .
end
i f
do
read
( e l e v u n i t ,
* ,
i o s t a t=i o e r r ,
iomsg=i o t x t ) &
height ,
temperature ,
p r e s s u r e
i f
( i o e r r /= 0)
e x i t
end do
i f
( i o e r r /= IOSTAT END)
then
write
(ERROR UNIT,
*)
’ problem
reading :
’ ,
ELEV FILE
write
(ERROR UNIT,
*)
’
message
:
’ , &
trim
( i o t x t )
stop 2
!
Or
r e t u r n
an
e r r o r
to
the
c a l l e r .
end
i f
end subroutine
P r o c e s s e l e v f i l e
106. Use the inquire statement for computing direct-access record length.
Direct access ﬁles have ﬁxed-length records. The record size must be speciﬁed
in the open statement with the recl speciﬁer. The units used in the recl
speciﬁer are called ﬁle storage units or FSUs. It is implementation deﬁned as
to how a FSU is measured. Generally it is either the size of a character (e.g.,
8-bit bytes), or in numeric storage unit, NSU, size (e.g., often 32-bits for many
modern computers). It is also often difﬁcult to reliably calculate the total record
size when the I/O list is composed of different data types, each with speciﬁc
alignment requirements. Compilers will also vary as to padding requirements
speciﬁc to the machine and environment.
To be able to compute the size of the record in a portable manner, the inquire
statement should be used. In this mode, the inquire statement is written very
much like a read or write statement for the ﬁle, because it has an I/O list. The
record length for the given I/O list is returned via the recl value:
character ( len=DESCRIPTION LEN)
: :
f i l
t x t
r e a l
: :
x pos ,
y pos ,
z pos
integer
: :
p o i n t r e c l ,
i r e c ,
i o e r r ,
p o i n t u n i t
character
( len=IOMSG LEN)
: :
msgtxt
. . .
i n q u i r e
( r e c l=p o i n t r e c l )
f i l t x t ,
x pos ,
y pos ,
z pos
open ( unit=p o i n t u n i t ,
f i l e =’ p o i n t s f i l e ’ ,
&
Cambridge Books Online © Cambridge University Press, 2012

146
MODERN FORTRAN
access =’ direct ’ ,
r e c l=p o i n t r e c l ,
status =’ old ’ , &
action =’read ’ ,
i o s t a t=i o e r r ,
iomsg=msgtxt )
. . .
read
( p o i n t u n i t ,
rec=i r e c ,
i o s t a t=i o e r r , &
iomsg=msgtxt )
f i l t x t ,
x pos ,
y pos ,
z pos
107. When reading or writing arrays, use implied loops only when the
storage order needs to be changed from the default.
Use the array name rather than implied do loops in the I/O list when reading
or writing an entire array. Implied do loops can be hard to read. Moreover,
some compilers have been known to call their internal I/O library on an
element-by-element basis, which may cause a hidden performance problem
on large ﬁles. By simply stating the name of the array, the code is clear and it
executes quickly. Here are two examples, one showing a complete matrix, the
second an array section (see Rule 31):
integer
: :
my data ( : , : )
integer
: :
i o e r r
character
( len=IOMSG LEN)
: :
msg txt
. . .
write
( unit=data unit ,
i o s t a t=i o e r r , &
iomsg=msg txt )
my data
integer
: :
my data ( : , : )
integer
: :
i1 ,
i2 ,
j1 ,
j2
. . .
write
( unit=d a t a u n i t )
my data ( i 1 : i2 ,
j1 : j2 )
The implied do should be reserved for cases where the normal Fortran column-
wise storage order is not wanted. The following code builds a run-time format
and then writes out a matrix by rows:
r e a l
: :
r e s u l t t a b l e ( : , : )
character (FRMT LEN)
: :
frmt
integer
: :
i ,
j
!
P r i n t
the
t a b l e
i n human r e a d a b l e
form .
write
( frmt ,
’( a ,
i0 ,
a ) ’ )
’ ( ’ , &
ubound ( r e s u l t t a b l e ,
dim=2) ,
’ f8 . 4 ) ’
do ,
i =1, ubound ( r e s u l t t a b l e ,
dim=1)
write
(* ,
frmt )
( r e s u l t t a b l e ( i , j ) , &
j =1, ubound ( r e s u l t t a b l e ,
dim=2) )
end do
108. Use the same formats and I/O lists when writing, and reading back,
a data ﬁle.
It is common for a program to write intermediate data to a ﬁle and then, at
some later time, read the results back in. The reading program could be the
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
147
same program that wrote the ﬁle, or perhaps a different program written by a
different author.
The I/O lists in the write statements should be identical to the I/O lists on
the corresponding read statements. This ensures that the data items and the
record lengths written out are the same as those expected when reading the
data back. For example:
write
( temp unit ,
i o s t a t=i o e r r o r )
i ,
j ,
k ,
r ,
s ,
t
. . .
read
( temp unit ,
i o s t a t=i o e r r o r )
i ,
j ,
k ,
r ,
s ,
t
Sometimes the I/O lists will differ in small ways but can still be arranged so
that they are as close as possible to the eye. This example writes out the sizes
of arrays before writing the arrays themselves. The reader is expected to read
the size of the arrays, allocate space for them, and then read the arrays.
write
( temp unit ,
i o s t a t=i o e r r o r )
s i z e
( a r r 1 ) , &
s i z e
( a r r 2 )
write
( temp unit ,
i o s t a t=i o e r r o r )
arr 1 ,
a r r 2
. . .
rewind
( temp unit ,
i o s t a t=i o e r r o r )
read
( temp unit ,
i o s t a t=i o e r r o r )
a r r 1 l e n ,
a r r 2 l e n
a l l o c a t e
( a r r 1 ( a r r 1 l e n ) ,
stat=a l l o c e r r o r )
a l l o c a t e
( a r r 2 ( a r r 2 l e n ) ,
stat=a l l o c e r r o r )
read
( temp unit ,
i o s t a t=i o e r r o r )
arr 1 ,
a r r 2
With formatted I/O, named character constants, and character strings in gen-
eral, may be an alternative to the traditional format statements. An advantage
of these is that they can be located at module scope, so that a common def-
inition may be used between procedures. When written as named constants,
compilers will often check the formats for errors as thoroughly as they do
format statements.
109. Read and write only a single data record in each data transfer
statement.
In formatted I/O, the format speciﬁcations can become fairly complex if more
than a single operation is carried out in one write statement. It is recommended
that only a single record be written or read per data transfer statement to make
the code easier to comprehend. An exception might be made during reading
where records need to be skipped. Where this occurs, a comment should be
inserted describing what is being skipped as shown here (*Cmnt-1):
write
( r e p u n i t ,
* ,
i o s t a t=i o e r r )
’ Output
t a b l e : ’
write
( r e p u n i t ,
* ,
i o s t a t=i o e r r ) &
’ index
d e s c r i p t i o n
values ’
write
( r e p u n i t ,
* ,
i o s t a t=i o e r r ) &
’−−−−−−−−−−−−−−−−−−−−−−−−−’
do ,
i =1, ubound ( o b j e c t s )
Cambridge Books Online © Cambridge University Press, 2012

148
MODERN FORTRAN
write
( r e p u n i t ,
fmt=’( i0 ,
a ,
f10 . 4 ) ’ , &
i o s t a t=i o e r r )
i ,
o b j e c t s ( i )% d e s c r i p t i o n , &
o b j e c t s ( i )%num value
end do
. . .
rewind
( r e p u n i t ,
i o s t a t=i o e r r )
!
*Cmnt−1: comment
s k i p p i n g
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r )
!
s k i p
t i t l e
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r )
!
s k i p
c o l .
t i t l e
read
( r e p u n i t ,
* ,
i o s t a t=i o e r r )
!
s k i p
hyphens
do ,
i =1, ubound ( o b j e c t s )
read
( r e p u n i t , ’ ( i0 ,
a , f10 . 4 ) ’ ,
i o s t a t=i o e r r )
&
i ,
o b j e c t s ( i )% d e s c r i p t i o n ,
o b j e c t s ( i )%num value
i f
( i o e r r /= 0)
e x i t
end do
110. When writing I/O routines for each derived type, consider using
deﬁned derived-type I/O.
Derived types are commonly packaged in modules with procedures that pro-
cess fundamental operations pertaining to that type. All derived types should
have I/O routines for an object of that type, at least one to print debugging
information (see Rule 133).
Routines for writing to ﬁles and reading from input ﬁles can also be imple-
mented. Prior to Fortran 2003, a limited set of default rules governed I/O
on derived types. Starting with Fortran 2003, the derived-type I/O (DTIO)
facility may be used to override the default rules by specifying user-provided
routines for performing I/O on a type.
User-provided DTIO routines are speciﬁed in the type-bound procedure sec-
tion of a type declaration. They have a speciﬁc dummy argument list that
is deﬁned by the Fortran standard. With formatted I/O, the DTIO facil-
ity is invoked by using the “DT” edit descriptor in the format of read and
write statements. List-directed and namelist forms of formatted I/O are also
supported (see Rule 112). Here is an example:
Listing 8.3: Program DTIO demo
module My type mod
i m p l i c i t
none
private
type ,
public
: :
my type t
integer
: :
i ,
j ,
k
r e a l
: :
r ,
s ,
t
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
149
contains
procedure
: :
Debug print
generic
: :
Print => Debug print
! DTIO r o u t i n e
generic
: :
write
( formatted ) => Debug print
end type
my type t
contains
subroutine
Debug print
( t h i s ,
unit ,
iotype ,
v l i s t , &
iostat ,
iomsg )
use
i so fortran env ,
only
: ERROR UNIT
c l a s s ( my type t ) ,
intent ( in )
: :
t h i s
integer ,
intent ( in )
: :
unit
!
i o t y p e
i s
e i t h e r
’DT’
with
a
user −s u p p l i e d
s u f f i x ,
! ’NAMELIST’ ,
or
’LISTDIRECTED ’ .
!
v
l i s t ( 1 ) . . . v
l i s t (6)
contain
f i e l d
widths
f o r
!
each
of
the
s i x
d e r i v e d
type
components ,
!
Not used
i n
t h i s
example .
character ( len =*) ,
intent
( in )
: :
iotype
integer ,
intent
( in )
: :
v
l i s t ( : )
integer ,
intent
( out )
: :
i o s t a t
character ( len =*) ,
intent
( in
out )
: :
iomsg
integer
: :
i p a s s
i o s t a t = 0
iomsg
= ””
!
s i n g l e −pass
loop
p r o v i d e s
e x i t
point .
!
( F2008
A l t e r n a t i v e :
t h i s b l o c k :
block )
t h i s b l o c k :
do
i p a s s = 1 , 1
write
( unit ,
* ,
i o s t a t=iostat ,
iomsg=iomsg ) &
’ my type t : ’
i f
( i o s t a t /= 0)
e x i t
t h i s b l o c k
i f
( iotype ( 1 : 2 ) == ’DT’
. and .
len
( iotype ) > 2) &
write
( unit ,
* ,
i o s t a t=iostat ,
iomsg=iomsg ) &
iotype ( 3 : )
i f
( i o s t a t /= 0)
e x i t
t h i s b l o c k
write
( unit ,
* ,
i o s t a t=iostat ,
iomsg=iomsg ) &
’
components
i ,
j ,
k : ’ ,
t h i s%i ,
t h i s%j ,
t h i s%k
i f
( i o s t a t /= 0)
e x i t
t h i s b l o c k
write
( unit ,
* ,
i o s t a t=iostat ,
iomsg=iomsg ) &
’
r ,
s ,
t : ’ ,
t h i s%r ,
t h i s%s ,
t h i s%t
!
( F2008
A l t e r n a t i v e :
end
block
t h i s b l o c k )
end do
t h i s b l o c k
Cambridge Books Online © Cambridge University Press, 2012

150
MODERN FORTRAN
i f
( i o s t a t /= 0)
then
write
(ERROR UNIT,
” (A) ” ) ” p r i n t
e r r o r :
” // &
trim
( iomsg )
write
(ERROR UNIT,
” (A,
I0 ) ” ) ”
i o s t a t :
” , &
i o s t a t
end
i f
end subroutine
Debug print
end module My type mod
program DTIO demo
use My type mod
i m p l i c i t
none
type ( my type t )
: :
my object
my object = my type t
( i =4,
j =5, k=6, r =42.0 , &
s =43.0 ,
t =44.0)
write
(* , ’( dt ” my object ” ) ’ )
my object
write
(* , ’( dt ) ’ )
my object
end program DTIO demo
The unformatted version of DTIO is similar the formatted version. The main
difference is that the iotype and v list dummy arguments are elided (see
Reference [38] and Rule 117).
111. Consider using asynchronous I/O to increase the speed of data
transfer.
I/O operations generally involve the intervention of the operating system. In
some cases, these I/O operations can take a great deal of time to complete.
In the case of an electromechanical device such as a disk drive, the time to
access data may be measured in milliseconds, compared to central processor
operations that may be measured in fractions of a nanosecond. With a device
such as a keyboard, where human intervention is required, or perhaps a lab
experiment, where a result is periodically produced, even longer time periods
are involved.
Operating systems and runtime libraries use a variety of techniques to miti-
gate problems caused by the relative slowness of I/O devices. For example, a
technique called “read ahead,” where more data is obtained from the device
than is actually needed, places the unused data in a “buffer” in the hope that
the additional data will be eventually needed. This allows data for succeeding
requests to be obtained directly from memory, rather than having to wait for
the slow device to operate again. Likewise, on writes, a technique called “write
behind” is used with buffering to delay placing data on the device until a
large request can be formed. These techniques are normally invisible to the
programmer.
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
151
However, sometimes it is more efﬁcient to program the I/O operations explic-
itly. The idea is to issue a time-consuming read or write operation and gain
control back before it has completed. Other useful work can then proceed
in parallel. At some point, the program can poll the I/O operation using the
inquire statement to probe to see if it has completed. Alternatively, both the
wait and the inquire statements can block execution of the program until the
operation has completed. File positioning statements, such as rewind, can also
block the program execution until the I/O operation terminates.
Several key areas need to be addressed by any program that uses asynchronous
I/O:
■Ensure asynchronous I/O is supported by the operating system for the ﬁle.
■Ensure that requests will be large enough that the additional coding com-
plexity will be beneﬁcial.
■Document and account for side effects by using the asynchronous attribute.
■Check for errors upon issuing the I/O request.
■Ensure completion to the extent possible.
■Check for errors upon completion of the I/O request.
When you open a ﬁle for asynchronous I/O, by using the asynchronous=’yes’
speciﬁer in the open statement, you should check the result returned by the
iostat argument. If the ﬁle cannot be properly connected in asynchronous
mode, it may be necessary to provide alternative code to perform normal
synchronous requests.
Two key performance parameters for a device are its latency, which is the time
it takes for a typical minimal request to begin, and its bandwidth, which is the
speed additional data can be transferred between the device and the computer’s
memory once the operation has begun. These speciﬁcations can be determined
by looking at manufacturer’s data sheets and by using benchmarking tools such
as lmdd (see Reference [48]).
A typical disk drive at the time of this writing spins at 7200 RPM, giving a maxi-
mum rotational latency of about 8 milliseconds. Ignoring operating system and
hardware buffering, large data transfers run at about 150 megabytes per sec-
ond. To checkpoint a large three-dimensional array, say 1000x1000x128 data
points at 8 bytes per point, the time required is easily computed. It would take:
0.008 + 1.024e9/1.50e8 = 6.835 seconds
If this operation needs to be performed many times, it could be beneﬁcial to
split the data across multiple disk drives by using asynchronous I/O.
When declaring variables, the asynchronous attribute is used to indicate data
objects that are in the I/O list of asynchronous operations. The attribute
indicates that side-effects on the objects can occur, so that compilers will be
conservative in how they optimize code. In this sense, the attribute is similar to
the volatile attribute. However, asynchronous is weaker than volatile because
Cambridge Books Online © Cambridge University Press, 2012

152
MODERN FORTRAN
the compiler only has to take into account code between the issuance of a read
or write operation and the corresponding wait, or other blocking operation.
The compiler is then free to fully optimize data access outside these boundaries
(see Rule 71).
In program units where read and write statements have an asynchronous=’yes’
speciﬁer, the I/O list variables automatically have the asynchronous attribute.
However, in a procedure that might be called with an argument that may
have an asynchronous operation active on it, the dummy argument must have
the asynchronous attribute as well. Otherwise the compiler could improperly
optimize code involving the variable. Even in the procedures where the asyn-
chronous I/O operations are performed, it is useful to use the asynchronous
attribute explicitly to document its use.
Once the asynchronous operation has been initiated, the inquire statement
may be used to probe to see if the operation is still active, in “pending” state,
or has completed. At some point, the wait statement can be used to block
further execution of the program until the operation has completed.
Generally, the inquire and wait statements operate on the unit as a whole –
rather than with individual requests. Because multiple asynchronous opera-
tions may be issued on a unit, an id speciﬁer may be used in the read and write
statements. The speciﬁer provides a variable that is ﬁlled in by the Fortran
runtime library with a unique value to identify each I/O operation. Later, this
variable can be used in an id speciﬁer with the inquire and wait statements to
either probe or wait on individual requests.
real ,
asynchronous
: :
b u f i o ( : , : , : )
integer
: :
i o i d
. . .
read
(AIO UNIT ,
asynchronous=’yes ’ ,
id=i o i d , &
iomsg=io msg ,
i o s t a t=i o e r r )
b u f i o
. . .
i n q u i r e
(AIO UNIT ,
id=i o i d ,
pending=i o p e n d i n g )
. . .
wait
(AIO UNIT ,
id=i o i d ,
iomsg=io msg , &
i o s t a t=i o e r r )
Here is an example of double buffering. The idea is to sequentially read ahead
in the ﬁle, while processing is overlapped with the the data in the current
buffer. Two buffers are deﬁned, and a pointer used to point to the one with
coherent data for processing. Once an end of ﬁle situation is encountered and
the loop is exited, the ﬁnal buffer is processed.
Listing 8.4: Program Dbuf example
module Compute mod
i m p l i c i t
none
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
153
private
public
: :
Compute
contains
subroutine
Compute ( buf )
real ,
intent ( in )
: :
buf ( : )
p r i n t
* ,
’ buf (1)
= ’ , buf (1)
end subroutine
Compute
end module Compute mod
program Dbuf example
!
Demonstrate
double
b u f f e r
I /O with
o v e r l a p p i n g
!
computations .
use Compute mod ,
only
:
Compute
use
ISO Fortran env ,
only : IOSTAT END
i m p l i c i t
none
character (*) ,
parameter
: :
AIO FILE=’ d a t a f i l e 1 ’
integer ,
parameter
: :
AIO UNIT=11, IO MSG LEN=128, &
BUF SIZE=1000
real ,
dimension ( BUF SIZE ) ,
target ,
asynchronous
: : &
buf1 ,
buf2
real ,
pointer
: :
buf compute ( : )
integer
: :
id1 ,
id2 ,
ios11 ,
ios12 ,
ios21 ,
ios22 , &
i o e r r
character (IO MSG LEN)
: :
iomsg11 ,
iomsg12
character (IO MSG LEN)
: :
iomsg21 ,
iomsg22
integer
: :
read number
l o g i c a l
: :
pending1 ,
pending2
iomsg11 = ’ ’
open (AIO UNIT ,
f i l e=AIO FILE ,
action =’read ’ , &
status =’old ’ ,
asynchronous=’yes ’ , &
form=’unformatted ’ ,
i o s t a t=ios11 ,
iomsg=iomsg11 )
i f
( i o s 1 1 /= 0)
then
p r i n t
* ,
’ cannot open
f i l e :
’ ,
AIO FILE
p r i n t
* ,
’
msg = ’ ,
trim
( iomsg11 )
stop 1
end
i f
!
I n i t i a l
read
on
b u f f e r
1 to
get
t h i n g s
going .
read number = 1
p r i n t
* ,
’ i s s u i n g
read no ’ ,
read number
Cambridge Books Online © Cambridge University Press, 2012

154
MODERN FORTRAN
read
(AIO UNIT ,
asynchronous=’yes ’ ,
id=id1 , &
iomsg=iomsg11 ,
i o s t a t=i o s 1 1 )
buf1
IO loop :
do
!
I s s u e
read
on
b u f f e r
2 ,
then
compute
with
!
b u f f e r
1.
read number = read number + 1
p r i n t
* ,
’ i s s u i n g
read no ’ ,
read number
read
(AIO UNIT ,
asynchronous=’yes ’ ,
id=id2 , &
iomsg=iomsg21 ,
i o s t a t=i o s 2 1 )
buf2
iomsg11 = ’ ’
i n q u i r e
(AIO UNIT ,
id=id1 ,
pending=pending1 , &
iomsg=iomsg11 )
i f
( . not .
pending1
. and .
i o s 1 1 == IOSTAT END)
then
p r i n t
* ,
’ i n q u i r y
1 msg = ’ ,
trim
( iomsg11 )
buf compute => n u l l
()
e x i t
IO loop
end
i f
iomsg12 = ’ ’
wait
(AIO UNIT ,
id=id1 ,
iomsg=iomsg12 ,
i o s t a t=i o s 1 2 )
i f
( i o s 1 2 == IOSTAT END)
then
p r i n t
* ,
’ w a i t i n g
1 msg = ’ ,
trim
( iomsg12 )
buf compute => buf2
e x i t
IO loop
end
i f
buf compute => buf1
c a l l
compute
( buf compute )
!
I s s u e
read
on
b u f f e r
1 ,
then
compute
with
!
b u f f e r
2.
read number = read number + 1
p r i n t
* ,
’ i s s u i n g
read no ’ ,
read number
read
(AIO UNIT ,
asynchronous=’yes ’ ,
id=id1 , &
iomsg=iomsg11 ,
i o s t a t=i o s 1 1 )
buf1
i n q u i r e
(AIO UNIT ,
id=id2 ,
pending=pending2 , &
iomsg=iomsg21 )
iomsg21 = ’ ’
i f
( . not .
pending2
. and .
i o s 2 1 == IOSTAT END)
then
p r i n t
* ,
’ i n q u i r y
2 msg = ’ ,
trim
( iomsg21 )
buf compute => n u l l
()
e x i t
IO loop
end
i f
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
155
iomsg22 = ””
wait
(AIO UNIT ,
id=id2 ,
iomsg=iomsg22 ,
i o s t a t=i o s 2 2 )
iomsg22 = ’ ’
i f
( i o s 2 2 == IOSTAT END)
then
p r i n t
* ,
’ w a i t i n g
2 msg = ’ ,
trim
( iomsg22 )
buf compute => buf1
e x i t
IO loop
end
i f
buf compute => buf2
c a l l
compute
( buf compute )
end do IO loop
!
F i n a l
compute
p o r t i o n .
i f
( associated
( buf compute )) &
c a l l
Compute ( buf compute )
iomsg11 = ’ ’
close
(AIO UNIT ,
i o s t a t=i o e r r ,
iomsg=iomsg11 )
i f
( i o e r r /= 0) &
p r i n t
* ,
’ problem
c l o s i n g ’
//
trim
( iomsg11 )
end program Dbuf example
A limitation in the Fortran implementation of asynchronous I/O is that there
is no way to program a “time-out” or otherwise cancel the request once a
request is issued.
8.2 Formatted, Unformatted, and Stream I/O
112. Use formatted I/O for human-readable ﬁles.
Formatted I/O involves the reading and writing of ﬁles containing text and
character data that can be read and are understandable in the context in which
they are used in the program. They can be created with a text editor, viewed
and manipulated with various operating system tools such as a sort utility, and
printed on printers.
In all formatted I/O transfers, when numeric variables are read and written,
a conversion process must be performed. There are two steps to the process:
First, the speciﬁed format must be interpreted in order to deﬁne how each I/O
list item will be converted. The second step is to process each I/O list item
according to the desired conversion. These steps require work by the central
processor, and so may be time-consuming when used with large data ﬁles.
Because of the conversion process, ﬂoating-point data can suffer loss of preci-
sion when used with formatted I/O. For example, a 64-bit IEEE ﬂoating-point
variable can represent about 17 decimal digits. If the formats specify fewer
digits on an output ﬁle, accuracy could be lost when the ﬁle is read back in.
Cambridge Books Online © Cambridge University Press, 2012

156
MODERN FORTRAN
For such data, when storing intermediate results for future reuse, it may be
better to use unformatted I/O (see Rule 117).
Formatted I/O comes in several forms: The most common is speciﬁed by a
format string or format statement in conjunction with the fmt speciﬁer in read
or write statements (see Rules 113 and 114).
read
( p o i n t d a t a u n i t ,
fmt= ’(3 i 0 ) ’ )
i ,
j ,
k
. . .
write
( output unit ,
fmt=100) x ,
y ,
z
100 format
( ’ The answers
are :
’ ,
3 f8 . 3 )
A second form, called “list-directed” I/O, is speciﬁed by using an asterisk with
the fmt speciﬁer. List-directed I/O uses Fortran-deﬁned rules for performing
a reasonable, but not always desirable set of conversions. This is especially the
case with ﬂoating-point variable output. The full conversion of each numeric
item may involve dozens of digits, quickly leading to output that is difﬁcult
to read.
write
( unit =*, fmt=*)
’ x ,
y ,
z = ’ , x ,
y ,
z
A third form is called “namelist” I/O. As with list-directed I/O, namelist I/O
uses a predeﬁned set of rules for performing conversions. It also moves the
I/O list away from the individual read and write statements, and into special
namelist statements that deﬁne namelist group names. These namelist group
names are then used as needed. If derived types are to be printed with namelist,
consider using the sequence statement in the derived-type deﬁnition so the
namelist output will not be rearranged (see Rule 110).
namelist / e l e v / height ,
temperature ,
p r e s s u r e
. . .
read
(ELEV UNIT ,
nml=elev ,
i o s t a t=i o e r r ,
iomsg=msgtxt )
Data records within a namelist ﬁle contain the namelist group name, the
individual variable names and their values in name=value form. Each record is
terminated with a slash character. Because of the name=value form, on input,
the variable names may be in any order. A value may even be omitted, which
leaves the original value of the variable unchanged.
&e l e v
h e i g h t =500,
temperature =65,79
! p r e s s u r e
i s
unchanged
/
&e l e v
h e i g h t =1000,
p r e s s u r e =12.4 ,
temperature =60.5
/
113. Use named character constants for frequently used format speciﬁca-
tions.
If a format speciﬁcation is used in I/O statements throughout a module,
create a named character constant whose scope is the entire module, and if the
speciﬁcation is used throughout your program, consider placing it in a separate
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
157
module (see Rules 47, 48, 108, and 114). Traditional format statements are
not allowed at module scope. So, for example, you could use the following
named character constant:
character
(*) ,
parameter
: : &
NOD REC FMT = ” (a ,
i0 ,
a ,
g14 . 7 ,
a ) ”
. . .
write
( unit = * , fmt=NOD REC FMT) &
”Node ” ,
node id ,
” , Temp . :
” ,
node temp ,
” deg . ”
114. For infrequently used format speciﬁcations, use character literals
directly in I/O statements.
If a particular format speciﬁcation is used in only a few locations, the clearest
manner to specify it is to embed a character literal in the I/O statement that
employs it. In this example, the frequency, response, and phase shift of a
transfer function are printed in tabular form (see Rule 113).
write
( unit=WRITE UNIT , &
fmt=” ( t2 ,
f12 . 5 ,
t20 ,
g14 . 4 ,
t40 ,
g14 . 7 ) ” ) &
freq ,
response ,
s h i f t
115. Use internal read and write statement for converting between char-
acter strings and numeric items.
A very common requirement when building or interpreting character strings
is to convert between decimal digits and their numeric equivalents. Since
the formatted I/O statements must perform this task for ﬁle I/O, the same
statements and conversion capabilities are also available for character strings.
The syntax is identical except that the unit number is replaced by a character
string (see Rule 199).
integer ,
parameter
: :
STRING LEN = 32
character (STRING LEN)
: :
s t r i n g
r e a l
: :
temperature
. . .
read
( s t r i n g ,
fmt=’( f8 . 3 ) ’ )
temperature
This example reads character string records from a data ﬁle. Based on the ﬁrst
few characters of each record, different conversions are made depending on
record type:
Listing 8.5: Program Read sensor ﬁle
module Pres mod
i m p l i c i t
none
private
public
: :
P r e s s u r e p r o c e s s
contains
subroutine
P r e s s u r e p r o c e s s
( pres ,
time stamp )
Cambridge Books Online © Cambridge University Press, 2012

158
MODERN FORTRAN
real ,
intent
( in
out )
: :
pres
character
(*) ,
intent
( in )
: :
time stamp
p r i n t
* , ” P r e s s u r e
p r o c e s s
” // trim
( time stamp )
end subroutine
P r e s s u r e p r o c e s s
end module Pres mod
module Temp mod
i m p l i c i t
none
private
public
: :
Temperature process
contains
subroutine
Temperature process
( temp ,
time stamp )
integer ,
intent
( in
out )
: :
temp
character
(*) ,
intent
( in )
: :
time stamp
p r i n t
* , ” Temperature
p r o c e s s
” // trim
( time stamp )
end subroutine
Temperature process
end module Temp mod
program
R e a d s e n s o r f i l e
use
i so fortran env ,
only
: ERROR UNIT
use Pres mod ,
only :
P r e s s u r e p r o c e s s
use Temp mod ,
only :
Temperature process
i m p l i c i t
none
integer ,
parameter
: :
RECORD LEN = 128 , &
MSG LEN = 200 , TIMESTAMP LEN = 8 , &
SEN UNIT = 10
character (*) ,
parameter
: : &
SENSOR FILE=’ s e n s o r d a t a . txt ’
character (MSG LEN)
: :
io msg
character (RECORD LEN)
: :
record
character (TIMESTAMP LEN)
: :
timestamp
r e a l
: :
p r e s s u r e
integer
: :
temperature ,
i o e r r ,
i n d x p r e s s u r e , &
indx temp
open ( unit=SEN UNIT ,
f i l e=SENSOR FILE , &
status =’old ’ ,
action =’read ’ , &
iomsg=io msg ,
i o s t a t=i o e r r )
open ok :
i f
( i o e r r == 0)
then
r e a d r e c o r d :
do
read
(SEN UNIT ,
fmt=’(a ) ’ , &
i o s t a t=i o e r r ,
iomsg=io msg )
record
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
159
i f
( i o e r r /= 0)
e x i t
r e a d r e c o r d
record = a d j u s t l
( record )
a c t i o n s w i t c h :
s e l e c t
case
( record ( 1 : 8 ) )
case
( ’ comment ’ )
! Do nothing .
case
( ’ pressure ’ )
a c t i o n s w i t c h
i n d x p r e s s u r e = i n d x p r e s s u r e + 1
read
( record ( 9 : ) ,
fmt=’(a8 ,
f8 . 3 ) ’ , &
i o s t a t=i o e r r ,
iomsg=io msg ) &
timestamp ,
p r e s s u r e
c a l l
P r e s s u r e p r o c e s s
( pressure ,
timestamp )
case
( ’ temp ’ )
a c t i o n s w i t c h
indx temp = indx temp + 1
read
( record ( 9 : ) ,
fmt=’(a8 ,
i 5 ) ’ , &
i o s t a t=i o e r r ,
iomsg=io msg ) &
timestamp ,
temperature
c a l l
Temperature process
( temperature , &
timestamp )
case
default
a c t i o n s w i t c h
write
(ERROR UNIT,
* ,
i o s t a t=i o e r r )
&
’ unknown
record
ignored :
’ ,
trim
( record )
end
s e l e c t
a c t i o n s w i t c h
end do
r e a d r e c o r d
close
(SEN UNIT ,
i o s t a t=i o e r r ,
iomsg=io msg )
e l s e
open ok
write
(ERROR UNIT,
*)
’ problem
opening ’ , &
SENSOR FILE
end
i f
open ok
end program
R e a d s e n s o r f i l e
116. Use format reversion where possible to simplify format statements.
Fortran provides a method whereby simple format statements can serve for
I/O lists containing more elements than there are edit descriptors in the format
list. This is called format reversion, and a few examples best illustrate its use.
Here an array of shape [4, 4] is printed one row per line:
r e a l
: :
r o t a r r a y (4 ,
4)
p r i n t
” (4 f12 . 5 ) ” ,
( r o t a r r a y
( i row ,
j c o l ) , &
j c o l = 1 ,
4 ,
i r o w = 1 ,
4)
Even though there are 16 array elements to print, you need only specify the
format for one record; it will be reused for the remaining three.
The following example shows the same technique used for reading records.
Say you have a ﬁle containing both historical and real-time information about
Cambridge Books Online © Cambridge University Press, 2012

160
MODERN FORTRAN
equities. Each record contains the stock symbol, the current price, the current
volume, the price-to-earnings ratio, and the stock’s market capitalization. A
record may look like this:
NCC 16.1114025776.6410.03E9
For a real-time display you might need only the ﬁrst three pieces of information.
If you know ahead of time the exact number of records to be read, you can
achieve this by using the following single I/O statement:
read
( unit = READ UNIT ,
fmt = ” (a ,
f6 . 2 ,
I9 ) ” , &
i o s t a t = i o s )
( symbol ( i ) ,
p r i c e ( i ) , &
i = 1 , NO OF RECORDS)
When edit descriptors are nested with parentheses, and format reversion takes
place, the innermost parenthesized edit descriptors are repeated. The following
demonstrates how a title and some column data are printed in a single print
statement:
p r i n t
” ( a/ ( i5 ,
f8 . 3 ) ) ” , ”
index
value ” ,
&
( i ,
v a l u e s ( i ) ,
i =1,
s i z e
( v a l u e s ))
In Fortran 2008, an asterisk can be used to indicate an edit descriptor that
repeats indeﬁnitely. With this feature, the previous code can be more clearly
stated as:
p r i n t
” (a ,
*(/ i5 ,
f8 . 3 ) ) ” , ”
index
value ” ,
&
( i ,
v a l u e s ( i ) ,
i =1,
s i z e
( v a l u e s ))
117. Use unformatted I/O when full numerical accuracy needs to be
maintained.
Unformatted ﬁles have a number of advantages over formatted ones. The data
is copied directly between internal buffers and the I/O list items with no
conversion taking place. The data can be moved at a very high speed because
of this. And, because there is no conversion, numeric data does not suffer any
loss of precision.
Unformatted I/O is indicated by using form=‘‘unformatted’’ in the open
statement, and by omitting the fmt speciﬁer in read and write statements.
complex ,
a l l o c a t a b l e
: :
s i g s ,
s i g s i n v e r t e d ( : )
. . .
open ( newunit=s i g u n i t ,
f i l e =’ s i g n a l
f i l e . dat ’ , &
form=’unformatted ’ , &
i o s t a t=i o e r r ,
iomsg=io msg )
write
( s i g u n i t ,
i o s t a t=i o e r r )
s i g s ,
s i g s i n v e r t e d
. . .
rewind
( s i g u n i t ,
i o s t a t=i o e r r )
read
( s i g u n i t ,
i o s t a t=i o e r r )
s i g s ,
s i g s i n v e r t e d
Each unformatted write statement writes a record composed of values of the
I/O list variables out to the ﬁle. On a sequential ﬁle, the records may be
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
161
of variable length, that is, each write statement may have different I/O list
items with different types of data, different shapes of arrays, and so on. In
order to distinguish one record from the next, the Fortran runtime library
will typically place a record mark of some sort in the ﬁle between each record.
The record mark generally contains a count of the length of the record. This
count supports skipping records on sequential ﬁles without transferring their
data into I/O list items, via a read statement with no I/O list. Likewise, the
counts also support the backspace statement, which allows positioning to the
previous record so that it can be reread, or overwritten. Note that the record
marks are implementation-deﬁned, and, therefore, unformatted ﬁles may not
be portable between environments. Also, ﬂoating-point and endian issues may
further complicate portability.
When skipping and backspacing are not required, a streaming option
is allowed. The streaming is speciﬁed in the open statement with the
access=’stream’ speciﬁer. Streaming does not organize data into records. Data
is transferred based on the I/O list given. This removes the need for record
marks within a ﬁle, thereby removing an implementation-dependent issue
when interfacing with non-Fortran ﬁles, such as those written by other lan-
guages or hardware devices. In the following program, four data entities are
written to ﬁle METER FILE. It will simulate a device that provides this as a
continuous stream of data. To control the device, only the pressure is needed;
all the data is read in as a stream, and only the pressure is used.
Listing 8.6: Program Stream demo
program Stream demo
i m p l i c i t
none
integer ,
parameter
: :
TIME MARK LEN = 5 , &
NO OF SAMPLES = 3 , METER UNIT = 20 , &
IO MSG LEN = 100
character
( len =*) , parameter
: : &
METER FILE = ” meter dat ”
character
( len=TIME MARK LEN)
: : &
time marks (NO OF SAMPLES) = [ ” 14:01 ” , ” 14:02 ” , &
” 14:03 ” ]
character
( len=IO MSG LEN)
: :
msg text
real ,
dimension (NO OF SAMPLES)
: :
pres ,
temp ,
v e l
integer
: :
i samp ,
i o e r r ,
j o n e p a s s
do i samp = 1 , NO OF SAMPLES
pres ( i samp ) = i samp * 10.0
temp ( i samp ) = i samp + 20.0
v e l ( i samp )
= i samp * 50.0 + 600.0
end do
Cambridge Books Online © Cambridge University Press, 2012

162
MODERN FORTRAN
!
open
f o r
steam
I /O.
open ( unit=METER UNIT,
f i l e=METER FILE , &
status=” r e p l a c e ” ,
access=” stream ” , &
i o s t a t=i o e r r ,
iomsg=msg text )
!
s i n g l e −pass
loop
f o r
e r r o r
e x i t .
!
( F2008
A l t e r n a t i v e :
i o b l o c k 1 :
block )
i o b l o c k 1 :
do
j o n e p a s s = 1 , 1
i f
( i o e r r /= 0)
e x i t
i o b l o c k 1
!
e s t a b l i s h
data
source ,
stream
I /O.
do i samp = 1 , NO OF SAMPLES
write
(METER UNIT,
i o s t a t=i o e r r ,
iomsg=msg text ) &
time marks ( i samp )
i f
( i o e r r /= 0)
e x i t
i o b l o c k 1
write
(METER UNIT,
i o s t a t=i o e r r ,
iomsg=msg text ) &
pres ( i samp ) ,
temp ( i samp ) ,
v e l ( i samp )
i f
( i o e r r /= 0)
e x i t
i o b l o c k 1
end do
rewind
(METER UNIT,
i o s t a t=i o e r r ,
iomsg=msg text )
i f
( i o e r r /= 0)
e x i t
i o b l o c k 1
!
read
data
back
in ,
stream
I /O.
do i samp = 1 , NO OF SAMPLES
read
(METER UNIT,
i o s t a t=i o e r r ,
iomsg=msg text ) &
time marks ( i samp )
i f
( i o e r r /= 0)
e x i t
i o b l o c k 1
read
(METER UNIT,
i o s t a t=i o e r r ,
iomsg=msg text ) &
pres ( i samp ) ,
temp ( i samp ) ,
v e l ( i samp )
i f
( i o e r r /= 0)
then
e x i t
i o b l o c k 1
e l s e
!
use
p r e s s u r e
( only )
f o r
feedback .
write
(* , ” (A,
I0 ) ” ) ” sample no :
” ,
i samp
write
(* , ” (A, G8 . 3 ) ” ) ” p r e s s u r e :
” , &
pres ( i samp )
end
i f
i f
( i o e r r /= 0)
e x i t
i o b l o c k 1
end do
i f
( i o e r r /= 0) &
write
(* , ” (A,
I0 , A) ” ) ” Error
no . : ,
” ,
i o e r r , &
msg text
close
(METER UNIT,
i o s t a t = i o e r r )
!
( F2008
A l t e r n a t i v e :
end
block
i o b l o c k 1 )
end do
i o b l o c k 1
end program Stream demo
Cambridge Books Online © Cambridge University Press, 2012

INPUT AND OUTPUT
163
The program output is:
sample no: 1
pressure: 10.0
sample no: 2
pressure: 20.0
sample no: 3
pressure: 30.0
8.3 Messages
118. Issue meaningful error messages.
The purpose of an error message is to inform the user of a situation that
the program is not able to handle. Good error messages will aid the user in
correcting the inputs in order to conform to whatever requirements are needed.
The best error messages for an end-user are related to items that are under the
user’s control. They are also written in terms that the user is familiar with. For
example:
ERROR: Attempted to connect element 73 edge 2 to unknown
element 7463. Please correct geometry in file:
problem_23/widget_geometry.dat
This error message describes the situation encountered and points in the
direction of a ﬁx. It even tells where the problem might be found.
Error messages may also be directed to those who maintain the program. The
program may, for instance, log all program messages to a ﬁle. For these types of
messages, to locate the source of the problem in the code, you should indicate
the location of the error, including the module name and the contained
procedure within the ﬁle:
Angular_formulae_mod::XYZ_Computation:
ERROR: Input value was 76.5, but must be
greater than 0.0 and less than pi.
119. Use meaningful stop statements for error termination.
The normal method of terminating a Fortran program is either by executing the
stop statement, or by encountering the end statement of the main program
unit. In cases where processing must end prematurely, such as in an error
situation, you should indicate the reason this occurred.
The Fortran 2008 standard has adopted the POSIX standard of issuing an
“exit status” on program termination. This is accomplished by specifying a
Cambridge Books Online © Cambridge University Press, 2012

164
MODERN FORTRAN
series of between one to ﬁve digits with the stop statement. The default exit
status for successful termination is the digit “0.” This allows for a shell script
to detect different cases of termination and take appropriate actions.
The following is a segment of code showing an error termination. It is followed
by a POSIX compliant shell script showing access to the exit status of a process
by using the question mark (?) environment variable:
use
ISO fortran env ,
only
: ERROR UNIT
. . .
open (MYDATA UNIT,
f i l e=DATA FILE NAME ,
status =’old ’ ,
&
access =’read ’ ,
i o s t a t=i o e r r ,
iomsg=msgtxt )
i f
( i o e r r /= 0)
then
write
(ERROR UNIT, * ) &
’ Error
encountered
opening :
’ , DATA FILE NAME
write
(ERROR UNIT, * )
’
message :
’ ,
trim
( msgtxt )
stop 1
end
i f
# sh
s h e l l
s c r i p t
to
run
the
program
meltdown sim
i f
[
$? = 0
] ;
then
echo
S u c c e s s f u l
e x e c u t i o n ;
e l s e
echo
e x i t
s t a t u s
was :
$ ? ;
f i
It is generally better to return an error status to the caller of a procedure than to
abort the program. This allows the caller to decide upon an appropriate action
to take. It also allows the precedure to be more readily unit tested. Example:
i f
( present
( e r r o r s t a t u s ))
then
e r r o r s t a t u s = ERROR CODE
return
e l s e
write
(ERROR UNIT,
*) ” Procedure
xyz :
Error
. . . ”
stop 1
end
i f
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

9.
Packaging Conventions
9.1 Files
120. Place each program unit in a separate ﬁle.
Program units in Fortran are the main program, external subroutines, modules,
and submodules. Placing each unit in a separate ﬁle makes the program easier
to maintain. Shorter ﬁles tend to compile faster. You can locate different
program components in ﬁles more easily. When a team of programmers is
collaborating on a project, smaller ﬁles make it less likely that the work of one
programmer will conﬂict with that of others.
It is crucial that you place submodules in ﬁles separate from their parent mod-
ules. Doing so prevents “compilation cascade,” a phenomena where a change
in the implementation of a subprogram needlessly causes the recompilation of
other program units (see Rule 124).
121. Whenever possible, use the module name, the type name, the subpro-
gram name, or the program name as the ﬁle name.
This rule makes it easier to maintain programs. This is especially true if you
code in conformance to Rule 133 and place each derived type in its own
module, and you also choose to use either a preﬁx or sufﬁx attached to a
common base name when naming derived types and the modules that contain
them. In that case, name the ﬁle according to the base name. For instance, you
might have a type called pixel t deﬁned in module pixel mod, and you can
name the ﬁle pixel.f03 (see Section 4.2).
9.2 External Procedures
External procedures are those that do not reside in a module or are an internal
procedure within a main program. An explicit interface is not deﬁned unless
one is created by using interface blocks. Examples of external procedures are
older FORTRAN 77 code, and code written in other languages, such as C.
122. Group the interface blocks for all user-deﬁned external procedures
in one or more modules. Use these modules in all procedures where these
external procedures are referenced.
Using this rule allows an interface to be easily changed. Say you have an
external subroutine contained in its own ﬁle:
165
Cambridge Books Online © Cambridge University Press, 2012

166
MODERN FORTRAN
subroutine
Sub a
( argi ,
a r g r )
i m p l i c i t
none
integer ,
intent
( in )
: :
a r g i
real ,
intent
( in
out )
: :
a r g r
. . .
code
to
c a l c u l a t e
a r g r
end subroutine
Sub a
In every location in the program from which Sub a is called, be it from a
module subprogram or from another external procedure, an interface should
be provided. One method of doing so is to include an interface block in the
speciﬁcation section of the calling unit.
subroutine
Sub b
i m p l i c i t
none
integer
: :
i n t 1
r e a l
: :
r e a l 1
i n t e r f a c e
subroutine
Sub a
( argi ,
a r g r )
integer ,
intent
( in )
: :
a r g i
real ,
intent
( in
out )
: :
a r g r
end subroutine
Sub a
end
i n t e r f a c e
. . .
c a l l
Sub a
( int1 ,
r e a l 1 )
. . .
end subroutine
Sub b
If the interface changes, all such interface blocks must be changed accordingly.
A better method is to gather all such interface blocks into modules and use the
modules where needed. The module would appear as shown in the following
code. This method is the preferred manner in which to package a library of
external procedures. The source code is placed in one or more ﬁles, and a
module containing the interfaces to all the procedures is provided.
module
Interface mod
i m p l i c i t
none
i n t e r f a c e
subroutine
Sub a
( argi ,
a r g r )
integer , intent
( in )
: :
a r g i
real ,
intent
( in
out )
: :
a r g r
end subroutine
Sub a
. . .
a d d i t i o n a l
b l o c k s
f o r
other
procedures
end
i n t e r f a c e
end module
Interface mod
subroutine
Sub b
i m p l i c i t
none
integer
: :
i n t 1
Cambridge Books Online © Cambridge University Press, 2012

PACKAGING CONVENTIONS
167
r e a l
: :
r e a l 1
use
Interface mod
. . .
c a l l
Sub a
( int1 ,
r e a l 1 )
. . .
end subroutine
Sub b
123. Place the declaration of the dummy arguments of external procedures
in a separate ﬁle and then include it using an include line in the ﬁle
containing the procedure and every ﬁle containing its interface block.
Conforming to this rule will prevent you from inadvertently forgetting to
change the interface block to an external procedure after you have modiﬁed
the interface to the procedure itself.
Here’s an external procedure, contained in its own ﬁle, sub a args.f90,
followed by the contents of the included ﬁle:
subroutine
Sub a
( arg 1 ,
arg 2 )
i m p l i c i t
none
include
” s u b a a r g s . f90 ”
. . .
end subroutine
Sub a
!
contents
of
f i l e
s u b a a r g s . f90
complex ,
intent
( in
out )
: :
arg 1
real ,
intent
( in ) ,
optional
: :
arg 2
The module making the interface available would look like this:
module
Interface mod
i m p l i c i t
none
i n t e r f a c e
subroutine
Sub a
( arg 1 ,
arg 2 )
include
” s u b a a r g s . f90 ”
end subroutine
Sub a
. . .
a d d i t i o n a l
b l o c k s
f o r
other
procedures
end
i n t e r f a c e
end module
Interface mod
9.3 Submodules
Modules are the fundamental feature of modern Fortran for grouping highly
related deﬁnitions, globally available variables, and procedures. However, prob-
lems occur in large applications because there is not a clean split between the
interface the module deﬁnes for the outside world, and the internal imple-
mentation of that interface.
One problem is that of “compilation cascade,” whereby changes in a low-level
module that did not affect the interfaces to its procedures trigger an unnecessary
Cambridge Books Online © Cambridge University Press, 2012

168
MODERN FORTRAN
recompilation of many program units that depend on that module’s interface.
The change could be as small as ﬁxing a typographical error in a comment
line, yet massive recompilation could occur.
A second problem is that it is sometimes desirable to distribute the interface
in source form, yet maintain the actual procedural code separately as exter-
nal procedures. In this case, interface blocks are deﬁned for the procedures.
The problem here is that there is no linkage between the interface blocks
and the actual procedures. The interface is therefore deﬁned in at least two
places. The developers must vigilantly keep multiple ﬁles in sync, or possibly
use include ﬁles in some manner (see Section 9.2).
The ISO/IEC Technical Report TR 19767, Enhanced Module Facilities (see
Reference [32]) addressed the issue by developing “submodules.” This TR is
incorporated as part of Fortran 2008. Submodules provide a method for cleanly
separating the interfaces of module procedures from their implementation.
124. Use submodules to separate the interfaces of module procedures from
their implementations. Specify the interface in the parent module only.
Here is a module that deﬁnes a data type vector t , and an interface block to
deﬁne a function for that type: It is followed by a submodule that contains the
actual implementation of the function Comp components:
module Vector mod
i m p l i c i t
none
private
public
: :
Comp components , UNIT VECTORS ,
v e c t o r t
type ,
public
: :
v e c t o r t
real ,
dimension (3)
: :
o r i g i n = 0.0 , &
d i r c o s = [ 1 . 0 ,
0.0 ,
0 . 0 ] ,
v e c l e n = 0.0
end type
v e c t o r t
i n t e r f a c e
function
Comp components ( t h i s )
r e s u l t
( r e t v a l s )
import
: :
v e c t o r t
i m p l i c i t
none
type
( v e c t o r t ) ,
intent
( in )
: :
t h i s
r e a l
: :
r e t v a l s (3)
end
function
Comp components
end
i n t e r f a c e
type
( v e c t o r t ) ,
parameter ,
dimension (3)
: : &
UNIT VECTORS = &
[ v e c t o r t
( v e c l e n =1.0) , &
v e c t o r t
( d i r c o s =[0.0 ,
1.0 ,
0 . 0 ] ,
v e c l e n =1.0) , &
v e c t o r t
( d i r c o s =[0.0 ,
0.0 ,
1 . 0 ] ,
v e c l e n =1.0)]
end module Vector mod
Cambridge Books Online © Cambridge University Press, 2012

PACKAGING CONVENTIONS
169
submodule ( Vector mod )
Vector submod
i m p l i c i t
none
contains
module procedure Comp components
r e t v a l s = t h i s%v e c l e n
*
t h i s%d i r c o s
end procedure Comp components
end submodule Vector submod
The submodule statement speciﬁes the module that the submodule is associated
with. Here it is module Vector mod. The module procedure statement states
that the interface from the parent module is to be used. In this case, it is
function Comp components. The argument list and various declarations do
not need to be repeated, so there is no opportunity for error. The submodule
code for this can, and, in fact, should, reside in a separate ﬁle from the parent
module, so that it can be developed independently of the interface.
A drawback of this manner of writing the procedure code in submodules is that
you do not see the interface when you are looking at the source code listing;
you need to refer to the listing of the parent module as well. The submodule
that follows, however, would also work. Its use removes this disadvantage by
repeating the interface. The compiler is required to compare the two interfaces
and issue an error if they differ. However, the previous form is still preferable
because the code specifying the interface exists solely in one place, the parent
module. If you need to change the interface, you can make all changes to the
interface code in it alone.
submodule ( Vector mod )
Vector submod
contains
function
Comp components ( t h i s )
r e s u l t
( r e t v a l s )
type
( v e c t o r t ) ,
intent
( in )
: :
t h i s
r e a l
: :
r e t v a l s (3)
r e t v a l s = t h i s%v e c l e n
*
t h i s%d i r c o s
end
function
Comp components
end submodule Vector submod
The parent module is the one speciﬁed in use statements in other program
units to obtain access both to the module procedure interfaces and to objects
whose scope is the module.
module ModA mod
use Vector mod ,
only
:
Comp components ,
v e c t o r t
i m p l i c i t
none
private
public
: :
!
. . .
l i s t
of
p u b l i c
e n t i t i e s
Cambridge Books Online © Cambridge University Press, 2012

170
MODERN FORTRAN
contains
! . . .
procedures
that
r e f e r e n c e
the
f u n c t i o n
! . . . Comp Components
i n
submodule
Vector submod .
end module ModA mod
If you modify the implementation of Comp components in submodule
Vector submod, but do not modify the interface, module ModA mod need
not be recompiled because it does not use Vector submod.
When using an application building tool, such as make, in the speciﬁcation
used to build the application, compilation of the parent module is the prereq-
uisite for compilation of the submodules. It should also be the prerequisite for
all program units that need access to the public entities and interfaces of the
module; compilation of the submodules should not be the prerequisite to these
units. For this reason, you should deﬁne all public objects, not just the inter-
faces, in the parent module. The named constant UNIT VECTORS in module
Vector mod in the previous example is an example as is the type vector t .
With most make programs, you will need to place the parent module and
each of its submodules in a separate ﬁle to prevent the unneeded compilation
(see Rule 120).
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

10.
Generic Programming
A common requirement when writing code is the ability to use the identical, or
nearly identical, code for different data types. In the case of the public domain
LAPACK linear algebra library (see Reference [5]), for instance, procedures
support much the same set of operations for each of real, double precision,
and complex data types. For example, the real version of a matrix operation
routine might be identical to the complex version, except for a few details,
primarily:
■The data type of the dummy arguments.
■The data type of function return values.
■The data type of localized temporary variables.
■Numeric constants (e.g., 1.0 vs (1.0,0.0)).
In addition to the data type, the kind and rank of arguments may also differ.
A routine that processes real data may be identical to its double precision
counterpart, thereby making the kinds different. And often routines accepting
scalar arguments may need to be expanded to accept array arguments.
A number of techniques are used to make the job of generic programming
easier and less error prone than simply replicating and hand-editing code.
These techniques can be divided into three general methodologies: reducing
the need to replicate code, reducing the number of code changes required to
replicate code, and ﬁnally, automating the replication of code. The speciﬁc
techniques we discuss are:
■Use parameterized derived types to avoid replication based on kind and len.
■Create and use generic names for procedures with interface blocks.
■Use optional arguments to avoid the need for additional replication.
■Use elemental procedures for rank independence.
■Use the result clause for function result names.
■Use generic names for intrinsic procedures.
■Use a preprocessor for automated replication of code and handling condi-
tional operations.
■Create and use generic speciﬁcations for two or more type-bound proce-
dures using the generic keyword.
■Use polymorphic dummy arguments.
171
Cambridge Books Online © Cambridge University Press, 2012

172
MODERN FORTRAN
The guidelines in this chapter cover all these points except the ﬁnal two: They
more naturally belong in Chapter 11, Object Orientation, where you can ﬁnd
the guidelines that explain them (see Rules 143 and 154).
10.1 Generic Code Techniques
125. Use parameterized derived types to create generic code.
Parameterized derived types, new in Fortran 2003, add a generic capability
to derived types. They enable the programmer to use a single derived-type
deﬁnition to serve as the derived type for components of various kinds and
lengths. Here is an example deﬁnition; it is based on a type used in Rule
170. The kind type parameters are pixel kind and color kind. They set the
kinds, respectively, of components pixel intensity and i colors, and they are
identiﬁed by the keyword kind. The length type parameter is color len; it sets
the dimension of the rank 1 array i colors and is identiﬁed by the keyword
len. The length parameter may also be used for character string lengths (see
Rule 137). All type parameters are integers.
type
p i x e l t
( p i x e l k i n d ,
c o l o r k i n d ,
c o l o r l e n )
integer ,
kind
: :
p i x e l k i n d ,
c o l o r k i n d
integer ,
len
: :
c o l o r l e n
r e a l
( r e a l k i n d )
: :
p i x e l i n t e n s i t y = 0.0
integer
( c o l o r k i n d )
: :
i c o l o r s ( c o l o r l e n ) = NO COLOR
end type
p i x e l t
You must specify the kind type parameters such that they can be determined
during compilation. The length type parameters can vary. Here is a sample
declaration of an assumed-shape array of pixels, where SMALL INT is a named
constant, and number of colors is a variable:
type
( p i x e l t
( p i x e l k i n d=s e l e c t e d r e a l k i n d
(6 ,
37) , &
c o l o r k i n d=SMALL INT , &
c o l o r l e n=n u m b e r o f c o l o r s ))
: :
p i x e l s ( : ,
: )
Liberal use of parameterized derived types can eliminate the necessity of writing
separate code to handle different kinds of intrinsic data types. Here is the code,
for example, for a simple linked list of default integers:
module
I n t L i n k e d L i s t m o d
i m p l i c i t
none
private
type ,
public
: :
i n t n o d e t
integer
: :
i n t v a l u e
type
( i n t n o d e t ) ,
pointer
: :
next node => n u l l
()
contains
procedure
: :
Get next node
Cambridge Books Online © Cambridge University Press, 2012

GENERIC PROGRAMMING
173
procedure
: :
I n s e r t n o d e
!
other
type−bound
procedures
end type
i n t n o d e t
contains
. . .
code
implementing
procedures
Get next node ,
. . .
I n s e r t n o d e ,
etc .
end module
I n t L i n k e d L i s t m o d
The code declaring a linked list would be:
type
( i n t n o d e t ) ,
pointer
: :
d e f
i n t
l i s t
If the need exists for a linked list for a second kind of integer, you could create a
separate module and duplicate the code for the default kind for the second kind.
The procedures could then be made generic using the techniques described in
Rule 126. An alternative method is to make this type a parameterized derived
type as shown here:
type ,
public
: :
i n t n o d e t
( i n t k i n d )
integer ,
kind
: :
i n t k i n d = kind
(1)
integer
( i n t k i n d )
: :
i n t v a l u e
type
( i n t n o d e t ) ,
pointer
: :
next node => n u l l
()
contains
procedure
: :
Get next node
procedure
: :
I n s e r t n o d e
!
other
type−bound
procedures
end type
i n t n o d e t
The following is a declaration for a list containing integer values of extended
magnitude:
type
( I n t n o d e t
( i n t k i n d = s e l e c t e d i n t k i n d
( 1 5 ) ) ) , &
pointer
: :
e x t
i n t
l i s t
126. Create generic names for related speciﬁc procedures.
When multiple procedures exist that perform identical, or nearly identical,
operations, interface blocks can be used to create a single generic name for
them. At compile time, when the compiler encounters a call to a generic
name, it will examine each of the actual arguments in the call and attempt to
match it to one of the speciﬁc procedures based on the type, kind, and rank
of the arguments. Fortran 2008 also differentiates between the allocatable
and pointer attributes. Each of the procedures will be coded to handle its own
speciﬁc arguments. The advantage to the caller of a generic named procedure
is that the speciﬁc routine name is irrelevant, provided the compiler can ﬁnd
a suitable speciﬁc version of the routine to call. This manner of creating a
generic procedure for two or more distinct derived types is referred to in
object-oriented terminology as “overloading.” The method shown here was
Cambridge Books Online © Cambridge University Press, 2012

174
MODERN FORTRAN
the one you could use in Fortran 95. In Fortran 2003, the preferred way is to
write type-bound procedures (see Chapter 11).
module
Polysort mod
use
Kinds module
i m p l i c i t
none
private
public
: :
P o l y s o r t
i n t e r f a c e
P o l y s o r t
module procedure
P o l y s o r t r e a l
module procedure
P o l y s o r t d p
module procedure
P o l y s o r t c h a r
end
i n t e r f a c e
P o l y s o r t
contains
subroutine
P o l y s o r t r e a l
( input ,
d i r e c t i o n ,
output , &
r e t u r n s t a t )
real ,
intent
( in )
: :
input ( : )
character (*) ,
intent
( in )
: :
d i r e c t i o n
real ,
intent
( out )
: :
output ( : )
integer ,
intent
( out ) ,
optional
: :
r e t u r n s t a t
. . .
end subroutine
P o l y s o r t r e a l
subroutine
P o l y s o r t d p
( input ,
d i r e c t i o n ,
output , &
r e t u r n s t a t )
r e a l
(DP K) ,
intent
( in )
: :
input ( : )
character (*) ,
intent
( in )
: :
d i r e c t i o n
r e a l
(DP K) ,
intent
( out )
: :
output ( : )
integer ,
intent
( out ) ,
optional
: :
r e t u r n s t a t
. . .
end subroutine
P o l y s o r t d p
subroutine
P o l y s o r t c h a r
( input ,
d i r e c t i o n ,
output , &
r e t u r n s t a t )
character (*) ,
intent
( in )
: :
input ( : )
character (*) ,
intent
( in )
: :
d i r e c t i o n
character (*) ,
intent
( out )
: :
output ( : )
integer ,
intent
( out ) ,
optional
: :
r e t u r n s t a t
. . .
end subroutine
P o l y s o r t c h a r
end module
Polysort mod
For functions, only the argument lists are matched to ﬁnd the correct speciﬁc
procedure. The function result type is not to be used for matching. For
example, the following code is incorrect; the compiler will not differentiate
between the two functions:
Cambridge Books Online © Cambridge University Press, 2012

GENERIC PROGRAMMING
175
i n t e r f a c e
C a l c v a l u e
module procedure
C a l c v a l u e r e a l
module procedure
C a l c v a l u e i n t
end
i n t e r f a c e
function
C a l c v a l u e r e a l
( t h i s )
r e s u l t
( r e t u r n v a l u e )
type
( o b j e c t t ) ,
intent
( in )
: :
t h i s
r e a l
: :
r e t u r n v a l u e
end
function
C a l c v a l u e r e a l
function
C a l c v a l u e i n t
( t h i s )
r e s u l t
( r e t u r n v a l u e )
type
( o b j e c t t ) ,
intent
( in )
: :
t h i s
integer
: :
r e t u r n v a l u e
end
function
C a l c v a l u e i n t
One way to overcome this problem is to pass an additional argument that will
allow the compiler to distinguish between the two routines.
function
C a l c v a l u e r e a l
( t h i s ,
type mold ) &
r e s u l t
( r e t u r n v a l u e )
type
( o b j e c t t ) ,
intent
( in )
: :
t h i s
real ,
intent
( in )
: :
type mold
r e a l
: :
r e t u r n v a l u e
end
function
C a l c v a l u e r e a l
function
C a l c v a l u e i n t
( t h i s ,
type mold ) &
r e s u l t
( r e t u r n v a l u e )
type
( o b j e c t t ) ,
intent
( in )
: :
t h i s
integer ,
intent
( in )
: :
type mold
integer
: :
r e t u r n v a l u e
end
function
C a l c v a l u e i n t
More than one module can possess the same generic procedure name. Here’s
an example using two derived types:
module Node mod
i m p l i c i t
none
private
public
: :
node t ,
P r i n t d a t a
type
node t
r e a l
: :
p o i n t s (3)
end type
node t
i n t e r f a c e
P r i n t d a t a
module procedure
Print node
end
i n t e r f a c e
P r i n t d a t a
contains
Cambridge Books Online © Cambridge University Press, 2012

176
MODERN FORTRAN
subroutine
Print node
( t h i s )
type
( node t ) ,
intent
( in )
: :
t h i s
!
. . .
code
to
p r i n t
the
components
of
a
type
!
. . .
node t
o b j e c t
end subroutine
Print node
end module Node mod
module Element mod
use Node mod ,
only
:
node t ,
P r i n t d a t a
i m p l i c i t
none
private
public
: :
element t ,
P r i n t d a t a
type
element t
integer
: :
i d
type
( node t ) ,
a l l o c a t a b l e
: :
nodes ( : )
end type
element t
i n t e r f a c e
P r i n t d a t a
module procedure
P r i n t e l e m e n t
end
i n t e r f a c e
P r i n t d a t a
contains
subroutine
P r i n t e l e m e n t
( t h i s )
type
( element t ) ,
intent
( in )
: :
t h i s
integer
: :
i n o d e
!
. . .
code
to
p r i n t
t h i s%i d
i f
( allocated
( t h i s%nodes ))
then
do
i n o d e = 1 ,
s i z e
( t h i s%nodes )
c a l l
P r i n t d a t a
( t h i s%nodes ( i n o d e ))
end do
end
i f
end subroutine
P r i n t e l e m e n t
end module Element mod
127. Use optional arguments to avoid replication.
The use of optional arguments allows a procedure to be called with a basic set
of arguments, and then, as additional capabilities are needed, the procedure
can grow to accommodate them (see Rules 57 and 58).
In the following example, two optional arguments provide the capability of
specifying that the printing of either of the components may be disabled.
Otherwise all are.
Listing 10.1: Module My type mod
module My type mod
i m p l i c i t
none
Cambridge Books Online © Cambridge University Press, 2012

GENERIC PROGRAMMING
177
private
public
: :
m y t y p e p r i n t
integer ,
parameter
: :
NAME LEN = 50
type ,
public
: :
my type t
character (NAME LEN)
: :
name comp
real ,
a l l o c a t a b l e
: :
v a l s ( : )
integer ,
a l l o c a t a b l e
: :
l o c s ( : )
end type
my type t
contains
subroutine
My type print
( t h i s ,
p r t v a l s ,
p r t l o c s )
type
( my type t ) ,
intent ( in )
: :
t h i s
l o g i c a l ,
intent ( in ) ,
optional
: :
p r t v a l s ,
p r t l o c s
l o g i c a l
: :
l o c a l p r t v a l s ,
l o c a l p r t l o c s
!
d e f a u l t :
p r i n t
both
components
v a l s
and
l o c s
l o c a l p r t v a l s = . true .
l o c a l p r t l o c s = . true .
p r i n t
* ,
’ my type t dump :
’ ,
t h i s%name comp
i f
( present
( p r t v a l s ))
l o c a l p r t v a l s = p r t v a l s
i f
( l o c a l p r t v a l s )
p r i n t
* ,
’
v a l s = ’ ,
t h i s%v a l s
i f
( present
( p r t l o c s ))
l o c a l p r t l o c s = p r t l o c s
i f
( l o c a l p r t l o c s )
p r i n t
* ,
’
l o c s = ’ ,
t h i s%l o c s
end subroutine
My type print
end module My type mod
128. Use elemental procedures to create rank-insensitive code.
When using arrays, it is often the case that procedures may need to be replicated
for each rank. Because Fortran supports arrays of up to 15 dimensions, plus
scalars, there could be as many as 16 rank combinations for each argument.
The number of procedures needed to support, say, two real kinds and two
complex kinds would be 64. By using elemental procedures, you may be able
to reduce this example to only four (see Rule 59).
Elemental procedures are written with all scalar dummy arguments. When
called with array actual arguments, the compiler will automatically call the
procedure for each array element. Elemental procedures are a special case of
pure procedures. So when evaluating candidates, keep in mind that they must
not introduce side effects (see Rule 52).
A typical example of such a subprogram is an accessor function that retrieves
the value of a component of a derived type.
type
o b j t
r e a l
: :
r comp
end type
o b j t
Cambridge Books Online © Cambridge University Press, 2012

178
MODERN FORTRAN
elemental
function
Get comp
( t h i s )
r e s u l t
( r e t v a l )
type
( o b j t ) ,
intent
( in )
: :
t h i s
r e a l
( kind
( t h i s%r comp ))
: :
r e t v a l
r e t v a l = t h i s%r comp
end
function
Get comp
All three of the references to Get comp in the following code will work. The
function will return either a scalar or an array that conforms to the actual
argument.
integer ,
parameter
: :
MAX 1 = 10 , MAX 2 = 20 , MAX 3 = 5
type
( o b j t )
: :
obj s ,
obj 1 (MAX 1) ,
obj 2 (MAX 2, MAX 3)
r e a l
: :
r s ,
r 1 (MAX 1) ,
r 2 (MAX 2, MAX 3)
r s = Get comp
( o b j s )
r 1 = Get comp
( obj 1 )
r 2 = Get comp
( obj 2 )
Elemental functions present one problem: All the actual arguments of elemen-
tal functions must be scalars. The compiler will reject the following function
interface because arguments x lim and y lim are arrays:
elemental
function
I s o u t o f b o u n d s
( t h i s , &
x lim ,
y l i m )
r e s u l t
( r e t u r n v a l u e )
type
( p o i n t t ) ,
intent
( in )
: :
t h i s
real ,
dimension (2) ,
intent
( in )
: :
x lim ,
y l i m
l o g i c a l
: :
r e t u r n v a l u e
. . .
end
function
I s o u t o f b o u n d s
One way to make this an elemental function is to organize the two arrays into
a derived type and to recast the interface:
type ,
public
: :
l i m i t t
real ,
dimension (2)
: :
x lim ,
y l i m
end type
l i m i t t
. . .
elemental
function
I s o u t o f b o u n d s
( t h i s ,
l i m i t p a i r ) &
r e s u l t
( r e t u r n v a l u e )
type
( p o i n t t ) ,
intent
( in )
: :
t h i s
type
( l i m i t t ) ,
intent
( in )
: :
l i m i t p a i r
l o g i c a l
: :
r e t u r n v a l u e
end
function
I s o u t o f b o u n d s
129. Use the result clause for function return values.
Fortran requires a symbolic name be used for function return values. By
default, the name is the same as the function itself. In complicated functions,
Cambridge Books Online © Cambridge University Press, 2012

GENERIC PROGRAMMING
179
Table 10.1. Speciﬁc and generic names for the intrinsic
square root functions
Specific Name
Generic Name
Argument Type
csqrt
sqrt
default complex
dsqrt
sqrt
double precision real
sqrt
sqrt
default real
the name may be both assigned to and used in many places. When replicating
the function to create speciﬁc versions, each and every one of these places
needs to be modiﬁed. To eliminate the need for simply changing the name of
the return value, the result clause may be used to deﬁne a non-default name.
function
D i s t a n c e r e a l
(a ,
b )
r e s u l t
( r e t u r n v a l )
real ,
intent ( in )
: :
a ,
b
!
Generic name
f o r
r e s u l t
r e a l
: :
r e t u r n v a l
!
This
l i n e
need
not
be changed
during
r e p l i c a t i o n .
r e t u r n v a l = abs
(a−b )
end
function
D i s t a n c e r e a l
130. Use the generic form of intrinsic functions.
For many generic intrinsic functions, Fortran has historically provided pro-
grammers with sets of speciﬁc function names. Each function has a speciﬁc
name, corresponding to both the type and kind of arguments that are passed to
it and to the type and kind of result that is returned. For example, the Fortran
standard speciﬁes the set of functions in Table 10.1 to calculate the square root
of a number. The generic versions of the intrinsic functions will work in the
same manner as the speciﬁc procedures and should always be used.
complex
: :
hypot
r e a l
: :
comp len
. . .
comp len = sqrt
( r e a l
( hypot )**2.0 + aimag ( hypot )**2.0)
Over the years, compiler vendors have also added their own functions and
extensions. Their use increases the likelihood that you will not be able to
port your code from one computing platform to another. For this reason you
should refrain from using them.
10.2 Preprocessor Replication
A preprocessor is a tool that reads the ﬁle that is to be compiled, performs
a set of transformations on it, then outputs the result to the compiler for
Cambridge Books Online © Cambridge University Press, 2012

180
MODERN FORTRAN
compilation. Preprocessing Fortran is not a standard stage of the compilation
process; it is typically speciﬁed in the speciﬁcation ﬁle used by a tool, such as
the make utility, to automate the build process.
Although some uses of preprocessors have been made obsolete by improve-
ments in Fortran itself, replicating code with them is still widely done. Prepro-
cessing reduces the possibility of errors that can occur when code is replicated
by manual editing. On the minus side, the code can be harder to comprehend
at ﬁrst glance. A more serious problem is that error messages and diagnostics
will sometimes point to locations in the preprocessed code and not the original.
Preprocessing also presents the challenge of anticipating all required speciﬁc
procedures and creating them. With large combinations of dummy arguments
of different types, kinds, and ranks, this could create an explosion of speciﬁc
routines. Care must be used to design routines that minimize this problem.
Two preprocessors are commonly used: the C language and the Fortran CoCo
(Conditional Compilation) preprocessors. We describe the latter, and present
an example of the former.
131. Use a preprocessor to automate generation of generic code via CoCo.
Beginning with the Fortran 95 Standard, a speciﬁcation for an optional pre-
processor has been available. The preprocessor speciﬁcation was primarily
designed for conditional compilation, that is, for code with sections that need
to be compiled differently for different environments. Machine-dependent
code, for example, handling differences between Unix and Windows ﬁle nam-
ing conventions, can be written in a Fortran-like syntax. At compile time, the
preprocessor can then be instructed to present the appropriate version of the
code to the compiler. The preprocessor deﬁned by the Standard is commonly
known as CoCo (pronounced “cocoa”).
An enhanced version of CoCo is publicly available (see Reference [19]). This
extended version allows substitution of text via a macro facility, which makes
it usable for performing generic code replication. Its use is similar to the C
processor, described in the following rule, and we refer you to the reference
for details.
132. Use a preprocessor to automate generation of generic code via the
C language preprocessor.
The C language preprocessor is commonly used for conditional compilation,
name substitution, and replication of code (see Reference [46]). A Fortran-
speciﬁc variation is sometimes provided by the compiler vendor because some
of the syntax common to both Fortran and C conﬂict in their meaning. For
example, // is the operator for character string concatenation in Fortran, but
it begins an in-line comment in C99. The variant limits the preprocessor
slightly to make itself more friendly to Fortran code. Some C preprocessors
accept a “traditional” option, which is also friendlier to Fortran code than in
strict ANSI C mode.
Cambridge Books Online © Cambridge University Press, 2012

GENERIC PROGRAMMING
181
The C preprocessor operates on the basis of macro substitution. It is case-
sensitive. The convention is to use UPPERCASE for words that the pre-
processor needs to substitute via macro substitution. First, the code to be
replicated is placed in its own ﬁle. The following is an example. The ﬁle is
called scan generic.inc:
function SPECIFIC NAME ( array )
r e s u l t
( r e s )
SPECIFIC TYPEKIND ,
intent ( in )
: :
array ( : )
SPECIFIC TYPEKIND
: :
r e s ( s i z e
( array ,
dim=1))
SPECIFIC TYPEKIND ,
parameter
: :
zero = 0
integer
: :
i
SPECIFIC TYPEKIND
: :
c a r r y
l o g i c a l
: :
f l i p
c a r r y
= array (1)
r e s (1) = c a r r y
do ,
i = 2 ,
s i z e
( array ,
dim=1)
c a r r y
= SPECIFIC OPERATOR( array ( i ) ,
c a r r y )
r e s ( i ) = c a r r y
end do
end
function SPECIFIC NAME
A module is then created, which can be run through the preprocessor. It uses
the #deﬁne directive to create a macro for setting the correct name, type and
kind, and operation for each speciﬁc procedure. The generic code is inserted
for each speciﬁc routine via the #include directive. Then the #undef directive
is used to clear the name so that it can be redeﬁned for the next speciﬁc routine.
Generic interface declarations allow the compiler to choose the correct speciﬁc
version at compile time.
Listing 10.2: Module Scan mod
module Kinds mod
i m p l i c i t
none
integer ,
parameter
: : DP = s e l e c t e d r e a l k i n d
(15 ,300)
end module Kinds mod
module Scan mod
use Kinds mod
i m p l i c i t
none
i n t e r f a c e
Scan plus
module procedure
S c a n p l u s r e a l
module procedure
Scan plus dp
end
i n t e r f a c e
Cambridge Books Online © Cambridge University Press, 2012

182
MODERN FORTRAN
i n t e r f a c e
Scan product
module procedure
S c a n p r o d u c t r e a l
module procedure
Scan product dp
end
i n t e r f a c e
Scan product
contains
!
Plus
scan
#define SPECIFIC OPERATOR(a , b )
( a + b )
#define SPECIFIC NAME
S c a n p l u s r e a l
#define SPECIFIC TYPEKIND
r e a l
#include
” s c a n g e n e r i c . i n c ”
#undef SPECIFIC NAME
#undef SPECIFIC TYPEKIND
#define SPECIFIC NAME Scan plus dp
#define SPECIFIC TYPEKIND
r e a l (DP)
#include
” s c a n g e n e r i c . i n c ”
#undef SPECIFIC NAME
#undef SPECIFIC TYPEKIND
!
Product
scan
#define SPECIFIC OPERATOR(a , b )
( a * b )
#define SPECIFIC NAME
S c a n p r o d u c t r e a l
#define SPECIFIC TYPEKIND
r e a l
#include
” s c a n g e n e r i c . i n c ”
#undef SPECIFIC NAME
#undef SPECIFIC TYPEKIND
#define SPECIFIC NAME Scan product dp
#define SPECIFIC TYPEKIND
r e a l (DP)
#include
” s c a n g e n e r i c . i n c ”
#undef SPECIFIC NAME
#undef SPECIFIC TYPEKIND
end module Scan mod
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

11.
Object Orientation
Until the advent of modern Fortran, the language could be classiﬁed as a
strictly procedural one, built from subroutines and functions. A procedural
program could be thought of as a series of calls to these procedures in which
the desired computations are performed. Object-oriented programming, on
the other hand, can be thought of as the interaction of independent entities,
whereby the computations are carried out by means of messages sent and
received by procedures (methods) bound to the entities (see Reference [8]).
Object-oriented programming (OOP) is a paradigm for programming that
emphasizes the construction of objects that group related data. The objects
are grouped with associated procedures and placed into a program unit, the
module beginning with Fortran 90. Fortran 90 provided a limited capability
for OOP, often referred to as “object-based” programming. Fortran 2003
provides the additional features that allow a programmer to program using
object-oriented techniques. Some of the key features of OOP are (a) entities
are constructed as objects. All objects are “instances” of what is commonly
referred to as a “class,” which Fortran 90 introduced as “derived types.” These
types deﬁne templates for the type data and its procedures. The placing of data
in derived types is called “encapsulation.” (b) The procedures are referred to as
“methods.” Execution of a program is carried out by objects communicating
with each other by invoking the methods of other objects. This process is
called “sending and receiving messages.” In Fortran 90, methods were created
by writing module procedures. Fortran 2003 expanded this capability by
introducing type-bound procedures and procedure components, methods that
are bound to a particular derived type.
Two additional OOP techniques that Fortran 2003 has brought to the lan-
guage, and that now allow the programmer to write code that conforms to
the OOP paradigm are “inheritance” and “polymorphism.” With inheritance,
derived types can be organized into a hierarchy of types. This is done in Fortran
by creating an “extended derived type” or “descendant” from an existing one,
which is referred to as the “parent type,” or “ancestor.” This new type inherits
the existing type’s data and methods, to which it can add its own. Polymor-
phism is accomplished by declaring an object as a “class.” Such an object can
take on the characteristics of its declared type or any of the descendants of that
type.
Object-oriented programming increases the possibility for creating reusable
code. Fortran programmers are accustomed to placing commonly used
183
Cambridge Books Online © Cambridge University Press, 2012

184
MODERN FORTRAN
algorithms into procedures, and then grouping the procedures in libraries,
so that the code can be reused. In Chapter 10 we have seen tools by which we
can write generic code that is written in a single way, yet can be expanded by
the compiler or preprocessor to handle a variety of input argument ranks, data
types, kinds, and so on. Now, with the full capability for object-oriented pro-
gramming that Fortran 2003 puts at his disposal, the programmer’s ability to
create reusable code that is easily maintained and expanded is further enhanced.
The remainder of this chapter comprises ﬁve sections: The ﬁrst presents some
basic rules for designing derived types; the rules apply equally well to derived
types written solely to the Fortran 95 standard as well as to types written
for Fortran 2003. The second section contains guidelines for the creation,
construction, initialization, and assignment of derived types. Here, the con-
centration is on aspects of types not involved with object orientation.
The last three sections make up a group: The third section introduces type-
bound procedures and the fourth inheritance. In the ﬁrst of these two, the
use of these procedures is explained. The section again discusses creation, con-
struction, and so on, zeroing in on features and capabilities that require type-
bound procedures. In this section, ﬁnal procedures, which must be written
as type-bound procedures, are presented. In the section on inheritance, the
remaining guidelines explain how type-bound procedures enable the inheri-
tance of object-oriented methods. Polymorphism, both regular and unlimited,
is explained in the ﬁnal section (see Reference [12]).
11.1 Type and Class Design
The rules in this section are general ones that apply to all derived types equally
well; they would be applicable to code written in conformance to the Fortran
95 standard.
133. Deﬁne every derived type in its own module, along with its type-
speciﬁc procedures.
For ease of maintenance, each major derived type should be deﬁned in a
distinct module. In this manner, a data object of one type can easily be made
a component of another type or several types (see Rule 120).
Commonly required type-speciﬁc procedures, including type-bound proce-
dures, should also be packaged along with their type deﬁnitions. A minimal
set of procedures to be considered are:
■Initialization procedure – beyond what is possible with default initialization
(see Section 7.1)
■Final procedure – when a derived-type object controls resources that require
special processing when the object ceases to exist (see Rule 147)
■Accessor procedures – to allow other program units access, as required, to
individual private components of derived-type objects (see Rule 135)
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
185
■Deﬁned operators – such as assignment, equality and inequality
■Print procedure – for debugging the type (see Rules 110 and 145)
■Module-speciﬁc error handler – for uniﬁed handling of errors
134. Use a unique name for every derived type.
Always choose a unique name for a derived type. A standard-conforming
compiler should not compile the following code because two distinct modules,
Name1 mod and Name2 mod, both deﬁne a type called same name t, each
distinct, and both are used in the main program, thereby creating an ambiguity.
module Name1 mod
i m p l i c i t
none
private
public
: :
same name t
type
same name t
integer
: :
i n t a
= 0
r e a l
: :
r e a l a = 1.0
end type
same name t
. . .
contains
. . .
module
procedures
end module Name1 mod
module Name2 mod
i m p l i c i t
none
private
public
: :
same name t
type
same name t
integer
: :
i n t a
= 0
r e a l
: :
r e a l a = 1.0
end type
same name t
. . .
contains
. . .
module
procedures
end module Name2 mod
program Same name
use Name1 mod ,
only
:
same name t
use Name2 mod ,
only
:
same name t
i m p l i c i t
none
type
( same name t )
: :
name var
name var%i n t a = 1.0
. . .
end program Same name
Cambridge Books Online © Cambridge University Press, 2012

186
MODERN FORTRAN
An exception applies if both type deﬁnitions include a sequence statement,
thereby making them sequence types. The physical storage and order of these
types are ﬁxed, thereby allowing storage association of blocks of data. They
serve their purpose, for example, accessing external telemetry data, where the
data is arranged in a particular order, but their use is restricted (see Reference
[38] and Rule 112). Here type same name t is a sequence type:
type
same name t
sequence
integer
: :
i n t a
= 0
r e a l
: :
r e a l a = 1.0
end type
same name t
135. Declare any data component of a derived type that is not required
for computation-intensive calculations to be private. Provide access to its
components so declared using type-bound accessor procedures.
Good programming practice using object-oriented programming techniques
recommends hiding the components of derived types. The program accom-
plishes all interactions with the concrete objects through their methods. The
term for this is “encapsulation.” In Fortran, the unit of encapsulation is the
module. Almost all entities in a module are publicly available within the
module regardless of whether they possess the public or the private attribute.
Other modules gain access to the public entities of modules by use of the use
statement. This grants them use access. They can further restrict and modify
access using the only option and the renaming capability (see Rules 48 and
49). This rule applies to modules accessing other modules by use association.
By default, all derived-type components possess the public attribute. You can
assign the private attribute to all the components, or, alternatively, beginning
with Fortran 2003, you can assign one of these two attributes on a component-
by-component basis. For public access to private components, you need to
write accessor routines. In the example that immediately follows, subroutine
Set rgb is the accessor procedure, written as a type-bound procedure, for the
private component array rgb.
module Pixel mod
i m p l i c i t
none
private
public
: :
NO OF PRIM COLS
integer ,
parameter
: :
NO OF PRIM COLS = 3
type ,
public
: :
p i x e l t
private
integer
: :
rgb (NO OF PRIM COLS) = 0
. . .
other
components
contains
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
187
procedure
: :
S e t c o l o r s => Set rgb
. . .
other
procedures
end type
p i x e l t
contains
subroutine
Set rgb
( t h i s ,
c o l o r s )
c l a s s
( p i x e l t ) ,
intent
( in
out )
: :
t h i s
integer
( kind
( t h i s%rgb ) ) ,
intent
( in )
: : &
c o l o r s (NO OF PRIM COLS)
t h i s%rgb = c o l o r s
end subroutine
Set rgb
. . .
end module Pixel mod
Here is a section of code that calls Set colors .
type
( p i x e l t )
: :
p i x e l g r i d ( GRID SIZE ,
GRID SIZE )
c a l l
p i x e l g r i d ( i r ,
i c )% S e t c o l o r s ( &
[ (WHITE,
i = 1 , NO OF PRIM COLS ) ] )
If, however, a component is used repeatedly in a time-consuming calculation,
it could be left public and used directly in the calculation. In the next example,
a plate is divided into a grid of elements, each at a different initial temperature.
The elements are of derived type grid t , deﬁned in the following Grid mod
module. The ﬁnal temperatures are determined by repeatedly calling the code
that follows the module to iterate to a solution by averaging the temperatures
of neighboring elements. If there are many calls, this could be time-consuming
because there would be repeated calls to a function to retrieve each element’s
temperature.
module Grid mod
i m p l i c i t
none
private
type ,
public
: :
g r i d t
r e a l
: :
temp = 0.0
. . .
other
components
end type
g r i d t
. . .
end module Grid mod
use
grid mod ,
only
:
g r i d t
integer ,
parameter
: :
GRID SIZE = 10000
integer
: :
i r ,
i c
type ( g r i d t ) ,
dimension ( GRID SIZE ,
GRID SIZE )
: : &
plate elems ,
new plate elems
Cambridge Books Online © Cambridge University Press, 2012

188
MODERN FORTRAN
. . .
code
to
i n i t i a l i z e
temperatures
loop rows :
do
i c = 2 ,
s i z e ( plate elems ,
dim=2) −1
l o o p c o l s :
do
i r = 2 ,
s i z e ( plate elems ,
dim=1) −1
! . .
i n t e r i o r
elements
! . .
compute
temperature
from
surrounding
elements .
new plate elems ( i r ,
i c )%temp = 0.25 * &
( p l a t e e l e m s ( i r −1,
i c )%temp + &
p l a t e e l e m s ( i r +1,
i c )%temp + &
p l a t e e l e m s ( i r ,
ic −1)%temp + &
p l a t e e l e m s ( i r ,
i c +1)%temp )
end do
l o o p c o l s
end do loop rows
. . . s i m i l a r
code
f o r
boundary
elements
As an alternative to this direct access, quickly access its value using an accessor
that returns a pointer. In the current example, type grid t would be written
like this:
module Grid mod
i m p l i c i t
none
private
type ,
public
: :
g r i d t
real ,
private
: :
temp = 0.0
. . .
other
components
contains
procedure
: :
Get temp ptr
!
. . .
other
type−bound
procedures
end type
g r i d t
. . .
contains
function
Get temp ptr
( t h i s )
r e s u l t
( r e t u r n p t r )
c l a s s
( g r i d t ) ,
intent
( in ) ,
target
: :
t h i s
real ,
pointer
: :
r e t u r n p t r
!
quick ;
no copy
i n v o l v e d
r e t u r n p t r => t h i s%temp
end
function
Get temp ptr
end module Grid mod
With this modiﬁcation in place, the body of the loop in the previous code
would be:
new plate elems
( i r ,
i c )%temp = 0.25
* &
( p l a t e e l e m s
( i r
−1,
i c )%Get temp ptr
() + &
p l a t e e l e m s
( i r
+1,
i c )%Get temp ptr
() + &
p l a t e e l e m s
( i r ,
ic −1)%Get temp ptr
() + &
p l a t e e l e m s
( i r ,
i c +1)%Get temp ptr
( ) )
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
189
This is one of the few cases where a function can safely return a pointer. There
are no ownership issues that can lead to memory issues.
11.2 Creation, Construction, Initialization,
and Assignment
Creation Objects are created in numerous ways. Section 7.1 contains rules
that pertain equally well to both intrinsic and derived-type objects. In this
section we narrow our focus to derived-type objects. The most basic method
of creating an object is a simple scalar or array declaration.
type ( o b j e c t t )
: :
object1 ,
o b j v e c t o r 1 (100)
type ( o b j e c t t ) ,
target
: :
o b j t a r ,
obj mat3 tar ( : , : , : )
!
o b j e c t
i s
created
by an
assigment
or
an
a l l o c a t i o n
type ( o b j e c t t ) ,
a l l o c a t a b l e
: :
object2 ,
obj mat2 ( : , : )
!
o b j e c t may be
created
by an
a l l o c a t i o n
( but may
!
be
a s s o c i a t e d
with
a
p r e v i o u s l y
created
o b j e c t )
type ( o b j e c t t ) ,
pointer
: :
obj p ,
obj mat row p ( : )
Objects may also be created in nonobvious ways. The return value of a func-
tion may be a derived type. Procedure arguments with intent (out) also cre-
ate objects. Likewise, expressions involving objects can also create temporary
objects.
Construction Unlike other object-oriented languages, Fortran does not sup-
port a user-deﬁned constructor, a procedure that executes automatically when-
ever a derived-type object is created in any manner. The optional default
initialization of components in the derived-type speciﬁcation is the only vehi-
cle for automatically initializing an object. Fortran does have what are called
“structure constructors.” These are explained in the next section on initial-
ization. Even though they are called constructors, they are not, from a strict
object-oriented sense, truly constructors because they do not execute automat-
ically whenever an object is created; instead, they must be explicitly written
into the code in every spot you need them to be executed.
Initialization, Part 1: Component Initialization The following rules apply
to initializing the components of derived types in their deﬁnition:
136. Whenever possible, initialize the components of derived types in their
deﬁnition. Always initialize pointer components to null ().
Whenever a variable of derived type comes into scope, that is, is created, its
components take on the values optionally speciﬁed in its deﬁnition (see Rule
137). For example, if a subroutine has a dummy argument of derived type
whose intent is intent (out), and any of the type’s components are initialized in
Cambridge Books Online © Cambridge University Press, 2012

190
MODERN FORTRAN
its deﬁnition, the program will initialize them to the speciﬁed values when exe-
cution enters the routine. The value of any component not so speciﬁed is unde-
ﬁned. Providing a default initialization in this manner will prevent accidentally
referencing an undeﬁned variable. Here is an example of a derived type that is
a three-dimensional vector deﬁned by its origin, direction cosines, and length:
type
v e c t o r t
!
s e t
a l l
components
of
o r i g i n = 0.0
real ,
dimension (3)
: :
o r i g i n = 0.0 , &
d i r c o s i n e s = [ 1 . 0 ,
0.0 ,
0 . 0 ]
r e a l
: :
v e c l e n= 0.0
end type
v e c t o r t
On entry to a program with the following interface, the value of the com-
ponents of dummy argument ret value will be initialized as speciﬁed in the
deﬁnition:
subroutine
I n i t v e c t o r
( o r i g i n ,
components ,
r e t v a l u e )
real ,
dimension (3) ,
intent
( in )
: :
o r i g i n ,
components
type
( v e c t o r t ) ,
intent
( out )
: :
r e t v a l u e
end subroutine
I n i t v e c t o r
137. Initialize all derived-type parameters in the deﬁnition of parameter-
ized derived types.
Initialize the length and kind type parameters in parameterized derived types
when they are deﬁned. Here is an example of a type containing a text label.
Both the type parameters and the components are initialized (see Rule 136).
integer ,
parameter
: : MAX LENGTH = 80
type ,
public
: :
l a b e l t
( t e x t l ,
text k ,
l o c k )
integer ,
len
: :
t e x t l = MAX LENGTH
integer ,
kind
: :
t e x t k = kind
( ”a” ) , &
l o c k
= s e l e c t e d i n t k i n d
(3)
character
( len=t e x t l ,
kind=t e x t k )
: :
t e x t = ””
integer
( kind=l o c k )
: :
l o c a t i o n (2) = 0
end type
l a b e l t
Initialization, Part 2: Structure Constructors Structure constructors may
be used to initialize variables in their declarations and to create unnamed
objects within expressions. However, unlike the behavior described in Part 1,
structure constructors initialize derived-type components only when they, the
constructors, are speciﬁed explicitly in the code.
Here are two examples of structure constructors being used to initialize data: in
the ﬁrst, an array called blood cells of type cell t , in the second, a variable of
type colors t called us ﬂag colors . Each of the nameless expressions such as
cell t (”red”) and colors t (”red”) on the right-hand side of the assignment
statements are also structure constructors.
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
191
!
i n i t i a l i z a t i o n
i n
a
d e c l a r a t i o n .
type ( c e l l
t )
: :
b l o o d c e l l s (2) = &
[ c e l l
t
( ” red ” ) ,
c e l l
t
( ” white ” ) ]
!
i n i t i a l i z a t i o n
i n
an
assignment .
type ( c o l o r s t ) ,
a l l o c a t a b l e
: :
u s f l a g c o l o r s ( : )
. . .
u s f l a g c o l o r s = [ c o l o r s t ( ” red ” ) , &
c o l o r s t ( ” white ” ) ,
c o l o r s t ( ” blue ” ) ]
138. Always use keywords in structure constructors.
The use of keywords in derived-type structure constructors permits you to
override the initial values given to a component in the type deﬁnition. It allows
the derived type deﬁnition to vary as the program is developed and maintained,
both in its contents (components) and their order without affecting existing
code. Here is a short program that includes a polymorphic derived type (see
Section 11.5). First, two types are deﬁned, each in its own module. A short
program that uses a structure constructor follows:
Listing 11.1: Program Comp name
module
Position mod
i m p l i c i t
none
private
type ,
public
: :
p o s t
r e a l
: :
xy coords (2) = 0.0
contains
procedure
: :
Get coords
end type
p o s t
contains
function
Get coords
( t h i s )
r e s u l t
( r e t v a l s )
c l a s s
( p o s t ) ,
intent
( in )
: :
t h i s
r e a l
( kind
( t h i s%xy coords ))
: :
r e t v a l s (2)
r e t v a l s = t h i s%xy coords
end
function
Get coords
end module
Position mod
module Pixel mod
use
Position mod ,
only
:
p o s t
i m p l i c i t
none
private
public
: :
BLACK, GRAY, WHITE
Cambridge Books Online © Cambridge University Press, 2012

192
MODERN FORTRAN
integer ,
parameter
: : &
MAX LEVEL
= 256 , GRAY LEVEL = MAX LEVEL / 2
integer ,
parameter
: : &
BLACK = 0 , GRAY = GRAY LEVEL , WHITE = MAX LEVEL
type ,
public ,
extends
( p o s t )
: :
p i x e l t
integer
: :
rgb (3) = BLACK
contains
procedure
: :
Get rgb
end type
p i x e l t
contains
function
Get rgb
( t h i s )
r e s u l t
( r e t v a l s )
c l a s s
( p i x e l t ) ,
intent
( in )
: :
t h i s
integer
( kind=kind
( t h i s%rgb ))
: : &
r e t v a l s ( s i z e
( t h i s%rgb ))
r e t v a l s = t h i s%rgb
end
function
Get rgb
end module Pixel mod
program Comp name
use
Position mod ,
only
:
p o s t
use
Pixel mod ,
only
: GRAY,
p i x e l t
i m p l i c i t
none
integer ,
parameter
: :
I ROWS = 10 , I COLS = 10
type
( p i x e l t ) ,
a l l o c a t a b l e
: :
p i x e l s ( : ,
: )
type
( p o s t )
: :
l o c
integer
: :
a l l o c s t a t
a l l o c a t e
( p i x e l t
: :
p i x e l s (I ROWS ,
I COLS ) , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
!
two
s t r u c t u r e
c o n s t r u c t o r s
with
keywords :
!
use name of
the
parent
type
i n
p i x e l t .
!
o v e r r i d e
d e f a u l t
rgb
component .
l o c
= p o s t
( xy coords =[5.3 ,
−4.2])
p i x e l s = p i x e l t
( rgb=GRAY,
p o s t=l o c )
p r i n t
* , ” rgb :
” ,
p i x e l s (1 , 1)%rgb
p r i n t
* , ” xy coords :
” ,
p i x e l s (1 , 1)% xy coords
e l s e
p r i n t
* , ” a l l o c a t i o n
problem ”
stop
end
i f
end program Comp name
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
193
139. Always use keywords to specify the values of type parameters when
declaring parameterized derived types and when initializing them using
structure constructors.
The Fortran 2003 standard speciﬁes an order for type parameters for use when
declaring a derived type. For a nonextended type, it is the order of the type
parameters in the deﬁnition. For extended types, the order is ﬁrst the type
parameters of the parent type followed by those of the child type, both in the
order they were speciﬁed in their respective deﬁnitions. To avoid confusion,
use keywords to specify the values. Here is the deﬁnition of such a type,
temp grid t :
integer ,
parameter
: :
SP = s e l e c t e d r e a l k i n d
(6 ,
37)
integer ,
parameter
: : DP = s e l e c t e d r e a l k i n d
(15 ,
307)
integer ,
parameter
: :
DEF COLS = 20 , DEF ROWS = 20
type
t e m p g r i d t
( prec ,
cols ,
rows )
integer ,
kind
: :
prec = SP
integer ,
len
: :
c o l s = DEF COLS ,
rows = DEF ROWS
r e a l
( kind=PREC)
: :
temperatures ( rows ,
c o l s ) = 1.0
end type
t e m p g r i d t
When a data object of type temp grid t is initialized by coming into scope, its
components and type parameters will take on the default values speciﬁed in the
type deﬁnition. It is possible to override the default values of the length type
parameters (only), either in the declaration or by using a structure constructor
as in these two examples here:
!
d e c l a r a t i o n
type
( t e m p g r i d t
( c o l s =40, rows =40))
: :
temp grid 1
. . .
!
s t r u c t u r e
c o n s t r u c t o r
type
( t e m p g r i d t )
: :
temp grid 2
temp grid 2 = t e m p g r i d t
( c o l s =40, rows=40) &
( temperatures = 100.0)
140. For derived types requiring extensive initialization, consider using
user-deﬁned structure constructors.
Fortran 2003 introduced the capability of overriding the default structure
constructor for objects that need more extensive initialization. For example,
an object may need to have some of its elements read in from a data ﬁle, so a
procedure can be written and explicitly called after it is created. This is done
by creating a generic function whose name is the same as the derived type
but whose interface differs unambiguously from the interface of the default
constructor.
As an example, here is a segment of code. It contains a type that needs to be
initialized by a subprogram. Instead of explicitly calling a routine, a logical
Cambridge Books Online © Cambridge University Press, 2012

194
MODERN FORTRAN
component indicates if a variable of the type has been initialized, and an
override of the structure constructor causes the initialization to occur.
module Mesh mod
i m p l i c i t
none
private
type ,
public
: :
mesh t
character ( : ) ,
a l l o c a t a b l e
: :
f i l e n a m e
integer ,
a l l o c a t a b l e
: :
pts ( : , : )
integer ,
a l l o c a t a b l e
: :
connects ( : , : )
l o g i c a l
: :
i n i t = . f a l s e .
end type
mesh t
!
c r e a t e
s t r u c t u r e
c o n s t r u c t o r
o v e r r i d e
by
i n t e r f a c e
!
whose name
i s
the
type .
i n t e r f a c e
mesh t
module procedure
Mesh t const
end
i n t e r f a c e
contains
!
procedure
c a l l e d
when
using
c o n s t r u c t o r
o v e r r i d e .
function
Mesh t const
( m e s h f i l e ) &
r e s u l t
( r e t u r n v a l u e )
character (*) ,
intent ( in )
: :
m e s h f i l e
type
( mesh t )
: :
r e t u r n v a l u e
c a l l
M e s h i n i t
( r e t u r n v a l u e ,
m e s h f i l e )
end
function
Mesh t const
subroutine
M e s h i n i t
( t h i s ,
m e s h f i l e )
type ( mesh t ) ,
intent
( in
out )
: :
t h i s
character (*) ,
intent
( in )
: :
m e s h f i l e
integer
: :
i o s t a t
!
. . .
code
to
open ,
read ,
and
c l o s e
the
f i l e ,
!
. . .
s e t t i n g
i o s t a t
at
each
stage .
i f
( i o s t a t == 0)
t h i s%i n i t = . true .
end subroutine
M e s h i n i t
. . .
end module Mesh mod
The following constructor will trigger a call to the user-deﬁned constructor:
type
( mesh t ) ,
intent
( in
out )
: :
mesh
. . .
i f
( . not .
mesh%i n i t ) &
mesh = mesh t
( m e s h f i l e=” d a t a d i r / mesh def ” )
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
195
Here, the interface of the constructor override differs unambiguously from the
default constructor. Therefore, the following constructor would trigger the
normal structure constructor, not the user-deﬁned one:
mesh = mesh t
( f i l e n a m e=” d a t a d i r / mesh def ” , &
pts=n u l l
( ) ,
connects=n u l l
( ) ,
i n i t =. f a l s e . )
In cases where there might be an ambiguity, you can ensure that only a
user-written override constructor, and not the default constructor, be called
from outside a module by specifying the accessibility of the components
to be private. If this is not possible, always specify argument names in the
override that differ from the component names, and then invoke either the
default constructor or the override, as necessary, by employing keywords. If
the function statement interface to the override had been
function
Mesh t const
( m e s h f i l e ,
pnts ,
con ) &
r e s u l t
( r e t u r n v a l u e )
the ﬁrst of the following two statements invokes the default constructor, the
second the override:
! dummy argument
keyword
i s
component name :
d e f a u l t
!
c o n s t r u c t o r
mesh t
( f i l e n a m e = ” d a t a d i r / mesh def ” , &
pts = n u l l
( ) ,
connects = n u l l
()
)
. . .
! dummy argument
keyword
i s
argument name of
o v e r r i d e :
!
o v e r r i d e
c o n s t r u c t o r
mesh t
( m e s h f i l e = ” d a t a d i r / mesh def ” , &
pnts = n u l l
( ) ,
cons = n u l l
()
)
A signiﬁcant restriction of user-deﬁned structure constructors is that they
cannot be used in initialization expressions in variable declarations.
Assignment In this section we discuss using a deﬁned assignment for extensive
derived-type initialization.
141. For derived types requiring extensive initialization, consider using a
deﬁned assignment.
An alternative method of accomplishing the extended initialization described
in Rule 140 is to use a deﬁned assignment. Deﬁned assignment operations
are carried out by user-written subroutines that are assigned to the generic
speciﬁer assignment(=). This is an overload of the assignment operator. Here
is the code to accomplish this:
module Mesh mod
i m p l i c i t
none
private
public
: :
assignment (=)
Cambridge Books Online © Cambridge University Press, 2012

196
MODERN FORTRAN
type ,
public
: :
mesh t
character ( : ) ,
a l l o c a t a b l e
: :
f i l e n a m e
integer ,
a l l o c a t a b l e
: :
pts ( : , : )
integer ,
a l l o c a t a b l e
: :
connects ( : , : )
l o g i c a l
: :
i n i t = . f a l s e .
end type
mesh t
i n t e r f a c e
assignment (=)
module procedure
Mesh t assign
end
i n t e r f a c e
contains
subroutine
Mesh t assign
(a ,
b )
type
( mesh t ) ,
intent
( out )
: :
a
type
( mesh t ) ,
intent
( in )
: :
b
!
a s s i g n
on a component−by−component
b a s i s .
!
( a = b ,
i t s e l f
an
assignment ,
g e n e r a t e s
an
!
i l l e g a l
and
e n d l e s s
r e c u r s i v e
c a l l . )
i f
( b%i n i t )
then
a%f i l e n a m e = b%f i l e n a m e
a%pts
= b%pts
a%connects = b%connects
a%i n i t
= b%i n i t
e l s e
c a l l
M e s h i n i t
(a ,
m e s h f i l e=b%f i l e n a m e )
end
i f
end subroutine
Mesh t assign
subroutine
M e s h i n i t
( t h i s ,
m e s h f i l e )
type
( mesh t ) ,
intent
( in
out )
: :
t h i s
character (*) ,
intent
( in )
: :
m e s h f i l e
integer
: :
i o s t a t
!
. . .
code
to
open ,
read ,
and
c l o s e
the
f i l e ,
!
. . .
s e t t i n g
i o s t a t
at
each
stage .
i f
( i o s t a t == 0)
t h i s%i n i t = . true .
end subroutine
M e s h i n i t
. . .
end module Mesh mod
Contrasting this with the code in Rule 140, with this code in place, a mesh t
objectcanbecreated bysimplyusingthestructureconstructorinanassignment
to trigger the initialization:
!
Assignment
invokes
c a l l
to
M e s t t a s s i g n
!
with
d e f a u l t
c o n s t r u c t o r
on
r . h . s .
of
=.
mesh = mesh t
( f i l e n a m e=” d a t a d i r / mesh def ” )
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
197
Make further note that because allocatable array components are used, and
therefore cannot have their default initialization speciﬁed in the type deﬁni-
tions, they will be initialized to an unallocated state in the structure construc-
tor. This is a Fortran 2008 feature. For Fortran 2003 compilers, the intrinsic
function null () needs to be explicitly used to achieve the same end:
mesh = mesh t
( f i l e n a m e=” d a t a d i r /mesh . def ” ,
&
pts=n u l l
( ) ,
connects=n u l l
()
)
A caveat applies to this: The assumption in writing this particular assignment
is that the data components of mesh t are public; otherwise, you cannot access
them from outside the module. If the data components are private, as Rule
135 recommends for most situations, a deﬁned assignment can still be used.
One way would be to write a public module function that returns a variable of
the target type, mesh t in the example, whose dummy argument corresponds
to the ﬁlename component:
function
Build mesh t
( f i l e n a m e )
r e s u l t
( r e t u r n m e s t t )
character
(*) ,
intent
( in )
: :
f i l e n a m e
type
( mesh t )
: :
r e t u r n m e s h t
r e t u r n m e s h t%f i l e n a m e = f i l e n a m e
end
function
Build mesh t
The deﬁned assignment would then work if it was written like this:
mesh object=Build mesh t
( f i l e n a m e=” d a t a d i r / mesh def ” )
11.3 Type-Bound Procedures and Procedure
Pointer Components
Type-bound procedures, introduced in Fortran 2003, are intricately involved
in type design and object orientation. This section discusses their general
capabilities. The ﬁrst rule explains their syntax, accessibility, and invocation;
the second explains how to use the generic statement to create generic names
from two or more of these procedures. The third moves to a related and similar
feature, procedure pointer components, also referred to simply as procedure
components.
142. Write type-bound procedures to implement inheritance and
polymorphism.
In object-oriented terminology, procedures bound to objects of a speciﬁc type
are called methods; invoking the procedure is called “sending the object a
message.” The creation of the object is termed “instantiation.” In Fortran
2003, you create methods by writing type-bound procedures.
Cambridge Books Online © Cambridge University Press, 2012

198
MODERN FORTRAN
Type-bound procedures are an indispensable tool in inheritance. Their use
greatly reduces the need to rewrite code, but you need not restrict their use to
types that are extended; you can use them for all derived types.
What follows in this guideline is a basic description of type-bound procedures:
the syntax used to declare them, and the attributes that ﬁx the manner in
which they are both accessible to and invoked in program units other than the
one in which they are deﬁned.
Basic Syntax Type-bound procedures are speciﬁed within the derived-type
deﬁnition in a separate section marked by the keyword contains.
module Pt2d mod
i m p l i c i t
none
private
type ,
public
: :
pt2d t
private
r e a l
: :
x = 0.0 ,
y = 0.0
contains
!
binding −name => [ procedure −name ]
!
no
procedure name
i f
i t
i s
the
same as
the
!
binding
name
procedure
: :
Add points
procedure
: :
Get length => Comp dist
. . .
more
p r o c e s s
bi n d i n g
statements .
end type
pt2d t
. . .
contains
!
. . .
code
f o r
procedure
Add points
function
Comp dist
( pt 1 ,
pt 2 )
r e s u l t
( r e t v a l )
!
c l a s s
must be
used
f o r
the
passed
argument .
c l a s s
( pt2d t ) ,
intent
( in )
: :
pt 1 ,
pt 2
r e a l
(
kind
( pt 1%x )
)
: :
r e t v a l
r e a l
(
kind
( pt 1%x )
)
: :
x d i s t ,
y d i s t
. . .
e x e c u t a b l e
code
end
function
Comp dist
. . .
end module Pt2d mod
Accessibility: public and private An important feature in the previous code
is the fact that the type-bound procedures are not listed in a module-scope
public statement. Their accessibility differs from module procedures and other
entities having module scope.
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
199
Here are speciﬁc characteristics about type-bound procedure accessibility:
■Unless speciﬁcally declared to be private using the private keyword in the
deﬁnition of a derived type, type-bound procedures are public. Moreover,
even if the speciﬁc procedures are assigned the private attribute, the generic
procedure, assignment, or user-deﬁned operator to which they are bound
can be given the public attribute when it is speciﬁed as being generic.
■To have public accessibility, type-bound procedures need not be speciﬁcally
assigned the public attribute in a public statement even if the default
accessibility of a module is private. The type, however, must be public.
■Type-bound procedures are accessible via use association of a module even if
the binding name is not listed among the entities following the only option
of a use statement. The type it is bound to, though, must be accessible.
A use statement to obtain this access could be as follows:
use Pt2d mod ,
only
:
pt2d t
Invocation: pass and nopass Here is code that invokes binding Get length,
which causes a reference to speciﬁc procedure Comp dist.
type
( pt2d t )
: :
point a ,
p o i n t b
r e a l
: :
d i s t a n c e
!
Invoke
binding name
d i s t a n c e = p o i n t a%Get l e n g t h
( p o i n t b )
Each type-bound procedure and procedure component possesses by default
the pass attribute. This means that the object is passed as an actual argument,
and that argument, again by default, corresponds to the ﬁrst dummy argument
of the speciﬁc procedure interface. In the case of subroutine Comp dist, the
data reference is point a.
Alternatives to the pass attribute are pass (arg-name ) and nopass. The ﬁrst
provides a method of designating a dummy argument other than the ﬁrst as the
one to pass as the object. Here, the second argument of procedure Comp dist
is the one passed:
procedure ,
pass
( p o i n t 2 )
: :
Get length => Comp dist
d i s t a n c e = p o i n t b%Get length
( p o i n t a )
If you assign the nopass attribute, the object is not passed at all. This capability
is useful for procedures that operate on the class as a whole, rather than on
a speciﬁc object. Note, though, that the same syntax is used to invoke the
procedure as that for procedures having the pass attribute (see Rule 144).
procedure ,
nopass
: :
Calc
. . .
c a l l
obj%Calc
()
Cambridge Books Online © Cambridge University Press, 2012

200
MODERN FORTRAN
143. Create generic speciﬁcations for type-bound bindings that perform
similar tasks but have distinct dummy arguments.
Employing the generic keyword to create a generic binding, you can make two
or more type-bound procedures generic, that is, you can invoke them using a
common name. This makes the generic speciﬁer, the common name, generic
in the same sense as the generic interface block explained in Rule 126, and the
same rules that applied there apply with generic bindings. The following type
deﬁnition shows how this works:
module Simple mod
type ,
public
: :
s i m p l e t
integer
: :
int comp
r e a l
: :
real comp
contains
!
no
p u b l i c
access
to
procedures
private
procedure
: :
Set int comp
procedure
: :
Set real comp
!
p u b l i c
access
to
g e n e r i c
binding
generic ,
public
: :
Set => Set int comp
generic ,
public
: :
Set => Set real comp
end type
s i m p l e t
contains
. . .
subroutine
Set int comp
( t h i s ,
p a s s e d i n t )
c l a s s
( s i m p l e t ) ,
intent
( in
out )
: :
t h i s
integer ,
intent
( in )
: :
p a s s e d i n t
t h i s%int comp = p a s s e d i n t
end subroutine
Set int comp
. . .
s i m i l a r
code
f o r
s e t r e a l c o m p .
end module Simple mod
The generic speciﬁer is Set. Here are two calls to it – the ﬁrst to set the value
of the integer component, the second to set the real component:
type
( s i m p l e t )
: :
s i m p l e o b j
integer
: :
i n t v a l
. . .
c a l l
s i m p l e o b j%Set
( i n t v a l )
c a l l
s i m p l e o b j%Set
( 4 . 5 2 )
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
201
144. Use procedure pointer components to invoke different subprograms
possessing identical interfaces.
In Rule 90 we presented procedure pointers. Here, we introduce procedure
pointer components, which are also such pointers. They share much in com-
mon with type-bound procedures: the attributes you can assign to them, the
syntax you use to invoke them, and the rules you use to govern their behavior.
This next example is a complete program called Transaction demonstrating
these types of components. Where necessary, comments in the code point out
some of the characteristics of procedure components. The term following the
keyword procedure in parentheses is designated the interface-spec. It
can be the name of either an abstract interface or of a speciﬁc procedure having
an explicit interface. Procedure components share both the pass and nopass
attribute with type-bound procedures, and the characteristics of the attribute
are indentical for both.
Listing 11.2: Program Transaction
module Transaction mod
i m p l i c i t
none
private
public
: : BUY,
Execute op ,
P r i n t r e p o r t ,
SELL
enum ,
bind (C)
enumerator
: :
NO OP = 0 , BUY,
SELL
enumerator
: :
BRIEF = 1 , DETAIL
end enum
type ,
public
: :
t r a n s a c t i o n t
integer
: :
t r a n s i d ,
i o p
character ( len =:) ,
a l l o c a t a b l e
: :
trans name ,
comment
r e a l
: :
amount ,
p r i c e
!
procedure
component
d e c l a r e d
with
data
components ,
!
not
with
type−bound
procedures .
procedure
( P r i n t t y p e ) ,
pointer ,
private
: : &
P r i n t p t r => n u l l
()
end type
t r a n s a c t i o n t
abstract
i n t e r f a c e
subroutine
P r i n t t y p e
( t h i s )
import
: :
t r a n s a c t i o n t
c l a s s
( t r a n s a c t i o n t ) ,
intent
( in )
: :
t h i s
end subroutine
P r i n t t y p e
end
i n t e r f a c e
Cambridge Books Online © Cambridge University Press, 2012

202
MODERN FORTRAN
integer ,
parameter
: :
NO OF OPS = 3 , MAX TRANS = 1000
integer
: :
id op = 0 ,
i n d e x c u r r e n t = 0 , &
j r e p o r t l e v e l = BRIEF
character ( len =*) , parameter
: : &
OP NAMES( 0 : NO OF OPS −1) = &
[ character ( len =5)
: :
”NO OP” , ”BUY” , ”SELL”
]
type
( t r a n s a c t i o n t ) ,
save
: :
t r a n s a c t i o n s (MAX TRANS)
contains
function
Execute op
( op name ,
i op ,
op amount , &
op price ,
op comment )
r e s u l t
( r e t u r n i d )
character
( len =*) ,
intent
( in )
: :
op name
integer ,
intent
( in )
: :
i o p
real ,
intent
( in )
: :
op amount ,
o p p r i c e
character
( len =*) ,
intent
( in ) ,
optional
: : &
op comment
integer
: :
r e t u r n i d
type
( t r a n s a c t i o n t )
: :
t r a n s a c t i o n
r e t u r n i d = 0
id op
= id op + 1
t r a n s a c t i o n = t r a n s a c t i o n t
( t r a n s i d=id op , &
i o p=i op ,
trans name=trim
( op name ) , &
comment=n u l l
( ) , &
amount=op amount ,
p r i c e=o p p r i c e )
i f
( present
( op comment )) &
t r a n s a c t i o n%comment = trim
( op comment )
i n d e x c u r r e n t = i n d e x c u r r e n t + 1
t r a n s a c t i o n s ( i n d e x c u r r e n t ) = t r a n s a c t i o n
r e t u r n i d = id op
end
function
Execute op
subroutine
P r i n t b r i e f
( t h i s )
c l a s s
( t r a n s a c t i o n t ) ,
intent
( in )
: :
t h i s
write
(* , ” (A,
I0 , A) ” ) ” i d :
” ,
t h i s%t r a n s i d , &
” name :
” // trim
( t h i s%trans name ) , &
”
o p e r a t i o n :
” // OP NAMES( t h i s%i o p )
write
(* , ” (2(A,
F0 . 3 ) ) ” ) ” s h a r e s :
” ,
t h i s%amount , &
”
p r i c e :
” ,
t h i s%p r i c e
end subroutine
P r i n t b r i e f
subroutine
P r i n t d e t a i l
( t h i s )
c l a s s
( t r a n s a c t i o n t ) ,
intent
( in )
: :
t h i s
write
(* , ” (A,
I0 , A) ” ) ” i d :
” ,
t h i s%t r a n s i d , &
” name :
” // trim
( t h i s%trans name ) , &
”
o p e r a t i o n :
” // OP NAMES( t h i s%i o p )
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
203
write
(* , ” (2(A,
F0 . 3 ) ) ” ) ” s h a r e s :
” ,
t h i s%amount , &
”
p r i c e :
” ,
t h i s%p r i c e
i f
( allocated
( t h i s%comment )) &
write
(* , ” (A) ” ) ”comment :
” // trim
( t h i s%comment )
end subroutine
P r i n t d e t a i l
subroutine
P r i n t r e p o r t
integer
: :
j o p
!
point
procedure
component
to
the
a p p r o p r i a t e
!
procedure .
s e l e c t
case
( j r e p o r t l e v e l )
case
(BRIEF)
f o r a l l
( j o p =1:
i n d e x c u r r e n t ) &
t r a n s a c t i o n s ( j o p)% P r i n t p t r => P r i n t b r i e f
case
(DETAIL)
f o r a l l
( j o p =1:
i n d e x c u r r e n t ) &
t r a n s a c t i o n s ( j o p)% P r i n t p t r => P r i n t d e t a i l
case
default
end
s e l e c t
do
j o p = 1 ,
i n d e x c u r r e n t
c a l l
t r a n s a c t i o n s ( j o p)% P r i n t p t r
()
end do
end subroutine
P r i n t r e p o r t
end module Transaction mod
program
Transaction demo
use
Transaction mod ,
only
: BUY,
Execute op , &
P r i n t r e p o r t ,
t r a n s a c t i o n t ,
SELL
i m p l i c i t
none
integer
: :
id op
id op = Execute op
( ”AJAX” , BUY,
25.2 ,
3.53)
id op = Execute op
( ”ACME” , SELL ,
33.3 ,
8.54 , &
” s h o r t
s a l e ” )
c a l l
P r i n t r e p o r t
end program
Transaction demo
The following is the program output:
id: 1 name: AJAX
operation: BUY
shares: 25.200 price: 3.530
id: 2 name: ACME
operation: SELL
shares: 33.300 price: 8.540
Cambridge Books Online © Cambridge University Press, 2012

204
MODERN FORTRAN
A new feature of Fortran 2008 applies to procedure component initializa-
tion that Fortran 2003 limits to the null () intrinsic function. With Fortran
2008 you may initialize the binding by writing the derived-type deﬁnition for
transaction t like this:
procedure
( P r i n t t y p e ) ,
pointer ,
private
: : &
P r i n t p t r => P r i n t b r i e f
145. For debugging purposes, for every derived type, write a type-bound
procedure that prints its components.
You should write a procedure for every derived type that prints the value of
its components. Fortran 2003 has introduced deﬁned derived-type input/out-
put (DTIO), which can be used to write output routines for printing the
components of derived type (see Rule 110).
146. Write type-bound subroutines for deﬁned assignments.
The accessibility characteristics of type-bound procedures, and of generic oper-
ators or assignments bound to them (see Rule 142) make them especially
useful, and safer, for deﬁned assignments. They should be used in place of
the user-deﬁned structure constructors written using module procedures (see
Rule 140). These characteristics imply that a deﬁned assignment will always
be carried out if it is a type-bound procedure; there is almost no possibility of
an intrinsic assignment of a variable to an expression if both are of the same
derived type.
This rule returns to Rule 141. In that rule, the deﬁned assignment was created
using a module procedure. Now it’s created using a type-bound procedure.
The deﬁnition of type mesh t is now:
module Mesh mod
i m p l i c i t
none
private
type ,
public
: :
mesh t
character ( : ) ,
a l l o c a t a b l e
: :
f i l e n a m e
integer ,
dimension
( : , : ) ,
a l l o c a t a b l e
: : &
pts ,
connects
l o g i c a l
: :
i n i t = . f a l s e .
contains
!
no
p u b l i c
access
to
the
procedure .
private
procedure
: :
Mesh t assign
!
p u b l i c
access
to
the
assignment
generic ,
public
: :
assignment (=) => Mesh t assign
end type
mesh t
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
205
With this code in place, an assignment such as this can be written:
type
( mesh t )
: :
mesh a ,
mesh b
. . .
mesh a = mesh b
147. Provide a ﬁnal subroutine for all derived types that have pointer
components or that require special handling when they cease to exist.
As mentioned in the section introduction, while Fortran does not support
automatic constructors; it does support user-deﬁned ﬁnalization procedures,
often called destructors in other languages. These are type-bound procedures
that the program will invoke whenever a derived-type object ceases to exist.
Final procedures allow you to cleanly handle both objects with non-simple
components such as pointers to other objects, reference counts, and objects
that have reserved resources such as open data ﬁles.
A program will automatically invoke a type-bound ﬁnal subroutine when an
object of a derived type ceases to exist. To prevent memory leaks and dangling
pointers, you should write one that processes the pointer components of all
derived types. In addition, components requiring special processing, such as a
ﬁle unit number representing an open ﬁle that needs to be closed, should be
processed to properly release their resources.
Referring to the code in Rule 146 that presents module mesh mod and derived
type mesh t, we add a unit number component for ﬁle objects.
type ,
public
: :
mesh t
integer
: :
unit number = INVALID UNIT
character ( : ) ,
a l l o c a t a b l e
: :
f i l e n a m e
integer ,
dimension ( : , : ) ,
pointer
: :
pts ,
connects
l o g i c a l
: :
i n i t = . f a l s e .
contains
private
. . .
end type
mesh t
Now, when a variable of type mesh t goes out of scope and no longer exists,
the ﬁle needs to be properly closed. Furthermore, there are two pointer com-
ponents to account for. If a type mesh t object is allocatable, only ﬁlename is
automatically deallocated when the object is. The following code will cause
deallocation of ﬁlename in addition to mesh 1: The ﬁle, however, will not be
automatically closed nor the pointers automatically deallocated.
type ,
a l l o c a t a b l e
: :
mesh 1
. . .
deallocate
( mesh 1 ,
stat=a l l o c s t a t )
Cambridge Books Online © Cambridge University Press, 2012

206
MODERN FORTRAN
And in the following subroutine Mesh generate, none of the components of
temp mesh are deallocated when variable temp mesh goes out of scope on
subroutine exit because no deallocation process is initiated.
subroutine
Mesh generate
( t h i s )
type
( mesh t ) ,
intent
( in
out )
: :
t h i s
type
( mesh t )
: :
temp mesh
! . . .
code
that
a l l o c a t e s
a l l
components
of
v a r i a b l e
! . . .
temp mesh and
c o p i e s
i t
on
e x i t
to
argument
t h i s
i f
!
. . .
t h e r e
are
no
e r r o r s .
end subroutine
Mesh generate
To ensure that the ﬁle is always closed and that the components are deallocated,
you need to write a ﬁnalizer as shown here:
type ,
public
: :
mesh t
integer
: :
unit number = INVALID UNIT
character ( : ) ,
a l l o c a t a b l e
: :
f i l e n a m e
integer ,
dimension ( : , : ) ,
pointer
: :
pts ,
connects
l o g i c a l
: :
i n i t = . f a l s e .
contains
private
procedure
: :
Mesh t assign
generic ,
public
: :
assignment (=) => Mesh t assign
f i n a l ,
public
: :
F i n a l i z e => Final mesh
end type
mesh t
contains
. . .
!
f i n a l i z e r
subroutine
Final mesh
( t h i s )
type
( mesh t ) ,
intent ( in
out )
: :
t h i s
integer ,
parameter
: :
IO MESSAGE LEN = 80
l o g i c a l
: :
f i l e o p e n e d
integer
: :
i o s t a t ,
d e a l l o c s t a t
character (IO MESSAGE LEN)
: :
io message
i f
( associated
( t h i s%pts )
) &
deallocate
( t h i s%pts ,
stat=d e a l l o c s t a t )
i f
( associated
( t h i s%connects )
) &
deallocate
( t h i s%connects ,
stat=d e a l l o c s t a t )
i n q u i r e
( unit=t h i s%unit number ,
opened=f i l e o p e n e d ,&
i o s t a t=i o s t a t ,
iomsg=io message )
i f
( f i l e o p e n e d )
close
( t h i s%unit number , &
i o s t a t=i o s t a t ,
iomsg=io message )
end subroutine
Final mesh
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
207
148. Be aware of the situations where ﬁnalization occurs.
Just as objects can be created in ways that may not be obvious, the ﬁnalizer
can be invoked in less than obvious ways. The standard lists seven situations
where ﬁnalization occurs and two additional situations where its occurrence is
processor-dependent (see Reference [39]).
To avoid unexpected behavior, three of the more unusual situations where
ﬁnalization occurs are important for the programmer to be aware of:
■If the target of a pointer has a ﬁnalizer, the target is ﬁnalized when the
pointer is deallocated.
type
( mesh t ) ,
target
: :
obj mesh t
type
( mesh t ) ,
pointer
: :
mesh ptr
. . .
mesh ptr => obj mesh t
. . .
deallocate
( mesh ptr ,
stat=a l l o c s t a t )
■If an object of a derived type has a ﬁnalizer and if it is the actual argu-
ment corresponding to a dummy argument of a subprocedure that has the
intent (out) attribute, the object is ﬁnalized on entry into the subproce-
dure.
Here, the intent of argument this in subroutine mesh generate in Rule 147
is changed to intent (out). The call to mesh generate will cause a reference
to the ﬁnalizer of object mesh 1, closing ﬁle mesh 1%unit number if it is
open:
subroutine
Mesh generate
( t h i s )
type
( mesh t ) ,
intent
( out )
: :
t h i s
end subroutine
Mesh generate
. . .
type
( mest t )
: :
mesh 1
. . .
c a l l
mesh generate
( mesh 1 )
■Another situation is an intrinsic assignment. In the following code snippet,
variable obj mesh t is of type mesh t. The dummy argument will be ﬁnalized
before the assignment:
subroutine
Mesh generate
( t h i s )
type
( mesh t ) ,
intent
( in
out )
: :
t h i s
. . .
type
( mesh t )
: :
obj mesh t
. . .
t h i s = obj mesh t
end subroutine
Mesh generate
Cambridge Books Online © Cambridge University Press, 2012

208
MODERN FORTRAN
It is important to note that ﬁnalization of active objects does not occur when
the end of a program is encountered by either executing a stop statement,
or the end of the main program unit is encountered. So if an object requires
it, the ﬁnal procedure should be called explicitly.
11.4 Inheritance
149. Use type inclusion for Has-A relationships and type extension for Is-A
relationships.
When building objects from other objects, there are two basic techniques:
type inclusion and type extension. The ﬁrst, type inclusion, has been available
in Fortran since Fortran 90 and is a feature of its “object-based” program-
ming model. The second, type extension, is a more powerful feature that was
introduced in Fortran 2003.
Type Inclusion Type inclusion occurs when objects are nested within derived
types. Type inclusion represents a “has a” relationship from the point of view of
the containing object. The included objects are the components of the derived
types. The two types deﬁned in the next code, photograph t and organism t,
demonstrate this:
module Photograph mod
i m p l i c i t
none
private
type ,
public
: :
photograph t
private
character ( : ) ,
a l l o c a t a b l e
: :
m e s h f i l e
contains
procedure ,
private
: :
P h o t o g r a p h t p r i n t
generic
: :
Print => P h o t o g r a p h t p r i n t
end type
photograph t
contains
subroutine
P h o t o g r a p h t p r i n t
( t h i s )
c l a s s
( photograph t ) ,
intent
( in )
: :
t h i s
p r i n t
* , ”Photo
i n
f i l e : ” //
trim
( t h i s%m e s h f i l e )
end subroutine
P h o t o g r a p h t p r i n t
end module Photograph mod
module Organism mod
use Photograph mod ,
only
:
photograph t
i m p l i c i t
none
private
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
209
type ,
public
: :
organism t
private
r e a l
: :
a v e r a g e l i f e = 0.0
r e a l
: :
average mass = 0.0
character ( : ) ,
a l l o c a t a b l e
: :
latin name
!
has a photograph
of
the
o b j e c t
type ( photograph t ) ,
pointer
: :
image => n u l l
()
contains
procedure
: :
O r g a n i s m t p r i n t
generic
: :
Print => O r g a n i s m t p r i n t
end type
organism t
contains
subroutine
O r g a n i s m t p r i n t
( t h i s )
c l a s s ( organism t ) ,
intent ( in )
: :
t h i s
p r i n t
* ,
’ organism : ’ ,
trim
( t h i s%latin name )
p r i n t
* ,
’ avg
l i f e : ’ ,
t h i s%a v e r a g e l i f e
p r i n t
* ,
’ avg mass : ’ ,
t h i s%average mass
i f
( associated
( t h i s%image ))
c a l l
t h i s%image%Print
end subroutine
O r g a n i s m t p r i n t
. . .
end module Organism mod
Type Extension Type extension represents an “is a” relationship. In Fortran
2003 this is done using the extends attribute. This relationship is used when an
existing object needs to be extended to be a more specialized type. The extended
object still has all the properties of the original base object, including reuse of
the base object’s data components, procedure components, and type-bound
procedures. The new object can add additional components and type-bound
procedures that may not be relevant to the parent object.
Type extension is a very powerful technique because it allows reuse of all of the
parent’s type-bound procedures. This can dramatically reduce the amount of
replicated code when deﬁning multiple, specialized, yet related types. The par-
ent type contains components and type-bound procedures that are common
to the various specialized types. The specialized types are then free to imple-
ment new components and procedures as needed. Here is an extended derived
type, based on the original derived type organism t. It contains specialized
information on animals:
type ,
extends ( organism t )
: :
a n i m a l t
integer
: :
n o o f e y e s
= 2
integer
: :
n o o f l e g s
= 4
l o g i c a l
: :
warm blooded = . true .
end type
a n i m a l t
Cambridge Books Online © Cambridge University Press, 2012

210
MODERN FORTRAN
An application that uses an extended type refers to the components in the
original type as if no extension had taken place. That is, if we have an array
called animal array of type animal t , with parent organism t, there are two
syntactically correct ways we can refer to the average mass of one of its elements:
a n i m a l a r r a y ( j i n d )%average mass
. . .
a n i m a l a r r a y ( j i n d )%organism t%average mass
150. Provide an abstract base object type for the application.
An application-wide base object type for an application is one that is a parent
to all other types, that is, one that all other objects are extended from. In some
object-oriented languages all objects automatically have a predeﬁned base
object. For example, in Java there is a base type called Object. To accomplish
this in Fortran, you must deﬁne your own base type and then extend all your
types from it. Such a base object type can be very simple and contain only
a minimal number of highly used components and type-bound procedures.
It may even be empty. For this purpose, the abstract derived type containing
deferred type-bound procedures is useful. Abstract types are just that. You
cannot declare a data object to be of an abstract type, although a polymorphic
variable may be one (see Rule 152). You can use it solely as the parent of other
types. The keyword abstract in the interface, combined with the keyword
deferred, means that the interface is a template and that speciﬁc procedures
whose interface exactly match the deferred ones must be written for speciﬁc
data types that are immediate descendants of the abstract type. Here is a
module for a sample base object:
module Base object mod
!
Purpose : A module
d e f i n i n g
an
a b s t r a c t
type
that
every
!
d e r i v e d
type
i s
extended
from .
i m p l i c i t
none
private
type ,
abstract ,
public
: :
b a s e o b j e c t t
contains
procedure
( P r i n t t y p e ) ,
deferred
: :
Print
end type
b a s e o b j e c t t
abstract
i n t e r f a c e
subroutine
P r i n t t y p e
( t h i s )
!
Purpose :
I n t e r f a c e
f o r
type−bound
procedure
to
p r i n t
!
type
components .
A l l
immediate
descendants
must
!
p o s s e s s
t h i s
procedure
with
the
i d e n t i c a l
i n t e r f a c e .
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
211
i m p l i c i t
none
import
: :
b a s e o b j e c t t
c l a s s
( b a s e o b j e c t t ) ,
intent
( in )
: :
t h i s
end subroutine
P r i n t t y p e
end
i n t e r f a c e
end module Base object mod
151. Provide a concrete base object type for the application.
This guideline continues Rule 150. The starting point is abstract derived type
base object t . Type base object t is a simple type; it comprises no data or
procedure pointer components and a solitary deferred type-bound procedure,
Print. If this is adequate for an application, it is most likely sufﬁcient as the
base object, from which all other types are extended. If the abstract type is
even slightly more populated by components and deferred procedures, then it
can be advantageous to immediately extend this object to a nonabstract, that
is, a concrete, one, and from it extend all the other types. The following code
and explanation show the reasons why this is the case.
Say just two components are added to the type along with a set of accompa-
nying deferred type-bound procedures.
type ,
abstract ,
public
: :
b a s e o b j e c t t
character
( : ) ,
a l l o c a t a b l e
: :
name
integer
: :
e r r f l g
contains
procedure
( P r i n t t y p e ) ,
deferred
: :
Print
procedure
( C l e a r e r r f l g ) ,
deferred
: :
C l e a r e r r o r
procedure
( G e t e r r f l g ) ,
deferred
: :
G e t e r r o r
procedure
( Get name ) ,
deferred
: :
Get object name
procedure
( S e t e r r f l g ) ,
deferred
: :
S e t e r r o r
procedure
( Set name ) ,
deferred
: :
Set object name
end type
b a s e o b j e c t t
Here is the abstract interface for the procedure interface Get err ﬂg . The
others perform similar tasks. They are accessor procedures that either set or
retrieve the appropriate component.
abstract
i n t e r f a c e
function
G e t e r r f l g
( t h i s )
r e s u l t
( r e t u r n e r r f l g )
import
: :
b a s e o b j e c t t
c l a s s
( b a s e o b j e c t t ) ,
intent
( in
out )
: :
t h i s
integer
( kind
( t h i s%e r r f l g ))
: :
r e t u r n e r r f l g
end
function
G e t e r r f l g
end
i n t e r f a c e
Every derived type extended directly from abstract type base object t must
supply speciﬁc type-bound procedures corresponding to every one in the
abstract type. If the application has many derived types extended directly from
Cambridge Books Online © Cambridge University Press, 2012

212
MODERN FORTRAN
base object t , you will have to replicate the code repeatedly. To avoid this,
you should ﬁrst extend the abstract base object to one that is not abstract:
module
Concrete base object mod
. . .
type ,
public ,
extends
( b a s e o b j e c t t )
: : &
c o n c r e t e b a s e o b j e c t t
contains
!
n o n o v e r r i d a b l e :
always
execute
t h i s
module ’ s
!
procedure .
procedure ,
n o n o v e r r i d a b l e
: : &
C l e a r e r r o r => C l e a r f l g
procedure ,
n o n o v e r r i d a b l e
: : &
G e t e r r o r => G e t f l a g
procedure ,
n o n o v e r r i d a b l e
: : &
Get object name => Get obj name
!
o v e r r i d a b l e :
each
c h i l d
o b j e c t may p r o v i d e
i t s
! own procedure .
procedure
: :
Print => P r i n t f l a g
procedure ,
n o n o v e r r i d a b l e
: :
S e t e r r o r => S e t f l a g
procedure ,
n o n o v e r r i d a b l e
: :
Set object name &
=> Set obj name
end type
c o n c r e t e b a s e o b j e c t t
. . .
contains
. . .
function
G e t f l a g
( t h i s )
r e s u l t
( r e t u r n e r r f l g )
c l a s s
( c o n c r e t e b a s e o b j e c t t ) ,
intent
( in
out )
: : &
t h i s
integer
: :
r e t u r n e r r f l g
r e t u r n e r r f l g = t h i s%e r r
f l g
end
function
G e t f l a g
. . .
end module
Concrete base object mod
where, as an example, one of the ﬁve needed speciﬁc procedures is shown.
Using concrete base object t as the launching point for all further derived-
type extensions, there is no need to write the code for the ﬁve nonoverridable
procedures.
11.5 Polymorphism
In discussing the term “polymorphism” in object-oriented programming,
Reference [8] lists four different programming capabilities and techniques that
programmers refer to. One of those, ad hoc overloading, the ability to assign a
single name to many functions, has already been discussed in the section on
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
213
generic coding techniques (see Rule 126). Another, templates, is a capability
not available in Fortran except in the sense of parameterized derived types.
These types are also explained in the section on generic coding techniques (see
Rule 125).
In this section we turn our attention to the two other capabilities of poly-
morphism: the ability to have a single variable assigned dynamically to be one
of various types, which may be user-deﬁned derived types or intrinsic types,
and the ability to call, within the context of inheritance, different procedures
(methods) based on the type of the variable used in the procedure invocation.
Several guidelines in the subsections following this one refer to the two
modules, Pt2d mod and Pt3d mod, and a program, Type bound demo, whose
source can be found in Appendix A.1. The main program is divided into two
major sections: the ﬁrst comprises two sets of tests and demonstrates inheri-
tance; the second comprises four test sets and demonstrates polymorphism.
152. Do not confuse the meaning of a derived data type, keyword type,
with the meaning of a polymorphic variable, keyword class.
Many object-oriented languages refer to inheritable objects as classes. This is
the keyword used in C++, Java, Python, C#, and the object Pascal language used
in Borland’s DelphiTM product. Fortran uses the keyword type. In Fortran,
an entity declared using the keyword class is polymorphic, one that can be a
derived data type or any of its descendants. A class entity must be a dummy
argument, an allocatable variable, or a pointer.
c l a s s
( b a s e t ) ,
intent ( in )
: :
t h i s
c l a s s
( b a s e t ) ,
a l l o c a t a b l e
: :
c l a s s v a r
c l a s s
( b a s e t ) ,
pointer
: :
c l a s s p t r ( : )
153. Use sourced allocation to allocate polymorphic variables.
In Rule 79 sourced allocation was discussed under the category of the advan-
tages of using allocatable variables, and it was mentioned that this type of
allocation could be used equally well with pointers as it could with allocatable
variables. However, sourced allocation is critical for polymorphic variables
because such variables cannot appear on the left side of an intrinsic assignment
statement.
Given the next declaration of array temp pts of extensible type pt2d t, the
assignment statement that follows it is not correct; the sourced allocation, as
shown, must be used.
c l a s s
( pt2d t ) ,
a l l o c a t a b l e
: :
temp pts ( : )
! INCORRECT CODE.
temp pts = p a s s e d p t s
!
Correct
sourced
a l l o c a t i o n .
a l l o c a t e
( temp pts ,
source=passed pts ,
stat=a l l o c s t a t )
Cambridge Books Online © Cambridge University Press, 2012

214
MODERN FORTRAN
Fortran 2008 has removed this restriction; the following code from the previous
code is correct:
temp pts = p a s s e d p t s
Program Type bound demo has several examples of sourced allocation (*Cmnt-
6, *Cmnt-7) (see also *Cmnt-3 in program Unlimited demo in Appendix A.2).
The ﬁnal two sets of output, for example, show the sourced allocation of a
polymorphic allocatable variable. The output from this set is the following:
Callee: Module pt2d_mod: Print_pt: x: 1.00
y: 2.00
Callee: Module pt3d_mod: Print_pt
Callee: Module pt2d_mod: Print_pt: x: 11.0
y: 12.0
Callee: Module pt3d_mod: Print_pt: z: 13.0
154. Exploit inheritance and polymorphic dummy arguments to write
generic code.
The passed-object dummy argument of type-bound procedures of derived
types must be declared as polymorphic using the keyword class , and its
declared type must be the type to which it is bound. This allows polymorphic
calls to the routine. That is, when a derived type is extended, users of the
extended derived type can use the procedures deﬁned in the parent type. In
this manner the procedure becomes a generic one (see Chapter 10 and Rule
142).
As an example, in module Pt3d mod, there is no type-bound procedure cor-
responding to Get xy coordinate pair in module Pt2d mod. In the main pro-
gram there is a call to this function, whose generic binding is Get, passing a
variable of type Pt3d t (see *Cmnt-8).
p o i n t p a i r = pt 3d%Get
()
The program output for this particular test, which shows that
Get xy coord pair in module Pt2d mod is called, is:
Callee: Module pt2d_mod: Get_xy_coord_pair
Result: point_pair (pt_2d) x/y:
11.00000
12.00000
155. Use the select
type construct to dynamically dispatch polymorphic
data objects to the appropriate type-bound procedure.
When you do need to override a type-bound procedure, you will often be
required to use the Fortran 2003 select type construct to correctly dispatch
the call. The type-bound binding Get coord in both module Pt2d mod and
Pt3d mod demonstrates this. Their task is to return the value of the x, y,
or z component as indicated by the value of component coord in the second
dummy argument, mold.
Cambridge Books Online © Cambridge University Press, 2012

OBJECT ORIENTATION
215
In module Pt3d mod, the code for Get coord contains a select type construct
(*Cmnt-2). This construct branches to the appropriate code based on either
the type or the class of a data object (see Rule 156). Part I of the main program
contains several invocations to this routine. The relevant program output is
next:
Callee: Module pt2d_mod: Get_coord
Result: coordinate_value
2.000000
Callee: Module pt2d_mod: Get_coord
Result: coordinate_value
0.000000
Callee: Module pt3d_mod: Get_coord
Callee: Module pt2d_mod: Get_coord
Result: coordinate_value
12.00000
Callee: Module pt3d_mod: Get_coord
Result: coordinate_value
13.00000
Callee: Module pt2d_mod: Get_coord
Result: coordinate_value
12.00000
156. Use unlimited polymorphic variables to create data structures con-
taining heterogeneous data types.
In addition to polymorphic variables of a declared type, it is possible to declare
entities to be unlimited polymorphic using the notation class (*) (see *Cmnt-
2 in module Base node mod in program Unlimited demo in Appendix A.2).
Such variables can be dynamically associated with any intrinsic or user-deﬁned
derived type.
Many applications deﬁne what are called “container procedures,” those that
aggregate objects into data structures such as stacks and linked lists. It is
often useful to write the container procedures to operate on an application-
wide base type. The ability to associate with every type makes unlimited
polynomial variables ideal for creating container data structures that hold sets
of heterogeneous data. Because all of the derived types within the application
can be extensions of the base type, only one set of container routines needs to
be written to handle all objects. Appendix A.2 contains a complete program
demonstrating such a structure.
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

12.
Parallel Processing
In the world of scientiﬁc and engineering computing, applications must often
take advantage of all the processing power the system is capable of providing.
With the advent of low-cost computers with multiple processing cores, writing
programs that employ parallel processing has become common.
Modern computers operate in the digital domain, yet users wish to simulate or
control physical processes, which are usually continuous, or analog, in nature.
The conversion between the two domains is necessarily imprecise. The closer
the digital process can model the real-world one, the better the result.
A numerical model must be ﬁne-grained enough to accurately model the
process, yet it must not be too ﬁne, or resource requirements such as CPU
utilization and main memory space will be exceeded. A practical choice must
often be made between precision of results and the ability to produce results
in a reasonable time frame, if at all.
When faced with the requirement to speed up a computation, it is natural to
consider parallel processing as a solution. At its inception, Fortran was designed
in terms of a scalar processor model. That is, only a single thread of control is
present, and code is executed in a serial fashion. However, as computers have
evolved, many features have been added to the language that can be executed
in parallel. These parallel capabilities are built in. Their use depends on the
hardware available and the compiler. To the programmer, their use is part of
the language, regardless of the hardware and software environment. Moreover,
Fortran has often been used as a base for parallel computations using either
language extensions, or library-based approaches.
Three sections compose this chapter: The ﬁrst concentrates on the charac-
teristics of the target application and those of the hardware and software
environment that should be considered before converting a program to run
in parallel. The second moves on to the program and discusses in its three
subsections, “Data Parallelism,” the built-in features of the language that
can be executed in parallel, and two of the widely used technologies used
with Fortran to create applications that execute in parallel: the OpenMP
application programming interface (API) and the message-passing interface
(MPI) library. The ﬁnal section presents two new features of Fortran 2008
designed speciﬁcally for parallel processing: the do concurrent construct and
coarrays.
216
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
217
12.1 Preliminary Considerations
157. Tune programs to run correctly and as quickly and efﬁciently as
possible as a single thread program running on a single processor before
rewriting them for parallel processing.
Two essential steps should be accomplished before turning your attention to
ways to parallelize an application: The ﬁrst is to thoroughly verify that the
program is running correctly and producing the correct results when it is not
optimized. The second is to tune it to run as fast as possible as a single-thread
program running on a single processor. In doing so, you establish a benchmark,
a reference point, from which to measure the improvement later achieved by
converting code to run in parallel. And, because one of the preliminary steps
in tuning is to pinpoint the most time-consuming code, tuning aids in deter-
mining where to focus your attention when converting. Tuning encompasses,
among other tasks, algorithm design and code optimization using the com-
piler (see References [22], [53], and [61]). Frequently, tuning also includes
choosing the most suitable publicly available libraries for computation.
A common tool used to analyze code performance is a proﬁler. This is a
program that provides an indication of the time an application in spending in
each section of code. Many compiler vendors provide some form of proﬁler;
on Unix and Linux, the common proﬁlers are the programs prof and gprof
(see Reference [76]). Commercial compiler vendors often provide proﬁlers
that extend the capabilities of gprof, and they also offer additional tools for
optimizing code. Here is an example shell script:
$
g f o r t r a n −pg my−program . f90
$ a . out
$
gprof
158. Estimate the performance improvement that can be realized using
parallel programming methods.
One of the ﬁrst questions to ask is “how much performance improvement can
I expect from parallel processing”? (Estimating the expected improvement may
lead to the conclusion that it is not worth the effort, and that the improvements
in speed that can be obtained using the built-in Fortran data parallel capabilities
and the compiler optimizations will sufﬁce.) To model the expected speedup
of an application, Dr. Gene Amdahl published his famous equation known as
Amdahl’s Law (see Reference [6]):
speedup = 1/((1 −P ) + P /Np)
where:
P = Fraction of computations that can run in parallel
Np = Number of parallel processing units
The (1 −P ) term represents the scalar portion of a computation, and the
P/Np term is the parallel portion.
Cambridge Books Online © Cambridge University Press, 2012

218
MODERN FORTRAN
If, for example, 50 percent (P = 0.5) of the calculations are parallelizable, the
maximum possible speedup with an inﬁnite number of processors is twice
the serial speed. On a machine with, say, sixteen processors (Np = 16), the
expected speedup would be:
= 1/((1 −0.5) + 0.5/16)
= 1/(0.5 + 0.031)
= 1.89
Likewise, if 95 percent of the time spent in computations can be done in
parallel, the maximum is twenty times the serial speed. The estimated speedup
with sixteen processors becomes:
= 1/((1 −0.95) + 0.95/16)
= 1/(0.05 + 0.059)
= 9.14
Clearly, as the number of processors increases, the scalar term becomes dom-
inant. This indicates that a large percentage of the computations must be
parallizable in order to effectively utilize large numbers of processors.
Amdahl’s Law, as originally devised, ignores an important problem in parallel
processing, communications overhead. Communications overhead comprises
two major components: synchronization overhead, the overhead needed to
keep the processors working in unison with one another; and data motion, or
data communications, overhead, the overhead caused when one parallel task
needs access to data associated with a different task.
Depending on the parallel processing model and the actual hardware in use,
communications overhead can cause degradations to the expected speedups
calculated from Amdahl’s Law. When evaluating a computation, it is important
to know how the communications scale with the size of the problem and with
the number of parallel tasks. For example, with so-called “embarrassingly
parallel” problems, communications might be limited to distributing a small
amount of initial input data and, as a result, the communications overhead
may scale along with the number of processors. In this case, communications
may not be an issue.
An alternative example might be a case where data objects are distributed
across processing threads, as with a weather model that divides the processes
along boundaries of latitude and longitude. Boundary information between
neighbors must be communicated. So, as the size of the problem increases,
relatively more communication will be needed.
Finally, in some cases, parallel computations have been known to exhibit
“super-linear” speedup. These are cases where a computation involving a dis-
tributed object runs faster than expected on a larger number of processors
than the increase in processor count alone would explain. Typically, the reason
is that as the number of processors increases, and the problem size is held
constant, the individual portions of the distributed objects begin to ﬁt better
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
219
within the various levels of memory caching hierarchy (see Rule 97 and Ref-
erence [51]).
159. Determine the hardware conﬁguration on which the application will
run.
A common classiﬁcation of parallel architectures (see Reference [51]) divides
them into four categories, three of which apply to our discussion:
Single Instruction, Single Data (SISD) This is what is referred to as the
classic von Neumann model of a program with a single stream of instructions
processing a single stream of data.
Single Instruction, Multiple Data (SIMD) In SIMD computing, a single
program is run, with parallel instructions “fanned out” to the various parallel
computing elements. This architecture carries out a single instruction on
multiple pieces of data. It is usually the compiler that parallelizes the code.
Many of the Fortran data parallel capabilities are SIMD (see Section 12.2.1).
Multiple Instruction, Multiple Data (MIMD) In MIMD computing, there
may be either multiple threads of control executing within a single program,
or multiple programs executing concurrently. Most modern parallel architec-
tures fall into this category. Each processing unit processes its own stream of
instructions on its own data.
Before continuing, we introduce two terms used in parallel computing: The
ﬁrst is a Processing Environment (PE). This is a hardware term for a combina-
tion of a processor, its memory, communications interface, and possibly I/O
devices. The second term is the thread, which is a software term used when
there are multiple processors running within a single program image, but not
necessarily in lockstep with each other as in SIMD code.
The ﬁnal category, MIMD, can be further divided into shared memory and
distributed memory architectures. There are also hybrid systems that combine
the two.
Shared memory machines support multiple processors sharing a single memory
system. Each processor, taken individually, has equal and high-speed access to
data in the memory. This style of programming is easy to comprehend since
normal Fortran constructs are used to lay out data and access it. However, with
multiple processors running at the same time, the memory system must be
designed to be robust enough to handle the aggregate of all processors requests,
or degradation will occur. Per processor cache memory can help mitigate the
performance issues, but at some point serious degradation can occur, limiting
the scalability of the program.
Distributed memory machines are built in a modular fashion. The basic
component is a node. Each node contains a local memory system, and one or
a small number of processors. Each processor in the node is a PE. These nodes
Cambridge Books Online © Cambridge University Press, 2012

220
MODERN FORTRAN
are then interconnected with a special communications fabric or network.
The communications fabric has a topology, or order to it that allows parallel
communications between nodes. Topologies can vary from simple, such as
rings, with two connections on each node for the left and right neighbors, to
grids, with four connections (up, down, left, and right), to cubes and beyond.
Hybrid systems are distributed memory machines where each node has several
processing units, either multiple processors, multicore processors, or both.
When evaluating various parallel processing architectures, communications
costs can be extremely important. It is always beneﬁcial to select techniques
and machines with the lowest overhead possible in order to provide maxi-
mum scalability. However, when scaling from moderate to very high processor
counts, it is difﬁcult and costly to provide a shared memory solution.
12.2 Parallel Program Patterns
Three common patterns used in Fortran to structure source code for parallel
computation are loop parallelism, fork/join, and multiple instruction, multiple
data (MIMD) (see Reference [51]). The ﬁrst concentrates on converting the
iterations of time-consuming loops that execute one after another in serial
fashion into iterations that execute in parallel. With the fork/join pattern, a
unit of execution spawns a set of units of execution (UE) that execute in parallel
and then rejoin and continue as a single UE. When structured for MIMD,
each parallel UE processes a set of instructions, each with its own set of data.
Data Parallelism Many computer vendors introduced array syntax extensions
into their Fortran compilers for use with various parallel processing schemes,
in a style known as data parallel computing (see Reference 71). Array syntax
often allows the replacement of a small loop with a single assignment statement.
Array syntax was successful enough that it was incorporated into Fortran 90,
and has been extended since then. Array syntax is generally used in a shared
memory environment, and is especially useful with SIMD computers, though
SIMD instructions are not required. With extensions for data placement, it
can also be used in a distributed memory environment.
In the mid-1990s, the High Performance Fortran (HPF) speciﬁcation was
developed. HPF extended the data parallel concept by adding directives for
data placement, additional parallel constructs over Fortran 90, and a useful
set of intrinsic procedures. However, some aspects of HPF were more difﬁcult
to implement than anticipated, so HPF was not widely adopted. Nonetheless,
some HPF concepts were incorporated into Fortran 95. And others are useful
to keep in mind while writing code in a data parallel style (see Reference [48]).
Fork/Join Many compilers have supported “directive-based” syntax to specify
areas of code that could be parallelized, in particular, do loops. The problem
for application developers was that different compilers used different directives
to represent similar concepts. In response, in the mid-1990s, a consortium of
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
221
compiler vendors decided to publish a common speciﬁcation. This became
known as OpenMP. It is a fork/join method for parallel computation.
OpenMP has been widely implemented on shared memory machines. But
since it allows shared data access between threads, implementation in dis-
tributed memory environments is a challenge (see References [62], [11], and
[13]).
MIMD Message passing is a style of computing where multiple programs are
executing in a team to solve a problem. When they need to pass data between
themselves, they use explicit calls to special message passing subroutines. It
represents a form of MIMD parallel computing.
Because all communication between the programs is accomplished using
explicit calls, each program has access to only its own private, low-level memory.
This allows the programs to be run in either a shared memory environment,
where the blocks of data may be moved between programs via simple shared
memory copies, and also in a distributed memory environment where the
blocks of data are moved by special communications hardware.
The most common message passing library in current use is the aptly named
Message Passing Interface MPI. MPI is an extensive library with over 100
calls for passing data, performing certain low-level computations that require
message passing, synchronization, and even parallel I/O (see References [58],
[50], and [26]).
In the three following subsections, we expand our discussion of these patterns.
12.2.1 Data Parallel Programming
160. Use built-in Fortran data parallelism to replace simple loops that
can execute in parallel.
Many processors, from some of the earliest parallel machines of the 1960s, to
the latest microprocessors, offer SIMD capability, the ability to execute a single
instruction on multiple array elements simultaneously. With this capability,
the serial nature of Fortran execution is maintained, yet each instruction causes
multiple data items to be processed. This scheme of parallel processing is often
known as “data parallel” computing (see Reference [72]).
In a data parallel environment, it is often useful to think of each element
of a data array being associated with its own processing element and private
memory. In this model, data communication occurs when data associated with
one processor is needed for a computation on a different processor. Because
the array elements are placed for optimal access for the “owning” processor, it
may be likely that this is at the price of suboptimal access by other processors.
For example, while processing the matmul intrinsic, each processor may need
to read data in the row and column it is associated with. If we imagine the
processors as being placed in a two-dimensional grid, each processor will need
to ask its neighbors to the right and left, and those above and below, for data.
Cambridge Books Online © Cambridge University Press, 2012

222
MODERN FORTRAN
The following sections describe the tools that are part of the language that will
execute in parallel if the appropriate hardware and compiler is used. In each,
we bring forth any issues involving communications.
Broadcasting A broadcast operation is a one-to-many operation where a
single scalar value is assigned to an entire array or an array section. The scalar
value is fanned out to each processor, and then each processor initializes its
portion of the data array. Although broadcasting is a form of communication,
broadcasts of a scalar such as this will generally be very fast. A trivial example
is:
real ,
dimension
(MAX ELEMS)
: :
b
b = 0.0
Parallel Assignments Fortran offers array expressions that allow program-
mers to directly state parallel computations in data parallel fashion. In the fol-
lowing code, three arrays all having the same shape, a, b, and d, are deﬁned.
Array syntax is used to indicate that a parallel operation be used in the addition
and assignment:
real ,
dimension (128 ,
128 ,
128)
: :
a ,
b ,
d
. . .
a = b + d
These operations are known as “elemental operations.” Each array element is
operated on with other associated array elements in the equation on a one-
for-one basis with no interplay with its neighbors. Importantly, there is also
no order implied as to which elements are processed in which order.
The use of array syntax often leads to the use of arrays of temporary data,
compared to do loop code, which might use scalar temporary variables instead.
Compilers can often merge multiple statements together and eliminate the use
of a temporary array, even though the programmer was forced to include it in
the code. However, the statements usually need to be grouped together so that
it is easy for a compiler to analyze the usages.
An alternative may be to use the Fortran 2008 do concurrent loop capability.
The temporary variable may be written as a scalar. The compiler then has less
to analyze to produce optimal code (see Rule 168).
In addition to entire arrays, array sections could be processed using array section
notation. Say, for three arrays a, b, and d, a 20 × 20 × 20 array section is to
be processed. The following maintains the relationships between the elements
of the arrays to one another. No communication takes place:
a ( : 2 0 , : 2 0 , : 2 0 ) = b ( : 2 0 , : 2 0 , : 2 0 ) + d ( : 2 0 , : 2 0 , : 2 0 )
Communication issues come up, however, when the data elements are moved
from their original position:
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
223
a (11:30 ,
11:30 ,
11:30) = b ( : 2 0 , : 2 0 , : 2 0 ) &
+ d ( 6 : 2 5 , 6 : 2 5 , : 2 0 )
Arrays a, b, and d may all be aligned such that the ﬁrst elements of each are
associated with the same processor. As the relationship changes between the
different variables within the array expression, at some point the data may not
be optimally placed for fastest access by the processor that needs to access it.
The forall Statement and Construct The forall statement and construct
are used to write array-based code, which is difﬁcult to state in normal array
syntax. This statement and construct speciﬁes, on an element-by-element basis,
which elements are to be processed in parallel in an assignment statement, or
group of assignments that are written in scalar form.
An example of forall is the processing of a sparse matrix. This example assumes
that each of the elements in the indices array is unique and that the expression
may be evaluated in any order.
f o r a l l
( i =1: s i z e
( i n d i c e s ))
a ( i n d i c e s ( i )) = a ( i n d i c e s ( i )) + b ( i )
end
f o r a l l
Code similar to this is often used for building histograms. With a histogram,
the indices array would likely have many repeated values, and this would make
parallel processing difﬁcult. For this case, a scalar do loop should be used. This
is a case where the programmer must know his data usage to ascertain which
way the assignment statement should be written. Here is a case where forall
is used to unpack a character string into individual characters:
character ( len =:) ,
a l l o c a t a b l e
: :
s t r i n g
character ( len =1) ,
a l l o c a t a b l e
: :
c h a r a r r a y ( : )
. . .
a l l o c a t e
( c h a r a r r a y ( len
( s t r i n g ) ) ,
stat = a l l o c s t a t )
f o r a l l
( i =1: s i z e
( i n d i c e s ))
&
c h a r a r r a y ( i ) = s t r i n g ( i : i )
Unfortunately, the forall construct has proved in practice to be difﬁcult for
compilers to optimize. Therefore, if proﬁling shows that a speciﬁc forall
statement is a “hot spot,” it may be better to use an explicit loop with either an
OpenMP directive or the Fortran 2008 do concurrent construct. (see Sections
12.3 and 12.2.2).
Intrinsic Elemental Functions Besides the usual arithmetic and logical oper-
ators, many of the intrinsic functions are categorized as “elemental functions.”
These functions accept arguments of any rank and shape, and return array
results of the same rank and shape, again on a one-for-one basis with no order
implied. These functions include the usual math intrinsic functions such as
sin, sqrt, and mod.
b = cos
( sqrt
( a ))
Cambridge Books Online © Cambridge University Press, 2012

224
MODERN FORTRAN
Transformational Intrinsic Procedures The transformational intrinsic func-
tions either process their input arrays in a nonelemental fashion, or create a
result where the shape may differ from the input array. We have previously
discussed reasons why column-wise access of array elements is faster than row-
wise access (see Rule 97). The compiler is generally given the responsibility to
arrange the data motion in an optimal fashion.
The cshift and eoshift intrinsic functions shift data through their neighbors
in either a circular, or an “end off” manner. On distributed memory SIMD
memory machines of the past, these intrinsic functions directly mapped into
communications instructions between the nodes in order to place the array
elements into more optimal locations. The following example moves a two-
dimensional array section to the origin of the matrix. It uses eoshift so that
the data motion can be clearly seen:
Listing 12.1: Program Shift demo
program
Shift demo
i m p l i c i t
none
integer
: :
a (4 ,
4) = reshape
(
source = [
&
11 ,
12 ,
13 ,
14 ,
&
21 ,
22 ,
23 ,
24 ,
&
31 ,
32 ,
33 ,
34 ,
&
41 ,
42 ,
43 , 44
&
] ,
shape = shape
( a ) ,
order = [ 2 ,
1 ] )
c a l l
P r i n t m a t r i x
(a ,
’ i n i t i a l
c o n f i g u r a t i o n ’ )
a = e o s h i f t
( array=a ,
s h i f t =2, dim=1)
c a l l
P r i n t m a t r i x
(a ,
’ a f t e r
dimension 1
s h i f t ’ )
a = e o s h i f t
( array = a ,
s h i f t = 2 , dim=2)
c a l l
P r i n t m a t r i x
(a ,
’ a f t e r
dimension 2
s h i f t ’ )
contains
subroutine
P r i n t m a t r i x
( matrix ,
t e x t )
integer ,
intent ( in )
: :
matrix ( : , : )
character (*) ,
intent ( in )
: :
t e x t
integer
: :
i
l o g i c a l
: :
f i r s t t i m e = . true .
i f
( . not .
f i r s t t i m e ) &
p r i n t
*
f i r s t t i m e = . f a l s e .
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
225
p r i n t
* ,
t e x t
do ,
i = 1 ,
s i z e
(a ,
dim=1)
p r i n t
* , a ( i , : )
end do
end subroutine
P r i n t m a t r i x
end program
Shift demo
When run, this program prints:
initial configuration
11 12 13 14
21 22 23 24
31 32 33 34
41 42 43 44
after dimension 1 shift
31 32 33 34
41 42 43 44
0 0 0 0
0 0 0 0
after dimension 2 shift
33 34 0 0
43 44 0 0
0 0 0 0
0 0 0 0
The transpose intrinsic ﬂips a two-dimensional matrix across its diagonal.
Since a transpose must process array elements in both column-wise and row-
wise patterns, it can represent an extreme case to the computer’s memory and
communications system. The term “bisection bandwidth” relates to how well
one-half of a machine can interchange data with the other half. The bisectional
bandwidth is often a key indicator of how well a machine can scale.
The reshape intrinsic function is used to rearrange array elements from one
dimensionality to another. We saw earlier where reshape is used to turn a one-
dimensional array into a two-dimensional array in an initialization expression.
The one-dimensional array was laid out row-wise to look like a textbook
representation of a matrix for ease of reading. The reshape intrinsic function is
used to perform the task of properly creating a two-dimensional matrix from
it (see Rule 93).
The dot product and matmul intrinsic functions are transformations, because
for every point in the input matrices both row-wise and column-wise access
are used.
Cambridge Books Online © Cambridge University Press, 2012

226
MODERN FORTRAN
User-Deﬁned Elemental Functions User-deﬁned elemental procedures also
ﬁt into the data parallel model (see Rule 128). Such procedures are written as
if they accept scalar arguments and return a scalar result. The compiler can
then use the function in array expressions of any rank and shape. For example,
here is a simple elemental function that returns the volume of a cone, followed
by a call to it:
elemental
function
Compute cone volume
( radius ,
h e i g h t ) &
return
( volume )
real ,
intent ( in )
: :
radius ,
h e i g h t
r e a l
: :
volume
volume = 1.0/3.0
* PI *
r a d i u s **2 *
h e i g h t
end
function
Compute cone volume
real ,
dimension (NO OF CONES)
: :
volumes ,
r a d i i ,
h e i g h t s
. . .
volumes = Compute cone volume
( r a d i i ,
h e i g h t s )
Conditional Operations The merge intrinsic function is very useful for
implementing “branch-less” conditional code. The ﬁrst two arguments are the
two expressions with values to choose from. The third argument is a logical
expression that indicates which of the two choices to use. Because merge is
elemental, the selection process is performed on an element-by-element basis.
The input arguments must have identical shapes, and the result will have
the same shape as the inputs. All three arguments in the merge intrinsic are
evaluated prior to the selection process; when carried out in this manner, the
resulting branch-less code can be very highly optimized by most compilers.
a = merge (b ,
d ,
b > PI )
The where statement and construct also provide a way to conditionally pro-
cess array data. The conditional expression is evaluated. The remaining array
expression is evaluated for the elements that are true. In its statement form, a
single assignment is performed. In the construct form, there can be multiple
blocks as shown in the two examples here:
where ( abs
( b ) > 0 . 0 )
d = a / b
where
( 0 . 0 <= b
. and .
b <= PI )
a = b
e l s e
where ( PI < b
. and .
b <= PI TIMES TWO)
a = −(PI TIMES TWO −b )
e l s e
where
a = d
end where
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
227
These conditional operations are often implemented by processing all of the
calculations, whether needed or not, then assigning the desired results and
throwing away the rest. For high levels of parallelism and relatively small
expressions, this style of programming can be very fast.
However, when there are complicated expressions that take some time to
compute, it seems wasteful to calculate results and then discard them. So an
alternative is to compress the desired input data elements into shorter arrays,
run the expressions using this subset of data, and then restore the data back
to its original shape. The pack and unpack intrinsic functions are used for this
task.
r e a l
: :
raw data ( : )
l o g i c a l
: :
non zeros ( s i z e
( raw data ))
real ,
a l l o c a t a b l e
: :
s h o r t d a t a ( : )
integer
: :
a l l o c s t a t
. . .
non zeros = abs
( raw data ) > 0.0
a l l o c a t e
( r e a l
: :
s h o r t d a t a ( count
( non zeros ) ) , &
stat=a l l o c s t a t )
s h o r t d a t a = pack ( array=raw data ,
mask=non zeros )
. . .
raw data = unpack ( vector=short data ,
mask=non zeros , &
f i e l d=raw data )
The elemental approach to conditionals tends to be best when the ratio of
trues to falses is high and the conditional expressions are fairly simple. When
the data becomes sparse, or the conditional expressions are complicated, the
compression technique is usually best.
Reductions A reduction operation is a many-to-one operation. Most com-
monly, these are summations, which are represented by the sum and count
intrinsic functions. Other associative operations, represented by the product,
minval, maxval, all , and any intrinsic functions, also carry out reduction
operations.
real ,
a l l o c a t a b l e
: :
a ( : )
r e a l
: :
t o t a l
l o g i c a l ,
a l l o c a t a b l e
: :
v a l i d c a s e s ( : )
integer
: :
n v a l i d
. . .
t o t a l
= sum ( a )
n v a l i d = count
( v a l i d c a s e s )
Like broadcasting, reduction is a communications operation. However, fast
algorithms exist for performing reduction operations in parallel. One such is
to perform Np partial reductions in parallel and then to combine the partial
reductions in log(Np) steps to obtain a single result.
Cambridge Books Online © Cambridge University Press, 2012

228
MODERN FORTRAN
With ﬂoating-point summations in particular, the parallel result may slightly
differ numerically from the result obtained by equivalent scalar do loop code.
This is due to the differing rounding of the intermediate computations that is
the result of the differing order of computations. Often this difference can be
ignored because, due to the nature of ﬂoating-point arithmetic, it is hard to
say which result is “more correct” without having some knowledge of the data
being reduced, and its ordering within the array.
12.2.2 OpenMP
161. Use the OpenMP API to create sections of code that execute in
parallel.
The OpenMP application programming interface (API) is a set of directives
and procedures that permit the programmer to target sections of code to exe-
cute in parallel. When a parallel section of code is encountered, as deﬁned
by an OpenMP compiler directive, a team of parallel threads are created
during the parallel region. As such, it is an example of the fork/join model; a
single thread forks into a team of parallel threads for a portion of the execution.
Each thread can execute on a different processing element. When completed,
the threads rejoin to again form a single execution thread. Each thread may
access both shared data, which is visible to all of the OpenMP threads, and
private data, which is replicated for each thread. OpenMP’s ability to tar-
get speciﬁc sections of code differs from the message passing model, which
normally requires extensive planning before any code is written or rewritten.
When using free source form, the directives are preﬁxed using the sentinel
“!$omp.” When you compile code containing such directives, the compiler will
normally read these as comment statements because of the leading exclamation
mark. To activate the directives, a compiler ﬂag is set or speciﬁed, and the
compiler will process the directives and generate the program for execution in
parallel. To indicate a parallel region of the code, the parallel directive is used:
!
. . .
s e r i a l
r e g i o n
of
code
! $omp
p a r a l l e l
!
. . .
p a r a l l e l
r e g i o n
of
code
! $omp end
p a r a l l e l
!
. . .
s e r i a l
r e g i o n
of
code
Clauses on the parallel region indicate whether variables within the region
are either shared, that is, there is a single copy of each variable that all of the
threads share, or private, variables that are replicated so that each thread has
its own copy. As a special case, variables used as part of a reduction operation
can also be indicated.
Loops can be processed in parallel within a parallel region using the do “work-
share” directive. The iterations of the loop are then divided among the parallel
threads:
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
229
! $omp
p a r a l l e l
. . .
code
runs Np times −once
per
thread
! $omp do
do ,
i =1, N
. . .
code
runs N times .
end do
! $omp end do
. . .
code
runs Np times −once
per
thread .
! $omp end
p a r a l l e l
Since processing loops in parallel is such a common case, OpenMP allows
combining the parallel directive with the work-sharing do clause for ease of
use:
! $omp
p a r a l l e l
do
do ,
i =1, N
. . .
end do
! $omp end
p a r a l l e l
do
Because data is often shared between the forked threads, OpenMP is most suit-
able for shared memory systems. Communication costs may become impor-
tant. On shared memory systems, data that is normally associated with a given
processor may likely be in that processor’s cache memory. When a different
processor needs to access it, as indicated by the shared clause in the parallel
directive, additional memory operations may be needed to present a coherent
view. An acute case of this is when multiple processors are trying to update
values in the same cache line. To avoid the case where multiple threads are
simultaneously updating the same location in memory,
critical
sections
are used. Only one thread is allowed to be in a critical section at
a time.
What follows is a short example of a loop that is processed in parallel using
OpenMP. It is what is termed a reduction operation. A set of computations is
performed, and the result of each computation is summed to form the ﬁnal
answer.
Reduction variables are a special case of shared data. Use these for associative
operations, primarily summations, where each thread needs to maintain a
private copy of the reduction variable, and at the end of the parallel region,
the individual results are combined to create a single shared result.
The example is taken from the ﬁeld of illumination optics. A grid of rays is
traced through a lens and the energy, or irradiance, is computed at a surface.
The lens data – the number of lens elements, their shape, spacing, optical
glass, and so forth – are contained in a derived type lens t . The data for the
ray – its coordinates and direction cosines – are contained in a second derived
type ray t. Neither of these are shown here.
Cambridge Books Online © Cambridge University Press, 2012

230
MODERN FORTRAN
type
( l e n s t )
: :
l e n s
type
( r a y t ) ,
a l l o c a t a b l e
: :
r a y s ( : ,
: )
r e a l
(WORKING PREC)
: :
i r r a d i a n c e ,
t o t a l i r r a d i a n c e
integer
: :
i row ,
j c o l
!
. . .
code
to
a l l o c a t e
r a y s .
! $omp
p a r a l l e l
do
d e f a u l t
( none ) &
! $omp shared
( r a y s ) &
! $omp
p r i v a t e
( i row ,
j c o l ,
i r r a d i a n c e ) &
! $omp r e d u c t i o n
(+:
t o t a l i r r a d i a n c e )
t o t a l i r r a d i a n c e = 0.0 WORKING PREC
row loop :
do
j c o l = 1 ,
s i z e
( rays ,
dim = 2)
c o l l o o p :
do
i r o w = 1 ,
s i z e
( rays ,
dim = 1)
c a l l
Trace ray
( lens ,
r a y s ( i row ,
j c o l ) , &
i r r a d i a n c e )
t o t a l i r r a d i a n c e = t o t a l i r r a d i a n c e + i r r a d i a n c e
end do
c o l l o o p
end do row loop
! $omp end
p a r a l l e l
do
where the interface to subroutine Trace ray is:
pure
subroutine
Trace ray
( lens ,
ray ,
i r r a d i a n c e )
type
( l e n s t ) ,
intent
( in )
: :
l e n s
type
( r a y t ) ,
intent
( in )
: :
ray
r e a l
(WORKING PREC) ,
intent
( out )
: :
i r r a d i a n c e
end subroutine
Trace ray
The parallel do directive indicates the beginning of a section of code that
can be executed in parallel by a team of threads; the end parallel do directive
terminates it. In the parallel do directive, the clause default (none) indicates
that the user must explicitly state the visibility of variables within the parallel
region. By default, all variables in the section can be shared by the threads,
which is not recommended (see Rule 162). The shared (rays) clause indicates
data that is shared between the threads; that is, there is only one copy of the data.
The clause private (i row , j col , irradiance ) indicates those not shared;
each thread has a private copy. And the reduction (+: total irradiance ) clause
indicates that this is a summation and that the variable total irradiance will
store the sum.
The compiler, when the appropriate OpenMP compilation ﬂag is set, can
generate code to compile this to execute in parallel on multiple processing units.
Note that the subroutine Trace ray is pure, indicating that no side effects will
occur during its execution. This characteristic is essential for creating parallel
programs that execute correctly.
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
231
162. Use default (none) for all parallel regions.
By default, most variables within a parallel region are set as shared. However,
accessing, and especially updating, shared data can limit the scalability of
code. At worst, unintended interactions between threads on a shared variable
could even lead to incorrect results. To ensure that all variables have been
properly divided into shared and private, use the default(none) clause. The
compiler will then require that all variables be explicitly set with the desired
scope.
163. Minimize shared variable locking and usage for best scalability.
Shared data access is fast, but if the different threads need to update the same
locations in memory, some interlocking is necessary to maintain coherency in
the data. The OpenMP critical and end critical directives are often used to
serialize blocks of code. Consider a loop that builds a histogram, written using
a critical section:
histogram = 0.0
! $omp
p a r a l l e l
do
d e f a u l t ( none )
&
! $omp shared ( histogram ,
i n d i c e s )
&
! $omp
p r i v a t e ( i ,
temp )
do ,
i =1,
s i z e
( i n d i c e s )
temp = . . .
! $omp
c r i t i c a l
histogram ( i n d i c e s ( i )) = histogram ( i n d i c e s ( i )) + temp
! $omp end
c r i t i c a l
end do
! $omp end
p a r a l l e l
do
The loop may not scale well, as the threads would spend most of their time
waiting to enter the critical section. It is slightly better to use the OpenMP
atomic directive, which is essentially a miniature critical section just for the
update of the histogram variable for a single line of code:
histogram = 0.0
! $omp
p a r a l l e l
do
d e f a u l t ( none )
&
! $omp shared ( histogram ,
i n d i c e s )
&
! $omp
p r i v a t e ( i ,
temp )
do ,
i =1,
s i z e
( i n d i c e s )
temp = . . .
! $omp atomic
histogram ( i n d i c e s ( i )) = histogram ( i n d i c e s ( i )) + temp
end do
! $omp end
p a r a l l e l
do
However, the best way to solve this problem is to use private arrays to build
private histograms, each containing a partial result. Then merge the ﬁnal
results, using a critical section to maintain coherency:
Cambridge Books Online © Cambridge University Press, 2012

232
MODERN FORTRAN
histogram = 0.0
! $omp
p a r a l l e l
d e f a u l t ( none ) &
! $omp& shared ( histogram ,
i n d i c e s )
&
! $omp& p r i v a t e ( h i s t o p r i v a t e ,
i ,
temp )
!
Build
a
p r i v a t e
histogram
i n
each
thread .
h i s t o p r i v a t e = 0.0
! $omp do
do ,
i =1,
s i z e
( i n d i c e s )
temp = . . .
h i s t o p r i v a t e ( i n d i c e s ( i )) = &
h i s t o p r i v a t e ( i n d i c e s ( i )) + temp
end do
! $omp end do
! Merge
the
p r i v a t e
histograms
i n t o
the
shared
histogram .
! $omp
c r i t i c a l
histogram = histogram + h i s t o p r i v a t e
! $omp end
c r i t i c a l
! $omp end
p a r a l l e l
It is often possible to arrange computations on shared data such that critical
sections or other synchronization directives are not needed at all.
This example is of a parallel do loop that repeatedly calls an FFT library
routine, Cﬀt1d, for each of the columns of the matrix. The FFT routine requires
an initialization call to subroutine Cﬀt1di to set up a coefﬁcient array for the
size of the FFT. The coefﬁcient array must be of size N+FFT FACTOR MAX,
so it is allocatable. Each thread has its own copy of the coefﬁcient array by
making it private. The matrix data is shared, but because each iteration of the
loop is operating on a different column, critical section locking is not required.
subroutine
Compute ffts
( matrix ,
d i r e c t i o n )
use
fft mod ,
only :
Cfft1d ,
C f f t 1 d i
complex ,
intent ( in
out )
: :
matrix ( : , : )
integer ,
intent ( in )
: :
d i r e c t i o n
complex ,
a l l o c a t a b l e
: :
c o e f f a r r a y ( : )
integer
: :
mat size ,
j ,
a l l o c s t a t
mat size = s i z e
( matrix ,
dim=1)
! $omp
p a r a l l e l
d e f a u l t ( none )
&
! $omp& shared ( matrix ,
d i r e c t i o n ,
mat size ) &
! $omp& p r i v a t e ( c o e f f a r r a y ,
j )
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
233
a l l o c a t e
( complex
: : &
c o e f f a r r a y ( mat size + FFT FACTOR MAX) , &
stat=a l l o c s t a t )
c a l l
C f f t 1 d i
( c o l s i z e=mat size ,
c o e f f=c o e f f a r r a y )
! $omp do
do ,
j =1,
s i z e
( matrix ,
dim=2)
c a l l
Cfft1d
( s i g n=d i r e c t i o n ,
&
c o l s i z e=mat size ,
c o l a r r a y=matrix ( : , j ) , &
c o e f f=c o e f f a r r a y )
end do
! $omp end do
! $omp end
p a r a l l e l
end subroutine
Compute ffts
12.2.3 MPI
164. Use MPI to create multiple instruction, multiple data programs that
execute in parallel.
The message passing interface (MPI) is an example of multiple instruction
multiple data (MIMD) computing. Copies of one or more programs are
launched together by a special MPI executive program typically mpiexec or
mpirun. All data in each MPI process is private, and control ﬂow can be very
different between the processes. The only way you can transfer data between
the processes is via calls to special message passing library routines. The MPI
library is implemented using a variety of data communication mechanisms,
including specialized hardware and shared memory. Due to this ﬂexibility,
MPI may be commonly used to parallelize applications in both shared and
distributed memory environments. The distinction is hidden from the caller,
except possibly in communication costs.
The MPI library consists of over 100 entry points and provides many features
and capabilities. The Fortran bindings were designed to be FORTRAN 77
compatible. Only a basic set of these, those needed to get started, will be
described here. We will use a capitalization style identical to the MPI C
bindings for clarity.
On distributed memory systems, the communication costs can be much higher
than on shared memory systems. This is because the additional hardware and
distance involved in the communications adds additional latency to the trans-
fers. Where a non-cached shared memory access might cost, say, 200 nanosec-
onds, the same access on a distributed memory machine with very high-speed
interconnects might take several microseconds. Clearly, communication is to
be avoided if possible.
Here is a small “hello, world” program in which each MPI process prints its
unique identity and the total number of MPI processes. Informally, we will
refer to each MPI process as a processing environment, or PE, to indicate that
Cambridge Books Online © Cambridge University Press, 2012

234
MODERN FORTRAN
it is a program that is running with its own processor and memory, possibly
on a distinct node in a distributed memory system:
Listing 12.2: Program MPI hello
program
MPI hello
use mpi ,
only :
MPI Init ,
MPI Finalize
use mpi ,
only : MPI Comm rank ,
MPI Comm size , &
MPI COMM WORLD
i m p l i c i t
none
integer
: :
me,
npes ,
m p i e r r o r
c a l l
MPI Init
( i e r r o r=mpi err )
c a l l
MPI Comm rank (comm=MPI COMM WORLD,
rank=me, &
i e r r o r=m p i e r r o r )
c a l l
MPI Comm size (comm=MPI COMM WORLD,
s i z e=npes , &
i e r r o r=m p i e r r o r )
p r i n t
* ,
’ h e l l o ,
world !
−from PE ’ , me,
’ , NPES =’ ,
npes
c a l l
MPI Finalize
( i e r r o r=m p i e r r o r )
end program
MPI hello
The mpi module speciﬁed in the use mpi statement is deﬁned as part of the
MPI-2 Standard. It deﬁnes named constants and function return types used
within MPI. All versions of MPI are also required to have a FORTRAN 77-
compatible include ﬁle called mpif.h, which deﬁnes the same values and types.
MPI-2 also allows the mpi module to provide explicit interfaces for all of the
MPI routines. This should always be used when possible to ensure that the
compile-time checking is performed on argument lists. It also allows the use of
keyword=value style actual arguments for clarity (see Rule 60). The examples
shown here use such an implementation. If your version of MPI does not
provide explicit interfaces, you will have to forego the use and beneﬁts of these
features in your program or write your own MPI module (see Rule 165).
The MPI Init routine is called once at the beginning of the program, and
MPI Finalize is called once at the end the program. These bracket the use of
MPI.
To identify the number of MPI processes and allow each process to
identify itself, the MPI Comm rank and MPI Comm size calls are used.
The comm arguments refer to the MPI concept of “communicators.” A
communicator refers to either all of the processes, as the MPI-deﬁned
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
235
communicator MPI COMM WORLD provides, or a user-deﬁned commu-
nicator associated with a subset of the processes. These calls return the size
(number of MPI processes) associated with the communicator – in this case
MPI COMM WORLD, and each process’s unique rank within it.
Almost all MPI library calls return an error code as the ﬁnal argument. An error
value of MPI SUCCESS is returned upon normal completion. Error processing
is omitted in our examples for brevity.
When run with four processes, the output of the program would likely be
something like the following. Note that the rank ordinals are numbered from
zero. Also note that the output is unordered and should be considered to be
nondeterministic, and the order might change from run to run:
$ mpirun -np 4 hello
hello, world! - from PE
0 , NPES =
4
hello, world! - from PE
3 , NPES =
4
hello, world! - from PE
1 , NPES =
4
hello, world! - from PE
2 , NPES =
4
There are many ways to communicate data between the MPI processes. The
most basic is to call the MPI routines MPI Send and MPI Recv. These imple-
ment a “two-sided” communications model whereby a sender explicitly sends
a message to a speciﬁc receiver. A receiver then accepts the data.
The interface to the two calls are similar:
c a l l
MPI Send ( buf ,
count ,
datatype , &
dest ,
tag , comm,
i e r r o r )
. . .
c a l l
MPI Recv ( buf ,
count ,
datatype , &
source ,
tag , comm,
status ,
i e r r o r )
The ﬁrst three arguments, buf, count, and datatype, make up a triplet of
arguments that is used throughout MPI. The argument buf is a buffer of data,
the argument count speciﬁes the number of elements in the buffer, and the
datatype argument speciﬁes the data type of the elements. The data types are
named constants, which are deﬁned in the mpi module and the mpif.h include
ﬁle.
The dest and source arguments specify the PE to which MPI Send will send
the message, and likewise, the PE from which MPI Recv will receive it. The tag
argument allows the sender to uniquely identify a message, so that if multiple
messages have been sent, the receiver can choose which message it desires.
The
status argument in MPI Recv is a small integer array, of size
MPI STATUS SIZE, which contains information on which sender and tag
the message was received from. This is used with a “wildcard” receive capabil-
ity that MPI Recv supports.
Cambridge Books Online © Cambridge University Press, 2012

236
MODERN FORTRAN
Finally, the desired communicator, in this case MPI COMM WORLD, is spec-
iﬁed, along with the ever-present error return argument.
The MPI Send and MPI Recv calls are known as “blocking” operations. The
calls do not return to the caller until the data is safely copied out of, or into,
the buffer area. The receive call in particular could wait for a very long time
in the case where the sender is delayed in sending the data.
Another basic tool for synchronization is called a “barrier,” represented by the
MPI Barrier call. A barrier is simply a point where each of the PEs wait until all
of the processes arrive. Once they do, the barrier opens and the PEs continue
running. Its interface is:
c a l l
MPI Barrier
(comm,
i e r r o r )
Here is an example that demonstrates simple communication and syn-
chronization. Each PE sends a random number, representing some user-
deﬁned computation, to its next higher-ranked neighbor. Likewise, each PE
receives the random number from its next lower-ranked neighbor. There is
a wrap-around in communication where the highest ranked PE sends its
random number to rank 0, and likewise, rank 0 receives it from the high-
est ranked PE. A loop is then used, with a barrier, to enable each PE to
print its random number in order. (For brevity, the program does no error
checking.)
Listing 12.3: Program Comm random
program Comm random
use
i so fortran env ,
only : OUTPUT UNIT
use mpi ,
only :
MPI Init ,
MPI Finalize ,
MPI Barrier
use mpi ,
only : MPI Comm rank ,
MPI Comm size
use mpi ,
only :
MPI Send ,
MPI Recv
use mpi ,
only : MPI COMM WORLD, MPI REAL, &
MPI STATUS SIZE
i m p l i c i t
none
!
buf
argument
r e q u i r e s
a r r a y s .
r e a l
: :
random mine (1) ,
random neighbor (1)
integer ,
a l l o c a t a b l e
: :
s e e d v a l u e s ( : )
integer
: :
a l l o c s t a t , me,
npes ,
neighbor ,
mpi error ,&
i ,
s e e d s i z e ,
s t a t (MPI STATUS SIZE)
c a l l
MPI Init
( i e r r o r=m p i e r r o r )
c a l l
MPI Comm rank (comm=MPI COMM WORLD,
rank=me, &
i e r r o r=m p i e r r o r )
c a l l
MPI Comm size (comm=MPI COMM WORLD,
s i z e=npes , &
i e r r o r=m p i e r r o r )
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
237
!
Seed
d i f f e r e n t
random numbers on each PE .
c a l l
random seed
( s i z e=s e e d s i z e )
a l l o c a t e
( integer
: :
s e e d v a l u e s ( s e e d s i z e ) , &
stat=a l l o c s t a t )
s e e d v a l u e s = me
c a l l
random seed
( put=random values )
!
Send my random number
to my next
h i g h e r
neighbor .
c a l l
random number ( random mine )
random mine = random mine * (me+1)
neighbor = mod (me+1, npes )
c a l l
MPI Send ( buf=random mine ,
count=1, &
datatype=MPI REAL,
dest=neighbor ,
tag=1,
&
comm=MPI COMM WORLD,
i e r r o r=m p i e r r o r )
!
Receive
from my lower
neighbor .
i f
(me /= 0)
then
neighbor = me −1
e l s e
neighbor = npes −1
end
i f
c a l l
MPI Recv ( buf=random neighbor ,
count=1,
&
datatype=MPI REAL,
source=neighbor ,
tag=1,
&
comm=MPI COMM WORLD,
status=stat ,
i e r r o r=m p i e r r o r )
!
P r i n t
r e s u l t s .
c a l l
MPI Barrier
(comm=MPI COMM WORLD, &
i e r r o r=m p i e r r o r )
do ,
i =0, npes −1
i f
( i == me)
then
write
(OUTPUT UNIT,
*)
’PE ’ , me,
&
’ :
o r i g i n a l
no . : ’ ,
random mine ,
&
’ ,
neighbors
no . : ’ ,
random neighbor
f l u s h
(OUTPUT UNIT)
end
i f
c a l l
MPI Barrier
(comm=MPI COMM WORLD, &
i e r r o r=m p i e r r o r )
end do
c a l l
MPI Finalize
( i e r r o r=m p i e r r o r )
end program Comm random
Here is sample output produced when running this on four PEs. Note that
different compilers have different random number algorithms, so the values
you get will differ. The important thing is that the proper values have been
transferred to the neighbor PEs and printed in the proper order:
Cambridge Books Online © Cambridge University Press, 2012

238
MODERN FORTRAN
$ mpirun -np 4
PE 0 : original no.: 0.717690945, neighbors no.: 2.87076378
PE 1 : original no.: 1.43538189, neighbors no.: 0.717690945
PE 2 : original no.: 2.15307283, neighbors no.: 1.43538189
PE 3 : original no.: 2.87076378, neighbors no.: 2.15307283
MPI, like most parallel models, supports all-to-one reductions and one-to-
many broadcasts. These are examples of “collective” communications:
c a l l
MPI Reduce ( sendbuf ,
recvbuf ,
count ,
datatype , &
op ,
root , comm,
i e r r o r )
. . .
c a l l
MPI Bcast ( buffer ,
count ,
datatype ,
root , comm, &
i e r r o r )
Like most MPI routines that communicate data, the triplet argument form
of buffer/count/datatype is required. MPI Reduce has two buffers, a source
buffer that is reduced, and a receive buffer that receives the ﬁnal result. The
op argument is used to specify which operation is performed. Generally, this is
a summation, MPI SUM, but other associative operators such as MPI PROD
and MPI MAX are also available.
The root argument speciﬁes the rank of the processor where the result of
a reduction is placed. Likewise, it speciﬁes the location of the value to be
broadcast to the other processes. And, ﬁnally, the communicator and error
return arguments are speciﬁed. As an example, we could append the following
lines to our example to sum the random numbers from each PE:
. . .
!
Reduce
(sum)
v a l u e s
to PE 0.
c a l l
MPI Reduce ( sendbuf=random mine , &
recvbuf=random sum ,
count=1, datatype=MPI REAL, &
op=MPI SUM,
root =0, comm=MPI COMM WORLD, &
i e r r o r=m p i e r r o r )
!
Broadcast
the sum back
out
to
everyone .
c a l l
MPI Bcast ( b u f f e r=random sum ,
count=1, &
datatype=MPI REAL,
root =0, comm=MPI COMM WORLD, &
i e r r o r=m p i e r r o r )
p r i n t
* ,
’sum =’ ,
random sum
165. Write an MPI communicator module to tailor its use to the applic-
ation.
It is useful to write a module that insulates the application from “bare MPI”
for several reasons: MPI was developed with FORTRAN 77 in mind. It does
not know much about newer versions of Fortran. In particular, the argument
lists tend to be long, confusing, and error-prone. Common cases are not
simple; optional arguments cannot be speciﬁed. And passing objects is very
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
239
cumbersome because MPI does not know about derived types. A complex
set of library calls is required to deﬁne an aggregate object and use it for
communication.
The MPI-2 module, when available, and when it contains all the interface
blocks needed for the application, can help to enhance the readability and
clarity of the code by the use of the keyword=value argument style. And
as always, when explicit interfaces are available, the compiler can do a much
better job of checking the arguments. However, interface blocks are difﬁcult in
standard Fortran for many of the MPI routines because the buﬀer arguments
are allowed to be of any data type, with the actual type being speciﬁed in
the separate datatype argument. (MPI calls these arguments “choice buffers.”)
One approach to writing the module might be to deﬁne generic procedure
names and use a preprocessor to replicate speciﬁc module procedures for each
type/kind/rank for every “choice” argument needed by the application (see
Section 10.2).
For these reasons, it is usually best to write a communications module to isolate
the actual calls to the MPI library, and to provide a friendlier, less error-prone
communications interface to the rest of the application. Only the speciﬁc
routines that are actually used by the application need be deﬁned, though this
is a highly reusable module that would be added to over time.
Let’s deﬁne a derived type containing a default communicator, and deﬁne
some type-bound procedures with it:
Listing 12.4: Module Comm mod
module Comm mod
use mpi
i m p l i c i t
none
private
type ,
public
: :
comm t
integer
: :
comm w = MPI COMM WORLD
contains
procedure
: :
B a r r i e r => Comm barrier
procedure ,
nopass
: :
I n i t => Comm init , &
Final comm => Comm final
procedure
: :
Send => Comm send ,
Recv => Comm recv
end type comm t
l o g i c a l ,
private ,
save
: :
c o m m i n i t i a l i z e d = . f a l s e .
contains
subroutine
Comm barrier
( t h i s )
c l a s s ( comm t ) ,
intent ( in )
: :
t h i s
Cambridge Books Online © Cambridge University Press, 2012

240
MODERN FORTRAN
integer
: :
m p i e r r o r
c a l l
MPI Barrier
(comm=t h i s%comm w ,
i e r r o r=m p i e r r o r )
end subroutine
Comm barrier
subroutine
Comm init
(me,
npes )
integer ,
intent ( out )
: :
me
integer ,
intent ( out )
: :
npes
integer
: :
m p i e r r o r
i f
( . not .
c o m m i n i t i a l i z e d )
then
c a l l
MPI Init
( i e r r o r=m p i e r r o r )
c o m m i n i t i a l i z e d = . true .
end
i f
c a l l
MPI Comm rank (comm=MPI COMM WORLD,
&
rank=me,
i e r r o r=m p i e r r o r )
c a l l
MPI Comm size (comm=MPI COMM WORLD,
&
s i z e=npes ,
i e r r o r=m p i e r r o r )
end subroutine
Comm init
subroutine
Comm recv ( t h i s ,
buff ,
i s o u r c e ,
i t a g )
c l a s s ( comm t ) ,
intent ( in )
: :
t h i s
real ,
intent ( out )
: :
b u f f ( : )
integer ,
intent ( in )
: :
i s o u r c e
integer ,
intent ( in )
: :
i t a g
integer
: :
mpi status (MPI STATUS SIZE)
integer
: :
m p i e r r o r
c a l l
MPI Recv ( buf=buff ,
count=s i z e
( b u f f ) ,
&
datatype=MPI REAL,
source=i s o u r c e ,
tag=i t a g , &
comm=t h i s%comm w ,
status=mpi status , &
i e r r o r=m p i e r r o r )
end subroutine
Comm recv
subroutine Comm send ( t h i s ,
buff ,
i d e s t ,
i t a g )
c l a s s ( comm t ) ,
intent ( in )
: :
t h i s
real ,
intent ( in )
: :
b u f f ( : )
integer ,
intent ( in )
: :
i d e s t
integer ,
intent ( in )
: :
i t a g
integer
: :
m p i e r r o r
c a l l
MPI Send ( buf=buff ,
count=s i z e
( b u f f ) ,
&
datatype=MPI REAL,
dest=i d e s t ,
tag=i t a g , &
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
241
comm=t h i s%comm w ,
i e r r o r=m p i e r r o r )
end subroutine Comm send
end module Comm mod
Using this module, the communication calls in the random number example
program simplify to:
program Comm random
use comm mod ,
only :
comm t
i m p l i c i t
none
. . .
type ( comm t )
: :
my comm
. . .
c a l l
my comm%i n i t
(me=me,
npes=npes )
. . .
c a l l
my comm%send
( b u f f=random mine ,
i d e s t=neighbor )
. . .
c a l l
my comm%recv
( b u f f=random neighbor , &
i s o u r c e=neighbor )
. . .
c a l l
my comm%b a r r i e r
()
. . .
c a l l
my comm%final comm
()
Details of the communicator and anything else that needs to be maintained
can be encapsulated in the comm t object. The sizes and types of the messages
to be passed are also automatically determined by the compiler. For example,
if the application also needs a 2-D integer version of the send and receive calls,
it is easy to create a version of them in the module and make the name generic.
Or, if a communicator other than MPI COMM WORLD needs to be used, it
is a simple matter to store the alternative communicator.
166. Minimize the use of communications and barriers.
The time it takes to transfer data from one MPI process to another is highly
dependent on the underlying hardware. Compared to a shared memory model
like OpenMP, the speed could be slower by a factor of 10, 100, or more. Even
when run on a shared memory system, there is overhead in the library call itself.
The cost of passing a message is broken into two components: the initial latency
of starting up the transfer, and the rate of communications once the transfer has
been initiated. For example, if the latency of starting up the communication
is, say, ﬁve microseconds, and once started, the cost of moving each additional
data item is, say, 100 nanoseconds, it is obvious that moving multiple data
items in a block is far more efﬁcient than initiating a new transfer for each item.
The same considerations apply to synchronization. Often, the only synchro-
nization needed is taking advantage of the blocking characteristics of the receive
Cambridge Books Online © Cambridge University Press, 2012

242
MODERN FORTRAN
calls. Barriers are handy for debugging. As we have seen with our deterministic
I/O loop, barriers are useful to get correct ordering between processes. But
otherwise, barriers should be used as sparingly as possible for best performance.
167. Avoid conditional use of synchronization.
The MPI library does not know the location in your code from which a barrier
call was made. When the MPI processes start encountering barriers, they will
dutifully wait until all the processes encounter a barrier. If the control ﬂow
through the program is different from process to process, it is very easy for the
code to “deadlock,” waiting forever for all the processes to call the barrier for
the communicator, and this may never happen.
i f
( some condition )
then
. . .
c a l l
MPI Barrier
(comm=MPI COMM WORLD, &
i e r r o r=m p i e r r o r )
. . .
end
i f
Carefully placing barriers outside of conditional constructs helps ensure that all
of the processes will eventually encounter the same barrier. The same guideline
applies to loops, even though our deterministic I/O loop demonstrates a case
where a barrier within the loop is essential to making the code work as intended.
12.3 Fortran 2008 Parallel Processing
168. Use the do concurrent statement to write loops that execute in parallel.
The do concurrent statement is an explicit way to indicate that a speciﬁc do
loop may have its iterations performed in parallel. In this sense, it is a simpliﬁed
version of the OpenMP parallel do directive that indicates the same task. It
is most appropriate for shared memory systems when enhancing existing do
loops, when array syntax would cause the creation of temporary arrays, or as
a replacement for forall constructs.
Here is an example of a do concurrent construct. The code carries out the same
task, the tracing of a grid of rays through a lens to compute the irradiance at
a surface, that was described in Rule 161.
type
( l e n s t )
: :
l e n s
type
( r a y t ) ,
a l l o c a t a b l e
: :
r a y s ( : ,
: )
r e a l
(WORKING PREC) ,
a l l o c a t a b l e
: :
i r r a d i a n c e ( : ,
: )
r e a l
(WORKING PREC)
: :
t o t a l i r r a d i a n c e
integer
: :
i row ,
j c o l
!
code
to
a l l o c a t e
r a y s
and
i r r a d i a n c e
to
the
!
same shape .
t o t a l i r r a d i a n c e = 0.0 WORKING PREC
c o l l o o p :
do concurrent
j c o l = 1 ,
s i z e
( rays ,
dim = 2)
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
243
row loop :
do
i r o w = 1 ,
s i z e
( rays ,
dim = 1)
c a l l
Trace ray
( lens ,
r a y s ( i row ,
j c o l ) , &
i r r a d i a n c e ( i row ,
j c o l ))
end do
c o l l o o p
t o t a l i r r a d i a n c e = t o t a l i r r a d i a n c e + &
sum ( i r r a d i a n c e ( : ,
j c o l ))
end do row loop
where the interface to subroutine Trace ray is:
pure
subroutine
Trace ray
( lens ,
ray ,
i r r a d i a n c e )
type
( l e n s t ) ,
intent
( in )
: :
l e n s
type
( r a y t ) ,
intent
( in )
: :
ray
r e a l
(WORKING PREC) ,
intent
( out )
: :
i r r a d i a n c e
end subroutine
Trace ray
When you compare this with the code in Rule 161, you will see that the
variable irradiance has been changed from a scalar to an allocatable array.
Note also that the do concurrent loop is over the columns of the ray grid, and
that after each column the interim sum is calculated using the Fortran intrinsic
function sum.
169. Use coarrays to write programs that execute in parallel.
Coarrays are a new feature that Fortran 2008 introduces. A program that uses
them is SPMD, a single program is replicated into multiple “images.” An
image can be thought of as what we have referred up to now as a process
environment (PE). Coarrays, as will soon be explained, can best be thought of
as a simpliﬁed and integrated alternative to MPI. The coarray model supports
both shared memory and distributed memory hardware.
As with message passing programs, each coarray image performs local memory
accesses in the usual manner. However, speciﬁc arrays may be designated as
“coarrays.” These are data arrays that may be accessed by any of the images.
Data is accessed in the coarrays using normal Fortran expressions and assign-
ment statements. However, when a particular image needs to reference data
from another one, a special notation is used to indicate which remote process
is being referred to.
Coarray data access is “one-sided” in that it simply accesses the remote data
without requiring any action on the part of the remote image and its processor.
This can signiﬁcantly reduce overhead from synchronization of the images and
allow a greater speedup of the code compared to the “two-sided” technique
often used in message passing where one thread has to explicitly send data and
the other thread has to explicitly receive it.
The standard speciﬁes a format for coarray declarations, a set of statements,
and a set of functions. In declarations, square brackets are used to indicate
coarrays. The keyword codimension can be added. Here are some example
declarations:
Cambridge Books Online © Cambridge University Press, 2012

244
MODERN FORTRAN
real ,
codimension [ * ]
: :
ambient temperature
real ,
dimension ( GRID SIZE ,
GRID SIZE )
: :
temper grid [ * ]
Note that the coarray dimension in square brackets is an asterisk [*]; this is
similar to the speciﬁcation for assumed-size regular arrays. The default lower
cobound is 1, not 0 as in MPI.
The variable ambient temperature is a scalar coarray. A single scalar value exists
in each image. The array temper grid is an array coarray. Each image has its own
array of values. The statement that most closely corresponds to the MPI Barrier
procedure is sync all . Two of the more useful intrinsic functions return the
total number of images and the unique identiﬁcation number of a particular
image: num images () and this image (). In addition to the standard itself
(see Reference [43]), Reference [64] is a good starting point to learn more
about this new feature.
The following program is a coarray version of the program Comm random in
Section 12.2.3. Here, it is called Coarray random.
Listing 12.5: Program Coarray random
program Coarray random
use
i so fortran env ,
only : OUTPUT UNIT
i m p l i c i t
none
integer ,
parameter
: :
RANDOM ARRAY SIZE = 1
integer
: :
image number ,
number of images
integer
: :
neighbor ,
i ,
a l l o c s t a t
!
coarray
e n t i t i e s :
each
image
has
i t ’ s own s e t
of
!
s e e d v a l u e s ,
which
i s
an
a r r a y .
Use
[ : ]
f o r
!
a l l o c a t a b l e
c o a r r a y s .
integer ,
allocatable ,
codimension [ : ]
: :
s e e d v a l u e s ( : )
integer
: :
s e e d s i z e
!
use
a s t e r i s k
f o r
non−a l l o c a t a b l e
c o a r r a y s .
real ,
codimension [ * ]
: :
random mine ,
random neighbor
!
V e r i f y
the
number
of
images
running .
number of images = Num images ()
i f
( number of images <= 2) &
stop ” i n s u f f i c i e n t
images ”
image number = this image
()
i f
( image number == 1) &
write
(OUTPUT UNIT,
” (A,
I0 ) ” ) &
” the
number
of
images
i s
” ,
number of images
Cambridge Books Online © Cambridge University Press, 2012

PARALLEL PROCESSING
245
!
Set up the
random number
g e n e r a t o r
on each
image .
!
I n i t i a l i z e
the
seed
to
the
image number .
!
Wait
u n t i l
a l l
the
i n i t i a l
v a l u e s
have
been
s e t
!
b e f o r e
proceeding .
c a l l
random seed
( s i z e=s e e d s i z e )
!
a s t e r i s k
must be
s p e c i f i e d .
a l l o c a t e
( integer
: :
s e e d v a l u e s ( s e e d s i z e ) [ * ] , &
stat=a l l o c s t a t )
!
colon
must be
s p e c i f i e d .
s e e d v a l u e s ( : ) = image number
c a l l
random seed
( put=s e e d v a l u e s )
c a l l
random number ( random mine )
random mine = random mine * image number
sync
a l l
!
Set
the
h i g h e r
neighbor
to
t h i s
images random
!
number :
(2 <−1;
3 <−2;
. . .
1 <−4 ) .
!
This
accomplishes
both
the
send
and
r e c e i v e
of
the
!
MPI program .
neighbor = mod ( image number ,
number of images ) + 1
random neighbor [ neighbor ] = random mine
!
P r i n t
the
r e s u l t s
i n
image
order
a f t e r
a l l
the
!
images
have
reached
t h i s
point .
sync
a l l
do ,
i = 1 ,
number of images
i f
( i == image number )
then
write
(OUTPUT UNIT,
” (A,
I0 ,
2(A,
G14 . 7 ) ) ” ) &
”image ” ,
image number ,
’ :
o r i g i n a l
no . :
’ , &
random mine ,
” ,
neighbors
no . :
” , &
random neighbor
f l u s h
(OUTPUT UNIT)
end
i f
sync
a l l
end do
end program Coarray random
Here is the output using four images:
the number of images is 4
im1: orig. no.:
0.3920868E-06, neighbors no.:
0.1568347E-05
im2: orig. no.:
0.7841736E-06, neighbors no.:
0.3920868E-06
im3: orig. no.:
0.1176260E-05, neighbors no.:
0.7841736E-06
im4: orig. no.:
0.1568347E-05, neighbors no.:
0.1176260E-05
Cambridge Books Online © Cambridge University Press, 2012

246
MODERN FORTRAN
Pay attention to several particular details: Coarrays can be allocatable, as the
array coarray seed values is. In this case, however, the codimension is speciﬁed
using the deferred-shape notation, a colon. When allocating such entities, an
asterisk in brackets must be speciﬁed:
a l l o c a t e
( integer
: :
s e e d v a l u e s ( s e e d s i z e ) [ * ] , &
stat=a l l o c s t a t )
Moreover, when referencing an entire array coarray, a colon in parentheses
must be included as was done here in the program:
s e e d v a l u e s ( : ) = image number
The simplicity of this notation is signiﬁcant. The following single state-
ment showing inter-image communication replaces the calls to MPI send
and MPI recv in the MPI program:
random neighbor [ neighbor ] = random mine
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

13.
Numerical Types, Kinds,
and Operations
The ﬁrst section in this chapter explains the concept of “kinds” in Fortran. The
second section presents several guidelines for using ﬂoating-point numbers in
the context of performing numerical calculations using a representation that is
by nature inexact. The third section presents some aspects of the ﬂoating-point
exception handling that are now part of modern Fortran. Finally, in the fourth
section we present some of the bit manipulation features.
13.1 The Concept of KIND
Modern Fortran characterizes the sizes and characteristics of integers, ﬂoating-
point numbers and other data types as different kinds, and parameterizes
them by kind type parameter values. For example, the Fortran processor will
almost certainly provide a kind type parameter that corresponds to a four-
byte real. For one Fortran processor, the kind type parameter value may be 4,
corresponding to the number of bytes; but, for a second processor, it could
be 1, corresponding to the lowest precision available. The processor may also
provide kind type parameters that correspond to single-byte, two-byte, and
eight-byte integers.
The standard requires the processor provide at least one integer type. Similarly,
two real kinds must be available. The default real kind is the less precise of the
two. Normally, the default real will correspond to “single precision,” and the
additional required kind to “double precision.” Thus, a processor may support
several sizes of integers, each with a different kind type parameter value, and
likewise for reals. Because each integer and real has a different size, each has
different numerical limits of the number of representable digits (in the case
of integers) or the representable precision and range (in the case of real and
complex ﬂoating-point numbers).
Only one character kind is required, but the standard makes a provision for
an international character set. The default logical type parameter, the sole one
required, corresponds to a logical that is the same length as a default real
and default integer to accommodate storage association with equivalence and
common blocks. Many vendors provide logical kinds that occupy less memory;
247
Cambridge Books Online © Cambridge University Press, 2012

248
MODERN FORTRAN
they may be efﬁcient in terms of storage for applications that have large logical
arrays.
170. Based on application numerical requirements, and using Fortran
instrinsic functions such as
selected int kind and
selected real kind ,
establish a set of integer named constants that correspond to the kind
type parameters needed. Place them all in a single module, and use these
constants in the deﬁnition of program data objects.
Every application has its particular requirements for both the accuracy and the
range of magnitude of ﬂoating-point numbers. It will also possess requirements
for the range of magnitude of integer values. You should use these requirements
to specify the particular real and integer kinds used to deﬁne program data
objects.
Beginning with Fortran 90, the language has provided the programmer with
intrinsic functions that return the kind type parameter value that corresponds
to a required range for integers and a required range and precision for reals.
The values returned by these functions can be used to set the value of integer
named constants, and these constants, in turn, can be used in the declaration
of program data objects.
You should use the Fortran intrinsic functions
selected real kind
and
selected int kind to deﬁne named constants for use in your program as kind
type parameters. Then place them in one module. The Fortran processor will
use the kind with the least precision and the smallest range that satisﬁes the
requested values.
For example, suppose the required ﬂoating-point accuracy is 15 decimal digits
of accuracy and a range between 10−308 to 10308. This is commonly double
precision accuracy. Additionally, say there is a requirement for a set of integers
whose range varies between 0 and 64,000, that is, a value up to 105. Further-
more, there is also a requirement for integers whose values can range from
−109 to 109. The program will also have an array numbering fewer than 100
elements.
module App kinds mod
i m p l i c i t
none
integer ,
parameter
: :
WORKING PREC = &
s e l e c t e d r e a l k i n d
(15 ,
307)
integer ,
parameter
: :
COLOR INT = s e l e c t e d i n t k i n d
(5)
integer ,
parameter
: :
PIXEL INT = s e l e c t e d i n t k i n d
(9)
integer ,
parameter
: :
INT 100
= s e l e c t e d i n t k i n d
(2)
end module App kinds mod
Here these constants are used to deﬁne program data objects:
Cambridge Books Online © Cambridge University Press, 2012

NUMERICAL TYPES, KINDS, AND OPERATIONS
249
module
P i x e l c o l o r m o d
use
App kinds mod
i m p l i c i t
none
enum ,
bind
(C)
enumerator
: :
NO COLOR = 0 , RED, GREEN, BLUE
end enum
integer
( kind
(BLUE) ) , parameter
: : MAX COLOR = BLUE
integer
( PIXEL INT ) ,
parameter
: : &
MAX PIXEL = 10000000
integer
( INT 100 ) ,
parameter
: :
MAX CONFIGS = 10
type
p i x e l t
r e a l
(WORKING PREC)
: :
i n t e n s i t y = 0.0
integer
(COLOR INT)
: :
c o l o r s (MAX COLOR) = NO COLOR
end type
p i x e l t
type
( p i x e l t ) ,
parameter
: : &
INITIAL PIXEL = p i x e l t
( i n t e n s i t y = 0.0 , &
c o l o r s = NO COLOR)
type
c o l o r c o n f i g t
integer
( INT 100 )
: :
configuration number = 0
type
( p i x e l t )
: :
p i x e l s (MAX PIXEL) = INITIAL PIXEL
end type
c o l o r c o n f i g t
type
( c o l o r c o n f i g t )
: :
c o n f i g u r a t i o n s (MAX CONFIGS)
contains
!
. . .
module
procedures .
end module
P i x e l c o l o r m o d
By stringently specifying the kind type parameter values, your program will
produce consistent results, and it can be ported from one Fortran processor
to another more easily (see Rule 193). In Fortran 2008, the intrinsic module
iso fortran env provides constants that may assist in selecting intrinsic type
kinds. For example, for type real, the constant REAL KINDS is an integer
array whose size equals the number of real kinds supported by the compiler
and whose elements are equal to the kind values. The named constants,
REAL32, REAL64, and REAL128 are integers holding the kind values for
reals of storage size 32, 64 and 128 bits. (See Reference [43].)
13.2 Floating-Point Operations
Floating-point operations are essential to almost all scientiﬁc applications. The
rules in this section are intentionally general. Far more detailed information
Cambridge Books Online © Cambridge University Press, 2012

250
MODERN FORTRAN
is available in texts and papers than can be presented here. An excellent
introduction to ﬂoating-point arithmetic and its issues is Reference 25.
171. Never write code depending upon ﬂoating-point equality.
Because ﬂoating-point numbers cannot always exactly represent a value, you
should not use them in relational expressions where the operator is the exact
equality (==). At its simplest, this means you should not write code like this:
r e a l
: :
a ,
b
test number :
i f ( a == b ) then
. . .
end
i f
test number
Given that for any particular real kind there are a ﬁxed number of ﬂoating-
point values that can be represented exactly, the chance of two numbers having
exactly the same value is small.
The test statement should be written
i f
( abs
(a−b ) < e p s i l o n )
then
where epsilon is a very small, user-provided, number. The code for function
Near0 dp in the next listing shows the use of intrinsic functions to approach
zero when the user does not provide a value for epsilon. Using it, the test
statement would be written:
i f
( Near0 dp
( abs
(a−b ) ) )
then
This is a situation in your application where you need to determine if one
ﬂoating-point value is essentially the same as another, acknowledging the fact
that they most likely will not be exactly the same. You wish to know if a
number is essentially zero. Instead of testing for an exact comparison, you can
use the code in the function Near0 dp shown here:
Listing 13.1: Function Near0 dp
module Kinds mod
i m p l i c i t
none
integer ,
parameter
: : &
DP = s e l e c t e d r e a l k i n d
(15 ,
307)
r e a l
(DP) ,
parameter
: :
TINY DP = tiny
( 1 . 0 DP ) , &
TINY FACTOR = 5.0
end module Kinds mod
elemental
function
Near0 dp
( test number ,
e p s i l o n ) &
r e s u l t
( r e t u r n v a l u e )
Cambridge Books Online © Cambridge University Press, 2012

NUMERICAL TYPES, KINDS, AND OPERATIONS
251
!
Purpose : To t e s t
i f
a number
i s
near
0.
use Kinds mod
i m p l i c i t
none
r e a l
(DP) ,
intent
( in )
: :
test number
r e a l
(DP) ,
intent
( in ) ,
optional
: :
e p s i l o n
l o g i c a l
: :
r e t u r n v a l u e
r e a l
( kind
( e p s i l o n )
)
: :
l o c a l e p s i l o n
l o c a l e p s i l o n = TINY FACTOR * TINY DP
i f
( present
( e p s i l o n )
)
then
i f
( abs
( e p s i l o n ) >= TINY DP) &
l o c a l e p s i l o n = abs
( e p s i l o n )
end
i f
r e t u r n v a l u e = abs
( test number ) < l o c a l e p s i l o n
end
function
Near0 dp
Another example of a situation where you trap a particular condition in your
code is the use of a sentinel. Never use ﬂoating-point quantities as sentinel
values. For example, when reading ﬂoating-point values from a ﬁle, you might
think to signal the end of a set of data in the ﬁle by the number −999.999.
You would then write a test like the following to exit the read operation. Use
integer, character, or logical values for sentinel values.
integer ,
paramter
: :
NUMBER PER RECORD = 3
real ,
parameter
: :
STOP SENTINEL = −999.999
r e a l
: :
data row (NUMBER PER RECORD)
. . .
do
read
(UNIT NUMBER,
data frmt )
data row
! BAD, Do not
use
f l o a t i n g −point
numbers
as a
s e n t i n a l .
i f
( any ( data row == STOP SENTINEL ))
e x i t
!
. . .
normal
p r o c e s s i n g
end do
172. Write code that performs ﬂoating-point operations in a manner that
reduces rounding errors.
Every time your program performs a ﬂoating-point calculation, and the result
does not produce a ﬂoating-point exception, it is more than likely that the
result will not represent the exact correct answer; it will be the nearest number
representable for the particular type parameter being used. As a series of
computations is performed, this error can accumulate and become signiﬁcant;
code should be written to maintain the error as small as possible.
Cambridge Books Online © Cambridge University Press, 2012

252
MODERN FORTRAN
Here is an example. A loop is established that will step by increments through
a range of values and a function is called at each iteration.
function
F u n c c a l l
( delta ,
i n i t i a l
v a l ,
f i n a l v a l ) &
r e s u l t
( r e t v a l )
real ,
intent ( in )
: :
delta ,
i n i t i a l
v a l ,
f i n a l v a l
r e a l
: :
r e t v a l
r e a l
( kind
( i n i t i a l
v a l ))
: :
tmp val
real ,
a l l o c a t a b l e
: :
d a t a r y ( : ) ,
r e d u c t d a t ( : )
integer
: :
i s t p
tmp val = i n i t i a l
v a l
i s t p
= 1
do
i f
( tmp val > f i n a l v a l )
then
e x i t
e l s e
c a l l
C a l c v a l
( tmp val ,
dat ary ,
r e d u c t d a t ( i s t p ))
end
i f
i s t p
= i s t p + 1
tmp val = tmp val + d e l t a
end do
r e t v a l = tmp val
end
function
F u n c c a l l
where the interface to subroutine Calc val is:
i n t e r f a c e
subroutine
C a l c v a l
( comp value ,
dat ary ,
r e t u r n v a l )
real ,
intent
( in )
: :
comp value
real ,
intent
( in
out )
: :
d a t a r y ( : )
real ,
intent
( out )
: :
r e t u r n v a l
end subroutine
end
i n t e r f a c e
The problem with this code is that the value of the variable tmp val accumulate
a rounding error as the iterations proceed. Here is code that avoids the problem
by eliminating the summation:
i s t p = 1
do
tmp val = i n i t i a l
v a l + ( i s t p −1) *
d e l t a
i f
( tmp val > f i n a l v a l )
then
e x i t
e l s e
c a l l
C a l c v a l
( tmp val ,
dat ary ,
r e d u c t d a t ( i s t p ))
end
i f
i s t p = i s t p + 1
end do
Cambridge Books Online © Cambridge University Press, 2012

NUMERICAL TYPES, KINDS, AND OPERATIONS
253
173. Avoid performing ﬂoating-point operations involving numbers of
widely different orders of magnitude.
Performing operations using ﬂoating-point numbers that differ widely in their
orders of magnitude can produce unexpected results. Here for example is
the addition of two numbers of default type real, here assumed to be single
precision, with eight digits of decimal precision.
r e a l
: :
a ,
b ,
d
a = 1.687 e8
b = 2.4 e−6
d = a + b
This operation will produce a value for the variable d that is equal to that of
variable a. The following addition is being done:
168700000.0
+ 0.0000024
-----------------
168700000.0000024
The result will be 168700000.0 because the precision of the numbers does not
extend past eight signiﬁcant ﬁgures, and the range of signiﬁcant ﬁgures here
extends over an order of magnitude of 1014.
13.3 Floating-Point Exceptions
174. Use the capabilities of intrinsic modules IEEE exceptions,
IEEE arithmetic, and IEEE features to trap ﬂoating-point exceptions.
Background The publication in 2001 of Reference [30] marked the impor-
tance of adding ﬂoating-point exception handling to Fortran. The features
it speciﬁed, as well as some additional ones, are now part of the language
standard.
IEEE Intrinsic Modules Reference [33], commonly referred to as “IEEE
arithmetic, exceptions, and procedures,” is the international standard for
binary arithmetic. The Fortran 2003 features support the standard, that is,
IEEE arithmetic, but do not fully implement it. They do, however, place
tools in the programmer’s hands that enable the writing of robust numerical
code. The compiler provides access to these tools through three intrinsic mod-
ules IEEE features, IEEE arithmetic, and IEEE exceptions. IEEE arithmetic
contains a use statement for the last. The following paragraphs are brief
descriptions of the modules.
Cambridge Books Online © Cambridge University Press, 2012

254
MODERN FORTRAN
IEEE features The module IEEE features contains only named constants.
Each named constant corresponds to the inclusion of support for a particular
feature of IEEE arithmetic. For example, the named constant IEEE HALTING
speciﬁes support for IEEE halting for at least one kind of real and at least one
exception ﬂag.
IEEE arithmetic The module IEEE arithmetic contains named constants
and functions. There are two groups of functions: The ﬁrst are pure inquiry
functions. You use them to determine which arithmetic features are supported.
The function IEEE support datatype (x), for example, returns a logical result
that indicates if the compiler supports IEEE arithmetic for the kind of real
variable represented by the argument x. The second set of functions are all
elemental ones. Some are inquiry functions; others perform operations. For
example, the function IEEE is ﬁnite (x) returns a logical value indicating if
x is or is not a ﬁnite number. As an example of a function in this module
that performs an operation, the function IEEE rint (x) returns the rounded
integer value of x.
The named constants of this module also divide into two sets: The ﬁrst are con-
stants such as IEEE POSITIVE INF, the number that represents positive inﬁn-
ity. The second set describes rounding modes. The constant IEEE NEAREST,
for example, speciﬁes that the exact value of a number be rounded to the
nearest representable value.
IEEE exceptions The module IEEE exceptions is used to handle exceptions.
For this reason, we explain its properties in more detail than we did the two
others. Five exceptions are deﬁned in the module, and each is designated by
a ﬂag. The exceptions are overﬂow, division by zero, an invalid operation,
underﬂow, and an operation that produces a result that is an inexact num-
ber, meaning one that cannot be represented exactly, and, therefore, must be
rounded. During program execution an exception ﬂag can be signaling, indi-
cating an exception has occurred, or quiet. The module contains ﬁve named
constants that correspond to the exceptions. It also contains pure inquiry
functions, and elemental and nonelemental subroutines that will permit you
to handle them. The named constants are of derived type IEEE ﬂag type. If
you want to trap an overﬂow condition, for instance, you will use the constant
IEEE OVERFLOW as the ﬁrst argument in calls to the elemental subrou-
tine IEEE get ﬂag (IEEE OVERFLOW, ﬂag value) to determine if the ﬂag is
signaling that an overﬂow exception has occurred.
This module contains two pure inquiry functions,
IEEE support ﬂag (FLAG, [,x]) and IEEE support halting (FLAG). The for-
mer returns a value of .true. if the processor supports the detection of the
exception FLAG for the data type kind represented by x (or for all real kinds
if x is absent); otherwise, it returns . false .. The second function returns a
value indicating if the program supports halting control for FLAG. If it does,
Cambridge Books Online © Cambridge University Press, 2012

NUMERICAL TYPES, KINDS, AND OPERATIONS
255
you can, using functions in this module, control whether a program does or
does not terminate if the exception represented by FLAG occurs; otherwise,
you cannot control halting.
The
two
elemental
subroutines
in
the
module
are
IEEE get ﬂag
(FLAG, ﬂag value)
and
IEEE get halting mode (FLAG, halting),
which,
respectively, permit you to retrieve the ﬂag value and halting mode for FLAG.
Two of the nonelemental subroutines permit you to set ﬂag val-
ues and halting modes: subroutine IEEE set ﬂag (FLAG, ﬂag value) and
IEEE set halting mode (FLAG, halting).
Example The elemental function Divide dp demonstrates how you can incor-
porate exception handling in your code. It is an elemental function that a
program can call to perform a “safe” divide. Using the ﬂoating-point excep-
tion handling capabilities now in Fortran, it traps three serious exceptions:
overﬂow, division by zero, and invalid division, and returns a number that can
be used in subsequent calculations.
First, a module is created containing some named constants. The constants
are deﬁned in comment statements in the routine.
Listing 13.2: Function Divide DP
module IEEE params
i m p l i c i t
none
! DP −double
p r e c i s i o n
! HUGE DP −the
l a r g e s t
r e p r e s e n t a b l e
double
!
p r e c i s i o n
number .
integer ,
parameter
: : &
DP = s e l e c t e d r e a l k i n d
(15 ,
307)
r e a l
(DP) ,
parameter
: :
HUGE DP = huge
( 1 . 0 DP)
!
enumeration
corres ponding
to
the
IEEE
e x c e p t i o n
f l a g s .
!
the
i n d i c e s
correspond
to
the
index
of
the
each
f l a g
!
i n
the named
constant
a r r a y
IEEE USUAL .
enum ,
bind
(C)
enumerator
: :
OVERFLOW INDEX = 1 ,
&
DIVIDE BY ZERO INDEX ,
INVALID INDEX
end enum
!
synonyms
f o r
. t r u e .
and
. f a l s e .
l o g i c a l ,
parameter
: :
QUIET
= . f a l s e . , &
SIGNAL = . true . , ON = . true . , OFF = . f a l s e .
end module IEEE params
Cambridge Books Online © Cambridge University Press, 2012

256
MODERN FORTRAN
elemental
function
Divide DP
( numer ,
denom ,
n a n r e s u l t )&
r e s u l t
( r e t u r n v a l u e )
use
IEEE params
use ,
i n t r i n s i c
: :
IEEE exceptions
use ,
i n t r i n s i c
: :
IEEE features ,
only
: &
IEEE INVALID FLAG , IEEE DATATYPE, IEEE HALTING
i m p l i c i t
none
!
numer −the
numerator
!
denom −the
denominator
!
n a n r e s u l t −answer
to
be
r e t u r n e d
f o r
an
undefined
!
o p e r a t i o n
such
as
0.0/0.0
r e a l
(DP) ,
intent ( in )
: :
numer ,
denom ,
n a n r e s u l t
r e a l
(DP)
: :
r e t u r n v a l u e
l o g i c a l
: :
f l a g v a l u e s ( s i z e
(IEEE USUAL))
!
f i r s t
attempt
to
d i v i d e
normally
r e t u r n v a l u e = numer / denom
! Now check
the
f l a g s
and
s e t
the
r e s u l t
a c c o r d i n g l y
!
i f
an
overflow ,
a
d i v i d e −by−zero
or
an
i n v a l i d
!
o p e r a t i o n
are
s i g n a l i n g .
c a l l
IEEE get flag
( IEEE USUAL , &
f l a g v a l u e s (OVERFLOW INDEX:
INVALID INDEX )
)
f l a g t e s t :
i f
( any ( f l a g v a l u e s ))
then
i f
( any (
f l a g v a l u e s (OVERFLOW INDEX:
&
DIVIDE BY ZERO INDEX)
))
then
r e t u r n v a l u e = HUGE DP
e l s e
i f
( f l a g v a l u e s ( INVALID INDEX ))
then
r e t u r n v a l u e = n a n r e s u l t
end
i f
!
s e t
the
s i g n .
r e t u r n v a l u e = r e t u r n v a l u e
*
s i g n
(
1.0 e0 DP , &
(
s i g n
( 1 . 0 e0 DP ,
numer ) *
&
s i g n
( 1 . 0 e0 DP ,
denom)
)
)
end
i f
f l a g t e s t
end
function
Divide DP
At every location in the code where a precarious division needs to be done,
this function can be used. In the following code, the function will return a
value of HUGE DP because of the division by 0.0.
r e a l
( kind=DP)
: :
a ,
b ,
d
b = 5.0
Cambridge Books Online © Cambridge University Press, 2012

NUMERICAL TYPES, KINDS, AND OPERATIONS
257
d = 0.0
a = Divide DP
(b ,
d ,
0.0 DP)
A few comments about this function are in order: Two named constants in
module IEEE exceptions are used. The constant IEEE USUAL is the array of
three of the exceptions: [IEEE OVERFLOW, IEEE DIVIDE, IEEE INVALID].
Similarly, the named constant IEEE ALL is the array [IEEE OVERFLOW,
IEEE DIVIDE, IEEE INVALID, IEEE UNDERFLOW, IEEE INEXACT].
The correct functioning of this function depends on several conditions being
met. It assumes that the halting mode has been turned off for all the exceptions;
otherwise, the program would halt when one occurs. This could have been
done when the program was started by making the following call for each
exception ﬂag using the named parameter OFF deﬁned in the previous module
IEEE Params.
c a l l
IEEE set halting mode
(FLAG, OFF)
This call has to be made for each exception ﬂag separately because this sub-
routine is not elemental. For a program that will be built using many different
Fortran processors, which may possess varying degrees of support for ﬂoating-
point exception handling, support of halting control should ﬁrst be checked
by calls to the following pure function:
IEEE support halting
(FLAG)
There is a similar requirement to check if the exception is supported; this is
done by calls to this aforementioned pure function:
IEEE support flag
(FLAG [ ,
x ] )
The procedure Divide DP, as previously written, assumes all these neces-
sary conditions exist. In this manner it can execute quickly; if the divi-
sion doesn’t raise an exception, the division is carried out and only the
exception ﬂags need to be checked before control is returned to the
calling procedure. A more general but time-consuming procedure would
include calls to IEEE support datatype (x) and, if it returns .true., calls to
IEEE support halting (FLAG) for the three exceptions being checked. If any of
these calls returned . false ., alternative code (not shown) would be executed
to trap a potential exception before it occurs.
Note that the function IEEE set ﬂag is not called on entry to the procedure
to set the ﬂags quiet. It is conceivable that one or more might have been sig-
naling in the calling procedure when Divide DP was referenced. The standard
speciﬁes that signaling ﬂags will be set quiet on entry to all procedures. On
return, the ﬂags that were signaling on entry will be reset tosignaling; any
Cambridge Books Online © Cambridge University Press, 2012

258
MODERN FORTRAN
ﬂags that began signaling an exception in the procedure will remain signaling
on return.
13.4 Bit Manipulation
Fortran provides a set of intrinsic procedures to allow the manipulation of indi-
vidual bits within data items. Generally, bit manipulation centers around the
packing of multiple small ﬁelds of data into a larger data item, and the extrac-
tion of the ﬁelds when needed. This is often needed when interfacing with
external data layouts and hardware devices that are not directly supported by
the compiler in use. A programmer might even recognize bit-oriented shortcuts
to use instead of more time-consuming operations. For example, certain inte-
ger division operations can be performed by using simple bit shifting, thereby
avoiding the need for using a more expensive general division algorithm in
time critical code.
However, by their nature, bit manipulation operations introduce portability
and code clarity problems. Therefore, their use should be as isolated and
well documented as possible. In particular, named constants should be used
wherever possible to identify bit ﬁeld sizes and positions.
175. Use high-level bit manipulation.
The fundamental tools for bit manipulation on integers are the “shifting and
masking” instrinsic functions. These include ishft (end-off shift), ishftc (cir-
cular shift), iand (logical product), ior (logical sum or inclusive OR), ieor (log-
ical difference or exclusive-OR), and not (bit inversion). By combining these
operations in various ways, any bit manipulation may be performed. How-
ever, there are additional intrinsic functions that can simplify code. Depending
on the hardware in use, some may even directly translate into more efﬁcient
machine instruction sequences.
It is important to note that specifying a positive value for the second argument
in ishft and ishftc , the shift count, indicates a “left shift.” Likewise, a negative
value speciﬁes a “right shift.” With an end-off shift, vacated bit positions are
ﬁlled with zero bits. With a circular shift, bits are “wrapped around.”
The ibits intrinsic function extracts a ﬁeld of bits without explicitly coding
the shift and mask operation. This is equivalent to shifting the desired bit ﬁeld
to the right-hand side of the integer, and then extracting the ﬁeld with an OR
operation:
!
i n s t e a d
of :
my new bits = iand
( i=i s h f t
( i=my data ,
s h i f t =−12), &
j=b ’111111 ’)
!
use :
integer ,
parameter
: :
FIELD POS
= 12
Cambridge Books Online © Cambridge University Press, 2012

NUMERICAL TYPES, KINDS, AND OPERATIONS
259
integer ,
parameter
: :
FIELD WIDTH = 6
. . .
my new bits = i b i t s
( i=my data ,
pos=FIELD POS , &
len=FIELD WIDTH)
The mvbits intrinsic subroutine allows insertion of bits into a bit ﬁeld without
explicitly coding multiple shift and mask operations.
!
i n s t e a d
of :
integer ,
parameter
: :
MY FIELD MASK = b ’111111 ’
. . .
!
E l i m i n a t e
unwanted
b i t s
temp1 = iand
( i=my new bits ,
j=MY FIELD MASK)
!
Rotate
z e r o s
to
low
order
b i t s
temp2 = i s h f t c
( i=my data ,
s h i f t =−12)
!
E l i m i n a t e
unwanted
b i t s
temp2 = iand
( i=temp2 ,
j=not
(MY FIELD MASK))
!
I n s e r t
f i e l d
and
r o t a t e
back
to
c o r r e c t
p o s i t i o n
my data = i s h f t c
( i=i o r
( i=temp2 ,
j=temp1 ) ,
s h i f t =12)
!
use :
integer ,
parameter
: :
FIELD POS
= 12
integer ,
parameter
: :
FIELD WIDTH = 6
. . .
c a l l
mvbits
( from=my new bits ,
frompos=0,
&
length=FIELD WIDTH ,
to=my data ,
topos=FIELD POS)
Likewise, the ibset, ibclr , and ibtest intrinsic functions allow setting, clearing,
and testing of individual bits without explicitly coding multiple shift and mask
operations.
176. Avoid unwanted data conversion problems.
The bit intrinsic functions in Fortran 2003 operate on normal signed integer
variables. When widening from one integer kind to a different kind via simple
integer assignment, the sign bit can become a problem. When widening to a
larger kind, the sign bit will be “extended” to maintain the representation of
the number. Likewise, when narrowing to a smaller kind, the sign will also be
maintained, thereby eliminating a possibly desired bit. One solution is to use
the transfer intrinsic. Another is to use mvbits.
!
i n s t e a d
of :
integer ( kind=s e l e c t e d i n t k i n d
( 8 ) )
: :
b i t s 3 2
integer ( kind=s e l e c t e d i n t k i n d
(14))
: :
r e s u l t 6 4
. . .
!
P o s s i b l y
bad due
to
s i g n
e x t e n s i o n
r e s u l t 6 4 = b i t s 3 2
Cambridge Books Online © Cambridge University Press, 2012

260
MODERN FORTRAN
!
use :
r e s u l t 6 4 = t r a n s f e r
( bits32 ,
mold=r e s u l t 6 4 )
!
or
use :
r e s u l t 6 4 = 0
c a l l
mvbits
( from=bits32 ,
frompos=0,
&
length =32,
to=r e s u l t 6 4 ,
topos=0)
Problems can also occur when attempting to compare bit ﬁelds. Since the
usual comparison operators assume signed integers, bit ﬁelds that include the
sign bit may be incorrectly compared. The exclusive-OR intrinsic, ieor, is
often used to compare ﬁelds. It is especially useful when the bit pattern for
−0 is confused with the bit pattern for +0. The Fortran standard requires that
comparison be performed as if +0 and −0 are equivalent.
!
i n s t e a d
of :
integer ( kind=s e l e c t e d i n t k i n d
( 8 ) )
: :
b i t s a ,
b i t s b
b i t s a = 0
b i t s b = z ’80000000 ’
. . .
!
P o s s i b l y
bad due
to
s i g n
e x t e n s i o n
i f
( b i t s a /= b i t s b )
then . . .
!
use :
l o g i c a l
: :
is same
. . .
do ,
i=b i t s i z e
( b i t s a )−1, 0 , −1
i f
( btest
( b i t s a ,
i )
. neqv .
( btest
( b i t s b ,
i ))
e x i t
end do
i f
( i < b i t s i z e
( b i t s a ))
then . . .
With Fortran 2008, the above loop may be replaced with the ieor intrinsic
function, and then you can use the new popcnt intrinsic function to detect
differences.
!
i n
F2008 ,
use :
i f
( popcnt
( i e o r
( b i t s a ,
b i t s b )) /= 0)
then
Worse problems occur when converting between integer and real data types.
During conversion, the bits are rearranged and sometimes eliminated. Again,
the transfer intrinsic must be used to properly copy the bits without reinter-
pretation.
!
i n s t e a d
of :
r e a l ( s e l e c t e d r e a l k i n d
( 6 ) )
: :
r e a l v a l u e
integer ( s e l e c t e d i n t k i n d
( 8 ) )
: :
b i t s
. . .
! Bad due
to
data
c o n v e r s i o n
b i t s = r e a l v a l u e
Cambridge Books Online © Cambridge University Press, 2012

NUMERICAL TYPES, KINDS, AND OPERATIONS
261
!
use :
b i t s = t r a n s f e r
( r e a l v a l u e ,
mold=b i t s )
As a further aid to avoid these problems, Fortran 2008 has many additional
versions of the intrinsic functions. They still only accept integers, so transfer
is still needed to perform bitwise moves between the various data types.
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

14.
C Interoperability
177. Use Fortran’s C interoperability capabilities to interact with
C programs.
Due to the enormous popularity of the C programming language (References
[46], [38], and [28]), many Fortran programmers need to be able call routines
written in C, or written to conform to C calling conventions. Likewise, it is
often useful for C programmers to call routines written in Fortran. Beginning
with Fortran 2003, there is a new and standard mechanism to allow easier and
more portable interfacing between Fortran and C.
Here are some of the topics that must be considered when code written in
Fortran accesses that written in C and vice versa:
■The mapping of built-in data types between Fortran and C.
■The mapping of pointers.
■The mapping between Fortran derived types and C structs.
■The mapping of global variables.
■The internal calling sequence mechanisms for passing actual arguments and
function return values during procedure calls.
■The mapping of external names between Fortran and C and invocation of
functions and procedures.
The next sections present details of these various points. The ﬁrst deals with the
mapping of the basic data types. Using these types, the second section presents
the calling mechanism between the two, including mapping of external names;
we present a short example. The sections that follow continue presenting the
mapping of other types of entities, pointers, global data, and so on, also with
short examples.
Two entities are key to C interoperability: the intrinsic module iso c binding ,
and the bind attribute. The ﬁrst contains named constants, derived types, and
module procedures that must be used; the bind attribute allows variables to
inter-operate with C.
Mapping Intrinsic and Basic Data Types Each of the named constants
deﬁned in module iso c binding speciﬁes a kind value that corresponds to a
particular basic type in C. Here are two examples:
use
iso c binding ,
only
: C FLOAT,
C INT
. . .
integer
( kind=C INT)
: :
f o r t i n t v a l u e
262
Cambridge Books Online © Cambridge University Press, 2012

C INTEROPERABILITY
263
r e a l
( kind=C FLOAT)
: :
f o r t f l o a t v a l u e
Calling Sequence A calling sequence deﬁnes the internal mechanisms used
to pass actual arguments from a calling procedure to a called procedure, and
to return values from the latter to the former. The internal details such as
the machine registers to use, and the operation of any stack-based or other
memory allocation, must be compatible. Fortran 2003 addresses these issues
by requiring a “companion” C compiler to be used with the Fortran compiler.
Once this requirement has been met, by the compiler developers themselves,
programmers typically do not need to concern themselves with these low-level
issues.
Mapping External Names – Invoking C from Fortran Consider a program
that runs on a POSIX-compliant system, such as Linux. At some point, the
program desires to call the getpid system call, which returns the program’s
process ID number. The C prototype is the following:
#include <u n i s t d . h>
p i d t
g e t p i d ( void ) ;
The type pid t is aliased to the C basic type int using a typedef keyword:
typedef
i n t
p i d t ;
To map external names, the bind(C) statement can be used with a procedure
deﬁnition in an interface block. The statement speciﬁes that the C language
will be used, and it optionally provides a C-compatible name. Here is a Fortran
program, containing the interface block for the system call, that will print the
process ID:
Listing 14.1: Program Pid printer
program
P i d p r i n t e r
i m p l i c i t
none
i n t e r f a c e
function
g e t p i d
()
bind
(C, name=’ getpid ’ )
!
minic C typedef :
rename C INT
p i d t
use
iso c binding ,
only :
p i d t => C INT
i m p l i c i t
none
integer ( kind=p i d t )
: :
g e t p i d
end
function
g e t p i d
end
i n t e r f a c e
Cambridge Books Online © Cambridge University Press, 2012

264
MODERN FORTRAN
p r i n t
* ,
’ pid
i s : ’ ,
g e t p i d
()
end program
P i d p r i n t e r
Mapping External Names – Invoking Fortran from C In a similar manner,
Fortran code is made interoperable with C. Here is a subroutine, Fortran FFT,
that is called by C, the prototype that needs to be provided to the C program,
and the C program itself:
Listing 14.2: Subroutine Fortran FFT
subroutine
Fortran FFT
( data array ,
a r r a y s i z e , &
d i r e c t i o n )
bind
(C, name=’Fortran FFT ’ )
use
iso c binding ,
only : C DOUBLE COMPLEX,
C INT , &
C CHAR
i m p l i c i t
none
!
assumed
s i z e
a r r a y
( 0 : * )
whose
lower
bound
i s
0
!
must be
used
with C.
complex ( kind=C DOUBLE COMPLEX) ,
intent ( in
out ) ,
: : &
d a t a a r r a y ( 0 : * )
integer
( kind=C INT ) ,
intent
( in )
: :
a r r a y s i z e
character
( kind=C CHAR) ,
intent
( in )
: :
d i r e c t i o n
!
. . .
compute FFT
p r i n t
* , ” f i r s t
element :
” ,
d a t a a r r a y (1)
end subroutine
Fortran FFT
#i f
! d e f i n e d
(FORTRAN FFT H)
#define FORTRAN FFT H
void
Fortran FFT
( double
Complex * data array ,
i n t
* a r r a y s i z e ,
char * d i r e c t i o n ) ;
#endif
#include
” Fortran FFT . h”
#include <complex . h>
#define N 1024
i n t
main
()
{
double
Complex
my data [N ] ;
i n t
a r r a y s i z e = N;
char
forward = ’ f ’ ;
Cambridge Books Online © Cambridge University Press, 2012

C INTEROPERABILITY
265
for
( i n t
i =0;
i <N;
i++)
my data [ i ] = ( f l o a t )
i + I
* ( f l o a t )
i /100.0 f ;
Fortran FFT
( my data , &a r r a y s i z e , &forward ) ;
}
The output for this program is:
first element:
(0.000000000000000,0.000000000000000)
Mapping Pointers Fortran pointers, which are data types, are mapped to C
pointers, which are addresses, by ﬁrst declaring the C pointer in the Fortran
code to be of derived type C PTR, which is deﬁned in iso c binding . The
pointers are then converted by calls to pointer conversion procedures, also
deﬁned in iso c binding . The C and Fortran code that follows shows an
example:
#include < s t d l i b . h>
i n t
* c a l l o c a t e ( i n t
n )
{
i n t
* ptr ,
i ;
ptr = ( i n t
*) malloc ( n* s i z e o f ( i n t ) ) ;
for
( i =0;
i <n ;
i++)
ptr [ i ] = i ;
p r i n t f ( ” c a l l o c a t e :
n = %d\n” , n ) ;
return
ptr ;
}
Listing 14.3: Program c f pointer test
program
c f p o i n t e r t e s t
use ,
i n t r i n s i c
: :
iso c binding , &
only
:
c f p o i n t e r ,
C INT , C PTR
i m p l i c i t
none
i n t e r f a c e
function
c a l l o c a t e ( n )
bind (C, name=” c a l l o c a t e ” )
import
: :
C PTR,
C INT
i m p l i c i t
none
type (C PTR)
: :
c a l l o c a t e
integer (C INT ) ,
value
: :
n
end
function
c a l l o c a t e
end
i n t e r f a c e
integer ,
parameter
: : ROWS=16, COLS=24
integer (C INT ) ,
pointer ,
contiguous
: :
f o r t p t r ( : , : )
Cambridge Books Online © Cambridge University Press, 2012

266
MODERN FORTRAN
type (C PTR)
: :
c p t r
integer (C INT)
: :
g r i d s i z e
g r i d s i z e = ROWS * COLS
c p t r = c a l l o c a t e
( g r i d s i z e )
!
e s t a b l i s h
p o i n t e r
a s s o c i a t i o n .
c a l l
c f p o i n t e r
( cptr ,
f o r t p t r ,
[ROWS, COLS ] )
p r i n t
* , ”
s i z e =” ,
s i z e
( f o r t p t r ,
dim=1) , &
s i z e
( f o r t p t r ,
dim=2)
p r i n t
* , ” second
column ,
f i r s t
row :
” ,
f o r t p t r (1 ,
2)
end program
c f p o i n t e r t e s t
The output is the following:
c_allocate: n = 384
size = 16 24
second column, first row:
16
Keep in mind that with arrays of rank greater than 1, the leftmost subscript
varies ﬁrst (columnwise storage for rank 2) in Fortran, whereas the rightmost
subscript varies ﬁrst (rowwise storage for rank 2) in C (see Rule 97).
Mapping Derived Types and Structs Fortran derived types that need to
be compatible with C structs in the companion C compiler are deﬁned by
specifying the bind(C) attribute when deﬁning the derived type. Here is an
example of a C struct and the derived type:
typedef
struct
{
char
plant name [ 7 0 ] ;
Bool
deciduous ;
char
genus [ 3 2 ] ;
}
p l a n t t ;
use
iso c binding ,
only : C CHAR, C BOOL
. . .
type ,
bind (C)
: :
p l a n t t
character
( kind=C CHAR)
: :
plant name (70)
l o g i c a l
( kind=C BOOL)
: :
deciduous
character
( kind=C CHAR)
: :
genus (32)
end type
p l a n t t
Mapping Global Data The bind(C) attribute allows the interoperability of
module variables in Fortran and variables in C. Changing the value of the
variable in one location changes the other. Here is an example:
Cambridge Books Online © Cambridge University Press, 2012

C INTEROPERABILITY
267
!
s p e c i f y
the name
f o r
a l l
mixed−case
v a r i a b l e
names .
integer (C INT ) ,
bind (C, name=” G r i d S i z e ” )
: :
G r i d S i z e
i n t
G r i d S i z e ;
178. Pass Fortran character arguments to C as length-1, character arrays
with a ﬁnal element of C CHAR NULL.
C does not support strings of characters. Instead, it only supports arrays of
single characters, the last element of which is the constant NULL. You can
map a Fortran character data type to a C char data type by declaring it kind
C CHAR, and by placing the C NULL CHAR at the end of the string. The
named constants
C CHAR and
C NULL CHAR are available in the
iso c binding module. Here is a short program showing this:
Listing 14.4: Program Char test
program
C h a r t e s t
use
iso c binding ,
only : C CHAR, C NULL CHAR
i m p l i c i t
none
i n t e r f a c e
subroutine
c r o u t i n e
( s t r i n g ) &
bind
(C, name=’ c r o u t i n e ’ )
import C CHAR
i m p l i c i t
none
character ( kind=C CHAR) ,
intent ( in )
: :
s t r i n g (*)
end subroutine
c r o u t i n e
end
i n t e r f a c e
integer
: :
f s t r i n g l e n ,
a l l o c s t a t ,
i c h a r
character ( len =:) ,
a l l o c a t a b l e
: :
f s t r i n g
character ( kind=C CHAR, len =:) ,
a l l o c a t a b l e
: :
c s t r i n g ( : )
!
Convert a
c h a r a c t e r
s t r i n g
i n t o
an
a r r a y
of
!
c h a r a c t e r s ,
terminated
with
a
n u l l
s e n t i n e l
!
c h a r a c t e r .
f s t r i n g
= ” h e l l o C world ”
f s t r i n g l e n = l e n t r i m
( f s t r i n g )
a l l o c a t e
( character ( kind=C CHAR,
len =1)
: : &
c s t r i n g ( f s t r i n g l e n + 1) ,
stat=a l l o c s t a t )
f o r a l l
( i c h a r = 1:
f s t r i n g l e n ) &
c s t r i n g ( i c h a r ) = f s t r i n g ( i c h a r :
i c h a r )
end
f o r a l l
c s t r i n g ( f s t r i n g l e n + 1) = C NULL CHAR
Cambridge Books Online © Cambridge University Press, 2012

268
MODERN FORTRAN
c a l l
c r o u t i n e
( c s t r i n g )
end program
C h a r t e s t
#include <s t d i o . h>
#include <s t r i n g . h>
void
c r o u t i n e
( char * s t r i n g ) {
p r i n t f
( ” c r o u t i n e :
l e n g t h = %i \n” ,
( i n t )
s t r l e n
( s t r i n g ) ) ;
p r i n t f
( ” c r o u t i n e :
t e x t = %s \n” ,
s t r i n g ) ;
}
179. Pass scalar arguments by value when using C interoperability.
C supports a “call by value” calling sequence where a copy of scalar arguments
is passed to the called procedure (see Rule 54). In the example in Rule 177,
showing a program written in C calling a subroutine written in Fortran, the
Fortran code is generating, and passing, pointers to data array, array size ,
and direction as the call-by-value arguments. On the C side, the pointers
need to be dereferenced by the code. For simple scalar arguments, it may be
desirable to pass the values themselves, rather than pointers. Fortran supports
the value attribute to allow this. Here is the Fortran interface and C prototype
using value arguments:
subroutine
Fortran FFT
( data array ,
a r r a y s i z e , &
d i r e c t i o n )
bind
(C, name=’Fortran FFT ’ )
use
iso c binding ,
only : C DOUBLE COMPLEX, &
C INT , C CHAR
i m p l i c i t
none
!
assumed
s i z e
a r r a y
(*)
must be
used
with C.
complex ( kind=C DOUBLE COMPLEX) ,
intent ( in
out ) ,
: : &
d a t a a r r a y (*)
integer
( kind=C INT ) ,
intent ( in ) ,
value
: : &
a r r a y s i z e
character ( kind=C CHAR) ,
intent ( in ) ,
value
: :
d i r e c t i o n
end subroutine
Fortran FFT
In the prototype the array size and direction arguments would not be point-
ers.
void
Fortran FFT
( double
Complex * data array ,
i n t
a r r a y s i z e ,
char
d i r e c t i o n ) ;
This method has two advantages: simplicity – a pointer does not need to be
generated, and dereferencing is not required; safety – the called procedure
operates solely on its own copy of the argument. It does not modify the caller’s
argument.
Cambridge Books Online © Cambridge University Press, 2012

C INTEROPERABILITY
269
180. Design out potential “buffer overrun” problems.
With C interoperability, array arguments must be declared as assumed-size;
assumed-shape arrays cannot be used. There is no built-in mechanism for pass-
ing the number of elements in the array. If the array possesses the intent (out)
or the intent (in out) attribute, that is, one to whose elements values will
be assigned, relying on an array that is “big enough” without knowing the
exact size of the array can be problematic. The program may inadvertently
write beyond the last element, an event called a “buffer overrun.” To avoid
this problem, always pass in a separate argument the size of the array. That
way, you can write code to prevent this from taking place. Here is an interface
that has the bind(C) attribute. The elements of the array argument buﬀer will
be assigned in readstring . The length of buﬀer is passed in argument buf len
so that code that monitors the assignments to the elements of buﬀer can be
written in readstring.
subroutine
r e a d s t r i n g
( buffer ,
buf len ,
at end )
&
bind
(C, name=’ r e a d s t r i n g’)
use
iso c binding ,
only
: : C CHAR,
C INT , C BOOL
i m p l i c i t
none
character ( kind=C CHAR) ,
intent ( in
out )
: :
b u f f e r (*)
integer
( kind=C INT ) ,
intent ( in ) ,
value
: :
b u f l e n
l o g i c a l
( kind=C BOOL) ,
intent ( out ) ,
value
: :
at end
end subroutine
r e a d s t r i n g
end
i n t e r f a c e
181. Use extern "C" in C++ ﬁles to allow interoperability with Fortran.
The C++ programming language (Reference [73]) is mostly a super-set of C. It
supports many advanced features, including full object-oriented capabilities,
exception handling, and templates (a method for writing generic code). Fortran
only supports interoperability with the C subset of C++. With limitations,
however, interoperability between C++ and Fortran is possible.
Due to the characteristics of C++, and the system by which procedures are
assigned names, called “name mangling,” you should use the extern ”C”
reserved word to specify that C is the style of external naming within the block
of code associated with it.
A second standard feature that assists in the process is the
cplusplus macro
that is built into the preprocessor. By using this macro, the C++ extern ”C”
capability may be used during C++ compilations, and ignored during C com-
pilations. This allows one header ﬁle to serve both compilation styles:
#i f
! d e f i n e d
(FORTRAN FFT H)
#define FORTRAN FFT H
#i f
d e f i n e d
(
c p l u s p l u s )
Cambridge Books Online © Cambridge University Press, 2012

270
MODERN FORTRAN
extern ”C” {
#endif
void
Fortran FFT
( double
Complex * array , &
i n t
a r r a y s i z e ,
char
d i r e c t i o n ) ;
#i f
d e f i n e d
(
c p l u s p l u s )
}
#endif
182. Do not throw C++ exceptions through Fortran procedures.
When using the C interoperability, the C++ exception handling capability
should not be used. While it may be possible to use exception handling
within the conﬁnes of the C++ code itself, throwing an exception that requires
unwinding the call stack through a Fortran-compiled routine may cause prob-
lems. In particular, automatic and allocatable arrays may not be deallocated,
and ﬁnal procedures may not be invoked. (A similar situation exists with
setjmp and longjmp in C code.)
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

15.
Updating Old Programs
Over the years, the Fortran standards committee has striven to keep each new
standard backward-compatible with previous releases. Fortran is one of the
oldest high-level languages; much old code is still in use. The committee has
admirably succeeded, and programmers have known that they could continue
to write programs that contained old features and that they could add features
of the new standards whenever it was convenient, useful, or appropriate. Each
new standard has marked only a few old features as “obsolescent,” deﬁned
as “A feature that is considered redundant but that is still in frequent use.”
Those so marked in one standard may be “deleted” in a subsequent one.
The standard describes a “deleted” feature as “A feature in a previous Fortran
standard that is considered to have been redundant and largely unused.” This
chapter describes many of these old features and the new ones provided by the
modern Fortran standards (meaning from Fortran 90 and on) that you can
use to replace them. We note the status of the each old feature. For further
details, see the appropriate language standard: Fortran 90, Reference [40];
Fortran 95: Reference [42]; Fortran 2003, Reference [39]; and Fortran 2008,
Reference [43].
15.1 Statements
183. Replace common blocks with modules.
In FORTRAN 66 and FORTRAN 77, programmers stored global data in
common blocks. A program could have one unnamed common block and any
number of named blocks. Here is an example of the latter:
INTEGER NNODES
PARAMETER (NNODES = 100)
DOUBLE PRECISION DPOS(NNODES)
INTEGER NODEID(NNODES)
COMMON /NODES/ DPOS, NODEID
SAVE /NODES/
For ease of maintenance, the normal practice was to place such code in a
separate ﬁle and then to use an include statement to embed it in all program
units that needed access to it. Because include was not standardized until
Fortran 90, preprocessing was commonly used for compilers that did not
271
Cambridge Books Online © Cambridge University Press, 2012

272
MODERN FORTRAN
support it. If the previous code was in a ﬁle called NODECOM.COM, you
would see statements such as this in program units:
INCLUDE
’NODECOM.COM’
Blank common was indicated by either two consecutive forward slashes (//) or
by no slashes:
COMMON // A, B, D
. . .
COMMON A, B, D
Starting with Fortran 90, all common blocks should be replaced with modules.
The following is a module equivalent for the data in COMMON block NODES.
You access this module in every program unit that requires access to the
variables with the use statement.
module node common mod
i m p l i c i t
none
integer ,
parameter
: : NNODES
= 100
integer ,
parameter
: : WORK PREC = &
s e l e c t e d r e a l k i n d
(15 ,
307)
integer ,
save
: :
node id (NNODES)
r e a l
(WORK PREC) ,
save
: :
d pos (NNODES)
end module node common mod
If you are charged with updating an old program containing common blocks,
the ﬁrst step is to ensure that all occurrences of each common block are the
same in every program unit. To accomplish that, place each common block
in a separate ﬁle, remove all cases where common blocks are explicitly entered
in the code and replace all such cases with include statements. Recognizing
that common blocks may be placed inside modules, the next step is to copy
each named common block into its own module. Then use this module
in every program unit where the common block is used and eliminate the
corresponding include statement.
module node common mod
i m p l i c i t
none
INTEGER NNODES
PARAMETER (NNODES = 100)
DOUBLE PRECISION D POS(NNODES)
INTEGER NODE ID(NNODES)
COMMON /NODES/ D POS , NODE ID
SAVE /NODES/
end module node common mod
The ﬁnal steps are to remove the common and save statements from the
module and then to rewrite the code as shown previously.
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
273
184. Remove block data program units. Use initializers with module scope
data.
To initialize variables in common blocks, you would use block data program
units (see Rule 183).
BLOCK DATA EC
INTEGER NOCOEF
PARAMETER (NOCOEF = 14)
REAL ECOEFS(NOCOEF)
COMMON /COEFS/ ECOEFS
DATA ECOEFS /NOCOEF * 0.0/
END BLOCK DATA EC
When the variables are deﬁned at module scope, normal initializers may be
used, thereby making block data unnecessary:
module coefs mod
i m p l i c i t
none
integer ,
parameter
: :
NUM COEFFICIENTS = 14
r e a l
: :
e c o e f s (NUM COEFFICIENTS) = 0.0
end module coefs mod
185. Replace multiple entry point procedures with separate module pro-
cedures that can share data scope.
The entry statement, as its name implies, provided an alternative entry point
into a procedure. If you used two or more separate subroutines instead of one
subroutine with entry points, you most likely would have needed to deﬁne
data entities multiple times. With entry statements in a subroutine, you would
deﬁne entities such as local variables and possibly dummy arguments only once.
All code would have access to any entities that had the save attribute. Sections
of code in the procedure could be shared, while others could be skipped during
execution.
In this following example, you would call subroutine CALSLO if you needed to
check the size of the argument NEWDAT and to call the subroutine DATCHK
(not shown); otherwise, you called the entry point CALFST. The subroutine
PDAT (not shown) processes the data.
Listing 15.1: SUBROUTINE CALSLO
SUBROUTINE CALSLO (NEWDAT, N, RETERR)
IMPLICIT NONE
INTEGER N
REAL
NEWDAT(N)
Cambridge Books Online © Cambridge University Press, 2012

274
MODERN FORTRAN
INTEGER RETERR
INTEGER MAXDAT
PARAMETER (MAXDAT = 200)
LOGICAL DATOK
REAL HISDAT(MAXDAT)
SAVE HISDAT
RETERR = 0
C
CHECK INPUT
IF
(N .GT. MAXDAT) THEN
RETERR = 1
GO TO 90
END IF
C
CHECK AGAINST HISDAT .
CALL DATCHK (NEWDAT, N, HISDAT , DATOK)
IF
( .NOT. DATOK) THEN
RETERR = 2
GO TO 90
END IF
GO TO 10
ENTRY CALFST (NEWDAT, N)
C
PROCESS NEWDAT
10
CALL PDAT (NEWDAT, HISDAT)
90
CONTINUE
END SUBROUTINE
To replace entry statements, you could create a module. Declare the variables
that have the save attribute before the contains statement. This makes their
scope the entire module as shown in the next example. One way to convert
the code is to write two distinct module subprograms:
Listing 15.2: Module data mod
module Data mod
i m p l i c i t
none
integer ,
parameter
: : MAX DAT = 200
real ,
save
: :
h i s d a t (MAX DAT)
!
r e t u r n
codes .
enum ,
bind (C)
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
275
enumerator
: :
CALSLO SUCCESS = 0 , CALSLO BAD SIZE , &
CALSLO BAD DATA
end enum
!
Declare
a
g e n e r i c
i n t e r f a c e
to
both
r o u t i n e s .
i n t e r f a c e
Calc dat
module procedure
Calslo ,
C a l f s t
end
i n t e r f a c e
Calc dat
contains
subroutine
C a l s l o
( newdat ,
r e t e r r )
real ,
intent
( in
out )
: :
newdat ( : )
integer ,
intent
( out )
: :
r e t e r r
l o g i c a l
: :
datok
r e t e r r = CALSLO SUCCESS
!
check
a r r a y
s i z e ;
p r o c e s s
and
r e p o r t
e r r o r s .
i f
( s i z e
( newdat ) > MAX DAT)
then
r e t e r r = CALSLO BAD SIZE
e l s e
c a l l
Datchk
( newdat ,
datok )
i f
( . not .
datok )
then
r e t e r r = CALSLO BAD DATA
e l s e
c a l l
C a l f s t ( newdat )
end
i f
end
i f
end subroutine
C a l s l o
subroutine
C a l f s t
( newdat )
real ,
intent
( in
out )
: :
newdat ( : )
c a l l
Pdat
( newdat ,
h i s d a t )
end subroutine
C a l f s t
end module Data mod
As an alternative to breaking the procedure into two separate ones, you could
use a single procedure, add a variable to its argument list, and branch to the
appropriate code based on its value.
The Fortran 2008 standard degrades the ENTRY statement to be an obsoles-
cent feature.
186. Replace alternate returns with structured code.
The alternate return feature allowed you to specify that, on return from a
subroutine, program execution branch to a speciﬁc labeled statement instead
of proceeding normally with the next sequential executable one. You could
Cambridge Books Online © Cambridge University Press, 2012

276
MODERN FORTRAN
accomplish this by specifying labels, preceded by an asterisk, as actual argu-
ments in the subroutine call. In the called procedure, the dummy arguments
corresponding to the labels were indicated with asterisks. You speciﬁed the
label of the branch desired on return using the return statement followed by
an integer indicating the ordinal position of the alternate return, that is, the
statement return 1 caused the program to branch to the ﬁrst alternate return
label, return 2 to the second, and so forth. As an example, here, in outline
form, is a call to a subroutine with alternate return arguments:
CALL INTSCT (ORIG , VECT, PLANE, INTPNT,
+
*100 ,
*200)
GO TO 500
100
CONTINUE
CALL LOGERR ( ” I n t e r s e c t :
p a r a l l e l ” )
GO TO 500
200
CONTINUE
CALL LOGERR ( ” I n t e r s e c t :
no
i n t e r s e c t ” )
C
CONTINUING NORMAL EXECUTION
500
CONTINUE
SUBROUTINE INTSCT (PT, VEC, PLANE, INTER ,
* ,
*)
REAL PT(3) , VEC(3) , PLANE (3 ,
3) , INTER(3)
INTEGER CALSTA
CALL PARLEL (PT, VEC, PLANE, CALSTA)
C
! RETURN AND BRANCH TO LABEL 100
IF
(CALSTA /= 0) RETURN 1
CALL CALINT (PT, VEC, PLANE, INTER , CALSTA)
C
! RETURN AND BRANCH TO LABEL 200
IF
(CALSTA /= 0) RETURN 2
C
! RETURN TO NORMAL EXECUTION
RETURN
END SUBROUTINE
You can easily replace alternate returns by returning an integer variable from
the called subroutine and then use a select case construct to execute the
desired code:
enum ,
bind (C)
enumerator
: :
PARAL = 1 , NO INTERSECT
end enum
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
277
c a l l
I n t e r s e c t
( orig ,
vect ,
plane ,
intpnt ,
r e t u r n s t a t )
s e l e c t
case
( r e t u r n s t a t )
case
(PARAL)
c a l l
L o g e r r o r
( ” I n t e r s e c t :
p a r a l l e l ” )
case
(NO INTERSECT)
c a l l
L o g e r r o r
( ” I n t e r s e c t :
no
i n t e r s e c t ” )
case
default
. . . normal
e x e c u t i o n
end
s e l e c t
The alternate return feature was ﬁrst designated an obsolescent feature in
Fortran 90, and it remains one in both Fortran 2003 and Fortran 2008.
187. Replace arithmetic if statements with case or block if constructs.
The arithmetic if statement speciﬁed three different branches for the contin-
uation of program execution. It accomplished this with three statement labels
that corresponded to the location to which the program would branch if the
value of a numeric expression was less than, was equal to, or was greater than
0.
IF
(INT ( x ))
10 ,
20 , 30
10
PRINT * , ” l e f t
hemisphere ”
GO TO 40
20
PRINT * , ” near
a x i s ”
GO TO 40
30
PRINT * , ”RIGHT HEMISPHERE”
40
CONTINUE
Use instead an if −elseif−else−endif or select case construct
i f
( abs
( x ) < e p s i l o n )
then
p r i n t
* , ” near
a x i s ”
e l s e
i f
( x < 0 . 0 )
then
p r i n t
* , ” l e f t
hemisphere ”
e l s e
p r i n t
* , ” r i g h t
hemisphere ”
end
i f
The Fortran 90 standard declared the arithmetic if statement an obsolescent
feature; both the Fortran 2003 and the Fortran 2008 standards continue to
do so.
188. Replace computed GOTO statements with case constructs.
You could use the computed GOTO statement to branch to different parts of
a program according to the value of an integer expression.
DO 100
I = 1 , NELEMS
NCOLOR = INT (
(TEMP( I )/MAXTMP) *
3.0
) + 1
Cambridge Books Online © Cambridge University Press, 2012

278
MODERN FORTRAN
NCOLOR = MIN0 (MAX0 (NCOLOR,
1) ,
3)
GO TO (10 ,
30 ,
50) , NCOLOR
10
COLOR( I ) = BLACK
GO TO 100
30
COLOR( I ) = GREEN
GO TO 100
50
COLOR( I ) = RED
GO TO 100
100 CONTINUE
The most logical replacement for this feature is the select case construct.
do
i = 1 ,
number of elements
n c o l o r = i n t
(
( temp ( i ) / max temp ) *
3.0
) + 1
n c o l o r = min (max ( n color ,
1) ,
3)
s e l e c t
case
( n c o l o r )
case
(1)
c o l o r ( i ) = BLACK
case
(2)
c o l o r ( i ) = GREEN
case
( 3 : )
c o l o r ( i ) = RED
case
default
end
s e l e c t
end do
This feature was ﬁrst declared an obsolescent one in the Fortran 95 standard
and continues to be so in the standard for both Fortran 2003 and Fortran 2008.
189. Replace assigned GOTO with structured constructs.
The assigned GOTO statement allowed you to assign a label number to an
integer variable and then to branch to that label from a particular form of the
GOTO statement.
INTEGER ISTAGE ,
FAIL PHASE 1 ,
FAIL PHASE 2 ,
+
SUCCESS
PARAMETER ( FAIL PHASE 1=20, FAIL PHASE 2=30,
+
SUCCESS=100)
ASSIGN SUCCESS TO ISTAGE
CALL PHASE1 (N, DAT, RETVAL)
IF
(RETVAL .NE.
0) THEN
ASSIGN FAIL PHASE 1 TO ISTAGE
GO TO 10
END IF
CALL PHASE2 (N, DAT, RETVAL)
IF
(RETVAL .NE.
0) THEN
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
279
ASSIGN FAIL PHASE 2 TO ISTAGE
GO TO 10
END IF
10 GO TO ISTAGE ( FAIL PHASE 1 ,
FAIL PHASE 2 ,
+ SUCCESS)
20
PRINT * , ”PHASE1
f a i l e d ”
PRINT * , ”no
r e c o v e r y ”
GO TO 100
30
PRINT * , ”PHASE2
f a i l e d ”
PRINT * , ” use PHAS3A”
CALL PHAS3A (N, DAT)
GO TO 100
100 CONTINUE
As shown in the following short example, you can use a select case construct
in place of this feature.
enum ,
bind (C)
enumerator
: :
FAIL PHASE 1 = 1 , FAIL PHASE 2
end enum
i s t a g e = 0
c a l l
Phase1
(n ,
dat ,
r e t v a l )
i f
( r e t v a l /= 0)
then
i s t a g e = FAIL PHASE 1
e l s e
c a l l
Phase2
(n ,
dat ,
r e t v a l )
i f
( r e t v a l /= 0)
i s t a g e = FAIL PHASE 2
end
i f
s e l e c t
case
( i s t a g e )
case
( FAIL PHASE 1 )
p r i n t
* , ”Phase1
f a i l e d ”
p r i n t
* , ”no
r e c o v e r y ”
case
( FAIL PHASE 2 )
p r i n t
* , ”Phase2
f a i l e d ”
p r i n t
* , ” use
Phas3a”
c a l l
Phas3a
(n ,
dat )
case
default
end
s e l e c t
In cases where the assigned GOTO was used to emulate internal procedures,
simply use internal procedures.
The Fortran 90 standard declared this feature an obsolescent one; beginning
with the Fortran 95, it has been a deleted feature.
Cambridge Books Online © Cambridge University Press, 2012

280
MODERN FORTRAN
190. Replace statement functions with internal procedures.
Statement functions were a single-line of code, an assignment that accepted
arguments, performed a calculation, and returned a value. You needed to
place them in a program unit after the speciﬁcation statements, but before the
executable ones.
Here, as an example, is the code to calculate the local curvature of a curve,
given the ﬁrst and the second derivatives of its y-coordinate with respect to its
x-coordinate:
CURV (YP,YPP) = YPP /
( ( 1 . 0 + YP * YP) *
+
SQRT ( 1 . 0 + YP * YP)
)
Throughout the program unit, you could refer to the function in this manner:
LCURV = CURV (DER1, DER2)
To replace a statement function, write an internal function.
subroutine
Some subroutine
()
. . .
l c u r v = . . .
curv
( der1 ,
der2 )
. . .
contains
function
curv
( yp ,
ypp )
r e s u l t
( r e t v a l )
real ,
intent
( in )
: :
yp ,
ypp
r e a l
: :
r e t v a l
r e t v a l = ypp / (
( 1 . 0 + yp * yp ) * &
sqrt
( 1 . 0 + yp * yp )
)
end
function
curv
end subroutine
Some subroutine
From the Fortran 95 standard on, statement functions have been an obsolescent
feature.
191. Replace PAUSE statements with normal I/O and stop statements.
You could use the PAUSE statement to suspend the execution of a program.
It then waited for operator intervention in some processor-deﬁned way.
PAUSE ’REMOVE TAPE 1 , MOUNT TAPE 2 ’
This capability was rarely used. The standards committee declared it an obso-
lescent feature beginning with FORTRAN 77 and a deleted one beginning
with Fortran 95. If needed, you can accomplish the same end by writing a
statement to standard output and reading from standard input:
character
( len =1)
: :
temp char
write
(* , ” ( a ) ” ,
advance = ”no” ) &
” Terminate
o p e r a t i o n ?(Y/N) : ”
read
(* ,
*)
temp char
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
281
192. Use the character (length-selector) form to declare all character vari-
ables, arrays, and named constants.
Two old forms of declaring a variable, an array, or a named constant of intrinsic
type character exist. You could specify the number of characters by appending
an asterisk and the number to the keyword CHARACTER, or to the variable
itself:
CHARACTER*80 FILE LINE , ERROR MESSAGE*40
Instead, declare character data objects like this:
character ( len =80)
: :
f i l e
l i n e
character ( len =40)
: :
error message
193. Replace double precision or any other type declaration that explicitly
speciﬁes the storage size, with kind speciﬁcations.
The standard requires that the processor provide two distinct ﬂoating-point
intrinsic data types. One corresponds to the speciﬁcation real; the second
is of greater precision, and you can use the speciﬁcation double precision to
specify it. There was also a manner in which the exponent letter D replaced the
exponent letter E, to express a literal constant of the corresponding precision.
An example would be 1.0D0. Typically, a real type occupied four eight-bit
bytes of memory, and the double precision type twice as much (see Section
13.1).
In addition to this speciﬁcation, which was, and still is, part of the standard,
compiler vendors often added the capability of declaring the type of ﬂoating
point, integer, and logical data objects by appending an asterisk followed by
the number of bytes to the type speciﬁcation. This method is not standard but
is widely supported. Here are declarations for a two-byte integer, a one-byte
logical, and a double precision real variable:
INTEGER*2 ICOUNT
LOGICAL*1 GOODNO
REAL*8
VELOC
You should not use these statements to declare data objects. Rule 170 contains
the rules for establishing the precision of data objects using the intrinsic
functions selected real kind and selected int kind .
194. Do not use real or double precision do variables.
FORTRAN 77 permitted ﬂoating-point variables to be used as the do variable
in do loops.
REAL A, TURB, MAT(100 ,20)
DO 100 A = 0.0 ,
1.0 ,
0.000001
CALL CALTUR (MAT, INP ,A,TURB)
100 CONTINUE
Cambridge Books Online © Cambridge University Press, 2012

282
MODERN FORTRAN
Rounding errors can cause an unintended number of iterations to be executed.
This code should now be written as follows:
r e a l
: :
a ,
turb ,
mat (100 ,20)
integer
: :
i
do
i = 0 ,
1000000
a = r e a l
( i
* 0.000001 ,
kind
( a ))
c a l l
CalTur
(mat ,
inp ,
a ,
turb )
end do
The standards committee made the use of ﬂoating-point variables as do vari-
ables an obsolescent feature in Fortran 90.
15.2 Techniques
195. Replace Hollerith constants with character data type.
Prior to FORTRAN 77, there was no character data type. Numeric variables,
usually integers, were used to hold ﬁelds of characters. Hollerith constants
were “typeless” constants that could be used in a DATA statement to initialize
a numeric variable with characters. Because of the differences in integer sizes
on different computer systems, a numeric variable could hold anywhere from
two to ten characters. This led to portability problems. The following assumes
a computer with four characters per integer:
INTEGER HELLO(3)
DATA HELLO/4HHELL,4HO WO,4HRLD./
. . .
WRITE (6 ,100) HELLO
100 FORMAT (3A4)
Replace this with:
character (12)
: :
h e l l o = ’ h e l l o
world . ’
. . .
write
(* ,
’( a ) ’ )
h e l l o
Hollerith constants were also allowed as actual arguments in procedure calls.
An array was used as a dummy argument:
CALL PRINTR (3 ,
12HHELLO WORLD. )
. . .
SUBROUTINE PRINTR (NWORDS, STRING)
INTEGER NWORDS, STRING(NWORDS)
Replace this with:
c a l l
p r i n t e r
( ’ h e l l o
world ’ )
. . .
subroutine
p r i n t e r
( s t r i n g )
character (*) ,
intent ( in )
: :
s t r i n g
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
283
The previous example illustrates that in larger programs where integer vari-
ables containing Hollerith data are being passed between procedures, such
as through argument lists or common blocks, interfaces are being changed.
Because of this, a stepwise approach must be made to code conversion. It is
recommended that all procedures ﬁrst be placed into modules, and common
blocks converted to module form (see Rule 183). Then, as variables are con-
verted to character, the compiler will quickly be able to ﬁnd any problem
areas when checking subprocedure interfaces.
196. Replace Hollerith, H, edit descriptors with quoted strings.
Prior to Fortran 77, the H edit descriptor was the only method to describe
character strings. Here’s an example in a format statement:
WRITE (6 ,
10100) ATOM
10100 FORMAT (5X,
5HATOM: ,
1X, A4 , A2)
This technique was already declared an obsolescent feature in FORTRAN 77,
and the H format descriptor has been a deleted feature starting with Fortran
95. Use either single or double apostrophes as the descriptor for character
strings.
write
(* , ” (5 x ,
2a ) ” )
’Atom :
’ ,
atom
197. Do not branch to an end if statement from outside its block.
The following code, with the branch to a labeled end if statement, was per-
mitted in Fortran 77:
IF
(SHADE) THEN
. . .
IF
(HIDDEN (X, Y)) GO TO 100
GO TO 50
END IF
50
IF
(XMIN . LE . X .AND X . LE . XMAX) THEN
IF
(YMIN . LE . Y .AND. Y . LE . YMAX)
+
CALL SHADING (X, Y)
100
END IF
You can quickly replace this by adding a labeled continue statement immedi-
ately after the end if and branching to it instead (see also Rule 100).
This technique was declared obsolescent in Fortran 90, and further down-
graded to a deleted feature beginning with Fortran 95.
198. Replace nonblock do constructs with block versions.
A nonblock do construct is a do construct that either shares a terminal state-
ment with another do construct or terminates in an action statement instead
of in a continue statement. Here are two examples, one of each type:
Cambridge Books Online © Cambridge University Press, 2012

284
MODERN FORTRAN
DO 50 J = 1 , NCOLS
DO 50
I = 1 , NCOLS
A( I ,
J ) = A( I ,
J ) * B( I )
50 CONTINUE
SUM = 0
DO 50
I = 1 , NNODES
50
SUM = SUM + A( I )
Since the Fortran 90 standard, this technique has been obsolescent. Use a
block do construct, with its paired do and end do statements, in place of the
nonblock form.
15.3 Nonstandard Features
This subsection describes several capabilities that were introduced by speciﬁc
compiler vendors to overcome limitations in earlier versions of Fortran. They
were never part of any standard. When encountered, they should be replaced
with standard conforming code.
199. Replace all decode and encode statements with read and write state-
ments using internal ﬁles.
The encode statement transferred data from internal, that is, binary, form to
character form. The decode statement did the reverse. Here’s an example of
the latter:
CHARACTER*8 CH
REAL X,Y
DATA CH/ ’12.513.3 ’/
DECODE(8 ,
900 , CH) X, Y
PRINT (* ,
910)
’X = ’ , X,
’ , Y = ’ , Y
900
FORMAT(2 F4 . 1 )
910
FORMAT(2(A,
F4 . 1 ) )
The ﬁrst argument, here 8, in the DECODE statement is the number of
characters in the third argument, CH. The label of the FORMAT statement,
900, is the second argument. The transfer is from the character variable to the
two real variables as the FORMAT statement speciﬁes. The variables X and Y
would have the values 12.5 and 13.3 after the program executed the DECODE
statement; therefore, it would print:
X = 12.5 , Y = 13.3
Use the read statement with internal ﬁles to transfer data:
character
( len =8)
: :
ch
r e a l
: :
x ,
y
. . .
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
285
ch = ” 12.513.3 ”
read
( ch ,
” (2 F4 . 1 ) ” ) x ,
y
Here is an example of the encode statement:
INTEGER I ,
J ,
ISAVE , JSAVE
CHARACTER*8 ICH
ENCODE (8 ,
900 , ICH ) ISAVE ,
’ , ’ , JSAVE
WRITE (* ,
910)
’NEG. ELEMENT, ROW, COL: ’ ,
ICH
900 FORMAT ( I3 , A1 ,
I3 )
910 FORMAT (23A,
8A)
The ﬁrst argument for ENCODE is the number of bytes to transfer. Here it is 8
representing two four-byte integers. The second argument is the format label,
and the third argument is the recipient of the data transfer. A typical line of
output would appear as follows:
NEG. ELEMENT, ROW, COL:140 ,130
Use the write statements with internal ﬁles to transfer data. Here the previous
code that used the encode statement is replaced by a write statement to an
internal ﬁle.
integer
: :
i ,
j
character ( len =4)
: :
i c h (2)
write
( i c h (1) ,
” ( i 3 ) ” )
i
write
( i c h (2) ,
” ( i 3 ) ” )
j
write
(* , ” ( a ) ” ) ”Neg .
element ,
row :
” // &
adjustr
( i c h ( 1 ) )
// ” ,
c o l :
” //
adjustr
( i c h ( 2 ) )
200. Replace the BYTE data declarations with the appropriate integer
kind.
The nonstandard BYTE data type could be used to deﬁne a single-byte integer.
In its place use the selected int kind instrinsic function to declare a named
constant for this type of data (see Rule 170):
!
old
byte
data
type
BYTE INT BYTE
!
use
i n s t e a d
integer ,
parameter
: : &
BYTE INTEGER = s e l e c t e d i n t k i n d
(2)
. . .
integer
( kind=BYTE INTEGER)
: :
i n t b y t e
Cambridge Books Online © Cambridge University Press, 2012

286
MODERN FORTRAN
201. Replace structures, records, unions, and maps with derived types.
STRUCTURESs and RECORDs, along with UNIONs and MAPs, constituted a
nonstandard form of data structure whereby heterogeneous data types could
be referred to, and manipulated by name. Structures and records could be
nested. A typical structure could look like this:
C
DEFINE STRUCTURE EMPLOYEE
STRUCTURE /EMPLOYEE/
CHARACTER*20 LASTNAME, FIRSTNAME
INTEGER SSNUMBER
LOGICAL SALARIED
END STRUCTURE
. . .
C
ARRAY OF EMPLOYEES
RECORD /EMPLOYEE/ EMPLOYEES(1000) , WORKER
C
REFER TO EMPLOYEE LAST NAME
I = 20
WORKER = EMPLOYEES( I )
WRITE (* ,
100)
’NO. : ’ ,
I ,
’NAME: ’ , WORKER.LASTNAME
100
FORMAT (A,
I5 , A,
A20)
Derived types should be used instead of structures:
type
employee t
character ( : ) ,
a l l o c a t a b l e
: :
last name ,
f i r s t n a m e
integer
: :
ss number
l o g i c a l
: :
s a l a r i e d
end type
employee t
. . .
type
( employee t )
: :
employees (1000)
i = 20
write
(* , ” (A,
I0 , A) ” ) ”no . : ,
” i ,
”name : ” , &
employees ( i )%last name
Unions, containing maps, created a speciﬁc area of data that could then be
referred to, as indicated previously, by name. However, the map areas within
the union are “overlaid” with one another to conserve storage. In this sense,
unions are much like equivalence. For example, in the following, component
REAL 1 is overlaid with INT 1, and REAL 2 is overlaid with INT 2:
STRUCTURE REALINT
UNION
MAP
REAL REAL 1 ,
REAL 2
END MAP
MAP
INTEGER INT 1 ,
INT 2
Cambridge Books Online © Cambridge University Press, 2012

UPDATING OLD PROGRAMS
287
END MAP
END UNION
END STRUCTURE
There are no direct replacements for unions. One possibility when converting
to standard derived types is to simply not overlay the data components. A
second possiblity is to deﬁne and use extended types:
type
r e a l i n t t
end type
r e a l i n t t
type ,
extends ( r e a l i n t t )
: :
r e a l i n t
r e a l
t
r e a l
: :
r e a l 1 ,
r e a l 2
end type
r e a l i n t
r e a l
t
type ,
extends ( r e a l i n t t )
: :
r e a l i n t
i n t
t
integer
: :
i n t e g e r 1 ,
i n t e g e r 2
end type
r e a l i n t
i n t
t
202. Replace integer pointers with allocatable arrays.
Integer pointers are a nonstandard technique for basing an array to a user-
speciﬁed area of memory. The pointer statement incorporates two pieces of
data: a “pointer” name that is used to set the base address of the array, and the
“pointee” array it is associated with.
Integer pointers were generally used with nonstandard allocation procedures
simply to provide a dynamic memory allocation capability. In many cases,
the code can be modiﬁed to use allocatable arrays, along with the allocate
statement. For example, the following uses a nonstandard allocator called
“MALLOC.” In the following declaration, PARRAY is the pointer and contains
an integer address; the rank-1 array ARRAY is the pointee:
REAL ARRAY(1)
POINTER (PARRAY, ARRAY)
EXTERNAL MALLOC
INTEGER MALLOC
. . .
PARRAY = MALLOC (1234*4)
In modern Fortran, you should use Fortran allocatable arrays:
real ,
a l l o c a t a b l e
: :
a r r a y ( : )
. . .
a l l o c a t e
( a r r a y (1234))
When allocation mechanisms outside the Fortran standard are needed, such as
the need to reference data in a shared memory area, the c f pointer intrinsic
subroutine in intrinsic module iso c binding may be useful (see Rule 177).
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

Appendix A
Source Code
A.1 Type bound demo
Listing 1.1: Program Type bound demo
module Pt2d mod
!
Purpose :
Module
f o r
type
Pt2d t
i m p l i c i t
none
private
public
: :
operator (==)
type ,
public
: :
pt2d t
private
r e a l
: :
x = 0.0 ,
y = 0.0
contains
procedure
: :
G e t l e n => Comp dist
procedure
: :
Get coord
procedure
: :
G e t x y c o o r d p a i r
procedure
: :
P r i n t p t
procedure
: :
Set => Set coords
generic
: :
Get => G e t x y c o o r d p a i r ,
Get coord
generic
: :
Print => P r i n t p t
end type
pt2d t
!
*Cmnt−1: Argument
parameter
f o r
c a l l s
to
!
Get coord .
type ,
public
: :
c o o r d s p e c t
integer
: :
coord
end type
c o o r d s p e c t
type
( c o o r d s p e c t ) ,
public ,
parameter
: : &
X COORD = c o o r d s p e c t
(1) , &
Y COORD = c o o r d s p e c t
(2)
i n t e r f a c e
operator (==)
module procedure
Coord spec eq
end
i n t e r f a c e
289
Cambridge Books Online © Cambridge University Press, 2012

290
SOURCE CODE
character (*) ,
parameter
: : &
MOD HEAD = ” C a l l e e :
Module pt2d mod :
” , FA = ” (A) ”
contains
function
Coord spec eq
( t h i s ,
that )
r e s u l t
( r e t e q l )
type
( c o o r d s p e c t ) ,
intent
( in )
: :
t h i s ,
that
l o g i c a l
: :
r e t e q l
r e t e q l = t h i s%coord == that%coord
end
function
Coord spec eq
function
Comp dist
( pt 1 ,
pt 2 )
r e s u l t
( r e t v a l )
!
*Cmnt−4:
o v e r r i d d e n
f o r
some
i n s t a n c e s
i n
!
module pt3d mod .
See *Cmnt−5
c l a s s
( pt2d t ) ,
intent
( in )
: :
pt 1 ,
pt 2
r e a l
(
kind
( pt 1%x )
)
: :
r e t v a l
r e a l
(
kind
( pt 1%x )
)
: :
x d i s t ,
y d i s t
write
(
* , FA) MOD HEAD // ” Comp dist ”
x d i s t = pt 1%x −pt 2%x
y d i s t = pt 1%y −pt 2%y
r e t v a l = sqrt
(( x d i s t
** 2) + ( y d i s t
**
2))
end
function
Comp dist
function
Get coord
( t h i s ,
mold )
r e s u l t
( r e t v a l )
c l a s s
( pt2d t ) ,
intent
( in )
: :
t h i s
type
( c o o r d s p e c t ) ,
intent
( in )
: :
mold
r e a l
(
kind
( t h i s%x )
)
: :
r e t v a l
write
(* , FA) MOD HEAD // ” Get coord ”
!
*Cmnt−3 s e l e c t
case
cannot
be
used
with
d e r i v e d
!
types .
see
*Cmnt−2 f o r
a l t e r n a t i v e .
s e l e c t
case
( mold%coord )
case
(1)
r e t v a l = t h i s%x
case
(2)
r e t v a l = t h i s%y
case
default
r e t v a l = 0.0
end
s e l e c t
end
function
Get coord
function
G e t x y c o o r d p a i r
( t h i s )
r e s u l t
( r e t v a l )
c l a s s
( pt2d t ) ,
intent
( in )
: :
t h i s
r e a l
(
kind
( t h i s%x )
)
: :
r e t v a l (2)
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
291
write
(* , FA) MOD HEAD // ” G e t x y c o o r d p a i r ”
r e t v a l = [ t h i s%x ,
t h i s%y ]
end
function
G e t x y c o o r d p a i r
subroutine
P r i n t p t
( t h i s )
c l a s s
( pt2d t ) ,
intent
( in )
: :
t h i s
write
(* , FA,
advance=”no” ) MOD HEAD // ” P r i n t p t : ”
write
(* , ” (2(A, G8 . 3 ) ) ” ) ” x :
” ,
t h i s%x ,
”y :
” , &
t h i s%y
end subroutine
P r i n t p t
subroutine
Set coords
( t h i s ,
coords )
c l a s s
( pt2d t ) ,
intent
( in
out )
: :
t h i s
r e a l
( kind
( t h i s%x ) ) ,
intent
( in )
: :
coords ( : )
write
(* , FA) MOD HEAD // ” Set coords ”
t h i s%x = coords (1)
t h i s%y = coords (2)
end subroutine
Set coords
end module Pt2d mod
module Pt3d mod
!
Purpose :
Module
f o r
type
pt3d t
use Pt2d mod ,
only
:
coord spec t ,
pt2d t , &
X COORD, Y COORD,
operator (==)
i m p l i c i t
none
private
type ,
public ,
extends ( pt2d t )
: :
pt3d t
private
r e a l
: :
z = 0.0
contains
procedure
: :
Get coord
procedure
: :
G e t l e n => Comp dist
procedure
: :
P r i n t p t
procedure
: :
Set => Set coords
end type
pt3d t
type
( c o o r d s p e c t ) ,
public ,
parameter
: : &
Z COORD = c o o r d s p e c t
(3)
character (*) ,
parameter
: : &
MOD HEAD = ” C a l l e e :
Module pt3d mod :
” , FA = ” (A) ”
Cambridge Books Online © Cambridge University Press, 2012

292
SOURCE CODE
contains
function
Comp dist
( pt 1 ,
pt 2 )
r e s u l t
( r e t v a l )
!
*Cmnt−5:
o v e r r i d e s
some
cases
i n
module
!
Pt2d mod .
!
See *Cmnt−4
c l a s s
( pt3d t ) ,
intent
( in )
: :
pt 1
c l a s s
( pt2d t ) ,
intent
( in )
: :
pt 2
r e a l
(
kind
( pt 1%z )
)
: :
r e t v a l
r e a l
(
kind
( pt 1%z )
) : :
x d i s t ,
y d i s t ,
z d i s t
write
(* , FA) MOD HEAD // ” Comp dist ”
s e l e c t
type
( pt 1 )
type
i s
( pt3d t )
s e l e c t
type
( pt 2 )
type
i s
( pt3d t )
associate
( pt1 => pt 1%pt2d t , &
pt2 => pt 2%pt2d t )
x d i s t = pt1%Get
(X COORD) −pt2%Get
(X COORD)
y d i s t = pt1%Get
(Y COORD) −pt2%Get
(Y COORD)
z d i s t = pt 1%z −pt 2%z
end
associate
end
s e l e c t
end
s e l e c t
r e t v a l = sqrt
(( x d i s t
** 2) + ( y d i s t
** 2) + &
( z d i s t
**
2))
end
function
Comp dist
function
Get coord
( t h i s ,
mold )
r e s u l t
( r e t v a l )
c l a s s
( pt3d t ) ,
intent
( in )
: :
t h i s
type
( c o o r d s p e c t ) ,
intent
( in )
: :
mold
r e a l
(
kind
( t h i s%z )
)
: :
r e t v a l
write
(* , FA) MOD HEAD // ” Get coord ”
s e l e c t
type
( t h i s )
!
*Cmnt−2:
a l t e r n a t i v e
to
s e l e c t
case .
See *Cmnt−3
type
i s
( pt3d t )
i f
( mold == X COORD . or .
mold == Y COORD)
then
associate
( pt2d => t h i s%pt2d t )
r e t v a l = pt2d%Get
( mold )
end
associate
e l s e
i f
( mold ==Z COORD)
then
r e t v a l = t h i s%z
end
i f
end
s e l e c t
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
293
end
function
Get coord
subroutine
P r i n t p t
( t h i s )
c l a s s
( pt3d t ) ,
intent
( in )
: :
t h i s
write
(* , FA) MOD HEAD // ” P r i n t p t ”
s e l e c t
type
( t h i s )
type
i s
( pt3d t )
associate
( pt 2d => t h i s%pt2d t )
c a l l
pt 2d%Print
()
end
associate
end
s e l e c t
write
(* , FA,
advance=”no” ) MOD HEAD // ” P r i n t p t : ”
write
(* , ” (A, G8 . 3 ) ” ) ” z :
” ,
t h i s%z
end subroutine
P r i n t p t
subroutine
Set coords
( t h i s ,
coords )
c l a s s
( pt3d t ) ,
intent
( in
out )
: :
t h i s
r e a l
(
kind
( t h i s%z )
) ,
intent
( in )
: :
coords ( : )
write
(* , FA) MOD HEAD // ” Set coords ”
s e l e c t
type
( t h i s )
type
i s
( pt3d t )
associate
( pt 2d => t h i s%pt2d t )
c a l l
pt 2d%Set
( coords )
t h i s%z = coords (3)
end
associate
end
s e l e c t
end subroutine
Set coords
end module Pt3d mod
program Type bound demo
use Pt2d mod ,
only
:
pt2d t , Y COORD
use Pt3d mod ,
only
:
pt3d t , Z COORD
i m p l i c i t
none
type
( pt2d t ) ,
target
: :
pt 2d
type
( pt3d t ) ,
target
: :
pt 3d
c l a s s
( pt2d t ) ,
pointer
: :
p o l y p n t r
c l a s s
( pt2d t ) ,
a l l o c a t a b l e
: :
p o l y a l l o c v a r
integer
: :
a l l o c s t a t
real ,
a l l o c a t a b l e
: :
p o i n t p a i r ( : )
r e a l
: :
c o o r d i n a t e v a l u e
Cambridge Books Online © Cambridge University Press, 2012

294
SOURCE CODE
character
(*) ,
parameter
: :
FA = ” (A) ” , &
FG14 BLANK = ” (A,
2G14 . 7 ,
/ , A) ”
!
Part
I :
I n h e r i t a n c e
c a l l
pt 2d%Set
(
[ 1 . 0 ,
2 . 0 ]
)
p o i n t p a i r = pt 2d%Get
()
write
(* , FG14 BLANK) &
” Result :
p o i n t p a i r
( pt 2d ) x/y :
” ,
p o i n t p a i r ,
””
c a l l
pt 3d%Set
(
[ 1 1 . 0 ,
12.0 ,
1 3 . 0 ]
)
!
*Cmnt−8:
Generic
c a l l .
p o i n t p a i r = pt 3d%Get
()
write
(* , FG14 BLANK) &
” Result :
p o i n t p a i r
( pt 2d ) x/y :
” ,
p o i n t p a i r ,
””
c o o r d i n a t e v a l u e = pt 2d%Get
(Y COORD)
write
(* , FG14 BLANK) &
” Result :
c o o r d i n a t e v a l u e ” ,
c o o r d i n a t e v a l u e ,
””
c o o r d i n a t e v a l u e = pt 2d%Get
(Z COORD)
write
(* , FG14 BLANK) &
” Result :
c o o r d i n a t e v a l u e ” ,
c o o r d i n a t e v a l u e ,
””
c o o r d i n a t e v a l u e = pt 3d%Get
(Y COORD)
write
(* , FG14 BLANK) &
” Result :
c o o r d i n a t e v a l u e ” ,
c o o r d i n a t e v a l u e ,
””
c o o r d i n a t e v a l u e = pt 3d%Get
(Z COORD)
write
(* , FG14 BLANK) &
” Result :
c o o r d i n a t e v a l u e ” ,
c o o r d i n a t e v a l u e ,
””
c o o r d i n a t e v a l u e = pt 3d%pt2d t%Get
(Y COORD)
write
(* , FG14 BLANK) &
” Result :
c o o r d i n a t e v a l u e ” ,
c o o r d i n a t e v a l u e ,
””
!
Part
I I :
Polymorphism
p o l y p n t r => pt 2d
c a l l
p o l y p n t r%Print
write
(* , FA) ””
n u l l i f y
( p o l y p n t r )
p o l y p n t r => pt 3d
c a l l
p o l y p n t r%Print
write
(* , FA) ””
n u l l i f y
( p o l y p n t r )
!
*Cmnt−6:
sourced
a l l o c a t i o n
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
295
a l l o c a t e
( p o l y a l l o c v a r ,
source=pt 2d , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t /= 0)
then
stop ” a l l o c a t i o n
problem ”
e l s e
c a l l
p o l y a l l o c v a r%Print
write
(* , FA) ””
deallocate
( p o l y a l l o c v a r ,
stat=a l l o c s t a t )
i f
( a l l o c s t a t /= 0) &
stop ” d e a l l o c a t i o n
problem , Demo ”
end
i f
!
*Cmnt−7:
sourced
a l l o c a t i o n
a l l o c a t e
( p o l y a l l o c v a r ,
source=pt 3d , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t /= 0)
then
stop ” a l l o c a t i o n
problem ”
e l s e
c a l l
p o l y a l l o c v a r%Print
write
(* , FA) ””
deallocate
( p o l y a l l o c v a r ,
stat=a l l o c s t a t )
i f
( a l l o c s t a t /= 0) &
stop ” d e a l l o c a t i o n
problem , Demo ”
end
i f
end program Type bound demo
A.2 Unlimited demo
Listing 1.2: Program Unlimited demo
module Base object mod
!
Purpose : A module
d e f i n i n g
an
a b s t r a c t
type
that
!
every
d e r i v e d
type
i s
extended
from .
i m p l i c i t
none
private
type ,
abstract ,
public
: :
b a s e o b j e c t t
contains
procedure
( P r i n t t y p e ) ,
deferred
: :
Print
end type
b a s e o b j e c t t
abstract
i n t e r f a c e
subroutine
P r i n t t y p e
( t h i s )
Cambridge Books Online © Cambridge University Press, 2012

296
SOURCE CODE
import
: :
b a s e o b j e c t t
c l a s s
( b a s e o b j e c t t ) ,
intent
( in )
: :
t h i s
end subroutine
P r i n t t y p e
end
i n t e r f a c e
end module Base object mod
module Base node mod
use
Base object mod ,
only
:
b a s e o b j e c t t
i m p l i c i t
none
private
type ,
extends
( b a s e o b j e c t t ) ,
public
: :
base node t
!
*Cmnt−2:
Unlimited
polymorphic
e n t i t y
c l a s s
(*) ,
a l l o c a t a b l e
: :
o b j e c t
type
( base node t ) ,
pointer
: :
next node => n u l l
()
contains
procedure
: :
Get
=> G e t o b j e c t
procedure
: :
Print => P r i n t o b j e c t
procedure
: :
Put
=> Put object
end type
base node t
contains
subroutine
G e t o b j e c t
( t h i s ,
o b j e c t )
!
Purpose :
R e t r i e v e
the
o b j e c t
component .
c l a s s
( base node t ) ,
intent
( in )
: :
t h i s
c l a s s
(*) ,
intent
( out ) ,
a l l o c a t a b l e
: :
o b j e c t
integer
: :
a l l o c s t a t
a l l o c a t e
( object ,
source=t h i s%object , &
stat=a l l o c s t a t )
end subroutine
G e t o b j e c t
subroutine
P r i n t o b j e c t
( t h i s )
use
Base object mod ,
only
:
b a s e o b j e c t t
c l a s s
( base node t ) ,
intent
( in )
: :
t h i s
!
cannot
use
a l l o c a t a b l e
deferred −l e n g t h
c h a r a c t e r
!
because
t e x t
i s
used
f o r
i n t e r n a l
w r i t e
!
( see
*Cmnt−4).
character
(80)
: :
t e x t
character
(*) ,
parameter
: :
FA = ” (A) ”
l o g i c a l
: :
p r i n t t x t
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
297
!
obj
r e q u i r e d
because
t h i s%o b j e c t
i s
a component
!
not a
v a r i a b l e
!
*Cmnt−5:
s e l e c t
both
d e r i v e d
and
i n t r i n s i c
types
p r i n t t x t = . true .
s e l e c t
type
( obj => t h i s%o b j e c t )
c l a s s
i s
( b a s e o b j e c t t )
c a l l
obj%Print
p r i n t t x t = . f a l s e .
!
not
a l l
i n t r i n s i c
types
r e q u i r e d
by
standard
are
!
l i s t e d
type
i s
( r e a l )
!
*Cmnt−4:
I n t e r n a l
w r i t e
to
f i x e d −l e n g t h
!
c h a r a c t e r
v a r i a b l e
t e x t .
write
( text ,
” (A,
F0 . 8 ) ” ) ” r e a l :
” ,
obj
type
i s
( integer )
write
( text ,
” (A,
I0 ) ” ) ” i n t e g e r :
” ,
obj
type
i s
( complex )
write
( text ,
” (A,
2( F0 . 8 ,
1x )) ” ) ” complex :
” ,
obj
type
i s
( character ( * ) )
write
( text , FA) ” c h a r a c t e r :
” // trim
( obj )
c l a s s
default
write
( text , FA) ” i n d e t e r m i n a t e
type ”
end
s e l e c t
i f
( p r i n t t x t )
write
(* , FA)
trim
( t e x t )
end subroutine
P r i n t o b j e c t
subroutine
Put object
( t h i s ,
o b j e c t )
c l a s s
( base node t ) ,
intent
( in
out )
: :
t h i s
c l a s s
(*) ,
intent
( in )
: :
o b j e c t
integer
: :
a l l o c s t a t
!
*Cmnt−3:
Fortran
2008:
t h i s%o b j e c t = o b j e c t
a l l o c a t e
( t h i s%object ,
source=object , &
stat=a l l o c s t a t )
end subroutine
Put object
end module Base node mod
module Base stack mod
!
Purpose : A stack
data
s t r u c t u r e .
!
Notes
! =====
!
Implemented
as a
s i n g l e −l i n k e d
l i s t .
Cambridge Books Online © Cambridge University Press, 2012

298
SOURCE CODE
!
Component top
i s
the
beginning
of
the
l i s t .
!
Component bottom
i s
the
end
of
the
l i s t .
!
Items
are
pushed
onto and popped
o f f
the
top
of
the
!
stack .
use Base node mod ,
only
:
base node t
use
Base object mod ,
only
:
b a s e o b j e c t t
i m p l i c i t
none
private
public
: :
BASE OP SUCCESS
type ,
public ,
extends
( b a s e o b j e c t t )
: :
b a s e s t a c k t
private
integer
: :
number of nodes = 0
character
( : ) ,
a l l o c a t a b l e
: :
name
type
( base node t ) ,
pointer
: :
top => n u l l
( ) , &
bottom => n u l l
()
contains
procedure
: :
Count stack no
procedure
: :
C o u n t s t a c k s t r
procedure
: :
Empty
=> Empty stack
procedure
: :
Get
=> Get stack
procedure
: :
Pop
=> Pop stack
procedure
: :
Print
=> P r i n t s t a c k
procedure
: :
P r i n t s t a c k s t a t u s
procedure
: :
Push
=> Push stack
generic
: :
Count => Count stack no ,
C o u n t s t a c k s t r
f i n a l
: :
Destroy
end type
B a s e s t a c k t
enum ,
bind (C)
enumerator
: :
BASE OP SUCCESS = 0 , BASE OP FAIL , &
BASE ALLOC ERROR , BASE BAD DATA
end enum
character
(*) ,
parameter
: :
FA = ” (A) ” , &
F TXT BLANK = ” (A,
/ , A) ”
contains
function
Count stack no
( t h i s ,
mold )
r e s u l t
( r e t n o o f n o d e s )
c l a s s
( b a s e s t a c k t ) ,
intent
( in )
: :
t h i s
integer ,
intent
( in )
: :
mold
integer
: :
r e t n o o f n o d e s
r e t n o o f n o d e s = t h i s%number of nodes
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
299
end
function
Count stack no
function
C o u n t s t a c k s t r
( t h i s ,
mold )
r e s u l t
( r e t s t r )
c l a s s
( b a s e s t a c k t ) ,
intent
( in )
: :
t h i s
character ,
intent
( in )
: :
mold
character
( : ) ,
a l l o c a t a b l e
: :
r e t s t r
character
( len =80)
: :
l o c a l s t r
write
( l o c a l s t r ,
” ( I0 ) ” )
t h i s%Count (1)
r e t s t r = trim
( l o c a l s t r )
end
function
C o u n t s t a c k s t r
subroutine
Destroy
( t h i s )
!
*Cmnt−1:
F i n a l i z e r ,
using
r e c u r s i o n .
type
( b a s e s t a c k t ) ,
intent
( in
out )
: :
t h i s
type
( base node t ) ,
pointer
: :
t r a v e r s e p t r
integer
: :
c a l l s t a t
c a l l s t a t
= BASE OP SUCCESS
i f
( . not .
t h i s%Empty
()
)
then
!
i n i t i a t e
r e c u r s i v e
d e s t r u c t i o n
of
nodes
t r a v e r s e p t r => t h i s%top
c a l l
Destroy worker
( t r a v e r s e p t r ,
c a l l s t a t )
e l s e
write
(* , F TXT BLANK) ” Stack
i s
empty . ” , ””
end
i f
!
clean
up
i f
( c a l l s t a t == BASE OP SUCCESS)
then
t h i s%number of nodes = 0
n u l l i f y
( t h i s%top )
n u l l i f y
( t h i s%bottom )
end
i f
contains
r e c u r s i v e
subroutine
Destroy worker
( c u r r e n t p t r , &
r e t u r n s t a t )
!
Note
that
r e t u r n s t a t
i s
i n t e n t
( i n
out )
to
!
allow
r e t e n t i o n
of
a
f a i l u r e
at
any
c a l l .
type
( base node t ) ,
intent
( in
out ) ,
pointer
: : &
c u r r e n t p t r
Cambridge Books Online © Cambridge University Press, 2012

300
SOURCE CODE
integer ,
intent
( in
out )
: :
r e t u r n s t a t
integer
: :
d e a l l o c s t a t
l o g i c a l
: :
l a s t n o d e
!
r e c u r s i v e
c a l l s
to
the
bottom
of
the
stack
i f
( associated
( c u r r e n t p t r%next node )
)
then
l a s t n o d e = . f a l s e .
c a l l
Destroy worker
( c u r r e n t p t r%next node , &
r e t u r n s t a t )
e l s e
!
d e a l l o c a t e
the
bottom
l a s t n o d e = . true .
deallocate
( c u r r e n t p t r ,
stat=d e a l l o c s t a t )
i f
( d e a l l o c s t a t /= 0)
then
r e t u r n s t a t = BASE ALLOC ERROR
e l s e
r e t u r n s t a t = BASE OP SUCCESS
end
i f
end
i f
!
d e a l l o c a t e
backing
out
of
r e c u r s i v e
c a l l s
i f
( . not .
l a s t n o d e )
then
deallocate
( c u r r e n t p t r ,
stat=d e a l l o c s t a t )
i f
( d e a l l o c s t a t /= 0)
then
r e t u r n s t a t = BASE ALLOC ERROR
e l s e
r e t u r n s t a t = BASE OP SUCCESS
end
i f
end
i f
end subroutine
Destroy worker
end subroutine
Destroy
function
Empty stack
( t h i s )
r e s u l t
( r e t u r n v a l u e )
c l a s s
( b a s e s t a c k t ) ,
intent
( in )
: :
t h i s
l o g i c a l
: :
r e t u r n v a l u e
r e t u r n v a l u e = . not .
associated
( t h i s%top )
end
function
Empty stack
subroutine
Get stack
( t h i s ,
o b j e c t )
!
Purpose :
Return
the
f i r s t
item
( not
node )
i n
the
!
l i s t
without
removing
i t .
c l a s s
( b a s e s t a c k t ) ,
intent
( in )
: :
t h i s
c l a s s
(*) ,
intent
( out ) ,
a l l o c a t a b l e
: :
o b j e c t
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
301
i f
( . not .
t h i s%Empty
()
)
then
c a l l
t h i s%top%Get
( o b j e c t )
e l s e
write
(* , F TXT BLANK) ” Stack
i s
empty” , ””
end
i f
end subroutine
Get stack
subroutine
Pop stack
( t h i s ,
r e t u r n o b j e c t , &
r e t u r n s t a t )
!
Purpose :
Get
the
top
of
the
stack
and remove
i t .
c l a s s
( b a s e s t a c k t ) ,
intent
( in
out )
: :
t h i s
c l a s s
(*) ,
intent
( out ) ,
a l l o c a t a b l e
: : &
r e t u r n o b j e c t
integer ,
intent
( out )
: :
r e t u r n s t a t
integer
: :
a l l o c s t a t
type
( base node t ) ,
pointer
: :
node ptr
r e t u r n s t a t = BASE OP SUCCESS
s t a c k s t a t u s :
i f
( . not .
t h i s%Empty
( ) )
then
!
Get
the
o b j e c t .
R e a s s o c i a t e
top
p o i n t e r
and
!
d e a l l o c a t e .
Decrement node
count .
c a l l
t h i s%top%Get
( r e t u r n o b j e c t )
node ptr => t h i s%top%next node
deallocate
( t h i s%top ,
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
t h i s%top => node ptr
t h i s%number of nodes = t h i s%number of nodes −1
e l s e
r e t u r n s t a t=BASE ALLOC ERROR
end
i f
e l s e
s t a c k s t a t u s
write
(* , F TXT BLANK) ” Stack
i s
empty . ” , ””
end
i f
s t a c k s t a t u s
end subroutine
Pop stack
subroutine
P r i n t s t a c k
( t h i s )
c l a s s
( B a s e s t a c k t ) ,
intent
( in )
: :
t h i s
type
( base node t ) ,
pointer
: :
t r a v e r s e p t r
integer ,
parameter
: :
NODE CHAR WID = 15
character
( len=NODE CHAR WID)
: :
node num
Cambridge Books Online © Cambridge University Press, 2012

302
SOURCE CODE
integer
: :
i nod
c a l l
t h i s%P r i n t s t a c k s t a t u s
s t a c k s t a t u s :
i f
( . not .
t h i s%Empty
()
)
then
t r a v e r s e p t r => t h i s%top
i nod = 0
do
i nod = i nod + 1
write
( node num ,
” (A,
I0 , A) ” ) ”Node ” ,
i nod , &
” : ”
write
(* , FA)
trim
( node num ) // ” ”
c a l l
t r a v e r s e p t r%Print
t r a v e r s e p t r => t r a v e r s e p t r%next node
i f
( associated
( t r a v e r s e p t r ,
t h i s%bottom ))
then
write
( node num ,
” (A,
I0 , A) ” ) ”Node ” , &
i nod + 1 , ” : ”
write
(* , FA)
trim
( node num ) // ” ”
c a l l
t r a v e r s e p t r%Print
e x i t
end
i f
end do
e l s e
s t a c k s t a t u s
write
(* , F TXT BLANK) ” Stack
i s
empty” , ””
end
i f
s t a c k s t a t u s
end subroutine
P r i n t s t a c k
subroutine
P r i n t s t a c k s t a t u s
( t h i s )
c l a s s
( b a s e s t a c k t ) ,
intent
( in )
: :
t h i s
character
(80)
: :
t e x t
write
(* , F TXT BLANK)
” Stack
s t a t u s ” , &
”=========== ”
i f
( t h i s%Empty
( ) )
then
write
( text , FA) ” Stack
i s
empty”
e l s e
write
( text ,
” (A) ” ) ” The stack
has ” // &
t h i s%Count
( ’ a ’ )
// ” nodes . ”
end
i f
write
(* , F TXT BLANK)
trim
( t e x t ) ,
””
end subroutine
P r i n t s t a c k s t a t u s
subroutine
Push stack
( t h i s ,
object ,
r e t u r n s t a t )
c l a s s
( b a s e s t a c k t ) ,
intent
( in
out )
: :
t h i s
c l a s s
(*) ,
intent
( in )
: :
o b j e c t
integer ,
intent
( out )
: :
r e t u r n s t a t
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
303
integer
: :
a l l o c s t a t ,
c a l l s t a t
type
( base node t ) ,
pointer
: :
node ptr
c a l l s t a t
= 0
r e t u r n s t a t = BASE OP SUCCESS
s t a c k s t a t u s :
i f
( t h i s%Empty
( ) )
then
!
Empty stack ,
use
top .
a l l o c a t e
( base node t
: :
t h i s%top , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
t h i s%bottom => t h i s%top
n u l l i f y
( t h i s%bottom%next node )
c a l l
t h i s%top%Put ( o b j e c t )
c a l l
t h i s%top%Print
()
e l s e
r e t u r n s t a t = BASE ALLOC ERROR
end
i f
e l s e
s t a c k s t a t u s
!
use
temporary
s t o r a g e
node .
a l l o c a t e
( base node t
: :
node ptr , &
stat=a l l o c s t a t )
i f
( a l l o c s t a t == 0)
then
c a l l
node ptr%Put ( o b j e c t )
node ptr%next node => t h i s%top
t h i s%top => node ptr
n u l l i f y
( t h i s%bottom%next node )
c a l l
t h i s%top%Print
()
e l s e
r e t u r n s t a t = BASE ALLOC ERROR
end
i f
end
i f
s t a c k s t a t u s
!
Increment
number
of
nodes .
i f
( r e t u r n s t a t == BASE OP SUCCESS) &
t h i s%number of nodes = t h i s%number of nodes + 1
end subroutine
Push stack
end module Base stack mod
module Key mod
use
Base object mod ,
only
:
b a s e o b j e c t t
i m p l i c i t
none
private
type ,
public ,
extends
( b a s e o b j e c t t )
: :
k e y t
Cambridge Books Online © Cambridge University Press, 2012

304
SOURCE CODE
integer
: :
key = 0
character ( : ) ,
a l l o c a t a b l e
: :
key name
contains
procedure
: :
Print => P r i n t k e y t
end type
k e y t
character
(*) ,
parameter
: :
FA = ” (A) ” , &
F TEXT BLANK = ” (A,
/ , A) ”
contains
subroutine
P r i n t k e y t
( t h i s )
c l a s s
( k e y t ) ,
intent
( in )
: :
t h i s
character (80)
: :
t e x t
write
(* , F TEXT BLANK) ” k e y t ” , ”=====”
write
(* , ” (A,
I0 ) ” ) ” key :
” ,
t h i s%key
i f
( allocated
( t h i s%key name )
)
then
write
( text , FA) ”key name :
” // &
trim
( t h i s%key name )
e l s e
write
( text , FA) ”key name :
unassigned ”
end
i f
write
(* , F TEXT BLANK)
trim
( t e x t ) ,
””
end subroutine
P r i n t k e y t
end module Key mod
module Simple mod
use
Base object mod ,
only
:
b a s e o b j e c t t
i m p l i c i t
none
private
type ,
public ,
extends
( b a s e o b j e c t t )
: :
s i m p l e t
r e a l
: :
real comp
= 0.0
integer
: :
integer comp = 0
contains
procedure
: :
Print => P r i n t s i m p l e t
end type
s i m p l e t
character
(*) ,
parameter
: :
FA = ” (A) ” , &
F TEXT BLANK = ” (A,
/ , A) ”
contains
subroutine
P r i n t s i m p l e t
( t h i s )
c l a s s
( s i m p l e t ) ,
intent
( in )
: :
t h i s
character (80)
: :
t e x t
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
305
write
(* , F TEXT BLANK) ” s i m p l e t ” , ”========”
write
( text ,
” (A,
T16 ,
F0 . 8 ) ” ) ” real comp :
” , &
t h i s%real comp
write
(* , FA)
trim
( t e x t )
write
( text ,
” (A,
T16 ,
I0 ) ” ) ” integer comp :
” , &
t h i s%integer comp
write
(* , F TEXT BLANK)
trim
( t e x t ) ,
””
end subroutine
P r i n t s i m p l e t
end module Simple mod
!
Main program
program Unlimited demo
use
Base object mod ,
only
:
b a s e o b j e c t t
use
Base stack mod ,
only
:
b a s e s t a c k t
use Key mod ,
only
:
k e y t
use Simple mod ,
only
:
s i m p l e t
i m p l i c i t
none
type
( s i m p l e t )
: :
simple
type
( k e y t )
: :
key
type
( b a s e s t a c k t )
: :
stack
integer
: :
c a l l s t a t ,
i node ,
i n t e g e r v a l u e
r e a l
: :
r e a l v a l u e
complex
: :
cmplx val
c l a s s
(*) ,
a l l o c a t a b l e
: :
o b j e c t
character
(80)
: :
t e x t
character
( len =:) ,
a l l o c a t a b l e
: :
c h a r s t r i n g
i n t e g e r v a l u e = 23
r e a l v a l u e
= 14.5
cmplx val
= cmplx
(10.5 ,
−8.1)
c h a r s t r i n g
= ” h e l l o
world ”
c a l l
stack%Push ( simple ,
c a l l s t a t )
c a l l
stack%Push ( i n t e g e r v a l u e ,
c a l l s t a t )
c a l l
stack%Push ( key ,
c a l l s t a t )
c a l l
stack%Push ( r e a l v a l u e ,
c a l l s t a t )
c a l l
stack%Push ( c h a r s t r i n g ,
c a l l s t a t )
c a l l
stack%Push ( cmplx val ,
c a l l s t a t )
c a l l
stack%Print
do
i n o d e = 1 ,
stack%Count
(1)
c a l l
stack%Pop ( object ,
c a l l s t a t )
c a l l
P r i n t o b j
( o b j e c t )
end do
c a l l
stack%P r i n t s t a c k s t a t u s
contains
Cambridge Books Online © Cambridge University Press, 2012

306
SOURCE CODE
subroutine
P r i n t o b j
( obj )
c l a s s
(*) ,
intent
( in ) ,
a l l o c a t a b l e
: :
obj
character
(*) ,
parameter
: :
FA = ” (A) ” , &
F TXT BLANK = ” (A,
/ , A) ”
l o g i c a l
: :
p r i n t t x t
p r i n t t x t = . true .
s e l e c t
type
( obj )
c l a s s
i s
( b a s e o b j e c t t )
c a l l
obj%Print
p r i n t t x t = . f a l s e .
type
i s
( r e a l )
write
( text ,
” (A,
F0 . 8 ) ” ) ” r e a l :
” ,
obj
type
i s
( integer )
write
( text ,
” (A,
I0 ) ” ) ” i n t e g e r :
” ,
obj
type
i s
( complex )
write
( text ,
” (A,
2( F0 . 8 ,
1x )) ” ) ” complex :
” ,
obj
type
i s
( character ( * ) )
write
( text , FA) ” c h a r a c t e r :
” // trim
( obj )
c l a s s
default
write
( text , FA) ” I n d e t e r m i n a t e
type ”
end
s e l e c t
i f
( p r i n t t x t )
write
(* , F TXT BLANK)
trim
( t e x t ) , &
””
end subroutine
P r i n t o b j
end program Unlimited demo
The following is the output of the program:
simple_t
========
real_comp:
.00000000
integer_comp:
0
integer: 23
key_t
=====
key: 0
key_name: unassigned
real: 14.50000000
character: hello world
complex: 10.50000000 -8.10000038
Stack status
===========
Cambridge Books Online © Cambridge University Press, 2012

SOURCE CODE
307
The stack has 6 nodes.
Node 1:
complex: 10.50000000 -8.10000038
Node 2:
character: hello world
Node 3:
real: 14.50000000
Node 4:
key_t
=====
key: 0
key_name: unassigned
Node 5:
integer: 23
Node 6:
simple_t
========
real_comp:
.00000000
integer_comp:
0
complex: 10.50000000 -8.10000038
character: hello world
real: 14.50000000
key_t
=====
key: 0
key_name: unassigned
integer: 23
simple_t
========
real_comp:
.00000000
integer_comp:
0
Stack status
===========
Stack is empty
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

Appendix B
Rule List
This appendix provides the user with a complete list of all the guidelines
contained in the book. They are listed in the order of their appearance and
grouped by chapter. The page on which each rule can be found in parentheses
following the rule.
Chapter 2. General Principles
1. Write programs that are clear to both the reader and the compiler.
(3)
2. Write programs that can be efﬁciently tested. (4)
3. Write programs that will scale to different problem sizes. (5)
4. Write code that can be reused. (6)
5. Document all code changes, keeping a history of all code revisions.
(6)
Chapter 3. Formatting Conventions
6. Always use free source form. (9)
7. Adopt and use a consistent set of rules for case. (10)
7.1 Use lowercase throughout. (11)
7.2 Capitalize the names of all user-written procedures. (11)
7.3 Write all named constants using uppercase letters. (12)
7.4 Begin the name of all data entities using a lowercase letter. (12)
8. Use a consistent number of spaces when indenting code. (13)
9. Increase the indentation of the source code every time the data scope
changes. (13)
10. Indent the block of code statements within all control constructs. (14)
11. Indent all the code after a named construct so the name stands out.
(15)
12. Consider using one indentation for block constructs and a different
one for statement continuation. (15)
308
Cambridge Books Online © Cambridge University Press, 2012

RULE LIST
309
13. Left-justify major documentation blocks; indent short comments the
same as the code it describes or one additional indentation level. (16)
14. Use all optional white space in keywords. (17)
15. Align similar code. (17)
16. Consider using white space to differentiate between the use of paren-
theses to enclose the argument list in calls to subprograms and their
use to enclose the index list of arrays. (19)
17. Place a space after all commas. (19)
18. Do not use “hard” tabs. (20)
19. Consider using leading ampersands (&) to mark continuation lines.
(20)
20. Place each program statement on its own line. (21)
21. In general, avoid putting comments at the end of lines containing
source code. (21)
22. Use the symbolic relational operators, <, <=, /=, ==, >=, >.
(22)
23. Use the square bracket notation, [ ], introduced in Fortran 2003,
for array constructors. (22)
24. Write at least one digit on each side of the decimal point of ﬂoating-
point literal constants. (23)
Chapter 4. Naming Conventions
25. Use detailed names for data objects whose scope is global, less detailed
names for those whose scope is a module, and simple but clear names
for those whose scope is a single procedure. (24)
26. Name user-written procedures using verbs. (24)
27. Use a consistent set of verbs throughout to name common procedures.
(25)
27.1 Name accessor procedures using either the verb “Set” or “Put”
and the verb “Get” followed by the component name. (25)
27.2 Name procedures that traverse data structures using the verbs
that are commonly used – “Next, Previous, Pop, Push,” and so on.
(26)
27.3 Use the same verb for all ﬁnal procedures followed by the name
of the derived type. (26)
Cambridge Books Online © Cambridge University Press, 2012

310
RULE LIST
27.4 Name functions that return a logical result using verbs such as
“Is,” or “Has.” (26)
28. Add an identifying tag to all module names. (27)
29. Add an identifying tag to all derived type names. (28)
30. Consider adding an identifying tag to all pointers. (29)
31. Use plural nouns to differentiate arrays from scalars. (30)
32. In modules in which a derived type is deﬁned, use either the name
“this” or the name “self” for the pass argument a in all type-bound
procedures and procedure pointer components and for the dummy
argument of the type in all module procedures. (30)
33. Establish pairs of logical named constants to replace the values of
.true. and . false . in cases where this will clarify the code. (31)
34. Consider using a unique name or a limited number of names
throughout a program as the names of the value returned by a func-
tion. (32)
35. Use common names for variables that represent accepted mathe-
matic, scientiﬁc, and engineering terms. Spell out the names of
quantities whose symbol is not part of the Fortran character set.
(33)
36. Consider beginning the names of all do, index, and subscript vari-
ables using the letters “i” through “n.” (33)
37. Name all executable construct blocks with a name describing the
purpose of the construct. (34)
38. Always use optional names on end statements. (35)
39. Make liberal use of the associate construct. (35)
Chapter 5. Documentation Conventions
40. Write self-documenting code. (38)
41. Add comments to your code to allow other programmers to under-
stand its purpose. It is especially important to explain what cannot
be read from the source text itself. (39)
42. Always synchronize the documentation with the code. (41)
43. Write a documentation block for every program unit. (41)
Cambridge Books Online © Cambridge University Press, 2012

RULE LIST
311
Chapter 6. Programming Principles
44. Always write standard-conforming code. (44)
45. Do not rely on compiler switches that change code semantics. (44)
46. Order the statements in modules in a ﬁxed and consistent manner.
(44)
47. Place data objects that require global accessibility in modules. (46)
48. Include a default private statement in the speciﬁcation section of all
modules. Provide either public or read-only access to module entities
on an as-needed basis. (47)
49. Use the only option in use statements. (49)
50. Indicate the intent of all dummy arguments. (50)
51. In functions, specify the intent of all dummy arguments as
intent (in). (53)
52. Whenever possible, write procedures such that they can be preﬁxed
by the pure preﬁx. (56)
53. Use caution when specifying derived-type dummy arguments with
the intent (out) attribute. (57)
54. When appropriate, assign the value attribute to dummy arguments
to allow their values to change without affecting the value of the
actual argument. (60)
55. Be attentive to the particular standard speciﬁcations regarding argu-
ments possessing either the pointer or the target attribute. (62)
56. Be attentive to the particular standard speciﬁcations regarding argu-
ments possessing the target attribute; do not rely on pointers that
become associated with dummy arguments possessing this attribute
to retain their value or their association status. (69)
57. Consistently place subprogram arguments in the following order:
pass arguments,
intent (in out) arguments,
intent (in) argu-
ments, intent (out) arguments, optional arguments. (74)
58. Assign a default value to all dummy arguments possessing the optional
attribute. (77)
59. Reduce long argument lists by placing arguments in derived types.
(78)
60. In all calls to subprograms, use the form dummy-argument-name =
actual-argument-name with all optional arguments. (79)
Cambridge Books Online © Cambridge University Press, 2012

312
RULE LIST
61. Use assumed-shape arrays as dummy array arguments in subpro-
grams. (80)
62. Use assumed-length or deferred-length allocatable character dummy
arguments. (82)
63. Provide simple runtime argument checking at the beginning of pro-
cedures. (82)
64. Create private “argument parameter” types for better compile-time
checking of valid values. (85)
65. Write recursive procedures so they have a beginning, a middle, and
an end. (86)
66. Use recursion to simplify locally scoped data. (87)
67. Take advantage of tail recursion when possible. (89)
68. Write code that avoids side effects. (90)
69. Separate initialization from computation to maintain computa-
tional purity. (91)
70. Use subroutines instead of functions when returning results through
the argument list. (94)
71. Avoid unintentional aliasing. (94)
Chapter 7. Programming Conventions
72. Declare all variables. To enforce this rule, always include the state-
ment implicit none in all program units. (98)
73. Assign data object attributes on the same statement as their declara-
tion. (99)
74. Initialize all pointers to have an initial association status of disas-
sociated using the intrinsic function null. (99)
75. Do not initialize variables in their declaration unless necessary.
(100)
76. Use assumed-length character notation when declaring named con-
stants of intrinsic type character. (101)
77. Use named constants instead of “magic numbers” and frequently
used character strings. (101)
78. Set mathematical constants using known precise values. (102)
Cambridge Books Online © Cambridge University Press, 2012

RULE LIST
313
79. Wherever possible, use allocatable variables rather than data point-
ers. (103)
80. Use allocatable deferred-length character strings wherever possible.
(111)
81. Create simple data structures using derived types with allocatable
components. (113)
82. Use pointers to create dynamic data structures. (115)
83. Use pointers to access array sections and to form arrays of components
of nested derived types. (115)
84. Use pointers to arrays as dummy arguments when it is necessary to
maintain the array bounds of the actual argument. (116)
85. When needed, create an array of pointers by deﬁning a supplemental
derived type with a single component. (117)
86. Avoid assigning an intent (out) attribute to a dummy argument that
is a derived type containing pointer components. (117)
87. Do not use deﬁned assignments for pointer assignment. (119)
88. In a hierarchy of derived types containing allocatable components,
begin allocation with the component of the parent type and proceed
through the hierarchy; deallocate in the reverse order. (120)
89. Establish a convention for tracking the owner of a pointer target.
(123)
90. Use procedure pointers to invoke different subprograms possessing
identical interfaces. (125)
91. Where possible and appropriate, use the intrinsic function kind in
conjuction with the instrinsic conversion functions int , real , and
cmplx when converting types. (128)
92. Use the Fortran intrinsic functions lbound and ubound to determine
both the lower and upper limits of iterations performed using the do
construct and both the lower and upper limits of array assignments
accomplished using both the forall and where statements and the
forall and the where constructs. (131)
93. Use the intrinsic functions shape and reshape when initializing
arrays of rank 2 or larger. (132)
Cambridge Books Online © Cambridge University Press, 2012

314
RULE LIST
94. When specifying the kind of both subprogram dummy arguments
and function results, take advantage of the fact that Fortran knows
the kind of a data type. (132)
95. Always include the stat= option in all allocate and deallocate state-
ments; always check its value. (133)
96. Check the status of allocatable entities using the allocated intrinsic
function before allocating or deallocating them. (134)
97. Write all loops that index arrays of rank 2 or greater such that the
innermost (ﬁrst) rank varies ﬁrst, then the next most inner loop, and
so on. (134)
98. Where possible, assign the contiguous attribute to assumed-shape
arrays and array pointers to improve performance. (135)
99. Code all logical tests that make up the scalar logical expressions of
an if construct such that they can always be successfully executed.
(136)
100. Use a single-pass loop to avoid deeply nested constructs. (136)
101. For portability, use the lexical comparison functions llt , lle , lge,
and lgt to compare character strings. (138)
Chapter 8. Input and Output
102. Use the named constants in the intrinsic module iso fortran env .
(140)
103. Manage unit numbers as a resource. (141)
104. Use the optional iostat= speciﬁer in all input/output statements to
verify that the operation was successful and to control the program
ﬂow. (143)
105. Use open and close statements for all data ﬁles. (144)
106. Use the inquire statement for computing direct-access record length.
(145)
107. When reading or writing arrays, use implied loops only when the
storage order needs to be changed from the default. (146)
108. Use the same formats and I/O lists when writing, and reading back,
a data ﬁle. (146)
109. Read and write only a single data record in each data transfer
statement. (147)
Cambridge Books Online © Cambridge University Press, 2012

RULE LIST
315
110. When writing I/O routines for each derived type, consider using
deﬁned derived-type I/O. (148)
111. Consider using asynchronous I/O to increase the speed of data trans-
fer. (150)
112. Use formatted I/O for human-readable ﬁles. (155)
113. Use named character constants for frequently used format speciﬁca-
tions. (156)
114. For infrequently used format speciﬁcations, use character literals
directly in I/O statements. (157)
115. Use internal read and write statement for converting between char-
acter strings and numeric items. (157)
116. Use format reversion where possible to simplify format statements.
(159)
117. Use unformatted I/O when full numerical accuracy needs to be main-
tained. (160)
118. Issue meaningful error messages. (163)
119. Use meaningful stop statements for error termination. (163)
Chapter 9. Packaging Conventions
120. Place each program unit in a separate ﬁle. (165)
121. Whenever possible, use the module name, the type name, the subpro-
gram name, or the program name as the ﬁle name. (165)
122. Group the interface blocks for all user-deﬁned external procedures
in one or more modules. Use these modules in all procedures where
these external procedures are referenced. (165)
123. Place the declaration of the dummy arguments of external procedures
in a separate ﬁle and then include it using an include line in the ﬁle
containing the procedure and every ﬁle containing its interface block.
(167)
124. Use submodules to separate the interfaces of module procedures from
their implementations. Specify the interface in the parent module
only. (168)
Chapter 10. Generic Programming
125. Use parameterized derived types to create generic code. (172)
Cambridge Books Online © Cambridge University Press, 2012

316
RULE LIST
126. Create generic names for related speciﬁc procedures. (173)
127. Use optional arguments to avoid replication. (176)
128. Use elemental procedures to create rank-insensitive code. (177)
129. Use the result clause for function return values. (178)
130. Use the generic form of intrinsic functions. (179)
131. Use a preprocessor to automate generation of generic code via CoCo.
(180)
132. Use a preprocessor to automate generation of generic code via the C
language preprocessor. (180)
Chapter 11. Object Orientation
133. Deﬁne every derived type in its own module, along with its type-
speciﬁc procedures. (184)
134. Use a unique name for every derived type. (185)
135. Declare any data component of a derived type that is not required
for computation-intensive calculations to be private. Provide access
to its components so declared using type-bound accessor procedures.
(186)
136. Whenever possible, initialize the components of derived types in their
deﬁnition. Always initialize pointer components to null (). (189)
137. Initialize all derived-type parameters in the deﬁnition of parame-
terized derived types. (190)
138. Always use keywords in structure constructors. (191)
139. Always use keywords to specify the values of type parameters when
declaring parameterized derived types and when initializing them
using structure constructors. (193)
140. For derived types requiring extensive initialization, consider using
user-deﬁned structure constructors. (193)
141. For derived types requiring extensive initialization, consider using
a deﬁned assignment. (195)
142. Write type-bound procedures to implement inheritance and poly-
morphism. (197)
143. Create generic speciﬁcations for type-bound bindings that perform
similar tasks but have distinct dummy arguments. (200)
Cambridge Books Online © Cambridge University Press, 2012

RULE LIST
317
144. Use procedure pointer components to invoke different subprograms
possessing identical interfaces. (201)
145. For debugging purposes, for every derived type, write a type-bound
procedure that prints its components. (204)
146. Write type-bound subroutines for deﬁned assignments. (204)
147. Provide a ﬁnal subroutine for all derived types that have pointer
components or that require special handling when they cease to exist.
(205)
148. Be aware of the situations where ﬁnalization occurs. (207)
149. Use type inclusion for Has-A relationships and type extension for
Is-A relationships. (208)
150. Provide an abstract base object type for the application. (210)
151. Provide a concrete base object type for the application. (211)
152. Do not confuse the meaning of a derived data type, keyword type,
with the meaning of a polymorphic variable, keyword class. (213)
153. Use sourced allocation to allocate polymorphic variables. (213)
154. Exploit inheritance and polymorphic dummy arguments to write
generic code. (214)
155. Use the select
type construct to dynamically dispatch polymorphic
data objects to the appropriate type-bound procedure. (214)
156. Use unlimited polymorphic variables to create data structures con-
taining heterogeneous data types. (215)
Chapter 12. Parallel Processing
157. Tune programs to run correctly and as quickly and efﬁciently as
possible as a single thread program running on a single processor
before rewriting them for parallel processing. (217)
158. Estimate the performance improvement that can be realized using
parallel programming methods. (217)
159. Determine the hardware conﬁguration on which the application will
run. (219)
160. Use built-in Fortran data parallelism to replace simple loops that
can execute in parallel. (221)
Cambridge Books Online © Cambridge University Press, 2012

318
RULE LIST
161. Use the OpenMP API to create sections of code that execute in par-
allel. (228)
162. Use default (none) for all parallel regions. (231)
163. Minimize shared variable locking and usage for best scalability.
(231)
164. Use MPI to create multiple instruction, multiple data programs that
execute in parallel. (233)
165. Write an MPI communicator module to tailor its use to the applica-
tion. (238)
166. Minimize the use of communications and barriers. (241)
167. Avoid conditional use of synchronization. (242)
168. Use the do concurrent statement to write loops that execute in paral-
lel. (242)
169. Use coarrays to write programs that execute in parallel. (243)
Chapter 13. Data Types, Numerical Operations, and
Floating-Point Numbers
170. Based on application numerical requirements, and using Fortran
instrinsic functions such as selected int kind and selected real kind,
establish a set of integer-named constants that correspond to the kind
type parameters needed. Place them all in a single module, and use
these constants in the deﬁnition of program data objects. (248)
171. Never write code depending upon ﬂoating-point equality. (250)
172. Write code that performs ﬂoating-point operations in a manner that
reduces rounding errors. (251)
173. Avoid performing ﬂoating-point operations involving numbers of
widely different orders of magnitude. (253)
174. Use
the
capabilities
of
intrinsic
modules
IEEE exceptions,
IEEE arithmetic, and IEEE features to trap ﬂoating-point exceptions.
(253)
175. Use high-level bit manipulation. (258)
176. Avoid unwanted data conversion problems. (259)
Cambridge Books Online © Cambridge University Press, 2012

RULE LIST
319
Chapter 14. C Interoperability
177. Use Fortran’s C interoperability capabilities to interact with C pro-
grams. (262)
178. Pass Fortran character arguments to C as length-1, character arrays
with a ﬁnal element of C CHAR NULL. (267)
179. Pass scalar arguments by value when using C interoperability. (268)
180. Design out potential “buffer overrun” problems. (269)
181. Use extern "C" in C++ ﬁles to allow interoperability with Fortran.
(269)
182. Do not throw C++ exceptions through Fortran procedures. (270)
Chapter 15. Updating Old Programs
183. Replace common blocks with modules. (271)
184. Remove block data program units. Use initializers with module scope
data. (273)
185. Replace multiple entry point procedures with separate module pro-
cedures that can share data scope. (273)
186. Replace alternate returns with structured code. (275)
187. Replace arithmetic if statements with case or block if constructs.
(277)
188. Replace computed GOTO statements with case constructs. (277)
189. Replace assigned GOTO with structured constructs. (278)
190. Replace statement functions with internal procedures. (280)
191. Replace PAUSE statements with normal I/O and stop statements.
(280)
192. Use the character (length-selector) form to declare all character vari-
ables, arrays, and named constants. (281)
193. Replace double precision or any other type declaration that explicitly
speciﬁes the storage size, with kind speciﬁcations. (281)
194. Do not use real or double precision do variables. (281)
195. Replace Hollerith constants with character data type. (282)
196. Replace Hollerith, H, edit descriptors with quoted strings. (283)
Cambridge Books Online © Cambridge University Press, 2012

320
RULE LIST
197. Do not branch to an end if statement from outside its block. (283)
198. Replace nonblock do constructs with block versions. (283)
199. Replace all decode and encode statements with read and write state-
ments using internal ﬁles. (284)
200. Replace the BYTE data declarations with the appropriate integer
kind. (285)
201. Replace structures, records, unions, and maps with derived types.
(286)
202. Replace integer pointers with allocatable arrays. (287)
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

Bibliography
[1] Adams, Jeanne C., Walter S. Brainerd, Richard A. Hendrickson, Richard E.
Maine, Jeanne T. Martin, and Brian T. Smith. The Fortran 2003 Handbook:
The Complete Syntax, Features and Procedures. Springer, 2009.
[2] Adams, Jeanne C., Walter S. Brainerd, Jeanne T. Martin, Brian T. Smith,
and Jerrold L. Wagener. Fortran 95 Handbook: Complete ISO/ANSI Reference.
Cambridge, MA: The MIT Press, 1997.
[3] Adams, Jeanne C., Walter S. Brainerd, Jeanne T. Martin, Brian T. Smith,
and Jerrold L. Wagener. Fortran 90 Handbook: Complete ISO/ANSI Refer-
ence. New York: Intertext Publications, The McGraw Hill Book Company,
1992.
[4] Akin, Ed. Object-Oriented Programming via Fortran 90/95. Cambridge,
United Kingdom: Cambridge University Press, 2003.
[5] Anderson, E., Z. Bai, C. Bischof, J. Demmel, J. Dongarra, J. Du Croz,
A. Greenbaum, S. Hammarling, A. McKenney, S. Ostrouchov, and D.
Sorensen. LAPACK User’s Guide. 2nd ed. Philadelphia: Society for Industrial
and Applied Mathematics, 1995.
[6] Amdahl, Gene. “Validity of the Single Processor Approach to Achiev-
ing Large-Scale Computing Capabilities.” AFIPS Conference Proceedings,
no. 30 (1967): 483–485.
[7] Blelloch, Guy E. Vector Models for Data-Parallel Computing. Cambridge,
MA: MIT Press, 1990.
[8] Budd, Timothy. An Introduction to Object-Oriented Programming. 3rd ed.
Boston: Pearson Education, Inc., 2002.
[9] Baldwin, Kenneth, Andrew Gray, and Trevor Misfeldt. The Elements of C#
Style. New York: Cambridge University Press, 2006.
[10] Brainerd, Walter S., Charles H. Goldberg, and Jeanne C. Adams. Program-
mer’s Guide to Fortran 90. 3rd ed. New York: Springer-Verlag, 1996.
[11] Chandra, Rohit, Dagum Leonardo, Dave Kohr, Dror Maydan, Jeff McDon-
ald, and Ramesh Menon. Parallel Programming in OpenMP. San Diego, CA:
Academic Press, 2001.
[12] Chapman, Stephen J. Fortran 95/2003 for Scientists and Engineers. 3rd ed.
New York: McGraw-Hill, 2008.
321
Cambridge Books Online © Cambridge University Press, 2012

322
BIBLIOGRAPHY
[13] Chapman, Barbara, Gabriele Jost, and Ruud Van Der Pas. Using OpenMP:
Portable Shared Memory Parallel Programming. Cambridge, MA: MIT Press,
2008.
[14] Clerman, Norman S. “Fortran 90 ’Gotcha!’ (variation on a theme).” Fortran
Forum, Association for Computing Machinery, 18, no. 3, December 1999.
[15] Clerman, Norman S. “Notes on creating an array of procedure pointers.”
Fortran Forum, Association for Computing Machinery, 28, no. 1, April
2009.
[16] Concurrent Versions System, http://www.nongnu.org/cvs.
[17] Decyk, Victor K., Charles D. Norton, and Boleslaw K. Szymanski. “For-
tran 90 ’Gotchas’ (Part 1).” Fortran Forum, Association for Computing
Machinery, 18, no. 2, August 1999.
[18] Decyk, Victor K., and Charles D. Norton. “Fortran 90 ’Gotchas’ (Part 3).”
Fortran Forum, Association for Computing Machinery, 19, no. 1, April
2000.
[19] Program coco, Purple Sage Computing, Inc., http://users.erols.com/
dnagle/coco.html.
[20] Dongarra, J. J., C. B. Moler, J. R. Bunch, and G. W. Stewart. LINPACK:
Users’ Guide. Philadelphia, PA: Society for Industrial and Applied Mathe-
matics, 1979.
[21] Dorn, William S., and Daniel D. McCracken. Numerical Methods with
Fortran IV Case Studies. New York: John Wiley & Sons, Inc., 1972.
[22] Dowd, Kevin, and Charles Severance. High Performance Computing. 2nd ed.
Sebastopol, CA: O’Reilly & Associates, Inc., 1998.
[23] Earth System Modeling Framework, http://www.earthsystemmodeling.org.
ESMF KeywordEnforcer arguments were based on a suggestion by Alan
Wallcraft of the Noval Research Laboratories.
[24] Ellis, T. M. R., and Ivor R. Philips. Programming in F. Harlow, England:
Addison Wesley Longman, Limited, 1998.
[25] Goldberg, David. “What Every Computer Scientist Should Know About
Floating Point Arithmetic.” ACM Computing Surveys, 23, no. 1 (1991):
5–48.
[26] Gropp, William, Ewing Lusk, and Rajeev Thakur. Using MPI-2: Portable
Parallel Programming with the Message-Passing Interface. Cambridge, MA:
MIT Press, 1999.
[27] Gropp, William, Ewing Lusk, and Anthony Skjellum. Using MPI-2: Portable
Parallel Programming with the Message-Passing Interface. 2nd ed. Cambridge,
MA: MIT Press, 1999.
[28] Harbison, Samuel P., and Guy L. Steele Jr. C – A Reference Manual. 5th ed.
Upper Saddle River, NJ: Prentice Hall, 2002.
Cambridge Books Online © Cambridge University Press, 2012

BIBLIOGRAPHY
323
[29] Hughes, Charles E., Charles P. Pﬂeeger, and Lawrence L. Rose. Advanced
Programming Techniques: A Second Course in Programming Using FORTRAN.
New York: John Wiley & Sons, 1978.
[30] ISO/IEC TR 15580:2001(E), Information technology – Programming lan-
guages – Fortran – Floating-point exception handling. ISO/IEC JTC 1/SC
22/WG 5, 2001.
[31] ISO/IEC/JTC/SC 22 SO/IEC TR 15581:1999(E), Information technology –
Programming languages – Fortran – Enhanced data type facilities. 2nd ed.
2000.
[32] ISO/IEC/JTC/SC 22 SO/IEC TR 19767:2005, Information technology – Pro-
gramming languages – Fortran – Enhanced Module Facilities. 2005.
[33] Binary ﬂoating-point arithmetic for microprocessor systems. IEC 60669 (1989-
01).
[34] ISO/IEC 7942-1: Information technology – Computer graphics and image
processing – Graphical Kernal System (GKS) – Part 1: Functional Description.
2nd ed. 1994.
[35] ISO 8651-1 Information processing systems – Computer graphics – Graphical
Kernal System (GKS) language bindings – Part 1: FORTRAN. 1988.
[36] ISO/IEC 8651-4 Information technology – Computer graphics – Graphical
Kernal System (GKS) language bindings – Part 4: C. 2nd ed. 1995.
[37] ISO 9241 – Ergonomics of Human System Interaction. Geneva, Switzerland:
International Standards Organization.
[38] ISO/IEC 9899:1999 (C99). Geneva, Swizerland: International Standards
Organization.
[39] ISO/IEC 1539-1:2004 Information technology – Programming languages –
Fortran – Part 1: Base language. 2nd ed. 2004.
[40] ISO/IEC 1539:1991 Information technology – Programming languages – For-
tran. 2nd ed. 1991.
[41] f90gl, Fortran bindings for OpenGL. http://math.nist.gov/f90gl.
[42] ISO/IEC 1539-1:1997 Information technology – Programming languages –
Fortran – Part 1: Base language. 1997.
[43] ISO/IEC JTC1/SC22/WG5/N1723 J3/08-007r2 March 2008.
[44] Hatton, Les. Fortran, C, or C++ for geophysical development. Journal of
Seismic Exploration, January 1992.
[45] Kernigan, B., and P. Plauger. The Elements of Programming Style. 2nd ed.
New York: McGraw-Hill, 1978.
[46] Kernighan, Brian W., and Dennis M. Ritchie. The C Programming Language.
2nd ed. Englewood Cliffs, NJ: Prentice-Hall, 1988.
Cambridge Books Online © Cambridge University Press, 2012

324
BIBLIOGRAPHY
[47] Kit, Edward. Software Testing in the Real World: Improving the Process. ACM
Press, 1995.
[48] Koelbel, Charles H., David B. Loveman, Robert S. Schreiber, Guy L. Steele
Jr., and Mary E. Zosel. The High Performance Fortran Handbook. Cambridge,
MA: MIT Press, 1994.
[49] McVoy, Larry, and Carl Staelin. http://www.bitmover.com/lmbench.
[50] LAM/MPI parallel computing. http://www.lam-mpi.org/.
[51] Mattson, Timothy G., Beverly A. Sanders, and Berna L. Massingill. Patterns
for Parallel Programming. Boston, MA: Pearson Education, Inc., 2005.
[52] McConnell, Steve. Code Complete. Redmond, WA: Microsoft Press, 1993.
[53] McConnell, Steve. Code Complete. 2nd ed. Redmond, WA: Microsoft Press,
2004.
[54] Metcalf, Michael, and John Reid. The F Programming Language. New York:
Oxford University Press, 1996.
[55] Metcalf, Michael, John Reid, and Malcolm Cohen. Fortran 95/2003
Explained. Oxford, United Kingdom: Oxford University Press, 2004.
[56] Metcalf, Michael. Effective FORTRAN 77. Oxford, United Kingdom:
Oxford University Press, Reprint with corrections, 1986.
[57] Misfeldt, Trevor, Gregory Bumgardner, and Andrew Gray. The Elements of
C++ Style. New York: Cambridge University Press, 2004.
[58] MPICH – a portable implementation of MPI. http://www-unix.mcs.
anl.gov/mpi/mpich.
[59] netcdf, A Network Common Data Format. http://www.unidata.ucar.
edu/software/netcdf.
[60] Netlib Repository at UTK and ORNL. http://www.netlib.org.
[61] Oliveira, Suely, and David Stewart. Writing Scientiﬁc Software: A Guide to
Good Style. New York: Cambridge University Press, 2006.
[62] OpenMP: Simple, portable, scalable SMP programming. http://www.
openmp.org.
[63] IEEE Std 1003.9-1992 IEEE Standard for Information technology – POSIX
FORTRAN 77 Language Interfaces – Part 1: Binding for System Application
Interface [API]. Institute of Electrical and Electronics Engineers, Inc., 1992.
[64] Reid, John. Coarrays in the next Fortran Standard. ISO/IEC JTC1/
SC22/WG5 N1747, October 31, 2008.
[65] Roark, Raymond J., and Warren C. Young. Formulas for Stress and Strain.
5th ed. New York: McGraw-Hill, 1975.
[66] Roberts, Eric. Thinking Recursively. New York: John Wiley & Sons, 1984.
Cambridge Books Online © Cambridge University Press, 2012

BIBLIOGRAPHY
325
[67] Sale, A. H. J. The Classiﬁcation of FORTRAN Statements. The Computer
Journal 14, no. 1.
[68] United States Public Law 107–204, Sarbanes-Oxley Act of 2002.
[69] Shonkwiler, Ronald W., and Lew Lefton. An Introduction to Parallel and
Vector Scientiﬁc Computing. New York: Cambridge University Press, 2006.
[70] Siever, Ellen, Stephen Figgins, and Aaron Weber. Linux in a Nutshell: A Desk-
top Quick Reference. 4th ed. Sabastopol, CA: O’Reilly Press & Associated,
Inc., 2003.
[71] Smith, Alan Jay. Cache Memories. ACM Computing Surveys, September
1982.
[72] Steele Jr., Guy L., and W. Daniel Hillis. Data Parallel Algorithms. Commu-
nications of the ACM, December 1986.
[73] Stroustrup, Bjarne. The C++ Programming Language. 3rd ed. Upper Saddle
River, NJ: Addison-Wesley, 1997.
[74] Apache Subversion, http://subversion.apache.org/.
[75] Vermeulen, Allan, Scott W. Ambler, Greg Bumgardner, Eldon Metz, Trevor
Misfeldt, Jim Shur, and Patrick Thompson. The Elements of Java Style. New
York: Cambridge University Press, 2000.
[76] von Hagen, William. The Deﬁnitive Guide to GCC. 2nd ed. Berkeley, CA:
Apress, 2006.
[77] Vowels, R. A. Algorithms and Data Structures in F and Fortran. Tucson, AZ:
Unicomp, 1998.
[78] Zwillinger, Daniel. Standard Mathematical Tables and Formulae. 31st ed.
Boca Raton, FL: Chapman and Hall/CRC Press LLC, 2003.
Cambridge Books Online © Cambridge University Press, 2012

Cambridge Books Online © Cambridge University Press, 2012

Index
abstract derived type, 210
access = speciﬁcation, 161
accessor procedure, 25, 46, 132, 177, 186
action speciﬁcation, 144
aliasing, 94
all intrinsic procedure, 227
allocatable
array, 103
character, 111
codimension, 246
polymorphic variable, 213
scalar, 111
allocatable attribute, 18, 99, 102, 120,
123, 205, 246
allocate statement, 29, 111, 120, 123, 133
allocated intrinsic procedure, 134
alternate return, 275
Amdahl’s Law, 217
any intrinsic procedure, 227
argument-types, 85
arguments, 78
actual, 62, 63, 69, 74, 79
dummy, 41, 50, 53, 56, 57, 62, 69, 77, 82,
116, 117, 167, 197,
213
optional, 74, 77, 79, 171, 176
passed-object dummy, 199, 201,
214
passing, 82
procedure, 125
veriﬁcation, 5
arithmetic if statement, 277
array
allocatable, 103
section, 222
array constructor, 22
array of pointers, 117
array section, 115
ASCII, 138
assigned goto statement, 278
associate construct, 14, 34, 35, 94
associated intrinsic procedure, 99
assumed-length character, 82, 101
assumed-shape array, 71, 80
assumed-size array, 71, 80
asynchronous attribute, 96, 151
asynchronous I/O
wait, 150
attribute
allocatable, 18, 99, 102, 120, 123, 205,
246
asynchronous, 96, 151
bind, 264
class, 110, 213, 214
codimension, 243
contiguous, 135
dimension, 18, 99
extends, 28, 209
external, 165
intent, 50, 53, 57, 74, 117
non-overridable, 212
nopass, 201
optional, 18, 74, 77, 79
parameter, 99, 101
pass, 74, 201
pointer, 18, 29, 62, 65, 99, 103, 115,
116, 117, 119, 125, 205, 213
private, 47, 48, 49, 99, 186, 198, 212
protected, 46, 47
public, 47, 49, 80, 99, 186, 187, 198
327
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

328
INDEX
attribute (cont.)
save, 46, 47, 56, 89, 99, 100, 103,
104, 111
target, 18, 62, 94, 99
value, 60
volatile, 96, 151
attributes, 99
backspace statement, 143, 160
base object, 210, 211
bind(C) statement, 263
bind attribute, 264
bind statement, 262
bisection bandwidth, 225
bit size intrinsic procedure, 260
blank common, 271
block, 34
block construct, 137
broadcasting, 222
byte, 285
C
companion compiler, 263
interoperability, 81, 263
preprocessor, 180
c f pointer intrinsic procedure, 287
cache, 134, 218
case, 10
case construct, 129
central processing unit, 134
character intrinsic type, 82, 101, 111,
281
character statement, 111
character set, 10, 33
class attribute, 110, 213, 214
class is statement, 214
class keyword, 183, 213, 214
close statement, 141, 143, 144
cmplx intrinsic procedure, 128
coarray, 5, 23, 243
coarrays, 216
CoCo preprocessor, 180
code
format, 20
code blocks, 14
codimension attribute, 243
common block, 271, 273
compilation cascade, 165, 167
component
procedure pointer, 126
computed goto statement, 277
conditional compilation, 180
construct
associate, 14, 34, 35, 94
block, 137
case, 129
do concurrent, 5, 57, 216,
222
do, 14, 34, 131, 281, 284
forall, 14, 34, 55, 131, 223
if, 14, 34, 136, 277, 283
select case, 14, 34, 276, 278, 279
select type, 214
where, 14, 34, 55, 131, 226
constructs, 14, 15, 34, 136
named, 34, 35
container procedures, 211, 215, 295
contains statement, 104, 198
contiguous attribute, 135
continuation
line, 15, 20
mark, 20
continue statement, 136, 283
count intrinsic procedure, 227
CPU, 134
Cray pointers, 287
cshift intrinsic procedure, 224
CVS, 41
cycle statement, 34
data parallel computing, 220, 221
deadlock, 242
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

INDEX
329
deallocate statement, 133
debugging, 204
decode, 284
deep copy, 114
deferred type-bound procedures, 210
deﬁned assignment, 119, 195, 204
derived type, 28, 50, 78, 102, 120,
123, 184, 185, 189, 204,
213
derived-type I/O (DTIO), 148, 204
derived-type parameter, 190, 193
dimension attribute, 18, 99
distributed memory, 219
do concurrent construct, 5, 57, 216, 222
do construct, 14, 34, 131, 281, 284
do variable, 33, 281
double precision, 281
dummy argument, 53, 57, 116, 117
dynamic data structures, 113, 115
EBCDIC, 138
edit
descriptor, 282, 283
elemental procedures, 79, 171, 177,
222
elemental operation, 222
encapsulation, 183, 186
encode, 284
end = speciﬁcation, 143
endﬁle statement, 143
entry statement, 273
eoshift intrinsic procedure, 224
equivalence statement, 94
err = speciﬁcation, 143
errmsg = option, 133
Error messages, 163
ERROR UNIT intrinsic named constant,
141
exit statement, 34
explicit-shape array, 71
explicit-shape arrays, 80
extends attribute, 28, 209
external attribute, 165
external statement, 125
external subprogram, 80, 165, 167
ﬁle, 165
ﬁle speciﬁcation, 144
ﬁle storage units, 145
ﬁnal statement, 26, 205
ﬁnal subroutine, 26, 119, 205, 207
ﬁnalization, 26, 205, 207
ﬂoating point
exception handling, 253
literal, 23
ﬂoating-point equality, 250
fmt = speciﬁcation, 155, 160
forall construct, 14, 34, 55, 131,
223
forall statement, 55, 56, 131, 223
fork/join, 220
form = speciﬁcation, 160
format
reversion, 146, 159
speciﬁcation, 156, 157
format statement, 146, 155, 159
free source form, 9
function, 53
garbage collection, 123
generic binding, 171, 200
generic interface block, 171, 173
generic procedure, 171
get command arg intrinsic procedure, 7
global variable, 46, 271, 273
go to statement, 136
gprof, 217
Graphical Kernal System, 78
high performance Fortran, 220
hybrid systems, 220
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

330
INDEX
I/O
asynchronous, 150
formatted, 155
list, 146, 159
list directed, 148, 156
namelist, 148, 156
sequential access, 160
stream access, 161
unformatted, 160
iand intrinsic procedure, 258
ibclr intrinsic procedure, 259
ibits intrinsic procedure, 258
ibset intrinsic procedure, 259
IEEE arithmetic intrinsic module, 253
IEEE exceptions intrinsic module, 253
IEEE features intrinsic module, 253
ieor intrinsic procedure, 258,
260
if construct, 14, 34, 136, 277, 283
implicit none statement, 34, 44,
98
implicit typing, 33, 98
import statement, 98
impure procedures, 57
include line, 20, 167, 271
indentation, 13
inheritance, 173, 183
input/output statement, 143
INPUT UNIT intrinsic named constant,
141
inquire statement, 142, 143, 145
instantiation, 183, 197
int intrinsic procedure, 128
intent attribute, 50, 53, 57, 74, 117
interface, 168
interface block, 80, 98, 165, 167
internal ﬁle, 284
internal procedure, 13
interoperability with C, 81, 263
intrinsic module
iso c binding, 262, 287
iso fortran env, 140, 143
intrinsic named constant
ERROR UNIT, 141
INPUT UNIT, 141
IOSTAT END, 143
IOSTAT EOR, 143
OUTPUT UNIT, 141
intrinsic procedure
allocated, 134
all, 227
any, 227
associated, 99
bit size, 260
c f pointer, 287
cmplx, 128
count, 227
cshift, 224
eoshift, 224
get command arg, 7
iand, 258
ibclr, 259
ibits, 258
ibset, 259
ieor, 258, 260
int, 128
ior, 258
is contiguous, 135
ishftc, 258
ishft, 258
kind, 128, 132, 281
len, 82
lge, 138
lgt, 138
lle, 138
llt, 138
maxval, 227
merge, 226
minval, 227
move alloc, 109
mvbits, 259
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

INDEX
331
not, 258
nullify, 100
null, 57, 99, 117, 189, 204
pack, 227
popcnt, 260
present, 77
product, 227
real, 128
reshape, 132, 225
selected int kind, 128, 248,
281
selected real kind, 128, 248, 281
shape, 132
sum, 227
transfer, 260
transpose, 225
ubound, 131
unpack, 227
intrinsic type
character, 82, 101, 111, 281
intrinsic elemental functions, 223
intrinsic function, 179
intrinsic module
IEEE arithmetic, 253
IEEE exceptions, 253
IEEE features, 253
iso c binding, 262
iso fortran env, 249
intrinsic type, 248
iomsg = speciﬁcation, 143
iomsg speciﬁcation, 144
ior intrinsic procedure, 258
IOSTAT END intrinsic named constant,
143
IOSTAT EOR intrinsic named constant,
143
iostat = speciﬁcation, 143
iostat speciﬁcation, 140, 144
is contiguous intrinsic procedure, 135
ishft intrinsic procedure, 258
ishftc intrinsic procedure, 258
iso c binding intrinsic module, 262, 287
iso fortran env intrinsic module, 140,
143
iso fortran env intrinsic module, 141,
143
Java, 210
keyword, 17, 18, 191, 193, 213
argument, 79
keyword
class, 183, 213, 214
kind intrinsic procedure, 128, 132,
281
labels, 15
latency, 241
len intrinsic procedure, 82
lexical comparison functions, 138
lge intrinsic procedure, 138
lgt intrinsic procedure, 138
lle intrinsic procedure, 138
llt intrinsic procedure, 138
lmdd, 151
loc, 287
logical unit number, 140, 141
loop parallelism, 220
lowerCamelCase, 12
magic number, 101
make, 170, 179
Maps, 286
maxval intrinsic procedure, 227
memory
distributed, 219
leak, 63, 103, 123
shared, 219
merge intrinsic procedure, 226
message passing, 183, 221
methods, 183, 197
MIMD, 219
minval intrinsic procedure, 227
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

332
INDEX
module, 44, 271, 273
names, 24
move alloc intrinsic procedure,
109
MPI, 5, 216, 221, 233, 243
barrier, 236, 242
broadcasts, 238
communicator, 234, 239
process environment, 233, 243
reductions, 238
synchronization, 235
mvbits intrinsic procedure, 259
named common, 271
named constant, 99, 101, 156, 248
newunit speciﬁcation, 142
non-overridable attribute, 212
nonblock do, 281, 283
nopass attribute, 201
not intrinsic procedure, 258
null intrinsic procedure, 57, 99, 117, 189,
204
nullify intrinsic procedure, 100
Numerical Algorithm Group, 52, 68
numeric storage units, 145
object-oriented programming
inheritance, 173
overloading, 173
only option, 47, 49, 198
open statement, 143, 144, 160
OpenMP, 5, 216, 220, 221, 228
option
errmsg =, 133
stat =, 133
optional attribute, 18, 74, 77, 79
OUTPUT UNIT intrinsic named constant,
141
overloading, 173
pack intrinsic procedure, 227
parameter attribute, 99, 101
parameterized derived type, 171, 172, 190,
193
pass attribute, 74, 201
passed-object dummy argument, 199, 201,
214
pause statement, 280
pointer, 120, 123
dangling, 65
pointer attribute, 18, 29, 62, 65, 99,
103, 115, 116, 117, 119, 125, 205,
213
polymorphism, 110, 183, 213, 295
popcnt intrinsic procedure, 260
POSIX, 163, 263
preconnection, 141
present intrinsic procedure, 77
private attribute, 47, 48, 49, 99, 186, 198,
212
procedure
accessor, 25, 46, 132, 177, 186
names, 24, 25, 26
procedure statement, 126
procedure components, 125, 201
procedure pointers, 74, 125, 201
processing element, 219
product intrinsic procedure, 227
prof, 217
proﬁler, 217
program unit, 18, 41, 44, 165, 273
protected attribute, 46, 47
public attribute, 47, 49, 80, 99, 186, 187,
198
pure preﬁx, 56
pure procedure, 53, 178, 230
read statement, 141, 143, 155, 160, 284
real intrinsic procedure, 128
real statement, 281
Records, 286
recursion, 86, 295
reduction operation, 227, 229, 238
relational operator, 22
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

INDEX
333
reshape intrinsic procedure, 132, 225
result clause, 32, 178
return statement, 275
rewind statement, 143
Sarbanes-Oxley, 6
save attribute, 46, 47, 56, 89, 99, 100, 103,
104, 111
save statement, 47
scope, 13, 47
select case construct, 14, 34, 276, 278,
279
select type construct, 214
selected int kind intrinsic procedure, 128,
248, 281
selected real kind intrinsic procedure,
128, 248, 281
sequence statement, 156, 185
sequence type, 185
shape intrinsic procedure, 132
shared memory, 219
side effect, 53, 56, 90, 230
signiﬁcant blanks, 9
SIMD, 219
SISD, 219
source code ﬁles, 165
source control, 6
source form
free, 9, 228
sourced allocation, 110, 213, 295
speciﬁcation
access =, 161
action, 144
end =, 143
err =, 143
ﬁle, 144
fmt =, 155, 160
form =, 160
iomsg =, 143
iomsg, 144
iostat =, 143
iostat, 140, 144
newunit, 142
status, 144
SPMD, 220, 243
square brackets, 22
standard input, 141
standard output, 141
stat = option, 133
statement
allocate, 29, 111, 120, 123, 133
arithmetic if, 277
assigned goto, 278
backspace, 143, 160
bind(C), 263
bind, 262
character, 111
class is, 214
close, 141, 143, 144
computed goto, 277
contains, 104, 198
continue, 136, 283
cycle, 34
deallocate, 133
endﬁle, 143
entry, 273
equivalence, 94
exit, 34
external, 125
ﬁnal, 26, 205
forall, 55, 56, 131, 223
format, 146, 155, 159
go to, 136
implicit none, 34, 44, 98
import, 98
inquire, 142, 143, 145
open, 143, 144, 160
pause, 280
procedure, 126
read, 141, 143, 155, 160, 284
real, 281
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

334
INDEX
statement (cont.)
return, 275
rewind, 143
save, 47
sequence, 156, 185
stop, 56, 163
type is, 214
use, 49, 186, 272
where, 55, 131, 226
write, 141, 143, 155, 160, 284
statement function, 280
status speciﬁcation, 144
Stop statement, 163
stop statement, 56, 163
structure constructor, 28, 189, 191, 193
Structures, 286
submodule, 168
subprograms, 82
sum intrinsic procedure, 227
tabs, 20
tail recursion, 89
target attribute, 18, 62, 94, 99
telephone test, 4
transfer intrinsic procedure, 260
transformational intrinsic procedures, 224
transpose intrinsic procedure, 225
type, 213, 317
type-bound procedure, 12, 74, 93, 197,
204
type extension, 183, 208
type inclusion, 208
type is statement, 214
ubound intrinsic procedure, 131
Unicode, 139
Unions, 286
unit of execution, 219
unit testing, 4
unlimited polymorphic entity, 215, 295
unnamed common, 271
unpack intrinsic procedure, 227
UpperCamelCase, 11
use association, 47, 186
use statement, 49, 186, 272
value attribute, 60
variables
global, 46, 271, 273
version control system, 41
volatile attribute, 96, 151
von Neumann, 219
where construct, 14, 34, 55, 131, 226
where statement, 55, 131, 226
write statement, 141, 143, 155, 160,
284
http://ebooks.cambridge.org/ebook.jsf?bid=CBO9781139027687
Cambridge Books Online © Cambridge University Press, 2012

