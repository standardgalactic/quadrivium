The call-by-value lambda-calculus,
the SECD machine, and the
pi-calculus
Vasco T. Vasconcelos
DI‚ÄìFCUL
TR‚Äì00‚Äì3
May 2000
Departamento de Inform¬¥atica
Faculdade de CiÀÜencias da Universidade de Lisboa
Campo Grande, 1749‚Äì016 Lisboa
Portugal
Technical reports are available at http://www.di.fc.ul.pt/biblioteca/tech-reports.
The Ô¨Åles are stored in PDF, with the report number as Ô¨Ålename. Alternatively, reports
are available by post from the above address.

Abstract
We present an encoding of the call-by-value lambda-calculus into the pi-calculus,
alternative to the well-known Milner‚Äôs encodings. We show that our encoding
is barbed congruent (under typed contexts) to Milner‚Äôs ‚Äúlight‚Äù encoding, and
that it takes two pi-steps to mimic a beta-reduction for normalizing terms.
We describe a translation of Plotkin‚Äôs SECD machine into the pi-calculus,
and show that there is an operational correspondence between a SECD machine
and its encoding.
Equipped with a notion of state-based machine and two kinds of correspon-
dences between them, we compare the encodings of the call-by-value lambda-
calculus and the SECD machine into the pi-calculus.

Contents
1
Introduction
2
2
The correspondences
4
2.1
Machines and correspondences
. . . . . . . . . . . . . . . . . . .
4
2.2
Some properties of convergences
. . . . . . . . . . . . . . . . . .
5
2.3
Summary of the correspondences . . . . . . . . . . . . . . . . . .
6
3
The call-by-value Œª-calculus
8
4
The SECD machine
9
5
The œÄ-calculus
11
5.1
Syntax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
11
5.2
Reduction semantics . . . . . . . . . . . . . . . . . . . . . . . . .
11
5.3
Input/output types . . . . . . . . . . . . . . . . . . . . . . . . . .
12
5.4
Contexts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
13
5.5
Behavioural equality . . . . . . . . . . . . . . . . . . . . . . . . .
13
5.6
Replication theorems . . . . . . . . . . . . . . . . . . . . . . . . .
13
6
Encoding the cbv-Œª into œÄ
15
6.1
The encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
6.2
Typing the encoding . . . . . . . . . . . . . . . . . . . . . . . . .
18
6.3
Convergence correspondence . . . . . . . . . . . . . . . . . . . . .
19
6.4
Weak operational correspondence . . . . . . . . . . . . . . . . . .
21
6.5
Further optimizations
. . . . . . . . . . . . . . . . . . . . . . . .
23
7
Comparison with Milner‚Äôs encoding
25
7.1
The encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
25
7.2
Comparing
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
8
Encoding the SECD machine into œÄ
28
8.1
The encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
8.2
Operational correspondence . . . . . . . . . . . . . . . . . . . . .
30
9
Conclusion
33
1

Chapter 1
Introduction
Most concurrent programs include large pieces of sequential code. While the
eÔ¨Écient compilation schemes for sequential (functional) languages are certainly
not based on the pi-calculus, the sequential code of pi-based concurrent pro-
gramming languages is often interpreted in a pi-calculus machine [6, 17]. For
a smooth integration of functional computations into œÄ-based concurrent lan-
guages, Œª-terms are compiled into œÄ-processes and run as ordinary processes.
In this setting, the eÔ¨Éciency of the encoding, more precisely, the number of
reduction steps in the œÄ-calculus needed to mimic a Œ≤-reduction, becomes of
paramount importance.
We study an encoding of the call-by-value Œª-calculus [14] into the œÄ-
calculus [3, 10], alternative to the ones proposed by Milner [8].
The encod-
ing is not new; it was presented before in the context of idioms for concurrent
programming languages [18, 19]; we now analyze its behavior.
The SECD machine [14] was studied by Plotkin as a simpliÔ¨Åcation of Landin‚Äôs
ISWIM [5] machine, and reÔ¨Çects the behaviour of stack-based implementations
of functional languages. We present an encoding of the SECD machine in the œÄ-
calculus, based on the above mentioned encoding of the call-by-value Œª-calculus
into the œÄ-calculus.
To compare the call-by-value Œª-calculus, the SECD machine and the two
encodings of Œª into œÄ, we set up four state-based machines, each composed of
a set of states, a transition relation, and an equivalence relation. Given two
such machines, and a pair of encoding/decoding mappings between them, we
deÔ¨Åne two kinds of correspondences: the usual operational correspondence, and
a convergence correspondence where a state and its image can only be compared
when reduction is no longer possible.
In this setting, we show that our encoding of the call-by-value Œª-calculus is
convergent (but not operational), and that the encoding of the SECD machine
is operational, thus revealing that our encoding closely behaves as stack-based
implementations (with call-return) of functional languages. From the literature
we know that the encoding of the call-by-value Œª-calculus into SECD is conver-
gent [14], and Milner‚Äôs encoding is operational [16]. Section 2.3 summarizes the
correspondences.
Our encoding is similar to Milner‚Äôs ‚Äúlight version‚Äù [4, 9, 12, 16]: it compiles
a Œª-term into a œÄ-process, given a name (the location of the term) that may be
used to interacted with the compiled term. Furthermore, encoded terms only
2

behave correctly when placed in controlled contexts, namely contexts governed
by input-output types [12]. However, contrary to the above mentioned encodings
that, given a Œª-term and a name, return a œÄ-process ready to run, we further
require the scope (in the form of a process) where the encoded term is to be
used. In other words, our compilation scheme returns a context with a hole
that deÔ¨Ånes the scope where the encoded term may be accessed. In order to
run the encoded term we need to Ô¨Åll the hole with a process that invokes the
term. In this way, not only do we exert a Ô¨Åner control on the scope where the
encoded term is to be used, but, more importantly, we may directly instantiate
in the hole the location of the term. In contrast, Milner‚Äôs encoding sends this
location to some user-deÔ¨Åned receptor that sets up the scope. This mechanism
ultimately allows us to save one message exchange per Œ≤-reduction, with respect
to Milner‚Äôs encoding.
The usage of contexts also simpliÔ¨Åes the incorporation of pieces of sequential
code in concurrent programs. The œÄ-calculus allows names to carry names only;
we write xy to denote the sending of name y on channel x. We would often like
to send an arbitrary Œª-term on a channel; for example, we would like to write
xM to denote the sending of the (cbv normal-form of the) Œª-term M on channel
x. With our scheme, such an ‚Äúextended‚Äù œÄ-process can be interpreted as the
process obtained by compiling M into a process located at some (fresh) name
a valid only in the scope denoted by the process xa, written [[M]]axa.
SpeciÔ¨Åcally, we show that
1. the encoding of the call-by-value Œª-calculus is convergent;
2. the encoding of the SECD machine is operational;
3. the cbv Œª-encoding is barbed congruent to Milner‚Äôs ‚Äúlight‚Äù encoding.
The outline of the paper is as follows. The next section introduces the notion
of operational and convergence correspondences and presents a summary of the
correspondences discussed in the paper.
The following three sections brieÔ¨Çy
introduce the call-by-value Œª-calculus, the SECD machine, and the œÄ-calculus.
Then, section 6 studies the encoding of the call-by-value Œª-calculus; and section 7
compares to Milner‚Äôs encoding. Section 8 is dedicated to the study of the SECD
encoding. Section 9 concludes the paper.
3

Chapter 2
The correspondences
This chapter introduces the notions of machines and correspondences between
them, and summarizes the correspondences discussed in the paper.
2.1
Machines and correspondences
Machines are given by a set of states, a transition function, and an equivalence
relation. We write ‚ü®S, ‚Üí, ‚àº‚ü©for the machine composed of set of states S, a
function ‚Üíin S√óS, and an equivalence relation ‚àºin S√óS, such that the relation
‚Üí‚àó‚àºis transitive.1 The equivalence relation we are thinking of is a ‚Äústrong‚Äù
one: alphabetic equivalence in the lambda-calculus, strong bisimulation in the
œÄ-calculus.
For a given machine ‚ü®S, ‚Üí, ‚àº‚ü©, we say that state s converges to state s‚Ä≤ in
n steps (n ‚â•0), and write s ‚Üìn s‚Ä≤, if s ‚Üís1 ‚Üí. . . ‚Üísn = s‚Ä≤ Ã∏‚Üí. When n is
not important, we write s ‚Üìs‚Ä≤, and when s‚Ä≤ is also not important, we write s ‚Üì.
Notice that ‚Üìis a partial function.
Given two machines ‚ü®S, ‚ÜíS, ‚àºS‚ü©, ‚ü®R, ‚ÜíR, ‚àºR‚ü©, a function load : S ‚ÜíR is
called a correspondence. We distinguish two kinds of correspondences. In the
below diagrams solid arrows describe conditions, dashed arrows conclusions. For
example, the Ô¨Årst diagram reads: for all s, s‚Ä≤, r, r‚Ä≤, if s ‚ÜíS s‚Ä≤ and load(s) = r
and load(s‚Ä≤) = r‚Ä≤, then r ‚Üí‚àó
R‚àºR r‚Ä≤.
1. A correspondence is operational if
s
‚ÜíS /
(1) load

s‚Ä≤
load

r
‚Üí‚àó
R‚àºR/_
_
_
r‚Ä≤
s
‚ÜìS
/_
_
_
(2) load

r
‚ÜìR
/
s
‚ÜíS /_
_
_
(3) load

r
‚ÜíR /
1‚Üí‚àóis the transitive and reÔ¨Çexive closure of ‚Üí.
4

2. A correspondence is convergent if
s
‚ÜìS /
(4) load

s‚Ä≤
load

r
‚ÜìR‚àºR/_
_
_
r‚Ä≤
s
‚Üì
/_
_
_
(5) load

r
‚Üì
/
Notice that the equivalence relation of the source machine is not used in the
deÔ¨Ånitions.
2.2
Some properties of convergences
The following diagram is sometimes used in the deÔ¨Ånition of operational corre-
spondence.
Proposition 1. For load an operational correspondence,
s
‚Üí
/_
_
_
_
_
_
load

s‚Ä≤
load



r
‚Üí
/
‚Üí‚àó‚àº/_
_
_
r‚Ä≤
.
Proof. Consider diagrams (3) and (1). At the bottom, the two diagrams read
r ‚Üíand r ‚Üí‚àó‚àºr‚Ä≤, respectively. Since ‚Üíis a function, there must be a r‚Ä≤‚Ä≤ such
that r ‚Üír‚Ä≤‚Ä≤ ‚Üí‚àór‚Ä≤.
For the operational case note that, together with diagram (1), diagram (3)
is stronger than the usual requirement that ‚Äòs ‚Üìimplies load(s) ‚Üì‚Äô.
Proposition 2. For load an operational correspondence
s
‚Üì
/
(6) load
r
‚Üì
/_
_
_
.
Proof. Suppose that s ‚Üìn. Compose n copies of diagram (1) with the contraposi-
tive of diagram (3). The bottom line reads r ‚Üí‚àó‚àºr1 ‚Üí‚àó‚àº. . . ‚Üí‚àó‚àºrn Ã∏‚Üí. Use
the hypothesis that ‚Üí‚àó‚àºis closed under transitivity, to get r ‚Üí‚àó‚àºrn Ã∏‚Üí.
Notice that (3) is weaker than (6). Using diagrams (1) and (6), we may have
s
‚Üí‚àó/
load

s‚Ä≤
load

Ã∏‚Üí
/
r
‚Üí‚àó‚àº/_
_
_
r‚Ä≤
‚Üí
/_
_
_
.
Proposition 3 (Adequacy). For load an operational correspondence, s ‚ÜìiÔ¨Ä
load(s) ‚Üì.
Proof. Diagrams (2) and (6).
Now for the convergent case.
Proposition 4. For load a convergence correspondence,
s
‚Üì
/
(7) load
r
‚Üì
/_
_
_
.
5

Proof. Directly from diagram (4).
Proposition 5 (Adequacy). For load a convergence correspondence, s ‚ÜìiÔ¨Ä
load(s) ‚Üì.
Proof. Diagrams (5) and (7).
Proposition 6. For load a convergence correspondence,
s
‚ÜìS
/_
_
_
_
_
_
load

s‚Ä≤
load



r
‚ÜìR
/
‚àºR /_
_
_
r‚Ä≤
.
Proof. Start with diagram (5); then use diagram (4). Remember that ‚Üìis a
(partial) function.
Note that the above result does not imply that
s
‚Üí‚àó/
load

s‚Ä≤
load

‚Üí
/_
_
_
r
‚Üì‚àº/ r‚Ä≤
. The
SECD correspondence in chapter 4 constitutes a counter-example. The main
result concerning correspondences say that operational correspondences are also
convergence correspondences.
Proposition 7. Operational correspondences are also convergence correspon-
dences.
Proof. Diagram (5) is diagram (2). To show that diagram (4) holds, suppose
that s ‚Üìn. Build a diagram by placing n copies of (1) side-by-side; end with a
copy of diagram (3). The bottom line reads r ‚Üí‚àó‚àºr1 ‚Üí‚àó‚àº. . . ‚Üí‚àó‚àºrn Ã∏‚Üí; use
the hypothesis that ‚Üí‚àó
R‚àºR is closed under transitivity, to get r ‚Üí‚àó‚àºrn Ã∏‚Üí.
2.3
Summary of the correspondences
This section summarizes the correspondences between the various machines de-
scribed in the paper. The four machines under consideration are the lambda-
calculus equipped with the call-by-value strategy (Lambda, chapter 3), the
SECD machine (SECD, chapter 4), and two machines based on the pi-calculus
(Context, section 6.3, and Process, section 7.1).
For two machines M1, M2, write M1 ‚ÜíM2 if there is a correspondence from
M1 to M2. For the operational case, we have
Lambda

SECD

Process
Context
where the correspondence Lambda ‚ÜíProcess is the object of Theorem 25, and
the correspondence SECD ‚ÜíContext is shown in Theorem 30.
6

For the convergence case we have
Lambda
/
&L
L
L
L
L
L
L
L
L
L

SECD

Process
Context
where the correspondence Lambda ‚ÜíSECD is the object of Theorem 1 in
Plotkin [14] (cf. chapter 4). The two down arrows follow from proposition 7
and the respective arrows in the operational correspondence. The correspon-
dence Lambda ‚ÜíContext is obtained indirectly via the SECD machine (that
is, by composing the results for Lambda ‚ÜíSECD and SECD ‚ÜíContext), or
directly by theorem 17.
7

Chapter 3
The call-by-value Œª-calculus
This chapter introduces Plotkin‚Äôs call-by-value Œª-calculus [14]. We presuppose
a countable set variable of variables, and let x, y, z range over it. The sets value
and term, of values and terms, are inductively deÔ¨Åned as follows.
V
::=
x
|
ŒªxM
M
::=
V
|
MN
We say that a variable x occurs free in a term M is x is not in the scope of a
Œªx; x occurs bound otherwise. The set fv(M) of the free variables in M is deÔ¨Åned
accordingly, and so is the result of substituting N for the free occurrences of x
in M, denoted by M[N/x], as well as the alpha equivalence, denoted by ‚â°Œ±. A
term M is closed if fv(M) = ‚àÖ. The set of closed lambda-terms is denoted by
term0.
The reduction relation over term, written ‚Üív, is the smallest relation over
term satisfying the following rules.
(ŒªxM)V ‚ÜíM[V/x]
(Œ≤)
M ‚ÜíM ‚Ä≤
V M ‚ÜíV M ‚Ä≤
(AppR)
M ‚ÜíM ‚Ä≤
MN ‚ÜíM ‚Ä≤N
(AppL)
The ‚Üív relation is Plotkin‚Äôs left reduction: ‚ÄúIf M ‚Üív N, then N is gotten from
M by reducing the leftmost redex, not in the scope of a Œª‚Äù [14].
In the sequel we are interested in closed lambda-terms. Consequently, the
(call-by-value) lambda machine, Lambda, we need is ‚ü®term0, ‚Üív, ‚â°Œ±‚ü©. Notice
that, since states are closed terms, saying that M ‚Üìn N is saying that M ‚Üín N
and N is a value.
8

Chapter 4
The SECD machine
This chapter presents the SECD machine, a simpliÔ¨Åed formulation of the Landin‚Äôs
ISWIM machine [5], as studied by Plotkin [14].
The SECD machine is given by a set of states and a transition function.
States, or dumps, are quadruples ‚ü®S, E, C, D‚ü©composed of a stack of closures,
an environment, a control string, and a dump. The sets of closures and envi-
ronments, closure and environment, are deÔ¨Åned mutually recursively. Symbol Cl
is used to range over closures, and E over environments.
1. {‚ü®xi, Cli‚ü©| i = 1, n} is in environment, if x1, . . . , xn are distinct variables
and n ‚â•0; in this case, the domain of the environment, dom(E), is the
set {x1, . . . , xn};
2. ‚ü®M, E‚ü©is in closure, if fv(M) ‚äÜdom(E).
Notice that an empty environment constitutes the base of recursion: if M is a
closed term, then ‚ü®M, ‚àÖ‚ü©is a closure. The sets of control strings and of dumps,
controlstring and dump, are deÔ¨Åned as follows. Letter C is used to range over
control strings and D over dumps.
1. controlstring
def
= (term ‚à™{ap})‚àó, where ap Ã∏‚ààterm;
2. nil is in dump, and so is ‚ü®S, E, C, D‚ü©.
Environment update is captured by the operation E{Cl/x}, denoting the
unique environment E‚Ä≤ such that E‚Ä≤(y) = E(y) if y Ã∏= x, and E‚Ä≤(x) = Cl
otherwise. The term represented by a closure is given by the real : closure ‚Üíterm
function, deÔ¨Åned as
real(‚ü®M, E‚ü©)
def
= M[real(E(x1))/x1] . . . [real(E(xn))/xn]
where fv(M) = {x1, . . . , nn}.
The transition function over dump, written ‚ÜíSECD, is deÔ¨Åned by the follow-
9

ing rules.
‚ü®S, E, x: C, D‚ü©‚Üí‚ü®E(x): S, E, C, D‚ü©
(Var)
‚ü®S, E, ŒªxM : C, D‚ü©‚Üí‚ü®‚ü®ŒªxM, E‚ü©: S, E, C, D‚ü©
(Abs)
‚ü®S, E, MN : C, D‚ü©‚Üí‚ü®S, E, N : M : ap: C, D‚ü©
(App)
‚ü®‚ü®ŒªxM, E‚Ä≤‚ü©: Cl: S, E, ap: C, D‚ü©‚Üí‚ü®nil, E‚Ä≤{Cl/x}, M, ‚ü®S, E, C, D‚ü©‚ü©
(Call)
‚ü®Cl: S, E, nil, ‚ü®S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©‚ü©‚Üí‚ü®Cl: S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©,
(Ret)
To translate a lambda term into a dump, use the term-to-dump : term ‚Üí
dump function deÔ¨Åned as follows:
term-to-dump(M)
def
= ‚ü®nil, ‚àÖ, M, nil‚ü©
If a SECD machine halts at a dump of the form ‚ü®Cl, ‚àÖ, nil, nil‚ü©, then we read the
result by identifying the term represented by the closure Cl, using function real.
Thus the equivalence on dumps, ‚â°SECD, is the smallest relation that includes
the pairs
(‚ü®nil, ‚àÖ, M, nil‚ü©, ‚ü®Cl, ‚àÖ, nil, nil‚ü©)
for all terms M and closures Cl such that real(Cl) ‚â°Œ± M. The SECD machine,
SECD, is the triple ‚ü®dump, ‚ÜíSECD, ‚â°SECD‚ü©. Notice that if we load the machine
with an abstraction V , we get the dump ‚ü®nil, ‚àÖ, V, nil‚ü©. Such a dump both reduces
and is equivalent to ‚ü®‚ü®V, ‚àÖ‚ü©, ‚àÖ, nil, nil‚ü©.
Theorem 8 ([14], Theorem 1). The term-to-dump correspondence is conver-
gent.
Example 9. Consider the term (ŒªxIx)V where V is a closed value. We have
term-to-dump((ŒªxIx)V ) ‚Üí‚àó
SECD
‚ü®‚ü®ŒªxIx, ‚àÖ‚ü©: ‚ü®V, ‚àÖ‚ü©, ‚àÖ, ap, nil‚ü©‚Üí‚àó
SECD
‚ü®‚ü®I, E‚ü©: ‚ü®V, E‚ü©, E, ap, ‚ü®nil, ‚àÖ, nil, nil‚ü©‚ü©‚Üí‚àó
SECD
‚ü®‚ü®V, E‚ü©, E{‚ü®V, E‚ü©/y}, nil, ‚ü®nil, E, nil, ‚ü®nil, ‚àÖ, nil, nil‚ü©‚ü©‚ü©‚ÜíSECD
‚ü®‚ü®V, E‚ü©, E, nil, ‚ü®nil, ‚àÖ, nil, nil‚ü©‚ü©‚ÜíSECD
‚ü®‚ü®V, E‚ü©, ‚àÖ, nil, nil‚ü©
where E is the environment {‚ü®x, {‚ü®V, ‚àÖ‚ü©}‚ü©}.
The second and the third line
correspond to Call transitions; the fourth and Ô¨Åfth to Ret transitions. Then,
we read the result to get real(‚ü®V, E‚ü©) = V as expected.
10

Chapter 5
The œÄ-calculus
This section brieÔ¨Çy introduces the (asynchronous) œÄ-calculus to the extent
needed for this presentation, namely, the syntax, the reduction semantics, i/o-
types, and barbed congruence.
5.1
Syntax
Fix a countable set name of names, and let lower-case letters range over this
set. The set process of processes is inductively deÔ¨Åned as
P
::=
aÀúb
|
a(Àúx).P
|
P | Q
|
ŒΩxP
| !a(Àúx).P
|
0
where the names in the sequence of names Àúx are pairwise distinct.
Processes of the form aÀúb are called messages; a is the target, whereas the
sequence of names Àúb represents the contents of the message.
Receptors are
processes of the form a(Àúx).P, where a is called the location of the receptor, Àúx
the formal parameters, and P its body. The interaction between a message aÀúb
and a receptor a(Àúx).P is the process P where names in Àúb replace those in Àúx. The
parallel composition of P and Q is written P | Q. Processes of the form ŒΩxP
introduce a new name x local, or private, to P. A replicated receptor !a(Àúx).P
behaves as a persistent receptor surviving interaction with messages. Finally,
0 represents the terminated process. We say that a process P occurs under a
preÔ¨Åx when P is in the scope of a a(Àúx).
We follow the convention that the scope of ŒΩx extends as much to the right
as possible, so that, for example, ŒΩx P | Q denotes the process ŒΩx (P | Q).
5.2
Reduction semantics
We say that a name x occurs free in a process P if x is not in the scope of a
ŒΩx or a a(ÀúyxÀúz); x occurs bound otherwise. The set fn(P) of the free names in
P; the result of simultaneously substituting Àúb for the free occurrences of Àúa in P,
denoted by P[Àúb/Àúa]; and alpha equivalence, denoted by ‚â°Œ±, are all deÔ¨Åned in the
standard way.
We also follow the convention that, if P1, . . . , Pn occur in a certain math-
ematical context, then in these processes all bound names are chosen to be
diÔ¨Äerent from the free names (cf. the variable convention [1]).
11

The operational semantics of processes is given by a reduction relation. Fol-
lowing Milner [9], reduction exploits the structural congruence relation over
process, written ‚â°, and deÔ¨Åned as the smallest relation containing alpha equiv-
alence that satisÔ¨Åes the following rules.
1. P | 0 ‚â°P, P | Q ‚â°Q | P, and P | (Q | R) ‚â°(P | Q) | R;
2. ŒΩx 0 ‚â°0, and ŒΩxy P ‚â°ŒΩyx P;
3. P | ŒΩx Q ‚â°ŒΩx P | Q if x Ã∏‚ààfn(P).
The reduction relation over process, written ‚Üí, is the smallest relation sat-
isfying the following rules.
aÀúb | a(Àúx).P ‚ÜíP[Àúb/Àúx]
(Com)
aÀúb | !a(Àúx).P ‚Üí!a(Àúx).P | P[Àúb/Àúx]
(Rep)
P ‚ÜíP ‚Ä≤
ŒΩx P ‚ÜíŒΩx P ‚Ä≤
(Scop)
P ‚ÜíP ‚Ä≤
P | Q ‚ÜíP ‚Ä≤ | Q
(Par)
P ‚Ä≤ ‚â°P
P ‚ÜíQ
Q ‚â°Q‚Ä≤
P ‚Ä≤ ‚ÜíQ‚Ä≤
(Equiv)
For any name a, the observation predicate ‚Üìa denotes the possibility of a
process immediately performing a communication with external environment
along a. Thus, P ‚Üìa holds if P has a sub-term ab or a(Àúx).Q which is not under
the scope of a ŒΩa or of a b(a). We write P ‚Üíd P ‚Ä≤ if the reduction P ‚ÜíP ‚Ä≤ is
deterministic, that is: P ‚ÜíP ‚Ä≤‚Ä≤ implies P ‚Ä≤ ‚â°P ‚Ä≤‚Ä≤, and there is no a such that
P ‚Üìa.
5.3
Input/output types
The set type of input/output types is inductively deÔ¨Åned as follows.
S
::=
I‚ü®ÀúS‚ü©
|
t
|
¬µt.S
I
::=
o
|
i
|
b
Input/output types distinguish between the capability of reading a name
(i‚ü®ÀúS‚ü©is the type of a name that may be used only for input, and that carries
names of types ÀúS), writing on a name (o‚ü®ÀúS‚ü©is the type of a name that may be
used only for output), and reading and writing on a name (b‚ü®ÀúS‚ü©).
Type environments, or typings, denoted by the Greek letters Œì, ‚àÜ, are Ô¨Ånite
maps from names to types. A typing judgment Œì ‚ä¢P asserts that process P
is well typed under the type environment Œì, or that P obeys Œì. We omit the
deÔ¨Ånition of the relation ‚ä¢, which can be found in reference [12]. IF X is the
set {x1, . . . , xn}, we write X : S to mean the typing x1 : S, . . . , xn : S.
12

5.4
Contexts
A process context C is a process expression with a hole in it. We let context
denote the set of contexts, and we write C[P] for the expression obtained by
Ô¨Ålling the hole in C with P. The hole itself is denoted by []. Reduction is deÔ¨Åned
for processes, but can be easily extended to contexts by saying that C ‚ÜíC‚Ä≤
whenever, C[P] ‚ÜíQ implies Q ‚â°C‚Ä≤[P], for P an arbitrary process.
To type contexts, we use context typings. Since a context is a process with a
hole, we need two typings: one for the (process that Ô¨Ålls the) hole, the other for
the context (with the hole Ô¨Ålled by the process). Using ‚àÜfor the typing of the
hole, and Œì for that of the context, a context-typing is denoted by Œì[‚àÜ]. Then
we write Œì[‚àÜ] ‚ä¢C when ‚àÜ‚ä¢P implies Œì ‚ä¢C[P]. In this case, we say that C
is a Œì[‚àÜ]-context.
5.5
Behavioural equality
Behavioural equality is based on the notion of barbed congruence [11]. The def-
inition uses the reduction relation and the observation predicate deÔ¨Åned earlier.
A relation R is a strong barbed bisimulation if
P
‚Üí/
R

P ‚Ä≤
R



Q
‚Üí/_
_
_
Q‚Ä≤
P
‚Üí/_
_
_
R

P ‚Ä≤
R



Q
‚Üí/Q‚Ä≤
P
‚Üìa
/
R

Q
‚Üìa
/_
_
_
P
‚Üìa
/_
_
_
R

Q
‚Üìa
/
Two processes P, Q are called strongly barbed bisimilar if PRQ for some strong
barbed bisimulation R. Barbed bisimulation by itself is a rather coarse relation;
better discriminating power can be achieved by using the induced congruence,
called barbed congruence. In typed calculi, the processes being compared must
obey the same typing, and the contexts employed must be compatible with this
typing. Suppose that processes P, Q obey a given typing ‚àÜ. We say that P, Q
are strongly barbed congruent at ‚àÜ, written P ‚àº‚àÜQ, if, for all typings Œì, and
all Œì[‚àÜ]-contexts C, we have that C[P] and C[Q] are strongly barbed bisimilar.
The weak version of barbed bisimulation is deÔ¨Åned by replacing the reduction
‚Üíwith the relation ‚Üí‚àó, and the observation predicate ‚Üìa with the predicate
‚Üí‚àó‚Üìa. We write ‚âà‚àÜfor the (weak) barbed congruence at ‚àÜ.
Extending barbed congruence to contexts, we say that two Œì[‚àÜ]-contexts
C, C‚Ä≤ are strongly barbed congruent, and write C ‚àºŒì[‚àÜ] C‚Ä≤, if ‚àÜ‚ä¢P implies
C[P] ‚àºŒì C‚Ä≤[P], and similarly for the weak regime.
5.6
Replication theorems
The replication theorems constitute the cornerstone of results in the paper. All
proofs ultimately, directly or indirectly, are based on these theorems taken from
the literature.
We say that a, a name free in P, is used as a trigger in P, if P obeys a
typing Œì, and the tag of the type of a in Œì is o.
Theorem 10 (Replication theorems [12, 12]). If a is used as a trigger in
P, Q, R, then
13

1. ŒΩa !a(Àúx).Q | b(y).P ‚àº‚àÜb(y).(ŒΩa !a(Àúx).Q | P);
2. ŒΩa !a(Àúx).P | !b(Àúy).Q ‚àº‚àÜ!b(Àúy).(ŒΩa !a(Àúx).P | Q).
3. ŒΩa !a(Àúx).Q | ŒΩb !b(Àúx).Q | P ‚àº‚àÜŒΩa !a(Àúx).Q | P[a/b], if b is not free in Q
and is used as a trigger in P.
Proof. The two Ô¨Årst clauses are the Ô¨Årst and second replication theorems [12].
The third clause constitutes part of the proof of Lemma C.2.2 in [12].
Relying on the variable convention, we omit the condition on clause 1 above:
y is not free in Q since it is bound in b(y).P, and a Ã∏= b since b is free in the left
hand side whereas a is bound.
Theorem 11 (Link theorem [16] B.12). If ‚àÜ‚ä¢ab where ‚àÜ(a) = ooS for
some S, then ab ‚âà‚àÜŒΩc: oS ac | !c(x).bx.
14

Chapter 6
Encoding the cbv-Œª into œÄ
We now introduce our encoding of the call-by-value Œª-calculus into the œÄ-
calculus, thereby deÔ¨Åning a machine that can be put into correspondence with
lambda-machine deÔ¨Åned in section 3. The section also presents a comparison
with Milner‚Äôs encoding, and shows that there is room for optimizing the encod-
ing.
6.1
The encoding
To deÔ¨Åne the compilation scheme we need to know:
1. the Œª-term to encode,
2. the channel where the Œª-term is to be located (the location of the term),
and
3. the scope of this channel, that is, the piece of code (a process) where this
channel is to be visible.
The novelty with respect to Milner‚Äôs encoding resides exactly in this last
item. Instead of providing an encoding that may be placed in any context, we
ask for the scope where the term is to run, and return a process that includes
the encoding of the term and the scope. So we have a mapping
[[M]]aP : term ‚Üíname ‚Üíprocess ‚Üíprocess.
By using the contexts we can simplify the presentation and work with a mapping
[[M]]a : term ‚Üíname ‚Üícontext.
A form [[M]]a represents a context in whose hole name a denotes the location
of term M. The process in the hole is blocked (at some preÔ¨Åx r(a).[]) until the
term attains its normal form. Name a is free in the hole, allowing the process
in the hole to refer to (the value of) M.
We are now in position to present the encoding. Starting with Œª-variables,
and assuming that the set variable is an inÔ¨Ånite and co-inÔ¨Ånite subset of name,
we have
[[x]]a
def
= [][x/a],
15

so that variables are not really translated, but else syntactically substituted in
the hole. For example, [[y]]aua
def
= uy.
For abstractions, we have
[[ŒªxM]]a
def
= ŒΩa !a(xr).[[M]]brb | [],
where names b and r are fresh.
Notice that a, the location of the term, is
local to the hole, so that the process placed in the hole ‚Äúsees‚Äù, or ‚Äúknows‚Äù,
the abstraction. The part !a(xr).[[M]]brb is called an environment entry; in the
sequel we abbreviate such a process to a := ŒªxM. The location a of the term is
replicated since the function may be invoked an arbitrary number of times from
within the process in the hole. Channel a receives a pair of names: the Ô¨Årst is
the argument to the function, the second is a name intended to reply the result
of the function, and is usually called a reply-to name. In this way, the function,
when invoked, evaluates M (with x replaced by the actual argument) to a fresh
name b, and returns this name in the reply-to name r supplied by the caller.
Finally, for applications, we have
[[MN]]a
def
= ŒΩr [[M]]b[[N]]cbcr | r(a).[],
where names b, c, r are fresh. We Ô¨Årst evaluate M to b, then N to c, and then
invoke the function at b with the argument c and request to have the result sent
to r. Finally we wait for the result at r, and instantiate it in the hole as a,
since the process in the hole expects to see the result of the evaluation of MN
located at a.
We have omitted the square brackets in the contexts above: instead of writ-
ing [[M]]b[[[N]]c[bcr]], we simply write [[M]]b[[N]]cbcr, and similarly for abstrac-
tions.
The below examples help in understanding the dynamics of the encoding.
Example 12. 1.
Values involve no reduction: Œª-variables are syntactically
substituted in the context; the location of an abstraction is local to the context
of the abstraction . Let I denote the term Œªzz. Then,
[[I]]a
def
= ŒΩa !a(zr).rz | [].
Notice that there is no reduction involved in letting the hole know the location
of I.
2. An application of the beta-axiom corresponds to a pair of œÄ-reductions,
one to invoke the function, the other to get the reply. In the sequel we underline
each redex.
[[Ix]]a
def
=
ŒΩrb !b(xr‚Ä≤).r‚Ä≤x | bxr | r(a).[] ‚Üíd
ŒΩrb b := I | rx | r(a).[] ‚Üíd
(ŒΩb b := I) | [][x/a] ‚àº
[][x/a]
def
= [[x]]a
The last step represents the garbage collection of an environment entry that is
no longer accessible.
16

3. Reduction is determinate. Below the leftmost redex (Ix) must be reduced
before the rightmost one (Iy), since the latter is under the preÔ¨Åx r‚Ä≤(b). Using
the above result twice, we have the following reduction.
[[Ix(Iy)]]a
def
=
ŒΩrr‚Ä≤ [[I]]d[[x]]eder‚Ä≤ | r‚Ä≤(b).([[Iy]]cbcr | r(a).[]) ‚Üí2
d‚àº
ŒΩr [[Iy]]cxcr | r(a).[] ‚Üí2
d‚àº
ŒΩr xyr | r(a).[]
def
= [[xy]]a
We can see that, on the Œª-calculus side, we have
Ix(Iy) ‚Üív x(Iy) ‚Üív xy,
and that, on the œÄ-calculus side, there are contexts C, C‚Ä≤ such that
[[Ix(Iy)]]a ‚Üí2
d C ‚àº[[x(Iy)]]a ‚Üí2
d C‚Ä≤ ‚àº[[xy]]a.
That is not always the case, as the next example witnesses.
4. Take for M the term (ŒªxIx)y. We know that M ‚Üív Iy, but there is no
context C such that [[M]]a ‚Üí‚àóC with C ‚àº[[Iy]]a. In fact, M has two nested
redexes. As such, after two œÄ-steps, the two function calls have been performed,
but the two ‚Äúreturns‚Äù (r‚Ä≤y and rb) are pending.
[[M]]a ‚Üí2
d‚àºŒΩr‚Ä≤ r‚Ä≤y | ŒΩr r‚Ä≤(b).rb | r(a).[]
At this point there remains a ‚Äústack‚Äù with two ‚Äúactivation records‚Äù; we can eas-
ily see that two deterministic steps are what it takes to pop this stack, reducing
the above context to [[y]]a. Compare with Example 9, where the correspond-
ing SECD machine proceeds by performing two call operations followed by two
return operations.
5. The last example focuses on a divergent reduction. Let ‚Ñ¶= ZZ, and
Z = Œªzzz. Then we have:
[[‚Ñ¶]]a
def
=
ŒΩrb b := Z | ŒΩc c := Z | bcr | r(a).[] ‚Üíd‚àº
ŒΩrr‚Ä≤c c := Z | ccr‚Ä≤ | r‚Ä≤(a).ra | r(a).[] ‚Üíd
ŒΩrr‚Ä≤r‚Ä≤‚Ä≤c c := Z | ccr‚Ä≤‚Ä≤ | r‚Ä≤‚Ä≤(a).r‚Ä≤a | r‚Ä≤(a).ra | r(a).[] ‚Üíd
ŒΩrr‚Ä≤r‚Ä≤‚Ä≤r‚Ä≤‚Ä≤‚Ä≤c c := Z | ccr‚Ä≤‚Ä≤‚Ä≤ | r‚Ä≤‚Ä≤‚Ä≤(a).r‚Ä≤‚Ä≤a | r‚Ä≤‚Ä≤(a).r‚Ä≤a | r‚Ä≤(a).ra | r(a).[]
Notice the ever growing chain of forwarders (or activation records): r‚Ä≤‚Ä≤‚Ä≤(a).r‚Ä≤‚Ä≤a |
r‚Ä≤‚Ä≤(a).r‚Ä≤a | r‚Ä≤(a).ra. Each Œ≤-reduction remains half-done: the function Z has
been invoked; but there is a forwarder waiting to convey the result to the cor-
responding context (or, using the activation stack analogy, there remains an
activation record to pop).
We conclude this section by analyzing the free names present in the encoding.
The encoding introduces no free names other than the free variables in M. Also,
any process placed in the hole of [[M]]a may access the (encoding of) M via
name a. This name, however, is not free in the context when Ô¨Ålled up with a
process.
Lemma 13.
1. fn([[M]]a) = fv(M);
2. fn([[M]]aP) = fv(M) ‚à™fn(P) ‚àí{a}.
17

6.2
Typing the encoding
Encoded Œª-terms are meant to run in a concurrent environment. Such environ-
ments are in general overly permissive. The terms, as we have encoded them,
are somewhat sensible ‚Äî they only behave correctly when placed in controlled
surroundings.
Let us see what happens if we allow the placing of arbitrary processes in the
hole of the encoding. Take the two terms KI and ŒªyI.1 We know that the two
terms are Œ≤-equivalent (in fact the former reduces to the latter), but there is a
process capable of distinguishing them. We have
[[KI]]a ‚Üí2
d‚àºŒΩc c := I | ŒΩa !a(yr).rc | []
(
def
= C1)
[[ŒªyI]]a
def
= ŒΩa !a(yr).(ŒΩc c := I | rc) | []
(
def
= C2)
By concentrating on the processes !a(yr) . . . , we see that in the case of KI all
invocations return the same name c, whereas for ŒªyI each invocation provides
a fresh name. (Notice that although the names are diÔ¨Äerent, the processes the
names locate are syntactically equal.) How can we take distinguish the two
cases? We invoke twice the function to obtain two names. If they are the same,
then we are in presence of KI, otherwise we have ŒªyI. All that remains is to
compare two names for equality: we write on one of them, read from the other,
and arrange for an observable action to emerge from the contractum. So, for
the observer take the process
P
def
= axr | r(c‚Ä≤).(axr | r(c‚Ä≤‚Ä≤).(c‚Ä≤(xr).o | c‚Ä≤‚Ä≤xr)).
We can easily check that
[[KI]]aP ‚Üí6
d C1[c(xr).o | cxr] ‚Üíd
C1[o] ‚Üìo
[[ŒªyI]]aP ‚Üí4
d C2[ŒΩc ‚Ä≤c‚Ä≤ := I | ŒΩc ‚Ä≤‚Ä≤c‚Ä≤‚Ä≤ := I | c‚Ä≤(xr).o | c‚Ä≤‚Ä≤xr] ‚Üíd
C2[ŒΩc ‚Ä≤c‚Ä≤ := I | ŒΩc ‚Ä≤‚Ä≤c‚Ä≤‚Ä≤ := I | c‚Ä≤(xr).o | rc‚Ä≤‚Ä≤] Ã∏‚ÜíÃ∏‚Üìo
Only by violating the (hitherto implicit) protocol for locations of terms were
we able to tell the two terms apart. In fact we have installed a reader (c‚Ä≤(xr).o)
on the location of a function.
What kind of processes may we place in the hole of an encoding? Processes
that follow a discipline of i/o-types [12]. There are two kinds of names involved
in the encoding:
1. value names comprising variables x, y, z, as well as locations of abstrac-
tions a, b, c; and
2. and reply-to names r, r‚Ä≤, r‚Ä≤‚Ä≤, names that return value names.
Let us call Val the type of the value names. How does this type look like?
Looking at the fragment [[M]]b[[N]]cbcr of the encoding of MN, we know that
Val must be of the form o‚ü®Val, S‚ü©, for some type S. How does S looks like?
1K is the term Œªxyx; KI and ŒªyI are the terms used in Sangiorgi‚Äôs thesis [15] for this exact
purpose.
18

Concentrating on the part [[M]]brb of the encoding of ŒªxM, we easily conclude
that S is the type oVal. So we have2
Val
def
= ¬µX.o‚ü®X, oX‚ü©.
In the encoding of an abstraction, the name a locating the abstraction may
be used for input (at !a(xr) . . . ) as well as for output (from the process within
the hole). Such a name is of type
Valb def
= b‚ü®Val, o Val‚ü©.
Also, in the encoding of an application, the reply-to name r is used to output
the value of the application (in [[M]]b[[N]]cbcr), as well as to input (in r(a).[]).
The encoding, where bound names are annotated with types, is as follows.
[[x]]a
def
= [][x/a]
[[ŒªxM]]a
def
= ŒΩa: Valb !a(x: Val, r: o Val).[[M]]brb | []
[[MN]]a
def
= ŒΩr: b Val [[M]]b[[N]]cbcr | r(a: Val).[]
The main result related to the typing of the encoding states that the free
variables in a term all have type Val, and so does the location of the encoded
term.
Lemma 14. If fv(M) : Val ‚äÜŒì, then Œì[Œì, a : Val] ‚ä¢[[M]]a.
Proof. By induction on the structure of M, using basic results of the type system
such as weakening and substitution [12].
6.3
Convergence correspondence
Lemma 14 says that when ‚àÜis a typing assigning type Val to all the free
variables in a term M, then [[M]]a is a ‚àÜ[‚àÜ, a : Val]-context. In the sequel we
abbreviate context-typings of the form ‚àÜ[‚àÜ, a : Val] to ‚àÜ, so that, when we
write [[M]]a ‚àº‚àÜ[[N]]a, we mean [[M]]a ‚àº‚àÜ[‚àÜ,a:Val] [[N]]a where ‚àÜcontains the
typing fn(MN) : Val.
The pi-based machine we are interested at, the context machine, Context, is
the triple ‚ü®context, ‚Üíd, ‚àº‚àÜ‚ü©. Fix a name a not in variable; the term-to-context
correspondence is deÔ¨Åned as
term-to-context(M)
def
= [[M]]a
if M is closed
Theorem 15. If M ‚Üìn
v N, then [[M]]a ‚Üì2n
d ‚àº‚àÜ[[N]]a.
Theorem 16. If [[M]]a ‚Üìn C, then n is even, and there is a term N such that
M ‚Üìn/2
v
N with C ‚àº‚àÜ[[N]]a.
Corollary 17. The term-to-context correspondence is convergent.
2This is exactly the type of value names in Milner‚Äôs encoding [12], cf. section 7.
19

From Proposition 5 it follows that the encoding is adequate for the call-
by-value lambda calculus. The proofs of the two Theorems above require two
lemmas.
Lemma 18 (Value exchange lemma). [[M]]a[[V ]]b ‚àº‚àÜ[[V ]]b[[M]]a.
Proof. Case analysis on V ; case analysis on M when V is an abstraction. Uses
the replication theorem 10.1. First notice that, since term locations are taken
freshly, a does not occur free in V , and b does not occur free in M.
Case V is a variable. Notice that, by hypothesis, b is not free in M.
[[M]]a[[V ]]b
def
= ([[M]]a)[V/b]
def
= [[V ]]b[[M]]a
Case V is an abstraction. The diÔ¨Écult case is when is M an application;
the reader is invited to check the two remaining cases.
[[NL]]a[[V ]]b
def
=
ŒΩr [[N]]c[[L]]dcdr | r(a).(ŒΩb b := V | []) ‚àº‚àÜ
(Replication theorem 10.1)
ŒΩr [[N]]c[[L]]dcdr | ŒΩb b := V | r(a).[] ‚â°
ŒΩb b := V | ŒΩr [[N]]c[[L]]dcdr | r(a).[]
def
=
[[V ]]b[[NL]]a
In the application of the structural congruence, notice that r is not free in b := V
since it is taken freshly, by deÔ¨Ånition.
Lemma 19 (Substitution lemma). If x is not free in the hole,
then
[[V ]]x[[M]]a ‚àº‚àÜ[[M[V/x]]]a.
Proof. Case analysis on V ; induction on M when V is an abstraction. Uses the
replication theorems 10.2 and 10.3, and the exchange lemma 18.
Case V is a variable. The two sides of the equation become syntactically
equal. The remaining cases are for when V is an abstraction.
Case M is the variable x. Notice that, by hypothesis, x is not free in the
hole.
[[V ]]a
def
= ŒΩa a := V | [] ‚â°Œ± ŒΩx x := V | [][x/a]
def
= [[V ]]x[[x]]a
Case M is a variable x Ã∏= y. Again notice that x is not free in the hole.
[[y]]a
def
= [][y/a] ‚àºŒΩx x := V | [][y/a]
def
= [[V ]]x[[y]]a
The ‚àº-step represents the generation of a garbage environment entry.
Case M is an abstraction ŒªyN.
[[ŒªyN[V/x]]]a
def
=
ŒΩa !a(yr).[[N[V/x]]]brb | [] ‚àº‚àÜ
(Induction)
ŒΩa !a(yr).[[V ]]x[[N]]brb | [] ‚àº‚àÜ
(Replication theorem 10.2)
[[V ]]x(ŒΩa !a(yr).[[N]]brb | [])
def
=
[[V ]]x[[ŒªyN]]a
20

Case M is an application NL.
[[N[V/x]L[V/x]]]a
def
=
ŒΩr [[N[V/x]]]b[[L[V/x]]]cbcr | r(a).[] ‚àº‚àÜ
(Induction twice)
ŒΩr [[V ]]x[[N]]b[[V ]]x[[L]]cbcr | r(a).[] ‚â°Œ±
(y fresh)
ŒΩr [[V ]]x[[N]]b[[V ]]y[[L[y/x]]]cbcr | r(a).[] ‚àº‚àÜ
(Exchange lemma 18)
ŒΩr [[V ]]x[[V ]]y[[N]]b[[L[y/x]]]cbcr | r(a).[] ‚àº‚àÜ
(Replication theorem 10.3)
ŒΩr [[V ]]x[[N]]b[[L]]cbcr | r(a).[]
def
=
[[V ]]x[[NL]]a
Proof of Theorem 15. By induction on n; uses the Substitution lemma 19. When
n is zero, M = N, and we are done. When n is positive, M is an application
M1M2. Let M1 ‚Üìn1
v
ŒªxL, M2 ‚ÜìV
v V , and L[V/x] ‚Üìn3
v
N, with n = n1+n2+n3+1.
Then we have
[[M1M2]]a
def
=
ŒΩr [[M1]]b[[M2]]cbcr | r(a).[] ‚Üí2(n1+n2)
d
‚àº
(Induction hypothesis)
ŒΩr ŒΩb b := Œªxl | ŒΩc c := V | bcr | r(a).[] ‚Üíd‚àº
(Garbage collection)
ŒΩr ŒΩc c := V | [[L[c/x]]]drd | r(a).[] ‚â°Œ±
def
=
ŒΩr [[V ]]x[[L]]drd | r(a).[] ‚àº‚àÜ
(Substitution lemma 19)
ŒΩr [[L[V/x]]]drd | r(a).[] ‚Üí2n3
d
‚àº‚àÜ
(Induction hypothesis)
ŒΩr [[N]]drd | r(a).[]
def
=
ŒΩr ŒΩd d := N | rd | r(a).[] ‚Üíd‚â°Œ±
ŒΩa a := N | []
def
=
[[N]]a
Proof of Theorem 16. By induction on n; uses the Substitution lemma 19. When
n is zero, [[M]]a = C, and we are done. When n is positive, M is an application
M1M2. Let [[M1]]b ‚Üìn1
d ‚àº‚àÜ[[ŒªxL]]b, [[M2]]c ‚Üìn2
d ‚àº‚àÜ[[V ]]c, and [[V ]]c[[L[c/x]]]d ‚Üìn3
d ‚àº‚àÜ
[[N]]d, with n = n1 + n2 + n3 + 2.
Then, noticing that by the substitution
lemma 19, [[V ]]c[[L[c/x]]]d ‚àº‚àÜ[[L[V/x]]], by induction we have
M1M2 ‚Üín1/2
v
(ŒªxL)M2 ‚Üín2/2
v
(ŒªxL)V ‚Üív L[V/x] ‚Üín3/2
v
N
6.4
Weak operational correspondence
The term-to-context correspondence is not operational; Example 12.4 provides a
counter-example. Nonetheless, if we compare lambda and pi reduction steps up
to weak barbed congruence, we get a form of weak operational correspondence.
21

Theorem 20.
M
‚Üív /
term-to-context

M ‚Ä≤
term-to-context



C
‚Üíd‚âà‚àÜ/_
_
_
C‚Ä≤
M
‚Üív
/_
_
_
_
_
_
term-to-context

M ‚Ä≤
term-to-context



C
‚Üíd
/
‚âà‚àÜ/_
_
_
C‚Ä≤
As a corollary we get that the encoding is valid for the call-by-value lambda-
calculus.
Corollary 21 (Validity). If M =Œ≤ N, then [[M]]a ‚âà‚àÜ[[N]]a.
The proof of Theorem 20 requires the Substitution Lemma 19, and three
further lemmas. The Ô¨Årst says that there is an alternative encoding for appli-
cations.
Lemma 22 (Alternative encoding). [[MN]]a ‚àº‚àÜ[[M]]b[[N]]c[ŒΩr bcr | r(a).[]].
Proof. Apply the replication theorem 10.1 once for each application in MN, to
obtain
[[MN]]a ‚àº‚àÜŒΩr [[M]]b[[N]]c[bcr | r(a).[]].
Finally, since reply-to names are taken freshly, use structural congruence to
bring the ŒΩr inwards, and obtain the result.
The forwarder lemma accounts for the presence of the weak congruence in
the main result of this section.
Lemma 23 (Forwarder lemma). ŒΩr [[M]]brb | r(a).[] ‚âà‚àÜ[[M]]a.
Proof. A case analysis on M. Uses the link theorem 11, and the alternative
encoding 22.
Case M is a value V .
ŒΩr [[M]]brb | r(a).[] ‚Üíd [[M]]a
Case M is an application NL.
ŒΩr [[NL]]brb | r(a).[] ‚àº‚àÜ
(Alternative encoding 22)
ŒΩr [[N]]c[[L]]d[ŒΩr‚Ä≤ cdr‚Ä≤ | r‚Ä≤(b).rb) | r(a).[]] ‚âà‚àÜ
(Link theorem 11)
ŒΩr [[N]]c[[L]]dcdr | r(a).[]
def
=
[[NL]]a
Unlike theorem 11, the preÔ¨Åx r(a).[] is not replicated, due to the linearity con-
straint on reply-to names.
A Œ≤-step corresponds to a deterministic pi-step (‚Üíd), the calling of the func-
tion, possibly followed by a return step, accounted for by the barbed congruence.
Lemma 24 (Beta lemma). [[(ŒªxM)V ]]a ‚Üíd‚âà‚àÜ[[M[V/x]]]a.
22

Proof. Case analysis on V . Uses the substitution lemma 19 and the forwarder
lemma 23.
Case V is the variable.
[[(ŒªxM)V ]]a
def
=
ŒΩrb b := ŒªxM | bV r | r(a).[] ‚Üíd
(ŒΩb b := ŒªxM) | ŒΩr [[M[V/x]]]drd | r(a).[] ‚àº
(Garbage collection)
ŒΩr [[M[V/x]]]drd | r(a).[] ‚âà‚àÜ
(Forwarder lemma 23)
[[M[V/x]]]a
Case V is an abstraction.
[[(ŒªxM)V ]]a
def
=
ŒΩrb b := ŒªxM | ŒΩc c := V | bcr | r(a).[] ‚Üíd
(ŒΩb b := ŒªxM) | ŒΩc c := V | ŒΩr [[M[c/x]]]drd | r(a).[] ‚àº
(Garbage collection)
ŒΩc c := V | ŒΩr [[M[c/x]]]drd | r(a).[] ‚âà‚àÜ
(Forwarder lemma 23)
ŒΩc c := V | [[M[c/x]]]a ‚àº‚àÜ
(Substitution lemma 19)
[[M[V/x]]]a
In the application of the substitution lemma above, notice that x, being bound
in M, is not free in the hole by the variable convention.
Proof of Theorem 20. For the Ô¨Årst diagram, use induction on the structure of
reduction. When the last rule is the Œ≤-rule, use the beta lemma 24; for the two
remaining cases use a straightforward induction.
For the second diagram, we know that, if C reduces, then M is an applica-
tion. Since M is closed, there is a term M ‚Ä≤ such that M ‚Üív M ‚Ä≤. Using the Ô¨Årst
diagram, we get C ‚Üíd‚âà‚àÜ[[M ‚Ä≤]]a.
6.5
Further optimizations
So we manage to mimic a Œ≤-reduction step with two œÄ-steps. Is is this best
we can do? For general terms, the author believes so. As long as we compile
lambda-terms in given pi-locations, the interaction with the term must be via
this location. In particular, invoking a function needs a message exchange at the
function‚Äôs location. Then, if we care for the result, we must read it somehow; I
cannot see any other way than exchanging a message for this purpose.
This is not to say that in particular cases we cannot do better.
As an
example, we try to optimize recursive functions. Take a call-by-value Ô¨Åxed-point
combinator [2].
Z
def
= ŒªfWW
with
W
def
= ŒªxŒªyf(xx)y.
The reader can easily check that, for each abstraction ŒªzM, there is a term
Z‚Ä≤ such that,
Z(ŒªzM) ‚Üív Z‚Ä≤
and
Z‚Ä≤V ‚Üí3
v M[Z‚Ä≤/z]V
23

Then, using the substitution lemma 19, we have that
[[Z‚Ä≤V ]]a ‚Üí5
d‚àº‚àÜŒΩr [[M[Z‚Ä≤/z]V ]]brb | r(a).[].
We thus see that the generic encoding requires Ô¨Åve-steps (plus the pending
reduction at r; cf. theorem 17) for the function to access its Ô¨Åxed-point combi-
nator Z‚Ä≤. We propose to compile recursive functions by letting the body of the
function know its location, thus allowing for the function to call itself directly
through its location,
[[Z(ŒªzM)]]a
def
= [[M[a/z]]]a.
The correctness of this optimization remains open at the time of this writing.
24

Chapter 7
Comparison with Milner‚Äôs
encoding
Milner proposed two encodings for the call-by-value lambda-calculus [8]. The
correctness of one of the encodings is proved in the paper; the analysis of the
other (more eÔ¨Écient, the ‚Äúlight version‚Äù) was established later by Pierce and
Sangiorgi [12]. This last encoding is quite similar to ours: not only value names
and reply-to names share the same types, but the two encodings are barbed
congruent.
7.1
The encoding
Milner‚Äôs encoding is a mapping {|M |}a : term ‚Üíname ‚Üíprocess, deÔ¨Åned as
{|x|}p
def
= px
{|ŒªxM |}p
def
= ŒΩa !a(xq).{|M |}q | pa
{|MN |}p
def
= ŒΩq {|M |}q | q(a).(ŒΩr {|N |}r | r(b).abp)
where names a, b, c, q, r are always fresh. As before we abbreviate processes of
the form !a(xq).{|M |}q to a := ŒªxM, relying on the surroundings to select the
appropriate deÔ¨Ånition for an environment entry.
First, notice that values write their value-names (either the variable itself, or
the location of the abstraction) on some reply-to name. An environment entry
gets the argument to the function and the channel where to locate the result;
if the evaluation of the function converges (to some value) then this channel is
written (with the value). In order to mimic an application MN located at p,
we Ô¨Årst evaluate the function M on some fresh reply-to name q, and wait for
the result b on q. Then we do the same for the argument N, thus obtaining
its result c. All that remains is to invoke b with c, requesting for the resulting
value to be sent on p.
The process machine, Process, is given by ‚ü®process, ‚Üíd, ‚àº‚ü©, where all three
components are deÔ¨Åned in section 5. Fix a name a not in variable; the term-to-
25

process correspondence is the the function deÔ¨Åned as
term-to-process(M)
def
= {|M |}a
if M is closed
This correspondence is discussed by Sangiorgi [16].
Theorem 25. The term-to-process correspondence is an operational correspon-
dence.
Proof. The two Ô¨Årst diagrams are corollaries 5.19 and 5.14 in Sangiorgi [16]; the
third constitutes a simple exercise.
7.2
Comparing
For comparison purposes, we are interested in the following theorem.
Theorem 26 ([16], Corollary 5.19). For M
closed,
M
‚Üív
N
implies
{|M |}p ‚Üí3
d‚àºp: oVal {|N |}p.
Notice that since M is closed, the only free name in {|M |}p is p, and p is a
reply-to name; hence the typing p: oVal in the congruence above.
Milner‚Äôs encoding enjoys a simple property: one reduction step in the call-
by-value Œª-calculus corresponds to three (deterministic) reduction steps in the
œÄ-calculus, modulo strong barbed congruence (theorem 26). In our case, all we
can say is that a normalizing term takes, on average, two pi-steps to simulate
a beta-step (theorem 17). Put in another way, Milner‚Äôs encoding is operational
(Theorem 25), whereas our is only convergent (Corollary 17).
The two encodings cannot be directly compared, for they have diÔ¨Äerent
signatures: Milner‚Äôs expects a term and a name, whereas ours further expects
a process. A simple analysis of the two encodings, leads us to compare the the
following pairs of processes and contexts
{|M |}p
and
[[M]]apa,
[[M]]a
and
ŒΩp {|M |}p | p(a).[].
Now we can ask: are {| M |}a and [[M]]apa bisimilar? Not in general. In an
untyped scenario, we can Ô¨Ånd a process able to distinguish the two encodings.1
However, if we stick to typed contexts, we can show that the two encodings are
indeed bisimilar.
Theorem 27. For M closed,
1. {|M |}p ‚âàp: oVal [[M]]apa;
2. [[M]]aP ‚âà‚àÖŒΩp {|M |}p | p(a).P.
Proof. 1. By induction on the structure of M. Uses the main results 20, 26 of
the two encodings.
Case M is a variable.
{|M |}p
def
= pM
def
= [[M]]apa
1To distinguish the two encodings of the term xI take the process x(bq).(pd | q(c).cer).
Notice, however that neither of the encodings was designed to run on arbitrary contexts.
26

Case M is an abstraction ŒªxN.
{|M |}p
def
=
ŒΩa !a(xq).{|N |}q | pa ‚âàp: oVal
(Induction)
ŒΩa !a(xq).[[N]]bqb | pa
def
=
[[M]]apa
Case M is an application. Since M is closed, there is a term N such that
M ‚Üív N. By the main result 26 of Milner‚Äôs encoding, we have
[[M]] ‚âàp: oVal {|N |}p.
By the main result 20 of our encoding,
[[M]]apa ‚âàp: oVal [[N]]apa.
The result follows by induction.
2. Similar.
27

Chapter 8
Encoding the SECD
machine into œÄ
We now present our encoding of the SECD machine into the œÄ-calculus, thereby
deÔ¨Åning a correspondence that turns out to be operational.
8.1
The encoding
To reduce the number of rules in the translation, we write ME do denote the
closure of a term M in an environment E, and deÔ¨Åne it as follows.
xE
def
= E(x)
ME
def
= ‚ü®M, E‚ü©
(M Ã∏‚ààvariable)
Closures and environments are translated into pi-contexts. More precisely,
we deÔ¨Åne a mapping [[Cl]]a : closure ‚Üíname ‚Üícontext that, given a closure
and a name, returns a context in whose hole the name denotes the location of
the term in the closure. The mapping for environments is [[E]]a : environment ‚Üí
name ‚Üícontext, that, given an environment E, yields a context where each term
Mi is located at a name xi, if ‚ü®xi, Cli‚ü©is a closure in E. The two mappings are
mutually recursive.
[[‚ü®M, E‚ü©]]a
def
= [[E]][[M]]a
[[‚àÖ]]
def
= []
[[E{Cl/x}]]
def
= [[Cl]]x[[E]]
An important property of the above encoding is that if a closure Cl contains
only values, then the hole in [[Cl]]a is under no preÔ¨Åx. We say that
1. a closure ‚ü®M, E‚ü©is a value closure if E is a value environment;
2. an environment E is a value environment if, for every variable x in the
domain of E, E(x) is a value closure.
3. nil is a value dump; if the closures in S are value closures, each ‚ü®M, E‚ü©for
M in C is a value closure, and D is a value dump, then ‚ü®S, E, C, D‚ü©is a
value dump.
Proposition 28. If Cl is a value closure, then the hole in [[Cl]]a is under no
preÔ¨Åx.
28

Proof. By expanding the deÔ¨Ånitions of [[V ]]a we see that the hole in [[E]][[V ]]a is
under no preÔ¨Åx if the hole in [[E]] is under no preÔ¨Åx. To show the that the hole
in [[E]] = [] is under no preÔ¨Åx, we proceed by induction. Clearly the hole in [[‚àÖ]]
is under no preÔ¨Åx; as for [[E{Cl/x}]] = [[Cl]]x[[E]], by induction the holes in [[Cl]]x
and in [[E]] are under no preÔ¨Åx.
The mapping [[D]]‚Éóa : dump ‚Üíname+ ‚Üícontext is inductively deÔ¨Åned by the
following rules that must be tried from top to bottom.
[[‚ü®S, E, N : M : ap: C, D‚ü©]]‚Éóa
def
= [[NE]]b[[‚ü®S, E, M : ap: C, D‚ü©]]b‚Éóa
(Ctr2)
[[‚ü®S, E, M : ap: C, D‚ü©]]b‚Éóa
def
= [[ME]]c[[‚ü®S, E, ap: C, D‚ü©]]bc‚Éóa
(Ctr1)
[[‚ü®S, E, ap: C, D‚ü©]]cb‚Éóa
def
= ŒΩr bcr | r(d).[[‚ü®S, E, C, D‚ü©]]d‚Éóa
(Call)
[[‚ü®S, E, nil, ‚ü®S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©‚ü©]]b‚Éóa
def
= ŒΩr rb | r(c).[[‚ü®S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©]]c‚Éóa
(Ret)
[[‚ü®S, E, M, D‚ü©]]‚Éóa
def
= [[ME]]b[[‚ü®S, E, nil, D‚ü©]]b‚Éóa
(Term)
[[‚ü®Cl: S, E, C, D‚ü©]]‚Éóa
def
= [[Cl]]b[[‚ü®S, E, C, D‚ü©]]b‚Éóa
(Stk)
[[D]]cb‚Éóa
def
= [][c/b]
(Nil)
The encoding proceeds by orderly compiling the Œª-terms in the control string
and in the stack (rules Ctr2, Ctr1, and Stk). To keep hold of the location of
these terms, our encoding asks for a sequence of names (name+ in the signature
of the encoding), rather than a single name. In this way, when time comes to
compile a dump with an ap at the head of the control string, we know which
function to call with which argument (rule Call).
Notice that rule Ret cannot be generalized to [[‚ü®S, E, nil, D‚ü©]]b‚Éóa
def
= ŒΩr rb |
r(c).[[D]]c‚Éóa, for the context [[‚ü®Cl: S, E, nil, nil‚ü©]]a would reduce, whereas the
dump ‚ü®Cl: S, E, nil, nil‚ü©does not.
Rules Term and Nil allow to show that
[[term-to-dump(M)]]a = [[M]]a.
Example 29. Take for M the term (ŒªxIx)V where V is a closed value. We
have seen in Example 9 that
term-to-dump(M) ‚Üí‚àó
SECD ‚ü®‚ü®V, ‚àÖ‚ü©, {‚ü®V, y‚ü©}, nil, ‚ü®nil, {‚ü®V, x‚ü©}, nil, ‚ü®nil, ‚àÖ, nil, nil‚ü©‚ü©‚ü©
Then, encoding the thus obtained dump into a pi-context, using rules Stk, Ret,
Ret, Nil, we get
[[V ]]b[ŒΩr‚Ä≤ r‚Ä≤b | ŒΩr r‚Ä≤(c).(rc | r(a).[])]
On the other hand, a adaptation of example 12.4 yields
[[M]]a ‚Üí2
d‚àº[[V ]]b[ŒΩr‚Ä≤ r‚Ä≤b | ŒΩr r‚Ä≤(c).rc | r(a).[]]
Notice that the pi contexts above are strongly barbed congruent (see Proposi-
tion 32 below).
29

8.2
Operational correspondence
The context machine, Context, is the triple ‚ü®context, ‚Üíd, ‚àº‚àÜ‚ü©. Fix a name a
not in variable; the dump-to-context correspondence is the function deÔ¨Åned as
follows.1
dump-to-context(D)
def
= [[D]]a
if D is a value dump
Theorem 30. The dump-to-context correspondence is operational.
To establish this result we need the exchange lemma 18, the alternative
encoding 22, and the following four lemmas.
Proposition 31. ŒΩr [[M]]ara | r(b).[] ‚àº‚àÜ[[M]]a[ŒΩr ra | r(b).[]].
Proof. Case analysis on M.
When M is a value, the left hand side of the
equation syntactically equals the right hand side. When M is an application
the left hand side is structural congruent to
ŒΩr ‚Ä≤[[N]]c[[L]]dcbr‚Ä≤ | ŒΩr r‚Ä≤(a).ra | r(b).[]
and the right hand side is structural congruent to
ŒΩr ‚Ä≤[[N]]c[[L]]dcbr‚Ä≤ | ŒΩr r‚Ä≤(a).(ra | r(b).[])
We only have to show that ŒΩr r‚Ä≤(a).ra | r(b).[] ‚àº‚àÜr‚Ä≤(a).(ra | r(b).[]), which
should be easy to establish.
Proposition 32. If the variables in the domain of E are not free in the hole,
then [[NE]]a[[ME]]b ‚àº‚àÜ[[E]][[N]]a[[M]]b.
Proof. A case analysis on M and N; uses the replication lemma 10.3. Suppose
that E is the environment {‚ü®xi, Cli‚ü©| i = 1, n}. Four cases must be analyzed.
Case M, N are variables.
Without loss of generality, suppose M is x1
and N is x2. The left-hand-side is [[Cl1]]a[[Cl2]]b, whereas the right-hand-side
is [[Cl1]]a[[Cl2]]b[[Cl3]]x3 . . . [[Cln]]xn . . . . To obtain the result, garbage collect en-
vironment entries x3 to xn since these names are not free in the hole.
Case exactly one of M, N is a variable. As above.
Case M and N are not variables. Use the replication lemma 10.3 for each
closure in E.
Theorem 33. If D ‚ÜíSECD D‚Ä≤, then [[D]]a ‚Üíd‚àº‚àÜ[[D‚Ä≤]]a or [[D]]a ‚àº‚àÜ[[D‚Ä≤]]a.
Proof. A case analysis on the dumps that are in the transition function; uses
the exchange lemma 18, the alternative encoding 22, and propositions 28, 31,
32. The relation that holds between [[D]]a and [[D‚Ä≤]]a is summarised in the table
below, according to the SECD reduction rule used.
1For dump-to-context to be a total function, add a rule [[D]]‚Éóa
def
= [] at the bottom of the list
of the rules that compose the mapping [[D]]‚Éóa above.
30

Rule
Relation
Var
‚â°
Abs
‚â°
App
‚àº‚àÜ
Call
‚Üíd‚àº‚àÜ
Ret
‚Üíd
Case Var. Three sub-cases must be analyzed. The diagrams below sum-
marise the proof.
‚ü®S, E, x: M : ap: C, D‚ü©
‚ÜíSECD/
Ctr2
3
‚ü®E(x): S, E, M : ap: C, D‚ü©
‚ü®Cl: S, E, x: ap: C, D‚ü©
‚ÜíSECD
/
Stk;Ctr1

‚ü®E(x): Cl: S, E, ap: C, D‚ü©
Stk;Stk
sffffffffffffffffffffff
[[E(x)]]b[[Cl]]c[[‚ü®S, E, ap: C, D‚ü©]]bca
‚ü®S, E, x, D‚ü©
‚ÜíSECD/
Ctr2
5
‚ü®E(x): S, E, nil, D‚ü©
Case Abs. Similar.
Case App. As above, three sub-cases must be analyzed.
‚ü®S, E, MN : L: ap: C, D‚ü©
‚ÜíSECD/
Ctr2

‚ü®S, E, N : M : ap: C, D‚ü©
Ctr2;Ctr1;Call

[[E]][[M]]b[[N]]cB
‚àº‚àÜ
/ [[ME]]b[[NE]]cB
where the context B is ŒΩrbcr | r(d).[[‚ü®S, E, L: ap: C, D‚ü©]]da. The ‚àº‚àÜstep follows
from proposition 32.
‚ü®Cl: S, E, MN : ap: C, D‚ü©
‚ÜíSECD /
Stk;Ctr1;Call

‚ü®Cl: S, E, N : M : ap: ap: C, D‚ü©
Ctr2;Ctr1;Call;Stk;Call

[[Cl]]e[[(MN)E]]dB
‚àº‚àÜ
/ [[NE]]b[[ME]]c[ŒΩr cbr | r(d).[[Cl]]eB]
where the context B is ŒΩr ‚Ä≤edr‚Ä≤ | r‚Ä≤(f).[[‚ü®S, E, C, D‚ü©]]fa. The ‚àº‚àÜstep follows
from proposition 32, the alternative encoding 22, and the exchange lemma 18.
‚ü®S, E, MN, D‚ü©
‚ÜíSECD
/
Term;Stk

‚ü®S, E, N : M : ap, D‚ü©
Ctr1;Ctr2;Call

[[ME]]dB
‚àº‚àÜ
/ [[NE]]b[[ME]]c[ŒΩr cbr | r(d).B]
where B is the context [[‚ü®S, E, nil, D‚ü©]]da. The ‚àº‚àÜstep follows from proposi-
tion 32, the alternative encoding 22.
31

Case Call.
‚ü®‚ü®ŒªxM, E‚Ä≤‚ü©: Cl: S, E, ap: C, D‚ü©
‚ÜíSECD/
Stk;Stk;Call

‚ü®nil, E‚Ä≤{Cl/x}, M, ‚ü®S, E, C, D‚ü©‚ü©
Term;Ret

[[Cl]]c[[E‚Ä≤]][[ŒªxM]]b[ŒΩr bcr | r(d).B]
‚Üíd‚àº‚àÜ/ [[E‚Ä≤{Cl/x}]][[M]]b[ŒΩr rb | r(d).B]
where B is the context [[‚ü®S, E, C, D‚ü©]]da. For the reduction step ‚Üíd, notice that
only values are present in closures so that the process ŒΩr bcr | r(d).B is under
no preÔ¨Åx (proposition 28). The ‚àº‚àÜstep follows from the garbage collection of
the environment entry at b, and from proposition 31.
Case Ret.
‚ü®Cl: S, E, nil, ‚ü®S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©‚ü©
‚ÜíSECD
/
Stk;Ret

‚ü®Cl: S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©
Stk

[[Cl]]b[ŒΩr rb | r(c).[[‚ü®S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©]]ca]
‚Üíd / [[Cl]]b[[‚ü®S‚Ä≤, E‚Ä≤, C‚Ä≤, D‚Ä≤‚ü©]]ba
Once again notice that, since only values are present in closures, the process
ŒΩr rb | r(c).B is under no preÔ¨Åx (proposition 28).
Theorem 34. If D ‚Üë, then [[D‚Ä≤]]a ‚Üë.
Proof. Examining the table in the proof of Theorem 33, one needs to show that
when D diverges there there are inÔ¨Ånitely many transitions by rules Call or
Ret. In other words, in any reduction, the number of consecutive applications
of rules Var, Abs, and App is Ô¨Ånite. That the above holds becomes obvious
by inspection of the transitions rules of the SECD machine, in Section 4. There
can only be a Ô¨Ånite number of consecutive applications of rules Var, Abs, and
App since the control string has a Ô¨Ånite number of elements, and each of its
elements (ap or a lambda term) is Ô¨Ånite.
Proof of Theorem 30. We show that the three diagrams in the deÔ¨Ånition of the
operational correspondence hold.
The Ô¨Årst corresponds to Theorem 33; the
second to the contrapositive of Theorem 34.
For the third diagram, we show its contrapositive, that is, if D Ã∏‚ÜíSECD
then [[D]]a Ã∏‚Üí. We proceed by analyzing the dumps that do not reduce. They
are of the form ‚ü®‚ü®E, M‚ü©: , , ap: , ‚ü©for M not an application, ‚ü®Cl, , ap: , ‚ü©,
‚ü®Cl: , , nil, nil‚ü©, ‚ü®nil, , nil, ‚ü©, and nil. Clearly their encodings do not reduce.
32

Chapter 9
Conclusion
We present an encoding for the call-by-value Œª-calculus into the œÄ-calculus that
is barbed-congruent to Milner‚Äôs well-known ‚Äúlight‚Äù encoding, and saves one œÄ-
reduction-step per Œ≤-reduction-step.
Based on the new lambda-to-pi encoding, we describe an encoding of the
SECD machine into the œÄ-calculus, and prove that is constitutes an operational
correspondence.
The impact of the call by value-Œª to œÄ encoding here proposed on actual,
œÄ-based, programming languages [13, 20] should be analyzed.
Also, further
optimizations for particular patterns of Œª-terms could be pursued.
The encoding of the SECD machine opens perspectives of encoding others
machines, thus providing for the study of other lambda reduction strategies in
the œÄ-calculus.
Sangiorgi presents Milner‚Äôs encoding using a continuation-passing scheme [16].
It should be interesting to investigate whether there is a continuation-passing-
style transform that would yield the encoding here presented.
The local œÄ-calculus [7] seems a promising setting to study the encoding,
obviating the need for typed contexts. All the proofs in the paper ultimately
rely on a handful of replication lemmas. It remains to see if these theorems are
valid in the local œÄ-calculus.
Acknowledgements. Special thanks to D. Sangiorgi and A. Ravara for fruitful
discussions. The Wednesday Morning Club at the University of Lisbon provided
important feedback, N. Barreiro in particular. This work is partially supported
by project PRAXIS/P/EEI/120598/98 DiCoMo.
33

Bibliography
[1] H. P. Barendregt. The Lambda-Calculus, its Syntax and Semantics, vol-
ume 103 of Studies in Logic and the Foundations of Mathematics. North-
Holland, 1974. Revised edition.
[2] Carl A. Gunter. Semantics of Programming Languages. MIT Press, 1992.
[3] Kohei Honda and Mario Tokoro. An object calculus for asynchronous com-
munication. In 5th European Conference on Object-Oriented Programming,
volume 512 of LNCS, pages 141‚Äì162. Springer-Verlag, 1991.
[4] Naoki Kobayashi.
A partially deadlock-free typed process calculus.
In
Proceedings of LICS ‚Äô97, pages 128‚Äì139. Computer Society Press, July
1997.
[5] P. J. Landin. The mechanical evaluation of expressions. Computer Journal,
6(4), 1964. Referred in [14].
[6] L. Lopes, F. Silva, and V. Vasconcelos. A virtual machine for the TyCO pro-
cess calculus. In PPDP‚Äô99, volume 1702 of LNCS, pages 244‚Äì260. Springer-
Verlag, September 1999.
[7] Massimo Merro and Davide Sangiorgi.
On asynchrony in name-passing
calculi. In Kim G. Larsen, Sven Skyum, and Glynn Winskel, editors, Pro-
ceedings of ICALP ‚Äô98, volume 1443 of LNCS, pages 856‚Äì867. Springer,
July 1998.
[8] Robin Milner. Functions as processes. Rapport de Recherche RR-1154,
INRIA Sophia-Antipolis, 1990. Final version in [9].
[9] Robin Milner. Functions as processes. Journal of Mathematical Structures
in Computer Science, 2(2):119‚Äì141, 1992.
[10] Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile
processes, I and II. Information and Computation, 100:1‚Äì77, 1992.
[11] Robin Milner and Davide Sangiorgi. Barbed bisimulation. In W. Kuich,
editor, Proceedings of ICALP ‚Äô92, volume 623 of LNCS, pages 685‚Äì695.
Springer, 1992.
[12] Benjamin C. Pierce and Davide Sangiorgi. Typing and subtyping for mobile
processes.
Mathematical Structures in Computer Science, 6(5):409‚Äì454,
1996. An extract appeared in Proceedings of LICS ‚Äô93: 376‚Äì385.
34

[13] Benjamin C. Pierce and David N. Turner. Pict: A programming language
based on the pi-calculus. CSCI Technical Report 476, Indiana University,
March 1997.
[14] G.D. Plotkin. Call-by-name and call-by-value and the Œª-calculus. Theoret-
ical Computer Science, 1:125‚Äì159, 1975.
[15] Davide Sangiorgi.
Expressing Mobility in Process Algebras: First-Order
and Higher-Order Paradigms. PhD thesis, University of Edinburgh, 1992.
[16] Davide Sangiorgi. Interpreting functions as œÄ-calculus processes: a tutorial.
Unpublished, August 1998.
[17] David N. Turner. The Polymorphic Pi-Calculus: Theory and Implementa-
tion. PhD thesis, LFCS, University of Edinburgh, June 1996. CST-126-96
(also published as ECS-LFCS-96-345).
[18] Vasco T. Vasconcelos. Typed concurrent objects. In 8th European Confer-
ence on Object-Oriented Programming, volume 821 of LNCS, pages 100‚Äì
117. Springer-Verlag, July 1994.
[19] Vasco T. Vasconcelos. Processes, functions, datatypes. Theory and Practice
of Object Systems, 5(2):97‚Äì110, 1999.
[20] Vasco T. Vasconcelos and Rui Bastos. Core-TyCO, the language deÔ¨Åni-
tion, version 0.1. DI/FCUL TR 98‚Äì3, Department of Computer Science,
University of Lisbon, March 1998.
35

