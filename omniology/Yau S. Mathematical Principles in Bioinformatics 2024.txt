Interdisciplinary Applied Mathematics  58
Mathematical 
Principles in 
Bioinformatics 
Stephen S.-T. Yau · Xin Zhao · 
Kun Tian · Hongyu Yu

Interdisciplinary Applied Mathematics 
Volume 58 
Series Editors 
Anthony Bloch, University of Michigan, Ann Arbor, MI, USA 
Charles L. Epstein, University of Pennsylvania, Philadelphia, PA, USA 
Alain Goriely, University of Oxford, Oxford, UK 
Leslie Greengard, New York University, New York, USA 
Advisory Editors 
Rick Durrett, Duke University, Durham, NC, USA 
Andrew Fowler, University of Oxford, Oxford, UK 
L. Glass, McGill University, Montreal, QC, Canada 
R. Kohn, New York University, New York, NY, USA 
P. S. Krishnaprasad, University of Maryland, College Park, MD, USA 
C. Peskin, New York University, New York, NY, USA 
S. S. Sastry, University of California, Berkeley, CA, USA 
J. Sneyd, University of Auckland, Auckland, New Zealand

Problems in engineering, computational science, and the physical and biological 
sciences are using increasingly sophisticated mathematical techniques. Thus, the 
bridge between the mathematical sciences and other disciplines is heavily traveled. 
The correspondingly increased dialog between the disciplines has led to the 
establishment of the series: Interdisciplinary Applied Mathematics. 
The purpose of this series is to meet the current and future needs for the 
interaction between various science and technology areas on the one hand and 
mathematics on the other. This is done, ﬁrstly, by encouraging the ways that 
mathematics may be applied in traditional areas, as well as point towards new 
and innovative areas of applications; and secondly, by encouraging other scientiﬁc 
disciplines to engage in a dialog with mathematicians outlining their problems to 
both access new methods as well as to suggest innovative developments within 
mathematics itself. 
The series will consist of monographs and high-level texts from researchers 
working on the interplay between mathematics and other ﬁelds of science and 
technology.

Stephen S.-T. Yau • Xin Zhao • Kun Tian • 
Hongyu Yu 
Mathematical Principles 
in Bioinformatics

Stephen S.-T. Yau 
Department of Mathematical Sciences 
Tsinghua University 
Beijing, China 
Yanqi Lake Beijing Institute of 
Mathematical Sciences and Applications 
(BIMSA) 
Beijing, China 
Kun Tian 
Department of Mathematics 
Renmin University of China 
Beijing, China 
Xin Zhao 
Beijing Electronic Science and Technology 
Institute 
Beijing, China 
Hongyu Yu 
Department of Mathematical Sciences 
Tsinghua University 
Beijing, China 
ISSN 0939-6047
ISSN 2196-9973 
(electronic) 
Interdisciplinary Applied Mathematics 
ISBN 978-3-031-48294-6
ISBN 978-3-031-48295-3 
(eBook) 
https://doi.org/10.1007/978-3-031-48295-3 
© The Editor(s) (if applicable) and The Author(s), under exclusive license to Springer Nature Switzerland 
AG 2023 
This work is subject to copyright. All rights are solely and exclusively licensed by the Publisher, whether 
the whole or part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse 
of illustrations, recitation, broadcasting, reproduction on microﬁlms or in any other physical way, and 
transmission or information storage and retrieval, electronic adaptation, computer software, or by similar 
or dissimilar methodology now known or hereafter developed. 
The use of general descriptive names, registered names, trademarks, service marks, etc. in this publication 
does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant 
protective laws and regulations and therefore free for general use. 
The publisher, the authors, and the editors are safe to assume that the advice and information in this book 
are believed to be true and accurate at the date of publication. Neither the publisher nor the authors or 
the editors give a warranty, expressed or implied, with respect to the material contained herein or for any 
errors or omissions that may have been made. The publisher remains neutral with regard to jurisdictional 
claims in published maps and institutional afﬁliations. 
This Springer imprint is published by the registered company Springer Nature Switzerland AG 
The registered company address is: Gewerbestrasse 11, 6330 Cham, Switzerland 
Paper in this product is recyclable.

Preface 
Bioinformatics is among the newest and most highly demanded subjects in biology 
and mathematics. In recent years, however, bioinformatics has undergone vast 
changes in style and language. For these reasons, the subject has gained a reputation 
for inaccessibility. This book presents the main laws of general biology in a rigorous 
mathematical setting, accompanied by, and indeed with special emphasis on, appli-
cations to the study of various interesting biological problems and the development 
of useful computational tools. I hope that this book will serve two purposes. The 
ﬁrst one is to introduce the subject of bioinformatics to readers without a biology 
background. The second one is to give biologists valid mathematical tools for 
biological analysis and to help biologists understand how to use these mathematical 
tools to deal with bioinformatics problems. 
Many studies in molecular biology require performing speciﬁc computational 
procedures on given sequence datasets. Traditional textbooks and bioinformatics 
methods are normally based on multiple sequence alignment (MSA) analysis. 
However, there are two fundamental drawbacks to alignment methods. The ﬁrst 
one is that these methods are based on the choice from a variety of models. How 
the model is chosen is somewhat arbitrary, and if the wrong model is chosen, the 
results may be inaccurate. Second, using the language of computational complexity 
theory, the MSA algorithm is non-deterministic polynomial-time hard (NP-hard). 
As a result, it is unable to cluster a dataset consisting of thousands of sequences, not 
to mention the million sequence datasets required in modern molecular biology. 
When I started teaching bioinformatics courses, I quickly realized that none 
of the textbooks that I found on the subject covered the above problems. Those 
textbooks were not very satisfying from a mathematician’s point of view and were 
unacceptable for my purposes. I was looking for fundamental laws which govern 
seemingly complicated biological phenomena. What I needed was a clear and 
mathematically rigorous exposition of the procedures, algorithms, and principles 
commonly used in bioinformatics. Consequently, I began writing my own lecture 
notes. It is these notes, together with my research work, which have been published 
in various journals, that form the basis of this book. I used these materials to teach 
bioinformatics courses at the Department of Mathematics, Statistics, and Computer
v

vi
Preface
Science of the University of Illinois at Chicago for two years before 2011. I also used 
these materials to teach at the Department of Mathematical Sciences of Tsinghua 
University in Beijing, China in 2013, 2018, 2019, and 2022. 
This book can be divided into two parts. The ﬁrst part has three chapters 
that provide an introduction to the subject of bioinformatics for readers with 
good mathematical backgrounds but insufﬁcient biological backgrounds. This 
ﬁrst part covers basic background knowledge in molecular biology, some useful 
bioinformatics databases, and the concept of sequence alignment. Chapter 1 covers 
nucleotides, DNA, RNA, proteins, the genetic code, and how DNA translates 
into proteins. Chapter 2 describes commonly used databases, such as nucleotide 
sequence databases, protein sequence databases, and sequence motif databases. 
Chapter 3 is concerned with alignment methods, for example, global alignment, 
local alignment, and multiple alignments. 
The second part of the book consists of ﬁve chapters that describe several 
bioinformatics principles using a rigorous mathematical formulation. The aim of 
this part is to give biologists valid mathematical tools for understanding biology. 
Chapter 4 introduces the time-frequency spectral principle and its applications in 
bioinformatics. In Chaps. 5 and 6, we use two-dimensional graphical representations 
which allow people to visually compare different DNA sequences or different 
protein sequences and see their differences. We also introduce higher dimensional 
natural vectors which are able to represent DNA and protein sequences without 
losing any information. This provides real-time, accurate complete sequence com-
parison and phylogenetic analysis. Chapter 7 presents the convex hull principle and 
shows how it can be used to mathematically determine whether a certain amino acid 
sequence can be a protein. The last chapter summarizes additional mathematical 
ideas relating to sequence comparisons, such as new feature vectors and metrics. 
Our book discusses and gives principles that relate to the current open problems 
in bioinformatics. One guiding light is the convex hull principle. It states that 
the convex hulls formed from the natural vectors of the genomes/proteins from 
the same family do not intersect with convex hulls of natural vectors from other 
families. This principle implies that biological sequences with similar distributions 
of the nucleotides or amino acids should be in the same family. This opens up 
a new interdisciplinary area of research in biology, mathematics, and computer 
science. We believe that our convex hull principle will become a powerful tool 
in protein research and it can be viewed as a biological law. Another important 
principle is how to determine whether an arbitrary amino acid sequence can be a 
protein sequence. No one has developed a criterion for this before. We show that 
when the collection of arbitrary amino acid sequences is viewed in an appropriate 
geometric context, the protein sequences cluster together. This leads to a new 
computational test that has proved to be remarkably accurate at determining whether 
an arbitrary amino acid sequence can be a protein. We believe our computational 
test will be useful for researchers who are attempting to complete the job of 
discovering all proteins or constructing the protein universe. The 3-base periodicity 
principle is a useful tool that is also introduced in our book. The 3-base periodicity, 
identiﬁed as a pronounced peak at the frequency N = 3 of the Fourier power

Preface
vii
spectrum of the DNA sequences, is prevalent in most exon sequences, but not 
in intron sequences. This gives a new understanding of gene prediction study 
based on Fourier spectral analysis. We also introduce effective ways of performing 
sequence comparisons and phylogenetic analyses. DNA and protein sequences can 
be represented geometrically as two-dimensional graphs or algebraically as high-
dimensional natural vectors without losing any information about the sequence. The 
two representations are in one-one correspondence, and you can convert between a 
sequence and either of its representations without losing information. The similarity 
between two sequences can be calculated using either representation. The Yau-
Hausdorff distance is used for calculating similarity for the graph representation, 
and the usual Euclidean distance is used for the natural vector representation 
similarity calculation. This creates a new space with biological distance, which 
allows us to do phylogenetic analysis in a most natural and efﬁcient manner. To 
be self-contained, the book includes a description of the Yau-Hausdorff distance. 
Among the above principles, the convex hull principle is of the greatest signiﬁ-
cance and provides a solution to one of the 23 Mathematical Challenges of DARPA 
(The Defense Advanced Research Projects Agency): “What are the Fundamental 
Laws of Biology?” This principle, along with the outstanding performance of the 
natural vectors in the classiﬁcation problem, shows that the geometry of the space 
formed by natural vectors can reﬂect the relationship among biological sequences 
well. It also solves another problem of DARPA: “The Geometry of Genome Space.” 
Overall, the book concentrates on mathematical methods in bioinformatics 
including plenty of natural ideas and my own research progress in the area. There 
is no available book that discusses the fundamental principle of bioinformatics. 
Most of the books in the market rely on some artiﬁcial assumptions, the so-called 
model approach. Ours is the ﬁrst book that develops the fundamental principles 
of bioinformatics. Although this book is primarily a textbook for students with 
some mathematical background, at the same time, it is also suitable for any 
mathematician or biologist, or anyone who is interested in mathematical principles 
in bioinformatics. The mathematical knowledge used in the book is explained in 
detail. 
We would like to thank my friend Prof. Alexander Isaev of the Department 
of Mathematics of the Australian National University (ANU) in Canberra for 
his encouragement and many valuable comments. In fact, the Chap. 3 Sequence 
Alignment was written with his generous help. I also want to thank all my previous 
Ph.D. students in the subject of Bioinformatics. Much of the work described in 
Chaps. 4 through 8 was done by them under my guidance. 
My father passed away when I was 11 years old. I am very grateful to my mother, 
Yau-Leung Yeuk Lam, who was determined to give me the chance to receive a high-
level education. Without her continuous support, I would not be able to make this 
contribution to the ﬁeld of bioinformatics today. I owe so much to her for who I am 
and who I shall be. 
Beijing, China
Stephen S.-T. Yau 
April, 2023

Acknowledgments 
Stephen S.-T. Yau is supported by National Natural Science Foundation of China 
(NSFC) grant (12171275) and Tsinghua University Education Foundation fund 
(042202008). Xin Zhao is supported by National Natural Science Foundation of 
China (NSFC) grant (12201015).
ix

Contents 
1 
Biological Overview..................................................................... 
1 
1.1 
Basic Information on Macromolecules....................................... 
1 
1.2 
The Central Dogma............................................................... 
2 
1.3 
Nucleotides and Amino Acids.................................................. 
4 
1.4 
DNA................................................................................... 
5 
1.5 
RNA................................................................................... 
7 
1.6 
Protein................................................................................ 
8 
1.7 
The Genetic Code.................................................................. 
10 
2 
Bioinformatics Databases............................................................. 
13 
2.1 
Introduction to Bioinformatics Databases................................... 
13 
2.2 
Nucleotide Sequence Databases................................................ 
14 
2.2.1 
EMBL (http://www.ebi.ac.uk/embl/)................................ 
14 
2.2.2 
DDBJ (http://www.ddbj.nig.ac.jp/).................................. 
14 
2.2.3 
GenBank (http://www.ncbi.nlm.nih.gov/genbank/).............. 
15 
2.3 
Protein Sequence Databases..................................................... 
18 
2.3.1 
Swiss-Prot (https://www.uniprot.org/uniprotkb? 
query=reviewed:true)................................................... 
18 
2.3.2 
TrEMBL (https://www.uniprot.org/uniprotkb? 
query=reviewed:false).................................................. 
19 
2.3.3 
PIR (http://pir.georgetown.edu)....................................... 
19 
2.4 
Sequence Motif Databases....................................................... 
20 
2.4.1 
Pfam (http://pfam.xfam.org/).......................................... 
20 
2.4.2 
PROSITE (http://prosite.expasy.org/)............................... 
20 
2.5 
Macromolecular 3D Structure Databases.................................... 
21 
2.5.1 
PDB (http://www.rcsb.org/)........................................... 
21 
2.5.2 
SCOP (http://scop.mrc-lmb.cam.ac.uk/scop/)..................... 
22 
2.5.3 
CATH (http://www.cathdb.info)...................................... 
23 
2.5.4 
DALI (http://ekhidna2.biocenter.helsinki.ﬁ/dali/)................ 
25 
3 
Sequence Alignment.................................................................... 
27 
3.1 
Sequence Similarity............................................................... 
27
xi

xii
Contents
3.2 
Global Alignment.................................................................. 
29 
3.3 
Local Alignment................................................................... 
30 
3.4 
Alignment with Afﬁne Gap Model............................................ 
31 
3.5 
Heuristic Alignment Algorithms............................................... 
34 
3.5.1 
FASTA...................................................................... 
34 
3.5.2 
BLAST..................................................................... 
36 
3.6 
Multiple Alignment............................................................... 
36 
3.6.1 
MSA......................................................................... 
39 
3.6.2 
Progressive Alignment.................................................. 
40 
4 
The Time-Frequency Spectral Analysis and Applications in 
Bioinformatics............................................................................ 
43 
4.1 
Introduction......................................................................... 
43 
4.2 
Discrete Fourier Transform...................................................... 
43 
4.3 
Exon Prediction Based on Fourier Spectral Analysis..................... 
48 
4.3.1 
Eukaryotic Gene Structure............................................. 
48 
4.3.2 
Fourier Spectrum Analysis of DNA Sequences.................. 
49 
4.3.3 
The 3-Base Periodicity in Exon Sequences........................ 
51 
4.3.4 
PS(N/3) Is Determined by the Unbalanced 
Nucleotide Distributions of the Three Codon Positions........ 
52 
4.3.5 
Algorithm for Finding Exons by Nucleotide 
Distribution (FEND).................................................... 
54 
4.4 
DNA Comparison Based on Fourier Spectral Analysis................... 
60 
4.4.1 
Even Scaling Method of Fourier Power Spectrum............... 
60 
4.4.2 
Power Spectrum Moment Method................................... 
61 
4.4.3 
Cumulative Power Spectrum Moment Method................... 
63 
5 
Graphical Representation of Sequences and Its Application.............. 
65 
5.1 
Graphical Representation by Curves Without Degeneracy.............. 
65 
5.1.1 
A Construction Without Degeneracy................................ 
65 
5.1.2 
Other Constructions Without Degeneracy......................... 
69 
5.1.3 
Constructions for Proteins............................................. 
75 
5.1.4 
Yau-Hausdorff Distance................................................ 
81 
5.2 
Chaos Game Representation.................................................... 
84 
5.2.1 
Chaos Game Representation for DNA Sequences............... 
84 
5.2.2 
Chaos Game Representation for Proteins.......................... 
86 
6 
The Development and Applications of the Natural Vector Method...... 
91 
6.1 
The Natural Vector Method for DNA Sequences.......................... 
91 
6.2 
The Properties and Advantages of the Natural Vector Method......... 
93 
6.2.1 
The One-to-One Correspondence Between DNA 
Sequence and Its Natural Vector..................................... 
93 
6.2.2 
The Convergence to 0 for High-Order Moments................. 
95 
6.2.3 
Advantages................................................................ 
96 
6.3 
The Natural Vector Method for Protein Sequences........................ 
96 
6.4 
The Natural Graph Method...................................................... 
97

Contents
xiii
6.5 
Applications......................................................................... 
98 
6.5.1 
12-Dimensional Viral Genome Space............................... 
98 
6.5.2 
60-Dimensional Protein Space........................................ 105 
6.6 
Other Alignment-Free Methods Motivated by the Natural 
Vector Method...................................................................... 113 
7 
Convex Hull Principle and Distinguishing Proteins from 
Arbitrary Amino Acid Sequences.................................................. 115 
7.1 
The Convex Hull Principle...................................................... 115 
7.1.1 
Methods for Determining Whether Two Convex 
Hulls Intersect............................................................ 116 
7.1.2 
The Veriﬁcation of the Convex Hull Principle.................... 118 
7.1.3 
New Sequence Detection............................................... 119 
7.2 
Distinguishing Proteins from Arbitrary Amino Acid Sequences....... 125 
7.2.1 
The Principle and the Algorithm..................................... 126 
7.2.2 
The Veriﬁcation by Real Protein Sequences....................... 129 
7.2.3 
Derivation for the Equations of the Boundaries of 
Amino Acid Space....................................................... 132 
8 
New Features or Metric on Sequence Comparison........................... 139 
8.1 
The K-mer Natural Vector Method and Its Application.................. 139 
8.2 
New Features Based on the Singular Value Decomposition............. 145 
8.2.1 
The K-mer Sparse Matrix Model and Its Applications......... 145 
8.2.2 
Noise Reduction Based on the Singular Value 
Decomposition............................................................ 148 
8.3 
DFA7: A Novel Approach for Discriminating 
Intron-Containing and Intronless Genes...................................... 149 
8.4 
The Lempel–Ziv Complexity and Its Application in 
Sequence Comparison............................................................ 152 
8.5 
An Information-Based Network Approach for Protein 
Classiﬁcation........................................................................ 154 
References....................................................................................... 161

Chapter 1 
Biological Overview 
The purpose of this chapter is to provide some basic background in molecular 
biology for readers. Among the molecules in cells, macromolecules, which are large 
molecules made by joining small molecules (monomers) into polymers, are of most 
interest to us. There are three types of macromolecules: DNA, RNA, and protein. 
In this chapter, we will introduce their components, structures, and properties and 
show how DNA templates RNA and protein [1]. 
1.1 
Basic Information on Macromolecules 
In this section, we only introduce some basic concepts of three types of macro-
molecules. Further information will be shown in later sections. 
Nucleic acids are the polymers of nucleotides. They can be divided into two 
classes: deoxyribonucleic acids (DNA) and ribonucleic acids (RNA). Both of them 
have a distinguishable direction from one end called 5 prime5′ to the other end called 3 prime3′. 
(The reason why they are named 5 prime5′ and 3 prime3′ will be provided in Sect. 1.4.) 
DNA is the basis of heredity and all other macromolecules are made from the 
instruction of DNA, directly or indirectly. Nucleobases of nucleotides in DNA 
include adenine (A), cytosine (C), guanine (G), and thymine (T). In most cases, 
DNA exists as a double-stranded form. Two strands are connected by hydrogen 
bonds between complementary bases in each strand (A matches T and C matches 
G). Two strands form a helix structure and the direction of the two strands are 
opposite. (See Fig. 1.1.) Therefore, the relationship between the two strands is a 
reverse complement. 
The nucleotides of RNA are different from those of DNA in two aspects. First, the 
nucleobases thymine (T) is replaced by uracil (U). In other words, RNA is written 
as a string of letters from {A, C, G, U}. Second, the sugar in the nucleotides is 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_1
1

2
1
Biological Overview
Fig. 1.1 Double-stranded 
DNA 
Table 1.1 Amino acids and their abbreviations 
Amino acid 
3 letter  
code 
1 letter  
code
Amino acid 
3 letter 
code 
1 letter 
code
Amino acid 
3 letter  
code 
1 letter  
code 
Alanine
Ala
A
Glycine
Gly
G
Proline
Pro
P 
Arginine
Arg
R
Histine
His
H
Serine
Ser
S 
Aspartic acid Asp
D
Isoleucine
Ile
I
Threonine
Thr
T 
Asparagine
Asn
N
Leucine
Leu
L
Tryptophan
Trp
W 
Cysteine
Cys
C
Lysine
Lys
K
Tyrosine
Tyr
Y 
Glutamic acid Glu
E
Methionine
Met
M
Valine
Val
V 
Glutamine
Gln
Q
Phenylalanine Phe
F 
Fig. 1.2 The central dogma 
A schematic presents the formation of protein from d n a replication through r n 
a via transcription and translation.
Protein is a kind of polymer made of 20 types of amino acids with directionality. 
Table 1.1 is the list of the amino acids and their abbreviations. 
1.2 
The Central Dogma 
In 1958, Francis Crick put forward the “central dogma” to summarize the infor-
mation ﬂow in a cell. The information here refers to the determination of the 
sequence, either base in the nucleic acid or amino acids’ residues in the protein. The 
direction of information ﬂow shows how one macromolecule is synthesized with the 
instruction of another macromolecule. Except for some special viruses, the “central 
dogma” includes three processes: the replication process of DNA, the transcription 
process to produce RNA, and the translation process to synthesize protein (Fig. 1.2). 
Replication is illustrated by the loop from DNA to DNA in the picture. It is 
the process that DNA duplicates with the guidance of itself in cell division. In 
replication, two strands in the double helix are separated with a special class of 
enzymes called helicases and then each strand is used to template a complementary 
strand from 5 prime5′ to 3 prime3′. In this way two almost identical molecules are made, each 
having one strand of the original molecule. We say they are almost identical 
because there are replication errors. By a series of correction mechanisms, the ﬁnal 
replication error rate is less than 10 Superscript negative 910−9. The accumulation of replication errors can 
lead to dysfunction or even cancer for organisms while it is a signiﬁcant part of 
evolution (Fig. 1.3).

1.2
The Central Dogma
3
Fig. 1.3 Replication 
Fig. 1.4 Transcription 
Transcription is the process to let information ﬂow from DNA to RNA. In 
transcription, after separating two strands of the double helix, one strand of DNA 
will be used to template a single strand of RNA. After this process, the double-
stranded DNA remains as before and a single-stranded RNA is synthesized with the 
instruction of DNA (Fig. 1.4). 
Translation is the process that protein is encoded by messenger RNA (mRNA). 
Speciﬁcally speaking, in ribosomes, a type of organelle, mRNA acts as a template 
and transfer RNA (tRNA) transports amino acids, which are the raw material of 
protein. They work together to synthesize long polypeptide chains of amino acids 
and these polypeptide chains will become proteins after folding into particular 
three-dimensional structures. In translation, three nucleotides (known as a codon) 
correspond to one amino acid. 
From the “central dogma,” we can say that DNA is the genetic material of all cells 
and most viruses. First, organisms use DNA to transfer genetic information to their 
descendants. Second, other macromolecules (RNA and protein) are all produced 
with the instruction of DNA, directly or indirectly so DNA contains all the heredity 
information of the organisms. 
The “central dogma” also states that the information ﬂow from DNA to protein 
is irreversible. It is possible to transfer the heredity information from nucleic acids 
to nucleic acids or from nucleic acids to proteins, but it is impossible to transfer the 
heredity information from proteins to proteins, or from proteins to nucleic acids. 
Today, the “central dogma” has been extended. Two other information ﬂow paths, 
RNA replication and reverse transcription, have been found in viruses. Some viruses 
use RNA as templates to produce new RNA directly and some viruses use RNA to 
synthesize the complementary DNA (cDNA) ﬁrst and then use cDNA to produce 
RNA that can encode protein. The genetic materials of these two types of viruses 
are RNA.

4
1
Biological Overview
Fig. 1.5 The structure of the 
nucleotide 
1.3 
Nucleotides and Amino Acids 
Nucleotides are the monomers that compose DNA and RNA. A nucleotide is com-
posed of three parts: a nitrogen-containing base (nucleobase), a sugar molecule, and 
a phosphate group. Speciﬁcally, the nucleobase connects the 1 prime1′ carbon of the sugar 
while the phosphate group is bound to the 5 prime5′ carbon. For deoxyribonucleotides, 
the sugar molecule is deoxyribose and the nucleobase is chosen from adenine (A), 
cytosine (C), guanine (G), and thymine (T). For ribonucleotides, the sugar molecule 
is ribose and the nucleobase uracil (U) replaces thymine (T). (See Fig. 1.5. X is H for  
deoxyribonucleotide, the nucleotides that form DNA, and is OH for ribonucleotide, 
the nucleotides that form RNA. In the graph, some H molecules are omitted.) 
Among ﬁve bases, adenine and guanine have a 2-ring structure and are called 
purines. Cytosine, thymine, and uracil have a 1-ring structure and are called 
pyrimidines. (See Fig. 1.6.) An important property of nucleobases is that they can 
form hydrogen bonds between complementary bases (A with T or U and C with G) 
when forming the double-strand structure in nucleic acids. There are two hydrogen 
bonds in A-T pairing and A-U pairing and there are three hydrogen bonds in C-G 
pairing. 
There can be more than one phosphate group attached to a nucleotide. Taking off 
additional phosphate groups produces energy while attaching new phosphate groups 
absorbs energy. This property is practical for cells to transport energy. In the process 
of extending DNA or RNA, the raw materials are nucleotides that have three extra 
phosphate groups (triphosphate nucleotides) since they can provide the energy for 
extensions. 
The chemical structure of the amino acid can be regarded as a central carbon 
(CSubscript alphaα) connecting an amino group (-NHSubscript 22), a carboxyl group (-COOH), and an R 
group which determines the type of the amino acid. (See Fig. 1.7.) The R group can 
be also called the residue. There are 20 kinds of residues. 
These different residues lead to diverse chemical properties of amino acids. 
It is believed that one of the most important driving forces in protein folding 
is the hydrophobic force, which represents the tendency for a molecule to avoid 
contact with water molecules. Besides the properties of amino acids themselves, the 
interaction between amino acids such as salt bridges and disulﬁde bonds is also of 
great signiﬁcance.

1.4
DNA
5
Fig. 1.6 The structure of ﬁve nucleobases 
Fig. 1.7 The structure of the 
amino acid 
1.4 
DNA 
Deoxyribonucleotides form a strand via the phosphodiester bond where the phos-
phate group of one nucleotide is attached to the 3 prime3′ carbon of the deoxyribose of 
the next nucleotide. There is a direction for each strand. The end where nucleotide 
has a free phosphate group is called the 5 prime5′ end and the other end is called the 
3 prime3′ end. (The number is the carbon atom position where the next nucleotide can 
be attached.) In nature, the energy for the DNA extension is given by the new 
nucleotide containing three phosphate groups. Therefore, DNA always extends from 
5 prime5′ to 3 prime3′. If the extending direction is opposite, then we need to add phosphate groups 
to the 5 prime5′ end of the existing strand to provide energy. In this way, removing the ﬁrst 
nucleotides on the 5 prime5′ end will be hard because the energy provider will be removed. 
In the eukaryotic cell nucleus, DNA is combined with protein to form chromo-
somes. To be speciﬁc, DNA tightly entangles a type of highly conserved protein, 
histones, in the structure nucleosome and makes chromosomes visible after using 
certain stains. For each nucleosome, the DNA molecule of about 150–200 bps forms 
about two superhelices. For high-level organisms, most DNA appears in pairs of

6
1
Biological Overview
Table 1.2 Notations for nucleotides (including uncertain cases) 
Code
Meaning
Complement
Code
Meaning
Complement 
A
A
T
Y
C or T
R 
C
C
G
K
G or T
M 
G
G
C
B
C or G or T
V 
T
T
A
D
A or G or T
H 
M
A or C
K
H
A or C or T
D 
R
A or G
Y
V
A or C or G
B 
S
C or G
S
X/N
A or C or G or T  
X 
W
A or T
W
bullet•
not A, C, G, T
bullet•
linear chromosomes and for many viruses and bacteria, DNA can exist in a circular 
form. 
In sequencing, due to laboratory uncertainties, we sometimes cannot completely 
determine all bases. For example, we may know a certain base is either A or C but 
we are not sure which is true. Therefore, we will use some notations to denote these 
situations. (See Table 1.2.) 
The entire set of DNA in a cell can be called a genome. For human beings, there 
are about 3 times 10 Superscript 93 × 109 letters in the genome. A natural idea is that there is a strong 
relationship between the length of the genome and the complexity of organisms. 
However, it is not always correct. For instance, the lungﬁsh genome is almost 50 
times as large as the human genome. 
Genes are the basic unit of heredity. A gene can be viewed as the entire sequence 
of nucleotides that is needed for producing a polypeptide chain or functional RNA. 
A DNA molecule can contain many genes. It is worth noticing that there exist some 
parts of a DNA molecule that do not belong to any gene. Another essential point to 
note is that not all segments within a gene directly encode proteins. These segments 
are referred to as non-coding regions. Conversely, the segments responsible for 
coding proteins are known as coding regions. 
Biologists have found a counterintuitive fact that the percentage of nucleotides 
in non-coding regions can be very high for many organisms. Among 23 pairs of 
chromosomes amounting to about 3 times 10 Superscript 93 × 109 base pairs in the human genome, there 
are only about 10 Superscript 5105 genes [2]. We have mentioned that three bases correspond to one 
amino acid in translation. Assuming that a protein consists of at most 1000 amino 
acids, then we can infer that 90 percent sign90% of DNA is non-coding [2]. Being non-coding does 
not mean being useless. Non-coding regions such as promoters and terminators are 
of great signiﬁcance for cells. 
The promoter is a section of DNA upstream of a gene that RNA polymerases 
bind when producing RNA. It is the starting point of transcription. The terminator, 
similarly, is a downstream DNA section that terminates the transcription process. 
For many prokaryotes, there are two important parts in promoters, named the 
Pribnow box and the TATA box (Goldberg-Hogness box). We use plus 1+1 to denote 
the transcription start site and negative 1−1 to the neighboring site upstream. (There is no 0 in

1.5
RNA
7
Fig. 1.8 Exons and introns 
this scheme, negative 1−1 is followed by 1.) The Pribnow box and the TATA box are highly 
conserved segments, whose centers are located at negative 10−10 and negative 35−35 approximately, 
respectively. (The consensus sequences are TATAAT and TTGACA, respectively.) 
Two boxes are important for RNA polymerases’ binding and the exact distance of 
them inﬂuences the activity of genes. 
For organisms of low complexity like viruses, the percentage of nucleotides 
in coding regions is much higher than the human genome. For instance, in the 
polyomavirus genome, more than 90% of the genome is coding regions [3]. 
The genes of prokaryotes and eukaryotes are quite different. Cells of prokaryotes 
do not have a true nucleus or membranous organelles. Cells of eukaryotes, on 
the other hand, do have a true nucleus to separate DNA from the cytoplasm (the 
content of cells including organelles) and have membranous organelles. For genes of 
prokaryotes, the coding regions of DNA are continuous. For genes of eukaryotes, the 
coding DNA is interrupted by parts that somehow disappeared in the mRNA. As is 
shown in Fig. 1.8, the RNA segments corresponding to upper I 1 comma upper I 2 commaI1, I2, and upper I 3I3 are removed to 
get mRNA that produces protein. (The RNA segment upper E prime Subscript iE′
i corresponds to upper E Subscript iEi for each 
i.) upper I 1 comma upper I 2 commaI1, I2, and upper I 3I3 are called introns. upper E 1 comma upper E 2 comma upper E 3 commaE1, E2, E3, and upper E 4E4, whose heredity information 
ﬁnally pass to protein, are denoted as exons. Exons may be sparse in a gene. For 
example, in a human gene, thyroglobulin, exons of 8500 bps are interrupted by over 
40 introns of 100,000 bps. Determining exons and introns is a signiﬁcant problem 
in Bioinformatics. 
After removals of introns, sometimes it may still be insertions or removals of 
nucleotides directed by guide RNA (gRNA). This process is RNA editing. RNA 
editing has a strong impact on cells since a few changes in the sequence of 
nucleotides might lead to huge changes for corresponding proteins. 
Before polypeptide chains translated by mRNA fold into proteins, there can be 
a protein splicing process similar to the genes of eukaryotes. The removed parts in 
the splicing are called inteins and the remaining parts are called exteins. 
1.5 
RNA 
Nucleotides construct a strand of RNA also via phosphodiester bond and the way 
of connection is the same as that of DNA. In most cases, RNA is single-stranded 
in the cell. There are mainly three types of RNA: messenger RNA, transfer RNA,

8
1
Biological Overview
and ribosomal RNA. The process of translation is contributed to the efforts of three 
kinds of RNA together. 
Messenger RNA (mRNA) is a single-stranded RNA produced in transcription 
that carries heredity information from DNA. It plays an important role in translation. 
The production of protein uses mRNA as templates. In transcription, the RNA 
polymerase reads the sequence between promoters and terminators and converts 
it to RNA. For prokaryotes, the RNA produced is mRNA. For eukaryotes, the RNA 
produced, named primary transcript mRNA or pre-mRNA, contains sections that 
correspond to introns and still need further processing. After a series of splicing, 
pre-mRNA is converted to mRNA. 
Similar to most RNA molecules, tRNA is also single-stranded without the 
complementary strand. However, unlike mRNA, tRNA tends to fold back and form 
hydrogen bonds with itself. To be more speciﬁc, tRNA forms a cloverleaf structure 
by hydrogen bonds and the cloverleaf folds into an L shape in the three-dimensional 
space. The length of tRNA is usually between 70 and 90 bps. As the amino acids’ 
transporter in the translation process, tRNA has two important functions. The ﬁrst is 
the ability to carry the amino acid. Transfer RNA can link the speciﬁc amino acid on 
its acceptor stem located on its 3 prime3′ side. The second is the ability to identify codons. 
By a part called anticodon, tRNA can form three base pairs with the target mRNA. 
Besides acceptor stem and anticodon, there are other structures in tRNA such as 
D-arm and T-arm, but we will not focus on them in this book. 
We have mentioned that ribosomes are important organelles in translation. They 
are the places where tRNA matches the codons of mRNA to produce polypeptide 
chains. Ribosomes are constituted by ribosomal RNA and protein. Ribosomal RNA 
is a kind of enzyme. In translation, amino acids are linked to produce polypeptide 
chains. This process is catalyzed by ribosomal RNA. 
There are also some other RNA in living systems [2]. Small nuclear RNA is found 
in eukaryotic cells’ nuclei and is important in processing RNA. For example, in the 
process where pre-mRNA is spliced to produce mRNA, snRNA plays a signiﬁcant 
role. Guide RNA is also used for mRNA editing. It can do point-wise nucleotide 
insertions or deletions for RNA. 
1.6 
Protein 
Two amino acids can be connected via a peptide bond, where the carboxyl group 
of one amino acid binds the amino group of the next one. (See Fig. 1.9.) It makes 
amino acids form a linear polymer called a polypeptide chain. Two ends of the chain 
can be named by their free group (N terminus and C terminus). 
The sequence of amino acids in the polypeptide chain is the primary structure of 
the protein. Besides the primary structure, polypeptide chains can fold into diverse 
three-dimensional structures (or called conformations) since there are some angles 
in the polypeptide chain that can be changed.

1.6
Protein
9
Fig. 1.9 The structure of the peptide bond connected by two amino acids 
Fig. 1.10 Ramachandran plot 
In polypeptide chains, there are three kinds of angles. Since the peptide bond is 
planar, the angle of the peptide bond, omegaω, has only two possible choices, which are 
180 Superscript ring180◦(trans) and 0 Superscript ring0◦(cis), respectively. Most conformations in polypeptide chains 
are trans. The other two angles, phiφ and psiψ, which are angles of N-CSubscript alphaα bond and C-
CSubscript alphaα bond, respectively, have more freedom. Nevertheless, the two angles are not 
independent. The well-known Ramachandran plot shows that the pair left parenthesis phi comma psi right parenthesis(φ, ψ) locates 
in a restricted area. (See Fig. 1.10. This picture is from [4]. This picture considers 
310 proteins and each dot represents a left parenthesis phi comma psi right parenthesis(φ, ψ) pair of one amino acid in proteins.) 
Given a polypeptide chain, the three-dimensional structure is determined by its 
order of amino acids in natural cases. This structure is believed to have a global 
minimum of free energy. (The free energy includes the potential energy of van 
der Waals attraction, electrostatic forces, hydrogen bonds, and other attractions.)

10
1
Biological Overview
However, sometimes proteins can be folded incorrectly due to some abnormal 
inﬂuences and these wrongly folded proteins may lead to diseases. Some abnormal 
proteins can even bind the normal proteins and transform them into a wrong 
conformation. These infectious proteins are called prions. 
To reduce the impact of wrong folding, there are certain proteins called chap-
erones that can assist in the proper folding of proteins. Chaperones are located in 
the neighborhood of ribosomes. They can recognize wrongly folded proteins by 
hydrophobic residues on the protein’s surface and help refold abnormal proteins. 
The three-dimensional structure of a protein can determine its function. There-
fore, two proteins that have completely different sequences but are similar in 
three-dimensional structure may process similar functions. 
Proteins can be divided into three classes roughly by their shapes: globular 
proteins, ﬁbril proteins, and membrane proteins. Many physiologically active 
proteins such as enzymes and immunoglobulins are globular proteins. Fibril proteins 
including collagen and elastin can form strong structures in organisms. Membrane 
proteins are important for material transport in cell membranes. 
In the three-dimensional structure of proteins, some pieces are frequently used 
such as alphaα helices and betaβ sheets. An alphaα helix is a structure formed by stacking amino 
acids in a polypeptide chain like a spiral and a betaβ sheet is a linear structure formed by 
adjacent protein strands and the hydrogen bonds between them. There are also other 
common pieces such as turns and other helices’ structures (piπ helix, 3 Subscript 10310 helix). These 
pieces form the secondary structure of a protein. The combinations of secondary 
structures form supersecondary structures (also called motifs) such as helix-turn-
helix motifs. 
The tertiary structure, composed of secondary structures and supersecondary 
structures, is the structure that has speciﬁc functions. At this level, proteins are 
available to interact with other proteins or other molecules. If more than one protein 
with a tertiary structure gathers together and forms a protein complex, the quaternary 
structure appears. 
1.7 
The Genetic Code 
The genetic code is the rule that organisms use to produce speciﬁc proteins with 
the instructions of DNA. In transcription, we know that the heredity information 
passes from DNA to RNA by the pairing rule of nucleobases. So the genetic code 
often refers to the code of how protein is encoded by mRNA. It is a question that 
scientists have studied for a long time since Watson and Crick proposed the double 
helix model of DNA in 1953. 
There are many conjectures about how exactly a sequence of nucleotides encodes 
a polypeptide chain. We here introduce an interesting attempt from Crick. Crick 
assumed that the code reads blocks of k letters where 4 Superscript k Baseline greater than or equals 204k ≥20 since there are only 
four types of nucleobases for RNA and there are 20 types of amino acids. Therefore, 
the length of the blocks cannot be less than three letters long and Crick took k equals 3k = 3. 
Crick also believed that each nucleobase should be read in only one block and the

1.7
The Genetic Code
11
reading frame, which is the phase of codon reading, is uniquely determined by the 
blocks. To be more speciﬁc, if n 1 n 2 n 3n1n2n3 is a sequence of nucleotides that encodes 
amino acid upper A 1A1 and n 4 n 5 n 6n4n5n6 is a sequence of nucleotides that encodes amino acid upper A 2A2, 
then n 2 n 3 n 4n2n3n4 and n 3 n 4 n 5n3n4n5 should not encode any amino acid or the meaning of the 
sequence n 1 n 2 n 3 n 4 n 5 n 6n1n2n3n4n5n6 will be ambiguous. Therefore, in Crick’s theory, AAA is 
impossible to be a codon, or in AAAAAA there will be no obvious reading frame 
since there are four places to begin reading AAA. 
The experiments of biologists show that Crick is partially correct. The genetic 
code reads three letters as a block to encode one amino acid and the blocks are 
non-overlapping in one translation process. However, different from Crick’s theory, 
all 4 cubed equals 6443 = 64 possible triplets are codons and there may be different codons that 
correspond to the same kind of amino acid. This coding method may be less elegant 
in the view of mathematics but is practical for lives by reducing the impact of 
mutations. The property that most amino acids correspond to more than one codon is 
called the degeneracy of codons. Since the reading frame is no longer determined by 
the sequences in this method, there should be signals for organisms to know where 
to start and where to stop the translation. There are two special types of codons: the 
initiation codon and the termination codon. For most organisms, the initiation codon 
is AUG and for some prokaryotes, GUG and UUG are also the initiation codons. 
The termination codons are UAG, UAA and UGA. The initiation codons encode 
amino acids while the termination codons do not. Table 1.3 gives the genetic code 
in a compact form. (TC is the termination signal and it does not encode any amino 
acid.) It is worth noticing that the genetic code is not unique. A few organisms have 
different correspondences between codons and amino acids. What we show in the 
table is the most common representation. 
Table 1.3 The genetic code 
2nd 
1st
U
C
A
G
3rd 
U
Phe
Ser
Tyr
Cys
U 
Phe
Ser
Tyr
Cys
C 
Leu
Ser
TC
TC
A 
Leu
Ser
TC
Trp
G 
C
Leu
Pro
His
Arg
U 
Leu
Pro
His
Arg
C 
Leu
Pro
Gln
Arg
A 
Leu
Pro
Gln
Arg
G 
A
Ile
Thr
Asn
Ser
U 
Ile
Thr
Asn
Ser
C 
Ile
Thr
Lys
Arg
A 
Met
Thr
Lys
Arg
G 
G
Val
Ala
Asp
Gly
U 
Val
Ala
Asp
Gly
C 
Val
Ala
Glu
Gly
A 
Val
Ala
Glu
Gly
G

12
1
Biological Overview
In fact, from the table, we can see that many pairs of codons that differ only in 
the third position base code for the same amino acid while pairs of codons differing 
only in the ﬁrst or second position usually code for different amino acids. 
Since each codon has its meaning, there are many possible reading frames for 
one mRNA. For each DNA strand, there are three reading frames and there are six 
reading frames together. In other words, for a given sequence of nucleotides, a shift 
of one letter will lead to a completely different translation result. This phenomenon 
may happen in reality. Certain viruses can encode two distinct proteins within 
roughly the same genomic region by a shift in the reading frame. 
An interesting fact is that, although the genetic code is universal for most species, 
different organisms may have different preferences for the usage of certain codons 
for particular amino acids. Some species even do not have tRNA corresponding to a 
particular codon. 
Finally, we introduce some discussions about the origin of the genetic code. 
(See [5–8].) A natural idea is that different genetic codes existed in the past and 
natural selection has promoted the evolution of the genetic code and the translation 
machinery until they achieved the optimal case. However, F. Crick has proposed a 
completely different conjecture. Crick believed that there may be a so-called frozen 
accident after which any further random mutations are lethal for organisms. This 
theory can explain why the genetic code is almost the same for completely different 
species.

Chapter 2 
Bioinformatics Databases 
2.1 
Introduction to Bioinformatics Databases 
The advent of rapid DNA sequencing technologies has profoundly revolutionized 
our comprehension of life sciences. The abundance of data generated by these 
technologies has fueled the expansion of databases that gather and disseminate 
sequence, structure, and gene expression information. These biological databases 
amalgamate data from various sources, including scientiﬁc experiments, published 
literature, high-throughput experiments, and computational analyses. They encom-
pass a wide array of research areas, such as genomics (the study of genomes), 
proteomics (the study of proteins), and metabolomics (the study of chemical pro-
cesses involving metabolites). Biological databases provide a wealth of information, 
including gene function, structure, localization (both cellular and chromosomal), 
clinical effects of mutations as well as similarities of biological sequences and 
structures. These databases play a pivotal role in aiding scientists to comprehend and 
elucidate diverse biological phenomena, ranging from the structure and interactions 
of biomolecules to the complete metabolism of organisms, and even the evolution 
of species. This knowledge is invaluable in advancing the ﬁght against diseases, 
facilitating medication development, and unraveling fundamental relationships 
among species throughout the history of life. 
Organizing biological sequences into a database serves another critical purpose: 
discovering new biology [1]. Useful sequence patterns are preserved over long 
periods of evolutionary time. When a newly discovered sequence exhibits signiﬁcant 
similarity with an existing sequence in the database, there is a high likelihood 
that their biological functions might also be similar. This comparison process 
gives rise to new and valuable biological hypotheses, allowing researchers to draw 
meaningful insights and make important discoveries based on the relationships 
observed between sequences. By leveraging the power of sequence comparison, 
scientists can unravel the hidden connections and functionalities within biological 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_2
13

14
2
Bioinformatics Databases
systems, opening up avenues for further exploration and understanding of the 
complexities of life. 
2.2 
Nucleotide Sequence Databases 
The primary nucleotide sequence databases include: 
• 
European Molecular Biology Laboratory (EMBL) (http://www.ebi.ac.uk/embl/) 
[9] 
• 
DNA Data Bank of Japan (DDBJ) (http://www.ddbj.nig.ac.jp/) [10] 
• 
GenBank (http://www.ncbi.nlm.nih.gov/) [11] 
They constitute the International Nucleotide Sequence Database Collaboration 
(INSDC, http://www.insdc.org), standing as one of the most celebrated global 
initiatives in public domain data sharing. Each database group compiles a segment 
of the overall sequence data contributed from around the world, with all fresh and 
revised data exchanged daily to ensure harmonization across them [12]. The amount 
of data in the database is growing very fast. Figure 2.1 illustrates the data growth of 
EMBL, DDBJ, and GenBank. 
2.2.1 
EMBL (http://www.ebi.ac.uk/embl/) 
EMBL nucleotide sequence database is maintained by the European Bioinformatics 
Institute (EBI) in Hinxton, Cambridgeshire, UK. It offers an extensive repository of 
global nucleotide sequencing details, encompassing raw sequencing data, sequence 
assembly information, and functional annotations. Up to Aug 21, 2022, the EMBL 
database contains roughly 3.5 billion sequence records. 
2.2.2 
DDBJ (http://www.ddbj.nig.ac.jp/) 
DDBJ Center collects nucleotide sequence data and provides freely available 
nucleotide sequence data and a supercomputer system, to support research activities 
in life science. Up to June 2022, the DDBJ database contains around 3.6 billion 
sequence records.

2.2
Nucleotide Sequence Databases
15
Fig. 2.1 These ﬁgures are from https://www.ebi.ac.uk/ena/browser/about/statistics, https:// 
www.ddbj.nig.ac.jp/statistics/index-e.html, and  https://www.ncbi.nlm.nih.gov/genbank/statistics/, 
respectively 
2.2.3 
GenBank (http://www.ncbi.nlm.nih.gov/genbank/) 
The GenBank is the NIH genetic sequence database maintained by the National 
Center for Biotechnology Information (NCBI, a part of the National Institutes

16
2
Bioinformatics Databases
of Health in the United States) [11]. GenBank stands as a curated compilation 
of all DNA sequences accessible to the public. The indexing of GenBank is 
organized by release number. Up to Aug 2023, the GenBank database encompasses 
approximately 246 million sequence records. Starting from 1982 up to the present, 
the base count within GenBank has doubled roughly every 18 months. Each 
GenBank entry encompasses a succinct description of the sequence, accompanied 
by details encompassing the scientiﬁc nomenclature and taxonomic classiﬁcation of 
the speciﬁc organism from which the data is derived. Furthermore, a comprehensive 
table of features is provided, delineating coding and noncoding regions, alongside 
other biologically signiﬁcant sites such as transcription units, points of mutations or 
modiﬁcations, and repetitive elements. Bibliographic references are included for all 
known sequences with a link to the Medline unique identiﬁer [13]. The following is 
the list of entries for identiﬁers: 
• 
LOCUS: a short unique name for the entry, chosen to suggest the sequence 
deﬁnition 
• 
DEFINITION: a concise description of the sequence 
• 
ACCESSION: the primary accession number is a unique, unchanging code 
assigned to each entry. This code should be used when citing information from 
GenBank 
• 
KEYWORDS: short phrases describing gene products and other information 
about an entry 
• 
SEGMENT: information on the order in which this entry appears in a series of 
discontinuous sequences from the same molecule 
• 
SOURCE: common name of the organism or the name most frequently used in 
the literature 
• 
ORGANISM: formal scientiﬁc name of the organism (ﬁrst line) and taxonomic 
classiﬁcation levels (second and subsequent lines) 
• 
REFERENCE: citations for all articles containing data reported in this entry. 
Includes four sub-keywords and may repeat 
• 
AUTHORS: lists the authors of the citation 
• 
JOURNAL: lists the journal name, volume, year, and page numbers of the 
citation 
• 
COMMENT: cross-references to other sequence entries, comparisons to other 
collections, notes of changes in LOCUS names, and other remarks 
• 
FEARURES: table containing information on portions of the sequence that code 
for proteins and RNA molecules and information on experimentally determined 
sites of biological signiﬁcance 
• 
BASE COUNT: summary of the number of occurrences of each base code in the 
sequence 
• 
ORIGIN: speciﬁcation of how the ﬁrst base of the reported sequence is oper-
ationally located within the genome. Where possible, this includes its location 
within a larger genetic map 
Figure 2.2 gives an example of GeneBank data entry.

2.2
Nucleotide Sequence Databases
17
Fig. 2.2 Example of GeneBank data entry: Bacillus subtilis strain NDH03 DNA gyrase subunit B 
(gyrB) gene

18
2
Bioinformatics Databases
2.3 
Protein Sequence Databases 
UniProt database is the world’s most comprehensive repository of protein sequences 
and functions created by joining the three major protein sequence databases: 
• 
Swiss-Prot (https://www.uniprot.org/uniprotkb?query=reviewed:true) [14] 
• 
Translated EMBL Nucleotide Sequence Data Library (TrEMBL) (https://www. 
uniprot.org/uniprotkb?query=reviewed:false) [9] 
• 
Protein Information Resource (PIR) (http://pir.georgetown.edu) [15] 
It integrates the resources of EBI (European Bioinformatics Institute), SIB 
(the Swiss Institute of Bioinformatics), and PIR (Protein Information Resource) 
databases [16]. 
UniProt comprises three distinct components, each tailored to 
serve speciﬁc functions. The core of UniProt is the UniProt Knowledgebase, which 
serves as a centralized hub for comprehensive protein-related data encompassing 
functions, classiﬁcations, and cross-references. Additionally, UniProt Reference 
Clusters (UniRef) amalgamate closely related sequences into uniﬁed records, opti-
mizing search efﬁciency. The UniProt Archive (UniParc) serves as a comprehensive 
repository that chronicles the evolutionary history of all protein sequences. 
2.3.1 
Swiss-Prot (https://www.uniprot.org/uniprotkb?query= 
reviewed:true) 
UniProtKB/Swiss-Prot is the manually annotated and reviewed section of the 
UniProt Knowledgebase [14]. It is a high-quality annotated and non-redundant 
protein sequence database, which brings together experimental results, computed 
features, and scientiﬁc conclusions. Up to June 2023, the Swiss-Prot database has 
encompassed approximately 570 thousand sequence entries. The growth of the 
database is summarized as Fig. 2.3. This database is generally considered one of 
the best protein sequence databases in terms of the quality of the annotation. 
Fig. 2.3 The growth of the database, UniProtKB/Swiss-Prot (https://web.expasy.org/docs/ 
relnotes/relstat.html)

2.3
Protein Sequence Databases
19
Fig. 2.4 The growth of the database, UniProtKB/TrEMBL (https://www.ebi.ac.uk/uniprot/ 
TrEMBLstats) 
2.3.2 
TrEMBL (https://www.uniprot.org/uniprotkb?query= 
reviewed:false) 
UniProtKB/TrEMBL (Translated EMBL Nucleotide Sequence Data Library) is an 
automatically annotated and not reviewed section that contains all the translations 
of EMBL nucleotide sequence entries not yet integrated into Swiss-Prot. Up to June 
2023, TrEMBL database has included about 248 million protein sequences. The 
growth of the database is summarized in Fig. 2.4. 
Swiss-Prot and TrEMBL are developed by the Swiss-Prot groups at EMBL-EBI 
(European Bioinformatics Institute) and SIB (Swiss Institute of Bioinformatics). 
2.3.3 
PIR (http://pir.georgetown.edu) 
Founded in 1984 by the National Biomedical Research Foundation, the Protein 
Information Resource (PIR) serves as a valuable tool aiding researchers in iden-
tifying and comprehending protein sequence information. It consistently offers 
cutting-edge resources to facilitate the integration of proteomic and genomic data. 
Moreover, PIR assumes a pivotal role in advancing the worldwide dissemination 
and standardization of protein annotation.

20
2
Bioinformatics Databases
2.4 
Sequence Motif Databases 
The primary sequence motif databases include: 
• 
Pfam (http://pfam.xfam.org/) [17] 
• 
PROSITE (http://prosite.expasy.org/) [18] 
In genetics, a sequence motif refers to a prevalent pattern of nucleotides or 
amino acids with presumed biological signiﬁcance. For proteins, a sequence motif 
is distinguished from a structural motif, a motif formed by the three-dimensional 
arrangement of amino acids, whose corresponding sequences may not be adjacent. 
Protein sequence motifs serve as distinctive signatures for protein families and are 
frequently employed as predictive tools for determining protein function. 
2.4.1 
Pfam (http://pfam.xfam.org/) 
Pfam is a database of protein families deﬁned as domains (contiguous segments of 
entire protein sequences) [17]. For each domain, it contains multiple alignments of 
a set of deﬁning sequences (the seeds) and the other sequences in Swiss-Prot and 
TrEMBL that can be matched to that alignment. The database was started in 1996 
and is maintained by a consortium of scientists. The Pfam 35.0, released in Nov 
2021, encompasses a total of 19 thousand families and clans. 
HMMER, a HMM based algorithm developed by Sean Eddy, constitutes the 
computational framework underpinning Pfam. Pfam offers direct access to the 
domain architecture of protein sequences from Swiss-Prot and TrEMBL, and users 
can also explore domain searches for other sequences via web-based servers. The 
Pfam database can be employed for both searching and domain identiﬁcation within 
sequences. 
2.4.2 
PROSITE (http://prosite.expasy.org/) 
PROSITE is a database of protein families and domains [18]. It consists of 
biologically signiﬁcant sites, patterns, protein domains, families, and functional 
sites, as well as associated patterns and proﬁles to identify them. Its foundation lies 
in regular expressions that describe characteristic subsequences unique to speciﬁc 
protein families or domains. It is complemented by ProRule, a collection of rules, 
which increases the discriminatory power of these proﬁles and patterns by providing 
additional information about functionally and structurally critical amino acids. Up 
to June 2023, PROSITE has included a repository of 1311 patterns, 1367 proﬁles, 
and 1382 ProRule.

2.5
Macromolecular 3D Structure Databases
21
2.5 
Macromolecular 3D Structure Databases 
The main protein structure databases include: 
• 
Protein Data Bank (PDB) (http://www.rcsb.org/) [19] 
• 
Structural Classiﬁcation of Proteins (SCOP) (http://scop.mrc-lmb.cam.ac.uk/ 
scop/) [20] 
• 
Class, Architecture, Topology, Homologous superfamily database (CATH) 
(http://www.cathdb.info) [21, 22] 
They offer valuable and profound understandings of molecular function at the 
atomic scale and furnish conclusive evidence supporting various aspects of molec-
ular function and elucidate patterns of sequence conservation present in protein 
families. Furthermore, the alignment of 3D structures can be a valuable tool in 
guiding precise multiple sequence alignments, crucial for conducting phylogenetic 
analyses [24]. (Phylogenetic analyses involve the examination of the evolutionary 
history and relationships among organisms or groups of organisms.) 
2.5.1 
PDB (http://www.rcsb.org/) 
The Protein Data Bank (PDB) serves as a main repository for three-dimensional 
structural data pertaining to signiﬁcant biological macromolecules like proteins and 
nucleic acids [19]. This data is usually acquired through methodologies such as X-
ray crystallography, NMR spectroscopy, or the emerging technique of cryo-electron 
microscopy. Up to Aug 2023, the PDB has contained 208 thousand experimental 
structures. 
The PDB entries contain the atomic coordinates, and some structural parameters 
connected with the atoms (B-factors, occupancies), or computed from the structures 
(secondary structure). The PDB entries contain some annotation, but it is not 
as comprehensive as in Swiss-Prot. Fortunately, there are cross-links between 
the databases in both ﬁle formats. Files in the PDB contain various essential 
information, including the compound’s name, the species and tissue it originates 
from, amino acid sequence, secondary structure locations, and the coordinates of 
the atoms in the protein. (Hydrogen atoms’ coordinates are not included in the PDB 
due to the constraints of x-ray crystallography and NMR structure analysis.) An 
example of a PDB ﬁle is shown in Fig. 2.5 and its visualization is shown in Fig. 2.6. 
The following is the list of entries for identiﬁers: 
• 
HEADER, TITLE, and AUTHOR provide information about the researchers 
who deﬁned the structure. Numerous other types of records are available to 
provide other types of information. 
• 
REMARK contains free-form annotation, but they also accommodate standard-
ized information. For example, the REMARK 350 BIOMT records describe how 
to compute the coordinates of the experimentally observed multimer from those 
of the explicitly speciﬁed ones of a single repeating unit.

22
2
Bioinformatics Databases
Fig. 2.5 The PDB ﬁle of the protein with ID=1MBS 
• 
SEQRES gives the sequences of the three peptide chains (named A, B, and C), 
which are very short in this example but usually span multiple lines. 
• 
ATOM describes the coordinates of the atoms that are part of the protein. For 
example, the ﬁrst ATOM line above describes the alpha-N atom of the ﬁrst 
residue of peptide chain A, which is a proline residue. The ﬁrst three ﬂoating 
point numbers are its x, y, and z coordinates. The next three columns are the 
occupancy, temperature factor, and element name, respectively. 
• 
HETATM describes coordinates of hetero-atoms, that is those atoms that are not 
part of the protein molecule. Through the years the ﬁle format has undergone 
many changes and revisions. Its original format is dictated by the width of 
computer punch cards (80 columns). 
2.5.2 
SCOP (http://scop.mrc-lmb.cam.ac.uk/scop/) 
The Structural Classiﬁcation of Proteins (SCOP) database is a manually curated 
classiﬁcation system for protein structural domains, established to discern structural 
and amino acid sequence similarities among proteins [20]. This classiﬁcation

2.5
Macromolecular 3D Structure Databases
23
Fig. 2.6 The visualization of 
the protein with ID=1MBS 
primarily serves the purpose of unraveling evolutionary relationships between 
proteins. Proteins exhibiting analogous structures yet possessing limited sequence 
or functional likeness are grouped into distinct “superfamilies,” implying a remote 
common ancestry. Conversely, proteins with comparable shapes and some degree of 
sequence and/or functional resemblance are categorized into “families,” suggesting 
a closer shared lineage. SCOP’s central aim is to organize protein 3D structures 
hierarchically within structural classes. 
6 spiral str ip-like  struct ure s vis ual ize the protein  wi th I D = I  M B S.
2.5.3 
CATH (http://www.cathdb.info) 
The CATH (Class, architecture, topology, homologous superfamily) database is a 
hierarchical classiﬁcation of protein domain structures, which clusters proteins at 
four major structural levels [21, 22]. Although the aim is very similar to SCOP,

24
2
Bioinformatics Databases
the approach undertaken diverges, and the underlying philosophy when conducting 
classiﬁcation exhibits notable distinctions. Notably, a more substantial portion of 
the determinations involved in classifying novel 3D protein structures is automated 
by the software. 
CATH has employed a crucial algorithm named CATHEDRAL, which serves to 
ascertain domain boundaries automatically and consequently enhance the frequency 
of CATH updates. The foundational concept of CATHEDRAL is to identify 
recurring folds that are already classiﬁed within the CATH database. 
The CATH database presently encompasses a vast compilation of 151 million 
protein domains, meticulously categorized into 5841 superfamilies. As an illus-
trative example, Fig. 2.7 showcases the CATH classiﬁcation of the protein bovine 
papillomavirus-1 E2 DNA-binding domain. 
Fig. 2.7 CATH classiﬁcation of protein bovine papillomavirus-1 E2 DNA-binding domain 
(http://www.cathdb.info/version/latest/domain/2bopA00). PDB ID = 2BOP, CATH domain ID = 
2bopA00, UniProtId = P03122

2.5
Macromolecular 3D Structure Databases
25
2.5.4 
DALI (http://ekhidna2.biocenter.helsinki.ﬁ/dali/) 
In our previous discussion, we introduced three protein structure databases. Now, 
our focus shifts to the server DALI that help search the similar structures. To be more 
speciﬁc, if you are interested in identifying the structural neighbors of a protein that 
is already present in the Protein Data Bank, you can access this information from the 
Dali server [23]. It is based on an all-against-all 3D structure comparison of protein 
structures in the Protein Data Bank. The structural neighborhoods and alignments 
are automatically maintained and regularly updated using the Dali search engine 
[25].

Chapter 3 
Sequence Alignment 
3.1 
Sequence Similarity 
New biological sequences do not emerge de novo in nature but rather are derived 
from pre-existing sequences. This foundational principle underlies sequence anal-
ysis. When we establish a connection between a newly discovered sequence and 
one for which certain information (such as structure or function) is available, we 
open the possibility of applying the known information, to some extent, to the 
new sequence as well. Sequences that share a common ancestral origin during 
evolution are considered related and are termed homologous. It is important to 
note that, in the context of a belief that all life on Earth originates from a common 
source, all sequences are fundamentally homologous. However, in practical terms, 
two sequences are classiﬁed as homologous if their relatedness can be veriﬁed 
using some speciﬁc methodologies. Therefore, the concept of sequence homology 
is dynamic, and the delineation of known families of homologous sequences may 
evolve with improvements in methodologies [26]. 
The approach for establishing homology can be seen as the method for deﬁning 
sequence similarity. Different approaches to deﬁning similarity lead to varying 
outcomes in terms of homology. Among these, sequence alignment stands out as 
the most widely used method for establishing similarity. 
As sequences undergo evolution, their individual residues can undergo three pri-
mary types of changes: substitutions, insertions, and deletions. Substitutions involve 
replacing one residue with another. Insertions involve adding a new residue to the 
sequence, and deletions involve the removal of an existing residue. Although other 
evolutionary events, such as segment duplications, inversions, and translocations, 
do occur, these events are on a larger scale and are less frequent. Typically, these 
events are not taken into consideration in most sequence alignments. 
When we only consider substitutions, the alignment process becomes relatively 
straightforward. We merely compare two sequences of equal length, checking 
whether corresponding elements are identical. However, the inclusion of insertions 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_3
27

28
3
Sequence Alignment
and deletions necessitates introducing gaps in the alignment, making the alignment 
calculations more intricate. 
For illustration purposes, let us consider the following two nucleotide sequences, 
which consist of only seven residues each: 
StartLayout 1st Row 1st Column x colon 2nd Column upper G 3rd Column upper C 4th Column upper T 5th Column upper T 6th Column upper C 7th Column upper A 8th Column upper G 2nd Row 1st Column y colon 2nd Column upper T 3rd Column upper T 4th Column upper T 5th Column upper A 6th Column upper G 7th Column upper C 8th Column upper C period EndLayoutx : G C T T C A G
y : T T T A G C C.
The sequences have equal lengths, so there exists just one way to align them if no 
gaps are allowed. That is, we only need to count that there are only one identical 
element T . 
However, if gaps are allowed, there are plenty of possible alignments. For 
instance, the following alignment appears to be much more acceptable than the 
preceding one: 
StartLayout 1st Row 1st Column x colon 2nd Column upper G 3rd Column upper C 4th Column upper T 5th Column upper T 6th Column upper C 7th Column upper A 8th Column upper G 9th Column minus 10th Column minus 2nd Row 1st Column y colon 2nd Column upper T 3rd Column minus 4th Column upper T 5th Column upper T 6th Column minus 7th Column upper A 8th Column upper G 9th Column upper C 10th Column upper C period EndLayoutx : G C T T C A G −−
y : T −T T −A G C C.
This alignment suggests that the subsequence T T AG  may be an evolutionarily 
conserved region, which means that both x and y may have evolved from a 
common ancestral sequence containing this subsequence. There are other reasonable 
alignments such as: 
StartLayout 1st Row 1st Column x colon 2nd Column upper G 3rd Column upper C 4th Column upper T 5th Column upper T 6th Column upper C 7th Column upper A 8th Column upper G 9th Column minus 10th Column minus 2nd Row 1st Column y colon 2nd Column minus 3rd Column minus 4th Column upper T 5th Column upper T 6th Column upper T 7th Column upper A 8th Column upper G 9th Column upper C 10th Column upper C period EndLayoutx : G C T T C A G −−
y : −−T T T A G C C.
How does one decide among all possible alignments? Addressing these queries 
necessitates the ability to assign scores to each alignment. The alignments with 
the highest scores are, by deﬁnition, the optimal choices. (Note that there could 
be multiple optimal alignments.) 
In elementary scoring schemes, columns within an alignment are assumed to be 
independent. As a result, the total score is the sum of column scores. Such schemes 
require speciﬁcation of scores s(a, b) = s(b, a) and the gap penalty s(−, a)  = 
s(a, −), with a, b ∈ Q, where Q signiﬁes the DNA or RNA alphabet comprising 
four letters, or the amino acid alphabet with twenty letters. It is noteworthy that 
the optimal alignments for a sequence pair hinge upon the chosen scoring scheme. 
Consequently, two different scoring schemes may yield notably distinct optimal 
alignments. A possible scoring scheme example involves setting s(a, a) = 1 for  
a match, s(a, b) = −1 when a /= b for a mismatch, and s(−, a)  = s(a, −) = −2 
as the gap penalty. 
The values s(a, b) form a matrix. In the case of protein alignments, the 
relationship between two amino acids in substitutions is more intricate. To elaborate, 
certain substitutions can occur more frequently than others. Thus, relying solely on 
an identity matrix, where s(a, a) = 1 and s(a, b) = −1 when a /= b, might yield

3.2
Global Alignment
29
imprecise results. Previous research has introduced effective substitution matrices 
like PAM [27] and BLOSUM [28] to address this. We do not delve into the 
derivation of these matrices since the selection of these matrices does not impact 
the methodology of sequence alignments. 
For the purposes of this chapter we ﬁx a substitution matrix and restrict our 
considerations to DNA sequences, thus assuming that Q = {A, C, G, T }. This setup 
will be sufﬁcient to demonstrate the main sequence alignment principles. 
3.2 
Global Alignment 
In this section we consider a linear gap model (i.e., set s left parenthesis minus comma a right parenthesis equals s left parenthesis a comma minus right parenthesis equals negative ds(−, a) = s(a, −) = −d
for a element of script upper Qa ∈Q, with d greater than 0d > 0, so that the score of a gap region of length L is equal 
to minus d upper L−dL) and describe an algorithm, the Needleman-Wunsch algorithm [29], which 
always ﬁnds every optimal global alignment. (Note there are often more than one 
such alignment.) The idea of the algorithm is called dynamic programming, which 
denotes the act of simplifying a complex problem by decomposing it into more 
manageable sub-problems through a recursive approach. 
Suppose we have two sequences x equals x 1 x 2 ellipsis x Subscript i Baseline ellipsis x Subscript n Baselinex = x1x2 . . . xi . . . xn and y equals y 1 y 2 ellipsis y Subscript j Baseline ellipsis y Subscript m Baseliney = y1y2 . . . yj . . . ym. 
Let us construct an left parenthesis n plus 1 right parenthesis times left parenthesis m plus 1 right parenthesis(n + 1) × (m + 1)-matrix, which we call F. Its  left parenthesis i comma j right parenthesis(i, j)th 
element upper F left parenthesis i comma j right parenthesisF(i, j) for i equals 1 comma ellipsis comma ni = 1, . . . , n, j equals 1 comma ellipsis comma mj = 1, . . . , m is the score of any optimal 
alignment between the subsequences x 1 ellipsis x Subscript i Baselinex1 . . . xi and y 1 ellipsis y Subscript j Baseliney1 . . . yj. The element upper F left parenthesis i comma 0 right parenthesisF(i, 0)
for i equals 1 comma ellipsis comma ni = 1, . . . , n is the score of aligning the subsequence x 1 ellipsis x Subscript i Baselinex1 . . . xi to a gap region of 
length i. Similarly, the element upper F left parenthesis 0 comma j right parenthesisF(0, j) for j equals 1 comma ellipsis comma mj = 1, . . . , m is the score of aligning the 
subsequence y 1 ellipsis y Subscript j Baseliney1 . . . yj to a gap region of length j. We build F recursively starting 
with the initial condition upper F left parenthesis 0 comma 0 right parenthesis equals 0F(0, 0) = 0 and proceeding to ﬁll the matrix from the top 
left corner to the bottom right one. Here upper F left parenthesis i comma j right parenthesisF(i, j) is calculated as follows: 
upper F left parenthesis i comma j right parenthesis equals max StartLayout Enlarged left brace 1st Row upper F left parenthesis i minus 1 comma j minus 1 right parenthesis plus s left parenthesis x Subscript i Baseline comma y Subscript j Baseline right parenthesis comma 2nd Row upper F left parenthesis i minus 1 comma j right parenthesis minus d comma 3rd Row upper F left parenthesis i comma j minus 1 right parenthesis minus d period EndLayoutF(i, j) = max
⎧
⎨
⎩
F(i −1, j −1) + s(xi, yj),
F(i −1, j) −d,
F(i, j −1) −d.
Indeed, there are three possibilities for obtaining the optimal score upper F left parenthesis i comma j right parenthesisF(i, j): x Subscript ixi is 
aligned to y Subscript jyj (the ﬁrst option in the formula above), or x Subscript ixi is aligned to a gap (the 
second option), or y Subscript jyj is aligned to a gap (the third option). When calculating upper F left parenthesis i comma j right parenthesisF(i, j)
we keep the pointer to each of the options from which upper F left parenthesis i comma j right parenthesisF(i, j) was derived. When 
we reach upper F left parenthesis n comma m right parenthesisF(n, m), we trace back the pointers to obtain the optimal alignments. The 
value upper F left parenthesis n comma m right parenthesisF(n, m) is then exactly their score. Notice that more than one pointer may 
come out of a cell of the matrix, which leads to several optimal alignments. 
Example 3.1 Let x equals upper T upper G upper G upper C upper A upper Cx = T GGCAC, y equals upper A upper G upper C upper Cy = AGCC, and suppose that we are using the 
scoring scheme s left parenthesis a comma a right parenthesis equals 1s(a, a) = 1, s left parenthesis a comma b right parenthesis equals negative 1s(a, b) = −1, if a not equals ba /= b, and s left parenthesis minus comma a right parenthesis equals s left parenthesis a comma minus right parenthesis equals negative 2s(−, a) = s(a, −) = −2. 
The corresponding matrix F is shown in Fig. 3.1.

30
3
Sequence Alignment
 0
 _
 1
 
 2
 
 3
 
 4
 
0     
 0
 -2
 -4
 -6
 -8 
1    
 -2
 -1
 -3
 -5
 -7 
2    
 -4
 -3
 0
 -2
 -4 
3    
 -6
 -5
 -2
 -1
 -3 
4    
 -8
 -7
 -4
 -1
 0 
5    
 -10
 -7
 -6
 -3
 -2 
6    
 -12
 -9
 -8
 -5
 -2 
Fig. 3.1 The corresponding matrix F and paths through the matrix of Example 3.1 
Tracing back the pointers yields the following three optimal alignments 
StartLayout 1st Row 1st Column x colon 2nd Column upper T 3rd Column upper G 4th Column upper G 5th Column upper C 6th Column upper A 7th Column upper C 2nd Row 1st Column y colon 2nd Column upper A 3rd Column minus 4th Column upper G 5th Column upper C 6th Column minus 7th Column upper C comma EndLayoutx : T G G C A C
y : A −G C −C,
StartLayout 1st Row 1st Column x colon 2nd Column upper T 3rd Column upper G 4th Column upper G 5th Column upper C 6th Column upper A 7th Column upper C 2nd Row 1st Column y colon 2nd Column upper A 3rd Column upper G 4th Column minus 5th Column upper C 6th Column minus 7th Column upper C comma EndLayoutx : T G G C A C
y : A G −C −C,
StartLayout 1st Row 1st Column x colon 2nd Column upper T 3rd Column upper G 4th Column upper G 5th Column upper C 6th Column upper A 7th Column upper C 2nd Row 1st Column y colon 2nd Column minus 3rd Column upper A 4th Column upper G 5th Column upper C 6th Column minus 7th Column upper C EndLayoutx : T G G C A C
y : −A G C −C
whose score is negative 2−2. The corresponding paths through the matrix F are shown by 
thicker arrows. 
3.3 
Local Alignment 
A more biologically relevant alignment problem is the one of ﬁnding all pairs of 
subsequences of two given sequences having the highest-scoring alignments. We 
will only look at segments, i.e., subsequences of consecutive elements. Any segment 
of a sequence x 1 x 2 ellipsis x Subscript n Baselinex1x2 . . . xn is of the form x Subscript i Baseline x Subscript i plus 1 Baseline ellipsis x Subscript i plus k Baselinexixi+1 . . . xi+k where i plus k less than or equals ni + k ≤n. This  
alignment problem is usually called the local alignment problem. Here we present 
the Smith-Waterman algorithm [30], which completely solves the question for a 
linear gap model.

3.4
Alignment with Afﬁne Gap Model
31
As in the previous section, we construct an left parenthesis n plus 1 right parenthesis times left parenthesis m plus 1 right parenthesis(n + 1) × (m + 1)-matrix, but the 
formula for its entries is slightly different: 
upper F left parenthesis i comma j right parenthesis equals max StartLayout Enlarged left brace 1st Row 0 comma 2nd Row upper F left parenthesis i minus 1 comma j minus 1 right parenthesis plus s left parenthesis x Subscript i Baseline comma y Subscript j Baseline right parenthesis comma 3rd Row upper F left parenthesis i minus 1 comma j right parenthesis minus d comma 4th Row upper F left parenthesis i comma j minus 1 right parenthesis minus d period EndLayoutF(i, j) = max
⎧
⎪⎪⎨
⎪⎪⎩
0,
F(i −1, j −1) + s(xi, yj),
F(i −1, j) −d,
F(i, j −1) −d.
(3.1) 
Opting for the initial choice in the formula mentioned above entails commencing 
a new alignment. If the optimal alignment achieved until a certain juncture yields 
a negative score, it becomes more advantageous to initiate a new alignment rather 
than extending the existing one. 
Another distinction from the Needleman-Wunsch algorithm is that in this 
context, an alignment can terminate at any position within the matrix. Therefore, 
instead of considering the value upper F left parenthesis n comma m right parenthesisF(n, m) located in the bottom right corner of the 
matrix for the optimal score, we identify the maximum elements within matrix 
F and initiate the traceback process from these points. The traceback procedure 
concludes upon reaching a cell with a value of 0, signifying the starting point of the 
alignment. 
Example 3.2 For the sequences from Example 3.1 the only best local alignment is 
StartLayout 1st Row 1st Column x colon 2nd Column upper G 3rd Column upper C 2nd Row 1st Column y colon 2nd Column upper G 3rd Column upper C comma EndLayoutx : G C
y : G C,
and its score is 2. The corresponding dynamic programming matrix F is shown in 
Fig. 3.2, where the thicker arrows represent the traceback. Notice that if an element 
of F is 0 and no arrows come out of the cell containing the element, then it is 
obtained as the ﬁrst option in Formula (3.1). 
3.4 
Alignment with Afﬁne Gap Model 
In this section we consider an afﬁne gap model, that is, we let the score of any gap 
region of length L be equal to negative d minus e left parenthesis upper L minus 1 right parenthesis−d −e(L −1) for some d greater than 0d > 0 and e greater than 0e > 0. In this  
situation negative d−d is called the gap opening penalty and negative e−e the gap extension penalty. It is 
common to set e to be smaller than d, which reﬂects the biological fact that starting 
a new gap region is harder than extending an existing one. In this section, we only 
discuss a global alignment algorithm; its local version can be readily obtained as in 
the preceding section. 
The algorithm utilizes three matrices: one left parenthesis n plus 1 right parenthesis times left parenthesis m plus 1 right parenthesis(n + 1) × (m + 1)-matrix and two 
n times mn × m-matrices. For i equals 1 comma ellipsis comma ni = 1, . . . , n and j equals 1 comma ellipsis comma mj = 1, . . . , m, let  upper M left parenthesis i comma j right parenthesisM(i, j) be the score of 
any optimal alignment between x 1 ellipsis x Subscript i Baselinex1 . . . xi and y 1 ellipsis y Subscript j Baseliney1 . . . yj under the assumption that the

32
3
Sequence Alignment
F
 0
 _
 1
 A
 2
 G
 3
 C
 4
 C 
0     
 0
 0
 0
 0
 0
 
1   T
 0
 0
 0
 0
 0
 
2   G
 0
 0
 1
 0
 0
 
3   G
 0
 0
 1
 0
 0
 
4   C
 0
 0
 0
 2
 1
 
5   A
 0
 1
 0
 0
 1
 
6   C
 0
 0
 0
 1
 1
 
_ 
Fig. 3.2 The dynamic programming matrix F with the traceback arrows 
alignment ends with x Subscript ixi aligned to y Subscript jyj. Next, the element upper M left parenthesis i comma 0 right parenthesisM(i, 0) for i equals 1 comma ellipsis comma ni = 1, . . . , n is 
the score of aligning x 1 ellipsis x Subscript i Baselinex1 . . . xi to a gap region of length i and the element upper M left parenthesis 0 comma j right parenthesisM(0, j)
for j equals 1 comma ellipsis comma mj = 1, . . . , m is the score of aligning y 1 ellipsis y Subscript j Baseliney1 . . . yj to a gap region of length j. 
Further, for i equals 1 comma ellipsis comma ni = 1, . . . , n and j equals 1 comma ellipsis comma mj = 1, . . . , m deﬁne upper I Subscript x Baseline left parenthesis i comma j right parenthesisIx(i, j) to be the score of any 
optimal alignment between x 1 ellipsis x Subscript i Baselinex1 . . . xi and y 1 ellipsis y Subscript j Baseliney1 . . . yj provided the alignment ends with 
x Subscript ixi aligned to a gap. Finally, for i equals 1 comma ellipsis comma ni = 1, . . . , n and j equals 1 comma ellipsis comma mj = 1, . . . , m set upper I Subscript y Baseline left parenthesis i comma j right parenthesisIy(i, j) to 
be the score of any optimal alignment between x 1 ellipsis x Subscript i Baselinex1 . . . xi and y 1 ellipsis y Subscript j Baseliney1 . . . yj provided the 
alignment ends with y Subscript jyj aligned to a gap. It follows that if we assume that a deletion 
is never followed directly by an insertion. In other words, there are no instances 
where “a minusa−” aligns with “negative b−b”. Otherwise, we can substitute it with the match where 
a aligns with b, resulting in an increased score. 
We can calculate the values in three matrices by the following formulas 
recursively: 
StartLayout 1st Row 1st Column upper M left parenthesis i comma j right parenthesis 2nd Column equals 3rd Column max StartLayout Enlarged left brace 1st Row upper M left parenthesis i minus 1 comma j minus 1 right parenthesis plus s left parenthesis x Subscript i Baseline comma y Subscript j Baseline right parenthesis comma 2nd Row upper I Subscript x Baseline left parenthesis i minus 1 comma j minus 1 right parenthesis plus s left parenthesis x Subscript i Baseline comma y Subscript j Baseline right parenthesis comma 3rd Row upper I Subscript y Baseline left parenthesis i minus 1 comma j minus 1 right parenthesis plus s left parenthesis x Subscript i Baseline comma y Subscript j Baseline right parenthesis comma EndLayout 2nd Row 1st Column Blank 2nd Column Blank 3rd Column Blank 3rd Row 1st Column upper I Subscript x Baseline left parenthesis i comma j right parenthesis 2nd Column equals 3rd Column max StartLayout Enlarged left brace 1st Row upper M left parenthesis i minus 1 comma j right parenthesis minus d comma 2nd Row upper I Subscript x Baseline left parenthesis i minus 1 comma j right parenthesis minus e comma EndLayout 4th Row 1st Column Blank 2nd Column Blank 3rd Column Blank 5th Row 1st Column upper I Subscript y Baseline left parenthesis i comma j right parenthesis 2nd Column equals 3rd Column max StartLayout Enlarged left brace 1st Row upper M left parenthesis i comma j minus 1 right parenthesis minus d comma 2nd Row upper I Subscript y Baseline left parenthesis i comma j minus 1 right parenthesis minus e period EndLayout EndLayout
M(i, j) = max
⎧
⎨
⎩
M(i −1, j −1) + s(xi, yj),
Ix(i −1, j −1) + s(xi, yj),
Iy(i −1, j −1) + s(xi, yj),
Ix(i, j) = max
M(i −1, j) −d,
Ix(i −1, j) −e,
Iy(i, j) = max
M(i, j −1) −d,
Iy(i, j −1) −e.

3.4
Alignment with Afﬁne Gap Model
33
Ix 
1 
A 
2 
C 
3 
A 
4 
A 
5 
G 
1      C
-6
  M(0,1)
-8 
M(0,2)
-10 
M(0,3)
-12 
M(0,4)
-14 
M(0,5) 
2      T
-4 
M(1,1)
-5 
M(1,2)
-9 
M(1,3)
-11 
M(1,4)
-13 
M(1,5) 
3      A
-6
-5 
M(2,2)
-6 
M(2,3)
-9 
M(2,4)
-11 
M(2,5) 
4      A
-7 
M(3,1)
-7
-4 
M(3,3)
-5 
M(3,4)
-10 
M(3,5) 
5      G
-9 
M(4,1)
-8 
M(4,2)
-6
-3 
M(4,4)
-6 
M(4,5) 
6      C
-11
-10 
M(5,2)
-8
-5
-2 
M(5,5) 
7      T
-13
-11 
M(6,2)
-10
-7
-4 
Iy 
1 
A 
2 
C 
3 
A 
4 
A 
5 
G 
1      C
-6
  M(1,0)
-4 
M(1,1)
-5 
M(1,2)
-7
-9 
2      T
-8 
M(2,0)
-7 
M(2,1)
-5 
M(2,2)
-6 
M(2,3)
-8 
3      A
-10 
M(3,0)
-7 
M(3,1)
-8 
M(3,2)
-4 
M(3,3)
-5 
M(3,4) 
4      A
-12 
M(4,0)
-9 
M(4,1)
-8 
M(4,2)
-7 
M(4,3)
-3 
M(4,4) 
5      G
-14 
M(5,0)
-13 
M(5,1)
-10 
M(5,2)
-9 
M(5,3)
-8 
M(5,4) 
6      C
-16 
M(6,0)
-15 
M(6,1)
-11 
M(6,2)
-11 
M(6,3)
-10 
M(6,4) 
7      T
-18 
M(7,0)
-17 
M(7,1)
-15 
M(7,2)
-12 
M(7,3)
-12 
M(7,4) 
M 
0 
_ 
1 
A 
2 
C 
3 
A 
4 
A 
5 
G 
0      
0
-3
-5
-7
-9
-11 
1      C
-3
-1
-2
-6
-8
-10 
2      T
-5
-4
-2
-3
-6 
Iy(1,3)
-8 
Iy(1,4) 
3      A
-7
-4
-5 
Ix(2,1)
-1
-2
-7 
Iy(2,4) 
4      A
-9
-6
-5
-4 
Ix(3,2) 
0
-3
 
5      G
-11
-10
-7
-6
-5 
Ix(4,3) 
1 
6      C
-13
-12
-8 
Ix(5,1)
-8
-7 
Ix(5,3)
-4 
Ix(5,4) 
7      T
-15
-14
-12 
Ix(6,1)
-9
-9 
Ix(6,3)
-6 
Ix(6,4) 
Fig. 3.3 The dynamic programming matrices of Example 3.3 
These recurrence relations allow us to ﬁll in the matrices M, upper I Subscript xIx, and upper I Subscript yIy once we have 
initialized the process as upper M left parenthesis 0 comma 0 right parenthesis equals 0M(0, 0) = 0. Here if, for some i and j, one of the options 
in the right-hand sides of the recurrence relations is not deﬁned (for example, in 
the formula for upper M left parenthesis 1 comma 2 right parenthesisM(1, 2) the right-hand side contains upper I Subscript x Baseline left parenthesis 0 comma 1 right parenthesisIx(0, 1) and upper I Subscript y Baseline left parenthesis 0 comma 1 right parenthesisIy(0, 1)), then 
this option is disregarded in the calculations. The score of an optimal alignment is 
then equal to max left brace upper M left parenthesis n comma m right parenthesis comma upper I Subscript x Baseline left parenthesis n comma m right parenthesis comma upper I Subscript y Baseline left parenthesis n comma m right parenthesis right bracemax{M(n, m), Ix(n, m), Iy(n, m)}, and the traceback starts from the 
element (or elements) where the maximum is attained. 
Example 3.3 Let x equals upper C upper T upper A upper A upper G upper C upper Tx = CT AAGCT , y equals upper A upper C upper A upper A upper Gy = ACAAG, the score of any match be 
equal to 1, that of any mismatch to minus−1, d equals 3d = 3 and e equals 2e = 2. Then we obtain the 
dynamic programming matrices displayed in Fig. 3.3. 
The arrows and labels show from which elements of the three matrices each 
number is derived (we also draw the vertical and horizontal arrows in the 0th column 
and zeroth row of the matrix M). The thicker arrows indicate the traceback; it starts 
at upper I Subscript x Baseline left parenthesis 7 comma 5 right parenthesis equals negative 4Ix(7, 5) = −4. There is only one optimal alignment with score negative 4−4: 
StartLayout 1st Row 1st Column x colon 2nd Column upper C 3rd Column upper T 4th Column upper A 5th Column upper A 6th Column upper G 7th Column upper C 8th Column upper T 2nd Row 1st Column y colon 2nd Column upper A 3rd Column upper C 4th Column upper A 5th Column upper A 6th Column upper G 7th Column minus 8th Column minus period EndLayoutx : C T A A G C T
y : A C A A G −−.

34
3
Sequence Alignment
3.5 
Heuristic Alignment Algorithms 
Previous alignment methods based on dynamic programming are both practical and 
accurate but come with a drawback of being time-consuming. The time complexity 
of these algorithms is upper O left parenthesis n m right parenthesisO(nm) when comparing two sequences of lengths n and m, 
respectively. (The notation O stands for order. upper O left parenthesis n m right parenthesisO(nm) signiﬁes that approximately 
Cnm calculations are required, where C is a constant.) This becomes impractical 
when dealing with lengthy sequences in computer searches. A similar concern arises 
for memory complexity. Additionally, when conducting a homology search between 
a query sequence and an extensive sequence database, these time and memory 
complexities can pose signiﬁcant challenges. 
To mitigate these challenges, several heuristic algorithms have been developed. 
These alternatives offer swifter performance but may not necessarily yield the best 
feasible alignments. In this section, we will delve into some of these heuristic 
algorithms to address the aforementioned computational constraints. 
3.5.1 
FASTA 
Calculation of dynamic programming matrices takes a substantial amount of time 
and memory. At the same time, the segments we are interested in are often small 
in comparison to the entire sequences. The FASTA algorithm is designed to limit 
the dynamic programming search to particular parts of the matrices [31]. First, 
FASTA determines the candidate parts, that is, the parts that are likely to lead to 
optimal alignments. Then, the dynamic programming algorithm is utilized with 
the additional condition that all matrix elements lying outside these candidate 
parts are set to negative normal infinity−∞. By imposing this condition, the traceback procedure remains 
conﬁned within the candidate parts. Given that these candidate parts are generally 
much smaller than the complete matrices, this reduction leads to a substantial 
enhancement in computational efﬁciency. 
The identiﬁcation of candidate parts can be achieved through methods such as 
analyzing the so-called dot matrix. In this matrix, each match between the two 
sequences is denoted by a dot. Within this matrix, it becomes feasible to pinpoint 
local similarities by detecting consecutive dots that align diagonally. As illustrated 
in Fig. 3.4, an instance of a dot matrix is presented, wherein shaded areas represent 
diagonal runs comprising three or more dots consecutively aligned. 
Fix positive integers k and b. Once diagonal stretches of length at least k have 
been detected, we extend them to complete diagonals, and the candidate parts of the 
dynamic programming matrix F are then constructed as bands of width b around 
the extensions. Figure 3.5 shows the candidate parts for the sequences from Fig. 3.4, 
where k equals 3k = 3 and b equals 1b = 1. (The row and column indexed at 0 are excluded.) The 
provided illustration follows a linear gap model, while this approach is equally 
applicable to the afﬁne gap model.

3.5
Heuristic Alignment Algorithms
35
Dot 
Matrix 
A 
G 
T 
C 
A 
C
T 
A 
T 
G 
T 
C 
T
*
*
*
 * 
C
*
*
* 
A
* 
*
*
 
C
*
*
* 
A
* 
*
*
 
G
*
* 
G
*
* 
C
* 
*
*
T
*
*
*
* 
A
*
*
* 
G
*
* 
T
*
*
*
* 
C
*
*
* 
Fig. 3.4 An example of a dot matrix 
F 
A 
G 
T 
C 
A 
C 
T
A 
T 
G 
T 
C 
T
-
-
-
-
-
-
-
-
C
-
-
-
-
-
-
-
A
-
-
-
-
-
-
C
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
A
-
G
-
-
G
-
-
C
-
-
-
-
T
-
-
-
-
A
-
-
-
-
G
-
-
-
-
T
-
-
-
-
-
C
-
-
-
-
-
-
Fig. 3.5 The candidate parts for the sequences from Fig. 3.4 
It is worth noticing that FASTA searches can miss optimal alignments, with 
the values of k and b chosen in accordance with the trade-off between time 
and optimality. A smaller value of k and a larger value of b result in improved 
performance but require more time, and vice versa.

36
3
Sequence Alignment
3.5.2 
BLAST 
Unlike FASTA, the BLAST (Basic Local Alignment Search Tool) algorithm [32] 
does not refer to dynamic programming. It looks for short stretches of identities 
(just as FASTA does) and then tries to extend them in both directions searching for 
a good longer alignment. This strategy is reasonable from the biological point of 
view as related sequences tend to share conserved regions. Despite the fact that the 
search algorithm implemented in BLAST is entirely heuristic, its performance is 
satisfactory for many cases and is one of the most popular alignment method. 
3.6 
Multiple Alignment 
In sequence analysis it is often required to determine common parts in sequences 
from a large dataset. To ﬁnd such a part, one needs to come up with an optimal 
multiple alignment for the entire dataset. Analogously to the case of a pair of 
sequences, in order to ﬁnd an optimal multiple alignment, we need to have a scoring 
scheme. As in the case of two sequences, the existing alignment methods generally 
assume that the columns of an alignment not containing gaps are independent and 
use a scoring function of the form 
script upper S left parenthesis upper M right parenthesis equals upper G left parenthesis upper M right parenthesis plus sigma summation Underscript i Endscripts s left parenthesis upper M Subscript i Baseline right parenthesis commaS (M) = G(M) +

i
s(Mi),
with M being a multiple alignment, upper M Subscript iMi the ith column without gaps, s left parenthesis upper M Subscript i Baseline right parenthesiss(Mi) the 
score of upper M Subscript iMi, and G a function for scoring the columns containing gaps. 
In the commonly used methods for scoring multiple alignments, the columns not 
containing gaps are scored by the sum of pairs (SP) function. The SP-score for 
column upper M Subscript iMi not having gaps is deﬁned as 
s left parenthesis upper M Subscript i Baseline right parenthesis equals sigma summation Underscript k less than l Endscripts s left parenthesis upper M Subscript i Superscript k Baseline comma upper M Subscript i Superscript l Baseline right parenthesis commas(Mi) =

k<l
s(Mk
i , Ml
i),
where the sum is taken over all pairs left parenthesis upper M Subscript i Superscript k Baseline comma upper M Subscript i Superscript l Baseline right parenthesis(Mk
i , Ml
i), k less than lk < l, of elements of upper M Subscript iMi, and 
the scores s left parenthesis a comma b right parenthesiss(a, b), for  a comma b element of script upper Qa, b ∈Q, are derived from a substitution matrix used 
for scoring pairwise sequence alignments. Gaps are frequently scored by letting 
s left parenthesis minus comma a right parenthesis equals s left parenthesis a comma minus right parenthesiss(−, a) = s(a, −), setting s left parenthesis minus comma minus right parenthesis colon equals 0s(−, −) := 0 and deﬁning the corresponding SP-score 
for the columns containing gaps. We call any such method for scoring gap regions 
a linear gap model for multiple alignments. Although summing up all the pairwise 
substitution scores may seem to be natural, in fact there is no statistical basis for an 
SP-score. 
Upon ﬁxing a scheme for scoring multiple alignments, one can generalize 
pairwise dynamic programming algorithms to aligning n sequences for any n greater than or equals 3n ≥3.

3.6
Multiple Alignment
37
In situations involving multiple alignments one is usually interested in global 
alignments, and below we give a variant of the Needleman-Wunsch algorithm. Here 
we assume a scoring scheme with 
script upper S left parenthesis upper M right parenthesis equals sigma summation Underscript i Endscripts s left parenthesis upper M Subscript i Baseline right parenthesis commaS (M) =

i
s(Mi),
(3.2) 
where the sum taken over all columns (including the ones containing gaps). Note 
that there is also a multi-dimensional dynamic programming algorithm with the 
afﬁne gap model. 
Suppose one has n sequences x Superscript 1 Baseline equals x 1 Superscript 1 Baseline ellipsis x Subscript m 1 Superscript 1x1 = x1
1 . . . x1
m1, x squared equals x 1 squared ellipsis x Subscript m 2 Superscript 2x2 = x2
1 . . . x2
m2, ellipsis. . . , x Superscript n Baseline equals x 1 Superscript n Baseline ellipsis x Subscript m Sub Subscript n Subscript Superscript nxn =
xn
1 . . . xn
mn. Let  i 1 comma ellipsis comma i Subscript n Baselinei1, . . . , in be nonnegative integers with i Subscript j Baseline less than or equals m Subscript jij ≤mj, j equals 1 comma ellipsis comma nj = 1, . . . , n, 
where at least one number is non-zero. Deﬁne upper F left parenthesis i 1 comma ellipsis comma i Subscript n Baseline right parenthesisF(i1, . . . , in) to be the maximal score 
of an alignment of the subsequences ending with x Subscript i 1 Superscript 1 Baseline ellipsis x Subscript i Sub Subscript n Subscript Superscript nx1
i1 . . . xn
in (if for some j one has 
i Subscript j Baseline equals 0ij = 0, then the other subsequences are aligned to a gap region). The recursion step 
of the dynamic programming algorithm is then written as 
upper F left parenthesis i 1 comma ellipsis comma i Subscript n Baseline right parenthesis equals max StartLayout Enlarged left brace 1st Row upper F left parenthesis i 1 minus 1 comma ellipsis comma i Subscript n Baseline minus 1 right parenthesis plus s left parenthesis x Subscript i 1 Superscript 1 Baseline comma ellipsis comma x Subscript i Sub Subscript n Subscript Superscript n Baseline right parenthesis comma 2nd Row upper F left parenthesis i 1 comma i 2 minus 1 ellipsis comma i Subscript n Baseline minus 1 right parenthesis plus s left parenthesis minus comma x Subscript i 2 Superscript 2 Baseline comma ellipsis comma x Subscript i Sub Subscript n Subscript Superscript n Baseline right parenthesis comma 3rd Row upper F left parenthesis i 1 minus 1 comma i 2 comma i 3 minus 1 ellipsis comma i Subscript n Baseline minus 1 right parenthesis plus s left parenthesis x Subscript i 1 Superscript 1 Baseline comma minus comma x Subscript i 3 Superscript 3 Baseline comma ellipsis comma x Subscript i Sub Subscript n Subscript Superscript n Baseline right parenthesis comma 4th Row vertical ellipsis 5th Row upper F left parenthesis i 1 minus 1 comma ellipsis comma i Subscript n minus 1 Baseline minus 1 comma i Subscript n Baseline right parenthesis plus s left parenthesis x Subscript i 1 Superscript 1 Baseline comma ellipsis comma x Subscript i Sub Subscript n minus 1 Subscript Superscript n minus 1 Baseline comma minus right parenthesis comma 6th Row upper F left parenthesis i 1 comma i 2 comma i 3 minus 1 ellipsis comma i Subscript n Baseline minus 1 right parenthesis plus s left parenthesis minus comma minus comma x Subscript i 3 Superscript 3 Baseline comma ellipsis comma x Subscript i Sub Subscript n Subscript Superscript n Baseline right parenthesis comma 7th Row vertical ellipsis EndLayoutF(i1, . . . , in) = max
⎧
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩
F(i1 −1, . . . , in −1) + s(x1
i1, . . . , xn
in),
F(i1, i2 −1 . . . , in −1) + s(−, x2
i2, . . . , xn
in),
F(i1 −1, i2, i3 −1 . . . , in −1) + s(x1
i1, −, x3
i3, . . . , xn
in),
...
F(i1 −1, . . . , in−1 −1, in) + s(x1
i1, . . . , xn−1
in−1 , −),
F(i1, i2, i3 −1 . . . , in −1) + s(−, −, x3
i3, . . . , xn
in),
...
where all possible combinations of gaps occur except for the one where all the 
residues are replaced with gaps. The algorithm is initialized by the condition 
upper F left parenthesis 0 comma ellipsis comma 0 right parenthesis equals 0F(0, . . . , 0) = 0. The traceback begins at the element upper F left parenthesis m 1 comma ellipsis comma m Subscript n Baseline right parenthesisF(m1, . . . , mn) and is similar 
to that for pairwise alignments. The matrix left parenthesis upper F left parenthesis i 1 comma ellipsis comma i Subscript n Baseline right parenthesis right parenthesis

F(i1, . . . , in)
	
with 0 less than or equals i Subscript j Baseline less than or equals m Subscript j0 ≤ij ≤mj, 
j equals 1 comma ellipsis comma nj = 1, . . . , n, is an  left parenthesis m 1 plus 1 right parenthesis times midline horizontal ellipsis times left parenthesis m Subscript n Baseline plus 1 right parenthesis(m1 + 1) × · · · × (mn + 1)-matrix, and it is convenient to 
visualize it by looking at its two-dimensional sections. 
Example 3.4 We will ﬁnd all optimal alignments of the sequences x equals upper C upper C upper G upper Tx = CCGT , 
y equals upper A upper G upper Ty = AGT , z equals upper C upper C upper Az = CCA using the scoring scheme as follows: one calculates the score 
of an alignment from the scores of its columns upper M Subscript iMi’s by applying formula (3.2); 
if upper M Subscript iMi has three identical symbols, set s left parenthesis upper M Subscript i Baseline right parenthesis equals 2s(Mi) = 2; if it has exactly two identical 
symbols, but no gaps, set s left parenthesis upper M Subscript i Baseline right parenthesis equals 1s(Mi) = 1; if it has three distinct symbols, but no gaps, 
set s left parenthesis upper M Subscript i Baseline right parenthesis equals negative 1s(Mi) = −1; if it has exactly one gap, set s left parenthesis upper M Subscript i Baseline right parenthesis equals negative 2s(Mi) = −2; if it has two gaps, set 
s left parenthesis upper M Subscript i Baseline right parenthesis equals negative 4s(Mi) = −4. Here the indices i 1i1, i 2i2, and i 3i3 correspond to sequences x, y, and z, 
respectively.

38
3
Sequence Alignment
F(*,*,0) 
0 
_ 
0       
0
-4
-8
-12 
1       C
-4
-2
-6
-10 
2      C
-8
-6
-4
-8 
3      G
-12
-10
-8
-6 
4     T
-16
-14
-12
-10 
F(*,*,1) 
0 
_ 
0       
-4 
F(0,0,0)
-2 
F(0,0,0)
-6 
F(0,1,0)
-10 
F(0,2,0) 
1       C
-2 
F(0,0,0) 
1 
F(0,0,0)
-3 
F(0,1,0)
-7 
F(0,2,0) 
2      G
-6 
F(1,0,0)
-3 
F(1,0,0)
-1 
F(1,1,0)
-5 
F(1,2,0) 
3      G
-10 
F(2,0,0)
-7
-5 
F(2,1,0)
-3 
4     T
-14 
F(3,0,0)
-11
-9
-7 
F(3,2,0) 
F(*,*,2) 
0 
_ 
0       
-8 
F(0,0,1)
-6 
F(0,1,1) 
F(0,0,1)
-4 
F(0,1,1)
-8 
F(0,2,1) 
1       C
-6 
F(1,0,1) 
F(0,0,1)
-3 
F(1,1,1) 
F(0,0,1)
-1 
F(1,1,0) 
F(0,1,1)
-5 
F(1,2,1) 
F(0,2,1) 
2      C
-4 
F(1,0,1)
-1 
F(1,1,1) 
F(1,0,1) 
2 
F(1,1,1)
-2 
F(1,2,1) 
3      G
-8 
F(2,0,1)
-5 
F(2,1,1)
-2 
F(2,1,1) 
0 
4     T
-12 
F(3,0,1)
-9 
F(3,1,1)
-6
-4 
F(3,2,1) 
F(*,*,3) 
0 
_ 
0       
-12 
F(0,0,2)
-10 
F(0,1,2) 
F(0,0,2)
-8 
F(0,2,2) 
F(0,1,2)
-6 
F(0,2,2) 
1       C
-10 
F(1,0,2) 
F(0,0,2)
-7 
F(1,1,2) 
F(0,0,2)
-5 
F(1,2,2) 
F(1,1,2)
-3 
F(1,2,2) 
2      C
-8 
F(1,0,2) 
F(2,0,2)
-5 
F(2,1,2) 
F(1,1,2) 
F(1,0,2)
-2 
F(2,2,2) 
0 
F(2,2,2) 
3      G
-6 
F(2,0,2)
-3 
F(2,1,2) 
F(2,0,2) 
0 
F(2,2,2) 
F(2,1,2) 
1 
F(2,2,2) 
4     T
-10 
F(3,0,2)
-7 
F(3,1,2) 
F(3,0,2)
-4 
F(3,2,2)
-1 
F(3,2,2) 
Fig. 3.6 The sections of matrix F in direction i 3i3
Figure 3.6 gives the sections of F in direction i 3i3. As before, the arrows and labels 
show from which elements each number was obtained. The shaded cells and thick 
arrows indicate the traceback; it begins at upper F left parenthesis 4 comma 3 comma 3 right parenthesis equals negative 1F(4, 3, 3) = −1 and travels through the 
shaded cells until it reaches upper F left parenthesis 0 comma 0 comma 0 right parenthesisF(0, 0, 0). The traceback leads to the following three 
paths:

3.6
Multiple Alignment
39
StartLayout 1st Row upper F left parenthesis 4 comma 3 comma 3 right parenthesis right arrow upper F left parenthesis 3 comma 2 comma 2 right parenthesis right arrow upper F left parenthesis 2 comma 1 comma 1 right parenthesis right arrow upper F left parenthesis 1 comma 0 comma 0 right parenthesis right arrow upper F left parenthesis 0 comma 0 comma 0 right parenthesis comma 2nd Row upper F left parenthesis 4 comma 3 comma 3 right parenthesis right arrow upper F left parenthesis 3 comma 2 comma 2 right parenthesis right arrow upper F left parenthesis 2 comma 1 comma 1 right parenthesis right arrow upper F left parenthesis 1 comma 1 comma 1 right parenthesis right arrow upper F left parenthesis 0 comma 0 comma 0 right parenthesis comma 3rd Row upper F left parenthesis 4 comma 3 comma 3 right parenthesis right arrow upper F left parenthesis 3 comma 2 comma 2 right parenthesis right arrow upper F left parenthesis 2 comma 2 comma 2 right parenthesis right arrow upper F left parenthesis 1 comma 1 comma 1 right parenthesis right arrow upper F left parenthesis 0 comma 0 comma 0 right parenthesis period EndLayout
F(4, 3, 3) →F(3, 2, 2) →F(2, 1, 1) →F(1, 0, 0) →F(0, 0, 0),
F(4, 3, 3) →F(3, 2, 2) →F(2, 1, 1) →F(1, 1, 1) →F(0, 0, 0),
F(4, 3, 3) →F(3, 2, 2) →F(2, 2, 2) →F(1, 1, 1) →F(0, 0, 0).
They give rise, respectively, to the following three optimal alignments having score 
minus−1: 
StartLayout 1st Row 1st Column x colon 2nd Column upper C 3rd Column upper C 4th Column upper G 5th Column upper T 2nd Row 1st Column y colon 2nd Column minus 3rd Column upper A 4th Column upper G 5th Column upper T 3rd Row 1st Column z colon 2nd Column minus 3rd Column upper C 4th Column upper C 5th Column upper A EndLayout comma StartLayout 1st Row 1st Column x colon 2nd Column upper C 3rd Column upper C 4th Column upper G 5th Column upper T 2nd Row 1st Column y colon 2nd Column upper A 3rd Column minus 4th Column upper G 5th Column upper T 3rd Row 1st Column z colon 2nd Column upper C 3rd Column minus 4th Column upper C 5th Column upper A EndLayout comma StartLayout 1st Row 1st Column x colon 2nd Column upper C 3rd Column upper C 4th Column upper G 5th Column upper T 2nd Row 1st Column y colon 2nd Column upper A 3rd Column upper G 4th Column minus 5th Column upper T 3rd Row 1st Column z colon 2nd Column upper C 3rd Column upper C 4th Column minus 5th Column upper A period EndLayout
x : C C G T
y : −A G T
z : −C C A
,
x : C C G T
y : A −G T
z : C −C A
,
x : C C G T
y : A G −T
z : C C −A.
Owing to the memory and time complexity, in practice the algorithm discussed 
above cannot be utilized to align a large number of sequences. As a result, alternative 
(heuristic) algorithms have been developed. We will brieﬂy mention some of them 
below. 
3.6.1 
MSA 
MSA builds upon the aforementioned multi-dimensional dynamic programming 
algorithm, while incorporating certain constraints to mitigate the time complexity. 
For simplicity, let us assume an SP-scoring system for both the residues and gaps 
(i.e., an SP-scoring scheme with linear gap model). Thus, the score of a multiple 
alignment is the sum of the scores of all the induced pairwise alignments. Denote 
by M a multiple alignment and by Mkl the induced pairwise alignment between 
sequences k and l. Then 
script upper S left parenthesis upper M right parenthesis equals sigma summation Underscript k less than l Endscripts script upper S left parenthesis upper M Superscript k l Baseline right parenthesis commaS (M) =

k<l
S (Mkl),
where S (Mkl ) is the score of Mkl. Clearly, if skl is the score of an optimal global 
alignment between sequences k and l, then S (Mkl ) ≤ skl. 
Suppose now that there is a lower bound τ on the score of an optimal multiple 
alignment. This threshold can be established using a rapid heuristic multiple 
alignment algorithm, such as the forthcoming Star Alignment algorithm we will 
delve into. Given this context, we can assert the following relationship for the 
optimal multiple alignment M0: 
tau less than or equals script upper S left parenthesis upper M 0 right parenthesis equals sigma summation Underscript k prime less than l Superscript prime Baseline Endscripts script upper S left parenthesis upper M 0 Superscript k prime l Super Superscript prime Superscript Baseline right parenthesis less than or equals script upper S left parenthesis upper M 0 Superscript k l Baseline right parenthesis minus s Superscript k l Baseline plus sigma summation Underscript k prime less than l Superscript prime Baseline Endscripts s Superscript k prime l Super Superscript prime Superscript Baseline commaτ ≤S (M0) =

k'<l'
S (Mk'l'
0
) ≤S (Mkl
0 ) −skl +

k'<l'
sk'l',
for all k, l. It then follows that

40
3
Sequence Alignment
script upper S left parenthesis upper M 0 Superscript k l Baseline right parenthesis greater than or equals t Superscript k l Baseline commaS (Mkl
0 ) ≥tkl,
where 
t Superscript k l Baseline colon equals tau plus s Superscript k l Baseline minus sigma summation Underscript k prime less than l Superscript prime Baseline Endscripts s Superscript k prime l Super Superscript prime Superscript Baseline periodtkl := τ + skl −

k'<l'
sk'l'.
The scores of the pairwise optimal alignments in the right-hand side of this formula 
can be calculated as discussed in the earlier sections and therefore tkl can be 
computed. 
Thus, we only need to look for the multiple alignments that induce pairwise 
alignments whose scores are no less than tkl. This observation signiﬁcantly reduces 
the number of elements in the multi-dimensional dynamic programming matrix that 
need to be taken into account and as a result increases the computational speed. 
3.6.2 
Progressive Alignment 
Progressive alignment methods are heuristic techniques that generate multiple align-
ments from pairwise alignments. Typically, these methods follow this procedure: 
initially, two sequences are chosen and aligned, then a third sequence is selected 
and aligned to the existing alignment of the ﬁrst two sequences. This process 
continues iteratively until all sequences have been incorporated. ClustalW is an 
illustrative algorithm that falls within this category [33]. It is important to note 
that multiple alignments obtained through the progressive alignment approach often 
require manual reﬁnement to ensure accuracy. 
We will now describe one simple progressive alignment algorithm, called the 
Star Alignment algorithm. It is a rather fast heuristic method for producing multiple 
alignments. Certainly, just like any other heuristic algorithm, it is not guaranteed 
to ﬁnd an optimal alignment. The idea of this method is to choose a sequence that 
has the most similarity to all the other sequences and utilize it as the center of a 
“star” aligning all the other sequences to it. We will explain the algorithm using the 
following example. 
Example 3.5 Suppose we are given the following DNA sequences: 
StartLayout 1st Row x Superscript 1 Baseline colon upper C upper G upper G upper A upper T upper T upper C upper G upper G 2nd Row x squared colon upper C upper G upper A upper A upper T upper T upper C upper G upper G 3rd Row x cubed colon upper C upper G upper T upper T upper C upper C upper G upper G upper G upper G 4th Row x Superscript 4 Baseline colon upper C upper G upper T upper G upper G upper T upper G upper G 5th Row x Superscript 5 Baseline colon upper C upper T upper G upper A upper C upper T upper T period EndLayout
x1 : CGGAT T CGG
x2 : CGAAT T CGG
x3 : CGT T CCGGGG
x4 : CGT GGT GG
x5 : CT GACT T.
We adopt the scoring scheme for pairwise alignments from Example 3.1, utilize the 
corresponding SP-scoring scheme with linear gap model, compute all the pairwise

3.6
Multiple Alignment
41
optimal scores (i.e., the scores found by the global pairwise alignment algorithm 
outlined in Sect. 3.2), arrange them into the matrix shown below, and ﬁnd the sum 
in each row: 
StartLayout 1st Row 1st Column Blank 2nd Column x Superscript 1 3rd Column x squared 4th Column x cubed 5th Column x Superscript 4 6th Column x Superscript 5 7th Column Blank 8th Column Total Score 2nd Row 1st Column x Superscript 1 2nd Column Blank 3rd Column 7 4th Column negative 2 5th Column 0 6th Column negative 3 7th Column Blank 8th Column 2 3rd Row 1st Column x squared 2nd Column 7 3rd Column Blank 4th Column negative 2 5th Column 0 6th Column negative 4 7th Column Blank 8th Column 1 4th Row 1st Column x cubed 2nd Column negative 2 3rd Column negative 2 4th Column Blank 5th Column 0 6th Column negative 7 7th Column Blank 8th Column negative 11 5th Row 1st Column x Superscript 4 2nd Column 0 3rd Column 0 4th Column 0 5th Column Blank 6th Column negative 3 7th Column Blank 8th Column negative 3 6th Row 1st Column x Superscript 5 2nd Column negative 3 3rd Column negative 4 4th Column negative 7 5th Column negative 3 6th Column Blank 7th Column Blank 8th Column negative 17 period EndLayout
x1 x2 x3 x4 x5 Total Score
x1
7 −2
0 −3
2
x2
7
−2
0 −4
1
x3 −2 −2
0 −7
−11
x4
0
0
0
−3
−3
x5 −3 −4 −7 −3
−17.
Among these sequences, x1 has the best total score (which is equal to 2) and is 
chosen to be at the center of the future star. Optimal alignments between x1 and 
each of the remaining sequences are found by the global alignment algorithm from 
Sect. 3.2: 
StartLayout 1st Row StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper G 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 2nd Row 1st Column x squared colon 2nd Column upper C 3rd Column upper G 4th Column upper A 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G comma EndLayout 2nd Row Blank 3rd Row StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper G 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 11th Column minus 12th Column minus 2nd Row 1st Column x cubed colon 2nd Column upper C 3rd Column upper G 4th Column upper T 5th Column minus 6th Column upper T 7th Column upper C 8th Column upper C 9th Column upper G 10th Column upper G 11th Column upper G 12th Column upper G comma EndLayout 4th Row Blank 5th Row StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper G 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 2nd Row 1st Column x Superscript 4 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper T 5th Column upper G 6th Column upper G 7th Column upper T 8th Column minus 9th Column upper G 10th Column upper G comma EndLayout 6th Row Blank 7th Row StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper G 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 2nd Row 1st Column x Superscript 5 Baseline colon 2nd Column upper C 3rd Column upper T 4th Column upper G 5th Column upper A 6th Column upper C 7th Column upper T 8th Column upper T 9th Column minus 10th Column minus period EndLayout EndLayout
x1 : C G G A T T C G G
x2 : C G A A T T C G G,
x1 : C G G A T T C G G −−
x3 : C G T −T C C G G G G,
x1 : C G G A T T C G G
x4 : C G T G G T −G G,
x1 : C G G A T T C G G
x5 : C T G A C T T −−.
We will now merge the pairwise alignments displayed above using the “once a 
gap – always a gap” principle. We begin with x1 and x2: 
StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper G 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 2nd Row 1st Column x squared colon 2nd Column upper C 3rd Column upper G 4th Column upper A 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G EndLayoutx1 : C G G A T T C G G
x2 : C G A A T T C G G
and add x3, but, as  x3 is longer than each of x1 and x2, we add gaps at the ends of 
x1 and x2: 
StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper G 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 11th Column minus 12th Column minus 2nd Row 1st Column x squared colon 2nd Column upper C 3rd Column upper G 4th Column upper A 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 11th Column minus 12th Column minus 3rd Row 1st Column x cubed colon 2nd Column upper C 3rd Column upper G 4th Column upper T 5th Column minus 6th Column upper T 7th Column upper C 8th Column upper C 9th Column upper G 10th Column upper G 11th Column upper G 12th Column upper G period EndLayout
x1 : C G G A T T C G G −−
x2 : C G A A T T C G G −−
x3 : C G T −T C C G G G G.
These gaps are never deleted. If we introduce a gap at some position, it will stay 
there until the end of the alignment process.

42
3
Sequence Alignment
Now, we add x4 and x5. They also must have gaps added to their ends. The 
resulting multiple alignment is shown below: 
StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper G 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 11th Column minus 12th Column minus 2nd Row 1st Column x squared colon 2nd Column upper C 3rd Column upper G 4th Column upper A 5th Column upper A 6th Column upper T 7th Column upper T 8th Column upper C 9th Column upper G 10th Column upper G 11th Column minus 12th Column minus 3rd Row 1st Column x cubed colon 2nd Column upper C 3rd Column upper G 4th Column upper T 5th Column minus 6th Column upper T 7th Column upper C 8th Column upper C 9th Column upper G 10th Column upper G 11th Column upper G 12th Column upper G 4th Row 1st Column x Superscript 4 Baseline colon 2nd Column upper C 3rd Column upper G 4th Column upper T 5th Column upper G 6th Column upper G 7th Column upper T 8th Column minus 9th Column upper G 10th Column upper G 11th Column minus 12th Column minus 5th Row 1st Column x Superscript 5 Baseline colon 2nd Column upper C 3rd Column upper T 4th Column upper G 5th Column upper A 6th Column upper C 7th Column upper T 8th Column upper T 9th Column minus 10th Column minus 11th Column minus 12th Column minus period EndLayout
x1 : C G G A T T C G G −−
x2 : C G A A T T C G G −−
x3 : C G T −T C C G G G G
x4 : C G T G G T −G G −−
x5 : C T G A C T T −−−−.
The alignments found by the Star Alignment algorithm may not be optimal as is 
the case in the example below. 
Example 3.6 Consider the sequences 
StartLayout 1st Row x Superscript 1 Baseline colon upper A upper A upper T upper C upper C 2nd Row x squared colon upper A upper T upper C upper T upper C 3rd Row x cubed colon upper A upper A upper C upper T upper C EndLayout
x1 : AAT CC
x2 : AT CT C
x3 : AACT C
and assume the scoring scheme from Example 3.5. Again, here x1 is the center of 
the star, and some of the optimal alignments between x1 and each of the other two 
sequences are 
StartLayout 1st Row StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper A 3rd Column upper A 4th Column upper T 5th Column upper C 6th Column minus 7th Column upper C 2nd Row 1st Column x squared colon 2nd Column upper A 3rd Column minus 4th Column upper T 5th Column upper C 6th Column upper T 7th Column upper C comma EndLayout 2nd Row Blank 3rd Row StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper A 3rd Column upper A 4th Column minus 5th Column upper T 6th Column upper C 7th Column upper C 2nd Row 1st Column x cubed colon 2nd Column upper A 3rd Column upper A 4th Column upper C 5th Column upper T 6th Column upper C 7th Column minus period EndLayout EndLayout
x1 : A A T C −C
x2 : A −T C T C,
x1 : A A −T C C
x3 : A A C T C −.
Merging these alignments, we obtain 
StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper A 3rd Column upper A 4th Column minus 5th Column upper T 6th Column upper C 7th Column minus 8th Column upper C 2nd Row 1st Column x squared colon 2nd Column upper A 3rd Column minus 4th Column minus 5th Column upper T 6th Column upper C 7th Column upper T 8th Column upper C 3rd Row 1st Column x cubed colon 2nd Column upper A 3rd Column upper A 4th Column upper C 5th Column upper T 6th Column upper C 7th Column minus 8th Column minus period EndLayout
x1 : A A −T C −C
x2 : A −−T C T C
x3 : A A C T C −−.
The above alignment is not optimal. Indeed, its score is equal to −5, whereas a 
higher-scoring alignment (with score 1) is 
StartLayout 1st Row 1st Column x Superscript 1 Baseline colon 2nd Column upper A 3rd Column upper A 4th Column upper T 5th Column upper C 6th Column minus 7th Column upper C 2nd Row 1st Column x squared colon 2nd Column upper A 3rd Column upper T 4th Column minus 5th Column upper C 6th Column upper T 7th Column upper C 3rd Row 1st Column x cubed colon 2nd Column upper A 3rd Column upper A 4th Column minus 5th Column upper C 6th Column upper T 7th Column upper C period EndLayout
x1 : A A T C −C
x2 : A T −C T C
x3 : A A −C T C.

Chapter 4 
The Time-Frequency Spectral Analysis 
and Applications in Bioinformatics 
4.1 
Introduction 
In signal processing, time-frequency analysis encompasses a set of techniques that 
study a signal across both time and frequency domains concurrently, employing 
diverse time-frequency representations. The notion that a time series exhibits repet-
itive or predictable behaviors over time holds pivotal signiﬁcance, distinguishing 
time series analysis from classical statistics analyses. The consistency within a time 
series ﬁnds expression in the frequency domain through the identiﬁcation of periods 
inherent to the underlying phenomenon governing the series. This periodicity is 
encapsulated by Fourier frequencies, derived from combinations of sine and cosine 
functions. Hence, we can regard a time series as an outcome of a system responding 
to varied driving frequencies. In terms of regression, the time-domain methodology 
may be likened to a regression of the present state against past occurrences. 
Conversely, the frequency-domain approach involves a regression of the present 
state against periodic sine and cosine components [34]. Since biological signals 
have changing frequency characteristics, time-frequency analysis has a broad scope 
of applications in bioinformatics. We will explore the application of the Fourier 
transform in exon prediction study. 
4.2 
Discrete Fourier Transform 
Fourier analysis has become the most valuable tool in spectral data analysis 
and has consequently been applied to different kinds of data in many scientiﬁc 
or engineering disciplines. This process can be conceptualized as the expansion 
of a signal x left parenthesis n right parenthesisx(n) into a collection of waves, typically represented as sine and 
cosine functions. The Discrete Fourier Transform (DFT) serves as an adaptation 
of the traditional Fourier analysis. It operates on discrete signals within the time 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_4
43

44
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
domain, transforming them into a series of values in the frequency domain. This 
transformation is particularly applicable since dealing with discrete signals is more 
common. 
Prior to introducing the Discrete Fourier Transform (DFT), let us ﬁrst acquaint 
ourselves with the Euler identity, presented as follows: 
e Superscript i x Baseline equals cosine x plus i sine x commaeix = cos x + i sin x,
(4.1) 
where i equals StartRoot negative 1 EndRooti =
√
−1. (We assume that readers have some basic knowledge of complex 
numbers.) This formula enables us to utilize exponential functions to replace sine 
and cosine functions, yielding: 
StartLayout 1st Row cosine x equals StartFraction e Superscript i x Baseline plus e Superscript minus i x Baseline Over 2 EndFraction 2nd Row sine x equals StartFraction e Superscript i x Baseline minus e Superscript minus i x Baseline Over 2 i EndFraction period EndLayout
cos x = eix + e−ix
2
sin x = eix −e−ix
2i
.
(4.2) 
There are numerous advantages to employing this technique. For instance, the 
computation of exponential functions becomes considerably simpler and the for-
mulation is more uniﬁed in this way. Let us now proceed to deﬁne discrete Fourier 
transform (DFT) and inverse discrete Fourier transform (IDFT) using the framework 
of exponential functions. 
Deﬁnition 4.1 Given a time-domain sequence x equals left parenthesis x left parenthesis 0 right parenthesis comma x left parenthesis 1 right parenthesis comma ellipsis comma x left parenthesis upper N minus 1 right parenthesis right parenthesisx = (x(0), x(1), . . . , x(N −1)) in 
upper C Superscript upper NCN, we deﬁne the discrete Fourier transform (DFT) to be 
upper X left parenthesis k right parenthesis equals sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts x left parenthesis n right parenthesis e Superscript minus StartFraction 2 pi Over upper N EndFraction i k nX(k) =
N−1

n=0
x(n)e−2π
N ikn
(4.3) 
for k equals 0 comma 1 comma ellipsis comma upper N minus 1k = 0, 1, . . . , N −1. 
Deﬁnition 4.2 Given a frequency-domain sequence upper X equals left parenthesis upper X left parenthesis 0 right parenthesis comma upper X left parenthesis 1 right parenthesis comma ellipsis comma upper X left parenthesis upper N minus 1 right parenthesis right parenthesisX = (X(0), X(1), . . . , X(N −
1)) in upper C Superscript upper NCN, the inverse discrete Fourier transform (IDFT) is deﬁned as 
x left parenthesis n right parenthesis equals StartFraction 1 Over upper N EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts upper X left parenthesis k right parenthesis e Superscript StartFraction 2 pi Over upper N EndFraction i k nx(n) = 1
N
N−1

k=0
X(k)e
2π
N ikn
(4.4) 
for n equals 0 comma 1 comma ellipsis comma upper N minus 1n = 0, 1, . . . , N −1. 
The two deﬁnitions appear quite similar, differing only in the sign within the 
exponential functiona and the coefﬁcient StartFraction 1 Over upper N EndFraction1
N . We will subsequently show the reason 
why DFT and IDFT are considered “inverse” operations. To begin with, we will 
establish the following orthogonality property:

4.2
Discrete Fourier Transform
45
sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts e Superscript StartFraction 2 pi Over upper N EndFraction i left parenthesis m minus k right parenthesis n Baseline equals StartLayout Enlarged left brace 1st Row 1st Column upper N comma 2nd Column for m equals k 2nd Row 1st Column 0 comma 2nd Column for m not equals k comma EndLayout
N−1

n=0
e
2π
N i(m−k)n =
N,
for
m = k
0,
for
m /= k,
(4.5) 
where m comma k equals 0 comma 1 comma ellipsis comma upper N minus 1m, k = 0, 1, . . . , N −1. If  m equals km = k, the summation is equal to N as 
e Superscript StartFraction 2 pi Over upper N EndFraction i left parenthesis m minus k right parenthesis n Baseline equals e Superscript 0 Baseline equals 1e
2π
N i(m−k)n = e0 = 1. Otherwise, by using the summation formula of geometric 
progression, we get 
sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts e Superscript StartFraction 2 pi Over upper N EndFraction i left parenthesis m minus k right parenthesis n Baseline equals StartFraction 1 minus e Superscript 2 pi i left parenthesis m minus k right parenthesis Baseline Over 1 minus e Superscript StartFraction 2 pi Over upper N EndFraction i left parenthesis m minus k right parenthesis Baseline EndFraction equals 0 comma for m not equals k period
N−1

n=0
e
2π
N i(m−k)n = 1 −e2πi(m−k)
1 −e
2π
N i(m−k) = 0,
for
m /= k.
(4.6) 
In order to construct x left parenthesis n right parenthesisx(n) in terms of upper X left parenthesis k right parenthesisX(k), we multiply upper X left parenthesis k right parenthesisX(k) by e Superscript StartFraction 2 pi Over upper N EndFraction i k ne
2π
N ikn and sum 
them over the interval k equals 0k = 0 to k equals upper N minus 1k = N −1. Note that, 
StartLayout 1st Row 1st Column sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts upper X left parenthesis k right parenthesis e Superscript StartFraction 2 pi Over upper N EndFraction i k n 2nd Column equals sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts left parenthesis sigma summation Underscript m equals 0 Overscript upper N minus 1 Endscripts x left parenthesis m right parenthesis e Superscript minus StartFraction 2 pi Over upper N EndFraction i m k Baseline right parenthesis e Superscript StartFraction 2 pi Over upper N EndFraction i k n Baseline 2nd Row 1st Column Blank 2nd Column equals sigma summation Underscript m equals 0 Overscript upper N minus 1 Endscripts x left parenthesis m right parenthesis sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts e Superscript minus StartFraction 2 pi Over upper N EndFraction left parenthesis m minus n right parenthesis k Baseline equals upper N x left parenthesis n right parenthesis period EndLayout
N−1

k=0
X(k)e
2π
N ikn =
N−1

k=0
(
N−1

m=0
x(m)e−2π
N imk)e
2π
N ikn
=
N−1

m=0
x(m)
N−1

k=0
e−2π
N (m−n)k = Nx(n).
(4.7) 
Therefore, we show that x left parenthesis n right parenthesisx(n) is the IDFT of upper X left parenthesis k right parenthesisX(k) if upper X left parenthesis k right parenthesisX(k) is the DFT of x left parenthesis n right parenthesisx(n), 
and vice versa. We use x left parenthesis n right parenthesis left right double arrow upper X left parenthesis k right parenthesisx(n) ⇔X(k) to represent this relationship. 
Let us compute an example. Assume that x equals left parenthesis 2 comma 3 comma 1 comma 4 right parenthesisx = (2, 3, 1, 4), the  DFT of  x is 
computed as 
upper X left parenthesis 0 right parenthesis equals 2 e Superscript minus StartFraction 0 pi Over 4 EndFraction i Baseline plus 3 e Superscript minus StartFraction 0 pi Over 4 EndFraction i Baseline plus e Superscript minus StartFraction 0 pi Over 4 EndFraction i Baseline plus 4 e Superscript minus StartFraction 0 pi Over 4 EndFraction i Baseline equals 2 plus 3 plus 1 plus 4 equals 10X(0) = 2e−0π
4 i + 3e−0π
4 i + e−0π
4 i + 4e−0π
4 i = 2 + 3 + 1 + 4 = 10
upper X left parenthesis 1 right parenthesis equals 2 e Superscript minus StartFraction 0 pi Over 4 EndFraction i Baseline plus 3 e Superscript minus StartFraction 2 pi Over 4 EndFraction i Baseline plus e Superscript minus StartFraction 4 pi Over 4 EndFraction i Baseline plus 4 e Superscript minus StartFraction 6 pi Over 4 EndFraction i Baseline equals 2 plus 3 left parenthesis negative i right parenthesis plus left parenthesis negative 1 right parenthesis plus 4 i equals 1 plus iX(1) = 2e−0π
4 i + 3e−2π
4 i + e−4π
4 i + 4e−6π
4 i = 2 + 3(−i) + (−1) + 4i = 1 + i
upper X left parenthesis 2 right parenthesis equals 2 e Superscript minus StartFraction 0 pi Over 4 EndFraction i Baseline plus 3 e Superscript minus StartFraction 4 pi Over 4 EndFraction i Baseline plus e Superscript minus StartFraction 8 pi Over 4 EndFraction i Baseline plus 4 e Superscript minus StartFraction 12 pi Over 4 EndFraction i Baseline equals 2 plus 3 left parenthesis negative 1 right parenthesis plus 1 plus 4 left parenthesis negative 1 right parenthesis equals negative 4X(2) = 2e−0π
4 i + 3e−4π
4 i + e−8π
4 i + 4e−12π
4 i = 2 + 3(−1) + 1 + 4(−1) = −4
upper X left parenthesis 3 right parenthesis equals 2 e Superscript minus StartFraction 0 pi Over 4 EndFraction i Baseline plus 3 e Superscript minus StartFraction 6 pi Over 4 EndFraction i Baseline plus e Superscript minus StartFraction 12 pi Over 4 EndFraction i Baseline plus 4 e Superscript minus StartFraction 18 pi Over 4 EndFraction i Baseline equals 2 plus 3 i plus left parenthesis negative 1 right parenthesis plus 4 left parenthesis negative i right parenthesis equals 1 minus i periodX(3) = 2e−0π
4 i + 3e−6π
4 i + e−12π
4 i + 4e−18π
4 i = 2 + 3i + (−1) + 4(−i) = 1 −i.
Then the DFT result of the sample sequence x is upper X equals left parenthesis 10 comma 1 plus i comma negative 4 comma 1 minus i right parenthesisX = (10, 1 + i, −4, 1 −i). On  
the other hand, the IDFT of X gives the original data x which could be computed as 
StartLayout 1st Row 1st Column x left parenthesis 0 right parenthesis 2nd Column equals one fourth left bracket 10 e Superscript StartFraction 0 pi Over 4 EndFraction i Baseline plus left parenthesis 1 plus i right parenthesis e Superscript StartFraction 0 pi Over 4 EndFraction i Baseline plus left parenthesis negative 4 right parenthesis e Superscript StartFraction 0 pi Over 4 EndFraction i Baseline plus left parenthesis 1 minus i right parenthesis e Superscript StartFraction 0 pi Over 4 EndFraction i Baseline right bracket 2nd Row 1st Column Blank 2nd Column equals one fourth left bracket 10 plus left parenthesis 1 plus i right parenthesis minus 4 plus left parenthesis 1 minus i right parenthesis right bracket equals 2 EndLayout
x(0) = 1
4

10e
0π
4 i + (1 + i)e
0π
4 i + (−4)e
0π
4 i + (1 −i)e
0π
4 i
= 1
4 [10 + (1 + i) −4 + (1 −i)] = 2

46
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
StartLayout 1st Row 1st Column x left parenthesis 1 right parenthesis 2nd Column equals one fourth left bracket 10 e Superscript StartFraction 0 pi Over 4 EndFraction i Baseline plus left parenthesis 1 plus i right parenthesis e Superscript StartFraction 2 pi Over 4 EndFraction i Baseline plus left parenthesis negative 4 right parenthesis e Superscript StartFraction 4 pi Over 4 EndFraction i Baseline plus left parenthesis 1 minus i right parenthesis e Superscript StartFraction 6 pi Over 4 EndFraction i Baseline right bracket 2nd Row 1st Column Blank 2nd Column equals one fourth left bracket 10 plus left parenthesis 1 plus i right parenthesis i plus 4 plus left parenthesis 1 minus i right parenthesis left parenthesis negative i right parenthesis right bracket equals 3 EndLayout
x(1) = 1
4

10e
0π
4 i + (1 + i)e
2π
4 i + (−4)e
4π
4 i + (1 −i)e
6π
4 i
= 1
4 [10 + (1 + i)i + 4 + (1 −i)(−i)] = 3
StartLayout 1st Row 1st Column x left parenthesis 2 right parenthesis 2nd Column equals one fourth left bracket 10 e Superscript StartFraction 0 pi Over 4 EndFraction i Baseline plus left parenthesis 1 plus i right parenthesis e Superscript StartFraction 4 pi Over 4 EndFraction i Baseline plus left parenthesis negative 4 right parenthesis e Superscript StartFraction 8 pi Over 4 EndFraction i Baseline plus left parenthesis 1 minus i right parenthesis e Superscript StartFraction 12 pi Over 4 EndFraction i Baseline right bracket 2nd Row 1st Column Blank 2nd Column equals one fourth left bracket 10 plus left parenthesis 1 plus i right parenthesis left parenthesis negative 1 right parenthesis minus 4 plus left parenthesis 1 minus i right parenthesis left parenthesis negative 1 right parenthesis right bracket equals 1 EndLayout
x(2) = 1
4

10e
0π
4 i + (1 + i)e
4π
4 i + (−4)e
8π
4 i + (1 −i)e
12π
4 i
= 1
4 [10 + (1 + i)(−1) −4 + (1 −i)(−1)] = 1
StartLayout 1st Row 1st Column x left parenthesis 3 right parenthesis 2nd Column equals one fourth left bracket 10 e Superscript StartFraction 0 pi Over 4 EndFraction i Baseline plus left parenthesis 1 plus i right parenthesis e Superscript StartFraction 6 pi Over 4 EndFraction i Baseline plus left parenthesis negative 4 right parenthesis e Superscript StartFraction 12 pi Over 4 EndFraction i Baseline plus left parenthesis 1 minus i right parenthesis e Superscript StartFraction 18 pi Over 4 EndFraction i Baseline right bracket 2nd Row 1st Column Blank 2nd Column equals one fourth left bracket 10 plus left parenthesis 1 plus i right parenthesis left parenthesis negative i right parenthesis plus 4 plus left parenthesis 1 minus i right parenthesis i right bracket equals 4 period EndLayout
x(3) = 1
4

10e
0π
4 i + (1 + i)e
6π
4 i + (−4)e
12π
4 i + (1 −i)e
18π
4 i
= 1
4 [10 + (1 + i)(−i) + 4 + (1 −i)i] = 4.
Since the sequence in the frequency domain can be complex even if the sequence 
in the time domain is real, we sometimes use DFT power spectrum PS to represent 
the sequence in the frequency domain where 
upper P upper S left parenthesis k right parenthesis equals StartAbsoluteValue upper X left parenthesis k right parenthesis EndAbsoluteValue squared periodPS(k) = |X(k)|2.
Two important properties of DFT are applied in the following content. The ﬁrst 
property is the conjugate relation between upper X left parenthesis k right parenthesisX(k) and upper X left parenthesis upper N minus k right parenthesisX(N −k) when the sequence 
in the time domain is real. Given a sequence x equals left parenthesis x left parenthesis 0 right parenthesis comma ellipsis comma x left parenthesis upper N minus 1 right parenthesis right parenthesisx = (x(0), . . . , x(N −1)) in double struck upper R Superscript upper NRN, 
StartLayout 1st Row 1st Column upper X left parenthesis upper N minus k right parenthesis equals 2nd Column sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts x left parenthesis n right parenthesis e Superscript minus StartFraction 2 pi Over upper N EndFraction i left parenthesis upper N minus k right parenthesis n 2nd Row 1st Column equals 2nd Column sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts x left parenthesis n right parenthesis e Superscript StartFraction 2 pi Over upper N EndFraction i k n 3rd Row 1st Column equals 2nd Column left parenthesis sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts x left parenthesis n right parenthesis e Superscript minus StartFraction 2 pi Over upper N EndFraction i k n Baseline right parenthesis Superscript asterisk 4th Row 1st Column equals 2nd Column upper X left parenthesis k right parenthesis Superscript asterisk Baseline comma EndLayout
X(N −k) =
N−1

n=0
x(n)e−2π
N i(N−k)n
=
N−1

n=0
x(n)e
2π
N ikn
=(
N−1

n=0
x(n)e−2π
N ikn)∗
=X(k)∗,
(4.8) 
where asterisk∗is the conjugate operator, that is, left parenthesis a plus b i right parenthesis Superscript asterisk Baseline equals a minus b i(a + bi)∗= a −bi for real numbers a comma ba, b. 
Therefore, we can obtain upper X left parenthesis upper N minus k right parenthesisX(N −k) by upper X left parenthesis k right parenthesisX(k). As a direct result, we have 
upper P upper S left parenthesis k right parenthesis equals upper P upper S left parenthesis upper N minus k right parenthesis periodPS(k) = PS(N −k).
(4.9) 
It is the reason why we only present half of the picture in the frequency domain. 
Another signiﬁcant property is the well-known Parseval’s theorem.

4.2
Discrete Fourier Transform
47
Theorem 4.1 Let x left parenthesis n right parenthesis left right double arrow upper X left parenthesis k right parenthesisx(n) ⇔X(k) with sequence length N, then 
sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue x left parenthesis n right parenthesis EndAbsoluteValue squared equals StartFraction 1 Over upper N EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue upper X left parenthesis k right parenthesis EndAbsoluteValue squared period
N−1

n=0
|x(n)|2 = 1
N
N−1

k=0
|X(k)|2.
(4.10) 
Proof The proof of the theorem is direct: 
StartLayout 1st Row 1st Column sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue x left parenthesis n right parenthesis EndAbsoluteValue squared 2nd Column equals sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts x left parenthesis n right parenthesis x Superscript asterisk Baseline left parenthesis n right parenthesis 2nd Row 1st Column Blank 2nd Column equals StartFraction 1 Over upper N squared EndFraction sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts left parenthesis sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts upper X left parenthesis k right parenthesis e Superscript StartFraction 2 pi Over upper N EndFraction i k n Baseline right parenthesis left parenthesis sigma summation Underscript m equals 0 Overscript upper N minus 1 Endscripts upper X left parenthesis m right parenthesis e Superscript StartFraction 2 pi Over upper N EndFraction i m n Baseline right parenthesis Superscript asterisk Baseline 3rd Row 1st Column Blank 2nd Column equals StartFraction 1 Over upper N squared EndFraction sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts sigma summation Underscript m equals 0 Overscript upper N minus 1 Endscripts upper X left parenthesis k right parenthesis upper X Superscript asterisk Baseline left parenthesis m right parenthesis e Superscript StartFraction 2 pi Over upper N EndFraction i left parenthesis k minus m right parenthesis n Baseline 4th Row 1st Column Blank 2nd Column equals StartFraction 1 Over upper N squared EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts sigma summation Underscript m equals 0 Overscript upper N minus 1 Endscripts upper X left parenthesis k right parenthesis upper X Superscript asterisk Baseline left parenthesis m right parenthesis sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts e Superscript StartFraction 2 pi Over upper N EndFraction i left parenthesis k minus m right parenthesis n Baseline 5th Row 1st Column Blank 2nd Column equals StartFraction 1 Over upper N EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue upper X left parenthesis k right parenthesis EndAbsoluteValue squared period EndLayout
N−1

n=0
|x(n)|2 =
N−1

n=0
x(n)x∗(n)
= 1
N2
N−1

n=0
(
N−1

k=0
X(k)e
2π
N ikn)(
N−1

m=0
X(m)e
2π
N imn)∗
= 1
N2
N−1

n=0
N−1

k=0
N−1

m=0
X(k)X∗(m)e
2π
N i(k−m)n
= 1
N2
N−1

k=0
N−1

m=0
X(k)X∗(m)
N−1

n=0
e
2π
N i(k−m)n
= 1
N
N−1

k=0
|X(k)|2.
(4.11) 
The quantity sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue x left parenthesis n right parenthesis EndAbsoluteValue squared
N−1

n=0
|x(n)|2 can be referred to as the energy in the time domain, 
while StartFraction 1 Over upper N EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue upper X left parenthesis k right parenthesis EndAbsoluteValue squared 1
N
N−1

k=0
|X(k)|2 can be interpreted as the energy in the frequency domain. 
This theorem demonstrates the equality between these two energy functions. 
Furthermore, it implies that the Euclidean distance between two signals x left parenthesis n right parenthesisx(n) and 
y left parenthesis n right parenthesisy(n) in the time domain is the same as their Euclidean distance in the frequency 
domain divided by N. Sometimes we may use DFT power spectrum to index and 
query signals in databases and compare the difference between two signals in the 
frequency domain. 
Fourier transforms are frequently employed to identify the frequency compo-
nents of a signal that are obscured within a noisy time-domain signal. As an 
example, consider the following signal containing a 50 Hz sinusoid of amplitude 1.5, 
120 Hz sinusoid of amplitude 1, and 240 Hz cosine of amplitude 3 and is corrupted 
with some zero-mean random noise. 
s equals 1.5 s i n left parenthesis 2 dot pi dot 50 dot t right parenthesis plus s i n left parenthesis 2 dot pi dot 120 dot t right parenthesis plus 3 c o s left parenthesis 2 dot pi dot 240 dot t right parenthesis plus r a n d o ms = 1.5sin(2·π ·50·t)+sin(2·π ·120·t)+3cos(2·π ·240·t)+random
(4.12)

48
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
0
10
20
30
40
50 
−8 
−6 
−4 
−2 
0 
2 
4 
6 
8 
Signal Corrupted with Zero−Mean Random Noise 
Time (milliseconds) 
Fig. 4.1 Plotting the test signal vs time t 
It is difﬁcult to identify the three frequency components, 50, 120, and 240 Hz 
in the original time-domain signal (Fig. 4.1), but after converting to the frequency 
domain by the discrete Fourier transform, these three frequency components can be 
detected after the signal is converted to the frequency domain by the DFT (Fig. 4.2). 
From this example, we see that the signal is made up of three different colors 
(frequencies) at various strengths (amplitudes), then we might consider the power 
spectrum periodogram as a prism that decomposes the color into its primary colors. 
Hence we call the frequency analysis spectral analysis. 
4.3 
Exon Prediction Based on Fourier Spectral Analysis 
4.3.1 
Eukaryotic Gene Structure 
Let us brieﬂy revisit some of the concepts we covered in Chap. 1. Living cells 
can be classiﬁed into two categories: prokaryotes, such as bacteria, in which the 
cells do not have a distinct nucleus, and eukaryotes, such as most animal cells, in 
which the cells have distinct nuclei. For eukaryote cells, genes are composed of 
alternating stretches of exons (coding regions) and introns (non-coding regions).

4.3
Exon Prediction Based on Fourier Spectral Analysis
49
0
100
200
300
400
500 
0 
0.5 
1 
1.5 
2 
2.5 
3 
Single−Sided Amplitude Spectrum 
Frequency (Hz) 
Power Spectrum 
Fig. 4.2 Plotting DFT power spectrum vs frequency 
During transcription, both exons and introns are transcribed into pre-mRNA in their 
linear order. Thereafter, a process called splicing takes place, in which the intron 
sequences are excised and discarded from the RNA sequence. The remaining RNA 
segments, the ones corresponding to the exons, are ligated to form the mature RNA 
strand. 
Distinguishing exons from DNA sequences is a signiﬁcant challenge. This 
difﬁculty arises due to the absence of distinctive characteristics between exons 
and introns in the primary DNA sequence. To address this issue, numerous 
computational methods such as hidden Markov models have been proposed [35]. 
Nevertheless, there remains a desire to uncover intrinsic features of exons for 
the development of more natural techniques. In this section, we will explore the 
application of DFT to solve this problem. 
4.3.2 
Fourier Spectrum Analysis of DNA Sequences 
A DNA sequence can be depicted as a permutation of four characters (A, T , C, and 
G) of varying lengths. However, this representation is not directly suitable for DFT. 
To accommodate this, binary indicator sequences are introduced. Let us take a DNA 
sequence denoted as x equals left parenthesis x left parenthesis 0 right parenthesis comma x left parenthesis 1 right parenthesis comma ellipsis comma x left parenthesis upper N minus 1 right parenthesis right parenthesisx = (x(0), x(1), . . . , x(N −1)) as an example. This sequence

50
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
can be decomposed into four binary indicator sequences: u Subscript upper A Baseline left parenthesis n right parenthesisuA(n), u Subscript upper T Baseline left parenthesis n right parenthesisuT (n), u Subscript upper C Baseline left parenthesis n right parenthesisuC(n), and 
u Subscript upper G Baseline left parenthesis n right parenthesisuG(n). These indicators represent the presence or absence of each nucleotide (A, 
T , C, and G) at the  nth position, respectively. For example, the indicator sequence 
u Subscript upper A Baseline left parenthesis n right parenthesis equals 0001010111 ellipsisuA(n) = 0001010111 . . . indicates that the nucleotide A presents in positions 4, 6, 
8, 9, and 10 of the DNA sequence. (The position four corresponds to u Subscript upper A Baseline left parenthesis 3 right parenthesisuA(3) since 
the index starts from 0.) That is, 
upper U Subscript alpha Baseline left parenthesis n right parenthesis equals StartLayout Enlarged left brace 1st Row 1st Column 1 comma 2nd Column x left parenthesis n right parenthesis equals alpha 2nd Row 1st Column 0 comma 2nd Column otherwise comma EndLayoutUα(n) =
1,
x(n) = α
0,
otherwise,
(4.13) 
where alpha element of StartSet upper A comma upper T comma upper C comma upper G EndSetα ∈{A, T, C, G}, n equals 0 comma 1 comma ellipsis comma upper N minus 1n = 0, 1, . . . , N −1. 
According to the Deﬁnition 4.1, we deﬁne the DFT of the indicator sequences of 
the DNA sequence x to be 
upper U Subscript alpha Baseline left parenthesis k right parenthesis equals sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts u Subscript alpha Baseline left parenthesis n right parenthesis e Superscript minus StartFraction 2 pi Over upper N EndFraction i k nUα(k) =
N−1

n=0
uα(n)e−2π
N ikn
(4.14) 
for alpha element of StartSet upper A comma upper T comma upper C comma upper G EndSetα ∈{A, T, C, G}, k equals 0 comma 1 comma ellipsis comma upper N minus 1k = 0, 1, . . . , N −1 and we deﬁne the DFT power spectrum 
of a binary indicator at the frequency k to be: 
upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis equals StartAbsoluteValue upper U Subscript alpha Baseline left parenthesis k right parenthesis EndAbsoluteValue squared comma k equals 0 comma 1 comma ellipsis comma upper N minus 1 periodPSα(k) = |Uα(k)|2,
k = 0, 1, . . . , N −1.
(4.15) 
The DFT power spectrum of a DNA sequence is the sum of the power spectrum 
of its four binary indicator sequences: 
upper P upper S left parenthesis k right parenthesis equals upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis plus upper P upper S Subscript upper T Baseline left parenthesis k right parenthesis plus upper P upper S Subscript upper C Baseline left parenthesis k right parenthesis plus upper P upper S Subscript upper G Baseline left parenthesis k right parenthesis commaPS(k) = PSA(k) + PST (k) + PSC(k) + PSG(k),
(4.16) 
where upper P upper S Subscript upper A Baseline left parenthesis k right parenthesisPSA(k), upper P upper S Subscript upper T Baseline left parenthesis k right parenthesisPST (k), upper P upper S Subscript upper C Baseline left parenthesis k right parenthesisPSC(k), and upper P upper S Subscript upper G Baseline left parenthesis k right parenthesisPSG(k) are the Fourier power spectrum of 
the four indicator sequences u Subscript upper A Baseline left parenthesis n right parenthesisuA(n), u Subscript upper T Baseline left parenthesis n right parenthesisuT (n), u Subscript upper C Baseline left parenthesis n right parenthesisuC(n), and u Subscript upper G Baseline left parenthesis n right parenthesisuG(n), respectively. 
Based on Parseval’s Theorem, the energy in the time domain sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue u Subscript alpha Baseline left parenthesis n right parenthesis EndAbsoluteValue squared
N−1

n=0
|uα(n)|2 equals 
to the energy in the frequency domain StartFraction 1 Over upper N EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts StartAbsoluteValue upper U Subscript alpha Baseline left parenthesis k right parenthesis EndAbsoluteValue squared 1
N
N−1

k=0
|Uα(k)|2. (In Fourier analysis, the term 
“time domain” is a specialized term. However, when dealing with sequences, it is 
not necessarily associated with time. In this context, it can be better understood as 
the spatial domain.) Therefore, by Parseval’s theorem and the fact that 
StartAbsoluteValue u Subscript upper A Baseline left parenthesis n right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue u Subscript upper T Baseline left parenthesis n right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue u Subscript upper C Baseline left parenthesis n right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue u Subscript upper G Baseline left parenthesis n right parenthesis EndAbsoluteValue squared equals 1 comma for all n comma|uA(n)|2 + |uT (n)|2 + |uC(n)|2 + |uG(n)|2 = 1, ∀n,
(4.17) 
we have

4.3
Exon Prediction Based on Fourier Spectral Analysis
51
StartLayout 1st Row 1st Column upper E equals 2nd Column StartFraction 1 Over upper N EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts upper P upper S left parenthesis k right parenthesis 2nd Row 1st Column equals 2nd Column StartFraction 1 Over upper N EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts left parenthesis StartAbsoluteValue upper U Subscript upper A Baseline left parenthesis k right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue upper U Subscript upper T Baseline left parenthesis k right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue upper U Subscript upper C Baseline left parenthesis k right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue upper U Subscript upper G Baseline left parenthesis k right parenthesis EndAbsoluteValue squared right parenthesis 3rd Row 1st Column equals 2nd Column sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts left parenthesis StartAbsoluteValue u Subscript upper A Baseline left parenthesis n right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue u Subscript upper T Baseline left parenthesis n right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue u Subscript upper C Baseline left parenthesis n right parenthesis EndAbsoluteValue squared plus StartAbsoluteValue u Subscript upper G Baseline left parenthesis n right parenthesis EndAbsoluteValue squared right parenthesis 4th Row 1st Column equals 2nd Column upper N comma EndLayout
E = 1
N
N−1

k=0
PS(k)
= 1
N
N−1

k=0
(|UA(k)|2 + |UT (k)|2 + |UC(k)|2 + |UG(k)|2)
=
N−1

n=0
(|uA(n)|2 + |uT (n)|2 + |uC(n)|2 + |uG(n)|2)
=N,
(4.18) 
where E is the total energy of four indicator sequences in frequency domain, which 
can be considered as noise background in gene-ﬁnding methods. 
4.3.3 
The 3-Base Periodicity in Exon Sequences 
Over the past two decades, a range of computational algorithms have emerged for 
exon prediction. The predominant approach in exon ﬁnding methods is rooted in 
statistical techniques, often utilizing training datasets of known exon and intron 
sequences to derive prediction functions. For instance, the GenScan algorithm 
assesses distinct statistical features of exons and introns within a genome, employ-
ing them in prediction through a hidden Markov model (HMM) [35]. Another 
method, MZEF, is grounded in quadratic discriminant analysis of diverse sequence 
characteristics in exons and introns [36]. However, statistical methods rely on 
training sets from which various statistical parameters are derived, rendering them 
less effective in scenarios where training data are unavailable. Consequently, the 
pursuit of gene prediction techniques that transcend statistical approaches has 
emerged as a fundamental endeavor in gene-ﬁnding research [37]. 
In recent years, signal processing methodologies, particularly time-frequency 
analysis, have garnered considerable attention in genomic DNA research. They 
offer the potential to unveil concealed periodicities within sequences, thus proving 
increasingly valuable in unraveling genome structures. By transforming symbolic 
DNA sequences into numerical counterparts, signal processing tools like the Fourier 
transform or wavelet analysis can be applied to the numerical vectors, enabling 
the exploration of sequence frequency domains [38, 39]. These investigations are 
based on a crucial characteristic of exon sequences: the 3-base periodicity, which 
is recognized by a distinct peak at the frequency upper N divided by 3N/3 within the Fourier power 
spectrum of the DNA sequence, where N signiﬁes the sequence length. 
We take a simple example to show why the peak at the frequency upper N divided by 3N/3 is related 
to the 3-base periodicity of the sequence in the time domain for DFT. Consider a 
sequence with period 3 and length upper N equals 3 upper MN = 3M:

52
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
x left parenthesis t right parenthesis equals StartLayout Enlarged left brace 1st Row 1 comma t equals 0 left parenthesis m o d 3 right parenthesis 2nd Row 0 comma o t h e r w i s e EndLayoutx(t) =

1, t = 0 (mod 3)
0, otherwise
(4.19) 
Then 
StartLayout 1st Row 1st Column upper X left parenthesis k right parenthesis equals 2nd Column sigma summation Underscript n equals 0 Overscript 3 upper M minus 1 Endscripts x left parenthesis n right parenthesis e Superscript minus StartFraction 2 pi Over 3 upper M EndFraction i k n 2nd Row 1st Column equals 2nd Column sigma summation Underscript m equals 0 Overscript upper M minus 1 Endscripts e Superscript minus StartFraction 2 pi Over upper M EndFraction i k m 3rd Row 1st Column equals 2nd Column StartLayout Enlarged left brace 1st Row 1st Column 0 2nd Column comma StartFraction k Over upper M EndFraction not an element of upper Z 2nd Row 1st Column upper M 2nd Column comma StartFraction k Over upper M EndFraction element of upper Z EndLayout EndLayout
X(k) =
3M−1

n=0
x(n)e−2π
3M ikn
=
M−1

m=0
e−2π
M ikm
=

0
,
k
M /∈Z
M
,
k
M ∈Z
(4.20) 
and 
upper P upper S left parenthesis k right parenthesis equals StartLayout Enlarged left brace 1st Row 1st Column 0 2nd Column comma StartFraction k Over upper M EndFraction not an element of upper Z 2nd Row 1st Column upper M squared 2nd Column comma StartFraction k Over upper M EndFraction element of upper Z EndLayoutPS(k) =

0
,
k
M /∈Z
M2
,
k
M ∈Z
(4.21) 
Hence, it becomes evident that the 3-base periodicity of the sequence results in 
a peak at the frequency upper M equals upper N divided by 3M = N/3. However, in real-world scenarios, sequences 
exhibiting the 3-base periodicity might not be as regular as the illustrative example 
above. Consequently, there is a large possibility that upper X left parenthesis k right parenthesisX(k) may not be zero outside 
the peak frequency. 
Research has shown that the 3-base periodicity is prevalent in most exon 
sequences, but not in intron sequences [38]. The existence of the 3-base periodicity 
is the basis of the Fourier exon prediction method. Figure 4.3 is the DFT power 
spectrum of an exon (a) and an intron (b) from the gene of a fruit ﬂy. (As mentioned 
before, we only show the ﬁrst half of the DFT spectrum.) It is easy to see a peak at 
the frequency StartFraction upper N Over 3 EndFractionN
3 for exons but not for introns. 
4.3.4 
PS(N/3) Is Determined by the Unbalanced Nucleotide 
Distributions of the Three Codon Positions 
The computation time for Fourier transforms is expensive, especially for long DNA 
sequences [40, 41]. However, for the gene prediction problem, we only need to 
calculate upper P upper S left parenthesis StartFraction upper N Over 3 EndFraction right parenthesisPS( N
3 ), which is determined by the unbalanced nucleotide distributions 
of the three codon positions [40, 43–46]. 
Given a nucleotide sequence (x left parenthesis 0 right parenthesis comma x left parenthesis 1 right parenthesis comma ellipsis comma x left parenthesis upper N minus 1 right parenthesisx(0), x(1), . . . , x(N −1)) (upper N equals 3 upper MN
=
3M), 
we can divide the nucleotides into three classes: the ﬁrst codon positions 
(x left parenthesis 0 right parenthesis comma x left parenthesis 3 right parenthesis comma ellipsis comma x left parenthesis upper N minus 3 right parenthesisx(0), x(3), . . . , x(N −3)), the second codon positions (x left parenthesis 1 right parenthesis comma x left parenthesis 4 right parenthesis comma ellipsis comma x left parenthesis upper N minus 2 right parenthesisx(1), x(4), . . . , x(N −2)),

4.3
Exon Prediction Based on Fourier Spectral Analysis
53
Fig. 4.3 DFT power spectrum of an exon (a) and an intron (b) from the gene of AAM70818.2 of 
Drosophila melanogaster (fruit ﬂy) 
and the third codon positions (x left parenthesis 2 right parenthesis comma x left parenthesis 5 right parenthesis comma ellipsis comma x left parenthesis upper N minus 1 right parenthesisx(2), x(5), . . . , x(N −1)). In exonic regions, an 
imbalance has been noted in the nucleotide distributions across the three classes. In 
contrast, these distributions are balanced within intronic regions. The occurrence 
of this unbalanced distribution in the three classes can be attributed to redundant 
mappings within coding amino acids, coupled with the preference of proteins for 
speciﬁc amino acid compositions. 
To investigate the relationship between the nucleotide distributions and the 3-
base periodicity of a DNA sequence, we calculate the number of occurrences of 
different nucleotides of three classes and denote them as upper F Subscript upper A iFAi, upper F Subscript upper T iFT i, upper F Subscript upper C iFCi, and upper F Subscript upper G iFGi
where i equals 1 comma 2 comma 3i = 1, 2, 3 for the ﬁrst, second, third codon positions, respectively. In other 
words, we can get the following matrix: 
upper F equals Start 4 By 3 Matrix 1st Row 1st Column upper F Subscript upper A Baseline 1 Baseline 2nd Column upper F Subscript upper A Baseline 2 Baseline 3rd Column upper F Subscript upper A Baseline 3 Baseline 2nd Row 1st Column upper F Subscript upper T Baseline 1 Baseline 2nd Column upper F Subscript upper T Baseline 2 Baseline 3rd Column upper F Subscript upper T Baseline 3 Baseline 3rd Row 1st Column upper F Subscript upper C Baseline 1 Baseline 2nd Column upper F Subscript upper C Baseline 2 Baseline 3rd Column upper F Subscript upper C Baseline 3 Baseline 4th Row 1st Column upper F Subscript upper G Baseline 1 Baseline 2nd Column upper F Subscript upper G Baseline 2 Baseline 3rd Column upper F Subscript upper G Baseline 3 Baseline EndMatrix periodF =
⎛
⎜⎜⎝
FA1 FA2 FA3
FT 1 FT 2 FT 3
FC1 FC2 FC3
FG1 FG2 FG3
⎞
⎟⎟⎠.
In fact, upper P upper S left parenthesis StartFraction upper N Over 3 EndFraction right parenthesisPS( N
3 ) is determined by this matrix. 
For x element of StartSet upper A comma upper T comma upper C comma upper G EndSetx ∈{A, T, C, G},

54
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
StartLayout 1st Row 1st Column upper U Subscript x Baseline left parenthesis StartFraction upper N Over 3 EndFraction right parenthesis equals 2nd Column sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts u Subscript x Baseline left parenthesis n right parenthesis e Superscript minus StartFraction 2 pi Over 3 EndFraction i n 2nd Row 1st Column equals 2nd Column upper F Subscript x Baseline 1 Baseline plus e Superscript minus StartFraction 2 pi Over 3 EndFraction i Baseline upper F Subscript x Baseline 2 Baseline plus e Superscript minus StartFraction 4 pi Over 3 EndFraction i Baseline upper F Subscript x Baseline 3 Baseline period EndLayout
Ux(N
3 ) =
N−1

n=0
ux(n)e−2π
3 in
=Fx1 + e−2π
3 iFx2 + e−4π
3 iFx3.
(4.22) 
StartLayout 1st Row 1st Column upper P upper S Subscript x Baseline left parenthesis StartFraction upper N Over 3 EndFraction right parenthesis equals 2nd Column left parenthesis upper F Subscript x Baseline 1 Baseline minus one half upper F Subscript x Baseline 2 Baseline minus one half upper F Subscript x Baseline 3 Baseline right parenthesis squared plus three fourths left parenthesis upper F Subscript x Baseline 2 Baseline minus upper F Subscript x Baseline 3 Baseline right parenthesis squared 2nd Row 1st Column equals 2nd Column upper F Subscript x Baseline 1 Superscript 2 Baseline plus upper F Subscript x Baseline 2 Superscript 2 Baseline plus upper F Subscript x Baseline 3 Superscript 2 Baseline minus upper F Subscript x Baseline 1 Baseline upper F Subscript x Baseline 2 Baseline minus upper F Subscript x Baseline 1 Baseline upper F Subscript x Baseline 3 Baseline minus upper F Subscript x Baseline 2 Baseline upper F Subscript x Baseline 3 Baseline period EndLayout
PSx(N
3 ) =(Fx1 −1
2Fx2 −1
2Fx3)2 + 3
4(Fx2 −Fx3)2
=F 2
x1 + F 2
x2 + F 2
x3 −Fx1Fx2 −Fx1Fx3 −Fx2Fx3.
(4.23) 
Therefore, 
upper P upper S left parenthesis StartFraction upper N Over 3 EndFraction right parenthesis equals sigma summation Underscript x equals upper A comma upper T comma upper C comma upper G Endscripts left parenthesis upper F Subscript x Baseline 1 Superscript 2 Baseline plus upper F Subscript x Baseline 2 Superscript 2 Baseline plus upper F Subscript x Baseline 3 Superscript 2 Baseline minus upper F Subscript x Baseline 1 Baseline upper F Subscript x Baseline 2 Baseline minus upper F Subscript x Baseline 1 Baseline upper F Subscript x Baseline 3 Baseline minus upper F Subscript x Baseline 2 Baseline upper F Subscript x Baseline 3 Baseline right parenthesis periodPS(N
3 ) =

x=A,T,C,G
(F 2
x1 + F 2
x2 + F 2
x3 −Fx1Fx2 −Fx1Fx3 −Fx2Fx3).
(4.24) 
Since the matrix F is relatively easy to calculate, the computation for upper P upper S left parenthesis StartFraction upper N Over 3 EndFraction right parenthesisPS( N
3 )
can be simpliﬁed by the formula (4.24). 
We can reformulate the formula (4.24) and get 
upper P upper S left parenthesis StartFraction upper N Over 3 EndFraction right parenthesis equals three halves sigma summation Underscript x equals upper A comma upper T comma upper C comma upper G Endscripts sigma summation Underscript i equals 1 comma 2 comma 3 Endscripts left parenthesis upper F Subscript x i Baseline minus one third sigma summation Underscript j equals 1 comma 2 comma 3 Endscripts upper F Subscript x j Baseline right parenthesis squared commaPS(N
3 ) = 3
2

x=A,T,C,G

i=1,2,3
⎛
⎝Fxi −1
3

j=1,2,3
Fxj
⎞
⎠
2
,
(4.25) 
where the right-hand side can be regarded as a measurement of the unbalance of the 
distributions among three classes. 
4.3.5 
Algorithm for Finding Exons by Nucleotide Distribution 
(FEND) 
The background noise of a DNA sequence of length N, represented by E, the total 
energy of four indicator sequences in frequency domain, is proved to be N. Thus, the 
ratio of the 3-base periodicity signal to the background noise of a DNA sequence, 
denoted as upper S upper N left parenthesis upper N right parenthesisSN(N), is deﬁned as follows: 
upper S upper N left parenthesis upper N right parenthesis equals StartStartFraction upper P upper S left parenthesis StartFraction upper N Over 3 EndFraction right parenthesis OverOver upper N EndEndFraction periodSN(N) = PS( N
3 )
N
.
(4.26) 
upper S upper N left parenthesis upper N right parenthesisSN(N)represents the measure of the strength of the 3-base periodicity per 
nucleotide in a given DNA sequence. This characteristic has been observed to 
differentiate between exon and intron sequences. Typically, most exon sequences 
exhibit upper S upper N left parenthesis upper N right parenthesisSN(N) values equal to or greater than 2, whereas most intron sequences tend 
to have upper S upper N left parenthesis upper N right parenthesisSN(N) values less than 2. Therefore, by evaluating the value of upper S upper N left parenthesis upper N right parenthesisSN(N), it  
is possible to determine whether a sequence corresponds to an exon or an intron.

4.3
Exon Prediction Based on Fourier Spectral Analysis
55
However, in real applications, the problem is much more complicated. Real DNA 
sequences are composed of both exons and introns, rather than consisting solely 
of either type. Therefore, the challenge lies in accurately identifying the exonic 
nucleotides within long sequences. This task cannot be effectively accomplished 
solely by computing upper S upper N left parenthesis upper N right parenthesisSN(N) and necessitates the development of a new algorithm 
to achieve accurate results. 
One way to solve this problem is to consider sliding windows of a ﬁxed length 
[38], which break the long sequence into subsequences of the window length. For 
this method, the window length should be selected properly. A small window length 
emphasizes the small peaks that appear due to the background noise and a large 
window length causes short exons or introns in DNA sequences to be missed. 
In this part, we will focus on another method to deal with the problem, which is 
to consider the slope of SN. We ﬁrst introduce some notations used in the following 
part. For a DNA sequence of length N, let  upper D Subscript kDk denotes the sub-region ranging from 
the beginning to the position k (also called DNA walk of length k). In addition, since 
the sub-region changes in the algorithm, to avoid the ambiguity for upper P upper S left parenthesis StartFraction upper N Over 3 EndFraction right parenthesisPS( N
3 ) (not only 
related to the position but also related to the sub-region), we use upper P upper S left parenthesis upper D Subscript k Baseline comma StartFraction k Over 3 EndFraction right parenthesisPS(Dk, k
3) and 
upper S upper N left parenthesis upper D Subscript k Baseline right parenthesisSN(Dk) to denote the 3-base periodicity signal and the ratio of 3-base periodicity 
signal to the background noise of upper D Subscript kDk, respectively. 
It is found that upper S upper N left parenthesis upper D Subscript k Baseline right parenthesisSN(Dk) has different trends when k increases between exons and 
introns. In Fig. 4.4a we plot the average upper S upper N left parenthesis k right parenthesisSN(k) of DNA walks of 1000 base pairs 
fragment of 258 exon sequences from the human genome. In Fig. 4.4b we plot the  
average upper S upper N left parenthesis k right parenthesisSN(k) of DNA walks of 1000 base pairs fragment of 216 intron sequences 
from the human genome. The result is that upper S upper N left parenthesis upper D Subscript k Baseline right parenthesisSN(Dk) increases as k increases for 
a pure exon sequence while it randomly ﬂuctuates around some low values as k 
increases for a pure intron sequence. 
This phenomenon inspires us to consider the slope of SN. The algorithm for 
ﬁnding exons by nucleotide distribution (or FEND) is developed as follows [42]. 
(Fig. 4.5 depicts the ﬂowchart of the algorithm.) 
1. Let k equals 1k = 1. 
2. Calculate the nucleotide distributions within the three codon positions of upper D Subscript kDk
(represented by the F matrix denoted as upper F Subscript kFk). The matrix upper F Subscript kFk is recursively derived 
from the previous matrix upper F Subscript k minus 1Fk−1 and the nucleotides at position k when k greater than 1k > 1. 
3. Compute upper S upper N left parenthesis upper D Subscript k Baseline right parenthesisSN(Dk) by formula (4.24) and formula (4.26). 
4. Increment k by 1 and iterate through steps 2 to 3 until k equals upper Nk = N. 
5. Calculate the slope of SN at each position on the SN plot by the following way: 
Given that the majority of exon or intron sequences within a genome surpass 50 
base pairs in length, the slope at the ith position is determined as left parenthesis upper S upper N left parenthesis upper D Subscript i Baseline right parenthesis minus upper S upper N left parenthesis upper D Subscript i minus 50 Baseline right parenthesis right parenthesis divided by 50(SN(Di) −
SN(Di−50))/50, with i ranging from 51 to N. 
6. Assign the nucleotide at each position to either the exon or intron region based 
on the following criteria: If the slope at the position is greater than 0 and SN is 
equal to or greater than 2, designate the nucleotide at that position as an exon 
nucleotide. Otherwise, classify it as an intron nucleotide.

56
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
Fig. 4.4 Plots depicting average signal-to-noise ratios of DNA walks for 1000 bp DNA fragments 
from the human genome are shown. (The average signal-to-noise ratios are in the middle and the 
corresponding 95% conﬁdence intervals of these average ratios are illustrated in the lower and 
upper plots.) These fragments comprise 258 exons and 216 introns. (a) Exons. (b) Introns 
7. If a DNA region with fewer than 50 base pairs is categorized as an intron in step 
6, and it is enclosed by two exon regions, this region is commonly a false negative 
and should be reclassiﬁed as an exon region. Correspondingly, if a DNA region 
with less than 50 base pairs is identiﬁed as an exon in step 6 and is surrounded 
by two intron regions, it is often a false positive and should be reassigned as an 
intron region. 
In the case of a lengthy DNA sequence that might encompass more than two 
exons (or introns), such as an exon-intron-exon arrangement, the cumulative signal-
to-noise ratio of the ﬁnal exon could decline, particularly when a lengthy intron 
is positioned between them. This potential decline could inﬂuence the prediction 
accuracy. Enhancements to the algorithm could be made by segmenting a DNA 
sequence into distinct sub-regions. Moreover, in order to diminish the occurrence of 
false exons and false introns, the algorithm is applied from various arbitrary starting 
points, allowing multiple evaluations for each nucleotide. The subsequent algorithm 
has been devised to enhance the precision of exon prediction when utilizing the 
FEND method: 
1. If a DNA sequence is longer than 2000 base pairs (bp), divide it into subse-
quences of 2000 base pairs.

4.3
Exon Prediction Based on Fourier Spectral Analysis
57
Fig. 4.5 The ﬂowchart of the FEND exon ﬁnding algorithm (Step 1–6)

58
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
2. For each 2000 base pairs sub-sequence, set upper P 1 equals 1P1 = 1, upper P 2 equals 401P2 = 401, upper P 3 equals 801P3 = 801, 
upper P 4 equals 1201P4 = 1201, upper P 5 equals 1601P5 = 1601, and upper P 6 equals 2000P6 = 2000 be the six even-spaced points. 
3. Identify exon or intron nucleotides using the FEND method on the sub-sequence 
between point upper P Subscript iPi and upper P 6P6 where i equals 1 comma 2 comma 3 comma 4 comma 5i = 1, 2, 3, 4, 5. So each nucleotide after points 
upper P 3P3 is tested at least three times using the FEND method from different start 
points. A nucleotide is identiﬁed as an exon nucleotide when it is predicated 
in an exon region in the majority of the tests. 
The performance evaluation of the FEND algorithm involves the metrics of 
sensitivity, speciﬁcity, and accuracy, which are deﬁned as follows: Sensitivity (upper S Subscript nSn): 
Sensitivity is calculated using the formula upper S Subscript n Baseline equals StartFraction upper T upper P Over upper T upper P plus upper F upper N EndFractionSn =
T P
T P+FN . Here, T P  represents 
the true positive, which corresponds to the nucleotide length of correctly predicted 
exons; FN corresponds to the false negative, representing the nucleotide length 
of incorrectly predicted introns. Speciﬁcity (upper S Subscript pSp): Speciﬁcity is computed using the 
formula upper S Subscript p Baseline equals StartFraction upper T upper N Over upper T upper N plus upper F upper P EndFractionSp =
T N
T N+FP . In this equation, T N  stands for the true negative, which 
is the nucleotide length of correctly predicted introns; FP represents the false 
positive, indicating the nucleotide length of incorrectly predicted exons. Accuracy 
(AC): The accuracy is deﬁned as the average of sensitivity and speciﬁcity, expressed 
as upper A upper C equals StartFraction upper S Subscript n Baseline plus upper S Subscript p Baseline Over 2 EndFractionAC =
Sn+Sp
2
. In summary, sensitivity (upper S Subscript nSn) captures the correct prediction 
of coding sequences, speciﬁcity (upper S Subscript pSp) measures the accurate prediction of non-
coding sequences, and accuracy (AC) represents the overall performance, taking 
into account both sensitivity and speciﬁcity. 
To assess the FEND algorithm’s viability for predicting protein-coding regions, 
we employ test datasets comprising full-length gene sequences that encompass both 
introns and exons. The FEND algorithm is then applied to these full-length gene 
sequences to validate its efﬁcacy. As an illustrative instance, Fig. 4.6a presents 
the upper S upper N left parenthesis upper D Subscript k Baseline right parenthesisSN(Dk) plot for a test gene exhibiting an exon-intron-exon structure (gene 
locus: AAB26989.1 of Drosophila melanogaster). Figure 4.6b depicts the slope 
plot derived from SN, revealing predominantly positive slopes in exon regions 
and negative slopes in introns. Figure 4.6c showcases expected gene structures 
veriﬁed by biological experiments. Figure 4.6d displays predicted gene structures 
without applying the enhanced algorithm. For this case, the values of upper S Subscript nSn, upper S Subscript pSp, 
and AC are 0.8684, 0.4372, and 0.6528, respectively. Upon implementing the 
improved algorithm, Fig. 4.6e portrays the predicted gene structure. The ensuing 
values of upper S Subscript nSn, upper S Subscript pSp, and AC are 0.9450, 0.7556, and 0.8503, respectively. Notably, the 
FEND algorithm’s accuracy (AC) enhances by 19.75% in this particular test case. 
These outcomes underscore the algorithm’s capability in effectively identifying 
the majority of exon and intron sequences, particularly following the algorithmic 
enhancement. 
The FEND algorithm has the following advantages: (1) It uses extendable win-
dows to compute the 3-base periodicity, which reduces the bias when ﬁxed window 
lengths are used. (2) The computation of magnitude of the 3-base periodicity is 
based on nucleotide distributions on the three coding positions. The computation of 
the nucleotide distributions on the DNA walk sequences uses a recursive approach 
in which the computation of nucleotide distributions on the DNA sequence of length

4.3
Exon Prediction Based on Fourier Spectral Analysis
59
7 
a 
b 
c 
d 
e 
6 
5 
4 
3 
2 
1 
0 
0 
200 
400 
600 
800 1000 
Nucleotide Position 
Signal/Noise
Slope 
1200 1400 1600 1800 
0.04 
0.03 
0.02 
0.01 
0 
–0.01 
–0.02 
–0.03 
2 
1 
0 
–1 
2 
1 
0 
–1 
0 
200 
400 
600 
800 1000 
Nucleotide Position 
1200 1400 1600 1800 
0 
200 
400 
600 
800 1000 
Nucleotide Position 
Expected Structure 
2 
1 
0 
–1 
Predicted Structure
Predicted Structure 
1200 1400 1600 1800 
0 
200 
400 
600 
800 
1000 
Nucleotide Position 
1200 1400 1600 1800 
0 
200 
400 
600 
800 
1000 
Nucleotide Position 
1200 1400 1600 1800 
Fig. 4.6 Gene structure prediction by the FEND method. The gene locus is at AAB26989.1 of 
Drosophila melanogaster (fruit ﬂy). (a) The signal-to-noise ratios SN of the DNA walk from this 
sequence calculated by the FEND method. (b) The plot of the slopes of every two points at a 
distance of 50 base pairs from the SN plot. (c) The expected gene structure that is veriﬁed by 
biological experiments. Exon regions are marked as 1, and intron regions are marked as 0. (d) 
The predicted gene structure by the FEND method without improvement. (e) The predicted gene 
structure by the improved FEND method

60
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
k uses the results of the nucleotide distributions on the k minus 1k −1 length DNA segment. 
In terms of computational complexity, the algorithm has a linear computation time 
proportional to the length of the DNA sequence, which is very efﬁcient. (3) This 
method does not require training data sets as in statistical methods. Thus it is an ab 
initio method, which is very useful when information on the known gene structure 
is limited. 
4.4 
DNA Comparison Based on Fourier Spectral Analysis 
Comparing DNA sequences, which is the basis of clustering and classiﬁcation, is 
of great signiﬁcance in Bioinformatics. Sequence alignment introduced in Chap. 3 
is a good method to compare the sequences but it is too time-consuming for some 
large-scale problems. Therefore, the alignment-free sequence comparisons attract 
much attention. 
A basic approach for alignment-free sequence comparisons is developing a 
method to transform sequences into vectors. Then we can compare two sequences 
by calculating the distance between their corresponding vectors. In this section, we 
propose several methods that can form vectors from DNA sequences based on DFT. 
4.4.1 
Even Scaling Method of Fourier Power Spectrum 
The power spectrum obtained from the Discrete Fourier Transform (DFT) of a DNA 
sequence results in a vector, the length of which is contingent upon the sequence’s 
length. Consequently, comparing the power spectra of two sequences with distinct 
lengths directly is not feasible. A previous solution involved truncating the vectors 
and utilizing partial spectra, but this approach risked losing information crucial 
for sequence comparison. To surmount this challenge, we propose an even scaling 
method, outlined in our previous work [49], aimed at aligning DFT power spectra 
of varying lengths to a uniform length. This scaling technique is versatile and 
applicable to diverse data series. In this context, we will refrain from explicating 
the method through the lens of the DFT process. 
Let upper T Subscript n Baseline left parenthesis 1 right parenthesis comma ellipsis comma upper T Subscript n Baseline left parenthesis n right parenthesisTn(1), . . . , Tn(n) denote a data series. Our goal is to stretch it into a data 
series of length m, denoted by upper T Subscript m Baseline left parenthesis 1 right parenthesis comma ellipsis comma upper T Subscript m Baseline left parenthesis m right parenthesisTm(1), . . . , Tm(m). Let  upper Q left parenthesis k right parenthesis equals StartFraction k n Over m EndFractionQ(k) =
kn
m and upper R left parenthesis k right parenthesis equals max left brace 1 comma left floor StartFraction k n Over m EndFraction right floor right braceR(k) =
max{1,
 kn
m

} where the symbol left floor ellipsis right floor⎿. . .⏌denotes the ﬂoor function. The even scaling 
operation on the original power spectrum upper T Subscript nTn to upper T Subscript mTm is deﬁned as follows: 
upper T Subscript m Baseline left parenthesis k right parenthesis equals StartLayout Enlarged left brace 1st Row 1st Column upper T Subscript n Baseline left parenthesis upper Q left parenthesis k right parenthesis right parenthesis comma 2nd Column upper Q left parenthesis k right parenthesis element of double struck upper Z Superscript plus Baseline comma 2nd Row 1st Column upper T Subscript n Baseline left parenthesis upper R left parenthesis k right parenthesis right parenthesis plus left parenthesis upper Q left parenthesis k right parenthesis minus upper R left parenthesis k right parenthesis right parenthesis left parenthesis upper T Subscript n Baseline left parenthesis upper R left parenthesis k right parenthesis plus 1 right parenthesis minus upper T Subscript n Baseline left parenthesis upper R left parenthesis k right parenthesis right parenthesis right parenthesis comma 2nd Column upper Q left parenthesis k right parenthesis not an element of double struck upper Z Superscript plus Baseline EndLayout periodTm(k) =

Tn(Q(k)),
Q(k) ∈Z+,
Tn(R(k))+(Q(k)−R(k))(Tn(R(k)+1)−Tn(R(k))),
Q(k) /∈Z+ .
(4.27)

4.4
DNA Comparison Based on Fourier Spectral Analysis
61
By this method, we can stretch the DFT spectrum to a given length m. In real 
applications, m is determined according to the longest length of the DNA sequences 
in a data set. It is worth noticing that we always exclude the zeroth term in the power 
spectrum because it is just the sum of data and its value is too large compared with 
other terms. 
Having standardized the DNA sequence vectors to uniform lengths, we can 
proceed to compute the distance between two vectors for the purpose of comparing 
their corresponding sequences by the Euclidean distance shown as follows: 
d left parenthesis left parenthesis x 1 comma ellipsis comma x Subscript n Baseline right parenthesis comma left parenthesis y 1 comma ellipsis comma y Subscript n Baseline right parenthesis right parenthesis equals StartRoot sigma summation Underscript k equals 1 Overscript n Endscripts left parenthesis x Subscript k Baseline minus y Subscript k Baseline right parenthesis squared EndRoot periodd((x1, . . . , xn), (y1, . . . , yn)) =




n

k=1
(xk −yk)2.
(4.28) 
By this distance, we can construct the phylogenetic tree of the genomes or make a 
classiﬁcation of the genomes. 
4.4.2 
Power Spectrum Moment Method 
In this part, we consider the moments of the power spectra to deal with the problem 
of different lengths. In other words, for nucleotide A we can deﬁne its j-th moment 
to be 
upper M Subscript j Superscript upper A Baseline equals a Subscript j Superscript upper A Baseline sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts left parenthesis upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis right parenthesis Superscript j Baseline comma j equals 1 comma 2 comma ellipsis commaMA
j = aA
j
N−1

k=0
(PSA(k))j, j = 1, 2, . . . ,
(4.29) 
where a Subscript j Superscript upper AaA
j is a scaling factors [51]. Our objective is to achieve the convergence 
of higher moments toward zero, ensuring that essential information is retained 
primarily within the initial moments. As a result, the selection of normalization 
factors a Subscript j Superscript upper AaA
j should align with the inherent characteristics of the sequences. 
By Parseval theorem, we have 
sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis equals upper N Subscript upper A Baseline upper N comma
N−1

k=0
PSA(k) = NAN,
(4.30) 
where upper N Subscript upper ANA is the number of 1 in the binary sequence u Subscript upper AuA. So it is reasonable for 
a Subscript j Superscript upper AaA
j to be a power of upper N Subscript upper A Baseline upper NNAN. As stated above, we want moments to converge to zero 
gradually so that information loss is minimal, thus a Subscript j Superscript upper A Baseline equals 1 divided by left parenthesis upper N Subscript upper A Baseline upper N right parenthesis Superscript j minus 1aA
j = 1/(NAN)j−1 will be a 
good choice, i.e., we have 
upper M Subscript j Superscript upper A Baseline equals StartFraction 1 Over upper N Subscript upper A Superscript j minus 1 Baseline upper N Superscript j minus 1 Baseline EndFraction sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts left parenthesis upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis right parenthesis Superscript j Baseline periodMA
j =
1
Nj−1
A
Nj−1
N−1

k=0
(PSA(k))j.
(4.31)

62
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
With this normalization, upper M 1 Superscript upper A Baseline equals sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis equals upper N Subscript upper A Baseline upper NMA
1 =
N−1

k=0
PSA(k) = NAN. Our experimental results 
on various datasets have proved that this is a good normalization. As mentioned 
before, zeroth moment may not be useful since it is too large. We can improve the 
outcomes by considering a new j-th moment: 
upper M Subscript j Superscript upper A Baseline equals a Subscript j Superscript upper A Baseline sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts left parenthesis upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis right parenthesis Superscript j Baseline periodMA
j = aA
j
N−1

k=1
(PSA(k))j.
(4.32) 
It is easy to check that 
sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis equals upper N Subscript upper A Baseline upper N minus upper P upper S Subscript upper A Baseline left parenthesis 0 right parenthesis equals upper N Subscript upper A Baseline upper N minus upper N Subscript upper A Superscript 2 Baseline equals upper N Subscript upper A Baseline left parenthesis upper N minus upper N Subscript upper A Baseline right parenthesis period
N−1

k=1
PSA(k) = NAN −PSA(0) = NAN −N2
A = NA(N −NA).
(4.33) 
Therefore, we can naturally consider 
upper M Subscript j Superscript upper A Baseline equals StartFraction 1 Over upper N Subscript upper A Superscript j minus 1 Baseline left parenthesis upper N minus upper N Subscript upper A Baseline right parenthesis Superscript j minus 1 Baseline EndFraction sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts left parenthesis upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis right parenthesis Superscript j Baseline periodMA
j =
1
Nj−1
A
(N −NA)j−1
N−1

k=1
(PSA(k))j.
(4.34) 
The fact that higher moments tend to zero is veriﬁed as follows: 
upper M Subscript j Superscript upper A Baseline equals upper N Subscript upper A Baseline left parenthesis upper N minus upper N Subscript upper A Baseline right parenthesis sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts left parenthesis StartFraction upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis Over upper N Subscript upper A Baseline left parenthesis upper N minus upper N Subscript upper A Baseline right parenthesis EndFraction right parenthesis Superscript j Baseline equals upper N Subscript upper A Baseline left parenthesis upper N minus upper N Subscript upper A Baseline right parenthesis sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts z Subscript k Superscript j Baseline commaMA
j = NA(N −NA)
N−1

k=1

PSA(k)
NA(N −NA)
j = NA(N −NA)
N−1

k=1
zj
k,
(4.35) 
where z Subscript k Baseline equals upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis divided by upper N Subscript upper A Baseline left parenthesis upper N minus upper N Subscript upper A Baseline right parenthesiszk = PSA(k)/NA(N −NA). Notice that sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts z Subscript k Baseline equals 1
N−1

k=1
zk = 1, thus it is obvious that 
limit Underscript j right arrow normal infinity Endscripts sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts z Subscript k Superscript j Baseline equals 0 lim
j→∞
N−1

k=1
zj
k = 0. 
Additionally, due to the symmetric property of DFT coefﬁcients, we only have to 
consider the ﬁrst half of the power spectrum. Therefore, the moments are improved 
as follows: 
upper M Subscript j Superscript upper A Baseline equals StartFraction 1 Over upper N Subscript upper A Superscript j minus 1 Baseline left parenthesis upper N minus upper N Subscript upper A Baseline right parenthesis Superscript j minus 1 Baseline EndFraction sigma summation Underscript k equals 1 Overscript left bracket upper N divided by 2 right bracket Endscripts left parenthesis upper P upper S Subscript upper A Baseline left parenthesis k right parenthesis right parenthesis Superscript j Baseline periodMA
j =
1
Nj−1
A
(N −NA)j−1
[N/2]

k=1
(PSA(k))j.
(4.36) 
The moments for the remaining nucleotides T , C, and G are derived 
in a similar manner. Subsequently, the ﬁrst few moments are utilized to 
construct 
vectors 
within 
the 
Euclidean 
space. 
Our 
experimental 
ﬁndings 
demonstrate that the inclusion of three moments sufﬁces for achieving accurate 
clustering. As a result, each gene or genome sequence can be represented 
as a geometric point within a 12-dimensional Euclidean space, denoted as

4.4
DNA Comparison Based on Fourier Spectral Analysis
63
left parenthesis upper M 1 Superscript upper A Baseline comma upper M 1 Superscript upper T Baseline comma upper M 1 Superscript upper C Baseline comma upper M 1 Superscript upper G Baseline comma upper M 2 Superscript upper A Baseline comma upper M 2 Superscript upper T Baseline comma upper M 2 Superscript upper C Baseline comma upper M 2 Superscript upper G Baseline comma upper M 3 Superscript upper A Baseline comma upper M 3 Superscript upper T Baseline comma upper M 3 Superscript upper C Baseline comma upper M 3 Superscript upper G Baseline right parenthesis(MA
1 , MT
1 , MC
1 , MG
1 , MA
2 , MT
2 , MC
2 , MG
2 , MA
3 , MT
3 , MC
3 , MG
3 ). 
To 
cluster 
the 
gene or genome sequences, pairwise Euclidean distances are computed between 
these points, thereby facilitating the clustering process. 
4.4.3 
Cumulative Power Spectrum Moment Method 
A variant of the power spectrum moment method is the following cumulative power 
spectrum (CPS) moment method [53]. We consider the cumulative function of the 
power spectrum 
upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis equals sigma summation Underscript n equals 1 Overscript k Endscripts upper P upper S Subscript alpha Baseline left parenthesis n right parenthesis comma k equals 1 comma 2 comma ellipsis comma upper N minus 1 periodCPSα(k) =
k

n=1
PSα(n),
k = 1, 2, . . . , N −1.
(4.37) 
It is worth noticing that we delete upper P upper S left parenthesis 0 right parenthesisPS(0) similar to previous methods. 
For alpha element of StartSet upper A comma upper T comma upper G comma upper C EndSetα ∈{A, T, G, C}, we can repeat what we have done in the previous part and 
deﬁne 
upper M Subscript j Superscript alpha Baseline equals a Subscript j Superscript alpha Baseline sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts left parenthesis upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis right parenthesis Superscript j Baseline periodMα
j = aα
j
N−1

k=1
(CPSα(k))j.
(4.38) 
Since 
StartLayout 1st Row 1st Column sigma summation Underscript n equals 1 Overscript upper N minus 1 Endscripts upper C upper P upper S Subscript alpha Baseline left parenthesis n right parenthesis 2nd Column equals sigma summation Underscript n equals 0 Overscript upper N minus 1 Endscripts sigma summation Underscript k equals 0 Overscript n Endscripts upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis minus upper N upper P upper S Subscript alpha Baseline left parenthesis 0 right parenthesis 2nd Row 1st Column Blank 2nd Column less than or equals upper N sigma summation Underscript k equals 0 Overscript upper N minus 1 Endscripts upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis minus upper N upper P upper S Subscript alpha Baseline left parenthesis 0 right parenthesis 3rd Row 1st Column Blank 2nd Column equals upper N upper N Subscript alpha Baseline left parenthesis upper N minus upper N Subscript alpha Baseline right parenthesis comma EndLayout
N−1

n=1
CPSα(n) =
N−1

n=0
n

k=0
PSα(k) −NPSα(0)
≤N
N−1

k=0
PSα(k) −NPSα(0)
= NNα(N −Nα),
(4.39) 
a natural idea is to let a Subscript j Superscript alpha Baseline equals left parenthesis StartFraction 1 Over upper N upper N Subscript alpha Baseline left parenthesis upper N minus upper N Subscript alpha Baseline right parenthesis EndFraction right parenthesis Superscript j minus 1aα
j = (
1
NNα(N−Nα))j−1. However, in this way 
upper M 1 Superscript alpha Baseline equals a 1 Superscript alpha Baseline sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis equals sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis commaMα
1 = aα
1
N−1

k=1
CPSα(k) =
N−1

k=1
CPSα(k),
(4.40) 
and upper M 1 Superscript alphaMα
1 will be too large since upper C upper P upper S Subscript alphaCPSα is cumulative. Therefore, the scale factor is 
chosen as StartFraction 1 Over upper N left parenthesis upper N upper N Subscript alpha Baseline left parenthesis upper N minus upper N Subscript alpha Baseline right parenthesis right parenthesis Superscript j minus 1 Baseline EndFraction equals StartFraction 1 Over left parenthesis upper N Subscript alpha Baseline left parenthesis upper N minus upper N Subscript alpha Baseline right parenthesis right parenthesis Superscript j minus 1 Baseline upper N Superscript j Baseline EndFraction
1
N(NNα(N−Nα))j−1 =
1
(Nα(N−Nα))j−1Nj for the CPS method. Then

64
4
The Time-Frequency Spectral Analysis and Applications in Bioinformatics
upper M Subscript j Superscript alpha Baseline equals StartFraction 1 Over left parenthesis upper N Subscript alpha Baseline left parenthesis upper N minus upper N Subscript alpha Baseline right parenthesis right parenthesis Superscript j minus 1 Baseline upper N Superscript j Baseline EndFraction sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts left parenthesis upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis right parenthesis Superscript jMα
j =
1
(Nα(N −Nα))j−1Nj
N−1

k=1
(CPSα(k))j
(4.41) 
The mean value of the CPS is deﬁned as 
upper M e a n Subscript alpha Baseline equals StartFraction 1 Over upper N minus 1 EndFraction sigma summation Underscript n equals 1 Overscript upper N minus 1 Endscripts upper C upper P upper S Subscript alpha Baseline left parenthesis n right parenthesis periodMeanα =
1
N −1
N−1

n=1
CPSα(n).
(4.42) 
We can make use of the mean value and deﬁne the central moment vectors. 
upper C upper M Subscript j Superscript alpha Baseline equals StartFraction 1 Over left parenthesis upper N Subscript alpha Baseline left parenthesis upper N minus upper N Subscript alpha Baseline right parenthesis right parenthesis Superscript j minus 1 Baseline upper N Superscript j Baseline EndFraction sigma summation Underscript k equals 1 Overscript upper N minus 1 Endscripts StartAbsoluteValue upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesis minus upper M e a n Subscript alpha Baseline EndAbsoluteValue Superscript j Baseline periodCMα
j =
1
(Nα(N −Nα))j−1Nj
N−1

k=1
|CPSα(k) −Meanα|j.
(4.43) 
The absolute value is used, otherwise the ﬁrst central moment vector would be zero. 
When evaluating the moments of cumulative Fourier power spectra for genomic 
sequences, a notable observation arises: the moment vectors and central moment 
vectors of the third moment are signiﬁcantly smaller in magnitude compared to the 
ﬁrst and second moments. Building upon this insight, we opt to focus exclusively on 
the initial two moment vectors and the ﬁrst two central moment vectors. This results 
in a 16-dimensional truncated moment vector for each sequence in the Euclidean 
space, given by 
StartLayout 1st Row 1st Column Blank 2nd Column left parenthesis upper M 1 Superscript upper A Baseline comma upper M 2 Superscript upper A Baseline comma upper C upper M 1 Superscript upper A Baseline comma upper C upper M 2 Superscript upper A Baseline comma upper M 1 Superscript upper T Baseline comma upper M 2 Superscript upper T Baseline comma upper C upper M 1 Superscript upper T Baseline comma upper C upper M 2 Superscript upper T Baseline comma upper M 1 Superscript upper C Baseline comma upper M 2 Superscript upper C Baseline comma upper C upper M 1 Superscript upper C Baseline comma 2nd Row 1st Column Blank 2nd Column upper C upper M 2 Superscript upper C Baseline comma upper M 1 Superscript upper G Baseline comma upper M 2 Superscript upper G Baseline comma upper C upper M 1 Superscript upper G Baseline comma upper C upper M 2 Superscript upper G Baseline right parenthesis period EndLayout(MA
1 , MA
2 , CMA
1 , CMA
2 , MT
1 , MT
2 , CMT
1 , CMT
2 , MC
1 , MC
2 , CMC
1 ,
CMC
2 , MG
1 , MG
2 , CMG
1 , CMG
2 ).
We name this method the cumulative Fourier power spectrum (CPS) to dis-
tinguish it from the traditional power spectrum approach. A pivotal enhancement 
offered by the CPS method is that, mathematically, upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesisCPSα(k) and its moment 
vectors can be computed from each other, while the power spectrum cannot achieve 
this [53]. (A similar proof will be given in details in Theorem 6.1. The  key  
difference between PS and CPS is that upper C upper P upper S Subscript alpha Baseline left parenthesis k right parenthesisCPSα(k) is increasing while upper P upper S Subscript alpha Baseline left parenthesis k right parenthesisPSα(k) is 
not.) Consequently, the CPS method retains more essential information from the 
original sequence during the transformation into numerical sequences. This feature 
distinguishes it as a potent tool for preserving the inherent characteristics of the 
original genomic data.

Chapter 5 
Graphical Representation of Sequences 
and Its Application 
Mathematical analysis of large-volume genomic DNA sequence data is one of the 
challenges for biologists. Graphical representation of DNA or protein sequences 
provides a simple way of viewing, sorting, and comparing sequence similarity. In 
this chapter, we introduce two directions to construct graphical representation for 
biological sequences. The ﬁrst direction is by curves without degeneracy and the 
second one is by Chaos Game Representation. 
5.1 
Graphical Representation by Curves Without 
Degeneracy 
5.1.1 
A Construction Without Degeneracy 
Approximately two decades ago, Hamori introduced the concept of utilizing a three-
dimensional H curve to depict a DNA sequence [54]. However, generating the 
H curve requires sophisticated computer graphic tools. As an alternative, Gates 
proposed a simpler two-dimensional graphical representation [55]. Nevertheless, 
Gates’s graphical approach exhibits substantial degeneracy. For instance, sequences, 
like AGTC, AGTCA, AGTCAG, and so forth, yield identical graphical repre-
sentations. In mathematical terms, this degeneracy manifests as repetitive closed 
loops or circuits within the DNA graph. In light of these considerations, we 
introduce a novel two-dimensional graphical representation for DNA sequences. 
This representation successfully eliminates circuits and degeneracy, establishing a 
one-to-one correspondence between DNA sequences and DNA graphs [48]. 
As shown in Fig. 5.1a, we construct a pyrimidine-purine graph on two quadrants 
of the Cartesian coordinate system, with pyrimidines (T and C) in the ﬁrst quadrant 
and purines (A and G) in the fourth quadrant. The unit vectors representing four 
nucleotides A, C, G, and T are as follows: 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_5
65

66
5
Graphical Representation of Sequences and Its Application
Fig. 5.1 The unit vectors 
designed by Yau (a) and  
Gates (b) in the  Cartesian  
coordinate plane 
left parenthesis one half comma minus StartFraction StartRoot 3 EndRoot Over 2 EndFraction right parenthesis right arrow upper A comma left parenthesis StartFraction StartRoot 3 EndRoot Over 2 EndFraction comma one half right parenthesis right arrow upper C comma left parenthesis StartFraction StartRoot 3 EndRoot Over 2 EndFraction comma negative one half right parenthesis right arrow upper G comma left parenthesis one half comma StartFraction StartRoot 3 EndRoot Over 2 EndFraction right parenthesis right arrow upper T period
1
2, −
√
3
2

→A,
√
3
2 , 1
2

→C,
√
3
2 , −1
2

→G,
1
2,
√
3
2

→T.
(5.1) 
Different from Gates’s method (Fig. 5.1b), our representation method utilizes 
only two quadrants of the Cartesian coordinates. The point corresponding to the 
jth nucleotide in the graphical representation is obtained by the sum of vectors 
representing nucleotides from ﬁrst to jth in the sequence. Figure 5.2 illustrates the 
graphs for two DNA segments based on our method and Gate’s method, respectively. 
We can see that graphs produced by our method avoid circuits. 
It is not hard to prove that there is no circuit or degeneracy in our two-
dimensional graphical representation. We here present a simple proof by contra-
diction. We assume that (1) the number of nucleotides forming a circuit is n, (2)

5.1
Graphical Representation by Curves Without Degeneracy
67
Fig. 5.2 Two-dimensional 
graphs of both human and 
mouse β-globin exon-1 DNA 
sequences are generated by 
Yau’s (a) or Gates’s  (b) 
method. Both sequences are 
obtained from NCBI 
GenBank (AF527577 or 
gi:22094826 for human 
β-globin, and J00413 or 
gi:193793 for mouse 
β-globin)

68
5
Graphical Representation of Sequences and Its Application
the number of A, C, G, and T in a circuit is a, c, g, and t, respectively. So, 
a + c + g + t = n. Because aA, cC, gG, and tT form a circuit, the following 
equation holds: 
a left parenthesis one half comma minus StartFraction StartRoot 3 EndRoot Over 2 EndFraction right parenthesis plus c left parenthesis StartFraction StartRoot 3 EndRoot Over 2 EndFraction comma one half right parenthesis plus g left parenthesis StartFraction StartRoot 3 EndRoot Over 2 EndFraction comma negative one half right parenthesis plus t left parenthesis one half comma StartFraction StartRoot 3 EndRoot Over 2 EndFraction right parenthesis equals 0a
1
2, −
√
3
2

+ c
√
3
2 , 1
2

+ g
√
3
2 , −1
2

+ t
1
2,
√
3
2

= 0
(5.2) 
then 
a plus StartRoot 3 EndRoot c plus StartRoot 3 EndRoot g plus t equals 0 comma minus StartRoot 3 EndRoot a plus c minus g plus StartRoot 3 EndRoot t equals 0 perioda +
√
3c +
√
3g + t = 0,
−
√
3a + c −g +
√
3t = 0.
(5.3) 
Clearly (5.2) and (5.3) hold if and only if a = c = g = t = 0. Therefore, n = 0, 
which means no circuit exists in this graphical representation. 
Furthermore, given x-projection and y-projection of any point p = (x, y) on the 
sequence, we have 
a left parenthesis one half comma minus StartFraction StartRoot 3 EndRoot Over 2 EndFraction right parenthesis plus c left parenthesis StartFraction StartRoot 3 EndRoot Over 2 EndFraction comma one half right parenthesis plus g left parenthesis StartFraction StartRoot 3 EndRoot Over 2 EndFraction comma negative one half right parenthesis plus t left parenthesis one half comma StartFraction StartRoot 3 EndRoot Over 2 EndFraction right parenthesis equals left parenthesis x comma y right parenthesisa
1
2, −
√
3
2

+ c
√
3
2 , 1
2

+ g
√
3
2 , −1
2

+ t
1
2,
√
3
2

= (x, y)
(5.4) 
and 
a plus StartRoot 3 EndRoot c plus StartRoot 3 EndRoot g plus t equals 2 x comma minus StartRoot 3 EndRoot a plus c minus g plus StartRoot 3 EndRoot t equals 2 y commaa +
√
3c +
√
3g + t = 2x,
−
√
3a + c −g +
√
3t = 2y,
(5.5) 
where x is the x-projection and y is the y-projection of the point. 2x and 2y are 
irrational numbers of form m + n
√
3, where m and n are integers. After uniquely 
determining mx, nx, my, and ny from 2x and 2y, the number ap, cp, gp, and tp of 
A, C, G, and T from the beginning of the sequence to the point p can be found by 
solving the following linear system: 
a Subscript p Baseline plus t Subscript p Baseline equals m Subscript xap + tp = mx
g Subscript p Baseline plus c Subscript p Baseline equals n Subscript xgp + cp = nx
minus g Subscript p Baseline plus c Subscript p Baseline equals m Subscript y−gp + cp = my
minus a Subscript p Baseline plus t Subscript p Baseline equals n Subscript y Baseline period−ap + tp = ny.
By successive x-projection and y-projection of points on the sequence, we can 
recover the original DNA sequence uniquely from the DNA graph. 
The current approach introduces a direct plotting method to represent DNA 
sequences without encountering degeneracy. In comparison to previous methods, 
this graphical representation is more in-line with the conventional recognition of 
linear sequences from the 5’ to 3’ end, a perspective familiar to molecular biologists. 
Furthermore, it can be easily constructed without the need for extensive computer 
graphic tools. The distinctive peaks and valleys generated by the DNA graph offer

5.1
Graphical Representation by Curves Without Degeneracy
69
clear differentiation for speciﬁc DNA sequences, allowing for visual recognition of 
these long-range patterns. Through the DNA graph, one can mathematically recap-
ture the usage of A, C, G, and T, along with the original DNA sequence, without any 
loss of textual information. The considerable complexity and degeneracy that have 
plagued previous DNA graphical representations, limiting the practical application 
of DNA graphs, are effectively addressed by this newly introduced two-dimensional 
graphical representation of DNA sequences. 
5.1.2 
Other Constructions Without Degeneracy 
Previously, we introduced a two-dimensional graphical representation for gene 
sequences that eliminates circuitry and degeneracy, ensuring a one-to-one corre-
spondence between gene sequences and gene graphs. This approach facilitates the 
mathematical recovery of the original DNA sequence from its graph, preserving 
all biological information. In this part, we will introduce two other constructions 
without degeneracy. They are modiﬁed versions of the method introduced in 
Sect. 5.1.1 and both of them help deﬁne the distance for sequences. 
5.1.2.1 
A Construction with Corresponding Moment Vectors 
In this part, we present a slight modiﬁcation to our previous method, resulting in 
a novel approach for graphical representation of DNA sequences [57]. The key 
advancement lies in our ability to derive moment vectors from DNA sequences 
using this novel graphical technique. The unique aspect of our approach is that these 
moment vectors enable the construction of a genome space within the Euclidean 
space. Remarkably, each genome sequence can be transformed into a distinct point 
within this genome space, exemplifying the distinctive feature of our method. 
Consequently, the genome space serves as a platform for conducting comparative 
analyses, facilitating investigations into clustering and phylogenetic relationships 
among genomes. The biological or evolutionary distance between two genomes is 
accurately gauged through the calculation of the Euclidean distance between the 
corresponding points within the genome space. 
In this construction, the vectors corresponding to the four nucleotides A, C, G, 
and T are as follows (Fig. 5.3): 
left parenthesis 1 comma negative one third right parenthesis right arrow upper A comma left parenthesis 1 comma two thirds right parenthesis right arrow upper C comma left parenthesis 1 comma negative two thirds right parenthesis right arrow upper G comma left parenthesis 1 comma one third right parenthesis right arrow upper T period

1, −1
3

→A,

1, 2
3

→C,

1, −2
3

→G,

1, 1
3

→T.
(5.6) 
In Fig. 5.4, we present the graphical depictions of complete mitochondrial 
genome sequences for the human, common chimpanzee, Norway rat, and hedgehog. 
These visual representations are constructed based on the vector system outlined 
in Fig. 5.3. Notably, the human and chimpanzee, both belonging to the primate

70
5
Graphical Representation of Sequences and Its Application
Fig. 5.3 Nucleotide vector 
system based on A(1, −1/3), 
C(1, 2/3), G(1, −2/3) and 
T (1, 1/3) 
y 
x 
o 
1 
–1 
C(1, 2/3) 
G(1, –2/3) 
T(1, 1/3) 
A(1, –1/3) 
x = 1 
A line graph of  y versus  x. The  nucleotide  ve ctors C, T, A, and G  origin ate from t
he origin O and t ouch the  lin e x = 1  at C (1 , 2  over 3), T  (1, 1 o ver 3), A (1,  neg
ative 1 o ver  3),  and G (1,  ne gative  2 over 3) , respe ctiv ely.
56A l ine gr aph of y versu s x. T he nu cleo tide vecto rs C, 
T, A , a nd G origina te fr om the or igi n O and  to uch t he line x  = 1 at C ( 1, 2 ov
er 3), T (1 , 1 over 3),  A (1, n e gativ e  1 over  3 ),  and G (1, negati ve 2  over 3
), respectively.
upper M Subscript j Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts StartFraction left parenthesis i minus y Subscript i Baseline right parenthesis Superscript j Baseline Over n Superscript j Baseline EndFraction comma j equals 1 comma 2 comma ellipsis comma n commaMj =
n

i=1
(i −yi)j
nj
,
j = 1, 2, . . . , n,
(5.7) 
where n is the number of nucleotides contained in a DNA sequence. According 
to this deﬁnition, each DNA sequence has an n-dimensional moment vector 
(M1, M2, . . . , Mn) associated with it. The crucial point here is that the correspon-
dence between a DNA sequence and its moment vector obtained from its sequence 
graph is one-to-one. In other words, we can compute the values in {i − yi|i = 
1, . . . , n} from (M1, M2, . . . , Mn). (A similar proof will be given in details in

5.1
Graphical Representation by Curves Without Degeneracy
71
2000 
Human
Common chimpanzee 
Norway rat
Hedgehog 
1500 
1000 
500 
0 
–500 0
0.5
1 
X 
Y 
Y 
Y 
Y
Y
 
x104
X 
X
X
x104 
x104
x104 
1.5
2
0
0.5
1
1.5
2 
0
0.5
1
1.5
2
0
0.5
1
1.5
2 
2000 
1500 
1000 
500 
0 
–500 
2000 
1500 
1000 
500 
0 
–500 
2000 
1500 
1000 
500 
0 
–500 
Fig. 5.4 Graphical representations of the whole mitochondrial genome sequences of four species 
(the human, the common chimpanzee, the Norway rat, and the hedgehog) based on the vector 
system shown in Fig. 5.3 
Theorem 6.1. The key point is that i − yi is strictly increasing with respect to i.) 
Therefore, we can obtain the sequence if the moment vector is given. 
In real applications, we consider the ﬁrst N components (M1, M2, . . . , MN) of 
the moment vector to represent a sequence where N is ﬁxed for all sequences so 
that we can calculate the distance between two sequences with different length. 
Furthermore, phylogenetic and clustering analysis can be performed since the 
distance of two sequences is deﬁned. 
5.1.2.2 
A Construction with Corresponding Probability Distribution 
In this part, a new construction of graphical representation is introduced. The 
novelty of this method is that we can construct a probability distribution for the 
DNA sequences by the representation [58]. 
In this construction, the vectors corresponding to the four nucleotides A, C, G, 
and T are as follows (Fig. 5.5): 
left parenthesis 1 comma 0.8 right parenthesis right arrow upper A comma left parenthesis 1 comma 0.6 right parenthesis right arrow upper G comma left parenthesis 1 comma 0.4 right parenthesis right arrow upper C comma left parenthesis 1 comma 0.2 right parenthesis right arrow upper T period

1, 0.8

→A,

1, 0.6

→G,

1, 0.4

→C,

1, 0.2

→T.
(5.8)

72
5
Graphical Representation of Sequences and Its Application
Fig. 5.5 Nucleotide vector 
system based on upper A left parenthesis 1 comma 0.8 right parenthesisA(1, 0.8), 
upper G left parenthesis 1 comma 0.6 right parenthesisG(1, 0.6), upper C left parenthesis 1 comma 0.4 right parenthesisC(1, 0.4), and  
upper T left parenthesis 1 comma 0.2 right parenthesisT (1, 0.2)
A (1, 0.8) 
X 
Y 
1
0 
1 
G (1, 0.6) 
C (1, 0.4) 
T (1, 0.2) 
Fig. 5.6 Graphical 
representation of DNA 
sequence (ATGGTGCACC) 
based on the vector system 
shown in Fig. 5.5 
6 
5 
4 
3 
2 
1 
0 0 
A 
T 
G 
DNA Sequence (ATGGTGCACC) 
G 
T 
G 
C 
A 
C 
C 
1
2
3
4
5
 
X 
Y 
6
7
8
9
 10
 
The points depicted in the graphical representation are derived by aggregating 
the vectors corresponding to nucleotides within the sequence. Each vector’s ter-
minal point signiﬁes an individual nucleotide. Figure 5.6 illustrates the graphical 
representation of the DNA sequence (ATGGTGCACC) of the initial ten nucleotides 
of the human betaβ-globin coding sequence. Importantly, the graphical curve displayed 
avoids circuits or redundancies, conﬁrming a clear and unambiguous one-to-one 
correspondence between the sequence and its graphical representation. 
Subsequently, we establish a discrete probability distribution to process the 
graph. In other words, we deﬁne a vector left parenthesis p 1 comma ellipsis comma p Subscript n Baseline right parenthesis(p1, . . . , pn) with the following properties. 
(1) sigma summation Underscript i equals 1 Overscript n Endscripts p Subscript i Baseline equals 1 period
n
i=1
pi = 1. (2) 0 less than or equals p Subscript i Baseline less than or equals 10 ≤pi ≤1 for i equals 1 comma ellipsis comma ni = 1, . . . , n. 
Our deﬁnition is shown as follows:

5.1
Graphical Representation by Curves Without Degeneracy
73
p Subscript i Baseline equals StartFraction x Subscript i Baseline minus ModifyingAbove y Subscript i Baseline With quotation dash Over one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline EndFraction commapi =
xi −yi
1
2n(n + 1) −yn
,
(5.9) 
where left parenthesis x Subscript i Baseline comma y Subscript i Baseline right parenthesis(xi, yi) represents the position of the ith nucleotide in the DNA graphical 
curve and ModifyingAbove y Subscript i Baseline With quotation dashyi represents the choice of y-coordinate value at the ith nucleotide in 
the DNA graphical curve according to Fig. 5.5. For example, for the DNA sequence 
ATGGT, we have 
ModifyingAbove y 1 With quotation dash equals 0.8 comma ModifyingAbove y 2 With quotation dash equals 0.2 comma ModifyingAbove y 3 With quotation dash equals 0.6 comma ModifyingAbove y 4 With quotation dash equals 0.6 comma ModifyingAbove y 5 With quotation dash equals 0.2 comma y 5 equals 2.4y1 = 0.8, y2 = 0.2, y3 = 0.6, y4 = 0.6, y5 = 0.2, y5 = 2.4
StartLayout 1st Row 1st Column left parenthesis p 1 comma p 2 comma p 3 comma p 4 comma p 5 right parenthesis 2nd Column equals left parenthesis StartFraction 1 minus 0.8 Over one half dot 5 dot 6 minus 2.4 EndFraction comma StartFraction 2 minus 0.2 Over one half dot 5 dot 6 minus 2.4 EndFraction comma StartFraction 3 minus 0.6 Over one half dot 5 dot 6 minus 2.4 EndFraction comma StartFraction 4 minus 0.6 Over one half dot 5 dot 6 minus 2.4 EndFraction comma StartFraction 5 minus 0.2 Over one half dot 5 dot 6 minus 2.4 EndFraction right parenthesis 2nd Row 1st Column Blank 3rd Row 1st Column Blank 2nd Column equals left parenthesis 0.0159 comma 0.1429 comma 0.1905 comma 0.2698 comma 0.3810 right parenthesis period EndLayout
(p1, p2, p3, p4, p5) =

1−0.8
1
2 ·5·6−2.4,
2−0.2
1
2 ·5·6−2.4,
3−0.6
1
2 ·5·6−2.4,
4−0.6
1
2 ·5·6−2.4,
5−0.2
1
2 ·5·6−2.4

= (0.0159, 0.1429, 0.1905, 0.2698, 0.3810).
Next, we prove that left parenthesis p 1 comma ellipsis comma p Subscript n Baseline right parenthesis(p1, . . . , pn) is a discrete probability distribution: 
sigma summation Underscript i equals 1 Overscript n Endscripts p Subscript i Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts StartFraction x Subscript i Baseline minus ModifyingAbove y Subscript i Baseline With quotation dash Over one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline EndFraction equals StartFraction sigma summation Underscript i equals 1 Overscript n Endscripts x Subscript i Baseline minus sigma summation Underscript i equals 1 Overscript n Endscripts ModifyingAbove y Subscript i Baseline With quotation dash Over one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline EndFraction equals StartFraction one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline Over one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline EndFraction equals 1 period
n

i=1
pi =
n

i=1
xi −yi
1
2n(n + 1) −yn
=
n
i=1
xi −
n
i=1
yi
1
2n(n + 1) −yn
=
1
2n(n + 1) −yn
1
2n(n + 1) −yn
= 1.
(5.10) 
Since 0 less than ModifyingAbove y Subscript i Baseline With quotation dash less than 10 < yi < 1 and 1 less than or equals x Subscript i Baseline less than or equals n1 ≤xi ≤n, x Subscript i Baseline minus ModifyingAbove y Subscript i Baseline With quotation dash less than or equals x Subscript i Baseline less than or equals nxi −yi ≤xi ≤n, then 
y Subscript n Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts ModifyingAbove y Subscript i Baseline With quotation dash less than n comma one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline greater than one half n left parenthesis n plus 1 right parenthesis minus n periodyn =
n

i=1
yi < n,
1
2n(n + 1) −yn > 1
2n(n + 1) −n.
(5.11) 
Thus 
p Subscript i Baseline equals StartFraction x Subscript i Baseline minus ModifyingAbove y Subscript i Baseline With quotation dash Over one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline EndFraction less than StartFraction n Over one half n left parenthesis n plus 1 right parenthesis minus n EndFraction equals StartStartFraction 1 OverOver StartFraction n plus 1 Over 2 EndFraction minus 1 EndEndFraction equals StartFraction 2 Over n minus 1 EndFraction periodpi =
xi −yi
1
2n(n + 1) −yn
<
n
1
2n(n + 1) −n
=
1
n+1
2
−1
=
2
n −1.
(5.12) 
So, when n greater than or equals 3n ≥3, p Subscript i Baseline less than 1pi < 1. On the other hand, x Subscript i Baseline minus ModifyingAbove y Subscript i Baseline With quotation dash greater than 0xi −yi > 0 and 
one half n left parenthesis n plus 1 right parenthesis minus y Subscript n Baseline greater than one half n left parenthesis n plus 1 right parenthesis minus n equals one half n left parenthesis n minus 1 right parenthesis greater than 0 comma n greater than or equals 3 period1
2n(n + 1) −yn > 1
2n(n + 1) −n = 1
2n(n −1) > 0,
n ≥3.
(5.13) 
Therefore, when n greater than or equals 3n ≥3, 0 less than p Subscript i Baseline less than 10 < pi < 1. By (5.10), (5.12), and (5.13), we have proved 
that left parenthesis p 1 comma ellipsis comma p Subscript n Baseline right parenthesis(p1, . . . , pn) is a discrete probability distribution. 
The probability distribution of a DNA sequence is inherently linked to its length. 
It restricts the direct comparison between DNA sequences of varying lengths. 
To overcome this limitation, we introduce a methodology capable of generating 
distributions of a speciﬁed length. For a DNA sequence s with a length of n and 
a particular value N where upper N less than nN < n, a total of n minus upper N plus 1n −N + 1 subsequences, each of 
length N, can be derived. These subsequences are represented as s 1 Superscript upper N Baseline comma ellipsis comma s Subscript n minus upper N plus 1 Superscript upper NsN
1 , . . . , sN
n−N+1. 
Each subsequence corresponds to a discrete probability distribution of length N,

74
5
Graphical Representation of Sequences and Its Application
permitting the calculation of an average distribution across these subsequences. 
By adopting this approach, a probability distribution of length N can be obtained. 
By employing this technique, in scenarios involving a collection of sequences of 
varying lengths, we can standardize the process. Speciﬁcally, we can set N as the 
length of the shortest sequence within the dataset, thereby generating corresponding 
distributions of equal length for all sequences. 
Now that we have discrete probability distributions with the same length N 
for all DNA sequences where N is the minimal length among all sequences, we 
want to ﬁnd a dissimilarity measure between two discrete probability distributions 
lamda 1 equals left parenthesis p 1 comma p 2 comma ellipsis comma p Subscript n Baseline right parenthesisλ1 = (p1, p2, . . . , pn) and lamda 2 equals left parenthesis q 1 comma q 2 comma ellipsis comma q Subscript n Baseline right parenthesisλ2 = (q1, q2, . . . , qn). A well-known measure between 
two probability distributions is the Kullback-Leibler divergence [59]. The Kullback-
Leibler divergence (KLD) or the relative entropy of lamda 1λ1 with respect to lamda 2λ2, denoted 
as upper D Subscript upper K upper L Baseline left parenthesis lamda 1 StartAbsoluteValue EndAbsoluteValue lamda 2 right parenthesisDKL(λ1||λ2) is deﬁned by 
upper D Subscript upper K upper L Baseline left parenthesis lamda 1 StartAbsoluteValue EndAbsoluteValue lamda 2 right parenthesis equals sigma summation Underscript i equals 1 Overscript n Endscripts p Subscript i Baseline l o g StartFraction p Subscript i Baseline Over q Subscript i Baseline EndFraction periodDKL(λ1||λ2) =
n

i=1
pilog pi
qi
.
(5.14) 
Kullback-Leibler divergence is often called a distance, but it is not a true distance 
in mathematics for not being symmetric, i.e., upper D Subscript upper K upper L Baseline left parenthesis lamda 1 StartAbsoluteValue EndAbsoluteValue lamda 2 right parenthesis not equals upper D Subscript upper K upper L Baseline left parenthesis lamda 2 StartAbsoluteValue EndAbsoluteValue lamda 1 right parenthesisDKL(λ1||λ2) /= DKL(λ2||λ1). 
Moreover, it does not satisfy the triangle inequality. To make it symmetric, we use 
the following version: 
d left parenthesis lamda 1 comma lamda 2 right parenthesis colon equals one half left parenthesis upper D Subscript upper K upper L Baseline left parenthesis lamda 1 StartAbsoluteValue EndAbsoluteValue lamda 2 right parenthesis plus upper D Subscript upper K upper L Baseline left parenthesis lamda 2 StartAbsoluteValue EndAbsoluteValue lamda 1 right parenthesis right parenthesis periodd(λ1, λ2) := 1
2(DKL(λ1||λ2) + DKL(λ2||λ1)).
(5.15) 
We then utilize this method to perform phylogenetic analysis. We consider com-
plete coding sequence of betaβ-globin genes extracted from 10 distinct species: human 
(U01317), woolly monkey (AY279114), tufted monkey (AY279115), rat (X06701), 
rabbit (V00882), hare (Y00347), gallus (NM_001081704), duck (X15739), opos-
sum (J03642), and salmon (NM_001123672). All these DNA sequences encompass 
444 nucleotides. We utilize the UPGMA (Unweighted Pair Group Method with 
Arithmetic Mean) algorithm [60] to construct the phylogenetic tree, which is 
the diagram with branches that represents the evolutionary relationships among 
different biological species. The tree is depicted in Fig. 5.7. Notably, it is important 
to acknowledge that the phylogenetic relationships among these 10 species may 
not be perfectly precise due to the exclusion of complete genome information in 
the tree’s construction. Nevertheless, the ﬁgure still illustrates the striking similarity 
shared by these 10 DNA sequences.

5.1
Graphical Representation by Curves Without Degeneracy
75
Woolly monkey 
Capuchin monkey 
Human 
Rabbit 
Hare 
Opossum 
Rat 
Gallus 
Duck 
Salmon 
0.06
0.04
0.02
0.00 
Fig. 5.7 Phylogenetic tree of 10 different species based on their complete coding sequence of 
betaβ-globin genes by using our new approach 
5.1.3 
Constructions for Proteins 
5.1.3.1 
A Protein Map Based on Amino Acid Hydrophobicity 
The preceding sections have introduced graphical representation methods for gene 
sequences. In this section, we will introduce a technique for constructing a graph 
from a protein sequence. Unlike gene or DNA sequences, which consist of only four 
nucleotides, protein sequences consist of 20 amino acids, which are more intricate. 
However, we demonstrate that it is possible to graphically represent protein or amino 
acid sequences, leading to the generation of a comprehensive protein map [61]. This 
protein map holds the potential to predict the properties of proteins whose functions 
remain undetermined. 
The framework is what we introduce in Sect. 5.1.2.1. A amino acid x is mapped 
to a vector (1, f (x)) where f (x)  ∈[−1, 1]. However, since there are 20 amino 
acids, it is much more difﬁcult to design their corresponding vectors. In this part, 
we will provide a protein map based on hydrophobicity. 
Amino acid hydrophobicity is a signiﬁcant property for amino acids and it 
plays an important role in protein folding [62]. In the protein map, we sort the 
amino acids based on their hydrophobicity scale values. Higher hydrophobicity 
scale values correspond to higher y-coordinate values. Among the amino acids, 
there exist 12 with positive hydrophobicity scale values. These are allocated to 
the ﬁrst quadrant, where the difference in y-coordinate values between consecutive 
amino acids amounts to 1/13. Glycine, possessing a hydrophobicity scale value of 
zero, is assigned a y-coordinate value of zero. The remaining seven amino acids, 
characterized by negative hydrophobicity scale values, are positioned in the fourth 
quadrant. Here, the difference in y-coordinate values between neighboring amino

76
5
Graphical Representation of Sequences and Its Application
Table 5.1 Hydrophobicity 
scale values and y-coordinate 
of the 20 amino acids 
Amino acid 
Hydrophobicity scale 
y-coordinate 
Trp (W)
+2.25
12/13 
Ile (I)
+1.80
11/13 
Phe (F)
+1.79
10/13 
Leu (L)
+1.70
9/13 
Cys (C) 
+1.54
8/13 
Met (M) 
+1.23
7/13 
Val (V)
+1.22
6/13 
Tyr (Y)
+0.96
5/13 
Pro (P)
+0.72
4/13 
Ala (A) 
+0.31
3/13 
Thr (T)
+0.26
2/13 
His (H) 
+0.13
1/13 
Gly (G)
0
0 
Ser (S)
−0.04
−1/8 
Gln (Q) 
−0.22
−2/8 
Asn (N) 
−0.60
−3/8 
Glu (E) 
−0.64
−4/8 
Asp (D) 
−0.77
−5/8 
Lys (K) 
−0.99
−6/8 
Arg (R)
−1.01
−7/8 
acids is set at 1/8. The y-coordinates corresponding to the 20 amino acids are 
enumerated in Table 5.1, and their respective vectors are illustrated in Fig. 5.8. 
The points within the graphical depiction are derived from the summation of 
vectors that represent amino acids present in the sequence. Illustrated in Fig. 5.9, 
we showcase the graphical representation of the initial 10 characters of the human 
β-globin amino acid sequence. The comprehensive graphical representation of 
the complete human β-globin amino acid sequence is displayed in Fig. 5.10. A  
straightforward validation conﬁrms the correspondence between the sequence and 
the graphical curve, ensuring a one-to-one mapping, while simultaneously ensuring 
that the representation is devoid of any circuits or degeneracy. 
Similar to the method in Sect. 5.1.2.1, we can deﬁne the moment vector. Given 
the graphical curve of a DNA sequence represented by a sequence of points (1, y1), 
(2, y2),. . . ,(n, yn), the moment is deﬁned as follows: 
upper M Subscript j Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts StartFraction left parenthesis i minus y Subscript i Baseline right parenthesis Superscript j Baseline Over n Superscript j Baseline EndFraction comma j equals 1 comma 2 comma ellipsis comma n commaMj =
n

i=1
(i −yi)j
nj
,
j = 1, 2, . . . , n,
(5.16) 
where n is the number of amino acids contained in a protein sequence. The 
properties and applications of the moment vectors are almost the same as those 
in Sect. 5.1.2.1. We do not repeat the process.

5.1
Graphical Representation by Curves Without Degeneracy
77
W 
I 
F 
L 
C 
M 
V 
Y 
P 
A 
T 
H 
G 
S 
Q 
N 
E 
D 
K 
R 
–1 
–1 
1 
Y 
X 
X = 1 
Fig. 5.8 Amino acid vector system based on Table 5.1 
Fig. 5.9 Graphical representation of the ﬁrst 10 amino acids of the human β-globin sequence 
based on the vector system of Fig. 5.8

78
5
Graphical Representation of Sequences and Its Application
Fig. 5.10 Graphical representation of the human β-globin amino acid sequence based on the 
vector system of Fig. 5.8 
Likewise, in practical applications, the moments are often truncated, allowing 
a protein sequence graph to be succinctly represented as a point situated within a 
two-dimensional or three-dimensional space, depending on whether the ﬁrst two or 
the ﬁrst three moments of this sequence graph are employed as its moment vector. 
By applying clustering techniques to either of these mappings, diverse aspects of 
protein sequences can be analyzed systematically and efﬁciently. 
5.1.3.2 
Protein Maps Based on Various Properties of Amino Acids 
In the preceding section, the construction process of a protein map was determined 
by the hydrophobicity property of amino acids, overlooking other crucial biological 
factors governing amino acid substitution. In this section, we will present an 
enhanced protein map that incorporates a broader spectrum of biological elements 
that contribute to protein evolution at the amino acid level [63]. 
The inﬂuence of amino acid physico-chemical properties on substitution rates 
and the overall pattern of protein evolution has been extensively studied, necessitat-
ing the incorporation of a broader range of amino acid properties into our analysis 
[64]. In the previous research, 10 amino acid properties, including the chemical 
composition of side chains, polarity metrics, hydropathy, isoelectric point, volume, 
aromaticity, aliphaticity, hydrogenation, and hydroxythiolation, are studied [64]. 
Furthermore, the research conducted a comprehensive assessment of the relative 
signiﬁcance of these amino acid properties in relation to (1) the evolution of the 
genetic code, (2) the amino acid composition of proteins, and (3) the pattern of 
nonsynonymous substitutions. The insights garnered from this investigation serve 
as a solid foundation for the development of our new protein map.

5.1
Graphical Representation by Curves Without Degeneracy
79
We formulate 10 tables to showcase the point values and corresponding y-
coordinates for all amino acids, each based on one of the 10 properties under study 
[64, 65]. These properties include: chemical composition of the side chain, polarity, 
volume, polar requirement, hydropathy, isoelectric point, PC I (aliphaticity), PC II 
(hydrogenation), PC III (aromaticity), and PC IV (hydroxyethylation). Below, we 
present the isoelectric point values and their respective y-coordinates for the 20 
amino acids in Table 5.2. For the amino acid with the largest property value, its y-
coordinate is assigned as 1, while the amino acid with the smallest property value 
receives a y-coordinate of −1. Notably, the y-coordinate values for other amino 
acids lie within the range of −1 to 1. The discrepancy in y-coordinates between 
any two amino acids is proportional to the disparity in their corresponding property 
values. To clarify, if the value in the second column is denoted as xi and the y-
coordinate value as yi for the ith amino acid, then the relationship holds: 
y Subscript i Baseline equals negative 1 plus 2 StartFraction x Subscript i Baseline minus min Underscript j Endscripts x Subscript j Baseline Over max Underscript j Endscripts x Subscript j Baseline minus min Underscript j Endscripts x Subscript j Baseline EndFraction periodyi = −1 + 2
xi −minj xj
maxj xj −minj xj
.
(5.17) 
It is important to note that several amino acids might share identical values for 
certain properties. For example, Leu (L), Ala (A), Val (V), Ile (I), Phe (F), and 
Met (M) have the same value zero with the property “chemical composition of the 
side chain.” To address this scenario, we introduce slight perturbations to their y-
coordinate values. Speciﬁcally, Phe (F) is assigned 0.001, Ile (I) receives 0.002, 
Val (V) is assigned 0.003, Ala (A) receives 0.004, and Leu (L) is given 0.005. 
This adjustment ensures that the y-coordinate values for the 20 amino acid vectors 
remain distinct. This distinction is pivotal to preserving the unique correspondence 
of moment vectors. 
For one amino acid sequence, we can obtain ten graphical representations based 
on 10 properties. For each graphical representation, we can get one moment vector 
according to our protein map method. Thus, for one protein sequence with n amino 
acids, we have 10 moment vectors associated with it: 
left parenthesis upper M Subscript 1 comma 1 Baseline comma upper M 1.2 comma ellipsis comma upper M Subscript 1 comma n Baseline right parenthesis comma left parenthesis upper M Subscript 2 comma 1 Baseline comma upper M 2.2 comma ellipsis comma upper M Subscript 2 comma n Baseline right parenthesis comma ellipsis comma left parenthesis upper M Subscript 10 comma 1 Baseline comma upper M 10.2 comma ellipsis comma upper M Subscript 10 comma n Baseline right parenthesis period(M1,1, M1.2, . . . , M1,n), (M2,1, M2.2, . . . , M2,n), . . . , (M10,1, M10.2, . . . , M10,n).
(5.18) 
Since the ﬁrst several moments of one n-dimensional moment vector are crucial 
as we discussed before, we choose the ﬁrst 3 moments for each vector. Therefore, 
for one amino acid sequence, we have a 30-dimensional combined vector associated 
with it: 
left parenthesis upper M Subscript 1 comma 1 Baseline comma upper M Subscript 1 comma 2 Baseline comma upper M Subscript 1 comma 3 Baseline comma upper M Subscript 2 comma 1 Baseline comma upper M Subscript 2 comma 2 Baseline comma upper M Subscript 2 comma 3 Baseline comma ellipsis comma upper M Subscript 10 comma 1 Baseline comma upper M Subscript 10 comma 2 Baseline comma upper M Subscript 10 comma 3 Baseline right parenthesis period(M1,1, M1,2, M1,3, M2,1, M2,2, M2,3, . . . , M10,1, M10,2, M10,3).
(5.19) 
Until this point, we have combined ten distinct physico-chemical properties of 
amino acids. However, the importance among these properties can exhibit consider-
able variability [64]. Consequently, it becomes imperative to introduce weighting 
factors to the constituents of the 30-dimensional vectors based on their relative

80
5
Graphical Representation of Sequences and Its Application
Table 5.2 Isoelectric point 
values and y-coordinate 
values of 20 amino acids 
Amino acid
Isoelectric point
y-coordinate 
Arg (R)
10.76
1 
Lys (K)
9.74
0.74468 
His (H)
7.59
0.20651 
Pro (P)
6.30
−0.1164 
Thr (T)
6.16
−0.15144 
Ile (I)
6.02
−0.18648 
Ala (A)
6.00
−0.19149 
Leu (L)
5.98
−0.1965 
Gly (G)
5.97
−0.199 
Val (V)
5.96
−0.2015 
Trp (W)
5.89
−0.21902 
Met (M)
5.74
−0.25657 
Ser (S)
5.68
−0.27159 
Tyr (Y)
5.66
−0.2766 
Gln (Q)
5.65
−0.2791 
Phe (F)
5.48
−0.32165 
Asn (N)
5.41
−0.33917 
Cys (C)
5.07
−0.42428 
Glu (E)
3.22
−0.88736 
Asp (D)
2.77
−1 
signiﬁcance. In their comprehensive study of ten protein-coding mitochondrial 
genes from 19 mammalian species, Xia and Li [64] identify intriguing trends. They 
observe that the genetic code seems to have evolved toward minimizing polarity and 
hydropathy, while the other properties appear less inﬂuential. Furthermore, only the 
chemical composition and isoelectric point seem to have impacted the amino acid 
composition of the proteins under scrutiny. Regarding amino acid nonsynonymous 
substitutions, all ten properties, with the exception of PC IV, exert an effect. The 
authors provide quantiﬁed insights into the effects of these amino acid properties 
on the rates of substitution, measured in numerical values. Each value represents 
the average percentage change across the 10 genes for a speciﬁc amino acid 
property. The magnitude of this percentage denotes the relative importance of the 
property. These values serve as the weights that empower the enhancement of the 
30-dimensional vector. Despite Xia and Li’s assertion that PC IV has negligible 
inﬂuence on amino acid substitution rates [64], we assign it a smallest weight (0.1). 
As a result, for any given protein sequence, we derive a weighted 30-dimensional 
vector, delineated as follows:

5.1
Graphical Representation by Curves Without Degeneracy
81
StartLayout 1st Row left parenthesis 0.2909 upper M Subscript 1 comma 1 Baseline comma 0.2909 upper M Subscript 1 comma 2 Baseline comma 0.2909 upper M Subscript 1 comma 3 Baseline comma 0.3240 upper M Subscript 2 comma 1 Baseline comma 0.3240 upper M Subscript 2 comma 2 Baseline comma 0.3240 upper M Subscript 2 comma 3 Baseline comma 2nd Row 0.2990 upper M Subscript 3 comma 1 Baseline comma 0.2990 upper M Subscript 3 comma 2 Baseline comma 0.2990 upper M Subscript 3 comma 3 Baseline comma 0.3749 upper M Subscript 4 comma 1 Baseline comma 0.3749 upper M Subscript 4 comma 2 Baseline comma 0.3749 upper M Subscript 4 comma 3 Baseline comma 3rd Row 0.2358 upper M Subscript 5 comma 1 Baseline comma 0.2358 upper M Subscript 5 comma 2 Baseline comma 0.2358 upper M Subscript 5 comma 3 Baseline comma 0.4348 upper M Subscript 6 comma 1 Baseline comma 0.4348 upper M Subscript 6 comma 2 Baseline comma 0.4348 upper M Subscript 6 comma 3 Baseline comma 4th Row 0.2238 upper M Subscript 7 comma 1 Baseline comma 0.2238 upper M Subscript 7 comma 2 Baseline comma 0.2238 upper M Subscript 7 comma 3 Baseline comma 0.1736 upper M Subscript 8 comma 1 Baseline comma 0.1736 upper M Subscript 8 comma 2 Baseline comma 0.1736 upper M Subscript 8 comma 3 Baseline comma 5th Row 0.2819 upper M Subscript 9 comma 1 Baseline comma 0.2819 upper M Subscript 9 comma 2 Baseline comma 0.2819 upper M Subscript 9 comma 3 Baseline comma 0.1 upper M Subscript 10 comma 1 Baseline comma 0.1 upper M Subscript 10 comma 2 Baseline comma 0.1 upper M Subscript 10 comma 3 Baseline right parenthesis period EndLayout
(0.2909M1,1, 0.2909M1,2, 0.2909M1,3, 0.3240M2,1, 0.3240M2,2, 0.3240M2,3,
0.2990M3,1, 0.2990M3,2, 0.2990M3,3, 0.3749M4,1, 0.3749M4,2, 0.3749M4,3,
0.2358M5,1, 0.2358M5,2, 0.2358M5,3, 0.4348M6,1, 0.4348M6,2, 0.4348M6,3,
0.2238M7,1, 0.2238M7,2, 0.2238M7,3, 0.1736M8,1, 0.1736M8,2, 0.1736M8,3,
0.2819M9,1, 0.2819M9,2, 0.2819M9,3, 0.1M10,1, 0.1M10,2, 0.1M10,3).
(5.20) 
By the method mentioned above, we transform the protein sequences into 
30-dimensional vectors based on various properties. This vector contains more 
information than that based on only amino acid hydrophobicity. 
5.1.4 
Yau-Hausdorff Distance 
In the previous parts, we have introduced some constructions of graphical represen-
tation by curves that have corresponding vectors or distributions which allow us to 
calculate distance. However, it is also a good idea to deﬁne a distance for curves 
directly. In this part, we will introduce Yau-Hausdorff distance [66], a method to 
measure the distance between sets of high-dimensional points. We can apply it to 
the curves in graphical representation since these curves can be regarded as sets of 
points. 
We ﬁrst introduce Hausdorff distance, one of the most widely used criteria for 
point set comparisons [67]. For two point sets A and B, the Hausdorff distance 
between point A and point B sets is deﬁned by 
h left parenthesis upper A comma upper B right parenthesis equals max left brace max Underscript a element of upper A Endscripts min Underscript b element of upper B Endscripts StartAbsoluteValue a minus b EndAbsoluteValue comma max Underscript b element of upper B Endscripts min Underscript a element of upper A Endscripts StartAbsoluteValue b minus a EndAbsoluteValue right brace periodh(A, B) = max{max
a∈A min
b∈B |a −b|, max
b∈B min
a∈A |b −a|}.
(5.21) 
When comparing graphical representations of DNA or protein sequences, our 
primary focus lies in the extent of shape similarity. Consequently, the ideal 
metric should encompass the optimal alignment considering rigid transformations, 
including translation and rotation. While the general Hausdorff distance gauges the 
separation between two ﬁxed sets, it may not be the most suitable choice for an ideal 
metric, despite being a formally deﬁned metric. 
The introduced minimum two-dimensional Hausdorff distance, outlined below, 
serves as a well-deﬁned metric that precisely fulﬁlls this requirement. 
upper H squared left parenthesis upper A comma upper B right parenthesis equals min Underscript theta element of left bracket 0 comma 2 pi right bracket Endscripts min Underscript t element of upper R squared Endscripts h left parenthesis upper A plus t comma upper B Superscript theta Baseline right parenthesis commaH 2(A, B) =
min
θ∈[0,2π] min
t∈R2 h(A + t, Bθ),
(5.22) 
where h is the Hausdorff distance deﬁned in Eq. (5.21), and h left parenthesis upper A plus t comma upper B Superscript theta Baseline right parenthesish(A + t, Bθ) stands for 
the Hausdorff distance between A and B after shifting A rightward by t and rotating 
B counterclockwise by thetaθ. 
The minimum two-dimensional Hausdorff distance is widely utilized for graph 
comparison, and several algorithms have been developed to calculate this distance.

82
5
Graphical Representation of Sequences and Its Application
Some of these algorithms assume that the point sets consist only grid points. 
Such algorithms are primarily employed in pixel image matching tasks, such 
as photo identiﬁcation and MRI analysis. However, when comparing graphical 
representations of sequences, precise rotation of each point is required, rendering 
the grid point assumption inadequate. 
In more general scenarios, where two point sets of sizes m and n are considered, 
the Huttenlocher algorithm computes the minimum two-dimensional Hausdorff 
distance with a time complexity of upper O left parenthesis left parenthesis m plus n right parenthesis Superscript 6 Baseline log left parenthesis m n right parenthesis right parenthesisO((m+n)6 log(mn)) [68]. A later improvement 
to the algorithm brings down the complexity to upper O left parenthesis left parenthesis m plus n right parenthesis Superscript 5 Baseline log squared left parenthesis m n right parenthesis right parenthesisO((m+n)5 log2(mn)) [69]. Despite 
these enhancements, these algorithms remain impractical for comparing graphic 
curves of lengthy sequences exceeding 10,000 base pairs. 
If the points are in double struck upper RR, the computation will be much easier since there will be no 
rotation. The minimum one-dimensional Hausdorff distance [70] is deﬁned below: 
upper H Superscript 1 Baseline left parenthesis upper A comma upper B right parenthesis equals min Underscript t element of upper R Endscripts h left parenthesis upper A plus t comma upper B right parenthesis commaH 1(A, B) = min
t∈R h(A + t, B),
(5.23) 
where h left parenthesis upper A plus t comma upper B right parenthesish(A + t, B) is the Hausdorff distance between A and B after shifting A 
rightward by t. This equation can be rewritten as 
upper H Superscript 1 Baseline left parenthesis upper A comma upper B right parenthesis equals min Underscript t element of upper R Endscripts max left brace max Underscript a element of upper A plus t Endscripts min Underscript b element of upper B Endscripts StartAbsoluteValue a minus b EndAbsoluteValue comma max Underscript b element of upper B Endscripts min Underscript a element of upper A plus t Endscripts StartAbsoluteValue b minus a EndAbsoluteValue right brace periodH 1(A, B) = min
t∈R max{ max
a∈A+t min
b∈B |a −b|, max
b∈B min
a∈A+t |b −a|}.
(5.24) 
Li has proposed an algorithm to calculate the minimum one-dimensional Hausdorff 
distance with complexity upper O left parenthesis left parenthesis m plus n right parenthesis l o g left parenthesis m plus n right parenthesis right parenthesisO((m + n)log(m + n)) [71]. 
The Yau-Hausdorff distance is a method to deal with two-dimensional points by 
the minimum one-dimensional Hausdorff distance: 
upper D left parenthesis upper A comma upper B right parenthesis equals max left brace max Underscript theta Endscripts min Underscript phi Endscripts upper H Superscript 1 Baseline left parenthesis upper P Subscript x Baseline left parenthesis upper A Superscript theta Baseline right parenthesis comma upper P Subscript x Baseline left parenthesis upper B Superscript phi Baseline right parenthesis right parenthesis comma max Underscript phi Endscripts min Underscript theta Endscripts upper H Superscript 1 Baseline left parenthesis upper P Subscript x Baseline left parenthesis upper A Superscript theta Baseline right parenthesis comma upper P Subscript x Baseline left parenthesis upper B Superscript phi Baseline right parenthesis right parenthesis right brace commaD(A, B) = max{max
θ
min
ϕ H 1(Px(Aθ), Px(Bϕ)), max
ϕ
min
θ
H 1(Px(Aθ), Px(Bϕ))},
(5.25) 
where upper P Subscript x Baseline left parenthesis upper A Superscript theta Baseline right parenthesisPx(Aθ) is a one-dimensional point set representing the projection of A on the 
x-axis after being rotated counterclockwise by thetaθ. 
The Yau-Hausdorff distance D possesses the following properties [66]: 
• 
D can be proven as a metric. 
• 
D is deﬁned in terms of and inherits properties from the minimum one-
dimensional Hausdorff distance. 
• 
Using the projection of two-dimensional point sets, D successfully avoids cal-
culation of the Hausdorff distance of two-dimensional sets and can be computed 
efﬁciently. 
The Yau-Hausdorff distance is not equal to the two-dimensional minimum 
Hausdorff distances. In fact, the Yau-Hausdorf distance is the lower bound of the 
minimum two-dimensional Hausdorff distances, i.e., upper H squared left parenthesis upper A comma upper B right parenthesis greater than or equals upper D left parenthesis upper A comma upper B right parenthesisH 2(A, B) ≥D(A, B). 
When dealing with two sequences of lengths m and n, the computational 
complexity of the Yau-Hausdorff distance between these sequence curves is upper O left parenthesis m n right parenthesisO(mn)

5.1
Graphical Representation by Curves Without Degeneracy
83
Fig. 5.11 Phylogenetic tree 
of COI sequences 
0
10
20
30
 
Luscinia_megarhynchos 
Callobius_bennetti 
Ninox_variegata 
Otus_scops 
Bubo_Bubo 
Falco_tinnunculus 
Buteo_magnirostris 
Accipiter_francesiae 
Accipiter_gularis 
40 50 60 
A phyl ogen etic tre e of C O I seque nces. a. A ccipiter f ran ce siae and  acc ipiter gula
ris  b. Ninox-vari egata an d otus-scops. c. Falco tinnuculus and bubo-bubo are connected to the nodes. d. a and buteo-magnirostris and e. b and luscinia-megarhynchos are connected. f. b and d. g. f is connected to Callobius-bennetti. upper O left parenthesis m n left parenthesis m plus n right parenthesis log left parenthesis m plus n right parenthesis right parenthesisO(mn(m + n) log(m + n))A phy logenetic tree of C
 O I sequen ces. a . A ccipiter fra nces iae and accipiter gularis b . Ni nox-va riega
ta and  otus-scop s. c. F alco  tinnuculus a nd bu bo-bubo are  conn ecte d to th e nodes. d.
 a and buteo-magnirostris and e. b and luscinia-megarhynchos are connected. f. b and d. g. f is connected to Callobius-bennetti. upper O left parenthesis left parenthesis m plus n right parenthesis Superscript 5 Baseline log squared left parenthesis m n right parenthesis right parenthesisO((m + n)5 log2(mn)) A phylogenetic tree of C O I sequences. a. Accipiter francesiae and accipiter gularis b. Ninox-variegata and otus-scops. c. Falco tinnuculus and bubo-bubo are connected to the nodes. d. a and buteo-magnirostris and e. b and luscinia-megarhynchos are connected. f. b and d. g. f is connected to Callobius-bennetti.69A p hylo genetic tree o f C O I s equences.  a. Accipiter
 frances iae and accipiter gularis b. Ninox-var ieg ata and otus -sco ps. c. F alco 
tinnuc ulus and bubo-bub o are connected to the n
odes. d. a  and buteo-mag nirostris and  e. b and lusc inia-mega rhynchos  are
 connected . f. b and d. g.  f is conn ected to  Callo bius -be nnett i.
n plus 1n+1 A phylo gene ti c tree of  C O I seq uen ces . a. Accipite r fr ancesiae and a cci piter gula
ris b. Ninox-var iega ta and ot us-scops. 
c. Falco  tinn ucul us and bubo-b ubo  are connected to the nodes. d. a and buteo-magnirostris and e. b and luscinia-megarhynchos are connected. f. b and d. g. f is connected to Callobius-bennetti. 5.1.1 A p hylo genetic tr ee of C O  I s
equenc es. a. Accipiter francesiae and accipiter gularis b. Ninox-variegata and otus-scops. c. Falco tinnuculus and bubo-bubo are connected to the nodes. d. a and buteo-magnirostris and e. b and luscinia-megarhynchos are connected. f. b and d. g. f is connected to Callobius-bennetti.60A phy logenetic  tr ee of C O I se quences. a. A ccipi ter fr ance
siae and accipit er gularis  b.  Nin ox-variegata a nd otus-sc ops. c. Falco tinnuculus and bubo-bubo are connected to the nodes. d. a and buteo-magnirostris and e. b and luscinia-megarhynchos are connected. f. b and d. g. f is connected to Callobius-bennetti. 5.11A p hylog
enetic tree o f C O I s eque nces . a. Acci piter frances ia e and a ccip iter g ularis b.  Nin ox-
variegata and o tus- scops. c. Falc o tin nuculus and  b ubo-bubo  a re con nect ed to the  no
des.  d. a and b uteo -m agniros tris and e. b and  luscin ia-m egarhync hos are connected. f. b and d. g. f is connected to Callobius-bennetti.72A ph ylog enetic t
ree of C O  I s equen ces. a. Ac cip iter francesia e an d acc ipiter 
gularis b.  Ninox-var ie gata and  ot us-scops.  c. F alco  tinnu cul us and  bubo-bub o ar e connec
ted to the  no des. d. a and buteo-magnirostris and e. b and luscinia-megarhynchos are connected. f. b and d. g. f is connected to Callobius-bennetti. 5.11 A phylogene tic tree of C O  I s equence s. a. Accipite r francesia
e and acci piter gul aris b. Ni nox- variegata  and otus -sc ops. c. Falco t innuculus 
and bubo-bu bo a re connect ed to th e n odes. d . a and bu teo-magni ros tris a nd e. b a
nd lu scinia-megar hynchos  are connected. f. b and d. g. f i s connecte d to Callob ius-
bennetti.

84
5
Graphical Representation of Sequences and Its Application
two-dimensional space. The only difference is the dimensions of point sets A and 
B increase to three. The 3D Yau-Hausdorff distance does not require the compared 
proteins to be aligned before calculation. It can measure the similarity/dissimilarity 
of protein structures without superimposing them together. The 3D Yau-Hausdorff 
is a natural generalization for the minimum one-dimensional Hausdorff distance and 
takes all possible translation and rotation into full consideration. The complexity of 
this new 3D metric is the same as that of the two-dimensional Yau-Hausdorff dis-
tance. It is lower than many other comparison algorithms by descending dimension 
in the calculation without losing information of structure. These advantages enable 
it to be a powerful tool for comparing protein structures. 
5.2 
Chaos Game Representation 
5.2.1 
Chaos Game Representation for DNA Sequences 
Chaos Game Representation (CGR) for DNA sequences is an iterative mapping 
technique that assigns each nucleotide in a DNA sequence to a respective position 
in the unit square left bracket 0 comma 1 right bracket times left bracket 0 comma 1 right bracket[0, 1] × [0, 1] [73]. CGR produces a one-to-one correspondence 
between sequences and graphs. Given the point of ith nucleotide in the CGR, we 
can reconstruct the sequence from position 1 to position i. Therefore, CGR is not 
only a nucleotide mapping but also a sequence mapping. Another advantage of CGR 
is that images obtained from parts of a genome present a similar structure as that of 
the whole genome, which allows us to compare the genomes that are not complete. 
Given the unit square in the Euclidean plane, four vertices in the unit square 
are assigned to the four nucleotides as upper A equals left parenthesis 0 comma 0 right parenthesisA = (0, 0), upper T equals left parenthesis 1 comma 0 right parenthesisT = (1, 0), upper C equals left parenthesis 0 comma 1 right parenthesisC = (0, 1) and 
upper G equals left parenthesis 1 comma 1 right parenthesisG = (1, 1). Starting with the center of the square left parenthesis one half comma one half right parenthesis( 1
2, 1
2), the CGR position of 
each nucleotide of the DNA sequence is calculated by moving a pointer to half the 
distance between the previous point and the corner square of the current nucleotide. 
The formal deﬁnition of CGR is given by an iterated function as in the equations 
below. For a DNA sequence s 1 s 2 ellipsis s Subscript n Baseline ellipsis s Subscript upper N Baselines1s2 . . . sn . . . sN, the corresponding CGR sequence 
upper X Subscript n Baseline equals left parenthesis x Subscript n Baseline comma y Subscript n Baseline right parenthesisXn = (xn, yn) is given by: 
upper X 0 equals left parenthesis one half comma one half right parenthesis comma upper X Subscript n Baseline equals one half left parenthesis upper X Subscript n minus 1 Baseline plus upper W Subscript n Baseline right parenthesis commaX0 = (1
2, 1
2), Xn = 1
2(Xn−1 + Wn),
(5.26) 
where upper W Subscript nWn is coordinates of the corners of the unit square upper A equals left parenthesis 0 comma 0 right parenthesisA = (0, 0), upper T equals left parenthesis 1 comma 0 right parenthesisT = (1, 0), 
upper C equals left parenthesis 0 comma 1 right parenthesisC = (0, 1), and upper G equals left parenthesis 1 comma 1 right parenthesisG = (1, 1) if s Subscript nsn is upper A comma upper T comma upper C comma upper GA, T, C, G, respectively. 
The unit square can be equally divided into four quadrants where points in the 
same quadrant have the same current nucleotide. Similarly, we can equally divide 
the square into 4 Superscript k4k pieces and points in each piece have the same k-mer string before 
the current stage. For example, we have s Subscript n Baseline equals upper Asn = A if upper X Subscript n Baseline element of left bracket 0 comma one half right bracket times left bracket 0 comma one half right bracketXn ∈[0, 1
2] × [0, 1
2] and we have 
s Subscript n Baseline equals s Subscript n minus 1 Baseline equals upper Asn = sn−1 = A if upper X Subscript n Baseline element of left bracket 0 comma one fourth right bracket times left bracket 0 comma one fourth right bracketXn ∈[0, 1
4] × [0, 1
4]. Therefore, each part of the CGR image 
has a direct biological meaning. It is not hard to see that subsequences of a gene or

5.2
Chaos Game Representation
85
1 
0.8 
0.6 
0.4 
0.2 
0.2
0.4
0.6
0.8
1 
0 
0 
–0.2 
–0.2 
–0.4 
–0.4 
–0.6 
–0.6 
–0.8 
–0.8 
–1 
–1 
Fig. 5.12 CGR of Human beta globin region on Chromosome 11 (HUMHBB) 
genome exhibit the main characteristics of the whole sequence since the piece that 
a point belongs to is determined mainly by its local information, thus it is useful 
to detect the features of the genome when only part of it is available. Figure 5.12 
shows the CGR image of Human beta globin region on Chromosome 11. 
The result of the CGR can be seen as a sequence of two-dimensional vectors 
or complex numbers. We can apply many mathematical or statistical techniques to 
further process the CGR result. 
We can use DFT to transform the CGR result into the frequency domain and then 
use the even scaling method in Sect. 4.4.1 to scale all sequences to the maximum 
length of the data set [50]. Then distance can be deﬁned naturally in Euclidean 
space and the phylogenetic tree representing evolutionary relations between the 
DNA sequences can be constructed. 
We have applied this method to the analysis of HRV (human rhinovirus) 
genomes, a virus associated with upper and lower respiratory diseases and a 
predominant cause of common cold and cold-like illnesses. These HRV genomes are 
categorized into three distinct genetic groups within the genus Enterovirus and the 
family Picornaviridae. Our dataset comprises three main groups: HRV-A, HRV-B, 
and HRV-C, totaling 113 genomes, along with three additional outgroup sequences 
of HEV-C. Although previous studies have accurately classiﬁed the genomes, the

86
5
Graphical Representation of Sequences and Its Application
computational time required was long due to the utilization of multiple sequence 
alignment for constructing the evolutionary tree. 
In this study, we apply the method above (CGR+DFT) to calculate the distance 
among HRV genomes and utilize UPGMA [60] to draw the phylogenetic tree. The 
resulting phylogenetic tree, displayed in Fig. 5.13, clearly delineates the three HRV 
groups and effectively distinguishes them from the outgroup HEV-C, all achieved 
in a mere 7 seconds of computation. To provide a comparison, we also utilized 
Clustal Omega for clustering the dataset [52]. While Clustal Omega successfully 
classiﬁed the genomes into the correct groups, the process consumed 19 minutes 
and 35 seconds to complete. (Computations are done on a PC with conﬁguration of 
Intel Core i7 CPU 2.40 GHz and 8 Gb RAM.) 
The CGR result can also be used as feature inputs for machine learning. For 
example, the artiﬁcial neural network can be applied to detect the acceptor and 
donor splice sites using CGR results. Computational experiments indicate that this 
approach gives good accuracy [74]. 
5.2.2 
Chaos Game Representation for Proteins 
In this part, we will introduce the Chaos Game Representation for proteins. It is 
much more complicated than that of DNA since the number of amino acids is 
much higher than that of nucleobases. A natural idea is to distribute 20 amino 
acids on the vertices of a regular 20-sided polygon [75]. However, this method 
cannot be used to demonstrate the similarity of homologous protein sequences with 
conservative substitutions. Another method ﬁrst divides amino acids into 4 types 
based on the polarity and then uses each vertex of the unit square to represent one 
type similar to the mapping in CGR for DNA [76]. However, the correspondence 
between sequences and representations is no longer one-to-one. 
In the following content, we will introduce a three-dimensional Chaos Game 
Representation for proteins that maps sequences into a regular dodecahedron [77]. 
The regular dodecahedron is one of the ﬁve regular polyhedrons in double struck upper R cubedR3 and its vertex 
number is 20. We distribute 20 amino acids on these vertices such that similar 
amino acids have shorter distances in the dodecahedron, which makes homologous 
proteins correspond to similar CGR images. The distribution arrangement is shown 
in Fig. 5.14. (In order to show the arrangement clearly, we unfold the dodecahedron 
into a planar graph.) 
The dodecahedron is inscribed to ball B, which is centered at (1,1,1) with radius 
1. For a protein sequence s 1 s 2 ellipsis s Subscript n Baseline ellipsis s Subscript upper N Baselines1s2 . . . sn . . . sN, the corresponding CGR sequence upper X Subscript n Baseline equals left parenthesis x Subscript n Baseline comma y Subscript n Baseline right parenthesisXn =
(xn, yn) is given by: 
upper X 0 equals left parenthesis 1 comma 1 comma 1 right parenthesis comma upper X Subscript n Baseline equals left parenthesis 1 minus u right parenthesis upper W Subscript n Baseline plus u upper X Subscript n minus 1 Baseline commaX0 = (1, 1, 1), Xn = (1 −u)Wn + uXn−1,
(5.27) 
where upper W Subscript nWn is the coordinates of the vertex that s Subscript nsn corresponds to and u is a parameter 
to be chosen.

5.2
Chaos Game Representation
87
Fig. 5.13 Phylogenetic trees 
of 113 HRV genomes and 3 
outgroup sequences. The ﬁrst 
graph is based on CGR and 
DFT. The second graph is 
based on Clustal Omega

88
5
Graphical Representation of Sequences and Its Application
Fig. 5.14 Distribution of 
amino acids on the vertices of 
a regular dodecahedron 
(extended image) 
Deﬁnition 5.1 For each amino acid s whose corresponding vertex is W, we deﬁne 
the ball centered at upper X Subscript s Baseline equals left parenthesis 1 minus u right parenthesis upper W plus u left parenthesis 1 comma 1 comma 1 right parenthesisXs =(1−u)W +u(1, 1, 1) with radius u to be the ball controlled 
by amino acid s, and is denoted by upper B Subscript sBs. 
Deﬁnition 5.2 For each dipeptide s 1 s 2s1s2 where s 1s1, s 2s2 correspond to vertices upper W 1W1, upper W 2W2, 
respectively, we deﬁne the ball centered at upper X Subscript s 1 s 2 Baseline equals left parenthesis 1 minus u right parenthesis upper W 2 plus u left parenthesis 1 minus u right parenthesis upper W 1 plus u squared left parenthesis 1 comma 1 comma 1 right parenthesisXs1s2 =(1 −u)W2 + u(1 −u)W1 +
u2(1, 1, 1) with radius u squaredu2 to be the ball controlled by dipeptide s 1 s 2s1s2 and is denoted 
by upper B Subscript s 1 s 2Bs1s2. 
We can prove the following theorem: 
Theorem 5.1 For an amino acid sequence of length N, if we choose 
u equals StartFraction StartRoot 5 EndRoot minus 1 Over StartRoot 5 EndRoot plus 2 StartRoot 3 EndRoot minus 1 EndFractionu
=
√
5−1
√
5+2
√
3−1, then the CGR images have the following properties: 
(1) 
.Xn ∈Bsn, for all 1 less than or equals n less than or equals upper N∀1 ≤n ≤N. 
(2) 
.Xn ∈Bsn−1sn, for all 2 less than or equals n less than or equals upper N∀2 ≤n ≤N. 
(3) 
.Bs1 ∩Bs2 = ∅if s 1 not equals s 2s1 /= s2. More precisely, if s 1s1 and s 2s2 are adjacent vertices, then 
upper B Subscript s 1Bs1 and upper B Subscript s 2Bs2 are tangent to each other. 
(4) 
. Bs is inscribed to B. 
(5) 
.Bs1s2 is inscribed to upper B Subscript s 2Bs2. 
(6) The number of amino acids s in a protein is equal to the number of points in upper B Subscript sBs. 
Besides, for a certain dipeptide s 1 s 2s1s2, the number of s 1 s 2s1s2 in a protein is equal to 
the number of points in upper B Subscript s 1 s 2Bs1s2. 
(7) 
.s1, . . . , sn is determined by upper X Subscript nXn, that is, given the coordinates of upper X Subscript nXn in a CGR 
image, we can obtain the ﬁrst n amino acids in the protein. Therefore, the three-
dimensional CGR for proteins is a one-to-one correspondence to sequences. 
Proof Let s comma s 1 comma s 2 comma s Subscript n Baselines, s1, s2, sn be three amino acids that correspond to upper W comma upper W 1 comma upper W 2 comma upper W Subscript n BaselineW, W1, W2, Wn, 
respectively, then 
StartLayout 1st Row 1st Column Blank 2nd Column StartAbsoluteValue upper X Subscript s Baseline minus upper X 0 EndAbsoluteValue equals left parenthesis 1 minus u right parenthesis StartAbsoluteValue upper W minus upper X 0 EndAbsoluteValue equals 1 minus u 2nd Row 1st Column Blank 2nd Column StartAbsoluteValue upper X Subscript s 1 s 2 Baseline minus upper X Subscript s 2 Baseline EndAbsoluteValue equals left parenthesis u minus u squared right parenthesis StartAbsoluteValue upper W 1 minus upper X 0 EndAbsoluteValue equals u minus u squared period EndLayout
|Xs −X0| = (1 −u)|W −X0| = 1 −u
|Xs1s2 −Xs2| = (u −u2)|W1 −X0| = u −u2.
(5.28)

5.2
Chaos Game Representation
89
Fig. 5.15 A sketch map  of  
the proof of Theorem 5.1 (3). 
In this ﬁgure, the vertices are 
denoted by omega 1 comma omega 2ω1, ω2
An ill ustr ation o f C  G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript sBsAn illustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript s 1 s 2Bs1s2 An illustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. 1 comma u comma u squared1, u, u2An  illustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript s Baseline comma upper B Subscript s 1 s 2 BaselineBs, Bs1s2 An i llustratio
n o f C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript s 2Bs2An  illus tration  of C G R ima
ge p roperties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. f left parenthesis upper X right parenthesis equals left parenthesis 1 minus u right parenthesis upper W Subscript n Baseline plus u upper Xf (X) = (1 −u)Wn + uX An il lust ratio n of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript s Sub Subscript nBsn An i llustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript sBs
An illustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript s s Sub Subscript nBssnAn  il lustra tio n of  C G  R im
age proper tie s. A  big sp her e in  the 3- D s cal e of 0.0  to 2.0 h as a ce nte r at X 0, 
and omega 1 a nd omega 2  ar e marke d on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. m equals StartFraction StartRoot 3 EndRoot Over 3 EndFraction left parenthesis StartRoot 5 EndRoot minus 1 right parenthesism =
√
3
3 (
√
5 −1)An  ill ustra tion  of C G R
 image  pr oper ties. A b ig sphere  in t he 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. alphaα An illustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. sine StartFraction alpha Over 2 EndFraction equals StartFraction m Over 2 EndFractionsin α
2 =
m
2 An  illustrat ion
 of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. 5.15An illustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript s 1Bs1 An illustration of C G R image properties. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2. upper B Subscript s 2Bs2 An i llustrat ion  of C  G R i mag e pr opert ies. A big sphere in the 3-D scale of 0.0 to 2.0 has a center at X 0, and omega 1 and omega 2 are marked on 2 small spheres within the big sphere. The distance between omega 1 and omega 2 is m and the distance from X 0 to omega 1 and omega 2 is 1 minus u making an angle alpha with both omega 1 and omega 2.
StartFraction u Over 1 minus u EndFraction equals sine StartFraction alpha Over 2 EndFraction
u
1 −u = sin α
2
(5.29) 
and therefore 
u equals StartFraction sine alpha divided by 2 Over sine alpha divided by 2 plus 1 EndFraction equals StartFraction StartRoot 5 EndRoot minus 1 Over StartRoot 5 EndRoot plus 2 StartRoot 3 EndRoot minus 1 EndFraction periodu =
sin α/2
sin α/2 + 1 =
√
5 −1
√
5 + 2
√
3 −1
.
(5.30) 
It proves (3).

90
5
Graphical Representation of Sequences and Its Application
For (6), since the balls controlled by each amino acid do not intersect with each 
other, and upper X Subscript nXn will be in the ball controlled by s Subscript nsn, thus the number of s in a protein 
is equal to the number of points in upper B Subscript sBs. Moreover, imitating the calculation in (3), 
we can prove that the balls controlled by different dipeptides will not intersect with 
each other as well. Therefore, the number of a dipeptide in a protein is equal to the 
number of points in the ball it controls. 
For the nth point upper X Subscript nXn in a CGR image, there exist a unique s such that upper X Subscript n Baseline element of upper B Subscript sXn ∈Bs. 
Therefore, the nth amino acid in the protein is s (corresponding to the vertex W) and 
with the formula upper X Subscript n Baseline equals left parenthesis 1 minus u right parenthesis upper W plus u upper X Subscript n minus 1Xn = (1 −u)W + uXn−1, we can determine the location of upper X Subscript n minus 1Xn−1
and the amino acid s Subscript n minus 1sn−1. Recursively, we can determine the ﬁrst n amino acids in a 
protein. 
Therefore, we take u equals StartFraction StartRoot 5 EndRoot minus 1 Over StartRoot 5 EndRoot plus 2 StartRoot 3 EndRoot minus 1 EndFractionu =
√
5−1
√
5+2
√
3−1 in this method. This method can transform a 
protein sequence into a sequence of points in double struck upper R cubedR3. We can use the same way as CGR 
for DNA to process the CGR result. 
There are also some techniques established especially for the CGR result for 
proteins. For example, motivated by the natural vector method which will be 
introduced in the next chapter, we can focus on the points in each ball controlled 
by dipeptides (or in each group of balls) and use their statistical information to form 
vectors of the same length, which are practical for protein classiﬁcation [77].

Chapter 6 
The Development and Applications of the 
Natural Vector Method 
In this chapter, we will introduce an effective alignment-free method called the 
natural vector method that can map biological sequences to vectors and discuss 
its properties and advantages. Then we will apply this method together to several 
biological problems. Finally, we show that the natural vector method can be 
generalized to produce some other alignment-free methods. 
6.1 
The Natural Vector Method for DNA Sequences 
The natural vector method uses moments of nucleotides’ distributions to represent 
the biological information in the sequence [78]. To be more speciﬁc, we combine the 
number, the average position, and the higher moments of each nucleotide to form a 
vector to represent the DNA sequence. Let n Subscript knk denote the number of the nucleotide 
k in the DNA sequence and let n be the length of the DNA sequence. s left bracket k right bracket left bracket i right brackets[k][i] is the 
position of the ith nucleotide k in the DNA sequence. Then the average position and 
the higher moments of nucleotide k can be deﬁned as follows: 
StartLayout 1st Row 1st Column mu Subscript k 2nd Column equals StartFraction sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts s left bracket k right bracket left bracket i right bracket Over n Subscript k Baseline EndFraction comma 2nd Row 1st Column upper D Subscript j Superscript k 2nd Column equals sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts StartFraction left parenthesis s left bracket k right bracket left bracket i right bracket minus mu Subscript k Baseline right parenthesis Superscript j Baseline Over n Subscript k Superscript j minus 1 Baseline n Superscript j minus 1 Baseline EndFraction comma j equals 2 comma 3 comma ellipsis comma EndLayout
μk =
nk

i=1
s[k][i]
nk
,
Dk
j =
nk

i=1
(s[k][i] −μk)j
nj−1
k
nj−1
,
j = 2, 3, . . . ,
(6.1) 
where k equals upper A comma upper C comma upper G comma upper Tk = A, C, G, T . The order m natural vector is deﬁned as 
left parenthesis n Subscript upper A Baseline comma n Subscript upper C Baseline comma n Subscript upper G Baseline comma n Subscript upper T Baseline comma mu Subscript upper A Baseline comma mu Subscript upper C Baseline comma mu Subscript upper G Baseline comma mu Subscript upper T Baseline comma upper D 2 Superscript upper A Baseline comma upper D 2 Superscript upper C Baseline comma upper D 2 Superscript upper G Baseline comma upper D 2 Superscript upper T Baseline comma ellipsis comma upper D Subscript m Superscript upper A Baseline comma upper D Subscript m Superscript upper C Baseline comma upper D Subscript m Superscript upper G Baseline comma upper D Subscript m Superscript upper T Baseline right parenthesis period(nA, nC, nG, nT , μA, μC, μG, μT , DA
2 , DC
2 , DG
2 , DT
2 , . . . , DA
m, DC
m, DG
m, DT
m).
(6.2) 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_6
91

92
6
The Development and Applications of the Natural Vector Method
In real applications, n Subscript k Baseline greater than 0nk > 0 for each k in most cases so mu Subscript kμk and upper D Subscript j Superscript kDk
j are well-deﬁned. 
However, in order to make our deﬁnition more rigorous, we further deﬁne mu Subscript k Baseline equals upper D 2 Superscript k Baseline equals ellipsis equals upper D Subscript j Superscript k Baseline equals ellipsis equals 0μk =
Dk
2 = . . . = Dk
j = . . . = 0 when n Subscript k Baseline equals 0nk = 0. 
.Dk
j describes the jth normalized central moment of the distribution of the 
nucleotide k where the normalization factor is chosen to ensure that upper D Subscript j Superscript kDk
j tends to 
0 when j right arrow normal infinityj →∞, which will be discussed later. We start with j equals 2j = 2 since upper D 1 Superscript k Baseline equals 0Dk
1 = 0. 
We take a short DNA sequence ACGGT as an example. We have n Subscript upper A Baseline equals n Subscript upper C Baseline equals n Subscript upper T Baseline equals 1 comma n Subscript upper G Baseline equals 2nA = nC =
nT = 1, nG = 2 by counting the nucleotides. The average positions are 
StartLayout 1st Row 1st Column mu Subscript upper A 2nd Column equals 1 comma 2nd Row 1st Column mu Subscript upper C 2nd Column equals 2 comma 3rd Row 1st Column mu Subscript upper G 2nd Column equals 3.5 comma 4th Row 1st Column mu Subscript upper T 2nd Column equals 5 comma EndLayout
μA = 1,
μC = 2,
μG = 3.5,
μT = 5,
and the second central moments are 
StartLayout 1st Row 1st Column upper D 2 Superscript upper A 2nd Column equals 0 comma 2nd Row 1st Column upper D 2 Superscript upper C 2nd Column equals 0 comma 3rd Row 1st Column upper D 2 Superscript upper G 2nd Column equals StartFraction left parenthesis 3 minus 3.5 right parenthesis squared plus left parenthesis 4 minus 3.5 right parenthesis squared Over 2 times 5 EndFraction equals one twentieth comma 4th Row 1st Column upper D 2 Superscript upper T 2nd Column equals 0 period EndLayout
DA
2 = 0,
DC
2 = 0,
DG
2 = (3 −3.5)2 + (4 −3.5)2
2 × 5
= 1
20,
DT
2 = 0.
Therefore, the order 2 natural vector of the sequence ACGGT is 
left parenthesis 1 comma 1 comma 2 comma 1 comma 1 comma 2 comma 3.5 comma 5 comma 0 comma 0 comma one twentieth comma 0 right parenthesis period(1, 1, 2, 1, 1, 2, 3.5, 5, 0, 0, 1
20, 0).
It is worth noticing that the natural vector method for DNA can be applied to 
RNA if simply replacing the base T with U. So in the following content, we do not 
distinguish the genetic material. 
We have already obtained a good numerical characterization to represent a DNA 
sequence. Now we will use this tool to construct a natural vector for genomes. It 
is known that the structure of a genome can be very complicated. It may be single-
stranded or double-stranded, and in a linear, circular, or segmented structure. Thus, 
we should consider the different structures when constructing the natural vector for 
genomes. 
For the simplest genome structures, linear single-strand forms, we can treat them 
as linear DNA sequences. That is, every genome corresponds to a general DNA 
sequence. Thus, we can construct the natural vector for genomes. The order m 
is chosen depending on the concrete conditions. In general, m equals 2m = 2 is enough to 
make the result stable, which means that we transfer a DNA sequence into a 12-

6.2
The Properties and Advantages of the Natural Vector Method
93
dimensional vector. Thus, using the Euclidean distance between each pair of vectors 
for comparison, we can perform phylogenetic and clustering analyses for genome 
sequences. 
In the case of circular single-strand genomes, constructing the natural vector 
presents additional complexity due to the lack of knowledge about the starting 
point in the circular DNA sequence. We here propose a method to address this 
problem. We can consider every point as a potential starting point in the circular 
sequence with a length of n. This approach generates n linear single-strand genome 
sequences. For each linear single-strand genome, we compute its corresponding 
natural vector. To obtain a normalized vector, we calculate the average of these 
individual natural vectors. For double-stranded genomes, it is important to note that 
the natural vector of the reverse complementary sequence is distinct from that of the 
original sequence. In general, we treat double-stranded genomes as two separate 
single-stranded genomes. Applying the method outlined above (either linear or 
circular), we derive two natural vectors for these single-stranded sequences. Sub-
sequently, we calculate the average of these two vectors to obtain a comprehensive 
natural vector representation. In the case of multiple-segmented sequences, we treat 
each segment as a sequence and transform the virus into a set of points, which will 
be further discussed later. 
6.2 
The Properties and Advantages of the Natural Vector 
Method 
In this part, we will ﬁrst introduce two important properties of natural vectors, 
which are the one-to-one correspondence and the convergence to 0 for high-order 
moments. Then we will discuss the advantages of the natural vector method. 
6.2.1 
The One-to-One Correspondence Between DNA 
Sequence and Its Natural Vector 
We ﬁrst show that the correspondence between a DNA sequence and its natural 
vector is one-to-one when the order is high enough. It is easy to see that we can 
calculate the natural vector given the DNA sequence. The non-trivial part of the 
correspondence is that we can calculate the DNA sequence given its natural vector 
with a sufﬁciently high order. To be more speciﬁc, we have the following theorem. 
Theorem 6.1 Suppose a DNA sequence contains n nucleotides where the number 
of four nucleotides are n Subscript upper A Baseline comma n Subscript upper T Baseline comma n Subscript upper C Baseline comma n Subscript upper G BaselinenA, nT , nC, nG, respectively. Then the correspondence 
between the DNA sequence and its order M natural vector is one-to-one where 
upper M equals max left brace n Subscript upper A Baseline comma n Subscript upper T Baseline comma n Subscript upper C Baseline comma n Subscript upper G Baseline right braceM = max{nA, nT , nC, nG}.

94
6
The Development and Applications of the Natural Vector Method
Proof In fact, we can recover the DNA sequence given the following truncation of 
its order M natural vector: 
StartLayout 1st Row 1st Column Blank 2nd Column left parenthesis n Subscript upper A Baseline comma mu Subscript upper A Baseline comma n Subscript upper C Baseline comma mu Subscript upper C Baseline comma n Subscript upper G Baseline comma mu Subscript upper G Baseline comma n Subscript upper T Baseline comma mu Subscript upper T Baseline comma upper D 2 Superscript upper A Baseline comma ellipsis comma upper D Subscript n Sub Subscript upper A Subscript Superscript upper A Baseline comma upper D 2 Superscript upper C Baseline comma ellipsis comma upper D Subscript n Sub Subscript upper C Subscript Superscript upper C Baseline comma upper D 2 Superscript upper G Baseline comma 2nd Row 1st Column Blank 2nd Column ellipsis comma upper D Subscript n Sub Subscript upper G Subscript Superscript upper G Baseline comma upper D 2 Superscript upper T Baseline comma ellipsis comma upper D Subscript n Sub Subscript upper T Subscript Superscript upper T Baseline right parenthesis period EndLayout(nA, μA, nC, μC, nG, μG, nT , μT , DA
2 , . . . , DA
nA, DC
2 , . . . , DC
nC, DG
2 ,
. . . , DG
nG, DT
2 , . . . , DT
nT ).
Let z Subscript left bracket k right bracket i Baseline equals s left bracket k right bracket left bracket i right bracket minus mu Subscript kz[k]i = s[k][i] −μk, then the normalized central moments can be simpliﬁed 
as: 
upper D Subscript j Superscript k Baseline equals sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts StartFraction z Subscript left bracket k right bracket i Superscript j Baseline Over n Subscript k Superscript j minus 1 Baseline n Superscript j minus 1 Baseline EndFraction comma j equals 2 comma 3 comma ellipsis comma n Subscript k Baseline periodDk
j =
nk

i=1
zj
[k]i
nj−1
k
nj−1 ,
j = 2, 3, . . . , nk.
(6.3) 
Then we have 
StartLayout Enlarged left brace 1st Row 1st Column z Subscript left bracket k right bracket 1 Baseline plus z Subscript left bracket k right bracket 2 Baseline plus midline horizontal ellipsis plus z Subscript left bracket k right bracket n Sub Subscript k 2nd Column equals 0 2nd Row 1st Column z Subscript left bracket k right bracket 1 Superscript 2 Baseline plus z Subscript left bracket k right bracket 2 Superscript 2 Baseline plus midline horizontal ellipsis plus z Subscript left bracket k right bracket n Sub Subscript k Superscript 2 2nd Column equals upper D 2 Superscript k Baseline n Subscript k Baseline n 3rd Row 1st Column midline horizontal ellipsis 2nd Column Blank 4th Row 1st Column z Subscript left bracket k right bracket 1 Superscript n Super Subscript k Baseline plus z Subscript left bracket k right bracket 2 Superscript n Super Subscript k Baseline plus midline horizontal ellipsis plus z Subscript left bracket k right bracket n Sub Subscript k Superscript n Super Subscript k 2nd Column equals upper D Subscript n Sub Subscript k Subscript Superscript k Baseline n Subscript k Baseline Superscript n Super Subscript k Superscript minus 1 Baseline n Superscript n Super Subscript k Superscript minus 1 Baseline period EndLayout
⎧
⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎩
z[k]1 + z[k]2 + · · · + z[k]nk
= 0
z2
[k]1 + z2
[k]2 + · · · + z2
[k]nk
= Dk
2nkn
· · ·
znk
[k]1 + znk
[k]2 + · · · + znk
[k]nk
= Dk
nknknk−1nnk−1.
(6.4) 
We take k equals upper Ak = A as an example and denote the right-hand sides by delta 1 comma ellipsis comma delta Subscript n Sub Subscript upper A Subscript Baselineδ1, . . . , δnA. Then 
the equations can be rewritten as 
StartLayout Enlarged left brace 1st Row 1st Column z 1 plus z 2 plus midline horizontal ellipsis plus z Subscript n Sub Subscript upper A 2nd Column equals delta 1 2nd Row 1st Column z 1 squared plus z 2 squared plus midline horizontal ellipsis plus z Subscript n Sub Subscript upper A Superscript 2 2nd Column equals delta 2 3rd Row 1st Column midline horizontal ellipsis 2nd Column Blank 4th Row 1st Column z 1 Superscript n Super Subscript upper A Baseline plus z 2 Superscript n Super Subscript upper A Baseline plus midline horizontal ellipsis plus z Subscript n Sub Subscript upper A Superscript n Super Subscript upper A 2nd Column equals delta Subscript n Sub Subscript upper A Subscript Baseline period EndLayout
⎧
⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎩
z1 + z2 + · · · + znA
= δ1
z2
1 + z2
2 + · · · + z2
nA
= δ2
· · ·
znA
1
+ znA
2
+ · · · + znA
nA
= δnA.
(6.5) 
z 1 comma z 2 comma ellipsis comma z Subscript n Sub Subscript upper A Subscript Baselinez1, z2, . . . , znA are roots of a symmetric polynomial 
left parenthesis z minus z 1 right parenthesis left parenthesis z minus z 2 right parenthesis midline horizontal ellipsis left parenthesis z minus z Subscript n Sub Subscript upper A Subscript Baseline right parenthesis equals a 0 plus a 1 z plus a 2 z squared plus midline horizontal ellipsis plus a Subscript n Sub Subscript upper A Subscript Baseline z Superscript n Super Subscript upper A Superscript Baseline period(z −z1)(z −z2) · · · (z −znA) = a0 + a1z + a2z2 + · · · + anAznA.
(6.6) 
z 1 comma ellipsis comma z Subscript n Sub Subscript upper A Subscript Baselinez1, . . . , znA can be easily solved if we can calculate a 0 comma ellipsis comma a Subscript n Sub Subscript upper A Subscript Baselinea0, . . . , anA based on 
delta 1 comma ellipsis comma delta Subscript n Sub Subscript upper A Subscript Baselineδ1, . . . , δnA. The key method applied is the famous Newton’s identities [80]. Let 
p Subscript d Baseline left parenthesis d equals 1 comma 2 comma ellipsis comma n Subscript upper A Baseline right parenthesispd (d = 1, 2, . . . , nA) be the elementary symmetric polynomials in z 1 comma z 2 comma ellipsis comma z Subscript n Sub Subscript upper A Subscript Baselinez1, z2, . . . , znA, 
i.e., 
p 1 equals sigma summation Underscript i Overscript n Subscript upper A Baseline Endscripts z Subscript i Baseline comma p 2 equals sigma summation Underscript i less than j Endscripts z Subscript i Baseline z Subscript j Baseline comma p 3 equals sigma summation Underscript i less than j less than l Endscripts z Subscript i Baseline z Subscript j Baseline z Subscript l Baseline comma ellipsis comma p Subscript n Sub Subscript upper A Subscript Baseline equals z 1 z 2 midline horizontal ellipsis z Subscript n Sub Subscript upper A Subscript Baseline periodp1 =
nA

i
zi, p2 =

i<j
zizj, p3 =

i<j<l
zizjzl, . . . , pnA = z1z2 · · · znA.
(6.7) 
Then p 1 equals minus a Subscript n Sub Subscript upper A Subscript minus 1 Baseline comma p 2 equals a Subscript n Sub Subscript upper A Subscript minus 2 Baseline comma ellipsis comma p Subscript n Sub Subscript upper A Subscript Baseline equals left parenthesis negative 1 right parenthesis Superscript n Super Subscript upper A Superscript Baseline a 0p1 = −anA−1, p2 = anA−2, . . . , pnA = (−1)nAa0. 
The Newton’s identities claim that:

6.2
The Properties and Advantages of the Natural Vector Method
95
delta Subscript d Baseline minus p 1 delta Subscript d minus 1 Baseline plus midline horizontal ellipsis plus left parenthesis negative 1 right parenthesis Superscript d minus 1 Baseline p Subscript d minus 1 Baseline delta 1 plus left parenthesis negative 1 right parenthesis Superscript d Baseline p Subscript d Baseline equals 0 commaδd −p1δd−1 + · · · + (−1)d−1pd−1δ1 + (−1)dpd = 0,
(6.8) 
where d equals 1 comma 2 comma ellipsis comma n Subscript upper A Baselined = 1, 2, . . . , nA and p Subscript dpd is the elementary symmetric polynomials in 
z 1 comma z 2 comma ellipsis comma z Subscript n Sub Subscript upper A Subscript Baselinez1, z2, . . . , znA. Then a Subscript iai can be obtained by delta Subscript jδj as shown below: 
StartLayout Enlarged left brace 1st Row a Subscript n Sub Subscript upper A Subscript Baseline equals 1 2nd Row a Subscript n Sub Subscript upper A Subscript minus 1 Baseline equals left parenthesis negative 1 right parenthesis delta 1 3rd Row a Subscript n Sub Subscript upper A Subscript minus 2 Baseline equals one half left parenthesis delta 1 squared minus delta 2 right parenthesis 4th Row a Subscript n Sub Subscript upper A Subscript minus 3 Baseline equals left parenthesis negative 1 right parenthesis cubed one sixth left parenthesis delta 1 cubed minus 3 delta 1 delta 2 plus 2 delta 3 right parenthesis 5th Row a Subscript n Sub Subscript upper A Subscript minus 4 Baseline equals one twenty fourth left parenthesis delta 1 Superscript 4 Baseline minus 6 delta 1 squared delta 2 plus 3 delta 2 squared plus 8 delta 1 delta 3 minus 6 delta 4 right parenthesis 6th Row midline horizontal ellipsis midline horizontal ellipsis midline horizontal ellipsis EndLayout period
⎧
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩
anA = 1
anA−1 = (−1)δ1
anA−2 = 1
2(δ2
1 −δ2)
anA−3 = (−1)3 1
6(δ3
1 −3δ1δ2 + 2δ3)
anA−4 = 1
24(δ4
1 −6δ2
1δ2 + 3δ2
2 + 8δ1δ3 −6δ4)
· · ·
· · ·
· · ·
.
(6.9) 
Given the order M natural vector, delta 1 comma ellipsis comma delta Subscript n Sub Subscript upper A Subscript Baselineδ1, . . . , δnA are known, so we can solve 
a 1 comma ellipsis comma a Subscript n Sub Subscript upper A Subscript Baselinea1, . . . , anA. By enumerating l minus mu Subscript upper Al −μA where l equals 1 comma ellipsis comma nl = 1, . . . , n, we can solve all solutions 
of the polynomial a 0 plus a 1 z plus a 2 z squared plus midline horizontal ellipsis plus a Subscript n Sub Subscript upper A Baseline z Superscript n Super Subscript upper Aa0+a1z+a2z2+· · ·+anAznA. Since z Subscript izi increases when i increases, 
we can calculate each z Subscript izi and therefore each s left bracket upper A right bracket left bracket i right brackets[A][i]. 
Similarly, we can ﬁnd all s left bracket k right bracket left bracket i right brackets[k][i] for k equals upper C comma upper G comma upper Tk = C, G, T , respectively. Therefore, the 
unique corresponding DNA sequence can be recovered based on all s left bracket k right bracket left bracket i right brackets[k][i], k equals upper A comma upper C comma upper G comma upper Tk =
A, C, G, T . 
The proof above shows that the one-to-one correspondence exists rigorously 
when the order is sufﬁciently high, while in applications we can ﬁnd that the one-
to-one correspondence is still valid when we consider natural vectors with order 2 
for most cases. 
6.2.2 
The Convergence to 0 for High-Order Moments 
For a natural vector, the high-order moment converges to 0. The proof is as follows: 
StartLayout 1st Row 1st Column upper D Subscript j Superscript k Baseline 2nd Column equals sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts StartFraction left parenthesis s left bracket k right bracket left bracket j right bracket minus mu Subscript k Baseline right parenthesis Superscript j Baseline Over n Subscript k Superscript j minus 1 Baseline n Superscript j minus 1 Baseline EndFraction less than or equals sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts StartFraction max Underscript i Endscripts StartAbsoluteValue s left bracket k right bracket left bracket i right bracket minus mu Subscript k Baseline EndAbsoluteValue Superscript j Baseline Over n Subscript k Superscript j minus 1 Baseline n Superscript j minus 1 Baseline EndFraction 2nd Row 1st Column Blank 2nd Column equals StartFraction max Underscript i Endscripts StartAbsoluteValue s left bracket k right bracket left bracket i right bracket minus mu Subscript k Baseline EndAbsoluteValue Superscript j Baseline Over n Subscript k Superscript j minus 2 Baseline n Superscript j minus 1 Baseline EndFraction less than or equals StartFraction n Superscript j Baseline Over n Subscript k Superscript j minus 2 Baseline n Superscript j minus 1 Baseline EndFraction equals StartFraction n Over n Subscript k Superscript j minus 2 Baseline EndFraction EndLayout period
Dk
j =
nk

i=1
(s[k][j] −μk)j
nj−1
k
nj−1
≤
nk

i=1
max
i
|s[k][i] −μk|j
nj−1
k
nj−1
=
max
i
|s[k][i] −μk|j
nj−2
k
nj−1
≤
nj
nj−2
k
nj−1 =
n
nj−2
k
.
(6.10) 
When n Subscript k Baseline greater than or equals 2nk ≥2, the convergence is easy to check. If n Subscript k Baseline equals 0nk = 0 then all moments 
are deﬁned to be 0, and if n Subscript k Baseline equals 1nk = 1 then upper D Subscript j Superscript k Baseline equals 0Dk
j = 0. Therefore, we have proved the 
convergence.

96
6
The Development and Applications of the Natural Vector Method
From the viewpoint of probability, suppose that the expectation value of any 
nucleic base is n Subscript k Baseline equals StartFraction n Over 4 EndFractionnk = n
4 (uniform distribution) for a sequence with a given length n, 
we can have an estimation for the upper bound: 
limit Underscript j Endscripts StartFraction n Over n Subscript k Superscript j minus 2 Baseline EndFraction almost equals limit Underscript j Endscripts StartFraction n Over left parenthesis n divided by 4 right parenthesis Superscript j minus 2 Baseline EndFraction equals limit Underscript j Endscripts StartFraction n dot 4 Superscript j minus 2 Baseline Over n Superscript j minus 2 Baseline EndFraction equals limit Underscript j Endscripts StartFraction 4 Superscript j minus 2 Baseline Over n Superscript j minus 3 Baseline EndFraction period lim
j
n
nj−2
k
≈lim
j
n
(n/4)j−2 = lim
j
n · 4j−2
nj−2
= lim
j
4j−2
nj−3 .
(6.11) 
Sometimes, n Subscript knk may be far from StartFraction n Over 4 EndFractionn
4. For example, the GC content, which is the 
percentage of nitrogenous bases on a DNA molecule which are either guanine or 
cytosine, can be extremely low for some species such as Plasmodium falciparum 
[79]. Even in this case, upper D Subscript j Superscript kDk
j still converges to 0 at a high speed. 
The convergence for high-order moments implies that it is not necessary to 
involve moments of a too high order when calculating distance since high-order 
moments do not play important roles. 
6.2.3 
Advantages 
There are four major advantages of the natural vector method [78]. 
(1) The natural vector method is much faster than alignment methods and is easier 
to manipulate. 
(2) Once a genome space has been constructed, it can be stored in a database. There 
is no need to reconstruct the genome space for any subsequent application, 
whereas in multiple alignment methods, realignment is needed for adding new 
sequences. 
(3) One can perform the global comparison of all genomes simultaneously. 
(4) The natural vector method is not based on any invented evolutionary model, 
which makes the result more stable and natural. 
6.3 
The Natural Vector Method for Protein Sequences 
We have mentioned that the natural vector method for DNA can be generalized 
to RNA without difﬁculty. Similarly, we can generalize this method to protein 
sequences [94]. The protein sequences are composed of 20 types of amino acids 
(denoted by A, R, N, D, C, E, Q, G, H, I, L, K, M, F, P, S, T, W, Y, and V, 
respectively). So the order m natural vector of a protein sequence can be deﬁned 
by 
left parenthesis n Subscript upper A Baseline comma n Subscript upper R Baseline comma ellipsis comma n Subscript upper V Baseline comma mu Subscript upper A Baseline comma mu Subscript upper R Baseline comma ellipsis comma mu Subscript upper V Baseline comma upper D 2 Superscript upper A Baseline comma upper D 2 Superscript upper R Baseline comma ellipsis comma upper D 2 Superscript upper V Baseline comma ellipsis comma upper D Subscript m Superscript upper A Baseline comma upper D Subscript m Superscript upper R Baseline comma ellipsis comma upper D Subscript m Superscript upper V Baseline right parenthesis comma(nA, nR, . . . , nV , μA, μR, . . . , μV , DA
2 , DR
2 , . . . , DV
2 , . . . , DA
m, DR
m, . . . , DV
m),
(6.12)

6.4
The Natural Graph Method
97
which belongs to upper R Superscript 20 m plus 20R20m+20. (For most cases, m equals 2m = 2 is good enough, leading to 
60-dimensional vectors.) 
The properties and advantages mentioned in the previous section are also true 
for this generalized version. The proof of the one-to-one correspondence and the 
convergence to 0 for high-order moments are the same. 
6.4 
The Natural Graph Method 
In previous sections, we employed the phylogenetic tree as a way to depict the 
relationships among genomes. In this section, we will introduce the natural graph 
method, a more intuitive graphical representation approach that offers improved 
visualization of the relationships among genomes [81]. 
We can compute a distance matrix by calculating the Euclidean distance 
between every pair of natural vectors, essentially treating these vectors as points. 
Subsequently, we can generate a natural graph by following these steps: 
(1) For each point A, ﬁnd the closest point(s) B (B1, B2, . . . , Bk) to A. Then 
connect A to B (B1, B2, . . . , Bk) with a directed line(s) from A to B. If both A 
and B are closest to each other, then connect them using a bi-directional line. 
(2) We then get many connected components, called level-1 graphs, after step (1). 
We compute the distance matrix for these connected components. The distance 
between two components is deﬁned as the minimum of all distances between 
an element in one component and an element in another component. We then 
obtain a new distance matrix, in which the elements are the connected graphs 
obtained in step (1). 
(3) Repeat the process in steps (1) and (2) to obtain higher-level graphs until we 
get one connected component for all elements, which is the ﬁnal graphical 
representation. 
We strengthen that other distance matrices can be used in this algorithm while 
we use the distance matrix produced by the natural vector method since it is a good 
metric for DNA or protein sequences. 
Finally, we take an example to show how this method works. In this example, 
we only consider the closest point. Our goal is to visualize the distance matrix of 
10 elements in Table 6.1. We illustrate the graph construction process in Fig. 6.1. 
First, we ﬁnd the closest element for each element and connect them as shown 
in Fig. 6.1a. Then we combine the level-1 connected components to get level-2 
components, graph 1 and graph 2, as shown in Fig. 6.1b. We check the minimum 
distance between these two graphs and get the new distance matrix in Table 6.2. 
The minimum distance 18 is obtained between element A in graph 1 and element G 
in graph 2. So, we connect these two elements to get a connected graph as shown in 
Fig. 6.1c. We use the directed red line to mark this connection, indicating 2nd level

98
6
The Development and Applications of the Natural Vector Method
Table 6.1 The distance 
matrix of 10 elements 
A 
B 
C 
D 
E 
F
G 
H 
I
J 
A 
0 
B 
9
0 
C 
13 
4
0 
D 
23 
21 
23 
0 
E 
27 
34 
38 
30 
0 
F 
26 
36 
39 
39 
12 
0 
G 
18 
26 
30 
25 
12 
16 
0 
H 
19 
8
9
18 
34 
25 
25 
0 
I 
20 
14 
11 
30 
43 
44 
35 
12 
0 
J 
28 
21 
20 
18 
20 
47 
37 
17 
20 
0 
connection. Clearly, this directional graphical representation uniquely illustrates the 
1st-nearest-neighbor relationships. 
The direction in the graph shows the closest element to each element based on 
their biological distances. For example, given a virus A, virologists would like to 
know which virus B is closest to A. An arrow from A to B in the graph represents 
this relation. Here we need to point out that the natural graph is not necessarily a 
tree. As in the example, a cycle may exist in the graphical representation which may 
show interesting biological information. 
6.5 
Applications 
6.5.1 
12-Dimensional Viral Genome Space 
The natural vector method can help classify genomes and let us know the rela-
tionship among genomes. More speciﬁcally, this method is able to transform all 
genomes into points in a 12-dimensional genome space and many mathematical 
and statistical techniques can be applied to study these points. We take the viral 
genome sequences as an example to show how a 12-dimensional genome space is 
established. We will ﬁrst introduce the genome space for only single-segmented 
viruses, and then we will add the multiple-segmented viruses. 
6.5.1.1 
The Genome Space for Only Single-Segmented Viruses 
In [81], 2044 reference sequences of single-segmented viruses are considered to 
establish a genome space. All sequences are transformed into 12-dimensional 
(order 2) natural vectors. A problem we may face in real applications is that the 
sequencing data can be ambiguous. As is shown in Table 1.2, a single character 
may represent more than one nucleotide. For example, the letter R refers to either

6.5
Applications
99
A 
B 
C 
D 
E 
H 
F 
F 
G 
H 
I 
J 
I
C
 B
 
H
J
 
D 
G 
11
4
9 
17 
18
18 
18
12
12 
E 
I
C
 
H
J 
D 
B
A
 
G
 
E
 F
 
F 
Graph 1 
Graph 2 
A 
B 
C 
B 
J 
G 
E 
E 
B 
C 
H 
a 
b 
c 
Fig. 6.1 The construction of the natural graph 
A or G. In order to deal with this problem, we ﬁrst introduce an equivalent 
deﬁnition of natural vectors. Let upper S equals left parenthesis s 1 comma s 2 comma ellipsis comma s Subscript n Baseline right parenthesisS = (s1, s2, . . . , sn) be a nucleotide sequence of 
length n where s Subscript i Baseline element of StartSet upper A comma upper C comma upper G comma upper T EndSetsi ∈{A, C, G, T }, i equals 1 comma 2 comma ellipsis comma ni = 1, 2, . . . , n. For k equals upper A comma upper C comma upper G comma upper Tk = A, C, G, T , deﬁne 
w Subscript k Baseline left parenthesis dot right parenthesis colon StartSet upper A comma upper C comma upper G comma upper T EndSet right arrow StartSet 0 comma 1 EndSetwk(·) : {A, C, G, T } →{0, 1} such that w Subscript k Baseline left parenthesis s right parenthesis equals 1wk(s) = 1 if s equals ks = k and w Subscript k Baseline left parenthesis s right parenthesis equals 0wk(s) = 0
otherwise.

100
6
The Development and Applications of the Natural Vector Method
Table 6.2 The distance 
matrix of 2 graphs obtained 
from Fig. 6.1b 
Graph 1 Graph 2 
Graph 1 0 
Graph 2 18
0 
(1) Let n Subscript k Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts w Subscript k Baseline left parenthesis s Subscript i Baseline right parenthesisnk =
n
i=1
wk(si) denote the number of letter k in S. 
(2) Let mu Subscript k Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts i dot StartFraction w Subscript k Baseline left parenthesis s Subscript i Baseline right parenthesis Over n Subscript k Baseline EndFractionμk =
n
i=1
i · wk(si)
nk
be the mean position of letter k. 
(3) For j equals 2 comma 3 comma ellipsisj = 2, 3, . . . , let upper D Subscript j Superscript k Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts StartFraction left parenthesis i minus mu Subscript k Baseline right parenthesis Superscript j Baseline w Subscript k Baseline left parenthesis s Subscript i Baseline right parenthesis Over n Subscript k Superscript j minus 1 Baseline n Superscript j minus 1 Baseline EndFractionDk
j =
n
i=1
(i −μk)jwk(si)
nj−1
k
nj−1
. 
The order m natural vector of a nucleotide sequence S is deﬁned by 
left parenthesis n Subscript upper A Baseline comma n Subscript upper C Baseline comma n Subscript upper G Baseline comma n Subscript upper T Baseline comma mu Subscript upper A Baseline comma mu Subscript upper C Baseline comma mu Subscript upper G Baseline comma mu Subscript upper T Baseline comma upper D 2 Superscript upper A Baseline comma upper D 2 Superscript upper C Baseline comma upper D 2 Superscript upper G Baseline comma upper D 2 Superscript upper T Baseline comma ellipsis comma upper D Subscript m Superscript upper A Baseline comma upper D Subscript m Superscript upper C Baseline comma upper D Subscript m Superscript upper G Baseline comma upper D Subscript m Superscript upper T Baseline right parenthesis period(nA, nC, nG, nT , μA, μC, μG, μT , DA
2 , DC
2 , DG
2 , DT
2 , . . . , DA
m, DC
m, DG
m, DT
m).
(6.13) 
The natural vector deﬁned here is exactly the same as that deﬁned previously but 
it is easier to be generalized when s Subscript isi is not in the range of StartSet upper A comma upper C comma upper G comma upper T EndSet{A, C, G, T }. To be more  
speciﬁc, for k equalsk = A, C, G, and T , let the weight w Subscript k Baseline left parenthesis s Subscript i Baseline right parenthesiswk(si) be the expected count of letter 
k at position i. For example, R refers to either A or G, then w Subscript upper A Baseline left parenthesis upper R right parenthesis equals w Subscript upper G Baseline left parenthesis upper R right parenthesis equals one halfwA(R) = wG(R) = 1
2
and w Subscript upper C Baseline left parenthesis upper R right parenthesis equals w Subscript upper T Baseline left parenthesis upper R right parenthesis equals 0wC(R) = wT (R) = 0. As another example, N refers to A, T , C, or  G, then 
w Subscript upper A Baseline left parenthesis upper N right parenthesis equals w Subscript upper C Baseline left parenthesis upper N right parenthesis equals w Subscript upper G Baseline left parenthesis upper N right parenthesis equals w Subscript upper T Baseline left parenthesis upper N right parenthesis equals one fourthwA(N) = wC(N) = wG(N) = wT (N) = 1
4. By the introduction of weight, we can 
deal with the problem of ambiguous sites and successfully transform viral genomes 
into 12-dimensional vectors. 
For each virus, we can ﬁnd its nearest neighbor in the 12-dimensional natural 
vector genome space and check whether its label matches that of its nearest 
neighbor. If we have a complete genome space that contains all of the viruses it 
is reasonable to assume any virus must have a neighbor sharing the same label. In 
reality, even though the genome space may be incomplete, we can still predict the 
label of a sequence by this strategy. There are many types of labels that can be 
chosen. The Baltimore class, the family, the subfamily, and the genus of a virus are 
examples of the label. 
We ﬁrst take the Baltimore class as the label. The Baltimore classiﬁcation 
system categorizes viruses into seven classes based on the type of genome molecule 
and replication strategy [82–84]. These classes are double-stranded DNA viruses, 
single-stranded DNA viruses, double-stranded RNA viruses, positive-sense single-
stranded RNA viruses, negative-sense single-stranded RNA viruses, single-stranded 
RNA reverse transcriptase viruses, and double-stranded DNA reverse transcriptase 
viruses, respectively. (Labels range from I to VII.) 
With viral genome data and topological characteristics (DNA/RNA, 
single/double-stranded, linear/circular), natural vectors can be used to predict 
Baltimore class labels. Single-stranded DNA or double-stranded RNA sequences 
belong to class II or III, respectively. Double-stranded DNA sequences may be 
class I or VII, while single-stranded RNA sequences could be class IV, V, or

6.5
Applications
101
VI. Inconsistency, based on the percentage of viruses with inconsistent nearest 
neighbor labels, gauges method effectiveness. In class I and VII, linear viruses have 
0% inconsistency, whereas circular viruses exhibit 1.36%. In classes IV, V, and 
VI, linear viruses demonstrate 6.55% inconsistency, with circular viruses at 0%. 
Overall, inconsistency stands at 3.18%. 
Sparsity of the reference dataset leads to inconsistency, as distant neighbors 
become unreliable due to potential true neighbor absence. This explains incon-
sistency distribution. To mitigate this, we determine the 75% quantile of nearest 
distances within each class and set a 75%-cutoff for predictions. (We make the 
prediction only when the nearest distance is less than the cutoff.) This adjustment 
reduces circular viruses’ inconsistency in classes I and VII to 0.90% and linear 
viruses’ inconsistency in classes IV, V, and VI to 2.33%. The overall rate improves 
to 1.19%, prompting the adoption of this strategy for subsequent predictions. 
Even with only sequence information, accurate Baltimore class predictions are 
possible. Among 2044 viruses, 54 receive incorrect predictions, yielding a 2.64% 
inconsistency rate. Higher inconsistency in classes III (11%) and VI (12%) is due 
to their smaller sizes (45 and 58, respectively). Expanding the database with more 
samples should further diminish inconsistency rates. 
The classiﬁcation also achieves good performance when the label is chosen as the 
family, the subfamily, and the genus. We can predict the family of a virus based on 
only sequence information with an inconsistency rate of 3.38%. The inconsistency 
rate of subfamily prediction and genus prediction based on sequence information 
and family information are 0.29 and 2.79 percent sign2.79%, respectively. 
The natural graph allows us to visually represent and analyze the outcomes of the 
natural vector method in more detail. In Fig. 6.2, we provide a graphical depiction 
of 44 single-segment referenced viruses belonging to Baltimore class VII, serving 
as an illustrative example. Each integer in the ﬁgure corresponds to a virus, while 
the real number displayed on an arrow signiﬁes the distance between two viruses. 
Notably, the graph distinctly separates the Hepadnaviridae and Caulimoviridae 
families. Within the Hepadnaviridae family, there are two genera Avihepadnavirus 
and Orthohepadnavirus. For viruses No. 1476 (Ross’s goose hepatitis B), No. 1529 
(Sheldgoose hepatitis B), and No. 1583 (Snow goose hepatitis B) that lack ICTV 
genus labels, their nearest neighbors are all attributed to the Avihepadnavirus genus, 
leading us to predict their association with the Avihepadnavirus genus. These pre-
dictions align with the ﬁndings of other researchers [85]. The family Caulimoviridae 
encompasses six genera: Badnavirus, Petuvirus, Caulimovirus, Cavemovirus, Soy-
movirus, and Tungrovirus. Virus No. 988 (Lucky bamboo bacilliform) lacks a genus 
label and is nearest to Virus No. 482 (Dracaena mottle), with a distance of merely 
14.52. Given this proximity, we conﬁdently predict that Virus No. 988 is also a 
member of the Badnavirus genus, consistent with the conclusions of Chen et al. 
[86]. Furthermore, while ICTV labels Virus No. 217 (Bougainvillea spectabilis 
chlorotic vein-banding) and Virus No. 454 (Cycad leaf necrosis) as Badnaviruses, 
our genome space analysis reveals their signiﬁcant separation from the rest of the 
Badnaviruses. Similarly, viruses such as No. 325 (Cestrum yellow leaf curling), No. 
616 (Eupatorium vein clearing), and No. 1481 (Rudbeckia ﬂower distortion) display

102
6
The Development and Applications of the Natural Vector Method
Fig. 6.2 The natural graph for the 44 single-segment referenced viruses in Baltimore class VII 
considerable distance from the remaining Caulimoviruses. Consequently, we raise 
questions about the ICTV genus classiﬁcations for these particular viruses. 
For comparison, we also conducted Multiple Sequence Alignment (MSA) anal-
ysis on three small Baltimore classes: III (45 sequences), V (67 sequences), and VII 
(44 sequences), aiming to assess whether a virus’s nearest neighbor corresponds to 
the same family as itself. The ClustalW program from the MEGA 5.0 software was 
employed to perform the alignment for these three groups, followed by veriﬁcation 
of label consistency between viruses and their nearest neighbors. The results 
indicated inconsistent family labels in Baltimore class III (1 inconsistency), while 
no inconsistencies were found in classes V and VII. While MSA offers accurate 
classiﬁcation outcomes, one of its most prominent challenges is computational 
time. MSA demands around 2, 10, and 1 hours to generate alignment results for 
Baltimore classes III, V, and VII, respectively, on a standard PC (CPU 1.67 GHz, 
3 GB of RAM). In contrast, our approach achieves similar results in just 2.1, 9.4, 
and 1.7 seconds for the same classes on the same computer. When dealing with 
larger classes such as Baltimore classes I (776 viruses), II (328 viruses), and IV 
(563 viruses), MSA becomes computationally demanding, if not impractical. In 
contrast, our method takes approximately 76.7 minutes, 5.2, and 45.1 seconds for 
these classes, with the majority of computational time allocated to natural vector 
calculations. It is worth noting that classifying a new virus typically requires less 
than one second to calculate its natural vector and determine its classiﬁcation. Our

6.5
Applications
103
approach surpasses MSA in terms of computational efﬁciency, as the recalculations 
of natural vectors are unnecessary for known viruses. For Baltimore class VI, a 
check is unnecessary since all 58 viruses belong to a single family. 
6.5.1.2 
The Genome Space with Multiple-Segmented Viruses 
For multiple-segmented sequences, we transform each segment into a 12-
dimensional natural vector. Thus each sequence is mapped into a set of points. 
To simultaneously compare viruses with multiple segments, we propose the use of 
the Hausdorff distance which measures the distance between two sets of vectors 
[87]. 
The deﬁnition of the Hausdorff distance has been introduced in Sect. 5.1.4. Here, 
we employ an example to illustrate its application for multi-segmented sequences 
more effectively. Let us assume that virus X is composed of four segments with 
corresponding natural vectors x 1 comma x 2 comma x 3 comma x 4x1, x2, x3, x4, and virus Y consists of four segments 
with corresponding natural vectors y 1 comma y 2 comma y 3 comma y 4y1, y2, y3, y4. Suppose we have the Euclidean 
distance matrix left parenthesis d Subscript i j Baseline right parenthesis equals left parenthesis d left parenthesis x Subscript i Baseline comma y Subscript j Baseline right parenthesis right parenthesis(dij) = (d(xi, yj)) given by: 
Start 4 By 4 Matrix 1st Row 1st Column 16 2nd Column 7 3rd Column 2 4th Column 23 2nd Row 1st Column 1 2nd Column 10 3rd Column 15 4th Column 8 3rd Row 1st Column 25 2nd Column 18 3rd Column 7 4th Column 2 4th Row 1st Column 19 2nd Column 3 3rd Column 37 4th Column 22 EndMatrix period
⎛
⎜⎜⎝
16 7 2 23
1 10 15 8
25 18 7 2
19 3 37 22
⎞
⎟⎟⎠.
(6.14) 
We identify the smallest distance in each row (2, 1, 2, and 3, respectively) and 
in each column (1, 3, 2, and 2, respectively). Consequently, the Hausdorff distance 
between X and Y is determined as max left parenthesis max 2 comma 1 comma 2 comma 3 comma max 1 comma 3 comma 2 comma 2 right parenthesis equals 3max(max 2, 1, 2, 3, max 1, 3, 2, 2) = 3. One  
signiﬁcant advantage of the Hausdorff distance is its invariance to the rearrangement 
of virus segment orders. Hence, there is no need to align the segments of two viruses 
beforehand for measuring their distance. Furthermore, if h left parenthesis upper X comma upper Y right parenthesis equals 0h(X, Y) = 0, it signiﬁes 
that the two viruses possess identical matched segments. Another beneﬁt lies in the 
Hausdorff distance’s capability to compare viruses with varying segment quantities. 
For instance, even if segment x 4x4 is unintentionally omitted, we can still calculate 
h left parenthesis x 1 comma x 2 comma x 3 comma upper Y right parenthesis equals 7 greater than 3 equals h left parenthesis upper X comma upper Y right parenthesish(x1, x2, x3, Y) = 7 > 3 = h(X, Y). In this scenario, the Hausdorff distance might 
impose a penalty due to the absent segment. 
By the Hausdorff distance, we can add the multiple-segmented sequences into 
the genome space. It is worth noticing that we can calculate the distance between a 
single-segmented sequence and a multiple-segmented sequence since the Hausdorff 
distance does not require the numbers of the segments to be the same. Therefore, 
two kinds of sequences can be put into one genome space. In [87], 2384 reference 
sequences including 370 multiple-segmented viruses are considered to establish a 
genome space. Applying the Hausdorff distance, we observe that 97.7% of the 2384 
viruses exhibit an identical number of segments with their closest neighbors. This 
suggests a tendency for a virus to have the same segment count with its nearest

104
6
The Development and Applications of the Natural Vector Method
neighbor according to the Hausdorff distance. However, there are a few cases where 
a virus and its closest neighbor possess differing segment quantities. For instance, 
utilizing the Hausdorff distance, the nearest neighbor of the Subterranean clover 
stunt virus (SCSV), characterized by eight segments, is the Abaca bunchy top 
virus (ABTV), comprising six segments. Remarkably, both viruses belong to the 
Nanoviridae family. 
Similar to the genome space with only single-segmented viruses, 75 percent sign75%-cutoff 
strategy is also applied when predicting Baltimore classes and other labels. The 
inconsistency rate for Baltimore class and family given the sequence only are 3.5% 
and 4.6 percent sign4.6%, respectively, and the inconsistency rate for subfamily and genus based on 
sequence information and the family information are 0.3% and 4.4 percent sign4.4%, respectively. 
The results are comparable with those in [81]. 
We have successfully established a genome space that encompasses multiple-
segmented viruses. This genome space provides us with a valuable tool for 
analyzing speciﬁc viruses, such as the inﬂuenza A (H7N9) virus. The H7N9 virus, 
comprised of eight gene segments, poses a signiﬁcant public health concern due 
to its high contagiousness, lethality, and rapid evolution [88]. Swift identiﬁcation 
and placement of newly evolved H7N9 strains within the phylogenetic tree are 
of paramount importance. Traditionally, the phylogenetic trees for these strains 
are constructed on a segment-by-segment basis, often focusing solely on the 
hemagglutinin (HA) and neuraminidase (NA) gene segments. However, leveraging 
the natural vector method allows us to conduct a simultaneous analysis of these 
two gene segments. In our study, we consider 28 strains of H7N9 viruses sourced 
from the NCBI Inﬂuenza virus database. We employ the neighbor-joining method 
to reconstruct a phylogenetic tree using the Hausdorff distance of natural vectors 
(see Fig. 6.3). The clustering outcome from this approach outperforms the results 
obtained from the consensus tree [89], which merged the HA and NA segment trees 
using the majority rule. This highlights the efﬁcacy of our method in enhancing the 
accuracy of phylogenetic analyses for multi-segmented viruses. 
There are many other applications of the 12-dimensional viral genome space. 
The classiﬁcation and prediction based on the natural vector method have been 
applied to many viruses including HIV [78], West Nile viruses [81], and Ebolavirus 
[90]. In order to promote the analysis based on the natural vector method, a 
virus database called VirusDB (http://yaulab.math.tsinghua.edu.cn/VirusDB/) and 
an online inquiry system has been constructed to serve people who are interested in 
viral classiﬁcation and prediction. The database stores all viral genomes, their cor-
responding natural vectors, and the classiﬁcation information of the single/multiple-
segmented viral reference sequences downloaded from the National Center for 
Biotechnology Information. The online inquiry system serves the purpose of com-
puting natural vectors and their distances based on submitted genomes, providing 
an online interface for accessing and using the database for viral classiﬁcation and 
prediction, and back-end processes for automatic and manual updating of database 
content to synchronize with GenBank. Submitted genomes data in FASTA format 
will be carried out and the prediction results with 5 closest neighbors and their clas-
siﬁcations will be returned by email. Considering the one-to-one correspondence

6.5
Applications
105
Fig. 6.3 (a) Phylogenetic tree based on the Hausdorff distances of the NA and HA segments. (b) 
The consensus tree of the HA and NA segments 
between sequence and natural vector, time efﬁciency, and high accuracy, the natural 
vector method is a signiﬁcant advance compared with alignment methods, which 
makes VirusDB a useful database in further research. 
6.5.2 
60-Dimensional Protein Space 
Similarly, the natural vector method for protein sequences can be applied to show 
how proteins are distributed in the protein space. We take three examples to show the 
effectiveness of the 60-dimensional protein space constructed by the natural vector 
method. 
6.5.2.1 
The Classiﬁcation of the PKC-Like Superfamily 
In [94], a 60-dimensional natural vector approach is employed to classify proteins 
belonging to the PKC-like superfamily. Protein kinase C (PKC) is a family of 
enzymes that plays a pivotal role in regulating the activity of other proteins by the 
phosphorylation of hydroxyl groups on serine and threonine amino acid residues 
within these proteins [95]. The structure of PKC proteins is characterized by 
a regulatory domain and a catalytic domain, interconnected by a hinge region. 
Notably, the regulatory domain tends to determine the primary classiﬁcation, given 
that the catalytic domain usually displays a high degree of conservation. The PKC-
like superfamily is composed of six categories of PKCs and PKC-related protein 
molecules: cPKC, nPKC, aPKC, PKCmu (ν, μ, and D2 types), PKC1 (from fungus), 
and PRK (similar to PKC1 but from animals).

106
6
The Development and Applications of the Natural Vector Method
124 proteins from the PKC-like superfamily are transformed into 60-dimensional 
vectors by the natural vector method. By computing the Euclidean distances 
between these vectors, we obtain a distance matrix. Based on the distance matrix, 
a natural graph can be drawn (See Figs. 6.4, 6.5, and 6.6). The lengths of lines in 
this graphical representation are proportional to the biological distances among the 
proteins. Our classifying results for these proteins totally agree with those from 
GenBank (NCBI) descriptions and literature and the natural graph can greatly 
visualize the distribution of proteins in the protein space. 
Furthermore, the natural vector method provides us with insight into the rela-
tionship among proteins. For example, sequence No. 5 (GenBank ID: O17874) (in 
Fig. 6.6) is a protein sequence belonging to the category PRK from C. elegans. In 
the natural graph, it is closest to a PKC1 protein (No. 89). We further check that 
all the other PRK proteins in the dataset are from vertebrate animals. Thus, we 
believe that the PRK subfamily should be divided into two smaller groups, one is 
from vertebrate animals (PRK-v) and the other is from invertebrate animals (PRK-
inv). Thus, sequence No. 5 belongs to a new subfamily PRK-inv, which is closer to 
PKC1 subfamily than PRK-v. As another example, sequence No. 84 (GenBank ID: 
Q69G16) (in Fig. 6.4) is a cPKC according to GenBank while the closest protein 
sequence from it belongs to aPKC. Thus, our theory predicts that there may be 
some cPKC members missing in our dataset, lying between No. 84 and No. 100 in 
our protein space. It is the job of biologists to ﬁnd these new cPKC members. This 
unique natural graphical representation gives a whole picture of the phylogenetic 
relationships of the PKC-like superfamily. It allows us to have a global comparison 
of proteins simultaneously, which no other existing method can achieve. 
6.5.2.2 
The Evolutionary Origin of the SAR11 Clade Marine Bacteria 
In [96], a 60-dimensional natural vector approach is employed to discern the 
phylogenetic placement of the SAR11 clade. Planktonic bacterial lineages with 
streamlined genomes are broadly distributed throughout the oceans. A notable 
example of such lineages is the SAR11 clade within the Alphaproteobacteria [97]. 
The SAR11 bacteria constitute a highly abundant group inhabiting the upper layers 
of oceanic surface waters, playing a crucial role in the global ocean carbon cycle. 
The Global Ocean Sampling Expedition (GOS) has conﬁrmed SAR11’s prevalence 
as the most dominant ribotype across various ocean habitats, encompassing coastal, 
estuary, and open-ocean environments [98]. However, the taxonomic delineation 
of the SAR11 clade within the Alphaproteobacteria remains relatively indistinct 
[99]. Statistical analyses often yield conﬂicting evolutionary models, further com-
plicating matters. Clarifying the origin of the SAR11 lineage requires addressing the 
uncertainty surrounding its position in the Alphaproteobacteria tree [97]. This task 
presents a challenge due to the fact that the genomic G+C content of ecologically 
distinct SAR11 and Rickettsiales lineages remains notably low (below 30%), in 
contrast to the majority of other Alphaproteobacterial lineages that exhibit a higher 
G+C content (ranging from 50% to 70%) [97].

6.5
Applications
107
Fig. 6.4 The natural graphical representation of 124 proteins from PKC-like superfamily. We 
break the large original ﬁgure into three pieces: (a)–(c). This ﬁgure is Part (a)

108
6
The Development and Applications of the Natural Vector Method
Fig. 6.5 The natural graphical representation of 124 proteins from PKC-like superfamily. This 
ﬁgure is Part (b) 
Eight clades are used to reconstruct the phylogeny of Alphaproteobacteria and 
62 strains from these clades are chosen in Luo’s research [97]. (See Table 6.3.) We 
take the following steps to deﬁne the distance between two clades. First, we pick 
a protein dataset (containing some speciﬁc families) and transform each protein 
sequence into a 60-dimensional natural vector. Then each strain can be seen as a 
set of vectors whose corresponding protein sequences belong to this strain and the 
distance between two strains can be calculated by the Hausdorff distance. Finally, 
we use the Hausdorff distance again to calculate the distance between two clades by 
regarding each clade as a set of strains.

6.5
Applications
109
Fig. 6.6 The natural graphical representation of 124 proteins from PKC-like superfamily. This 
ﬁgure is Part (c) 
Table 6.3 Eight clades used 
for reconstructing the 
phylogeny of 
Alphaproteobacteria. The 
number in parentheses shows 
the number of strains in each 
clade 
Number
Clade name 
1
Caulobacterales (5) 
2
Rhizobiales (14) 
3
Rhodospirillales (7) 
4
Rickettsiales (7) 
5
Rhodobacterales (10) 
6
SAR11 (8) 
7
SAR116 (5) 
8
Sphingomonadales (6) 
In [96], many protein datasets are used to study the evolutionary origin of the 
SAR11 clade. We here show the result of one dataset. The chosen protein dataset, 
including 3315 protein sequences, consists of 24 composition-heterogeneous ribo-
somal protein families and 28 composition-homogeneous protein families. Given 
this dataset, we can compute the distance between two clades. Then the phylogenetic 
tree (using the single linkage method [100] and neighbor-joining algorithm [101])

110
6
The Development and Applications of the Natural Vector Method
Fig. 6.7 The phylogenetic tree for Alphaproteobacteria based on the Hausdorff distance 
Fig. 6.8 The natural graph for Alphaproteobacteria based on the Hausdorff distance 
and the natural graph can be plotted. (See Figs. 6.7 and 6.8.) The evolutionary result 
is consistent with Viklund’s work [98]. 
6.5.2.3 
The Phylogenetic Analysis of the Zika Virus 
In [103], the phylogenetic analysis of the Zika virus (ZIKV) is conducted based on 
the 60-dimensional protein space. Previously we have shown the effectiveness of the 
genome space in the virus-related study. Now we will show that the protein space 
is also practical when studying viruses. Zika virus (ZIKV) is an arbovirus within 
the genus Flavivirus and family Flaviviridae. It is transmitted by Aedes (Stegomyia) 
mosquitoes and is closely related to other ﬂaviviruses such as dengue, West Nile, 
and yellow fever viruses. 
Most of the phylogenetic trees of the Zika virus were constructed by multiple 
sequence alignment algorithms and based on genomic sequences. However, these

6.5
Applications
111
trees were inconsistent with one another. For example, the recovered evolutionary 
relationship presented two cases: Asian and African lineages; Asian and two 
African lineages. Based on the complete genomes, the two different cases of ZIKV 
phylogeny could be obtained [102]. The protein sequences of ZIKV are directly 
involved in a variety of biological processes and are more conserved than the gene 
sequences. To fully understand the origin and diversity of this virus, the natural 
vector method can be applied to perform the phylogeny analysis of ZIKV strains. 
According to the organization of the ZIKV genome, the complete coding region 
of ZIKV is ﬁrst translated into a protein (polyprotein) which is then cleaved into 
three structural and seven nonstructural proteins. Based on the 60-dimensional 
natural vector method, the phylogenetic tree using 87 ZIKV polyproteins is 
reconstructed. As illustrated in Fig. 6.9, the 87 ZIKV are well classiﬁed into three 
lineages: the Asian, West African, and East African lineages, which is consistent 
with the previous work [104]. The two African clades form a sister group to the 
Asian clade. The newly identiﬁed ZIKV strains in countries of Americas (such as 
Brazil, Haiti, Suriname, Guatemala, Martinique, and Puerto Rico) are all close to 
Asian and Paciﬁc strains as shown in Fig. 6.9. 
The strains from the Asian and Paciﬁc countries are in the base of the Asian clade 
consisting of strains from Asia, Paciﬁc regions, and Americas. This indicates that 
the epidemics in the Americas are likely dated back to strains from Malaysia isolated 
in 1966. The two African lineages are sister groups. The strains from Senegal are 
distributed in the two lineages, which suggests that two independent lineages have 
been circulating in this country. The MR766 prototype strains are clustered together 
as well. 
6.5.2.4 
The Protein Universe 
The applications discussed above highlight the utility of the natural vector method 
in gaining insights into the distribution of proteins within the protein space. A fun-
damental challenge in biology revolves around unraveling the characteristics of the 
protein universe, encompassing the entirety of known proteins [92]. This expansive 
and enigmatic entity constitutes a foundational aspect of biological understanding. 
Prior approaches [91–93] aimed at elucidating the nature of the protein universe 
typically clustered sequences into families based on their similarities. However, 
these methods often fall short of providing a concrete depiction of the protein 
universe’s nature. Furthermore, they rely on diverse amino acid substitution models 
and entail manual intervention, leading to potentially contentious outcomes. Addi-
tionally, these approaches rely on multiple sequence alignment, a computationally 
intensive NP-hard problem, rendering them impractical for handling substantial 
volumes of protein sequences. In contrast, the natural vector method for proteins 
offers an effective representation of a protein sequence’s position within the protein 
universe. Notably, it presents a swift algorithm capable of parallel computation, 
thereby addressing the computational limitations of previous methods.

112
6
The Development and Applications of the Natural Vector Method
Fig. 6.9 Phylogenetic tree of 87 Zika viruses with polyproteins based on the 60-dimensional 
natural vector method

6.6
Other Alignment-Free Methods Motivated by the Natural Vector Method
113
6.6 
Other Alignment-Free Methods Motivated by the 
Natural Vector Method 
There are many alignment-free methods that are motivated by the natural vector 
method. For example, in Chap. 8, we will introduce the k-mer natural vector method. 
In this part, we will present another generalization of the natural vector method, 
which takes the covariance into account. 
The order 2 natural vector contains the occurrence, the mean, and the variance. In 
[105], the covariance is further added to the vector to produce a new alignment-free 
method. In the following content, we will deﬁne the covariance of two letters in a 
string. 
We ﬁrst deﬁne the covariance of two sets of points in double struck upper RR. Let upper A equals StartSet a 1 comma a 2 comma ellipsis comma a Subscript n Baseline EndSetA = {a1, a2, . . . , an}
and upper B equals StartSet b 1 comma b 2 comma ellipsis comma b Subscript m Baseline EndSetB = {b1, b2, . . . , bm} be two ﬁnite point sets in double struck upper RR, where a 1 less than a 2 less than midline horizontal ellipsis less than a Subscript na1 < a2 < · · · < an
and b 1 less than b 2 less than midline horizontal ellipsis less than b Subscript mb1 < b2 < · · · < bm. 
(1) If m equals nm = n, then upper C o v left parenthesis upper A comma upper B right parenthesis colon equals sigma summation Underscript i equals 1 Overscript m Endscripts left parenthesis a Subscript i Baseline minus mu Subscript upper A Baseline right parenthesis left parenthesis b Subscript i Baseline minus mu Subscript upper B Baseline right parenthesis divided by mCov(A, B) := m
i=1(ai −μA)(bi −μB)/m, where mu Subscript upper A Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts a Subscript i Baseline divided by nμA =
n
i=1 ai/n, mu Subscript upper B Baseline equals sigma summation Underscript i equals 1 Overscript m Endscripts b Subscript i Baseline divided by mμB = m
i=1 bi/m. 
(2) If m not equals nm /= n, we can assume that n greater than mn > m. We then choose m numbers from set 
upper A equals StartSet a 1 comma a 2 comma ellipsis comma a Subscript n Baseline EndSetA = {a1, a2, . . . , an} which satisfy a Subscript i 1 Baseline less than a Subscript i 2 Baseline less than midline horizontal ellipsis less than a Subscript i Sub Subscript mai1 < ai2 < · · · < aim, 1 less than or equals i 1 less than i 2 less than ellipsis less than i Subscript m Baseline less than or equals n1 ≤i1 < i2 < . . . <
im ≤n, and here are upper C Subscript n Superscript mCm
n choices in total. We compute the covariance between 
the m numbers and set upper B equals StartSet b 1 comma b 2 comma ellipsis comma b Subscript m Baseline EndSetB = {b1, b2, . . . , bm}, then take the average value of 
these upper C Subscript n Superscript mCm
n results as the ﬁnal covariance of the point sets A and B, written as I. 
We can simplify the result in the language of matrix, that is, 
upper I equals StartFraction 1 Over m upper C Subscript n Superscript m Baseline EndFraction upper B upper D upper A Superscript upper T Baseline minus mu Subscript upper A Baseline mu Subscript upper B Baseline commaI =
1
mCm
n
BDAT −μAμB,
(6.15) 
where mu Subscript upper A Baseline equals sigma summation Underscript i equals 1 Overscript n Endscripts a Subscript i Baseline divided by nμA
= n
i=1 ai/n, mu Subscript upper B Baseline equals sigma summation Underscript i equals 1 Overscript m Endscripts b Subscript i Baseline divided by mμB
= m
i=1 bi/m, upper A Superscript upper T Baseline equals left brace a 1 comma a 2 comma ellipsis comma a Subscript n Baseline right brace Superscript upper TAT
= {a1, a2, . . . , an}T
represents an n times 1n×1 column vector, and D is an m times nm×n matrix written as left parenthesis upper D Subscript i j Baseline right parenthesis Subscript m times n(Dij)m×n, 
If i equals 1i = 1,
upper D Subscript i j Baseline equals StartLayout Enlarged left brace 1st Row 1st Column upper C Subscript n minus j Superscript m minus 1 Baseline 2nd Column comma 1 less than or equals j less than or equals n minus m plus 1 2nd Row 1st Column 0 2nd Column comma n minus m plus 2 less than or equals j less than or equals n EndLayoutDij =

Cm−1
n−j
, 1 ≤j ≤n −m + 1
0
, n −m + 2 ≤j ≤n
If 2 less than or equals i less than or equals m minus 12 ≤i ≤m −1, 
upper D Subscript i j Baseline equals StartLayout Enlarged left brace 1st Row 1st Column 0 2nd Column comma 1 less than or equals j less than or equals i minus 1 2nd Row 1st Column upper C Subscript j minus 1 Superscript i minus 1 Baseline upper C Subscript n minus j Superscript m minus i Baseline 2nd Column comma i less than or equals j less than or equals n minus m plus i 3rd Row 1st Column 0 2nd Column comma n minus m plus i plus 1 less than or equals j less than or equals n EndLayoutDij =
⎧
⎪⎪⎨
⎪⎪⎩
0
, 1 ≤j ≤i −1
Ci−1
j−1Cm−i
n−j
, i ≤j ≤n −m + i
0
, n −m + i + 1 ≤j ≤n
If i equals mi = m,
upper D Subscript i j Baseline equals StartLayout Enlarged left brace 1st Row 1st Column 0 2nd Column comma 1 less than or equals j less than or equals i minus 1 2nd Row 1st Column upper C Subscript j minus 1 Superscript m minus 1 Baseline 2nd Column comma i less than or equals j less than or equals n EndLayoutDij =

0
, 1 ≤j ≤i −1
Cm−1
j−1
, i ≤j ≤n
. 
For a DNA sequence S of length N, we want to compute the covariance 
between any pair of nucleotides or amino acids X and Y. Assume that position 
of X appeared in the sequence S is upper A equals StartSet a 1 comma a 2 comma ellipsis comma a Subscript n Baseline EndSetA = {a1, a2, . . . , an}, and the position of 
Y is upper B equals StartSet b 1 comma b 2 comma ellipsis comma b Subscript m Baseline EndSetB = {b1, b2, . . . , bm}. Then the covariance between X and Y is deﬁned as 
upper C o v left parenthesis upper A comma upper B right parenthesis divided by upper NCov(A, B)/N.

114
6
The Development and Applications of the Natural Vector Method
For example, given a DNA sequence ACACACGTGT, we ﬁrst compute the 
covariance between nucleotides A and C. The position of A appeared in the 
sequence is {1,3,5}, and the position of C is {2,4,6}. We could calculate mu Subscript upper A Baseline equals 3μA = 3
and mu Subscript upper C Baseline equals 4μC = 4. Then the covariance between nucleotides A and C is 
left bracket left parenthesis 1 minus 3 right parenthesis left parenthesis 2 minus 4 right parenthesis divided by 3 plus left parenthesis 3 minus 3 right parenthesis left parenthesis 4 minus 4 right parenthesis divided by 3 plus left parenthesis 5 minus 3 right parenthesis left parenthesis 6 minus 4 right parenthesis divided by 3 right bracket divided by 10 equals 4 divided by 15 period[(1 −3)(2 −4)/3 + (3 −3)(4 −4)/3 + (5 −3)(6 −4)/3]/10 = 4/15.
Secondly, we calculate the covariance between A and G. The position of G is {7,9} 
and mu Subscript upper G Baseline equals 8μG = 8. The covariance between A and G is 
StartLayout 1st Row left brace left bracket left parenthesis 1 minus 2 right parenthesis left parenthesis 7 minus 8 right parenthesis divided by 2 plus left parenthesis 3 minus 2 right parenthesis left parenthesis 9 minus 8 right parenthesis divided by 2 right bracket plus left bracket left parenthesis 1 minus 3 right parenthesis left parenthesis 7 minus 8 right parenthesis divided by 2 plus left parenthesis 5 minus 3 right parenthesis left parenthesis 9 minus 8 right parenthesis divided by 2 right bracket 2nd Row plus left bracket left parenthesis 3 minus 4 right parenthesis left parenthesis 7 minus 8 right parenthesis divided by 2 plus left parenthesis 5 minus 4 right parenthesis left parenthesis 9 minus 8 right parenthesis divided by 2 right bracket right brace slash left parenthesis 3 times 10 right parenthesis equals 2 divided by 15 period EndLayout{[(1 −2)(7 −8)/2 + (3 −2)(9 −8)/2] + [(1 −3)(7 −8)/2 + (5 −3)(9 −8)/2]
+[(3 −4)(7 −8)/2 + (5 −4)(9 −8)/2]}/(3 × 10) = 2/15.
The covariances between the other pairs of nucleotides could be calculated in the 
same way. 
Once we have obtained the covariances between pairs of nucleotides or amino 
acids, we integrate these covariances into the original natural vector of the sequence 
S. For nucleotides, there are upper C 4 squared equals 6C2
4 = 6 possible pairs, and for amino acids, there are 
upper C 20 squared equals 190C2
20 = 190 possible pairs. Consequently, the dimension of the extended natural 
vector for DNA sequences increases from 12 to 18, and for protein sequences, it 
expands from 60 to 250. This enhanced approach yields a novel type of natural 
vector that encapsulates additional natural statistical information for sequences. This 
advanced method effectively incorporates more comprehensive insights compared 
to the basic second-order natural vector, while it involves higher dimension, 
particularly in the case of protein sequences.

Chapter 7 
Convex Hull Principle and Distinguishing 
Proteins from Arbitrary Amino Acid 
Sequences 
7.1 
The Convex Hull Principle 
In every natural science ﬁeld, it is important to discover the laws that govern it. In 
chemistry, there are three laws: the Law of Mass Conservation, the Law of Deﬁnite 
Proportions, and the Law of Multiple Proportions. In physics, there are Newton’s 
Three Laws of Motion, which describe basic rules about how the motion of physical 
objects changes. Most of the scientiﬁc laws use mathematics to precisely describe 
natural phenomena. For instance, Maxwell formulated the four fundamental laws of 
electromagnetism (Gauss’s law for electricity, Gauss’s law for magnetism, Faraday’s 
law, and Ampere’s circuital law with Maxwell’s correction) based on mathematical 
equations. Similarly, in molecular biology, an essential principle states that the 
biological properties of proteins or DNA are inﬂuenced by the distribution of the 
20 amino acids or 4 nucleotides within their sequences. From a mathematical 
perspective, natural vectors corresponding to sequences from the same family tend 
to cluster in the high-dimensional space. To provide a more detailed explanation, we 
introduce the convex hull principle, which is founded on the mathematical concept 
of the convex hull. 
The convex hull of a set A is the set containing all convex combinations of points 
in A. To be more precise, consider a set upper A equals StartSet a 1 comma a 2 comma ellipsis comma a Subscript n Baseline EndSetA = {a1, a2, . . . , an}. The convex hull of 
A, denoted as upper S left parenthesis upper A right parenthesisS(A), encompasses all points that can be expressed in the following 
form: sigma summation Underscript i equals 1 Overscript n Endscripts lamda Subscript i Baseline a Subscript i
n
i=1
λiai, where 0 less than or equals lamda Subscript i Baseline less than or equals 10 ≤λi ≤1 and sigma summation Underscript i equals 1 Overscript n Endscripts lamda Subscript i Baseline equals 1
n
i=1
λi = 1. The convex hull principle means 
that the convex hull formed by natural vectors of biological sequences from one 
family does not intersect with the convex hull of natural vectors from another family. 
In this section, we will initially present methods to determine if two convex hulls 
intersect, followed by the validation of this principle using both protein and DNA 
sequences. Lastly, we will introduce a novel sequence detection framework based 
on the convex hull principle. 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_7
115

116
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
7.1.1 
Methods for Determining Whether Two Convex Hulls 
Intersect 
Consider two ﬁnite point sets upper A equals StartSet a 1 comma a 2 comma ellipsis comma a Subscript n Baseline EndSetA = {a1, a2, . . . , an} and upper B equals StartSet b 1 comma b 2 comma ellipsis comma b Subscript m Baseline EndSetB = {b1, b2, . . . , bm} in 
double struck upper R Superscript kRk, where S denotes the convex hull function. The convex hull intersection problem 
involves determining whether the two convex hulls upper S left parenthesis upper A right parenthesisS(A) and upper S left parenthesis upper B right parenthesisS(B) intersect. In 
this section, we present several mathematical approaches to solve the convex hull 
intersection problem. The detailed proofs of these methods can be found in [106]. 
7.1.1.1 
The Projection-Line Method and the Normal Vector Method 
An important property for convex hulls is that upper S left parenthesis upper A right parenthesis intersection upper S left parenthesis upper B right parenthesis equals phiS(A) ∩S(B) = φ if and only if there 
is a line l subset of double struck upper R Superscript kl ⊂Rk, s.t. upper S left parenthesis upper P Subscript l Baseline left parenthesis upper A right parenthesis right parenthesis intersection upper S left parenthesis upper P Subscript l Baseline left parenthesis upper B right parenthesis right parenthesis equals phiS(Pl(A)) ∩S(Pl(B)) = φ, where upper P Subscript lPl is the projection operator 
to the line l. 
The projection-line method states that if we can identify a line, denoted as upper P Subscript lPl, 
such that the projections upper P Subscript l Baseline left parenthesis upper A right parenthesisPl(A) and upper P Subscript l Baseline left parenthesis upper B right parenthesisPl(B) of the point sets A and B onto this line 
are disjoint, then the convex hulls of the original point sets A and B do not intersect. 
This method signiﬁcantly simpliﬁes the computation by reducing the problem from 
a k-dimensional space to a one-dimensional space. 
Since A and B are sets of ﬁnite points, the surfaces of upper S left parenthesis upper A right parenthesisS(A) and upper S left parenthesis upper B right parenthesisS(B) are 
composed of hyperplanes. In this case, we have a stronger property for convex hulls: 
The necessary and sufﬁcient condition of upper S left parenthesis upper A right parenthesis intersection upper S left parenthesis upper B right parenthesis equals phiS(A) ∩S(B) = φ is that there is a normal 
vector N of one hyperplane of upper S left parenthesis upper A right parenthesisS(A) or upper S left parenthesis upper B right parenthesisS(B), s.t. upper S left parenthesis upper P Subscript upper N Baseline left parenthesis upper A right parenthesis right parenthesis intersection upper S left parenthesis upper P Subscript upper N Baseline left parenthesis upper B right parenthesis right parenthesis equals phiS(PN(A))∩S(PN(B)) = φ, where 
upper P Subscript upper NPN is the projection operator to the direction of the vector N. 
Therefore, we can check all possible normal vectors to see whether two convex 
hulls intersect since the number of normal vectors for upper S left parenthesis upper A right parenthesisS(A) and upper S left parenthesis upper B right parenthesisS(B) is ﬁnite. It 
is called the normal vector method. The normal vector method can be seen as a 
special case of the projection-line method whose candidates of the projection lines 
are natural and ﬁnite. 
7.1.1.2 
The Subset Determination Method 
In 
double struck upper R Superscript kRk, the condition 
upper S left parenthesis upper A right parenthesis intersection upper S left parenthesis upper B right parenthesis equals normal empty setS(A) ∩S(B)
=
∅is necessary and sufﬁcient when 
for all 
i 1 comma i 2 comma ellipsis comma i Subscript k plus 1 Baseline element of left bracket 1 comma n right bracketi1, i2, . . . , ik+1
∈
[1, n] and 
j 1 comma j 2 comma ellipsis comma j Subscript k plus 1 Baseline element of left bracket 1 comma m right bracketj1, j2, . . . , jk+1
∈
[1, m], we have  
upper S left parenthesis StartSet a Subscript i 1 Baseline comma a Subscript i 2 Baseline comma ellipsis comma a Subscript i Sub Subscript k plus 1 Subscript Baseline EndSet right parenthesis intersection upper S left parenthesis StartSet b Subscript j 1 Baseline comma b Subscript j 2 Baseline comma ellipsis comma b Subscript j Sub Subscript k plus 1 Subscript Baseline EndSet right parenthesis equals normal empty setS({ai1, ai2, . . . , aik+1}) ∩S({bj1, bj2, . . . , bjk+1}) = ∅. Using this property, we 
can divide each convex hull into multiple convex blocks, each constructed by 
k plus 1k + 1 points, and check for intersections among these smaller blocks. In a k-
dimensional space, each convex block consists of k plus 1k + 1 vertices and k plus 1k + 1 faces 
formed by any possible combination of k vertices. The equations of each face and 
the corresponding normal vector of the convex block can be easily calculated. This 
enables us to employ the normal vector method to handle the intersection problem 
for subsets, resulting in a signiﬁcant reduction in computation.

7.1
The Convex Hull Principle
117
7.1.1.3 
The Linear Programming Method 
S(A) ∩S(B) = φ is equivalent with that there are no nonnegative real numbers λ1, 
λ2,. . ., λn, μ1, μ2,. . ., μm satisfying the following equations: 
StartLayout Enlarged left brace 1st Row 1st Column sigma summation Underscript i equals 1 Overscript n Endscripts lamda Subscript i Baseline a Subscript i Baseline equals 2nd Column sigma summation Underscript j equals 1 Overscript m Endscripts mu Subscript j Baseline b Subscript j Baseline period 2nd Row 1st Column sigma summation Underscript i equals 1 Overscript n Endscripts lamda Subscript i 2nd Column equals 1 period 3rd Row 1st Column sigma summation Underscript j equals 1 Overscript m Endscripts mu Subscript j 2nd Column equals 1 period EndLayout
⎧
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩
n

i=1
λiai =
m

j=1
μjbj.
n

i=1
λi = 1.
m

j=1
μj = 1.
(7.1) 
By applying this theorem, we can convert the original problem into an algebraic 
problem. If any convex combination of the points in one set is equal to a convex 
combination of points in the other set, we can conclude that the two convex hulls 
intersect. Regardless of the dimension of the space or the number of points, this 
problem can be efﬁciently solved using linear programming functions available in 
various software. This method proves to be both time-saving and effective. 
7.1.1.4 
The Minimum Distance Method 
Consider the optimization problem 
StartLayout 1st Row 1st Column min 2nd Column StartAbsoluteValue EndAbsoluteValue sigma summation Underscript i equals 1 Overscript n Endscripts lamda Subscript i Baseline a Subscript i minus sigma summation Underscript j equals 1 Overscript m Endscripts mu Subscript j Baseline b Subscript j Baseline StartAbsoluteValue EndAbsoluteValue 2nd Row 1st Column s period t period 2nd Column sigma summation Underscript i equals 1 Overscript n Endscripts lamda Subscript i Baseline equals 1 period 3rd Row 1st Column Blank 2nd Column sigma summation Underscript j equals 1 Overscript m Endscripts mu Subscript j Baseline equals 1 period 4th Row 1st Column Blank 2nd Column lamda Subscript i Baseline greater than or equals 0 comma i equals 1 comma ellipsis comma n comma 5th Row 1st Column Blank 2nd Column mu Subscript j Baseline greater than or equals 0 comma j equals 1 comma ellipsis comma m period EndLayout
min
||
n

i=1
λiai −
m

j=1
μjbj||
s.t.
n

i=1
λi = 1.
m

j=1
μj = 1.
λi ≥0, i = 1, . . . , n,
μj ≥0, j = 1, . . . , m.
(7.2) 
The condition upper S left parenthesis upper A right parenthesis intersection upper S left parenthesis upper B right parenthesis equals normal empty setS(A) ∩S(B) = ∅is equivalent to the minimum value of an 
optimization problem being greater than zero. In this case, we can reframe the 
problem as calculating the minimum distance between the two convex hulls. If the 
minimum distance is positive, it indicates that the convex hulls are disjoint. Various

118
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
mathematical software packages provide quadratic programming functions that can 
efﬁciently solve this minimization problem. 
7.1.2 
The Veriﬁcation of the Convex Hull Principle 
In this part, we will use biological data to verify the convex hull principle. To be 
more speciﬁc, we will show that biological sequences from different families can be 
transformed into pairwise disjoint convex hulls by the natural vector method. 
7.1.2.1 
The Veriﬁcation by Protein Sequences 
We ﬁrst show that the convex hull principle holds for protein sequences [107]. 
Two protein datasets are considered. The ﬁrst dataset is the protein kinase dataset 
including 31,355 sequences, which can be divided into 107 families. The second 
dataset is the human protein dataset including 10,983 sequences that are divided 
into 2156 families. We use the natural vector method with covariance introduced 
in Sect. 6.6 to construct convex hulls. The natural vector method with covariance 
transforms protein sequences into 250-dimensional vectors. By applying the linear 
programming method as mentioned earlier, it is observed that there is no intersection 
between any pair of convex hulls in both datasets. This observation further conﬁrms 
the validity of the convex hull principle. (There are 5671 pairs of convex hulls in the 
ﬁrst dataset and 2,323,090 pairs of convex hulls in the second dataset.) 
To visualize the results, we employ the linear discriminant analysis (LDA) 
method for dimension reduction [109]. LDA is utilized to determine the linear 
separability of two groups, reducing the vector dimension from 250 to 2. In 
Figs. 7.1 and 7.2, we present visualizations of a pair of convex hulls from two 
datasets, respectively. Notably, the protein space points exhibit clustering rather 
than a dispersed distribution. This observation implies that as new protein kinase 
sequences are incorporated, their points are expected to lie within the approximate 
convex hull of known protein kinase families. Furthermore, Fig. 7.3 showcases 
ﬁfteen families within the AGC group of human protein kinases, aiding in our 
comprehension of the disjoint nature of distinct convex hulls. 
7.1.2.2 
The Veriﬁcation by DNA Sequences 
The convex hull principle also holds for DNA sequences [108]. The dataset for 
veriﬁcation is a viral genome dataset including 7382 sequences from 83 families. 
Different from what we have done when dealing with protein sequences, we use the 
standard natural vector method without covariance but with high orders to construct 
convex hulls. The reason is that the method in Sect. 6.6 transforms DNA sequences 
into vectors of only 18 dimensions, which may not include sufﬁcient information.

7.1
The Convex Hull Principle
119
Fig. 7.1 Convex hulls of the CAMK1 (including 295 sequences) and CAMKL (including 1075 
points) animal protein kinase families after dimension reduction by LDA method 
Therefore, we consider the standard natural vectors with high-order moments to 
separate different families. The speciﬁc order depends on the dataset. For the viral 
genome dataset considered in [108], the order for the complete separation is seven. 
In other words, 3403 pairs of convex hulls are disjoint after transforming the DNA 
sequences into order 7 natural vectors in a 32-dimensional space. 
7.1.3 
New Sequence Detection 
Despite the rapid growth in the number of known genomes and protein sequences, 
they represent only a small fraction of the vast diversity found in nature. Biologi-
cally, the detection and prediction of new genome or protein sequences based on real 
sequence data remains a challenging and crucial problem. The convex hull principle 
provides us with a new framework to solve this problem. Since the natural vector of a 
new sequence must lie in the convex hull of its family, the problem of detecting new 
sequences can be transformed into ﬁnding sequences whose corresponding natural 
vector is in a given convex hull. In this section, we will ﬁrst introduce the method to

120
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
Fig. 7.2 Convex hulls of the G-protein coupled receptor 1 (including 670 sequences) and Krueppel 
C2H2-type zinc-ﬁnger (including 538 sequences) after dimension reduction by LDA method 
determine the composition of biological sequences and then introduce two heuristic 
methods to detect new biological sequences. Without loss of generality, we focus on 
genome sequences, and all contents can be transferred to protein sequences without 
difﬁculty. 
7.1.3.1 
Determination of the Nucleotide Composition of Genome 
Sequences 
In this part, we will discuss the constraints on the ﬁrst four elements of natural vec-
tors of genomes, which describe the nucleotide composition of genome sequences. 
An obvious observation is that the ﬁrst four elements of a natural vector should be 
integers. In fact, there is a tighter constraint shown in [110]. 
For an order 2 natural vector, it is not hard to prove that its elements satisfy the 
following equations:

7.1
The Convex Hull Principle
121
Fig. 7.3 Convex hulls of ﬁfteen families in the AGC group of human protein kinases after 
dimension reduction by LDA method 
StartLayout 1st Row 1st Column sigma summation Underscript k element of upper K Endscripts n Subscript k Baseline mu Subscript k Baseline equals 2nd Column sigma summation Underscript j equals 1 Overscript n Endscripts j comma 2nd Row 1st Column sigma summation Underscript k element of upper K Endscripts sigma summation Underscript i equals 1 Overscript n Subscript upper K Baseline Endscripts s left bracket k right bracket left bracket i right bracket squared equals 2nd Column sigma summation Underscript k element of upper K Endscripts n n Subscript k Baseline upper D 2 Superscript k Baseline plus sigma summation Underscript k element of upper K Endscripts n Subscript k Baseline mu Subscript k Superscript 2 Baseline equals sigma summation Underscript j equals 1 Overscript n Endscripts j squared comma EndLayout

k∈K
nkμk =
n

j=1
j,

k∈K
nK

i=1
s[k][i]2 =

k∈K
nnkDk
2 +

k∈K
nkμ2
k =
n

j=1
j2,
(7.3) 
where upper K equals StartSet upper A comma upper T comma upper C comma upper G EndSetK = {A, T, C, G} for DNA sequences. 
Therefore, for a real natural vector 
left parenthesis n Subscript upper A comma alpha Baseline comma n Subscript upper C comma alpha Baseline comma n Subscript upper G comma alpha Baseline comma n Subscript upper T comma alpha Baseline comma mu Subscript upper A comma alpha Baseline comma mu Subscript upper C comma alpha Baseline comma mu Subscript upper G comma alpha Baseline comma mu Subscript upper T comma alpha Baseline comma upper D 2 Superscript upper A comma alpha Baseline comma upper D 2 Superscript upper C comma alpha Baseline comma upper D 2 Superscript upper G comma alpha Baseline comma upper D 2 Superscript upper T comma alpha Baseline right parenthesis comma(nA,α, nC,α, nG,α, nT,α, μA,α, μC,α, μG,α, μT,α, DA,α
2
, DC,α
2
, DG,α
2
, DT,α
2
),
which lies in the convex hull of N natural vectors 
left parenthesis n Subscript upper A comma i Baseline comma n Subscript upper C comma i Baseline comma n Subscript upper G comma i Baseline comma n Subscript upper T comma i Baseline comma mu Subscript upper A comma i Baseline comma mu Subscript upper C comma i Baseline comma mu Subscript upper G comma i Baseline comma mu Subscript upper T comma i Baseline comma upper D 2 Superscript upper A comma i Baseline comma upper D 2 Superscript upper C comma i Baseline comma upper D 2 Superscript upper G comma i Baseline comma upper D 2 Superscript upper T comma i Baseline right parenthesis comma(nA,i, nC,i, nG,i, nT,i, μA,i, μC,i, μG,i, μT,i, DA,i
2
, DC,i
2 , DG,i
2
, DT,i
2 ),
where i equals 1 comma ellipsis comma upper Ni = 1, . . . , N, there exists a solution about alpha Subscript iαi in the following equations:

122
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
StartLayout Enlarged left brace 1st Row sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline equals 1 comma alpha Subscript i Baseline greater than or equals 0 2nd Row n Subscript k comma alpha Baseline equals sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline n Subscript k comma i Baseline 3rd Row sigma summation Underscript k element of upper K Endscripts n Subscript upper K Baseline left parenthesis sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline mu Subscript k comma i Baseline right parenthesis equals one half n Subscript alpha Baseline left parenthesis n Subscript alpha Baseline plus 1 right parenthesis 4th Row sigma summation Underscript k element of upper K Endscripts n n Subscript k Baseline sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline upper D 2 Superscript k comma i Baseline plus n Subscript k Baseline left parenthesis sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline mu Subscript k comma i Baseline right parenthesis squared equals one sixth n Subscript alpha Baseline left parenthesis n Subscript alpha Baseline plus 1 right parenthesis left parenthesis 2 n Subscript alpha Baseline plus 1 right parenthesis 5th Row n Subscript alpha Baseline equals sigma summation Underscript k element of upper K Endscripts n Subscript k comma alpha Baseline EndLayout period
⎧
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩
N
i=1
αi = 1, αi ≥0
nk,α =
N
i=1
αink,i

k∈K
nK
 N
i=1
αiμk,i
	
= 1
2nα(nα + 1)

k∈K
nnk
N
i=1
αiDk,i
2
+ nk
 N
i=1
αiμk,i
	2
= 1
6nα(nα + 1)(2nα + 1)
nα = 
k∈K
nk,α
.
(7.4) 
Equation (7.4) is hard to solve directly because this is a large-scale underdeter-
mined equation of alpha Subscript iαi. Therefore, in real applications, we ﬁrst ﬁx a four-dimensional 
integer point left parenthesis n Subscript k comma alpha Baseline right parenthesis Subscript k element of upper K(nk,α)k∈K and deﬁne n Subscript alpha Baseline equals sigma summation Underscript k element of upper K Endscripts n Subscript k comma alphanα = 
k∈K
nk,α. Then we transform the existence 
of the solution of Eq. (7.4) to an optimization problem. 
StartLayout Enlarged left brace 1st Row 1st Column min Underscript ModifyingAbove alpha With right arrow Endscripts left parenthesis or max Underscript ModifyingAbove alpha With right arrow Endscripts right parenthesis 2nd Column sigma summation Underscript k element of upper K Endscripts n Subscript alpha Baseline n Subscript k comma alpha Baseline sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline upper D 2 Superscript k comma i Baseline plus n Subscript k comma alpha Baseline left parenthesis sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline mu Subscript k comma i Baseline right parenthesis squared 2nd Row 1st Column s period t period 2nd Column sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline equals 1 3rd Row 1st Column Blank 2nd Column sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline n Subscript k comma i Baseline equals n Subscript k comma alpha Baseline for all k element of upper K 4th Row 1st Column Blank 2nd Column sigma summation Underscript k element of upper K Endscripts n Subscript k comma alpha Baseline left parenthesis sigma summation Underscript i equals 1 Overscript upper N Endscripts alpha Subscript i Baseline mu Subscript k comma i Baseline right parenthesis equals StartFraction n Subscript alpha Baseline left parenthesis n Subscript alpha Baseline plus 1 right parenthesis Over 2 EndFraction 5th Row 1st Column Blank 2nd Column 0 less than or equals alpha Subscript i Baseline less than or equals 1 comma i equals 1 comma 2 comma midline horizontal ellipsis comma upper N EndLayout period
⎧
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎨
⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎪⎩
min→α(or max→α)

k∈K
nαnk,α
N
i=1
αiDk,i
2
+ nk,α
 N
i=1
αiμk,i
	2
s.t.
N
i=1
αi = 1
N
i=1
αink,i = nk,α
∀k ∈K

k∈K
nk,α
 N
i=1
αiμk,i
	
= nα(nα+1)
2
0 ≤αi ≤1,
i = 1, 2, · · · , N
.
(7.5) 
A necessary condition of a four-dimensional integer point to be the ﬁrst four 
elements of a natural vector is that the target value one sixth n Subscript alpha Baseline left parenthesis n Subscript alpha Baseline plus 1 right parenthesis left parenthesis 2 n Subscript alpha Baseline plus 1 right parenthesis 1
6nα(nα + 1)(2nα + 1) lies 
between the minimum and the maximum of the corresponding optimal problem. 
According to this condition, we can choose the candidates of the ﬁrst four elements 
of a natural vector in two steps. First, we ﬁnd the integer points of a given convex 
hull. Second, we check the necessary condition to determine the ﬁnal candidates. 
There are proven calculation methods for both two steps [110]. 
7.1.3.2 
Heuristic Methods to Detect New Sequences 
Solving the new genome detection problem as an optimization problem is proven 
to be NP-hard [111], making it challenging to ﬁnd a complete solution. Therefore, 
heuristic methods are commonly employed. In a previous discussion, we presented 
a method to estimate the nucleotide counts in a genome sequence. The objective 
of heuristic methods is to generate a sequence that has a corresponding natural

7.1
The Convex Hull Principle
123
vector within the convex hull of its family, given the nucleotide counts. In this 
section, we will introduce two approaches: the Random-permutation Algorithm 
with Penalty (RAP) and the Random-permutation Algorithm with Penalty and 
Constrained Search (RAPCOS) [111]. 
The idea of RAP is natural. After determining the counts of nucleotides, we can 
generate a sequence randomly according to the given counts. Then we randomly 
conduct a permutation, and the new sequence is recorded only when a loss function 
that describes how far the present status is from the goal decreases. If we know 
a real target natural vector that lies in the given convex hull and we want to ﬁnd 
a corresponding sequence for it, we can take the loss function as loss left parenthesis bold upper S Superscript seq Baseline right parenthesis equals d left parenthesis bold v Superscript seq Baseline comma bold v Superscript tg Baseline right parenthesisloss(Sseq) =
d(vseq, vtg), where bold v Superscript seqvseq is the input of the function and bold v Superscript tgvtg is the target natural 
vector. We can also let bold v Superscript tgvtg be a fuzzy natural vector, which may not actually be 
a natural vector but have some properties of natural vectors. For example, a 12-
dimensional vector whose corresponding Eq. (7.4) has solutions can be regarded as 
a fuzzy natural vector. 
In algebra, it is widely acknowledged that any permutation can be expressed as a 
combination of 2 cycles permutations, i.e., transpositions. In simpler terms, we can 
convert one sequence into another, provided both sequences have the same count 
of nucleotides, using a series of transpositions. Hence, it is reasonable for us to 
focus exclusively on 2 cycle permutations. During each step of a random 2 cycle 
permutation, the following actions are taken: 
1. Randomly select two nucleotides, denoted as k and q, from the set of nucleotides 
upper K equals StartSet upper A comma upper T comma upper C comma upper G EndSetK = {A, T, C, G}, where k not equals qk /= q. 
2. Choose two positions from the positions occupied by nucleotides k and q, 
respectively. Subsequently, perform the 2 cycle permutation by exchanging the 
nucleotides at the selected positions if it leads to a reduction in the loss function. 
By iteratively following these steps, the random 2 cycle permutation enables 
exploration of various nucleotide arrangements, with the objective of minimizing 
the associated loss function. 
To improve the efﬁciency of selecting two nucleotides, a penalty probability is 
utilized, which assigns varying probabilities to different nucleotides. Speciﬁcally, 
for a given nucleotide, the likelihood of selecting it for permutation increases 
as the difference between its current natural vector and the target natural vector 
grows larger. In order to account for ﬁxed counts associated with a particular 
nucleotide, both the mean position and the second-order central normalized moment 
are measured simultaneously. This implies that we consider the statistical properties 
of the nucleotide’s distribution in addition to its frequency of occurrence. 
upper P Subscript k Baseline left parenthesis bold v Superscript seq Baseline comma bold v Superscript tg Baseline right parenthesis equals StartFraction left parenthesis StartAbsoluteValue mu Subscript k Superscript seq Baseline minus mu Subscript k Superscript tg Baseline EndAbsoluteValue plus StartAbsoluteValue upper D 2 Superscript k comma seq Baseline minus upper D 2 Superscript k comma tg Baseline EndAbsoluteValue right parenthesis Over sigma summation Underscript j element of upper K Endscripts left parenthesis StartAbsoluteValue mu Subscript j Superscript seq Baseline minus mu Subscript j Superscript tg Baseline EndAbsoluteValue plus StartAbsoluteValue upper D 2 Superscript j comma seq Baseline minus upper D 2 Superscript j comma tg Baseline EndAbsoluteValue right parenthesis EndFraction periodPk(vseq, vtg) =
(|μseq
k
−μtg
k | + |Dk,seq
2
−Dk,tg
2
|)

j∈K
(|μseq
j
−μtg
j | + |Dj,seq
2
−Dj,tg
2
|)
.
(7.6) 
The algorithm ﬂowchart of RAP is shown in Algorithm 1.

124
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
Algorithm 1 Random-permutation Algorithm with Penalty (RAP) 
An 11-lin e al gorithm  with re quireme nt th at r eads, th e target n atural vec tor v t g, th e maxi mal
 it erat ion number M, a nd a preset limit eps ilon .
7.6An 
11
-line alg orithm with requ ireme nt th at r eads, the tar get na tur al vector v t 
g,
 the  maxi mal i terat ion nu mber M, and a preset  limit ep silon.
In RAP’s permutation, it often requires multiple iterations to discover a new 
sequence that minimizes the loss function. However, we can enhance the algo-
rithm’s efﬁciency by imposing constraints on the selection of nucleotides and their 
positions. During each step of the 2 cycle permutation, we choose two distinct 
nucleotides, denoted as k and q, from a set K. Following the permutation, the values 
of mu Subscript k Baseline comma mu Subscript q Baseline comma upper D 2 Superscript k Baseline commaμk, μq, Dk
2, and upper D 2 Superscript qDq
2 undergo changes. Our objective is to ensure that these four 
values simultaneously approach the target natural vector more closely than in the 
previous iteration. In the subsequent discussion, we will delve into the analysis of 
the alterations in the natural vector subsequent to the permutation. 
It is not hard to check the following result: 
Lemma 7.1 If for k element of upper Kk ∈K, mu Subscript k Superscript seq Baseline less than mu Subscript k Superscript tgμseq
k
< μtg
k , there must exist q element of upper K comma q not equals kq ∈K, q /= k, where 
mu Subscript q Superscript seq Baseline greater than mu Subscript q Superscript tgμseq
q
> μtg
q and vice versa. 
By each 2 cycle permutation, if mu Subscript kμk increases, then mu Subscript qμq decreases and vice versa. 
So it is a good idea to choose two nucleotides whose mean positions have the 
opposite relation with those of the target natural vector. According to this strategy, 
we can classify the choices of two nucleotides into eight cases. We use the letter 
normal upper GG to represent “Greater than that of the target natural vector” and use the letter normal upper LL
to represent “Lower than that of the target natural vector.” For example, the case 
upper L upper L ampersand upper G upper LLL&GL means that mu Subscript k Superscript seq Baseline less than mu Subscript k Superscript tgμseq
k
< μtg
k , upper D 2 Superscript k comma seq Baseline less than upper D 2 Superscript k comma tgDk,seq
2
< Dk,tg
2
, mu Subscript q Superscript seq Baseline greater than mu Subscript q Superscript tgμseq
q
> μtg
q , upper D 2 Superscript q comma seq Baseline less than upper D 2 Superscript q comma tgDq,seq
2
< Dq,tg
2
. 
Therefore, we have eight cases denoted as upper L upper L ampersand upper G upper LLL&GL, upper L upper L ampersand upper G upper GLL&GG, upper L upper G ampersand upper G upper LLG&GL, upper L upper G ampersand upper G upper GLG&GG, 
upper G upper L ampersand upper L upper LGL&LL, upper G upper L ampersand upper L upper GGL&LG, upper G upper G ampersand upper L upper LGG&LL, upper G upper G ampersand upper L upper GGG&LG. We can set a constraint for each case to 
ensure the reduction of the loss function. (In the statement of Theorem 7.1, we  
sometimes use mu Subscript kμk to represent mu Subscript k Superscript seqμseq
k
to make the formulas more compact.) 
Theorem 7.1 For a genome sequence bold upper S Superscript seqSseq and a target sequence bold upper S Superscript tgStg, the corre-
sponding natural vectors are bold v Superscript seqvseq and bold v Superscript tgvtg, respectively. Denote the chosen position 
in a permutation as s Subscript k Baseline comma s Subscript q Baselinesk, sq. Denote h Subscript k Baseline left parenthesis x right parenthesis equals left parenthesis n Subscript k Baseline minus 1 right parenthesis Superscript negative 1 Baseline left bracket 2 n Subscript k Baseline mu Subscript k Baseline minus left parenthesis n Subscript k Baseline plus 1 right parenthesis x right brackethk(x) = (nk −1)−1 [2nkμk −(nk + 1)x], 
g Subscript k Baseline left parenthesis x right parenthesis equals left parenthesis n Subscript k Baseline plus 1 right parenthesis Superscript negative 1 Baseline left bracket 2 n Subscript k Baseline mu Subscript k Baseline minus left parenthesis n Subscript k Baseline minus 1 right parenthesis x right bracketgk(x) = (nk + 1)−1 [2nkμk −(nk −1)x], where k element of upper Kk ∈K can be replaced by q element of upper Kq ∈K. 
And denote rho 1 equals left parenthesis n Subscript k Baseline plus n Subscript q Baseline right parenthesis Superscript negative 1 Baseline left bracket left parenthesis n Subscript q Baseline plus 1 right parenthesis n Subscript k Baseline mu Subscript k Baseline minus left parenthesis n Subscript k Baseline minus 1 right parenthesis n Subscript q Baseline mu Subscript q Baseline right bracketρ1 = (nk + nq)−1 
(nq + 1)nkμk −(nk −1)nqμq

. Then the following

7.2
Distinguishing Proteins from Arbitrary Amino Acid Sequences
125
requirement ensures that parallel to bold v Superscript new Baseline minus bold v Superscript tg Baseline parallel to less than parallel to bold v Superscript seq Baseline minus bold v Superscript tg Baseline parallel to‖vnew −vtg‖ < ‖vseq −vtg‖ for each case. Furthermore, 
it is guaranteed that StartAbsoluteValue mu Subscript k Superscript new Baseline minus mu Subscript k Superscript tg Baseline EndAbsoluteValue less than StartAbsoluteValue mu Subscript k Superscript seq Baseline minus mu Subscript k Superscript tg Baseline EndAbsoluteValue|μnew
k
−μtg
k | < |μseq
k
−μtg
k |, StartAbsoluteValue mu Subscript q Superscript new Baseline minus mu Subscript q Superscript tg Baseline EndAbsoluteValue less than StartAbsoluteValue mu Subscript q Superscript seq Baseline minus mu Subscript q Superscript tg Baseline EndAbsoluteValue|μnew
q
−μtg
q | < |μseq
q
−μtg
q |, 
StartAbsoluteValue upper D 2 Superscript k comma new Baseline minus upper D 2 Superscript k comma tg Baseline EndAbsoluteValue less than StartAbsoluteValue upper D 2 Superscript k comma seq Baseline minus upper D 2 Superscript k comma tg Baseline EndAbsoluteValue|Dk,new
2
−Dk,tg
2
| < |Dk,seq
2
−Dk,tg
2
|, StartAbsoluteValue upper D 2 Superscript q comma new Baseline minus upper D 2 Superscript q comma tg Baseline EndAbsoluteValue less than StartAbsoluteValue upper D 2 Superscript q comma seq Baseline minus upper D 2 Superscript q comma tg Baseline EndAbsoluteValue|Dq,new
2
−Dq,tg
2
| < |Dq,seq
2
−Dq,tg
2
|. 
.LL&GL: mu Subscript k Baseline less than mu Subscript qμk < μq, rho 1 less than s Subscript k Baseline less than mu Subscript qρ1 < sk < μq, maxmax left brace s Subscript k Baseline{sk,h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesis right brace less than s Subscript q Baseline less than g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesishk(sk)} < sq < gq(sk). 
.LL&GG: s Subscript q Baseline greater than max left brace s Subscript k Baseline comma h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesis comma g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesis comma mu Subscript q Baseline right bracesq > max{sk, hk(sk), gq(sk), μq}. 
.LG&GL: s Subscript k Baseline less than min left brace mu Subscript k Baseline comma mu Subscript q Baseline right bracesk < min{μk, μq}, s Subscript k Baseline less than s Subscript q Baseline less than minsk < sq < min StartSet h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesis comma g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesis EndSet{hk(sk), gq(sk)}. 
.LG&GG: s Subscript k Baseline less than min left brace mu Subscript k Baselinesk < min{μk, rho 1 comma g Subscript k Baseline left parenthesis mu Subscript q Baseline right parenthesis right braceρ1, gk(μq)}, maxmax StartSet s Subscript k Baseline comma mu Subscript q Baseline comma g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesis EndSet less than s Subscript q Baseline less than h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesis{sk, μq, gq(sk)} < sq < hk(sk). 
.GL&LL: mu Subscript k Baseline greater than mu Subscript qμk > μq, mu Subscript q Baseline less than s Subscript k Baseline less than rho 1μq < sk < ρ1, g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesis less than s Subscript q Baseline less than min left brace s Subscript k Baseline comma h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesis right bracegq(sk) < sq < min{sk, hk(sk)}. 
.GL&LG: s Subscript q Baseline less than min left brace s Subscript k Baseline comma h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesis comma g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesis comma mu Subscript q Baseline right bracesq < min{sk, hk(sk), gq(sk), μq}. 
.GG&LL: s Subscript k Baseline greater than max left brace mu Subscript k Baseline comma mu Subscript q Baseline right bracesk > max{μk, μq}, max left brace h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesismax{hk(sk), g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesis right brace less than s Subscript q Baseline less than s Subscript k Baselinegq(sk)} < sq < sk. 
.GG&LG: s Subscript k Baseline greater than max left brace mu Subscript k Baseline comma rho 1 comma g Subscript k Baseline left parenthesis mu Subscript q Baseline right parenthesis right bracesk > max{μk, ρ1, gk(μq)}, h Subscript k Baseline left parenthesis s Subscript k Baseline right parenthesis less than s Subscript q Baseline less than minhk(sk) < sq < min StartSet s Subscript k Baseline comma mu Subscript q Baseline comma g Subscript q Baseline left parenthesis s Subscript k Baseline right parenthesis EndSet{sk, μq, gq(sk)}. 
According to Theorem 7.1, RAP method can be accelerated by the constrained 
search. The framework of the algorithm is the same, while there are constraints 
when selecting the nucleotides and the positions. When selecting nucleotides k comma qk, q, 
we need left parenthesis mu Subscript k Superscript seq Baseline minus mu Subscript k Superscript tg Baseline right parenthesis left parenthesis mu Subscript q Superscript seq Baseline minus mu Subscript q Superscript tg Baseline right parenthesis greater than 0(μseq
k
−μtg
k )(μseq
q
−μtg
q ) > 0. When selecting the positions, constraints 
in Theorem 7.1 are considered. By these constraints, we can accelerate the previous 
RAP method. It is important to note that the constraints outlined in Theorem 7.1 
may be overly stringent in certain cases. Speciﬁcally, when the loss function is 
extremely close to its minimum value, it is possible that no positions satisfy the 
given requirements. In such situations, we revert to the original strategy of the RAP 
method, which involves random permutation, if the constrained search fails to yield 
any results. 
The experiments conducted in [111] demonstrate the practicality of both meth-
ods, RAP and RAPCOS, with RAPCOS exhibiting superior performance compared 
to RAP when the loss function is deﬁned as the distance between the current natural 
vector and the target natural vector. 
7.2 
Distinguishing Proteins from Arbitrary Amino Acid 
Sequences 
Protein sequences are composed of amino acids and can be identiﬁed as valid protein 
sequences if they meet certain criteria. While known proteins represent only a small 
fraction of all possible combinations of amino acids, efforts have been made to 
understand the structure of existing protein sequences in order to deﬁne the protein 
universe. However, we still need some criterion for determining whether an arbitrary 
amino acid sequence can be classiﬁed as a protein. 
It was discovered that when arbitrary amino acid sequences are examined within 
a suitable geometric framework, protein sequences tend to cluster together. This 
observation has led to the development of a new computational test. Remarkably, 
this test has demonstrated a high level of accuracy in determining whether an 
arbitrary amino acid sequence has the characteristics of a protein.

126
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
This section presents a computational test, as described in [112], with an 
accuracy of 99.69% for determining the protein potential of an arbitrary amino acid 
sequence. Our test provides a rapid means to assess whether a given amino acid 
sequence has the characteristics of a protein. It relies on the observation that natural 
vectors of genuine protein sequences exhibit clustering behavior, aligning with the 
principle of convex hull. 
7.2.1 
The Principle and the Algorithm 
For each amino acid sequence, we consider the 60-dimensional natural vector to 
represent this property: 
left parenthesis n Subscript upper A Baseline comma n Subscript upper R Baseline comma ellipsis comma n Subscript upper V Baseline comma mu Subscript upper A Baseline comma mu Subscript upper R Baseline comma ellipsis comma mu Subscript upper V Baseline comma upper D 2 Superscript upper A Baseline comma upper D 2 Superscript upper R Baseline comma ellipsis comma upper D 2 Superscript upper V Baseline right parenthesis period(nA, nR, . . . , nV , μA, μR, . . . , μV , DA
2 , DR
2 , . . . , DV
2 ).
(7.7) 
To begin, we establish the one-to-one nature of the mapping. While theoretically, 
we cannot guarantee one-to-one correspondence due to insufﬁcient order, this is 
not the case with actual protein sequences. The primary outcome of this section 
is the pivotal ﬁnding that, by gathering all known and reviewed complete protein 
sequences submitted prior to March 6, 2013, from the UniprotKB database [113], 
and calculating their natural vectors, we conﬁrm that the 60-dimensional natural 
vector representation indeed exhibits one-to-one correspondence with known pro-
tein sequences. 
To gain insight into the distribution of protein space within the amino acid 
sequence space, we employ a visualization technique by plotting the points along 
two coordinate axes associated with the amino acid Alanine (A). Figure 7.4a and b 
depicts the two-dimensional projection onto the left parenthesis n Subscript upper A Baseline comma mu Subscript upper A Baseline right parenthesis(nA, μA) coordinate plane, while 
c and d illustrates its projection onto the left parenthesis n Subscript upper A Baseline comma upper D 2 Superscript upper A Baseline right parenthesis(nA, DA
2 ) coordinate plane. These visual 
representations provide a clearer understanding of how the points in protein space 
are distributed relative to the amino acid sequence space. 
In the left parenthesis n Subscript upper A Baseline comma mu Subscript upper A Baseline right parenthesis(nA, μA) coordinate plane, the projection of amino acid space is bounded 
by the following three lines: 
mu Subscript upper A comma m i n Baseline colon mu Subscript upper A Baseline equals StartFraction n Subscript upper A Baseline plus 1 Over 2 EndFractionμA,min : μA = nA + 1
2
(7.8) 
mu Subscript upper A comma m a x Baseline colon mu Subscript upper A Baseline equals StartFraction 2 n plus 1 minus n Subscript upper A Baseline Over 2 EndFractionμA,max : μA = 2n + 1 −nA
2
(7.9) 
n Subscript upper A Baseline equals 0 periodnA = 0.
(7.10) 
In the left parenthesis n Subscript upper A Baseline comma upper D 2 Superscript upper A Baseline right parenthesis(nA, DA
2 ) coordinate plane, the projection of the amino acid space is 
bounded by the following three curves:

7.2
Distinguishing Proteins from Arbitrary Amino Acid Sequences
127
Fig. 7.4 The Alanine convex hull was computed using the Uniprot 2013_03 dataset. The blue 
points in each of the four subﬁgures represent vectors corresponding to proteins. Subﬁgure (a) 
illustrates the projection onto the left parenthesis n Subscript upper A Baseline comma mu Subscript upper A Baseline right parenthesis(nA, μA) coordinate plane, while subﬁgure (c) depicts the 
projection onto the left parenthesis n Subscript upper A Baseline comma upper D 2 Superscript upper A Baseline right parenthesis(nA, DA
2 ) coordinate plane. Subﬁgure (b) provides an enlarged view of the 
protein area in (a), with black lines indicating the boundaries of the convex hull. Similarly, 
subﬁgure (d) presents an enlarged view of the protein area in (c), with black lines representing 
the boundaries of the convex hull 
upper D Subscript 2 comma m i n Superscript upper A Baseline colon upper D 2 Superscript upper A Baseline equals StartFraction n Subscript upper A Superscript 2 Baseline minus 1 Over 12 n EndFractionDA
2,min : DA
2 = n2
A −1
12n
(7.11)

128
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
upper D Subscript 2 comma m a x Superscript upper A Baseline colon upper D 2 Superscript upper A Baseline equals StartLayout Enlarged left brace 1st Row 1st Column StartFraction n minus n Subscript upper A Baseline Over 4 EndFraction plus StartFraction n Subscript upper A Superscript 2 Baseline Over 12 n EndFraction minus StartFraction 1 Over 12 n EndFraction 2nd Column if n Subscript upper A Baseline is even 2nd Row 1st Column StartFraction left parenthesis n Subscript upper A Baseline minus 1 right parenthesis left parenthesis n Subscript upper A Baseline plus 1 right parenthesis left parenthesis n minus n Subscript upper A Baseline right parenthesis Over 4 n Subscript upper A Superscript 2 Baseline EndFraction plus StartFraction n Subscript upper A Superscript 2 Baseline Over 12 n EndFraction minus StartFraction 1 Over 12 n EndFraction 2nd Column if n Subscript upper A Baseline is odd EndLayoutDA
2,max : DA
2 =
⎧
⎪⎪⎨
⎪⎪⎩
n −nA
4
+ n2
A
12n −
1
12n
if nA is even
(nA −1)(nA + 1)(n −nA)
4n2
A
+ n2
A
12n −
1
12n if nA is odd
(7.12) 
n Subscript upper A Baseline equals 0 periodnA = 0.
(7.13) 
We will prove these boundaries in the ﬁnal part of this chapter. 
In these equations, n represents the maximum length of proteins in the dataset. 
For the collection of known, reviewed complete protein sequences found in the 
UniprotKB data as of March 6, 2013, it is determined that n equals 35,213n = 35,213. 
From Fig. 7.4, it is evident that the points in the protein space are clustered 
rather than widely distributed. This observation leads us to believe that as new 
protein sequences are discovered, their corresponding points will likely fall within 
the approximate boundaries of the convex hull formed by the points corresponding 
to known protein sequences. 
Although we can directly deal with the convex hull in the 60-dimensional space, 
it is more efﬁcient to deal with the convex hull of left parenthesis n Subscript k Baseline comma mu Subscript k Baseline comma upper D 2 Superscript k Baseline right parenthesis(nk, μk, Dk
2) for each amino acid 
k in the 3-dimensional space. We use the word the k-protein area to represent the set 
of points left parenthesis n Subscript k Baseline comma mu Subscript k Baseline comma upper D 2 Superscript k Baseline right parenthesis(nk, μk, Dk
2). 
Several tests have been conducted to demonstrate the stability of the boundaries 
of these protein areas over time, even as more proteins are described. These tests 
serve as robust evidence supporting the validity of the following computational test. 
In order to determine if an arbitrary amino acid sequence can be classiﬁed as a 
protein sequence, the following steps are undertaken: 
1. The natural vector of the amino acid sequence is computed. 
2. A pre-computed vector database containing natural vectors corresponding to 
known protein sequences is established. 
3. If the natural vector of the amino acid sequence is found within the vector 
database, we check whether the amino acid sequence is a known sequence. It 
is concluded that the amino acid sequence is a protein only if it is identical to a 
known protein sequence, as a result of the one-to-one correspondence between 
natural vectors and protein sequences. 
4. In the event that the natural vector of the amino acid sequence is not in the vector 
database, we need to verify the inclusion of each of the 20 points left parenthesis n Subscript k Baseline comma mu Subscript k Baseline comma upper D 2 Superscript k Baseline right parenthesis(nk, μk, Dk
2) in 
a 3-dimensional space within their respective convex hulls for the corresponding 
k-protein areas. If all of these checks prove successful, it can be concluded that 
this amino acid sequence has the potential to be categorized as a real protein. 
Conversely, if not all points lie within their corresponding convex hulls, the 
second key result suggests that the amino acid sequence is unlikely to be a protein 
sequence.

7.2
Distinguishing Proteins from Arbitrary Amino Acid Sequences
129
7.2.2 
The Veriﬁcation by Real Protein Sequences 
To validate our algorithm, we utilize three snapshots of the UniprotKB database: 
Uniprot 2013_03 (March 6, 2013), Uniprot 2014_03 (March 19, 2014), and Uniprot 
2014_06 (June 11, 2014). In each instance, we exclusively consider the reviewed 
and complete proteins for analysis and evaluation. 
We employ a consistent methodology to generate all three datasets. We 
include the keyword “Complete proteome[KW-0181]” to exclusively select 
complete sequences, thereby eliminating any sequences with missing amino acids. 
Additionally, we incorporate the keyword “Reviewed” to narrow down the dataset 
to only reviewed proteins. Redundant sequences are not reduced during this process. 
Following the download, the datasets undergo normalization by removing protein 
sequences that contain Selenocysteine (U) and Pyrrolysine (O), as well as sequences 
containing placeholders (B, Z, J, X). The resulting datasets are then subjected to a 
cleaning process. Table 7.1 presents the sequence numbers for each dataset after this 
cleaning process: 
To verify the one-to-one correspondence for 60-dimensional natural vectors, we 
utilize the Uniprot 2013_03 and Uniprot 2014_03 datasets. The analysis reveals that 
the number of unique protein sequences in each dataset is equivalent to the number 
of distinct natural vectors. This ﬁnding suggests that there is a direct mapping 
between protein sequences and the corresponding 60-dimensional natural vectors 
in both datasets. 
We conducted multiple tests to assess the effectiveness of our computational 
method in determining the proteinogenic nature of a given amino acid sequence. 
Initially, we utilized the 391,704 distinct protein sequences present in both 
Uniprot 2013_03 and Uniprot 2014_03 datasets to generate twenty 3-dimensional 
convex hulls using the Qhull algorithm in MATLAB software. Subsequently, 
we examined the 3810 sequences exclusively present in Uniprot 2014_03 to 
determine how many of them fell outside the boundaries of the twenty convex 
hulls. Surprisingly, only 14 sequences (equivalent to a mere 0.37% of the 3810 
Table 7.1 Detailed counts of sequences in the three snapshots of UniprotKB 
Number of distinct sequences in Uniprot 2013_03
392,455 
Number of distinct sequences in Uniprot 2014_04
395,514 
Number of distinct sequences in Uniprot 2014_06
397,348 
Number of distinct sequences in Uniprot 2013_03 and Uniprot 2014_04
391,704 
Number of distinct sequences contained in all three datasets
391,528 
Number of sequences in Uniprot 2013_03 but not Uniprot 2014_03
751 
Number of sequences in Uniprot 2014_03 but not Uniprot 2013_03
3810 
Number of sequences in Uniprot 2013_03 and Uniprot 2014_03, but not Uniprot 
2014_06 
176 
Number of sequences in Uniprot 2014_06 but not in the intersection of Uniprot 
2013_03 
and Uniprot 2014_03
5820

130
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
Table 7.2 The 14 protein sequence outliers in Uniprot 2014_03 and their distances from the 
convex hulls 
No. 
Sequence 
length
Access ID 
Convex hull the 
sequences fall outside 
Distance to convex 
hull 
1
11
P85817
Asparagine (N)
0.0177 
2
16
P81071
Aspartic acid (D)
0.0110 
3
19
P68116
Aspartic acid (D)
0.0018 
4
20
P14469
Isoleucine (I)
0.003 
5
199
Q9ZVZ9
Histidine (H)
0.0000208 
6
211
P33191
Tyrosine (Y)
0.0027 
7
237
Q6M923
Glutamine (Q)
0.0362 
8
287
P50751
Proline (P)
0.0044 
9
392
Q5A8I8
Proline (P)
33.9023 
10
1086
Q59XL0
Methionine (M)
0.4508 
11
1129
Q9QR71
Glutamic acid (E)
5.5955 
Glutamine (Q)
1.4455 
12
1404
Q59SG9
Serine (S)
0.2427 
13
2346
A1Z8P9
Glycine (G)
0.2179 
14
3461
P62288
Arginine (R)
1.8593 
sequences) were found to lie outside one of the convex hulls. It is worth noting 
that none of these 14 sequences was signiﬁcantly distant from the convex hull 
boundaries. The details of these sequences, along with their respective distances 
from the convex hulls, are presented in Table 7.2. Furthermore, Fig. 7.5 visually 
illustrates one of the 14 sequences positioned outside a convex hull. Additionally, 
we repeated the process using all 392,455 sequences from Uniprot 2013_03, and the 
results remained consistent. 
Next, we proceeded to calculate new convex hulls using the aforementioned 
391,704 protein sequences combined with the 14 sequences that did not pass the 
ﬁrst test. Subsequently, we examined each of the 5820 sequences present in Uniprot 
2014_06 but not found in the intersection of Uniprot 2013_03 and Uniprot 2014_03 
to determine how many of them failed to fall within any of the convex hulls. 
Remarkably, only 18 sequences (equivalent to a mere 0.31% of the 5820 sequences) 
were found to lie outside one of the convex hulls. Similar to the previous test, none 
of these 18 sequences were signiﬁcantly distant from the convex hull boundaries. 
Table 7.3 provides a detailed list of these 18 sequences along with their respective 
distances from their corresponding convex hulls. 
In the ﬁnal test, we examined whether the protein sequences from Top 7 [114], 
HOP2 [115], and GLUT1 [116] were located within the convex hulls constructed 
using the sequences present in both Uniprot 2013_03 and Uniprot 2014_03. As 
anticipated, all three proteins were found to lie inside the twenty convex hulls. This 
result aligns with our expectations. 
Indeed, the results of our tests are promising. Although there were a few 
proteins that fell outside at least one of the convex hulls, the percentage of proteins

7.2
Distinguishing Proteins from Arbitrary Amino Acid Sequences
131
Fig. 7.5 The protein sequence with Access ID P85817 is identiﬁed as lying outside the convex 
hull corresponding to Asparagine. In subﬁgure (a), the cyan surfaces represent the convex hulls in 
3-dimensional space, while the red point represents the coordinate n Subscript upper N Baseline comma mu Subscript upper N Baseline comma upper D 2 Superscript upper NnN, μN, DN
2 for this particular 
sequence. Subﬁgure (b) provides an enlarged view of subﬁgure (a), clearly demonstrating that the 
point falls outside the boundaries of the convex hull 
Table 7.3 The 18 protein sequence outliers from Uniprot 2014_06 and their distances from the 
convex hulls 
No. 
Sequence 
length
Access ID 
Convex hull the 
sequences fall outside 
Distance to convex 
hull 
1
20
P82867
Aspartic acid (D)
0.0045 
2
19
P68214
Aspartic acid (D)
0.0309 
3
15
P80612
Alanine (A)
0.3850 
4
267
P14918
Arginine (R)
0.0000042949 
5
150
P27787
Phenylalanine (F)
0.00025511 
6
372
Q5AKU5
Histidine (H)
0.00013742 
7
105
Q2RB28
Leucine (L)
0.000053612 
8
105
B9GBM3
Leucine (L)
0.000053612 
9
94
Q5G8Z3
Aspartic acid (D)
0.0022 
10
391
P46525
Serine (S)
0.1044 
11
838
P08489
Methionine (M)
0.0840 
Valine (V)
3.0627 
12
848
P10388
Glutamic acid (E)
0.1269 
Methionine (M)
0.1408 
Valine (V)
3.1465 
13
240
P04702
Glycine (G)
0.000036147 
14
240
P06677
Glycine (G)
0.000036147 
15
240
P04703
Glycine (G)
0.000036147 
16
240
P06676
Glycine (G)
0.000036147 
17
267
P04698
Glycine (G)
0.000070559 
18
187
B6U769
Proline (P)
0.0037

132
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
failing the test is relatively small in both cases (0.37% and 0.31%). Furthermore, 
it is noteworthy that the proteins not contained within a convex hull are never 
signiﬁcantly distant from the boundary of the convex hull. This suggests that as more 
protein sequence data become available, the computed convex hulls will become 
increasingly reliable and eventually stabilize, providing an accurate and efﬁcient 
method for determining whether a given amino acid sequence can be classiﬁed as a 
protein sequence. These ﬁndings provide a strong indication that the approach holds 
great potential for practical applications in protein sequence analysis. 
We anticipate that researchers in two distinct domains will employ this test. 
Protein designers seeking to synthesize novel proteins can utilize this test to rapidly 
identify amino acid sequences that are unlikely to fold into functional proteins, 
thus saving resources on costly laboratory synthesis efforts. Likewise, biologists 
investigating alternative splicing [117] now possess a novel tool for predicting the 
production of authentic protein sequences resulting from alternative splicing events. 
7.2.3 
Derivation for the Equations of the Boundaries of Amino 
Acid Space 
Finally, we derive the equations of the boundaries introduced before rigorously. 
7.2.3.1 
The Boundaries of Amino Acid k in the (nk, μk) Plane 
Our objective is to determine the minimum value mu Subscript k comma minμk,min and maximum value mu Subscript k comma maxμk,max
of the mean for sequences of length n that contain n Subscript knk instances of the amino acid k. 
Theorem 7.2 Let n Subscript knk be the number of occurrences of amino acid k in a sequence 
of length n. Then: 
(a) 
mu Subscript k comma m i n Baseline equals StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction periodμk,min = nk + 1
2
.
(7.14) 
(b) 
mu Subscript k comma m a x Baseline equals StartFraction 2 n minus n Subscript k Baseline plus 1 Over 2 EndFraction periodμk,max = 2n −nk + 1
2
.
(7.15) 
Proof 
(a) Obviously, if we choose the amino acid k to be distributed in positions x 1 equals 1x1 = 1, 
x 2 equals 2x2 = 2, ellipsis. . . , x Subscript n Sub Subscript k Baseline equals n Subscript kxnk = nk, then we will get the minimum value of mu Subscript kμk that is

7.2
Distinguishing Proteins from Arbitrary Amino Acid Sequences
133
mu Subscript k comma m i n Baseline equals StartFraction 1 plus 2 plus midline horizontal ellipsis plus n Subscript k Baseline Over n Subscript k Baseline EndFraction equals StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction periodμk,min = 1 + 2 + · · · + nk
nk
= nk + 1
2
.
(7.16) 
(b) Similarly, if we choose the amino acid k to be distributed in positions x 1 equals n plus 1 minus n Subscript kx1 =
n + 1 −nk, x 2 equals n plus 2 minus n Subscript kx2 = n + 2 −nk, ellipsis. . . , x Subscript n Sub Subscript k Baseline equals nxnk = n, then we will get the maximum value 
of mu Subscript kμk that is 
StartLayout 1st Row 1st Column mu Subscript k comma m a x Baseline equals 2nd Column sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts StartFraction n plus i minus n Subscript k Baseline Over n Subscript k Baseline EndFraction 2nd Row 1st Column equals 2nd Column StartStartFraction n Subscript k Baseline left parenthesis n minus n Subscript k Baseline right parenthesis plus StartFraction n Subscript k Baseline left parenthesis n Subscript k Baseline plus 1 right parenthesis Over 2 EndFraction OverOver n Subscript k Baseline EndEndFraction 3rd Row 1st Column equals 2nd Column StartFraction 2 n minus n Subscript k Baseline plus 1 Over 2 EndFraction EndLayout period
μk,max =
nk

i=1
n + i −nk
nk
=
nk(n −nk) + nk(nk + 1)
2
nk
= 2n −nk + 1
2
.
(7.17) 
Remark 7.1 The equation mu Subscript k Baseline equals StartFraction n Subscript k Baseline plus 1 Over 2 EndFractionμk = nk+1
2
represents the lower boundary of the region, 
where 1 less than or equals n Subscript k Baseline less than or equals c1 ≤nk ≤c. Similarly, the equation mu Subscript k Baseline equals StartFraction 2 c minus n Subscript k Baseline plus 1 Over 2 EndFractionμk = 2c−nk+1
2
represents the upper 
boundary of the region, where 1 less than or equals n Subscript k Baseline less than or equals c1 ≤nk ≤c. In these equations, c represents the 
maximum length of the sequences in our dataset. 
7.2.3.2 
The Boundaries of Amino Acid k in the (nk, Dk 
2) Plane 
To begin, we aim to ﬁnd the maximum value upper D Subscript 2 comma max Superscript kDk
2,max of the second normalized 
moment for sequences of length n that contain n Subscript knk instances of the amino acid k. 
Lemma 7.2 Let mu left parenthesis dot right parenthesisμ(·) be the average function. Deﬁne 
upper F left parenthesis x right parenthesis equals left parenthesis x minus mu left parenthesis x comma x 1 comma ellipsis comma x Subscript m Baseline right parenthesis right parenthesis squared plus sigma summation Underscript i equals 1 Overscript m Endscripts left parenthesis x Subscript i Baseline minus mu left parenthesis x comma x 1 comma ellipsis comma x Subscript m Baseline right parenthesis right parenthesis squared periodF(x) = (x −μ(x, x1, . . . , xm))2 +
m

i=1
(xi −μ(x, x1, . . . , xm))2.
Then upper F left parenthesis x right parenthesis greater than upper F left parenthesis y right parenthesisF(x) > F(y) if and only if 
StartAbsoluteValue x minus mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesis EndAbsoluteValue greater than StartAbsoluteValue y minus mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesis EndAbsoluteValue period|x −μ(x1, . . . , xm)| > |y −μ(x1, . . . , xm)|.
(x is not necessary to be an integer in this lemma.) 
Proof 
StartLayout 1st Row 1st Column upper F prime left parenthesis x right parenthesis equals 2nd Column StartFraction 2 m Over m plus 1 EndFraction left parenthesis x minus mu left parenthesis x comma x 1 comma ellipsis comma x Subscript m Baseline right parenthesis right parenthesis minus StartFraction 2 Over m plus 1 EndFraction sigma summation Underscript i equals 1 Overscript m Endscripts left parenthesis x Subscript i Baseline minus mu left parenthesis x comma x 1 comma ellipsis comma x Subscript m Baseline right parenthesis right parenthesis 2nd Row 1st Column equals 2nd Column 2 left parenthesis x minus mu left parenthesis x comma x 1 comma ellipsis comma x Subscript m Baseline right parenthesis right parenthesis EndLayoutF '(x) =
2m
m+1(x −μ(x, x1, . . . , xm)) −
2
m+1
m

i=1
(xi −μ(x, x1, . . . , xm))
= 2(x −μ(x, x1, . . . , xm))
(7.18)

134
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
upper F double prime left parenthesis x right parenthesis equals 2 StartFraction m Over m plus 1 EndFraction greater than 0 periodF ''(x) = 2
m
m + 1 > 0.
(7.19) 
Since upper F prime left parenthesis x right parenthesis equals 0 long left right double arrow x equals mu left parenthesis x comma x 1 comma ellipsis comma x Subscript m Baseline right parenthesis long left right double arrow x equals mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesisF '(x) = 0
⇐⇒
x = μ(x, x1, . . . , xm)
⇐⇒
x = μ(x1, . . . , xm), 
we know that upper F left parenthesis x right parenthesisF(x) increases when x greater than mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesisx > μ(x1, . . . , xm) and decreases when x less than mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesisx <
μ(x1, . . . , xm). Furthermore, from the form of upper F prime left parenthesis x right parenthesisF '(x), it is not hard to check that 
upper F left parenthesis x right parenthesisF(x) is symmetric about the line x equals mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesisx = μ(x1, . . . , xm). Therefore, upper F left parenthesis x right parenthesis greater than upper F left parenthesis y right parenthesisF(x) > F(y) if 
and only if StartAbsoluteValue x minus mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesis EndAbsoluteValue greater than StartAbsoluteValue y minus mu left parenthesis x 1 comma ellipsis comma x Subscript m Baseline right parenthesis EndAbsoluteValue period|x −μ(x1, . . . , xm)| > |y −μ(x1, . . . , xm)|.
Now, we can determine the speciﬁc distribution of the amino acid k where the 
maximum value of the second normalized moment is assumed. 
Theorem 7.3 Let 0 less than n Subscript k Baseline less than or equals n0 < nk ≤n be ﬁxed positive integers. Consider a distribution 
of the amino acid k given by 1 less than or equals x 1 less than x 2 less than midline horizontal ellipsis less than x Subscript n Sub Subscript k Baseline less than or equals n1 ≤x1 < x2 < · · · < xnk ≤n. If the second 
normalized moment upper D 2 Superscript k Baseline left parenthesis x right parenthesisDk
2(x) achieves the maximum value upper D Subscript 2 comma max Superscript kDk
2,max among all possible 
distributions, then the values x 1 comma x 2 comma ellipsis comma x Subscript n Sub Subscript k Subscript Baselinex1, x2, . . . , xnk follow a speciﬁc pattern. 
n Sub scr
ipt knk even integer: 
StartLayout 1st Row x 1 equals 1 comma x 2 equals 2 comma ellipsis comma x Subscript StartFraction n Sub Subscript k Subscript Over 2 EndFraction Baseline equals StartFraction n Subscript k Baseline Over 2 EndFraction comma x Subscript StartFraction n Sub Subscript k Subscript Over 2 EndFraction plus 1 Baseline equals n plus 1 minus StartFraction n Subscript k Baseline Over 2 EndFraction comma 2nd Row x Subscript StartFraction n Sub Subscript k Subscript Over 2 EndFraction plus 2 Baseline equals n plus 2 minus StartFraction n Subscript k Baseline Over 2 EndFraction comma ellipsis comma x Subscript n Sub Subscript k Subscript Baseline equals n period EndLayout
x1 = 1, x2 = 2, . . . , x nk
2 = nk
2 , x nk
2 +1 = n + 1 −nk
2 ,
x nk
2 +2 = n + 2 −nk
2 , . . . , xnk = n.
(7.20) 
n Sub scr
ipt knk odd integer: 
StartLayout 1st Row x 1 equals 1 comma x 2 equals 2 comma ellipsis comma x Subscript StartFraction n Sub Subscript k Subscript minus 1 Over 2 EndFraction Baseline equals StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction comma x Subscript StartFraction n Sub Subscript k Subscript plus 1 Over 2 EndFraction plus 1 Baseline equals StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction comma 2nd Row x Subscript StartFraction n Sub Subscript k Subscript plus 1 Over 2 EndFraction plus 1 Baseline equals n plus 1 minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction comma x Subscript StartFraction n Sub Subscript k Subscript plus 1 Over 2 EndFraction plus 2 Baseline equals n plus 2 minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction comma ellipsis comma x Subscript n Sub Subscript k Subscript Baseline equals n period EndLayout
x1 = 1, x2 = 2, . . . , x nk−1
2
= nk−1
2 , x nk+1
2
+1 = nk+1
2 ,
x nk+1
2
+1 = n + 1 −nk−1
2 , x nk+1
2
+2 = n + 2 −nk−1
2 , . . . , xnk = n.
(7.21) 
Proof We will focus on proving the case when n Subscript knk is an even integer, as the proof 
for the case when n Subscript knk is an odd integer follows a similar logic. 
We ﬁrst show that the amino acid k piles on the two sides when upper D 2 Superscript k Baseline left parenthesis x right parenthesisDk
2(x) attains 
the maximum value. That is, there exist I and J such that x Subscript i Baseline equals ixi = i when 1 less than or equals i less than or equals upper I1 ≤i ≤I
and x Subscript n Sub Subscript k Subscript minus j plus 1 Baseline equals n minus j plus 1xnk−j+1 = n −j + 1 when 1 less than or equals j less than or equals upper J1 ≤j ≤J (upper I plus upper J equals n Subscript kI + J = nk). Otherwise, there exist 
x Subscript ixi and two positions l 1 comma l 2l1, l2 not in StartSet x 1 comma ellipsis comma x Subscript n Baseline EndSet{x1, . . . , xn} such that l 1 less than x 1 less than l 2l1 < x1 < l2. Since one of 
StartAbsoluteValue l 1 minus mu Subscript negative i Baseline EndAbsoluteValue|l1 −μ−i| and StartAbsoluteValue l 2 minus mu Subscript negative i Baseline EndAbsoluteValue|l2 −μ−i| will be larger than StartAbsoluteValue x Subscript i Baseline minus mu Subscript negative i Baseline EndAbsoluteValue|xi −μ−i|, upper D 2 left parenthesis x right parenthesisD2(x) increases if swapping 
x Subscript ixi to position from l 1l1 and l 2l2 that are farther away from the center. (mu Subscript negative iμ−i is the average 
position of StartSet x 1 comma ellipsis x Subscript n Baseline EndSet minus StartSet x Subscript i Baseline EndSet{x1, . . . xn} \ {xi}). 
Then we show that upper I equals StartFraction n Subscript k Baseline Over 2 EndFractionI = nk
2 . Otherwise, without the loss of generality, we assume 
upper I greater than StartFraction n Subscript k Baseline Over 2 EndFractionI > nk
2 . Then mu Subscript k Baseline less than StartFraction n plus 1 Over 2 EndFractionμk < n+1
2 . Therefore, upper D 2 left parenthesis x right parenthesisD2(x) increases if swapping x Subscript upper IxI to n minus upper Jn−J, which 
leads to contradiction. 
Theorem 7.4 For a ﬁxed positive integer 0 less than n Subscript k Baseline less than or equals n0 < nk ≤n, the maximum value upper D Subscript 2 comma max Superscript k comma nDk,n
2,max
among all possible distributions 1 less than or equals x 1 less than x 2 less than midline horizontal ellipsis less than x Subscript n Sub Subscript k Baseline less than or equals n1 ≤x1 < x2 < · · · < xnk ≤n of amino acid k can 
be determined using the following formulas: 
(1) 
. nk even, then mu Subscript k Baseline equals StartFraction n plus 1 Over 2 EndFractionμk = n + 1
2

7.2
Distinguishing Proteins from Arbitrary Amino Acid Sequences
135
upper D Subscript 2 comma m a x Superscript k comma n Baseline equals one fourth n plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction minus one fourth n Subscript k Baseline periodDk,n
2,max = 1
4n + n2
k −1
12n
−1
4nk.
(7.22) 
(2) 
. nk odd, then mu Subscript k Baseline equals StartFraction n n Subscript k Baseline minus n plus 2 n Subscript k Baseline Over 2 n Subscript k Baseline EndFractionμk = nnk −n + 2nk
2nk
upper D Subscript 2 comma m a x Superscript k comma n Baseline equals StartFraction left parenthesis n Subscript k Superscript 2 Baseline minus 1 right parenthesis n Over 4 n Subscript k Superscript 2 Baseline EndFraction plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction minus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 4 n Subscript k Baseline EndFraction periodDk,n
2,max = (n2
k −1)n
4n2
k
+ n2
k −1
12n
−n2
k −1
4nk
.
(7.23) 
Proof 
(1) If n Subscript knk is even, in view of Theorem 7.3, we have  
mu Subscript k Baseline equals StartFraction n plus 1 Over 2 EndFractionμk = n + 1
2
(7.24) 
StartLayout 1st Row 1st Column n Subscript k Baseline n upper D Subscript 2 comma m a x Superscript k comma n 2nd Column equals sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline Over 2 EndFraction Endscripts left parenthesis x Subscript i Baseline minus StartFraction n plus 1 Over 2 EndFraction right parenthesis squared plus sigma summation Underscript i equals StartFraction n Subscript k Baseline Over 2 EndFraction plus 1 Overscript n Subscript k Baseline Endscripts left parenthesis x Subscript i Baseline minus StartFraction n plus 1 Over 2 EndFraction right parenthesis squared 2nd Row 1st Column Blank 2nd Column equals sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline Over 2 EndFraction Endscripts left parenthesis i minus StartFraction n plus 1 Over 2 EndFraction right parenthesis squared plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline Over 2 EndFraction Endscripts left parenthesis n plus i minus StartFraction n Subscript k Baseline Over 2 EndFraction minus StartFraction n plus 1 Over 2 EndFraction right parenthesis squared 3rd Row 1st Column Blank 2nd Column equals sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline Over 2 EndFraction Endscripts left parenthesis i minus StartFraction n plus 1 Over 2 EndFraction right parenthesis squared plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline Over 2 EndFraction Endscripts left parenthesis i plus StartFraction n minus n Subscript k Baseline minus 1 Over 2 EndFraction right parenthesis squared 4th Row 1st Column Blank 2nd Column equals one sixth dot StartFraction n Subscript k Baseline Over 2 EndFraction left parenthesis StartFraction n Subscript k Baseline Over 2 EndFraction plus 1 right parenthesis left parenthesis n Subscript k Baseline plus 1 right parenthesis minus left parenthesis n plus 1 right parenthesis StartStartFraction StartFraction n Subscript k Baseline Over 2 EndFraction left parenthesis StartFraction n Subscript k Baseline Over 2 EndFraction plus 1 right parenthesis OverOver 2 EndEndFraction plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline Over 2 EndFraction Endscripts StartFraction left parenthesis n plus 1 right parenthesis squared Over 4 EndFraction 5th Row 1st Column Blank 2nd Column plus one sixth dot StartFraction n Subscript k Baseline Over 2 EndFraction left parenthesis StartFraction n Subscript k Baseline Over 2 EndFraction plus 1 right parenthesis left parenthesis n Subscript k Baseline plus 1 right parenthesis plus left parenthesis n minus n Subscript k Baseline minus 1 right parenthesis StartStartFraction StartFraction n Subscript k Baseline Over 2 EndFraction left parenthesis StartFraction n Subscript k Baseline Over 2 EndFraction plus 1 right parenthesis OverOver 2 EndEndFraction 6th Row 1st Column Blank 2nd Column plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline Over 2 EndFraction Endscripts StartFraction left parenthesis n minus n Subscript k Baseline minus 1 right parenthesis squared Over 4 EndFraction 7th Row 1st Column Blank 2nd Column equals StartFraction n Subscript k Superscript 3 Baseline minus n Subscript k Baseline plus 3 n Subscript k Baseline left parenthesis n squared minus n n Subscript k Baseline right parenthesis Over 12 EndFraction EndLayout
nknDk,n
2,max =
nk
2

i=1
(xi −n + 1
2
)2 +
nk

i= nk
2 +1
(xi −n + 1
2
)2
=
nk
2

i=1
(i −n + 1
2
)2 +
nk
2

i=1
(n + i −nk
2 −n + 1
2
)2
=
nk
2

i=1
(i −n + 1
2
)2 +
nk
2

i=1
(i + n −nk −1
2
)2
= 1
6 · nk
2 (nk
2 + 1)(nk + 1) −(n + 1)
nk
2 ( nk
2 + 1)
2
+
nk
2

i=1
(n + 1)2
4
+ 1
6 · nk
2 (nk
2 + 1)(nk + 1) + (n −nk −1)
nk
2 ( nk
2 + 1)
2
+
nk
2

i=1
(n −nk −1)2
4
= n3
k −nk + 3nk(n2 −nnk)
12
(7.25) 
upper D Subscript 2 comma m a x Superscript k comma n Baseline equals StartFraction 1 Over n Subscript k Baseline n EndFraction StartFraction n Subscript k Superscript 3 Baseline minus n Subscript k Baseline plus 3 n Subscript k Baseline left parenthesis n squared minus n n Subscript k Baseline right parenthesis Over 12 EndFraction equals one fourth n plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction minus one fourth n Subscript k Baseline periodDk,n
2,max =
1
nkn
n3
k −nk + 3nk(n2 −nnk)
12
= 1
4n + n2
k −1
12n
−1
4nk.
(7.26)

136
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
(2) If n Subscript knk is odd, then in view of Theorem 7.3 
StartLayout 1st Row 1st Column mu Subscript k 2nd Column equals StartFraction 1 Over n Subscript k Baseline EndFraction left bracket sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction Endscripts i plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction Endscripts left parenthesis n plus i minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction right parenthesis right bracket 2nd Row 1st Column Blank 2nd Column equals StartFraction 1 Over n Subscript k Baseline EndFraction left bracket 2 sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction Endscripts i plus StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction plus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction left parenthesis n minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction right parenthesis right bracket 3rd Row 1st Column Blank 2nd Column equals StartFraction n n Subscript k Baseline minus n plus 2 n Subscript k Baseline Over 2 n Subscript k Baseline EndFraction EndLayout
μk = 1
nk

nk+1
2

i=1
i +
nk−1
2

i=1
(n + i −nk −1
2
)

= 1
nk

2
nk−1
2

i=1
i + nk + 1
2
+ nk −1
2
(n −nk −1
2
)

= nnk −n + 2nk
2nk
(7.27) 
StartLayout 1st Row 1st Column n Subscript k Baseline n upper D Subscript 2 comma m a x Superscript k comma n 2nd Column equals sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction Endscripts left parenthesis i minus StartFraction n n Subscript k Baseline minus n plus 2 n Subscript k Baseline Over 2 n Subscript k Baseline EndFraction right parenthesis squared 2nd Row 1st Column Blank 2nd Column plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction Endscripts left parenthesis n plus i minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction minus StartFraction n n Subscript k Baseline minus n plus 2 n Subscript k Baseline Over 2 n Subscript k Baseline EndFraction right parenthesis squared 3rd Row 1st Column Blank 2nd Column equals sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction Endscripts i squared minus StartFraction left parenthesis n Subscript k Baseline minus 1 right parenthesis n plus 2 n Subscript k Baseline Over n Subscript k Baseline EndFraction sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction Endscripts i plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction Endscripts StartFraction left parenthesis left parenthesis n Subscript k Baseline minus 1 right parenthesis n plus 2 n Subscript k Baseline right parenthesis squared Over 4 n Subscript k Superscript 2 Baseline EndFraction 4th Row 1st Column Blank 2nd Column plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction Endscripts i squared 5th Row 1st Column Blank 2nd Column plus 2 left parenthesis n minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction minus StartFraction left parenthesis n Subscript k Baseline minus 1 right parenthesis n plus 2 n Subscript k Baseline Over 2 n Subscript k Baseline EndFraction right parenthesis sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction Endscripts i 6th Row 1st Column Blank 2nd Column plus sigma summation Underscript i equals 1 Overscript StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction Endscripts left parenthesis n minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction minus StartFraction left parenthesis n Subscript k Baseline minus 1 right parenthesis n plus 2 n Subscript k Baseline Over 2 n Subscript k Baseline EndFraction right parenthesis squared 7th Row 1st Column Blank 2nd Column equals StartFraction left parenthesis n Subscript k Superscript 2 Baseline minus 1 right parenthesis left parenthesis n Subscript k Superscript 2 Baseline minus 3 n n Subscript k Baseline plus 3 n squared right parenthesis Over 12 n Subscript k Baseline EndFraction EndLayout
nknDk,n
2,max =
nk+1
2

i=1
(i −nnk −n + 2nk
2nk
)2
+
nk−1
2

i=1
(n + i −nk −1
2
−nnk −n + 2nk
2nk
)2
=
nk+1
2

i=1
i2 −(nk −1)n + 2nk
nk
nk+1
2

i=1
i +
nk+1
2

i=1
((nk −1)n + 2nk)2
4n2
k
+
nk−1
2

i=1
i2
+ 2(n −nk −1
2
−(nk −1)n + 2nk
2nk
)
nk−1
2

i=1
i
+
nk−1
2

i=1
(n −nk −1
2
−(nk −1)n + 2nk
2nk
)2
= (n2
k −1)(n2
k −3nnk + 3n2)
12nk
(7.28) 
upper D Subscript 2 comma m a x Superscript k comma n Baseline equals StartFraction left parenthesis n Subscript k Superscript 2 Baseline minus 1 right parenthesis left parenthesis n Subscript k Superscript 2 Baseline minus 3 n n Subscript k Baseline plus 3 n squared right parenthesis Over 12 n n Subscript k Superscript 2 Baseline EndFraction equals StartFraction left parenthesis n Subscript k Superscript 2 Baseline minus 1 right parenthesis n Over 4 n Subscript k Superscript 2 Baseline EndFraction plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction minus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 4 n Subscript k Baseline EndFraction periodDk,n
2,max = (n2
k −1)(n2
k −3nnk + 3n2)
12nn2
k
= (n2
k −1)n
4n2
k
+ n2
k −1
12n
−n2
k −1
4nk
.
(7.29)

7.2
Distinguishing Proteins from Arbitrary Amino Acid Sequences
137
Corollary 7.1 Let c be the maximum length of the sequences in the dataset. 
Suppose n Subscript knk, the number of occurrences of the amino acid k, is a ﬁxed even integer. 
In this case, the maximum value upper D Subscript 2 comma max Superscript kDk
2,max in the dataset can be calculated using the 
following expression: 
upper D Subscript 2 comma m a x Superscript k Baseline equals one fourth left parenthesis c minus n Subscript k Baseline right parenthesis plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 c EndFraction periodDk
2,max = 1
4(c −nk) + n2
k −1
12c .
(7.30) 
Proof Let f left parenthesis n right parenthesis equals upper D Subscript 2 comma max Superscript k comma n Baseline equals one fourth n plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction minus one fourth n Subscript kf (n) = Dk,n
2,max = 1
4n + n2
k−1
12n −1
4nk for n Subscript k Baseline less than or equals n less than or equals cnk ≤n ≤c. Our goal is to ﬁnd 
the maximum value of f left parenthesis n right parenthesisf (n). It can be shown that f left parenthesis n right parenthesisf (n) attains its minimum value 
at n equals StartRoot StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 3 EndFraction EndRootn =

n2
k−1
3 . For values of n greater than StartRoot StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 3 EndFraction EndRoot

n2
k−1
3 , f left parenthesis n right parenthesisf (n) increases as n increases. 
Since StartRoot StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 3 EndFraction EndRoot less than n Subscript k Baseline less than or equals n

n2
k−1
3
< nk ≤n, the maximum value of f left parenthesis n right parenthesisf (n) occurs at n equals cn = c. 
Therefore, 
upper D Subscript 2 comma m a x Superscript k Baseline equals one fourth left parenthesis c minus n Subscript k Baseline right parenthesis plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 c EndFraction periodDk
2,max = 1
4(c −nk) + n2
k −1
12c .
(7.31) 
Corollary 7.2 Let c represent the maximum length of the sequences in the dataset. 
Let n Subscript knk denote the ﬁxed odd integer representing the number of occurrences of the 
amino acid k. Then the value of upper D Subscript 2 comma max Superscript kDk
2,max in the dataset can be determined as follows: 
upper D Subscript 2 comma m a x Superscript k Baseline equals StartFraction left parenthesis n Subscript k Baseline minus 1 right parenthesis left parenthesis n Subscript k Baseline plus 1 right parenthesis left parenthesis c minus n Subscript k Baseline right parenthesis Over 4 n Subscript k Superscript 2 Baseline EndFraction plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 c EndFraction periodDk
2,max = (nk −1)(nk + 1)(c −nk)
4n2
k
+ n2
k −1
12c .
(7.32) 
Proof Let us deﬁne the function f left parenthesis n right parenthesis equals upper D Subscript 2 comma max Superscript k comma n Baseline equals StartFraction left parenthesis n Subscript k Superscript 2 Baseline minus 1 right parenthesis n Over 4 n Subscript k Superscript 2 Baseline EndFraction plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction minus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 4 n Subscript k Baseline EndFractionf (n) = Dk,n
2,max = (n2
k−1)n
4n2
k
+ n2
k−1
12n −n2
k−1
4nk
for 
n Subscript k Baseline less than or equals n less than or equals cnk ≤n ≤c. In this case, the minimum value of f left parenthesis n right parenthesisf (n) occurs at n equals StartFraction n Subscript k Baseline Over StartRoot 3 EndRoot EndFractionn =
nk
√
3. As  
n increases beyond StartFraction n Subscript k Baseline Over StartRoot 3 EndRoot EndFractionnk
√
3, f left parenthesis n right parenthesisf (n) increases. Since StartFraction n Subscript k Baseline Over StartRoot 3 EndRoot EndFraction less than n Subscript k Baseline less than or equals n nk
√
3 < nk ≤n, f left parenthesis n right parenthesisf (n) reaches its 
maximum value at n equals cn = c. 
Therefore, 
upper D Subscript 2 comma m a x Superscript k Baseline equals StartFraction left parenthesis n Subscript k Baseline minus 1 right parenthesis left parenthesis n Subscript k Baseline plus 1 right parenthesis left parenthesis c minus n Subscript k Baseline right parenthesis Over 4 n Subscript k Superscript 2 Baseline EndFraction plus StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 c EndFraction periodDk
2,max = (nk −1)(nk + 1)(c −nk)
4n2
k
+ n2
k −1
12c .
(7.33) 
The last step involves calculating the minimum value upper D Subscript 2 comma min Superscript kDk
2,min of the second 
normalized moment. This value is obtained when the amino acid k occupies the 
initial n Subscript knk positions.

138
7
Convex Hull Principle and Distinguishing Proteins from Arbitrary Amino Acid...
Corollary 7.3 Let 0 less than n Subscript k Baseline less than or equals n0 < nk ≤n be ﬁxed positive integers. Consider a distribution of 
the amino acid k where x Subscript i Baseline equals ixi = i for 1 less than or equals i less than or equals n Subscript k1 ≤i ≤nk. In this distribution, the values of x Subscript ixi
represent the positions of the amino acid k within the sequence. Then: 
(1) 
upper D 2 Superscript k comma n Baseline left parenthesis x 1 comma ellipsis comma x Subscript n Sub Subscript k Subscript Baseline right parenthesis equals StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction periodDk,n
2 (x1, . . . , xnk) = n2
k −1
12n .
(7.34) 
(2) 
.Dk,n
2 (x1, . . . , xnk) ≤Dk,n
2 (y1, . . . , yn) where 1 less than or equals y 1 less than midline horizontal ellipsis less than y Subscript n Sub Subscript k Baseline less than or equals n1 ≤y1 < · · · < ynk ≤n is any 
distribution of the amino acid k. 
Proof We only need to prove (1) since (2) is obvious. 
StartLayout 1st Row 1st Column upper D 2 Superscript k comma n Baseline left parenthesis x 1 comma ellipsis comma x Subscript n Baseline right parenthesis 2nd Column equals StartFraction 1 Over n Subscript k Baseline n EndFraction sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts left parenthesis i minus 1 minus StartFraction n Subscript k Baseline minus 1 Over 2 EndFraction right parenthesis squared 2nd Row 1st Column Blank 2nd Column equals StartFraction 1 Over n Subscript k Baseline n EndFraction sigma summation Underscript i equals 1 Overscript n Subscript k Baseline Endscripts left parenthesis i minus StartFraction n Subscript k Baseline plus 1 Over 2 EndFraction right parenthesis squared 3rd Row 1st Column Blank 2nd Column equals StartFraction 1 Over n Subscript k Baseline n EndFraction StartFraction n Subscript k Baseline left parenthesis n Subscript k Superscript 2 Baseline minus 1 right parenthesis Over 12 EndFraction equals StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 n EndFraction period EndLayout
Dk,n
2 (x1, . . . , xn) =
1
nkn
nk

i=1
(i −1 −nk −1
2
)2
=
1
nkn
nk

i=1
(i −nk + 1
2
)2
=
1
nkn
nk(n2
k −1)
12
= n2
k −1
12n .
(7.35) 
Corollary 7.4 Let c represent the maximum length of the sequences in the dataset. 
Let n Subscript knk denote the ﬁxed number representing the number of occurrences of the amino 
acid k. Then 
upper D Subscript 2 comma m i n Superscript k Baseline equals StartFraction n Subscript k Superscript 2 Baseline minus 1 Over 12 c EndFraction periodDk
2,min = n2
k −1
12c .
(7.36)

Chapter 8 
New Features or Metric on Sequence 
Comparison 
8.1 The K-mer Natural Vector Method and Its Application 
In Chap. 6, we presented the natural vector approach, which is alignment-free and 
establishes a direct mapping between genetic sequences and vectors in a ﬁnite-
dimensional space, ensuring a one-to-one correspondence. And we have shown two 
ways to develop the traditional natural method. The ﬁrst way is to increase the order 
of the moments, and the second way is to take the covariance into account. In this 
section, we will introduce the k-mer natural vectors that contain more information 
and are more suitable for calculating the relationship between biological sequences 
[118]. 
The k-mer natural vector method builds upon the k-mer model, initially utilized 
by Blaisdell [119] for comparing genome sequences. A k-mer is a string containing 
k characters. A sequence can be transformed into a k-mer sequence. For example, 
the DNA sequence ACGGT can be seen as a 2-mer sequence of length 4 
(AC)(CG)(GG)(GT ). More generally, the sequence s1s2 . . . sn can be regarded as 
a sequence comprised of n−k +1 k-mers  (s1 . . . sk)(s2 . . . sk+1) . . . (sn−k+1 . . . sn). 
Kantorovitz et al. employ the frequencies of k-mers appearing in the sequences 
to conduct sequence comparison [120]. The k-mer model is a fast alignment-
free method for the sequence comparison. 
Nevertheless, the limitation of the 
k-mer model lies in its disregard for the relationships among the k-mers within a 
sequence to a certain extent [121, 122]. Therefore, the k-mer natural vector method 
is proposed to make up for this shortcoming. 
The deﬁnition of the k-mer natural vector is similar to that of the traditional 
natural vector. After transforming a sequence into a k-mer sequence, we can count 
the appearance and calculate the average position and the moments for each k-mer. 
We use l1, . . . , lL to represent all possible k-mers (L = 4k for DNA sequences and 
L = 20k for protein sequences). Deﬁne s[lj][i] be distance from the origin to the 
ith k-mer lj in the sequence and let nlj be the number of the k-mer lj. Then we 
deﬁne 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3_8
139

140
8
New Features or Metric on Sequence Comparison
StartLayout 1st Row 1st Column mu Subscript l Sub Subscript j 2nd Column colon equals StartFraction sigma summation Underscript i equals 1 Overscript n Subscript l Sub Subscript j Subscript Baseline Endscripts s left bracket l Subscript j Baseline right bracket left bracket i right bracket Over n Subscript l Sub Subscript j Subscript Baseline EndFraction comma 2nd Row 1st Column upper D Subscript m Superscript l Super Subscript j 2nd Column colon equals sigma summation Underscript i equals 1 Overscript n Subscript l Sub Subscript j Subscript Baseline Endscripts StartFraction left parenthesis s left bracket l Subscript j Baseline right bracket left bracket i right bracket minus mu Subscript l Sub Subscript j Subscript Baseline right parenthesis Superscript m Baseline Over n Subscript l Sub Subscript j Subscript Superscript m minus 1 Baseline left parenthesis n minus k plus 1 right parenthesis Superscript m minus 1 Baseline EndFraction comma EndLayout
μlj :=
nlj

i=1
s[lj][i]
nlj
,
D
lj
m :=
nlj

i=1
(s[lj][i] −μlj )m
nm−1
lj
(n −k + 1)m−1 ,
(8.1) 
if nlj /= 0 where n is the length of the original sequence (n − k + 1 = 
L
j=1 
nlj ). If 
nlj = 0, we deﬁne μlj = D 
lj 
1 = . . .  = D 
lj 
m = . . .  = 0 in particular. A k-mer natural 
vector of order M can be deﬁned as 
left parenthesis n Subscript l 1 Baseline comma ellipsis comma n Subscript l Sub Subscript upper L Subscript Baseline comma mu Subscript l 1 Baseline comma ellipsis comma mu Subscript l Sub Subscript upper L Subscript Baseline comma upper D 2 Superscript l 1 Baseline comma ellipsis comma upper D 2 Superscript l Super Subscript upper L Superscript Baseline ellipsis comma upper D Subscript upper M Superscript l 1 Baseline comma ellipsis comma upper D Subscript upper M Superscript l Super Subscript upper L Superscript Baseline right parenthesis period(nl1, . . . , nlL, μl1, . . . , μlL, Dl1
2 , . . . , DlL
2 . . . , Dl1
M, . . . , DlL
M).
(8.2) 
When k = 1, the k-mer natural vector is identical to the original natural vector, 
indicating that the k-mer natural vector method is an extension of the original natural 
vector model. 
In the case where the distribution of each k-mer varies, it is not possible for 
two genetic sequences to be similar solely based on containing the same set of k-
mer and having the same total distance measurement. While individual subsets of 
numerical parameters may not be adequate for annotating genetic sequences, the 
collective numerical parameters are capable of characterizing each genetic sequence 
effectively. It can be mathematically demonstrated that there exists a one-to-one 
correspondence between a genetic sequence and its corresponding k-mer natural 
vector for a given k when the order is sufﬁciently high. 
When conducting sequence comparisons, M is often chosen as 2 since high 
moments are relatively small and hardly make any contribution. Then the dimension 
of a k-mer natural vector is 3 × 4k for DNA sequences and 3 × 20k for protein 
sequences. 
Considering that the parameter k signiﬁcantly impacts the outcomes of sequence 
comparisons and evolutionary analyses, it becomes crucial to select an appropriate 
k value for different datasets. For the k-mer model, there are many works that guide 
the choice of k. For instance, Wu et al. [123] suggested an ideal word size for 
measuring dissimilarity, which is contingent upon the length of the sequences under 
consideration. Speciﬁcally, as the sequence length increases, it is recommended 
to increase the value of the optimal k, denoted by k∗. Sims et al. conducted 
a study [124, 125] and found that the ideal length of the k-mer falls within a 
range approximately bounded by log4n, where n represents the sequence length. 
Additionally, they determined that the upper limit is deﬁned by the requirement that 
the phylogenetic tree topology for length k should align with that of k + 1. 
In order to determine the optimal value k∗ for the k-mer natural vector method, 
we conducted experiments on several real datasets [78, 126]. The selection of the

8.1
The K-mer Natural Vector Method and Its Application
141
optimal k∗ within the range of considered k values was based on the following 
strategy: If the phylogenetic tree obtained using value k showed a relatively stable 
result compared to that of k + 1, we chose k∗ = k; otherwise, k∗ was set to the 
maximum value within the range of considered k values. This approach allowed 
us to identify the most suitable k value for the k-mer natural vector model. Based 
on our inference, the optimal value k∗ for the k-mer natural vector method falls 
within the range [ceil(log4min(L)), ceil(log4max(L)) + 1], where L represents the 
set of lengths of genetic sequences considered in the phylogenetic analysis, and 
ceil(x) denotes the smallest integer greater than or equal to x. This explicit range 
for selecting the optimum value k∗ is considerably shorter compared to the ranges 
considered in previous k-mer model methods. Moreover, the optimal k∗ obtained 
using the k-mer natural vector method is smaller than those selected by other k-mer 
model methods [126, 127] for the same candidate dataset (18S rRNA dataset). This 
suggests that the k-mer natural vector method requires less computational time and 
can more easily extract hidden features from genetic sequences. 
We can establish a distance metric to quantify the evolutionary relationships 
among genetic sequences because each sequence can be distinctly represented by 
a natural vector derived from its k-mer. There are many types of distances that 
can be chosen. For example, we can use the Euclidean distance to measure the 
dissimilarities between genetic sequences, or we can use angles to represent their 
similarities [127–129]. To be more speciﬁc, let v1 and v2 be the k-mer natural 
vectors of genetic sequences s1 and s2, respectively, and we can deﬁne the following 
two distances (actually d2 is not a distance mathematically): 
d 1 left parenthesis s 1 comma s 2 right parenthesis equals StartAbsoluteValue EndAbsoluteValue v 1 minus v 2 StartAbsoluteValue EndAbsoluteValue Subscript 2 Baseline commad1(s1, s2) = ||v1 −v2||2,
(8.3) 
d 2 left parenthesis s 1 comma s 2 right parenthesis equals 1 minus cosine left parenthesis v 1 comma v 2 right parenthesis equals 1 minus StartFraction v 1 dot v 2 Over StartAbsoluteValue EndAbsoluteValue v 1 StartAbsoluteValue EndAbsoluteValue Subscript 2 Baseline StartAbsoluteValue EndAbsoluteValue v 2 StartAbsoluteValue EndAbsoluteValue Subscript 2 Baseline EndFraction commad2(s1, s2) = 1 −cos(v1, v2) = 1 −
v1 · v2
||v1||2||v2||2
,
(8.4) 
where ||.||2 represents Euclidean norm. 
In [118], d2 is used to construct the distance matrix, and the neighbor-joining 
method is applied to obtain an evolutionary tree of 40 tetrapod 18S rRNA 
sequences (see Fig. 8.1). k is chosen to be 6 in this problem. The phylogenetic 
tree depicted here exhibits four distinct clades: Birds (green), Crocodilians (blue), 
Mammals (red), and Amphibians (purple), with each clade accurately grouping the 
corresponding species together. These ﬁndings align closely with results obtained 
through sequence alignment and are consistent with certain phylogenetic analyses 
[126, 130]. (The tree plotted by ClustalW is in Fig. 8.2.) 
There is another strategy to apply the k-mer natural vector. Instead of choosing 
a speciﬁc k, we can consider the Euclidean distance (d1) of  k-mer natural vectors 
with different k and sum them up with a given weight. Let d(k) denote the distance 
of k-mer natural vectors, and we can use D(ai, K)  = 
K
i=1 
aid(i) to measure the 
dissimilarities between sequences.

142
8
New Features or Metric on Sequence Comparison
Rattus V01270 
Rattus K01593 
Rattus M11188 
Alligator AF 173605 
Xenopus X04025 
Xenopus X02995 
Ranodon AJ279506 
Ciconia AF 173636 
Coracias AF 173625 
Tockus AF 173626 
Columba AF 173630 
Tyrannus AF 173616 
Gallirex AF 173618 
Trogon AF 173623 
Turnix AF 173631 
Grus AF 173632 
Apus AF 173619 
Chordeiles AF 173622 
Cuculus AF 173628 
Larus AF 173637 
Charadrius AF 173638 
Urocolius AF 173617 
Upupa AF 173627 
Galbula AF 173624 
Picoides AF 173615 
Ortalis AF 173613 
Anas AF 173614 
Coturnix AF 173611 
Gallus AF 173612 
Apleryx AF 173609 
Dromaius AF 173610 
Oryctolagus X00640 
Oryctolagus X06778 
Homo K03432 
Homo M10098 
Homo U13369 
Homo X03205 
Mus X00686 
Mus X82564 
Sphenodon AF 115860 
0.02 
Fig. 8.1 The NJ tree of 40 18S rRNA sequences based on 6-mer natural vector method

8.1
The K-mer Natural Vector Method and Its Application
143
0.005 
Apus AF 173619 
Chordeiles AF 173622 
Ciconia AF 173636 
Coracias AF 173625 
Tockus AF 173626 
Columba AF 173630 
Tyrannus AF 173616 
Gallirex AF 173618 
Larus AF 173637 
Trogon AF 173623 
Turnix AF 173631 
Grus AF 173632 
Charadrius AF 173638 
Cuculus AF 173628 
Urocoliusus AF 173617 
Upupa AF 173627 
Galbula AF 173624 
Picoides AF 173615 
Ortalis AF 173613 
Anas AF 173614 
Cotumix AF 173611 
Gallus AF 173612 
Apteryx AF 173609 
Dromaius AF 173610 
Rattus V01270 
Rattus K01593 
Rattus M11188 
Mus X00686 
Mus X82564 
Oryctolagus X06778 
Homo M10098 
Homo K03432 
Homo U13369 
Homo X03205 
Oryctolagus X00640 
Alligator AF 173605 
Sphenodon AF 115860 
Ranodon AJ279506 
Xenopus X04025 
Xenopus X02995 
Fig. 8.2 The NJ tree of 40 18S rRNA sequences obtained by ClustalW

144
8
New Features or Metric on Sequence Comparison
Table 8.1 The accuracy of 
D(ai, K)  with different 
weights and K 
K \ Weight 
1 
2i 
1 
i2 
1
79.90% 
79.90% 
2
82.80% 
82.80% 
3
83.30% 
83.30% 
4
83.30% 
83.30% 
5
84.10% 
84.40% 
6
85.80% 
86.30% 
7
86.90% 
87.70% 
8
87.40% 
88.00% 
9
88.30% 
85.60% 
In [108], the viral classiﬁcation is based on this strategy. The dataset considered 
consists of 7382 viral reference sequences in NCBI up to March 2020. The nearest 
neighborhood method (1-NN) with the leave-one-out strategy is used to check the 
effectiveness of the method. In the case of a viral sequence, if its closest sequence 
in terms of similarity belongs to the same family as itself, the classiﬁcation outcome 
is considered accurate. The accuracy of classiﬁcation can be calculated by dividing 
the number of correctly classiﬁed sequences by the total number of sequences. The 
accuracies of D(ai, K)  with different K and different ai are listed in Table 8.1. It  
shows that combining different k-mer is helpful for increasing the accuracy and the 
weight 1 
2i , and K = 9 is a good choice for the summation. 
Finally, we introduce the concept of k-mer dictionary, which may reduce the 
dimension of k-mer natural vectors for some cases [131]. We know that there 
are 4k possible k-mers for genome sequences and 20k possible k-mers for protein 
sequences, while the possible k-mers in a real dataset may be less than this number. 
Therefore, we can compute a k-mer dictionary that includes possible k-mers in 
a real dataset, which can greatly reduce the computational time. For example, 
titin is currently the largest known protein, and its human variant (GenBank No.: 
NP_001243779) consists of 34,350 amino acids [132]. Take K = 10, and then titin 
has 34,350 − 10 + 1 = 34,341 k-mers. Therefore, even dealing with a dataset 
containing 1000 proteins as big as the titin, the amount of all k-mers appearing in 
the dataset is bounded by 4×107, which is far less than 2010 = 1.024×1013. In fact, 
since many k-mers are duplicate, the real k-mer dictionary will be far less than the 
calculated bound. In [131], the size of the k-mer dictionary of a real protein dataset 
containing 290 proteins and a simulated dataset that has the same lengths as the real 
sequences in the above real dataset is calculated and listed in Table 8.2. The result 
further shows that there are some patterns in the real protein sequences so that the 
repetition of k-mers in real datasets is more common than in random sequences.

8.2
New Features Based on the Singular Value Decomposition
145
Table 8.2 The cardinalities of K-string dictionary of real and simulated dataset 
K value
Cardinality (real dataset)
Cardinality (simulated dataset) 
1
20
20 
2
400
400 
3
7186
8000 
4
41703
83601 
5
61792
115394 
6
65733
117083 
7
67214
116892 
8
68182
116604 
9
68898
116314 
10
69450
116024 
11
69895
115734 
12
70255
115444 
13
70551
115154 
14
70804
114864 
15
71012
114574 
16
71188
114284 
17
71343
113994 
18
71482
113704 
19
71607
113414 
20
71720
113124 
8.2 New Features Based on the Singular Value 
Decomposition 
In this section, we will present two applications of the singular value decomposition 
(SVD). The ﬁrst application is to transform one-hot encoding matrices to feature 
vectors, and the second application is to reduce the noise of the vector representa-
tion. 
8.2.1 
The K-mer Sparse Matrix Model and Its Applications 
Yu and Huang [133] proposed the sparse matrix representation for protein primary 
sequences. This method can be generalized by the k-mer model [134]. 
We take the genetic sequence as an example. Each sequence of length L can 
be transformed into a matrix of size 4 × L by one-hot encoding. That is, after the 
nucleotides are assigned to 1, 2, 3, 4, respectively, we can deﬁne Mij = 1 if  i is 
the assigned number of the jth nucleotide in the sequence and Mij = 0 otherwise. 
Similarly, by regarding a sequence of length L as a k-mer sequence of length L − 
k + 1, we can transform each sequence into a matrix M of size 4k × (L − k + 1).

146
8
New Features or Metric on Sequence Comparison
It is simple to observe that each column of matrix M contains only one 
element, indicating its sparsity. We can also readily verify that this transformation 
is bijective, preserving all the information embedded within a genetic sequence. 
Various powerful tools can be employed to extract characteristic information from 
the sparse matrix representation of k-mer. Singular value decomposition is among 
the available tools, and the singular value vector, composed of singular values, can 
be utilized to numerically represent the characteristics of a genetic sequence. 
The k-mer sparse matrix M can be decomposed using singular value decompo-
sition (SVD) as follows: 
upper M equals upper U sigma summation upper V Superscript upper T Baseline commaM = U

V T ,
(8.5) 
where U is a real square matrix satisfying UT U = I4k (I4k is a unit matrix of 
rank 4k),  is a 4k × (L − k + 1) diagonal matrix with nonnegative singular 
values σ1, σ2, . . . , σk', where k' = min(4k , L  − k + 1) on the diagonal, and V T 
(the transpose of V ) is a real square matrix having V T V = IL−k+1. 
Based on the given deﬁnition, we observe that the number of singular values 
depends on the value of k and the length L of the considered sequence. Genetic 
sequences often have varying lengths, and this leads to non-uniqueness in the 
dimension of the singular value vector, particularly when 4k is greater than L−k+1. 
To enable the comparison of genetic sequences using a distance measure, it is 
desirable to obtain a consistent dimensional singular value vector for sequences of 
different lengths when k is ﬁxed. To achieve this, a slight modiﬁcation is made to 
the k-mer sparse matrix when 4k exceeds L − k + 1. Speciﬁcally, the k-mer sparse 
matrix is extended into a square matrix of rank 4k by appending a zero matrix of 
dimensions 4k × (4k − (L −k + 1)) to the end of the k-mer sparse matrix. This 
modiﬁcation ensures that we always obtain 4k singular values through the SVD of 
k-mer sparse matrices for genetic sequences of varying lengths when k is given. This 
approach effectively preserves all the information encoded in the genetic sequences 
while enabling the characterization of genetic sequences of different lengths using 
singular value vectors of the same dimension. 
Therefore, for each given value of k, we can construct and employ the k-mer 
singular value vector to capture the genetic sequence’s characteristics numerically. 
Within this vector, the 4k singular values are arranged in the lexicographic order of 
the corresponding k-mer. 
In Sect. 8.1, we have shown the process of selecting the optimum value k∗. 
Based on this approach, we can deduce that the optimal value of k, denoted as 
k∗, for our k-mer sparse matrix model is approximately equal to the ﬂoor value of 
ﬂoor(log4mean(L)), where L represents the length set of the considered genetic 
sequences. 
We take the 18S rRNA dataset again to show the effectiveness of the method. The 
distance is chosen as the formula 8.4 and k = 5. The phylogenetic tree is shown in 
Fig. 8.3. The result is also satisfying.

8.2
New Features Based on the Singular Value Decomposition
147
Ciconia AF 173636 
Coracias AF 173625 
Tockus AF 173626 
Columba AF 173630 
Tyrannus AF 173616 
Gallirex AF 173618 
Trogon AF 173623 
Turnix AF 173631 
Grus AF 173632 
Apus AF 173619 
Chordeiles AF 173622 
Cuculus AF 173628 
Larus AF 173637 
Charasnus AF 173638 
Urocolius AF 173617 
Upupa AF 173627 
Galbula AF 173624 
Picoides AF 173615 
Ortalis AF 173613 
Anas AF 173614 
Coturnix AF 173611 
Gallus AF 173612 
Apleryx AF 173609 
Dromaius AF 173610 
Alligator AF 173605 
Sphenodon AF 115860 
Oryctolagus X00640 
Oryctolagus X06778 
Rattus V01270 
Rattus K01593 
Rattus M11188 
Mus X82564 
Mus X00686 
Homo M10098 
Homo K03432 
Homo U13369 
Homo X03205 
Ranodon AJ279506 
Xenopus X04025 
Xenopus X02995 
0.005 
Fig. 8.3 The NJ tree of 40 18S rRNA sequences based on the 5-mer sparse matrix model

148
8
New Features or Metric on Sequence Comparison
8.2.2 
Noise Reduction Based on the Singular Value 
Decomposition 
By the natural vector method or other sequence embedding techniques, we can 
transform a sequence into a vector and therefore transform sequences into a matrix. 
Let the number of sequences to be n and let the dimension of the vector to be c, and 
then the matrix M is c by n: 
upper M equals Start 4 By 4 Matrix 1st Row 1st Column f 11 2nd Column f 12 3rd Column midline horizontal ellipsis 4th Column f Subscript 1 n Baseline 2nd Row 1st Column f 21 2nd Column f 22 3rd Column midline horizontal ellipsis 4th Column f Subscript 2 n Baseline 3rd Row 1st Column midline horizontal ellipsis 2nd Column midline horizontal ellipsis 3rd Column midline horizontal ellipsis 4th Column midline horizontal ellipsis 4th Row 1st Column f Subscript c Baseline 1 Baseline 2nd Column f Subscript c Baseline 2 Baseline 3rd Column midline horizontal ellipsis 4th Column f Subscript c n Baseline EndMatrix periodM =
⎡
⎢⎢⎣
f11 f12 · · · f1n
f21 f22 · · · f2n
· · · · · · · · · · · ·
fc1 fc2 · · · fcn
⎤
⎥⎥⎦.
(8.6) 
We can use the singular value decomposition to improve the vector representation 
[131, 135]. M is decomposed into three separate matrices U, sigma summation, and V using SVD, 
that is, 
upper M equals upper U sigma summation upper V Superscript upper T Baseline commaM = U

V T ,
(8.7) 
where U represents the orthogonal matrix of size c times cc×c, where its columns consist of 
the left singular vectors of matrix M. Similarly, V represents the orthogonal matrix 
of size n times nn × n, with its columns comprising the right singular vectors of matrix M. 
The diagonal matrix sigma summation of size c times nc × n contains the singular values sigma 1 greater than sigma 2 greater than midline horizontal ellipsis greater than sigma Subscript min left parenthesis c comma n right parenthesisσ1 > σ2 > · · · >
σmin(c,n) of matrix M arranged in descending order along its diagonal. The rank r 
of matrix M is determined by the number of non-zero singular values it possesses. 
Then the Frobenius norm of M is deﬁned as 
StartAbsoluteValue EndAbsoluteValue upper M StartAbsoluteValue EndAbsoluteValue Subscript upper F Baseline equals StartRoot sigma summation Underscript j equals 1 Overscript r Endscripts sigma Subscript j Superscript 2 Baseline EndRoot period||M||F =




r

j=1
σ 2
j .
(8.8) 
The Eckart–Young theorem [136] states that the distance between M and its 
rank-m approximations left parenthesis m less than or equals r right parenthesis(m ≤r) is minimized by the approximation upper M Subscript mMm. In  this  
equation, upper M Subscript mMm is expressed as the product of three matrices: upper U Subscript mUm, sigma summation Underscript m Endscripts
m, and upper V Subscript m Superscript upper TV T
m . Here, 
upper U Subscript mUm is a matrix of size c times mc × m whose columns consist of the ﬁrst m columns of 
matrix U. Similarly, upper V Subscript mVm is a matrix of size n times mn × m whose columns comprise the 
ﬁrst m columns of matrix V . Lastly, sigma summation Underscript m Endscripts
m is a diagonal matrix of size m times mm × m whose 
diagonal elements correspond to the m largest singular values of matrix M. The  
theorem further shows how the norm of that distance is related to singular values of 
M: 
StartAbsoluteValue EndAbsoluteValue upper M minus upper M Subscript m Baseline StartAbsoluteValue EndAbsoluteValue Subscript upper F Baseline equals min Subscript rank left parenthesis upper X right parenthesis less than or equals m Baseline StartAbsoluteValue EndAbsoluteValue upper M minus upper X StartAbsoluteValue EndAbsoluteValue equals StartRoot sigma Subscript m plus 1 Superscript 2 Baseline plus midline horizontal ellipsis plus sigma Subscript r Superscript 2 Baseline EndRoot period||M −Mm||F = minrank(X)≤m||M −X|| =

σ 2
m+1 + · · · + σ 2r .
(8.9)

8.3
DFA7: A Novel Approach for Discriminating Intron-Containing and...
149
This low-rank matrix approximation can improve the quality of vector represen-
tation by discarding a substantial fraction of the noise [135]. If sigma 1 comma ellipsis comma sigma Subscript r Baselineσ1, . . . , σr are the 
positive singular values of M, then by using Frobenius norm, the singular vector 
associated with any particular singular value (i.e., sigma Subscript jσj) accounts for the fraction 
StartRoot StartFraction sigma Subscript j Superscript 2 Baseline Over sigma 1 squared plus sigma 2 squared plus midline horizontal ellipsis plus sigma Subscript r Superscript 2 Baseline EndFraction EndRoot

σ 2
j
σ 2
1 +σ 2
2 +···+σ 2r of the data. So, choosing the m largest values left parenthesis m less than r right parenthesis(m < r) explains 
the fraction StartRoot StartFraction sigma 1 squared plus sigma 2 squared plus midline horizontal ellipsis plus sigma Subscript m Superscript 2 Baseline Over sigma 1 squared plus sigma 2 squared plus midline horizontal ellipsis plus sigma Subscript r Superscript 2 Baseline EndFraction EndRoot

σ 2
1 +σ 2
2 +···+σ 2m
σ 2
1 +σ 2
2 +···+σ 2r of the data, and it also allows the approximation of the 
matrix from the ﬁrst m singular triplets: upper M Subscript m Baseline equals upper U Subscript m Baseline sigma summation Underscript m Endscripts upper V Subscript m Superscript upper TMm = Um

m V T
m . 
Determining the number m of ranked singular values that best serve to separate 
signal from noise within the dataset is challenging [137]. A natural idea is to ﬁx a 
number p element of left parenthesis 0 comma 1 right parenthesisp ∈(0, 1), and let m to be the smallest integer satisfying StartRoot StartFraction sigma 1 squared plus sigma 2 squared plus midline horizontal ellipsis plus sigma Subscript m Superscript 2 Baseline Over sigma 1 squared plus sigma 2 squared plus midline horizontal ellipsis plus sigma Subscript r Superscript 2 Baseline EndFraction EndRoot greater than or equals p

σ 2
1 +σ 2
2 +···+σ 2m
σ 2
1 +σ 2
2 +···+σ 2r ≥
p. It means that we make the proportion of changes in the initial matrix less than 
1 minus p1 −p. 
8.3 DFA7: A Novel Approach for Discriminating 
Intron-Containing and Intronless Genes 
In this section, we present DFA7, a novel approach for categorizing genes according 
to their intron presence [138]. We explore three novel parameters derived from 
the cross-correlations among the distributions of nucleic base distances in gene 
sequences. By combining these new parameters with Zhang et al.’s original three 
parameters [139] and considering the total standard deviation, we can greatly 
enhance the accuracy of gene classiﬁcation based on their intron status. All 7 
parameters extracted from the gene can be denoted by α, β, γ , λ, θ, φ, and σ. 
Detrended ﬂuctuation analysis (DFA), initially proposed by Peng et al. [141], is 
a technique for assessing long-range power law correlations in noisy signals. This 
method employs a scaling analysis approach to estimate the relevant correlation 
parameters. In the following content, we will show how this idea contributes to 
feature extraction. 
In a DNA sequence, the cumulative distance Dm 
j represents the sum of distances 
between all nucleotides of the nucleic base j (j  = A, C, G, T ) and the ﬁrst 
nucleotide (considered as the origin) within m steps. We deﬁne t j 
i as the distance 
from the ﬁrst nucleotide to the ith nucleotide if the ith nucleotide is of type j. 
If the ith nucleotide is not of type j, then t j 
i is set to 0. Consequently, we can 
express Dm 
j as the summation of t j 
i from i = 1 to  m: Dm 
j = m 
i=1 t j 
i . For example, 
(AGCCTCGACT) is a DNA sequence. For nucleic base C, tc 
1 = 0, tc 
2 = 0, tc 
3 = 2, 
tc 
4 = 3, tc 
5 = 0, tc 
6 = 5, tc 
7 = 0, tc 
8 = 0, tc 
9 = 8, tc 
10 = 0, so D10 
C = 2+3+5+8 = 18. 
Similarly, we get D10 
A = 7, D10 
G = 1 + 6 = 7, and D10 
T = 4 + 9 = 13. Therefore, 
we can deﬁne three types of cumulative distances as follows:

150
8
New Features or Metric on Sequence Comparison
StartLayout Enlarged left brace 1st Row 1st Column upper D Subscript n Baseline equals 2nd Column left parenthesis upper D Subscript upper A Superscript n Baseline plus upper D Subscript upper G Superscript n Baseline right parenthesis minus left parenthesis upper D Subscript upper C Superscript n Baseline plus upper D Subscript upper T Superscript n Baseline right parenthesis 2nd Row 1st Column upper E Subscript n Baseline equals 2nd Column left parenthesis upper D Subscript upper A Superscript n Baseline plus upper D Subscript upper C Superscript n Baseline right parenthesis minus left parenthesis upper D Subscript upper G Superscript n Baseline plus upper D Subscript upper T Superscript n Baseline right parenthesis 3rd Row 1st Column upper H Subscript n Baseline equals 2nd Column left parenthesis upper D Subscript upper A Superscript n Baseline plus upper D Subscript upper T Superscript n Baseline right parenthesis minus left parenthesis upper D Subscript upper C Superscript n Baseline plus upper D Subscript upper G Superscript n Baseline right parenthesis EndLayout comma
⎧
⎨
⎩
Dn = (Dn
A + Dn
G) −(Dn
C + Dn
T )
En = (Dn
A + Dn
C) −(Dn
G + Dn
T )
Hn = (Dn
A + Dn
T ) −(Dn
C + Dn
G)
,
(8.10) 
where n = 1, 2, . . .  , N  and N represents the length of the DNA sequence, and the 
cumulative distances Dn, En, and Hn provide insights into the cross-correlation of 
the “position” of each nucleic base within the DNA sequence. 
Next, we will build a 3 × 3 cumulative distance matrix using the values of Dn, 
En, and Hn. This matrix will be utilized to calculate three feature parameters: λ, θ, 
and φ. The following algorithmic steps outline the process of determining these new 
parameters λ, θ, and φ: 
(1) Create a window with a width of l, where l is equal to 2n and n can take values 
of 1, 2, 3, 4, or5. Move this window starting from the position l0. 
(2) Compute the variation of each distribution at both ends of the window, 
StartLayout Enlarged left brace 1st Row 1st Column normal upper Delta upper D Subscript l Baseline equals 2nd Column upper D Subscript l 0 plus l Baseline minus upper D Subscript l 0 Baseline 2nd Row 1st Column normal upper Delta upper E Subscript l Baseline equals 2nd Column upper E Subscript l 0 plus l Baseline minus upper E Subscript l 0 Baseline 3rd Row 1st Column normal upper Delta upper H Subscript l Baseline equals 2nd Column upper H Subscript l 0 plus l Baseline minus upper H Subscript l 0 Baseline EndLayout period
⎧
⎨
⎩
ΔDl = Dl0+l −Dl0
ΔEl = El0+l −El0
ΔHl = Hl0+l −Hl0
.
(8.11) 
(3) Iteratively shift the window from the starting position l0 = 1 to  l0 = 2, and so 
on, up to l0 = N − l, where N represents the length of the sequence. For each 
value of l0 ranging from 1 to N −l, calculate the respective variations ΔDl, 
ΔEl, and ΔHl. 
(4) Deﬁne the ﬂuctuation functions 
StartLayout Enlarged left brace 1st Row 1st Column rho Subscript upper D upper D Baseline left parenthesis l right parenthesis equals 2nd Column StartAbsoluteValue left parenthesis ModifyingAbove normal upper Delta upper D Subscript l Baseline normal upper Delta upper D Subscript l Baseline With quotation dash right parenthesis minus left parenthesis ModifyingAbove normal upper Delta upper D Subscript l Baseline With quotation dash right parenthesis left parenthesis ModifyingAbove normal upper Delta upper D Subscript l Baseline With quotation dash right parenthesis EndAbsoluteValue 2nd Row 1st Column rho Subscript upper E upper E Baseline left parenthesis l right parenthesis equals 2nd Column StartAbsoluteValue left parenthesis ModifyingAbove normal upper Delta upper E Subscript l Baseline normal upper Delta upper E Subscript l Baseline With quotation dash right parenthesis minus left parenthesis ModifyingAbove normal upper Delta upper E Subscript l Baseline With quotation dash right parenthesis left parenthesis ModifyingAbove normal upper Delta upper E Subscript l Baseline With quotation dash right parenthesis EndAbsoluteValue 3rd Row 1st Column rho Subscript upper H upper H Baseline left parenthesis l right parenthesis equals 2nd Column StartAbsoluteValue left parenthesis ModifyingAbove normal upper Delta upper H Subscript l Baseline normal upper Delta upper H Subscript l Baseline With quotation dash right parenthesis minus left parenthesis ModifyingAbove normal upper Delta upper H Subscript l Baseline With quotation dash right parenthesis left parenthesis ModifyingAbove normal upper Delta upper H Subscript l Baseline With quotation dash right parenthesis EndAbsoluteValue EndLayout
⎧
⎨
⎩
ρDD(l) = |(ΔDlΔDl) −(ΔDl)(ΔDl)|
ρEE(l) = |(ΔElΔEl) −(ΔEl)(ΔEl)|
ρHH(l) = |(ΔHlΔHl) −(ΔHl)(ΔHl)|
(8.12) 
StartLayout Enlarged left brace 1st Row 1st Column rho Subscript upper D upper E Baseline left parenthesis l right parenthesis equals rho Subscript upper E upper D Baseline left parenthesis l right parenthesis equals 2nd Column StartAbsoluteValue left parenthesis ModifyingAbove normal upper Delta upper D Subscript l Baseline normal upper Delta upper E Subscript l Baseline With quotation dash right parenthesis minus left parenthesis ModifyingAbove normal upper Delta upper D Subscript l Baseline With quotation dash right parenthesis left parenthesis ModifyingAbove normal upper Delta upper E Subscript l Baseline With quotation dash right parenthesis EndAbsoluteValue 2nd Row 1st Column rho Subscript upper D upper H Baseline left parenthesis l right parenthesis equals rho Subscript upper H upper D Baseline left parenthesis l right parenthesis equals 2nd Column StartAbsoluteValue left parenthesis ModifyingAbove normal upper Delta upper D Subscript l Baseline normal upper Delta upper H Subscript l Baseline With quotation dash right parenthesis minus left parenthesis ModifyingAbove normal upper Delta upper D Subscript l Baseline With quotation dash right parenthesis left parenthesis ModifyingAbove normal upper Delta upper H Subscript l Baseline With quotation dash right parenthesis EndAbsoluteValue 3rd Row 1st Column rho Subscript upper E upper H Baseline left parenthesis l right parenthesis equals rho Subscript upper H upper E Baseline left parenthesis l right parenthesis equals 2nd Column StartAbsoluteValue left parenthesis ModifyingAbove normal upper Delta upper E Subscript l Baseline normal upper Delta upper H Subscript l Baseline With quotation dash right parenthesis minus left parenthesis ModifyingAbove normal upper Delta upper E Subscript l Baseline With quotation dash right parenthesis left parenthesis ModifyingAbove normal upper Delta upper H Subscript l Baseline With quotation dash right parenthesis EndAbsoluteValue EndLayout period
⎧
⎨
⎩
ρDE(l) = ρED(l) = |(ΔDlΔEl) −(ΔDl)(ΔEl)|
ρDH(l) = ρHD(l) = |(ΔDlΔHl) −(ΔDl)(ΔHl)|
ρEH(l) = ρHE(l) = |(ΔElΔHl) −(ΔEl)(ΔHl)|
.
(8.13) 
The bars represent an average over all positions l0 in the sequence. Subse-
quently, the matrix of ﬂuctuation functions can be deﬁned as follows: 
upper F equals Start 3 By 3 Matrix 1st Row 1st Column rho Subscript upper D upper D Baseline left parenthesis l right parenthesis 2nd Column rho Subscript upper D upper E Baseline left parenthesis l right parenthesis 3rd Column rho Subscript upper D upper H Baseline left parenthesis l right parenthesis 2nd Row 1st Column rho Subscript upper E upper D Baseline left parenthesis l right parenthesis 2nd Column rho Subscript upper E upper E Baseline left parenthesis l right parenthesis 3rd Column rho Subscript upper E upper H Baseline left parenthesis l right parenthesis 3rd Row 1st Column rho Subscript upper H upper D Baseline left parenthesis l right parenthesis 2nd Column rho Subscript upper H upper E Baseline left parenthesis l right parenthesis 3rd Column rho Subscript upper H upper H Baseline left parenthesis l right parenthesis EndMatrix periodF =
⎛
⎝
ρDD(l) ρDE(l) ρDH(l)
ρED(l) ρEE(l) ρEH(l)
ρHD(l) ρHE(l) ρHH(l)
⎞
⎠.
(8.14) 
Indeed, F is a real and symmetric matrix. It can be regarded as a modiﬁed 
version of the covariance matrix for the variables (ΔDl, ΔEl, ΔHl). Let us 
denote the three eigenvalues of F as ε1, ε2, and ε3, with the condition that

8.3
DFA7: A Novel Approach for Discriminating Intron-Containing and...
151
ε1 ≥ ε2 ≥ ε3. (Readers that are not familiar with eigenvalues can refer to 
[140].) Through ﬂuctuation analysis, we can derive the following result: 
epsilon 1 proportional to l Superscript lamda Baseline comma epsilon 2 proportional to l Superscript theta Baseline comma epsilon 3 proportional to l Superscript phi Baseline periodε1 ∝lλ,
ε2 ∝lθ,
ε3 ∝lφ.
(8.15) 
The parameters λ, θ, and φ are determined by the slopes observed in the log–log 
plots. In simpler terms, εi (i = 1, 2, 3) can be seen as a proportional function 
of lj (j = λ, θ, φ), meaning that εj can be expressed as c × lj, where c is a 
non-zero constant. Due to the nonlinear scaling of the axes, a function in the 
form of y = a × xb will appear as a straight line on a log–log graph, with b 
representing the slope of the line. As a result, the parameters λ, θ, and φ can be 
calculated by estimating the slope of the log–log graph corresponding to ε1, ε2, 
and ε3 using the available numerical data. 
(5) Estimate the slopes λ, θ, and φ of each log–log graph corresponding to ε1, ε2, 
and ε3 computed in step (4). 
Hence, by following the aforementioned ﬁve algorithmic steps, we can compute 
three parameters λ, θ, and φ for any given DNA sequence. In step (1), to enhance 
computational efﬁciency and minimize error in determining the slope φ, we utilize 
values of l = 2n (n = 1, 2, 3, 4, 5). These values result in a perfectly ﬁtted line. 
Even in cases where linearity is not ideal, a least-squares ﬁt of the data enables us 
to obtain a unique straight line while minimizing the squared error associated with 
the slope and intercept parameters. 
In [139], three exponents α, β, and γ are extracted with the same step from the 
Z-curve, which is a curve representation deﬁned as follows: 
Let us consider a DNA sequence consisting of N bases. We deﬁne the number 
of steps as n (n  = 1, 2, . . . , N). To analyze the sequence, we count the cumulative 
occurrences of the bases A, C, G, and T in the subsequence from the ﬁrst to the nth 
base. These cumulative counts are represented by An, Cn, Gn, and Tn, respectively. 
The Z-curve is a three-dimensional curve that comprises a series of nodes Pn (n = 
1, 2, . . .  , N), with coordinates denoted as xn, yn, and zn. It is shown that 
StartLayout Enlarged left brace 1st Row 1st Column x Subscript n Baseline equals 2nd Column 2 left parenthesis upper A Subscript n Baseline plus upper G Subscript n Baseline right parenthesis minus n 2nd Row 1st Column y Subscript n Baseline equals 2nd Column 2 left parenthesis upper A Subscript n Baseline plus upper C Subscript n Baseline right parenthesis minus n 3rd Row 1st Column z Subscript n Baseline equals 2nd Column 2 left parenthesis upper A Subscript n Baseline plus upper T Subscript n Baseline right parenthesis minus n EndLayout period
⎧
⎨
⎩
xn = 2(An + Gn) −n
yn = 2(An + Cn) −n
zn = 2(An + Tn) −n
.
(8.16) 
The Z-curve of the DNA sequence is deﬁned by connecting the nodes P0 = 0, 
P1, . . . , PN in a sequential manner using straight lines, where n = 1, 2, . . .  , N, and 
the initial cumulative counts are A0 = C0 = G0 = T0 = 0. 
We can extract three exponents α, β, and γ from (xn, yn, zn) by the same way by 
which we extract λ, θ, and φ from (Dl, El, Hl). Therefore, we can combine these 
exponents and get a 6-dimensional feature vector. In conclusion, the inclusion of the 
parameter σ, representing the sample standard deviation of the other 6 features, is 
essential. The cumulative distances (Dl, El, Hl), derived directly from the original 
DNA sequence, capture additional sequence information that the Z-curve method

152
8
New Features or Metric on Sequence Comparison
lacks. By incorporating these new parameters, we can improve the accuracy of gene 
classiﬁcation. 
Following the preceding procedures, we obtain a 7-dimensional feature vector 
for each gene sequence. Subsequently, a machine learning technique employing a 
support vector machine (SVM) with a Gaussian radial basis kernel function (RBF) 
is employed to predict intronless and intron-containing genes solely based on the 
primary sequences [138]. 
In SVM, there are two types of parameters: the penalty parameter C and 
the kernel type K. The penalty parameter C acts as a regularization parameter, 
controlling the balance between maximizing the margin and minimizing the training 
error. The kernel type K is another crucial parameter. For this problem, we 
utilize the radial basis kernel function K(xi, xj) = exp(−γ ||xi −xj||2). In this  
chapter, the parameter γ in the radial basis function plays a signiﬁcant role in 
determining the generalization ability of SVM by regulating the kernel function’s 
amplitude. Therefore, optimizing the two parameters C and γ is necessary. To 
perform parameter optimization, a grid search approach within a limited range can 
be employed. 
The dataset used to test this method consists of 1000 randomly selected intronless 
genes from UniProtKB/Swiss-Prot (release 15.1) and 1000 randomly selected 
intron-containing genes from Genbank database (release 170). These genes are 
derived from various eukaryotes such as humans, thale cress, and Mus musculus 
to ensure diversity and avoid similarity. Four methods, namely GENSCAN, N-
SCAN, Z-curve method, and DFA7, are compared in terms of classiﬁcation results 
(refer to Table 8.3 and Fig. 8.4). For the classiﬁcation process, a ﬁve-fold cross-
validation strategy is employed, and the parameter values (C, γ ) are selected as 
(16, 2−6) using a grid search approach. The results indicate that DFA7 exhibits the 
best performance among the four methods. 
8.4 The Lempel–Ziv Complexity and Its Application in 
Sequence Comparison 
In the following section, we will present the notion of Lempel–Ziv complexity, a 
valuable metric for quantifying the uncertainty of a sequence [142]. We will then 
utilize this measure to establish the distance between two genomes [143]. 
Table 8.3 Accuracy of different methods on 2000 mixed prokaryotic and eukaryotic genes (%) 
Methods
1
2
3
4
5
Average 
GENSCAN
76.50
74.00
76.75
78.25
77.50
76.60 ± 1.61 
N-SCAN
82.50
81.75
83.75
80.25
81.50
81.95 ± 1.29 
Z-Curve
88.75
87.25
85.25
83.75
85.75
86.15 ± 1.90 
DFA7
94.75
93.50
92.75
91.75
92.50
93.05 ± 1.14

8.4
The Lempel–Ziv Complexity and Its Application in Sequence Comparison
153
Fig. 8.4 The accuracy comparison of DFA7 and other three methods on 2000 mixed prokaryotic 
and eukaryotic genes 
Let S be a sequence deﬁned over an alphabet Ω, L(S) be the length of S, S(i) 
denotes the ith element of S, and S(i, j) deﬁnes the substring of S composed of 
the elements of S between positions i and j (inclusive). For DNA case, Ω = 
{A, C, G, T }, if  S = AACGT CGT CG, then L(S) = 10, S(4) = G, and 
S(4, 7) = GT CG. 
The Lempel–Ziv complexity of a sequence S can be quantiﬁed as the minimum 
number of steps needed to synthesize it within a speciﬁc process 
upper H left parenthesis upper S right parenthesis equals upper S left parenthesis 1 colon i 1 right parenthesis dot upper S left parenthesis i 1 plus 1 colon i 2 right parenthesis dot midline horizontal ellipsis dot upper S left parenthesis i Subscript k minus 1 Baseline plus 1 colon i Subscript k Baseline right parenthesis dot midline horizontal ellipsis dot upper S left parenthesis i Subscript m minus 1 Baseline plus 1 colon upper N right parenthesis periodH(S) = S(1 : i1)·S(i1+1 : i2)· · · · ·S(ik−1+1 : ik)· · · · ·S(im−1+1 : N).
(8.17) 
At each step, two operations are allowed: copying the longest fragment from the 
part of S that has already been synthesized, or generating a new symbol that ensures 
the uniqueness of each component S(ik−1 + 1 : ik). 
More speciﬁcally, at each step k, the sequence S is extended by concatenating 
a fragment S(ik−1 + 1 : ik). The length of this fragment is 1 if some symbol at 
position ik−1 + 1 occurs for the very ﬁrst time. Otherwise, this fragment is obtained 
by copying from the preﬁx S(1 : ik−1) and adding an additional symbol. The 
Lempel–Ziv complexity is the number of concatenating components in this process. 
For example, given a DNA sequence S = AACGT ACCAT T G, the Lempel–Ziv 
schema of synthesis gives the following components: H(S) = A· < A > C·G·T · < 
AC > C· < A > T · < T  > G  (here <> means that the copied part from the preﬁx 
and · separate each component), and the corresponding complexity CLZ(S) = 7.

154
8
New Features or Metric on Sequence Comparison
Another example is that, given a DNA sequence R = CT AGGGGACT T AT , 
the Lempel–Ziv schema of synthesis gives the following components: H(R) = 
C · T · A · G· < GGG > A· < CT  > T · < A > T , and CLZ(R) = 7. Note that, 
during one concatenating component, the part from the preﬁx can be continually 
copied many times, like G here. 
Ziv and Lempel [144] called the complexity decomposition of a sequence S 
following the above schema the exhaustive history of S and mathematically proved 
that every sequence S has a unique exhaustive history. 
The Lempel–Ziv complexity provides a powerful tool for measuring the similar-
ity between two DNA sequences [145]. Given two sequences S and R, consider 
the sequence SR and its Lempel–Ziv complexity. By deﬁnition, the number of 
components needed to build R when appended to S is CLZ(SR) − CLZ(S). This  
number will be less than or equal to CLZ(R) because at any given step of the 
production process of R (in building the sequence SR) we use a larger search space 
due to the existence of S. Therefore, if R is more similar to S than T , then we would 
expect CLZ(SR) − CLZ(S) to be smaller than CLZ(ST ) − CLZ(S). Here we adopt 
a similarity measure between two sequences P and Q as 
d left parenthesis upper P comma upper Q right parenthesis equals StartFraction upper C Subscript upper L upper Z Baseline left parenthesis upper P upper Q right parenthesis minus upper C Subscript upper L upper Z Baseline left parenthesis upper P right parenthesis plus upper C Subscript upper L upper Z Baseline left parenthesis upper Q upper P right parenthesis minus upper C Subscript upper L upper Z Baseline left parenthesis upper Q right parenthesis Over one half left parenthesis upper C Subscript upper L upper Z Baseline left parenthesis upper P upper Q right parenthesis plus upper C Subscript upper L upper Z Baseline left parenthesis upper Q upper P right parenthesis right parenthesis EndFraction periodd(P, Q) = CLZ(PQ) −CLZ(P) + CLZ(QP) −CLZ(Q)
1
2(CLZ(PQ) + CLZ(QP))
.
(8.18) 
Due to its successful application in the phylogenetic analysis of complete mam-
malian mitochondrial genomes, the Lempel–Ziv complexity has gained signiﬁcant 
usage and recognition [145]. 
The application of the Lempel–Ziv complexity in measuring the distance 
between multi-segmented genomes is extended in reference [143]. By deﬁning 
the distance between two sequences and employing the Hausdorff distance, it 
becomes possible to generalize this measurement to multi-segmented genomes. 
Additionally, the method can be further extended using a modiﬁed Hausdorff 
distance, as described in [146]. The modiﬁed Hausdorff distance is deﬁned as 
d2(A, B) = 1 
n

a∈A d(a, B), and then the modiﬁed Hausdorff distance is deﬁned 
by 
MHD left parenthesis upper A comma upper B right parenthesis equals max StartSet d 2 left parenthesis upper A comma upper B right parenthesis comma d 2 left parenthesis upper B comma upper A right parenthesis EndSet periodMHD(A, B) = max{d2(A, B), d2(B, A)}.
(8.19) 
8.5 An Information-Based Network Approach for Protein 
Classiﬁcation 
In the present section, we introduce a novel approach for protein classiﬁcation, 
which utilizes an information-based network methodology [147]. This innovative 
method is rooted in the principles of information theory and network analysis. 
Initially, it involves the construction of a discrete map representing the amino

8.5
An Information-Based Network Approach for Protein Classiﬁcation
155
acid sequences. The subsequent mathematical intricacies of this novel approach are 
delineated as follows. 
In our analysis, we examine the amino acid sequence data of proteins. A protein 
sequence consists of 20 distinct types of amino acids, which can be regarded as a 
discrete time series with 20 possible states. To facilitate further analysis, each amino 
acid is mapped uniquely to an integer value b ∈{1, 2, . . . ,  20}. By employing this 
mapping scheme, the entire protein sequence is transformed into a discrete time 
series representation. 
For a pair of integer time series X and Y, where X has a length of M and Y 
has a length of N (M  ≤ N), we deﬁne Yi (1 ≤ i ≤ N − M + 1) as the ith 
segment of length M in Y. The mutual information rate [148, 149] between X and 
Yi (1 ≤ i ≤ N −M + 1) is calculated as 
upper I left parenthesis upper X semicolon upper Y Subscript i Baseline right parenthesis equals sigma summation Underscript alpha element of upper S Subscript upper X Baseline comma beta element of upper S Subscript upper Y Sub Subscript i Subscript Baseline Endscripts p left parenthesis x equals alpha comma y equals beta right parenthesis log StartFraction p left parenthesis x equals alpha comma y equals beta right parenthesis Over p left parenthesis x equals alpha right parenthesis p left parenthesis y equals beta right parenthesis EndFraction periodI(X; Yi) =

α∈SX,β∈SYi
p(x = α, y = β)log p(x = α, y = β)
p(x = α)p(y = β).
(8.20) 
In the equation, SX and SYi represent the state sets (subsets of integers from 1 to 20) 
of X and Yi, respectively. It is important to note that the summation in this equation 
is position-free, as it encompasses all possible combinations of states between X and 
Yi. The mutual information rate is a probability expectation of logarithmic ratios, 
and it solely relies on the probability distribution of the states involved, rather than 
the speciﬁc values of the states themselves. 
By varying i from 1 to N −M +1, we obtain a series of mutual information rates: 
I1, . . . , IN−M+1. To determine the maximum mutual information rate between 
sequences X and Y, we select the largest value from this series: 
upper I Subscript upper X upper Y comma max Baseline equals max Underscript 1 less than or equals i less than or equals upper N minus upper M plus 1 Endscripts upper I left parenthesis upper X semicolon upper Y Subscript i Baseline right parenthesis periodIXY,max =
max
1≤i≤N−M+1 I(X; Yi).
(8.21) 
To calculate the maximum mutual information rates for each pair of integer 
sequences, we generate a matrix that represents these rates. In this matrix, denoted 
as IXY , each element corresponds to the maximum mutual information rate between 
the sequences X and Y. 
The mutual information rate provides a measure of the mutual relationships 
between sequences. By using the maximum mutual information matrix as the 
adjacency matrix, we can construct a protein network. In this network, each protein 
is represented as a node, and the connections between nodes are determined by 
their mutual relationships. The protein network is considered a weighted network, 
where the weights are given by the values in the adjacency matrix. It is important 
to note that the protein network is undirected because the mutual information rate is 
symmetric, meaning that the mutual information rate between protein X and protein 
Y is the same as the mutual information rate between protein Y and protein X [148]. 
a Subscript upper X upper Y Baseline equals a Subscript upper Y upper X Baseline equals upper I Subscript upper X upper Y comma max Baseline equals upper I Subscript upper Y upper X comma max Baseline periodaXY = aYX = IXY,max = IYX,max.
(8.22)

156
8
New Features or Metric on Sequence Comparison
The maximum mutual information rate IXY,max between two arbitrary sequences 
X (with a length of M) and Y (with a length of N) in the dataset is attained when a 
speciﬁc value of k exists, where 1 ≤ k ≤N − M + 1: 
upper I Subscript upper X upper Y comma max Baseline equals upper I left parenthesis upper X semicolon upper Y Subscript k Baseline right parenthesis periodIXY,max = I(X; Yk).
(8.23) 
Due to the upper bound imposed by the entropies in information theory [148, 
149], the mutual information rate is subject to the following relationship: 
upper I left parenthesis upper A semicolon upper B right parenthesis less than or equals min StartSet upper H left parenthesis upper A right parenthesis comma upper H left parenthesis upper B right parenthesis EndSet commaI(A; B) ≤min{H(A), H(B)},
(8.24) 
where H(A) = −
α∈SA 
p(a = α)logp(a = α), H(B) = −
β∈SB 
p(b = β)logp(b = 
β), and A and B denote two general sequences of the same length. Therefore, we 
have 
upper I Subscript upper X upper Y comma max Baseline equals upper I left parenthesis upper X semicolon upper Y Subscript k Baseline right parenthesis less than or equals min StartSet upper H left parenthesis upper X right parenthesis comma upper H left parenthesis upper Y Subscript k Baseline right parenthesis EndSet periodIXY,max = I(X; Yk) ≤min{H(X), H(Yk)}.
(8.25) 
In addition, Yk is a subsequence of Y, and we therefore have [148] 
upper H left parenthesis upper Y Subscript k Baseline right parenthesis less than or equals upper H left parenthesis upper Y right parenthesis commaH(Yk) ≤H(Y),
(8.26) 
and the inequality holds: 
upper I Subscript upper X upper Y comma max Baseline less than or equals min StartSet upper H left parenthesis upper X right parenthesis comma upper H left parenthesis upper Y right parenthesis EndSet periodIXY,max ≤min{H(X), H(Y)}.
(8.27) 
In order to enable a universal comparison between nodes, the adjacency matrix is 
normalized by dividing each element by the maximum entropy. Assuming there are 
N proteins in the database, the adjacency element between the ith and jth proteins 
is transformed as follows: 
a Subscript i j Baseline equals StartFraction upper I Subscript i j comma max Baseline Over max Underscript 1 less than or equals q less than or equals upper N Endscripts upper H Subscript q Baseline EndFraction commaaij =
Iij,max
max
1≤q≤N Hq
,
(8.28) 
where Hq denotes the entropy of the qth protein. By dividing each element of 
the adjacency matrix by the maximum entropy, the resulting values are bounded 
between 0 and 1, ensuring a standardized range for the elements. 
For the normalized adjacency matrix, a mutation threshold is deﬁned to ﬁlter the 
matrix. This threshold is determined by multiplying a constant with the maximum 
adjacency element. In other words, the mutative threshold can be expressed as 
upper T Subscript c Baseline equals c dot max Underscript i comma j Endscripts a Subscript i j Baseline periodTc = c · max
i,j aij.
(8.29)

8.5
An Information-Based Network Approach for Protein Classiﬁcation
157
The multiplicity, denoted as c, ranges from 0.1 to 1. For each value of c, denoted 
as Tc, it is used as a threshold to ﬁlter the adjacency matrix. Elements below 
this threshold are set to zero, while the rest remain unchanged. By examining 
the adjacency elements of the ﬁltered matrix, the connected components of the 
network can be identiﬁed. In matrix form, the ﬁltered adjacency matrix is raised 
to powers with exponents ranging from 1 to N − 1, where N represents the 
number of nodes in the network, which is also the size of the adjacency matrix. 
In a network, the connected components refer to the largest sets of nodes where 
all members are interconnected through at least one path [150]. To obtain these 
connected components, the adjacency matrix raised to the power s is summed from 
s = 1 to  s = N − 1. 
upper A Subscript sum Baseline equals sigma summation Underscript i equals 1 Overscript upper N minus 1 Endscripts upper A Superscript i Baseline periodAsum =
N−1

i=1
Ai.
(8.30) 
The connected components are deﬁned as the largest sets of nodes where 
all elements in the sum matrix Asum are positive. Adding new nodes to these 
components would result in the violation of this property. Intuitively, through 
reversible transformations, the sum matrix Asum can be transformed into a block 
diagonal form, where each block represents a connected component. 
Start 3 By 3 Matrix 1st Row 1st Column upper D 1 2nd Column 0 3rd Column midline horizontal ellipsis 2nd Row 1st Column 0 2nd Column upper D 2 3rd Column midline horizontal ellipsis 3rd Row 1st Column vertical ellipsis 2nd Column vertical ellipsis 3rd Column down right diagonal ellipsis EndMatrix period
⎛
⎜⎝
D1 0 · · ·
0 D2 · · ·
...
...
...
⎞
⎟⎠.
(8.31) 
Each connected component of the network is represented by a positive diagonal 
matrix, denoted as Di (i = 1, 2, . . .  ). 
By varying the multiplicity c, the connected components of the network undergo 
changes. The connected components obtained with a higher threshold exhibit 
stronger connections among their nodes compared to those obtained with a lower 
threshold. As a result, the connected components obtained with a higher threshold 
are encompassed by the connected components obtained with a lower threshold. 
Based on the inclusion or exclusion of these connected components, we create 
protein classiﬁcations. The presence or absence of speciﬁc connected components 
within a given threshold range determines the classiﬁcation of proteins. 
We apply this method to a dataset consisting of 35 NADH dehydrogenase 
proteins encoded by mitochondrial genes from 35 diverse mammalian species [47]. 
The classiﬁcation results of the 35 NADH dehydrogenase proteins are depicted 
in Fig. 8.5, where the proteins are represented by their corresponding mammalian 
species. The ﬁgure showcases the classiﬁcation of NADH dehydrogenase proteins 
based on their respective orders, namely Carnivora, Artiodactyla, Perissodactyla, 
Lagomorpha, Rodentia, Proboscidea, Primate, and Eulipotyphla. Within these

158
8
New Features or Metric on Sequence Comparison
Fig. 8.5 The ﬁgure illustrates the component graph of mitochondrial proteins from 35 mammalian 
species. It showcases the connected components derived from the adjacency matrix, which has 
been ﬁltered using various thresholds (Tc = c · Amax, c  ∈[0, 1]). Each set in the ﬁgure represents 
a connected component, and it demonstrates that components obtained with higher thresholds are 
inclusive of those obtained with lower thresholds. The proteins are represented according to their 
respective mammalian species 
orders, four primary clusters can be observed: Primate, Rodentia (including Norway 
rat and Vole), Eulipotyphla (including Hedgehog), and other non-primate orders. 
Within the primates, the classiﬁcation of NADH dehydrogenase proteins reveals 
three distinct groups. The ﬁrst group belongs to the Homininae family, which 
includes the Pygmy chimpanzee, Common chimpanzee, Gorilla, and Human (c = 
0.85). The second group consists of the Cercopithecidae family (baboon, Vervet 
monkey) and the Hominidae family (ape). Lastly, the third group belongs to the 
Hominidae family and speciﬁcally includes the Ponginae subgroup, represented by 
the Sumatran orangutan and Bornean orangutan (c  0.8). 
=
The classiﬁcation of non-primate orders is also accurate. The Carnivora order 
is divided into distinct groups: Phocidae (Gray seal and Harbor seal, c = 0.98), 
Ursidae (Brown bear, Polar bear, Black bear, and Giant panda, c = 0.94), Canidae 
(Dog and Wolf, c = 1), and Felidae (Cat and Tiger, Leopard, c = 0.94). The 
proteins within the Perissodactyla order (Indian rhinoceros and White rhinoceros, 
c = 0.93) are also properly grouped. Additionally, the proteins of the Artiodactyla 
order are classiﬁed into the Bovinae subfamily (Cow and Buffalo, c = 0.97), the 
Caprinae subfamily (Sheep and Goat, c = 0.96), and the Suidae family (Pig). It 
is worth noting that the rabbit, belonging to the Lagomorpha order, is a distinct 
species.

8.5
An Information-Based Network Approach for Protein Classiﬁcation
159
Within the diverse range of non-primate orders, the Carnivora order serves as the 
central group, surrounded by the Perissodactyla order and the Artiodactyla order. 
The clustering results obtained from this method exhibit consistency with other 
approaches, such as libSVM, which relies on machine learning techniques [151]. 
Furthermore, this method not only uncovers the mutual relationships between 
proteins but also identiﬁes clusters based on their connections, offering additional 
insights compared to machine learning methods.

References 
1. M.S. Waterman, Introduction to computational biology: maps, sequences and genomes, 
Chapman & Hall/CRC, New York, 1995. 
2. R. Tyagi, Computational molecular biology, Discovery Publishing House Pvt. Ltd., Delhi, 
2009. 
3. C.J. Benham, Sites of predicted stress-induced DNA duplex destabilization occur prefer-
entially at regulatory loci, Proceedings of the National Academy of Science USA, 90: 
2999–3003, 1993. 
4. T.E. Creighton, W.H. Freeman, et al., Protein folding, New York, 1992. 
5. D. Haig, L. Hurst, A quantitative measure of error minimization in the genetic code, Journal 
of Molecular Evolution, 33: 412–417, 1991. 
6. S.J. Freeland, L.D. Hurst, The genetic code is one in a million, Journal of Molecular 
Evolution, 47: 238–248, 1998. 
7. J. Konecny, M. Schöniger, G.L. Hofacker, Complementary coding conforms to the primeval 
comma-less code, Journal of Theoretical Biology, 173: 263–270, 1995. 
8. M. Eigen, B.F. Lindemann, M. Tietze, R. Winkler-Oswatitsch, A. Press, A. von Haeseler, 
How old is the genetic code? Statistical geometry of tRNA provides an answer, Science, 244: 
673–679, 1989. 
9. C. Kanz, P. Aldebert, et al., The embl nucleotide sequence database, Nucleic Acids Research, 
33: D29-D33, 2005. 
10. H. Sugawara, T. Abe, T. Gojobori, Y. Tateno, Ddbj working on evaluation and classiﬁcation 
of bacterial genes in insdc, Nucleic Acids Research, 35: D13-D15, 2007. 
11. D.A. Benson, M. Cavanaugh, K. Clark, I. Karsch-Mizrachi, J. Ostell, K.D. Pruitt, E.W. 
Sayers, GenBank, Nucleic Acids Research, 46: D41-D47, 2018. 
12. P. Rodriguez-Tome, P. Stoehr, G. Cameron, T. Flores, The European Bioinformatics Institute 
(EBI) databases, Nucleic acids research, 24, 6–12, 1996. 
13. E.C. Kamau, G. Winter(Eds.), Common Pools of Genetic Resources: Equity and Innovation 
in International Biodiversity Law, Routledge, 2013. 
14. The UniProt Consortium, Reorganizing the protein space at the universal protein resource 
(UniProt), Nucleic Acids Research, 40: D71-D75, 2012. 
15. C. H. Wu, L. S. Yeh, H. Huang, et al., The Protein Information Resource, Nucleic acids 
research, 31: 345–347, 2003. 
16. K. Najarian, S. Najarian, S. Gharibzadeh, C.N. Eichelberger, Systems Biology and Bioinfor-
matics: A Computational Approach, CRC Press, 2009. 
© The Author(s), under exclusive license to Springer Nature Switzerland AG 2023 
S. S.-T. Yau et al., Mathematical Principles in Bioinformatics, Interdisciplinary 
Applied Mathematics 58, https://doi.org/10.1007/978-3-031-48295-3
161

162
References
17. R.D. Finn, J. Mistry, J. Tate, P. Coggill, A. Heger, J.E. Pollington, O.L. Gavin, P. Gunesekaran, 
G. Ceric, K. Forslund, L. Holm, E.L. Sonnhammer, S.R. Eddy, A. Bateman, The pfam protein 
families database, Nucleic Acids Research, 38: D211-D222, 2010. 
18. C.J.A. Sigrist, E. Castro, L. Cerutti, B.A. Cuche, N. Hulo, A. Bridge, L. Bougueleret, I. 
Xenarios, New and continuing developments at PROSITE, Nucleic Acids Research, 41: 
D344-D347, 2013. 
19. F.C. Bernstein, T.F. Koetzle, G.J. Williams, E.E. Meyer, M.D Brice, J.R. Rodgers, O. Kennard, 
T. Shimanouchi, M. Tasumi, The protein data bank: a computer-based archival ﬁle for 
macromolecular structures, Journal of Molecular Biology, 112: 535–542, 1977. 
20. A.G. Murzin, S.E. Brenner, T. Hubbard, C. Chothia, Scop: a structural classiﬁcation of 
proteins database for the investigation of sequences and structures, Journal of Molecular 
Biology, 247: 536–540, 1995. 
21. F.M. Pearl, C.F. Bennett, J.E. Bray, A.P. Harrison, N. Martin, A. Shepherd, I. Sillitoe, 
J. Thornton, C.A. Orengo, The CATH database: an extended protein family resource for 
structural and functional genomics, Nucleic acids research, 31, 452–455, 2003. 
22. C.A. Orengo, A.D. Michie, S. Jones, D.T. Jones, M.B. Swindells, J.M. Thornton, Cath-a 
hierarchic classiﬁcation of protein domain structures, Structure, 5: 1093–1108, 1997. 
23. L. Holm, P. Rosenstrom, Dali server: conservation mapping in 3D, Nucleic Acids Research, 
38: W545-W549, 2010. 
24. T. Madej, K.J. Addess KJ, J.H. Fong, et al. MMDB: 3D structures and macromolecular 
interactions. Nucleic acids research, 40(Database issue): D461-D464., 2012. 
25. K.C. Wong, Computational Biology and Bioinformatics: Gene Regulation, CRC Press, 2016. 
26. A. Isaev, Introduction to mathematical methods in bioinformatics, Springer, 2005. 
27. M. O. Dayhoff, R. M. Schwartz, B. C. Orcutt, A model of Evolutionary Change in Proteins, 
Atlas of protein sequence and structure, 5: 345–358. 1978. 
28. S. Henikoff, J. Henikoff, Amino acid substitution matrices from protein blocks, Proceedings 
of the National Academy of Sciences of the United States of America, 89: 10915–10919, 
1992. 
29. S. B. Needleman and C. D. Wunsch, A general method applicable to the search for similarities 
in the amino acid sequence of two proteins, Journal of molecular biology, 48: 443–453, 1970. 
30. T. F. Smith and M. S. Waterman, Identiﬁcation of common molecular subsequences, Journal 
of molecular biology, 147: 195–197, 1981. 
31. D. J. Lipman, W. R. Pearson, Rapid and sensitive protein similarity searches, Science. 227: 
1435–1441, 1985. 
32. S. Altschul, W. Gish, W. Miller, E. Myers, D. J. Lipman, Basic local alignment search tool, 
Journal of Molecular Biology, 215: 403–410, 1990. 
33. D. G. Higgins, P. M. Sharp, CLUSTAL: a package for performing multiple sequence 
alignment on a microcomputer, Gene, 73: 237–244, 1988. 
34. R.H. Strunk, D.S. Stoer, Time series analysis and its applications: with R examples, Springer, 
third edition, 2010. 
35. C. Burge, S. Karlin, Prediction of complete gene structures in human genomic DNA, Journal 
of Molecular Biology, 268: 78–94, 1997. 
36. M.Q. Zhang, Identiﬁcation of protein coding regions in the human genome by quadratic 
discriminant analysis, Proceedings of the National Academy of Science USA, 94: 565–568, 
1997. 
37. S.A. Marhon, S.C. Kremer, Gene prediction based on DNA spectral analysis: a literature 
review, Journal of Computational Biology, 18: 1–28, 2011. 
38. S. Tiwari, S. Ramachandran, A. Bhattacharya, S. Bhattachrya, R. Ramaswamy, Prediction of 
probable genes by Fourier analysis of genomic sequences, CABIOS, 113: 263–270, 1997. 
39. D. Anastassiou, Frequency-domain analysis of biomolecular sequences, Bioinformatics, 16: 
1073–1081, 2000. 
40. C. Yin, S.S.-T. Yau, A Fourier characteristic of coding sequences: origins and a non-Fourier 
approximation, Journal of Computational Biology, 9: 1153–1165, 2005.

References
163
41. K. Shah, A. Krishnamachari, On the origin of three base periodicity in genomes, Biosystems, 
107: 142–144, 2012. 
42. C. Yin, S.S.-T. Yau, Prediction of protein coding regions by the 3-base periodicity analysis of 
a DNA sequence, Journal of Theoretical Biology, 247: 687–694, 2007. 
43. C. Yin, D. Yoo, S.S.-T. Yau, Tracking the 3-Base periodicity of protein-coding regions by the 
nonlinear tracking-differentiator, Proceedings of the 45th IEEE Conference on Decision & 
Control, 2094–2097, 2006. 
44. C. Yin, D. Yoo, S.S.-T. Yau, Denoising the 3-Base periodicity walks of DNA sequences in 
gene ﬁnding, Journal of Medical and Bioengineering, 2: 80–83, 2013. 
45. C. Yin, S.S.-T. Yau, Numerical representation of DNA sequences based on genetic code 
context and its applications in periodicity analysis of genomes, IEEE Symposium on 
Computational Intelligence in Bioinformatics & Computational Biology, 2: 223–227, 2008. 
46. X. Jiang, S.S.-T. Yau, A novel analysis model for DNA sequences, International Conference 
on BioMedical Engineering and Informatics, 1: 24–28, 2008. 
47. B. Zhao, R. He, S.S.-T. Yau, A new distribution vector and its application in genome 
clustering, Molecular Phylogenetics and Evolution, 59: 438–443, 2011. 
48. S.S.-T. Yau, J. Wang, A. Niknejad, C. Lu, N. Jin, Y. Ho, DNA sequence representation without 
degeneracy, Nucleic Acids Research, 31: 3078–3080, 2003. 
49. C. Yin, S.S.-T. Yau, An improved model for whole genome phylogenetic analysis by Fourier 
transform, Journal of Theoretical Biology, 382: 99–110, 2015. 
50. T. Hoang, C. Yin, S.S.-T. Yau, Numerical encoding of DNA sequences by chaos game 
representation with application in similarity comparison, Genomics, 108: 134–142, 2016. 
51. T. Hoang, C. Yin, H. Zheng, C. Yu, R. He, S.S.-T. Yau, A new method to cluster DNA 
sequences using Fourier power spectrum, Journal of Theoretical Biology, 372: 135–145, 
2015. 
52. F. Sievers, D.G. Higgins, Clustal Omega for making accurate alignments of many protein 
sequences, Protein Sci, 27: 135–145, 2018. 
53. R. Dong, Z. Zhu, C. Yin, R. He, S.S.-T. Yau, A new method to cluster genomes based on 
cumulative Fourier power spectrum, Gene, 673: 239–250, 2018. 
54. E. Hamori, J. Ruskin, H curves, a novel method of representation of nucleotide series 
especially suited for long DNA sequences, Journal of Biological Chemistry, 258: 1318–1327, 
1983. 
55. M.A. Gates, Simpler DNA sequence representations, Nature, 316: 219, 1985. 
56. L. Liu, Y. Ho, S.S.-T. Yau, Clustering DNA sequences by feature vectors, Molecular 
Phylogenetics and Evolution, 41: 64–69, 2006. 
57. C. Yu, Q. Liang, C. Yin, R. He, S.S.-T. Yau, A novel construction of genome space with 
biological geometry, DNA Research, 17: 155–168, 2010. 
58. C. Yu, M. Deng, S.S.-T. Yau, DNA sequence comparison by a novel probabilistic method, 
Information Sciences, 181: 1484–1492, 2011. 
59. C.M. Cover, J.A. Thomas, Elements of information theory, John Wiley and Sons, NY, 1991. 
60. R.R. Sokal and C.D. Michener, A statistical method for evaluating systematic relationships, 
University of Kansas science bulletin, 38: 1409–1438, 1958. 
61. S.S.-T. Yau, C. Yu, R. He, A protein map and its application, DNA and Cell Biology, 27: 
241–250, 2008. 
62. J. Fauchere, V. Pliska, Hydrophobic parameters of amino-acid side-chains from the partition-
ing of N-acetyl-amino acid amides, European Journal of Medicinal Chemistry, 18: 369–375, 
1983. 
63. C. Yu, S.Y. Cheng, R. He, S.S.-T. Yau, Protein map: An alignment-free sequence comparison 
method based on various properties of amino acids, Gene, 486: 110–118, 2011. 
64. X. Xia, W.H. Li, What amino acid properties affect protein evolution? Journal of Molecular 
Evolution, 47: 557–564, 1998. 
65. P.H.A. Sneath, Relations between chemical structure and biological activity, Journal of 
Theoretical Biology, 12: 157–195, 1966.

164
References
66. K. Tian, X. Yang, Q. Kong, C. Yin, R. He, S.S.-T. Yau, Two dimensional Yau-Hausdorff 
distance with applications on comparison of DNA and protein sequences, PLoS ONE, 10: 
e0136577, 2015. 
67. D.P. Huttenlocher, G.A. Klanderman, W.J. Rucklidge, Comparing images using the Hausdorff 
distance, IEEE Transactions on Pattern Analysis and Machine Intelligence, 15: 850–863, 
1993. 
68. D.P. Huttenlocher, K. Kedem, J.M. Kleinberg, On dynamic Voronoi diagrams and the 
minimum Hausdorff distance for point sets under Euclidean motion in the plane, Proceedings 
of the eighth annual symposium on Computational geometry, 110–119, 1992. 
69. L.P. Chew, M.T. Goodrich, D.P. Huttenlocher, K. Kedem, J.M. Kleinberg, D. Kravets, 
Geometric pattern matching under Euclidean motion, Computational Geometry, 7: 113–124, 
1997. 
70. G. Rote, Computing the minimum Hausdorff distance between two point sets on a line under 
translation, Information Processing Letters, 38: 123–127, 1991. 
71. B. Li, Y. Shen, B. Li, A new algorithm for computing the minimum Hausdorff distance 
between two point sets on a line under translation, Information Processing Letters, 106: 52– 
58, 2008. 
72. P.D. Hebert, A. Cywinska, S.L. Ball, J.R. deWaard, Biological identiﬁcations through DNA 
barcodes, Proc. Biol. Sci., 270: 313–321, 2003. 
73. Jeffrey, H. Joel, Chaos game representation of gene structure, Nucleic Acids Research, 18: 
2163–2170, 1990. 
74. T. Hoang, C. Yin, S.S.-T. Yau, Splice sites detection using chaos game representation and 
neural network, Genomics, 112: 1847–1852, 2020. 
75. A. Fiser, G. E. Tusnády, I. Simon, Chaos game representation of protein structures, Journal of 
Molecular Graphics, 12: 302–304, 1994. 
76. Z. Yu, V. Anh, K. Lau, Chaos game representation of protein sequences based on the detailed 
HP model and their multifractal and correlation analyses, Journal of Theoretical Biology, 226: 
341–348, 2004. 
77. Z. Sun, S. Pei, R. He, S.S.-T. Yau, A novel numerical representation for proteins: Three-
dimensional Chaos Game Representation and its Extended Natural Vector, Computational 
and Structural Biotechnology Journal, 18: 1904–1913, 2020. 
78. M. Deng, C. Yu, Q. Liang, R. He, S.S.-T. Yau, A novel method of characterizing genetic 
sequences: genome space with biological distance and applications, PLoS ONE, 6: e17293, 
2011. 
79. H. Musto, S. Caccio, H. Rodriguez, G. Bernardi, Compositional constraints in the extremely 
GC-poor genome of Plasmodium falciparum, Mem Inst Oswaldo Cruz, 92: 835–841, 1997. 
80. D.G. Mead, Newton’s Identities, The American Mathematical Monthly, 99: 749–751, 1992. 
81. C. Yu, T. Hernandez, H. Zheng, S.C. Yau, H. Huang, R. He, J. Yang, S.S.-T. Yau, Real time 
classiﬁcation of viruses in 12 dimensions, PLoS ONE, 8: e64328, 2013. 
82. D. Baltimore, Expression of animal virus genomes, Bacteriological reviews, 35: 235–241, 
1971. 
83. D. Baltimore, Viral genetic systems, Transactions of the New York Academy of Sciences, 33: 
327–332, 1971. 
84. D. Baltimore, The strategy of RNA viruses, Harvey lectures, 70: 57–74, 1974. 
85. H. Guo, W.S. Mason, C.E. Aldrich, J.R. Saputelli, D.S. Miller, A.R. Jilbert, J.E. Newbold, 
Identiﬁcation and characterization of Avihepadnaviruses isolated from exotic Anseriformes 
maintained in captivity, Journal of Virology, 79: 2729–2742, 2005. 
86. X. Chen, X. Ruan, Q. Zhao, H. Li, Molecular identiﬁcation of badnavirus in Dracaena 
sanderiana from Hubei of China, Scientia Agricultura Sinica, 42: 2002–2009, 2009. 
87. H. Huang, C. Yu, H. Zheng, T. Hernandez, S.C. Yau, R. He, J. Yang, S.S.-T. Yau, Global 
comparison of multiple-segmented viruses in 12-dimensional genome space, Molecular 
Phylogenetics and Evolution, 81: 29–36, 2014. 
88. D. Liu, W. Shi, Y. Shi, D. Wang, H. Xiao, W. Li, Y. Bi, Y. Wu, X. Li, J. Yan, W. Liu, G. 
Zhao, W. Yang, Y. Wang, J. Ma, Y. Shu, F. Lei, G.F. Gao, Origin and diversity of novel avian

References
165
inﬂuenza A H7N9 viruses causing human infection: phylogenetic, structural, and coalescent 
analyses, Lancet, 381: 1926–1932, 2013. 
89. M. Barrett, M.J. Donoghue, E. Sober, Against consensus, Systematic Zoology, 40: 486–493, 
1991. 
90. H. Zheng, C. Yin, T. Hoang, R. He, J. Yang, S.S.-T. Yau, Ebolavirus classiﬁcation based on 
natural vectors, DNA and Cell Biology, 34: 418–428, 2015. 
91. M. Levitt, Nature of the protein universe, Proceedings of the National Academy of Science 
USA, 106: 11079–11084, 2009. 
92. E.V. Koonin, Y.I. Wolf, G.P. Karev, The structure of the protein universe and genome 
evolution, Nature, 420: 218–223, 2002. 
93. E.V. Koonin, Metagenomic sorcery and the expanding protein universe, Nature Biotechnol-
ogy, 25: 540–542, 2007. 
94. C. Yu, M. Deng, S.C. Cheng, S.C. Yau, R. He, S.S.-T. Yau, Protein space: A natural method 
for realizing the nature of protein universe, Journal of Theoretical Biology, 318: 197–204, 
2013. 
95. H. Mellor, P.J. Parker, The extended protein kinase C superfamily, Biochem J, 332: 281–292, 
1998. 
96. X. Zhao, X. Wan, R. He, S.S.-T. Yau, A new method for studying the evolutionary origin 
of the SAR11 clade marine bacteria, Molecular Phylogenetics and Evolution, 98: 271–279, 
2016. 
97. H. Luo, Evolutionary origin of a streamlined marine bacterioplankton lineage, ISME Journal, 
9: 1423–1433, 2015. 
98. J. Viklund, T. Ettema, S. Andersson, Independent genome article and phylogenetic reclassiﬁ-
cation of the oceanic SAR11 clade, Molecular Biology and Evolution, 29: 599–615, 2012. 
99. J. Viklund, J. Martijn, T. Ettema, S. Andersson, Comparative and phylogenomic evidence that 
the alphaproteobacterium HIMB59 is not a member of the oceanic SAR11 clade, PLoS ONE, 
8: e78858, 2013. 
100. J. Gower, G. Ross, Minimum spanning trees and single linkage cluster analysis, J. Roy. Stat. 
Soc., 18: 54–64, 1969. 
101. N. Saitou, M. Nei, The neighbor-joining method: a new method for reconstructing phyloge-
netic trees, Mol. Biol. Evol., 4: 406–425, 1987. 
102. A. Enﬁssi, J. Codrington, J. Roosblad, M. Kazanji, D. Rousset, Zika virus genome from the 
Americas, Lancet, 387: 227–228, 2016. 
103. Y. Li, L. He, R. He, S.S.-T. Yau, Zika and Flaviviruses phylogeny based on the alignment-Free 
natural vector method, DNA and Cell Biology, 36: 109–116, 2017. 
104. R.S. Lanciotti, A.J. Lambert, M. Holodniy, S. Saavedra, L.C. Signor, Phylogeny of Zika virus 
in Western hemisphere, 2015, Emerging Infectious Diseases, 22: 933–935, 2016. 
105. X. Zhao, K. Tian, R. He, S.S.-T. Yau, Establishing the phylogeny of Prochlorococcus with a 
new alignment-free method, Ecology and Evolution, 7: 11057–11065, 2017. 
106. K. Tian, X. Zhao, S.S.-T. Yau, Convex hull analysis of evolutionary and phylogenetic 
relationships between biological groups, Journal of Theoretical Biology, 456: 34–40, 2018. 
107. X. Zhao, K. Tian, R. He, S.S.-T. Yau, Convex hull principle for classiﬁcation and phylogeny 
of eukaryotic proteins, Genomics, 111: 1777–1784, 2019. 
108. N. Sun, S. Pei, L. He, C. Yin, R. He, S.S.-T. Yau, Geometric construction of viral genome 
space and its applications, Computational and Structural Biotechnology Journal, 19: 4226– 
4234, 2021. 
109. A.M. Martinez, A.C. Kak, PCA versus LDA, IEEE Trans Pattern Anal Mach Intell, 23:228– 
233, 2001. 
110. X. Jiao and S. Pei and Z. Sun and J. Kang and S.S.-T. Yau, Determination of the nucleotide or 
amino acid composition of genome or protein sequences by using natural vector method and 
convex hull principle, Fundamental Research, 1: 559–564, 2021. 
111. R. Zhao, S. Pei, S.S.-T. Yau, New Genome Sequence Detection via Natural Vector Convex 
Hull Method, IEEE/ACM Transactions on Computational Biology and Bioinformatics, 19: 
1782–1793, 2022.

166
References
112. S.S.-T. Yau, W. Mao, M. Benson, R. He, Distinguishing proteins from arbitrary amino acid 
sequences, Scientiﬁc Reports, 5: 1–8, 2015. 
113. The UniProt Consortium, Activities at the universal protein resource (UniProt), Nucleic Acids 
Research, 42: D191-D198, 2014. 
114. B. Kuhlman, G. Dantas, G.C. Ireton, G. Varani, B.L. Stoddard, D. Baker, Design of a novel 
globular protein fold with atomic-level accuracy, Science, 302: 1364–1368, 2008. 
115. Y.L. Chan, M.S. Brown, D. Qin, N. Handa, D.K. Bishop, The third exon of the budding yeast 
meiotic recombination gene HOP2 is required for calcium-dependent and recombinase Dmc1-
speciﬁc stimulation of homologous strand assimilation, Journal of Biological Chemistry, 289: 
18076–18086, 2014. 
116. D. Deng, C. Xu, P. Sun, J. Wu, C. Yan, M. Hu, N. Yan, Crystal structure of the human glucose 
transporter GLUT1, Nature, 510: 121–125, 2014. 
117. T.W. Nilsen, B.R. Graveley, Expansion of the eukaryotic proteome by alternative splicing, 
Nature, 463: 457–463, 2010. 
118. J. Wen, R. Chan, S.C. Yau, R. He, S.S.-T. Yau, K-mer natural vector and its application to the 
phylogenetic analysis of genetic sequences, Gene, 546: 25–34, 2014. 
119. B.E. Blaisdell, A measure of the similarity of sets of sequences not requiring sequence 
alignment, Proceedings of the National Academy of Science USA, 83: 5155–5159, 1986. 
120. M.R. Kantorovitz, G.E. Robinson, S. Sinha, A statistical method for alignment-free compari-
son of regulatory sequences, Bioinformatics, 23: 249–255, 2007. 
121. X.W. Yang, T.M. Wang, A novel statistical measure for sequence comparison on the basis of 
k-word counts, Journal of Theoretical Biology, 318: 91–100, 2013. 
122. H.J. Yu, Segmented K-mer and its application on similarity analysis of mitochondrial genome 
sequences, Gene, 518: 419–424, 2013. 
123. T.J. Wu, Y.H. Huang, L.A. Li, Optimal word sizes for dissimilarity measures and estimation 
of the degree of dissimilarity between DNA sequences, Bioinformatics, 21: 4125–4132, 2005. 
124. G.E. Sims, S.R. Jun, G.A. Wu, S.H. Kim, Alignment-free genome comparison with feature 
frequency proﬁles (FFP) and optimal resolutions, Proceedings of the National Academy of 
Science USA, 106: 2677–2682, 2009. 
125. G.E. Sims, S.R. Jun, G.A. Wu, S.H. Kim, Whole-genome phylogeny of mammals: evolu-
tionary information in genic and non-genic regions, Proceedings of the National Academy of 
Science USA, 106: 17077–17082, 2009. 
126. R.H. Chan, T.H. Chan, H.M. Yeung, R.W. Wang, Composition vector method based on maxi-
mum entropy principle for sequence comparison, IEEE/ACM Transactions on Computational 
Biology and Bioinformatics, 9: 79–87, 2012. 
127. J. Qi, B. Wang, B.L. Hao, Whole proteome prokaryote phylogeny without sequence align-
ment: a k-string comparison approach, Journal of Molecular Evolution, 58: 1–11, 2004. 
128. J. Wen, Y. Zhang, A 2D graphical representation of protein sequence and its numerical 
characterization, Chemical Physics Letters, 476: 281–286, 2009. 
129. G.W. Stuart, M.W. Berry, An SVD-based comparison of nine whole eukaryotic genomes 
supports a coelomate rather than ecdysozoan linkage, BMC Bioinformatics, 5: 204, 2004. 
130. S.B. Hedges, K.D. Moberg, L.R. Maxson, Tetrapod phylogeny inferred from 18S and 28S 
ribosomal RNA sequence and a review of the evidence for amniote relationships, Molecular 
Biology and Evolution, 7: 607–633, 1990. 
131. C. Yu, R. He, S.S.-T. Yau, Protein sequence comparison based on K-string dictionary, Gene, 
529: 250–256, 2013. 
132. A. Minajeva, M. Kulke, J.M. Fernandez, W.A. Linke, Unfolding of titin domains explains the 
viscoelastic behavior of skeletal myoﬁbrils, Biophysical Journal, 80: 1442–1451, 2001. 
133. H.J. Yu, D.S. Huang, Novel 20-D descriptors of protein sequence and its applications in 
similarity analysis, Chemical Physics Letters, 531: 261–266, 2012. 
134. J. Wen, Y. Zhang, S.S.-T. Yau, K-mer Sparse matrix model for genetic sequence and its 
applications in sequence comparison, Journal of Theoretical Biology, 363: 145–150, 2014. 
135. G.W. Stuart, K. Moffett, J.J. Leader, A comprehensive vertebrate phylogeny using vector 
representations of protein sequences from whole genomes, Molecular Biology and Evolution, 
19: 554–562, 2002.

References
167
136. C. Eckart, G. Young, The approximation of one matrix by another of lower rank, Psychome-
trika, 1: 211–218, 1936. 
137. M.W. Berry, Z. Drmac, E.R. Jessup, Matrices, vector spaces, and information retrieval, SIAM 
Review, 41: 335–362, 1999. 
138. C. Yu, M. Deng, L. Zheng, R. He, J. Yang, S.S.-T. Yau, DFA7, a new method to distinguish 
between intron-containing and intronless genes, PLoS ONE, 9: e101363, 2014. 
139. C.T. Zhang, Z.S. Lin, M. Yan, R. Zhang, A novel approach to distinguish between intron-
containing and intronless genes based on the format of Z curves, Journal of Theoretical 
Biology, 192: 467–473, 1998. 
140. S. Lang, Eigenvectors and Eigenvalues. In: Introduction to Linear Algebra. Undergraduate 
Texts in Mathematics. Springer, New York, NY, 1986. 
141. C.K. Peng, S.V. Buldyrev, A.L. Coldberger, S.L. Havlin, F. Sciortino, Longrange correlations 
in nucleotide sequences, Nature, 356: 168–170, 1992. 
142. A. Lempel, J. Ziv, On the complexity of ﬁnite sequences, IEEE Transactions on Information 
Theory, 22:75–81, 1976. 
143. C. Yu, R. He, S.S.-T. Yau, Viral genome phylogeny based on Lempel-Ziv complexity and 
Hausdorff distance, Journal of Theoretical Biology, 348: 12–20, 2014. 
144. J. Ziv, A. Lempel, A universal algorithm for sequential data compression, IEEE Transactions 
on Information Theory, 23: 337–343, 1977. 
145. H.H. Otu, K. Sayood, A new sequence distance measure for phylogenetic tree construction, 
Bioinformatics, 19: 2122–2130, 2003. 
146. M.P. Dubuisson, A.K. Jain, A modiﬁed Hausdorff distance for object matching, Proceedings 
of the 12th IAPR International Conference on Pattern Recognition, Conference A: Computer 
Vision & Image Processing, 1: 566–568, 1994. 
147. X. Wan, X. Zhao, S.S.-T. Yau, An information-based network approach for protein classiﬁca-
tion, PLoS ONE, 12: e0174386, 2017. 
148. Y. Zhou, The basics of information theory, 3rd Edition, Beijing University of Aeronautics and 
Astronautics Press, 2006. 
149. K. Hlavackova, M. Palus, M. Vejmelka, J. Bhattacharya, Causality detection based on 
information-theoretic approached in time series analysis, Physics Reports, 441: 1–46, 2007. 
150. S.Z. Raina, J.J. Faith, T.R. Disotell, H. Seligmann, C.B. Stewart, D.D. Pollock, Evolution of 
base-substitution gradients in primate mitochondrial genomes, Genome Research, 15: 665– 
673, 2005. 
151. C. Chang, C. Lin, LibSVM: A Library for support vector machines, ACM Transactions on 
Intelligent Systems & Technology, 2: 1–27, 2011.

