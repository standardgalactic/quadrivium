Graph	 Â Primi*ves	 Â 
Dijkstraâ€™s	 Â Algorithm:	 Â 
Fast	 Â Implementa*on	 Â 
Design	 Â and	 Â Analysis	 Â 
of	 Â Algorithms	 Â I	 Â 

Tim	 Â Roughgarden	 Â 
Single-Â­â€Source	 Â Shortest	 Â Paths	 Â 
Length of path  
= sum of edge lengths 
Input: directed graph G=(V, E). (m=|E|, n=|V| ) 
â€¢â€¯ each edge has non negative length le 
â€¢â€¯ source vertex s 
 
Output: for each          ,compute 
L(v) := length of a shortest s-v path in G 
 
Assumption: 
1.â€¯ [for convenience] 
2.â€¯ [important] 
Path	 Â length	 Â =	 Â 6	 Â 

Tim	 Â Roughgarden	 Â 
Dijkstraâ€™s	 Â Algorithm	 Â 
Ini*alize:	 Â 
â€¢â€¯	 Â X	 Â =	 Â [s]	 Â 	 Â 	 Â 	 Â [ver*ces	 Â processed	 Â so	 Â far]	 Â 
â€¢â€¯	 Â A[s]	 Â =	 Â 0	 Â 	 Â [computed	 Â shortest	 Â path	 Â distances]	 Â 
â€¢â€¯	 Â B[s]	 Â =	 Â empty	 Â path	 Â [computed	 Â shortest	 Â 
paths]	 Â 
Main	 Â Loop	 Â 
â€¢â€¯	 Â while	 Â 	 Â XÇ‚V:
	 Â 	 Â 
	 Â -Â­â€need	 Â to	 Â grow	 Â 	 Â 
	 Â 
	 Â 
	 Â x	 Â by	 Â one	 Â node	 Â 
Main	 Â Loop	 Â contâ€™d:	 Â 
â€¢â€¯	 Â 	 Â 
	 Â 
	 Â 
	 Â 
[call	 Â it	 Â (v*,	 Â w*)]	 Â 
	 Â 
â€¢â€¯	 Â add	 Â w*	 Â to	 Â X	 Â 
â€¢â€¯	 Â set	 Â 
â€¢â€¯	 Â set	 Â 	 Â 	 Â 
	 Â 
	 Â  Â 
This array 
only to help 
explanation! 
Already 
computed in 
earlier iteration 

ğœƒ(ğ‘š+ğ‘›)	 Â 
ğœƒ(ğ‘šâ€‹logâ ğ‘›âŸ)	 Â 
ğœƒ(â€‹ğ‘›â†‘2âŸ)	 Â 
ğœƒ(ğ‘šğ‘›)	 Â 
Which	 Â of	 Â the	 Â following	 Â running	 Â *mes	 Â seems	 Â to	 Â best	 Â describe	 Â a	 Â 
â€œnaÃ¯veâ€	 Â implementa*on	 Â of	 Â Dijkstraâ€™s	 Â algorithm?	 Â 
â€¢â€¯ (n-1) iterations of while loop 
â€¢â€¯         work per iteration 
[        work per edge] 
 
CAN WE DO BETTER? 

Tim	 Â Roughgarden	 Â 
Recall: raison dâ€™Ãªtre of heap = perform Insert, Extract-Min in O(log n) time. 
[rest of video assumes familiarity with heaps] 
 
â€¢â€¯ conceptually, a perfectly balanced binary tree 
â€¢â€¯Heap property: at every node, key <= childrenâ€™s keys 
â€¢â€¯ extract-min by swapping up last leaf, bubbling down  
â€¢â€¯ insert via bubbling up 
Also: will need ability to delete from middle of heap. (bubble up or down as 
needed) 
Heap	 Â Opera*ons	 Â 
Height ~ log2n 

Tim	 Â Roughgarden	 Â 
Two	 Â Invariants	 Â 
Invariant # 1: elements in heap = 
vertices of V-X. 
Invariant #2: for  
Key[v] = smallest Dijstra greedy 
score of an edge (u, v) in E with v 
in X 
 
(of +     if no such edges exist) 
Point: by invariants, Extract-
Min yields correct vertex w* to 
add to X next. 
 
(and we set A[w*] to key[w*] ) 
 
Dijkstraâ€™s 
greedy score 
of (v, w) : 
A[v] +lvw  

Tim	 Â Roughgarden	 Â 
Maintaining	 Â the	 Â Invariants	 Â 
To maintain Invariant #2: [i.e., that 
Key[v] = smallest Dijkstra greedy  
score of edge (u,v) with u in X ] 
 
When w extracted from heap (i.e., added to X) 
â€¢â€¯ for each edge (w,v) in E: 
â€¢â€¯ if v in V-X (i.e., in heap) 
â€¢â€¯ delete v from heap 
â€¢â€¯ recompute key[v] = min{key[v] , A[w] + lwv } 
â€¢â€¯ re-Insert v into heap  
Key 
update 
Greedy score of (w,v) 
Need	 Â to	 Â 
update	 Â key!	 Â 
New	 Â 
crossing	 Â 
edges	 Â 

Tim	 Â Roughgarden	 Â 
Running	 Â Time	 Â Analysis	 Â 
You check: dominated by heap operations. (O(log(n)) each ) 
â€¢â€¯ (n-1) Extract mins 
â€¢â€¯ each edge (v,w) triggers at most one Delete/Insert combo  
(if v added to X first) 
So: # of heap operations in O(n+m) = O(m) 
So: running time = O(m log(n)) (like sorting) 
Since graph is 
weakly connected 

