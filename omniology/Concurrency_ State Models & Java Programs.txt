



The  Worldwide  Series  in  Computer  Science  has  been  created  to  publish  textbooks 
which both  address  and  anticipate  the  needs  of 
an  ever  evolving  curriculum 
thereby  shaping  its  future. 
It is  designed  for  undergraduates  majoring  in 
~omputer Science  and  practitioners  who  need  to  reskill. Its p~ilosophy derives 
from  the  conviction  that  the  discipline of computing  needs  to  produce  technically 
skilled  engineers  who  will  inevitably  face,  and  possibly  invent,  radically  new 
technologies t~roughout their  future  careers.  New  media  will 
be used  innova- 
tively  to  support high quality  texts  written by leaders  in  the  field. 
Published titles Ameraal, Co~puter ~raphics  for Java Progra~mers 
Ben-Ari, Ada  for  Software Engineers 
Ercegovac, Introduction to Digital Systems 
Gollmann, Com~uter Security 
Goodrich & Tamassia, Data  Structures and Algorith~s in Java 
Kotonya &: Sommerville, ~ e ~ u i r e ~ e n t s  
Engin~ering: Processes and 
Tec~ni~ues 
Lowe &: Hall, ~ypermedia & the Web: An ~ngineering Approach 
Preiss, Data Structures and Algorith~s with Object-Ori~nt~d 
Design 
Patterns in C + + 
Reiss, A Practical ~ntroduction  to  Software Design  with C+ $- 
Winder &: Roberts, Developing Java Software 


Copyright c) 
1999 by John Wiley & Sons  Ltd, 
Baffins  Lane, Chichester, 
West  Sussex P019 lUD, England 
National 
01243 
 
779777 
International 
(+44) 1243  779777 
e-mail  (for orders and customer service enquiries): 
Visit our Home Page on ht~://www.wiley.co.uk 
cs-books@wiley.co.uk 
or http://www.wiley.com 
Reprinted  November 1999, November 2000 
All rights reserved. No part of this publication may be reproduced, stored in a retrieval system, or 
transmitted, in any form  or  by any means, electro~c,.mechanical, photocopying, recording, scanning 
or otherwise,  except under the terms of the Copyright, Designs and Patents Act  1988 or under the 
terms of a  licence issued by the Copyright Licensing  Agency,  90 Tottenham Court Road,  London, 
W1P  9HE,  UK, without the prior permission  in writing of the publisher,_with the exception of any 
material supplied specifically  for the purpose of being entered and executed on a computer system 
for  exclusive  use by the purchaser of the publication. 
damage occasioned to any person or property through using the material, instructions, methods or 
ideas contained herein, or acting or refraining  from acting as a result of such use.  The authors and 
publisher expressly  disclaim  all implied warranties, including merchantability or fitness for any 
particular purpose. There  will be no duty on the authors or publisher to  correct any errors or  defects 
in the software. 
Every  effort has been made to  trace and acknowledge ownership of copyright. The publishers will 
be glad to hear from copyright holders whom it has not  been  possible to contact. 
Jeff Magee and Jeff Kramer have asserted their right under the Copyright, Designs and Patents 
Act  1988 to be identified as the authors of this work. 
Neither the authors nor John Wiley & Sons  accept any responsibility or liability  for  loss  or 
Other Wiley €~i~oriul 
Offices 
John Wiley & Sons, Inc.,  605 Third Avenue, 
New  York, NY 10158-0012, USA 
Weinheim . Brisbane + Singapore Toronto 
Library of’ Congress Cataloginfi-in-Publication Data 
Magee,  Jeff. 
Kramer 
Concurrency : state models & Java programs / Jeff  Magee and Jeff 
p. cm. - 
(Worldwide series  in computer science) 
Includes bibliographical  references and index. 
ISBN  0-471-98710-7 (hc. : alk. paper) 
1. Parallel p r o g r a ~ m ~ g  
(Computer science) 2. Java (Computer 
program language) I. Kramer,  Jeff. 11. Title. 111. Series. 
QA76.642M34  1999 
005.2’752-dc21 
 
98-51717 
CIP 
~ r ~ t i s h  
Library Catalofiui~fi 
in Publi~ation Data 
A catalogue record  for this book  is  available from the British Library. 
ISBN 0 471  98710 7 
Typeset  from the authors’ disks by Keyword’Publishing Services Ltd. 
Printed and bound in Great Britain by Bookcraft  (Bath)  Ltd,  Midsomer  Norton,  Somerset. 
This  book  is printed on acid-free paper responsibly manufactured from sustainable forestry, 
in  which at least two trees are planted for  each one used for paper production. 

hornas and John 
Jeff ho gee 
o Nitza, Lisa an 
~
e
~
f
 
 er 

This Page Intentionally Left Blank

1 .l 
1.2 
1.3 
1.4 
2.1 
2.2 
3 
3.1 
3.2 
Concurrent  Programs 
The  Modeling  Approach 
Practice 
Content  Overview 
Sumary 
Notes  and  Further  Reading 
Modeling  Processes 
~ m ~ l e m e n ~ g  
Processes 
Surrunary 
Notes  and  Further  Reading 
Exercises 
~ o n c ~ ~ r e n ~  
Exec~tion 
Modeling  Concurrency 
~ulti-Threaded Programs 
Sumary 
Notes  and  Further  Reading 
Exercises 
xi 
XV 
11 
11 
23 
31 
31 
32 
37 
38 
53 
60 
60 
61 


Con~en~s 
ix 
9 
9.1 
9.2 
9.3 
9.4 
9.5 
9.6 
9.7 
y
~
~
~
i
c
 
~ y § t e ~ §  
Golf  Club  Program 
Golf  Club  Model 
Fair  Allocation 
Revised  Golf  Ball  Allocator 
Bounded  Overtaking 
~ a s ~ e r - ~ l ~ v e  
Program 
Master-Slave  Model 
S ~ a r y  
Notes  and  Further  Reading 
Exercises 
10.1  Synchronous  Message  Passing 
10.2  Asynchronous  Message  Passing 
10.3  Rendezvous 
Summary 
Notes  and  Further  Reading 
Exercises 
11 
~ o ~ c ~ r r e n t   ~ r c h i t e c ~ r e s  
11 .l Filter  Pipeline 
11.2  Supervisor-Worker 
11.3  Announcer-Listener 
Smmary 
Notes  and  Further  Reading 
Exercises 
12.1  Modeling T h e d  Systems 
12.2  Implementing Thed Systems 
12.3  Parcel  Router  Problem 
12.4  Space  Invaders 
Summary 
Notes  and  Further  Reading 
Exercises 
A.l Processes 
A.2  Composite  Processes 
A.3 Cornrnon  Operators 
A.4  Properties 
183 
184 
188 
192 
194 
195 
197 
200 
201 
201 
203 
205 
205 
215 
221 
229 
230 
230 
233 
233 
246 
263 
270 
271 
272 
275 
276 
285 
293 
304 
314 
315 
315 
317 
317 
318 
319 
319 

B.l FSP  Description 
B.2 
Identifiers 
8.3 
Action  Labels 
B.4 const,  range,  set 
.5 Process  Definition 
B.6  Composite  Process 
B.7 
 
Parameters 
B.8 
Relabelkg and Hiding 
B.9  property,  progress  and  menu 
B.10 Expression 
B.11  Basic FSP 
~~~ 
 ema antics 
C.l Labeled  Transition  System  (LTS) 
C .2 Processes 
C.3  Composite  Processes 
C.4 C o m o n  Operators 
C.5 Safety  Properties 
C .6 Semantic  Equivalences 
endix 
322 
322 
323 
324 
325 
327 
329 
330 
331 
332 
334 
335 
335 
336 
337 
338 
340 
340 
343 
345 
349 

This  book  arose  from  concurrent  prograrnrning  courses  taught by the  authors  at 
Imperial  College  London  and from  their  experience  with  using  concurrency  in 
industrial  applications. It was  motivated by dissatisfaction  with  the  lack of prac- 
tical  and  accessible  techniques  that  aid  reasoning  about  designs 
for  concurrent 
software. 
Most  courses  and  textbooks  in  this  area  are  targeted  at 
e ~ ~ ~ e r  
the  theory  and 
formal  methods  aspects  of  concurrency 
or the  practical  aspects 
of concurrent 
prograrnrning  and  concurrency  in  operating  systems.  Due  to  the  lack  of  a  widely 
available  concurrent programing language,  textbooks  had  to  resort  to  special 
purpose  notations  that  could  not  easily 
be related by the  reader  to noma1 sequen- 
tial programing practice.  Two  recent  technical  developments  have 
made it pos- 
sible  to  offer  a  practical  and  accessible  approach  to  learning  about  concurrency 
and  concurrent p r o g r a ~ i n g .  
First,  model-checking  tools  have  made  the  use of 
design  models  for  concurrent  behavior  practical, 
~ o r m a t i ~ e  
and  rewarding. 
Second,  the  availability  and  widespread  use  of  Java  has  solved  the  problem 
of 
finding  an  accessible  general  purpose programing language  with  in-built  con- 
currency  constructs. As a  result,  this  book  offers  a  soundly-based  systematic 
approach  to  the  development of concurrent  software  which  is  supported by soft- 
ware  tools,  is  interesting  and fun to  use,  and  can 
be used  to  develop  practical 
concurrent  programs. 
The  book  provides  a  comprehensive  description  and  explanation 
of the  important 
concepts and t e c ~ n ~ ~ ~ e s  
in  concurrent p r o g r a m ~ g ,  
the  problems  that  arise  and 
the  means  for  ensuring  that  desirable  properties  are  achieved  and  undesirable 
ones  avoided.  Readers  will  learn  about  concepts  such  as  threads  and  interaction, 

xii 
P?+&? 
gain  an  appreciation  of  how  these  lead 
to problems  such  as  interference  and 
deadlock,  and  learn  how  to  use  techniques  such 
as exclusion  and synchro~~ation 
to good  effect. 
To  ensure  a  thorough ~ n d e r s ~ ~ n d i ~ g ,  
concurrency  concepts,  techniques  and  pro- 
blems  are  presented in  many forms: through idorma1 descriptions  and il~ustrative 
examples,  abstractly  in  models  and  concretely  in  Java.  The  modeling  techniques 
will  enable  readers  to  reason  about  the  properties of their  proposed  designs  and 
programs. As in  other  engineering  disciplines,  modeling  is  promoted  as  a  means 
to  gaining  greater  confidence  in  the  proposed  designs.  Using  Java,  readers  can 
turn  their  designs  into  programs. 
Together  with  a  knowledge  and  understanding 
of the  principles of concur- 
rency,  readers  can  expect  to  aquire 
experience in its  application.  The  book  uses 
examples  to  illustrate  concepts  and  techniques,  and  exercises  for  learning 
by 
doing.  Use  of  the  associated  analysis  tool  provides  practical  experience 
of con- 
currency  modeling,  model  animation,  model  property  checking  and  model  correc
tion.  Similarly,  use 
of Java  provides  practical  experience 
of p r o g r a ~ i n g  
concurrency. 
Thus,  the  book  provides: 
a  systematic  treatment of the  concepts  and  issues  in  concurrency; 
a  rigorous  technique  to  specify  and  model  concurrent  behavior,  with  analysis 
tools  for  animation  and  verification; 
a  wide  range of Java  examples  to  illustrate  the  concepts  and  issues  in  concur- 
rent  programming. 
We  hope  that  this  will  leave  readers  with  the  ability  to  use  concurrency  with 
confidence  and  expertise,  recognizing  when  problems  might  arise  and  knowing 
how  to  avoid  or  solve  them.  Concurrency  is  a  fascinating  and  challenging  area 
of 
software  design.  The  combination 
of Z e ~ r ~ i ~ g  
and doing should  make  acquiring 
design  skills in this  area  an  interesting  and  enjoyable  process.  We  hope  that  read- 
ers  will  find  that  concurrency  can be both  challenging  and  fun! 
The  book  is  intended  for  students in Computer  Science  and  for  professional soft- 
ware  engineers  and  programmers.  We  believe  that  it  has  much 
to offer  for  anyone 
interested  in  the  concepts of concurrency,  interaction  and  synchronization. 
Readers  are  expected  to  have  some 
~ a c k g r o ~ d  
in sequen~al p r o g r a ~ i n g  
and  an  acquaintance  with  object-oriented  concepts.  Some  knowledge  of  operating 
systems  concepts  is  an  advantage,  but  is  not  a  prerequisite. 

Prejace 
xiii 
The material  has  been  used  by  a  variety 
of students: ~dergraduate students  in 
the  second  year 
of three  and  four  year  computing,  software  engineering  and 
combined  computing/electrical  engineering  degree  courses;  and  graduate 
students  taking  conversion  courses  in  computing.  In  all  cases,  the  material  repre- 
sented  the  students’  first  introduction  to  concurrent  programming. 
Chapters 1 to 8 are  designed to provide  a  comprehensive  and  cohesive  course 
on  concurrency.  They  cover  the  main  concepts  of  concurrency,  including  model- 
ing,  programming  and  the  process 
of model-based  design.  Since  each  chapter 
builds on  the  preceding  one,  we  recommend  that  these  chapters be read  sequen- 
tially from start  to  finish. 
Chapter 9 to 12 provide  more  advanced  material  on  dynamic  systems,  message 
passing,  concurrent  software  architectures,  and  timed  systems.  Readers  may  pick 
and  choose  from  these  according  to  their  interests. 
Accompanying  this  book  are  the  following: 
Java  examples  and  demonstration  programs 
state  models  for  the  examples 
the  LTSA  analyzer  for  concurrency  modeling,  model  animation,  and  model 
property  checking 
overhead  slides  for  course  presentation 
These  are  provided  on  the 
accom~anying CD-ROM  and  at  the  following 
URL: ht~://www-dse.doc.ic.ac.uk/concurrency/ 

This Page Intentionally Left Blank

We wish  to thank our colleagues in the  Distributed  Software  Engineering  research
section  for  many  helpful  discussions  over  the  years, 
and for  their  contributions  to 
the  work on software  architecture.  In  particular,  we  gratefully  acknowledge  the 
contributions of Shing  Chi (SC) Cheung and Dimitra ~ i a ~ a k o p o u l o u  
to  the  work 
on behavior  analysis. SC had the  insight  to  select LTS as an appropriate modeling 
formalism, provided much of the  ground-work and was a prime  contributor  to 
our investigation of safety  properties.  Dimitra has contributed  crucial  work in the 
theory and analysis of safety,  liveness and progress  properties, and the  semantics 
of  FSP. 
Our thanks, are due to  Steve  Crane,  Nat  Pryce,  Wolfgang Emerich and the 
anonymous  reviewers  for  their  useful  comments and suggestions on early drafts 
of the  book.  Their  encouragement, and the  enthusiasm of our students, is  greatly 
appreciated. We would like  to  thank  Storm  Thorgerson,  the  cover  designer, who 
worked  beyond  the  call 
of duty and even  friendship  to  produce 
a cover worthy of 
a trainspotter  extraordinaire. 
Finally,  we would like  to  thank  our  families  for  their  tolerance 
during the 
writing of this  book. Our children - 
Lisa,  Alon,  Thomas and John - 
were  kind 
enough  to  feign  enthusiam  for  the  examples and demonstration applets. Let us 
hope  that  the  delusion of future fortune, with which  we  placated our wives  Nitza 
and Judith, is  not  revealed as such  too  soon. 
Jeff  Magee and Jeff Kramer 
April 1999 

This Page Intentionally Left Blank

Between  June  1985  and  January  1987,  a  computerized  radiation  therapy  machine 
called  Therac-25  caused  six  known  accidents  involving  massive  overdoses  with 
resultant  deaths  and  serious  injuries.  Although  most  accidents  are  systemic  invol- 
ving  complex  interactions  between  various  components  and  activities,  and 
Therac-25  is  not  an  exception  in  this  respect,  concurrent 
p r o g r a ~ n g  
errors 
played an important  part  in  these  six  accidents.  Race  conditions  between  differen
concurrent  activities  in  the  control  program  resulted  in  occasional  erroneous  con- 
trol  outputs. ~urthermore, the  sporadic  nature 
of the  errors  caused 
by faulty 
concurrent  programs  contributed  to  the  delay  in  recognizing  that  there  was  a 
problem.  The  designers  of  the  Therac-25  software  seemed  largely  unaware 
of 
the  principles  and  practice  of  concurrent  programming. 
The  wide  acceptance of Java  with  its  in-built conc~rency constructs  means  that 
concurrent  programming  is  no  longer  restricted  to  the  minority of p r o g r a ~ e r s  
involved in operating  systems  and  embedded  real-time  applications. 
 onc currency 
is  useful  in  a  wide  range  of  applications  where  responsiveness  and  throughput  a
issues. M i l e  most  programmers  are  not  engaged  in  the  implementation 
of safety 
critical  systems such as  Therac-25,  increasing  numbers  are using  concurrent  pro- 
g r a ~ n g  
constructs  in  less  esoteric  applications.  Errors  in  these  applications  and
systems  may  not be directly l i f e - t ~ e a t e ~ g  
but  they  adversely  affect  our  quality 
of life  and  may  have  severe  financial  implications. h 
~derstanding of  the  prin- 
* 
ciples of concurrent  programming  and  an  appreciation 
of how it is  practiced  is  an 
essential  part of the  education of computing  science  undergraduates  and of the 
background  of  software  engineering  professionals.  The  pervasive  nature of com- 
puting  and  the  Internet  make it also an  important  topic  for  those  whose  primary 
activity  may  not be computing  but  who  write  programs  none  the  less. 

2 
Chapter 1: ~ntru~~ctiun 
Most  complex  systems  and  tasks  that  occur  in  the  physical  world  can be broken 
down into  a  set  of  simpler  activities.  For  example,  the  activities  involved 
in build- 
ing a  house  include  bricklaying,  carpentry,  plumbing,  electrical  installation  and 
roofing.  These  activities  do  not  always  occur  strictly  sequentially,  one  after  the 
other,  but  can  overlap  and  take  place  concurrently.  For  example,  the  plumbing 
and  wiring 
in a  new  house  can  be  installed  at  the  same  time.  '"he  activity 
described by a cornputer  program  can  also  be  subdivided  into  simpler  activities 
each  described by a  subprogram.  In  traditional  sequential  programs,  these  sub- 
programs  or  procedures  are  executed  one  after  the  other  in  a  fixed  order  deter- 
mined by the  program  and  its  input.  The  execution 
of one  procedure  does  not 
overlap  in  time  with  another.  In  concurrent  programs,  computational  activities  are 
permitted  to  overlap  in  time  and  the  subprogram  executions  describing  these 
activities  proceed concurr~ntly . 
The  execution  of  a  program  (or  subprogram)  is  termed  a process and  the  execu- 
tion  of  a  concurrent  program  thus  consists  of  multiple  processes. As we  see  later, 
concurrent  execution  does  not  require  multiple  processors.  Interleaving  the 
instructions  from  multiple  processes 
on a  single  processor  can be used  to  simulate 
concurrency,  giving  the  illusion  of  parallel  execution.  Of  course, 
if a  computer  has 
multiple  processors  then  the  instructions  of  a  concurrent  program  can  actually 
be 
executed  in  parallel  rather  than  being  interleaved. 
Structuring  a  program as a  set of concurrent  activities  or  processes  has  many 
advantages.  For  programs  that  interact  with  the  environment  to  control  some 
physical  system,  the  parallelism  and  concurrency  in  that  system can be reflected 
in  the  control  program  structure.  Concurrency  can  be  used  to  speed  up  response 
to  user  interaction 
by offloading  time-consuming  tasks 
to separate  processes. 
 roughp put can  be  improved by using  multiple  processes  to  manage 
comunica- 
tion  and  device  latencies.  These  advantages  are  illustrated  in  detail  in  subsequent 
chapters.  However,  the  advantages 
of concurrency  may  be  offset by the  increased 
complexity  of  concurrent  programs.  ana aging this  complexity  and  the  principles 
and tech~ques necessary  for  the  construction  of  well-behaved  concurrent  pro- 
grams  is  the  main  subject  matter  of  this  book. 
In  order  to  illustrate  the  need  for  a  rigorous  approach  to  concurrent  program 
design  and  implementation,  let  us  consider  an  example. 
Consider  an  automobile  cruise  control  system  that  has  the  following  require- 
ments. It is  controlled by three  buttons: r e s ~ ~ e ,  
on and off (Figure 1.1). When  the 
engine is running  and on is pressed, the  cruise  control  system  records  the  current 
speed  and  maintains  the  car  at  this  speed.  When  the  accelerator,  brake  or 
off is 
pressed,  the  cruise  control  system  disengages  but  retains  the  speed  setting. 
If 

Figure 1.1 Cruise control system. 
resume is  pressed,  the  system  accelerates  or  de-accelerates  the  car  back  to  the 
previously-recorded  speed. 
Our  task  is  to  provide  a  Java  program  that  satisfies  the  specified  requirements 
and behaves  in  a  safe  manner.  How  should  we  design  such  a  program?  What 
software  processes  should  we  construct 
and how  should  we  structure  them  to 
form a  program?  How  can  we  ensure  that  our  program  provides  the  behavior  t
we require  while  avoiding  unsafe  or  undesirable  behavior? 
Given  no  guidance, we may  be  tempted  simply  to  use  previous  design  experi- 
ence and construct  the  program as best  as  we  can,  using  the 
appropriate Java 
concurrency  constructs. To test  the  cruise  control  software,  we  could  construct  a 
sirnulation  environment  such  as that illustrated  in  Figure 1.2. The  accompanying 
CD-ROM contains  this  environment  as 
an interactive  Java  applet  for  use 
and 
experimentation.  The buttons at the  bottom of the  display  can  be  used  to  control 
the  sirnulation:  to  switch  the  engine  on  or  off;  to 
resume or turn the  cruise  control 
system on or of; and to  press  the  accelerator or brake  (simulated  by  repeatedly 
pressing  the  relevant button). 
The  behavior of the  system  can  be  checked  using  particular  scenarios  such as 
the  following: 
Is the  cruise  control  system  enabled  after  the  engine  is  switched  on and the on 
button is  pressed? 
Is  the  cruise  control  system  disabled  when  the  brake  is  pressed? 
Is the  cruise  control  system  enabled  when resume is  then  pressed? 
However,  testing  such  software  is  difficult, as there  are  many  possible  scenarios. 
How do we h o w  when we have  conducted  a  sufficient  number 
of test  scenarios? 
For  instance, what happens in  the  unlikely  event  that  the  engine  is  switched 
off 
while  the  cruise  control  system  is  still  enabled?  The  system  behaves  as  follows.  I
ret~ins the  cruise cont~o~  se~~ing, 
and,  when  the  ignition  is  again  switched  on,  the  
accelerates so as  to  resume  the  previous  speed  setting! 

Figure 1.2 Simulation of the  cruise  control  system. 
Would  testing  have  discovered that this dangerous behavior  is  present in the 
system?  Perhaps, but in general  testing is extremely  difficult  for  concurrent  pro- 
grams as it relies  on  executing  the  particular  sequence of events and actions that 
cause  a  problem.  Since  concurrent  events  may  occur  in 
any order,  the  problem 
sequences  may  never  occur in the  test  environment, but may  only  show up in the 
deployed  system, as with the Therac-25  machine. 
There must be  a  better  way  to  design, 
check and construct  concurrent  pro- 
grams! 
A model is a  simplified  representation of the  real  world and, as such,  includes 
only  those  aspects of the  real-world  system  relevant  to  the  problem at hand. For 
example,  a  model  airplane,  used  in  wind 
tunnel tests,  models  only  the  external 
shape of the airplane. The power of the  airplane  engines,  the  number 
of seats and 
its  cargo  capacity do not affect the  plane’s aerod~amic properties, Mo~els are 
widely  used  in  engineering  since  they  can  be  used  to  focus  on  a  particular  aspe
of a  real-world  system  such as the  aerodynamic  properties of an airplane  or  the 
strength of a  bridge. The reduction in scale and complexity  achieved  by  modeling 

2.2 The ~ o ~ e l i ~ g  
Appro~ch 
5 
allows  engineers  to  analyze  properties  such as the  stress and strain on  the  struc- 
tural components of a  bridge.  The  earliest  models  used  in  engineering,  such 
as 
airplane  models  for wind tunnels and ship models  for drag tanks,  were  physical, 
Modern  models  tend to be  mathematical in nature and as such  can  be  analyzed 
using  computers. 
This  book  takes  a  modeling  approach  to  the  design 
of concurrent  programs. 
Our models re~resent the  behavior of real  concurrent programs written in Java. 
The  models  abstract  much of the  detail of real programs concerned  with data 
representation,  resource  allocation and user  interaction. They  let us focus on con- 
currency. We can  animate  these  models  to  investigate  the  concurrent  behavior 
of 
the  intended program. More  importantly,  we  can ~ e c ~ ~ ~ ~ c ~ 2 2 ~  
verify  that  a  model 
satisfies  particular  safety and progress  properties,  which  are  required of the  pro- 
gram when it is  implemented.  This  mechanical  or  algorithmic  verification  is 
made 
possible  by  a  model-checking  tool LTSA (Labeled  Transition  System  Analyzer). 
Exhaustive  model-checking  using LTSA allows us to  check  for  both  desirable and 
 desirable properties  for  all  possible  sequences of events and actions. LTSA is 
r  vi  d  with  this  book 
and is  also  available  from  the  World  Wide Web 
). As  it has been  implemented in Java, 
on  a wide range of platforms,  either as an applet or as an application program. 
The models  introduced  in  the  book are based on finite state machines.  Finite 
state  machines  are  familiar  to  many  programmers 
and engineers. They are used  to 
specify  the  dynamic  behavior 
of objects in well-known  object-oriented  design 
methods  such as Booch,  (1986),  OMT  (Object  Modeling  Technique) (~umbaugh, 
1991) and, more  recently,  the  all-encompassing 
UML (Unified  Modeling 
Language)  (Booch,  1998).  They  are  also  extensively  used in the  design of digital 
circuits - 
the original engineering use. 
For those not yet familiar 
with state 
machines,  they  have an intuitive  easily  grasped  semantics and a  simple  graphical 
representation.  The 
state machines  used 
in this  book  (technically,  Labeled 
Transition  Systems)  have  well-defined  mathematical  properties,  which  facilitate 
formal  analysis and mechanical  checking, thus avoiding  the tedium (and error 
introduction)  inherent  in  manual  formal  methods. 
For  instance,  for  the  cruise  control  system  described 
in section 1.1, we can 
model  the  various  processes of the  system as state machines. A state machine 
for  the  process  responsible  for  obtaining  the  current  speed  is  given 
in Figure 
1.3.  Starting  from 
st~~e(O), 
it indicates that once  the  engine  is  switched  on, 
it transits 
to  state(1) and can  then  repeatedly  obtain  a  speed  reading  until  the  engine  is 
switched off, when it returns to st~te(0). Other  processes  can  be  modeled  similarly. 
We can  compose  the  system  from  the  constituent  processes  according  to  the 
proposed  design  structure,  indicatin  the  interactions  between  the  processes. 
The advantage is that such  models  can  be  used  to  animate 
and check the  behavior 
of the  overall  system before it is  implemented.  Figure  1.4  shows 
an animation of the 

en~ineOn 
en~ineoff 
Figure 1.3 Speed input process. 
model  for  the  cruise  control  system. It clearly  shows  the  problem  encountered  in 
our  simulation: if the  engine  is  switched  off  and  on  again  when  cruise  control  is 
enabled,  the  previous  speed  setting  is 
resmed. Exhaustive  analysis  can be used  to 
identify  the  problem  under  all  possible  situations.  Furthermore,  to  help  under- 
stand  and  correct  the  problem,  the  model  checker  produces  the 
 articular 
sequence of actions  that  led  to  it! 
Later  chapters  describe  and  illustrate  how  to  provide  and  use  such  models  to 
gain  confidence in the  correctness  and  validity of a  proposed  design.  We  illustrate 
Figure 1.4 Animation of the cruise control system. 

how  premature  and  erroneous  implementations  can  be  avoided  by  careful  mod- 
eling  and  analysis.  Further,  we  indicate  how  such  models  can 
be systematically 
transformed  into  Java  programs.  The  cruise  control  system  is  fully  described, 
modeled  and  implemented  in  Chapter 8. 
Note  that  representing  state  .machines  graphically  severely  limits  the  complex- 
ity  of  problems  that  can be addressed.  Consequently,  we  use  a  textual  notation 
(Finite State Processes, FSP) to  describe  our  models.  The 
LTSA tool  associated  with 
the  book  translates FSP descriptions  to  the  equivalent  graphical  description.  The 
book  itself  presents  the  initial  models  in  both  textual  and  graphical  forms  to  en
the  reader  to  become  familiar  with  the  meaning  of FSP descriptions.  Technically, 
FSP is  a  process  calculus - 
one  of  a  family  of  notations  pioneered  by  Milner 
(1989), 
Calculus  of C o ~ u ~ c a t i n g  
Systems  (CCS),  and  Hoare 
(1985), Co~unicating 
Sequential  Processes (CSP), for  concisely  describing  and  reasoning  about  concur- 
rent  programs.  The  difference 
from  these  notations  is  largely  syntactic: 
FSP is 
designed  to be easily  machine  readable.  Like  CCS  and  GSP, 
FSP has  algebraic 
properties;  however,  it  is  used  in  this  book  primarily  as  a  concise  way  of  describ- 
ing  Labeled  Transition  Systems. 
Previous  authors  of  concurrent p r o g r a ~ i n g  
textbooks  have  been  hampered by 
the  lack  of  a  widely  available  and  generally  accepted  programming  language 
with 
concurrency  features.  Java  meets  the  criteria  of  availability  and  acceptance  and  ha
the  advantage  of  being  a  general-purpose  language  with  concurrency  rather  than 
a  special  purpose  language  of  restricted  applicability.  Consequently,  we  use  Java 
exclusively  as  the  language  for 
p r o g r a ~ i n g  examples.  The  simplicity 
of the 
concurrency  features  in  Java  is  an  advantage  since  more  complex  concurrency 
abstractions  can be constructed  and  packaged  as  classes. 
The  full  source  of  the  set  of  example  programs  presented  in  the  book  is  pro- 
vided  with  the  book  and  is  available  on  the  Web.  In  addition,  all  of  the  example 
programs  may  be  run  as  applets  in  Web  browsers.  We  believe  that  the  ability  to 
execute  the  programs  is  a  significant  aid  to  understanding  the  issues  involved,  Th
controls  embedded  in  most  of  the  example  programs  enable  different  execution 
scenarios  to  be  set  up,  facilitating 
"what if " 
questions  to be asked  of  the  programs. 
The  satisfaction  of  seeing  (and  experiencing)  rather  than  merely  believing  is 
important  in  sustaining  both  interest  and  comprehension,  This  is  as  true  for 
self-study  as  it  is  for  formally  taught  courses. 
The  availability  of  Java  on  a  wide  range  of  platforms  means  that  most  readers 
will  be  able  to  treat  both  the  modeling  and 
p r o g r a ~ i n g  
problems  included in the 
book as implementation  rather  than  purely  pen-and-paper  exercises.  In  many  of 

the  problems  a  graphical  interface  is  already  provided 
so that  the  reader  can 
concentrate  on  the  concurrent p r o g r a ~ g  
component of the  problem. 
~e  make  no  apologies  for  including  in  the  set 
of examples  and  exercises  those 
that  are  sometimes dispara~ingly referred  to as ”toy  problems”.  Typical of this 
class of example  is  the Dining Philosophers  problem.  The  authors  regard  these 
examples as being  valuable  in  condensing  and  crystallizing  particular  concurrent 
p r o g r a ~ i n g  
problems.  They  let  the  reader  concentrate  on  the  concurrency  issue
without  the  burden of understanding  the  application  context.  These  examples  are 
widely  used in the  literature  on  concurrent 
p r o g r a ~ i n g  
as a  means of comparing 
different  concurrent  programming  languages  and  constructs. 
The  concepts  of  concurrency  are  presented  in  a  careful,  systematic  manner.  Each 
concept  is  introduced  and  explained,  indicating  how  it  is  modeled  and  implemen- 
ted.  In  this  way,  state  models  and  Java  programs  are  presented  hand-in-hand 
throughout  the book. Furthermore,  every  chapter  uses  examples  to  illustrate  the 
concepts,  models  and  programs. 
The  next two chapters  introduce  the  basic  concepts 
of concurrent  program- 
ming.  Chapter 2 introduces  the  concept  of  a  process,  for  modeling  a  sequence of 
actions,  and  a  thread,  for  implementing such a  sequence  in  Java.  Chapter 3 intro- 
duces  concurrency,  both  in  the  form of models of concurrent  processes  and  in  the 
form of multi-threaded  programs. 
The  following two chapters  deal  with  some of the  basic  problems  associated 
with  concurrency  and  the  means  for  dealing  with  them.  Chapter 
4 discusses 
shared  objects  and  the  associated  problem of interference if concurrent  activities 
are  allowed  free  access  to  such  objects.  This  leads  to  the  need  for  mutually  exclu- 
sive  access  to  shared  objects.  Further  requirements  for s~chronization and  coor- 
dination  are  introduced  in  Chapter 
S, manifested as guarded  actions  in  the  models 
and  monitors  in  Java. 
Concurrent  programs  must be checked  to  ensure  that  they  satisfy  the  required 
properties.  One of the  general  properties  is  the  absence of deadlock,  where  the 
program  stops  and  makes  no  further  progress.  Deadlock  is  discussed  in  Chapter 
6, 
Properties  are  generally  described  as  either  safety  properties,  concerned  with  a 
program  not  reaching  a  bad  state,  or  liveness  properties,  concerned  with  a  pro- 
gram  eventually  reaching  a  good  state.  These  are  usually  specific  to  the  particula
application  required.  The  modeling  and  checking 
of safety  and  liveness  properties 
for  Java  programs  is  discussed  in  Chapter 7. 

Notes and F ~ r t ~ e r  
~ e ~ d i n g  
9 
Chapter 8 reiterates  the  design  approach  used  implicitly  in  the  previous  chap- 
ters,  that  of  model-based  design  of  programs.  The  cruise  control  system,  discuss
above,  is  used  as  the  example. 
The last  four  chapters of the  book  deal  with  a 
n u b e r  of more  advanced  topics 
of interest.  Chapter  9  deals  with  dynamic  systems  of  processes  and  threads. 
Chapter 10 deals  with  systems  that  interact  using  message  passing.  Chapter 
11 
discusses  various  concurrent  software  architectures,  modeling  and  implementing 
c o m o n  structures  and  patterns 
of interaction.  Finally,  Chapter 
12 discusses 
timed  systems, i n d i c a ~ g  
how  time  can be modeled  and  included  in  implementa- 
tions of conc~rent programs. 
This  chapter  has  introduced  the  area 
of concurrent  programs  and  justified  the 
need  for  a  model-based  approach  to  design  and  construction.  In  particular: 
Finite  state  models  are  used  to  represent  concurrent  behavior.  These  can 
be 
animated  and  analyzed  to  gain  confidence  in  the  correctness  and  validity of a 
proposed  design. 
The  Java p r o g r a ~ n g  
language  is  used  for construc~g 
concurrent  programs. 
Java  is  general-purpose  and  has  concurrency  features. 
Examples  and  exercises  are  used  throughout  the  book  to  illustrate  the  concepts 
and  provide  the o p p o r t ~ t y  
for  experimentation  and  learning by experience. 
A comprehensive  description of the  Therac-25  incident  and  investigation  can be 
obtained  from  the  paper, 
An  ~nvestiga~ion of the ~herac-25 Accidents, by Nancy 
Leveson  and  Clark  Turner  (1993). 
The  automobile  cruise  control  system  is  a  simplified  version of a  real  system. 
The  example  is  fully  discussed in Chapter 8. 
There  are  a  number of existing  books  on  concurrency  and  concurrent  program- 
ming.  For  instance,  Ben-Ari  (1990)  provides  a  simple  introduction  to  the  area 
in  his 
book, Princi~Zes of Concurrent and  Distri~uted  Progr~mming. 
A comprehensive  cov- 
erage  of  the  area,  with  logical  reasoning  and  many  examples,  is  provided 
by Greg 
Andrews (1991) in  his  book, 
Concurr~nt  ~rogramming:  Princi~les  and 
Practice. A 
further  readable  text  in  the  area  is  that 
by Burns  and  Davies  (1993), Concurrent 
Program~ing. For  more  on  the  pragmatics 
of object-orientation  and  concurrent 
programing in Java,  readers  may  consult  the  book 
by Doug  Lea  (1997), 
Concurrent Program~ing in Java:  Design Princi~les  and Patterns. 

This Page Intentionally Left Blank

h Chapter  1,  we  noted  that  in  concurrent  programs,  computational  activities  are 
permitted  to  overlap  in t h e  and  that  the  subprogram  executions  describing  these 
activities  proceed  concurrently.  The  execution of a  program  (or  subprogram)  is 
termed  a  process  and  the  execution 
of a  concurrent  program  thus  consists 
of multi- 
ple  processes.  In  this  chapter,  we  define  how  processes  can be modeled  as  finite 
state  machines.  We  then  describe  how  processes  can be programed as tkrea~s, 
the  form of process  supported by Java. 
A process  is  the  execution of a  sequential  program.  The  state of a  process  at  any 
point  in  time  consists of the  values of explicit  variables,  declared by the  program- 
mer,  and  implicit  variables  such  as  the  program  counter  and  contents 
of data/ 
address  registers. As a  process  executes, it transforms  its  state by executing  state- 
ments.  Each  statement  consists of a  sequence of one  or  more a t o ~ ~ c  
a c t ~ o ~ s  
that 
make  indivisible  state  changes.  Examples 
of atomic  actions  are ~ t e r r u p t i b l e  
machine  instructions  that  load  and  store  registers. 
A more  abstract  model of a 
process,  which  ignores  the  details 
of state  representation  and  machine  instruc- 
tions,  is  simply  to  consider  a  process  as  having  a  state  modified 
by indivisible 
or  atomic  actions.  Each  action  causes  a  transition  from  the  current  state  to  the  nex
state.  The  order in  which  actions  are  allowed  to  occur  is  determined 
by a  transition 
graph  that  is  an  abstract  representation of the  program.  In  other  words,  we  can 
model  processes  as  finite  state  machines. 
Figure  2.1  depicts  the  state  machine  for  a  light  switch  that  has  the  actions 
on 
and o f f  . We use the following 
diagramatic conventions.  The  initial  state  is 
always  numbered 0 and  transitions  are  always  drawn  in  a  clockwise  direction. 
Thus  in  Figure  2.1, on causes  a  transition  from state(0) to state(1) and o f f  causes  a 
transition  from state(1) to state(0). This form of state  machine  description  is  known 
as a  Labeled  Transition  System 
(LTS), since  transitions  are  labeled  with  action 

12 
C ~ ~ t e r  
2: Processes and ~ ~ r e a ~ s
on 
Figure 2.1 Light  switch  state  machine. 
names.  Diagrams of this  form  can be displayed  in  the  LTS  analysis  tool, 
LTSA. 
Although  this  representation  of  a  process  is  finite,  the  behavior  described  need  no
be finite.  For  example,  the  state  machine 
of Figure 2.1 allows  the  following 
sequence of actions: 
on-+off-+on-+off+on+off-+ 
, . 
, 
The graphical  form of state  machine  description  is  excellent  for  simple  processes; 
however, it becomes  unmanageable  (and  unreadable)  for  large  numbers of states 
and  transitions.  Consequently,  we  introduce  a  simple  algebraic  notation  called 
FSP (for  Finite  State  Processes)  to  describe  process  models.  Every  FSP  description 
has  a  corresponding  state  machine 
(LTS) description. In this  chapter, we will 
introduce  the  action  prefix  and  choice  operators  provided  by 
FSP. The  full  lan- 
guage  definition of ESP may be found in Appendix B. 
If x is  an  action  and P a  process  then  the  action  prefix ( x ->P ) describes  a 
process  that  initially  engages in  the  action x and  then  behaves  exactly  as 
described by P. 
The  action  prefix  operator ” 
- 
>” always  has  an  action on its  left  and  a  process  on 
its right. In FSP, identifiers b e g i ~ i n g  
with  a  lowercase  letter  denote  actions  and 
identifiers  beginning  with an  uppercase  letter  denote  processes.  The  following 
example  illustrates  a  process  that  engages  in  the  action once and  then  stops: 
ONES~OT = (once->STOP). 
Figure 2.2 illustrates  the  equivalent LTS state  machine  description  for O N ~ S ~ O T .  
It  shows  that  the  action  prefix  in FSP describes  a  transition  in  the  corresponding 

2.1 ~ o ~ e l i ~ g  
Processes 
13 
once 
Figure 2.2 ONESHOT state machine. 
state  machine  description. STOP is  a  special  predefined  process  that  engages  in 
no  further  actions, as is  clear  in  Figure  2.2.  Process  definitions  are t e r ~ a t e d  
by 
/ I  / I  
.
*
 
Repetitive  behavior is described  in FSP using  recursion. The  following FSP 
process  describes  the  light  switch of Figure  2.1: 
/L 
a 
SWITCH = OFF, 
OFF 
= (on ->ON), 
ON 
= (Off->OFF). 
As  indicated by the ”,” 
separators,  the  process  definitions  for 
ON and OFF are  part 
of and  local  to  the  definition  for 
SWITCH. It should be noted that these local 
process definitions correspond to states in Figure 
2.1. OFF defines sta~e(0) and 
ON defines  state(1).  A  more  succinct  definition 
of SWITCH can be achieved by 
substituting  the de~nition of ON in  the  definition  of OFF: 
 WITCH = OFF, 
OFF 
= (on ->(off->OFF)). 
Finally, by substituting SW1  TCH 
for OFF, since  they  are  defined  to  be  equivalent, 
and  dropping  the  internal  parentheses  we  get: 
S~ITCH 
= (on->off->SWITCH). 
These  three  definitions  for SWITCH generate  identical  state  machines  (Figure  2.1). 
The  reader  can  verdy  this  using  the  LT§  analysis  tool, 
LT”, to  draw  the  state 
machine  that  corresponds  to  each 
FSP definition.  The  definitions  may  also 
be 
animated  using  the  LTSA  Animator  to  produce  a  sequence of actions.  Figure  2.3 
shows  a  screen  shot of the  LTSA  Animator  window.  The  animator  lets  the  user 
control  the  actions  offered by a  model  to  its  environment.  Those  actions  that  can 
be chosen  for  execution  are  ticked. h Figure  2.3,  the  previous  sequence of actions, 
shown  on  the  left,  has  put  the 
SWITCH in  a  state  where  only  the 
on action  can 
occur  next.  We  refer  to  the  sequence 
of actions  produced  by  the  execution of a 
process  (or  set of processes)  as  a trace. 

Figure 2.3  LTSA 
Animator window for SWITCH. 
The  process TRAFF I CL IGHT is  defined  below  with  its  equivalent  state  machine 
representation  depicted in Figure 2.4. 
TRAFFICLIGHT = 
(red->orange->green->orange->TRAF~ICLIGHT). 
In  general,  processes  have  many  possible  execution  traces.  However,  the  only 
possible  trace of the  execution of TRAFF ICL IGHT is: 
r e d ~ o r a n g e ~ g r e e n ~ o r a n g e ~ r e d ~ o r a n g e ~ g r e e n  
. 
TO allow  a  process  to  describe  more  than  a  single  execution  trace, 
we introduce  the 
choice  operator. 
red 
 
orange 
 
green 
orange 
Figure 2.4 TRAFFICLIGHT. 

2.1 ~ o ~ e l i ~ g  
Pro~esses 
15 
If x and y are  actions  then ( x - 
>P I y - 
>Q ) describes  a  process  which  initi- 
ally  engages  in  either 
of the  actions x or y . After  the  first  action  has 
occurred,  the  subsequent  behavior  is  described 
by P if the  first  action 
was x and Q if the  first  action  was y . 
The  following  example  describes  a  drinks  dispensing  machine  which  dispenses 
hot  coffee if the  red  button  is  pressed  and  iced  tea if the  blue  button  is  pressed. 
blue 
tea 
Figure 2.5 DRINKS state  machine. 
Figure 2.5 depicts  the  graphical  state  machine  descri  tion  of  the  drinks  dispenser. 
Choice  is  represented as a  state  with  more  than  one  outgoing  transition.  The  initi
state  has  two  possible  outgoing  transitions  labeled red and b l u  E! Who or  what 
makes  the  choice  as  to  which  action  is  executed?  In  this  example,  the 
enviro~ent 
makes  the  choice - 
someone  presses  a  button.  We  will  see  later  that  a  choice  may 
also be made  internally  within  a  process.  The  reader  may  also  question  at  this 
point if there  is  a dist~ction between  input  and  output  actions.  In  fact,  there  is 
no 
semantic  difference  between  an  input  action  and  an  output  action  in  the  models 
we use.  However,  input  actions  are  usually  distinguished 
by forming  part of a 
choice  offered  to  the  environment  while  outputs  offer  no  choice. In the  example, 

16 
C ~ a ~ ~ e r  
2: Processes 
 
and 
~ ~ r e ~ d
red and blue model  input  actions  and coffee and t e a  model  output  actions. 
Possible  traces of DR I NKS include: 
r e ~ ~ c o f f e e ~ r e d ~ c o f f e e ~ r e ~ ~ ~ o f f e e . "  
.... 
b l u e ~ t e a ~ b l u e ~ t e a ~ b l u e ~ t e a . .  
. 
b l u e ~ t e a ~ r e d ~ c o f f e e ~ b l u e ~ t e a ~ b l u e ~ t e ~ "  
. . . . . 
As before,  the LTSA Animator  can be used  to  animate  the  model  and  produce  a 
trace, as indicated  in  Figure 2.6. In  this  case,  both red and blue actions  are  ticked 
as both  are  offered  for  selection. 
Figure 2.6 LTSA Animator window for ~ R I ~ K S ~  
A state  may  have  more  than two outgoing t r a n s i ~ o ~ ;  
hence  the  choice  opera- 
tor " 
I '' 
can  express  a  choice of more  than two actions.  For  example,  the  following 
process  describes  a  machine  that  has 
four colored buttons only one 
of which 
produces  an  output. 
FAULTY = (red ->FAULTY 
lblue ->FAULTY 
I ~ r e e ~ - > F A U L T Y  
Iyellow->ca~dy->FAULTY 
1. 
The  order of elements  in  the  choice  has  no  si  ificance.  The 
FAULTY process  may 
be  expressed  more  succinctly  using  a set of action  labels. The set  is  interpreted  as 
being  a  choice of one of its  members.  Both  definitions of FAULTY generate  exactly 

2.1 ~ o ~ e l i ~ g  
Processes 
17 
the  same  state  machine  graph as depicted  in  Figure 2.7. Note  that red, blue, and 
ree n label  the  same  transition  back  to s ~ ~ ~ e ( 0 ) .  
FAULTY = ( ~ r e d , b l u e , ~ r e e n ~ - >  
FAULTY 
lyellow -> candy - 3  FAULTY 
)- 
yellow 
candy 
Figure 2.7 FAULTY. 
"he process ( x - 
>P I x ->Q) is  said  to be ~ ~ ~ - ~ e ~ e ~ ~ i ~ i s ~ i c  
since  after  the  action x, it 
may  behave  as  either P or Q. The CO I  N 
process  defined  below  and dram as a state 
machine in Figure 2.8 is  an  example of a  on-determ~s~c process. 
COIN = (toss -> heads -> COIN 
]toss - 3  t a i l s  -> COIN 
) =  
toss 
tails 
Figure 2.8 COIN. 

Figure 2.9 LTSA Animator window for CO1 N. 
After  a  toss  action,  the  next  action  may be either  heads or tails.  Fi 
sample  trace  for  the ~~~ 
N process. 
In  order  to  model  processes  and  actions  that  can  take  multiple  values,  both  local 
processes  and  action  labels  may  be  indexed  in 
FSP. This 
expressive  power of the  notation.  Indices  always  have  a 
that  they  can  take.  This  ensures  that  the  models  we  describe  in 
thus  potentially mecha~cally analy~able. The  process  below is a  buffer  that  can 
contain  a  single  value - 
a  single-slot  buffer.  It  inputs  a  value in  the  ran 
then o u ~ u t s  
that  value. 
The above  process  has  an  exactly 
e~uivalent definition  in  which  the  choice 
between  input  values  is  stated  explicitly,  e  state 
m a c ~ e  
for  both  of  these 
defi~tions is  depicted in  Figure 2.10. Note  that  each  index  is  translated  into  a 
dot  notation ” 
. 
” 
for  the  transition  label,  so  that i n  [ 
0 ] becomes i n  . 
0, and  so  on. 

2.1 ~ u ~ e l i ~ g  
Prucesses 
19 
in.3 
Figure 2.10 BUFF. 
Another  equivalent  definition,  which  uses 
an indexed  local  process,  is 
shown 
below.  Since  this  uses 
two index  variables  with  the  same  range,  we  declare  a 
range type. 
T = O..3 
= ( i n [ i : T ] - > $ T O ~ E [ i ] ) ,  
The  scope of a  process  index  variable  is  the  process  definition.  The  scope of an 
action  label  index  is  the  choice  element  in  which 
it occurs. ~ o n s e ~ u e ~ t l ~ ,  
the two 
definitions of the  index  variable i in UFF above do not conflict.  Both  processes 
and action  labels  may  have  more 
than one  index.  The  next  example  illustrates  this 
for  a  process  which inputs two values a and b and outputs their sum. Note that 
the  usual a r i t ~ e t i c  
operations are supported on index  variables. 
N = l  
T = O..N 
SUM 
= ( i n ~ ~ : T ~ [ b : T ~ - > T O T A L [ a + b ] ) ,  
T ~ T ~ L [ S : ~ ]  
= (Out[S]-> 

20 
C ~ a ~ t e ~  
2: Processes and ~ r e a ~ s  
We  have  chosen  a  small  value  for  the  constant N in  the d e ~ ~ t i o n  
of SUM to  ensure 
that  the  graphic  representation of Figure  2.11  remains  readable.  The  reader  should 
generate  the SUM state  machine  for  larger  values 
of N to  see  the li~tation of 
graphic  representation. 
in.1 .l 
out.2 
Figure 2.11 SUM. 
Processes  may be parameterized so that  they  may  be  described in a  general form 
and  modeled  for  a  particular  parameter  value.  For  instance,  the  single-slot  buffer 
described  in  section  2.1.3  and  illustrated  in  Figure  2.10  can 
be described  as  a 
parameterized  process  for  values  in  the  range 0 to N as  follows: 
BUFF(N=3) = (in[i:O..N]->out[i]->  BUFF). 
Parameters  must be given  a  default  value  and  must  start  with  an  uppercase  letter. 
The  scope of the  parameter  is  the  process  definition. 
~lte~atively, 
N may be given 
a  fixed,  constant  value.  This  may  be  more  appropriate if N is to be used in more 
than  one  process  description. 
N = 3  
= (i~~i:O,.N]->out[i~-> 

2.2 ~ o ~ e ~ i ~ g  
Processes 
21 
It  is  often  useful  to  define  particular  actions  as  conditional, 
dependin 
current  state of the  machine. ~e use  Boolean guards to  indicate  that  a  particular 
action  can  only  be  selected if its guard is  satisfied. 
B x -> P I y -> Q) means  that  when  the guard E3 is true 
and y  are  both  eligible  to  be  chosen,  otherwise if 
false  then  the  action x cannot  be  chosen. 
The  example  below  (with  its  state  machine  depicted  in  Figure 
2.12) is a  process 
that encapsulates  a  count  variable. The  count  can  be  increased  by inc operations 
and decreased  by dec operations. The  count  is  not  allowed  to  exceed N or  be  less 
than  zero. 
COUNT (N=3) = C ~ U ~ T ~ O ~ ,  
COUNT[i:O..N] = 
(icN) 
 
inc->COUNT[i~l] 
(i>O)  dec->COUNT[i-l~ 
inc 
 
inc 
inc 
dec 
 
dec 
 
dec 
Figure 2.12 COUNT, 
FSP supports only  integer  expressions;  consequently,  the  value  zero  is  used  to 
represent  false and any  non-zero  value  represents true. Expression  syntax is the 
same  as G, C++ and Java. 
In  section 2.2, which  describes  how  processes  can  be  implemented  in  Java,  we 
outline  the  implementation of a  countdown  timer. The  timer,  once  started, 
outputs 
a tick sound  each  time  it  decrements  the  count 
and a  beep  when  it  reaches  zero.  At 
any  point,  the  countdown  may  be  aborted  by  a  stop  action.  The  model  for  the 
countdown  timer  is  depicted  below;  the state machine  is  in  Figure  2.13. 
COUN~DO~N 
(N=3) = (start+ COUNTDO~~[N]), 
COUNT~OW~[i:O..N~ 
= 
(i>O) tick-> 
 
COUNTDOWN[i-l] 
(i==O) beep-> STOP 
Istop-> STOP 
)
m
 

2 
C~apter 2: Processes and  reads 
StOD 
start 
Figure 2.13 COUNTDOWN, 
The  set  of  possible  traces of C O ~ ~ T D O ~ ~  
are  as  given  below. 
start+stop 
start+tick+stop 
start+tick+tick+sto~ 
~ t ~ r t ~ t i c k ~ ~ i c k ~ t i ~ k ~ s t o p  
s t a r t ~ t i c k ~ t i c k ~ t i c k + b e e p  
(Note  that  the LTSA Animator  reports  the STOP state  as D ADLOCK. Deadlock  is  a 
more  general  situation  where  a  system 
of processes  can  engage in no  further 
actions.  It  is  discussed  later,  in  Chapter 6.) 
The  alphabet of a  process  is  the  set of actions in which  it  can  engage. 
For  example,  the  alphabet 
of the C O ~ ~ T D O ~ ~  
process  of  the  previous  section  is 
(start,  stop,  tick, beep). A process  may  only  engage in the  actions in its 
alphabet;  however, it may  have  actions in its  alphabet  in  which  it  never  engages. 
For  example,  a  process  that  writes  to  a  store  location  may  potentially  write  any 
32- 
bit  value  to  that  location;  however, it will  usually  write  a  more  restricted  set  of 
values.  In FSP, the  alphabet of a  process  is  determined i~plicitly by the  set of 
actions  referenced in its  definition. We will  see  later  in  the  book  that 
it is  important 
to be precise  about  the  alphabet of a  process. 
How do we deal  with  the  situation  described  above  in  which  the  set of actions 
in the  alphabet  is  larger  than  the  set of actions  referenced  in  its  definition? The 
answer  is  to  use  the  alphabet  extension  construct  provided by FSP. The  process 
defined  below  uses  the  actions writ e [ 
1 1 and writ e [ 
3 1 in its ~efinition 

but  defines  an  alphabet  extension 
”+ { . . 
} 
” of the  actions W 
a  process  is  the 
onse~uently, the  a 
It  should be noted  that  where  a  process  is  defined  using  one  or  more  local  process
definitions,  the a 
et of  each  local  process 
is exactly  the  same as that of the 
alphabet of the  enclosing  process  is  simply  the  on of the 
set of actions  referenced  in  all  local  definitions  together  with  any  explicitly  speci- 
fied  alphabet  extension. 
inning of this  chapter, we  introduced  a  process 
as being  the  execution  of 
or su~program. In  the  previous  section, we  described  how  a  process 
could be modeled  as  a  finite  state  machine.  In  this  section,  we  will  see  how 
processes  are  represented in c o m p u ~ g  
systems.  In  particular, we  describe  how 
processes  are p r o g r a ~ e d  
in Java. 
The  term  process,  mea^ the  execution of a  program,  originates in the  literature 
on  the  design of operating  systems. A process  in  an  operating  system  is  a  unit of 
resource  allocation  both  for  CPU  time  and  for  memory. A process  is  represented 
by its  code,  data  and  the  state of the  machine  registers.  The  data of the  process  is 
divided  into  global  variables  and  local  variables  organized as a  stack.  Generally, 
each  process  in  an  operating  system  has  its  own  address  space  and  some  special 
action  must 
be taken  to  allow  rent  processes  to  access  shared  data.  The 
execution of an  application  pro 
in an  operating  system  like  Unix  involves 
the  following  activities:  allocating  memory  (global  data  and  stack)  for  the  process, 
loading  some  or  all of its  code  into  memory  and r
~
g
 
the  code by loading  the 
address of the  initial ~ s t r u ~ t i o n  
into  the  program  counter  register,  address of its 
stack  into  the  stack  pointer  register  and  so 
on. The  operating  system  maintains  an 
internal  data s~ucture called  a  process  descriptor  which  records  details  such  as 
scheduling  priority,  allocated  memory  and  the  values of machine  registers  when 
the  process  is  not  running, 
The above  description  does  not  conflict  with  our  previous  conception 
of a 
process, it is  simply  more  concrete.  This 
~aditional operating  system  process 

24 
~
~
~
~
t
e
r
 
2: Processes and  reads 
has  a  single  thread of control - 
it has  no  internal  concurrency.  With  the  advent 
of 
shared  memory  multiprocessors,  operating  system  designers  have  catered  for  the 
requirement  that  a  process  might  require  internal  concurrency 
by providing Z~g~t- 
weight processes or t ~ r e a ~ s .  
The  name t ~ ~ e a ~  
comes  from  the  expression  "thread of 
control".  Modern  operating  systems  like  Windows 
KIT permit  an  operating  sys- 
tem  process to have  multiple  threads of control. 
The relationship  between ~ e a ~ ~ w e ~ g k ~  
operating  system (OS) processes  and 
lig~tweight processes  or  threads  is  depicted  in  Figure 
2.14. The OS process  has 
a  data  segment  and  a  code  segment;  however, it has  multiple  stacks,  one  for  each 
thread.  The  code  for  a  thread  is  included  in  the OS process  code  segment  and all 
the  threads  in  a  process  can  access  the  data  segment.  The  Java  virtual  machine, 
which of course  usually  executes 
as a  process  under  some  operating  system, 
supports  multiple  threads  as  depicted  in  Figure  2.14.  Each  Java  thread  has  its 
o m  local  variables  organized as a  stack  and  threads  can  access  shared  variables. 
In the  previous  section, we  modeled  processes as state  machines.  Since  threads 
are  simply  a  particular  implementation 
of the  general  idea of a  process  as  an 
executing  program,  they  too  can 
be modeled as state  machines.  They  have  a 
state,  which  they  transform 
by performing  actions  (executing  instructions). 
To 
avoid  confusion  in  the  rest 
of the  book, we  will  use  the tern p~ocess when  referring 
to  models of concurrent  programs  and  the  term t k ~ e a ~  
when  referring  to  imple- 
menta~ons of processes  in  Java. 
Figure 2.14 Operating  system threads, 
The  operations  to  create  and  initialize  threads  and  to  subsequently  control  their 
execution  are  provided by the  Java  class Thread in  the  package j ava . 
lang. The 
program  code  executed by a  thread  is  provided by the  method run ( ) . The  actual 
code  executed  depends  on  the  implementation  provided  for run ( ) in  a  derived 
class, as depicted  in  the  class  diagram of Figure  2.15. 

2.2 ~ ~ ~ l e ~ e ~ t i n ~  
Processes 
25 
~yThread 
S Thread { 
ic void run () { 
I / .  
3 
3 
Figure 2.15 I ~ p l e m e n ~ g  
run ( ) using  inheritance. 
"he class diagrams we  use in this  book are a  subset of the  Unified  Modeling 
Language, UML  (Booch,  1998;  Fowler,  1997).  For  those  unfamiliar with  this  nota- 
tion,  a  key  may  be found in Appendix D. 
Since Java  does not permit  multiple  inheritance,  it  is  sometimes  more  conveni- 
ent  to  implement  the run ( ) method  in  a  class  not  derived  from 
T h read but from 
the ~terface ~ u n n a ~ l e  
as depicted in Figure  2.16. 
tar et 
i 
t s  Runnable { 
lic v o i d  run() { 
/ I  .... 
Figure 2.16 Implementing run ( ) using  the R U n  n 
a b le interface. 
A  Java T h read object  is  created  by  a  call to new in  the  same  way that any  other 
Java object  is  constructed: "he two ways of creating  a  thread  corresponding  to 
Figures  2.15 and 2.16 respectively  are: 

y  optionally  take  a  str  t  to  name  the  thread. 
follo~ing outlines  the 
~ ~ ~ ~ ~ c s )  
in  which  a  thread  may  exist  a  e  operations  provided 
by the 
lass to control  a  thread. 
read  to  call  its run ( ) method  and  execute it as 
ivity,  concurrent  with  the  thread  which  called st 
when  the r u n  ( ) method  returns  or  when it is S 
not be restarted. A thread  object  is  only 
o references  to  it  and it has t e r m ~ a t e ~ .  
true if a  thread  has  been  started  but  has  not 
~ently 
~~~~~~~ 
on  the  processor,  or  it  may 
be 
d. A r~nning process  may  explicit1 
as  a  result of being  suspended  using s u  
It  can be made ~~~~~~~e 
again  using  res^^ 
( ) causes  a h e a d  to be suspended  (made ~
~
~
-
~
~
for  a  given  time 
(specified in mi~iseconds) and  then  automatically  resume  (be  made ~
~
~
~
This  is  not  a  complete  list of operations  provided by the Thread class.  For  exam- 
ple,  threads  may be given  a sch~duling priority.  We  will ~ t r o ~ u c e  
these  extra 
operations  later in the book, as they  are  required. 
~e can  use FSP to  give  a  concise ~escription of the  thread  life  cycle  as  shown 
below.  The  actions  shown  in ~ ~ ~ Z ~ c s  
are  not  methods  from  class T h read. Taking 
them in order of appearance: ~n~ represents  the  action 
of the run ( ) method 
or  exiting, ~ u n  
represents  a  set of application  actions  from  the r u n  ( ) 
method  and ~~~~~~c~ represents  an  action by the  Java  virtual  machine  to  run  a 
thread  on  the  processor. 

->RUNNABLE 
I stop 
TER~I~ATED = STOP. 
The corresponding state machine  is  depicted in Figure  2.17,  States 0 to 4 corre- 
respectively. 
D, R ~ ~ N I N ~ /  
NON-RUNNA6LE, and ~UNNA 
start 
yield 
stop 
Figure 2.17 "IWAD life  cycle. 
The model  for  a  timer  which  counts 
down to  zero and then beeps was described in 
section  2.1.5  (Figure  2.13). In this  section,  we  describe  the imple~entation of the 
c o ~ t d o w n   t h e r  
as a thread that is  created  by 
a Java applet. The  class diagram for 
the  timer  is  depicted in Figure  2.18. 
Numbe rCanvas is  a  display  canvas that paints an integer  value  on  the  screen. 
An outline of the  class,  describing  the  methods  available  to  users,  is  presented  in 
Program 2.1.  It  is the  first of a  set of display  classes that will  be  used throughout 
the  book.  The  full  code  for  these  classes  may  be 
found on  the CD-ROM that 
accompanies  the  book  or  on  the  website. 

28 
C~apter 
2: Processes and ~ ~ r e a ~ s
I 
““”A 
I 
I 
I 
Figure 2.18 Countdown  timer  class  diagram. 
Program 2.1 NumberCanva~ 
class. 
The  code for the Count Down applet is listed in Program 2.2. 
Program 2.2 Count  Down 
applet  class. 

2.2 ~ ~ p l e ~ e ~ ~ i ~ g  
Processes 
29 
The count e r  thread  is  created  and  started running by the st  art 
( ) method 
when  the Count  Down 
applet  is  started by the  Web browser in  which  it  executes. 
CountDown implements  the Runnable interface by providing  the  method run ( ) 
which  defines  the  behavior of the  thread. To permit  easy  comparison  between  the 
~
O
~
~
T
~
O
~
~
 
model and the behavior implemented 
by the run ( ) method, the 
model  is  repeated  below: 

COUNTDOWN (N=3) = (start-> COUNTDOWN~N~), 
C O U ~ T ~ O ~ N ~ i : O . . N ]  
= 
(i>O) tick-> C O U N T D O ~ ~ [ i - l ~  
(i==O)  beep->  STOP 
/Stop-> STOP 
The  thread counter.  start 
( ) method  causes  the run ( ) method  to  be  invoked. 
Hence,  just  as  the st  art 
action  in  the  model  is  followed 
by C
O
U
~
T
~
~
~
~
[ 
i 1, so the 
run ( ) method  is  an  implementation of the COUNTDO~N 
[ i 
3 process. The  index of 
the  process CQUNTDQWN [ i] 
is  represented by the  integer  field i . 
The  recursion in 
the  model  is  implemented  as  a  Java 
while loop.  Guarded  choice  in 
COUNTDOWN [ i 3 
is  implemented  by  Java if statements.  Note  that we  have  reordered  the  conditions 
from  the  model,  since  in  the  implementation,  they  are  evaluated  sequentially. 
If 
the  thread  is  stopped,  it  must  not  perform  any  further  actions.  In  Chapters 
4 and S, 
we will  see  a  different  way of implementing  choice  when a model  process is not 
implemented  as  a  thread. 
When run ( ) returns  the  thread  terminates - 
this  corresponds  to  the  model 
process STOP. This  can  happen  for  two  reasons:  either i==O or  the  thread  refer- 
ence CO U n t e r becomes  null.  It  can  become  null 
if the  browser  invokes  the 
stop ( ) 
method - 
usually  as  a  result  of  a  user  requesting  a  change  from  the  Web  page  in 
which  the  applet  is  active.  The stop ( ) method  sets count er to  null.  This  method 
of stopping  a  thread  is  preferable  to  using  the Thread . 
stop ( ) method  since it 
allows  a  thread  to  terminate  gracefully,  performing  cleanup  actions if necessary. 
Th read . 
stop ( ) terminates  a  thread  whatever  state  it  is  in,  giving it no  oppor- 
tunity  to  release  resources. ~elodramatically, we  may  think of T h read . 
stop ( ) 
as  killing  the  thread  and  the  technique  we  have  used  as  equivalent  to  requesting 
the  thread  to  commit  suicide!  For  these  reasons,  Sun  have  suggested  that 
Thread.  stop 
( ) be "deprecated".  This  means  that 
it may  not be supported by 
future  Java  releases. 
The  implementation  of tick ( ) displays  the  value  of i, plays  the  tick  sound 
and  then  delays  the  calling  thread  for 
1000 milliseconds  (one  second)  using 
T h re ad . 
S 1 
e  e  p 
( ) . This  is  a  class  method  since  it  always  operates  on  the  currentl
thread.  The  method 
sleep ( ) can t e r ~ a t e  abnormally  with  an 
~nterrupted~xception. 
The  code  of  Program 2.2 simply  provides  an  exception 
handler  that  does  nothing. 
The  implementation  of 
be e  p 
( ) displays i and  plays  the  beep  sound.  The 
tick ( ) and beep ( ) methods  correspond  to  the tick and beep actions of the 
model. An implementation  must  fill  in  the  details  that  are  abstracted  in  a  model. 

This  chapter  has  introduced  concept 
of a  process,  explaine 
processes  and  described  Jav  reads  as  implementations 
of p 
cular: 
The  execution  of  a  pro  ram)  is  termed  a 
~ r ~ c e s s .  
Processes  are 
the  units of concurre 
A process  can be modeled  as  a  state  ma 
or indivisi~le actions  executed by the 
Systems,  to  represent  state  machines. 
State  machines  are  described 
chapter introdu~ed the  action 
tion  to  the  use  of  recursion, 
Our notations  do  not distin~uish input  actions from outputs.  However,  inputs 
usually  form  part of a  choice  offered  to  the  environment  of  a  process  while 
The  use  of  state  machines  as  an 
a ~ s t r a ~ t  
model  for  processes  is  widely  used  in  the 
study of concurrent 
 
le, 
 
in 
 
er 
~ i s ~ r i ~ ~ ~ e ~  
A Z g ~ r ~ ~ ~ ~ s ,  
to 
 
describe 
 
and 
reason 
 
about 
concur~ent and 
 
dis 
 
automata 
 
are 
 
state 
machines  in  which  input, 
o u ~ u t  
which  input  actions  are  always 
environment  in  all  states).  The  inte 
reactive  systems. A 

32 
C ~ ~ p t e r  
2: P~~cesses 
and  reads 
C o ~ ~ u n i c a t i o n  
and Conc~rrenc~. 
M i l e  we  have  adopted  the 
CCS approach  to 
semantics,  the  syntax  of 
FSP owes  more  to 
C.A.R. Hoare’s CSP presented  in 
C o ~ ~ u n i ~ a t i n g  
Se~uential Processes (1985). The  semantic  differences  between FSP 
and  its  antecedents, CCS and CSP, are  documented  and  explained  in  succeeding 
chapters.  The  syntactic  differences  are  largely  due  to 
the  requirement  that FSP be 
easily  parsed by its  support  tool LTSA. 
Process  algebra  has  also  been  used  in  formal  description 
l a n ~ a g e s  such as 
LOTOS (ISO/IEC, 1988).  LOTOS  is  an IS0 standard  language  for  the  specification 
of distributed  systems  as  interacting  processes. 
As in FSP, process  behavior  is 
described  using  action  prefix  and  choice  operators,  guards  and  recursion. 
However,  unlike FSP, LOTOS  includes  facilities  for  defining  abstract  data  types. 
Naive  use of the  data  type  part of LOTOS  quickly  leads  to  intractable  models. 
FSP was  specifically  designed  to  facilitate  modeling of finite  state  processes  as 
Labeled  Transition  Systems,  LTS  provides  the 
well-de~ne~  ma~ematical 
proper- 
ties  that  facilitate  formal  analysis. LTSA provides  automated  support  for  display- 
ing  and a~mating 
the  examples  in  this  chapter.  Later  in  the  book  we  will  see  how 
LTSA can be used  for  verifying  properties  using  model  checking. 
The  reader  interested  in  more  details 
on Java  should  consult  the  orm mat ion 
on-line  from  JavaSoft. For more  on  the  pragmatics of concurrent p r o g r a ~ n g  
in 
Java,  see  Doug  Lea’s  book ~ o ~ c ~ r r e n t   P r o g r a ~ ~ i n g  
in  Java:  Design Princi~les and 
Pat~e~ns 
(Lea,  1997). 
2.1 For  each  of  the  following  processes,  give  the  Finite  State  Process  (FSP)  description  of 
the  Labeled  Transition  System 
(LTS) graph.  The  FSP  process  descriptions  may  be 
checked by generating  the  corresponding  state  machines 
using the  analysis  tool, LTSA. 
I. MIiETING 
hello 
converse 
~ o o ~ ~ y e  
11. JOB 
arrive 
 
work 
leave 

Ex~cises 
33 
111. GAME 
two 
one 
win 
IV. MOVE 
V. DOUBLE 
ahead 
 
left 
right 
in.3 
out.6 

34 
  apte er 2: Processe~ and T ~ r e u ~ s  
VI. F ~ U ~ ~ C K  
tick 
tick 
tick 
tick 
WI.  ER^^^ 
weekend 
2.2 
2.3 
2.4 
2.5 
shop 
Play 
A variable  stores  values  in  the  range 
O..N and  supports  the  actions 
read and w r ~ ~ e .
Model  the  variable as a process, VAR 
For  N=2,  check  that it can  perform 
wriite.:!+read. 
~ r e ~ ~ . ~ ~ w r i t e . l   ~ w r i t e . ~ ~ r e a d
A bistable  digital  circuit  rec 
* 
nce of ~ r ~ g g e r  
inputs  and  alternately  outputs 
0 
and 1. Model  the  process  using 
FSP, and  check  that 
it produces  the 
required  output;  i.e., 
it sho  e  actions  given 
by the  trace: 
t r i g g e r  +l +trigge 
(Hint:  The  alphabet  of 
A sensor  measures  the  water  level 
of a tank.  The  level (initially 5) is measured in units 
0..9. The  sensor  outputs a low signal if the  level is less  than  2  and a 
~~~~ 
signal if the 
level is greater  than 8 otherwise it outputs ~ o ~ ~ a Z .  
Model  the  sensor  as  an FSP process, 
NSOR. 
(Hint:  The  alphabet  of 
SEN OR is  level[^. . 1, ~ i g ~ ,  
low, nor~al3.) 
A drinks  dispensing  machine  charges  15p  for  a  can of Sugarola.  The m a c h e  accepts 
ons 5p, lop and  20p  and  gives  change.  Model  the  machine 
as an 

Exercises 
35 
2.6  A  miniature  portable  FM  radio  has  three  controls. 
An on/off  switch  turns  the  device  on 
and off. Tuning is controlled by two buttons scan and re 
S e t which  operate  as 
follows.  When  the  radio is turned  on  or reset is pressed,  the  radio is tuned to the 
top  frequency of the  FM  band 
(108MHz). When Sc n is pressed,  the  radio  scans 
towards  the  bottom  of  the  band 
(8~MHz). It stops  sc  g  when 
it locks on to  a 
station  or it reaches  the  bottom (end). If the  radio is currently  tuned to a  station  and 
scan is pressed  then it starts  to  scan  from  the  frequency  of  that  station  towards  the 
bottom,  Similarly,  when 
reset is pressed  the  ceiver  tunes  to  the  top.  Using  the 
alphabet (on, o f f ,  scan,  reset, lock, 
d }, model  the  FM  radio  as  an 
FSP 
process, RAD IO. 
For  each  of  the  exercises 2.2 to 2.6, draw tlne state  machine  diagram  that  corresponds 
to  your FSP specification  and  check  that it can  perform  the  required  actions.  The  state 
machines  may be drawn  manually  or  generated  using  the  analysis  tool, LTSA. LTSA 
may  also be used  to  animate  (run)  the  specification  to  produce  a  trace. 
2.7  Program  the  radio  of  exercise 2.6 in  Java,  complete  with  graphic  display. 

This Page Intentionally Left Blank

The  execution of a  concurrent  program  consists of multiple  processes  active at the 
same  time. As discussed  in  the  last  chapter,  each  process  is  the  execution 
of a 
sequential  program. A process  progresses by submitting  a  sequence of ins~uctions 
to  a  processor  for  execution. If the  computer  has  multiple  processors  then  instruc- 
tions  from  a  number of processes,  equal  to  the  number 
of physical  processors,  can 
be  executed  at  the  same  time.  This  is  sometimes  referred  to 
as parallel  or rea2 
concurrent  execution.  However, it is  usual  to  have  more  active  processes  than 
processors.  In  this  case,  the  available  processors  are  switched  between  processes. 
Figure  3.1  depicts  this  switching  for  the  case 
of a  single  processor  supporting  three 
processes, A, 
13 and C. The  solid  lines  represent  instructions  from  a  process  being 
executed  on  the  processor.  With  a  single  processor,  each  process  makes  progress 
but, as depicted  in  Figure  3.1, instruc~ons from  only  one  process  at  a  time  can be 
executed. 
"-"" 
"
"
"
"
"
 
> 
> 
""".." 
"-3 
"
"
"
_
 
.F 
Time 
Figure 3.1 Process switching. 
The  switching  between  processes  occurs  voluntarily  or in response  to  interrupts. 
Interrupts  signal  external  events such as the  completion of an 1 / 0  operation  or  a 
clock  tick  to  the  processor. 
As can be seen  from  Figure  3.1,  processor  switching  does
not  affect  the  order of instructions  executed  by  each  process.  The  processor  exe- 
cutes  a  sequence of instructions  which  is  an 
i ~ t e r ~ e ~ ~ i ~ g  
of the instructio~ sequences 

from  each individual process.  This  form 
of concurrent  execution  using  interleaving 
is  sometimes  referred  to as pseudo-concurrent  execution  since instructio~ from 
different  processes  are not executed at the  same  time but are interleaved. We use 
the  terms ~a~aZZe~ 
and c
~
~
c
~
~
r
e
~
~
 
interchangeably and usually do not  distinguish 
between  real and pseudo-concurrent  execution  since, in general,  the  same  pro- 
ramming  principles and techniques  are  applicable  to both physically  (real)  con- 
current and interleaved  execution. In fact,  we  always  model  concurrent  execution 
as interleaved  whether  or not implementations run on  multiple  processors. 
This  chapter  describes  how  programs  consisting 
of multiple  processes are model- 
ed and illustrates  the  correspondence  between  models 
and implementations of con- 
current  programs  by  a  multi-threaded  Java  example. 
In  the  previous  chapter,  we  modeled  a  process  abstractly 
as a state machine that 
proceeds  by  executing  atomic  actions,  which  transform  its 
state. The  execution of a 
process  generates  a  sequence  (trace) of atomic  actions. We now  examine  how  to 
model  systems  consisting of multiple  processes. 
The  first  issue  to  consider  is  how  to  model 
the speed at which  one  process 
executes  relative  to 
another. The  relative  speed 
at which  a  process  proceeds 
depends on factors  such as the  number of processors and the  scheduling strat- 
egy - 
how  the  operating  system  chooses  the  next  process  to  execute.  In  fact,  si
we want to  design  concurrent  programs  which  work  correctly  independently of 
the  number of processors and the  scheduling  strategy,  we  choose not to  model 
relative  speed but state simply that processes  execute at arbitrary relative speeds. 
This  means that a  process  can  take an arbitrarily  long  time  to  proceed  from  one 
action  to  the  next. We abstract away from  execution  time.  This has the disadvan- 
tage that we  can  say  nothing about the  real  time  properties of programs but has 
the advantage that  we  can  verify  other  properties  independently of the  particular 
configuration of the  computer and its operating  system.  This  independence  is 
clearly important for  the  portability of concurrent  programs. 
The  next  issue  is  how  to  model  concurrency  or  parallelism.  Is  it  necessary  to 
model  the situation in  which  actions  from  different  processes  can 
be executed 
simultaneously by different  processors  in addition to  the  situation in which  con- 
currency is  simulate^ by  interleaved  execution? We choose  always to model  con- 
currency  using  interleaving. h 
action a is  concurrent with another  action b if a 
model  permits  the  actions  to  occur  in  either  the 
order a+b or  the  order b+a. Since 
we do not  represent  time in the  model,  the  fact that the  event a actually  occurs at 
the  same  time as event b does not affect  the  properties  we  can  assert about con- 
current  executions. 

decided  on an interleaved  model of concurrent  execution,  what 
t  the  relative order of actions  from  different  processes in the 
interleaved  action  trace  representing  the  concurrent  program  execution? 
We 
know that the  actions  from  the  same  process 
are executed in order. However, 
since  processes  proceed at arbitrary relative  speeds,  actions  from  different pro- 
cesses are arbitrarily interleaved. Arbitrary  interleaving turns out to be  a  good 
model of concurrent  execution  since  it  abstracts  the  way  processors  switch 
between  processes as a  result of external interrupts. The t h i n  
relative  to  process  execution  cannot in general  be  predetermine^ since  actions  in 
the  real  world  cannot  be  predicted  exactly - 
we  cannot  foretell the future. 
The  concurrent  execution  model in which  processes  perform  actions in an arbi- 
trary order at arbitrary relative speeds is  referred to as an ~
s
y
~
c
~
~
model of 
execution.  It  contrasts with the s
~
~
c
~
~
~
~
~
~
model  in  which  processes  perform 
actions in shultaneous execution  steps,  sometimes  referred  to as lock-step. 
are processes then ( P 1 I Q) represents the  concurrent  execution 
of P and Q. 'The operator I 1 is  the  parallel  composition operator. 
Parallel  composition  yields  a  process,  which  is  represented as a state machine  in 
the same  way as any  other  process.  The state machine  representing the composi- 
tion  generates  all  possible  interleavings of the traces of its  constituent  processes. 
For  example,  the  process: 
ITCH = ( ~ c r a t c h - > ~ T O ~ ) .  
has a  single  trace  consisting of the  action s c rat c h. The  process: 
= (think->talk->~TO~). 
has the  single  trace t h in k-+ t a1 k. The  composite  process: 
CH = (ITCH I I CONV 
has the  following  traces: 

The state  machines  corresponding  to ITCH, CO~VERSE 
and CO~VERS 
depicted  in  Figure  3.2.  The  state  machine  representing  the  compositi 
tesian  product of its consti~ents. For  example, if ITCH is h 
st~te(~) 
and 
is h s t ~ t e ~ ) ,  
then  this  combined  state  is  represented 
by 
CO~VERSE-~TCH 
in st~te(<~,~>). 
So if CONV  RSE 
has  performed  the think action 
and  is  in state(1) and ITCH performs  its scratch action  and is in state(1) then  the 
state  representing  this  in  the  composition  is 
state(<l,l>). This  is  depicted as state@) 
of  the  composition.  We  do  not  manually  compute  the  composite  state  machines  in
the  rest of the  book,  since  this  would be tedious  and  error-prone.  omp positions 
are  computed by the LTSA tool  and  the  interested  reader  may  use 
it to  verlfy  that 
the co~positions depicted  in  the  text  are  in  fact  correct. 
From  Figure  3.2,  it  can  be  seen  that  the  action 
scratch is  concurrent  with  both 
think and t a1 k as the  model  permits  these  actions  to  occur  in  any  order  while 
r e t a ~ ~  
the  constraint  that t 
h ink must  happen  before t a 1 
k . In  other  words,  one 
must  think  before  talking  but  one  can  scratch at any  point! 
Composite  process  definitions  are  always  preceded by I I to distinguis~ them 
from p r i ~ t i v ~  
process de~itions. 
As  described in the  previous  chapter,  primitive 
scratch 
think 
 
talk 
scratch 
talk 
 
think 
Figure 3.2 Composition CONVE~SE-ITCH. 

processes  are  defined  using  action  prefix  and  choice  while  composite  processes 
defined  using  only  parallel  composition.  Maintaining  this  strict  distinction 
between p r i ~ t i v e  
and  composite  processes  is  required  to  ensure  that  the  models 
described by FSP are  finite. 
As a further  example,  the  followin  processes  model 
a clock  radio  which 
incorporates  two  independent  activities: 
a clock  which  ticks  and 
a radio  which 
can  be  switched  on  and  off.  The  state  machine  for  the  composition  is  depicted  in 
on 
ick 
ick 
Off 
Figure 3.3 Composition CLOCK-~AD~O. 
CLOCK = (tick->CLOCK). 
IO = (on->off->~~~I 
R ~ R I O  
= (CLOCK 1 1  
Examples of traces  generated by the  state  machine of Figure 3.3 are  given  below. 
The LTSA animator  can be used  to  generate  such  traces. 
The parallel  composition  operator  obeys  some  simple  algebraic  laws: 
ether  these  mean  that  the  brackets  can be dispensed  with  and  the  order 
that  processes  appear  in  the  composition  is  irrelevant. 
The  examples  in  the  previous  section  are  all  compositions of processes  with  dis- 
joint  alphabets.  That  is,  the  processes 
in a composition  do  not  have  any  actions  in 

common. If processes  in  a  composition  do  have  actions  in 
CO 
on,  these  actions 
are  said  to be  share^. h ha red actions  are  the  way  that  process  interaction is mod- 
eled.  While mshared actions  may be arbitrarily  interleaved, a  share^ action  must  be 
e ~ e c ~ t e ~  
at the  s#me t i ~ e  
by  all  the  processes  that ~artici~ate 
in that sh#re~ 
action. The 
following  example  is  a  composition of processes  that  share  the  action me 
l a y  -> meet -> 
ork -> meet -> 
ossible  execution  traces of the c o ~ p o s i t i o ~  
are: 
hared  actions, play and wo r 
k , 
are  concurrent  and  thus  may be executed 
rder.  However,  both  of  these  actions  are  constrained 
to happen  before  the 
eet . The  shared  action synchronizes the  execution of the  processes 
The  state  machine  for  the  composite  process  is  depicted 
in Figure 
3.4. 
work 
Figure 3.4 Composition BILL-BEN . 
The  next  example  consists of a  process  that manufac~res an  item  and  then si 
that  the  item  is  ready  for  use by a  shared ready action. A user  can  only  use  the 
item  after  the ready action  occurs. 
R = (make->ready->~ 
= (ready->use->US 
R-USER = (MAKE 

make 
 
ready 
 
make 
use 
use 
Figure 3.5 Composition MAKER-USER. 
From  Figure 3.5, it  can be seen  that  the  following  are  possible  execution  traces: 
After  the  initial  item  is  manufactured  and  becomes ready, manufacture  and  use 
can  proceed  in  parallel  since  the  actions 
make and us e can  occur in any  order. 
However,  it  is  always  the  case  that  an  item  is  made  before  it  is  used  since  the  first 
action  is make in all  traces.  The  second  trace  shows  that  two  items  can be made 
before  the  first  is  used.  Suppose  that  this  is  undesirable  behavior  and we do  not 
wish  the ~AKER process  to  get  ahead  in  this  way. The solution  is to modify  the 
model so that  the  user  indicates  that  the  item  is  used.  This used action  is  shared 
with  the ~ A K E ~  
who  now  cannot  proceed  to  manufacture  another  item  until  the 
first  is  used.  This  second  version  is  shown  below  and  in  Figure 3.6. 
~ A K E R v ~  
= (ma~e->ready->used->~AK 
= (re~dy->use->u~ed->~SER 
make 
 
ready 
 
use 
used 
Figure 3.6 Composition MAKE~-USERv~. 
‘The interaction  between ~AKER 
and USER in this  second  version  is  an  example 
of a 
k ~ ~ ~ s k ~ ~ e ,  
an action which is  acknowledged by another. As we  see in the  chapters 
to  follow,  handshake  protocols  are  widely  used  to  structure  interactions  between 
processes.  Note  that  our  model  of  interaction  does  not  distinguish  which  process 
instigates  a  shared  action  even  though it is  natural  to  think of the MAK 

instigating  the ready action  and  the USER process instiga~g the used action. 
However, as noted  previously,  an  output  action  insti  ated  by  a  process  does  not 
usually  form  part of a  choice  while  an  input  action  may. 
The  examples of s ~ c h r o ~ ~ a t i o n  
so far  are  between two processes;  however, 
many  processes  can  engage 
in a  shared  action.  The  next  example 
illus~ates the  use 
of multi- par^ s~chroni~ation 
in  a  small m a n u f a c t u ~ ~  
system  which  produces 
two different  parts  and  assembles  the  parts  into  a  product.  Assembly  cannot  take 
place  until  both  parts  are  ready.  Again,  makers  are  not  permitted  to  get  ahead 
of 
users. The state  machine  is  depicted  in  Figure 3.7. 
~AKE-A = (makeA->ready->used->~~KE-A). 
MAKE-B 
= (makeB->ready->used->MAKE- 
ASSEMBL€ = (rea~y->assem~le->u§~~->ASSE~BLE). 
I /FACTORY = (MAKE-~ I I MAK 
makeA 
used 
Figure 3.7 Composition FACTORY. 
Since  a  parallel  composition 
of processes  is  itself  a  process,  called  a  composite 
process, it can be used  in  the d e ~ t i o n  
of ~ r t h e r  
com~ositions. We  can  restruc- 
ture  the  previous  example 
by creatirig a  composite  process  from 
~AKE-A and 
~AKE-A = (makeA->ready->~sed->~AKE-A). 
MAKE-B = (~akeB->rea~y->used->MAKE- 

45 
The  rest of the  factory  description  now  becomes: 
I IFACTORY = ( ~ A ~ E R ~  
1 1  A S S E ~ ~ L E ) .  
"he state  machine  remains  that  depicted  in  Figure 3.7. ~ubstituting the  definition 
RS in FACTORY and applying  the comutative and associative  laws  for 
parallel  composition  stated  in  the  last  section  results  in  the  original  definition  for 
FACTORY in  terms of primitive  processes.  The 
LTSA tool  can  also  be  used  to 
confirm  that  the  same  state  machine  results  from  the two descriptions. 
Given  the  definition of a  process, we often want to  use  more than one  copy of that 
process  in  a  program  or  system  model. 
For  example,  given  the  definition  for  a 
switch: 
SWITCH = (on->Qff->S~ITCH). 
we may  wish  to  describe  a  system 
that is  the  composition of two distinct  switches. 
However, if we  describe  this  system as (SWITCH 
1 I S~ITCH 
), the  composition  is 
indistinguishable  from  a  single  switch  since  the 
two switch  processes  synchronize 
on their  shared  actions on and off . We must  ensure  that  the  actions 
of each 
S~ITCH 
process  are  not  shared,  i.e.  they  must  have  disjoint  labels. 
To do this 
we  use  the  process  labeling  construct. 
a : 
P prefixes  each  action  label  in  the  alphabet of P with the  label "a". 
A system  with two switches  can  now  be  defined as: 
I ITWO-SWITCH = (a:S~ITCH I 1 b:S~ITCH). 
"he state  machine  representation  for  the  processes a : 
SWITCH and b : 
SWITCH is 
given  in  Figure 3.8. It  is  clear that the  alphabets of the two processes  are  disjoint, 
i.e. (a.on, a.off} and {b.on,  b.off}. 
Using  a  parameterized  composite  process, 
SWITCHES, we  can  describe an array 
of switches  in FSP as follows: 
1 /SWITCHES(N=3) 
=( 
[i:I..N] s ~ i ~ : S ~ I T C H ) .  

.on 
b.on 
a.off 
b.off 
a.on 
&Off 
Figure 3.8 Process labeling in T ~ O - ~ ~ I T C ~ .  
h 
e ~ ~ v a l e n t  
but  shorter defin~tion is: 
(N=3) = ( s [ i : l  
e .NI: 
rocesses  may  also  be  labeled by a  set of prefix  labels.  The  general  form of this 
pre~ixi~g 
is  as  follows: 
. , 
a,) : : 
P replaces  every  action  label n in  the al~habet of 
S al. n, . 
. 
,a,. n. Further,  every  transition (n->Q) in  the 
is  replaced  with  the  transitions ( { 
al . 
n , 
. . . , 
a, I n 3 - > 
e  explain  the  use 
of this  facility in the  following  example.  The  control 
of a 
resource  is  modeled  by  the  following  process: 
and  users of the  resource  are  modeled by the  process: 

~e  wish  to  model  a  system  consis 
that  only  one  user  at  a t b  ay be using  it  (called ’ 
users  may be modeled  us 
recess labeling as a : 
U 
that  there  are 
two distinct  actions (a. acquire an 
actions  to 
free it (a 
st be labeled  with  the 
S 
tions.  The composi~on is  described  below. 
The state  machine  representations of the  processes in the 
are  depicted 
in Figure 3.9. The  e 
of process  labeling 
clearly  seen.  The  composite  proce  ph  shows  that  the  desired  result 
of allow- 
ing only  one  user  to  use  the  resource  at  a  time  has  been  achieved. 
a-acauire 
a.use 
 
b.acquire 
b.use 
a.release 
b.reie~se 
b.acquire 
a.acquir~ 
asrelease 
bxelease 
asacquire 
axelease 
Figure 3.9 Process labeling in RESOURCE-SHARE. 

A perceptive  reader  might  notice  that  our  model of the 
permit  one  user to acquire  the  resource  and  the  other to release  it!  For  example, it 
would  permit  the  following  trace: 
a.acquire  +&.release 
+... 
However,  each of the  USER  processes  cannot 
r e 1  
e the  resource  until it has 
succeeded in perfor~ing an acquire action.  Hence, when  the RE 
posed  with  the USER processes,  this  composition  ensures  that  only  the  same  user 
that  acquired  the  resource can  release  it.  This  is  shown in the  composite  process 
R ~ ~ O ~ R C E - S H ~ ~ E  
in Figure  3.9. 
This can  also be confirmed using the LTSA 
 mato or to run  through  the  possible  traces. 
Relabeling  functions  are  applied  to  processes  to  change  the  names 
of 
action  labels. The general form of the re label in^ function  is: 
/ (newlabel__l/olddabel__l, 
... ~ewlabel-n/ol~~abe~-n}. 
Relabeling  is  usually  done to ensure  that  composite  processes s ~ c h r o ~ z e  
on  the 
desired  actions. A relabeling  function  can be applied  to  both p r ~ ~ t i ~ e  
and  com- 
posite  processes.  However,  it  is  generally  used  more  often in com~osition. 
A server  process  that  provides  some  service  and a client  process  that  invokes 
the  service  are  described  below: 
C L ~ E N T  = (call->wait->conlinue->CLI 
RvER = ( ~ e q u e ~ t - > s e r v i c ~ - > r e ~ l y - >  
As described, 
 
the 
CL I 
oint al~habets and 
 
do 
 
not 
 
interact 
in  any  way.  Howeve 
HT with  the requ 
actions. T'he composition  is  defined  below. 
The  effect  of apply in^ the  relab 
~ c t i o n  
can be seen in the  state m a c ~ e  
tions of Figure  3.10. 
el call replaces r e  
in the  description 
and reply replace 
in the  description 
o 
NT . 

continue 
call 
 
service 
continue 
Figure 3.10 Relabeling  in ~LIE~T-SERVER. 
An alternative  formulation of the  client-server  system  is  described  below  using 
qualified  or  prefixed  labels. 
SER~ERv2 
= (accept.request 
CLIENTv2 = (call.request 
->service->accept.reply->SERVERv2). 
-~call.reply-~continue-~CLIENTv2). 
I ICLIENT-SERVERv2 = (CLIENTv2 I I SERVERv2) 
/{call/accept}. 
The  relabeling  function / { 
call / accept } replaces  any  label  prefixed by accept 
with  the  same  label  prefixed 
by call. Thus accept. request becomes call. 
request and accept. reply becomes call. reply in  the  composite  process 
CLIE~T-~ERVERV~. 
This  relabeling by prefix  is  useful  when  a  process  has  more 
than  one  interface.  Each  interface  consists 
of a  set of actions  and  can be related by 
having  a  common  prefix. If required  for  composition,  interfaces  can  be  relabeled 
using this prefix as in  the  client-server  example. 

When  applied  to  a  process P, the  hiding  operator \ { 
al . . 
a,} 
removes  the 
action  names al . . 
a, from  the  alphabet of P and  makes  these  concealed 
actions "silent".  These  silent  actions  are  labeled 
tau. Silent  actions  in 
different  processes  are  not  shared. 
The  hidden  actions  become  unobservable  in  that  they  cannot 
be shared  with 
another  process  and so cannot  affect  the  execution  of  another  process.  Hiding  is 
essential  in  reducing  the  complexity of large  systems  for  analysis  purposes  since, 
as we  see  later,  it  is  possible  to ~
~
~
~
~
~
z
the  size of state  machines  to  remove tau 
actions.  Hiding  can be applied  to  both  primitive  and  composite  processes  but  is 
generally  used  in  defining  composite  processes.  Sometimes it is  more  convenient 
to  state  the  set of action  labels which  are  visible  and  hide  all  other  labels. 
en applied to a  process P, the  interface  operator @{ al . . 
a,} 
hides all 
ons  in  the  alphabet of P not  labeled in  the  set al . 
a,. 
The  following  definitions  lead to the  state  machine  depicted in  Figure  3.11: 
R = (acquire->use->release->USE 
\{use}. 
USER = (acquire->use->release->U~ER) 
@{acquire,release~. 
acquire 
 
tau 
release 
Figure 3.11 Hiding applied to USER. 
~ i m i ~ a t i o n  
of USER removes  the  hidden tau action  to  produce  a  state  machine 
with  equivalent  observable  behavior,  but  fewer  states  and  transitions  (Figure 
3.12). LTSA can  be  used  to  confirm  this. 

3.1 M o ~ e l i n ~  
C o n c ~ r r e ~ ~  
51 
acquire 
release 
Figure 3.12 Minimized LTS for USER. 
We  have  used  state  machine  diagrams  to  depict  the  dynamic  behavior  of  pro- 
cesses.  State  machine  diagrams  represent  the  dynamic  process  operators,  action 
prefix  and  choice.  However,  these  diagrams  do  not  capture  the  static  structure 
of a 
model.  While  the  result  of  applying  parallel  composition 
can be described as a 
state  machine  (since  it  is  a  process),  the  parallel  composition  expression  itself  is  n
represented.  Parallel  composition,  relabeling  and  hiding  are  static  operators  that 
describe  the  structure of a  model  in  terms  of p r i ~ t i v e  
processes  and  their  inter- 
actions.  Composition  expressions  can 
be represented  graphically  as  shown  in 
Figure 3.13. 
Process p with 
alphabet (a, b} . 
Figure 3.13 Structure diagram conventions. 
A process  is  represented  as  a box with  visible  actions shown as  circles  on  the 
perimeter. A shared  action  is  depicted  as  a  line  connecting 
two action  circles,  with 
relabeling if necessary. A line  joining  two  actions  with  the  same  name  indicates 

52 
C ~ a ~ t e r  
3: Co~curre~t 
Execution 
only  a shared action  since  relabeling  is  not  required. A composite  process  is  the 
box  enclosing  a  set 
of process  boxes.  The alphabet of the  composite  is  again 
indicated  by  action  circles  on  the  perimeter.  Lines  joining  these  circles  to  internal 
action  circles  show  how  the  composite’s  actions 
are defined  by  primitive  pro- 
cesses.  These  lines  may  also  indicate  relabeling  functions if the  composite  name 
for an action  differs  from  the  internal name. Those  actions that appear internally, 
but are not joined  to  a  composite  action  circle,  are 
hidden. This  is  the  case  for 
action a inside S in Figure  3.13.  The  processes  inside  a  composite  may, of course, 
themselves  be  composite and have structure diagram  descriptions. 
We sometimes  use  a  line  in  a structure diagram to  represent  a  set of shared 
actions that have  a c o m o n  prefix  label.  The  line  is  labeled  with  the  prefix  rather 
than explicitly  by  the  actions.  The  example 
in Figure 3.14 uses  the  single-slot 
buffer of section  2.1.3  to  construct  a  buffer 
that can  store two values. A definition 
of the  single-slot  buffer  is  given  below. 
P 
T = 0..3 
BUFF = (in[i:T~->out[i]-~BUFF), 
Each of the  labels in the diagram of Figure  3.14 - 
in, out and a  out 
- 
represents 
the  set of labels in [ i 
:T] , 
out [ i 
: 
T] and a. out [ i 
: 
TI , 
respectively. 
I ITMOBUF = (a:BUFFI  1b:BUFF) 
/{in/a.in, 
a.out/b.in, 
out/~.out3 
@{in,out}. 
Figure 3.14 Two-slot buffer T~OBUF. 
Sometimes  we o
~
t
 
the  label  on  a  connection  line  where  it  does 
not matter  how 
relabeling  is done since  the  label  does not appear in  the  alphabet  (interface) 
of the 
composite.  For  example, in Figure 3.14, it would not  matter if we  omitted  the  label 
a.out and used b.in/a.out instead of a.out/b.in as shown. We also  omit 
labels  where  all  the  labels  are  the  same,  i.e.  no  relabeling  function  is  required. 

RESOURCE = (acquire->release->RESOUR~E). 
USER = 
(printer.acq~ire->~se 
->printer.rele~se->USER). 
~ ~ R I ~ T E R - S ~ A R E  
= (a:USER/ 1b:USERI l~a,~3::printer:~ESOURCE). 
Figure 3.15 Resource-sharing PRINTER-SHARE. 
Lastly, we  use  a  diagrammatic  convention  to  depict  the  common  situation 
of 
resource  sharing  as  described  in  section  3.1.3.  The  resource-sharing  model  is 
repeated  in  ,Figure  3.15  together  with  its  structure  diagram  representation.  The 
resource  is  not  anonymous  as  before;  it  is  named 
print e  r 
. Sharing  is  indicated by 
enclosing  a  process  in  a  rounded  rectangle.  Processes,  which  share  the  enclosed 
process,  are  connected  to 
it by thick  lines.  The  lines  in  Figure  3.15  could 
be labeled 
a . 
print e  r 
and b . 
print e r; however  these  labels  are  omitted  as  a  relabeling 
function  is  not  required. 
Concurrency  occurs  in  Java  programs  when  more  than  one  thread  is  alive. 
Remember  from  Chapter 
2 that  a  thread  is  alive 
if it has  started  but  has  not 
yet  terminated.  In  this  section,  we  present  an  example 
of a  simple  Java  multi- 
threaded  program  that  has 
two concurrently  active  threads  in  addition  to  the 
main  thread of execution  present  in  every  Java  program.  The  threads 
in the 
example  program  do  not  interact  directly.  The  topic 
of how  threads  interact  is 
left  to  succeeding  chapters. 

The  example  program  drives  the  display  depicted  in  Figure 
3.16. Each of the 
threads A and I3 can be run and  paused  by  pressing  the  appropriate  button. 
When a  thread  is  run,  the  display  associated  with 
it rotates.  Rotation  stops 
when  the  thread  is  paused.  When  a  thread  is  paused,  its  background  color  is 
set  to  red  and  when it is r
u
~
~
,
 
the  background  color  is  set  to  green.  The  threads
do  not  interact  with  each  other,  however  they  do  interact  with  the  Java  main 
thread of execution  when  the  buttons  are  pressed. 
Figure 3.16 ThreadDemo display. 
The  behavior of each of the two threads  in  the  applet  is  modeled 
by the  follow- 
ing ROTATOR process: 
ROTATOR = PAUSED, 
PAUSED = (run->RUN I pause->PAUSED), 
RUN 
= (pause->PAUSE~ 
 
l~run,rotate}->RUN). 
The  process  cannot  perform  the rot at e action  until it moves  into  the RUN state. 
This  can  only  occur  after  the run action,  whic 
When  the pause action  occurs - 
modeling  the 
back  to  the PAUSED state in  which  the  rotate  action  cannot  take  place.  The  model 
implies  that  the  implementation 
of ROTA TO^ runs  forever - 
there  is  no  way 
of 
stopping it. It is  not  good  practice  to  program  threads  which  run  forever;  they 
should  terminate  in  an  orderly  manner  when,  for  example,  the Apple t . 
stop ( ) 
method  is  called 
by a browser.  As we  discussed  in  the  previous  chapter,  the 
designers of Java  do  not  recommend  using 
7" h read . 
stop ( ) to  terminate  the 
execution of a  thread.  Instead,  they  suggest  the  use of T h read . 
in t e r r 
u p t ( ) 

which  raises  the Interrupt  edExcept  ion 
that allows  a thread to  clean up before 
terminating. We can  include  termination in the ROTATOR process as shown below. 
The corresponding LTS is  depicted. in Figure 3.17. 
ROTATQ~ = PAUSED, 
PAUSED = (run->RUN I pause->~AU~~D 
RUN 
 
AUSED 
~~r~~~rotate}->RUN 
linterrupt->§TOP), 
linterrupt->§TOP). 
interrupt 
pause 
Figure 3.17 ROTATOR. 
This  revised  model  includes  the  effect 
of an interrupt action.  Whether  the 
ROTATOR process  is  in  the paused or running state,  the interrupt takes it into a 
final  state  in  which no further  actions  are  possible,  i.e. 
it is  terminated.  The  model 
for  the ~ r e a d ~ e m o  
program consisting of two copies  or  instances of the ROTATOR 
thread  is shown in  Figure 3.18. 
We have  relabeled  the a. in t e r  r 
u p t and b . 
in t e r r 
u  p 
t actions  to  be 
the same 
action stop, ind.icatin~ that we  always interrupt both threads at the  same  time, 
~ i g u ~ e  
3.18 T ~ e a d ~ e ~ o  
model. 

56 
Chapter 3: C o ~ c ~ r r ~ t  
~ x e c ~ t i o ~
when  the  browser  calls Applet stop ( ) Having  constructed  the  model,  we  can 
animate  it  using  the 
LTSA tool  to  check  that  its  behavior  corresponds  to  the 
behavior  we  expect of the ThreadDe~o 
applet. Figure  3.19  shows  a  screen  shot 
of the LTSA Animator  window. As described  in  Chapter 2, those  actions  that  can 
be  chosen  for  execution  are  ticked. In the  figure,  the  action a . 
run has put process 
a in  the state where a. rot at  e 
actions  can  occur  while  process b cannot  perform 
its b. rotate action  since b. run has not  occurred. 
Figure 3.19 LTSA Animator window for T~~EAD-DE~O. 
In fact,  in  the implementa~on, the  environment  is  provided 
by  the  main  thread 
of execution of the  Java  program. We can of course  also  model  this  main  thread  as 
a  process that shares  the  actions. The display  can  rotate at any  time and the 
buttons can  be  pushed at any  time.  Consequently,  this  main  thread  can  be  mod- 
eled  as: 
MAIN = (~a,rotate,a.run,a.pause,stop, 
b.rotate,b.run,b.pause}->MAIN). 
Composing MAIN with T~READ-~EMO does  not  modify  the  behavior 
of 
T~READ-DE~O 
since  it  does  not  provide  any  additional  ordering  constraints  on 
the  actions. 
The  implementation  for  the  process  is  provided  by  the 
Rot at o r class,  which 
implements  the Run n  a  ble 
interface  as  shown  in  Program  3.1.  The 
r u n ( ) method 
simply  finishes if an InterruptedEx~eption 
raised  by Thread  interrupt 
( ) 

occurs. As described in the  previous  chapter, when  the run ( ) method  exits,  the 
thread  which  is  executing it terminates. 
Program 3.1 Rotator class. 
The  details of suspending  and  resuming  threads  when  buttons  are  pressed  are 
encapsulated in the Thread  Panel class.  The 
run ( ) method  simply  calls 
ThreadPane~ 
I rotate( ) to  move  the  display. 
If 
&use button  has  been 
pressed,  this  method  suspends  a  calling  thread 
mti 
is  pressed.  We  use  the 
T h read  Pan 
e 1 class  extensively in programs  throughout  the  book.  The  methods 
offered by this  class  relevant  to  the  current  example  are  listed  in  Program 3.2, 
Program 3.2 Threadpanel class. 
The T h re ad  Pan 
e l class  manages  the  display  and  control  buttons  for  the  thread 
that  is  created by a  call  to  the st art ( ) method.  The  thread  is  created  &om  the 

isplayThread which  is  derived  from 
Thread. The implemention of 
st a r t  ( ) is  given  below: 
(canvas,r, ...); 
thread.start(); 
f 
where c an  vas is  the  display  used  to draw the  rotating  segment. The thread is 
terminated  by  the stop( ) method  using Thread I interrupt ( ) as shown below: 
v o i d   s t o p ( )   ~ t h r e a d . i n t e r r u p t ( ) ; ~  
Threadpanel delegates  calls  to rotate ( ) to ~ ~ s p l ~ y T h r e ~ d .  
The relationship 
between  these  classes,  the applet and the Rot  at 
o r class  is  depicted in the  class 
diagram of Figure 3.20. Note that rot  at 
e ( ) is  a  static  method  which  determines 
the  particular 
thread instance  to  which 
it applies  by  calling  the  method 
T h read . 
c u r r e  n t T h re ad ( ) . This returns a  reference  to  the  currently r ~ i n g  
thread,  which of course,  is  the  only  thread  which  can  have  called  the 
method. 
Figure 3.20 T h r ~ a d ~ ~ ~ o  
class diagram. 

Program 3.3 ThreadDemo applet class, 
In  section 2.2.3, we  saw that Java  provides  a standard set of operations  on threads 
including suspend ( ) and resume ( ) which  the  reader  might  surmise  have  been 
used  to suspend and resume  the  execution of the threads in response to pushing 
the buttons. In  fact, we cannot  use  the  operations  directly  in  the  implementation
of 
the Thread~emo program for  the  following  reason.  The 
rotate( ) method 
acquires and releases  resources  from  the  graphical  interface 
provided by  the 
browser in which  the applet runs. If we  used suspend ( ) , 
a  thread  could  be 
suspended at some arbitrary t h e  when 
was pressed. In  particular,  it 
could  be suspended while it was holding  on  to 
display resources,  This  can 
cause  some  browsers  to 
hang or  deadlock'.  Consequently,  the 
threads in 
the program are  suspended.  using  the  methods 
Ob j ect . 
wait ( ) and 
0 b j ec t . 
not i f  y ( ) . We defer an explanation of how  these  work  until  Chapter 
5 
and consider  the  problem of deadlock  in  Chapter 6. 
For  just  this  reason, at the h
e
 
writing,  JavaSoft  have  issued a white  paper  suggesting  that,  as  with 
stop ( ) , 
suspend ( ) and resume ( ) should be deprecated in future  Java  releases. 

This  chapter  has  introduced  the  concept  of 
in~e~Ze~~ing 
both as a  way of executing 
multiple  processes  on  a  single  processor  and 
as a  way of modeling  concurrent 
execution. The  chapter  has  dealt  mainly  with  modeling  concurrency: 
The  model of concurrency  is  interleaved  and  asynchronous.  By  asynchronous 
we  mean  that  processes  proceed  at  arbitrary  relative  speeds  and conse~uently 
their  actions  can be arbitrarily  interleaved. 
The parallel  composition of two or  more  processes  modeled  as  finite  state  pro- 
cesses  results  in  a  finite  state  process  that  can  generate  all  possible  interleavings 
of the  execution  traces of the  constituent  processes. 
Process  interaction  is  modeled 
by shared  actions,  where  a  shared  action  is 
executed  at  the  same t h e  by all  the  processes  that  share  the  action. A shared 
action  can  only  occur when all  the  processes  that  have  the  action  in  their  alpha- 
bets  are  ready  to  participate  in  it - 
they  must  all  have  the  action as an eligible 
choice. 
Process  labeling,  relabeling  and  hiding  are  all  ways  of  describing  and  control- 
ling  the  actions  shared  between  processes. 
M ~ i z a t i o n  
can be used  to  help 
reduce  the  complexity of systems  with  hidden  actions. 
Parallel  composition  and  the  labeling  operator  describe  the  static  structure 
of 
a  model.  This  structure  can  be  represented  diagrammatically 
by structure 
diagrams. 
Concurrent  execution  in  Java  is programed simply  by  creating  and  starting 
multiple  threads. 
The  parallel  composition  operator  used  here  is from CSP  (Hoare,  1985). It is  also 
used  in  the IS0 specification  language  LOTOS (ISO/IEC, 1988). We have  chosen 
to  use  explicit  process  labeling  as  the  sole  means of creating  multiple  copies of a 
process  definition.  LOTOS  and  CSP  introduce  the  interleaving  operator 
’ 
I l I ’ 
which interleaves  all  actions  even  if  they  have  the  same  name. 
We  have  found 
that  explicit  process  labeling  clarifies  trace 
 orm mat ion from  the 
LTSA tool. 
Further,  having  a  single  composition  operator  rather  than  the  three  provided by 
LOTOS  is  a  worthwhile  notational 
shplification. The  simple  rule  that  actions  with 
the  same  name  synchronize  and  those  that  are  different  interleave  is  intuitive  for 
users to grasp. 
Most  process  calculi  have 
an  underlying  interleaved  model 
of concurrent 
execution.  The  reader  should  look 
at the  extensive  literature  on  Petri  Nets 
(Peterson,  J.L.,  1981)  for  a  model  that  permits  simultaneous  execution of concur- 
rent  actions. 

Exercises 
61 
Forms of action  relabeling  and  hiding  are  provided  in  both CSP (Hoare,  1985) 
and CC§ (Milner,  1989). The FSP approach  is  based  on  that of CCS, from  which 
the  concepts of the  silent tau action  and  observational  equivalence  also  come. 
Techniques  for  equivalence  testing  and 
min~ization 
can  be  found  in  the  paper 
by 
Kanellakis  and  Smolka (1990). 
The  Structure  Diagrams  presented  in  this  chapter  are 
a simplified  form of the 
graphical  representation  of  Darwin  (Magee,  Dulay  and 
banner, 1994;  Magee, 
Dulay,  Eisenbach et al., 1995),  a  language  for  describing  Software  Architectures. 
The  Darwin  tool  set  includes  a  translator  from  Darwin  to 
FSP composition  expres- 
sions  (Magee,  Kramer  and ~ia~akopoulou, 
1997). 
Exercises  3.1  to  3.6  are  more  instructive  and  interesting if the  FSP  models  are  devel- 
oped  using  the  analyzer  tool LTSA. 
3.1  Show  that S1 and S2 describe  the  same  behavior: 
3.2 ELE~E~T=  (up->down->E~E~ENT) 
accepts  an UP action  and  then  a down action. 
Using  parallel  composition  and  the 
E L E ~ E ~ T  
process  describe  a  model  that  can  accept 
up  to  four up actions  before  a down action.  Draw  a  structure  diagram  for  your  solu- 
tion. 
3.3  Extend  the  model  of  the  client-server  system  described  in  section  3.1.4  such  that  more 
than  one  client  can  use  the  server. 
3.4  Modify  the  model  of  the  client-server  system  in  exercise  3.3  such  that  the 
call may 
terminate  with  a  timeout  action  rather  than  a  response  from  the  server.  What  happens 
to  the  server  in  this  situation? 
3.5 A roller-coaster  control  system  only  permits its car  to  depart  when it is full.  Passengers 
arriving  at  the  departure  platform  are  registered  with  the  roller-coaster  controller 
by a 
turnstile.  The  controller  signals  the  car  to  depart  when  there  are  enough  passengers  on
the  platform  to fill the  car  to its maximum  capacity  of  M  passengers.  The  car  goes 
around  the  roller-coaster  track  and  then  waits  for  another  M  passengers. A maximum 
of M passengers  may  occupy  the  platform.  Ignore  the s ~ c ~ o ~ ~ a t i o n  
detail of pas- 
sengers  embarking  from  the  platform  and  car  departure.  The  roller  coaster  consists  of 
three  processes: TURNSTILE, CONTROL and CAR, TURNSTILE and CONTROL inter- 
act by the  shared  action passenger indicating  an  arrival  and 
CONTROL and CAR 

3.6 
3.7 
interact by the  shared  action de part signaling  car  departure.  Draw  the  structure 
diagram  for  the  system  and  provide FSP descriptions  for  each  process  and  the  overall 
composition, 
A museum  allows  visitors to enter  through  the  east  entrance  and  leave  through 
its west 
exit.  Arrivals  and  departures 
are signaled to the  museum  controller by the  turnstiles at 
the  entrance  and exit. At  opening  time,  the  museum  director  signals  the  controller  that 
the  museum is open  and  then  the  controller  permits  both  arrivals  and  departures. At 
closing  time,  the  director  signals  that  the  museum 
is closed, at which  point  only 
departures  are  permitted by the  controller.  Given  that  it  consists of the  four  processes 
EAST,  WEST, CO~TROL 
and DIRECTOR, draw  the  structure  diagram  for  the 
museurn.  Now  provide an FSP description  for  each of the  processes  and  the  overall 
composition. 
Modify  the  example  Java  program 
of section 3.2.2 such  that it consists of three  rotating 
displays. 

In  the  last  chapter,  we  discussed  the  execution of multiple  processes  on  one  or 
more  processors,  modelin  concurrent  execution  by  interleaving 
and executing 
multiple  concurrent threads in a  Java  program. We explained  how  process  inter- 
action  is  modeled  using 
shared atomic  actions, but not  how  real  processes  or 
threads interact. In this  chapter,  we turn to  the  issues  involved in construc~g 
concurrent programs in which threads interact  to commu~cate and cooperate. 
The simplest  way  for 
two or  more threads in a  Java program to  interact  is  via 
an 
object  whose  methods  can  be  invoked by the  set of threads. This s
~
~
~
object’s 
state can of course  be  observed and modified  by  its  methods. ~ o n s e ~ u e ~ t l y ,  
two 
threads can c o m m ~ c a t e  
by  one thread writing  the state of the shared object and 
the  other thread reading  that state. Similarly,  a  set of threads may  cooperate  to 
update some  information  encapsulated in a shared object. ~~ortunately, 
as we 
will  explain,  this  simple  scheme of interaction  does  not  work. 
We have  seen that the  execution of the  instructions  from  a  set of threads can  be 
~terleaved in an arbitra~ fashion,  This  interleaving  can  result 
in incorrect 
updates to  the state of a  shared  object.  The  heno omen on is  known as ~ ~ ~ e ~ e ~
The problem of interference, and how  to deal with  it,  is  the  main  topic 
of this 
chapter. 

To focus  on  the  issues 
of thread  interaction, we  use  an  example  known  as  the 
problem of the  Ornamental  Garden,  due  to  Alan Bums and  Geoff  Davies (1993). 
The  problem  is  stated  as  follows. 
A large  ornamental  garden  is  open  to  members 
of 
the  public  who  can  enter  through  either 
of two turnstiles  as  depicted in Figure 4.1. 
The mana~ement wants  to  determine  how  many  people  there  are  in  the  garden 
at 
any  one  time.  They  require  a  computer  system  to  provide  this  orm mat ion. 
Figure 4.1 Ornamental  Garden. 
To simplify  the  problem  further,  we  consider  a  garden  that  people  are  allowed 
to  enter  but  never  leave!  The  concurrent  program  to  implement  the  population 
count  required by the  management of the  ornamental  garden,  consists 
of two 
concurrent  threads  and  a  shared  counter  object.  Each  thread  controls  a  turnstile 
and  increments  the  shared  counter  when  a  person  passes 
 rough the  turnstile. 
The  class  diagram  for  the  program is depicted in Figure 4.2. 
Figure 4.2 Ornamental  Garden  class  diagram. 
The CO U n t e r object  and Tu r n st ile threads  are  created by the go() method of 
the Garden applet  shown  below 
in which eastD, westD and c o u ~ t e r D  are 
objects of the  same ~ u ~ b e r C a n v a s  
class  that  we  used in Chapter 2. 

nter(counterD)~ 
ile(west~,counter); 
ile(eastD,counter); 
west.  start 
( ) ; 
east.start(); 
3 
The Tu rnst ile thread  shown  in  Program 4.1 simulates  the  periodic  arrival of a 
visitor  to  the  garden by sleeping  for  half  a  second  and  then  invoking  the 
in c re - 
men t ( ) method  of  the  counter.  After  the  arrival 
of Ga rd e  n 
. 
MAX visitors,  the 
run ( ) method  exits  and conse~uently, the  thread  terminates. 
Program 4.1 Turnstile class. 
The  remaining  class 
Count er is more  complex  than  is  strictly  necessary.  The 
additional  complexity  is  to  ensure  that  the  program  demonstrates  the  effects 
of 
interference  independently of any  particular  implementation of Java. To  ensure 
that  the  program  demonstrates  the  desired  effect,  Program 4.2 ensures  that  arbi- 
trary  interleaving  occurs. 

66 
C ~ a ~ t e ~  
4: S ~ u ~ e d  
Objects and Mutual Excl~sion 
Program 4.2 Counter class. 
It  does  this  by  using  the  class 
Simulate which  provides  the  method 
HWin t e r r u pt ( ) . The  method, when called,  sometimes  causes  a thread switch 
by  calling T h read . 
y i e l d  ( ) and sometimes  omits  the  call  leaving  the  current 
thread ~
~
n
g
.
 
The  idea is to  sirnulate  a hardware interr~pt which  can  occur at 
arbitrary times  between  reading and writing  to  the shared Count e r  when per- 
forming an increment. Thus thread switches  can  occur at arbitrary  times as dis- 
cussed  at  the  beginning of the  last chapter. The Simulate class  is  defined  by  the 
following  code: 
void ~ W i ~ ~ e r r u ~ ~  
( ) { 
( ~ a t h . r a n d o m ( ) c O . ~ )   ~ h r e a d . y i ~ l  
3 
The  problem with the Q~amental Garden program is illustrated by the  screen 
shot of the running applet in  Figure  4.3.  When  the 
button is pressed,  the 
Ea  rden 
I go ( ) method  is  invoked  to  create  a  counter 
object and the two tu~stile 
threads. Each thread then increments  the  counter  exactly Garden . 
MAX times and 
then terminates. The value of the  constant Garden, MAX has been  set  to 20, con- 
sequently,  when both turnstile threads t e r ~ a t e ,  
the  counter  display  should  reg- 
ister that 40 people  have  entered  the garden. In fact, as can  be  seen  from  Figure 
4.3, the  counter  registers  only 
31.  Where  have  the  missing  people  gone?  Why  hav

Figure 4.3 Garden display 
nine  increments  to  the  counter  been  lost?  To  investigate  why,  we  develop 
a model 
of  the  Ornamental  Garden  problem. 
In the  remainder  of  the  book,  we  generally  model  each  object  or  set 
of objects as an 
FSP process.  However,  to  find  out  why  the 
ornamental Garden  program  operates 
incorrectly, we  must  model  it 
at the  level of store  accesses. ~onse~uently, 
the 
model  includes a VAR process  that  describes  the  read  and  write  accesses  to 
a 
store  location.  This  store  location  is  the 
value variable  encapsulated by the 
people instance  of  the 
Count  e 
r class  (Program 4.2). The  complete  model  is 
described  in  Figure 
4.4. The  reader  may 
be surprised  that  there  is  no  explicit 
mention  of  an  increment  action.  Instead,  increment  is  modeled  using  read  and 
write  actions by the  definition INCRE~ENT 
inside T U R ~  
TI LE. Each  thread  object, 
east and west, has  its  own  copy  of  the  read  and  write  actions  that  make  up  the 
increment  operation  or  procedure.  This  models  what  happens  in  the  actual  Java 
program  since  methods  are  re-entrant  and  thus  the  instructions  which  constitute 
a 
method  may  be  interleaved  on  behalf of the  threads  executing  the  method  con- 
currently. In other  words,  method  activations  are  not  atomic  actions.  The  LTS  for 
the TURNST~LE 
is  given  in  Figure 4.5. 
Figure 4.4. We  have  not  used  set  constants  before. 
A. set  constant  can  be  used 
wherever  we  previously  declared  sets  of  action  labels  explicitly.  Sets  are  simply a 
way  of a~breviating model  descriptions. VarAlpha is  declared  as  follows: 
The alphabet  of  the  process VAR has  been  declared  explicitly  as  the 
VarAlpha = { v ~ l u e . ~ r e a ~ [ T ~ , w r i t e ~ T ] }  
} 
The  alphabet  for  the 
TURNST~LE 
process is. extended  with  this  set  using  the 
alphabet  extension  construct + { . . 
L. }. This  is  to  ensure  that  there  are 
no unin- 

68 
Chapter 4: Shared 
 
Objects 
 
and 
~
~
t
~
a
l
 
Exclzlsio~ 
c o ~ s t  
N = 4 
set 
VarAlpha = {value.{read[T~,write[T]}} 
VAR 
= VAR[O], 
VAR[u:T] = (read[u]  ->VAR[ul 
lwrite[v:T]->VAR[v])~ 
TURNSTILE = (go 
-> RUN), 
RUN 
= (arrive -> INCRE~ENT 
lend 
-> TUR~STILE), 
I N ~ R E ~ E N T  
= (value.read[x:T] 
-> value.write~x+l~-~RUN 
)+VarAlpha. 
I IGARDEN = (east:TURNSTILE I I west:TURNSTILE 
I I {east,west,~isplay~::value:VAR) 
/{go /{east,west}.go, 
end/{east,west}.end}. 
Figure 4.4 
Ornamental  Garden  model. 
tended  free actions. For  example, if a VAR write  of  a  particular  value  is  not  shared 
with  another  process  then  it  can  occur  autonomously. 
A TUR'NSTI LE process  never 
engages  in  the  action value  writ  e 
[ 
0 ] since  it  always  increments  the  value  it 
reads.  However,  since  this  action  is  included  in  the  alphabet  extension  of 
TURNSTILE, although  it is not  used  in  the  process  definition,  it 
is prevented 
from  occurring  autonomously.  The TURNSTILE process is slightly  different  from 
its  Java  implementation in that it does  not  run  for  a  fixed  number of arrivals  but 
may  end at any  point.  However, it cannot  end  in  the  middle  of  updating  the 
shared  variable value. The end action  is  only  accepted  as  an  alternative 
to an 
arrive action.  Note  that  the  shared  variable VAR is not  only  shared by the  turn- 
stiles east and west, but  also by display which  is  used  for  checking  purposes. 

4.1 ~ ~ t e r ~ e r ~ c e  
69 
value.read.4 
value.write.5 
Figure 4.5 LTS for TURNSTILE. 
Having  developed  a  model  of  the  Ornamental  Garden  program, 
in some detail, 
what  can  we  do  with  it?  Well,  we  can  animate  the  model  using  the 
LTSA tool  to 
produce  action  traces  for  particular  input  scenarios.  For  example,  the  trace  in 
Figure 4.6 illustrates  the  case  where  there  is 
an  east  arrival  and  a  west  arrival 
and  then end occurs. 
The trace  is  correct in that  after two arrivals  the  counter  has  a  value of two. 
However,  we  might  try  many  input  scenarios  before  finding  out  what  is  wrong 
with  the  program, 
To automate  the  search  for  the  error,  we  combine  a 
TEST 
process  with  the  existing  model  that  signals  when  an  erroneous  action  trace 
occurs.  The  process  is  defined  below: 

Figure 4.6 An Animator  trace for the  Ornamental  Garden. 
= TESTCO], 
( v c N ) ~ e a s ~ . a r r i v e , w e s t . a r r i v e 3 - 3 T ~ ~ T [ v ~ l ]  
- 
- 
L 
C ~ E C K [ v : T ]  = 
. v a l u e . r e a d ~ u : ~ ~  
-> 
(u==v)  right 
-> TEST[v] 
(u!=v) ~ r o n ~  
-3 ERROR 
) + ~ ~ i s p l a y , V a r A l p h a 3 .  
The  process  counts  the  total  number of east.  arrive 
and west m a r r i v e  actions. 
When  an end action  occurs,  and  consequently  the  shared  variable  updates  are 
complete, it checks  that  the  value  stored is the  same  as  the  total  number  of  arrival 
events. If not, an error  is  declared by moving  into  the 
RROR state. ERROR (like 
STOP) is  a  predefined FSP local  process  (or  state). It is always  numbered -1 in the 
equivalent  LTS.  Again,  alphabet  extension  is  used  to  ensure  that  no  actions  pre- 
fixed by d i s  play can  occur auto~omously. 
The TEST process  is  combined  with  the  existing  model  as  follows: 
We can now  request  the LTSA analysis  tool  to  perform 
an  exhaustive  search to see 
RROR state in TES can be  reached  and if so to  produce  an  example trace. 
The  trace  produced  is: 

Trace to property  violation  in  TEST: 
go 
east.arrive 
e~§t.v~lue.read.O 
west.  arrive 
west.v~lue.read.0 
east.value.write.1 
~~§t.value.write.I 
end 
dis~lay.value.read.1 
wrong 
This  trace  clearly  indicates  the  problem 
with the  original  Java 
program. 
Increments are lost  because  the shared variable  is not updated atomically.  Thus 
both east and west turnstile read the  value 0 and write 1. If the east increment 
finished  before the west  increment started or  vice  versa, then the result  would  be 
two (as in the previous trace). 
~estructive update, caused  by  the arbitrary interleaving of read and write 
actions,  is  termed i ~ ~ e ~ e ~ e ~ c e .  
h real  concurrent  programs,  interference  bugs are extremely  difficult to locate. 
They  occur ~ r e ~ u e n t l y ,  
perhaps due to some  specific  combination 
of device 
interrupts and a~plica~on 
I/O requests.  They  may not be found even  after  exten- 
sive  testing. We had to include  a simulated interrupt in  the  example  program to 
de~onstrate the error. Without  the simulated interrupt, the  program  is  still  incor- 
rect, although the erroneous behavior  may not manifest  itself on  all  systems. 
The  general  solution  to 
the problem of interference  is to give  methods that 
access  a shared object 
~~~~~~~~ 
e ~ c ~ ~ ~ i ~ e  
access to that object.  This ensures that 
an update is not interrupted by  concurrent updates. As we  see in the  following 
sections,  methods with mutually exclusive  access  can  be  modeled 
as atomic 
actions. 
 onc current activations of a  method  in  Java  can  be  m 
sive  by  prefixing  the  method with the  keyword 

72 
Chapter 4: Shared 
 
Objects 
 
and 
~ ~ t u a l  
Exclusion 
The  Counter  class  from  the  Ornamental  Garden  program  can 
be corrected by 
deriving  a Syflchroflize~Cou~ter 
class  from Counter and  making  the  incre- 
ment  method in the  subclass s
~
~
c
~
~
as shown in Program 4.3. 
Program 4.3 Corrected Count er class. 
fava  associates  a  lock  with  every  object.  The  fava  compiler  inserts  code  to  acquire
the  lock  before  executing  the  body of a  synchronized  method  and  code  to  release 
the  lock  before  the  method  returns.  Concurrent  threads  are  blocked  until  the  lock 
is  released.  Since  only  one  thread  at  a  time  may  hold  the  lock,  only  one  thread  
be executing  the  synchronized  method. If this  is  the  only  method, as in  the  exam- 
ple,  mutual  exclusion  to  the  shared  object  is  ensured. If an  object  has  more  than 
one  method,  to  ensure  mutually  exclusive  access  to  the  state of the  object, all the 
methods  should  be  synchronized. 
Access  to  an  object  may  also 
be made  mutually  exclusive by using  the  synchro- 
nized  statement: 
( o ~ ~ e c t )  
{ s t ~ t e ~ e ~ t s  
1 
This  acquires  the  referenced  object’s  lock  before  executing  the  bracketed  statemen
block  and  releases  it  on  exiting  the  block.  For  example,  an  alternative  (but  less 
elegant)  way  to  correct  the  example  would be to  modify  the T u r n s t i l e  . 
run ( ) 
method  to  use: 
(people)  ~people*iflcremeflt();3 
This  is  less  elegant  as  the  user  of  the  shared  object  has  the 
responsibili~ for 
imposing  the  lock,  rather  than  embedding it in the  shared  object  itself.  Since  not 
all  users  of  the  object  may  act  responsibly,  it  may  also  be  less  secure  against 
interference. 
The  output  from  the  corrected  Ornamental  Garden  program  is  depicted  in 
Figure 4.7. The only change is to use the class defined 
in Program 4.3 rather 

Figure 4.7 Corrected Garden display. 
than  the  original Count er class.  This  change  is  made 
by clicking  the 
box before  pressing 
Once  a  thread  has  acquired  the  lock  on  an  object by executing  a  synchronized 
method,  that  method  may  itself  call  another  synchronized  method 
from  the  same 
object  (directly or indirectly)  without  having  to  wait  to  acquire  the  lock  again. 
The 
lock  counts  how  many  times  it  has  been  acquired 
by the  same  thread  and  does  not 
allow  another  thread  to  access  the  object  until  there  has  been  an  equivalent  num- 
ber  of  releases.  This  locking  strategy  is  sometimes  termed 
recursive locking  since  it 
permits  recursive  synchronized  methods.  For  example: 
v o i d   ~ n c r e ~ e n t ( i n t  
n) { 
++value; 
3 
1 
This  is  a  rather  unlikely  recursive  version 
of a  method  which  increments value by 
n. If locking  in  Java  was  not  recursive,  it  would  cause  a  calling  thread 
to be 
blocked  forever,  waiting  to  acquire  a  lock  which  it  already  holds! 
The  sirnplest  way  to  correct  the  model  of  the  Ornamental  Garden  program  listed 
in  Figure 4.4 is  to  add  locking  in  exactly  the  same  way  as 
it was  added  to  the  Java 
program.  For simplici~, we  ignore  the  detail  that  Java  locks  are  recursive  since 
whether  or  not  the  lock  is  recursive  has  no  irnpact  on  this  problem. 
A (non- 
recursive)  lock  can be modeled by the  process: 
LOCK = (acquire->release->LOCK). 

74 
Ckap~er 4: S ~ r e ~  
Objects 
 
and 
~
~
t
~
a
l
 
~ x c l ~ s i o ~  
The  composition LOCKVAR associates  a  lock  with  a  variable. It is  substituted  for 
VAR in the  definition  of GARDEN. 
I ILOCKVA~ = (LOCK 1 I VAR). 
The  alphabet Va rAlp ha is  modified as follows  to  include  the  additional  locking 
actions: 
set  VarAlpha = ~value.~read[T],write[T], 
acquire, release)) 
Finally,  the  definition of TURNSTILE must be modified to acquire  the  lock  before 
accessing  the  variable  and  to  release it afterwards: 
TURNSTILE = (SO 
-> RUN), 
RUN 
= (arrive-> INCRE~ENT 
INCRE~ENT = (value.acquire 
lend 
-> TUR~STILE), 
-> value.read[x:T]-~value.write~x~1] 
-> value.release->RUN 
)+VarAlpha. 
We can  check  this  model  in  exactly  the  same  way  as  before  using 
TEST. h 
exhaustive  search  does  not  find  any  errors.  Consequently,  we  have  mechanically 
verified  that  this new version  of  the  model  satisfies  the  property  that  the  count 
value  is  equal  to  the  total  number 
of arrivals  when  stop  is  pressed. 
A sample 
execution  trace  of  the  new  model  is  shown  below: 
SO 
east.arrive 
east.value.acquire 
east"value.read.0 
east.value.write.1 
east.value.release 
west.arrive 
west.value.a~quire 
west.value.read.1 
west. value. write. 2 
west.value"re1ease 
end 
dis~lay.value.read.2 
right 
Now that  we  have  shown  that  we  can  make  shared  actions  indivisible  or  atomic 
using  locks, we  can  abstract  the  details of variables  and  locks  and  model  shared 

4.3 M o ~ e l i ~ g  
M ~ t ~ a l  
~ x c l ~ s i o ~  
75 
objects  directly  in  terms of their  synchronized  methods.  We  can  perform  abstrac- 
tion  mechanically by hiding  actions.  For  example,  we  can  describe  the  behavior 
of 
the Sync h ronizedcoun t  e 
r class  (over  a  finite  integer  range) by: 
N = 4  
T = O..N 
VAR = VAR[O], 
VAR[u:T] = ( read~u]->VAR[u] 
I write[v:T]->VAR[v]). 
LOCK = (acquire->release->LOCK). 
~ N C R E ~ E N T  
= (acquire->read[x:T] 
-> ( 
( x 4 )  write[x+l] 
->release->increment->INCRE~ENT 
) 
)+{read[T],write[T]}. 
I ICOUNTER = (INCRE~ENTI 
ILOCKl lVAR)@{incre~ent}. 
The d e f ~ t i o n  of INCRE~ENT 
has  been  slightly  modified 
from that  used  pre- 
en clause  ensures  that  the 
increment action  can  only  occur 
when  the  value  stored  is  less  than N. In  other  words, increment is  not  allowed 
to  overflow  the  range 
T. The alphabet  declaration @{ inc reme n  t 
} means  that 
read,  write, acquire and release become  internal  actions 
(tau) of 
R. The  Labeled  Transition  System  which  results  from 
~ ~ i z i n
R is  depicted  in  Figure 4.8. 
increment 
 
increment 
 
increment 
 
increment 
Figure 4.8 
" d z e d  LTS for COUNTER. 
We  can  describe  a  single  process  that  generates  exactly  the  same LTS: 
COUNTER = COUNTER[O], 
COU~TER[v:T~ 
= ( W  
n ( v 4 )  increment->COUNTER[v+l])" 
This  is  a  much  more  abstract  and  consequently  simpler  model 
of the  shared 
Counter object  with  its  synchronized 
increment method. We  have  demon- 
strated  above  (by LTSA ~ ~ z a t i o n )  
that  it  has  exactly  the  same  observable 

'76 
C~apter 4: S~ared 
O~~ects 
and ~
u
t
~
~
l
 
~xclusion 
behavior  as  the  more  complex 
def~tion. 
A display  action to read  the  value  of  the 
counter  can be added as shown  below: 
DIS~LAY-COUNTER = COUNTER[O], 
CO~NT~R[v:T] 
= (when  (vcN) in~re~ent->COU~TER~v+l] 
Idisplay[v] -> COUNTER[v]). 
The  LTS  which  results  from ~ ~ i z i n g  
DIS~LAY-COUNTER is  depicted in  Figure 
4.9. 
increment 
 
increment 
 
increment 
 
increment 
ispiay.4 
Figure 4.9 
Minimized LTS for DISPLAY-~OUNTE~. 
To implement  this  action in the  Java  class, we  would  simply  add  the  synchro- 
nized  method: 
int display( ) { 
3 
In the  following  chapters, we usually  model  shared  objects  at  this  level  of  abstrac- 
tion/  ignoring  the  details of locks  and  mutual  exclusion  (as  provided 
by the  use of 
synchronized  methods in Java).  Each  shared  object is modeled  as  an FSP process, 
in  addition  to  modeling  each  Java  thread 
as an FSP process. The  model of a 
program  does  not  distinguish  active  entities  (threads)  from  passive  entities  (shared
objects).  They  are  both  modeled  as  finite  state  machines.  This  uniform  treatment 
facilitates  analysis. 
In  this  chapter,  we  have  discussed  thread 
~teraction via  shared  objects.  The 
Ornamental  Garden  example  served  to  demonstrate  that  uncontrolled  interleav- 
ing of method  instructions  leads  to  destructive  update of the  state of the  shared 
object.  This  is  termed 
i ~ t e ~ e r e ~ c e .  
Interference  can be avoided by giving  each 
concurrent  method  activation  mutually  exclusive  access 
to the  shared  state.  In 
Java,  this  is  achieved by making  such  methods s y ~ c ~ r o ~ i z e  
~ ~ n c h r o ~ ~ e d  
meth- 
ods acquire  a  lock  associated  with  the  object  before  accessing  the  object  state  and 

Exercises 
77 
release  the  lock  after  access.  Since  only  one  thread  at  a  time  can  acquire  the  lock, 
synchronized  methods  obtain  mutually  exclusive  access  to  the  object  state. 
Interference  bugs  in  real  concurrent  programs  are  notoriously  difficult to find. 
They  can be found by analyzing  program  models  as  we  demonstrated.  However, 
this  requires  detailed  modeling  at  the  level 
of store  accesses  to  variables. Such 
models  quickly  become  too  large  to  analyze.  The  answer  is  to  ensure  system- 
atically  that  all  the  methods of objects  shared  between  threads  are  synchronized. 
They  can  then  be  treated as atomic  actions for  modeling  purposes. 
We  have  dealt  with  the  problem 
of access  to  shared  objects  encapsulating  vari- 
ables.  However,  access  to  any  resource  must 
be made  mutually  exclusive if the 
resource  cannot  be  concurrently  shared.  These  resources  are  sometimes  termed 
serially  reusable  since  they  can be used by many  processes  at  different  times  but 
not  shared by many  processes at the  same  time.  For  example,  a  printer  can  only 
produce  the  output  from  one  print  job 
at a  time. The solution of using  locks  to 
ensure  mutual  exclusion  is  a  general  one  that  can be applied  to  controlling  access 
to  a  printer  in  the  same  way as to  shared  variables. 
A  solution  to  the  mutual  exclusion  problem  was  first  proposed 
by Dijkstra 
(1965). All  operating  systems  and  concurrent p r o g r a ~ i n g  
textbooks  deal  with 
mutual  exclusion.  Usually,  great  emphasis  is  placed 
on  the  concept of a c ~ ~ ~
section. A  critical  section  is  simply  the  section 
of code  belonging  to  a  thread  or 
process  which  accesses  the  shared  variables. 
To  ensure  correct  behavior,  this 
critical  section  must  be  given  mutually  exclusive  access 
by acquiring  a  lock 
before  the  critical  section  and  releasing  it  afterwards. 
We have  not  used  the 
term  critical  section  since,  in  an  object-oriented  language 
such as Java,  shared 
variables  are  encapsulated in objects  and  accessed  via  methods.  In  other  words, 
synchronized  methods  are  critical  sections.  The  synchronized  statement  is 
another  way of making  a  section of code  a  critical  section in Java.  However,  it 
is usually  the  case  in  well-designed  concurrent  object-oriented  programs  that 
critical  sections  are  methods. 
4.1 Modify  the  uncorrected  version 
of the  Ornamental  Garden  program  such  that  Turnstile 
threads  can  sleep  for  different  times. Is it  possible to choose  these  sleep  times  such  that 
interference  does  not  occur? 

4.2 
4.3 
4.4 
Given  the  following  declarations: 
N = 3  
P = 1 . 
. 2   rea^ i~en~i~ies 
C = 0. . 
N //cu~n~er 
range fur luck 
Model a Java  recursive  lock as the FSP process RECURSIVE-LOCK with  the  alphabet 
{acquire[p:P] ,release[p:P]}. The  action 
acquire[p] acquires  the  lock  for 
thread p. 
A central  computer  connected  to  remote  terminals  via 
c o ~ ~ c a ~ o n  
links is used to 
automate seat reservations  for a concert  hall. A booking  clerk  can  display  the  current 
state of reservations  on  the  terminal  screen. To book a seat, a client  chooses a free  seat 
and  the  clerk  enters  the  number 
of the  chosen  seat at the  terminal  and  issues 
a ticket, A 
system is required  which  avoids double-book~g of the  same  seat  whilst  allowing 
clients  free  choice of the  available  seats.  Construct a model of the  system  and  demon- 
strate  that  your  model  does  not  permit dou~le-boo~ngs. 
(Hint: It is only  necessary  to 
model a few  terrninals  and 
a few  seats.  Remember, 
a seat  can  appear 
to be free 
although  it is booked  or  being  booked by another  clerk). 
Write a Java program  that  implements  the  seat  reservation  system of exercise 4.3. 

Monitors  are  language  features  for  concurrent 
program~ng. A monitor  encap- 
sulates  data,  which  can  only be observed  and  modified by monitor  access  pro- 
cedures.  Only  a  single  access  procedure  may 
be active  at  a  time. 
h 
access 
procedure  thus  has  mutually  exclusive  access  to  the  data  variables  encapsulated 
in the  monitor.  Monitors  should  sound  familiar  since we have  already  seen  the 
monitor  concept in the  last  chapter,  though  explained  using  different  terminol- 
ogy. h 
object  satisfies  the  data  access  requirement of a  monitor  since it encap- 
sulates 
 
data 
 
which, 
if declared 
 
accessed 
 
only 
by the 
 
object’s 
methods. 
 
These 
 
methods 
 
can 
 
b 
 
to 
 
provide 
 
mutually 
 
exclusive 
access.  Thus,  a  monitor  is  simply  represented 
in Java as a  class  that  has  syn- 
chronized  methods. 
Monitors  support c~~~~~~~~ 
s
y
~
c
~
~
~
~
~
z
~
~
~
in addition  to  ensuring  that  access  to 
the  data  they  encapsulate  is  mutually  exclusive.  Condition  synchronization, 
as the 
term  suggests,  permits  a  monitor  to  block  threads  until  a  particular  condition 
holds,  such 
as a count  becoming  non-zero,  a  buffer  becoming  empty  or  new 
input  becorning  available.  This  chapter  describes  how  condition  synchronization 
in monitors  is  modeled  and  how it is  implemented in Java. 
We illustrate  condition  synchronization  using  a  simple  example. A controller  is 
required  for  a  car  park,  which  only  permits  cars  to  enter  when  the  car  park  is  not 
full  and,  for  consistency,  does  not  permit  cars  to  leave  when  there  are  no  cars in 
the  car  park. A snapshot of our  Java shulation of the  car  park  is  given in Figure 
5.1. It  depicts  the  situation 
in which  the  car  park  is  full,  the  barrier  is  down  and  no
further  cars  are  permitted  to  enter.  Car  arrivals  and  departures  are  simulated by 

80 
C ~ a ~ ~ e r  
5: ~ o n i ~ o r s  
and Condi~ion S~nc~ronizatio~z 
Figure 5.1 Car park display. 
separate  threads. h Figure 5.1, the  departures  thread  has  been  stopped to allow 
the  car  park  to  become hll. The  arrivals  thread  is  therefore  blocked from  further 
progress. 
The  first  step  in  modeling  a  system  is  to  decide  which  events  or  actions  are 
of 
interest.  In  the  car  park  system, 
we  can  abstract  details  such 
as display  panel 
rotation  and  the  starting  and  stopping of the  display  threads.  We  thus  omit  the 
actions  concerned  with  running,  rotation,  pausing  and 
term in at in^ threads  that 
we  modeled  in  section 
3.2.1. Instead, we  concern  ourselves  with  only 
two 
actions:  car  arrival  at  the  car  park  and  car  departure  from  the  car  park.  These 
actions  are  named arrive and ~
~
a
r
~
 
respectively.  The  next  step  is to id en ti^ the 
processes.  These  are  the  arrivals  process,  the  departures  process  and  the  process 
that  controls  access  to  the c q  park.  Both  the  arrivals  process  and  the  departures 
process  are  trivial.  They  attempt  to  generate,  respectively,  a  sequence 
of arrival 
actions  and  a  sequence 
of departure  actions.  The  car  park  control  must  only 
permit  arrival  actions  to  occur when there  is  space in  the  car  park  and  departures 
to occw w ~ e n  
there  are  cars  in  the  car  park.  This  expresses  the 
s~chronization 
conditions  that  must be satisfied by the  other  processes  when  interacting  with 
the  car  park. 
The car  park  model  is  given  in  Figure 5.2. The ~ARPARKCONTRO~ 
process  uses 
the  indexed  state SPACES to  record  the  number of available  spaces in the  car  park. 
The  control  requirements  described  above  have  been  modeled  using  the 
FSP 
guarded  action  construct  (see  section 
2.1.5). Thus in  state SPACES[ 
01, arrive 
actions  are  not  accepted  and 
in state SPAC S [ 
N 3 , 
de p a r t actions  are  not  accepted. 

CARPARKCONTROL(N=4) = SPACESEN] 
SPACE[i:O".N~ = ( 
(i>O) arrive->SPAC 
(i<N)  depart->S~ACES[i~l] 
ARRIVALS 
= (arrive->ARRIVALS). 
DEPARTURES = (depart->~EPARTURES). 
1 ICARPARK = 
(ARRIVALS/  lCARPARKCONTROL(4)~ 
IDEPARTURES). 
Figure 5.2 Car park model. 
The behavior of the  car  park  system  is  depicted  as  a  labeled  transition  system 
(LTS) in  Figure 5.3. The  LTS  has  been  generated  directly  from  the  model 
of Figure 
5.2. It clearly  shows  that  a  maximum 
of four arrive actions  can be accepted 
before  a depart action  must  occur. 
arrive 
 
arrive 
 
arrive 
 
arrive 
depart 
 
depart 
 
depart 
 
depart 
Figure 5.3 Car park LTS. 
Our  models of concurrent  systems  represent all the  entities in a  system as pro- 
cesses.  In implement in^ the  behavior of a  model as a  Java  program,  we  must 
decide  which  entities  are  active  and  which  are  passive.  By 
active, we  mean  an 
entity  that  initiates  actions;  this  is  implemented  as  a 
t
~
~
e
~
~
.
 
By passive, we  mean  an 
entity  that  responds to actions;  this  is  implemented  as  a 
 it^^* As we will  see in 
subsequent  examples,  the  decision  as  to  which  processes 
in a  model  become 
threads in the im~lementation and which  become  monitors  is  not  always  clear- 
cut.  However,  in  the  car  park  example,  the  decision  is  clear.  The  processes 

82 
C ~ ~ t e r  
5: ~onitors 
and Conditi~~ 
 
Sync~roni~~ion 
A R R ~ V ~ L ~  
and DEPART~RES, 
which initiate arrive and depart actions,  should 
be  implemented as threads. The CARPARKCO~TRO~ 
process,  which  responds  to 
arrive and depart actions,  should be a  monitor.  The  class  structure of the  car 
park  program  is  depicted  in  Figure 5.4. 
rk 
Figure 5.4 Car park class diagram. 
We  have  omitted  the DisplayThread and ~raphiccanvas 
threads  managed 
by T h read Pan e l to  simplify  Figure 5 '4. These  are  organized in exactly  the  same 
way as depicted in  the  class  diagram  for ThreadDe~o 
in  Chapter 3. The  classes 
that  are  relevant  to  the  concurrent  execution 
of the  program  are  the 
two R  u  n  
ab l e 
classes, Arrivals and Departures, and  the ~arParkContro1 
class,  which  con- 
trols  arrivals  and  departures.  Instances 
of these  classes  are  created 
by the Car Park 
applet st art ( ) method: 
i c  void start() { 
rkcontrol c = 
W DisplayCarPark(carDisplay,Places); 
arrivals,start(~ Arrivals(c)); 
departures. start ew Departures(c)); 
1 
Arrivals and Departures are  instances  of  the 
Threadpanel class  and 
carDisplay is an instance of CarParkCanvas as shown  in  the  class  diagram. 

Program 5.1 Arrivals and Departures classes. 
"he code  for  the 
A r r i v a l s  and Departures classes  is  listed  in  Program 
5.1. 
These  classes  use  a Th read  Pan 
e l . 
rot  at 
c3 ( ) method  which  takes as its  para- 
meter  the  number 
of degrees  the  rotating  display  segment  is  moved.  The 
~ a r p a r k ~ o n t r o l  
class  must  block  the  activation 
of arrive ( ) by the  arrivals 
thread if the  car  park is full and  block  the  activation of depart ( ) by the  depar- 
tures  thread if the  car  park  is  empty.  How  do  we  implement  this in Java? 

Java  provides  a  thread  wait 
queue per  monitor;  actually,  per  object,  since  any 
object  may  have  a  monitor  synchronization  lock  associated  with 
it. The  following 
methods  are  provided  by  from  which  all  other  classes  are 
derived. 
v o i d   n o t i f y ( )  
Wakes up a  single  thread  that  is  waiting  on  this  object’s  wait  set. 
v o i d   n o t i f y A l l ( )  
Wakes up all threads that  are  waiting on this object’s wait set. 
~ n t ~ r r ~ ~ t ~ d E x c ~ p t i o n  
Waits  to  be  notified  by  another thread. The  waiting  thread  releases  the 
synchronization lock  associated  with  the  monitor.  When  notified,  the 
thread  must  wait  to  reacquire  the  monitor  before  resuming  execution, 
The operations  fail if called  by  a thread that  does  not  currently 
”own” the  monitor 
(i.e.  one that has not  previously  acquired  the s~chronization 
lock  by  executing  a 
synchronized  method  or statement). We  refer  to a  thread en~e~ing 
a  monitor when 
it  acquires  the mutual exclusion  lock  associated  with  the  monitor and exiting the 
monitor  when it releases  the  lock.  From  the  above  definitions,  it  can  be  seen  that
thread  calling wait ( ) exits  the  monitor.  This  allows  other  threads  to  enter  the 
monitor and, when  the appropriate condition  is  satisfied,  to  call not if y ( ) or 
n o t i f  )/All( 
) to  awake  waiting  threads. The operation of wait ( ) and notify ( ) 
is  depicted in Figure 5.5. 
Figure 5.5 Monitor wait ( ) and not if y ( ) . 

The  basic  format  for  modeling a guarded action  for  some  condition cond and 
action act using FSP is  shown  below: 
FSP: when cond act: -> ~ E ~ S T A T  
The  corresponding  format  for 
im~lementing the guarded action  for  condition cond 
and  action act using Java is as follows: 
J 
av'a : 
void 
 
act 
() 
InterruptedException 
( ! 
cond)  wait ( ) ; 
// ~
o
~
i
~
 
~ ~ o ~ i t o r  
data 
n o t i f y A l l (  ) 
l- 
The  while  loop  is  necessary to ensure that co  nd is indeed satisfied  when a thread 
re-enters  the monitor. Although the thread invoking wait ( ) may have been  noti- 
fied that cond is  satisfied,  thereby  releasing  it  from  the  monitor 
wait queue, cond 
may  be invalidated by another thread that runs between the time that the waiting 
thread is  awakened  and  the  time  it  re-enters  the  monitor (by  acquiring  the  lock). 
If an action  modifies  the 
data of the  monitor, it can  call not i f  yA11 ( ) to 
awaken  all  other threads that may  be waiting for a particular condition to hold 
with respect to this data. If it  is not certain that only a single thread needs to be 
awakened, it  is  safer to call not i f  yA11 ( ) than not if y ( ) to make sure that 
threads are not kept waiting ~ecessarily. 
Returning to the car park example, 
 
the 
 
implementation 
of 
the 
C a r ~ ~ r k C o n t r o l  
monitor  is  given in Program 5.2. Since either  the ARRIVALS 
thread is  blocked waiting space  or the ~EPARTURES thread is  blocked waiting 
cars  and  these  conditions are exclusive,  only a single thread may  be waiting on 
the monitor  queue at any  one  time.  Consequently,  we  can  use not i f  y ( ) rather 
ve  made  the spaces and capacity vari- 
so that they  can  be  accessed  by  the 
display 
class that is  derived  from  CarParkControl. 
P r o ~ r a ~  
5.2 CarParkCont rol monitor. 

Program 5.2 (Cont~n~ed). 
The  general  rules  for  guiding  the  translation 
of the process  model  into  a  Java 
monitor  are as follows: 
Each  arded  action 
in the  model of a  monitor  is  implemented as a syn - 
method  which  uses  a  while  loop  and wait ( ) to  implement 
e  while  loop  condition  is  the  negation of the  model  guard 
condition. 
and 
1 Changes  in  the  state of the  monitor  are  signaled  to  waiting  threads  using 
1 notify ( ) or notifyAll( ) . 
Thus in the  car  park  model: 
en(i>O)  arrive->SPACES[i-l] 
becomes 
Java: ~ 
(spaces==O)  wait();  --spaces; 
and 
(i:N) 
~ e p a r t - > ~ P A C ~ S [  
i + 1 ]  

becomes 
(spaces==N) wait(); ++spaces; 
The state of the  car  park  monitor  is  the  integer  variable 
spaces. Each method 
modifies spaces and consequently,  the  change  is  signaled  by not i f  y ( ) at the 
end of each  method. 
Semaphores,  introduced  by  Dijkstra 
(1968), were  one of the  first  mechanisms 
proposed  to deal with  inter-process  synchronization  problems. A semaphore S is 
an integer  variable that can  take  only  non-negative  values.  Once 
S has been  given 
an initial  value,  the  only  operations  permitted  on 
S are up(s) and down(s~ 
defined as 
follows: 
dow~(s): 
when S >O do decrement S ; 
up(s): increment S 
In  Dijkstra’s  original  proposal,  the down operation  was  called P (for  the  first  letter 
in the  Dutch word puss ere^, which  means “to pass”). The up operation was called 
V (after  the  first  letter of the  Dutch word vrijgeven, which  means ”to release”). 
Semaphores are implemented  in  the  kernels of many operating systems and real- 
time  executives.  The  above  definition of semaphores  seems  to  imply  some 
sort of 
busy  wait  by ~ o w ~ ~ s )  
until S becomes  non-zero.  In  fact, in the  kernel of an operat- 
ing system,  semaphores are usually ~plemented by  a  blocking  wait as shown 
below: 
dow~(s): 
if S >O then 
else 
decrement S 
block  execution of the  calling  process 
up(s): if processes  blocked on S then 
awaken  one of them 
else 
increment S 
Implementations of semaphores  usually  manage  processes,  blocked  on  a  sema- 
phore by down, as a  first-in-first-out  (FIFO) queue. The up operation  awakens  the 
process at the  head of the  queue. FIFO queuing  should not be  relied  on  in  reason- 
ing about the  correctness of semaphore programs. 

88 
C ~ a ~ t e r  
5: ~onitors and Co~dition S ~ n c ~ r o n i z u ~ o ~
In  the  following,  we  describe  how  Semaphores  are  modeled  and  how  they  c
implemented  using  Java  monitors.  However,  it  should 
be realized  that  semaphores 
are  a  low-level  mechanism  sometimes  used 
in ~ p l e m e n t i n ~  
the  higher-level  moni- 
tor  construct,  rather  than  vice  versa  as  presented  here  for  pedagogic  reasons. 
The  models of concurrent  systems  that  we  can  describe  in 
FSP are  finite,  to  ensure 
they  can be analyzed.  Consequently,  we  can  only  model  semaphores  that  take  a 
finite  range of values. If the  range  is  exceeded  then  this  is  regarded  as  an  error  in 
the  model as described  below: 
Max = 3 
Int = O..Max 
SE~A~HORE(N=O) 
= SEMACN], 
SEMA[v:Int] 
= ( ~ p - ~ S E ~ A [ v ~ l ]  
( W O )   d o ~ n ~ > S E ~ A [ v - l ]  
1
9
 
~ € ~ A [ M a x + l ]  = ERROR. 
Figure 5.6 Semaphore LTS. 
The  behavior of the  semaphore  is  depicted  in  Figure 
5.6, with  the ERROR state 
indicated by state(4). In  fact,  since  the FSP compiler  automatically  maps  unde- 
fined  states  to  the ERROR state, we  can omit the  last  line of the  description  and 
model  a  semaphore  more  succinctly  as: 
SE~APHORE(N=O) 
= SEMA[N], 
SEMA[v:Int] 
= ( ~ p - ~ S E M A ~ v ~ l ]  
( W O )   d o ~ n - > ~ E M A [ v - l ~  
1. 

The  model  follows  directly  from  the  first  definition  for  a  semaphore  in  the  pre- 
vious  section.  The  action 
down is  only  accepted  when  the  value 
v of the 
is  greater than zero. The  action UP is  not guarded. SEMAPHORE can 
take  values  in  the  range 0 . 
Max and has an initial  value N. If an up action  causes 
Max to  be  exceeded  then SE~APHORE 
moves  to  the ERROR state. When SEMAPHO~E 
is  used  in  a  larger  model,  we  must  ensure  that  this 
ERROR state  does  not  occur. 
As 
an example,  we  model  the  use of semaphores  to  provide mutual exclusion. 
Figure 5.7 Semaphore  mutual  exclusion  model. 
Figure  5.7  depicts  a  model  in  which  three  processes 
p [ 1 . 
.3] use  a  shared 
semaphore mu t ex to  ensure  mutually  exclusive  access  to  some  resource.  Each 
process  performs  the  action mu t ex . 
down to get  exclusive  access and mu t ex . 
U p 
to  release  it.  Access  to  the  resource  is  modeled as the  action c  r  i 
t ic a1 (for  the 
critical  section of code  used  to  access  the  shared  resource).  The  model  for  each of 
the  processes  is  as  shown  below: 
LOOP = (mutex.down->critical->mutex.up->LOOP). 
The  composite  process SE~A~EMO, 
which  combines  processes and semaphore and 
which  is  depicted  graphically  in  Figure  5.7,  is  defined  as: 
Note  that  for mutual exclusion,  the  semaphore  must  be  given  the  initial  value  on
The  first  process  that  tries  to  execute  its 
c  rit  ical 
action,  performs  a mu t ex down 
action  making  the  value of mu t ex zero.  No  further  process  can  perform mu t ex . 
down until  the  original  process  releases  exclusion  by 
mu t ex . 
up. This  can  be  seen 
clearly  from  the S ~ A ~ E M O  
labeled  transition  system  in  Figure 5.8. 
It should  also  be  clear  from  Figure  5.8  that  no  error  state  is  reachable  in 
MO since  it  does  not appear in  the LTS. In fact,  the  value of the  semaphore 
does  not  exceed  one  (from  the 
LTS, we  can  see  that  a  trace of two consecutive 
mut ex. up actions  without 
an intermediate mut ex . 
down cannot  occur).  For 

p.1 .~utex.down 
p.1 .mutex.up 
Figure 5.8 
S ~ M A ~ E M O  
LTS. 
mutual  exclusion,  it  is  sufficient to use  a ~~~~~y 
semaphore  which  takes  the  values 
0 or 1. We  have  already  seen  in  the  previous  chapter  that  we  can  use  the  analysis 
tool  to  check  mechanically  for  errors.  We  will  see  in  subsequent  chapters  that 
we 
do  not  have  to  rely on visual  inspection  of  the LTS to  assert  properties  concerning 
sequences of actions. Of  course,  in  this  example,  we  can  quickly  check 
if mutex 
ever  goes  above 1 by setting Max to 1 and  searching  for  errors. 
Semaphores  are  passive  objects  that  react  to 
up and 
~~~~ 
actions;  they  do  not 
initiate  actions.  Consequently, we  implement  a  semaphore in Java as a  monitor 
class.  The  actions 
up and 
~~~~ 
become  synchronized  methods.  The  guard  on 
the 
~~~~ 
action in the  model  is  implemented  using  condition  synchronization 
as we  saw  in  section 
5.1. The  class  that  implements  semaphores 
is listed  in 
Program 5.3. 

Program 5.3 Semaphore class. 
Even  though  the down ( ) method  in  Program  5.3  changes  the  state  of  the  monitor 
by decrementing value, we  do  not use not if y ( ) to  signal  the  change  in  state. 
This  is  because  threads  only  wait  for  the  value  of  the  semaphore  to be incremen- 
ted,  they  do  not  wait  for  the  value  to 
be decremented.  The  semaphore  implemen- 
tation  does  not  check  for  overflow  on  increment. 
This is  usually  the  case  in 
semaphores  implemented by operating  systems. It is  the  responsibility 
of the 
programer to  ensure,  during  design,  that  overflow  cannot OCCLW. 
We advocate 
the  use of analyzable  models to check  such  properties. 
Figure  5.9  depicts  the  display of the  semaphore  demonstration  program  mod- 
eled  in  the  previous  section. A thread  executing  in  its  critical  section  is  indicated 
by a  lighter-colored  segment.  Each  thread  display  rotates  counter-clockwise. In 
Figure  5.9,  Thread 1 is  executing  in  its  critical  section,  Thread 
2 is  blocked  waiting 
to  enter  its  critical  section  and  Thread  3  has  finished  its  critical  section  and  is 
executing  non-critical  actions.  The  sliders  underneath  each  thread  adjust  the 
time  a  thread  spends  executing  critical, as opposed to non-critical,  actions. If the 
total  time  spent in critical  sections by all  three  threads  is  less  than  a  full  rotation 
then it is  possible  to  get  all  three  threads  to  execute  concurrently. 
In other  words, 
there  need be no conflict  for  access to the  critical  resource.  This  is  often  the  case  in
real  systems. ~echanisms for  mutual  exclusion  only  take  effect  when  there  is 
conflict~g access  to  a  shared  resource. 
In real  systems, it is  therefore  advisable 
to  keep  the  time  spent  in  critical  sections  as  short  as  possible so as to  reduce  the 
likelihood of conflict. 

92 
C ~ u ~ t e r  
5: ~onitors 
and Conditia~ S y n ~ ~ ~ o ~ i z a t i o
Figure 5.9 Sema~emo 
display 
The  program  behind  the  display of Figure 5.9 uses  the  same Th re ad P an e l 
class as before;  however, it uses  a  different  constructor  to  create  the  display 
with multi-co~ored segments.  The  interface  offered  by  the  class,  extended  with 
the  methods  used  in  this  chapter, is shown  in  Program 5.4. 
Program 5.4 Extended version of Threadpanel class. 

5.2 Se~aphores 
93 
The Mu t ex Loop class,  which provides the r U n ( ) method  for  each thread, is  listed 
in Program 5.5. The  critical (mutually exclusive)  actions are the rot  at 
e ( ) actions 
which are executed  when  the  segment  changes  to  the  lighter  color.  This  is  indi- 
cated  by  the rot  at 
e ( ) method r e ~ r ~ g  
false  when the rotating arc  is dark- 
colored  and true when lig~t-colored. 
Pro~ram 
5.5 
~utexLoop 
class. 
The threads and  semaphore are created in the usual way  by  the applet st art ( ) 
method: 

94 
C ~ p t e ~  
5: ~onitors 
and Con~i~ion 
Syn~~ronization 
where threadl,  thread2 
and thread3 are Thread~anel instances  and 
s e ~ a ~ i s ~ l ~ y  
is an  instance  of ~ u ~ ~ e r C a ~ v a s .  
Buffers  are  frequently  used  in  concurrent  systems  to  smooth  out  information 
transfer  rates  between  the  producers 
of data  and  the  consumers 
of that  data. 
Consider,  for  example,  a  keyboard  device  driver  that  is  supplying  characters 
typed  at  a  keyboard  to  an  editor  program.  The  editor  can  consume  characters  at 
a much faster  rate,  on  average,  than  a  person  can  type  at  a  keyboard.  However, 
some characters  can  take  longer  than  others  to  process, for example,  a  character 
that  causes  the  screen  to  scroll  or  a  keyboard  command  that  invokes  a  formatting 
command.  When  the  editor  is  processing  a  character  that  takes  a  long  time  to 
process, it is  necessary  to  buffer  characters  from  the  keyboard,  otherwise  they 
would  be  lost.  This  buffer  is  sometimes  referred  to 
as the ~
~
~
e
-
~
buffer.  It  is 
an  example of the  sort of buffer  that we describe  in  the  follow 
h this  section  we  model  and  program  a  bounded  buffer,  which  consists 
of a 
fixed  number of slots.  Items  are  put  into  the  buffer 
by a ~ y o ~ ~ c e y  
process  and 
removed by a c o ~ s ~ ~ e y  
process.  The  buffer  is  organized 
so that  the  first  item 
put  into  it  will be the  first  item  out  (FIFO). 
Figure 5.10 Bounded  buffer  display. 
Figure  5.10  depicts  the  display 
of our  example  system  in  which 
a producer 
process  communicates  characters  to 
a consumer  process  via  a  five-slot  buffer. 
The small  circle  above  the  buffer  indicates  the  next free  slot  into  which  the  pro- 
ducer  process  can  place  a  character.  The  circle  below  the  buffer  indicates  the  next 
slot from  which  the  consumer  process  can  take  a  character.  The  reader  may  note 
the  similarity  between  this  example  and  the  initial  car  park  example  in  section  
.l. 
In  fact,  the  synchronization  requirements  are  the  same.  The  producer  is  only 

allowed  to put a  character  into  the  buffer  when  there  is  a  free  slot  and  the  con- 
sumer  process  can  only  get  a  character  when  there  is at least  one  in  the  buffer. 
These are exactly  the re~uirements for  the carpark, if we substitute space  for  slot 
and  car  for  character.  What  is  different  between  the  two  examples  is  the 
FIFO 
discipline  enforced  by  the  buffer,  in  contrast  to 
the car park where  cars  can  occupy 
any  free  space  and  need not leave in arrival order. 
The  producer-consumer  system with a  bounded  buffer  is an example of a pro- 
gram that handles data items without altering  them. In addition, the  behavior of 
the producer,  the  consumer and the  buffer  itself are not affected  by  the  value 
of the 
items  they handle. In other words, they do not test the value of these data items. 
The  behavior  is  said 
to be ~
~
~
~
-
~
~
~
e
~
e
~
~
e
If data independence can  be  estab- 
lished then models  can  be  simplified  by omitting the detailed representation of 
parameters and data structures. This leads to much  smaller  and  more  tractable 
models.  The get and put operations are simple actions that do not have para- 
meters.  The LTS  for the bounded  buffer  system,  depicted in Figure 5.12, should be 
compared with the  car park LTS  of Figure 5.3 to  see  the  similarity  between the 
s ~ c h r o ~ ~ a t i o n  
behavior of the two  systems. 
6UFFER(N=5) = COUNT[O], 
COUNT[i:O. .NI 
n (i<N) put->COUNT[ i+l ] 
n (irO) get->COUNT[i-l] 
)
W
 
PRO~UCER = (pUt->PRODUCER). 
CONS~~ER 
= (~et->CONSU~ER). 
I lBOUNDED6UFFER = (PRODUCER1  IBUFFER(5)I 
ICONSU~ER). 
Figure 5.11  Bounded  buffer  model, 

96 
C ~ z ~ ~ t e r  
5: ~ o ~ i t o r s  
and C o ~ d i ~ i o n  
 
S ~ ~ c ~ ~ o n i z a t i o ~  
Figure 5.12 Bounded  buffer LTS. 
The BUFFER of the  model  becomes  a  monitor in the  Java imp~ementa~on, 
with 
synchronized  methods put and g e t  (Program 5.6). We have separated the  inter- 
face of the  buffer  from  its  implementation  since  we  will 
provide an alte~ative 
~~lementation 
in  the  next  section. 
Program 5.6 Buffer interface  and B u f f e r I ~ p l  
class. 

Program 5.6 ( C u ~ ~ ~ ~ ~ e ~ ) .  
The  buffer  has  been  implemented  as  a genera~-purpose class  that can buffer  any 
type  of  Java  object.  The  buffer  data  structure  is 
a fixed  size  array bu f , 
indexed by 
i n  which points  to  the  next  free  slot  and out which points  to  the  next  slot  to be 
emptied.  These  indexes  are  incremented  modulo  the  size  of  the  buffer.  The  code 
for  the  producer  and  consumer  programs  is  listed  in  Program 5.7. 
rogram 5.7 Producer and Consumer classes. 

98 
Cha~ter 
5: ~ o n ~ t o r s  
and Con~ition 
 
S~nchroniz~tion 
Program 5.7 ( C o n ~ i ~ ~ e d ) .  
Suppose  that  we  did  not  wish  to  use  condition 
s ~ c h r o ~ z a t i o n  
directly h 
the 
implementation of the  buffer  monitor  class  but  instead 
we  decided  to  use 
two 
semaphores~Z2 and e~~~~ to  reflect  the  state of the  buffer. The  semaphore e~~~~ 
counts  the  number of spaces  and  is  decremented  during  a 
put operation, The 
put is, of course,  blocked if the  value of e~~~ is  zero.  Similarly, ~Z~ counts  the 
n ~ b e r  
of  items in the  buffer  and  is  decremented by a get operation.  The get 
is  therefore  blocked 
if the  value of ~
2
2
 
is  zero.  The  modified  buffer  class  is 
shown in Program 5.8. 
Program 5.8 Buffer  class using semaphores. 

The  semaphores  of  Program 5.8 replace  the cou n  t 
variable in the  original  imple- 
mentation,  the  conditional  waits  on  the  value  of  count  and  the  notification 
of 
changes in its  value. An updated  model to reflect  the  changes in the  buffer  imple- 
mentation  is  shown  below: 
Max = 5 
Int = 0. .Max 
(T=O) = SEMAEI], 
t 1 
= (up->SEMA[ 
Vt-l 
(WO) down->SEMA[v-l] 
) *  
UFFER = (put -> e m p t y . ~ o ~ n  
->full.up -> 
lget -> full.down ->empty.up  ->BUFFER 
L 
PRO~UCER = (put -> PRO~UCER). 
CO~SUMER = (get -> CQ~SUMER). 
R = (PRQDUCERI I BUFFER I I CO~SUMER 
I lempty:SEMAP~ORE(5) 
I lfull:SEMAP~ORE(O))~{put,~~t}. 

100 
C~apter 5: ~uniturs 
and Cundi~iu~ 
 
Sync~run~~a~iun 
problem  occurs  when  we check  this  model  using  the  analyzer  tool LTSA and 
find that it  reports  a  potential  deadlock  together  with  a  trace  of  actions  to that 
deadlock: 
Composing 
States Composed: 28 ~ r a n s i t i o n s :  32 i n  60ms 
Trace t o  DEAD~OCK: 
potential DEADLOCK 
get 
We discuss  deadlock in more  detail in the  next  chapter.  However, in essence, it 
means that a  system  can  make 
no further  progress  since  there 
are no further 
actions it can  take. The  deadlock in the  model  can  be  seen in the  demonstration 
version of the program by starting the  consumer and letting it block,  waiting  to  get 
a  character  from  the empty buffer.  When  the  producer  is started, it cannot put a 
character into the  buffer.  Why?  The  reason  is  to 
do with  the  use of two  levels of 
synchronization  lock:  the  first  gives  mutually  exclusive  access  to  the  buffer  moni- 
tor and the  second  gives  mutually  exclusive  access  to  the  semaphores. 
Program 5.9 Fixed  bounded  buffer using semaphores. 

5.4 Nested ~ o ~ i t o r s  
101 
Program 5.9 ( C o ~ t ~ ~ ~ e d ) .  
When  the  consumer  calls 
get, it  acquires  the 
Buff  er 
monitor  lock  and  then 
acquires  the  monitor  lock  for  the 
f 
U 11 semaphore by calling f  u 
11. down ( ) to 
check  if  there  is  something  in  the  buffer.  Since  initially  the  buffer  is  empty,  the  ca
to f  u 
11 . 
down ( ) blocks  the  consumer  thread  (using wait ( ) ) and  releases  the 
monitor  lock  for  the full semaphore.  However,  it  does  not  release  the  monitor 
uf  f  er. 
Consequently,  the  producer  cannot  enter  the  monitor  to  put  a 
character  into  the  buffer  and so no  progress  can be made by either  producer  or 
consumer - 
hence  the  deadlock.  The  situation  described  above  is  known  as  the 
nested ~ o n ~ t o r   ~ r o ~ ~ e ~ .  
The  only  way  to  avoid  it  in  Java  is  by  careful  design.  In  our
example,  the  deadlock  can  be  removed by ensuring  that  the  monitor  lock  for  the 
buffer  is  not  acquired  until  after  semaphores  are  decremented  (Program 5.9). 
A s  mentioned  before,  in  this  book  we  advocate  the  use  of  the  model  and 
analysis  to  aid  in  the  process  of 
"careful  design".  Those 
parts of the  model 
which  need  to  be  revised  to  take  into  account  the  changes  to  the  buffer,  documen- 
ted  in  Program 5.9, are  shown  below: 
BUFFER = (put -> BUFFER 
) *  
PROD~CER = (empty.dow~->put ->full.up  ->PRODUCER). 
C O ~ S U ~ E R  
= (ful1.down  +get  ->empty.up->CONSU~ER). 
Moving  the  semaphore  actions  from  the  buffer  process  to  the  producer  and  con- 
sumer  processes  reflects  the  change  in  the im~lementation where  the  semaphore 
actions  are  performed  outside  the  monitor  (i.e.  before  acquiring  the  monitor  lock
If this  modified  model  is  composed  and  minimized,  it  generates  an  identical  LTS 
to  that  depicted  in  Figure 
5.12 for  the  original  model.  This  gives  us  confidence  that 

102 
Cllapte~ 5: ~ o n i t o ~ ~  
and 
 
Condition 
S~nc~roniza~ion 
our  revised  semaphore ~plementation of  the  bounded  buffer  is  equivalent  to  the 
original  one which  used wait ( ) and not if y ( ) directly. 
An invariant for a  monitor  is  an  assertion  concerning  the  variables 
it encapsulates. 
This  assertion  must  hold  whenever  there  is  no  thread  executing  inside  the  moni
~onse~uently, 
the  invariant  must be true at any  point  that  a  thread  releases  the 
monitor  lock - 
when  a  thread  returns  from  a  synchronized  method  call  and  when
thread  is  blocked by a wait ( ) . A  formal  proof of the  correctness  of  a  monitor  can 
be  achieved by demonstrating  that  the  constructor  for  a  monitor  establishes  the 
invariant  and  that  the  invariant  holds  after  the  execution  of  each  access  meth
just  before  a wait ( ) is  executed.  Such an  approach  requires  a p r o g r a m ~ g  
logic, 
a  formal  logical  system  that  facilitates  making  precise  statements  about  program 
execution. Greg  Andrews  uses  this  approach  in  his  book (1991). 
Instead, for  the  reasons  outlined  at  length  in  Chapter 
1, we have  chosen  to  use  a 
model-based  approach  amenable  to  mechanical  proof.  The  disadvantage  is  that 
our  mechanical  proofs  only  apply  to  specific  cases  or  models  while  the  manual 
proof-theoretic  approach  used by Andrews  permits  correctness  proofs  for  the 
general  case.  For  example,  a  proof  method  could  establish  monitor  correctness 
for all  sizes of a  bounded  buffer  rather  than  just  a  specific  size.  However,  it 
is 
usually  the  case  that 
if a  model  for  a  specific  case  is  shown  to  be  correct,  the 
general  case  can  be  inferred by induction. 
Although  we  do  not  use  invariants  in  formal  correctness  proofs,  they  are  usefu
program  documentation  that  aid  informal  correctness  reasoning.  The  invariants 
for  the  monitor  programs  developed  in  this  chapter  are: 
The  invariant  for  the  car  park  controller  simply  states  that  the  number  of  spaces 
available  must  always 
be greater  than  or  equal 
to zero  and  less  than  or  equal  to  the 
m a x ~ u m  
size  of  the  car  park (v. 
The  semaphore  invariant  simply  asserts  that  the  value 
of a  semaphore  must 
always  be  a  non-negative  value. 
0 5 count 5 size 
and 0 5 in 
size 
and 0 5 out 
size 
in = (out + count) modulo size 

The  bounded  buffer  invariant  asserts  that  the  number of items  in  the  buffer  must 
lie  in  the  range  zero  to size and  that  the  indexes in and out must  lie  in  the  range 
zero  to size-1. It states  that  the in index  must  always be count items  ”ahead”  of  the 
out index  where  ahead  means  addition  modulo size. 
Invariants  are  also  used  to  reason  about  the  correctness 
of classes  in  sequential 
object-oriented  programs.  The  invariant  is  required  to  hold  after  each  method 
execution.  The  difference  in  concurrent  programs  is  the  additional 
responsibili~ 
to  establish  that  the  invariant  holds  at  any  point  where  the  object’s  monitor  lock 
released.  These  additional  points  are  where  a wait ( ) can be executed. 
In this  chapter, we  introduced  condition s~chronization’ which  in  combination 
with  the  mutual  exclusion  provided by sync~ronize~ 
methods,  supports  the  con- 
cept of a  monitor  in  Java.  Condition 
s~chronization is  implemented  using  the 
wait ( ), notify( ) and notify811 ( ) primitives  which  operate on a  waiting 
queue  which  can  be  associated  with  any  Java  object.  Operation 
wait ( ) suspends 
the  calling  thread  on  the  wait  queue, 
not if y ( ) unblocks  one of the  threads  on  the 
wait  queue  and not if y A l l (  ) unblocks  all  the  threads  on  the  wait  queue.  When  a
thread  suspends  itself by calling wait ( ) , 
the  monitor  mutual  exclusion  lock  is 
released.  Use of these  primitives  causes  an  exception  if  the  invoking  thread  does 
not  currently  hold  the  monitor  lock. 
Model  processes  that  react  to  actions  rather  than  instigate  them  are  usually 
translated  into  monitors  in  the  program  that  implements  the  model.  Each  guard
action  in  the  model 
of a  monitor  is  implemented  as  a 
s y n c ~ r o n i z ~ ~  
method  which 
uses  a while loop  and wait ( ) to  implement  the  guard.  The  while  loop  condition 
is  the  negation of the  model  guard  condition.  Changes  in  the  state of the  monitor 
are  signaled  to  waiting  threads  using not if y ( ) or not i f  y A l l (  ) . 
Nested  monitor  calls  should be used  with  great  care as they  can  cause  a  pro- 
gram  to  deadlock.  This can  occur  since  a  thread  that  waits  in  a  monitor  releases 
only  its  lock,  not  the  lock of any  monitor  from  which it may  have  been  called. 
The  idea of associating  data  encapsulation  with  mutual  exclusion,  which  is  the 
essence  of  the  monitor  concept,  is  jointly  due  to  Edsger W. Dijkstra  (1972b),  Per 
Brinch-Hansen (1972) and  C.A.R.  Hoare  (1974).  The  monitors  in  C.A.R.  Hoare’s 
classic  paper  differ  in  a  number 
of respects  from  the  way  monitors  appear  in  Java. 
Condition  wait  queues  are  declared  explicitly  in  the  original  proposal  and  more 

104 
~hffpter 
5: ~ o n i t o ~ s  
and ~ondition 
 
Sync~ronizfftio~ 
than  one  can be declared  in  a  monitor.  This  contrasts  with  the  Java  monitor,  which
permits  only  a  single  implicit  condition  queue.  ultiple  queues  allow  less  resche- 
duling  and thread-awake~g if multiple  threads  are  waiting  on  different  condi- 
tions. h Java,  all  threads  must 
be awakened  to  re-test  their  waiting  conditions. 
If a 
thread’s  condition  does  not  hold, it blocks  again.  In  practice,  threads  waiting on 
different  conditions  usually  wait at different  times  and  consequently  there  is  no 
extra  thread-activation  cost.  Even  when it does  occur,  the  extra schedu~g does 
not  usually  cause  a  problem. 
Another difference is the semantics 
of not if y ( ) . The  Java  semantic  for 
not if y ( ) is  known  as signal  and c ~ n t i ~ ~ e .  
This  means  that  the  notified  thread 
is  taken  off  the  wait  queue  and  put  into  the  scheduler’s  ready  queue.  However, 
thread  invoking  the  notify  operation  does  not  necessarily  give  up  the  processor 
and  can  continue  running.  Conditions  in  Java  are  thus  always  re-tested  when  the 
notified  thread  regains  the  monitor,  since  the  condition  may  have  been  invalid
between  the  time it was  notified  and  the  time  the  monitor  lock  is  re-acquired.  In 
contrast,  the not*  operation 
of the  original  proposal  had sign~l and urgent wait 
semantics.  Notify  would  cause  the  notified  thread  to  be  executed 
inmediately and 
the  notifying  thread to be suspended.  However,  the  notifying  thread  would  regain 
the  monitor  lock  before  new  entries.  Signal  and  urgent  wait  has  the  advantage  t
wait  conditions  do  not  need  to 
be re-tested.  The  disadvantages  are  additional 
~plementation complexity  and,  in  a  Java  context,  the  fact  that  the  semantics do 
not  fit  well  with  having  a  single  wait  queue.  An  extensive  discussion 
of the 
different  semantics  possible  for  condition 
synchro~zation may be found  in 
Greg  Andrews’  book  (1991). 
The  development of monitors  was  inspired  by  the  class  concept 
of S1MUL.A-67 
(Birtwistle,  Dahl,  Myhrhaug, et al., 1973).  Monitors  have  been  included  in  a  wide 
range of early  concurrent  programming  languages.  Concurrent  Pascal  (Brinch- 
Hansen,  1975)  was  the  first  concurrent programing language  to  include  moni- 
tors.  Subsequent  influential  concurrent 
programing languages  with  monitors 
include  Modula  (Wirth,  1977),  Mesa 
( ~ a ~ p s o n  
and Rede~, 1980),  Pascal  Plus 
(Welsh  and  Bustard,  1979)’  Concurrent  Euclid  (Holt,  1983)  and  Turing  Plus 
(Holt  and  Cordy,  1988). 
The  problem  of  nested  monitor  calls  was  raised 
by 
Andrew  Lister  (1977).  Java  has  brought  the  development 
of monitors h11 circle 
by including  the  concept in an  object-oriented p r o g r a m ~ g  
language. 
5.1 .A single-slot  buffer  may be  mod~led by: 

Exercises 
105 
Program a Java  class, On e us', that implements  this  one-slot buffer as a monitor. 
52 Replace the  condition s~chroni%ation 
in  your  implementation of the  one-slot  buffer  by 
using  semaphores.  Given that Java  defines  assignment  to  scalar  types  (with  the  excep- 
tion of long and double) and reference  types  to  be  atornic,  does  your  revised  imple- 
mentation  require  the  use of the  monitor's mutual exclusion  lock? 
um example  (Chapter 3,  exercise  3.6),  identify  which 
of the  processes, 
, 
C O ~ T ~ O L  
and ~ ~ ~ E C T O ~ ,  
should  be threads and which  should  be 
monitors.  Provide an implementation of the  monitors. 
5.4 The  Dining  Savages: A tribe of savages  eats  communal  dinners  from 
a large  pot that can 
hold A4 servings of stewed  missionary.  When a savage wants to  eat,  he  helps  himself 
from  the  pot  unless  it  is  empty  in  which  case  he  waits  for  the  pot  to  be  filled. 
If the  pot 
is  empty,  the cook  refills  the  pot  with M servings. The  behavior of the  savages and the 
cook are  described  by: 
SAVAGE = ( ~ e t s e r v i n ~  
-> SAVAGE). 
COOK 
= (fillpot -> COOK). 
Model  the  behavior of the  pot as an FSP process and then  implement  it as a Java 
monitor. 
5.5 FSP allows  multiple  processes  to  synchronize  on 
a single  action. A set of processes  with 
the  action sync in their  alphabets  must  all  perform  this  action  before  any 
of them  can 
proceed.  Implement a monitor  called Bar r ie r in  Java  with a S y n C method that 
ensures that all of N threads  must  call S y n C before  any of them  can  proceed. 
5.6 The S a v ~ ~ ~ s  
A c c o ~ ~ ~  
P
~
~
~
~
e
~
~
 
A savings  account  is  shared  by  several  people.  Each 
person  may  deposit  or  withdraw 
funds from  the  account  subject  to  the  constraint 
that  the  balance of the  account  must  never  become  negative.  Develop 
a model  for 
the  problem and from  the  model  derive a Java  implementation of a monitor  for  the 
savings  account. 

This Page Intentionally Left Blank

Deadlock  occurs  in  a  system 
when all  its  constituent  processes  are  blocked. 
Another way of saying  this  is  that  the  system is  deadlocked  because  there  are 
no  eligible  actions  that  it  can  perform.  We  have  already  seen 
an example of dead- 
lock in  the  nested  monitor  example 
of the  last  chapter.  There,  neither  producer  nor
consumer  process  could  make  further  progress  since  the consmer was  blocked 
waiting for  characters  from  the  producer and the  producer  was  blocked  waiting 
for  the  monitor  lock  held  by  the  consumer. 
In other  words,  each  process  was 
blocked  waiting  for  a  resource  held  by  the  other,  sometimes  referred  to 
as a 
”deadly  embrace”,  Coffrnan,  Elphick and Shoshani (1971) identified  four  neces- 
sary and sufficient  conditions  for  the  occurrence of deadlock 
Serially  reusable  resources:  the  processes  involved  share  resources 
~ h i c h  
they  use  under 
~utual  e~clusion. 
For  example,  monitors  encapsulate  resources  which  are  accessed  using 
mutual 
exclusion  (i.e.  synchronized  methods). 
~ncre~ental 
ac~uisition:  processes hold on to resources  already  allocated  to  the^ ~ h i l e  
~aiting to a c ~ u i ~ e  
additional  resources. 
This  is  exactly  the  situation  in  the  nested  monitor  deadlock  where  the  consum
holds  the  monitor lock  while  waiting  for  the  producer 
to put a  character  into  the 
buffer. 
No pree~ption: once ac~uired by a  process,  resources  cannot  be 
pree~pted  ~orcibly 
~ i ~ h d r a ~ n )  
but  are  only  release^ voluntarily. 
Again,  the  relevance of this  to  the  nested  monitor  deadlock  can  easily  be  seen 
since if the  consumer  thread  could  be  forced  to  release  the  monitor  lock  then 
execution of the  producer  could  proceed. 
~ a i t ~ o r  
cycle:  a  circular  chain (or cycle) o~processes exists  such  that  each  process  holds 
a  resource ~ h i c ~  
its successor in the  cycle is ~aiting to  ac~uire. 
The  nested  monitor  deadlock  is  a  specific  example 
of this  with  a  chain of length 
two. The  consumer  holds  the  monitor  lock  for  which  the  producer  is  waiting 
and the  producer has a  character  for  which  the  consumer  is  waiting. 

108 
C ~ a ~ ~ e 7  
6: Deadlock 
Strategies  for  dealing with deadlock  involve  ensuring that one of these  four  con- 
ditions  does not hold. For  example,  consider  a  system  which  allows  deadlocked 
cycles of processes  to  occur but then detects  these  cycles and aborts the dead- 
locked  processes, perhaps by  operator  action.  Such  a  system  is  denying  the 
third 
condition (no preemption),  since  the  aborted  processes are forced  to  release  the 
resources  they hold. The  system  implements d e ~ ~ l o c ~  
~
e
~
e
c
~
~
~
~
and recovery. 
In  this  chapter,  we are concerned  with an alternative  strategy. Our aim  is  to 
design programs such that deadlock  cannot  occur.  ~e  describe how to  analyze 
models  for  deadlock and how  to show that a  model  is  free  from  deadlock.  Finally, 
both the  model 
and implementation of a  classic  concurrent 
p r o g r a ~ ~ g
problem,  the Dining Philosophers, is presented. 
In  the  finite state model of a  process,  a  deadlocked state is,  simply,  a state with no 
outgoing  transitions. A process in such  a state can  engage in no further actions.  In 
FSP this  deadlocked  state  is  represented  by  the  local  process 
a  process  which  can  lead to a  deadlocked state is depicted in Figure 6.1. 
north 
 
north 
south 
~ O V E  = ( n o r t h - > ( s o ~ t h - > ~ O V ~  
I north->~TOP) 
Figure 6.1 MOVE process. 
The ~ O V E  
process of Figure 6.1 can  engage in alter~ating north and south 
actions.  However, an action  sequence of no r t h followed  by north leads  to  a 
deadlocked state in which no further  actions are possible.  This  can  be  seen 
using  the  Animator. We can  ask  the LTSA analyzer  tool to find  deadlock states 
and to produce a  sample  trace of how  these states can  be  reached  from  the start 
state. By performing  a  breadth-first  search of the LTS graph,  the LTSA tool guar- 
antees that the  sample  trace  is  the  shortest  trace  to  the  deadlock 
state. In the 
example of Figure 6.1, LTSA produces  the  following output: 

6.1 ~ e a ~ l o c ~  
Analysis 
109 
Trace to ~€A~LOCK: 
north 
north 
In  general,  the  deadlocks 
which  interest  us  are  not  those  that  are  declared 
explicitly  in 
prhitive processes  using 
STOP as  above,  but  those  that  arise 
from  the  parallel  composition 
of a  number of interacting  primitive  processes. 
The  deadlock  check  that  the  analyzer  performs  for  composite  processes  is,  of 
course,  the  same  as  the  check 
it performs  for  primitive  processes  since  a  com- 
position  is  also  described by a LTS graph. The  check  remains  a  search  for  states 
with  no  outgoing ~ansitions. 
R€S~URC€ 
= (get->put->R 
P = (printer.~et->scanner.get->copy 
->printer.put->scanner.put->P). 
Q = (scanner.get->printer.g~t-~copy 
->scanner.put->printer.put->Q). 
I jSYS = (p:Pi Iq:Q 
I f(p,q}::printer:R€SOURC€ 
I l~p,q}::scanner:R€SOURC€ 
) m  
Figure 6.2 Printer-scanner system. 
The  example  of  Figure 6.2 is  a  system  in  which two processes, P and Q, perform 
the  same  task,  that 
of scanning  a  document  and  printing 
it, by using  a  shared 
printer  and  shared  scanner. Each. process  acquires  both  the  printer  and  the  scan- 

110 
~ h a p ~ e ~  
6: ~ ~ a d l o ~ k
ner,  performs  the  scanning  and  printing  and  then  releases  the  scanner  and  printer 
resources.  The LTS  diagrams  for  process P and  for  the  shared print  e 
r are  given 
in  Figures 6.3 and 6.4 respectively. 
p.scanner.put 
Figure 6.3 LTS  for  process P. 
q.printer.g~t 
p.printer.get 
p.printer.put 
~.printer.put 
Figure 6.4 LTS  for the shared p r i n t  e r process. 
The  only  difference  between  the  processes 
P and Q is  that P acquires  the  printer 
first  and Q acquires  the  scanner  first.  This  system  satisfies  the  four  necessary  and 
sufficient  conditions  for  deadlock  which  were  outlined  in  the  introduction to this 
chapter:  the  scanner  and  printer  resources  are  serially  reused;  each  process  holds 
on  to  either  the  scanner  or  printer  while  waiting  to  get  the  second  resource 
it 
requires;  these  resources  are  not  preempted;  and  the  wait-for  cycle  is  apparent 
from  the  following  deadlock  discovered by LTSA: 
Trace to DEADLOCK: 
p.printer.get 
q.scanner.get 
This  is  the  situation  in  which  the  process P has  the  printer  and  is  waiting  for  the 
scanner  and  the  process 
Q has  the  scanner  and  is  waiting  for  the  printer.  The 
deadlock  is  easily  fixed  in  the  example 
by ensuring  that  both  processes  ask  for 
the  printer  and  the  scanner  in  the  same  order  (The  reader  should  verify,  using 
LTSA, that if the  model of Figure 6.1 is  modified  in  this  way,  deadlock  no  longer 
occurs.)  In  fact,  where  processes  share  different  classes 
of resources,  such as prin- 

6.2   in in^ P ~ i l o s ~ h ~ s  
Proble~ 
111 
ters and scanners,  a  general  purpose  strategy  for  avoiding  deadlock  is  to 
 er the 
resource  classes  i.e. if processes  use  resources  from  different  classes,  all  processes 
acquire  these  resources  in  the  same order. For OUT example,  this  can  be  achieved 
by,  for  example, always  requesting  printers  before  scanners. 
Another  solution  to  avoiding  deadlock,  in  this  example,  is  to  set  a  time-out  on
waiting  for  the  second  resource, If the  resource  has  not  been  acquired  within  the 
time-out  period  then  the  first  resource  is  released and the  process starts afresh as 
shown  below: 
P 
= (printer.get->   ET SCANNER), 
T~CANNER = (scanner.get->copy->printer,put 
->scanner.  put 
->P 
I timeout -> printer.  put 
->P 
) v  
Q 
= (scanner.get-> T ET PRINTER), 
~ETP~INTER 
= (~rinter.get->copy->printer.put 
->scanner.put-~Q 
/timeout -> scanner.put->Q 
1. 
is  denies  the  second  deadlock  condition 
of incremental  acquisition.  The  solution 
can  be ~ p l ~ m e n t e d  
in  Java  using  a  timed  wait.  However,  it  is  not  a  good  soluti
as both  processes  can  continually  acquire  the  first  resource,  time 
out and then 
repeat  this  cycle  without  making  any  progress towards accomplishing  the  copy 
action. LTSA detects  this  progress  problem,  returning  the  following: 
Progress violation for actions: 
(p.scanner.get,  p.copy,  p.scanner.put, 
q.printer.get,  q.copy, q.print~r~put3 
~e deal  with  this  class of problems  in  the  next  chapter. 
The  Dining  Philosophers  Problem  (Dijkstra, 
1968) is  a  classic  concurrent-program- 
ming  problem  in  which  the  deadlock  is  not  quite so apparent as in  the  previous 
examples. We develop  both  the  model and Java ~plementation. The  problem  is 
stated as  follows:  five  philosophers  share  a  circular  table  (as  depicted  in  Figure 
6.5) 
at which  they  have  allotted  seats.  Each 
p~osopher spends his  life  alternately 
thinking and eating.  In  the  centre of the  table  is  a  large  plate 
of tangled  spaghetti. 
A philosopher  needs  two  forks to eat  a  helping of spaghetti. U~or~nately, 
as 
philosophy  is  not as well  paid as computing,  the ph~osophers can  only  afford  five 

Figure 6.5 The Dining Philosophers table. 
forks.  One  fork  is  placed  between  each  pair of philosophers  and  they  agree  that 
each  will  only  use  the  forks  to  his Mediate right  and  left. 
The  resources  in  this  system  are  the  forks  shared  between  the  philosophers.  ~e 
model  a  fork  in  the  same  way  that  we  modeled  the  scanner  and  printer  resources 
in  the  previous  section: 
To use  a  fork,  a  philosopher  must  first  pick  up (get) that  fork  and  when  finished 
with  the  fork,  the  philosopher  puts  it  down 
(put). 
Each  philosopher  is  modeled 
by 
the  process: 
PHIL = (sit~own->right.get->left~get 
->ea~->left*put->right€put 
->arise->PHIL). 
h other  words,  when  a  philosopher  becomes  hungry, 
he (or  she)  sits  down  at  the 
table,  picks up  the  fork to his  left, if it is  free,  and  then  picks  up  the  fork  to  his 
right, if it  is  free.  The  philosopher  can  then eat. When  finished  eating,  the  philo- 
sopher  releases  the  forks  and  leaves  the  table.  The  Dining  Philosophers  system  ca
now be described by the  composition of five  fork  processes  and  five  philosopher 
processes as depicted  in  Figure 6.6. 
The  diagram of Figure 6.6 can  be  expressed  concisely as the  composite  process: 

6.2 ~
i
~
i
~
g
 
P~ilosop~ers 
P r o ~ l e ~  
113 
Figure 6.6 Dining P ~ ~ o s o p h e ~ s  
composite model. 
The  expression ( ( i- 
1 ) +N ) %N is subtraction  modulo N so that,  for  example,  a  fork 
is  shared  between p h il [ 
0 ] and p h il [ 
4 3 Analysis of this  system  reveals  the 
following  deadlock: 
Trace to DEADLOC~: 
phil.0.sitdown 
phil.O.right.get 
phil 
I 1 . 
sitdo~n 
phil.l"right,~et 
phil.2.sitdown 
phil.~.ri~ht.get 
~ h i l . ~ . s i t ~ o w n  
phil.~"right.get 
phil. 4 
m  itd down 
phil.4.ri~ht.get 
This  is  the  situation  where  all  the  philosophers  become  hungry 
at the  same  time, 
sit down at the  table and then  each  philosopher  picks up the  fork  to  his  (or  her) 
right. The  system  can  make  no  further  progress  since  each  philosopher  is  waiting 
for  a  fork  held  by  his  neighbor. 
In other  words,  a  wait-for 
cycle  exists, as  described 
in  the  introduction. 
It  is  generally  not  a  good  idea  to  implement 
an erroneous  model.  However, in this 
section,  our  objective  is  to  show  that,  while  deadlock  can  be  detected  easily  in  a 

model,  it  is  not so apparent in the running program  which  corresponds  to that 
model.  In  translating  the  Dining  Philosophers  model  to an ~plementation, we 
must consider  which  processes in the  model  will  be  represented  by  passive  objec
(mo~tors) and which by active  objects  (threads), 
as outlined in the  previous 
chapter. The  decision  is  reasonably  obvious;  forks 
are the  passive  entities and 
philosophers  are  the  active  entities in this  system. 
The relationships  between  the  various  classes  involved 
in the  Dining 
Philosophers  program  is shown in the  class  diagram of Figure 6.7. 
Applet 
 
Thread 
1 
Fork 
I 
controller 
~ 
display 
Figure 6.7 Dining Philosophers class diagram. 
The display  is  implemented  by  the 
PhilCanvas class.  The  interface  offered  by 
this  class  is  given  in  Program 6.1. 
Program 6.1 Outline of PhilCanvas class. 

The Java ~plementation of the  fork  monitor  is  listed  in  Program 
6.2. The boolean 
variable, taken, encodes  the  state of the  fork.  When  the  fork  is  on  the  table, 
t a  ken 
is  false. When  the  fork  has  been  picked  up by a  philosopher, taken is  true. 
Program 6.2 Fork monitor. 
The  code  for  the Ph ilo so p he r thread  is  listed  in  Program 6.3. It  follows  directly 
from  the  model.  The  detail  of  the  philosopher  sitting  down  and  leaving  the  table 
has  been  omitted;  philosophers  think  while  sitting  at  the  table. 
Program 6.3 
Philosopher Thread class. 

Pro~ram 
6.3 ( C o ~ ~ i ~ ~ e ~ ) .  
The  time  that  a  philosopher  spends t h i ~ g  
and  eating  is  controlled by the  slider 
in  the  applet  display  (Figure 6.8). 
The  code to create  the  philosopher  threads  and  fork  monitors  is: 
( i n t  i -0; i < N ;  ++i) 
( i n t  i =0; i < N ;  ++i)( 
F o r k ( ~ i s p l a y , i ) ;  
, ~ , f o r k ~ ( i - ~ + N ) ~ N ] , f o r k ~ i ] ) ;  
p ~ i l [ i ] . ~ ~ a r t ( ) ;  
1 
Figure  6.8  depicts  the  Dining 
P~losophers applet  running.  The  applet  may  run  for 
a  long  time  before  deadlock  occurs.  To  ensure  deadlock  occurs  eventually,  the 
slider  control  may be moved to the  left.  This  reduces  the  time 
p~losophe~s 
spend 
thinking  and  eating  and  this  "speedup"  increases  the  probability 
of deadlock 
occurring.  Figure 6.9 depicts  the  applet  when  deadlock  occurs. 
It is  clear  that 
each  philosopher  is  holding  on  to  the  fork  on  his  right. 

6.2 ~ining 
P~ilosop~ers 
P r o ~ l e ~  
Figure 6.8 Dining  Philosophers  applet - 
executing. 
Figure 6.9 Dining  Philosophers  applet - 
deadlocked. 

118 
C ~ u ~ ~ e ~  
6: Deudlock 
There  are  many  different  solutions  to  the  Dining  Philosophers  problem.  Some of 
these  are  referenced  in Notes and ~
~
~
t
~
e
~
 
~ e ~ d i ~ g  
at  the  end  of  this  chapter. AU of 
the  solutions  involve  denying  one of the  four  necessary  and  sufficient  conditions 
for  deadlock  identified  at  the  beginning 
of the  chapter.  The  solution we  outline 
here  depends  on  ensuring  that  a ~
f
f
~
~
~
o
~
 
cycle  cannot  exist. To do  this, we intro- 
duce  some  asymmetry  into  the  definition 
of a  philosopher. Up to  now,  each 
philosopher  has  had  an  identical  definition.  We  make  odd-numbered  philoso- 
phers  get  the  right  fork  first  and  even-numbered  philosophers  get  the  left  fork 
first.  The  revised  model  is  listed  below: 
FORK = (get -> put -> FORK). 
PHIL(  I=O) 
(1%2==0) sitdown 
->left.get->right.get 
(1%2==1) sitdown 
->right.get->left.get 
->eat->left.put->right.put->arise->PHIL 
eat->left.put->rig~t.put->arise->PHIL 
)
m
 
I I ~ I ~ E R S ( ~ = ~ ) =  
forall  [i:O..N-l] 
(phil[i]:PHIL(i) 
I ~~phil[i].left,phil[((i-~)+~)%N].right3::FORK). 
This  specification  for  the  Dining  Philosophers  is  deadlock-free  since 
it is  no  longer 
possible  for  the  wait-for  cycle  to  exist,  in  which  each  philosopher  holds  the  right 
fork.  The  reader  should  verify  using LTSA that  the  above  model  is  in  fact  dead- 
lock-free. The  same  change  can of course be made  to  the  Java  implementation  and 
the  result  is  a  deadlock-free  program. 
In  this  chapter,  we  have  seen  that  deadlock  is  a  system  state  in  which  all 
of the 
processes  in a system  are  blocked  and  the  system  can  consequently  make  no 
further  progress.  Deadlock  is  modeled  by  a  state  with  no  outgoing  transitions. 
Deadlock  analysis of a  model  involves  performing  an  exhaustive  search 
of the 
labeled  transition  system  for  such  states. If none are  found,  the  model  is  shown  to 
be deadlock-free. 

Exercises 
119 
We identified  four  necessary and sufficient  conditions  for  deadlock.  Strategies 
for  dealing  with  deadlock  involve  ensuring  that at least  one of these  conditions 
does  not  hold. The  conditions  are: 
Serially  reusable  resources:  the  processes  involved  share  resources  which  they  use  unde
~ u t u a l  
exclusion. 
~ncre~ental  ac~uisition: 
processes  hold on to  resources  already  allocated  to  the^ while 
waiting to ac~uire additional  resources. 
No pree~ption: once ac~uired by  a  process,  resources  cannot  be 
~ r e e ~ p t e d   ~ o r c i ~
withdr~wn) but  are  only re~eased voluntarily. 
~ a i t ~ o r  
cycle:  a  circular  chain (or cycle) o~processes exists  such  that  each  process  holds 
a  resource w h i c ~  its successor  in  the  cycle is waiting to  ac~uire. 
The  Dining  Philosophers  problem  was  used  to  illustrate  the  point  that  while 
deadlocks  are  easily  found  in  models,  they  are  not 
so readily apparent in  pro- 
grams.  Indeed,  the  reason  for  modeling  is  to  remove  problems  such  as  deadlock 
during design. 
The  Dining  Philosophers  problem  has  been  widely  used  to  compare  both  process
synchronization  primitives and strategies  for  dealing  with  deadlock.  The  problem 
was  introduced  by  Dijkstra  (1968)  in  a  paper  which  shows  how  to  use  semaphor
to  solve  a  variety 
of synchronization  problems. We have  used  asymmetry  to  avoid 
deadlock. A second way to  avoid  deadlock  is  to  allow 
at most  four  philosophers 
to 
sit down together at the  table.  Another  approach  is  to  ensure  that  the  act 
of 
picking up both  forks  is  atomic.  Chandy and Misra  (1984) proposed  a  fully  dis- 
tributed  solution  which  passes  tokens  between  philosophers. 
All of these 
approaches to the Dining Philosophers  problem  are  deterministic:  each  process 
takes  a  predetermined  set of actions.  Lehman and Rabin  (1981) showed  that  any 
deterministic  solution  has  to  be asymetric or  use an outside  agent  (such as the 
butler in exercise  6.2).  They  also  presented  a  probabilistic  solution  to  the  problem 
which  is  perfectly  symmetric.  Philosophers  toss  a  coin to determine  the  order of 
picking up forks and defer to a  neighbor if it  has  used  the  fork  less  recently. 
6.1 The  figure  below  depicts  a  maze.  Write  a  description 
of the  maze  in FSP which,  using 
deadlock  analysis,  finds  the  shortest path out of the  maze  starting at any  square. 

east 
(Hint: At  each  numbered  square 
in the  maze,  a  directional  action  can  be  used  to 
indicate an allowed path to  another  square.) 
6.2  One solution  to  the Dining Philosophers  problem  permits  only  four  philosophers  to  sit
down  at the  table at the  same  time. 
Specify a BUTLER process  which,  when  composed 
with  the  model of section 6.2 pemits a  maximum of four p~osophers to  engage in 
the sit down action  before an arise action  occurs.  Show  that  this  system  is dead- 
lock-free. 
6.3  Using  the  Java  timed  wait  primitive: 
void wait long timeout) 
mod* the Fork monitor  such that after  a  wait of 1 second,  the  call  to get times  out 
and returns  the  result  false. "he P h iloso p h e r should  release  the  other  fork, if it 
holds  it, and try again.  Observe  the  behavior of the  resulting  system. 
6.4 It  is  possible  for  the  following  system  to  deadlock.  Explain  how  this  deadlock  occurs 
and relate  it  to  one of the  four  necessary and sufficient  conditions  for  deadlock  to 
occur. 
Alice = (call 
Bob 
= (call 
Chris = (call 
1 IS = (Alice 
.bob -> waitxhris -> Alice). 
.chris -> wait.alice -> Bob). 
.alice -> wait.bob -> Chris). 
I I Bob 1 1  Chris) /{call/wait}. 
."he  following  model  attempts  to fix the  problem  by  allowing Alice,  Bob and Chris  to 
time  out  from  a  call  attempt. 
Is a  deadlock  still  possible? 
If so, describe  how  the 
deadlock  can  occur and give an execution  trace  leading  to  the  deadlock. 
Alice = (call.bob -> waitxhris -> Alice 
Bob 
= (calLchris -> wait.alice -> Bob 
Chris = (callsalice -> wait.bob -> Chris 
I 
timeout.alice -> wait,chris ->Alice), 
I 
timeout.bob -> wait.alice ->Bob). 
I 
timeout.chris -> wait.bob ->Chris). 
11s = (Alice 1 1  
ob I I Chris) /{call/wait~. 

A property  is an a ~ i b u t e  
of a  program  that  is true for  every  possible  execution 
of 
that  program.  Properties of interest  for  concurrent  programs  fall  into 
two cate- 
gories: s
~
~
e
~
~
 
and Eiveness. A safety  property  asserts  that  nothing  bad 
happens 
during execution. A liveness  property  asserts  that  something  good  eventually 
happens. hother way of putting this  is  that  safety  is  concerned  with a program 
not  reaching  a bad state and that  liveness  is  concerned  with  a  program  eventually 
reaching  a  good  state. 
In  sequential  programs,  the  most  important  safety  property  is  that  the  final 
state  is  correct. We have  already  seen  that  for  concurrent  programs,  important 
safety  properties  are mutual exclusion and the  absence of deadlock.  In  the  pre- 
vious  chapter,  we deter~ned that  deadlock  is  generally  a 
bad state  from  which  no 
further  actions  can  be  executed.  In  Chapter 
4, we  saw  that  allowing  more 
than one 
process  to  access  a  shared  variable  resulted  in  interference 
and thus incorrect  or 
bad  states. 
The  most  important  liveness  property  for  a  sequential  program  is  that  it  even- 
tually t e r ~ a t e s .  
However,  in  concurrent  progranxning,  we  are  frequently  con- 
cerned  with  systems  that do not  terminate.  In  this  chapter, 
we primarily  deal  with 
liveness  issues  relating  to  resource  access:  are  process  requests  for  shared 
resources  eventually  granted? We  will  see that  liveness  properties  are  affected 
by  the  scheduling  policy  that  determines  which 
of a  set of eligible  actions  are 
chosen  for  execution. 
This chapter  explains  how  we  can  analyze  the  finite  state  models 
of concurrent 
systems  for  both  safety and liveness  problems.  The  example of cars  crossing  a 
le-lane  bridge  is  used  to  focus  discussion. 
We then  analyze  a  number 
of 
implementations of read/write locks. Read/write locks  allow  many  processes to 
access a  shared  resource at the  same  time  for  read  access, 
but require  write  access 
to be mutu~lly exclusive.  They  occur  in  many  concurrent  programs. 

122 
Chapter 7: Safety 
 
and 
Liveness ?yo~~yties 
In  the  previous  chapter, we  saw  that  the LTSA analysis  tool  performs  deadlock 
analysis  using  a  breadth-first  search on  the  labeled  transition  system  correspond- 
ing  to  an FSP model.  The  "bad" states  that  are  the  objective 
of this  search  are  those 
states  with no outgoing  transitions,  i.e.  deadlock  states.  In  addition  to  deadlock 
states,  the  search  is  looking  for  error  states.  These  are  distinguished  in  the 
LTS by 
having  a  unique  identity 
(-1). So far in the  book, we  have  used  the  error-state 
explicitly  denoted by the  local  process ERROR. In Chapter 4, we specified  a  test 
process  that  explicitly  caused  a  transition  to 
ERROR when it detected  erroneous 
behavior.  In  Chapter 5, the ERROR state  was  used  to  detect  when  a  finite  range  was
exceeded.  The  example  given in Figure 7.1 is an actuator  that  must  not  receive  a 
second  command  before  it  has  responded  to  the  first. 
command 
command 
ACTUATOR = (command->ACTION), 
ACTION 
= (respond->A~TUATORlcommand->ERROR). 
Figure 7.1 ACTUATOR LTS. 
With  no  control  system  to  ensure  that  the  actuator  does  not  receive  multiple 
unacknowledged commands, ~ ~ ~ e t y  
analysis performed by LTSA produces the 
following  trace: 
Trace to property  violation in ACTUATOR: 
command 
command 
In  the  test  process of Chapter 4, the  range  excess of Chapter 5 and  the  actuator 
example of Figure 7.1, we  have  specified  the  situations  regarded as errors  rather 
than  directly  expressing  the  required  safety  property  that 
we  wish  to  preserve. In 
the  actuator  example,  the  safety  property  is  that  a 
command action  must  always be 
followed by a respond action  without  an  intervening command. In  complex  sys- 
tems  it  is  usually  better  to  specify  safety  properties 
by stating  directly  what is 
required  rather  than  stating  what  is not required. In this  way,  we  can  concentrate 

7.1 Safety 
123 
on  the  desired  behavior  of  a  system  rather  than  trying  to  enumerate all the  pos- 
sible  undesirable  behaviors. 
Safety  properties  are  specified in FSP by property  processes.  Syntactically,  these 
are  simply FSP processes  prefixed by the  keyword ~ r o ~ e r  
. 
They  are  composed 
with  a  target  system  to  ensure  that  the  specified  property  holds  for  that  system. 
The  example of Figure 7.2 specifies  the  property  that  it  is  polite  to  knock  before 
entering  a  room. 
knock 
knock 
y POLITE = (knock->enter->POLITE). 
Figure 7.2 property POLITE. 
The LTS diagram of Figure 7.2 reveals  that  in  translating  a  property  process,  the 
compiler  automatically  generates  the  transitions  to  the  error  state.  It  is  easily  seen 
that  an en t e r action  before  a knock action  causes  a  transition  to  the  error  state.  In 
addition,  knocking  twice  is  a  violation  of  the 
POLITE property. It should be noted 
that  in  every  state 
of the  property  process 
of Figure 7.2, all  the  actions 
in its 
alphabet (enter , 
knock) are  eligible  choices.  Those  that  are  not  part 
of the beha- 
vior  allowed by the  safety  property  are 
transitio~s to  the  error  state.  This  is  true 
of 
all  property  processes. 
The  property  to  check  the  correct  operation 
of the ACTUATO~ 
of Figure 7.1 is 
simply: 

124 
C~apter 7: Safety and Liveness ~ropert~es 
Property  processes  may be composed  with  a  system  without  affecting  the  correct 
behavior  of  that  system. In other  words,  composing  a  property  process  with  a  set 
of processes  does  not  affect  their  normal  operation.  However, 
if behavior  can 
occur  which  violates  the  safety  property,  then  a  transition  to  the  error  state  result
To preserve  this ~
~
~
~
s
~
~
of  safety  properties,  property  processes  must 
be 
deterministic.  That  is  they  must  not  contain 
non-deter~~stic 
choices. 
Experience  has  shown  that  this  is  rarely  a  restriction in practice. 
P defines  a d e t e r ~ ~ s t i c  
process  that  asserts  that  any 
ons in the ~lphabet of P, is  accepted by P. 
Thus,  if P is composed  with S, then  traces  of  actions  that  are in the  alphabet of S 
and  the  alphabet of P, must  also be valid  traces of P, otherwise RROR is  reachable. 
We  can  specify  that  an  action  or  a  set 
of actions  should  never  happen by using 
alphabet  extension.  The  example  of  Figure 
7.3 asserts  that d is as t e r should  never 
happen. 
disaster 
+ ~disa~ter3. 
Figure 7.3 property CALM. 
Listed  below  is  a  slightly  modified  version 
of the S E ~ A ~ ~ ~ O  
model  used  in  section 
5.2.1 to  show  how  semaphores  are  used  to  ensure  mutual  exclusion,  The  modi& 
cation  is  to  replace  the  single  action c r it ical. with  the  actions en t e r and ex it 
which  model  the  entry  and  exit  to  the  critical  section 
in which mutually  exclusive 
access  to  a  shared  resource  is  required. 
LOOP = 
(mutex.~o~n 
I 

To  verify that  this  system  does in fact  ensure mutual exclusion,  we  can  specify  a 
mutual exclusion  property and compose  it  with  the  system as follows: 
The  safety pro~erty 
X specifies  that  when  a  process  enters  the  critical  section 
e  process  must  exit  the  critical  section 
(p [ i 
] . 
exit) before 
another  process  can enter, The ~roperty is  not  violated in the  system  as  it  stands; 
however, if we change  the  value  with  which  the  semaphore  is 
i~tiali~ed 
from one 
) ) then  safety  analysis  using LTSA produces  the  follow- 
ing trace: 
to  property v i o l a  i o n   i n  ~ ~ T E X :  
p. 1 
e ~ ~ t e x .  
down 
p . 1  .enter 
The  trace  is  clearly 
a  violation of mutual  exclusion  since 
two processes  have 
entered  the  critical  section. 
e  problem  is  depicted  in 
Fig 
7.4. A bridge  over  a  river  is 
only wide eno~gh to 
permit  a  single  lane of traffic 
nse~~ently, 
cars  can  only  move c o n c u r r ~ ~ t l ~  
if 
ure 7.4 Singlelane bridge. 

126 
Chap~er 7: Safety and Liveness P~oper~ies 
they are moving in the  same  direction. A safety  violation  occurs if two cars  mov- 
ing in different  directions enter the bridge at the  same  time. 
To clarify  the  discussion,  we  refer  to  cars  moving  from  left  to  right as red  cars 
and  cars  moving  from right to left as blue cars  (see demo~tration applet). In our 
concurrent-programming model,  each  car 
is a  process  and 
the problem  is to 
ensure that cars  moving in different  directions  cannot  concurrently  access 
the 
shared resource that is the bridge. To make  the simulation more  realistic, we 
must  also ensure that cars  moving in the  same  direction  cannot pass each other. 
In  the  following  section,  we  develop  a  model of the  system  and  a  Java  imple- 
 ent tat ion that corresponds to the model. In this  section,  we are concerned  pri- 
marily with the safety properties of the  problem.  Later in the  chapter,  we  will 
address liveness  issues. 
In  modeling  the  single-lane  bridge,  we  use  the  following  constant  and 
range 
definitions: 
N = 3 
// n u ~ ~ e r  
of each type of car 
T = 0. N // type of car c
o
~
~
~
 
ID= 1 
m . 
N // car identities 
The  essence of the problem  is  access to the bridge, so the  only  events of interest in 
which  a  car 
~articipates are entering  the 
bridge and  leaving 
the bridge. 
~onsequently, a car  is  modeled  by  a  process 
that repeatedly enters and leaves 
the  bridge: 
CAR = (e~ter->exit->CAR). 
To model  the  fact that cars  cannot pass each  other  on  the  bridge,  we  require the 
following  processes  which  constrain 
the order of the  enter and exit  actions  respec- 
tively: 
NOPASSI = C [ 
1 ] ,  reserves entry  order 
C[i:ID] = ([i~.enter->C[i%~+l]). 
NOPASS2 = C [ 1 ] , 
//~reser~es 
exit  order 
C[i:ID] = ([i] 
.exit->C[i%N~l]). 
I lCONVOY = ([ID]:CARI 
lNOPASSll INOPASS2). 

The CONVOY process  models  a  set of cars  travelling  in  the  same  direction  that  enter 
the  bridge  one  after  the  other  and  leave  the  bridge 
one after  the  other.  However, 
it 
does  not  stop one  car  exiting  the  bridge  before  the  next  car  enters.  The  behavior  of 
all  cars  is  captured by the  following  composition: 
1 ICARS = (red:CONVOY I I b1ue:CONVOY). 
The  remaining  entity  that  must  be  modeled  is  the  bridge  itself.  This  must  constr
CARS so  that  although  one  or  more  cars  moving  in  the  same  direction  may be on 
the  bridge  concurrently,  cars  moving  in  different  directions  may  not.  To  enforce 
this,  the  bridge  maintains  a  count 
of blue  cars  on  the  bridge  and 
of red  cars  on  the 
bridge. Red  cars  are  only  allowed  to  enter  when  the  blue  count  is  zero  and  vice 
versa.  The  bridge  process  is  listed  below: 
BRIDGE = BRIDGE[ 01 [ 
01 , / / i n i t ~ ~ l ~ y  
empty 
BRIDGE[ nr  :T] 
[ 
nb:T] = 
/ /nr is the red count, nb the blue 
(~~~~ (nb==O) 
red[ID].enter -> BRIDGE[nr+l][n~] 
/red[ID].exit 
-> BRIDGE[nr-l][nb] 
blue[IDJ.enter->  BRIDGE[nr][nb+l] 
/blue[ID].exit -> BRIDGE[nr][nb-l~ 
1. 
Note  that  the  exit  actions  of  the  bridge  permit  the  car  counts, 
n  r 
and nb, to be 
decremented  even  though  their  value  is 
0. As described  in  Chapter 5, the FSP 
compiler  in  the LTSA tool  will  automatically map  these  undefined  states  to  the 
ERROR state,  indicating  this by issuing  warnings: 
~arning - BRIDGE.-I.O defined to  be ERROR 
Warning - BRIDGE.0.-1 defined to  be ERROR 
... 
In  fact,  when BRIDGE is  composed  with CARS, their  behavior  prevents  cars  which 
have  not  entered  from  exiting  and  the ERROR state  is  unreachable. 
Before  describing  the  overall  system  composition,  we  need  to  specify  a  safety 
property  to  compose  with  the  system  that  verifies  that  cars  do  not  collide  on  the 
bridge. The  required  property  is  listed  below. 
It specifies  that  while  red  cars  are  on
the  bridge  only  red  cars  can  enter  and  while  blue  cars  are  on  the  bridge  only  blu
cars  can  enter. When  the  bridge is empty,  either  a  red  car  or  a  blue  car  may  enter. 
The  index i 
is  used  to  count  the  red (or blue)  cars  currently  on  the  bridge. 

O ~ E ~ A Y  
=(red [ 
ID] . 
enter 
-> 
~blue[~D],enter 
-> 
1
9
 
(i>l) red[ID]  .e 
[ID].enter -3 
(i==l  )blue[  ID] 
(i>l) blue[  ID] 
1. 
The  entire  system  can  now 
be modeled by the  composite  process  specified  in 
Figure 7.5. 
I ISin~l~Lane~rid~e 
= (CA 
Figure 7.5 SingleLa 
Safety  analysis  using LTSA verifies  that  the O ~ E ~ A Y  
safety  property  is  not  vio- 
lated. 
However,  without  the  constraints  provided 
by the 
, 
the  composition 
( CARS I I O ~ E ~ A Y )  
yields  the  following  safety  violation: 
Trace  to  property  violation 
in O ~ E ~ A Y :  
red, 1 . 
enter 
blue. 1 .enter 
In  the  single-lane  bridge  problem, 
it is  reasonably  clear 
which are  the  active 
entities  and which are  the  passive  entities.  Gars  are ~ p l e ~ e n t e ~  
as Java  threads 
and  the  bridge  as  a  monitor. 
This leaves  the  model  entities ~ O ~ A S ~ l  
and ~
O
~

concerned  with c o n s ~ a i ~ g  
overta~ing. These  have  no  explicit  representation in 
the  implementation.  The overta~ing  cons~aint 
is  dealt  with in the 
class  which  displays  car  movement.  Figure 7.6 depicts  the  class  diagram  for  the 
program. 
Figure 7.6 Single-lane bridge class  diagram. 
An instance of the r i ~ ~ e ~ ~ n v ~ s  
class is created by th 
applet. A reference t it is passed  to each  newly  created 
object.  The  methods  provided by the 
~ ~ n v ~ s  
class  are  listed  in  Program 7.1. 
rogram 7.1 ~ r i ~ ~ e c a n v a s  
class. 

130 
C ~ a ~ t e r  
7: Safety and Liveness ~ro~erties 
" 
- ~- 
The  code  for  the two classes  representing  cars  is  listed  in  Program 
7.2. Each  car 
moves  until  it  is  about  to  enter  the  bridge.  It  then  requests  access  to  the  bridge 
by 
~vokingcontrol.redEnter() ifitisaredcarandcontrol. blueEnter() ifit 
is blue. When a  car  has  crossed  the  bridge, 
it invokes  the  appropriate Exit method. 
Program 7.2 RedCar and BlueCar classes. 

The  entry  and  exit  bridge  access  methods  are  provided  by  an  instance 
of the  class 
ridge or a class  derived  from ridge. Class B rid g e provides a null  implemen- 
tation  as  listed in  Program 7.3. '"his  enables  us to view  the  results of an  unsafe 
bridge ~plementation. 
Program '7.3 B r i d g e  class. 
' " h e ~ i n g ~ e L ~ n e  
ridge applet  class  creates  one, two or three  of  each  of  the  red 
and  blue  cars  depending on  which  button  is  clicked.  In  addition,  the  check  boxes 
select  an imple~entation of the  bridge  monitor.  Figure  7.7  depicts  the  conse- 
quences  of  using  the  null ~plementation of  Program  7.3. 
Figure 7.7 Single-lane  bridge display using B r i d g e  class. 
Clicking  the  Safe  check box creates a system  that  avoids  the  collisions  of  Figure 
7.7. It uses  the  class 
Safe ridge which is a direct  translation of the 
process  from  the  model.  Each  of  the  guarded  actions  from  the  model  becomes 
a 
conditionally  synchronized  method.  Since  this  has  been  modeled  and  shown  to 

132 
Chapter 7: Safety and 
 
Liveness 
~ r ~ e r ~ i e s
preserve  the O ~ E ~ A Y  
safety  property,  we  can  be  reasonably  confident  in  the  safety 
of the SafeBridge imple~entation. The  code  for  the  class  is  listed 
in Program '7.4. 
Program 7.4 Saf eBridge class. 
The  implementation of § a ~ e ~ r i ~ g e  
uses  conditional  notification.  We  only  wake 
up  waiting  threads  when  the  number 
of cars  on  the  bridge - 
either  red  or  blue - 
is 
decremented  to  zero.  This  avoids 
~ e c e s s a r y  
thread  switches  since  otherwise, 
blue  cars  would  be  woken  up  every  time 
a red  car  leaves  the  bridge  and  vice 
versa. It is  only  the  last  car of a  particular  color  to  leave  the  bridge  that  should 
wake  up  waiting  car  threads. 
§af  eBridge 
ensures  that  cars  do  not  collide  on  the  bridge;  however, 
it does  not 
ensure  that  cars  eventually  get  the 
o p p o r ~ ~ y  
to  cross  the  bridge.  With  three  cars 
of each. color, if a  red  car  crosses  the b ~ d g e  
first  there  is  always  a  red  car  on  the 
bridge and consequently, blue cars never get to cross. This situation is called 
s
~
~
~
~
~
~
~
~
~
a form  of  liveness  property  discussed  in  the  next  section. 

7.3 Liveness 
133 
A liveness  property  asserts  that  something  good  eventually  happens. 
A reason- 
able  liveness  property  for  the  single-lane  bridge  would 
be that  all  red  and  blue 
cars  eventually  get  to  cross  the  bridge. 
As we  have  seen,  the  program  developed  in 
the  previous  section  does  not  satisfy  this  property  in  the  situation  where  there  are 
three  cars  of  each  type.  In  this  section,  we  see  how  models  can 
be analyzed  for 
liveness.  Like  deadlock  and  other  safety  properties,  the  objective  is  to  solve  live- 
ness  problems  at  the  modeling  stage 
so that  they  do  not  occur  in  the  implemented 
program. 
A completely  general  treatment of liveness  is  rather  involved  and  requires  the 
use  of  a  temporal  logic  to  specify  the  required  liveness  properties.  Rather  than 
burden  the  reader  with  another  formalism,  we  deal  with  a  restricted  class 
of 
liveness  properties  which  we  term 
progress. A progress  property  asserts  that  what- 
ever  state  a  system  is  in, 
it is  always  the  case  that  a  specified  action  will  eventually
be executed.  Progress  is  the  opposite 
of s
~
~
~
~
~
~
~
o
~
,
 
the  name  given  to  a  concurrent- 
p r o g r a ~ i n g  
situation  in  which  an  action  is  never  executed.  Progress  properties 
are  simple  to  specify  and  are  sufficiently  powerful  to  capture  a  wide  range 
of 
liveness  problems  in  concurrent  programs. 
To illustrate  the  notion  of  progress, we  use  a  simple  example,  that 
of tossing  a 
coin.  The  model  is  depicted  in  Figure '7.8. 
toss 
tails 
COIN = { t o s s - ~ ~ e ~ ~ s - ~ C O I ~ ~ t o s s - ~ t ~ i l s - ~ C O I N ) .  
Figure 7.8 COIN model. 

134 
C ~ a ~ t e r  
7: Safety 
 
and 
 
Liveness 
~ r o ~ e r ~ i e s
If the  coin  were  tossed an infinite  number of times,  we  would  expect that heads 
would be  chosen  infinitely  often 
and that  tails  would  be  chosen  infinitely  often.  In
fact,  this depends on  the  scheduling  policy  used  to  decide  on  which  transition 
from  the  set of eligible  transitions should be  executed. If the  policy  is  not 
fair then 
we could  always  choose  the 
t o  s S transition  leading  to 
h  e 
ad s . We assume that the 
scheduling  policy  for  choice  is  fair as defined  in  the  following: 
ir Choice: If a  choice  over  a  set 
of transitions  is  executed  infinitely  often, 
n  every  transition in the  set  will  be  executed  infinitely  often. 
If the  transition  (or  transitions) of an action  occurs  infinitely  often in a  system,  we 
can  say  that it is  always  the  case at any  stage of the  execution that the  action  will 
eventually  occur.  With  the  assumption 
of fair  choice then the  coin-tossing  system 
should eventually  choose heads and eventually  choose  tails. We can  assert  this 
with progress  properties  specified in FSP. A progress property is  defined  by: 
In  other  words,  a  progress property asserts  that at any  stage of execution  one of 
the  actions in the  progress  set  will  eventually  occur. 
The  liveness  requirement  for 
coin  tossing  can  now  be  expressed  as: 
HEADS = (heads) 
TAILS = ( t a i l s }  
The CO I N  system  we  have  defined 
so far  satisfies  these  properties. We now  exam- 
ine a system  that  does not. Suppose that the  agent  which  tosses  the  coin  first  pick
one of two coins:  a  normal  coin 
with a  head and a  tail as defined in Figure '7.8 and 
a  trick  coin  which has a  head  on  both  sides. 
'The outcome of tossing  the  trick  coin 
must  always  be heads. This  system  is  modeled  in  Figure 17.9. 
Progress  analysis of the T ~ O C O I ~  
system  against  the  progress  properties 
HEADS 
and TAILS produces  the  following output: 
Progress  violation:  TAILS 
Path  to  terminal  set 
of states: 
pick 
Actions  in  terminal  set: 
(toss,  heads} 

7.3 ~ i ~ e ~ e s s  
135 
pick 
toss 
heads 
T~OCOIN = (pick->COINlpick->T~ICK), 
TRICK 
= (toss->heads->TRICK), 
COIN 
= ( t o s s - ~ h ~ a d s - ~ C O I N ~ t o s s - ~ t a i l s - ~ C O I N ) I  
Figure 7.9 T ~ O C O I ~  
model. 
This  confirms  the  expected  result: if the  agent  picks  the  trick  coin  then  the  action 
t a i l s  will  never  occur.  This  is  of  course  a  violation of the TA1  LS 
progress  prop- 
erty,  which  asserts  that in an  infinite  execution,  tails  must  occur  infinitely  often. 
The  reader  should  note  that  the  system  of  Figure 7.9 does  not  violate  the  progress 
property: 
H E A ~ S o r T A ~ L ~  
= {headsJails} 
Property H E ~ ~ S o r T A I   L S  
is  not  violated  since  only  one 
of the  actions in the 
progress  set  need be executed  infinitely  often  to  satisfy  the  property. 
Progress  analysis  involves  first  performing  a  search  for  t  rminal  sets  of  states. 
A terminal  set of states  is  one in  which  every  state  is  reachable 
from every 
other  state  in  the  set  via  one  or  more  transitions  and  there  is  no  transition 
from  within  the  set to any  state  outside  the  set. 

136 
C ~ a ~ t e r  
7: Safety and ~iveness 
 
Pr~erties 
In graph  theory,  this is  own as  a  strongly  connected  component,  which  has  no 
path  to  any  nodes  outside  the  set of nodes  in  the  component.  For  example,  the 
labeled  transition  system of Figure 7.9 has  two  terminal  sets of states, {1,2}, which 
are  the  states  relating  to  the  trick  coin,  and {3,4,5}, which are  the  states  relating  to 
the  normal  coin. 
h 
execution of a  system  represented by a  finite  set of states  can only be infinite 
if some  of  the  states  are  visited 
~ n i t e l y  
often. The states  that  are  visited 
~ n i t e l y  
often  in  an  execution  must  form  a  terminal  set.  Given  fair  choice,  each  terminal  s
of  states  represents  an  execution in which  each  transition  in  the  set  is  executed 
infinitely  often.  Since  there  is  no  transition  out 
of a  terminal  set,  any  action  that  is 
not  used  in all terminal  sets  cannot  occur  infinitely  often  in  all  executions of the 
system.  Checking  that  a  progress  property  holds  is  now  simply  checking  that  in 
each  terminal  set, at least  one of the  actions  in  the  progress  set  occurs  as  a  transi- 
tion.  Conversely,  a  progress  property  is  violated 
if analysis  finds  a  terminal  set of 
states in  which  none of the  progress  set  actions  appear.  For  the TA1 LS property, 
this  terminal  set  is  the  set 
of states { 1,2) in  which  the  action t a i l s  does  not  occur. 
The  output  gives  the  shortest  execution  path  to  the  root  of  the  terminal  set  and 
lists  the  actions  that  do  appear in the  set. 
If  no  progress  properties  are  specified, 
LTSA performs  pr  ess  analysis  using  a 
~
e
~
~
~
2
~
 
~
~
~
~
e
~
~
~
.
This  property  asserts  that  for  every  action  the  alphabet 
of the 
target  system,  given  fair  choice,  that  acti  will be executed  infinitely often, This  is 
equivalent  to  specifying  a  separate  pr  ess  property  for  every  action.  For  the 
T ~ O ~ O I  
N system,  this  default  analysis  produces  the  followi 
P r o ~ r e s s   v i o l a t i o n   f o r   a c t i o n s :  
(pick) 
Path  to  terminal 
set of  states: 
Actions  in  terminal  set: 
(toss,  heads,  tails} 
pick 
Progress  violation  for  actions: 
Path  to  terminal 
s e t  of  states: 
pick 
Actions  in  terminal  set: 
(toss,  heads) 
The  analysis  produces two progress  violations  since  the  action pick is  not  exe- 
cuted  infinitely  often  in  either  terminal  set.  The  value of this  default  property  is 
that, if it  is  not  violated,  then  no  specified  progress  properties  can be violated.  In 
other  words,  if  the defau~t property  holds,  then  every  other  progress  property, 

7.3 ~ i v e ~ e s s  
137 
specified  in  terms of subsets of the  action  alphabet of a  target  system,  must  also 
hold. This  is true since  the  default  property  asserts  that  every  action  is  executed 
infinitely  often. All systems  in  which  the  states  occur  inside  a  single  terminal  set 
satisfy  the  default  progress  property. 
If default  progress  analysis  is  applied  to  the  single-lane  bridge  model  then  no 
violations  are  detected.  However,  we  know  from  the 
imp~ementation that  it is 
possible  for  progress  violations to occur.  Either  the  blue  cars  or  the  red  cars  may 
wait  forever  to  cross  the  bridge.  Why do we  not  detect  these  progress  problems? 
The answer  lies  in  the  fair  choice  assumption  underlying  the  progress  test.  Thi
means  that  every  possible  execution of the  system  will  eventually happen includ- 
ing  those  in  which  cars 
do not  starve. To detect  progress  problems  we  must 
superimpose  some  scheduling  policy  for  actions,  which  models  the  situation  in 
which  the  bridge  is  heavily  used,  i.e.  we  need  to  impose  adverse  conditions  wh
"stress-test"  the  system.  We  use  action 
priority  expressions  to  describe  these 
scheduling  policies.  Action  priority  is  specified  in 
ESP with  respect  to  process 
compositions. 
1 I C = (P I I Q) <<(al , 
. 
. , 
a,) 
specifies  a  composition  in  which  the 
actions at , . . . , 
a, have  higher  priority than any  other  action  in  the  alpha- 
bet of P I Q including  the  silent  action tau. In  any choice  in  this  system 
which has one  or  more of the  actions al , . . 
11 a, labeling  a  transition,  the 
transitions  labeled  with  lower  priority  actions  are  discarded. 
I I C =: (P I I Q) >>(a1 , 
. . . , 
a,) 
specifies  a  composition  in  which  the 
actions al , 
. . . a, have  lower  priority than any  other  action  in  the  alpha- 
bet of P 1 I Q including  the  silent  action tau . 
In  any choice  in  this  system 
which  has  one  or  more  transitions  not  labeled  by al 
)I . . a,, 
the  transi- 
tions  labeled  by al , . . . , 
a, are  discarded. 
Action  priority  operators  simplify  the  composite  processes  by  discarding  particu- 
lar  transitions.  Figure 
7.10 illustrates  the effect  for  a  simple  example.  When 
WO r 
k is 

138 
C ~ p t e r  
7: Safety and 
 
Liveness 
Pr~perties 
specified  to be a  high  priority  action  in  the  composition 
H I GH, the sleep transition 
disappears  since it is  lower  priority  and  consequently  in  a  choice  between sleep 
and WO r 
k, wo r 
k will  always be chosen. When  work  is  specified  to 
be a  low  priority 
action  in  the  composition LOW, the work transition  disappears  since  it  is  lower 
priority  and  consequently 
in a choice between 
sleep and wo r 
h, sleep will 
always  be  chosen. 
sleep 
work 
sleep 
NOR~AL 
= (work->play->NORMALIsleep->play->NORMAL). 
I IHIGH = (NO~~AL)cc{work}. 
I ILOW = (NORMAL)>>{work}. 
Figure 7.10 Action priority. 
Using  progress  properties  and  action  priorities,  we  are  now  in  a  position  to  inv
tigate  the  liveness  problems of the  single-lane  bridge.  In  particular, we are  inter- 
ested  in  the  following  two  progress  properties 
when  the  bridge  is  heavily  loaded 
or  congested. 
ress BLUECROSS = {~lue[ID].enter} 
REDCROSS = {re~[ID].enter~ 

7.4 Liveness of the Single-La~e Bridge 
139 
BLUECROSS asserts that it is always the case that one of the blue cars  will  be  able 
to 
enter  the  bridge; REDCROSS asserts the same  for red cars.  This  leaves the problem 
of how to model  congestion  using  action 
priority. If we give  all the actions  related 
to red cars priority over blue cars  we  get  the 
situation where BLUECROSS is 
violated and similarly if we give blue cars priority REDCROSS is violated, 
Neither of these  scheduling  policies are good  models of the program. Neither 
red nor blue cars have priority in the ~plementation. Instead,  we  give  car  exit 
from  the bridge low priority. This  models the situation where  the bridge is  con- 
gested  since in any choice  between another car entering the bridge and a  car 
leaving the bridge, we choose to let  a  car enter. The  congested bridge is  modeled 
by: 
I lCongestedBridge = (SingleLaneBridge) 
> > ~ r e ~ [ ~ D ] . e x i t , b l u e [ I ~ ~ . e x i t } ~  
Progress  analysis of this system against the properties BLUECROSS and REDCROSS 
produces the following output: 
Progress violation: BLUECROSS 
Path  to  terminal 
set of states: 
red. 1 .enter 
red.2.enter 
Actions  in  terminal set: 
{red. 1 .enter,  red1  .exit, 
red .2. 
enter, 
red.2.exit,  red.3.enter,  red.3.exit) 
Progress violation: REDCROSS 
Path to terminal set of states: 
blue. 1 enter 
blue.2.enter 
Actions in terminal set: 
{blueAenter, blue.l.exit,  blue.2.enter, 
blue.2.exit,  blue.3.enter,  blue.3.exit) 
The output corresponds with observations of the program. When there are three 
cars  and a red car enters first then the bridge is  continuously  occupied  by red cars 
and blue cars  never  cross. SiMlilarly, red cars  never  cross if a blue car enters first. 
However, the model abstracts from  a  number 
of program details such as the 
length of the bridge and  consequently, the number of cars  needed to continuously 
occupy it. As a  result, the model  detects  lack of progress when there are only  two 
cars  moving in each  direction.  The  ternxinal  sets 
of states for this scenario  can 
clearly  be  seen in the  transition  system depicted in Figure 7.11. 

140 
C ~ p ~ e r  
7: Safety and ~ i v e ~ e s s  
Pro~er~ies 
red.1  .enter 
blue.1 
 
.enter 
 
blue.2.enter 
 
blue.1 
 
.exit 
 
blue.1 
 
.enter 
 
red.2.enter 
 
red.1 
 
.exit 
 
red.1 
 
.enter 
blue.2.exit 
 
red
Figure 7.11 ~ongestedBridge model with two cars. 
When  there  is  only 
one car  moving  in  each  direction,  the  bridge  does  not 
become  congested  and  both  red  and  blue  car  make  progress.  The  transition  syst
for  the  one  car  scenario  is  depicted  in  Figure 7.12. 
red.1  .enter 
red.1  .exit 
Figure 7.12 ~ongestedBridge model with one car. 
Will we  receive  the  same  progress  results if we  instead  model  congestion by 
giving  car entry to  the  bridge high priority?  The  interested  reader  should  check  tha
this  is  indeed  the  case. 
What  we  must  now  do  is  devise  a  model  which  does  not  exhibit  progress 
problems  when  there  is  more  than  one  car  moving  in  each  direction. 

7.4 ~ i v ~ e ~ s  
of the S i ~ g l e - ~ ~ e  
 
~ r j ~ g e  
141 
A bridge which  decides d ~ a ~ c a l l y  
at any  given point whether to admit blue cars 
or  red  cars needs to have more  orm mat ion about the state of cars than is currently 
available in the  model. In particular,  the bridge needs to know whether cars are 
waiting to cross. To this end, the  model  for  a  car  is  modified so that it requests 
access to the bridge before a t t e m p ~ g  
to enter. The  revised  model  for  a  car 
is: 
CAR = (request->enter->exit->CAR). 
The bridge model  can  now  count the number of cars waiting at each end. The 
count is  incremented  when  a  car  requests  access  and  decremented  when the car 
enters the bridge. Our  first attempt at a  revised BRIDGE process  uses this count of 
waiting cars as follows.  Red  cars are only  allowed to enter the bridge if there are 
no blue cars  on  the bridge and there are no blue cars waiting. Blue  cars are only 
allowed to enter  the bridge if there are no red cars  on the bridge and no red cars 
waiting to enter  the bridge. The  revised BRIDG€ process  is as follows: 
/* nr - n u ~ ~ e r  
of red  cars on the ~ r l d ~ e  
nb - n u ~ ~ e r  
of ~
~
u
e
 
cars on the ~ r l d ~ e  
wr - n u ~ ~ e r  
of red  cars ~
~
l
t
~
n
~
 
to  enter 
wb - n u ~ ~ e r  
of ~
~
u
e
 
cars ~ a l t i n ~   t o   e n t ~ r  
*I 
R I D ~ E  
= ~RIDGE[Q][O~[Q][Q]~ 
~I~~E[nr:T~[nb:T][wr:T 
(red[ID].request -> 
][nb][wr+l][wb] 
I 
(nb==O && wb==O) 
red[ID].enter 
-> BRIDGE[nr+l][nb][wr-l][wb] 
lred[ID].exit 
-> BRID~E[nr-l][nb][~r][wb] 
R ~ D ~ E [  
nr] [ 
nb]  [wr] 
[wb+l ] 
RIDG€[nr]  [nb+l]  [wr]  [wb-l] 
RID~€[nr] 
[nb-l]  [wr]  [wb] 
The  problem with this model  is that when  we check the safety properties of the 
new ~in~leLaneBrid~e 
system,  a  deadlock  is reported: 
red. 1 . 
request 
red.2.reques-t 
red.3.request 
blue. l request 
blue.2.request 
blue. 3. request 

142 
C ~ u ~ t e r  
7: Safety and Liveness Pro~er~ies 
The trace  is  the  scenario  in which there  are  cars  waiting  at  both  ends,  and  conse- 
quently,  the  bridge  does  not  allow  either  red  or  blue  cars  to  enter.  To  solve  this 
problem, we  must  introduce  some ~
s
~
~
~
e
into  the  problem (as was  done  for 
the  Dining  Philosophers  in  Chapter 6). This  takes  the form of a boolean  variable 
(bt) which  indicates  whether it is  the  turn  of  blue  cars  or  red  cars 
to enter  the 
bridge.  Initially, bt is  set  to  true  indicating it is  blue’s  turn. As soon as  a  blue  car 
exits  the  bridge, bt is set to false.  hen a red  car  exits, bt is  set to true  again.  The 
BR I DGE process  becomes: 
True = 1 
False = 0 
range B = False..True 
I* nr I n u ~ b e r   o f   r e d   c a r s  on the  bridge 
nb - n u ~ b e r  of blue  cars on the  brldge 
wr - n u ~ b e r  o f  red  cars ~ a i t ~ n g   t o  
enter 
wb - nu~ber  of  blue  cars  waiting  to  enter 
bt - true  indicates  blue  turn, 
false  indicates  red  turn 
* I  
B R I D G ~  
= BRIDGE[O][O]~O][O][True], 
BRIDGElnr:T][nb:T]lwr:T]lwb:T][bt:~] = 
(nb==O && (wb==Ol I !bt)) 
ID].request ->6R~DGElnr~[nb]~wr+l][~b][bt] 
red[ID].enter ->6RIDGE[nr+i][nb][wr-i][wb][bt] 
~ r e ~ ~ I D ] . e x i t  ->BRIDGE[nr-l][nb]~wr][wb]~True] 
Iblue[lD].request->BRIDGE[nr][nbl[wrl[wr][wb+l][bt] 
en (nr==O && (wr==Ol /bt)) 
blue[ID].enter ->BRIDGE[nr][nb+i]~wr][wb-i]~bt] 
/bluelID].exit 
->BRIDGE[nr][nb-i][wr][wb][False] 
The  condition  under  which  the  bridge  permits  a  red  car  to  enter  is  that  there  are 
blue cars  on  the  bridge  and  either  there  are  no  blue  cars  waiting  or 
it is  not  blue’s 
turn: nb==O && (wb==O 1 / ! 
bt ) . The  condition  for  a  blue  car  to  enter  is  that  there 
are no red  cars  on  the  bridge  and  either  there  are  no  red  cars 
w a i t ~ g  
or  it  is  blue’s 
turn: nr==O && (wr==O 1 I bt ). 
This  corrected  model  no  longer  deadlocks.  Further,  a  progress  analysis  reports 
that BLUECROSS and REDCROSS properties  are  not  violated. 
The  revision to the  program  involves  a  new  version of the  bridge  monitor  which 
implements  precisely  the BRIDGE process  from  the  model  developed  in  the  last 

7.4 ~ i v e ~ e s s  
of the S i ~ g l e - ~ u ~ ~  
Bridge 
143 
section.  In  fact,  we do not need  to introdu~e a new monitor  method to implement 
the request action made by  cars.  The  existing  enter  methods  can  be  modified  to 
increment  a wait count  before  testing  whether  or  not  the  caller  can  access  the 
bridge. As before,  the  tests are simply  the  negation of the guards in the  model 
BRIDGE process.  The  new ~plementation is  listed in Program 7.5. 
h the  demonstration  applet,  this  implementation of the  monitor  is  used when 
ir check  box  is  clicked. 
Program 7.5 FairBridge class. 

144 
~
~
a
~
t
e
~
 
7: Safety and Liveness   roper ties 
The  Readers-Writers  problem  is  concerned  with  access  to  a  shared  database 
by 
two kinds of processes.  Readers  execute transac~ons that  examine  the  database 
while  Writers  both  examine  and  update  the  database.  For  the  database  to 
be 
updated  correctly,  Writers  must  have  exclusive  access  to  the  database  while 
they  are  updating 
it. If no  Writer  is  accessing  the  database,  any  number 
of 
Readers  may  concurrently  access it. h this  section,  we  develop  a  solution  to  the 
problem.  As  usual,  we  construct  a  model 
of the  problem  to  examine  its  safety  and 
liveness  properties  before  proceeding  to a n  implementa~on. 
In  modeling  the  problem,  the  first  step  is  to  decide  on  the  actions 
of interest. "hese 
are ~cquirin~ 
and  releasin  read  access to the  shared  database  and ac~uiring and 
releasing  write access, The  actions  are  declared  below as the  set 
Actions = {acquire ead,releaseRea~, 
a c q u i r e ~ r i t e , r e l e a s e ~ r i ~ e }  
As for  the O~amental 
Garden  model in section 4.1.2, we  use  a  set  constant  simply 
as  a  way of abbreviating  the  model  description.  The  processes  that  model  Readers 
and  Writers  are: 
ADER = 
(acquireRead->examine->releaseRead->R 
+Actions 
 examine^. 
~
R
~
T
E
~
 
= 
(aCquireWrite->modify->releaseWrite->W 
+Actions 
\{modify}. 
process  must  acquire  read  access  before  exa  the  database  and  a 
ust  acquire  write  access  before  modifying  the 
se, "he alphabets of 
both  processes  have  been  defined  to 
be the full set of access  actions by the  alpha- 
bet  extension +Act ion s. This  ensures  that  while  a READER only  engages  in  the 
acquireReadandreleaseReadactionstheacquire\l\lriteandreleaseWrite 
actions  cannot  occur  freely for any  prefixed  instance  of  the  process.  Similarly,  for 
processes,  the a c q u i 
re ead and relea~eRea actions  cannot  occur 

7.5 R e a ~ e r s - ~ r i t ~ ~ s  
~ r o ~ l e ~  
145 
xamin e and mod i f  y actions  are  hidden  since  they  are  irrelevant  to 
Access  to  the  shared  database  is  controlled 
by a  read/write  lock.  The  lock 
Read actions when it has  not  been  acquired  for  write  access by 
acqu i rewrit e. It permits  only  a  single  write  access  when 
it has  not  been 
acq~ired for  read  access.  The  lock  is  modeled by the RW-LOCK process: 
the  problem  of synchro~zing access  to  the  shared  database. 
W-LOCK 
= R ~ [ O ] [ F a l s e ] ,  
0 e Nread ] [writing : 
 writing) 
acquireRead - > R ~ [ r e a d e r s + i ~ [ w r i t i ~ g ]  
aseRead 
->RW[readers-l~[writing~ 
(readers==0 && !writing) 
acquireWrite->R~[readers][Tr~e~ 
~ r ~ l e ~ s e w r i t e  
->R~[readers][False] 
W-LOC~ process  maintains  a  count of the  number  of  concurrent  read  accesses 
(readers) and  a  boolean (writing) which  is  set  to  true  when  the  lock 
is acquired 
for  write  access.  The  action  to  acquire  read  access 
is only  accepted  when writing 
is  false  and  the  action  to  acquire  write  access  is  only  accepted  when 
reade rs==O 
and ~ r i t i n g  
is  false. 
To check  that  the  lock  behaves  as  desired  we  define  a  safety  property, 
RW-SAFE, as 
follows: 

146 
C ~ ~ p ~ e r  
7: Safety and ~iver~ess 
~ r o p ~ r ~ i e s  
action  or  an 
for  either  read  or  write  access. 
 hen a c ~ ~ i r e d  
for  read  access 
\ 
acquir 

writer[l ..Nwrite]: 
WRITER 
= (reader [ 
1 . . 
Nread] :READ 
I l w r i t e r [ l . . N w r i t e ~ : ~ R  
ader[l  .Nread], 
writer[l,.Nwrit 
igure '7.14 
~ E ~ D E ~ S - ~ ~ I T E ~ S  
model. 
The progress  properties  that  are  important in the  Readers-Writers  system  are  that 
both  Readers  and  Writers  should  eventually  acquire  access  to  the  shared  database.
~e  can  express  the  required  progress  properties  as  follows: 
= (writer f l . . 
Nwrite] . 
a c q u i r e ~ r i t e }  
= {reader~~..Nread].ac~uire~ead} 
property  asserts  that  it  should  always  be  the  case  that  at  least  one  of 
processes  can  perform  an a c q u i r e ~ r i t e  
action.  Since ~ 
e  can  reasonable  expect  that  if  one  can 
acq 
D specifies  the  same  property  for 
READER processes  and 
check  reports  no  violations  of  these  properties in the 
ITERS. Because  of  the  fair  choice  assumption, 
progress  problems  only  occur  in  complete  system  models  that  are  erroneous. To 
find  how  the  system  performs  when  loaded  or  "stressed",  we  must  specify 
adverse  scheduling  conditions  using  action  priority.  This  is  exactly  the  procedure 
we  adopted  to  find  the  progress  problems  in  the  single-lane  bridge  model.  Indeed, 
the  adverse  conditions  are  similar  to  those  used  in  the  bridge  problem.  To  model  
heavily-load~d system,  we  give  lower  priority  to 
r e   l e a s  
e actions in the  same 
way  we  gave  lower  priority  to e x i t  actions in the  bridge  problem. (~lte~atively, 
we  could  give  higher  priority  to  the 
acquire actions.) The  system  model  used  for 
progress  analysis  is  described  by: 

148 
C ~ p t e r  
7: Safety 
 
and 
~ i v e ~ e s s  
Properties 
Analysis of this  system  leads  to  the  violation: 
Progress  violation:  WRITE 
Path  to  terminal 
set of states: 
reader.1.acquireRead 
Actions  in  terminal 
set: 
(reader. 1 acquireRead, reader. 
1 . 
releaseRead, 
reader,2,acquireRead, reader.2.releaseRead~ 
The violation  describes  the  scenario in which  writers  cannot  access  the  shared 
database  because  a  reader  always  has  read  access. 
In other  words,  the  number 
of  Readers  never  drops 
to zero and consequently, the read/write lock denies 
access  to  Writers.  The  terminal  set 
of states  that  describes  this  behavior  can  clearly 
be seen  in  Figure 7.15. It contains  the  states nmbered 3,4 and 5. Before  exploring 
solutions  to  this  progress  problem,  we  translate  the  existing  model 
into an imple- 
mentation in the  next  section. 
In the  interests  of  brevity,  we  describe  only  the  monitor  that  synchronizes  the 
accesses of Readers  and  Writers  to  a  shared  database.  This 
s~chroni~ation 
is 
the  essence of the  problem.  In  the  same  way  that  we  defined  the  set 
of actions 
of interest  in  the  Readers-Writers  model,  we  define  an  interface  that  identifies  the 
monitor  methods  that  must  be  implemented.  In  the  sections  that  follow,  we 
develop  a nmber of alternative implemen~atio~ 
of  this  interface.  The  interface 
is  listed in Program 7.6. 
Program 7.6 R e a d ~ r i t ~  
interface. 


150 
Clza~~er 
7: Safety and ~ i ~ e n e s s  
 ropert ties 
Each method  in  the ReadWr i t e interface  corresponds  directly  to  the  action 
of the 
same  name in the  model. Our first i~ple~entation 
of 
dWr it e, which  corre- 
sponds exactly  to  the ~ W - L O ~ ~  
process  from  the  model,  is  listed  in  Pro 
Program 7.7 Read~riteSaf  e 
class. 
The guarded actions  from  the  model  become  synchronized  methods c o n t a ~ g  
waits.  However, in the  implementation,  we  must  decide 
on notification  to awake 
threads blocked in waits. The simple  solution, as discussed in Chapter 5, is  to 
include  a  call  to not if y A l l  ( ) in  every  monitor  method 
that modifies  the state of 
the  monitor.  However,  this  can  lead  to  unnecessary  thread  switches. 
In the 
R e a ~ ~ r i t e S ~ f  
e monitor,  notification  is  required  only  when  the  last  Reader has 
relinquished  access and when a  Writer  releases.  When  the  last  Reader  calls 
r e l e a s e R e a ~ ( )  (i.e. readers==O), notify() rather than notifyAll( )can be 
used  since  only  Writers  can  be  waiting 
and it  is  only  necessary  to  unblock 
a single 
Writer.  When  a  Writer  is  finished it calls re  le  as 
eWr it e ( ) which  then  calls 
not if yAl1 ( ) . This  is  because it may  be  necessary  to  unblock  either  one  or 
more  Readers  or  a  Writer. 

igure 7.16 Readers-Writers applet display. 
To address the pro ress  problem  discovered with our first  model  and  i 
tation of the Readers-Writers  lem,  we 
adopt an appr~ach in  which  Readers 
are denied access if there are 
to acquire  access.  This 
should give 
Writers priority in acquiring  the  lo 
id the si~ation 
in which  they wait 
forever  for  access. To detect that a Writer  is waiting for  access, we  must add 
another action to its repertoire. A Writer  must  request  access  before attempt~g 
to acquire it. This  is  exactly  the  same 
solution we adopted in the 
solution to  detect 
whether cars  were 
waiting. The add 
Writ  e 
and  the  revised W 
R process  is  shown  below: 

152 
C ~ a ~ ~ e r  
7: Safety 
 
and 
 
Liveness 
  roper ties 
ADER process  remains  unchanged. 
RW-LOC~ is  modified  to  maintain  a 
count of waiting  Writers (wait  ingW). 
The  count  is  incremented  when  a  Writer 
requests  access  and  decremented  when 
it actually  acquires  access.  Readers  are 
only  allowed  to  acquire  the  lock  when  the  number  of  waiting  Writers  is  zero. 
The  revised  lock  process  is  listed.  below: 
RW-LOCK = RW[O][False][O], 
RW[readers:O. Aread] 
[writing : 
60011 
~waitingW:O..~write~ 
= 
n (!writing && waiting~==O) 
cquireRead -> RW[readers+l][writing][waitin~W] 
aseRead 
-> RW[readers-l][writing][waitingW] 
quirewrite-> R~[readers][True][waitin 
(readers==O && !writing) 
Ireleasewrite -> RW[readers][False] 
Irequestwrite -> RW[rea~ers][writin 
This  definition  of RW-LOCK still  satisfies  the W-SAFE property.  Note  that we  have 
not  had  to  change  the  definition 
of the  safety  property. 
The  request  action 
(request 
Wr it  e) 
is  not  relevant  to  the  safe  operation 
of the  lock  and so does 
not  appear  in  the  alphabet 
of the  safety  property.  Safety  is  ete ermined only by 
the  correct  sequencing of acquire  and  release  actions. 
A progress  analysis of RW-PRO~R SS now  produces  the  output: 
Progress violation: READ 
Path to ter~inal 
set of states: 
writer. 1 . 
requestwrite 
w~iter.~"requestWrite 
Actions in ter~inal 
set: 
~~riter.l.requestWrite,  writer.l.acquireW~ite, 
writer.l.releaseWrite,  writer. 
w~iter~~.acquireWrite, 
writer.2 
We no  longer  have  a  violation of the WRIT property,  demonstrating  that in &is 
Writers  priority  system,  Writers  can  always  access  the  shared  database.  Howeve
we  now  have  a 
READ progress  violation.  This  occurs  since, if there  is  always  a 
Writer  waiting  to  acquire  the  lock,  then  Readers  will  never  gain  access.  However, 
in the  practical  application of read/write  locks,  the Writ~rs priority  solution  is 
often  satisfactory  since  there  are  usually  many  more  read  accesses  to  a  database 
than  write  accesses.  In  addition,  it  may 
be ~ ~ o r t a n t  
that  Readers  get  the  most  up- 

to-date  information.  '"he 
~plementation of a  Writers  priority  lock  is  listed 
in 
Program 7.8. It  follows  directly  from  the  revised  definition  of RW-LO~~. 
Program 7.8 R e a ~ ~ r i t e P r i o ~ i t y  
class. 
A version of the readlwrite lock  that 
S 
h the READ and WR I "E proper- 
ties  involves  the  addition 
of a  boolean  ates 
-whether  it is  the  Readers' 
turn or  the  Writers' 
turn. Readers o 
aiti-qj Writers -when it is not 
their  turn  to  acquire  the  lock.  This  lays  exactly  the  same  role 
.h 
the 
 
Readers-Writers 
 
problem 
as th 
the 
 
single-lane 
 
bridge. 
 
The 
final  version of the  read/write  lock model is  listed  below.  The ~plementation is 
left  as  an  exercise. 

154 
C~apter 7: Safety and ~iveness ~roper~ies 
]  writi in^]   itin in^^] [False] 
True] [ ~ ~ i t i n ~ ~ - i ]  
[ r~a~ersturn] 
False] ~
w
~
i
t
~
n
~
~
]
 
[True] 
~ r e ~ u e § t ~ r ~ t e  
- > ~ ~ ~ r e a ~ e r s ] ~ w r i t i n ~ ] [ w a i t i n ~ ~ + i ] ~ r e a ~ e
)
m
 
A safety property  asserts  that  nothing  bad  happens  during  the  execution  of  a 
program  and  a Z~~e~ess 
property  asserts  that  somethin  od  eventually  happens. 
In  this  chapter,  we  described  how FSP models  can  be  ked 
for both  safety  and 
liveness  properties. 
A safety  property  is  defined 
by a determi~stic process 
P. This 
asserts  that  any  trace 
incl~ding actions in the  a  abet 
of P is  accepted by P 
When  the  property P is  composed  with  a  system  traces 
of actions  that  are  in 
the  alphabet of S and  the  alphabet of P must  also  b  lid  traces  of 
P, otherwise  the 
error  state  is  reachable.  Consequently, if safety  analysis  does  not  detect an  error 
state, we  know that  the  property  holds for  the  system. 
We  defined a subset of liveness  properties  which  we  termed 
progress properties. 
A progress  property  is  defined by a  ress  set 
of action  labels.  It  asserts  that in 
any  infinite  execution of a  system,  one  of  the  actions  in  the  progress  set  must 
happen  in.finitely  often. h asserting  progress, it is  necessary  to  make  some  sche- 
duling  assumptions  as  to  which  transitions  are  chosen  for  execution.  We  assume 
fair  choice  for  a  set of transitions  such  that if the  set  is  executed  infinitely  often, 
then  every  transition in the  set  will be executed  infinitely  often. To investigate  the 
liveness  problems  that  occurred 
in our  example  programs,  we  introduced  a  way 
of 
specifying  action  priority  that  let  us  superirnpose  a  specific  scheduling  policy  on 
fair  choice.  This  enabled  us  to  model  adverse  situations 
in which  processes 
compete  for  scarce  resources. 
The  example  programs  developed  in  this  chapter  had  a  fixed  set  of  threads 
competing  for  a  resource.  In  Chapter 9, we  examine  systems in. which  the  size of 
the  set  varies  as  threads  are d ~ a ~ c a l l y  
created  and  terminated. 

Exercises 
155 
The  terms safety and l i ~ e ~ e s s  
applied  to  concurrent  programs 
were  first  introduced 
by Lamport  (1977).  In  this  book,  we  have  adopted  a  modeling  approach  to  reason
ing  about  concurrent  pro  rams  and  consequently  a 
~odel-checking approach  to 
verifying prope~ties. As discussed  at  the  end of Chapter 5, an alternative  approach 
is  to  reason  about  safety  properties of concurrent  programs  using  assertions  and 
invariants  specified  in  predicate  logic.  The  reader  should  consult  Greg  Andrews’ 
book  (1991) for  an extensive  exposition  of  this  approach. 
The  mechanisms  used  in  this  chapter  for  checking  safety  and  progress  proper- 
ties  have  been  developed by the  authors and  their  colleagues.  The  safety  property 
technique  is  due  to  Cheung  and  Kramer  (1999).  Progress  checking  as  described 
here  is  due  to ~iamakopoulou, Magee  and  Kramer  (1998)  and  is  a  simplified  form 
of a  more  general  technique  for  checking  that  properties  specified  in  Linear 
Temporal  Logic  (LTL)  hold  for  a  system.  The  property  that  our  approach  checks 
is  that  an  action  always  eventually  occurs. As an  LTL,  formula,  this is  specified as 
nOa, where 
means  always  and 0 means  eventually.  The  general  technique 
involves  translating  LTL  formula  into  Buchi  automata  and  then  composing  the 
Buchi auto~ata with  the  target  system  and  performing  a  connected  component 
analysis  of  the  resulting  automata  (Gribomont  and  Wolper,  1989).  Technically,  th
is  a check that  the  system  is  a  valid  model  of  the  formula 
- 
the  origin of the  term 
~~~e~ 
c~ec~i~g, 
which  we have used  in  the  looser  sense  to  refer  to  any  technique  for 
analyzing  models.  Buchi  automata  are  a  form  of  finite  state  automata  which 
recognize  infinite  sequences 
of actions. The  interested  reader  should  look  at 
Holzmam’s SPIN model  checker 
(Holzmam, 1991,  1997)  which  uses  this 
approach.  The  pioneering  work on  model  checking  is  due  to  Clarke,  Emerson 
and  Sistla  (1986). 
The  topic  of  fairness 
in concurrent  programs  has  an  extensive  literature.  We 
have  used  a  strong  form  of  fair  choice.  For  an  extensive  discussion  on  the  differen
classes of fairness,  see  the  book by Francez  (1986). 
7.1 What  action  trace  violates  the follow in^ safety property? 
7.2 A lift has  a  maximum  capacity of ten  people. In the  model of the  lift  control  system, 
passengers  entering  a  lift 
are signaled by an en t e r action  and  passengers  leaving  the 
lift are  signaled by an exit action.  Specify  a  safety  property h 
FSP which  when 
composed  with  the  lift  will  check  that  the  system  never  allows 
the lift that  it  controls  to 
have  more  than  ten  occupants. 

156 
Chapter 7: Safety and ~iveness 
P~operties 
7.3  Specify a  safety  property  for  the  car  park  problem 
of Chapter 5, which  asserts that the 
car park does  not  overflow.  Specify  a  progress  property  which  asserts  that  cars  even- 
tually  enter  the  car 
park. If car departure is  lower  priority  than  car  arrival,  does 
starvation  occur? 
7.4 In an operating  system,  a  binary  semaphore  is  used to control  access  to  the  console. 
The  console  is  used  by  user  processes 
and system  processes.  Construct  a  model 
of this 
system and investigate  the  scheduling  conditions  under  which  user  processes  may  be
denied  access  to  the  console. 
7.5 Implement  the  system  modeled  in  exercise 7.4  in  Java  using  the Th read Pan el and 
~ u ~ b e r ~ a n v a s  
classes  for  display,  Can  you  induce  starvation  in  a  user  thread  by 
giving  it  a  lower  scheduling  priority  using Th re ad . 
S et P  r 
io r i t y ( ) . If not,  can 
you  explain  why  starvation  does  not  occur? 
7.6  Two warring  neighbors are separated  by  a  field  with  wild  berries.  They  agree  to 
permit  each  other  to  enter  the  field  to  pick  berries, but also  need  to  ensure  that  only 
one of them  is  ever  in  the  field 
at a  time.  After  negotiation,  they  agree  to  the  following 
protocol. 
When  one  neighbor wants to  enter  the  field,  he  raises  a  flag. 
If he  sees  his  neighbor's 
flag,  he  does  not  enter 
but lowers  his  flag and tries  again. If he  does  not  see  his 
neighbor's  flag,  he  enters  the  field and picks  berries.  He  lowers  his  flag  after  leaving 
the  field. 
Model  this  algorithm  for two neighbors, n 1 and n2. Specify  the  required safety 
property for  the  field and check that it  does  indeed  ensure mu~ally exclusive  access. 
Specify  the  required ~ y ~ g ~ e s s  
properties  for  the  neighbors  such  that  they  both  get  to 
pick  berries  given  a  fair  scheduling  strategy.  Are  there  any  adverse  circumstances  in 
which  neighbors  would  not  make  progress?  What if the  neighbors  are  greedy? 
(Hint:  The  following FSP can  be  used  to  model  the  flags.) 
C 
True = 1 
const False = 0 
r 
Boo1 = False..True 
set BoolActions = 
~setTru~,setFalse,[False],[True]~ 
BOOLVAR = VAL[False], 
VAL[v:Bool] = ( setTrue -> VALETrue] 
1 setFalse - 3  VAL[False] 
1 [ V ]  -> VAL[V] 
1. 
I I FLAGS = (flag1 : 
BOOLVAR I I flag2 : 
BOOLVAR) . 
7.7  Peterson's  Algorithm  for two processes  (Peterson G.L. 1981) 
F o r ~ a t e l y  for the neighbors  in  exercise 
7.6, Gary  Peterson  visits  one 
day  and 
explains  his  algorithm  to  them.  He  explains  that,  in  addition  to  the  flags,  the  neigh
must  share  a turn indicator  which  can  take  the  values 1 or 2. This  is  used  to  avoid 
potential  deadlock. 

Exercises 
157 
When  one  neighbor  wants 
to enter  the  field,  he  raises  his  flag  and  sets  the  turn 
indicator  to  indicate  his  neighbor. 
If he  sees his neighbor’s  flag  and  it is his neighbor’s 
turn,  he may not  enter but must try again later, Otherwise, he can  enter  the  field  and 
pick  berries  and  must  lower his flag  after  leaving  the  field. 
For  instance,  neighbor 
nl behaves as shown  below,  and  neighbor 
n2 behaves 
spmetrically. 
flagl = true; turn = 2; 
while (flag2 and turn==2) { }; 
enterfield; pickBerries; 
flagl = false; 
1 
Model  Peterson’s  algorithm  for  the two neighbors.  Check  that it does  indeed  avoid 
deadlock  and  satisfy  the  mutual  exclusion 
(safety) and  berry-picking  (progress)  prop- 
erties. 
(Hint:  “he  following FSP can be used  to  model  the  turn  indicator.) 
set CardActions = {setl,set2,[1],[2]} 
CARDVAR = VAL[l], 
VAL[i:Card] = ( set1 -3 VAL[l] 
I set2 -> VAL[2] 
I [i] 
-> VAL[ i] 
1. 
7.8 Implement  Peterson’s  Algorithm  as  modeled in exercise 7.7. 

This Page Intentionally Left Blank

deling  is  widely  used  in  engineering  desi 
re  simplified  represen- 
ions of the  real  world,  designed  to  includ 
aspects  relevant  to  the 
problem  at  hand.  The  reduction  in  scale  and  complexity  achieved 
by model 
enables  design  engineers  to  analyze  their  designs  to  check  the  properties 
interest. 
For  instance,  a  structural  engineer  may  build  a  mathematical  model  of  a 
particular  bridge  design  to 
~vestigate its  stren 
Using different  model  para- 
meters  to  represent  differing 
si~ations and  ma 
als, the  engineer  analyzes  the 
stresses  and  strains 
on  the  structural  components 
of the  proposed  bridge, 
assessing  its  stren  th.  The  engineer  uses  data  from  past  experience 
wledge  and  skill  t  design  and  tailor  the  model  such  that  it  accurately 
reflects  the  behavior  of  a  real  bridge.  This  is  essential 
if the  faults found  in  the 
model  are  to  be  true  indications  of  faults  that  could  occur in the  real bri 
e  lack of faults  indicates  a  sound  design  for  a  fault-free 
interprets  the  model  behavior  in  order  to  infer  behavi 
er  may  need  to  modify  the  design  and  corre- 
sponding 
 
model 
 
ith 
 
the 
 
results, 
 
he 
 
or 
 
she 
 
can 
c o n ~ u e  
with 
confidence  on  the  path  to  bridge  construction. 
As illustrated in the  apters,  this  book  takes  a 
mo~eling approach  to 
the  design 
of concur  Our  models  represent  the  concurrent  behavior 
of real  concurrent  programs  written  in  Java.  We  abstract  much  of  the  detail 
of the 
real  programs,  neglecting  aspects  concerned  with  data  representation,  resource 
usage  and  user  interaction.  Instead,  we  focus  on  actions,  interactions  and  concur- 
rency.  For  instance, in our  model of the  bridge for  the  single-lane  brid 
in the  previous  chapter,  we  are  only  concerned  with  the  enter  and  exit 
car. We therefore  restrict  our  model  to  these  actions.  We  model  the  constraints 
imposed  on  these  actions by the  cars  and  the  brid 
safety  and  progress  properties of interest.  Adjust 
are  made  to  the  model  to  "stress-test" it and  to 

between  the  model  and  the  desired  program.  Safety  and  progress  violations,  and 
the  associated  trace  and  path 
 orm mat ion, require inte~retation to  understand  the 
c i r c ~ s t ~ c e s  
of the  violation  and  the  implications for the  program. The  model 
provides  a  sound  basis  for  proceeding  towards  program 
c o ~ ~ u c t i o n  
with  greater 
confidence,  insight  and  understanding. 
This chapter  recapitulates  and  consolidates  the  concepts  presented  in  previous 
chapters. It carefully  and  systematically  describes  the  process 
of moving from 
system  requirements  through  modeling 
to programming. No particular  design 
method  is  imposed,  since  different  designers  may  choose to use  different  techni- 
ques  according  to  their  own  particular  training  or  experience,  or  according to the 
particular  system  application.  The  intention  is  to  emphasize  the  role  and  utility 
of 
modeling  in  association  with  any  design  method.  Modeling  and  program  design 
go hand-in-hand  when  designing  any  software, 
but it is  particularly  important 
when  constructing  concurrent  programs.  The  example  of  a  cruise  control  system 
for  a  car 
is used  to  illustrate  the  description.  This  was  briefly 
in~oduced in 
Chapter 1; for  convenience,  we  repeat  the  description  and  deal  with 
it in  detail 
in  this  chapter. 
The ~ e ~ ~ i ~ e ~ e n t s   s p e ~ ~ c ~ t i o n  
of  a  system  states  the  goals  that  the  system  is 
expected  to  satisfy.  These  are  couched 
in application  domain  terms,  describing 
the  desired  behavior  of  the  proposed  system  in  the  context 
of its enviro~ent. 
It is 
the  responsibility of the  requirements  engineers  to  elicit  the  requirements  from  the 
system  stakeholders  and  to  produce  the  requirements  specification.  Even  at  this 
stage,  models  are  essential  to  facilitate ~derstanding and  analysis.  For  instance, 
the  different  scenarios  that  the  system  should  support  can 
be captured  as  Use  Case 
models  using  the  Unified  Modeling  Language  (UML).  These  provide  a  description 
of the  various  actors  that  interact  with  the  system  and  the  typical  interactions.  Use
case  scenarios  can  also be useful  later  in  examining  traces  in  the  design  model  and 
test  cases  in  the  implemented  system.  Furthermore,  the  requirements  specification
should  identify  the  particular  properties  of  interest.  This  can  help  to  articulate  the 
safety  and  progress  properties which  must  hold  for  the  system. 
The  process of design  is  required  to  decompose  the  requirements  into  a design 
~ ~ c ~ ~ ~ e c t ~ ~ e .  
This  describes  the  gross organiza~on and  global  structure of the  sys- 
tem  in  terms 
of its  constituent  components.  In  order  to  cope  with  complexity, 
hierarchical  composition  is  employed.  Quite  simply,  this  means  that  the  architec- 
ture  is  composed  from  components  such  that  each  component  may 
be composite, 
constructed  from  simpler  components. 

8.1 From ~ e ~ ~ i r e m e ~ t s  
to ~ o ~ e l s  
161 
The c o ~ ~ o n e n ~ s  
of a  design  architecture  have  a  state,  exhibit  some  well-defined 
behavior,  and  have  a  unique  identity.  The  identity  distinguishes 
it from all other 
components;  the  behavior  represents  its  outwardly  visible  and  testable  activity; 
and  the  state of a  component  represents  the  cumulative  results 
of its  behavior. 
Design  architectures  and  components  satisfy  the  basic  three  principles  underlying 
object-oriented  approaches: 
~
~
s
~
~
~
c
~
~
o
n
 
- 
this  is  the  removal  or  neglecting of unnecessary  detail.  Levels of 
abstraction  are  supported by moving  up  and  down  the  hierarchy of composed 
components. 
~ n c ~ ~ s ~ Z ~ ~ ~ o n  
- 
components  encapsulate  local  behavior  and  information,  and 
only  expose  activity  at  their  interfaces.  Components  thereby  provide infoma- 
tion-hiding  facilities. 
~
o
~
~
2
~
~
~
~
- 
the  architecture  provides an  organizing  structure of components 
which  dictates  the  component  compositions  and  interactions. 
Any  design  approach  which  produces  a  decomposition  into  components  may be 
used  to  provide  an  outline  design  architecture.  The  main  activities  are as follows: 
Identify  the  main  actions  and  interactions of the  system. 
Identify  the  main  components of the  system. 
Structure  the  components  into  an  architecture. 
The  aim  is  to  produce  an  outline  architecture  that  can 
be used  to  informally  check 
that  all  the  required  system  functionality  is  satisfied.  This  would  include  informa
checks  that  the  use  case  scenarios  are  supported  and  that  the  properties 
of interest 
are  satisfied. 
However,  in  order  to  check  the  adequacy  and  validity 
of a  proposed  design  in  a 
more  rigorous  manner,  it  is  necessary  to  model  the  system  behavior  more  pre- 
cisely.  A  structure  diagram  model  can  be  used  as a precise form of design  archi- 
tecture  for  a  system.  Structure  diagrams  were  introduced  in  Chapter 3 and  have 
been  used  in  subsequent  chapters  to  describe  the  structure 
of the  models  in  terms 
of  processes  and  their  interactions.  Processes  model  components  and  composite 
processes  model  composite  components.  Action  hiding,  relabeling  and  sharing  are
used to model  component  encapsulation  and  interaction  respectively. 
An  automobile  cruise  control  system  has  the  following  requirements. 
It is  con- 
trolled  by  three  buttons: 
~ e s ~ ~ e ,  
on and off (Figure 8.1). When  the  engine  is  running 
and on is  pressed,  the  cruise  control  system  records  the  current  speed  and  main- 
tains  the  car at this  speed. When  the  accelerator,  brake  or off is  pressed,  the  cruise 

Figure 8.1 Cruise control system. 
control  system  disengages  but  retains  the  speed  setting. If r e s ~ ~ e  
is  pressed,  the 
system  accelerates  or  de-accelerates  the  car  back  to  the 
pre~ious~y-recorde~ 
speed. 
The  hardware  that  supports  the  cruise  control  system  is  shown 
in Figure 8.2. It 
con~ists of a  Parallel  Interface  Adapter 
(P~A) which  records  the  actions  of  the 
buttons (on, of 
and r e s ~ ~ e ) ,  
the  brake ( ressed),  the  accelerator  (pressed)  and 
the  engine  (on  or  off).  The  PIA  is  polled  periodically  every 
100 msec  to  determine 
if any  of  these  actions  has  occurred. 
A wheel  revolution  sensor ~enerates inter- 
rupts  for  every  wheel  revolution  in  order  to  enable  the  system 
to calculate  the 
current  speed of the  car.  The  cruise  control  system  controls  the  car  speed 
by s e t t ~ g  
the  throttle of the  car  via  a  di 
a 
throttle 
Figure 8.2 
Hardware constraints. 
The  structure  diagram  and  actions  for  the  cr  control  system  shown 
in  Fi 
8.3 can be produced  using  the  following  de 
Identify  the  main  actions  and  interactions of the  system. 
Identify  and  define  the  main  processes of the sy§te~. 
Identify  the main  properties of the  system. 
Structure  the  processes into a struc~re 
diagram. 

ese acti~i~ies 
corre 
Structure  diagram  for  the  cruise  control  system. 
The  main  internal  control 
processes:  the  cruise  control1 
sensors  and  actuators  is pro 

164 
C~upter 
8: Model-~ased Design 
archy. Animation  can  be used for  scenario-checking,  and automated model-check- 
ing  can  be used for  verification of safety and progress properties. 
Each of the  processes  is  defined  in  Figure 8.4. The  sensors are repeatedly  scanned; 
the input speed is repeatedly monitored  when  the  engine  is  on; and, when the 
throttle is  set, the car  "zooms"  off!  Speed  control is  initially disabled. It  clears  and 
records  the current speed setting and, when it is  enabled, it sets the throttle 
according to the current speed and the recorded speed. The  behavior of the  cruise 
controller  is as follows.  When  the  engine  is  switched  on, 
C le a r Speed is  triggered 
and the cruise  controller  becomes  active.  When  active,  pressing  the 
on button 
triggers the recording of the current speed and  enables  the speed control. The 
system  is then cruising.  Pressing the on button again triggers  the  recording of 
the  new current speed and  the  system  remains  cruising.  Pressing  the o f  button, 
brake or  accelerator  disables  the 
speed control and sets  the  system to standby. 
§witching the engine off at any  time  makes the system  inactive. 
Sensors = (engineOn,engineOffTon,off, 
Engine = (engineOn,engineOff} 
Prompts = ~clearSpeed,recordSpeed, 
res~meTbrakeyaccelerator} 
en~bleControlTdisableControl} 
SENSORSCAN = ((Sensors} -> SENSO~SCAN). 
INPUTSPEED = (engineon -> CHECKSPEED), 
CHECKSPEED = (speed -> CHECKSPEED 
IengineOff -2 I ~ ~ U T ~ P E E D  
THROTTLE =(setThrottle -> zoom -> THROTTLE). 
SPEEDCONTROL = DISABLED, 
DISABLED =((speed,clearSpeed,recordSpeed}->DISA~LED 
I enablecontrol -> ENA 
ENABLED =( speed -> setThrottle -> ENABLED 
) J  
l(recordSpeed,enableControl} -> ENABLED 
I disableContro1 -> DISABLED 
1. 
Figure 8.4 Model for the cruise control system. 

OLLER = INACTIVE, 
engineon -> clearspeed -> ACTIVE), 
engineoff -> INACTIVE 
~on->recordSpeed->enableControl->CR~ISING 
> I  
I {  off,brake,acceler~tor3 
Ion->recordspeed->enablecontrol->CRUISING 
C~UISING  =(~n~ineOff 
-> INACTIVE 
-> disableco~trol -> STAND6Y 
STAND6Y  =(engineoff -> INACTIVE 
lresume -3 enablecontrol -> CRUISING 
~on->recor~Spe~d->enableControl->CRUIS~NG 
1- 
engineon 
engine0~ 
Figure 8.5 LTS diagram  for INPUTSPEED, 
enableControl 
 
enableControl 
disableControl 
setThro~le 
Figure 8.6 LTS diagram for SPEEDCO~TROL . 
'"he  corresponding LTS diagram  for  each of these  processes  can be inspected  to 
check  that  the  process  does  indeed  model  the  desired,  intuitive  behavior.  For 
example,  the 
I ~ ~ ~ T S ~ E E D  
and S~EEDCONT~OL 
LTS diagrams  are  shown 
in 

166 
C ~ a p ~ e r  
8: ~
o
~
e
l
~
~
Design 
It  can  be  animated  to  produce  answers  to  the  following  questions: 
after  the  engine  is  switched 
on  and  the  on  button  is  pressed? 
when  the  brake is then  pressed? 
- Is control  enabled  when  resume  is  then  pressed? 
The  trace  depicted  in  Figure 
.7 confirms  this  behavior.  Note  that  the  trace  also 
illustrates  that when  control  enabled,  the  speed  input  causes  the  throttle  to  be 
set,  and when disabled,  it  does  not.  Alth  various  scenarios  help  to  improve 
our  confidence  in  the  adequacy of the mo 
d  its  behavior,  they  do  not  provide 
an  exhaustive  check  over  all  ossible  execution  paths. 
To this  end,  we  need  to 
specify  the  safety  properties of interest. 

afety  checks  are 
CO 
ositional in the  sense that if there  is no violation at a 
there  cannot  be  a  violation  when  the  subsystem  is 
S. This  is  because if the 
e in the LTS  of the  subsy 
subseq~ent parallel  composition  which  includes  the  subsystem.  Safety  checks  can 
therefore  be  conducted  directly on the  subsystems  which  exhibit  the  behavior  to 
be  checked.  The  following  guidelines are used  when  performing  safety  checks: 
Safety  properties should be  composed  with  the 
appropriate system  or 
subsystem  to  which  the property refers. In order that the property can 
check the  actions in its  alphabet,  these  actions  must  not  be 
hidden in the 
A  safety property required of the CO~TROL 
subsystem  is as follows: 
brake,~isableControl} -> CRUISESAFETY 
l~on,resum~} 
-3 SAFETYCHECK 
L 
({on,resum~} -> SAFETYCHECK 
l{o~f,acc~lerator,bra~e~ 
-> SAFETYACTIO~ 
~disabl~Contro1 
-> CRUISESAFETY 
1, 
T Y ~ C T I O ~  
=(dis~~l~Control->CR~ISESAFETY). 
This property states that if the  control  subsystem  is  enabled  by  pressing  the 
on or 
~
e
~
~
~
e
 
buttons,  then  pressing  the of button,  the  brake  or  the  accelerator should 
result in the  control  system  being  disabled.  The LTS diagram for  this property is 
shown in  Figure 8.8. We compose C~UISESAFETY 
with the CO~TROL 
subsystem 
processes  (Figure 8.3) as follows: 
Safety  analysis  using LTSA verifies that the CRU~SESAFETY 
safety property is  not 
violated. We can  now  hide  internal  actions and proceed  with  the  composition of 
that subsystem  to  form  the  complete  cruise  control  system. 

I /CONTROL = 
(CRUISECONTROLLERI  ISPEEDCONTROLI  ICRUISESAFETY) 
8 ~~ensors,s~ee~,setT~rottle3. 
I ICRUISECONT~OLSYSTE~ 
= 
(CONTROLI ISE~SORSCANI 
IINPUTSPEEDI /THROTTLE). 
Safety  analysis  using LTSA verifies  that  the 
CRUISECONTROLSYSTE~ 
does  not 
deadlock  or  violate  the  safety  property. 
resume 
on 
brake 
accelerator 
Off 
A 
accelerator 
 
resume 
\ 
\ 
disableControi 
\ 
disabIeContro1 
/ 
Off 
accelerator 
brake 
on 
resume 
Figure 8.8 L E  
diagram  for the CRUISESAFETY property. 

Progress  checks  are  not  compositional.  Even 
if there  is  no  violation at a  subsystem 
level,  there  may  still  be  a  violation when the  subsystem  is  composed  with  other 
subsystems.  This  is  because 
an action  in  the  subsystem  may  satisfy 
~ e a c h a ~ l e  
when  the  subsystem is  composed  with  other  subsystems  which  con- 
strain its  behavior.  Furthermore,  action  priorities  act  to  discard  lower  priority 
action  transitions  in  preference  to  higher  priority  ones.  With  parallel  compositi
higher  priority  actions  may  become  unreachable  thereby  removing  particular 
choices and requiring  the  restoration of the  lower  priority  actions. We therefore 
conduct  progress  checks  on  the  complete  target  system. 
Progress  checks  should  be  conducted  on  the  complete  target  system  after 
We can  now  subject  the  cruise  control  system  to  progress  checks,  such  as  that  the
throttle is  eventually  set. h fact,  the  cruise  control  system  is  expected  to  be  capa
of operating  repeatedly  whenever  the  engine  is  switched  on. Hence,  we  would 
expect  that  no  action  suffers  starvation and that  it  is  always  that  case  that  every 
action  can  eventually  be  chosen. 
We therefore  perform  a  general  progress  test 
without  specifying  particular  sets of progress  actions. If this  general  test  produces 
no  violations,  then we can  be  certain  that  there  are  no  violations  for  any  specific 
progress  property. 
However,  progress  analysis  using 
LTSA on  the 
C R U I ~ E C O ~ T R O ~ ~ Y S T
produces  the  following  violation: 
Progress  violation  for  actions: 
~ e n ~ i n e o n ,   e n ~ i n e o f ~ ,  
on, off,  brake, 
accelerator, resume) 
Path  to  terminal  set  of  states: 
en~ineOn 
tau 
on 
tau 
tau 
engineof f 
en~ineOn 
Actions  in  terminal  set: 
(speed,  setThrottle, 
zoom) 

This  indicates  the  violation of a number of actions  and  a term~al 
set  in  which  the 
itted  are  speed  input  and  the  settin  of  the  throttle  with  the 
action.  Thus, if the  system  is  enabled by switch 
on button,  and  then  the  engine  is  switched  off 
a 
pears  that  the  cruise  control  system  causes  the  car  to  zoom  off! 
ngerous  situation  and  one  that  should  definitely  be  avoided 
To  further 
~vestigate the  circu  hich  lead  to  this  violation,  we  can 
expose  the  actions  hidden  in CONT 
replaces  the tau actions  in  the  trace 
by the  actual  actions  hidden  in CO 
full  trace  then  becomes: 
r e s s   v i o l a t i o n   ~ o r ~ a c t i o n s :  
ineon,  clearspeed, 
engine off^ on, 
recordspeed,  enablecontrol, 
o f f ,  
i ~ ~ ~ l e C o n t r o 1 ,   b r a k e ,   a c c e l e r a t o r  
........... 
3 
ath  to  terminal  set 
o f  states: 
engineon 
clearspeed 
on 
$ecordSpeed 
enableContro1 
engineof f 
engineon 
Actions  in  terminal  set: 
{speed,  setThrottle, 
zoom) 
This  confirms  the 
inte~retation that contr~l is not ~ i s ~ ~ l e ~  
 he^ the e ~ ~ i n e  
is 
s ~ i ~ c h e ~  
of. Further  clarification of the  situation  can be obtained by e x a m ~ n g  
a 
m ~ i ~ % e d  
LTS  diagram of the  cruise  control  system  in  which  only  the 
and speed actions  are  visible: 
I /CRUISEMINIMIZED = ( C R ~ I S E ~ O ~ T ~ O L S Y S T E M )  
@ {Sensors,speed~. 
Action  hiding  and m ~ ~ i z a t i o n  
can  help  to  reduce  the  size of the  diagram  and 
make  it  easier  to  interpret. 
CRU I SEM I N I  M I ZED produces  the  LTS  diagram  in 
Figure 8.9 which  clearly  illustrates  the  situation. 
ow  can  this  catastrophic  situation  be  avoided?  Why  did  our  safety  property  not 
identify  this  error? 

brake 
en~ineQn 
on 
enaineQn 
peed 
peed 
\ 
enaineQff 
on 
e n ~ i n e 0 ~  
Figure 8.9 ~ i ~ i ~ i z e d  
LTS diagram for C ~ U I ~ E ~ I ~ I ~ I ~ E ~ .  
TY safety  property  did  not  include  a  check  on  the  engine 
status.  This  must now be  included  to  form  an  improved  safety  property: 
( { o ~ , r e s ~ ~ e }  
-> ~ ~ F E T Y C H E C K  
/(off,accelerato 
It  is  clear  that  control  should  be  disabled  when  the 
en  ne 
is  switched off. This 
would  ensure  that  control  is  disabled  when  the  engine  switched  on  again.  The 
required  change  to  the C 

172 
C
~
~
t
e
~
 
8: Model-~ased Design 
... 
CRUISING  =(engineoff -2 
I {  
off,brake,accelerator} 
/on->recordspeed->enableControl->CRUISING 
1, 
-> disablecontrol -> STANDBY 
S
.
.
 
We  can  now  repeat  the  analysis  process  as  before.  This 
t h e  there  are  no  safety  or 
progress  violations. The  minimized  cruise  control  system, as shown  in  Figure 8.10, 
is clearly  reassuring. It indicates  that  all  actions 
in  the  system  are  in  a  single 
terminal  set. 
engineon 
on 
accelerator 
brake 
Off 
\ 
engineoff 
engineoff 
Figure 8.10 Minimized LTS diagram for the  revised ~ ~ U I S E ~ I N I ~ I Z E ~ .  
Further  analysis of the  model  could be conducted  to  investigate  system  beha- 
vior  under  particular  adverse  conditions.  For  instance,  we  could  employ  action 
priorities  to  check  progress when sensors  are given.  high  priority. 
I ISENSORSHIGH = CRUISECONTROLSYSTE~  {Sensors}. 
NO progress violations are detected. However, 
if the  sensors  are  given  a  low 
priority: 
I ISENSORSLO~ = CRUISECONTROLSYSTE~ >> {Sensors). 

8.2 From ~ o ~ e ~ s  
to ~mp~ementutions 
173 
then the speed action  dominates and, on analysis,  we  obtain  the  following 
violation: 
Progress  violation  for  actions: 
{engineon,  engineoff,  on, 
off, brake, 
accelerator,  resume,  setThrottle, 
zoom} 
Path  to  terminal  set  of  states: 
engineon 
tau 
Actions  in  terminal  set: 
{speed) 
This  seems  to  indicate 
that the  system  may  be  sensitive  to  the  priority 
of the  action 
speed. This  can  be  confirmed  since,  making 
speed a  high  priority  is  similar to 
making  Sensors  low, and making speed a  low  priority  results  in  the  following 
violation: 
Progress  violation  for  actions: 
{speed,  setThrottle, 
zoom} 
Path  to  terminal  set  of  states: 
Actions  in  terminal  set: 
{engineon,  engineoff,  on,  off,  brake, 
accelerator, resume} 
Thus,  models  such as this  can  be  used  to  indicate  system  sensitivities. 
If it  is 
possible that erroneous situations detected  in  the  model  may  occur  in  the  imple- 
mented  system,  then  the  model should be  revised  to  find  a  design  which  ensures 
that those  violations are avoided. However, if it is  considered  that  the  real  system 
will not exhibit  this  behavior,  then no further  model  revisions are necessary.  In 
this  way,  model 
inte~retation and correspondence  to  the  implementation 
are 
important in  determining  the  relevance and adequacy of the  model  design and 
its  analysis. 
In  the  cruise  control  system, 
speed monitoring  needs  to  be  carefully  controlled 
so that it neither  dominates  nor  suffers  from starvation. If we are confident that 
this  can  indeed  be  achieved  in 
our implementation,  then we need  perform  no 
further  modeling. We now turn our attention to an implementation of the  cruise 
control  system,  based  on  the  model. 
As mentioned,  a  design  architecture  describes  the  gross  organization and global 
structure of the  system in terms of its constituent  components.  In  order  to 
support 

.l1 Design  architecture,  behavior  model and other  models. 
ram ~escri~ed 
in this  section  provides  a s i ~ u l ~ t i o n  
for the  environ- 
ment h 
which  the  cruise  control 
~~lementation 
executes. 
si~ulation is a 
rovides buttons to s i ~ ~ l a t ~  
the  actions of 
n and off both  the 

re 8.12 Cruise  control  applet  display. 
The  class  diagram  for  the  cruise  control  program  is  shown  in  Figure 
classes   on troll er and ~ p e e d ~ o ~ t r o l  
implement  the  model  processes 
p e ~ d ~ o n ~ r o l  
intera 
s~ulation 
provided by the  clas 
tor via  the  interface 
interface  provides  methods  to  set  the  throttle  and to 
the c u ~ ~ e n t  
speed at which 
the  car  is  travelling.  We  have  introduced  this  inter 
so that  the  classes  imple- 
menting  control  are  insulated  from  all  the  details 
of the simulation The  interface  is 
P r o ~ r a ~  
8.1 CarSpeed interface. 
When a button  is  pressed,  this  event  is  passed by the p p l e l  class  to  both  the 
car  simulator and  the  cruise  controller  using  a  method  call. 
Thus, the Controller 
class  provides  a  method  corresponding to each  button. 

accelerator0 
engineoff() 
CS 
I 
I 
Figure 8.13 Cruise  control  class diagram. 
"he implementation of Con t r o l l e r  follows  directly  from  the  model  process 
C ~ ~ I S E C O ~ T ~ O L L E ~ .  
Each method  modifies  the  control state and invokes  speed 
control  actions. The implementation  is  listed in Program 8.2. Controller is  a 
passive  entity; it always  reacts  to  events and does  not  instigate  them.  It  is  imple- 
mented as a  monitor  with  each  model  action  becoming  a 
s~chronized method. 
In contrast, SpeedCont rol, listed in Program 8.3, is an active  entity.  When  it  is 
enabled,  a  thread  is  created  which  periodically  obtains  the  current  car  speed  from
the  car  simulator 
and sets  the  throttle 
so that  the  target  cruising  speed  is  maintain
"he thread terminates  when  speed  control  is  disabled. 
The run ( ) method  contains 
section  since  the  code 
in this  section  accesses  the 
set Speed vari- 
able  which  can  be  modified  by  other 
threads via  the 
clearSpeed( ) and 
r e  c o r d  S pe ed ( ) methods.  This  is  not  strictly  necessary,  since  Java  guarantees 
atomic  access  to  32-bit  quantities  such 
as integers.  Indeed,  we  have not protected 
the st at e variable  which  is  also  used  by 
r u  n ( ) and other  methods. 
Program 8.2 Controller class. 


Program 8.3 SpeedCont rol class. 

~ e e ~ ~ o n  
t ro l is  the  first  example  we  have  met of a  class that combines both 
s ~ c h r o n i ~ e d  
access  methods and a thread. We could  have  implemented it as two 
classes,  a  purely  passive  entity  which  encapsulated  the 
st a t  e and s e t  Speed 
variables and an active  entity with only  a run ( ) method. However,  this  would 
have  been ~ecessarily 
complex and would lead  to additional methods  to  set 
and 
et  the  variables. As implemented,  the  class  satisfactorily  encapsulates  the thread 
and the  methods that control  its  execution. 
This  chapter has consolidated  the  model-based  approach  used in previous  chap- 
ters.  It 
has described  the  process 
of progressing  from  system  requirements 
through modeling  to progranxning. The  main  activities  were  identified,  including 
system  decomposition  into  a  model 
structure and model  elaboration,  analysis and 
revision, if necessary.  The  stage at which  properties are checked was also  dis- 
cussed.  Safety  properties  can  be  checked  on  system  or  subsystem  models 
as 
a~propriate. Progress  checks  need  to 
‘be performed  on  the  overall  system 
model. The mapping of a  model structure into an i~plementation was  also 
described. 
No particular  design  method  is  imposed. 
We advocate  modeling in association 
with every  design method. Modeling  complements program design and is  parti- 
cularly  useful  when  constructing  concurrent  programs. 
A  cruise  control  system  for  a  car  was  used  to  illustrate  the  model-based  design
approach. This system was briefly  introduced  in Chapter 1 to  motivate  model- 
based  design; it was  dealt  with  in  detail in this  chapter,  giving both the  model 
details and an ~plementation in Java. 
There  are numerous books that describe  software  design  methods and techniques, 
most of which  include  some  form of informal  modeling and r e a s o ~ g  
to  help  in 
the  design  process.  However,  few  use  modeling 
in a  rigorous  fashion.  One of the 
exceptions  is  Giorgio  Bruno’s  book, 
~ 5 ~ e ~ - ~ a s e ~   ~ 5 ~ ~ a
~
~
g
~
~
e
e
~
~
(1995),  which 
et  models.  Another  technique 
of interest  is ROOM  (Real-Time  Object- 
deling)  which  combines  a  language  for  system structure with state 
m a c ~ e  
models and is supported by  the ObjecTime  toolset  for  model  execution 
(Selic,  Gullekson and Ward,  1994).  Statecharts  (Harel,  1987)  are 
supported by  the 
S ~ A T E ~ T E  
(Harel,  Lachover,  Naamad, et al., 1990) software  tool and is  used  for 
n of reactive  systems.  A  form of statecharts  is  also  incorporated in the 

UML approach  (Eooch,  Rumbaugh  and  Jacobson,  1998;  Fowler  and  Scott,  1997), 
which  recognizes  the  importance of modeling  and  provides  a  basketful of model- 
ing  notations  and  techniques. 
The  car  cruise  control  system  used  in  this  chapter  is  a  simplified  version 
of a 
real  system.  Actual  systems  do  not  disengage 
when  the  accelerator  is  pressed,  but 
retain  the  speed  setting  and  return  the  car to that  speed  when  the  accelerator  is 
released. 
The  example of the  car  cruise  control  system is originally  due  to  Grady  Booch 
(1986)  who  adapted 
it from  an  exercise  provided 
by P. Ward at the  Rocky 
Mountain  Institute  for  Software  Engineering.  Since  then, 
it has  been  widely 
used  as 
an example  for  the  design 
of concurrent  and real-the systems.  For 
instance,  Hassan  Gomaa  uses 
it as  a  case  study  in  his  book, 
S ~ ~ ~ a r e  
Design 
M e ~ ~ ~ d s  
for C~nc~rrent 
and ~ e ~ l - ~ ~ m e  
Systems (1993). Mary  Shaw  uses it as a  com- 
mon  example  for C ~ m ~ ~ r ~ n g   A ~ c ~ i t e c t ~ r a ~  
Design  Styles (1995). 
8.1 Each  of  the  rooms  in  a  building  has  a  control  station  for 
mo~toring and  controlling 
the  environment.  Each  control  station  measures  and  displays  the  current  temperature 
and  humidity.  For  each  room,  the  desired  temperature  and 
humidi~ 
is set  by  a  pair  of 
dials. If the  current  readings  are  outside  the  desired  setting 
by more  than 1 %, then  the 
station  can  control  the  heating  or  ventilation  accordingly. 
A central  operator  station is 
able to request  the  current  readings  from  any  control  station. 
Outline  the  design  structure  of  a  room  control  station  given  that  it  is  decomposed 
into  the fo~owing processes:  sensors,  dials, heater-vent~ator, display  and  controller. 
Provide  a  model  for  each  process  and  check  that  the  control  station  satisfies  appro- 
priate  safety  and  progress  properties. 
Provide  an ~plementation for  the  room  control  station. 
8.2 A self-service  gas  station  has  a  number  of p m p s  for  delivering  gas to customers  for 
their  vehicles.  Customers  are  expected to prepay  a  cashier  for  their  gas.  The  cashier 
activates  the p u p  to  deliver  gas. 
Provide  a  model  for  a  simple  system  with 
two customers  and  a  gas  station  with  one 
pump  and  a  cashier.  Include  in  the  model  a  range  for  the  different  amounts 
of pay- 
ment  and  that  a  customer  is  not  satisfied 
( ~ R R O ~ )  
if the  incorrect  amount  of gas is 
delivered: 
C ~ ~ T O ~ ~ R  
= (pre~ay[a:A~->~as[x:A~-> 
if (x==a) then CUSTO~~R 
else ERROR 
) m  

Exercises 
181 
Check  the  safety and progress  properties  for  this  system. 
Provide  a  simple  Java  implementation  for  the  gas  station  system. 
8.3 Extend  the  gas  station  model  in  exercise 8.2 to cater  for N customers and M p u p s .  
Spec* and check a  safety  property, FIFO, which  ensures  that  customers  are  served 
in 
the  order in which  they pay. 

This Page Intentionally Left Blank

In  the  programs  we 
have described so far, threads are created during ~tialization 
and  they run until program termination. The  organization of threads,  and the 
which  they  interact in these  programs, has been  static during 
program  execution.  This chapter examines  systems in which thread creation and 
t e r ~ a t i o n  
occurs  dynamically during program  execution.  The  number of active 
threads thus varies as execution  progresses.  This sort of behavior  occurs in oper- 
ating systems  where  processes are created  dynamically in response to user  com- 
mands. For  example, when  a  user  clicks  on  the  word  processor  icon,  a  process  is 
created to run the  word  processor  program;  when the user  exits the word  pro- 
cessor program, the  process  terminates. 
To illustrate some of the  issues  involved  in  modeling  and  programming 
dynamic  systems, we consider the problem of resource  allocation  in  which dyna- 
mically-created threads need  variable  amounts of a  resource to proceed. To make 
the  problem  less  abstract,  we 
simulate a golf  club with players simulated by 
threads and golf balls  representing  the  resources  they  require. 
A specific  problem addressed in this chapter is the relevance of finite state 
models to dynamic  systems.  Briefly stated, the problem  is that the models  we 
construct  must  be  static 
with a  fixed number of processes to permit analysis, 
while  a  dynamic  system has a  variable  number of processes.  To  see how  this  is 
handled, we  proceed  by  developing 
the program  first  and 
then developing  a 
model. We  examine how  much of the behavior of the  dynamic  system  is 
captured 
in the static  model and whether this  static  model  is 
helpful in analyzing the 
behavior of the d ~ a m i c  
system. 
Finally, the chapter looks at the  use of the Java j oin ( ) method,  which permits 
a thread to wait for the t e r ~ a t i o n  
of another thread, which  it has usually  created 
dyna~cally 
. 

A golf club  has  a  limited  number of olf  balls  available  for  hire.  Players can hire 
golf  balls  for  their  game  from  the  club  and  return 
them to  the  club  after  use.  Expert 
players, who  tend  not to lose  any of their  golf  balls,  only  hire  one  or two. Novice 
players  hire  more  balls, so that  they  have  spares  during  the  game  in  case of loss. 
However,  they  are  required  to  buy  replacements  for  lost  balls so that  they  return 
the  same  number  that  they  originally  hired. 
To sim~late the  golf  club  as  a  Java 
program,  we  create  a  new  thread  for  each  player  arriving 
at the  golf  club  and  use  a 
monitor  to  control  the  hiring 
of golf  balls  to  players. 
The display  for  the  program  is 
shown  in  Figure 9.1. 
ure 9.1 Golf Club applet display. 
New players,  with  their  golf ball re~uire~ents 
indicated  in  parentheses,  are 
created  by  clickin  the  buttons  at  the  bottom  of  the  dis  lay.  Each 
newly- create^ 
player  is  given  a  name con~isting of  a  letter,  allocated ~ o ~ e c ~ t i v e l y  
in al~habeti~ 
order,  and  the  number of golf balls  the  player  requires. A newly-created  player 
appears  briefly  in  the 
'New' window  and  then  appears 
in the  'Wait golf  ball 
window if there  are  not  enough  golf  balls  available  for  the  player  to  start  playin 
When  the  player  acquires  golf  balls  and  starts  entity  appears 
in the 
'playing' window, When  finished  playing,  the  tity  appears  briefly  in 
the 'end' window, The '~~pleAllocato~' 
wind  e  state 
of the m o ~ t o r  
controlling  golf  ball  allocation.  The m a x ~ u m  
number of golf  balls  available  is  set 
to five, 

Figure  9.1  depicts  the  situation  in  which  there  are  currently  no  golf  balls  avail- 
able  for  hire  since  all  five  are  in  use 
by players c2, fl, el and gl. The  novice  player 
who  requires  four  golf  balls  to  start  playing  is  thus  waiting.  Note  that  the 
expert  players el,  fl and  were  created  after 
d4. They  have  started  playing 
before d4 since  at  the  time 
y requested  golf  balls,  there  were  enough  to  satisfy 
their  requirements  but  not  enough  to  satisfy d4. In  fact, if we  keep  creating  new 
expert  golfers  that  only  require  one  or 
two golf  balls,  then  the  novice 
continue  waiting. A continuous  stream of expert  players  arriving  at  the  golf 
club  can  cause  novices to wait  forever. h other  words,  the  program  has  a  liveness 
problem  in  which  novice  players  may  experience 
s ~ ~ r ~ ~ ~ i o ~ .  
Before  examining  this 
problem  in  more  detail  using  a  model,  we  describe  the  program  that  drives  the 
display of Figure  9.1.  The  classes  involved  are  depicted  in  the 
W
L
 
class  diagram 
of Figure  9.2. 
~ 
Applet 
starting 
waiting 
ending 
playing 
I /  
I 
Figure 9.2 Golf Club class diagram. 
We  are  going  to  develop  a  number 
of ~plementations of the  golf ball allocator. 
To allow us to substitute  these  implementations  without  modifying  the  rest 
of the 
program, we  define  the  Java  interface 
Allocator as listed  in  Pro 
~isplayAllocator 
class  implements  this  interface  and  delegates  calls  to  get  and 
put  golf  balls  to 
~impleAllocator 
which  actually  implements  the  allocation 
monitor.  In  addition, 
~isplayAllocator displays  the  state 
of the  monitor 
using  the ~ t r i n ~ ~ a n v a s  
class  we  have  used in previous  chapters.  The  code  for 
the ~ i m p l ~ A l l o c ~ t o r  
monitor  is  also  listed  in  Program  9.1. 

186 
C ~ a ~ ~ e r  
9: Dynamic Systems 
Program 9.1 Allocator interface  and Si~pleAllocator 
class. 
From  Program 9.1, it  can  be  seen that a  call to get n golf balls  will block  a  calling 
thread until enough  balls  become  available. M e n  a thread returns golf  balls, all 
blocked threads are awakened so that they  can  see if there are now  sufficient  for 
them to proceed.  Notice that this  allows  a thread trying to get  a large number of 
golf balls to remain  blocked  while  a thread requiring fewer  can  proceed. 
The PlayerArrival class  creates  new Player threads in  response to button 
presses.  Each  newly-created 
thread is passed a reference to the applet class 
Golf  Club. The thread needs this  reference  since  it  calls  the 
golf ball  allocator 
monitor  indirectly  via  the 
GolfClub methods getGolfBalls ( ) and 
r e  1Go I f  Balls(). The program has been  organized  this  way  to  avoid 
passing 
all  the display objects to every  newly-created thread. The  code  for the Player 
class  is  listed in. Program 9.2. 

9.1 Golf Club Program 
187 
Program 9.2 Player class. 
Notice  that,  in  contrast  to  the  threads  we  have  defined  in  previous  chapters,  the 
run ( ) method of the Player class  does  not  involve  a  loop.  After 
it has  been 
started,  the  player  gets  the  golf  balls  it  requires 
by calling get Golf 
sleeps  for  a  period 
of time  to  simulate  playing  and  then  releases  the  golf  balls 
using relGolf Balls ( ) . The run ( ) method  then  terminates.  Rather  than  listing 
the  entire  code  for  the  class Golf Clu b, since it is  rather  lengthy,  we  have  listed 
below  the two methods  used by Player: 
void  getGolf 
Balls (int n , St ring name) 
ws ~nterru~tedException 
{ 
String S = name+n; 
starting.enter(s); 
T~read"sleep(500); 
starting. leave( s) ; 
waiting.enter(s); 
alloc.get(n); 
w~iting.leave(s); 
~laying.enter(s); 
1 

l%% 
   apt er 9: ~ y ~ u ~ i c  
S y s ~ e ~ s  
void rel~olf~alls(int 
n, String name) 
throws InterruptedException 
String S = name+n; 
alloc.  put 
(n) ; 
playing.leave(s); 
ending.enter(s); 
Thread.sleep(500); 
ending.leave(s); 
These  methods  access  the  allocator  monitor  using 
alloc which  references  the 
DisplayAllocator object  which  in turn calls SimpleAllocator as  previously 
explained.  The  references 
starting, ~ a i t i n ~ ,  
playing and ending refer  to 
instances of the SlotCanvas class.  This  is  the  first  time  we  have  used  this  display
class. h outline of the  methods  it  provides  is  listed in Program 9.3. 
Program 9.3 SlotCanvas class. 
This  completes  the  description of the golf club  program. As discussed  previously, 
it  has  the  problem  that  novices  can  wait  forever  to  play  while  they  are  continu- 
ously  overtaken by expert  players. In the  next  section,  we  investigate  a  solution 
to 
this  liveness  problem  by  modeling  the  golf  club. 
In modeling  the  golf  club  program,  we  need  only be concerned  with  the  player 
threads  and  the  allocator  monitor  that  embody  the  concurrent  behavior  of  the  go
club. We can  abstract  away from  the  details of how  the  program’s  display  inter- 

9.2 Golf Club Mo~el 
189 
face is  constructed. We first  model the allocator  monitor  and then examine  the 
problem of modeling d~a~cally-created 
threads. The  model  for the allocator  is 
listed  below: 
N=5 
/ / ~ a x i ~ ~ ~  
##golf balls 
81.0. . 
N //avai~able range 
ALLOCATOR = BALL[N], 
BALL[b:B] = (~~~~ (b>O) ~et[i:l..b]->BALL[b-i] 
!put[ 
j :l. .NI 
->BALL[b+jJ 
The ALLOCATOR process  initially has N golf balls to allocate. In the state with b golf 
balls, the process  accepts  requests  for 
1.h. In other words, the process  blocks 
requests to get  more than b golf balls. The  process  moves into an error state if 
more golf balls are put back than were  previously  requested  (i.e. b+j > N). The 
behavior of ALLOCATOR can  be  clearly  seen 
in Figure 9.3 where N = 2 to reduce the 
complexity of the diagram. 
get.1 
put.2 
Figure 9.3 ALLOCATOR LTS for N = 2. 
How do we  model the potentially  infinite stream of d~a~cally-created 
player 
threads? The straightfo~ard answer  is that we cannot  since  this  would  involve 
an 
infinite state space.  However,  while  we  cannot  model  infinite 
state spaces,  we  can 
model  infinite  behaviors that are repetitive. In the golf club  example,  we do not 
need to model the fact that each  player thread is  distinct.  Instead,  we  model  a 

190 
C ~ a ~ t e ~  
9: Dynamic 
 
Systems 
fixed  population of golfers  who  continuously  repeat  the  actions  involved  in  play- 
ing  golf - 
a  situation  not too far  removed  from  real  life!  Effectively,  our  model 
constrains  the  maximum  number of golfers who are  concurrently  trying  to  play 
golf.  The  maximum  number of active  player  threads  in  the  program  is  only  con- 
strained by the  available  storage. 
Our  model  generates  an  infinite 
stream, of 
requests  from  a  fixed  set 
of golfers  while  the  program  generates  a  stream 
of 
requests  with  each  request  originating  from  a  new  player. 
A player  is  modeled by a  process  that  initially  decides  the  number 
of golf  balls 
it  needs to play  golf.  Subsequently,  the  process  continuously  attempts to get  and 
then  put  back  that  number of golf  balls.  The  model  for  a  player  process  is: 
PLAY~R 
= (~ee~[b:~]->PLAYER[b]), 
P L A Y ~ R ~ b : ~ ]  
= (set[b]->put[b]->PLAYE~[bl). 
The  behavior of PLAY ER can be seen  in  Figure 9.4 where  we  have  again  set N = 2 to 
reduce  the  complexity  of  the  diagram. 
need.2 
 
get.1 
 
get.2 
put.1 
 
put.2 
Figure 9.4 
PLAYER LTS for N = [L. 
We  now  need  to  distinguish  between  expert  players  and  novices.  The  difference
is,  of  course,  that  novices  require  more  golf  balls  than  experts.  We  define  an 
additional  process  to  constrain  the  numbers 
of golf  balls  requested 
by both  novices 
and  experts. We  use  named  label  sets to declare  the  names of players.  Sets  of  labels 
were  first  used  explicitly in Chapter 4. FSP also  allows  named  sets  to be declared 
as  below: 
Experts = {alice,bob,chris) 
Novices = {dave,eve) 
Players = ~Experts,Novices3 

9.2 Golf Club ~
o
~
e
~
 
191 
FSP does  not support sets of sets,  simply  sets of labels. ~onse~uently, 
the  set 
named Players is the union 
of the sets Experts and Novices, With these 
declarations,  we  can  define  the  constraint  that 
distin~ishes experts  from  novices 
as: 
~ A N ~ I C A P  
= 
({Novices.{fleed[~..N]3,Experts"need[l~~2]3 
~~Pl~yers.fleed~R13. 
-> ~ A N ~ I C A P )  
The alphabet of the  process ~ A N ~ I  
CAP consists of all  the need actions  that  can  be 
performed  by  all  players.  However,  it  only  engages  in  actions  in  which  experts 
need  one  or two golf balls and novices  need  between  three  and N golf balls.  When 
composed  with  the  player  processes, 
~ A N ~ I C A P  
inhibits  these  processes  from 
p e r f o r ~ g  
any  other need actions.  The  composition 
of players,  allocator  and 
constraint  is  described  in  Figure  9.5. 
Figure 9.5 GOLFCLUB Composition. 
Analysis of the GOLFCLU~ 
model of Figure  9.5  reveals  no  safety  violations.  The 
system  is  well-behaved  in  the  sense  that  players return the  same  number of  golf 
balls  they  get and conse~uently the  allocator  cannot  get  into  the ERROR state. The 
problem  with  this  system  is  not  safety 
but liveness.  The  following pro 
erties  assert  for  experts 
and novices  that  they  make  progress  with  respect  to 
getting golf balls. 
NOVICE = ~Novices~get[R]3 
EXPERT = ~Experts.~et~R]3 
Notice that we  have  not  specified  any  particular  number 
of  golf balls.  Getting  any 
number  satisfies  the  property.  Similarly,  we  have  not  specified  a  specific  novice
or 

expert.  Consequently, if any  novice  regularly  gets  any  number of  golf  balls, the 
property NOVICE is  satisfied and similarly  for  experts. A progress  check  against 
these  properties  reveals  no  violations. 
To reveal  the  problem  that  occurred in the 
program,  we  must  set 
up adverse  scheduling  conditions  using  the  technique 
described  in  Chapter 7 .  ~e make the put action,  which  releases  golf  balls,  low 
priority: 
I IProgressCheck = ~ O L F C L ~ ~  
>>(~layers.put~~~). 
Progress  analysis of this  system  detects  a  violation 
of the  progress  property 
NOVICE. One of the  violating  traces  produced  by  the  analyzer  is  listed  below: 
Progress violation: NOVICE 
Path  to t e r ~ i ~ a l  
set of" states: 
alice.need.1 
alice.get.1 
bob.need.1 
bob.get.1 
chris. need. 1 
chris.get.1 
dave.need.~ 
eve.need.4 
Actions in  terminal set: 
(alice.get.1,  alice.put.1,  bob.get.l, 
bob.put.1,  chris.get.1,  chris.put.1) 
This  is  the  situation  in  which  each of the  expert  players alic e, bob and c h r is 
needs  a  single  ball and the  novices d ave and eve need  four.  The  terminal  set 
indicates an infinite  execution,  in  which  the  experts  repeatedly get and put the 
golf balls  they  need.  However,  novices 
do not  get  access  because  the  situation  does 
not  occur  in  which two experts put their golf balls  without an inte~ediate get .. 
Consequently,  the  allocator  never  has  four 
golf balls  to  give  to  a  novice. 
A s  in  the 
Java  program,  experts  continuously  overtake  novices 
and consequently,  the 
novices  make no progress. 
Having  successfully  detected  the  liveness  problem  in  the  model,  the  next  step  is
look at ways of solving  the  problem and to check that  they  work  correctly in the 
model. We can  then  change  the  program  to 
reflect  the updated model. h the 
model,  we  could  simply  increase  the  number of  olf balls  with  which  the  allocator 
is  initialized. Since  we  have  a  fixed  population of golfers,  we  can  easily  increase 

9.3 Fair ~ l l o c ~ t i o ~  
193 
the  number  such  that  there  is  no  contention.  This  would  not  be  a  general  solu
since  it  would  always  be  possible  for  expert  players  to  arrive 
at a  faster  rate  and, 
as 
a  result,  novices  would  starve.  Instead,  we  arrange  it  such 
that players  wait  in an 
orderly  line  for golf balls  such  that  experts  cannot  overtake  novices. 
Rather than make  players  line up in ~rst-in-first-out (FIFO) order,  we  use  a 
ticketing  scheme.  New  tickets  are  generated  in  ascending  numerical 
order. Players 
take  a  new  ticket  from  a  dispenser  when  they  arrive 
at the golf  club and they  are 
su~sequently served  with golf balls  in  ticket order. In the  model,  we do not  require 
an infinite  number of tickets  since, as long  as we have at least as many  tickets  as 
players,  we  can  restart  the  numbering  sequence  when  the  last  ticket  has  been 
handed out. 
The  ticket dispenser  is  modeled  by  the  following  process: 
TICKET 
= NEXT[l], 
~EXT[t:T] = (ticket[t]->NEXT[t~T~+l])~ 
We must  modify  the  player  process  to  get  tickets 
and modify  the  allocator  to  only 
accept  requests  in  ticket  order.  The  modified  processes  are  shown  below. 
PLAYER 
= (n~ed[b:R~->PLAYER[b]), 
PLAYER[b:R]=  (ticket[t:T] 
->get[b][t]->put[b]->PLAYE~[b]). 
ALLOCATOR 
= BALL[N][l], 
BALL[b:B][t:T] = 
(b>O) get[i:l..b][t]->BALL[b-i][t~T~+l] 
Iput[j:l 
m .N] 
->6ALL[b+j~[t] 
) *  
The  revised PLAYER process  requests  a  ticket and uses  it  when  requesting golf 
balls  i.e. get [ 
b  ] 
[ 
t  ] 
. 
The  revised ALLOCATOR accepts get actions  in  ticket  order 
starting  with  ticket  number 1. The  ticket  scheme  increases  the size of the  model 
considerably. To compensate  for  the  increase, 
we modify  the ~ A ~ ~ I ~ A P  
constraint 
such  that  expert  players  always  request  a  single 
golf ball and novices  request  four: 
HAN~ICAP 
= 
({~ovic~s~{need[~~},Experts.need[l]~ 
+{Pl~yers.need[R]}. 
-> HAN~ICAP) 
The  golf  club  system  is  now  modeled as  follows: 

194 
C
~
a
~
~
e
~
 
9: ~ y ~ a m i c  
Systems 
To analyze  progress  for  this  system,  the  progress  properties  must 
be slightly 
revised  to  take  into  account  the  addition of the  ticket  value in the get action. 
NOVICE = ~Novices.get~R]~T]} 
EXPERT = ~ E x ~ e r t s . g e t ~ R ] [ T ~ }  
Using P rog  res 
sCh ec k, as defined  before,  no  progress  violations  are  detected. 
The  next  section  discusses  the  implementation  of  the  revised  allocator. 
F o r ~ a t e l ~ ,  
we  can  encapsulate  the  ticketing  scheme  described 
in the  previous 
section  in  a  revised ~ p l e ~ e n t a t i o n  
of the  allocator mo~tor. 
Other  than  using  this 
revised ~plementation in place of S i ~ ~ l e A l l o c ~ t o  
r, no  other  changes  are 
required  to  the  program. 
"The new  implementation,  called 
FairAllocator, is 
listed in Program 9.4. 
Program 9.4 FairAllocator class. 

~e have added two instance  variables to implement the ticketing  scheme: next 
records  the value of the  next  ticket to be  served,  and t U r n records  the  value of the 
next  ticket to be dispensed. A thread gets  a  ticket  by  recording  it 
in the  local 
variable m yt u r n . Remember that each  time  a thread calls  the  method 
get, a 
new  activation  record  is created. Consequently,  a  new  copy of myt U r n  is  also 
created  which is only  used  by  the  calling thread. A thread is  now  blocked until 
there are sufficient  golf  balls and its ticket  is the next  one to be served. To keep  the 
code  simple,  we have not dealt with resetting  the  ticket  when  the  maximum  ticket 
value is reached.  However,  by using 64-bit  ticket  values,  we have ensured that, 
with a  player arrival rate of one per second, the program  will run for 300 billion 
years before  ticket  overflow  becomes  a  problem! 
Figure  9.6  shows  a  screen dump of the  revised golf club applet. The  changed 
behavior can clearly  be seen. Altho~~gh 
two golf balls are available,  players 
are waiting because  they  cannot  overtake 
due to the FIFO ordering enforced 
by  the  ticketing  scheme. 
Figure 9.6 Golf Club applet  with fair allocation. 
The  ticketing  scheme ensures that starvation does not occur.  However,  it  does not 
use the available golf ball  resources  efficiently.  Expert 
players are kept waiting by 
novices  even though the olf balls  they  require are available. A ~odified 
scheme 
allows  experts  to  overtake  novices 
but denies starvation by setting an upper 
bound  on  the  number of times  a  novice  can be overtaken. This  revised  scheme 
is  implemented in the bounded  overtaking  allocator of Program 9.5. Essentially, 

196 
C ~ ~ t e r  
9: Dynamic Systems 
each  thread  detects  whether  it  has  been  overtaken 
by more  than  the  bound by 
comparing  its  ticket  value,  recorded  in myt u rn , 
with  the  value of the  next  ticket 
to  be  served,  recorded  in 
next. The  thread  has  been  overtaken 
if next >= 
( myt U r n+ bou nd ) . When a  thread  has  been  overtaken,  it  increments  the  instance 
variable overt a ke n . When ove r t a k  e 
n is  greater  than  zero,  all  threads  except  the
overtaken  threads  are  blocked  until  the  overtaken  threads  are  allocated  golf 
balls. 
Program 9.5 ~oundedOvertakin~Allo~ator 
class. 
The  operation of the  bounded  overtaking  allocator  can be seen  in  the  applet  dis- 
play  shown  in  Figure  ptures  the  situation  in  which  player 
overtaken by players 
il. Since  the  overtaking  bound,  whi 

9.6 ~uster-Sluve P r o ~ r a ~  
197 
set  to  three,  has  been  exceeded,  players jl and kl are  blocked  although  there  are 
two golf  balls  available.  They  will  remain  blocked  until f4 has  been  served. 
Figure 9.7 Golf  Club  with  bounded  overtaking  allocator  (bound = 3). 
In  the  golf  club  example,  when  a  player  thread  finished  playing  and  returned  its 
golf  balls, it shply terminated.  In  some  concurrent  programming  situations,  we 
may  want  to  determine  a  result  that  is  computed 
by a dyna~cally-created 
thread, 
Usually,  a s ~ ~ v e  
thread  is  created  to  perform  some  input/output 
(I/O) activity 
while  the  aster thread  that  created  it,  continues  with  some  other  activity.  At 
some  point,  the  master  must  synchronize  with  the  slave  to  retrieve  the  result of 
the 1 / 0  activity.  This ~~ster-szave 
arrangement  is  frequently  used  to  allow  the 
master  thread  to  continue  executing  while  the  slave  waits  for  a  remote  commu- 
nication  to  complete.  When  the  remote 
c o ~ ~ c a t i o n  
completes,  the  slave  thread 
terminates  and  the  master  must  obtain  the  result of the  remote c o ~ ~ i ~ a t i o
We  could  use  a  monitor  to  allow  the  slave  to  signal  when it is  about  to  terrninate. 
Alternatively,  the  master  could  continuously  test  the  status 
of the  slave  thread 
using  the isAlive ( ) method.  This  method  returns  false  when  the  thread  to  whic
it is  applied  terminates.  However,  this  busy  wait  would  consume 
CPU cycles  that 
could  be  put  to  better  use by another  thread.  To  avoid  this  busy  wait,  the  Java 
Thread class  provides  a  method  to  allow  one  thread  to  await  the  terrnination of 
another: 

19 
~
~
~
p
t
e
~
 
9: Dynamic Systems 
"
"
 
void 
 
join 
( 
~ n t e r r u p t e d E x ~ e p t i o n  
Waits  for  this  thread  to  die,  e.g. by r e t u r ~ g  
from run ( ) or as a  result 
Figure 9.8 is  the  display of an applet  that ~emons~ates 
the  operation of j o i n  ( ) . 
The  upper  display  shows  the  master  executing  concurrently  with  the  slave.  The 
slave  was  created at  the  point  the  master's  segment  changed  color.  The  bottom 
display  shows  the  point at which  the  slave  has 
t e r ~ a t e d  
and  the  master  has 
obtained  the  .result 
of its  computation.  In  the  demonstration,  the  result  is  the 
amount  the  slave  rotates  its  display  before  terminating.  The  amount 
of slave 
rotation  can be adjusted by the  slider  control  positioned  below  its  rotating  seg- 
ment.  The  amount  that  the  master  rotates  before  waiting  for  the  slave  to  terminate 
is a~justed using  the  other  slider. 
Figure 9.8 
j oin ( ) demonstration applet. 

9.6 ~ast~r-slave 
Program 
199 
By adjusting the  sliders,  it  is  possible to arrange for the master to wait  for  the 
slave  to  terminate  or  for  the  slave to terminate  before the master  gets  the  result. 
The  code  for both master and slave threads is  depicted in Program 9.6. 
Pro~ram 
9.6 Master and Slave classes. 

200 
C~za~ter 
9: ~
~
a
~
i
c
 
Systems 
The slave  thread  is  created  and  started  using  the 
st art ( ) method  provided  by 
T ~ r e a d ~ a n e l ~  
'This returns  a  reference  to  the  new  thread.  The  result  is  obtained 
from  the  slave  thread by calling  the result ( ) method  after  the  slave  thread  has 
terminated.  Note  that result () need  not  be ~
y
~
~
~
~
o
since, as long as it is 
only  called  after t e ~ ~ a t i o n ,  
there  can be no interference  between  master  and 
slave  threads. 
We  can  construct  a s a ~ s f a c t o ~  
model  of  the  master-slave  program by observing 
that,  although it creates a sequence of new slave  processes,  only  a  single  slave 
thread  is  active at any  one  time.  Consequently,  we  use  a  single  slave  process, 
which  after it terminates, immediately becomes  available to be  started agah. 
SLAVE = (start->~otate->join->SLAVE). 
The  master  thread  is  modeled by the fo~owing process: 
~ A S T E ~  
= (slave.start->rotate 
-~slave.join->rotate-~~AST 
The  master-slave  program  can  now  be  modeled as the  composition: 
1   ASTER-SLAVE = ( ~ A ~ T E R  
1 1  s1ave:SLAVE). 
The  behavior of this  model  is  depicted  in  the  labeled  transition  system of Figure 
9.9. 
rotate 
rotate 
Figure 9.9 ~ASTE~-SLAVE LTS. 

Notes and F ~ r ~ h e r  
 
201 
From the LTS, it  can  be  seen  that  the  slave  rotation  action, 
slave . 
rot  at 
e, and 
the  master  rotation  action, rot  at 
e, are  concurrent  since  they  can  occur  in  any 
order.  However,  after  the slave j o i n  action  only  the  master  rotation  action  can 
take  place, as in  the applet. The  model  can  easily  be  generalized  to  a  system  in 
which two or  more  slave  processes  are  active  concurrently. 
In this  chapter,  we  have  looked 
at programs  in  which  threads  both 
start and 
terminate  dynamically during program  execution. We have  shown  that  it  is  pos- 
sible  to  construct  satisfactory  finite  state  models  for  this  sort 
of program  by  using  a 
static  population of processes  with  cyclic  behavior.  The  model  fixes  the  maximum 
number of concurrently  active  processes  while  concurrent  thread  activation  in  the 
program is  only  limited  by  available  storage.  We  regard  a  model 
as satisfacto~ 
if 
it  exhibits  the  same  behavior as the  program  it  is  modeling  with  respect  to  safety 
and liveness  properties. We were  able  to  use  the 
golf  club  model to  investigate and 
correct  a  liveness  problem and subsequently  to  implement  that  correction  in  the 
program. 
"he main  example  concerned  a  resource  allocator  that  managed  a  pool 
of 
identical  reusable  resources.  Threads  competed  for  access  to  these  resources. 
h 
our  example,  the  resources  were golf balls.  In  computing  systems,  this  form of 
allocation  is r e ~ ~ i r e d  
for  resources  such  as  memory  pages and message  buffers. 
The results of this  chapter  show  that  the  models  we  constructed  in  previous 
chapters  for  resource  access  also apply to  programs  in  which  threads  are  created 
d~amically. For  example, the  Readers-Writers  program of Chapter 7 had  a fixed 
n ~ b e r  
of reader and writer  threads  with cyclic  behavior.  However,  the  monitor 
that  controlled read/write access would  work  equally  well  in  a  program  with  a 
dynamically  varying  number of reader and writer  threads. 
Finally,  this  chapter  demonstrated  the  use of the  Java j o i n  ( ) method  which 
allows  one h e a d  to  await  the  termination 
of another. The  example  was  a  master- 
slave  arrangement  in  which  the  master  thread  obtained  the  result 
of the  slave 
computation. 
ne of the  first  proposals  for  thread  creation  was  the 
fork L c o ~ a n d ,  
which 
the state~ent labeled L and also  allows  control  to  pass  to  the 
. h this  way, two conc~rently 
executing  threads of control  are 
and was  provided  to  allow  the two threads  to  rejoin  execu- 

tion. The  first  thread  to  reach join blocks  until  the  second  thread  also  executes  the
c o ~ a n d .  
Qdy a  single  thread  executes  after  the  join.  Unstructured  use of fork 
and  join  leads  to  extremely  complex  multi-threaded  programs.  The 
UNIX  operat- 
ing  system  has  a  version of the  fork  command  with  no  label.  The  fork  operating 
system  call  creates  a  complete  copy  of  the  calling  process  and  starts  it  executing. 
The  fork  call  returns  a  result,  which  lets  a  process  determine  whether 
it is  the 
 re^^ or c ~ i l ~ .  
To  resolve  the  problems  caused by unstructured  use of fork  and  join,  Dijkstra 
(1965)  proposed  what  later  became  the cQ~e~in..cQen 
P and Q are  executed  concurrently as separate  threads  until  both  have  terminated.
The  construct  can  easily be generalized  to  more  than two threads. It was  proposed 
for  use  in  block-structured  languages such as  Algol. In these  languages,  the  main 
struc~ring tools  are  procedures  and  procedure  activations  rather  than  classes  and
objects.  Storage  for  procedure  activations  is  managed  as  a  stack  in  these 
l a n ~ ~ a g e s
and  the  addition  of  threads  created  using  the 
CQ 
construct  requires  a 
tree of stacks,  sometimes  called  a  "cactus"  stack. 
The Java  thread  model  does  not  enforce  this  degree  of  structure  on  thread 
execution. A thread  can  continue  executing  after  the  thread  that  created 
it has 
terminated.  This  is  more  appropriate  in 
an object-oriented  language  where  we  are 
generally  less  concerned  with  the  lifetime 
of objects.  Storage  is  managed 
by a heap 
structure.  Qbjects  exist  until  they  are  garbage  collected  and  threads  exist  until 
terminate, at which point  their  storage  can  also 
be garbage  collected.  Java  provides 
the T  h  readG  rou 
p class  to  manage  collections of threads  and  to  enforce  security 
policies by dynamically  restricting  access  to Thread operations.  For  example,  a 
thread  may  only stop ( ) another  thread if both  are in  the  same  group.  By  default, 
each  thread  is  created in the  same T  h  readG  rou 
p as its  creator. We have  been  able 
to  ignore T h  readG  rou 
ps in the  examples  since  all  threads  are  created  in  the 
default  group  provided by browsers for  applet  execution. 
In this  chapter, we have  dealt  with  programs  where  dynamic  thread  creation 
and  termination  can 
be modeled by a  fixed  set 
of cyclic  processes. The  more 
general  problem  is  to  model  programs 
in which  the confi~uration of threads 
and  monitors  evolves 
as execution  proceeds.  For 
this sort of program,  using 
FSP, each  configuration  must  be  enumerated.  The  program  can  then  be  modeled 
as the  composition of its  possible 
co~igurations. To address  the  problem 
of 
describing  concurrent  systems  in  which 
co~guration changes  dynamically, 
Robin  Nlilner  introduced  the  n-calculus  (Milner,  Parrow  and  Walker,  1992).  This 
pernxits an  elegant  and  concise  description 
of dynamic  systems.  However, 
in 

Exercises 
03 
pool 
1. 
3. 
general,  these  n-calculus  descriptions  are  not  amenable  to  the 
form of state 
exploration  analysis  that  we  use  for FSP descriptions. 
e  idea of bounded  delays  to  provide 
a class of resource  allocation s~ategies is 
due  to  Dijkstra (197 a). These  strategies  can be characteri~ed as satisfying a set of 
safe  scheduling  rules  for  resource  allocation  to afixed pool of m processes  from a 
of n reusable  resources: 
No process shod wait for resources  unless  some  other  process  is  usin 
resources. 
If process i has requested  resources,  not  more  than k other  processes  can be 
iven  their  requested  resources  before  satisfying  process 
i (for  some  bound 
2 m-2). 
The  number of resources  in  the  pool  plus  the 
sum of the  number  allocated  to 
processes  equals n. 
The  first two rules  avoid  resource  starvation  for  an  individual  process  and  the 
third  rule  preserves  resource  integrity.  Allocation  from 
a pool of reusable 
resources  was  used 
as an  exercise  in  rigorous  program  design  at  Imperial 
College in  the  late 1970s. ~tudents were  required  to  design,  verify  and  implement 
a resource  allocator in ~
I
~
~
L
A
 
(Birtwistle,  Dahl,  Myhrhaug 
ef al., 1973). The rules 
were  used by ~ ~ i n g h a m  
and  amer 
(1978) as an invariant  to @de  the 
devel- 
opment  and  verification of the  program.  Rule two was  subsequently  modified as 
follows  to  permit  simpler 
i~plementations and  to  cater  for  dyn 
where  there  is  no  bound  on  the  number 
of processes 
C ~ i n g h a m ,  
1979): 
2'. If process i has  requested  resources,  not  more  than 
k' s ~ ~ s e ~ ~ e n
a~~iwing 
requests  can be serviced  before i (for  some  bound k' 2 0). 
The golf  club  problem  and  the  particular  formulation  described 
in this  book 
evolved  from  that  experience. 
9.1 The  cheese  counter in a  supermarket  is  continuously  mobbed by hungry customers. 
There  are  two  sorts 
of customer:  bold  customers  who  push  their  way  to  the  front 
of the 
mob and demand  service; and meek  customers  who  wait  patiently 
for service.  Request 
for  service is denoted  by  the  action 
g e t  C h e e S e and service  completion  is  signaled  by 
e ~ e .  
Assuming that there  is  always  cheese  available,  model  the  system 
for  a  fixed  population of two bold  customers and two meek customers,  Show that 

9.2 
9.3 
9.4 
9 *5 
meek  customers  may  never  be  served  when  their  requests  to  get  cheese  have  lower 
priority than those of bold  customers. 
To restore  order,  the  management  installs  a  ticket  machine  that  issues  tickets  to  cus- 
tomers.  Tickets  are  numbered  in  the  range 
1 .MT. 
When  ticket MT has  been  issued,  the 
next  ticket  to  be  issued  is  ticket  number 
1, i.e.  the m ~ a ~ e m e n t  
install  a  new  ticket  roll. 
The  cheese  counter  has  a  display 
that indicates  the  ticket  number of the  customer 
currently  being  served. The  customer  with  the  ticket  with  the  same  number 
as the 
counter  display  then  goes  to  the  counter and is  served.  When  the  service  is  finished, 
the  number  is  incremented  (modulo M?. Model  this  system and show  that,  even 
when  their  requests  have  low  priority, meek  customers are now  served. 
Translate  the  model of the  cheese  counter  from  exercise  9.2  into  a  Java  program.  Eac
customer  should  be  implemented  by  a 
d ~ a ~ c a l l y  
created  thread that obtains  a 
ticket,  is  served  cheese and then  terminates. 
Extend  the  master-slave  model of section 9.6 to  cater  for two slave  processes.  Now 
generalize  this  model  to  describe  systems  with N slave  processes. 
Modify  the  demonstration  applet of section  9.6  to  create two slave  processes. 

In previous  chapters,  we  have  seen  that  when  threads  interact  through  shared 
variables,  these  variables  must  be  encapsulated  in  monitor  objects  to  ensure  cor- 
rect  behavior, An alternative way of organizing  concurrent  programs  which  does 
not  required  shared  variables  is to use  message  passing. In message-passing  pro- 
grams,  processes  interact  by  sending and receiving  messages.  Processes  that  inter- 
act  solely  by  message  exchange 
do not  need 
to access shared  memory 
and 
consequently  can  be  located  on  different  computers  connected  by  a  cornmunica- 
tion  network.  However,  message  passing  is  also  frequently  used  when  processes 
are  intended  to run within  a  single  computer. 
~undamental to  message  passing  are  the  operations  to send and ~eceive a mes- 
sage.  There  are  a  surprising  number 
of different  definitions  for  these  operations  in 
message-passing  systems. We examine  the two basic  models  for  message  passing: 
s ~ ~ c k ~ u ~ u ~ s  
message  passing,  in  which  the  sender of a  message  waits  until  it  has 
been  received; and ~ s y ~ c k ~ u ~ u ~ s  
message  passing,  in  which  the  sender  does  not 
wait and messages  which  have  been  sent but not  yet  received  are  buffered.  These 
are  both  one-way  forms of c o r n m ~ c a ~ o n :  
the  messages  are trans~tted in  one 
direction  only,  from  sender  to  receiver.  In  addition, we examine  the ~endezvo~s, 
a 
two-way  message-passing  protocol  used  for  client-server  interaction. 
h 
 porta ant design  decision  in  a  message-passing  scheme  is  how  to  designate 
the  sources and destinations of messages.  Messages  can  be  addressed  directly  to 
the des~ation process  or  indirectly  to  some  intermediate  entity. 
In discussing 
s~chronous message  passing, we adopt the  scheme  used  in  Occam  (INMOS 
Ltd.,  1988a),  in  which  messages are  sent  to and received  from ck~n~eZs. 
We  will 
see  that  it  is  possible,  in  some  message-passing  schemes,  for  many  senders  to 
com~unicate with  a  receiver  through  a  single co~unication entity.  However, 

cam, we  specify  that  a  channel  connects two and  only two processes. A 
ocess  can  send  to  the  channel  and  a 
sin le  process  can  receive from the 
channel  as  shown  in  Figure 10.1. ~ o ~ u n i c a t i o n  
is  said  to  be ~ ~ e - ~ ~ - ~ ~
Figure 10.1 Synchronous  message-passing charnel. 
The  send  and  receive  operations  on charnels are: 
(e, c) - 
send  the  value of the  expression e to  channel c. "he 
send  operation  is  blocked  until  the  message  is  received  from 
c) - 
receive  a  value  into  local  variable v from  channel c. The 
ss is  blocked  waiting  until  a  message  is  sent  to  the charnel. 
The  first  process,  whether  sender  or  receiver,  to  perform  a  channel  operation  is 
blocked  until  its  partner  performs  the 
complementa~ action.  After  a c o ~ u n i c a -  
tion  occurs,  sender and  receiver  can  proceed  independently.  This  form of message 
passing is termed  synchronous,  since  the  sender  and  receiver  must 
be exactly 
s ~ c h r o ~ z e d  
for comm~ication to  occur. h o  
nous commu~cation is  that it ~plements 
a  dis 
sender's expression  is  ass  to  the 
rec~iver's l 
e  Occam  and  the 
form~lism (Hoare,  1985) 
which  inspired 
it, the 
erations  do  not  require rnes  to 
be  buffered. If the 
sender  process  is r ~ i n g  
on  the  same  computer 
as the  er  then.  the  message 
can be copied  directly  from  the  sender  into  the 
receiver's local  variable.  This 
licity  enabled  the  send  and  receive  erations  to  be  implemented 
tly  as 
~ransputer ( 
Ltd.,  1988b) 
mach 
S c!e and  for  receive  is c?v. 

10.1 S ~ n c ~ r o ~ o ~ s  
Message Pussing 
2017 
We  have  seen  that  choice  between  actions  is  important  in  both  modeling  and 
implementing  concurrent  programs.  In  Java,  choice  is  implemented  within 
a 
monitor.  The  monitor  lock  effectively  selects 
a single synchroni~ed method  activa- 
tion  to  execute  from  the  set  of  possible  activations.  The  synchronous,  message 
receive  operation  blocks  waiting  on a single charnel. How  do  we choose  between 
receiving  messages  from a set of channels?  The  solution  provided by la~guages 
such as Occam and Ada is to use 
a S 
statement. The general form of a select 
statement  is as shown  below: 
G I  ..Gn are  boolean  expressions  known 
as guards. A receive is eligible  if  the 
associated  with it evaluates  to  true.  The  select  statement  chooses 
an  eligible  r 
operation  for  which  there  is a sender  waiting to send.  The  statement Si is  executed 
after a successful  receive  on a channel  The  select  statement  then  terminates. 
If none  of  the  channels  have  waiting  sends  then  the  select  statement  blocks.  The 
reader  should  immediately  see  the  correspondence  between  this  select  construct 
and  choice  over  guarded  actions  in 
FSP. Indeed, we  will  see  later  that  this  is 
exactly  the  way  selective  receive  is  modeled  in 
FSP. As  in FSP, guards  are  usually 
onal in select stateme~ts such that an omitted guard is e~uivalent to 
frue 
. Some  select  statements  allow 
~
o
~
-
~
~
o
c
~
~
~
~
 
semantics by providing  an else 
alte~ative 
as follows: 
If a sender  is  not  waiting  on  the  channel  then  the 
e se part  is ~ e d i a t e l y  
chosen. 
Another  variation  is  to  permit a timeout as an  alternative. If no  message  arrives 
within  the  tirneout  period  then  the  statements  associated  with  the  timeout  part  ar
executed  and  the  select  terminates. 

The  send  and  receive  operations  are s y ~ e t r i c a l  
in s~chronous 
message 
sing  in  that  the  send  blocks  if  there  is  no  corresponding  receive  and  vice  versa. 
~onse~uently, 
it is  reasonable  to  suggest  that  send  operati 
S should  be  allowed 
as  select  alternatives  in  addition  to  receive  operations.  owever,  because 
of 
the  resulting ~~lementation 
complexity,  only  experimental message~passing lan- 
guages  have  included  both  send  and  receive  select  alternatives. 
We  have  seen 
in  the  preceding  chapters  that  Java 
s~pports thread  interaction 
through  monitors. How do we write message-passing programs in Java? The 
answer  is  to  use  Java’s  object-oriented p r o g r a ~ g  
facilities  to  implement  and 
encapsulate message-passing abstractions. We can 
im~lement the s~chronous 
message-  as sing channel  as  a  class.  The  outline  of  the  Java  class  that imp~ements 
the  channel  abstraction  is  defined  in  Program 10.1. 
P r o ~ r a ~  
10.1 Channel class. 
The implementati~n of C h an  ne 
1 is  a  monitor  that  has  synchronized  access  meth- 
ods  for  send  and  receive.  (The  code  may  be  found  on  the 
CD-ROM: that  accom- 
panies  this  book).  The  class  extends  the 
Select  able 
base  class  to  support  the  Java 
selective  receive ~plementation, described  later. 
To  demonstrate  the  operation 
of the C h an  ne 
l ~plemented 
in Java, we  develop 
a  simple  program  in  which  a  sender  thread c o ~ m ~ c ~ t e s  
with  a  receiver  thread 
using  a  single  channel.  The  display  for  this 
progra~ 
is  depicted  in  Figure 10.2. The 
display  depicts  the  situation  where  the  sender  thread  is  blocked  waiting to send 
the  value in e. The  receiver  has  not  yet  executed  the  receive  operation  to  copy  the 
value  into  its  local  variable v. The  sender  simply  transmits  a  sequence of integer 
values  from 0 to 9 and  then  restarts  at 0 again. 

10.1 Sync~rvnv~s 
~ ~ s s a ~ e  
Passing 
209 
Fi~ure 
10.2 Synchronous ~ e s s a ~ e - p a s s ~ ~  
applet display. 
Sender and Receiver threads. 

210 
C
~
a
~
~
e
~
 
10: Message 
 
Passing 
The  code  for  both  sender  and  receiver  threads  i  ogram 
10.2. m e  
threads  use  the  display  class  that  we  defined  in 
lotcanvas. The 
threads  and  channel  are  created by the  following  Java  code: 
Channel 
 
chan 
= 
Channel(); 
r(chafl,senddisp)); 
ceiver(chafl,recvdisp)); 
where t x and r x  are  instances of the  thread  display  class, T h read  Pan 
e l, and 
sendisp and recvdisp are  instances of ~ ~ o t c a f l v a s .  
~ i l e  
the  code of Program 10.2 is  straightforward,  a  subtlety  can  lead  to  pro- 
blems if the programer is  not  aware of it. Our  implementation of channels  in 
Java  simply  copies  the  reference  to an object from  sender  to  receiver, it does  not 
make  a  copy of the  referenced  object.  Consequently, it is  possible  for  the  receiver 
to modify  an  object  held  by  the  sender.  When  messages  are  passed by reference, 
the  safest  discipline  to  adopt  is  that  a  sender  should  not  access 
an object if it has 
sent  its  reference  to  another  thread. If a  thread  needs  to  reference  the  object  in  the 
future, it should  copy it before  sendin it. With  this  discipline,  a  thread  is  guar- 
anteed  mutually  exclusive  access  to  the  objects  it  has  received  but  not  sent.  The 
sample progra~ obeys  this  discipline  even  though  the  receiver  does  not  modify 
To illustrate how  message  passing  programs  are  modeled,  we  start  with  the 
simple  Sender-Receiver  example of the  previous  section.  The  model of the  sender 
thread  is: 

20.1 S ~ n c ~ ~ o ~ o ~ s  
 
s s a g e  
Passing 
211 
M = 0..9 
R = SENDER[O], 
R[e:M] =(chan.send[e]-~~ENDER~(e+i)%lO~). 
where c  h  an 
. 
send [ 
e 1 models  the  action of sending  a  value e to  a charnel chan. 
The  model of the  receiver  thread  is: 
R = (chan.receive[v:M]->RECE~VE~). 
where c  h 
an . 
receive [ 
v : 
M ] models  the  action of receiving  a  value  into  a  local 
variable v of type M from  channel chan. The  remaining  question  is  how  to  model 
the  channel  entity.  In  fact, 
as sending and receiving  are  synchronous,  they  become 
the  same  action  in  the  model.  Consequently,  we 
do not  need  a  separate  process  to 
model  a charnel; we  simply  rename  send and receive  to  be  the  same  action. We 
can thus rename  both  the  action c han . 
send and c han . 
receive to be  the  action 
c han shown  in  the structure diagram of Figure 10.3. 
= ( ~ E ~ ~ E R  
1 I R E ~ E ~ V E R )  
/{chan/chan.{send,receive}}. 
Figure 10.3 Modeling  synchronous  message  passing. 
To avoid  the  relabeling,  we  could  have  modeled  the  send  action  directly  as 
c  h 
an [ 
e ] and the  receive  action as c  h 
an [ 
v : 
M ] . In the  following, we model  syn- 
chronous  message  passing  by: 
The  only  difference  between  the  model  for  send 
and receive  actions  is  that receive 
is  modeled as a choice  between  a  set of values M which  can  be  sent  over  a  channel 
specifies  a  specific  value e. In  the  example,  the  values  are 
in the 
range 0..9. The  composite  behavior  for  the  example  is  given  by  the LTS of Figure 
10.4. 

212 
C ~ a ~ ~ e ~  
10: Message Passing 
chan.0 
 
chan.1 
 
chan.2 
 
chan.3 
 
chan.4 
 
chan.5 
 
chan.6 
 
chan.7 
 
chan.8 
chan.9 
Figure 10.4 SyncMsg labeled  transition  system. 
To explain  how  to  model  and  implement  selective  message  reception,  we  use  the 
car  park  example from Chapter 5. In  this  example,  an  arrivals 
arrival  of  a  car at the  car  park  and  the  departures  gate  signals  the  departure of a 
car from  the  car  park.  The  model  for  the  car  park  is  repeated in Figure 10.5. 
CARPARKCONTROL (N=4.) = SPACES[N], 
§PACES[i:O."N] = (when(i>O)  arrive->§PACES[i-l] 
= ( w h e ~ ( i c ~ )  
depart->S~AC 
)
m
 
A ~ R ~ V A L ~  
= (arrive->AR~IVAL~)~ 
DEPARTURES = (depart->D 
1 ICARPARK = 
(ARRIVALS 
Figure 10.5 Car  park  model. 
Instead of implemen~g the CARPARKCONT  OL process  as  a  monitor  with 
arrive and depart access  methods,  we  implement  the  process 
as a thead 
which  receives  signals  from  channels  called a r rive and de part . The  behaviors 
f  the 
ARR~VALS and D 
S processes  are  implemented 
by a  common 
sg Gat e class as show  ram 
10.3. A thread  created  from 

10.2 S ~ ~ c ~ r o ~ o ~ s  
Message Pussing 
213 
sends  messages  to  the charnel with  which  it  is  initialized.  Messages  in  this  exam- 
ple  contain  no  orm mat ion. They  signal  the  arrival  or  departure  of  a  car 
from  the 
car  park. ~onse~uently, 
the  message  is  always  the  same  instance 
of the  Java 
Ob j e c t  base  class. 
Program 10.3  ate class. 
The  ans sf or mat ion of the CAR~ARKCO~T~OL 
process  into  a  thread  using  message 
passing  is straightfo~ard since,  as  we  noted  earlier,  choice  and  guarded  actions 
express  the  behavior 
of selective  receive. An outline ~plementation for  the 
C~R~ARKCO~TROL 
process  using  a  selective  receive  is  shown  below: 
Msg~arPar~:: 
e c ~ i ~ e ( a ~ ~ ~ ~ e )  
=> ++spaces; 
r ~ c e i v e ( ~ ~ a ~ ~ )  
=> - -spaces; 
or 
We  use  the  object-oriented  facilities 
of Java  to ~ p l e m e n t  
the  selective  receive 
abstraction in the  same  way  that  we  packaged  channels as a  class.  Channels  are 
derived  from  the 
Select  able base  class,  which  provides  the  public  method, 
guard . A selective  receive  is co~structed using  the S e l e c t  class,  which  provides 
the add public  method  to  include  a 
Selectable object  into  a  selective  receive. 

Using  these  classes,  the  outline of the  message  version of car  park  control  can be 
translated  into  Java, as shown  in  the ~ s ~ C a r ~ a r k  
class of Program 10.4. 
Program 10.4 ~sgCarPark 
class. 
A selective  receive  is  executed  by  invoking  the c h oose ( ) method  on  a Select 
object.  This  returns  the  index of a Select  able object  which is ready. A selectable 
channel  is ready if the  sender  has  performed a send  operation. The  index  is  allo- 
cated  to  a  selectable  object  based  on  the  order  that  the  object  was  added  to  the 

select  object.  Thus, in  the  example,  the depart charnel is  allocated  index 1 and  the 
a r r 
live charnel index 2. When  receive  on  the  chosen  channel  is  executed,  it  does 
not  block  since  the 
charnel is ready. If no selectable  objects  are  ready 
then 
choose ( ) blocks  the  calling  thread  waiting, in  the  example  case,  for 
a send  on 
either  the  leave  or  the  arrive charnel. 
This  rather clmsy coding of a  selective  receive  in  Java  would  normally 
be done 
by a  compiler  if  we  had  used  a  message-passing  langua  e.  However,  we  have 
used  Java so that  readers  can  run  message-passing  programs  in  the  same  envir- 
oment as the  rest of the  example  programs  in  the  book. 
In as~chronous message  passing  the  send  operation  does  not  block,  as  in  the 
synchronous  scheme,  but  continues.  Messages  which  have  been  sent  but  not 
received  are  held  in  a  message  queue.  Senders  add  messages 
to the  tail  of  the 
queue  and  a  receiver  removes  messages  from  the  head. 
R e  abstraction we  use  for 
as~chronous 
message c o m m ~ i c a ~ o n  
is  termed  a port. As  shown  in  Figure 10.6, 
many  senders  may  send  to  a  port  but  only 
a single  receiver  may  receive  messages 
from it. C o ~ ~ i c a t i o n  
is  said  to be ~ ~ ~ y - ~ o - o ~ e .  
Figure 10.6 Asynchronous message-passing port. 
A port  is  a (concep~ally)   bounded first-in-~rst-out (FIFO)  queue of mes- 
sages. R e  send  and  receive  operations  on  ports  are  defined as follows: 

216 
C~up~er 
10: ~essuge 
Pussi~g 
, 
p) - 
send  the  value of the 
ression e to  port p. The  process  calling 
nd  operation is not  blocke 
he  message e is  queued at the  port if 
the  receiver  is  not  waitin 
ive(p) - 
receive  a  value  into  local  va 
le U from  port p. The 
rocess  is  blocked if there  are  no  mess 
queued  to  the  port. 
This form of comm~cation is termed  asynchronous  since  the  sender  proceeds 
 dependently of the  receiver. ~ynchroniza~on 
only occurs  when  the  receiver 
waits  for  a  sender if the  queue of messages  at  the  port  is  empty. 
If send  operations 
can occur more frequently than receive, then there is no upper bound on the 
length of queue  required  and conseq~ently no upper  bound  on  the  amount 
of 
store  required  to  buffer  messages.  Obviously,  in  a  real  computer  system  there 
is a 
fixed  bound  on  the  buffer  space  available. 
It is  the responsibili~ of the  designer  to 
emure that  a  message-passing  program  does  not  exceed  this  bound. 
A process  may  selectively  wait  for  messages  from  a  set of ports  using  exactly 
the  same  select  construct  described  earlier  for s ~ ~ h r o n o u s  
message  passing. 
We  can ~ p l e m e n t  
asynchronous  message  passing in Java in the  same  way as we 
~plemented channels.  The  outline of the  Java  class  that  implements  the  port 
abs~action is  described in Program 10.5. 
~ ~ o ~ r a m  
10.5 Port class. 
The Port class  extends  the S 1 e c  t 
ab1 e base  class  so  that  receive  operations  on 
ports  can be combined  in  selective  receive  operations  as 
de~cribed 
in  section 20.1.4 
for  channel  receives.  In  fact,  the ~plementation permits  channels  and  ports  to be 
mbined  in  the  same Select object  since  they  are  both  derived  from  the  same 
electa~le 
base  class. 

10.2 ~ s y n c ~ r o n o ~ s  
~essuge Passing 
217 
The  operation of as~chronous 
message comm~cation 
can be observed  using 
the  applet  depicted in F i p e  10.7. 
Figure 10.7 A s ~ c h r o ~ o u s  
message-passing applet display. 
The  demonstration  program  has 
two sender  threads  which  each  send  a 
sequence  of  messages  with  values 
0..9 to  the  receiver  thread  via  a  port.  The 
receiver  thread  receives  a  sequence 
of values,  which  is  a  merge  of  the 
two 
sequences  sent.  The  display  depicts  the  situation  in  which 
Sender 1 is  about  to 
send  the  value 9 and Sende r2 is  about  to  send  the  value 8. The  port  is  currently 
empty  and  the  receiver  blocked.  The  receiver  thread  performs  four  receive  opera- 
tions  on  every  revolution 
of its  display  while  the  senders  perform  a  single  send 
on 
each  revolution. ~onsequently, if all  three  threads  are  running,  the  port  will  have  a
maximum  of two messages  queued  and  for  most 
of the  time it will be empty. 
However, if the  receiver  thread  is  suspended  using  the  button  then  the 
senders  continue to run queuing  messages  in  the  port.  In  this  situation,  the  applet 
will  eventually  terminate  with  a  Java O ~ t O ~ ~ e ~ o r y  
runtime  error.  The  code  for 
sender  and  receiver  threads  is  given  in  Program 10.6. 

218 
C ~ a p ~ e ~  
10: Message 
 
Passing 
Program 10.6 Asender and Areceiver classes. 

10.2 Async~rono~s 
Message Passi~g 
219 
The  threads  and  port  are  created by the  Java  code: 
Port () ; 
sender(port,sendldisp)); 
Asender(port,send2disp)); 
eceiver(port,recvdisp)); 
where txl, tx2 and rx are  instances of Threadpanel and sendldisp, 
send2disp and recvdisp are  instances of SlotCanvas. 
We  modeled s~chronous 
communication  directly  as  actions  shared  between two 
processes. A channel  was  modeled  as  the  name 
of a  shared  action.  Modeling 
asynchronous co~unication is  considerably  more  difficult. The  first  difficulty 
arises  because  of  the  potentially  unbounded  size 
of port  queues.  As  discussed 
earlier,  models  must be finite so that we  can  carry  out  analysis.  Consequently, 
we  cannot  model  a  port  with  an  unbounded  queue.  Instead,  we  use  the  solution 
we  adopted  in  modeling  semaphores  in  Chapter 5 and  model  a  finite  entity  that 
causes  an  error  when it overflows.  The  model for a  port  that  can  queue 
up to  three 
messages  is: 
PORT 
// empt~ state, only send per~itted 
PO~T[h:M] 
// one message q ~ e ~ e d  
to port 
= (send[x:M]  ->PORT[x]), 
= (send[x:M] ->PORT[x][h] 
Ireceive[h]->PORT 
)II 
ORT [ 
t : 
S ] [ 
h : 
M ] // two or more ~ e s s a g e s   q ~ e ~ e d  
to port 
= (send[x:M]  ->PORT[x][t][h] 
~receive[h]->PORT[t] 
The  set S defines  the  set of values  that  can be taken by the  tail of the  queue  when 
the  queue  contains two or more messages.  However,  care  must be taken  when 
modeling  queues  since  the  port  described  above,  for  a  queue 
of up to  three 
messages,  generates  a  labeled  transition  system  with 
1111 states. A port to 
queue  up  to  four  messages  can  be  produced 
by redefining  the  set 
S to be 
{[M],  [M]  [M],  [M] 
[M]  [M]}. Extending  the  model  to  queue  up  to  four  messages 

220 
C ~ a ~ t e r  
10: Message 
 
Passing 
would  generate an LTS with 11111 states. h general,  the  model of a  queue  with n 
places  for  messages  which  can  take up to x distinct  values  requires (x"'l-l)/(x-l) 
states.  In  modeling  asynchronous  message-passing  programs,  care  must  be  taken 
to  restrict  both  the  range of data  values  that  a  message  can  take and the  size of 
queues.  Otherwise,  intractably  large  models  are produced. The port  model  with 
11  12 
states  is  clearly  too  large  to  view  as  a 
graph. To check that  the  model 
describes  the  correct  behavior,  we  can  abstract  from  the  value of messages and 
examine  only  send and receive  actions. To do this,  we  relabel  the  send 
and receive 
actions  as  shown  below: 
I IAPORT = PORT 
/~send/send[~],rec~ive/receive~~]3. 
The  minimized LTS for  this  abstracted  port,  called APORT, consists of only  four 
states and is depicted  in  Figure 10.8. 
send 
 
send 
 
send 
send 
Figure 10.8 APORT labeled transition system. 
Figure 10.8 clearly  shows  that  the port accepts up to  three  consecutive  sends. A 
fourth  send  causes  the port queue  to  overflow and the port to  move  to  the  error 
state. 
With  the  model  for  a  port,  we  can  now  provide  a  complete  model  for  the 
example  program of the  previous  section. The sender and receiver  threads  are 
modeled  as: 
~ S E ~ D E R  = ASENDER[O], 
A S E ~ D E R [ e : ~ ~  
= (port.sen~~e~-~ASE~~ER[(e+l)~lO]). 
ARECE~~ER = (por~.receive[v:~]->ARECE~V~R). 
The  composition of tvvo sender  processes and a  receiver  process c o ~ u ~ c a t i n g  
by  a  port  is  described  in  Figure 10.9. 

I lAsyncMsg 
= (s[l..2]:A~E~~ER 
1 1  port:PORT 1 1  ARECEIV 
/{s[l.,2~.port.send/port.send3. 
Figure 10.9 Asynchronous  message  applet  model. 
A safety  analysis  of As y n cMsg produces  the  following  output: 
Trace to property  violation in port:PORT: 
s.1 .port.send.O 
s.1 .port.send.l 
s.1 .port.send.Z 
s.1 .port.send.3 
This  is  the  situation  where  a  fourth  consecutive  send  causes  the  port  queue  to 
overflow.  Since  the  model  abstracts  from  time,  it  takes  no  account of the  fact  that 
in  the  implementation,  we  have  made  the  receiver 
.run. 
faster  than  the  senders. 
However,  queue  overflow  (or  rather  memory  overflow)  can  occur  in  the  imple- 
mentation if we  slow  the  receiver  by  suspending it. The  demonstration  applet  is 
inherently  unsafe  since,  no  matter  how  large  the  port  queue,  it  can  eventually 
overflow. 
~ e n ~ e ~ ~ u u s ,  
sometimes  called ~ e ~ u e s t - ~ ~ Z ~ ,  
is  a  message-passing  protocol  used  to 
support  client-server  interaction.  Client  processes  send  request  messages  to 
a 
server  process  requesting  the  server  to  perform  some  service.  These  request  mes- 
sages  are  queued  to  an entry in  FIFO  order.  The  server  accepts  requests  from  the 
entry and on completion of the  requested  service  sends  a  reply  message  to  the 
client  that  made  the  request.  The  client  blocks  waiting  for  the  reply  message. 
Rendezvous  involves 
~ ~ n ~ - t u - u n e  
c o ~ ~ c a t i o n  
in  that  many  clients  may 
request  service  from  a  single  server.  The  reply  to  a  request  is  a 
une-tu-une commu- 
nication  from  the  server  process  to  the  client  that  requested  the  service.  The  pro- 
tocol  is  depicted  in  Figure 10.10. 
The abstraction  that  supports  rendezvous  is  termed 
an entry. The  operations  on 
entries  are  defined  as  follows: 

222 
C ~ a ~ t e r  
10: Message 
 
Passing 
res = call(entry,reg) 
! 
I 
--" 
request 
! 
message 
suspended 
I 
perform service 
I 
I 
Figure 10.10 Rendezvous  message-passing protocol. 
res = call(e,req) - 
send  the  value req as  a  request  message  which  is  queued 
to  the  entry 
e. The  calling  process  is  blocked  until  a  reply  message  is 
received  into  the  local  variable res. 
t(e) - 
receive  the  value of the  request  message  from  the  entry 
e 
into  the  local  variable req. If there  are no request  messages  queued  to  the 
entry,  then  the  server  process  is  blocked. 
ly(e,res) - 
send  the  value res as  a  reply  message  to  entry e. 
The  term  "rendezvous"  for  this  form of interaction  was  coined by the  designers of 
the  Ada  programming  language  (Department of Defense, 1983) in which it is  the 
main  process  interaction  mechanism. ~ e ~ ~ e z v o ~ s  
captures  the  essence of the  inter- 
action  since  client  and  server  meet  and  synchronize when  the  server  performs  a 
service  for  the  client. 
As with  channels  and  ports,  a  server  process  may  selectively  wait  for  messages 
from a  set of entries  using  the  select  construct  described  in  section 10.1.1. 
We i~plement the  rendezvous  entry  abstraction  using  the  port  and 
charnel 
abstractions  defined in  the  previous  sections.  Remembering  that  request  commu- 
nication is many-to-one,  we  use  a  port  to 
~ p l e m e n t  
it. Since  reply c o ~ u ~ c a t i o n
is  one-to-one, we  can  use  a  channel.  Each  client  that c o ~ u n i c a t e s  
with  a  server 
via an  entry  requires  its own charnel to receive  replies.  The  entry  implementation 
is  depicted in  Program 10.7. 

Program 10.7 Entry class. 
The En t r y class  extends Po r t , 
which in turn  extends Se l e  c 
t ab l e. ~ o ~ e ~ u e n t l y
Entry objects can be added  to  a Select object  in  the  same  way  as Channels and 
Ports. The c a l l  method  creates  a  channel  object  on  which  to  receive  the  reply 
message. It then  constructs  a  message,  using  the 
CallMs 
S, consisting  of  a 
reference  to  this  channel  and  a  reference  to  the req object 
has  queued  this  message  send,  it  is  suspended 
by a r e  c  e i v  e on the  channel. 
The  server  calls 
accept 
t  a  message  from  the  entry.  The 
accept method 
keeps a copy  of  the  channel  reference  on  which  to  reply in the  local  variable cm. 
The reply method  sends  the  reply  message  to  this  channel.  Note  that  although 
the reply method  performs  a s~chronous 
send  operation,  this  does not  suspend 
the  server  since  the  client  must  a  d  waiting  on  the  reply  channel. 
Call, accept and reply are  not  methods  since  client  and  server 
threads do not  share  any  variable  The 
cm variable is only  accessed 

by the  server  thread.  Client  and  server  threads  interact  via Port and Gh an n e l 
objects,  which  are  thread-safe. 
Runtime  systems  for  Ada  have  much  more  efficient 
impleme~tations of ren- 
dezvous  than  the ~plementation des~ribed here.  They  exploit  the  fact  that,  since 
the  client  is  blocked  during  a  rendezvous,  when  client  and  server  are  on  the  same 
computer  messages  can  be  copied  directly  between  client  memory  and  server 
memory  without  buffer 
The  applet  display of Figure  10.11  demonstrates  the  operation of rendezvous 
using  the Entry class.  The  display  depicts  the  situation  where  both  clients  have 
called  the  server  and  are  waiting  for  a  reply.  The  server  is  currently  servicing  the 
request  from  Client A. The  color of the rota~ng segment of the  Server  is  set  to  the 
same  color  as  the  client it is servicing. 
Figure 10.11 Rendezvous message-pass~g applet display. 
The  code  for  client  and  server  threads  is  given  in  Program  10.8.  The  threads  an
entry  for  the  demonstration  program  are  created by the  following  Java  code: 
Entry entry = 
Entry (1 ; 
l e n t   ( e n t r y ,   ~ l i e n t A d i s ~ ,  
"A" ) ) ; 
n t  (entry,  client 
r(entry,~erverd 


226 
C
~
a
~
~
e
~
 
10: Message 
 
Passing 
To  model  rendezvous comm~ication, we  can  reuse  the  models  for  ports  and 
charnels in  the  same  way  as  we  reused  the  implementation  classes 
Port and 
Channel in ~ ~ l e m e n t i n g  
the En t r y class. In modeling  the  demonstration  pro- 
gram, we  ignore  the  message  data  values  and  concentrate  on  interaction. 
Consequently,  the  message  that  is  sent by a  client  to  the  server  consists 
of only 
the  reply  channel.  This  message  is  defined  by: 
= {replyA~reply~} 
The PORT process  queues  messages of this type. An entry  is  modeled  by: 
This  reuses  the PORT definition  from  the  previous  section  and  relabels send to be 
call and receive to be accept. The  server  thread  is  modeled by: 
SERVER = (entry.~ccept~ch:~]->[ch~->~E~VE~). 
The  server  accepts  a  message  from  the  entry  consisting of the  name of the  reply 
channel  and  then  replies  using  this 
charnel name.  Remember  that  we  model 
synchronous commu~cation by a  single  shared  action which is  the  name of the 
charnel. The  client  is  modeled  by: 
CLIENT(CH='reply) = (entry.call[CH] 
->~CH]->CLI~NT). 
where CH is  a  parameter  initialized  to  the  action  label 
re ply. In FSP, action  labels 
used  as  parameter  values  or  in  expressions  must 
be prefixed  with  a  single  quote  to 
distinguish  them  from  variables.  The 
CL1 ENT process  sends  this  parameter,  which 
names  the  reply  channel,  to  the  entry  and  then  waits  for  the  reply.  The  composite 
model  describing  the  demonstration  program  is  shown  in  Figure 10.12. 
Figure 10.12 Rendezvous  applet  model. 

20.3 ~ e ~ ~ e z v o ~ s  
227 
We do  not  need  to  prefix  the  client  processes  since  their  parameter  values  lead 
to each 
 
having 
 
a 
 
distinct 
 
alphabet. 
 
For 
 
example, 
 
the 
 
alphabet 
 
of 
CL~E~T('rep1yA) 
is {entry.call. replyA,  replyA). 
The  following  trace  is 
the  scenario  in  which  both  clients  request  service  and  the  server  has  accepted 
the  request  for  client A and  replied: 
entry , 
call. replyA 
entry.call.reply~ 
entry . 
accept replyA 
replyA 
A safety  analysis  of Ent ryDemo reveals  no  deadlocks  or  errors.  Rendezvous  com- 
munication  means  that  each  client  can  only  have  one  outstanding  request  queued 
to  the  server  entry at any  one h e .  Consequently, in our  demonstration  program 
with two clients,  the  maximum  entry queue  length  is two. In  the  model,  we  have 
used  a  port  capable of queuing  three  messages.  We  can  redefine  this  to  be  a  queue 
with  maximum  capacity two by redefining  the  set S to be { 
[ 
M ] } 
. 
A safety  analysis 
of  this  system  reveals  that  the  entry  queue  does  not  overflow. 
From  the  viewpoint of a  client,  apart from syntactic  differences,  a  call on  an  entry 
is  the  same as calling  a  monitor  access  method.  The  difference  between  rendez- 
vous  and  monitor  method  invocation  is  to  do  with  how  the  call  from  the  client  is 
handled.  In  the  case  of  a  rendezvous,  the  call  is  handled by a  server  thread  that 
accepts  the  call  from  an  entry.  In  the  case 
of method  invocation, the call  is  serviced 
by execution of the  body  of  the  method.  The  method  body  is  executed 
by the  client 
thread  when  it  acquires  the  monitor  lock.  We  saw  how  a  bounded  buffer  can  be 
implemented  by  a  monitor 
in Chapter 5. The  same  buffer  semantics  from  the 
viewpoint  of  the  client  can  be  implemented  using  rendezvous 
c o m ~ u ~ c a t i o n  
as sketched  in  outline  below: 
Buffer:: 
entry put,  get; 
//number of items in buffer 
s e ~ ~ c t  
en ( c o u ~ ~ < s ~ z e )  
an ~ = a c c ~ ~ t ( p ~ t )  
=> 
++count; 
//insert item o into buffer 

228 
~ ~ a p ~ e r  
10: Message Passing 
Or 
when (count>O) an. 
--count; 
//get  item o from  buffer 
Mutual  exclusion  is  ensured by the  fact  that  the  buffer  state  is  encapsulated  in  the 
server  thread.  Since  the  server  thread  processes  only 
one  request at a  time,  mutual 
exclusion  is  guaranteed.  Which  implementation  is  more  efficient,  monitor  or  ren- 
dezvous? h considering  this  question,  we  should  compare  rendezvous as imple- 
mented  in  Ada  rather  than  the  example  implementation  presented  in  this  chapter. 
However,  even  with  an  efficient 
~plementation, in  a  local  context,  where  the 
client is located on  the  same  computer as the  server,  the  monitor  implementation 
is  more  efficient  since  the  rendezvous  implementation  always  involves two con- 
text  switches.  For  each  rendezvous,  there  is  a  switch  from  client  thread  to  server 
thread  and  then  back  from  server  to  client.  A  method  call 
to a  monitor  may  require 
no  context  switch:  for  example,  a  get  from  a  non-empty  buffer  when  the  producer 
does  not  currently  have  the  monitor  lock.  However,  the  situation  is  not 
so clear-cut 
when  the  client  is  located  on  a  different  computer  to  the  server.  In  this  situation, 
the  rendezvous  may be better for  the  following  reasons. 
If the  client  is  remote  from 
the  monitor,  then  a  protocol  such  as  Java’s  Remote  Method  Invocation 
( W I )  must 
be  used  to  transfer  the  client’s  invocation  to  the  remote  computer  on  which  the 
monitor  is  located.  At  this  location, 
M I  creates  a new thread to perform the 
invocation on the monitor on behalf 
of the  client.  This  thread  creation  is  not 
required by a  remote  rendezvous. 
We  have  used  the  issue of efficiency  to  focus on  the  differences  in  implementa- 
tion  between  rendezvous  and  monitor  method  invocation.  However,  we  can 
model  programs at a  sufficiently  abstract  level  that  the  model  can  be  implemente
by either  mechanism.  For  example,  the  model  for  the  bounded  buffer  presented  in 
Chapter 5 captures  the  behavior 
of both  the  monitor 
~plementatio~ 
and  the 
rendezvous im~lementation we  have  outlined  in  this  section.  This  illustrates  a 
more  general  point.  The  modeling  techniques  we  are  using  to  describe  and  ana- 
lyze  concurrent  programs  are  not  restricted  to  programs  implemented  in  Java. 
They  can  be  used  to  model  message-passing  programs  with  equal  facility. 

"his chapter has described  three  different  kinds of message-passing  mechanism. 
In s y ~ c ~ ~ o ~ o ~ s  
message  passing,  the  sender 
of a  message  is  blocked  until 
it is 
received. In ~ s y ~ c ~ ~ o ~ o ~ s  
message  passing,  the  sender  continues  after 
sending. 
Messages that have  been  sent and not  received  must  be  buffered. "he buffering 
requirement of as~chronous message c o ~ ~ c a t i o n  
is  potentially unbounded. 
In r e ~ ~ e ~ ~ o ~ s ,  
a  two-way  message-passing  protocol  provides  for  client-server 
interaction.  Selective  receive  provides  a  way 
of irnplementing guarded actions 
in  message-passing  systems. 
To illustrate  message-passing  programs,  we  developed  three  different  abstrac- 
tions:  the Channel for s ~ c ~ r o n o u s  
message  passing,  the Port for  asynchronous 
message  passing and the En t r y  for  rendezvous c o ~ ~ c a t i o n .  
The  irnplementa- 
tion  relationship  between  these  classes  is 
s ~ a r i z e d  
in  the  class  diagram 
of 
Figure 10.13. In constructing Entry directly  from Port we  have  deliberately 
ignored  good  object-oriented p r o g r a ~ g  
practice in the  interests of simplicity. 
The  problem  we  have  ignored  is that it  is  possible  to  invoke both send ( ) and 
r e  c e i v  e ( ) methods  on En t r y objects. A more  robust  implementation would 
introduce  a port implementation  class with protected send and receive  methods 
which would be  used  by both Port and Ent  ry to  implement  their  public  inter- 
faces. 
l choose() l 
Figure 10.13 Message-passing  classes. 

230 
C ~ p t e r  
10: Message Passing 
Synchronous  communication  was  introduced by C.A.R, Hoare  (1978) in his  paper 
on  communicating  sequential  processes.  The  ideas  in  this  paper  led  both  to  the 
CSP formalism  (Hoare,  1985)  and  to  the  Occam 
pr 
~
n
g
 
language (
I
~
Q
Ltd.,  1988a)  designed by David May, Occam  was 
o program  the  Transputer 
(INMQS  Ltd.,  1988b),  which  supported  both  intra-  and  inter-processor  synchro- 
nous comm~ication in  hardware. 
Asynchronous  message  passing  originated 
in opes  ting  systems  in  the  late 
1960s.  Brinch-Hansen  (1970) 
ib 
a  set  of  message-passing  primitives  for 
the  Danish RC4000 computer.  r  (1971) 
~ntroduced the  notion of a  com- 
munication  port.  Asynchrono  assing  operations  can  now 
be found  in 
all  operating  systems  which 
S to c o m m ~ c a t e  
with  other  machines 
on a  network.  For  example,  a  port-like  abstraction  called  a  socket 
and 
 
a 
 
variety 
of calls 
 
for 
sen 
 
Asynchronous 
 
message 
passing 
 
has 
 
been 
 
included 
 
i 
 ramming 
 
languages 
and 
 
in 
 
the 
t e l e c o ~ u ~ c a t i o n s  
lang 
 
1993). 
 
However, 
 
neither 
s~chronous 
nor 
 
asynchronous 
 
mes 
 
es 
 
have 
 
found 
 
their 
 
way 
into 
 
a 
 
widely-ac 
 
ed 
 
general-purpose 
 
language. 
 
Consequently, 
message 
 
passing 
 
ncurrent 
p r o g r ~ ~  
el of operating 
 
system 
calls 
The 
 
name 
 
”rendezvous” 
 
e 
 
programing 
language 
 
(Department 
of 
only 
 
the 
 
basic 
 
Ada 
rendezvous 
 
scheme 
 
in 
 
thi 
 
mitted 
 
details 
 
concerned 
 
with 
 
timeouts 
on 
 
calls 
 
and 
 pts, 
h a  select,  and so on.  These a ~ d i t i o ~ s  
make  the  semantics of Ada inter-process 
comm~ication quite  complex.  In  particular,  they  make  extending  the  Ada  ren- 
dezvous from a  local  interaction  mechanism  to  a  remote  interaction  mechanism 
di~~cult. 
The  use of rendezvous  style commu~cati~n 
is,  of  course,  not  restricted  to 
Ada.  Many  operating  system  messa  assing  primitives  support  request-reply 
message  passing  reasonably  directly  example, 
recvf rom ( ) on a UNIX data- 
gram  socket  returns  an  address  which  can 
be used  to  send  a  reply  message.  In 
conclusion,  the  us 
of request-reply  ssage  protocols  for  client-server  interac- 
tion  is  pervasive. 
10.1 Ignoring  the  feature  that  allows  objects of the Channel class  to be used  in a select, 
program  a  monitor  in  Java  that imple~ent~ 
the  send  and  receive  operations on chan- 
nels (i.e. consider  that Channel. is not  derived  from Selectable). 

Exercises 
231 
0 ~ ~ ~ 0 ~ ~ 2 :  
Test  your  implementation by using it, instead of the  provided Channel 
class,  in  the  synchronous  message  passing  demonstration  applet. 
10.2  Modify  your ~plementation of the  previous  exercise  such  that  the  receive  operation 
can  time  out.  The  receive  becomes: 
Object receive(int  timeout); 
If the theout period  expires  before a message is sent to the  channel,  the  receive 
operation  returns  the  value n U 11. 
10.3 Pesign a message-passing  protocol  which  allows a producer  process comm~cating 
with a consumer  process by ~
s
y
~
c
~
~
~
~
o
~
s
 
messaging  to  send  only a bounded  number 
of messages, N, 
before  it is blocked  waiting  for  the  consumer to receive a message. 
Construct a model  which  can be used to verify  that  your  protocol  prevents  queue 
overflow  if  ports are correctly  dimensioned, 
0
~
~
~
0
~
~
~
~
 
Pesip and  implement an applet  which  demonstrates  the  operation 
of 
your  protocol. 
10.4  Translate  the  bounded  buffer  outline of section  10.3.3 into Java  using  the Entry and 
Select classes. 
0
~
~
~
~
~
~
~
:
 
Modify  the  bounded  buffer  applet 
of Chapter 5 to use  this hplementation 
rather  than  the  monitor. 

This Page Intentionally Left Blank

The  term ~ ~ c ~ ~ t e c ~ ~ ~ e  
is  used  in  this  chapter  to  mean  the  process  structure  of  a 
concurrent  program  together  with  the  way  in  which  the  elements  of  the  program 
interact.  For  example,  the  client-server  architecture  of  Chapter 
10 is  a  structure 
c o n s i s ~ g  
of  one  or  more  client  processes  interacting  with  a  single  server  process. 
The  interaction  is  bi-directional co~isting of a  request  from  a  client  to  the  server 
and  a  reply  from  the  server  to  the  client.  This 
orga~~ation 
is  at  the  heart of many 
distributed co~puting applications.  The  client-server  architecture  can  be  described
independently  of  the  detailed  operation of client  and  server  processes.  We  do  not 
need  to  consider  the  service  provided by the  server  or  indeed  the  use  the  client 
makes of the  result  obtained  from  requesting  the  service.  In  describing  the  con- 
current  architecture  of  a  program,  we  can  ignore  many  of  the  details  concerned 
plication  that  the  program  is 
d e s i ~ e d  
to i m ~ l e ~ e n t .  
The  advantage of 
studying  architecture  is  that we can  examine  concurrent  program  structures  that 
can be used  in  many  different  situations  and  applications.  In  the  following,  we  lo
at some  architectures  that 
c
o
~
o
~
y
 
occur  in  concurrent  programs. 
i 
A ~ l ~ e ~  
is  a  process  that  receives  a  stream of input  values,  performs  some  compu- 
tation  on  these  values  and  sends  a  stream 
of results  as  its  output. In general,  a 
filter  can  have  more  than  one  input  stream  and  produce  results  on  more  than  one 
output  stream.  Filters  can  easily be combined  into  larger  computations by con- 
necting  the  output  stream from one  filter  to  the  input  stream  of  another.  Where 
filters  have  more  than  one  input  and  output,  they  can be arranged  into  networks 
with  complex  topologies. In this  section, we restrict  the  discussion  to  filters  that 
have  a  single  input  and  a  single  output.  Such  filters  can 
be combined  into ~ ~ ~ e l ~
networks.  Many  of  the  user-level  commands in  the UNIX operating  system  are 
filter  processes,  for  example  the  text  formatting  programs 
tbl, eqn  and t
~
~
In 
UNIX, filter  processes  can be combined  using  pipes. A TJNIX ~~~e is  essentially 

a  bounded  buffer  that  buffers  bytes 
of data  output by one  filter  until  they  are  input 
to  the  next  filter.  We  will  see  in  the  following  that  the  pipes  that 
interco~ect 
filters 
do  not  always  need  to  include  buffering. 
To illustrate  the  use of filter  pipelines,  we  develop  a  program  with  this  archi- 
tecture  that  computes  prime  numbers. The  program  is  a  concurrent  implementa- 
tion of a  classic algorithrn  known  as  the  Primes  Sieve 
of Eratosthenes,  after  the 
Greek  mathematician  who  developed 
it. The  algorithm  to  determine  all  the  primes 
between  2  and n proceeds as follows.  First,  write own a  list  of all the  numbers 
between  2  and n: 
2 3 4 5 6 7  ... n 
Then,  starting  with  the  first  uncrossed-out  number in  the  list, 2, cross  out  each 
number  in  the  list  which  is  a  multiple  of  2: 
2 3 4 5 6 7  ... n 
Now  move to the  next  uncrossed-out  number,  3,  and  repeat  the  above 
by crossing 
out  multiples  of  3.  Repeat  the  procedure  until  the 
end of the  list is reached.  When 
finished,  all  the  uncrossed-out 
nubers are  primes. The  primes  form  a  sieve  which 
prevents  their  multiples  falling throug~ into  the  final list. 
The  concurrent  version of the  primes  sieve a l g o r i t ~  
operates by generating  a 
stream of numbers.  The  multiples  are  removed 
by filter  processes.  The  outline 
architecture of the  program  is  depicted  in  Figure 
11.1. It is  essentially  a  process 
structure  diagram  from  which we  have  omitted  the  details of action  and  process 
labels. 
p ~ e l i ~ e  
I
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
1
 
Figure 11.1 Primes  Sieve prociss architecture. 
The  diagram  describes  the  high-level  structure of the  program.  The  process 
GEN 
generates  the  stream  of  numbers  from  which  multiples  are  filtered 
by the FILTER 
processes. To fully  capture  the  architecture of the  program,  we  must  also  consider 
how  the  application-specific  processes  interact.  Interaction  between  these  elemen

2 2 .Z ~ i ~ t e r  
Pipeli~e 
235 
in  the  example  is  described 
by the P  I 
PE processes.  In  the  terminology  of  Software 
Architecture,  these  processes  are  termed 
c ~ ~ ~ e c ~ ~ ~ s .  
Connectors  encapsulate  the 
inte~action between  the  components of the  architecture.  Connectors  and  compo- 
nents  are  both  modeled  as  processes.  The  distinction  with  respect  to  modeling  is 
thus  essentially  methodological. We  model  the  pipe  connectors  in  the  example  as 
one-slot  buffers  as  shown  below: 
const MAX = 
set S = {[NU~],eos3 
PIPE 
(p~t[x:S]->get~x]->PIPE)~ 
The P  I 
PE process  buffers  elements from  the  set S which  consist  of  the  numbers 
2 . . 
MAX and  the  label eos , 
which  is  used to signal  the  end  of  a  stream 
of numbers. 
This  end of stream  signal  is  required  to  correctly  terminate  the  program. 
To simplify  modeling of the G EN and F I LTE R processes, we  introduce an addi- 
tional FSP construct - 
the  conditional  process. The  construct  can be used  in  the 
definition  of  both  primitive  and  composite  processes. 
B then P else Q behaves  as  the  process P if the  condition B 
e it behaves as Q. If the 
Q is  omitted  and 
E3 is  false, 
then  the  process  behaves as STOP. 
The  definition of GEN using  the  conditional  process  construct  is  given  below: 
GEN 
= GEN[2], 
~ E N [ x : N U ~ ~  
= (out.put[x] -> 
(o~t.put.eos->end-~GEN) 
)
a
 
The GEN process  outputs  the  numbers 2 to MAX, followed by the  signal eos. The 
action end is used  to  synchronize  termination  of  the GEN process  and  the  filters. 
After end occurs,  the  model  re-initializes  rather  than  terminates.  This  is  done so 
that, if deadlock  is  detected  during  analysis, it will  be an error  and  not  because of 
correct  termination.  The F1 LTER process  records  the  first  value it gets  and  subse- 
quently  filters  out  multiples 
of that  value  from  the  numbers  it  receives  and 
forwards  to  the  next  filter  in  the  pipeline. 

R = (in.get[p:NUM]->prime 
/in.get.eos->ENDFILTE 
1, 
FILTER[p:NU~] = (i 
lin.~et,eos->EN~FILTER 
1, 
ENDFILTE~ 
= (out.put.eos->en~-> 
The  composite  process  that  conforms  to  the  structure  given  in  Figure  11.1  can  no
be defined  as: 
I /P~~MES(N=4) 
= 
( gen:GEN 
I /pipe[O..N-l]:PIPE 
I /filter[O.  .N-l]  :FILTER 
)/{ pipe~O]/gen~out~ 
pipe[i:O.  .N-l~/fjlter[i]  .in, 
pipe[i:l.  .~-l]/fjlter[i-l]  .out, 
en~/~filter[O..N-l].en~,gen.end3 
3~{filter[O. .N-l]  .prime,en~3. 
Safety  analysis of this  model  detects  no  deadlocks  or  errors.  The m i ~ ~ e d  
LT§ 
for  the  model  is  depicted  in  Figure  11.2.  This  confirms  that  the  model  computes 
the  primes  between  2  and 9 and  that  the  program  terminates  correctly. 
In  fact,  the  concurrent  version of the  primes  sieve a l g o r i t ~  
does  not  ensure 
that  all  the  primes  between  2  and 
MAX are  computed: it computes  the  first N 
primes  where N is  the  number of filters  in  the  pipeline.  This  can  easily 
be con- 
firmed by changing MAX to 11 and  re-computing  the  minimized LT§, which  is  the 
same  as  Figure 11 $2. To compute  all  the  primes  in  the  range  2  to  11,  five  filters  are 
required. 
end 
Figure 11.2 h4nimized PRIMES LTS. 

11 .1 Filter ~ i p e l i ~ e  
237 
We have  modeled  the  filter  pipeline  using  single-slot  buffers  as  the  pipes 
comect- 
ing filters.  Would  the  behavior  of  the  overall  program  change if we  used  unbuf- 
fered  pipes?  This ~uestion can  easily  be  answered  by 
construc~g a  model  in 
which  the PI PE processes  are  omitted  and  instead,  filters 
c o m m ~ c a t e  
directly 
by  shared  actions.  This  model  is  listed  below.  The  action 
pipe [ i] 
relabels  the 
out.  put action  of filter [ i- 
l 3 and  the i n   . g e t  
action of filter[ i]. 
I I ~ R ~ ~ E ~ U N ~ U ~ ( N = ~ )  
= 
( ~ e n : ~ E N  
I I filter[O.  .N-i] :F~LTER) 
/{ p i p e ~ O ] / ~ e n . o u t . p u t ,  
p i ~ e [ i : O " . N - l ] / f i l t e r [ i ] . i ~ . ~ ~ t ,  
pipe[i:l.  .N-l]/filter[i-l]  .out.put, 
end/{filter[O..N-i]"end,~en.end} 
}@(filter [ 
0 e . 
N- l ] prime,  end}. 
The  minimized LT§ for  the  above  model  is  depicted  in  Figure 11.3. 
end 
Figure 11.3 Minimized ~ ~ I ~ E S U N ~ U F  
LTS. 
"he reader  can  see  that  the LT§ of Figure 11.3 is  identical  to  that of Figure 11.2. 
The  behavior of the  program  with  respect  to  generating  primes  and t e ~ ~ a t i o n  
has  not  changed  with  the  removal 
of buffers.  Roscoe (1998) describes  a  program as 
being ~~~~r  er^^^ if its  required  behavior  does  not  change  with  the  introduction 
of  buffers. We  have  shown  here  that  the  primes  sieve  program  is  buffer  tolerant  to 
the  introduction of a  single  buffer  in  each  pipe.  Buffer  tolerance  is  an  important 
property in the  situation  where  we  wish  to  distribute  a  concurrent  program  and, 
for  example,  locate  filters  on  different  machines. 
In this  situation,  buffering  may 
be 
unavoidable if introduced by the comm~cation system. 
We  showed  above  that  the  primes  sieve  program  is  tolerant  to  the  introduction  of 
a  single  buffer  in  each  pipe.  The  usual  problem 
of state  space  explosion  arises 
if we 
try  to  analyze  a  model  with  more  buffers. 
To overcome  this  problem,  we  can 

abstract  from  the  detailed  operation 
of the  primes  sieve  program.  Instead of mod- 
eling  how  primes  are  computed,  we  concentrate  on  how  the  components 
of the 
program  interact,  independently of the  data  values  that  they  process. 
The abstract 
versions of components  can  be  generated  mechanically by relabeling  the  range of 
values NUM to be a  single  value.  This  is  exactly  the  same  technique  that  we  used 
in  section 102.2 to  generate  an  abstract  model  of  an async~onous message port. 
The  abstract  versions of GEN,  FILTER 
and PIPE are  listed  below. 
1 IAGEN 
= GEN/~out,put/out.put[NU~]3. 
I IAFILTER = FILTER/~out"put/out.put[NU 
in.get  /in.get. 
[ ~ U ~ ] ,  
prime / p r i m e ~ N U ~ ~  
I IAPIPE 
= ~IPE/~put/put[NU~],get/~et[NU~]~. 
in.get.eos 
Figure 11.4 Minimized AFILTER LTS. 
The  LTS for  the  abstract  version of a  filter  process  is  shown  in  Figure 11.4. In  the 
detailed  version of the  filter,  the  decision  to  output  a  value  depends on  the  com- 
putation  as  to  whether  the  value  is  a  multiple 
of the  filter's prime.  In  the  abstract 
version,  this  computation  has  been  abstracted  to  the 
non-determ~stic 
choice as to 
whether, in state (4) , 
after an in 
e get action,  the  LTS  moves  to state (5) and  does 
an out . 
put action  or  remains  in state (4). This  is a good  example of how  non- 
d e t e ~ ~ s t i c  
choice  is  used  to  abstract  from  computation.  We  could, 
of course, 

11 .1 Filter ~ i p e l i ~ e  
239 
have written the  abstract  versions of the  elements of the  primes  sieve  program 
directly,  rather than writing  detailed  versions and abstracting  mechanically as we 
have done here.  In  fact,  since 
FSP, as a  design choice, has extremely  limited 
facilities  for  describing and manipulating data, for  complex programs abstraction 
is  usually  the  best way to  proceed. 
To analyze  the  primes  sieve program with multi-slot  pipes, we can  use  a  pipe- 
line of AP I PE processes  defined  recursively as follows: 
"te abstract  model  for  the  primes  program, 
with exactly  the  architecture  of  Figure 
11 .l, can  now  be  defined  as: 
I IAPRIMES(N=4, 
(gen:A~EN 1 I PRIM~P(N) 
I I 
p i p e [ O . . ~ - l ] : M P I P E ( 6 )  
I I filterf0. . N - l ]  :A~ILTER) 
/{ p i p e ~ O ~ / g e n ~ o u t 9  
pipe[i:O.  .N-l]/filter[i]  .in, 
p i p e [ i : l . ~ ~ - ~ ] / f i l t e r [ i - l ~ . o u t ,  
end/{filter[O..~-I]~end,gen,end3 
where PR I MEP is  a  safety property which  we  define  in  the  following  discussion. 
0 
We  refer to  the  properties that we  can  assert  for  the  abstract  model of the  primes 
sieve program as architectural  properties  since  they are concerned  with  the  con- 
current  architecture of the program - 
structure and interaction - 
rather than its 
detailed  operation.  The  general  properties 
we wish  to  assert 
at this  level are 
absence of deadlock and eventual  termination  (absence of livelock).  Eventual 
ter~nation is  checked  by  the  progress 
property END, which  asserts  that, in all 
executions of the  program,  the  terminating  action end must always  occur. 
END = {end} 

The  property  specific to the  application is that  the  prime from fi It e r 0 ] should 
be produced  before  the  prime  from f i l t  e r [ 1 ] and so on.  The  following  safety 
property  asserts  this: 
The  property  does  not  assert  that all the  filters  must  produce  primes  before end 
occurs  since  the  model  can  no  longer  determine  that  there  are 
4 primes  between 2. 
and 9. 
Analysis of A P R I ~ E  
using LTSA determines  that  there  are  no  deadlocks,  safety 
violations  or  progress  violations  for  four  filters  and  three  slot  pipes.  The  reader 
should  verify  that  the  safety  and  progress  properties  hold  for  other  combinations 
of filters  and  buffering.  U&en  building  this  model, it is  important  that  the L T ~ A  
is  set,  otherwise  the a mi zed models 
for  the  abstracted  elements  are  not  built  and conse~uently, the  reduction in state 
space  is  not  realized. 
Figure 11.5 is  a  screen  shot of the  Primes  Sieve  applet  display.  The 
imple~entation 
supports  both  a  buffered  and  unbuffered  implementation of the  pipe  connector. 
The  figure  depicts  a  run  using  unbuffered  pipes.  The  box  in  the  top  left  hand 
of the 
display  depicts  the  latest  number  generated by the  thread  that  implements GEN. 
The  rest of the  boxes, at the  top,  display  the  latest  number  received 
by a  €ilter. The 
boxes  below  display  the  prime  used by that  filter  to  remove  multiples. 
The ~plementation follows in a  strai 
t f o ~ ~ r d  
way  from  the  model  devel- 
oped  in  the  previous  section.  The  number  erator  and  filter  processes  are  imple- 
mented as threads. As mentioned  above,  we  have  provided two implementations 
for  the  pipe  connector.  The  classes  involved in the  program  and  their  inter-rela- 
tionships  are  depicted  in  the  class  diagram of Figure 11 -6. The  dis 
by a  single  class, P rime sCanv as. The  methods  provided by this  class,  together 
with a description of their  functions,  are  listed in Program 11.1. 

I1 .1 Filier ~ i ~ e l i n e  
241 
igure 11.5 Primes  Sieve applet display. 
The  code  for  the  ene era tor and  Filter  threads  is  listed  in  Programs 
11.2 and 
11.3. The i~plementation of these  threads  corresponds  closely  to  the  detailed 
developed  in  the  previous  section.  Additional  code 
has  been  added  only  to  display  the  values  generated  and  rocessed. 
To simplify 
the  display  and  the  pipe 
~plementations, the  end-of-stre  signal  is 
an integer 
value  that  does  not  occur  in  the  set 
of generat  e  obvious  values  to 
use  are 
0, 1, - 1 or MAXI-1. In  the  applet  class,  defined  to 
be - 1. 
ut 
Primes  class diagram. 

Program 11.1 PrimesCanvas class. 
Program 11.2 Generator class. 

11 .l Filter Pipeli~e 
243 
Program 11.3 F i l t e r  class. 
Instead of implementing  buffered  and  unbuffered  pipes  from  scratch,  we  have 
reused  classes  developed in earlier  chapters. The  synchronous  message-passing 
class, Channel, from Chapter 10 is  used  to  implement  an  unbuffered  pipe  and  the 
bounded  buffer  class, 
6uf f e r I mpl, from Chapter 5 is  used  to i~plement buffered 
pipes. The Pipe interface  and  its implementatio~ are  listed  in  Program 11.4. 

Program 11.4 Pipe, PipeIm~lUn~uf 
and Pipe~mpl~uf 
classes. 

22.2 F i l ~ ~  
~ipeline 
245 
The structure of a  generator  thread and N filter  threads  connected  by  pipes  is 
constructed  by  the go ( ) method of the Primes applet  class.  The  code  is  listed 
below: 
void go( boolean  buffered) { 
Pipe  pipe[ ] = 
Pipe~mplUnBuf(); 
// create t ~ r e a ~ s  
~ e n e r ~ t o r ( p i p e ~ O ] , d i s p l a y ) ;  
( i n t  i=O; icN; ++i) 
F i l t e r ( p i ~ e [ i ] ~ p i p e [ i + l ] , i + l , ~ i s p l a y ) ;  
( i n t  i=O;  i<N; ++i) 
filter[ i] s t a r t  () ; 
We saw  from  modeling  the  primes  sieve  program  that  it  computed  the  correct 
result,  whether  or  not  the  pipes  connecting  filter  processes  were  buffered.  In  line 
with  the  model,  the im~lementation also  works  correctly  with and without  buf- 
fers.  Why  then  should we ever  use  buffering  in  this  sort of architecture  when  the 
logical  behavior  is  independent of buffering?  The  answer  is  concerned  with  the 
execution  efficiency of the  program. 
M e n  a  process  or  thread suspends itself and another  is  scheduled,  the  operat- 
ing  system  performs  a  context  switch  which, as discussed  in  Chapter 3, involves 
saving  the  registers of the  suspended  process and loading  the  registers  for  the 
newly  scheduled  process.  Context  switching  consumes 
CPU  cycles and,  although 
the  time  for  a  thread  switch  is  much  less 
than that for an operating  system  process, 
it  is  nevertheless an overhead. A concurrent  program m s  faster if we can  reduce 
the  amount of context  switching.  With  no  buffering,  the  generator 
and filter 
threads  are suspended every  time  they  produce an item  until  that  item  is  con- 
sumed  by  the  next  thread  in  the  pipeline.  With  buffers,  a  thread  can 
run until  the 
buffer  is  full.  Consequently,  in  a  filter  pipeline,  buffering  can  reduce  the  amount 
of 
context  switching.  In  our 
~plementation, this  benefit  is  not  actually  realized  since 
we have  introduced  delays  for  display  purposes.  However,  it 
is generally  the  case 
that  a  pipeline  architecture  performs  better  with  buffered  pipes. 

246 
~ ~ p t e r  
l I: Co~c~rrent 
~ r c ~ i t e c t ~ r e s  
If filters are located  on  physically  distributed  processors,  buffering  has 
an addi- 
tional  advantage. When a  message  is  sent  over  a c o ~ ~ c a t i o n  
link,  there  is  a 
fixed  processing and transmission  overhead  that  is  independent of message  size. 
Consequently, when tra~mitting a  lot of data, it  is  better to ~ansmit a few large 
messages  rather  than  many  small  messages.  With  buffering  in  the  filter  pipeline
is  easy  to arrange that a sequence of items  be  sent  in  the  same  message. 
Supervisor-Worker  is  a  concurrent  architecture  that  can  be  used  to  speed up the 
execution of some  computational  problems  by  exploiting  parallel  execution  on 
multiple  processors.  The  architecture  applies  when  a  computational  problem 
c m  be  split up into  a  number of independent  sub-problems.  These  independent 
sub-problems  are  referred  to  as 
~
~
s
~
s
 
in  the  following  discussion.  The  process 
architecture of a  Supervisor-Worker  program  is  depicted  in  Figure 11.7. 
1"""""""""""""-"""""""~ 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
i 
I 
l 
I 
I 
I 
I 
I 
I 
I 
S u ~ e ~ ~ ~ o r - ~ o r k e r  
I 1 
L
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
"
1
 
Figure 11.7 Supervisor-worker  process  architecture. 
Supervisor and worker  processes  interact  by  a  connector  that  we  refer  to,  for
moment, as a "bag".  The supervisor  process  is  responsible  for  generating 
an initial 
set of tasks and placing  them  in  the  bag.  Additionally,  the  supervisor  collects 
results  from  the  bag and determines  when  the  computation has finished. Each 
worker  repetitively  takes  a  task  from  the  bag,  computes  the  result  for  that  task, 
and places  the  result  in  the  bag.  This  process  is  repeated  until  the  supervisor 
signals  that  the  computation has finished. The  architecture  can  be  used  to  paral- 
lelize  divide-and-conquer  problems  since  workers  can 
put new  tasks  into  the  bag 
as  well as results.  Another way of thinking of this  is  that  the  result  computed  by  a 
worker  can  be  a  new  set 
of tasks.  Thus,  in  a  divide-and-conquer  computation,  the 
supervisor  places an initial  task  in  the  bag 
and this  is  split  into  two  further 

1 1.2 S ~ p ~ ~ i s o r - ~ o r ~ e ~  
247 
problems by a  worker  and so on. We  can  use  any  number of worker  processes  in 
the  upe er visor-~orker architecture.  Usually, it is  best  to  have  one  worker  process 
per  physical  processor.  First, we  examine  an  interaction  mechanism  suitable  for 
implementing  the bag connector. 
Linda  is  the  collective  name  given by Carrier0  and  Gelernter  (1989a)  to  a  set of 
primitive  operations  used  to  access  a  data  structure  called  a 
tuple  space. A tuple 
space  is  a  shared  associative  memory  consisting  of  a  collection 
of tagged  data 
records  called  tuples.  Each  data  tuple in a  tuple  space  has  the form: 
(“tag”, valuel, ..., value, ) 
The tag  is  a  literal  string  used  to  distinguish  between  tuples  representing  different 
classes of data. valuei are  zero  or  more  data  values:  integers,  floats  and  so  on. 
There  are  three  basic  Linda  operations  for  manipulating  data  tuples: 
out, in and 
A process  deposits  a  tuple in a  tuple  space  using: 
out(”tag”, exprl, ..., expr, ) 
Execution of out completes  when  the  expressions  have  been  evaluated  and  the 
resulting  tuple  has  been  deposited  in  the  tuple  space.  The  operation  is 
shilar to an 
asynchronous  message se 
except  that  the  tuple  is  stored  in  an  unordered  tuple 
space  rather  than  append 
o the  queue  associated  with  a  specific 
removes  a  tuple  from  the  tuple  space by executing: 
in(”tag”, field l,..., 
field, ) 
Eachfieldi is  either  an  expression 
or a  formal  parameter 
of the  form ?var where var is 
a  local  variable  in  the  executing  process.  The  arguments 
to in are  called  a  template; 
the  process  executing in blocks  until  the  tuple  space  contains  a  tuple  that  matches 
the  template  and  then  removes 
it. A template  matches  a  data  tuple  in  the  following 
circumstances:  the  tags  are  identical,  the  template  and  tuple  have  the  same  numb
of  fields,  the  expressions  in  the  template  are  equal  to  the  corresponding  values 
in 
the  tuple,  and  the  variables  in  the  template  have  the  same  type  as  the  correspon
ing  values  in  the  tuple.  When  the  matching  tuple  is  removed  from  the  tuple  space, 
the  formal  parameters  in  the  template  are  assigned  the  corresponding  values  from
operation  is  similar  to  a  message receive operation  with  the  tag 
and  values  in  the  template  serving  to  identify  the port. 
The third  basic  operation is r , 
which functions  in  exactly  the  same  way as in 
except  that  the  tuple  matching  the  template  is  not  removed  from  the  tuple  space. 

The  operation  is  used  to  examine  the  contents 
of a  tuple  space  without  modifying 
it. Linda  also  provides  non-blocking  versions 
of i 
which  return  true if a  matching  tuple  is  found  and 
Linda  has  a  sixth  operation  called 
I that  creates an active  or  process  tuple. 
I operation  is  similar  to  an  except  that  one 
of the a r g ~ e n t s  
is  a 
procedure  that  operates  on  the  other a r g ~ e n t s .  
A process  is  created to evaluate 
the  procedure  and  the  process  tuple  becomes  a  passive  data  tuple 
when  the 
procedure term~ates. This @v I operation  is  not  necessary  when  a  system  has 
some  other  mechanism  for  creating  new  processes.  It  is  not  used  in  the  following 
examples. 
Our  modeling  approach  requires  that  we  construct  finite  state  models. 
Consequently, we  must  model  a  tuple  space  with  a  finite  set 
of tuple  values.  In 
addition,  since  a  tuple  space  can  contain  more  than  one  tuple  with  the  same  v
we  must  fix  the  number of copies of each  value  that  are  allowed.  We  define  this 
num~er to be the  constant N and  the  allowed  values  to be the  set ~ ~ ~ l e s .  
N = ... 
uples = (...) 
The  precise  definition of N and Tuples depends  on  the  context  in  which  we  use 
the  tuple  space  model.  Each  tuple  value  is  modeled by an FSP label of the  form 
~
a
g
.
~
~
~
~
 
... val,. We  define  a  process  to  manage  each  tuple  value  and  the  tuple  space 
is  then  modeled by the  parallel  composition of these  processes: 
001 = False..True 
-3 TU~LE~i-l] 
rue][T] -> TU~LE[i-l~ 
alse][T] -> TUUPL 
I ~ T U ~ L E ~ ~ ~ C E  
= 
[ t : 
Tuples] TU 

11.2 S u p e ~ i ~ o r - ~ o r ~ r  
249 
The LTS for TUPLE value any with N=2 is  depicted in figure 11.8. Exceeding  the 
capacity by perfo~ing 
more  than two out operations  leads  to  an ERROR. 
out.any 
outany 
outany 
Figure 11.8 TUPLE LTS. 
h example  of  a condi~onal operation  on  the  tuple  space  would  be: 
The  value of the  local  variable t is  only  valid  when b is  true.  Each TUPLE process 
has in its  alphabet  the  operations 
on  one  specific  tuple  value.  The  alphabet 
of 
TU~LE~PACE 
is  defined by the  set TupleAlpha: 
A process  that  shares  access  to  the  tuple  space  must  include  all  the  actions 
of this 
set  in  its  alphabet. 
Linda  tuple  space  can be distributed  over  many  processors  connected by a  net- 
work.  However,  for 
demo~tration purposes  we  describe  a  simple  centralized 
~pleme~tation 
that  allows  matching 
of templates  only  on  the  tag  field 
of a 
tuple.  The  interface  to  our  Java 
~plementation of a  tuple  space  is  listed  in 
Program 1 1.5. 

250 
C ~ ~ ~ t e r  
11: C o n c ~ ~ e n ~  
Arc~itect~res 
Program 11.5 Tuplespace interface. 
We use  a  hash  table 
of vectors to implement  the tuple space  (Program 11 '6). 
Although  the  tuple  space  is  defined  to  be  unordered,  for  simplicity, 
we have 
chosen  to  store  the  tuples under a  particular  tag in FIFO order.  New  tuples  are 
appended to  the  end of a vector  for  a  tag and removed  from  its head. For  sim- 
plicity, a naive  synchronization  scheme  is  used  which  wakes 
up all  threads  when- 
ever  a  new  tuple  is added. A more  efficient  scheme  would  wake up only  those 
threads  waiting  for  a  tuple  with  the  same  tag as the  new  tuple. 
Program 11.6 TupleSpaceI~pl 
class. 

11.2 S ~ ~ e ~ i s o r - ~ o r ~ e r  
251 
Program 11.6 ( C o ~ ~ ~ ~ ~ e ~ ) .  
We model  a  simple  supervisor-worker  system 
in which  the  supervisor  initially 
outputs a  set of tasks  to  the tuple space and then.  collects  results.  Each  worker 
repetitively  gets  a  task and computes  the  result. The algorithms  for  the  supervisor 
and each  worker  process are sketched  below: 
Supervisor:: 
forall  tasks: out(”task”,..J 
forall  results: in(”result”, . 
. .) 
out(”st0p”) 

~ o r ~ e r : :  
while  not r~~(”stop”) 
do 
in(”task”/. . 
.) 
compute  result 
out(”result”, ...) 
To terminate  the  program,  the  supervisor outputs a tuple with the tag  ”stop” 
when  it has collected  all  the  results  it  requires.  Workers run until  they  read  this 
tuple.  The  set of tuple  values and the  maximum  number of copies of each  value 
are  defined  for  the  model  as: 
- 2  
Tuples = {task,result,stop) 
The supervisor outputs N tasks  to  the  tuple  space,  collects 
N results and then 
outputs the  ”stop”  tuple and ter~nates. 
SUPERVISOR 
= TASK[ 1 1, 
TASK[i:l.  .N] 
= 
(Outstask -> 
if icN  en TASK[i+l] 
RESULT~i:l. 
.NI = 
(in. result -> 
n RESULT[ i+l 1 
(out.stop -$ end -3 STOP) + TupleAlp~a. 
FINISH = 
The  worker  checks  for  the “stop” tuple before  getting  a  task and outputting the 
result. The  worker  terminates  when  it  reads  ”stop”  successfully. 
~ORKER = 
(rdp[b:Bool].stop-> 
> out. result -> ~ORKER) 
(end -> STOP) 
)~TupleAlp~a. 
The LTS for  both SUPERVISOR and ~ORKER 
with N=2 is depicted  in  Figure 11.9. 
In the  primes  sieve  example,  we  arranged  that  the  behavior  was  cyclic 
to avoid 
detecting  a  deadlock  in  the  case 
of correct t e r ~ a t i o n .  An alternative way of 

11.2 S ~ ~ e r v i s ~ r - ~ o r ~ r  
253 
out.task 
outtask 
in.result 
 
in.result 
outstop 
end 
rdp.1  .stop 
.stop 
 
in.task 
out.result 
Figure 11.9 SUPERVISOR and WORKER LTS. 
avoiding  this situation is  to  provide  a  process 
that can  still  engage  in  actions  after 
the end action has occurred. We use  this  technique  here 
and define an END process 
that engages in the  action ended after  the  correct  termination  action end occurs. 
END 
= (end->E~DED), 
ENDED = (ended->ENDED). 
A supervisor-worker  model  with two workers  called redWo r 
k and blu e ~ o  
r 
k, 
which  conforms  to  the  architecture of Figure 11 -7, can  now  be  defined by: 
1 ISUPERVISO~-WORKER 
= ( su~ervisor:SU~ERVISOR 
I I {redWork,~lue~ork}:~OR~ER 
I I {su~ervisor,redWork,blueWork}::TUPLESPACE 
)/{e~d/{su~ervisor,redWork,blueWork}.end}* 
I I END 

Safety  analysis of  this  model  using LTSA reveals  the  following  deadlock: 
Trace to DEAD LO^^: 
supervisor.out.task 
supervisor.  out.  task 
redwork. rdp 
m 0 .  stop 
redWork.in.task 
redWork.out.result 
su~ervisor.in.resu1t 
redWork.rd~.O.stop 
redwork. in.  task 
redwork.  out.  result 
supervisor.  in.  result 
redwork.  rdp 
m 0 ,  
stop 
supervisor.out.stop 
blueWork. rdp 1 stop 
This  trace  is  for  an  execution  in  which  the  red  worker  computes  the  results  for  t
two  tasks  put  into  tuple  space 
by the  supervisor.  This is quite  legitimate  behavior 
for  a  real  system  since  workers  can 
run at different  speeds  and  take  different 
amounts  of  time  to  start.  The  deadlock  occurs  because  the  supervisor  only  outputs
the "stop" tuple @er the  red  worker  attempts  to  read 
it. When  the  red  worker  tries 
to  read,  the "stop"  tuple  has 
not  yet  been  put  into  the  tuple  space  and,  conse- 
quently,  the  worker  does  not  terminate  but  blocks  waiting 
for  another  task.  Since 
the  supervisor  has  finished,  no  more  tuples  will be put  into  the  tuple  space  and 
consequently,  the  worker  will  never  terminate. 
This  deadlock, which  can  be  repeated  for  different  numbers of tasks  and  work- 
ers,  indicates  that  the  termination  scheme 
we have  adopted  is  incorrect.  Although 
the  supervisor  completes  the  computation,  workers  may  not 
ter~nate. 
It relies  on 
a worker  being  able  to  input  tuples  until  it  reads  the "stop" tuple. As  the  model 
demonst~ates, this  may  not  happen.  This  would be a  difficult  error  to  observe in 
an  implementation  since  the  program  would  produce  the  correct  computational 
result.  However,  after  an  execution,  worker  processes  would 
be blocked  and 
consequently  retain  execution  resources  such 
as memory  and  system  resources 
such  as  control  blocks.  Only  after  a  number 
of executions  might  the  user  observe  a 
system  crash  due  to  many  hung  processes.  Nevertheless,  this  technique 
of using  a 
"stop"  tuple  appears  in  an  example  Linda  program  in  a  standard  textbook  on 
conc~rrent programming! 
A  simple  way 
of implementing  termination  correctly  would 
be to make  a 
worker  wait  for  either  inputting  a  "task"  tuple  or  reading  a  "stop"  tuple. 
U ~ o r ~ a t e l y ,  
while  this 
is easy  to  model, 
it cannot  easily 
be implemented 

11.2 S ~ ~ ~ ~ i s o r - ~ o r k e r  
255 
since  Linda  does  not  have 
an equivalent  to  the  selective  receive  described  in 
Chapter  10.  Instead,  we 
adopt a  scheme  in  which  the  supervisor 
outputs a 
”task” tuple with  a  special  stop  value. 
m e n  a  worker inputs this  value,  it outputs 
it  again and then  terrrtinates.  Because  a  worker outputs the  stop  task  before  ter- 
rrtinating,  each  worker  will  eventually 
input it and terminate. This  termination 
technique appears in  algorithms  published  by  the  designers of Linda  (Carrier0 
and Gelernter, 198913).  The revised  algorithms  for  supervisor 
and worker  are 
sketched  below: 
~uper~isor:: 
forall  tasks:- Qut(”task”,. .) 
forall  results:- in(”result”, ...) 
Qut(”tas~’,stop) 
while  true do 
~ o r ~ e r : :  
in(”task”, ...) 
if value  is stop then ~ut(”tas~’,sto~); 
exit 
compute  result 
~ut(”result”,. 
. 
.) 
The tuple definitions and models  for  supervisor and worker  now  become: 
Tuples = {task,t~sk.stop,result3 
SUPERVISOR 
= TASK[ l ] ,  
TASK[i:l 
m .NI = 
(Out.taSk -> 
TASK[ i+l ] 
RES~LT[l]), 
RESULT[i:l. .NI = 
FINISH = 
(out.task.stop -> end -> STOP) 
+ TupleAlpha, 
~ ~ R K E R  
= 
(in.task -> outxesult -3 ~ O ~ K E R  
1in.task.stop -> out.task.stop -> end ->STOP 
) + Tuple~lph~. 
The  revised  model  does  not  deadlock and satisfies  the  progress  property: 

A sample  trace  from  this  model,  which  again 
has the  red  worker  computing  both 
tasks,  is  shown  in  Figure 11.10. 
In  the  first  section 
of this  chapter,  the  primes  sieve  application  was  modeled  in 
some  detail. We then  abstracted  from  the  application  to  investigate  the  concurrent 
properties of the  Filter  Pipeline  architecture. In this  section,  we  have  modeled  the 
Supe~isor-Worker architecture  directly  without  reference  to an application. We 
were  able  to  discover  a  problem  with termina~on and provide  a  general  solution 
that  can  be  used  in  any  application 
implemen~ed within  the  framework of the 
architecture. 
Figure 11.10 
Trace of S u ~ e ~ i s o r - ~ o r k e r  
model. 
To illustrate  the ~ ~ l e m e ~ t a t i o n  
and operation of Supe~visor-Wor~er 
architec- 
tures,  we  develop  a  program  that  computes 
an approximate  value of the  area 
under  a  curve  using  the ~ e c ~ ~ ~ g Z e  
~
e
~
~
~
~
.
 
More  precisely,  the  program  computes 
an approximate  value  for  the  integral: 

1 l .2 S ~ ~ e r ~ i s o r - W o r ~ r  
257 
0 
1 .o 
Figure 11.11 Rectangle  method. 
The  rectangle  method  involves s m i n g  the  areas of small  rectangles  that  nearly 
fit  under  the  curve as shown  in  Figure 11.11. 
In  the 
~upe~isor-~orker  ~plementation, 
the  supervisor  determines  how 
many  rectangles  to  compute  and  hands  the  task 
of computing  the  area of the 
rectangles  to  the  workers.  The demonst~a~on 
program  has  four  worker  threads 
each  with  a  different  color  attribute.  When  the  supervisor  inputs  a  result, 
it dis- 
plays  the  rectangle  corresponding  to  that  result  with  the  color 
of the  worker.  The 
display of a  completed  computation  is  depicted  in  Figure 11.12. 
Figure 11.12 Super~isor-~orker 
applet. 

258 
Chapter 1 1: Co~curre~t 
Archi~ectures 
Each  worker  is  made  to  run  at  a  different  speed by performing  a  delay  before 
outputting  the  result  to  the  tuple  space.  The  value 
of this  delay  is  chosen  at 
random  when  the  worker  is  created.  Consequently,  each m 
behaves  differently. 
The  display of Figure 11.12 depicts  a run  in  which  some  workers  compute  more 
results  than  others.  During  a  run,  the  number of the  task  that  each  worker  thread 
is  currently  computing  is  displayed.  The  last  task  that  the  worker  completed  is 
displayed at the  end of a run.  The  class  diagram  for  the  demonstration  program  is 
shown  in  Figure 11.13. 
J 
Figure 11.13 Supervisor-Worker class diagram. 
The displays for  the  supervisor  and  worker  threads  are  handled,  respectively, 
by the  classes SupervisorCanvas and WorkerCanvas. The  methods  provided 
by these  classes,  together  with  a  description 
of what  they  do,  are  listed  in  Program 
11.7. The interface for  the  function f(xj together  with  three i~plementations are 
also  included  in  Program 11.7. 

11.2 Superviso~-~orker 
259 
P r o ~ r a ~  
11.7 SupervisorCanvas,  WorkerCanvas 
and Function classes. 
A task  that  is  output to the  tuple  space by the  supervisor  thread is represented 
by  a  single  integer  value.  This  value  identifies  the  rectangle  for  which  the  worker 
computes  the  area. 
A result  requires  a  more  complex  data  structure  since,  for 
display  purposes,  the  result  includes  the  rectangle n u b e r  and  the  worker  color 
attribute  in  addition to the  computed  area  of  the  rectangle. "te definition  of  the 
Result and  the Supervisor classes  are  listed  in  Program 11.8. 

Program 11.8 Result and Supervisor classes. 
The  supervisor  thread  is  a  direct  translation  from  the  model. It outputs  the  set 
of rectangle  tasks  to  the  tuple  space  and  then  collects  the  results.  Stop  is  encoded 
as a "task"  tuple  with  the  value 
-1, which falls  outside  the  range 
of rectangle 
identifiers.  The ~o r 
ke r thread  class  is  listed in Program 11.9. 

11.2 S ~ ~ e r v i s o ~ - W o r ~ r  
261 
Program 11.9 Worker class. 
The  choice  in  the  worker  model  between  a  task  tuple  to  compute  and  a  stop 
task  is  implemented  as  a  test  on  the  value of the task, The  worker  thread  termi- 
nates  when it receives  a  negative  task value, The  worker  thread is able  to  compute 
the  area  given only a  single  integer  since  this  integer  indicates  which  "slice" 
of the 
range of x from 0 to 1.0 for  which  it  is  to  compute  the  rectangle.  The  worker  is 
initialized  with  a  function  object. 

263- 
 apter er 1 1: Conc~rre~t 
 
Arc~itec~ures 
The structure of supervisor,  worker and tuple space  is  constructed  by  the 
go ( ) 
method of the Su pe rviso  rWo 
r ke r applet class.  The  code  is  listed  below: 
v
~
~
e
 
void go(Function fn) { 
isplay.  reset 
(f n) ; 
W TupleSpace~~pl(); 
Worker (red,  bag, 
f n) ; 
rker~green,~ag~fn); 
orker(yellow,~ag,fn); 
ker(blue,bag,fn); 
supervisor = new Supervisor(~isplay,bag); 
red~ork.start(); 
i re en work. start ( ) ; 
yellowWork  start 
( ) ; 
blueWork.start(); 
supervisorstart(); 
3 
where display is an instance of Supe rviso rCanvas and red,  green,  yellow and 
blue are instances of WorkerCanvas. 
The s
~
e
e
~
~
~
 
of a  parallel program is  defined  to  be  the  time 
that a  sequential 
program takes  to  compute  a  given  problem  divided by the  time that the  parallel 
program takes  to  compute  the  same  problem  on 
N processors.  The e ~ c ~ e ~ c ~
is  the 
speedup divided by the  number of processors N. For  example, if a  problem  takes 
12 seconds  to  compute  sequentially and 4 seconds  to  compute  on  six  processors, 
then  the speedup is 3 and the  efficiency 0.5 or 50%. 
Unfortunately,  the demonstra~on supervisor-worker program would not  exhi- 
bit  any speedup if executed  on  a  multi-processor  with  a  Java runtime that sched- 
uled threads on  different  processors.  The  most  obvious  reason  for  this  is that we 
have  introduced  delays  in  the  worker 
threads for  display purposes. However, 
there  is  a  reason that provides  a  more  general  lesson. 
The amount of  CPU time  to  compute  each  task in the  example  is  very  small, 
since  each  task  requires  only  a  few  arithmetic  operations.  The  supervisor  uses 
more  CPU  time putting the  task  into tuple space and retrieving  the  result than 
it would if it computed  the  task  locally. Speedup of greater than unity is only 
achieved in supervisor-worker programs if the  tasks  require  significantly  more 
computation  time than the  time  required  for c o ~ u ~ c a t i o n  
with the  workers. 
The advantage of the  supervisor-worker  architecture  is  that  it  is  easy  to 
develop  a  parallel  version of an existing  sequential program in which  sub-pro- 
blems are independent. Often  the  sub-problem  solution  code  from  the  sequential 

11.3 A ~ ~ o ~ ~ c e r - ~ i s f e ~ e r  
263 
program  can be reused  directly  in  the  parallel  version. 
In practice,  the  architecture 
has  been  successfully  applied  to  computation-intensive  problems  such 
as image 
rendering  using  ray-tracing  techniques. 
Announcer-Listener is an  example of an event-based  architecture.  The  announcer 
process  announces  that  some  event  has  occurred  and  disseminates  it  to all those 
listener  processes  that  are  interested  in  the  event.  The co~unication 
pattern  is 
one  (announcer)  to  zero  or  more  (listeners).  Listener  processes  indicate  their  inter- 
est  in  a  particular  event 
by registering  for  that  event.  In  the  architecture  diagram 
of 
Figure 11.14, we  have  termed  the  connector  that  handles  event  dissemination  an 
"event  manager". 
,
"
"
"
"
"
"
"
"
"
"
"
"
"
"
I 
I 
LISTENER 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
! 
f 
~~ 
LISTENER 
l"""""""""""""""""""""1 
Figure 11.14 ~ O ~ c e r - L i s t ~ n e r  
process architecture. 
Listeners  can  choose  to  receive  only  a  subset 
of the  events  announced by regis- 
tering  a  "pattern"  with  the  event  manager, Only events  that  match  the  pattern  are 
forwarded  to  the  listener.  The  architecture  can  be  applied  recursively 
so that 
listeners  also  announce  events  to  another  set 
of listeners.  In  this  way, an  event 
dissemination  "tree"  can be constructed. 
An hportant property  of  this  architecture  is  that  the  announcer  is  insulated 
from  knowledge  of  how  many  listeners  there  are  and  from  which  listeners  are 
affected by a  particular  event.  Listeners  do  not  have  to 
be processes;  they  may 
simply be objects  in which a  method  is  invoked 
as a  result of an  event.  This 
~echanism is  sometimes  called i ~ ~ ~ i c i ~  
i ~ v o c ~ ~ i o ~  
since  the  announcer  does  not 
invoke  listener  methods  explicitly.  Listener  methods  are  invoked  implicitly as a 
result of an  event  announcement. 

264 
C ~ ~ ~ t e r  
11: Conc~r~ent 
 
Arc~itect~res 
The ~ouncer-Listener architecture is widely  used  in  user  interface  frame- 
works,  and  the  Java  Abstract  Windowing  Toolkit  (AWT)  is  no  exception.  In  sec- 
tion  11.3.2,  we  use  the A W  event mecha~sm in  an  example  program.  In  AWT, 
listeners  are  usually  ordinary  objects.  Events,  such  as  mouse  clicks  and  button 
presses,  cause  methods  to  be  invoked  on  objects. 
Our  example  uses  events  to 
control  the  execution of thread  objects. 
The  model is defined  for  a  fixed  set  of  listeners  and  a  fixed  set  of  event  patterns: 
Listeners = { a , ~ , ~ ~ d ~  
Pattern 
= {pall ,pat23 
The  event  manager  is  modeled 
by a  set of REGISTER processes,  each of which 
controls  the re~stration and  event  propagation  €or  a  single,  particular  listener. 
~ E ~ I S T E R  
= IDLE, 
IDLE = (regis~er[p:Pattern] -> M A T C ~ ~ p ]  
lannounce[Pattern] -> IDLE 
), 
(announce[a:Pattern] -> 
(a==p) then 
(eventia] ->  MATCH[^^ 
deregister -> IDLE) 
MATCH[p:Pattern] = 
MATCH [ 
p] 
I deregister -> IDLE 
1
9
 
The REGISTE~ 
process  ensures  that  the  event  action  for  a  listener  only 
Occurs if 
the  listener  has  previously  registered,  has  not  yet 
~egistered, and if the  event 
pattern  matches  the  pattern  with  which  the  listener  registered.  Figure  11.15 
depicts  the LTS for a: REGISTER for  listener a. 
The a M o ~ c e r  
is  modeled as repeatedly a M o ~ c i n g  
an  event  for  one of the 
p a t t e ~ s  
defined by the Pattern set: 


The  listener  initially  registers  for  events 
of a  particular  pattern  and  then  either 
performs  local  computation,  modeled 
by the  action compute, or  receives  an  event. 
01 
receiving  an  event,  the  process  either  continues  computing  or  deregisters  and 
stops. 
LISTENER(P='pattern) = 
LISTENING = 
(register[P] -> LISTENING), 
(compute -> LISTENING 
levent[P] -$ L I S T E ~ I N ~  
levent[P]I -> deregister -> STOP 
)+(register[Pattern]). 
~ ~ O ~ ~ C E R - L I S T E N E R  
describes  a  system  with  four  listeners a, b, c, d, in 
which a and c register  for  events  with  pattern pat 1 and b and d register  for pat 2. 
1 IANNOUNCER-LISTE~ER 
= ( a:LISTENE~('patl) 
I Ib:LISTE~E~('pat2) 
I ~c:LISTENER('p~tl) 
I Id:LISTENER('pat2) 
1 IEVENT~ANAGER 
I  ANNOUNCER 
1IListeners:SAFE). 
The 
 
safety 
 
property, 
SAFE, included 
in 
the 
 
composite 
 
process 
ANNOUNCER- IST TEN ER, asserts  that  each  listener  only  receives  events  while it is 
registered  and  only  those  events  with  the  pattern  for  which  it  registered.  The 
property  is  defined  below: 
ert 
SAFE = (register[p:Pattern] -2 SAFE[p]), 
SAFE[p:Pattern]=  (event[p] -> SAFE[p] 
(deregister -> SAFE 
1. 
Safety  analysis  reveals  that  the  system  has  no  deadlocks  or  safety  violations. 
A 
sample  execution  trace  is  shown  in  Figure 11.16. 
The important  progress  property for this  system is that  the a n n o ~ c e r  
should 
be  able  to  announce  events  independently of the  state of listeners,  i.e.  whether  or 

I I  .3 A ~ ~ o ~ n c e ~ - ~ i s t e ~ e r  
267 
Figure 11.16 ANNOUN~ER-LISTENER trace. 
not listeners are registered and whether  or not listeners  have stopped. We can 
assert  this  using  the  following  set of progress  properties: 
ANNOUNCE[p:Pattern] = {announce[p]) 
Progress  analysis  using 
LTSA verifies  that  these  properties  hold  for 
ANNOUNCE~-LISTEN~~. 
To illustrate  the  use of the  Announcer-Listener  architecture,  we  implement  the 
simple  game  depicted in Figure 11A7. The  objective of the  game  is  to  hit  all  the 
moving  colored  blocks with the  minimum  number of mouse  presses. A moving 
block  is  hit by pressing  the  mouse button when the  mouse  pointer  is 
on top of the 
block.  When  a  block  is  hit,  it turns black and stops moving. 
Each  block  is  controlled  by  a 
separate thread that causes  the  block  it  controls  to 
jump about the  display at random. The threads also  listen  for  mouse  events  that 
are announced  by  the  display  canvas 
in which  the  blocks  move.  These  events  are 
generated  by  the A W  and the program uses  the AWT classes provided for  event 
handling.  The  class diagram for  the program is  depicted  in  Figure 11.18. 

Figure 11.17 EventDemo applet display. 
Figure 11.18 ~ v e n t ~ e m o  
class diagram. 
'The display  for  the Event Demo applet is provided by the 
described in outhe by Program 11.10. 
Program 11.10 BoxCanvas class. 

P r o ~ r a ~  
11.11 BoxMover and MyListener classes. 

The  AWT  interface MouseList ene r describes  a  set of methods  that  are  invoked 
as a  result of mouse  actions.  To  avoid  implementing all these  methods,  since  we 
are  only  interested  in  the  mouse  pressed  event,  we  use  the  adapter  class 
Mouse Adapt er which  provides  null ~plementa~ons 
for  all  the  methods  in  the 
MouseListener interface. MyClass extends MouseA~apter and  provides  an 
~plementation for  the mousepressed method. MyClass is  an  inner  class 
of 
the ~oxMover 
thread  class; co~se~uently, 
it can  directly  call  private ~oxMover 
methods.  The  code  for BoxMover and MyListener is  listed in Program 11.11. 
The run ( ) method of oxMover repeatedly  computes  a  random  position  and 
displays  a  box  at  that  position.  After  displaying  the  box, 
wait Hit ( ) is  called.  This 
uses  a  timed wait ( ) and  returns  for two reasons:  either  the  wait  delay  expires 
and  the  value fa 1 se is  returned  or is Hit ( ) computes  that  a  hit  has  occurred  and 
calls not if y ( ) in  which  case t rue is  returned.  Because My List en e r is  registered 
as a listener for  events  generated by the  display,  whenever  the  display  announces 
a  mouse  pressed  event, MyListener . 
m o ~ s e ~ r e s s e ~  
( ) is  invoked.  This in turn 
calls isHi t ( ) with  the  mouse  coordinates  contained in the Mouse Event para- 
meter. 
If we  compare  the run ( ) method  with  the L1 S T E ~ E ~  
process  from  the  model, 
the  difference  in  behavior  is  the  addition of a  timeout  action  which  ensures  that 
after  a  delay, if no  mouse  event  occurs,  a  new  box  position  is  computed  and 
displayed. A model  specific  to  the BoxMover thread  is  described by: 
OX~OVER(P='~attern) 
= 
(register[P~ 
-> L I S T E ~ I ~ ~ ) ,  
(compute-> 
// c o m ~ u ~ e  
and ~ i s ~ l a ~  
~osi~ion 
(timeout -> L I S T E ~ I ~ ~  
// no mouse event 
levent[P] -> timeo~t -> L I S T E ~ I ~ ~  
// miss 
/event[P] -> deregister -> STOP 
// hit 
L I S T E ~ I ~ G  
= 
) 
) ~ ~ r e g i s t e r [ ~ a t t e r n ~ 3 .  
The reader  should  verify  that  the  safety  and  progress  properties  for  the 
A ~ ~ O U ~ C E ~ - L I S T E ~ E R  
still  hold when  OXM MOVER is  substituted  for L I ~ T E ~ E ~ .
In this  chapter, we  have  described  three  different  concurrent  architectures:  Filter 
Pipeline, S u p ~ ~ i s o r - W ~ r ~ e r  
and  Announcer-Listener . A model  was  developed 
for  each  architecture  and  analyzed  with  respect  to  general  properties  such 
as 
absence of deadlock  and  correct  termination.  Guided 
by the  models, we devel- 

Notes and F ~ r t ~ e r  
~eading 
271 
oped  example programs to  demonstrate  how  the  components 
of each  architecture 
interact during execution. 
Each  of the  architectures  uses  a  different  type of connector  to  coordinate  the 
communication  between  the  components of the  architecture. The  Filter  Pipeline 
uses ~ i ~ e s ,  
which  are  essentially comm~cation channels with zero  or  more  buf- 
fers. We showed that the  behavior of our pritnes  sieve  application,  organized 
as a 
Filter  Pipeline,  was independent of the  buffering provided in pipes. The  compo- 
nents of the  Supervisor-Worker  architecture  interact  via  a  Linda 
~
~
~
Z
e
 
space, which 
is an unordered collection of data tuples. We provided a  model of Linda tuple 
space and used it to  investigate  termination  strategies  for  Supervisor-Worker 
systems.  The  Announcer-Listener  components  interact  by  event  dissemination. 
We presented  a  general  model of event dissemination and then  used  Java AWT 
events  to  implement  the  example program. 
Pipes support ~
~
e
-
~
~
-
~
~
e
 
communication, tuple space supports ~ ~ y - ~ u - a ~ y  
com- 
m ~ c a t i o n  
and event  dissemination  is u ~ e - ~ ~ - ~ ~ ~ y .  
These  connectors  were  cho- 
sen as the  most natural match with the  topology of the  architecture  to  which 
they  were applied. However,  it  is  possible, if not very natural, to  use tuple space 
to  implement  a  set of pipes and, more  reasonably,  to  use  rendezvous  (section 
10.3)  instead of tuple  space in the Supervisor-Wor~er architecture.  In  other 
words,  for  each  architecture  we  have  described  one  technique  for  organizing 
the co~unication between  participating  components.  However,  many variants 
of these  architectures  can  be found in the  literature,  differing  in  the  mechanisms 
used  to support co~unication, how  termination  is  managed and, of course, in 
the  applications  they support. A  particular  concurrent program may  incorporate 
a  combination of the  basic  architectures  we  have  described  here and in  the  rest 
of the  book.  For  example,  the  filter  processes in a  pipeline  may  also  be  the  clients 
of a  server  process. 
As mentioned  earlier,  Filter  Pipeline  is  the  basic  architecture  used 
in the Unix 
operating system  to  combine programs. The architecture  is  also  used  extensively 
in multimedia  applications  to  process  streams 
of video and audio information. An 
example of this  sort of program can  be found in Kleitnan,  Shah and Srnaalders 
(1996).  A  discussion of the  properties of more  general pipe and filter  networks 
may  be found in Shaw and Garlan’s  book on Software  Architecture  (1996). 
The  Supervisor-Worker  architecture 
appears in many  guises in books and 
papers on concurrent  programming.  Andrews (1991)  calls the  architecture  ”repli- 
cated  worker”,  Burns and Davies  (1993)  call it ”process  farm”,  while  Garriero 
and 
Gelernter  (1989b)  characterize  the  form of parallelism supported by the  architec- 

ture as ”agenda  parallelism”. A paper  by  Cheung  and 
simple  way of assessing  the  likely  performance 
of a  se  ntial  algorithm 
.when 
parallelized  using  the Supe~iso~-~orker 
architecture.  The  paper  also  describes  a 
technique  for  making  the  architecture  fault-tolerant  with  respect  to  worker  failure
The Supe~isor-~orker 
architecture  has  been  used  extensively  in  exploit 
computational  power of clusters of worksta~ons. 
A large  literature  exists 
on  Linda  (Gelernter,  1985;  Carrier0  and  Gelernter, 
1989a,  1989b)  and  its  derivatives.  The  proceedings 
of the  ”Coordination”  series 
of conferences  (Ciancarini  and  Hankin,  1996;  Garlan  and  Le  Metayer,  1997) 
describe  some of the  current  work  on  tuple  space  based  models  for  concurrent 
p r o ~ r a ~ i n ~ .  
The  Linda  tuple  space  paradigm  has  clearly  influenced  the  JavaSo
white  paper  proposal for JavaSpaces. 
Event-based  architectures  have  been  used  to  connect  tools  in  software  devel- 
opment  environments  (Reiss,  1990). 
As discussed  in  the  chapter,  windowing 
e n v ~ o ~ e n t s  
are  usually  event-based,  as  Smalltalk  (Goldberg  and  Robson, 
1983). In a  distributed  context,  event  processing  forms an important  part of net- 
work mana~ement systems  (Sloman,  1994). §haw  and  Garlan  (1996)  discuss  some 
of the  general  properties of event-based  systems. 
11 .l N processes  are  required to synchronize  their  execution at some  point  before  proceed- 
ing.  Describe  a  scheme  for 
~plementing this ~ ~ r r i e r  
s ~ c ~ o ~ a ~ o n  
using  Linda 
tuple  space.  Model  the  scheme  using 
TU P L ESPAC and  generate  a  trace  to  show 
the  correct  operation of your  scheme. 
11.2 Describe  a  scheme  for ~plementing the  Supervisor-Worker  architecture  using  ren- 
dezvous  message-passing c o ~ u ~ c a t i o n  
rather  than  tuple  space. 
( ~ i ~ ~ :  
Make  the  Supervisor  a  server  and  the  Workers clients,) 
Model  this  scheme  and  show  absence 
of deadlock  and  successful 
te~ination. 
Modify  the  Java  example  program to use ntry rather  Ihan T u ~ l e ~ ~ ~ ~ e
11.3 A  process  needs  to  wait  for 
an event  from  either  announcer A or a ~ o u n c e r  B, for 
example,  events  indicating  that  button  A  or  button B has  been  pressed,  i.e. 
( b u t ~ o n A  -> P[1] 1 button 
Sketch  the  implementation  of  a  Java  thread  that  can  block  waiting  for  either of two 
events to occur.  Assume  initially  that  the  Java  events  are  handled 
by the  same  listener 
interface.  Now  extend  the  scheme  such  that  events  with  different  listener  interfaces 
can be accommodated. 

Exercises 
273 
11.4  Provide  a  Java  class  which  implements  the  following  interface  and  has  the  behavior 
of 
V E ~ ~ ~ A ~ A ~ E ~ :  
ction(int  event); 
v e n t ~ a n a ~ e r  
{ 
e ~ i ~ ~ e r (  
Listener x) ; 
void  ~nnounce(int  event); 
i s t e r (   L i s t e n e r  x) : 
3 
11.5 Each  filter  in  a  pipeline  examines  the  stream 
of symbols  it  receives  for  a  particular 
pattern.  When  one of the  filters  matches  the  pattern  it 
is looking  for  the  entire  pipeline 
terminates.  Develop  a  model  for  this  system  and  show  absence 
of deadlock  and 
correct  termination.  Outline  how  your  model  might be implemented in Java,  paying 
particular  attention to t e ~ a t i o n .  
11.6  A token ring is an  architecture  which is commonly  used  for  allocating  some  privilege, 
such as access  to  a  shared  resource, to one of a  set of processes at a  time.  The  archi- 
tecture  works as follows: 
A token is passed  round  the  ring.  Possession 
of the  token  indicates  that  that  process 
has  exclusive  access to the  resource.  Each  process  holds  on to the  token  while  using 
the  resource  and  then  passes  it  on to its successor  in  the  ring/  or  passes  on  the  token 
directly if it  does  not  require  access. 
Develop  a  model  for  this  system  and  show  absence  of  deadlock,  exclusive  access  to 
the  resource  and  access  progress  for  every  process. Is the  system  ”buffer  tolerant”? 
Outline  how  your  model  might be implemented  in Java, 
11.7 Consider  a  ring 
of nodes,  each of which acts as a  simplified  replicated  database 
(Roscoe,  1998).  Each  node  can  autonomously  update its local  copy.  Updates are cir- 
culated  round  the  ring  to  update  other  copies. It is possible  that two nodes  perform 
local  updates  at  similar  times  and  propagate  their  respective  updates.  This  would  le
to  the  situation  where  nodes  receive  updates in different  orders,  leading to inconsis- 
tent  copies  even  after  all  the  updates  have  propagated  round  the  ring.  Although  we 
are prepared to tolerate  copy  inconsistency  while  updates are circulating,  we  cannot 
accept  inconsistency  that  persists. 
To ensure  consistent  updates  in  the  presence 
of 
node  autonomy  and  concurrency/  we  require that, when  quiescent (no updates are 
circulating  and  no  node is updating its copy), all copies  should  have  the  same  value. 
In order  to  achieve  this,  we  assign  a  priority  to  each  update  according  to an (arbi- 
trary)  ordering of the  ori  inating  node.  Thus,  in  the  case of clashes  due  to two simul- 
taneous  updates by different  nodes,  node  i 
has priority  over  node j if icj. S i m u l t ~ e i ~  
is recognized by a  node  receiving  an  update  while  still  having 
an outstanding  update. 
Develop a model for this system and show absence 
of deadlock  and  consistent 
values  when  quiescent. 

274 
C ~ p t e r  
I I: Conc~rrent Arc~itect~res 
(Hint: In order to keep  the  problem  simple,  let  each  node deal with ody a  single 
value.  Updates are passed  round  the ring in the form:  [j][x]  where  j=originator and 
x=update value.  Nodes  should  be  connected  by  channels  which  can  be  modeled as 
follows.) 
c~~~~ N = 3 
// n ~ ~ b e r  
of nodes 
Nodes = O..N-l 
Max = 2 
// u ~ d a ~ e  
values 
Value = O..Max-l 
C~ANNEL 
( ~ ~ [ j : N o d e s ] [ x : V a l u e ] - ~ o u t [ j ~ [ x ~ - ~ C ~ A N N E L ) ~  

The  programs  we  have  developed  in  the  previous  chapters 
of this  book  are  not 
explicitly  concerned  with  the  passage of time. We  have  used  delays  to  make  the 
execution of example  programs  viewable  in  a  convenient  way,  however  the  cor- 
rect  operation of these  programs  is  independent of t h e .  Correctness  depends on 
performing  actions  in  a  certain  order  and  not  on  performing  an  action 
by a  certain 
time.  This  has  the  advantage  that  the  programs  work  safely,  independently 
of 
processor  speed  and  thread  scheduling. 
h this  chapter, we  develop  programs  that are concerned  with  the  passage  of 
time  and in which correctness does depend  on  performing  actions 
by specific 
times.  In  general,  we  deal  with  the  relationship  between  the  time  at  which 
program  actions  are  executed  and  the  time  that  events  occur  in  the  real 
world. We make  the  simplifying  assumption  that  program  execution  proceeds 
sufficiently  quickly  such  that, when  related  to  the  time  between  external  events, 
it  can  be  ignored.  For  example,  consider  a  program  that  detects  double  mouse 
clicks.  The  program  notes  the  time  that  passes  between  successive  mouse  clicks 
and  causes  a  double-click  action  to  be  executed  when  this  is  less  than  some 
specified  period.  The  inter-click  time  for  such  a  program  would 
be specified 
in  tenths of a  second,  while  the  instructions  necessary  to  recognize  clicks  and 
measure  the  inter-click  time  would  require  tenths of a xnillisecond. In  modeling 
and  developing  such  a  program, it is  reasonable to ignore  the  execution  time of 
actions. We  can  assume  that  the  execution of an action  takes  zero  time,  although 
we do  not  assume  that  executing an Minite number  of  actions  takes  zero  time. 
A much  more  difficult  approach  to  action  execution  time  is  to  specify  and 
subsequently  guarantee  an  upper  bound  to  execution  time.  This  falls  into  a 
specialized  area of concurrent  software  design  termed r e ~ Z - ~ ~ ~ e  
and it is  beyond 
the  scope of this  book. 
In  the  following,  we  first  examine  how  we  can  incorporate  time  into  models 
and  then  how  the  behavior  exhibited 
by these  models  can  be  implemented  in  Java. 

In  Chapter 3, we stated  that  our  model of concurrent  execution  was async~rono~s; 
processes  proceed at arbitrary  relative  speeds.  Consequently,  the  delay  between 
two successive  actions  of  a  process  can  take  an  arbitrarily  long  time.  How  then 
do 
we make  processes  aware of the  passage of time  and, in particular,  how  can we 
synchronize  their  execution  with  time?  The  answer  is  to  adopt  a  discrete  model 
of 
time  in  which  the  passage 
of time  is  signaled 
by successive  ticks of a  clock. 
Processes  become  aware of the  passage of time by sharing  a  global  tick  action. 
Time is  measured  as  a  positive  integer  value.  To  illustrate  the  use  of  this  model 
of 
time,  we  return  to  the  double-click  program  described 
in the  introduction  to  the 
chapter.  Figure 12.1 depicts  the  relationship  between  discrete  time  and  mouse 
clicks. 
0
1
2
3
4
5
6
7
8
 
Figure 12.1 Discrete  time and mouse clicks. 
To make  the  discussion  concrete,  assume  that  the  unit 
of time  represented in 
Figure  12.1  is  a  second.  We  specify  that  a  double-click  should 
be reco 
the  time  between two successive  mouse  clicks  is  less  than,  say,  three  seconds.  We 
can  easily  see  that  the  click  during  period 
0 and  the  click  during  period 
1 con- 
stitute  a  double-click  since  the  interval  between  these  clicks  must 
be less  than two 
seconds.  The  click  during  period 3 and  the  click  during  period '7 do  not form a 
double-click  since  there  is  an  interval  between  these  clicks 
of at  least  three  seconds, 
The  use of discrete  time  means  that we  cannot  determine  precisely  when  an  event 
occurs, we  can  only  say  that it occurs  within  some  period  delimited by two ticks of 
the  clock.  This  gives  rise  to  some 
t i ~ i n g   ~ n c e r t a i n ~ .  
For  example, if the  last  mouse 
click  happened in period 6, would  a  double-click  have  occurred  or  not? 
The  most 
we  could  say  is  that  the  last 
two mouse  clicks  were  separated by at  least two 
seconds  and  not  more  than  four  seconds.  We  can  increase  the  accuracy 
by having 
more  ticks  per  second,  however  some  uncertainty  remains,  For  example,  with 
two 
ticks  per  second, we could  say  that 
two clicks  were  separated by at least  2.5 
seconds  and  not  more  than 
3.5 seconds.  In  fact,  this  certain^ also  exists in 
implementations  since  time  is  measured in computer  systems using a  clock  that 

ticks with a fixed periodicity,  usually  in  the order of milliseconds. h 
implemen- 
tation can  only  detect that two  events are separated by  time (n f 
l)*T,  where T is 
the  periodicity of the  clock and n the  number of clock  ticks  between  the  two 
events. In  general, despite the li~tations we have discussed  above,  discrete 
time  is  sufficient  to  model  many  timed  systems  since  it  is  also  the  way  time  is 
represented  in imple~entations. 
In  the  example  above, 
if we want to ensure that the clicks which form 
a 
double-click are never  more 
than three  seconds 
apart, the last click would 
have to happen  in period 5. Consequently,  after  the  first  mouse  click  occurs, 
the clock must not tick  more 
than three  times  before 
the second  click 
of a 
double-click  occurs. To capture the  behavior of the  double-click  program 
as a 
model in FSP, we  use the t i c k  action  to  signal  the  beginning (and end) of each 
period. A. dou b l e c l i c  k action occurs if less than three t i c k  actions  occur 
between  successive  mouse 
clicks. l%e  behavior of the double-click  program 
is  modeled as follows: 
LICK I c l i c k  -> PERIOD[l]), 
(t==D) t i c k  -> ~OUBLECLICK 
(t<D) 
t i c k  -> P E ~ I O D ~ t ~ l ]  
I c l i c k  -3 ~ o ~ b l e c l i c k  
-> DOUBL 
CLICK process  accepts a c l i c k  action at any the, since  initially, 
there is a choice  between c l i c k  and t i c k ,  When a c 1 i c  k occurs,  the  process 
starts counting the t i c k s  that follow. If a c l i c k  occurs  before the third sue 
ceeding t i c  k , then a double c l i c k  action  is output, otherwise  the  process 
resets. Figure 12.2 shows the LTS for DOUBLECLICK and  two  possible  traces 
of the  model; in (a) a dou b l e c  l i c  k is output after  two clicks and in (b) it is 
not. 
In  discussing  the  double-click 
program, we  assumed that clock  ticks  occur 
every  second.  However,  this  is  simply an interpretation of the model. We  choose 
an interpretation for a tick that is appropriate to the problem at hand. For 
example,  in  modeling  hardware  circuits,  ticks  would  delimit 
periods measured 
in nanoseconds.  However, within a particular time  frame,  the  more  accurately 
we  represent  time,  the  larger  the model. For  example, if we  wanted to increase 
the  accuracy of the  double-click  model  while  retaining  the  same  time  frame,  we 
could  decide to have two  ticks  per  second and, consequently, the parameter D 
would  become 6 rather than 3. This  would double the number of states in 
DOUBLECLICK. 

278 
C ~ ~ p ~ e r  
12: ~ i ~ e d  
Systems 
Figure 12.2 DOUBLECLICK LTS and traces, 
The  previous  example  dealt  with  how  a  process  is  made  aware  of  the  passage  of 
time. We  now  examine  the  implications 
of time in models  with  multiple  processes. 
We  look  at  a  simple producer-consmer system in which  the  consumer  process 
produces  an  item  every Tp seconds  and  the  consumer  process  takes Tc seconds  to 
consume  an  item.  The  models  for  the  producer  and  consumer  processes  are  listed 
below: 

12.1 ~ o ~ e ~ i ~ g  
~ i m e ~  
Systems 
279 
CONSUMER(Tc=3) = 
(item -> DELAY[i] 1 tick -> CONSUMER), 
DELAY~t:i .Tc] = 
(t==Tc) tick -> 
(t<Tc) tick -> 
1. 
P~O~UCER(Tp=3) 
= 
DELAY[t:i.  .Tp] 
= 
(item -> DELAY[i]), 
(t==Tp)  tick -> 
(t<Tp)  tick -> 
) *  
Note  that  the  consumer  initiallq 
action.  This  models  waiting  for 
CONSUMER 
DELAY[t+i] 
PRODUCER 
DELAY [ 
t+l  ] 
has  a choice  between  getting an it em and a tick 
an action  to happen while  allowing  time  to  pass. 
We can  model  the  three  possible  situations  that  can  occur  when  the 
PRODUCER and 
CONSU~ER 
processes  are  combined.  Firstly,  the  situation  where  items  are  produce
at the s
~
~
e
 
rate  that  they  are  consumed: 
I jSAME = (PRODUCER(2) I I  CONSUMER(^)). 
Analysis of this  system  does  not  detect  any  safety  problems.  Similarly,  analysis 
detects  no  problems  in  the  system  in  which  items  are  produced 
at a s l ~ ~ e r  
rate  that 
they  are  consumed: 
1 ISLOWER = (PRODUCER(3) I I CONSUME~(2)). 
However,  analysis of the  system  in  which  the  producer  is 
faster than the 
consumer  detects  the  deadlock  depicted  in  Figure 12.3. 
I IFASTER = I PRODUCER(^) 1 I CONSUMER(3)). 
The  deadlock  occurs  because  after  the  first  item  is  produced and accepted  by  the 
consumer,  the  producer  tries to produce  another  item  after  two clock  ticks,  while 
the  consumer  must  accept  a  third  clock  tick  before  it  can  accept  another  item.  T
deadlock  is  caused  by  the  timing  inconsistency  between  producer 
and consumer. 
The producer  is  required  to  produce an item  every two seconds  while  the  con- 
sumer  can  only  consume 
an item  every  three  seconds.  This  kind 
of deadlock, 
caused  by  tiaxing  inconsistencies,  is  termed  a ~ ~ ~ e - s t ~ ~ .  
If we  combine  processes 
into  a  system and time-stop  does  not  occur, we can  say  that  the tbing assump- 
tions  built  into  these  processes  are  consistent. 

item 
 
tick 
 
tick 
tick 
item 
 
tick 
tick 
Figure 12.3 Timed P r o d u c e r ~ o ~ u m e ~  
deadlock. 
Consider  a  system  that  connects  the  producer 
and c o n s ~ e r  
processes of the 
previous  section  by  a  store  for  items 
as shown  below: 
 STORE(^=^) = STORE[O], 
STORE[i:O..N] = (put -> STORE[i+l] 
(i>O) get -> STORE[i-l] 
)- 
I ISYS = ( ~ R O ~ U C E R ( l ) / ( p u t / i t e ~ ~  
I ICONSU~ER(l)/(set/item) 
I /STORE 
) =  
We would  reasonably  expect  that if we  specify  that  items  are  consumed at the 
same  rate  that  they  are  produced  then  the  store  would  not  overflow. h fact, if a 
safety  analysis  is  performed  then  the  following  violation  is  reported: 
Trace to property  violation  in  STOR 
Put 
tick 
Put 
tick 
Put 
tick 
Put 

12.1 ~ o d e l i ~ g  
Timed 
 
281 
This  violation  occurs  because  the  consumer  has  a  choice  between  getting 
an item 
from  the  store,  by  engaging  in  the 
get action, and engaging  in  the t i c k  action. If 
the  consumer  always  chooses to let  time  pass,  then  the  store  fills 
up  and over- 
flows. To avoid  this  form of spurious  violation  in b e d  models, we must  ensure 
that an action  occurs as soon  as  all  participants  are  ready to perform it. This  is 
known  as  ensuring ~~~i~~~ progress of actions. We can  incorporate  maximal  pro- 
gress into our timed  models  by  making  the 
t i c k  action  low  priority. For the 
example,  a  system  that  ensures  maximal  progress  is  described  by: 
l (NEW-SYS = SYS>>{tick). 
Safety  analysis of this  system  reveals  no  violations.  Maximal  progress  means  that 
after  a  tick,  all  actions  that  can  occur  will happen before  the  next  tick,  However, 
even  though  we  assume  that  actions  take  a  negligible  amount 
of time,  it  would  be 
unrealistic  to  allow an infinite  number of actions to occur  between  ticks. We can 
easily  check  for  this  problem  in  a  model  using  the  following  progress  property, 
which  asserts  that  a 
t i c k  action  must  occur  regularly  in  any  infinite  execution  (se
Chapter 7). 
ss TIME = {tick) 
The  following  process  violates  the TIME progress  property  because  it  permits an 
infinite  number of compute actions  to  occur  between t i c k  actions: 
PROG = ( s t a r t  
-3 LOOP l t i c k  -> PROG) , 
LOOP = (compute -> LOOP I t i c k  -> LOOP). 
l ICWECK = PROG>>{tick). 
The progress  violation  is  reported  by  the  analyzer  as: 
Progress  violation: TIME 
Path  to  terminal  set 
of states: 
Actions  in  terminal  set: 
{compute) 
s t a r t  
If we  include an action  that  terminates  the  loop 
and then  engages  in  a 
t i c k  action, 
the  progress  property  is  not  violated: 
PROG = (start 
-> LOOP I t i c k  -> PROG), 
LOOP = (compute -> LOOP 1 t i c k  -> LOOP 
lend -> t i c k  -> PROG 
1. 

This  may  seem  strange  since  the  loop  still  exists  in  the  process.  However,  the 
end 
and compute actions  are  the  same  priority  and  consequently,  with  the  fair  choice 
assumption of Chapter 'I, the compute action  cannot be chosen  an  infinite  number 
of times  without  the end action  being  chosen.  The  revised LOOP now  models  a 
finite  number of iterations.  The tick action  following end means  that  the PROG 
process  can  only  execute  this  finite LOOP once  every  clock  tick.  Consequently,  the 
TIME progress  property  is  not  violated. 
Incorporating  tirne  in  models by the  simple  expedient of a  global t  ick 
action  is 
surprisingly  powerful. In the  following,  we  look at modeling  techniques  for  situa- 
tions  that  occur  frequently in timed  systems. 
The  examples  we  have  seen 
so far  produce  an  output  or  accept  an  input  at  a 
precise  time,  within  the  limitations of the  discrete  model of time.  The INTERVAL 
process  below  produces  an  output 
at any  time  after Min ticks  and  before Max ticks. 
The  LTS  for  the  process is depicted in Figure 12.4. 
OUTPUT(M~n=I,~ax=3) 
= 
OUTPUT[t:I..~ax] = 
(start -> OUTPUT[1] I tick -> OUTPUT), 
&& t<=MaX) Output ->OUTPUT 
tick ->OUTPUT[t+l] 
)- 
start 
tick 
tick 
output 
Figure 12.4 L E  
for OUTPUT ( 
1 ,3). 

12.1 ~ o d e l i ~ g  
Timed 
 
283 
The  technique of using  choice  with  respect to the tick action  allows us to  model 
processes  in  which  the  completion  time  is  variable,  for  example,  due  to  loading  or 
congestion. 
A variation  on  the  previous  technique is a  process  that  periodically  produces an 
output  at  a  predictable  rate.  However,  the  output  may be produced  at  any  time 
within  the  period. In c o ~ ~ c a t i o n  
systems,  this  kind of timing  certain^ is 
termed ~
~
~
~
e
~
.
 
The J 
ITTER process  defined  below  is  an  example 
of how jitter  can be 
modeled.  Figure 12.5 depicts  the LTS for  the JITTER process. 
J 
ITTER  (Max=2) 
= 
JITTER[t:l.  .Max] = 
(start -> JITTER[ 1 3  I tick -> JITTER), 
(Output -> FINISH[t] 
(tKMax) tick -3 JITTER[t+l] 
(t==Max) o~tput 
-3 FINISH[t] 
ick -> FINISH[t+l] 
ick - 2  JITTER 
tick 
tick 
Figure 12.5 LTS for JITTER ( 2 ) .  

284 
~ h a ~ t e ~  
12: Timea Systems 
Timeouts  are  frequently  used  to  detect  the  loss 
of messages  in c o ~ ~ i c a t i o n
systems  or  the  failure 
of processes  in  distributed  systems.  Java  provides  a  ver- 
sion of the wait ( ) s ~ c h r o ~ a t i o n  
primitive  that  takes  a  timeout  parameter - 
a 
wait ( ) invocation  returns  either  when  notified  or  when  the  timeout  period 
expires.  The  most  elegant way to  model  a  timeout  mechanism  is to use  a  sepa- 
rate  process  to  manage  the theout, as shown  below  for  a  receive  operation  with 
a theout. The  timeout and receive  processes  are  combined  into  a 
R ECE 1 VER 
process. 
TIMEOUT(D=l) 
= (setTO 
-> T I ~ E O U T ~ O ~  
I(tick,resetTO) -> TIMEOUT 
L 
T I ~ E O U T ~ t : O . . ~ ]  
-> T I ~ E O U T ~  
t+l 1 
Out -> T ~ ~ E O U T  
1 resetTO 
-> TI~EOUT 
)
a
 
RECEIVE = (start 
-> set70 -2 WAIT), 
WAIT 
= (timeout -> RECEIVE 
lreceive -> resetTO -> ~ECEIVE 
1 IRECEIVER(D=2) = (RECEIVE 1 I TIM~OUT(D)) 
>>(receive,timeou~,start,tick) 
~(receive,tick,timeout,start~. 
In addition to tick, the start, receive and timeout actions  are  declared as 
low  priority irt the RECEIVER composite  process.  This  is  because  maximal  pro- 
gress  requires  that an action  take  place  when  all  the  participants  in  that  action 
are  ready.  However,  the  participants  in ~terface actions  depend  on  the  system 
into  which RECEIVER is  placed, so we should  not apply maximal  progress  to 
these  actions  within  the 
RECEIVER process but later at the  system  level. 
Consequently,  we  give  interface  actions  the  same  priority  as  the 
tick action. 
All internal  actions  have  a  higher  priority. 
The  rninimized LTS for RECEIVER, 
which  hides  the  internal  actions  concerned  with  setting 
and resetting  the  time- 
out,  is  depicted  in  Figure 12.6. 

12.2 ~ ~ p l ~ e n t i n ~  
Timed 
 
285 
start 
 
tick 
timeout 
receive 
Figure 12.6 LTS for RECEIVER (3). 
Timed  concurrent  systems  can be implemented  in  Java by a  set of threads  which 
use sleep ( ) and  timed wait ( ) to  synchronize  with time, We  can  characterize 
this  as  a ~
~
~
e
~
~
-
~
~
s
e
~
 
approach  since  active  entities  in  the  model  are  translated  into 
threads in an  implementation.  This  approach  to  translating  models  into  programs 
was  used  in  the  preceding  chapters  for  non-timed  systems.  In  this  chapter,  we 
exploit  the  time-driven  nature of the  models  and  use an e ~ e ~ ~ - ~ ~ s e ~
approach  in 
which  active  entities  are  translated  into  objects  that  respond 
to thing events. 
Essentially,  the tick action  in  the  model  becomes  a  set of events  broadcast by a 
time  manager  to  all  the  program  entities  that  need  to  be  aware of the  passage of 
time. The organization of a  timed  system  implementation  conforms  to  the 
Announcer-Listener  architecture  described  in  Chapter 11, with  the  time  manager 
acting  as  the  announcer  and  timed  objects 
as the  listeners. We  have  chosen  this 
event-based  approach  for two reasons.  First,  the  translation  from  timed  model  to 
timed  implementation  is  reasonably  direct;  and  secondly,  for  timed  systems  with 
many  activities  the  resulting  implementation  is  more  efficient  than  the  thread- 
based  approach  since  it  avoids  context-switching  overheads.  However, 
as dis- 
cussed in the  following,  the  approach  also  has  some  limitations  when  compared 
with  a  thread-based  approach. 

286 
C ~ ~ ~ f e ~  
12: T i ~ e ~  
Systems 
Each  process in a  timed  model that has tick in its alphabet  becomes  a t i ~ e ~  
object 
in an implementation. A timed object  is created  from  a  class that implements  the 
Timed interface  listed in Program  12.1. 
Program 12.1 Timed interface. 
Each  timed  object  is  registered  with  the  time  manager,  which  implements  a 
two- 
phase event  broadcast. In phase 1, the pret ic k ( ) method of each  timed  object  is 
invoked and, in phase 2, the tick ( ) method  is  invoked.  The  behavior 
of a  timed 
object  is provided by  the  implementation of these two methods. In the pre-tick 
phase,  the object perfoms all output actions  that  are  enabled in its current state. 
These  may  modify  the state of other  timed  objects. In the tick phase,  the  object 
updates its state with respect  to inputs and the  passage of time.  Two  phases are 
needed  to  ensure  that c o ~ ~ i c a t i o n  
between  timed  objects  completes  within  a 
single  clock  cycle.  We  clarify 
the  translation  from  model  processes  into  timed 
objects,  with pretick() and tick() methods and the  use of the TimeStop 
exception, in the  examples  that  follow. 
A version of the countdown timer  model introduced in Chapter 2 is  given  below. 
COUNTDOWN (N=3) = C O U N T D O ~ ~ [ N ~ ,  
COUNTDOWN~i:O.~N] 
= 
(i>O) tick -> C O U N T ~ O ~ N ~ i - 1 ~  
(i==O) beep -> STOP 
1. 
The COUNTDOWN process outputs a beep action  after N ticks and then stops. The 
implementation  is  given 
in Program  12.2.  The  translation  from  the  model  is 
straightforward. Each invocation of the t kc k ( ) method  decrements  the  integer 
variable i. When i 
reaches  zero,  the  next  invocation of p ret ic k ( ) performs  the 
beep  action and the  timer stops by removing  itself  from  the  time  manager.  The 
operation of Time~ana~er 
is  described in the  next  section. 

22.2 ~mpleme~ti~g 
Timed Systems 
287 
Program 12.2 TimedCountDown class. 
The  next  example  implements  the producer-co~umer model of section  12.1.1. To 
keep  the  code  succinct,  the  timed  class  definitions  are  nested  inside  the 
~ r o ~ u c e r C o n s u ~ e r  
class of Program  12.3.  The  class  creates  the  required 
instances of the  producer,  consumer  and  time  manager  classes. 
Program 12.3 ProducerConsumer class. 

288 
C ~ ~ ~ e r  
12: T i ~ e ~  
Systems 
For  convenience,  the  producer  process  is  listed  below: 
PRODUCER(Tp=3) = 
DELAY[t:l. .Tp] = 
(item -> DELAY[l]), 
( w ~ e ~ ( t = = T p )  
tick -> ~ R O D U ~ E R  
~ w ~ e ~ ( t c T p )  
tick -> DELAY[t+l] 
Initially,  the  producer  outputs an  item  and  then  waits  for 
Tp clock  ticks  before 
outputting  another  item.  The  timed  class  that  implements  this  behavior  is  listed  in
Program 12.4. 
Program 12.4 Producer class. 
An instance of the  Producer  class  is  created  with 
t = 1 and  the consumer it em ( ) 
method  is  invoked on the  first  pre-tick  clock  phase  after  creation.  Each  subsequent 
tick  increments t until  a  state is reached  when  another  item  is  output.  The  beha- 
vior  corresponds  directly  with PRODUCER. 
Now  let  us  examine  how  the item ( ) method  is  handled by the  consumer.  The 
timed  model  for  the  consumer  is  shown  below.  The  consumer  waits  for  an  item 
and  then  delays Tc ticks  before  offering  to  accept  another  item. 

12.2 l m ~ l ~ e ~ t i ~ g  
Timed 
 
289 
CO~SU~ER(Tc=~) 
= 
DELAY[t:I..Tc] = 
(item -> DELAY[l] I tick -> CO~SU~ER), 
(t==Tc)  tick 
-3 C O ~ S U ~ E R  
(t<Tc)  tick -> DELAY[t+l] 
1- 
The hplementation of C O ~ S U ~ E R  
is  listed  in  Program 12.5. 
Program 12.5 Consumer class. 
In the Consumer class,  the tick ( ) method  returns  immediately if the consuming 
field  has  the  value null, implementing  the  behavior of waiting for an item.  The 
item ( ) method  sets  this  field  when  invoked  by  the  producer.  When 
consu~ing 
is 
not null, the tick ( ) method  increments t until Tc is  reached and then  resets 
consuming to  null  indicating  that  the  item has been  consumed and that  another 
item  can  be  accepted.  Effectively, con S uming represents  the DE LAY states  in  the 
model. If the  producer  tries  to  set 
consuming when  it is not null then  a TimeStop 
exception  is  thrown.  This  si 
1s a  timing  inconsistency  in  exactly  the  same way 
that  a ~
~
~
e
-
s
~
~
~
 
deadlock  in  the  model  is  the  result 
of a t W g  inco~istency. 
Times  t 
o p is  thrown if the  producer  tries  to output an item  when  the  previous 
item  has  not  yet  been  consumed. 
As we  see  in  the  next  section,  a 
TimeS~op 
exception  stops  the t h e  manager and consequently,  no  further  actions  are  exe- 

290 
~ ~ ~ p t e r  
12: ~ i ~ e d  
Systems 
cuted.  The  implementation  of  producer-consumer  has  exactly  the  same  property
as 
the  model.  For  correct  execution, Tc must be less  than  or  equal  to Tp. Note  that,  in 
the CO n s ume r class,  the  method p  ret 
ic k ( ) has  no  implementation  because  the 
class  has  no  outputs. 
The  operation of the  two-phase  clock  cycle  should  now 
be clear.  Methods  on  other 
objects  are  invoked  during  the  pre-tick  phase  and  the  changes  in  state  caused 
by 
these  invocations  are  recognized  in  the  tick  phase.  This  ensures  that  actions  com- 
plete in a  single  clock  cycle.  However,  this  scheme  only  approximates  the  maxim
progress  property of timed  models.  Maximal  progress  ensures  that  all  actions  that 
can  occur  happen  before  the  next  tick.  Our 
~plementation scheme  only  gives  each 
timed  object  one o p p o r ~ t y  
to  perform  an  action,  when  its 
p  ret 
ic k ( ) method  is 
executed. A multi-way  interaction  between  timed  objects  thus  requires  multiple 
clock  cycles. An example of a  multi-way  interaction  would  be  a  request  action 
followed by a  reply  followed by an ac~owledgement (three-way).  Maximal  pro- 
gress  in  the  model  ensures  that  such  a  multi-way  interaction  would  occur  withi
single  clock  cycle 
if no i n t e ~ e ~ g  
tick  events  were  specified. 
We could  implement 
a  multi-phase  clock  scheme  to  allow  multi-way  interaction  in  a  single  clock  cycle, 
however  this  complexity  might 
be better  dealt  with by reverting  to  a  thread-based 
implementation  scheme.  In  fact,  the  examples  later  in  the  chapter  show  that  th
phase  scheme  is  sufficiently  powerful  to  implement  quite  complex  systems  that 
exhibit  the  same  behavior  as  their  models. 
We take  care  that  multi-way  interaction 
within  a  single  clock  cycle  is  not  required.  This  usually  means  that  we  introduce
inte~ening tick  in  the  model,  for  example  between  a  request  and  a  reply. 
h addition to the  ease  with which  models  can be translated  into  implementa- 
tions,  the  event-based  implementation  scheme  has  the  advantage,  when  compared
to  the  thread-based  scheme,  that  we  do  not  have  to  synchronize  access  to  shared 
objects.  The  activations of the tick ( ) and pret  ick 
( ) methods of a  timed  object 
are  indivisible  with  respect  to  other  activations of these  methods.  This  is  because 
the  methods  are  dispatched  sequentially by the  time  manager.  Method  dispatch 
incurs 
 
much 
 
less 
 
overhead 
 
than 
 
context-switching 
 
between 
 
threads. 
Consequently,  the  event-based  scheme  is  more  efficient  in  systems  with  large 
numbers of time-driven  concurrent  activities. An example of such  a  system  is 
presented  in  the  final  section of the  chapter. 
The T i m e ~ ~ ~ a ~ e r  
class  (Program 12.6) maintains  a  list of all  those  timed  objects 
which  have  registered  with it using a d d ~ i ~ e d ( ) .  
The pretick() and tick() 

12.2 ~ ~ p l e ~ e ~ f i ~ g  
Timed Sysfms 
291 
methods  are  invoked  on  all Timed objects  in  this  list by the Time~anager thread 
every delay milliseconds.  The  value of delay can  be  adjusted by an external 
control, such as a  slider  through  the 
Ad j us t 
me n t List en e r interface  that  the  class 
implements. 
Program 12.6 TirneManager class. 

292 
Chapter 12: T i ~ e d  
Systems 
The  data  structure  used to hold  the  list of timed  objects  must be designed  with 
some  care. A pret i c  k ( ) or t i c k  ( ) method  may  cause  a  timed  object  to  remove 
itself from  the  list. To ensure  that  such  a  removal  does  not  destroy  the  integrity 
of 
the  list  data  structure, we  use  an  irrtmutable list  that  does  not  change  during an 
enumeration  off  it. If a  removal  occurs  during  a  broadcast,  this  removal  generates 
a  new  list  which  is  used  for  the  next  broadcast.  The  class 
i~plementing the 
immutable  list  is  given in Program 12.7. 
Program 12.7 ImmutableList class. 
The delay and c l o c k e d   T i ~ e ~ a n a g e r  
fields  (Program 12.6) are  declared  to be 
ensures  that  the run ( ) method  reads  the  actual  value of these  fields  before  every 
tile since  they can be  changed by external  threads.  The  keyword v 

broadcast. It prevents  a  compiler  optimizing  access  by  storing  the  fields  in  local 
variables  or  machine  registers. 
If such an optimization  occurred,  the  values 
would 
be  read  only  once, when the run ( ) method started, and it would not see  subse- 
quent updates. 
The pretick ( ) method  allows  a  timed  object  to 
throw a TimeStop exception 
if it  detects  a  timing  inconsistency.  This  exception  terminates  the T i m e ~ a n a ~ e r  
thread. Consequently,  a  timing  inconsistency in an implementation has the  same 
behavior as a model with timing  inconsistency - 
no further  actions  can  be  exe- 
cuted. 
The  parcel  router  problem  is  concerned 
with the  simple  parcel-sorting  device 
depicted in Figure 12.7. 
Figure 12.7 Parcel  router device. 
Parcels are dropped into  the  top of the  router and fall  by  gravity through the 
chutes. Each  parcel has a  destination  code that can  be  read  by  sensors.  When  a 
parcel  passes  a  sensor,  its  code  is  read 
and the  switch  following  the  sensor  is  set 
to 
route the  parcel  to  the  correct  destination  bin. 
Ln this  simple  router,  there are only 
four  possible  destinations  numbered  from  zero  to  three.  The  switches  can  only  be
moved  when  there  is 
no parcel in the  way.  The  problem 
was originally  formulated 
as a  simple  case study to  show that specifications are not independent of imple- 

294 
C
~
~
~
e
r
 
12: ~ i m e ~  
Systems 
mentation  bias  (Swartout, 
1982). It was  called  the 
Package ~~~~e~ problem. We 
have  renamed  packages  to  parcels  to  avoid  possible  confusion  with  Java  package
In  the  following,  we  develop  a  timed  model 
of the  parcel  router  and  then 
hplement a shulation based  on  the model, We  ignore  gravity  and  friction  and 
assume  that  parcels  fall at a  constant  rate  through  chutes  and  switches. 
The  overall  structure of the  parcel  router  model  is  depicted  in  Figure 12.8. Parcels 
are  fed  into  the  routing  network 
by a  generator  process  and  emerge  from  the 
network  into  one of four  destination  bins. 
I l~AR~EL-RO~TER(T=4) 
= 
(top:STA~E(l) 
1 I left:STAGE(O)I I right:STA~E(O) 
I I GEN(T) 1 I ~orall~d:O..3] 
BIN(d) 
)/{ enter/top.enter, 
top.left/left.enter,  top.right/right.enter, 
dest[O]/left.left, 
 
dest[l]/left.right, 
dest[2]/rightmleft,  dest[3~/right,right, 
tick/{top,left,right).tick 
3>>{tick3~{enter,dest,tick~. 
Figure 12.8 Parcel  router  model  structure. 

12.3 P ~ ~ c e l  
Router P r o ~ l e ~  
295 
The  generator  process 
GEN, defined  below,  generates  a  parcel  every 
T units of 
t k e .  Each  parcel  contains  the  number  of  its  destination. 
The  generator  picks  a 
destination  for a parcel  using  non-deterministic  choice. 
Parcel = {parcel[Dest]} 
GEN (T=3) = 
DELAY[t:l. .TI = 
(enter[Parcel] -3 DELAY[l] I tick -3 GEN), 
en DELAY[t+l] else GEN). 
The destination  bins  are  property  processes  that  assert  that  the  parcel  delivered 
by 
the  routing  network to the  bin  must  have  the  same  destination  number 
as the bin. 
BIN(D=O) = ( ~ ~ s t [ D ] . p a r c e l [ ~ ]  
-2 BIN) 
+{~est~D]~Parcel]3. 
We  have  subdivided  the  routing  network  into  three  stages.  Each  stage  has  an 
identical  structure.  The  parameter  to  a  stage 
~ e t e ~ e s  
its  level in  the  routing 
network.  The  structure  of  the 
STAGE composite  process  is  depicted  in  Figure 
12.9. 
Figure 12.9 STAGE structure. 

296 
C
~
~
~
e
r
 
12: T i ~ e d  
Systems 
The  composition  expression  which  Figure 12.9 represents  graphically  is: 
I /STAGE(L=O) = 
( a:CHUTE I I b:CHUTE I I g:S~ITCH 
1 I s:SE~SORCO~TROLLER(L) 
)/{ enter/a.enter, 
b.enter/{s.sense~a.leave}, 
g.enter/b.leave, s.setSwitch/g.setSwitc~, 
left/g.leave[O], right/g.leave[l], 
tick/{a,b,g}.tick 
} >>{enter,left,right,tick} 
~{enter,left,rig~t,tick}. 
Each  physical  chute  in  the  physical  device  is  modeled 
by a  set  of CHUTE processes. 
A CHUTE process  models  the  movement of a  single  parcel  through  a  segment of a 
physical  chute. To model  a  chute  that  can  have n parcels  dropping  through it, we 
need n CHUTE processes.  In  modeling  the  system,  we  use 
WO processes  and so we 
are  modeling  a  physical  chute  that  can  accommodate  only 
two parcels.  The CHUTE 
process  is  given  below: 
CWUTE(T=2) = 
(enter[p:Parcel~ -> DROP[p][O] 
I tick 
-> CHUTE 
), 
DROP[p:Parcel~~i:O..T] 
= 
-3 DROP[ p] [ 
i+l ] 
e[p] -> CHUTE 
L 
A parcel  enters  the  chute  and  leaves  after 
T units  of  time.  We  must 
be careful  when 
composing CHUTE processes  that  the  resulting  composition  has  consistent  timing. 
For  example,  the  following  system  has  a  time-stop. 
I ICHUTES = (~irst:CHUTE(i) 
1 1  seco~d:CHUTE(2)) 
/{second.enter/first.leave, 
tick/{first,second~,tick}. 
It happens  when  a  parcel  tries  to  enter  the  second 
CHUTE before  the  previous 
parcel  has  left.  Time-stop in this  context  can be i n t e ~ r ~ t e d  
as  detecting  a  parcel 
jam in  the  physical  device,  For  consistent thing in  a  pipeline of CHUTE processes, 
each  process  must  have  a  delay which is  the  same  or  greater  than  the  delay of its 
successor. 

22.3 P~rcel ~ o ~ t e r  
P r o ~ l e ~  
297 
This  process  detects  a  parcel  by  observing  the  action  caused by a  parcel  passing 
to  the  next.  Based  on  the  destination  of  the  parcel, 
it computes 
should  be  set.  This  routing  function  depends  on  the  level 
of the 
stage.  Because  the  network  is  a  binary  tree, it is  simply  (destination>>Level)gz:l  (in 
this  expression  context, >> is  the  bit s~~ operator  and (41; the  bit-wise and opera- 
tion  returns  either  zero,  indicating  left,  or  one,  indicating  right. 
is  not  a  timed  process  since  we 
a s s u e  that  detection  of 
the  parcel  and  computation  of  the  route  takes  negligible  time.  Each  execution 
occurs  within  a  clock  cycle. 
During  the  time  that  a  parcel  takes  to  pass  through  the  parcel  switch, 
it ignores 
commands  from  the 
S ~ ~ S O R C O ~ T ~ O L L E ~ .  
This  models  the  physical  situation 
where  a  parcel  is  passing  through  the  switch  and  consequently,  the  switch  gate 
is ~ b s ~ u c t e d  
from moving. 
~WITCH(T=I) = SWITC~[OJ, 
 WITCH [ 
S : 
Dir] = 
(set~witch[x:Dir] 
-> SWITC~[x] //ucc~~ 
s
~
~
~
c
~
 
c
o
~
~
a
~
~
~enter[p:Parcel] -3 ~WITC~[s][p][O] 
I tick 
-> S W I T C ~ [ S ~  
1, 
S~~TCH[s:Dir][p:Parcel][i:O..T] 
= 
(setS~itch[Dir] 
-> SWITCH[ S] [p] 
[ i] / / ~ g ~ o r e  
l 
(i<T) tick 
-> ~ ~ I T C H [ s ~ [ ~ ~ [ i ~ l ]  
l 
(i==T)l~av@[s~[p] 
-3 S ~ I ~ C ~ [ s ]  
)
9
 
The SWITC~ 
process  extends  the  behavior of the CHUTE process  with  an  additional 
~omp~nent 
of its  state  to  direct  output  and 
an  extra  action  to  set  this  state. 
SWITCH 
can be implemented by deriving  its  behavior,  using  inheritance,  from  the  imple- 
mentation of CHUTE. 

298 
C ~ ~ ~ t e r  
12: ~
i
~
e
~
Systems 
Having  completed  the  definition 
of all  the  elements of the  ARCE EL-ROUTER model, 
we  are now in  a  position  to  investigate  its  properties. We first  perform  a  safety 
analysis of a  minimized   ARC EL-  OUTER (3) . This  system  feeds  a  new  parcel 
every  three  timing  units  into  the  routing  network.  This  produces  the  following 
property  violation: 
Trace to property violation in BI~(0): 
enter. parcel. 0 
tick 
tick 
tick 
enter. parcel. 1 
tick 
tick 
tick 
enter. parcel. 0 
tick 
tick 
tick 
enter. parcel. 0 
tick 
dest.O.parcel.0 
tick 
tick 
enter. parcel.0 
tick 
dest.O.parcel.1 
The  trace  clearly  shows that a  parcel  intended  for  destination  one 
has ended up in 
B1 N zero.  However,  while it may  be  obvious  to  the  reader 
why this has occurred, 
it  is  not  clear  from  the  trace  since we have hidden the  intermediate  events  that 
occur  in  each  stage. 
We can  elicit  more i~ormation from  the  model  in  a  number 
of 
ways. We can  make  internal  actions  visible 
and rerun the  analysis  or  we  can 
investigate  the  problem  using  the  animator  tool  provided  by 
LTSA. The  second 
approach has the advantage  that we do not  need  to  modify  the  model  in  any  way. 
We simply  select STAGE as the  target  for  analysis  (with  default  level  parameter 
as 
0) and run the  Animator  using  the  following menu to  specify  the  actions  we  wish 
to  control. 
TEST = ~enter~~arcel~,tick3 

12.3 ~
~
~
c
e
~
 
~ o ~ t e r  
 
e ~  
299 
The  trace  depicted  in  Figure 
12.10 was  produced  by  initially  choosing 
an 
enter I parcel. 0 action  followed  by  three t i c k  actions,  then enter.  parcel. 
1 
followed  by  five ticks. This  is  the  trace  produced  by  the  safety  violation, 
without 
the  subsequent  parcel  entries. 
The  Animator  trace  clearly  exposes  the  reason  for  the
violation. The  first  parcel  is  still  in  the  switch  when  the  sensor  detects  the  second 
parcel and tries  to  set  the  switch  to  direction 
1. Since  the  first  parcel  is  in  the  switch, 
the S . 
SE! t Swit c h .l action  is  ignored 
and the  switch  does  not  change. 
Consequently,  the  second  parcel  follows  the  first  in  going  to  the  left  when  it  
have  been  switched  to  the  right. 
Figure 12.10 Animation trace  for STAGE(0). 
The  physical  interpretation of the  problem  is  that  parcels  are  too  close  together 
to permit  correct  routing. We can  check  this in~ition 
by  analyzing  a  system  with  a 
slower  parcel  arrival  rate, ~ARCEL-~O~TER 
( 4) Safety  analysis  finds  no  problems 
with  this  system and progress  analysis  demonstrates that the "TIME property  is 
satisfied. 
In the  next  section, we describe  a  simulation of the  parcel  router  based  on  the 
model.  This ~plementation faithfully  follows  the  model  in  allowing  parcels  that 
are  too  close  together  to  be  misrouted. 

300 
~
~
u
~
~
e
r
 
22:  time^ Systems 
The display  for  the  parcel  router  simulation  is  shown  in  Figure  12.11. 
A new parcel 
for a  particular  destination  is  generated  by  pressing  the 
button beneath  that  des- 
tination.  Parcels  that  arrive at the  wrong  destination  flash  until  they  are  replaced 
by  a  correct  arrival.  The  speed of the  simulation  can  be  adjusted  using  the  slider 
control  to  the  right of the  display. This  controls  the T i ~ e ~ a n a ~ e r  
described  in 
section 12 2 
2. 
Figure 12.11 Parcel  router  applet  display. 
In  describing  the  parcel  router 
~plementation, we  concentrate  on  the  interfaces 
and classes  shown  in  Figure  12.12.  These  classes  implement  the 
b e d  behavior of 
the  simulation.  Display  is  implemented  by  the 
Parcelcanvas and Parcel 
classes.  Each Parcel object  is  registered  with  the ParcelCanva§/ which  displays 
the  parcel 
at its  current  position 
once  per  clock  cycle. 
In addition,  the 
Par  ce  LCanvas 
displays  the backgro~d and the  current  state of each  switch. 
The Parcel and Parcelcanvas code  can  be  found  on  the 
accompany~g CD- 
ROM. 
To permit  flexible interco~ection of Chute,  Switch, 
SensorCo~troller 
and 
~e§tination~in 
objects,  each  class  implements  the 
Parcel~over and 
Swit c hCon  t 
rol interfaces  listed in Program  12.8.  The  latter ~terface is required 
to  allow  switches  to  be  connected  to  controllers. 

12.3 Parcel ~ o ~ t e r  
Proble~ 
301 
I 
I 
l 
I 
I I 
I 
I 
I 
l 
I 
l 
I 
I 
I 
I 
l 
I 
I 
l 
I 
I 
I 
I 
I 
l
"
"
 
-r"--------- 
4 
/58nsolCOn11011811 
L- 
I 
l 
-r---------- l 
Figure 12.12 Parcel  router  classes  and  interfaces. 
P r Q g r a ~  
12.8 P a r c ~ l ~ o v ~ r  
and SwitchCont rol interfaces. 
The Ch u t e class  listed  in  Program  12.9  is  a  direct  translation 
of the CWUT 
defined in the  previous  section  using  the  method  described  in  section  12. 
cu r re n t field  is  not nu l1 then  the  chute  contains  a  parcel.  After T clock  cycles 
this  parcel  is  transferred  to  the 
Pa rce lMove r object  referenced by the next field, 
This field  is ~tialized en  the config~ation of chutes,  switches,  etc.  is  con- 
structed by the Parcel 
Program 12.9 Chute class. 

302 
C ~ a p t e ~  
12: Timed Systems 
The Switch class  listed in Program 12AO is  derived  from Chute. A Switch object 
has references  to  the 
P a r c e l ~ o v e r  objects  to 
its l e f  t and right. The 
set Swit c  h method  sets  the  next  field of the super class  to  one of these if there 
is no  parcel  currently o c ~ u ~ y ~ ~  
the switch. If there is, the c o ~ a n d  
to switch is 
ignored,  as in the  model.  Setting  the 
next field  means that when a parcel  leaves,  it 
is  sent  to  the P a r c e l ~ o v e r  referenced by either l e f t  or right. 
Program 12.10 S w i t ~ h  
class. 
. .. 

22.3 Parcel Router P r o ~ l ~  
303 
Program 112.10 ( C o ~ ~ ~ ~ u e ~ ) .  
The S e ~ ~ o r C o ~ t r o l l e r  
class  is  listed  in  Program 
12.11. Parcels  pass  through 
within  a  single  clock  cycle.  The  class  is  not  aware 
of time  and  does  not  implement 
the Timed interface.  Only  model  processes  that  have 
t i c k  in  their  alphabets  need 
to be implemented  as Timed classes. 
Program 12.11 SensorCont roller class. 
The P ~ r c e l ~ o u t e r  
applet  class  contains  a  set of methods  that  create  and  ”wire 
together”  the  parts of the simula~on. 
The  method  listed  below  creates  an  assembly 
that  corresponds  to  the STAGE composite  process of the  model. 

304 
C ~ ~ ~ t e r  
12: ~ i m e d  Systems 
ParcelMover makestage 
(ParcelMover left, Parcel~over right, 
in t  fa 
11Di r , // ~ o ~ e ~ e n t  
direction for parcel   is play 
int  level, // 0 or 1 as in the ~ o ~ e l  
int  gate 
// i ~ e n t i ~  
of gate for display p ~ ~ o s e s  
1 
// create parts and register each ~ i t h  
Time~an 
ag  e 
r t 
ic  ke 
r 
ticker. ~ d ~ T i m e d   ( a )  
; 
SensorController S = 
~ensorController(leve1); 
ticker.~ddTimed(b); 
W Chute(l~,fallDir); 
( l ~ , f a l l D i r ~ g a t e , d i ~ ~ l a y ) ;  
// wire parts together 
a.next = S ;  s.next = b; 
s.controlled = g; 
b.next = g; g.left = left;  g.right = ri 
The  method  exhibits  a  pleasing  correspondence  with  the 
STAG model.  The  model 
process  prefix  names  become  object  references  and  the  model  relabels  become 
reference assig~ents. 
The Destination~in 
class,  which  may be found  on  the  CD-ROM,  accepts  a 
parcel  object  and  displays 
it in  a  fixed  position.  When  a  new  parcel  arrives,  the  old
parcel  is  removed from  the  display.  Parcels  that  arrive  at  the  wrong  destination 
are  flashed by hiding  and  revealing  them  on  alternate  clock  cycles. 
The  reader  is  encouraged  to  run  the Pac  kag 
eRo u t  e 
r applet  and  observe  that 
its  behavior  is as predicted by the  model.  The res~iction that  only  one-way  inter- 
actions  can be supported by the  clocking  scheme  has  not  caused  a  problem  in  this 
example.  Even  though  the  interaction  between Chute, ~ensorCo~troller 
and 
Switch requires  more  than  one  method  call  in  a  clock  cycle, 
it is  still  a 
LI& 
directional  interaction  in  which  a  chute  output  causes an  input  to  another  chute 
and  a  switch. 
The  final  example of a  timed  system  is  a  simple  video  arcade  ame.  The  display  is 
depicted  in  Figure 12.13. The  spaceship  can be moved  around  the  screen  using  the 
cursor  keys.  Pressing  the  space  bar  on  the  keyboard  launches  a  missile  from  the 
spaceship.  Missiles  move up  the  display  and  appear as white  arrows  on  the  dis- 

22.4 Space ~ ~ ~ a ~ e r s  
305 
play.  Aliens,  depicted as spheres, drop from  the top of the  screen and explode 
when hit  by  a  missile.  When an alien  collides with the  spaceship, an explosion 
occurs and the  shield stren 
of the  spaceship  is  reduced. The  game  terminates 
when  the  shield  stren 
S to  zero. The  objective, as is usual in this  style of 
game,  is  to  shoot as many  aliens as possible. 
.l3 Space  invaders  applet  display. 
Video  games  involve  many  active  entities,  called 
s ~ ~ ~ ~ e s ,  
which  move around 
independently and concurrently.  A sprite has a  screen  representation and a  beha- 
vior.  Sprites  may  interact 
when they  collide. In Space  Invaders,  the sprites are the 
spaceship,  aliens,  missiles and explosions.  Sprites are essentially  concurrent  activ- 
ities,  which  we  could  consider 
~ p l e m e ~ t i n g  
as threads. However,  this would 
result  in  a  game  with  poor 
perfor~ance due to  the synchro~zation and con- 
overheads  involved.  A  much  better  scheme 
is to ~plement 
sprites 
S. Each sprite has an o p ~ o r ~ i t y  
to  move  once  per  clock  cycle.  This 
age that it  is  simple  to  synchronize  screen 
updates with sprite 
ly  repaint  the  screen  once  per  clock  cycle. 

Sprites  move  about in the ~ o - d ~ e n s i o n a l  
space  depicted  in  Figure 22.14. In an 
implementation,  the  coordinates  refer  to  screen  locations. 
h the  model,  we  use a 
smaller  space  to  perrnit  analysis. 
west 
 
east 
south 
S 
Figure 12.14 Came space. 
x 
The coordinate  system is represented  in  the  model  by  the  following  definition
In  the  interests of simplicity,  the width of the  game  space  is assmed to  be  the 
same as its depth. The undef label  is  used to specify  the  coordinate of a sprite that 
has  not  been  created and consequently  does not have a defined  position  on  the 
screen. 
Coord = ~[D~[D],undef3  //(x,y) 
The entities that comprise  the  Space  Invaders  game  have  behavior  in  common 
with respect  to  the  way that they  move about in  the  game  space. We model  this 
common  behavior as the SPRITE process  listed  below.  The  behavior 
of the  space- 
ship,  missiles and aliens  is  defined  using  this  process. 
SPRITE = 
(cre~te[x:D][y:D] 
-> SPRITE[x]~y] 
]tick -> SPRITE 
(pos.undef -> SPRITE 
1, 

12.4 Space ~ ~ v a ~ e ~ s  
307 
ITE[x:D~[y:D] 
= 
S P R I T E [ X ] [ ~ * ~ ]  END 
SPRITE[x][y+l] 
END 
SPRITE[x-l][y] 
END 
END 
) 9  
ND = (end -> SPRITE). 
Before  a  sprite  is  created,  its  location  is  undefined.  A  query  using  the  action 
POS 
will  return  the undef value for its  location.  After  the create action, pos returns  a 
valid  coordinate  for  the  sprite's  current  location.  At  each  clock  tick,  a  sprite  can 
move  in  one of four  directions,  or  it  can  remain  in  the  same  position 
(rest action). 
The  sprite ~plementation described  in  the  next  section  allows  a  sprite  to  move 
in 
one of eight  directions,  however,  four  directions  are  sufficient  detail  for  modeling 
pu~oses. 
In  addition  to  moving,  a  sprite  can  instigate  an act ion during  a  clock 
cycle. When a  sprite  moves  out of the  game  space,  it  indicates  that it has  termi- 
nated by perfo~ing 
the end action. In an  implementation,  a  sprite  would  then 
be 
arbage  collected.  In  the  model,  the  sprite  goes  back  to  the  state  in  which 
it can be 
created.  As  described in Chapter 9, we  use  cyclic  behavior  to  model  dynamic 
creation. "he set of actions  that  the SPRITE process  can  engage  in - 
excluding 
tick and  the  position  query pos - 
is  specified  by: 
Sprite = 
~ n o r t h 9 s o u t h , ~ e s t , e a s t , r e s t , a c t i o n , c r e a t e [ D ] [ D ~ ~  
h 
alien  is  a  sprite  that  moves  down  the  screen.  Consequently,  we  can  specify  its 
behavior  by  constraining  the  movement of the SPRITE process. In the  model,  an 
alien  starts  at  the top of the  screen  and  moves  vertically  down;  in  the  implementa- 
tion, it can  also  move  diagonally  down. 
N-CONSTRAINT = 
( c r e a t e [ ~ ] ~ O ]  
-> ~ O V E ) ,  
(south -> MOVE I end -> ALIEN-CONSTRAINT) 
+Sprite. 
MOVE = 
I /ALIEN = (SPRIT 
 CONSTRAINT). 

308 
~~~~E~ 22: Timed Systems 
The cons~aint permits  an  alien  to 
be created  at  any  osition 
at the  top of the 
screen  and  only  permits it to move south and  then e 
hen it leaves  the  screen. 
N composite  process  permits  only  these  actions  to  occur  since  the  con- 
straint  has  the S p r i t  e alphabet. 
The  behavior  of  the  missile  sprite 
is defined  in  exactly  the  same  way. h this  case, 
the  missile  is only permitted  to  move north, up  the  screen. 
The  spaceship  has  more  complex  behavi 
tally at  the  bottom  of  the  screen,  either 
position, r e s t  . It  is  created  in  the  center of the  screen  and  is  constrained  not  to 
move  off  the  screen.  The 
spaces hi^ can  perfo 
n, which  is  used  to 
create  a  missile,  as  explained  later.  In  fact,  the implementa~on ~ermits the  space- 
ship to move  up  and  down  the  screen  as  well.  However, ho~ontal  ~ovement 
is 
sufficient  detail  for  us  to  gain  an 
~ d e r s t a n d i n ~  
of  the o~era~ion 
of the  system 
from  the  model. 
Collision  detection  is  modeled 
by the C 
rocess  which,  after  a 
t ick, 
queries  the  positions  of 
two sprites  and 
c o l ~ s i o ~  
through  the  action 
explode if their  positions  coincide.  Unde 
ositions  are  excluded.  In  the 

12.4 Space ~ ~ v ~ ~ e r s  
309 
implementa~on, the  detection of a  collision  results  in  the  creation of an  explosion 
sprite  that  displays  a  series of images  to  create  the  appropriate  graphic  appear- 
ance. In the  model, we  omit  this  detail. 
[B].pos[p2:Coo 
& pZ!='undef) 
ode -> COLLIDE) 
The  composite  process S ~ A C E - I ~ V A D E ~ S  
models  a  game  that,  in  addition  to  the 
spaceship,  permits  only  a  single  alien  and 
a single  missile  to  appear  on  the  screen. 
This  simplification  is  required  for  a  model 
of manageable  size.  However, we have 
defined  sprites  as  having  cyclic  behavior  that  models  recreation.  Consequently, 
the  alien  can  reappear  in  different  start  positions  and  the  spaceship  can  launch 
another  missile as soon as the  previous  one  has  left  the  screen. 
The  model  captures 
all  possible  behaviors of the  combination of spaceship,  alien  and  missile. 
To  model  launching  a  missile,  we  have  associated  the  spaceship's 
act  ion 
with 
the  missile's create by relabeling.  Two  collision  detectors  are  included  to  detect 
spaceship-alien  and  alien-missile  collisions. 
L L ~ ~ E ( ' m i s s i l e , ' a l i e n ) )  
~e§hip.action/missile.cr~ate, 
tick/(alien,sp~ce§hip,missile}.tick} 
>>(.tick}. 
Safety  analysis 
of 
- ~ ~ V A D E ~ ~  
does  not  detect  a  time-stop  and  progress 
analysis  demonstrates  that  the TI ME progress  property  is  satisfied.  Further,  the 

310 
C ~ a ~ t e r  
22: Timed S ~ s t e ~ s  
are  satisfied, show in^ that  both  alien-missile and alien-spaceship  collisions  can 
occur. To gain an ~ d e r s t a n d i n ~  
of the  operation. of the  model,  we  can  animate  it 
to  produce  example  execution  traces. h 
alternative  approach  to  producing Sam- 
ple  traces  is to use  safety  properties as follows.  Suppose we wish  to  find  a  trace 
that  results in a  collision  between 
an alien and a  missile.  We  specify 
a  safety 
property  that  the  action missile.  alien.  explode 
should  not  occur and analyze 
the  system  with  respect  to  this  property: 
A L I € ~ - ~ I T  
= STOP + {missile.alien,~xplode~. 
i l ~ I ~ ~ - A L I E ~ - ~ I T  
= (SPACE-I~VADE~S 1 I A L I E ~ - ~ I T ) .  
The  trace  produced  is: 
Trace to property  violation in A L I € ~ - ~ I T :  
alien create. 1 .O 
spaceship.create.2.4 
tick 
alien.south 
sp~ceship.~est 
missile"pos.undef 
alien.  pos. 
l . l  
spaceship.pos.l.4 
tick 
alien.so~th 
spaceship.  action. 
1 .4 - 
~ ~ s s ~ Z e  
Z ~ ~ ~ c k e ~  
missile.pos.l.4 
alien. pos '1 .2 
spa~eship.pos~l.4 
tick 
alien.south 
missile. north 
missile.pos.l,3 
alien.  pos. 
1 .3 
missile.alien,explo~e 
Exactly the  same  approach  can  be  used 
to find  a  trace  leading 
to a  spaceship-alien 
collision. 
The emphasis of the  Space  Invaders  model  is  not so much  on demon st rat in^ 
that  it  satisfies  specific  safety 
and liveness  properties but rather as a  means of 
i n ~ e s t i g ~ ~ g   i n t e r a c ~ ~ n s  
and architecture.  After  all,  the  program  is  far  from  a 
safe~-critical ap~licatio~. 
However,  in  abstracting  from ~plementation details 
concerned  with  the  display 
and concentra~g 
on  interaction,  the  model  provides  a 
clear  explanation of how  the  program  should  operate. 
h addition,  it  provides 
some  indication of how  the ~plementation should be structured. For  example, 

22.4 Space ~ ~ v a ~ e ~ s  
311 
it  indicates  that  a  collision  detector  class  is  needed  and  confirms  that  a  sprite  clas
can be used to implement  the c o m o n  behavior  of  missiles,  aliens  and  the  space- 
ship. 
The ~plementation of the  Space  Invaders  program  is  large  in  comparison  to  the 
example  programs  presented  previously.  Consequently,  we  restrict  ourselves 
to 
describing  the  structure 
of the  program  using  class  diagrams.  The  translation  from 
timed  processes  to  timed  objects  should 
be clear  from  examples  presented 
in 
earlier  sections of this  chapter  The  reader  can  find  the  Java  code  for  each of the 
classes  we  mention on  the  accompanying  CD-ROM. 
The  display  for  the  Space  Invaders  program  is  handled 
by the two classes  depicted 
in  Figure 12.15. A Sprite is  created  with  an  initial  position  and an image.  The 
Spritecanvas maintains  a  list of sprites.  Every  clock  tick,  the 
S ~ r i t e ~ ~ n v a
calls  the pain 2: ( ) method  of  each  sprite  on  its  list.  The  sprite  then  draws  its  image
at  its  current  position. 
_
"
"
"
 
"
"
"
"
"
"
"
"
.
.
#
 
addsprite() 
remo~Sprite() 
Figure 12.15 Sprite and Spritecanvas classes. 
The move ( ) method  has  a  direction  parameter  that  specifies  one 
of eight 
directions  in which the sprite 
cm move. It is  called by a  subclass  each  clock 
cycle  to  change  the  position of the  sprite.  The c o l l i d  e ( ) method  tests  whether 
the sprite's bounding  rectangle  intersects  with  the  sprite  passed as a  parameter. 

312 
~ k a ~ t e r  
12: ~ i m e ~  
Systems 
The h  it 
( ) method  is  called  by  the  collision  detector  when  a  collision  is 
OSX ( ) and POSY ( ) return  the  current 
x and  y  coordinates 
of the 
sprite. 
The  collision  detector  maintains  a  list 
of the  alien  sprites  and  missile  sprites  and  a 
reference to the  spaceship  sprite as shown  in  Figure 12.16. Every  clock  cycle,  the 
detector  determines  whether  each  alien  has  collided  with  either  a  missile 
or the 
spaceship. If a  collision  is  detected,  the hit ( ) methods of the  sprites  involved in 
the  collision  are  invoked. 
L””””“””””- 
Figure 12.16 C o l l i s i o n ~ e t e ~ t o r  
class diagram. 
The  method  listed  below  is  the 
~plementation provided  for  the hit ( ) method 
in the Alien’ class. 
void hit() { 
xplosion(this); 
§ ~ a c e ~ f l v ~ ~ e r s . s c o ~ e . a l i e f l ~ i t ( ) ;  
§pace~nva~ers.detector.re~ove~li~n(this); 
r e ~ o v ~  
( ) ; // ~ e ~ o ~ e  
from S ~ r i t e C ~ ~ ~ ~ s  
1 
The  method  creates  a  new  explosion  sprite  at  the  same  location 
as the alien, 
records  an  alien  hit  on  the  scoreboard  and  removes  the  alien  from  the  collision 
detector 
 
and 
 
the 
 
display. 
The Colli~iofl~~t 
n, ~ i ~ s i ~ e  
and 
c e s h i 
p classes 
 
imp 
 
me. 
 
These 
 
classes 
correspond 
 
to 
 
the 
COLL 
~ o d e l  
processes. 

12.4 Space ~ ~ u a ~ e r s  
313 
The S pace I nvad e r s applet  class  creates  the  spaceship,  the  alien  generator,  the 
missile  launcher  and  the  score  board  in 
addition to  the  display,  time  manager 
and 
collision  detector  as  shown  in  Figure  12.17. 
W 
Applet 
"1 
l I 
l 
-1 
Figure 12.17 SpaceInvaders class diagram, 
The Alien~enerator waits  for a random  number of clock  cycles and  then 
creates a new  alien  with a randomly-chosen start position and a random  down- 
ward direction.  The issileLauncher creates a new  missile when the  space  bar 
is  pressed. The  x-coordinate of the  new  missile  is  the  current  position 
of the  space- 
ship. The  classes  included  in  Figure  12.17  provide  the 
~ a s t ~ c ~ r e  
for  scoring 
and the  creation  and  display of sprites. 
The  collision  detector 
and display m 
during the  pre-tick  clock  phase; 
the 
remaining  program  actions,  such  as 
sprite movement,  occur during the tick 
phase. This permits  the  display  to  render 
a consistent  set of positions and for 
the  effect of hits  to  be  computed during tick  processing.  However,  in  reality,  we 
could  implement  this sort of program  using  only a single-phase  clock. This is 
because  the  clock  ticks  rapidly and, since  the  screen  is updated every  cycle, any 
inconsistencies  which  resulted  from an action  happening  over two clock  cycles 
rather  than  one  would  not  be  visible  to 
a user. 

314 
~ h ~ p t e ~  
12: Timed 
 
Systems 
This chapter  has  presented  a  discrete  approach to modeling and implemen~g 
timed  systems.  The  passage of time  is  signaled  by  regular  successive  ticks of a 
clock. In models,  this  tick appears as an action  that  is  shared  by  the  processes  for 
which  behavior depends on  the  passage of time, h implementations,  the  tick  is 
an 
event  broadcast  by  a  time  manager. 
In  discrete  time  models,  we  saw  that  the  composition 
of processes  with  incon- 
sistent timing resulted in a  deadlock.  This  sort of deadlock  is  termed  a ti~e-st~p. 
The order  in  which  actions  can  occur  in  a  timed  model  is  restricted  by  making  a 
~~~~~~2 
pr~gress ass~ption. This ensures  that an action  occurs as soon as all 
participants  are  ready  to  perform it. Maximal  progress  is true for  a  model  when 
we make  the tick action  low  priority,  This  ensures  that  all  ready  actions  occur 
within  a clock  cycle.  Maximal progress thus reflects  the  implementation  assump- 
tion  that  actions  take  negligible  time  to  execute. 
We described an implementation  approach  for  timed  systems  that  is 
e v e ~ t - ~ ~ s
rather  than t ~ r e ~ ~ - ~ ~ s e ~ .  
h this  approach,  each  model  process  that 
has tick in  its 
alphabet  is  translated  into  a  timed  object. 
Timed  objects are invoked  regularly  by  a 
time  manager  that  dispatches  timing  events. 
We use  a  two-phase  scheme  that 
requires  a  pre-tick and tick event  dispatch.  Timed  objects  produce outputs during 
the  pre-tick  phase and compute  the  next state based  on  received inputs during the 
tick phase.  This  scheme  perrnits  one-way 
c o ~ u n i c a t i o n   i n t e r a c ~ o ~  
to occur 
atomically  within  a  single  clock  cycle.  It  was  pointed out that  multi-way  interac- 
tions  within  a  single clock  cycle are  not supported by  this  scheme.  However, this 
did not  cause  problems  in  the  example  programs,  The  advantage of using  timed 
objects rather than threads  to  implement  timed  processes  is  concerned  with run- 
time  efficiency.  Timed  objects  are  activated  by  method  invocation,  which  has  a 
lower  overhead than context  switching  threads.  Further,  since  the  pre-tick 
and tick 
methods run sequentially,  there  is  no  synchronization  overhead  to  ensure 
mutual 
exclusion.  Lastly,  for  programs  largely  concerned  with  display,  the  approach 
na~rally  synchron~es 
screen updates from  multiple  activities. 
We should  also  point 
out some of the  disadvantages 
of the  event-based 
approach or the reader  might  wonder why we have  devoted the main part of 
the  book  to  a  thread-based  approach.  Threads  abstract  from  the  detail 
of how 
activities  should  be  scheduled  to  organize 
interactio~. We saw  that  the  timed 
approach  was  limited  to  uni-directional  interactions  in  a  single 
clock  cycle. 
More  complex  interaction  needs  to  be  explicitly  scheduled  with  either  a  multi- 
phase clock.  or  alternatively,  over  multiple  clock  cycles.  This  rapidly  becomes 
manageable for  complex  interactions.  Further,  the  event-based  scheme  required
a  timed  object  to  examine  its  state  every  clock  cycle  to  determine  whether 
an event 
has occurred. A thread-based i~plementati~n 
may  incur  lower  overhead  for  sys- 

Exercises 
315 
tems  in  which  activities  do  not  perform  some  action  every  clock  cycle.  The  thread 
scheduler  dispatches  a  thread  only  when  there  is  some  work  for it to  do. 
Finally, we  note  that  the  model-based  approach 
to concurrent p r o g r a ~ i n g  
permits  a  designer  the  flexibility  to  use  either  an  event-based  or  thread-based 
irnplementation  scheme  or  indeed  a  hybrid.  We  use  the  same  modeling  and  ana- 
lysis  techniques  for  both ~plementation approaches. 
A comprehensive  treatment  of  using  discrete  time  in  the  context of CSP may be 
found  in  Roscoe’s  book  (1998).  We  have  adapted  the  approach  presented  there  to 
fit  with  the  modeling  tools  and  techniques  used  in  this  book.  However,  our 
approach  is  essentially  the  same  and  much  credit  is  due  to  Roscoe  for  providing 
the  first  generally  accessible  introduction  to  this  style  of  modeling  time. 
It  was  explicitly  stated  in  the  introduction  that  the  timed 
system we deal  with 
are  not  real-time in  the  sense of guaranteeing  deadlines.  The  interested  reader  will 
find  that  there is a  vast  literature on  the  specification,  verification  and  analysis of 
real-time  systems. A good  starting  point  is  a  book  edited 
by Mathai  Joseph  which 
presents  a  number of techniques  with  respect  to  the  same  case  study  (1996).  One 
of 
the  techniques  presented  is  Tirned CSP, which  uses  a  dense  continuous  model of 
time  in  contrast  to  the  discrete  model  we  present.  Continuous  time  is  more  expre
sive  but  leads  to  difficulties  in  automated  analysis. 
12.1 Define  a  process that models  a  timed  single-slot  buffer.  The  buffer  should  both  wait  to
accept input and wait  to  produce output. The  buffer  requires a minimum of T time 
units  to  transfer an item  from its input to  its output. 
12.2  Using  the  process  defined in  exercise  12.1,  define  a  two-slot  timed  buffer and explore 
its  properties.  Determine  the  tirning  consistency  relationship  between  the  delays  for 
the  two  buffers.  Explore  the  effect 
of applying  maximal  progress  by  making 
tick low 
priority. 
12.3  Implement  the  timed  buffer  process of exercise  12.1  as  a  timed  object and explore  the 
runthe behavior of a  system  composed of these  objects  with  producer and consuer 
timed  objects. (Note: Waiting  to  produce an  output is  implemented  in  timed system 
by ~ u l ~ i ~ g  
rather than throwing  a  time-stop. By balking,  we  mean that the  method 
performing  the output returns  a  boolean  indicating  whether  or  not  the output  was 
possible. If it  fails,  it is retried  on  the  next clock  cycle.) 
12.4 An electric  window  in  a  car  is  controlled  by 
two press-button  switches: up and down. 
M e n  the up  button is  pressed,  then  the  window starts closing. If the up  button is 

316 
C
~
~
~
e
r
 
12: Timed Systems 
12.5 
pressed  for  less  than 
T seconds  then  the  window  closes  completely. 
If the up  button is 
pressed  for  more  than T seconds  then  when  the button is  released,  the  window  stops 
closing.  The down button works in exactly  the  same  way,  except that the  window 
opens  rather  than  closes. A mechanical  interlock  prevents  both  buttons  being  pressed 
at the  same  time. 
The window  is  moved  by  a  motor 
that responds  to  the c o ~ a n d s  
start-close, 
stop-close,  start-open and stop-open. Two  sensor  switches, 
closed and opened, 
detect,  respectively,  when  the  window  is  fully  closed and when  it  is Mly open. "he 
window  takes X units of h e  to  move  from  the  completely  open  position  to  the 
completely  closed  position  or  vice  versa. 
Define a  timed  model  for  the  electric  window  system  in 
FSP. Specify  safety  proper- 
ties  that  assert that the  motor  is  not  active  when  the  window  is Mly closed  or  fully 
opened. 
Translate  the  model of the  electric  window  system  into  a  Java ~plementation using 
timed  objects. 

A process is defined by one  or  more  local  processes  separated by commas. The 
defi~tion is terminated by a  full  stop. STOP and ERROR are prhitive local  pro- 
cesses. 
Process = (a -3 Local), 
Local 
(b -> STOP). 
~ 
Action  Prefix - > 
Choice I 
Guarded  Action 
Alphabet 
Extension + 
If X is an action  and P a  process  then ( X - 
>P ) describes  a 
process  that  initially  engages in the  action X and  then  behaves 
exactly  as  described by P. 
If X and y are actions  then ( 
X - 
>P i y - 
>Q ) describes  a  process 
which  initially  engages in either of the  actions X or y . After  the 
first  action  has  occurred,  the  subsequent  behavior 
is described 
by P if the  first  action  was X and Q if  the  first  action  was y . 
II B X -> P 
y -> Q) means  that  when  the 
guard B is true  then  the  actions X and y are both  eligible  to be 
chosen,  otherwise  if B is false  then  the  action X cannot be 
chosen. 
The  alphabet of a  process is the  set of actions in which  it cm 
engage. P + S extends  the  alphabet of the  process P with  the 
actions in the  set S. 
Table A.l - 
Process  operators 

318 
A ~ ~ e ~ ~ i x  
A: FSP Quick ~ e ~ e ~ e ~ c
A. composite  process  is  the  parallel 
composi~o~ 
of one  or  more  processes.  The 
definition of a  composite  process  is  preceded by I l . 
1 1 C o ~ ~ o s i t ~  
= (P I I Q). 
Parallel 
composition I 
Replicator 
Process 
Labeling : 
Process 
Sharing : 
: 
Priority  High g*(: 
Priority Low >> 
If P and Q are processes  then ( P I I Q) represents  the  concurrent 
execution of P and Q. 
[ i : 
1 m . 
N 1 P ( i ) is  the  parallel  composition 
(P(?) l I ..* I I P(N) ) 
a : 
P prefixes  each  label in the  alphabet of P with a. 
{ 
al , . . , 
a,} 
: 
: 
P replaces  every  label n in  the  alphabet of P 
with  the  labels al n , 
... , 
a,. n . Further,  every  transition 
( n - >Q) in the  definition of P is  replaced  with  the  transitions 
({al. n ,..., a,. n} ->Q). 
1 I C =(P 1 I Q) <x{ at, ..., a,)specifies  a  composition  in  which 
the  actions al, ..., an have  higher  priority  than my other  action in 
the  alphabet of P I I Q including  the  silent  action tau , In any 
choice  in  this  system  which  has  one  or  more 
of the  actions 
al , 
... , 
a, labeling  a  transition,  the  transitions  labeled  with 
lower  priority  actions are discarded. 
I I C = ( P I 1 Q) >> { 
al .,., a,) 
specifies  a  composition in which  the 
actions a 1 ,..., a, have  lower  priority than any  other  action  in  the 
alphabet of P I I Q including  the  silent  action tau . 
In  any  choice 
in  this  system  which 
has one  or  more  transitions  not  labeled  by 
al ,..., a,, the  transitions  labeled  by 
,..., a, are discarded. 
Table A.2 - 
Composite Process Operators 

A.4 ~ r o ~ e r ~ i e s  
319 
The  operators in Table A.3 may be used in the  definition of both  processes  and 
composite  processes. 
Conditional 
Relabeling / 
Hiding \ 
Interface 8 
Q behaves as the  proc 
it  behaves as Q. If the 
is omitted  and B is false,  then  the  process  behaves as STOP. 
Relabeling is applied to a  process  to  change  the  names of action 
labels.  The  general fom of relabeling  is: /{newlabeZ-l/ 
oldlabel-l, ... ne~la~el-n/ol~Zabel-n}. 
When  applied  to  a  process P, the  hiding  operator \ ( 
ai . 
. 
a, 3 
removes  the  action  names al . . 
a, from  the  alphabet of P and 
makes  these  concealed  actions "silent".  These silent  actions are 
labeled t a U. Silent  actions  in  different  processes  are  not  shared. 
When  applied  to  a  process P, the  interface  operator @( al . a, 
hides all actions  in  the  alphabet of P not  labeled in the  set 
al .a,. 
Table 8.3 - 
Common  Process  Operators 
e r t y  P defines  a  deterministic  process  that 
trace  including  actions  in  the  alphabet of P, is 
accepted by P. 
P = ( 
a 1 , 
a2 an 3 defines  a  progress  property P 
least  one of the  actions ai , 
a2. . 
an will be executed  infinitely 
often. 
sserts  that  in an infinite  execution of a  target  system, at 
Table A.4 - 
Safety  and  Progress  Properties 

This Page Intentionally Left Blank

FSP stands for  Einite  State  grocesses.  This  appendix  contains  a 
~omprehensive 
specification of the  syntax of FSP  together  with  a  commentary  on  features  such 
as  variable  scope  that  are  not  treated  explicitly  in  the  body  of  the  book.  A  formal 
description  of  the  semantics  of  the 
FSP process  operators  may 
be found in 
Appendix C. 
In  specifying  the  syntax 
of FSP, we  have  followed  the  approach  used  in  the  Java 
Language ~pecification. In particular,  the  syntax is specified  using  a  context-free 
g r a ~ a r  
that  consists of a  number of productions.  Each  production  is  defined 
by 
a n o n - t e ~ ~ a l  
symbol  as  its  left-hand  side  and  a  sequence  of  one  or  more  termina
and  non-terminal  symbols  as  its  right-hand  side.  In  the  following, 
n o n - t e ~ ~ a l  
symbols  are  shown  in  italic  type  and 
ternhal symbols  in  a  fixed  width  bolded 
type.  The  definition of a  non-terminal is introduced by its  name  followed by a 
colon.  One or more  alternative  right-hand  sides for  the  non-terminal  then  follow 
on  succeeding  lines. For example,  the  following  production  specifies  the  syntax  for 
an FSP constant d e ~ t i o n .  
The  production  below  specifies  an a r g ~ e n t  
list  as  consisting  of  either  a  single 
expression  or  a  list of expressions  separated by comas: 
A r ~ ~ ~ ~ n t s :  
Expression 
A r g ~ ~ ~ n t s  
Expres~ion 
The  subscripted  suffix "opt", which  may  appear  after  a ternhal or  non-terminal, 
indicates  an  optional  symbol. 

322 
Appen~ix B: FSP ~ a n g ~ a g e  
 
S ~ e c ~ c a ~ i 5 ~  
In addition  to  definitions  for  processes  and  compositions 
of processes,  an FSP 
model  description  consists of definitions  for  constants,  ranges  of  integers,  sets of 
action  labels,  safety  properties,  progress  properties  and a~mation 
menus. 
FSPdescription: 
~SPde~nition 
~SPdescription  ~SPde~nition 
ConstantDef 
RangeDef 
SetDef 
 process^^ 
C o ~ p o s i t e D ~  
P r o ~ e r t y D ~  
~ r o g r e s s ~ ~  
Menu~ef 
FSPde~nition: 
FSP d~fini~ons 
and  process  parameters  are  named by identifiers  beginning  with 
an  uppercase  letter.  Action  label  and  variable  identifiers  begin  with  a  lower  case 
letter. 
Upper  and  lower  case 
i~entifiers are  specified by the fo~owing productions in 
which ~ p p ~ r c a s e ~ e t t e r  
denotes  one of the  upper  case alphabe~cal characters  and 
Lo~er~useLetter 
denotes  one  of  the  lower  case  alphabetical  characters  or 
mder- 
score ”-”. 
Digit denotes  one  of  the  decimal  digits. 

B.3 Action Labels 
323 
~ p p e r c a s e ~ d e n t ~ e r :  
~pperCaseLetter 
~ p p e r c a s e ~ d e n t ~ e r  
Letter 
~ p p e r c a s e ~ d e n t ~ e r  
Digit 
Lo~erC~seLetter 
LowerCase~~ent~er 
Letter 
LowerCase~dent~er 
Digit 
~pperCaseLetter 
LowerC~seLetter 
LowerCase~dent~er: 
Letter: 
Actions  in FSP can  be  labeled  either  by  a  lower  case  identifier  or  by  a  value 
computed  from an expression  enclosed  by 
square brackets.  Action  labels  are 
also  formed  by  concatenating  simpler  labels  with  a 
dot. 
ActionLa~el; 
LowerCase~dent~er 
ActionLa~el 
 
LowerCase~dent~er 
[ 
~ ~ p r e s s i ~ n  
ActionLa~eZ [ 
 p press ion ] 
in 
[43] in1121 
in[2][i*2] 
 
x[l].y[3] 
Wherever  a  single  action  label  can  be  used 
in FSP, a  set of action  labels  can  also  be 
used. The  exception  is  where  label  values are used  in  expressions  (see B.10). 
ActionLabels; 
ActionLabe1 
Set 
ActionLabels 
I Action~abel 
ActionLabels . 
Set 
ActionL~bels [ Action~ange ] 
Action~ange 

Sets of action  labels are defined  explicitly  by  a  set or by  a range of integer values. 
ActionRange; 
Range 
Set 
Variable : 
Range 
Variab~e : 
Set 
Runge~~ent 
Expression . 
. 
Expression 
S e t ~ ~ e n ~  
{ SetEZe~ents 1 
Action~a~e~s 
SetEZe~e~ts 
 
Action~abels 
Range: 
Set: 
Se~Ele~ents: 
{a,b,c) X.a in[x:1..3] 
in[x:t] a.{x,y,z) 
Variables  can  be  associated with a set or  a range in an A c ~ ~ o n ~ ~ n g e .  
The  variable 
successively takes on  each of the values of the set or range. The  scope of variables 
is  discussed in the following with respect to their  use in processes,  composite 
processes  and  relabeling  definitions. 
a[i:1..3] x[v: (a,b,c)] 
Named  constants,  ranges and sets are defined as follows: 

B.5 Process ~ e ~ ~ i t i o ~  
325 
A process  is  defined by one  or  more  local  processes. A process  can  optionally be 
parameterized  and  have  relabeling,  hiding  and  alphabet  extension  parts. 
P r o c e s s ~ e ~  
P r o c e s s ~ ~ e ~ t  
P a r a ~ o ~ ~  
= Process~o~y 
A l ~ ~ a ~ e t E x t e n s i o ~ o ~ t   ~ e l a ~ e l o ~ t  
~
i
~
i
~
g
~
~
~ r o c e s s ~ o ~ ~ ;  
Local  Process 
LocalProcess 
LocalProcess~e~s 
LocalProcess~~ 
LocalProcess~e~s,  LocalProcess~e~ 
LocalProcess~e~ 
~ r o c e s s ~ ~ e n t   ~ ~ ~ e x ~ a ~ g e s o ~ ~  
= LocalProcess 
A l ~ ~ a ~ e t E x t e ~ s i o ~ :  
+ Set 
LocalProcess~e~s; 
The scope of the  name  for  a  local  process  definition  is  the  process  in  which 
it is 
contained. A local  process  is STOP, ERROR, a  reference  to  another  local  process,  a 
conditional  process  or  is  defined  using  action  prefix  and  choice. 
LocalProcess: 
' 
f ~x~ression 
t h en LocaZProcess 
f Ex~ressio~ 
t h en LocalProcess 
( Choice ) 
Ac~ionPre~x 
Choice l Actio~Pre~x 
~ ~ a r ~ o ~ t  
Pre~xActio~s - LocalProcess 
Choice: 
Ac~ionPre~x: 

326 
Appen~ix B: FSP ~ang~age 
 
Spec~cation 
~re~xActions: 
Actions~u~els 
~ r e ~ x A c t i ~ ~ s  
- 
> Actions~a~els 
Guard: 
TIME = (tick -> TIME) 
m 
S=STOP+ {a,b,c}. 
R = (a -2 R 
b - > Q ) ,  
Q = STOP. 
P = (a[i:I.  .3] 
-> 
i==l  then  STOP  else 
P ) ,  
The  scope of a  variable  defined  in  an  action  label  is  the  rest 
of the  local  process in 
which it is  defined,  However,  the  scope 
of a  variable  defined  inside  a  set  does  not 
extend  beyond  that set, e.g. {a, b , 
c [ 
i : 
0 .  .2] } 
. 
Note  that  variables  are  a  syntactic 
convenience  to  permit  concise  definitions.  The  example  process 
P above c m  be 
expanded  to  an  equivalent  definition  without  variables  and  conditionals: 
P = (a[l] -> STOP I a[2] -> P I a[3] -> P). 
In a  similar  way,  processes  with  guards  can  be  expressed by explicitly  enumerat- 
ing the  choices  that  an  action  label  set  represents.  For  example,  the  process: 
P = (a[i:0..3] -> 
( when  i==O x -> STOP 
I when i!=O y -> P 
) 
1- 
is  equivalent  to: 
Index  ranges  for  local  processes  are  also  a  syntactic  convenience.  They  define  a  se
of local  processes. 

B.6 Co~~osite 
Process 
P 
i<3 a -3 S [ i + i ] ) ,  
sc31 
= STOP. 
The  scope of a  variable  used in a  local  process  definition  is  the  local  process, 
i.e. it 
extends  to  the  comma  that  terminates  the  definition.  The  example  above  could 
be 
defined  without  a  variable  as: 
P 
= S [ O ] ,  
S [ O ]  = (a -> S [ i ] ) ,  
S[l] = (a -3 S[2]), 
S[2] = (a -> S [ 3 ] ) ,  
S[3] = STOP. 
'The reference to a local process can be replaced 
by s u b s t i ~ ~ g  
its d e ~ t i o ~
giving: 
P = (a -> (a -3 (a -> STOP))). 
This  is  exactly  equivalent  to: 
P = (a -> a -> a -> STOP). 
Variables in FSP defi~tions can  always be removed by syntactic transfo~ation. 
Consequently,  in  Appendix G, which  presents  the  semantics of FSP, variables  are 
not  considered. 
A  composite  process  is 
d i s ~ ~ i s ~ e d  
from a  primitive  process by prefixing its 
definition  with l 
l . Composite  processes  are  constructed  using  parallel  composi- 
tion,  relabeling,  priority  and  hiding.  Process  labeling  and  sharing  are  specialized 

328 
A p p e ~ ~ i x  
B: FSP  age Spec~catio~ 
forrns of relabeling.  The  replication  and  conditional  constructs  are  purely  syntactic 
conveniences. 
C o ~ p o s i t e ~ e ~  
l I Process~dent P a r ~ m ~ ~ t  
= C o ~ ~ o s i t e ~ o ~ ~  
Co~posite~ody: 
Priority*~t ~ i ~ i n g ~ ~ t  
m 
P r o c e s s ~ e ~   A r g ~ m e n t s ~ ~ ~   ~ e l a ~ e l * ~ ~  
( Par~llelCom~ositio~ 
~ e l a ~ e l ~ ~ ~  
--condi~onal 
P~ocessRe~ 
Proc~ss~dent 
A c t i o n ~ ~ ~ e l s  
: 
P r o c e s s ~ ~ ~ t  
--process 
 
labeling 
A c t i o n ~ ~ ~ e l s  
: 
: 
Process~~e~t 
--process 
 
sharing 
C o ~ p o s i t e ~ o ~ y  
Paralle~Com~ositio~ 
i I Co~posite~ody 
~xpressio~ 
Arg~ments 
11 Ex~ressio~ 
3% Set 
<< Set 
Para~lelComposition: 
A r g ~ ~ e n t s :  
Priority 
The  composite  process  definitions  above  are  exactly  equivalent  and  define  the 
same  composite  process. 
"he syntax  for re label in^ is  described in section B.8. 
The  scope of a  variable in a  composite  process  is  the 
~ o m p o s i t e ~ o ~ ~  
in which 
it is defined  together  with 
any other ~ o m p o s i t e ~ ~ d y  
contained  within  that 
Composite~o~y 
definition. 

The d e ~ t i o n s  
of the two occurrences of the  variable j do not  conflict in the  above 
example  since  they 
are each  defined 
in a  different 
C
~
~
~
~
s
~
~
Neither 
C
~
~
~
~
s
~
~
e
S
~
~
y
 
is  contained  within  the  other. The  replication  can  be  unfolded  to 
give  the  equivalent  definition  for S shown below. 
Process and composite  process  parameters  must  always  have  a  default  value.  Th
means that a  process  can  always  be  compiled  into  a  finite  Labeled  Transition 
System (LTS). The default  parameter  value  may  be  changed  by 
an argument 
when  the  process,  whether  composite  or  primitive,  forms 
part of another  compo- 
site  process. 
 para^: 
Paru~eter 
 para^ 
Para~eter 
~ f f r a ~ e t e r ~ ~ e ~ t  
= ~ ~ ~ r e s s i o ~  
Para~e~er: 
= (a[X] - 2  STOP). 
= (P(Y+1) 
1 1  P(Y+ 
The  scope of a  parameter  is  the  process  or  composite 
in which it is  defined. 
Parameter substit~tion creates  a  new  process  with  each  occurrence of the para- 
meter  replaced  by  the a r ~ ~ m e n t  
value.  This  is  simply  macro  expansion. 
Substitu~ng the  parameters in the  example  results in the  following  equivalent 
definition. 

The  relabeling  and  hiding  operators  can  be  applied  to  both  processes  and  compo- 
site  processes. 
ESP supports  relational re label in^. The  relabeling  operator  applies  a  relation  to  a 
process,  which  can  result  in  replacing  many  labels  with  a  single  label  and  repla- 
cing  one  label  with  multiple  labels.  The r e l a ~ e ~ g  
relation  is  defined by a  set of 
pairs.  Each  pair  takes  the  form n e ~ l a b e l / o l ~ l a b e l .  
Sets of labels  and  the  repli- 
cation  construct  perrnit  the  concise  definition of the  relabeling  relation. In each of 
the  examples  below,  both  the  concise  form  and  the  equivalent  expanded  forrn of 
the  relation  are  given. 
/* one t o  one relabeling * I  
I* equivalent */ 
P/( a [ l I / x [ 1 1  
I a[21/xWI  a[31/x[31 
1 
[ i : 1 . . 3 ]   { a [ i ] / x [ i ] )  
/* one t o  many r e l ~ b e l i n g  */ 
P/{ { x , y , W a  3 
I* equivalent */ 
P/{ xla,  yla,  z/a 
1 
I* many t o  one ~ e l a b e l i n g  */ 
P/{ a H x , y , z 3  ) 
I* e q ~ i v a l e n t  */ 
P/{ a l x ,   a l y ,   a l z  
3 
/* many t o  many r e l a ~ e l i ~ g  
*/ 
P/{ { a , b 3 U x , y 1  3 
I* equivalent */ 
P/{ a h ,  a/y,  blx,  bly 
3 

B.9 property, progress and 0 en^ 
331 
If the  old  label  does  not  appear  in  the  alphabet 
of P, then  the  relabeling  pair 
~ e ~ l a b e l / o l ~ l a b e l  
has  no  effect.  Relabeling  in 
FSP is always  applied  before 
parallel  composition  such  that  for  a  relabeling  relation R, ( P I I Q) /R is  equivalent 
to ( P m /  
lam). 
~ i ~ i ~ g :  
\ Set 
Set 
There  are two forms of the  hiding  operator: \ applies  a  set of labels  to  a  process 
such  that  the  labels  that  occur  in  both  the  alphabet of the  process  and  the  set  are 
hidden, @ applies  a  set of labels  to  a  process  such  that  every  label  in  the  alphabet 
hidden  except  those  that  occur  in  the  set. 
Action  labels  in  hiding  sets,  priority  sets  and  on  the  right-hand  side 
of a  relabeling 
pair  match  prefixes 
of labels in  the  alphabet 
of the  process  to which  they  are 
applied.  For  example,  an  action  label 
a in  a  hiding  set  will  hide  all  labels  prefixed 
by a, e.g. a b, a [ 
1 3, a x . 
y . 
Similarly,  the  relabeling  pair 
x / a would  replace  these 
labels  with x m b, x [ 
1 1, x . 
x. y . Prefix  matching  perrnits  label  details  to be ignored 
when  processes  are  composed. 
A  safety  property  is  defined by a  process  prefixed by the  keyword 
There  are two forms of progress  property,  though we have  used only the  simpler 
form  in  the  main  text 
of this  book.  The  first 
form asserts  that at least  one  action  in  a 
set S must  occur  infinitely  often.  The  second  form is conditional  progress,  which 
S. This  asserts  that if one of the  actions  in  the  set 
C occurs 
infinitely  often  then so must  one  of  the  actions  in  the  set S. 
A  set of progress  properties  may be declared  using an  index  range. 

332 
Appenai~ B: FSP ~ a ~ g ~ a g e  
Spec~cation 
G[i:1..3] = ((a,b)[i]) 
A menu  definition  specifies  the  set 
of actions  that  the  user  can  control  in  an 
animation. 
Expressions in FSP are  a  subset  of expressio~ 
in Java.  This  has  the  advantage of 
familiarity,  however it has  the  disadvantage  that  some of the FSP process  opera- 
tors  have  a  different  meaning  when  used 
in the  context  of  an  expression. 
In 
particular,  the  priority  operators <C and >> mean  shift  left  and  shift  right  when 
used  in  an  expression,  the  parallel  composition  operator 
I I means  logical  or  when 
used  in  an  expression,  the  choice  operator 
I means  bit-wise  or  in  an  expression 
and  the  relabel  operator / means  division.  Where 
c o ~ s i o n  
~~~t  arise,  namely  in 
constant  and  range  definitions,  expressions  with  the  logical  and  shift  operators 
must  be bracketed, This is the  reason  why  constant  and  range 
d e ~ n i t i o ~  
are 
defined  using Si~pleExpression rather  than Express~o~. 
The  syntax of expressions 
used in FSP is specified by the  following expressio~s. 

PS23 s u ~ ~ o r t s  
only  integer  and  label  expressions.  Variables  may  take  either  an 
integer  value  or a label  value.  Label  literals  are  formed by precedin 
label  with a quote - 
this  distinguishes a label  value  from  a  variable. 
The only  valid 

operators  on  label  values  are 
equali~ and ine~uality. As in the programing 
language G, the  results of boolean  expressions in FSP are  integer  values. A false 
expression  has  the  value 0 and  a  true  expression  the  value 1. 
h the  previous  sections,  we  have  indicated  that  constructs  such as guards,  repli- 
cators,  conditionals,  variables  and  index  ranges  are  syntactic 
conve~ences to 
permit  concise  descriptions. ~ o d e l s  
described  using  these  constructs  can be syn- 
tactically  transformed  into  a  more  basic  form of FSP. This  basic  form of FSP uses 
only  the  process  operators  and  the 
prhitive local  processes STOP and E
~
~
O
~
.
The 
syntax of basic FSP is  described by the  following  productions: 
A formal  semantics  for  basic FSP is  presented in Appendix G. 

The semantics of basic FSP are  defined  in  terms of Labeled  Transition  Systems 
(LTS). In  the  body of the  book, we have  depicted  the LTS that corresponds  to an 
FSP process as a graph. h the  following, we formally  define what an LTS is then 
describe  the  correspondence  between 
FSP process  expressions and LTSs. This 
correspondence  is  defined  by  the  function: 
where €xp is  the  set of FSP process  expressions and p the  set of  LTSs.  The function 
Its is  defined  inductively  on  the structure of FSP process  expressions. 
Let States be  the  universal  set 
of states including n a  designated error state, L be  the 
universal  set of labels, and Act = L U {z}, where z is  used  to  denote an internal 
action that cannot  be  observed  by  the  environment of an LTS. 
A finite LTS P is  a quadruple 
S, A, A, q > 
where: 
S c: Stat~s is a  finite  set of states. 
A = aP U {z}, where aP c: L denotes  the a ~ p ~ a b ~ t  
of P. 
A S - 
{x} x A x S, denotes  a  transition  relation that maps from  a state and an 
action onto another state. 
q E S indicates  the  initial state of P. 
The only LTS that  is  allowed  to  have  the  error 
state n as its  initial state is 
{E}, 
Act, {}, n>, named II. The alphabet of this  process an = L. 
h 
LTS P =K S, A, A, q > 
t r ~ ~ s i t s  
with  action a E A into an LTS P ', denoted as 
P 4  
P', if 

336 
A ~ p e ~ ~ i x  
C: FSP S ~ a ~ ~ i c
P‘ =< S, A, A, q’ >/ where 4’ #n and (4, a, 4‘) E A, or 
P’ = 27, and (4, a, E-) E A. 
We use P 4 
to  mean  that 3P’ such that P 4 
P’, and P 
to  mean  that j3 P’ such 
that P -% P’. 
h the  following, E ranges  over FSP process  expressions/ Q ranges  over  process 
iden~fiers, and A, B range  over  sets of observable  actions  (i.e. A c: L and B 5 L). 
Q = E means  that ~ts(q) 
=&f 
lts(E). 
=< 
{ S } ,  {z}, { } , S  > 
If Zts(E) =< S, A, A, q > 
and E is not 
=-C 
S U {p}, A U {a}, A U {(p, 
a, q)}, p 
where p$S. 
=-C 
{p, R } ,  {a}, {(p, a, x)}, p 
>I where p # x. 
If k(E) =< S, A, A, 4 B, 
then lts(E + B) =< S, A U B, A, q > 
. 
We represent  the FSP process  defined  by  the  recursive 
e~uation X = E as 
rec(X = E), where X is a  variable  in E, 
For example,  the p~ocess defined 
by  the  recursive  definition X = 
(a - 
> X) is repr~se~ted 
as rec(X = 
(a - 
> 
X)). We use E[X .c- rec(X = E)] to denote  the FSP ex~re§§ion that is 
obtained  by  substitutin 
rec(X = E) for X in E. Then  lts(rec(X = E)) is 
the  smallest LTS that  satisfies  the  followin 

C.3 Cu~pusife 
Processes 
337 
Ets(E[X .c" rec(X = E)]) a, 
P 
lts(rec(X = E)) "%- P 
Intuitively,  any  action  inferred by the  expression E unwound  once  can 
also be inferred by the  process  represented by the  recursive  definition. 
~utually recursive  equations  can 
be reduced  to  the  simple  form 
described  above.  For  local  processes, all occurrences of process  variables 
are  guarded by an action  prefix  and  consequently,  recursive  definitions 
are  guaranteed  to  have  a  fixed-point  solution. 
Before  defining  the  meaning of composition  in FSP and of the  priority  operators 
on  composite  processes,  we  must  first  describe  the m e a ~ g  
of  composition  and 
priority in  the  underlying  LT§  model. 
The  parallel  composition PI/ Q of two LTSs P and Q is  defined  as  follows: 
If P = rI or Q = rI, then PIIQ = n. 
For P =-c 
SI,  AI, Ax, q1 > 
and Q =< S2, AIL, A2, q2 >, 
such  that P + r]: and Q # 11, 
where A is  the  smallest  relation  satisfying  the  rules: 
PllQ =-c 
S1 x s2, A1 U A21 A, 
(41, q2) >, 
Let a E Act in 
Parallel  composition  is  both  commutative  and  associative. 
~onsequently, the 
order  in  which LT% are  composed  is  not  significant. 
The  set of actions B c: Act are k ~ ~ k  
priority  in  the LT§ P << B, 
whereP=-cS,A,A',q>. 

P << B =K S, A, 
A, q > 
where A is  the  smallest  relation  satisfying  the  rule: 
Let a, b, E Act in 
Pa, P’ 
P<<B+P’<<B 
if ((a E B) or (Vb E B, P 
The  set 
of actions B C. Act are low priority  in  the 
LTS P >> B, where 
P =< S,A, A’, 
q >. 
P >> B =K S, A, 
A, q > 
where A is  the  smallest  relation  satisfying  the  rule: 
Let a, b E Act in 
Using  the  definitions  for LTS composition and priority,  we  can  now  simply  define 
the  meaning of composition and priority  in FSP. In  the  following, C€ refers  to FSP 
composition  expressions of the  form (Q1 I I . . 
. I IQn) 
and Q refers  to  the  identifier of 
a  process  or  composite  process. 
Z ~ S ( C ~ C C B )  
= Zts(C€) << B 
To define  the FSP relabeling,  hiding and interface  operators,  which  can  be  applied 
to  processes and composite  processes,  we  first  describe  the  meaning of relabeling 
and hiding in the  underlying LTS model. 

C.4 C
o
~
~
o
~
 
Operutors 
339 
Relabeling  applies  a  relation  over  action  labels 
R 5 L, x L,, to an LTS 
P =< S,A,  A, q > 
such  that: 
The  set of actions B c: Act are ~
i
~
~
e
~
 
in the LT5 P\ B, where P =K S, A, h ‘q >. 
If P = 
ll then P\B = 
ll otherwise 
P\B = < 
(A - 
B) U {z}, A, q > 
where A is  the  smallest  relation  satisfying  the  rule: 
let a E Act in 
Pa, P’ 
Pa. P’ 
a E B  
P\B+  P’\B 
P\B+  P’\B 
ing \: 
h%(€ \ B) = .&(€)\B. 
I n t e ~ ~ ~ c e  
63: 
Zts(€631) = Its(€)\B where B = a(Zts(E)) - 
1. 

A safety  property Q in FSP  is  represented by an i ~ a g e  
of the  LTS of the  process 
expression  that  defines  the  property.  The  image  LTS  has  each  state 
of the  original 
LT§  and  has  a  transition  from  each  state  for  every  action  in  the  alphabet 
of the 
original.  Transitions  added  to  the  image  LTS  are  to  the  error-state. 
Q = € :  
Zts(Q) ==&f ~~age(Zts(€)), 
for  an  LTS P =< S,A, A, 
p >, i ~ ~ g e ( P )  
=< S U {E}, A, A f ,  q P, 
where 11’ == A U {(S, a, n)/s E S, a E A, and $l 
S’ E S : 
(S, a, S ’ )  E A}. 
~ i n i ~ a t i o n  
of the LTS corresponding  to  an FSP process  definition  results  in  a 
semantically  equivalent  LTS.  The  equivalence  relations  used  in  performing 
mini- 
&ation  are  defined  in  the  following  sections. 
Strong  semantic  equivalence  equates  LTSs  that  have  identical  behavior  when  the 
occurrence of all  their  actions  can be observed,  including  that of the  silent  action z, 
Let ,p be the  universal  set of LTSs.  Strong  semantic  equivalence 
” M ”  is  the  union 
c: ,p x p satisfying  that (P, Q) E 
1. CXP = CXQ; 
2. Va E Act : 
P A P ‘  implies 3Q‘, Q& 
QAQ’ 
implies 3~’, 
P ~ P ’  
3. P = 
l.7 iff Q = 
l.7, 
The LTSA tool  performs ~ n ~ z a t i o n  
using  strong  equivalence if an LTS contains 
no  silent  actions (z). For an LTS P, without  z-actions: 

Weak  semantic  equivalence  equates  systems  that  exhibit  to  the  same  behavior  to 
an external  observer  who  cannot  detect  the  occurrence of z-actions. 
Let P 
P’ denote P q P ’ ,  where z* means  a  sequence of zero  or  more zs. Then 
~ e G ! ~  
(or ~ ~ s e ~ ~ G ! ~ i ~ ~ G ! Z )  
semantic  equivalence 
”
d
r
 is  the  union 
of all  relations 
c: p x p satisfying  that {P, Q) E 
1. RP= RQ; 
2. VG! E I, U {E}, where I, = Act - 
{z}, and E is the  empty  sequence: 
P % P’ implies 3Q’, Q 3 Q’ and (P’, Q‘) E 
Q =$ Q‘ implies 3P’, P % P’ and (P’, Q’) E 
3. P = l7 iff Q = l7. 
The LTSA tool  performs ~ m i z a t i o n  
using  weak  equivalence if an LTS contains 
silent  actions (z). For  an LTS P, with  z-actions: 
Both  strong  and  weak  equivalence  are  congruences  with  respect  to  the  composi- 
tion,  relabeling,  and  hiding  operators.  This  means  that  strongly  or  weakly  equiva- 
lent  components  may  substitute  one  another  in  any  system  constructed  with  these
operators,  without  affecting  the  behavior of the  system  with  respect  to  strong  or 
weak  equivalence,  respectively. 

This Page Intentionally Left Blank

This  appendix  presents  the  subset of UML class  diagrams  used in the  book. .We 
have  used 
UML to describe ~ p l e ~ e n t a t i o ~  
rather  than  high-level  design. 
~enerali~ation 
is  consistently  used  to  mean  inheritance 
in Java  and  association 
with  navigability to mean  that  the  source  class  holds  a  reference 
to an  object of the 
target  class. 

344 
~ ~ ~ e n d i x  
D: UML Class D ~ g r a ~ s  
I 
I 
l 
""M 
exactly one 

Andrews,  G.R. (1991). Concuyyent  Progyamming:  Pyinciples  and  Practice. Redwood City, CA: 
Baker, R.M. (1971). PORTS:  a ~etkod 
for dynamic i n t e ~ y o ~ a m  
comm~nication and job control. 
Ben-Ari, M. (1990). Pyincip~es  of Conc~yyent and ~istribu~ed  P~ogya~ming. 
Prentice-Hall 
Birtwistle, G.M., Dahl, 0, Myhrhaug,  B.  and  Nygaard, K. (1973). S
~
~
U
~
A
 
BEGIN. New 
Booch, G. (1986). Object-o~iented develop~ent. IEEE  Transactions  on  Software  Engineering 
Booch, G.,  Ruxnbaugh, J. and  Jacobson, I. (1998). ~ n ~ e d   ~ o d e ~ i ~ g  
~anguage User  Guide. 
Brinch-Hansen, P. (1970). The  nucleus  of  a m~ltipyogyam~ing 
system. C o ~ ~ c a t i o ~  
of the 
Brinch-Hansen, P. (1972). Sty~ct~yed  ~~ltipyogya~~ing. 
C o ~ ~ c a t i o n s  
of the  ACM 15, 7 
Brinch-Hansen, P, (1975). Tke progyamming ~ang~age 
Conc~yyent Pascal. IEEE  Transactions  on 
Bmo,  G, (1995). ~o~el-Based  So~ware 
Enginee~ing. London:  Chapman & Hall. 
Burns, A. and  Davies,  G.L. (1993). Concuryent ~ y o g y a m ~ i ~ g .  
W o ~ g h a m :  
Addison-~esley. 
Carriero, N. and  Gelernter, D. (1989a). ~ ~ n d a  
in  Context. C o ~ ~ c a t i o ~  
of the  ACM 32'4 
Carriero, N. 
and  Gelernter,  D.  (1989b). 
How to  write  payal~el  pyograms~  a 
guide~or the p e ~ ~ e x e d .  
CCITT (1993). CCITT  Higk  Level 
~anguage ~ C H ~ L ~ ~  
Recomm~dation 2200. Geneva: 
Chandy,  K.M.  and  Misra, J. (1984). 27ze drin~ing pkilosopkeys  pyoblem. ACM  Transactions  on 
Cheung,  S.C.  and  Magee,  J.N. 
(1991). Payalle~ a~goyitkm design for woy~station clusteys. 
Cheung,  S.C.  and  Kramer, J. (1999). Ckec~ing  safe^ propeyties  using  compositional ye~ckabili~ 
Ciancarini,  P.  and Hadcin, C. (eds.) (1996). Cooydinatio~ ~ang~ages 
and ~ o d e l s .  
Proceedings 
B e n j a ~ / C u ~ i n g s  
Publishing  Company. 
Proceedings  AFIPS  SJCC  Computer  Conference, 39,485489. 
International  Series  in  Computer  Science. 
York:  Van  Nostrand  Reinhold. 
SE-12'2 (February),  211-221. 
Addison-Wesley  Object  Technology  Series. 
ACM 13,4 (April),  238-241. 
(July),  574-578. 
Software  Engineering SE-1,2 (June),  199-206. 
(April), 444458. 
ACM  Computing  Surveys 21,3 (September),  323-358. 
International T e l e c o ~ ~ c a t i o n  
Union ITU. 
Programming  Languages  and  Systems 6,4 (October), 632-646. 
Software:  Practice  and  Experience 21, 3 (March),  235-250. 
analysis. AGM Transactions  on  Software E n ~ e e ~ g  
Methodology  TOSEM. 
of Coordination '96, LNCA  1061, B e r h  Springer-Verlag. 

Clarke,  E.M.,  Emerson,  E.A.  and  Sistla,  A.P.  (1986). Automatic ver~cation  of~nite 
state con- 
current  systems  using  temporal  logic 
spec~cations. ACM  Transactions  on  Programming 
Languages  and  Systems S, 2 (April),  626-643. 
Coffman, E.G. Jr.,  Elphick,  M.J.  and  Shoshani, A. (1971). System deadloc~. 
ACM  Computing 
Surveys 3 , 2  (June),  67-78. 
Cuningham, R.J. and  Kramer, J. (1978). An exercise in progrffm design  using S
~
~
~
L
A
class 
invffriants. Software:  Practice  and  Experience S, 3 (May-June),  355-369. 
Department of Defense.  (1983). ~eference ~
a
n
~
a
~
 
for the  Ada ~ r o ~ a ~ ~ i n g  
Lffng~age. 
New 
York Springer-Verlag. 
Dijkstra,  E.W.  (1965). Solution ofa  pr~blem 
in  concurrent program~ing control. Communication 
of the  ACM 8,9 (September), 569. 
Dijkstra, E.W. (1968). Coopera~ing s e ~ u ~ t i a l  
processes. In F.  Genuys  (ed.) 
~rogra~ming 
Languages, 43-112,  New  York:  Academic  Press. 
Dijkstra, E.W. (1972a). A class of allocation  strategies  inducing  bounded  delays  only. 
AFIPS 
Spring  Joint  Computer  Conference  SJCC,  933-936. 
Dijkstra, E.W. (1972b). ~ierarchical ordering ofse~uential processes. In C.A.R. Hoare  and  R.H. 
Perrott  (eds.)  Operating  System  Techniques.  New  York:  Academic  Press. 
Fowler, NI. and  Scott, K. (1997). UML ~isti~led: 
Applying  the  Standard  Object  Modeling 
Language. Addison-Wesley  Object  Technology  Series. 
Francez, N. (1986). ~airness. New  York:  Springer-Verlag. 
, 
Garlan,  D.  and Le Metayer, D. (eds.)  (1997). Coordination  Languages  and Mode~s, 
Proceedings 
of the  2nd  International  Conference,  Coordination 
'97,  LNCS 
1282,  Berlin:  Springer- 
Verlag. 
Gelernter,  D.  (1985). ~ e n e ~ f f t i ~ e  
com~unication in  Linda. ACM  Transactions  on  Programming 
Languages  and  Systems 7 , l  (January),  80-112. 
~ i a ~ a k o ~ o ~ o u ,  
D.,  Magee,  J.N.  and  Kramer, 
J. (1998). ~ h e c ~ i n g  
progress in  concurrent 
systems. 
Goldberg, A. and  Robson, D. (1983). S~a~ltal~-80. 
Addison-Wesley. 
Gomaa,  H.  (1993). S o ~ ~ a r e  
Design   et hods for Concurrent  and ~ e a l - T i ~ e  
Systems. Reading, 
MA: Addison-Wesley. 
~ r i ~ o m o n t ,  
P. and  Wolper, P. (1989). Temporff~ 
Logic. In A. Thayse (ed.) From ~ o d a ~  
Logic  to 
Deducti~e Dfftabases. John  Wiley  and  Sons. 
Harel, P. 
(1987). Statechffrts:  a vi sua^ forma~ism  for complex  systems. Science of Computer 
Programming S ( J ~ l y ) ~  
231-1274. 
Harel, D., Lachover, H., Naamad,  A.,  Pnueli, A., Politi, M.,  Sherman, R., Sh~ll-Trauring, A. 
and Tra~tenbrot,  M, 
(1990). S
~
A
~
~
~
A ~ o r ~ i n g  
environme~t 
for the de~elopment of 
complex  reactive syste~s. IEEE  Transactions  on  Software  Engineering 
SE-16, 4 (April), 
403-414. 
Hoare,  C.A.R. (1974). ~onitors: an  operating  system  structuring conc~t. 
Communicatio~ of 
the AGM 17,lO (October),  549-557. 
Hoare,  C.A.R.  (1978). Co~mun~cat~ng  se~uent~ff~ 
processes. Communications of the  ACM 21,8 
(August), 666-677. 
Hoare,  C.A.R.  (1985). Co~municating  Se~uential 
~rocesses. Prentice-Hall  International  Series 
in Computer  Science. 
Holt, RC. (1983). Concurrent ~ u c l i ~ ,  
The ~~~~ 
Syste~, 
and  Tunis. Reading,  MA:  Addison- 
Wesley. 
Holt, RC. and Cordy, J.R.  (1988). The T~ring  pro~am~ing  lang~ffge. 
C o ~ ~ i c a t i o n s  
of the 
ACM 31,12 (December),  1410-1423. 

~ibliogrup~y 
347 
Holzmam, G.J. (1991). Design  and ~alidation of  Computer  Protocols. Englewood Cliffs, NJ: 
Prentice-Hall  International. 
Holzmann,  G.J. (1997). The  model  checker SPIN. IEEE  Transactions  on  Software  Engineering 
SE-23, 5 (May),  279-295. 
INNIOS Ltd.  (1988a). OCCAM 2 Reference  Manual. Prentice-Hall  International  Series  in 
Computer  Science. 
NMOS Ltd. (1988b). Transpu~er Reference  Manual. Englewood Cliffs, NJ:  Prentice-Wall 
International. 
ISO/IEC. (1988). LOTOS: ~ormal 
description techni~ue based  on  the te~poral 
ordering  of  observa- 
tional ~ehaviou~. 
International  Standard 9074. Geneva:  International  Organization  for 
Standardization - 
Information  Processing  Systems - 
Open  Systems Intercomection. 
Joseph,  M. (ed,) (1996). Real-Time  Systems: Spec~cation, ~ e r ~ c a t ~ o n  
and A ~ ~ ~ y s i s .  
Prentice- 
Hall  International  Series  in  Computer  Science. 
Kanellakis,  P.C.  and  Smolka,  S.A. (1990). CCS E~pressions, Finite  State  Processes,  and  Three 
Pr~blems of E~uivalence. Information  and  Computation 86,l (May),  43-68. 
Kleiman, S., Shah, D. and  Smaalders, B. (1996). Progra~ming with  Threads. Upper  Saddle 
River, NJ: SmSoft Press,  Prentice-Hall. 
Kramer, J. and  Cunningham,  R.J. (1979). Invarian~sfor  Spec~cations. 
Proceedings of 4& IEEE 
International  Conference  on  Software  Engineering  ICSE  ’79,  Munich,  183-193. 
Lamport,  L. (1977). Proving  the  correctness  of  mu~tiprocess  programs. IEEE  Transactions  on 
Software  Engineering SE-3,  2 (March),  125-143. 
Lampson,  B.W.  and  Redell,  D.D. 
(1980). ~ ~ p e r i e n c e   ~ i t h  
processes  and  monitors  in  Mesa. 
Communications of the AGM 23,2 (February),  105-117. 
Lea, D. (1997). Concurrent Pr~gramming in  Java:  Design ~rinciples and  Patterns. Reading, M A :  
Addison-Wesley. 
Lehman, D. and  Rabin, M.0. (1981). A sy~metric and ~ l l y  
distributed  solution to the  dining 
phil~sophers problem. Proceedings of the 8& ACM Spposium on  Principles 
of 
Programming  Languages,  January,  133-138. 
Leveson,  N.G.  and  Turner, 
CS, (1993). An  investigation of the  Therac-25 accide~ts. IEEE 
Computer 26, 7 (July), 18-41. 
Lister, A. (1977). The  problem of  nested m o ~ i t o ~  
calls. Operating  Systems  Review 11,3 (July), 5- 
7. 
Lynch,  N.A. (1996). Distributed  Algorithms. San  Francisco,  CA:  Morgan Kaufmam. 
Magee,  J.N.,  Dulay, N. and Gamer, J. (1994). Regis:  A  constructive  development  environment 
for distributed  programs. Distributed  Systems  Engineering  Journal 1, 5, Special Issue on 
Configurable  Distributed  Systems,  304-312. 
Magee,  J.N.,  Dulay,  N.,  Eisenbach, S., and  Kramer, J. (1995). Speczfying dis~ributed so~ware 
architectures. Proceedings of 5& European  Software  Engineering  Conference  (ESEC  ’95), 
Sitges  (September),  LNCS 989, Springer-Verlag,  137-153. 
Magee,  J.N., Gamer, J. and Giamakopo~ou, 
D. (1997). Analysing  the  behaviour ofdistrib~ted 
so~ware 
architectures:  a  case  study. 
Proceedings of 5& IEEE  Workshop  on  Future  Trends 
in 
Distributed  Computing  Systems  (FTDCS’97),  Tunisia  (October), 240-247, 
Miher, R. (1989). Communication  and  Concurrency. 
Prentice-Hall  International  Series 
in 
Computer  Science. 
Milner,  R.,  Parrow, 
J. and  Walker,  D. 
(1992). A ca~culus of  mobile  processes, 
I and II. 
Information  and  Computation 100,1, 1-77. 
Peterson,  G.L. 
(1981). Myths  about  the 
~ ~ t u a 2  
e~clusion  prob~em. 
Information  Processing 
Letters 12,  3 (June),  115-116, 

Peterson, J.L. (1981). Petri  Net  Theory  and  the 
~ o d e l i ~ g  
of Systems. Englewood  Cliffs, NJ: 
Reiss, S.P. (1990). Connecting  tools  using  message  passing  in  the  Field  Environment. 
IEEE 
Roscoe, A.W. (1998). 
The  Theory  and 
Pr~ct~ce 
of Conc~rre~cy. 
Prentice-Hall Inte~ational 
Rmbaugh, J., Blaha, M*, 
Premerlani, W., Eddy, F. and Lorensen,  W.  (1991). Object-O~iented 
Selic, B., Gullekson,  G. and Ward, P.T. (1994). ~ e a l - ~ i m e  
Object Oriented ~ o ~ e ~ i n g .  
New 
Shaw, M. 
(1995). Co~paring 
architect~raZ  design  styles. IEEE Software 12, 6 (November), 27- 
Shaw, M. 
and Garlan, D.  (1996). S o ~ ~ a r e  
Architecture:  Perspectives  on  an  Emerging 
~iscipline. 
Sloman, MS, 
(ed.)  (1994). ~ e t ~ o ~ k  
and ~ i s t r i b ~ ~ e d  
S y s ~ e ~ s  
~an~gement. 
~ddi~on-Wesley. 
Swartout, W. and Baker, R. (1982). On  the inevita~le  intert~ining 
of spec~catio~ 
and  imple- 
Welsh, J. and Bustard, D.W.  (1979). Pascal-Pl~s~ 
 noth he^ language for m o d ~ ~ ~ r   ~ u l ~ i p r
Wirth, N. (1977). ~ o d ~ Z a ~  
a lang~age for m o d ~ ~ a r   m ~ l t i p r o g ~ a ~ ~ i n g .  
Software:  Practice and 
Prentice-Hall ~ t e ~ a t i o n a l .  
Series in Computer Science. 
  ode ling and  Design. Englewood  Cliffs, NJ: Prentice-Hall  International. 
York John Wiley and Sons. 
41. 
New  Jersey:  Prentice-Hall. 
 ent tat ion. C o ~ u ~ c a t i o n s  
of the ACM 25, 7 (July), 438440. 
ming. Software:  Practice and Experience 11, 947-957. 
Experience 7, 3-35. 

abstract  model 
238 
Abstract  Windowing  Toolkit  (AWT) 264, 
267 
abstraction 75,  161 
accept  222 
accept  method  223 
action  labels 
3234 
action  prefix 
12-17 
action  priority 137-8,  147,  154 
action  priority  operators  137 
actions 11, 31 
active  entities 76,  81 
active  objects  114 
Ada  222,230 
adverse  scheduling  conditions  147 
Allocator interface  186 
alphabet 22 
alphabet  extension 22-3,  144 
Andrews, G.R. ‘ 9,104,155,271 
animation 5-6 
~ouncer-Listener event-based 
architecture 263-71 , 
285 
~ p l e ~ e ~ t a t i o n  
267-70 
modeling 2667 
safety  analysis 
266-7 
applets 7,  27 
architectural  properties,  analysis 
23940 
architectures 233-74 
Areceiver class  218 
Arrivals class  83 
Asender class  218 
asynchronous  message  passing 
205, 
215-21 
applet  display 
217 
definition 205,  229 
in Java 216-19 
modeling 219-21 
asynchronous  model 
39 
as~chronous 
processes  60,276 
atomic  actions 11, 31, 77 
balking  315 
Baker, B. 230 
barrier synchro~~ation 272 
Ben-Ari, M. 9 
Birtwistle, G.M. 104,  203 
BlueCar class  130 
Booch, G. 5,31,180 
bounded  buffers 
94-7,227 
model  95 
program 96-7 
using  semaphores  100 
bounded  delays 
203 
bounded  overtaking 
195-7 
bounder  buffer  invariant  103 
BoxCanvas class  268 
BoxMover class  269 
Bridge class 131 
Bri~geCanvas class  129 
Brinch-Hansen, P. 103,  104,230 
Bruno, G. 179 
Buchi  automata  155 
B u f f e r I ~ p l  
class 96,243 
Buff  er interface 96 
buffer  invariant  102 

350 
Index 
buffer  tolerant 
237,  273 
buffers 94-7,  245-6 
Burns, A. 9,271 
Bustard,  D.W. 
104 
Calculus of Communicating  Systems 
call 222 
call method 223 
Car Park  class  diagram 
82 
Car Park  model 
80-1 
Car Park  program 
81-3 
CarParkControl  invariant 
102 
Carriero, N. 271,  272 
CarSpeed interface 175 
Chandy, KM. 119 
channel 205,206,222,226,229,243 
Channel class 208 
Cheung,  S.G. 
155,272 
CHILL 230 
choice 15 
Chute class 301 
Ciancarini, P. 272 
Clarke, EM. 155 
client-server 
233 
comrnon operators 319,  338-9 
Gomrnunicating  Sequential  Processes 
composite  process 
39,44,318,327-9,337 
composition  operator 
39 
concurrent 38 
concurrent  activity 
31 
Concurrent  Euclid 
104 
concurrent  execution 
37-62 
Concurrent  Pascal 
104 
concurrent  program 
37 
condition  synchronization 
79-87 
conditional  notification 
132 
conditional  process 
235 
connectors 235, 246, 271 
const 19,324-5 
constraint 308 
Consumer class 97,289-90 
consumer  process 
94 
Cordy, J.R. 104 
countdown  timer 
21,27-31 
Counter class 66, 72 
critical  section 
77, 91 
cruise  control  system 
2-4, 161-79 
(CCS) 7,31-2,61 
CARPARKCONTROL 
 
80-3,85 
CD-ROM 3,27 
(GSP) 7 
in  Java 
84-7 
animation 6 
applet  display 
175 
class  diagram 
176 
Controller class 176-7 
~plementation 173-9 
model  elaboration 
1 6 M  
progress  properties 
169-70 
revising  the  model 
170-3 
safety  properties 
167-8 
simulation 4 
SpeedCont r o l  class 178-9 
structure  diagram 
162-4 
CSP 32,61,206,230,315 
Cunningham,  R.J. 
203 
Dahl, 0. 104,203 
Darwin,  graphical  representation 
61 
data  independence 
95 
Davies,  G.L. 
9, 271 
deadlock 59,100,107-20,279 
analysis 107-11 
check 109 
detection  and  recovery 
108 
state 107, 122 
default  progress  property 
137 
default  property 
136 
Departures class 83 
design  architecture 
160,  173,  174 
deterministic  property 
124 
Dijkstra, E.W. 77,103,119,202,203 
Dining  Philosophers 
111-13 
applet 116 
composite  model 
113 
~plementation 113-16 
Dining  Savages 
105 
discrete  time 
276,  314 
CSP 315 
double-click  program 
277 
Dulay, N. 61 
dynamic  systems 
183-204 
efficiency 262-3 
Eisenbody, S. 61 
Emerson,  E.A. 
155 
encapsulation 161 
entering  a  monitor 
84 
entry 221,229 
En t ry class 223 
equivalent  observable  behavior 
50 
ERROR state 70, 88, 122, 123 
event 271 
event-based  architectures 
272 
event-based  systems 
285,  314 
exhaustive  analysis 
6 

exhaustive  search 
70 
exiting a monitor 84 
expressions 3324 
fair  allocation 
1924 
fair  choice 
134, 154 
FairAllocator class  194 
FairBridge class  143 
filter  233 
Filter class  243 
filter  pipeline 
233-46, 270-1 
finite  state  machines 
11 
finite  state  models 
9 
Finite  State  Processes, see FSP 
fork L 201 
Fowler, M. 180 
Francez, N. 155 
free  actions 
68 
FSP 7,12,31 
basic form  334 
composition  and  priority 
338 
description  322 
identifiers  322 
language  specification  321-34 
quick  reference  317-19 
semantics 335-41 
Function class  259 
Garlan, D. 271, 272 
Gelernter, D. 271, 272 
Generator class  242 
Giannakopoulou, D. 61,155 
Goldberg, A, 272 
Golf  Club  program  184-8 
applet  display  184 
class  diagram  185 
modeling  188-92 
revised  allocator  194-5 
Gomaa,  H.  180 
Gribomont,  P.  155 
guarded  actions 
21-2 
Gullekson,  G.  179 
handshake  43 
Hankin, C. 272 
Harel, D. 31, 179 
heavyweight  processes  24 
hiding  50, 
60, 75,330-1, 339 
hiding  operator  50 
high  priority  operator  137 
Hoare,  C.A.R. 
32, 60, 61,103, 230 
Holt,  R.C.  104 
Holzmann,  G.J.  155 
ImmutableList class  292 
implicit  invocation  263 
indexed  processes  and  actions  18-20 
input  action  15 
interface  339 
interface  operator  50 
interference  63-71, 
76 
interleaving 2, 37, 38, 60 
interrupt () 54 
invariants,  monitors  102-3 
1 / 0  automata  31 
isAlive( ) 26,197 
Jacobson, I, 31, 180 
Java  1, 
3, 7, 9, 81,  115 
applet 27 
asynchronous  message  passing 
condition synchroni~a~on 
in  84-7 
mutual  exclusion  in  71-3 
rendezvous  in  222-5 
semaphores  in 
90-4 
synchronous  message  passing  in 
threads  31 
threads  in  24-5 
JITTER 283 
join ( ) 183,198,201 
Joseph, M. 315 
Kanellakis,  P.C.  61 
Kleiman, S. 271 
Gamer, J. 61,155, 203 
label  sets  190 
Labeled  Transition  System, see LTS 
Labeled  Transition  System  Analyzer, see 
Lachover, H. 31, l79 
Lamport, L. 155 
Lampson, B.W. 104 
Lea, D. 9,32 
Lehman, D. 119 
Le  Metayer, D. 272 
Leveson, N. 9 
lightweight  processes  24 
Linda  tuple  space 
247-50,255,272 
in  216-19 
208-10 
LTSA 
in  247 
out  247 
rd 247 
Linear  Temporal  Logic  (LTL)  155 
Lister,  A.  104 
livelock  239 

352 
Index 
liveness,  single-lane  bridge 
problem 13843 
liveness  property 
121,133-8,154 
lock 72, 76, 100 
LOTOS 32 
low  priority  operator  137 
LTS 5,12,31,335-6 
composition 337 
priority  337-8 
LTSA 5,56 
LTSA Animator 13 
Lynch,  N.  31 
Magee, J.N. 61,155, 272 
master  197 
Master class  199 
master-slave  program  197-201 
modeling  200-1 
maximal  progress 
280-2,284,290,314 
May, D. 230 
menu  332 
Mesa  104 
message  passing  205-31 
see also asynchronous  message  passing; 
rendezvous;  synchronous  message 
passing 
Milner, R. 31, 61, 202 
~ n i ~ a t i o n  
50,60, 75 
minimized  LTS  236 
Msra,  J. 
119 
model-based  design  159-81 
modeling 4"7,38-9,80 
processes 
 
11-23 
semaphores  88-90 
Modula 
 
104 
modularity  161 
monitor  method  227-8 
monitor  wait  queue  85 
monitors 79, 81,  148 
entering  a  monitor 
84 
exiting  a  monitor 
84 
invariants  102-3 
nested  98-102 
~sgCarPark class  214 
Msg~ate 
class  213 
multi-party  synchronization  44 
multi-threaded  programs 
53-9 
~utexLoop 
class 93 
mutual  exclusion 47, 76, 89, 124 
modeling 73 
property  125 
Myhrhaug, B. 104,203 
MyListener class  269 
Naamad, A. 31, l79 
nested  monitor  calls  104 
nested  monitor  problem  101 
nested  monitors  98-102 
n o n - d e t e ~ s t i c  
choice 17-18,124,238 
non-determ~stic process  17 
not if y ( ) 84,104 
not if yAll( ) 84,85 
Num~erCanvas 27 
observational  equivalence  61 
Occam 205-6,230 
OMT  (Object  Modeling T e c ~ q u e )  5 
operating  system  processes 
23-4 
operators  319 
Ornamental  Garden 
Animator  trace 
70 
class  diagram 
64 
corrected  program  72 
model 67-71/68 
problem  64-7 
output  action  15 
Package  Router  problem  294 
parallel 38 
parallel  composition 
3941, 60 
parameters  329 
parcel  router  problem  293-304 
applet  display  300 
~plementation  300-4 
modeling  294-9 
~ a r c e l ~ o v e r  
interface  301 
Parrow, J. 202 
Pascal  Plus  104 
passive  entities 
76, 81 
passive  objects  114 
Peterson,  J.L. 
60 
Peterson's algorithm 156-7 
Petri  Nets 
60, 179 
n-calculus  202 
Pipe class  244 
P i p e I m p l ~ u ~  
class  244 
P i p e I m p l ~ n ~ u ~  
class  244 
pipeline  233 
pipes 233,271 
Player class  187 
Port class 216 
ports 215, 222, 226, 229, 230 
pre-tick() 286,290,292,293 
pre-tick  clock  phase 
313 
pre-tick  phase 
286, 290, 314 
preemption 107,119 
prefix  labels 
46 

(k- ex 
353 
prefix  matching  331 
PrimesCanvas class  242 
Prirnes  Sieve 
applet  240 
implementation 240-6 
model 234-40 
process  architecture  234 
Primes  Sieve of Eratosthenes  234 
p~inter-sca~er 
system 109-1 1 
process 2,11,23,24,31,317,336-7 
alphabets  22-3 
definition  325-7 
interaction 60 
labeling 45-8,60 
parameters 20 
Producer class 97, 288-9 
producer  process 
94 
ProducerConsumer class 287 
producer-consumer  model  287-90 
progress  133 
analysis 135-7 
properties  133-5,  147-8,  154,  191, 
319, 
331 
cruise  control  system  169-70 
violation  134 
property 121,123,154,319 
Rabin, M.O.  119 
range 19,324-5 
range type 19 
read/write  lock  145 
Readers-Writers  problem  144-54 
applet  display 
151 
~plementation 148-51 
modeling 144-8 
revised ~plementation  1514 
revised  model 
1514 
Readwrite interface  148 
ReadWrlteSafe class  150 
real-time 275 
receive 205, 206, 215 
Receiver class  209-10 
rectangle  method 
256 
recursive  locking 
73 
RedCar class  130 
Redell, D.D. 104 
Reiss, S.P. 272 
relabeling 60,330-1, 338-9 
relabeling  functions 
48-9 
Remote  Method  Invocation 
( M I )  228 
rendezvous 205,221-8,271 
and  monitor  method  invocation  227-8 
applet  display  224 
definition 205,221,229 
in  Java  222-5 
modeling  226-7 
reply  222 
reply  method 
223 
request-reply 221 
requirements  specification  160 
Result class  260 
resume ( ) 26 
Robson, D. 272 
ROOM  179 
Roscoe,  A.W. 
315 
Rotator class  57 
Rumbaugh, J. 31,180 
run ( ) 24,29,293 
Rmable 25, 29 
safety  analysis  122-5 
safety  properties  121, 
1234,145--6,154, 
319,331,339-40 
cruise  control  system  167-8 
for  mutual  exclusion 
124-5 
safety  violation  126 
Savings  Account  Problem  105 
Scott, K. 180 
select  207 
Selectable class  213 
selective  receive  207-8 
Selic, B, 179 
SemaBuf f er class 98 
semantic  equivalences  340 
Semaphore class  91 
semaphore  invariant  102 
semaphores  87-94,  124 
modeling  and ~plementing 212-15 
fixed  bounded  buffer  using  100 
in  Java 
9 0 4  
modeling  88-90 
send 205,206,215 
Sender class  209-10 
SensorCont  roller 
class 303 
set  constant 
67 
set of action  labels  16 
Shah, D. 271 
shared  actions  41-5, 
60 
shared  objects  63-71 
Shaw,  M. 
180,271,272 
shortest  trace  107 
signal  and  continue  104 
signal  and  urgent  wait  104 
SimpleAllocator class  186 
Set 324-5 
SIiVUL,A-67 104 

354 
Index 
single-lane  bridge  problem  125-32 
class  diagram  129 
display  using Bridge class  131 
implementation  128-32 
liveness 138-43 
modeling 
 
126-8 
revised  implementation  142-3 
revised  model 
141-2 
Sistla,  A.P.  155 
slave  197 
Slave class  199 
sleep ( ) 26 
Sloman, M.S. 272 
Slotcanvas class 188,210,225 
Smaalders, B. 271 
Smolka,  S.A.  61 
Space  Invaders 
30413 
applet  display  305 
implementation  311-13 
modeling  306-1 
1 
safety  analysis  309-1 
1 
speedup  262-3 
SPIN 155 
sprites  305-7 
start() 26 
starvation 132, 133,  185 
state 11 
state  machine  31 
State  Transition  Diagrams (STD) 31 
statecharts 31, 179 
STATEMATE 
 
179 
STOP 13,107,109 
stop( ) 26,30,54 
strong  semantic  equivalence  340 
strongly  connected  component  136 
structure  diagram  model  161 
structure  diagrams  51-3,  60 
SupervisorCanvas class  259 
Supervisor class 260 
supervisor-worker  system 
246-63,270-l 
applet  display  257 
class  diagram 
258 
implementation 256-63 
modeling 251-6 
process  architecture  246 
safety  analysis  254-6 
Switch class  302 
S ~ i t c h C o n t   r o l  
interface  301 
synchronized  method 
71,72,  76,86 
synchronous  message  passing  205-15 
applet  display  209 
definition 205,229 
in  Java  208-10 
modeling  210-11 
synchronous  model 
39 
terminal  sets  of  states  135 
Therac-25  1, 4, 9 
thread-based  systems 
285,314 
ThreadDemo  example 
implementation 56-9 
model 5&6 
thread  life  cycle  25-7 
Threadpanel class  57,  82, 
92, 210,225 
threads 11,24,31, 81 
tick 277,314 
tick  phase 
286, 290,313 
tickets 
 
193 
t i c k  ( ) 286,290,292 
time 275 
TimeManager class 291,300 
time-stop 279, 296, 309, 314 
TimedCount~own class 287 
timed CSP 315 
timed  objects 
286, 290, 305, 314 
timed  systems  275-316 
implementing  285-93 
modeling  276-84 
modeling  techniques 
2824 
output  in  an  interval  282-3 
in  Java 
2 6 5  
timed  wait ( ) 120 
timeout 207,284 
timing  consistency  278-9 
timing  uncertainty 
276 
token  ring  architecture  273 
trace  13,  70,  100, 
122 
transition  graph  11 
transitions  31 
transparency  124 
Transputer 206,230 
tuple  space 
247, 271 
implementation  249-50 
modeling  248-9 
Tuplespace interface 250 
TupleSpaceImpl class  250 
Turing  Plus  104 
Turner, C. 9 
Turnstile class 65 
two-phase  clock 
290 
type-ahead  buffer 
94 
UML 5,160,180 
class  diagrams 3434 
unbuffered  pipes 237 
undefined  states 88, 127 

lizdex 
355 
Unified  Modeling  Language, see UML 
Welsh, J. 104 
use  case  scenarios  160 
Wirth, N. 104 
wait() 84 
Worker class 
 
261 
wait-for 
 
cycle 
 
107, 
113, 118, 
 
119 
Workercanvas class 
 
259 
Walker, D. 202 
Ward, P.T. 179 
weak 
 
semantic 
 
equivalence 
340-1 
yield() 26,66 
Wolper, P. 155 

