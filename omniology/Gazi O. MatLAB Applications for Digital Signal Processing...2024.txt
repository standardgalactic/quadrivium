MRTLRB 
Applications For 
Digital Signal 
Processing
from Sampling to 
Filter Design
Drhan Dazi

MATLAB Applications for 
Digital Signal Processing
from Sampling to Filter 
Design
Orhan Gazi

Copyright Information
Orhan Gazi
Electrical and Electronics Engineering Department
Ankara Medipol University
Ankara, Turkey
© oG
oG Publications
This work is subject to copyright. All rights are reserved by 
the Publisher, whether the whole or part of the material is 
concerned, specifically the rights of translation, reprinting, 
reuse of illustrations, recitation, broadcasting, reproduction 
on microfilms or in any other physical way, and transmission 
or information storage and retrieval, electronic adaptation, 
computer software, or by similar or dissimilar methodology 
now known or hereafter developed. The use of general 
descriptive names, registered names, trademarks, service 
marks, etc. in this publication does not imply, even in the 
absence of a specific statement, that such names are 
exempt from the relevant protective laws and regulations 
and therefore free for general use. The publisher, the 
authors, and the editors are safe to assume that the advice 

and information in this book are believed to be true and 
accurate at the date of publication. Neither the publisher 
nor the authors or the editors give a warranty, expressed or 
implied, with respect to the material contained herein or for 
any errors or omissions that may have been made. The 
publisher remains neutral with regard to jurisdictional claims 
in published maps and institutional affiliations. This imprint 
is published by Orhan Gazi.

Table of Contents
Preface
Chapter-1
MATLAB Commands-1
1.1 Taking Input from Keyboard
1.2 Data Display on Screen
1.3 Number Vectors
1.4 LINSPACE command
1.5 Indices of the Vector Elements
1.6 Transpose of a Vector
1.7 Zero and One Vectors
1.8 Matrices
1.9 FIND command
Chapter-2
MATLAB Commands-2
2.1 Matrix Transpose
2.2 Matrix Operations
2.3 MATLAB HELP Function
2.4 LOOKFOR Command
2.5 QUIT and EXIT Commands
2.6 Clc, Clear All and Close All Commands
2.7 Save Command
2.8 Load Command
2.9 INF and NaN Results
2.10 Who Command
2.11 Complex Numbers in MATLAB
2.12 MATLAB Functions and MATLAB Scripts
2.13 Functions in MATLAB
2.14 Relational and Logical Operations in MATLAB
2.15 Control Flow Statements
If and Break Statements
For Loops
While Loops
Chapter-3
MATLAB Commands-3
3.1 How to Write MATLAB Programs Which Runs Fast and Use Less Memory: 
Tic Command

Toc Command
3.2 Pre Memory Reservation
3.3 Graphics in MATLAB
Axis Command
3.4 Determination of Coordinates
3.5 HOLD ON Command
3.6 HOLD OFF Command
3.7 XLABEL, YLABEL, and TITLE Commands
3.9 LEGEND Command
3.10 GRIN ON Command
Chapter-4
MATLAB Commands-4
4.1 STEM Command
4.2 SUBPLOT Command
4.3 FIGURE Command
Chapter-5
Continuous-Time and Discrete-Time Basic Signals with MATLAB
5.1 Continuous Time Impulse Signal
5.2 Continuous Time Unit Step Signal
5.3 Continuous Time Unit Ramp Signal
5.4 Continuous Time Square Signal
5.5 Digital Impulse Signal
5.6 Digital Unit Step Function
5.7 Digital Ramp Signal
Chapter-6
Sampling Operation
6.1 Sampling of Continuous Time Signals
6.2 Reconstruction of Continuous Time Signal from Its Samples
6.3 Spectral Overlapping and Aliasing Problem
Chapter-7
Fourier Transform of Continuous Time Signals and Sampled Signals
7.1 Fourier Transform of Continuous Time Signals
7.2 Fourier Transform of Digital Signals
Chapter-8
Defining Signals in MATLAB and Inverse Fourier Transform
8.1 Defining Signals in MATLAB
8.2 Inverse Fourier Transform
Chapter-9

Downsampling
9.1 Downsampling Operation
9.2 Sampling of Digital Signals
9.3 The Relationship between Downsampled Signal and Digital Signal
9.4 Decimation Filter and Downsampling
Chapter-10
Upsampling.
10.1 Upsampling
10.2 The Fourier Transform of Upsampled Signal
10.3 Interpolation of Upsampled Signal
Chapter-11
Rotation and Fourier Transform of Digital Signals
11.1 Rotation of Digital Signals
Rotation to the Right
Rotation to the Left
Rotation Inside
11.2 Discrete Fourier Transform
Chapter-12
ANALOG and DIGITAL Filter Design
12.1 Laplace Transform
Laplace Transform in MATLAB
ILAPLACE Command
12.2 Z-Transform
The Z-transform of the digital signal
Inverse Z-Transform in MATLAB:
12.3 Transfer Function and FREQS Commands
12.4 FREQZ Command
12.5 Analog Filter Design
12.6 Filter Parameters
12.7 Practical Filter Design Methods
12.8 Butterworth Filter Design
Butterworth Filter Design in MATLAB
12.9 Analog Chebychev Filter Design
Chebychev Type-II Filter
Chebychev Type-II Filter Design Using MATLAB
12.10 Elliptic Filters
12.11 Highpass, Bandpass and Bandstop Filter Design
Highpass Analog Filter Design

Bandpass Analog Filter Design
Bandstop Filter Design
12.12 Digital Filter Design
12.13 Filter Design Using FDATOOL
12.14 SIMULINK Filtre Orneqi
Bibliography

Preface
In this book, we explain the subject of digital signal 
processing with MATLAB examples. Digital signal processing 
has a wide field of study in electronic engineering. MATLAB 
program is a computer software that offers a wide range of 
working opportunities in engineering sciences. While 
preparing this book, we wanted it to be of maximum benefit, 
not only just providing MATLAB applications on digital signal 
processing, but also as a good MATLAB tutorial. That's why 
we prepared the starting chapters of the book as MATLAB 
tutorial.
In the book, basic MATLAB commands are explained in 
detail in the first four chapters. These chapters were 
prepared considering the readers who do not know the 
MATLAB programming language, want to remember it, or 
want to reinforce what they know. In the fifth chapter, the 
basic signals frequently used in the literature are explained 
in continuous and discrete time form. In the Chapter-6, 
sampling of continuous time signals is explained. We also 
covered spectral overlapping, i.e., aliasing problem.
In Chapter-7, the Fourier transform of digital and analog 
signals are studied. The relationship between Fourier 
transforms of digital and analog signals are inspected.
Chapter-8 includes the topic of inverse Fourier transform. 
Downsampling operation is covered in Chapter-9. We 
explain upsampling operation using MATLAB codes in 
Chapter-10. Chapter-11 is devoted to discrete Fourier 
transform subject, and finally we cover analog and digital 
filter design in Chapter-12. In Chapter-12, filter design using 
fdatool is also explained, and we also provided a filter 
design example for SIMULINK environment.

This book can be used as an accompanying book for digital 
signal processing courses. It can be especially useful for 
laboratory studies. Although, the book is prepared for 
university students and engineers studying digital signal 
processing subject, it can be read by anyone interested in 
digital signal processing subject.

Chapter-1
MATLAB Commands-1
Abstract: In this chapter, we explain the type MATLAB 
commands input, disp, linspace, zeros, and ones. Besides, 
we introduce the number vectors and perform operations on 
number vectors.
1.1 Taking Input from Keyboard
INPUT command
The input command is used to get data from the user and it 
is used as
r = input('Please enter your input: ');
where the variable r is used to keep the entered data.
Example-1.1:
Command Window
» r=input(1 Please enter and integer: '}
Please enter and integer: 23 
r = 
23
Figure-1.1 The use of input command
If we just hit the return key without entering a value, then 
empty matrix is assigned to the variable as shown in Figure-

1.2.
Command Window
» r=input('Please enter and integer: ■} 
Please enter and integer:
r =
[]
Figure-1.2 The use of input command
If the input data is a string, then the input command is used 
as
r = input('Please enter your name: ', 's');
Example-1.2:
Command Window
» r=inpat(1 Please enter your nair.e : 1 , ’s') 
Please enter your name: Ohan
r =
'Ohan1
Figure-1.3
In Figure-1.1, we did not use semicolon after the first line 
that is why the variable name, i.e., r and its name is 
displayed. If we use a semicolon at the end of the first line, 
then nothing is displayed as shown in Figure-1.4..
Example-1.3:
Command Window
» r=input(1 Elease enter your nair.e: 
’s');
Please enter your name: Ohan

Figure-1.4
We can use the next line operator '\n' inside a text to break 
it into two parts as shown in Figure-1.5.
Example-1.4:
Command Window
» r=input('Please eatei\nyoui name: ', 1s'}; 
Please enter 
your name: Ohan
Figure-1.5
1.2 Data Display on Screen
disp command
The command disp() is used to print the values and results 
to the monitor, an it is used as
disp(X)
where X can be number vector, or it can be a matrix, or it 
can be a string.
Example-1.5:
Command Window
» disp('Hello world, how are you?'}; 
Hello world, how are you?
Figure-1.6
Example-1.6:

Command Window
» x=[2 3 E 7 3 -2 -5 6];
» disp(x) ;
2 
3 
£ 
7 a -2 
-5 
£
Figure-1.7
1.3 Number Vectors
A number vector can be formed as in
x = [2.3 4.5 6 - 5.6 7],
We can also use the colon operator, :, to generate the 
vector elements as
x = first element: increment amount:last element
Example-1.7:
Command Window 
» x=2 :3:17 
x =
2 
5 a 11 
14 
17
Figure-1.8
Increment amount can be a negative number
Example-1.8:

Command Window 
» x=18 -2:-4 
x =
18 
1£ 
14 
12 
10 
8 
6 
4 
2 
0 
-2 
-4
Figure-1.9
Multiplication of Two Vectors
Let
x = [X1 x2-xN]
and
y = lyi y2"-yNl
be two number vectors. The dot product of these two 
vectors is calculated using
x. *y  = [x1y1 x2y2-xNyN]
Example-1.9:
Command Window
» x=[2 3 5 7] ;
» y=[2 2 2 2];
» x. *y
ans =
4 
£ 
10 
14
Figure-1.10
Number vectors can be used as arguments of functions, in 
this case the function operates on each of the vector 
elements.
Example-1.10: For x = [2 - 4 6 1.2 4] , y = exp(x) gives
y=[exp(2) exp( - 4) exp(6) exp(1.2) exp(4)]

Example-1.11:
Command Window
» x=0:pi/4:2
*pi;
» y=sin(x) 
y =
□ 
0.7071 
1.0000 
0.7071 
0.0000 
-0.7071 
-1.0000 
-0.7071 
-0.0000
Figure-1.11
Note: In MATLAB pi is used for n
1.4 LINSPACE command
Linspace command is used to generate a number vector 
between two numbers. It is used as
r = linspace(first_number, last_number, N);
where N is the length of the vector, and the vector contains 
the first and last numbers as well.
Example-1.12:
Command Window
>> r=linspace(-4,4,5)
r =
-4-2024
Figure-1.12
Example-1.13:

Command Window
» r=linspace(-pi,pi, a) 
r =
-3.1416 
-2.2440 
-1.3464 
-0.4488 
0.4488 
1.3464 
2.2440 
3.1416
Figure-1.13
1.5 Indices of the Vector Elements
For the number vector x “ txi x'2 Xn^ the first element is X1
and the index of the first element is 1, and the last element
X 
NT 
*
is N and the index of the last element is . The 1 element 
of the vector x is xu'.
Example-1.14:
Command Window
» x=[-4 £ a 9 3 -3 4 7 0] 
» x(3) , x(7)
ans =
a
ans =
4
Figure-1.14
The expression
X(i:j)
indicates the sub-vector obtained from x with the indices
i,i + 1,-j.

The expression
X(i:k:j)
indicates the sub-vector obtained from x with the indices
t i + kj + 2k/ -j
Example-1.15:
Command Window
» x=[-4 E 8 9 3 -3 470];
» x(3 :7)
ans =
□93-34
Figure-1.15
Example-1.16:
Command Window
» x=[-4 £893-3470];
» x (2 : 2 : and)
ans =
£9-37
Figure-1.16
1.6 Transpose of a Vector
The transpose of the vector x is obtained either using x' or 
using transpose^).

Example-1.17:
Figure-1.17
1.7 Zero and One Vectors
We can generate zero and one vector containing N zeros 
and N ones using
zeros(1, N) and ones(1, N)
Example-1.18:
Command Window 
» x=zeros(1,8) 
x =
□ 
0000000
Figure-1.18

Example-1.19:
Command Window 
» x=ones(1,3) 
x =
11111111
Figure-1.19
1.8 Matrices
A matrix of size 3x3 is defined as
A = [1 2 3 ; 4 
5 6 ; 7 8 9]
Where each row of the matrix is separated with semicolon, 
i.e., ;
Example-1.20:
Command Window 
» A=[l 2 3; 4 5 £; 7 3 9]
A =
12 
3
4 
5 
6
7 
a 
9
Figure-1.20
Elements of a Matrix
Let A denote a matrix. The rows of can be obtained as in 
A(l/ H indicates the first row of the matrix 
A( A:)— indicates the third row of the matrix 
A'j-indicates the i row of the matrix

Example-1.21:
Command Window
» A=[l 2 3; 4 5 £; 7 8 9]
A =
12 
3
4 
5 
£
7 
8 
9
» A (3 , : J
ana =
7 
8 
9
Figure-1.21
The columns of A can be obtained as in
A(UH 
matrix
indicates the first column of the

A(:,3H indicates the third column of the 
matrix
indicates the J column of the matrix
Example-1. 22:
Figure-1.22
indicates the submatrix obtained from the rows
A(2:4,:)
with row numbers 2, 3, and 4
indicates the submatrix obtained
columns with column numbers 1, 2, and 3
from
the
A(i:o, indicates the submatrix obtained 
intersection of rows 1, 2, 3 and columns 2, 3, 4 
A(a:b,c:d)-> indicates the submatrix obtained 
intersection of rows a> a + V-ab and columns c'c + !'■■■,d
from
from
the
the
A(a:k:b,c:m:d)— indicates the submatrix obtained from the 
intersection of rows a' a + kz---,b and columns c'c + m'---,d

Am— indicates the matrix obtained by concatenating the 
columns of A
Example-1.23:
Command Window
» A= [ 1 2 3 4; 5 £ 7 3; 9 10 11 12; 13 14 15 1£]
A =
12 
3 
4
5 
6 
7 
8
9 
10 
11 
12
13 
14 
15 
lfi
Figure-1.23
Example-1.24:
Command Window
» A=[l 2 3 4; 5 £ 7 □; 9 10 11 12; 13 14 15 1£]
A =
12 
3 
4
5 
£ 
7 
a
9 
10 
11 
12
13 
14 
15 
16
» A(2:4,:)
ans =
5 
£ 
7 
a
9 
10 
11 
12
13 
14 
15 
16
Figure-1.24
Example-1.25:

Figure-1.25
Example-1.26
Figure-1.26
Example-1.27

Command Window
» A=[l 2 3 4; 5 6 7 8; 9 10 11 12; 13 14 15 16]
A =
......-1.............2.............-3............ k—■
5 ig 
7 
!8
---- &---------------------3_. -------- 2r2----
13 
i;4 
15 
X6
» A(l:2:4,2:2:4)
ans =
2 
4
10 
12
Figure-1.27
Example-1.28:
Command Window
» A= [ 1 2 3; 4 5 6]
A =
12 
3
4 
5 
6
» A(:)
ans =
1
4
2
5
3
6
Figure-1.28
1.9 FIND command

Find command is used to get the one dimensional index of a 
matrix element. Order indexes start from the first element 
of the first column and it increases downward continuing 
from the second column and so on.
Example-1.29: In the MATLAB code in Figure-1.29, the one 
dimensional indices of matrix element 5 are found and 
displayed
Command Window
» A=[5 4 7; 8 0 5]
A =
5 4 7 
8 0 5
» find(A==5)
ans =
1 
£
Figure-1.29
Example-1.30: In the MATLAB code in Figure-1.30, the one 
dimensional indices of matrix elements greater than or 
equal to 5 are found and displayed

Command Window 
» A=[5 4 7; 8 0 5]
A =
5 
4 
7
8 
0 
5
» find(A>=5) 
ans =
1
5
" 
Figure-1.30

Chapter-2
MATLAB Commands-2
Abstract: In this chapter, we first perform operations of 
matrices, and then explain the commands help, lookfor, 
quit, exit, clc, close all, clear all, save, load, who. After 
studying logical operations with MATLAB, we will explain 
loop and control structures in MATLAB programming.
2.1 Matrix Transpose
The matrix obtained by replacing the rows of a matrix with 
columns and the columns with rows is called a transpose 
matrix. If the matrix A is defined as
A =
an
aln
akl
akn
then the transpose matrix happens to be as
In MATLAB the transpose of A is obtained using either or 
transpose(A).

Example-2.1:
Command Window
» A=[5 4 7; 8 0 5]
A =
5 
4 
7
8 
0 
5
>> transpose(A)
ans =
5 
8
4 
0
7 
5
Command Window
» A=[5 4 7; 8 0 5]
A =
5 
4 
7
8 
□ 
5
» A1
ans =
5 
8
4 
0
7 
5
Figure-2.1
2.2 Matrix Operations
Let and be two matrices as

'an
Laln
akil 
rbn bkl
! B = 
= 
■. 
=
akiJ 
Lbln ■■■ bkn
where n'k are integers. We can perform 
operations with matrices as
A * B~ is the matrix product of A and B
arithmetic
A * B~ is the 
calculated as
element product of A and B, that is A- * B is
k * A— every element of A is multiplied by k, and a new 
matrix is formed
A/k— every element of A is divided by \ and a new matrix 
is formed
AAk-> the k power of every element of A is evaluated and 
a power matrix is formed
kA A -> the powers of k are calculated using the elements 
of the matrix A, and a new matrix is formed
sin(A) -> the sine of every element of A is calculated, and a 
new matrix is formed 
exp(A) -> the exponent of every element of a is calculated, 
and a new matrix is formed
g(A) -> the elements of the matrix A are sent to the function 
) and a new matrix is formed from function returns
A + B~ is the matrix obtained from the addition of A and B

A - B~ is the matrix obtained from the subtraction of & and 
B
Let A and B be two square matrices of the same size, then 
we have the arithmetic operations
A/B— A is divided to B and the result equals AB
A\B— B is divided to A and the result equals A B
mv(AH is the inverse of A
det(AH is the determinant of A
Example-2.2: For the matrices A and B given in Figure-2.2.
Command Window 
» A=[l 2;3 4], B=[5 £;7 8]
A = 
1 2
3 
4
B = 
5 £
7 
a
Figure-2.2
We can perform the operations in Example-2.3, 2.4, 2.5, 2.6

Example-2.3:
» A. *B
» A*B
V 
V 
t-j 
*
ans =
ans =
ans =
5
12
19
— —
2
4
2 1
32
43
50
£
8
» A/2
ana =
0.5000 
1.0000
1.5000 
2.0000
Example-2.4:
» A."2 
» 
>> =xp(A)
ans = 
ans = 
ans =
1
4
3
9
2.7183
7.3891
9
16
27
81
20.0855
54.5982
» sin(A)
ans =
0.8115 
0.9093
0.1411 
-0.7558
Example- 2.5

>> inv(A) 
» det।A)
ana = 
ans =
-2.0000
1.5000
1.0000
-0.5000
» A/B
» A'.B
ans =
ans =
3.0000
-2.0000
-3 
-4
2.0000
-1.0000
4 
5
Example-2.6:
2.3 MATLAB HELP Function
MATLAB help function is used as
help search_word
Example-2.7:
Command Window
» help exp
EXP Exponential.
EXP(K) is the exponential of the elements of Zr e to the X 
For complex Z=X+i
*Y,
 EXP(Z) = EXP (X) * (COS (Y) +i
*SIN
 (T) ) .|
See also expml, log, 1 oglO, expiti, expint.
If we type
Figure-2.3

help lang
we get the list of programming commands used to write a 
MATLAB program.
Example-2.8:
Command Window
» help lang 
Programming language constructs.
Control flow.
if
else
- Conditionally execute statements.
- Execute statement if previous IF condition failed.
elseif
- Execute if previous IF failed and condition is true.
end
for
parfor
while
- Terminate scope of control statements.
- Repeat statements a specific number of times.
- Parallel FOR-loop.
- Repeat statements an indefinite number of times.
Figure-2.4
2.4 LOOKFOR Command
The command lookfor is used to find the terms where the 
search word is found. It is used as
lookfor search_word
Example-2.9:
Command Window
» lookzfor inverse
invhilb
ipermute
acos
acosd
acosh
acot
- Inverse Hilbert matrix.
- Inverse permute array dimensions.
- Inverse cosine, result in radians.
- Inverse cosine, result in degrees.
- Inverse hyperbolic cosine.
- Inverse cotangent, result in radian.
Figure-2.5

2.5 QUIT and EXIT Commands
To terminate the MATLAB compiler we use quit and exit 
commands.
2.6 Clc, Clear All and Close All
Commands
clc is used to clear the screen, clear all is used to erase all 
the variables from the memory, and close all is used to 
close all the open windows.
We usually place all these commands at the beginning of a 
MATLAB program.
2.7 Save Command
When MATLAB is closed all the variables are erased from 
memory. If we want to save the values of some variables, 
we can use the save command as
save file_name variableName1 variableName2 ...
where file_name is the file in which variable values are 
stored.
Example-2.10:

Command Window
>> x=13.7; y=32.3; z=-23
>> x
x =
13.7000
» y
7 =
32.3000
» z
z =
-23
Figure-2.6
Example-2.11:
Command Window
» x=13.7; y=32.3; z=-23
» clear all;
» x
??? Undefined function or variable
1 X
???
y
Undefined function or variable
1 7
???
z
Undefined function or variable
1 z
Figure-2.7
Example-2.12:
Command Window
» x=13.7; y=32.3; z=-23; 
» save myVariables x y z 
» dir *.mat
myVariables.mat
Figure-2.8

Example-2.13:
Command Window
» x=13.7; y=32.3; z=-23;
» save myVariables x y z 
» clear all;
» x
Undefined function or variable 'x'.
Figure-2.9
2.8 Load Command
Load command is used to restore the previously save 
variables and their values. It is used as
load file_name
Example-2.14:
Command Window
» x=13.7; y=32.3; z=-23;
» save myVariables x y z 
» clear all;
» x
Undefined function or variable 'x'.
» load myVariables 
» x
x =
13.7000
Figure-2.10
We can write simulation programs using MATLAB and after 
running these simulation programs we can save the results 
using the save command. Later on we can recover the 
results using the load command.
2.9 INF and NaN Results

If a number is divided by 0 in MATLAB, we get INF, i.e., 
infinity, result. The result NaN, i.e., not a number is obtained 
when °/° or 'x'/'x operations are performed.
Example-2.15:
Command Window 
» 1/0 
ans =
Inf 
» 0/0 
ans =
NaN
Figure-2.11
2.10 Who Command
The list of defined variables is displayed using who 
command and it is used as
who
Example-2.16:
Command Window 
» clear all; 
» x=3; y=9; z=2; 
> > who
Tour variables are: 
x y z
Figure-2.12
2.11 Complex Numbers in MATLAB

We can form the complex numbers in MATLAB using either 
‘i’ or ‘j’ complex numbers.
Example-2.17:
Command Window
2.0000 + 3 .OOOOi 
a=2+3 *i
2.0000 + 3 .OOOOi
Command Window
>> a=2+3j
2.0000 + 3.OOOOi
a=2+3 *j
2.0000 + 3.OOOOi
Example-2.18:
Figure-2.13

Command Window
» a=[l 2; 3 4]+j
*[5
 6; 7 8]
1.0000 + 5.00001 
2.0000 + 5.00001
3.0000 + 7.00001 
4.0000 + 8.00001
Figure-2.14
2.12 MATLAB Functions and MATLAB
Scripts
We write MATLAB programs to files to save them for later 
use. These files are called script files. MATLAB functions are 
also written separate files and MATLAB functions can be 
called inside MATLAB scripts.
At the beginning of a MATLAB script it is custom to write 
some comment lines to provide information about the 
written script, and we usually place clc, clear all, and close 
all command to the beginning of the program.
Example-2.19: In Figure-2.15, it is shown that to open a 
new script file we click on the left top icon of the MATLAB 
platform.

Workspace Current Folder
Figure-2.15
Example-2.20: The comment lines can be written as in 
Figure-2.16 to provide information about the MATLAB code.
Figure-2.16

Unless otherwise indicated, we will write our programs to 
MATLAB files from this point on.
2.13 Functions in MATLAB
The template of a MATLAB function is as 
function [out1, out2, ...] = functionName(inp1, inp2,...)
% statements
% statements
out1 = ..,
out2 = ..,
When the function file is saved, the file name must be the 
same as the function name, otherwise we cannot call the 
function inside a script.
Example-2.21:
Figure-2.17

The function in Example-2.21 can be called as 
sumAndDiff(45, 7) as in Example-2.22
Example-2.22:
Command Window
» [s, d]=sumAndDiff(45, 7)
s =
52
d =
38
Figure-2.18
It is also possible to define sub-functions inside a function 
file, and sub-functions can be called inside the main 
functions. The template is as
function [out1, out2, ...] = mainFunctionName(inp1, inp2,...) 
% statements
out1 = ..,
out2 = ..,
function [sub_out1, sub_out2, ...]=subFunctionName1(inp3, inp4,...) 
% statements
subout1 =
subout2 =
function [sub_out3, sub_out4, ...]=subFunctionName2(inp5, inp6,...) 
% statements

sub_out3 = ..,
sub_out4 = ..,
Example-2.23:
Figure-2.19

Command Window
» smDfSq(1, 2)
ans =
3
» [a, b, c, d]=smDfSq(l, 2) 
a =
3
b =
-1
c =
5
d =
-3
2.14 Relational and Logical 
Operations in MATLAB
Relational operators in MATLAB is listed as
smaller than 
smaller than or equal to 
greater than 
greater than or equal to
equality check 
non equality check

Logical operations in MATLAB are done using
logical AND
I 
io logica OR
~ ~o logical NOT
any(x) -> this function returns ‘1’ for the element of x 
greater than or equal to zero, otherwise it returns ‘0’ for the 
corresponding element.
all(x) -> this function returns ‘1’ if all the elements of x 
are greater than or equal to zero, otherwise it returns ‘0’.
Example-2.24:
Command Window
» x=[4.5 £ 7 -2 5 -£ 0]; 
» x>3 
ans =
1110 
10 
0
» x = = 7
ans =
0 
0 
1 
0 
0 
0 
0
Figure-2.20
Example-2.25: Let x be a number vector. Find the number
of elements of x greater then 5.

Figure-2.21
2.15 Control Flow Statements
In MATLAB control flow statements can be written using for- 
loops, while-loops, and if-then-else structures.
If and Break Statements
The if conditional statement is used as
if conditions
% statements
elseif conditions
% statements
else
% statements
end
Example-2.26:

Figure-2.22
When the program in Figure-2.22 is run, we get the output 
in Figure-2.23.
Command Window
Please enter a number: -23
You have entered a negative number.
Figure-2.23
Example-2.27: Write a MATLAB program which assigns 
letter grades to the student marks according to the table.
Letter Grade Average Mark
AA
>90
BA
85 < Not < 90
BB
80 < Not < 85
CB
75 < Not < 80
CC
70 < Not < 75
DC
65 < Not < 70
DD
60 < Not < 65

FD 
<60
Solution-2.27: The MATLAB program can be written as
Figure-2.24
When the MATLAB program in Figure-2.24 is executed we 
can get an output as in Figure-2.25.
Command Window
Please enter your mark: 56
Harf Notunuz: FD
Figure-2.25

For Loops
For loops are used to execute a number of statements for a 
definite number of times. It is used as
for index = values
% statements
end
Example-2.28: Write a MATLAB program which sums the 
integers from 1 to 9 and displays the result.
Figure-2.26
When the MATLAB program in Figure-2.26 is run we get the 
output in Figure-2.27.
Command Window
» for_examplel
The sum of the integers in the range [1..9] equals 25
Figure-2.27
Example-2.29: Write a MATLAB program which finds the 
sum of the elements of the number vector a = [1 3 12 6 8]

Solution-2.29: The MATLAB program can be written as in
MCode-12.x
clc; clear all;
sm = 0;
for a = [1 3 12 6 8] 
sm = sm + a;
end
When the MATLAB program in MCode-12.x is executed we 
obtain the output 30.
While Loops
While loop is written as
while logical_condition 
% statements
end
where as long as the logical condition is true the statements 
inside the while-loop are executed, otherwise the loop is 
quitted.
Example-2.30: Write a MATLAB program which gets a 
number from the user and concatenates it to the end of a 
positive number vector, when the user enters a negative 
number the program quits.
Initially the number vector contains no element.
Solution-2.30: The program can be written as shown in 
Figure-2.28.

Figure-2.28
When the MATLAB program in Figure-xx is run we get an 
output as in Figure-2.29.
Command Window
Bir pozitif sayi giriniz: 5
Please enter a positive number: 67
Please enter a positive number: 23 
Please enter a positive number: -1 
x =
5 
67 
23
Figure-2.29
Exercise: Write a program which 
the user and displays the vector
gets an integer N from
N N N N
■■■ □
1 2 2 3 3 3 4 4 4 4 N pieces

Chapter-3
MATLAB Commands-3
Abstract: In this chapter, first we will explain how to 
measure the execution speed of the MATLAB programs, and 
we will show the methods to increase the execution speed 
of the MATLAB programs. Next, we will explain the MATLAB 
graphic commands such as plot, axis, hold on, hold off, 
xlabel, ylabel, grid on, grid off, gtext, and legend.
3.1 How to Write Faster MATLAB
Programs
If MATLAB programs contains loops statements like for, 
while, the speed of the programs will be slower. To increase 
the speed of programs we can replace loop statements by 
vectors.
Tic Command
It is used to reset the chronometer of MATLAB.
Toc Command
It is used to read the chronometer value of MATLAB.
Example-3.1: The MATLAB program in Figure-3.1 measures 
the elapsed time needed for the execution of the for loop.

Figure-3.1
When the MATLAB program in Figure-3.1 is run we get an 
output as in Figure-3.2.
Figure-3.2
We can write the program in Figure-3.1 using vectors as in 
Figure-3.3.

Figure-3.3
When the MATLAB program in Figure-3.3 is run we get an 
output as in Figure-3.4.
Figure-3.4
The for-loop in Figure-3.1 takes 0.007576 seconds execution 
time, on the other hand the program in Figure-3.3 takes 
0.000429 seconds execution time. It is seen that the second 
program runs faster.
3.2 Pre Memory Reservation
If the use of loop statements is mandatory in a MATLAB 
program, to increase the speed of program execution, we 
can define vectors whose elements equal to zero or one. 
This is called pre-memory reservation.

Example-3.2: Let’s write the program in Figure-3.1 as in 
Figure-3.5.
Figure-3.5
When the MATLAB program in Figure-3.5 is run we get an 
output as in Figure-3.6.
Figure-3.6
The MATLAB program in Figure-3.1 takes 0.007576 second 
for execution, and in Figure-3.6 pre-allocation is performed 
for the same code and the execution time deceased to 
0.001285.
It is seen that pre-allocation increase the speed of the 
program.
3.3 Graphics in MATLAB

To draw the graphs of continuous time signals we use the 
MATLAB function plot(), and to draw the graph of discrete 
time signals we use the MATLAB function stem(). The plot() 
function is used as
plot(x, y)
where x and y are two number vectors. Let x=[1 2 3 4] and 
y=[2 4 5 8], then plot(x, y) first locates the coordinates as in 
Figure-3.7.
Figure-3.7
and then connects the coordinates and draws the graph as 
in Figure-3.8.
Figure-3.8
Example-3.3: 
The MATLAB program in Figure-3.9
illustrates the use of plot() function.

Figure-3.9
When the MATLAB program in Figure-3.9 is run we get an 
output as in Figure-3.10.
Figure-3.10

If the graph in Figure 3-10 is examined, it is seen that the 
horizontal axis starts from the integer 1 and the vertical axis 
starts from the integer 2. The ‘1’ is the first element of the x 
vector and the ‘2’ is the first element of the y vector. We 
can see the graph more clearly by zooming the shape 
outwards, and for this purpose we can use the "axis" 
command.
If the plot command is used only as 'plot(y)', then MATLAB 
accepts the vector x as its default value x=[1 2 3 — ] and 
runs the 'plot(x, y)' command. In other words, it creates the 
coordinates of the elements of the y vector according to 
their sequence numbers and draws the graph.
Axis Command
The axis command is used to zoom a specific part of the 
graph between certain horizontal and vertical axis values.
The general usage of the axis command is as
ax^S([Xmin Xmax Vmin Vmax^
where Xmin Xmax and ^min ^max specify the frontiers of the 
region to be displayed
Example-3.4:

Figure-3.11
When the MATLAB program in Figure-3.11 is run we get an 
output as in Figure-3.12.
Figure-3.12
Example-3.5:
Figure-3.13

When the MATLAB program in Figure-3.13 is run we get an 
output as in Figure-3.14.
Figure-3.14
3.4 Determination of Coordinates
The general use of the plot() function is as
plot(x, y, ‘s’)
where ‘s’ determines the properties of the drawn graph, and 
it consists of at most three letters and at least one letter. If 
the coordinate points are to be shown explicitly, then we 
can use one of the symbols in Table-3.1 for the ‘s’ 
parameter.
Table-3.1 The symbols used for 
marking of the coordinate points.
o circle
x-mark
x

+ plus
* star
s square 
d diamond
v triangle
^ triangle
< triangle
> triangle 
p pentagram 
h hexagram
Example-3.6:
Figure-3.15
When the MATLAB program in Figure-3.15 is run we get an 
output as in Figure-3.16.

Figure-3.16
If the lines which are used to connect the coordinates have 
specific properties, then the ‘s’ parameter in plot(x, y, ‘s’) 
consists of two characters. The first character is chosen 
from Table-3.1 and the second character is taken from Table- 
3.2.
Table-3.2 Line types
- solid
: dotted
-. dashdot 
-- dashed
Example-3.7:

Figure-3.17
When the MATLAB program in Figure-3.17 is run, we get an 
output as in Figure-3.18.
Figure-3.18
Example-3.8:

Figure-3.19
When the MATLAB program in Figure-3.19 is run we get an 
output as in Figure-3.20.
Figure-3.20
If we want the lines to be drawn to be colored, a third 
character is added to the 's' variable in the plot(x, y, 's') 

command. The third character is selected from Table-3.3.
Tabl3-3.3 Color parameters 
b blue 
g green 
r red 
c cyan 
m magenta 
y yellow 
k black 
w white
Example-3.9:
Figure-3.21
When the MATLAB program in Figure-3.21 is run we get an 
output as in Figure-3.22.

Figure-3.22
A single graph is drawn on Figure-xx. More than one graph 
can be drawn on the same figure using the “HOLD ON” 
command.
3.5 HOLD ON Command
The HOLD ON command is used to keep more than one 
graphic on the same figure. If HOLD ON is not used, the last 
graphic drawn remains on the figure.
Example-3.10:

Figure-3.23
When the MATLAB program in Figure-3.23 is run, we get an 
output as in Figure-3.24.
Figure-3.24
It is enough to write the HOLD ON command once to keep 
all graphics on the same figure. The HOLD ON command 
should be written after the “plot” command.

Example-3.11:
Figure-3.25
The output of the program in Figure-3.25 is as Figure-3.26.
Figure-3.26
3.6 HOLD OFF Command

Once the HOLD ON command is typed, all drawn graphics 
stay on the figure. HOLD OFF command is used to cancel 
the HOLD ON command.
Example-3.12:
Figure-3.27
When the MATLAB program in Figure-3.27 is executed we 
get the graph in Figure-3.28.

Figure-3.28
“XLABEL”, “YLABEL”, and “TITLE” commands are used to put 
labels on the horizontal axis, vertical axis and the top of the 
figure.
3.7 XLABEL, YLABEL, and TITLE
Commands
XLABEL is used as
xlabel('Label Text')
If the label on the x axis is to be colored, bolded, etc, then 
we use the XLABEL command as
xlabel('Label Text', 'property1', 'property2',...)
YLABEL is used as
ylabel('Label Text')

If the label on the y axis is to be colored, bolded, etc, then 
we use the YLABEL command as
ylabel('Label Text', 'property1', 'property2',...)
TITLE is used as
title('Label Text')
If the label on the title is to be colored, bolded, etc, then we 
use the TITLE command as
title('Label Text', 'property1', 'property2',...)
Example-3.13:

Figure-3.29
When the MATLAB program in Figure-3.29 is executed, we 
get the graph in Figure-3.30.
Subscript and superscript characters can be used with 
XLABEL, YLABEL and TITLE commands, and for subscript '_' 
and for superscript '~' is used.
Example-3.14:

Figure-3.31
When the MATLAB program in Figure-3.31 is executed, we 
get the graph in Figure-3.32.
Figure-3.32

3.8 GTEXT Command
This command used to add "text" with the mouse to any 
part of the graph drawn with the PLOT command. It is used 
as
Example-3.15:
gtext('Any Text')
Figure-3.33
When the program in Figure-3.33 is run, we get the graph in 
Figure-3.34.

Figure-3.34
When we click the mouse, the text in the gtext( ■■■) 
command is placed to the screen and the place lies to the 
right of the midpoint of the plus sign. In other words, when 
the mouse is pressed, the graph looks like as in Figure-3.35.

Figure-3.35
3.9 LEGEND Command
LEGEND command is used to give brief information the 
graphics on the figure. The information provided appears in 
the upper right corner of the figure. Its use is as
legend('first graph explanation','second graph 
explanation',...)
3.10 GRIN ON Command
GRIN ON command is used to place grid lines on the drawn 
graph. It may become easier to read some values on the 
graph with the help of grid lines. We can disable the GRIN 
ON command by typing GRID OFF.

Example-3.16:
Figure-3.36
When the program in Figure-3.36 is run, we get the graph in 
Figure-3.37.

Figure-3.37

Chapter-4
MATLAB Commands-4
Abstract: In this section, we will first discuss in details the 
“stem” command used to draw graphs of digital signals. 
Later, explanations and examples containing the “subplot” 
and “figure” commands will be given.
4.1 STEM Command
STEM command is used to draw discrete time signals or 
functions. This command is used as
stem(X,Y)
where X and Y are number vectors and the X vector is used 
for horizontal ordinates, and Y vector is used for vertical 
ordinates . If STEM command is used as
stem(Y)
then the elements of the Y vector are placed to the vertical 
axis according to their index values, i.e., X vector consists of 
the indices of the Y elements.
The symbols used to select color, line type, and coordinate 
marks for the PLOT command can also be used for the STEM 
command. Apart from this, XLABEL, YLABEL, TITLE, and AXIS 
commands can also be used with the STEM command.
In other words, all graphic parameters used with the PLOT 
command can also be used with the STEM command.

Example-4.1:
Figure-4.1
When the program in Figure-4.1 is run, we get the graph in 
Figure-4.2.
Figure-4.2

If the coordinate points are to be filled with small circles, 
then use the STEM command is used as
stem(X, Y,'filled')
Example-4.2:
Figure-4.3
When the program in Figure-4.3 is run, we get the graph in 
Figure-4.4.

Figure-4.4
The most general use of the stem command is as
Example-4.3:
stem(X, Y,'filled', LINE SPECS) or stem(X, Y, LINE SPECS, 'filled')
Figure-4.5

When the program in Figure-4.5 is run, we get the graph in 
Figure-4.6.
Figure-4.6
To change the interior color of the shapes at the top of the 
vertical lines, we can use the STEM command as
stem(X, Y,'filled', LINE SPECS, 'MarkerFaceColor', 'x')
where ‘x’ indicates the interior color.
Example-4.4:

Figure-4.7
When the program in Figure-4.7 is run, we get the graph in 
Figure-4.8.
Figure-4.8
To change the frontier color of the shapes at the top of the 
vertical lines, we can use the STEM command as

stem(X,Y,'filled',LINE SPECS,'MarkerFaceColor','x','MarkerEdgeColor', 'y')
where ‘y’ is the color parameter for the frontier.
Example-4.5:
Figure-4.9
When the program in Figure-4.9 is run, we get the graph in 
Figure-4.10.

Figure-4.10
Note: For MATLAB commands that cannot fit to a single 
line, we can use '...' at the end of the line to break the 
MATLAB command into two lines, in the previous example 
we used this feature.
It is possible to draw more than one graphic on the same 
figure with the STEM Command. In this case, the command 
is used as
stem(X,Y)
where if X is a vector and Y is a matrix such that Y=[Y1 Y2 "■] 
where Y1 Y2 ■" are the columns of the matrix.
In this case each column of Y is drawn with the same X 
vector. If X is a matrix such that X=[X1 X2 "] and Y=[Y1 Y2 "

], in this case, a column of Y is matched with a column of X 
such that they have the same column index and the 
matched pair is drawn.
Example-4.6:
Figure-4.11
When the program in Figure-4.11 is run, we get the graph in 
Figure-4.12.

Figure-4.12
Example-4.7:
Figure-4.13

When the program in Figure-4.13 is run, we get the graph in 
Figure-4.14
Figure-4.14
Example-4.8:

Figure-4.15
When the program in Figure-4.15 is run, we get the graph in 
Figure-4.16.
Figure-4.16
4.2 SUBPLOT Command
SUBPLOT command is used to divide the figure into several 
parts. PLOT command is used after the SUBPLOT command. 
The SUBPLOT is used as
subplot(m,n,k) 
plot(..) or stem(..)
Here, the figure is divided into mxn cells and any graph is 
drawn in the k cell with the next PLOT or STEM command.

Example-4.9:
Figure-4.17
When the program in Figure-4.17 is run, we get the graph in 
Figure-4.18.

Figure-4.18
Example-4.10:

Figure-4.19
When the program in Figure-4.19 is run, we get the graph in 
Figure-4.20.

Figure-4.20
The commands xlabel, ylabel, title and axis used for PLOT 
and STEM commands can be used separately for each 
subgraph, and they are written after the PLOT and STEM 
commands which are written after SUBPLOT command.
Example-4.11:

Figure-4.21
When the program in Figure-4.21 is run, we get the graph in 
Figure-4.22.

Figure-4.22
4.3 FIGURE Command
The FIGURE command is used to open a new figure window 
or to make one of the open windows the current window. It 
is used as
figure or figure(n)
The FIGURE(n) command is used to make the figure with 
figure number n the current figure and new graphic is drawn 
on the current figure.

Example-4.12: The use of figure command is illustrated in 
the MATLAB program in Figure-4.23.
Figure-4.23

Chapter-5
Continuous-Time and Discrete-Time Basic
Signals with MATLAB
Abstract: In this chapter we will study basic signals. We will 
briefly explain the continuous and discrete-time impulse, 
unit, ramp and square functions.
5.1 Continuous Time Impulse Signal
The continuous time impulse signal is defined as
r oo if t = 0 
(*
6^ = 10 otherwise J 
J 6(t)dt = 1
This function can be implemented in MATLAB as in
function y = imp(t) 
y = (t == 0);
end
In MCode-5.1, the graph of the impulse function is drawn.
MCode-5.1
t=-5:1/1000:5;
plot(t,imp(t),'k','LineWidth',2) 
grid on
xlabel('t','FontSize',12)
ylabel('\delta(t)','FontSize',12)

title('Impulse Function'); 
ylim([-0.5 1.5])
When MCode-5.1 is run, we get the graph in Figure-5.1.
5.2 Continuous Time Unit Step Signal
Unit step signal has the value of ‘1’ for non-zero time 
values, and it has ‘0’ value for negative time values. It is
denoted by and defined as
u(t) = {□ if t > 0 
otherwise

The unit step function can be implemented as in MCode-5.2
MCode-5.2 
function y = u(t) 
y = (t >= 0); 
end
The graph of the unit step function is drawn using MCode- 
5.3
MCode-5.3 
t=-5:1/1000:5;
plot(t,u(t),'LineWidth',2) ; 
grid on 
xlabel('t','FontSize',12) ; 
ylabel('u(t)','FontSize',12) ; 
title('Unit Step Signal');
ylim([-0.5 1.5]);
When MCode-5.3 is run, we get the graph in Figure-5.2.

Figure-5.2
5.3 Continuous Time Unit Ramp 
Signal
The ramp signal is denoted by rW and it is defined as
f t if t > 0 
1
r(t) - otherwise J
The ramp signal, i.e., function can be implemented as in 
MCode-5.4.
MCode-5.4 
function r = ramp(t) 
r = t.*  (t >= 0); 
end
The graph of the unit ramp function is drawn using MCode- 
5.5.
MCode-5.5 
t=-5:1/1000:5;
plot(t, ramp(t),'LineWidth',2);
grid on;
xlabel('t','FontSize',12);
ylabel('r(t)','FontSize',12); 
title('Ramp Signal');
ylim([-0.5 5.5]);
When MCode-5.x is run, we get the graph in Figure-5.3.

Figure-5.3
5.4 Continuous Time Square Signal
Square signal is defined as
, x f 1 if |t| < 0.5 1
sqr(t) - |o otherwise J
and it is implemented as in MCode-5.6.
MCode-5.6 
function y = sqr(t) 
y = (abs(t)<0.5) 
end
The graph of the square function is drawn using MCode-5.7.
MCode-5.7
t = -1:1/1000:1;

plot(t,sqr(t),'LineWidth',2);
grid on;
xlabel('t', 'FontSize', 12);
ylabel('square(t)','FontSize', 12);
title('Square Signal');
ylim([-0.5 1.5]);
When MCode-5.7 is run, we get the graph in Figure-5.4.
Figure-5.4
5.5 Digital Impulse Signal
Digital impulse signal is denoted by and it is defined as
6[n] = rlifn = O 1
10 otherwise]
It is implemented as in MCode-5.8.
MCode-5.8 
function y = impDT(n) 
y = (n == 0);

ks = find(round(n)~ = n); 
if(~isempty(ks))
y(ks) = = NaN;
end 
end
The discrete time axis consists of only integers. If the user 
enters a fractional number for the discrete time the impulse 
function implementation give, NaN, not a number error.
The graph of the digital impulse function is drawn using 
MCode-5.9.
MCode-5.9
n = -5:0.5:5;
stem(n, impDT(n), 'filled', 'LineWidth', 2);
grid on;
xlabel('n','FontSize',12);
ylabel('\delta[n]','FontSize',12);
title('Digital Impulse Function');
ylim([-0.5 1.5]);
When MCode-5.9 is run, we get the graph in Figure-5.5.

5.6 Digital Unit Step Function
Digital unit step function is defined as
rl ifn > 0 
1
ULnJ 10 otherwise/
It is implemented as in MCode-5.10.
MCode-5.10 
function y = uDT(n) 
y = (n >= 0); 
ks = find(round(n)~ = n); 
if(~isempty(ks)) 
y(ks) = NaN;
end

end
The graph of the digital impulse function is drawn using 
MCode-5.11.
MCode-5.11
n = -5:5;
stem(n, uDT(n), 'filled', 'LineWidth', 2) 
grid on
xlabel('n','FontSize',12) 
ylabel('u[n]','FontSize',12) 
title( 'Digital Unit Step Signal');
ylim([-0.2 1.2]);
Figure-5.6

5.7 Digital Ramp Signal
Digital ramp signal rM is defined as
fn if n > 0 
1
rLnJ 10 otherwise]
It is implemented as in MCode-5.12.
MCode-5.12
function y = rampDT(n) 
y = n.*(
n >= 0);
ks = find(round(n) ~= n);
if(~isempty(ks)) 
y(ks) = NaN;
end 
end
The graph of the digital impulse function is drawn using 
MCode-5.13.
MCode-5.13
n = -5:5;
stem(n,rampDT(n),'filled','LineWidth', 2);
grid on;
xlabel('n','FontSize',12);
ylabel('r[n]','FontSize',12);
title('Digital Ramp Signal');
ylim([-0.5 5.5]);
When MCode-5.13 is run, we get the graph in Figure-5.7.

Example-5.1: Definethesignal 
x(t) = 6(t - 1) - u(t - 3) + r(t - 5) in matlab and draw its 
graph for " 1 - 
10.
Solution-5.1: The graph of the x(tt can be drawn as in 
MCode-5.14
MCode-5.14
t = -1:1/1000:10;
plot(t,imp(t-1)-u(t-3) + ramp(t-5),'LineWidth', 2) 
grid on;
xlabel('t', 'FontSize', 12);
ylabel('x(t)=\delta(t-1)-u(t-3) + r(t-5)','FontSize', 12); 
title('Graph of x(t)=\delta(t-1)-u(t-3) + r(t-5)');

ylim([-1.5 4.5]);
Example-5.2: Definethesignal
x[n] = r[n + 1] - u[n - 1] + r[n - 3] in matlab and draw its
graph for " 1 - 11 - 10
Solution-5.2: The graph of the xfnl can be drawn as in
MCode-5.15.
MCode-5.15
n = -2:7;
stem(n,impDT(n + 1)-uDT(n-1) + rampDT(n-
3),'filled','LineWidth',2);

grid on;
xlabel('n', 'FontSize', 12);
ylabel('x[n]','FontSize', 12);
title('x[n] = r[n + 1]-u[n-1] + r[n-3]');
ylim([-1.5 3.5]);
Figure-5.9

Chapter-6
Sampling Operation
Abstract: In this chapter, we will first explain the sampling 
of continuous-time signals. Then, we will study the 
reconstructing of continuous-time signals from their 
samples.
6.1 Sampling of Continuous Time 
Signals
X (t)
The sampling of the continuous time signal ' is 
expressed as
x[n] = xc(t)|t = nT 
s
T 
kT
where s is the sampling period. At each s instant, a 
sample is taken from the continuous time signal and a 
mathematical sequence is formed from the collected 
samples. The mathematical sequence is denoted by
For the sampling operation, we will use second as the unit of 
time variable, *,  unless otherwise indicated. The same unit 
will also be used for the sampling period.
T   1 /8
For example, let the time interval be ° - * - 3 and “ 
.
In this case, if time unit is second, then the sampling period 

is 1/8 seconds.
Example-6.1: Draw the sine signal for the time interval 0 
- t - 2, the period of the signal is 1/4.
First, let's setup the time interval. We can use MATLAB 
vector for the formation of the time interval. If we select the 
increment amount in the time interval as 1/1000, we can 
obtain the time interval as in MCode-6.1.
MCode-6.1 
t = 0:1/1000:2;
In the second step, we will generate the sine signal using 
sm(2nft) where 1 is the frequency of the signal and it is 
equal to 4. The sine signal can be generated as in MCode- 
6.2.
MCode-6.2 
t = 0:1/1000:2 
F = 4;
x_t = sin(2*pi*F*t);
In the last step we draw the graph of the generated signal 
using the plot function as in MCode-6.3.
MCode-6.3 
t = 0:1/1000:2 
F = 4;
x_t = sin(2*pi*F*t); 
plot(t,x_t,'LineWidth',2); 
xlabel('t');
ylabel('sin(8\pit)'); 
title('sin(8\pit)');
When the MCode-6.3 is run, we get the graph in Figure-6.1.

for the 
period
Figure-6.1
Now let's sample the sine function in Figure 6-1.
Example-6.2: Draw the sine signal with period 1/4 
time interval 0 - * - 2 and using the sampling
s “ s ° sample the sine signal and obtain the digital sine 
signal xtn]. Draw the continuous and digital sine signals on 
the same figure. Draw the digital sine signal on a separate 
figure.
First, let’s generate the sine signal as in MCode-6.4.
MCode-6.4
t=0:1/1000:2
F=4;
x_t=sin(2*pi*F*t);

In the second step let’s form the digital signal by taking 
samples from continuous time signal at every multiple of 
!/16. For this purpose, first let’s form the sampling time ts 
interval as in MCode-6.5.
MCode-6.5
t=0:1/1000:2
F=4;
x_t=sin(2*pi*F*t);
The digital signal can be formed as in MCode-6.6.
MCode-6.6
t=0:1/1000:2
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16;
ts=0:Ts:2;
x_n=sin(2*pi*F*ts);
In the last step, we draw the graph of both continuous and 
digital signals using MCode-6.7.
MCode-6.7
t=0:1/1000:2
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16;
ts=0:Ts:2;
x_n=sin(2*pi*F*ts);
plot(t,x_t,'LineWidth',2);
hold on;
stem(ts,x_n,'r-.','filled');

When the MCode-6.7 is run, we get the graph in Figure- 
6.2.
Figure-6.2
Now let's draw the xtn] digital signal on a separate figure. 
For this purpose, let's first find the 11 integer values. We can 
calculate n integer values with the expression n “ ts//Ts as in 
MCode-6.8
MCode-6.8

t=0:1/1000:2
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16; 
ts=0:Ts:2;
x_n=sin(2*pi*F*ts);
n=ts/Ts;
Finally, we can plot the digital signal on a separate graph as 
in MCode-6.9.
MCode-6.9 
t=0:1/1000:2 
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16; 
ts=0:Ts:2;
x_n=sin(2*pi*F*ts);
n=ts/Ts;
stem(n,x_n,'r-.','filled');
When the MCode-6.9 is run, we get the graph in Figure-6.3.

Figure-6.3
T ~~ 1 /fi
Let’s change the sampling period to 
and revise
the program as in MCode-6.10.
MCode-6.10 
t=0:1/1000:2
F=4;
x_t=sin(2*pi*F*t);
Ts=1/64;
ts=0:Ts:2;
x_n=sin(2*pi*F*ts);
n=ts/Ts;

figure;
stem(n,x_n,'r-.','filled','MarkerEdgeColor','k',...
'MarkerFaceColor', 'k');
When the MCode-6.10 is run, we get the graph in Figure-6.4.
Figure-6.4
6.2 Reconstruction of Continuous
Time Signal from Its Samples
X (t)
Let * be the continuous time signal to be sampled. The
T
sampling period is s. The digital signal obtained after 
sampling operation is denoted by xlnL We can reconstruct 

continuous time signal from its samples using the 
reconstruction formula
xr(t) = ^x[n]hr(t - nTs)
n
where is the reconstruction filter and it is given as
sin
hr(t) = sine
' s
-A(t) = ——
s
s
Example-6.3: Generate the sine signal with period I/4 for 
the time interval 0 - * - 2 and sample this signal with 
sampling period 
, and let xfn] be the digital signal
obtained after sampling operation. Reconstruct the 
continuous time signal from its samples and compare the 
reconstructed signal to the original continuous time signal.
First, let's create the continuous time signal and then take
T ~~ 1/10 
samples from this signal with the sampling period 
and calculate the index values of these samples as in 
MCode-6.11.
MCode-6.11 
t=0:1/1000:2;
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16;
ts=0:Ts:2;
x_n_vec=sin(2*pi*F*ts);
n_vec=ts/Ts;
Now let’s consider the reconstruction formula

xr(t) = ^x[n]hr(t - nTs) 
n
First, we create a zero vector for the reconstructed signal as 
in MCode-6.12.
MCode-6.12
t=0:1/1000:2;
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16;
ts=0:Ts:2;
x_n_vec=sin(2*pi*F*ts);
n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
Let’s write the reconstruction expression. For this purpose, 
we first write the for-end structure as in MCode-6.13.
MCode-6.13
t=0:1/1000:2;
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16;
ts=0:Ts:2;
x_n_vec=sin(2*pi*F*ts);
n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec)
end
then we read a sample from the digital signal and determine 
its index as in MCode-6.14.

MCode-6.14 
t=0:1/1000:2; 
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16; 
ts=0:Ts:2;
x_n_vec=sin(2*pi*F*ts);
n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec) 
xn =x_n_vec(1,n_indx); 
n=n_vec(1,n_indx);
end
In the next step, we multiply the shifted sinc( ■) filter by the 
read sample and add the multiplication result to the variable 
created to hold the reconstructed signal as in MCode-6.15.
MCode-6.15 
t=0:1/1000:2; 
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16; 
ts=0:Ts:2;
x_n_vec=sin(2*pi*F*ts);
n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec) 
xn =x_n_vec(1,n_indx); 
n=n_vec(1,n_indx);
temp= xn *sinc((t- n *Ts)/Ts); 
x_r_t= x_r_t+ temp;
end

We can plot the reconstructed signal and original signal in 
the same figure using MCode-6.16.
MCode-6.16
t=0:1/1000:2;
F=4;
x_t=sin(2*pi*F*t);
Ts=1/16;
ts=0:Ts:2;
x_n_vec=sin(2*pi*F*ts);
n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec)
xn =x_n_vec(1,n_indx);
n=n_vec(1,n_indx);
temp= xn *sinc((t- n *Ts)/Ts); 
x_r_t= x_r_t+ temp;
end
plot(t,x_r_t,'k-.','LineWidth',3); % reconstructed signal 
hold on
plot(t,x_t,'g-','LineWidth',2); % original signal 
legend('Reconstructed Signal','Original Signal');

When the MCode-6.16 is run, we get the graph in Figure- 
6.5.
Figure-6.5
6.3 Spectral Overlapping and Aliasing 
Problem
The sampling frequency must be higher than twice the 
largest frequency present in the signal. Otherwise, enough 
examples are not taken from the continuous-time signal 

during the sampling operation and distortions will occur in 
the reconstructed signal.
In the previous example, the sampling period is taken as 
1/16, that is, the sampling frequency equals to 16. The 
frequency of the signal is 4, in this case 16>2x4. If we take 
the sampling frequency as 6, then the condition 6>2x4 
becomes false. Let’s choose the sampling frequency as 6 
and write the program as in MCode-6.17.
MCode-6.17
t=0:1/1000:2;
F=4;
x_t=sin(2*pi*F*t);
Ts=1/6;
ts=0:Ts:2;
x_n_vec=sin(2*pi*F*ts);
n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec)
xn =x_n_vec(1,n_indx);
n=n_vec(1,n_indx);
temp= xn *sinc((t- n *Ts)/Ts); 
x_r_t= x_r_t+ temp;
end
plot(t,x_r_t,'k-.','LineWidth',3); % reconstructed signal 
hold on
plot(t,x_t,'g-','LineWidth',2); 
% original signal

legend('Reconstructed Signal','Original Signal');
When the MCode-6.17 is run, we get the graph in Figure-6.6.
Figure-6.6
It is seen from Figure-6.6 that, the reconstructed analog 
signal is different than the original signal. This is due to the 
fact that the sampling frequency is not chosen high enough 
and not enough samples are taken from the continuous time 
signal.
T =1/4
Example-6.4: Using the sampling period 
sample
the signal shown in Figure-6.7 and using the digital signal 
obtained from the sampling operation, reconstruct the 
analog signal from its samples.

xc(t)
Figure-6.7
Sampling of the continuous time signal in Figure-6.7 with
T = 1/4
sampling period 
is illustrated in Figure-6.8.
xc(t)
Figure-6.8
The digital signal obtained from the sampling operation can 
be written
x[n] =11111111 □ 11111111
Now, let’s implement the sampling operation in MATLAB.
First, let’s generate the continuous time signal as in MCode- 
6.18.
MCode-6.18
t=-2:1/1000:2;
x_c_t=ones(1,length(t));

We plot the generated signal in MCode-6.19.
MCode-6.19 
t=-2:1/1000:2; 
x_c_t=ones(1,length(t)); 
plot(t,x_c_t,'k');
axis([-3 3 0 1.5]);
When the MCode-6.19 is run, we get the graph in Figure-6.9.
Figure-6.9
Vertical lines can be added to the graph in Figure-6.9 using 
the MCode-6.20.
MCode-6.20
t=-2:1/1000:2;
x_c_t=ones(1,length(t)); 
plot(t,x_c_t,'k');
axis([-3 3 0 1.5]);

hold on;
stem(-2,1,'marker','none');
stem(2,1,'marker','none');
When the MCode-6.20 is run, we get the graph in Figure- 
6.10.
Figure-6.10
Now we can write the program for sampling operation. First, 
let’s form the sampling instants as in MCode-6.21.
MCode-6.21
t=-2:1/1000:2;
x_c_t=ones(1,length(t));
Ts=1/4;
ts=-2:Ts:2;
Next, generate the digital signal by sampling the continuous 
time signal as in MCode-6.22 where the index values of the 

samples are also calculated.
MCode-6.22
t=-2:1/1000:2;
x_c_t=ones(1,length(t));
Ts=1/4;
ts=-2:Ts:2;
x_n_vec=ones(1,length(ts));
n_vec=ts/Ts;
In the next step, we write the for-loop structure for the 
reconstruction operation as in MCode-6.23.
MCode-6.23
t=-2:1/1000:2;
x_c_t=ones(1,length(t));
Ts=1/4;
ts=-2:Ts:2;
x_n_vec=ones(1,length(ts)); 
n_vec=ts/Ts;
for n_indx=1:length(n_vec)
end
And we write the body of the for loop using the 
reconstruction formula as in MCode-6.24.
MCode-6.24
t=-2:1/1000:2;
x_c_t=ones(1,length(t));
Ts=1/4;
ts=-2:Ts:2;
x_n_vec=ones(1,length(ts));

n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec)
xn =x_n_vec(1,n_indx);
n=n_vec(1,n_indx);
temp= xn *sinc((t- n *Ts)/Ts); 
x_r_t= x_r_t+ temp;
end
We can plot the graph of reconstructed signal as in MCode- 
6.25.
MCode-6.25
t=-2:1/1000:2;
x_c_t=ones(1,length(t));
Ts=1/4;
ts=-2:Ts:2;
x_n_vec=ones(1,length(ts)); 
n_vec=ts/Ts;
x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec)
xn =x_n_vec(1,n_indx);
n=n_vec(1,n_indx);
temp= xn *sinc((t- n *Ts)/Ts); 
x_r_t= x_r_t+ temp;
end
plot(t,x_r_t,'k-.','LineWidth',3); % reconstructed signal 
hold on;
plot(t,x_c_t,'g-','LineWidth',2); % original signal
axis([-3 3 0 1.5]);
legend('Reconstructed signal','Original signal');

When the MCode-6.x is run, we get the graph in Figure- 
6.11.
Figure-6.11
T = 1/32
If we use sampling period 
in MCode-6.25, then we
get the output as in Figure-6.12

1.5
• Reconstructed sign,al 
Original signal
1 -
0.5 -
0-3-2-10 
1 
2 
3
Figure-6.12
T — 1/128
If we use sampling period s 1 in MCode-6.25, then
we get the output as in Figure-6.13

Figure-6.13
T
As can be seen, as s decreases, that is, as more samples 
are taken, the quality of the generated signal increases. But 
deterioration still exists at the ends. This is because the 
bandwidth of the rectangular wave is infinite.
Exercise: Perform sampling operation for the signal shown
T _ 1/64
in Figure-6.14. Take the sampling period as 
.
Reconstruct the continuous tines signal from its samples 
using the S111C reconstruction filter.

Figure-6.14
Solution: Sampling and reconstruction operation are 
implemented in MCode-6.26.
MCode-6.26
t1=-6:1/1000:0;
t2=0.001:1/1000:3;
t3=3.001:1/1000:7
t=[t1 t2 t3];
x_c_t1=(1/3)* t1+2;
x_c_t2=2*ones(1,length(t2));
x_c_t3=-0.5*t3+3.5;
x_c_t=[x_c_t1 x_c_t2 x_c_t3];
Ts=1/64;
ts1=-6:Ts:0;
ts2=0.001:Ts:3;
ts3=3.001:Ts:7;
x_n_vec1=( 1/3 )* ts1+2;
x_n_vec2=2*ones(1,length(ts2));
x_n_vec3=-0.5*ts3+3.5;
x_n_vec=[x_n_vec1 x_n_vec2 x_n_vec3];
n_vec1=ts1/Ts;
n_vec2=ts2/Ts;
n_vec3=ts3/Ts;
n_vec=[n_vec1 n_vec2 n_vec3];

x_r_t=zeros(1,length(t));
for n_indx=1:length(n_vec)
xn=x_n_vec(1,n_indx);
n=n_vec(1,n_indx);
temp=xn * sinc((t- n *Ts)/Ts);
x_r_t=x_r_t + temp;
end
plot(t,x_r_t,'k-'); % Reconstructed signal
hold on;
plot(t,x_c_t,'m'); % Original signal
axis([-17 8 0 2.5]);
% legend('Reconstructed signal','Original signal');

Chapter-7
Fourier Transform of Continuous Time Signals 
and Sampled Signals
Abstract: In this chapter, we will first explain how to 
evaluate and plot the Fourier transforms of continuous-time 
signals in MATLAB, and then illustrate how to calculate and 
plot the Fourier transforms of digital signals obtained by 
sampling continuous-time signals in MATLAB.
7.1 Fourier Transform of Continuous
Time Signals
X (t)
The Fourier transform of the continuous time signal ' is 
calculated using
00
Xc(w) = J*  xc(t)e'jutdt 
- 00
(7.
1)
where w is the angular frequency.
Example-7.1: Draw the cosine signal on the interval 0 - t 
2 2. The period of the signal is ^2. Evaluate the Fourier 
transform of the signal and plot it.
Solution-7.1: First, let's define the time interval as in 
MCode-7.1.
MCode-7.1

t=0:0.001:2;
Then, we generate the cosine signal with frequency 2Hz as 
in MCode-7.2.
MCode-7.2
t=0:0.001:2;
f=2;
xct=cos(2*pi*f*t);
In the third step, we draw the graph of the cosine signal 
using the plot() function as in MCode-7.3.
MCode-7.3
t=0:0.001:2;
f=2;
xct=cos(2*pi*f*t);
plot(t,xct);
xlabel('t(sec)');
ylabel('cos(4\pit)');
title('Continuous Time Cosine Signal');
When the MCode-7.3 is run, we get the graph in Figure-7.1.

Figure-7.1
Now, let's calculate the Fourier transform of the cosine 
signal. For this purpose, first let's write frequency vector. We 
use linspace command to create the angular frequency 
vector which ranges from -8n to 8n as in MCode-7.4
MCode-7.4
t=0:0.001:2;
f=2;
xct=cos(2*pi*f*t);
plot(t,xct);
xlabel('t(sec)');
ylabel('cos(4\pit)');
title('Contiuous Cosine Signal'); 
w=linspace(-8*pi,8*pi,length(t));
In the next step, we write the first line of the for-loop which 
will be used to calculate the Fourier transform of the cosine 
signal. Fourier transform function is calculated for each 
value of the angular frequency as in MCode-7.5.

MCode-7.5
t=0:0.001:2;
f=2;
xct=cos(2*pi*f*t);
plot(t,xct);
xlabel('t(sec)');
ylabel('cos(4\pit)');
title('Contiuous Cosine Signal');
w=linspace(-8*pi,8*pi,length(t));
for i=1:length(t)
We will use the trapz function to calculate the integral 
expression in Fourier transform formula. T rapz function can 
take a single argument as in trapz (A) where the approximate 
integral of A is calculated. If the function takes two 
argument as in trapz (B, A ), then the integral of A is 
calculated according to B.
For instance, to calculate /x(t)dt we write trapz (t,x). For the 
t x e
Fourier integral expression we will use trapz( 
)
inside the for-loop as in MCode-7.6.
MCode-7.6
t=0:0.001:2;
f=2;
xct=cos(2*pi*f*t);
plot(t,xct);
xlabel('t (sec)');
ylabel('cos(4\pit)');
title('Contiuous Cosine Signal');
w=linspace(-8*pi,8*pi,length(t));
for i=1:length(t)
xcw(i)=trapz(t,xct.* exp(-j*w(i).
* t));
end

In MCode-7.6, XCW is the Fourier transform of xct, and the 
Fourier transform is calculated for each w(i) angular 
frequency. The calculated XCW values can be plotted using 
MCode-7.7.
MCode-7.7
t=0:0.001:2;
f=2;
xct=cos(2*pi*f*t);
plot(t,xct);
xlabel('t (sec)');
ylabel('cos(4\pit)');
title('Contiuous Cosine Signal'); 
w=linspace(-8*pi,8*pi,length(t));
for i=1:length(t)
xcw(i)=trapz(t,xct.* exp(-j*w(i).
* t));
end 
figure 
plot(w,abs(xcw)); 
xlabel('\omega');
ylabel('FT(cos(4\pit))');
title('Fourier Transform of Cosine Signal');
WhenMCode-7.7 is run, we get the Fourier transform of 
cos (2nft) as in Figure-7.2.

When the graph in Figure-7.2 is inspected, it is seen that 
there are two impulse functions at the points -4n and +4n. 
However, the impulse functions of Figure-7.2 are not very 
narrow functions as in theory. To get better impulse 
functions we can increase the time interval for the 
parameter t in MCode-7.7 from 0 to 20, i.e., ° - * - 20. In 
this case, we get the graph in Figure-7.3.

Figure-7.3
7.2 Fourier Transform of Digital
Signals
A digital signal is obtained from a continuous time signal 
X (t)
* via sampling operation described as
x[n] = x.,(t)|t = uT 
(7­
s 
2)
The digital signal xtn] is a mathematical sequence.
The Fourier transform of digital signal xtn] is calculated as
00
Xn(w) = ^x[n].e’jGm 
n =- co
(7.
3)

The relationship between the Fourier transform of the 
continuous time signal and the Fourier transform of the 
digital signal obtained from continuous time signal via 
sampling operation is given as 
(7.
4)
where 11 is an integer and s is the sampling period.
Example-7.2: Consider a cosine signal with frequency 
2Hertz. Sample this signal with sampling period Ts “ 
and obtain a digital signal. Draw the Fourier transforms of 
both continuous time cosine signal and digital signal using 
MATLAB.
Solution-7.2:
Let's first define time interval, frequency of cosine signal, 
sampling period, sampling instants, and then generate the 
continuous and digital signals as in MCode-7.8.
MCode-7.8
clc;clear all;close all;
t=0:1/1000:2;
f=2;
Ts=1/16;
ts=0:Ts:2;
n=ts./Ts;
xct=cos(2*pi*f*t);
xn=cos(2*pi*f*ts);
Now let's plot the signals using the 'subplot' command as in 
MCode-7.9.
MCode-7.9
figure(1);
subplot(2,1,1);

plot(t,xct);
xlabel('t(sec)');
ylabel('cos(4\pi t)');
title('Contiuous Time Cosine Signal');
subplot(2,1,2);
stem(n,xn,'r-.','filled');
xlabel('n (integer)');
ylabel('cos(4\pi n Ts)'); 
title('Digital Cosine Signal');
When MCode-7.9 is run, we get the graph in Figure-7.4.
CDs(4?rnTs)
Figure-7.4

In the second step, we will define the angular frequency 
axis, and calculate the Fourier transform of the continuous 
time signal with the 'trapz' command, and for the 
calculation of Fourier transform of the digital signal 'sum' 
command is used.
We write one for-loop for the calculation of Fourier 
transforms as in MCode-7.10.
The Fourier transform of a digital signal is a continuous 
function. To plot both Fourier transforms we use the plot() 
function.
MCode-7.10
clc;clear all;close all;
t=0:1/1000:2;
f=2;
Ts=1/16;
ts=0:Ts:2;
n=ts./Ts;
xct=cos(2*pi*f*t);
xn=cos(2*pi*f*ts);
figure(1);
subplot(2,1,1);
plot(t,xct);
xlabel('t(sec)');
ylabel('cos(4\pit)');
title('Contiuous Time Cosine Signal');
subplot(2,1,2);
stem(n,xn,'r-.','filled');
xlabel('n (integer)');
ylabel('cos(4\pi n Ts)');
title('Digital Cosine Signal');
w=linspace(-8*pi,8*pi,length(t));
for i = 1:length(t)

xcw(i)=trapz(t,xct.* exp(-j*w(i).
* t));
xnw(i)=sum(xn.* exp(-j.* w(i)* n));
end
figure(2)
subplot(2,1,1)
plot(w,abs(xcw))
xlabel('\omega (radian)')
ylabel('F(cos(4\pit))')
title('Fourier Transform of Cosine Signal')
subplot(2,1,2)
plot(w,abs(xnw))
xlabel('\omega (radian)')
ylabel('F(cos(4\pi n Ts))')
title('Fourier Transform of Digital Cosine Signal')
When MCode-7.10 is run, we get the graph in Figure-7.5.

Figure-7.5
In Figure-7.5, the upper graph is the Fourier transform graph 
of the continuous time cosine signal and the lower one is 
the Fourier transform graph of the digital cosine signal.
The upper graph contains two impulses with amplitude of 1, 
and these impulses are centered at the frequencies "4n 
and + 4n.
In the lower graph, the first two impulses around zero are
centered at the frequencies s and s and their
1/T 
amplitutes are multiplied by , and the other impulses 
are placed in a periodic manner with periodicity of 2n.

Example-7.3: Consider a cosine signal with frequency of 
defi defined on the interval ° -t - 2. Sample this signal 
with three different sampling periods 
, s ,
T = 1 /32 
s ' and obtain three different digital signals.
Calculate the Fourier transform of three digital signals 
separately and plot them on the same graph.
Solution-7.3: Let's generate the first digital signal with 
T = 1 /8
sampling period s z using MCode-7.11.
MCode-7.11 
clc; clear all; close all; 
t=0:1/1000:2; 
f=i;
Ts1=1/8;
ts1=0:Ts1:2;
n1=ts1./Ts1;
xn1=cos(2*pi*f*ts1);
For the other sampling periods, we generate the digital 
signals using MCode-7.12.
MCode-7.12
clc;clear all;close all;
t=0:1/1000:2;
f=1;
Ts1=1/8;
ts1=0:Ts1:2;
n1=ts1./Ts1;
xn1=cos(2*pi*f*ts1);
Ts2=1/16;
ts2=0:Ts2:2;
n2=ts2./Ts2;
xn2=cos(2*pi*f*ts2);
Ts3=1/32;

ts3=0:Ts3:2;
n3=ts3./Ts3;
xn3=cos(2*pi*f*ts3);
We can plot the generated signals using MCode-7.13.
MCode-7.13
figure(1)
subplot(3,1,1)
stem(ts1,xn1,'r-.','filled')
xlabel('ts(sec)') 
ylabel('cos(2\pi n Ts)') 
title('Ts=1/8 Digital Cosine Signal')
subplot(3,1,2)
stem(ts2,xn2,'g-.','filled') 
xlabel('ts(sec)') 
ylabel('cos(2\pi n Ts)') 
title('Ts=1/16 Digital Cosine Signal')
subplot(3,1,3)
stem(ts3,xn3,'b-.','filled') 
xlabel('ts(sec)') 
ylabel('cos(2\pi n Ts)') 
title('Ts=1/32 Digital Cosine Signal')
When all the written codes are assembled and run we get 
the graphs in Figure-7.6.

Figure-7.6
In Figure-7.6, the digital signal is drawn with respect to ts 
instead of 11. We can easily calculate the number of samples 
taken from the continuous time signal in one second. Since 
the frequency of cosine signal is lHz, for ^eQ eight 
samples are taken from one period of the signal. Similarly, 
1/T
for other sampling periods in one second, samples are 
taken from the continuous time signal. This is clearly seen in 
Figure-7.6.
Now let's calculate the Fourier transforms of the digital 
signals. For this purpose, let's first define the angular 
frequency vector from " 8n to 8n as in MCode-7.14
MCode-7.14

w=linspace(-8*pi,8*pi,length(t));
The digital signals in MCode-7.12 are indicated by xn^, X112 
ve xn3, the Fourier transforms of these signals will be 
denoted by XNW1, XNW2, XNW3.
Fourier transform calculations will be performed inside a for 
loop. To increase the speed of calculations inside the for- 
loop we pre-allocate memory for vectors as in MCode-7.15.
MCode-7.15
w=linspace(-8*pi,8*pi,length(t));
XNW1=zeros(length(t));
XNW2=zeros(length(t));
XNW3=zeros(length(t));
The Fourier transform calculations can be performed as in 
MCode-7.16.
MCode-7.16
w=linspace(-8*pi,8*pi,length(t));
XNW1=zeros(length(t));
XNW2=zeros(length(t));
XNW3=zeros(length(t));
for i=1:length(t)
XNW1(i)=sum(xn1.* exp(-j.* w(i)* n1));
XNW2(i)=sum(xn2.* exp(-j.* w(i)* n2));
XNW3(i)=sum(xn3.* exp(-j.* w(i)* n3));
end
Finally, the magnitude of the Fourier transforms are 
displayed using MCode-7.17.
MCode-7.17
figure(2) 
subplot(3,1,1) 

plot(w,abs(XNW1),'r') 
xlabel('\omega (radian))') 
ylabel('FT(cos(2\pi n Ts))') 
title('Ts=1/8, Digital Cosine Signal')
subplot(3,1,2)
plot(w,abs(XNW2),'g')
xlabel('\omega (radian))') 
ylabel('FT(cos(2\pi n Ts))') 
title('Ts=1/16, Digital Cosine Signal')
subplot(3,1,3)
plot(w,abs(XNW3),'b')
xlabel('\omega (radian))')
ylabel('FT(cos(2\pi n Ts))')
title('Ts=1/32, Digital Cosine Signal')
When MCode-7.17 is run, we get the graphs in Figure-7.7.

Figure-7.7
When the graphs in Figure-7.7 are inspected we see that all 
the signals are periodic with period 2n, and for Ts “ ^°, the 
impulses around the origin are placed to the frequencies 
+ w x Ts and ■ w x Ts which corresponds to + ^n/8 and 
- 2n/8
T _ 1/16
Similarly, for 
, the impulses around the origin are
placed to the frequencies + 2n/16 and - 2n/16, and for 
, the impulses around the origin are placed to the 
frequencies + 2n/32 and - 2n/32.

Chapter-8
Defining Signals in MATLAB and Inverse Fourier 
Transform
Abstract: In this chapter, we will explain how to obtain the 
inverse Fourier transform of signals using MATLAB.
8.1 Defining Signals in MATLAB
We can implement a signal defined for a specific time 
interval in MATLAB. Let's examine the subject with an 
example.
Example-8.1: Consider a triangle signal is defined in 
frequency domain such that the signal takes nonzero values 
for angular frequency values in the range t" 
+
. The signal gets its peak value of 1 at w = 0. Implement the 
triangle signal in MATLAB.
Solution-8.1: Let's first define the frequency values for 
which the signal takes nonzero values, and initialize the 
signal vector to all zero vector as in MCode-8.1.
MCode-8.1 
clc;clear all;close all;
w=-10*pi:pi/10:10*pi;
xcw=zeros(1,length(w));

Using the given information, we can first implement the 
signal portion for frequency values in the range t
as in MCode-8.2.
MCode-8.2
clc;clear all;close all;
w=-10*pi:pi/10:10*pi;
xcw=zeros(1,length(w));
for i=1:length(w)
if -10*pi<=w(i) && w(i)<0
The left side of the triangle for " 10 n <_ w < ° is a linear 
line with slope n/10. Considering this we can implement the 
left side of the triangle as in MCode-8.3.
MCode-8.3 
clc;clear all;close all;
w=-10*pi:pi/10:10*pi; 
xcw=zeros(1,length(w));
for i=1:length(w)
if -10*pi<=w(i) && w(i)<0 
xcw(i)=w(i)/(10*pi)+1;
The left side of the triangle crosses the vertical axis at point 
(0,1). We can implement the crossing point as in MCode-8.4.
MCode-8.4
clc;clear all;close all;
w=-10*pi:pi/10:10*pi;
xcw=zeros(1,length(w));
for i=1:length(w)
if -10*pi<=w(i) && w(i)<0 
xcw(i)=w(i)/(10*pi)+1;
elseif w(i)==0
xcw(i)=1;

The right side of the triangle is defined for frequency values 
in the range [O-lOn]. Considering the general equation 
y = ax + b of a linear line, we can implement the right side 
of the triangle as in MCode-8.5 after the second elseif 
statement.
MCode-8.5 
clc;clear all;close all; 
w=-10*pi:pi/10:10*pi; 
xcw=zeros(1,length(w));
for i=1:length(w)
if -10*pi<=w(i) && w(i)<0 
xcw(i)=w(i)/(10*pi)+1;
elseif w(i)==0 
xcw(i)=1;
elseif 0<w(i) && w(i)<=10*pi 
xcw(i)=-(w(i)/(10*pi))+1;
Outside the frequency interval t" 10n 
+ 10n], the
triangle signal has zero value, and this is implemented in 
MCode-8.6 after 'else' statement.
MCode-8.6
for i = 1:length(w)
if -10*pi<=w(i) && w(i)<0 
xcw(i)=w(i)/(10*pi)+1;
elseif w(i)==0 
xcw(i)=1;
elseif 0<w(i) && w(i)<=10*pi 
xcw(i)=-(w(i)/(10*pi))+1;
else
xcw(i)=0;
end 
end

Finally, we add the plot commands to the MCode-8.6 to see 
the graphical results and obtain MCode-8.7.
MCode-8.7
clc;clear all;close all;
w=-10*pi:pi/10:10*pi;
xcw=zeros(1,length(w));
for i=1:length(w)
if -10*pi<=w(i) && w(i)<0 
xcw(i)=w(i)/(10*pi)+1;
elseif w(i)==0
xcw(i)=1;
elseif 0<w(i) && w(i)<=10*pi 
xcw(i)=-(w(i)/(10*pi))+1;
else
xcw(i)=0;
end
end
plot(w,xcw)
xlabel('\omega(radian)') 
ylabel('x_c(\omega)') 
title('x_c(\omega)')
When the MCode-8.7 is run, we get the graph in Figure-8.1.

Figure-8.1
8.2 Inverse Fourier Transform
Example-8.2: Write a MATLAB program to calculate the 
inverse Fourier transform of 
example.
Solution-8.2:
Let's first define the time vector, and for this purpose we 
use ‘linspace' command as in MCode-8.x. After defining the 
time vector we initialize the X):-^ using ‘zeros’ command
defined in the previous
MCode-8.8
t=linspace(-1,1,length(w));
xct=zeros(1,length(t));
The inverse Fourier transform is calculated using

00
x (t) = — f x (w)e ■ jwtdw 
c 2nJ . m c
(8.
1)
which can be implemented using traPz command as in 
MCode-8.9.
MCode-8.9
t=linspace(-1,1,length(w));
xct=zeros(1,length(t));
for i=1:length(w)
xct(i)=1/(2*pi).
* trapz(w,(Xcw.* exp(j.* t(i).
* w))); 
end
To draw the graphs we use the ‘subplot’ commands as in 
MCode-8.10.
MCode-8.10
t=linspace(-1,1,length(w));
xct=zeros(1,length(t));
for i=1:length(w)
xct(i)=1/(2*pi).
* trapz(w,(xcw.* exp(j.* t(i).
* w)));
end
subplot(2,1,2)
plot(t,abs(xct))
xlabel('ts(sec)')
ylabel('X_c(t)')
title('Inverse Fourier Transform of X_c(\omega)')
Combining MCode-8.9 and MCode-10, we get MCode-11.
MCode-8.11
clc;clear all;close all;
w=-10*pi:pi/10:10*pi;
xcw=zeros(1,length(w));
for i=1:length(w)

if -10*pi<=w(i) && w(i)<0 
xcw(i)=w(i)/(10*pi)+1;
elseif w(i)==0
xcw(i)=1;
elseif 0<w(i) && w(i)<=10*pi 
xcw(i)=-(w(i)/(10*pi))+1;
else
xcw(i)=0;
end 
end
subplot(2,1,1) 
plot(w,xcw)
xlabel('\omega (radian)')
ylabel('x_c(\omega)')
title('x_c(\omega) defined on [-10\pi ... 10\pi] ')
t=linspace(-1,1,length(w));
xct=zeros(1,length(t));
for i=1:length(w)
xct(i)=1/(2*pi).
* trapz(w,(xcw.* exp(j.* t(i).
* w))); 
end
subplot(2,1,2) 
plot(t,abs(xct)) 
xlabel('ts(sec)') 
ylabel('X_c(t)') 
title('Inverse Fourier Transform of x_c(\omega)')
When MCode-8.11 is run, we get the graphs in Figure-8.2.

When Figure-8.2 is inspected, it is seen that the inverse 
Fourier transform of the triangle signal in frequency domain 
results in a signal which is similar to the S111C function but it 
has no negative values.
It is know that convolution of two square signals results in a 
triangle signal, and we know that Fourier or inverse Fourier 
transforms of square signals give the sinc() function.
Convolution in a domain corresponds to the multiplication in 
the counter domain. That is, if two signals are multiplied in 
time domain, the Fourier transform of the resulting signal is 
the convolution of the Fourier transforms of the individual 
time domain signals.

If triangle signal is obtained by convolving two time domain 
square signals, the inverse Fourier transform of the triangle 
signal equals to the multiplication of the inverse Fourier 
transform of two square signals, and we know that inverse 
Fourier transform of a square signal is a sinc function. Then, 
. 
2
the inverse Fourier transform of a triangle signal is a sinc 
function. That is why we do not have negative parts in 
Figure-8.2.
Example-8.3: Draw the graph of smc(t) function writing a 
MATLAB program. Calculate and draw the Fourier transform 
of the sinc(t) function. Take the square of the smc(t) 
function, calculate its Fourier transform and draw it.
Solution-8.3: We can draw the graph of smc(t) function as 
in MCode-8.12.
MCode-8.12
clc;clear all;close all; 
t=-5:1/100:5;
xct=sinc(t);
subplot(2,2,1) 
plot(t,xct) 
xlabel('t(sec)') 
ylabel('sinc(t)') 
title('sinc() Function')
When MCode-8.12 is run, we get the graph in Figure-8.3.

Figure-8.3
We can calculate the Fourier transform of the sinc function 
using 'traPz’ command as in MCode-8.13.
MCode-8.13 
clc;clear all;close all;
t=-5:1/100:5;
xct=sinc(t);
subplot(2,2,1) 
plot(t,xct) 
xlabel('t(sec)') 
ylabel('sinc(t)') 
titie('sinc(t) Function') 
w=linspace(-5*pi,5*pi,length(t)); 
for i = 1:length(w)
xcw( i)=trapz(t,xct.* exp(-j*w( i).
* t));
end
subplot(2,2,2) 
plot(w,abs(xcw)) 
xlabel('\omega(radian)') 
ylabel('FT[sinc(t)]') 
title('Rectangle Signal')
When MCode-8.13 is run, we get the graphs in Figure-8.4.

Figure-8.4
Now, let's calculate the Fourier transform of the square of 
the smc(t) function. For this purpose, we write MCode-8.14.
MCode-8.14
xct2=xct.~2;
subpiot(2,2,3) 
piot(t,xct) 
xlabel('t(sec)') 
yiabei('(sinc(t))~2')
titie('sinc~2(t) Function')
When the MCode-8.13 and MCode-8.14 are combined and 
run, we get the graphs in Figure-8.5.

Figure-8.5
• 
2
Finally, we can calculate the Fourier transform of smc ft) as 
in MCode-8.15.
MCode-8.15
for i = 1:length(w)
xcw2(i)=trapz(t,xct2.* exp(-j*w(i).
* t)); 
end
subplot(2,2,4)
plot(w,abs(xcw2))
xlabel('\omega (radian)') 
ylabel('FT[sinc~2(t)]') 
title('Triangle Signal')
When the MCode-8.13, 8.14, 8.15 are combined and run, we 
get the graphs in Figure-8.6.

Figure-8.6
Considering Figure-8.6, we can summarize the results as
FT{sinc( • )} = rectangle
FT{sinc2( • )} = triangle
and
FT{sinc( • )sinc( ■ )} = FT{sinc( ■ )} * FT{sinc( • )}
• 
2
Example-8.4: Perform sampling operation on sinc ft) with
T =1/5
sampling period 
and calculate and draw the
= rectangle * rectangle
= triangle

Fourier transform of the digital signal obtained from 
sampling operation.
Solution-8.4: Let's first calculate the Fourier transform of 
• 2
smc (t) and drawn it as in MCode-8.16.
MCode-8.16
clc;clear all;close all;
t=-5:1/100:5;
xct=(sinc(t)).~2;
subplot(2,2,1)
plot(t,xct)
xlabel('t(sec)')
yiabei('sinc~2(t)')
titie('sinc~2(t) Function')
w=linspace(-10*pi,10*pi,length(t));
for i=1:length(t)
xcw(i)=trapz(t,xct.* exp(-j*w(i).
* t));
end
subplot(2,2,2)
plot(w,abs(xcw))
xlabel('\omega (radian)')
yiabei(,FT[sinc^2(t)]')
title('Triangle Signal')
When MCode-8.16 is run, we get the graphs in Figure-8.7.

Figure-8.7
• 
2( A
In the second step, we sample the smc ' ' signal with
T = 1/5
sampling period s , and calculate the Fourier 
transform of the digital signal using MCode-8.17.
MCode-8.17
Ts=1/5;
ts=-5:Ts:5;
n=ts./Ts;
xn=(sinc(ts)).~2;
subplot(2,2,3)
stem(ts,xn)
xlabel('ts(sec)')
ylabel('sinc~2(n)')
title('sinc^2(n) Fonksiyonu')
for i=1:length(w)
xsw(i)=sum(xn.* exp(-j.* w(i).
* n));
end
subplot(2,2,4)
plot(w,abs(xsw))
xlabel('\omega (radian)')
ylabel('FT[sinc~2(n)]')
title('Periodic Triangle Signal')

When MCode-8.17 is run, we get the graphs in Figure-8.8.
Figure-8.8
When the Fourier transforms of sinc 0 and digital sinc 0 
signals are inspected, we see that the Fourier transform of 
the digital signal is periodic with period 2n and the 
amplitudes of the Fourier transform of the digital signal are 
obtained by dividing the amplitude of the Fourier transform 
T 
of the continuous time signal by s.
And the frequency axis of the digital Fourier transform can 
be obtained by multiplying the frequency axis of the
T
continuous Fourier transform by .

I
* 
2
. , , 5 x s^nc (5t)
■ 
' 
«- i- ~ T = 1/16 T = 1/8
using different sampling periods s ,s , 
T = 1/4 T = 1/2
, 
, and calculate the Fourier transforms of
the digital signals separately, and inspect the overlapping 
case on the Fourier transform graphs.
In MCode-8.18, we sample the continuous time signal with 
different sampling periods and calculate the Fourier 
transforms of the digital signals and plot them
MCode-8.18
clc; clear all; close all;
t=-5:1/100:5;
Tsarr=[1/16 1/8 1/4 1/2];
w=linspace(-10*pi,10*pi,length(t));
for Ts=1:length(Tsarr) 
xsw=zeros(1,length(w));
ts=-5:Tsarr(Ts):5;
n=ts./Tsarr(Ts);
xn=zeros(1,length(n)); 
xn=5*(( sinc(5*ts)).^2);
for i=1:length(w)
xsw(i)=sum(xn.* exp(-j.* w(i).
* n));
end
subplot(2,2,Ts)
plot(w,abs(xsw),'b')
xlabel('\omega (radian)')
ylabel('F[5
*Sinc~2(5t=5nTs)]'
)
title(['Ts=' num2str(Tsarr(Ts)) ', FT[5
*Sinc^2(5Ts)]'
]) 
end
When MCode-8.18 is run, we get the graphs in Figure-8.9.

Figure-8.9
When the graphs in Figure-8.9 are inspected we see that for 
sampling periods greater than or equal to aliasing, i.e., 
spectral overlapping, occurs, and due to spectral 
overlapping in graphs 2, 3 and 4 vertical axis starts from 3, 
4.8 which indicates overlapping problem.

Chapter-9
Downsampling
Abstract: In this chapter, we will explain the downsampling 
operation and introduce the decimation filter and explain its 
use.
9.1 Downsampling Operation
Downsampling is used to decrease the sample number in a 
digital signal. Let xtn] be the digital signal to be 
downsamples. To perform downsampling on xtn] by M we 
divide the signal xtnl into subsequences each one having M 
elements, then from every group with M elements, only the 
first one is taken the the others are eliminated. In this way, 
we form another sequence indicated by y[nL and the 
relationship between xtnl and vt11! is shown by 
y[n] = x[Mn]
Example-9.1: xtnl digital sequence ids given as
x[n] = [1 2ab34cd56ef7 8]
obtain x^ul for M = 2 and M = 3.
Solution-9.1: First let's define the digital signal as in 
MCode-9.1.
MCode-9.1
clc; clear all;close all; 
syms a b c d e f;

xn=[1 2 a b 3 4 c d 5 6 e f 7 8 ];
Next, we define downsampling factors, i.e., compression 
parameter, for M = 2 and M = 3 as in MCode-9.2 and we 
initialize the indexes i and j to 1.
MCode-9.2 
clc; clear all;close all;
syms a b c d e f;
x=[1 2 a b 3 4 c d 5 6 e f 7 8 ];
M1=2;
M2=3;
i=1;
j=1;
The downsampling operation is performed using two for 
loops as in MCode-9.3 where y1 and y2 are the 
downsampled digital sequences.
MCode-9.3
clc; clear all;close all;
syms a b c d e f;
x=[1 2 a b 3 4 c d 5 6 e f 7 8 ];
M1=2; M2=3; i=1; j=1;
for indeks=1:M1:length(x) 
y1(i)=x(indeks);
i=i+1;
end
for indeks=1:M2:length(x)
y2(j)=x(indeks);
j=j+1; 
end 
y1 
y2
When MCode-9.3 is run, we get the outputs in Figure-9.1.

Command Window
yl =
[ UIg 5, e. 7]
y2 =
[ Lb,c,6, 7]|
Figure-9.1
9.2 Sampling of Digital Signals
Downsampling can be considered digital signal sampling. 
Since, we select some of the samples from digital signal and 
discard the others, and this process is also a sampling 
process.
Example-9.2: Obtain a digital signal by performing 
sampling operation on smc signal with sampling period 
Ts - 1/6. Downsample the digital signal using M = 2, 
M = 3, M=4, M = 5, and M = 6.
Check whether downsampling creates spectral overlapping 
problem for the given M values.
Solution-9.2: The downsampling degree, i.e., M, and time 
and frequency vectors are defined in MCode-9.4.
MCode-9.4 

clc;clear all; close all;
t=-10:1/100:10;
w=linspace(-10*pi,10*pi,length(t));
Mvec=[1 2 3 4 5 6];
In MCode-9.4, M - 1 corresponds to the original signal, 
since, =x[Mn]. The sampling period is ^^. For 
M = 2, the downsampling operation equals to the sampling 
operation with sampling period 
, since
x[n] = xc(nTs)-»x[Mn] = xc(nMTs)
Then, downsampling operation can also be achieved during 
the sampling operation by changing the sampling period, 
■ 
MTC . . 
. fT
i.e., we use s instead of .
We use for-loop for the creating of sinc() function in MCode- 
9.9 where other parameters are also defined.
MCode-9.5
for i = 1:length(Mvec)
yn=zeros(1);
Ts=Mvec(i)*(
1/6);
ts=-10:Ts:10;
n=ts./Ts;
yn=(sinc(ts)).~2;
We add the sampling operation parts to the MCode-9.5 and 
obtain MCode-9.6.
MCode-9.6
for i = 1:length(Mvec)
yn=zeros(1);
Ts=Mvec(i)*(
1/6);
ts=-10:Ts:10;
n=ts./Ts;

yn=(sinc(ts)).~2;
figured)
subplot(3,2,i)
stem(ts,yn,'b','filled')
xlabel('ts(sec)')
ylabel('sinc~2(M
*ts)'
)
title(['M = ' num2str(Mvec(i)) ', sinc^2(ts)'])
end
When MCode-9.4, 9.5 and 9.6 are combined and run we get 
the graphs in Figure-9.2.
Figure-9.2

Now, we will add Fourier transformation parts to the MCode- 
9.6. We first define the xsw vector and write the Fourier 
transform calculation part as in MCode-9.7.
MCode-9.7
xsw=zeros(1,length(w));
for k=1:length(w)
xsw(k)=sum(yn.* exp(-j.* w(k).
*
n));
end
Lastly, we can add the graphic commands as in MCode-9.8 
to draw the downsampled signals.
MCode-9.8
xsw=zeros(1,length(w));
for k=1:length(w)
xsw(k)=sum(yn.* exp(-j.* w(k).
* n));
end
figure(2)
subpiot(3,2,i) 
piot(w,abs(xsw)) 
xlabel('\omega (radian)') 
yiabei(,FT[sinc^2(M
*ts)]'
)
title(['M = ' num2str(Mvec(i)) ', FT[sinc^2(M
*ts)]
 ']) 
end
The entire program is given in MCode-9.9.
MCode-9.9
clc;clear all; close all;
t=-10:1/100:10;
w=iinspace(-10*pi,10*pi,length(t));
Mvec=[1 2 3 4 5 6];
for i = 1:length(Mvec)
yn=zeros(1);
Ts=Mvec(i)*(
1/6);

ts=-10:Ts:10;
n=ts./Ts;
yn=(sinc(ts)).~2;
figured)
subplot(3,2,i)
stem(ts,yn,'b','filled')
xlabel('ts(sec)')
ylabel('sinc~2(M
*ts)'
)
title(['M = ' num2str(Mvec(i)) ', sinc^2(ts)'])
xsw=zeros(1,length(w));
for k=1:length(w)
xsw(k)=sum(yn.* exp(-j.* w(k).
* n));
end
figure(2)
subplot(3,2,i)
plot(w,abs(xsw),'b')
xlabel('\omega (radian)')
ylabel('FT[sinc~2(M
*ts)]'
)
title(['M = ' num2str(Mvec(i)) ', FT[sinc^2(M
*ts)]
 ']) 
end
When MCode-9.9 is run we get the graphs in Figure- 
9.3.

Figure-9.3
When the graphs in Figure-9.3 are inspected it is seen that 
for M - 4 spectral overlapping occurs, and when M = 6 
digital signal does not carry any information about the 
continuous time signal.

9.3 The Relationship between 
Downsampled Signal and Digital 
Signal
Let yM be the digital signal obtained from xln] via 
dowwnsampling, that is
y[n] = x[Mn]
The relationship between the Fourier transforms of x[n] and 
yM is given as
(9.
1)
* 
2
Example-9.3: Let x,..(t) = sinc'(t) and x[n] = x,:(nTs» where 
T*  ~ we downsample xlnl for M = 2 and M = 4 and 
obtained two new doensampled digital sequences. Calculate 
the Fourier transforms of all the digital signals
Solution-9.3: Let's first obtain the digital signal x[n3 as in 
MCode-9.10.
MCode-9.10
clc;clear all; close all;
t=-5:1/100:5;
Ts=1/6;
ts=-5:Ts:5;
n=ts./Ts;
xn=(sinc(ts)).~2;
In the next step we calculate the Fourier transform of the 
digital signal xfn] using a for-loop as in MCode-9.11.

MCode-9.11 
clc;clear all; close all;
t=-5:1/100:5;
Ts=1/6;
ts=-5:Ts:5;
n=ts./Ts;
xn=(sinc(ts)).~2;
w=linspace(-10*pi,10*pi,length(t));
xnw=zeros(1,length(w));
for i = 1:length(w)
xnw(i)=sum(xn.* exp(-j.* w(i).
* n));
end
We plot the calculated Fourier transform using MCode-9.12.
MCode-9.12
figured)
plot(w,abs(xnw),'b')
xlabel('\omega(radian)')
ylabel('FT[sinc~2(ts)]')
title('Fourier Transform of sinc^2(nTs)')
When MCode-9.10, 9.11 and 9.12 are combined and run, we 
get the graph in Figure-9.4.

Figure-9.4
Now let's calculate the Fourier transform of Y^11] = x[2n]. For 
this purpose, we first multiply the amplitudes of Fourier 
transform of xtn], i.e., xnw, by 1//M, then multiply the 
frequency values of xnw by M and shift to the right by 2n 
and plot them on the same figure as in MCode-9.13.
MCode-9.13
M1=2;
figure(2)
plot(M1*w,abs(xnw)/M1) 
hold on
plot(M1*w-2*pi,abs(xnw)/M1)

xlabel('\omega(radian)')
ylabel('FT[sinc~2(ts)]')
title('Fourier Transform of sinc^2(nMTs), M = 2')
When the MCode-9.10, 9.11, 9.12 and 9.13 are combined, 
we get the complete program as in MCode-9.14.
MCode-9.14
clc; clear all; close all;
t=-5:1/100:5;
Ts=1/6;
ts=-5:Ts:5;
n=ts./Ts;
xn=(sinc(ts)).~2;
w=linspace(-10*pi,10*pi,length(t));
xnw=zeros(1,length(w));
for i = 1:length(w)
xnw(i)=sum(xn.* exp(-j.* w(i).
*
n));
end
figure(1)
plot(w,abs(xnw),'b')
xlabel('\omega(radian)')
ylabel('FT[sinc~2(ts)]')
title('Fourier Transform of sinc^2(nTs)')
M1=2;
figure(2)
plot(M1*w,abs(xnw)/M1)

hold on
plot(M1*w-2*pi,abs(xnw)/M1) 
xlabel('\omega(radian)') 
ylabel('FT[sinc~2(ts)]')
title('Fourier Transform of sinc^2(nMTs), M = 2')
When the MCode-9.14 is run, we get the graph in Figure-9.5.
Fourier Transform of sine (nMTs), M=2
■80 
-60 
-40 
-20 
0 
20 
40 
60 
80
^'(radian)
Figure-9.5
Now, let's repeat the previous procedure for M = 4. In 
formula (9.1), the shifting operation is performed for 
k = 0...M-l. For this purpose, we write a for-loop as in 
MCode-9.15.
MCode-9.15

M=4;
figure(3)
for k=0:M-1;
plot(M*w-2*pi*k,abs(xnw)/M)
hold on
end
xlabel('\omega(radian)')
ylabel('FT[sinc^2(ts)]')
title('Fourier Transform of sinc^2(nMTs), M=4')
xlim([-10*pi 10*pi])
When the MCode-9.15 is run, we get the graph in Figure-9.6.
[(Sl)7OUIS]ld
Figure-9.6

9.4 Decimation Filter and 
Downsampling
In downsampling operation, as M increases spectral 
overlapping occurs due to insufficient information of the 
analog signal in the digital signal. We cannot prevent 
aliasing, i.e., spectral overlapping for large M values, 
however, we can decrease the amount of overlapping using 
decimation filters. Using decimation filters we increase the 
quality of the digital signal which contains insufficient 
information about the analog signal. Decimation filters are 
used before downsampling operation. The decimation filter 
is defined as
(9.
2)
and its time domain version can be calculated using inverse 
Fourier transform as
(9.
3)
• 
2
Example-9.4: Perform sampling operation on smc with 
sampling period 
and obtain the digital signal xtnl.
Downsample with M = 4 and pass the downsamped 
signal through the decimation filter, inspect the signals in 
spectral domain.

• 
2
Solution-9.4: We first define the signal sinc then 
sample it and calculate the Fourier transform of the digital 
signal as in MCode-9.16.
MCode-9.16 
clc;clear all; close all; 
t=-10:1/100:10;
w=linspace(-10*pi,10*pi,length(t));
Ts=1/6;
ts=-10:Ts:10;
n=ts./Ts;
xn=(sinc(ts)).~2;
M=4;
xsw=zeros(1,length(w));
for k=1:length(w)
xsw(k)=sum(xn.* exp(-j.* w(k).
* n));
end
For this example, we will obtain a total of 6 graphs. We use 
the subplot command to plot the graphs in three rows and 
two columns and place the Fourier transform of the signal 
we obtained in MCode-9.x in the first drawing section. For 
this, add the lines in MCode-9.17.
MCode-9.17
figure(1)
subplot(3,2,1)
plot(w,abs(xsw))
xlabel('\omega(radian)')
ylabel('FT[sinc^2(ts)]')

title('FT of sinc~2(nTs)')
Now, let's draw the Fourier transform of the downsampled 
signal with M = 4 as in MCode-9.18.
MCode-9.18
subplot(3,2,2) 
for k=0:M-1;
plot(M*w-2*pi*k,abs(xsw)/M) 
hold on
end
xlabel('\omega(radian)')
ylabel('FT[sinc~2(ts)]')
title('FT of sinc^2(nTs) downsampled with M=4') 
xlim([-pi pi])
When MCode-9.16, 9.17, 9.18 are combined and run, we get 
the graphs in Figure-9.7
Figure-9.7

When the right graph in Figure-9.7 is inspected we see that 
spectral overlapping occurs in the Fourier transform of the 
downsampled signal. The amount of overlapping shows the 
amount of missing information that the digital signal lacks 
about the continuous time signal it represents. To decrease 
the amount of overlapping let's define the decimation filter 
and plot it in time domain as in MCode-9.19.
MCode-9.19
hdn=(1/M)* sinc(n./M);
subplot(3,2,3)
stem(n,hdn)
xlabel('n(integer)')
ylabel('1/M sinc(n)]')
title('Decimation Filter in n Domain')
In MCode-9.20, the Fourier transform of the decimation filter 
is calculated and plotted.
MCode-9.20
hdw=zeros(1,length(w));
for h=1:length(w)
hdw(h)=sum(hdn.* exp(-j.* w(h).* n));
end
subplot(3,2,4)
plot(w,abs(hdw))
xlabel('\omega(radian)')
ylabel('FT[1/M sinc(n)]]') 
title('Decimation Filter in Spectral Domain') 
xlim ([-pi pi])
When MCode-9.16, 9.17, 9.18, 9.19, 9.20 are combined and 
run, we get the graphs in Figure-9.8.

Figure-9.8
It is seen from the fourth graph of Figure-9.8 that the digital 
decimation filter has almost a flat spectrum for 
-n/M < w < n/M and it has zero value outside this interval. 
Note that the Fourier transform of digital signals are periodic 
functions with periodicity of 2n.
To see the periodicity of the Fourier transform of the 
decimation filter we can change the limits of the horizontal 
axis using 
xlim([-10
*pi
 10
*pi])
We can now use decimation filter before downsampling 
operation. Filtering in spectral domain corresponds to the 
multiplication of the Fourier transform of the information 
bearing signal and Fourier transform of the filter. In our 

case, the information bearing signal is s^nc ^nTs\ We 
perform filtering operation as in MCode-9.21.
MCode-9.21
Hdxw=hdw.* xsw;
subplot(3,2,5) 
plot(w,abs(Hdxw)) 
xlabel('\omega(radian)') 
ylabel('H_d_n(\omega).X_n(\omega)') 
title('Filtered Signal in Spectral Domain') 
xlim([-3*pi 3*pi]) 
After filtering operation dowsampling is performed and 
Fourier transform of the downsampled signal can be drawn 
as in MCode-9.22.
MCode-9.22
subplot(3,2,6) 
for k=0:M-1;
plot(M*w-2*pi*k,abs(Hdxw)/M) 
hold on
end
xlabel('\omega(radian)')
ylabel('M=4, H_d_n(\omega).X_n(\omega)') 
title('sinc^2(nTs), filtered and downsampled with 
M=4')
xlim([-10*pi 10*pi])
When MCodes-9.16-9.22 are combined, we get the entire 
code as in MCode-9.23.
MCode-9.23 
clc;clear all; close all;
t=-10:1/100:10;

w=linspace(-10*pi,10*pi,length(t));
Ts=1/6;
ts=-10:Ts:10;
n=ts./Ts;
xn=(sinc(ts)).~2;
M=4;
xsw=zeros(1,length(w));
for k=1:length(w)
xsw(k)=sum(xn.* exp(-j.* w(k).
* n)); 
end
figured) 
subplot(3,2,1) 
plot(w,abs(xsw))
xlabel('\omega(radian)') 
ylabel('FT[sinc^2(ts)]') 
title('FT of sinc~2(nTs)')
subplot(3,2,2)
for k=0:M-1;
plot(M*w-2*pi*k,abs(xsw)/M) 
hold on
end
xlabel('\omega(radian)') 
ylabel('FT[sinc~2(ts)]') 
title('FT of sinc^2(nTs) downsampled with M=4')

xlim([-10*pi 10*pi])
hdn=(1/M)* sinc(n./M);
subplot(3,2,3)
stem(n,hdn)
xlabel('n(integer)')
ylabel('1/M sinc(n)]')
title('Decimation Filter in n Domain')
hdw=zeros(1,length(w));
for h=1:length(w)
hdw(h)=sum(hdn.* exp(-j.* w(h).
* n));
end
subplot(3,2,4)
plot(w,abs(hdw))
xlabel('\omega(radian)')
ylabel('FT[1/M sinc(n)]]') 
title('Decimation Filter in Spectral Domain') 
xlim ([-pi pi])
Hdxw=hdw.* xsw;
subplot(3,2,5)
plot(w,abs(Hdxw))
xlabel('\omega(radian)')
ylabel('H_d_n(\omega).X_n(\omega)') 
title('Filtered Signal in Spectral Domain') 
xlim([-3*pi 3*pi])

subplot(3,2,6)
for k=0:M-1;
plot(M*w-2*pi*k,abs(Hdxw)/M) 
hold on 
end
xlabel('\omega(radian)')
ylabel('M=4, H_d_n(\omega).X_n(\omega)') 
title('FT of filtered and downsampled signal, M=4') 
xlim([-10*pi 10*pi]
When MCode-9.23 is run, we get the graphs in Figure-9.9.
Figure-9.9

The first graph in the second column of Figure-9.9 is the 
spectrum of downsampled digital signal.
The third graph in the second column of Figure-9.9 is the 
spectrum of filtered and downsampled digital signal. It is 
seen from these graphs that filtering operation before 
downsampling decreases distortion amount in the digital 
signal.

Chapter-10
Upsampling
Abstract: In this chapter we will cover upsampling and 
interpolation operations in MATLAB environment.
10.1 Upsampling
Sampling operation is performed on a continuous time 
signal to obtain a digital signal which contains the 
information of the continuous time signal. To decrease the 
overhead in digital transmission or storage we decrease the 
number of samples and this is called downsampling.
The continuous signal is reconstructed from its digital 
samples. If too many samples are eliminated in digital signal 
during downsampling operation, the reconstructed digital 
signal contains some distortion. As the number of 
eliminated samples increase, the distortion in the 
reconstructed signal increases as well. After a definite 
number of eliminated samples, the continuous time signal 
cannot be constructed.
In upsampling operation, we try to increase the number of 
samples in the downsampled digital signal before 
reconstruction operation. This is achieved in a two step 
process. In the first process, we increase the length of the 
donwsampled digital vector, and places of eliminated 
samples we put zero values. In the second step, we guess 
the eliminated samples and replace zeros by the estimated 
sample values, and in the final step reconstruction operation 
is performed.

The upsampling operation for xtn] is mathmematically 
described as
y[n] = x[n/L]
where L is a positive integer. In this operation, L - 1 zeros 
are inserted after each sample of xtnL
For example, for the given
x[n] = [a b c]
the sequence
rir
y[n] = x[-
Equals
y[n] = [aOOObOOOcOOO]
Example-10.1 : Given x[n] = [1 3 5 7 9 11 13 15 17 19 ] find
rir 
y[n] = x - 
■ ■
Solution-10.1: First define xtn] and L parameter as in 
MCode-10.1.
MCode-10.1
clc; clear all;close all;
x=[1 3 5 7 9 11 13 15 17 19];
L=2;
We define as in MCode-10.2.
MCode-10.2
clc; clear all;close all;
xn=[1 3 5 7 9 11 13 15 17 19];
L=2;
yn=zeros(1,L*( length(xn)-1) + 1);

rir 
y[n] = x ~ 
Each elements of 
L2J
each element of We can construct yfn] with a for-loop 
as in MCode-10.3.
contains a single zero after
MCode-10.3 
clc; clear all;close all;
xn=[1 3 5 7 9 11 13 15 17];
L=2;
yn=zeros(1,L*( length(xn)-1) + 1);
i = 1;
for indeks=1:length(xn);
yn(i)=xn(indeks);
i = i + L;
end 
yn
When MCode-10.x is run, we get the output in Figure-10.1.
Command Window 
®
yn = 
Columns 1 through 12
1030507090 
11 
0
Columns 13 through 17 
13 
0 
15 
0 
17
Figure-10.1
10.2 The Fourier Transform of 
Upsampled Signal

The time domain between upsampled signal and data signal 
is given as yt11] =x[n/L]. The Fourier transforms of these 
signals are related by
Yn(w) = Xn(Lw)
Example-10.2: Consider a cosine signal with frequency of 
1Hz. This signal is sampled using sampling period 16 and a 
digital signal is obtained. The digital signal is downsampled 
with M = 2, and then the downsampled signal is upsampled 
with L = 2. Inspect the Fourier transforms of downsampled 
and upsampled signals.
Solution-10.2: We first obtain time domain versions of the 
downsampled and upsampled signals as in MCode-10.4.
MCode-10.4 
clear all; close all; clc;
Ts=1/16;L=2;M = 2;
t=-1:1/100:1;
ts=-1:Ts:1;
n=ts./Ts;
xn=cos(2*pi*ts);
subplot(3,2,1) 
stem(ts,xn) 
xlabel('time (ts)') 
title('Digital Cosine Signal, Ts=16')
Ts2=2*Ts;
ts2=-1:Ts2:1;
n2=ts2./Ts2;
xdn=xn(1:M:length(xn));
subplot(3,2,3)
stem(ts2,xdn)
xlabel('time (ts)')
title('Downsampled Cosine Signal, M=2') 

yn(1:L:length(xn))=xdn;
subplot(3,2,5) 
stem(ts,yn) 
xlabel('time(ts)') 
title('Upsampling of Downsampled Signal, L=2')
We calculate and plot the Fourier transforms of digital 
cosine, dowwnsampled and upsampled signals in MCode- 
10.5.
MCode-10.5
w=linspace(-10*pi,10*pi,length(t));
xw=zeros(length(w));
xdw=zeros(length(w));
ynw=zeros(length(w));
for i = 1:length(w)
xw(i)=sum(xn.* exp(-1i.*w(i).
*
n));
ynw(i)=sum(yn.* exp(-1i.*w(i).
* n));
end
subplot(3,2,2) 
plot(w,abs(xw)) 
xlabel('\omega (radian)') 
title('Fourier Transform of Digital Cosine Signal')
for k=1:length(w)
xdw(k)=sum(xdn.* exp(-1i.*w(k).
* n2));
end
subplot(3,2,4) 
plot(w,abs(xdw)) 
xlabel('\omega(radian)') 
title('Fourier Transform of Downsampled Cosine 
Signal')
subplot(3,2,6) 
plot(w,abs(ynw)) 
xlabel('\omega(radian)')

title('Fourier Transform of Upsampled')
When MCode-10.4 and MCode-10.5 are combined and run, 
we get the graphs in Figure-10.2.
u..'i. radian)
Figure-10.2

10.3 Interpolation of Upsampled 
Signal
When a downsampled digital signal is upsampled, the 
length of the downsamples signal is increased and new 
samples, i.e., zeros, are placed between samples. This is 
called upsampling. In the next step the dummy values, i.e., 
zeros, are replaced by the estimated values of the samples 
omitted during the downsampling operation. This process is 
called interpolation.
If ytn] is the upsampled signal, then the interpolated signal 
vJnl ■ 
. 
__ । 
■ _
is obtained using
yjn] = hjn] * y[n] 
(10
where is called interpolation filter and it is defined as
hjn] = sinc(n/L)
The convolution expression in (10-D can be written as
00
yjn] = y[k]hj[n - k]
k =- oo
(10.
2)
Example-10.3: Consider a cosine signal with frequency of 
1Hz. This signal is sampled using sampling period 16 and a 
digital signal is obtained. The digital signal is downsampled 
with M = 2, and then the downsampled signal is upsampled 
with L = 2. The upsampled signal is interpolated using the

interpolation filter 
siiicCii/L) . obtain the intepoiated
signal.
Solution-10.3: In this example, we will plot 4 graphs, and 
for this we will use subplot(4,1,x) expression. First, we plot the 
digital cosine signal obtained from sampling operation as in 
MCode-10.6.
MCode-10.6 
clear all; close all; clc;
F=1;
Ts=1/16;
ts=-1:Ts:1;
n=ts./Ts;
xn=cos(2*pi*F*ts);
subplot(4,1,1) 
stem(n,xn) 
xlabel('n')
title('Digital Cosine Signal, Sampling Period = 16')
When MCode-10.6 is run, we get the graph in Figure-10.3.

Figure-10.3
We perform downsampling operation on the digital signal 
and plot its graph in MCode-10.7.
MCode-10.7
M=2;
Ts2 = M*Ts;
ts2=-1:Ts2:1;
n2=ts2./Ts2;
xdn=xn(1:M:length(xn));
subplot(4,1,2)
stem(n2,xdn)
xlabel('n')
title('Downsampled Digital Cosine Signal, M = 2')
When MCode-10.7 is run, we get the graph in Figure-10.4.

Figure-10.4
In MCode-10.8, the downsampled signal is upsampled and 
plotted.
MCode-10.8
L=2;
yn(1:L:length(xn))=xdn;
subplot(4,1,3) 
stem(yn) 
xlabel('n')
title('Upsampling of the Downsampled Signal, 
L=2')

When MCode-10.6, 10.7 and 10.8 are combined and run, we 
get the graphs in Figure-10.5.
Figure-10.5
When upsampling is performed zero values are inserted 
after the samples of downsampled signal The zero values 
correspond to the samples omitted from the original digital 
signal during the downsampling operation. The upsampled 
signal is passed through the sinc() filter to replace the zeros 
with the estimated values of the omitted samples. The 
filtering operation is performed using
yin=conv(yn,hin,'same');

where Vn is the upsampled signal and llin is the sinc() filter 
impulse response. The 'same' argument is used to obtain 
output signal which has the same length as the input signal. 
The interpolation operation is performed in MCode-10.9.
MCode-10.9
hin=sinc(n/L);
yin=conv(yn,hin,'same');
subplot(4,1,4)
stem(n,yin)
xlabel('n')
title('Reconstructed Digital Cosine Signal')
When MCode-10.6, 10.7, 10.8 and 10.9 are combined and 
run, we get the graphs in Figure-10.6.

we see that 
some little
Figure-10.6
When the graphs in Figure-10.6 are inspected 
the reconstructed digital cosine signal has 
amplitude differences from the original digital cosine signal, 
this is due to the short of 11 values. If bigger ranges are 
used, we get better reconstructed signals. The sinc() filter 
used in the reconstruction process is implemented and 
drawn in MCode-10.10.
MCode-10.10

figure
stem(n,hin) 
xlabel('n')
title('Dijital Sinc Filtre')
When MCode-10.10 is run, we get the graph in Figure-10.7.
Figure-10.7

Chapter-11
Rotation and Fourier Transform of Digital 
Signals
Abstract: In this chapter we will explain rotation of digital 
signals, and we will cover discrete Fourier transforms of 
digital signals.
11.1 Rotation of Digital Signals
Let's consider the digital signal
x[n] = [1 2 3 N- 2 N - 1 N ]
Rotation to the Right
When the digital signal is rotated to the right, we get
RR{x[n]} = [N-1 123N-2N-1]
Rotation to the Left
When the digital signal is rotated to the left, we get
RL{x[n]} = [2 3 N - 2 N - 1 N 1]
Rotation Inside
When the digital signal is rotated inside, we get
RI{x[n]} = [1 NN- 1 N- 2 3 2]
Example-11.1: Write a MATLAB program to rotate 
x[n] = [a b c d e f] to the right, to the left and inside.
Solution-11.1: The MATLAB program can be written as in 
MCode-11.1.

MCode-11.1
clc; clear all;
syms a b c d e f
x=[a b c d e f]
rrx=[x(length(x)) x(1:length(x)-1)]
rlx=[x(2:length(x)) x(1)]
rin=[x(1) x(length(x):-1:2)]
When MCode-11.1 is run, we get the outputs in Figure-11.1.
Command Window
x =
[ a, b, c, d, e, fj
rri =
[ f„ a, b, c, d, efl
ilx =
[ b, c, df e, f, a]
rin =
[ a, f, e, d, c, b]
Figure-11.1
11.2 Discrete Fourier Transform

Discrete Fourier transform, DFT, is used for finite length 
digital signals, i.e., not periodic signals such as digitalcosine 
signal. The DFT of finite length digital signal xtn] is 
calculated using
(11.
1)
The numbers X[k] can
also be called discrete Fourier
transform coefficients.
The inverse discrete Fourier transform is calculated using
(11.
2)
Calculation of the discrete Fourier transform coefficients is 
called signal analysis, and inverse discrete Fourier transform 
is called signal synthesis.
Example-11.2: 
Calculate the DFT of
x[n] =[2 3- 5667-10 2] using MATLAB.
Solution-11.2: First, let's define the finite length signal as 
in MCode-11.2.
MCode-11.2
clc;clear all;close all;
N=9;
x=[2 3 -5 6 6 7 -1 0 2];
When formula dll) is inspected, we see that we need 
two for loops, since the parameters 11 and k take values as
0 < n < N 0 < k < N
In MATLAB, index value of a vector starts from 1, for this 
reason we will use + D and x^n + D expressions in the 
loop. The DFT is calculated as in MCode-11.3.

MCode-11.3
clc;clear all;close all;
N=9;
x=[2 3 -5 6 6 7 -1 0 2];
for k=0:N-1
for n=0:N-1;
y(n + 1)=x(n + 1).
* exp(-j.* k*n*2*pi/N);
end
xdft(k+1)=sum(y);
end
xdft
When MCode-11.3 is run, we get the results in Figure-11.2.
Command Window
xdft =
Columns 1 through 5
20.0000 + 0.00001 -9.7540 - 1.43891 
15.0253 + 6.14471 
0.5000 - 4.33011 -6.7713 -10.60291
Columns 6 through 9 
-6.7713 +10.60291 
0.5000 + 4.33011 
15.0253 - 6.14471 -9.7540 + 1.43891
Figure-11.2
In MATLAB Fourier transform of a signal can be calculated 
using the fast Fourier transform function fft0. We can 
compare the result of our DFT calculation to the (Fast 
Fourier Transform) as in MCode-11.4.
MCode-11.4 
clc;clear all;close all; 
N=9;
x=[2 3 -5 6 6 7 -1 0 2];
for k=0:N-1
for n=0:N-1;

y(n + 1)=x(n + 1).
* exp(-j.* k*n*2*pi/N);
end
xdft(k+1)=sum(y);
end
xdft
fft(x,N)
When MCode-11.4 is run, we get the results in Figure-11.3.
Command Window
xdft =
Columns 1 through 5
20.0000 + 0.00001 -9.7540 - 1.43891 
15.0253 + 6.14471 
0.5000 - 4.33011 
-6.7713 -10.60291
Columns 6 through 9
-6.7713 +10.60291 
0.5000 + 4.33011 
15.0253 - 6.14471 
-9.7540 + 1.43891
ans =
Columns 1 through 5
20.0000 + 0.00001 -9.7540 - 1.43891 15.0253 + 6.14471 
0.5000 - 4.33011 -6.7713 -10.60291
Columns 6 through 9
-6.7713 +10.60291 
0.5000 + 4.33011 
15.0253 - 6.14471 
-9.7540 + 1.43891
Figure-11.3
It is seen from the result of Figure-11.3 that the function 
gives the same results.
Example-11.3: CalculatetheFourier transform of 
x[n] = [2 - 3 
3 
4 - 2 
5] using fft() function, and
using inverse Fourier transform formula obtain x[n] signal 
from DFT coefficients.
Solution-11.3: First, we define x^signal as in MCode- 
11.5.
MCode-11.5

clc; clear all; close all;
N=6;
x=[2 -3 3 4 -2 5];
The Fourier transform of the signal is calculated using W) 
function as in MCode-11.6.
MCode-11.6
clc;clear all;close all;
N=6;
x=[2 -3 3 4 -2 5];
y=fft(x,N)
The inverse Fourier transform implementation is written in 
MCode-11.7.
MCode-11.7
for n=0:N-1
for k=0:N-1
x2(k+1)=y(k+1).
* exp(j.* k*n*2*pi/N);
end
x2idft(n + 1)=sum(x2)/N;
end
x2idft
When MCode-11.5, 11.6, 11.7 are combined and run, we get 
the results in Figure-11.4.

Command Window
y
Columns 1 through 4
9.0000
-1.5000 + 2.59811
4.5000 +11.25831 -3.0000
Columns 5 through 6
4.5000 -11.25831J -1.5000
2.59811
n ? x
x2idft
4
Columns 1 through
2.0000
-3.0000 + O.OOOOi
3.0000
O.OOOOi
4.0000
O.OOOOi
Columns 5 through
-2.0000 + O.OOOOi
5.0000
O.OOOOi
6
Figure-11.4
Inverse Fourier transform can be calculated using 
function. In MCode-11.8, we calculate the inverse Fourier 
transform using ifftO.
MCode-11.8 
clc;clear all;close all; 
N=6;
x=[2 -3 3 4 -2 5];
y=fft(x,N) 
for n=0:N-1 
for k=0:N-1
x2(k+1)=y(k+1).
* exp(j.* k*n*2*pi/N);
end
x2idft(n + 1)=sum(x2)/N;
end 
x2idft 
ifft(y,N)
When MCode-11.5, 11.6, 11.8 are combined and run, we get 
the results in Figure-11.5.

Figure-11.5

Chapter-12
ANALOG and DIGITAL Filter Design
Abstract: In this chapter we will explain analog and digital 
infinite impulse response, IIR, filter design using MATLAB. 
First, we will explain analog filter design, then we will cover 
digital filter design. We will also utilize MATLAB tool fdatool 
for filter design.
12.1 Laplace Transform
Laplace transform is defined for continuous time signals. 
The Laplace transform of W is defined as
F(s) = J*f(t)e’stdt
(12.
1)
Laplace Transform in MATLAB
The Laplace transform of the function a function is obtained 
using
L = laplace(f)
where symbolic parameters are used for the arguments of 
the MATLAB Laplace function.
Example-12.1: The Laplace transform of = t is 
calculated using the MATLAB code in Figure-12.1.

Command Window
>> syms t;
>> laplace )
ans =
120/srt6
Figure-12.1
Example-12.2: The Laplace transform of = cos(t) is 
calculated using the MATLAB code in Figure-12.2.
Command Window
>> syms t;
>> laplace(cos(t))
ans =
s/ (s~2 + l)
Figure-12.2
ILAPLACE Command
Inverse Laplace transform of an expression is calculated 
using
F = ilaplace(L)
Example-12.3: The Laplace transformation of the function 
f(t) = cos(t) and the inverse Laplace transformation of this 
transformation is calculated using the MATLAB code in 
Figure-12.3.

Command Window
>> syms t;
>> L=laplace(cos(t))
L =
s/ (s~2+lj
>> F=ilaplace(L)
F =
cos (t)
Figure-12.3
12.2 Z-Transform
Z-Transform is used for digital signals. The Z-transform of 
the digital signal is defined as
00
X(z) = x[n]z
n = 0
(12.
2)
Z-Transform in MATLAB
The Z-transform of the digital signal is calculated using
xz = ztrans(x)
in MATLAB.
i 
x[n] = — u[n]
Example-12.4: The Z-transform of 
is
calculated using the MATLAB code in Figure-12.4.

Command Window
>> syniH n;
>> X=ztrans(l/4An)
X =
4*z/
 (4
*z-l)
Figure-12.4
Inverse Z-Transform in MATLAB:
Inverse Z-transform is calculated in MATLAB using the 
MATLAB function iztrans(). The inverse Z-transform of xz is 
calculated using
x = iztrans(xz)
Example-12.5: The Z-transform of the function
1
x[n] = — u[n]
4n
and the inverse Z-transform of this transformation is 
calculated using the MATLAB code in Figure-12.5.
Command Window
>> synis n;
>> X=zt rans (1/ 4"n)
X =
4*z/
 (4
*z-l)
>> x=iztrans(X)
x =
(1/4)

Figure-12.5
12.3 Transfer Function and FREQS
Commands
The transfer function of a system with input x^) and output 
yW is calculated as 
where X(s) and Y(s) are the Laplace transforms of input and 
output signals.
For the calculation of the transfer function, freqs() function 
is used as
H = freqs (B, A, W)
(12.
3)
where B and A are number vectors whose elements are the 
polynomial coefficients of numerator and denominator 
terms of H(s l such that
b^1" ’1 + b2sr ’2 + b3sr ’ 3 + ■ ■ ■ + b 
t -1 , t - 2 , t - 3 , ,
ats + a9s + a3s + ■■■ + at
(12. 
4)
After calculating the transfer function H, we can calculate 
the absolute value and angle functions of the transfer 
functionusing 
abs(H) angle(H)
If the freqs() command is used alone as in
freqs (B, A, W)
(12. 
5) 

then the absolute value and the angle functions are 
automatically drawn in separate graphs.
Example-12.6: 
Draw the absolute value and angle
functions of the transfer function
0.2s2 + 0.5s - 1
H(s) = —----------------
s2 + 0.5s - 1
Solution-12.7: Considering the Formulas (12.3) and (12.4) 
we can write the MATLAB program as in MCode-12.1.
MCode-12.1
b = [0.2 0.5 -1];
a = [1 0.5 -1];
w = logspace(-1,1);
freqs(b,a,w)

When MCode-12.1 is run, we get the graphs in Figure- 
12.6.
Figure-12.6
Or we can write the program as in MCode-12.2 where 
magnitude and phase functions are separately obtained and 
plotted.
MCode-12.2
b = [0.2 0.5 -1];
a = [1 0.5 -1];
w = logspace(-1,1);
h=freqs(b,a,w);

mag=abs(h);
phase=angle(h);
phasedeg = phase*180/pi;
subplot(2,1,1), loglog(w,mag), grid on;
xlabel 'Frequency (rad/s)', ylabel 'Magnitude';
subplot(2,1,2), semilogx(w,phasedeg), grid on;
xlabel 'Frequency (rad/s)', ylabel 'Phase (degrees)';
If the frequency axis is plotted using Hz unit and magnitude 
axis uses dB unit, we can utilize MCode-12.3 in our program.
MCode-12.3
f=w/(2*pi);
mag=20*log10(mag);
12.4 FREQZ Command
The MATLAB command freqz is used to obtain the transfer 
function of a digital system, the function freqz returns the 
magnitude and phase response of a transfer. The transfer 
function
_ ’ jw
where 2 - e and w is the frequency, is calculated using 
freqz() function as
[h,w] = freqz(b,a) or as freqz(b,a)
If freqz(b,a) is used without assigning the returned values to 
the parameters and w, magnitude and phase graphs are 
utomyically drawn.

Not: If the coefficients of the polynomials P^x) and ^tx) are 
denoted by the number vectors a and k, then the 
coefficients of c^x) = l)(xHrxi can be calculated as c = a*  b 
where * is the convolution operator.
Example-12.8: The transfer function of a digital system is 
given as
0.056(1 + z ’ 2)(1 - 1.2z ’1 + 0.98z ’ 2)
H(z) = “7---------H--------------------77T
(1 - 0.68z )(1 - 1.51Z 
+ 0.8z )
Plot the magnitude and phase of the transfer function.
Solution-12.9: The magnitude and phase responses are 
drawn using MCode-12.4.
MCode-12.4
b0 = 0.056;
b1 = [1 1];
b2 = [1 -1.2 0.98];
a1 = [1 -0.68];
a2 = [1 -1.5 0.8];
b = b0*conv(b1,b2);
a = conv(a1,a2);
freqz(b,a);
When MCode-12.4 is run, we get the graphs in Figure-12.7.

Figure-12.7
12.5 Analog Filter Design
The magnitude square of a typical low-pass analog filter is 
depicted in Figure-12.8.

Figure-12.8 The magnitude square of a low-pass analog 
filter
It is seen from Figure-12.X that for the pass band we have
(1 + e2) ’1 < |H(w)|2 <1 
0 < w < wp
and at the stop band we have
0 < |H(w)|2 < 62 for ws < w < oo
(12.
7)
(12.
8)
12.6 Filter Parameters
For the design of an analog filter, a number of parameters of 
the analog filter should be specified beforehand. In this 
section, we explain the analog filter parameters.
Cut-off Frequency
At the cutoff frequency W(, the transfer function satisfy
(12.
9)

If |H(w)|max 1, then at w(, we have
lH<Wc)| = 
\ 2^1
Passband Ripple
Passband ripple parameter is defined as
Rp= 101og(l + e2)
and the measurement of this quantity is decibel.
Stopband Attenuation
Stopband attenuation parameter is defined as
Rs =- 101og(62)
and the measurement of this quantity is decibel.
Selectivity Parameter
Selectivity parameter is defined as
k =
ws
(12.1 
0)
(12.1
3)
and this parameter equals 1 for ideal filters, and for 
practical filters we have < 1.
Discrimination Parameter
Discrimination parameter is defined as
(12.1
4)
and this parameter equals 0 for ideal filters, and for 
practical filters we have d > 1 .

12.7 Practical Filter Design Methods
In this section the practical analog filter design methods are 
explained. Every method has advantages and 
disadvantages as well. None of the methods is perfect. One 
of the easiest method is the Butterworth filter design 
technique.
Analog filter design methods can be outlines as
1) Butterworth filter design
2) Chebychev I and II filter design
3) Elliptic filter design
4) Bessel filter design
12.8 Butterworth Filter Design
For the design of a Butterworth filter the filter parameters 
wi, w«' Rp and R should be determined first. Then, the filter 
order N and cutoff frequency w* is calculated. In the third 
step, the filter transfer function
n pk>
(12.1
5)
is calculated where are the poles of the transfer function 
and they are calculated according to
(12.1
6)
Butterworth Filter Design in MATLAB 

Assuming that the filter parameters wi>, Ws' ^i1' s are 
given, the order and cutoff frequency of the analog 
Butterworth filter are calculated using
[N, wc] = buttord(wp, ws, rp, rs, 's')
Where N is the filter order and wc is the cutoff frequency. 
Once we have the filter order and cutoff frequency, the 
coefficient vectors of the numerator and denominator 
polynomials of the transfer function ^(sl are calculated 
using
[num, den]=butter(N,wc,'ftype','s')
where 'ftype' indicates filter type and it can be one of 'low', 
'high' and 'stop'. For the lowpass filters, we use 'low' for the 
place of 'ftype'.
After the calculation of the coefficient vectors of the 
numerator and denominator polynomials, we calculate the 
transfer function of the filter using
[h, phs]= freqs(num, den, w)
or using freqs() function, we can get the filter magnitude 
and phase responses using
freqs(num, den)
Example-12.10: The parameters
given 
as
ws = 6000rad/sec, Rp = 20dB, Rs 
of an analog filter are 
wp = 2000rad/sec
= 40dB c. . 
..
. Find 
the
degree and cutoff frequency of the Butterworth filter 
corresponding to the given parameters.
Solution-12.10: We can calculate the degree and cutoff 
frequency of the Butterworth filter as MCode-12.5.

MCode-12.5
clc; clear all;
wp=2000; ws=4000;
Rp=20; Rs=40;
[N, wc]=buttord(wp, ws, Rp, Rs, 's');
When MCode-12.5 is run, we get the outputs N=4 and 
wc=1264.9.
Example-12.11: The parameters of an analog filter are
■ 
wri = 2000rad/sec
given 
as
ws = 6000rad/sec, Rp = 20dB, Rs = 40dB
transfer function of this analog filter.
Draw the
Solution-12.11: We first find the degree and cut-off 
frequency of the filter, and in the next step we find the 
numerator and denominator coefficients of the transfer 
function, and in the last step we draw the magnitude and 
phase responses using freqs() function as in MCode-12.6.
MCode-12.6
clc; clear all;
wp=2000; ws=4000;
Rp=20; Rs=40;
[N, wc]=buttord(wp, ws, Rp, Rs, 's');
[num, den]=butter(N, wc, 'low', 's'); 
freqs(num, den);
When MCode-12.6 is inspected it is seen that, the frequency 
range is not defined or freqs() function. It is automatically 
defined by the MATLAB.
When MCode-12.6 is run, we get the graphs in Figure-12.9.

Frequency (rad/s)
Figure-12.9
12.9 Analog Chebychev Filter Design
In this section, we will explain Chebychev analog filter 
design method.
Chebychev Type-I Filter
The magnitude squared transfer function of the Chebychev 
Type-I filter is depicted in Figure-12.10. It is seen from 
Figure-12.10 that Chebychev Type-I filter has ripples in 
passband, and this is a negative aspect of this type of filter.

Figure-12.10 Magnitude Squared Transfer Function of 
Chebychev Type-I Filter
Chebychev Type-I Filter Mathematical Design
Assume that the filter parameters wi>, Ws' are given. 
Chebychev Type-I low pass filter can be designed using 
following the steps:
1) The degree of the filter is determined using
log(d’1 + Jd’2 - 1) cosh’1 (d’X)
N >-------------------- , 
=------------------------ )12'17
log(k ’1 + ^k ’ 2 - 1) 
cosh'1 (k'X)
where k and d are called selectivity and discrimination 
parameters and they are calculated as

The ripple parameter shows the ripple amount in the 
passband and it is calculated by solving the equation
R._P 
(12.1
H(wt,) = 10 10 
8)
where ' is the cutoff frequency.
2) The transfer function is obtained using
(12.1
9)
Where the pole values are calculates using
2k-1 \ 
2N n)
pk =- wpsinh((|))sin 2k-1 \ 
, . I
2N n + jwpcosh (cpcosI
(12.2 
0)
where is calculated using
(12.2
1)
and the constant term in (12.19) is calculated using
(12.22 
)

Chebychev Type-I Filter Design Using MATLAM
Assume that the filter parameters wi', Ws' Rs are given. 
We first determine the order and cutoff frequency using
[N, wc] = cheb1ord(wp, ws, Rp, Rs, 's')
then the coefficients of the numerator and denominator 
polynomials of the transfer function are calculated as
[b,a] = cheby1(N,Rp,wc,'low', 's')
and finally magnitude and phase transfer functions are 
drawn using
freqz(b,a)
Example-12.12: Find the order and cutoff frequency of the
Chebychev Type-I filter for the given filter parameters
wp = 1000 rad/sec ws = 3000 rad/s Rp = 2 dB Rs = 60 dB
Solution-12.12: In MCode-12.7, the filter order and its 
cutoff frequency is calculated.
MCode-12.7
clc; clear all;
wp=1000; ws=3000;
Rp=2; Rs=60;
[N, wc]=cheb1ord(wp, ws, Rp, Rs, 's')
When MCode-12.7 is run, we get the outputs N=5 and 
wc=1000.
Example-12.13: Plot the magnitude and phase response of 
the Chebychev Type-I filter whose specifications are

Wp = 1000 rad/sec ws = 3000 rad/s Rp = 2 dB Rs = 60 dB
Solution-12.13: The magnitude and phase transfer 
functions of the Chebychev Type-I filter can be as in MCode- 
12.8.
MCode-12.8
wp = 1000;
ws = 3000;
Rp = 2;
Rs = 60;
[N, wc] = cheb1ord(wp, ws , Rp , Rs, 's');
[B , A] = cheby1(N, Rp , wc , 's');
freqs(B, A)
When MCode-12.8 is run, we get the graphs in Figure-12.11.

Phase (degrees) 
Magnitude
Figure-12.11
If we zoom into the magnitude graph, we can see the 
ripples in the transition part better as in Figure-12.12.

Figure-12.12
It is seen from the graph of Figure-12.12 that the passband 
contains ripples in the amplitude and this is the negative 
property of the Chebychev Type-I filters.
Chebychev Type-II Filter
The magnitude squared transfer function of the Chebychev 
Type-II filter is depicted in Figure-12.13. It is seen from 
Figure-12.13 that Chebychev Type-II filter has ripples in 
stopband, and this is a negative aspect of this type of filter. 
The passband has smooth amplitude compared to the 
Chebychev Type-I filter.

Figure-12.13 Magnitude Squared Transfer Function of 
Chebychev Type-II Filter
The magnitude squared transfer functions of the Chebychev 
Type-II filter are given as
( 
1 
)
( 
2 
)
( 
3 
)

The Laplace transform of the impulse response, i.e., transfer 
function, of the Chebychev Type-II filter is given as 
eger N gift ise
eger N tek ise
(12.2
6)
Z‘ 19
where 1 and are the zeros, 
and they are calculated as
poles of the transfer function
( 
4 
)
where is calculated as
(
6 
)

1
= —cosh’1 (6 ’ ■*■)
i
= ^ln[6’1 + (6’2-l)2]
i
= 
1 + (6 ’2 - l)2j
and the constant c is evaluated as
(12.3
0)
Chebychev Type-II Filter Design Using MATLAB
Given the filter specifications wp, ws, Rp, Rs, we can 
calculate the degree and cutoff frequency of the Chebychev 
Type-II analog filter using
[N, wc] = cheb2ord (wp, ws, Rp, Rs, 's')
The coefficient vectors of the numerator and denominator 
polynomials of the transfer function can be found using
[b,a] = cheby2(N,rs,ws,ftype, 's')
where ftype=’low’ is used for lowpass filter design, and 
lastly the transfer function of the filter is drawn 
using
freqz(b,a)
Example-12.14: Find the order and cutoff frequency of the 
Chebychev Type-II filter whose specifications are given as
wp = 1000 Ws = 3000 Rp = 2 Rs = 60

Solution-12.14: The order of the filter and its cutoff 
frequency is evaluated using MCode-12.9.
MCode-12.9
wp = 1000;
ws = 3000;
Rp = 2;
Rs = 60;
[N, wc] = cheb2ord(wp, ws , Rp , Rs, 's')
When MCode-12.9 is run, we get the outputs N=5, 
wc=2616.1
Example-12.15: Find the transfer function of the
Chebychev Type-II filter whose specifications are given as
wp = 1000 Ws = 3000 Rp = 2 Rs = 60
Solution-12.15: The transfer of the filter can be obtained 
using the MATLAB function tf() as in MCode-12.10.
MCode-12.10
wp = 1000;
ws = 3000;
Rp = 2;
Rs = 60;
[N, wc] = cheb2ord(wp, ws, Rp, Rs, 's');
[B, A] = cheby2(N, Rp, wc, 's');
tf(B, A)
When MCode-12.10 is run, we get the output in Figure- 
12.14.

Command Window
ans =
1.645e04 s'4 - 4.08Se-ll s'3 + 4.166ell b~2 - 0.0002861 3 + 2.llelS
3'5 4- 1.9te04 3'4 4- 5.68e07 3'3 4 4.515ell 3'2 + 3.333el4 3 + 2.11el8 
Continuous—time transfer function.
Figure-12.14
Example-12.16: Draw the graphs of magnitude and phase 
transfer functions of the Chebychev Type-II filter whose 
specifications are given as
wp = 1000 ws = 3000 Rp = 10 Rs = 60
Solution-12.16: The phase and magnitude transfer 
functions can be drawn using MCode-12.11.
MCode-12.11
wp = 1000;
ws = 3000;
Rp = 10;
Rs = 60;
[N, wc] = cheb2ord(wp, ws , Rp , Rs, 's');
[B , A] = cheby2(N, Rp , wc , 's');
freqs(B, A);
When MCode-12.11 is run, we get the graphs in Figure- 
12.15.

Figure-12.15
It is seen from the magnitude graph of Figure-12.15 that the 
filter magnitude has ripples at the stopband.
12.10 Elliptic Filters
Elliptic filter has ripples both in passband and stopband. 
However, the transition band has larger slope compared to 
Butterworth and Chebychev filters.
Example-12.17: Draw the graphs of phase and magnitude 
transfer functions of the elliptic filter whose specifications 
are given as
wp = 1000 Ws = 3000 Rp = 10 Rs = 60

Solution-12.17: The graphs of phase and magnitude 
transfer functions of the elliptic filter can be drawn as in 
MCode-12.12.
MCode-12.12
wp = 1000;
ws = 3000;
Rp = 2;
Rs = 60;
[N, wc] = ellipord(wp, ws, Rp, Rs, 's')
[B , A] = ellip(N,Rp,Rs,wc,'s');
freqs(B, A);

Bessel Filters: Bessel filter has no ripples in passband and 
stopband, however, the slope of the transition band is 
smaller compared to Butterworth, Chebychev and Elliptic 
filters.

The coefficient vectors of the numerator and denominator 
polynomials of the Bessel filter are calculated using
[b,a] = besself(n,w0)
where w0 indicates the frequency below which group delay 
of the Bessel filter is constant.
The frequency w0 also shows the frequency below which 
passes from the filter without distortion.
Example-12.18: Draw the magnitude and phase responses 
of the Bessel filter whose order N=5 and wo=1000.
Solution-12.18: In MCode-12.13, we draw the magnitude 
and phase response of the Bessel filter
MCode-12.13
[B, A] = besself(5, 1000) 
freqs(B, A)
When MCode-12.13 is run, we get the graphs in Figure- 
12.17.

Figure-12.17
12.11 Highpass, Bandpass and
Bandstop Filter Design
In this section, we will consider highpass, bandpass and 
bandstop filter design. We will design the filters using only 
Butterworth filter method. The other filters can be designed 
following the similar steps of Butterworth filter design.
Highpass Analog Filter Design
Let's explain the topic via an example.

Example-12.19: Design the highpass Butterworth filter 
whose stopband and passband frequencies are 
ws = 1000 rad/sec wp = 3000 rad/sec 
and the ripple factors are
Rp = 2 dB Rs = 60 dB
Solution-12.19: The required filter is designed in MCode- 
12.14.
MCode-12.14
ws = 1000;
wp = 3000;
Rp = 2;
Rs = 60;
[N, wc] = buttord(wp, ws, Rp, Rs, 's') 
[B , A] = butter(N,wc,'high','s');
freqs(B, A)
When MCode-12.14 is run, we get the graphs in Figure- 
12.18.

Figure-12.18
Bandpass Analog Filter Design
Let's explain the topic via an example.
Example-12.20: Design a bandpass filter such that it 
passes the frequencies between 100 rad/sec and 200 
rad/sec, and it blocks the frequencies lower than 50 rad/sec 
and higher than 250 rad/sec. Ripple parameters are given 
as Rp=3 dB, Rs=40 dB.
Solution-12.20: The required filter is designed in MCode- 
12.15.
MCode-12.15
wp = [100 200];
ws = [50 250];

Rp = 3;
Rs = 40;
[n,wc] = buttord(wp,ws,Rp,Rs,'s');
[B , A] = butter(N,wc, 'bandpass', 's');
freqs(B, A);
When MCode-12.15 is run, we get the graphs in Figure- 
12.19.
Figure-12.19
Bandstop Filter Design
Let's explain the topic via an example.
Example-12.21: Design a bandstop filter such that the 
filters stops the frequencies between 100 rad/sec and 200 

rad/sec, and it passes the frequencies smaller than 50 
rad/sec and greater than 250 rad/sec. The ripple parameters 
of the filter are Rp=3 dB and Rs=40 dB.
Solution-12.21: The required bandstop filter is designed in 
MCode-12.16.
MCode-12.16
wp = [100 200];
ws = [50 250];
Rp = 3;
Rs = 40;
[n,wc] = buttord(wp,ws,Rp,Rs,'s');
[B , A] = butter(N,wc,'stop','s');
freqs(B, A)
When MCode-12.16 is run, we get the graphs in Figure- 
12.20.

Figure-12.20
Example-12.22: An analog signal is given as 
x(t) = 1 + sin(t) + sm(6t). Design a filter such that when 
is the iput of th filter, the output of the filter becomes 
sin(6t), i.e., it only passes the component sin(6t).
Solution-12.22: The frequency of the signal sm<6t) is 
larger than the frequency of sin(t). To eliminate the high 
frequency signal, we should design a low pass filter. We can 
choose the specifications of the low pass filter as
wp = 1.5 ws = 4 Rp = 3 Rs = 60

Using the filter specifications, we can design the filter as in 
MCode-12.17.
MCode-12.17
wp = 1.5;
ws = 4;
Rp = 3 ;
Rs = 60;
[N,wc] = buttord(wp,ws, Rp , Rs , 's'); 
[B, A] = butter(N ,wc,'s');
freqs(B, A)
When MCode-12.17 is run, we get the graphs in Figure- 
12.21.

Figure-12.21
12.12 Digital Filter Design
Digital filters are obtained from analog filters via sampling 
operation. The transfer function of an analog filter is 
converted to the transfer function of a digital filter via 
transformation methods.

Transfer function of an analog filter is the Laplace transform 
of its linear and time invariant impulse response.
In a similar manner, the transfer function of a digital filter is 
the Z-transform of its linear and time invariant impulse 
response.
The transfer functions obtained using Laplace transforms 
are usually converted to the Z-transforms using "Bilinear" 
transformation method.
Assume that the values of the filter parameters
Wp' WS Rp'
are given. Using these values, we can calculate the order 
and cutoff frequency of the filters using
Butterworth
[N, wc] = buttord(wp, ws, Rp, Rs)
Chebyshev Type I
[N, wc] = cheb1ord(wp, ws, Rp, Rs)
Chebyshev Type II
[N, wc] = cheb2ord(wp, ws, Rp, Rs)
Elliptic
[N, wc] = ellipord(wp, ws, Rp, Rs)
The transfer function of a digital filter is expressed as
b0 + bxz ’1 + , ■ ■ \bnz ’n
H(z) =--- n----~
a0 + a2z + /■■/anz n
(12.3
1)
If the order and cutoff frequency of a digital filter is known, 
then numerator and denominator coefficients of (12.31) can 

be calculated using
Butterworth
[num, den] = butter(N, wc,'ftype')
Chebyshev Type I
[num, den] = cheby1(N,Rp,wc,'ftype')
Chebyshev Type II
[num, den] = cheby2(N,Rs,wc,'ftype')
Elliptic
[num, den] = ellip(N,Rp,Rs,wc,'ftype')
where ‘ftype’ can be replaced by ‘low’, ‘high’, and ‘stop’ 
words depending on the type of the filter to be designed.
We can also use ‘freqz’ MATLAB function to calculate the 
numerator and denominator coefficients.
To filter the digital signal X|1, we use the filter() function as in
yn = filter (num, den, xn)
where is the output of the filter. The output of the filter 
can have some phase delay, this is due to the group phase 
and group delay of the filter.
Example-12.23: For the given the continuous time signal 
xc(t) = cos (lOnt) + cos (120nt)
a) Draw the graph o the signal.
b) Sample the continuous time signal and obtain a digital 
signal, choose sampling frequency such that spectral

overlapping does not occur on the digital signal.
c) Design a lowpass filter such that the filter only passes 
the digital signal obtained from cos (10nt), i.e., the filter 
eliminates the digital signal obtained by sampling 
cos (120nt) ■
Solution-12.23:
a) 
First, let's draw the graph of
X,.(t) = cos (10nt) + cos (120nt) as in MCode-12.18.
MCode-12.18
f1=5;
f2=60;
t=-0.25:0.00125:0.25;
xc_t=cos(2*pi*f1*t)+cos(2*pi*f2*t);
plot(t,xc_t);
xlabel('t');
ylabel('x_c(t)');
When MCode-12.18 is run, we get the graph in Figure-12.22.

Figure-12.22
b) 
The signal x-(t) = cos(10nt) + cos(120nt)
frequencies 5Hz and 60Hz. The sampling 
chosen higher than twice of the largest frequency as
fs > 2 X 60—> 120
contains the 
frequency is
Let's choose 256 , and sampling period equals
1
T =-----
s 256
Using the chosen values, we can sample analog signal and 
obtain the digital signal as in MCode-12.19.
MCode-12.19
f1=5;
f2=60;
t=-0.25:0.00125:0.25;
xc_t=cos(2*pi*f1*t)+cos(2*pi*f2*t);

plot(t,xc_t,'k','LineWidth',2);
xlabel('t');
ylabel('x_c(t)');
Ts=1/256; % Sampling period
ts=-0.25:Ts:0.25;
xn=cos(2*pi*f1*ts)+cos(2*pi*f2*ts); %Digital signal 
hold on;
stem(ts,xn,'filled','r')
When MCode-12.19 is run, we get the graph in Figure-12.23.
Figure-12.23
c) 
We can choose the values of the filter parameters as
Rp=2 Rs=40 
wp=2
*pi
*10
 
ws=2
*pi
*50
In MCode-12.20, we calculate the cutoff frequency of the 
analog filter first, and then we convert this cutoff frequency 
to digital cutoff frequency using
WcTs/n
and then perform filtering operation
MCode-12.20 

clc; clear all; close all;
f1=5;
f2=60;
t=-0.25:0.00125:0.25;
xc_t=cos(2*pi*f1*t)+cos(2*pi*f2*t);
% plot(t,xc_t);
% xlabel('t');
% ylabel('x_c(t)');
Ts=1/256;
ts=-0.25:Ts:0.25;
xn=cos(2*pi*f1*ts)+cos(2*pi*f2*ts);
Rp=2;
Rs=40;
wp=2*pi*10;
ws=2*pi*50;
[N, wc]=buttord(wp,ws,Rp,Rs,'s')
[B, A]=butter(N,wc*Ts*1/pi); 
yn=filter(B,A,xn);
stem(ts,yn,'filled','r') 
hold on;
plot(t,cos(2*pi*f1*t));
The graph of the low frequency signal cos (10nt) and the 
graph of the filter output are depicted in Figure-12.24.

Figure-12.24
It is seen from Figure-12.24 that the filter output has some 
delay compared to the analog signal cos (1 Ont). The output 
signal is also a low frequency cosine signal and high 
frequency cosine signal is eliminated using the filtering 
operation.
The output of the filter can be send to D/A converted and 
analog low frequency cosine signal can be reconstructed. 
The delay on the filter output is due to the phase and group 
delay of the filter transfer function.
The are a number of functions in MATLAB for filter design. 
The transfer function of the filter can be given as
(12.3 
2)

For the transfer function given in (12.32), the zeros and 
poles of the Butterworh filter can be calculated using
[z,p,k] = butter(N,Wc,ftype)
and the transfer function of the filter can be drawn as in
[z,p,k] = butter(n,Wn,'ftype','s'); 
[pay,payda] = zp2tf(z,p,k);
freqs(num,den);
12.13 Filter Design Using FDATOOL
There is a visual interface of MATLAB for filter design. To 
activate this interface we write fdatool in the MATLAB 
command window. When we write fdatool and press return, 
we get the interface in Figure-12.25.

Figure-12.25
Example-12.24: A lowpass filter designed using FDATOOL 
is depicted in Figure-12.26.

Figure-12.26
The coefficients of the transfer function can be read as 
shown in Figure-12.27

Figure-12.27
The MATLAB program of the Figure-12.26 can also be 
obtained as illustrated in Figure-12.28.

Figure-12.28
MCode-12.21
function Hd = myButterWorthFilter
%myButterWorthFilter Returns a discrete-time filter object.
% MATLAB Code
% Generated by MATLAB(R) 8.1 and the Signal Processing Toolbox 6.19.
% Generated on: 18-Jun-2017 01:57:09
% Butterworth Lowpass filter designed using FDESIGN.LOWPASS.
% All frequency values are in kHz. 
Fs = 100; % Sampling Frequency
Fpass = 20;
Fstop = 40;
Apass = 1;
Astop = 80;
match = 'stopband'; % Band to match exactly 
% Passband Frequency
% Stopband Frequency
% Passband Ripple (dB)
% Stopband Attenuation (dB) 

% Construct an FDESIGN object and call its myButterWorthFilter method. 
h = fdesign.lowpass(Fpass, Fstop, Apass, Astop, Fs);
Hd = design(h, 'myButterWorthFilter', 'MatchExactly', match);
Example-12.25: Design of a Chebyshev Type-I filter using 
FDATOOL is shown in Figure-12.29.
Figure-12.29
We can zoom the passband of the filter using ‘View’ menu of 
Figure-12.29 and choosing passband as in Figure-12.30. It is 
seen Figure-12.30 that the filter passband section contains 
ripples, and these ripples are not very clear in Figure-12.29.

Figure-12.30
Example-12.26: Design of a Chebyshev Type-II filter using 
FDATOOL is shown in Figure-12.31.

Figure-12.31
The stopband of the filter is viewed in Figure-12.31 where it 
is seen that stopband contains ripples.

Figure-12.32
Example-12.27: Design of an Elliptic filter using FDATOOL 
is shown in Figure-12.33.

Figure-12.33
The stopband of the filter is viewed in Figure-12.33 where it 
is seen that stopband contains ripples. The small ripples of 
the passband in Figure-12.33 are not very clearly seen. The 
passband of the filter is viewed in separate graph in Figure- 
12.34 where small ripples are seen better.

Figure-12.34
12.14 SIMULINK Filter Design
A filter designed using FDATOOL can be used in MATLAB 
SIMULINK environment.

Example-12.28: Design a lowpass filter which passes only 
the low frequency cosine of 
.
Test your filter in SIMULINK environment.
Solution-12.29: The values of the filter parameters are
Rp = ldB Rs = 80dB Fp = 10Hz Fs = 40Hz
Filter design using FDATOOL can be achieved as shown in 
Figure-12.35.
Figure-12.35

We can export the designed filter to the SIMULINK 
environment as illustrated in Figure-12.36.
Figure-12.36
When export is completed we get the window in Figure- 
12.37.

Figure-12.37
If we press the realize button of the window in Figure-12.37 
we get the window in Figure-12.38.

Figure-12.38
We can add the cosine signal generators to the window of 
Figure-12.38 as illustrated in Figures-12. 39, 40, 41, 42.

Figure-12.39

Figure-12.40

Figure-12.41

Figure-12.42
Finally we get the window in Figure-12.43.

Figure-12.43
Clicking on the cosine block in Figure-12.43 we can enter 
the parameters of the cosine signals as illustrated in Figure- 
12.44.


Figure-12.44
If we click on the scope-2, and scope-1, we see the 
summed signal and filter output as shown in Figure-12.45 
where the upper graph shows the summed signal and lower 
graph shows the filter output. It is seen from the lower 
graph of Figure-12.45 that the filter output only contains low 
frequency cosine signal.

Figure-12.45
Bibliography
1) O. Gazi, Understanding Digital Signal Processing, 
Springer, 2018. ISBN:978-981-10-4961-3
2) A.V. Oppenheim, Digital Signal Processing, 1989.

