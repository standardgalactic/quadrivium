www.it-ebooks.info

Neo4j Cookbook
Harness the power of Neo4j to perform complex data 
analysis over the course of 75 easy-to-follow recipes
Ankur Goel
BIRMINGHAM - MUMBAI
www.it-ebooks.info

Neo4j Cookbook
Copyright © 2015 Packt Publishing
All rights reserved. No part of this book may be reproduced, stored in a retrieval system, 
or transmitted in any form or by any means, without the prior written permission of the 
publisher, except in the case of brief quotations embedded in critical articles or reviews.
Every effort has been made in the preparation of this book to ensure the accuracy of the 
information presented. However, the information contained in this book is sold without 
warranty, either express or implied. Neither the author, nor Packt Publishing, and its dealers 
and distributors will be held liable for any damages caused or alleged to be caused directly 
or indirectly by this book.
Packt Publishing has endeavored to provide trademark information about all of the 
companies and products mentioned in this book by the appropriate use of capitals. 
However, Packt Publishing cannot guarantee the accuracy of this information.
First published: May 2015
Production reference: 1260515
Published by Packt Publishing Ltd.
Livery Place
35 Livery Street
Birmingham B3 2PB, UK.
ISBN 978-1-78328-725-3
www.packtpub.com
www.it-ebooks.info

Credits
Author
Ankur Goel
Reviewers
Onofrio Panzarino
Ignaz Wanders
Commissioning Editor
James Jones
Acquisition Editor
James Jones
Content Development Editor
Ruchita Bhansali
Technical Editor
Narsimha Pai
Copy Editors
Dipti Kapadia
Rashmi Sawant
Project Coordinator
Kranti Berde
Proofreaders
Safis Editing
Paul Hindle
Indexers
Hemangini Bari
Rekha Nair
Graphics
Sheetal Aute
Valentina D'silva
Disha Haria
Production Coordinators
Komal Ramchandani
Alwin Roy
Cover Work
Komal Ramchandani
www.it-ebooks.info

About the Author
Ankur Goel has been passionate about software development for a long time. He is 
particularly interested in exploring upcoming technologies in the areas of big data, artificial 
intelligence, and machine learning. He started his career with CDAC High Performance 
Computing Lab, where he worked on the PARAM series of supercomputers and built real-world 
use cases around them. He has been working for start-up companies and research labs for 
most of his career.
He also enjoys working with start-ups that are in the stealth mode stage, and helps them 
with their technology stack.
He lives in the beautiful city of Chandigarh, India, with his pretty wife and cute 
newborn daughter.
This book and all of the work that went on around it would not have been 
possible without the unconditional support of my wife, Pooja, and mother, 
Santosh. During this book, my daughter, Aradhita, came into our life, so 
I've been taking care of both the babies together, my first book and our 
first child.
I would also like to thank the amazing people at Neo4j Technologies 
for introducing the power of graph databases to the world and also for 
keeping everyone on their toes by introducing cool features frequently.
Special thanks to the reviewers and editors at Packt Publishing, especially 
Ruchita and Narsimha, without whose efforts this work would not have 
been possible.
www.it-ebooks.info

About the Reviewers
Onofrio Panzarino is a programmer with 15 years of experience, working with various 
languages (mostly with Java), platforms, and technologies. Before receiving his master of 
science degree in electronics engineering, he worked as a digital signal processor programmer. 
Around the same time, he started working as a C++ developer for real-time embedded systems 
and PCs. Currently, he is working with Android, ASP.NET C#, and JavaScript. During these years, 
he gained a lot of experience in graph databases, particularly in Neo4j.
Onofrio is the author of Learning Cypher, by Packt Publishing, in 2014. He also reviewed 
Fast ASP.NET Websites, by Manning Publications.
He resides in Ancona, Italy. He is a speaker in the local Java user group and also a technical 
writer, mostly for Scala and NoSQL. In his spare time, he loves playing the piano with his 
family and programming with functional languages. His Twitter handle is @onof80.
Ignaz Wanders is an enterprise architect who specializes in integration and data 
architectures. He is an expert in service-oriented architecture and in applying top-down 
methodologies to achieve his goals.
Ignaz has great practical experience in ESBs, BPM, Neo4j, Java EE, and a wide variety 
of supporting frameworks and tools.
He is a speaker at international conferences and his astronomical background facilitates 
a strong analytical mind and excellent problem-solving skills.
Ignaz works for Archimiddle and offers consultancy to a variety of customers, ranging from 
government institutions to telecom and logistics.
www.it-ebooks.info

www.PacktPub.com
Support files, eBooks, discount offers, and more
For support files and downloads related to your book, please visit www.PacktPub.com.
Did you know that Packt offers eBook versions of every book published, with PDF and ePub 
files available? You can upgrade to the eBook version at www.PacktPub.com and as a print 
book customer, you are entitled to a discount on the eBook copy. Get in touch with us at 
service@packtpub.com for more details.
At www.PacktPub.com, you can also read a collection of free technical articles, sign up 
for a range of free newsletters and receive exclusive discounts and offers on Packt books 
and eBooks.
TM
https://www2.packtpub.com/books/subscription/packtlib
Do you need instant solutions to your IT questions? PacktLib is Packt's online digital book 
library. Here, you can search, access, and read Packt's entire library of books.
Why Subscribe?
f
f
Fully searchable across every book published by Packt
f
f
Copy and paste, print, and bookmark content
f
f
On demand and accessible via a web browser
Free Access for Packt account holders
If you have an account with Packt at www.PacktPub.com, you can use this to access PacktLib 
today and view 9 entirely free books. Simply use your login credentials for immediate access.
www.it-ebooks.info

i
Table of Contents
Preface	
v
Chapter 1: Getting Started with Neo4j	
1
Introduction	
2
Single node installation of Neo4j over Linux	
2
Single node installation of Neo4j over Windows	
4
Single node installation of Neo4j over Mac OS X	
6
Creating your first graph with Neo4j	
8
Importing data from the CSV format to Neo4j	
12
Importing data from RDBMS to Neo4j	
16
Importing data from the Geoff format to Neo4j	
18
Importing data from OrientDB to Neo4j	
19
Importing data from InfiniteGraph to Neo4j	
21
Importing data from the DEX graph database to Neo4j	
22
Common configurations of Neo4j	
23
Running multiple instances of Neo4j over a single machine	
24
Building Neo4j from the source	
25
Chapter 2: Connecting to Neo4j	
27
Introduction	
28
Accessing Neo4j from the command line using the Neo4j shell	
28
Accessing Neo4j from the command line using curl	
30
Accessing Neo4j from the Java libraries	
34
Accessing Neo4j using the Java REST bindings	
36
Mapping Neo4j to Java-annotated classes using Spring Data Neo4j	
38
Accessing the embedded Neo4j from Python	
41
Accessing Neo4j from Python using the REST bindings	
42
Annotate the Python object model to the Neo4j graph database	
43
Accessing the embedded Neo4j from Ruby	
44
Accessing Neo4j from Ruby using the REST Bindings	
45
www.it-ebooks.info

ii
Table of Contents
Accessing Neo4j from Scala	
46
Accessing Neo4j from .NET	
47
Accessing Neo4j from PHP	
48
Accessing Neo4j from Node.js	
49
Chapter 3: The Cypher Query Language	
51
Introduction	
51
Creating your first node and relationship using Cypher	
53
Querying nodes and relationships using Cypher	
56
Deleting data from Neo4j using the Cypher query	
58
Boolean operators with Cypher	
59
Changing the order of results with Cypher	
61
Limiting and skipping results with Cypher	
63
Regular expressions with Cypher	
64
Aggregation with Cypher	
66
Combining results with Cypher	
68
Finding paths in Cypher along with their shortest route	
70
Chapter 4: Data Modeling and Leveraging with Neo4j	
73
Introduction	
73
Data modeling with Neo4j – moving away from traditional SQL	
75
Aggregate versus connected data models	
77
Creating a binary search tree with Neo4j	
80
Healthcare data modeling with Neo4j	
83
Travel data modeling with Neo4j	
86
Social data modeling with Neo4j	
89
Retail data modeling with Neo4j	
91
Chapter 5: Mining the Social Treasure	
93
Introduction	
93
Finding mutual friends with Neo4j	
95
Finding friends of friends with Neo4j	
99
Activity streaming with Neo4j	
102
Finding user similarity with Neo4j	
107
Network reachability with Neo4j	
109
Chapter 6: Developing Location-based Services with Neo4j	
113
Introduction	
113
Installing the Neo4j Spatial extension	
114
Importing the Esri shapefiles	
116
Importing the OpenStreetMap files	
118
Importing data using the REST API	
119
Creating a point layer using the REST API	
122
www.it-ebooks.info

iii
Table of Contents
Finding geometries within the bounding box	
124
Finding geometries within a distance	
125
Finding geometries within a distance using Cypher	
127
Chapter 7: Visualization of Graphs	
131
Introduction	
131
Visualization using the Neo4j console	
132
Viewing your graph with Linkurious	
136
The Neo4j graph with Gephi	
144
Visualization with Neoeclipse	
149
Chapter 8: Industry Usages of Neo4j	
153
Introduction	
153
Healthcare with Neo4j	
153
The social networking industry with Neo4j	
157
The travel industry with Neo4j	
161
E-commerce with Neo4j	
164
Chapter 9: Neo4j Administration and Maintenance	
167
Introduction	
167
Deploying Neo4j over the Amazon EC2 Cloud	
168
Deploying Neo4j over the Heroku Cloud	
172
Deploying Neo4j over the Microsoft Azure Cloud	
174
Backups with Neo4j	
178
Upgrading Neo4j to the latest version	
180
Neo4j's remote debugging setup	
181
Configuring secure access to your Neo4j instance	
183
Chapter 10: Scaling Neo4j	
185
Introduction	
185
A bulk upload of the initial large dataset	
185
The high availability setup	
191
Handling high read loads	
194
Handling high write loads	
195
Optimizing the Cypher query for performance	
197
Index	
201
www.it-ebooks.info

www.it-ebooks.info

v
Preface
In this connected world, where gigabytes of unstructured information gets generated every 
second, the Neo4j graph database fits in perfectly to store such data and visualize it from 
every angle. A graph is the most natural form in which data can be stored and visualized, 
where every connected edge gives you a new path of the data flow and possible new insights 
into the data, which are not possible in the traditional data stores. Nearly, every company 
in a wide variety of domains, such as healthcare, retail, and travel, have realized the true 
potential of graph databases, and started to explore them for various use cases, such as 
recommendation, pattern detection, optimizing routes, and tons of other examples.
Many fortune 500 companies have adopted graph databases for a wide array of 
business-critical use cases and many start-ups are adopting them for new innovative 
use cases, which were never heard of before. Facebook, LinkedIn, and Twitter are the 
most well-known users of graph technologies for social web properties.
Neo4j, a graph database by Neo Technologies, is the leading player in the graph database 
market. It is so easy to use that even a non-technical person can easily browse the data 
and explore new use cases around it. With this also comes power-packed features that 
any enterprise database should have.
This cookbook not only provides insights into Neo4j but also into tools, libraries, and 
visualization tools in a short, concise manner, which will be required frequently when you 
are exploring Neo4j for a new case, deploying Neo4j to production, or scaling it to gigabytes 
of connected data. Regardless of whether you are a programmer, database expert, or data 
scientist, this book has recipes that can be easily learnt and applied. 
What this book covers
Chapter 1, Getting Started with Neo4j, introduces Neo4j, and the installation of Neo4j on the 
operating system of your choice. It also helps you move your data from various formats, such 
as CSV, Geoff, or from other databases, such as RDBMS, OrientDB, and so on.
www.it-ebooks.info

Preface
vi
Chapter 2, Connecting to Neo4j, deals with the various ways in which you can connect to 
Neo4j with the programming language of your choice, such as Java, Python, Scala, and PHP, 
and also shows how you can access it over the REST interface, as well as using an embedded 
version of it.
Chapter 3, The Cypher Query Language, teaches you the most used aspect of Neo4j, which is 
Cypher. You will learn about queries, which you will need frequently when working with Neo4j.
Chapter 4, Data Modeling and Leveraging with Neo4j, explores the data modeling concepts 
and techniques associated with the graph data in Neo4j; in particular, the property graph 
model, design constraints for Neo4j, and modeling across multiple domains. 
Chapter 5, Mining the Social Treasure, helps you build frequently used use cases around 
social data. Whether you use data from popular social networks, such as Facebook, LinkedIn, 
or have data of your own, this chapter quickly gets you started with social use cases.
Chapter 6, Developing Location-based Services with Neo4j, teaches you the most important 
aspect of today's data, location, and how to deal with it in Neo4j. You can also learn how to 
import geospatial data into Neo4j and run queries, such as proximity searches, bounding 
boxes, and so on.
Chapter 7, Visualization of Graphs, shows you how to integrate the Neo4j graph database 
with the powerful domain of graph visualizations. We will discuss the different alternatives 
and resources to get started with. 
Chapter 8, Industry Usages of Neo4j, shows you how different industries, such as healthcare, 
travel, and retail, use Neo4j in their domains. This all comes with a sample dataset and 
queries, which you can easily build and execute to see it running.
Chapter 9, Neo4j Administration and Maintenance, deals with recipes for deploying Neo4j on 
different clouds, backup strategies, debugging and security aspects. 
Chapter 10, Scaling Neo4j, teaches you how to develop applications with Neo4j to handle 
high volumes of data. You will learn about different aspects while scaling different types 
of applications over Neo4j.
What you need for this book
This book is intended for users who work on machines based on Linux, Mac OS X, or Windows. 
All the prerequisites are described in the first and second chapters, to make sure that your 
system is Neo4j-enabled and meets a few requirements. In general, all the examples should 
work on any platform.
This book assumes that you have a basic understanding of graph theory and are familiar with 
the fundamental concepts of Neo4j. It focuses primarily on recipes around Neo4j, which are 
required frequently.
www.it-ebooks.info

Preface
vii
A reasonable and recommended lab setup can be done on a machine with a dual or quad-
core processor with 8 GB (Gigabyte) of RAM. A system with a less powerful configuration would 
probably also work, but the recommended one will make it more comfortable for you.
You might be required to install libraries or tools, depending on the recipe you are executing, 
which have been explained in the recipe itself.
Who this book is for
If you are already using Neo4j in your application and want to learn more about data analysis 
or database graphs, this is the book for you. This book also caters for your needs if you are 
looking to migrate your existing application to Neo4j in the future. We assume that you are 
already familiar with any general purpose programming language and have some familiarity 
with Neo4j.
Sections
In this book, you will find several headings that appear frequently (Getting ready, How to do it, 
How it works, There's more, and See also).
To give clear instructions on how to complete a recipe, we use these sections as follows:
Getting ready
This section tells you what to expect in the recipe, and describes how to set up any software 
or any preliminary settings required for the recipe.
How to do it…
This section contains the steps required to follow the recipe.
How it works…
This section usually consists of a detailed explanation of what happened in the previous section.
There's more…
This section consists of additional information about the recipe in order to make the reader 
more knowledgeable about the recipe.
www.it-ebooks.info

Preface
viii
See also
This section provides helpful links to other useful information for the recipe.
Conventions
In this book, you will find a number of styles of text that distinguish between different kinds 
of information. Here are some examples of these styles, and an explanation of their meaning.
Code words in text, shell commands, file extensions, pathnames, dummy URLs, user input 
are shown as follows: "A good approach for this recipe will be to go through the readme file, 
which is present in the top level directory, and follow the steps given in that file".
A block of code is set as follows:
Node node = embed.createNode();
node.setProperty("name","Neo4j");
node.setProperty("Message","Hello World");
The shell commands are provided in the following manner
$ curl -H Accept:application/json -H Content-Type:application/json  
http://localhost:7474/db/data/node/2/relationships/all
New terms and important words are shown in bold. Words that you see on the screen, 
for example, in menus or dialog boxes, appear in the text like this: "We can see two nodes, 
2 and 3, in the data visualization, which are connected to each other."
Warnings or important notes appear in a box like this.
Tips and tricks appear like this.
Reader feedback
Feedback from our readers is always welcome. Let us know what you think about this 
book—what you liked or may have disliked. Reader feedback is important for us to develop 
titles that you really get the most out of. To send us general feedback, simply send an e-mail 
to feedback@packtpub.com, and mention the book title via the subject of your message. 
If there is a topic that you have expertise in and you are interested in either writing or 
contributing to a book, see our author guide on www.packtpub.com/authors.
www.it-ebooks.info

Preface
ix
Customer support
Now that you are the proud owner of a Packt book, we have a number of things to help you 
to get the most from your purchase.
Downloading the example code
You can download the example code files for all Packt books you have purchased from your 
account at http://www.packtpub.com. If you purchased this book elsewhere, you can 
visit http://www.packtpub.com/support and register to have the files e-mailed directly 
to you.
Downloading the color images of this book
We also provide you with a PDF file that has color images of the screenshots/diagrams used 
in this book. The color images will help you better understand the changes in the output. You 
can download this file from: https://www.packtpub.com/sites/default/files/
downloads/7253OS_ColoredImages.pdf.
Errata
Although we have taken every care to ensure the accuracy of our content, mistakes do happen. 
If you find a mistake in one of our books—maybe a mistake in the text or the code—we would be 
grateful if you could report this to us. By doing so, you can save other readers from frustration 
and help us improve subsequent versions of this book. If you find any errata, please report them 
by visiting http://www.packtpub.com/submit-errata, selecting your book, clicking on 
the Errata Submission Form link, and entering the details of your errata. Once your errata are 
verified, your submission will be accepted and the errata will be uploaded to our website or 
added to any list of existing errata under the Errata section of that title.
To view the previously submitted errata, go to https://www.packtpub.com/books/
content/support and enter the name of the book in the search field. The required 
information will appear under the Errata section.
Piracy
Piracy of copyrighted material on the Internet is an ongoing problem across all media. 
At Packt, we take the protection of our copyright and licenses very seriously. If you come 
across any illegal copies of our works in any form on the Internet, please provide us with 
the location address or website name immediately so that we can pursue a remedy.
www.it-ebooks.info

Preface
x
Please contact us at copyright@packtpub.com with a link to the suspected pirated material.
We appreciate your help in protecting our authors and our ability to bring you valuable content.
Questions
If you have a problem with any aspect of this book, you can contact us at questions@
packtpub.com, and we will do our best to address the problem.
www.it-ebooks.info

1
1
Getting Started 
with Neo4j
In this chapter, we will cover the following recipes:
f
f
Single node installation of Neo4j over Linux
f
f
Single node installation of Neo4j over Windows
f
f
Single node installation of Neo4j over Mac OS X
f
f
Creating your first graph with Neo4j
f
f
Importing data from the CSV format to Neo4j
f
f
Importing data from RDMS to Neo4j
f
f
Importing data in the Geoff format to Neo4j
f
f
Importing data from OrientDB to Neo4j
f
f
Importing data from InfiniteGraph to Neo4j
f
f
Importing data from the DEX graph database to Neo4j
f
f
Common configurations of Neo4j
f
f
Running multiple instances of Neo4j over a single machine
f
f
Building Neo4j from the source
www.it-ebooks.info

Getting Started with Neo4j
2
Introduction
Neo4j is a highly scalable, fully transactional ACID (atomicity, consistency, isolation, and 
durability) graph database that stores data structured as graphs. It allows developers to achieve 
excellent performance in queries over large, complex graph datasets and at the same time, it 
is very simple and intuitive to use. This chapter consists of readymade recipes that allow users 
to hit the ground running with Neo4j. There are several recipes to set up Neo4j over a wide 
array of platforms, such as Linux, Windows, Mac, Android, and so on. Neo4j runs in different 
configuration modes: server and embedded inside application. Both of these configuration 
modes has been fully explained in this chapter. This chapter also includes common 
configurations of the key configuration files.
Single node installation of Neo4j over Linux
Neo4j is a highly scalable graph database that runs over all the common platforms; it can be 
used as is or can be embedded inside applications as well. The following recipe will show you 
how to set up a single instance of Neo4j over the Linux operating system.
Getting ready
Perform the following steps to get started with this recipe:
f
f
Download the community edition of Neo4j from http://www.neo4j.org/
download for the Linux platform:
$ wget  http://dist.neo4j.org/neo4j-community-2.2.0-M02-unix.tar.
gz
f
f
Check whether Java is installed for your operating system or not by typing this in the 
shell prompt:
$ echo $JAVA_HOME
If this command produces no output, install JDK/JRE for your Linux distribution and 
also set the JAVA_HOME path
www.it-ebooks.info

Chapter 1
3
How to do it...
Now, let's install Neo4j over the Linux operating system, which is simple, as shown in the 
following steps:
1.	 Extract the TAR file by using the following command:
$ tar –zxvf neo4j-community-<version>-unix.tar.gz
$ ls
2.	 Go to the bin directory under the root folder:
$ cd <neo4j-community-version>/bin/
3.	 Start the Neo4j graph database server:
$ ./neo4j start
4.	 Check whether Neo4j is running or not by using the following command:
$ ./neo4j status
Neo4j can also be monitored using the web console. Open http://<ip>:7474/
webadmin, as shown in the following screenshot:
The preceding diagram is a screenshot of the web console of Neo4j, through which 
the server can be monitored and different Cypher queries can be run on the 
graph database.
www.it-ebooks.info

Getting Started with Neo4j
4
How it works...
Neo4j comes with prebuilt binaries over the Linux operating system, which can be extracted 
and run over. Neo4j comes with both web-based and terminal-based consoles, over which the 
Neo4j graph database can be explored.
See also
During installation, you may face several kind of issues, such as the maximum number of files 
you can keep open at once and so on. For more information, check out http://neo4j.com/
docs/stable/server-installation.html#linux-install.
Single node installation of Neo4j over 
Windows
Neo4j is a highly scalable graph database that runs over all the common platforms; it can be 
used as is or can be embedded inside applications. The following recipe will show you how to 
set up a single instance of Neo4j over the Windows operating system.
Getting ready
Perform the following steps to get started with this recipe:
f
f
Download the Windows installer from http://www.neo4j.org/download.
This has both 32-bit and 64-bit prebuilt binaries.
f
f
Check whether Java is installed for the operating system or not by typing this 
in the cmd prompt:
echo %JAVA_HOME%
If this command throws no output, install JDK/JRE for your Windows distribution 
and also set the JAVA_HOME path.
www.it-ebooks.info

Chapter 1
5
How to do it...
Now, let's install Neo4j over the Windows operating system, which is simple, as shown here:
1.	 Run the installer by clicking on the downloaded file:
The preceding screenshot shows the Windows installer running.
2.	 After the installation is complete, when you run the software, it will ask for the 
database location. Choose the location carefully, as the entire graph database 
will be stored in this folder:
www.it-ebooks.info

Getting Started with Neo4j
6
The preceding screenshot shows the Windows installer asking for the graph 
database's location.
3.	 The Neo4j browser can be opened by entering http://localhost:7474/ in the 
browser. The following screenshot depicts Neo4j started over the Windows platform:
How it works...
Neo4j comes with prebuilt binaries over the Windows operating system, which can be 
extracted and run over. Neo4j comes with both web-based and terminal-based consoles, 
over which the Neo4j graph database can be explored.
See also
During installation, you might face several kinds of issues such as max open files and 
so on. For more information, check out http://neo4j.com/docs/stable/server-
installation.html#windows-install.
Single node installation of Neo4j over Mac 
OS X
Neo4j is a highly scalable graph database that runs over all the common platforms; it can be 
used as in a mode and can also be embedded inside applications. The following recipe will 
show you how to set up a single instance of Neo4j over the OS X operating system.
www.it-ebooks.info

Chapter 1
7
Getting ready
Perform the following steps to get started with this recipe:
f
f
Download the binary version of Neo4j from http://www.neo4j.org/download 
for the Mac OS X platform and the community edition, as shown in the following 
command:
$ wget  http://dist.neo4j.org/neo4j-community-2.2.0-M02-
unix.tar.gz
f
f
Check whether Java is installed for the operating system or not by typing this over 
the cmd prompt:
$ echo $JAVA_HOME
If this command throws no output, install JDK/JRE for your Mac OS X distribution 
and also set the JAVA_HOME path
How to do it...
Now, let's install Neo4j over the OS X operating system, which is very simple, as shown in 
the following steps:
1.	 Extract the TAR file using the following command:
$ tar –zxvf neo4j-community-<version>-unix.tar.gz
$ ls
2.	 Go to the bin directory under the root folder:
$ cd <neo4j-community-version>/bin/
3.	 Start the Neo4j graph database server:
$ ./neo4j start
4.	 Check whether Neo4j is running or not by using the following command:
$ ./neo4j status
How it works...
Neo4j comes with prebuilt binaries over the OS X operating system, which can be extracted 
and run over. Neo4j comes with both web-based and terminal-based consoles, over which 
the Neo4j graph database can be explored.
www.it-ebooks.info

Getting Started with Neo4j
8
There's more…
Neo4j over Mac OS X can also be installed using brew, which has been explained here.
Run the following commands over the shell:
$ brew update
$ brew install neo4j
After this, Neo4j can be started by using the start option with the Neo4j command:
$ neo4j start
This will start the Neo4j server, which can be accessed from the default URL (http://
localhost:7474).
The installation can be reached by using the following commands:
$ cd /usr/local/Cellar/neo4j/
$ cd {NEO4J_VERSION}/libexec/
You can learn more about OS X installation from http://neo4j.com/docs/stable/
server-installation.html#osx-install.
Creating your first graph with Neo4j
After the successful setup of Neo4j on an operating system of our choice, now it's time to say 
Hello World to Neo4j, which means it's time to create our first graph by using Neo4j.
We know that any graph consists of nodes and edges, where edges represent the 
relationships between nodes.
Consider an example where there are two persons, Alice and Bob, who know each other. 
So, in graph terminology, Alice will be node A and Bob will be node B. The technical 
representation of this example can be done as follows:
f
f
Nodes: A and B
f
f
Edges: A----------- knows -------------B
www.it-ebooks.info

Chapter 1
9
The preceding diagram shows nodes and edges, where edges represent the properties 
between the nodes.
Getting ready
To get started with this recipe, install Neo4j by using the earlier recipes of this chapter.
How to do it...
There are many ways to create a graph with Neo4j. However, in order to create our first graph, 
we will use the Neo4j shell that comes with Neo4j by default and can be intuitively operated 
from both the command line and the shell.
For our first graph, consider a scenario where London and Paris are two cities that are 
connected by the following flights:
f
f
Airline X, which connects London to Paris daily (start time: 1400 hours)
f
f
Airline Y, which connects Paris to London daily (start time: 2300 hours)
www.it-ebooks.info

Getting Started with Neo4j
10
Let's gets started to create our first graph using the Neo4j shell. To do so, perform the 
following steps:
1.	 Start the Neo4j server by using the following command:
${NEO4J_ROOT}/bin/neo4j start
The detailed steps to start the Neo4j server has been described in the previous 
recipes.
2.	 The Neo4j shell can be invoked by two methods. The first method is to simply 
type in the following command (under the same <neo4J_Home_Directory>/
bin directory):
${NEO4J_ROOT}/bin/neo4j-shell
The output of this command is shown as follows:
The nodes are created using the mknode command as follows:
neo4j-sh (0) $ mknode London
neo4j-sh (0) $ mknode Paris
3.	 Let's create a node and enter this node by using the cd option with mknode:
neo4j-sh (0) $ mknode --cd --np "{'name':'London'}"
The np option can be used to specify as many properties as you want with that node.
4.	 Now, we will create another node with the name Paris:
neo4j-sh (0) $ mknode  --np "{'name':Paris}" -v
www.it-ebooks.info

Chapter 1
11
5.	 Next, we will create a relationship between them by executing the following 
commands from the command line:
neo4j-sh (London,2)$  mkrel -d OUTGOING -t CONNECTED <nodeid from 
preceding command> --rp "{'Airline':'X','Start-Time':'1400'}"
neo4j-sh (London,2)$  ls
*name =[London]
(me)-[:CONNECTED]->(Paris,3)
The mkrel command is used to create a relationship. To see the options in detail, 
type man mkrel in the Neo4j shell.
Let's create another relationship, as demonstrated by the following commands:
neo4j-sh (London,2)$  mkrel -d INCOMING -t CONNECTED <nodeid> --rp 
"{'Airline':'Y','Start-Time':'2300'}"
neo4j-sh (London,2)$  cd 3
neo4j-sh (Paris,3)$  ls
*name =[Paris]
(me)<-[:CONNECTED]-(London,2)
6.	 Let's visualize our first graph in the browser. For this, go to the Neo4j webadmin 
URL and then click on Data Browser; you will see something similar to the 
following screenshot:
We can see two nodes, 2 and 3, in the data visualization, which are connected to each other.
www.it-ebooks.info

Getting Started with Neo4j
12
How it works...
The Neo4j shell comes with the handy utilities of mknode to create new nodes with properties 
and with mkrel to create relationships among them.
Nodes in Neo4j are analogous to files in the Unix filesystem, except with one major difference. 
The difference is that when you create a file in any directory, a relationship automatically gets 
created between the parent directory and the file. Using this relationship, we can browse the 
filesystem, whereas mknode in Neo4j creates disjointed nodes that cannot be browsed, as 
they don't have any relationship between them.
There's more…
To study more about the mknode and mkrel commands, use the man pages under the Neo4j 
shell. If you want to delete an entire graph that you have just created, the following are the 
steps to do so:
1.	 Stop the Neo4j server by using the following command:
$ ./neo4j stop
2.	 Delete the graph.db file under the data directory (assuming that you are using the 
default configuration):
$ rm –rf data/graph.db
Once deleted, the data is not recoverable.
Importing data from the CSV format to 
Neo4j
Graph data comes in different formats, and sometimes it's a combination of two or more 
formats. It is very important to learn about the various ways to import data, which is in 
different formats into Neo4j. In this recipe, you will learn how to import data present in the 
CSV file format into the Neo4j graph database server. A sample CSV file is shown as follows:
www.it-ebooks.info

Chapter 1
13
Getting ready
To get started with this recipe, install Neo4j by using the steps from the earlier recipes 
of this chapter.
How to do it...
There are several methods that you can use to import data which is in the CSV format 
or Excel into Neo4j, which are described in the sections that follow.
Using a batch importer
There is excellent tool written by Michael Hunger, which can be cloned from 
https://github.com/jexp/batch-import.
The CSV file has to be converted into the format specified in the readme file. The tool is very 
flexible in terms of the number of properties and the types of each property. The nodes and 
relationships can be within the same file or within multiple files. The example  file format is 
present in the sample directory. To run the tool, use the following command:
$ wget 
https://dl.dropboxusercontent.com/u/14493611/batch_importer_22.zip
$ unzip batch_importer_22.zip
# Download sample nodes.csv and rels.csv from the github repo under 
sample
$ import.sh test.db nodes.csv rels.csv
$ cp test.db ${NEO4J_ROOT}/data/graph.db
Each parameter in the command has been fully explained in the readme file.
The batch import tool also supports a parallel batch inserter, 
which can speed up the process of importing data from a large 
number of nodes and relationships.
Benchmark figures claimed by the batch importer tool are 2 billion nodes and 20 billion 
relationships in 11 hours (500K elements/second).
This is claimed over the EC2 high I/O instance.
www.it-ebooks.info

Getting Started with Neo4j
14
Using custom scripts
Custom scripts can be written in any language to import data from CSV files. Custom scripts 
give you the advantages of checking various erroneous scenarios, leaving out redundant 
columns, and other flexibilities. For a smaller number of nodes and relationships, custom 
scripts can be written in any language of your choice.
The exact format of the script will depend on the CSV file. You can write the script as follows:
#Bash Script for importing nodes
NEO4J_ROOT="/var/lib/neo4j"
while read LINE
do
  name=`echo $LINE | awk -F "," '{print $3}'`
  ${NEO4J_ROOT}/bin/neo4j-shell -c mknode --np \"{'name':$name}\" 
-v
done
Downloading the example code
You can download the example code files from your account at 
http://www.packtpub.com for all the Packt Publishing 
books you have purchased. If you purchased this book elsewhere, 
you can visit http://www.packtpub.com/support and 
register to have the files e-mailed directly to you.
Similar scripts can be written for relationships too, as shown here:
#Bash Script for creating relationships
#Format of csv should be startnode,endnode,type,direction
NEO4J_ROOT="/var/lib/neo4j"
IFS=","
while read LINE
do
  echo $LINE
  array=($LINE)
  ${NEO4J_ROOT}/bin/neo4j-shell -c cd -a ${array[0]} mkrel -d 
${array[3]} -t ${array[2]} ${array[1]}
done
This task can also be achieved in Python using the py2neo module, as shown in the 
following script:
#Sample Python code to create nodes from csv file
import csv
from py2neo import neo4j, cypher
from py2neo import node, rel
www.it-ebooks.info

Chapter 1
15
graph_db = neo4j.Graph("http://localhost:7474/db/data/")
ifile = open('nodes.csv', "rb")
reader = csv.reader(ifile)
rownum = 0
for row in reader:
  nodes = graph_db.create({"name":row[2]})
ifile.close()
A similar Python code can be written for creating relationships, too. The py2neo module 
can also be used to create a batch request, wherein there's a whole list with parameters 
as shown in the following code:
records = [(101, "A"), (102, "B"), (103, "C")]
graph_db = neo4j.Graph ("http://localhost:7474/db/data/")
batch = neo4j.WriteBatch(graph_db)
for emp_no, name in records:
  batch.get_or_create_indexed_node("Employees", "emp_no", emp_no,
{
  "emp_no": emp_no, "name": name
})
nodes = batch.submit()
How it works...
Batch import performance is achieved by skipping all the transactional behavior and losing 
ACID guarantees. If the batch import fails, the database will be broken, possibly irrecoverably, 
and lead to the loss of all the information.
See also
Custom scripts can be written for REST as well as for the embedded interfaces of Neo4j. For 
the full cookbook on py2neo recipes, refer to http://py2neo.org/2.0/cookbook.html.
www.it-ebooks.info

Getting Started with Neo4j
16
Importing data from RDBMS to Neo4j
Graph data comes in different formats, and sometimes it's a combination of two or more 
formats. It is very important to learn about the various ways to import data having different 
formats into Neo4j. In this recipe, you will learn how to import data present in an RDBMS 
database, such as MySQL, SQL Server, into the Neo4j graph database server. Following is a 
sample figure for a graph:
Getting ready
To get started with this recipe, install Neo4j by using the steps from the earlier recipes of 
this chapter.
How to do it...
The data from RDBMS can be imported by using the two methods described here.
Using the Neo4j SQL importer tool
Peter Neubauer, the man behind the Neo technology, has developed an excellent tool for 
this purpose, called the Neo4j SQL importer tool, which takes SQL dumps. The tool can 
be cloned from his repository over GitHub, which is available at https://github.com/
peterneubauer/sql-import.
www.it-ebooks.info

Chapter 1
17
Using custom scripts
Custom scripts can be written for a particular RDBMS schema, which is more useful as it is 
designed by keeping the schema in mind. Take an example of the following schema:
The Orders and Products tables will represent nodes in Neo4j, while OrderDetails will 
represent the relationships between them. Relationships can be in both the directions. So, 
starting from the Products node, we can easily find out how many different Orders have been 
made for that product and vice versa.
How it works...
In the SQL import tool, most of the things revolve around the primary key. Each of the columns 
can be made a node, and it will have a relationship with the node that is storing the primary 
key. In the case of relationships with other tables, the relationship will be made on the 
foreign key.
There's more…
One of the best use cases of Neo4j is to build a recommendation engine on top of it. Since 
most of the data now resides in traditional RDBMS, the very first step will involve importing 
the data into Neo4j.
www.it-ebooks.info

Getting Started with Neo4j
18
Importing data from the Geoff format to 
Neo4j
Graph data comes in different formats, and sometimes it's a combination of two or more 
formats. It is very important to learn about the various ways to import data having different 
formats into Neo4j. In this recipe, you will learn how to import data that is present in the 
Geoff format, into the Neo4j graph database server.
Getting ready
To get started with this recipe, install Neo4j by using the steps from the earlier recipes of 
this chapter.
How to do it...
The data in the Geoff format can be easily imported using the load2neo tool available at 
http://nigelsmall.com/load2neo.
The following is the code for building the tool:
wget http://nigelsmall.com/d/load2neo-0.6.0.zip
This ZIP archive contains three files: two JAR files which that need to be copied to your Neo4j 
plugin directory and a neo4j-server.properties file that contains has content to be 
added to the identically named file within the Neo4j conf directory. This is a single line that 
mounts the plugin at the correct URI offset.
How it works...
Geoff is a text-based interchange format for Neo4j graph data that should be instantly 
readable to anyone familiar with Cypher, on which its syntax is based.
This is the syntax of Geoff:
(alice {"name":"Alice"})
(bob {"name":"Bob"})
(carol {"name":"Carol"})
(alice)<-[:KNOWS]->(bob)<-[:KNOWS]->(carol)<-[:KNOWS]->(alice)
www.it-ebooks.info

Chapter 1
19
Bulk load
Bulk loads can be executed by running the following curl command from the command line:
curl -X POST http://localhost:7474/load2neo/load/geoff -d '(a)<-
[:KNOWS]->(b)'
See also
To know more about the Geoff format, go to http://nigelsmall.com/geoff.
Importing data from OrientDB to Neo4j
There are tons of options available when it comes to graph databases, such as FlockDB, 
AllegroGraph, InfiniteGraph, OrientDB, and so on. It is important to learn how to migrate data 
from any one of these to Neo4j if you are thinking of migrating to Neo4j.
In this recipe, you will learn how to migrate data from OrientDB to the Neo4j server.
Getting ready
To get started with this recipe, install Neo4j using the steps from the earlier recipes of 
this chapter.
How to do it...
OrientDB is an open source GraphDB, with a mix of features taken from document databases 
and object orientation.
Exporting in the JSON format
OrientDB has given us the utility to export data in the JSON format. We can access this utility 
by typing the following commands in a terminal:
$ ./console.sh
 orientdb> export database graph.json
The JSON format is as follows:
"records": [{
            "@type": "d", "@rid": "#12:476", "@version": 0, "@class": 
"Whiz",
            "id": 476,
            "date": "2011-12-09 00:00:00:000",
www.it-ebooks.info

Getting Started with Neo4j
20
            "text": "Los a went chip, of was returning cover, In the",
            "@fieldTypes": "date=t"
          },{
            "@type": "d", "@rid": "#12:477", "@version": 0, "@class": 
"Whiz",
            "id": 477,
            "date": "2011-12-09 00:00:00:000",
            "text": "He in office return He inside electronics for 
$500,000 Jay",
            "@fieldTypes": "date=t"
          }
Now, this data can be parsed using a custom script, which can insert data into Neo4j.
Using Gremlin
Gremlin can be used to export data in the XML format from OrientDB and to import data into 
Neo4j, as shown here:
gremlin> graph = new OrientGraph("local:<path_of_db> ");
gremlin> graph.saveGraphML('graph.xml');
gremlin> graph = new Neo4jGraph('data/graph.db');
gremlin> graph.loadGraphML('graph.xml');
Gremlin can also be used to get all the nodes and relationships from OrientDB, which can be 
inserted into Neo4j, as follows:
gremlin> graph = new OrientGraph("local: <path_of_db> ");
gremlin> graph.V # Get All Vertices
gremlin> graph.E # Get All Edges
How it works...
Gremlin is a graph traversal language. Gremlin works over those graph databases/frameworks 
that implement the Blueprints property graph data model. Fortunately, OrientDB and Neo4j 
are among them.
See also
To find out more about Gremlin, go to http://www.tinkerpop.com/.
www.it-ebooks.info

Chapter 1
21
Importing data from InfiniteGraph to Neo4j
There are tons of options available when it comes to graph databases, such as FlockDB, 
AllegroGraph, InfiniteGraph, OrientDB, and so on. It is important to learn how to migrate data 
from any one of these to Neo4j if you are thinking of migrating to Neo4j.
In this recipe, you will learn how to migrate data from InfiniteGraph to the Neo4j server.
Getting ready
To get started with this recipe, install Neo4j by using the steps from the earlier recipes of 
this chapter.
How to do it...
InfiniteGraph, a product of Objectivity, Inc., is an enterprise-proven, distributed graph database 
that can handle the needs of big data.
The best way to import data from InfiniteGraph to Neo4j is via Gremlin, as shown here:
gremlin> import com.tinkerpop.blueprints.impls.ig.*
gremlin> graph = new IGGraph("neo_data.boot")
gremlin> graph.V # Gives all the nodes
gremlin> graph.E # Gives all the edges
gremlin> graph.loadGraphML('graph.xml');
gremlin> graph = new Neo4jGraph('neo/graph.db');
gremlin> graph.loadGraphML('graph.xml');
Infinite supports Blueprints, so it works with Gremlin, which means that all the methods also 
work with InfiniteGraph.
How it works...
Gremlin is a graph traversal language. Gremlin works over those graph databases/frameworks 
that implement the Blueprints property graph data model. Fortunately, OrientDB and Neo4j 
are among them.
www.it-ebooks.info

Getting Started with Neo4j
22
There's more…
To know more about Gremlin, go to http://www.tinkerpop.com/.
Importing data from the DEX graph database 
to Neo4j
There are tons of options available when it comes to graph databases, such as FlockDB, 
AllegroGraph, InfiniteGraph, OrientDB, and so on. It is important to learn how to migrate data 
from any one of these to Neo4j, if you are thinking of migrating to Neo4j.
In this recipe, you will learn how to migrate data from the DEX graph database to the 
Neo4j server.
Getting ready
To get started with this recipe, install Neo4j by using the steps from the earlier recipes of 
this chapter.
How to do it...
DEX is a highly scalable graph database solution, which is mostly written in Java and C++. 
The key feature of DEX is that its query performance has been optimized for large graph 
databases. Also, it's very lightweight, which allows the storage of billions of nodes and 
relationships at a very low metadata storage cost.
The default exporter can be used to export the DEX graph database to GraphML, which can 
be easily loaded into Neo4j. This is done by using the following lines of code:
DefaultExport graph = new DefaultExport();
g.export("dex_export.graphml", ExportType.YGraphML, graph);
Gremlin can also be used to solve the problem, as shown here:
gremlin> graph = new DexGraph("neo/data.dex");
gremlin> graph.saveGraphML('graph.xml');
gremlin> graph = new Neo4jGraph('neo/graph.db');
gremlin> graph.loadGraphML('graph.xml');
www.it-ebooks.info

Chapter 1
23
How it works...
Gremlin is a graph traversal language. Gremlin works over those graph databases/frameworks 
that implement the Blueprints property graph data model. Fortunately, OrientDB and Neo4j 
are among them.
See also
To know more about Gremlin, go to http://www.tinkerpop.com/.
Common configurations of Neo4j
Neo4j is very flexible in terms of configuration, and it can be changed to achieve performance, 
security, and flexibility.
In this recipe, you will learn about the common configuration files of Neo4j.
Getting ready
To get started with this recipe, install Neo4j using the steps from the earlier recipes of 
this chapter.
Before getting into the recipe, here are some important points that you need to consider:
f
f
The main configuration file can be found at conf/neo4j-server.properties
f
f
The default server logging configuration file is at conf/log4j.properties
f
f
Tuning parameters can be tuned in the conf/neo4j.properties file
f
f
The configuration file for a wrapper used in daemonizing can be found at conf/
neo4j-wrapper.properties
f
f
The logging configuration for the HTTP protocol is found in the conf/neo4j-http-
logging.xml file
How to do it...
The Neo4j shell can also be used to access a remote graph database. To do so, perform the 
following steps:
1.	 Change the following settings:
In the server primary configuration file, add this line:
enable_remote_shell = true
www.it-ebooks.info

Getting Started with Neo4j
24
The default port for remote shell access can be changed by adding the following line:
enable_remote_shell_port=1234
Now, you can access the remote database.
2.	 The Neo4j web console, by default, can be accessed only from the localhost. If you 
want to access the web console from any machine (which you should never do as 
anyone can then play with your graph database), then perform the following tasks:
1.	 In the server primary configuration file, uncomment this line:
org.neo4j.server.webserver.address=0.0.0.0
The default port for remote shell access can be changed by editing the 
following line:
org.neo4j.server.webserver.port=7473
2.	 Now, restart the Neo4j server using the following command:
./neo4j restart
How it works...
Neo4j comes with lots of configuration options, and by changing the parameters in different 
configuration files, you can configure each part of it.
There's more…
To find out more about the configuration options, check out http://neo4j.com/docs/
stable/server-configuration.html.
Running multiple instances of Neo4j over a 
single machine
Many times, there will be a need to run multiple instances of Neo4j over a single machine.
In this recipe, you will learn about how to run multiple instances of Neo4j.
Getting ready
To get started with this recipe, install Neo4j by using the steps from the earlier recipes of 
this chapter.
www.it-ebooks.info

Chapter 1
25
How to do it...
Neo4j can handle only a single graph instance. To run multiple graph instances, you have to 
run multiple Neo4j servers over the same machine, as follows:
1.	 Replicate the configuration file for each instance and change the following 
parameters:
org.neo4j.server.database.location=data/graph.db
Change this path for each instance by setting different database paths for different 
instances. Also, for each instance, set different ports for the web console, which is 
shown in the following parameter:
org.neo4j.server.webserver.port=5678
2.	 Now, restart the Neo4j server by using the following command:
./neo4j restart
How it works...
Neo4j can handle only one instance at a time. In order to run multiple instances of Neo4j, 
we have to replicate the files and change the graph database directory of each instance.
See also
To know more about the configuration options, check out http://neo4j.com/docs/
stable/server-configuration.html.
Building Neo4j from the source
Neo4j is an open source software that is readily available to other open source developers to 
change the source code according to their requirements.
In this recipe, you will learn how to build Neo4j from the source.
Getting ready
To get started with this recipe, install JDK and Maven before building Neo4j.
www.it-ebooks.info

Getting Started with Neo4j
26
How to do it...
Run the following commands to build Neo4j from the source:
git clone https://github.com/neo4j/neo4j.git
cd neo4j
mvn clean install
A good approach for this recipe will be to go through the readme file, which is present in 
the top level directory, and follow the steps given in that file. For more information, please 
refer to https://github.com/neo4j/neo4j/.
How it works...
Neo4j is open source and Java based. It is built using Maven.
There's more…
To know more about how to build Neo4j from the source, go to https://github.com/
neo4j/neo4j/.
www.it-ebooks.info

27
2
Connecting to Neo4j
In this chapter, we will cover the following recipes:
f
f
Accessing Neo4j from the command line using the Neo4j shell
f
f
Accessing Neo4j from the command line using curl
f
f
Accessing Neo4j from the Java libraries
f
f
Accessing Neo4j using the Java REST bindings
f
f
Mapping Neo4j to Java-annotated classes using Spring Data Neo4j
f
f
Accessing the embedded Neo4j from Python
f
f
Accessing Neo4j from Python using the REST bindings
f
f
Annotate the Python object model to the Neo4j graph database
f
f
Accessing the embedded Neo4j from Ruby
f
f
Accessing Neo4j from Ruby using the REST bindings
f
f
Accessing Neo4j from Scala
f
f
Accessing Neo4j from .NET
f
f
Accessing Neo4j from PHP
f
f
Accessing Neo4j from Node.js
www.it-ebooks.info

Connecting to Neo4j
28
Introduction
In this chapter, we will take a look at the various ways in which you can connect to Neo4j. 
Neo4j is a high-performance graph database, which gives the flexibility to access it from 
various languages and in different options. The two most popular ones being the embedded 
option and the server mode. The embedded mode gives the user the power to embed it within 
the application to get high performance with low latency, whereas the server mode gives 
the user the flexibility to access the services using the REST endpoint, making it (virtually) 
language-neutral. Let's briefly discuss both the modes:
f
f
The embedded mode: The Neo4j graph database can be directly embedded into the 
application, making it look like a single binary executable file. It can be accessed 
using the appropriate Java binding.
f
f
The server mode: The Neo4j graph database can run in the server mode, in which 
its services can be accessed from any host, using the REST endpoints that 
are exposed by the Neo4j server and various other language bindings.
In this chapter, we will discuss both the options with some of the commonly used 
programming languages.
Accessing Neo4j from the command line 
using the Neo4j shell
Often, you will find yourself in the need of firing simple Neo4j operations, either to create 
a node or delete a node, query the total number of nodes, or to poke into the Neo4j graph 
database. With Neo4j, this can easily be done through the command-line interface.
Neo4j can also be accessed from the command line like the Unix shell. Although it is less 
likely that this mode is going to be used in production, it's very handy when it comes to 
development and debugging. In this recipe and the next recipe, we will explore the two ways to 
connect to Neo4j from the command-line interface, which are using the Neo4j shell and curl.
In this recipe, we will learn how to connect to Neo4j from the command-line interface.
Getting ready
Neo4j ships with a command-line client called the Neo4j shell. The Neo4j shell is a fully 
featured interactive shell that supports line editing, history, and various help options. Using 
man followed by a Neo4j command, you can also get help on how each command works.
www.it-ebooks.info

Chapter 2
29
How to do it...
The following steps will get you started with this recipe:
1.	 You can also use the Neo4j shell to connect to a local or remote Neo4j graph 
database. The path of the Neo4j shell is in the bin directory. To get a list of the 
command-line options that the Neo4j shell offers, type the following command in 
the shell:
$ ${NEO4J_ROOT}/bin/neo4j-shell  –h
2.	 The most typical use would be to connect to the local system running the Neo4j 
graph server instance, which can be done via the following command:
$ ${NEO4J_ROOT}/bin/neo4j-shell
3.	 Before starting the Neo4j shell, it's required that you start the Neo4j server to 
which the shell is connected to. This can done using following command:
$ ./neo4j start
4.	 The Neo4j shell can also be accessed from the web administration console by 
opening http://<ip>:7474/webadmin in the browser.
5.	 After the preceding step is executed, click on the Power tool Console on the top row 
of the screen. What you see here is the web console of Neo4j, which demonstrates 
the usage of the Neo4j shell from the web interface:
www.it-ebooks.info

Connecting to Neo4j
30
How it works...
Neo4j works in a similar fashion to the Unix filesystem, where nodes are represented as files 
and relationships, among them, as links between them. The various shell commands, such as 
ls, pwd, cd, and so on, work in a similar fashion with the Neo4j shell, where they can be used 
to iterate the graph.
Accessing Neo4j from the command line 
using curl
Curl is a popular command-line tool used to access and transfer the data using various 
protocols. Because the REST API uses the HTTP protocol to transfer data, the curl tool becomes 
a command-line tool that is used to access the REST API, which is exposed by the Neo4j graph 
database server.
In this recipe, we will learn how to access the Neo4j graph database server using curl.
Getting ready
The service root endpoint by default is http://host:port/db/data/, which can also 
be seen through the web interface by opening the endpoint URL in the browser. You will see 
something similar to this:
www.it-ebooks.info

Chapter 2
31
How to do it...
Let's access the Neo4j graph database server using the REST endpoint via the curl 
command-line tool:
1.	 Start the Neo4j graph database server using the following command:
$ ./neo4j start
To check whether things are running fine, open http://localhost:7474/db/
data/ in a browser.
The browser sends the text/HTML as the accepted encoding, but in curl, we will set 
the accept encoding to application/json. This will make it easy to parse, using 
the following command:
$ curl -H Accept:application/json -H Content-
Type:application/json -v http://localhost:7474/db/data/
Newer Neo4j versions are password secured by default, so users need 
to specify the username/password in curl using the -u option.
The output will consist of the return status, and if it's 200 OK, then we are successfully 
able to access the REST endpoint. You will also see something similar to this:
The preceding output shows the important parameters and various REST endpoints.
www.it-ebooks.info

Connecting to Neo4j
32
2.	 Let's create one node using the REST endpoint:
$ curl -X POST -H Accept:application/json -v 
http://localhost:7474/db/data/node
After this command is executed, the following will appear on your screen:
We have successfully created one node with the id 3 node, as depicted in the json 
output.
3.	 Now we create another node with some properties. In this example, we are going 
to create one node with the property name Neo4j:
$ curl -X POST -H Accept:application/json -H Content-
Type:application/json -d '{"name":"Neo4j"}' -v 
http://localhost:7474/db/data/node
4.	 You can specify as many properties you want in the JSON format:
$ curl -X POST -H Accept:application/json -H Content-
Type:application/json -d '{"name":"Neo4j","type":"Graph 
Database"}' -v http://localhost:7474/db/data/node
5.	 Let's query for the node we have just created:
$ curl -H Accept:application/json -H Content-
Type:application/json  http://localhost:7474/db/data/node/16
Here, 16 denotes the node ID of the recently created node.
6.	 Now, we will delete this node using the curl command line:
$ curl -X DELETE  -v http://localhost:7474/db/data/node/16
www.it-ebooks.info

Chapter 2
33
7.	
Now, we will create the two nodes A and B and a relationship between them, 
which is A KNOWS B:
$ curl -X POST -H Accept:application/json -H Content-
Type:application/json -d '{"name":"A"}' -v 
http://localhost:7474/db/data/node
$ curl -X POST -H Accept:application/json -H Content-
Type:application/json -d '{"name":"B"}' -v 
http://localhost:7474/db/data/node
$ curl -X POST -H Accept:application/json -H Content-
Type:application/json -d 
'{"to":"http://localhost:7474/db/data/node/1","type":"KNOWS"}' 
-v http://localhost:7474/db/data/node/2/relationships
We have successfully created a relationship between node 2 and node 1, 
as shown here:
8.	 Let's list all the relationships of node 2:
$ curl -H Accept:application/json -H Content-
Type:application/json  
http://localhost:7474/db/data/node/2/relationships/all
www.it-ebooks.info

Connecting to Neo4j
34
The result of this command is as follows:
How it works...
Neo4j exposes the REST API interface with well-defined interfaces, which makes it compatible 
with any standard HTTP client. We can see that the REST API endpoint is very powerful and 
can be used to interact with Neo4j in a flexible language-agnostic way. It also provides you 
with a very simple way of accessing the Neo4j graph database remotely.
Curl comes in handy for the Neo4j developers who know the shell commands and want to play 
with Neo4j.
Accessing Neo4j from the Java libraries
Java is at the sweet spot when it comes to the Neo4j language bindings, as Neo4j itself 
is implemented in Java. Most of the other language bindings, which access Neo4j as an 
embedded application, have been built on Java. In this recipe, we will take a look at the 
various ways to connect to Neo4j in Java.
In this recipe, we will learn how to access Neo4j in the most powerful way.
www.it-ebooks.info

Chapter 2
35
Getting ready
Neo4j can be embedded into the Java application, which can provide you with 
high-performance query results. Follow these steps to embed it into the application:
1.	 Neo4j JAR files can be found in the lib directory of the source code. Include all the 
JAR files present in this directory. Alternatively, the JAR files are also present in the 
Maven repository.
2.	 Add Neo4j to the build path and also add it as a dependency. Detailed information 
on this can be found at http://docs.neo4j.org/chunked/milestone/
tutorials-java-embedded-setup.html.
How to do it...
Let's create our first graph using the Java embedded libraries:
1.	 Instantiate EmbeddedGraphDatabase in order to create a new database or use an 
existing one:
embed = new GraphDatabaseFactory().newEmbeddedDatabase( 
NEO4J_DB_PATH );
2.	 Now let's create a node with the following properties:
Node node = embed.createNode();
node.setProperty("name","Neo4j");
node.setProperty("Message","Hello World");
We have successfully created a node with the two properties, name and Message.
3.	 Now we will read back the properties of the node we have just created using the 
following command:
System.out.print( node.getProperty( "name" ) );
System.out.print( node.getProperty( "message" ) );
4.	 The node can be deleted by calling the delete method over the instance, as follows:
node.delete();
5.	 Now let's create two nodes and a relationship between them:
node1 = embed.createNode();
node1.setProperty("name","A");
node2 = embed.createNode();
node2.setProperty("name","B");
rel = node1.createRelationshipTo( node2, RelTypes.KNOWS );
rel.setProperty("type","Friend");
www.it-ebooks.info

Connecting to Neo4j
36
The nodes and the relationship will look like this:
Name = A
Name = B
KNOWS
Type = Friend
The Java embedded binding is very powerful and lots of it is left to be explored by you.
How it works...
Neo4j offers a rich set of possibilities when it comes to Java. The Neo4j graph database 
software itself is written in Java, enabling many low-level APIs to be directly exposed using 
the Java interface.
Using the Java API in a nontransactional batch insertion facility, it is 
possible to insert millions of nodes and relationships in seconds.
Accessing Neo4j using the Java REST 
bindings
Neo4j can also be accessed using the Java REST bindings, which allows it to be accessed 
from remote nodes easily. In this recipe, we will take a look at the ways of accessing Neo4j 
from Java using the REST bindings.
Getting ready
The Neo4j REST interface provides an easy way to access Neo4j graph database remotely.
Follow these instructions to go through this recipe:
Start the Neo4j graph database server using the following command:
$ ./neo4j start
To check whether the REST interface is running fine, open http://localhost:7474/db/
data/ in a browser.
www.it-ebooks.info

Chapter 2
37
How to do it...
This problem can be dealt with in two ways, which are described as follows:
Developing your own Neo4j REST client
There are many REST Java client libraries that can be utilized to write your own REST API 
client for Neo4j. The bad part is that you have to deal with all the possible scenarios and error 
cases. One example is using the Jersey client, which is shown in the following code:
final String ROOT_URI = "http://localhost:7474/db/data/";
final String nodeEntry = ROOT_URI + "node";
WebResource res = Client.create().resource( nodeEntry );
ClientResponse res = resource.accept( MediaType.APPLICATION_JSON )
  .type( MediaType.APPLICATION_JSON )
  .entity( "{}" )
  .post( ClientResponse.class );
URI loc = res.getLocation();
res.close();
Using the Java Neo4j REST binding
The Java REST binding can be downloaded from http://m2.neo4j.org/content/
repositories/releases/org/neo4j/neo4j-rest-graphdb/.
You need to perform the following steps:
1.	 Download the JAR file from the preceding URL according to your Neo4j server version.
2.	 Add it to your class path.
3.	 Using this line of code, you can test the connection:
RestAPI neo4j_db = new RestAPIFacade("http://localhost:7474/db/
data");
4.	 Let's create a node using this binding:
Transaction tr = neo4j_db.beginTx();
Map<String,Object> pr=new HashMap<String, Object>();
pr.put("id",1);
pr.put("name","A");
Node n=neo4j_db.createNode(props);
tr.success();
tr.finish();
So, we have successfully cooked our recipe and have learned how to connect to Neo4j 
from Java.
www.it-ebooks.info

Connecting to Neo4j
38
How it works...
The Neo4j REST API works in a similar fashion, as we have already seen in the Accessing 
Neo4j from the command line using curl recipe of this chapter.
Mapping Neo4j to Java-annotated classes 
using Spring Data Neo4j
Spring Data Neo4j can increase the productivity of Java by many folds when dealing with Neo4j. 
It provides a Plain Old Java Objects (POJO) based programming model that significantly reduces 
the amount of boilerplate code needed to develop Neo4j-based applications. It helps the 
developer to think in terms of an object-oriented approach, which is easily extendible to add 
new data models and enhance existing ones (properties, entities, and relationships).
In this recipe, we will learn the use of Neo4j with Spring Data Neo4j.
Getting ready
To step through this recipe, we will need the following configurations to be set before:
The following is the Maven configuration:
<dependency>
  <groupId>org.springframework.data</groupId>
  <artifactId>spring-data-neo4j</artifactId>
  <version>2.3.1.RELEASE</version>
</dependency>
<repositories>
  <repository>
    <id>spring-neo4j</id>
    <name>Spring Neo4j Data </name>
    <url>http://maven.springframework.org/milestone </url>
  </repository>
</repositories>
Follow these steps to go through this recipe:
1.	 Configure AspectJ by including the following XML in the pom.xml file to enable it 
in the build process, as shown in the following XML code:
<build>
  <plugins>
    <plugin>
      <groupId>org.pactkpub.cookbook</groupId>
      <artifactId>aspectj-maven-plugin</artifactId>
www.it-ebooks.info

Chapter 2
39
      <version>1.1</version>
      <configuration>
        <aspectLibrary>
          <groupId>org.springframework</groupId>
          <artifactId>springneo4j-aspects</artifactId>
        </aspectLibrary>
        <aspectLibrary>
          <groupId>org.springframework.data</groupId>
          <artifactId>spring-neo4j</artifactId>
        </aspectLibrary>
        <source>1.6</source>
        <target>1.6</target>
      </configuration>
      <executions>
        <execution>
          <goals>
            <goal>test-compile</goal>
            <goal>compile</goal>
          </goals>
        </execution>
      </executions>
      <dependencies>
        <dependency>
          <groupId>org.aspectj</groupId>
          <artifactId>aspectjrt</artifactId>
          <version>1.7.11.RELEASE</version>
        </dependency>
        <dependency>
          <groupId>org.aspectj</groupId>
          <artifactId>aspectjtools</artifactId>
          <version>1.7.11.RELEASE</version>
        </dependency>
      </dependencies>
    </plugin>
  </plugins>
</build>
2.	 Now, configure Spring using the XML namespace for your Neo4j application, as 
shown in the following code:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <beans 
xmlns="http://www.springframework.org/schema/beans"
    
xmlns:context="http://www.springframework.org/schema/contex
t"
www.it-ebooks.info

Connecting to Neo4j
40
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    
xmlns:neo4j="http://www.springframework.org/schema/data/neo
4j"
    xsi:schemaLocation="
      http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-
beans.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/spring-
context.xsd
      http://www.springframework.org/schema/data/neo4j
  http://www.springframework.org/schema/data/neo4j/spring-
neo4j.xsd">
    <context:annotation-config/>
    <neo4j:config storeDirectory="target/config-test"/>
</beans>
The exact versions might change with newer Neo4j versions and 
other libraries, which are used here.
How to do it...
We have successfully set up Spring Data Neo4j. Now let's annotate our first Neo4j node and 
relationship in terms of annotated classes.
Graph Entities
Annotate your Movie and Actor classes, where the Movie class has a relationship with 
the Actor class for the actor that acts in that movie:
@
NodeEntity
public class Movie {
  @
  Indexed
  private string movie_name;
  @
  GraphId Long movie_id;
  @
  RelatedTo(type = "acts_in", direction = Direction.INCOMING, 
elementClass = Actor.class)
  @ NodeEntity
  public class Actor {
    @
    Indexed
www.it-ebooks.info

Chapter 2
41
    private string actor_name;
    @
    GraphId Long actor_id;
    @
    RelatedTo(type = "acts_in", direction = Direction.OUTGOING, 
elementClass = Movie.class)
Spring Data Neo4J offers advanced features to map annotated entity classes to the Neo4j 
graph database. The template programming model is equivalent to the well-known Spring 
templates and builds the basis for interaction with the graph. It is also used for the advanced 
repository support.
How it works...
Spring Data Neo4j enables developers to map annotated classes directly to the Neo4j graph 
database. Rather than thinking in terms of nodes and relationships, it lets programmers 
apply a thought process in classes, which is well understood, and all the boilerplate code 
generation is taken care of by the framework. The classes can easily be extended by adding 
new properties and methods that enhance the capability of the graph. For more information, 
have a look at https://github.com/spring-projects/spring-data-neo4j.
Accessing the embedded Neo4j from Python
Python is getting increasingly popular nowadays, and, in this recipe, we will learn how to 
connect to the Neo4j embedded graph server from the Python client.
Getting ready
Embedded Neo4j is an excellent binding module available in Python to access the Neo4j 
embedded database. The following steps describe the use of this module:
1.	 Install the JPype Python module, as shown in the following command:
$ sudo apt-get install python-jpype
It can also be installed from the source available at http://sourceforge.net/
projects/jpype/files/JPype/.
2.	 Install Neo4j embedded using either pip or easy_install, as follows:
$ pip install neo4j-embedded
$ easy_install neo4j-embedded
www.it-ebooks.info

Connecting to Neo4j
42
How to do it...
Perform the following steps in order to access Neo4j from Python:
1.	 Let's create our first node using the following code:
import neo4j
db_obj =  neo4j.GraphDatabase(DB_PATH)
# All write operations on graph database happens in 
transaction
with db_obj.transaction:
  node = db_obj.node(name="neo4j")
2.	 Now we will create our first relationship between the nodes A and B:
import neo4j
db_obj =  neo4j.GraphDatabase(DB_PATH)
# All write operations on graph database happens in 
transaction
with db_obj.transaction:
  node1 = db_obj.node(name="A")
  node2 = db_obj.node(name="B")
  rel = node1.knows(node2,name="friend")
db_obj.shutdown()
3.	 We have successfully created a node and a relationship using Python Neo4j 
embedded binding. To use it with recent versions of Neo4j, set the allow_store_
upgrade=true in the ${NEO4J_ROOT}/conf/neo4j.properties file.
How it works...
JPype allows Python programs to have complete access over the Java libraries. This has been 
achieved by interfacing them at the native level.
Accessing Neo4j from Python using the 
REST bindings
The REST interface is widely used and in this recipe, we will learn how to access Neo4j from 
Python using the REST Bindings.
Getting ready
The py2neo module (http://py2neo.org/2.0/) is an excellent Python binding module 
used to connect to the Neo4j REST API server.
www.it-ebooks.info

Chapter 2
43
The py2neo module can be installed from both pip and easy_install, as shown here:
$ pip install py2neo
$ easy_install py2neo
How to do it...
The following steps will get you started with this recipe:
1.	 First, we will create our first node assuming the default installation, as shown in the 
following code:
from py2neo import neo4j
graph = neo4j.GraphDatabaseService(ENDPOINT_URL)
graph.create(node(name="A")
2.	 Next, let's create our first relation using the py2neo module:
from py2neo import neo4j
graph = neo4j.Graph(ENDPOINT_URL)
graph.create(node(name="A"),
             node(name="B"))
rel(1, "PLAYS WITH", 2)
rel(2, "FATHER OF", 1)
Annotate the Python object model to the 
Neo4j graph database
In this recipe, we will learn how to map the Python object model to the Neo4j graph 
database server.
Getting ready
Neomodel is an excellent binding module used for mapping an object model to the Neo4j 
graph database, thinking in terms of objects and further enhancing properties, relationships, 
and so on.
Neomodel can be installed from both via pip and easy_install:
$ pip install neomodel
$ easy_install neomodel
Now, set the location of Neo4j via the environment variable:
export NEO4J_REST_URL="http://<ip:port>/db/data"
www.it-ebooks.info

Connecting to Neo4j
44
How to do it...
Let's create our first relationship model using Neomodel, as shown in the following code:
from neomodel import (StructuredNode, StringProperty, 
IntegerProperty,RelationshipTo, RelationshipFrom)
class Movie(StructuredNode):
    name = StringProperty(unique_index=True, required=True)
    actors = RelationshipFrom('Actor', 'ACTED_IN')
class Actor(StructuredNode):
    name = StringProperty(unique_index=True, required=True)
    acted = RelationshipTo('Movie', 'ACTED_IN')
Let's create our first movie Titanic:
titanic = Movie(name="Titanic").save()
Let's create two actors Leonardo and Kate:
leo = Actor(name="Leonardo DiCaprio").save()
kate = Actor(name="Kate Winslet").save()
As we all know that both Leonardo and Kate acted in titanic, let's create our first 
relationship:
Leo.acted.connect(titanic)
Kate.acted.connect(titanic)
How it works...
The Neomodel underneath utilizes the py2neo library to create the graph. This excellent 
Neomodel library hides all the complexities of mapping the Python classes to the Neo4j 
graph database.
For further information on Neomodel, you can refer to https://github.com/
robinedwards/neomodel.
Accessing the embedded Neo4j from Ruby
Many modern web apps are built on Ruby and Rails, so it is important to learn how to access 
Neo4j embedded using Ruby.
Getting ready
Andreas Ronge has written the Ruby bindings in JRuby, which utilizes the neo4j Java library 
underneath it. It can be embedded into an existing Rails application very easily.
www.it-ebooks.info

Chapter 2
45
This project can be accessed at https://github.com/neo4jrb/neo4j-core.
This project comes with an excellent documentation on how to use it with the Rail application.
How to do it...
Install gem neo4j-core on the machine, using the gem install neo4j-core command.
The complete documentation has been provided at https://github.com/neo4jrb/
neo4j-core/wiki.
One sample example of creating nodes and relationships is shown as follows:
node = Neo4j::Node.create({name: 'neo'}, :hero, :human)
puts "Created node #{node[:name]} with labels 
#{node.labels.join(', ')}"
n1 = Neo4j::Node.create
n2 = Neo4j::Node.create
rel = n1.create_rel(:knows, n2, since: 2015)
How it works...
The Neo4j Ruby library is a JRuby wrapper, which makes it compliant with the JVM, and helps 
you access the Java libraries using Ruby.
Accessing Neo4j from Ruby using the REST 
Bindings
In this recipe, we will learn how to access the Neo4j graph database server from Ruby using 
the REST bindings.
Getting ready
The Neo4j REST server can be accessed using an excellent neography gem module, which 
claims to be a thin wrapper over the Neo4j REST API interface.
The following steps will get you started with neography gem:
1.	 The neography gem modules can be installed on the machine using the gem 
install command:
gem install 'neography'
www.it-ebooks.info

Connecting to Neo4j
46
2.	 The neography module also requires the gem module in the Ruby code, so configure 
and initialize the neography gem modules with the following code:
@graph = Neography::Rest.new({ :protocol   => 'http://',
                               :server     => IP_ADDRESS,
                               :port       => PORT,
})
How to do it...
Follow these steps to go through this recipe:
1.	 Let's create our graph using neography using the following code:
node1 = @graph.create_node("name" => "A")
node2 = @graph.create_node("name" => "B")
@graph.create_relationship("mother of",node1,node2)
@graph.create_relationship("daughter of",node2,node1)
2.	 Then, let's execute a Cypher query, the default language of Neo4j:
@graph.execute_query("start n=node(10) return n")
3.	 The neography gem module can also be used to do bulk operations, as shown here:
@graph.batch [:create_node, {"location" => "A"}],
           [:create_node, {"college" => "B"}]
Neography can be used extensively to perform operations exposed by the Neo4j REST server. 
It is available as a GitHub project at https://github.com/maxdemarzi/neography/.
Accessing Neo4j from Scala
Scala is a general purpose language, which is being increasingly used for high-performance 
applications, as it has been implemented over JVM, which makes interoperability easier with 
the existing Java libraries.
In this recipe, we will learn how to access the Neo4j graph database using Scala.
How to do it...
There are multiple solutions for this problem, although there is no standard module that can 
be considered as the de facto standard with Scala. The solution is listed in the following steps:
1.	 Java JAR files works with Scala due to interoperability, so the first way is to import 
Neo4j JAR files, which can be found under the lib directory, under the Scala project.
www.it-ebooks.info

Chapter 2
47
2.	 There are many REST clients available in Scala, such as Lift, Scalatra, and Akka with 
Spray, so it is easy to write your own code on the top of any of these libraries. One 
such example is being shown here:
import dispatch._
val http_client = new Http
val json = http_client(:/("localhost:7474/data/db/) /  
"node/1")
3.	 The best way to access Neo4j from Scala is via Gremlin. Gremlin is the 
domain-specific language used for graphs and together with Tinkerpop it 
makes graph databases interoperable. The Scala port of Gremlin can be accessed 
from https://github.com/mpollmeier/gremlin-scala. This is shown in the 
following code:
val node1 = graph.addV()
node1.setProperty("name", "A")
val node2 = graph.addV()
node2.setProperty("name", "B")
graph.addE(node1,node2,"Friend of")
Accessing Neo4j from .NET
This chapter would be incomplete without the discussion on how to access Neo4j from 
the .NET Framework.
The .NET Framework is still the primary framework for developing all sorts of applications 
when it comes to the Windows platform.
How to do it...
This problem can be solved in multiple ways using some already available solutions or 
writing your own code on the top of the REST API.
The Neo4j client is available at https://bitbucket.org/Readify/neo4jclient/
wiki/Home.
The Neo4j client claims that it makes writing Cypher queries easier with IntelliSense. It comes 
exclusively as a NuGet package. The following code shows you how to install the package:
# Installing the Package
Install-Package Neo4jClient
# Key class is GraphClient
var c = new GraphClient(new Uri(REST_API_ENDPOINT));
c.Connect();
www.it-ebooks.info

Connecting to Neo4j
48
The .NET Framework comes with many REST client libraries, and they can be used to write 
your own framework on top of the REST API endpoint, for example, using RESTSharp, 
you can refer to http://restsharp.org/.
In this chapter, we learnt how to connect to Neo4j from the various programming languages 
of your choice. In other programming languages, which have not been covered in this chapter, 
the best way is to find the REST client library and connect to Neo4j using the REST API 
endpoints that provides greater flexibility.
Accessing Neo4j from PHP
PHP is a one of the most popular languages when it comes to web development and it would 
make this chapter incomplete if we don't mention it.
In this recipe, we will learn how to access the Neo4j graph database using PHP.
Getting ready
Neo4jPHP is the most popular client when its comes to accessing the Neo4j graph database 
server using PHP.
You can find more information on this at https://github.com/jadell/neo4jphp.
The following steps will get you started with Neo4jPHP:
1.	 Neo4jPHP can be installed by typing the following on the command line:
echo '{"require":{"everyman/neo4jphp":"dev-master"}}' > 
composer.json && composer install
2.	 In the PHP script, include the library, which has been installed, using the following 
command:
require("vendor/autoload.php")
How to do it…
The following steps will get you started with Neo4jPHP:
1.	 Let's access Neo4j from the PHP script:
<?php
  require('vendor/autoload.php');
  $client = new Everyman\Neo4j\Client ('localhost', 7474);
print_r($client->getServerInfo());
www.it-ebooks.info

Chapter 2
49
2.	 Let's create the first node using the following code:
$arthur = $client->makeNode();
$arthur->setProperty('name', 'Arthur Dent')
    ->setProperty('mood', 'nervous')
    ->setProperty('home', 'small cottage')
    ->save();
Neo4jPHP can be used extensively to perform operations exposed by the Neo4j REST server. 
It can be studied in detail at https://github.com/jadell/neo4jphp/wiki.
Accessing Neo4j from Node.js
Node.js is getting increasingly popular with the entrant of JavaScript on the server side due 
to its asynchronous nature.
In this recipe, we will learn how to access the Neo4j graph database using Node.js.
Getting ready
Node-Neo4j is the most popular client when its comes to accessing the Neo4j graph database 
server from Node.js. For more information on this, you can refer to https://github.com/
thingdom/node-neo4j.
The following steps will get you started with Node-Neo4j:
1.	 Node-Neo4j can be installed by typing the following on the command line:
npm install neo4j
2.	 In the Node.js code, include the library, which has been installed, using the following 
line of code:
var neo4j = require('neo4j');
How to do it…
The following steps will get you started with this recipe:
1.	 Let's access Neo4j from Node.js using the following code:
var neo4j = require('neo4j');
var db = new neo4j.GraphDatabase('http://localhost:7474');
www.it-ebooks.info

Connecting to Neo4j
50
2.	 Let's create the first node using the following code:
var node = db.createNode({hello: 'world'});
node.save(function (err, node) {
if (err) {
console.error('Error saving new node to database:', err);
    } else {
        console.log('Node saved to database with id:', 
node.id);
    }
});
Node-Neo4j can be used extensively to perform operations exposed by the Neo4j REST server. 
It can be studied in detail at https://github.com/thingdom/node-neo4j.
We tried our best to keep this book updated with third-party libraries, but 
the exact syntax might change with the library version you are using with 
a particular programming language.
www.it-ebooks.info

51
3
The Cypher Query 
Language
In this chapter, we will cover the following recipes:
f
f
Creating your first node and relationships using Cypher
f
f
Querying nodes and relationships using Cypher
f
f
Deleting data from Neo4j using the Cypher query
f
f
The Boolean operators with Cypher
f
f
Changing order of result with Cypher
f
f
Limiting and skipping results with Cypher
f
f
Regular expression with Cypher
f
f
Aggregation with Cypher
f
f
Combining results with Cypher
f
f
Finding paths in Cypher along with their shortest route
Introduction
Cypher is the most powerful tool in the hands of any graph database developer when it 
comes to Neo4j. Cypher is the de facto language for querying graphs and came into 
existence, because the Java API for Neo4j was considered too verbose and that of Gremlin 
too prescriptive. Cypher was designed to strike the right balance by being declarative and 
easy for those who come from a SQL background.
www.it-ebooks.info

The Cypher Query Language
52
In this chapter, we will learn many recipes around the Cypher query language, which will 
be very helpful in dealing with the common graph problems, such as creating new nodes/
relations, finding nodes and the shortest distance between the two nodes, and many others, 
which are required in our day-to-day life. For the sake of simplicity, we will use a graph of the 
United States airports and the different flights connecting them together.
The data for the following graph has been taken from the dataset Airline On-Time 
Performance and Causes of Flight Delays, which was released by Bureau of Transportation 
Statistics, and contains detailed information on all the United States' flights since 1987.  
The dataset is huge, so, for the sake of simplicity, we are considering only 5 Airport objects  
and 20 Flight observations between them. The inspiration comes from Neo4j gist  
(http://gist.neo4j.org/?6619085), which describes it in more detail.
The following is the screenshot of the graph taken from Neo4j, which shows the various 
entities and types of relations between each entity. This is the Neo4j console showing two 
Airport objects and one Flight connecting them:
The following screenshot of the Neo4j console shows the flights and causes of its delay:
www.it-ebooks.info

Chapter 3
53
The airport and the flight destination graph is shown in the following screenshot. This depicts 
the Neo4j console showing the flight and its diverted airport:
Creating your first node and relationship 
using Cypher
In this recipe, you will learn to create nodes and relationships between them. Nodes can 
consist of various properties, which describes the nodes. Similarly, properties can also exist 
on relationships.
Getting ready
To step through this recipe, you will need to run an instance of the Neo4j Server. For the 
sake of simplicity, we will type the Cypher query from the Neo4j web console, as shown in 
the following screenshot. However, you can also send queries programmatically, using the 
language of your choice:
www.it-ebooks.info

The Cypher Query Language
54
How to do it...
In this recipe, we are creating two airports, J.F Kennedy Airport, based in New York, and 
Austin-Bergstrom International, based in the city of Austin. This recipe is as follows:
1.	 We are also creating a flight that connects them, which is shown in the following 
code:
CREATE (JFK:Airport { name:'JF Kennedy Airport', city:'New 
York' }),(AUS:Airport { name:'Austin-Bergstrom 
International', city:'Austin' })
CREATE (flight1:Flight { flight_number:'BG45', 
month:'August' })
The following screenshot shows the query console and result of the CREATE query:
2.	 Now, we have created two airport nodes and one flight node. Let's create a 
relationship that connects both the airports, with the flight number BG45:
MATCH (JFK:Airport { name:'JF Kennedy Airport'})
MATCH (AUS:Airport { name:'Austin-Bergstrom 
International'})
MATCH (flight1:Flight { flight_number:'BG45'})
CREATE (flight1)-[:ORIGIN]->(JFK),(flight1)-[:DESTINATION]- 
>(AUS)
www.it-ebooks.info

Chapter 3
55
The following screenshot shows the two airports that are connected by a flight:
How it works...
The CREATE keyword is used for creating nodes and relationships. The following example 
will show you how to use the CREATE keyword:
CREATE (JFK:Airport { name:'JF Kennedy Airport', city:'New York' 
}),(AUS:Airport { name:'Austin-Bergstrom International', 
city:'Austin' })
In the preceding query, we are specifying the label, which is JFK:Airport. The label is 
useful for referencing the node later. We have also specified two properties, which are 
name and city, in this case. The properties are specified in the JSON format.
The relationships are created between the two nodes, as specified in the following code:
CREATE (flight1)-[:ORIGIN]->(JFK),(flight1)-[:DESTINATION]-
>(AUS)
In the preceding Cypher query, we are creating two relationships between flight1->JFK 
and flight1->AUS. The first relationship is of type ORIGIN, and the second relationship 
is of type DESTINATION.
So, we have completed our first recipe where we have learnt how to create nodes, 
relationships with labels, and properties.
www.it-ebooks.info

The Cypher Query Language
56
Querying nodes and relationships using 
Cypher
Cypher can be used to query nodes and relationships based on properties, relation types, 
labels, and so on. You can also write complex Cypher queries to query a subpart of the graph. 
In this recipe, we will learn some commonly used Cypher queries, which will be useful for 
querying the graph.
Getting ready
To step through this recipe, you will need to create some nodes and relationships among them 
to get the most from this recipe.
How to do it...
We have divided this recipe into the following problem sets:
f
f
Counting all nodes that exist in the graph:
START n = node(*) RETURN COUNT(n)
f
f
Counting all relationships that exist in the graph:
MATCH (n)-[r]-(m) RETURN COUNT(r)
f
f
Finding all distinct labels that exist in the graph:
MATCH (n) RETURN DISTINCT LABELS(n)
f
f
Finding all distinct relationship types that exist in the graph:
MATCH n-[r]-() RETURN DISTINCT TYPE(r)
f
f
Finding all nodes that are disjoint, which means that they do not have any 
relationship with the other nodes:
MATCH (n) WHERE NOT (n)-[]-() RETURN n
f
f
Finding all nodes that have some specific property:
MATCH (n) where has(n.name) RETURN n
f
f
Finding all nodes that have some specific relationship, regardless of the direction:
MATCH (n)-[:ORIGIN]-() RETURN DISTINCT n
www.it-ebooks.info

Chapter 3
57
How it works...
The Cypher query has very powerful querying features, which we have seen in this recipe. 
Let's describe the various keywords used in the preceding queries:
f
f
START: In any graph database, the query must start from a node, which is called the 
root node. We can specify a node by an ID, such as node(10) or node(*), where * 
is a wild card character that instructs every node to take the position of the root node, 
turn by turn.
f
f
MATCH: The match clause is used to specify the patterns for Cypher to search in the 
Neo4j database.
f
f
DISTINCT: The distinct clause is used to remove duplicates from the result.
f
f
COUNT: The count clause is used to aggregate the result.
f
f
RETURN: The return clause is used to return the result from any Cypher query.
In the Cypher query, we have used one or more previously mentioned keywords to construct 
the Cypher query.
The Cypher query is case independent, and it's up to you to decide how to 
specify the preceding keywords and queries in either lower or upper case. 
For example consider the code:
START n = node(*) RETURN COUNT(n)
The preceding code can also be written as:
start n = node(*) return count(n)
The following screenshot shows the Neo4j console depicting the result of a query 
through Cypher:
www.it-ebooks.info

The Cypher Query Language
58
Deleting data from Neo4j using the Cypher 
query
In this recipe, we will learn how to delete nodes and relationships from Neo4j. This recipe can 
be used to delete all nodes/relations or subsets of them.
Getting ready
To step through this recipe, you will need to create some nodes and relationships among them 
to get the most from this recipe.
How to do it...
We have divided this recipe into the following problem sets:
f
f
Deleting all relationships from the Neo4j graph:
MATCH (n)-[r]-() DELETE r
f
f
Deleting all nodes from the Neo4j graph:
MATCH (n) DELETE n
The preceding query will only work if there are no relationships in the graph.
f
f
Deleting all nodes from the Neo4j graph matching a condition:
MATCH (n) WHERE n.city = "Atlanta" DELETE n
# You have to delete all relationships from that node 
before deleting that node
f
f
Deleting all relationships of a particular type:
MATCH n-[r:ORIGIN]-() DELETE r
f
f
Deleting a property/properties from a particular node/nodes:
MATCH (n) REMOVE n.city
# To specify a particular node specify either node id in 
start or where clause
f
f
Removing a label/labels from a particular node/nodes:
MATCH (n) REMOVE n:Airport
# To specify a particular node specify either node id in 
start or where clause
www.it-ebooks.info

Chapter 3
59
Back ticks (`) are not necessary with the recent versions of Neo4j.
Similarly framing the query using * as shown here is optional:
Start n =  node(*)
How it works...
In this recipe, we learned two more new keywords: DELETE and REMOVE. The definition of 
these keywords are as follows:
f
f
DELETE: This is used to delete nodes or relationships based on a matched pattern
f
f
REMOVE: This is used to delete a particular property or label from the nodes or 
relationships
Before removing the nodes, don't forget to remove the relationships 
that are connecting them to the other nodes.
The following screenshot shows the Neo4j console depicting the result of the delete 
Cypher query:
Boolean operators with Cypher
Cypher supports the Boolean operators AND, OR, NOT, and XOR, which are very useful to 
describe more than one condition to be checked simultaneously. In this recipe, we will learn 
their uses within the graph we have created.
www.it-ebooks.info

The Cypher Query Language
60
Getting ready
To step through this recipe, you will need to create the nodes and relationships for which data 
has been provided with the code files.
How to do it...
We have divided this recipe into the following problem sets:
f
f
The Boolean operator AND with Cypher: Let's get all the flights that originate from 
any airport in Atlanta city that are destined for Dallas/Fort Worth:
MATCH (o)<-[:`ORIGIN`]-(f)-[:`DESTINATION`]->(d) where 
o.city = "Atlanta" AND d.city = "Dallas/Fort Worth" return 
o,f,d
The following screenshot shows the Neo4j console depicting the result of the AND 
Boolean query:
f
f
The Boolean operator OR with Cypher: Let's get all the flights that originate from 
either from Atlanta or Dallas/Fort Worth:
MATCH (o)<-[:ORIGIN]-(f) where o.city = "Atlanta" OR o.city 
= "Dallas/Fort Worth" return o,f
www.it-ebooks.info

Chapter 3
61
f
f
The Boolean operator NOT with Cypher: Let's get all flights that originate from any 
city, but not from Atlanta:
MATCH (o)<-[:`ORIGIN`]-(f) WHERE NOT o.city = "Atlanta" 
RETURN o
f
f
The Boolean operator in conjunction with each other: Let's get all the flights that 
start from either Atlanta or Dallas/Fort Worth and have been delayed due to 
late aircraft arrival:
MATCH (o)<-[:`ORIGIN`]-(f)-[:`DELAYED_BY`]-(r) where 
(o.city = "Atlanta" OR o.city = "Dallas/Fort Worth")AND 
r.name = "Late Aircraft"  return o,f
How it works...
The Boolean operators work in the same way as they work in any other programming language 
or SQL. They can be used in conjunction with each other to create a powerful Cypher query.
Changing the order of results with Cypher
Cypher is similar to SQL, where the order of the results can be changed using the ORDER BY 
clause, both in ascending and descending order. In this recipe, we will learn the use of the 
ORDER BY clause using the instance of the graph we have created.
Getting ready
To work through this recipe, you will need to create the nodes and relationships for which 
data has been provided with the code files.
How to do it...
We have divided this recipe into the following problem sets:
f
f
ORDER BY on numerical value: Let's get the delay times of the most delayed flights, 
along with the flight number and reason for delay:
MATCH (f)-[r:`DELAYED_BY`]->(x) 
RETURN f.flight_number,r.time,x.name 
ORDER BY r.time DESC
www.it-ebooks.info

The Cypher Query Language
62
The following screenshot shows the Neo4j console depicting the result of the late 
flight time Cypher query:
f
f
ORDER BY on unicode strings: Let's get all the airports in ascending order by name:
MATCH (f)-[r:ORIGIN]->(x) 
RETURN DISTINCT x.name 
ORDER BY x.name
f
f
ORDER BY on multiple properties: Let's get all the airports sorted, first by the city 
name and then by the airport name:
MATCH (f)-[r:ORIGIN]->(x) 
RETURN DISTINCT x.name,x.city 
ORDER BY x.city,x.name
How it works...
The ORDER BY clause is used to sort the results by one or more columns, either in ascending 
or descending order. The ORDER BY clause sorts the records in ascending order, by default. 
In numerical values, the comparison is done on the basis of values whereas in case of string 
values, the ORDER BY clause works by using lexicographic order and the numerical value of 
the character. In the case of multiple properties specified with ORDER BY, the sorting is done 
on the first parameter and if they are the same, then sorting is done on the next parameter 
specified, and so on.
www.it-ebooks.info

Chapter 3
63
The parameters, by which ORDER BY is specified, must also be 
present in the RETURN statement too.
Limiting and skipping results with Cypher
The Cypher, by default, returns all the results that match a particular query. However, many 
times we require a limited number of results or just the topmost result. This can easily be 
done via LIMIT and SKIP, specified with the query. In this recipe, we will learn the use of 
LIMIT and SKIP, along with the Cypher query.
Getting ready
To work through this recipe, you will need to create the nodes and relationships for which data 
has been provided with the code files.
How to do it...
We have divided this recipe into the following problem sets:
f
f
Limiting the results: Let's get the delay times of the topmost three delayed flights, 
along with the flight number and reason of delay:
MATCH (f)-[r:DELAYED_BY]->(x) 
RETURN f.flight_number,r.time,x.name 
ORDER BY r.time DESC LIMIT 3
The following screenshot shows the Neo4j console depicting the top three results 
of the late flight time Cypher query:
www.it-ebooks.info

The Cypher Query Language
64
f
f
Skipping the results: Let's get the delay times of flights. We will skip the first three 
results and get the next ones:
MATCH (f)-[r:DELAYED_BY]->(x) 
RETURN f.flight_number,r.time,x.name 
ORDER BY r.time DESC SKIP 3
f
f
Skipping with limits: Let's get the delay time of a flight that is on the third rank with 
respect to the flight delay timing:
MATCH (f)-[r:DELAYED_BY]->(x) 
RETURN f.flight_number,r.time,x.name 
ORDER BY r.time DESC SKIP 2 LIMIT 1
How it works...
The LIMIT and SKIP keywords return the subset of the results. The LIMIT keyword is used 
to limit the results to be returned as the result, whereas the SKIP keyword is used to skip 
the subset specified with skip.
The LIMIT and SKIP keywords both operate from the top of 
the result set. The SKIP keyword does not guarantee the order, 
unless specified with ORDER BY.
Regular expressions with Cypher
By default, Cypher works on an exact match, which is case sensitive in nature. Many times 
we will know the pattern we want to match, but not the exact value. In this recipe, we will 
learn to use regex with a Cypher query.
Getting ready
To work through this recipe, you will need to create the nodes and relationships for which 
data has been provided with the code files.
How to do it...
We have divided this recipe into the following problem sets:
f
f
Getting the details: Let's get all the Airport names starting with the letter H:
MATCH (n) 
WHERE "Airport" in LABELS(n) AND n.name =~ '^H.*' 
RETURN n
www.it-ebooks.info

Chapter 3
65
You can also specify a label along with the node, as shown in the following code:
MATCH (n:Airport)
The following screenshot shows the Neo4j console depicting the result of all the 
airports starting with the letter H:
f
f
Making the regex matching case insensitive: Let's get all the airports with names 
starting with either H or h:
MATCH (n) 
WHERE "Airport" in LABELS(n) AND n.name =~ 
'(?i)^H.*' 
RETURN n
f
f
Complex regular expressions: Let's get all the airports in a city whose name is 
exactly seven characters long:
MATCH (n) 
WHERE "Airport" in LABELS(n) AND n.city =~ 
'.?.?.?.?.?.?.?' 
RETURN n
The preceding code can also be written as follows:
MATCH (n:Airport)
WHERE n.city =~ '.{7}' RETURN n
f
f
Regular expressions on numerical values: Let's get all the flights whose delay time 
is in a single digit:
MATCH (n)-[r:`DELAYED_BY`]->(x)
WHERE str(r.time) =~ '.?' 
RETURN n.flight_number,r.time
www.it-ebooks.info

The Cypher Query Language
66
The following screenshot shows the Neo4j console depicting flights whose delay 
timing is in a single digit:
How it works...
The =~ operator is used to specify regex or a pattern, which is to be matched against 
the property. The regex works in a similar fashion to how it would work with other 
programming languages.
The Cypher query doesn't support escape string regex such as \W, \D, 
and so on. Also, the numerical values need to be converted to a string 
form before applying regex to them.
Aggregation with Cypher
The Cypher query offers aggregation similar to GROUP BY offered by SQL. The aggregate 
function can take multiple values and can calculate the aggregated values for them. In this 
recipe, we will learn the common aggregation techniques, with the help of examples.
Getting ready
To work through this recipe, you will need to create the nodes and relationships for which 
data has been provided with the code files.
www.it-ebooks.info

Chapter 3
67
How to do it...
We have divided this recipe into the following problem sets:
f
f
Nodes and relationships: Let's get all the nodes and then count the number of 
relationships they have with the other nodes:
START n = node(*) 
MATCH n-[r]-() 
RETURN n, count(r) as rel_count 
ORDER BY rel_count desc
The following screenshot shows the Neo4j console depicting nodes and count of 
relationships they share with the other nodes in the graph:
f
f
Count the number of entities: Let's count the total number of flights originating 
from any airport:
START n = node(*)
MATCH (n)-[r:`ORIGIN`]->(o) 
RETURN o.name,count(r) as rel_count 
ORDER BY rel_count desc
www.it-ebooks.info

The Cypher Query Language
68
The following screenshot shows the Neo4j console depicting the flights count 
originating from any airport:
How it works...
The count keyword aggregates the parameters specified with it, and if * is specified with the 
count keyword, it aggregates the number of matching rows.
Always try to specify some identifiers with count, so that it 
doesn't match the NULL value.
Combining results with Cypher
The UNION operator can be used to combine the results from two separate queries. This 
operator is very useful to combine the results of two altogether different queries, which have 
no common match pattern among them. In this recipe, we will learn the use of the UNION 
operator via examples.
Getting ready
To work through this recipe, you will need to create the nodes and relationships for which 
data has been provided with the code files.
www.it-ebooks.info

Chapter 3
69
How to do it...
We have divided this recipe into the following problem sets:
f
f
Getting the details: Let's get name of all the airports and flight numbers existing in 
our graph database:
MATCH (n:Airport) 
RETURN n.name AS name 
UNION ALL MATCH (n:Flight) 
RETURN n.flight_number AS name
The following screenshot shows the Neo4j console depicting the union result of two 
separate queries:
f
f
Removing duplicates from the query: For removing duplicates from the query, 
UNION is specified instead of UNION ALL:
MATCH (n:Airport) 
RETURN n.name AS name 
UNION  MATCH (n:Flight) 
RETURN n.flight_number AS name
How it works...
The UNION operator aggregates the result in the form of rows by combining the rows together. 
If only UNION is specified instead of UNION ALL, then the duplicate rows are removed from 
the result.
www.it-ebooks.info

The Cypher Query Language
70
The name and number of columns must be identical in all the queries 
combined by the UNION or UNION ALL keywords.
Finding paths in Cypher along with their 
shortest route
The most common operation in any graph database is graph traversal, which includes finding 
all possible paths between the two nodes, the shortest path, and the shortest weighted path. 
In this recipe, we will cover them with the help of examples.
Getting ready
Let's create some sample data of airports and routes between them, using the following 
Cypher queries:
CREATE (ATL:Airport {  city:'Atlanta' }),(ORD:Airport { 
city:'Chicago' }),(LAX:Airport { city:'Los Angeles' 
}),(DFW:Airport { city:'Dallas/Fort Worth' }),(AUS:Airport { 
city:'Austin' })
CREATE (ATL)-[:ROUTE { time:22 }]->(AUS),(AUS)-[:ROUTE { time:35 
}]->(LAX),(ATL)-[:ROUTE { time:40 }]->(DFW),(DFW)-[:ROUTE { 
time:34 }]->(LAX),(ORD)-[:ROUTE { time:13 }]->(ATL),(LAX)-[:ROUTE 
{ time:63 }]->(ORD)
The following screenshot shows the Neo4j console depicting the sample airport and route 
data that was inserted into the Neo4j graph database:
173
Airport
172
171
174
ROUTE
ROUTE
ROUTE
ROUTE
ROUTE
ROUTE
170
www.it-ebooks.info

Chapter 3
71
How to do it...
We have divided this recipe into the following problem sets:
f
f
Number of paths: Let's get all the paths possible to reach from Atlanta to Los 
Angeles along with the number of hops:
START n = node(*) 
MATCH p = (n)-[r:ROUTE*..]->(m) 
WHERE n.city = "Atlanta" AND m.city = "Los Angeles" 
RETURN p,length(p)
The following screenshot shows the Neo4j console depicting all possible routes 
between Atlanta and Los Angeles:
f
f
Finding paths that are near to the nodes to which we are connected: Let's see 
where we can reach in 2 hops from our nearest airport:
START n=node(*) 
MATCH p = (n)-[r:ROUTE*1..2]->(m)  
WHERE n.city = "Atlanta" RETURN p,length(p)
f
f
Finding the shortest path based on the time of flight: Let's find the quickest flight 
from Atlanta to Los Angeles based on the time parameter, which we have 
stored in the relationship as time:
START n=node(*) 
MATCH p = (n)-[r:ROUTE*..]->(m) 
WHERE n.city = "Atlanta" AND m.city = "Los Angeles" 
RETURN p,reduce(total = 0, x in relationships(p)| total + x.time) 
as tt ORDER by tt asc LIMIT 1
www.it-ebooks.info

The Cypher Query Language
72
How it works...
The path and shortest route have typical graph problems, where we can start from the start 
node in the graph and try to find all the possible routes to the ending node specified, which 
meet the matching conditions.
Neo4j also comes with built-in graph algorithms, which can be 
accessed by using REST-based API. For more information on this, 
visit the URL at http://docs.neo4j.org/chunked/stable/
rest-api-graph-algos.html.
There's more…
The Cypher query language is very vast, and it's almost impossible to cover everything in one 
chapter. In this chapter, we touched on the recipes that will be required by the graph database 
developer/analyst most of the time. In the subsequent chapters, the remaining advanced 
Cypher queries will be covered.
www.it-ebooks.info

73
4
Data Modeling and 
Leveraging with Neo4j
In this chapter, we will cover the following recipes:
f
f
Data modeling with Neo4j – moving away from traditional SQL
f
f
Aggregate versus connected data models
f
f
Creating a binary search tree with Neo4j
f
f
Healthcare data modeling with Neo4j
f
f
Travel data modeling with Neo4j
f
f
Social data modeling with Neo4j
f
f
Retail data modeling with Neo4j
Introduction
Neo4j is a very powerful tool for storing, querying, and manipulating data. The relationship 
model on which the graph database structure is based gives the user the flexibility to map any 
domain-specific data into the Neo4j database. However, modeling data as Neo4j graphs 
is very different from modeling data into relational databases, such as Oracle, MySQL, and 
so on. These are especially useful when we have a domain that has lots of relationships.
In this chapter, we will cover various aspects of data modeling using Neo4j and how they 
differ from relational databases with the help of domain-specific examples. We will also 
learn the impact of this on flexibility, complexity, and performance.
Before trying our first recipe, let's do a recap of the basic building blocks of the Neo4j 
graph database.
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
74
These are the two fundamental building blocks of any Neo4j graph database:
f
f
Nodes: These are used to represent entities in a particular domain. Any two 
nodes in the graph database can differ from each other in the entities they 
represent, types of properties they hold, and so on.
f
f
Relationships: These are used to represent relationships between data in the 
domain. Every relationship must have a start node, an end node, and a name. Like 
nodes, relationships can also contain properties, which can be used to give weight 
to the relationship/metadata.
The following are the other two important blocks that will be used very frequently in Neo4j:
f
f
Labels: These are used to qualify nodes. Every node in Neo4j can have zero or 
more labels attached to it. They are also useful in expressing constraints and 
indexes over groups of nodes.
f
f
Properties: These are a set of attributes that can be attached to nodes and 
relationships. They vary in structure and are best suited using the JSON format. 
They are very useful in data modeling when expressed with nodes and relationships.
Any Neo4j graph will consist of one or more of these blocks. The Neo4j database model has 
been kept simple so that anyone new to graph databases can understand it easily and has 
been kept flexible so that any type of data can be modeled with Neo4j.
The following screenshot shows the Neo4j console that depicts the blocks of the Neo4j 
graph database:
www.it-ebooks.info

Chapter 4
75
Data modeling with Neo4j – moving away 
from traditional SQL
Data modeling using SQL is very different from the usual data modeling we do using Neo4j. 
The nearest mapping of SQL using the Neo4j graph database will be as follows:
SQL
Neo4j
The primary elements of any table, such as 
person, product, and so on
Node
Two different tables joined via a foreign key
Relationship
Tuple or row
Properties or attributes
Relational databases have a very rich model to store/express data, but it comes at a cost. 
To express relationships, the user has to use joins, which have their own cost. The more the 
number of relationships to be expressed, the more the number of joins over the table. This 
phenomenon has a serious impact on performance. Thus, in spite of having a rich model for 
the storage of data, SQL limits this when using queries that require the usage of a rich model.
In Neo4j, the preceding limitation has been simplified by the removal of joins when expressing 
interrelated data using relationships. A node can be connected to millions of other nodes and 
can be easily queried on the basis of one or more relationships. In this recipe, you will learn, 
with the help of an example, the difference between data modeling using SQL and Neo4j.
Getting ready
Install MySQL and Neo4j on your machine. The steps to install Neo4j have been described 
in Chapter 1, Getting Started with Neo4j. This installation process will depend on your 
preference for your machine OS type.
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
76
How to do it...
Perform the following instructions to get started with this recipe:
f
f
The following screenshot shows how SQL models data. We have used three 
entities, namely customers, products, and merchants. You will further see a 
pictorial comparison of SQL data modeling and its equivalent Neo4j data 
modeling in the graph database:
Products
id: int
name: String
merchant: Merchant
tags: List<String>
...
save()
...
Customer
id: int
name: String
...
save()
purchaseProduct(Product,purchaseDate)
...
Merchant
id: int
name: String
type: String
...
save()
...
f
f
The following screenshot is the graph model of the preceding relational model:
“Customer 1"
purchased
sells
“Merchant 1"
has_type
“MerchantType”
has_Tag
“Tag1"
“Tag2"
has_Tag
“Product 1"
www.it-ebooks.info

Chapter 4
77
The preceding screenshot shows Neo4j data modeling in comparison to its equivalent SQL 
data modeling.
From the preceding screenshot, we can see that it is easier to express complex relationships 
between data in the graph model rather than in the relational database model.
Suppose we have to find merchants and their associated products, then we can construct 
a query as follows:
SELECT Merchant.name,Product.name
FROM Merchant
INNER JOIN Product
ON Merchant.id=Product.merchant;
In the Neo4j the same would be expressed as:
MATCH (m:Merchant)-[:`sells`]->(p:Product) 
RETURN m,p
From the preceding query, you can see that the graph data model is closer to the actual data 
domain model and is easier to express. In fact, it is so simple that it can be easily expressed 
by non-technical people, such as domain experts.
How it works...
In Neo4j, creating relationships is the best way to express connected data and the joins 
operation has become the traversal of relationships. This is typically a nanosecond operation 
giving the user more power and flexibility to query very complex data relationships, which we 
will learn in later recipes.
Aggregate versus connected data models
Data can be modeled in Neo4j using both connected and aggregated forms. The connected 
form has the advantage that new dimensions can be easily extracted from the same model. 
In comparison, the aggregate form (also can be called as MapReduce) can give us quick 
access to the aggregated result, which is very useful in particular. In this recipe, you will 
learn both data models and a third one also, which has been derived by combining 
both of these data models.
Getting ready
Install the Neo4j graph database on the host machine using the recipe described in 
Chapter 1, Getting Started with Neo4j. This installation process will depend on your 
preference for your machine OS type.
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
78
How to do it...
Perform the following steps to get started with this recipe:
f
f
In this recipe, we will use Apache log files to describe both connected and aggregated 
data models. A typical log file has the following structure:
LogFormat "%h %l %u %t \"%r\" %>s %b" common
For example, one such log entry will look like the following:
127.0.0.1 - ankur [11/Mar/2013:13:55:36 -0700] "GET 
/apache_pb.gif HTTP/1.0" 200 2326
The Apache log files are useful sources for analyzing traffic. Let's model this data in 
Neo4j, as follows:
URL
Visits
Returns
Response
Gets
IP
Address
Is From
Country
f
f
For the sake of simplicity, we have taken only three fields from the logs.
The preceding model is a connected model where every field from every line in the log 
file is modeled into the graph. Any new dimension can easily be extracted from this 
form, as this is the most purest form nearest to the data, where every line from the 
log file has got a place in the graph.
f
f
For a website having heavy traffic, the log file can easily run into gigabytes and more. 
This can result in millions/billions of nodes and relationships for queries such as 
"How many visitors have visited the given URL from Spain?".
The result time can run into seconds as the result will be obtained by combining all the 
edges that connect the country node and the URL node, which can be in the millions.
Hence, the aggregated model came into the picture, which solves this particular 
disadvantage of connected models, where results are precomputed for the 
expected queries and stored in the graph itself.
www.it-ebooks.info

Chapter 4
79
The following screenshot shows a typical aggregated graph on the basis of country:
URL
Spain
Visited
{count : 1000,
date : 02/01/2013}
f
f
Now, it is much faster to answer queries, such as finding a visitor from a particular 
country on a particular day and so on, but after aggregation, it is not possible to 
view data from different angles.
How it works...
The use of connected models or aggregation models depends on the use case. If the 
application consists of only a fixed number of views, then the aggregated model will be 
preferred. If the use case consists of finding new dimensions from the same data, then 
the connected model should be chosen.
There's more...
Here are the advantages and disadvantages of both connected and aggregated models:
The connected model
The following are the pros of the connected model:
f
f
It allows efficient access to new use cases
f
f
It can serve as a raw data storage medium for other data stores
The following are the cons of the connected model:
f
f
The database's size can increase rapidly
f
f
Aggregation and other queries can become slow with a large number of 
nodes and edges
The aggregated model
The following are the pros of the aggregated model:
f
f
Aggregation queries are lightning fast
f
f
The graph database's size does not increase rapidly
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
80
The following are the cons of the aggregated model:
f
f
New aggregations cannot be derived from the data
f
f
There is a need for a different data store in order to store raw data
The hybrid model
The best approach can be to use a hybrid model that combines the strength of both models. 
The following are the features of the hybrid model:
f
f
Uses the same Neo4j graph to store both aggregated model data as well as 
connected model data.
The following screenshot shows the hybrid approach, which combines both models:
URL
Visits
Response
Gets
IP
Address
Is From
Country
Spain
Visited
Connected Model
Aggregated Model
Returns
f
f
Uses different Neo4j databases, one of which is over cheap storage and stores 
raw data and supports new dimensions. The other one, which is over small and 
fast storage, supports real-time aggregation queries.
f
f
Uses a single Neo4j database with both connected and aggregated models. 
This allows you to delete old nodes and edges, which are no longer required, 
and store their aggregated results.
Creating a binary search tree with Neo4j
One of the powerful use cases of the Neo4j graph database is to create scalable in-graph data 
structures, such as linked lists, trees, and so on. In this recipe, you will learn how to create a 
binary search tree from the Neo4j graph database.
www.it-ebooks.info

Chapter 4
81
Getting ready
Install the Neo4j graph database on the host machine using the recipe described in 
Chapter 1, Getting Started with Neo4j. This installation process will depend on your 
preference for the machine OS type.
How to do it...
By definition, a data structure should have nodes, where each node has a comparable 
key and an associated value. If any node satisfies the restriction that the key in any node 
is larger than the keys in all the nodes, then this becomes the node's left subtree. The keys 
that are smaller than the keys in all the nodes become the node's right subtree.
Let's create a root node and its children using the following command:
CREATE (root { name: 'ROOT',value: 10 })
CREATE (root)-[:LEFTCHILD]->(node1 {value : 5})
CREATE (root)-[:RIGHTCHILD]->(node2 {value : 15})
CREATE (node1)-[:LEFTCHILD]->(node3 {value : 3})
CREATE (node1)-[:RIGHTCHILD]->(node4 {value : 7})
CREATE (node2)-[:LEFTCHILD]->(node5 {value : 12})
CREATE (node2)-[:RIGHTCHILD]->(node6 {value : 20})
RETURN root
The preceding statements will look like the following binary search tree diagram:
ROOT
RIGHTCHILD
LEFTCHILD
3
7
5
15
20
12
RIGHTCHILD
RIGHTCHILD
LEFTCHILD
LEFTCHILD
Let's find out where to insert the next node using the following command:
MATCH (root)-[:LINK*0..]->(before),(after)-[:LINK*0..]-
>(root),(before)-[old:LINK]->(after)
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
82
WHERE root.name = 'ROOT' AND (before.value < 25 OR before = root) AND 
(25 < after.value OR after =
  root)
CREATE UNIQUE (before)-[:LINK]->({ value:25 })-[:LINK]->(after)
DELETE old
Let's do the in-order traversal of the tree using the command:
MATCH (root { name: "ROOT" })-[:LEFTCHILD|RIGHTCHILD*0..]->()-
[lastRel:LEFTCHILD|RIGHTCHILD]->element
RETURN element
ORDER BY element.value
The following screenshot shows the in-order traversal of the binary search tree (BST):
Let's find the leaf nodes in the BST, as follows:
start n=node(*) 
match n-[r*]->m
where not(m-->())
return distinct m;
www.it-ebooks.info

Chapter 4
83
The preceding query yields the following result , which shows the leaf nodes in the binary 
search tree:
How it works...
The binary search tree is a special kind of graph, with the restriction of the left subtree being 
smaller and the right subtree being larger. As long as we obey these restrictions, Neo4j can 
act as a perfect BST. You can also create many BSTs, which can coexist together in a single 
Neo4j graph.
Neo4j also gives you the flexibility to reach the parent node without explicitly storing the 
relationship of the parent node. The other benefit of using Neo4j as a BST is that there 
are no memory leaks, as they can be easily queried anytime.
Healthcare data modeling with Neo4j
Healthcare is the one domain that has been getting attention recently, and many start-ups 
are trying to improve healthcare services with the help of data analytics. Predicting the 
treatment outcome, suggesting an alternative treatment/physician, and improving the patient 
experience are some of the places where Neo4j is being applied. In this recipe, you will learn 
how to model the healthcare domain data with Neo4j.
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
84
Getting ready
Install the Neo4j graph database on the host machine using the recipe described in 
Chapter 1, Getting Started with Neo4j. This installation process will depend on your 
preference for your machine OS type.
For this recipe, we will use examples from a popular healthcare website.
How to do it...
If we go to website http://docgraph.org, it has an excellent source of drug, disease, 
symptom, and patient information. Let's build a data model for our healthcare graph, as follows:
Patient – [HAVE] – Disease[s]
Disease– [HAVE] – Symptom[s]
Disease– [HAVE] – Treatment[s]
Treatment – [HAVE] – Drug[s]
Drug – [INTERACT] – Drug[s]
The preceding query yields the following result, which shows the healthcare graph modeling:
: Symptom Cough
: Treatment Chemotherapy
: Drug Taraceva
: Disease Cancer
: Patient Patient
: Patient John
: Food Peanut
HAS_SYMPTOM
HAS_DRUG
HAS_TREATMENT
HAS_DISEASE
HAS_ALLERGY
HAS_DISEASE
Let's answer some questions based on our healthcare graphs using queries:
f
f
The most common symptoms of any disease: We know that every disease has 
some symptoms and patients exhibit (some of) these symptoms. Let's find out 
the most common symptoms experienced by patients who have been diagnosed 
with a particular disease, using the following query:
MATCH (p:Patient)-[r:SHOWS_SYMPTOM]->(s:Symptom)<-
[:HAS_SYMPTOM]-(d:Disease{name:"Cancer"})
www.it-ebooks.info

Chapter 4
85
RETURN p.name,count(r)
ORDER by count(r)
f
f
Can a patient consume this food: Patients often suffer from allergies with some 
particular food items, such as cream, peanuts, and so on. If we have the food 
ingredients for a particular item, we can easily find out whether that food is good 
for a particular patient or not, using this query:
MATCH (p:Patient{name:"John"})-[:HAS_ALLERGY]->(s:Food)-
[r:IS_INGREDIENT_OF]->(p:Item{name:"Pizza"})
RETURN count(r) AS Suitable
f
f
Is the doctor suggesting some new drugs that interact with your treatment: This 
one is for the doctor to find out; they need to find out whether the new drug they 
have recommended interacts with any of the previously given medications, using 
the following query:
MATCH (p:Patient{name:"John"})-[:HAS_TREATMENT]-
>(t:Treatment)-[r:HAS_DRUG]-(d:Drug)-[s:INTERACTS_WITH]-
(n:Drug {name:"Abc"})
RETURN count(r) AS Interacts
Many more such answers can be easily answered by healthcare data modeled in the 
graph database.
Healthcare providers can also be modeled in the healthcare graph, as shown here:
Speciality
Specializes_In
Parent_Of
Parent
Org
refers
Location_In
Location
Provider
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
86
How it works...
The data has been modeled using the connected data model, in which each entity, called a 
node, in the graph has been linked with what it is related to. Patients have been related to 
diseases, symptoms, allergies, treatment, and so on, which is common.
See also
The DocGraph project is a very useful project related to the healthcare open graph. They have 
opened many of their healthcare-related graphs, and it will be useful to look at them here:
f
f
https://github.com/ftrotter/DocGraph
f
f
http://docgraph.org/
Travel data modeling with Neo4j
Travel is the most happening and an evergreen field when it comes to start-ups. According 
to a study, nearly two-third of start-ups start operations in the travel field.
In this recipe, you will learn how to build a route-planning application using the open 
flight database.
Getting ready
Install the Neo4j graph database over the host machine using the recipe described in 
Chapter 1, Getting Started with Neo4j. This installation process will depend on your 
preference for your machine OS type.
For this recipe, we will use data from http://openflights.org/data.html. 
They have data each airport and of the routes between airports.
The list of cities will be obtained from GeoName data taken from http://download.
geonames.org/export/dump/.
For this recipe, we have used cities15000.zip, which represents cities that have a 
population greater than 15,000.
How to do it...
Let's model this data to build a travel route planner:
City – [HAVE] – Airport[s]
Airport – [HAVE] – Flight[s]
www.it-ebooks.info

Chapter 4
87
City – [ROUTE] – Cities
Airport – [ROUTE] – Airport[s]
The preceding query yields the following result that shows the travel graph modeling:
Let's answer some questions on the basis of our travel graph; they are as follows:
f
f
Nearest airport to any city by distance: We know that every city is connected 
to its nearest airport by distance. This is represented in the relationship. Let's 
find out the nearest airport to any city using this query:
MATCH (c:City{name:"Sydney"})-[r:ROUTE]->(a:Airport)
RETURN c,a
f
f
Where you can reach in two hops from any city: Each city is connected to either 
a city or an airport. Let's find out where you can reach in two hops using this query:
MATCH (n:City{name:"Sydney"})-[ROUTE*..2]->(a:Airport)-[]-
(p:City) RETURN p
f
f
Shortest path between two cities on the basis of number of hops: Let's find 
out the route between two cities on the basis of the number of hops between them 
using this query:
MATCH x=allshortestPaths((n:City{name:"Bangkok"})-
[ROUTE*..15]-(p:City{name:"Delhi"})) RETURN x
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
88
The preceding query yields the following result that shows the shortest route 
between Bangkok and Delhi:
Airport
City
1609350
3885
1273294
3093
ROUTE
ROUTE
ROUTE
f
f
Shortest path between two cities on the basis of time: Let's find out the fastest 
route between two cities on the basis of time with the help of this query:
MATCH p=(n:City{name:"bangkok"})-[rels:ROUTE*..15]-
>(p:City{name:"delhi"})
RETURN p AS shortestPath,
  reduce(time=0, r in rels | time+r.time) AS totaltime
How it works...
The data has been modeled using the connected data model, with each entity, called nodes, 
in the graph has being linked with what connected to.
See also
There are some excellent travel data sources that can be modeled using the graph database. 
Some of them are as follows:
f
f
OpenStreetMap (http://www.openstreetmap.org/)
f
f
GeoNames (http://www.geonames.org/export/)
f
f
Wikitravel (http://wikitravel.org/en/Main_Page)
f
f
Weatherbase (http://www.weatherbase.com/)
www.it-ebooks.info

Chapter 4
89
Social data modeling with Neo4j
Data sources, such as Twitter, Facebook, and LinkedIn, are excellent sources of social data, 
and this data can be modeled in Neo4j to get useful insights.
In this recipe, you will learn how to model LinkedIn data using Neo4j.
Getting ready
Install the Neo4j graph database on the host machine using the recipe described in 
Chapter 1, Getting Started with Neo4j. This installation process will depend on your 
preference for your machine OS type.
For this recipe, we will use data from LinkedIn, which although it is not open, some part of 
it can be obtained using the LinkedIn API.
How to do it...
Let's model this data to get some insights from LinkedIn:
User – [IS_FRIEND_OF] – User[s]
User – [IS_EMPLOYEE_OF] – Company[s]
User – [HAS_SKILL] – Skill[s]
Company – [NEED_SKILL] – Skill[s]
Let's answer some questions on the basis of our social graph:
f
f
Friends who belong to my skill set: Let's find out the friends who match my 
profile skill set, using this query:
MATCH (me)-[:HAS_SKILL]->(s:Skills)<-[r:HAS_SKILL]-(u:User)
RETURN u.name,count(r),s
Order by count(r) 
f
f
Friends who like my posts the most: Let's find out who have most liked my posts 
using this query:
MATCH (me)-[:HAS_POSTED]->(a:Article)<-[r:LIKED]-(u:User)
RETURN u.name,count(r)
Order by count(r)
f
f
Suitable candidates for a company: Let's find out the suitable candidates for a job 
description, which a company has posted recently, in which Java is mandatory, using 
the following query:
MATCH (company)-[:NEED_SKILL]->(s:Skills)<-[r:HAS_SKILL]-
(u:User) where s.name in ["Java"]
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
90
RETURN u.name,count(r),s
Order by count(r) 
Other social data can also be easily modeled into the graph. The following image shows Twitter 
graph modeling in Neo4j, which is taken from Neotechnology (http://neo4j.com/):
In the preceding image, the following elements are present:
f
f
Green nodes (with names), which are Twitter users
f
f
Red nodes, which are tweets
f
f
Purple nodes, which are retweets
f
f
Blue nodes, which are mentions (or replies)
How it works...
The data has been modeled using the connected data model, with each entity, 
called a node, in the graph has being linked with what it is connected to.
See also
One excellent sources of open dataset is Stanford SNAP, which is available at 
http://snap.stanford.edu/.
www.it-ebooks.info

Chapter 4
91
Retail data modeling with Neo4j
In this recipe, you will learn how to model retail data using Neo4j.
Getting ready
Install the Neo4j graph database over the host machine using the recipe described in 
Chapter 1, Getting Started with Neo4j. This installation process will depend on your 
preference for your machine OS type.
How to do it...
Let's model this data to build a retail insight engine:
Customer – [HAVE] – Location
Customer – [BUYS] – Product[s]
Product – [HAVE] – Categories
Customer-[LOOKS]- Product[s]
The following screenshot shows the retail graph modeling:
Product
Customer
31065
31066
BUY
Let's answer some questions on the basis of our retail graph, which are as follows:
f
f
The day on which there is the highest sale of wine: Let's find out on which day 
there is the highest sale of wine. In this, we will also make use of an aggregated 
model, where the given dates will be aggregated on the basis of days, as follows:
MATCH (p:Product{name:"perfume"})-[r:SOLD_ON]->(d:date)<-
[X:DAY_OF_WEEK]-(w:Weekday)
RETURN w, count(r)
Order by count(r)
f
f
Which two products are sold together the most: Let's find out which products are 
sold together the most times using this query:
MATCH (u:Customer)-[:BUY]->(p:Product),(u)-[:BUY]->(p)
return p
www.it-ebooks.info

Data Modeling and Leveraging with Neo4j
92
How it works...
The data has been modeled using the connected data model, with each entity, called a node, 
in the graph has being linked with what it is connected to.
See also
One excellent source of open datasets is Stanford SNAP, http://snap.stanford.edu/.
Apart from these recipes, you can learn about the other excellent sources of domain data 
modeling using Neo4j from the following links:
f
f
http://docs.neo4j.org/chunked/stable/data-modeling-examples.html
f
f
https://github.com/neo4j-contrib/graphgist/wiki
www.it-ebooks.info

93
Mining the Social 
Treasure
In this chapter, we will cover the following recipes:
f
f
Finding mutual friends with Neo4j
f
f
Finding friends of friends with Neo4j
f
f
Activity streaming with Neo4j
f
f
Finding user similarity with Neo4j
f
f
Network reachability with Neo4j
Introduction
According to the article Social Data Revolution on Wikipedia, social data can be defined 
as follows:
"Social data refers to data individuals create that is knowingly and voluntarily 
shared among them."
Social data platforms, such as Facebook, Twitter, and LinkedIn, are enabling individuals 
to form groups, share their thoughts, express opinions, and connect with other individuals 
based on common interests.
In this chapter, we will cover various recipes to mine social data with Neo4j. The scale is very 
important when it comes to social data, as a graph database can quickly reach billions of 
nodes and their relationships on hugely popular social networks.
5
www.it-ebooks.info

Mining the Social Treasure
94
You will learn about common algorithms through the recipes, which you will find helpful while 
implementing a new social platform or analyzing the output from existing ones.
Before trying our first recipe, let's recap the basics of Cypher query elements:
f
f
START: This is used to denote the starting node in the graph
f
f
MATCH: This is used to match patterns with respect to the starting node
f
f
WHERE: This is used to filter the results
f
f
RETURN: This is used to return the results
f
f
CREATE: This is used to create basic graph elements, which are nodes and 
relationships
f
f
DELETE: This is used to delete graph elements
f
f
SET: This is used to set the value of the properties in the graph
f
f
WITH: This is used to divide the query into distinct parts
f
f
FOREACH: This is used to loop across the elements in the graph
One of the most important aspects of social data with Neo4j is the proper modeling of the data. 
Most of the query parameters must be near the nodes to avoid the unnecessary traversal of 
relationships, which can have a serious impact on performance in large social graphs.
It is then advisable to follow proven patterns, much like design patterns, which are 
well understood for a given set of problems. Neo4j has done exceptionally well on the 
documentation front and has described many of them at http://neo4j.com/docs/
stable/data-modeling-examples.html.
The data used in the following recipes can be obtained from the following APIs exposed by 
the social network. Here are the links for five such social networks:
f
f
Facebook: https://developers.facebook.com/
f
f
LinkedIn: http://developer.linkedin.com/apis
f
f
Twitter: https://dev.twitter.com/docs/api
f
f
GitHub: https://developer.github.com/v3/
f
f
Foursquare: https://developer.foursquare.com/
For the sake of simplicity in describing recipes, we have taken one model from Neo4j gist; 
for more information, refer to http://gist.neo4j.org/?8389170.
www.it-ebooks.info

Chapter 5
95
The following diagram depicts one of the example of the Neo4j model for social data:
Finding mutual friends with Neo4j
Sally and John are Facebook friends. Now, find out the people who are friends with both Sally 
and John. This is also known as the mutual friend problem.
In this recipe, you will learn how to find mutual friends between two people.
Getting ready
Perform the following steps to get ready for this recipe:
1.	 Install Neo4j on your machine using the recipes from Chapter 1, Getting 
Started with Neo4j.
www.it-ebooks.info

Mining the Social Treasure
96
2.	 Use the following Cypher script to create the dataset for this recipe:
CREATE
    (bradley:User {name:'Bradley', surname:'Green', age:24, 
city:'Los Angeles'}),
    (matthew:User {name:'Matthew', surname:'Cooper', age:36, 
city:'Los Angeles'}),
    (lisa:User {name:'Lisa', surname:'Adams', age:15, 
city:'New York'}),
    (annie:User {name:'Annie', surname:'Behr', age:25, 
city:'Chicago'}),
    (ripley:User {name:'Ripley', surname:'Aniston', city:'Los 
Angeles'}),
    (john:User {name:'John', surname:'Goodman', age:34, 
city:'New York'}),
    (amy:User {name:'Amy', surname:'Cooper', age:22}),
    (mark:User {name:'Mark', surname:'McAdams', age:17, 
city:'Los Angeles'}),
    (dennis:User {name:'Dennis', surname:'Lemon', age:42, 
city:'Los Angeles'}),
//FRIEND
    (bradley)-[:FRIEND]->(matthew),
    (bradley)-[:FRIEND]->(ripley),
    (bradley)-[:FRIEND]->(john),
    (matthew)-[:FRIEND]->(bradley),
    (lisa)-[:FRIEND]->(matthew),
    (lisa)-[:FRIEND]->(annie),
    (annie)-[:FRIEND]->(lisa),
    (annie)-[:FRIEND]->(matthew),
    (annie)-[:FRIEND]->(ripley)
3.	 The graph will look similar to the graph in the following screenshot after you run the 
following Cypher query:
MATCH (a)-[:'FRIEND']->(b) RETURN a,b
www.it-ebooks.info

Chapter 5
97
The following screenshot shows the output of the preceding query, depicting Neo4j's 
friend graph:
How to do it...
The following Cypher queries will get you started with this recipe; the recipe has been broken 
down into subrecipes:
f
f
The following Cypher query will find out the common friends between Annie and Lisa:
MATCH pMutualFriends=(me)-[:FRIEND]->(mf)<-[:FRIEND]-(other) 
where me.name = "Annie" and other.name = "Lisa" RETURN mf.name
www.it-ebooks.info

Mining the Social Treasure
98
This is the output of the preceding mutual friends Cypher query:
f
f
Now, let's find out which user shares the most number of common friends with Annie 
using the following query:
MATCH pMutualFriends=(me)-[:FRIEND]->(mf)<-[:FRIEND]-(other) 
where me.name = "Annie" RETURN other.name,count(mf) ORDER BY 
count(mf) DESC
This is the output of the preceding mutual friends count Cypher query:
f
f
Now, use the following query to find out which two users share the most number 
of common friends in the network (an expensive query that is not advisable on 
large graphs):
OPTIONAL MATCH pMutualFriends=(me)-[:FRIEND]->(mf)<-[:FRIEND]-
(other) RETURN me.name AS Friend1,other.name AS 
Friend2, count(mf) AS Count ORDER BY count(mf) DESC LIMIT 2
How it works...
This is a relatively simple query that can be easily deciphered, as follows:
MATCH pMutualFriends=(me)-[:FRIEND]->(mf)<-[:FRIEND]-(other) where 
me.name = "Annie" and other.name = "Lisa" RETURN mf.name
In the preceding query, (me)-[:FRIEND]->(mf) gives the mutual friends between Annie 
and Lisa, namely Matthew and Ripley.
www.it-ebooks.info

Chapter 5
99
Now, we find out how many of them share a relationship with Lisa using [Lisa, Matthew 
and Ripley]<- [:FRIEND]-(other), which gives us only Matthew.
The other Cyphers can also be deciphered by following the previous steps.
Finding friends of friends with Neo4j
If you have used Facebook or LinkedIn, you must have seen something such as "People 
you may know". This feature can be implemented using various different algorithms; most 
common are mutual friends, common interests, common location, and so on.
In this recipe, you will learn how to implement these algorithms and implement this feature 
with Neo4j.
Getting ready
The steps required for this recipe are similar to the steps described in the first recipe of this 
chapter. We are adding one more field, Interest, to find friends based on mutual interests. 
Apart from the Cypher query used in the first recipe of this chapter, we add the following 
nodes and relationships in a similar Cypher query, as shown here:
CREATE
(music:Interest {name : 'music'}),
(sports:Interest {name : 'sports'}),
(dance:Interest {name : 'dance'}),
//INTEREST
    (bradley)-[:INTEREST]->(music),
    (bradley)-[:INTEREST]->(dance),
    (john)-[:INTEREST]->(dance),
    (matthew)-[:INTEREST]->(sports),
    (lisa)-[:INTEREST]->(music),
    (lisa)-[:INTEREST]->(dance),
    (annie)-[:INTEREST]->(sports),
    (annie)-[:INTEREST]->(music),
    (ripley)-[:INTEREST]->(music),
    (ripley)-[:INTEREST]->(dance),
    (amy)-[:INTEREST]->(sports),
    (amy)-[:INTEREST]->(dance),
    (mark)-[:INTEREST]->(music),
    (mark)-[:INTEREST]->(dance)
www.it-ebooks.info

Mining the Social Treasure
100
The following screenshot depicts Neo4j's user interest graph:
User
Interest
18
11
10
19
9
20
INTEREST
INTEREST
INTEREST
INTEREST
INTEREST
FRIEND
FRIEND
It is advisable to create a large number of nodes with varying interests and locations to 
properly visualize the results.
How to do it...
The following Cypher queries will get you started with this recipe. The recipe has been broken 
down into subrecipes:
f
f
Let's implement our first algorithm to find a new friend based on maximum mutual 
friends, using the following Cypher query:
MATCH pMutualFriends=(me { name: 'Annie' })-[:FRIEND*2..2]-
>(foaf)
WHERE NOT (me)-[:FRIEND]-(foaf) AND NOT me=foaf
RETURN foaf.name, COUNT(*)
ORDER BY COUNT(*) DESC , foaf.name
This is the output of the preceding Cypher query:
www.it-ebooks.info

Chapter 5
101
f
f
Let's find some new friends based on the maximum number of common interests 
shared by the user using the following query:
MATCH (me { name: 'Bradley' })-[:INTEREST]->(stuff)<-
[:INTEREST]-(new_friend)
WHERE NOT (me)-[:friend]-(new_friend)
RETURN new_friend.name, count(stuff)
ORDER BY count(stuff) DESC LIMIT 3
This is the output of the preceding query, which shows the friends found based on 
common interests:
f
f
Similarly, there can be other algorithms based on commonly visited places, as shown 
in the following query:
MATCH (me { name: 'Bradley' })-[:VISITED]->(stuff)<-[: 
VISITED]-(new_friend)
WHERE NOT (me)-[:friend]-(new_friend)
RETURN new_friend.name, count(stuff)
ORDER BY count(stuff) DESC LIMIT 3
f
f
Use the following query to find friends in the same age group:
MATCH (me { name: 'Bradley' })-[:FRIEND]->(mf)-[:FRIEND]-
>(new_friend)
WHERE NOT (me)-[:friend]-(new_friend) AND (me.age <= 1.1 * 
new_friend.age AND me.age >= new_friend.age)
RETURN new_friend.name,new_friend.age,me.age LIMIT 3
f
f
Two or more of these algorithms can also be clubbed together, as follows:
MATCH pMutualFriends=(me { name: 'Annie' })-[:FRIEND*2..2]-
>(foaf)
WHERE NOT (me)-[:FRIEND]-(foaf) AND (me.age <= 1.1 * foaf.age 
AND me.age >= foaf.age) AND NOT me=foaf
RETURN foaf.name, COUNT(*)
ORDER BY COUNT(*) DESC , foaf.name
www.it-ebooks.info

Mining the Social Treasure
102
So, in this recipe, you learned the most common algorithms to implement the "Finding new 
friends" feature of a social network. In a large graph such as Facebook or LinkedIn, it is 
advisable to keep the distance between you and your new friend as minimum as possible 
(less than 1) so as not to impact the overall performance. It is advisable to run these queries 
as a batch and insert their results again into the graph.
How it works...
This is a relatively simple query that can be easily deciphered, as follows:
MATCH pMutualFriends=(me { name: 'Annie' })-[:FRIEND*2..2]->(foaf)
WHERE NOT (me)-[:FRIEND]-(foaf) AND NOT me=foaf
RETURN foaf.name, COUNT(*)
ORDER BY COUNT(*) DESC , foaf.name
In the preceding query, (me { name: 'Annie' })-[:FRIEND*2..2]->(foaf) gives 
all the users that are at a distance of 2 from Annie, where a distance of 1 represents all the 
friends of Annie.
After that, using the filter WHERE NOT (me)-[:FRIEND]-(foaf) AND NOT me=foaf, we 
check whether the new friend returned is not already in my friend list or is not mapped to me.
Then, we return the results based on the maximum number of common friends with the new 
friend, as shown here:
RETURN foaf.name, COUNT(*)
ORDER BY COUNT(*) DESC , foaf.name
The preceding query can also be easily deciphered on similar lines, as follows:
MATCH (me { name: 'Bradley' })-[:VISITED]->(stuff)<-[: VISITED]-
(new_friend)
WHERE NOT (me)-[:friend]-(new_friend)
RETURN new_friend.name, count(stuff)
ORDER BY count(stuff) DESC LIMIT 3
Activity streaming with Neo4j
The implementation of activity streaming or news feed is one of the most fundamental 
features of any social network, which enables a user to follow the activity of other users 
in real time, making it more engaging.
In this recipe, you will learn how to implement activity streaming or news feed with Neo4j.
www.it-ebooks.info

Chapter 5
103
Getting ready
The steps required for this recipe are similar to the steps described in the first recipe of this 
chapter. We are adding one more field, Status, to get updates from friends. Apart from the 
Cypher query used in the first recipe of this chapter, add the following nodes and relationships 
to a similar Cypher query:
//STATUS
(st1:Status { text : 'I am sleeping', date:'1234'}),
(st2:Stautus { text : 'Going to ibiza', date:'1345'}),
(st3:Status { text : 'Added mark as friend', date:'1695'}),
(st4:Status { text : 'Going to college', date:'1700'}),
(st5:Stautus { text : 'Eating pizza', date:'1567'})
(st6:Status { text : 'drinking coffee', date:'2000'}),
// STATUS Updates
(bradley)-[:STATUS]->(st1),
(bradley)-[:STATUS]->(st2),
(matthew)-[:STATUS]->(st3),
(lisa)-[:STATUS]->(st4),
(lisa)-[:STATUS]->(st5),
(annie)-[:STATUS]->(st6),
The graph will now look like what is shown in the following screenshot:
The preceding screenshot depicts the output of the status update graph.
www.it-ebooks.info

Mining the Social Treasure
104
How to do it...
f
f
Let's implement our first algorithm to find the new latest status update from our 
friends, as follows:
MATCH (me { name: 'Annie' })-[:FRIEND]->(my_friend)-[:STATUS]-
(status_posted)
RETURN my_friend.name,status_posted.text,status_posted.date 
ORDER BY status_posted.date DESC LIMIT 1
This is the output of the preceding query, which depicts the fetching of the topmost 
status update:
f
f
Let's implement page loading using SKIP, where every page load will bring two more 
status updates:
MATCH (me { name: 'Annie' })-[:FRIEND]->(my_friend)-[:STATUS]-
(status_posted)
RETURN my_friend.name,status_posted.text,status_posted.date 
ORDER BY status_posted.date SKIP 1 LIMIT 2
This is the output of the preceding query, which depicts the fetching of status 
updates with page loads:
f
f
Now, to find the status updates of users who are not directly my friends but share one 
or more common interests with me, use the following query:
MATCH (me { name: 'Bradley' })-[:INTEREST]->(stuff)<-
[:INTEREST]-(new_friend)
WHERE NOT (me)-[:friend]-(new_friend)
WITH new_friend
MATCH (new_friend)-[:STATUS]-(status_posted)
RETURN new_friend.name,status_posted.text,status_posted.date 
ORDER BY status_posted.date DESC LIMIT 2
www.it-ebooks.info

Chapter 5
105
This is the output of the preceding query, which depicts the status update by users 
sharing interests:
There's also another way to model the same query, described in the Neo4j documentation, 
using the doubly linked list method. The model looks similar to the following diagram, which 
depicts the linked list modeling of status updates:
name= Bob
'
'
name= Alice
'
'
name= bob_s1
'
'
text= bobs status1
'
'
date=1
name= bob_s2
'
'
text= bobs status2
'
'
date=4
name= joe_s1
'
'
text= Joe status1
'
'
date=3
name=
oe
'J
'
FRIEND
status=CONFIRMED
'
'
FRIEND
status=CONFIRMED
'
'
FRIEND
status=PENDING
'
'
name= alice_s1
'
'
text= Alices status1
'
'
date=2
name= alice_s2
'
'
text= Alices status2
'
'
date=5
STATUS
STATUS
NEXT
NEXT
STATUS
In this type of model, the latest status update can be fetched using the following Cypher 
query:
MATCH (me { name: 'Annie' })-[rels:FRIEND*0..1]-(myfriend)
WHERE ALL (r IN rels WHERE r.status = 'CONFIRMED')
WITH myfriend
MATCH (myfriend)-[:STATUS]-(latestupdate)-[:NEXT*0..1]-
(status_posted)
www.it-ebooks.info

Mining the Social Treasure
106
RETURN myfriend.name AS name, status_posted.date AS date, 
status_posted.text AS text
ORDER BY status_posted.date DESC LIMIT 1
The new status updates can be inserted using the following Cypher query:
MATCH (me)
WHERE me.name='Annie'
OPTIONAL MATCH (me)-[r:STATUS]-(secondlastupdate)
DELETE r
CREATE (me)-[:STATUS]->(latest_update { text:'Status',date:123 })
WITH latest_update, collect(secondlastupdate) AS seconds
FOREACH (x IN seconds | CREATE latest_update-[:NEXT]->x)
RETURN latest_update.text AS new_status
How it works...
Let's decipher the following Cypher query:
MATCH (me { name: 'Annie' })-[:FRIEND]->(my_friend)-[:STATUS]-
(status_posted)
RETURN my_friend.name,status_posted.text,status_posted.date ORDER 
BY status_posted.date DESC LIMIT 1
In this query, we first find the friends of the user Annie and then the status updates from them 
in the order of time.
Similarly, in finding the status posts by users who share common interests with the user, we 
first find all the users that share common interests using the following query:
MATCH (me { name: 'Bradley' })-[:INTEREST]->(stuff)<-[:INTEREST]-
(new_friend)
WHERE NOT (me)-[:friend]-(new_friend)
WITH new_friend
Then, we find all the status updates by them, ordered by date.
The linked list type of modeling is more like inserting an element in the linked list, where we 
first find the latest post using the following line:
OPTIONAL MATCH (me)-[r:STATUS]-(secondlastupdate)
Then, we delete the relationship using DELETE r so as to insert a new post in the place of 
an older one. The new post is inserted using the following Cypher query:
CREATE (me)-[:STATUS]->(latest_update { text:'Status',date:123 })
www.it-ebooks.info

Chapter 5
107
WITH latest_update, collect(secondlastupdate) AS seconds
FOREACH (x IN seconds | CREATE latest_update-[:NEXT]->x)
Finding user similarity with Neo4j
It is often necessary to find the similarities between things on any social network so as to 
effectively propose new things and other suggestions.
In this recipe, you will learn how to implement algorithms for finding similarities between 
users based on some criteria.
Getting ready
The steps required for this recipe are similar to the steps described in the first recipe of this 
chapter. We are adding one more field, Place visited and times, to similar friends. Instead 
of the Cypher query used in the first recipe of this chapter, add the following nodes and 
relationships to a similar Cypher query:
//Places
(pl1:Place { type: 'Disco'}),
(pl2:Place { type : 'Coffee bar'}),
(pl3:Place { type : 'Church'}),
(pl4:Place { type : 'College'}),
(pl5:Place { type : 'pizza Corner'}),
(pl6:Place { type : 'Stadium'}),
//VISITED
(Bradley)-[:VISITED {times:5} ]-> (pl1),
(Bradley)-[:VISITED {times:1} ]-> (pl3)
How to do it...
The following Cypher queries will get you started with this recipe. The recipe has been broken 
down into subrecipes, as follows:
f
f
Let's implement our first algorithm to find the similarity index between two users 
based on the number of times they have visited the same type of place using the 
following query:
MATCH (me { name: 'Bradley' })-[r1:VISITED]->(place)<-
[r2:VISITED]-(you {name: 'Lisa'})
RETURN SUM(ABS(r1.times-r2.times)) as Similarity
www.it-ebooks.info

Mining the Social Treasure
108
This is the output of the preceding query, which depicts the similarity index:
f
f
Find the top three users based on their similarity with the user, as shown in the 
following query:
MATCH (me { name: 'Bradley' })-[r1:VISITED]->(place)<-
[r2:VISITED]-(you)
WITH SUM(ABS(r1.times-r2.times)) as Similarity,you,me
RETURN you.name,me.name, Similarity
ORDER BY Similarity LIMIT 3
f
f
Let's learn how to find the cosine similarity index between users based on the rating 
for some Place using the following query:
MATCH (p1:User)-[x:RATED]->(m:Place)<-[y:RATED]-(p2:User)
WITH SUM(x.rating * y.rating) AS dp,
SQRT(REDUCE(xDot = 0.0, a IN COLLECT(x.rating) | xDot + a^2)) 
AS xLength,
SQRT(REDUCE(yDot = 0.0, b IN COLLECT(y.rating) | yDot + b^2)) 
AS yLength,
p1, p2
CREATE UNIQUE (p1)-[s:SIMILARITY]-(p2)
SET s.similarity = dp / (xLength * yLength)
RETURN p1,p2
f
f
Find nearest neighbors based on the similarity index we have just created as follows:
MATCH (p1:User)-[s:SIMILARITY]-(p2:User)
WITH p2, s.similarity AS sim
www.it-ebooks.info

Chapter 5
109
ORDER BY sim DESC
LIMIT 5
RETURN p2.name AS User, sim AS Score
f
f
Now, let's use the following query to find out whether a user will like a Place or not 
based on his similarity score and the places he has visited in the past:
MATCH (b:User)-[r:RATED]->(m:Place), (b)-[s:SIMILARITY]-
(a:User {name:'Lisa'})
WHERE NOT((a)-[:RATED]->(m))
WITH m, s.similarity AS similarity, r.rating AS rating
ORDER BY m.name, similarity DESC
WITH m.name AS place, COLLECT(rating)[0..3] AS ratings
WITH place, REDUCE(s = 0, i IN ratings | s + i)*1.0 / 
LENGTH(ratings) AS reco
ORDER BY reco DESC
RETURN place AS Place, reco AS Recommendation
How it works...
Neo4j has excellent support for mathematical functions, therefore the cosine similarity 
algorithm can be easily implemented in the Cypher query itself.
Network reachability with Neo4j
If you have visited any social website, it will show you your network reachability, such as 
23,951,064 professionals in your network.
In this recipe, you will learn how to find all the nodes reachable in your network.
Getting ready
1.	 Install Neo4j on your machine using steps in the earlier recipes.
2.	 Use the following Cypher script to create the dataset for this recipe:
CREATE
    (bradley:User {name:'Bradley', surname:'Green', age:24, 
city:'Los Angeles'}),
    (matthew:User {name:'Matthew', surname:'Cooper', age:36, 
city:'Los Angeles'}),
    (lisa:User {name:'Lisa', surname:'Adams', age:15, 
city:'New York'}),
www.it-ebooks.info

Mining the Social Treasure
110
    (annie:User {name:'Annie', surname:'Behr', age:25,})
    (disjoint:User{name:'Andy', surname:'Leone', age:47, 
city:'Los Angeles'}),
//FRIEND
    (bradley)-[:FRIEND]->(matthew),
    (bradley)-[:FRIEND]->(ripley),
    (bradley)-[:FRIEND]->(john),
    (matthew)-[:FRIEND]->(bradley)
By performing the preceding steps, we have created a node that is not connected to any 
other node in the graph.
How to do it...
The following steps demonstrate how to obtain the network reachability in Neo4j:
f
f
Let's find all the nodes that are reachable in the network using the following 
Cypher query:
MATCH (a {name:'Annie'})-[:FRIEND*..]->(b) where NOT a=b 
RETURN count(DISTINCT(b))
f
f
If we have to find all the users reachable from Annie (not advisable on a large graph), 
then use the following query:
MATCH (a {name:'Annie'})-[:FRIEND*..]->(b) where NOT a=b 
RETURN DISTINCT(b.name)
This is the output of the preceding query, which depicts network reachability 
using Neo4j:
www.it-ebooks.info

Chapter 5
111
How it works...
Network reachability can be easily found using path traversals in Neo4j using a variable 
length path query, as follows:
MATCH (a {name:'Annie'})-[:FRIEND*..]->(b)
In this chapter, you learned that any social network can be implemented with Neo4j 
and almost any useful feature you find on Facebook or LinkedIn can be easily implemented 
in Neo4j.
www.it-ebooks.info

www.it-ebooks.info

113
6
Developing 
Location-based 
Services with Neo4j
In this chapter, we will cover the following recipes:
f
f
Installing the Neo4j Spatial extension
f
f
Importing the Esri shapefiles
f
f
Importing the OpenStreetMap files
f
f
Importing data using the REST API
f
f
Creating a point layer using the REST API
f
f
Finding geometries within the bounding box
f
f
Finding geometries within a distance
f
f
Finding geometries within a distance using Cypher
Introduction
By definition, any database that is optimized to store and query the data that represents 
objects defined in a geometric space is called a spatial database. Although Neo4j is primarily 
a graph database, due to the importance of geospatial data in the modern world, the spatial 
extension has been introduced in to Neo4j as an unmanaged extension. It gives you most 
of the facilities that are provided by common geospatial databases along with the power of 
connectivity through edges, which Neo4j, as a graph database, provides.
In this chapter, we will take a look at some of the widely-used use cases of Neo4j as a spatial 
database, and you will learn how typical geospatial operations can be performed on it.
www.it-ebooks.info

Developing Location-based Services with Neo4j
114
Installing the Neo4j Spatial extension
Neo4j Spatial is a library of utilities for Neo4j that facilitates the enabling of spatial operations 
on the data. Even on the existing data, geospatial indexes can be added and many geospatial 
operations can be performed on it.
In this recipe, you will learn how to install the Neo4j Spatial extension.
Getting ready
The following steps will get you started with this recipe:
1.	 Install the Neo4j graph database using the recipes from Chapter 1, Getting Started 
with Neo4j. This installation process will depend on your preference for your machine 
OS type.
2.	 Install the dependencies listed in the pom.xml file for this project from 
https://github.com/neo4j-contrib/spatial/blob/master/pom.xml.
3.	 Install Maven using the following command for your operating system:


For Debian systems:
apt-get install maven


For Red Hat Linux/CentOS systems:
yum install apache-maven


To install on a Windows-based system, please refer to https://maven.
apache.org/guides/getting-started/windows-prerequisites.
html.
How to do it...
Now, let's install the Neo4j Spatial plugin, which is very simple to do, by following these steps:
1.	 Clone the GitHub repository for the Spatial extension:
git clone git://github.com/neo4j/spatial spatial
2.	 Move into the spatial directory:
cd spatial
3.	 Build the code using Maven. This will download all the dependencies, compile the 
library, run the tests, and install the artifacts in the local repository:
mvn clean install
www.it-ebooks.info

Chapter 6
115
4.	 Move the built artifact into the Neo4j plugin directory:
unzip target/neo4j/neo4j-spatial-0.11-SNAPSHOT-server-
plugin.zip $NEO4J_ROOT_DIR/plugins/
5.	 Restart the Neo4j graph database server:
$NEO4J_ROOT_DIR/bin/neo4j restart
6.	 Check whether the Neo4j Spatial plugin is properly installed or not:
curl –L http://<neo4j_server_ip>:<port>/db/data
If you are using Neo4j 2.2 or higher, then use the following command:
curl --user neo4j:<password> http://localhost:7474/db/data/
The output will look like what is shown in the following screenshot, which shows the 
Neo4j Spatial plugin installed:
How it works...
Neo4j Spatial is a library of utilities that help to perform geospatial operations on the dataset, 
which is present in the Neo4j graph database. You can add geospatial indexes to the existing 
data and perform operations, such as data within a specified region or within some distance 
of point of interest.
Neo4j Spatial comes as an unmanaged extension, which can be easily installed, as well as 
removed from Neo4j. The extension does not interfere with any of the core functionality, 
which we have seen in the earlier chapters of this book.
There's more…
To read more about the Neo4j Spatial extension, we encourage users to visit the GitHub 
repository at https://github.com/neo4j-contrib/spatial.
Also, it is a good idea to read about the Neo4j unmanaged extension in general 
(http://neo4j.com/docs/stable/server-unmanaged-extensions.html).
www.it-ebooks.info

Developing Location-based Services with Neo4j
116
Importing the Esri shapefiles
The shapefile format is a popular geospatial vector data format for the Geographic Information 
System (GIS) software. It is developed and regulated by Esri as an open specification for data 
interoperability among Esri. It is very popular among GIS products, and a lot of the time, the 
data format is in the Esri shapefiles.
The main file is the .shp file, which contains the geometry data. The binary data file consists 
of a single, fixed-length header followed by variable-length data records.
In this recipe, you will learn how to import the Esri shapefiles into the Neo4j graph database.
Getting ready
Perform the following steps to get started with this recipe:
1.	 Install Neo4j using the recipes from Chapter 1, Getting Started with Neo4j. This 
installation process will depend on your preference for your machine OS type.
2.	 Install the Neo4j Spatial plugin using the Installing the Neo4j Spatial extension, 
recipe from this chapter.
3.	 Restart the Neo4j graph database server using the following command:
$NEO4J_ROOT_DIR/bin/neo4j restart
How to do it...
Since the Esri shapefile format is, by default, supported by the Neo4j Spatial extension, 
it is very easy to import data using the Java API from it, by using the following steps:
1.	 Download a sample .shp file from http://www.statsilk.com/maps/
download-free-shapefile-maps.
Execute the following commands:
wget http://biogeo.ucdavis.edu/data/diva/adm/AFG_adm.zip
unzip AFG_adm.zip
mv AFG_adm1.* /data
2.	 The ShapefileImporter method lets you import data from the Esri shapefile 
using the following code:
GraphDatabaseService esri_database = new 
GraphDatabaseFactory().newEmbeddedDatabase(storeDir);
try {
www.it-ebooks.info

Chapter 6
117
    ShapefileImporter importer = new 
ShapefileImporter(esri_database);
importer.importFile("/data/AFG_adm1.shp", 
"layer_afganistan");
        } finally {
            esri_database.shutdown();
}
3.	 Using similar code, we can import multiple SHP files into the same layer or different 
layers, as shown in the following code snippet:
File dir = new File("/data");
      FilenameFilter filter = new FilenameFilter() {
          public boolean accept(File dir, String name) {
      return name.endsWith(".shp");
  }};
File[] listOfFiles = dir.listFiles(filter);
 for (final File fileEntry : listOfFiles) {
     System.out.println("FileEntry Directory "+fileEntry);
   try {
   importer.importFile(fileEntry.toString(),
"layer_afganistan");
} catch(Exception e){
   esri_database.shutdown();
}}
How it works...
The Neo4j Spatial extension natively supports the importing of data in the Esri shapefile 
format. Using the ShapefileImporter method, any SHP file can be easily imported into 
Neo4j. The ShapefileImporter method takes two arguments; the first argument is the 
path to the SHP files and the second is the layer in which it should be imported.
There's more…
We will encourage you to read more about shapefiles and layers in general; for this, please 
visit the following URLs for more information:
f
f
http://en.wikipedia.org/wiki/Shapefile
f
f
http://wiki.openstreetmap.org/wiki/Shapefiles
f
f
http://www.gdal.org/drv_shapefile.html
www.it-ebooks.info

Developing Location-based Services with Neo4j
118
Importing the OpenStreetMap files
OpenStreetMap is a powerhouse of data when it comes to geospatial data. It is a collaborative 
project to create a free, editable map of the world. OpenStreetMap provides geospatial data 
in the .osm file format. To read more about .osm files in general, check out http://wiki.
openstreetmap.org/wiki/.osm.
In this recipe, you will learn how to import the .osm files into the Neo4j graph database.
Getting ready
Perform the following steps to get started with this recipe:
1.	 Install Neo4j using the recipes from Chapter 1, Getting Started with Neo4j. This 
installation process will depend on your preference for your machine OS type.
2.	 Install the Neo4j Spatial plugin using the Installing the Neo4j Spatial extension, 
recipe from this chapter.
3.	 Restart the Neo4j graph database server:
$NEO4J_ROOT_DIR/bin/neo4j restart
How to do it...
Since the OSM file format is, by default, supported by the Neo4j Spatial extension, it is very 
easy to import data from it using the following steps:
1.	 Download one sample .osm file from http://wiki.openstreetmap.org/wiki/
Planet.osm#Downloading.
Execute the following commands:
wget http://download.geofabrik.de/africa-latest.osm.bz2
bunzip2 africa-latest.osm.bz2
mv africa-latest.osm /data
2.	 The importfile method lets you import data from the .osm file, as shown in the 
following code snippet:
OSMImporter importer = new OSMImporter("africa");
try {
    importer.importFile(osm_database, "/data/botswana-
latest.osm", false, 5000, true);
 } catch(Exception e){
    osm_database.shutdown();
}
importer.reIndex(osm_database,10000);
www.it-ebooks.info

Chapter 6
119
3.	 Using similar code, we can import multiple OSM files into the same layer or different 
layers, as shown here:
File dir = new File("/data");
     FilenameFilter filter = new FilenameFilter() {
         public boolean accept(File dir, String name) {
     return name.endsWith(".osm");
 }};
 File[] listOfFiles = dir.listFiles(filter);
 for (final File fileEntry : listOfFiles) {
     System.out.println("FileEntry Directory "+fileEntry);
   try {
importer.importFile(osm_database, fileEntry.toString(),
false, 5000, true);
 importer.reIndex(osm_database,10000);
 } catch(Exception e){
   osm_database.shutdown();
}
How it works...
This is slightly more complex as it requires two phases; the first phase requires a batch 
inserter performing insertions into the database, and the second phase requires the 
reindexing of the database with the spatial indexes.
There's more…
We will encourage you to read more about the OSM file and the batch inserter in general; 
for this, visit the following URLs:
f
f
http://en.wikipedia.org/wiki/OpenStreetMap
f
f
http://wiki.openstreetmap.org/wiki/OSM_file_formats
f
f
http://neo4j.com/api_docs/2.0.2/org/neo4j/unsafe/batchinsert/
BatchInserter.html
Importing data using the REST API
The recipes that you have learned until now consist of Java code, which is used to import 
spatial data into Neo4j. However, by using any other programming language, such as Python 
or Ruby, spatial data can be easily imported into Neo4j using the REST interface.
In this recipe, you will learn how to import geospatial data using the REST interface.
www.it-ebooks.info

Developing Location-based Services with Neo4j
120
Getting ready
Perform the following steps to get started with this recipe:
1.	 Install Neo4j using the recipes from Chapter 1, Getting Started with Neo4j. This 
installation process will depend on your preference for your machine OS type.
2.	 Install the Neo4j Spatial plugin using the Installing the Neo4j Spatial extension, 
recipe from this chapter.
3.	 Restart the Neo4j graph database server:
$NEO4J_ROOT_DIR/bin/neo4j restart
How to do it...
Using the REST API interface is a very simple three-stage process to import the geospatial 
data into the Neo4j graph database server. For the sake of simplicity, the code of the Python 
language has been used to explain this recipe, although you can also use curl for this recipe:
1.	 Create the spatial index, as shown in the following code:
# Create geom index
url = http://<neo4j_server_ip>:<port>/db/data/index/node/
payload= {
    "name" : "geom",
    "config" : {
        "provider" : "spatial",
        "geometry_type" : "point",
        "lat" : "lat",
        "lon" : "lon"
    }
}
2.	 Create nodes as lat/lng and data as properties, as shown in the following code:
url = "http://<neo4j_server_ip>:<port>/db/data/node"
payload = {'lon': 38.6, 'lat': 67.88, 'name': 'abc'}
req = urllib2.Request(url)
req.add_header('Content-Type', 'application/json')
response = urllib2.urlopen(req, json.dumps(payload))
node = json.loads(response.read())['self']
3.	 Add the preceding created node to the geospatial index, as shown in the following 
code snippet:
#add node to geom index
url = "http:// 
www.it-ebooks.info

Chapter 6
121
<neo4j_server_ip>:<port>/db/data/index/node/geom"
payload = {'value': 'dummy', 'key': 'dummy', 'uri': node}
req = urllib2.Request(url)
req.add_header('Content-Type', 'application/json')
response = urllib2.urlopen(req, json.dumps(payload))
print response.read()
The data will look like what is shown in the following screenshot after the addition of a few 
more nodes; this screenshot depicts the Neo4j Spatial data that has been imported:
ReferenceNode
0
3
9
10
10
8
8
6
6
2
4
4
RTREE_...
RTREE_..
RTREE_..
RTREE_...
RTREE_R..
RTREE_
RTREE_REFERENCE
RTREE_REFERENCE
RTREE_ROOT
RTREE_M..
LAYER
The following screenshot depicts the properties of a single node that has been imported 
into Neo4j:
www.it-ebooks.info

Developing Location-based Services with Neo4j
122
How it works...
Adding geospatial data using the REST API is a three-step process, listed as follows:
1.	 Create a geospatial index using an endpoint, by following this URL as a template:
http://<neo4j_server_ip>:<port>/db/data/index/node/
2.	 Add a node to the Neo4j graph database using an endpoint, by following this URL 
as a template:
http://<neo4j_server_ip>:<port>/db/data/node
3.	 Add the created node to the geospatial index using the endpoint, by following this 
URL as a template:
http://<neo4j_server_ip>:<port>/db/data/index/node/geom
There's more…
We encourage you to read more about spatial REST API interfaces in general 
(http://neo4j-contrib.github.io/spatial/).
Creating a point layer using the REST API
In this recipe, you will learn how to create a point layer using the REST API interface.
Getting ready
Perform the following steps to get started with this recipe:
1.	 Install Neo4j using the recipes from Chapter 1, Getting Started with Neo4j. This 
installation process will depend on your preference for your machine OS type.
2.	 Install the Neo4j Spatial plugin using the Installing the Neo4j Spatial extension, 
recipe from this chapter.
3.	 Restart the Neo4j graph database server using the following command:
$NEO4J_ROOT_DIR/bin/neo4j restart
How to do it...
In this recipe, we will use the http://<neo4j_server_ip>:<port>/db/data/ext/
SpatialPlugin/graphdb/addSimplePointlayer endpoint to create a simple point layer.
www.it-ebooks.info

Chapter 6
123
Let's add a simple point layer, as shown in the following code:
"layer" : "geom",
"lat"   : "lat" ,
"lon"   : "lon",url = "http://
<neo4j_server_ip>:<port>//db/data/ext/SpatialPlugin/graphdb/addSim
plePointlayer
payload= {
"layer" : "geom",
"lat"   : "lat" ,
"lon"   : "lon",
}
r = requests.post(url, data=json.dumps(payload), headers=headers)
The data will look like what is shown in the following screenshot; this screenshot shows the 
output of the created point in the layer query:
How it works...
Creating a point in the layer query is based on the REST interface, which the Neo4j Spatial 
plugin already provides.
There's more…
We will encourage you to read more about spatial REST interfaces in general; to do this, visit 
http://neo4j-contrib.github.io/spatial/.
www.it-ebooks.info

Developing Location-based Services with Neo4j
124
Finding geometries within the bounding box
In this recipe, you will learn how to find all the geometries within the bounding box using the 
spatial REST interface.
Getting ready
Perform the following steps to get started with this recipe:
1.	 Install Neo4j using the recipes from Chapter 1, Getting Started with Neo4j. This 
installation process will depend on your preference for your machine OS type.
2.	 Install the Neo4j Spatial plugin using the Installing the Neo4j Spatial extension, 
recipe from this chapter.
3.	 Restart the Neo4j graph database server using the following command:
$NEO4J_ROOT_DIR/bin/neo4j restart
How to do it...
In this recipe, we will use the http://<neo4j_server_ip>:<port>/db/data/ext/
SpatialPlugin/graphdb/findGeometriesInBBox endpoint to find all the geometries 
within the bounding box.
Let's find all the geometries, using the following information:
"minx" : 0.0,
"maxx" : 100.0,
"miny" : 0.0,
"maxy" : 100.0
url = "http://
<neo4j_server_ip>:<port>//db/data/ext/SpatialPlugin/graphdb
payload= {
"layer" : "geom",
"minx" : 0.0,
"maxx" : 100.3,
"miny" : 0.0,
"maxy" : 100.0
}
r = requests.post(url, data=json.dumps(payload), headers=headers)
The data will look like what is shown in the following screenshot; this screenshot shows the 
output of the bounding box query:
www.it-ebooks.info

Chapter 6
125
How it works...
Finding geometries in the bounding box is based on the REST interface, which the Neo4j 
Spatial plugin provides. The output of the REST call contains an array of the nodes, containing 
the node's id, lat/lng, and its incoming/outgoing relationships. In the preceding output, 
you can see node id 54 returned as the output.
There's more…
We encourage you to read more about spatial REST interfaces in general; to do this, visit 
http://neo4j-contrib.github.io/spatial/.
Finding geometries within a distance
In this recipe, you will learn how to find all the geometries within a distance using the spatial 
REST interface.
Getting ready
Perform the following steps to get started with this recipe:
1.	 Install Neo4j using the recipes from Chapter 1, Getting Started with Neo4j. This 
installation process will depend on your preference for your machine OS type.
2.	 Install the Neo4j Spatial plugin using the Installing the Neo4j Spatial extension, 
recipe from this chapter.
www.it-ebooks.info

Developing Location-based Services with Neo4j
126
3.	 Restart the Neo4j graph database server using the following command:
$NEO4J_ROOT_DIR/bin/neo4j restart
How to do it...
In this recipe, we will use the http://<neo4j_server_ip>:<port>/db/data/ext/
SpatialPlugin/graphdb/findGeometriesWithinDistance endpoint to find all the 
geometries within a certain distance.
Let's find all the geometries between the specified distance using the following information:
"pointX" : -116.67,
"pointY" : 46.89,
"distanceinKm" : 500,
url = "http://
<neo4j_server_ip>:<port>//db/data/ext/SpatialPlugin/graphdb/findGe
ometriesWithinDistance
payload= {
"layer" : "geom",
"pointY" : 46.8625,
"pointX" : -114.0117,
"distanceInKm" : 500,
}
r = requests.post(url, data=json.dumps(payload), headers=headers)
The data will look like what is shown in the following screenshot; this screenshot shows the 
output of a withinDistance query:
www.it-ebooks.info

Chapter 6
127
How it works...
Finding the geometries within a distance is based on the REST interface that the Neo4j 
Spatial plugin provides. The output of the REST call contains an array of the nodes, containing 
the node's id, lat/lng, and its incoming/outgoing relationships. In the preceding output, we 
can see node id 71 returned as the output.
There's more…
We encourage you to read more about spatial REST interfaces in general (http://neo4j-
contrib.github.io/spatial/).
Finding geometries within a distance using 
Cypher
In this recipe, you will learn how to find all the geometries within a distance using the 
Cypher query.
Getting ready
Perform the following steps to get started with this recipe:
1.	 Install Neo4j using the recipes from Chapter 1, Getting Started with Neo4j. This 
installation process will depend on your preference for your machine OS type.
2.	 Install the Neo4j Spatial plugin using the Installing the Neo4j Spatial extension, 
recipe from this chapter.
3.	 Restart the Neo4j graph database server:
$NEO4J_ROOT_DIR/bin/neo4j restart
How to do it...
In this recipe, we will use the http://<neo4j_server_ip>:<port>/db/data/ext/
SpatialPlugin/graphdb/findGeometriesWithinDistance endpoint to find all the 
geometries within a certain distance.
Let's find all the geometries within a distance using a Cypher query:
"pointX" : -116.67,
"pointY" : 46.89,
"distanceinKm" : 500,
url = "http://<neo4j_server_ip>:<port>//db/data/cypher
payload= {
www.it-ebooks.info

Developing Location-based Services with Neo4j
128
"query" : "START n=node:geom('withinDistance:[46.9163, -114.0905, 
500.0]') RETURN n"
}
r = requests.post(url, data=json.dumps(payload), headers=headers)
The data will look like what is shown in the following screenshot; this screenshot shows the 
output of the withinDistance query that uses Cypher:
The following is the Cypher output in the Neo4j console:
How it works...
Cypher comes with a withinDistance query, which takes three parameters: lat, lon, 
and search distance.
www.it-ebooks.info

Chapter 6
129
There's more…
We encourage you to read more about spatial REST API interfaces in general 
(http://neo4j-contrib.github.io/spatial/).
www.it-ebooks.info

www.it-ebooks.info

131
7
Visualization of Graphs
In this chapter, we will cover the following recipes:
f
f
Visualization using the Neo4j console
f
f
Viewing your graph with Linkurious
f
f
The Neo4j graph with Gephi
f
f
Visualization with Neoeclipse
Introduction
Any data store is incomplete without visualization. The same applies to Neo4j, where 
a powerful visualization is required to convey the content lying underneath an easily 
understandable form. With visualization, it is easy to understand the patterns in the data 
highlight clusters, connections, and discoveries of a new set of properties. In this chapter, 
we will primarily explore two broad categories of tools:
f
f
Plug and Play tools: These are the tools where little or no programming is needed to 
visualize Neo4j. They can be made pointing to your Neo4j database, and the rest will 
be taken care of. They may not be as powerful as the second category but provide 
an excellent starting point for data scientists and machine learning people to start 
exploring the graph. The examples are the Neo4j console, Linkurious, and so on.
f
f
Write your own tools using graph visualization libraries: Often readymade tools 
don't provide the flexibility required for custom use cases or to visualize graphs in 
a certain manner. The most powerful graph visualization libraries, such as d3.js, 
sigma.js or vivagraph.js, provide you with some basic functions, such as node 
or edge creation, deletion, and others. The rest is left to you to decide how you use 
them to create powerful visualizations. Good programming or framework experience 
is needed when you are writing your own tool.
www.it-ebooks.info

Visualization of Graphs
132
We will mostly suggest you to start with the readymade tools that are available, find out their 
functionalities, check them with your use case, and if they don't suffice your purpose, then 
write your own tool. The recipes of this chapter will cover some of the tools frequently used 
to visualize the Neo4j graph.
Visualization using the Neo4j console
The easiest and fastest starting point to visualize Neo4j is via the Neo4j Webadmin Console. 
It automatically comes up when the Neo4j Server is started and is used to visualize the 
result of the Cypher query. In this recipe, we will learn more about Neo4j Webadmin Console 
visualization and how to customize it.
Getting ready
The following steps will get you started with this recipe:
1.	 Install Neo4j on your machine using the earlier recipes from Chapter 1, Getting 
Started with Neo4j.
2.	 Access the Neo4j Webadmin Console in the browser by navigating to 
http://<neo4j_server>:<port_name>. The default port is 7474.
The following screenshot depicts the Neo4j Webadmin Console:
www.it-ebooks.info

Chapter 7
133
How to do it...
The following steps will get you started with this recipe:
1.	 The Neo4j Webadmin Console only visualizes the output of Cypher queries, so let's 
start with a Cypher query on the Neo4j graph:
// What is related, and how
MATCH (a)-[r]->(b)
WHERE labels(a) <> [] AND labels(b) <> []
RETURN DISTINCT head(labels(a)) AS This, type(r) as To, 
head(labels(b)) AS That
LIMIT 10
The output of the the preceding query depicts the Neo4j visualization of the 
Cypher query:
www.it-ebooks.info

Visualization of Graphs
134
2.	 The individual nodes or edges can be dragged to conveniently visualize the graph. 
Also, the graph can be viewed in fullscreen. The individual node or edge can also 
be highlighted by clicking on it. The following screenshot depicts the node property 
visualization in the Neo4j Webadmin Console:
The nodes or edges can be styled according to your requirements, as shown in the 
following screenshot:
www.it-ebooks.info

Chapter 7
135
3.	 The Neo4j Webadmin Console visualization can also be styled using a Graph Style 
Sheet (GSS), which is very much like CSS. An example of one such style sheet is 
shown as follows:
node.Airport {
color: #30B6AF;
border-color: #46A39E;
text-color-internal: #FFFFFF;
diameter: 50px;
border-width: 2px;
caption: '{id}';
font-size: 10px;
}
So, we can say that Neo4j is quite flexible in styling when it comes to visualization. 
Let's change the attributes for the following and again visualize the graph:
node.Airport {
color: #FF6C7C;
border-color: #EB5D6C;
text-color-internal: #FFFFFF;
diameter: 80px;
border-width: 2px;
caption: ' {city}';
font-size: 10px;
}
The following screenshot depicts the Neo4j visualization after the changes have been 
made to the graph style sheet:
www.it-ebooks.info

Visualization of Graphs
136
How it works...
The Neo4j Webadmin Console works on the output of a Cypher query, where it parses the 
query result and converts it into nodes and edges. The visualization of nodes and edges 
takes the styling from the graph style sheet, which is very much like CSS. Let's see the 
pros and cons of using the Neo4j Webadmin Console as a visualization tool:
The following are the pros:
f
f
It is easy to set up and comes by default with Neo4j binaries
f
f
The output of any complex Cypher query can be visualized
f
f
It offers simple customization using the graph style sheet
f
f
Node properties can also be visualized using it
f
f
The Neo4j graph can easily be explored and used with a little knowledge 
of Cypher and can be fine-tuned for an optimized output
The following are the cons:
f
f
Since Neo4j Webadmin visualization works on Cypher query results, knowledge of 
Cypher becomes mandatory for using it
f
f
Zoom in or zoom out features on subgraphs are not available
f
f
A limited set of customizations comes with the Neo4j Webadmin Console
f
f
Graphs cannot be edited using it
f
f
A limited set of nodes and edges can be visualized using it
So, basically, the Neo4j Webadmin Console is a simple tool to get started quickly when 
it comes to visualizing the Neo4j graph. If you are looking for some power-packed features 
and large scale visualization of the Neo4j graph, then perhaps it is not the right choice.
Viewing your graph with Linkurious
Linkurious is one of the few start-ups that appears in the graph visualization field especially 
for Neo4j, and is getting good traction among the Neo4j community. It is packed with some 
powerful features, such as Search, and Explore, which are not directly present in the Neo4j 
Webadmin Console. It is a plug and play kind of a tool that can directly be pointed to 
Neo4j installation.
www.it-ebooks.info

Chapter 7
137
Getting ready
Since Linkurious is a paid visualization tool, we will use its demo version to visualize Neo4j. 
Go to the URL http://linkurio.us/try/ and after the registration, you will be redirected 
to the demo setup. The following screenshot depicts Linkurious' application console:
Let's dive more into the Linkurious Neo4j graph visualization.
How to do it...
The starting point of an application lets you query for any node in a free text form that 
also has autocomplete features. This is not Cypher-based, and the nodes that you are 
about to  search for are already been indexed into the Linkurious backend server. This 
functionality was missing in the Neo4j Webadmin Console.
www.it-ebooks.info

Visualization of Graphs
138
The following steps will get you started with this recipe:
1.	 Let's search for the node named abc, and see how Linkurious handles the query:
2.	 Let's select one of the nodes from the autocomplete list and check how it is shown. 
The output of the preceding query is as follows:
www.it-ebooks.info

Chapter 7
139
3.	 All relations in this node can be visualized. The following screenshot depicts all the 
edges of a particular node:
4.	 The properties of the selected nodes and edges can also be viewed in the right-hand 
side window as follows:
www.it-ebooks.info

Visualization of Graphs
140
5.	 The graph can also be edited in the visualization stage itself by creating new nodes or 
relationships. Right-click on any node:
The following screenshot shows how to create a new node with the Linkurious console:
www.it-ebooks.info

Chapter 7
141
6.	 Linkurious has a nifty feature of taking the screenshot of the graph in a picture 
format and storing it as an image file. The screenshot can be obtained by clicking on 
the camera button at the top of the console. This feature is very useful for sending 
someone interesting portions of the graph. The following screenshot demonstrates 
this feature:
Jean Reno
G rard Depardieu
é
Loic Brabant
Michel Aumont
Jean-Michel Noirey
Leonor Varela
Aur lien Recoing
é
Francis Veber
Edgar Givry
Ticky Holgado
Jean-Pierre Malo
Andr
Dussollier
é
Laurent Gamelon
Richard Berry
52
1
8
4
16
5
1
5
3
5
1
29
6
1
Tais-toi!
Vincent Moscafo
ACTS_IN
ACTS_IN
ACTS_IN
ACTS_IN
ACTS_IN
ACTS_IN
ACTS_IN
DIRECTED
ACTS_IN
ACTS_IN
ACTS_IN
ACTS_IN
ACTS_IN
ACTS_IN
www.it-ebooks.info

Visualization of Graphs
142
7.	
Linkurious also provides zoom in and zoom out features, which are very much required 
for visualizing large graphs. The zoom out feature can be applied by clicking on the plus 
button, as it is in Google Maps, and the zoom in feature can be applied by clicking on 
the minus button. The wheel can be used to change the focus to left/right or top/down. 
The following screenshot is a visualization of a bigger graph in Linkurious:
The demo version does not allow the user to point the Linkurious tool to its own 
installation. There are many other features, such as customization, and so on, which 
are present in the paid version of the tool.
8.	 Linkurious also provides a Cypher console, where Neo4j Cypher queries can be run 
and results can be visualized, as shown in the following screenshot:
www.it-ebooks.info

Chapter 7
143
How it works...
Linkurious is mainly built for graph users who are not very interested in the underlying details 
and want to visualize the graph in a simple, easy way like other database visualization. It 
comes with almost all the features when it comes to Neo4j graph visualization. Let's see the 
pros and cons of using Linkurious as a visualization tool:
The following are the pros:
f
f
It is easy to set up and requires little time to configure it for your own Neo4j installation
f
f
Its interface is simple and nodes/relationships can easily be visualized without the 
knowledge of Cypher queries
f
f
Power-packed features, such as graph editing, screenshots, and so on, come with it
f
f
The properties of a node/edge can also be visualized using it
www.it-ebooks.info

Visualization of Graphs
144
The following are the cons:
f
f
Linkurious is a paid tool, and its minimum licensing fee is 249 Euros per user
f
f
All the data is indexed before it is usable by Linkurious
f
f
The maximum graph size is limited to 500 nodes
These were the limitations which were checked at the time of writing this book. For newer 
release please check the Linkurious website http://linkurio.us/.
Linkurious is an excellent choice if you are not constrained by a budget and if you're looking 
at handling basic graph operations from the web console. This tool is recommended for data 
scientists who want to focus on graph data rather than diving deep into Neo4j basics.
The Neo4j graph with Gephi
Gephi is an award-winning and one of the best tools to use when it comes to any kind of 
graph visualization, whether this relates to networks, social, or any other. It is basically 
referred to as Photoshop for graphs. It has a 3D rendering engine that allows the graph 
to be visualized in 3D form.
In this recipe, we will learn how to visualize the Neo4j graph database with Gephi.
Getting ready
The following steps will get you started with Gephi for Neo4j:
1.	 Download Gephi from the URL https://gephi.github.io/.
2.	 Install it on your machine. As the installation is platform-specific, follow the 
instructions from the readme file before installing it.
3.	 Upgrade Gephi and install the Neo4j Graph Database Plugin. You can install the 
plugins by navigating to Tools | Plugins | Available Plugins, then checking the 
plugins you want to install. The following screenshot depicts a Gephi plugin store:
www.it-ebooks.info

Chapter 7
145
4.	 Once the plugin is installed, point it to the graph database directory on the local 
machine from where it will pickup the Neo4j graph data. The following screenshot 
depicts the loading of the Neo4j data into Gephi:
www.it-ebooks.info

Visualization of Graphs
146
5.	 Gephi also can take data in many other forms described in the URL http://gephi.
github.io/users/supported-graph-formats/. The other way to insert the 
Neo4j graph data into Gephi is by converting the Neo4j data into Graph Modeling 
Language (GML). This can be done by the following Python code:
g = new Neo4jGraph('data/graph.db');
g.saveGraphML('Mygraph.gml');
How to do it...
The following steps will get you started with this recipe:
1.	 Let's import the graph database into Gephi. The following screenshot depicts the 
Gephi console's database import window:
2.	 After the importing is done, the graph will look like the following screenshot. This 
screenshot depicts the visualization of Neo4j:
www.it-ebooks.info

Chapter 7
147
3.	 It provides various graph functions that are missing from other visualization tools, 
such as Graph Density, Average Degree, and so on, These are very useful in analyzing 
the graph. Let's find out the average degree of the graph that we have created. 
The following screenshot depicts the output of the average degree of the graph:
www.it-ebooks.info

Visualization of Graphs
148
There can be different layouts that can be applied to the graph. The following 
screenshot depicts the layout of the Neo4j graph:
How it works...
Gephi is an excellent tool when it comes to graph analysis. It provides all the previously 
mentioned functions to judge the quality of the graph. It is not specific to Neo4j, but a 
useful tool to visualize Neo4j from the graph theory angle.
The following are the pros:
f
f
It is easy to set up and requires little time to configure it for your own 
Neo4j installation
f
f
Its interface is simple and nodes/relationships can easily be visualized 
without the knowledge of Cypher queries
f
f
The properties of a node/edge can also be visualized using it
f
f
The graph analysis function is present in Gephi
f
f
It is good for large scale visualization
f
f
Gephi is a complex tool and supports complex algorithms, such as 
paths or layouts
The following are the cons:
f
f
A desktop application needs to be installed on every machine
f
f
Learning is difficult
f
f
There is no free text search present in Gephi
www.it-ebooks.info

Chapter 7
149
Visualization with Neoeclipse
Neoeclipse is the standalone workbench to visualize the Neo4j graph database. It is 
basically built on Eclipse and can be used as a Plug and Play tool to visualize the 
Neo4j graph database.
In this recipe, we will learn how to set up Neoeclipse and visualize Neo4j using it.
Getting ready
The following steps will get you started with Neoeclipse:
1.	 Install Neoeclipse on your platform from the URL https://github.com/neo4j-
contrib/neoclipse.
2.	 On Windows, it can be installed by simply double-clicking on it, whereas on Linux, 
it can be started by running a bash file, which is described in the readme file.
3.	 Create a connection in your database in the following manner. Neoeclipse can take 
a connection to the database either locally or using a URL connection. The following 
screenshot depicts how to create a new connection in Neoeclipse:
www.it-ebooks.info

Visualization of Graphs
150
4.	 After making a connection, it will look like the following screenshot:
How to do it...
The following steps will get you started with this recipe:
1.	 Click on the home button to visualize the Neo4j graph. The graph would look like the 
following screenshot depicting the visualization:
www.it-ebooks.info

Chapter 7
151
2.	 The output of the Cypher query can also be viewed in the Cypher query tab. The 
following screenshot depicts the Cypher query results:
The graph can also be edited using Neoeclipse.
How it works...
Neoeclipse is basically an Eclipse workbench plugin that uses the Neo4j REST interface 
as well as a native file support to read the Neo4j graph database. The benefit of using 
Neoeclipse is that it can easily integrate in your development environment. Let's see the pros 
and cons of using Neoeclipse as a visualization tool:
The following are the pros:
f
f
It is easy to set up and requires little time to configure it for your own Neo4j installation.
www.it-ebooks.info

Visualization of Graphs
152
f
f
Its interface is simple and nodes/relationships can easily be visualized without its 
knowledge
f
f
We can use the edge of Cypher queries
f
f
The properties of a node/edge can also be visualized using it
The following are the cons:
f
f
A desktop application needs to be installed on every machine
f
f
Visual traversal is not supported
f
f
The maximum graph size is limited to 50 nodes
Neoeclipse is a simple tool and provides limited options when it comes to visualizing Neo4j.
Here is the screenshot taken from Linkurious website depicting the key differences between 
the various tools, some of which are described in this chapter and some of which are not. 
The following screenshot shows the comparision of the various visualization options present 
for Neo4j:
www.it-ebooks.info

153
8
Industry Usages 
of Neo4j
In this chapter, we will cover the following recipes:
f
f
Healthcare with Neo4j
f
f
The social networking industry with Neo4j
f
f
The travel industry with Neo4j
f
f
Neo4j in e-commerce
Introduction
Neo4j is built for flexibility and domain independence, much like SQL, where it can be applied 
to almost any task. From start-ups to Fortune 500 companies, Neo4j is powering a number of 
innovative solutions through use cases across a wide range of industry sectors.
In this chapter, we will go through some of the widely used use cases of Neo4j, how it is being 
applied to specific domains, and what innovative solutions are getting built on top of it.
Healthcare with Neo4j
The healthcare sector is undergoing a complete revamp and lots of innovative solutions are 
coming up in this domain. The healthcare industry is one of the fastest sectors to adopt the 
graph revolution, and lots of companies are trying to make sense of data in order to generate 
powerful insights.
In this recipe, you will see some typical use cases of Neo4j in the healthcare domain.
www.it-ebooks.info

Industry Usages of Neo4j
154
Getting ready
Although this recipe consists of explaining the various use cases of Neo4j in the healthcare 
domain, we will still encourage you to build something useful in the healthcare domain from 
the sample data available. To do this, perform the following steps:
1.	 Set up a Neo4j instance using the recipes covered in Chapter 1, Getting Started 
with Neo4j, of this book. This installation process will depend on your preference for 
your machine OS type.
2.	 Set up a Neo4j spatial extension using the recipes covered in Chapter 6, 
Location-based Services with Neo4j, of this book.
Download healthcare data suitable to your requirements from https://www.
healthdata.gov/dataset/search.
3.	 Sample patient/doctor data can be generated from http://www.mockaroo.
com/, which gives you the ability to generate data of various types—up to 1,000 rows 
in the free edition and up to 10 million rows in the paid edition. For more data, you 
can either opt for a big data edition or write a simple script that gives you the ability 
to generate billions of data points. The following screenshot shows the patient data 
generated from Mockaroo:
How to do it...
Since this recipe consists of exploring the various use cases of Neo4j in the healthcare 
domain, this section will briefly describe each one of them. Let's find answers to the 
following use cases:
www.it-ebooks.info

Chapter 8
155
f
f
Finding a doctor that specializes in orthopedics within 5 miles: Patients usually 
require physicians of a certain specialty within a certain distance. A sample graph for 
this will look like what is shown here:
Patient
Location
Speciality
Location
Doctor
The following Cypher query can easily serve this recipe. The sample data required for 
the Cypher query can be obtained from the BetterDoctor API (https://developer.
betterdoctor.com/):
START n=node:DoctorLocation('withinDistance:[53.489271, -
2.246704, 5.0]') where n.speciality = "orphopedics" return n
f
f
Finding whether two drugs that I am taking interact or not: Most often, patients 
suffer from multiple diseases and take more than one drug. It is often necessary 
to find out whether any new drug prescribed to the patient will interact with 
the drug they are already taking. The data for this can be obtained from 
http://www.drugs.com/drug_interactions.html.
A sample graph for finding drug interactions will look like this:
Patient takes drug
Drug interacts with drug
Patient
Drug
Drug
Drug
Drug
www.it-ebooks.info

Industry Usages of Neo4j
156
The following Cypher query can easily serve this recipe:
MATCH (node {id:10})-[:IS_TAKING]->(drug)-[:INTERACTS_WITH]-
(new_drug)
WHERE new_drug.name = "aspirin"
RETURN drug.name
Here, node refers to the patient who has been prescribed a new drug whose id is 10.
f
f
Finding similarities between patients based on the diseases that they are 
suffering from: Most often, patients look for other patients who are suffering from a 
similar disease to share their experiences with, for advice, and so on. A sample graph 
for finding similar patients will look like this:
Patient suffers from
disease
Disease
Disease
Disease
Disease
Patient
Patient
The following Cypher query can easily serve this recipe:
MATCH (patient_a { name: 'Joe' })-[:suffers_from]->(disease)<-
[:suffers_from]-(patient_b)
RETURN patient_b.name, count(disease) ORDER BY count(disease)
f
f
Suggesting the best insurance policy based on a person's illness: This is also a 
frequently-used use case, where insurance has to be suggested to a person based 
on his/her budget, existing diseases or illness. A sample graph for finding the best 
insurance plan will look like this:
Insurance
Plan
Person
Cost
Hospital
Disease
Patient
Zipcode
Physician
We will encourage you to create a graph for this use case and write Cypher queries for it as well. 
www.it-ebooks.info

Chapter 8
157
How it works...
If you analyze all the preceding use cases, you will find that we have built all the healthcare 
use cases from the existing Neo4j knowledge that we have acquired from the recipes in earlier 
chapters. Thus, connecting all the relationships between various entities in the form 
of edges, gives you the power to come up with new innovative solutions from the data you 
already have. A similar thing is also possible in relational databases, but the ease with which 
data models and queries map each other in Neo4j gives the user the power to explore data 
and develop new use cases.
There's more…
We will recommend users read more about the existing case studies of Neo4j from the 
following links. This will enable them to study how different healthcare companies are utilizing 
Neo4j to build compelling solutions that are not only driving their revenue but also improving 
healthcare effectiveness:
f
f
http://neo4j.com/customers/
f
f
http://watch.neo4j.org/video/76806552
f
f
http://finance.yahoo.com/news/neo4j-graph-database-powers-
healthcare-130300803.html
The social networking industry with Neo4j
After the acquisition of WhatsApp by Facebook for a whopping 19 billion dollars, lots of 
start-ups are trying to build scalable chat services where the core functionality still remains 
the ability to allow users to communicate with each other. On top of that, they are trying 
to build innovative services that can give them a differentiating factor.
In this recipe, you will learn about some of the industry usages of Neo4j in chat applications, 
which form the backbone of social networks
Getting ready
Although this recipe consists of explaining the various use cases of Neo4j in chat 
applications, we will still encourage you to build something useful from the sample 
data available. To do this, perform the following steps:
1.	
Set up a Neo4j instance using the recipes covered in Chapter 1, Getting Started
with Neo4j, of this book. This installation process will depend on your preference for
your machine OS type.
2.	
Set up a Neo4j spatial extension using the recipes covered in Chapter 6,
Location-based Services with Neo4j, of this book.
www.it-ebooks.info

Industry Usages of Neo4j
158
3.	 Sample user data can be generated from http://www.mockaroo.com/, which 
gives you the ability to generate data of various types—up to 1,000 rows in the free 
edition and up to 10 million rows in the paid edition. For more data, you can either 
opt for a big data edition or write a simple script that gives you the ability to generate 
billions of data points. The following screenshot shows the generated sample user 
data for a chat application:
We have generated limited fields for demonstration purposes, but we will encourage you to 
generate more extensive data, which consists of interests, languages spoken, hobbies, and 
so on.
How to do it...
Since this recipe consists of exploring the various use cases of Neo4j in chat applications, 
this section will briefly describe each one of them. The following use cases can be deduced:
f
f
Finding new friends within 5 miles who like to play football: Most of the time, it is a 
requirement for the chat applications to show new friends who have similar interests. 
A sample graph for finding friends based on common interests will look like this:
User
Interest
Interest
Location
Location
User
www.it-ebooks.info

Chapter 8
159
The following Cypher query can easily serve this recipe:
START n=node:UserLocation('withinDistance:[53.489271, -
2.246704, 8.0]')
WITH n
MATCH (n)-[:LIKES]-[interest]
WHERE interest.name = "football"
RETURN n
f
f
Finding friends who are within 1 mile of where I am: Most applications 
nowadays show friends who are very close to each other so that they can 
possibly hang out together.
A sample graph for finding friends that are close by will look like this:
User
Interest
Location
Location
User
The following Cypher query can easily serve this recipe:
START n=node:UserLocation('withinDistance:[53.489271, -
2.246704, 1.6]')
MATCH (n)-[:FRIENDS]-[me]
RETURN n
f
f
Finding similar users based on interests: Chat applications will only be successful 
if they can make the user spend lots of time on the application. One of the primary 
needs for this will be to connect users based on common interests. A sample graph 
for finding similar users based on interests will look like this:
Interest
Interest
Interest
Interest
Location
User
Location
User
www.it-ebooks.info

Industry Usages of Neo4j
160
The following Cypher query can easily serve this recipe:
MATCH (user_a { name: 'Joe' })-[:LIKES]->(stuff)<-[:likes]-
(user_b)
RETURN user_b.name, count(stuff)
f
f
Suggesting the best pizza place based on a friend's visit: This is also a frequent use 
case, where a user suggests new places that they mostly visit for a particular delicacy 
to other users. A sample graph for finding the best pizza place will look like this:
Place
Place
Specially
User
User
User
We will encourage you to create a graph for this use case and write the Cypher queries for 
it as well.
How it works...
If you analyze all the preceding use cases, you will find that we have built all the social 
networking use cases from the existing Neo4j knowledge that we have acquired from the 
recipes in earlier chapters. Thus, connecting all the relationships between various entities 
in the form of edges gives you the power to come up with new innovative solutions from 
the data you already have.
There's more…
We recommend that users read more about the existing case studies of Neo4j from the 
following links. This will enable them to study how different chat applications are utilizing 
Neo4j to build compelling solutions which are not only driving their revenue but also improving 
the user experience and the amount of time the user spends on the applications:
f
f
http://neo4j.com/use-cases/recommendations/
f
f
http://www.onlinepersonalswatch.com/news/2014/01/neo4j-
interview-with-ceo-emil-eifrem.html
f
f
http://www.datingadvice.com/online-dating/graph-database-neo4j-
to-share-expert-insights-at-idate-2014
www.it-ebooks.info

Chapter 8
161
The travel industry with Neo4j
The travel industry is one of the biggest industries in terms of revenue, and recently, there has 
been a lot of buzz about making this domain more customer friendly and more persona-based.
In this recipe, you will learn about some of the industry usages of Neo4j in the travel domain.
Getting ready
Although this recipe consists of explaining the various use cases of Neo4j in the travel 
domain, we will still encourage you to build something useful in the travel domain from 
the sample data available. To do this, perform the following steps:
1.	 Set up a Neo4j instance using the recipes covered in Chapter 1, Getting Started 
with Neo4j, of this book. This installation process will depend on your preference for 
your machine OS type.
2.	 Set up a Neo4j spatial extension using the recipes covered in Chapter 6, 
Location-based Services with Neo4j, of this book.
3.	 Sample location data can be generated from http://www.mockaroo.com/, which 
gives you the ability to generate data of various types—up to 1,000 rows in the free 
edition and 10 million rows in the paid edition. For more data, you can either opt for 
a big data edition or write a simple script that gives you the ability to generate billions 
of data points. The following screenshot shows the sample data generated for the 
travel domain:
We have generated limited fields for demonstration, but we will encourage you to generate 
more extensive data that consists of user personas, the weather in a city, budgets, and so on.
www.it-ebooks.info

Industry Usages of Neo4j
162
How to do it...
Since this recipe consists of exploring the various use cases of Neo4j in the travel domain, 
this section will briefly describe each one of them. The following are the possible use cases 
that can be deduced:
f
f
Finding the nearest beach: A user, Joe, likes to travel to beaches and we have 
to suggest a beach nearest to him. A sample graph for finding a new place to visit 
based on an interest will look like this:
Place
User
Type
User Like Certain Type
Place has Type
The following Cypher query can easily serve this recipe:
START place=node:PlaceLocation('withinDistance:[53.489271, -
2.246704, 8.0]')
WITH place
MATCH (place)-[:TYPE]-[type]
WHERE type.name = "beach"
RETURN place LIMIT 1
f
f
Finding where I can see snowfall: A user wants to see snowfall, and we have to 
suggest some places near his location where snow is falling currently. A sample graph 
for finding places based on seasons will look like this:
City
User
Location
Weather
www.it-ebooks.info

Chapter 8
163
The following Cypher query can easily serve this recipe:
START n=node:PlaceLocation('withinDistance:[53.489271, -
2.246704, 100.0]')
MATCH (n)-[:HAS_WEATHER]-[weather]
WHERE weather.type = "snowfall"
RETURN n
f
f
Suggesting the shortest route to the user: This is used to suggest the shortest route 
to a user travelling from point A to point B. A sample graph for finding the shortest 
route will look like this:
London
NewYork
Hawai
Los Angeles
The following Cypher query can easily serve this recipe:
MATCH (src:Place { name:"london" }),(dst:Place { name:"hawai" 
}),
p = shortestPath((src)-[*..15]-(dst))
RETURN p
f
f
Suggesting the cheapest hotel to stay at near an airport: A user wants to search for 
the cheapest hotel to stay at near an airport. A sample graph for finding cheap hotels 
near airports will look like this:
Date
Hotel
Star Rating
Location
www.it-ebooks.info

Industry Usages of Neo4j
164
How it works...
If you analyze all the preceding use cases, you will find that we have built the most common 
travel use cases from the existing Neo4j knowledge we have acquired from the recipes in the 
earlier chapters. Thus, connecting all the relationships between various entities in the form 
of edges, gives you the power to come up with new innovative solutions from the data you 
already have.
There's more…
We will recommend that users read more about the existing case studies of Neo4j from the 
following links. This will enable them to study how different travel applications are utilizing 
Neo4j to build compelling solutions, which are not only driving their revenue but also 
improving user experience and the time users spend on the applications:
f
f
http://www.slideshare.net/neo4j/wanderu-lessons-from-building-
a-travel-site-with-neo4j-eddy-wong-graphconnect-ny-2013
f
f
http://www.tikalk.com/java/travel-nosql-application-polyglot-
nosql-springdata-neo4j-and-mongodb/
f
f
https://github.com/cosmin-marginean/poc-neo4j-tfl-travel-time/
blob/master/README.md
E-commerce with Neo4j
The e-commerce sector is booming with lots of start-ups coming up each year, each proving 
that they have better stuff than the rest and each providing a differentiating wow factor.
In this recipe, you will learn some of the industry usages of Neo4j in the e-commerce domain.
Getting ready
Although this recipe consists of explaining the various use cases of Neo4j in the e-commerce 
domain, we will encourage you to build something useful from the sample data available. 
To do this, perform the following steps:
1.	 Set up a Neo4j instance using the recipes covered in Chapter 1, Getting Started with 
Neo4j, of this book. This installation process will depend on your preference for your 
machine OS type.
2.	 Sample product data can be generated from http://www.mockaroo.com/, which 
gives you the ability to generate data of various types—up to 1,000 rows in the free 
edition and up to 10 million rows in the paid edition. For more data, you can either 
opt for a big data edition or write a simple script that gives you the ability to generate 
billions of data points. The following screenshot shows the generated sample product 
data for the e-commerce application:
www.it-ebooks.info

Chapter 8
165
We have generated limited fields for demonstration, but we will encourage you to generate 
more extensive data.
How to do it...
Since this recipe consists of exploring the various use cases of Neo4j in the e-commerce 
domain, this section will briefly describe each one of them. The following use case can be 
deduced:
Finding black pants from xyz brand: A user has a particular brand and color preference. A 
sample graph for finding clothes based on preference will look like this:
Color
Product
Size
Brand
Size
The following Cypher query can easily serve this recipe:
MATCH (brand { name: 'xyz' })-[:is_brand]->(clothes {type: 'pants')<-
[:color]-(color {color: 'black})
RETURN clothes
There are other use cases that center around recommendations, delivery preferences, carts, 
and so on. We will encourage you to create a graph for these and explore new use cases.
www.it-ebooks.info

Industry Usages of Neo4j
166
How it works...
If you analyze all the preceding use cases, you will find that we have built the common 
e-commerce use cases from the existing Neo4j knowledge we have acquired from the 
recipes in earlier chapters. Thus, connecting all the relationships between various entities 
in the form of edges, gives you the power to come up with new innovative solutions from 
the data you already have.
There's more…
We will recommend that readers to learn more about the existing case studies of Neo4j 
from the following links to study how different e-commerce applications are utilizing Neo4j to 
build compelling solutions which are not only driving their revenue but also improving user 
experience and the time users spend on the applications:
f
f
http://info.neotechnology.com/rs/neotechnology/images/ebaynow_
final.pdf
f
f
http://www.slideshare.net/maxdemarzi/windy-city-db-
recommendation-engine-with-neo4j
f
f
http://www.mobilecommerceinsider.com/topics/
mobilecommerceinsider/articles/374006-graph-database-solutions-
ga-popularity-as-neo4j-implemented.htm
www.it-ebooks.info

167
9
Neo4j Administration 
and Maintenance
In this chapter, we will cover the following recipes:
f
f
Deploying Neo4j over the Amazon EC2 Cloud
f
f
Deploying Neo4j over the Heroku Cloud
f
f
Deploying Neo4j over the Microsoft Azure Cloud
f
f
Backups with Neo4j
f
f
Upgrading Neo4j to the latest version
f
f
Neo4j's remote debugging setup
f
f
Configuring secure access to your Neo4j instance
Introduction
In this chapter, we will move from the design and prototype stages to the deployment of Neo4j 
in the production scenario. There are several key aspects to the successful deployment and 
management of Neo4j into the production environment. They include deploying Neo4j over 
common cloud providers with ease, updating Neo4j to the newer, more stable releases, 
making regular backups, high availability failover setups, remote statistics collection for 
functional and performance issues, securing access to Neo4j, and a lot more.
This is the single most important chapter that covers all the recipes to bring your Neo4j 
application live into production.
www.it-ebooks.info

Neo4j Administration and Maintenance
168
Deploying Neo4j over the Amazon EC2 Cloud
In Chapter 1, Getting Started with Neo4j, you learned about the recipes that involve installing 
Neo4j over various operating systems. However, when it comes to production, cloud is 
preferred over a dedicated self-owned server most of the time, which provides ease of 
scalability and maintenance of resources. In this recipe, you will learn how to deploy Neo4j 
over one of the most popular cloud providers, which is EC2.
Neo4j can be deployed over EC2 in many ways, so, in this recipe, you will learn how to deploy 
via Puppet. The Puppet setup creates a complete Neo4j setup, which includes the EC2 server, 
a fixed IP address, and a backup storage for graph data.
Getting ready
Perform the following steps to get ready for this recipe:
1.	 Create a new AWS account, which will need credentials and a credit card.
2.	 Log in to https://console.aws.amazon.com/cloudformation/
home?region=us-east-1, which is the AWS Cloud formation console.
3.	 Go to the AWS console in order to create a new stack, as shown in the following 
screenshot:
www.it-ebooks.info

Chapter 9
169
How to do it...
Now, perform the following steps to complete this recipe:
1.	 Click on Create New Stack.
2.	 Fill in a stack name of your choice and then select the template option, as specified 
from an Amazon S3 template URL.
The URL to be pasted here is https://s3-eu-west-1.amazonaws.com/bio4j-
public/Bio4jBasicInstanceTemplate.txt.
The following screenshot depicts the AWS console for creating the Neo4j stack:
3.	 Click on the Next button.
www.it-ebooks.info

Neo4j Administration and Maintenance
170
4.	 Fill in AvailabilityZone, InstanceType, and KeyPair.
The following screenshot shows how the Review screen will look:
5.	 Click on the Next button and your stack will be created via Puppet, as shown here:
www.it-ebooks.info

Chapter 9
171
6.	 The Outputs tab will show you the key and value of Neo4jEndPoint of the Neo4j 
server, as shown in the following screenshot:
How it works...
The following steps will get you started with this recipe:
The URL, which was provided as the template URL, contains everything that is needed to 
install Neo4j over the EC2 instance. If you go to the JSON file, which was provided as the 
URL link, you will find wget -O /var/tmp/ go: https://raw.github.com/neo4j-
contrib/neo4j-puppet/master/go.
This installs Puppet over the EC2 instance and then launches the Neo4j-Puppet module, 
available at https://github.com/neo4j-contrib/neo4j-puppet.
Go through the preceding URL to learn more about the Neo4j-Puppet module and the other 
various options, which it provides. You can also customize it according to your production 
environment.
Perform sanity checks by accessing the Neo4j admin URL and create some data to validate 
whether Neo4j has been properly installed or not.
www.it-ebooks.info

Neo4j Administration and Maintenance
172
There's more…
In the preceding recipe, you learned how to install Neo4j over EC2 via Puppet. There are 
several other ways to achieve the same objective. The methods are as follows:
f
f
Create an EC2 instance and then deploy Neo4j over it by following the recipes from 
Chapter 1, Getting Started with Neo4j.
GrapheneDB is a start-up, which provides Neo4j as a service over many cloud 
platforms. Go through http://www.graphenedb.com/ to learn more about it.
f
f
Neo4j can also be deployed as a Chef recipe. To learn more about it, please visit 
https://github.com/michaelklishin/neo4j-server-chef-cookbook.
We have completed our first recipe of this chapter, in which you learned about the various ways 
that you can deploy Neo4j over Amazon EC2 for the production environment. The exact method 
that you follow will depend on the kind of skill or expertise you have within your team.
Deploying Neo4j over the Heroku Cloud
Heroku is an excellent Platform as a Service (PaaS) provider, which offers quick development 
and deployment by offering ways to deploy your locally developed apps in the managed cloud. 
In this recipe, you will learn various ways to deploy Neo4j over the Heroku Cloud.
Getting ready
The following steps will get you ready for this recipe:
1.	 Create a new Heroku account by going to https://www.heroku.com/.
2.	 Install the Heroku Toolbelt by downloading it from 
https://toolbelt.heroku.com/.
How to do it...
Now, you will learn step by step how to deploy Neo4j over the Heroku Cloud:
1.	 Launch the bash shell and type the command heroku login.
www.it-ebooks.info

Chapter 9
173
2.	 It will prompt you for your Heroku credentials, which you have entered while creating 
an account over Heroku, as shown in the following screenshot:
3.	 Now, type the following command into the console:
heroku apps:create <your_app_name>
4.	 Neo4j comes as a GrapheneDB add-on in Heroku. So, now to install Neo4j; type the 
following command:
heroku addons:add graphenedb --app neo4jcookbook
The output of this command will give you the following error:
www.it-ebooks.info

Neo4j Administration and Maintenance
174
The error occurs because GrapheneDB comes with various plans with Heroku and 
most of these plans are paid. To check pricing, go to https://addons.heroku.
com/graphenedb.
Here, we can see that only the chalk plan is free, so let's rerun our command again:
heroku addons:add graphenedb:chalk --app neo4jcookbook
5.	 Open the Heroku add-on administration page by typing the following command:
heroku addons:open graphenedb:chalk
6.	 Check the environment variable by using the following command:
heroku config –app neo4jcookbook
7.	
To get the Neo4j endpoint URL, use ENV['GRAPHENEDB_URL'].
8.	 Perform sanity checks by accessing the Neo4j administrator URL and create some 
data to validate whether Neo4j has been properly installed or not.
There's more…
In the preceding recipe, you learned how to install Neo4j over the Heroku Cloud, which is 
simple. To learn more about Neo4j over Heroku, please visit the following URLs:
f
f
http://docs.graphenedb.com/faq.html
f
f
http://maxdemarzi.com/2012/01/13/neo4j-on-heroku-part-one/
f
f
https://devcenter.heroku.com/articles/graphenedb
Deploying Neo4j over the Microsoft Azure 
Cloud
Azure is a cloud platform by Microsoft, and it is getting increasingly popular among Microsoft 
Windows users. Until now, you have learned how to deploy Neo4j over the Linux cloud, but in 
this recipe, we will cover Windows Azure.
In this recipe, you will see a step-by-step approach to deploy Neo4j over Windows Azure.
www.it-ebooks.info

Chapter 9
175
Getting ready
The following steps will get you started with this recipe:
1.	 Create a Windows Azure subscription from http://www.windowsazure.com/ 
if you don't have one.
2.	 Create an account on Dynamic Deploy using https://www.dynamicdeploy.com.
How to do it...
Now, let's learn step by step how to deploy Neo4j over the Microsoft Azure Cloud:
1.	 Search for the latest Neo4j that is the stable version in Dynamic Deploy. In our case, 
this is the version:
https://www.dynamicdeploy.com/packagedetails.aspx?pkgid=309
The following screenshot shows a Neo4j virtual machine on Dynamic Deploy:
www.it-ebooks.info

Neo4j Administration and Maintenance
176
2.	 Sign in using your Dynamic Deploy credentials. You will then need to perform some 
simple steps, such as selecting the Datacenter location, creating new publish 
settings file, selecting the Windows Azure subscription account, and so on.
The following screenshot depicts the process of installing Neo4j on Windows Azure:
During the installation procedure, it will also ask for virtual machine size, admin 
credentials, and other details.
www.it-ebooks.info

Chapter 9
177
After the completion of all the preceding steps, you will be able to see the following 
screenshot, depicting the completion of Neo4j installation over Windows Azure:
You can access the Neo4j URL depicted in the preceding screenshot.
3.	 Perform sanity checks by accessing the Neo4j admin URL and creating some data 
to validate whether Neo4j has been properly installed or not.
www.it-ebooks.info

Neo4j Administration and Maintenance
178
There's more…
In the preceding recipe, you learned how to install Neo4j over the Microsoft Azure Cloud by 
following some very simple steps. To learn more about Neo4j over Microsoft Azure, visit the 
following URLs:
f
f
http://www.neo4j.org/develop/cloud/azure
f
f
http://www.slideshare.net/neo4j/neo4j-on-azure-step-by-
step-22598695
f
f
http://vmdepot.msopentech.com/List/Index
Backups with Neo4j
Data backups are very important for any production environment. There are many things 
that can go wrong, such as the loss of hard drive, upgrade failure and so on. So, it is 
very important to take periodic backups of the Neo4j graph data.
In this recipe, you will learn various ways to take backups with both the Community and 
Enterprise Editions.
Getting ready
The following steps will get you started with the Neo4j backup recipe:
1.	 We have assumed that Neo4j is up and running. If it is not, use an appropriate recipe 
to deploy and run Neo4j.
2.	 If you are using the Neo4j Enterprise Edition, which comes with backup utilities, set 
the following configuration variables:
online_backup_enabled=true
online_backup_server=ip:port
How to do it...
Neo4j comes in two editions, and in the following recipe, you can learn how to take backups 
with both of them.
Neo4j backup with Community Edition
Neo4j Community Edition does not come with any default backup utilities. So, a simple way of 
taking a backup is to take a backup of the ./data/graph.db directory periodically.
www.it-ebooks.info

Chapter 9
179
The following script will get you started with taking regular, periodic backups of the Neo4j data 
with Neo4j Community Edition:
#Backup script for taking Neo4j backup
NEO4J_ROOT="/var/lib/neo4j"
mkdir -p /mnt/backup
$NEO4J_ROOT/bin/neo4j stop
cp -r $NEO4J_ROOT/data/graph.db "/mnt/backup/neo4j_backup.$(date 
+%y-%m-%d)"
$NEO4J_ROOT/bin/neo4j start
You can add this script to the cron job, which will enable you to take automatic periodic 
backups. The only disadvantage is that you have to stop Neo4j while creating the backup, 
and using this process, you cannot take incremental backups.
Neo4j backup with Enterprise Edition
Neo4j Enterprise Edition comes with handy Neo4j backup utilities. This can be used to take 
a backup from a live Neo4j system without the need to stop the server. It is also possible to 
take incremental backups.
The following script will get you started with taking backups of the Neo4j data with Neo4j 
Enterprise Edition:
mkdir /mnt/backup/neo4j
$NEO4J_ROOT/bin/ neo4j-backup -host 10.16.10.94 -to 
/mnt/backup/neo4j
You can add this script to the cron job, which will enable you to take automatic periodic 
backups.
The next time when the script will be run again, it will take only incremental backups. 
You should not opt for an incremental backup when the last backup was from a different 
Neo4j version.
Also, the incremental backup depends on the historical logs specified by the keep_logical_
logs config variable. If these historical logs are not found, the tool will do a full backup.
The following Java code can also be used to do a periodic backup:
OnlineBackup neo4j_backup = OnlineBackup.from( "ip_address" );
neo4j_backup.full( backupPath.getPath() );
assertTrue( "Should be consistent", backup.isConsistent() );
neo4j_backup.incremental( backupPath.getPath());
www.it-ebooks.info

Neo4j Administration and Maintenance
180
For restoring the data, you just need to replace your database folder with the backup folder, 
as Neo4j functional databases are fully functional databases. This can be done by using the 
following command:
cp –r /mnt/backup/neo4j $NEO4J_ROOT/data
There's more…
In the preceding recipe, you leaned about various techniques to take Neo4j backups. The best 
practices might be the same as the ones you are already following for your existing database 
server. The backup frequency might depend on various factors, such as load, number of 
nodes/relations, backup time involved, and so on.
Upgrading Neo4j to the latest version
Neo4j is an actively developed project, and, new releases frequently come out with old bug 
issues fixed, new features, and so on.
In this recipe, you will learn some of important steps to upgrade the Neo4j graph database. 
The upgrade steps will totally depend on the version of Neo4j that you are currently using, 
and the new version you are upgrading to.
Getting ready
The following steps will get you started with this recipe:
1.	 We have assumed that Neo4j is up and running. If it is not, use the appropriate 
recipe to deploy and run Neo4j.
2.	 Check the current version of your Neo4j installation.
How to do it...
An important step in any database upgrade is taking backups of the data. Use the earlier 
recipe to take the data of the Neo4j graph database server. This is a very important step, 
as even if something goes wrong, you can always revert back to the older version.
The exact steps will vary depending on the version you are upgrading. There are no fixed 
steps for this. Always follow the Neo4j documentation for the exact version, which is available 
at http://docs.neo4j.org/chunked/stable/deployment-upgrading.html.
In the recent versions of Neo4j, the configuration variable allow_store_upgrade needs 
to be setup in your neo4j.properties file.
www.it-ebooks.info

Chapter 9
181
The information for the upgrade can be accessed from messages.log present under 
NEO4J_ROOT/data/log. It is advisable to run the following command in a new shell 
when you are running an upgrade:
tail -f $NEO4J_ROOT/data/log/messages.log
There's more…
In the preceding recipe, you learned how to upgrade the Neo4j graph database. It is advisable 
to go through the release notes of a particular release and check whether upgrading would 
be worthwhile or if it would be better to wait for the next release.
Neo4j's remote debugging setup
In the production setup, it is always advisable to do remote debugging, and the Neo4j 
server provides the mechanism for this.
In this recipe, you will learn how to set up Neo4j for remote debugging and attach it to 
an IDE from a remote machine.
Getting ready
The following steps will get you started with this recipe:
1.	 We have assumed that Neo4j is up and running. If it is not, use the appropriate 
recipe to deploy and run Neo4j.
2.	 Install the Java IDE of your choice. In this recipe, we will demonstrate how to 
use IntelliJ.
How to do it...
1.	 Add the following lines to your conf/neo4j-wrapper.properties file:
# Java Additional Parameters
wrapper.java.additional.1=-
Dorg.neo4j.server.properties=conf/neo4j-server.properties
wrapper.java.additional.2=-
agentlib:jdwp=transport=dt_socket,server=y,suspend=n,addres
s=5005 \
-Xdebug-Xnoagent-Djava.compiler=NONE\
-Xrunjdwp:transport=
dt_socket,server=y,suspend=n,address=5005
www.it-ebooks.info

Neo4j Administration and Maintenance
182
2.	 Restart the Neo4j server by using the following command:
./bin/neo4j restart
3.	 Now, in IntelliJ, perform the following steps:
1.	 Select the Run menu and choose Edit Configuration.
2.	 Select the Remote tab.
3.	 Fill in the details of your Neo4j server (host and port), as shown in the 
following screenshot. The screenshot depicts the IntelliJ IDE configuration 
of a remote process attachment:
There's more…
In the preceding recipe, you will have learned how to remotely attach the Neo4j server. You 
will need this recipe when you have written an unmanaged extension and need to debug it.
www.it-ebooks.info

Chapter 9
183
Configuring secure access to your Neo4j 
instance
Securing access to the Neo4j production server is a very important aspect of production 
deployment and by no means should it be accessible to all. Security comes at many levels 
with Neo4j.
In this recipe, you will learn how to secure access to the Neo4j server.
Getting ready
To get started with this recipe, install and run the Neo4j graph database server from the 
recipes of Chapter 1, Getting Started with Neo4j.
How to do it...
We will consider the following scenarios to explain this recipe:
f
f
Your application code and Neo4j server are running on the same machine. 
This will mean that if the Neo4j server is run on localhost, it can be accessed 
by the application code, we need to, perform the following steps:
1.	 Add the following values to your conf/neo4j-
server.properties line:
conf/neo4j-
server.propertiesorg.neo4j.server.webserver.address
=127.0.0.1
2.	 Restart the Neo4j server using ./bin/neo4j restart.
f
f
Your application code and Neo4j server are running on different machines. This will 
mean that if the Neo4j server has to be accessed from the fixed IP address, we need 
to, perform the following steps:
1.	 Add the following values to your conf/neo4j-server.properties line:
conf/neo4j-server.propertiesorg.neo4j.server.webserver.
address
=<ip_address>
2.	 Restart the Neo4j server using ./bin/neo4j restart.
www.it-ebooks.info

Neo4j Administration and Maintenance
184
3.	 Use a proxy setup, such as Apache's mod_proxy module, and configure 
it by the following configuration code:
<Proxy *>
Order Deny,Allow
Deny from all
Allow from <application_server>
</Proxy>
f
f
You will want to add user-based authentication to Neo4j. To do this, follow the 
instructions from https://github.com/neo4j-contrib/authentication-
extension.
This extension does not provide any access control lists (ACL) based user 
management and provides just a simple extension to add more administrator 
credentials.
f
f
It can happen that you will be accessing the data multiple number of times, over 
the REST API. Thus, it is important to use https for securing and encrypting the 
communication, as follows:
# Certificate location
org.neo4j.server.webserver.https.cert.location=
ssl/mycert.cert
# Private key location
org.neo4j.server.webserver.https.key.location=
ssl/mycert.key
org.neo4j.server.webserver.https.enabled=true
org.neo4j.server.webserver.https.port=443


Use the following code to run Neo4j as a non-root user on port that is less 
than 1000:
ProxyPass /neo4j_root/data http://localhost:7474/db/data
ProxyPassReverse /neo4j_root/data 
http://localhost:7474/db/data


Use the following code to run Neo4j on a non-standard port (the standard 
port is 7474). Add the following line to your conf/neo4j-server.
properties file:
org.neo4j.server.webserver.port=<random_port>
There's more…
In the preceding recipe, you learned about several aspects of securing access to the Neo4j 
server. There can be many other scenarios where different types of security mechanisms have 
to be implemented. For more information, check out http://docs.neo4j.org/chunked/
stable/security-server.html.
www.it-ebooks.info

185
10
Scaling Neo4j
In this chapter, we will cover the following recipes:
f
f
A bulk upload of the initial large dataset
f
f
The high availability setup
f
f
Handling high read loads
f
f
Handling high write loads
f
f
Optimizing the Cypher query for performance
Introduction
Neo4j is built to scale both in terms of data size as well as query performance. The limit for 
the number of nodes and relationships for any graph database is in billions, which is more 
than sufficient even for a large-sized graph. Even though the entire data of Neo4j is stored 
over a single node, its current architecture cleverly optimizes it for both read and write 
performance. There are many deployment scenarios in Neo4j where the number of nodes 
and relationships in a graph runs into billions.
In this chapter, you will learn some of the important recipes that are required to build and 
manage large graphs over Neo4j.
A bulk upload of the initial large dataset
Often, requirement is such that you have a large amount of data lying in traditional SQL 
databases or in files and you want to import everything to Neo4j. Often, this takes months, 
as people mostly use Cypher queries or a one-at-a-time node creation approach, which is 
not suitable when your nodes/relationships run into millions or higher.
In this recipe, you will learn how to import an initial bulk dataset into Neo4j.
www.it-ebooks.info

Scaling Neo4j
186
Getting ready
Perform the following steps to get ready for this recipe:
1.	 Set up a Neo4j instance using the recipes covered in Chapter 1, Getting Started 
with Neo4j, of this book.
2.	 You need a large dataset, which needs to be imported to Neo4j. For this recipe, we 
will use http://www.mockaroo.com/, which gives you the ability to generate data 
of various types—up to 1,000 rows in the free edition and up to 10 million rows in the 
paid edition. For more data, you can either go for a big data edition or write a simple 
script that gives you the ability to generate billions of data points. The following 
screenshot shows sample CSV data generated from mockaroo:
How to do it...
Now, let's explore the various ways in which you can insert a large amount of data into Neo4j:
f
f
Cypher Load CSV: Cypher comes with a handy LOAD CSV command, which allows 
you to easily insert millions of nodes and relationships into Neo4j without the need 
to write long code. This is one of the easiest and fastest methods for the bulk 
insertion of data. Let's explore this in detail with the help of some example 
commands, as shown in the following steps:
1.	 Use the following Cypher query to create nodes with the label Person 
and the properties id, name, email, and country:
LOAD CSV WITH HEADERS FROM  "file:///tmp/MOCK_DATA.csv" as 
line CREATE (p:Person { id: toInt(line.id), name: 
line.first_name, email: line.email, country: line.country })
www.it-ebooks.info

Chapter 10
187
The following screenshot shows the output of the preceding command:
2.	 Let's create a country node and an email node that has a relationship 
with the Person node, as shown in the following command:
LOAD CSV WITH HEADERS FROM  "file:///tmp/MOCK_DATA.csv" as  
line CREATE (p:Person { id: toInt(line.id), name:  
line.first_name, email: line.email, country: line.country })  
CREATE(e:Email {email : line.email }) CREATE(c:Country  
{country : line.country }) CREATE (e)-[:EMAIL_OF]->(p) 
CREATE (c)-[:COUNTRY_OF]->(p)
The following screenshot shows the output of the preceding command:
www.it-ebooks.info

Scaling Neo4j
188
3.	 Now, there's a problem with the preceding Cypher query, as we are creating 
duplicate country nodes. Let's fix this problem using MERGE, as shown here:
LOAD CSV WITH HEADERS FROM  "file:///tmp/MOCK_DATA.csv" as 
line CREATE (p:Person { id: toInt(line.id), name: 
line.first_name, email: line.email, country: line.country }) 
CREATE(e:Email {email : line.email }) MERGE(c:Country 
{country 
: line.country }) CREATE (e)-[:EMAIL_OF]->(p) CREATE (c)-
[:COUNTRY_OF]->(p)
Now, duplicate country nodes won't be created and nodes representing 
the same country will be merged together.
4.	 The problem with the preceding code is that it does not handle missing or 
null values and bulk insertion will stop when the first error is encountered. 
We can easily fix this using the following command:
LOAD CSV WITH HEADERS FROM  "file:///tmp/MOCK_DATA.csv" as 
line CREATE (p:Person { id: toInt(line.id), name: 
line.first_name }) FOREACH(ignoreMe IN CASE WHEN 
trim(line.email) <> "" THEN [1] ELSE [] END | SET p.email = 
line.email)
This will only set the property of the node, if the property is present, 
else the property will not be set.
Similarly, we can use this command to create an email node if an e-mail is 
present in the CSV file for the Person node, as shown in the following code.
LOAD CSV WITH HEADERS FROM  "file:///tmp/MOCK_DATA.csv" as 
line CREATE (p:Person { id: toInt(line.id), name: 
line.first_name }) FOREACH(ignoreMe IN CASE WHEN 
trim(line.email) <> "" THEN [1] ELSE [] END | SET p.email = 
line.email) FOREACH(ignoreMe IN CASE WHEN trim(line.email) 
<> 
"" THEN [1] ELSE [] END | CREATE (e:email {email : line.
email 
}) )
5.	 In order to create indexes, use the following commands before the actual 
LOAD CSV query:
CREATE INDEX ON :Person(name)
CREATE INDEX ON :Country(country)
www.it-ebooks.info

Chapter 10
189
There can be a case where the same e-mail is accidently entered for 
two different people. This can be fixed by creating constraints before 
the actual LOAD CSV query, as shown here:
CREATE CONSTRAINT ON (e:Email) ASSERT e.email IS UNIQUE;
For a large graph, it is advisable to do periodic commits using the 
following command:
USING PERIODIC COMMIT
The LOAD CSV command's performance part has been explained well in the 
article at http://jexp.de/blog/2014/06/load-csv-into-neo4j-
quickly-and-successfully/.
We have covered all the important aspects of the LOAD CSV command.
f
f
Parallel batch import: Neo4j comes with a superfast batch importer, which is very 
easy to use and can create millions of nodes and relationships easily. This can only 
be used for the initial import as it creates its own graph.db directory, unlike the 
earlier LOAD CSV command, which can be used on a preexisting graph. The other 
thing this batch importer needs is two CSV files, one for nodes and the other for 
relationships. Follow these steps to install the parallel batch importer:
1.	
Download the ZIP file from http://neo4j.com/developer/guide-
import-csv/#_super_fast_batch_importer_for_huge_datasets.
You can also use the following command line to download the file:
wget http://dist.neo4j.org/batch-import/batch_importer_21.
zip
2.	
Unzip the downloaded file using the following command:
unzip batch_importer_21.zip
The nodes and relationships files look similar to what is shown in the
following screenshots, which are under the sample directory:
www.it-ebooks.info

Scaling Neo4j
190
The following screenshot shows how the relationship file looks:
Regarding the preceding file format, the following are the key aspects of 
the file format for the nodes and relationships files:
A parallel batch importer also comes with a test data generator, which can 
be used to generate test data, as follows:
./generate.sh
The following command shows the usage of test data generator:
TestDataGenerator nodes=1000000 relsPerNode=50 
relTypes=KNOWS,FOLLOWS propsPerNode=5 propsPerRel=2
3.	 Now, let's create nodes and relationships using a parallel batch inserter, 
as shown in the following command:
./import.sh -db-directory graph.db -nodes sample/nodes.csv -
rels sample/rels.csv
www.it-ebooks.info

Chapter 10
191
4.	 Now, copy the newly created graph.db directory to the original Neo4j 
directory path and restart Neo4j as shown here:
cp –r graph.db $NEO4J_ROOT/data
$NEO4J_ROOT/bin/neo4j restart
How it works...
The LOAD CSV command is a relatively simple command and requires no preparation. It 
basically creates an object with properties, out of the CSV row, which can be iterated through 
to create different types of nodes and relationships. The LOAD CSV command is sequential 
in nature, and each row is executed one after the other. However, it can be used in parallel if 
two altogether different data sources have to be inserted in the same graph. This will typically 
depend on the graph, which you are going to create, where some part can be parallel and 
some can be sequential.
The parallel batch inserter is more complex in nature and requires data preparation. It basically 
identifies the dependency of the nodes and relationships so that you can figure out which nodes 
and relationships can be created in parallel, which in turn gives high performance.
There's more…
In the preceding recipe, you learned how to bulk insert data into Neo4j. You can learn more 
about both the methods from the URLs provided:
f
f
LOAD CSV is excellently explained in greater depth at the following URLs:


http://neo4j.com/docs/stable/cypherdoc-importing-csv-
files-with-cypher.html


http://www.neo4j.org/graphgist?d788e117129c3730a042
f
f
You can read more about the parallel batch inserter from the following URLs:


http://neo4j.com/developer/guide-import-csv/#_super_
fast_batch_importer_for_huge_datasets


https://github.com/jexp/batch-import
The high availability setup
Neo4j stores all the data on a single machine. This is important when it comes to fault 
tolerance or disaster recovery, especially in the case of scaling read-mostly applications.
In this recipe, you will learn how to configure the High Availability (HA) setup with Neo4j.
www.it-ebooks.info

Scaling Neo4j
192
Getting ready
In order to get ready for this recipe, install the Neo4j Enterprise edition, as the HA feature 
only comes with Neo4j Enterprise editions. The following diagram shows the Neo4j HA 
architecture that comprises of three nodes:
How to do it...
You need to perform the following steps to create a 2-node HA setup. Before starting 
the actual configuration, let's check out various important configuration parameters in 
the HA setup. It is important to understand the various parameters and their meaning 
before starting the actual configuration. The following screenshot shows the various 
configuration parameters for Neo4j HA:
www.it-ebooks.info

Chapter 10
193
You can read up on the other parameters at http://docs.neo4j.org/chunked/
stable/ha-configuration.html.
Now, let's start with the setup by performing the following steps:
1.	 On node1 and node2, add/modify the following lines in the conf/neo4j-server.
properties file, as shown here:
org.neo4j.server.webserver.address=0.0.0.0
org.neo4j.server.database.mode=HA
2.	 On node1, add/modify the following lines in the conf/neo4j.properties file 
as shown here:
ha.server_id = 1
ha.intitial_hosts = <node1ip:5001>,<node2ip:5001>
3.	 On node2, add/modify the following lines in the conf/neo4j.properties file 
as shown here:
ha.server_id = 2
ha.intitial_hosts = <node1ip:5001>,<node2ip:5001>
Now, start Neo4j on both the nodes, as shown here:
neo4j-01$ ./bin/neo4j start
neo4j-02$ ./bin/neo4j start
This will start Neo4j in the HA configuration.
How it works...
On startup, a Neo4j HA database instance will try to connect to an existing cluster specified 
by the configuration. If the cluster exists, the instance will join it as a slave. Otherwise, a 
cluster will be created and the instance will become its master. Thus, in our case, node1 
will be elected as the master node.
Slaves can also be configured to pull updates asynchronously by setting the 
ha.pull_interval option.
Whenever a Neo4j database becomes unavailable by the means of, for example, hardware 
failure or network outages, the other database instances in the cluster will detect that 
and mark it as temporarily failed. A database instance that becomes available after being 
unavailable will automatically catch up with the cluster. If the master node goes down, 
another (best suited) member will be elected and have its role switched from slave to 
master after a quorum has been reached within the cluster.
www.it-ebooks.info

Scaling Neo4j
194
The following test is recommended for users to test the HA setup:
1.	 Load some data into the cluster, query it, and add some data to it. This is 
instance one.
2.	 Then, deliberately bring down instance one, query it again, and add some 
more data to it. This becomes your instance two.
3.	 Bring back instance one. Bring down instance two.
4.	 Then, query the data that was added when only instance two was up.
This proves that the failover works and the data is synchronized between the nodes.
There's more…
You can read more about the Neo4j HA setup and its various configuration aspects from this 
excellent Neo4j documentation at http://docs.neo4j.org/chunked/stable/ha.html.
Handling high read loads
Most applications require high read throughputs rather than high write throughputs. In this 
recipe, you will learn more about how to scale Neo4j read throughputs with various techniques.
Getting ready
To get started with this recipe, install Neo4j using the earlier recipes from Chapter 1, Getting 
Started with Neo4j, of this book. Since this recipe covers both Community and Enterprise 
editions, it will be helpful to deploy both the applications, which creates a high read load.
How to do it...
Now, we will learn about the various aspects of scaling Neo4j read throughputs, which are 
as follows:
f
f
Increasing the number of slaves: In the HA configuration, read operations can be 
done locally at each slave; so, increasing the number of slaves along with the load 
balancers, which properly distribute read requests, can significantly increase the 
read throughput. Theoretically, if you are getting X number of requests from N number 
of nodes, then adding one more slave will increase the read performance by X/N.
www.it-ebooks.info

Chapter 10
195
f
f
Using cache along with Neo4j: Many of the simpler queries, such as finding 
nodes on the basis of certain properties, the existence of nodes, and the existence 
of relationships, can be easily served by adding a simple cache such as a 
Redis-based cache, which can significantly improve the overall throughput.
f
f
Routing to warm cache: The performance can be significantly increased if the same 
type of requests are routed toward the same node, as with the previous request, 
there's a high chance of finding the data in the cache and hence increasing the read 
throughput. This can be easily achieved through the load balancer configuration.
How it works...
In Neo4j, every node is in sync with each other; therefore, any node can serve a read request. 
Also, the read performance significantly depends on the type of storage used and the hit ratio 
of the cache. The miss ratio is quite significant; thus, it is important that most of the requests 
be served from the cache itself.
There's more…
You can read more about Neo4j's read scalability at the following URLs:
f
f
http://neo4j.com/neo4j-scales-web-enterprise/
f
f
http://making.fiftythree.com/load-testing-an-unexpected-
journey/
f
f
http://asakta.blogspot.in/2014/04/experiences-using-graph-
database-neo4j.html
Handling high write loads
Some applications will require a high write throughputs rather than high read throughputs 
where updates to the same data are very frequent. In this recipe, you will learn more about 
how to scale Neo4j write throughputs with various techniques.
Getting ready
To get started with this recipe, install Neo4j using the earlier recipes from Chapter 1, Getting 
Started with Neo4j, of this book. Since this recipe covers both the Community and Enterprise 
Editions, it will be helpful to deploy both applications, which generate high write loads, such 
as check-ins or posts.
www.it-ebooks.info

Scaling Neo4j
196
How to do it...
Now, you will learn about the various aspects of scaling Neo4j read throughputs, which are 
explained as follows:
1.	 Writing to the master: In a HA configuration, writes are synced through the master 
node; so, even if you are writing to slaves, it will first be propagated to the master 
node and then to the slaves. Therefore, you can increase performance and reduce 
the network load if you write to the master node in Neo4j.
2.	 Increasing the value of vm.dirty_background_ratio: Neo4j typically writes to 
memory-mapped files until dirty pages can be accepted by the OS and then the 
dirty pages are also written to disk. If you experience too much I/O, then changing 
vm.dirty_background_ratio might be helpful. You can read more on this 
at https://www.kernel.org/doc/Documentation/sysctl/vm.txt and 
http://lonesysadmin.net/2013/12/22/better-linux-disk-caching-
performance-vm-dirty_ratio/.
3.	 Batch writing to the system: Rather than writing or updating a single node or 
relationship at a time, it will be helpful to maintain a queue of writes and then 
commits. Writing in batches can significantly improve write performance, although 
it will totally depend on the application.
How it works...
In Neo4j, an important aspect of writing in batches is that it gives high performance compared 
to writing to a single node at a time. Another important aspect is committing memory-mapped 
files to disk; hence, the SSD-based disks have been successfully used to achieve exceptionally 
high write performance.
There's more…
You can read more about Neo4j's write scalability at the following URLs:
f
f
http://docs.neo4j.org/chunked/stable/performance-guide.html
f
f
https://structr.org/blog/neo4j-performance-on-ext4
f
f
http://neo4j.com/users/fusion-io/
www.it-ebooks.info

Chapter 10
197
Optimizing the Cypher query for 
performance
Cypher is the most important aspect of Neo4j, and many migrations to the Neo4j database 
from their SQL counterparts are because of it. It provides easy migration from the SQL 
background to Neo4j without losing flexibility in querying, which the SQL language provides.
In this recipe, you will learn the various aspects of how to improve Cypher query performance; 
however, it totally depends on the domain and the application involved.
Getting ready
To get started with this recipe, install Neo4j using the earlier recipes from Chapter 1, 
Getting Started with Neo4j, of this book.
How to do it...
The profiling of a Cypher query should be the first step.
Now, you will learn some aspects of how to improve Cypher query performance, 
which are explained here:
f
f
Index decision: An index is the single most thing that can increase Cypher 
performance by many folds, but this doesn't mean that you index on everything, 
as over indexing can create lots of I/O to disk and hence degrade performance. 
You need to choose the attributes/nodes/relationships that 
you frequently require wisely and create an index on them.
f
f
Cypher parameters: This is important for performance because Cypher caches 
execution plans, and it will be faster the second time you run the same query even 
if different parameters are provided with the Cypher query. You can read more on 
this at the following location: http://docs.neo4j.org/chunked/milestone/
cypher-parameters.html.
f
f
Patterns in the where clause: Avoid these at any cost. Do not use something 
similar to this:
MATCH (u:User)-[:works]->(c:company)
WHERE u.id=123
  AND (i)-[:related_to]->(abc)
RETURN i
www.it-ebooks.info

Scaling Neo4j
198
You can also prepend PROFILE with any query to see what is going on in the backend in 
detail.
How it works...
The overall goal of manual query performance optimization is to ensure that only necessary 
data is retrieved from the graph. At least, data should be filtered out as early as possible in 
order to reduce the amount of work that has to be done in the later stages of query execution. 
This also goes for what is returned; avoid returning whole nodes and relationships—instead, 
pick the data you need and only return that. You should also make sure to set an upper limit 
on variable length patterns, so they don't cover larger portions of the dataset than necessary.
There's more…
You can read more about Neo4j Cypher query performance at the following URLs:
f
f
http://neo4j.com/developer/guide-sql-to-cypher/
f
f
http://wes.skeweredrook.com/pragmatic-cypher-optimization-2-
0-m06/
f
f
http://wes.skeweredrook.com/cypher/
f
f
http://docs.neo4j.org/chunked/stable/performance-guide.html
www.it-ebooks.info

Chapter 10
199
f
f
http://neo4j.com/blog/neo4j-2-2-0-scalability-performance/
f
f
http://www.kennybastani.com/2014/07/understanding-how-neo4j-
cypher-queries.html
f
f
http://neo4j.com/docs/stable/how-are-queries-executed.html
f
f
http://neo4j.com/docs/stable/configuration-settings.
html#config_dbms.cypher.planner
www.it-ebooks.info

www.it-ebooks.info

201
Index
Symbols
.NET
about  47
Neo4j, accessing from  47
A
access control lists (ACL)  184
activity streaming
implementing  102-106
aggregate model
cons  80
pros  79
versus connected data model  77-79
Amazon EC2 Cloud
Neo4j, deploying over  168-171
aspects, of scaling Neo4j read throughputs
cache, using with Neo4j  195
number of slaves, increasing  194
warm cache, routing to  195
aspects, of scaling Neo4j write throughputs
batch, writing to system  196
master, writing to  196
value of vm.dirty_background_ratio, 
increasing  196
atomicity, consistency, isolation, 
and durability (ACID)  2
AWS Cloud formation console
URL  168
Azure  174
B
backups, Neo4j
performing  178
with Community Edition  178
with Enterprise Edition  179
BetterDoctor API
URL  155
binary search tree
about  82
creating, with Neo4j  80-83
boolean operators
using, with Cypher  59-61
building blocks, Neo4j graph database
labels  74
nodes  74
properties  74
relationships  74
C
common configuration files, Neo4j
about  23, 24
URL  24
connected data model
cons  79
pros  79
versus aggregate model  77-79
curl
about  30
used, for accessing Neo4j from command 
line  30-34
www.it-ebooks.info

202
Cypher
about  51-53
aggregation  66-68
Boolean operator AND  60
Boolean operator NOT  61
boolean operators  59-61
paths  70-72
paths, along with shortest route  70-72
regular expressions, using  64-66
results, combining with  68, 69
used, for changing order of results  61, 62
used, for creating node  53-55
used, for creating relationship  54, 55
used, for finding geometrics within 
distance  127, 128
used, for limiting results  64
used, for querying nodes  56
used, for querying relationship  56, 57
used, for skipping results  63, 64
Cypher query
used, for deleting data from Neo4j  58, 59
Cypher query elements
CREATE  94
DELETE  94
FOREACH  94
MATCH  94
RETURN  94
SET  94
START  94
WHERE  94
WITH  94
Cypher query performance
Cypher parameters  197
index decision  197
optimizing  197, 198
patterns, where clause  197
URL  198
D
data
importing, REST API used  119-122
data import
from CSV format to Neo4j  12-15
from DEX graph database to Neo4j  22
from Geoff format to Neo4j  18
from InfiniteGraph to Neo4j  21
from OrientDB to Neo4j  19, 20
from RDBMS to Neo4j  16, 17
data import, CSV format to Neo4j
about  12, 15
batch importer, using  13
custom scripts, using  14
data import, DEX graph database to Neo4j  22
data import, Geoff format to Neo4j
about  18
bulk loads  19
data import, InfiniteGraph to Neo4j  21
data import, OrientDB to Neo4j
about  19
exporting, in JSON format  19
Gremlin, using  20
data import, RDBMS to Neo4j
about  16
custom scripts, using  17
Neo4j SQL importer tool, using  16
data modeling, using Neo4j
URL  92
data modeling, with Neo4j
defining  75-77
DocGraph project
URL  86
Dynamic Deploy
URL  175
E
e-commerce, with Neo4j
about  164
use cases  165
embedded mode  28
Esri shapefiles
importing  116, 117
F
Facebook
URL  94
Foursquare
URL  94
friends of friends
finding, with Neo4j  99-102
www.it-ebooks.info

203
G
Geoff format
URL  19
Geographic Information System (GIS) 
software  116
geometries
searching, within bounding box  124, 125
searching, within distance  125, 126
searching, within distance using 
Cypher  127, 128
GeoName data
URL  86
Gephi
about  148
cons  148
Neo4j graph, using with  144-148
pros  148
URL  144
GitHub
URL  94
GrapheneDB
about  172
URL  172
Graph Modeling Language (GML)  146
graphs
viewing, with Linkurious  136-143
Graph Style Sheet (GSS)  135
graph visualization libraries
used, for writing tools  131
Gremlin
about  23
URL  20
using  20
working  21
H
HA setup
configuring  191-193
healthcare data
 modeling, with Neo4j  83-85
healthcare, with Neo4j
about  153
functioning  157
use cases  154-156
Heroku
about  172
URL  172
Heroku Cloud
Neo4j, deploying over  172-174
Heroku Toolbelt
URL  172
high read loads
handling  194
high write loads
handling  195
hybrid model  80
I
initial bulk dataset
Cypher Load CSV  186
uploading  185-191
J
Java Development Kit (JDK)  2
Java libraries
Neo4j, accessing from  34-36
Java Neo4j Rest binding
download link  37
using  37
Java REST bindings
about  36
used, for accessing Neo4j  36, 37
JPype  42
L
Linkurious
cons  144
pros  143
URL  137
used, for viewing graphs  136-143
Linux
single node installation of Neo4j, 
setting up  2-4
single node installation of Neo4j, URL  4
load2neo tool
URL  18
www.it-ebooks.info

204
LOAD CSV command
about  191
parallel batch import  189
URL  189
M
Mac OS X
single node installation of Neo4j, 
setting up  6, 7
MapReduce  77
Microsoft Azure Cloud
Neo4j, deploying over  174-177
mockaroo
URL  186
multiple instances, of Neo4j
running, over single machine  24, 25
mutual friends
finding, with Neo4j  95-98
N
Neo4j
about  73
accessing from command line, 
curl used  30-34
accessing from command line, Neo4j shell 
used  28, 29
accessing, from Java libraries  34-36
accessing, from .NET  47
accessing, from Node.js  49
accessing, from PHP  48
accessing from Python, REST bindings 
used  42
accessing from Ruby, REST bindings 
used  45, 46
accessing, from Scala  46
accessing, Java REST bindings used  36, 37
backups, performing  178
binary search tree, creating with  80-83
building, from source  25
building, URL  26
common configuration files  23, 24
data, deleting with Cypher query  58, 59
data, importing from CSV format  12-15
data, importing from DEX graph 
database   22, 23
data, importing from Geoff format  18
data, importing from InfiniteGraph  21
data, importing from OrientDB  19, 20
data, importing from RDBMS  16, 17
deploying, over Amazon EC2 Cloud  168-172
deploying, over Heroku Cloud  172-174
deploying, over Microsoft Azure 
Cloud  174-177
mapping to Java-annotated classes, Spring 
Data Neo4j used  38-40
multiple instances, running over single 
machine  25
remote debugging setup  181, 182
scaling  185
secure access, configuring  183, 184
single node installation, over Linux  3
single node installation, over Windows  4-6
upgrading  180
URL  2, 72
URL, for downloading Neo4j  7
URL, for server configuration  25
used, for creating first graph  9-12
Neo4j client
URL  47
Neo4j console
used, for visualization  132-136
Neo4j embedded
about  41
accessing, from Python  41, 42
accessing, from Ruby  44
Neo4j gist
URL  52
Neo4j graph
using, with Gephi  144-148
Neo4j HA setup
URL  194
Neo4j over Heroku
references  174
Neo4j over Microsoft Azure
references  178
Neo4j-Puppet module
URL  171
Neo4j REST client
developing  37
www.it-ebooks.info

205
Neo4j shell  28
Neo4j Spatial extension
about  114
installing  114, 115
URL  115
working  115
Neo4j SQL importer tool
about  16
URL  16
Neo4j unmanaged extension
URL  115
Neo4j Webadmin Console
cons  136
pros  136
Neoeclipse
cons  152
pros  151
URL  149
using, with visualization  149-151
Neography
URL  46
Neomodel
about  43
URL  44
using  44
working  44
Neotechnology
URL  90
network reachability
displaying  109-111
node
creating, with Cypher  54, 55
querying, with Cypher  56, 57
Node.js
about  49
Neo4j, accessing from  49
Node-Neo4j
about  49
URL  49
O
open flight database
about  86
URL  86
OpenStreetMap
about  118
importing  118, 119
URL  88
order of results
changing, with Cypher  61, 62
OS X installation
URL  8
P
parallel batch inserter
URL  191
PHP
about  48
Neo4j, accessing from  48
Plain Old Java Objects (POJO)  38
Platform as a Service (PaaS) provider  172
plug and play tools  131
point layer
creating, REST API used  122, 123
py2neo module
URL  42
Python
embedded Neo4j, accessing from  41
Python object model
mapping, to Neo4j graph database  43, 44
Q
queries, for healthcare graphs  84
queries, travel graph  87, 88
questions, retail graph  91
questions, social graph  89
R
readme file
URL  26
read scalability
URL  195
regular expressions
complex regular expressions  65
on numerical values  65
using, with Cypher  65, 66
www.it-ebooks.info

206
relationship
creating, with Cypher  53-55
querying, with Cypher  56, 57
remote debugging setup  181, 182
REST API
used, for creating point layer  122, 123
used, for importing data  119-122
REST bindings
used, for accessing Neo4j from Python  42
used, for accessing Neo4j from Ruby  45, 46
RESTSharp
URL  48
results
limiting, with Cypher  63, 64
skipping, with Cypher  63, 64
retail data
modeling, with Neo4j  91
Ruby
embedded Neo4j, accessing from  44, 45
S
Scala
about  46
Neo4j, accessing from  46
secure access
configuring, to Neo4j instance  183, 184
server mode  28
shapefile format  116
social data
modeling, with Neo4j  90
modeling, with Neo4j  89
social networking industry, with Neo4j
about  157
use cases  157-160
spatial database  113
Spring Data Neo4j
about  38-41
graph entities  40, 41
URL  41
used, for mapping Neo4j to Java 
annotated classes  38, 39
SQL data modeling
versus Neo4j data modeling  75
Stanford SNAP
URL  90
T
travel data
 modeling, with Neo4j  86-88
travel industry, with Neo4j
about  161
use cases  162-164
Twitter
URL  94
U
user-based authentication
URL  184
user similarity
finding  107, 108
V
visualization
Neo4j console, using  132-136
Neoeclipse, using  149-152
W
Weatherbase
URL  88
Wikitravel
URL  88
Windows
single node installation of Neo4j, 
setting up  4-6
single node installation of Neo4j, URL  6
Windows Azure
URL  175
Windows installer
URL  4
www.it-ebooks.info


Thank you for buying 
Neo4j Cookbook
About Packt Publishing
Packt, pronounced 'packed', published its first book, Mastering phpMyAdmin for Effective MySQL 
Management, in April 2004, and subsequently continued to specialize in publishing highly focused 
books on specific technologies and solutions.
Our books and publications share the experiences of your fellow IT professionals in adapting and 
customizing today's systems, applications, and frameworks. Our solution-based books give you the 
knowledge and power to customize the software and technologies you're using to get the job done. 
Packt books are more specific and less general than the IT books you have seen in the past. Our 
unique business model allows us to bring you more focused information, giving you more of what 
you need to know, and less of what you don't.
Packt is a modern yet unique publishing company that focuses on producing quality, cutting-edge 
books for communities of developers, administrators, and newbies alike. For more information, 
please visit our website at www.packtpub.com.
About Packt Open Source
In 2010, Packt launched two new brands, Packt Open Source and Packt Enterprise, in order to 
continue its focus on specialization. This book is part of the Packt open source brand, home 
to books published on software built around open source licenses, and offering information to 
anybody from advanced developers to budding web designers. The Open Source brand also runs 
Packt's open source Royalty Scheme, by which Packt gives a royalty to each open source project 
about whose software a book is sold.
Writing for Packt
We welcome all inquiries from people who are interested in authoring. Book proposals should 
be sent to author@packtpub.com. If your book idea is still at an early stage and you would 
like to discuss it first before writing a formal book proposal, then please contact us; one of our 
commissioning editors will get in touch with you.
We're not just looking for published authors; if you have strong technical skills but no writing 
experience, our experienced editors can help you develop a writing career, or simply get some 
additional reward for your expertise.
www.it-ebooks.info

Learning Neo4j
ISBN: 978-1-84951-716-4             Paperback: 222 pages
Run blazingly fast queries on complex graph datasets 
with the power of the Neo4j graph database
1.	
Get acquainted with graph database systems 
and apply them in real-world use cases.
2.	
Get started with Neo4j, a unique NOSQL database 
system that focuses on tackling data complexity.
3.	
A practical guide filled with sample queries, 
installation procedures, and useful pointers 
to other information sources.
Learning Cypher
ISBN: 978-1-78328-775-8            Paperback: 162 pages
Write powerful and efficient queries for Neo4j with 
Cypher, its official query language
1.	
Improve performance and robustness when you 
create, query, and maintain your graph database.
2.	
Save time by writing powerful queries using 
pattern matching.
3.	
Step-by-step instructions and practical examples 
to help you create a Neo4j graph database 
using Cypher.
Please check www.PacktPub.com for information on our titles
www.it-ebooks.info

Building Web and Mobile 
ArcGIS Server Applications 
with JavaScript
ISBN: 978-1-84969-796-5            Paperback: 274 pages
Master the ArcGIS API for JavaScript, and build 
exciting, custom web and mobile GIS applications 
with the ArcGIS Server
1.	
Develop ArcGIS Server applications with 
JavaScript, both for traditional web browsers 
as well as the mobile platform.
2.	
Acquire in-demand GIS skills sought by 
many employers.
3.	
Step-by-step instructions, examples, and 
hands-on practice designed to help you learn 
the key features and design considerations for 
building custom ArcGIS Server applications.
Scala for Java Developers
ISBN: 978-1-78328-363-7            Paperback: 282 pages
Build reactive, scalable applications and integrate Java 
code with the power of Scala
1.	
Learn the syntax interactively to smoothly 
transition to Scala by reusing your Java code.
2.	
Leverage the full power of modern web 
programming by building scalable and 
reactive applications.
3.	
Easy to follow instructions and real world 
examples to help you integrate java code 
and tackle big data challenges.
Please check www.PacktPub.com for information on our titles
www.it-ebooks.info

