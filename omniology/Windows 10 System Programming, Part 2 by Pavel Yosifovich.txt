
Windows 10 System Programming, Part 2
Pavel Yosifovich
This book is for sale at http://leanpub.com/windows10systemprogrammingpart2
This version was published on 2020-08-09
This is a Leanpub book. Leanpub empowers authors and publishers with the Lean Publishing
process. Lean Publishing is the act of publishing an in-progress ebook using lightweight tools and
many iterations to get reader feedback, pivot until you have the right book and build traction once
you do.
© 2020 Pavel Yosifovich

Contents
Chapter 13: Working With Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
Memory APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1
The VirtualAlloc* Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2
Decommitting / Releasing Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5
Reserving and Committing Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
6
The Micro Excel Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
9
Working Sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
15
The Working Sets Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
17
Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
21
Private Heaps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
22
Heap Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
26
Heap Debugging Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
28
The C/C++ Runtime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
30
The Local/Global APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
Other Heap Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
32
Other Virtual Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
Memory Protection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
Locking Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
35
Memory Hint Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
36
Writing and Reading Other Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
38
Large Pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
39
Address Windowing Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
42
NUMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
43
The VirtualAlloc2 Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
47
Sumamry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
49
Chapter 14: Memory Mapped Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
50
Mapping Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
51
The filehist Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
53
Sharing Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
57
Sharing Memory with File Backing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
61
The Micro Excel 2 Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
63
Other Memory Mapping Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
66

CONTENTS
Data Coherence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
70
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
71
Chapter 15: Dynamic Link Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
72
Building a DLL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
73
Implicit and Explicit Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
78
Implicit Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
79
Explicit Linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
83
Calling Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
86
DLL Search and Redirection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
87
The DllMain Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
89
DLL Injection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
Injection with Remote Thread . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
91
Windows Hooks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
94
DLL Injecting and Hooking with SetWindowsHookEx . . . . . . . . . . . . . . . . . . . . .
95
API Hooking
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
IAT Hooking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
“Detours” Style Hooking
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111
DLL Base Address . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
Delay-Load DLLs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
The LoadLibraryEx Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
Miscellaneous Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
Chapter 16: Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
WinLogon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122
LogonUI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
LSASS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
LsaIso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
Security Reference Monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
Event Logger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124
SIDs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
Tokens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
The Secondary Logon Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
Impersonation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
Impersonation in Client/Server
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147
Privileges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
Super Privileges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
Access Masks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
Security Descriptors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
The Default Security Descriptor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166

CONTENTS
Building Security Descriptors
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168
User Access Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170
Elevation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
Running As Admin Required . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
UAC Virtualization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
Integrity Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
UIPI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179
Specialized Security Mechanisms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
Control Flow Guard . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
Process Mitigations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192
Chapter 17: The Registry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
The Hives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
HKEY_LOCAL_MACHINE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
HKEY_USERS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
HKEY_CURRENT_USER (HKCU) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
HKEY_CLASSES_ROOT (HKCR) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 196
HKEY_CURRENT_CONFIG (HKCC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
HKEY_PERFORMANCE_DATA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
32-bit Specific Hives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
Working with Keys and Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
Reading Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
Writing Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202
Deleting Keys and Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204
Creating Registry Links . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205
Enumerating Keys and Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
Registry Notifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Transactional Registry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
Remote Registry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
Miscellaneous Registry Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224

Chapter 13: Working With Memory
In chapter 12, we looked at the basics of virtual and physical memory. In this chapter, we’ll discuss the
various APIs available to developers for managing memory. Some APIs are better to use for large
allocations, while others are more suited to managing small allocations. After you complete this
chapter, you should have a good understanding of the various APIs and their capabilities, allowing
you to choose the right tool for the job where memory is involved.
In this chapter:
• Memory APIs
• The VirtualAlloc* Functions
• Reserving and Committing Memory
• Working Sets
• Heaps
• Other Virtual Functions
• Writing and Reading Other Processes
• Large Pages
• Address Windowing Extensions
• NUMA
• The VirtualAlloc2 Function
Memory APIs
Windows provides several sets of APIs to work with memory. Figure 13-1 shows the available sets
and their dependency relationship.

Chapter 13: Working With Memory
2
Figure 13-1: Windows user-mode APIs
We’ll look at the APIs from the lowest level to the highest. Each API set has its strengths and
shortcomings.
The VirtualAlloc* Functions
The lowest layer - the Virtual API is the closest to the memory manager, which has several
implications:
• It’s the most powerful API, providing practically everything that can be done with virtual
memory.
• It always works in units of pages and on page boundaries.
• It’s used by higher-level APIs, as we’ll see throughout this chapter.
The most fundamental function that allows reserving and/or committing memory is VirtualAlloc:
LPVOID VirtualAlloc(
_In_opt_ LPVOID lpAddress,
_In_ SIZE_T dwSize,
_In_ DWORD flAllocationType,
_In_ DWORD flProtect);
An extended function, VirtualAllocEx, works on a potentially different process:

Chapter 13: Working With Memory
3
LPVOID VirtualAllocEx(
_In_ HANDLE hProcess,
_In_opt_ LPVOID lpAddress,
_In_ SIZE_T dwSize,
_In_ DWORD flAllocationType,
_In_ DWORD flProtect);
VirtualAllocEx is identical to VirtualAlloc except for the process handle parameter, that must
have the PROCESS_VM_OPERATION access mask.
VirtualAlloc(Ex) cannot be called from a UWP process. Windows 10 added a variant of VirtualAlloc
that can be called from a UWP process:
PVOID VirtualAllocFromApp(
_In_opt_ PVOID BaseAddress,
_In_ SIZE_T Size,
_In_ ULONG AllocationType,
_In_ ULONG Protection);
To make things simpler for UWP processes, VirtualAlloc is defined inline and calls VirtualAllocFromApp,
so technically you can call VirtualAlloc from a UWP process.
There is another VirtualAlloc variant introduced in Windows 10 version 1803 called VirtualAlloc2.
It’s dealt with in its own section. There is yet another VirtualAlloc variant (VirtualAllocExNuma)
that is used specifically with Non-Uniform Memory Architecture (NUMA). We’ll discuss NUMA in
its own section as well.
We’ll start by describing the basic VirtualAlloc function upon which all the rest are built.
VirtualAlloc’s main purpose is to reserve and/or commit a block of memory.
The first parameter to VirtualAlloc is an optional pointer where the reservation/committing should
take place. If it’s a new allocation, NULL is typically passed-in, indicating that the memory manager
should find some free address. If the region is already reserved, and a commitment inside the region
is needed, then lpAddress indicates where the committing should start. In any case, the address
is rounded down to the nearest page. For new reservations, it’s rounded down to the allocation
granularity.
Allocation granularity is currently 64 KB on all Windows architectures and versions. You can always
get the value dynamically by calling GetSystemInfo.
dwSize is the size of the block to reserve/commit. If lpAddress is NULL, the size is rounded up to
the nearest page boundary. For example, 1 KB is rounded to 4 KB, 50 KB is rounded to 52 KB. If
lpAddress is not NULL, then all pages in the range of lpAddress to lpAddress+dwSize are included.

Chapter 13: Working With Memory
4
flAllocationType indicates the type of operation to perform. The most common flags are MEM_-
RESERVE and MEM_COMMIT. With MEM_RESERVE, the region is reserved, although the function fails if
lpAddress specifies an already reserved region.
MEM_COMMIT commits a region (or part of a region) previously reserved. This means lpAddress cannot
be NULL in this case. However, it is possible to reserve and commit memory at the same time by
combining both flags. For example, the following code reserves and commits 128 KB of memory:
void* p = ::VirtualAlloc(nullptr, 128 << 10, MEM_COMMIT | MEM_RESERVE,
PAGE_READWRITE);
if(!p) {
// some error occurred
}
A VirtualAlloc Bug
Technically, you can commit and reserve memory at the same time by using MEM_COMMIT alone.
Strictly speaking, this is incorrect. The reason this works goes back to a bug in the API that allowed
it. Unfortunately, many developers (knowingly or not) abused this bug, and so Microsoft decided
not to fix it so that existing code would not break. You should always use both flags if reserving and
committing at the same time.
Any committed pages are guaranteed to be filled with zeros. The reason has to do with a security
requirement stating that a process can never see any memory belonging to another process, even if
that process no longer exists. To make it explicit, the memory is always zeroed out.
This is not the case with functions such as malloc and similar. The reason will be clear later
in this chapter.
Reserving a region of memory that is already reserved is an error. On the other hand, committing
memory that is already committed succeeds implicitly.
The last parameter to VirtualAlloc is the page protection to set for the reserved/committed memory
(see chapter 12 in part 1 for more on protection flags). For committed memory, it’s the page
protection to set. For reserved memory, this sets the initial protection (AllocationProtect member
in
MEMORY_BASIC_INFORMATION), although it can change when memory is later committed. The protec-
tion flag has no effect on reserved memory, since reserved memory is inaccessible. Still, a valid value
must be supplied even in this case.
The return value of VirtualAlloc is the base address for the operation if successful, or NULL
otherwise. If lpAddress is not NULL, the returned value may or may not equal lpAddress, depending
on its page or allocation granularity alignment (as described earlier).

Chapter 13: Working With Memory
5
There are other possible flags to VirtualAlloc except MEM_RESERVE and MEM_COMMIT:
• MEM_RESET is a flag, that if used, must be the only one. It indicates to the memory manager that
the committed memory in the range is no longer needed, and so the memory manager should
not bother writing it to a page file. The committed memory cannot be backed by a mapped file,
only by a page file. Note that this is not the same as decommitting the memory; the memory
is still committed and can be used later (see next flag).
• MEM_RESET_UNDO is the opposite of MEM_RESET, stating that the committed memory region is of
interest again. The values in the range are not necessarily zero, since the memory manager
may or may not have reused the mapped physical pages.
• MEM_LARGE_PAGES indicates the operation should use large pages rather than small pages. We’ll
discuss this option in the “Large Pages” section, later in this chapter.
• MEM_PHYSICAL is a flag that can only be specified with MEM_RESERVE, for use with Address
Windowing Extensions (AWE), described later in this chapter.
• MEM_TOP_DOWN is an advisory flag to the memory manager to prefer high addresses rather than
low ones.
• MEM_WRITE_WATCH is a flag that must be specified with MEM_RESERVE. This flag indicates the
system should track memory writes to this region (once committed, of course). This is described
further in the “Memory Tracking” section.
Decommitting / Releasing Memory
VirtualAlloc must have an opposite function that can de-commit and/or release (the opposite of
reserve) a block of memory. This is the role of VirtualFree and VirtualFreeEx:
BOOL VirtualFree(
_in_ LPVOID lpAddress,
_In_ SIZE_T dwSize,
_In_ DWORD dwFreeType);
BOOL VirtualFreeEx(
_In_ HANDLE hProcess,
_In_ LPVOID lpAddress,
_In_ SIZE_T dwSize,
_In_ DWORD dwFreeType);
VirtualFreeEx is an extended version of VirtualFree that performs the requested operation in the
process specified by hProcess, which must have the PROCESS_VM_OPERATION access mask (just like
VirtualAllocEx). Only two flags are supported by the dwFreeType parameter - MEM_DECOMMIT and
MEM_RELEASE - one of which (and only one) must be specified.
MEM_DECOMMIT decommits the pages that span lpAddress to lpAddress+dwSize, returning the
memory region to the reserved state. MEM_RELEASE indicates the region should be freed completely.

Chapter 13: Working With Memory
6
lpAddress must be the base address of the region originally reserved, and dwSize must be zero. If
any memory in the region is committed, it’s first decommitted and then the entire region is released
(pages become free).
Reserving and Committing Memory
Using the VirtualAlloc function to reserve and commit memory is a good idea when large
allocations are needed, since this function works on page granularity. For small allocations, using
VirtualAlloc is too wasteful, since every new allocation would be on a new page. For small
allocations, it’s better to use the heap functions (described later in this chapter).
Committed Memory and RAM
Committing memory does not mean that RAM is immediately allocated for that memory. Commit-
ting memory increases the total system commit, meaning it guarantees that the committed memory
will be available when accessed. Once a page is accessed, the system provides the page in RAM
and the access can go through. Providing this page in RAM may be at the expense of another page
in RAM that would be pushed to disk if the system is low on memory. Regardless, this process is
transparent to the application.
Suppose you want to create an application that works similarly to Microsoft Excel, where a grid of
cells is available for data entry of some sort. Let’s further suppose that you want the user to have
a large grid at her disposal, say 1024 by 1024 cells, and each cell can contain a 1 KB of data. How
would you manage the cells in such an application?
One way is to use some linked list or map implementation, where each element is a 1 KB chunk of
memory. When the user accesses a cell, the element is retrieved based on the managed data structure
and used. Since every cell has the same size, another alternative might be to allocate a large enough
memory chunk and then access a particular cell with a quick calculation. Here is an example:
int cellSize = 1 << 10;
// 1 KB
int maxx = 1 << 10, maxy = 1 << 10; // 1024 x 1024 cells
void* data = malloc(maxx * maxy * cellSize);
// locate cell (x,y) address
void* pCell = (BYTE*)data + (y * maxx + x) * cellSize;
// perform access to pCell...
This works, and locating a cell is very fast. The problem is that 1 GB of memory is committed
upfront. This is wasteful because the user is unlikely to use all the available cells. Also, if we later
decide to allow more cells to be used, the committed memory would have to be larger.

Chapter 13: Working With Memory
7
What we want is a way to continue locating cells very fast, but not allocate the cell data unless it’s
being used. This is where reserving memory and committing in chunks can help solve this issue. We
start with reserving a 1 GB of address space:
void* data = ::VirtualAlloc(nullptr, maxx * maxy * cellSize,
MEM_RESERVE, PAGE_READWRITE);
The reserving operation is very cheap - the commit size of the system is not modified. Now whenever
access is required for a cell, we can compute its address withing the block as before, and then commit
the required cell:
// commit page for cell (x, y)
void* pCell = (BYTE*)data + (y * maxx + x) * cellSize;
::VirtualAlloc(pCell, cellSize, MEM_COMMIT, PAGE_READWRITE);
// access cell...
The code calculates the cell’s address like before, but because the memory is initially reserved,
there is nothing there. Accessing that memory in any way causes an access violation exception/
By using VirtualAlloc with MEM_COMMIT, the page where the cell resides is committed, making it
“real”. Accessing this memory must now succeed.
VirtualAlloc always works with pages, so the above code commits 4 cells (remember each cell is 1
KB in size), not just one. There is no way around that when using the Virtual* functions.
Every time a cell needs to be used, the same code runs, committing that cell (and 3 adjacent cells),
so that there are accessible. The consumption of memory is only for those cells that are used (and
the adjacent cells even if they are not used). This scheme allows us to use a very large number
of potential cells without wasting more memory. For example, we can increase the maximum grid
size to 2048 by 2048. The only change is the amount of reserved memory, to keep the address space
contiguous.
The main downside of this approach is that large portions of the address space are taken. In
64-bit processes (where the address space is 128 TB), this is not an issue. In 32-bit processes,
this might fail. For example, using a 2048 by 2048 grid with 1 KB of memory per cell requires
4 GB of address space, which is beyond the capabilities of a 32-bit process (even on WOW64
with the LARGEADDRESSAWARE set, since the address space must also contain DLLs, thread
stacks, etc.). The address range must also be contiguous, which even with a smaller size
could be a problem to get in a 32-bit process.
Committing an already committed memory is not an issue, but it does incur a system call, that
perhaps could be avoided if the cell memory in question is already committed. How can that be
done?

Chapter 13: Working With Memory
8
One way is to use the VirtualQuery function described in chapter 12 to query the memory region and
decided whether to commit memory or not. But that requires a system call in itself, so it’s actually
worse than just committing before any access. The alternative is to access the memory “blindly” - if
it’s already committed, it just works; if not, an exception is raised, which can be caught and handled
by committing the required memory. Here is the basic idea in code:
void DoWork(void* data, int x, int y) {
// in some function
void* pCell = (BYTE*)data + (y * maxx + x) * cellSize;
__try
// access the cell memory
::strcpy((char*)pCell, "some text data");
// if we get here, all is well
}
__except(FixMemory(pCell, GetExceptionCode())) {
// no code needed here
}
}
int FixMemory(void* p, DWORD code) {
if(code == EXCEPTION_ACCESS_VIOLATION) {
// we can fix it by comitting the memory
::VirtualAlloc(p, cellSize, MEM_COMMIT, PAGE_READWRITE);
// tell the CPU to try again
return EXCEPTION_CONTINUE_EXECUTION;
}
// some other exception, look elsewhere for a handler
return EXCEPTION_CONTINUE_SEARCH;
}
If an exception is raised in the strcpy call, the __except expression is evaluated by calling the
FixMemory function with the address in question and the exception code. The purpose of this function
is to return one of three possible values indicating to the exception handling mechanism what to do
next. If the exception code is an access violation, then we can do something about it and commit
the required memory before returning EXCEPTION_CONTINUE_EXECUTION, indicating the processor
should try the original instruction again. If it’s some other exception, we don’t handle it and return
EXCEPTION_CONTINUE_SEARCH to continue searching up the call stack for a handler.
The other possible return value is EXCEPTION_EXECUTE_HANDLER. Exception handling is detailed in
chapter 23.

Chapter 13: Working With Memory
9
The Micro Excel Application
The Micro Excel application demonstrates the above technique. Running it shows the dialog in figure
13-2.
Figure 13-2: The Micro Excel application
The application reserves a 1 GB memory range, starting at the address shown at the top. The Cell
X and Cell Y edit boxes allow selecting a cell in either direction (0-1023). By typing something in
the large edit box and clicking Write, the text is written to the requested cell. If the memory is not
committed (which must be the case the first time), it’s committed by handling an access violation
exception. After adding one string to cell (0,0), the application window looks like figure 13-3.

Chapter 13: Working With Memory
10
Figure 13-3: Micro Excel application with one allocation
The bottom text indicates 4 KB have been committed, which is what we expect, as a single page is
required for the 1 KB cell. If we set cell X to 1 and write something, what would be the committed
size? It would remain the same, because the first committed page covers 4 cells (figure 13-4).
Figure 13-4: Writing to cell (1,0)
What would happen if you write something to cell (0,1)? Try it and find out! You can read back from
any cell by using the Read button. If the cell is not committed, an error is returned.
It’s interesting to see the allocated memory region with VMMap. Each time a new page is committed,

Chapter 13: Working With Memory
11
it “punches a hole” in the large reserved region. Figure 13-5 shows the memory region used by the
application with several “punched holes” of committed memory.
Figure 13-5: VMMap showing the committed regions inside the large reserved region
The application is built as a standard WTL dialog-based application. The CMainDlg class holds several
data members related to the managed memory:
class CMainDlg : public CDialogImpl<CMainDlg> {
//...
const int CellSize = 1024, SizeX = 1024, SizeY = 1024;
const size_t TotalSize = CellSize * SizeX * SizeY;
void* m_Address{ nullptr };
};
The various sizes are declared as constants, but it wouldn’t be much different if these were
dynamically set. OnInitDialog calls AllocateRegion to reserve the initial region of memory:
bool CMainDlg::AllocateRegion() {
m_Address = ::VirtualAlloc(nullptr, TotalSize, MEM_RESERVE, PAGE_READWRITE);
if (!m_Address) {
AtlMessageBox(nullptr, L"Available address space is not large enough",
IDR_MAINFRAME, MB_ICONERROR);
EndDialog(IDCANCEL);
return false;
}
// update the UI
CString addr;
addr.Format(L"0x%p", m_Address);
SetDlgItemText(IDC_ADDRESS, addr);
SetDlgItemText(IDC_CELLADDR, addr);
return true;
}
Once the user clicks any of the buttons, the address of the cell needs to be retrieved. This is
accomplished with GetCell:

Chapter 13: Working With Memory
12
void* CMainDlg::GetCell(int& x, int& y, bool reportError /* = true */) const {
// get indices from UI
x = GetDlgItemInt(IDC_CELLX);
y = GetDlgItemInt(IDC_CELLY);
// check range validity
if (x < 0 || x >= SizeX || y < 0 || y >= SizeY) {
if(reportError)
AtlMessageBox(*this, L"Indices out of range",
IDR_MAINFRAME, MB_ICONEXCLAMATION);
return nullptr;
}
return (BYTE*)m_Address + CellSize * ((size_t)x + SizeX * y);
}
The interesting code is in the Write button handler. First, the cell address is retrieved:
LRESULT CMainDlg::OnWrite(WORD, WORD, HWND, BOOL&) {
int x, y;
auto p = GetCell(x, y);
if(!p)
return 0;
Next, the edit box context is read and written to the memory block. If an exception occurs, the helper
FixMemory is called:
WCHAR text[512];
GetDlgItemText(IDC_TEXT, text, _countof(text));
__try {
::wcscpy_s((WCHAR*)p, CellSize / sizeof(WCHAR), text);
}
__except (FixMemory(p, GetExceptionCode())) {
// nothing to do: this code is never reached
}
FixMemory will attempt to correct the error if indeed this was an access violation:

Chapter 13: Working With Memory
13
int CMainDlg::FixMemory(void* address, DWORD exceptionCode) {
if (exceptionCode == EXCEPTION_ACCESS_VIOLATION) {
// commit the cell
::VirtualAlloc(address, CellSize, MEM_COMMIT, PAGE_READWRITE);
// tell the CPU to try again
return EXCEPTION_CONTINUE_EXECUTION;
}
// some other error, continue to search a handler up the call stack
return EXCEPTION_CONTINUE_SEARCH;
}
Technically, the VirtualAlloc call inside FixMemory could fail if the system is at its maximum
commit limit. In that case, VirtualAlloc returns NULL, and the return value from FixMemory should
be EXCEPTION_CONTINUE_SEARCH.
The Read button handler is similar, except that no committing is attempted if the cell is not
committed, and an error is displayed instead:
LRESULT CMainDlg::OnRead(WORD, WORD, HWND, BOOL&) {
int x, y;
auto p = GetCell(x, y);
if(!p)
return 0;
WCHAR text[512];
__try {
::wcscpy_s(text, _countof(text), (PCWSTR)p);
SetDlgItemText(IDC_TEXT, text);
}
__except (EXCEPTION_EXECUTE_HANDLER) {
AtlMessageBox(nullptr, L"Cell memory is not committed",
IDR_MAINFRAME, MB_ICONWARNING);
}
return 0;
}
The Release and Release All buttons decommit a cell and release the entire memory block,
respectively:

Chapter 13: Working With Memory
14
LRESULT CMainDlg::OnRelease(WORD, WORD, HWND, BOOL&) {
int x, y;
auto p = GetCell(x, y);
if (p) {
::VirtualFree(p, CellSize, MEM_DECOMMIT);
}
return 0;
}
LRESULT CMainDlg::OnReleaseAll(WORD, WORD wID, HWND, BOOL&) {
::VirtualFree(m_Address, 0, MEM_RELEASE);
// allocate a new reserved region
AllocateRegion();
return 0;
}
Finally, the bottom output indicating the amount of committed memory is displayed using a timer
that uses the VirtualQuery API from chapter 12 to walk the entire memory region and count the
size of the committed memory:
LRESULT CMainDlg::OnTimer(UINT, WPARAM id, LPARAM, BOOL&) {
if (id == 1) {
MEMORY_BASIC_INFORMATION mbi;
auto p = (BYTE*)m_Address;
size_t committed = 0;
while (p < (BYTE*)m_Address + TotalSize) {
::VirtualQuery(p, &mbi, sizeof(mbi));
if (mbi.State == MEM_COMMIT)
committed += mbi.RegionSize;
p += mbi.RegionSize;
}
CString text;
text.Format(L"Total: %llu KB Committed: %llu KB",
TotalSize >> 10, committed >> 10);
SetDlgItemText(IDC_STATS, text);
}
return 0;
}

Chapter 13: Working With Memory
15
Working Sets
The term Working Set represents memory accessible without incurring a page fault. Naturally, a
process would like all of its committed memory be in its working set. The memory manager must
balance the needs of a process with the needs of all other processes. Memory that was not accessed
for a long time might be removed from a process’ working set. This does not mean it’s automatically
discarded - the memory manager has elaborate algorithms to keep physical pages that used to be part
of a process’ working set in RAM longer than might be necessary, so that if the process in question
decided to access that memory, it can be immediately faulted into the working set (this is known as
a soft page fault).
The details of the way the memory manager manages physical memory is beyond the scope of this
book. Interested readers should consult chapter 5 in the Windows Internals, 7th ed. Part 1 book.
The current and peak woking sets of a process can be obtained by calling GetProcessMemoryInfo,
described in chapter 12 (part 1), repeated here for convenience:
BOOL GetProcessMemoryInfo(
HANDLE Process,
PPROCESS_MEMORY_COUNTERS ppsmemCounters,
DWORD cb);
The members WorkingSetSize and PeakWorkingSetSize of PROCESS_MEMORY_COUNTERS give the
current and peak working set of the specified process. Other members of this (and the extended)
structure provide other useful metrics. Refer to chapter 12 for the full details.
A process has a minimum and maximum working set. These limits are soft by default, so that a
process can consume more RAM than its maximum working set if memory is abundant, and can
use less RAM than its minimum working set if memory is scarce. You can query for these limits
with GetProcessWorkingSetSize:
BOOL GetProcessWorkingSetSize(
_In_
HANDLE hProcess,
_Out_ PSIZE_T lpMinimumWorkingSetSize,
// bytes
_Out_ PSIZE_T lpMaximumWorkingSetSize); // bytes
The process handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION
access mask. The default values are minimum of 50 pages (200 KB), and maximum of 345 pages (1380
KB), but these limits can be altered by calling SetProcessWorkingSetSize:

Chapter 13: Working With Memory
16
BOOL SetProcessWorkingSetSize(
_In_ HANDLE hProcess,
_In_ SIZE_T dwMinimumWorkingSetSize,
// bytes
_In_ SIZE_T dwMaximumWorkingSetSize);
// bytes
The process handle must have the PROCESS_SET_QUOTA access mask for the operation to have a
chance to succeed. If the minimum or the maximum working set values is higher than the current
maximum working set, the caller’s token must have the SE_INC_WORKING_SET_NAME privilege. This is
not normally an issue, as all users have this privilege.
The minimum value for the minimum working set size is 20 pages (80 KB), and the minimum value
for the maximum working set size is 13 pages (52 KB). The maximum for the maximum working set
size is 512 pages less than the available memory. Specifying zero for any of the values is an error.
One special case is specifying (SIZE_T)-1 for both values. This causes the system to remove as
many pages as possible from the process’ working set. The same can be accomplished with the
EmptyWorkingSet function:
BOOL WINAPI EmptyWorkingSet(_In_ HANDLE hProcess);
The process handle must have the PROCESS_SET_QUOTA access mask and either PROCESS_QUERY_-
INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION.
As mentioned, the minimum and maximum working set sizes are soft limits by default. This can be
changed with an extended version of SetProcessWorkingSetSize:
BOOL SetProcessWorkingSetSizeEx(
_In_ HANDLE hProcess,
_In_ SIZE_T dwMinimumWorkingSetSize,
_In_ SIZE_T dwMaximumWorkingSetSize,
_In_ DWORD Flags);
The extra flags parameter can be a combination of the values listed in table 13-1.
Table 13-1: Flags for SetProcessWorkingSetSizeEx
Flag
Description
QUOTA_LIMITS_HARDWS_MIN_ENABLE (1)
Hard limit on the minimum working set
QUOTA_LIMITS_HARDWS_MIN_DISABLE (2)
Soft limit on the minimum working set
QUOTA_LIMITS_HARDWS_MAX_ENABLE (4)
Hard limit on the maximum working set
QUOTA_LIMITS_HARDWS_MAX_DISABLE (8)
Soft limit on the maximum working set
If a process is configured to use a maximum working set hard limit, any extra committed memory
the process might like to have as part of its working set causes other pages to be removed from

Chapter 13: Working With Memory
17
its working set, essentially making page faults against itself. Specifying zero for the flags does not
change the limit flags, essentially making the call equivalent to SetProcessWorkingSetSize. The
opposite function for getting the current limits and the flags exists as well:
BOOL GetProcessWorkingSetSizeEx(
_In_ HANDLE hProcess,
_Out_ PSIZE_T lpMinimumWorkingSetSize,
_Out_ PSIZE_T lpMaximumWorkingSetSize,
_Out_ PDWORD Flags);
The Working Sets Application
The Working Sets application shows all processes with memory-related counters, such as the
working set size, the peak working set size, the minimum and maximum, and more. It’s based on
the APIs discussed in the previous section. It’s interesting (and sometime necessary) to get a sense
of how various processes use memory.
When the application is first launched, many processes do not show any memory counters. This
is because a handle could not be successfully open to them. Selecting the View / Accessible
Processes Only leaves only accessible processes in the display. Alternatively, selecting File / Run
as Administrator (or launching the application with admin rights) shows many more processes as
accessible. Figure 13-6 shows what this might look like.
Figure 13-6: The Working Sets application

Chapter 13: Working With Memory
18
The display refreshes automatically every second. You can try working with a certain process and
watch its working set and committed memory usage change dynamically. You can sort by any
column. Figure 13-7 shows the processes whose peak working set usage is the highest (at least from
the processes that can be queried).
Figure 13-7: Working Sets sorted by peak working set
The Memory Compression process has the highest peak working set, which is no real surprise, since
it holds compressed memory, thus saving physical memory. Next in the list is Windows Defender,
which consumes way too much memory for an anti-malware software. Visual Studio Code is next,
and so on.
You can select the Process / Empty Working Set menu item to force a process to relinquish most of its
physical memory usage (at least for a while). For some processes, this will fail, as PROCESS_SET_QUOTA
is not possible to get for every process.
The application is built as a standard WTL Single Document Interface (SDI), which a view that is
based on a list view control. The most important function is CView::Refresh, called initially and
every second when the timer expires. Each process information is stored in the following structure
(defined as a nested type in view.h):
struct ProcessInfo {
DWORD Id;
// process ID
CString ImageName;
SIZE_T MinWorkingSet, MaxWorkingSet;
DWORD WorkingSetFlags;
PROCESS_MEMORY_COUNTERS_EX Counters;
bool CountersAvailable{ false };
};
std::vector<ProcessInfo> m_Items;
The first order of business in the Refresh method is to start process enumeration:

Chapter 13: Working With Memory
19
void CView::Refresh() {
wil::unique_handle hSnapshot(::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0));
if (!hSnapshot)
return;
PROCESSENTRY32 pe;
pe.dwSize = sizeof(pe);
// skip the idle process
::Process32First(hSnapshot.get(), &pe);
m_Items.clear();
m_Items.reserve(512);
The Toolhelp functions introduced in chapter 3 are used. For each process, a ProcessInfo object is
filled up:
while (::Process32Next(hSnapshot.get(), &pe)) {
// attempt to open a handle to the process
wil::unique_handle hProcess(::OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION,
FALSE, pe.th32ProcessID));
if (!hProcess && m_ShowOnlyAccessibleProcesses)
continue;
ProcessInfo pi;
pi.Id = pe.th32ProcessID;
pi.ImageName = pe.szExeFile;
If a handle cannot be obtained and the “show only accessible processes* option is set, then skip this
process. Otherwise, fill in the only two values that are guaranteed to be available for all processes -
the process ID and process image name.
Next, if a proper handle could be opened, the memory APIs are invoked to get the information and
store it in the ProcessInfo instance:
if (hProcess) {
::GetProcessMemoryInfo(hProcess.get(), (PROCESS_MEMORY_COUNTERS*)&pi.Counters,
sizeof(pi.Counters));
::GetProcessWorkingSetSizeEx(hProcess.get(), &pi.MinWorkingSet,
&pi.MaxWorkingSet, &pi.WorkingSetFlags);
pi.CountersAvailable = true;
}
If a handle is available, the CountersAvailable field is set to true, indicating the memory
information in the structure is valid. Finally, the object is added to the vector and the loop continues
for all processes:

Chapter 13: Working With Memory
20
m_Items.push_back(pi);
}
All that’s left to do is sort the items (if needed) and update the list view:
DoSort(GetSortInfo(*this));
SetItemCountEx(static_cast<int>(m_Items.size()),
LVSICF_NOSCROLL | LVSICF_NOINVALIDATEALL);
RedrawItems(GetTopIndex(), GetTopIndex() + GetCountPerPage());
}
I’m not discussing the other functions in the CView class, since they don’t use any memory-related
APIs. The full source code is available for the interested reader to browse through.
To empty the working, SetProcessWorkingSetSize is called with both values as -1. The EmptyWorkingSet
function could have been called instead:
LRESULT CView::OnEmptyWorkingSet(WORD, WORD, HWND, BOOL&) {
auto index = GetSelectedIndex();
ATLASSERT(index >= 0);
const auto& item = m_Items[index];
wil::unique_handle hProcess(::OpenProcess(PROCESS_SET_QUOTA, FALSE, item.Id));
if (!hProcess) {
AtlMessageBox(*this, L"Failed to open process", IDR_MAINFRAME, MB_ICONERROR);
return 0;
}
if (!::SetProcessWorkingSetSize(hProcess.get(), (SIZE_T)-1, (SIZE_T)-1)) {
AtlMessageBox(*this, L"Failed to empty working set",
IDR_MAINFRAME, MB_ICONERROR);
}
return 0;
}
Add a menu option to set a minimum and/or maximum working set sizes (perhaps with a
dialog box), along with the optional flags available with SetProcessWorkingSetSizeEx and
do some experimentation on how these values affect running processes.

Chapter 13: Working With Memory
21
Heaps
The VirtualAlloc set of functions are very powerful, since they are very close to the memory
manager. There is a downside, however. These functions only work in page chunks: if you allocate 10
bytes, you get back a page. If you allocate 10 more bytes, you get a different page. This is too wasteful
for managing small allocations, which are so common in applications. This is exactly where heaps
come in.
The Heap Manager is a component layered on top of the Virtual API, that knows how to manage
small allocations efficiently. A heap, in this context, is a memory block managed by the heap
manager. Every process starts with a single heap, called the default process heap. A handle to that
heap is obtained with GetProcessHeap:
HANDLE GetProcessHeap();
More heaps can be created, described in the section Other Heaps. With a heap in hand, allocating
(committing) memory is done with HeapAlloc:
LPVOID HeapAlloc(
_In_ HANDLE hHeap,
_In_ DWORD dwFlags,
_In_ SIZE_T dwBytes);
HeapAlloc accepts a handle to a heap, optional flags and the number of bytes of requested memory.
The flags can be zero or a combination of the following values:
• HEAP_ZERO_MEMORY specifies that the returned memory block should be zeroed out by the
function. Otherwise, whatever was in that block remains.
• HEAP_NO_SERIALIZE indicates the function should not take the heap’s lock. This means the
developer provides her own synchronization or guarantees that no concurrent access is made
to the heap. This value should not be specified for the default process heap, since the default
heap is created with synchronization and it’s used with some APIs which do not expect
unsynchronized access. For application-created heaps, this flag can be specified when a heap is
created (HeapCreate, see later), so that specifying this value for every allocation is not required.
• HEAP_GENERATE_EXCEPTIONS indicates the function should report failure by raising an SEH
exception (STATUS_NO_MEMORY), rather than returning NULL. If such behavior is desired for all
heap operations, this flag can be specified when the heap is created with HeapCreate.
Here is an example of allocating some data from the default process heap:

Chapter 13: Working With Memory
22
struct MyData {
//...
};
MyData* pData = (MyData*)::HeapAlloc(::GetProcessHeap(), 0, sizeof(MyData));
if(pData == nullptr) {
// handle failure
}
If an allocated block needs to be increased or decreased in size while preserving the existing data,
HeapReAlloc can be used:
LPVOID HeapReAlloc(
_Inout_ HANDLE hHeap,
_In_ DWORD dwFlags,
_Frees_ptr_opt_ LPVOID lpMem,
_In_ SIZE_T dwBytes);
lpMem is the existing address, with dwBytes being the new requested size. The function returns the
address of the new block, which may be the same as the original address if the new size is smaller
than the original or the there is enough space to resize the block without moving it. If the new size
is larger but does not fit in the existing heap-block, the memory is copied to a new location and
the new address is returned from the function. If this copying is not desired, an additional flag is
supported by HeapReAlloc - HEAP_REALLOC_IN_PLACE_ONLY - that if specified, fails the re-allocation
if the new size cannot fit in the existing block.
Once an allocation is no longer needed, call HeapFree to return it to the heap:
BOOL HeapFree(
_Inout_ HANDLE hHeap,
_In_ DWORD dwFlags,
_In_ LPVOID lpMem);
The only valid flag for HeapFree is HEAP_NO_SERIALIZE. After a successful call to HeapFree, the lpMem
address should be considered invalid. In most cases, this address remains valid in the sense of it still
pointing to committed memory, but new allocations may reuse this address. No access violation
exception is likely to be thrown if that memory is accessed without a proper allocation. This is in
contrast to VirtualFree that decommits memory so that any access to the same page will raise an
access violation exception.
Private Heaps
A heap starts its life as a reserved chunk of memory, part of which may be committed. A heap can
have a fixed maximum size or be growable. A growable heap can grow as far as the process address

Chapter 13: Working With Memory
23
space allows. The default process heap is growable - its initial reserved and committed sizes can be
specified with linker settings. Figure 13-8 shows a project’s properties dialog in Visual Studio for
setting these values.
Figure 13-8: Heap sizes linker settings
The default sizes for the default process heap can be inspected with any PE viewer tool, such as
Dumpbin. Here is an example for Notepad:
c:\>dumpbin /headers c:\Windows\System32\notepad.exe
Microsoft (R) COFF/PE Dumper Version 14.26.28805.0
Copyright (C) Microsoft Corporation.
All rights reserved.
Dump of file c:\Windows\System32\notepad.exe
PE signature found
File Type: EXECUTABLE IMAGE
...
OPTIONAL HEADER VALUES
20B magic # (PE32+)

Chapter 13: Working With Memory
24
...
100000 size of heap reserve
1000 size of heap commit
...
The initial commit is a single page and the initial reserved size is 1 MB. This is the default (for the
defaults), if no custom values are specified in the linker settings.
The default process heap always exists and cannot be destroyed. Since it’s growable, why would
you want to create additional heaps?
One reason is to avoid fragmentation. When various sizes are used for allocations on the same heap,
fragmentation to one degree or another is inevitable. For example, suppose the application allocates
several structures 16 bytes in size. Now suppose one of these structures is freed, and a new structure
24 bytes in size needs to be allocated. The gap of 16 bytes is not enough, and so the heap manager
allocates the block at the end of the used heap area. If a 12-byte structure is needed, it can fit in that
16-byte space, but now the 4-byte space would probably never used again. This fragmentation leads
to using more memory than is really needed. If the process lives for hours or even more, with lots
of allocations and deallocations, the problem is compounded.
Every heap allocation carries with it some management overhead, in terms of CPU and
memory. Thus, using VirtualAlloc is always a bit faster and does not have the same memory
overhead.
One (partial) solution to the problem is using the Low Fragmentation Heap (LFH), described in the
section Heap Types. The other is to create a separate (private) heap that holds blocks of a certain
size. if one block is freed, there is exactly room for a new block of the same size. This scheme is
useful if many objects of a certain size (typically a certain structure/class) are allocated and freed
throughout the lifetime of the process.
Creating a new heap is done with HeapCreate:
HANDLE HeapCreate(
_In_ DWORD flOptions,
_In_ SIZE_T dwInitialSize,
_In_ SIZE_T dwMaximumSize);
The first options parameter can be zero or a combination of three flags, two of which we met with
HeapAlloc: HEAP_GENERATE_EXCEPTIONS and HEAP_NO_SERIALIZE. If HEAP_NO_SERIALIZE is specified,
the heap manager does not hold any lock while performing heap operations. This means any
concurrent access to the heap could result in a heap corruption. This option makes the heap manager
slightly faster, but it’s up to the developer to provide synchronized access to the heap if required.
One potential downside of setting this flag, is that the heap cannot use the Low Fragmentation Heap
(LFH) layer (described later).

Chapter 13: Working With Memory
25
The last flag, HEAP_CREATE_ENABLE_EXECUTE, tells the heap manager to allocate blocks with PAGE_-
EXECUTE_READWRITE access rather than just PAGE_READWRITE. This could be useful if code is to be
written to the heap and executed, such as in Just in time (JIT) compilation scenarios.
The dwInitialSize parameter indicates the amount of memory that should be committed upfront.
The value is rounded up to the nearest page. A value of zero equals a single page. dwMaximumSize
specifies the maximum size the heap can grow to. The memory between the initial commit and the
maximum size is kept reserved. If the maximum value specified is zero, then the heap is growable,
otherwise this is the maximum size of the heap (fixed heap). Any attempt to allocate more than the
heap’s size, fails. If the heap is fixed then the largest chunk that can be allocated is slightly less than
512 KB in 32-bit systems and slightly less than 1 MB in 64-bit processes. You should not use the heap
API anyway for such large sizes, but instead use the VirtualAlloc function.
The function’s return value is a handle to the new heap, to be used with other heap functions such
as HeapAlloc and HeapFreee. If the function fails, NULL is returned.
A private heap needs to be destroyed at some point, accomplished with HeapDestroy:
BOOL HeapDestroy(_In_ HANDLE hHeap);
HeapDestroy frees the entire heap in a single stroke, so there is no need to free every individual
allocation if heap destruction is imminent. This could be yet another motivation to create a private
heap.
One way to leverage a private heap with same-size structures is to use C++’s ability to override the
new and delete operators, so that any dynamic allocation or deallocation of the structure ocurrs
on the private heap, while the developer does not to concern herself with calling any specific APIs.
Here is the header of such an example type:
class MyClass {
public:
void* operator new(size_t);
void operator delete(void*);
void DoWork();
private:
static HANDLE s_hHeap;
static unsigned s_Count;
};
The class holds two static members (common to all instances of MyClass). These hold the heap handle
and the count of instances, so that the heap can be destroyed when the last instance is freed. Here
is the implementation:

Chapter 13: Working With Memory
26
HANDLE MyClass::s_hHeap = nullptr;
unsigned MyClass::s_Count = 0;
void* MyClass::operator new(size_t size) {
if (InterlockedIncrement(&s_Count) == 1)
s_hHeap = ::HeapCreate(0, 64 << 10, 16 << 20);
return ::HeapAlloc(s_hHeap, 0, size);
}
void MyClass::operator delete(void* p) {
::HeapFree(s_hHeap, 0, p);
if (::InterlockedDecrement(&s_Count) == 0)
::HeapDestroy(s_hHeap);
}
The private heap is created with 64 KB committed size and a maximum of 16 MB (these are just
examples, of course). Any client to the MyClass type can use normal C++ operations:
auto obj = new MyClass;
obj->DoWork();
delete obj;
The client does not need to know that under the covers the objects are allocated from a private heap,
that guarantees fragmentation-free usage.
Heap Types
We’ve seen that a heap can be created with a fixed maximum size or growable. To help mitigate
heap fragmentation, Windows supports the Low Fragmentation Heap (LFH) for heaps that are
not created without serialization (don’t have the flag HEAP_NO_SERIALIZE). The LFH attempts to
minimize fragmentation by using specific-sized blocks that have a better chance to fulfill allocations.
For example, an 8-byte and a 12-byte allocation request will get 16 bytes. When such an allocation
is freed, there is a better chance of putting a new allocation into the same block if its requested size
is no more than 16 bytes. This means the LFH minimizes fragmentation by potentially using more
memory than needed for each allocation.
The LFH is built as an optional front-layer for the standard heap. It’s activated automatically under
certain conditions, and cannot be turned off once activated. It’s also not possible to force using the
LFH.
Windows versions prior to Vista did allow turning the LFH on and off. It was difficult for
developers to know when is a good time for such operations, so now the heap manager uses
its own tuning logic.
You can query for the type of a heap with HeapQueryInformation:

Chapter 13: Working With Memory
27
BOOL HeapQueryInformation(
_In_opt_ HANDLE HeapHandle,
_In_ HEAP_INFORMATION_CLASS HeapInformationClass,
_Out_ PVOID HeapInformation,
_In_ SIZE_T HeapInformationLength,
_Out_opt_ PSIZE_T ReturnLength);
The function provides a generic way to query some heap parameters, based on the HEAP_-
INFORMATION_CLASS enumeration, of which one value (HeapCompatibilityInformation) is officially
documented. The output buffer is a 32-bit number, which can be 0 (no LFH) or 2 (LFH). The following
example queries the type of the defailt process heap:
ULONG type;
::HeapQueryInformation(::GetProcessHeap(), HeapCompatibilityInformation, &type,
sizeof(type), nullptr);
Windows 8 introduced another type of heap called the Segment Heap. This heap has better
management of blocks and extra security measures to help prevent malicious code in the process
from recognizing heap blocks just by having a pointer to somewhere on the heap. The segment
heap is used by all UWP processes because it has a smaller memory footprint that is beneficial for
UWP processes running on small devices such as phones or tablets. Some system processes use the
segment heap as well, including smss.exe, csrss.exe and svchost.exe.
The segment heap is not the default heap for compatibility reasons. It is possible to enable it for
a specific executable by creating a subkey with the executable name (with the EXE extension but
no path) in the registry key HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File
Execution Options (this requires admin access). In that subkey, add a DWORD value named Fron-
tEndHeapDebugOptions and set its value to 8. Figure 13-9 shows this value set for Notepad.exe.
The next time this executable is launched, it will use the segment heap by default.

Chapter 13: Working With Memory
28
Figure 13-9: Enabling the segment heap for an executable
For more information on the segment heap, consult chapter 5 in the “Windows Internals 7th
edition Part 1” book.
Heap Debugging Features
One too common occurrence when working with the heap APIs is heap corruption, typically due
to accessing memory with dangling pointers, or writing beyond an allocation’s size. These bugs are
notoriously difficult to track down in all but the simplest applications. The main issue making such
problems difficult to solve is the fact that the corruption itself is usually detected much later, when
the offending code is no longer in the call stack. Other reasons for these occurrences is sometimes
due to malicious code injection attempts on the heap. The heap manager provides some help in this
regard.
You can call the HeapValidate function to tell the heap manager to scan all allocations from a given
heap and validate their integrity:
BOOL HeapValidate(
_In_ HANDLE hHeap,
_In_ DWORD dwFlags,
_In_opt_ LPCVOID lpMem);
The only valid flag to the function is HEAP_NO_SERIALIZE, discussed earlier. If lpMem is NULL, the
entire heap is scanned, otherwise just the provided memory block is checked for integrity. If lpMem

Chapter 13: Working With Memory
29
is not NULL, the pointer must be to a start of an allocation (returned by a previous call to HeapAlloc
or HeapReAlloc).
HeapValidate returns TRUE if the heap/block is valid, and FALSE otherwise. If a debugger is connected
to the process, an exception is triggered, breaking into the debugger by default. Validating a full heap
can be time-consuming, so this option should generally be used for debugging purposes only.
If lpMem is NULL, HeapValidate always returns TRUE for the segment heap.
Some errors will go undetected by HeapValidate. If some code wrote to a block beyond
its size, that happened to be free, or there was extra memory because the LFH is used,
HeapValidate would miss the overflow.
Another option is to request the heap manager to terminate the process in case a heap corruption is
detected (instead of just marching on), by calling HeapSetInformation:
BOOL HeapSetInformation(
_In_opt_ HANDLE HeapHandle,
_In_ HEAP_INFORMATION_CLASS HeapInformationClass,
_In_ PVOID HeapInformation,
_In_ SIZE_T HeapInformationLength);
The HEAP_INFORMATION_CLASS in question is HeapEnableTerminationOnCorruption. This op-
tion is process-wide, so the heap handle is ignored, and can be specified as NULL. The HeapInformation
and HeapInformationLength should be set to NULL and zero, respectively. Once enabled, this feature
cannot be disabled for the lifetime of the process.
There are some other heap debugging features that can be set by using certain flags set with the
NtGlobalFlags value in the Image File Execution Options registry key used in a previous section.
Normally, these values are set with a tool, such as GFlags (part of the Debugging Tools for Windows
package, normally installed with the Windows SDK), or my own GFlagsX tool. Figure 13-10 shows
GFlags used for Notepad.exe. There are several heap-related options, marked in figure 13-10. Consult
the GFlags tool documentation for a description of these options.

Chapter 13: Working With Memory
30
Figure 13-10: GFlags Heap related options
Using any of the debugging options (except “Disable heap coalesce on free”) slows down
all heap operations, so it’s best to use these only while debugging or troubleshooting heap
related issues.
The C/C++ Runtime
The implementation of the C/C++ memory management functions, such as malloc, calloc, free,
the C++ new and delete operators, and so on, depends on the compiler-provided libraries. Since we
do our work mostly with Microsoft’s compilers, then we can say something about the Visual C++
runtime implementation of these functions.
The C/C++ runtime uses the heap functions to manage their allocation. Current implementation use
the default process heap. Since the CRT source code is distributed with Visual Studio, it’s possible

Chapter 13: Working With Memory
31
to simply look at the implementation. Here is the implementation of malloc with some macros and
directives removed for clarity (in malloc.cpp):
extern "C" void* __cdecl malloc(size_t const size) {
#ifdef _DEBUG
return _malloc_dbg(size, _NORMAL_BLOCK, nullptr, 0);
#else
return _malloc_base(size);
#endif
}
There are two implementations for malloc - one for debug build and another for release builds. Here
is an excerpt from the release build version (in the file malloc_base.cpp):
extern "C" __declspec(noinline) void* __cdecl _malloc_base(size_t const size) {
// Ensure that the requested size is not too large:
_VALIDATE_RETURN_NOEXC(_HEAP_MAXREQ >= size, ENOMEM, nullptr);
// Ensure we request an allocation of at least one byte:
size_t const actual_size = size == 0 ? 1 : size;
for (;;) {
void* const block = HeapAlloc(__acrt_heap, 0, actual_size);
if (block)
return block;
//...code omitted...
}
The global __acrt_heap is initialized in this function (from heap_handle.cpp):
extern "C" bool __cdecl __acrt_initialize_heap() {
__acrt_heap = GetProcessHeap();
if (__acrt_heap == nullptr)
return false;
return true;
}
This implementation uses the default process heap.

Chapter 13: Working With Memory
32
The Local/Global APIs
The set APIs having the prefixes Local and Global, such as LocalAlloc, GlobalAlloc, LocalFree,
LocalLock and others were created primarily for compatibility with 16-bit Windows. Their use is
awkward, since an allocation returns a handle of sorts, that needs to be turned into a pointer with a
LocalLock or GlobalLock function.
There are very specific scenarios that unfortunately require the use of some of these functions. The
first relates to clipboard operations. Putting some data on the clipboard requires using an HGLOBAL
handle returned from GlobalAlloc. Another scenario involves some APIs (especially security APIs),
some of which allocate some data to be returned to the caller. The caller often has to free the data
when it’s no longer needed with the LocalFree function.
In short, these functions should only be used when some constraint requires it. For all other cases,
use heap, C/C++, or Virtual APIs.
Other Heap Functions
There are a few more heap functions not covered by the previous sections. This section briefly
describes the functions and their uses.
Getting summary information for a certain heap is available with HeapSummary:
typedef struct _HEAP_SUMMARY {
DWORD cb;
SIZE_T cbAllocated;
SIZE_T cbCommitted;
SIZE_T cbReserved;
SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
BOOL HeapSummary(
_In_ HANDLE hHeap,
_In_ DWORD dwFlags,
_Out_ PHEAP_SUMMARY lpSummary);
Before calling HeapSummary, initialize the cb member to the size of the structure. The members of
HEAP_SUMMARY are as follows:
• cbAllocated is the number of bytes currently allocated (actively used) on the heap.
• cbCommitted is the number of bytes currently committed on the heap.
• cbReserved is the reserved memory size to which the heap can grow.
• cbMaxReserve is the same as cbReserved in the current implementation.
The HeapSize function allows querying the size of an allocated block:

Chapter 13: Working With Memory
33
SIZE_T HeapSize(
_In_ HANDLE hHeap,
_In_ DWORD dwFlags,
_In_ LPCVOID lpMem);
The only valid flag is HEAP_NO_SERIALIZE. The lpMem pointer must be one that was returned earlier
from HeapAlloc or HeapReAlloc.
A heap that is created without HEAP_NO_SERIALIZE maintains a critical section (lock) to prevent heap
corruption in case of concurrent access. The HeapLock and HeapUnlock allow acquiring and releasing
the heap’s critical section:
BOOL HeapLock(_In_ HANDLE hHeap);
BOOL HeapUnlock(_In_ HANDLE hHeap);
This could be used to speed up multiple operations that can be invoked without taking the lock. One
such operation that can be used for debugging purposes is walking the heap blocks with HeapWalk:
BOOL HeapWalk(
_In_ HANDLE hHeap,
_Inout_ LPPROCESS_HEAP_ENTRY lpEntry);
A heap enumeration works by writing a loop that returns structures of type PROCESS_HEAP_ENTRY:
typedef struct _PROCESS_HEAP_ENTRY {
PVOID lpData;
DWORD cbData;
BYTE cbOverhead;
BYTE iRegionIndex;
WORD wFlags;
union {
struct {
HANDLE hMem;
DWORD dwReserved[ 3 ];
} Block;
struct {
DWORD dwCommittedSize;
DWORD dwUnCommittedSize;
LPVOID lpFirstBlock;
LPVOID lpLastBlock;
} Region;
} DUMMYUNIONNAME;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;

Chapter 13: Working With Memory
34
A heap enumeration starts by allocating a PROCESS_HEAP_ENTRY instance and setting its lpData to
NULL. Each call to HeapWalk gets back data for the next allocated block on the heap. The enumeration
ends when HeapWalk returns FALSE. Check out the documentation for a detailed description of the
various fields.
Write a heap enumeration function that accepts a heap handle and display the various blocks
with their properties.
Heap enumeration with HeapWalk is only available for the current process. If such heap walking
is desired for other processes, the ToolHelp offer a flag for CreateToolhelp32Snapshot (TH32CS_-
SNAPHEAPLIST), which provides a way to enumerate heaps in a selected process (Heap32ListFirst,
Heap32ListNext), and go further with enumerating blocks in each heap (Heap32First, Heap32Next).
When working with the heap, there may be two or more contiguous free memory blocks. Normally,
the heap automatically coalesces these adjacent free blocks. One of the global flags shown in figure
13-10 allows disabling this feature (called “Disable Heap Coalesce on Free”), to save some processing
time. In that case, you can call HeapCompact to force this coalescing to occur:
SIZE_T HeapCompact(
_In_ HANDLE hHeap,
_In_ DWORD dwFlags);
The only valid flag is HEAP_NO_SERIALIZE. The function coalesces free blocks if this was disabled,
and returns the largest block that can be allocated on the heap.
Finally, getting handles to all heaps in the current process is possible with GetProcessHeaps:
DWORD GetProcessHeaps(
_In_ DWORD NumberOfHeaps,
_Out_ PHANDLE ProcessHeaps);
The function accepts a maximum number of heap handles to return and an array of handles. It
returns the total number of heaps in the process. If the number is greater than NumberOfHeaps, then
not all heap handles have been returned. A simple way to get the number of heaps in the current
process is with this snippet:
DWORD heapCount = ::GetProcessHeaps(0, nullptr);

Chapter 13: Working With Memory
35
Other Virtual Functions
In this section, we’ll look at other functions from the Virtual family of APIs, except for the
VirtualQuery functions that are covered in chapter 12.
Memory Protection
Once a memory region is committed, the VirtualProtect* set of functions can be used to change
the page protection for a region of pages that are part of the same initial reserved region:
BOOL VirtualProtect(
_In_ LPVOID lpAddress,
_In_ SIZE_T dwSize,
_In_ DWORD flNewProtect,
_Out_ PDWORD lpflOldProtect);
BOOL VirtualProtectEx(
_In_ HANDLE hProcess,
_In_ LPVOID lpAddress,
_In_ SIZE_T dwSize,
_In_ DWORD flNewProtect,
_Out_ PDWORD lpflOldProtect);
BOOL VirtualProtectFromApp(
_In_ PVOID Address,
_In_ SIZE_T Size,
_In_ ULONG NewProtection,
_Out_ PULONG OldProtection);
As with VirtualAllocEx, VirtualProtectEx is able to perform the operation in a different process
context, assuming the process handle has the PROCESS_VM_OPERATION access mask. VirtualProtectFromApp
is the variant allowed to be called from a UWP process. As with VirtualAlloc, VirtualProtect
is implemented inline if the macro WINAPI_PARTITION_APP is defined (indicating an AppContainer
caller), by calling VirtualProtectFromApp.
The protection is changed for the address range spanning all pages between lpAddress and
lpAddress+dwSize, setting the new protection to flNewProtect (see chapter 12 for a list of the
possible protection attributes). The previous protection for the range of pages is returned via the
lpflOldProtect parameter (which cannot be NULL). If the span of pages had more than a single
protection value, the first one is returned.
Locking Memory
As we’ve seen already, committed memory that is part of a process’ working set is not guaranteed
to remain in the working set, but may be paged out. In some cases, a process might want to tell the

Chapter 13: Working With Memory
36
memory manager that a certain memory buffer should not be paged out, even if it’s not accessed
for a long time. The VirtualLock function can be used for this purpose, with VirtualUnlock being
the way to remove the locking:
BOOL VirtualLock(
_In_ LPVOID lpAddress,
_In_ SIZE_T dwSize);
BOOL VirtualUnlock(
_In_ LPVOID lpAddress,
_In_ SIZE_T dwSize);
The range of addresses for both functions is always rounded up to the nearest page boundaries, just
like any Virtual API. The maximum size a process can lock is a bit less than its minimum working
set size. If a larger block is to be locked, SetProcessWorkingSetSize(Ex) should be called to increase
the minimum (and probably the maximum) working set sizes. Of course, a process should be careful
not to lock too much memory because of the adverse effect it can have on other processes and the
system as a whole.
Memory Hint Functions
This section describes functions that are never absolutely necessary, but can be used to improve
performance in one respect or another, by giving the memory manager hints at the application’s use
of committed memory.
The OfferVirtualMemory function, introduced in Windows 8.1 (and Server 2012 R2), indicates to
the memory manager that a range of committed memory is no longer of interest, so the system can
discard the physical pages being used by that memory. The system should not bother writing the
data to a page file.
typedef enum OFFER_PRIORITY {
VmOfferPriorityVeryLow = 1,
VmOfferPriorityLow,
VmOfferPriorityBelowNormal,
VmOfferPriorityNormal
} OFFER_PRIORITY;
DWORD OfferVirtualMemory(
_Inout_ PVOID VirtualAddress,
_In_ SIZE_T Size,
_In_ OFFER_PRIORITY Priority);

Chapter 13: Working With Memory
37
The virtual address must be page-aligned, and the size must be a multiple of the page size.
At first it may seem that simply decommitting the memory (VirtualFree) has the same effect. From
the point of view of releasing RAM, it’s similar. But with VirtualFree, the application is giving
up the address range and the committed memory, so that a new allocation would be needed in
the future, which may or may not succeed; it’s also slower than just reusing an already existing
committed memory block.
The priority parameter specifies the importance of the memory region. The lowest the priority, the
more likely the physical memory will be discarded sooner rather than later. The function returns an
error code directly (no point in calling GetLastError), where ERROR_SUCCESS (0) indicates success.
Once the application is ready to use the offered memory again, it can reclaim it back with
ReclaimVirtualMemory:
DWORD ReclaimVirtualMemory(
_In_ void const* VirtualAddress,
_In_ SIZE_T Size);
The reclaimed memory may or may not have its previous contents. The application should assume
the memory is needs to be repopulated with meaningful data.
Another variant similar to OfferVirtualMemory is DiscardVirtualMemory:
DWORD DiscardVirtualMemory(
_Inout_ PVOID VirtualAddress,
_In_ SIZE_T Size);
DiscardVirtualMemory is equivalent to calling OfferVirtualMemory with the VmOfferPriorityVeryLow
priority.
The last function in this section is PrefetchVirtualMemory (available from Windows 8 and Server
2012):
typedef struct _WIN32_MEMORY_RANGE_ENTRY {
PVOID VirtualAddress;
SIZE_T NumberOfBytes;
} WIN32_MEMORY_RANGE_ENTRY, *PWIN32_MEMORY_RANGE_ENTRY;
BOOL PrefetchVirtualMemory(
_In_ HANDLE hProcess,
_In_ ULONG_PTR NumberOfEntries,
_In_ PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses,
_In_ ULONG Flags);

Chapter 13: Working With Memory
38
The purpose of PrefetchVirtualMemory is to allow an application to optimize I/O usage for reading
data from discontiguous blocks of memory that the process is fairly confident it’s going to use.
The caller provides the committed memory blocks (using an array of WIN32_MEMORY_RANGE_ENTRY
structures), and the memory manager uses concurrent I/O with large buffers to fetch the data quicker
than it would if the pages were to be accessed normally. This function is never necessary, it’s merely
an optimization.
Writing and Reading Other Processes
Normally processes are protected from one another, but one process can read and/or write to
another’s process address space given strong enough handles. Here are the functions to use:
BOOL ReadProcessMemory(
_In_ HANDLE hProcess,
_In_ LPCVOID lpBaseAddress,
_Out_ LPVOID lpBuffer,
_In_ SIZE_T nSize,
_Out_opt_ SIZE_T* lpNumberOfBytesRead);
BOOL WriteProcessMemory(
_In_ HANDLE hProcess,
_In_ LPVOID lpBaseAddress,
_In_ LPCVOID lpBuffer,
_In_ SIZE_T nSize,
_Out_opt_ SIZE_T* lpNumberOfBytesWritten);
ReadProcessMemory requires a handle with PROCESS_VM_READ access mask, while WriteProcessMemory
requires PROCESS_VM_WRITE access mask. lpBaseAddress is the address in the target process to
read/write. lpBuffer is the local buffer to read to or write from. nSize is the size of the buffer to
read/write. Finally, the last optional parameter returns the number of bytes actually read or written.
Even with the process access mask, these functions may fail because of incompatible page protection.
For example, WriteProcessMemory fails to write to pages protected with PAGE_READONLY. Of course,
the caller could try to change the protection with VirtualProtectEx.
The primary user of these functions are debuggers. A debugger must be able to read information
from the debugged process, such as local variables, threads’ stack, etc. Similarly, a debugger allows
its user to make changes to data in the debugged process. There are other uses for these functions,
however. We’ll use one example for WriteProcessMemoey in chapter 15 to help inject a DLL into a
target process.

Chapter 13: Working With Memory
39
Large Pages
Windows supports two basic page sizes, small and large (with a third huge page size described in an
upcoming aside). Table 12-1 shows the sizes of pages, where small pages are 4 KB on all architectures,
and large pages are 2 MB on all but ARM architecture, where it’s 4 MB. The VirtualAlloc family of
functions support allocation using large pages with the MEM_LARGE_PAGE flag. What are the benefits
of using large pages?
• Large pages perfrom better internally because the translation of virtual to physical addresses
do not page tables (only page directories, see the “Windows Internals” book). This also makes
the Translation Lookaside Buffer (TLB) CPU cache more effective - a single entry maps 2 MB
rather than just 4 KB.
• Large pages are always non-pageable (never paged out to disk).
Large pages come with a few downsides, however:
• Large pages cannot be shared between processes.
• Large page allocations must be an exact multiple of a large page size.
• Large page allocations may fail if physical memory is too fragmented.
There is yet another important caveat - since large pages are always non-pageable, using large
pages requires the SeLockMemoryPrivilege privilege, normally given to no user, including the
Administrators group. Figure 13-11 shows the Local Security Policy tool showing the list of privileges,
where the “Lock Pages in Memory” privilege is shown with no users or groups assigned.

Chapter 13: Working With Memory
40
Figure 13-11: Local Security Policy privileges window
There are two ways to get the required privilege:
• An administrator can add users/group to have this privilege. The next time such a user logs off
and logs on again, the privilege will be part of its access token.
• A service running under the Local System account can request any privilege it desires. (Services
are described in chapter 19, along with this capability).
The large page size on a system can be queried with GatLargePageMinimum. This is important since
large page allocations must be done in mutiples of large page size:
SIZE_T GetLargePageMinimum();
Huge Pages
Modern processors support a third page size, huge page, 1 GB in size. The benefits of huge pages is
essentially the same as for large pages, with even better use of the TLB cache. There is no flag for
VirtualAlloc to use huge pages. Instead, when large page allocations occur, if the size is at least 1
GB, the system tries to locate huge pages first, and then use large pages for the remainder. If huge

Chapter 13: Working With Memory
41
pages cannot be obtained (since that requires contigous 1 GB chunks in physical memory), large
pages will be used.
Having the SeLockMemoryPrivilege privilege is not enough - it must be enabled as well. This is easy
enough to do with a function very similar to the one used in chapter 3 to enable the Debug privilege
(a detailed discusstion of this code is saved for chapter 16):
bool EnableLockMemoryPrivilege() {
HANDLE hToken;
if (!::OpenProcessToken(::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
return false;
bool result = false;
TOKEN_PRIVILEGES tp;
tp.PrivilegeCount = 1;
tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
if (::LookupPrivilegeValue(nullptr, SE_LOCK_MEMORY_NAME,
&tp.Privileges[0].Luid)) {
if (::AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp),
nullptr, nullptr))
result = ::GetLastError() == ERROR_SUCCESS;
}
::CloseHandle(hToken);
return result;
}
Now using large pages is no different than using normal pages except for the MEM_LARGE_PAGE flag:
if (!EnableLockMemoryPrivilege()) {
printf("Failed to enable privilege\n");
return 1;
}
auto largePage = ::GetLargePageMinimum();
// allocate 5 large pages
auto p = ::VirtualAlloc(nullptr, 5 * largePage,
MEM_RESERVE | MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
if (p) {
// success - use memory
}
else {

Chapter 13: Working With Memory
42
printf("Error: %u\n", ::GetLastError());
}
// free memory
::VirtualFree(p, 0, MEM_RELEASE);
Address Windowing Extensions
In the early days of Windows NT, the system supported no more than 4 GB of physical memory,
which was the maximum processors Windows ran on supported at the time. Starting with the Intel
Pentium Pro, more than 4 GB of physical memory were supported on 32-bit systems (64 bit was not
around at the time). Applications that wanted to utilize the extra physical memory beyond 4 GB
had to use a special API called Address Windowing Extensions (AWE) - the usage of any physical
memory above 4 GB was not “automatic”.
The AWE allows a process to allocate directly physical pages, and then map them to their address
space. Since the amount of physical memory allocated could be larger than can fit in a 32-bit address
space, the application can map a “window” into this memory, use the memory, unmap the window,
and map a new window at another offset.
This mechanism is awkward and was used very little in practice. The only well-known application
that used AWE to gain the advantages of large memory on 32-bit systems was SQL Server.
Since using AWE means the application is allocating physical pages, the SeLockMemoryPrivilege
privilege is required, just like with large pages.
Here is an example that uses AWE to allocate and use physical pages:
EnableLockMemoryPrivilege();
ULONG_PTR pages = 1000;
// pages
ULONG_PTR parray[1000];
// opaque array (PFNs)
if (!::AllocateUserPhysicalPages(::GetCurrentProcess(), &pages, parray))
return ::GetLastError();
if (pages < 1000)
printf("Only allocated %zu pages\n", pages);
// access the first 200 pages at most
auto usePages = min(pages, 200);
// reserve memory region for mapping physical pages

Chapter 13: Working With Memory
43
void* pWindow = ::VirtualAlloc(nullptr, usePages << 12, MEM_RESERVE | MEM_PHYSICAL,
PAGE_READWRITE);
// read/write is the only valid value
if (!pWindow)
return ::GetLastError();
// map pages to the process address space
if (!::MapUserPhysicalPages(pWindow, usePages, parray))
return ::GetLastError();
// use the memory...
::memset(pWindow, 0xff, usePages << 12);
// cleanup
::FreeUserPhysicalPages(::GetCurrentProcess(), &pages, parray);
::VirtualFree(pWindow, 0, MEM_RELEASE);
return 0;
AWE allocated pages are non pageable and must be protected with PAGE_READWRITE - no other value
is supported.
32-bit processes runing on 64-bit Windows (WOW64) cannot use AWE functions.
AWE is rarely used today, because on 64-bit systems (the norm), any amount of physical memory is
accessible without any special API usage, although normal memory usage does not guarantee it will
always be resident. The awkwardness of AWE and the fact it requires the SeLockMemoryPrivilege
privilege makes it almost useless.
NUMA
Non Uniform Memory Architecture (NUMA) systems involve a set of nodes, each one holding a set
of processors and memory. Figure 13-12 shows an example topoly of such a system.

Chapter 13: Working With Memory
44
Figure 13-12: A NUMA system
Figure 13-12 shows an example of a system with two NUMA nodes. Each node holds a socket with
4 cores and 8 logical processors. NUMA systems are still symmetric in the sense that any CPU can
run any code and access any memory in any node. However, accessing memory from a the local
node is considerably faster than accessing memory in another node.
Windows is aware of a NUMA system’s topoly. With thread scheduling discussed in chapter 6, the
scheduler makes good use of this information, and tries to schedule threads on CPUs where the
thread’s stack is in that node’s physical memory.
NUMA systems are common for server machines, where multiple sockets typically exist. Getting
the NUMA topoly information involves several API calls. The number of NUMA nodes on a system
is availbale (somewhat indirectly) with GetNumaHighestNodeNumber:
BOOL GetNumaHighestNodeNumber(_Out_ PULONG HighestNodeNumber);
The function provides the highest NUMA node on the system, where 0 means it’s not a NUMA
system. On a two-node system,
*HighestNodeNumber is set to 1 on return.
For each node, the process affinity mask (the processors connected to a node) is available with
GetNumaNodeProcessorMaskEx:
BOOL GetNumaNodeProcessorMaskEx(
_In_ USHORT Node,
_Out_ PGROUP_AFFINITY ProcessorMask);
The processors connected to a specific node can be retrieved with GetNumaNodeProcessorMask or
GetNumaNodeProcessorMaskEx:

Chapter 13: Working With Memory
45
BOOL GetNumaNodeProcessorMask(
_In_
UCHAR Node,
_Out_ PULONGLONG ProcessorMask);
BOOL GetNumaNodeProcessorMaskEx(
_In_ USHORT Node,
_Out_ PGROUP_AFFINITY ProcessorMask
);
GetNumaNodeProcessorMask is sutiable for systems with less than 64 processors (it returns the process
mask in the group this node is part of), but GetNumaNodeProcessorMaskEx can handle any number
of processors by returning a GROUP_AFFINITY structure that combines a processor group and a bit
mask of processors (see chapter 6 for more on process groups):
typedef struct _GROUP_AFFINITY {
KAFFINITY Mask;
WORD
Group;
WORD
Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;
The amount of available physical memory in a node is available with GetNumaAvailableMemoryNodeEx.
This can be used as a hint when allocating memory and targeting a specific node:
BOOL GetNumaAvailableMemoryNodeEx(
_In_
USHORT Node,
_Out_ PULONGLONG AvailableBytes);
The following function shows NUMA node information using the above functions:
void NumaInfo() {
ULONG highestNode;
::GetNumaHighestNodeNumber(&highestNode);
printf("NUMA nodes: %u\n", highestNode + 1);
GROUP_AFFINITY group;
for (USHORT node = 0; node <= (USHORT)highestNode; node++) {
::GetNumaNodeProcessorMaskEx(node, &group);
printf("Node %d:\tProcessor Group: %2d, Affinity: 0x%08zX\n",
(int)node, group.Group, group.Mask);
ULONGLONG bytes;
::GetNumaAvailableMemoryNodeEx(node, &bytes);
printf("\tAvailable memory: %llu KB\n", bytes >> 10);
}
}
Here is an example run (2 nodes, 8 total processors):

Chapter 13: Working With Memory
46
NUMA nodes: 2
Node 0: Processor Group:
0, Affinity: 0x0000000F
Available memory: 3567936 KB
Node 1: Processor Group:
0, Affinity: 0x000000F0
Available memory: 3283832 KB
The VirtualAlloc function lets the system decide where the physical memory for committed
memory should come from. If you want to select a preferred NUMA node, call VirtualAllocExNuma:
LPVOID VirtualAllocExNuma(
_In_ HANDLE hProcess,
_In_opt_ LPVOID lpAddress,
_In_ SIZE_T dwSize,
_In_ DWORD flAllocationType,
_In_ DWORD flProtect,
_In_ DWORD nndPreferred);
The function is identical to VirtualAllocEx, but adds a preferred NUMA node number as its last
parameter. The provided NUMA node has effect only when the initial memory block is reserved or
reserved and committed. Further manipulations of the same memory region disregard the NUMA
node parameter, and it’s much easier to continue working with VirtualAlloc(Ex).
Here is an example that uses the above NumaInfo function twice, where some memory is committed
(and forced into RAM) between calls:
NumaInfo();
auto p = ::VirtualAllocExNuma(::GetCurrentProcess(), nullptr, 1 << 30,
// 1 GB
MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE, 1);
// node 1
// touch memory
::memset(p, 0xff, 1 << 30);
NumaInfo();
::VirtualFree(p, 0, MEM_RELEASE);
Here is an example output:

Chapter 13: Working With Memory
47
NUMA nodes: 2
Node 0: Processor Group:
0, Affinity: 0x0000000F
Available memory: 3587332 KB
Node 1: Processor Group:
0, Affinity: 0x000000F0
Available memory: 3287952 KB
NUMA nodes: 2
Node 0: Processor Group:
0, Affinity: 0x0000000F
Available memory: 3584884 KB
Node 1: Processor Group:
0, Affinity: 0x000000F0
Available memory: 2243764 KB
Notice the reduced amount of physical memory on node 1.
Testing NUMA-related code is problematic on non-NUMA systems, as there is just one node.
One way to get around this is to use a virtualization technology, such as Hyper-V, to simulate
NUMA nodes. For Hyper-V, a virtual machine’s settings in the CPU node can be used to
configure NUMA nodes (note that you must disable Dynamic Memory to make this work).
The VirtualAlloc2 Function
The VirtualAlloc2 function, introduced in Windows 10 version 1803 (RS4), as a possible replace-
ment for the various other VirtualAlloc variants. It combines the power of all of them, so that a
single call can use a different process than the current one, a preferred NUMA node, specific memory
alignment, AWE and a selected memory partition (a semi-documented entity beyond the scope of
this book). Its prototype is as follows:
PVOID VirtualAlloc2(
_In_opt_ HANDLE Process,
_In_opt_ PVOID BaseAddress,
_In_ SIZE_T Size,
_In_ ULONG AllocationType,
_In_ ULONG PageProtection,
_Inout_ MEM_EXTENDED_PARAMETER* ExtendedParameters,
_In_ ULONG ParameterCount);
The first 5 parameters are identical to VirtualAllocEx. The last two parameters are an optional array
of MEM_EXTENDED_PARAMETER structures, each one specifiying some extra attribute related to the call.
The number of such structures is provided by the last parameter. Here is what MEM_EXTENDED_-
PARAMETER looks like:

Chapter 13: Working With Memory
48
typedef struct DECLSPEC_ALIGN(8) MEM_EXTENDED_PARAMETER {
struct {
DWORD64 Type : MEM_EXTENDED_PARAMETER_TYPE_BITS;
DWORD64 Reserved : 64 - MEM_EXTENDED_PARAMETER_TYPE_BITS;
} DUMMYSTRUCTNAME;
union {
DWORD64 ULong64;
PVOID Pointer;
SIZE_T Size;
HANDLE Handle;
DWORD ULong;
} DUMMYUNIONNAME;
} MEM_EXTENDED_PARAMETER, *PMEM_EXTENDED_PARAMETER;
This structure is really a union where just one member is valid, based on the Type member, which
is an enumeration selecting the valid member inside the union:
typedef enum MEM_EXTENDED_PARAMETER_TYPE {
MemExtendedParameterInvalidType = 0,
MemExtendedParameterAddressRequirements,
MemExtendedParameterNumaNode,
MemExtendedParameterPartitionHandle,
MemExtendedParameterUserPhysicalHandle,
MemExtendedParameterAttributeFlags,
MemExtendedParameterMax
} MEM_EXTENDED_PARAMETER_TYPE;
For example, setting a preferred NUMA node similar to the example given in the section “NUMA”
can be accomplished with VirtualAlloc2 like so:
MEM_EXTENDED_PARAMETER param = { 0 };
param.Type = MemExtendedParameterNumaNode;
param.ULong = 1;
// NUMA node
auto p = ::VirtualAlloc2(::GetCurrentProcess(), // NULL also works for current proce\
ss
nullptr, 1 << 30,
MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE,
&param, 1);
Consult the documentation for some more examples.

Chapter 13: Working With Memory
49
Sumamry
In this chapter, we examined the various APIs provided by Windows for allocating and otherwise
managing memory. Memory is one of the fundamental resources in a computer system, where almost
everything else is mapped to memory usage in one way or another.
In the next chapter, we’ll dive into Memory Mapped Files and their capabilities of mapping files to
memory and sharing memory between processes.

Chapter 14: Memory Mapped Files
A Memory Mapped File, called Section in kernel terminology, is an object that provides the ability
to seamlessly map a file’s contents to memory. Additionally, it can be used to share memory
efficiently between processes. These capabilities provides several benefits, which will be explored
in this chapter.
In this chapter:
• Introduction
• Mapping Files
• Sharing Memory
• The Micro Excel 2 Application
• Other Memory Mapping Functions
• Data Coherence
Introduction
File mapping objects are everywhere in Windows. When an image file (EXE or DLL) is loaded, it’s
mapped to memory using memory-mapped files. With this mapping, access to the underlying file is
done indirectly, by accessing memory through standard pointers. When code needs to execute within
the image, the initial access causes a page fault exception, which the memory manager takes care of
by reading the data from the file and placing it in physical memory, before fixing the appropriate
page tables used to map this memory, at which point the calling thread can access the code/data.
This is all transparent to the application.
In chapter 11 we looked at various I/O related APIs to read and/or write data, such as ReadFile and
WriteFile. Imagine that some code needs to search a file for some data, and that search requires
going back and forth in the file. With I/O APIs, this is inconvenient at best, involving multiple calls
to ReadFile (with a buffer allocated beforehand) and SetFilePointer(Ex). On the other hand, if a
“pointer” to the file was available, then moving and performing operations with the file is much
easier: no buffers to allocate, no ReadFile calls, and any file pointer changes just translate to pointer
arithmetic. All other common memory functions, such as memcpy, memset, etc. work just as well with
memory-mapped files.

Chapter 14: Memory Mapped Files
51
Mapping Files
The steps required to map an existing file is first to open it with a normal CreateFile call. The access
mask to CreateFile must be appropriate to the access required to the file, such as read and/or write.
Once such a file is open, calling CreateFileMapping creates the file mapping object where the file
handle can be provided:
HANDLE CreateFileMapping(
_In_ HANDLE hFile,
_In_opt_ LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
_In_ DWORD flProtect,
_In_ DWORD dwMaximumSizeHigh,
_In_ DWORD dwMaximumSizeLow,
_In_opt_ LPCTSTR lpName);
The first parameter to CreateFileMapping is a file handle. If this MMF object is to be map a file,
then a valid file handle should be provided. If the file mapping object is going to be used for creating
shared memory backed up by a page file, then INVALID_HANDLE_VALUE should be specified, indicating
page file usage. We’ll examine shared memory not backed up by a specific file later in this chapter.
Next, the standard SECURITY_ATTRIBUTES pointer can be set, typically to NULL. The flProtect
parameter indicates what page protection should be used when physical storage is (later) used for
this file mapping object. This should be the most permissive page protection that is needed later.
Common examples are PAGE_READWRITE and PAGE_READONLY. Table 14-1 summarizes the valid values
for flProtect and the corresponding valid values when creating/opening the file used with the file
mapping object.
Table 14-1: Protection flags for CreateFileMapping
MMF protection flag
Minimum access flags for the file
Comments
PAGE_READONLY
GENERIC_READ
Writing to memory/file is not
permitted
PAGE_READWRITE
GENERIC_READ and GENERIC_WRITE
PAGE_WRITECOPY
GENERIC_READ
Equivalent to PAGE_READONLY
PAGE_EXECUTE_READ
GENERIC_READ and GENERIC_EXECUTE
PAGE_EXECUTE_READWRITE
GENERIC_READ, GENERIC_WRITE and
GENERIC_EXECUTE
PAGE_EXECUTE_WRITECOPY
GENERIC_READ and GENERIC_EXECUTE
Equivalent to PAGE_EXECUTE_READ
One of the values in table 14-1 can be combined with some flags, described below (there are more
flags, but the list is of the officially documented ones):
• SEC_COMMIT - for page-file backed MMF only (hFile is INVALID_HANDLE_VALUE), indicates that
all mapped memory must be committed when a view is mapped into the process address. This

Chapter 14: Memory Mapped Files
52
flag is mutually exclusive with SEC_RESERVE, and is the default if neither is specified. In any
case, it has no effect for MMF backed up by a specific file.
• SEC_RESERVE - the opposite of SEC_COMMIT. Any view is initially reserved, so that the actual
committing must be performed explicitly with VirtalAlloc call(s).
• SEC_IMAGE - specifies that the file provided is a PE file. It should be combined with PAGE_-
READONLY protection, but the mapping is done according to the sections in the PE. This flag
cannot be combined with any other flag.
• SEC_IMAGE_NO_EXECUTE - similar to SEC_IMAGE, but the PE is not intended for execution, just
mapping.
• SEC_LARGE_PAGES - valid for page-file backed MMF only. Indicates the usage of large pages
when mapped. This requires the SeLockMemoryPrivilege as described in chapter 13. It also
requires any view into the MMF and the view size to be multiple of the large page size. This
flag must be combined with SEC_COMMIT.
• SEC_NOCACHE and SEC_WRITECOMBINE - rarely used flags, typically because a device driver
requires it for proper operation.
The next two parameters to CreateFileMapping specify the MMF size using two 32-bit values that
should be treated as a 64-bit value. If the MMF is to map an existing file with read-only access, set
both values to zero, which effectively set the size of the MMF to the size of the file.
If the file in question is to be written to, set the size to the maximum size of the file. Once set, the
file cannot grow beyond this size, and in fact its size will immediately grow to the specified size. If
the MMF is backed by a page file, then the size indicates the sized of the memory block, where the
page files in the system must be able to accommodate at MMF creation time.
The final parameter to CreateFileMapping is the object’s name. It can be NULL, or it can be named,
just like other named object types (e.g. events, semaphores, mutexes). Given a name, it’s easy to
share the object with other processes. Finally, the function returns a handle to the memory-mapped
file object, or NULL in case of failure.
The following example creates a memory-mapped file object based on a data file, for read access
only (error handling omitted):
HANDLE hFile = ::CreateFile(L"c:\\mydata.dat", GENERIC_READ, FILE_SHARE_READ,
nullptr, OPEN_EXISTING, 0, nullptr);
HANDLE hMemFile = ::CreateFileMapping(hFile, nullptr,
PAGE_READONLY, 0, 0, nullptr);
::CloseHandle(hFile);
The last line may be alarming. Is it OK to close the file handle? Wouldn’t that close the file, making
it inaccessible by the file mapping object? As it turns out, the MMF cannot rely on the client to keep
the file handle open long enough, and it duplicates it to make sure the file is not closed. This means
closing the file handle is the right thing to do.
Once a memory-mapped file object is created, the process can use the returned handle to map all or
part of the file’s data into its address space, by calling MapViewOfFile:

Chapter 14: Memory Mapped Files
53
LPVOID MapViewOfFile(
_In_ HANDLE hFileMappingObject,
_In_ DWORD dwDesiredAccess,
_In_ DWORD dwFileOffsetHigh,
_In_ DWORD dwFileOffsetLow,
_In_ SIZE_T dwNumberOfBytesToMap);
MapViewOfFile takes the MMF handle and maps the file (or part of it) into the process address space.
dwDesiredAccess can be a combination of one or more flags described in table 14-2.
Table 14-2: Mapping flags for MapViewOfFile
Desired access
Description
FILE_MAP_READ
map for read access
FILE_MAP_WRITE
map for write access
FILE_MAP_EXECUTE
map for execute access
FILE_MAP_ALL_ACCESS
equivalent to FILE_MAP_WRITE when used with MapViewOfFile
FILE_MAP_COPY
copy-on-write access. Any write gets a private copy, that is discarded when
the view is unmapped
FILE_MAP_LARGE_PAGES
maps using large pages
FILE_MAP_TARGETS_INVALID
sets all locations in the view as invalid targets for Control Flow Guard
(CFG). The default is that the view is a valid target for CFG (see chapter 16
for more on CFG)
The dwFileOffsetHigh and dwFileOffsetLow form the 64-bit offset from which to begin mapping.
The offset must be a multiple of the allocation granularity (64 KB on all Windows versions and
architectures). The last parameter, dwNumberOfBytesToMap specifies how many bytes to map starting
from the offset. Setting this to zero maps to the end of the file mapping.
The function returns the virtual address of the mapped memory in the caller’s address space. The
caller can use the pointer with all standard memory operations (subject to the mapping constraints).
Once the mapped view is no longer needed, it should be unmapped with UnmapViewOfFile:
BOOL UnmapViewOfFile(_In_ LPCVOID lpBaseAddress);
lpBaseAddress is the same value returned from MapViewOfFile. Once unmapped, the memory
pointed by lpBaseAddress is no longer valid, and any access causes an access violation.
The filehist Application
The command line application filehist (File Histogram) counts the number of occurrences of each
byte (0 to 255) in a file, effectively building a histogram distribution of the byte values in the file.
The application is built by using a memory-mapped file, so that views are mapped into the process
address space and then the values are accessed with normal pointers. The application can deal with

Chapter 14: Memory Mapped Files
54
files of any size, but mapping limited views into the process address space, processing the data,
unmapping, and then mapping the next chunk in the file.
Running the application with no arguments shows the following:
C:\>filehist.exe
Usage:
filehist [view size in MB] <file path>
Default view size is 10 MB
The view size is configurable, where the default is 10 MB (no special reason for this value). Here is
an example with a large file and the default view size:
C:\>filehist.exe file1.dat
File size: 938857496 bytes
Using view size: 10 MB
Mapping offset: 0x0, size: 0xA00000 bytes
Mapping offset: 0xA00000, size: 0xA00000 bytes
Mapping offset: 0x1400000, size: 0xA00000 bytes
Mapping offset: 0x1E00000, size: 0xA00000 bytes
...
Mapping offset: 0x36600000, size: 0xA00000 bytes
Mapping offset: 0x37000000, size: 0xA00000 bytes
Mapping offset: 0x37A00000, size: 0x55D418 bytes
0xB3:
445612 ( 0.05 %)
0x9E:
460881 ( 0.05 %)
0x9F:
469939 ( 0.05 %)
0x9B:
496322 ( 0.05 %)
0x96:
546899 ( 0.06 %)
0xB5:
555019 ( 0.06 %)
...
0x0F:
11226199 ( 1.20 %)
0x7F:
11755158 ( 1.25 %)
0x01:
14336606 ( 1.53 %)
0x8B:
14824094 ( 1.58 %)
0x48:
20481378 ( 2.18 %)
0xFF:
72242071 ( 7.69 %)
0x00:
342452879 (36.48 %)
The value zero is clearly the dominant one. If we increase the view size to 400 MB, this is what we
get:

Chapter 14: Memory Mapped Files
55
C:\>filehist.exe 400 file1.dat
File size: 938857496 bytes
Using view size: 400 MB
Mapping offset: 0x0, size: 0x19000000 bytes
Mapping offset: 0x19000000, size: 0x19000000 bytes
Mapping offset: 0x32000000, size: 0x5F5D418 bytes
0xB3:
445612 ( 0.05 %)
0x9E:
460881 ( 0.05 %)
...
0x48:
20481378 ( 2.18 %)
0xFF:
72242071 ( 7.69 %)
0x00:
342452879 (36.48 %)
The first thing done in main is process some of the command line arguments:
int wmain(int argc, const wchar_t* argv[]) {
if (argc < 2) {
printf("Usage:\tfilehist [view size in MB] <file path>\n");
printf("\tDefault view size is 10 MB\n");
return 0;
}
DWORD viewSize = argc == 2 ? (10 << 20) : (_wtoi(argv[1]) << 20);
if (viewSize == 0)
viewSize = 10 << 20;
Next, we need an array where the values and counts are stored:
struct Data {
BYTE Value;
long long Count;
};
Data count[256] = { 0 };
for (int i = 0; i < 256; i++)
count[i].Value = i;
Now we can open the file, get its size, and create a file mapping object pointing to that file:

Chapter 14: Memory Mapped Files
56
HANDLE hFile = ::CreateFile(argv[argc - 1], GENERIC_READ, FILE_SHARE_READ,
nullptr, OPEN_EXISTING, 0, nullptr);
if (hFile == INVALID_HANDLE_VALUE)
return Error("Failed to open file");
LARGE_INTEGER fileSize;
if (!::GetFileSizeEx(hFile, &fileSize))
return Error("Failed to get file size");
HANDLE hMapFile = ::CreateFileMapping(hFile, nullptr, PAGE_READONLY, 0, 0, nullptr);
if (!hMapFile)
return Error("Failed to create MMF");
::CloseHandle(hFile);
The file is opened for read-only access, since there is no intention of changing anything in the file.
The MMF is opened with PAGE_READONLY access, compatible with the file’s GENERIC_READ access.
Next we need to loop a number of times, depending on the file size and selected view size and
process the data:
auto total = fileSize.QuadPart;
printf("File size: %llu bytes\n", fileSize.QuadPart);
printf("Using view size: %u MB\n", (unsigned)(viewSize >> 20));
LARGE_INTEGER offset = { 0 };
while (fileSize.QuadPart > 0) {
auto mapSize = (unsigned)min(viewSize, fileSize.QuadPart);
printf("Mapping offset: 0x%llX, size: 0x%X bytes\n", offset.QuadPart, mapSize);
auto p = (const BYTE*)::MapViewOfFile(hMapFile, FILE_MAP_READ,
offset.HighPart, offset.LowPart, mapSize);
if (!p)
return Error("Failed in MapViewOfFile");
// do the work
for (DWORD i = 0; i < mapSize; i++)
count[p[i]].Count++;
::UnmapViewOfFile(p);
offset.QuadPart += mapSize;
fileSize.QuadPart -= mapSize;
}

Chapter 14: Memory Mapped Files
57
::CloseHandle(hMapFile);
As long as there are still bytes to process, MapViewOfFile is called to map a portion of the file from
the current offset with the minimum of the view size and the bytes left to process. After processing
the data, the view is unmapped, the offset incremented, the remaining bytes decremented, and the
loop repeats.
The final act is displaying the results. The data array is first sorted by the count, and then everything
is displayed in order:
// sort by ascending order
std::sort(std::begin(count), std::end(count),
[](const auto& c1, const auto& c2) {
return c2.Count > c1.Count;
});
// display results
for (const auto& data : count) {
printf("0x%02X: %10llu (%5.2f %%)\n", data.Value, data.Count,
data.Count * 100.0 / total);
}
Static C++ arrays can be sorted with std::sort just like vectors. The global std::begin and
std::end functions are needed to provide iterators for arrays because there are no methods
in C++ arrays.
Sharing Memory
Processed are isolated from one another, so that each has its own address space, its own handle
table, etc. Most of the time, this is what we want. However, there are cases where data needs to
be shared in some way between processes. Windows provides many mechanisms for Interprocess
Communication (IPC), including the Component Object Model (COM), Windows messages, sockets,
pipes, mailslots, Remote Procedure Calls (RPC), clipboard, Dynamic Data Exchange (DDE) and more.
Each has its strengths and weaknesses, but the common theme for all the above is that memory must
be copied from one process to another.
Memory-mapped files are yet another mechanism for IPC, and it’s the fastest of them all because
there is no copying going around (in fact, some of the other IPC mechanisms use memory-mapped
files under the covers when communicating between processes on the same machine). One process
writes the data to the shared memory, and all other processes that have handles to the same file

Chapter 14: Memory Mapped Files
58
mapping object can see the memory immediately - there is no copying going around because each
process maps the same memory into its own address space.
Sharing memory is based on multiple processes having access to the same file mapping object. The
object can be shared in any of the three ways described in chapter 2. The simplest is to use a name
for the file mapping object. The shared memory itself can be backup up by a specific file (valid file
handle to CreateFileMapping), in which case the data is available even after the file mapping object
is destroyed, or backuped up by the paging file, in which case the data is discarded once the file
mapping object is destroyed. Both options work essentially in the same way.
We’ll start by using the Basic Sharing application from chapter 2. There we looked at sharing
capabilities based on an object’s name, but now we can dig into the details of sharing itself. Figure
14-1 shows two instances of the application running, where writing in one process and reading in
another process shows the same data since these use the same file mapping object.
Figure 14-1: Multiple instance of Basic Sharing
In CMainDlg::OnInitDialog the file mapping object is created, backuped up by the page file:
m_hSharedMem = ::CreateFileMapping(INVALID_HANDLE_VALUE, nullptr,
PAGE_READWRITE, 0, 1 << 12, L"MySharedMemory");
The MMF is created for read/write access and its size is 4 KB. Its name (“MySharedMemory”) is going
to be the method used for sharing the object with other processes. The first time CreateFileMapping
is called with that object name, the object is created. Any subsequent calls using the same name just
get a handle to the already existing file mapping object. This means the other parameters are not
really used. For example, a second caller cannot specify a different size for the memory - the initial
creator determines the size.
Alternatively, a process may want to open a handle to an existing file mapping object and fail if it
does not exist. This is the role of OpenFileMapping:
HANDLE OpenFileMapping(
_In_ DWORD dwDesiredAccess,
_In_ BOOL bInheritHandle,
_In_ LPCTSTR lpName);
The desired access parameter is a combination of access masks from table 14-2. bInheritHandle
specifies whether the returned handle is inheritable or not (see chapter 2 for more on handle

Chapter 14: Memory Mapped Files
59
inheritance). Finally, lpName is the named MMF to locate. The function fails if the there is no file
mapping object with the given name (returning NULL).
In most cases, using CreateFileMapping is more convenient, especially if sharing is intended by
multiple processes based off the same executable image - the first process creates the object and all
subsequent processes just get handles to the existing object - no need to synchronize creation vs.
opening.
With a file mapping object handle in place, writing to the memory is done by the following function:
LRESULT CMainDlg::OnWrite(WORD, WORD, HWND, BOOL &) {
void* buffer = ::MapViewOfFile(m_hSharedMem, FILE_MAP_WRITE, 0, 0, 0);
if (!buffer) {
AtlMessageBox(m_hWnd, L"Failed to map memory", IDR_MAINFRAME);
return 0;
}
CString text;
GetDlgItemText(IDC_TEXT, text);
::wcscpy_s((PWSTR)buffer, text.GetLength() + 1, text);
::UnmapViewOfFile(buffer);
return 0;
}
The call to MapViewOfFile is not much different than the call from the filehist application. FILE_-
MAP_WRITE is used to gain write access to the mapped memory. The offset is zero and the mapping
size is specified as zero as well, which means mapping all the way to the end. Since the shared
memory is only 4 KB in size, that’s not an issue, and in any case everything is rounded up to the
nearest page boundary. After the data is written, UnmapViewOfFile is called to unmap the view from
the process address space.
Reading data is very similar, just using different flags for access:
LRESULT CMainDlg::OnRead(WORD, WORD, HWND, BOOL &) {
void* buffer = ::MapViewOfFile(m_hSharedMem, FILE_MAP_READ, 0, 0, 0);
if (!buffer) {
AtlMessageBox(m_hWnd, L"Failed to map memory", IDR_MAINFRAME);
return 0;
}
SetDlgItemText(IDC_TEXT, (PCWSTR)buffer);
::UnmapViewOfFile(buffer);

Chapter 14: Memory Mapped Files
60
return 0;
}
We can create a new application, that can use the shared memory just the same. The memview
application monitors changes to the data in the shared memory and displays any new data that
appears.
First, the file mapping object must be open. In this case, I decided to use OpenFileMapping, because
this is a monitoring application, and should not be able to determine the shared memory size or
backup file:
int main() {
HANDLE hMemMap = ::OpenFileMapping(FILE_MAP_READ, FALSE, L"MySharedMemory");
if (!hMemMap) {
printf("File mapping object is not available\n");
return 1;
}
Next, we need to map the memory into the process address space:
WCHAR text[1024] = { 0 };
auto data = (const WCHAR*)::MapViewOfFile(hMemMap, FILE_MAP_READ, 0, 0, 0);
if (!data) {
printf("Failed to map shared memory\n");
return 1;
}
The “monitoring” is based on reading the data every certain period of time (1 second in the following
code). The text local variable stores the current text from the shared memory. It’s compared to the
new data and updated if needed:
for (;;) {
if (::_wcsicmp(text, data) != 0) {
// text changed, update and display
::wcscpy_s(text, data);
printf("%ws\n", text);
}
::Sleep(1000);
}
The loop is infinite in this simple example, but it’s easy to come up with an appropriate exit condition.
You can try it out and watch the text updated whenever any of the running Basic Sharing instances
writes a new string to the shared memory.

Chapter 14: Memory Mapped Files
61
If you open Process Explorer and look for one of the handles to the file mapping object, you’ll find
the total handles to the MMF object reflect the total number of processes using the shared memory.
If you have two instances of Basic Sharing and one instance of memview, then three handles are
expected (figure 14-2).
Figure 14-2: Object shared in Process Explorer
Sharing Memory with File Backing
The Basic Sharing+ application demonstrates the usage of shared memory possibly backup up by a
file other than the paging file. The application is based on the Basic Sharing application. Figure 14-3
shows the application’s window at startup.

Chapter 14: Memory Mapped Files
62
Figure 14-3: The Basic Application+ window
You can specify a file to use, or leave the edit box empty, in which case the page file will be used
as backup (equivalent to the Basic Sharing application). Clicking the Create button creates the file
mapping object. If the file is specified and exists, its size determines the size of the file mapping
object. If the file does not exist, it’s created with the size specified in CreateFileMapping (4 KB, just
like in Basic Sharing). The file size itself becomes 4 KB immediately.
Once the file mapping object is created, the UI focus changes to the data edit box and the read and
write buttons, just like in Basic Sharing. If you now launch another instance of Basic Sharing+,
it will automatically go to the editing mode, disabling the Create button. This is done by calling
OpenFileMapping when the process is launched. If the file mapping object exists, there is no point
in allowing the user to select a file, since that has no effect.
The CMainDlg::OnInitDialog attempts to open the file mapping object if it exists:
m_hSharedMem = ::OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE,
FALSE, L"MySharedMemory");
if (m_hSharedMem)
EnableUI();
If this succeeds, EnableUI is called to disable the file name edit box and Create button and enable
the data edit box and the Read and Write buttons. Clicking the Create button (if enabled), creates
the file mapping object as requested:
LRESULT CMainDlg::OnCreate(WORD, WORD, HWND, BOOL&) {
CString filename;
GetDlgItemText(IDC_FILENAME, filename);
HANDLE hFile = INVALID_HANDLE_VALUE;
if (!filename.IsEmpty()) {
hFile = ::CreateFile(filename, GENERIC_READ | GENERIC_WRITE, 0,
nullptr, OPEN_ALWAYS, 0, nullptr);
if (hFile == INVALID_HANDLE_VALUE) {
AtlMessageBox(*this, L"Failed to create/open file",
IDR_MAINFRAME, MB_ICONERROR);

Chapter 14: Memory Mapped Files
63
return 0;
}
}
m_hSharedMem = ::CreateFileMapping(hFile, nullptr, PAGE_READWRITE,
0, 1 << 12, L"MySharedMemory");
if (!m_hSharedMem) {
AtlMessageBox(m_hWnd, L"Failed to create shared memory",
IDR_MAINFRAME, MB_ICONERROR);
EndDialog(IDCANCEL);
}
if (hFile != INVALID_HANDLE_VALUE)
::CloseHandle(hFile);
EnableUI();
return 0;
}
If a file name is specified, CreateFile is called to open or create the file. It uses the OPEN_ALWAYS
flag that means “create the file if it does not exist, or open otherwise”. The file handle is passed to
CreateFileMapping to create the file mapping object. Finally, the file handle is closed (if previously
opened) and EnableUI is called to put the application in the data editing mode.
The Micro Excel 2 Application
The Micro Excel application from chapter 13 demonstrated how to reserve a large region of memory
and then only commit those pages that are being actively used by the application. We can combine
this approach with a memory-mapped file, so that the memory can also be shared efficiently with
other processes. Figure 14-3 shows the application in action.

Chapter 14: Memory Mapped Files
64
Figure 14-4: The Micro Excel 2 application
The secret to mapping a large region of memory without committing when MapViewOfFile is called,
is by using the SEC_RESERVE flag with CreateFileMapping. This causes the mapped region to be
reserved only, meaning direct access causes an access violation. In order to commit pages, the
VirtualAlloc function needs to be called.
Let’s examine the changes we need to make to Micro Excel to support this functionality with file
mapping. First, the file mapping object creation:
bool CMainDlg::AllocateRegion() {
m_hSharedMem = ::CreateFileMapping(INVALID_HANDLE_VALUE, nullptr,
PAGE_READWRITE | SEC_RESERVE, TotalSize >> 32, (DWORD)TotalSize,
L"MicroExcelMem");
if (!m_hSharedMem) {
AtlMessageBox(nullptr, L"Failed to create shared memory",
IDR_MAINFRAME, MB_ICONERROR);
EndDialog(IDCANCEL);
return false;
}
m_Address = ::MapViewOfFile(m_hSharedMem, FILE_MAP_READ | FILE_MAP_WRITE,
0, 0, TotalSize);
CString addr;
addr.Format(L"0x%p", m_Address);
SetDlgItemText(IDC_ADDRESS, addr);
SetDlgItemText(IDC_CELLADDR, addr);

Chapter 14: Memory Mapped Files
65
return true;
}
AllocateRegion is called when the dialog is initialized. The call to CreateFileMapping uses the page
file as a backup (this is the only scenario supported with SEC_RESERVE), and requests the SEC_RESERVE
flag along with PAGE_READWRITE. The file mapping object is given a name for easy sharing with other
processes.
Next, MapViewOfFile is called to map the entire shared memory (TotalSize=1 GB). It would of
course been possible to map just part of this memory, and this is in fact a very good idea for 32-bit
processes, where the address space range is somewhat limited. Because of the SEC_RESERVE flag, the
entire region is reserved, rather than committed.
Writing and reading data from any cell is done in exactly the same way as with the original
Micro Excel: An initial write attempt causes an access violation exception, which is caught, where
VirtualAlloc is called to explicitly commit the page where the particular cell falls, and then returns
EXCEPTION_CONTINUE_EXECUTION to tell the processor to try the access again. The code for writing
and handling the exception is repeated here for convenience:
LRESULT CMainDlg::OnWrite(WORD, WORD, HWND, BOOL&) {
int x, y;
auto p = GetCell(x, y);
if(!p)
return 0;
WCHAR text[512];
GetDlgItemText(IDC_TEXT, text, _countof(text));
__try {
::wcscpy_s((WCHAR*)p, CellSize / sizeof(WCHAR), text);
}
__except (FixMemory(p, GetExceptionCode())) {
// nothing to do: this code is never reached
}
return 0;
}
int CMainDlg::FixMemory(void* address, DWORD exceptionCode) {
if (exceptionCode == EXCEPTION_ACCESS_VIOLATION) {
::VirtualAlloc(address, CellSize, MEM_COMMIT, PAGE_READWRITE);
return EXCEPTION_CONTINUE_EXECUTION;
}

Chapter 14: Memory Mapped Files
66
return EXCEPTION_CONTINUE_SEARCH;
}
If you run a second Micro Excel 2 application, you’ll find that the same information is visible in the
other process, because it’s the same mapped memory. However, do notice that the address to which
the 1 GB region is mapped in each process is unlikely to be the same. This is completely OK, and
does not deter from the fact that both processes see the exact same memory (figure 14-5).
Figure 14-5: Two Micro Excel 2 instances sharing memory
If you want to view this memory arrangement in VMMap, the correct memory “type” to look at is
Shareable (figure 14-6).
Figure 14-6: Page file-backed shared memory in VMMap
Other Memory Mapping Functions
An extended version of MapViewOfFile allows selecting the address to which mapping occurs:

Chapter 14: Memory Mapped Files
67
LPVOID MapViewOfFileEx(
_In_ HANDLE hFileMappingObject,
_In_ DWORD dwDesiredAccess,
_In_ DWORD dwFileOffsetHigh,
_In_ DWORD dwFileOffsetLow,
_In_ SIZE_T dwNumberOfBytesToMap,
_In_opt_ LPVOID lpBaseAddress);
All parameters are identical to MapViewOfFile, except the last one. This is the requested address for
the mapping. The address must be a multiple of the system’s allocation granularity (64 KB). The
function may fail if the specified address with the requesting mapping size is already occupied in
the process address space. This is why it’s almost always better to let the system locate an empty
region by specifying NULL as the value, which makes the function identical to MapViewOfFile.
Why would you want to set up a specific address? One common case (for the system, at least) is
in the case a PE file must be mapped from multiple processes (SEC_IMAGE flag). This is used for
PE images, because code can contain pointers (addresses) that reference another location in the PE
image range. If the mapping is done to a different address, then some of the code needs to change.
This normally happens in cases DLLs need to be relocated (discussed in the next chapter).
For data, it’s also possible to store pointers that point to other locations in the mapped region, but
that would not be a good idea, because MapViewOfFileEx may fail. It’s better to store offsets in the
data, so these are address-independent.
Another variation on MapViewOfFile is about selecting a preferred NUMA node for the physical
memory used by the mapping:
LPVOID MapViewOfFileExNuma(
_In_
HANDLE hFileMappingObject,
_In_
DWORD dwDesiredAccess,
_In_
DWORD dwFileOffsetHigh,
_In_
DWORD dwFileOffsetLow,
_In_
SIZE_T dwNumberOfBytesToMap,
_In_opt_ LPVOID lpBaseAddress,
_In_
DWORD nndPreferred);
MapViewOfFileExNuma extends MapViewOfFileEx with a preferred NUMA node (refer to chapter 13
for more on NUMA).
Windows 10 version 1703 (RS2) introducted MapViewOfFile2:

Chapter 14: Memory Mapped Files
68
PVOID MapViewOfFile2(
_In_ HANDLE FileMappingHandle,
_In_ HANDLE ProcessHandle,
_In_ ULONG64 Offset,
_In_opt_ PVOID BaseAddress,
_In_ SIZE_T ViewSize,
_In_ ULONG AllocationType,
_In_ ULONG PageProtection);
This function is implemented inline by calling the more expaned function MapViewOfFileNuma2 by
passing NUMA_NO_PREFERRED_NODE (-1) as the preferred NUMA node:
PVOID MapViewOfFileNuma2(
_In_ HANDLE FileMappingHandle,
_In_ HANDLE ProcessHandle,
_In_ ULONG64 Offset,
_In_opt_ PVOID BaseAddress,
_In_ SIZE_T ViewSize,
_In_ ULONG AllocationType,
_In_ ULONG PageProtection,
_In_ ULONG PreferredNode);
These functions and other that follow in this section require the import library mincore.lib.
Currently the documentation specifies kernel32.lib incorrectly.
These functions add a second parameter (hProcess) identifying the process into which to map the
view (the original functions always work on the current process). Of course, using GetCurrentProcess
is perfectly legal. If the process in question is different, the handle must have the PROCESS_VM_-
OPERATION access mask. A nice bonus of these functions is the offset that can be specified as a single
64-bit number instead of the two 32-bit values in the original functions.
The AllocationType parameter can be 0 (for normal committed view), or MEM_RESERVE for reserving
the view without committing. Also, MEM_LARGE_PAGES can be specified if large pages are to be used
for mapping. In that case, the file mapping object would have to be created with the SEC_LARGE_PAGES
flag and the caller must have the SeLockMemoryPrivilege privilege.
The rest of the parameters are the same as for MapViewOfFileExNuma (albeit in a difefrent order). The
returned address is valid in the target process address space only. These function can be useful when
some memory is required to share with another process without that process having any knowledge
about the file mapping object that is needed to open, the region to map. etc. This means the file
mapping object can be created without a name, that makes it harder to interfere with. The only
piece of information that needs to be passed to the target process is the resulting address, which can

Chapter 14: Memory Mapped Files
69
even be predefined if BaseAddress is not NULL. Passing a single pointer value to another process is
much easier to do than more complex information. For example, a window message can be used, or
even a shared variable from a DLL, as demonstrated in chapter 12.
Unmapping the mapped view can be done from within the target process normally with UnmapViewOfFile
or from the mapping process with UnmapViewOfFile2:
BOOL UnmapViewOfFile2(
_In_ HANDLE Process,
_In_ PVOID BaseAddress,
_In_ ULONG UnmapFlags
);
UnmapFlags is typically zero, but can have two more values. Consult the documentation for the
details. Another variant is UnmapViewOfFileEx that works like UnmapViewOfFile2, but always uses
the calling process.
UWP processes that need to use MapViewOfFile2 have their own version, MapViewOfFile2FromApp.
With with similar functions in the Virtual family, if compiled in a UWP app, MapViewOfFile2 is
implemented inline to call MapViewOfFile2FromApp. Check the documentation for the details.
There is yet another MapViewOfFile variant, introduced in Windows 10 version 1803 (RS4):
PVOID MapViewOfFile3(
_In_ HANDLE FileMapping,
_In_opt_ HANDLE Process,
_In_opt_ PVOID BaseAddress,
_In_ ULONG64 Offset,
_In_ SIZE_T ViewSize,
_In_ ULONG AllocationType,
_In_ ULONG PageProtection,
_Inout_ MEM_EXTENDED_PARAMETER* ExtendedParameters,
_In_ ULONG ParameterCount);
This is a “super function” combining the capablities of the other variants, where the properties are
given as an array of MEM_EXTENDED_PARAMETER structures. Refer to the discussion of VirtualAlloc2
in chapter 13, as this is the same structure used there.
As perhaps expected, there is another variant for UWP processes - MapViewOfFile3FromApp,
implemented similarly as previously described.
Finally, Windows 10 version 1809 (RS5) added a variant for CreateFileMapping:

Chapter 14: Memory Mapped Files
70
HANDLE CreateFileMapping2(
_In_ HANDLE File,
_In_opt_ SECURITY_ATTRIBUTES* SecurityAttributes,
_In_ ULONG DesiredAccess,
_In_ ULONG PageProtection,
_In_ ULONG AllocationAttributes,
_In_ ULONG64 MaximumSize,
_In_opt_ PCWSTR Name,
_Inout_updates_opt_(ParameterCount) MEM_EXTENDED_PARAMETER* ExtendedParameters,
_In_ ULONG ParameterCount);
This function seems to be currently undocumented, but it uses the same MEM_EXTENDED_PARAMETER
structures. For example, specifying a preferred NUMA node for all mappings from this file mapping
object can be done like so:
HANDLE hFile = ...;
MEM_EXTENDED_PARAMETER param = { 0 };
param.Type = MemExtendedParameterNumaNode;
param.ULong = 1;
// NUMA node 1
HANDLE hMemMap = ::CreateFileMapping2(hFile, nullptr, FILE_MAP_READ,
PAGE_READONLY, 0, 0, nullptr, &param, 1);
Data Coherence
File mapping objects provide several guarantees in terms of data coherence.
• Multiple views of the same data/file, even from multiple processes, are guaranteed to be
synchronized, since the various views are mapped to the same physical memory. The only
exception is when mapping a remote file on the network. In that case, views from different
machine may not be synchronized at all times. Views from the same machine continue to be
synchronized.
• Mutiple file mapping objects that map the same file are not guaranteed to be synchronized.
Generally, it’s a bad idea to map the same file with two or more file mapping objects. It’s best
to open the file in question for exclusive access so that no other access is possible on the file
(at least if writing is intended).
• If a file is mapped by a file mapping object, and at the same time opened for normal I/O
(ReadFile, WriteFile, etc.), the changes from I/O operations will not generally be immediately
reflected in views mapped to the same locations in the file. This situation should be avoided.

Chapter 14: Memory Mapped Files
71
Summary
Memory-mapped file objects are flexible and fast, providing shared memory capabilities, whether
they map a specific file or just sharing memory backed up by the page file. They are very efficient,
and I consider them one of my favorite features in Windows.
In the next chapter, we’ll turn our attention to Dynamic Link Libraries (DLL), which are a crucial
part of Windows.

Chapter 15: Dynamic Link Libraries
Dynamic Link Libraries (DLLs) were a fundamental part of Windows NT since its inception. The
major motivation behind the existence of DLLs is the fact they can be easily shared between
processes so that a single copy of a DLL is in RAM and all processes that need it can share the
DLL’s code. In those early days, RAM was much smaller than it is today, which made that memory
saving very important. Even today these memory sacings are siginificant, as a typical process uses
dozens of DLLs.
DLLs have many uses today, many of which we’ll examine in this chapter.
In this chapter:
• Introduction
• Building a DLL
• Explicit and Implicit Linking
• The DllMain Function
• DLL Injection
• API Hooking
• DLL Base Address
• Delay-Load DLLs
• The LoadLibraryEx Function
• Miscellaneous Functions
Introduction
DLLs are Portable Executable (PE) files that can contain one or more of the following: code, data and
resources. Every user-mode process uses subsystem DLLs, such as kernel32.dll, user32.dll, gdi32.dll,
advapi32.dll, implementing the documented Windows API. And naturally, Ntdll.Dll is mandatory
in every user-mode process, including native applications.
DLLs are libraries that can contain functions, global variables, and resources, such as menus,
bitmaps, icons. Some functions (and types) can be exported by a DLL, so that they can be used
directly by another DLL or executable that loads the DLL. A DLL can be loaded into a process
implicitly, when the process starts up, or explicitly when the application calls the LoadLibrary or
LoadLibraryEx function.

Chapter 15: Dynamic Link Libraries
73
Building a DLL
We’ll start by looking at how to build a DLL and export symbols. With Visual Studio, a new DLL
project can be created by selecting the appropriate project template (figure 15-1).
Figure 15-1: New DLL Project in Visual Studio
One of the templates indicates the DLL exports symbols, but any DLL template will do. The only
fundamental change for a DLL project compared to an EXE project is the Configuration Type (figure
15-2) in the project’s properties.

Chapter 15: Dynamic Link Libraries
74
Figure 15-2: DLL Project properties in Visual Studio
A typical project created by Visual Studio would have the following files:
• pch.h and pch.cpp - precompiled header and implementation.
• framework.h - included by pch.h and should contain all “standard” Windows headers such as
Windows.h. I typically delete this file and just put all Windows headers in pch.h.
• dllmain.cpp - includes the DllMain function (discussed later in this chapter).
At this point we can build the project successfully. However, the DLL is fairly useless. Most DLLs
export some functionality to be called by other modules (other DLLs or an EXE). Let’s add one
function to the DLL, called IsPrime. First in a header file that can be included by users of the DLL:
// Simple.h
bool IsPrime(int n);
Then the implementation in a different file, since this should not be visible by users of the DLL:

Chapter 15: Dynamic Link Libraries
75
// Simple.cpp
#include "pch.h"
#include "Simple.h"
#include <cmath>
bool IsPrime(int n) {
int limit = (int)::sqrt(n);
for (int i = 2; i <= limit; i++)
if (n % i == 0)
return false;
return true;
}
The implementation is not important for the purposes of this section. The point is, we have some
functionality in our DLL and we want to be able to use it. Let’s add a console application project to
the same solution in Visual Studio named SimplePrimes.
To gain access to the DLL’s functionality, we add an include to Simple.h before our main function:
// SimplePrimes.cpp
#include "..\SimpleDll\Simple.h"
// other includes...
Let’s add a simple test by calling IsPrime:
int main() {
bool test = IsPrime(17);
printf("%d\n", (int)test);
return 0;
}
If we compile this, it compiles fine, but it fails to link with the dreaded “unresolved external”
error: SimplePrimes.obj : error LNK2019: unresolved external symbol “bool __cdecl IsPrime(int)”
(?IsPrime@@YA_NH@Z) referenced in function _main
The compiler finds the declaration of the function in Simple.h, so it’s relatively happy. It also looks
for an implementation, but cannot find one. Instead of complaining, it signals the linker that the
implementation of IsPrime is missing, so perhaps the linker can resolve it.
How can the linker do so? The linker has a “global” view of the project and is aware of libraries that
may be provided as binary pieces of compiled code. The linker, however, does not find anything in
the list of libraries it knows about, and eventually gives up with an “unresolved external” error.

Chapter 15: Dynamic Link Libraries
76
There are two pieces missing here: one is some reference to where to find the implementation.
We’ll add that by right-clicking the References node in the SimplePrimes project and selecting Add
Reference… from the menu. The Add Reference dialog opens (figure 15-3).
Figure 15-3: The Add Reference dialog box
You have to check the box for Simple.Dll and click OK. A node named Simple.Dll appears under the
References node. Building the project now produces the same “unresolved external” error. This is
where the second missing piece comes in: the IsPrime function must be exported. Here is one way
to do it in Simple.h by extending the declaration of IsPrime:
__declspec(dllexport) bool IsPrime(int n);
In general, there are several __declspec types supported by Microsoft’s compiler, as there is no
standard way of exporting symbols from modules.
The C++ feature called Modules that is part of the C++ 20 standard attempts to address this
issue. However, it’s not necessarily geared towards DLLs. It’s not fully implemented by the
Visual C++ compiler at the time of this writing.
Now we can build the project and should build successfully. We can run SimplePrimes and get the
expected result. Adding the dllexport specifier added the IsPrime function to the list of exported
symbols. This still does not explain exactly why the linker was satisfied, and how the DLL was found
at runtime. We’ll get to these details in the next section.
You can now open any PE viewer tool and look at Simple.Dll and SimplePrimes.exe. For Simple.Dll,
the IsPrime function should be listed as exported (figure 15-4 using my own PE Explorer V2). You
can also get this information with the Dumpbin.exe command-line tool like so:

Chapter 15: Dynamic Link Libraries
77
C:\>dumpbin /exports SimpleDll.dll
Microsoft (R) COFF/PE Dumper Version 14.26.28805.0
Copyright (C) Microsoft Corporation.
All rights reserved.
Dump of file c:\dev\Win10SysProg\Chapter15\Debug\SimpleDll.dll
File Type: DLL
Section contains the following exports for SimpleDll.dll
00000000 characteristics
FFFFFFFF time date stamp
0.00 version
1 ordinal base
1 number of functions
1 number of names
ordinal hint RVA
name
1
0 000111F9 ?IsPrime@@YA_NH@Z = @ILT+500(?IsPrime@@YA_NH@Z)
Summary
1000 .00cfg
1000 .data
1000 .idata
1000 .msvcjmc
2000 .rdata
1000 .reloc
1000 .rsrc
7000 .text
10000 .textbss
Notice the IsPrime-ish symbol. It has some weird decorations, explained in the next section.

Chapter 15: Dynamic Link Libraries
78
Figure 15-4: Exports in Simple.dll
Figure 15-5 shows the imports for SimplePrimes.exe. One of them is from Simple.Dll - the IsPrime
function.
Figure 15-5: Imports in SimplePrimes.exe
Implicit and Explicit Linking
There are two fundamental ways to link against a DLL (so that its functionality can be used). The
first and simplest is implicit linking (sometimes called static linking to DLLs), used in the previous
section. The second is explicit linking, which is more involved, but provides more control on the
timing of loading and unloading of DLL.

Chapter 15: Dynamic Link Libraries
79
Implicit Linking
When a DLL is generated, an accompanying file called an import library is generated by default as
well. This file has the LIB extension and contains two pieces of information:
• The file name of the DLL (with no path)
• List of exported symbols (functions and variables)
When adding a reference to a DLL project in Visual Studio, as was done in the previous section, the
import library generated by the DLL project is added as a dependency to the EXE project (or another
DLL project that wants to use the DLL). Instead of adding a reference with Visual Studio (an option
that did not exist in early versions of Visual Studio), the LIB file can be added as a dependency using
the project’s properties (figure 15-6).
Figure 15-6: Import libraries in Project Properties
Figure 15-6 uses the $(TargetDir) variable used by Visual Studio to locate the LIB file properly, but
more generally, the LIB file can be copied to anywhere and referenced. You can see all the “standard”
subsystem DLLs the application links against using import libraries provided by the Visual Studio
installation.
An alternative way to link against an import library (or a static library, for that matter), is add the
dependency in code:

Chapter 15: Dynamic Link Libraries
80
#ifdef _WIN64
#pragma comment(lib, "../x64/Debug/SimpleDll.lib")
#else
#pragma comment(lib, "../Debug/SimpleDll.lib")
#endif
The gymnastics around locating the LIB file is not elegant, but this can be improved by more
configuration options to place the resulting LIB file in a more convenient directory, or by configuring
other default search directories (all possible to do in a project’s properties).
Using the #pragma option is somewhat easier to see, as the dependency on the vcxproj file is
reduced.
With the import library in place, building the dependent project (the one using the DLL) take the
following steps:
• The compiler sees a call to a function (IsPrime in SimpleDll) that it cannot find an implemen-
tation for in any source file.
• The compiler places instructions for the linker to locate such an implementation.
• The linker attempts to locate an implementation in static library files (that also typically have
a LIB extension), but fails.
• The linker sees the imported lib where the function IsPrime is said to be implemented in the
SimpleDll.Dll. The linker adds the appropriate data to the resulting PE that instructs the loader
to locate the DLL at runtime.
At runtime, the loader (in NtDll.Dll), reads the information in the PE, and realizes it needs to locate
the SimpleDll.Dll file. The search path the loader uses is the same described in chapter 3 for locating
required DLLs by a newly created process - this is implicit linking in action. The search list (in order)
is repeated here for convenience:
1. If the DLL name is one of the KnownDLLs (specified in the registry), the existing mapped file
is used without searching.
2. The directory of the executable
3. The current directory of the process (determined by the parent process).
4. The System directory returned by GetSystemDirectory (e.g. c:\windows\system32)
5. The Windows directory returned by GetWindowsDirectory (e.g. c:\Windows)
6. The directories listed in the PATH environment variable
If the DLL is not found in any of these directories, the process shows the error message box shown
in figure 15-7 and the process terminates.

Chapter 15: Dynamic Link Libraries
81
Figure 15-7: Failure to locate a DLL with implicit linking
The KnownDLLs registry key specifies DLLs that should be searched for in the system directory
before trying other locations. This is used to prevent a hijacking of one of these DLLs. For
example, a malicious application may place its own copy of (say) kernel32.dll in the application’s
directory, causing the process to load the malicious version. This cannot happen, though, because
kernel32.dll is in the list of the known DLLs. Figure 15-8 shows the KnownDLLs registry key at
HKLM\System\CurrentControlSet\Control\Session Manager\KnownDLLs.
Figure 15-8: KnownDLLs in the Registry
The known DLLs are mapped when the system is initialized (with memory-mapped file objects),
so that loading these DLLs into processes is faster, since the memory-mapped files are ready even
before the DLLs are needed by the process. These file mapping (section) objects can be seen in
WinObj (figure 15-9) from Sysinternals or my own Object Explorer.

Chapter 15: Dynamic Link Libraries
82
Figure 15-9: KnownDLLs sections in WinObj
If a DLL has dependencies on other DLLs (implicit linking again), these are searched in exactly the
same way, recursively. All these DLLs must be located successfully, otherwise process terminates
with the error message box in figure 15-7.
Once an implicitly loaded DLL is found, its DllMain function (if provided) is executed with a reason
parameter of DLL_PROCESS_ATTACH, indicating to the DLL that it has now been loaded into a process
(see the section “The DllMain Function” for more on DllMain). If DllMain returns FALSE, it indicates
to the loader that the DLL was not initialized successfully, and the process terminates with a similar
message box to figure 15-7.
All implicitly loaded DLLs load at process startup and unload when the process exits/terminates.
Attempts to use the FreeLibrary function (discussed later) to unload such DLLs appear to succeed,
but do nothing in practice.
Implicitly linking to DLLs is easy from the developer’s perspective. Here is a summary of the steps
needed by an application developer that wants to link implicitly with a DLL:
• Add the relevant #include(s) where the exported functions/variables are declared.
• Add the import library provided with the DLL to its set of imports (in one of the ways described
earlier).
• Invoke exported functions or access exported variables.
The “exported functions” are not necessarily global functions. These can be C++ member functions
in classes as well. The __declspec(dllexport) directive can be applied to a class like so:

Chapter 15: Dynamic Link Libraries
83
class __declspec(dllexport) PrimeCalculator {
public:
bool IsPrime(int n) const;
std::vector<int> CalcRange(int from, int to);
};
And using this class is done normally, for example:
PrimeCalculator calc;
printf("123 prime? %s\n", calc.IsPrime(123) ? "Yes" : "No");
Explicit Linking
Explicit linking to a DLL provides more control over when the DLL is loaded and unloaded. Also,
if the DLL fails to load the process does not crash, so the application can handle the error and carry
on. One common use of explicit DLL linking is to load language-related resources. For example, an
application might try to load a DLL with resources in the current system locale, and if not found,
can load a default resource DLL that is always provided as part of the application’s installation.
With explicit linking, no import library is used so that the loader does not attempt to load the DLL
(as it may or may not exist). This also means that you cannot use #include to get the exported
symbols declarations, because the linker will fail with “unresolved external” errors. How can we use
such a DLL?
The first step is to load it at runtime, typically close to where it’s needed. This is the job of
LoadLibrary:
HMODULE LoadLibrary(_In_ LPCTSTR lpLibFileName);
LoadLibrary accepts a file name only or a full path. If a file name only is specified, the search for
the DLL is done in the same order as for implicitly loaded DLLs as described in the previous section.
If a full path is specified, only that file is attempted loading.
Before the actual search begins, the loader checks if there is a module with the same name that
is loaded into the process address space already. If so, no search is performed, and the existing
DLL’s handle is returned. For example, if SimpleDll.Dll is loaded already (from whatever path), and
LoadLibrary is called to load a file named SimpleDll.Dll (in whatever path or without apath), no
additional DLL is loaded.
If the DLL is located successfully, it’s mapped into the process address space, and LoadLibrary’s
return value is the virtual address into which it’s mapped in the process. The type itself is HMODULE and
sometimes HINSTANCE, and these are interchangable; these are not “handles” in any sense. These type
names are relics from 16-bit Windows. In any case, this return value represents the DLL uniquely in
the process address space, and is the parameter to use with other functions that access information
in the DLL, as we shall soon see.

Chapter 15: Dynamic Link Libraries
84
As with all DLL loads, DllMain is called on the loaded DLL. If TRUE is returned, the DLL is considered
loaded successfully, returning control to the caller. Otherwise, the DLL unloads and the function fails.
If the function fails (because the DLL failed to locate or its DllMain returned FALSE), NULL is returned
to the caller.
Now that the DLL is loaded, how can we access exported functions from the DLL? The function in
question is GetProcAddress:
FARPROC GetProcAddress(
_In_ HMODULE hModule,
_In_ LPCSTR lpProcName);
The function returns the address of an exported symbol from the DLL. Its first parameter is the DLL
handle returned from LoadLibrary. The second parameter is the name of the symbol. Notice the
name must be ASCII - there is no Unicode variant. The return value is a generic FARPROC, yet another
type from the old 16-bit days, where “far” and “near” meant different things. The actual definition of
FARPROC is unimportant; the caller will cast the return value to the appropriate type based on some
foreknowledge, such as a header file (that cannot be included) or old-fashioned documentation. If
the symbol does not exist (or is not exported, which is the same thing), GetProcAddress returns NULL.
Let’s go back to the IsPrime function exported form SimpleDll.Dll like so:
__declspec(dllexport) bool IsPrime(int n);
It looks innocent enough. Here is a first attempt at loading SimpleDll.Dll dynamically, and then
locating IsPrime:
auto hPrimesLib = ::LoadLibrary(L"SimpleDll.dll");
if (hPrimesLib) {
// DLL found
using PIsPrime = bool (*)(int);
auto IsPrime = (PIsPrime)::GetProcAddress(hPrimesLib, "IsPrime");
if (IsPrime) {
bool test = IsPrime(17);
printf("%d\n", (int)test);
}
}
The using statement in the preceding code is the preferred way in C++ 11 and higher to
create type definition, effectively replacing typedef. If you’re using C or an old compiler,
replace this using line with typedef bool (*PIsPrime)(int); Function type definitions are
never pretty, but using makes them bearable.

Chapter 15: Dynamic Link Libraries
85
The code looks relatively straighforward - the DLL is loaded (it’s located in the executable’s directory
when building a DLL and an EXE as part of the same solution in Visual Studio), so it’s located
just fine. Unfortunately, the call to GetProcAddress fails, with GetLastError returning 127 (“The
specified procedure cannot be found”). Clearly, GetProcAddress cannot locate the exported function,
even though it was exported. Why?
The reason has to do with the name of the function. If we go back to the information dumped by
Dumpbin about SimpleDll.Dll, this is what we find (see earlier in this chapter):
1
0 000111F9 ?IsPrime@@YA_NH@Z = @ILT+500(?IsPrime@@YA_NH@Z)
The linker “mangled” the name of the function to be ?IsPrime@@YA_NH@Z. The reason has to do with
the fact that the name “IsPrime” is not unique enough in C++. An IsPrime function can be in class
A and in class B as well as globally. And it could be part of some namespace C. If this is not enough,
there can be multiple functions named IsPrime in the same scope, due to C++ function overloading.
So the linker gives the function a weird-looking name that contains these unique attributes. We can
try substituting this mangled name in the preceding code example like so:
auto IsPrime = (PIsPrime)::GetProcAddress(hPrimesLib, "?IsPrime@@YA_NH@Z");
And this works! However, it’s not fun, and we have to look up the mangled name with a tool to
get it right. The common practice is to turn all exported functions into C-style functions. Because C
does not support function overloading or classes, the linker does not have to do complex mangling.
Here is one way to export a function as C:
extern "C" __declspec(dllexport) bool IsPrime(int n);
If you’re compiling C files, this would be the default.
With this change, getting the pointer to the IsPrime function is simplified:
auto IsPrime = (PIsPrime)::GetProcAddress(hPrimesLib, "IsPrime");
This scheme of turning function into C-style, cannot be done for member functions in classes. This
is why it’s not practical to use GetProcAddress to access C++ functions. This is why most DLLs that
are intended to be used with LoadLibrary / GetProcAddress expose C-style functions only.
Once a DLL is no longer needed, call FreeLibrary to unload it from the process:

Chapter 15: Dynamic Link Libraries
86
BOOL FreeLibrary(_In_ HMODULE hLibModule);
The system maintains a per-process counter for each loaded DLL. If multiple calls to LoadLibrary
are made for the same DLL, the same number of FreeLibrary calls are needed to truly unload the
DLL from the process address space.
If a handle to a loaded DLL is needed, GetModuleHandle can be used to retrieve it:
HMODULE GetModuleHandle(_In_opt_ LPCTSTR lpModuleName);
The module name does not need a full path, just a DLL name. If no extension is provided, “.dll” is
appended by default. The function does not increment the load count for the DLL. If the module
name is NULL, the handle to the executable is returned. The executable is mapped to the process
address space just like a DLL - the returned “handle” is in fact the virtual address to which the
executable image was loaded.
Calling Conventions
The term Calling Convention indicates (among other things) how function parameters are passed
to functions, and who is responsible for cleaning up the parameters, if passed on the stack. For x64,
there is only one calling convention. For x86, there are several. The most common are the standard
calling convention (stdcall) and the C calling convention (cdecl). Both stdcall and cdecl use the
stack to pass arguments, pushed from right to left. The main difference between them is that with
stdcall the callee (the function body itself) is responsible for cleaning up the stack, whereas with
cdecl the caller is responsible for that.
stdcall has the advantage of being smaller, since the stack cleanup code appears only one (as part
of the fucntion’s body). With cdecl, every call to the function must be followed by an instruction to
clean up the arguments from the stack. The advantage of cdecl functions is the fact they can accept
a variable number of paramaters (specified by the ellipsis ... in C/C++), because only the caller
knows how many arguments were passed in.
The discussion on calling conventions in this section is far from exhastive. Check online resources
to get all the details.
The default calling convention used in user mode projects in Visual C++ is cdecl. Specifying the
calling convention is done by placing the proper keyword between the return type and the function
name. The Microsoft compiler reconginzes the __cdecl and __stdcall keywords for this purpose.
The keyword used must be specified in the implementation as well. Here is an example of turning
IsPrime to use stdcall:

Chapter 15: Dynamic Link Libraries
87
extern "C" __declspec(dllexport) bool __stdcall IsPrime(int n);
This also means that when defining the function pointer for use with GetProcAddress, the correct
calling convention must be specified as well, otherwise we’ll get runtime errors or stack corruption:
using PIsPrime = bool (__stdcall *)(int);
// or
typedef bool(__stdcall* PIsPrime)(int);
__stdcall is the calling convention used for most Windows APIs. This is usually conveyed using
one of the following macros, which mean the exact same thing (WINAPI, APIENTRY, PASCAL, CALLBACK).
This is why one of these macros is used in the Windows headers. Here is the exact declaration of
the Sleep function:
VOID WINAPI Sleep(_In_ DWORD dwMilliseconds);
I’ve ommitted these macros when showing function declarations to simplify them and focus on the
important stuff.
There is an additional wrinkle with stdcall functions. The linker mangles them differently than
cdecl, by prefixing their names with an underscore and appending the @ sign and the number of
bytes passed in as arguments. So for IsPrime, the actual exported name is _IsPrime@4. This also
means the name passed to GetProcAddress should be this name for x86, but just IsPrime for x64
(x64 does not mangle names since it has a single calling convention).
The solution for stdcall functions is to use a Module Definition (DEF) file. This file can be added
to a DLL project to specify various options. Its main usage is to list exported symbols, which means
using __declspec(dllexport) is no longer needed. The exported functions can be looked up by their
simple name regardless of the calling convention.
You can add a DEF file by using Visual Studio’s “Add New Item…” menu just like any other file.
You can search for “def” or just specify the file’s extension explicitly. The DEF file name must be
the same as the projec’s name so it’s processed without any extra configuration. For SimpleDll the
file name is SimpleDll.def. Here is the contents for the DEF file to export IsPrime in a consistent
manner:
LIBRARY
EXPORTS
IsPrime
If more exports are needed, add each one in a separate line. With this file in place, the IsPrime
function can be looked up by its simple name with GetProcAddress.
DLL Search and Redirection
When calling LoadLibrary with a file name only, a certain search path is used. It’s possible to add a
custom path to search for DLLs with SetDllDirectory:

Chapter 15: Dynamic Link Libraries
88
BOOL SetDllDirectory(_In_opt_ LPCTSTR lpPathName);
The specified path is looked up after the executable’s directory. If lpPathName is NULL, any directory
set earlier by SetDllDirectory is removed, restoring the default search order. If lpPathName is an
empty string, then the current directory of the process is removed from the search list. Each call to
SetDllDirectory replaces any previous call.
If multiple search directories are desired, call AddDllDirectory:
DLL_DIRECTORY_COOKIE AddDllDirectory(_In_ PCTSTR NewDirectory);
The function adds the specified directory to the search path, and returns an opaque pointer
that represents this “registration”. However, directories added with AddDllDirectory are not used
automatically. An additional call must be made to SetDefaultDllDirectories to enable these extra
directories:
BOOL SetDefaultDllDirectories(_In_ DWORD DirectoryFlags);
The flags can be a combination of the values listed in table 15-1.
Table 15-1: Flags for SetDefaultDllDirectories
Value (LOAD_LIBRARY_SEARCH_ prefix)
Description
APPLICATION_DIR
Executable directory is included in the search
USER_DIRS
Adds directories added with AddDllDirectory to the search
SYSTEM32
Adds the System32 directory to the search
DEFAULT_DIRS
Combines all the previous values
DLL_LOAD_DIR
The loaded DLL’s directory is added temporarily to the search for
dependent DLLs
To allow AddDllDirectory directories to hava an effect on future LoadLibrary calls, use the following
call:
::SetDefaultDllDirectories(LOAD_LIBRARY_SEARCH_USER_DIRS);
An added directory should be removed at some point with RemoveDllDirectory:
BOOL RemoveDllDirectory(_In_ DLL_DIRECTORY_COOKIE Cookie);
There is no explicit function to return to the default search paths. The best way to handle this is to call
RemoveDllDirectory for each AddDllDirectory and call SetDllDirectory with NULL. Alternatively,

Chapter 15: Dynamic Link Libraries
89
the LoadLibraryEx function can be used for a “one time” search path alteration (see later in this
chapter).
The DllMain Function
A DLL can have an entry point, traditionally called DllMain that must have the following prototype:
BOOL WINAPI DllMain(HINSTANCE hInsdDll, DWROD reason, PVOID reserved);
The hInstance parameter is the virtual address the DLL is loaded into the process. It’s the same
value returned from LoadLibrary if the DLL is loaded explicitly. The reason parameter indicates
why DllMain was called. It can have the values listed in table 15-2.
Table 15-2: Reason values for DllMain
Reason value
Description
DLL_PROCESS_ATTACH
Called when the DLL is attached to a process
DLL_PROCESS_DETACH
Called before the DLL is unloaded from a process
DLL_THREAD_ATTACH
Called when a new thread is created in the process
DLL_THREAD_DETACH
Called before a thread exits in the process
When a DLL is loaded into a process, DllMain is called with reason DLL_PROCESS_ATTACH. If the same
DLL is loaded multiple times into the same process (calling LoadLibrary multiple times), the internal
reference counter for the DLL is incremented, but DllMain is not called again. With DLL_PROCESS_-
ATTACH, DllMain must return TRUE to indicate the DLL initialized properly, or FALSE otherwise. If
FALSE is returned, the DLL is unloaded.
The opposite of DLL_PROCESS_ATTACH is DLL_PROCESS_DETACH, called before the DLL is unloaded. It
could be because the entire process is shutting down, or because FreeLibrary was called to unload
this DLL. Remember that forceful process termination with TerminateProcess does not invoke
DllMain (see chapter 3 for more details).
The remaining two values cause DllMain to be called when a new thread is created (DLL_THREAD_-
ATTACH) and before a thread exits (DLL_THREAD_DETACH). Many DLLs don’t care about threads
created or destroyed in their hosting process. A useful optimization in such a case is to call
DisableThreadlibraryCalls:
BOOL DisableThreadLibraryCalls(_In_ HMODULE hLibModule);
This call with the DLL’s module handle tells the system not to call DllMain for thread-related events.
This call is typically invoked when DLL_PROCESS_ATTACH reason is sent.

Chapter 15: Dynamic Link Libraries
90
The DLL_THREAD_ATTACH reason is not invoked for the first thread in the process - the DLL should
use DLL_PROCESS_ATTACH for that.
If the DLL uses Thread Local Storage (TLS, discussed in chapter 10), then it might want to allocate
some structure for each thread in the process. The reasons DLL_THREAD_ATTACH and DLL_THREAD_-
DETACH are useful for such allocations and deallocations.
There is a fifth value supported for reason, called DLL_PROCESS_VERIFIER (equal to 4), that
can be used to write Application Verifier DLLs, although it’s not officially documented. I’ll
say more about Application Verifier in chapter 20.
The last parameter to DllMain is called “reserved”, but it indicates whether the DLL is implicitly
loaded (lpReserved is non-NULL) or explicitly loaded (lpReserved is NULL).
Creating a DLL project with Visual Studio provides a bare-bones DllMain that just returns TRUE for
all notifications. Here is a simple DllMain that calls DisableThreadlibraryCalls when the DLL is
loaded into a process:
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID lpReserved) {
switch (reason) {
case DLL_PROCESS_ATTACH:
::DisableThreadLibraryCalls(hModule);
break;
case DLL_THREAD_ATTACH:
case DLL_THREAD_DETACH:
case DLL_PROCESS_DETACH:
break;
}
return TRUE;
}
The DllMain function is called with the Loader Lock held. You can think of the Loader Lock as a
critical section. What this means is that calling some functions is not allowed or dangerous from
DllMain as they can lead to deadlocks. For example, if DllMain code (say in DLL_THREAD_ATTACH)
waits to acquire a mutex managed by the application while another thread holds the mutex. The
other thread, before releasing the mutex, calls some function that causes an attempt to acquire the
Loader Lock, such as calling LoadLibrary or GetModuleHandle. This causes a deadlock.
The recommendation is simple: do as little as possible in DllMain, and defer other initialization to
an explict function that could be called right after DllMain returns. Functions that create/destroy

Chapter 15: Dynamic Link Libraries
91
processes and DLLs (CreateProcess, CreateThread, etc.) should be avoided. Using heap or virtual
APIs, I/O functions, TLS and most other functions from kernel32.dll are safe to use.
DLL Injection
In some cases it’s desirable to inject a DLL into another process. By “injecting a DLL” I mean forcing
in some way another process to load a specific DLL. This allows that DLL to execute code in the
context of the target process. There are many uses for such an ability, but all of them essentially boil
down to some form of customization or interception of operations within the target process. Here
are some concrete examples:
• Anti-malware solutions and other applications may want to hook API functions in the target
process. Hooking is described in the next major section.
• The ability to customize windows by subclassing windows or controls, allowing behavioral
changes to the UI.
• Being part of a target process gives unlimited access to anything in that process. Some can be
used for good, like DLLs that monitor an application’s behavior to locate bugs, and some for
bad.
In this section we’ll look at some common techniques for DLL injections. These are by no means
exhastive, as the cyber-security community always manages to come up with ingenious way to inject
code into a target process. This section focus on the more “traditional” or “standard” techniques to
make the fundamentals understandable.
Injection with Remote Thread
Injecting a DLL by creating a thread in the target process that loads the required DLL is probably
the most well-known and straightforward technique (relatively speaking). The idea is to create a
thread in a target process that calls the LoadLibrary function with the DLL path to be injected. The
problem is, how to you get the code to execute into the target process?
The Injector project demonstrates this technique. First, we need to check command line arguments:
int main(int argc, const char* argv[]) {
if (argc < 3) {
printf("Usage: injector <pid> <dllpath>\n");
return 0;
}
The injector requires the target’s process ID and the DLL to inject. Next we open a handle to the
target process:

Chapter 15: Dynamic Link Libraries
92
HANDLE hProcess = ::OpenProcess(
PROCESS_VM_WRITE | PROCESS_VM_OPERATION | PROCESS_CREATE_THREAD,
FALSE, atoi(argv[1]));
if (!hProcess)
return Error("Failed to open process");
As we’ll see very soon, we need quite a few access mask bits to gain sufficient power for this injection
technique. This means that some processes would not be accessible.
The trick with this injection method is the fact that from a binary standpoint, the LoadLibrary
function and a thread’s function are essentally the same:
HMODULE WINAPI LoadLibrary(PCTSTR);
DWORD WINAPI ThreadFunction(PVOID);
Both prototypes accept a pointer, and here lies the trick: we can create a thread that runs the function
LoadLibrary! This is nice because the code to LoadLibrary is already in the target’s process (as it’s
part of kernel32.dll that must be loaded into every process which is part of the Windows subsystem).
The next task is to prepare the DLL path to load. The path string itself must be placed in the target
process since that’s where LoadLibrary would execute. We can use the VirtualAllocEx function for
this purposes:
void* buffer = ::VirtualAllocEx(hProcess, nullptr, 1 << 12,
MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
if (!buffer)
return Error("Failed to allocate buffer in target process");
Using VirtualAllocEx requires PROCESS_VM_OPERATION access mask, which we requested at OpenProcess
time. We allocate a 4 KB buffer, which is an overkill, but even if we specify less than that, it would
be rounded up to 4 KB anyway. Note the returned pointer has no meaning in the caller’s process -
it’s the allocated address in the target process.
Next we need to copy the DLL path to the allocated buffer with WriteProcessMemory:
if (!::WriteProcessMemory(hProcess, buffer, argv[2], ::strlen(argv[2]) + 1, nullptr))
return Error("Failed to write to target process");
Using WriteProcessMemory requires the process handle to have the PROCESS_VM_WRITE access mask,
which it does. The code writes the DLL’s path retrieved from the command line using ASCII, which
may seem unusual. We’ll see why in a moment. Everything is ready = it’s time to create the remote
thread:

Chapter 15: Dynamic Link Libraries
93
DWORD tid;
HANDLE hThread = ::CreateRemoteThread(hProcess, nullptr, 0,
(LPTHREAD_START_ROUTINE)::GetProcAddress(
::GetModuleHandle(L"kernel32"), "LoadLibraryA"),
buffer, 0, &tid);
if (!hThread)
return Error("Failed to create remote thread");
CreateRemoteThread accepts the target process handle (must have PROCESS_CREATE_THREAD access
mask, which it does), a NULL security descriptor, default stack size, and the thread’s start routine.
This is where we take advantage of the binary equivalence of LoadLibrary and a thread’s function.
First, LoadLibrary is not a function at all - it’s a macro. We must select LoadLibraryA or
LoadLibraryW - I selected LoadLibraryA, just because it’s a bit more convenient to use. This is why
the copied string above was ASCII. We could have used LoadLibraryW and copied a Unicode string
to the target process and essentially get the same result.
The GetProcAddress call is used to dynamically locate the address of LoadLibraryA, taking
advantage of the fact that it’s the same address in the current process. This is the key to this technique
- no need to copy code into the target process. The parameter to the thread is buffer - the address
in the target process where we copied the DLL path.
And that’s it. One important thing to note is that the injected DLL must be the same “bitness” as the
target process, as Windows does not allow a 32-bit process to load a 64-bit DLL or vice versa.
All that’s left is to do some cleanup:
printf("Thread %u created successfully!\n", tid);
if (WAIT_OBJECT_0 == ::WaitForSingleObject(hThread, 5000))
printf("Thread exited.\n");
else
printf("Thread still hanging around...\n");
// be nice
::VirtualFreeEx(hProcess, buffer, 0, MEM_RELEASE);
::CloseHandle(hThread);
::CloseHandle(hProcess);
Waiting for the thread to terminate is not mandatory, but we need to give it some time before calling
VirtualFreeEx to remove the allocation done with VirtualAllocEx. This is polite, but not stricktly
necessary. We could just as well leave that 4 KB committed in the target process.
The solution for this chapter has a DLL project named Injected you can use to test this technique.
Here is a command line example for testing:

Chapter 15: Dynamic Link Libraries
94
C:\>Injector.exe 44532 C:\Dev\Win10SysProg\Chapter15\x64\Debug\Injected.dll
You might get a notification from your anti-virus software if you have any, as the above
combination of APIs is typically monitored for and considered malicious. Windows Defender
on my machine labeled Injector.exe as malware, threatening to delete it.
You must specify a full path to the DLL, as the loading rules are from the target’s process perspective,
rather than the caller’s. The Injected DLL’s DllMain shows a simple message box:
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, PVOID lpReserved) {
switch (reason) {
case DLL_PROCESS_ATTACH:
wchar_t text[128];
::StringCchPrintf(text, _countof(text), L"Injected into process %u",
::GetCurrentProcessId());
::MessageBox(nullptr, text, L"Injected.Dll", MB_OK);
break;
}
return TRUE;
}
Windows Hooks
The term Windows Hooks used in this section refers to a set of user interface-related hooks available
with the SetWindowsHookEx API:
HHOOK SetWindowsHookEx(
_In_ int idHook,
_In_ HOOKPROC lpfn,
_In_opt_ HINSTANCE hmod,
_In_ DWORD dwThreadId);
The first parameter is the hook type. There are several types of hooks, each with its own semantics.
You can find the full list and details in the official documentation. These hooks can be installed for a
specific thread (provided by the dwThreadId parameter), or globally, for all processes in the caller’s
desktop (dwThreadId set to zero). Some hook types can only be installed globally (WH_JOURNALRECORD,
WH_JOURNALPLAYBACK, WH_MOUSE_LL, WH_KEYBOARD_LL, WH_SYSMSGFILTER), while the others may be
installed globally or for a particular thread.
The hook function provided by lpfn has the following prototype:

Chapter 15: Dynamic Link Libraries
95
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
The meaning of the parameters are described for each individual type of hook. The function must be
valid in the context of the hooked process. If the hook is used globally or on a thread of a different
process, the callback function must be part of a DLL, that is injected to the target process or processes.
In that case, the hmod parameter is the DLL’s handle provided by the caller. If the hooked thread is
within the calling process, the module handle can be NULL, and the hook callback can be part of the
caller’s process.
There are other details specifically for global hooks. Since a 32-bit DLL cannot be loaded by a 64-bit
process and vice versa, how do you hook both 32-bit and 64-bit processes? One option is to have two
hooking applications, 32-bit and 64-bit, each providing its own DLL with the correct bitness. Another
option is to use just one installing application, but that causes the other bitness processes to make a
remote call back to the hooking application which must pump messages. This works, but is slower,
and the callback is not running in the context of a target process. Check out the documentation for
more details.
The return value of SetWindowsHookEx is a handle to the hook, or NULL if the function fails. The nice
thing about SetWindowsHookEx is that the DLL (if provided) is automatically injected by Win32k.sys
behind the scenes. This is considerably less visible than using something like CreateRemoteThread.
SetWindowsHookEx is not perfect. Here are a few of its shortcomings:
• It can only be used on processes that load user32.dll. Processes that don’t have a GUI typically
don’t load user32.dll.
• The global hooks are “global” to all threads that use the caller’s desktop. Thus, it cannot hook
processes in other sessions, even if they have a GUI.
DLL Injecting and Hooking with SetWindowsHookEx
The following example uses SetWindowsHookEx with the WH_GETMESSAGE hook type to inject a DLL
into the first Notepad process found, and monitor all keys typed in. These keys are sent to the
monitoring application, which effectively sees every key stroke made by the user in Notepad.
There are two projects involved in this system. The injecting executable (HookInject) and the DLL
to be injected indirectly with SetWindowsHookEx (HookDll). Lets’ start with the injecting application.
To test these, run Notepad first, and then run HookInject. Now start typeing in Notepad. You’ll see
the same text echoed in the console window of HookInject (figure 15-10).

Chapter 15: Dynamic Link Libraries
96
Figure 15-10: Notepad hooked
You can make sure the DLL is in fact injected by looking it up Notepad in Process Explorer and
examine the loaded modules (figure 15-11).

Chapter 15: Dynamic Link Libraries
97
Figure 15-11: Injected DLL in Notepad’s process
The first order of business is to locate the first thread of the first Notepad instance, since we need to
get information on messages processes by Notepad’s UI, handled by Notepad’s first thread. To this
end, we can write a thread enumeration function using the Toolhelp API and locate that thread:
DWORD FindMainNotepadThread() {
auto hSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
if (hSnapshot == INVALID_HANDLE_VALUE)
return 0;
DWORD tid = 0;
THREADENTRY32 th32;
th32.dwSize = sizeof(th32);
::Thread32First(hSnapshot, &th32);
do {
auto hProcess = ::OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION,
FALSE, th32.th32OwnerProcessID);
if (hProcess) {
WCHAR name[MAX_PATH];
if (::GetProcessImageFileName(hProcess, name, MAX_PATH) > 0) {
auto bs = ::wcsrchr(name, L'\\');
if (bs && ::_wcsicmp(bs, L"\\notepad.exe") == 0) {
tid = th32.th32ThreadID;

Chapter 15: Dynamic Link Libraries
98
}
}
::CloseHandle(hProcess);
}
} while (tid == 0 && ::Thread32Next(hSnapshot, &th32));
::CloseHandle(hSnapshot);
return tid;
}
CreateToolhelp32Snapshot is used with TH32CS_SNAPTHREAD to enumerate all threads in the system
(the API does not support enumerating threads in a specific process). For each thread, a handle
to the parent process is opened. If successful, the image path of the executable is looked up with
GetProcessImageFileName. If this ends in \Notepad.exe, then the thread ID is returned, since it would
be the first thread.
Now the main function can get to work. It starts by calling FindMainNotepadThread:
int main() {
DWORD tid = FindMainNotepadThread();
if (tid == 0)
return Error("Failed to locate Notepad");
Next, the DLL to be injected is loaded and two exported functions are extracted:
auto hDll = ::LoadLibrary(L"HookDll");
if (!hDll)
return Error("Failed to locate Dll\n");
using PSetNotify = void (WINAPI*)(DWORD, HHOOK);
auto setNotify = (PSetNotify)::GetProcAddress(hDll, "SetNotificationThread");
if (!setNotify)
return Error("Failed to locate SetNotificationThread function in DLL");
auto hookFunc = (HOOKPROC)::GetProcAddress(hDll, "HookFunction");
if (!hookFunc)
return Error("Failed to locate HookFunction function in DLL");
SetNotificationThread is a function exported from the DLL that will be used later to communicate
information from the Notepad process to the injector/monitoring process. HookFunction is the hook
function itself that must be passed to SetWindowsHookEx.
It’s time to install the hook:

Chapter 15: Dynamic Link Libraries
99
auto hHook = ::SetWindowsHookEx(WH_GETMESSAGE, hookFunc, hDll, tid);
if (!hHook)
return Error("Failed to install hook");
The hook type is WH_GETMESSAGE which is useful for intercepting messages destined to windows
created by the hooked thread. An added bonus of this hook is the ability of the hook function to
change the message if desired before it reached its destination.
At this point the hook DLL is injected automatically into Notepad’s process when the next message
is send to Notepad’s window, and the hook function will be called for each message. What can the
hook function do with the message information? The simplest option would be to simply write it to
some file. However, to make it a bit more interesting, the hook function notifies the injecting process
of all keystrokes by using thread messages. The hook function (inside Notepad’s process) needs to
know to which thread to send the messages. This is the role of SetNotificationThread, which is
now invoked:
setNotify(::GetCurrentThreadId(), hHook);
::PostThreadMessage(tid, WM_NULL, 0, 0);
SetNotificationThread is passed two pieces of information: the caller’s thread ID to receive
messages, and the hook handle itself that will be needed by the hook function as we’ll soon see.
If you’re paying attention, the call does not make entire sense, since it calls SetNotificationThread
in the local process - the DLL was loaded into this process, but the information conveyed by these
two parameters should be available in the context of the Notepad process. What gives? We’ll solve
this conundrum soon.
The call to PostThreadMessage is a trick to wake up Notepad with a dummy message (WM_NULL) that
will force it to load out hook DLL, if it wasn’t loaded already.
PostThreadMessage is function that allows sending a window message to a thread. Normal messages
are targeted at a window (using the window handle). With PostThreadMessage, the window handle
is effectively NULL. The rest of the parameters are the same as for other window message sending
functions, such as SendMessage and PostMessage. For thread messages, there is no “SendThreadMes-
sage”, meaning PostThreadMessage is asynchronous in nature - it puts the message in the target
thread’s queue and returns immediately. With messages targeted at a window handle, there is more
flexibility - SendMessage is synchronous while PostMessage is asynchronous.
All that’s left to do now is wait for incoming messages from the hooked Notepad and handle them
in some way:

Chapter 15: Dynamic Link Libraries
100
MSG msg;
while (::GetMessage(&msg, nullptr, 0, 0)) {
if (msg.message == WM_APP) {
printf("%c", (int)msg.wParam);
if (msg.wParam == 13)
printf("\n");
}
}
::UnhookWindowsHookEx(hHook);
::FreeLibrary(hDll);
return 0;
}
GetMessage examines the message queue of the current thread and only returns if a message is there.
Since the current thread has no windows, any message is destined for the thread, coming from the
Notepad process. GetMessage returns if a message is available other than WM_QUIT. We would want
WM_QUIT to be posted by the hook function if the Notepad process is terminating.
The expected message is WM_APP (0x8000), which is guaranteed to be unused by standard window
message constants, and it’s the one that is posted from the hook function (as we shall soon see). The
wParam member of the MSG structure holds the key (again, provided by the hook function), and the
application just echos it to the console.
Finally, when WM_QUIT message is received, the process cleans up by unhooking the hook and
unloading the DLL.
Now let’s turn our attention to the hook DLL. The conundrum we had earlier is solved by having
some global shared variables that are part of the DLL:
#pragma data_seg(".shared")
DWORD g_ThreadId = 0;
HHOOK g_hHook = nullptr;
#pragma data_seg()
#pragma comment(linker, "/section:.shared,RWS")
This technique of sharing variables in a DLL (or EXE) was described in chapter 12. The injecting
application called SetNotificationThread in the context of its own process, but the function writes
the information to the shared variables, so these are available to any process using the same DLL:

Chapter 15: Dynamic Link Libraries
101
extern "C" void WINAPI SetNotificationThread(DWORD threadId, HHOOK hHook) {
g_ThreadId = threadId;
g_hHook = hHook;
}
This arrangement is depicted in figure 15-12.
Figure 15-12: Injeting and injected processes
The DllMain function is implemented like so:
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, PVOID pReserved) {
switch (reason) {
case DLL_PROCESS_ATTACH:
::DisableThreadLibraryCalls(hModule);
break;
case DLL_PROCESS_DETACH:
::PostThreadMessage(g_ThreadId, WM_QUIT, 0, 0);
break;
}
return TRUE;
}
First, it calls DisableThreadLibraryCalls when attached to the process, indicating the DLL does
not care about thread creation/destruction. When unloaded, probably because Notepad is exiting, a
WM_QUIT message is sent to the injector’s thread, that causes its GetMessage call to return FALSE.
The interesting work is done by the hook function:

Chapter 15: Dynamic Link Libraries
102
extern "C" LRESULT CALLBACK HookFunction(int code, WPARAM wParam, LPARAM lParam) {
if (code == HC_ACTION) {
auto msg = (MSG*)lParam;
if (msg->message == WM_CHAR) {
::PostThreadMessage(g_ThreadId, WM_APP, msg->wParam, msg->lParam);
// prevent 'A' characters from getting to the app
//if (msg->wParam == 'A' || msg->wParam == 'a')
//
msg->wParam = 0;
}
}
return ::CallNextHookEx(g_hHook, code, wParam, lParam);
}
Every hook function used with SetWindowsHookEx has the same prototype, but the rules are not the
same. You should always read carefully the documentation for the particular hook callback. In our
case (WH_GETMESSAGE), if code is HC_ACTION, the hook should process the notification. The message
is packed into the lParam value. If the message is WM_CHAR, indicating a “printable” character, the
callback posts a message to the injector’s thread with the message information (wParam holds the
key itself).
The commented code shows how simple it is to change the message so that the key never reaches
Notepad’s thread. Finally, the call to CallNextHookEx is recommended to allow other hook functions
that may be in the chain of hooks to get a chance to do their work. However, this is not mandatory.
API Hooking
The term API Hooking refers to the act of intercepting Windows APIs (or, more generally, any
external function), so that its arguments can be inspected and its behavior possibly changed. This
is an extremely powerful technique, employed first and foremost by anti-malware solutions, that
typically inject their own DLL into every process (or most processes) and hook certain functions that
they care about, such as VirtualAllocEx and CreateRemoteThread, redirecting them to an alternate
implementation provided by their DLL. In that implementation, they can check parameters and do
whatever they need before returning a failure code to the caller or forwarding the call to the original
function.
In this section, we’ll take a look at two common techniques to hook functions.
IAT Hooking
Import Address Table (IAT) hooking is probably the simplest approach to function hooking. It’s
relatively simple to set up and does not require any platform-specific code.
Every PE image has an import table that lists the DLLs it depends on, and the functions it uses from
DLLs. You can view these imports by examining the PE file with Dumpbin or a graphical tool. Here
is an excerpt from Notepad.exe’s modules:

Chapter 15: Dynamic Link Libraries
103
dumpbin /imports c:\Windows\System32\notepad.exe
Microsoft (R) COFF/PE Dumper Version 14.26.28805.0
Copyright (C) Microsoft Corporation.
All rights reserved.
Dump of file c:\Windows\System32\notepad.exe
File Type: EXECUTABLE IMAGE
Section contains the following imports:
KERNEL32.dll
1400268B0 Import Address Table
14002D560 Import Name Table
0 time date stamp
0 Index of first forwarder reference
2B7 GetProcAddress
DB CreateMutexExW
1 AcquireSRWLockShared
113 DeleteCriticalSection
220 GetCurrentProcessId
2BD GetProcessHeap
...
GDI32.dll
1400267F8 Import Address Table
14002D4A8 Import Name Table
0 time date stamp
0 Index of first forwarder reference
34 CreateDCW
39F StartPage
39D StartDocW
366 SetAbortProc
...
USER32.dll
140026B50 Import Address Table
14002D800 Import Name Table
0 time date stamp
0 Index of first forwarder reference
157 GetFocus
2AF PostMessageW
177 GetMenu

Chapter 15: Dynamic Link Libraries
104
43 CheckMenuItem
...
The output above shows the functions used by Notepad from each module Notepad depends on.
Each module, in turn, has its own import table. Here is the example for User32.dll:
dumpbin /imports c:\Windows\System32\User32.dll
Microsoft (R) COFF/PE Dumper Version 14.26.28805.0
Copyright (C) Microsoft Corporation.
All rights reserved.
Dump of file c:\Windows\System32\user32.dll
File Type: DLL
Section contains the following imports:
win32u.dll
180092AD0 Import Address Table
1800AA0B0 Import Name Table
0 time date stamp
0 Index of first forwarder reference
297 NtMITSetInputDelegationMode
29B NtMITSetLastInputRecipient
363 NtUserEnableScrollBar
4FA NtUserTestForInteractiveUser
501 NtUserTransformRect
384 NtUserGetClassName
...
ntdll.dll
180092700 Import Address Table
1800A9CE0 Import Name Table
0 time date stamp
0 Index of first forwarder reference
8C5 __chkstk
95F toupper
936 memcmp
96A wcscmp
937 memcpy
5A1 RtlSetLastWin32Error
BB NlsAnsiCodePage

Chapter 15: Dynamic Link Libraries
105
...
GDI32.dll
180091C58 Import Address Table
1800A9238 Import Name Table
0 time date stamp
0 Index of first forwarder reference
309 PatBlt
36C SetBkMode
364 SelectObject
2E3 IntersectClipRect
...
The way these imported functions are called is thorugh the Import Address Table, which contains
the final addresses of these functions once the loader (NtDll.Dll) has mapped them at runtime. These
addresses are not known in advance, since the DLLs may not load at their preferred address (see the
section “DLL Base Address”, later in this chapter).
IAT hooking exploits the fact that all calls are indirect, and just replaces the function address in
the table at runtime to point to an alternate function, while saving the original address so that
implemenetation can be invoked if desired. This hooking can be done on the current process or
combined with DLL injection can be peformed in another process’ context.
The functions to hook must be searched in all process modules because each module has its own
IAT. For example, the function CreateFileW can be called by the Notepad.exe module itself, but it
can also be called by ComCtl32.dll when the Open File dialog box is invoked. If only Notepad’s
invocations are of interest, its IAT is the only one that needed to be hooked. Otherwise, all loaded
modules must be searched and their IAT entry for CreateFileW must be replaced.
To demonstrate this technique, I’ve copied the Working Sets application from chapter 13 to
this chapter’s Visual Studio solution. We will hook the GetSysColor API from User32.Dll for
demonstration purposes and change a couple of colors in the application without touching the
application’s UI code.
In the WinMain function we call a helper fucntion presented later to do the hooking. First, we need a
variable to save the original function pointer
decltype(::GetSysColor)* GetSysColorOrg;
The decltype keyword (C++ 11+) saves typing and errors by obtaining the correct type of the
expression in paranthesis, in this case the type of GetSysColor. Now we can start by getting the
original function:

Chapter 15: Dynamic Link Libraries
106
void HookFunctions() {
auto hUser32 = ::GetModuleHandle(L"user32");
// save original functions
GetSysColorOrg = (decltype(GetSysColorOrg))::GetProcAddress(
hUser32, "GetSysColor");
And the hooking itself is simple because of some helpers functions we’ll soon see:
auto count = IATHelper::HookAllModules("user32.dll",
GetSysColorOrg, GetSysColorHooked);
ATLTRACE(L"Hooked %d calls to GetSysColor\n");
}
GetSysColorHooked is our hook replacement function for GetSysColor. It must have the same
prototype, as the original. Here is our custom implementation:
COLORREF WINAPI GetSysColorHooked(int index) {
switch (index) {
case COLOR_BTNTEXT:
return RGB(0, 128, 0);
case COLOR_WINDOWTEXT:
return RGB(0, 0, 255);
}
return GetSysColorOrg(index);
}
The hooked function returns different colors for a couple of indices, and invokes the original function
for all other inputs.
The secret, of course, is in IATHelper::HookAllModules. This function and another helper is part
of a static library named IATHelper, also part of the same solution and linked to the WorkingSets
project. Here is the class declaration:

Chapter 15: Dynamic Link Libraries
107
// IATHelper.h
struct IATHelper final abstract {
static int HookFunction(PCWSTR callerModule, PCSTR moduleName,
PVOID originalProc, PVOID hookProc);
static int HookAllModules(PCSTR moduleName, PVOID originalProc, PVOID hookProc);
};
HookFunction’s task is to hook a single function called by a single module. HookAllModules iterates
over all currently loaded modules in the process and invokes HookFunction. HookAllModules accepts
the module name in which the function to hook is exported from (user32.dll in our case). Notice it’s
passed as an ASCII string rather than Unicode, because the module names are stored in ASCII in
the import table. The next parameters are the original function (so it can be located in the import
tables), and the new function to replace the old one.
int IATHelper::HookAllModules(PCSTR moduleName, PVOID originalProc, PVOID hookProc) {
HMODULE hMod[1024];
// should be enough (famous last words)
DWORD needed;
if (!::EnumProcessModules(::GetCurrentProcess(), hMod, sizeof(hMod), &needed))
return 0;
assert(needed <= sizeof(hMod));
WCHAR name[256];
int count = 0;
for (DWORD i = 0; i < needed / sizeof(HMODULE); i++) {
if (::GetModuleBaseName(::GetCurrentProcess(), hMod[i], name, _countof(name)\
)) {
count += HookFunction(name, moduleName, originalProc, hookProc);
}
}
return count;
}
The function is fairly simple. It enumerates the modules in the current process with the PSAPI
function EnumProcessModules declared like so:

Chapter 15: Dynamic Link Libraries
108
BOOL EnumProcessModules(
_In_ HANDLE hProcess,
_Out_ HMODULE* lphModule,
_In_ DWORD cb,
_Out_ LPDWORD lpcbNeeded);
EnumProcessModules fills the provided lphModule array up to the size set by cb, and returns the
required size in lpcbNeeded. If the returned size is greater than cb, then some modules were not
returned, and the caller should re-allocated and enumerate again. In my code, I’ve assumed no more
than 1024 modules for simplicity, but in production-level code this could miss modules. The process
handle must have the PROCESS_QUERY_INFORMATION access mask, which is never an issue for the
current process.
GetModuleBaseName is another function from PSAPI that returns the base name (excludes any path)
of a module:
DWORD GetModuleBaseName(
_In_ HANDLE hProcess,
_In_opt_ HMODULE hModule,
_Out_ LPTSTR lpBaseName,
_In_ DWORD nSize);
The HookFunction does all the hard work. It first gets the caller’s module handle to be used as the
basis for accessing its import table:
int IATHelper::HookFunction(PCWSTR callerModule, PCSTR moduleName,
PVOID originalProc, PVOID hookProc) {
HMODULE hMod = ::GetModuleHandle(callerModule);
if (!hMod)
return 0;
Now comes the tricky bits. The import table must be located by parsing the PE file. Fortunately, some
of this parsing logic is available by some APIs from dbghelp and imagehlp. In this case, a dbghelp
function is used to get to the import table quickly:
ULONG size;
auto desc = (PIMAGE_IMPORT_DESCRIPTOR)::ImageDirectoryEntryToData(hMod, TRUE,
IMAGE_DIRECTORY_ENTRY_IMPORT, &size);
if (!desc)
// no import table
return 0;

Chapter 15: Dynamic Link Libraries
109
Discussion of the PE file format is outside the scope of this chapter. More information can be found
in Appendix A. The full specification is documented at https://docs.microsoft.com/en-us/windows/
win32/debug/pe-format. Quite a few articles and blogs cover the format well.
ImageDirectoryEntryToData returns one of the so-called data directories, that are part of an image
PE. Here is its declaration:
PVOID ImageDirectoryEntryToData (
_In_ PVOID Base,
_In_ BOOLEAN MappedAsImage,
_In_ USHORT DirectoryEntry,
_Out_ PULONG Size);
Base is the base address of the module and as we know that’s the module’s “handle”. MappedAsImage
should be set to TRUE, because the image is mapped to the address space as a true image, rather than
loaded as a data file. DirectoryEntry is the index of the data directory to retrieve, and Size returns
the data directory’s size. The return value from the function is the virtual address where the data
directory is located.
The import table for a specific module may contain many imported libraries this module depends
on. We need to locate just the one where are function is. It’s user32.dll in the WorkingSet example.
The IMAGE_IMPORT_DESCRIPTOR is the structure the heads the import library, from which our search
begins:
int count = 0;
for (; desc->Name; desc++) {
auto modName = (PSTR)hMod + desc->Name;
if (::_stricmp(moduleName, modName) == 0) {
The code loops through all the modules and compares their names to the module in question.
The module name is stored as ASCII, which is why we passed it to HookFunction as such. The
Name member of IMAGE_IMPORT_DESCRIPTOR is the offset where the module name is stored from the
module’s beginning.
Now that the module is found, we need to iterate over all imported functions, looking for our original
function pointer:

Chapter 15: Dynamic Link Libraries
110
auto thunk = (PIMAGE_THUNK_DATA)((PBYTE)hMod + desc->FirstThunk);
for (; thunk->u1.Function; thunk++) {
auto addr = &thunk->u1.Function;
if (*(PVOID*)addr == originalProc) {
// found it
The code is not very pretty and is based on the data structures that make up information in the PE
- IMAGE_THUNK_DATA in this case. Each one of these “thunks” stores the address of a function, and so
we compare it with the original function we received. If they are equal, we have our match:
DWORD old;
if (::VirtualProtect(addr, sizeof(void*), PAGE_WRITECOPY, &old)) {
*(void**)addr = (void*)hookProc;
count++;
}
}
}
break;
}
We need to replace the existing value with the new value. However, the pages of the import table
are protected with PAGE_READONLY, so we must replace that with PAGE_WRITECOPY to get our own
writable copy of the page we have to access.
The structures and layout of members is based on the PE file format documentation.
Combine API hooking with DLL injection from the previous section to hook GetSysColor
in a Notepad process, rather than the current process. Try hooking other functions!
What’s the downside of IAT based hooking? First, if a new module is loaded later, it must be hooked
as well. Paradoxically, this can be done by hooking LoadLibraryW, LoadLibraryExW and LdrLoadDll
(undocumented from NtDll.dll, but possibly used).
Second, It’s easy to circumvent by avoiding the IAT - by calling the API directly with the function
pointer returned from GetProcAddress. This means calling the original GetSysColor function could
have been done with this code:

Chapter 15: Dynamic Link Libraries
111
return ((decltype(::GetSysColor)*)::GetProcAddress(GetModuleHandle(L"user32"),
"GetSysColor"))(index);
If the hooking is done for security purposes, then IAT hooking is probably unacceptable because it’s
easily circumvented. If the need is for something else, where normal code uses functions without
calling GetProcAddress, IAT hooking is convenient and reliable.
“Detours” Style Hooking
The other common way of hooking a function is by following these steps:
• Locate the original function’s address and save it.
• Replace the first few bytes of the code with a JMP assembly instruction, saving the old code.
• The JMP instruction calls the hooked function.
• If the original code is to be invoked, do so with the saved address from the first step.
• When unhooking, restore the modified bytes.
This scheme is more powerful that IAT hooking because the real function code is modified, whether
it’s called through the IAT or not. There are two drawbacks to this method:
• The replaced code is platform-specific. The code for x86, x64, ARM and ARM64 is different,
making it more difficult to get right.
• The steps above must be done atomically. There could be some other thread in the process that
invokes the hooked function just as assembly bytes are being replaced. This is likely to cause a
crash.
Implementing this hooking is difficult, and requires intricate knowledge of CPU instructions and
calling conventions, not to mention the synchronization problem above.
There are several open-source and free libraries that provide this functionality. One of them is called
“Detours” from Microsoft (hence the section name), but there are others like MinHook and EasyHook
which you can find online. If you need this kind of hooking, consider using an existing library rather
than rolling your own.
To demonstrate hooking with the Detours library, we’ll use the Basic Sharing application from
chapter 14. We’ll hook two functions: GetWindowTextLengthW and GetWindowTextW. With the hooked
functions, the code will return a custom string for edit controls only.
The first step is to add support for Detours. Fortunately, this is easy through Nuget - just search for
“detours” and you shall receive (figure 15-13).

Chapter 15: Dynamic Link Libraries
112
Figure 15-13: Detours library in Nuget package manager
Setting up the hooks is fairly straighforward. Here is the helper function that does it:
#include <detours.h>
bool HookFunctions() {
DetourTransactionBegin();
DetourUpdateThread(GetCurrentThread());
DetourAttach((PVOID*)&GetWindowTextOrg, GetWindowTextHooked);
DetourAttach((PVOID*)&GetWindowTextLengthOrg, GetWindowTextLengthHooked);
auto error = DetourTransactionCommit();
return error == ERROR_SUCCESS;
}
Detours works with the concept of transactions - a set of operations that are committed to be
executed atomically. We need to save the original functions. This can be done with GetProcAddress
prior to hooking or right with the pointers definitions:
decltype(::GetWindowTextW)* GetWindowTextOrg = ::GetWindowTextW;
decltype(::GetWindowTextLengthW)* GetWindowTextLengthOrg = ::GetWindowTextLengthW;
The hooked functions provide some implementation. Here is what this demo does:
static WCHAR extra[] = L" (Hooked!)";
bool IsEditControl(HWND hWnd) {
WCHAR name[32];
return ::GetClassName(hWnd, name, _countof(name)) &&
::_wcsicmp(name, L"EDIT") == 0;
}
int WINAPI GetWindowTextHooked(
_In_
HWND
hWnd,

Chapter 15: Dynamic Link Libraries
113
_Out_ LPWSTR lpString,
_In_
int
nMaxCount) {
auto count = GetWindowTextOrg(hWnd, lpString, nMaxCount);
if (IsEditControl(hWnd)) {
if (count + _countof(extra) <= nMaxCount) {
::StringCchCatW(lpString, nMaxCount, extra);
count += _countof(extra);
}
}
return count;
}
int WINAPI GetWindowTextLengthHooked(HWND hWnd) {
auto len = GetWindowTextLengthOrg(hWnd);
if(IsEditControl(hWnd))
len += (int)wcslen(extra);
return len;
}
The hooked GetWindowTextW adds the extra string to edit controls only. If you run Basic Sharing
now, type “hello” in the edit box, click Write and click Read, you’ll get what figure 15-14 shows.
Figure 15-14: A hooked Basic Sharing
The Write button click handler calls GetDlgItemText which calls GetWindowText, which invokes the
hooked function.
Use Detours to hook Notepad similarly to Basic Sharing.

Chapter 15: Dynamic Link Libraries
114
DLL Base Address
Every DLL has a preferred load (base) address, that is part of the PE header. It can even be specified
using the project’s properties in Visual Studio (figure 15-15).
Figure 15-15: Setting a DLL’s base address in Visual Studio
There is nothing there by default, which makes Visual Studio use some default values. These are
0x10000000 for 32-bit DLLs and 0x180000000 for 64-bit DLLs. You can verify these by dumping
header information from the PE:
dumpbin /headers c:\dev\Win10SysProg\Chapter15\x64\Debug\HookDll.dll
...
OPTIONAL HEADER VALUES
20B magic # (PE32+)
...
112FD entry point (00000001800112FD) @ILT+760(_DllMainCRTStartup)
1000 base of code
180000000 image base (0000000180000000 to 0000000180025FFF)
...

Chapter 15: Dynamic Link Libraries
115
dumpbin /headers c:\dev\Win10SysProg\Chapter15\Debug\HookDll.dll
...
OPTIONAL HEADER VALUES
10B magic # (PE32)
...
111B8 entry point (100111B8) @ILT+435(__DllMainCRTStartup@12)
1000 base of code
1000 base of data
10000000 image base (10000000 to 1001FFFF)
...
In the old days (pre-Vista), when Address Space Load Randomization (ASLR) didn’t exist, DLLs
insisted on loading to their preferred address. If that address was already occupied by some other
DLL or data, the DLL went through relocation. The loader had to find a new location for the DLL
in the process address space. Furthermore, it would have to perform code fixups (stored in the PE
by the linker), because some code had to change. For example, a string that was expected to be in
address x now has moved to some other address y, that the loader had to fix. These fixes take time,
and extra memory because the code in that page can no longer be shared.
In Process Explorer, relocated DLLs are easy to spot. First, there is a yellowish color you can enable
called “Relocated DLLs” and appears in the Modules (DLLs) view for every relocated DLLs. Second,
the sure way to recognize relocated DLLs is where the Image Base column is different than Base
(figure 15-16).

Chapter 15: Dynamic Link Libraries
116
Figure 15-16: Relocated DLLs in Process Explorer
I’ve chosen Visual Studio’s process (devenv.exe) in figure 15-16, which shows lots of relocated DLLs.
However, this is not as common as it used to be in the old days. Most processes have very few
relocated DLLs.
The solution to the relocation problem was selecting different addresses for different DLLs, to
minimize the chance of collisions. This was sometimes done with the rebase.exe tool, part of the
Windows SDK, that can perform the operation on multiple DLLs at the same time. The tool does
not require source code, since it manipulates the PE. The functionality of the rebase.exe tool is
available programmatically with the ReBaseImage64 function from the debug help API.
Most DLLs have the Dynamic Base characteristic flag that indicates the DLL is ok with relocation.
With ASLR, the loader selects an address that does not conflict with previously selected DLLs, so the
likelihood of collisions is very low, since the addresses used start for a high address and move down
for each loaded DLL. A DLL can specify it wants a fixed address so that relocation is forbidden, but
that may cause the DLL to fail to load if ots preferred address range is taken. There should be a very
good reason for a DLL to insist on a fixed base address.
Delay-Load DLLs
We have examined the two primary ways to link to a DLL: either implicit linking with a LIB file
(easiest and most convenient), and dynamic linking (loading the DLL explictly and locating functions
to use). It turns out there is a third way, sort of a “middle ground” between static and dynamic linking
- delay-load DLLs.

Chapter 15: Dynamic Link Libraries
117
With delay-loading, we get the benefits of both options: the convenience of static linking with
dynamic loading of the DLL only in case it’s needed.
To use delay-load DLLs, some changes are required to the modules that use these DLLs, whether
that’s an executable or another DLL. The DLLs that should be delay-loaded are added to the linker’s
options in the Input tab (figure 15-17).
Figure 15-17: Specifying delay-load DLLs in project’s properties
If you want to support dynamic unloading of delay-load DLLs, add that option in the Advanced
linker tab (“Unload delay loaded DLL”).
All that’s left is to link with the import libraries (LIB) files of the DLLs and use the exported
functionality just like you would an implicitly linked DLL.
Here is an example from the project SimplePrimes2 that delay-load links with SimpleDll.Dll:

Chapter 15: Dynamic Link Libraries
118
#include "..\SimpleDll\Simple.h"
#include <delayimp.h>
bool IsLoaded() {
auto hModule = ::GetModuleHandle(L"simpledll");
printf("SimpleDll loaded: %s\n", hModule ? "Yes" : "No");
return hModule != nullptr;
}
int main() {
IsLoaded();
bool prime = IsPrime(17);
IsLoaded();
printf("17 is prime? %s\n", prime ? "Yes" : "No");
__FUnloadDelayLoadedDLL2("SimpleDll.dll");
IsLoaded();
prime = IsPrime(1234567);
IsLoaded();
return 0;
}
The strange-looking function __FUnloadDelayLoadedDLL2 (from delayimp.h) is the one to use to
unload a delay-load DLL. If you call FreeLibrary, the DLL will unload; however it will not load
again if needed just by invoking an exported function, and instead will throw an access violation
exception.
Running the above program shows:
SimpleDll loaded: No
SimpleDll loaded: Yes
17 is prime? Yes
SimpleDll loaded: No
SimpleDll loaded: Yes
When you call an exported function from a delay-load DLL, there is a different function that
is being called (provided by the delay-load infrastructure), that knows to call LoadLibrary and
GetProcAddress and then invoke the function, fixing the import table so that future calls to the
same function go directly to its implementation. This also explains why unloaded a delay-loaded
DLL must be done with a special function that can return the initial behavior into play.

Chapter 15: Dynamic Link Libraries
119
The LoadLibraryEx Function
LoadLibraryEx is an extended LoadLibrary function defined like so:
HMODULE LoadLibraryEx(
_In_ LPCTSTR lpLibFileName,
_Reserved_ HANDLE hFile,
// must be NULL
_In_ DWORD dwFlags);
LoadLibraryEx has the same purpose as LoadLibrary: to load a DLL explicitly. As you can see,
LoadLibraryEx supports a set of flags that affect the way the DLL in question is searched for and/or
loaded. Some of the acceptable flags are from table 15-1, where the search path and order can be
modified to some extent. Here are some other possibly useful flags (check the documentation for a
complete list):
• LOAD_LIBRARY_AS_DATAFILE - this flag indicates the DLL should just be mapped to the process
address space, but its PE image properties disregarded. DllMain is not called, and functions
such as GetModuleHandle or GetProcAddress fail on the returned handle.
• LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE - similar to LOAD_LIBRARY_AS_DATAFILE, but the file is
opened with exclusive access so that other processes cannot modify it while it’s loaded.
• LOAD_LIBRARY_AS_IMAGE_RESOURCE - loads the DLL as an image file, but does not perform any
initialization such as calling DllMain. This flag is usually specified with LOAD_LIBRARY_AS_-
DATAFILE for the purpose of extracting resources.
• LOAD_WITH_ALTERED_SEARCH_PATH - if the path specified is absolute, that path is used as a basis
for search.
When using LOAD_LIBRARY_AS_IMAGE_RESOURCE, the returned handle can be used to extract resources
with APIs such as LoadString, LoadBitmap, LoadIcon, and similar. Custom resources are supported as
well, and in that case the functions to use include FindResource(Ex), SizeOfResource, LoadResource
and LockResource.
Miscellaneous Functions
In this section, we’ll go briefly over some other DLL-related functions you might find useful. We’ll
start with GetModuleFileName and GetModuleFileNameEx:

Chapter 15: Dynamic Link Libraries
120
DWORD GetModuleFileName(
_In_opt_ HMODULE hModule,
_Out_ LPTSTR lpFilename,
_In_ DWORD nSize);
DWORD GetModuleFileNameEx(
_In_opt_ HANDLE hProcess,
_In_opt_ HMODULE hModule,
_Out_
LPWSTR lpFilename,
_In_
DWORD nSize);
Both functions return the full path of a loaded module. GetModuleFileNameEx can access such
information in another process (the handle must have the PROCESS_QUERY_INFORMATION or PROCESS_-
QUERY_LIMITED_INFORMATION access mask). If hModule is NULL, the main module path is returned (the
executable path). If a list of modules are needed, EnumProcessModules can be used (shown earlier in
this chapter).
The LoadPackagedLibrary (Windows 8+) is a variant on LoadLibrary that may be used by a UWP
process to load a DLL which is part of its package:
HMODULE LoadPackagedLibrary (
_In_
LPCWSTR lpwLibFileName,
_Reserved_ DWORD Reserved);
// must be zero
If a thread needs to unload a DLL in which its code is running, it cannot use the function pair
FreeLibrary and then ExitThread, because once FreeLibrary returns, the thread’s code would no
longer be part of the process, and a crash would occur. To solve this, use FreeLibraryAndExitThread:
VOID FreeLibraryAndExitThread(
_In_ HMODULE hLibModule,
_In_ DWORD dwExitCode);
The function frees the specified module and then calls ExitThread, which means this function never
returns.
Summary
In this chapter, we looked at DLLs - how to build them and how to use them. We’ve also seen the
ability to inject a DLL into another process, which gives that DLL a lot of power in the target process.
In the next chapter, we’ll turn our attention to a completely different topic: security.

Chapter 16: Security
Windows NT was built with security in mind from its initial design. That was contrary to the
Windows 95/98 family of operating systems that did not support security. Windows adheres to the
C2 level security, defined by the US Department of Defence. C2 is the highest level a general-purpose
operating system can attain.
Some of the requirements of C2 are as follows:
• Logging into the system must require some form of authentication.
• A dead process’ memory should never be revealed to another process.
• There must be a file system with the ability to set permissions on file system objects.
In this chapter, we’ll examine the foundations of Windows security and look at many of the APIs
used to manipulate it.
In this chapter:
• Introduction
• SIDs
• Tokens
• Access Masks
• Privileges
• Security Descriptors
• User Account Control
• Integrity Levels
• Specialized Security Mechanisms

Chapter 16: Security
122
Introduction
There are several components in Windows that are related to security. Figure 16-1 shows most of
them.
Figure 16-1: Security-related components
Here is a quick rundown of the major components in figure 16-1:
WinLogon
The logon process (Winlogon.exe) is responsible for interactive logons. It’s also responsible for
responding to the Secure Attention Sequence (SAS, by default Ctrl+Alt+Del) key combination by
switching to the Winlogon desktop where it shows the familiar options (lock, switch user, sign out,
etc.).
Winlogon gets the credentials from the user with a helper process, LogonUI.exe (see next section),
and sends them to Lsass.exe for authentication. If authentication succeeds, Lsass creates a logon
session and an access token (discussed later in this chapter), that represents the security context
of the user. Then it creates the startup process (by default userinit.exe, read from the Registry),
which in turn creates Explorer.exe (again, this is just the default in the Registry). The access token
is duplicated for each newly created process. Figure 16-2 shows part of a system’s initialization
process tree, generated with the Process Monitor (ProcMon.exe) tool from Sysinternals. Notice the
connection between WinLogon, UserInit and Explorer.

Chapter 16: Security
123
Figure 16-2: Logon process tree
Userinit also runs startup scripts and then terminates (this is why Explorer is normally parentless).
The
Registry
key
with
the
above-mentioned
settings
is
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon.
LogonUI
Windows support several ways to log in: username/password, “Windows Hello” using face recog-
nition and fingerprint to name a few. The LogonUI.exe process is launched by Winlogon to present
the selected authentication method UI. In the old days (prior to Windows Vista), Winlogon was in
charge of that (LogonUI didn’t exist). The problem was that is the UI component crashed, it would
being Winlogon down with it. Starting with Vista, if the UI crashes, LogonUI is terminated, and
Winlogon allows the user to select a different method of authentication.
LogonUI displays the UI provided by a Credential Provider - a COM DLL that implements some
user interface for its associated authentication mechanism. Credential providers may be developed
by anyone where a custom method for authentication is needed.
LSASS
The Local Security Authentication Service (lsass.exe) is the cornerstone of authentication manage-
ment. Its most fundamental role is to authenticate the user. In the common case of a username/pass-
word combination, Lsass examines the local Registry (in case of a local logon), or communicates with
a Domain Controller (domain logon), to authenticate the user. Then it returns the result to Winlogon.
If the authentication succeeded, it creates and populates the access token for the logged-in user.

Chapter 16: Security
124
LsaIso
The LsaIso.exe process exists in a Windows 10 (or later) system that has Virtualization Based Security
(VBS) active with the Credential Guard feature turned on. LsaIso is known as a trustlet, a user-mode
process running in Virtual Trust Level (VTL) 1, where the secure kernel and the isolated user mode
(IUM) reside. As an IUM process, Lsaiso access is protected by the Hyper-V hypervisor, so it’s not
accessible even from the kernel. The purpose of Lsaiso is to keep secrets for Lsass, so certain types
of attacks like “pass the hash” are mitigated, since no process (not even admin level) and not even
the kernel can peer into Lsaiso’s address space.
There are many new terms in the above paragraph that are not explained in this book, as they have
very little to do with system programming. For further info on VBS, Hyper-V, VTL, and related
concepts, please consult the “Windows Internals 7ʰ edition Part 1” book and/or online resources.
Security Reference Monitor
The SRM is the part of the executive responsible for access checks needed when certain operations
occur. For example, trying to open a handle to an existing kernel object requires an access check,
performed by the SRM.
Event Logger
The event logger service is one of the standard services provided by Windows. It’s not specific to
security, but security events are logged using this service. The common way to view information in
the log is using the Event Viewer built-in application, shown in figure 16-3 (with the Security node
selected).

Chapter 16: Security
125
Figure 16-3: The Event Viewer application
SIDs
The term principal describes an entity that can be referred to in a security context. For example,
permissions can be granted or denied to a principal. Principals can represent users, groups,
computers, and more. A principal is uniquely identified by a Security ID (SID), which is a variable-
sized structure that contains several parts, depicted in figure 16-4.
Figure 16-4: SID

Chapter 16: Security
126
When displayed as a string a SID looks like the following:
S-R-A-SA-SA-…-SA
“S” is a literal S, the revision (R) is always one (the revision never changed), “A” is a 6-byte authority
that generated the SID, and “SA” is an array of 4-byte sub-authorities (also called Relative IDs - RID)
unique to the authority which generated them. Although a SID’s size depends on the number of
sub-authorities, the maximum count of sub-authorities is currently 15, giving a cap to the size of a
SID. This helps in cases where you need to allocate a buffer to hold a SID, and you’d rather allocate
it statically rather than dynamically. Here are the definitions from winnt.h:
#define SID_MAX_SUB_AUTHORITIES
(15)
#define SECURITY_MAX_SID_SIZE
\
(sizeof(SID)-sizeof(DWORD)+(SID_MAX_SUB_AUTHORITIES*sizeof(DWORD))) // 68 bytes
SIDs are typically shown in their string form (it’s also usually easier to persist them as strings).
Converting between the binary and string forms can be done with the following functions (declared
in <sddl.h>):
BOOL ConvertSidToStringSid(
_In_ PSID Sid,
_Outptr_ LPTSTR* StringSid);
BOOL ConvertStringSidToSid(
_In_ LPCTSTR StringSid,
_Outptr_ PSID* Sid);
Both functions return a result that later must be freed by the caller with LocalFree.
Groups and Aliases
A group, represented by a SID, is a collection of principals. Every principal that belongs to the group
will have the group SID in its security context (see the section “Tokens” later in this chapter). This
helps in modeling organizational structures without specifying individual principles beforehand.
An alias (also called local group) is yet another container principal, that can hold a set of groups
and other principals (but not other aliases). For example, the local administrators group is actually
an alias, that can contain individual SIDs and group SIDs that are all part of the alias. Aliases are
always local to a machine and cannot be shared with other machines.
The distinction between groups and aliases is not that important in practice, but is worth keeping
in mind nonetheless.

Chapter 16: Security
127
SIDs are guaranteed to be statistically unique when representing different principals. Some SIDs are
called “Well-known” and they represent the same principal on every machine. Examples include
“S-1-1-0” (the Everyone group) and S-1-5-32-544 (the Local administrators alias). winnt.h defines an
enumeration, WELL_KNOWN_SID_TYPE, that holds the list of well-known SIDs. These SIDs exist so it’s
easy to refer to the same group of principals on any machine. (Imagine what would happen if every
machine had its own local administrators SID).
Creating a well-known SID is accomplished with CreateWellKnwonSid:
BOOL CreateWellKnownSid(
_In_ WELL_KNOWN_SID_TYPE WellKnownSidType,
_In_opt_ PSID DomainSid,
_Out_ PSID pSid,
_Inout_ DWORD* cbSid);
The DomainSid parameter is needed for some types of well-known SIDs. For most, NULL is an
acceptable value. The returned SID is placed in a caller’s allocated buffer. cnSid should contain
the size of the caller’s supplied buffer, and on return stores the actual size of the SID.
We can combine CreateWellKnownSid and ConvertSidToStringSid to list all well-known SIDs that
do not require a domain SID parameter:
BYTE buffer[SECURITY_MAX_SID_SIZE];
PWSTR name;
for (int i = 0; i < 120; i++) {
DWORD size = sizeof(buffer);
if (!::CreateWellKnownSid((WELL_KNOWN_SID_TYPE)i, nullptr, (PSID)buffer, &size))
continue;
::ConvertSidToStringSid((PSID)buffer, &name);
printf("Well known sid %3d: %ws\n", i, name);
::LocalFree(name);
}
The SID buffer is allocated statically with the maximum SID size. Here is a brief output:

Chapter 16: Security
128
Well known sid
0: S-1-0-0
Well known sid
1: S-1-1-0
Well known sid
2: S-1-2-0
Well known sid
3: S-1-3-0
...
Well known sid
20: S-1-5-14
Well known sid
22: S-1-5-18
Well known sid
23: S-1-5-19
...
Well known sid
36: S-1-5-32-555
Well known sid
37: S-1-5-32-556
Well known sid
51: S-1-5-64-10
Well known sid
52: S-1-5-64-21
Well known sid
53: S-1-5-64-14
...
Well known sid 118: S-1-18-3
Well known sid 119: S-1-5-32-583
The well-known SID WinLogonIdsSid (21) cannot be created.
A SID can be checked to see if it matches a specific well-known one with IsWellKnownSid:
BOOL IsWellKnownSid(
_In_ PSID pSid,
_In_ WELL_KNOWN_SID_TYPE WellKnownSidType);
We can also get the well-known SID name by using LookupAccountSid:
BOOL LookupAccountSid(
_In_opt_ LPCTSTR lpSystemName,
_In_ PSID Sid,
_Out_ LPWSTR Name,
_Inout_ LPDWORD cchName,
_Out_ LPWSTR ReferencedDomainName,
_Inout_ LPDWORD cchReferencedDomainName,
_Out_ PSID_NAME_USE peUse);
lpSystemName is the machine name for SID lookup, where NULL indicates the local machine, and
Sid is the SID to look up. Name is the returned account name, and cchName points to the maximum
character count accepted by the name. On return, it stores the actual number of characters copied

Chapter 16: Security
129
to the buffer. ReferencedDomainName and cchReferencedDomainName serve the same purpose for the
domain name (or more accurately, the authority under which the account resides). Finally, peUse
returns the type of the SID in question, based on the SID_NAME_USE enumeration:
typedef enum _SID_NAME_USE {
SidTypeUser = 1,
SidTypeGroup,
SidTypeDomain,
SidTypeAlias,
SidTypeWellKnownGroup,
SidTypeDeletedAccount,
SidTypeInvalid,
SidTypeUnknown,
SidTypeComputer,
SidTypeLabel,
SidTypeLogonSession
} SID_NAME_USE, *PSID_NAME_USE;
Adding a call to LookupAccountSid to the well-known SID iteration looks like the following:
WCHAR accountName[64] = { 0 }, domainName[64] = { 0 };
SID_NAME_USE use;
for (int i = 0; i < 120; i++) {
DWORD size = sizeof(buffer);
if (!::CreateWellKnownSid((WELL_KNOWN_SID_TYPE)i, nullptr, (PSID)buffer, &size))
continue;
::ConvertSidToStringSid((PSID)buffer, &name);
DWORD accountNameSize = _countof(accountName);
DWORD domainNameSize = _countof(domainName);
::LookupAccountSid(nullptr, (PSID)buffer, accountName, &accountNameSize,
domainName, &domainNameSize, &use);
printf("Well known sid %3d: %-20ws %ws\\%ws (%s)\n", i,
name, domainName, accountName, SidNameUseToString(use));
::LocalFree(name);
}
The loop iterates over all the defined well-known SID indices (currently 120 values). There is no
static reflection in C++ (yet), so using a number is as good as it gets.
The SidNameUseToString function simply converts the SID_NAME_USE enumeration to a string.
Running this piece of code shows the following:

Chapter 16: Security
130
Well known sid
0: S-1-0-0
\NULL SID (Well Known Group)
Well known sid
1: S-1-1-0
\Everyone (Well Known Group)
Well known sid
2: S-1-2-0
\LOCAL (Well Known Group)
Well known sid
3: S-1-3-0
\CREATOR OWNER (Well Known Group)
Well known sid
4: S-1-3-1
\CREATOR GROUP (Well Known Group)
...
Well known sid
22: S-1-5-18
NT AUTHORITY\SYSTEM (Well Known Group)
Well known sid
23: S-1-5-19
NT AUTHORITY\LOCAL SERVICE (Well Known Group)
Well known sid
24: S-1-5-20
NT AUTHORITY\NETWORK SERVICE (Well Known Group)
Well known sid
25: S-1-5-32
BUILTIN\BUILTIN (Domain)
Well known sid
26: S-1-5-32-544
BUILTIN\Administrators (Alias)
Well known sid
27: S-1-5-32-545
BUILTIN\Users (Alias)
Well known sid
28: S-1-5-32-546
BUILTIN\Guests (Alias)
...
Well known sid
65: S-1-16-0
Mandatory Label\Untrusted Mandatory Level (Label)
Well known sid
66: S-1-16-4096
Mandatory Label\Low Mandatory Level (Label)
Well known sid
67: S-1-16-8192
Mandatory Label\Medium Mandatory Level (Label)
...
Well known sid
84: S-1-15-2-1
APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PAC\
KAGES (Well Known Group)
Well known sid
85: S-1-15-3-1
APPLICATION PACKAGE AUTHORITY\Your Internet conne\
ction (Well Known Group)
...
Well known sid 117: S-1-18-6
\Key property attestation (Well Known Group)
Well known sid 118: S-1-18-3
\Fresh public key identity (Well Known Group)
Well known sid 119: S-1-5-32-583
BUILTIN\Device Owners (Alias)
The output clearly shows which SIDs are aliases (rather than groups).
The project wellknownsids contains the full code. It also has code to retrieve the domain SID, so that
more well-known SIDs can be created.
LookupAccountSid has a reciprocal function, LookupAccountName:

Chapter 16: Security
131
BOOL LookupAccountName(
_In_opt_ LPCTSTR lpSystemName,
_In_
LPCTSTR lpAccountName,
_Out_
PSID Sid,
_Inout_
LPDWORD cbSid,
_Out_
LPTSTR ReferencedDomainName,
_Inout_
LPDWORD cchReferencedDomainName,
_Out_
PSID_NAME_USE peUse);
LookupAccountName is a hard-working function attempting to locate a name and return its SID.
It checks for well-known names first. lpAccountName can be a simple name like “joe” or include a
domain name (“mydomain\joe”, better from a performance standpoint). It also accepts other formats,
such as “joe@mydomain.com”. It returns the SID in the Sid parameter and the domain name in
ReferencedDomainName, as well as a SID_NAME_USE just like LookupAccountSid.
The SID APIs include some fairly self-explanatory functions, such as IsValidSid, CopySid, EqualSid,
GetLengthSid, AllocatedAndInitializeSid, InitializeSid, FreeSid, GetSidIdentifierAuthority,
GetSidSubAuthorityCount and GetSidSubAuthority.
Tokens
When a user logs in successfully, whether interactively or not, a logon session object is created
behind the scenes, holding information related to the logged in principal. Normally, a logon session
is hidden behind an access token (or simply token), which is an object that maintains several pieces
of information and has a pointer to the logon session.
The token is the object developers can interact with and manipulate to some extent. A process
always has a token associated with it, known as primary token. All threads within a process use that
primary token by default when performing operations that require a security context. A thread can
perform impersonation by assuming a different token, called impersonation token. Once a thread
is done impersonating, it reverts to using its process (primary) token. The relationship between a
logon session, tokens and processes is depicted in figure 16-6.

Chapter 16: Security
132
Figure 16-6: A logon session, tokens and processes
Three logon sessions always exist, used by the three built-in users in Windows - Local Service,
Network Service and Local System (also called SYSTEM). We’ll look at these accounts more closely
in chapter 19 (“Services”), which is their primary use by developers.
You may be surprised at how many logon sessions exist at any given time. Run the pslogonses-
sions.exe tool from Sysinternals from an elevated command window. It uses the LsaEnumerateLogonSessions
API that returns an array of logon session IDs. For each ID, it calls LsaGetLogonSessionData to
retrieve details about the logon session. Here is an abbreviated output:
[0] Logon session 00000000:000003e7:
User name:
WORKGROUP\PAVEL7540$
Auth package: NTLM
Logon type:
(none)
Session:
0
Sid:
S-1-5-18
Logon time:
19-May-20 19:29:32
Logon server:
DNS Domain:
UPN:
...
[2] Logon session 00000000:0001964a:
User name:
Font Driver Host\UMFD-0
Auth package: Negotiate
Logon type:
Interactive
Session:
0

Chapter 16: Security
133
Sid:
S-1-5-96-0-0
Logon time:
19-May-20 19:29:32
...
[3] Logon session 00000000:000003e5:
User name:
NT AUTHORITY\LOCAL SERVICE
Auth package: Negotiate
Logon type:
Service
Session:
0
Sid:
S-1-5-19
Logon time:
19-May-20 19:29:32
...
[5] Logon session 00000000:000003e4:
User name:
WORKGROUP\PAVEL7540$
Auth package: Negotiate
Logon type:
Service
Session:
0
Sid:
S-1-5-20
Logon time:
19-May-20 19:29:32
...
[7] Logon session 00000000:00023051:
User name:
Window Manager\DWM-1
Auth package: Negotiate
Logon type:
Interactive
Session:
1
Sid:
S-1-5-90-0-1
Logon time:
19-May-20 19:29:32
...
[17] Logon session 00000000:02edfae1:
User name:
NT VIRTUAL MACHINE\47E3D5AD-77C2-4BCE-AC4F-252E2A6935DA
Auth package: Negotiate
Logon type:
Service
Session:
0
Sid:
S-1-5-83-1-1206113709-1271822274-774197164-3660933418
Logon time:
19-May-20 20:14:35
...
Normally, a token is created by Lsass when a user logs in successfully. Winlogon attached it to
the first process created in the user’s session, and the token is duplicated and propagates from that
process to child processes, and so on.
A token contains several pieces of information, some of which are the following:
• The user’s SID

Chapter 16: Security
134
• The primary group
• The groups the user is a member of
• The privileges the user has (discussed later)
• The default security descriptor for newly created objects
• Token type (primary or impersonation)
The primary group was created for use with the POSIX subsystem since this is part of a *NIX security
permissions, and so is mostly unused.
Process Explorer allows viewing information for the primary token of a process in its Security tab
in the process’ properties dialog box (figure 16-7).

Chapter 16: Security
135
Figure 16-7: The Security tab in Process Explorer
Let’s start our exploration of tokens by looking at how to get one. Since every process must have
a token associated with it (its primary token), a token handle can be open for a process with
OpenProcessToken:

Chapter 16: Security
136
BOOL OpenProcessToken(
_In_ HANDLE ProcessHandle,
_In_ DWORD DesiredAccess,
_Outptr_ PHANDLE TokenHandle);
Before attempting to get a token handle, an open process handle must be obtained (OpenProcess)
with at least PROCESS_QUERY_INFORMATION access mask (of course GetCurrentProcess always works).
DesiredAccess is the access mask requested for the token object. Common values include TOKEN_-
QUERY (query information), TOKEN_ADJUST_PRIVILEGES (enable/disable privileges), TOKEN_ADJUST_-
DEFAULT (adjust various defaults), TOKEN_DUPLICATE (duplicate the token), and TOKEN_IMPERSONATE
(impersonate the token). There are other, more powerful, access masks supported, but these
cannot normally be granted since they require some powerful privileges (described in the section
“Privileges”). Finally, TokenHandle returns the actual handle if the call succeeds.
If a thread’s token is needed (most likely the thread is impersonating a different token than its
process), OpenThreadToken can be invoked instead:
BOOL OpenThreadToken(
_In_ HANDLE ThreadHandle,
_In_ DWORD DesiredAccess,
_In_ BOOL OpenAsSelf,
_Outptr_ PHANDLE TokenHandle);
ThreadHandle is a handle to the thread in question that must have the THREAD_QUERY_LIMITED_-
INFORMATION access mask. Such a handle can be opened with OpenThread (GetCurrentThread is
always OK). DesiredAccess is the access required for the returned token handle. OpenAsSelf
indicates under which token should the access check be made for the retrieval of the token. If
OpenAsSelf is TRUE, the access check is against the process token; otherwise it’s against the current
thread’s token. Of course, this only matters if the current thread is currently impersonating.
With a TOKEN_QUERY access mask token handle in hand, GetTokenInformation provides a wealth of
data stored inside the token:
BOOL GetTokenInformation(
_In_
HANDLE TokenHandle,
_In_
TOKEN_INFORMATION_CLASS TokenInformationClass,
_Out_ LPVOID TokenInformation,
_In_
DWORD TokenInformationLength,
_Out_ PDWORD ReturnLength);
The function is very generic, using the TOKEN_INFORMATION_CLASS enumeration to indicate the type
of information requested. For each value in the enumeration, the correct buffer size needs to be
specified. The last parameter indicates how many bytes were used or needed to complete the
operation successfully. The enumeration list is very long. Let’s look at a few examples.
To get the user’s SID associated with the token, use the TokenUser enumeration value like so:

Chapter 16: Security
137
BYTE buffer[1 << 12];
// 4KB - should be large enough for anything
if (::GetTokenInformation(hToken, TokenUser, buffer, sizeof(buffer), &len)) {
auto data = (TOKEN_USER*)buffer;
printf("User SID: %ws\n", SidToString(data->User.Sid).c_str());
}
SidToString uses the already discussed ConvertSidToStringSid function:
std::wstring SidToString(const PSID sid) {
PWSTR ssid;
std::wstring result;
if (::ConvertSidToStringSid(sid, &ssid)) {
result = ssid;
::LocalFree(ssid);
}
return result;
}
Here is another example using the TokenStatistics token information class that retrieves some
useful stats for the token:
TOKEN_STATISTICS stats;
if (::GetTokenInformation(hToken, TokenStatistics, &stats, sizeof(stats), &len)) {
printf("Token ID: 0x%08llX\n", LuidToNum(stats.TokenId));
printf("Logon Session ID: 0x%08llX\n", LuidToNum(stats.AuthenticationId));
printf("Token Type: %s\n", stats.TokenType == TokenPrimary ?
"Primary" : "Impersonation");
if (stats.TokenType == TokenImpersonation)
printf("Impersonation level: %s\n",
ImpersonationLevelToString(stats.ImpersonationLevel));
printf("Dynamic charged (bytes): %lu\n", stats.DynamicCharged);
printf("Dynamic available (bytes): %lu\n", stats.DynamicAvailable);
printf("Group count: %lu\n", stats.GroupCount);
printf("Privilege count: %lu\n", stats.PrivilegeCount);
printf("Modified ID: %08llX\n\n", LuidToNum(stats.ModifiedId));
}
Here are the two helper functions used above:

Chapter 16: Security
138
ULONGLONG LuidToNum(const LUID& luid) {
return *(const ULONGLONG*)&luid;
}
const char* ImpersonationLevelToString(SECURITY_IMPERSONATION_LEVEL level) {
switch (level) {
case SecurityAnonymous: return "Anonymous";
case SecurityIdentification: return "Identification";
case SecurityImpersonation: return "Impersonation";
case SecurityDelegation: return "Delegation";
}
return "Unknown";
}
The TOKEN_STATISTICS structure is defined like so:
typedef struct _TOKEN_STATISTICS {
LUID TokenId;
LUID AuthenticationId;
LARGE_INTEGER ExpirationTime;
TOKEN_TYPE TokenType;
SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
DWORD DynamicCharged;
DWORD DynamicAvailable;
DWORD GroupCount;
DWORD PrivilegeCount;
LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;
Some of its members bear explanation. First, there is the LUID type, which we have not encountered
yet. This is a 64-bit number that is guaranteed to be unique on a particular system while it’s running.
Here’s its definition:
typedef struct _LUID {
DWORD LowPart;
LONG HighPart;
} LUID, *PLUID;
LUIDs are used in several places in Windows, not necessarily related to security. This is just a way to
get unique values on a per-machine basis. If you need to generate one, call AllocateLocallyUniqueId.
The TokenId member is a unique identifier for this token instance (the object, not the handle), so an
easy way to compare tokens is by comparing TokenId values. AuthenticationId is the logon session
ID, uniquely identifying the logon session itself.

Chapter 16: Security
139
The logon session IDs for the three built-in logon sessions have well-known IDs: 999 (0x3e7)
for SYSTEM, 997 (0x3e5) for Local Service and 996 (0x3e4) for Network Service.
TokenType in TOKEN_STATISTICS is either PrimaryToken (process token) or ImpersonationToken
(thread token). If the token is an impersonation one, then the ImpersonationLevel member has
meaning:
typedef enum _SECURITY_IMPERSONATION_LEVEL {
SecurityAnonymous,
// not really used
SecurityIdentification,
SecurityImpersonation,
SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL;
The impersonation level indicates what kind of “power” this impersonation token has - from just
identifying the user (SecurityIdentification) and its properties, to impersonating the user on
the server process’ machine only (SecurityImpersonation), to impersonating the client on remote
machines (relative to the server process’ machine).
There is a lot more stored in a token. We’ll examine more details in subsequent sections. The to-
ken.exe application demonstrates more token information obtained with calls to GetTokenInformation.
Some information inside the token can be changed as well. One generic way is to use SetTokenInformation
that uses the same TOKEN_INFORMATION_CLASS enumeration as GetTokenInformation does:
BOOL SetTokenInformation(
_In_ HANDLE TokenHandle,
_In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
_In_ LPVOID TokenInformation,
_In_ DWORD TokenInformationLength);
Unfortunately, the documentation does not state which information classes are valid, as only a
subset is. Some changes to the token are possible with different APIs. Table 16-1 describes the valid
information classes for SetTokenInformation and the privileges and access mask they require (if
any).

Chapter 16: Security
140
Table 16-1: Valid values for SetTokenInformation
TOKEN_INFORMATION_CLASS
Access mask required
Privilege required
TokenOwner
TOKEN_ADJUST_DEFAULT
TokenPrimaryGroup
TOKEN_ADJUST_DEFAULT
TokenDefaultDacl
TOKEN_ADJUST_DEFAULT
TokenSessionId
TOKEN_ADJUST_SESSIONID
SeTcbPrivilege
TokenVirtualizationAllowed
SeCreateTokenPrivilege
TokenVirtualizationEnabled
TOKEN_ADJUST_DEFAULT
TokenOrigin
SeTcbPrivilege
TokenMandatoryPolicy
SeCreateTokenPrivilege
As an example, here is the code necessary to change the UAC virtualization state of a process, by
manipulating its token. UAC virtualization is discussed in the section “User Access Control” later in
this chapter. For now, we’ll focus on the mechanics of SetTokenInformation. For each information
class, the documentation states the associated structure that should be provided. In this case, for
TokenVirtualizationEnabled, the value is stored in a simple ULONG, where 1 is to enable and 0 to
disable. Here is the code (error handling omitted):
// hProcess is an open process handle with PROCESS_QUERY_INFORMATION
HANDLE hToken;
::OpenProcessToken(hProcess, TOKEN_ADJUST_DEFAULT, &hToken);
ULONG enable = 1;
// enable
::SetTokenInformation(hToken, TokenVirtualizationEnabled, &enable, sizeof(enable));
According to table 16-1, TokenVirtualizationEnabled requires the TOKEN_ADJUST_DEFAULT access
mask. The setvirt.exe is a command-line application (from this chapter’s samples) allows enabling
or disabling UAC virtualization of a process (which is stored in its primary token, of course). Here
is an example run to enable UAC virtualization for process 6912:
c:\>setvirt 6912 on
You can view the UAC virtualization state with Task Manager (add the UAC virtualization column,
figure 16-8) or in Process Explorer’s security tab (figure 16-9).

Chapter 16: Security
141
Figure 16-8: UAC Virtualization in Task Manager
Figure 16-9: UAC Virtualization in Process Explorer
The Secondary Logon Service
The Secondary Logon service (seclogon) is a built-in service that allows launching a process under
a different user than the caller. It’s the service used with the runas.exe built-in command-line tool.
Invoking the service is done by calling CreateProcessWithLogonW:
BOOL CreateProcessWithLogonW(
_In_
LPCWSTR lpUsername,
_In_opt_
LPCWSTR lpDomain,
_In_
LPCWSTR lpPassword,
_In_
DWORD dwLogonFlags,
_In_opt_
LPCWSTR lpApplicationName,
_Inout_opt_ LPWSTR lpCommandLine,
_In_
DWORD dwCreationFlags,
_In_opt_
LPVOID lpEnvironment,

Chapter 16: Security
142
_In_opt_
LPCWSTR lpCurrentDirectory,
_In_
LPSTARTUPINFOW lpStartupInfo,
_Out_
LPPROCESS_INFORMATION lpProcessInformation);
Notice there is no ANSI version for CreateProcessWithLogonW.
Some of the parameters of CreateProcessWithLogonW should seem familiar, as they are normally
provided to a standard CreateProcess call. In actuality, CreateProcessWithLogonW is a combination
of two separate calls: LogonUser and CreateProcessAsUser. LogonUser allows retrieving a token for
a user given proper credentials:
BOOL LogonUser(
_In_
LPCTSTR lpszUsername,
_In_opt_ LPCTSTR lpszDomain,
_In_opt_ LPCTSTR lpszPassword,
_In_
DWORD dwLogonType,
_In_
DWORD dwLogonProvider,
_Outptr_ PHANDLE phToken);
lpszUsername is the username, which can be either a “normal” name or a User Principal Name (UPN)
- something like “user@domanin.com”. If the username is a UPN name, lpszDomain must be NULL.
Otherwise, lpszDomain should be a domain name, where “.” is valid as the local machine (for local
logins). lpszPassword password is the cleartext password of the user.
dwLogonType is the logon type. Here are the common values (check the documentation for the full
list):
• LOGON32_LOGON_INTERACTIVE - suitable for users that will interactively be using the machine.
It caches logon information for disconnected operations, meaning it has higher overhead than
other logon types.
• LOGON32_LOGON_BATCH - suitable for performing operations on behalf of a user without his/her
intervention. This logon type does not cache credentials.
• LOGON32_LOGON_NETWORK - similar to batch, but the returned token is an impersonation token
rather than a primary token. Such a token cannot be used with CreateProcessAsUser, but can
be converted to a primary token with DuplicateTokenEx (see the section “impersonation”). This
is the fastest logon type.
To succeed, the logon type must have been granted to the account logging into.
dwLogonProvider selects the logon provider, either LOGON32_PROVIDER_WINNT50 (kerberos, also called
“negotiate”), or LOGON32_PROVIDER_WINNT40 (NTLM - NT Lan manager). Specifying LOGON32_-
PROVIDER_DEFAULT selects NTLM.
phToken returns the token handle if the function succeeds. With a token in hand, CreateProcessAsUser
is just a function call away:

Chapter 16: Security
143
BOOL CreateProcessAsUser(
_In_opt_ HANDLE hToken,
_In_opt_ LPCTSTR lpApplicationName,
_Inout_opt_ LPTSTR lpCommandLine,
_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
_In_ BOOL bInheritHandles,
_In_ DWORD dwCreationFlags,
_In_opt_ LPVOID lpEnvironment,
_In_opt_ LPCTSTR lpCurrentDirectory,
_In_ LPSTARTUPINFO lpStartupInfo,
_Out_ LPPROCESS_INFORMATION lpProcessInformation);
The function looks identical to CreateProcess except the extra first parameter: a primary token
under which the new process should execute. Although it seems simple enough, there is at least
one snag: calling CreateProcessAsUser requires the SeAssignPrimaryTokenPrivilege privilege. This
privilege is normally granted to the service-running accounts (Local Service, Network Service and
Local System), but not to standard users or even the local administrators alias. This means calling
CreateProcessAsUser is feasible when called from a service (see chapter 18), but is problematic
otherwise.
This is where the Secondary Logon service comes in. Since it runs under the Local System account,
it can call CreateProcessAsUser without any issue. CreateProcessWithLogonW is its driver.
In reality, calling CreateProcessAsUser is not that simple because some security settings
needs to be configured for the process to launch successfully.
The dwLogonFlags parameter to CreateProcessWithLogonW can be one of the following:
• LOGON_WITH_PROFILE - causes CreateProcessWithLogonW to load the user’s profile. This is
important if the new process needs access to the HKEY_CURRENT_USER registry key.
• Zero (0) - do not load the user’s profile.
• LOGON_NETCREDENTIALS_ONLY - the new process will execute under the caller’s user (not the
specified user), but a new network logon session with the specified user is created. This means
any network access by the new process will use the other user’s token.
The next two parameters, lpApplicationName and lpCommandLine serve the same purpose as they do
in CreateProcess (refer to chapter 3 for a refresher if needed). dwCreationFlags is a combination of
flags that are passed internally to CreateProcessAsUser - most flags that are valid in CreateProcess
are valid here as well. lpEnvironment has the same meaning as it does to CreateProcess, except the
default environment is the other user’s default rather than the caller’s.
Finally, lpStartupInfo and lpProcessInfo have the same meaning as they do in CreateProcess.

Chapter 16: Security
144
You may be thinking that creating a process under another user can be accomplished by calling
LogonUser, then impersonating the new user (ImpersonateLoggedOnUser), and finally just call
CreateProcess normally. This fails, however, because CreateProcess always uses the caller’s
primary (process) token rather the active impersonation token (if any).
There is yet another function that invokes the secondary logon service - CreateProcessWithTokenW:
BOOL CreateProcessWithTokenW(
_In_
HANDLE hToken,
_In_
DWORD dwLogonFlags,
_In_opt_
LPCWSTR lpApplicationName,
_Inout_opt_ LPWSTR lpCommandLine,
_In_
DWORD dwCreationFlags,
_In_opt_
LPVOID lpEnvironment,
_In_opt_
LPCWSTR lpCurrentDirectory,
_In_
LPSTARTUPINFOW lpStartupInfo,
_Out_
LPPROCESS_INFORMATION lpProcessInformation);
This function requires the SeImpersonatePrivilege, normally granted to the local administrators
alias and the service accounts. It uses an existing token (for example, from a successful LogonUser
call), but it does require some extra work so the new process does not fail initialization.
Using CreateProcessWithLogonW is by far the easiest way to go, with some loss of flexibility
compared to CreateProcessWithLogonW and CreateProcessAsUser.
Impersonation
Normally any operation performed by a thread is done with the process’ token. What if a thread in
the process wants to make temporary changes to the token before performing some operation? Any
change to the token would be reflected on the process level, affecting all threads in the process. The
thread might want its own private token.
Using something like DuplicateHandle will not work as perhaps expected, because the new handle
still refers to the same object. Instead, the DuplicateTokenEx function can be used:

Chapter 16: Security
145
BOOL DuplicateTokenEx(
_In_ HANDLE hExistingToken,
_In_ DWORD dwDesiredAccess,
_In_opt_ LPSECURITY_ATTRIBUTES lpTokenAttributes,
_In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
_In_ TOKEN_TYPE TokenType,
_Outptr_ PHANDLE phNewToken);
DuplicateTokenEx is unique in the sense of being the only function that can duplicate an object.
There are no such functions for mutexes or semaphores, for example.
hExistingToken is the existing token to duplicate. It must have the TOKEN_DUPLICATE access mask.
dwDesiredAccess is the requested access mask for the new token. Specifying zero results in the same
access mask as the original token. TOKEN_IMPERSONATE is needed if this new token is going to be used
for impersonation.
lpTokenAttributes is the standard SECURITY_ATTRIBUTES (discussed in the section “Security De-
scriptors”), usually set to NULL. ImpersonationLevel indicates the impersonation information level
inherent in the new token (see later in this section for more on this). TokenType is TokenPrimary
(for attaching to a process) or TokenImpersonation for attaching to a thread. Finally, phNewToken
receives the new token handle if the call is successful.
The new token can now be manipulated (enabling/disabling privileges, changing UAC virtualization
state, etc.), without affecting the original token. To make the new token make a difference, it needs to
be attached to the current thread (assuming it was duplicated as an impersonation token) by calling
SetThreadToken:
BOOL SetThreadToken(
_In_opt_ PHANDLE Thread,
_In_opt_ HANDLE Token);
Thread is a pointer to a thread’s handle, where NULL means the current thread.
This is a rather unusual way to specify a thread handle; usually a direct handle is used where
GetCurrentThread is used to indicate the current thread.
Token is an impersonation token to use. NULL is acceptable as a way to stop using any existing token.
Alternatively, the RevertToSelf function can be called instead if the impersonation is on the current
thread:
BOOL RevertToSelf();
The following example duplicates the process token for impersonation, and makes a “local” change
to the impersonation token (error handling omitted):

Chapter 16: Security
146
HANDLE hProcToken;
::OpenProcessToken(GetCurrentProcess(), TOKEN_DUPLICATE, &hProcToken);
HANDLE hImpToken;
::DuplicateTokenEx(hProcToken, MAXIMUM_ALLOWED, nullptr,
SecurityIdentification, TokenImpersonation, &hImpToken);
::CloseHandle(hProcToken);
// enable UAC virtualization on the new token
ULONG virt = 1;
::SetTokenInformation(hImpToken, TokenVirtualizationEnabled,
&virt, sizeof(virt));
// impersonate
::SetThreadToken(nullptr, hImpToken);
// do work...
::RevertToSelf();
::CloseHandle(hImpToken);
This whole procedure of taking the current process token and duplicating as an impersonation token
and attaching it to the current thread can be achieved with one stroke:
BOOL ImpersonateSelf(_In_ SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);
ImpersonateSelf duplicates the process token to create an impersonation token and then calls
SetThreadToken.
Another shorthand function can be used when impersonating with some token (not necessarily the
process token) on the current thread:
BOOL ImpersonateLoggedOnUser(_In_ HANDLE hToken);
ImpersonateLoggedOnUser accepts a primary or impersonation token, duplicates the token (if
needed) and calls SetThreadToken on the current thread.
In the following example, ImpersonateLoggedOnUser is used after LogonUser:

Chapter 16: Security
147
HANDLE hToken;
::LogonUser(L"alice", L".", L"alicesecretpassword",
LOGON32_LOGON_BATCH, LOGON32_PROVIDER_DEFAULT, &hToken);
// impersonate alice
::ImpersonateLoggedOnUser(hToken);
// do work as alice...
::RevertToSelf();
::CloseHandle(hToken);
Impersonation in Client/Server
The classic usage of impersonation is in client/server scenarios. Imagine there is a server process
running under user A. Multiple clients connect to the server process using some communication
mechanism (COM, named pipes, RPC, and some others), asking the server process to perform some
operation on their behalf (figure 16-10).
Figure 16-10: Client/server
If the sever process performs the requested operation using its own identity (A), that wouldn’t be
right. Perhaps client B asked to perform an operation on a file B has no access to, but A does. Instead,
the server should impersonate the requesting client before attempting to perform the operation.
When a token is duplicated, the SECURITY_IMPERSONATION_LEVEL impersonation level indicates what
“power” is inherent in the resulting token when it’s sent to a server on another machine:

Chapter 16: Security
148
typedef enum _SECURITY_IMPERSONATION_LEVEL {
SecurityAnonymous,
SecurityIdentification,
SecurityImpersonation,
SecurityDelegation
} SECURITY_IMPERSONATION_LEVEL;
With SecurityAnonymous, the server has no idea who is the client, and so cannot impersonate it. This
could be fine for some types of operations the server is asked to perform. SecurityIdentification is
the next level where the server can query properties of the client, but still cannot impersonate it (un-
less the server process is on the same machine as the client process). With SecurityImpersonation,
the server can impersonate the client on the server’s machine only (and no further). The last (and
most permissive) impersonation level, SecurityDelegation, allows the server to call another server
on another machine and propagate the token so that the other server can impersonate the original
client, and this can go on for any number of hops.
The token propagation mechanism depends on the communication mechanism used. Table 16-2
shows the impersonation and reverting APIs for some of these mechanisms. Check the documen-
tation for mode details (named pipes are discussed in chapter 18 and COM is discussed in chapter
21).
Table 16-2: APIs for remote client impersonation
Communication mechanism
Impersonation
Reverting
Named pipes
ImpersonateNamedPipeClient
RevertToSelf
RPC
RpcImpersonateClient
RpcRevertToSelf
COM
CoImpersonateClient
CoRevertToSelf
Privileges
A privilege is the right (or denied right) to perform some system-level operation, that is not tied to
a particular object. Example privileges include: loading device drivers, debug processes from other
users, take ownership of an object, and more. A full list can be viewed in the Local Security Policy
snapin (figure 16-11). For each privilege (“policy” column), the tool lists the accounts that are granted
that privilege.

Chapter 16: Security
149
Figure 16-11: Privileges in the Local Security Policy editor
Technically, figure 16-11 shows both privileges and user rights. The distinction is the following: user
rights apply to accounts - that is, the data stored in the users’ database. User rights are always about
allowing or denying some form of login. Privileges, on the other hand, (also stored as static data in
the account database), but they only apply after the user has logged in. Privileges are stored in the
user’s access token, while user rights are not, since they have meaning only before the user logs in.
Examples of user rights include: “Deny log on as a batch job”, “Allow log on locally” and “Allow log
on through Remote Desktop Services”.
Once a token is created (or duplicated), new privileges cannot be added to the token. An adminis-
trator could add privileges to the account (database) itself, but that has no effect on existing tokens.
Once the user logs off and logs on again, the new privileges will be available in its token.
Most privileges are disabled by default. This prevents accidental (unintended) usage of those
privileges. Figure 16-12 shows the list of privileges (shown in Process Explorer) for an Explorer.exe
process. The only enabled privilege (and this one is enabled by default) is SeChangeNotifyPrivilege
- the rest are disabled.

Chapter 16: Security
150
Figure 16-12: Privileges in Explorer’s token
The curiously named SeChangeNotifyPrivilege privilege is granted and enabled by default for all
users. Its descriptive name is “Bypass traverse checking”. It allows access to a file in a directory
where some of the parent directories are themselves inaccessible to that user. For example, the file
c:\A\B\c.txt is accessible (if its security descriptor allows it) for the user even if the directory A is
not. Traversing the security descriptors of all parent directories is costly, which is why this privilege
is enabled by default.
Getting the list of privileges in a token is possible with GetTokenInformation we met already. To
enable, disable, or remove a privilege, a call to AdjustTokenPrivileges is required:
BOOL AdjustTokenPrivileges(
_In_ HANDLE TokenHandle,
_In_ BOOL DisableAllPrivileges,
_In_opt_ PTOKEN_PRIVILEGES NewState,
_In_ DWORD BufferLength,
_Out_opt_ PTOKEN_PRIVILEGES PreviousState,
_Out_opt_ PDWORD ReturnLength);
TokenHandle must have the TOKEN_ADJUST_PRIVILEGES access mask for the call to have a chance at
success. If DisableAllPrivileges is TRUE, the function disables all privileges in the token, and the
next two parameters are ignored. The privilege(s) to change are provided by a TOKEN_PRIVILEGES
structure defined like so:

Chapter 16: Security
151
typedef struct _LUID_AND_ATTRIBUTES {
LUID Luid;
DWORD Attributes;
} LUID_AND_ATTRIBUTES;
typedef struct _TOKEN_PRIVILEGES {
DWORD PrivilegeCount;
LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;
Privileges are represented in the Windows API as strings. For example, SE_DEBUG_NAME is defined as
TEXT("SeDebugPrivilege"). However, each privilege is also given an LUID when the system starts,
which are different every time the system restarts. AdjustTokenPrivileges wants the privileges to
manipulate as LUIDs, rather than strings. So we have to make a little effort to get the LUID of a
privilege with LookupPrivilegeValue:
BOOL LookupPrivilegeValue(
_In_opt_ LPCTSTR lpSystemName,
_In_
LPCTSTR lpName,
_Out_
PLUID
lpLuid);
The function accepts a machine name (NULL is fine for the local machine), the name of a privilege,
and returns its LUID.
Back to AdjustTokenPrivileges - TOKEN_PRIVILEGES requires an array of LUID_AND_ATTRIBUTES
structures, each of which contains an LUID and the attributes to use. Possible values are SE_-
PRIVILEGE_ENABLED to enable the privilege, zero to disable it, and SE_PRIVILEGE_REMOVED to remove
it.
NewState is a pointer to TOKEN_PRIVILEGES and BufferLength is the size of the data, since multiple
privileges can be modified at the same time. Finally, PreviousState and ReturnedLength are optional
parameters that can return the previous state of the modified privileges. Most callers just specify NULL
for both parameters.
The return value of AdjustTokenPrivileges is somewhat tricky. It returns TRUE on any kind of
success, even if only some of the privileges have been changed successfully. The correct thing to do
(if the call returns TRUE) is call GetLastError. If zero is returned, all went well, otherwise ERROR_-
NOT_ALL_ASSIGNED may be returned which indicates something went wrong. If only one privilege
was requested, this really indicates a failure.
We already used AdjustTokenPrivileges a number of times, in chapter 13 and several chapters in
part 1, without a full explanation. Now we can write a generic function to enable or disable any
privilege in the caller’s token by leveraging AdjustTokenPrivileges and LookupPrivilegeValue:

Chapter 16: Security
152
bool EnablePrivilege(PCWSTR privName, bool enable) {
HANDLE hToken;
if (!::OpenProcessToken(::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &hToken))
return false;
bool result = false;
TOKEN_PRIVILEGES tp;
tp.PrivilegeCount = 1;
tp.Privileges[0].Attributes = enable ? SE_PRIVILEGE_ENABLED : 0;
if (::LookupPrivilegeValue(nullptr, privName,
&tp.Privileges[0].Luid)) {
if (::AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(tp),
nullptr, nullptr))
result = ::GetLastError() == ERROR_SUCCESS;
}
::CloseHandle(hToken);
return result;
}
Using a single privilege makes the call to AdjustTokenPrivileges easy, since there is room for exactly
one privilege in TOKEN_PRIVILEGES without the need for extra allocations.
Super Privileges
An exhaustive discussion of all available privileges is beyond the scope of this book. Some privileges,
however, do bear special mention. There is a set of privileges that are so powerful that having any
of them allows almost complete control of the system (some allow even complete control). There
are sometimes affectionally called “Super Privileges”, although this is not an official term.
Take Ownership
An object’s owner can always set who-can-do-what with the object (see the “Security Descriptors”
section for mode details). The SeTakeOwnershipPrivilege (SE_TAKE_OWNERSHIP_NAME) allows its
yielder to set itself as an owner of any kernel object (file, mutex, process, etc.). Being an owner,
the user can now give himself/herself full access to the object.
This privilege is normally given to administrators, which makes sense, as an administrator should
be able to take control of any object if needed. For example, suppose an employee leaves a company,
and some files/folders he/she owned are now inaccessible. An administrator can exercise the take
ownership privilege and set the administrator as the owner, allowing full access to the object to be
set.
One way to see this in action is to use the security descriptor of an object, such as a file (figure
16-13). Clicking the Advanced button shows the dialog in figure 16-14, where the owner is shown.

Chapter 16: Security
153
Figure 16-13: Security settings of a kernel object

Chapter 16: Security
154
Figure 16-14: Advanced security settings dialog
Clicking the Change button causes the dialog handler to enable the take ownership privilege (if
exists in the caller’s token, in this case the user running Explorer) and replace the owner.
Backup
The backup privilege (SE_BACKUP_NAME) gives its user read access to any object, regardless of its
security descriptor. Normally, this should be given to applications that perform some form of backup.
Administrators and the Backup operators group have this privilege by default. To use it for files,
specific FILE_BACKUP_SEMANTICS when opening a file with CreateFile.
Restore
The restore privilege (SE_RESTORE_NAME) is the opposite of backup, and provides write access to any
kernel object.
Debug
The debug privilege (SE_DEBUG_NAME) allows debugging and memory manipulation of any process.
This includes calling CreateRemoteThread to inject a thread to any process. This excludes protected
and PPL processes.

Chapter 16: Security
155
TCB
The TCB privilege (Trusted Computing Base, SE_TCB_NAME), described as “Act part of the operating
system”, is one of the most powerful privileges. A testament to that is the fact that by default it’s
not given to any user or group. Having this privilege allows a user to impersonate any other user,
and generally have the same access the kernel has.
Create Token
The create token privilege (SE_CREATE_TOKEN_NAME) allows creating a token, thus populating it with
any privilege or group. This privilege is not given to any user by default. However, the Lsass process
must have it as it’s required after a successful logon. If you examine Lsass security properties in
Process Explorer, you’ll find it has this privilege. How can this be if the privilege is given to no user?
We’ll answer that question in chapter 19.
Access Masks
We’ve encountered access masks many times before. At first, they might appear to use random
values for the various access bits, but there is a logical grouping of bits, depicted in figure 16-15.
Figure 16-15: Components of an access mask
The “specific rights* part (low 16 bits) represent just that: specific rights that are different for each
object type. For example, PROCESS_TERMNINATE and PROCESS_CREATE_THREAD are two specific rights
for process objects.
Next, there are standard rights, appropriate for many types of objects. For example, SYNCHRONIZE,
DELETE and WRITE_DAC are examples of standard rights. They don’t necessarily have meaning for all
object types. For example, SYNCHRONIZE only has meaning for dispatcher (waitable) objects.
The next bit (24) is the ACCESS_SYSTEM_SECURITY access right, that allows access to the System Access
Control List (discussed in the next section). MAXIMUM_ALLOWED (bit 25) is a special value, that if used,
provides the maximum access mask the client can obtain. For example:

Chapter 16: Security
156
HANDLE hProcess = ::OpenProcess(MAXIMUM_ALLOWED, FALSE, pid);
If a handle can be obtained, the resulting access mask is the highest possible for the caller. The above
example is not that useful in practice since the caller knows which access mask is needed to get the
job done.
Bits 28-31 represent generic rights. These rights (if used) must be translated, or mapped, to specific
access rights. For example, specifying GENERIC_WRITE must be mapped to what “write” means for
the object type in question. This is performed internally with the following structure:
typedef struct _GENERIC_MAPPING {
ACCESS_MASK GenericRead;
ACCESS_MASK GenericWrite;
ACCESS_MASK GenericExecute;
ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
The default mappings can be viewed with the Object Explorer tool (figure 16-13), but they are fairly
intuitive, and some are indirectly defined in the headers. For example, FILE_GENERIC_READ is the
GENERIC_READ mapping for files.

Chapter 16: Security
157
Figure 16-16: Generic mappings in Object Explorer
Security Descriptors
A Security Descriptor is a variable-length structure that includes information on who-can-do-what
with the object it’s attached to. A security descriptor contains these pieces of information:
• Owner SID - the owner of an object.
• Primary Group SID - used in the past for group security in POSIX subsystem applications.
• Discretionary Access Control List (DACL) - a list of Access Control Entries (ACE), specifying
who-can-do-what with the object.
• System Access Control List (SACL) - a list of ACEs, indicating which operations should cause
an audit entry to be written to the security log.

Chapter 16: Security
158
The owner of the object always has the WRITE_DAC (and READ_CONTROL) standard access rights,
meaning it can read and change the object’s DACL. This is important, otherwise a careless call can
make the object completely inaccessible. Having WRITE_DAC for the owner ensures that the owner
can change the DACL no matter what.
Getting the security descriptor of any kernel object for which you have an open handle can be done
with GetKernelObjectSecurity:
BOOL GetKernelObjectSecurity(
_In_ HANDLE Handle,
_In_ SECURITY_INFORMATION RequestedInformation,
_Out_ PSECURITY_DESCRIPTOR pSecurityDescriptor,
_In_ DWORD nLength,
_Out_ LPDWORD lpnLengthNeeded);
The handle must have the READ_CONTROL standard access mask. SECURITY_INFORMATION is an
enumeration specifying what kind of information to return in the resulting security descriptor (more
than one can be specified with the OR operator). The most common ones are OWNER_SECURITY_-
INFORMATION and DACL_SECURITY_INFORMATION. The result is stored in PSECURITY_DESCRIPTOR. SECURITY_-
DESCRIPTOR structure is defined, but should be treated opaquely, and this is why PSECURITY_-
DESCRIPTOR (pointer to that structure) is typedefed as PVOID. GetKernelObjectSecurity requires
the caller to allocate a large-enough buffer, specify its length in the nLength parameter and get back
the actual length in lpnLengthNeeded.
Requesting the SACL with SACL_SECURITY_INFORMATION requires the SeSecurityPrivilege,
normally given to administrators.
With the PSECURITY_DESCRIPTOR in hand, several functions exist to extract the data stored in it:
DWORD GetSecurityDescriptorLength(_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor);
BOOL GetSecurityDescriptorControl(
// control flags
_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor,
_Out_ PSECURITY_DESCRIPTOR_CONTROL pControl,
_Out_ LPDWORD lpdwRevision);
BOOL GetSecurityDescriptorOwner(
// owner
_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor,
_Outptr_ PSID* pOwner,
_Out_ LPBOOL lpbOwnerDefaulted);
BOOL GetSecurityDescriptorGroup(
// primary group (mostly useless)
_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor,
_Outptr_ PSID* pGroup,
_Out_ LPBOOL lpbGroupDefaulted);

Chapter 16: Security
159
BOOL GetSecurityDescriptorDacl(
// DACL
_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor,
_Out_ LPBOOL lpbDaclPresent,
_Outptr_ PACL* pDacl,
_Out_ LPBOOL lpbDaclDefaulted);
BOOL GetSecurityDescriptorSacl(
// SACL
_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor,
_Out_ LPBOOL lpbSaclPresent,
_Outptr_ PACL* pSacl,
_Out_ LPBOOL lpbSaclDefaulted);
For example, here is some code that shows the owner of a process given its ID:
bool DisplayProcessOwner(DWORD pid) {
HANDLE hProcess = ::OpenProcess(READ_CONTROL, FALSE, pid);
if (!hProcess)
return false;
BYTE buffer[1 << 10];
auto sd = (PSECURITY_DESCRIPTOR)buffer;
DWORD len;
BOOL success = ::GetKernelObjectSecurity(hProcess,
OWNER_SECURITY_INFORMATION,
sd, sizeof(buffer), &len);
::CloseHandle(hProcess);
if(!success)
return false;
PSID owner;
BOOL isDefault;
if (!::GetSecurityDescriptorOwner(sd, &owner, &isDefault))
return false;
printf("Owner: %ws (%ws)\n", GetUserNameFromSid(owner).c_str(),
SidToString(owner).c_str());
return true;
}
Another function to retrieve an object’s security descriptor is GetNamedSecurityInfo (#include
<AclAPI.h>):

Chapter 16: Security
160
DWORD GetNamedSecurityInfo(
_In_
LPCTSTR
pObjectName,
_In_
SE_OBJECT_TYPE
ObjectType,
_In_
SECURITY_INFORMATION
SecurityInfo,
_Out_opt_
PSID
* ppsidOwner,
_Out_opt_
PSID
* ppsidGroup,
_Out_opt_
PACL
* ppDacl,
_Out_opt_
PACL
* ppSacl,
_Out_ PSECURITY_DESCRIPTOR
* ppSecurityDescriptor);
This function can only be used named objects (mutexes, events, semaphores, sections) and objects
that have a “path” of some sort (files and registry keys). It does not require an open handle to the
object - just its name and type. The function fails if the caller cannot obtain a READ_CONTROL access
mask, of course.
pObjectName is the object’s name, in a format appropriate for the object type given by the SE_-
OBJECT_TYPE enumeration. The function can return the security descriptor as a whole, or just selected
parts. The return value from the function is error code itself, where ERROR_SUCCESS (0) means all is
well (there is no point in calling GetLastError).
The following example displays the owner of a given file:
bool DisplayFileOwner(PCWSTR filename) {
PSID owner;
DWORD error = ::GetNamedSecurityInfo(filename, SE_FILE_OBJECT,
OWNER_SECURITY_INFORMATION, &owner,
nullptr, nullptr, nullptr, nullptr);
if (error != ERROR_SUCCESS)
return false;
printf("Owner: %ws (%ws)\n", GetUserNameFromSid(owner).c_str(),
SidToString(owner).c_str());
return true;
}
Notice that you don’t free the returned information from GetNamedSecurityInfo - that will cause
an exception to be raised.
Specifically for files, there is another function that returns the file’s security descriptor:
GetFileSecurity. The various parts then need to be retrieved with one of the afore-
mentioned functions such as GetSecurityDescriptorOwner. Also, for desktop and window
station objects, another convenience function exists - GetUserObjectSecurity.

Chapter 16: Security
161
The most important part of a security descriptor is the DACL. This directly affects who is allowed
access to the object and in what way. The most well-known view of a DACL is the security property
dialog box available with various tools, such as for files and directories in Explorer (figure 16-17).
Figure 16-17: Security properties dialog box
The dialog in figure 16-17 shows the DACL. For each user or group, it shows the allowed or denied
operations. Each item in the DACL is an Access Control Entry (ACE) that includes the following
pieces of information:
• The SID to which this ACE applies (e.g. a user or a group).
• The access mask this ACE controls (e.g. PROCESS_TERMINATE for a process object) (could be more
than one bit)
• The ACE type, most commonly Allow or Deny.
When a caller tries to gain certain access to the file, the security reference monitor in the kernel
must check if the requested access (based on the access mask) is allowed for the caller. It does

Chapter 16: Security
162
so by traversing the ACEs in the DACL, looking for a definitive result. Once found, the traversal
terminates. Figure 16-18 shows an example of a DACL on some file object.
Figure 16-18: An example security descriptor
Suppose we have two users, USER1 and USER2 that are part of two groups, TEAM1 and TEAM2,
and another user, USER3, that is part of group TEAM2 only. Here are some questions we can ask:
1. If USER1 wants to open the file for read access, will that succeed?
2. If USER1 wants to open the file for write access, will that succeed?
3. If USER2 wants to open the file for write access, will that succeed?
4. If USER2 wants to open the file for execute access, will that succeed?
5. If USER3 wants to open the file for read access, will that succeed?
The ACEs are traversed in order. If no definitive answer exists, the next ACE is consulted. If no
definitive result is available after all ACEs are consulted, the final verdict is Access Denied.
If the security descriptor itself is NULL, this means the object has no protection and all access is
allowed. If the security descriptor exists, but the DACL itself is NULL, it means the same thing - no
protection. If, on the other hand, the DACL is empty (i.e. no ACEs), it means no-one has access to
the object (except the owner).
Let’s answer the above questions:
1. USER1 is denied read access, because of the second ACE. The first ACE doesn’t say anything
about read access.
2. USER1 is allowed write access - the order of ACEs matter.
3. USER2 is denied write access.
4. USER2 is allowed execute access, because it’s part of the Everyone group, and previous ACEs
had nothing to say about execute.
5. USER3 is denied read access, because no ACE provides a definitive answer, so the final verdict
is Access Denied.

Chapter 16: Security
163
There are other factors that come into play for access check, including other types of ACEs,
such as inheritance ACEs. Consult the documentation for the gory details.
If you edit the DACL with the security dialog box shown by Explorer, the ACEs built by the
security dialog box always places Deny ACEs before Allow ACEs. The example in figure
16-18 will never be constructed (but it can be constructed in this order programmatically),
since ACE 2 will be placed first because it’s a Deny ACE.
How would the answers to the above questions change if deny ACEs would be placed before
Allow ACEs?
You can show the security properties dialog programmatically with the EditSecurity
API. This is not easy because you need to provide an implementation of the
ISecurityInformation COM interface that returns appropriate information for the dialog
box’ operation. You can find an example implementation in my Object Explorer tool’s source
code and other resources online.
A DACL (and SACL for that matter) is represented by the ACL structure, a pointer to which is
returned when a DACL is retrieved with GetSecurityDescriptorDacl or GetNamedSecurityInfo:
typedef struct _ACL {
BYTE
AclRevision;
BYTE
Sbz1;
WORD
AclSize;
WORD
AceCount;
WORD
Sbz2;
} ACL;
typedef ACL *PACL;
The only interesting member is AceCount. The ACL object is followed immediately by an array of
ACEs. The size of each ACE may be different (depending on the type of ACE), but each ACE always
starts with an ACE_HEADER:

Chapter 16: Security
164
typedef struct _ACE_HEADER {
BYTE
AceType;
BYTE
AceFlags;
WORD
AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;
There is no need to manually calculate where each ACE starts - just call GetAce:
BOOL GetAce(
_In_ PACL pAcl,
_In_ DWORD dwAceIndex,
_Outptr_ LPVOID* pAce);
pAcl is the DACL pointer, dwAceIndex is the ACE index (starting from zero), and the returned pointer
points to the ACE itself, that always starts with ACE_HEADER. With the type of ACE in hand (from
the header), the returned pointer from GetAce can be cast to the specific ACE structure. Here are the
two most common ACE types: allowed and denied:
typedef struct _ACCESS_ALLOWED_ACE {
ACE_HEADER Header;
ACCESS_MASK Mask;
DWORD SidStart;
} ACCESS_ALLOWED_ACE;
typedef struct _ACCESS_DENIED_ACE {
ACE_HEADER Header;
ACCESS_MASK Mask;
DWORD SidStart;
} ACCESS_DENIED_ACE;
Here you can see the three parts of the ACE: its type, the access mask, and the SID. The SID follows
the access mask immediately, so SidStart is really a dummy value - only its address matters. Here
is function displaying information for the two common ACE types:

Chapter 16: Security
165
void DisplayAce(PACE_HEADER header, int index) {
printf("ACE %2d: Size: %2d bytes, Flags: 0x%02X Type: %s\n",
index, header->AceSize, header->AceFlags,
AceTypeToString(header->AceType));
// simple enum to string
switch (header->AceType) {
case ACCESS_ALLOWED_ACE_TYPE:
case ACCESS_DENIED_ACE_TYPE:
// have the same binary layout
{
auto data = (ACCESS_ALLOWED_ACE*)header;
printf("\tAccess: 0x%08X %ws (%ws)\n", data->Mask,
GetUserNameFromSid((PSID)&data->SidStart).c_str(),
SidToString((PSID)&data->SidStart).c_str());
}
break;
}
}
The sd.exe application allows viewing security descriptors of threads, processes, files, registry keys
and other named objects (mutexes, events, etc.). The above code is an excerpt from that application.
Here are some examples running sd.exe:
c:\>sd.exe
Usage: sd [[-p <pid>] | [-t <tid>] | [-f <filename>] | [-k <regkey>] | [objectname]]
If no arguments specified, shows the current process security descriptor
SD Length: 116 bytes
SD: O:BAD:(A;;0x1fffff;;;BA)(A;;0x1fffff;;;SY)(A;;0x121411;;;S-1-5-5-0-687579)
Control: DACL Present, Self Relative
Owner: BUILTIN\Administrators (S-1-5-32-544)
DACL: ACE count: 3
ACE
0: Size: 24 bytes, Flags: 0x00 Type: ALLOW
Access: 0x001FFFFF BUILTIN\Administrators (S-1-5-32-544)
ACE
1: Size: 20 bytes, Flags: 0x00 Type: ALLOW
Access: 0x001FFFFF NT AUTHORITY\SYSTEM (S-1-5-18)
ACE
2: Size: 28 bytes, Flags: 0x00 Type: ALLOW
Access: 0x00121411 NT AUTHORITY\LogonSessionId_0_687579 (S-1-5-5-0-687579)
c:\>sd -p 4936
SD Length: 100 bytes
SD: O:S-1-5-5-0-340923D:(A;;0x1fffff;;;S-1-5-5-0-340923)(A;;0x1400;;;BA)
Control: DACL Present, Self Relative
Owner: NT AUTHORITY\LogonSessionId_0_340923 (S-1-5-5-0-340923)
DACL: ACE count: 2

Chapter 16: Security
166
ACE
0: Size: 28 bytes, Flags: 0x00 Type: ALLOW
Access: 0x001FFFFF NT AUTHORITY\LogonSessionId_0_340923 (S-1-5-5-0-340923)
ACE
1: Size: 24 bytes, Flags: 0x00 Type: ALLOW
Access: 0x00001400 BUILTIN\Administrators (S-1-5-32-544)
c:\>sd -f c:\temp\test.txt
SD Length: 180 bytes
SD: O:S-1-5-21-2575492975-396570422-1775383339-1001D:AI(D;;CCDCLCSWRPWPLOCRSDRC;;;S-\
1-5-21-2575492975-396570422-1775383339-1009)(A;ID;FA;;;BA)(A;ID;FA;;;SY)(A;ID;0x1200\
a9;;;BU)(A;ID;0x1301bf;;;AU)
Control: DACL Present, DACL Auto Inherited, Self Relative
Owner: PAVEL7540\pavel (S-1-5-21-2575492975-396570422-1775383339-1001)
DACL: ACE count: 5
ACE
0: Size: 36 bytes, Flags: 0x00 Type: DENY
Access: 0x000301BF PAVEL7540\alice (S-1-5-21-2575492975-396570422-1775383339\
-1009)
ACE
1: Size: 24 bytes, Flags: 0x10 Type: ALLOW
Access: 0x001F01FF BUILTIN\Administrators (S-1-5-32-544)
ACE
2: Size: 20 bytes, Flags: 0x10 Type: ALLOW
Access: 0x001F01FF NT AUTHORITY\SYSTEM (S-1-5-18)
ACE
3: Size: 24 bytes, Flags: 0x10 Type: ALLOW
Access: 0x001200A9 BUILTIN\Users (S-1-5-32-545)
ACE
4: Size: 20 bytes, Flags: 0x10 Type: ALLOW
Access: 0x001301BF NT AUTHORITY\Authenticated Users (S-1-5-11)
Some of the above output bears some explanation. A security descriptor has a string representation
based on the Security Descriptor Definition Language (SDDL). There are functions to convert from
the binary to the string representation and vice versa: ConvertSecurityDescriptorToStringSecurityDescriptor
and ConvertStringSecurityDescriptorToSecurityDescriptor.
Security descriptors exist in two formats: Self-relative and Absolute. With Self-relative, the various
pieces of the security descriptor are packed into one structure that is easy to move around. Absolute
format has internal pointers to the security descriptor parts, so it cannot move around without
modifying the internal pointers. The actual format doesn’t matter in most cases, and conversion
between the two formats is possible with MakeAbsoluteSD and MakeSelfRelativeSD.
The Default Security Descriptor
Nearly every kernel object creation function has a SECURITY_ATTRIBUTES structure as a parameter.
As a reminder, this is what this looks like:

Chapter 16: Security
167
typedef struct _SECURITY_ATTRIBUTES {
DWORD nLength;
LPVOID lpSecurityDescriptor;
BOOL bInheritHandle;
} SECURITY_ATTRIBUTES;
We used bInheritHandle as one way to implement handle inheritance, but lpSecurityDescriptor
was always NULL. If the entire structure is not provided, this implies NULL in lpSecurityDescriptor.
Does that mean the object has no protection? Not necessarily.
We can check the security descriptor attached to an object after creation by using GetKernelObjectSecurity
like so:
BYTE buffer[1 << 10];
DWORD len;
HANDLE hEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);
::GetKernelObjectSecurity(hEvent,
DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
(PSECURITY_DESCRIPTOR)buffer, sizeof(buffer), &len);
Now we can examine the resulting security descriptor. It turns out that unnamed objects (mutexes,
events, semaphores, file mapping objects) get a security descriptor with no DACL. However, named
objects (including files and registry keys), do get a security descriptor with a default DACL. This
default DACL comes from the access token, so we can look at it and even change it.
Why are unnamed objects unprotected? The reasoning is probably that since the handle is private, it
cannot be accessed from outside the process. Only injected code can touch these handles. And since
such handle don’t have any “identifying marks”, it’s unlikely a malicious agent would know what
they’re used for. Named objects, on the other hand, are visible. Other processes can attempt to open
them by name, so some form of protection is prudent.
Querying the default DACL is just a matter of calling GetTokenInformation with the correct value:
HANDLE hToken;
::OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
::GetTokenInformation(hToken, TokenDefaultDacl, buffer, sizeof(buffer), &len);
auto dacl = ((TOKEN_DEFAULT_DACL*)buffer)->DefaultDacl;
You can view the DACL of kernel objects using Process Explorer’s handles view or with my
Object Explorer in its handles and objects views.

Chapter 16: Security
168
Building Security Descriptors
The default security descriptor is usually fine, but sometimes you may want to tighten security or
provide extra permissions to certain users or groups. For this, you’ll need to build a new security
descriptor or alter an existing one, before applying it to an object.
For following example builds a security descriptor for an event object, with an owner being the
administrators alias, with two ACEs in its DACL:
• The first allows all possible access to the event for the administrators alias.
• The second allows only SYNCHRONIZE access to the event.
The code is not pretty, but here is one way to do this (error handling omitted):
BYTE sdBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
auto sd = (PSECURITY_DESCRIPTOR)sdBuffer;
// initialize an empty security descriptor
::InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION);
// build an owner SID
BYTE ownerSid[SECURITY_MAX_SID_SIZE];
DWORD size;
::CreateWellKnownSid(WinBuiltinAdministratorsSid, nullptr, (PSID)ownerSid, &size);
// set the owner
::SetSecurityDescriptorOwner(sd, (PSID)ownerSid, FALSE);
// everyone SID
BYTE everyoneSid[SECURITY_MAX_SID_SIZE];
b = ::CreateWellKnownSid(WinWorldSid, nullptr, (PSID)everyoneSid, &size);
// build the DACL
EXPLICIT_ACCESS ea[2];
ea[0].grfAccessPermissions = EVENT_ALL_ACCESS;
// all access
ea[0].grfAccessMode = SET_ACCESS;
ea[0].grfInheritance = NO_INHERITANCE;
ea[0].Trustee.ptstrName = (PWSTR)ownerSid;
ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
ea[0].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;
ea[1].grfAccessPermissions = SYNCHRONIZE;
// just SYNCHRONIZE
ea[1].grfAccessMode = SET_ACCESS;
ea[1].grfInheritance = NO_INHERITANCE;
ea[1].Trustee.ptstrName = (PWSTR)everyoneSid;

Chapter 16: Security
169
ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
PACL dacl;
// create the DACL with 2 entries
::SetEntriesInAcl(_countof(ea), ea, nullptr, &dacl);
// set the DACL in the security descriptor
::SetSecurityDescriptorDacl(sd, TRUE, dacl, FALSE);
// finally, create the object with the created SD
SECURITY_ATTRIBUTES sa = { sizeof(sa) };
sa.lpSecurityDescriptor = sd;
HANDLE hEvent = ::CreateEvent(&sa, FALSE, FALSE, nullptr);
// the DACL was allocated by SetEntriesInAcl
::LocalFree(dacl);
The APIs used in this example are not the only ones that are available for building a DACL and
SIDs. One simple way (if you know SDDL) is to create the required security descriptor as a string
and call ConvertStringSecurityDescriptorToSecurityDescriptor to convert it to a “real” security
descriptor that can be directly used.
SDDL is fully documented in the Microsoft documentation.
The above code created a security descriptor to be used when creating a kernel object. If an object
already exists, there are several APIs that can be used to change existing values (read the docs for
the details):
BOOL SetKernelObjectSecurity(
// most generic
_In_ HANDLE Handle,
_In_ SECURITY_INFORMATION SecurityInformation,
_In_ PSECURITY_DESCRIPTOR SecurityDescriptor);
DWORD SetSecurityInfo(
// uses components of SD
_In_
HANDLE
handle,
_In_
SE_OBJECT_TYPE
ObjectType,
_In_
SECURITY_INFORMATION
SecurityInfo,
_In_opt_ PSID
psidOwner,
_In_opt_ PSID
psidGroup,
_In_opt_ PACL
pDacl,

Chapter 16: Security
170
_In_opt_ PACL
pSacl);
BOOL SetFileSecurity(
// specific for files
_In_ LPCTSTR lpFileName,
_In_ SECURITY_INFORMATION SecurityInformation,
_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor);
DWORD SetNamedSecurityInfo(
// named objects
_In_ LPTSTR
pObjectName,
_In_ SE_OBJECT_TYPE
ObjectType,
_In_ SECURITY_INFORMATION
SecurityInfo,
_In_opt_ PSID
psidOwner,
_In_opt_ PSID
psidGroup,
_In_opt_ PACL
pDacl,
_In_opt_ PACL
pSacl);
User Access Control
User Access Control (UAC) is a feature introduced in Windows Vista that caused quite a few
headaches to users and developers alike. In the pre-Vista days, users were created as local
administrators, which is bad from a security standpoint. Any executing code had admin rights which
means any malicious code could take control of the system.
Running with admin rights is convenient, as most operations just work, but can cause damage by
writing to sensitive files or HKEY_LOCAL_MACHINE registry hive.
Windows Vista changed that. A created user was not necessarily an administrator, and even the
first user, which must be a local administrator, was not operating with admin rights by default. In
fact, Lsass created (upon a successful login), two access tokens for local admin users - one is the full
admin token, and the other token was with standard user rights. By default, processes ran with the
standard user right token.
Most processes don’t need to execute with admin rights. Consider applications such as Notepad,
Word or Visual Studio. In most cases, they can run perfectly fine with standard user rights. There
may be cases, however, when it’s desirable they run with admin rights. This can be done with
elevation (discussed later).
Windows Vista made it easier to run with standard user rights by easing the requirements for some
operations:
• The change time privilege was split into two privileges: change time and change time zone.
“Change time zone” is granted to all users, while change time is only granted to administrators
(this makes sense, as changing time zone is just changing the view of time, not time itself).
• Some configurations that previously were permitted to admin users only, were now allowed
to standard users (e.g. wireless settings, some power options).

Chapter 16: Security
171
• Virtualization (discussed later).
If a process needs to run with admin rights, it requests elevation. This shows one of two dialogs
- either a Yes/No approval (if the user is a true administrator), or a dialog box that requires
username/password (the user has no admin rights and should call an admin from the IT department
or some other user which is an administrator on the machine). The color of the dialog box indicates
the level of danger of allowing the application to elevate to have admin rights:
• If the binary is signed by Microsoft, it appears in light blue color (blue is known as a relaxing
color).
• If the binary is signed by another entity except Microsoft, it appears in a light gray color.
• If the binary is unsigned, it appears in a bright orange/yellow color that draws the user’s
attention as this may be a dangerous executable.
The UAC dialog in the Control Panel has 4 levels to indicate in which circumstances should the
elevation dialog box pop up (figure 16-19).

Chapter 16: Security
172
Figure 16-19: The UAC dialog
Although it looks like 4 options, there are actually 3 where elevation dialog is concerned:
• Always notify - any elevation is prompted by the appropriate dialog box.
• Never notify - if the user is a true administrator, just perform the elevation automatically.
Otherwise, show the dialog for an admin username/password entry (also called Administrator
Approval Mode - AAM)
• The middle options - if the user is a true admin, don’t pop the consent dialog (Yes/No) for
Windows components.

Chapter 16: Security
173
What does “Windows components” mean? It means applications created by the kernel
team or very close to it. Example applications include Task Manager, Task Scheduler,
Device Manager and Performance Monitor. Examples of applications not included (these
are Microsoft components that are created by outside teams) are cmd.exe, notepad.exe, and
regedit.exe. The latter get a consent dialog if the mid-levels are selected.
The difference between the two middle options is that the upper one (which is the default)
shows the elevation dialog box in an alternate desktop (with the background set to a faded
bitmap of the original wallpaper), while the lower one uses the default desktop.
On Windows versions before Windows 8, “Never notify” causes the system to use the pre-
Vista model where there is just an admin token (if the user is a real admin). Starting with
Windows 8, UAC cannot be turned off completely, because UWP processes always run with
the standard token.
Elevation
Elevation is the act of running an executable with admin rights. The process of elevation is depicted
in figure 16-20.
Figure 16-20: Elevation
The only documented way to launch a process elevated is to use the shell function ShellExecute or
ShellExecuteEx (include <shellapi.h>):

Chapter 16: Security
174
HINSTANCE ShellExecute(
_In_opt_ HWND hwnd,
_In_opt_ LPCTSTR lpOperation,
_In_ LPCTSTR lpFile,
_In_opt_ LPCTSTR lpParameters,
_In_opt_ LPCTSTR lpDirectory,
_In_ INT nShowCmd);
typedef struct _SHELLEXECUTEINFO {
DWORD cbSize;
ULONG fMask;
HWND hwnd;
LPTSTR
lpVerb;
LPTSTR
lpFile;
LPTSTR
lpParameters;
LPTSTR
lpDirectory;
int nShow;
HINSTANCE hInstApp;
void *lpIDList;
LPCTSTR
lpClass;
HKEY hkeyClass;
DWORD dwHotKey;
union {
HANDLE hIcon;
HANDLE hMonitor;
};
HANDLE hProcess;
} SHELLEXECUTEINFO, *LPSHELLEXECUTEINFO;
BOOL ShellExecuteExW(_Inout_ SHELLEXECUTEINFOW *pExecInfo);
These functions are used by the shell (Explorer) and other applications to launch an executable based
on something other than an executable’s path (CreateProcess can do this just fine). These functions
can accept any file, lookup its extension in the registry, and launch the relevant executable. For
example, calling ShellExecute(Ex) with a txt file extension, launches Notepad (if that default has
not been changed by the user) by calling CreateProcess with the correct values behind the scenes.
The crucial parameter for elevation purposes is lpVerb, which must be set to “runas”. Here is an
example for launching notepad elevated:
::ShellExecute(nullptr, L"runas", L"notepad.exe", nullptr, nullptr, SW_SHOWDEFAULT);
The process of elevation (figure 16-20) causes a message to be sent to the AppInfo service (hosted
in a standard Svchost.exe). The service calls a helper executable, consent.exe that shows the

Chapter 16: Security
175
relevant elevation dialog box. If all goes well (the elevation is approved), the AppInfo service calls
CreateProcessAsUser to launch the executable with the elevated token, and then the new process
is “reparented”, so that it looks like the original process created it (Explorer in figure 16-20, but it
could be anyone calling ShellExecute(Ex)).
This “reparenting” is fairly unique. UWP processes, for example (discussed in chapter 3), are always
launched by the DCOM Launch service (also hosted in a standard Svchost.exe instance), but no
reparenting is attempted.
Some applications provide a “Run as Administrator” option (see WinObj from Sysinternals as an
example). Although it may seem the process suddenly becomes elevated, this is never the case. The
current process exits and a new process is launched with the elevated. There is no way to elevate
the token in place (if there was a way, UAC was useless).
Running As Admin Required
Some applications just cannot properly function when running with standard user rights. Such
executables must somehow notify the system that they require elevation no matter what. This is
accomplished by using a manifest file (discussed in chapter 1). One such part deals with elevation
requirements. Here is the relevant parts:
<trustInfo xmlns="urn:schema-microsoft-com:asm.v3">
<security>
<requestedPrivileges>
<requestedExecutionLevel Level="requireAdministrator" />
</requestedPrivileges>
</security>
</trustInfo>
The Level value indicates the type of elevation requested. These are the possible values:
• asInvoker - the default if no value is specified. Indicates the executable should launch elevated
if its parent runs elevated, otherwise runs with standard user rights.
• requireAdministrator - indicates admin elevation is required. Without it, the process will not
launch.
• highestAvailable - the in between value. It indicates that if the launching user is a true admin,
then attempt elevation. Otherwise, run with standard user rights.
An example of highestAvailable is the registry editor (regedit.exe). If the user is a local admin, it
requests elevation. Otherwise, it still runs. Some parts of regedit will not function, such as making

Chapter 16: Security
176
changes in HKEY_LOCAL_MACHINE, which is not permitted for standard users; but the application
is still usable.
In Visual Studio, it’s easy to set one of these options without manually creating an XML file and
specifying it as a manifest (figure 16-21).
Figure 16-21: Elevation requirement in Visual Studio
UAC Virtualization
Many applications from the pre-Vista days were assuming (consciously or not) the user is a local
administrator. Some of these applications perform operations that only succeed with admin rights
like writing to system directories or writing to the HKEY_LOCAL_MACHINE\Software registry key.
What should happen when these applications run on Vista or later, where the default token used is
the standard user token?
The simplest option would be to return “access denied” errors to the application, but that would cause
these applications to malfunction, since they have not been updated to take UAC into consideration.
Microsoft’s solution was UAC Virtualization, where such applications are redirected to a private
area of the file system / registry under the user’s files / HKEY_CURRENT_USER hive, so the calls
don’t fail.

Chapter 16: Security
177
This is a double-edged sword, however. If such an application makes a change to system files (or
thinks it did), these are not really changed, so other applications that are not virtualized will not
pick up the changes. The application will see its own changes - the system first looks at the private
store and if not found, looks in the real locations.
For
the
file
system,
the
private
store
is
located
at
C:\Users\<username>\AppData\Local\VirtualStore. You can find more details by searching
for “UAC Virtualization” online.
UAC Virtualization is applied automatically to executables that are dimmed “legacy”, where “legacy”
means: 32-bit executables, with no manifest indicating it’s a Vista+ application. Regardless, UAC
virtualization can be turned on for other processes by enabling it in the access token. You can view
the UAC virtualization column in Task Manager. Three values are possible:
• Not Allowed - virtualization is disabled and cannot be enabled. This is the setting for system
processes and services.
• Disabled - virtualization is not active.
• Enabled - virtualization is active.
You can perform a simple experiment to see UAC virtualization in action.
• Open Notepad, write something and save the file to the System32 directory. This will fail, as
the process does not have permission to write to that directory.
• Go to Task Manager, right-click the Notepad process and enable UAC virtualization.
• Now attempt to save the file again in Notepad. This time this will succeed.
• Open Explorer and navigate to the System32 directory. Notice the file you saved is not there.
It’s been saved in the virtual store because of virtualization.
• Disable virtualization for Notepad and open the file from System32. It won’t be there.
Integrity Levels
Integrity Level is yet another feature introduced in Windows Vista (officially called Mandatory
Integrity Control). One reason for its existence is to separate processes running with a standard
rights token from processes running with an elevated token, under the same user. Clearly, the process
running with the elevated token is more powerful and is a preferable target for attackers. The way
to differentiate between them is using integrity levels.
Integrity levels are represented by SIDs, and for processes are stored in the process’ token. Table
16-3 shows the defined integrity levels.

Chapter 16: Security
178
Table 16-3: Standard integrity levels
Integrity level
SID
Remarks
System
S-1-16-16384
Highest, used by system processes and services
High
S-1-16-12288
Used by processes running with elevated token
Medium Plus
S-1-16-8448
Medium
S-1-16-8192
Used by processes running with standard user rights
Low
S-1-16-4096
Used by UWP processes and most browsers
Process Explorer has an Integrity Level column that shows integrity levels for processes (figure 16-
22).
Figure 16-22: Integrity Levels in Process Explorer
The AppContainer value for integrity level shown in figure 16-22 is equal to “Low”, but the term
AppContainer is used for the sandbox in which UWP processes live.

Chapter 16: Security
179
A related term to Integrity Level is Mandatory Policy, which indicates how the difference in integrity
levels actually affects operations. The default is No Write Up, which means that when a process tries
to access an object with a higher integrity level, a write type of access is not allowed. For example,
process A with integrity level medium that wants to open a handle to a process with integrity
level of high can only be granted the following access masks: PROCESS_QUERY_LIMITED_INFORMATION,
SYNCHRONIZE and PROCESS_TERMINATE.
What about objects that are not processes? All objects (including files) have an integrity level of
Medium, unless explicitly changed by adding an ACE of type “Mandatory Label” with a different
value. It’s always possible to set a lower integrity level than the caller’s token, but trying to set a
higher integrity level is only possible if the caller has the SeRelabelPrivilege, normally not granted
to anyone.
As another example, the fact that UWP processes run with low integrity means they cannot access
even common files locations like the user’s documents or pictures, because these have medium
integrity level. Most browsers today run their processes with low integrity level as well. This way,
if a malicious file is downloaded and executed by such a browser, it will execute with low integrity
level, limiting its ability to do any damage.
When an executable is launched, the integrity level of the new process is the minimum of
the integrity level of the executable file and the caller’s process token.
You can read the integrity level of a process with GetTokenInformation with the TokenIntegrityLevel
enumeration value, and set with SetTokenInformation.
How does integrity level fit in with DACLs? The integrity level takes precedence. If the integrity
level of the caller is equal or higher than the target object, then a normal access check is made using
DACLs. Otherwise, the “No Write-up” policy takes precedence.
For more information on integrity levels and related terms, consult the official documentation at
https://docs.microsoft.com/en-us/windows/win32/secauthz/mandatory-integrity-control.
UIPI
User Interface Privilege Isolation (UIPI) is a feature based on integrity levels. Suppose there is a
process with high integrity level that has windows (GUI). What happens if other processes, perhaps
with lower integrity levels, send messages to those windows? Sending uncontrolled messages to a
window can cause the thread that created the window to perform operations that may not normally
be allowed by the calling process.

Chapter 16: Security
180
UIPI is a mechanism that exists to prevent such occurrences. A process cannot send messages to a
window owner by another process with a higher integrity level, except for a few benign messages
(for example: WM_NULL, WM_GETTEXT and WM_GETICON).
The higher integrity level process can allow certain messages to go through by calling ChangeWindowMessageFilter
or ChangeWindowMessageFilterEx:
BOOL ChangeWindowMessageFilter(
_In_ UINT message,
_In_ DWORD dwFlag);
BOOL ChangeWindowMessageFilterEx(
_In_ HWND hwnd,
_In_ UINT message,
_In_ DWORD action,
_Inout_opt_ PCHANGEFILTERSTRUCT pChangeFilterStruct);
ChangeWindowMessageFilter accepts a message to let through or block and dwFlag can be MSGFLT_ADD
(allow) or MSGFLT_REMOVE (block). This call affects all windows in the process.
Windows 7 added ChangeWindowMessageFilterEx to allow fine-grained control over each individual
window. action can be MSGFLT_ALLOW (allow), MSGFLT_DISALLOW (block, unless allowed by a process-
wide filter), or MSGFLT_RESET (reset to the process-wide setting). pChangeFilterStruct is a pointer to
an optional structure that returns detailed information on the effects of calling these two functions.
Consult the documentation for more information.
Specialized Security Mechanisms
The fundamental security mechanisms, such as security descriptors and privileges have been in
place since the first version of Windows NT. Along the way, more security mechanisms were added
to Windows, such as mandatory integrity control. Today, the attacks by malicious actors are more
powerful than ever, and Windows tries to keep up by including new defense mechanisms. Many
of these are beyond the scope of this book (e.g. Virtualization Based Security). In this section, we’ll
look at some mechanisms that can be leveraged programmatically.
Control Flow Guard
Control Flow Guard (CFG) was introduced in Windows 10 and Server 2016 to mitigate a certain type
of attack, related to indirect calls. For example, a C++ virtual function call is done using a virtual
table pointer that points to a virtual table where the actual target functions are stored. Figure 16-23
shows how an example C++ object looks like in memory if it has any virtual functions.

Chapter 16: Security
181
Figure 16-23: C++ objects with virtual functions
Each object starts with a virtual table pointer (vptr) that points to the virtual table for class A.
A malicious agent that is injected into the process can write over the vptr (since it’s read/write
memory), and redirect the vptr to an alternate vtable of its choice (figure 16-24).
The V-table mechanism is also used by COM classes, so CFG is relevant for such objects as
well.

Chapter 16: Security
182
Figure 16-24: V-table redirection
CFG provides an extra check to be made before any indirect call. If the indirect call’s target is not
in one of the modules (DLLs and EXE) in the process, then it must have been redirected by some
shellcode injected into the process, and in that case the process terminates. This procedure is depicted
in figure 16-25.

Chapter 16: Security
183
Figure 16-25: CFG at work
Getting CFG support is fairly straightforward, by selecting the CFG option in the project’s properties
in Visual Studio (figure 16-26). Note that CFG conflicts with “Debug Information for Edit and
Continue”, so the latter must be changed to “Program Database”.

Chapter 16: Security
184
Figure 16-26: CFG options in Visual Studio
Here is an example of some C++ code (available in the CfgDemo application):
class A {
public:
virtual ~A() = default;
virtual void DoWork(int x) {
printf("A::DoWork %d\n", x);
}
};
class B : public A {
public:
void DoWork(int x) override {
printf("B::DoWork %d\n", x);
}
};
void main() {
A a;

Chapter 16: Security
185
a.DoWork(10);
B b;
b.DoWork(20);
A* pA = new B;
pA->DoWork(30);
delete pA;
}
Class A defines two virtual methods - the destructor and DoWork, so its v-table has two function
pointers, in this order.
The calls to a.DoWork and b.DoWork don’t need to happen polymorphically. The call pA->DoWork
must be made polymorphically. Here is the assembly output for pA->DoWork before CFG is applied
(x64, Debug):
; 29
:
pA->DoWork(30);
000a5
mov
rax, QWORD PTR pA$[rsp]
000aa
mov
rax, QWORD PTR [rax]
000ad
mov
edx, 30
000b2
mov
rcx, QWORD PTR pA$[rsp]
000b7
call
QWORD PTR [rax+8]
; normal call
You can see the value 30 put in EDX. RCX is the this pointer (all part of the x64 calling convention).
RAX point to the vtable, and the call itself is made indirectly 8 bytes into the v-table, because DoWork
is the second function (each function pointer is 8 bytes in 64-bit processes).
If assembly language is not your thing, you can safely skip this part and just know CFG
works.
After CFG is applied, here is the resulting code for pA->DoWork:

Chapter 16: Security
186
; 29
:
pA->DoWork(30);
000a5
mov
rax, QWORD PTR pA$[rsp]
000aa
mov
rax, QWORD PTR [rax]
000ad
mov
rax, QWORD PTR [rax+8]
000b1
mov
QWORD PTR tv70[rsp], rax ; tv70=128
000b9
mov
edx, 30
000be
mov
rcx, QWORD PTR pA$[rsp]
000c3
mov
rax, QWORD PTR tv70[rsp]
000cb
call QWORD PTR __guard_dispatch_icall_fptr
The last line is the important one. It calls a function in NtDll.dll that checks if the call target is valid.
If it is, it makes the call. Otherwise, it terminates the process.
Verify that the delete pA call (which invokes the destructor) is also invoked via CFG.
Binaries that support CFG have extra information in their PE that list the valid functions in the
binary. This includes not just the exported functions, but all functions. You can view this information
with dumpbin.exe:
C:\>dumpbin /loadconfig cfgdemo.exe
Microsoft (R) COFF/PE Dumper Version 14.27.28826.0
Copyright (C) Microsoft Corporation.
All rights reserved.
Dump of file c:\dev\temp\ConsoleApplication6\x64\Debug\cfgdemo.exe
File Type: EXECUTABLE IMAGE
Section contains the following load config:
...
000000014000F008 Security Cookie
0000000140015000 Guard CF address of check-function pointer
0000000140015020 Guard CF address of dispatch-function pointer
0000000140015010 Guard XFG address of check-function pointer
0000000140015030 Guard XFG address of dispatch-function pointer
0000000140015040 Guard XFG address of dispatch-table-function pointer
0000000140013000 Guard CF function table
1C Guard CF function count
00014500 Guard Flags
CF instrumented
FID table present

Chapter 16: Security
187
Export suppression info present
Long jump target table present
0000 Code Integrity Flags
0000 Code Integrity Catalog
00000000 Code Integrity Catalog Offset
00000000 Code Integrity Reserved
0000000000000000 Guard CF address taken IAT entry table
0 Guard CF address taken IAT entry count
0000000000000000 Guard CF long jump target table
0 Guard CF long jump target count
0000000000000000 Guard EH continuation table
0 Guard EH continuation count
0000000000000000 Dynamic value relocation table
0000000000000000 Hybrid metadata pointer
0000000000000000 Guard RF address of failure-function
0000000000000000 Guard RF address of failure-function pointer
00000000 Dynamic value relocation table offset
0000 Dynamic value relocation table section
0000 Reserved2
0000000000000000 Guard RF address of stack pointer verification function pointer
00000000 Hot patching table offset
0000 Reserved3
0000000000000000 Enclave configuration pointer
0000000000000000 Volatile metadata pointer
Guard CF Function Table
Address
--------
0000000140001040
@ILT+48(??_EB@@UEAAPEAXI@Z)
0000000140001050
@ILT+64(mainCRTStartup)
0000000140001100
@ILT+240(??_Ebad_array_new_length@std@@UEAAPEAXI@Z)
0000000140001110
@ILT+256(?DoWork@A@@UEAAXH@Z)
...
00000001400013F0
@ILT+992(?DoWork@B@@UEAAXH@Z)
...
Notice the two DoWork mangled functions and the various CFG information.
How does CFG work? The loader creates a large reserved bit map, where each valid function
“punches” a “1” bit into this large bit map. Checking if a function is valid is an O(1) operation,
where the function pointer is quickly shifted to the right to get to the bit representing it in the bit
map. If the bit is “1”, the function is valid. If the bit is “0” or the memory is not committed, the
address is bad and the process terminates.

Chapter 16: Security
188
The above explanation is not completely accurate, but it’s good enough for this book’s
purposes. To get the exact details, consult the Windows Internals, 7th edition, part 1 book.
Process Explorer has a CFG column for processes and modules. For processes, you can see the
Virtual Size column is roughly 2 TB for 64-bit processes. Most of that memory is the CFG bit map,
where most of the memory is reserved. You can verify this by opening the process in the VMMap
Sysinternals tool. Figure 16-27 shows VMMap for a Notepad instance and its CFG bitmap.
Figure 16-27: CFG bit map in VMMap
Process Mitigations
Windows 8 introduced process mitigations, the ability to set various security-related properties on
a process, in a one-way fashion; once a mitigation is set, it cannot be revoked. (If it could, then
malicious code could turn these mitigations off). The list of mitigations grows with almost every
release of Windows.
There are four ways to set process mitigations:
• Using group policy settings controlled by administrators in an organization.
• Using the Image File Execution Options registry key based on an executable’s name only (not
its full path).
• By calling CreateProcess with a process attribute to set mitigations on the created process.

Chapter 16: Security
189
• By calling SetProcessMitigationPolicy from within the process.
Using group policy is not interesting for the purpose of this book. We met the Image File Execution
Options (IFEO)registry key in chapter 13. The full key path is HKLM\SOFTWARE\Microsoft\Windows
NT\CurrentVersion\Image File Execution Options. This is a key read by the loader when a process
starts up to set various properties for the process. One of these is related to process mitigations. A
convenient way to experiment with many of these mitigations is using my GFlagsX tool. Figure
16-28 shows GFlagsX open with the Image tab selected. Here you can see the list of executables that
currently have some settings in their IFEO key. You can click New Image… and create a key for some
executable (Notepad.exe in the example) (the extension is mandatory).
Figure 16-28: GFlagsX
The left side of the window is related to NT Global Flags, that are not in the scope of this

Chapter 16: Security
190
chapter. Some of them will be discussed in chapter 20. The right side shows the Mitigation options
list. A detailed examination of all mitigation types is beyond the scope of this book (check the
documentation for full details). Here is a brief explanation for a few of them:
• Strict Handle Checks - if an invalid handle is used, terminate the process instead of just
returning an error. An invalid handle could be the result of injected malicious code closing
the handle or misusing it.
• Disable Win32K calls - raises an exception if any user32.dll or gdi32.dll call is made. Win32k.sys
is the kernel component of the Windows subsystem, and it has been used for various attacks
in the past (and probably present and future). If the process is just a worker that does need a
GUI, using this mitigation prevents Win32k exploits from this process.
• Control Flow Guard - requires all DLLs loaded to support CFG. Without it, non-CFG DLLs are
loaded normally, and their entire memory has to be set as a valid target for CFG in that case.
• Prefer System Images - ensures that any DLL loaded that exists in the System32 directory is
preferred to any other location (This does not include Known DLLs which are always obtained
from System32).
As a simple experiment, select Disable Win32K Calls for Notepad.exe and set it to Always On and
click Apply Settings. Now try to launch Notepad. It should fail, since Notepad requires user32.dll
and gdi32.dll. The value written to the registry by GFlagsX in this case is shown in figure 16-29.
Figure 16-29: IFEO value settings for mitigation options
Make sure you remove this mitigation for Notepad (or erase the key completely) so Notepad
can execute properly.
A parent process can set process mitigations to a child process by using the PROC_THREAD_-
ATTRIBUTE_MITIGATION_POLICY process attribute. (Process attributes were discussed in chapter 3).
The following is an example that uses CreateProcess to launch an executable with the CFG
mitigation in place:

Chapter 16: Security
191
HANDLE LaunchWithCfgMitigation(PWSTR exePath) {
PROCESS_INFORMATION pi;
STARTUPINFOEX si = { sizeof(si) };
SIZE_T size;
// the mitigation
DWORD64 mitigation =
PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_ALWAYS_ON;
// get required size for one attribute
::InitializeProcThreadAttributeList(nullptr, 1, 0, &size);
// allocate
si.lpAttributeList = (PPROC_THREAD_ATTRIBUTE_LIST)::malloc(size);
// initialize with one attribute
::InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
// add the attribute we want
::UpdateProcThreadAttribute(si.lpAttributeList, 0,
PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY,
&mitigation, sizeof(mitigation), nullptr, nullptr);
// create the process
BOOL created = ::CreateProcess(nullptr, exePath, nullptr, nullptr, FALSE,
EXTENDED_STARTUPINFO_PRESENT, nullptr, nullptr, (STARTUPINFO*)&si, &pi);
// free resources
::DeleteProcThreadAttributeList(si.lpAttributeList);
::free(si.lpAttributeList);
::CloseHandle(pi.hThread);
return created ? pi.hProcess : nullptr;
}
The child process has no “say” in the mitigations applied to it - it must be able to cope.
The last way to set mitigations is from the process itself by calling SetProcessMitigationPolicy.
However, not all mitigation options are settable this way (check the docs for each mitigation’s
deatils).

Chapter 16: Security
192
BOOL SetProcessMitigationPolicy(
_In_ PROCESS_MITIGATION_POLICY MitigationPolicy,
_In_ PVOID lpBuffer,
_In_ SIZE_T dwLength);
PROCESS_MITIGATION_POLICY is an enumeration with the various mitigations supported. lpBuffer is
a pointer to the relevant structure depending on the type of mitigation. Finally, dwLength is the size
of the buffer.
The following example shows how to set the load image policy mitigation options:
PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = { 0 };
policy.NoRemoteImages = true;
policy.NoLowMandatoryLabelImages = true;
::SetProcessMitigationPolicy(ProcessImageLoadPolicy,
&policy, sizeof(policy));
Summary
Security in Windows is a big topic, that probably requires a book onto itself. In this chapter, we
looked at the major concepts in the Windows security system, and examined various APIs for
working with security. More information can be found in the official documentation and various
online resources.
In the next chapter, we’ll turn our attention to the most famous database in Windows - the Registry.

Chapter 17: The Registry
The Windows Registry is a foundational piece of Windows NT from its inception. It’s a hierarchical
database that stores information relevant to the system and its users. Some of the data is volatile,
meaning it’s generated while the system is running, and deleted when the system shuts down. Non-
volatile data, on the other hand, is persisted in files.
Windows has several built-in tools for examining and manipulating the Registry. The primary GUI
tool is Regedit.exe, while the classic command-line tool is reg.exe. There is another option for batch
/ command-line style manipulation using PowerShell.
Working with reg.exe and PowerShell is beyond the scope of this chapter.
The Registry was used quite heavily in the past by software developers to store various pieces of
information for their applications, and this is still done to some extent. The recommendation is
not to use the Registry to store application or user-related data. Instead, applications should store
information in the file-system, typically in some convenient format, like INI, XML, JSON or YAML
(to name a few of the common ones). The Registry should be left for Windows only. That said, it’s
sometimes convenient to store some information in the Registry if it’s small. One common technique
is to store a path to a file in a Registry value so that the bulk of the information is stored in that file,
only pointed to by the Registry.
In this chapter, we’ll examine the most important parts of the Registry and how to program against
it.
In this chapter:
• The Hives
• 32-bit Specific Hives
• Working with Keys and Values
• Registry Notifications
• Transactional Registry
• Miscellaneous Registry Functions

Chapter 17: The Registry
194
The Hives
The Registry is divided into hives, each one exposed certain pieces of information. Although
RegEdit.exe shows 5 hives, there are just two “real” ones, HKEY_USERS and HKEY_LOCAL_MA-
CHINE. All the others are made of some combination of data within these two “real” hives. Figure
17-1 shows the hives in Regedit.exe.
Figure 17-1: The hives
The following sections provide a brief description of the hives.
HKEY_LOCAL_MACHINE
This hive stores machine-wide information that is not specific to any user. Much of the data is very
important for proper system startup, that care must be taken when any changes are made. By default,
only admin-level users can make changes to this hive. Here are some of the important subkeys:
• SOFTWARE - this is where installed applications typically store their non-user-specific infor-
mation. The common subkey pattern is SOFTWARE\[CompanyName]\[ProductName]\[Version]
(the “Version” part is not always used), which may be followed by more subkeys. For example,
Microsoft Office stores its machine-wide information at SOFTWARE\Microsoft\Office with
some pieces of information stored in a version subkey.
• SYSTEM - this is where most system parameters are stored and read by various system
components when these start up. Here are some example of subkeys with useful information
for developers:
– SYSTEM\CurrentControlSet\Services - stores information on services and device drivers
installed on the system. We’ll take a deeper look at this key in chapter 19 (“Services”).
– SYSTEM\CurrentControlSet\Enum - this subkey is the parent key for hardware device
drivers.
– SYSTEM\CurrentControlSet\Control - this subkey is the parent key for many knobs
that various system components look at, such as the kernel itself, the session manager

Chapter 17: The Registry
195
(Smss.exe), the Win32 subsystem process (csrss.exe), the service control manager (Ser-
vices.exe) and others.
– SYSTEM\BCD00000000 - stores Boot Configuration Data (BCD) information.
– SYSTEM\SECURITY - stores information for the local security policy (this key is inacces-
sible by default for administrators but is accessible to the SYSTEM account).
– SYSTEM\SAM - stores local user and group information (same access limitation as the
above key).
You can view the SAM and SECURITY subkeys by running Regedit.exe with the SYSTEM
account by using (for example) the PsExec Sysinternals tool like so: psexec
-s
-i
-d
regedit. The alternative is to exercise the Take Ownership privilege and change the DACL
on these keys to allow administrator access (see chapter 16), but this is not recommended.
The subkey SYSTEM\CurrentControlSet is a link to the SYSTEM\ControlSet001 subkey. The reason
for this indirection has to do with an old feature of Windows NT called Last Known Good. In some
cases, there may be more than one “control set”. The subkey SYSTEM\Select holds values to indicate
which is the “current” control set.
Some of the details of Last Known Good are discussed in chapter 19.
The information in this hive is mostly persisted in files located in the %SystemRoot%\System32\Config
directory. Table 17-1 lists the subkeys and their corresponding storage file (the format of these files
is undocumented).
Table 17-1: Backup files for some hives
Subkey
File name
HKEY_LOCAL_MACHINESAM
SAM
HKEY_LOCAL_MACHINESecurity
SECURITY
HKEY_LOCAL_MACHINESoftware
SOFTWARE
HKEY_LOCAL_MACHINESystem
SYSTEM
The full list of hives and their storage files can be found in the Registry itself under the key
HKLM\System\CurrentControlSet\Control\hivelist.
HKEY_USERS
The HKEY_USERS hive stores all per-user information for each user that ever logged on on the local
system. Figure 17-2 shows an example of such a hive. Each user is represented by its SID (as a string).

Chapter 17: The Registry
196
Figure 17-2: HKEY_USERS hive
The .DEFAULT subkey stores the default values newly created users get. The next three short SID
values should look familiar from chapter 16 - they are for the SYSTEM, Local Service and Network
Service accounts. Then the long random-like SID represents a “normal” user. The second SID that
looks like the above one with the suffix “_Classes” is related to the HKEY_CLASSES_ROOT hive,
described in a subsequent section.
If you open one of the SID subkeys, you’ll discover various per-user settings related to the desktop,
console, environment variables, colors, keyboard, printers, and more. These settings are read by
various components, such as Windows Explorer, to tailor the environment to the user’s wishes.
HKEY_CURRENT_USER (HKCU)
The HKEY_CURRENT_USER hive is a link to the current user running RegiEdit.exe, showing the
same information from HKEY_USERS for that user. The data in this hive is persisted in a hidden file
named NtUser.dat, located in the user’s directory (e.g. c:\users\username)
HKEY_CLASSES_ROOT (HKCR)
This is a rather curious hive, built from existing keys, combining the following:
• HKEY_LOCAL_MACHINE\Software\Classes
• HKEY_CURRENT_USER\Software\Classes (HKEY_USERS\{UserSid}_Classes)
In case of conflict, HKEY_CURRENT_USER settings override HKEY_LOCAL_MACHINE, since the
user’s choice should have higher priority than the machine default. HKEY_CLASSES_ROOT contains
two pieces of information:

Chapter 17: The Registry
197
• Explorer Shell data: file types and associations, as well as shell extension information.
• Component Object Model (COM)-related information.
The Explorer shell information includes file type and associated actions. For example, searching
for .txt in HKEY_CLASSES_ROOT finds a key, in which the default value is txtfile. Looking
for a txtfile key locates the subkey shell\open\command, where its default value is %System-
Root%\System32\NOTEPAD.EXE %1, clearly indicating Notepad as the default application to open
txt files.
Other shell-related keys include the various shell extensions supported by the Explorer shell, such
as custom icons, custom context menus, item previews, and even full-blown shell extensions. (Shell
customization is beyond the scope of this book).
The more fundamentally important information in HKEY_CLASSES_ROOT has to do with COM
registration. The details are important and discussed in length in chapter 21.
HKEY_CURRENT_CONFIG (HKCC)
This hive is just a link to HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Hardware Pro-
files\Current. It’s mostly uninteresting in the context of this book.
HKEY_PERFORMANCE_DATA
This hive is not visible in Regedit.exe, and for good reason. This hive serves as a legacy mechanism
to consume Performance Counters (discussed in chapter 20). Starting with Windows 2000, there is a
new API for working with performance counters, and it’s preferred over using Registry APIs with
HKEY_PERFORMANCE_DATA.
32-bit Specific Hives
On 64-bit systems, some parts of the Registry should have distinct keys for 32-bit vs. 64-bit. For exam-
ple, application installation information is commonly stored in HKLM\Software\{CompanyName}\{AppName}.
Some applications can be installed as 32-bit and 64-bit on the same system. In such cases, there must
be a way to distinguish the 32-bit settings from the 64-bit settings.
32-bit processes that open the above-mentioned key receive another key that starts withHKLM\Software\Wow6432No
This redirection is transparent and does not require the application to do anything special. 64-bit
processes see the Registry as it is, with no such redirection taking place.
This redirection is often referred to as Registry Virtualization.

Chapter 17: The Registry
198
HKLM\Software is not the only key that goes through redirection for 32-bit processes. Some COM-
related information is also redirected from HKCR to HKCR\Wow3264Node. Here are some example
subkeys that get redirected:
• HKCR\CLSID is redirected for all in-process (DLL) COM components (see chapter 21) to
HKCR\Wow6432Node\CLSID.
• HKCR\AppID, HKCR\Interface, and HKCR\TypeLib are redirected similarly to the Wow64
subkey.
32-bit processes get this redirection automatically, but such processes can opt-out of this redirection
by specifying the KEY_WOW64_64KEY access flag in RegCreateKeyEx and RegOpenKeyEx functions (see
next section). The opposite flag exists as well (KEY_WOW64_32KEY) to allow 64-bit processes to access
the 32-bit registry parts without specifying Wow6432Node in key names.
Working with Keys and Values
Opening an existing Registry key is accomplished with RegOpenKeyEx:
LSTATUS RegOpenKeyEx(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey,
_In_opt_ DWORD ulOptions,
_In_ REGSAM samDesired,
_Out_ PHKEY phkResult);
The first visible change from most other APIs is the return value. It’s a 32-bit signed integer, returning
the error code of the operation. This is the same value returned by GetLastError used with other
APIs returning BOOL, HANDLE and similar. This means success is ERROR_SUCCESS (0); also, no point in
calling GetLastError - in fact, this should be avoided, as its value does not change because of the
Registry API call.
Now let’s get to the actual function. hKey is the base key from which to interpret lpSubKey. This
could be one of the predefined keys (HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER, etc.) or a key handle
from an earlier Registry API call. The subkey, by the way, is case insensitive.
ulOptions can be zero or REG_OPTION_OPEN_LINK, in the latter case if the key is a link (to another
key), the link key itself is opened, rather than the link’s target. Specifying zero is the common case.
samDesired is the required access mask to open the key with. If the access cannot be granted,
the call fails with an “access denied” error code (5). Common access masks include KEY_READ
for all query/enumerate operations and KEY_WRITE for write/modify values and creating subkeys
operations. This is also where the 32-bit or 64-bit Registry view can be specified as described in the
previous section. You can find the complete list of Registry key access masks in the documentation.

Chapter 17: The Registry
199
Finally, phkResult is the returned key handle if the call is successful. Notice that Registry keys have
their own type (HKEY), which is no different than other HANDLE types (all are opaque void*), but
Registry keys have their own close function:
LSTATUS RegCloseKey(_In_ HKEY hKey);
You may be wondering why Registry key handles are “special”. One reason has to do
with the fact that Registry keys may be opened to another machine’s Registry (using the
Remote Registry service, if enabled), which means that some close operations may involve
communication with the remote system.
The non-Ex function (RegOpenKey) still exists and supported, mainly for compatibility with
16-bit Windows. There is no good reason to use this (and other similar) functions.
RegOpenKeyEx opens an existing key and fails if the key does not exist. To create a new key, call
RegCreateKeyEx:
LSTATUS RegCreateKeyEx(
_In_ HKEY hKey,
_In_ LPCTSTR lpSubKey,
_Reserved_ DWORD Reserved,
_In_opt_ LPTSTR lpClass,
_In_ DWORD dwOptions,
_In_ REGSAM samDesired,
_In_opt_ CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
_Out_ PHKEY phkResult,
_Out_opt_ LPDWORD lpdwDisposition);
hKey is the base key to start with, which can be a value obtained from a previous call to
RegCreateKeyEx/RegOpenKeyEx or one of the standard predefined keys. The ability of the caller to
create a new subkey depends on the security descriptor of the key hKey, rather than the access mask
with which hKey was opened. lpSubKey is the subkey to create. It must be under hKey (directly or
indirectly), meaning the subkey can have multiple subkeys separated by a backslash. If successful,
the function creates all intermediate subkeys.
Reserved should be zero and lpClass should be NULL; both serve no purpose. dwOptions is usually
zero (equivalent to REG_OPTION_NON_VOLATILE). This value indicates a non-volatile key, that is saved
when the hive key is persisted. Additionally, the following combination of values can be specified:
• REG_OPTION_VOLATILE - the opposite of REG_OPTION_NON_VOLATILE - the key is created as
volatile, meaning it’s stored in memory, but is discarded once the hive key is unloaded.
• REG_OPTION_CREATE_LINK - creates a symbolic link key, rather than a “real” key. (See the section
“Creating Registry Links”, later in this chapter)

Chapter 17: The Registry
200
• REG_OPTION_BACKUP_RESTORE - the function ignores the samDesired parameter, and instead
creates/opens the key with ACCESS_SYSTEM_SECURITY and KEY_READ if the caller has the
SeBackupPrivilege in its token. If the caller has SeRestorePrivilege in its token, then ACCESS_-
SYSTEM_SECURITY, DELETE and KEY_WRITE are granted. If both privileges exist, then the resulting
access is a union of both, effectively granting full access to the key.
samDesired is the usual access mask the caller requests. lpSecurityAttributes is the usual
SECURITY_ATTRIBUTES we are familiar with. phkResult is the resulting key if the operation is
successful. Finally, the last (optional) parameter, lpdwDisposition returns whether the key was
actually created (REG_CREATED_NEW_KEY) or an existing key was opened (REG_OPENED_EXISTING_KEY).
A newly created key has no values.
Reading Values
With an open key (whether created or opened), several operations are possible. The most basic is
reading and writing values. Reading a value is possible with RegQueryValueEx:
LSTATUS RegQueryValueEx(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpValueName,
_Reserved_ LPDWORD lpReserved,
_Out_opt_ LPDWORD lpType,
_Out_ LPBYTE lpData,
_Inout_opt_ LPDWORD lpcbData);
hKey is the key from which to read, which can be a previously opened key or one of the predefined
keys (including the less common ones, like HKEY_PERFORMANCE_DATA). lpValueName is the value name
to query. If it’s NULL or an empty string, the default value of the key is retrieved (if any).
lpReserved is just that, and should be set to NULL. lpType is an optional pointer returning the type
of the returned data, one of the values shown in table 17-2.
Table 17-2: Registry value types
Value
Description
REG_NONE (0)
No value type
REG_SZ (1)
NULL-terminated Unicode string
REG_EXPAND_SZ (2)
NULL-terminated Unicode string (may contain unexpanded
environment variables in %%)
REG_BINARY (3)
Binary (any) data
REG_DWORD (4)
32-bit number (little endian)
REG_DWORD_LITTLE_ENDIAN (4)
Same as above
REG_DWORD_BIG_ENDIAN (5)
32-bit number (big endian)
REG_LINK (6)
Symbolic link (Unicode)

Chapter 17: The Registry
201
Table 17-2: Registry value types
Value
Description
REG_MULTI_SZ (7)
Multiple Unicode strings separated by NULL, second NULL
terminates
REG_RESOURCE_LIST (8)
CM_RESOURCE_LIST structure (useful in kernel mode only)
REG_FULL_RESOURCE_DESCRIPTOR (9)
CM_FULL_RESOURCE_DESCRIPTOR (useful in kernel mode only)
REG_RESOURCE_REQUIREMENTS_LIST (10)
Useful in kernel mode only
REG_QWORD (11)
64-bit number (little endian)
REG_QWORD_LITTLE_ENDIAN (11)
Same as above
lpType can be specified as NULL in case the caller is not interested in this information. This is typically
the case when the caller knows what to expect. lpData is a caller-allocated buffer to the data itself.
For some value types, the size is constant (such as 4 bytes for REG_DWORD), but others are dynamic
(e.g. REG_SZ, REG_BINARY), meaning the caller needs to allocate a large-enough buffer, otherwise only
part of the data is copied, and the function returns ERROR_MORE_DATA. The size of the caller’s buffer
is specified with the last parameter. On input, it should contain the caller’s buffer size. On output,
it contains the number of bytes written. If the caller needs the data size, it can pass NULL for lpData
and get back the size in lpcbData.
The following example shows how to read the string value at HKCU\Console\FaceName (error
handling omitted):
HKEY hKey;
::RegOpenKeyEx(HKEY_CURRENT_USER, L"Console", 0, KEY_READ, &hKey);
DWORD type;
DWORD size;
// first call to get size
::RegQueryValueEx(hKey, L"FaceName", nullptr, &type, nullptr, &size);
assert(type == REG_SZ);
// returned size includes the NULL terminator
auto value = std::make_unique<BYTE[]>(size);
::RegQueryValueEx(hKey, L"FaceName", nullptr, &type, value.get(), &size);
::RegCloseKey(hKey);
printf("Value: %ws\n", (PCWSTR)value.get());
Another function is available for retriveing values, RegGetValue:

Chapter 17: The Registry
202
LSTATUS RegGetValue(
_In_ HKEY hkey,
_In_opt_ LPCSTR lpSubKey,
_In_opt_ LPCSTR lpValue,
_In_ DWORD dwFlags,
_Out_opt_ LPDWORD pdwType,
_Out_ PVOID pvData,
_Inout_opt_ LPDWORD pcbData);
The function is similar to RegQueryValueEx, but adds the nice option (via the dwFlags parameter) of
restricting the value type(s) that may be returned. This allows a caller to get a failure if the value
it expects is not of the expected type (and saves the time it takes to retrive the data). The dwFlags
value can be a combination of the values shown in table 17-3.
Table 17-3: Flags to RegGetValue
Value
Description
RRF_RT_REG_NONE (1)
Allow REG_NONE type
RRF_RT_REG_SZ (2)
Allow REG_SZ type
RRF_RT_REG_EXPAND_SZ (4)
Allow REG_EXPAND_SZ type. Expand environment variables unless the
flag RRF_NOEXPAND is specified
RRF_RT_REG_BINARY (8)
Allow REG_BINARY type
RRF_RT_REG_DWORD (0x10)
Allow REG_DWORD type
RRF_RT_REG_MULTI_SZ (0x20)
Allow REG_MULTI_SZ type
RRF_RT_REG_QWORD (0x40)
Allow REG_QWORD type
RRF_RT_DWORD
RRF_RT_REG_BINARY | RRF_RT_REG_DWORD
RRF_RT_QWORD
RRF_RT_REG_BINARY | RRF_RT_REG_QWORD
RRF_RT_ANY (0x0000ffff)
no type restriction
RRF_SUBKEY_WOW6464KEY (0x10000)
(Win 10+) open the 64-bit key (if subkey is not NULL)
RRF_SUBKEY_WOW6432KEY (0x20000)
(Win 10+) open the 32-bit key (if subkey is not NULL)
RRF_NOEXPAND (0x10000000)
do not expand a REG_EXPAND_SZ result
RRF_ZEROONFAILURE (0x20000000)
fill the buffer with zeros on failure
Writing Values
To write a value to a Registry key, call RegSetValueEx:

Chapter 17: The Registry
203
LSTATUS RegSetValueEx(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpValueName,
_Reserved_ DWORD Reserved,
_In_ DWORD dwType,
_In_ CONST BYTE* lpData,
_In_ DWORD cbData);
Most of the parameters should be self-explanatory at this point. hKey is the key to write to, which
must have at least the KEY_SET_VALUE access mask (typically, the key is opened with the KEY_WRITE
access mask that includes KEY_SET_VALUE). lpValueName is the value name to set, and is not case
sensitive. If this name is NULL or an empty string, it sets the default value (which can be of any type).
The Reserved argument must be zero.
The data type is specified with the dwType parameter, and must be one of the values in table 17-2
(see the section Creating Registry Links for the special case of REG_LINK). The data itself consists of
a generic pointer (lpData) and size. The data must be appropriate to the type specified. Some of the
types have fixed sizes (e.g. REG_DWORD), while others can be of arbitrary length (e.g. REG_SZ, REG_-
BINARY, REG_MULTI_SZ). Be sure to end a string (REG_SZ) with a NULL terminator, and end MULTI_SZ
with two NULL terminators. Noe that the size specified (cbData) is always in bytes, regardless of the
value type. For strings, this size must include the terminating NULL(s).
If the value specified already exists, it’s overwritten with the new value.
The following example changes the FaceName value at HKEY_CURRENT_USER\Console to “Arial”
(error handling omitted):
HKEY hKey;
::RegOpenKeyEx(HKEY_CURRENT_USER, L"Console", 0, KEY_WRITE, &hKey);
WCHAR value[] = L"Arial";
::RegSetValueEx(hKey, L"FaceName", 0, REG_SZ, (const BYTE*)value, sizeof(value));
::RegCloseKey(hKey);
An alternative function is available for the same purpose, RegSetKeyValue:
LSTATUS RegSetKeyValue(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey,
_In_opt_ LPCTSTR lpValueName,
_In_ DWORD dwType,
_In_reads_bytes_opt_(cbData) LPCVOID lpData,
_In_ DWORD cbData);
The function is almost identical to RegSetValueEx. It’s sometimes more convenient to use because it
allows specifying a subkey (‘lpSubKey) relative to hKey‘, which is the final key where to set the
value. This avoids the need to open the subkey explicitly if a handle to it is not readily available.

Chapter 17: The Registry
204
Deleting Keys and Values
A Registry key can be deleted by calling RegDeleteKey or RegDeleteKeyEx:
LSTATUS RegDeleteKey (
_In_ HKEY hKey,
_In_ LPCTSTR lpSubKey);
LSTATUS RegDeleteKeyEx(
_In_ HKEY hKey,
_In_ LPCTSTR lpSubKey,
_In_ REGSAM samDesired,
_Reserved_ DWORD Reserved);
RegDeleteKey is the simplest function, deleting the subkey (and all its values) relative to the open
hKey. The access mask used to open the key does not matter - it’s the security descriptor on the key
that indicates whether the caller can perform the delete operation.
RegDeleteKeyEx adds the option to change the registry view by specifying KEY_WOW64_32KEY or KEY_-
WOW64_64KEY for the samDesired parameter. See the discussion in the section “32-bit Specific Hives”
earlier in this chapter.
The deleted key is marked for deletion, and is only deleted once all open handles to the key are
closed. The above delete functions can only delete a key with no-sub keys. If the key has subkeys,
the functions fail and return ERROR_ACCESS_DENIED (5).
To delete a key with all its subkeys, call RegDeleteTree:
LSTATUS RegDeleteTree(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey);
hKey must be opened with the following rights: DELETE, KEY_ENUMERATE_SUB_KEYS, KEY_QUERY_VALUE
and (if the key has any values) KEY_SET_VALUE. if lpSubKey is NULL, all keys and values are removed
from the key specified by hKey.
Deleting values is simple enough with RegDeleteKeyValue or RegDeleteValue:

Chapter 17: The Registry
205
LSTATUS RegDeleteValue(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpValueName);
LSTATUS RegDeleteKeyValue(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey,
_In_opt_ LPCTSTR lpValueName);
hKey must be opened with KEY_SET_VALUE access mask. RegDeleteValue deletes the given value in
hKey, and RegDeleteKeyValue allows specifying a subkey to reach from the given key from which
to delete a value.
RegDeleteValue is better for performance reason, becuase internally, whenever a subkey is
provided, the API opens the subkey, performs the operation and closes the subkey. This is
also true for other functions where a subkey is optional. If you have a direct key handle, it’s
always faster to use.
Creating Registry Links
The Registry supports links - keys that point to other keys. We’ve already met a few of these. For
example, the key HKEY_LOCAL_MACHINE\System\CurrentControlSet is a symbolic link to HKEY_-
LOCAL_MACHINE\System\ControlSet001 (in most cases). Looking at such keys with RegEdit.exe,
symbolic links look like normal keys, in the sense that they behave as the link’s target. Figure 17-3
shows the above-mentioned keys - they look and behave exactly the same.

Chapter 17: The Registry
206
Figure 17-3: A key and a link to that key
My own Registry editor, RegEditX.exe dows show links with a different icon (figure 17-4). It also
reveals the way the link’s target is stored - using the value name SymbolicLinkName.
Figure 17-4: A key and a link to that key in RegEditX.exe
The Microsoft documentation does provide full information on how to create Registry links.
The first step is to create the key and specify it to be a link rather than a normal key. The

Chapter 17: The Registry
207
following example assumes our intention is to create a link under HKEY_CURRENT_USER named
DesktopColors that links to HKEY_CURRENT_USER\Control Panel\Desktop\Colors. The following
snippet creates the required key as a link by specifying the option REG_OPTION_CREATE_LINK in the
call to RegCreateKeyEx (error handling omitted):
HKEY hKey;
::RegCreateKeyEx(HKEY_CURRENT_USER, L"DesktopColors", 0, nullptr,
REG_OPTION_CREATE_LINK, KEY_WRITE, nullptr, &hKey, nullptr);
Now comes the first tricky part. The documentation states that the link’s target should be written to
a value named SymbolicLinkValue and it must be an absolute registry path. The issue here is the “ab-
solute path” required is not something like HKEY_CURRENT_USER\Control Panel\Desktop\Colors.
Instead, it must be the absolute path in the way the kernel sees the Registry. You can see what this
looks like in RegEditX.exe if you open the tree node named “Registry” (figure 17-5).
Figure 17-5: The “real” Registry in RegEditX.exe
This means that HKEY_CURRENT_USER must be translated to HKEY_USERS\. This can be done
with a hardcoded SID string, but it would be better to obtain this dynamically. Fortunately, based

Chapter 17: The Registry
208
on the information detailed in chapter 16, we can get the current user’s SID as a string like so (error
handling omitted yet again):
HANDLE hToken;
::OpenProcessToken(::GetCurrentProcess(), TOKEN_QUERY, &hToken);
// Win8+: HANDLE hToken = ::GetCurrentProcessToken();
BYTE buffer[sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE];
DWORD len;
::GetTokenInformation(hToken, TokenUser, buffer, sizeof(buffer), &len);
::CloseHandle(hToken);
auto user = (TOKEN_USER*)buffer;
PWSTR stringSid;
::ConvertSidToStringSid(user->User.Sid, &stringSid);
// use stringSid...
::LocalFree(stringSid);
Now we can compose the absolute path like so:
// using std::wstring for convenience
std::wstring path = L"\\REGISTRY\\USER\\";
path += stringSid;
path += L"\\Control Panel\\Desktop\\Colors";
The second tricky part is that the link’s path must be written to the registry without the terminating
NULL bytes to the value SymbolicLinkValue:
::RegSetValueEx(hKey, L"SymbolicLinkValue", 0, REG_LINK, (const BYTE*)path.c_str(),
path.size() * sizeof(WCHAR));
// note - NULL terminator not counted in
This gets the job done. Deleting a Registry link cannot be accomplished with RegDeleteKey(Ex)
discussed in the previous section. if you try it, it deletes the target of the link, rather than the link
itself. A link can only be deleted by using the pseudo-documented native function NtDeleteKey
(from Ntdll.dll). To use it, we first must declare it and link against the ntdll import library (the other
option for linking is to dynamically call GetProcAddress to discover the address of NtDeleteKey):
extern "C" int NTAPI NtDeleteKey(HKEY);
#pragma comment(lib, "ntdll")
Now we can delete the symbolic link key like so:

Chapter 17: The Registry
209
HKEY hKey;
::RegOpenKeyEx(HKEY_CURRENT_USER, L"DesktopColors", REG_OPTION_OPEN_LINK,
DELETE, &hKey);
::NtDeleteKey(hKey);
::RegCloseKey(hKey);
Lastly, the RegCreateKeyEx cannot open an existing link - it can only create one. This is contrast to
“normal” keys that can be opened or created by RegCreateKeyEx. Opening a link must be done with
RegOpenKeyEx with the flag REG_OPTION_OPEN_LINK in the options parameter.
Enumerating Keys and Values
Tools such as RegEdit.exe need to enumerate subkeys under a certain key or the values set on that
key. Enumerating the subkeys is done with RegEnumKeyEx:
LSTATUS RegEnumKeyEx(
_In_ HKEY hKey,
_In_ DWORD dwIndex,
_Out_ LPTSTR lpName,
_Inout_ LPDWORD lpcchName,
_Reserved_ LPDWORD lpReserved,
_Out_ LPTSTR lpClass,
_Inout_opt_ LPDWORD lpcchClass,
_Out_opt_ PFILETIME lpftLastWriteTime);
The hKey handle must be opened with the KEY_ENUMERATE_SUB_KEYS access mask for the call to work.
The way enumeration is performed is by specifting an index of zero for dwIndex and incrementing
it in a loop, until the call returns ERROR_NO_MORE_ITEMS, indicating there are no more keys. The
results returned always include the key’s name (lpName), which must be accompanied by its size
(lpcchName, set on input to the maximum number of characters the buffer can store including the
NULL terminator, and changed by the function on output to the actual number of characters written
excluding the terminating NULL). The name is the key’s simple name, not the absolute name from
the hive root. If the lpName buffer is not large enough to contain the key name, the function fails
with ERROR_MORE_DATA and nothing is written to the lpName buffer.
The maximum key name length is 255 characaters.
Two other optional pieces of information may be returned: the class name (an optional user-defined
value that is rarely used) and the last time the key was modified.
The following example, taken from the DumpKey.exe application (part of this chapter’s code
samples) shows how to enumerate keys:

Chapter 17: The Registry
210
#include <atltime.h>
void DumpKey(HKEY hKey, bool dumpKeys, bool dumpValues, bool recurse) {
FILETIME modified;
//...
if (dumpKeys) {
printf("Keys:\n");
WCHAR name[256];
for (DWORD i = 0; ; i++) {
DWORD cname = _countof(name);
auto error = ::RegEnumKeyEx(hKey, i, name, &cname, nullptr, nullptr,
nullptr, &modified);
if(error == ERROR_NO_MORE_ITEMS)
// enumeration complete
break;
// cannot really happen, as the key name buffer is large enough
if (error == ERROR_MORE_DATA) {
printf(" (Key name too long)\n");
continue;
}
if (error == ERROR_SUCCESS)
printf(" %-50ws Modified: %ws\n", name,
(PCWSTR)CTime(modified).Format(L"%c"));
if (recurse) {
HKEY hSubKey;
if (ERROR_SUCCESS == ::RegOpenKeyEx(hKey, name, 0, KEY_READ,
&hSubKey)) {
printf("--------\n");
printf("Subkey: %ws\n", name);
DumpKey(hSubKey, dumpKeys, dumpValues, recurse);
::RegCloseKey(hSubKey);
}
}
}
}
}
Enumerating values within a given key is done in a similar manner, with RegEnumValue:

Chapter 17: The Registry
211
LSTATUS RegEnumValue(
_In_ HKEY hKey,
_In_ DWORD dwIndex,
_Out_ LPTSTR lpValueName,
_Inout_ LPDWORD lpcchValueName,
_Reserved_ LPDWORD lpReserved,
_Out_opt_ LPDWORD lpType,
_Out_opt_ LPBYTE lpData,
_Inout_opt_ LPDWORD lpcbData);
The function works in a similar way to RegEnumKeyEx, where dwIndex should start at zero and
incremeneted in a loop until the function returns ERROR_NO_MORE_ITEMS. hKey must have the
KEY_QUERY_VALUE access mask (also part of KEY_READ), otherwise the function returns ERROR_-
ACCESS_DENIED. The only mandatory return result is the value’s name, specified by the lpValueName
buffer and its size (lpcchValueName). The same rules apply here as with RegEnumKeyEx: if the value
name buffer is not large enough, nothing is returned in the name. This is trickier than the case for
RegEnumKeyEx, because the maximum length of a value’s name is 16383 characters. The simplest way
to resolve this is to allocate a buffer 16384 characters in size (adding the NULL terminator), but this
could be considered inefficient. An alternative way to handle this is to call RegQueryInfoKey before
enumeration begins, that can return the maximum value name’s length within the given key:
LSTATUS RegQueryInfoKey(
_In_ HKEY hKey,
_Out_opt_ LPWSTR lpClass,
_Inout_opt_ LPDWORD lpcchClass,
_Reserved_ LPDWORD lpReserved,
_Out_opt_ LPDWORD lpcSubKeys,
// # if subkeys
_Out_opt_ LPDWORD lpcbMaxSubKeyLen,
// max subkey length
_Out_opt_ LPDWORD lpcbMaxClassLen,
_Out_opt_ LPDWORD lpcValues,
// # values
_Out_opt_ LPDWORD lpcbMaxValueNameLen,
// max value name length
_Out_opt_ LPDWORD lpcbMaxValueLen,
// max value size
_Out_opt_ LPDWORD lpcbSecurityDescriptor,
_Out_opt_ PFILETIME lpftLastWriteTime);
This function contains too many parameters for my taste, it would have been better to set all these
values in a structure. Nevertheless, it’s fairly easy to use. Most of the parameters are optional,
allowing the caller to retrieve only the information it cares about. The maximum value name
length is provided, allowing the caller to allocate a large enough buffer for any value’s name in
the enumeration, which is most likely smaller than 16384 characters.
Back to RegEnumValue - the function optionally returns the value’s type (lpType) and the value itself
(lpData). If the value is needed (lpData is not NULL), the buffer for the value must be large enough to

Chapter 17: The Registry
212
contain the entire value, otherwise the function fails with ERROR_MORE_DATA and nothing is written
to the buffer.
The following example (taken from the DumpKey sample), enumerates values and displays the
value’s name and value (for the most common types):
void DumpKey(HKEY hKey, bool dumpKeys, bool dumpValues, bool recurse) {
DWORD nsubkeys, nvalues;
DWORD maxValueSize;
DWORD maxValueNameLen;
FILETIME modified;
if (ERROR_SUCCESS != ::RegQueryInfoKey(hKey, nullptr, nullptr, nullptr,
&nsubkeys, nullptr, nullptr, &nvalues, &maxValueNameLen,
&maxValueSize, nullptr, &modified))
return;
printf("Subkeys: %u Values: %u\n", nsubkeys, nvalues);
if (dumpValues) {
DWORD type;
auto value = std::make_unique<BYTE[]>(maxValueSize);
auto name = std::make_unique<WCHAR[]>(maxValueNameLen + 1);
printf("values:\n");
for (DWORD i = 0; ; i++) {
DWORD cname = maxValueNameLen + 1;
DWORD size = maxValueSize;
auto error = ::RegEnumValue(hKey, i, name.get(), &cname, nullptr,
&type, value.get(), &size);
if (error == ERROR_NO_MORE_ITEMS)
break;
auto display = GetValueAsString(value.get(), min(64, size), type);
printf(" %-30ws %-12ws (%5u B) %ws\n", name.get(),
(PCWSTR)display.first, size, (PCWSTR)display.second);
}
}
//...
The GetValueAsString helper function returns a std::pair<CString, CString> with the type and
value as text for the most common types:

Chapter 17: The Registry
213
std::pair<CString, CString>
GetValueAsString(const BYTE* data, DWORD size, DWORD type) {
CString value, stype;
switch (type) {
case REG_DWORD:
stype = L"REG_DWORD";
value.Format(L"%u (0x%X)", *(DWORD*)data, *(DWORD*)data);
break;
case REG_QWORD:
stype = L"REG_QWORD";
value.Format(L"%llu (0x%llX)", *(DWORD64*)data, *(DWORD64*)data);
break;
case REG_SZ:
stype = L"REG_SZ";
value = (PCWSTR)data;
break;
case REG_EXPAND_SZ:
stype = L"REG_EXPAND_SZ";
value = (PCWSTR)data;
break;
case REG_BINARY:
stype = L"REG_BINARY";
for (DWORD i = 0; i < size; i++)
value.Format(L"%s%02X ", value, data[i]);
break;
default:
stype.Format(L"%u", type);
value = L"(Unsupported)";
break;
}
return { stype, value };
}
Here is a truncated output froma call to DumpKey with the key HKEY_CURRENT_USER\Control Panel
with all arguments set to true:

Chapter 17: The Registry
214
Subkeys: 15 Values: 1
values:
SettingsExtensionAppSnapshot
REG_BINARY
(
8 B) 00 00 00 00 00 00 00 00
Keys:
Accessibility
Modified: Tue Mar 10 12:47:14 2020
--------
Subkey: Accessibility
Subkeys: 13 Values: 4
values:
MessageDuration
REG_DWORD
(
4 B) 5 (0x5)
MinimumHitRadius
REG_DWORD
(
4 B) 0 (0x0)
Sound on Activation
REG_DWORD
(
4 B) 1 (0x1)
Warning Sounds
REG_DWORD
(
4 B) 1 (0x1)
Keys:
AudioDescription
Modified: Tue Mar 10 12:47:14 2020
--------
Subkey: AudioDescription
Subkeys: 0 Values: 2
values:
On
REG_SZ
(
4 B) 0
Locale
REG_SZ
(
4 B) 0
Keys:
Blind Access
Modified: Tue Mar 10 12:42:53 2020
--------
Subkey: Blind Access
Subkeys: 0 Values: 1
values:
On
REG_SZ
(
4 B) 0
Keys:
HighContrast
Modified: Tue Mar 10 12:47:14 2020
--------
Subkey: HighContrast
Subkeys: 0 Values: 3
values:
Flags
REG_SZ
(
8 B) 126
High Contrast Scheme
REG_SZ
(
2 B)
Previous High Contrast Scheme MUI Value REG_SZ
(
2 B)
Keys:
Keyboard Preference
Modified: Tue Mar 10 12:42:53 2020
--------
Subkey: Keyboard Preference
Subkeys: 0 Values: 1
values:

Chapter 17: The Registry
215
On
REG_SZ
(
4 B) 0
Keys:
Keyboard Response
Modified: Tue Mar 10 12:42:53 2020
--------
Subkey: Keyboard Response
Subkeys: 0 Values: 9
values:
AutoRepeatDelay
REG_SZ
(
10 B) 1000
AutoRepeatRate
REG_SZ
(
8 B) 500
BounceTime
REG_SZ
(
4 B) 0
DelayBeforeAcceptance
REG_SZ
(
10 B) 1000
Flags
REG_SZ
(
8 B) 126
Last BounceKey Setting
REG_DWORD
(
4 B) 0 (0x0)
Last Valid Delay
REG_DWORD
(
4 B) 0 (0x0)
Last Valid Repeat
REG_DWORD
(
4 B) 0 (0x0)
Last Valid Wait
REG_DWORD
(
4 B) 1000 (0x3E8)
Keys:
MouseKeys
Modified: Tue Mar 10 12:42:53 2020
Registry Notifications
Some applications need to know when certain changes happen in the Registry, and update their be-
havior by reading again certain values of interest. the Registry API provides the RegNotifyChangeKeyValue
for exactly this purpose:
LSTATUS RegNotifyChangeKeyValue(
_In_ HKEY hKey,
_In_ BOOL bWatchSubtree,
_In_ DWORD dwNotifyFilter,
_In_opt_ HANDLE hEvent,
_In_ BOOL fAsynchronous);
hKey is the root key to watch for. It can be obtained by a normal call to RegCreateKeyEx or
RegOpenKeyEx by specifying the REG_NOTIFY access mask, or one of the 5 main predefined keys can
be used. bWatchSubtree indicates wheteher the specified key is only one watched (‘FALSE’) or that
the entire tree of keys under hKey is watched for changes (TRUE).
The dwNotifyFilter indicates which operations should trigger a notification. Any combination of
the flags shown in table 17-4 is valid.

Chapter 17: The Registry
216
Table 17-4: Flags to RegNotifyChangeKeyValue
Flag
Description
REG_NOTIFY_CHANGE_NAME (1)
subkey is added or deleted
REG_NOTIFY_CHANGE_ATTRIBUTES (2)
changes to any attribute of a key
REG_NOTIFY_CHANGE_LAST_SET (4)
change in modification time, indicating key value added,
changed or deleted
REG_NOTIFY_CHANGE_SECURITY (8)
change in the security descriptor of a key
REG_NOTIFY_THREAD_AGNOSTIC (0x10000000)
(Win 8+) the notification registration is bot tied to the calling
thread (see text for more details)
The hEvent parameter is an opiotnla handle to an event kernel object, that becomes signaled
when a notification arrives. This is required if the last argument (fAsynchronous) is set to TRUE.
If fAsynchronous is FALSE, the call does not return until a change is detected. If fAsynchronous is
TRUE, the call returns immediately, and the event must be waited on to get notifications. The flag
REG_NOTIFY_THREAD_AGNOSTIC indicates the calling thread is not associated with the registration, so
that any thread can wait on the event handle. If this flag is not specified and the calling thread
terminates, the registration is cancelled.
Using RegNotifyChangeKeyValue is fairly easy. Its main difficiency is the fact it does not specify
exactly what change had occurred, and does not provide additional information as to the key
and/or value where the change occurred. This makes it suitable to simple cases where a single key
monitoring is needed (non-recursive), so when a change is detected, it’s not too expensive to examing
the changes in the key.
The RegWatch sample application shows how to use RegNotifyChangeKeyValue in synchronous
mode. The interesting part is shown here:
// root is one of the standard hive keys
// path is the subkey (can be NULL)
HKEY hKey;
auto error = ::RegOpenKeyEx(root, path, 0, KEY_NOTIFY, &hKey);
if (error != ERROR_SUCCESS) {
printf("Failed to open key (%u)\n", error);
return 1;
}
// watch for adding/modifying keys/values
DWORD notifyFlags = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET;
printf("Watching...\n");
while (ERROR_SUCCESS == ::RegNotifyChangeKeyValue(hKey, recurse, notifyFlags,
nullptr, FALSE)) {
// no further info

Chapter 17: The Registry
217
printf("Changed occurred.\n");
}
::RegCloseKey(hKey);
The alternative way to get more details on changes in the Registry is to use Event Tracing For
Windows (ETW). This is the same mechanism used in chapters 7 and 9 for detecting DLL loads.
The ETW kernel provider provides a list of Registry-related notifications that can be processed.
The RegWatch2 sample application uses ETW to shows Registry activity. There is no built-in filter
for getting notifications from certain keys, and it’s up to the consumer to filter notifications it does
not care about. The example shown does not filter anything, and shows the key name related to the
operation (if any).
The class TraceManager used in chapters 7 and 9 has been copied as is. The only change is in the
Start method (TraceManager.cpp) that changes the event flags to indicate Registry events (rather
than image events in the original code):
_properties->EnableFlags = EVENT_TRACE_FLAG_REGISTRY;
The EventParser class (EventParser.h/cpp) has copied as is (the only changes are addition of header
files because RegWatch2 does not use precompiled headers). Here is the main function:
TraceManager* g_pMgr;
HANDLE g_hEvent;
int main() {
TraceManager mgr;
if (!mgr.Start(OnEvent)) {
printf("Failed to start trace. Are you running elevated?\n");
return 1;
}
g_pMgr = &mgr;
g_hEvent = ::CreateEvent(nullptr, FALSE, FALSE, nullptr);
::SetConsoleCtrlHandler([](auto type) {
if (type == CTRL_C_EVENT) {
g_pMgr->Stop();
::SetEvent(g_hEvent);
return TRUE;
}
return FALSE;
}, TRUE);

Chapter 17: The Registry
218
::WaitForSingleObject(g_hEvent, INFINITE);
::CloseHandle(g_hEvent);
return 0;
}
The main function creates a TraceManager object and calls Start (remember using ETW in this
way requires admin rights). Stopping the session is done with a Ctrl+C key combination. The call to
SetConsoleCtrlHandler is used to be notified when such key combination is detected. Unfortunately,
the function pointer to SetConsoleCtrlHandler does not provide a way to pass a context arguent,
which is why the pointer to the TraceManager is also stored in a global variable.
In addition, an event object is created and held in a global variable to indicate Stop has been called,
so that the wait is satisfied and the program can exit.
Each notification is sent to the OnEvent function, passed in the call to TraceManager::Start. Here
is OnEvent:
void OnEvent(PEVENT_RECORD rec) {
EventParser parser(rec);
auto ts = parser.GetEventHeader().TimeStamp.QuadPart;
printf("Time: %ws PID: %u: ",
(PCWSTR)CTime(*(FILETIME*)&ts).Format(L"%c"),
parser.GetProcessId());
switch (parser.GetEventHeader().EventDescriptor.Opcode) {
case EVENT_TRACE_TYPE_REGCREATE:
printf("Create key"); break;
case EVENT_TRACE_TYPE_REGOPEN:
printf("Open key"); break;
case EVENT_TRACE_TYPE_REGDELETE:
printf("Delete key"); break;
case EVENT_TRACE_TYPE_REGQUERY:
printf("Query key"); break;
case EVENT_TRACE_TYPE_REGSETVALUE:
printf("Set value"); break;
case EVENT_TRACE_TYPE_REGDELETEVALUE:
printf("Delete value"); break;
case EVENT_TRACE_TYPE_REGQUERYVALUE:
printf("Query value"); break;
case EVENT_TRACE_TYPE_REGENUMERATEKEY:
printf("Enum key"); break;
case EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY:
printf("Enum values"); break;
case EVENT_TRACE_TYPE_REGSETINFORMATION:
printf("Set key info"); break;
case EVENT_TRACE_TYPE_REGCLOSE:
printf("Close key"); break;
default:
printf("(Other)"); break;
}
auto prop = parser.GetProperty(L"KeyName");
if (prop) {

Chapter 17: The Registry
219
printf(" %ws", prop->GetUnicodeString());
}
printf("\n");
}
Only some of the possible notifications is specifically captured, all others are displayed as “(other)”.
if a key name property exists, it’s displayed as well. If you run the application, you’ll appreciate the
sheer number of Registry operations that occur at any given time.
There are other pieces of information for each event. Call EventParser::GetProperties() to get all
the custom properties for an event record.
Both of the notification options we’ve seen do not allow any interception of changes. Such a powerful
capability is only available when using kernel APIs. My book “Windows Kernel Programming”
shows how to achieve this.
Transactional Registry
In chapter 9 (part 1), we’ve seen that file operations can be part of a transaction by using functions
such as CreateFileTransacted, associating it with an open transaction. Such a transaction can be
created with CreateTrransaction (refer to chapter 9 for the details). Registry operations can be
transacted as well, operating as an atomic set of operations, which may also be combined with file
transacted operations.
Performing Registry operations as part of a transaction must be done by using a key created with
RegCreateKeyTransacted or opened with RegOpenKeyTransacted:
LSTATUS RegCreateKeyTransacted (
_In_ HKEY hKey,
_In_ LPCTSTR lpSubKey,
_Reserved_ DWORD Reserved,
_In_opt_ LPTSTR lpClass,
_In_ DWORD dwOptions,
_In_ REGSAM samDesired,
_In_opt_ CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
_Out_ PHKEY phkResult,
_Out_opt_ LPDWORD lpdwDisposition,
_In_
HANDLE hTransaction,
_Reserved_ PVOID
pExtendedParemeter);
LSTATUS RegOpenKeyTransacted (

Chapter 17: The Registry
220
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey,
_In_opt_ DWORD ulOptions,
_In_ REGSAM samDesired,
_Out_ PHKEY phkResult,
_In_
HANDLE hTransaction,
_Reserved_ PVOID
pExtendedParemeter);
These extended functions have the same parameters as the non-transactional versions, except the
last two parameters that indicate the transaction to work against (hTransaction). All subsequent
operations using the returned hKey are part of the transaction, and will all eventally succeed, or all
will fail as one atomic unit.
See the discussion on transactions in chapter 9.
Remote Registry
A Registry key can be opened or created on a remote machine by first calling RegConnectRegistry
to conect to the Registry on another machine. To make it work, the Remote Registry service must
be running on the remote computer. By default, this service is configured to start manually, so it’s
unlikely to be running. There are other security restrictions when connecting to a remote Registry
even if the service is running. Check the documentation for details. Here is RegConnectRegistry:
LSTATUS RegConnectRegistry (
_In_opt_ LPCTSTR lpMachineName,
_In_ HKEY hKey,
_Out_ PHKEY phkResult);
lpMachineName is the machine to connect to, which must have the format \\computername. hKey
must one of the following predefined keys: HKEY_USERS, HKEY_LOCAL_MACHINE or HKEY_PERFORMANCE_-
DATA. The last parameter (phkResult) is the returned handle to use locally.
Given the new handle, normal Registry operations can be performed, including reading values,
opening subkeys, writing values, etc., all subject to security checks. Once finished, the handle should
be closed normally with RegCloseKey.
An extended version of RegConnectRegistry exists as well, RegConnectRegistryEx:

Chapter 17: The Registry
221
LSTATUS RegConnectRegistryEx (
_In_opt_ LPCTSTR lpMachineName,
_In_ HKEY hKey,
_In_ ULONG Flags,
_Out_ PHKEY phkResult);
It’s identical to RegConnectRegistry, but allows specifying some flags. The only currently supported
flag is REG_SECURE_CONNECTION (1), which indicates the caller wants to establish a secure connection
to the remote Registry. This causes the RPC calls sent to the remote computer to be encrypted.
Miscellaneous Registry Functions
The Registry API includes other miscellaneous functions, some of which are described briefly in this
section.
The RegGetKeySecurity and RegSetKeySecurity functions allow retrieving and manipulating the
security descriptor of a given key. Although the more generic function GetSecurityInfo and
SetSecurityInfo functions (described in chapter 16) can be used with registry keys, the specific
ones are easier to use.
LSTATUS RegGetKeySecurity(
_In_ HKEY hKey,
_In_
SECURITY_INFORMATION SecurityInformation,
_Out_
PSECURITY_DESCRIPTOR pSecurityDescriptor,
_Inout_ LPDWORD lpcbSecurityDescriptor);
LSTATUS RegSetKeySecurity(
_In_ HKEY hKey,
_In_ SECURITY_INFORMATION SecurityInformation,
_In_ PSECURITY_DESCRIPTOR pSecurityDescriptor);
A Registry key (and all its values and subkeys) can be saved to a file by calling RegSaveKey:
LSTATUS RegSaveKey (
_In_ HKEY hKey,
_In_ LPCTSTR lpFile,
_In_opt_ CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes);
These functions save all the information for hKey and its descendants to a file given by lpFile.
hKey can be a key opened with the standard functions or one of the following predefined keys only:
HKEY_CLASSES_ROOT or HKEY_CURRENT_USER. lpFile must not exist before the call, othrewise the call
fails. The optional provided security attributes can provide the security descriptor on the new file;
if NULL, a default security descriptor is used, typically inherited from the file’s parent folder.

Chapter 17: The Registry
222
The format the data is saved in is called “standard format”, supported since Windows 2000. This
format is propriatary and genrally undocumented. Specifically, this is not the .REG file format used
by RegEdit.exe when the Export menu item is selected to back up a Registry key. The REG file format
is specific to RegEdit and is not generally known to the Registry functions.
The current (latest) format for saving keys is available by calling the extended function RegSaveKeyEx:
LSTATUS RegSaveKeyEx(
_In_ HKEY hKey,
_In_ LPCTSTR lpFile,
_In_opt_ CONST LPSECURITY_ATTRIBUTES lpSecurityAttributes,
_In_ DWORD Flags);
The function adds a Flags parameter, that must be one (and only one) of the following values:
• REG_STANDARD_FORMAT (1) - the original format, the same one used by RegSaveKey.
• REG_LATEST_FORMAT (2) - the latest (better) format.
• REG_NO_COMPRESSION (4) - saves the data uncompressed (as is). Only works on true hives
(marked with a special icon in RegEditX). The full hive list can be viewed within the Registry
itself, at HKLM\System\CurrentControlSet\Control\hivelist.
One downside of RegSaveKeyEx, is that the predefined key HKEY_CLASSES_ROOT is not supported.
Both RegSaveKey and RegSaveKeyEx requires the caller to have the SeBackupPrivilege in its token.
This privilege is normally given to members of the admnisitrators group, but not to users with
standard user rights.
With a saved file in hand, the information can be restored into the Registry with RegRestoreKey:
LSTATUS RegRestoreKey(
_In_ HKEY hKey,
_In_ LPCTSTR lpFile,
_In_ DWORD dwFlags);
hKey specifies the key to restore information to. It can be any open key or one of the standard 5 hive
keys. lpFile is the file where the data is stored. The restore operation preserves the name of root
key identified by hKey, but replaces all other attributes of that key, and replaces all subkeys/values,
as stored in the file.
dwFlags provides sevral options, from which only two are officially documented:

Chapter 17: The Registry
223
• REG_FORCE_RESTORE (8) - forces the restore operation even if there are open key handles to
subkeys that will be overwritten.
• REG_WHOLE_HIVE_VOLATILE (1) - creates a new hive in memory only. In this case, hKey must be
HKEY_USERS or HKEY_LOCAL_MACHINE. The hive is removed in the next system boot.
Similarly to RegSaveKey(Ex), the caller must have the SeRestorePrivilege in its token, normally given
to administrators.
An alternative to loading a hive with RegRestoreKey is to use RegLoadAppKey:
LSTATUS RegLoadAppKey(
_In_ LPCTSTR lpFile,
_Out_ PHKEY phkResult,
_In_ REGSAM samDesired,
_In_ DWORD dwOptions,
_Reserved_ DWORD Reserved);
RegLoadAppkey loads the hive specified by lpFile into an invisible root that cannot be enumerated,
and so is not a part of the standard Registry. The only way to access anything in the hive is through
the root phkResult key returned on success. The advantage over RegRestoreKey is that the caller
does not need the SeRestorePrivilege and so can be used by non-admin callers.
The only flag available in dwOptions (REG_PROCESS_APPKEY), if used, prevents other callers from
loading the same hive file while the key handle is open.
A Somewhat similar operation to RegRestoreKey with REG_WHOLE_HIVE_VOLATILE is available with
RegLoadKey, where a hive can be loaded from a file and stored as a new hive under either HKEY_-
LOCAL_MACHINE or HKEY_USERS. This is useful when looking at a Registry file offline, such as
a file brought from another system. RegEdit provides this funcionality by calling RegLoadKey in its
menu option File / Load Hive…. You’ll notice this option is only available when the selected key in
the tree view is either HKEY_LOCAL_MACHINE or HKEY_USERS (figure 17-6).

Chapter 17: The Registry
224
Figure 17-6: Load Hive option in RegEdit
Here is RegLoadKey’s definition:
LSTATUS RegLoadKey(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey,
_In_ LPCTSTR lpFile);
hKey can be HKEY_LOCAL_MACHINE or HKEY_USERS (because these are true keys rather than
various links). lpSubKey is the name of the subkey under which the hive is loaded from the file
specified by lpFile. Any changes made to the loaded key (or any of its subkeys) is persisted
eventually in the file.
Unloading the hive can be done with RegUnloadKey:
LSTATUS RegUnLoadKey(
_In_ HKEY hKey,
_In_opt_ LPCTSTR lpSubKey);
The parameters mirror their counterparts in RegLoadKey.
Summary
The Registry is the primary database the Windows system uses, for system-wide and user-specific
settings. Some parts of the Registry are especially important in the context of system security, kernel
operation, and much more. In this chapter, we looked at the Registry’s concepts and layout and the
most common API functions to read and otherwise manipulate it.

