
Wireless Web 
Development, 
Second Edition 
RAY RISCHPATER 
APress Media, LLC 

Wireless Web Development, Second Edition 
Copyright ©2002 by Ray Rischpater 
Originally published by Apress in 2002 
All rights reserved. No part of this work may be reproduced or transmitted in any form or by any 
means, electronic or mechanical, including photocopying, recording, or by any information 
storage or retrieval system, without the prior written permission of the copyright owner and the 
publisher. 
ISBN 978-1-59059-028-7 
ISBN 978-1-4302-1103-7 (eBook) 
DOI 10.1007/978-1-4302-1103-7 
Trademarked names may appear in this book. Rather than use a trademark symbol with every 
occurrence of a trademarked name, we use the names only in an editorial fashion and to the 
benefit of the trademark owner, with no intention of infringement of the trademark. 
Technical Reviewer: Charles Stearns 
Editorial Directors: Dan Appleman, Peter Blackburn, Gary Cornell, Jason Gilmore, Simon Hayes, 
Karen Watterson, John Zukowski 
Managing Editor: Grace Wong 
Project Manager: Sofia Marchant 
Copy Editor: Kim Wrmpsett 
Compositor: Impressions Book and Journal Services 
Indexer: Rebecca Plunkett 
Cover Designer: Kurt Krames 
Manufacturing Manager: Tom Debolski 
Marketing Manager: Stephanie Rodriguez 
The information in this book is distributed on an "as is" basis, without warranty. Although every 
precaution has been taken in the preparation of this work, neither the author nor Apress shall 
have any liability to any person or entity with respect to any loss or damage caused or alleged to 
be caused directly or indirectly by the information contained in this work. 

This book is dedicated to the memory of Meredith C. White and Raymond W. White, 
who could only imagine the possibilities of a world with the wireless Web, and to 
the future of Jarod Raymond Risch pater, who can only imagine the world without 
the wireless Web. 

Contents at a Glance 
Acknowledgments ................................................... . xiii 
About the Author .................................................. . xiv 
About the Technical Reviewer ..................................... . xv 
Introduction ....................................................... . xvi 
Chapter 1 A Wireless Data Primer ................................. . 1 
Chapter 2 The Wireless Landscape ................................. . 11 
Chapter 3 The Wireless User Interface ........................... . 35 
Chapter 4 The Wireless World Wide Web .......................... .49 
Chapter 5 Server-Side Content Management ....................... . 67 
Chapter 6 Server-Side Content-Management Scripting ........... . 91 
Chapter 7 eXtensible Markup Language .......................... . 117 
Chapter 8 HyperText Markup Language the Wireless Way ........ 135 
Chapter 9 Palm Powered Web Clipping Applications ............ . 169 
Chapter 10 i-mode Applications ................................. . 181 
Chapter 11 Wireless Application Protocol ...................... . 191 
Chapter 12 Wireless Markup Language ........................... . 203 
Chapter 13 Dynamic Content with WMLScript .................... . 247 
Chapter 14 Content Deli very ..................................... . 279 
Chapter 15 Custom Applications: When a Browser Won't Work 
.. 303 
Appendix A Resources for Wireless Web Developers ............. . 319 
v 

Appendix B Unified Modeling language for Web Developers .... . 325 
Appendix C Handheld Device Markup language ................... . 335 
Index ............................................................... . 367 

Contents 
Acknowledgments ................................................... . xiii 
About the Author .................................................. . xiv 
About the Technical Reviewer ..................................... . xv 
Introduction ....................................................... . xvi 
Chapter 1 A Wireless Data Primer ........................ . 1 
A Bit of Wireless Data History .................................... . 1 
A Bit of Technical Talk ............................................ . 3 
Putting It All Together: How a Cellular System Works ........... 7 
Summary .................. ~ ............................................. 9 
Chapter 2 The Wireless Landscape ...................... .. 11 
An Explosive Growth Industry .................................... .. 11 
Uses of the Wireless Web .......................................... . 12 
The Opportunities for Wireless Development .................... . 12 
The Fundamentals of Wireless Development ....................... . 14 
The Computing Capacity Gap: Handheld versus Desktop ........... 17 
Exploring Markup Options .......................................... . 19 
Exploring Hardware Options ....................................... . 25 
What Makes the Wireless Market Unique? ........................ .. 28 
Summary .............................................................. . 34 
Chapter 3 The Wireless User Interface ................ . 35 
Meeting User Expectations ........................................ . 35 
Designing the User Interface .................................... .. 37 
Creating User-Friendly Content .................................. .. 39 
Summary .............................................................. . 48 
vii 

Contents 
Chapter 4 The Wireless World Wide Web ................ .49 
Reviewing Web Standards ........................................... .49 
Getting Presentation Tips ........................................ . 59 
Summary .............................................................. . 65 
Chapter 5 Server-Side Content Management ............. 67 
What Is Server-Side Scripting? .................................. . 67 
Using Server-Side Scripting in Mobile Applications ............. 69 
Managing Server-Side Content with Apache ....................... . 72 
Using a Transcoding Server ....................................... . 86 
Using XML for Content Management ................................ . 88 
Summary .............................................................. . 90 
Chapter 6 Server-Side 
Content-Management Scripting .............................. . 91 
Creating PHP-Powered Wireless Web Sites ........................ . 91 
Summary ............................................................. . 114 
Chapter 7 eXtensible Markup Language ................ . 117 
An XML Primer ...................................................... . 117 
Sharing Your XML Creation ........................................ . 121 
Summary ............................................................. . 133 
Chapter 8 HyperText Markup Language 
the Wireless Way ............................................. . 135 
Picking a Version of HTML ....................................... . 135 
Marking Up the Document Heading ................................ . 136 
Marking Up the Document Body .................................... . 141 
Creating a Form ................................................... . 160 
Using Other HTML Tags ............................................. . 165 
Summary ............................................................. . 166 
viii 

Contents 
Chapter 9 Palm Powered Web 
Clipping Applications ...................................... . 169 
Introducing the Web Clipping Application Architecture ....... 169 
learning WCA Fundamentals ....................................... . 171 
Creating a Sample WCA ............................................ . 177 
Summary ............................................................. . 180 
Chapter 10 i-mode Applications ........................ .. 181 
looking at the i-mode Architecture ............................ .. 181 
Creating Content for i-mode ..................................... . 183 
Summary ............................................................. . 189 
Chapter 11 Wireless Application Protocol .......... . 191 
Introducing the WAP Standard .................................... . 191 
Using Tools for XHTMl Mobile Profile .......................... . 194 
Understanding XHTMl Mobile Profile ............................ .. 194 
Summary ............................................................. . 202 
Chapter 12 Wireless Markup Language ................... . 203 
Why Use WMl? ....................................................... . 203 
Designing WMl User Interfaces ................................... . 205 
Creating Your First WAP Application .......................... .. 208 
Viewing WMl Content .............................................. . 209 
learning WMl Syntax .............................................. . 210 
Marking Up Documents with WMl .................................. .. 213 
Summary ............................................................. . 246 
Chapter 13 Dynamic Content with WMLScript ......... . 247 
Purposes of WMlScript ............................................ . 247 
Exploring the Features of WMlScript .......................... .. 248 
Creating a Simple WMlScript Application ....................... . 249 
looking More Closely at WMlScript .............................. . 254 
ix 

Contents 
Debugging Hints ................................................... . 274 
Summary ............................................................. . 277 
Chapter 14 Content Delivery ............................ .. 279 
Pushing Web Content .............................................. . 279 
Pushing with WAP .................................................. . 282 
Synchronizing Web Content ....................................... . 289 
Developing for AvantGo ........................................... . 291 
Summary ............................................................. . 300 
Chapter 15 Custom Applications: 
When a Browser Won 't Work ............................... .. 303 
Deciding to Roll Your Own ....................................... .. 303 
Picking a Platform ................................................ . 309 
Summary ............................................................. . 317 
Appendix A Resources for Wireless 
Web Developers ................................................ . 319 
WAP Sped fications ................................................ . 319 
Client-Side Tools ................................................. . 319 
Server-Side Tools ................................................ .. 322 
Mobile Software Development ..................................... . 323 
Appendix B Unified Modeling Language 
for Web Developers .......................................... . 325 
UML for Wireless Web Developers ............................... .. 326 
Further Reading .................................................... . 333 
X 

Contents 
Appendix C Handheld Device Markup Language ........ . 335 
Introducing HDML .................................................. . 335 
HDML or WML? ....................................................... . 337 
Creating Your First HDML Page .................................. .. 337 
Using Browsers, Tools, and SDKs 
................................ . 338 
Understanding HDML for Web Developers .......................... . 339 
Designing an HDML User Interface .............................. .. 362 
Summary ............................................................. . 365 
Index .................................................. · ........... . 367 
xi 

Acknowledgments 
I AM INDEBTED TO THE STAFF at Apress for their contributions throughout this book. 
Specifically, Kim W1mpsett tackled this project with enthusiasm, support, under-
standing, and clear feedback. And, as with my previous books with Apress, folks 
such as Jason Gilmore, Sofia Marchant, Grace Wong, and Gary Cornell deserve 
my sincere thanks as well. This is especially true of Sofia Marchant, who waited 
with infinite patience as I repeatedly added and cut material from the manu-
script, moving things willy-nilly and destroying any sense of a schedule. 
My technical editor, Charles Stearns, gave innumerable helpful suggestions 
during the development of the examples in this book. I should note, of course, 
that despite Charles's efforts (and those of my editors), the responsibility for any 
remaining errors in this book falls squarely on my shoulders. 
My friends and colleagues at Rocket Mobile, Inc., exercised great restraint on 
the days I came in babbling about this part of the book or that part of the sched-
ule, and they gave me many helpful comments on segments of the manuscript 
and the ideas within. 
Finally, this book would not have been possible without the abundant love, 
support, and devotion of my family. My wife, Rachel, supported this project from 
its infancy, while my son, Jarod, supported it in his infancy. Now almost three, his 
questions about "our book'' and "Daddy's project" prompted me to write as fast 
as I could, both so he could see the results and so I could close the computer and 
get back to him. Rachel's love and enthusiasm for the project buoyed me on the 
days when I found writing difficult or impossible, and I owe her a world of grati-
tude for her gift of the freedom to write and to raise Jarod. 
xiii 

xiv 
About the Author 
RAv RiscHPATER is a software engineer and writer who has focused on mobile com-
puting since 1995. During that time, he has developed qmntless applications for 
Fortune 500 companies using handheld computers and wireless interfaces for 
enterprise and commercial deployment. He is the author of six books and forty-
seven articles on mobile and wireless computing. 
Projects to which he has contributed include 
• NetHopper, one of the first handheld Web browsers 
• EmbeddedWeb, the first Web browser for handhelds 
• The Atlanta Olympics Traveler's Info system, providing real-time wireless 
access to navigation and traffic data 
Publications of his include 
• Wireless Web Development, byRayRischpater (Apress, ISBN 1-893115-20-8, 
5/2000) 
• Wireless Web Development with PHP and WAP, by Ray Risch pater (Apress, 
ISBN 1-893115-93-3, 5/2001) 
• Advanced Palm Programming: Developing Real-World Applications, by 
Steve Mann and Ray Rischpater (John WJ.ley & Sons, ISBN 0-471-39089-
7,10/2000) 
• Palm Enterprise Applications: A Wiley Tech Brief, by Ray Rischpater (John 
Wiley & Sons, ISBN 0-471-39379-7, 10/2000) 
• Internet Appliances: A Wiley Tech Brief, by Ray Rischpater (John WJ.ley & 
Sons, ISBN 0-471-44111-2, 9/2001) 
Ray Risch pater is a member of the IEEE and is presently employed as a staff 
engineer at Rocket Mobile, Inc. He lives in the Santa Cruz mountains with his 
wife Rachel and his son Jarod. 

About The Technical 
Reviewer 
CHARLES STEARNs has been developing mobile computing software for over five 
years, getting his start on the Apple Newton. As a software engineer he has 
worked on numerous custom mobile applications, including Web browsers and 
server solutions. Most recently, he has been working in the area of device syn-
chronization. He has written programming articles and lent a technical eye to 
other publications by Ray Risch pater. Charles is currently a self employed soft-
ware consultant in Portland OR. 
XV 

xvi 
Introduction 
THE WIRELEss WEB is here to stay. More than a billion people now use wireless 
devices, up from a paltry 200 million devices when I wrote the first edition of 
Wireless Web Development (Apress, 2000) a mere three years ago. The World Wide 
Web, and more recently the wireless World Wide Web, has made the dream of 
handheld devices for information access a reality. 
Wireless providers have activated the third-generation cellular systems to 
bring voice and high-speed data services to subscribers around the world. Data 
transfer rates for mobile handsets are often better than that of a conventional 
dialup modem, and in the future with fourth- and fifth-generation systems, wire-
less networks rival today's Digital Subscriber Loop (DSL) data rates. It's time to 
stop and ask yourself: What are you doing on the wireless Web, and what can it do 
for you? 
Who Needs to Read This Book 
If you're interested in developing a Web site for use with wireless devices in 
a mobile environment, then this book is definitely for you. If you're a software 
developer, Webmaster, or intranet administrator, you can use the techniques and 
tools described in this book to deliver information to your customers, wherever 
they maybe. 
This book not only details the use of traditional Web technologies for the 
wireless market, but it gives you all the knowledge you need to create for emerg-
ing environments including Wireless Application Protocol (WAP) 2.0 with 
XHTML-MP and Compact HTML (the markup language behind i-mode, the 
world's most popular wireless data service). 
I've assumed you have some familiarity with traditional Web development, 
including knowledge in areas such as the following: 
• Client-server interaction: Understanding how a Web browser and a server 
interact will help you understand how technologies such as the WAP can 
be used with an existing Web server to reach new customers. 
• HyperText Markup Language (IITML): Familiarity with HTML is a good 
idea if you're going to be developing pages for wireless Web browsers. 
• Common Gateway Interface (CGI):As you'll soon find out, Web sites for 
wireless access are even more likely to be dynamic than their traditional kin. 
CGis are an important tool for bringing your information to your viewers. 

If, like me, you wondered as a kid how they fed the guy in the radio or you 
visualized electrons rolling around inside your computer like little peas, never 
fear. The foundation of this book lies in understanding the development ofWeb 
content, not comprehending the mysteries of radio transmissions or how mobile 
devices actually work. 
Moreover, I assume you're relatively new to the subject of wireless Web devel-
opment. Throughout this book, as you learn how to construct Web sites for 
wireless users, you'll gain important insights into the differences between wire-
less and traditional Web content development. 
A word of warning: If your intended platforms are high-speed, local-area 
wireless networks such as the incredibly successful WIFi (802.11 b) standard, this 
book may not apply to you. WiFi coupled with traditional computers in the guise 
oflaptops need little special attention from Web developers. But, if you're work-
ing with wireless local-area networks and significantly more constrained devices 
(say, a Microsoft Windows Powered device or Palm Powered platform device), 
then this book is for you. 
What You Will Find in This Book 
This book, like the previous edition, intersperses comments and ruminations 
about the nature of developing for wireless clients with examples using the latest 
technologies for the World Wide Web. It's written to be both a sourcebook of gen-
eral ideas you can call upon when developing your site and a cookbook of 
techniques and tricks for making the most of wireless presentation. 
Chapter 1, "A Wrreless Data Primer," provides an introduction for those new 
to wireless data and mobile devices. 
Chapter 2, "The Wireless Landscape," introduces the wireless industry, 
including some of its key features and pitfalls. 
Chapter 3, "The Wireless User Interface," discusses how to produce wireless 
World Wide Web content for your subscribers. 
Chapter 4, "The Wrreless World Wide Web," reviews the protocols and stan-
dards behind the wireless World Wide Web. 
Chapter 5, "Server-Side Content Management," offers server-side techniques 
for enabling wireless devices, including applications of Apache's server-parsed 
directives and PHP: Hypertext Processor. 
Chapter 6, "Server-Side Content-Management Scripting," provides a 
brief introduction to server-side scripting using the popular open-source 
language PHP. 
Chapter 7, "eXtensible Markup Language," gives you a succinct overview of 
XML and how you can use it when working with other wireless markup lan-
guages. Understanding XML is key in being able to use many newer markup 
Introduction 
xvii 

Introduction 
xvili 
languages, such as those defined by the WAP Forum, and critical for content 
developers to understand when working with engineers. 
Chapter 8, "HyperText Markup Language, the Wrreless Way," examines the 
use of HTML in wireless Web content and shows you a subset of HTML appropri-
ate for marking up wireless content. 
Chapter 9, "Palm-Powered Web Clipping Applications," describes Palm, Inc.'s 
novel and strikingly successful approach to bringing conventional Web content 
to its handheld devices, including the Palm Powered i705-connected organizer. 
Chapter 10, "i-modeApplications," discusses i-mode as developed by NIT 
DoCoMo. As I write this, i-mode is arguably the most successful wireless Web ser-
vice, available throughout Japan. 
Chapter 11, "Wireless Application Protocol," discusses the work done to date 
by the WAP Forum, an industry association of hardware and software manufac-
turers working to provide wireless Web standards, includingWAP 2.0's support for 
XHTML Mobile Profile. 
Chapter 12, "Wrreless Markup Language," takes a step back from WAP and 
looks at Wireless Markup Language (WML). Widely deployed throughout the 
United States, WML remains a powerful choice for those developers seeking to 
tap the market of deployed handsets. 
Chapter 13, "Dynamic Content with WMLScript," shows you how you can 
add dynamic behavior to your WAP content usingWMLScript, a lightweight 
scripting language for screen phones. 
Chapter 14, "Content Delivery," discusses content delivery for today's mobile 
devices. Although most wireless Web applications follow the traditional client-
server paradigm in which you request information from a remote position, the 
wireless Web supports other paradigms as well. Notably, I discuss synchronizing, 
bringing Web content to the handheld using browsers such as AvantGo, and 
pushing, where a content server sends content to your handset on your behalf. 
Chapter 15, "Custom Applications: When a Browser Won't Work," discusses 
when and why you would choose to write a custom application using the wireless 
protocols instead of tailoring content for a browser. 
AppendixA, "Resources forWrrelessWeb Developers," provides you with 
a list of resources including browsers for testing and software development kits 
for developing wireless Web content. 
Appendix B, "Unified Modeling Language for Web Developers," reviews the 
Unified Modeling Language (UML) for those readers new to using it. 
Appendix C, "Handheld Device Markup Language," compares WAP with 
Handheld Device Markup Language (HDML), the predecessor to WAP. Originally 
designed for screen phones, HDML remains a powerful alternative to WAP for 
some applications. 

How You Can Use this Book 
If you're new to the wireless frontier, you should plan on starting with the first 
two chapters of this book. (Of course, you're free to dip into this book wherever 
you want and skip through it as you please.) Chapter 1 provides a brief history of 
wireless data and wireless technologies as they pertain to the wireless Web, and 
Chapter 2looks at the exciting opportunities for wireless development. You're 
free to read either, both, or neither of these depending on your interests. Those 
with a technical streak will enjoy Chapter 1; those with an interest in marketing 
and business may find Chapter 2 a better place to start. 
You should definitely read Chapter 3, as in it I introduce many of the con-
straints on wireless Web content. You'll face these constraints when developing 
your content, and I refer back to them throughout my discussion of the markup 
languages that follows. 
With an understanding of the capabilities of the wireless Web in hand, you're 
free to roam through any of the remaining chapters. Readers interested in tradi-
tional Web technologies applied to wireless markets will want to focus on 
Chapters 4, 8, 9, and 10. Readers developing for the wireless phone market will 
want to read Chapters 10, 11, 12, and 13, which discuss the technologies available 
for these platforms. 
Of course, if you've already spent time working with wireless content or 
mobile devices, you may want to flip right to any chapter that interests you and 
dive in. Go right ahead! 
A Word on Presentation 
As with other technical books, it helps to make a distinction between what's 
meant for people to read and what's meant for computers to read. 
Any text in this book that looks like this is either a tag in one of the Web 
markup languages or a variable or statement in some computer language being 
discussed. Whole listings of code or markup languages are set in the same style: 
<HTML> 
<TITLE>He11o wor1d!</TITLE> 
<BODY><P>He11o wor1d!</P></BODY> 
</HTML> 
It is widely held that a picture is worth a thousand words. I've tried to use 
illustrations throughout for two purposes: to show you the results of marking up 
content using one of the wireless Web markup languages (HTML, HDML, or 
WML) or to describe the behavior of a system in some way. To represent a sys-
tem's operation, I use UML, which provides a powerful way to represent different 
Introduction 
xix 

Introduction 
XX 
aspects of systems in a compact notation that's clear and intuitive. If you're new 
to UML, you may want to read Appendix B for an introduction. 
Getting the Latest Resources 
Throughout the book, I'll be using developer tools and resources for HTML, WAP, 
and HDML authors. For the latest information regarding developer resources and 
where you can find them, see Appendix A. 
Looking Ahead 
The development of the wireless Web is in full swing. This is the time for new 
players and new ideas. I'm pleased to be sharing how to develop for the wireless 
Web with you and look forward to seeing the content and solutions you develop. 

CHAPTER 1 
A Wireless Data Primer 
UNDERSTANDING THE WIRELESs MARKETPLACE will help you develop better wireless con-
tent. Over the past 10 years there has been a dizzying array of technologies, 
services, and companies, all of which have contributed to today's wireless land-
scape. Unlike traditional computing, where a year-old technology can be pitifully 
obsolete, wireless technology persists for many years after its development 
because of its high installation cost and relatively low hardware turnover. The 
technologies behind many of today's wireless networks were developed as long as 
10 years ago. Knowledge of these networks reveals some of the strengths and 
weaknesses of the wireless Web. 
In this chapter, I walk you through a brief history of the wireless data indus-
try and then review some of the technologies behind today's wireless networks. 
(Those readers eager to get to the market opportunities can skip this chapter and 
move along to Chapter 2, "TheWrreless Landscape"; if you're ready to start devel-
oping, skip ahead to Chapter 3, "The Wrreless User Interface." Either way, you can 
refer to this chapter when you're curious about a particular technology or term.) 
As many of today's wireless data communications are coupled with voice ser-
vices, I present the development of wireless data through the deployment of 
voice networks. Understanding a wireless voice network will help you under-
stand a wireless data network as well. 
A Bit of Wireless Data History 
The history of today's wireless data is closely tied to that of wireless telephony. By 
the early 1940s, several thousand police cars equipped with two-way mobile 
radios had established the importance of wireless communications. Utilizing 
point -to-point communications from a central location, those early systems 
became an essential part of police communications. In 1946, the first public 
mobile telephone systems were introduced in 25 U.S. cities, providing businesses 
and wealthy individuals with the ability to make calls to destinations 30 miles or 
more away, while the users were in transit. 
Coverage over a metropolitan area was provided by a central service that 
encompassed numerous mobile radios using preassigned channels, which greatly 
limited the number of potential subscribers. Moreover, these mobile systems typi-
cally were not connected to the public telephone system. These early mobile 
networks expanded slowly because of frequency limitations and technological 
1 

Chapter 1 
2 
shortcomings. During the 1950s and 1960s, telephone companies around the 
world worked to address these limitations by developing the theories behind cel-
lular radio technology. 
The First Cellular Systems 
When AT&T proposed a cellular telephone network to the Federal Com-
munications Commission (FCC) in the late 1960s, the principles of cellular com-
munication were known, but the technology to implement them would not be 
available until more than a decade later. 
The Japanese firm Nippon Telegraph and Telephone Company deployed the 
first cellular system in 1979. It was followed in 1981 by the deployment of a cellu-
lar system that covered much of Europe. In 1983, the FCC finally allocated 
enough radio spectrum-that is, individual frequencies-to support the first 
domestic cellular telephone network. This network, called the Advanced Mobile 
Phone System (AMPS), remains in place today, providing what is typically called 
analog cellular service by wireless providers. 
Industry Partnerships 
The past 20 years have brought a series of revolutionary movements in both wire-
less telephony and wireless data. In the 1980s, IBM and Motorola joined forces to 
form ARDIS, a separate entity responsible for providing wireless data to mobile 
workers. Originally targeted at providing wireless messaging for IBM and 
Motorola field service technicians, the ARDIS network was rapidly adopted by 
outside clients such as Otis Elevator. This network is still operating today, under 
the auspices of Motient. 
In 1986, Ericsson developed Mobitex, the foundation of the RAM Mobile 
Data network. This network was initially established in Europe and the United 
States to provide wireless data to vertical markets (applications for a specific 
business) such as field technicians and service engineers. BellSouth acquired 
RAM Mobile Data Limited in June 1998 and deployed 13 networks worldwide 
based on the Mobitex standard; more recently, CingularWrreless took control of 
the domestic Mobitex network. This network provides the backbone for the first-
generation Palm.Net service, used by the successful Palm m705- and Palm 
Vllx-connected organizers. 
The ARDIS and RAM networks provide users in the United States with dedi-
cated data networks, and the RAM network provides service in the United 
Kingdom, Australia, the Netherlands, Belgium, Singapore, and other countries. 
Although the designers of these networks originally saw their primary appli-
cation as two-way paging, today these networks provide both valuable legacy 

A Wireless Data Primer 
service to vertical markets and wireless email and Web access to handheld 
devices including Palm Powered organizers and Research In Motion's BlackBerry 
products. 
Recent Advances 
In the early 1990s, advancements in cellular voice technology allowed the use of 
existing cellular networks for data transmission by employing Cellular Digital 
Packet Data (CDPD). (Prior to this, analog cellular could only carry digital data as 
part of an analog phone call, with high cost and drastically reduced perfor-
mance.) CDPD works with existing first- and second-generation AMPS cellular 
systems, allowing simple and inexpensive installation in areas already covered by 
AMPS. More recently, the advent of digital cellular networks, including Global 
Service for Mobile (GSM) in Europe and North America along with the various 
Personal Communication Services (PCS) networks in the United States has pro-
vided an even broader range of services for wireless data. 
By 2005, there will be as many wireless subscribers as there are wired ser-
vice subscribers. In fact, in many developing countries, wireless networks are 
being deployed faster than their traditional wired counterparts because the 
cost of installation, service, and upgrades is significantly lower. With the cost of 
wireless installation rapidly falling as standards converge and the volume of the 
installed base increases, costs to providers and consumers have similarly 
dropped. As a result, the rate at which the public has adopted wireless services 
is on par with the rate at which the videocassette recorder became a household 
item. In fact, wireless services have caught on much faster than other signifi-
cant product developments, including the automobile and telephone. 
A Bit of Technical Talk 
If you are interested in the nuts and bolts of wireless data technologies, you will 
probably find the material in this section fascinating. If you are not, you may 
regard it as optional reading. Wireless technologies may differ in their design and 
application, but their impact on content remains fundamentally the same. (Then 
again, if you need to separate fact from fiction when talking to the providers of 
specific services, the following information may also come in handy.) 
The Basic Concept behind Cellular Radio 
The concept of cellular radio communications is quite simple. Rather than using 
a single high-power station with multiple channels to cover a large area, many 
3 

Chapter 1 
4 
smaller stations are distributed across the saine area. Each station uses a differ-
ent subset of the same channels formerly used by the high-power station. This 
way, adjacent stations (each of which covers an area called a cell) do not interfere 
with each other, much as radio stations in different parts of the country can use 
the same frequency without getting in each other's way. Cellular network users 
use wireless access terminals to access the wireless network. These devices may 
be wireless telephone handsets (that is, a cell phone at your local wireless shop), 
screen phones, or wireless data terminals, depending on the network, service, and 
product. Regardless of what you call it, a wireless access terminal is small, 
mobile, and carried by you. These wireless access terminals communicate with 
base stations, which are fixed stations responsible for coordinating all wireless 
access terminals within a specific cell. In turn, the base stations coordinate with 
a Mobile Switching Center (MSC), responsible for coordinating activities between 
base stations. Figure 1-l shows a hypothetical cellular network. 
"',ii' 
MSC 
Web 
-
Hosts 
Figure 1-1. A simplified cellular network 
In a cellular system, channels are reused only when sufficient geographic 
distance exists between them to prevent interference among shared frequencies. 
The challenge here lies in designing and deploying a cellular system that can 
manage and maintain these frequencies and track the callers who are in contact 
with each cell station as they move between cells. 
A cellular base station moderates the reuse of frequency on behalf of the 
wireless terminals in its cell in accordance with geography, system use, and radio 
propagation. As the wireless terminal physically moves between multiple cells 
(such as when you carry it with you), it receives instructions regarding the fre-
quencies to be used for communications. Cellular radio works as it does because 
of the increased investment by providers in the system's individual stations and 
the growing complexity of the wireless terminals. 

A Wireless Data Primer 
Packet-Switched Radio Networks 
Traditional telephony networks are circuit switched. With circuit switching, the 
network establishes a point-to-point link between two nodes for the duration of 
the communication of a message. The analog phone system also worked this 
way, but with the advent of digital networks, this is no longer the case with a large 
number of calls. 
The Internet and the wireless networks discussed in this book generally 
operate as packet-switched networks. Over a packet -switched network, the mes-
sage originator breaks up a message into many small pieces called packets. Each 
packet may take a separate route to its destination. When the packets reach their 
destinations, they are reassembled to form the message that was sent. The origi-
nator and receiver are responsible for negotiating details about the ordering of 
packets, what to do about lost or corrupt packets, and similar details. 
The BellSouth RAM network, ARDIS, and other similar networks are exam-
ples of wireless packet -switched networks, whereas the Internet is an example of 
a wired packet-switched network. On the BellSouth RAM network, messages are 
broken into packets and exchanged using the Mobitex protocol, originally devel-
oped by Ericsson. ARDIS, on the other hand, uses the MDC4800 and RD-LAP 
protocols developed by Motorola. 
Most content developers do not have to worry about "raw" wireless protocols 
because their interaction will be with the Internet protocols, Wireless Application 
Protocol (WAP), or Short Messaging Service (SMS). All of these protocols are 
independent of the specific protocols a network offers. Many packet -switched 
networks now support Transport Control Protocol/Internet Protocol (TCP /IP) 
directly through gateways that move IP traffic from the Internet to a selected 
wireless network. On the client-side device, a customized TCP/IP stack is 
installed that uses the wireless interface and protocols as the underlying network 
(called the bearer or bearing network) forTCP/IP traffic. Other networks operate 
similarly using SMS, giving applications seamless access to Web services through · 
a gateway server at the interface between the wireless network and the Internet. 
Frequency Division Multiple Access 
Central to the notion of wireless communications is the need to share frequency 
between multiple users. One of the simplest schemes for accomplishing this is 
Frequency Division Multiple Access (FDMA). Used by AMPS, this system works 
by assigning specific frequencies to a user for the duration of a communication. 
During the course of a session, an assigned frequency is only used by its assignee. 
FDMA is generally used with analog systems or simple digital systems, such as 
local-area or medium-area cordless phones that may use digital encoding 
schemes to carry voice traffic over assigned frequency channels. 
5 

Chapter 1 
6 
Time Division Multiple Access 
Time Division Multiple Access (TDMA) is the simplest mechanism for packet 
radio networks. TDMA assigns each user a specific time slot over a unit oftime 
called a frame. Frames may be reserved by the protocol to coordinate new users 
within a defined area (for example, to facilitate roaming between adjacent cells). 
The system is essentially a buffer-and-burst system, in which units buffer data to 
be exchanged until it is their turn to transmit. 
The Cellular Digital Packet Data system discussed earlier in this chapter uses 
a blend ofFDMA and TDMA to carry IP-based traffic over the AMPS network. 
Callers on the network are assigned a fixed pair of frequencies (one for the down-
stream channel from the cell to the wireless terminal and one for the upstream 
channel from the wireless terminal to the cell) for the duration of a call in a spe-
cific cell. Cells typically have unused frequencies ready to assign to users to 
satisfy demand during peak operating times. In addition, unused gaps of time on 
the frequency between two calls are commonplace. The Cellular Digital Packet 
Data system employs TDMA to allocate use of these unused gaps of time on 
a particular frequency among multiple users with small packets of data and uses 
FDMA to allocate the use of frequencies among voice users. 
You will also find pure TDMA systems. The U.S. Digital Cellular (USDC) sys-
tem uses TDMA, as does GSM in Europe. In these systems, voice traffic is 
digitized and then broken into packets. The digital nature of these networks gives 
them the ability to carry short messages as well as voice traffic, such as SMS 
available under GSM, in which messages are carried as digital content between 
packets of voice data. These networks are also well suited to supporting the 
Wireless Application Protocol. 
Spread Spectrum Access 
Other, more-complex systems also exist for sharing multiple users. Both 
Frequency Hopped Multiple Access (FHMA) and Code Division Multiple Access 
(COMA) are applications of spread-spectrum technology designed to share a wide 
allocation of spectrum among multiple users. 
FHMA 
FHMA uses many small chunks of frequency over time, each lasting only a split 
second. Each user on an FMHA network is given a unique code that defines 
a particular pseudo-random set of frequencies. Although frequency use appears 
to be random, a receiver knowing the unique code of the transmitter can calcu-
late the frequencies on which to hear the transmitter. The user's terminal 

A Wireless Data Primer 
transmits on each frequency in the set for a small amount of time, which makes 
a user's signal appear to "hop" from frequency to frequency for the duration 
of a message. 
The receiving station uses that same sequence to tune its receiver and recon-
struct the message. The hops may be faster than the signal rate, in which case the 
system is called a fast-frequency hopper. Or, the hops may be slower than the sig-
nal rate, in which case the system is a slow-frequency hopper. The receiver selects 
the hopping sequence appropriate for the given user. FMHA is popular among 
local-area and medium-area networks, such as those employed by wireless 
PCMCIA cards that meet the WIF'i (IEEE 802.11) standard. 
COMA 
By comparison, CDMA uses one relatively large frequency region continuously, 
by multiplying the original signal and a wide bandwidth signal (called a spread-
ing function). Like FHMA, it is based on a pseudo-random sequence generated 
from a unique code, which determines the spreading function to be used. 
(Conceptually, a CDMA system can be compared to an extremely fast FMHA 
system in which the hop rate is of a magnitude many times higher than the signal 
rate.) Reception in a CMDA system requires monitoring the resultant high-
bandwidth signal and correlating the signal with the sequence of the transmitter. 
Qualcomm uses CDMA in its successful digital cellular products, providing 
the backbone to one of the PCS networks found in many areas in North America. 
Like FHMA and TMDA, CDMA can be used to exchange packet data for wireless 
data as well as digitized voice. The network protocols devised by Qualcomm sup-
port data and voice traffic, which is carried by digitizing and compressing analog 
data and then breaking the data into packets, which are then sent via CDMA to 
their destination. 
Putting It All Together: How a Cellular System 
Works 
Whereas the concept of a cellular network is fairly simple to grasp, the actual sys-
tem for supporting a cellular network is staggeringly complex. Figure 1-2 shows 
a simplified example of such a system. The network must provide a means for the 
setup and han doff of users between cells, as well as authorization, traffic routing, 
and billing. 
7 

Chapter 1 
8 
Wireless 
Access 
Terminal 
* 
Base Station 
Auto & Billing 
I 
Provider Intranet 
Mobile 
Switching 
Center 
Provider Intranet 
Web Server 
Gateway 
Servers 
* 
Figure 1-2. Deployment view for a hypothetical cellular network 
Initial Information Exchange 
When a user enters a region sezyi.ced by a cell station, his or her wireless terminal 
announces its presence and requests service from the mobile switching center. 
Typically, the wireless terminal listens for the strongest cell station. That station 
then gives the terminal instructions on how to announce its presence to the cell 
station from which it will seek service. During this exchange, the wireless termi-
nal is authenticated, billing information is processed, and instructions for 
operating within the cell (such as frequency, code, or time constraints for multi-
ple access) are provided to the terminal. 
This dialog, collectively referred to as registration, must occur whenever 
a terminal roams from cell to cell. Registration provides hosts on the network 
with the information needed to route data to a specific wireless terminal. 

A Wireless Data Primer 
Competing networks support so-called roaming features. Therefore, if a ter-
minal roams outside of its native service area, details on subscribed services, 
such as voice calling preferences for three-way conversations or call forwarding, 
may still be obtained. 
Movement Monitoring and Intersystem Handoff 
As the terminal moves within the cell, the base station continually monitors the 
terminal's signal strength and passes the measurements to the MSC. When 
appropriate, the MSC will instruct the base station and unit to perform a handoff, 
causing the unit to begin using a new base station. This may be done entirely 
through the action of the base station monitoring the unit, or with the assistance 
of the terminal if the unit is capable of monitoring adjacent cell activities during 
its normal operation. Less frequently, an MSC may initiate an intersystem hand-
off-allowing the terminal to roam-in which it hands the terminal to an 
adjacent MSC. This is done in the event the terminal moves into an area covered 
by another provider, or when the terminal moves out of the MSC's coverage area. 
Data Exchange 
While all this is happening, the data itself is being exchanged with the wireless 
terminal and base station. This data is carried to the MSC, where it is brought to 
the Internet through one or more gateways responsible for translating the wire-
less protocols to the appropriate Web protocols. 
At the MSC, gateway servers are responsible for translating the various proto-
cols used by the wireless network and the Internet on behalf of hosts on both 
networks. For example, using WAP, the protocols of the bearer network may be 
entirely different from those used by the Internet. In addition, in the case ofWAP, 
the gateway provides an application-level translation from the WAP protocols to 
Web protocols, and vice versa. 
Summary 
The wireless data marketplace has suddenly exploded after a nascent period that 
lasted over the past 10 years. Wireless networks have moved from being special-
purpose tools for a few mobile workers and wealthy consumers to being on the 
brink of widespread adoption by average consumers. 
Most commercial wireless networks are based on existing cellular networks, 
any one of which uses one of a number of schemes to share frequencies between 
mobile wireless access terminals over a wide area. These networks divide a geo-
9 

Chapter 1 
10 
graphic region into cells, each of which has a station responsible for bridging the 
gap between wireless terminals and wired network. 
This path from wireless network to wired Internet involves hops from a cell's 
base station, through one or more switching centers, through a gateway server, 
and then to an Internet destination. Packets from the Internet follow a similar 
route in reverse when finding their way to a wireless access terminal. 

CHAPTER 2 
The Wireless Landscape 
THE NATURE OF INFORMATION ACCESS is undergoing a quiet revolution. As the World 
Wide Web has become available to consumers around the world via their home 
computers, a similar type of network is emerging that eliminates the need for 
a computer or wires to access the Web. As this network emerges, more and more 
users are accessing Internet content through wide-area radio networks, such as 
those commercially deployed by the major telecommunications companies. 
This new wireless network consists of millions of small, portable devices, 
readily available whenever and wherever a user needs information. Handheld 
computers, smart phones, and similar gadgets are becoming increasingly avail-
able with wireless connectivity options. 
An Explosive Growth Industry 
As more and more companies employ the Web to integrate various sources of 
information with their partners' and consumers' information systems, the Web's 
value as a reference tool has risen exponentially. With today's rapidly growing 
wireless infrastructure, the Web makes it possible to access information from vir-
tually any source at any time. 
You can trace the growth of wireless Web access to the scores of companies 
that have invested big bucks in this emerging technology hoping to get a piece of 
the revenues from this growing market. These companies provide the infrastruc-
ture, hardware, and software necessary to make wireless Web access possible. 
They recognize the commercial potential of acquiring millions of wireless data 
subscribers over the next several years. 
The cellular phone is a perfect example of this business development. The 
growing public demand for cellular phones over the past 15 years has resulted in 
one of the most successful new industries of this century. Hundreds of millions of 
wireless handsets have been sold to date. 1\vo years ago, analysts including IDC 
and Gartner estimated that by 2005 more than one billion wireless handsets 
would be in use; today, we have already exceeded this number. Many, if not all, of 
those handsets will be equipped to handle both voice and data. 
11 

Chapter2 
12 
Uses of the Wireless Web 
Handset owners will use wireless devices whenever and wherever computers are 
impractical. For instance, a laptop may be usable in some instances, but access 
to the Internet might not be available. For workers who need a computer when 
they are on the road or out in the field, handheld wireless computers are avail-
. able to meet a variety of needs at a relatively low cost. There are also wireless 
handset users who will not even own a desktop computer. 
All of these people will tum to the wireless network for up-to-date infor-
mation and services. In fact, the trend has already begun. Pager subscribers 
receive customized news updates throughout the day, and users are turning to 
phones with Internet access for financial news, entertainment, and more. This 
interaction has a number of useful applications. 
For example, a family on vacation in an unfamiliar town can get instant 
travel directions. With these directions, they can find a hotel, reserve a room, and 
find a restaurant for dinner, all without needing to refer to a printed map or ask 
for directions. A student can use a wireless terminal to look up the meaning of an 
unfamiliar word during a classroom lecture, without interrupting the lecture 
and without fear of embarrassment. Consumers can comparison shop across 
the Internet while within a store, finding the best product at the best price. As the 
wireless Web grows, interaction with the Web will be immediate and tailored to 
the user. 
Another example is wireless pay-as-you-use service. With two-way data net-
works, some phone services can accept a credit card number entered directly on 
the handset to pre-pay for a number of days of data use or minutes of voice use. 
Users can buy a shrink-wrapped phone and subscribe to service off and on as 
they need it. This gives subscribers unprecedented budget flexibility while 
lowering paperwork costs for service providers burdened with contracts adminis-
tration overhead. In addition, some phones will feature an automated recharge 
capability right from the handset. 
The Opportunities for Wireless Development 
Opportunities for wireless content exist in several areas: 
• Partnerships between existing content providers and wireless Web devel-
opers to offer existing content to subscribers 
• Partnerships between existing wireless service providers and content 
providers make new content available to subscribers 
• Offerings of new wireless Web content to existing or new subscribers 

The Wireless Landscape 
In many cases, the opportunities will include a mix of all three, either initially 
or after consolidation rolls together content and service providers. The purchase 
of BigBook by Verizon, a union of content and service providers on the traditional 
Web, will be a model operation for many wireless content providers. 
Content Provider Partnerships 
Existing providers are working to move to the wireless Web. Consider the 
following: 
• Yahoo! Anywhere gives users of Palm Powered and Wireless Application 
Protocol (WAP) phones access to Yahoo! Messenger wherever they are. 
• Mobile MapQuest provides turn-by-tum directions to users of AvantGo 
software and Palm Powered organizers. 
• The Internet Movie Database provides access to information on the cast, 
crew, and reviews of movies for both Web and wireless Web viewers. 
In most cases, content providers offer these services as they position them-
selves for the coming generation of wireless subscribers. In other cases, such as 
the Internet Movie Database, the initial work was done outside the content 
provider, and only later was the content provider brought into the mix. 
The business models behind these partnerships vary. In many cases, wireless 
Web developers will be able to use their skills as contractors or employees to par-
ticipate in the building of wireless sites. Less often, developers may be able to 
share in the ongoing subscriber revenue stream from wireless services. 
Service Provider Partnerships 
In the short run, wireless service providers will be seeking content to enhance the 
value of their wireless services. During this time, some service providers may be 
willing to help finance not only the startup but also the ongoing maintenance 
costs incurred by a wireless content provider, especially for new and novel con-
tent. This relationship may enable enterprises with limited funding to break into 
the wireless marketplace. 
Over the long run, partnerships with wireless service providers will amount 
to endorsements, and the business enterprise of the wireless content provider 
will benefit from the increased usage volume from referrals. 
Although service partnerships are helpful, they are by no means required. 
A look at the Palm.Net wireless service from Palm is instructive. The service 
13 

Chapter2 
14 
launched with wireless access to ABC News, ESPN, E*Trade, and other services. 
Today the service has access to more than 600 commercial content providers, 
including Yahoo!, The Wall Street ]ouma~ and Starbucks. 
New Wireless Content 
The most lucrative opportunity for wireless Web developers is in the creation and 
deployment of new wireless content. A developer is free to obtain content, pro-
cess it, and make it useful to the mobile user as he or she sees fit. 
Opportunities abound in enterprise and business applications, enabling cor-
porations to provide greater access to increasing numbers of mobile users. 
A similar, untapped resource also exists in the consumer marketplace. Horo-
scopes, jokes, product reviews, travel reviews-anything a consumer would want 
can be provided wirelessly. 
Although some of these opportunities may require third-party partnerships 
with existing content providers, others will not. Imagine a consumer reporting 
site dedicated to providing purchase point information about thousands of prod-
ucts in different categories, organized by category and product code. Just such 
a service is in the making; it is called BarPoint.com. Here, content editors aggre-
gate content from distributors, reviewers, and wireless consumers around the 
country, and an entire new business is created. Other organizations will choose 
to buy content and repackage it, as Excite has done with their presentation of 
stock quotes from Standard & Poor's ComStock. In either case, businesses are 
able to provide content that was not previously available. 
The Fundamentals of Wireless Development 
Once you have staked a claim in the wireless world, it is time to get down to busi-
ness. Two fundamental principles demand a new approach to developing Web 
content for the wireless market: 
• Consumers become subscribers. 
• Subscribers are mobile, which makes the data appear to be mobile. 
Understanding these principles and knowing how they interrelate is key to 
designing truly valuable wireless sites. 

The Wireless Landscape 
Subscribers vs. Consumers 
In the wireless marketplace, device users are subscribers. In addition to renting or 
owning the device they use to access a network, they are also paying on a regular 
basis for access to the service that provides the data. Subscribers provide a reoc-
curring revenue stream, but only as long as they find the services they purchase 
worth what they are paying. This is in sharp contrast to users, who pay once for 
a product or service of limited duration. 
A wireless subscriber tends to be more aware of the cost of information 
access than the average desktop user. This awareness affects the relationship 
between the subscriber and the content provider. Subscribers become resentful if 
they end up paying for something they do not want, and many subscribers will 
quickly catch on to a content provider's misuse or abuse of subscriber-paid 
bandwidth and take their business elsewhere. Such transgressions may be minor, 
such as adding extra images, or they may be more serious, such as excessive 
advertising paid for by the subscriber. 
Subscribers consider themselves active participants in an ongoing business 
transaction, rather than just passive consumers. This shift in the customer-
provider relationship forces a different kind of business model on site developers 
interested in providing wireless content. Traditional Web models, such as adver-
tising and purchasing partnerships, will take a back seat to strategies involving 
pay-per-use and revenue sharing between service providers and content 
providers. 
These new models may be simple (for example, a subscriber pays a fee per 
transaction), or they may be complex (a service provider invests heavily in a con-
tent provider in order to jump-start a service, and then the content provider 
shares revenues with the service provider to repay the initial investment and gen-
erate additional revenue for the service provider). 
When setting out to create a wireless Web site, you should ask yourself the 
following questions: 
• What are you providing to your subscribers? 
• What are you asking for in return? 
• What implicit costs are you asking your subscribers to bear? 
• Is what you are providing equivalent in value to the sum of the implicit and 
explicit costs? 
• What kind of long-term relationship are you seeking with your subscribers? 
15 

Chapter2 
16 
The answers to these questions are a litmus test as to the true utility of your 
service to your subscribers. Moreover, they will help you explore how you can 
continue to add value to your content as you move forward. 
Subscriber Mobility and Data Mobility 
Wrreless subscribers are mobile subscribers. As such, they interact differently with 
their devices and the information displayed than do users of desktop computers 
or users ofWebTV-like Internet terminals. Mobile subscribers expect instant 
access to information. In their minds, the information is with them, and not on 
some distant server accessed over a network using thousands of radio towers and 
zillions of miles of cable. This creates a perception of data mobility-users feel as 
if they are carrying a metropolitan phone book, travel guide, map, newspaper, and 
the activities of the New York Stock Exchange clipped to their belt. 
In Chapter 3, "The Wireless User Interface," you will see how the need for 
data mobility affects when and how users interact with their mobile devices and 
how this need can impact your site design. This, in turn, requires you to pay spe-
cial attention to the following: 
Ease of use: Access to desired information must be fast and hassle-free for 
users. In many cases, your viewers will be performing other tasks, such as 
driving or talking, while working with your content. More importantly, 
many people viewing your content may never have even used a computer. 
Your great uncle, the plumber who bailed out your bathroom last 
Thanksgiving, or your grade-school math teacher (now retired) may be 
one of your staunchest subscribers. 
Information access: Subscribers will be using your site to access critical 
information as part of a task or activity they are trying to complete; they 
are not engaging in idle recreation. Therefore, your site must be well orga-
nized to enable rapid access to any desired information. Not only does this 
organization help provide an easy-to-use site; it meets your viewer's needs 
to accomplish his or her tasks quickly and efficiently. 
Viewer expectations: Your subscribers will expect your site to act in a man-
ner similar to that of the rest of their wireless devices. In fact, they will 
expect your site to be part of the device, and act the way their device does. 
Most users will not recognize the boundaries between your content and 
their hardware, especially on a device that has little differentiation in its 
interfaces. For example, lists, buttons, and other controls should be crafted 
with the target device in mind. The viewer is using a phone or handheld 
computing device, not a cumbersome personal computer. Interaction 

The Wireless Landscape 
between the user and your site must be intuitive and the desired results 
must be obtained quickly. 
Having an understanding of data mobility and your subscriber's environ-
ment will help you establish content in a manner best suited to its use. To foster 
this understanding, ask yourself these questions: 
• In what sort of surroundings will your content be viewed? 
• How-much attention will your subscribers give to your content? 
• What sort of mood will your subscribers be in when they view your con-
tent?What about when they are done viewing it? 
• Will your subscribers perceive the information you are providing as an 
integral part of the device? 
• Will the information reflect their lifestyles? If not, why? 
The Computing Capacity Gap: Handheld versus 
Desktop 
Factors such as power consumption, physical size, and affordability create 
a vast disparity between the capabilities of mobile information appliances and 
fixed ones. 
Devices used by mobile subscribers have vastly different capabilities than 
their desktop kin. The oft-quoted Moore's Law (named after Intel cofounder 
Gordon Moore), which says that computing capacities double every 18 months, 
applies equally to mobile devices and desktop units. Moore's original prediction 
was that chip capacity would double every two years. In reality, the pace is even 
faster. Take a look at Figure 2-1, which shows functionality per unit cost for both 
desktop and handheld devices. Over time, it becomes possible to buy signifi-
cantly more computing capacity for the same unit cost. 
17 

Chapter2 
18 
+-' 
VI 
0 
u 
+-' 
..... 
c:: 
:::::> 
......... 
>. 
+-' 
..... 
rl 
1'0 
c:: 
0 ..... 
+-' 
v 
c:: 
;:, 
u... 
-
Desktop 
- - -
Handheld 
1990 
2000 
Time 
Figure 2-1. Functionality per unit cost over time 
2010 
However, although the computing capacities of individual components and 
entire systems may be increasing at an exponential rate, a feature gap exists 
between the different platforms. And this gap, as the figure shows, will not close 
up anytime soon. The same advances in technology that have created the 
mobile-device market-increased miniaturization, increased computational 
power, and decreased power consumption-will also improve their desktop 
counterparts, further widening the gap in information-processing capabilities. 
Throughout this book, I will focus on how these differences affect how you need 
to develop content for the desktop. Chapter 3, "The Wireless User Interface," 
explores one side of this discrepancy-network bandwidth-in great detail. 
Because of the relatively limited processing capacities (for now, anyway) of 
mobile devices, wireless Web content must be simple, use relatively little memory 
and bandwidth, and require a small amount of processing by the device's Central 
Processing Unit (CPU) prior to the content being displayed. 

The Wireless Landscape 
Exploring Markup Options 
The first task you will need to do as you prepare to take the wireless plunge is 
recognize the platforms your subscribers will use so that you can pick the appro-
priate markup languages. Being knowledgeable about these choices is key to 
designing a wireless-ready Web site. 
HTML and the World Wide Web 
Unless you have been trapped under a heavy object for the past seven years, you 
are well aware of the sweeping influence of the World Wide Web. The establish-
ment of a worldwide network based on open data standards has fueled an 
explosion of information exchange. Millions of computers are already on the 
Web, with many thousands added each month. 
The Client-Server Model 
The Web uses a client -server model to provide data to viewers, as you can see in 
Figure 2-2. On behalf of its user, the Web client makes a request to the Web server 
for content. The Web server then obtains the content, either from its file system 
or by dynamically creating it on the fly, and returns the content to the Web client. 
The Web client then displays the resulting content. (In Figure 2-2, the smallest 
boxes represent software modules, hardware, firmware, libraries, components, 
and such that do things inside the computer. Appendix B, "Unified Modeling 
Language for Web Developers," has further information on UML diagrams for 
wireless Web deployment.) 
¢J 
User 
c::2 
Agent 
Web Client 
• 
Internet 
or 
Wireless 
Network 
Figure 2-2. The Web deployment model 
• 
Web Server 
The protocol for making the request to the Web server, and several possible 
schemes for formatting the content, have been standardized so that anyone can 
19 

Chapter2 
20 
write the software necessary for implementing this process. These standards are 
also used for wireless devices. Many of to day's handheld computing devices can 
run Web browsers capable of presenting Web pages from virtually any site on the 
Internet. 
The strengths of the client -server approach are obvious, although the imple-
mentation has problems. On the up side, content developed for mobile devices 
can be created using any of the multitudes of authoring tools available. The open 
standards allow developers to author content for many devices with just a single 
investment in technology. Let's take a look at some of the problems. 
Recognizing Some Formatting Limitations 
Using existing client-server technologies and content may be tempting, but the 
rewards are often few. Many handheld devices lack the capacity to fully render 
a rich Web page, especially if the page contains a good deal of images or multi-
media. Even when a device can render a full Web page, physical constraints such 
as screen size can alter page layouts because HyperText Markup Language 
(HTML) layout on limited screens can result in bizarre-looking Web pages. 
Layout, color, display contrast, and other factors can make a page that looks 
beautiful on a desktop device unreadable on a handheld one. In Chapter 3, "The 
Wrreless User Interface," I will show you how bandwidth limits the kind of con-
tent you can deliver to wireless devices; in Chapter 8, "HyperText Markup 
Language, the Wrreless Way," I will introduce you to a subset of HTML that can be 
used with almost any wireless device. 
In addition, whereas the basic formats for the Web-including HyperText 
Transfer Protocol (HTTP), HTML, and simple image formats such as GIF and 
JPEG-are available on mobile devices, many of the more sophisticated aspects 
of the Web are not. Most mobile devices, for example, do not support all the fea-
tures of HTML 4.0 and advanced formats (such as Adobe PDF) are not available 
at all. Where support for scripting exists, its functionality is a far cry from that 
found on a desktop. Multimedia, such as sound sequences or Shockwave-style 
animations, is not likely to be available on a device with a paltry 8MB of RAM. 
In general, content developed for conventional Web access when viewed on 
wireless devices will look lackluster by comparison. The opposite also holds true: 
Content meant for display on wireless devices, when viewed through a desktop 
browser, will lack much of the glamour and glitz needed to attract and hold a Web 
surfer. 
There is hope, however. Developing for wireless devices using Web standards 
is not impossible, or even that difficult, once you understand a few basic princi-
ples. (I will discuss those principles in Chapter 4, "The Wrreless World Wide Web," 
and Chapter 8, "HyperText Markup Language, the Wireless Way.") Supporting 
wireless Web clients can lead to a better Web site design for all viewers. 

The Wireless Landscape 
Lightweight content optimized for wireless devices looks clean and uncluttered, 
and it loads faster than gee-whiz pages with lots of flashy graphics, sound, and 
interactive scripts. This, in turn, can result in a more productive user experience, 
even for desktop viewers. 
i-mode 
i-mode is the most successful wireless service to date, with more than 27 million 
subscribers in Japan as of this writing. Released in 1999, i-mode has enjoyed 
astounding growth rates unparalleled in other countries. The American media 
has so often confused the distinction that it is worth remembering that unlike 
either the wireless Web discussed in the previous section or Wireless Application 
Protocol (WAP) discussed in the subsequent section, i-mode is a service, not a set 
of protocols. i -mode's success is because of many factors, including the careful 
partnerships established between the service's owner (NTT DoCoMo) and con-
tent providers, the relative scarcity of personal computers in Japan, and the high 
cost oflocal-loop Internet access (what Americans see as traditional dialup 
access) for most users. 
The i-mode service uses a restricted subset of HTML called cHTML (compact 
HTML) along with a number of extensions to support telephony features. 
Handsets request cHTML documents from a gateway server running at i-mode 
over PDC-P, NTT's wireless digital network. From there, requests go to existing 
Web servers providing cHTML content, which answer the request and send 
a response via the I-mode gateway server back to the handset. Figure 2-3 shows 
the deployment diagram. 
21 

Chapter2 
22 
i-mode Handset 
PDC-C Wireless Network 
Internet 
Figure 2-3. The i-mode deployment model 
Because the i-mode service uses cHTML, a simple variant ofHTML, it is easy 
for developers to learn. In contrast to WAP, i-mode's demand on gateway 
resources is minimal because the i-mode gateways need only bridge the wireless 
network and Web, and do not perform costly validation and compression. As 
deployed in Japan; i-mode has another advantage-running on the PDC-P net-
work, i-mode content is obtained over a packet -switched network. By 
comparison, many HTML- and WAP-based services in the United States and 
Europe access the Web over a circuit-switched connection, essentially dialing 
into a remote Internet Service Provider (ISP) before Web access takes place. 
Consequently, even though the PDC-P network is no faster than existing net-
works outside of Japan, the experience feels faster. 
As of this writing, a number of providers in the United States and abroad, 
including AT&T, have partnered with NTT DoCoMo to deploy cHTML-based ser-
vices outside of Japan. 
Wireless Application Protocol 
In June 1997, L. M. Ericsson, Motorola, Nokia, and Openwave (formerly Unwired 
Planet) formed the WAP Forum. As manufacturers of cellular phones and cellular 
infrastructure, Ericsson, Motorola, and Nokia sought a single standard for wire-

The Wireless Landscape 
less data; Openwave brought a proposed standard to the table that provided 
a starting point for everyone. The WAP Forum aimed to achieve the following: 
• Integrate Web content and advanced data services to be used on wireless 
phones and other wireless terminals. 
• Create a global wireless protocol specification that works across all wireless 
technologies. 
• Enable the creation of content and applications that scale across a wide 
range of wireless networks and device types. 
• Embrace and extend existing standards and technology wherever appro-
priate. 
• As a result of the forum's efforts, more than 80 companies recognize the 
WAP specifications, which are now becoming the standard mechanism for 
integrating the Web with wireless devices. 
WAP leverages the data distribution model adopted by the Web (see 
Figure 2-4). WAP clients running on wireless devices use the lowest levels of the 
protocols behind WAP between the client user agent and the WAP gateway to 
encode requests and responses. It does this in a way that is most efficient for 
wireless devices. In turn, the WAP Gateway uses HTTP to interact with the Web 
server. The Web server provides its content in WML, the Wrreless Markup 
Language (WML), although it may use any of the standard Web technologies 
(including CGis, content databases, server-side includes, and so on) to generate 
the content to be served. 
23 

Chapter2 
24 
WAP Client 
Wireless Network 
Internet 
1 
Figure 2-4. The WAP deployment model 
ProducingWML content is a fairly simple process. The content is authored 
using WML, either by hand or with content -editing tools designed for WML 
development. A Web server, which is either the same server used for desktop 
browsers or a secondary one, in turn, hosts this content. Mobile devices make 
their requests of the server via the WAP gateway, requesting WML documents 
instead of HTML documents. In Chapter 8, "HyperText Markup Language, the 
Wireless Way," you will see how you can create WML content; Chapter 9, "Palm-
Powered Web Clipping Applications," shows you how to make your content more 
interactive usingWMLScript, the scripting environment ofWAP. 
Hypertext Device Markup Language 
The Handheld Device Markup Language (HDML) preceded WAP, and is in fact 
the foundation for much of what constitutes WML. Created by Unwired Planet 
(now Openwave), it was a significant addition to the WAP Forum's activities and is 
now maintained by Open wave as a separate open standard competing with the 
WAP standard. 

The Wireless Landscape 
As of this writing, WAP has largely replaced HDML. Many wireless handsets 
use the browser written by Openwave, which can display both WML and legacy 
HDML content. 
The data distribution model of HDML is fundamentally identical to that of 
the WAP model. A Web server delivers content in HDML over HTTP, and the con-
tentis carried to a gateway server (called an UP.Link server in HDML parlance), 
where it is provided to wireless clients in response to a request. 
Writing HDML is similar to writingWML (or even HTML). In Appendix C, 
"Handheld Device Markup Language," you can learn how to produce HDML con-
tent for wireless screen phones. 
Exploring Hardware Options 
The emphasis on interoperability from organizations that are creating the stan-
dards, such as the WAP Forum and the World Wide Web Consortium (W3C), has 
not limited the creativity of hardware manufacturers building wireless access ter-
minals. If anything, the wide diversity in hardware belies the clear delineation of 
a few well-adopted standards for the management of wireless data. 
In some cases, hardware used for wireless access has been modified to oper-
ate in a way that differs from its Web-oriented purpose. This is especially true of 
handheld computers, which sport wireless modems or links to cellular phones in 
increasing numbers. Some of these devices have integrated wireless technology 
direct from the manufacturer, and others employ expansion cards that provide 
wireless access on one of the wireless networks. 
Other hardware is custom tailored for wireless access. For instance, so-called 
"smart phones" have multiline LCD displays and software to support wireless 
data access. Other hardware items, such as the Research In Motion BlackBerry 
pager, a two-way pager capable of interfacing with a user's e-mail account, are 
single-purpose devices. 
Finally, over the past decade, handheld device manufacturers have been 
releasing equipment with growing data functionality while making many 
attempts to endow these devices with wireless access. In some instances, wireless 
access has been tightly integrated with the device through the use of a voice net-
work, creating a sort of cellular phone on steroids or a Personal Digital Assistant 
(PDA) that can hear and speak, a.k.a. a super phone. Most vendors call these 
products simply communicators, which blurs the distinction between smart 
phones with simpler operating systems and these more powerful devices. 
In the following sections, I discuss the features of these hardware flavors, and 
touch on how they differ from laptop computers. Knowing which devices your 
subscribers are using can help guide you in applying a particular technology. 
(You must also have an understanding of your subscriber's environment in order 
to tailor your content to his or her needs. In later chapters of this book, I will 
25 

Chapter2 
26 
cover various operating platforms, user constraints, and device limitations and 
how they figure into your planning and creation of content.) 
Super Phones 
Epitomized by the Nokia 9000 series clamshell phone running Symbian's EPOC 
operating system, super phones offer a computing platform based on a Personal 
Digital Assistant (PDA) combined with cellular phone hardware. A number of 
these devices have been around for a while, ever since PDA manufacturers began 
working with telephony providers to integrate the power of handheld computing 
with wireless access technology. Today's super phones include Palm Powered 
handhelds from Handspring, Kyocera, and Samsung, as well as handsets from 
Sharp and others running Qualcomm's BREW platform. 
These devices include an integrated Web browser, allowing users to view Web 
pages wirelessly. In addition, many include WAP browsers, letting you view WAP 
content as well as HTML content within the same application. 
Super phones originally represented the first steps toward the creation of 
the smart phone (covered next). Consequently, the features of super phones and 
smart phones are often quite similar, although a key distinguishing feature is 
a super phone's ability to run third-party applications. Smart phones, by compar-
ison, are generally less expensive and can only run applications that the phone's 
vendor sells directly. 
Some super phone features-such as tight integration between data and 
voice, compact size, portability, and the availability ofPDA-like features-that 
make super phones desirable to some consumers also slows their deployment. 
The relatively powerful computing hardware also increases their cost, directing 
sales away from the devices in a price-sensitive market. Nevertheless, super 
phones constitute a hybrid that performs well for specific applications including 
vertical wide-area intranets. 
Smart Phones 
Smart phones are the newest of all devices in the wireless marketplace. An 
extension of the existing cell phone product concept, a smart phone combines 
the best features of a digital cellular phone with the ability to retrieve data 
from the Internet using HTML, WAP, or HDML. These phones often come with 
additional applications, such as messaging, a phone book, and games. 
Increasingly, the applications are being developed in WML or HDML and run on 
the phone, rather than in the phone's embedded programming environment. 
Smart phones have become the common denominator for transmission of 
wireless data. They are the least expensive of all wireless terminals and are simple 

The Wireless Landscape 
enough for the general population to use. In fact, the majority of handsets 
presently sold in the United States are smart phones, although relatively few con-
sumers use the data features these products offer. As such, potential smart phone 
users represent an enormous untapped market for wireless applications. 
Personal Digital Assistants 
Often regarded by the uninitiated as a glorified daily planner or electronic orga-
nizer, the PDA has been awaiting wireless Web access for a number of years while 
PDA manufacturers sought advanced connectivity to increase the demand for 
PDAs while straining the then-primitive networks. By 1995, products such as the 
Motorola Marco and Motorola Envoy that used the ARDIS two-way paging net-
work offered wireless connectivity. 
Today, most PDAs are palm-sized electronic tablets that accept snap-on mod-
ules or PC cards that enable the devices to interface with wireless service from 
digital networks. PDAs are increasingly being used in conjunction with wireless 
networks and for browsing Web content that is downloaded while the device rests 
in a cradle connecting the PDA to a PC. Web browsers of one sort or another are 
available for nearly all PDAs. These products may also use infrared or local-area 
wireless technology such as Bluetooth (a relatively young wireless personal 
area technology) to interface directly to a handset for wireless Web access, much 
as a computer uses a modem with a serial cable to access the Internet. 
The PDA marketplace is split into two camps: the Palm Computing Platform 
on one side, and everybody else on the other. Palm and Handspring, who 
together have shipped more than 10 million handheld devices as of this writing, 
own the lion's share of the PDA market. Both Palm and Handspring products run 
the Palm Operating System, providing binary application compatibility and 
a common user exi>erience across all of these devices. Other products include 
Pocket PC devices, running Microsoft's PocketPC operating system (a variant of 
Windows CE), and a growing minority of Unux-based handheld devices. 
Contrary to some analysts' projections, the PDA marketplace is not likely to 
disappear anytime soon. The demand for cheap personalized computing 
devices that can carry data is not likely to dry up, and the cost of wireless hard-
ware and services will not drop quickly enough for some segments of the 
market. Although wireless operation is becoming more economical (consider 
the Palm Computing Platform Palm VII wireless connected organizer), some 
folks will balk at spending money for a device with integrated wireless connec-
tivity and service. Still others find using PDAs that use Bluetooth to connect to 
wireless handsets for data a viable option. These factors combine to preserve the 
PDA market niche, especially for price-conscious consumers such as students. 
Nevertheless, as an increasing number of PDA manufacturers realize the impor-
tance of wireless connectivity, more and more PDAs will sport integrated 
27 

Chapter2 
28 
wireless technology, continuing to blur the distinction between smart phones, 
super phones, and PDAs. 
Laptops 
Unlike the other categories of wireless terminals discussed here, the computing 
capabilities of a laptop device {or notebook computer) are generally comparable 
to those of their desktop counterparts. Laptop devices are constrained primarily 
by the wireless network, and not by their weight, battery life, or software. And, 
unlike other wireless terminals, laptops are usually operated while the user is 
stationary. 
Laptop users are able to run applications identical to those found on desktop 
computers, the traditional means for Web access. Many laptops have memory, 
disks, and processors roughly comparable to that of desktop units and are used 
in much the same way. Laptop and desktop users employ essentially the same 
software and technologies to access the Web; however, functionality can be com-
promised if a laptop user explicitly selects a low-bandwidth wireless network. 
Over the next several years, many laptops are likely to start including wireless 
interfaces that are integrated into the units, added as expansion options, or pro-
vided through cellular phones. Already, Apple includes the WIFi-compliant 
AirPort as an option with their laptops, and many other vendors are following 
suit with WIFi or Bluetooth wireless expansion. These wireless networks, how-
ever, remain local-area networks, constituting a "wireless Ethernet cable" that 
can connect laptops to a local area network or handheld wireless access terminal. 
Laptop users with these products have the option of accessing the Web through 
traditional means or wirelessly by either using conventional Web technology or 
using a WAP browser running on a laptop. Therefore, if you are predominantly 
targeting laptop users, you may still need to support WAP or HDML and recog-
nize the limitations of a bandwidth-constrained connection. 
What Makes the Wireless Market Unique? 
At first blush, the wireless market seems to be largely an extension of the Web. 
Consumer growth by the millions, rapidly plummeting access costs, and 
increased integration among competing information sources will all be experi-
enced within the wireless marketplace. Despite these similarities, however, many 
contributing factors make the wireless data market significantly different from 
the Web market. 

The Wireless Landscape 
Centralized Distribution 
The current investment in infrastructure, services, and support by the major 
wireless providers is but one clue that the distribution of wireless data will differ 
quite a bit from Web access. The early days ofWeb access saw small providers 
catering to local communities and specific classes of users, with many of those 
small providers eventually consolidated into larger organizations eager to pro-
vide consumers with Web access. By comparison, the wireless environment has 
relatively few providers catering to nationwide markets. The high cost of deploy-
ing a wireless network makes the idea of startup wireless Web service providers, 
such as the new ISPs that have sprung up over the past few years, difficult to 
imagine. 
Existing large corporations in the telephony and data marketplaces will, for 
the most part, manage the distribution of wireless services. This changes the 
nature of opportunities for content providers because their distribution partners 
will be fewer. Nevertheless, after witnessing the growth of the Internet, these con-
tent and service providers are keenly aware that content drives the growth of the 
network. These distribution partners are already eager to obtain additional con-
tent services. For instance, consider the plethora of wireless solutions programs 
currently offered by major network providers such as France Telecom, AT&T, and 
BellSouth. 
For some content providers, partnering with a specific type of network 
provider will speed deployment. On the other hand, for many others, the interop-
eration of multiple standards across networks means that little or no 
differentiation exists among network providers. 
Bandwidth Limitations 
Bandwidth is at a premium in any network, but it has become a watchword for 
wireless networks. To use a plumbing analogy, bandwidth is the amount of con-
tent that can be passed down a pipe. The diameter of the pipe determines how 
much content can flow at any given time, and the speed at which the content is 
flowing determines its latency, or the length of time it takes the content to flow 
a certain distance. (I describe latency in the "How Bandwidth Affects Latency" 
section.) 
Today's third-generation cellular networks have bandwidth just beginning to 
approach that of traditional land-based modems, and many wireless subscribers 
may currently be using systems that provide throughput of a magnitude much 
less than that of their existing modem Web access. 
I discuss the technical implications of these limitations here; in Chapter 3, 
"The Wrreless User Interface," I will discuss in detail the way bandwidth con-
straints affect content and market issues. 
29 

Chapter2 
30 
How Bandwidth Affects Throughput 
By necessity, wide-area wireless networks have a relatively low throughput (the 
data transfer rate). A channel's capacity is a function of the amount of infor-
mation it carries. Additionally, the wider the channel, the more energy is required 
to maintain an equivalent signal strength at the reception point. Therefore, 
higher bit rates result in more bits sent per unit of time, which means that addi-
tional frequency spectrum is required and more power is needed to travel the 
same distance compared to a lower bit rate. This phenomenon is a factor not 
only for base stations, but also in the design of every wireless terminal. 
How Bandwidth Affects Latency 
Latency is a measure of the amount of time it takes for a request to make 
a roundtrip from the client and back. Wrreless networks suffer from greater laten-
cies than wired networks for two reasons. First, the low bandwidth of wireless 
networks results in longer transit times for data traveling through the network. In 
addition, the increased complexity of a wireless network (relative to a wired net-
work such as the Web) raises latency because data must traverse additional nodes 
to reach the final destination. 
A wireless network's throughput constraints are usually visible to the user. 
For example, high throughput on the Web results in fast download times for 
images, text, and large files. Latency, on the other hand, is generally observable 
only by the computers managing the data. In a networked computer game, for 
example, latency is more of an issue than throughput because the importance of 
real-time data surpasses that of the volume of data being exchanged. Conse-
quently, throughput drives the specifics of content design, and latency drives the 
specifics of software and protocol design. 
Subscriber Demands for Ease of Use 
As you will see in Chapter 3, "The Wireless User Interface," many wireless service 
subscribers are not computer literate, such as retirees using a new cell phone. 
Still others may be computer literate, such as today's teens, but by no means 
technical experts in wireless technology or computer programming per se. The 
large number of wireless subscribers-in some areas outpacing the growing pop-
ulation with access to a computer-suggests that many wireless subscribers will 
not have the computing skills of traditional Web users. 
These novice subscribers will expect a wireless terminal to operate as if it 
were a telephone or pager, and not a computer. They will expect the devices to be 
entirely reliable, easy to use, and provide an instantaneous response. Subscribers 

The Wireless Landscape 
may further assume that these devices will operate like a traditional telephone, 
with no extensions to the interface. The user's unstated assumption is that these 
are consumer devices designed for a single purpose. 
Efforts to meet these consumer expectations have been largely unsuccessful, 
with a few notable exceptions. Although a pager or cell phone is significantly 
more reliable than a desktop computer (when was the last time you saw someone 
reboot a cell phone?), the user friendliness of these simple devices is still debat-
able. Few users are able to employ the advanced features offered by these phones 
and their service plans; fewer still will be able to navigate the content on these 
devices unless some significant improvements are made. Therefore, content 
providers as well as manufacturers need to keep simplicity in mind when design-
ing the device-to-human interface. 
Today's wireless devices are a union of hardware, software, and content 
forms. Once manufacturers have figured out how to make these devices small 
and easy to use, and the "operating system'' designers have figured out how to 
create a human-friendly interface that anyone can quickly grasp, any remaining 
complexities that have to be made simple for the user are within the province of 
the content provider. Content will increasingly be the ingredient that differenti-
ates these devices, and for many users, content will determine what these devices 
actually are. 
Wireless Usage Patterns 
Using a computer requires a fair amount of preparation. You need a computer 
table, an ergonomically correct chair, a keyboard, mouse, and other peripherals. 
The system must be booted, applications launched, and a network connection 
made. Using a computer involves work, plans, and goals. 
The same cannot be said of wireless terminals. Their portability, compact 
size, and relative unobtrusiveness all contribute to finding them in use nearly 
everywhere. Users pluck them from bags or pockets to retrieve messages, check 
the weather, or examine the latest stock prices. Students use them to perform 
simple research queries, such as, "What is the meaning of this word?" Wrreless 
terminals are especially useful to mobile workers who can call up the infor-
mation residing on their company networks from the palms of their hands. 
These factors also serve to decrease the amount of time per access a user 
will spend with these devices as compared with the time they can expect to 
spend on a desktop computer. Typically, mobile device users are engaged in 
more than one activity. They may be waiting in a checkout line while using their 
devices, or they may be actively involved in conversation, driving, walking, or 
some other activity. Their primary focus is not on the device or the software it 
uses, but rather on the information being sought or their primary activity. This 
decreases the per-instance usage. The device, therefore, becomes a per-query or 
31 

Chapter2 
32 
per-idea tool, rather than a general-purpose computing device that can monop-
olize a user's attention. 
Price Sensitivity 
Market studies show that products and services must overcome certain price bar-
riers before they can gain widespread acceptance by the average consumer. 
Although this price barrier varies by geographic location, broad market statistics 
demand relatively low costs for the wireless products and services. 
In terms of product acceptance, wireless developers currently face price bar-
riers of $99, $150, and $300, depending on the device's functionality. Customer 
expectations and economics dictate these price limits. A simple wireless device, 
such as a base-model cell phone, should be priced at or below $99 for the great-
est acceptance; more feature-filled units should remain priced at or under $300. 
(A $900 price point also exists, but the expected sales volumes at that price are 
still too low to support most wireless applications.) As prices fall, consumer 
demand increases, but the increase is nonlinear; huge increases in demand are 
seen at each price point. Most consumers are immune to the justifications of 
higher prices and will not spend outside of a price barrier on the basis of features 
or capabilities. 
Market surveys on wireless services show a similar cost breakdown, with 
fee-per-access barriers at $29, $49, and $99 per month, depending on the extent 
of the service provided. 
It is up to the content provider to deliver the most for each dollar that sub-
scribers pay for their access. Subscribers will be seeking information, not 
sophisticated scripting, crazy formatting, or complex logos and graphical bullets. 
Content providers will probably find that the simplest sites are often the most 
popular, partly because simplicity equals low access cost for many viewers. 
Moreover, simple formatting guarantees the highest likelihood of fast access for 
the consumer. Thus, simple formatting itself becomes important when consider-
ing a customer's concern over pricing. 
Potential for Market Growth 
As mentioned in Chapter 1, "A Wrreless Data Primer," the adoption rate for wire-
less telephony devices has matched or exceeded that of other successful 
consumer products to date. This level of acceptance can also be expected for 
wireless data as the availability of wireless services grows and compelling content 
becomes available. Today's numbers on the actual volume of wireless data usage 
typically exceed the predicted numbers from previous years. Although the rate of 

The Wireless Landscape 
adoption may grow slowly at first, exponential growth likely will be experienced 
over the next several years. 
In many developing countries, the cost of deploying a wireless network is sig-
nificantly lower than the cost of installing a copper-wire network. Some countries 
are laying down only minimum wiring for their data infrastructure, preferring 
instead to spend their limit«1d finances on the latest in wireless technology. 
During the next decade, some young consumers' initial experience with 
a telephone may well be a phone call made on a wireless handset. Around the 
world, growing numbers of people are using wireless phones as their primary 
means of communication; some are even replacing their existing telephone ser-
vice with a wireless handset. These factors, along with the expanding integration 
of wireless data with wireless telephony services, will serve to speed the deploy-
ment of wireless data worldwide. 
Data Mobility 
To day's computer users think of their data as residing somewhere in the concep-
tual space that surrounds their personal computer. Many users may not 
recognize that their information could be on a hard drive, floppy disk, network 
server, or Internet server. Although the information they seek may be on a com-
puter halfway across the world, the user's interaction with this information 
occurs at most at a few physical locations using just a few computers-a laptop 
for business, a computer at work, and a computer at home. The infor-mation 
appears to be available to them locally while they use their computer, rather than 
in another physical location (or stored on a hard drive, CD, or other media). 
A number of factors will make the content, rather than the hardware, soft-
ware, or service, the most important element of the wireless network mix: 
• The user's increasing view of a wireless access terminal as an information 
source 
• The blurring of the distinction between manufacturers, service providers, 
and content providers, as consumers focus increasingly on content and 
less on service brand 
• The desire for instant access to information 
These factors point to a single trend: The user's attention will shift from the 
device where the information is obtained to the mobility they are experiencing 
while accessing the information. This gives the user the perception that the data 
itself is mobile; I call this trend data mobility. Data mobility encompasses all the 
factors I have discussed, from the blurring of brand distinction to the mobility of 
33 

Chapter2 
34 
the user, and centers around the notion that the user will expect data to be with 
them, regardless of the location of the source of the data. 
Summary 
In this chapter, I discussed some abstract and concrete opportunities for wireless 
Web developers. Whether you seek relationships with content providers, service 
providers, or both, your work will likely lie in the aggregation of existing content 
and repackaging that content for wireless devices. If you are lucky, you will be 
able to stand the world on its ear with a novel wireless application using data that 
is not presently available on either the wired or wireless Web. 
When you go about defining this content, you will need to weigh the funda-
mentals of wireless development against your content: Remember that users are 
subscribers, not consumers, and that your subscribers are mobile and expect 
their data to be mobile. 
Equally important, you will want to weigh how your subscribers access your 
content, both considering the wireless networks they will use and the devices 
they will carry. Some wireless networks (such as the wireless Web using IITML) 
are well suited to devices that most closely resemble computers, such as PDAs; 
other networks are primarily the domain of telephones, with small screens and 
limited capabilities at low cost that can reach a large audience. 
The wireless market is not about bringing the same content to mobile users. 
limitations of bandwidth, a demand for ease of use, and how wireless devices are 
used all conspire to make the wireless market a new field where all can make 
a mark. 

The 
CHAPTER 3 
Wireless User 
Interface 
DEVELOPING coNTENT FOR THE wireless Web is somewhat like developing content for 
the wired Web during its early days. Although the tools for wireless Web authoring 
are better than the early Web authoring tools, the constraints are similar. The net-
work connecting users to wireless subscribers is slow, the devices lack 
sophistication, and many end users are inexperienced in accessing information 
over a new medium. 
Data mobility-the user's belief that their data resides with them, regardless 
of its origin or means of transport-revolves around bandwidth (the rate of infor-
mation transfer). Bandwidth is a scarce commodity over today's wireless 
networks, and relative to wired networks, will remain so for the near future. 
Although the term bandwidth is usually reserved for technical discussions of 
data rates, it equally applies to the discussion of user interfaces. Your users will 
access your content in many different situations, and the user's attention is not 
dedicated to your content alone. 
When you are on the go, you also have less mental bandwidth-capacity for 
absorbing and processing content-than when you are at your desk. It is hard to 
keep your eye on the road and on the screen of a handheld device while you are 
driving at 40 miles an hour down a highway off-ramp. 
As a result, you need to craft your content to respect both the physical band-
width limitations-slow data rates, small screens, and limited input-as well as 
the mental bandwidth limitations your subscribers' experience. In this chapter, 
I discuss interface expectations and how you can work to meet those expecta-
tions. Central to your efforts will be the design of effective information 
presentation and collection, topics I explore with you in detail. 
Meeting User Expectations 
Users will have high expectations of wireless sites. Unfailing reliability, speedy 
operation, and ease of use will be of paramount importance. 
35 

Chapter3 
36 
Latency 
To a user, any service delay can be annoying. Fortunately, most users will under-
stand that the fulfillment of a wireless query takes time. Users will recognize that 
some amount of delay is inevitable, if only because they have become accus-
tomed to delays across all Internet services. 
Room for flexibility exists regarding users' expectations because users recog-
nize the convenience factor attached to wireless services and are willing to trade 
some speed for it. Most users want access instantly but will typically wait up to 10 
seconds for it; the number of users willing to wait for longer periods, however, 
quickly diminishes. In short, faster is always better. 
Traditional Web users have learned to become patient with sluggish content 
access over modem lines, especially those lacking high-speed connections at the 
office or elsewhere. They deal with it by rationalizing ("Well, it is downloading 
a big picture"), killing time (waving the cursor around the screen, sipping some 
coffee, balancing a checkbook), or avoiding a site altogether ("I do not really go 
there much; it is too slow."). Wrreless users tend to skip the first two coping steps 
and move straight to avoidance. 
Developers cannot do much to directly influence latency (the delay between 
the request and the response or between the exchange of individual data pack-
ets) on a wireless network or improve network performance. They can, however, 
unwittingly increase latency, stretching the time it takes to access a page to sev-
eral minutes and thereby making a wireless Web page virtually unusable to most 
viewers. 
Some browsers will refuse to render any content until a large percentage of 
the page is available, blurring the distinction between throughput (discussed 
next) and latency in the mind of the user. Users cannot distinguish between how 
long it takes the request and response to occur, drawing the page and entertain-
ing the user, and how long it takes the entire page to appear. 
Because of this, you should design small pages and format them so that 
a minimum of memory and computing horsepower are necessary to render them 
fully. Small is a relative term here, depending on the network being used and the 
device responsible for rendering the content. From a user's perspective, single 
screens are ideal and a good compromise if you want to achieve decent perfor-
mance over a variety of networks. In general, individual documents should be no 
bigger than one or two kilobytes; images should be as small as possible while 
retaining their meaning. Text should be concise, clear, and formatted simply. (I 
explore formatting in more depth later in "Creating User-Friendly Content.") 
The issue of latency has already reared its ugly head in some networks that 
implementWAP. Although digital, these networks use a circuit-switched mecha-
nism when handsets access the Internet, causing a noticeable delay when 
starting the Wrreless Application Protocol (WAP) browser. Worse still, because 
network providers bill based on usage time and not data transfer, these handsets 

The Wireless User Interface 
drop the established circuit quickly to reduce operating costs. Consequently, the 
handset may need to reconnect to the network and establish a new circuit for 
Internet access repeatedly throughout a browsing session, incurring frustrating 
delays during each reconnection. Although you cannot control this kind of per-
network activity, you can structure your pages to minimize the need to reconnect 
to the network. 
Throughput 
Given the relatively large number of users competing for limited wireless 
resources, any given user's traffic occupies a small part of the total channel. 
Consequently, a handheld device remains idle for a length of time between the 
transmission and reception of data. Apparent throughput (how much data 
appears to be exchanged, as opposed to throughput, which can be measured by 
looking at the average amount of data exchanged over time) on a wireless net-
work is largely a function of per-packet latency. If wireless terminals were 
equipped with lights such as modems have, users would be able to see a request 
go out and a response come back as two discrete operations. Although individual 
packets coming and going will not be visible to the user (most browsers do not 
render on a per-packet basis), the impact of these delays will be, as the apparent 
throughput is slow. 
Implementation issues force most wireless networks to have staggeringly 
long inter-packet times relative to wired networks, often extending to tenths of 
a second. Although wireless network stacks deal with these delays efficiently, the 
applications that use these stacks do not readily manage them. Most mobile 
browsers, for example, do not render images until the entire image is fully 
loaded. Other browsers, in the interest of conserving memory and computational 
efficiency, do not perform text layout until large portions of the page have been 
loaded. Thus, a high-throughput wireless network with relatively high latency 
may appear to be a low-throughput, high-latency network to the client applica-
tion and users. 
Controlling page length through appropriate formatting, presenting infor-
mation piecemeal rather than in one big chunk, and using images judiciously 
can help advance the perception of high throughput. 
Designing the User Interface 
User interface design for a Web page may seem like a superfluous concern. After 
all, isn't the user interface for a Web page largely supplied by the browser's user 
interface? Yes and no. 
37 

Chapter3 
38 
As any experienced Web developer knows, you can do a lot within the 
markup language to establish a look and feel for a particular site. Images, fonts, 
the application of text styles, word choice, and colors all impact the perception of 
your site. These factors contribute to a specific user interface that complements 
the site, or they can make a site much more cumbersome to use than it 
should be. 
Generally, each wireless hardware platform has a browser released by the 
platform vendor and at least two competing browsers written by third-party 
developers. Many browsers on wireless devices are essentially full-screen appli-
cations, with few menus, icons, or other adornments. Vendors must keep the 
interface to the browser simple to make the best possible use of limited screen 
space; similarly, wireless content demands simple page designs. 
Therefore, Web sites viewed on a wireless device play a larger role in defining 
the interface than would sites viewed on a full-sized computing device. An 
extreme case of this occurs with WAP, where the browser on many screen phones 
has no interface of its own, and on many of these devices the browser dominates 
the entire display while running; 
Fonts 
Although HyperText Markup Language (HTML) provides the ability to dictate 
which among a number of fonts the browser should use to draw a page, Wrreless 
Markup Language (WML) does not. Moreover, HTML browsers on many hand-
held devices do not have the rich set of fonts available on desktop computers. 
Your best bet is to stick with the default fonts selected by the device and user. 
Most platforms will pick a default font that users will find readable in various 
settings. Some Personal Digital Assistant (PDA) browsers will even allow the user 
to pick a default viewing font by choosing a size from a list of small, medium, or 
large, with the browser selecting an appropriate font to match. Most users will 
expect the browser to explicitly follow their font selection, rather than content 
choosing its own font, especially when their selection is appropriate to the oper-
ating environment. 
Even using fonts by name on platforms with multiple fonts can cause prob-
lems. Fonts with the same name may be different from device to device, and the 
same font used on multiple devices may lead to drastically different output 
depending on the font directives. This can negate the desired effect of a site's 
specific look and feel. 

The Wireless User Interface 
Scrolling 
On a desktop, most of the time, users will not even think about the scrolling 
operation, especially if they are viewing large screens with maximized windows 
because the scrolling action happens comparatively rarely. This is not so on 
a wireless device, where scrolling is a necessary evil. 
Most handheld devices have screens smaller than 400 pixels tall, half of 
to day's smallest desktop displays. Many of the most popular handheld devices 
are half again as small, and most screen phones have even smaller screens. 
Consequently, you need to scroll far more with a mobile Web browser than with 
your desktop's browser. Create short pages and you keep the need to scroll to a 
minimum. 
User Input 
Mobile users will not want to bother with a lot of input at most sites, given that 
inputting can be slow, tedious, and awkward on most small devices. Users will 
expect to be able to input text rapidly and with minimal delays. 
A common mistake is to prompt the user with an input line when a more 
specific means, such as selecting an item from a choice, is equally appropriate. 
For example, it is easier for a user to pick a state from a list than enter its name. 
The judicious use of specific input types, in addition to controls such as lists and 
radio buttons, can significantly decrease the amount of input the user has to per-
form. Some browsers, such as the Palm Powered Web Clipping browser, support 
specific input types for sophisticated data such as time and dates, invoking oper-
ating-system-specific dialog boxes for quickly entering information. (I will look 
more closely at Palm's Web Clipping Architecture in Chapter 9, "Palm-Powered 
Web Clipping Applications.") 
Creating User-Friendly Content 
There is more to creating user-friendly content than just trial and error. What fol-
lows are some general guidelines for creating content suited to your subscriber's 
needs. In Chapter 4, "The Wrreless World Wide Web," I will look closely at these 
issues for HTML developers, and in Chapter 12, "Wireless Markup Language," 
I will talk about these in detail for WML developers. 
39 

Chapter3 
40 
Using Images Wisely 
The old adage about a picture being worth a thousand words does not always 
apply to the wireless Web when you consider the cost of delivering the images. 
Plus, many "pictures" on the Web are not illustrative-they merely divide a page 
into sections, add some color or background patterns, or just provide a particular 
look and feel. Many Web sites have adopted the trick of using "empty" images as 
spacers, and others use image maps (graphics with embedded hyperlinks that 
allow users to click a region of the image to navigate to a new page) with text in 
special fonts to ensure a distinctive appearance. 
Virtually none of these embellishments work for wireless content. Many 
handheld devices have grayscale screens, and even color displays do not provide 
the same contrast quality as desktop displays and laptop screens. Users will 
view content displayed on handhelds in a variety of lighting, which can add to 
the contrast problem. More importantly, however, than the visual problem is the 
simple fact that images take precious time to load and display. 
Your content should employ images sparingly. Confine their usage to those 
times when you need to make an important point or when an image is a more 
efficient use of screen space than text. Some other guidelines to keep in mind 
include the following: 
• Images used for branding and advertising should occur rarely if at all 
because what might look appropriate on a desktop is often a messy 
smudge on a handheld. Complicated logos, or those that rely on color to 
promote recognition, rarely scale well to the screens used in these devices. 
• Images should be high contrast, preferably rendered in black and white (or 
in colors that appear to be black and white when viewed on monochrome 
devices). Line drawings without gray shading are ideal, as are simple block 
drawings. 
• Images should be as small as possible for the content they need to display. 
• Generally, the largest images should be no more than 50 percent of the 
device's target display area; selectable images (used as links, for example) 
should be in the neighborhood of 16-by-16 pixels in size. (Touchable on-
screen items are an exception to the "as small as possible" rule. Most users 
have difficulty selecting items on an average touch screen that are less than 
16 pixels wide.) 
• Where icons are appropriate, make sure they are simple and clear. Avoid 
rectangular icons, which users can easily misinterpret at a glance as 
characters on a display. 

The Wireless User Interface 
Figure 3-1 shows a sampling of icons suitable for use with a black -and -white 
client device. For color devices, you could add bold colors, if used sparingly. 
Figure 3-1. A selection of graphics suitable for a monochrome device 
These guidelines also apply to image maps. Although some mobile Web 
browsers support image maps, WML devices do not, and navigating multiple 
image maps will be prohibitively tedious and expensive for the average user. 
Although an attractive feature on a desktop device, image maps quickly become 
a nuisance on a mobile one. One exception is a user interface metaphor that 
makes navigating with images necessary, such as when maps are being dis-
played. But even when navigation through an image map is appropriate, 
using images for panning, scrolling, and zoom selection around the border of the 
image is not. 
Some Web browsers allow users to select whether images are downloaded, 
but a wireless content provider who gives the user this choice is looking for trou-
ble. A page designed around graphics inevitably falls short when viewed as 
a text-only page. Nothing is more aggravating to a viewer than discovering much 
of the content of a page is buried in graphical content. Almost as irritating for this 
user is to have to sift through dozens oflittle browser-supplied graphic icons 
representing images that were not downloaded indicating that if he or she down-
loads these images, the page might actually make sense. It is far better to design 
a spartan site with few graphics to begin with and then let the user decide 
whether the graphics you have selected are worth the download time. 
When reworking an existing page for wireless access, there is an irresistible 
temptation to recycle existing graphics, especially icons and diagrams. Do not do 
it! Most graphics simply do not look that good after they have been dithered and 
scaled, even by an artist. More importantly, do not be taken in by the siren's song 
of automated translation. Two strategies have appeared on the market: software 
packages you can run over the images from your site or proxy servers designed to 
provide mobile access to desktop images for handheld devices. These technolo-
gies were designed to be applicable to a variety of sites and images, and your 
content will inevitably suffer unless you invest the time to redo your graphics 
from scratch. 
41 

Chapter3 
42 
Writing Concisely 
Brevity is key. Subscribers appreciate a concise presentation of the information 
they need. Keeping everything short and sweet ensures that a minimum of 
content is delivered to the viewer. 
Sentences should be simple and vocabulary clear. Avoid run-on sentences, 
subordinate clauses, and the other sorts of things your English teacher did not 
like. Never use a long word when a short word will do. Examine respected news-
papers or news magazines for examples of clear, succinct prose; it is a style that 
will be familiar to your readers. 
Formatting for Readability 
You should place the most relevant information at the top of a document 
because readers will not want to scroll to get what they need. This is especially 
important for screen phones in which the display area is limited to a few lines. 
This generally precludes the use of banners and large headings for pages, and it 
poses an additional challenge for those trying to use advertising as a revenue 
source. 
Keeping It Short 
Pages should be brief. Short pages not only reduce the need to scroll, but several 
small pages may load more quickly than a single long one. Small pages also 
require less memory for the browser to format and display and are more likely to 
work on a variety of devices. 
How short is short? To some extent, that depends on the platform. Palm 
Powered wireless devices, for example, work best with pages having a few hun-
dred characters or less. This relatively small amount of information displays on 
a single screen without scrolling. Equally important, the proprietary wireless 
scheme used by Palm's browser can compress these small pages into one or two 
wireless packets, significantly reducing the time a page takes to load (and 
decreasing user cost). 
By extension, screen phones will accommodate even less information at 
a time, sometimes as little as 100 characters or so. On the other hand, super 
phones and PDAs may perform adequately with pages containing 1,000 charac-
ters, depending on screen size, formatting, and the nature of the information 
being displayed. 

The Wireless User Interface 
Using Tables 
You should use tables for creating tabular material and not for general-purpose 
formatting. Presenting a weather forecast, providing a stock quote, and summa-
rizing important information are all excellent uses of tables; using a table to 
create two columns of text or flow a paragraph around an image is not only an 
abuse of the table markup commands, but it generally will not have the effect 
you seek. 
Keep tables simple and use as few columns as possible by ensuring that the 
table only presents pertinent information and by breaking tables into multiple 
tables if they stretch more than two or three columns. On a narrow display, 
a wide table may end up badly formatted or incomprehensible. 
Most importantly, avoid nesting tables; not all wireless browsers support 
nested tables, and even those that do often render them poorly. 
Letting the Browser Do Its Job 
Do not second-guess the browser. The host of mobile devices makes writing 
device-independent content an even more important consideration than when 
you are writing for the Web. Keep the material simple, concentrate on providing 
the information, and let the browser do its job in interpreting markup tags in 
a way that is appropriate for the device. Attempting to coax a particular layout or 
alignment using browser tags not only needlessly increases the size of a page, it is 
a waste of time for the user and guaranteed to fail more often than it works. 
Other Tips 
You can do a number of other things Oust as you would in print) to promote 
readability: 
• Group related items together. 
• Avoid using more fonts and typefaces than necessary. In general, allow the 
viewer to select fonts, rather than using font directives to change the font. 
Also, use boldface and italic text sparingly. 
• Do not abuse the markup language. Pages with complex markup tend to · 
look cluttered and not too useful. 
43 

Chapter3 
44 
• Use color sparingly, and remember that many readers will not have access 
to a color screen. 
• Use numbered or bulleted lists to provide a series of steps, rather than 
individual paragraphs. Lists allow you to group related material tightly 
while keeping listed items clearly separate. 
Choosing Input Methods 
Many kinds of wireless content will require textual or numeric user input. For 
some sites, such as a dictionary or thesaurus site in which the user enters a word 
and-presto!-a definition appears, input is mandatory. Other sites, such as 
weather or travel guides, may require input at some entry points (for example, 
when looking up a review of a specific restaurant) but not at others (a list of 
regions with restaurants). Sites requiring user input present a special challenge 
for the wireless designer. 
Many devices will have numeric keypads, requiring a tremendous amount of 
finger gymnastics to spell even a short name. So, wherever possible, you should 
use buttons and pick lists in place of input text fields. 
Making Choices 
Menus-often called pick lists-are an excellent alternative to keystrokes when 
you know ahead of time what the choices are. When designing your menus, keep 
the number of choices short because most users on the go will be able to keep 
only six or seven items in their short-term memory. Short lists also eliminate the 
need for scrolling. 
Entering Text 
For many sites, some amount of text entry will be inevitable. 'fravel and naviga-
tion sites require destinations, dictionaries require words, and financial sites 
require stock ticker symbols. 
In cases where you must force the user to enter something, see if you can 
perform validation on the client side to eliminate unnecessary wireless transac-
tions. Markup languages such as WML offer input attributes that let you restrict 
input to a specific number and kind of characters. Even with HTML, you can help 
reduce the likelihood of user error by limiting the size of input fields to the num-
ber of characters in the input. 

The Wireless User Interface 
Entering Locations 
Input regarding current locations and destinations provides interesting opportu-
nities for the content developer. 
When designing a site that includes a positioning mechanism, ask yourself 
whether information on a user's current location is really necessary. For example, 
a navigation aid may want the cross streets nearest to the user, and a weather 
forecaster may only need a city name or zip code. As devices begin to meet the 
FCC's E911 initiative (which requires all wireless networks be able to locate 
a handset user to within 3 meters to be able to dispatch emergency vehicles 
when you dial911 on your handset), position data should be available directly 
from the handset, and you should not have to ask the user their location at all in 
many cases. 
A ZIP code is often the best compromise for location information. It is short, 
easy to enter, and usually available even when the user is not familiar with his or 
her current locale (hotel stationery, for instance, can supply the current ZIP 
code). Unfortunately, this method may not work if the traveler does not have the 
ZIP codes of the travel destination handy. A good compromise is to enable the 
user to enter either a ZIP code or a city name, as shown in Figure 3-2. As the fig-
ure depicts, you should do your best to keep the required input to a minimum 
such as the city name in Figure 3-2a, followed by the list in Figure 3-2b, rather 
than require the user to enter all of the city name, country, and postal code. The 
wireless Web is no place to force the user to enter unnecessary information. 
WeatherS off 
Foro r*91ond weothlr' forKon, 
ntertlther 
or 
Gty ,Stote!~~~!!::J 
!Wt:Gt:ht:rSuff 
ou tntt:rtd San Jose.. P~ose 
elect either 
~on .10~. (A (USA 
~on Jo<•(CortoRko} 
Figure 3-2. Optimizing user input for location finding 
Check Boxes 
Check boxes work well when the user must choose from a number of options. 
Few Web sites currently use free-form input when check boxes will do the job 
(who wants to spend extra time writing those back-end CGI scripts anyway?). 
This design consideration is even more important with wireless devices. Check 
boxes tend to be easier to use than multiple-pick lists, especially on a device that 
may lack a Shift key to indicate multiple selections. 
45 

Chapter3 
46 
Buttons 
Buttons provide an opportunity for the wireless content developer to get creative 
and emulate a device's native interface. Many handheld wireless platforms present 
a software developer with a steep learning curve or no Software Development Kit 
(SDK) at all. (See Chapter 9, "Palm-PoweredWeb Clipping Application," for a dis-
cussion of writing native applications for wireless platforms that provide SDKs). 
On wireless platforms with an SDK, writing a dedicated wireless application 
can become prohibitively expensive -especially if your goal is to support more 
than one wireless platform. Buttons on Web pages provide one mechanism for 
making a wireless site look more like an application than a Web site. Coupled 
with WAP and technologies such as WMLScript, buttons provide a Web site with 
a look and feel that is more native to the platform. 
Placement of controls presents an interesting challenge for many content 
developers. In general, layout languages will not allow you to provide exact place-
ment information for text or controls. However, if you are targeting specific 
platforms, you may find that you can obtain some control over the screen layout 
through careful editing of content. 
Touch Screens 
Most devices will employ a touch screen that the user operates with a fingertip or 
a stylus. Remember that, unlike with a mouse or graphics tablet, the user's inter-
action with the device will obscure a large percentage of the display. Therefore, 
buttons should be located underneath any relevant text, allowing the user to see 
information while making a selection. Most users cannot accurately select 
regions smaller than 16 pixels on a side; some browsers may size buttons 
intelligently, and others may not. 
Validating Content 
The key to meeting user expectations is envisioning your content from the per-
spective of the reader. This is not a new idea; site developers have been 
previewing their Web sites for years. Remember, however, that the range of wire-
less devices on the market is wide. If you are developing a site aimed at a couple 
different kinds of devices, it is well worth the expense to obtain those devices and 
begin regularly previewing content on both of them. 

The Wireless User Interface 
Simulating the Viewer's Environment 
Whenever possible, try to access your content in the same way your subscribers 
will. There is little point in measuring the performance of your site on a desktop 
browser with your Ethernet Local-Area Network (LAN) if you will be deploying 
a Cellular Digit Packet Data (CDPD) wireless solution using a Windows CE hand-
held computer. 
In some cases, accurately simulating your subscriber's environment will be 
difficult or impossible. When developing general sites, for instance, it may not 
be possible to assemble the full assortment of devices your clients will be using. 
In other cases, you will find that the network you plan to deploy over is not avail-
able in your area; the availability of CDPD is a case in point in which the mix of 
strong metropolitan coverage and weak rural coverage can cause problems for 
developers. 
Ironically, resurrecting old technology provides a good approximation of how 
the latest in wireless technology might work. To emulate most handheld Web 
browsers, you can use an early Web browser (Netscape 2.0 works well) and a slow 
LAN connection, such as the 9.6KB or 14.4KB modem you could not give away at 
your last garage sale. (Or, rather than dumpster-diving for that precious modem, 
you could adjust your computer's baud rate on the appropriate serial port.) Using 
older software helps when you examine sites for dependence on scripting, non-
standard tags, and certain image formats, and the slower modem simulates your 
user's connection speeds. 
Examining Display Parameters 
When using your browser to preview your work, set your display to no more than 
256 colors, or grayscale if applicable. You may want also to deliberately pick 
a poor contrast for your monitor to simulate the displays present on many 
devices. Adjusting the brightness and contrast controls on your monitor to simu-
late poor screen contrast may seem like a step backward for development, but it 
is for the greater good of your users. Also, be sure to scale your browser window 
to approximate the size of the target screen. 
Table 3-llists some common display parameters for wireless clients. Note 
that most browser applications take up 30 to 40 pixels of space along the top and 
bottom of the display for status and other information; this margin is not 
reflected in the numbers shown in Table 3-1. 
47 

Chapter3 
48 
Table 3-1. Typical Display Parameters for Wireless Clients 
DEVICE 
SCREEN SIZE 
SCREEN COLORS 
Screen phone 
12 characters x 4lines 
Monochrome* 
Palm Powered 
160x160 pixels 
4 shades of gray, 16 bits color 
handheld 
Handspring Visor 
160x160 pixels 
4 shades of gray, 16 bits color 
Sony Palm Powered 
320:x320 pixels 
16 bits of color 
handheld 
Microsoft Pocket PC 
320:x320 pixels 
16 bits of color 
• Minimal functionality as defined by the WAP Forum. Note that the soft buttons at the bottom 
of the display consume one of these four lines. 
Summary 
As you have doubtless gathered by now, the watchword for successful wireless 
Web development is brevity. Keeping pages short will help both objective and 
subjective perceptions of your content. The page will not only be easier for the 
viewer to read, thanks to its brevity and uncluttered appearance, but will also be 
more pleasing to view. 
You should use images sparingly, if at all, because they cannot be displayed 
by all platforms and consume a large amount of bandwidth. In no case should 
you use image maps because when you do, viewers without image display cannot 
navigate the links on your site. 
You will want to create your pages with a minimum of type fonts and styles 
so that it will appear correct on the widest number of wireless access terminals. 
This, along with brief content, will also help minimize scrolling, a source of frus-
tration for many users because of the small screens on most devices. When 
formatting your content, use markup commands sparingly, and preview often on 
the kinds of devices your viewers will use. 
User input poses challenges for many users. You should avoid prompting 
users for input unless absolutely necessary; whenever possible, give users 
a choice of items rather than having them resort to plinking in names, addresses, 
or other information. 

CHAPTER 4 
The Wireless World 
Wide Web 
WHETHER YOUR WIRELESS APPUCATION uses HyperText Markup Language (HTML), 
Wrreless Markup Language (WML), or cHTML (compact HTML), and whether it 
uses Wrreless Application Protocol (WAP), or i-mode, its foundation lies in today's 
Web standards. Navigating this sea of technology is not difficult. In fact, often 
a few landmarks suffice to get you to your destination. 
This chapter gives you a rough chart you can use in planning your voyage. 
Because an understanding of the fundamental Web technologies-HyperText 
Transfer Protocol (HTTP), HTML, and image formats-is crucial to understand-
ing their application in the wireless Web, you should skim this chapter even if you 
have developed Web content before. 
Reviewing Web Standards 
The power of the World Wide Web lies in its open, documented standards for the 
sharing of information. These standards describe how data is formatted and 
exchanged between different computers, enabling virtually any computer to 
access the information on any server connected to the Web. 
Before I discuss how to use the Web to distribute content to wireless devices, 
a brief review of the Web standards and their use in wireless Web development is 
in order. HTTP is widely used to exchange data between computers, and HTML, 
the Graphical Interchange Format (GIF), and the Joint Photographers Expert 
Group (JPEG) format are commonly used to specify data formats for kinds of 
content. There are also standards for security between hosts and for specifying 
scripting behavior, both of which I touch on briefly. 
HTTP 
HTTP is the backbone of the Web. Sitting atop the Transport Control 
Protocol/Internet Protocol (TCP /IP), Web clients and servers use it to exchange 
data around the world. This protocol builds on the concept of the Uniform 
49 

Chapter4 
50 
Resource Locator (URL) to specify documents within the protocol called objects. 
An object can be any aggregate stream of bytes-an HTML page, an image, 
a sound, or an application-specific blob of data. Common objects include Web 
pages (written in HTML), responses to forms from the client (commonly called 
form data), and image data. 
A unique URL identifies each object (for example, http: I lwww. apress. com/ 
CatalogMain. htm). A URL is a concatenation of the protocol used (http: I I), the 
name of the host serving the document (such as www. apress. com), and the path 
and filename of the document being served {!Catalog/ is the directory, and 
CatalogMain. htm is the document being requested). URLs serve as arguments to 
methods, which are plain-text keywords instructing the HTTP server to do some-
thing on the client's behalf. 
HTTP defines a handful of methods. These methods include GET and HEAD, 
which the client can use to get an object or information about an object. Other 
methods, such as POST, let a client submit new data to the server for processing 
or storage. 
Clients and servers modify the method using a header, which precedes the 
object. Headers identify the client and server, and they enable the client or server 
to give additional instructions. 
Unlike older protocols, HTTP is largely human readable. Requests and their 
URLs are written in English, and the accompanying headers are also in English 
using a tag/value format where the tag and value are separated by the colon (:) 
character. 
listing 4-1 shows a sample HTIP exchange between a client and server that 
shows both the header and object. 
Listing 4-1. An HITP Exchange 
GET /hello.html HTTP/1.1 
Host: ryoko.lothlorien.com 
Accept: text/html 
Accept-Language: en 
Accept-Charset: IS0-8859-1, UTF-8; Q=0.8, IS0-10646-UCS-2; Q=0.6 
Connection: Close 
HTTP/1.1 200 OK 
Date: Wed, 06 Sep 2001 03:18:25 GMT 
Server: Apache/1.3.12 (Unix) PHP/4.0.1pl2 
Last-Modified: Wed, 06 Sep 2001 03:15:22 GMT 
ETag: "fb1c-1b0-39b5b6ca" 
Accept-Ranges: bytes 
Content-Length: 45 
Connection: close 

The Wireless World Wide Web 
Content-Type: text/html 
<html> 
<body> 
<p>Hello world!</p> 
</body> 
</html> 
In this example, you see the client requesting the document hello. html on line 
1 using version 1.1 of HTI'P. This is a HTTP GET request. The headers from the client 
follow the GET request, up to and including the blank line ending the headers. These 
headers specify the host name that has the document (ryoko .lothlorien. com), that 
the client prefers HTML in English according to a specific character set (IS0-8859-
1), and that the server should close the connection after responding. 
The server's reply contains several headers as well as the object, the docu-
ment at http: I /ryoko .lothlorien. com/hello. html. The server provides the date 
at which the request took place, the server's software, the last time the document 
was modified, and a unique tag for the document, as well as the document's 
length, format, and an acknowledgment that the server will close the connection 
after sending the document. (As you will learn in an upcoming section, clients 
and servers use the unique tag to help caching, which minimizes the need for 
clients to download a new document.) 
Most of the time, you do not need to worry about the nuts and bolts of HTTP 
like this. You do, however, need to understand the difference between two kinds 
of requests the client can make and headers. Let's take a closer look. 
HTTP Methods 
The two methods-operations invoked by HTTP clients in a request-most com-
monly used by HTTP are GET and POST. As you can probably guess, HTTP clients 
use GET to obtain the object associated with a given URL, and they use POST to 
submit an object to the server. 
The previous section showed a typical GET request, consisting of the object's 
URL. Some Web applications also use the GET request to send short bits of form 
data, rather than the POST method and a separate object body. When an appli-
cation does this, a question mark follows the URL, and then any form data 
separated by semicolons, like this: http: I I search. a press. com/ 
query. cgi ?author=rischpater; ti tle=wwd;. Form data is generally a set of 
name/value pairs, one value for each named field in the form. 
As a content developer, you face the choice of whether to use GET or POST 
when handling data submission from the client. Generally, you use POST: It is 
newer, supports larger data sets, and is easier to handle on the server. 
Occasionally, it is easier to use GET, especially early on in developing a Web appli-
51 

Chapter4 
52 
cation where you simply want to pass a handful of values back to the server to 
test a script. 
Regardless of which method you choose, you specify it in the markup lan-
guage. As you will see in subsequent chapters, it is the method argument to the 
<form> tag in HTML, and the method argument to the <go> tag in WML. 
HTTP Caching 
Mastering the art of caching content is crucial to developing well-behaved wire-
less Web applications. A wireless Web browser has a cache, a region of memory it 
uses to store recently fetched documents in case you want to view one of them 
again. By looking first in the cache for any document you request before going 
over the air, the browser can eliminate the need to make a request, saving you 
time and money. 
To accomplish this, HTTP includes several headers that describe the object 
and how it should be cached. As you write a Web application for the server, your 
application must specify appropriate values for these headers to enable clients to 
make the best use of their cache. These headers include the document's modifi-
cation date (the Last-Modified header), when the document expires (the Expires 
header), and whether you want to override the default caching mechanism (the 
Cache-Control header). 
By default, most HTTP servers include the Last-Modified header, setting its 
value to either a static file's last-modified date or the time at which the server ran 
the script responding to the request. By including the Expires header-either 
with a directive in your markup or via a server-side script-you tell the client how 
long a document should remain in its cache. Because static content may not be 
able to specify an expiration date, but only an age until content expires, you can 
also use the Cache-Control header, selecting a maximum age for the document. 
(As you will see in subsequent chapters, the Cache-Control header specifies 
a maximum age in seconds.) 
XML 
Another markup language is the eXtensible Markup Language (XML). XML is 
a generalization of the concepts behind HTML, letting you define tags that 
describe your content, rather than its appearance. Using XML, you can create 
content that other applications can read, letting applications actually determine 
how best to present your data. 
XML offers unprecedented flexibility in marking up your data because with 
XML you can define your own tags that describe particular bits of information. 

The Wireless World Wide Web 
For example, Listing 4-2 shows a bit ofXML that describes a temperature reading 
and forecast at my house. 
Listing 4-2. The Weather at My House 
<?xml version=" 1. o" ?> 
<WEATHER> 
<LOCATION> 
<WHERE>Boulder Creek, CA</WHERE> 
<ZIP>95006</ZIP> 
</LOCATION> 
<REPORTED> 
<WHEN><DATE>11/25/2001</DATE><TIME>14:00</TIME></WHEN> 
<TEMPERATURE units="Centigrade">17</TEMPERATURE> 
<BAROMETER units="kPa">102.5</BAROMETER> 
<HUMIDITY>65</HUMIDITY> 
<WIND><SPEED units="m/s">1.8</SPEED><DIRECTION>270</DIRECTION></WIND> 
<PRECIPITATION units="mm">O</PRECIPITATION> 
</REPORTED> 
<FORECAST> 
<WHEN><DATE>11/26/2000</DATE></WHEN> 
<PRECIPITATION_PROBABILITY>.10</PRECIPITATION_PROBABILITY> 
<NWS>A small system will move in during the afternoon, 
leading to partly cloudy skies with a chance of showers 
in the evening. Temperatures in the high teens. 
</NWS> 
</FORECAST> 
</WEATHER> 
Even if you do not know XML, several things are immediately apparent: 
• XML tags look like HTML tags: They are contained within brackets ( < and 
>) and are paired to surround a datum. 
• A datum captured by an XML tag is in human-readable text. 
• Some tags, such as the <TEMPERATURE> tag in Listing 4-2, have additional 
attributes that further describe a datum. 
• An XML tag describes a datum, not how it should appear. Consider the tags 
in Listing 4-2: <LOCATION>, <ZIP>, <WHEN>. 
53 

Chapter4 
54 
Designers use XML to develop both domain-specific markup languages such 
as Math Markup Language (MathML) and more traditional markup languages 
such as the WML (discussed in Chapter 12, "Wireless Markup Language"). In fact, 
the World Wide Web Consortium (W3C) has adopted XML as the standard for 
developing HTML, resulting in a new version of HTML called XHTML that uses 
XML to describe Web page markup. I discuss the mobile flavor ofXHTML, 
XHTML Mobile Profile, in Chapter 11, "Wireless Application Protocol," when 
I examine the WAP. 
Chapter 7, "eXtensible Markup Language," describes XML in greater detail. 
HTML and XHTML 
You are probably already familiar with HTML. In this section, I discuss the gen-
eral aspects of HTML, and in Chapter 8, "HyperText Markup Language, the 
Wireless Way," I look closely at which HTML markup commands are appropriate 
for wireless Web developers. 
It is important to realize that HTML markup implies a set of guidelines, 
rather than hard-and-fast rules about how a document should appear. For exam-
ple, the <B> directive hints to the browser that content so marked should stand 
out in some way. The fact that browsers choose to use a bold font is a largely his-
torical one. Good browsers, especially good micro-browsers on wireless devices, 
use this flexibility to their advantage, and weigh markup requests with device 
constraints. Consequently, some browsers may ignore certain markup tags 
because they have no way to support the markup requested. 
An HTML document consists of American Standard Code for Information 
Interchange (ASCID text interspersed with tags that instruct the client as to how 
the viewer should format the text. Tags come in pairs surrounding the text they 
apply to, and are set off using angle brackets ( < and >). The first tag of the pair 
is generally a description of the operation to be performed, and the ending tag is 
the same term preceded by a I. 
Here is a simple HTML file: 
<HTML> 
<HEAD> 
<TITLE>Hello, Worldi</TITLE> 
</HEAD> 
<BODY> 
<P>Hello, world!</P> 
</BODY> 
</HTML> 

The Wireless World Wide Web 
Every HfML document begins and ends with the <HTML> tag, indicating that 
this document is marked up with HTML. A document consists of an HTML head-
ing, enclosed within starting and ending <HEAD> tags, and a body, enclosed within 
starting and ending <BODY> tags. (The HfML heading should not be confused 
with the HTTP header; it is an integral part of the HTML document, rather than 
part of the HTTP protocol.) Clients use the HTML heading to set the title of 
a window, the window size, and so forth; the body contains the actual Web con-
tent to be displayed. 
The sample HfML document uses the <TITLE> tag to specify a window title, 
and the < P> tag to indicate the beginning and end of a paragraph, which in this 
case says simply, "Hello, world!" HTML is versatile: There are tags for selecting 
fonts, sizes, and styles; tags to create bullet and auto-numbered lists; tags that 
can include images and sounds with a document; tags for tables; and tags for 
constructing pages consisting of several frames, calledframesets. 
If you are wholly unfamiliar with HfML, I suggest you take a break from 
reading this chapter and learn a little more about it. There are several good ways 
to do this: 
• Visit the W3C Web page about HfML, at http: I lww. W3. org/MarkUp/Guide/. 
• Search the Web (a Yahoo! search works wonders) for introductory HTML 
pages and read a few. 
• Get your hands on a free What-You-See-Is-What-You-Get (WYSIWYG) edi-
tor for HTML, such as Netscape Communicator. Write some pages in it, 
then use its View Source command to see the HTML it generated. You can 
edit the source by hand (using any text editor), and preview it with a Web 
browser to see what your changes do. Experimentation is the best way to 
learn how tags behave. 
In Chapter 8, "HyperText Markup Language, the Wrreless Way," I walk you 
through many of the common HTML tags as they apply to the wireless Web. If 
you are a quick study, that may be all you need to get started marking up HTML 
content. 
XHTML is quite similar to HTML; in fact, unless you look closely, you might 
not be able to tell the difference. For example, this is the previous listing shown 
inXHTML: 
<?xml version="1.0"?> 
<HTML> 
<HEAD> 
<TITLE>Hello, Worldi</TITLE> 
</HEAD> 
55 

Chapter4 
56 
<BODY> 
<P>Hello, world!</P> 
</BODY> 
</HTML> 
You can see one difference: The XHTML file begins with the tag < ?xml ?>, 
which specifies the version ofXML this file uses. In fact, that is the largest change 
for many well-formed HTML files; XHTML tags are HTML tags. There are three 
other key differences you should be aware of: 
• In XHTML, as in XML, empty tags such as <BR> must be written specially 
usingXML's <I> nomenclature, like this: <BR/>. 
• XHTML tags are case-sensitive. <P> is not <p>, and perhaps more impor-
tantly, <IP> does not close a paragraph begun by <p>. 
• Paired tags such as <P> and <IP> cannot have empty content. 
XHTML has two clear advantages over HTML. First, the grammar is consis-
tent, making it easier for software to interpret a page's markup. This reduces 
mistakes, ensuring consistent formatting across a site. Second, because its gram-
mar is consistent and well defined, platform developers can define arbitrary 
subsets ofXHTML for their own use. One platform, i-mode, does just that, using 
cHTML, a subset ofXHTML complying with HTML, as its markup language. I will 
talk more about cHTML in Chapter 10, "i-mode Applications." 
GIF 
GIF, developed in the 1980s by the CompuServe network, is the workhorse of 
Internet graphic formats. GIF is the mainstay for transferring both simple and 
complex images on the Web. 
GIF is good for crisp line art and general-purpose images. It supports eight 
bits of color data, making 255 colors (and a transparency "color" that can be used 
to make the background of an image transparent) available to the artist. GIF first 
encodes the image as scan lines and then compresses one or many scan lines 
into fixed-size packets, making it ideally suited to the compression ofline draw-
ings and drawings with solid color. 

The Wireless World Wide Web 
JPEG 
The JPEG format was formed to provide high-quality compression for highly 
detailed images such as photographs and satellite imagery. (This format, by the 
way, is actually technically called JFIF by the Independent JPEG Group, which 
stands for JPEG File Interchange Format, but in common parlance so many 
people refer to it as JPEG that I do the same in this book.) The format supports 
higher color depths than does GIF (24 bits of color information, providing up to 
16.8 million colors) and can support multiple images within a JPEG file. Unlike 
GIF, JPEG compression works using color reduction, which takes advantage of 
a peculiarity of the human eye: People are more likely to perceive differences in 
brightness than differences in hue. JPEG records the brightness and hue of any 
given point on an image separately, then reduces similar hues in adjacent pixels 
to the same hue and re-encodes the image using the reduced data. Brightness 
information is preserved, while similar hues are averaged, yielding a reduction 
in image size. This kind of compression is known as lossy because the resulting 
image contains less information than the original. 
The JPEG format enables the artist to choose the amount of color reduction 
that occurs. At greater levels of compression, the color reduction becomes more 
noticeable to the viewer, taking the form of artifacts that appear as blocky boxes 
of slightly off-color pixels. In images that consist of many solid horizontal and 
vertical intersections, these artifacts are only marginally observable because in 
many cases the artifacts will fall along the lines formed by the intersections. On 
the other hand, in complex images with a variety of shapes and lines at nonper-
pendicular angles, these artifacts can be distracting at best and disruptive at 
worst. Pictures with these abrupt transitions that show artifacts when com-
pressed by JPEG are best stored as GIF files. 
The JPEG format can dramatically reduce the space an image occupies with 
little noticeable difference to end users. Its algorithm works best with images that 
contain gradual transitions between colors (such as bitrnapped images from 
photographs), as this is where the opportunity exists to reduce the amount of 
data needed to record the image. For images with a relatively small number of 
solid colors (such as line diagrams or colored cartoons), JPEG fares more 
poorly-the algorithm cannot find hues that can be easily combined, and any 
combining it does may affect the image's quality significantly. 
Other Image Formats 
Other formats for transferring images on the Web abound. The traditional operat-
ing system image formats-Macintosh Picture format (PICT), Windows Bitmap 
format (BMP), andXWindows bitmap format (XBM)-are still supported by 
many Web browsers, although some browsers will only display formats native to 
57 

Chapter4 
58 
their platforms. (The Wmdows CE Microsoft Internet Explorer, for example, can 
draw BMP images, but not XBM or PICT images.) In general, it is best to avoid 
these three formats because they are platform-dependent and not necessarily 
well suited to the compression of images. 
A new format, the Portable Network Graphics (PNG) format is being adopted 
by a growing number ofWeb browsers for desktops. PNG provides patent-inde-
pendent compression (avoiding the potential headaches ofUnisys's claims over 
GIF, for example) and offers some attractive features, including variable trans-
parency, cross-platform control of image brightness, and two-dimensional 
interlacing. (Two-dimensional interlacingenco~es an image in successive layers 
of detail so that as the image is drawn, higher detail becomes apparent as the 
client obtains more data. This gives a user on a low-bandwidth connection the 
perception of a quick-loading image because there is something to watch 
sooner.) However, most of the browsers on wireless devices do not yet support 
PNG, so content developers targeting the wireless market should avoid it for now. 
Interactive Languages 
Interactive languager-Java, JavaScript, VBScript, Macromedia Flash, or the pro-
prietary scripting environments found in some smaller browsers-enables 
developers to create interactive content that runs on the client. Web browsers can 
download and run programs written in these languages. These programs appear 
as part of one or more content pages. Although not protocols per se, their use is 
closely linked to the Web protocols mentioned thus far. 
While desktop Web browsers support both JavaScript and Java, you will be 
hard-pressed to find a browser for a handheld device with similar features. Some 
software vendors-notably OpenTV-offer browsers that support one or another 
of the standard scripting environments, but few hardware manufacturers have 
actually deployed browsers with this level of sophistication because of the hard-
ware costs of running a browser with scripting support. 
The reason for this is simple: memory. All scripting implementations con-
sume enormous amounts of memory (in handheld terms). Although language 
providers such as Sun Microsystems are working to produce smaller scripting 
implementations, browser and hardware vendors are not likely to adopt these 
immediately. 
When they become available, scripting languages for the wireless Web are 
likely to be significantly simpler than those currently in use. This simplicity will 
reduce the burden on wireless access terminals, but will increase the burden on 
content providers; those interested in providing material for both the conven-
tional Web and its wireless counterpart will have to develop their content in two 
distinct versions, each using different scripting dialects. 

The Wireless World Wide Web 
Security 
Security is as important on the wireless Web as it is on its wired counterpart. 
Electronic commerce, transfer of corporate data, and other private transactions 
may need to be secured from prying eyes. 
Fortunately, for several reasons wireless networks are actually safer than 
wired networks. Wrreless networks often offer some form of encryption. And 
although seldom truly secure, the encryption schemes wireless networks use 
safely obscure data from most eavesdropping. Some wireless schemes, notably 
Code Division Multiple Access (CDMA), are devilishly hard to eavesdrop on. In 
addition, the interface between wireless clients and the network-except when 
the data is actually in the air -is usually part of a closed telecommunications 
network, making interception more difficult. 
As discussed in Chapter 1, "A Wireless Data Primer," wireless networks gener-
ally use some sort of frequency sharing-distributing data from a single source 
across multiple channels. Any attempt to eavesdrop on transactions being car-
ried out this way would require capturing and reassembling large amounts of 
data. On spread -spectrum networks, inside information about how a signal is 
spread might even be required to reconstitute the data from a particular source. 
This obfuscation does not guarantee security by any means, but it discourages 
many attacks by would-be hackers. 
In addition, many wireless networks have been designed with the need for 
higher security in mind. Most all-digital wireless networks are newer than five 
years old, and their architects have had supporting electronic commerce as 
a high priority right from the drawing-board stage. Therefore, wireless networks 
usually include active security measures such as encryption and authentication. 
Nonetheless, security remains an issue, especially where the wireless net-
work meets the wired one. To ensure that data does not become vulnerable once 
it arrives on the wired network, there are established security technologies avail-
able on both browsers and servers, such as Secure Sockets Layer (SSL), using 
standard encryption algorithms. The wide availability of these options makes 
them a good choice for wireless Web applications using HTML and HTTP-and is 
yet another point in favor of using traditional Web protocols. A chain is only as 
strong as its weakest link; this is as true in data security as anywhere else. 
Getting Presentation Tips 
The basic rules of wireless Web authoring are straightforward: Keep it simple and 
keep it small. Yet it can be surprisingly difficult to master the strategies for pre-
senting information in this manner. In Web content designed for the desktop or 
print, a single "page" of information commonly consists of a half-page to a page 
of print. If you think of this page as coming from your college notebook, think of 
59 

Chapter4 
60 
the wireless Web equivalent as a crib sheet-a mere 3x5-inch card on which you 
must fit all your information. Unfortunately, in this context you do not have the 
option of writing small and carrying a magnifying glass to your final exam! 
Displaying Text 
Perhaps the most important fact to remember about presenting text concisely is 
the value of summaries. Most users of mobile devices do not want copious 
amounts of data; they want just the facts. Summaries can help them quickly 
extract what they are looking for from the sea of data within your site. 
One approach is to offer the summary first, with a wireless link to the full 
content. Thus, a user is able to read the headline, skim the summary, and then 
decide if it is worth the extra time and bandwidth to download the longer ver-
sion. Some news sites are already doing this for the AvantGo HTML wireless 
browser (which you will encounter in Chapter 14, "Content Delivery"), enabling 
readers to pick the depth of information they need. Figure 4-1 shows a fictitious 
example of using content summaries to optimize wireless content. 
Iff/ All The News 
All The News for 22 November, 3 AM. 
Headlines 
•Chicken Crosses Road; Experts 
Mystified by Motivation [?.~If.l .. ?.~J[ 
~J~Cf. . ~.~J 
•Ten Thousandth Day of Good 
Weather; More People Die of 
Boredom !~.\lm..1.~1!~.~.9.r.Y. .~.~J 
•Broccoli Found Sentient, May Hold 
+•li~$BO 
All The News 
Chicken Crosses Road; EKpert:s 
Mystified by Mat:ivot:ian 
( 22 November, 8 AM) ~~~o::JXY .. ?.~J 
In a series of unprecedented steps 
today Sandy's chicken Lazalot crossed 
a road. Originally shocking onlookers 
with a crossing taking only two and a 
half minutes, poultry behaviorists are 
baffled as they study Lazalot, now 
seen pacing repeatedly across Rt 1 <lO 
+•li~$BO 
Figure 4-1. Optimizing wireless content by using a summary and a full story 
More often, however, only summaries are available to wireless viewers. The 
summary itself can include a URL (not a hyperlink) to a page with the full story 
for the viewer who wants to access it from a desktop via a separate link. This tac-
tic is especially appealing to content providers who derive revenue from desktop 
viewers through subscriptions or advertising. 
Because wireless users rely so heavily on them, it is especially important to 
make your headlines and summaries relevant and useful. Many writers, aiming 
to draw the reader into a story, are tempted to make headlines sensational or 
even absurd; this tactic may be acceptable in print, but it is rarely appropriate for 

The Wireless World Wide Web 
wireless content. Following the link from a dubious headline can cost the viewer 
precious time-and hence money-downloading a story of no interest. Naturally, 
this makes for a resentful customer. Keep headlines and summaries to the point! 
Displaying Tables 
For use on mobile browsers, it is generally best to create tables that are long and 
narrow, as opposed to wide and short. Although the market appears evenly split 
between portrait-oriented and landscape-oriented screens, they often scroll ver-
tically and only rarely horizontally; some narrow-screen platforms do not even 
support horizontal scrolling. A long, skinny table is therefore more likely to be 
accessible to all users than a short, fat one. 
Another pitfall to avoid is nesting tables. Although HTML supports nesting 
tables, the results on handhelds are indeterminate at best and catastrophic at 
worst. Some clients refuse to draw nested tables; others attempt it-and manage 
so poorly that the meaning of a table is obscured or changed without warning to 
the user. 
In any case, there is usually a more appropriate way to represent information 
than nesting tables. If you find yourself tempted to nest a table, stop and examine 
what content you are trying to bring to the reader. Often, you may realize your 
purpose is in fact to control the screen layout (for example, using a table to create 
a page with paragraphs of text in multiple columns). It is always better to let the 
client perform the screen layout, as it is more familiar with the characteristics of 
the device than you will be. 
Displaying Forms 
Handling form input for wireless devices presents challenges both in interface 
design and in handling the resulting data. The two factors to keep in mind are the 
following: 
• Providing end users with an easy-to-use interface 
• Keeping the quantity of form data that results from the responses as small 
as possible for its return trip over the wireless network 
Fortunately, these goals are not mutually exclusive. Most mobile users want 
to enter as little information as possible when using an online form. In most 
cases, they will be at least partially distracted-they may be walking, driving, or 
otherwise preoccupied-often with at least part of their body in motion, so 
inputting may require difficult feats of both mental and physical balance. 
61 

Chapter4 
62 
Therefore, you should design forms so that they require the minimum possi-
ble amount of input. For example, if you need to find out the user's location, ask 
for a ZIP code or telephone number with area code, rather than a full address. 
Often, this information can be used to pinpoint a location closely enough to pro-
vide information such as restaurant recommendations or movie listings. 
Radio buttons, pop-up menus, and pick lists are the easiest input methods 
for mobile users. Most mobile devices offer a touch screen or rocker key for rapid 
scrolling; many have both. These tools make managing lists easier than inputting 
text, as it requires fewer motions to manipulate a rocker button or touching an 
item on a display than to navigate a keyboard. Items best left to lists include the 
following: 
• Countries or states 
• Color or size choices 
• Categories of data, such as "Simple" or "Detailed" stock quotes 
• Choices of operations, such as "Accept" or "Cancel" an order 
Unfortunately, the most common scheme for reducing the inputting burden 
placed on users is not well supported on the wireless Web. Cookies are bits of 
information from specific HTTP headers that are stored on the client between 
transactions, which enables servers to maintain the illusion of a session without 
the need for server complexities. This information might be used for various pur-
poses: to manage the state of a transaction, to authenticate a user, to keep track 
of preferences, and so on. Not all wireless HTML browsers support cookies, 
although the number is growing gradually. Moreover, the convenience of cookies 
can pose a problem for handheld devices; as more and more sites adopt them, 
they tend to bloat the "hidden" cost ofWeb access, as they are exchanged with 
the browser but are not directly seen by the subscriber. 
Some handheld devices support another technique for reducing input and 
managing transactions, however. This mechanism uses a hidden identifier within 
forms that is generated uniquely by the client as a transaction starts and then is 
carried throughout a transaction's lifetime via a hidden variable within the form. 
For example, the following HTML: 
<INPUT TYPE="hidden" NAME="client" VALUE="%deviceid"> 
creates a hidden field on Palm Computing Platform devices running a Palm Web 
Clipping application that servers can access by checking the value of the client 
variable when examining form results. This resulting identifier can be carried 
from form to form exchanged between client and server, enabling the server to 

The Wireless World Wide Web 
track state in an internal database keyed by the value of the client variable. You 
should only do this when necessary to maintain state, however, to keep the client 
from needlessly downloading irrelevant content. 
Unfortunately, the way to get the unique identifier for a device is not stan-
dard, reducing this trick's usefulness for content aimed at a broad viewer base. As 
the use of unique identifiers for these devices spreads, one can hope that a stan-
dard will emerge and that unique identifiers can be used in concert with 
server-side data storage to emulate the behavior of cookies. 
Thus, forms work best when interaction can be kept to a single 
request/response sequence ("Give me the quote for this stock." or "Where will 
I have dinner tonight?" or "What wine goes best with salmon?"). Doing so mini-
mizes both the amount of information a user must enter and the complexity of 
the back-end service necessary to track clients, their requests, and results. 
Displaying Images 
Probably the feature of any Web page that makes the biggest impression on 
viewers is its use of images. You will want to use images sparingly in your wire-
less-oriented content for the reasons discussed in Chapter 3, "The Wireless User 
Interface" (hardware, memory, and network performance constraints all play 
a role in the decision). However, you may not want to abandon the use of images 
completely. 
The Proper Use of Images 
In some cases, images can provide more meaning in less space than can words. 
Consider Figure 4-2, inspired by the Web site Weather Underground. Both ver-
sions of this information take only a handful of bytes; in fact, depending on the 
format chosen, the amount of memory required could actually be smaller for the 
image than for the text. Which version provides the viewer with the most infor-
mation with the least effort? Although either may be appropriate for a deskbound 
user, the graphic is a better choice for a wireless user. The graphic carries the 
same message as the text and uses a similar amount of memory and network 
resources, yet is easier to read and takes up less screen space than the text. 
63 

Chapter4 
64 
Mostly cloudy with scattered showers 
early. Most numerous in the 
mountains. Sunny and warmer in the 
afternoon. Highs uper 50s and lower 
&Os. Northwest wind to 15 mph. 
~-[j"+t$BO 
Figure 4-2. Contrasting graphics with text 
Keep graphics simple; you should stick to either grayscale or just a few bold 
colors. Images should not make up more than a small fraction of your site's con-
tent, or they will easily dominate both screen space and bandwidth. Eschew 
complexity. 
Selecting a format for your images is as important as creating the images 
themselves. The right image format can minimize download time and avoid 
wasting bandwidth by downloading data that is not applicable to your content. 
Although graphics rule on the standard Web, they have a much less promi-
nent role in the wireless world. Often, the cast-in download time, screen space, 
and, ultimately, dollars-of transferring an image to a wireless device is simply 
too high to be worthwhile to the viewer. Although these limitations are decreas-
ing as the capabilities of both the wireless network and the devices that use it 
evolve, the wireless Web is likely to stay several steps behind the wired one in 
terms of graphics for some time yet. There is no point in losing your first wave of 
subscribers over the inappropriate use of graphics. 
Displaying Bullets and Spacers 
Graphic bullets and spacers are two examples of items to avoid. HTML can pro-
duce nicely formatted bulleted lists using the <UL></UL> tag pair; each item is 
delineated by the <LI> tag. Some authors, however, create special graphic bul-
lets-three-dimensional spheres, miniature logos, spinning balls, and so 
forth-for use in lists. Some users may find a few of these efforts tasteful, but the 
practice is deplored even by many desktop Web users. Using images this way can 
dramatically increase the amount of time it takes for even a desktop page to load; 
the equivalent performance hit for a handheld device is phenomenal. 

The Wireless World Wide Web 
NOTE 
In this and subsequent examples, I will use tag to refer to both 
empty tags-those used singly, such as <BR>-and paired tags that sur-
round a section of content, such as the pair of tags <UL> and <IUL>. Where 
necessary, I will call your attention to the fact that a tag is empty. 
Using image spacers poses a similar problem. HTML was designed as 
a device-independent markup language: It enables the client to format content 
in whatever way is best given the particular platform and user. Many Web design-
ers take exception to this loss of control, however, and seek an identical 
appearance for their content across different devices and viewers. A common 
trick used to achieve this goal is to create small transparent or solid-color images 
of a specific size and insert them as shims or spacers between the main graphic 
images on the page. These spacer images cause problems for mobile clients. They 
increase the time it takes to load a page and defeat the browser's algorithms for 
optimizing the data for small-screen display. Why force a user who is paying for 
your content by the minute-or by the byte-to download empty images? 
Displaying Logos 
A marketing department may deem the use of a corporate logo essential even on 
wireless sites. If you must include a logo in your content, take the time to create 
a version of it that is optimized for presentation on low-definition displays. Make 
it as small as you can and only use it on the first page of your content. 
This lesson is one I have presented before, but I cannot stress it enough: Use 
only images that are essential to your content. Any image on a page aimed at 
wireless devices should add distinct value and carry more information than an 
equivalently sized body of text on the display. 
Summary 
For many applications, existing Web standards such as HTTP, HTML, GIF, and 
JPEG are well suited to wireless development. Despite relatively large size 
requirements, the widespread adoption of these protocols among handheld 
devices and wireless terminals offers many advantages for the developer. 
You must use these standards with care, however. HTML, for example, has 
a number of tags not appropriate for wireless development, and just because 
wireless Web browsers can display images does not mean you should use them. 
You should balance the features of these standards against the need for succinct 
content and respect for the user's perception of data mobility. 
65 

Chapter4 
66 
HTML provides a good markup language for wireless Web content when you 
follow certain rules. The pages you create should be brief with descriptive links 
used to connect related content, enabling your users to pick and choose the 
material they want to view. You can use forms to enable users to select from dif-
ferent choices or obtain information about one of a group of things, but 
remember that they will be using the browser in settings where their attention is 
often elsewhere. 
Avoid using images. Where you find it necessary to use an image, be sure it 
conveys more meaning than would a like-sized block of text. You should take 
pains to optimize your images for wireless viewers, both by experimenting with 
how the images are compressed and by viewing the results on wireless devices. 
You will find you need to make tradeoffs in the image quality, size, and download 
times. 
In short, when using these protocols, you should pay close attention to the 
amount of bandwidth your content requires as you produce it. To ensure high-
quality presentation of your content as well as reasonable delivery speeds across 
the wide spectrum of devices in use today, your best bet is to try your content fre-
quently on the devices for which it is intended. 

CHAPTER 5 
Server-Side Content 
Management 
MANAGING CONTENT FOR THE WIRELESS WEB brings COmplexity above and beyond a tra-
ditional Web site. Not only do you need to support static and dynamic content, 
but you also need to do so in a variety of formats. With today's proliferation of 
wireless devices, it is not unusual for a site to support Handheld Device Markup 
Language (HDML), Wrreless Markup Language (WML), and two or three different 
dialects of HyperText Markup Language (HTML). You can use two technologies to 
address this challenge: server-side scripting or transcoding. With server-side 
scripting, you use scripts that determine the capabilities of the browser as it 
makes a request and then format the response appropriately. Using a special 
transcoding server, you provide one set of content and the transcoding server 
converts your content from one format to another. 
In this chapter, I introduce server-side scripting and show the simplest of 
solutions for content management using the Apache Web server's built-in script-
ing support. (In the next chapter, you will learn how to manage your content 
using PHP: Hypertext Processor, a robust scripting engine for the Apache Web 
server and other Web servers.) Following the discussion of server-side scripting, 
I show a brief survey of today's transcoding solutions and close the discussion 
with a high-level survey oftoday's eXtensible Markup Language (XML) solutions 
for content management. 
What Is Server-Side Scripting? 
Server-side scripting (also known as active server technology) has been around 
for a few years. Informally, any Common Gateway Interface (CGI) script that 
returns Web content is often called server-side scripting, but the term technically 
refers only to technologies characterized by the following: 
• The use of a simple scripting language with conditional constructs that can 
generate content for clients 
67 

ChapterS 
68 
• The placement of these scripts within or around HTML 
• The ability of these scripts to insert content within the HTML that 
contains them 
In a server-side scripting environment, the Web server invokes server scripts 
in response to client requests to create responses. These scripts can perform 
database operations, select formatting, manipulate content, and integrate con-
tent with data. 
The three main server-side environments currently available are PHP, a free, 
open-source environment available for Unix, Linux, and Windows; Java Server 
Pages (JSP), Sun's Java-based server-side technology; and Active Server Pages 
(ASP), Microsoft's technology for Windows-based servers only. 
Server-side scripting provides several benefits for developers of mobile data 
First and foremost, it provides a framework for separating data from its presen-
tation. This division leaves content developers free to divide their work between 
information and layout or to create many layouts for a single data set. Although 
other technologies (notably style sheets) exist that support content/format sepa-
ration, they require client support that is not likely to be available on mobile 
platforms for some time. 
Equally important is the support for conditional logic that a server-side 
scripting environment provides. Server-side scripts can examine what kind of 
client is making a request and prepare a document that is formatted optimally for 
that client. In many cases, this operation is as simple as the server selecting from 
a set of template scripts the one that is appropriate for a particular client. In 
other applications, the server selects an appropriate format template and merges 
it with the origin data. 
Finally, server-side processing frees the client to perform its most impor-
tant task: presenting data to the user. Although most clients can make the 
determination to ignore tags that the client cannot render, you should not rely 
on the client to do this. By forcing the client to make this determination, these 
tags may waste bandwidth by sending tags to a client that are then ignored. 
Although server-side scripting was developed for providing HTML content, 
there is nothing to stop an active server from providing content to Wireless 
Application Protocol (WAP) or HDML clients. The Web-based deployment model 
for both WAP and HDML enables the same Hypertext Transfer Protocol (HTTP) 
server to be used to deliver content in both HTML and a screen-phone format 
such as WML. Although scripting libraries capable of formatting content for these 
devices may not be available, server scripts can create these pages using the raw 
tags available in either WML or HDML. In turn, the same Web server can serve 
these pages and make them available to the client via the network operator's 
gateway .. 

Server-Side Content Management 
Using Server-Side Scripting in Mobile Applications 
To use server-side scripting for mobile data, you will need to prepare your site as 
follows: 
• Select an appropriate server-side scripting technology. 
• Separate your site's content into data and formatting information. 
• Identify the interfaces to your data sets and formatting sets. 
• Develop the data set. 
• Develop the format set. 
The following sections examine each of these steps in detail. 
Selecting a Server-Side Scripting Solution 
When selecting an appropriate server-side scripting solution, you will want to 
consider a number of factors, including your personal experience, your server's 
infrastructure, your business model, and any existing restrictions on your infor-
mation technology. Most technologies are functionally equivalent from the 
perspective of mobile data, so they are distinguished primarily by how well their 
feature sets fit with your skills and other requirements of site design. However, 
other constraints exist. 
Organizations that are able to make only a minimal initial investment of 
funds would be wise to look at one of the open-source active server solutions, 
such as PHP or JSP. These technologies run on a variety of computing platforms 
and are freely available for modification and use. Although there is little commer-
cial support for them, knowledgeable hands can install and configure these 
systems at little or no cost. 
In other cases, platform constraints or organizational politics may dictate the 
choice of a server scripting solution. Organizations with existing Information 
Technology (IT) appropriations will likely use the solution selected by their IT 
staff. Or, for example, a company focused on demonstrating the use of Microsoft 
technologies for mobile data will probably select Microsoft ASP, regardless of the 
strengths or weaknesses of it or other choices. Similarly, an organization with 
a heavy investment in a particular technology should make the most of that 
investment and pursue its service using that technology. 
69 

ChapterS 
70 
Separating Content into Data and Format Sets 
Central to the use of server-side techniques for mobile data is the separation of 
content into data and format. Data refers to the intellectual property your site 
delivers. Format refers to the look and feel, or the templates into which your data 
will be inserted. 
Determining the difference between data and format can be more difficult 
than one would first think. Is your beautiful logo data, for example, or is it part of 
a page's format? Or is it simply a resource that spans formatted pages? 
In general, content will change more often than information used to 
define your site's look and feel will change. Data often changes over time and 
needs to be updated to maintain accuracy. It must therefore be easy to access 
and change. Often, special tools can access or change information, such as 
a database front end or scripts for entering and validating up-to-date data. 
Format sets, on the other hand, are largely static. Once you have created 
a site, you will update format sets infrequently, often only to add support for a 
new kind of device in use. 
Another possibility is to define data and format according to who maintains 
them. Content specialists are responsible for maintaining data-the specialists 
may be simply you, or they may be a group of content editors. By contrast, for-
mat information is largely the domain of graphic artists, Web designers, software 
script developers, and similar resources-those responsible for the look and feel 
of a site. Again, for small organizations or small sites, there may not be different 
staff members responsible for each of these tasks, but the people who fulfill them 
will switch roles if they perform different tasks. 
Closely related to the idea of a format set is that of a resource set, which con-
sists of common format elements used across multiple formats. For example, 
your site's logo might be part of a set of elements used by many templates-one 
for rich HTML, one for simple HTML, one for screen phones, and so on. 
Advertising content might also belong to a resource set, presented in different 
formats for different devices. (On the other hand, the advertising service might 
also divide data and format as described here when providing content to you in 
multiple formats for multiple devices.) Whether it is worthwhile to create 
a resource set largely depends on the number of elements that are common to 
several of your formats. If there are only a few, it is sufficient to keep the elements 
that comprise the resource set in their own directory and handle them separately 
as you would any other sites. If you run a larger service with complex formats 
that have many shared elements, you may choose to enforce a more rigorous 
partitioning scheme, perhaps storing resource content on secondary servers. 
Similarly, how you store your data, format, and resource sets will depend 
largely on the scope of your service. For a small site, you may choose to keep data 
in text files and formats for various pages and devices in different directories. For 
a larger site, or one with many sources of input, you may find it more practical to 

Server-Side Content Management 
keep data-or even both content and format sets-in a relational database. Or 
you may want to use a mixture of strategies, mixing and matching data files and 
database access. 
For example, the creators of a site providing financial market data would 
probably consider the financial data-stock market indexes, stock quotes, finan-
cial news, and other information-to be their data set. Their format set would 
contain the scripts, HTML, WML, and HDML for the various devices they sup-
port. An organization of this size would probably define a resource set of 
information such as its logo, organization name, trademarks, and disclaimers. 
The data set would be stored in a variety of locations, no doubt including net-
worked access to commercial data feeds and databases for storing and retrieving 
news stories filed by commercial feeds and content editors. 
On the other hand, a smaller site, such as one responsible for keeping the 
calendar and other information for a local club, would have a much simpler 
division. The site's data set would likely be a set of text files containing meeting 
times and other special events for the calendar, and perhaps a simple contact 
list. The format set would contain the scripts and format for this data, probably 
organized for only the devices currently in use by club members and prospective 
club members. 
Identifying Interfaces 
Identifying interfaces to your format and data sets is a function of both your data 
storage choices and of the scripting environment you will use to provide the 
data to clients. It is largely a process of software design because you will use these 
interfaces entirely within the scripts produced to manage and present your con-
tent. Broad categories of interfaces include simple text-file parsers that select 
information from a file, Open Database Connectivity (OBDC) database interfaces 
that can access back-end databases via Structured Query Language (SQL), and 
network interfaces that interact with other information servers. 
Many simple sites choose to store their data in text files, using simple tools 
in Perl, Tel, C, or another language to search and sort them. These sites use sin-
gle-purpose tools, crafted for the site's data, and include means to add data, 
remove or edit data, and search for data by a relevant key such as filing date, 
topic, or name. Server scripts to access the data sets for presentation with form 
at elements use the same tools used to edit and manipulate the data set for 
content editors. 
More sophisticated sites use relational databases, accessed by tools created 
for content editors. These sites use integration tools such as OBDC to make 
requests of the database on behalf of clients. In turn, the resulting information is 
merged with format elements and returned to the client. Most server-side script-
ing environments provide explicit tools for access to databases or can be 
71 

ChapterS 
72 
extended to do so using third-party products. The content in these databases 
may be flat text, binary objects such as pictures or ring tones, XML data, or 
a combination of these formats. 
Large-scale sites, especially those interacting with legacy information 
sources such as financial or billing systems, may not provide traditional network 
interfaces. Such systems often require special network-based tools to gain access 
to their information. Server-side scripts are required to use these tools to make 
requests on behalf of clients. Although this process is similar conceptually to 
database integration, it is more complex because it calls for additional software 
rather than ready-made tools for integration. 
A special class of these systems uses XML for data exchange. Systems pro-
viding XML representation for their data often make this data available over 
HTTP; integrating with one of these systems simply involves the selection of 
an HTTP and XML layer in software. Although much work remains to be done in 
establishing XML interfaces for many data sources, XML will likely replace 
legacy interfaces to data. 
Managing Server-Side Content with Apache 
The Apache Web server1 has been the most popular Web server on the Internet 
since Aprill996. The March 2002 Netcraft Web Server Survey found that 54 per-
cent of the Web sites on the Internet use Apache, making it more widely used 
than all other Web servers combined. 
This Apache server is available for most Unix variants, including Mac OS X, 
Linux, and Solaris, as well as Microsoft Windows, and is available from many Web 
hosting companies. It is an open-source project; its source code is available for 
examination and modification to suit your purposes. As with many other open-
source projects, there are many customizations and enhancements available, 
and of course you can extend the software if necessary. 
The Apache server supports modules that extend its functionality. One mod-
ule commonly used to support simple server-side scripts is the mod_include 
module-also called the server-parsing module-which permits server parsing of 
HTML files. This module (available by default with the base installation) lets you 
use simple directives in your HTML to include dynamic content created by exter-
nal scripts. 
The server-parsing module scans source files for server directives that per-
form simple tasks, such as replacing a directive with the output from an executed 
program, the current file's size, or the last modified date. The module supports 
simple if-then conditional operations, enabling a variable to be tested and differ-
ent content returned based on the value of a variable. 
1. 
The Apache Web server is one of many projects available from the Apache Foundation at 
www.apache.org. 

Server-Side Content Management 
Server parsing with Apache is appropriate for simple sites where dynamic 
content is limited to the selection of markup. These sites can use server parsing 
to support desktop and synchronized browsers or to differentiate between 
a high-definition and a low-definition HTML client. Although the intrepid devel-
oper could choose to use server parsing for larger files, solutions such as PHP are 
a better choice because they are designed to support large aggregates of dynamic 
content. 
Using Server Parsing 
By default, the Apache server parses files with the • shtml suffix rather than . html. 
(Site administrators can change this suffix or make additional suffixes server-
parsed, so you should check your local configuration before you begin.) In other 
words, the Apache server scans them and replaces any directives with the con-
tent that the directives create. In case of errors, vague messages appear in the 
resulting HTML content; the Apache HTTP error log keeps track of the details. 
A server directive is a single word instructing the server to perform a task, 
along with zero or more options modifying how the task should be processed. 
Server directives may occur anywhere in the source content. They are contained 
within an HTML comment and always start with a hash symbol (#). For example, 
the following code samples are both valid server directives: 
<!--#set var="dog" value="husky" --> 
< 1--#echo var=" LAST_ MODIFIED" --> 
By encapsulating server directives in a comment, you can use HTML editors 
and validation tools to compose your content without receiving spurious error 
messages. 
When the Apache server processes content, it replaces server-parsed direc-
tives with the value of the directive's evaluation. For example, the following 
directive: 
<!--#echo var="LAST MODIFIED" --> 
is replaced by the value of the variable LAST_ MODIFIED, which happens to be the 
date that the current file was last modified. 
Using Server Directives 
The Apache server recognizes 12 server directives in server-parsed files, which 
are listed in Table 5-l. 
73 

ChapterS 
74 
Table 5-1. Apache Server-Parsed Directives 
DIRECTIVE 
config 
echo 
else 
elif 
end if 
exec 
fsize 
flastmod 
if 
include 
printenv 
set 
OPTION 
errmsg 
sizefmt 
timefmt 
var 
expr 
cmd 
cgi 
file 
file 
expr 
file 
var,value 
Configuring Output Format 
PURPOSE 
Controls various aspects of server parsing 
Sets the error message to be returned for 
parsing errors 
Sets the size format to be used when 
displaying file sizes (one of bytes or abbrev) 
Sets the time format to be used when 
displaying times 
Prints the variable specified by the var option 
Specifies the failure clause for a conditional 
expression 
Specifies an additional conditional clause 
for a conditional expression 
Terminates a conditional expression 
Executes the command specified by cmd 
Executes the CGI given by cgi 
Prints the size of the file specified 
Prints the last modified time of the 
file specified 
Begins a conditional expression 
Includes the specified file at the current 
location for parsing 
Prints all environment variables 
Sets the variable specified by var to the 
value indicated 
The config directive controls how the server presents the results of server-parsed 
data within. the current document. Most often, you use it with the errmsg option to 
specify what error message is inserted in the content if a directive fails. For exam-
ple, if there's an error elsewhere in a directive in a page, the following directive: 

Server-Side Content Management 
<! --#config errmsg= "Foiled again! " --> 
causes the message Foiled again! to be inserted in your content anytime an error 
occurs. By default, the error message displayed was the rather bland [an error 
occurred while processing this directive]. 
Reporting File Size 
The fsize directive reports the size of a file. The sizefmt option determines 
whether its output is an exact number (when sizefmt is bytes) or is rounded to the 
nearest kilobyte (when sizefmt is abbrev). For example, the following directives: 
<! --#config sizefmt ="bytes" -- > 
This file is <1--#fsize file="index.html"--> bytes. 
could return content similar to this: 
This file is 892 bytes. 
Using config sizefmt= "abbrev", the same file would result in the content: 
This file is lk bytes. 
Tracking File Modifications 
The flastmod directive reports the time a file was last modified. This example 
prints the last modification date of the file index. html: 
This file was last modified on <!- -#flastmod file=" index. html"-- >. 
The format of the output from flastmod depends on the timefmt option of 
the con fig directive. Its argument is a C printf-style format string, consisting 
of text and field format directives, which are represented by a% symbol followed 
by a letter. For example, the following server directive: 
< ! --#con fig timefmt = "%d %8 "£'("--> 
This file was last modified on <1--#flastmod file="index.html"--> 
results in output with the following date style: 
This file was last modified on 17 August 2000. 
75 

ChapterS 
76 
Table 5-2 shows the possible field format flags for the timefmt option. You 
may build a time string with any number of field format flags. 
Table 5-2. Time Format Field Flags 
FORMAT 
%a 
%A 
%b 
%8 
%c 
%d 
%H 
%1 
%j 
%m 
%M 
%p 
%5 
%U 
%W 
%w 
%x 
%X 
%y 
%Y 
%Z 
%% 
PURPOSE 
Day name (abbreviated). 
Day name (full). 
Month name (abbreviated). 
Month name (full). 
Preferred representation of date and time for current local and platform. 
Day of the month as a decimal number. 
Hour of the day (24-hour clock). 
Hour of the day (12-hour clock). 
Day of the year. 
Month number. 
Minutes past the hour. 
Either a.m. or p.m., depending on whether the time is before 
or after noon. 
Seconds past the minute. 
Number of the current week in the year. (The first Sunday 
starts week 1; days before the first Sunday are in week 0.) 
Number of the current week in the year (starting with the first 
Monday of the year). 
Day of week as a decimal number (Sunday= 0). 
Preferred representation of the date without the time for the 
current local and platform. 
Preferred representation of the time without the date for the 
current local and platform. 
Current year Oast two digits). 
Current year (all four digits). 
Time zone designation or abbreviation. 
Inserts a percent sign. 

Server-Side Content Management 
Including Other Content 
The include directive specifies a file to be included in the content. The server 
simply replaces this directive with the specified file's contents. For example, if the 
file test contains the message Hello World, the following directive: 
<P><!--#include file="test" --></P> 
is converted to the following HTML: 
<P>Hello World><IP>. 
You can use this directive to build a larger file from primitives such as 
a header, dynamic content, and footer. 
Executing External Scripts 
Similar but more powerful is the exec directive, which executes the script at 
a specified location. Thus, the following directive: 
<P><I--#exec cmd="date" --><IP> 
is converted to the following HTML: 
<P>Fri Feb 25 15:50:46 PST 2000</P>. 
The use of include and exec files can pose security risks for Web sites, how-
ever, as Web authors and others may have unrestricted access to these files and 
commands. The constraint that only commands in the Apache's CGI directories 
can be executed using the exec directive provides some protection. Moreover, the 
Apache server must have access (via Unix access controls) to the file that is 
included or executed. 
Using Variables 
The Apache server script parser supports both user-defined and server-defined 
variables that contain strings. You can define these variables for the server to 
evaluate and send to the client, or the server can test them using directives you 
provide to control your script's execution. The server defines the variables 
DATE_GMT,DATE_LOCAL,DOCUMENT_NAME,DOCUMENT_URI, LAST_MODIFIED,and 
HTTP USER AGENT. The first two of these are set to the current time relative to 
77 

ChapterS 
78 
Greenwich Mean Time (GMT) and the local time zone, respectively. The next two 
are set to the document's filename and the URL path of the document requested 
by the user. The LAST_MODIFIED variable is set to the last modification date of the 
document requested by the user. The HTTP_ USER_ AGENT variable is set to the value 
of the HTTP_ USER_ AGENT header passed by the client during a request. (I explain 
more about this a bit later in this chapter in the section "Managing Client-
Specific Content with Apache Server Directives.") 
The echo directive converts a variable to HTML: 
This page was last updated on <!--#echo var="LAST_MODIFIED" -->. 
resulting in a message showing the last updated date for the current file. This 
directive is handy for footers of frequently modified pages. 
The printenv directive prints all currently set variables, which makes it useful 
in debugging. 
Making Decisions 
Variables have a second use: conditional flow control. Apache provides condi-
tional evaluation through the if, else, and endif directives. These directives 
evaluate the expression given by the if directive's expr option. If the expression is 
true, the content between the if and else directives is evaluated and returned to 
the client; otherwise the content between the else and endi f directives is evalu-
ated and returned, as shown in the following example: 
<1--#if expr="$DATE_LOCAL=\"Mon Dec 25 oo:oo:oo PST 2000\""--> 
<B>Ho ho hoi<IB> 
<!--#else--> 
<!--#echo var="DATE LOCAL" --> 
<1--#endif--> 
This rather fruitless snippet prints Ho ho ho! in bold if a user views the page 
on Christmas morning at midnight; otherwise it prints the current date. 
Expressions may contain the comparison operations = and ! =, along with 
the ordinal comparisons < = and > =. Logical aggregation of operations is sup-
ported using the C-style not (!), (&&), and or (II) operations. Anything not 
recognized as a variable or operator is treated as a string for the purposes of com-
parisons. Regular expressions can be specified using I I instead of quotes, 
allowing partial matching to occur. Thus, the following example would print 
a Yuletide message anytime on Christmas day: 

Server-Side Content Management 
<!--#if expr="$DATE_LOCAL=/Dec 25/"--> 
<B>Ho Ho Hoi</B> 
<!--#else--> 
<!--#echo var="DATE LOCAL" --> 
<! --#endif--> 
You can perform multiple comparisons using eli f directives. Optionally, one 
or more eli f directives may lie between an if and an else directive, each with its 
own comparison. The contents between the first eli f resulting in true and the 
next if, eli f, else, or endi f block are returned to the client. The following exam-
ple uses the HTTP _USER_AGENT to differentiate betweenAvantGo, Palm VII, and 
other browsers: 
<1--#if expr="$HTTP_USER_AGENT = /AvantGo/" --> 
You're viewing this site with AvantGo. 
<!--#elif expr="$HTTP_USER_AGENT = /Elaine/" --> 
You must be using a device with the Palm Clipping Technology. 
<1--#else--> 
Hmm. Looks like you're using a no-name browser like 
Netscape, Microsoft Internet Explorer, or something else. 
< 1--#end if--> 
Managing Client-Specific Content with Apache Server 
Directives 
· 
One of the best uses of server-parsed pages is managing content for multiple 
client devices. When content is static, and only one or two different kinds of 
devices are supported, server parsing can be significantly easier to implement 
than a full active server solution. 
The server-parsing environment defines the variable HTTP _USER_AGENT. You 
can use this variable to identify the client and return client-specific content. 
During a transaction, the HTTP client sends a User-Agent header with a string 
identifying the client. The server places this string in the HTTP_ USER_ AGENT vari-
able before the script is parsed. 
Listing 5-l shows HTML for a Web site with both desktop and mobile users. 
In it, I test the HTTP _USER_AGENT variable to return a Web page formatted for either 
AvantGo or a desktop browser. 
79 

ChapterS 
80 
Listing 5-1. Using the HTTP _USER_AGENT Variable 
<HTML> 
<HEAD> 
<TITLE>San Lorenzo Valley ARES</TITLE> 
<META NAME= "Handheld Friendly" content= "True"> 
</HEAD> 
<BODY BGCOLOR="#FFFFFF"> 
<1--We provide different content if we're being loaded by 
Handspring Blazer or AvantGo.--> 
<!--#if expr="$HTTP_USER_AGENT = /Blazer/ II $HTTP_USER_AGENT 
<H1 ALIGN=right>San Lorenzo Valley ARES</H1> 
/AvantGo/" --> 
<P>Welcome to the San Lorenzo Valley ARES page, providing training 
and reference information for the ARES volunteers in and around the 
San Lorenzo Valley in California, USA.</P> 
<H2>Current events:</H2> 
<P><! --#include file="events. html "--><IP> 
<CENTER> 
<HR> 
<A HREF= "calendar. html ">Calendar</ A> 
<A HREF="meetnets.html">Meetings &amp; Nets</A><BR> 
<A HREF= "organization. html ">Organization</ A> 
<HR> 
&copy; 1997-2001 SLVARES. This page was downloaded on 
<!--#exec cmd="date"-->.</CENTER> 
<P>Visit http://www.lothlorien.com/~slvares/avantgo.html with your 
desktop browser to obtain a list of SLV ARES resources available to 
AvantGo users.</P> 
<!--#else --> 
<H1 ALIGN=right>San Lorenzo Valley ARES</H1> 
<CENTER> 
<HR> 
<TABLE BORDER=O WIDTH= "100%"> 
<TR> 
<TD WIDTH=243> 
<CENTER><IMG SRC= "images/ares256b. gi f" 
WIDTH=190 HEIGHT=190 ALIGN=bottom><ICENTER> 
<lTD> 
<TD> 
<CENTER>Welcome to the San Lorenzo Valley ARES page, 

Server-Side Content Management 
providing training and reference information for the ARES 
volunteers in and around the San lorenzo Valley in 
California, USA. 
<P>See what's new <A HREF="whatsnew.html">here</A>, or 
<A HREF="whatsnew.html#form">register</A> to get email 
whenever these pages change.</P></CENTER> 
<lTD> 
</TR> 
</TABLE> 
<HR> 
<A HREF="#ce">Current Events</A> - <A HREF="#background">Background</A> 
- <A HREF= "#training"> Training< lA> - <A HREF= "calendar. html ">Calendar</A> 
- <A HREF="#section">Our Section</A> - <A HREF="#weather">Weather</A> 
- <A HREF="#fires">Fires</A> - <A HREF="#earthquakes">Earthquakes</A> 
- <A HREF="#general">General</A> 
<P> 
<HR> 
<TABLE BORDER=O WIDTH="100%"> 
<TR> 
<TD COLSPAN=2 HEIGHT=18> 
<H4><CENTER><A NAME=ce></A>Current Events</CENTER></H4> 
<lTD> 
</TR> 
<TR> 
<TD COLSPAN=2> 
<P><! --#include file="events.html"--></P> 
<lTD> 
</TR> 
<TR> 
<TD> 
<H4><CENTER><A NAME=section></A>SLVARES Section 
Information</CENTER></H4> 
<lTD> 
<TD> 
<H4><CENTER><A NAME=training><IA>Training Resources &amp; 
Information</CENTER></H4> 
<lTD> 
</TR> 
81 

ChapterS 
82 
<TR> 
<TO VALIGN=top> 
<Ul> 
<li><A HREF="organization.html">The SLVARES 
Organization<IA><ILI> 
<li><A HREF="calendar.html">Calendar of Current 
·Events<IA><ILI> 
<li><A HREF="meetnets.html">Schedule of Meetings &amp; 
Radio Nets<IA><ILI> 
<li><A HREF="reportslindex.html">Reports from Recent 
Events<IA><ILI> 
<ll>The <A HREF="handbook.pdf">Santa Cruz Standard 
Operating Procedures and Field Guide<IA> in PDF. You'll 
need 
<A HREF= "http: I lwww.adobe. comlprodindexlacrobatlreadstep. html"> 
Adobe Acrobat<IA> to view or print this.<ILI> 
<ll><A HREF="traininglindex.html">SLVARES Training 
Resources<IA><ILI> 
<li><A HREF="snippetslindex.html">Snippets from Various 
Sources<IA><ILI> 
<IUL> 
<lTD> 
<TO VALIGN=top> 
<UL> 
<ll><A HREF="formslindex.html">Forms for use in ARES 
events<IA><ILI> 
<li><A HREF= "http: I lwww.arrl.org/fieldlpscmi">Public 
Service Communications Manual<IA>, by the ARRL.<ILI> 
<LI><A HREF="traininglindex.html">SLVARES Training 
Resources<IA><ILI> 
<IUL> 
<lTD> 
<ITR> 
<TR> 
<TO COLSPAN=2> 
<H4><CENTER><A NAME=background><IA>Backgroundl!ntroductory 
Information<ICENTER><IH4> 
<lTD> 
<ITR> 
<TR> 
<TO VALIGN=top COLSPAN=2> 
<Ul> 
LI><A HREF="what_is.html">What is ARES?<IA><ILI> 

< LI><A HRE F ="http: //WNW. arr 1. org/ pio/ emergen1. html" >ARES 
Background Paper</A> by the ARRL</LI> 
<Ll><A HREF= "http: //WNW. arrl.org/pio/emergen2. html ">Using 
Amateur Radio in an Emergency<IA>, by the ARRL</LI> 
<li><A HREF="http://WNW.arrl.org">The Amateur Radio Relay 
League</A>, or ARRL</LI> 
</UL> 
<lTD> 
<ITR> 
</TABLE> 
<IP></CENTER> 
<H3>0ther Emergency Resources</H3> 
<TABLE BORDER=o WIDTH="lOO%"> 
<TR> 
<TD> 
<CENTER><B><A NAME=weather><IA>Weather</B></CENTER> 
<lTD> 
<TD> 
<CENTER><B><A NAME=general></A>General I News</8></CENTER> 
<lTD> 
</TR> 
<TR> 
<TD VALIGN=top> 
<UL> 
<LI> 
<A HREF= "http: //www.wrh. noaa .gov/afos/SFO/RRS/SFORRSSFO"> 
Local River/Creek Levels</A></LI> 
<LI> 
The <A HREF="http: //www. nws.mbay. neti">National 
Weather Service's</A> San Francisco Region Office</LI> 
</UL> 
<lTD> 
<TD VALIGN=top> 
<UL> 
<LI> 
The <A HREF="http://www.qsl.net/n3xgr/">N3XGR Index 
of ARES Pages</A></LI> 
<LI> 
News of recent disasters from 
<A HREF= "http: //TheEpicenter. com/news. html "> 
The Epicenter</A></LI> 
<LI> 
The <A HREF="http://acs.oes.ca.gov">California OES 
Server-Side Content Management 
83 

Chapter5 
84 
Auxiliary Communications Service</A> pages</LI> 
<ll> 
<A HREF="http: I /www.dot.ca.gov/dist06/paffairs/upscr. txt"> 
local Road Conditions</A></LI> 
<ll> 
<A HREF="http://www.races.neti">ACS/RACES Web Page</A><Ill> 
<ll> 
<A HREF ="http: I lwww. caiso. com/SystemStatus. html" >California 
Independent System Operator Status</A></LI> 
</Ul> 
<lTD> 
</TR> 
<TR> 
<TD> 
<CENTER><B><A NAME=fires><IA>Fires</B></CENTER> 
<lTD> 
<TD> 
<CENTER><B><A NAME=earthquakes><IA>Earthquakes</B></CENTER> 
<lTD> 
</TR> 
<TR> 
<TD VALIGN=top> 
<Ul> 
<LI> 
<A HREF="http: I /www. fire.ca.gov/">California 
Department of Forestry and Fire Protection</A></LI> 
</Ul> 
<lTD> 
<TD VALIGN=top> 
<Ul> 
<ll> 
Recent earthquake information from the 
<A HREF="http: I /quake.wr .usgs.govi">USGS</A><Ill> 
</Ul> 
<lTD> 
</TR> 
</TABLE> 
<HR> 
<FONT SIZE="-1">&copy; 1997-2001 SLVARES. Comments may be sent to the 
</FONT><A HREF= "mail to: slvares-webmaster@lothlorien. com"><FONT SIZE=" -1 ">SLVARES 
webmaster</FONT><IA><FONT SIZE=" -1 ">. <BR> 
This page was last updated on <!--#echo var="LAST_MODIFIED" -->.</FONT></CENTER> 

Server-Side Content Management 
< 1--#endif --> 
</BODY> 
</HTML> 
This page actually uses several server script directives. The first is the condi-
tional statement evaluating the HTTP_ USER_ AGENT variable, which uses the server 
directive i f-else-endi f to return content for either the AvantGo or a conven-
tional browser. The server directive include in both versions of the page includes 
the upcoming events calendar (sparing the administrator the need to edit the· 
main page when the calendar changes). The echo directive displays the last modi-
fication date for the page. 
I chose a short page with a link structure appropriate for synchronizing 
a browser for the AvantGo page (see Chapter 14, "Content Delivery"), while the 
conventional page, formatted for a desktop browser, contains related links that 
are of little use to mobile users. 
Note that using a regular expression when testing HTTP_ USER_ AGENT ensures 
that the server will return the AvantGo page for all versions of AvantGo. If I had 
written the following, it would have returned AvantGo pages only to AvantGo 
clients with version 3.2: 
<!--#if expr= "\"$HTTP_ USER_AGENT\" 
\"Mozilla/3.0 (compatible; AvantGo 3.2)\"" --> 
I could make this page support multiple browsers using the 
if-elif-else-endif construction, as follows: 
<!-- HTML header here --> 
<!-- Support for AvantGo --> 
< 1--#if expr="$HTTP _USER_AGENT = /AvantGo/". --> 
<META NAME= "HandheldFriendly" content= "True"> 
<!--Support for PalmVII --> 
< 1--#elif expr="$HTTP _USER_AGENT = /Elaine/" --> 
<MET A NAME=" PalmComputingPlatform" content= "True"> 
<!--Everybody else --> 
<!--#else--> 
<1--endif--> 
<1-- HTML trailer here --> 
85 

ChapterS 
86 
As you can imagine, however, this approach grows cumbersome quickly. It is 
more efficient to use the include directive in conjunction with long conditionals: 
<!-- HTML header here --> 
<!-- Support for AvantGo --> 
<!--#if expr="$HTTP _USER_AGENT = /AvantGo/" --> 
<!--#include file=" avantgo/index. html"--> 
<!--Support for PalmVII --> 
<! --#elif expr="$HTTP _USER_AGENT = /Elaine/" --> 
<!--#include file="palm/index.html"--> 
<!--Everybody else --> 
<1--#else--> 
<1--#include file=" other I index. html"--> 
<1--#endif--> 
<!-- HTML trailer here --> 
Of course, you can use a conditional to contain only a portion of a docu-
ment, too. The following snippet send~ a background image to all clients except 
Palm Powered handhelds using the Handspring Blazer browser (presumably 
because Windows CE users are known to use low-bandwidth connections): 
<!--Don't send our background to Palm Powered handhelds running Blazer! --> 
<1--#if expr="$HTTP_USER_AGENT = /Blazer/" --> 
<body> 
<!--#else--> 
<body background="images/swiss-cheese.gif"> 
<!--#endif--> 
For simple sites with problems such as these, server parsing with Apache 
provides a solution that is efficient, quick to implement, and easy to understand 
later when adding new content. For more complex sites, you have two choices: 
turn to an industrial-strength scripting language such as PHP (see Chapter 6, 
"Server-Side Content-Management Scripting'') or turn to a transcoding server. 
Using a Transcoding Server 
Yet another alternative to scripting is to use a transcoding server, a special kind of 
proxy server. These servers act as intelligent gateways, reducing Web content to 
a form suitable for the wireless network and the client device. The idea is not 

Server-Side Content Management 
new; AllPen Software demonstrated a prototype system for the Apple Newton in 
1995 and shipped a commercial system allowing handheld devices to view 
reduced HTML content in 1996. 
Transcoding servers enable content providers to create a single version of 
content, usually one intended for minimal-functionality desktop browsers, and 
still allow clients with bandwidth or other constraints who otherwise would be 
unable to read this content to have access to it. As content passes through the 
proxy server, its HTML is modified or removed as necessary to make the Web 
content appropriate for the wireless terminal. Advanced examples of this tech-
nology can often perform other operations, such as manipulating images, 
managing HTML content by applying scripts using the Document Object Model, 
or actually converting content from one format to another. 
Historically, network providers install a transcoding server to support a spe-
cific service, such as wireless access for a class of wireless handsets. Content 
providers are increasingly turning to these servers to meet the needs of different 
kinds of devices. 
Introducing IBM WebSphere Transcoding Publisher 
IBM's WebSphere Transcoding Publisher, originally developed as a proof-of-
concept by the alpha Works team at IBM, provides server-side bandwidth reduc-
tion and translates data from one representation to another. This proxy is capable 
of discarding HTML comments or JavaScript tags to reduce bandwidth, reducing 
tables to lists, or creating a text summary of a page by discarding formatting tags. 
In addition, it can reduce color images to monochrome or grayscale ones, reduce 
the amount of color to "thin'' an image, and supports popular formats including 
HTML, HTML for Palm Powered Devices, XML with XSL conversions (see 
Chapter 7, "eXtensible Markup Language), andVoxML. 
Introducing Spyglass Prism 
Probably the most widely used server-assist technology is Spyglass Prism, which 
is available from Open TV for Windows or Solaris servers. Currently used by com-
panies such as Fujitsu, Seiko Epson, and Riverbed Technologies, Spyglass Prism 
provides various kinds of mobile clients access to the Internet. 
Spyglass Prism allows operators to apply two key techniques to reduce the 
demands their content places on wireless access terminals. The most widely 
understood technique is content reduction, in which the proxy manipulates con-
tent from origin servers. Spyglass Prism can remove a set of HTML tags, render 
tables as fixed regions, and reduce image size by both scaling and removing col-
ors from images. 
87 

ChapterS 
88 
One particularly powerful converter module performs text extraction, 
whereby portions of a document are extracted from the source page and used to 
synthesize a new document. A client's request for a desktop URL causes the con-
verter module to perform a set of text extraction operations and create a new 
page to be returned to the client. '!YPically, this page is formatted more simply 
than the original, making it more appropriate for the wireless access terminal. 
A different component of Spyglass Prism performs each manipulation. This 
feature enables developers to create specific components for new applications-
for example, you could craft a component to convert GIF and JPEG images to 
PNG for a new minimal-functionality mobile browser that supported only PNG 
images. These components can be placed in any sequence required by a particu-
lar translation, which makes this technology highly efficient and flexible. For 
example, an image conversion module need only worry about the mechanics of 
actual conversion; if an operation is needed that also rescales the image, an 
image-scaling module can be placed ahead of the converter. 
Administrators can configure a database of devices and users, and it can 
instruct the proxy server to select an appropriate translation sequence based on 
the device type in question and a user identifier. An interface can also be con-
structed for network operators that allows different subscribers to select different 
levels of filtering based on such variables as the device being used, the cost of the 
wireless connection, and network bandwidth. Hooks are available for both 
authentication-based user logins and logins based on device authentication 
through a network ID or other mechanism. In addition, devices can identify 
themselves via a set of standard HTTP headers, which can be used to trigger spe-
cific translations based on configurations in the user and device databases. 
One innovative development Spyglass has created based on this is an 
HTML-WAP gateway, which allows WAP browsers-which in tum allow for only 
limited formatting within a screen-based user metaphor-to access HTML 
content. The possibilities for developers to combine Spyglass Prism with 
their content in similar ways are limitless. 
Using XML for Content Management 
Although I discuss XML in detail in Chapter 7, "eXtensible Markup Language," it 
is worth taking a high-levellook now at how XML can help you develop a device-
independent strategy for your content. 
XML lets you create arbitrary tags that define the relationship between bits of 
data in your content. For example, if you are building a site to handle news sto-
ries, you might define specific tags for a story's source, author, date, and time of 
the event, headline, abstract, keywords, and body. Using XML, you then mark up 
your content using these tags so that your server understands the relationships 
between the different parts of your content. This is in stark contrast to how many 

Server-Side Content Management 
other markup languages-notably HTML-work because without definite mean-
ings, your tags cannot direct the actions of an application like a browser directly. 
Instead, you can define a set of transformations using an XML language 
called the eXtensible Stylesheet Language (XSL) that lets you map your XML tags 
to another set ofXML tags. Returning to the news site, for example, you might 
specify that your headlines be contained within a markup language's title and 
heading tags and that the story abstract be hidden within a meta tag that defines 
search keywords. 
This notion of content-independent markup and transformation has been 
central to XML's adoption as the basis for markup languages includingWML and 
XHTML. Because these markup languages use the syntax ofXML, you can define 
transformations from your content's XML to them, letting you automate the pro-
cess of correctly formatting the content for each kind of device you must support. 
Although simple in theory, the problem is challenging enough that whole 
books have been written about the subject. The difficulties lie in several areas: 
• Capturing the structure of your data succinctly when defining the XML 
tags and relationships between the tags 
• Formally defining the tags' relationship using XML Schema or XML 
Document Type Definitions 
• Constructing transformations for each of your devices that not only format 
your data correctly but present usable man/machine interfaces on each 
kind of device 
• Building the back-end scripts that must access your content from your 
content database and perform the necessary transformations 
Of course, these are not insurmountable, and the gains are well worth the 
effort for large-scale sites that must serve content to many different kinds of 
devices or those sites that require content independence because they interface 
with other systems. 
NOTE 
If you are interested in learning XML and XSL for the purpose of 
content independence, I recommend you look atXML Programming 
Using the Microsoft XML Parser by Soo Mee Foo and Wei Meng Lee 
(Apress, 2002) and XML Programming: Web Applications and Web 
Services with JSP and ASP by Tom Myers and Alexander Nakhimovsky 
(Apress, 2002). 
89 

ChapterS 
90 
Summary 
Authors of sites that target several different devices have two options: present 
information in the lowest common denominator format or prepare content for 
different classes of devices. 
A combination of server-scripting technologies and careful organization of 
your site's contents makes content preparation for multiple kinds of devices 
a much easier task. Authors can use active server technologies such as PHP or 
ASP to build large sites, and small sites can often be supported with a simple 
technology such as Apache's server-parsed directives. 
To use any scripting technology effectively, it is crucial to divide your content 
into data and format information. By identifying what your site presents-its 
data-from how it is presented, you can use scripts to assume the responsibility 
of formatting data. 
These scripts will use cues from the browser, such as the HTTP headers 
User-Agent and Http-Accept to determine the nature of the device originating the 
request. Armed with this information, the scripts can select format tags most 
appropriate for the client device. 
The Apache server-side parsing module provides some primitive server 
directives that you can use with simple sites to differentiate among different 
client types. Its chief strength is its simplicity; with only a handful of directives to 
learn, you can master it in an afternoon or use its ability to run external scripts 
to enhance your site. This simplicity is also its drawback; it's difficult to organize 
a complex site using just markup content and Apache server directives. 
Iranscoding servers intervene between the origin and destination of content, 
modifying the content to meet the constraints of a partictilar device. Images can 
be reduced, text formatted, and other operations performed to enhance the 
experience of users accessing existing Web content using a handheld device. 
Several commercial options from reputable companies including IBM and 
Open TV are available, and both network operators and large-scale content 
providers use them today. 

CHAPTER 6 
Server-Side 
Content-Management 
Scripting 
MosT, IF NOT ALL, MOBILE users seek access to dynamic content. They want immedi-
ate information. With few exceptions, people can wait for access to static content 
until they return to their homes or offices. However, even static content-maps, 
travel directions, or other material-can often be more useful with dynamic 
updates; for example, in the case of travel directions, up-to-date information on 
traffic, road hazards, and so on would be more beneficial. 
Even when content is truly static, a dynamic content strategy such as server-
side scripting can generalize the content of a site for different classes of devices. 
Separating the format from the data when authoring lets you create one set of 
information for many kinds of clients. 
In this chapter, I explore PHP: Hypertext Processor (PHP), an open source, 
server-side scripting language that you can use to build wireless Web sites. Mter 
this introduction to PHP, I show you how to use PHP to solve one of the most vex-
ing problems facing today's wireless sites: server-side content management. 
Creating PHP-Powered Wireless Web Sites 
You can use active scripting technologies such as PHP to offer dynamic content, 
including supporthig multiple clients. PHP includes constructions for flow con-
trol, a rich library of functions, and database interfaces. You can embed PHP 
within a Web document, or you can use it to generate documents through the 
execution of scripts. Scripts execute within the process and memory space of the 
Web server, although you can invoke system commands using two functions that 
create a new process and run any command on the system. Best of all, it is free. 
PHP is an open-source project. Maintained at www. php. net, PHP was started 
by Rasmus Lerdorf and blossomed with the efforts of several contributors. It is 
a robust, stable, active scripting environment used by more than a 100,000 Web 
sites, many of them commercial services. Many Internet Service Providers (ISPs) 
make PHP available to subscribers, enabling you to create a service quickly while 
91 

Chapter6 
92 
leaving the task of installing PHP and maintaining servers and the Internet con-
nection to an expert. 
Introducing PHP 
A thorough introduction to PHP would (and does) occupy an entire book-see 
A Programmer's Introduction to PHP 4.0 by W. J. Gilmore (Apress, 2000) or 
Wireless Web Development with PHP and WAP, by Ray Rischpater (Apress, 2001). 
I only scratch the surface in the following discussion. I show you how PHP is inte-
grated with a Web page, as well as the basic syntax of PHP commands, functions, 
and flow-control statements. With this knowledge, you will be able to understand 
the examples in the "Building a PHP-Based Wrreless Web Site" section, and you 
should be able to create simple PHP pages. To learn more about PHP, consult the 
online documentation at the PHP Web site or your local bookstore. 
Usage 
PHP scripts exist between special delimiters within a content file-such as 
a HyperText Markup Language (HTML) file, although, as you will see, you can 
also use PHP scripts with Wrreless Markup Language (WML) or any other 
markup language served by HyperText Transfer Protocol (HTTP) servers. PHP 
scripts begin with the special tag< ?php and end with the tag ?>. (You may 
encounter scripts enclosed simply by the tags <? and 7>, but this abbreviated 
form is discouraged in wireless Web development because the tag < ?php is XML-
compliant and more likely to work with future server-side wireless applications.) 
You save the content as a file with a specific suffix, usually o php or o php, that tells 
the server the PHP interpreter should process the file. As the server sends the file 
to the client, it first uses the PHP interpreter to process the scripts, replacing 
each script with the output the script generates. For example, the following page 
produces the output shown in Figure 6-1: 
<HTML> 
<HEAD> 
<TITLE>Hello</TITLE> 
</HEAD><BODY> 
<?php 
print("Hello world. Today is "); 
print(Date("l d F Y")); 
print(".\n"); 
h 
</BODY> 
</HTML> 

Server-Side Content-Management Scripting 
This page consists of some introductory HTML and a single PHP script. The 
script prints a series of three strings to the client: two are static, and the PHP 
function Date creates the third, which returns a string containing the date in the 
requested format. 
Figure 6-1. A simple PHP script's results 
You can rewrite this script so the PHP is responsible for generating the entire 
required content, as shown here: 
<?php 
?> 
print(" <HTML> \n"); 
print("<HEAD>\n"); 
print("<TITLE>Helloc/TITLE>\n"); 
print("</HEAD><BODY>\n"); 
print("Hello world. Today is "); 
print(Date("l d F Y")); 
print(".\n"); 
print("</BODY>\n"); 
print("<IHTML>\n"); 
In practice, this approach creates pages that are both easier to maintain and 
easier to extend for supporting different clients. It can, however, be somewhat 
baffling to newcomers because the entire page's content is written in PHP. In the 
sections that follow, I follow the convention that PHP mixed with other Web con-
tent is always bracketed by the < ?php and > tags; I leave these tags off for PHP 
script snippets not meant to stand alone, reminding you they are only examples, 
not complete scripts. It is important to remember that you can use PHP to create 
content for other markup languages, too. Doing this requires an extra step: The 
PHP script must inform the client of the content type returned using an HTTP 
header. PHP provides a function to modify this header, as shown here: 
<?php 
II Specify our content type 
header("Content-type: text/x-hdml"); 
93 

Chapter6 
94 
I* and produce an HDML deck. */ 
print("<HDML VERSION=3.0>\n"); 
print("<DISPLAY MARKABLE=\ "TRUE\" TITLE=\"Hello\" NAME=\ "hello\ ">\n"); 
print{"Hello world. Today is "); 
print(Date{"l d F Y")); 
print(".\n"); 
print("</DISPLAY></HDML>\n"); 
PHP supports C++-style comments. You can use the I I characters at the 
beginning of a line to mark the rest of it as a comment, and you can use the I* 
and *I characters anywhere on a line to treat the content between the characters 
as a comment. In the preceding example, the second and fourth lines of this 
script show the two ways to include a comment in a script. 
The third line instructs the Web server to return the HTIP header 
Content-type to the server, specifying that the content in this document will be 
Handheld Device Markup Language (HDML) content written in text. By using the 
appropriate content type declaration, you can have your PHP scripts return 
HTML, images, HDML, or WML. (This instruction must occur before any out-
put-including white space-from your content or PHP script, however, or the 
Web server will assume your content is HTML.) 
Syntax 
As you have already seen, you express a PHP script by a set of comments, key-
words, and function invocations. These expressions, which are separated from 
one another by a semicolon (;) as in most other languages patterned after Pascal 
and C, comprise identifiers and operators. An identifier is a variable or function 
name; an operator is a one- or two-character keyword that manipulates identi-
fiers. Examples of operators include arithmetic operators,. addition ( +), 
subtraction (-),division(!), and multiplication(*), along the dot or string con-
catenation (.) operator. You group statements into blocks using curly braces ( { 
and}). 
Variables 
Variables contain data that may change during the evaluation of a script. You 
name variables using a sequence ofletters, numbers, and underscores, subject to 
the following rules: 

Server-Side Content-Management Scripting 
• The first character of a variable identifier must be a dollar sign($). 
• The second character of a variable identifier must be a letter (a-z, A-B) or 
an underscore (_). 
• All other characters of the identifier must be letters, numbers, or under-
scores. 
PHP is case-sensitive; thus, the identifiers $myHome and $MYHOME are different. 
As you will see when I show you how functions are named, because all variable 
names begin with a $, you can use the same name for both a variable and 
a function. It is a good idea to avoid doing this, however, because you can easily 
get confused between the two. 
Variables may contain strings, integers, or floating-point numbers. PHP is 
loosely typed; a variable may contain any data type. '!ype conversions occur 
automatically when necessary so that expressions handle the conversion 
between strings and numbers transparently, such as the following: 
$x = "4"; $result = $x * $x; I I $x is converted to an integer 
print( $result ); II $result gets converted to a string before 
II output 
PHP dynamically creates variables as they are encountered. So, there is no 
need to declare a variable the way there is in many compiled languages. 
Variables can also hold arrays. An array can be indexed either by an integer 
or by the names of items within the array (these are known as associative arrays 
in other programming languages). The array function enables you create and ini-
tialize an array in a single step, as shown here: 
$pets=array( "dog"=>"Sake", 
"cat"=>"Kashka", 
"bird"=>"Tau" ); 
$days=array( O=>"Sunday", 
l=>"Monday", 
2=>"Tuesday", 
3=>"Wednesday", 
4=> "Thursday", 
S=>"Friday", 
6=>"Saturday"); 
95 

Chapter6 
96 
To access an array, you specify the index using the index ([]) operator: 
$today=$days[ 4]; 
print( $pets["dog"] 
"never did get the hang of " 
$today • ".\n" ); 
Functions 
You define functions using the function statement: Following the function state-
ment, you specify first the function's name and any arguments, and then the 
body of the function as a block: 
function doHeading( $heading ) 
{ 
print("<Hl>" • $heading • "<IHl>" ); 
} 
Variables used within a function have scope only through the function in 
which they are used. A function can return a result value to the function's caller 
using the return statement, as shown here: 
function square ( $x ) 
{ 
} 
$result = $x * $x; 
return $result; 
When a function must access a variable declared outside a script-called 
a global variable because its scope extends throughout a script-it must be 
explicitly declared using the global statement. This helps prevent accidental use 
or modification of global variables: 
$PI = 3.1415926536; 
function area( $radius ) 
{ 
} 
global $PI; II use this file's $PI. 
return $PI * square( $radius ); 

Server-Side Content-Management Scripting 
Functions can declare default values for variables, too. For example, later in 
the section "Building a PHP-Based Wireless Web Site," I show you the following: 
function hl( $head, $align="center" ) 
{ 
print(" <Hl ALIGN=$align>" • $head . "</Hl> \n"); 
} 
This function produces an HTML header tag with the alignment specified by 
the caller of the function; by default, $align is set to "center", and the header is 
centered on the page. 
Flow Control 
PHP provides conditional flow control in the form of the if-else, if-elseif-
else, and switch-case statements. The syntax of these statements strongly 
resembles that of other programming languages: They accept an expression to 
evaluate and blocks to execute if the expression is true or false. For example, the 
if statement looks like this: 
if ( $anchor ) 
{ 
print("<A NAME=\ "$anchor\ ">\n"); 
} 
This statement prints a string containing the anchor tag and the anchor 
name if and only if $anchor is not an empty variable. 
The if statement may be followed by an optional else clause or by one or 
more elsei f clauses to support multiple logic paths. For example: 
if ( strstr( $userAgent, "Windows CE" ) I I 
strstr( $userAgent, "WinCE" ) ) 
{ 
} 
$UserAgentType = "WinCE"; 
$UserAgentClass = "html-lo"; 
else if ( strstr( $userAgent, "AvantGo" ) ) 
{ 
} 
else 
$UserAgentType = "AvantGo"; 
$UserAgentClass = "html-lo"; 
97 

Chapter6 
98 
{ 
} 
$UserAgentType = "unknown"; 
$UserAgentClass = "html-hi"; 
Sometimes, it is clearer to use the switch statement. The switch statement 
takes a set of case statements and code to execute when one of the case con-
ditions matches. Execution then continues through the remaining cases: 
switch( $shape ) 
{ 
case "triangle": 
$kind= "pointy"; 
break; 
case "square": 
$kind= "rectangular"; 
break; 
case "circle": 
case "oval": 
$kind = "round"; 
break; 
default: 
$kind="unknown"; 
} 
In this example, if$shape is either "circle" or "oval", $kind will be setto 
"round". The break statement causes execution to continue outside the current 
block, so in the case that $shape is equal to "triangle", $kind is set to "pointy", 
and execution continues outside the switch statement. 
The switch statement can support a block that will be executed if no other 
conditional matches, called the default, which is declared using the default 
statement. In the previous example, $kind is set to "unknown" if$shape does not 
match one of the "triangle", "square", "circle", or "oval" strings. 
Looping 
Loop statements in PHP come in three flavors: while, do-while, and for. The 
while statement executes a block only while its test condition is true. The script 
that follows, for example, executes the block each time it loops back to it as long 
as $n is greater than zero: 

Server-Side Content-Management Scripting 
$n = $initial; 
while {$n > o) 
{ 
} 
$result = $result * $n; 
$n = $n - 1; 
Note that if $n is zero when the while statement is reached, the block is 
skipped altogether. In contrast, the do-while statement always executes its block 
the first time it is encountered, then applies the condition. Thus, the following 
example will not necessarily yield the same results as the previous one: 
$n = $initial; 
do 
{ 
} 
$result = $result * $n; 
$n = $n - 1; 
while {$n > o); 
In this case, the operation of multiplying $result by $n will always be exe-
cuted at least once, before the comparison with $n takes place. 
In many cases, the for statement is both more convenient and easier to read 
than do or do-while. It is functionally equivalent to the while statement, but 
divides a loop into four constructions: 
• The initial conditions for the loop 
• The statements to be executed each time the loop is executed 
• A conditional statement Ooop execution continues if it returns true) 
• The block to be executed through the loop 
For example, you could rewrite the first loop using the for statement: 
for ( $n = $initial; $n > o; $n = $n - 1 ) 
{ 
$result = $result * $n; 
} 
Here, $n is set to $initial once. The loop block (the statement $result = 
$result * $n) executes each time $n is found to be greater than zero; after the 
99 

Chapter6 
100 
loop block, $n is decremented. Once $n is equal to zero, the loop stops, and 
the instructions immediately after the loop execute. 
The break statement encountered in the switch-case statement is especially 
handy when working with loops. For example, the following section of code 
shown examines the array of headers returned by getallheaders, stopping when 
the User-Agent header is found: 
$headers = getallheaders (); 
for ( $value = reset ($headers) ; 
$index = key( $headers ) ; 
$value = next( $headers ) ) 
{ 
if ( strcasecmp( $index, "user-agent" ) == 0 ) 
{ 
} 
} 
$userAgent = $value; 
break; 
In this routine, the PHP getallheaders function retrieves the HTTP headers 
the client and server exchanged in the associative array $headers. The for loop 
initializes an iteration across all array elements using the reset function and then 
loops through each value in the array. On each pass, the for statement sets 
$index to the name of the current entry, with the key function and $value set to 
the current entry's contents using the next function. The next function also 
advances, and on each loop, the key and next functions to fetch the next element 
of the array. When the end of the array is reached, both key and next return an 
empty string; this string is evaluated as false, and the loop terminates. On each 
pass through the loop, $index is compared to the string "user-agent", and if the 
two are equal (irrespective of case), the value of that array element is saved in 
the variable $user Agent, and the loop ends. 
Importing Files 
PHP provides literally hundreds of functions for developing Web content. I have 
already mentioned several, including print, reset, key, and next; there is not 
nearly room to cover them all. But I do want to introduce one more function you 
will find useful, include, which imports the contents of a file into the current 
script. The include function is most often used to share common functions 
across multiple scripts. For example, the examples in the next section make use 
of a number of functions used in multiple PHP scripts, all of which are saved in 
the file nameUserAgent. php. This means that that the following statement: 

Server-Side Content-Management Scripting 
include{ "nameUserAgent.php" ); 
within any script allows access to all the functions within that file. The include 
function thus permits you to keep common functions in one location; if a func-
tion changes, you need to edit only one file. 
Building a PHP-Based Wireless Web Site 
Let's tum from a description of PHP to seeing it in action. For this example, let's 
look at APRS/Find, a wireless Web application that obtains a person's position 
and presents it to mobile clients. (For more information about APRS, see the 
sidebar.) The application obtains and returns a station's position in a format opti-
mized for the current client device by a set of PHP scripts. PHP allows the service 
to return content formatted for a host of different devices, including screen 
phones, using the same script. 
What Is APRS? 
The Automatic Position Reporting System (APRS) is a system developed by Bob 
Bruninga, WB4APR, that uses amateur ("ham") radio to transmit position 
reports, telemetry, and messages between users. Amateur radio operators rou-
tinely use it in public service, during emergencies, and just for fun. The APRS 
network covers the continental United States and much of the world via a far-
flung assortment of amateur radio stations and Internet gateways that carry 
APRS traffic from one area to another. 
Stations within the APRS network are referred to by their call signs. Each 
one is a unique identifier indicating a specific amateur radio operator. 
For more information about APRS, visit one of these sites: 
• Bob Bruninga's APRS page (web. usn a. navy. mil!-bruninga/ aprs. html) 
• Tucson Amateur Packet Radio (www. tapr. org) 
For more information about amateur radio, visit the Amateur Radio Relay 
League's Web site at www. arrl. org. 
Script Organization 
I divided these back-end scripts into several functional groups. One script, 
nameUserAgent. php, is responsible for identifying the current client based on 
HTTP headers. The format. php and aprs-image. php scripts use this information 
101 

Chapter6 
102 
to define a series of functions, which the locate. php script uses to build 
a response page. The locate. php script also accepts the form data posted by a 
wireless Web client. It then invokes a command to determine the requested 
station's position and uses the other scripts to build a response. 
The nameUserAgent. php script defines the nameUserAgent function, which 
other scripts use to determine what kind of client from which the request origi-
nated. It uses a table of comparisons to establish two pieces of information about 
the client: its type and its class. I define a type as a loose identification of a device 
by its manufacturer or form factor, such as Palm, WinCE (Microsoft Windows CE), 
or phone. I think of class as the kind of content a client can accept. A client's class 
is named by one of two strings: 11 html-hi 11 , which indicates desktop-fidelity 
HTML and II html-lo II, which indicates a wireless browser that accepts HTML 
content. 
NOTE 
By desktop-fidelity, I mean HTML content appropriate for today's 
high-end browsers, such as the latest versions of Microsoft Internet 
Explorer or Mozilla. 
Format scripts select a specific set of functions for formatting content based 
on the class of the device. These are stored in a file called xxx-format.php (that is, 
html-hi-format • php, html-lo-format. php, or other files following the same con-
vention). Each of these files defines the functions shown in Table 6-1. In addition, 
the locate. php script uses the indication of what class a browser is to select what 
format scripts will generate the map shown in the response using the 
xxx-aprs-image.phpscripts(html-hi-aprs-image.php,html-lo-aprs-image.php, 
and so on). 

Server-Side Content-Management Scripting 
Table 6-1. Functions Used to Generate Result Data 
FUNCTION 
doc Begin 
doc End 
paraBegin 
para End 
h1 
hr 
br 
bold 
ARGUMENTS 
$title 
$tag 
$heading,$align 
$text 
Response Generation 
PURPOSE 
Begins a document with the given title 
Ends a document 
Begins a paragraph and anchors it 
with the indicated tag 
Ends the current paragraph 
Creates a levell heading with the 
given text and alignment 
Draws a horizontal rule 
Creates a line break within 
a paragraph 
Outputs the specified text in boldface 
if supported 
The heart of the response generation occurs in the locate. php script. The server 
invokes this script in response to a client's form POST request. Forms using this 
script provide two variables in their POST request: call sign and scale. The for-
mer contains a call sign of the desired station, and the latter contains an optional 
map scale for the resulting map. The values of these variables are available within 
the PHP scripts as $callsign and $scale. 
A simple form that interacts with the locate. php script looks like Listing 6-1. 
Listing 6-1. A Simple Form 
<HTML> 
<HEAD> 
<TITLE>APRS/Find</TITLE> 
</HEAD> 
<BODY> 
<H1 ALIGN=right>APRS/Find</H1> 
<P> 
<HR> 
<FORM ACTION="locate.php" METHOD=POST> 
103 

Chapter6 
104 
<P>Callsign: <INPUT TYPE=text NAME=callsign VALUE="" SIZE=10 
MAXLENGTH=10><BR> 
Scale:<BR> 
<SELECT NAME=scale value=""> 
<OPTION VALUE=100000>1 mi 
<OPTION VALUE=200000>2 mi 
<OPTION VALUE=500000>8 mi 
<OPTION VALUE=3200000>50 mi 
</SELECT> <INPUT TYPE=hidden NAME=version VALUE=2 size=1 maxlength=1><BR> 
<INPUT TYPE=submit NAME=Submit VALUE="Map" size=O maxlength=O> 
</FORM><A HREF="about. html">About</A> - <A HREF="credits.html ">Credits</A> 
<HR> 
<IP> 
</BODY> 
</HTML> 
A closer look at locate. php reveals how the script selects the output format 
and the data obtained and presented. The first few lines are responsible for deter-
mining the client's class and type: 
<?php 
?> 
II Include the findu interface. 
include( "findu.php" ); 
II Determine our user agent. 
include( "nameUserAgent.php" ); 
nameUserAgent(); 
II load our format scripts for this user agent. 
$uac = userAgentClass (); 
$uat = userAgentType(); 
include ( "${uac}-format.php" ); 
include ( "${uac}-aprs-image.php" ); 
II The rest of the script follows 
This portion of the script includes the nameUserAgent • php script, which I dis-
cuss next. Suffice it to say this script defines the functions nameUserAgent, 
userAgentClass, and userAgentType, which together identify the client by its 
HTTP headers. The locate. php script uses this information to include one of the 
xxx.format.php files and one of the xxx-aprs-image.php files. Together, these two 

Server-Side Content-Management Scripting 
files define the functions responsible for formatting the output generated by the 
locate. php script. I examine them more closely in the "Presentation for HTML 
Browsers" section. 
Once the determination of format scripts is complete, the locate. php script 
uses a binary provided by the host system to locate the station by its call sign, as 
shown here: 
II Find the given station 
$result = finduWhereis( $callsign ) ; 
$call = $result[ 'call' ] ; 
$lat 
$result[ 'lat' ]; 
$Ion = $result[ 'Ion' ] ; 
$posAsStr="${result[ 'latDeg' ]} ${result[ 'latMin' ]} ${result[ 'latSec' ]}". 
" ${result[ 'lonDeg' ]} ${result[ 'lonMin' ]} ${result[ 'lonSec' ]} "; 
The finduWhereis function, defined in findu. php, contacts a remote server, 
passes on the call sign, and parses the response data. This function uses a com-
mon trick in PHP, returning several computed variables as elements of an 
associative array. The locate. php script parses the response from locate-staton 
into a series of variables. These variables describe the station's call sign, position 
as both floating-point numbers and human-readable strings. 
With the result data in hand, the locate. php script uses the format functions 
you have defined to generate the response in Listing 6-2. 
Listing 6-2. The Response 
II Present the results 
docBegin( $call ); 
h1( $call, "right" ); 
paraBegin(); 
if ( $result[ 'result' ] = = "ok" ) 
{ 
} 
map( $lat, $lon, $call, $scale, $uat ); 
br(); 
print( "Position $posAsStr " ) ; 
br(); 
else 
105 

Chapter6 
106 
{ 
print( "The server encountered an error." ); 
} 
paraEnd(); 
docEnd(); 
The work done by this portion of the script is straightforward. The script uses 
the format functions to output a document header using the station's call sign as 
a title. Then it creates a header, followed by the beginning of a new paragraph. 
The script outputs either a position report or an error message. This output is 
sandwiched between the markup language's document heading tags and closing 
tags. The position report contains a map, generated by the map function defined 
in the xxx-aprs-image.php file included at the beginning of the script, and 
the station's latitude, longitude, course, and status. Once the script reports the 
dynamic content, it ends the open paragraph and document and then 
terminates. 
Client Identification with PHP 
As mentioned previously, the nameUserAgent. php file contains the functions that 
perform client identification. This file defines three global variables used to track 
the client's identity, along with functions to obtain the values of these variables. 
Although it is not necessary, I chose to use access functions to return the value of 
these variables, rather than referring to them directly outside of the file. This is 
a good example of data abstraction, as it hides the representation of the data 
from entities that do not need that level of detail. By obscuring the nature of 
these variables, I minimized the opportunity for other scripts to accidentally 
manipulate or destroy them. You can see an example of data abstraction in this 
userAgentType function: 
<?php 
$User Agent Type = "unknown"; 
function userAgentType( ) 
{ 
} 
?> 
global $UserAgentType; 
return $UserAgentType; 

Server-Side Content-Management Scripting 
The nameUserAgent function sets the various global variables used by the data 
abstraction layer (see Listing 6-3). 
Listing 6-3. The nameUserAgent Function 
<?php 
function nameUserAgent( ) 
{ 
global $UserAgentType; 
global $UserAgentClass; 
$user Agent = ""; 
$userAccepts = ""; 
II Find the User-Agent header and get its value. 
$headers = getallheaders(); 
for ( $value = reset ($headers); 
$index 
key( $headers ); 
$value = next( $headers ) ) 
{ 
if ( strcasecmp( $index, "user-agent" 
o ) 
{ 
$userAgent = $value; 
} 
if ( strcasecmp( $index, "http-accept" 
0 ) 
{ 
$userAccepts 
$value; 
} 
} 
II Set the client name appropriately. 
if 
strstr( $userAgent, "Windows CE" ) II 
strstr( $userAgent, "WinCE" ) ) 
{ 
} 
$UserAgentType = "WinCE"; 
$UserAgentClass = "html-lo"; 
elseif ( strstr( $userAgent, "AvantGo" ) ) 
{ 
} 
$UserAgentType = "AvantGo"; 
$UserAgentClass = "html-lo"; 
elseif ( strstr( $userAgent, "Elaine" ) ) 
{ 
$UserAgentType = "Palm"; 
107 

Chapter6 
108 
} 
$UserAgentClass = "html-lo"; 
} 
elseif ( strstr( $userAgent, "Blazer" ) ) 
{ 
} 
$UserAgentType = "Palm"; 
$UserAgentClass = "html-lo"; 
elseif ( strstr( $userAgent, "Mozilla" ) ) 
{ 
} 
$UserAgentType = "desktop"; 
$UserAgentClass = "html-hi"; 
return $UserAgentType; 
This script performs two basic tasks: It obtains information from the HTIP 
headers and uses that information to make an educated guess about the kind of 
browser making the request. 
This script uses the PHP function getallheaders to obtain all headers 
exchanged between client and server. It then searches for the User-Agent and 
Http-Accept headers, used by convention to specify the browser's identity 
and the kind of content it will accept. With this information, a set of comparisons 
identify first the client type and class. 
I obtained the User-Agent and Http-Accept header values used in this 
function from two sources. Many mobile browser vendors make their headers 
available to content developers in developer documentation. For some browsers, 
however, this information may be difficult to collect, either because the browser's 
vendor has not provided the information or because the vendor no longer exists. 
An easy way to obtain the information is to examine the log file of an HTTP 
server after the client downloads a page. Even easier, however, is to use this sim-
ple PHP script, which prints the headers back to the client in response to 
a request. 
The following script simply loops over all headers exchanged between client 
and server, and then prints them as successive paragraphs in an HTML docu-
ment to be displayed by the client: 
<?php 
$headers = getallheaders (); 
print ("<HTML><BOOY>"); 
for ( $value = reset ($headers) ; 

Server-Side Content-Management Scripting 
} 
{ 
$index = key( $headers ) ; 
$value = next( $headers ) 
print ("<P>"); 
print ( $index ); 
print ("=<BR><IP><P>"); 
print ($value) ; 
print ("<IP>"); 
print ("<IBODY><IHTML >"); 
?> 
Returning to the implementation of nameUserAgent, it is obviously incom-
plete because it omits several popular browsers including Internet Explorer, 
Opera (both for the desktop and handhelds), pdqSuite for the Palm Computing 
Platform, and several others. (In fact, you can get away with this for desktop 
browsers because almost all desktop browsers send the word Mozilla as part of 
the User-Agent header.) To keep from overwhelming low-fidelity browsers, I used 
a copy of the format script for the html-lo class of devices as the default format 
script for unknown browsers. 
Presentation for HTML Browsers 
By separating the instructions for how the data is presented-its format-from 
the data itself, PHP enables you to easily add new format modules on a per-
browser or per-class basis. In this example, there are only a few basic differences 
among the versions for different browsers because the content is so simple. In 
fact, only the docBegin function and the map presentation differ between the 
html-hi and html-lo browser classes. 
The html-hi-format.php file for this example is instructive because it demon-
strates one way to separate data from formatting. This file defines functions 
(again, see Table 6-1) that provide abstractions for the HTML tags used by 
locate. php. You can modify these abstractions, in tum, to produce different 
markup tags to suit different browsers as necessary. 
The html-hi-format.php file looks like Listing 6-4. 
Listing6-4. Thehtml-hi-format.php File 
<?php 
function docBegin( $title ) 
{ 
II Specify our content type 
header("Content-type: textlhtml"}; 
109 

Chapter6 
110 
} 
II emit heading tags. 
print("<HTML>\n"); 
print("<HEAD>\n"); 
print("<TITLE>$title<ITITLE>\n"); 
print("<IHEAD>\n"); 
print("<BODY>\n"); 
function docEnd{ ) 
{ 
} 
print("<IBODY>\n"); 
print("<IHTML>\n"); 
function paraBegin( $anchor = "" ) 
{ 
if ( $anchor ) 
{ 
print("<A NAME=\ "$anchor\">\n"); 
} 
print("<P>"); 
} 
function paraEnd( 
{ 
print("<IP>"); 
} 
function h1( $head, $align="center" ) 
{ 
print(" <H1 ALIGN=$align>$head<IH1> \n"); 
} 
function bold{ $head ) 
{ 
print("<B>$head<IB>\n"); 
} 
function hr{ 
{ 
print("<HR>\n"); 
} 

Server-Side Content-Management Scripting 
function br( ) 
{ 
} 
?> 
print("<BR>\n"); 
One pair of functions that shows how the format abstraction layer works is 
the docBegin and doc End functions, which generate the tags that open and close 
a document. The docBegin function specifies the content type of the document 
sent to the browser, along with the heading of the document. The HTML imple-
mentations specify an HTML document and use the HTML <HTML>, <HEAD>, 
<TITLE>, and <BODY> tags to perform this task. After specifying the content type, 
the doc Begin function outputs a bare-bones HTML header, the document title, 
and the opening <BODY> tag. Scripts use subsequent calls to functions in this file, 
along with the print function to build the response document. When the docu-
ment creation is complete, the calling script uses the doc End function to close the 
document (in the case of an HTML device, the output is the closing </BODY> tag). 
Similarly, the xxx-aprs-image. php script files define the map function for vari-
ous browser classes. This function is responsible for using a supplied latitude, 
longitude, scale, and legend to generate an <IMG SRC> statement containing 
a URL, which in turn obtains the corresponding map from a map server. The 
html-hi-aprs-image.php script defines the map function (see listing 6-5). 
Listing 6-5. Defining the Map Function 
c?php 
function map( $lat, $lon, $legend, $scale, $type ) 
{ 
$imgsize = 300; 
II Goofy scaling to map from miles scale to tiger's internal scaling. 
$size = 
( $scale * 0.0000137671428571 - 0.606057142857 ) I 60.0 ; 
if ( strpos( $legend, "-" ) ) 
{ 
$call = strtoupper( 
substr( $legend, o, strpos( $legend, " " ) ) ); 
} 
else 
{ 
$call = strtoupper( $legend ) ; 
} 
111 

Chapter6 
112 
} 
?> 
print("<IMG SRC=\ '"'); 
print ("http: I /tiger. census. gov I cgi-bin/mapgen ?Ion= $lon&lat =$lat&" 
"iwd=$imgsize&iht =$imgsize&wid=$size&ht =$size&" • 
"mark=$lon, $lat, cross, $call;&on=places,majroads, streets, railroad"); 
print("\" ALT=\"Map around $lat $lon\">\n"); 
This function builds a URL in the format required by the database from 
which the maps are obtained (see the "The Tiger Map Database" sidebar for more 
information). This URL specifies the map's center latitude and longitude as well 
as the image size, the scale, the legend, and the themes to display. The function 
derives the latitude, longitude, and scale information from its arguments. It then 
converts the map scale, which is provided by $scale from the form input, into 
decimal degrees, and it then processes the legend to make a more attractive label 
on the map. The size of the image is controlled by the global variable $imgsize, 
which was defined as a variable at the top of the file to make it easy to revise if the 
script needs changing. 
What Is the Tiger Mapping Service? 
One of the handiest resources on the Web for prototyping new services is the 
United States Census Bureau Tiger Mapping Service at tiger. census. gov. The 
Tiger Mapping Service offers free geographic and thematic maps as GIF images 
based on 1990 Census data for the entire United States. 
Although not appropriate for commercial systems-the Census Bureau 
does not guarantee the server's reliability, and the system does not support 
commercial deployment per se-the server provides excellent maps for rapid 
proto typing and demonstration uses. A more sophisticated system, the 
American FactFinder, has replaced the Tiger Mapping Service, which was an 
experiment in Web-based mapping. Although the American FactFinder con-
tains more up-to-date content and is a more reliable service, the Tiger Mapping 
Service remains a great resource for online maps for prototyping and will likely 
be available for years to come. 
URLs supplied to the map server can specify a map's size in degrees, the 
resulting image size in pixels, and the specifics of the location to display. You 
can add annotations at specific points, as I did with the APRS/Find wireless 
application. In addition, the server can overlay thematic data such as popu-
lation, age distribution, and other information on generated maps. 

Server-Side Content-Management Scripting 
In Figure 6-2 you can see the server's response for Microsoft Internet 
Explorer, a high-fidelity browser. 
kf6gpe 
Po-ition 3 
10' 30'' 122° 8' 42" 
\ 
".. 
'i 
Figure 6-2. APRS/Find viewed with Microsoft Internet Explorer 
Figure 6-3 shows how the same data looks on a Palm Powered device running 
Handspring Blazer, which I classify as a low-fidelity browser. Although the infor-
mation contained is the same, the map format is radically different. 
osition3718.5QN, 1228.78W. 
osition report rtuHtd S llinu~ts 21 
t<ondsoqo.. 
Figure 6-3. APRS/Find viewed with Handspring Blazer 
113 

Chapter6 
114 
The html-lo-aprs-image.php script, which locate.php includes when the 
client is a low-fidelity HTML browser, requests a significantly smaller map. This 
script looks like Listing 6-6. 
Listing 6-6. The html-lo-aprs-image. php Script 
<?php 
function map( $lat, $lon, $legend, $scale, $type ) 
{ 
} 
7> 
$imgsize = so; 
II Goofy scaling to map from miles scale to tiger's internal scaling. 
$size = ( $scale * 0.0000137671428571 - 0.606057142857 ) I 60.0 ; 
if ( strpos( $legend, "-" ) ) 
{ 
$call = strtoupper( 
substr( $legend, o, strpos( $legend, " " ) ) ); 
} 
else 
{ 
$call 
strtoupper( $legend ); 
} 
print("<IMG SRC=\""); 
print ("http: I /tiger. census. gov I cgi-bin/mapgen ?lon = $lon&lat = $lat&" 
"iwd = $imgsize&iht =$imgsize&wid = $size&ht =$size&" • 
"mark=$lon, $lat, cross, $call;&on=places ,majroads, streets, railroad"); 
print("\" ALT=\"Map around $lat $lon\">\n"); 
This map function centers the resulting map, which is smaller than the one 
generated by html-hi-aprs-image. php. 
Summary 
PHP is a powerful, open-source solution for generating active server content 
using the most popular Web servers today. Like other scripting languages includ-
ingActive Server Pages (ASP), PHP lets you imbed instructions within your 

Server-Side Content-Management Scripting 
content for the scripting engine to perform before the server delivers the content 
to the client. 
Within your content, you enclose your scripts with the special characters 
< ?php and ?>. Scripts themselves may define variables and functions and alter the 
flow of control of the PHP script engine as well as call functions defined within 
the PHP scripting engine or those you have defined previously. 
PHP's syntax is a blend of that from other procedural languages, notably 
C. Unlike C, however, PHP is more fluid, providing dynamic variables, weak 
typing, and associative arrays as well as the more fundamental data types 
and constructions. 
115 

CHAPTER 7 
eXtensible Markup 
language 
XML rs THE IJNGUA FRANCA of the wireless Web. Its strength is in its generality: XML 
can describe virtually any kind of structured data. Once described, the data can 
be presented in other formats. Moreover, XML is already being used for a host of 
server-server communication applications, which make it possible for different 
data servers to easily exchange information. The trend toward a co~on format 
for representing data will doubtlessly present new opportunities for both Web 
and wireless Web clients. 
In this chapter I show you the basics ofXML. I first discuss its syntax, which as 
you will see draws strongly on the markup languages such as HyperText Markup 
Language (HTML) that precede it. Next, I show you a key feature unique to XML: 
defining your own markup language with XML. Along the way you learn two 
applications ofXML the Web uses to define and share its own markup languages. 
Learning XML is a crucial part of wireless Web development because both 
servers and clients use markup languages derived from XML to describe content, 
so let's get started! 
An XML Primer 
Like those created using other markup languages, XML documents consist of 
data and markup tags. XML, however, leaves the document author free to estab-
lish whatever markup tags may be appropriate for a given data set. For example, 
a site that manages intranet inventory content might use tags such as <ITEMID>, 
<ITEMSERIALNO>, <LOCATION>, <OWNER>, and <BIN> to represent the fields in a legacy 
inventory database; a site providing weather information might have markup 
tags such as <WHERE>, <REPORTED>, <FORECAST>, and <TEMPERATURE>. Also unlike the 
other markup languages you have seen, XML is likely to be "viewed" not by a sub-
scriber client application, but by an application responsible for processing data 
in XML and returning another data set -perhaps in a different markup format, 
such as HTML. 
An XML document consists of one or more entities, each containing either 
text or binary data (but not both). An entity's primary purpose is to hold content, 
117 

Chapter7 
118 
such as XML or text. An entity consists of a prologue, which describes the entity, 
and the entity data itself, which consists of exactly one root entity tag and its 
contents. 
XML entities and the documents that contain them need not be files on 
a host on the network. They can be, but they also can be built from aggregates of 
files or constructed on the fly from databases-or virtually any other source. 
A prologue must be the first entry in an XML file, and it declares attributes 
about the XML entities that follow. This is the general form of the prologue: 
<?xml attribute="value" attribute2="value" ••• ?> 
Between < ?xml and ?> are name/value attribute pairs describing the XML 
document that follows. In general, the prologue will contain at least one attribute, 
specifying the version ofXML used within the entity. It looks like this: 
<?xml version="l.O"?> 
XML documents consist of character data interspersed with tags that define 
the document's structure. As in HTML, you enclose tags within < and > charac-
ters; the text between these characters is the tag name. Tag names should begin 
with a letter or underscore, and may contain letters, numbers, and underscores, 
but not spaces. Unlike HTML, XML is case-sensitive; thus, <FORECAST> and 
<Forecast> are two different tags. 
Following are some valid XML tags: 
• <WEATHER> 
• <REPORTED> 
• <FORECAST> 
• <TEMPERATURE> 
• <species> 
• <Day_of_Week> 
XML tags, like those in most other markup languages, come in pairs. A clos-
ing tag has the same name as the corresponding opening tag, but with the 
addition of a slash at the beginning of the name, like this: </WEATHER>. 
Some tags are empty-that is, they do not contain data and do not require 
closing tags. These have a slash at the end of the tag name. Thus, the XML equiva-
lent of a break tag in XHTML (XML-compliant HTML) is written <BRI>. ( 

eXtensible Markup Language 
In practice, HTML viewers may not handle this tag properly, and those trying to 
write XML-compliant HTML generally use <BR></BR>.) The correct use of the<,>, 
and I characters enable an XML parser-the component of a program that inter-
prets your XML-to accurately construct an internal representation of your 
content when inspecting a new page ofXML. 
Tags may contain attributes, which describe their characteristics. Attributes 
are simply written as name/value pairs separated by an= after the tag name 
before the closing > character. For example: 
<TEMPERATURE UNITS="Centigrade">24</TEMPERATURE> 
describes a comfortably warm day on the California coast in Centigrade. 
Attributes in general qualify a tag and do not contain information specific about 
the thing being described. Thus, one could also describe the temperature as: 
<TEMPERATURE UNITS="Centigrade" VALUE="24"/> 
or 
<TEMPERATURE><VALUE>24</VALUE><UNITS>Centigrade</UNITS></TEMPERATURE> 
Note that these different examples, although they represent the same infor-
mation to a human, are not equivalent in XML. The first states that VALUE and 
UNITS modify the absolute notion of a temperature entity (which has no content), 
and the other says that VALUE 24 and UNITS CENTIGRADE are part of a temperature 
entity. 
Generally, if a piece of information is part of the data represented, it is best 
given as a tag; if it is meta data about the representation, it is best given using an 
attribute. Thus, because units and value are part of a temperature, the second is 
preferable for most applications. 
Comments are an important part ofXML, especially when a document is 
fleshed out during the initial development steps. A comment is flanked by the 
characters <! -- and -->, and it can contain any text except the two-hyphen 
string--. XML parsers ignore material contained in comments. You can use com-
ments to leave notes to future (human) readers of a file, to keep part of 
a document hidden from the XML parser during testing, or for similar purposes. 
As you might guess, the < and > have special meaning within XML. In fact, 
five characters have special meaning: <, >, ", ', and&. If you want to use any of 
these characters within an XML document for any other purpose, you must refer 
to them using their defined entity references ( <&1 t;, &gt;, &quot; ,&apos; ,and 
&1 t;, respectively). HTML defines a number of additional entities, such as &copy; 
for the copyright (©) symbol, but these five characters are the only predefined 
119 

Chapter7 
120 
entities in XML. Thus, if explaining an XML tag in XML, you might write the fol-
lowing: 
••• use the &lt;TEMPERATURE&gt; tag to specify a temperature ••• 
Of course, if you are actually writing about XML, remembering to include 
these entities on a regular basis can becoine awkward. To make things easier, you 
can define a special section of data in an XML document, called a COAT A section. 
Within a COAT A section, all text is treated as text except its closing delimiter, which 
is a double square bracket and a closing angle bracket: ] ] >. In fact, even com-
ments can appear in COAT A sections and are not treated as comments; the XML 
parser essentially ignores all tags within a COAT A. Thus, you could also write the 
previous example as the following: 
<I [CDATA[ 
••• use the <TEMPERATURE> tag to specify a temperature ••• 
]]> 
Bear in mind that you should not use COAT A for comments; unlike the com-
ment delimiters< 1- and->, the contents ofCDATA are passed on to the end 
application. In other words, users will be able to read any content contained 
within COAT A. 
Putting this together, let's create a sample XML file that describes the current 
and future weather for my hometown (see Listing 7 -1). 
Listing 7-1. Sample XML File 
<?xml version="l.O"?> 
<WEATHER> 
<LOCATION> 
<WHERE>Boulder Creek, CA</WHERE> 
<ZIP>95006</ZIP> 
</LOCATION> 
<REPORTED> 
<WHEN><DATE>11/25/2000</DATE><TIME>14:00</TIME></WHEN> 
<TEMPERATURE units="Centigrade">17</TEMPERATURE> 
<BAROMETER units= "kPa">102. 5</BAROHETER> 
<HUMIDITY>.65</HUMIDITY> 
<WIND><SPE ED units= "m/ s" > 1. 8< /SPE ED><DIRECTION> 270</DIRECTION></WIND> 
<PRECIPITATION units= "mm">O</PRECIPITATION> 
</REPORTED> 
<FORECAST> 
<WHEN><DATE>ll/26/2000</DATE></WHEN> 
<PRECIPITATION_PROBABILITY>.10</PRECIPITATION_PROBABILITY> 

eXtensible Markup Language 
<NWS>A small system will move in during the afternoon, 
leading to partly cloudy skies with a chance of showers 
in the evening. Temperatures in the high teens. 
</NWS> 
</FORECAST> 
</WEATHER> 
As Listing 7-1 shows, XML is readable, but verbose. Its strength is its flexibil-
ity. Because tags can be dynamically defined for each document in 
a self-describing, hierarchical manner, virtually any kind of content can be 
marked up in XML for further processing. 
Sharing Your XML Creation 
Of course, an XML document is of little use unless you and the others for whom it 
is intended agree on the tags to be used. The real strength ofXMLlies in the abil-
ity to not just create tags but to describe tag sets in an interoperable way so that 
groups can agree to use a specific tag set to denote certain kinds of data. Already, 
this feature has led to the creation of specialized XML-based languages in several 
industries, including the following: 
• Wireless Markup Language (WML): Used by the wireless Web for content 
markup 
• Voice Markup Language (VoxML): Used by telephone service providers to 
mark up text for speech synthesis in telephone exchange systems, voice-
mail systems, and the like 
• Mathematics Markup Language (MathML): Represents simple or complex 
mathematical formulae 
• Open Financial Exchange (OFX): Represents financial ~ansactions for per-
sonal finance packages 
In fact, parts ofXML widely used such as the eXtensible Stylesheet Language 
(XSL) are really expressed in XML itself. The industry calls these markup lan-
guages XML applications because the language applies XML in their imple-
mentation. 
Each of these XML applications must include a definition of what individual 
tags actually mean. For example, in WML, the <br/> tag instructs a browser to 
present a line break. To share these meanings, along with the grammatical details 
121 

Chapter7 
122 
of a specific markup language (such as which tags can contain specific attributes 
or other tags), developers must agree on a common language definition. 
To date, several complimentary XML-based definition schemes have been 
proposed. 1\vo of these, the XML Document 'IYPe Definition (DTD) and the XML 
Schema Definition Language (XML Schema) are now widely adopted, letting you 
specify your specific markup language in a way that ensures others can share 
your work. Others, including REIAX-NG, have been proposed but are less widely 
adopted or used only for specific applications. 
These schemes provide two key benefits to developers. First, they let devel-
opers share the definition of a specific XML application in a well-defined way. 
Second, and most important over the lifetime of an XML application, they pro-
vide a mechanism by which you can validate arbitrary XML documents you think 
conform to a specific application. This validation is key in developing content 
because you can use one of these schemes and a target document and obtain 
information as to how your document fares in meeting the specification of the 
XML application with an XML editor. 
Let's take a closer look at XML DTD and XML Schema. 
XML Document Type Definition 
The DTD is XM:Cs original means of capturing the syntax for a particular set of 
tags. Although not required, a DTD enables others to understand what tags have 
been defined and how they are to be used. A group that has agreed on a standard 
set of tags and usage can specify them in a DTD, which will then enable XML 
parsers to validate documents based on its specifications. Many of to day's 
XML applications, including the wireless Web's own WML, use a DTD to specify 
their tag and attribute syntax. 
You must declare each tag in a valid XML document with an element decla-
ration in an XML application's DTD using the <I ELEMENT> tag. This tag specifies 
the name, attributes, and usage of an element. The<! ELEMENT> tags are contained 
in a < I DOCTYPE> tag, which specifies the root element for a document. 
The previous example recorded weather information with a WEATHER element, 
which contained the various elements for a current measurement and forecast. 
The DTD for that document would begin as follows: 
<IDOCTYPE WEATHER[ 
••• <1-- Elements for the weather information go here --> 
]> 
You would include all of the individual elements within the <I DOCTYPE> tag, 
defined with the <!ELEMENT> tag. An < I ELEMENT> tag specifies an element's valid 

eXtensible Markup Language 
contents, including any enclosed elements and their ordering and attributes. The 
syntax of the <!ELEMENT> tag is as follows: 
<!ELEMENT element-name usage> 
where usage describes what may exist within the element. Thus, the element tag 
for the WEATHER element might be like this: 
<!ELEMENT WEATHER (LOCATION (REPORTED I FORECAST)*)> 
This simply says that the WEATHER element can contain a single LOCATION ele-
ment and zero or more REPORTED elements and FORECAST elements, in either 
order. 
In the usage portion of the<! ELEMENT> tag, you can specify that a tag can be 
used for any valid content by using the special keyword ALL. Or, you can restrict 
usage to only character data with arbitrary child tags by using the special tag 
#PCDATA. In addition, a tag can specify the valid list of elements it can contain 
using a simple list -based syntax. This syntax follows these rules: 
• The list appears within parentheses. 
• The order of the list is defined left to right, as the list is read. 
• Required elements are delimited by commas. 
• Exclusive elements are delimited by a 1. 
• An element can be followed by a* to indicate it may appear zero or more 
times. 
• An element can be followed by a+ to indicate it must appear one or more 
times. 
• An element can be followed by a ? to indicate it must appear exactly zero 
or one times. 
• lists can be treated as elements by containing them in parentheses (in 
other words, lists can be nested). 
123 

Chapter7 
124 
For example: 
• <!ELEMENT P ALL> states that the P element can contain any kind of ele-
ment or character text. 
• <I ELEMENT dl ( dt, dd )*>states that a dl element consists of alternating 
matched dt and dd elements (this is simply the definition list style in 
HTML). 
• <I ELEMENT WHEN ( DATE, TIME? )>states that WHEN must contain a DATE ele-
ment, with no more than one time element after the DATE element. 
• <I ELEMENT CHAPTER (TITLE, ( PARAGRAPH, FIGURE )* )>defines a CHAPTER 
element that must begin with exactly one TITLE and then contains an alter-
nation of PARAGRAPH and FIGURE elements. 
You can declare an element empty by using the special tag EMPTY. 
Each element must specify its attribute list (if any) using the< I ATTLIST> tag. 
This tag's structure is similar to that of the< I ELEMENT> tag: 
<!ATTLIST element-name attribute-name type default-value> 
Table 7 -!lists possible types. In general, the most commonly encountered 
type is COAT A, which indicates that an attribute's value may be a string. Less com-
mon, the ID, IDREF, or IDREFS attributes establish relationships among specific 
XML elements. Another common type is the enumeration-a list of possible val-
ues from which only one may be taken: 
< IATILIST ITEM show ( true I false ) "true"> 
You have the option of specifying a default value at the end of an< IATTLIST> 
tag, as shown here-by default, show will be true. The default may be a specific 
value, like this one, or you can use one of the following special values: 
• #REQUIRED indicates that an entry is required but that no default is speci-
fied (the DTD may not have a good idea what the default is, but a value will 
be necessary). 
• #IMPLIED shows that an entry is desirable but no default can be specified 
(there is no good default, but the user should supply one, and if not, the 
XML application is free to do what it wants with the omission). 
• #FIXED indicates that the default value cannot be overridden. 

eXtensible Markup Language 
Table 7-1. Attribute Types for XML Elements 
ATIRIBUTE TYPE 
COAT A 
ENTITY 
ENTITIES 
ID 
IDREF 
IDREFS 
NMTOKEN 
NMTOKENS 
NOTATION 
enumeration 
MEANING 
Character data without markup tags 
The name of an entity declared in the DTD 
A list of the names of entities declared in the DTD 
A unique identifier (not shared by any other ID 
attribute in the document) 
A reference to an ID attribute elsewhere in 
the document 
A list of references to ID attributes elsewhere in 
the document 
A name in XML syntax for use with other XML tags 
A list of names in XML syntax 
The name of a notation specified in the DTD 
A list of possible values from which exactly one may 
be chosen, such as (YES I NO ) 
Although XML comes with some predefined entities, there are many reasons 
why a content developer might want to add additional ones. The most common 
reason is a desire to create shortcuts for entering common long strings of text, 
such as a name, header, footer, or other information. The < ! ENTITY> tag in a DTD 
specifies additional entities delimited by quotes: 
<I ENTITY entity-name "value"> 
You can extend this definition capability to external entities-those defined 
outside the DTD-using the SYSTEM keyword. If, for example, a Web site contains 
a footer that is required on all pages, the footer could be kept in an independent 
location, and authors could reference it on each page using, for example, the 
entity &footer;, which they have defined in a DTD as follows: 
<!ENTITY footer SYSTEM "http://www.site.org/entities/footer.xml">. 
Because the DTD serves to document a markup language for both com put-
ers and humans, comments are an essential part of it. You write DTD comments 
using the same syntax as elsewhere in XML, using the < 1- and-> delimiters. 
125 

Chapter7 
126 
A DTD can precede the XML in a document, or it can be a separate document 
to which the XML document refers. This second possibility is a powerful advan-
tage ofXML because it means that one DTD can serve to describe a multitude of 
documents across many Web sites. In the case of a DTD specific to a single docu-
ment, the <I DOCTYPE> tag simply precedes the XML content, like this: 
<!DOCTYPE WEATHER[ 
]> 
<DOCUMENT> 
</DOCUMENT> 
For a shared DTD, however, you omit this <I DOCTYPE> tag. Instead, the DTD is 
denoted using a special <! DOCTYPE> tag with a SYSTEM keyword specifying the 
Uniform Resource Locator (URL) where the DTD can be found: 
<IDOCTYPE WEATHER SYSTEM" http://www.lothlorien.com/dtd/weather.dtd"> 
This indicates that the DTD is at the URL 
www.lothlorien.com/dtd/weather.dtd. 
Listing 7-2 shows what the weather DTD looks like. 
Listing 7-2. Sample DTD 
<IDOCTYPE WEATHER[ 
<!ELEMENT DATE #PCDATA> 
<!ELEMENT TIME #PCDATA> 
<!ELEMENT WHERE #PCDATA> 
<!ELEMENT ZIP #PCDATA> 
<!ELEMENT WEATHER (LOCATION (REPORTED I FORECAST)*)> 
<!ELEMENT LOCATION ( WHERE? I ZIP? )> 
<!ELEMENT DIRECTION #PCDATA> 
<!ELEMENT WHEN ( DATE, TIME? )> 
<!ELEMENT REPORTED ( WHEN, TEMPERATURE, BAROMETER?, HUMIDITY, 
WIND?, PRECIPITATION? ) > 
<!ELEMENT TEMPERATURE #PCDATA> 
<IATTLIST TEMPERATURE units ( "Centigrade" I "Fahrenheit") #REQUIRED> 
<!ELEMENT BAROMETER #PCDATA> 

eXtensible Markup Language 
< IATTLIST BAROMETER units ( "kPa" I "inHg" I "mmHg" I "mBar" ) #REQUIRED> 
<!ELEMENT HUMIDITY #PCDATA> 
<!ELEMENT WIND {SPEED, DIRECTION)> 
<!ELEMENT SPEED #PCDATA> 
<!ATTLIST SPEED units ("m/s" I "mi/h" I "km/h" I "knots" ) > 
<!ELEMENT PRECIPITATION #PCDATA> 
< !ATTLIST PRECIPITATION units ("mm" I "em" I "m" I "in" I "ft" )> 
<!ELEMENT FORECAST ( WHEN, PRECIPITATION_PROBABILITY?, NWS?) > 
<!ELEMENT PRECIPITATION_PROBABILITY #PCDATA> 
<!ELEMENT NWS #PCDATA> 
]> 
XML Schema Definition Language 
A more recent alternative to XML DID is XML Schema. Proposed to address sev-
eral shortcomings ofXML DID, XML Schema incorporates many features of the 
proposed alternatives to XML DTD (such as type checking), making it an attrac-
tive candidate for future markup definition. 
The concepts behind XML Schema are similar to DTD, although there are 
some subtle differences. The most obvious difference is that unlike the DTD tags, 
XML Schema tags are defined in an XML namespace, a convention XML uses to 
ensure that tags from different XML applications do not use the same name. All 
of the XML Schema tags are defined in the xs namespace, so you write a XML 
Schema tag using the convention xs: tgg, like this: 
<xs:schema> <lxs:schema> 
<xs:element> </xs:element> 
<xs:sequence> </xs:sequence> 
You write your XML Schema document-commonly simply called a schema 
when the context is clear-in an XML document containing a root <xs: schema> 
tag, like this: 
<?xml version= "1. o" ?> 
<xs: schema xmlns: xs ="http: I /www. w3. org/2001/XMLSchema" > 
<1-- your schema goes here --> 
</xs:schema> 
Note that the namespace declaration xs in this example is not set in stone: 
Many examples prefer xsd instead. 
127 

Chapter7 
128 
For each element in your XML application, you must write a <xs: element> 
tag that describes what the tag can contain, as well as what kind of data it can 
contain. XML Schema defines a number of primitive data types, including dates, 
Booleans, and strings, and lets you define your own as well. In fact, this type defi-
nition mechanism is how you describe what combinations of nested tags you 
allow. 
Consider, for a moment, the weather XML application's <WHEN> tag. This tag 
contains two valid elements: a <DATE> tag and a <TIME> tag. To express this using 
XML Schema, you would write something like this: 
<xs:element name="WHEN"> 
<xs:complexType> 
<xs:sequence> 
<xs:element name="DATE" type="xs:date"l> 
<xs:element name="TIME" type="xs:time"/> 
</xs:sequence> 
</xs:complexType> 
</xs:element> 
This says that every <WHEN> element is a complex element that must also con-
taina sequence of two other tags, a <DATE> tag and a <TIME> tag, of types xs:date 
and xs: time accordingly. (Table 7 -2lists the tags XML Schema supports.) As 
I show in a moment, it is also possible to create more flexible types that verify the. 
number of times an element may occur within another element. Before you see 
that, however, let's look at another way to write the definition of <WHEN>: 
<xs:element name="DATE" type="xs:date"l> 
<xs:element name="TIME" type="xs:time"/> 
<xs: element name= "WHEN"> 
<xs:complexType> 
<xs:sequence> 
<xs:element ref="DATE" min0ccurs="1" max0ccurs="1"/> 
<xs:element ref="TIME" min0ccurs="1" maxOccurs="l"l> 
</xs:sequence> 
</xs:complexType> 
</xs:element> 

eXtensible Markup Language 
Table 7-2. Common Data 1}rpes for XML Schema 
ATTRIBUTE TYPE 
xs:string 
xs:date 
xs:time 
xs:float 
xs:boolean 
xs:decimal 
xs:integer 
xs:duration 
xs:dateTime 
xs:anyURI 
MEANING 
String of characters 
Calendar date 
Time 
Floating-point number 
Boolean value (true or false) 
Arbitrary precision floating-point number 
Integer value 
Duration of time 
Calendar date and time 
A Uniform Resource Identifier 
In the previous example I have unwrapped the definition of the <WHEN> ele-
ment. Instead of having the actual definitions of the <DATE> and <TIME> tags 
within the <WHEN> tag, they sit alone, and the <WHEN> tag simply refers to them 
using the ref attribute of the <xs: element> tag. This is better than the previous 
listing for two reasons: It is easier to read, and it lets you use these definitions 
within other elements without rewriting them. 
The <DATE> and <TIME> elements have additional attributes in this snippet as 
well: the minOccurs and maxOccurs attributes, which specify how many times an 
element may occur. By default, both minOccurs and maxOccurs default to II 1 II, so 
this code is functionally equivalent to the previous listing. 
You can define other tags the same way. For example, here is the 
<TEMPERATURE> tag: 
<xs:element name="TEMPERATURE" type="xs:float"> 
<xs :attribute name="units" type="unitTemperatureType" I> 
</xs:element> 
This specifies the <TEMPERATURE> element as a number, taking an attribute 
units of type uni tT emperatureType. But what is that?lt is certainly not one of the 
built-in types because it is missing the xs : namespace identifier. 
XML Schema lets you extend its types in several ways, most notably 
restriction, in which you create a new data type by identifying an original data 
type that is close to what you want and paring it down to meet your needs. You 
can do this for the unitTemperatureType thusly: 
129 

Chapter7 
130 
<xs: simple Type name=" uni tTemperatureType" > 
<xs: restriction base= "xs: string"> 
<xs: pattern value= "Centigrade I Fahrenheit" I> 
</xs:restriction> 
</xs:simpleType> 
This creates a new data type, called unitTemperatureType, which is a string 
whose value can only be one of the strings "Centigrade" or "Fahrenheit". This is 
analogous to the DID's <!ATTRLIST>. 
Listing 7-3 shows the entire definition for the weather application. 
Listing 7-3. Weather DTD 
<7xml version="1.0"7> 
<xs : schema xmlns : xs ="http://www. w3. org/2001/XMLSchema • > 
<1-- data types --> 
<xs: simple Type name= "unitPressureType"> 
<xs: restriction base= "xs: string"> 
<xs: pattern value= "kPa I inHg I mrnHg I mBar"/> 
</xs:restriction> 
</xs:simpleType> 
<xs: simple Type name= "unitSpeedType"> 
<xs: restriction base= "xs: string"> 
<xs:pattern value="m/s lmi/h I km/h I knots"/> 
</xs:restriction> 
</xs:simpleType> 
<xs: simple Type name= "unitTemperatureType"> 
<xs: restriction base= "xs: string"> 
<xs: pattern value= "Centigrade I Fahrenheit "I> 
</xs:restriction> 
</xs:simpleType> 
<xs: simple Type name= "unitlengthType"> 
<xs: restriction base= "xs: string"> 
<xs:pattern value=""mml cml ml in 1ft"/> 
</xs:restriction> 
</xs:simpleType> 
<!-- simple elements --> 
<xs:element name="DATE" type="xs:date"l> 
<xs:element name="TIME" type="xs:time"l> 

<xs: element name= "HUMIDITY" type= "xs: float" I> 
<xs:element name="PRECIPITATION_PROBABILITY" type="xs:float" I> 
<xs:element name="DIRECTION" type="xs:float"l> 
<xs:element NAME="NWS" type="xs:string"l> 
<xs:element NAME="WHERE" type="xs:string"l> 
<xs:element NAME="ZIP" type="xs:string"l> 
<1-- composite elements --> 
<1--
Basic scalar elements for measurements --> 
<xs:element name="TEMPERATURE" type="xs:float"> 
<xs: attribute name=" units" type=" uni tT emperature Type" I> 
<lxs:element> 
<xs: element name= "BAROMETER" type= "xs: float"> 
<xs: attribute name=" units" type=" unitPressureType" I> 
<lxs:element> 
<xs:element name="SPEED" type="xs:float"> 
<xs: attribute name=" units" type=" unitSpeedType" I> 
<lxs:element> 
<xs: element name= "PRECIPITATION" type= "xs: string"> 
<xs: attribute name= "units" type= "unitlengthType" I> 
<lxs:element> 
<xs:element name="WHEN"> 
<xs:complexType> 
<xs:sequence> 
<xs:element ref="DATE" min0ccurs="1" max0ccurs="1"1> 
<xs: element ref= "TIME" minOccurs= "1" maxOccurs=" 1" I> 
<lxs:sequence> 
<lxs:complexType> 
<lxs:element> 
<xs: element name= "WIND"> 
<xs:complexType> 
<xs:sequence> 
<xs: element ref="SPEED" I> 
<xs: element ref="DIRECTION" I> 
<lxs:sequence> 
<lxs:complexType> 
eXtensible Markup Language 
131 

Chapter7 
132 
</xs:element> 
<xs:element name="LOCATION"> 
<xs:complexType> 
<xs:sequence> 
<xs: element ref= "WHERE" minOccurs= "o" maxOccurs= "1" I> 
<xs:element ref="ZIP"/> 
</xs:sequence> 
</xs:complexType> 
</xs:element> 
<!-- Groups of measurements --> 
<xs: element name= "REPORTED"> 
<xs:complexType> 
<xs:sequence> 
<xs: element ref= "WHEN" I> 
<xs: element ref= "TEMPERATURE" I> 
<xs: element ref=" BAROMETER"/> 
<xs :element ref= "HUMIDITY" I> 
<xs: element ref= "WIND" I> 
<xs:element ref="PRECIPITATION" minOccurs="O" max0ccurs="1"/> 
</xs:sequence> 
</xs:complexType> 
</xs:element> 
<xs: element name=" FORECAST"> 
<xs:complexType> 
<xs:sequence> 
<xs: element ref= "WHEN" I> 
<xs :element ref=" PRECIPIT A TION_PROBABI LITY" minOccurs = "o" 
maxOccurs =" 1" I> 
<xs:element ref="NWS" minOccurs="o" maxOccurs="l"/> 
</xs:sequence> 
</xs:complexType> 
</xs:element> 
<1-- Root element --> 
<xs:element name="WEATHER"> 
<xs:complexType> 
<xs:all> 
<xs:element ref="LOCATION"I> 

eXtensible Markup Language 
<xs: element ref=" REPORTED" minOccurs = "1" maxOccurs ="unbounded" I> 
<xs: element ref=" FORECAST" minOccurs=" 1" maxOccurs= "unbounded" I> 
</xs:all> 
</xs:complexType> 
<lxs:element> 
</xs:schema> 
Whew! This is quite a bit longer than my DTD, but it is also more specific. 
Taking it step by step, you can see that I describe some new data types, some sim-
ple data elements such as the <DATE> and <TIME> tags, and then composite data 
elements including the <TEMPERATURE> tag. Finally, I define the elements for 
weather measurements and weather reports, finishing with the <WEATHER> tag. 
Note that the <WEATHER> tag definition uses the <xs: alb tag to define its con-
tents, rather than the <xs: sequence> tag. By using <xs: all>, I say that the 
' 
<LOCATION>, <REPORTED>, and <FORECAST> elements may come in any order. 
Summary 
XML is deceptively simple. With syntax reminiscent of HTML, it is easy for most 
Web developers to learn quickly. Its key difference, however, is its flexibility: 
Using XML, you can define a markup language that defines nearly anything. XML 
is at the heart of new markup languages for the Web, including the standard 
WML, which you will see in detail in Chapter 11, "Wireless Application Protocol." 
Syntactically, the largest difference between XML and HTML is its distinction 
between tags that contain data and empty tags, which you write using the < and 
I> brackets. XML also requires a clear preamble, stating the version ofXML you 
are using to describe your document. 
Because ofXML's flexibility, it is important to document your markup lan-
guages. Doing so helps you share your markup language with others, and it lets 
you validate documents against your markup language's definition. XML pro-
vides a host of markup languages you can use to do this. The two most popular 
are XML DTD and XML Schema. The DTD is commonly used on to day's wireless 
Web to describe markup languages including XHTML, compact HTML (cHTML), 
and WML, and the XML Schema is poised to become the standard for describing 
newer markup languages. 
133 

CHAPTER 8 
HyperText Markup 
language the Wireless 
Way 
As mscussEo IN CHAPTER 4, "The Wireless World Wide Web," the HyperText Markup 
Language (HTML) has significant advantages as a medium for wireless access 
terminals. However, you must approach its use with the constraints of handheld 
devices in mind. If you are used to developing in HTML for desktop browsers, 
you will have to start thinking a little differently, making sure you stick to HTML 
tags appropriate for the wireless world. In this chapter, I first review the different 
versions of HTML in light of their suitability for use with the wireless Web. I then 
walk through a tag-by-tag discussion of using HTML in your development of 
wireless content. 
NOTE 
All of the examples in this chapter were generated using Microsoft 
Internet Explorer for Pocket PC and Handspring Blazer for the Palm 
Powered platform. You will see similar results using other Web browsers 
such as Opera, although there are marginal differences between their rep-
resentation of HTML and those shown in this chapter (just as there are 
differences between browsers on the same computing platform). Of course, 
you should always test your content on target devices before you make 
assumptions about its appearance! 
Picking a Version of HTML 
Most important to consider when beginning to work with HTML for wireless 
browsers is which version of HTML you will use. When developing content for 
the World Wide Web, you will usually want to use the most up-to-date version, 
with all of its features. But if the market for your content is a handheld device, 
135 

ChapterB 
136 
you cannot be sure the platforms your customers use will support the latest 
versions ofHTML. As a result, you will want to use earlier versions. 
This is because of the way in which wireless Web browsing crept up on the 
marketplace. Many wireless browsers currently in use were written with core 
code that was years old. Others evolved from prototypes (created for academic 
research, to satisfy someone's individual curiosity, or as corporate proof-of-con-
cept demonstrations) that later evolved into software products as the demand for 
portable Web access grew. The humble origins of these browser applications 
make them incompatible with many of the latest features of HTML. 
As long as hardware manufacturers are providing handheld devices with pre-
installed browsers, this disparity between wireless browsers and wired ones is 
likely to continue. Hardware vendors tend to have a significant amount of soft-
ware savvy, but few take the time and expense to track the rapid changes in Web 
standards hammered out by the World Wide Web Consortium (W3C) and indus-
try giants. Because hardware sales success is measured by the number of units 
sold, not by the products' compliance with W3C standards, there simply is no 
compelling business reason for them to do so. Smaller software vendors may pro-
vide more up-to-date browser applications for these devices, but the reality is 
that most users will have access only to those installed during manufacturing. 
So, what versions of HTML are recommended for wireless content develop-
ment? Well, nearly all wireless Web browsers support HTML 2.0, and most 
support a subset of the features of HTML 3.2. Some support certain features of 
HTML 4.0, but virtually none meet all of the W3C's requirements for implement-
ing HTML 4.0 in all of its glory. Therefore, it is best to stick with the features you 
find in HTML 2.0 or, for some markets, HTML 3.2. 
Determining exactly which version is appropriate requires knowledge of your 
user base. Keep in mind the adage Less is often more. If you know which wireless 
browsers will access your service, a quick look at the specifications provided by 
the browser vendor will often tell you which HTML version to use. If you are cre-
ating a site for general public access, however, you will need to use the lowest 
common denominator of features between HTML 2.0 and 3.2. 
Marking Up the Document Heading 
In Chapter 4, "The Wrreless World Wide Web," you learned that HTML documents 
are divided into two sections, a heading and a body. The heading is an optional 
segment containing meta information about the document. If included, it is 
delineated by the tags <HEAD> and </HEAD>. The actual document to be displayed 
by the browser is then marked with the <BODY> tag. 
Table 8-llists the HTML 4.0 heading tags of use in developing for wireless 
browsers; the following sections discuss each one in more detail. 

HyperText Markup Language, the Wireless Way 
Table 8-1. HTML Tags for Wireless Web Document Headings 
TAG 
TITLE 
META* 
BASE* 
INTRODUCED IN 
HTML2.0 
HTML2.0 
HTML2.0 
PURPOSE 
Specifies the document's title, which may 
appear in a document's window bar, offline 
cache, or other location 
Provides meta information not supported 
by HTML markup commands for the client 
Specifies the base URL from which 
relative URLs in the body should be derived 
*These tags are empty tags and do not have a corresponding closing tag. 
Specifying the Document Title 
Probably the most common heading tag is <TITLE>, which, obviously enough, 
specifies the title of the document. Most wireless browsers honor this tag but 
not necessarily in the way you might expect. For example, browsers on the 
Palm OS platform show as much of the title as will fit at the top of the display; 
Microsoft Pocket Internet Explorer shows the title in the task bar rather than in 
the browser window. 
Wrreless browsers can use the <TITLE> tag to identify a document in a list of 
bookmarks, for example, because most browsers provide a default title when 
a new bookmark is created. The browser derives this title from the document's 
<TITLE> tag. 
Generally, your documents should include a title that briefly describes its 
content. Appropriate sample titles include the following: 
• HTML 4.0 Specifications 
• Where to Go in Boulder Creek 
• Jarod Rischpater's Home Page 
Some titles to avoid: 
• Home (This is too short-home for what?) 
• Sandy's Stuff (Although this is cute, most readers will not remember Sandy 
or the stuff on the page, or know what is on the page from the title.) 
• Rachel and Ray's Not So Totally Exhaustive Survey of Coffee 
Establishments in and around Boulder Creek (This is just too long!) 
137 

Chapter8 
138 
Providing Meta Information to a Client 
The <MET A> tag is an empty tag that enables you to establish arbitrary 
name/value pairs, called entities, for specific browsers. You can use these tags to 
specify browser-dependent behavior, such as how and when the client should 
reload a document, or to assert that a specific document is in fact formatted for 
a particular device. Table 8-2 outlines common <MET A> entities in wireless Web 
publishing and how they are used. 
Table 8-2. HTML Meta Values for Wireless Web Document Headings 
NAME 
HTTP-EQUIV 
VALUE 
Varies 
PalmComputingPlatform 
true 
HandheldFriendly 
true 
PURPOSE 
Specifies HTTP header information (not to 
be confused with the HTML heading) to 
browsers in the HTML document, rather 
than the HTTP headers 
Indicates that the body of this document is 
appropriate for Palm Web Clipping 
applications 
Indicates that the body of this document is 
appropriate for the AvantGo browser 
For wireless Web developers, the most important meta entities are those 
indicating that the document's content is appropriate for small devices. 1\vo 
common meta entities that serve this purpose are PalmComputingPlatform and 
HandheldFriendly. Meta PalmComputingPlatform indicates suitability for Palm's 
Web Clipping application platform (see Chapter 9, "Palm-Powered Web Clipping 
Applications"); and Handheld Friendly is for the AvantGo browser (see Chapter 14, 
"Content Delivery). You will find many general-purpose wireless Web pages have 
the following in their headers: 
<META NAME="HandheldFriendly" CONTENT="true"> 
<META NAME="PalmComputingPlatform" CONTENT="true"> 
Both of these tags let the appropriate browsers know that the document was 
designed for handheld use (because each browser is different, a different meta 
tag must be used). In the absence of the tags-or if these values were equal to 
false-these browsers will assume the content was targeted for desktop devices 
and might display radically different results. For example, the Palm VII browser 
discards the end oflong pages lacking the PalmComputingPlatform meta tag-

HyperText Markup Language, the Wireless Way 
probably not what you would expect. And, when a browser encounters a meta 
entity it does not recognize, it ignores the entity entirely. 
Another useful <META> entity is HTIP- EQUIV, which replaces a HyperText 
'fransfer Protocol (H'ITP) header with the value specified. Content authors use 
this meta entity when they want to express control over a document's behavior in 
ways only specified by the HTTP protocol. For example, you can use HTIP- EQUIV 
to force the browser to refresh a page periodically or to expire a page in the cache. 
This ability can be handy for pages serving information that changes often, such 
as stock quotes or the weather; users generally will want this kind of information 
to be up to the minute. Not all browsers, however, support HTIP-EQUIV, and some 
that do only support some uses of it. 
A tag such as this one: 
<META HTIP-EQUIV="expires" 
CONTENT="Sun, 31 Dec 2005 11:59:00 GMT"> 
instructs the browser that this Web page should be discarded from the cache on 
New Year's Eve, 2005. 
The following line: 
<META HTIP-EQUIV="Refresh" CONTENT="300"> 
indicates that the Web page should be reloaded every five minutes (300 seconds). 
Be careful when using the HTIP- EQUIV=Refresh, however, as your content is dic-
tating the behavior of your customer's browser and may be incurring wireless 
fees subscribers are not aware of as the browser goes off and fetches pages peri-
odically. (Incidentally, the content loaded as a result of the refresh must also have 
this tag, or the refresh will not happen again. This is because the page loaded by 
the browser is different-the browser does not retain memory of this directive 
across pages.) 
The strength of a <MET A> tag in ordinary Web development is that it can be 
used with any name/value pair. But this fact can be a weakness in wireless Web 
development, as it means a <META> tag can consume a great deal of space. This 
kind of entity can take precious time to download and occupy space best left for 
more important material. If your desktop-oriented Web content uses meta tags 
this way, remove them before posting it for wireless use! 
Specifying a Base URL 
HTML headings use the <BASE> tag to specify the base Uniform Resource Locator 
(URL) from which other URLs in a particular document are derived. If your con-
tent refers to other content on the same server, it should always specify a <BASE> 
139 

ChapterB 
140 
tag and use relative URLs to keep your document body smaller. Consider the dif-
ference in the following two versions of the same page: 
<HTML> 
<HEAD> 
<BASE HREF="http://www.colors.org/pCp/index.html"> 
<TITLE>People Color Picker</TITLE> 
</HEAD> 
<BODY> 
<Hl ALIGN=right>People Color Picker</Hl> 
<P>Choose a color below to learn about people who have that 
color as their favorite color:</P> 
<MENU> 
<li><A HREF="chart.html">Chartreuse</A></LI> 
<li><A HREF="magen.html">Magenta</A></LI> 
<li><A HREF="cyan. html">Cyan</A></LI> 
</MENU> 
</BODY> 
</HTML> 
The previous HTML document, which specifies a base URL in the heading, 
uses 802 bytes. The following page, which does not, occupies 827 bytes: 
<HTML> 
<HEAD> 
<TITLE>People Color Picker</TITLE> 
</HEAD> 
<BODY> 
<Hl ALIGN=right>People Color Picker</Hl> 
<P>Choose a color below to learn about people who have that 
color as their favorite color:</P> 
<MENU> 
<LI><A HREF="http://www.colors.org/pCp/chart.html">Chartreuse</A></LI> 
<LI><A HREF="http://www.colors.org/pCp/magen.html">Magenta</A></LI> 
<li><A HREF="http://www.colors.org/pCp/cyan.html">Cyan</A></LI> 
</MENU> 
</BODY> 
</HTML> 
Although this example does not provide a marked increase in performance 
(the savings is a mere 5 percent or so), savings become dramatic when a page has 
many links that point to long domain names. With 20 links, for example, the sav-
ings will reach nearly 50 percent over all of the links in the document. 

HyperText Markup Language, the Wireless Way 
There is another reason to use the <BASE> tag, too. Keeping a document's 
links as much in one place as possible makes moving Web pages around easier. 
When www o colors o org decides to move its People Color Picker site to a new 
server, it will only have to edit the <BASE> reference if they use the first example. If 
it uses ~e second, it will have to change each link in the entire document. 
Avoiding Certain Tags 
Although the empty tags <ISINDEX>, <STYLE>, and <LINK> are valid HTML, these 
tags are not generally supported by wireless browsers. Most wireless browsers 
should ignore these tags, but including them may cause problems and will 
always waste space. As virtually no Web browsers on handheld computers sup-
port these three features, there is little point in including them in your content. 
A tag you should consider avoiding unless you know your target well is the 
<SCRIPT> tag because most devices do not support scripting. A few, notably 
Wmdows Powered handhelds, however, can correctly interpret simple JavaScript. 
Consequently, if your site uses the <SCRIPT> tag, you should plan on either devel-
oping a separate version of your content that does not require scripts or checking 
your client's headers to avoid sending JavaScript to less capable devices. 
Marking Up the Document Body 
Most HTML tags mark up the document itself. HTML is a structural markup lan-
guage, meaning that its tags specify how a document is structured, not how it is to 
be rendered. An author specifies the various structural elements of a document 
(sections, paragraphs, lists, tables, and so on), and each browser uses this infor-
mation to determine how best to render the content for its particular display. 
Creating a Section Head 
You may separate documents into sections and subsections, down to six levels, 
delineated with the section heading tags <Hl>, <H2>, <H3>, <H4>, <HS>, and <H6>. 
You should always mark section heads with these tags rather than with specific 
typography (such as bold or italic, which can be created as described under 
"Specifying a Text Style," later in this chapter). This leaves client applications free 
to present them in whatever format works best and even to construct navigation 
aids, such as a table of contents. (NetHopper, for the now-defunct Apple Newton 
platform, did this, for example.) Although the order and occurrence of headings 
is not constrained by the definition of HTML, you should avoid skipping levels 
141 

ChapterB 
142 
(for example, from <Hl> to <H3> ), as this can cause problems in some represen-
tations. 
Some wireless browsers may use the same formatting for several levels of 
section headings. This can be confusing, but often it is the only option, especially 
on platforms with a limited number of fonts. Figure 8-1 shows an example of 
using the same formatting for several heading levels, in Microsoft Internet 
Explorer/Pocket PC (MSIE/PPC) and in Handspring Blazer. Most can present at 
least the first level of section heading fairly clearly; many can also define a second 
level fairly well, at least using the bold face of the standard font. Subsequent lev-
els ( <H3 > through <H6>) are generally not well distinguished from the body text in 
wireless browsers, however, as you can see in the figure. 
~~ Internet Explorer 
-fx E) (+ 
Heading 1 <H1> 
Heading 2 <H2> 
Heading 3 <H3> 
Heading 4 <H4 > 
Headint 5 <H!S> 
Normal body text 
(A) 
(B) 
Figure 8-1. Section headings displayed in (A) MSIEIPPC and (B) Handspring 
Blazer 
Formatting Blocks of Text 
HTML provides three kinds of tags you can use when marking blocks of text. 
These tags enable you to indicate whether a block of text is a paragraph, prefor-
matted text such as a computer listing, or a quotation from another source. 
The tags for use with blocks of text are summarized in Table 8-3, and shown 
in Figure 8-2. 

HyperText Markup Language, the Wireless Way 
~ 
Internet EHplorer 
~K () 0 
Pa-agr aphs are the most common 
block you're ll<ely to create in HTML. 
Sometimes, you11 want text that's 
J}'eformatted, to ensure it looks 
exactly Ike It did beftte: 
dove% ls 
Thomas Hardy wrote: 
One everY1g of late 
surrner, before the 
rineteenth century had 
reached cre-tt'i'd of its 
span, a yourQ man and 
woman, the latter c.nying 
a chid, were apl}'oacling 
the large vilage of Weydon-
Prlors, in Upper Wessex, on 
foot. 
were I · 
but 
One evening of late 
Sl.flmer, beftte the 
nineteenth century had 
reached ere-tt'i'd of its 
span, a young man and 
woman, the latter c<Il)'ing 
a did, were apl}'oactin<J 
the large Wlage of Weydon-
PriJrs, in Upper Wessex, on 
foot. They were plainly but 
not m clad, though the thick 
hoa' of rust wt-ich had 
accunulated on their shoes 
and garments from an 
olmlusly ion~;~ journey lent 
a cisadvantageous 
shabbiness to thelr 
appearance just now. 
(A) 
aragraphs are the most common 
lock you're likely to create in HTML. 
ometimes, you'll want text that's 
reformatted, to ensure it looks 
xactly like it did before: 
ne evening of late summer, 
efore the nineteenth century hod 
eached one-third of its span, a 
oung man and woman, the Iotter 
1:! 
eoched one-third of its span, a 
oung man and woman, the latter 
arrying o child, were approaching 
he Iorge village of Weydon-Priors, 
n Upper Wessex, on foot. They 
ere plainly but not ill clad, though 
he thick hoar of dust which had 
ccumulated on their shoes and 
arments from on obviously long 
·ourney lent a disadvantageous 
hobbines:s to their appearance just 
ow. 
(B) 
Figure 8-2. Blocks of text displayed in (A) MSIE/PPC and (B) Handspring Blazer 
Table 8-3. HTML Tags for Wireless Web Text Blocks 
TAG 
PURPOSE 
NOTES 
<P> 
Marks a paragraph 
<PRE> 
Preformatted text 
Generally set in fixed-width font if 
one is available 
<BLOCKQUOTE> 
Long quotations 
May not be differentiated from body 
or other material 
text on all browsers 
143 

ChapterB 
144 
Paragraphs 
Within a section, documents are composed of blocks of text. The most common 
block of text is a paragraph. Paragraphs in HTML correspond to the paragraphs 
you are reading in this book and are indicated with the <P> tag, like this: 
<P> 
Within a section, documents are composed of blocks of text. 
The most common block of text is a <EM>paragraph</EM>; 
paragraphs in HTML correspond to the paragraphs you 
are reading in this book. 
<IP> 
Neither the opening nor closing tags need to be on their own line, but put-
ting them on their own lines can help to make things more readable. 
Prior to HTML 2.0, paragraphs were not marked as blocks with "start para-
graph'' and "end paragraph'' tags, but separated with a single <P> tag. However, 
when the W3C enhanced HTML and developed the standard for HTML 2.0, it was 
necessary to maintain the begin/ end paradigm for the <P> to adhere to the SGML 
specifications (of which HTML is a subset). Most browsers will support either 
style, but the start/ end style is now seen more frequently, and you should use it 
for all new pages. 
Preformatted Text 
Another kind of text block, called a preformatted region, is set in a fixed-width 
font (like this). Blocks ofpreformatted text are d~marcated with the <PRE> tag. 
You can use these tags to depict tab-delimited tables or other material in which 
character spacing is important, such as in the following code listing: 
<PRE> 
Hi 
Lo 
Kona 
82 
76 
</PRE> 
However, not all browsers on wireless devices support fixed-width fonts, and 
because many people find them hard to read, they are generally a poor choice for 
rendering most kinds of content. 

HyperText Markup Language, the Wireless Way 
Quotations 
The block quote format is used for citing a large body of text. It most often 
appears when long runs of text are quoted from another source-such as one 
article quoting another. This format enables readers to differentiate between reg-
ular text and quoted text (on desktop browsers, block quotes are often preceded 
and followed by blank lines, and slightly indented). The tag used to specify 
a block quote is <BLOCKQUOTE>. 
Making a List 
lists make up a significant portion of the content on the wireless Web because 
they are often more concise than paragraphs. In fact, after summaries, they are 
your best tool for reducing fluff and getting to the substance of your content. Put 
as much of your material as you can into lists, as they best reflect how your users 
are likely to approach your content. Examples of material suitable for list format 
include the following: 
• Directions for navigating 
• Steps in any ordered task, such as preparing a recipe or using a software 
feature 
• A series of items of equivalent or related priority, such as the various stocks 
in a portfolio 
HTML offers several ways to create lists, most of which are well supported by 
the browsers on handheld devices. Each item within a list is marked with the < Ll> 
tag (except definition lists), and the whole list is set off with one of several tags 
that indicate the type oflist, such as bulleted or numbered. 
You can nest lists as deeply as you choose, whether they are all of the same 
kind or of two or more different kinds. (An outline is an example of nested 
ordered lists.) You can use nested lists to create outlines or to make points in suc-
cessively greater detail. The results of nesting lists vary considerably, however. 
Most desktop browsers set off lists from surrounding paragraphs with inden-
tation and set off a list nested within a list by indenting further. Unfortunately, 
this scheme works poorly on the narrow screens of handheld devices, where 
repeated indentation quickly uses up valuable screen space, leaving little room 
for the list items themselves. 
Figure 8-3 shows several types oflists rendered as a succession of screens in 
each browser. Note the readability problems, discussed previously, with both def-
inition lists and nested lists. 
145 

ChapterS 
146 
Internet blplorer 
~E) G 
Scmo lsts are lroCic8od, II<& IH5 <no: 
Tanato sauce 
Moz<Rio 
Ricotto 
5Q.JM -
on a... othor hand, someli'nes ader ~ 
h"Qatint: 
I . Bol the noocfes. 
2. l-leat a... .....:e. 
3. ~ 
the """' to • ...-oe ....... 
of noodos. 
•· --.,....nma-soln 
~.YI"'O''ts. 
fled the""" 
MenJ IUs n»y t.!ike l.P less space ttw\ 
othor lots, ill1d don't have ~ts. 
Chartreuse 
• 
MaQent.l 
• 
Cyan 
Dofntlcn lsts .... usod for tiTogs Ike 
glos ........ 
l asac}'la 
A past.) Ca558ftil 
Comelcrl 
Pasta nocx1es: 'Stuffed wtth 
cheese 
Nested ksts MB OIC, too: 
Moru lots mi>'talco <e>less space lh;n 
othor lsts, ill1d don' have ~ts. 
Chartrwso 
• 
~y 
• 
Cyan 
Defl>tion lsts ille usod fa tiTogs ll<e 
glossaries. 
~ 
p., Pi>l• ,....,ole 
Comelcrl 
Past. noocJes sMfed V>ith 
-
Nestod ISIS ilia OK, too: 
Cyan 
Del'1r-. lots are usod fer tiTogs ll<e 
Qlossares. 
lasac}'la 
APi>IOC>Sset<*! 
Comelcrl 
Pasu noocfes stuffod with 
-
Nostod ists illo OK, too: 
l. Ooa.mont Body Marla.<> 
l . Sectla1s 
2. lllocksofText 
3. 
liSts 
2. T-. 
(A) 
:>ome lists ore unordered, like this 
1 
one: 
• T omoto sauce 
• Mozzarella 
• Ricotta 
• Squash 
• Noodles 
On the other hand, sometimes 
order is important 
1. Boil the noodles. 
2. Heat the sauce. 
~ Rnnlv th.::r. ~n11r~ tn n <:inniP lnvPI" 
•J~~~ 
¢ >~ ~ 
3. Apply th"'"" " "'"''' '''" 1 
of noodles. 
<l. Add sliced squash and cheese in 
~enerous amounts. 
...... " ""'" ,,·~ .,,, .h. ''"·I 
6. Bake until it looks cooked. 
fylenu lists fm?Y toke up less space 
hoo oth" ''"· ooddoo't how I 
~ullets. 
• Chartreuse 
• Magenta 
... 
• (yon 
•1~§1 
¢ >~ ~ 
• Cyan 
Definition lists ore used for things 
ike glossaries. 
osogna 
A pasta casserole 
onnelloni 
Posta noodles stuffed with cheese 
I 
Nested lists ore OK, too: 
1. Document Body Markup 
1. Sections 
l 
? Rlnrk< nf TP,..t 
•I~~ 
¢ >~ ~ 
Ike glOSSarieS. 
osagno 
A pasta casserole 
onnelloni 
Posta noodles stuffed with cheese 
Nested lists are OK, too: 
1. Document Body Markup 
1. Sections 
J 
2. Blocks of Text 
3. Lists 
• Tables 
•15~ 
¢ >~ ~ 
(B) 
Figure 8-3. Lists displayed in (A) MSIEIPPC and (B) Handspring Blazer 

HyperText Markup Language, the Wireless Way 
Table 8-4 summarizes the various list tags available in HTML. You will take 
a closer look at each one in the sections to follow. 
Table 8-4. HTML Tags for Wireless Web Lists 
TAG 
PURPOSE 
<UL> 
Unordered list 
<OL> 
Ordered list 
<DIR> 
Directory list 
<MENU> 
Menu list 
<DL> 
Definition list 
Unordered Lists 
NOTES 
Elements are numbered or lettered 
in sequence. 
Not often used. 
Good for presenting a list of choices, 
where bullets are not necessary. 
Used for glossaries or definitions 
of terms. 
In many cases, the order of items is not important. This is often the case with bul-
leted lists, where items are listed for clarity and all have equal weight. For 
example, this is a list of colors in no particular order: 
These wonderful aprons are available in the following colors: 
<UL> 
<Ll>Umber</LI> 
<Ll>Ochre</LI> 
<Ll>Sienna</LI> 
<IUL> 
You can use the <UL> tag to create unordered lists, which will be drawn with 
bullets, dashes, squares, or similar indicators at the beginning of each list item. 
Ordered Lists 
When the order of items in your list is crucial, use the ordered list tag, <Ol>. The 
browser will generate a number or letter as the leading element for each list item, 
just as it generated bullets for the unordered list. 
147 

ChapterB 
148 
For example: 
<P> 
To make a lasagna: 
<Ol> 
<LI>Boil the noodles.</LI> 
<LI>Heat the sauce.</LI> 
<LI>Apply the sauce to a single layer of noodles.</LI> 
<LI>Add sliced squash and cheese in generous amounts.</LI> 
<LI>Repeat until you've filled the pan.</LI> 
<LI>Bake until it looks cooked.</LI> 
</OL> 
<IP> 
Menus 
Another option is the menu list, which you create with the <MENU> tag. On screen, 
a menu list looks a lot like an unordered list without bullets. This means it can 
be a simple way to create separate lines without using the empty <BR> tag 
(described later in this chapter in "Raw Typographic Styles"). 
The <MENU> tag has not traditionally been used much in HTML, but it is likely 
to get a new lease on life in the wireless Web world, where it can be a handy 
way to present a menu of choices that tie many short one-screen pages together. 
(Recall the People Color Picker example in the section "Specifying a Base URL.") 
Menu lists are also appropriate for lists of headlines, subjects, topics, and, well, 
software menus. 
Definitions 
Definitions are specialized content often presented in a list. In a definition list, 
each item begins with the text to be defined, which is followed by the definition. 
You can create this format, often used in glossaries or in dictionaries, using the 
<DL> tag. Unlike the other kinds of HTML lists, however, the definition list does 
not use the < LI> tag to separate items; rather, special tags denote the item being 
defined-<DT>-and the definition-<DD>-as shown here: 
<Dl> 
<DT>lasagna</DT> 
<DD>A pasta casserole</DD> 

HyperText Markup Language, the Wireless Way 
<DT>Cannelloni</DT> 
<DD>Pasta noodles stuffed with cheese</DD> 
</DL> 
The default layout of a definition list-even in a desktop browser-is rather 
simplistic. There is usually little to connect the item being defined with its defi-
nition; in fact, they often appear on separate lines. For that reason, many people 
prefer to present definitions by kludging together a similar format using para-
graphs, line breaks, and bold tags, such as in the following example: 
<P> 
<B>Lasagna<IB> A pasta casserole</BR> 
<B>Cannelloni</B>Pasta noodles stuffed with cheese 
<IP> 
Of course, this kind of specificity nullifies both the purposes of HTML and 
the definition list. HTML tags are supposed to specify the structure, not the style, 
of a document, and the <DL> tag should allow flexibility in how the definition 
parts are displayed. Some browsers might choose to display definitions in a sepa-
rate view or space, for example. But because in the real world, no browsers do 
take advantage of this flexibility, it is hard to argue against the method I outlined. 
It produces a result that not only looks better to most people, but also requires 
less scrolling and is considerably easier to read. 
Specifying a Text Style 
Many developers who are tempted to play with type styles in HTML are often dis-
appointed to find out that its typesetting capabilities are reminiscent of the 
earliest word processors. 
TYPesetting for the wireless Web is even more restrictive; many mobile 
devices support only a few fonts, and often only a few styles of a particular font. 
Because of their limited memory and low performance levels, many of these 
devices use bitmapped fonts that look good only at specific sizes. Devices that 
use scalable fonts (fonts with a compact representation that scale well to various 
sizes) may provide a better appearance, but there is little standardization among 
the names and appearances of fonts and faces on handheld devices. 
149 

ChapterS 
150 
Idiomatic Text Styles 
Most typographic decisions are best left to the browser, which is presumably 
tuned to make the appropriate typographic decisions on a particular platform 
based on structural tags such as section headings, text blocks, and so on. When 
additional differentiation is required, it is generally best to use HTMI.:s idiomatic 
text styles, which indicate the intent (again, the structure) of the formatting 
rather than specifying a particular representation. This enables the browser to 
pick the most appropriate presentation for a particular environment. 
Table 8-5lists idiomatic tags. As you can see, these tags cover most situations 
where you would choose varying type styles and typefaces in printed text. Using 
these idioms rather than typographic tags frees you to think about content rather 
than the specifics of representation. 
Table 8-5. HTML Tags for Wireless Web Idiomatic 1jrpography 
TAG 
PURPOSE 
NOTES 
<CITE> 
Rendering a 
May be underlined, italicized, 
bibliography citation 
or neither 
<CODE> 
Computer print 
Fixed-width font if available 
<EM> 
Emphasized text 
'fraditionally rendered as italics 
<KBD> 
Material to be entered 
Fixed-width font if available 
at a keyboard 
<SAMP> 
A sequence of 
Fixed-width font if available 
literal characters 
<STRONG> 
Important material 
Usually rendered as boldface 
<VAR> 
A mathematical variable 
Usually italicized 
Raw Typographic Styles 
If you think you just have to have control over the particular appearance of a doc-
ument, you can use typographic tags, shown in Table 8-6. However, you will 
quickly discover that not all the tags look the way you expect on most handheld 
clients. Differences in supported fonts, typefaces, and screen quality make work-
ing with raw typography dicey unless your site is tailored to a specific device or 
unless you are creating content independently for each kind of device. Your best 
bet is to stick with the default font, using the bold tag sparingly to emphasize 
specific information to the reader. 

HyperText Markup Language, the Wireless Way 
Table 8-6. HTML Tags for Wireless Web Raw 'I}'pography 
TAG 
PURPOSE 
NOTES 
<B> 
Boldface 
Most likely supported on any device 
<BR>* 
Line break 
Inserts a line break at the 
current position 
<HR>* 
Horizontal line 
Inserts a horizontal rule at the 
current position 
<I> 
Italic 
Occasionally supported 
<U> 
Underlined 
Easily confused with hyperlinks 
<TT> 
Teletype 
Fixed-width font if available 
<FONT> 
Enables the selection 
Introduced informally after HTML 
of a specific font or 
3.2; codified in HTML 4.0 
modifies font size 
• Denotes an empty tag. 
The <B> tag surrounds text to be set in bold. Almost all mobile browsers sup-
port bold type, and this can be a good way to differentiate content when raw 
typography is appropriate. 
You indicate italic text using the <I> tag. Generally, you use italics for empha-
sis weaker than what boldface implies. About half of the mobile browsers support 
italic text, although many of those that do have wretched italic fonts. These fac-
tors make using italics a poor choice on almost all platforms. 
You can underline text on some browsers using the <U> tag, but I strongly dis-
courage doing this. Underlines mark hyperlinks on browsers; on grayscale 
screens, no colors will be available to tell the user the difference between an 
underlined title and a hyperlink. (In fact, I discourage using this tag in desktop 
content, too, for the same reason.) 
If your content requires a fixed-width font, you can request it using the <TT> 
tag. (The TTis short for Tele'I}'pe.) Unlike the <PRE> tag, the <TT> tag sets the text 
in fixed-width font, but treats all white space as single spaces, and it does not 
preserve other formatting. Because fixed-width fonts are hard to read, this tag 
should be used sparingly if at all. 
One raw typographic tag you should definitely avoid is the <FONT> tag. 
Introduced between HTML 3.2 and 4.0, it is widely used by desktop browsers to 
select both the size and typeface of a font. Wireless Web browsers rarely support 
this tag, however. Even where it is supported, its output is not well defined, as dif-
ferent platforms may have different fonts installed. In addition, the appearance 
151 

ChapterB 
152 
of scaled fonts cannot be predicted with the same kind of accuracy on a hand-
held as on a desktop display. 
Raw typographic tags also exist for separating text blocks. These are less 
problematic than those for specifying fonts and faces, and they can be useful 
in providing separations where headings may not be appropriate. The empty 
<BR> tag inserts a single line break without starting a new paragraph; the 
empty <HR> tag inserts a horizontal line. 
Aligning Text 
It is also possible to specify an alignment for text blocks in HTML using the ALIGN 
attribute with the paragraph tag. Table 8-7 summarizes the values for this attri-
bute. 
Table 8-7. HTML Attributes for Wireless Web Block Alignment 
ATIRIBUTE 
VALUES 
HTML VERSION 
PURPOSE 
ALIGN 
LEFT 
HTML 3.2 and later 
Specifies left alignment of 
a block 
ALIGN 
CENTER 
HTML 3.2 and later 
Specifies center alignment 
of a block 
ALIGN 
RIGHT 
HTML 3.2 and later 
Specifies right alignment 
of a block 
Although not widely supported, this attribute is worth using when you want 
to set off a section's content. It can be used to align text at the left, right, or center, 
as shown in the following example: 
<P ALIGN=left>Left</P> 
<P ALIGN=center>Center</P> 
<P ALIGN=right>Right</P> 
Some browsers may not support the ALIGN attribute but do support the older 
<CENTER> tag: 
<P>Left</P> 
<CENTER> 
<P ALIGN=center>Center</P> 
</CENTER> 

HyperText Markup Language, the Wireless Way 
For centering text, whether to use ALIGN or <CENTER> depends on what is most 
important for your users. ALIGN will create a smaller HTML file; for backward 
compatibility, the <CENTER> tag is more appropriate. It is worth trying both on the 
browsers your subscribers are likely to use to see which is handled better. 
Figure 8-4 illustrates examples of both idiomatic and raw typography, along 
with text alignment. 
~~ Internet Ewplort!r 
-4E E) 0 
Ctazy formatting Isn't iPPf6dat6dby 
lll!lSLof yo~ readers. 
Some browsers 
SJ..Pport different 
font siZes 
wlile some do not. 
Idiomatic TY):e(lg'aphy 
Ote Code ~wiltl 
strong 
Keyboatd s..,.ples usng Vatiables. 
left 
Center 
Right 
VIew Tools <) ~ Q (;;J ~ 
(A) 
rozy formot:t:ing isn't 
appr~dated by most of your 
eoders. 
~ome browsers 
upport different 
ont sizes 
while some do not. 
dioma1ic Typeography 
I 
(it~ Code Emp/Ja.t:h"'ed with St:rong 
Keyboard Samples using v~~-(' . ..., 
£•1551 
¢ > a: -<it 
upport different 
~ 
font sizes 
I 
~hile some do not. 
I 
diomatic Typeography 
t'lt~ Code Emp/Ja.<:i..w with St:rong 
~eyboord Samples using V~~-(' . 
'""eft 
Center 
Right 
t•J551 
¢ > es -<it 
(B) 
Figure 8-4. Raw typography and text alignment displayed in (A) MSIEIPPC and 
(B) Handspring Blazer 
Adding Hyperlinks and Images 
Of course, tags are available for linking documents and adding images to content. 
In general, I recommend using only the most basic tags for linking documents 
153 

ChapterB 
154 
and for inserting images, shown in Table 8-8. The tags for more specialized fea-
tures such as audio are inappropriate for most wireless browsers. 
Table 8-8. HTML Tags for Wireless Web Hyperlinks and Multimedia 
TAG 
ATTRIBUTE 
PURPOSE 
<A> 
HREF 
Specifies a hyperlink 
<A> 
NAME 
Specifies a name for other hyperlinks 
<IMG> 
SRC 
Specifies the source of the image 
<IMG> 
All 
Specifies an alternate title for the image 
<IMG> 
WIDTH 
Specifies the width the image should occupy 
<IMG> 
HEIGHT 
Specifies the height the image should occupy 
The anchor tag (<A>) creates a link between two documents or between 
two parts of a single document. The client will render the argument of this tag 
in a way that indicates a hyperlink is available-usually as underlined text. 
The anchor tag can have various attributes; in general, the only attributes 
appropriate for wireless development are the required HREF and NAME 
attributes. You will use the NAME attribute to name a link, which you can then 
reference using the anchor tag HREF attributes, as in the following example: 
<HTML> 
<HEAD> 
<TITLE>Anchors & Images</TITLE> 
<META NAME="PalmComputingPlatform" CONTENT="true"></HEAD> 
<BODY> 
<Hl ALIGN=righb 
<A NAME="Top"><IA>Anchors and Images 
</Hl> 
<P><IMG SRC="lost.GIF" ALT="Signs"><IP> 
<P><A HREF="#top">Back to the top</A><IP> 
</BODY> 
</HTML> 
This example, which is shown in Figure 8-5, uses the HTML <A NAME= Top></ A> to 
place a marker before the section heading at the top of the page. When a subscriber 
selects the Back to the Top link (HfML<A HREF="#top">Back to the top</ A>), the 
browser will scroll back to the position of the mark at the top of the page. 

HyperText Markup Language, the Wireless Way 
Ffj Internet EKplor~r 
•H E) 0 
View Tools ¢ ~ Q 
_ ~ 
(A) 
(B) 
Figure 8-5. Anchors, links, and the< IMG> tag displayed in (A) MSIEIPPC and (B) 
Handspring Blazer 
This example also shows the simplest < IMG> tag, which is used to include an 
image for display. This tag also has a number of possible attributes that you will 
generally want to use to create robust content. 
Other attributes used are the WIDTH and HEIGHT tags, which can specify 
the size of an image. Most wireless browsers that support the <IMG> tag also 
support the scaling of images using these attributes, although this feature 
is easily abused. Many content providers use these attributes to create 
thumbnail images-smaller versions of a larger image-on pages that offer 
a choice of images. This practice forces clients to download a large image, which 
is then subsequently scaled to the device's display; users must thus expend the 
time and memory necessary to download all of the large images, rather than just 
those they choose to see. Needless to say, this is especially onerous given the 
limited bandwidth of most handheld devices. In fact, the very notion of a page of 
images is a bad idea on the wireless Web. If you find you must provide images-
or scale images-consider doing it using server scripts instead. 
If some degradation in image quality can be tolerated, however, the reverse-
using these attributes to enlarge a smaller image-works well. In general, images 
will become grainy and distorted as they are scaled up, but, depending on your 
content, this approach can work well when both small and large versions of the 
same image are to be displayed. 
On the other hand, the ISMAP attribute, which specifies an image map, is not 
appropriate for wireless devices. Few handheld devices support image maps, and 
those that do may not display downloaded images depending on preferences 
selected by the user. In general, it is inappropriate to use images for navigation; 
155 

ChapterB 
156 
text -based lists of navigation locations load more quickly, display more reliably, 
render on a wider selection of devices, and are easier for a mobile user to use. 
Creating a Table 
You can think of tables as blocks of text within the body of an HTML document. 
The use of tables in a wireless Web page, however, deserves some additional 
attention. Tables are an important part of wireless Web presentation because 
they often provide information more concisely than paragraphs or lists. Many, 
but not all, wireless Web browsers support the table tags introduced in HTML 3.2 
{see Table 8-9). 
Table 8-9. HTML Tags for Wireless Web Tables 
TAG 
INTRODUCED IN 
PURPOSE 
<TABLE> 
HTML3.2 
Marks the beginning and end of a table 
<CAPTION> 
HTML3.2 
Marks a caption for a table 
<TR> 
HTML3.2 
Marks a table row, consisting of multiple table 
cells 
<TH> 
HTML3.2 
Marks a table heading cell within a row 
<TD> 
HTML3.2 
Marks a table cell within a row 
Tables on wireless browsers can be problematic, however. The small screens 
provided by many devices-notably the Palm and Microsoft Palm-sized PC plat-
forms-make tables with more than a few columns difficult to render. Some Web 
designers try to use tables as a means to control the layout of a page, which can 
defeat the optimal rendering of many handheld browsers. Other designers nest 
tables for particular effects, a practice that can consume inordinate amounts of 
memory on a handheld device where rendering sophisticated tables is often too 
difficult for the client. In these cases, the page could take too long to download 
and then be ugly or unreadable on the client, doubly disappointing your sub-
scribers. 
Tables consist of rows of cells, together with an optional caption. The <TABLE> 
tag delimits the start and end of a table. The <TD> tag surrounds each ordinary 
cell, and the <TH> tag indicates a table header cell; these basic table tags are illus-
trated in the following example: 
<TABLE BORDER=l> 
<CAPTION>Times</CAPTION> 
<TR> 
<TH><P>Start</P></TH> 

HyperText Markup Language, the Wireless Way 
<TH><P>Stop</P></TH> 
</TR> 
<TR> 
<TD><P>5:52</P></TD> 
<TD><P>5:57</P></TD> 
</TR> 
<TR> 
<TD><P>6:23</P></TD> 
<TD><P>6:37</P></TD> 
</TR> 
</TABLE> 
This HTML creates a three-row table with two columns. The table elements 
are to be drawn with a single-width border. The table's caption, Times, should 
appear somewhere near the table. The first row-the first <TR> • • • </TR> seg-
ment-labels the columns of the table, and all of the other table cells (between 
the <TO> and <lTD> tags) simply contain times. 
Browsers may make the column heads marked with <TH> stand out in a vari-
ety of ways, such as with bold type or a larger font, if available. Many, however, do 
not clearly differentiate between header cells and normal cells, and this is proba-
bly why many wireless Web developers do not bother to use the <TH> tag. 
The <CAPTION> tag, not surprisingly, enables you to provide a caption for 
a table. This contextual tag, like the <TH> tag, enables browsers to make appropri-
ate typographic decisions best suited to a specific device. Many developers, 
however, try to control the appearance of a table caption; all too often you will 
see something similar to the following: 
Times<BR> 
<TABLE BORDER=l> 
<TR> 
<TH><P>Start</P></TH> 
<TH><P>Stop</P></TH> 
</TR> 
<TR> 
<TD><P>5:52</P></TD> 
<TD><P>5:57</P></TD> 
</TR> 
</TABLE> 
This is bad form. I encourage you to use <CAPTION> instead because some 
browsers may use table captions for special purposes. For example, on a device· 
with a very small screen, a table may be given its own page, and the caption may 
be used as a link between the containing document and the table. 
157 

ChapterS 
158 
In some circumstances, you may want a single cell in a table to occupy multi-
ple rows or columns. The ROWS PAN and COL SPAN attributes of a cell enable it to 
stretch across multiple cells in a row (using ROWSPAN) or a column (with COLSPAN). 
For example, in the table outlined here the weekend rate occupies both the 
Friday and Saturday cells: 
<TR> 
<TD> 
<P>Friday<IP> 
<lTD> 
<TD ROWSPAN=2> 
<P>$99.95<BR> 
<B>(note the weekend ratel)<IB><IP> 
<lTD> 
<ITR> 
<TR> 
<TD> 
<P>Saturday<IP> 
<lTD> 
<ITR> 
The related NOWRAP attribute instructs the browser not to wrap the contents of 
a specific cell. Avoid using this tag, as it can cause inordinately long cells, making 
table layout unwieldy. 
Table elements can use the ALIGN attribute (introduced earlier when dis-
cussing the paragraph tag) to align the contents of a particular cell or heading. 
When the ALIGN attribute is used for a table, it instructs the browser to center the 
table, not the contents of the cells within the table. 
The WIDTH and HEIGHT tags are used by table elements to indicate a desired 
size for the element. Not all browsers support this, and they are considered advi-
sory at best-many browsers will work to fit the width of and height of a cell as 
best they can, but use these values as starting points only. 
Other HTML 4.0 tags, including <THEAD>, <TBODY>, and <TFOOT>, are not avail-
able on most wireless Web browsers and should consequently be avoided. 
These examples and the material in this section should help bring home sev-
eral points I have mentioned already: 
• Keep tables simple. 
• Do not nest tables. 

HyperText Markup Language, the Wireless Way 
• Opt for long, skinny tables over wide, short ones. 
• Do not use tables to override a browser's page layout choices. 
Table 8-10 reviews the attributes you are likely to use when marking up 
your tables. 
Table 8-10. HTML Attributes for Wireless Web Tables 
ATTRIBUTE 
APPLIES TO 
VALUES 
INTRODUCED IN 
PURPOSE 
NOTES 
ALIGN 
<TABLE>, <TH>, 
LEFT,CENTER, 
HTML3.2 
Specifies 
Deprecated in 
<TD>,<TR>, 
RIGHT 
alignment 
HTML4.0 
<CAPTION> 
WIDTH 
<TABLE>, 
An integer 
HTML3.2 
Specifies 
Specify in pixels 
<TH>,<TD> 
width of item 
or percent. Avoid 
specifying widths 
wherever 
possible to 
allow optimal 
rendering of tables 
on different 
platforms 
HEIGHT 
<TD>,<TH> 
An integer 
HTML3.2 
Specifies height 
Specify in pixels 
of an item 
or percent. 
BORDER 
<TABLE> 
An integer 
HTML3.2 
Specifies border 
Used as a relative 
size 
measurement 
(often indicates 
width of border 
in pixels). 
NOW RAP 
<TD>,<TH> 
HTML3.2 
Specifies that a 
Not often supported 
table entry should 
and inappropriate 
not be wrapped 
for most handhelds. 
ROWS PAN 
<TD>,<TH> 
An integer 
HTML3.2 
Specifies how 
many rows this 
cell should span 
COLSPAN 
<TD>,<TH> 
An integer 
HTML3.2 
Specifies how 
Use with caution, as 
many columns 
multiple column 
this cell 
spans can break on 
should span 
small devices. 
159 

ChapterB 
160 
Creating a Form 
Supporting interactive queries is at the heart of mobile Web design. All other fac-
tors being equal, user expectations tend toward greater customization and 
greater interactivity. The ability to target content-to provide a subscriber with 
only the content he or she desires-is often what differentiates one site from 
many other similar ones on the wireless Web. 
Form tags (see Table 8-11) provide developers working in HTML with the 
means to provide simple input areas where users can enter information. You can 
use this information to customize the content for the particular user. 
Table 8-11. HTML Tags for Wireless Web Forms 
TAG 
ATTRIBUTE 
PURPOSE 
NOTES 
<FORM> 
Marks the form region 
ACTION 
Specifies the destination URL 
METHOD 
Indicates the HTTP 
Must be either GET 
method to use 
or POST. 
<INPUT>* 
Specifies a form control 
TYPE 
Specifies the type of the control 
See Table 8-12. 
NAME 
Specifies the name of the field 
for use with the CGI 
VALUE 
Value to be returned to the CGI 
CHECKED 
Is item selected 
Include to select the 
given item. 
SIZE 
Specifies the size of the 
input item 
MAX LENGTH 
Specifies the maximum length 
of the input item 
SRC 
Specifies a URL for an image 
Avoid using in 
on a button 
wireless pages. 
ALIGN 
Used to specify the image 
Avoid using in 
alignment on buttons 
wireless pages. 
<SELECT> 
Specifies a list 
NAME 
Specifies the name of the field 
for use with the CGI 
(continued) 

HyperText Markup Language, the Wireless Way 
Table 8-11. HTML Tags for Wireless Web Forms (continued) 
TAG 
ATIRIBUTE 
PURPOSE 
NOTES 
SIZE 
Specifies the number of items 
to display in the list 
MULTPLE 
If present, indicates how many 
When omitted, list 
items may be selected 
supports only one 
selection at a time. 
May not be set to 
a value. 
<OPTION>* 
Specifies a list element within 
a <SELECT> region 
SELECTED 
Is item selected by default 
If present, item 
is selected. 
VALUE 
Value to be returned to the CGI 
<TEXT AREA> 
Specifies the default entry 
for a text region 
NAME 
Specifies the name of the field 
for use with the CGI 
ROWS 
Specifies the number of rows 
in region 
COLS 
Specifies number of characters 
per line in region 
*Denotes an empty tag. 
Defining the Form 
You identify forms using the <FORM> tag. For each <FORM> tag, you must specify 
two attributes: an action and a method. The ACTION attribute indicates the URL of 
the server and program where the form is to be sent, and the METHOD indicates 
how the form should be sent-using an HTTP POST or GET request method. The 
implementation of the Common Gateway Interface (CGI) scripts on the server 
determines what HTTP method should be used. As you develop CGI scripts, bear 
in mind that for wireless development it is generally more appropriate to use the 
newer POST method than the older GET method. 
Short forms can use the GET method, which has been supported since the 
early days of the Web; longer forms may call for the POST method, which supports 
161 

ChapterB 
162 
longer form bodies. Form data is returned as a series of name/ object pairs. The 
syntax of the response depends on which method was used: POST returns the 
pairs as a separate object body; GET returns the pairs concatenated to the end of 
the destination URL. For example, a form using the GET method would return 
a single URL in this example: 
GET http://www.lothlorien.com/cgi-bin/locate.php3?callsign=kf6gpe HTTP/1.0 
and the corresponding URL requested by a POST method would look like this: 
POST http://www.lothlorien.com/cgi-bin/locate.php3 HTTP/1.0 
callsign=kf6gpe 
Note that only the URL of the CGI script is passed in the request; everything 
else is the form data. In practice, you will never see this level of detail, although 
you may need to know which method is being used depending on how you imple-
ment your CGI script. Most server-side scripting environments (see Chapter 6, 
"Server-Side Content-Management Scripting'') handle this detail for you. 
Collecting User Input 
User input to a form is supported by four kinds of tags. Most form objects are 
specified with the empty <INPUT> tag, which creates an input line (or button, 
depending on its attributes). <SELECT> and the empty <OPTION> tag are used to 
create a pop-up or menu list of items on a form; the actual appearance of the list 
is up to the client to determine. 
Within the <SELECT> region, items are demarcated with <OPTION> tags. Note 
that this tag is in fact empty; there is not an </OPTION> tag. In addition, each 
option must use its VALUE attribute to specify a value to return to the Web server. 
You can create multiline form elements that enable the user to enter sen-
tences or paragraphs using the <TEXT AREA> tag. As I have mentioned before, you 
should avoid requiring lengthy text input from mobile users because their 
devices may not have keyboards. On such a device, entering even a small amount 
of text can quickly become frustrating. 
All form objects should be given a NAME attribute, which specifies the name of 
the input item for the CGI. 
The <INPUT> element uses the TYPE attribute to select the kind of input 
item to create-an input line, check box or radio boxes, a password input line, 
or a button. (Table 8-12lists the possible values of this attribute.) You can indi-
cate a single line oftext input using the value TEXT for the TYPE attribute. For 
a similar short text input object, but one where you do not want the field to echo 

HyperText Markup Language, the Wireless Way 
characters as they are input, use the value PASSWORD for the TYPE attribute 
instead. 
Table 8-12. HTML Attributes for Wireless Web Input with <INPUT> 
TYPE 
TEXT 
PASSWORD 
CHECKBOX 
RADIO 
SUBMIT 
RESET 
HIDDEN 
PURPOSE 
NOTES 
Creates a single text input line 
Creates a single text input line 
Input is not echoed to the user. 
Creates a check box element 
Creates a single radio button 
Creates a submit button 
Creates a reset button 
Creates a hidden 
name/value pair 
Radio buttons can be grouped by 
using the same NAME attribute value. 
Multiple SUBMIT buttons can be 
created with unique NAME attributes. 
The reset button resets the form's 
values to its default. 
This is used by dynamic forms to 
cache content between multiple 
requests and responses. 
FILE 
Requests the user to select a 
This is not appropriate for use with 
file to upload to the server 
wireless browsers. 
IMAGE 
Creates a button with an image 
This is not appropriate for use with 
wireless browsers. 
You can use the CHECKBOX value for TYPE to provide multiple possible 
selections and the RADIO value for TYPE to offer two or more mutually 
exclusive selections. These elements should be used to select optional behav-
iors, not items from an array of choices. Selecting a radio button or a check box 
indicates a characteristic of something ("the blue t -shirt," for example), not an 
actual action ("buy at-shirt"). Both support grouping using the NAME attribute; 
a group of RADIO buttons with the same name will only enable one element 
within that group to be selected. 
An <INPUT> tag can be used to handle form actions using the SUBMIT and 
RESET TYPE values. Each provides a button labeled with the NAME attribute indi-
cated for the tag. When pressed, the SUBMIT button packages the form's contents 
and submits the results to the URL indicated in the form's ACTION via the HTTP 
method indicated by the form's METHOD value. The RESET button, on the other 
hand, sets all the fields to supplied default values (or empties the fields if no 
defaults are provided) and displays the empty form to the user. Multiple in-
puts with SUBMIT values for the VALUE attribute, each with a distinct name, are 
163 

Chapter8 
164 
permissible, enabling a single form to be sent to the specified URL with the name 
of the button the user selects. 
The following form, shown in Figure 8-6 on various browsers, illustrates the 
concepts behind the different form input tags and their appearance for a hypo-
thetical page offering weather reports: 
<HTML> 
<HEAD> 
<TITLE>North American Weather</TITLE> 
</HEAD> 
<BODY> 
<H1 ALIGN=right>North American Weather</H1> 
<P>Enter the postal code and country:</P> 
<FORM 
ACTION="http://www.wirelesswx.com/cgi-bin/getwx.cgi" METHOD="POST"> 
<P>Postal Code: 
<INPUT TVPE="text" NAME="Code" VALUE="" SIZE=10 
MAXLENGTH=10><BR> 
Country: 
<SELECT NAME="Country"> 
<OPTION VALUE="C">Canada 
<OPTION VALUE="U">United States of America 
<OPTION VALUE="M">Mexico 
</SELECT><BR> 
<INPUT TVPE="checkbox" NAME="cond" VALUE="cond"> 
Current conditions<BR> 
<INPUT TVPE=checkbox NAME="fore" VALUE="fore"> 
Forecast</P> 
<P>Units: 
<INPUT TVPE="radio" NAME="unit" VALUE="m" CHECKED>Metric 
<INPUT TVPE="radio" NAME="unit" VALUE="e">English 
<IP> 
<P> 
<INPUT TVPE="submit" NAME="Weather" VALUE="Weather"> 
<INPUT TVPE="reset" VALUE="Clear"> 
</P> 
</FORM> 
</BODY> 
</HTML> 
Not all form elements need to be visible. The <INPUT> HIDDEN TYPE value 
enables additional name/value pairs (indicated with the NAME and VALUE attri-
butes) that do not appear on the form to be returned to the server. In a situation 

HyperText Markup Language, the Wireless Way 
where multiple forms are dynamically generated by back-end scripts, this capa-
bility can be useful for carrying context between forms, such as order numbers or 
a user's authentication. HIDDEN elements are not completely secure, but they can 
be used to replace some of the functionality offered by cookies. 
The FILE attribute, if used in conjunction with the POST method, enables 
some clients to submit files in response to a form. This is not necessarily a good 
idea for content intended for wireless clients; not all wireless devices support file 
systems, and sending an entire file might be prohibitively expensive for the sub-
scriber. 
Although it is possible to create buttons with images on them using the IMAGE 
attribute, do not. Wueless clients may not support the display of images, or 
a subscriber may have turned off image downloads. In either case, the user is 
faced with a series of similar buttons that have no labels. 
Ideally, most forms for mobile clients should be even simpler than the 
weather information form shown in Figure 8-6. Note the use of a <SELECT> list to 
enter a country (as opposed to free-input or check boxes), and of a check box 
to indicate actions to be taken by the server. 
~fJIIntern~t EMplorer 
.. E 0 0 
North American 
Weather 
Enter the postal code il1d cOU'ltry; 
Postal Code;;..!: =:====---, 
Cm.ntry: "'lcan:::..:ada=-=-------' .. 1 
D Current cordtlons 
D Faecast 
Ufits: @ Metric 0 EnQilsh 
I Weather II Clear I 
Ylew Tooh ¢ ~ Q €::)1 ~ 
(A) 
North American Weather 
nter the postal code and country: 
ostal Code: :::::::::::::::::::::::::::::: 
(B) 
Figure 8-6. A form displayed in (A) MSIEIPPC and (B) Handspring Blazer 
Using Other HTML Tags 
The constraints of mobile devices eliminate a great deal of the glamour ofWeb 
content development. Frames, image maps, sounds, scripts, and other such gim-
micks simply are not appropriate for a device the size of a calculator or notepad. 
Even if these handheld items evolve to the point where they do have the compu-
tational horsepower, memory, and wireless bandwidth to support such features, 
165 

ChapterS 
166 
most users will not appreciate navigating through such junk in search of their 
content. Remember that wireless users are mobile for a reason-they are proba-
bly in a hurry. 
When developing wireless content, stick to the subset of HTML outlined in 
this chapter. I have already mentioned several pitfalls to avoid when using these 
elements, including nesting tables, using images, or, worse, using image maps for 
navigation (all links should be marked with text). Some whole categories of fea-
tures, however, should be avoided altogether. Specifically, do not use the 
following: 
Frames: Displaying frames properly on a screen can occupy many hun-
dreds of pixels on one side-generally far more than are available on 
a mobile device. For kinds of information that is traditionally placed in 
frames, try creating multiple pages with a common navigation element. 
Sounds: Although some browsers do support audio, the bandwidth an 
audio file requires is excessive for many wireless users. And in any case, 
how many users really want their wireless Web devices to start talking to 
them in public? 
Scripting: Although not formally a part of HTML, the scripting technolo-
gies presently available-Java, JavaScript, and VBScript-are widely used in 
pages aimed at desktop Web viewers. Scripting is not even available on 
many mobile Web clients, however; and those clients that do provide sup-
port for scripting may not adhere to accepted specifications for 
functionality. Waiting until mobile-friendly scripting technologies such as 
Sun's Java KVM are adopted is your best bet. 
As time goes on, many of these features may become more widely and/ or 
more readily supported within the capabilities of a handheld device. You may 
find that using them becomes more and more tempting. Remember, however, 
that subscribers will not upgrade wireless terminals in the same way they do soft-
ware. Legacy browsers unable to handle these features well are likely to still be in 
common use several years after their manufacture. 
Summary 
HTML is a powerful tool for content development on both the World Wide Web 
and the wireless Web. Not all HTML commands are appropriate for wireless 
browsers, however. By using a carefully selected subset of HTML, you can create 
concise Web pages that use reasonable quantities of bandwidth and address the 

HyperText Markup Language, the Wireless Way 
special needs of wireless subscribers. Remember these general tips as you create 
your HTML content: 
• Keep content simple. 
• Allow the browser to select the best methods of presentation for a given 
combination of structural element and device. 
• Keep tables as small as possible; if they must be large, make them long 
rather than wide. 
• Avoid the use of frames, images, and bandwidth-intensive content. 
Be sure to declare a document heading with the document's title and any 
meta tags your subscriber's browsers will need. Often, you will want to be sure to 
include browser-specific meta tags such as PalmComputingPlatform and 
Handheld Friendly to ensure that these pages display correctly on specific 
browsers. 
Use HTML's idiomatic tags whenever possible. That means you will want to 
use the section head tags, block tags, and idiomatic tags such as <STRONG> to call 
out important content. Avoid raw typography such as <B>, <I>, and the <FONT> 
directive. The same guidelines apply to lists, too; HTML provides a rich set of tags 
for creating ordered and unordered lists, as well as definition lists for glossaries 
and lists of choices. Use images judiciously, always in conjunction with a text 
label using the <IMG> tag's AL T attribute. Other kinds of multimedia-sounds or 
movies-are always inappropriate for wireless-oriented content. 
Tables should be laid out simply using the table caption, table head, and cell 
tags. Preferably, these tables should be long and skinny, or better yet, short and 
skinny. The table tags new to HTML 4.0 are not widely supported, so be sure you 
use only the older HTML 3.2 tags discussed. 
Form input enables you to target your content to your viewers. Be sure to do 
so, keeping in mind how they are likely to use the browser. Using the <SELECT> 
and <OPTION> tags is preferable to asking the user to enter text with the 
<TEXT AREA> tag. When getting form input, you will find it easier to manage data 
submitted with the HTTP POST request, which you can specify using the <FORM> 
tag's METHOD attribute. 
Above all, keep your markup simple. 
167 

CHAPTER 9 
Palm Powered Web 
Clipping Applications 
RATHER 1HAN BROWSE THE WEB, mobile users seek answers to specific questions, 
such as the location of the closest hotel or restaurant. Although you can structure 
any wireless Web application to meet this expectation, only one wireless develop-
ment framework specifically addresses this concern from the ground up. 
In this chapter, I talk about Palm's Web Clipping Architecture, which lets you 
create Palm Powered applications using HyperText Markup Language (HTML) 
that meet your users' needs for targeted information. I first introduce the con-
cepts behind the system and then look at how to develop content for Palm 
Powered devices that take advantage of both its user interface and specific net-
work capabilities in a platform-independent manner. Finally, I extend the 
example presented in Chapter 6, "Server-Side Content-Management Scripting," 
to include the Palm Powered platform. 
Introducing the Web Clipping Application 
Architecture 
Palm's Web Clipping Application Architecture is a unique use of server-assisted 
browsing that allows certain devices, such as the Palm Powered Palm VII and 
Palm Powered i705 with wireless interfaces, to access specific Web sites via 
a wireless network. Responsibility for the content is shared between the server 
where it originates and a Web Clipping Application (WCA), which resides in the 
handheld device. (Historically, the WCA was known as the Palm Query 
Application, and it is so referred to in a great deal of the existing literature.) 
The WCA residing on the wireless terminal is not truly an application; rather, 
it is a highly compressed aggregation ofWeb content formatted for the Palm 
device created by a desktop tool. This content may contain both images and 
HTML content, including links to external Web resources. The Palm WCA viewer 
displays this package of data with an interface reminiscent of a simple Web 
browser. Figure 9-1 shows a representative Palm WCA. 
169 

Chapter9 
170 
Figure 9-1. The Palm WCA 
1112000
1\Ac~c! 
osition37° 18..58' H. tnc» 8.79"W. 
osition rtpon rectl¥td ~ 
111lnutts 
O$tcMds ogo. 
When a link in a WCA is selected, the viewer application finds the content-
either in the WCA itself or by making a wireless connection to a proxy 
server-which in tum requests the information from the origin server and 
returns it to the proxy. The proxy then performs a strenuous series of operations 
on the content, reducing it through tag stripping, representing tags as individual 
(and shorter) words called tokens, and compression, then returns the com-
pressed content to the device. 
You can use WCAs for a variety of purposes: transferring formatted static 
content to a device, aggregating a number ofWeb links, or tailoring content for 
a Palm device. 
The first of these-viewing static information on a handheld device-is sur-
prisingly underused. The desktop program responsible for creating a WCA can be 
used to aggregate content from a number of devices, and the fact that content 
can be provided in HTML means that sophisticated typesetting, including the 
embedding of links and graphics, is possible. WCAs are thus a good distribution 
mechanism for such static content as e-texts of corporate handbooks and other 
information. 
Then there is content that is relatively dynamic, but formatted simply, such 
as remote log files or other measurements. A WCA can be constructed as an index 
page that leads to an array of content, with links to the content that changes. You 
should take care when establishing this kind of application, however, to be sure 
that the amount of data to be obtained over the wireless network is not exces-
sively large. 
The most typical WCA is a query application, in which a targeted page in the 
WCA connects with a server CGI over the wireless network to obtain a specific 
piece of information-in other words, to answer a query (hence the name). Most 
users will gain the greatest value from these query applications, as their mode of 
operation most closely mirrors the needs of most mobile users, who want spe-
cific pieces of information quickly, such as, "What was that stock's price?" and 
"What does lachrymose mean?" and so on. 
Query applications can manage both clear text (not requiring encryption) 
and secure data. Because the Palm WCA provides over-the-air encryption of 

Palm Powered Web Clipping Applications 
HyperText 'fransfer Protocol Secure (HTIPS) requests, it can be useful in 
e-commerce solutions. 
Learning WCA Fundamentals 
Developing content for a WCA is similar to developing content for other mobile 
devices. However, the Palm platform has some specific limitations that must be 
met, notably that you should use HTML 3.2 or below (described in Chapter 8, 
"HyperText Markup Language, the Wireless Way'') to mark up your content 
(meaning no scripting or frames) and that nested tables, small fonts, supet-
scripts, subscripts, or vertical alignment should not occur in your content. You 
should also-as with most wireless browsers-avoid the <ISINDEX> tag. 
Generally, content that resides on the device is written first, followed by any 
content and/ or scripts to be provided by a Web server. Content for the device 
could be a single HTML page or multiple pages with links between them. These 
links should be relative-in other words, in the form file. html. 
WCA-Specific HTML Entities 
There are several entities unique to WCAs that developers can use to do the fol-
lowing: 
• Create new interface components not found in traditional HTML 
• Uniquely identify the device in form submissions 
• Control the operation of the viewing application 
Table 9-1 shows these entities, which are discussed in more detail in the next 
section. 
171 

Chapter9 
172 
Table 9-1. WCA~Specific HTML Entities 
ENTITY 
%DEVICEID 
DATE PICKER 
PURPOSE 
Is replaced with a device's unique ID, 
if available 
Presents a form element for validated date 
entry that adheres to Palm's user interface 
constraints 
%LOCATION 
Is replaced by the device location for a 
form response as determined by the 
wireless network 
<META NAME="PalmComputingPlatform" 
Indicates that content is tailored forWCAs 
VALUE="true"> 
<META NAME="HistorylistText" 
VALUE="value"> 
<META NAME="PalmDoNotCache" 
VALUE="value"> 
<META NAME="PalmlauncherRevision" 
VALUE="value"*> 
<META NAME="Locallcon" 
value="file.gif"> 
PALMBINARY* 
<SMALLSCREENIGNORE> 
TIMEPICKER 
%WCDEVCAPS* 
%ZIPCODE 
Creates a custom label for a page's history 
entry in the history picker 
Whether the page should be cached by the 
Palm Powered device 
Establishes the WCN.s version number for 
PalmOS dialog boxes 
Adds a local image to a WCA for over-the-
air references 
Specifies that the link that follows is a link 
to Palm native binary content 
Causes the Palm proxy server to disregard 
the content between the start and end of 
the entity 
Presents a form element for validated time 
entry that adheres to Palm's user interface 
constraints 
Is replaced by the device's capabilities in 
a form response 
Is replaced by the ZIP code of the base 
station serving the wireless terminal 
* Not supported on devices before PalmOS 4.0. 

Palm Powered Web Clipping Applications 
The most important of these for you, as a developer, to remember is the meta 
entity with the name/value pair of PalmComputingPlatform and TRUE (that is, <META 
NAME="PalmComputingPlatform" VALUE="true">), which indicates to the Palm 
proxy server that a given page was authored with the Palm Powered device in 
mind. If you do not include this tag, the proxy server may manipulate the content 
in ways you do not expect in the hopes of making the page smaller or more pre-
sentable on the device. 
Another meta entity you are likely to use is HistorylistText. Each Web 
Clipping Application keeps a separate history, which users can access by tapping 
the pick list in the upper-right comer of the screen. By default, a page in the his-
tory list is named after the title of the page, but you have the option of creating 
a separate name for each item in the list. If you include the special keywords 
&DATE and & TIME in a name, they will be replaced by the viewer with the page's 
download date and time. 
Two other special meta entities are used only in the main page of a WCA. 
<META NAME="PalmlauncherRevision" value="value"> enables a WCA to specify 
a recognized PalmOS version number, which you can see in the application 
launcher's version screen. The tag <META NAME="Localicon" value="file.gif"> 
enables a'WCA to include an image that can be referenced by content down-
loaded from the network. Developers can use this feature to cache commonly 
used graphics such as company logos and weather symbols within the WCA, 
minimizing the application's reliance on over-the-air image transmission. 
WCAs can access such local content using URLs in the form 
file:/ /myapp.pqa/file.gif, where myapp.pqa is the filename oftheWCA, and 
file.gif is the name of the image to be accessed specified in a Localicon <META> 
entity. 
The PalmDoNotCache <meta> is a meta directive new to the Web Clipping 
Application for PalmOS 4.0 that directs the client to explicitly disobey the HTTP 
cache control headers and never cache the indicated page. You can use it when 
server load is less important than up-to-date information such as real-time 
financial information or other data. 
Three form entities help developers identify a query's origin: the %DEVICEID, 
%ZIPCODE, and %LOCATION tags. These tags are form value tags; you place them as 
the default value in a hidden form element like this: 
<INPUT TYPE="hidden" NAME="1ocation" VALUE="%ZIPCOOE"> 
The %DEVICEID tag provides a unique identifier for the wireless access termi-
nal. Although the identifier is guaranteed to be unique, you should not attempt 
to use its contents to determine additional information about the device. This 
identifier will be prefixed by a 1, 0, or -1, which indicate, respectively, that the 
device was positively identified, that no positive identification could take place, 
or that the validation failed and no identification was available. 
173 

Chapter9 
174 
The %ZIPCODE entity provides the United States ZIP code of the base station 
from which the wireless terminal is accessing the network, allowing query appli-
cations to provide a medium -scale notion of their location. Typically, this entity is 
used in a form, where the service provider's proxy servers replace %ZIPCODE with 
the base station's ZIP code. 
Newer devices-those running PalmOS 4.0 and above-also respond to the 
%LOCATION tag, which can provide access to fine-grained location information 
such as the device's current latitude and longitude determined by the wireless 
network, Global Positioning System (GPS), or another on-board source. The 
%LOCATION tag is actually a set of tags, beginning with the tag itself and followed 
by a colon (:), a set of arguments that determines what location information 
your server receives, and a trailing period(.). Table 9-2lists the valid location 
arguments. 
Table 9-2. WCA %LOCATION Tag Arguments 
ARGUMENT 
RETURNS 
c 
City name 
G 
Global position (latitude & longitude) 
1 
State name 
L 
State code 
0 
County name 
0 
County code 
R 
Raw location data returned by the network 
y 
Country name 
y 
Country code as defined by ISO 3166-1993 
z 
ZIP or postal code 
For example, the following form tag: 
<INPUT TYPE="hidden" NAME="location" VALUE="%LOCATION:G."> 
would send the device's latitude and longitude to your server in the form variable 
location. 
The following example obtains both a device's unique identifier and location. 
The identifier is returned in the form variable userid, and the ZIP code of the 
base station is returned in the form variable location: 

Palm Powered Web Clipping Applications 
<FORM> 
<INPUT TYPE="hidden" NAME="location" VALUE=%ZIPCODE> 
<INPUT TYPE="hidden" NAME="userid" VALUE=%DEVICEID> 
</FORM> 
Note that these entities are not foolproof. A user with a Web browser can 
spoof the %0EVICEID value, and the %LOCATION and %ZIPCODE entities may not give 
a precise location because in some areas one base station serves several ZIP 
code regions. A safer way is to use the %DEVICEID attribute in conjunction 
with verifying the origin Internet Protocol (IP) address of the request 
because Palm publishes the IP addresses that their proxies use. 
WCAs also support specialized entities for entering dates and times in forms, 
too. The DATEPICKER and TIME PICKER entities produce custom input items that 
match the Palm Powered user interface guidelines for the entry of date and time 
in forms (several examples are shown in Figure 9-2). You use them as follows: 
<P><FORM ACTION=" . . . " METHOD=POST> 
Birthdate: <INPUT TYPE=datepicker NAME=date><BR> 
Birth time: <INPUT TYPE=timepicker NAME=time><BR> 
<INPUT TYPE=submit NAME=Go VALUE="Submit"> 
</FORM><IP> 
• 
Famous Birthdays 
Enttr pow birth do~t (and U••· 
optioMI,) to leornwl'lOIII'IIKborn 
neor,otrbirt~ 
BW'thdo 
~?,~~~'~! 
Bi<th ,;.J)Hl..!!!!.i 
(Subolt< ) 
CoorriCJht & QisdqiMr 
Sele<t dote 
~ 2000 ~ 
~ :: l:l: l:vl :l 
SMTWTFS 
1 
23
4
S& B
t 
9 
10 
II 
12 
13 14 
IS 
1& 
17 
18 
19 20 21 
22 
23 24 25 2& 27 28 29 
30 31 
( Can<ol )( T aday J 
• 
Famous Birthdays 
n1tr JOUr' birth datt (ond -. 
.. 
ptlonoly) toleG-fl who wosbom 
eor rour birthdo;. 
irthdat~! tn/00 M! 
ttl''"' 
ml 
lfl : [ill] ~ lll:ffiJ 
CK) ( canc .. ) 
Figure 9-2. TheDatePicker andTimePicker form items in action 
You use the PALMBINARY attribute with links to PalmOS native binary content, 
such as to download a Palm OS application or other WCA: 
<A HREF="new.pqa" PALMBINARY>Download<IA> the latest version. 
Bear in mind, however, that downloading an entire WCA or Palm application 
can consume a great deal of bandwidth on today's wireless networks. 
Any developer constructing one set of content for both a WCA and a conven-
tionalWeb browser will want to take advantage of the <SMALLSCREENIGNORE> 
175 

Chapter9 
176 
entity. As its name implies, this entity causes the Palm servers to ignore any con-
tent referred to within this tag. 
The WCA Builder 
Once you have created new Web pages suitable for your WCA, you bundle them 
using a tool from Palm, called the WCA Builder. This tool creates a Palm database 
from the HTML files and some additional information, which can then be 
installed on Palm devices and viewed using the Web Clipping browser appli-
cation. 
The application is simple to use. Figure 9-3 shows how it appears on 
a Macintosh (the interface is similar under MicrosoftWmdows). The main list 
shows the HTML files to be included in the WCA and their sizes. Below this list, 
you see the uncompressed and compressed sizes ofyourWCA (the compressed 
size tells you how big it will be on the device). You can pick small and large icons 
that appear in the Palm's application launcher using the buttons on the right. To 
use the tool, follow these steps: 
1. 
Open the main page ofyourWCA-the one viewers should see when 
launching the WCA itself-with the menu File > Open command. 
2. If you want to choose different custom icons to appear in the Palm's 
Launcher application (where installed WCAs are displayed), click the 
Small leon or Large Icon buttons and select the appropriate images. 
3. Enter a name for the resultingWCA (usually a file in the form name.pqa) 
and press the Build button. 
File 
Figure 9-3. The Palm WCA Builder application 

Palm Powered Web Clipping Applications 
Once the WCA has been produced, you can test it on either a Web 
Clipping-enabled device or on the Palm emulator. Freely available from Palm 
Computing's Web site (www. palmos. com), this emulator needs a Read-Only 
Memory (ROM) image from a device such as the Palm VII to operate. For testing 
purposes, you can either obtain the ROM from Palm computing or use the emu-
lator's own tools to extract it from a Palm VII. 
Creating a Sample WCA 
For a sample WCA, I have returned to the example used in Chapter 6, "Server-
Side Content-Management Scripting," that indicates the position of Automatic 
Position Reporting System (APRS) stations. Figure 9-4 shows a WCA that accom-
plishes the same task-presenting a map showing a station's location when the 
user enters its call letters. The WCA has three parts: 
• An index page that prompts the user for the station's call letters and the 
desired map scale 
• A page about APRS and amateur radio 
• A page acknowledging contributors to the data stream behind the WCA 
• • 
RPRServe Find 
(al<iQn.~fiw>! __ 
Sc:olt: ..,. SOOft 
~ 
~~ 
• "" t., 11Jcl'lpettr. '"•at. C•m~tttts 
..,..,eu~~otto ,ht!ll!!!:., 
ms 11: •rtglmrH trUtM"~ otiH.S 
Sortnnan4..., Sruni.,.. WI41ltl. 
Figure 9-4. The APRS/Find WCA 
Cii!i[J 
m2000 \tofnty Ce 
Position 3P 18..51i1' H. 122° 8.78' W. 
Position repor~ nctlved 46 Minutts: 
Slil second5 ogo.. 
The files for each of these three pages, and the logo for the application, are 
stored in a single folder, and WCA Builder is run with the index. html page as its 
opening argument. The resultingWCA can be installed on the Palm VII in the 
same manner as any application and made available through channels familiar 
to Palm users. 
Listing 9-1 shows the HTML for the index page. 
177 

Chapter9 
178 
Listing 9-1. The APRS/Find WCA 
<HTML> 
<HEAD> 
<TITLE>APRServe Find</TITLE> 
<META NAME="PalmComputingPlatform" CONTENT="true"> 
</HEAD> 
<BODY> 
<H1 ALIGN=right>APRServe Find</H1> 
<P> 
<FORM ACTION="http://"tMW.lothlorien.com/cgi-bin/palmvii-aprs-map.pl" 
METHOD= POST> 
<CENTER> 
Callsign: 
<INPUT TYPE=text NAME=CALLSIGN VALUE="" SIZE=10 MAXLENGTH=10> 
<BR> 
Scale: 
<SELECT NAME=SCALE> 
<OPTION VALUE=SOOOO>SOO ft 
<OPTION VALUE=100000>1 mi 
<OPTION VALUE=200000>2 mi 
<OPTION VALUE=800000>S mi 
<OPTION VALUE=3200000>50 mi 
</SElECT> 
<INPUT TYPE=hidden NAME=version VALUE=2> 
<INPUT TYPE=submit NAME=Submit VALUE="Find"> 
</CENTER> 
</FORM> 
<IP> 
<CENTER> 
<A HREF="about.html">About</A><BR> 
<A HREF="credits.html">Credits</A> 
</CENTER> 
<HR> 
<FONT SIZE="-1">1kopy; 1999-2001 Ray Rischpater, KF6GPE. Comments may be 
sent to the </FONT><A HREF="mailto:dove@lothlorien.com"> 
<FONT SIZE="-1">author</FONT><IA><FONT SIZE="-1">.<BR> 
APRS is a registered trademark of APRS Software and Bob Bruninga, 
WB4APR.</FONT></CENTER> 
</BODY> 
</HTML> 

Palm Powered Web Clipping Applications 
Note that this HTML file strongly resembles one that might be used by a Web 
page on a server to provide the same information or by the AvantGo channel 
described in Chapter 14, "Content Delivery." This similarity demonstrates the 
utility of a WCA for a content developer: It requires little work beyond creating 
a standard HTML file. Note also that the form contains a hidden version number 
that can be used by the server to differentiate among different versions of the 
WCA in the event that you decide to extend its functionality on the back end. 
The server behind the content returns a page with content such as Listing 9-2. 
Listing 9-2. A Response from the APRS/Find WCA 
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"> 
<HTML><HEAD><TITLE>kf6gpe</TITLE> 
<META NAME="pa1mcomputingplatform" CONTENT="true"> 
<IHEAD><BODY> 
<H1 ALIGN=right>kf6gpe</H1> 
<CENTER> 
<P> 
<IMG SRC="http: //www. vicinity.com/gif?& 
CT=37.17500:122.14500:200000:&IC=37.17500: 
-122.14S00:100:kf6gpe&FAM=mapblast&W=80&H=80"> 
<IP> 
</CENTER> 
Position 37&#176 10.50' N, 122&#176 8.70' W.<BR> 
Position report received 9 minutes 41 seconds ago. 
<IBODY><IHTML> 
NOTE 
The < IMG> tag in the listing is actually all one line, but I have bro-
ken it here into three lines so it fits on the page. 
Chapter 6, "Server-Side Content-Management Scripting," shows the server 
scripts behind this response. Note that the page includes the 
PalmComputingPlatform <META> entity, indicating to the Palm proxy servers that 
this page was formatted for Palm handheld computing devices. The image itself 
is intentionally small, both to respect the small screen size and to keep the aver-
age size of the data for the page with the image to a kilobyte or so for rapid 
transport across both the Mobitex and Global Service for Mobile (GSM) networks. 
179 

Chapter9 
180 
Summary 
The Palm Web Clipping Application Architecture addresses two key aspects of 
wireless Web development: a user's need for a specific fact and a developer's need 
for rapid development through standard tools. 
The Palm WCA lets you write a query application, an HTML document that 
appears to the user as a standard Palm application. Unlike Palm applications 
written in C, however, a query application is written using HTML compressed by 
a desktop application. The resulting application combines the Palm Powered 
user experience with rapid access to Web content. This Web content should con-
form to HTML 3.2, as well as respect the small form .factor (typically smaller than 
200 pixels) of a Palm Powered device. 
To integrate your query application with the Palm Powered platform, the 
Palm WCA includes tags that let you present Palm Powered user interface ele-
ments for time and date, as well as download Palm native binary applications. 
You can also use these extensions to determine a device's location, speeding user 
input for location-based services. 
Because the Palm WCA uses standard HTML, it is easy to integrate support 
for query applications into your wireless Web product. Moreover, if you start your 
wireless Web offering by creating a Palm WCA, it is easy to extend it to support 
other wireless HTML browsers, including i-mode and more traditional browsers 
such as Microsoft Internet Explorer for the Pocket PC and Opera running on 
handheld Linux devices. 

CHAPTER 10 
i-mode Applications 
INTERNATIONALLY, NIT DoCoMo's i-mode has arguably been the most successful 
wireless technology to date. With tens of millions of subscribers in Japan alone, 
i-mode's success has been widely coveted by other carriers around the world 
interested in expanding the wireless Web. In fact, with more users than any 
other wireless Web service, NTT DoCoMo has made substantial investments 
in other wireless providers, including AT&TWrreless and KPN Mobile. 
Unlike the technologies discussed so far, i-mode is not just a markup lan-
guage or technology-it is an entire business model. Providers such as i-mode 
offer developers as well as subscribers an end-to-end business model based on 
HyperText Transfer Protocol (HTTP) and HyperText Markup Language (HTML). 
In this chapter, I show how this business model works, as well as how to develop 
i-mode content. 
Looking at the i-mode Architecture 
The i-mode architecture is essentially the same as other proxy-assisted Web 
browsers, as you can see from Figure 10-1. Using a proxy to bridge the gap 
between the Web and the carrier's network, i-mode-enabled wireless terminals 
can view a subset ofHTML 3.2. 
181 

Chapter 10 
182 
i-mode Handset 
Wireless Network 
Internet 
Figure 10-1. A deployment view ofi-mode 
By supporting HTML, i-mode shares the same simplicity for you as the Palm 
Powered platform and more traditional handhelds. In fact, many of the thou-
sands of i-mode sites counted by NTT DoCoMo are sites written for any wireless 
Web browser that looks presentable on i-mode handsets. These pages may con-
tain HTML and references to GIF images and must be smaller than 5 kilobytes. 
There are two specific differences to consider, however: the devices on which 
you can viewi-mode content, and i-mode's business model. Unlike most of the 
technologies in the preceding chapters, most i-mode users view i-mode content 
on telephone handsets, with screens at least half as small as the typical handheld. 
The business model, however, is wholly different than that for any other 
wireless Web service save the downloadable applications discussed in 
Chapter 15, "Custom Applications: When a Browser Won't Work" (which, as you 
will see then, draw from i-mode's success). Services offering i-mode provide two 
tiers of content: content validated by the service that resides in a walled garden 
and content that the browser can display but resides outside the walled garden. 
Ensuring your content is within the walled garden provides significant· 
advantages. First, your content is available from the menus subscribers see when 
they launch the browser on the handset. This is an important benefit for you 
because most users will not make the effort to browse sites outside of this menu. 
Second, and perhaps even more importantly, those sites have the opportunity to 
share in revenue generated by the service. 

Unlike to day's Wrreless Application Protocol (WAP) or HTML sites, the 
i-mode gateway provides a billing infrastructure that lets you charge subscribers 
for the content they view within the walled garden. These charges show up on the 
subscriber's bill and do not require additional effort on your part besides the ini-
tial certification by the service and inclusion in the walled garden. As part of the 
billing arrangement, the service provider retains a percentage of the revenue as 
a fee for handling the complexities of billing on your behalf. 
In return for these benefits, the service provider must approve your content 
within the walled garden through a rigorous certification process. Testing forcer-
tification ensures that your site meets the service provider's requirements for 
appearance on handsets, stability, and quality requirements. JYpically, an outside 
testing agency performs this certification, and you must pay for the certification 
as part of the approval process with the service provider. 
Thus, the certification process provides a barrier to entry; you may choose 
not to meet a provider's certification requirements, especially if your primary tar-
get is another platform. As long as your content can display on ani-mode 
handset, your users can view your content by entering the URL in the browser. 
This choice-certification with better placement and the potential for down-
stream revenue versus immediate availability and the burden of income-is 
a difficult decision for many small content providers. Arguably, if you are com-
mitted to i-mode as a medium for your content, pursuing certification with your 
regional carriers is imperative. On the other hand, if your content is platform 
agnostic, you may choose to pursue i-mode certification only as part of a 
marketing directive. And, of course, you may choose to only ensure minimal 
compatibility or disregard i-mode compatibility as many content providers in the 
United States do today, simply because it is not yet available there. 
Creating Content for i-mode 
Because i-mode content is simply HTML, you already have the skills and tools to 
create content that displays on i-mode-enabled handsets. You should, however, 
be familiar with the dialect of HTML that i-mode currently supports. 
Using Tools for i-mode 
The single largest stumbling point you may encounter when beginning to 
develop content fori-mode is the paucity of tools available. Worse still, because 
i-mode was originally developed for the Japanese market, the majority of the 
tools you find are Japanese, making their use challenging unless you are one of 
the lucky few who can read the language fluently. 
i-mode Applications 
183 

ChapterlO 
184 
The good news is that there is a light at the end of the tunnel, and in the 
meantime you can use many of the tricks described in Chapter 3, "The Wrreless 
User Interface," such as shrinking your Web browser's window to ensure that your 
content is readable on a handset. Several vendors offer relatively inexpensive 
general-purpose emulators; you can find links to some of these in Appendix A, 
"Resources for Wrreless Web Developers." 
If you are lucky enough to be in a region with a wireless carrier deploying 
i-mode-such as Europe-you should make a point oflooking over the carrier's 
Web site for a development program that offers a wireless Software Development 
Kit (SDK) fori-mode development. Many of these SDKs include user interface 
guidelines, requirements for application certification, and PC-based emulators 
that let you test your content on a variety of simulated handsets. (Of course, 
emulation is no substitute for testing on the real hardware once you can get it!) 
Although viewing i-mode can be challenging until you find the proper tools, 
composing i-mode is easy: Simply choose your favorite text editor. Because 
i-mode is simply HTML, it is easy to craft by hand. You can even use a What-You-
See-Is-What-You-Get (WYSIWYG) editor, as long as you remember to test the 
output to ensure that it only contains tags supported by i-mode handsets. 
Writing HTML for i-mode 
The HTML i-mode handsets can display is surprisingly limited; perhaps equally 
surprising is the flexibility its limitation affords. Broadly speaking, i-mode hand-
sets support HTML for layout, links, images, and headings. As you might imagine 
given the constraints of a telephone handset, there is no support for tables or 
frames. Table 10-1 shows a list of the tags i-mode supports. 
Table 10-1. HTML Tags for Wireless Web Document Headings 
TAG 
A 
BASE 
BLINK 
BLOCKQUOTE 
BODY 
BR 
CENTER 
DD 
DIR 
PURPOSE 
Introduces a link 
Specifies the base URL for the document 
Requests blinking text 
Requests contained text be marked as a quotation 
Specifies a document's body 
Requests a line break 
Requests contained text be centered on the display 
Specifies a definition in a definition list 
Requests a directory list, similar to a definition list 
(continued) 

Table 10-1. HTML Tags for Wireless Web Document Headings (continued) 
TAG 
DIV 
DL 
DT 
FONT 
FORM 
HEAD 
H1 •• H6 
HR 
HTML 
IMG 
INPUT 
LI 
MARQUEE 
MENU 
META 
OBJECT 
OL 
OPTION 
p 
PLAINTEXT 
PRE 
SELECT 
TEXT AREA 
TITLE 
UL 
PURPOSE 
Requests text alignment via the ALIGN attribute 
Encloses a definition list 
Specifies a defined term in a definition list 
Requests a different font 
Indicates that contents are a form 
Specifies a document's header 
Specifies contained text is a heading 
Requests a horizontal rule 
Indicates all content is HTML; used to contain HEAD and BODY tags 
of document 
Specifies a link to an image 
Specifies a form input element 
Specifies an item in a list 
Specifies a single line of text that should scroll across the display 
Specifies a list of choices 
Specifies meta contents for the page 
Specifies ani-mode-handset object such as an iAppli application. 
Specifies an outline list 
Specifies an option in a choice list 
Specifies a paragraph 
Displays verbatim text as entered 
Requests preformatted (verbatim) text 
Contains an option list in a form 
Indicates a free-form text input in a form 
Indicates the title of a document 
Indicates an enumerated list 
i-mode Applications 
185 

Chapter 10 
186 
Using i-mode Heading Tags 
The general structure of ani-mode document is no different from that of any 
other HTML file. Its structure consists of the document's heading and body con-
tained within the <HTML> tag: 
<HTML> 
<HEAD> 
<TITLE>An i-mode Page</TITLE> 
<META HTIP-EQUIV="Content-Type" CONTENT="text/chtml"> 
</HEAD> 
<BODY> 
<1--Your text goes here--> 
</BODY> 
Do not to forget the <META> tag in the <HEAD> tag, or check to see that your 
server is properly configured to send an HTTP Content-type header that identi-
fies your content as cHTML (compact HTML). If you do not, it is quite likely that 
i-mode handsets will not recognize your content. 
Bear in mind, however, that the phone may not show the document's title as 
specified within the <TITLE> tag on the page itself; when in doubt, you should 
identify your content within the content using a section heading. 
Using i-mode Text Tags 
i-mode supports most of the HTML text formatting tags you are likely to need: 
section headings (the <Hl>-<H6>), list tags (<UL>, <DL>, and <OL>), quotations 
(<BLOCKQUOTE>), and verbatim text (<PRE> and <PLAINTEXT>). Notably absent, how-
ever, are the stylistic tags that indicate typographic conventions such as bold, 
italic, or underlined text. 
Although i-mode handsets do not support typographic HTML, those that 
support color let you specify a font's color using the <FONT> tag with the COLOR tag, 
like this: 
<FONT COLOR="RED">This is red</FONT> 
The value of COLOR can be one of"AQUA", "BLACK", "BLUE", "FUCHSIA", "GRAY", 
"GREEN", "LIME", "MAROON", "NAVY", "OLIVE", "PURPLE", "RED", "SILVER", "TEAL", 
"WHITE" or "YELLOW". 
For those who remember the ancient history of the Web, i-mode also sup-
ports the <BLINK> tag, which displays its content as blinking text. In lieu of more 

elegant (but unfortunately missing) choices such as bold or italic faces you can 
use it to attract attention to key parts of your content. However, if you do, you 
should do it sparingly. Although effective, blinking text can quickly become dis-
tracting to the reader. 
Another tag you can use to format your text is the <MARQUEE> text, which pre-
sents a line of text in marching marquee style across the display. The <MARQUEE> 
tag is an excellent choice for longer chunks of information that should stay on 
the same line, such as a stock ticker or train schedule times. 
Of course, i -mode handsets support hyper links. In addition to letting you 
navigate using the handset's user interface (typically a scroll wheel or four-way 
directional pad), you can also select links using the number keys. As a developer, 
you can connect a specific hyperlink to a number key using the ACCESSKEY attri-
bute of the <A> tag, like this page: 
<HTML> 
<HEAD> 
<META HTIP-EQUIV="Content-Type" CONTENT="text/chtml"> 
<TITLE>ACCESSKEY Demonstration</TITLE> 
</HEAD> 
<BODY> 
A demonstration of ACCESSKEY:<BR> 
<A HREF="http://www.lothlorien.com/i/index.html" accesskey="l" > 
Lothlorien Home Page 
<IA><BR> 
<A HREF="http://www.apress.com/i/index.html" accesskey="2"> 
Apress Home Page 
</A> 
</BODY> 
</HTML> 
Here, pressing the 1 key on the handset brings you to Lothlorien's home 
page, and pressing the 2 key on the handset brings you to Apress's home page. 
Including ACCESSKEY for common links will help your subscribers quickly find the 
content they want to see. 
Some newer handsets may also support the TEL attribute of the <A> tag, 
which links to a given telephone number. Using the TEL attribute, you might write 
the following: 
Call <A TEL="tel:+8885551212">information</A> 
to establish a hyperlink that dials the voice number 888-555-1212. 
i-mode Applications 
187 

Chapter 10 
188 
Using i-mode Form Tags 
i-mode's support for data entry is essentially the same as that provided by other 
versions of HTML. You can create text lists (<SELECT> and <OPTION>); input boxes 
(<INPUT>) that may contain text, radio buttons, check boxes, or submit or reset 
buttons; and free text entry (<TEXT AREA>) boxes. 
There are two key differences, however. First, like the <A> tag, the <INPUT> tag 
can take the ACCESSKEY attribute to map the input field item to a specific key. By 
doing so, you can simply touch the key associated with the field to begin entering 
information in that field. Second, the <INPUT> and <TEXT AREA> boxes also accept 
the I STYLE attribute, which controls the various mechanisms for Japanese text 
entry according to Table 10-2. 
Table 10-2. i-mode Input Styles 
STYLE 
1 
2 
3 
4 
KIND OF INPUT 
Full space kana characters 
Half space kana characters 
Roman alphanumeric characters 
Numeric characters 
Interestingly, password input formats default to numeric input, so be sure 
you either select the appropriate input style or limit passwords to numbers only. 
When developing forms fori-mode, bear in mind that the vast majority of 
i-mode handsets are just that: handsets. Although most wireless terminals that 
support HTML have at least limited alphanumeric entry via thumb keyboards or 
handwriting recognition, most i-mode handsets only have numeric keys. 
Consequently, entering more than a few letters becomes an excruciating process. 
Use text input only when necessary. 
Displaying Images and i-mode 
Using the <IMG> tag, you can include simple GIF images in your content. Because 
of the handset's limitations, you should be careful to follow these guidelines: 
• Images should be no more than 94-by-72 pixels. 
• Images should be one bit per pixel for monochrome handsets. 

• Images should not be animated, as some handsets do not support 
animation. 
• Images should be eight bits per pixel with the Web-safe palette for color 
handsets. 
Of course, common sense applies when using any images on the wireless 
Web; use them sparingly and keep them small. 
As an alternative to images, you can specify a number of on-device icons, 
which NTT DoCoMo calls emoji, within your HTML. You write these as HTML 
entities: for example, &#F8AO; results in a cloud. Currently, there are more than 
160 emoji, and NTT DoCoMo adds more with each release of the standard. 
Summary 
i-mode, developed by NTT DoCoMo in Japan, leverages a lightweight dialect of 
HTML to bring the wireless Web to handsets. In addition, i-mode also provides an 
end-to-end content solution that enables developers to create and certify con-
tent for today's wireless networks, including a means to charge for subscriber 
content. This certification mechanism provides access to both walled-garden 
content approved by the carrier as well as content outside the garden (which 
must be made freely available to subscribers). 
Because i-mode is based on HTML, you need little more than a simple text 
editor and Web browser to begin writing content fori-mode handsets. As you 
move forward, however, you should plan to work with regional carriers to vali-
date your content, especially if you intend to certify it for distribution within the 
walled garden. Doing so will ensure you have access to both a PC-resident 
i-mode emulator and i-mode handsets, which let you determine how your con-
tent will ultimately appear. 
There are few differences between HTML fori-mode and conventional 
i-mode. Notably, content fori-mode cannot contain tables or frames, must be 
smaller than 5 kilobytes, and should only point to GIF images (where images are 
necessary at all). i-mode includes handset-specific tags that let you link URLs to 
keys as well as hyperlink to telephone numbers, further integrating the wireless 
Web with the existing telephone network. 
i-mode Applications 
189 

CHAPTER 11 
Wireless Application 
Protocol 
THE WIRELEss APPUCATION PROTOCOL (WAP) is an emerging standard for marking up 
and presenting wireless content targeted explicitly at small mobile handheld 
devices such as cell phones, pagers, and wireless access terminals. At its heart is 
the eXtensible HyperText Markup Language Mobile Profile (XHTML-MP), a sub-
set of the XHTML standard tuned for wireless devices. 
NOTE 
Older WAP implementations only support the Wireless Markup 
Language (WML), which I will discuss in Chapter 12, 'Wireless Markup 
Language." 
In this chapter, I introduce the concepts behind WAP and show you the 
XHTML tags you can use to mark up your content. After you read this chapter, 
you will know how you can support today's WAP handsets using the content you 
have already developed for other wireless handhelds with only minimal changes. 
Introducing the WAP Standard 
The WAP standard, which includes WML, is maintained by the Wrreless 
Application Protocol Forum (WAP Forum), a multinational consortium of wire-
less infrastructure providers that includes Nokia, Motorola, Palm, Microsoft, 
Sony, and Symbian. First proposed in the late nineties, it is now in its second full 
iteration at version 2.0. 
At the lowest level, the WAP protocol stack uses a bearer network such as 
Cellular Digital Packet Data (CDPD) or General Packet Radio Service (GPRS) to 
carry data. Like Transmission Control Protocol/Internet Protocol (TCP/IP), the 
higher-level protocols are bearer-independent, enablingWAP to operate on 
a variety of wireless networks. The bearer network carries data in packets called 
datagrams, using a protocol such as TCP liP's Unreliable Datagram Protocol 
191 

Chapter 11 
192 
(UDP) or a network-native protocol. WAP uses the Wrreless Datagram Protocol 
(WDP) to abstract the bearer network's characteristics, such as TCP liP's UDP. 
Above the datagram layer are the Wrreless 'Ii'ansport Layer Security (WI'LS) 
and Wrreless 'Ii'ansaction Protocol (WI'P), which provide the facilities necessary 
for secure transactions between hosts. WI'LS is based on the 'Ii'ansport Layer 
Security (TLS)-formerly the Secure Sockets Layer (SSL)-in that it provides 
a means for hosts to negotiate a secure protocol for the exchange of data. WI'LS 
provides assurances for data integrity, privacy, and authentication, in con-
junction with the WI'P, which is responsible for establishing a reliable, two-way 
transaction service. 
Protocols such as the Wrreless Session Protocol (WSP), which provides a con-
sistent interface for session-oriented services, use the WI'P. The WSP provides 
both a connection-oriented service and a connectionless service based on WDP 
with or without security options. In turn, applications including the XHTML-MP 
and WML browsers use WSP as the bearer of data from servers to the handheld. 
The deployment view forWAP services strongly resembles that of existing 
HyperText Markup Language (HTML) services, as shown in Figure 11-1. Both 
dedicated WAP servers and existing Web servers can serve WAP content in WML. 
WML content served by HyperText 'Ii'ansfer Protocol (HTTP) servers on the 
Internet is translated into a tightly compressed binary format suitable for wire-
less transmission and gated to wireless networks that implement the WAP 
protocols using a WAP gateway. 'IYI>ically, wireless service providers make WAP 
gateways available to their subscribers transparently, so subscribers can access 
WML content served on the Internet. This gives them access to both dedicated 
WAP servers and traditional Web servers offeringWAP content. Subscribers need 
not even know whether a particular server they access is a dedicated WAP server 
or a Web server offeringWAP content. 

Wireless Application Protocol 
WAP Client 
Wireless Network 
Internet 
n 
Figure 11-1. The deployment view for WAP services 
The XHTML-MP is identical in concept and similar to other HTML wireless 
applications discussed, including compact HTML (cHTML), discussed in 
Chapter 10, "i-mode Applications." Using XHTML, wireless handsets equipped 
with WAP can view HTML pages that comply to the XHTML-MP standard, a sub-
set of the XHTML tags used by all Web sites. 
WAP-and specificallyWML-received a great deal of press when vendors 
first launched it during the late 1990s. Unfortunately, especially in the United 
States, it did not live up to its initial market promise. Many early adopters 
expected wired Internet features, and speed on existing handsets and second-
generation networks ran at slow speeds. Worse still, many wireless carriers and 
content developers did not immediately recognize the scope of the differences 
between WAP-based networks and the Web, resulting in content that was ill-
suited to mobile users and their devices. Consequently, many critics have 
declared that WAP is dead, or at least severely hemorrhaging. 
These declarations are clearly premature. Carriers continue to offer and sup-
port a growing number ofWAP applications usingWML for existing handsets, 
and a host of enterprise WML applications that interface with corporate intranets 
imply that WML is here to stay. The inclusion of XHTML-MP ensures an 
expansion path for the future ofWAP. Because the XHTML-MP includes those 
tags most commonly used by mobile Web sites (including sites written fori-mode 
handsets, Palm Powered devices, and other handhelds), WAP-enabled handsets 
can view HTML sites developed for super phones and PDAs. Moreover, because 
193 

Chapter 11 
194 
the WAP architecture isolates the interpretation (performed on the WAP gateway) 
from the presentation (performed on the terminal), carriers can perform many 
extensions to WAP without changing handsets already in consumers' hands. 
An important feature ofXHTML-MP not supported by many other wireless 
browsers is style sheets, which let you specify a specific appearance for all your 
content through the use of a single style sheet. Although not as sophisticated as 
desktop style sheets, they let you perform many of the same operations, simplify-
ing your content development. 
Using Tools for XHTML Mobile Profile 
As I write this, there are few tools available for XHTML-MP development. 
Open wave has made available prerelease versions of their WAP Software 
Development Kit (SDK) for MicrosoftWmdows, which promises to speed content 
development and testing. In the meantime, you will need to resort to more primi-
tive tools, such as a text editor. 
Although any text editor will do to edit XHTML, it is easier to use an XML-
aware text editor. There are many on the market and several good free ones, 
including emacs (my personal favorite) and jEdit. Although these editors do not 
provide explicit guidance about XHTML-MP (for example, whether a specific tag 
is included in the profile), they do provide simple syntax checking and color syn-
tax highlighting, reducing the chance that you will make a mistake. 
Of course, testing your XHTML-MP content is a little challenging until SDKs 
become available. For now, it is best to test using a browser that can display and 
help you debug XML, such as Microsoft Internet Explorer. As with testing cHTML, 
you can resize the window to simulate the small screen size of today's wireless 
terminals. 
Understanding XHTML Mobile Profile 
As part of the definition ofXHTML, the W3C created profiles. A profile is simply 
a set of related tags appropriate for specific applications on some kinds of 
browsers. (Some vendors also refer to a profile as a module.) When implementing 
a browser, developers must choose whether to support an entire profile, making 
it easier for you to determine exactly what tags of content you can use on a given 
browser. Because XHTML is based on XML, the syntax is identical to the syntax 
described in Chapter 7, "eXtensible Markup Language"; only the tags themselves 
are different. In most cases, of course, the tags are identical to the HTML tags you 
already know. 
One of the first profiles to be of interest to wireless Web developers was 
XHTML Basic Profile (XHTML-BP). Although browser vendors and device 

Wireless Application Protocol 
manufacturers have not widely used XHTML-BP as the foundation for discussing 
their browser features, XHTML-BP is a formalization of the tags defined in HTML 
2.0 and 3.2 that are appropriate for all browsers, including those for constrained 
devices. To this the W3C has added a number of other profiles, including profiles 
that codify the tags used for defining HTML frames, form elements, and style 
sheets. 
XHTML-MP is a strict superset of the XHTML-BP,-along with specific tags 
included from other profiles. Let's take a closer look. 
XHTML Basic 
XHTML-BP is similar to the wireless HTML subset recommended in Chapter 8, 
"HyperText Markup Language, the Wireless Way." Table 11-1 shows the tags you 
can use in XHTML-BP. 
Table 11-1. XHTML-BP Tags for Wireless Web Document Headings 
TAG 
<A> 
<ABBR> 
<ACRONYM> 
<ADDRESS> 
<BASE> 
<BLOCKQUOTE> 
<BODY> 
<BRI> 
<CAPTION> 
<CODE> 
<DD> 
<DIV> 
<DL> 
<DT> 
<FORM> 
<HEAD> 
PURPOSE 
Introduces a link 
Specifies an abbreviation 
Specifies the spelling of an acronym 
Specifies a postal address or other contact information 
Specifies the base URL for the document 
Requests contained text be marked as a quotation 
Specifies a document's body 
Requests a line break 
Specifies a text caption for a table 
Specifies text that should be rendered sans serif with no 
other formatting 
Specifies a definition in a definition list 
Requests text alignment via the ALIGN attribute 
Encloses a definition list 
Specifies a defined term in a definition list 
Indicates that contents are a form 
Specifies a document's header 
(continued) 
195 

Chapter 11 
196 
Table 11-1. XHTML-BP Tags for Wireless Web Document Headings (continued) 
TAG 
<H1>-<H6> 
<HTML> 
<IMGI> 
<INPUT/> 
<LI> 
<LINK/> 
<MENU> 
<META/> 
<OBJECT/> 
<OL> 
<OPTION> 
<P> 
<PARAM/> 
<PRE> 
<Q> 
<SAMP> 
<SELECT> 
<SPAN> 
<STRONG> 
<TABLE> 
<TD> 
<TH> 
<TR> 
<TEXT AREA> 
<TITLE> 
<UL> 
PURPOSE 
Specifies contained text is a heading 
Indicates all content is HTML; used to contain <HEAD> and 
<BODY> tags of document 
Specifies a link to an image 
Specifies a form input element 
Specifies an item in a list 
Specifies a contextual link between two documents 
Specifies a list of choices 
Specifies META contents for the page 
Specifies a specific object, such as a script or other 
downloadable item 
Specifies an outline list 
Specifies an option in a choice list 
Specifies a paragraph 
Specifies a parameter for an object 
Requests preformatted (verbatim) text 
Requests typesetting for a short quotation 
Requests text illustrating the sample output from a script, 
often similar to <CODE> 
Contains an option list in a form 
Specifies the span of a region using a style sheet 
Specifies text to be rendered in an emphasized form 
Specifies a table 
Denotes a table cell 
Specifies the heading of a table 
Specifies a row in a table 
Indicates a free-form text input in a form 
Indicates the title of a document 
Indicates an enumerated list 

Wireless Application Protocol 
A few tags, including <ADDRESS> tags, are not supported by older mobile 
HTML browsers, so you may not have encountered them unless you are familiar 
with hand-coding HTML. These tags are contextual tags that typeset their con-
tents much in the way you would imagine. For example, the <ADDRESS> tag lets 
you specify an address, and the <ACRONYM> tag lets you define an acronym, both in 
a device-independent manner, so each client can typeset the results as they see 
fit. Other tags, notably the <OBJECT> and <PARAM> tags, are defined to let you 
include specific non-markup objects, but in general, these tag are not yet imple-
mented on most handsets. 
As you might imagine, an XHTML-BP document looks very much like any 
other HTML document: 
<?xml version="l.O"?> 
<I DOCTYPE html PUBLIC "-//W3C/ /DTD XHTML Basic 1. 0//EN" 
"http://www.w3c.org/TR/xhtml-basic/xhtml-basic10.dtd"> 
<HTML> 
<HEAD> 
<TITLE>An XHTML-BP Page</TITLE> 
</HEAD> 
<BODY> 
<P>Hello worldi</P> 
</BODY> 
</HTML> 
Compared to the mobile HTML flavors you have seen in previous chapters, 
XHTML-BP documents have two key distinctions: their document type and their 
use of formal XHTML syntax. 
For a document to be considered valid XHTML-BP, it must be an XML docu-
ment, as the <?xml>tag on the first line indicates. Moreover, it must contain 
a<! DOCTYPE> tag pointing to the Document Type Definition (DTD) for XHTML-
BP, as the second and third lines of this file do. 
Second, documents must rigidly conform to XHTML syntax rules. Be espe-
cially careful to close all tags using either the matching <TAG> • • • </TAG> form 
or the <TAG/> form and that your capitalization of tags is consistent throughout 
the document. 
Of course, for WAP, your content should be XHTML-MP, not XHTML-BP. That 
is easy to change; just change the content declaration on the second and third 
line. Thus, the preceding example would look like this: 
<?xml version="l.O"?> 
<I DOCTYPE html PUBLIC "-1/WAPFORUM//DTD XHTML Mobile 1. 0//EN" 
"http://www.wapforum.org/DTD/xhtml-mobilelO.dtd"> 
<HTML> 
197 

Chapter 11 
198 
<HEAD> 
<TITLE>An XHTML-BP Page</TITLE> 
</HEAD> 
<BODY> 
<P>Hello worldi</P> 
</BODY> 
<HTML> 
Here, the< I DOCTYPE> tag includes a different URL, one that points to the 
WML Forum's definition of the XHTML-MP DTD. 
XHTML Forms 
XHTML-MP extends XHTML-BP's support for forms by including the <FIELDSET> 
and <OPTGROUP> group tags, which let you specify groups of text fields or groups of 
option selections, respectively. 
The <FIELDSET> tag tells the browser that a group oftext input fields on 
a form should be presented together. Some browsers draw a box around the text 
input fields, and others attempt to keep the fields on the same page. 
Similarly, the <OPTGROUP> tag tells the browser that a group of selection 
options on a form are related. The <OPTGROUP> tag gives you a way to create hier-
archical menus in an input form; if you set the NAME attribute of <OPTGROUP>, the 
list of options will have a name as well. 
XHTML Presentation 
XHTML-MP includes a handful of tags from the XHTML Presentation Profile 
(XHTML-PP) that let you set text in different typefaces and styles (see Table 11-2). 
Table 11-2. XHTML Tags for Wireless Web Document Presentation 
TAG 
<B> 
<BIG> 
<HR> 
<I> 
<SMALL> 
PURPOSE 
Sets text in bold if available 
Sets text in larger font than usual if available 
Draws a horizontal rule 
Sets text in italic font if available 
Sets text in smaller font than usual if available 

Wireless Application Protocol 
Styles 
The most important addition to XHTML-BP in XHTML-MP is support for style 
sheets that let you define and name text styles for your content. Like Cascading 
Style Sheets for HTML and XHTML, XHTML-MP supports assigning styles to spe-
cific tags. 
You can associate styles with your document in three ways: 
• By using the <LINK/> tag to obtain style directives from an external 
document 
• By using the <STYLE> tag to assign style directives in a document's heading 
• By using the STYLE attribute of most tags to assign a style tag, overriding 
any preset default 
Most of the time, you will want to use the first method, using the< LINK> tag 
to attach an external style sheet to an entire page. When you do so, you can create 
styles for all of the tags you want to style and then share that style sheet across 
multiple pages. For example, you might define a style sheet phone_ styles. css 
that assigned the color red to all <Hl> tags like this: 
Hl { color: red } 
With the following HTML header, you can include this style sheet in every 
XHTML-MP page on your site using the <LINK> tag (which is bold in this 
example): 
<?xml version="l.O"?> 
<! DOCTYPE html PUBLIC "-I /WAPFORUM/ /DTD XHTML Mobile 1.0/ /EN" 
"http://www.wapforum.org/DTD/xhtml-mobilelO.dtd"> 
<HEAD> 
<TITLE>Simple CSS Example</TITLE> 
<LINK HREF="phone_style.css" REL="stylesheet" TYPE="text/css"/> 
</HEAD> 
<BODY> 
<Hl>Greetings</Hl> 
<P>Hello world!</P> 
</BODY> 
<IHTML> 
199 

Chapter 11 
200 
Using the <LINK/> tag is almost always what you want to do with your site: 
Create a style sheet that defines a uniform appearance for all tags on your 
site. Occasionally, though, you might want to define a specific style for a tag on 
one page, such as when testing how a style might appear or overriding a style 
defined previously in a style sheet. To do this, you use the <STYLE> tag, which lets 
you define an inline style within your document's heading. For example, you 
could write the previous two examples like this: 
<?xml version="l.O"?> 
<! DOCTYPE html PUBLIC "-I /WAPFORUM//DTD XHTML Mobile 1. 0//EN" 
"http://www.wapforum.org/DTD/xhtml-mobile10.dtd"> 
<HEAD> 
<STYLE type="textlcss"> 
H1 { color: red } 
</STYLE> 
<TITLE>Simple CSS Example</TITLE> 
</HEAD> 
<BODY> 
<H1>Greetings</H1> 
<P>Hello world!</P> 
</BODY> 
<IHTML> 
Finally, you can assign a style to a tag's STYLE attribute, like this: 
<?xml version="l.O"?> 
<! DOCTYPE html PUBLIC "-1/WAPFORUM//DTD XHTML Mobile 1. 0//EN" 
"http://www.wapforum.org/DTD/xhtml-mobile10.dtd"> 
<HEAD> 
<TITLE>Simple CSS Example</TITLE> 
</HEAD> 
<BODY> 
<H1 STYLE="color:red">Greetings</H1> 
<P>Hello world!</P> 
</BODY> 
<IHTML> 
If you are considering using the STYLE attribute for styles, think no more. Just 
do not do it; it makes managing your XHTML that much more difficult as you add 
new content or need to change how your pages look. Even if you are just overrid-
ing a single tag or two, it quickly gets out of hand and becomes a hassle to 
manage. 

Wireless Application Protocol 
So, what can you actually do with a style? A lot, actually. Table ll-3lists 
the properties that XHTML-MP supports that you are likely to use; consult the 
XHTML-MP reference at the WAP Forum for a comprehensive list of all properties. 
Table 11-3. Common XHTML-MP Style Properties 
PROPERTY 
background-color 
background-image 
color 
font 
text-align 
text-decoration 
text-indent 
vertical-align 
VALUE 
normal, italic, bold, 
larger, smaller, 
x-small,small,medium, 
large,x-large 
right, left, center 
none, underline, blink 
baseline, sub, super, 
top, text-top, 
middle, bottom 
PURPOSE 
Sets background color of contents 
Sets background image of contents 
Sets foreground color of contents 
Sets font properties 
Sets text horizontal alignment 
Sets contents to underline or blink 
Sets text indentation in units 
Sets vertical alignment oftext 
You can set properties for a tag, as in the previous examples, or for a class of 
tags to which you assign a name. For example, this is a style sheet that defines the 
class brightRed for <P> tags: 
P.brightRed { color: red, font: bold } 
Later, you can use this class to define paragraphs that should be set using the 
brightRed style: 
<?xml version="1.0"h 
<! DOCTYPE html PUBLIC "-1/WAPFORUM//DTD XHTML Mobile 1. 0/ /EN" 
"http://www.wapforum.org/DTD/xhtml-mobile10.dtd"> 
<HEAD> 
<STYLE type="text/css"> 
P.brightRed { color: red, font: bold } 
</STYLE> 
<TITLE>Simple CSS Example</TITLE> 
</HEAD> 
201 

Chapter 11 
202 
<BODY> 
<H1>Greetings</H1> 
<P.brightRed>Hello worldl</P> 
</BODY> 
</HTML> 
Despite the flexibility of style sheets in XHTML-MP, there is a significant dis-
advantage: XHTML-MP is not available everywhere. Although you can count on 
support for XHTML-MP on most screen phones, you cannot say the same about 
other wireless terminals, including many super phones and just about all Palm 
Powered devices. Consequently, you will need to ensure that your content dis-
plays properly on these devices without a style sheet (perhaps by using separate 
forms of content or server-side tricks such as those in Chapter 5, "Server-Side 
Content Management"), or forego subscribers using these devices to view your 
content. 
Summary 
Today's WAP clients support two markup languages. One, WML, is primarily 
reserved for the legacy support of original WAP applications. Moving forward, 
you use XHTML-MP to write applications forWAP browsers, including those on 
most mobile phones. 
XHTML-MP is one of many profiles ofXHTML that defines a specific set of 
tags that all browsers adhering to the standard must support. XHTML-MP 
includes the HTML tags most suited to wireless browsers, which you already 
know from learning both through general experience and from developing spe-
cific applications for Palm Powered devices and i-mode phones. 
In addition to these tags, XHTML supports style sheets, which let you assign 
specific typography to one or more tags. Using the <LINK> tag, you can link many 
documents to a single style sheet, or you can define styles for a single document 
inside the document using the <STYLE> tag. 
Writing your WAP content using XHTML-MP is a good idea, especially if you 
are targeting your content solely for WAP handsets. If you are looking to field one 
site for multiple kinds of browsers, however, you should take care to use only 
those tags supported by all browsers. This is especially important when you con-
sider using XHTML-MP's support for style sheets because many wireless 
browsers do not yet support style sheets. 

CHAPTER 12 
Wireless Markup 
Language 
THE WIRELESS MARKuP LANGuAGE (WML) is a segment of the Wrreless Application 
Protocol (WAP) designed to meet the needs of resource-limited devices such as 
consumer screen phones and pagers. 
In this chapter, I show you how to use WML to make your content available 
to the Internet phones deployed today. You learn how to create and mark up con-
tent using WML. 
In Chapter 13, "Dynamic Content with WMLScript," you see how to extend 
WMCs power with WMLScript, the lightweight scripting environment that is 
a part of the WAP standard. If you are already familiar with the basics ofWML, 
you may want to skip straight to Chapter 13 to learn how scripting can enhance 
your wireless content. 
Why Use WML? 
Although there are many similarities between the World Wide Web's architecture 
and the WAP architecture, there are also several important differences. In many 
ways, WAP has taken the best features of the infrastructure for the World Wide 
Web and enhanced their operation for mobile devices. Therefore, WAP has many 
advantages for the wireless content developer. 
With the advent of Mobile XHTML for WAP (see Chapter 11, "Wrreless 
Application Protocol"), the question becomes a little more difficult. WML is best 
suited for supporting legacy devices, as well as writing wireless applications that 
require client -side scripting or custom user interfaces, because you can combine 
WML with WMLScript to override the look and feel of controls and perform sim-
ple scripting. On the other hand, if you already have a wireless HTML site, it is 
easy to ensure you have support for XHTML, giving newer WAP users the ability 
to access your site. 
203 

Chapter 12 
204 
WML Is Efficient 
WML is more efficient than traditional Web-based markup languages. Explicitly 
designed for wireless use, WAP enables clients and servers to exchange the most 
data using the least amount of bandwidth. 
Content marked up using WML generally occupies fewer bytes than content 
marked up in HTML. Not only is WML content more compact because of the 
encoding performed prior to exchange with the client, but WML markup gener-
ally results in pages that are more compact. WML's markup fosters concise 
writing because its constructs remind authors of the simplicity of the viewing 
device. In addition, the tags defined in WML provide efficiencies not available in 
HTML. Similarly, the WAP protocols that carry data from the physical layer to the 
WML layer, including the Wrreless Transport Protocol (WfP) and Wrreless 
Session Protocol (WSP), are more efficient than Transport Control 
Protocol/Internet Protocol (TCP /IP) or Hypertext Transport Protocol (HTTP). 
WML Provides for Constrained Clients 
WML was designed from the outset for clients with minimal computing capabili-
ties. Unlike HTML, which has been adapted with varying degrees of success to 
operate on low-capability devices, WAP has been optimized to provide the great-
est flexibility with minimal resources. 
WAP's use of gateway servers at points throughout the wireless network 
allows much of the processing required by Web browsers to be performed by 
servers, rather than by individual clients. Although these gateway servers are an 
additional link in the chain between origin server and client that require com put-
ing resources, maintenance, stability, and robust operation, their health is 
generally assured by the companies that operate them. 
Of course, to make the most of this feature, it is important to be sure your 
content is well-formed-that there are no errors in your WAP content as defined 
by the specification that will cause problems for either the gateway or handheld 
clients. 
WML Is Predictable 
The WAP Forum tightly controls both the WAP standard and deployment ofWAP-
compatible devices. If a browser is compatible with a specific version ofWAP, you 
know it will work with content authored to the specification. This is in sharp con-
trast to the wireless Hypertext Markup Language (HTML) browsers available, 
where the multitude of browser vendors and compromises has yielded an envi-
ronment where it is not clear which tags will be available on a specific device. 

Wireless Markup Language 
WML Provides Dynamic Behavior 
Unlike HTML, responses to behaviors can be coded in WML. WML provides 
a simple event mechanism that allows different content to be displayed. User 
actions, such as the user pressing a key, can be tied to scripts that cause changes 
in content, and the WML browser provides timers that can load a different page 
or trigger the change of variables when the indicated time elapses. These provide 
greater flexibility than the static content that HTML can deliver. 
Designing WML User Interfaces 
Content written using WML for WAP browsers is often referred to as a WAP appli-
cation. This expression is partially marketing hyperbole but partially factual; 
content targeted for a WAP browser is, arguably, an application ofWAP technol-
ogy-hence, a WAP application. 
Pedantic vocabulary arguments aside, designingWML content is similar in 
concept to designing Web content, with few notable differences. The standards 
advanced by the WAP Forum for WML are exceptionally general. They dictate 
intentions, not implementations. Thus, a WML specification indicates that 
a device needs to handle particular operations, but the specifics of how these 
operations behave are left up to device vendors. 
For example, the WML specification requires several unassigned interface 
elements, which application developers can assign to particular tasks. It does not 
specify how these elements should appear or behave; many manufacturers have 
chosen to provide them in the form of soft keys located just below the Liquid 
Crystal Display (LCD) screen so that the LCD can show content -assigned titles 
above each key. However, it would be equally appropriate to offer these as physi-
cal keys along the side of a unit, as voice commands, or as any other imaginable 
interface that meets the intention of the WML specifications. 
Cards and Decks 
The fundamental principle behind the organization ofWML documents is the 
metaphor of cards and decks. A card is a grouping of one or more user interface 
elements, such as text, lists from which the user can select an item, or lines for 
user input. A card usually represents a single screen on a WAP terminal, although 
there is no guarantee that a given card as constructed will fit on a given terminal's 
display. A deck is a single file containingWML content, consisting of one or 
more cards. 
The user navigates to a card, reviews its contents, and enters requested infor-
mation and/ or makes choices, then moves on to another card. The instructions 
205 

Chapter 12 
206 
embedded within a card may invoke services on an origin server as needed. 
The user's device obtains decks from origin servers on the Internet as they 
are needed. 
The card/ deck metaphor is a constant reminder of one of the significant dif-
ferences between WML and HTML: the constraints of the target device. HTML 
developers typically think in terms of pages, or at least screens, consisting of 
color content several hundred pixels on a side. WML application developers have 
no such luxury; many devices offeringWML browsers have monochrome screens 
only a hundred or so pixels on a side. Memory is similarly constrained, and the 
bandwidth available for communication between device and network is scant. 
Organizing content into the small parcels of information contained in cards 
reminds developers of the limited viewing capabilities at the reader's disposal. 
Emerging Paradigms 
Specific paradigms are becoming prevalent for wireless screen phones. Most 
have similar constraints as well as similar user interfaces, which generally 
include the following: 
• A numeric keypad 
• Text input via shifting or multiple key presses 
• Several special-function keys, such as SEND, CLEAR, ACCEPT, and so on 
• A directional cursor control using a rocker keypad 
• Soft keys that can be customized byWAP content 
As these devices become more and more prevalent, users and manufacturers 
are creating a de facto interface standard for them. For example, almost all of 
these devices have special-function soft keys assigned to the WML operations 
ACCEPT and OPTIONS; developers should follow the convention of assigning 
the most frequently performed tasks to the ACCEPT function key and reserve the 
OPTIONS function key for less common uses, such as clearing a form. 
User Input 
Data entry on wireless devices is tedious and error-prone. Most do not have a full 
keyboard, so several actions are required to select a single character. Your WML 
content should therefore avoid the need for data input wherever possible. Any 

Wireless Markup Language 
time you expect the user to enter a specific data type, take advantage ofWMI:s 
ability to validate input on the device (see the "Interaction" section later in this 
chapter) to catch mistakes before they are sent to your content servers. Content 
providers are adopting several appearance standards for different kinds of input; 
for example, e-mail addresses and keywords are entered using only lowercase. 
Descriptions, names, addresses, and free-form text are entered using mixed case. 
Option lists, which allow the viewer to select an item from a list and view 
additional material, are a good alternative to free-form paragraphs. However, you 
need to carefully construct these lists. A long list will require excessive scrolling 
and likely will confuse most viewers. Studies have shown that most people can 
manage between five to nine items in their short-term memory. A good compro-
mise is to keep option lists to the size of an average display, and be sure that none 
are more than nine items long. 
Content for WAP browsers should be brief, clear, and succinct. Devices using 
WAP are not suited to lengthy reading sessions. Most users will be in an environ-
ment where viewing more than a few lines of text is difficult or impossible, as 
they will be occupied with other matters. They would find scrolling long cards of 
text, manipulating many cards, and interacting at length with complex decks to 
be a hindrance to their activities. Some vendors advise breaking long content in 
to multiple cards to simplify scrolling, but the best solution is to avoid lengthy 
text from the beginning. 
Images 
Images on handheld devices present several problems. Client devices are suited 
to display only the simplest of images, such as low-resolution icons. Moreover, 
images are only available in WAP applications as separate Uniform Resource 
Locators (URLs), making a new network request necessary each time an image is 
displayed. Because such network requests can drastically increase the amount of 
time it takes a card to display, images should be used sparingly, if at all, and only 
in situations where they take less space than a text alternative would. For exam-
ple, an icon indicating weather conditions would be appropriate, but an icon 
denoting the direction of a stock has no advantages over a simple character, such 
as+ or-. 
Never use an image to give information that is not available from its text 
attribute or from the surrounding text because some devices may not display 
images at all. Remember also that if you want to be sure an image will appear 
correctly on all platforms, you need to be sure it is no larger than the smallest tar-
get device's display. 
207 

Chapter 12 
208 
Creating Your First WAP Application 
WAP is a markup language based on eXtensible Markup Language (XML). 
Although understanding XML can help you write well-formed WML, there is no 
need to study XML just to work with WML. (The curious reader can skip back to 
Chapter 7, "eXtensible Markup Language," before continuing with this chapter 
for a review ofXML.) 
No book about any computer technology would be complete without a good 
complement of "Hello World" examples. Here is yet another one, with its output 
in Figure 12-1: 
c?xml version="1.0"?> 
c!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" 
"http://"~MW.wapforum.org/DTD/wml_1.1.xml"> 
cwml> 
ccard title="Hello world"> 
<p> 
Hello world! 
c/p> 
<Icard> 
c/wml> 
r ~ ----. 
Hello world! 
'I, 
1-
r Back 
Figure 12-1. The "Hello World" program 
-· 
The first two lines simply indicate this document is an XML document and 
that the deck uses XML meeting the grammar specification for WML 1.1. 
The WML is contained between the <wml> and < /wml> tags. This WML docu-
ment consists of a single card, or aggregation of interface items. Within this card 
is a single paragraph, consisting of the text Hello world! for the browser to display. 
Along the bottom of the screen are the labels for the phone's two soft keys. 
A WML browser must support at least two such soft keys, which are flexible inter-
face elements, named ACCEPT and OPTIONS. Because this WML document does 
not specifically reassign these keys, the WML browser assigns default actions in 

Wireless Markup Language 
Figure 12-1. In this example, the left one is presently labeled OK, and the right 
key is unlabeled. {Currently, the default action for the left key-the ACCEPT 
key-is to perform the same action as the PREV key, bringing the viewer to the 
previously viewed page.) 
Viewing WML Content 
Although you will generally mark up WML content by hand, viewing it requires 
a WAP browser. You have several options for doing this: 
• A WML browser in a simulator or another environment as provided by 
Openwave, Nokia, or other vendors 
• A native-device browser provided by a software developer for testing, using 
a network connection on a Personal Digital Assistant {PDA) or similar 
device 
• An actual screen phone, such as a consumer would use 
Of course, you should always test your content on a production device of 
some sort; if you plan to develop any WML content at all, a WAP-compliant 
screen phone is one of the most important investments you can make. While 
developing content, the best way to work is to use one of the simulators available 
through the developer programs offered by WAP Forum members such as 
Openwave and Nokia, then perform final testing with a real screen phone. These 
simulators provide a WAP-compliant browser running on a desktop computer, 
allowing you to use your desktop environment to simulate a WAP terminal. 
Figure 12-2 shows Openwave's simulator in action; it allows you to preview con-
tent and interact with the phone's buttons. 
Many oftoday's handheld computers include a WAP-compatible browser, or 
you can buy one for a nominal fee. Perhaps the most popular is Handspring's 
Blazer, which comes bundled with the Handspring Thea and is available for other 
Palm Powered devices. 
209 

Chapter 12 
210 
... 
••• 
OPENWAVE 
Figure 12-2. The Open wave 'WML browser 
NOTE 
For the intrepid, several vendors have released WAP browsers for 
PDA devices in one form or another. My personal favorite is the 
SmartPhone Emulator Developer Edition from Yospace, available at 
www.yospace.com/. 
Learning WML Syntax 
WML documents follow the same rules as XML for organization and syntax. If 
you have written HTML by hand, the rules are similar enough that you will pick 
the syntax up almost instantly. 

Wireless Markup Language 
Basic Syntax 
WML documents consist of character data interspersed with tags, which are 
enclosed by< and > characters. These tags define the structure of a document. On 
the next few pages you will encounter the following tags: <wrnl>, <card>, <p> (para-
graph), and <b> (bold). 
Unlike HTML tags, WML tags are case-sensitive; thus, a browser interprets 
<wrnl> and <WML> as two different tags. Uke HTML tags, WML tags actually have 
two parts-an opening tag and a closing tag-that enclose the affected infor-
mation between them. For example, the beginning of a WML document is 
marked with <wrnl>, and the ending is marked with the tag </wrnl>. These opening 
and closing tags contain the entire contents of the deck. 
Some tags are empty; that is, they do not contain data. These tags do not 
require closing tags. Although HTML makes no distinction between tags and 
empty tags such as <br>, WML does. Empty tags in WML are written using 
<and 1>. For example, the line break tag is written as <brl>. 
Attributes 
Tags may contain attributes, which describe their characteristics. Attributes are 
simply written as name/value pairs separated by an equals sign(=); the attribute 
is placed after the tag name but before the closing of the tag. For example, the 
paragraph tag accepts the mode attribute to indicate how to wrap text. This causes 
the text in a paragraph to be kept on one line and displayed marquee-style: 
<p mode="nowrap"> 
WML supports comments, just as XML does. Within a WML document, the 
< 1-- and --> characters delimit a comment. Comments contain information 
intended for content authors; they do not affect the browser's behavior and are 
not displayed by clients. 
Variables 
WML allows content developers to declare variables within a WML deck. 
A browser will substitute a variable's name for its value in WML. Variable names 
can follow any of these syntax options: 
$variable 
$(variable) 
$(variable:conversion) 
211 

Chapter 12 
212 
WML interprets any text after the $ as part of the variable's name, unless the 
entire variable name is in parentheses. (There are times where you will want 
a variable to snuggle up close to the next word, for example, when you are con-
structing a URL from several variables, like this: http: II ($host name) I index. wml.) 
Variables are always evaluated before other markup is performed. Variables can 
be set either by user elements usingWML form elements or by the <setvar> tag. 
The scope of a variable is generally global across the browser; there are no ways 
to hide variables. 
Events and Tasks 
WML defines several events triggered when the browser changes state, such as 
when it loads a new deck. WML decks can use these events to trigger actions called 
tasks. WML uses the <onevent> tag for this purpose, as well as some of the attri-
butes of some specific tags that define items that can generate events. WML has 
defined tags to create tasks that tell the browser to refresh a page, jump to a specific 
URL, jump to the previous URL stored in the browser's history, and so on. 
Reserved Characters 
WML reserves the <, >, ', ", &, and $ characters; to use one of these in any text 
contained in a WML deck, you will need to use the corresponding character tag 
shown in Table 12-1. 
Table 12-1. Reserved WML Characters and Their Corresponding Character Entities 
CHARACTER 
< 
> 
& 
$ 
TAG 
&lt; 
&gt; 
&apos; 
&quot; 
&amp; 
$$ 
PURPOSE 
Less than symbol 
Greater than symbol 
Apostrophe 
Quotation marks 
Ampersand 
Dollar sign 

Wireless Markup Language 
Marking Up Documents with WML 
Like HTML, WML provides contextual tags for marking up content. When you use 
these tags to organize your content, the WAP browser can then select the opti-
mum formatting that captures your document's organization. 
WML tags can be organized into four broad categories: 
• Organizational tags and their attributes organize a page into cards and 
decks. 
• Navigation tags and their attributes specify how navigation occurs 
between cards. 
• Interaction tags and their attributes specify the interactive components of 
a card, such as events, selection lines, and input forms. 
• Format tags specify how the content on a card will appear. 
Document Organization 
A WML deck consists of an XML prologue, a heading, and one or more cards, all 
contained by the <wrnl> tag. I discuss each of these items in more detail in the fol-
lowing sections. The deck is contained within a single WML document and 
written as character data-generally, in conventional American Standard Code 
for Information Interchange (ASCII), although, because WML is an XML deriva-
tive, any proper subset of the Unicode character set will suffice. Most developers 
will not need to use any encoding except English, however, unless they are devel-
oping content for languages other than English. 
By convention, WML files are named with the suffix • wml, and bear the MIME 
type text/vnd. wap. wml. Gateways and browsers use a file's suffix and MIME type 
to determine how its content should be handled. 
The Document Prologue 
Because WML is expressed in XML, all WML documents must begin with an XML 
prologue. The XML prologue for a WML deck indicates the version ofXML syntax 
and Document Type Definition (DTD) used within the file containing a deck. This 
information is used by XML-compliant gateways and other applications to deter-
mine how a particular document should be interpreted. An XML prologue looks 
like this: 
213 

Chapter 12 
214 
<?xml version="1.0"?> 
<!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" 
"http://www.wapforum.org/DTD/wml_1.1.xml"> 
The first line simply says that this file follows the syntax used by XML 1.0. The 
second line identifies the document as a WML document, meeting the WML 1.1 
specification (a DTD) made available at the indicated URL. It generally suffices to 
simply copy and paste these two lines into any WML document you create. You 
will need to take care, however, if you are writing for another version ofWML, 
such as 1.0 or 1.2, to specify the appropriate DTD. Gateway servers will use this 
DTD to validate your content before passing it off to wireless clients for viewing. 
The Document Heading 
After the prologue comes an optional heading, which gives information about the 
deck's contents. This header contains access control and meta information that 
pertains to all cards within the deck. Most often, this kind of meta information 
relates to caching and bookmark behavior. Table 12-2 shows these tags. 
Table 12-2. WML Tags Used to Organize a Deck 
TAG 
<access> 
<card> 
<head> 
<meta> 
AmiBUTES 
domain, path 
Varied 
name, http-equiv, 
user-agent 
content 
scheme,forua 
PURPOSE 
Specifies access control information 
fora deck 
Delineates a card element within 
a deck 
Specifies the heading of a deck 
Indicates the kind of <meta> tag 
being provided 
Provides the value for a <meta> tag 
Specifies particular details of how the 
<meta> tag should be handled 
Specifies a WML deck 
WML provides a simple form of access control that enables a deck to restrict 
who can link to its cards. This feature is useful in situations where all content 
should come from specific sources, such as applications that provide access to 
account or billing information. The <access> tag limits access based on the 
domain and path information of the link. The domain attribute of this tag 

Wireless Markup Language 
indicates the domain of other decks that can access cards in the deck, and the 
path attribute specifies the URL root of the other decks permitted access within 
the given domain. In the following example, only those decks served from the 
wap. apress. com domain under the root directory can link to the cards in 
this deck: 
<access domain="wap.apress.com" path="/"/> 
The <meta> tag specifies additional meta information for a deck. Like the 
HTML tag, it is used as a catch-all for various functions that are not implemented 
using tags elsewhere. Many of these behaviors and meanings are browser-spe-
cific; others determine the behavior of a gateway between the origin server and 
wireless terminal. The <meta> tag uses one of several property attributes to indi-
cate the kind of meta information being given, and the content attribute to 
indicate the value of the indicated meta information. Currently, the meta attri-
butes supported in WML are as follows: 
• name, indicating a meta value. (Some meta name values are used by specific 
browsers to perform operations not supported in WML, such as alter 
caching behavior.) 
• http-equiv, indicating a meta value to be treated as equivalent to an HTIP 
response header value. 
• user-agent, indicating a meta value for a specificWAP client. This indicates 
that only one vendor's WAP client will understand the meta contents, and 
the meta tag is only passed to that vendor's client when accessing content 
through a gateway. 
The <meta> tag includes two attributes that indicate how its contents should 
be handled by gateway servers and the client. The scheme attribute indicates 
a particular form or structure to be used to interpret the property value, allowing 
the content of a <meta> tag to be interpreted by a specified component of a par-
ticular browser. The forua attribute indicates whether the <meta> tag's contents 
should be sent to the browser or only interpreted by an intermediate gateway 
and discarded. When forua is equal to true, the <meta> tag is passed to the client; 
if it is false, any intermediary gateways must strip the value before sending the 
final content to the client. 
The dizzying array of <meta> tag attributes is best clarified with an example. 
As <meta> tags are generally used to control a specific browser's behavior in ways 
not supported by WML, let's consider the problem of restricting how long a page 
should be cached by a browser. The Openwave WML browser provides a set of 
<meta> tags based on HTTP headers to manage its cache. The following example 
215 

Chapter12 
216 
shows a <meta> tag to restrict a document's time in the cache to an hour. You 
explicitly specify an http-equiv <meta> tag with the value Cache-Control and 
direct gateways to forward this <meta> tag to clients by including the forua=true 
attribute: 
<meta http-equiv="Cache-Control" content="max-age=3600" forua=t:r:uel> 
Because many meta values are browser-specific, selecting an appropriate set 
of general-purpose <meta> tags to perform an operation not supported byWML 
can be difficult. 
WML Cards 
Each card contains a bite-sized piece of information suitable for presentation to 
the user on a single screen. Although you think ofyourWML documents in terms 
of decks, your users perceive content in terms of screens, each of which is 
declared as a card in your deck. Table 12-3 summarizes the attributes of the 
<card> tag that you will use to control card behavior. (You will find other WML 
attributes for the <card> tag in the WML specifications, but these are not sup-
ported by most of today's browsers.) 
Table 12-3. Attributes of the <card> Tag 
AmiBUTE 
id 
ordered 
onenterbackward 
onenterforward 
ontimer 
title 
PURPOSE 
Specifies a card's name for navigation. 
When true, a card's input elements must be navigated 
in order. 
Specifies a URL to present when the card is entered 
using a <prev> task. 
Specifies a URL to present when the card is entered 
using a <go> task. 
Specifies a URL to present when the card is entered 
using a <timer> task. 
Specifies a card's title for bookmarks or elsewhere. 
Anything you want the user to see in a deck has to be on a card. This includes 
interface elements, images, and styled text. In addition, a card may contain 
actions that a user can perform while viewing it. WML provides several attributes 
that control their behavior. 

Wireless Markup Language 
The title and id attributes are self-explanatory. With the title attribute, 
a developer can assign a human-readable name to a card, and with the id attri-
bute a developer can assign it a navigation reference. The id attribute is similar to 
the anchor name tag <A NAME= 11 
• 
• 
• 
11 > in HTML, which specifies a location 
within a document. 
The ordered attribute controls how multiple input elements on a card will be 
displayed. A WAP browser may be unable to display a set of items on a single card 
because of screen or memory constraints and may choose to place the items on 
separate "virtual" cards. If the ordered attribute is true (the default), the user will 
only be able to navigate through the elements in the order specified. If the 
ordered value is false, the browser has the option of creating an index of the 
items and allowing the user to select items from the index in any order. Thus, 
a set of several input lines can be presented sequentially or can be navigated in 
an arbitrary order. 
Three attributes (onenterforward, onenterbackward, and ontimer) are short-
hand for declaring a card that contains an <onevent> tag, binding an event to 
a URL. You use these when you want to override what a particular card shows 
depending on how the user accessed the card. Using these tags, you can specify 
the URL of a card to show instead of the current card. 
When the user views a card using the <go> task, the browser will load the URL 
specified by the onenterforward attribute. On the other hand, if the user views 
the card using a timer event or <prev> task, the card's contents are shown. 
Likewise, the browser will load the URL specified by an onenterbackward 
attribute when the user navigates to a card with that attribute using a <prev> task 
or the PREV button but will show the card's contents when it is viewed by other 
means. 
Finally, the ontimer attribute loads the specified card when a card's 
timer expires. 
Navigation 
In addition to using URLs, WML has adopted the HTML standard of naming 
locations within a resource. A WML card is specified by the document URL, fol-
lowed by a hash symbol (#), followed by the card's id attribute value. If no card 
identifier is specified, a URL names an entire deck. If the URL does not indicate 
a card, and the context calls for a specific card, the URL refers to the first card of the 
deck. WML supports relative URLs, too. The base URL of a WML deck is the one 
that identifies the deck, and relative URLs are evaluated relative to the base URL. 
In addition to supporting URLs, all WAP browsers are required to keep a his-
tory of the pages viewed by the user in a stack, sorted in the order they were 
viewed. This history can be accessed by the <prev> tag, which pops the most 
217 

Chapter 12 
218 
recently visited card from the history and returns the viewer to it, as if the 
browser's Back button had been pushed. 
Several WML tags are provided for defining how navigation occurs; 
Table 12-4 shows these tags. Each is worth a closer look. 
Table 12-4. WML Tags Used in Navigation 
TAG 
<a> 
<anchor> 
<go> 
<option> 
<select> 
Menus 
ATIRIBUTES 
href 
title 
href,sendreferer, 
method,accept-charset 
onpick,name 
key, default, ikey, 
idefault,title 
PURPOSE 
Shorthand for the tags <anchor><go 
href="url" /></anchor>. Must contain 
the href attribute. 
Anchors a task to a region of formatted 
text. Must contain both a task and 
character data. The optional title may be 
used by the browser for help, a tool tip, 
the label of a soft key, or other purposes. 
Specifies a task element instructing the 
browser to go to the URL indicated by 
the href attribute. 
Identifies a particular selectable item 
within a <select> tag and labels the 
action key with the indicated name 
attribute. If the item is selected, the 
browser navigates to the URL indicated 
by the onpick attribute. 
Establishes a list of option tags 
The <select> tag presents a menu ofitems from which the user can select (see 
Figure 12-3). Although this tag has historically been used only in forms, I recom-
mend you use it whenever you present a list of links, too, because users find it 
easy and convenient. 

Wireless Markup Language 
Here's an examp:e 
of nav~qat~on by 
se ect:.on _.:.sts . 
l ~ See anchor 
examp e 
2 See anchor 
Figure 12-3. The <select> tag in use 
The <select> tag contains a series of <option> tags, each containing the 
information pertinent to one of the possible options. An <option> tag has a label 
assigned by the author, which is shown in the main browser screen. In addition, it 
can have a name attribute, which indicates a label that the browser displays above 
the ACCEPT soft key when the user has scrolled to that item. If an option is to 
operate as a navigation item, it should also have an onpick attribute that specifies 
the URL for the browser to go to when the user selects the item. Listing 12-1 
shows this in action. 
Listing 12-1. The <select> Tag 
<card id="selection" title="Selection Example"> 
<p> 
<select> 
<option onpick="#anchor">See anchor example</option> 
<option onpick="#href">See anchor href example</option> 
</select> 
</p> 
</card> 
The <select> tag is well suited for the traditional "index" card found on most 
sites, which provides links to a variety of content on separate cards (often in 
other decks) from a central resource. Use it also to present a list of topics like 
a Web portal's News/Stocks/Weather choices. 
Hyperlinks and Tasks 
Traditional hyperlinks are available within WML, although you may find you use 
them less frequently. The creators of HTML introduced hyperlinks to provide 
supplemental information for specific topics within a body oftext. However, the 
219 

Chapter 12 
220 
mechanics of using a screen phone make reading large bodies of text-and con-
sequently, following trains of hyperlinks-cumbersome at best. 
Hyperlinks are supported using the <go> tag, which defines a navigation task, 
and the <anchor> tag, which binds this task to a region of text. For example, the 
WML in Listing 12-2 creates the card shown in Figure 12-4. 
Listing 12-2. Hyperlinks 
<card id="anchor" title="Anchor Example"> 
<p>Here 's an example of navigation by anchors. You can see the 
<anchor><go href="#selection"l>selection list 
example</anchor>, the <anchor><go href="#href"/>anchor href 
example</anchor>, the <anchor><go href="#task"/>event/task 
example</anchor>, or the <anchor><go href="#key"l>key/task 
example</anchor>. 
<lp> 
<Icard> 
I" 
-
Here's an examp:e 
of nav ' qat ' on by 
anchors . 
• See se ection 
list examp:e 
[See anchor href 
L.:..nk 
Back 
Figure 12-4. Hyperlinks in a 'WML document 
Ill!,, 
t' 
l: 
t.i 
The rendering and selecting of hyperlinks varies from device to device; many 
devices use a directional cursor key that allows the user to select items by moving 
a cursor between selections. The <anchor> tag may provide an optional title 
attribute used to identify the item within the browser interface. How this infor-
mation appears differs from browser to browser; the Openwave browser uses it to 
label a soft key, and other browsers may choose to show the information in a sup-
plemental display line or provide other feedback. 
The <go> tag has attributes that specify the kind of navigation event that 
should take place. The mandatory href attribute indicates the destination URL; 
other attributes, which are generally only used when defining a form navigation 
task, are discussed in the next section. 

Wireless Markup Language 
You can use the <anchor> tag to anchor any task to a region oftext. Thus, the 
followingWML can create a hyperlink that brings the user to the previously 
viewed page: 
<anchor><prev/>Go back from whence you came!</anchor> 
This example is equivalent to the <prev> tag with the following content: 
<prev>Go back from whence you camel</prev> 
As in most languages, there is more than one way to say something! WML 
provides shorthand for the <anchor>/ <go> tag pair: the <a> tag, which combines 
the two like so: 
<a href="http://some.host.com/content.wml">A link</a> 
You may use it wherever an <anchor>/ <go> tag pair would be used, provided 
the default actions for both the <anchor>and <go> tags are appropriate. 
You can use navigation tasks with other events as well, such as timers. 
A timer event is generated when the delay specified by a <timer> task in a deck 
has elapsed. For example, the card in Listing 12-3 uses a timer and the card's 
ontimer attribute to force the browser to navigate to the card named key in the 
current deck after the timer expires. The timer is set to elapse after five seconds. 
(All timer values are expressed in tenths of a second.) 
Listing 12-3. A Card Timer Task 
<wml> 
<card id="task" title="Task Example" ontimer="#key"> 
<timer value="SO" name="time"l> 
<p>In five seconds, this card will take you to the key/task example.</p> 
<Icard> 
<card id="key" title="Key Example" ontimer="#task"> 
<p>It didn't take that long, did it? <p> 
<Icard> 
</wml> 
WML Navigation Example 
Combining the samples in the previous section, Listing 12-4 illustrates the ways 
you can code navigation in WML. Look for navigation using selection lists, hyper-
links, hyperlinks using the <a> tag, and two kinds of navigation tasks. 
221 

Chapter 12 
222 
Listing 12-4. Navigation Using Selection Lists 
<?xml version="l.O"?> 
<IDOCTYPE wml PUBLIC "-1/WAPFORUM//DTD WML 1.1//EN" 
"http://www.wapforum.org/DTD/1111111_1.1.xml"> 
<wml> 
<card id="selection" title="Selection Example"> 
<do type="options" label="Back"> 
<prev/> 
</do> 
<p>Here's an example of navigation by selection lists.</p> 
<p> 
<select> 
<option onpick="#anchor">See anchor example</option> 
<option onpick="#href">See anchor href example</option> 
<option onpick="#task">See event/task example</option> 
<option onpick="#key">See key/task example</option> 
</select> 
<lp> 
</card> 
<card id="anchor" title="Anchor Example"> 
<do type="options" label="Back"> 
<prev/> 
</do> 
<p>Here's an example of navigation by anchors. You can see the 
<anchor><go href="#selection" />selection list example</anchor>, the 
<anchor><go href="#href"l>anchor href example</anchor>, the 
<anchor><go href="#task"l>event/task example</anchor>, or the 
<anchor><go href="#key"l>key/task example</anchor>. 
</p> 
</card> 
<card id="href" title="HREF Example"> 
<do type="options" label="Back"> 
<prevl> 
</do> 
<p>Here's an example of navigation by anchors.</p> 
<p> 
<a href="#selection">See selection list example</a><br/> 
<a href="#anchor">See anchor example</a><br/> 
<a href="#task">See event/task example</a><brl> 

Wireless Markup Language 
<a href="#key">See key/task example<la><br/> 
<lp> 
<Icard> 
<card id="task" title="Task Example" ontimer="#key"> 
<timer value="so" name="timel"l> 
<do type="options" label="Back"> 
<prevl> 
</do> 
<p>In five seconds, this card will take you to the key/task example.</p> 
</card> 
<card id="key" title="Key Example" ontimer="#task"> 
<timer value="lOO" name="time2"1> 
<do type="accept" label="Selection"> 
<go href="#selection"l> 
</do> 
<do type="options" label="Anchor"> 
<go href="#anchor"/> 
</do> 
<p>In ten seconds, this card will take you to the event/task example.</p> 
<p>You can use one of the soft keys to go elsewhere.</p> 
<Icard> 
</wml> 
This example also shows the use of the <do> tag to bind a task to an interface 
element. As used here, the tag is similar to the <anchor> tag: The task to be bound 
is wrapped within the <do> tag, which specifies the details of the interface ele-
ment to be bound. While the <anchor> tag binds tasks to text, the <do> tag binds 
any interface element to a task. 
Interaction 
WML is designed to be an interactive markup language. It has several constructs 
that allow interactivity for simple operations. These constructions can substitute 
variables or codify dynamic interface elements the client will execute entirely on 
the client side without time-consuming wireless queries. 
One wayWML accomplishes this is through tasks, operations that the 
browser performs in response to events. The WML standard defines several kinds 
223 

Chapter 12 
224 
of events, such as the user viewing a new card or a time interval elapsing. In 
addition, there are tasks, such as navigation, that are not restricted to a single 
card. You can connect these in different ways in your WML by specifying an event 
and a task to be performed when the event occurs using the <onevent> tag. 
In addition to events and tasks, WML makes selection objects and text fields 
available to allow decks to accept user input. Your deck can use this input locally 
to create dynamic scripts, or it can interact with remote services, such as stock 
quote services, weather reports, and so on. 
Events 
WML presently defines four events that occur when the browser performs a spe-
cific function: 
• The browser generates an onenterforward event when a user navigates to 
a card using an element that is tied to a <go> tag. 
• The browser generates an onenterbackward event when a user navigates to 
a card using a <prev/> tag. (This also occurs when the user presses the 
PREVkey.) 
• The browser generates an onpick event if a user selects or deselects an item 
generated by an <option> tag. 
• The browser generates an ontimer event when a specified <timer> element 
expires. 
Developers often use the onenterforward and onenterbackward events to 
manipulate the chain of cards in a form to prevent the misuse of history and 
guarantee valid form data during submissions. For example, many decks use the 
following snippet: 
<card> 
<onevent type="onenterbackward"> 
<prev/> 
</onevent> 
<I--card content here--> 
</card> 
This bit ofWML prevents the given page from being visited as a result of 
a PREY key press or <prev I> operation. If the user requests one, the browser will 

Wireless Markup Language 
instead navigate to the card preceding this one. A variation, which forces the 
viewer to the beginning card in a deck if the PREY key pressed, is as follows: 
<card id="home"> 
<!--home card content here--> 
<Icard> 
<card> 
<onevent type="onenterbackward"> 
<go href="#home"> 
<lonevent> 
<I--card content here--> 
<Icard> 
Less often, a content provider may use a similar trick to prevent forward nav-
igation to a card, using the onenterforward event. 
You can use both the onenterforward and onenterbackward events to refresh 
a page's variables, as shown in the following example. This is important when 
their values may have changed: 
<card> 
<onevent type="onenterbackward"> 
<refresh><setvar name="ticker" value=""/></refresh> 
</onevent> 
<onevent type="onenterforward"> 
<refresh><setvar name="ticker" value=""l></refresh> 
</onevent> 
<I--card content here--> 
</card> 
The browser generates the onpick event by the <select> tag in response to 
the selection of an <option> item. This tag is used in conjunction with variables 
to prepare form data or provide an interactive feel, such as in Listing 12-5. 
Listing 12-5. Using the <select> Tag 
<?xml version="1.0"?> 
<IDOCTYPE wml PUBLIC "-1/WAPFORUM//DTD WML 1.1//EN" 
"http: //www.wapforum.org/DTD/wml_1.1.xml "> 
<wml> 
<card id="cl" title="Volume"> 
<onevent type="onpick"> 
225 

Chapter 12 
226 
<go href="#results"l> 
</onevenb 
<p> 
Pick the ringer volume: 
<select title="Category" name="volume"> 
<option value="4"Excruciating</option> 
<option value="3">loud</option> 
<option value="2">Soft</option> 
<option value="l">Silent</option> 
</select> 
<lp> 
</card> 
<card id="results"> 
<onevent type="onenterbackward"> 
<prev/> 
</onevent> 
<do type="options" label="Clear"> 
<refresh> 
<setvar name="volume" value="l"l> 
</refresh> 
</do> 
<p> 
You selected ringer volume level $(volume). 
Your phone will be set appropriately. 
<lp> 
</card> 
</wml> 
This deck produces the output shown in Figure 12-5. This deck demonstrates 
the use of the <select> tag and the <option> tag to select a ringer volume (note 
that we do not actually set a ringer volume because there is no way to do that in 
WML without device control in WMLScript!). For each <option> tag, an onpick 
attribute will cause the browser to navigate to the card named results. 

Wireless Markup Language 
vo ume : 
l .,Ex:cruc ·at:.nq 
2 Loud 
3 Soft 
4 SLent 
OK 
Figure 12-5. WML <select> tag and variables 
ri.nqer vo ume 
eve 
3. Your 
phone w· : be set 
appropr ' ate y . 
Back 
You encountered the ontimer event in the previous section. This timer event 
is the only event generated by an explicit tag within a WML deck. The <timer> tag 
declares a timer that starts when the page is viewed and counts down the speci-
fied number of tenths of a second. When the timer expires, the task associated 
with it is executed. Listing 12-6 simply flips between two cards every two seconds 
using two timers. 
Listing 12-6. Using Timers 
<?xml version=" 1. o" ?> 
<IDOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" 
"http: I lwww.wapforum.orgiDTDiwml_l.l.xml"> 
<wml> 
<card id="c1" title="Card 1" ontimer="#c2"> 
<timer value="20" name="cl"l> 
<p> 
Card 1. 
<lp> 
<Icard> 
<card id="c2" title="Card 2" ontimer="#cl"> 
<timer value="20" name="c2" I> 
<p> 
Card 2. 
<lp> 
<Icard> 
<lwml> 
This example also demonstrates the use of <card> attributes to associate nav-
igation tasks with events. In addition to being the names of events, the words 
227 

Chapter 12 
228 
onenterforward, onenterbackward, and ontimer describe attributes of a card, as 
discussed earlier in this chapter. Rather than using the <onevent>/ <go> tag pair to 
declare a task and specify a destination URL in response to an event, you can 
bind a task to one of these attributes. 
In addition, you can assign tasks to specific user interface elements using the 
<do> tag. The browser provides a set of generic interface elements, any one of 
which can be bound to a task using the <do> tag. When the user activates an ele-
ment bound with the <do> tag, the browser executes the corresponding task. The 
WAP standard explicitly restricts the names of the user interface objects that can 
be customized so that developers have a set list of items that they can use, but it 
leaves open the implementation of those interface elements so that hardware 
manufacturers can make these elements areas of a touch screen, soft keys, voice 
commands, or other items. 
At present, the WAP Forum has defined the following interface elements: 
• The accept element specifies the mechanism (soft key, hardware key, voice 
command, or so on) by which the user accepts screen data and sends it to 
the browser. 
• The options element specifies the mechanism for providing the user with 
a set of options from which to make a choice. 
• The delete element specifies the mechanism by which the user deletes an 
input. 
• The help element specifies the mechanism by which the user requests help 
about the current deck or the phone. 
• The prev element navigates to a previous card by invoking the browser's 
PREV mechanism. 
• The reset element invokes the browser's reset mechanism, bringing the 
device to a "fresh-from-factory" state (like resetting a computer). 
• The unknown element indicates an unknown interface element that has not 
been specified. It is equivalent to specifying a <do> task with no type attri-
bute or a type attribute consisting of an empty string. You should not use 
this element. 
• Types of the form vnd.co-type indicate manufacturer-specific mecha-
nisms, where co indicates the manufacturer and type indicates the type of 
interface element. 

Wireless Markup Language 
• Types of the form X-* and x-*, where* is any string, are reserved for 
future use. 
(Note that unless you are developing for a specific platform with documen-
tation indicating it is supported, you should not use the unknown, vnd. co-type, or 
X-* elements.) It is important to remember when creating content that these 
interface items can be anything-hardware keys, soft keys with a corresponding 
LCD labels, handwriting gestures, voice commands, or operations yet to be 
devised. 
In practice, however, most <do> types map tasks to the accept and options 
interface elements. You have already seen several examples of this. Consider this 
example: 
<do type="options" label="Clear"> 
<refresh> 
<setvar name="volume" value="1"1> 
</refresh> 
</do> 
This WML simply binds the operation of resetting a form's variable to 
a known default when the user invokes the options interface element. This ele-
ment is labeled Clear, giving the user some indication of its purpose. Within the 
Openwave browser, for example, this element is the right soft key. 
So far, you have looked only at examples of binding tasks to events over 
the scope of a single card. You can bind an event to a task across an entire deck 
by using the <template> tag. This tag resembles a simplified <card> tag with 
attributes: 
<template onenterforward="url" onenterbackward="url" 
ontimer="url"> 
<!-- Arbitrary <do> or <onevent> tags --> 
</template> 
For example, a deck providing a form for a server could use the following 
template to override the browser's history behavior and provide a single-key 
mechanism for restarting a form entry from scratch: 
<template onenterbackward="#home"> 
<do type="options" label="Change"> 
<go href="#home" I> 
</do> 
</template> 
229 

Chapter 12 
230 
If the user pressed the PREY key while viewing any card in the deck with this 
<template>, the card identified by home would be loaded. In addition, if the 
user pressed the OPTIONS key, the browser would display the home card, just 
as if PREY were pressed, allowing the user to make changes to the data they 
had input. 
Tasks 
In the process of exploring events and navigation, you have already encountered 
most of the tasks WML provides. As you have seen, the <go> tag specifies a navi-
gation task: 
<go href="url" sendreferer="boolean" method="method" 
accept-charset="charset"> 
<!--Optional post field declarations here --> 
</go> 
The <go> tag defines both conventional navigation and form submission 
navigation. In the latter case, the tag specifies the fields to be posted to the server 
handling the form. If desired, you can have the submitting deck's URL returned 
to the server using the sendreferer attribute; if you assign it a value of true, 
a back-end server will determine the source of the deck originating the request. 
Finally, for international applications, you can specify a list of supported charac-
ter sets with the accept-charset attribute, indicating to the WAP gateway that 
content should be converted into one of the character sets named in the 
browser-supplied list. 
The <prev> tag is a simplified form of navigation based on the browser's his-
tory stack. It is most often encountered as the empty tag <prev/>, but can also be 
used as a pair. This is a bit ofWML that clears a variable (presumably for a form 
input) with <setvar> before returning to a previous card: 
<prev><setvar name="last-name" value=""/></prev> 
If more than one variable at a time is to be set, use a separate <setvar> tag for 
each one. 
Often, it becomes necessary to reset variables to a new value and redraw 
a page because of some user action-for example, to clear a form's input lines 
when the user wants to start again. The <refresh> tag does this. The volume con-
trol deck presented previously used <refresh> and <setvar> to set the volume 
variable to a known value: 

Wireless Markup Language 
<do type="options" label="Clear"> 
<refresh> 
<setvar name="volume" value="l"/> 
</refresh> 
</do> 
As with the <prev> tag, more than one variable can be set within a <refresh> 
tag using multiple <setvar> tags. 
Finally, WML provides an interesting task tag called <noop/>, which does 
exactly what its name implies: no operation-that is, nothing. This tag is far from 
useless; it can be used anywhere a task is required by syntax, but no task should 
occur. This is often the case when an interface element is assigned to a task 
across a whole deck using a template but you want to override the task assign-
ment on a particular card. You might want to do this, for example, on a site where 
you allow the user to return to the beginning of a deck to enter information, 
except on the page where the results are displayed (presumably because once 
the results are displayed, the user will want to progress to another deck). In 
Listing 12-7, the default task assigned to the options interface element is to go 
to the card named options, and this element is labeled Change. For this one card, 
the task that occurs when it is invoked has been replaced with no action, and the 
label is suppressed. 
Listing 12-7. Usingthe<noopl> Tag 
<wml> 
<template onenterbackward="#home"> 
<do type="options" label="Change"> 
<go href="#home" I> 
</do> 
</template> 
<card ••• > 
<do type="options" label=""> 
<noopl> 
</do> 
<Icard> 
231 

Chapter 12 
232 
Forms 
While the ability of a WML deck to operate interactively with the user of the 
device is important, it is only half the story ofWMI.:s dynamic capabilities. WML 
decks also support traditional form-based operations, which allow users to sub-
mit all kinds of input data via the wireless network to Web servers and receive 
responses. This technology can be used for a multitude of purposes, as it is with 
traditional Web applications. 
WML provides two kinds of input primitives: option lists and text fields. Both 
of these primitives use variables to store the resulting data. Once a form has been 
completed, a <go> task submits the variable name/value pairs to the server for 
processing. 
Table 12-5 provides a reference to the tags you will use in forms discussed in 
this section. You will use these tags to define form elements, as well as bind inter-
face elements to tasks. 
Table 12-5. "WML Tags Used in Forms 
TAG 
<do> 
<go> 
<input> 
<noop/> 
<option> 
<onevent> 
<prevl> 
AmiBUTES 
type 
href,method,sendreferer, 
accept-charset 
Varied 
title,value,onpick 
type 
PURPOSE 
Binds a task to an input element. 
Defines a navigation task to the URL 
specified by href via the indicated 
HTI'P method. Can be used to 
specify character transcoding for 
forms submissions via the accept-
charset attribute. 
Defines an input field given 
attributes defining its name, input 
mask, length, size, and default value. 
A task tag that does nothing. 
Creates an option with the indicated 
title and value. The onpick attribute 
specifies a URL where navigation 
proceeds if the item is selected. 
Binds an event of the specified type 
to a task. 
A task tag that pops the current card 
from the browser's history and 
returns to the previously viewed card. 
(continued) 

Wireless Markup Language 
Table 12-5. \IVM"L Tags Used in Forms (continued) 
TAG 
<postfield> 
<select> 
<refresh> 
<template> 
ATTRIBUTES 
name, value 
name 
onenterforward, 
onenterbackward,ontimer 
PURPOSE 
Declares the indicated value attribute 
to be assigned to the server-side 
variable. 
Establishes a list of option tags 
storing the user selection in the 
variable specified by name. 
A task tag used to set the values of 
the indicated variables and refresh 
the current card. 
Defines the default event/task 
bindings for a deck. Contains zero or 
more <do> or <onevent> tags. 
<task> 
type, label, name, optional 
Binds a task to an interface item 
identified by the type attribute given 
in the name attribute. 
The <select> and <option> tags let you present users with a list of items and 
to set a variable to a value corresponding to the option selected. For example, the 
following WML fragment will result in setting the variable volume to a value 
from l to 4 depending on which item the user chooses: 
<select title="Category" name="volume"> 
<option value="4">Excruciating</option> 
<option value=" 3 '"'>Loud< I option> 
<option value="2">Soft</option> 
<option value="l">Silent</option> 
</select> 
Input to text fields is handled in a similar way: User input is accepted and 
used to assign a value to a specified variable. WML provides only a single way to 
request text input from the user, the <input> tag. This simplicity is deceiving 
because its attributes provide a lot of freedom to content developers. 
At a minimum, the <input> tag must specify the name of the variable to be 
set, using the name attribute. For example, the following line in WML: 
<input name="ticker" I> 
233 

Chapter 12 
234 
results in assigning user input from that card to the variable ticker for access by 
other parts of the WML deck. 
Most requests for user input are more sophisticated, however. For one thing, 
good interface design for handheld clients involves restricting the user's freedom 
to make mistakes. The <input> tag provides a variety of ways to limit possible 
input, making errors on the client side less likely. 
The most powerful of these error-avoidance techniques is the format attri-
bute, which allows you to specify a string, called a type mask, that indicates, 
character for character, what kinds of input are valid. Each character of the type 
mask indicates the appropriate type for one or more characters of the input. 
A type mask contains integers, which indicate the number of characters that 
should match a specific type (an asterisk indicates that any number of characters 
of this type is allowed) and type declarations. Table 12-6 shows possible type 
declarations. 
Table 12-6. Type Declarations for a WM"L Input Type Mask 
CHARACTER 
A 
a 
M 
m 
N 
X 
X 
ALLOWED INPUT TYPE 
Any symbolic or uppercase alphabetic character 
Any symbolic or lowercase alphabetic character 
Any symbolic, numeric, or uppercase alphabetic character 
(changeable to lowercase)-for multiple-character input, defaults 
to uppercase first character 
Any symbolic, numeric, or lowercase alphabetic character 
(changeable to uppercase)-for multiple-character input, defaults 
to lowercase first character 
Any numeric character 
Any symbolic, numeric, or uppercase alphabetic character (not 
changeable to lowercase) 
Any symbolic, numeric, or lowercase alphabetic character (not 
changeable to uppercase) 
Thus, the type mask lON indicates a 10-digit number (such as a North 
American phone number) with no hyphens or spaces, and the type mask 2A 
would restrict input to two alphanumeric characters, such as a U.S. state code. 
WML browsers may use the format attribute to both verify the data input by the 
user and tune input methods to meet the indicated type. (For example, a speech 
recognizer may be primed to only recognize numbers when a numeric format 
field is encountered.) 

Wireless Markup Language 
In addition to masking the kinds of data that can be entered, you can use the 
<input> tag to specify the default and maximum size for a field. The size attri-
bute gives an exact number of characters for an input field, and the maxlength 
attribute gives a maximum number. Note that these two attributes complement 
the format attribute; the format attribute defines the actual size and format of 
valid input, and the size and maxlength attributes restrict the behavior of the 
input element. 
The value and defaults attributes both allow you to set a field's initial value; 
the two tags are functionally equivalent. 
Some examples of valid input lines, which can be used as building blocks for 
more complicated forms, are as follows: 
• A stock ticker can be accepted using <input name="ticker 11 format= 11A4A 11>. 
• A domestic phone number can be accepted using <input name= 11 phone 11 
format= 1110N11>. 
• A person's name can be entered using <input name= 11namell format= 11*M11>. 
Once a form is rendered and the data collected, the browser returns the 
resulting variable values to the server for processing via a <go> tag and one or 
more <postfield> tags. The <go> tag, as you have seen elsewhere, specifies the 
destination URL where the form is to be submitted. 
The <go> tag must also specify the method to be used to deliver form data to 
the server. As discussed in Chapter 4, "The Wireless World Wide Web," a Web 
server may use one of two kinds of HTTP methods for accepting data: GET or POST. 
Although the mechanics of these methods are not relevant to many content 
authors, the net effect is; submitting data using the GET method to a server 
expecting a POST method, or vice versa, can result in unexpected behavior. 
A server expecting the GET method expects its form data within the URL being 
submitted by the client, and a server using the POST method will look for form 
data within the object body of the data sent to the server as part of the form 
request. 
WML supports both kinds of form requests. You can specify which kind is to 
be used by setting the method attribute of the <go> tag to the value GET or POST, 
appropriately. 
Within the <go> tag, one or more <postfield/> tags define the actual content 
to be sent in the form request. The <postfield/> tag is an empty tag bearing name 
and value attributes. The name attribute indicates the name of the server-side 
variable to be posted, and the value attribute gives the value of that variable. It is 
important to recognize that the variables being named here are notWML vari-
ables, but the variables defined by the server for processing form data. You use 
235 

Chapter 12 
236 
the <postfield/> tag to establish the correspondence between a Web server's 
form variables and your WML variables. 
For example, a server seeking a ZIP code to serve location-based information 
might offer the following <go> task within a deck: 
<do type="accept" label="Weather"> 
<go method="post" href="?"> 
<postfield name="zip" value="$zip"l> 
<I go> 
</do> 
Here, the remote server is expecting a single form variable, called zip. The 
<postfieldl> tag tells the browser that the server's zip variable should be set to 
the value of the WML browser's zip variable (evaluated using the expression $zip) 
when the <go> task is executed. 
An admittedly artificial example that uses WML variables, form tags, and the 
<go> and <postfieldl> tags to obtain a bank balance is shown in Listing 12-8. 
Listing 12-8. Using Forms Input 
<?xml version="l.O"?> 
<!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" 
"http://www.wapforum.org/DTD/wml_1.1.xml"> 
<wml> 
<template onenterbackward="#home"> 
<do type="options" label="Change"> 
<go href="#home"l> 
</do> 
</template> 
<card id="home" title="Account Type"> 
<p> 
Please indicate the type of account: 
<select title="Account" name="account"> 
<option valua="Savings" onpick="#number">Savings</option> 

Wireless Markup Language 
<option value="Checking" onpick="#number">Checking</option> 
</select> 
<lp> 
</card> 
<card id="number" title="Account Info" ordered="true"> 
<p> 
Account Number: 
<input name="number" title="Number" type="text" 
format="4NA4N" emptyok="false"l><brl> 
Last Four Digits of SSN: 
<input name="social" title="SSN" type="password" 
format="4N" emptyok="false"l><brl> 
<lp> 
<p> 
Obtaining account balance ••• use Fetch to continue. 
<do type="accept" label="Fetch"> 
<go href="results?" method="post"> 
<postfield name="acct-type" value="$account"/> 
<postfield name="acct-num" value="$number"/> 
<postfield name="acct-ssn" value="$social"l> 
</go> 
</do> 
<lp> 
<Icard> 
</wml> 
This example is somewhat contrived; its user interface fails miserably almost 
anyone's test for usability and intuitiveness (see Figure 12-6). But although ugly, it 
does give you a good idea of how to use the various user input tags together with 
a form to post several form variables to the server. 
237 

Chapter 12 
238 
fill:~ 
-
-
:~ P ease indicate 
~ 
~~ the type of 
~ 
~ a ccount : 
"' 
1 ~ Sav · nqs 
~ 2 Checkinq 
I'; OK 
Chanae 
~; :•:. 
r · ... -.-
-·~--- -
.. 
. 
~ 
r 
Account rumber : 
1234-5678901 
OK 
) 
aloha 
H 
...k 
-- -
·~ ~---
f: 
Obta ' ninq account 
ba ance ... use 
Fetch to 
cont.:..nue . 
'· 
" 
11 
Fetch 
l, 
Chanae r 
....... 
~ ....... 
-----.. --.......... ill 
:nformati on 
;, 
Account 
-~:: 
type :Savinqs 
Account 
~-· 
1 :1234-567890 : 
jl 
Ba ance : $142 . 35 Jl·,, 
Back 
Chanae 
Figure 12-6. An example of a WML application with a poor user interface 
A more complex but more user-friendly approach, assuming the device has 
a unique identifier, would be to use this identifier (or some other simple authen-
ticating mechanism) with the back-end server to determine which accounts can 
be queried wirelessly. Then, rather than having to deal with the mechanics of 
entering an account number and password, the user would have to make only 
a single selection to indicate the desired account. 
The back end to support such a system is beyond the scope of this section 
(and largely dependent on both the wireless provider and bank being supported). 
But Figure 12-7 shows the improved user interface. 

Wireless Markup Language 
iF 
r-..---~-"~ 
:nformat ·on 
Account 
type :Sav·nqs 
Account 
it : 1234-432 
Ba_ance : $142 . 35 
Back 
Figure 12-7. An example of a lVML application with a better user interface 
The WML deck returned by such a server might look like listing 12-9. 
Listing 12-9. A Deck with a Well-Structured User Interface 
dxml version="l.o"?> 
<!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" 
"http://WvM.wapforum.org/DTD/wml_1.1.xml"> 
<wml> 
<card id="home" title="Account Type"> 
<p> 
Greetings, 
Mr. Rischpater! 
Please select your account of interest: 
<select title="Account" name="account"> 
<option value="1234-4321">Savings</option> 
<option value="4321-4321">Checking</option> 
</select> 
<lp> 
<do type="accept" label="Fetch"> 
<go href="results?" method="get"> 
<postfield name="acct" value="$account"l> 
</go> 
</do> 
<Icard> 
</wml> 
Format 
.1 
J -
Despite the meager displays available on most handheld devices, WML provides 
a limited set of text formatting tags. These tags are largely contextual, and the 
239 

Chapter 12 
240 
WAP specifications do not specify how browsers should interpret them. Thus, 
their behavior can differ from device to device, and some browsers may choose 
to ignore some tags altogether. 
As you can see from Table 12-7, most of the tags you will use for formatting 
strongly resemble the HTML tags discussed in Chapter 6, "Server-Side Content-
Management Scripting." 
Table 12-7. WML Tags Used for Formatting 
TAG 
<b> 
<big> 
<br/> 
<em> 
<i> 
<img> 
<p> 
<small> 
<strong> 
<table> 
<td> 
<tr> 
<u> 
ATTRIBUTES 
alt,src,localsrc, 
heignt,width,align 
align, mode 
PURPOSE 
Indicates that text should be bold. 
Indicates that text should be in 
a larger font than the default. 
Indicates a line break. 
Indicates that text should be displayed 
with emphasis. 
Indicates that text should be in italics. 
Indicates an image; attributes specify 
its text description, source (from server), 
source (local), height and width (in 
pixels), and alignment on screen (left, 
right, or center). 
Defines a paragraph of text with the 
indicated alignment (left, right, or 
center), and word wrapping (wrap or 
nowrap). 
Indicates that text should be in a smaller 
font than the default. 
Indicates that text should be displayed 
with strong emphasis. 
columns, align, title 
Indicates a table; attributes specify 
number of columns (mandatory), 
alignment on screen (left, right, center), 
and title. 
Demarcates a cell within a table row. 
Demarcates a row within a table. 
Indicates that text should be underlined. 

Wireless Markup Language 
Typography 
The WML standard provides tags that alter the size of text. The <big> and <small> 
tags create regions of text in a larger or smaller font, respectively, than the 
default. You can use these to create simple headings, like this: 
<p><big>WAZU Fundamentals</big><lp> 
<p> 
Last trade: 64 3/8<br/> 
Today's Range 63 7/C-67 3/16<br/> 
Volume: 516,200<br/> 
<lp> 
The <strong> and <em> contextual tags provide a means to make informa-
tion that needs emphasis stand out. Most browsers will try to render these the 
same way HTML does: <strong> indicating boldface text, and <em> indicates ital-
icized text. Unfortunately, manyWML client devices do not have fonts with 
italicized text, and many do not have the ability to draw text in bold either. 
(Figure 12-8 shows a client that uses bold face text for both< strong> and <em> 
because it cannot support an italic font.) The syntax of <strong> and <em> is the 
same as for the <big> and <small> tags: 
<wml> 
<card> 
<p><big>WAZU Fundamentals</big></p> 
<p> 
Last trade: <strong>64 3/8</strong><br/> 
Today's Range <strong>63-67</strong><br/> 
<em>Volume: 516,200</em><br/> 
<lp> 
</card> 
</wml> 
Last 
3/8 
Today's Ranqe 
63-67 
Volume: 516,200 
Back 
Figure 12-8. WMLformat tags in action 
241 

Chapter 12 
242 
WML also has tags to produce particular effects in text, such as bold face, 
italics, and underlining: 
• The <b> tag indicates text that should be boldface. 
• The <i> tag indicates text that should be rendered as italic. 
• The <u> tag indicates text that should be underlined. 
Not all browsers support these tags, so it is important to be sure that the 
information called out will still appear in a clear and readable manner on devices 
where these tags are not available. 
Text Regions and Text Alignment 
All text on a card is contained within one or more paragraphs, which are defined 
by the paragraph tag <p>. This tag has two optional attributes, mode and align. 
Use the mode attribute to specify whether text should be word wrapped. By 
default, paragraphs are word wrapped; if the mode attribute is equal to nowrap, 
lines will instead be truncated to fit the display. With the align attribute, you can 
specify a paragraph's alignment; possible values are left, right, and center. 
The empty tag <br I> breaks lines within a paragraph and can be used to for-
mat simple tables, verse, or other information where the specifics of line breaks 
become important. 
Tables 
In many cases, a table can represent information more succinctly than a para-
graph can. WML has a <table> tag, but its use, unlike the corresponding tag in 
HTML, is restricted. A WML table must indicate the number of columns it will 
present using its columns attribute. All elements must occupy only a single cell-
they cannot span multiple rows or columns. You cannot nest tables in WML. 
Some formatting options exist, however. A table may be aligned to the left or 
right, or centered on its card using the align attribute, just as a paragraph can. It 
also may have a specific title identified by the title attribute, which the browser 
presents with the table. 
Within a table, rows are enclosed between opening and closing <tr> tags. 
A table may have any number of rows {within reason); this number is not speci-
fied ahead of time. A row may be empty, or it may contain table elements, which 
are demarcated by the <td> tag-one pair for each cell. There should be as many 

Wireless Markup Language 
<td> tags per row of the table as there are columns for the table; an empty <td> 
tag indicates an empty cell in the table. 
Listing 12-10 shows a WML table that generates the card shown in Figure 12-9. 
Listing 12-10. Using Table Tags 
<?xml version="l.O"?> 
<! DOCTYPE wml PUBLIC "-1/WAPFORUM//DTD WML 1.1//EN" 
"http://ww.~.wapforum.org/DTD/wml_1.1.xml"> 
<wml> 
<card title="Table"> 
<p align="center"> 
Weather Forecast for<br/> 
Boulder Creek, CA 
<table columns="2"> 
<tr> 
<td>High</td> 
<td>68</td> 
<ltr> 
<tr> 
<td>Low</td> 
<td>54</td> 
<ltr> 
</table> 
<lp> 
<Icard> 
</wml> 
F 
-~~?"" 
~weather Forecast 
Bou der creek, CA 
Hiqh 68 
Low 
54 
I' 
Back 
-
Figure 12-9. A simple table 
tl' 
I 
IM' 
243 

Chapter 12 
244 
Images 
Although mostWAP terminals are ill-suited to displaying images, the WAP stan-
dard does support the presentation of image data. The <img> tag instructs the 
device to draw the specified image. At present, the WML specification calls for 
supporting the Wireless Bitmap standard, which accommodates other graphics 
formats including GIF and BMP. At present, because of the widespread adoption 
of Microsoft Windows by content developers, most of the WML simulators accept 
one-bit-per-pixel Windows BMP files, rather than the GIF or JPEG file formats 
most Web content developers use. The kinds of images supported by any specific 
device depend on the WAP gateway provided by the wireless service provider. 
The al t attribute of the <img> tag specifies a text label for the image. This 
string should be a brief description of the image, such as sun, smile, up arrow, or 
a similar legend, which will be displayed instead of the image on any device that 
cannot show the image. In addition, all image tags must include a src attribute 
that specifies the source of the image the browser should display. For example: 
<img alt= 11 smile 11 src= 11 smile. bmp 11 I> 
You have the option of supplying the height and width, in pixels, that the 
image should occupy, although browsers are not required to honor these attri-
butes. You can specify the vertical alignment using the align attribute, indicating 
one of top, middle, or bottom. 
In addition to supporting Wireless Bitmap images, WML provides the ability 
to reference images stored on the device. These images may be in Read-Only 
Memory (ROM), in flash memory, or elsewhere where access is not an issue for 
the browser. They can be accessed using the image tag's source attribute, local-
src. One image can have both a source and a local source attribute; the browser 
will look for the image resource named in the localsrc attribute first; if it does 
not find it, it will download the image from the URL indicated in the src attri-
bute. For example, an application targeted for Open wave's WML browser could 
use the following image tag to select the cloud image within the browser: 
<img alt=cloud" src= 11cloud.bmp 11 1oca1src= 11cloud 11/> 
Browsers without this local resource would download and present the 
cloud. bmp image available from the server that provided the deck containing 
this tag. 
The previous section's weather example was missing an important character-
istic of weather reports: the current conditions. Listing 12-11 adds an icon to the 
weather report. 

Wireless Markup Language 
Listing 12-11. Using the <img> Tag 
<?xml version="l.O"?> 
<! DOCTYPE wml PUBLIC "-I /WAPFORUM/ /DTD WML 1.1/ /EN" 
"http://www.wapforum.org/DTD/wml_l.l.xml"> 
<wml> 
<card title="Table"> 
<p mode="nowrap" align="center"> 
Weather Forecast for<br/> 
Boulder Creek, CA 
<lp> 
<p align="center"> 
<img alt="Sun" src="sun.bmp"/> 
</p> 
<p> 
<table columns="2"> 
<tr> 
<td>High</td> 
<td>68</td> 
</tr> 
<tr> 
<td>Low</td> 
<td>54</td> 
</tr> 
</table> 
<lp> 
<Icard> 
</wml> 
Figure 12-10 shows how this deck would appear on the screen of a browser 
with image support. 
r 
-~ :-~ :.c ~~~~-
I ~ 
~weather Forecast [ 
~~ 
Bou der Creek, CA 
~-. 
Hiqh 68 
..~ 
I' 
T.n 
'l4 
~ I 
Back 
Figure 12-10. WML card including a simple image 
245 

Chapter 12 
246 
Summary 
The WAP protocols are fast becoming the international standard for wireless con-
tent distribution to smart phones. Leveraging the best ofWeb technologies and 
carefully optimized for today's wireless networks, the WAP protocols have been 
adopted by major manufacturers including Nokia, Ericsson, and Motorola. 
WML is an XML-based markup language for content creation for WAP appli-
cations. Web servers make WML content available via WAP gateways, enabling 
existing content developers to provide WML content to wireless devices. WML 
bears a strong resemblance to HTML, but it includes facilities for dynamic con-
tent through the introduction of events, tasks, and variables. 
WML treats content as decks composed of cards. Within cards, tags are pro-
vided to format and style text, as well as accept user input. Users may interact 
with cards input elements or by activating interface elements that generate 
events. A deck can use an event to trigger a task, such as loading another deck or 
displaying another card. 
Users can make selections from lists and enter free-form text for submission 
to origin servers. These are performed using variables, which permit WML more 
flexibility than HTML can provide. Variables can be used anywhere text can, 
including within a card to be displayed to the user. 
Another feature not found in HTML is the ability to map interface elements 
to tasks, such as using a key to display a specific card or setting a timer to display 
a new card after some period of time has elapsed. WML defines events for com-
mon browser actions and allows the developer to link these events to tasks such 
as navigation or redrawing the screen. 
Of course, WML provides traditional markup tags as well so that content can 
be presented as paragraphs or tables. Although not all WML browsers support all 
markup tags, there are tags to present text as bold or italic, as well as draw simple 
monochrome images. 

CHAPTER 13 
Dynamic Content with 
WMLScript 
CHAPTER 12, "WIRELEss MARKuP LANGuAGE," discusses the Wrreless Markup Language 
(WML) for preparing screen phone content. 
WML is only half of the story ofWAP 1.0, however. The other half is 
WMLScript, a JavaScript-like scripting environment for calculations, data vali-
dation, and interactive development. In this chapter, I talk about whyWMLScript 
was created and show you how you can use it to develop dynamic content for 
wireless handsets. 
Purposes of WMLScript 
The Wrreless Application Protocol (WAP) Forum conceived WMLScript in parallel 
with WML. Together, these two technologies provide wireless access terminals with 
the ability to serve dynamic content to subscribers with a minimum of wireless 
interaction. 
Although typical Web applications rely heavily on the use of back-end server 
applications (or memory-hungry programming platforms such as Java and 
JavaScript), such an approach simply is not appropriate for wireless clients. 
A dependence on back-end sever solutions increases a subscriber's operating 
costs, and traditional scripting languages increase hardware costs because they 
need additional memory and horsepower from the Central Processing Unit 
(CPU) to operate. Despite its lightweight nature, WMLScript is powerful enough 
to perform such tasks as data validation, native access to platform-specific 
peripherals, and dynamic content generation. 
Data Validation 
Form posting to back-end servers is a significant source of traffic on the Web. 
Unfortunately, validating form submissions in the HyperText Markup Language 
(HTML) is difficult without JavaScript support, making form validation with wire-
less HTML Web browsers a hit-and-miss affair. With WMLScript, decks can 
247 

Chapter 13 
248 
perform robust input validation prior to submitting queries to origin servers. 
Arithmetic and string libraries available to scripts can be used to examine inputs, 
make corrections, and either submit a corrected request or prompt the user for 
corrected input. 
Native Peripheral Access 
The modular nature ofWMLScript enables platform vendors to make additional 
libraries available on individual devices. These libraries can contain device-
specific code that links WML interfaces to device functions-functions such as 
a calendar or address book or interfaces to hardware elements such as a location 
service, infrared port, or a wireless Bluetooth module. These libraries are limited 
only by cost constraints and the imagination of the device manufacturers. 
Dynamic Content Generation 
WMLScript can access variables in the WML browser, enabling scripts to create 
content on the fly. This content can be simple, such as a predefined rearrange-
ment of strings, or it can be a set of complex strings or arithmetic operations. 
Because these variables can be used in WMLScript with complex calculations, 
comparisons, and loops, costly network interactions can be avoided during the 
presentation of dynamic content. 
Exploring the Features of WMLScript 
Making the decision to use WMLScript is easy. If you are usingWML and want 
dynamic content, you should use it. EveryWML browser provides a WMLScript 
environment, and at least for the present, no other scripting solution is available 
for WML browsers. There are more features to WMLScript that you should be 
aware of, however, to help you understand what is possible in your content. 
Similarity to ECMAScript 
WMLScript was designed to resemble ECMAScript, the formalization of 
JavaScript, in many ways. Although WMLScript is not compatible with 

Dynamic Content with WMLScript 
ECMAScript or JavaScript, the syntax ofWMLScript is similar enough that most 
content developers can author WMLScript after only a little study. Moreover, 
automated tools can be easily retrofitted to enable developers to author and vali-
date WMLScript quickly, bringing development tools to market quickly. 
Procedural Logic 
WML provides simple dynamic behavior using events, tasks, and variable substi-
tution, but its actions are limited by its lack of procedural logic. WMLScript 
provides comparison and looping operators, giving content developers the abil-
ity to implement scripts that make decisions based on variables and act 
accordingly. 
Compact Binary Representation 
Gateway servers compile WMLScript into a compact binary representation that is 
both appropriate for wireless networks and efficient for wireless terminals to 
interpret. In the process of sending a WMLScript to a wireless terminal, the gate-
way both validates and encodes the script. The process of validation makes 
interpreting and executing the script on the wireless terminal simpler because 
common errors can be detected before they are sent to the wireless client. 
Creating a Simple WMLScript Application 
Although many smart phones or screen phones shipping today have integrated 
date books, calendars, and calculators, they are missing one feature: a Reverse 
Polish Notation (RPN} calculator. The followingWMLScript example (see 
Figure 13-1} rectifies this by showing how to create a simple two-register RPN 
(postfix} calculator. (See the sidebar "What Is Reverse Polish Notation?" for a brief 
explanation ofRPN.} 
249 

Chapter 13 
250 
Postfix 
Calculator 
~! 
y: 
x: 
•I 
3 . 1415 
!I 
OK 
a_pha 
..1 
~ - · 
Figure 13-1. A simple WMLScript application 
Postfix 
Calculator 
y: 
12 . 5600 0 
x: 
12 . 560 
0 
12 . 560000 
OK 
To begin, the deck invokes a WMLScript by indicating the name of a function 
and the Uniform Resource Locator (URL) of a script as the href attribute of a <go> 
navigation task. When a WMLScript is invoked, control is passed from the WAP 
browser to the WMLScript interpreter; the browser is effectively frozen during the 
script's execution. When the function invoked by the script's <go> task is com-
pleted, control returns to the browser. 
The WMLScript behind this example is stored in a hypothetical file called 
sl.wmls and looks strikingly like JavaScript or C (Listing 13-1). 
Listing 13-1. The RPN Calculator 
extern function calculate() { 
var x, y, op, result; 
II Retrieve arguments from WAP Context 
x = WMLBrowser .getVar( "x" ) ; 
y = WMLBrowser.getVar( "y" ); 
op = WMLBrowser.getVar( "op" ); 
II Validate arguments 
if ( x == invalid I I y == invalid I I 
ILang.isFloat(x) II ILang.isFloat(y) ) { 

} 
} 
Dialogs.alert("x andy must be numbers!"); 
I* Set better defaults for invalid registers *I 
if ( x == invalid I I llang.isFloat(x) ) { 
WMLBrowser.setVar( "x", "0" ); 
} 
if ( y == invalid I I llang.isFloat(y) ) { 
WMLBrowser.setVar( "y", "o" ); 
} 
Lang.exit(""); 
I* Convert registers to floating point numbers for our use *I 
x = Lang.parseFloat( x ); 
y = Lang.parseFloat( y ); 
I* Determine type of operation *I 
if ( op == "+" ) { 
result = y + x; 
} 
else if ( op == "-" ) { 
result = y - x; 
} 
else if ( op == "*" ) { 
result = y * x; 
} 
else if ( op == "/" ) { 
result = y I x; 
} 
else { 
} 
Dialogs.alert{"An invalid operation was chosen!"); 
WMLBrowser.setVar( "op", "+" ); 
Lang.exit(""); 
I* Clean up result for display *I 
result = String. fomat( "%10f", result ) ; 
I* Set registers to resulting value for next calculation *I 
WMLBrowser.setVar( "x", result ); 
WMLBrowser.setVar( "y", result ); 
I* Return the browser to the first page *I 
WMLBrowser.refresh{); 
Dynamic Content with WMLScript 
251 

Chapter 13 
252 
This example consists of a single function, calculate, which takes no argu-
ments. This function defines four variables, x, y, op, and result, to be used within 
the function itself. 
Unlike JavaScript or Java, WMLScript does not have access to the screen. 
Instead, WMLScript accesses the WML browser using a library called 
WMLBrowser. (A library is simply a set of functions grouped together by func-
tionality provided by the platform for all scripts to use). The WMLBrowser 
library's getVar and setVar functions enable WMLScript to get and set variables 
within the browser. In this example, WMLScript obtains the values ofx, y, and op 
from the WML browser this way. 
Once the values of x, y, and op are determined, the script validates x andy 
before proceeding. It examines the x andy variables to be sure they are valid 
floating-point numbers (if not, the script sets them to appropriate defaults and 
exits with an error message). Then, the script converts the x andy variables, origi-
nally strings, to floating-point numbers, and examines the op variable to determine 
which arithmetic operation to perform. (If an invalid operation is entered, unlikely 
though that might be, an error message is displayed, and control returns to the 
browser.) Once the script has performed the desired operation, it formats the results 
in a meaningful way for the user using the String library's format function. Then, 
the script stores the results in the WMLBrowser's x andy variables for the next cal-
culation. When this function exits, it returns control to the WAP browser, which 
displays the original card with the results of the calculation. 
The WML deck that uses this script is quite a bit shorter than the script itself 
(see Listing 13-2). 
Listing 13-2. The RPN Calculator User Interface 
<?xml version="1.0"?> 
<100CTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" 
"http://www.wapforum.org/DTD/wml_1.1.xml"> 
<wml> 
<card id="calc" title="Postfix Calculator" ordered="true"> 
<p> 
<big>Postfix Calculator</big> 
<lp> 
<p> 
<!-- Input elements for the x and y registers --> 
<1-- The first value is really in the y register, 'cuz x --> 
<1-- gets pushed into y by the implicit enter operation --> 

Dynamic Content with WMLScript 
<b>y: <lb>$y<br/> 
<b>x: <lb>$x<br/> 
<input name="y" type="text" value="O" emptyok="false"l><br/> 
<lp> 
<p><big>Postfix Calculator</big><lp> 
<p> 
<b>y: <lb>$y<br/> 
<b>x: <lb>$x<br/> 
<input name="x" type="text" value="O" emptyok="false"l><brl> 
<lp> 
<p> 
<1-- Picker to select operation to be performed --> 
<b>operation</b> 
<select title="Operation" name="op"> 
<option value="+" on pick=" sl. wmls#calculate() ">+</option> 
<option value="-" onpick="s1.wmls#calculate()">-</option> 
<option value="*" onpick="s1.wmls#calculate()">*</option> 
<option value="/" onpick="s1.wmls#calculate()">/</option> 
</select> 
<lp> 
</card> 
</wml> 
This deck is straightforward except for its invocation of the WMLScript 
calculate. 
A WML deck invokes a WMLScript using a URL that indicates both the source 
of the script and the WMLScript's entry point, a function name. (JavaScript devel-
opers take note: WMLScript scripts exist as entities apart from the content that 
uses them. You cannot put a WMLScript inside a WML document.) This deck uses 
the onpick attribute of the option selection tag to invoke the s1. wmls file's calculate 
function; as long as the script is stored in the location indicated by the URL given 
to the onpick event, control will be passed to this function. 
253 

Chapter 13 
254 
What Is Reverse Polish Notation? 
In the 1920s, the Polish mathematician Jan Lukasiewicz developed a formal 
logic system that allowed mathematical expressions to be specified without 
parentheses by placing operations symbols before (prefix notation) or after 
(postfix notation) the operands, rather than between them. For example, this 
traditional expression: 
(3+2)*5 
could be expressed in postfix notation like this: 
32+5* 
Prefix notation came to be known as Polish Notation in honor ofLukasiewicz; 
postfix notation was later known as Reverse Polish Notation (RPN). 
In the early years of portable calculators, computer scientists realized that 
RPN was efficient for computer math, as numbers could be pushed on a stack, 
and operations could pop arguments from the stack and push the results back 
on the stack. 
At the time that Hewlett-Packard introduced the HP-35 calculator, compet-
ing calculators could provide only partial interpretation of algebraic order. 
Hewlett-Packard wisely recognized that RPN would allow them to design a cal-
culator meeting their cost constraints that could evaluate any expression. For 
most users, learning this new notation was a small price to pay for the increased 
ability to manipulate expressions on an electronic calculator. 
Today, RPN persists because of the wide user base of Hewlett-Packard com-
puting products developed in the 70s, 80s, and 90s. Those familiar with RPN 
tend to see it as the "natural" way to use a calculator and can show that it is 
both faster and less error-prone to use than the traditional alternatives. 
Looking More Closely at WMLScript 
The WMLScript language is easily readable to those familiar with C, C++, Java, or 
JavaScript. This is by design; programmers will have little problems picking up 
WMLScript. 
The Basics 
Like many languages, WMLScript programs are built from fundamental building 
blocks called functions. Each function consists of a group of statements, each of 
which instructs the computer to perform a specific operation, such as allocating 
a variable, performing an arithmetic operation, making a comparison, or invok-
ing another function. Some functions may accept arguments, which are used 

Dynamic Content with WMLScript 
internally by the function in its computation. Functions always return a value. 
Those functions that do not return an explicit value will return an empty string. 
The WMLScript language is both compiled and interpreted. A WMLScript is 
compiled by a gateway server and provided in a compact medium to a WAP 
client, which in tum uses a simple virtual machine (called the WMLScript inter-
preter) to interpret the individual byte codes generated by the gateway's compiler. 
Each set of byte codes corresponds to an operation, variable, or similar primitive. 
Structure 
Within a function, statements determine the operation of the WMLScript inter-
preter. Statements are constructed from alphanumeric symbols and are 
delimited by a semicolon. You can use them to declare variables, perform assign-
ments to variables, perform operations or logical decisions, or invoke other 
functions. A statement may contain white spaces, such as carriage returns, 
spaces, or tabs, which are ignored by the scripting language. Statements are case-
sensitive; not only reserved words, but variable names, function names, and 
other expressions must maintain a consistent case. Thus, While is not the while 
procedural statement in WMLScript, and the variable identifiers phoneNumber and 
phonenumber are different variables. Statements may be grouped in blocks, using 
the { and } characters; the language uses these blocks to build conditional state-
ments, functions, and loops. 
Like most languages, WMLScript supports comments, which you use to leave 
information for later readers about the organization, use, or other features of 
a statement. WMLScript comments follow the same style as in C++: They are 
delimited by I* and* I. Single-line comments begin with I I and end with a new 
line. Comments cannot be nested, so be careful if you are using them to tempo-
rarily remove a bunch of code during testing. 
Some sample WMLScript statements are shown here: 
var x; 
//Declares the variable ~· 
x = x + 1; //Adds 1 to the value of x. 
x = Lang.random( 5 ); II Uses the Lang library random function to obtain 
II a number between o and s. 
Statements may contain literals-primitive values such as a number or 
string. WMLScript defines four primitive data types for its literals: integers, floats, 
strings, and booleans. 
Integers and floats will be familiar from high-school mathematics. An integer 
is a whole number that is less than, equal to, or greater than zero, such as -242, 
13, 0, or 6. It cannot contain a fraction. The valid range for integers in WMLScript 
is from -2147483648 to 2147483647. 
255 

Chapter 13 
256 
A float is a floating-point number-that is, any fractional number less than, 
equal to, or greater than zero, such as -15.0, 3.14, or 64432.155. A floating-point 
number in WMLScript cannot exceed -3.40282347X 1038 or 3.40282347X 1038; the 
smallest floating-point number that can be expressed is 1.17549435X 10·38• 
Floating-point numbers are traditionally written with a trailing decimal point if 
they are whole numbers, and integers are never written with decimal points 
(since they never have a fractional component). 
A stringis an aggregation of characters contained within single (') or double (") 
quotes, such as "hello world", "your name goes here", or "this page intention-
ally left blank". Some characters are not readily expressible in strings, such as 
the quote marks themselves. Table 13-1lists the special character sequences that 
you can use to generate characters otherwise reserved. 
Table 13-1. WMLScript Character Sequences and Characters 
SEQUENCE 
CHARACTER 
SYMBOL 
\' 
Apostrophe (single quote) 
\" 
Double quote 
\\ 
Back slash 
\ 
\1 
Forward slash 
I 
\t 
Horizontal tab 
\b 
Backspace 
\f 
Form feed 
\n 
Newline 
\r 
Carriage return 
\xhh 
The Latin-I 1808859-I character 
with the encoding specified by 
two hexadecimal digits hh 
\ooo 
The Latin-I 1808859-I character 
with the encoding specified by 
the three octal digits ooo 
\uhhhh 
The Unicode character with the 
encoding specified by the four 
hexadecimal digits hhhh 

Dynamic Content with WMLScript 
In addition to these literal types, WMLScript defines the special value 
invalid, which indicates, not surprisingly, an invalid result or condition. 
Functions may return invalid when no reasonable result can be achieved, and 
comparisons can be made against the primitive value invalid. 
The boolean type represents a condition that is either true or false. 1\vo val-
ues are possible for booleans-the reserved word true, or the reserved word 
false. Booleans are encountered when performing logical tests, such as deter-
mining whether two statements are equal. 
WMLScript uses identifiers to name and refer to three different elements 
within statements: variables, functions, and pragmas. An identifier is an alphanu-
meric string; it cannot begin with a digit, but it may begin with or contain an 
underscore. Some valid identifiers are as follows: 
• secret 
• timeOfDay 
• thx1138 
WMLScript reserves certain identifiers for use as statements within 
WMLScript. For example, the following identifiers are reserved and may not be 
used by scripts as identifiers: 
• if 
• for 
• return 
• while 
• invalid 
• true 
• false 
• var 
For a complete list of the reserved words, refer to the current version of the 
WMLScript specification. 
257 

Chapter 13 
258 
You can use the same identifier as a unique variable name and function 
name; thus, the variable foo and the function foo() can both exist in a script and 
would refer to two different things. 
Variables and Types 
Variables act as placeholders for intermediate results during a script or as the 
conveyors of values between one function and another. Variables must be 
defined before they are used. Inside a function, variables are defined using the 
var statement; arguments to functions are declared when a function is declared. 
When a variable is declared, its value is set to an empty string. 
Values are assigned to variables using the = operator. This operator may be 
used in the context of a var declaration (setting a new variable to an initial value) 
or as a statement. 
In the RPN calculator example shown in Listing 13-1, I defined the variables 
x, y, op, and result; I could have just as easily given them initial values at the 
same time, thusly: 
II Retrieve arguments from WAP Context 
var x = WMLBrowser .getVar( "x" ) ; 
var y = WMLBrowser.getVar( "y" ); 
var op = WMLBrowser.getVar( "op" ); 
A variable's scope is limited to the function in which it is declared. That is, it 
exists only from the time it is created until its containing function exits. Variables 
cannot be referenced outside the function in which they are created. 
Variables may be any of the literal types defined in the previous section. 
WMLScript is weakly typed, meaning that a variable has no notion of its type 
internally and may contain any of the literal data types. WMLScript attempts to 
convert between data types as needed, relieving the headaches caused by strongly 
typed languages. For example, if the following snippet were to be evaluated: 
var x = 2.0; 
var y = "3"; 
var res; 
var display; 
res = x * y; 
display = "res=" + res; 
then res would be the float 6.0, and display would be the string "res=6. o". 
Although this automatic type conversion is handy, it can cause mistakes; some 

Dynamic Content with WMLScript 
operators act on multiple types, and using them with statements of mixed types 
can catch you by surprise. For example, if the variable str is a string, and 
x is an integer, will the result of the statement result = str + x be a string or an 
integer? The answer is, a string-but only by careful reading of the WAP specifi-
cations or writing a test script are you likely to know this in advance. 
Operators 
At the heart ofWMLScript are operators for arithmetic operations, string com-
parisons, binary manipulations, and comparisons. 
In the previous example, the arithmetic operators+, -, I, and* perform basic 
arithmetic. WMLScript also defines the div operator, which performs integer 
division, and the % operator, which performs the modulus (remainder) operation. 
The order of operations is algebraic, with multiplication and division taking 
precedence over addition and subtraction. The + operator is also used for string 
concatenation (combining two strings). Whether a+ sign results in a string con-
catenation or a numeric depends on the exact expression and the combination of 
variables, as you will see shortly. 
Bitwise operators are also available for integers, but they will probably only 
be used by those writing scripts to interact with hardware. The operators < < and > 
perform bitwise left and right shifts respectively, preserving sign, and > > performs 
a bitwise shift right, filling new bits with 0. The&, I, and" operators perform bit-
wise AND, OR, and XOR operations, and they can be used to apply masks for 
manipulating flags or other purposes. 
Logical operators are available for working with the boolean values true and 
false. As in the C programming language and elsewhere, && corresponds to 
a boolean AND, and II corresponds to a boolean OR. The logical AND operator 
evaluates the first operand, and if the result is invalid or false, does not evaluate 
the second operand because false && true and false && false are both false. 
Similarly, the logical OR statement will not evaluate the second operand if the 
first operand is true because true II false and true II true are both true. This 
"short circuit" operation results in the more efficient execution of scripts. 
If any value in an operation is invalid, the result is invalid. 
The ! operator also performs the logical NOT operation, turning false to 
true and vice versa. Logical operations can be used in both assignments and pro-
cedural statements. For example, the following block: 
{ 
} 
var what!f = iAmHappy && youAreHappy; 
if ( whatlf ) { 
WMLBrowser.go{"#smile"): 
} 
259 

Chapter 13 
260 
is equivalent to the following: 
if ( iAmHappy && youAreHappy ) { 
WMLBrowser.go("#smile"); 
} 
Boolean operations are often combined with comparison operations. 
Comparison operations test for equality or inequality, and they return a boolean 
value. Six comparison operators exist: <, <=, ==, >=, >, and I=. The< and> oper-
ations should be familiar from grammar school math; they test whether the first 
operand is less than or greater than the second operand, respectively. The <= and 
>= perform similarly, except that the comparison returns true if the first operand 
is less than or equal to (greater than or equal to, in the case of>=). Finally, the== 
operand tests for equality, and the I = tests for inequality. 
Comparisons perform automatic type conversion. They follow these rules 
when encountering different types: 
• Ifthe operand types are boolean, true is greater than false. 
• If the operand types are integers, comparison is based on the given integer 
values. 
• If the operand types are floats, comparison is based on the given floating-
point values. 
• If the operand types are strings, comparison is based on the order of char-
acter codes of the given string values. (Character codes are defined by the 
character set supported by the WMLScript interpreter.) 
• If at least one of the operands is invalid, then the result of the comparison 
is invalid. 
This behavior is intuitive, especially if you have worked with other program-
ming languages. 
1\vo special operators that can be helpful in debugging also exist. The 
typeof operator returns an integer indicating the type of its operand, and the 
isvalid operator returns false only if its operand is invalid. The typeof operator 
performs no type conversion on its operand and returns one of the integers shown 
in Table 13-2. You can use the isvalid operation for error checking, as shown here: 
if ( isvalid ( x I y ) ) { 
res = x I y; 
} else { 

Dynamic Content with WMLScript 
II oh-oh. Let's handle that divide-by-zero error NOW. 
} 
Of course, the previous snippet could also be written like this: 
res = x I y 
If ( res 
== invalid ) { 
II oh-oh. Let's handle the divide-by-zero error here 
} 
Table 13-2. WMLScripttypeof Operator Results 
OPERAND TYPE 
VALUE RETURNED 
Integer 
0 
Float 
1 
String 
2 
Boolean 
3 
Invalid 
4 
WMLScript also provides several operators that combine an assignment with 
an operation, such as++,--,+=,-=,*=, and 1=. The++ and-- operators are famil-
iar to those with previous programming experience as the increment and 
decrement operators. You can use these either before or after a variable-indicat-
ing that the operation should occur before or after the variable is evaluated, 
respectively. Operators that consist of an operator followed immediately by= will 
apply the operation to the statement's right side and assign it to the left side. 
Thus, the following pairs of statements are equivalent: 
X *= 10; 
answer+= n pounds."; 
X = X * 10j 
answer= answer+" pounds."; 
261 

Chapter 13 
262 
Procedural Statements 
For a programming language to be truly useful, it must have procedural state-
ments that can alter the flow of a program. WMLScript follows the example of 
other structured languages and provides procedural statements for flow control 
and looping. 
The if-else series of statements defines a conditional flow control based on 
a comparison. The expression of the if statement is evaluated, and if true, the 
first block is evaluated; otherwise the optional else block is evaluated. For exam-
ple, the following expression sets x equal to 3.0: 
var val = o; 
var x; 
if ( val == 0 ) { 
X = 3.0j 
} else { 
X = -3.0 
} 
The ? : operation is similar to the if-else conditional, but it combines an 
assignment with the conditional behavior. If the expression before the? is true, 
the value of the expression between the ? and : is returned; otherwise, the value 
of the expression after the : is returned. You could rewrite the previous example 
as follows: 
var val = o; 
var x; 
x = val == o ? 3.0 : -3.0; 
The ? : operation is often used as shorthand in arithmetic operations. Use it 
sparingly; in complex expressions, it can become devilishly hard to read. 
You can cause the execution of a statement to loop a number of times using 
the while or for keywords. The while statement evaluates an exit expression and 
repeats a block of statements for as long as that expression is true: 
while ( expression ) { statements; } 
For example, you can express the algebraic factorial function, n I (the product 
of all positive integers less than n) using the while statement: 
function factorial( n ) 
{ 
var result = 1; 

Dynamic Content with WMLScript 
} 
if ( llang.islnt(n) ) { 
return invalid; 
} 
while ( n > 1 ) 
{ 
} 
result = result * n; 
n = n - 1; 
return result; 
The for statement provides a similar looping construct, along with conve-
nient placeholders for initialization and exit expressions, and a placeholder for 
managing a variable that tracks the status of the loop. You could rewrite the 
aforementioned factorial function this way using the for statement: 
function factorial( n ) 
{ 
} 
var result; 
if ( llang.islnt(n) ) { 
return invalid; 
} 
for ( result = 1; n > 1; n-- ) 
{ 
result = result * n; 
} 
return result; 
The for statement takes three expressions before the block of statements: an 
expression indicating initial conditions, the exit expression, and an update expres-
sion to be executed every time the statement block is executed. Programmatically, 
the following for statement: 
for( a; b; c) { s } 
is functionally equivalent to the following while statement: 
263 

Chapter 13 
264 
a· ' 
while( b ) { 
} 
s· ' 
c; 
Whether to use a while or a for statement is largely a matter of convention or 
taste. Traditionally, for statements are for straightforward iteration over one vari-
able, and while statements are for more complex looping constructs. 
You can use the break and continue constructs to exit a loop prematurely in 
the event that all the conditions for continuing a loop are met. The break state-
ment terminates the current while or for loop and continues the program 
execution from the statement following the terminated loop: 
var n = o; 
while( true ) 
{ 
} 
n++; 
if ( n == 100) { 
break; 
} 
II when we get here, n is 100 and the loop was run 101 times. 
It is an error to use a break statement outside a while or a for statement. 
The continue statement terminates the execution of a block of statements in 
a while or for loop and continues the loop with the next iteration. This is often 
used when one or two passes of the loop encounters an exceptional circum-
stance, but the loop should continue (hence the statement's name) anyway. The 
continue statement keeps control within the scope of the loop. In a while loop, 
control returns to the exit condition, and in a for loop, control returns to the 
update expression. 
Functions 
Functions enable script authors to organize statements into meaningful seg-
ments intended to perform a specific task; they are the fundamental 
organizational unit for applications. At least one function must be designated as 
the entry point for applications executingWMLScript from the W.AP browser. 
Functions are declared using the function statement. This statement speci-
fies the name of the function and any arguments it uses to accept input from its 
callers: 

Dynamic Content with WMLScript 
function func( arg1, arg2, arg3 ) 
{ 
} 
The arguments are used as variables within the function; they have scope 
only over the function where they are used. A function returns a value explicitly 
with the return statement or implicitly when the function exits. If no value is 
explicitly returned, an empty string is returned to the caller. The arguments and 
return value enable the caller of a function to provide initial information and 
obtain the results of a function. 
To call a function, a statement indicates the function name with its argu-
ments in parentheses: 
var n = factorial( 6 ); 
Function calls can be used as operands in a more complex expression: 
howmany = factorial( 6 ) I factorial ( 3 ); 
Functions called by other scripts, or from the WAP browser, must be declared 
as external functions, indicating that they should be made available to entities 
outside the current script The calculate script used in the RPN calculator exam-
ple illustrated in Listing 13-1 was such a function: 
extern function calculate() { • • • } 
Libraries 
Libraries are collections of related functions. The WAP standard provides several 
standard libraries that group together, respectively, functions for the management 
of the WML browser, language functions, string manipulation functions, and URL 
manipulation functions. Platform vendors can enhance a specific device by 
adding specific libraries for integration between WMLScript and the device. For 
example, you could add a library that provided voice access or provided access to 
the device's address book. 
Library functions are invoked by specifying the library's name, a dot {.), and 
then the desired function. You saw this in examples of how WMLScript accesses 
variables from the WAP browser: 
265 

Chapter 13 
266 
var x = WMlBrowser.getVar( "x" ); 
The WAP requires that the manufacturers of any devices that support 
WMLScript supply the following standard libraries (which are detailed in Tables 
13-3 through 13-8): 
• The Lang library provides functions comprising features ofWMLScript, 
such as type conversion operators, a random number generator, and func-
tions specifying the minimum and maximum values for integers. (See 
Table 13-3.) 
• The Float library provides functions for simple floating-point operations, 
including exponents and square roots. At the present time, trigonometric 
functions are not available from this library. (See Table 13-4.) 
• The String library provides a set of primitive string functions, including 
a string formatter and accessory functions for manipulating individual 
functions within a string. (See Table 13-5.) 
• The URL library provides routines for extracting the various parts of 
a URL, such as the host, protocol, and port. The URL library's functions are 
significantly easier to use for URL manipulations than crafting functions 
from the String library to do the same thing. (See Table 13-6.) 
• The Dialogs library provides a simple modal dialog interface to present 
messages to the user. (See Table 13-7 .) 
• The WMLBrowser library provides routines for accessing and controlling 
the WML browser on the device. (See Table 13-8 and the following section.) 

Dynamic Content with WMLScript 
Table 13-3. Functions in the WMLScript Lang Library 
FUNCTION 
ARGUMENTS 
RETURNS 
PURPOSE 
abort 
string 
Causes the interpretation of the current 
script to abort and returns control to 
the caller of the WMLScript interpreter 
with the given string used to describe 
the error 
abs 
number 
number 
Computes the absolute value of the 
or invalid 
given number 
characterSet 
string 
Returns an integer that denotes the 
character set supported by the 
WMLScript interpreter on the host 
platform 
exit 
value 
Causes the interpretation of the 
WMLScript to terminate and returns 
control to the caller of the WMLScript 
interpreter with the given value 
float 
boolean 
Returns true if the platform supports 
floating-point arithmetic, false 
otherwise 
isint 
string 
boolean 
Returns true if the string can be 
interpreted as an integer, false 
otherwise 
is Float 
string 
boolean 
Returns true if the string can be 
interpreted as a float, false otherwise 
min 
n1, n2 
number 
Computes the minimum of two given 
or invalid 
numbers 
minint 
number 
Returns the minimum integer value 
supported 
max 
n1,n2 
number 
Computes the maximum of two given 
or invalid 
numbers 
maxi nit 
integer 
Returns the minimum integer value 
supported 
parseint 
string 
integer 
Returns an integer interpretation of the 
or invalid 
string or invalid if the string cannot be 
interpreted as an integer 
(continued) 
267 

Chapter 13 
Table 13-3. Functions in the WMLScript Lang Library (continued) 
FUNCTION 
ARGUMENTS 
RETURNS 
PURPOSE 
parseFloat 
string 
float 
Returns a floating-point numeric 
or invalid 
interpretation of the string or invalid 
if the string cannot be interpreted as 
afloat 
random 
integer 
integer 
Returns a random integer between 0 
and the value passed or invalid if 
value is less than zero or not a number 
seed 
value 
string 
Initializes the random number 
sequence and returns an empty string 
Table 13-4. Functions in the WMLScript Float Library 
FUNCTION 
ARGUMENTS 
RETURNS 
PURPOSE 
ceil 
value 
number 
Returns the smallest integer value that 
is not less than the given value 
int 
value 
number 
Returns the integer part of the given 
value 
floor 
value 
number 
Returns the greatest integer value that 
is not greater than the given value 
max Float 
number 
Returns the maximum valid floating-
point number 
min Float 
number 
Returns the minimum valid floating-
point number 
pow 
value1, 
number 
Returns an implementation-dependent 
value2 
approximation of the result of 
computing valuel vaiue2 
round 
value 
number 
Returns the integer that is closest to the 
value of the given number 
sqrt 
value 
number 
Returns an implementation-dependent 
approximation of the square root of the 
given value 
268 

Dynamic Content with WMLScript 
Table 13-5. Functions in the WMLScript String Library 
FUNCTION 
ARGUMENTS 
RETURNS 
PURPOSE 
charAt 
string, 
string 
Returns a new string, one character 
index 
long, containing the character in string 
at the position specified by index 
compare 
stringl, 
integer 
Specifies the lexicographic relation of 
string2 
stringl to string2 based on the char-
acter codes of the native character set 
elements 
string,sep integer 
Returns the number of elements in 
or invalid 
string separated by sep 
elementAt 
string, 
string 
Returns the index'th element of string 
index,sep 
as separated by sep 
find 
string, sub 
value 
Returns the index of sub in string, or 
invalid 
format 
format, 
string 
Uses the printf-style format string 
value 
to format the given value and convert 
it to a string 
insertAt 
string, 
string 
Returns a new string where element 
element, 
has been inserted at the index'th 
index, 
element of string separated by sep 
separator 
is Empty 
string 
boolean 
Returns true if string length is zero, 
false otherwise 
length 
string 
number 
Returns the number of characters in 
string 
replace 
string, 
string 
Returns a new string resulting from 
old, new 
the replacement of all occurrences in 
string of old by new 
removeAt 
string, 
string 
Returns a new string where both the 
index,sep 
element and the corresponding given 
string, sep, that has the given index 
number, have been removed 
replaceAt 
string, 
string 
Returns a new string where the 
element, 
index'th element of string separated 
index, 
by sep has been replaced by element 
separator 
(continued) 
269 

Chapter 13 
Table 13-5. Functions in the WMLScript String Library (continued) 
FUNCTION 
ARGUMENTS 
RETURNS 
PURPOSE 
squeeze 
string 
string 
Returns a string where all consecutive 
white spaces in string are reduced to 
single spaces 
subString 
string, 
string 
Returns a new string that is the 
start, 
substring of the given string, beginning 
length 
at start and extending the number of 
characters indicated by length 
toString 
value 
string 
Returns a string representation of value 
trim 
string 
string 
Retuns a string where all leading and 
trailing white space has been removed 
Table 13-6. Functions in the WMLScript URL Library 
FUNCTION 
ARGUMENTS 
RETURNS 
PURPOSE 
escapeString 
string 
string 
Computes a new version of string 
where all characters are represented in 
a format suitable for use in URLs 
get Base 
string 
Returns an absolute URL of the current 
WMLScript compilation unit 
get Fragment 
url 
Returns the fragment used in url 
getHost 
url 
string 
Returns the host specified in url 
get Path 
url 
string 
Returns the path specified in url 
get Parameters 
url 
string 
Returns parameters in the last path 
segment of url 
get Port 
url 
string 
Returns the port number specified in ur 1 
getQuery 
url 
string 
Returns the query part specified in url 
getReferer 
string 
Returns the smallest URL relative to the 
base URL of the current compilation 
unit to the resource that called the 
current compilation unit 
getScheme 
url 
string 
Returns the protocol (scheme) in url 
(continued) 
270 

Dynamic Content with WMLScript 
Table 13-6. Functions in the WMLScript URL Library (continued) 
FUNCTION 
is Valid 
load String 
resolve 
ARGUMENTS 
url 
string, 
type 
base, 
embedded 
unescapeString string 
RETURNS 
boolean 
string, 
integer, 
or invalid 
string 
PURPoSE 
Returns true ifurl is a syntactically 
valid URL 
Returns the content denoted by the 
given absolute URL and the given 
content type 
Returns an absolute URL created from 
the given base and embedded URL 
strings 
Computes a new version of the given 
string where URL-suitable characters 
have been converted to their human-
readable counterparts 
Note: Relative URLs are not resolved in these functions. 
Table 13-7. Functions in the WMLScript Dialogs Library 
FUNCTION 
alert 
confirm 
prompt 
ARGUMENTS 
message 
RETURNS 
message, 
boolean 
ok,cancel 
message, 
default 
string 
PURPOSE 
Displays message and waits for user 
confirmation. 
Displays message and two reply 
alternatives. It waits for the user to 
select a reply and returns true if the 
user selected the alternative ok 
otherwise returns false. 
Displays message and prompts for user 
input with default as the default input. 
Returns the user input. 
271 

Chapter 13 
272 
Table 13-8. Functions in the WMLScript WMLBrowser Library 
FUNCTION 
ARGUMENTS 
RETURNS 
PURPOSE 
getVar 
var 
string 
Returns the value of the variable var in 
the browser 
go 
string 
string 
Specifies the URL to be loaded by the 
or invalid 
browser when the script terminates 
getCurrentCard 
string 
Returns the smallest relative URL 
(relative to the script) that specifies the 
card being displayed by the browser 
neWContext 
Clears all variables and the history of 
the browser 
prev 
string 
string 
Signals the browser to go to the 
or invalid 
previous card 
refresh 
Signals the browser to update its user 
interface based on the current context 
setVar 
var,value 
string 
Sets the value of the variable var in the 
browser 
WML Browser Integration 
The WMLBrowser library provides integration between the WMLScript inter-
preter and the WML browser present on a device. Although its semantics and use 
are the same as any other library, it is perhaps the most important of any of the 
WMLScript libraries-you will need it every time you write a script that interacts 
with a WML deck. Without it, scripts would be unaware of a WML deck's variables 
and could not interact with decks in any way. 
The WMLBrowser library provides several functions for controlling the WML 
browser application. The most frequently used are getVar and setVar. The 
WMLBrowser. getVar function takes a string identifying the variable of interest and 
returns a string containing the value of the WML variable. If the variable is not 
defined in the browser, the function returns invalid. The WMLBrowser. setVar 
function sets a variable within the WML context. It accepts two strings-the 
name of the variable and its value. It will return true if the value is correctly set or 
false otherwise. To succeed, the WML variable's name must be a valid WML vari-
able name consisting only of an underscore and alphanumeric characters. 
The WMLBrowser. go function interprets its argument as the URL for a card to 
be shown when control returns to the WML browser. Multiple calls to this 
function will result in only the last specified URL being visited; no URL will be 

Dynamic Content with WMLScript 
resolved if the argument's value is an empty string. The WML browser will not 
request the content specified by the URL until the WMLScript function exits and 
control returns to the WML browser. 
The WMLBrowser. prev function is similar to the go function, except that it uses 
the last visited URL from the history stack as the URL of the card to be shown. If 
both WMLBrowser. go and WMLBrowser. prev are called, the last -called function has 
precedence. Thus, in a the following script: 
WMlBrowser.go("http://wap.apress.com/"); 
WMlBrowser.prev() 
the WML browser performs the prev operation when control returns to the 
browser. On the other hand, in this sequence: 
WMlBrowser.go("http://wap.apress.com/"); 
WMlBrowser.prev() 
WMlBrowser.go(""); 
no navigation takes place because the last -specified action was a WMLBrowser. go 
without a URL. 
The WMLBrowser. refresh method is similar, but it does not actually request 
a new URL. Rather, this function causes the browser to re-evaluate the currently 
displayed card based on its current context and to redisplay the card. Unlike the 
WMLBrowser. go and WMLBrowser. prev functions, this function is performed imme-
diately, or, if the browser cannot redraw the current card while a script is being 
executed, invalid is returned and the refresh will be performed when the script 
exits. (Some devices may not have enough memory to support both the browser 
and the script environments at the same time. On these devices, the script inter-
preter simply sets a flag telling the browser to redraw the current card when the 
script execution completes.) 
The WMLBrowser. newContext function clears the browser's history stack and 
all variables. This is done without affecting any pending navigation requests, 
enabling the script to return the browser to a known state before returning con-
trol to the browser. 
The WMLBrowser. getCurrentCard function returns a string indicating the 
source of the currently displayed card relative to the current script's base URL; it 
273 

Chapter 13 
274 
returns invalid if no current card is displayed. An absolute URL will be returned 
if no relative URL can be calculated between a script's base URL and the current 
card's URL. Note that the URL returned will be the current card, not the URL of 
any pending navigation actions undertaken by the WMLBrowser. go or 
WMLBrowser. prev functions. 
Debugging Hints 
Debugging a WMLScript is a little like finding your way to the bathroom at night 
with the lights off. Those with careful housekeeping habits and a methodical 
nature are likely to make the trip unscathed; those in a hurry or sloppy will even-
tually make it but will bear the occasional bruise or frustrating experience. 
WMLScript development debugging is best performed using a simulator, 
such as the Software Developer Kits (SDKs) available from Openwave or Nokia. 
These simulators can greatly speed the rapid development cycle, enabling you to 
author and test content either on a single machine or over a high-speed local 
network prior to testing your application on real devices. 
However, if you are expecting a robust software development toolkit with 
a debugger, source code editor, and breakpoints, you will be in for a bit of a sur-
prise. Although these SDKs accurately simulate the behavior of a WAP browser 
and provide valuable error messages indicating problems with your content, you 
can perform little true debugging with them. These environments provide a rapid 
cut-and-try development cycle, rather than the precision of a true software 
development environment. 
Those who have previous experience with leading-edge (bleeding-edge?) 
platforms will recognize the time-tried techniques available to WMLScript 
authors. Foremost is the careful organization that should take place behind 
developingWMLScript content. Scripts should be developed iteratively and 
tested at regular intervals. Test functions can report values through variables dis-
played on test cards, and these cards kept in decks made available to developers 
and quality assurance staff. This scaffolding should be retained through the 
development process of an application, as it provides a valuable means for dis-
cerning the behavior of a complex script. 
As functionality is added to your scripts and decks, your application should 
be checkpointed somewhere. Those with software development experience will 
immediately recognize the need for change control, which enables a developer to 
"roll back" to a previous release in the event that something goes wrong. To do 
this, you may not need complex tools such as Microsoft's Visual SourceSafe. 
A careful methodology of regularly backing up working scripts and decks 
to a fresh directory (or to backup media such as CD-ROM, floppy, or tape) pro-
vides a convenient place to go when you find that something no longer works. 

Dynamic Content with WMLScript 
Inevitably, you will reach a point where something does not work as you 
expect. More often than not, this will occur while you are developing a script, 
although do not be surprised when you discover that a function you thought you 
had finished appears to be working differently than you recall, usually because of 
the way it interacts with other functions within a script. You can use the 
Dialogs. alert function to display a given string while a script is running. You can 
pass a variable's value as a string to this function, which will let you see its value 
while a WMI.Script function is running. For example, the following code uses 
a WML deck's debug variable to determine whether a given debug dialog box 
should be shown displaying the value of the variable x after computations: 
var debug=WMLBrowser.getVar("debug") == "true"; 
var x; 
I* some manipulations are performed on x */ 
if (debug) 
{ 
Dialogs.alert( "x=" + x ); 
} 
Using a WML variable to trigger debugging enables your debugging code to 
remain in scripts through production for rapid testing by simply altering a WML 
deck. Of course, the drawback is that the test code remains in your final product. 
This makes your scripts slightly larger and can reveal parts of the internals of 
your scripts to prying eyes. 
Alternatively, you can use a deck's variables for debugging. You can assign 
intermediate results (or information regarding a function's status, for that matter) 
to variables as your function executes. When it returns, you can use the go 
function to show a card with these variables evaluated to see what your function 
was doing. When you have debugged your function, you can remove this card 
with the debugging information and the code you used to assign values to the 
deck's variables. 
One powerful tool available to conventional developers is the assert macro, 
which verifies an assumption and presents an error if the condition is not met. 
WMLScript unfortunately lacks the equivalent of the assert macro, but there is 
no reason why a similar effect cannot be simulated, especially at a script's entry 
function between the WML browser and the WMLScript interpreter. 
275 

Chapter 13 
276 
The following example simulates an assertion using the initial verification of 
input values {the first conditional of the script), and calls abort if the function's 
invoked with invalid arguments: 
extern function doSomething() 
{ 
} 
var debug=WMLBrowser.getVar{"debug") 
"true"; 
var value=WMLBrowser.getVar("value"); 
I* verify input value */ 
if ( debug && Lang.parseFloat( value ) == invalid ) 
{ 
Lang.abort{"doSomething Error: value should be a float!"); 
} 
WMLBrowser.setVar("value"); 
WMLBrowser.refresh{); 
You should perform this defensive coding anywhere a mistaken value might 
cause your application to fail, and you should perform appropriately during 
those failures by gracefully recovering or reporting a meaningful error to the user. 
Consumers are strikingly tolerant of computer failures and notoriously intolerant 
of failures in an embedded device such as a screen phone. 
Finally, some simulator environments provide a console where messages can 
be logged. This simulator is accessed through a library such as Openwave's 
Console library, which enables strings to be printed to the console using the 
console. print Ln function. You can use functions such as this in conjunction with 
a debug variable to log important events in your script, such as in the following 
situations: 
• When a variable is initialized or assigned value 
• When your script code acts on the value of a variable 
• When your script interacts with the WMI..Browser library to load a new 
card or refresh the existing card 
Depending on the development environment you choose, a function such as 
console. printLn can be more useful than scattering various Dialogs. alert invo-
cations throughout your script. 

Dynamic Content with WMLScript 
Summary 
The WAP Forum has also defined WMLScript, a dynamic scripting environment 
for WAP browsers. WMLScript bears a strong resemblance to JavaScript, making it 
easy for developers to learn. Although WMLScript cannot directly interact with 
WML content in the browser display, its ability to interact with the WML 
browser's variables provides an interface between WML content and procedural 
scripts. These scripts can invoke libraries, perform arithmetic and string manipu-
lations, and return content to the WML browser in the form of variables to be 
displayed by the WML browser itself. 
WMLScript supports variables independent of the WML browser and can 
exchange variables with the browser. The variables within a WMLScript can be 
used to store strings, numbers, boolean values, and floats on platforms that sup-
port floating-point math. 
WMLScript provides basic operations, including arithmetic and boolean 
comparisons. You can use these to manipulate variables or construct conditional 
expressions, including looping. Loops can be written using both the for and 
while statements, resembling traditional programming languages such as C and 
C++. These in turn can be used to create functions, at least one of which is called 
from a WML deck. 
DebuggingWMLScript is challenging because many of the conventional 
debugging tools available on other platforms simply do not exist for WMLScript. 
However, by carefully organizing your code, you can write scripts that are easily 
tested. When you need to test a script, you can always save values in debugging 
variables that your WML deck can display, or use the Dialogs. alert function to 
display intermediate values within a long function. 
277 

CHAPTER 14 
Content Delivery 
THROUGHOUT THE PREVIous cHAPTERS, I have presented the wireless Web as a client-
server system for obtaining content. Clients-wireless terminals-make requests 
of servers over the wireless network, and servers deliver the content to the clients 
in return. 
Although this client-server relationship is by far the most common way to 
distribute content, two other means are growing increasingly popular. One, 
called push, lets Web servers send content through a gateway to handsets that 
support the Wrreless Application Protocol {WAP). Push technologies let service 
providers send real-time information such as breaking news or e-mail notifi-
cations directly to the handset. 
The other, synchronization, permits users to download and read Web sites 
while out of network coverage. Synchronization is especially useful for infor-
mation that changes less frequently than a user connects to the network, such as 
regular news or entertainment. 
Pushing Web Content 
Pushing Web content from your back end to handhelds lets you drive your con-
tent to your subscribers. Doing so permits a host of new applications, including 
field service, dispatches, up-to-the-minute finance and banking news, weather 
forecasts, and more. 
To date, only WAP supports a widespread standard architecture for pushing 
content, although the architecture and content considerations are generally the 
same as would be used for other standards. 
Understanding Push Architecture 
Figure 14-l shows the deployment of a hypothetical WAP network's push servers. 
In this diagram, there are four different hosts: 
• The Push Initiator {PI), your content server that is initiating the push to 
a wireless Web client 
279 

Chapter 14 
280 
• The Push Proxy Gateway (PPG), the server that accepts the push request 
from the PI and sends the push message to the wireless Web client 
• The Gateway, which handles requests from the Wrreless Web client, 
requesting content from the origin server in response to requests from the 
origin server 
• The wireless Web client, which accepts the push request and displays the 
response 
Push Initiator 
Push Proxy Gateway 
(Origin HTTP Server) 
TCP/IP 
TCP/IP 
Wireless 
Network 
Gateway Server 
Wireless 
Wireless Web Client 
Network 
Figure 14-1. A hypothetical deployment diagram for a network that supports 
WAPpush 
In the first step, the PI-one of your servers that needs to trigger the push 
request-requests that the PPG push a message to a handset using the Push 
Access Protocol (PAP). PAP, as you will see in the next section, is simply an XML 
document the PI sends to the PPG via H'ITP, directing the PPG to send a message 
to a specific handset requesting it to load a particular page. 
Once the PPG receives your PI's PAP message, it queues it for eventual deliv-
ery to the handset. The PPG processes PAP messages in a combination of arrival 
order, priority, and any scheduling it may see fit, so there is no guarantee that 
your message will arrive at the handset within a specific time interval. In turn, 
the PPG makes an over-the-air request using whatever carrier protocols are 
required to send your message to the wireless handset. 
Once the handset receives your request, it displays the message to the user or 
requests another page of content from your origin server via the gateway server 

as appropriate. The handset determines the appropriate course of action based 
on the message you originally sent to the PPG. 
Understanding Push Content 
Clearly, it is not appropriate to push all wireless Web content to the handset. 
Typically, only timely, up-to-the-minute data such as breaking financial news and 
e-mail alerts are of interest, although what content on your site you should push 
is of course determined by your subscribers. 
This decision can be a tricky issue because most wireless plans require hand-
set users to pay for the content they receive via push messages. Consequently, 
pushing your content to subscribers willy-nilly is not just obnoxious, but poten-
tially harmful to your viewers as they find your content has recklessly raised their 
wireless service costs. This is especially true of advertising, where you may be col-
lecting revenue from advertisers, and then forcing subscribers to pay for you to 
deliver your advertisements to them. For consumers, it is better to establish an 
opt-in model, where your subscribers have a say regarding the kind and amount 
of content pushed to their handset. Doing so leaves them in control of the overall 
cost of using your service. 
For vertical applications, such as dispatch or mobile sales applications, the 
cost of pushing content remains an issue, although only as one part of the appli-
cation's total cost of ownership. In these applications, it is not the user, but 
the administrator and managers who must determine the balance between the 
importance of receiving timely data and the cost to the organization of pushing 
the data across the wireless network. 
In general, then, what content you deliver via push must be worth more to 
the user-either a subscriber or business application user-than what they must 
pay to receive a message. On today's networks, a push message can cost as little 
as a penny or two, but may in fact cost as much as US$0.25 or more, making the 
relationship a difficult one to establish. 
Understanding Push Format 
Equally important is not just whatyou push, but in what format you push it to 
the handset. Handsets supportingWAP can accept pushed content of any MIME 
type, although typically you should push your content as either aXHTML Mobile 
Profile (XHTML-MP, described Chapter 11, "Wrreless Application Protocol") or 
a Wireless Markup Language {WML, described in Chapter 12, "Wireless Markup 
Language") document. By using one of these formats, you ensure that the hand-
set can display the content. 
Content Delivery 
281 

Chapter 14 
282 
Another option is to use PAP to push simply a service indicator or service load 
request, which asks the handset to load a specific URL. That way, once the hand-
set receives the push message and requests the indicated content, your origin 
server can examine the handset's capabilities through its HTI'P headers and 
deliver the appropriate response. 
Pushing with WAP 
Pushing content with WAP is surprisingly easy: Your content server must simply 
initiate a push request using PAP, an XM:L-based protocol that carries your push 
request over HTTP from your PI to the PPG. How exactly you create and initiate 
this request is a function of how you store your content; in many cases, you can 
generate PAP requests as completion scripts that originate in your database or as 
the output of scripts that regularly run on your PI. 
Let's take a look at a typical push request and response as well as how you 
can control the PPG and handset through PAP. 
Understanding the Push Request and Response 
As already mentioned, PAP is simply an XM:L application and follows the syntax 
rules described in Chapter 7, "eXtensible Markup Language." The general skele-
ton of a PAP request looks like this: 
<?xml version="l.O"?> 
<IDOCTYPE pap PUBLIC "-//WAPFORUM//DTD PAP 2.0//EN" 
"http://www.wapforum.org/DTD/pap_2.0.dtd"> 
<pap> 
<push-message push-id="26068S-987379411@lothlorien.com" 
ppg-notify-requested-to= 
"http://pi.lothlorien.com/push-notify.php"> 
<address address-value= 
"WAPPUSH=+011008885551234/TYPE=PLMN@ppg.provider.net" 
I> 
</push-message> 
</pap> 
The request begins with the traditional XM:L declaration, stating that the 
request adheres to version 1.0 of the XM:L standard and that the document itself 
is a PAP document adhering to the DTD found at 
www.wapforum.org/DTD/pap_2.0.dtd. 

The request itself is a single <pap> XML tag, containing one <push-message/> 
tags. Each tag provides a single message the PPG must push to the gateway, as 
described by the push-id attribute and <address> tag. The pus h-id is a unique 
identifier your PI can assign to each message to track its progress through the 
network, and the <address> tag contains the unique address of the device that 
receives the pushed content. This skeleton also includes the ppg-notify-
requested-to attribute of <push-message/>, which tells the PPG that it should 
submit PAP status messages to the indicated URL 
("http: I /pi.lothlorien.com/push-notify .php"). 
A second XML message containing the actual information to be pushed must 
accompany the PAP request. This is a simple request telling the handset to load 
a specific URL: 
<?xml version="l.O"?> 
<IDOCTYPE si PUBLIC "-//WAPFORUM//DTD SI 1.0//EN" 
"http://www.wapforum.org/DTD/si.dtd"> 
<si> 
<indication href="http://www.lothlorien.com/stom.html" 
action=" signal-high" 
si-id="26068S-987379412@pi.lothlorien.com"> 
Urgent storm warning! 
<!indication> 
<lsi> 
This message begins with the obligatory XML header and contains only 
a single tag, the <si> tag that instructs the handset to load the specified page. 
Within the <si> tag, the <indication> tag specifies both the URL the handset 
should load and how the handset should prompt the user. (I explore these and 
other message details in the next section.) Regardless, using the <sl> tag, the 
handset loads the pushed content only if the user requests the content after 
the push. 
The PI posts these files to the PPG using an HTTP POST request. In turn, the 
PPG provides a short XML document in response to inform the PI of the push sta-
tus. This is an example: 
<?xml version="l.O"?> 
<IDOCTYPE pap PUBLIC "-1/WAPFORUM//DTD PAP 2.0//EN" 
"http://www.wapforum.org/DTD/pap_2.0.dtd"> 
<pap> 
<push-response push-id="26068S-987379411@lothlorien.com"> 
<response-result code="1001" desc="Accepted for Processing/> 
</push-response> 
</pap> 
Content Delivery 
283 

Chapter 14 
284 
This document contains two tags: the <pap> tag identifying the document as 
containing a PAP message, and the push-response header, which returns the sta-
tus of the result using both a status code and textual description in the 
<response-result/> tag. The textual status results, returned in the desc attribute, 
are suitable for debugging or logging purposes, and you can use the code attri-
bute's content to control your scripts. 
Controlling the Push Mechanism 
PAP provides a number of tags and attributes that give you control over how your 
content is pushed to handsets. The key to this flexibility is the options available 
for the <push-message> tag and the <address/> tag. 
In addition to the attributes of <push-message> in the previous section, there 
are also the deliver-before-timestamp and deliver-after-timestamp attributes, 
which let you request that your content arrive at the handset before or after 
a specific time. The value of this attribute is a time in the form YYYY -ft'lt1-
DDThh: mm: ssZ, where the following is true: 
• YYYY is the four-digit year. 
• MM is the two-digit numeric month number {from 01 to 12). 
• DO is the two-digit numeric day number (from 01 to 31). 
• hh is the two-digit hour number denoting hours past midnight {from oo 
to 23). 
• mm is the two-digit number denoting minutes after the hour {from oo to 59). 
• ss is the two-digit number denoting number of seconds after the minute 
{from oo to 59). 
• T is the letter T. 
• Z is the letter Z. 
• - is a single hyphen. 
• : is a colon. 
All times are relative to Universal Coordinated Time. 

The <address> tag lets you specify device addresses in a number of ways, 
including by IP address, mobile number, or a user-specific identifier such as an 
e-mail address. You can include more than one <address> tag in the push request, 
indicating that the PPG should deliver the message to each of the addresses you 
indicate. For example, this is a PAP request that pushes to three addresses: 
<?xml version="l.O"?> 
<IDOCTYPE pap PUBLIC "-//WAPFORUM//DTD PAP 2.0//EN" 
"http://www.wapforum.org/DTD/pap_2.0.dtd"> 
<pap> 
<push-message push-id="26068S-987379411@lothlorien.com" 
ppg-notify-requested-to= 
"http://pi.mobilehelper.com/push-notify.php"> 
<address address-value= 
"WAPPUSH=+011008885551234/TYPE=PLMN@ppg.service.net"l> 
<address address-value= 
"WAPPUSH=kf6gpe@msg.service.net/TYPE=USER@ppg.mobilehelper.net"l> 
<address address-value= 
"WAPPUSH=10.0.1.1/TYPE=IPV4@ppg.mobilehelper.net"l> 
</push-message> 
</pap> 
The first <address/> tag uses the TYPE=PLMN specifier to indicate that the 
address +011008885551234 is a phone number, complete with international 
country code. Most of the time, this is what you use to push content because you 
can link users' preferences and their mobile numbers in your content sub-
scription database. 
The second <address/> tag uses the TYPE=USER specifier to indicate that the 
address is an e-mail address. The PPG will use e-mail to send the content to 
the device. It is unlikely you will want to do this most of the time because most 
handsets will not process pushed content by e-mail and send the results to the 
browser. 
The third <address/> tag uses a device's native Transmission Control 
Protocol/Internet Protocol (TCP/IP) address; both the older 1Pv4 and newer 1Pv6 
standards are supported. This address is an 1Pv4 address, as you can see from the 
TYPE field. 
Once you issue a request, you will want to track its progress. The PPG queues 
your content for later delivery, returning an XML document with a <push-
response/> tag containing a <response-resul tl> tag to let you know the initial 
results of the transaction. Table 14-1 summarizes the <response-resul tl> code val-
ues. You will also obtain this status information as part of the request the PPG makes 
of the PI using the ppg-notify-request-to attribute of the <push-request> tag. 
Content Delivery 
285 

Chapter 14 
Table 14-1. PAP Status Codes 
CODE 
DESCRIPTION 
LIKELY REASON 
1000 
OK 
1001 
Accepted for processing 
2000 
Bad request 
PAP message is not correct. 
2001 
Forbidden 
You do not have permission to make the request. 
2002 
Address Error 
The address is not correctly formatted. 
2003 
Address Not Found 
The address is wrong. 
2004 
push-id not found 
You did not include a pus h-id attribute with your 
message. 
2005 
Capabilities mismatch 
The client does not support the request in the 
message. 
2006 
Required capabilities 
The input is not in a form supported by the 
not supported 
client. 
2007 
Duplicate push-id 
The push-id in your message is already in use. 
3000 
Internal server error 
The server could not process the request. 
3001 
Not implemented 
The request is not supported by the server. 
3002 
Version not supported 
The version of the request is not supported by 
the server. 
3003 
Not possible 
The requested action is not possible because the 
message no longer exists. 
3004 
Capability matching 
The requested action is not supported by the 
not supported 
server and client. 
3005 
Multiple addresses 
The server can only deliver messages to one 
not supported 
client at a time. 
3006 
Transformation failure 
The server could not transcode the message for 
the client. 
3007 
Specified delivery 
The server could not deliver the message as 
method not possible 
requested. 
3008 
Capabilities not available 
Client capabilities for the specified client are not 
available. 
3009 
Required network 
The desired network is not available. 
not available 
(continued) 
286 

Table 14-1. PAP Status Codes (continued) 
CODE 
DESCRIPTIOI 
3010 
Required bearer 
not available 
4000 
Service failure 
4001 
Service busy 
5xxx 
Mobile client aborted 
LIKELY REASON 
The bearer network is not available. 
The service failed. 
The service is too busy to handle the request. 
The mobile client aborted reception of the 
message. 
PAP also includes the <statusquery-rnessage>and the <cancel-message> 
requests, which take as an attribute the push-id of the message you are interro-
gating or canceling. In return, the PPG returns a response containing a status 
code. Note that you can only get the status of a message or cancel its delivery 
while it is in transit to the wireless terminal; once it has been delivered, the PPG is 
free to destroy its record of the message. 
Most of the time, the content you push are XML documents containing the 
<si/> tag directing the handset to load content at a specific URL. A <si/> tag 
notifies subscribers that a particular service or URL is available and gives them 
an opportunity to load indicated content. It is similar to a service load message, 
in that it primes the smart phone to load a particular URL but does not actually 
load the URL unless the user chooses to do so. 
All <si> tags must include an <indication> tag that tells the browser what 
to load and how urgent the message is. Inside the <si> tag is an indication that 
the network wants to push content to the handset, which may be displayed to the 
handset user depending on the action attribute. This is an <si> document that 
contains an urgent load request. 
<?xml version="l.O"?> 
<IDOCTYPE si PUBLIC "-//WAPFORUM//DTD SI 1.0//EN" 
"http://www.wapforum.org/DTD/si.dtd"> 
<si> 
<indication href="http://www.lothlorien.com/storm.html" 
action=" signal-high" 
si-id="26068S-987379412@pi.lothlorien.com"> 
Urgent storm warning! 
</indication> 
<lsi> 
Content Delivery 
287 

Chapter 14 
288 
The action attribute tells the client what action to take to obtain your 
attention when receiving the indication. Five values of action are possible, with 
each value having an increasingly intrusive impact to the user interface: 
• "signal-none" indicates that no action should be taken. 
• "delete" indicates that pending indications with the same ID should be 
deleted. 
• "signal-low" indicates that the message should be silently saved for 
review. 
• "signal-medium" indicates that the client should display an alert regarding 
the content's arrival as soon as it can without interruption. 
• "signal-high" indicates that the client will immediately display the 
indication. 
The PPG uses the si _ id attribute of the <indication> tag when sending the 
message to the handset to determine whether the message has been previously 
sent. You should provide a unique ID for each unique message or ensure that 
your href attribute is unique so that the handset does not confuse different mes-
sages as one single message. 
When cost to the user is not a factor-such as in a vertical application-you 
can simply tell the handset to load the content directly using the < sl> tag, like this: 
<?xml version="l.O"?> 
< IDOCTYPE sl PUBLIC "-/ /WAPFORUM/ /DTD SL 1.0/ /EN" 
"http://WWN.wapforum.org/DTD/sl.dtd"> 
<sl href="href="http://WWN.lothlorien.com/storm.html" action="execute-high"/> 
You can also simply push a document directly to the handset, provided that 
the handset can display the kind of content you send. In general, unless you can 
track which addresses have which handset, or ensure that your users have only 
one kind of handset, it is better not to do this and use the <sl/> tag instead. By 
using the <sl/> tag, the handset will request the document you suggest via 
HyperText 'Ii'ansfer Protocol (HTTP), giving your origin server an opportunity to 
determine the device's capabilities by looking at the HTTP headers. (Of course, 
the <sll> tag incurs more network use because the handset must request the 
document, but this overhead is minimal on today's networks.) You can also use 
PAP to directly query a device's capabilities, but it is generally easy to manage 

client characteristics when you serve the content because you have to do it there 
for client-pulled content anyway. 
Synchronizing Web Content 
Synchronizing Web content is an ideal solution for content that does not change 
frequently or for content that changes less frequently than you are likely to syn-
chronize your device. In its simplest form, a synchronized browser simply takes 
a snapshot of a remote server's document, by traversing (or spidering, as some 
call it) all links from a predetermined page. Each document is stored-and the 
entire site can be viewed-in the synchronized browser from the browser's local 
store. links between documents are preserved; the user is essentially unable to 
tell whether the browser is loading content from the device's local storage or from 
the remote origin server. 
It is true that synchronized browsers do not simply copy content. Rather, 
they compare the local copy with the copy on the origin server so that the client 
only needs to download the material that has changed since the last synchro-
nization. In addition, more sophisticated synchronized browsers can perform 
simple compression and content optimization operations on content before 
transferring the content to the device, making it possible to browse a wider vari-
ety of content and store more material for offline viewing. 
Most of the constraints of the wireless Web apply equally to synchronized 
Web access, such as the following: 
• Client devices have limited presentation abilities (memory, sound, display, 
and userinput). 
• The connection pipe between device and Web is relatively slow (most 
devices synchronize at rates between 19.2kbps and 112kbps). 
• Users generally view the content in a variety of settings with less than their 
full attention paid to the device or its content. 
Synchronized access is generally available only to the users of handheld 
computers such as the Personal Digital Assistants (PDAs) or super phones 
described in Chapter 2, "The Wrreless Landscape." These devices sport the syn-
chronization technologies required for the process and are capable of running 
the powerful third-party applications needed to implement it, such as AvantGo 
(available for both MicrosoftWmdows CE and the Palm Powered platform) and 
Mazingo, as well as several open-source solutions including Plucker. 
AvantGo supports both connected and synchronized browsing, enabling 
users to access the Web wirelessly or refer to synchronized content. By contrast, 
Content Delivery 
289 

Chapter 14 
290 
other applications such as Mazingo and Plucker only let you view offline content. 
In the following sections, you will learn how to write content for AvantGo, but the 
concepts are essentially the same for Mazingo and other offline browsers. 
Understanding the Synchronization Architecture 
Synchronized browsers rely on the notion of a channel, which is a group of 
related pages. Users select a channel using their desktop Web browser from a Web 
portal, an individual Web site, or other Web source. The handheld platform's 
desktop synchronization interface-typically a technology such as the Palm 
Powered platform HotSync or Microsoft Wmdows CE ActiveSync-uses the infor-
mation in a channel in conjunction with a desktop-computer side application to 
synchronize Web pages between the channel's origin servers and the handheld 
device. At any time, the user can update the handheld's copy of the Web site by 
synchronizing his or her handheld device. During synchronization, the handheld 
device uses the desktop synchronization software to interrogate the servers of 
each channel and determine what pages of content have changed {or been added 
or deleted) since the last synchronization. Once a list of changes has been built, 
the handheld downloads the new or changed pages, and deletes pages no longer 
relevant to the channel. 
The user views the device-resident content using a special browser capable 
of presenting content from the synchronized database. This synchronized 
browser may or may not be capable of connected Web access or of storing form 
queries for retrieval during a subsequent synchronization. 
The format of a channel varies from browser to browser; some browsers use 
a HyperText Markup Language {HTML) file to represent a channel, and others 
use other formats, such as an eXtensible Markup Language {XML) document 
describing the channel. The simplest approach-used by AvantGo-is to use 
a given HTML page as a channel and define the channel's contents as all of the 
links from that given page out to a specific link depth. The channel consists of 
this page, all the pages referred to by the given page, and so on out to the link 
depth. 
Understanding the Synchronization Content 
What kind of content is appropriate for synchronized browsers? More than you 
might think. In fact, the technology behind synchronized browsers can solve 
problems not well managed by either wireless or wired Web access. 
Most users, if asked, will say they seek up-to-date information. But of course, 
what they mean by up-to-date is relative. Newspapers, for example, are consid-
ered an up-to-date form of information for many purposes, yet they are only 

available once or twice per day. Although the information users are seeking with 
their wireless Web devices does change, for many kinds of content the rate of 
change is less than the frequency with which most users synchronize their hand-
held devices-hourly or daily. News items obtained this way will be no more out 
of date than printed newspapers and very likely less. Directions to a destination 
are not generally subject to change on a daily or weekly basis (road hazards, on 
the other hand, may change often and thus are probably not a good fit of infor-
mation type for synchronized browsing). Weather reports are generally good for 
a day or so. A special-interest publication, such as a science journal or hobby 
magazine, is also a good fit, enabling users to convert small amounts of down 
time into relaxing leisure time as they catch up on personal interests using their 
portable devices. Especially if their devices can store relatively large amounts of 
content (up to a megabyte or so for some devices), many users find their pur-
poses satisfied by the "relatively up-to-date" content provided by synchronized 
Web browsers. 
Understanding the Synchronization Format 
Synchronized browsers are a specialized kind ofWeb browser, and they use Web 
protocols to read content. During synchronization, content is collected from ori-
gin servers on the Web using the HyperText 'Iransfer Protocol (H'ITP). That 
content is then marked up using HTML or stored as images in Graphical 
Interchange Format (GIF) or Joint Photographers Expert Group (JPEG) images. 
The synchronized browser displays content in HTML, along with GIF and JPEG 
images. Developers should keep the same concerns in mind when creating con-
tent for synchronized browsers as they do when developing for other mobile 
Web-based devices: relatively little memory, small screen size, and limited 
processor speed. 
Developing for AvantGo 
AvantGo's browser is the leading application for synchronizing Web content. 
Available for both Microsoft Windows CE and the Palm Powered platform, it is 
integrated with Pocket Internet Explorer on Wmdows CE and as a separate appli-
cation often bundled with Palm Powered devices. 
Understanding the AvantGo Technology 
Although AvantGo sells its back-end server as a software package for Fortune 
1000 companies, its also operates a server farm with the same software for 
Content Delivery 
291 

Chapter 14 
292 
consumers. Consumers may freely download and use the AvantGo client applica-
tion and synchronize content from these servers. In addition, AvantGo maintains 
a vast directory of third-party content, providing a portal for synchronized Web 
content. 
Because most readers will use this commercial service-and because 
licensees of AvantGo's enterprise products receive support from AvantGo-
1 focus primarily on developing for the AvantGo subscriber service in the follow-
ing discussion. (The concepts for deploying a synchronized Web site with the 
Fortune 1000 server product are largely similar.) 
There are three components in an AvantGo deployment scenario. The first 
component is the AvantGo server. This AvantGo server runs applications that 
manage the data delivered to the mobile devices. In addition, this server provides 
administration for users and groups, as well as hosting the Mobile Application 
Link server responsible for the actual data delivery. Developers need not concern 
themselves with the details of the system, however, unless they are creating aver-
tical application with a specific server-in which case they will need to 
understand the architecture of the AvantGo server, and will work directly with 
AvantGo for installation, configuration, and support of the server product. 
The second component of the AvantGo technology is the user's desktop com-
puter. AvantGo installs a synchronization module on the desktop. This module is 
used by the handheld platform's synchronization software to obtain Web pages 
and deliver them to the handheld device during synchronization. Users can also 
perform synchronization via a traditional modem or wireless networks, enabling 
mobile users to synchronize Web data when away from their desktop computers. 
The final component is the AvantGo browser. The browser obtains its infor-
mation-Web pages stored in a compressed form-from the client side of the 
Mobile Application Link. Using this application, users can view content, create 
forms for submission during the next synchronization, and perform administra-
tive functions such as the removal of channels from the device. 
Understanding the AvantGo Service 
The AvantGo service provides hundreds of channels for mobile consumers. 
AvantGo works with content providers to develop content for leisure, business, 
news, and other channels consumers find interesting. You can sign up for this 
service at AvantGo's Web site (www. avant go. com). There are no subscription fees-
use of AvantGo and the account are free-although accounts are required to store 
users' preferences and subscriptions. (AvantGo's business model presumably 
draws income from the sales of its Fortune 1000 server products and other activi-
ties, as well as custom channels delivering content to a large number of users.) 

At the AvantGo Web site, users can download the necessary applications, reg-
ister for an account, and manage their list of channels to create a portal of 
synchronized content for mobile subscribers. 
As a subscriber, you first select channels of interest on the AvantGo service 
site. Once you have done this, when you synchronize your mobile device, your 
desktop computer uses the Mobile Application Link to access your AvantGo.com 
account, retrieve the list of subscribed channels, and then download your chan-
nels' contents to your device. 
In addition to subscribing to channels, the AvantGo service enables users to 
designate a particular Uniform Resource Locator (URL) as a channel so that any 
Web site can be synchronized with their handheld devices. Although this 
approach is not appropriate for many sites, AvantGo's servers and client software 
do a tolerable job of reducing HTML targeted for a desktop so that the content is 
usable on mobile devices. 
Developing Content for the AvantGo Service 
Creating content for the AvantGo service is similar to creating wireless Web pages 
with HTML. You will want to spend a bit of extra time thinking about how your 
content is organized, but once you have done that, all you need to do is mark up 
your content and create a channel. 
Organizing Your Content 
AvantGo's channels treat content as a tree rooted on a central page. When syn-
chronizing, AvantGo begins at an indicated page and collects all pages referenced 
by it up to a specified link depth. The resulting snapshot of the Web site contains 
the index page and content to support all links from that page and subsequent 
pages out to a specific depth, as illustrated in Figure 14-2. 
Content Delivery 
293 

Chapter 14 
294 
news:Channel 
<llTifL> 
<IIEliih 
I 
I 
<TITLE>llll the Iews</TITLE> 
index.html 
<t!ETll llliHE="IIaDdbeldFrieDdly" COB'l'EM="true" > 
<IHEIID> 
<BODY> 
< Hl liLIGI=right > 
I 
I 
<II:I& SRC= "logo . gif" > 
logo.gif 
1111 The Iews 
</Hl> 
<P><I>llll The Iews <II>for 22 Iovember, 8 ~.<IP> 
I 
I 
<UL> 
story1 .him I 
<LI> 
Chicken Crosses Road; Experts ~ystified 
by lfotivation 
<ll HREF="storyl.html">Story<lil> 
I 
I 
<ILI> 
copyright. him I 
<LI> 
Ten Tbo11SaDdth Day of Good '1/"eather; 
I 
I 
!fore People Die of Boredom 
story2 .him I 
<il HREF="s:tory2.html">Story<lil> 
<ILI> 
<IUL> 
<P> 
I 
I 
<il HREF="copyright.html">Copyright<lil> 
fig1.gif 
<IP> 
</BODY> 
< /llTifL> 
I 
fig2.gif 
I 
title: All The Ne'w'S 
uri: 
http :1/"vMYI.aln .orglm o bil elin d ex.html 
depth: 3 
iiRages: 1 
links: 1 
Figure 14-2. A channel seen as an aggregation of documents (static view) 
This method of organizing content-as a tree rather than a web-is slightly 
different from what most developers have used. When creating content intended 
for use with AvantGo, it is important to recognize that any items that are more 
links away from your root page than the selected link depth will not be trans-
ferred to the device. Moreover, you have to be careful when linking your content 
to other sites; an inadvertent link can cause AvantGo to attempt to download 
whole sections of a Web site that may be only appropriate for desktop viewers. 
AvantGo content developers have the option of enabling the synchronization 
to either accept or avoid content from servers other than the one indicated in the 
root page. By choosing to avoid content from other servers, you can maintain 
greater control over what content is transferred to the device, ensuring it is suit-
able for presentation. 

Marking Up Your Content 
Most wireless-accessible Web sites are already marked up to suit AvantGo, which 
uses traditional HTML, GIF, and JPEG images. However, it does have some spe-
cific requirements. 
AvantGo will attempt to display any HTML, although it does best with simple 
HTML targeted at small devices. HTML intended primarily for AvantGo users can 
be marked with a <meta> tag unique to AvantGo. For example, the following tag 
instructs AvantGo to trust that the author of the HTML has used only markup 
supported by AvantGo and respected the memory constraints of the mobile 
devices that will be viewing the content: 
<META NAME="HandheldFriendly" CONTENT="true"> 
AvantGo operates on the assumption that any HTML not marked with this 
tag was initially targeted at desktop viewers and will make corrections designed 
to improve its appearance on handheld devices, such as omitting tables or trun-
cating documents. 
You can optimize your content for AvantGo in several ways. Keep document 
titles short, with the first several characters unique; AvantGo will clip the title to 
fit a small device's screen (even if the <meta> tag is used because some screens 
simply do not have the space for long titles). Use only monochrome images or no 
more than four shades of gray for the best display results on all devices. Make 
sure any tables are kept simple, with only a few rows and columns. Finally, 
remember that tables will only be displayed if your page uses the 
HandheldFriendly <meta>tag. 
Creating Channels 
If your desktop Web site offers a version that works as a channel for AvantGo, you 
will want to advertise this fact. Most such sites do this with a small image linking 
the user to a channel subscription, which AvantGo represents as a special URL 
pointing back to the subscriber's AvantGo account. 
Within this URL, AvantGo indicates the location of the AvantGo subscription 
server, along with the information describing your channel. This URL is actually 
an HTTP GET form object, with the following fields: title, url, max, depth, images, 
and links. The meaning of most of these fields is self-explanatory; for details, see 
Table 14-2. 
Content Delivery 
295 

Chapter14 
296 
Following is a sample channel subscription for the example shown in 
listing 14-1: 
http://avantgo.com/mydevice/autoadd.html?title=APRS/Find& 
url= http://www.lothlorien.com/WWD2ed/aprs/& 
max=25&depth=2&images=1&links=1 
Table 14-2. Fields Used to Define an AvantGo Channel 
FIELD 
title 
url 
max 
depth 
images 
links 
PURPOSE 
The channel title 
The URL of the channel's root docwnent 
The anticipated maximwn size (in kilobytes) 
The nwnber oflinks to traverse from the root when harvesting 
pages 
Set to "1" if the channel should include images 
Set to "1" if the channel should include docwnents from hosts 
other than the host serving the root 
Looking at an AvantGo Example 
Figure 14-3 shows an example of a site that lists locations of amateur radio 
stations. It uses AvantGo to display data collected from the APRServe server and 
the Automatic Position Reporting System (APRS) network. (See the "What Is 
APRS?" sidebar in Chapter 6, "Server-Side Content-Management Scripting," for 
information on the APRS network and APRServe server.) For now, you should 
assume the existence of a back-end server Common Gateway Interface (CGO 
script that returns a page detailing the position of a station when given its call 
sign. (I describe the construction of this back end in Chapter 6.) 

Figure 14-3. The example channel shown using AvantGo on a Palm Powered 
platform device 
The example channel will consist of three HTML pages: 
• The form that enables the user to enter a call sign (which is the root page) 
• An acknowledgment page crediting those who have contributed to the 
channel 
• A page with background information about amateur radio and APRS 
This organization is typical of most AvantGo channels: Static information 
such as credits, copyrights, and other information is included within the channel, 
and dynamic forms point to Web scripts elsewhere to obtain the information 
requested by the user. In many cases, if the channel is constructed to answer 
a specific question ("Where is that person?" "How do I get there?" "What is the 
value of my portfolio?"), then the form where this question is entered should be 
the root page for the channel. The content in this example channel is likely to 
be useful to viewers within the time between device synchronization with the 
Web site. Although some stations may move from place to place, many APRS sta-
tions operate from fixed locations such as homes, fire departments, or shelters 
during an emergency. 
In the example, entering a call sign and pressing Find queues a form sub-
mission for the next AvantGo synchronization (see Figure 14-3a). (Users with 
a modem or a direct network link can use AvantGo to obtain the information 
immediately.) After synchronizing, the user can use the AvantGo Forms Manager 
Content Delivery 
297 

Chapter 14 
298 
to view the result of the form transaction (Figures 14-3b and 14-3c) and see the 
resulting information. 
The HTML for the root page is straightforward (see Listing 14-1). 
Listing 14-1. The Opening Page of the APRServe Find Root Page 
<HTML> 
<HEAD> 
<TITLE>APRServe Find</TITLE> 
<META NAME="HandheldFriendly" CONTENT="true"> 
</HEAD> 
<BODY> 
<Hl ALIGN=right>APRServe Find</Hl> 
<CENTER> 
<HR> 
<FORM ACTION="http://www.lothlorien.com/cgi-bin/locate-station.php3" METHOD=POST> 
<P> 
Callsign: <INPUT TYPE=text NAME=CALLSIGN VALUE="" 
SIZE=10 MAXLENGTH=10><BR> 
Scale: 
<SELECT NAME=SCALE> 
<OPTION VALUE=50000>500 ft 
<OPTION VALUE=100000>1 mi 
<OPTION VALUE=200000>2 mi 
<OPTION VALUE=800000>5 mi 
<OPTION VALUE=3200000>50 mi 
</SELECT> 
<IP><P> 
<INPUT TYPE=hidden NAME=version VALUE=2> 
<INPUT TYPE=submit NAME=Submit VALUE="Find"> 
<IP> 
</FORM> 
<HR> 
<P> 
<A HREF="about.html">About</A><BR> 
<A HREF="credits.html">Credits</A> 
<IP> 
<HR> 
<P> 
© 1999-2002 Ray Rischpater, KF6GPE. Comments may be sent to the 
<A HREF="mailto:dove@lothlorien.com">author</A><BR> 
APRS is a registered trademark of APRS Software and Bob Bruninga, 
WB4APR. 

<IP></CENTER> 
</BOOY> 
</HTML> 
The only way this page differs from a standard Web page in HTML is the ini-
tial <meta> tag indicating it is handheld-friendly. It is a good habit to include this 
<meta> tag in all pages destined for AvantGo browsers, even those, like this one, 
that contain no elements that AvantGo would need to adapt. 
This root page points to three other Web pages: 
• The Web CGI responsible for handling form submissions 
• The page about. html containing information about the channel 
• The page credits. html containing information about APRS and amateur 
radio 
In tum, each of these pages points back to the main page. This is a snippet 
from the credits. html page: 
<HTML> 
<HEAD> 
<TITLE>APRServe Find</TITLE> 
<META NAME="HandheldFriendly" CONTENT="true"> 
</HEAD> 
<BODY> 
<H1 ALIGN=right>APRServe Credits</H1> 
<CENTER> 
<HR> 
<A HREF="avantgo-aprs-find-index.html">Find</A><BR> 
<A HREF="about.html">About</A><BR> 
<HR> 
</CENTER> 
<BODY> 
</HTML> 
The final component of this example is the channel subscription URL, which 
enables users to access their AvantGo subscription manager and subscribe to the 
channel with a single click on a hyperlink. The URL that specifies the channel is 
as follows: 
Content Delivery 
299 

Chapter 14 
300 
http://avantgo.com/mydevice/autoadd.html?title=APRS/Find& 
url=http://www.lothlorien.com/WWD2ed/aprs/& 
max=25&depth=2&images=l&links=1 
This indicates that the channel's root URL is 
http: I lwww .lothlorien. com/l>MD2ed/aprs/ and that its title is APRS/Find. The 
channel is expected to occupy no more than 25K on a user's device and is two 
links deep. Images and offsite links are allowed (to permit the display of the map 
data provided by the channel). 
There are two ways to create this URL. The easiest is to use AvantGo's Custom 
Channels link for subscribers and use the channel creation wizard. Once the 
channel is created, it can be exported as a URL. The more difficult-but faster-
method is to manually write the URL, being careful to include all the necessary 
fields. 
As illustrated in the example in listing 14-1, AvantGo requires little in the 
way of support from content developers. Creating an AvantGo channel is as easy 
as constructing some HTML that is appropriate for a mobile device, posting it to 
the Web, and creating a channel subscription URL to make subscribing easy for 
your viewers. 
When deciding to distribute your content, you must also bear in mind 
AvantGo's business model. Most content services-especially those with a large 
number of subscribers or those where you intend to make money-should be 
offered through the AvantGo Content Provider program. In turn, they will help 
you establish the channel's download parameters and give you a channel ID, 
making it easier to distribute your channel. More importantly, your relationship 
with the AvantGo Provider Program gives you the opportunity to participate in 
marketing and branding opportunities. 
Summary 
Although the traditional client -server relationship is ideal for most kinds of wire-
less Web applications, two other mechanisms to deliver content to wireless 
terminals have emerged in recent years. Both extend the client -server relation-
ship by letting you choose how to deliver content to your users. 
Using content push technologies in WAP, you can push urgent data such as 
dispatch information, instant messages, e-mail, and other content directly to 
subscriber terminals from your content servers. UsingWAP push, you can push 
the URL for a document and let your subscriber choose whether to load the page 
or push your content directly to the handset. 
On the other hand, synchronizing browsers provides a powerful alternative 
to wireless browsers for bringing information to handheld devices. Their use 

often overlaps with wireless access, as many kinds of information can be kept 
current via occasional synchronization with the Web. This synchronization 
enables users to have access to relatively up-to-date content without being bur-
dened with fees to access this information. Sites for synchronizing browsers are 
small, with a central index page providing links to the rest of the content. 
Content Delivery 
301 

CHAPTER 15 
Custom Applications: 
When a Browser Won't 
Work 
IN PREVIous CHAPTERS, rou LOOKED at three standard client technologies for deliver-
ing wireless Web content to users: standard Web pages, synchronized browsers, 
and screen phone markup languages. In almost every case, data can successfully 
be presented using one or more of these technologies. 
However, there are times where a custom wireless application is necessary. In 
this chapter, I discuss the few situations where choosing to develop such an 
application makes sense, and I also address some of the pitfalls you may 
encounter on the road to bringing a custom wireless application to market. 
Deciding to Roll Your Own 
Making the decision to write a custom wireless application is a difficult process. 
The development process is expensive-more expensive than most developers 
realize. Understanding why a custom application might be necessary, what 
the limitations are, and where the costs are likely to appear will help you make 
the choice between using an existing wireless Web application technology, such 
as HyperText Markup Language (HTML) or eXtensible HyperText Markup 
Language Mobile Profile (XHTM-MP), and writing a custom application. 
Motivations 
You can break down the market for wireless applications into two categories. The 
largest to date has been the vertical market, which consists of custom appli-
cations narrowly targeted (hence vertical) to meet the needs of customers in 
a specific enterprise, such as health care workers or salespeople who are always 
on the road. The second market, with significantly smaller numbers of appli-
cations, is the traditional consumer marketplace. Arguably, the wireless browsers 
themselves fall into this second category, although usually they are considered 
303 

Chapter 15 
304 
platform applications. In many cases, vendors leap to create new wireless appli-
cations before they realize using an existing wireless Web browser is sufficient for 
their purposes. 
There are many reasons why a custom application may appear to be more 
desirable than an existing wireless client technology, but most of those reasons 
boil down to a variation on one of these three: 
• A desire to create an interface with specific legacy systems 
• A desire to meet specific user interface (look and feel) needs, including 
corporate branding requirements 
• The technological limitations of existing wireless client technology 
In fact, only the last of these reasons is usually compelling enough to justify 
the cost of a custom wireless application. 
Legacy System Interfaces 
Most vertical applications require an interface to an existing data processing sys-
tem of some sort. Many of these systems predate the availability of wireless 
access by years and consequently may not make convenient hooks for even con-
ventional Web access, let alone for wireless Web access. Most are based on large 
back-end databases running on Structured Query Language (SQL) database 
servers from major manufacturers; many have custom front ends to facilitate 
data access and manipulation. 
In general, the amount of effort required to create a custom interface 
between these applications and a mobile client of any kind is comparable to the 
level of effort required to upgrade to a system with Web access and craft a 
wireless-accessible Web site. This process often involves upgrading a back-end 
database and wiring it to a Web application server-a common occurrence in 
today's intranets. There are costs associated with both options, of course, but 
upgrading generally provides users and operators with greater long-term flexibil-
ity than bolting a custom application onto an existing system. 
Of course, upgrading a vertical system and making it compatible with a stan-
dard wireless Web interface takes a significant amount of work; you must create 
a custom interface between the wireless Web and the legacy system, then cus-
tomize the content for wireless devices. But the techniques required are 
essentially only those needed for constructing a traditional Web application, with 
some extra attention paid to the content-whether it is HTML targeted for wire-
less devices, or Wireless Markup Language (WML), or XHTML-MP for wireless 
terminals. 

Custom Applications: When a Browser Won't Work 
Custom Interfaces and Branding 
Although significant enhancements have been made recently to the user inter-
faces of many wireless devices, there is always room for improvement. Efforts to 
bring about such improvements can lead enterprise customers or platform ven-
dors to develop applications that are specific to a particular wireless device (such 
as two-way messaging with a wireless mail client) or even, in some cases, to revo-
lutionary products (such as the Palm VII wireless handheld computing device 
from Palm). 
Another common goal, related to this drive to improve the interface, is to 
closely associate a brand identity with an application. This is especially common 
for applications whose end customers-platform manufacturers or the recipients 
of a custom application-seek to differentiate between their applications and 
existing, similar ones. 
However, neither of these motivations-a desire to improve the interface or 
branding-is, in most cases, justification for the development of a custom appli-
cation in a situation where an existing wireless Web application can do the job. 
The reason for this, though it may seem sadly mundane to those excited by tech-
nology, is a compelling one: cost. As I illustrate in the next section, the cost of 
developing a wireless application can be prohibitive. 
Most of the usual goals of a custom interface-such as input validation, pre-
sentation of information, and innovative input schemes (such as handwriting 
recognition or alternate keyboards)-can be met by an existing browser running 
on a target platform that accepts third-party additions. 
In the case of branding, the client usually seeks a series of subtle user inter-
face changes, such as redefined controls, logos in prominent locations, and the 
adoption of specific guidelines for the look and feel (fonts, layout, and so on) of 
the various screens of the application. For example, one commonly requested 
feature is the ability to validate specific kinds of content, such as phone numbers, 
within an input line. 
In almost every case, these requirements can be better met by tailoring con-
tent. Establishing a brand using content provides greater extensibility for the 
future and, most importantly, is almost infinitely easier than developing custom 
software to meet the same goals. 
Overcoming Technological Limitations 
The human drive to overcome limitations is what led to the development of wire-
less networking. If you are involved in developing a wireless application with the 
goal of overcoming one of the many existing technical limitations to wireless use 
(such as limited bandwidth or network roaming challenges), you are likely to be 
well aware of the difficulties of creating a new wireless application. The 
305 

Chapter 15 
306 
information in the remainder of this chapter may help you make some decisions 
as you go about developing your application, but you should probably start by 
considering the following basic question: Does your business model support the 
work you are setting out to do? 
For some developers, business models may not be an issue. Those working in 
academic settings or corporate research centers are able to work at the cutting 
edge of technology with, at most, only a cursory examination of the business 
prospects for a project. {This freedom to explore without needing an immedi-
ately apparent business return has been an essential element in the development 
of some innovations that have eventually led to soaring profitability, such as the 
cellular radio networks now spanning the globe.) However, if your organization is 
a more traditional business, you should be sure you can afford the relatively 
lengthy adoption period {probably measured in years, not months) necessary to 
build a large enough market share to recover initial investments. Many successful 
products in this sector have been created on the assumption that the first, or first 
few, iterations will be loss leaders, enabling developers to fine-tune the offering 
and incorporate customer feedback. 
Pitfalls 
The previous comments may well have dissuaded you from the desire to write 
a custom wireless application-and, in general, so they should. If you are still 
convinced that your purposes call for a custom treatment, however, read on. Your 
path may be fraught with danger. 
Wrreless application development is significantly more expensive than tradi-
tional development, for several reasons: 
• The tools and technologies behind wireless devices are less robust. 
• Wrreless applications are more complex. 
• The development cycle of a wireless application is longer. 
• There is a relatively low level of integration between wireless hardware 
and the handheld computers necessary to support wireless software 
development. 
Let's take a closer look at each of these challenges. 

Custom Applications: When a Browser Won't Work 
Fledgling Tools and Technologies 
Mobile device technology is young and evolving quickly. Working in a new field 
can make a developer's life exciting-and risky. 
At almost any juncture during the creation of an application, an unforeseen 
problem with the environment's tools or with the platform's documentation can 
cause costly delays. Any experienced developer knows this risk is part of the cost 
of doing business. But you should recognize that the level of risk is unusually 
high when you are developing for wireless devices because the tools used for 
wireless platforms are younger. They have significantly fewer years of constant 
improvement and debugging behind them than more robust tool chains such as 
GNU or Microsoft Developer Studio. 
Although many platform vendors have worked to mitigate these risks by bas-
ing their tool chains on existing environments {for example, Microsoft Wmdows 
CE relies heavily on Microsoft Developer Studio, and the development of the 
Palm OS was hosted on Metrowerks Code Warrior), the wireless developer is still in 
many ways on untested ground. In general, when developing a new application 
for the wireless Web, you can expect delays of between 10 and 20 percent of total 
development time to be spent dealing with tools, documentation, and bona fide 
platform bugs. 
The causes of these delays are usually impossible to pinpoint except in hind-
sight. However, training time on new platforms, mistakes on the part of 
application developers, and problems with the new tools and platforms them-
selves are all factors you should anticipate. 
Complexity 
Every wireless application consists of at least two applications: the client appli-
cation running on the wireless terminal and the back-end software providing 
content to the mobile device. Moreover, the software must communicate seam-
lessly across a wireless network, managing intermittent connections, signal 
strength fluctuations, and other issues with robust error handling in all con-
ditions. All parts of the system must interact flawlessly in this demanding 
environment. 
Consequently, wireless applications are more complex than traditional appli-
cations. Developers familiar with mobile development tend to underestimate 
this complexity, just as desktop developers with server-side experience tend to 
underestimate the risks of wireless terminal development. 
307 

Chapter 15 
308 
Development Cycle Length 
The development cycle for a wireless application is considerably longer than for 
a traditional application. The two factors discussed previously are part of the rea-
son why. Another important factor is the need for pilot releases. 
Developing a new application requires one or more pilot releases to test the 
application in the field. Pilot releases go one step further than beta tests, expos-
ing potential markets to an entire end-to-end service while enabling product and 
service developers to fine-tune the offering. Usually, this fine-tuning involves 
changes to both the client software and the back-end network. 
Pilot releases generally take calendar months of effort-besides the time 
required for the pilot program itself, significant lead time is needed to prepare for 
it. A successful pilot program may take more than a year to implement. Because 
most wireless applications require several such pilot releases before they are 
ready for a full-scale launch, this part of the development process adds signifi-
cantly to both the cost and the schedule. 
Lack of Integration 
In the current marketplace, few wireless terminals are tightly coupled with 
devices that can support third-party applications. For a given handheld comput-
ing platform with Software Development Kits (SDKs) available to the public, 
perhaps two or three devices exist that offer integrated wireless support, which is 
generally linked to only one or two major networks, each of which is available 
only in a single country. 
This situation is a key failing of the current state of wireless networking, and 
it creates several barriers to the adoption of new wireless applications. Most sig-
nificant is the burden of system integration-selecting a provider and a wireless 
terminal and connecting the wireless terminal to the handheld device-which 
often remains the responsibility of the end consumer. Although most wireless 
data users still belong to the "early adopter'' segment of the consumer popu-
lation, few are able and willing to shop for and select wireless access terminals, 
services, and applications to support wireless access. Therefore, integrated, "aU-
in-one" products such as the pdQ Smartphone from Kyocera, WML screen 
phones, and other products have typically outsold stand-alone "integration 
nightmares." 
Furthermore, the relatively small number of integrated products available 
makes it unlikely that custom applications for them will achieve widespread 
adoption across a global market. Applications targeted for Palm's Palm i705, for 
example, will only work in markets where the Palm i705 has wireless coverage. 
Currently, that means the United States, period. Writing software to a specific set 

Custom Applications: When a Browser Won't Work 
of platforms narrows your market, limiting your application to the level of 
adoption of the platforms on which it runs. 
Picking a Platform 
If, even after this discussion of the pitfalls of custom wireless development, you 
still feel you simply cannot make do with the existing wireless Web technology, 
your next step is to focus on selecting the best platform for hosting your wireless 
solution. This decision has three parts. You will need to choose all of the following: 
• A mobile computing platform 
• A wireless network 
• A server platform 
Handheld Platforms 
In the span of just a few years, your selection of target platforms has expanded 
from just the "big three" (Palm Computing Platform, Wmdows CE, and Symbian) 
to five major platforms: the Palm Computing Platform, Qualcomm Binary 
Runtime for Wireless (BREW), Wmdows CE, Symbian, and Java 2 Micro Edition 
(J2ME). Each of these platforms has been adopted by a number of hardware 
manufacturers, and several other platforms occupy significant niches, including 
Research In Motion's BlackBerry and various flavors of Linux. 
Some developers let a preference for a particular hardware vendor drive their 
selection of a platform for their applications; others pick a platform first and then 
select from the available hardware that runs it. Although the baseline features of 
a given platform are generally similar, hardware manufacturers have worked to 
differentiate themselves by adding features specific to their market expertise. 
The handheld computing marketplace is changing so rapidly that it is diffi-
cult to predict what hardware options will be available at the time you are 
reading this book. However, the platforms themselves change relatively slowly (in 
general, most vendors release a new version of a platform every year to 18 
months, and hardware manufacturers release as many as three or four devices 
annually, each with different features). I have therefore opted to provide an 
overview of the strengths and weaknesses of the major platforms, leaving you to 
research the details of what hardware is currently available. 
309 

Chapter 15 
310 
The Palm Computing Platform 
The Palm Computing Platform, from Palm, is the most widely adopted handheld 
operating system developed to date. The Zen of Palm, as the company calls its 
approach, involves providing simple applications that connect customers with 
their data. These devices are targeted at a variety of users, although white-collar 
workers spending time away from the office are the ones who have adopted them 
so far. 
Palm is arguably the simplest of the three platforms you are likely to 
encounter, as its creators emphasized low cost and ease of use. The environment 
provides networking support for Infrared Data Association (lrDA) and 
Transmission Control Protocol/Internet Protocol {TCP /IP) over the serial port 
to a modem or wireless modem, giving developers access to these facilities 
through a BSD socket-like interface. Application developers usually use Cor C++, 
although several other third-party environments are available. These support 
high-level forms-based languages. In addition, other languages like Forth, and 
simple Java runtimes are available and are used by a few developers. The leading 
environment is the one supported by Palm, based on the Metrowerks tool chain 
and availal;>le from Metrowerks or Palm. A version of the GNU tool chain has also 
been available to Palm developers for some time. 
To date, hardware licensees include Kyocera, which has a wireless device 
compatible with Code Division Multiple Access {CDMA) networks; Symbol, 
which offers local-area wireless devices for enterprise developers; Sony, which 
has several consumer devices available in Japan and the United States; and 
Handspring, which provides a low-cost-base handheld device that can be 
expanded with plug-in modules meeting their Springboard interface require-
ments as well as CDMA and Personal Communication Services {PCS) phone 
products. In addition, Palm's own Palm VII and Palm i705 provide a wide-area 
wireless interface in the form of a radio modem, although this modem is not 
directly accessible to developers. Rather, the Palm VII offers services to obtain 
data via HyperText Transfer Protocol {HTTP) through its Web Clipping technol-
ogy, using proxy servers stationed at Palm headquarters. 
The chief advantage to the Palm platform is its wide adoption. With more 
than five million users and a host of licensees to date, the Palm OS is virtually 
guaranteed continued success. Its relatively simple environment may feel primi-
tive to many desktop developers, but it has the advantage of being simple to 
learn. A second key advantage of the Palm platform is that it has one of the best 
software developer kits, available inexpensively to all developers. 

Custom Applications: When a Browser Won't Work 
Qualcomm Binary Runtime for Wireless 
Qualcomm's BREW is a collection of Application Programming Interfaces (APis) 
running on smart phones from manufacturers including Kyocera, Sharp, and LG. 
These interfaces give C and C++ programmers access to a portion of memory, the 
file system, and the screen in an event -driven programming environment. Like 
PalmOS, you develop applications on the desktop, testing them first on the desk-
top in an emulator and then recompiling them and running them on the wireless 
terminal. 
Unlike other platform vendors to date, BREW provides a secure environment 
where users can download, evaluate, and purchase applications for their wireless 
terminals. This system includes direct billing to subscribers' wireless service bills, 
so you can distribute to your customers and receive payment for your appli-
cations through the network's billing system rather than needing to establish 
your own. Of course, you share the revenue from your subscribers with the net-
work for this service, but it is much cheaper than establishing an end-to-end 
sales, registration, and subscription mechanism for most applications. 
Microsoft Windows CE 
Microsoft Wmdows CE has been Microsoft's most successful foray into the hand-
held computing market to date. Available in a wide variety of form factors, from 
subnotebook to palm-sized, products runningWmdows CE offer an alternative to 
computers, laptops, and handheld computers as well. 
The Windows CE programming environment will be familiar to any seasoned 
Windows developer, as its APis are derived from existing Wm32 APis. However, 
the operating system was built from the ground up for portable and mobile 
devices and has been streamlined to run on relatively low-cost hardware appro-
priate for the handheld consumer and vertical markets. 
Microsoft's history in this market has been spotty at best. It came late to the 
table, after several successful products were already available from Symbian (for-
merly Psion) and Palm. Devices runningWmdows CE have been slow to sell, and 
many hardware manufacturers have already retreated from the Wmdows CE mar-
ket after offering initial devices. However, Microsoft's ongoing commitment to 
the marketplace and its unparalleled ability to invest leave little doubt that it will 
remain an important player in handheld computing for years to come. 
Not surprisingly, the tool chain for Windows CE is based on Microsoft's 
Developer Studio, which enables developers to develop inC and C++ for the plat-
form. For a time, Microsoft pledged support for Java, although as of this writing 
the battles between Sun Microsystems and Microsoft make a Java tool chain from 
Microsoft unlikely in the near future. 
311 

ChapterlS 
312 
Java 2 Micro Edition 
Developed by Sun Microsystems, backed by dozens of vendors and deployed on 
both Sprint and Nextel's wireless networks, J2ME offers many of the same bene-
fits ofQualcornm's BREW with cross-platform compatibility. 
J2ME handsets-typically priced at the upper end of consumer handsets-
run a lightweight version of the Java Virtual Machine (JVM) called the KVM and 
include a handful of Java classes suited for small wireless applications. With the 
J2ME, you can write smart client applications that use the network, including 
vertical applications and games. There is one catch, however. 
The classes included with J2ME that are available on the handset are a strict 
subset of other editions of Java. You cannot simply port your Java code from 
another platform to J2ME; in fact, you may be better off considering a rewrite. 
The limitations handsets and handset interfaces suffer (which I review through-
out this book) make it impossible for J2ME to offer the Swing or AWT user 
interface and make it equally difficult for your application to be usable without 
significant changes. Consequently, you should be careful to separate your appli-
cation's business logic from the user interface. This is true even if you are only 
developing applications for different mobile devices because the user interface 
between mobile devices-say, a consumer phone running J2ME and a high-end 
wireless Personal Digital Assistant (PDA) with a touch screen running J2ME-can 
be very different. 
Symbion 
Symbian is a new name for an old player in the mobile hardware space: Psion. As 
a world leader in handheld computing, Psion has successfully worked to repo-
sition itself as a leader in the wireless data marketplace, providing platform 
technology to hardware manufacturers. Its chief offering, the Symbian platform, 
is being embraced by a number of manufacturers worldwide. 
Although its adoption has been relatively slow in the United States, the 
Symbian platform has been known worldwide for some time. It is also the only 
mobile device with a practical Java implementation; developers can choose 
either native EPOC development or the use of networked applications in Java. 
Wrreless hardware using the Symbian platform has been slow to appear. At 
present, most users ofSymbian devices have third-partywireless handsets or 
expansion cards, rather than integrated devices. Doubtlessly, this will change 
over the next year as current licensees develop and market their products. 

Custom Applications: When a Browser Won't Work 
Traditional Desktop Systems 
Throughout this book, I have mostly disregarded the traditional desktop plat-
forms {Wmdows, llnux and other Unix variants, and the Mac OS) that are 
available on portable devices such as laptops or slates. In general, these devices 
offer near-desktop computing capacity, and the only limitation they are subject 
to regarding the wireless Web is the bandwidth of the wireless connection itself. 
These devices represent the smallest consumer base for wireless access as 
well; few consumers are likely to tote a laptop computer for purposes that could 
be achieved with a handheld device. However, these devices do provide opportu-
nities for wireless application development, and they enjoy a strong following in 
some vertical markets, such as outside plant management, where both the need 
for and the ability to pay the costs of custom wireless applications exist. These 
applications can provide, for example, specialized access to corporate databases, 
records, and computational resources. 
Before initiating the development of an application for one of these plat-
forms, however, consider carefully whether the Web might in fact be the best 
option. The sophistication of desktop Web browsers can be leveraged with local 
content and scripts to provide a robust environment for users; only in rare cir-
cumstances is there actually a need for a custom application. 
Only a specialized application-say, one that needed to interface with 
portable test equipment or facility monitoring equipment-would require sup-
port a Web browser could not provide. In such a case, it might be appropriate to 
write a custom application or create a custom component to be used by a laptop 
browser using ActiveX or another technology. 
Wireless Networks 
Selecting the right wireless network over which to deploy your new application is 
as important as choosing the development platform. In Chapter 2, "The Wrreless 
Landscape," I reviewed the major nationwide domestic networks, many of which 
are undergoing regular expansions and upgrades. In addition, the third gener-
ation of wireless networks will soon be up and running, increasing the 
alternatives available. 
The choice of wireless network is driven by several factors: 
• Coverage 
• Integration with the mobile client 
• Integration with the content servers hosting target content 
313 

Chapter15 
314 
Availability of developer support and business relationships remains a pri-
mary concern for all wireless applications. If mobile users cannot access 
application services at critical times, the business purposes that drove the devel-
opment of the application are defeated. 
Domestic developers must grapple with this problem every time they set out. 
Currently, no single network provides truly ubiquitous coverage across the 
United States. Two-way networks such as Bell South Wrreless Data cover more 
than 90 percent of the domestic business population, but if your user base is in 
the remaining 10 percent, even that is simply not good enough. These numbers 
are for coverage of major commercial and industrial districts, where custom wire-
less applications are most likely to be used. Residential areas, especially rural 
ones, are likely to have even poorer coverage. 
Determining whether a specific network provides the coverage needed for 
a particular application involves a combination of research and site surveys. 
Some simple research is the starting point. Basic information regarding 
a network's coverage is often available directly from the service provider, usually 
as maps of areas covered or as lists of Major Metropolitan Areas (MMAs) included 
in coverage. This information provides a general idea as to whether the network 
even approaches the coverage desired. 
Typically, the information obtained from service providers is insufficient to 
determine whether coverage will in fact be adequate for an actual application. 
Site surveys are often necessary to evaluate coverage more thoroughly. A site sur-
vey involves visiting a sample of the physical locations where the application will 
be used and testing the actual coverage available at those locations. In some 
cases an informal survey is all that is needed-the results might consist of a list of 
locations-usually stated as both street addresses and Global Positioning System 
(GPS) locations to make analysis of them easier-along with signal strength mea-
surements and logs of successful and failed communications from each one. 
A more serious survey would include multiple measurements at each location 
taken over a period of days or weeks to account for factors such as network load, 
radio propagation, and nearby sources of interference. 
If you are developing an application that requires high reliability, it is essen-
tial to perform at least a few site surveys. In general, the information provided by 
service providers relates to average network availability as determined by a theo-
retical model of coverage. But the great number of variables that can affect 
wireless networks, such as signal reflections, noise sources, varying usage, the 
impact of weather on signal propagation, and a host of other factors, make it nec-
essary to take direct measurements if you want to be sure of service availability in 
a specific area. 
In addition to coverage, you must also consider such factors as throughput 
and latency when evaluating a network's ability to successfully deliver your wire-
less application. If a network does not reliably provide timely access to 
information, the application will be unable to meet users' needs. 

Custom Applications: When a Browser Won't Work 
Client Integration 
Integration with the mobile client hardware is another important factor to con-
sider when selecting a wireless network. Your coverage analysis may determine, 
for example, that a lxRTT network such as that offered by AT&T is more than 
adequate for your application, but what if the hardware the client plans to use 
does not provide an easy physical or software interface to the network in 
question? Fortunately, this is problem can be solved for most combinations of 
network and hardware. 
A wide variety of PC Cards provide access to almost every wide area wireless 
network to mobile devices with PC Card slots. Even some devices that lack native 
PC Card interfaces can be refitted with aftermarket adapters offering PC Card 
support. Over time, this family of wireless PC Cards will likely be augmented by 
CompactFlash cards, increasing the available options for wireless connectivity. 
Finally, some wireless adapters are available as a snap-on cradle, which provides 
wireless connectivity at the expense of slight additional bulk. 
These two-component solutions (mobile client with an add -on card or snap-
on module) are not without their drawbacks, however. Requiring consumers to 
obtain an additional component shrinks the size of the consumer market consid-
erably. In the vertical market, inventory problems can arise as devices become 
separated from their wireless modules and units are damaged or lost. 
Furthermore, nearly all mobile devices are taxed by the power a wireless access 
unit draws, and some subsystems require additional sources of power. 
Bluetooth, a personal area wireless network standard, may help address this 
problem. Developed to provide wireless access between devices at very short 
range, one use of Bluetooth is to let your handheld computer use your handset 
forWWAN service. 
Because of the added cost and complexity-even with Bluetooth-many 
users prefer the idea of working with an integrated device. '!YPically thi8 means 
a super phone, although some PDAs with integral wireless access, such as the 
Palm i705, exist. They generally offer a wireless access unit within the case of the 
mobile computer and are explicitly designed with integration in mind. However, 
these integrated devices do not support all networks, so the needs of network 
coverage and cost must be balanced against the desire to use an integrated 
mobile device. Clearly, selecting a handheld device and choosing a network are 
issues closely related. 
The development of a large-scale application often involves trials with sev-
eral combinations of hardware and network during the early concept phases as 
platform capabilities, network coverage, and available network adapter configu-
rations are evaluated. 
315 

Chapter 15 
316 
Server Integration 
A major advantage of wireless Web applications is the simplicity of integrating 
wireless access terminals and content servers. This simple, generally seamless 
integration has been achieved as a result of substantial time and effort invest-
ments on the part of network operators who realized that establishing good 
gateways between their wireless networks and the Internet was a key to wide 
adoption. 
Unfortunately, anyone developing a wireless application from scratch must 
do much of this integration work anew. Most wireless networks use proprietary 
protocols tuned to the characteristics of the network itself, and creating an inter-
face between the wireless network and these protocols is a significant task. These 
interfaces are often multihop, connecting server farms at the network operator 
with the wireless application host servers across a leased line-or, more recently, 
across Internet connections tunneling the wireless protocol. 
Some companies have produced wireless middleware solutions, which miti-
gate much of the difficulty involved in integrating content servers with wireless 
network providers. This is a new and growing market involving mostly small 
companies, so developers should exercise some care when selecting a middle-
ware solution. When evaluating a solution, remember to consider the following 
factors: 
• Longevity of the vendor: How long will the provider be able to support 
a deployed solution? 
• Previous solutions to simllar problems: As with any technology acqui-
sition, the experience of previous users can answer a lot of questions about 
the stability of a solution. 
• Supported platforms and networks: Many middleware solutions provide 
network-independent services on both server and mobile client, but a par-
ticular option may not support the network you need. 
Developer Support 
The level of network support available to third-party developers can be a crucial 
factor in the success or failure of creating a new wireless application. Few devel-
opers consider this aspect of selecting a network. This is unfortunate, because 
a provider's developer support staff can provide unique insight into how an 
application might best run on their network and promote a deeper understand-
ing of the wireless network's operation, capabilities, and limitations. 

Custom Applications: When a Browser Won't Work 
In addition to special pricing on products and services, most developer sup-
port organizations provide not only documentation but also e-mail or phone 
support, and some actually offer face-to-face consultations and reviews. Of 
course, these benefits are not without cost, but the upfront costs of a good 
developer support organization can more than offset the long-term costs of 
going it alone. 
Server Platform 
The selection of the server platform is often the most straightforward decision to 
make when preparing to develop a wireless application. Not only are there fewer 
options, all of them well understood, but in general, the wireless application will 
be interfacing with existing sources of data, which dictate the server platform 
and leave little choice for the developer in many cases. 
Therefore, the questions to consider when choosing a server platform are rel-
atively straightforward: 
• Will the platform have the longevity necessary to support the commercial 
rollout of your product or service? (That is, will your platform vendor be 
around to support you when you have both users and questions?) 
• Will the platform offer the scalability necessary to support anticipated pro-
duction loads of your application? (It may be easy to manage server load 
when your developer staff is using the single server you have installed, but 
what about when you have 30,000 users?) 
• Will the platform support the tools you plan to use during development of 
the application? 
In general, any of the leading platforms-such as linux, other Unix variants 
such as BSD or Sun Microsystems' Solaris, or Microsoft Wmdows 2000-are good 
choices for most purposes. 
Summary 
There is little need to develop a custom wireless application for all but a few 
cases. The power of wireless Web browsers, coupled with the ease of developing 
content for the wireless Web, make custom applications a costly choice by com-
parison. 
It is unlikely you will want-or need-to tackle this challenge. Although the 
opportunity may sound exciting, few development organizations have the 
317 

Chapter 15 
318 
necessary expertise and resources. The early-stage nature of the available tools, 
the complexity of the task, and the need for multiple communicating applica-
tions (after all every client application has a server someplace it will need to talk 
to!) all conspire to make custom wireless application development an expensive 
proposition. 
For the few with the need and the means to create a wireless application 
from scratch, the choice of platforms, networks, and hardware is a complex pro-
cess, as each selection affects the others. Be sure to look over all of the available 
options; you will likely spend time exploring several before you find a match of 
hardware platform, form factor, and wireless network that meets your needs. 

APPENDIX A 
Resources for Wireless 
Web Developers 
THE FACE oF THE WIRELESS Web is changing so quickly that a book such as this can-
not keep up. By the time this reaches your hands, it is likely that a host of 
new tools for wireless Web development will be available. Moreover, there are 
more tools currently available than can be used in a work such as this. 
Throughout the production of this book, I have used tools with which I have 
had prior experience; these are tools I recommend to friends or colleagues set-
ting out to create their own wireless Web sites. 
In this appendix, I provide pointers to information on these and other 
emerging tools for wireless Web development. This is not an exhaustive list, but 
I include the most widely used and deployed tools and solutions for wireless 
developers. For each resource, I have included the vendor, a Uniform Resource 
Locator (URL) where you can find more information, the platforms it supports, 
and a brief description. 
WAP Specifications 
The Wrreless Application Protocol (WAP) Forum sets the letter of the law in stone. 
Although specifications make dry reading, they provide the ultimate answer 
as to how things should behave. You can find the WAP Forum's Web site at 
www.wapforum.org. 
More fun for me is the totally unrelated www. coolwapsi teoftheday. com. The 
URL describes it perfectly; this site can help you get a good idea about who is 
doing what with the wireless Web. 
Client-Side Tools 
A crucial part of your development process is testing your wireless application on 
a number of browsers. One of the best ways to do this is to get as many different 
WAP toolkits as you can, and see how your content renders on each. Several com-
panies have announced free or subscription-based software development kits; 
you can visit their Web site for details. 
319 

Appendix A 
320 
AvantGo 
Vendor: AvantGo 
URL: www.avantgo.com 
Platforms: Microsoft Wmdows CE, Palm Computing Platform 
Notes: The market's leading synchronizing HyperText Markup Language 
(HTML) browser 
cjpeg 
Vendor: Independent JPEG Group 
URL:ftp://ftp.uu.net/graphics/jpeg/jpegsrc.v6b.tar.gz 
Platforms: Microsoft Wmdows, Unix, Linux, Macintosh ports available. 
Source code available. 
Notes: Not a validation tool but a free tool enabling developers to experiment 
with different compression levels within JPEG images 
HTML: :Clean 
Vendor: Paul Lindner 
URL:people.itu.int/-lindner/ 
Platform: Anywhere Perl is available, including MicrosoftWmdows, 
Macintosh, Unix, and Linux 
Notes: Not a true validation tool but useful for reducing the size ofHTML files 
jEdit 
Vendor: Independent (Slava Pestov) 
UFUL:jedit.sourceforge.net/ 
Platforms: Unix, Linux, Mac OS, Wmdows 
Notes: This is not a true Software Development Kit (SDK); rather, it is a Java-
based text editor that provides auto indention, macros, and syntax coloring for 
a number of markup languages, including eXtensible Markup Language (XML), 
eXtensible Stylesheet Language 'Iransformations (XSLT), and Wrreless Markup 
Language (WML). It has more features than you can shake a stick at. Best of all, it 
is free. 

Resources for Wireless Web Developers 
Motorola 
Vendor: Motorola Corporation 
lJIUL:wwwomotorolaocom/developers/wireless/web-wo-wires/ 
Platforms: Varied 
Notes: Provides developers with information and toolkits for testingWAP 
content on Motorola hardware 
Nokia WAP Toolkit 
Vendor: Nokia Corporation 
lJIUL:wwwoforumonokiaocom 
Platform: Microsoft Wmdows 
Notes: Nokia WAP Toolkit for developing and debuggingWAP content on 
a PC-based simulator 
Openwave 
Vendor: Openwave 
lJIUL: www o openwave o com 
Platforms: Wmdows, Solaris 
Notes: Provides the Openwave SDK simulator to view and debug eXtensible 
HyperText Markup Language Mobile Profile (XliTM-MP), WML, and Hypertext 
Device Markup Language (HDML) applications, along with copious documen-
tation and examples 
Tidy 
Vendor: W3C, written by David Raggett 
lJIUL:tidyosourceforgeonet 
Platforms: Microsoft Wmdows, lJnix, Macintosh ports available. Source code 
available. 
Notes: One of the oldest-and best-HTML validation tools available 
Yospace 
Vendor: Yospace 
lJIUL:wwwoyospaceocom 
Platforms: Wmdows, Macintosh, 1Jnix, Linux 
321 

Appendix A 
322 
Notes: Provides the Yospace SPEDE to view and debug HDML and WML 
applications, along with copious documentation and examples. Also provides 
a number of Java 2 Micro Edition (J2ME) tools and samples. 
Server-Side Tools 
The client side is only half of the solution. These sites have software you can use 
to build your server applications. 
Apache 
Vendor: The Apache Software Foundation 
tJIUL:www.apache.org 
Platforms: Unix, Linux, Mac OS X, Wmdows 
Notes: The Internet's most widely used Web server. Why not make it yours, too? 
MySQL 
Vendor: MySQLAB 
tJIUL: www. mysql. com 
Platforms: Unix, linux, Mac OS X, Wmdows 
Notes: Freely available fast SQL database with reasonable feature set. Plays 
well with PHP, Perl, Java, and other software development tools. 
Nokia WAP Server 
Vendor: Nokia Corporation 
UIUL:tidy.sourceforge.net 
Platforms: Varied 
Notes: Provides developers and networks with a reference server for gating 
WAP content from HyperText Transfer Protocol (HTTP) to WAP browsers using 
Unreliable Datagram Protocol (tJDP) over Transmission Control 
Protocol/Internet Protocol (TCP/IP). 

Resources for Wireless Web Developers 
PHP 
Vendor: The PHP Development Team 
URL: WNW. php. net 
Platforms: Unix, linux, Mac OS X, Wmdows 
PostgreSQL 
Vendor: PostgreSQL 
URL: ~. pgsql. com 
Platforms: Most flavors of Unix and linux 
Notes: Open-source, object-oriented relational database with SQL and trans-
action support. Integrates well with PHP and scales well to support enterprise 
applications. 
Mobile Software Development 
If you are looking at developing a smart client (see Chapter 14, "Content 
Delivery''), you should look at these sites when picking your development 
platform. 
J2ME 
Vendor: Sun Microsystems 
UIUL:wireless.java.sun.com 
Platforms: Wmdows, linux, Solaris 
Notes: Provides Java 2 Micro Edition SDK, articles, and documentation for 
handheld devices and wireless terminals 
Metrowerks CodeWarrior for the Palm Powered 
Platform 
Vendor: Metrowerks 
URL:~.metrowerks.com 
Platforms: Macintosh, MicrosoftWmdows, some flavors of Unix 
Notes: Provides C and C++ development environment for the Palm 
Computing Platform 
323 

Appendix A 
324 
Microsoft Windows CE SDKs 
Vendor: Microsoft 
lJitL:wwwomicrosoftocom/windowsce/ 
Platforms: Microsoft Wmdows targeting Microsoft Wmdows CE 
Notes: Software development kits based on Visual Studio for Wmdows CE 
handhelds, including handheld PCs and palm-sized PCs 
PRC-Tools for the Palm Powered Platform 
Vendor: Open source project maintained by Palm 
lJitL:wwwopalmosocom/dev/tools/gcc/ 
Platforms: lJnix (including linux), Microsoft Wmdows 
Notes: An open-source tool chain for the Palm Computing Platform 
Qualcomm Binary Runtime Environment for Wireless 
Vendor: Qualcomm 
lJitL:wwwoqualcommocom/brew 
Platform: Microsoft Wmdows targeting Qualcomm BREW 
Notes: SDK and emulator for Qualcomm BREW running on Microsoft 
Wmdows and Microsoft Developer Studio 
Symbian Platform 
Vendor: Symbian 
lJitL: www o symbian o com 
Platform: Microsoft Wmdows 
Notes: Software development kits for developing EPOC applications for 
devices running the EPOC platform, including Psion devices 

APPENDIX B 
Unified Modeling 
Language for Web 
Developers 
THE UNIFIED MooEIJNG LANGUAGE {UML) is being widely adopted as the visual lan-
guage of choice for modeling relationships within computer systems. An 
outgrowth of the modeling languages used to represent object -oriented systems, 
UML is fast becoming the standard way to represent almost any aspect of a com-
puting system. 
Traditionally, developers have used modeling languages to explain the inner 
workings of software or the arrangement of a cluster of computers performing 
some task. In many cases, a modeling language's use has been highly technical, 
and the resulting diagrams have not necessarily been of interest to Web masters, 
content developers, or those in related occupations. UML, however, is different, 
for two key reasons: 
• First, its capabilities are far more general than many visual modeling lan-
guages. UML is capable of representing many views of a system, and in fact 
it can be applied to noncomputer problems as well, such as business and 
process flow. 
• Second, its wide adoption makes it a useful common language that stake-
holders in the areas of business, user advocates, software architects, 
software developers, system operators, and content developers can 
all share. 
If you currently represent your network as little cylinders connected by 
arrows and lines pointing to a big cloud simply labeled The Web, UML is for you. 
325 

AppendixB 
326 
UML for Wireless Web Developers 
Developers use UML to capture and visualize the structure and operation of 
a system from different views. In general, views are related but different ways 
of thinking about how a system functions. For example, one view may represent 
a network topology for a service, and another may show the flow of a request 
through the service. Although these views are related, the emphasis of each is 
different. 
There are three broad categories of views: 
• Structural views represent a system's static structure, such as the organi-
zation of software components. 
• Dynamic views represent a view of the system over time, such as how the 
parts of a system interact to exchange information. 
• Meta views represent relationships within the model itself, such as orga-
nizing a system's models into a hierarchy. 
UML uses various shapes to denote different aspects of a system, and it uses 
lines between the shapes to denote relationships. One shape used by all diagrams 
is the comment shape, which is reminiscent of a sticky note. Solid lines indicate 
a named relationship, and dashed lines indicate a dependency of some kind. For 
example, for a component diagram-which shows how different components 
relate to one another-! would chose a solid line to indicate the flow of data and 
a dotted line to connect a comment with a component. Where direction is impor-
tant, arrows indicate the flow of information or dependency. Finally, numbers at 
the intersection of a line and shape indicate the number of entities on each side 
of a connection. (An asterisk means it could be any number.) 
Figure B-1 shows a deployment diagram representing a server-assisted 
browser service. Each host on the network, which is represented by the three-
dimensional rectangle, relies on another host for its correct operation (this 
relationship is shown by the solid lines). The asterisk (*) tells you there are an 
arbitrary number of clients; these interact with between one and four proxy 
servers, which are in turn represented by the three-dimensional rectangle beside 
which is written 1 
o 
o 
o 4. Finally, these proxy servers rely on servers on the 
Internet for their content. 

Unified Modeling Language for Web Develeopers 
Internet Server 
* 
I 
TCP/IP 
l 
Proxy Server 
1-4 
I 
Wireless Network 
I 
* 
User's Mobile 
Device 
Marketing 
expects s,ooo 
additional users 
each month. 
Figure B-1. Deployment view of a server-assisted browser service 
Views for Representing Web Relationships 
One of UML's great strengths is its flexibility. UML brings many different visual 
modeling views together under one common standard. Let's take a closer look at 
the four views you will find the most helpful in wireless Web development. 
Deployment Views 
A deployment view is responsible for conveying the configuration of a running 
system. Deployment views indicate the hosts on which programs run, the net-
works between hosts, and other details. These views are valuable tools for 
network designers and administrators for whom an understanding of the physi-
callayout of a network and its relationship is of paramount importance. 
One essential component of a deployment view is a node, a computational 
resource used by the system. This is most often a server or workstation, although 
in some systems it may represent other computational resources, such as a single 
processor or a cluster of redundant servers containing the same set of compo-
nents. You draw a node as a three-dimensional rectangle. 
Nodes contain components, which are represented using the same symbols 
as in component diagrams. You show the relationships among components 
within a node using solid and dashed lines, again as in component diagrams. 
327 

AppendixB 
328 
Solid lines also represent the communications infrastructure that links two or 
more nodes. 
Figure B-1, shown previously, illustrates a deployment view of a server-
assisted browser service. 
Use Case Views 
A use case view captures how a system interacts as seen from the perspective of 
an outside user performing a task. Use cases represent users as actors, idealized 
users of a system that exchange a series of messages between the system and its 
components. Use cases can be fundamental in establishing how a subscriber will 
use a wireless system; they help everyone understand how a system can be orga-
nized to meet users' needs. 
In developing use cases, it is important to focus on establishing the actors 
that will characterize the various users of the system. Each actor represents 
a class of users with similar goals and backgrounds. In essence, actors are profiles 
of user populations, such as subscribers, administrators, network support staff, 
and so on. 
An actor invokes a use case, a functional unit of the system performing a par-
ticular task. A use case defines what happens in a system, without needing to 
worry about how it will happen. It captures all aspects of the operation, including 
appropriate behavior, abnormal operation, and input as well as the appropriate 
response. System designers use the use cases to determine the kinds of classes, 
objects, and relationships needed to construct a system. 
Figure B-2 shows the use case view for a simple wireless Web service that 
provides location information for its users. Stick figures denote actors, and 
labeled ovals represent the use cases. Solid lines show the interaction between 
actors and use cases. 

Unified Modeling Language for Web Develeopers 
Site Admin 
Figure B-2. A simple use case view 
Component Views 
Likely used 
only on high-
end devices 
... , 
......... 
......... 
......... ... , 
A component view captures how the various components of a system 
interact. A component is a physical entity, such as an aggregation of software that 
performs a well-defined task. Examples include a logging subsystem, a Web 
server, an eXtensible Markup Language (XML) parser, or a client application. 
Components can contain simpler components responsible for particular smaller 
tasks, such as caching or logging. You draw components as rectangles with two 
smaller rectangles overlapping the left side; the component's name is within the 
larger rectangle. Components may be drawn with the objects they contain shown 
inside them, although often the objects are omitted for clarity. 
Each component has an interface, which must be well defined. Components 
share the details of their interfaces, while keeping other aspects of their imple-
mentation hidden from view by other components. All interactions with 
329 

AppendixB 
330 
a component occur through an interface, which can be viewed as a kind of con-
tract: promising what a component will do and deliver, but leaving just how it 
does this as a private matter for the component and its developers. You draw 
interfaces as circles; a solid line joins an interface with its provider. A dotted line 
indicates that one component relies upon another's interface. When the direction 
of dependence is not relevant, components are drawn connected with straight 
lines, indicating simply that they communicate through some interface and have 
a dependence on each other. When direction of dependence is relevant, the 
arrow points to the provider of the interface. 
Figure B-3 shows a hypothetical component view diagram for the wireless 
Web service detailed in the previous section. 
User 
Preferences 
Database 
Figure B-3. A component view 
Sequence Views 
A sequence view shows the interaction of components via messages sent between 
them through interfaces, arranged by time. Typically, software developers use 
sequence views to visualize the interaction of objects, although there is no reason 
why they cannot also capture interactions among components, network nodes, 
or other parts of a model. Another common use more relevant to Web developers 
is showing the sequence of the events that make up a use case. 
You draw participants-components or hosts in a network-in a sequence 
view as rectangles along the top of the diagram; you show time along the vertical 
axis. Interactions (typically messages) between items are drawn as arrows. 
Figure B-4 shows the sequence view representing the Locate User use case 
shown in Figure B-2. 

Unified Modeling Language for Web Develeopers 
Client 
HTTP Server 
Locate 
User 
Web 
f----
-----1 
Page 
Figure B-4. A sequence view 
Other Views 
Invoke Script 
from POST 
Web Page 
(HTML, WML) 
PHP 
Position 
Record 
Location 
Database 
When working with software developers, you will often encounter other views. 
These views may not be directly pertinent to your own work if you are only 
responsible for creating and managing content, but understanding what these 
other views are will help you communicate with software developers. 
Model Management Views 
Developers use the model managementview to subdivide a set of views into 
manageable units. It breaks a model into packages and describes the relation-
ships among these packages within the model. 
A package is simply a logical segment of a model. Just as a file folder contains 
files (or as the icon of a file folder on your computer contains icons of files), 
a package contains other models. You should not confuse a package with other 
things in views; unlike ·most views, the model management view represents the 
model itself; the notion of a package does not have a real-world equivalent within 
the system, but rather represents a group of other model components. 
Every part of a model must belong to exactly one package. Modelers organize 
packages by conceptual categories, such as the responsibilities of subsystems. 
Each package contains top-level views in a particular category, such as use cases, 
component views, deployment views, or other entities. A view can belong to only 
one package, although a view in one package can point to a view in another 
package for more information. In large environments with document control, 
packages may be used as the organizational focus of change control-for exam-
331 

AppendixB 
332 
pie, you could divide models into packages stored in separate directories on 
a server and keep each directory under change control. 
You draw packages with an icon resembling a desktop folder icon-a larger 
rectangle with a smaller rectangle on top. Figure B-5 shows a model management 
view of the relationship among the user management, user location, and client 
services packages of the location wireless Web site illustrated in Figure B-2. 
Location Service 
....------,/ 
'\ 
L...---,----' \,\\, 
Figure B-5. A model management view 
Class Views 
Use Cases 
Operation 
Sequences 
UML's roots are in a number of object-oriented modeling systems developed 
over the last decade. Hence, UML provides a robust set of symbols for represent-
ing the relationships between classes and objects. If you are a software developer 
with a background in object-oriented design-especially if you are familiar with 
another modeling system-you will find UML's static class views largely intuitive. 
(If not, consult one of the many good books on the topic available today.) 
Within a class view, classes-abstractions of related object representations-
are represented as rectangles, divided in to sections containing the class name, 
attributes, and operations within the class. Class relationships are shown by solid 
lines; constraints by dotted lines. Named relationships between classes, called 
roles, demonstrate important interactions between classes. 
Collaboration Views 
Developers attempting to visualize the relationships among classes over time use 
collaboration views to represent the flow of messages through objects. (An object 

Unified Modeling Language for Web Develeopers 
is a specific thing that behaves according to the description of a class.) Objects 
are denoted as named rectangles, with links between objects shown as solid 
lines. Messages passed between objects are numbered and written with arrows 
next to the links between objects. Collaboration views are similar to sequence 
diagrams, but they are generally of more use to software developers than Web 
designers, as they can be used to represent the inner workings of a program per-
forming a specific operation. 
State Machine and Activity Views 
The state machine view also represents dynamic behavior. It shows a system's 
operation as a series of states, with lines indicating the transitions between them. 
You can think of a state as some period in the life of an object and a transition as 
the process of moving to a new state after certain conditions have been met. 
State machine views are often used to show the inner workings of protocol stacks. 
An activity view is a variation of the state machine view that focuses on por-
traying the computational activities required to meet the conditions necessary 
for transitions and on describing the behavior of a transition. 
Further Reading 
UML is a valuable tool for anyone working in the field of information technology 
and processing. Although to date it has been largely used only by software devel-
opers, an understanding ofUML can be of great use to Web designers and 
content developers working in a technical environment. 
For those interested in learning more about UML, one of the best works to 
date is UML Distilled: A Brief Guide to the Standard Object Modeling Language 
(Second Edition) by Martin Fowler and Kendall Scott (Addison-Wesley, 1999). For 
the stalwart, The Unified Modeling Language Reference Manual by James 
Rumbaugh, lvar Jacobson, and Grady Booch (Addison-Wesley, 1998) is the defini-
tive reference to UML. 
333 

APPENDIX C 
Handheld Device Markup 
Language 
AuHoUGH THE WIRELESS APPUCATION PROTOCOL (WAP) is now the world standard for 
screen phone content, the Handheld Device Markup Language (HDML) was 
important in North America for a number of years, and I recommend you gain at 
least some familiarity with it. 
In this appendix, I introduce HDML and show you how you use it to mark up 
your content for today's domestic screen phones and wireless terminals. 
Introducing HDML 
HDML was the first device-specific markup language available for screen phones. 
Created by Unwired Planet (now Openwave), it had been widely licensed to 
handset manufacturers. Major wireless providers, including AT&T, offered mobile 
data services that carried HDML at one time, and most domestic wireless data 
handsets in use can view HDML. 
Unlike the other wireless technologies discussed in this book, the HDML 
standard is controlled by a single company. Consequently, over time phone ven-
dors and carriers banded together to create the WAP forum to ensure an open 
standard. 
HDML depends on the Openwave Server, which provides server-side assis-
tance for HDML browsers. The Openwave Server gates HDML content from the 
Web to wireless terminals (see Figure C-1 for a deployment view). As with other 
server-assisted wireless browsers, the Openwave Server bridges the gap between 
media-rich Web content and constrained access devices. It provides network-
specific services to the wireless network, converting the wireless protocols to Web 
protocols and making requests of the servers where the content originates-on 
the Web or on private enterprise networks. 
335 

AppendixC 
336 
HDML Handset 
~ 
~ 
* 
Proxy 
Server 
Protocol 
Gateways 
Figure C-1. The deployment model for HDML services 
Web Server 
HTTP 
HDML 
Fortunately, it is not necessary to know much about the Openwave Server to 
develop HDML content. Network providers make an Openwave Server available 
and support it for their subscribers. 
Developers who set out to learn HDML will find experience with other 
markup languages helpful. Understanding the Wireless Markup Language (WML) 
makes HDML easier to learn at a conceptual level, but knowing the HyperText 
Markup Language (HTML) well makes HDML easier to write. HTML and HDML 
tags are written using the same syntax, and some tags are the same in both 
markup languages. However, the organization of an HDML document is most 
similar to that of a WML document, and several important features of HDML, 
including tasks and variables, resemble those ofWML. 
This dichotomy originates in the history ofHDML. Originally developed by 
Openwave's previous incarnation, Unwired Planet, HDML was intended as an 
alternative to HTML for mobile devices on which HTML processing would be too 
expensive to be practical. As the adoption ofHDML accelerated, a number of 
handset manufacturers interested in establishing an open standard for wireless 
data worked with Openwave to create the WAP Forum, the industry association 
that developed and maintains the WAP standards. Thus, HDML has a syntax 
based on HTML, but it includes concepts refined in WAP protocols. 

Handheld Device Markup Language 
HDML or WML? 
The existence of two complementary standards in a growing market leads 
inevitably to the question, "Which one should I use?" Although there may be spe-
cial cases, the basic answer in this case is simple: You should support WAP. 
The differences between WML and HDML are rooted in syntax, not seman-
tics. Almost all of to day's handsets support viewing WML, so you should only 
undertake HDML development if the economics do not support replacing an 
entire site at once. 
Fortunately, the features ofWML and HDML are technically similar. Both 
languages support variables, and both provide limited on-device processing of 
data. The WAP stack provides WMLScript, a scripting language that provides con-
ditional evaluation and other primitives you could only get from a server in an 
HDML application. However, HDML has a few other features, such as activities 
and iconic soft-key labels (more information about both of these appears later in 
this chapter), which are presently unavailable to WAP developers. 
Creating Your First HDML Page 
The basic syntax ofHDML is simple enough that it will become clear from a sin-
gle example: 
<HDML VERSION=3.0> 
<!-- A simple HDML deck --> 
<DISPLAY NAME=hello> 
Hello world! 
<BR> 
How are you today? 
</DISPLAY> 
<IHDML> 
Note the strong similarities to HTML: Tags are contained within angle brack-
ets:< and>. Tags that accept arguments, such as the <DISPLAY> tag, use the same 
angle brackets as empty tags such as <BR>. You can include comments between 
the delimiters < ! -and->. 
Again as in HTML, many tags have attributes that further describe their 
behavior. Attributes are specified as named values, within the angle brackets but 
after the tag's name, such as the NAME attribute of the <DISPLAY> tag in the previ-
ous example. (These attributes are described in detail in the "Understanding 
HDML for Web Developers" section later in this chapter.) 
337 

AppendixC 
338 
You must begin any HDML document with the <HDML> tag. Because only one 
document can occupy a file, every HDML file begins and ends with this tag. 
HDML documents are organized as decks of cards, just as are WAP docu-
ments. Thus, the <HDML> tag delimits a deck. The cards within the deck can specify 
actions, declare or evaluate variables, and display content. (A card may do any or 
all of these things, although as you will see, one card cannot prompt for both text 
and selection input.) You can use any of the tags <DISPLAY>, <NODISPLAY>, 
<CHOICE>, and <ENTRY> to specify a card. 
Another feature ofHDML that differs from HTML is the use of variables, 
which play an important role in handling user input in HDML. Variables are set 
using the <ACTION> tag and can be evaluated using the $ operator. The best way to 
explain their use is through an example: 
<HDML VERSION="3.0"> 
<NODISPLAY> 
<ACTION TYPE=ACCEPT TASK=GO DEST=#main 
VARS=pi=3.14159&e=2.71828> 
</NODISPLAY> 
<DISPLAY NAME=main> 
PI is $pi. <BR> 
e is $e. 
</DISPLAY> 
<HDML> 
This card uses a hidden card-declared with the <NODISPLAY> tag-to set 
the variables pi and e. The second card of the deck evaluates these variables 
in the content displayed using the $ operation. 
Using Browsers, Tools, and SDKs 
A variety of handset manufacturers once offered phones with HDML browsers, 
including Motorola, Alcatel, Mitsubishi, and Samsung. At present, there are no 
HDML browsers for laptops, Personal Digital Assistants (PDAs), or hybrid 
phone/ computing devices. Today, most phones support WML but can still dis-
play HDML via the gateway server, which must transcode HDML to WML before 
it is sent to the client. 
Despite HDML's well-established presence in the industry, no proven tools 
exist that enables What-You-See-Is-What-You-Get (WYSIWYG) editing or vali-
dation ofHDML; currently, therefore, you must develop HDML content with 
a text editor. Any simple text editor will do, includingWordPad, BBEdit, or emacs. 

Handheld Device Markup Language 
Simply compose using standard American Standard Code for Information 
Interchange (ASCII) characters, save the result as a flat text file with the extension 
• hdml. (When saving HDML files from a Wmdows text editor, do not forget to 
specify the filename in quotes, or your file will end up with the suffix • hdml. txt). 
Understanding HDML for Web Developers 
If you have used another markup language, you will find it easy to learn HDML. 
HDML draws on common concepts found in both WML and HTML, although it 
has some new ideas of its own as well. 
Cards and Decks 
The fundamental organizational metaphor behind HDML is the deck of cards. 
Cards act as containers for all other objects; they describe actions, display con-
tent, and control interactions with users. There are also hidden cards, which 
encapsulate tasks or manage variables. Cards are grouped together into decks. 
Usually, the cards in a deck relate to a common purpose or subject, such as 
a stock quote, news headline, or weather report. 
Attributes of Cards and Decks 
Many HDML tags accept attributes, which control how the client renders the tag. 
The attributes of cards and decks are paramount because they determine such 
aspects of your content as who can access your decks and how navigation 
between decks and cards behaves. In the following sections, I discuss the attri-
butes of the cards and decks shown in Table C-1. 
339 

AppendixC 
340 
Table C-1. Deck and Card Attributes 
TAG 
<DISPLAY>* 
<HDML> 
AnRIBUTE 
BOOKMARK 
NAME 
MAR KABLE 
TITLE 
VERSION 
ACCESSPATH 
ACCESSDOMAIN 
PUBLIC 
TIL 
PURPOSE 
Specifies the URL that should be saved when 
a card is bookmarked 
Specifies a card's name for navigation 
purposes 
Indicates whether a card can be bookmarked 
(true) or not (false) 
Specifies a card's bookmark title 
Specifies the version number of HDML 
being used 
Specifies the path of decks that are allowed to 
link to an access-controlled deck 
Specifies the domain of decks that are 
allowed to link to an access-controlled deck 
Indicates whether access to a deck is 
restricted (false) or not (true) 
Specifies a deck's time to live, in seconds 
*The attributes of the <DISPLAY> tag are also attributes of the <CHOICE> and <ENTRY> tags. 
Deck Attributes 
The attributes of a deck determine the behavior of all the cards in it: whether they 
can be bookmarked (by default), how long they can remain in the browser's 
cache, and whether the deck can be linked to other decks. 
The <HDML> tag, mentioned previously, introduces each deck. Its MARKABLE 
attribute specifies whether cards within the deck can, by default, be bookmarked. 
This flag may be overridden for specific cards. 
The PUBLIC attribute indicates whether a deck's contents can be accessed 
from other decks. By default, any deck can be linked to any other deck. You can 
restrict access to a deck by specifying a value of FALSE for the <HDML> PUBLIC attri-
bute. When PUBLIC is set to FALSE for a given deck, other decks can only be linked 
to it if they have the base URL specified in its ACCESSDOMAIN and ACCESSPATH attri-
butes. The default for the PUBLIC attribute is FALSE. Note that a deck with 
restricted access cannot have bookmarkable contents because the bookmark 
would access the deck from outside the specified access domain and path. 

Handheld Device Markup Language 
The final attribute of the <HDML> tag is the optional TIL attribute, which speci-
fies the amount of time a deck may remain cached. (TIL stands for "time to live'' 
and is given in seconds.) Rapidly changing data, such as stock quotes, call for 
a low TTL, and content that does not change can last longer. The following exam-
ple indicates that the deck should be cached for 12 hours: 
<HDML VERSION=3.0 TTL=43200> 
<DISPLAY NAME="result" MARKABLE=FALSE> 
<-- Card's content --> 
</DISPLAY> 
</HDML> 
By default, content will remain cached for no more than 30 days. Even with-
out a TIL attribute, however, data may end up cached for considerably less time, 
as browsers may delete content viewed infrequently. 
Card Attributes 
A card's behavior is primarily determined by four attributes of the <DISPLAY> tag 
and the other card tags <NODISPLAY>, <CHOICE>, and <ENTRY>.The NAME attribute 
specifies a name for the card. Card names are used for navigation and are similar 
to anchor references within HTML text. Every card can be uniquely identified by 
the URL of the deck, followed by the hash symbol (#), followed by the name of the 
card-for example, http: I /hdml.apress. com/ example. hdml#hello. As you will see 
in the next section, it is also possible to navigate among cards using relative URLs. 
HDML provides control over the behavior of bookmarks via the TITLE, MARK-
ABLE, and BOOKMARK attributes of the <DISPLAY> tag. A card can only be 
bookmarked if its MARKABLE attribute is TRUE. (This attribute for a specific card 
overrides the default, which is determined by the MAR KABLE attribute for the deck.) 
The TITLE attribute of a bookmarkable tag specifies a short title for the card 
within a bookmark; the URL that a bookmark opens can be set using the BOOK-
MARK attribute. By default, the current card's URL becomes the bookmark's URL. 
Consider a deck that is used to obtain telephone numbers from a directory. 
You would not want users bookmarking the results card or cards where form 
input has already taken place. In fact, you would probably want only the first card 
of the deck, where users enter the desired name, to be bookmarkable. Your 
HDML in this situation might look like this: 
341 

AppendixC 
342 
<HDML VERSION=3.0> 
<DISPLAY NAME="home" TITLE="Moonlight Directory" MARKABLE=TRUE> 
<ACTION TYPE=ACCEPT TASK=GO DEST="#InputChoice"> 
<-- Card content --> 
</DISPLAY> 
<CHOICE MARKABLE=FALSE NAME="InputChoice" 
KEY=choice IKEY=num IDEFAULT=1> 
<-- Card content --> 
</CHOICE> 
<ENTRY MARKABLE=FALSE NAME="last" KEY=last FORMAT="*a"> 
<-- Card content --> 
</ENTRY> 
<ENTRY MARKABLE=FALSE NAME="First" KEY=first FORMAT="*a"> 
<-- Card content --> 
</ENTRY> 
</HDML> 
Types of Cards 
There are three broad categories ofHDML cards: 
• Cards that display information, such as formatted text or images 
• Hidden cards that specify variables or encapsulate actions available to the 
user, such as navigation to other pages 
• Cards that accept input from the user 
In most decks, these categories are mixed and matched to create interactive 
applications. For example, an application that searches an intranet phone direc-
tory will use cards with actions and input to enable users to look up coworkers' 
names and dial their phone numbers. The first card would be an input card, let-
ting the user enter a name. This card would link to a hidden card, which would 
wrap up the form content and post it to the server for a response. The response 
deck would contain a content card that displayed the phone number and 
included an associated action that dialed the number on the card. 

Handheld Device Markup Language 
Displaying Information 
HDML decks can display plain text {there is no support for styles or different 
fonts) and images. Although it is minimalist compared to eitherWML or HTML, 
the text formats it supports are reasonable considering the capabilities of the tar-
get devices and quite sufficient to display a wide variety of information. Table C-2 
summarizes the tags available for formatting display information on HDML 
cards. Note that the tags listed are all empty tags. 
Table C-2. Tags for Card Formatting 
TAG 
<BR> 
<CENTER> 
<IMG> 
<LINE> 
<RIGHT> 
<TAB> 
<WRAP> 
AnRIBUTE 
ALT 
ICON 
SRC 
Presenting Text 
PURPOSE 
Inserts a line break 
Centers the current line 
Specifies a text label for an image 
Specifies the source of an image 
found in ROM (by name) 
Specifies the source of an image 
obtained from the wireless Web (by URL) 
Indicates that the current line should not 
be broken 
Right-justifies the following text 
Indicates that display should continue at 
the next tab stop 
Indicates that a wrapping line follows 
(paragraph form) 
HDML supports two kinds of text display: wrapped text {paragraphs) and a mar-
quee scrolling text line. Wrapped text is appropriate for most purposes, including 
text paragraphs, news stories, and data display. The <WRAP> tag works much like 
the <P> tag in HTML; it goes at the beginning of each chunk of word-wrapped text. 
Occasionally, you may need to display a line of text as an unbroken string, 
such as an e-mail header. The <LINE> tag comes in handy for this purpose: 
343 

AppendixC 
344 
<HDML VERSION=3.0> 
<DISPLAY> 
<LINE> 
The quick brown fox jumped over the lazy dog adroitly. 
<WRAP> 
After her followed four slow green turtles. 
</DISPLAY> 
</HDML> 
The contents of the <LINE> tag will scroll repeatedly across the display so that 
the entire contents can be read on a single line. (Unfortunately, it is hard to 
demonstrate this feature in a paper book!) This tag should be used sparingly, as 
a host of moving lines is difficult to read. 
Formatting Text 
Formatting is controlled by a set of tags that specify a particlar operation for the 
browser, such as "center the following text," "place a tab," or "end a line." Unlike 
in HTML, these tags do not enclose the text being formatted; rather, they are 
placed at the begining of the run of text to which they apply, and the indicated 
formatting continues until the next formatting tag. 
You can insert line breaks at any point using the empty <BR> tag. You can also 
use it in conjunction with the empty <TAB> tag, which inserts a tab, to create sim-
ple tables. By default, all text is left-justified. Text regions can be centered or 
right-justified using the empty <CENTER> and <RIGHT> tags. 
The following example shows some of these text formatting features in 
action. The initial text is centered with the <CENTER> tag, and the weather report 
appears in a two-column table: 
<DISPLAY NAME="result" MARKABLE=FALSE> 
<WRAP> 
<CENTER> 
Weather Forecast for<BR> 
Boulder Creek CA 
<LINE> 
<TAB>High<TAB>70<BR> 
<TAB>Low<TAB>54<BR> 
</DISPLAY> 

Handheld Device Markup Language 
Displaying Images 
Some HDML browsers can display simple monochrome images. The empty <IMG> 
tag specifies an image's text label and origin. Images may be obtained from origin 
servers on the Web or selected from a set of images stored in Read Only Memory 
(ROM) on the phone by the manufacturer. This set of images is defined by 
Openwave and consists of almost 200 clip-art images appropriate for wireless 
applications. These images are designed to look good on the phone and may 
have been redrawn to best suit a particular phone's display. Whenever possible, 
select your images from the phone collection, as they will both load faster and 
look better on the display. The particular images available may depend on the 
version of the HDML browser you are using; check the Openwave SDK documen-
tation when selecting an image for your content. 
You specify the image you want using the ICON attribute if the image is in the 
phone or the SRC attribute if it originates from a Web site. Using the <IMG> AL T 
attribute, you should also provide an alternate text title for each image. This attri-
bute is optional in HDML, but in practice it is essential, as some users may not be 
able to view the images you include with your content. 
Adding an icon from the handset's ROM to our weather page gives you an 
HDML file like the one that follows. (Figure C-2 shows the resulting display.) The 
cloud image is only one of several weather-related images available from the 
HDML browser: 
<DISPLAY NAME="result" MARKABLE=FALSE> 
<WRAP> 
<CENTER> 
Weather Forecast for<BR> 
Boulder Creek CA 
<LINE> 
<IMG ICON="cloud" ALT="clouds"><TAB>High<TAB>70<BR> 
<TAB>Low<TAB>54<BR> 
</DISPLAY> 
345 

AppendixC 
346 
Weather Forecast 
for 
Boulder Creek 
Hiqh 70 
Low 
54 
Figure C-2. A card with formatted text and an image 
If you need an icon that is not available in the cache, you can always specify 
a URL source for the image: 
<DISPLAY NAME="result" MARKABLE=FALSE> 
<WRAP> 
<CENTER> 
Weather Forecast for<BR> 
Mercury Desert 
<LINE> 
<IMG SRC="scorched.gif" ALT="scorched"><TAB>High<TAB>680<BR> 
<TAB>Low<TAB>-354<BR> 
</DISPLAY> 
Displaying Special Characters 
As in other markup languages, there are certain characters in HDML that you 
cannot use except as parts of the markup tags themselves. HDML reserves the 
characters<,>, ",&,and$ to define tags and manipulate variables. If you need 
one of these characters elsewhere, you can insert it using one of the special 
escape sequences shown in Table C-3. Note that these are all escape sequences. 

Handheld Device Markup Language 
Table C-3. Reserved Characters and Their Corresponding Entities 
CHARACTER 
< 
> 
& 
$ 
TAG 
&lt; 
&gt; 
&quot; 
&amp; 
$dol; 
Tasks and Actions 
PURPOSE 
Less than symbol 
Greater than symbol 
Double quotation mark 
Ampersand 
Dollar sign 
<ACTION> tags assign tasks to be performed with specific interface elements. 
These tasks include navigation to other decks, returning to a previous deck, and 
making a phone call. Some interface elements on the handset itself-such as the 
soft keys, Help key, and Delete key-can be assigned to tasks. In general, these 
are keys, but they may be other controls, such as a rocker switch or touchscreen. 
(In the following discussion, I refer to them simply as keys for brevity.) The actual 
kind and nature of these buttons may change from manufacturer to manu-
facturer. 
Actions may be defined either at the card level or at the deck level; if you 
assign an action at the deck level, it becomes the default for the entire deck, but 
may be overridden by a particular card. A card may contain one or more actions. 
Assigning a Task 
The empty tag <ACTION> binds an interface element to a task. Interface elements 
recognized by the browser include the following: 
• The ACCEPT button. 
• The HELP action (which may or may not be a physical control on the 
phone). 
• The PREV action (which also may or may not be a physical control on the 
phone), used by the browser to navigate to the previously viewed deck. 
347 

AppendixC 
348 
• The soft keys, SOFTl and SOFT2. These keys have no physical labels; 
a label must be specified to appear on the liquid Crystal Display (LCD) in 
conjunction with the key. 
• The SEND button, which initiates a voice call. 
• The DELETE button. 
Some of these elements are associated with expected phone-related behav-
iors, of course. For example, users expect the handset to dial a number when they 
press the SEND button, so assigning this button to the task of clearing a form, for 
example, is a bad idea. In general, it is best to assign most tasks to the ACCEPT 
buttons or to one of the soft keys. 
The <ACTION> tag accepts the attributes listed in Table C-4. I discuss each of 
these in the following sections. 
Table C-4. Attributes of the <ACTION> Tag 
TAG 
ATIRIBUTE 
<ACTION> 
DEST 
ICON 
LABEL 
METHOD 
NUMBER 
REL 
SRC 
TASK 
TYPE 
PURPOSE 
links a task to an interface element 
Specifies the destination of a GO or 
GOSUB task 
Specifies the name of an image from 
ROM to be used as a soft key label 
Specifies a label for a soft key 
Specifies whether a navigation should 
result in a GET or POST request 
Specifies a phone number to be called 
When set to the value NEXT, prefetches 
the indicated DEST resource 
Specifies the source URL for an image to 
be used as a soft key label 
Specifies the task to be performed 
Specifies the type of interface element to 
be assigned a task 

Handheld Device Markup Language 
Kinds of Tasks 
The browser recognizes the following tasks: 
• The GO task requests a URL. 
• The PREV task displays the previous card to the user. (If no previous card is 
available, the PREV task is equivalent to the CANCEL task.) 
• The CALL task initiates a voice call to a specified number. 
• The NOOP task does nothing. It is used to hide the default behavior of 
an interface item or to override a deck's <ACTION> tag for a specific 
interface item. 
• The GOSUB task pushes the current activity on the activity stack and 
requests a URL. 
• The CANCEL task cancels the current activity and returns the user to the 
caller's CANCEL card. 
• The RETURN task returns to the previous activity as specified by the caller's 
NEXT card. 
The relationship between an interface element and a task is established 
through the <ACTION> TYPE and TASK attributes. TYPE specifies the interface ele-
ment, and TASK, not surprisingly, indicates the task to be performed: 
<ACTION TYPE=ACCEPT TASK=GO DEST="http://hdml.apress.com/index.hdml"> 
In this example, the ACCEPT key has been programmed to display the first 
card of the deck at http: //hdml. apress. com/index. hdml when pressed. 
Other attributes of the <ACTION> tag control its behavior. The SRC and ICON 
attributes can specify an image resource for use as the label of a soft key's label, 
using the same syntax as the <IMG> tag. 
The RE L attribute can specify to prefetch the indicated resource. The follow-
ingcode: 
<ACTION TYPE=ACCEPT TASK=GO DEST ="football. hdml" REL=NEXT> 
causes the browser to fetch the deck at football. hdml while the current card is 
being viewed. Prefetching content increases the perceived speed at which a site 
functions-but it can increase airtime costs unnecessarily, as the user might not 
349 

AppendixC 
350 
view some prefetched content (but must pay for the time spent fetching it any-
way). You should therefore use the REL attribute carefully. 
Data from HDML forms is sent to servers using the GO task in conjunction 
with the METHOD and POSTDATA attributes. By default, all navigation operations use 
the HTIP GET request method. Specifying METHOD=POST instructs the Openwave 
server to send form data by using the POST method instead. (You can also specify 
the GET method using METHOD=GET to be explicit.) When the POST method is in 
use, the POSTDATA attribute should be set to an ampersand-delimited list of vari-
ables and names for the server to process. For example: 
<ACTION TYPE=ACCEPT TASK=GO 
DEST="http://masamune.lothlorien.com/wx" 
METHOO=POST 
POSTDATA="choice=$menu&city=$city&state=$state&zip=$zip"> 
This sends the form variables named choice, city, state, and zip to the 
server, along with the values of the HDML variables menu, city, state, and zip. 
Other attributes of the <ACTION> tag specify arguments for a particular task. 
In the last example, you saw the DEST attribute used to specify the location of the 
deck to be displayed. The DEST attribute may be any partial or whole URL, evalu-
ated relative to the current deck's URL. Similarly, the NUMBER attribute specifies 
a telephone number for the CALL task. 
Although there is no way to set HDML variables directly, it is possible to set 
them from within an action using the VARS attribute. VARS accepts a list ofHDML 
variables and their values in the same format as the one used by the POSTDATA 
attribute. For example, the following <ACTION> tag sets the default value for the 
variable ZIP: 
<ACTION TYPE=ACCEPT TASK=GO DEST=#result VARS=ZIP=95006> 
Actions Spanning an Entire Deck 
An <ACTION> tag contained within a card assigns a task only for that card. There 
may be times when you will want to replace the default action of an interface ele-
ment over the scope of an entire deck. To do this, simply place the <ACTION> tag 
after the <HDML> tag that begins the deck. For example, you might want to offer 
help information that will be the same across most or all of the cards in a deck, as 
shown in this example: 
<HDML VERSION=3.0> 
<ACTION TYPE=HELP TASK=GO DEST="#help"> 
••• <-- Other deck cards here --> 

Handheld Device Markup Language 
<DISPLAY NAME="help"> 
<ACTION TYPE=ACCEPT TASK=PREV> 
<WRAP> 
You can obtain the weather by entering 
either the ZIP code of the place of 
interest, or the city and state. 
</DISPLAY> 
</HDML> 
From any card in this deck, activating the browser's HELP interface will dis-
play the card named help. 
You may think you can do the same to set variables across a deck using this 
method, but you cannot. The VARS attribute of the <ACTION> tag is not a task in its 
own right but must be contained within another task. You cannot simply embed 
it in any <ACTION> tag in the deck, either, because the variables will only be set 
when the task is performed. Fortunately, there is another way to have the same 
effect. 
The <NODISPLAY> tag creates a hidden card that immediately invokes its 
ACCEPT or PREY interface element. It can be used at the beginning of a deck to 
initialize variables that will be needed later or to encapsulate several references 
to a single URL. (I will use this trick later in this chapter in "Integrating Actions 
and Input." The basic idea is to collect a form's various post operations on a sin-
gle card, rather than scattering them across multiple cards. This makes making 
changes to a deck easier.) 
The following deck demonstrates the difference between a hidden card that 
sets a variable and a deck <ACTION> tag: 
<HDML VERSION=3.0> 
<ACTION TYPE=HELP TASK=GO DEST="#help" VARS=setwhere=help> 
<NODISPLAY> 
<ACTION TYPE=ACCEPT TASK=GO DEST="#home" VARS="setwhere=hidden"> 
</NODISPLAY> 
<DISPLAY NAME="home" TITlE="Weather" MARKABLE=TRUE> 
<WRAP> 
The variable setwhere was set to $setwhere. 
</DISPLAY> 
<DISPLAY NAME="help"> 
<ACTION TYPE=ACCEPT TASK=PREV> 
<WRAP> 
This card simply sets the setwhere variable. 
</DISPLAY> 
</HDML> 
351 

AppendixC 
352 
When this deck is first viewed, the display will read, "The variable setwhere 
was set to hidden." But after a user has invoked HELP and then returned from the 
help card, the message will change to The variable setwhere was set to help. 
The <NODI SPLAY> card, like any other card, occupies memory in the cache 
and takes the browser some time to process. Because of this, you should avoid 
creating paths that require the browser to navigating through more than one hid-
den card at a time so that the user does not encounter a lengthy period of 
apparent inactivity. 
Using Activities to Organize Decks 
HDML activities are a mechanism for organizing decks. They provide some of the 
same structure as functions do in a structured programming language. An activ-
ity can be invoked, and when it is complete, control is returned to the calling 
activity. Control can be returned with either a RETURN task-if the activity has 
been successfully completed-or a CANCEL task-if the user has cancelled the 
activity in progress. 
Within a single activity, all variables have global scope across cards and 
decks. Variables of the same name can be used in different activities without 
conflict. 
Consider the process of reading e-mail. The user begins by perusing subjects, 
an activity unto itself. He or she then selects a particular message, initiating 
a new activity-reading the message. At this point, there are now two activities-
one in progress (reading a message) and the other suspended (perusal of 
subjects). The user could then add a third activity to the queue by replying to the 
message. This activity can either be terminated by the user (if the reply is can-
celled), or ended normally (if the message is sent). In the case of a termination, 
the user would return to the message display; if the message was sent, the user 
would return to the list of messages. Each of these activities can use a different 
set of variables and one or more decks. The activity stack allows a deck within 
a specific activity to refer to a calling activity (the preceding one) without previ-
ous knowledge of its behavior or location. 
The GOSUB task invokes a new activity. Like the GO task, it navigates to the deck 
specified in its DEST URL. Unlike GO, however, it declares a new activity context, 
creating a new name space for all variables. Previous variables' names and values 
are saved, but they cannot be accessed by the current deck or others until 
a RETURN or CANCEL task occurs. These variables may be shared with the previous 
activity using the RECEIVE and RETVALS attributes oftasks. 
When a GOSUB task is specified, attributes of the <ACTION> tag specify how 
variables are communicated between the two activities and where the browser 
should go when the activity is completed. 

Handheld Device Markup Language 
The NEXT and CANCEL attributes of GOSUB specify which card should be shown 
after the DEST card that was specified for the GOSUB activity has been invoked and 
the activity completed. The RECEIVE attribute may be used to assign the variables 
used by the browser to contain results once the activity is completed. 
Whether the activity ends with a CANCEL or a RETURN task, the variables speci-
fied by the RECEIVE attribute of the GOSUB task can be set using the value of 
RETVALS. The attribute RECEIVE contains a semicolon-delimited list of variables 
whose values the client will return, and RETVALS contains semicolon-delimited 
values. In other words, you can specify values by their variable names using 
the RECEIVE attribute, and you can specify returned values themselves using the 
RETVALS attribute. The first value in RETVALS is stored in the first variable in 
RECEIVE, the second value in the second variable, and so on. 
Listing C-1 shows an example of two activities, called home and sub. 
Listing C-1. Home and Sub 
<HDML VERSION=3.0> 
<DISPLAY NAME="home"> 
<ACTION TYPE=ACCEPT TASK=GOSUB DEST="#sub" 
NEXT="#next" CANCEL="#cancel" 
RECEIVE="result; "> 
This is a specific activity, like reading message headers. 
</DISPLAY> 
<DISPLAY NAME="next"> 
<ACTION TYPE=ACCEPT TASK=GO DEST="#home"> 
You've returned from the nested activity.<BR> 
result is $result. 
</DISPLAY> 
<DISPLAY NAME="cancel"> 
<ACTION TYPE=ACCEPT TASK=GO DEST="#home"> 
You've cancelled the nested activity.<BR> 
result is $result. 
</DISPLAY> 
<DISPLAY NAME="sub"> 
<ACTION TYPE=ACCEPT LABEL="Return" TASK=RETURN 
RETVALS="result;"> 
<ACTION TYPE=SOFT2 LABEL="Cancel" TASK=CANCEL 
RETVALS="cancel;"> 
This is a nested activity. 
</DISPLAY> 
</HDML> 
Figure C-3 shows the how the display screen will appear as the browser 
enters each of the activities and the variables are reset accordingly. When the 
353 

AppendixC 
354 
deck is first opened, home is the current activity. Pressing the ACCEPT key cre-
ates a new activity, the sub activity, which will set a return value to either 
"result" or "cancel". The user can exit this activity by pressing either ACCEPT 
(which is assigned to the RETURN task) or SOFT2 (which has been assigned to the 
CANCEL task). 
This is a 
specific 
activity, like 
readinq messaqe 
ders. 
've returned 
from the nested 
activity. 
result is result. 
Figure C-3. Flow between activities 
You've cancelled 
the nested 
activity. 
result is . 
It is important to remember that HDML provides support for activities 
through the activity stack, a hidden part of the implementation of the HDML 
browser, and the navigation task GOSUB. This stack contains each activity's vari-
able context, RECEIVE and RETVALS, NEXT URL, and related information. There are 
no explicit tags that specify an activity, its bounds, or how or where it can be 
invoked. Thus, using activities in HDML can be a little like object-oriented pro-
gramming in a procedural language-you can do it, but the language does not 
offer any concrete mechanisms to help. 
The GOSUB task always starts a new activity, using system resources in the pro-
cess. Be sure therefore that when a GOSUB task invokes a deck, it returns control to 
the calling deck with either a RETURN or a CANCEL task to end the new activity. 
Similarly, avoid using RETURN or CANCEL tasks in decks that can be accessed by GO, 

Handheld Device Markup Language 
as they will end the current activity and may cause the browser to return to an 
activity other than one you intend. 
Managing User Input 
HDML supports both single-choice menu selections and text or numeric input. 
The <CHOICE> and <ENTRY> tags present input choices and accept input from the 
user. Table C-5 summarizes the tags and attributes for input handling in HDML. 
Table C-5. Tags for Card Input 
TAG 
<CHOICE> 
<CE>* 
<ENTRY> 
ATIRIBUTE 
DEFAULT 
KEY 
!DEFAULT 
IKEY 
METHOD 
VALUE 
DEFAULT 
EMPTYOK 
FORMAT 
KEY 
NO ECHO 
• This is an empty tag. 
PURPOSE 
Indicates a choice card 
Specifies a default choice if the 
variable named by KEY is empty 
Specifies the variable to contain the 
choice's VALUE attribute 
Specifies a default choice by index if 
the variable named by IKEY is empty 
Specifies what variable is to contain 
the choice's index 
Indicates whether the list should be 
numbered or unnumbered 
Indicates that this item is a choice 
that may be selected 
Specifies the value of a choice item 
Indicates an input card 
Specifies a default value if the 
variable named by KEY is empty 
When true, allows empty inputs 
Specifies what kind of input is valid 
for the entry card 
Specifies a variable to contain the input 
When TRUE, blocks input echo to the user 
355 

AppendixC 
356 
The Choice Card 
The <CHOICE> tag creates a card that presents a menu of choices, like the one 
shown in Figure C-4. The user navigates among the choices on the screen using 
the arrows or number keypad, then presses the OK button when the browser 
highlights the desired choice. Cards featuring this tag are called choice cards. 
Figure C-4. A choice card 
Enter your 
dest:'..nat:'..on by: 
1 City & State 
2.-z·p code 
The attributes of the <DISPLAY> tag also apply to the <CHOICE> tag; it also has 
several more attributes that control the behavior of the choice interface. 
Every <CHOICE> tag must contain at least one <CE> tag to indicate choices to 
the user. In the following example, the browser records the user's selection in 
a variable indicated by the <CHOICE> tag: 
Openwave <CHOICE NAME="InputChoice" 
KEY=choice IKEY=num DEFAULT=zip> 
Enter your destination by: 
<ACTION TYPE=ACCEPT TASK=GO DEST="#$num"> 
<CE VALUE=city>City & State 
<CE VALUE=zip>Zip code 
</CHOICE> 
In this example, the <CE> tag declares two choices. The first is the value city, 
and the second is the value zip. The user's selection is returned in the HDML 
variable named choice, and the index of the choice (counting from 1) is returned 
in the HDML variable num. Thus, if the user selects the first choice, the value of 
the HDML variable choice will be city, and the value ofnumwill be 1. If he or she 
picks the second choice, choice will be zip, and num will be 2. 
The attribute KEY of the <CHOICE> tag names a variable that will contain the 
user's selection. The browser will assign this variable whatever value is contained 
in the VALUE attribute of the selected choice. Similarly, the IKEY attribute names 
the variable to contain the index of the selected item. The KEY attribute is best 

Handheld Device Markup Language 
used to assign human-readable values to variables for display in the current deck 
(such as phone numbers, prices, and so on), and the IKEY attribute can be used 
to return menu choices to a server for processing. 
You can present two kinds of choices in HDML: numbered and unnumbered. 
By default, choices are numbered, and the user can make a selection with the 
appropriate number key. If, however, you set the METHOD <CHOICE> attribute to 
ALPHA, the choices will be displayed without numbers, and the only way to select 
an item will be to scroll to it and press the ACCEPT key. Although there might be 
stylistic reasons for wanting a menu of choices without numbers, do not be too 
quick to create one. Unnumbered choices require the user to scroll through a list 
and enter multiple keystrokes and are therefore much slower to use than nuni-
beredones. 
The DEFAULT and IDE FAULT attributes of the <CHOICE> tag select an initial 
choice. If the variable assigned to the KEY or IKEY attributes does not have a value 
when the choice card is invoked, the DEFAULT and IDEFAUL T attributes specify the 
default item by name or index, respectively. For example, the previous HDML 
deck used the DEFAULT =zip attribute to indicate that, by default, the second item 
should be chosen. This could also have been done by providing the attribute 
IDE FAULT =2. 
Choices are specified using the <CE> tag. At least one <CE> tag must be 
included in each <CHOICE> tag, although normally, of course, there are at least 
two. The <CE> tag specifies how the choice will be labeled, along with its value 
and, optionally, a task to be performed if it is selected. 
Most <CE> tags are simple, like the one shown in the previous city and ZIP 
code example. The VALUE attribute of a <CE> tag specifies the value assigned to the 
KEY variable when the user makes his or her choice. This value can be used else-
where in the stack or posted to the server where the content originates to be 
processed. 
More complex <CE> tags contain a TASK attribute. The <CE> tag accepts all of 
the same attributes used to modify task behavior that the <ACTION> tag does (see 
Table C-4). For example, the following tag causes the browser to navigate to 
another deck named on the current origin server if the user selects the option 
labeled football: 
<CE VALUE="football" TASK=GO DEST="football.hdml"> 
<IMG ICON="football"><TAB>Football News 
357 

AppendixC 
358 
The Entry Card 
The <ENTRY> tag creates a card, commonly called an entry card, with a single entry 
field. (See Figure C-5 for an example.) 
Who are you qonna 
ca :? 
(aool 555-12 I 
Figure C-5. An entry card 
Input from the user may be numeric, alphanumeric, or constrained to cer-
tain kinds of characters. Like the <CHOICE> tag, the <ENTRY> tag declares a separate 
card and accepts all of the same attributes as does the <DISPLAY> tag. This card 
prompts the user for a ZIP code, then the browser downloads a new deck created 
by the Common Gateway Interface (CGI) weather on the remote server using that 
ZIP code: 
<ENTRY MARKABLE=FALSE NAME="2" KEY=zip FORMAT=NNNNN> 
<ACTION TYPE=ACCEPT TASK=GO DEST="weather?zip=$zip" > 
Zip: 
</ENTRY> 
The <ENTRY> tag uses the KEY and DEFAULT attributes in the same manner 
as the <CHOICE> tag does. The KEY attribute specifies the destination variable for 
the input, and the DEFAULT attribute specifies a default value in the event that the 
destination variable was empty when the entry card was drawn. 
By default, an entry card's action will be performed, and the browser will 
navigate to a subsequent card, only if the user provides some input. The EMPTYOK 
attribute-if set to TRUE-indicates that an action or navigation may occur even if 
no input was made. 
The NOECHO attribute prevents entered data from being displayed. The use of 
this tag is a matter of some debate, however. Many developers think it is appro-
priate to disable the display for sensitive input such as passwords or access 
codes, and others argue that a phone display's small size makes it easy for the 
user to enter sensitive information discreetly and that not echoing input detracts 

Handheld Device Markup Language 
from a deck's user interface. For those who choose to use it, the tag is available. 
By default, the NOECHO attribute is FALSE, but when it is set to TRUE, entered char-
acters will not be displayed to the user; instead, a character such as *will be 
displayed to mask user input. 
The FORMAT attribute is the most important <ENTRY> attribute you will use. It 
defines a format specifier, which is used by the HDML browser to validate input 
before allowing the user to continue. This specifier can include the following: 
• Integers, which specify the number of characters that should match a spe-
cific type. 
• Asterisks, which indicate that an arbitrary number of characters should be 
allowed. 
• One-letter type declarations, which indicate the permitted type(s) of 
input. (Table C-6lists possible type declarations.) 
Table C-6. Character 'I}tpe Definitions for HDML Input Specifiers 
CHARACTER 
A 
a 
M 
m 
N 
X 
X 
ALLOWED INPUT TYPE 
Any symbolic or uppercase alphabetic character 
Any symbolic or lowercase alphabetic character 
Any symbolic, numeric, or uppercase alphabetic character 
(changeable to lowercase)-for multiple character input, defaults to 
uppercase first character 
Any symbolic, numeric, or lowercase alphabetic character 
(changeable to uppercase)-for multiple character input, defaults to 
lowercase first character 
Any numeric character 
Any symbolic, numeric, or uppercase alphabetic character (not 
changeable to lowercase) 
Any symbolic, numeric, or lowercase alphabetic character (not 
changeable to uppercase) 
For example, if the required input was a United States XIP code, you could 
use the input specifier SN to restrict allowable input to exactly five numeric char-
acters; for a United States two-letter state code, you might make the input 
specifier 2A. 
359 

AppendixC 
360 
You can also use characters in the format specifier to format user input. For 
example, the input specifier \(NNN\)\ NNN\-NNNN accepts a phone number with 
area code. The display will begin with a leading parenthesis. Once three digits 
have been entered, a closing parenthesis will be displayed. After another three 
digits have been entered, a hyphen is displayed, and then the user can enter the 
final four digits. 
The following card shows this input specifier in action, prompting the user 
for a phone number: 
<HDML VERSION=3.0> 
<ENTRY KEY=phone FORMAT="\(NNN\)\ NNN\-NNNN"> 
<ACTION TYPE=ACCEPT TASK=CALL NUMBER=$phone> 
<ACTION TYPE=SEND TASK=CALL NUMBER=$phone> 
Who are you gonna call? 
</ENTRY> 
</HDML> 
Integrating Actions and Input 
Actions are closely related to input. IfHDML did not make it possible send user 
input to servers for processing, then the input would have little purpose. 
Similarly, actions are mostly useful for purposes of navigation based on 
user choices. 
HDML variables provide the link between actions and input. Through vari-
ables, user input is collected and verified; these variables are then sent to the 
origin server through an action for processing. Origin servers can format their 
responses as simple HDML decks or use variables again to enable dynamic con-
tent display. HDMI:s use of variables is, in a way, similar to that of programming 
languages, a fact best demonstrated by means of an example. 
The weather example presented in this chapter uses variables to return 
the user's location to the origin server. Both the city I state and zip code inputs 
use the hidden result card to request the weather results. This hidden card 
merges the variables entered by the user and posts them to the origin server for 
processing (see Listing C-2). 
Listing C-2. Using a Hidden Card to Post Data to the Origin Server 
<HDML VERSION=3.0> 
<DISPLAY NAME="home" TITLE="Weather" MARKABLE=TRUE> 
<- Home card display here -> 
</DISPLAY> 

Handheld Device Markup Language 
<CHOICE MARKABLE=FALSE NAME="InputChoice" 
KEY=zip IKEY=num IDEFAULT=2> 
<ACTION TYPE=ACCEPT TASK=GO DEST ="#$num"> 
Enter your destination by: 
<CE VALUE=city>City & State 
<CE VALUE=zip>Zip code 
</CHOICE> 
<ENTRY MARKABLE=FALSE NAME="1" KEY=city FORMAT=*M> 
<ACTION TYPE=ACCEPT TASK=GO DEST=#state> 
City: 
</ENTRY> 
<ENTRY MARKABLE=FALSE NAME="state" KEY=state FORMAT=AA> 
<ACTION TYPE=ACCEPT TASK=GO DEST=#result> 
State: 
</ENTRY> 
<ENTRY MARKABLE=FALSE NAME="2" KEY=zip FORMAT=NNNNN> 
<ACTION TYPE=ACCEPT TASK=GO DEST=#result> 
Zip: 
</ENTRY> 
<NODISPLAY NAME="result"> 
<ACTION TYPE=ACCEPT TASK=GO 
DEST="http://masamune.lothlorien.com/wx" 
METHOD= POST 
POSTDATA="choice=$num&city=$city&state=$state&zip=$zip"> 
</NODISPLAY> 
<IHDML> 
The action for the hidden card result collects the user's input into a single 
POST request sent by the client to the server. The server-side script then uses the 
values provided to create and return a deck with the desired information. 
In listing C-2, the deck's interaction with the server occupies its own card. 
The deck could also have been written with the server interaction taking place 
over several cards, as shown in listing C-3. 
Listing C-3. Server Interaction Across Several Cards 
<ENTRY MARKABLE=FALSE NAME="state" KEY=state FORMAT=AA> 
<ACTION TYPE=ACCEPT TASK=GO 
361 

AppendixC 
362 
DEST="http://masamune.lothlorien.com/wx" 
METHOD= POST 
POSTDATA="choice=$num&city=$city&state=$state&zip=$zip"> 
State: 
</ENTRY> 
<ENTRY MARKABLE=FALSE NAME="2" KEY=zip FORMAT=NNNNN> 
<ACTION TYPE=ACCEPT TASK=GO 
DEST="http://masamune.lothlorien.com/wx" 
METHOD= POST 
POSTDATA="choice=$num&city=$city&state=$state&zip=$zip"> 
Zip: 
</ENTRY> 
</HDML> 
Although this version may make more sense at first and may be slightly faster 
to create, the approach chosen in Listing C-2 is easier to debug and maintain. If 
you keep input cards separate from navigation, you will only need to change 
a single card if your origin server URL changes. 
Designing an HDML User Interface 
One benefit of HDML is how relatively consistent the hardware on which it is 
available is. Most phones running the Openwave browser share a large number 
of characteristics, which together represent the notion of an abstract phone, 
including the following: 
• A fixed-width display, at least four lines deep and 12 characters across 
• Support for vertical scrolling 
• Support for the ASCII character set (uppercase and lowercase) 
• Numeric and alphanumeric character entry and editing 
• Choice selection via an arrow keypad, numeric keys, or rocker switch 
• Keys providing functionality for ACCEPT and PREV (to move forward and 
back between screens) 
• One or two programmable soft keys with LCD labels 

Handheld Device Markup Language 
At a minimum, all wireless handsets that can browse HDML share these 
characteristics. A few may have more features, but if you are developing content 
for these devices, you should not assume a higher level of functionality than what 
is outlined here. 
In addition to the constraints of the handheld client, it is possible for the 
Openwave server to impose additional restrictions of its own. Most importantly, 
current versions of the Openwave server cannot transmit HDML decks larger 
than 1,492 bytes to browsers. Decks larger than this generate an error in the 
Openwave server. Because the server's manipulation of a deck can change its size 
slightly, decks slightly smaller than this limit may also fail. To be safe, keep all 
uncompiled decks fewer than 1,200 bytes. If this challenge sounds onerous, bear 
in mind that 1K of data on a screen phone is quite a bit-it can represent up to 21 
screens of content! 
Cards and Decks 
Wrreless handsets are not suitable tools for browsing long passages of text. Long 
runs of text are best avoided in HDML documents (as in WML ones), but if they 
are necessary, they should be broken up and presented on several different cards. 
When the phone shows multiple cards, the default key should move the user to 
the next card, and navigating backward should be accomplished by the handset's 
PREV key, not by a soft key. 
As with HDML (and even wireless HTML), less is truly more. A deck should 
be simple, and content kept brief. Screens are small and bandwidth precious, 
making brevity necessary. 
Tasks and Actions 
You can assign the functions to be performed by soft keys within HDML content. 
By convention, the first soft key should always be assigned to the default option, 
and the second one reserved for less common operations, such as Menu, Delete, 
or Home. (One secondary action that does not belong on a soft key is a link to 
user help-use HDML's HELP action.) When many functions are available at one 
time, the best solution is to label the second soft key simply Menu and offer the 
user a list of choices. 
You can override several hardware keys on a Openwave phone. When reas-
signing built -in keys, think carefully about what the user will expect when using 
your deck. Assign keys in such a way as to extend and integrate the phone's func-
tionality with your deck, rather than to try to tailor its behavior to meet your 
expectations. Rewiring the phone's SEND button, which ordinarily is used to 
make a call, to display a help message will not only be difficult to use but outright 
363 

AppendixC 
364 
annoying to most users. A better use of the SEND key, for example, is to map it to 
dial the number currently displayed on a card. 
Data Input 
HDML content must enable data entry, of course, but keep in mind that data 
entry on wireless phone handsets is always time-consuming and frustrating. Limit 
users' need to enter data by providing lists of choices wherever possible. Even 
these lists should be brief, preferably including fewer than seven items each. 
Where text entry is unavoidable, use format specifiers to restrict input to the 
kinds of characters required. For example, because it makes no sense for a user to 
enter alphabetic characters in a United States ZIP code, it is best to restrict entry 
to digits, to help prevent users from entering a letter in error, using format 
specifiers. 
Displaying Images 
As not all HDML devices can display images, they should be used sparingly if at 
all in HDML-based content. Include an image in a deck only if it carries a mean-
ing that text cannot. Every image should be accompanied (using the AL T 
attribute) by a text legend detailing the its meaning. These guidelines are identi-
cal to the guidelines for using images with WML and HTML content. 
Bookmarks 
Bookmarks provide a quick way for users to return to a commonly viewed card-
just as desktop-browser bookmarks enable easy access to commonly viewed pages. 
Dynamic content, however, should not be bookmarked. If a page was gener-
ated using input from a form, for example, you would want to make only the 
beginning of the form interface markable, not the end results-this way, you can 
ensure users cannot make the mistake of bookmarking the wrong page. 

Handheld Device Markup Language 
Summary 
HDML provides a rich alternative to HTML for content intended for screen 
phones and similar devices. Although HDMI:s organization and syntax predate 
WML, the two languages share many concepts, making it easy for developers to 
create both HDML and WML content for the same service. 
Like WML, HDML presents content in decks of cards. Cards may contain text, 
choice lists, or user input. Navigation between cards and other activities take the 
form of tasks, which can be bound to interface controls such as the phone's 
ACCEPT key or a soft key. Using tasks and variables that contain strings, decks 
can collect and validate input from a user, perform simple operations, and dis-
play the results. 
Although HDML is a flexible language capable of some complexity, it is best 
to keep decks simple. Users usually interact with them with one hand in a variety 
of settings that divide their attention among several tasks. With this in mind, you 
should organize decks according to the activities they help a user to perform and 
provide only the information that is necessary during a particular transaction. 
Do not use images unless you are sure they are worth the size they occupy. 
When choosing an image, be sure to see if the phone provides one you can use 
through the <IMG> ICON attribute. And, of course, avoid user input unless it is 
absolutely necessary. 
365 

Index 
Symbols 
$ (dollar sign) in PHP, 95 
%Device tag, 173 
%Location tag arguments, 17 4 
%Zipcode tag, 17 4 
*I, 94 
/*, 94 
II, 94 
<?php tag, 92, 93 
?> tag, 92, 93 
[](index operator), 96 
_(underscore) as PHP variable identi-
fier, 95 
A 
abstract phone, 362 
accessterminals,4 
<ACTION> tag in HDML, 347-348, 
350-351 
actions 
designing HDML user interface for, 
363-364 
inHDML,347 
integrating input and, 360-362 
spanning entire deck, 350-353 
active server technology. See server-side 
content management 
activity stack, 354 
activity view in UML, 333 
<address> tag, 285 
Advanced Mobile Phone System 
(AMPS),2 
aligning text, 152-153 
AMPS (Advanced Mobile Phone 
System), 2 
analog cellular, 2 
Apache Web server, 72-86 
about, 72-73,90 
conditional flow control by variables, 
78-79 
configuring output format, 
74-75 
executing external scripts, 77 
including other content, 77 
managing client-specific content 
with server directives, 79-86 
reporting file size, 75 
server directives, 73-79 
server parsing, 73 
tracking file modifications, 75-76 
variables in server directives, 77-78 
Apache Web server. See also server direc-
tives in Apache 
Apache Web site, 322 
apparent throughput, 37 
applications. See also i-mode appli-
cations; WCA 
complexity of wireless, 307 
creating first page in HDML, 337-338 
creating "Hello World" in WML, 
208-209 
development cycle for wireless, 308 
DTD for Xl\tiL, 122-127 
mobile, 69-72 
motivations for creating custom, 
303-306 
network support for third-party 
developers, 316-317 
overcoming technical limitations in 
custom, 305-306 
query, 170-171, 180 
for RPN calculator (WMLScript), 
250-253 
types ofWCA, 169-171 
WAP applications in WML, 205 
Xl\tiL,121 
APRS/FIND application. See also build-
ing APRS wireless Web site 
aboutAPRS, 101 
illustrated in Internet Explorer, 113 
response from, 179 
viewed in Handspring Blazer, 113 
inWCA, 177-179 
architecture 
fori-mode applications, 181-183 
push,279-281 
of synchronized browsers, 290 
WCA, 169-171 
ARDIS network, 2 
367 

Index 
368 
arithmetic operators in PHP, 94 
arrays 
associative arrays, 95 
in PHP, 95-96 
attributes 
attribute types for XML elements, 125 
data types for XML Schema, 129 
for form input in HTML, 163 
ofHDML <ACTION> tag, 348 
of HDML cards and decks, 339-342 
for HTML text block alignment, 
152-153 
for tables in HTML, 159 
ofWML <card> tags, 216 
ofWML tags, 211 
ofXML tags, 119 
Automatic Position Reporting System 
(APRS), 101. See also building 
APRS wireless Web site 
AvantGo, 291-300 
B 
creating channels, 295-296 
developer resources for, 320 
example of APRServe data in, 
296-300 
fields defining channels in, 296 
marking content for, 295 
organizing content for channels in, 
293-294 
service provided by, 292-293 
technology for, 291-292 
bandwidth, 29-30 
latency and, 29, 30 
overview, 29 
throughput affected by, 30 
user interface and, 35 
<BASE> tag, 139-141 
base stations, 4 
base URLs in heading, 139-141 
bearer networks, 191-192 
blocks 
paragraph tagging, 144 
tags for preformatted text, 144 
Bluetooth, 315 
BMP file format, 57-58 
body of HTML documents 
block quotes, 145 
creating section heads, 141-142 
defined, 136 
definition lists, 148-149 
formatting text blocks, 142-145 
lists, 145-147 
menus, 148 
tags for wireless Web text blocks, 143 
bookmarks in HDML, 364 
boolean operations in WMLScript, 260 
boolean types in WMLScript, 257 
branding of custom interfaces, 305 
break(<BR/>)tag,118-119 
BREW; 311, 324 
browsers. See also Handspring Blazer; 
Microsoft Internet Explorer 
for Pocket PC 
AvantGo, 292 
compact binary representation of 
WMLScript, 249 
display parameters for wireless, 
47-48 
font selection for user interface, 38 
HDML, 338-339 
HTML versions recommended for 
wireless, 136 
interpretation of layout, 43 
latency and, 36-37 
PHPscriptingforHTML, 109-114 
role in wireless user interface, 37-38 
synchronizing Web content, 289-291 
tags unsupported by wireless, 141 
viewingWML content in, 209-210 
building APRS wireless Web site 
client identification with PHP, 
106-109 
defining map function, 111-112 
functions used to generate result 
data, 103 
response generation in locate.php 
script, 103-106 
script organization, 101-103 
viewing server's response with 
browsers, 113 
bulleted lists, 64 
buttons,46 
c 
caching, H'ITP, 52 
cards 
about decks and, 205-206 
attributes ofWML <card> tag, 216 
formatting text regions and align-
menton,242 
HDML 
about,339 
attributes of, 339-340,341-342 
bookmarks in, 364 
choice cards, 356-357 
designing user interface for, 363 
entrycards,358-360 
tags for card input, 355 
tags for formatting, 343 

types of, 342 
in WML, 216-217 
case sensitivity 
inPHP, 95 
ofWML tags, 211 
ofXML, l18 
CDMA (Code Division Multiple Access) 
defined, 6 
overview, 7 
security and, 59 
spread-spectrum technology and, 
6-7 
CDPD (Cellular Digital Packet Data) 
as bearer network, 191 
defined,3 
FDMA and TDMA used with, 6 
cell,4 
cell phones 
cellular radio communications and, 4 
demand for, 11 
Cellular Digital Packet Data. See CDPD 
cellular radio communications, 3--4 
cellular telephone networks 
data exchange in wireless networks, 9 
initial information exchange within, 
8-9 
movement monitoring and intersys-
tem handoff, 9 
origins of, 2 
simplified diagram of, 8 
channel subscription, 295 
channels in AvantGo 
creating, 295-296 
example of, 296-300 
fields defining, 296 
organizing content for, 293-294 
synchronized browsers and, 290 
characters 
character type definitions for HDML 
input specifiers, 359 
HDML special, 346-347 
sequences and characters in 
WMLScript, 256 
WML reserved, 212 
check boxes, 45 
choice card, 356-357 
cHTML,21-22 
cjpeg development tools, 320 
class views in UML, 332-333 
clients 
display parameters for wireless, 
47-48 
providing HTML meta information 
to, 138-139 
push architecture and wireless Web, 
280 
typical display parameters for wire-
less, 48 
WML designed for constrained, 204 
client-server model 
sample client and server exchange in 
HTTP, 50-51 
standards for Web deployment, 
19-20 
client-side tools, 319-322 
collaboration views in UML, 333 
collecting user input for forms, 162-165 
comments 
denoting in XML, l19 
marking in PHP, 94 
compact binary representation of 
WMI.Script, 249 
component views in UML, 329-330 
conditional flow control 
by PHP statements, 97 
by variables, 78-79 
configuring Apache output format, 
74-75 
content. See also server-side content 
management; writing 
fori-mode applications, 183-189 
checking on simulated user's envi-
ronment, 46-4 7 
content reduction in Spyglass Prism, 
87 
developing 
dynamic WMI.Script, 248, 276-277 
new wireless, 14 
inWCJ\, 169,170-177 
displaying text, 60-61 
formatting 
limitations for handheld devices, 
20-21 
for readability, 42 
marking for AvantGo, 295 
need for synchronized, 290-291 
opportunities for wireless, 12-13 
organizing for channels in AvantGo, 
293-294 
providers for wireless networks, 13 
push, 279-289 
about,281 
controlling the push mechanism, 
284-289 
developing content for AvantGo, 
291-300 
format for, 281-282 
push architecture, 279-281 
push request and response in WAP, 
282-284 
synchronizing Web content, 
289-291 
Index 
369 

Index 
370 
content (continued) 
separating into data and format sets, 
70-71 
synchrorrlzll1g~eb,289-291 
WML 
capability of dynamic content, 205 
efficiency of, 204 
viewing in, 209-210 
WMLScript application for RPN cal-
culator, 250-253 
content providers, 13 
continue statements in WMLScript, 264 
custom applications, 303-318 
D 
branding and custom interfaces, 305 
choosing mobile computing platform 
for, 309-313 
legacy system interfaces and, 304 
motivations for creating, 303-306 
overcoming technical limitations, 
305-306 
overview, 303 
pitfalls of, 306-309 
selecting wireless network, 313-317 
server platform selection for, 317 
data 
bandwidth and data mobility, 35 
data exchange in wireless 
networks,9 
data types for XML Schema, 129 
identifying database interfaces for 
server-side scripting, 71-72 
initial information exchange within 
cellular systems, 8-9 
input methods for, 44-46 
subscribers' perception of data 
mobility, 16-17 
trends toward data mobility, 33-34 
data abstraction, 106 
data validation 
in i-mode and walled garden, 
182-183 
in WMLScript, 247-248 
datagrams, 191 
DatePicker ~CA form, 175 
debugging WMLScript, 274-276 
decks 
about cards and, 205-206 
HDML 
about, 339 
actionsspanning,350-353 
attributes of, 339-341 
designing user interface for, 363 
organizing by activities, 352-355 
WML 
declaring variables in, 211-212 
document headings for, 214-216 
events and tasks in, 212 
organization of, 213 
XML prologue for, 213-214 
definition lists in HTML text, 148-149 
deployment models 
i-mode, 22, 182 
deployment views in UML, 327-328 
for HDML services, 336 
of network supporting~AP push, 280 
~AP,24 
~eb, 19 
development. See also building APRS 
wireless ~eb site; UML 
client-side tools, 319-322 
complexity of application, 307 
creating first page in HDML, 
337-338 
cycle for wireless applications, 308 
of dynamic WMLScript content, 248, 
276-277 
further reading for UML developers, 
333 
mobilesoftNvareresources,323-324 
network support for third-party 
developers, 316-317 
of new wireless content, 14 
resources for ~AP specifications, 
319 
server-side tools, 322-323 
tools fori-mode application, 183-184 
tools forXH1ML-MP, 194 
of~CAcontent, 169,170-177 
ofWML, 22-24 
WML vs. HDML, 337 
ofWMLScript, 247 
Dialogs library, 266, 271 
document headings 
fori-mode applications in H1ML, 
184-185 
about, 136-137 
base URLs in, 139-141 
meta information for, 138-139 
for~ decks, 214-216 
Document Type Definition. See DTD 
documents. See also document headings 
creating section heads, 141-142 
documentheadings,136-137 
HDML tags, 338 
hyperlinks in WML, 220 
lists, 145-147 
menus, 148 
organization of in WML, 213-217 
paragraph tagging, 144 

quotations in HTML, 145 
specifying titles of, 137 
tags for preformatted text, 144 
XHTML-BP tags for headings, 
195-196 
do-while statements, 99 
DTD (Document Type Definition), 
122-127 
sample weather listing in, 126-127 
syntax for, 123-124 
dynamic content. See also content; 
WMLScript 
E 
generating in WMLScript, 248, 
276-277 
in~CJ\,169,170-171 
ECMAScript, 248-249 
emptytagsinXML, 118-119 
entities inXML, 117-118 
entry card, 358-360 
events, 224-230 
decks,212 
onenterforward and onenterback-
ward, 224-225 
onpick event using <select> tag, 
225-227 
on timer, 227-228 
types of, 224 
~AP interface elements used in, 
228-229 
eXtensible HyperText Markup Language. 
SeeXHTML; XHTML-BP; 
XH1ML-MP 
eXtensible Markup Language. See XML 
F 
fast-frequency hopper, 7 
FDMA (Frequency Division Multiple 
Access), 5 
FHMA (Frequency Hopped Multiple 
Access), 6-7 
file formats 
BMP,57-58 
GIE56 
JPEG,57 
PICT, BMP, XBM, and PNG, 57-58 
Float library, 266, 268 
floats in WMLScript statements, 256 
fonts 
font selection in WML, 38 
raw typographic styles in HTML, 
150-152 
specifyingtextstyles,149-153 
style properties in XHTML-MP, 201 
tags for idiomatic typography in 
HTML,150 
for statements in WMI.Script, 263-264 
form data, 50 
format specifier, 359 
formatting 
content for readability, 42 
format for push content, 281-282 
HDML text, 344 
HTML 
raw typographic styles, 150-152 
tags for preformatted text, 144 
text blocks, 142-145 
text styles, 149-153 
limitations for handheld devices, 
20-21 
WML,239-245 
image display, 244-245 
tables, 242-243 
tags,240 
text regions and alignment on 
cards,242 
typography, 241-242 
forms, 160-165,232-239 
DatePicker and TimePicker ~CJ\, 
175 
displaying, 61--63 
HTML 
attributes for input, 163 
collecting user input for forms, 
162-165 
defining,161-162 
formtags,160-161 
WML 
sample listing of forms input, 
236-237 
tags used in, 232-233 
type mask in, 234 
inXHTML-MP, 198 
frames, 6 
framesets, 55 
Frequency Division Multiple Access 
(FDMA),5 
functions 
defining in PHP, 96-97 
in Dialogs library, 266, 271 
in Float library, 266, 268 
generating result data for APRS 
wireless ~eb site, 103 
identifiers namingWMLScript, 
257-258 
in Lang library, 266, 267-268 
in String library, 266, 269-270 
in WMLBrowser library, 266, 272 
WMI.Script, 254, 264-265 
Index 
371 

Index 
372 
G 
Gateway Server in push architecture, 
280 
GET method (HTTP), 51-52 
GIF format standards, 56 
Global Service for Mobile (GSM) net-
work,3 
global variables in PHP scripts, 96 
graphics 
bullets and spacers, 64-65 
displaying images, 63-64 
GIF standards for Web, 56 
guidelines for using, 40-41 
JPEG file format for, 57 
logo images, 65 
monochrome, 41 
PICT, BMP, XBM, and PNG image 
formats, 57-58 
growth 
potential for wireless data market, 
32-33 
in wireless Web access, 11 
GSM (Global Service for Mobile) net-
work,3 
H 
Handheld Device Markup Language. See 
HDML 
handheld devices 
i-mode architecture and, 181-183 
advantages ofiiTML for, 135 
brevity of pages for, 42 
customizing hardware for wireless 
access, 25-26 
development cycle for applications, 
308 
emerging user interface paradigm for 
wireless screen phones, 206 
evolving tools and technologies for, 
307 
example Of channel in AvantGo, 
29~300 
formatting limitations for, 20-21 
IITML tags to avoid, 165-166 
Openwave browser's concept of 
abstract phone, 362-363 
product integration and, 308--309 
typical display parameters for, 48 
usage patterns of, 31-32 
versions ofiiTML for, 135-136 
writing for wireless, 42 
handheld platforms, 309-313 
Java 2 Micro Edition, 312 
MicrosoftWmdows CE, 311 
overview, 309 
Palm Computing Platform, 310 
Qualcomm BREW; 311, 324 
Symbian, 312 
traditional desktop systems as, 313 
HandheldFriendly tag, 138 
handoff,9 
Handspring Blazer 
anchors, links, and <IMG> tag in, 155 
attributes for IITML text block align-
ment, 152-153 
blocks oftext in, 143 
creating lists for, 145-147 
forms and user input, 165 
HTML for Pocket PC, 135 
section heads displayed in, 142 
viewing APRS/Find in, 113 
hardware 
customizing for wireless access, 25-26 
gap between handheld and desktop 
computing capacities, 17-18 
integrating mobile client with wire-
less networks, 315 
laptops,28 
personal digital assistants, 27-28 
smart phones, 2~27 
super phones, 26 
HDML (Handheld Device Markup 
Language),24-25,335-365 
about, 335-336 
browsers, tools, and SDKs for, 
338--339 
cards and decks 
about,339 
actions spanning entire deck, 
350-353 
attributes of, 339-342 
organizing decks by activities, 
352-355 
types of cards, 342 
creating first page in, 337-338 
designing user interface in, 362-364 
displaying 
images, 345-346 
special characters, 34~347 
formatting text, 344 
managing user input, 355-362 
character type definitions for 
HDML input specifiers, 359 
choice card, 35~357 
entrycard,358-360 
integrating actions and input, 
360-362 
tags for HDML card input, 355 
presentingtext,343-344 
server-side scripting with, 67--68 
tags for displaying information, 343 

tasks and actions 
about,347 
assigning tasks, 347-348 
kinds of tasks, 349-350 
WMLvs.,337 
<HEAD> tag, about, 136 
headings 
i-mode tags for, 186 
defined, 136 
document,136-137 
inHTML,55 
indicating base URL in, 139-141 
meta information for document, 
138-139 
"Hello World" 
inHDML, 337-338 
in WML, 208-209 
history of wireless networks, 1-3 
HTML::Clean development tools, 320 
HTML (HyperText Markup Language), 
135-167 
advantages for wireless devices, 135 
aligningtext,l52-153 
comparison of versions, 135-136 
compatibility with WAP protocol 
standard, 192 
creating 
section heads, 141-142 
tables, 156-159 
definitions,l48-149 
document headings for wireless Web, 
136-137 
documenttitlesin,l37 
font selection in, 38 
formatting text blocks, 142-145 
forms, 160-165 
collecting user input for, 162-165 
defining,l61-162 
form tags, 160-161 
hyperlinks and images, 153-156 
indicating base URL in heading, 
139-141 
lists, 145-147 
menus, 148 
meta information for document 
headings,l38-139 
overview, 166-167 
Palm WCAs with content in, 169, 180 
predictability ofWML vs., 204 
quotations in, 145 
raw typographic styles, 150-152 
sample listing of APRServe Find root 
page,298-299 
server-side scripting with, 67--68 
specifying text styles, 149-153 
standardsforWeb,54-56 
tags 
form tags, 160-161 
HTML tags to avoid, 165-166 
for idiomatic typography, 150 
paragraph tagging, 144 
preformatted text, 144 
unsupported by wireless browsers, 
141 
Tidy validation tool, 321 
WCA-specific entities in, 171-176 
WMLvs.,206 
writing fori-mode applications, 
184-189 
XHTML vs., 56 
html-hi-format.php file, 109-111 
html-lo-aprs-image.php script, 114 
HTTP (HyperText Transfer Protocol) 
caching, 52 
GET and POST methods, 51-52 
sample client and server exchange in, 
50-51 
Web standards for, 49-52 
hyperlinks 
HTML, 153-156 
WML,219-221 
HyperText Markup Language. See HTML 
HyperText Transfer Protocol. See HTTP 
I 
IBM WebSphere Transcoding Publisher, 
87 
icons for handheld devices, 40-41 
identifiers 
namingWMLScript variables, 
functions, and pragmas, 
257-258 
PHP, 95 
idiomatic text styles in HTML, 150 
if-else statements 
PHP, 97 
WMLScript, 262 
image maps, 40 
images 
designing 
guidelines for, 40-41,207,244-245 
inHDML,365 
displaying,63-64 
in i-mode applications, 188-189 
in HDML, 345-346 
in HTML, 153-156 
WML formatting for, 244-245 
logo, 65 
PICT, BMP, XBM, and PNG formats 
for, 57-58 
<img> tag, 245 
Index 
373 

Index 
374 
i-mode applications, 181-189 
i-mode heading tags, 186 
i-mode text tags, 186-187 
architecture for, 181-183 
creating content for, 183-189 
deployment models of, 22, 182 
displaying images, 188-189 
overview, 181, 189 
tools for developing, 183-184 
writingHTMLfor, 184-189 
i-mode service, 21-22 
importing files to PHP with include 
function, 100--101 
include function, 100--101 
index operator([)), 96 
industry partnerships in wireless tech-
nology,2-3 
input. See user input 
integers in WMI.Script statements, 255 
interactive tasks and events in WML, 
223-239. See also events; tasks 
navigation tags in tasks, 230--231 
onenterforward and onenterback-
ward events, 224-225 
onpick event using <select> tag, 
225-227 
ontimer events, 227-228 
overview, 223-224 
types of events, 224 
WAP interface elements used in 
events, 228-229 
Internet Movie Database, 13 
<ISINDEX> tag, 141 
J 
J2ME,323 
Java 2 Micro Edition, 312 
jEdit text editor, 320 
JPEG file format, 57 
L 
Lang library, 266, 267-268 
laptops as wireless terminal, 28 
latency 
bandwidth and, 29, 30 
reducing, 36-37 
legacy system interfaces, 304 
libraries forWMI.Script, 265-272 
about, 265-266 
Dialogs, 266, 271 
Float, 266, 268 
functions in URL library, 270--271 
Lang,266,267-268 
native peripheral access and, 248 
String,266,269-270 
WMLBrowser, 266, 272 
<UNK> tag, 141, 199, 202 
lists, 145-147 
bulleted, 64 
creating HTML, 145-14 7 
defirrltion,148-149 
menus, 148 
ordered, 147-148 
pick,44 
unordered, 147 
literals in WMLScript statements, 255 
locate.php script, 103-106 
logo images, 65 
looping 
in PHP, 98-100 
in WMI.Script, 262-264, 277 
M 
markup languages, 19-25 
development ofWML as standard for 
WAP,22-24 
formatting limitations for handheld 
devices, 20--21 
HDML,24-25 
HTML and client-server model, 
19-20 
i-mode service and cHTML, 21-22 
promoting readability of user inter-
face,43-44 
MathML (Mathematics Markup 
Language), 121 
menus, 148 
<META>tagsinHTML, 138-139 
<meta> tags in WML, 215-216 
meta entities in WCAs, 173 
Metrowerks Code Warrior for the Palm 
Powered Platform, 323 
Microsoft Internet Explorer for Pocket 
PC 
anchors, links, and <IMG> tag in, 
155 
attributes for HTML text block align-
ment, 152-153 
blocks oftext in, 143 
creating lists for, 145-147 
forms and user input, 165 
HTML for Pocket PC, 135 
section heads displayed in, 142 
viewingAPRS/Find in, 113 
Microsoft Wmdows CE 
as handheld platform, 311 
software development kit for, 324 
mobile applications 
identifying interfaces, 71-72 

selecting server-side scripting 
solution for, 69 
separate content into data and for-
mat sets, 70-71 
Mobile MapQuest, 13 
model management views in UML, 
331-332 
modules, 72 
monochrome graphics, 41 
Moore's Law, 17 
motivations for custom application 
development, 303-306 
branding and custom interfaces, 305 
legacy system interfaces, 304 
overcoming technical limitations as, 
305-306 
overview, 303-304 
Motorola Web site, 321 
movement monitoring and intersystem 
handoff,9 
MySQL,322 
N 
nameUserAgentfunction, 107-109 
navigation in WML, 217-223 
card timer task, 221 
hyperlinks and tasks, 219-221 
selection lists as navigation task, 
221-223 
tags used in, 218 
Nokia WAP server, 322 
Nokia WAP toolkit, 321 
<noop> tag in WML, 231 
0 
objects in HTTP, 50 
OFX (Open Financial Exchange), 121 
onenterbackward event, 224-225 
onenterforward event, 224-225 
onpick event, 225-227 
ontimereven~227-228 
Openwave 
developer tools, 321 
Openwave Server, 335-336 
WML browser, 210 
operators 
PHP, 94 
in WMLScript, 259-261 
ordered lists, 147-148 
p 
package,331-332 
packets, 5 
packet-switched radio networks, 5 
pages 
brevity of, 42 
creating in HDML, 337-338 
sample listing of APRServe Find root, 
298-299 
Palm 
PRC-tools for, 324 
WCA Builder, 176-177 
WCA viewer, 169-170 
Palm Computing Platform, 310 
Palm.Net wireless service, 13 
Palm Query Application, 169. SeeWCA 
Palm Web Clipping Applications. See 
WCA 
PalmComputingPlatform tag, 138 
PAP (Push Access Protocol), 280 
about push content delivery, 279 
controlling the push mechanism, 
284-289 
format for push content, 281-282 
push architecture, 279-281 
push content, 281 
push request and response in WAP, 
282-284 
status codes in, 286-287 
paragraph tagging, 144 
PCS (Personal Communication Services) 
network,3 
PDAs (Personal Digital Assistants) 
overview of, 27-28 
super phones based on, 26 
synchronized access and, 289 
per-packet latency, 37 
Personal Communication Services (PCS) 
network,3 
PHP91-115 
building APRS wireless Web site in, 
101 
client identification with, 106-109 
conditional flow control with state-
ments, 97 
defining functions in, 96-97 
importing files, 100-101 
looping, 98-100 
overview of, 91-92, 114-115 
presentation for HTML browsers, 
109-114 
resources on, 92 
response generation in locate.php 
script, 103-106 
script organization, 101-103 
scripting with, 92-94 
syntax in, 94 
variables, 94-96 
Web site for, 323 
Index 
375 

Index 
376 
PI (Push Initiator), 279, 280 
pick lists, 44 
PICT file format, 57-58 
pilot releases, 308 
pitfalls of custom applications, 306-309 
challenges of, 306 
complexity of application develop-
ment,307 
development cycle length, 308 
fledgling tools and technologies, 307 
lack of integration, 308-309 
PNG (Portable Network Graphics) file 
format, 57-58 
POST method (HTTP), 51-52 
postfix notation, 254 
PostgreSQL, 323 
PPG (Push Proxy Gateway), 280 
pragmas,257-258 
PRC-tools for Palm Powered Platform, 
324 
prefix notation, 254 
preformatted text, 144 
procedural logic in WMLScript, 249 
procedural statements in WMLScript, 
262-264 
prologue for XML file, 118 
protocols. See also HTTP; PAP; WAP 
compatibility ofWML with WAP, 192 
WAP and SMS, 5 
WDP, 192 
WSP, 192 
Psion, 312 
push,279 
Push Access Protocol. See PAP 
Push Initiator (PI), 279, 280 
Push Proxy Gateway (PPG), 280 
<push-message> tag, 284 
Q 
Qualcomm BREW (Binary Runtime for 
Wrreless) 
as handheld platform, 311 
software development kit and emula-
tor, 324 
query applications, defined, 17Q-171, 
180 
R 
RAM Mobile Data network, 2 
readability 
formatting content for, 42 
of user interface, 43-44 
registration, 8 
reporting file size in Apache, 75 
reserved characters in WML, 212 
resources for wireless developers, 
319-324 
client-side tools, 319-322 
further reading for UML, 333 
mobile software development, 
323-324 
server-side tools, 322-323 
on WAP specifications, 319 
resources on PHP, 92 
<response-result/> tag, 285 
roaming features, about, 9 
RPN (Reverse Polish Notation) calcula-
s 
tor, 249-253 
about Reverse Polish Notation, 254 
sample listing, 25Q-251 
user interface sample listing, 252-253 
sample listings 
APRS/FINDWCA, 178-179 
APRServe Find root page, 298-299 
code for XML weather readings, 53 
creating "Hello World" in WML, 
208-209 
defining map function, 111-112 
DTD weather listing, 126-127 
example ofWML user interface, 
236-239 
hidden card to post data to origin 
server, 36Q-361 
home and sub activities in HDML, 
353-354 
html-hi-format.php file, 109-111 
html-lo-aprs-image.php script, 114 
nameUserAgentfunction, 107-109 
navigation using selection lists in 
WML,222-223 
<noop> tag in WML, 231 
response from APRS/FIND WCA, 179 
for RPN calculator, 25Q-251 
for RPN user interface, 252-253 
sample XML file, 12Q-121 
of server interaction across several 
cards,361-362 
table tags in WML, 243 
using HTTP _USER_AGENT variable, 
8Q-86 
forWML card timer tasks, 221 
for WML hyperlinks, 220 
scalable fonts, 149 
screen phones, 4 
<SCRIPT> tag, 141 
scripts 
executing external Apache, 77 

html-lo-aprs-image.php, 114 
locate.php, 103-106 
organization for APRS wireless Web 
site, 101-103 
PHP scripting for HTML browsers, 
109-114 
Web standards for scripting lan-
guages, 58 
scrolling,39 
section heads in HTML, 141-142 
security for wireless Web, 59 
<select> tag 
onpick event using, 225-227 
forWMLmenus, 218--219 
selection lists as WML navigation task, 
221-223 
sequence views in UML, 330-331 
server directives in Apache, 73-79 
configuring output format, 74-75 
sample listing of, 79-86 
table of, 73-74 
variables in, 77-78 
server-parsing module, 72 
servers 
integrating with wireless networks, 
316 
server parsing, 73 
server platforms for custom appli-
cations, 317 
server-side content management, 67-90. 
See also PHP; server directives 
in Apache 
Apache for, 72--86 
overview, 67,90 
server-side scripting 
about, 67--68 
identifying interfaces, 71-72 
for mobile applications, 69-72 
PHP for, 92-94 
separate content into data and 
format sets, 70-71 
for WCA application, 179 
transcoding server, 86--88 
XML for, 88--89 
service indicator request, 282 
service provider partnerships, 13-14 
Short Messaging Service (SMS), 5 
simulating user's environment, 4 7 
slow-frequency hopper, 7 
smart phones, 25, 26-27 
SmiU'tPhone Emulator Developer 
Edition, 210 
SMS (Short Messaging Service), 5 
software development kits, 319-322, 324 
software for PDAs, 27 
spacers, 64, 65 
special characters, HDML, 346-347 
spidering, 289 
spreading function, 7 
S~assPrism,87--88 
state machine view in UML, 333 
statements 
continue, 264 
do-while, 99 
floats and strings in WMLScript, 256 
for, 263-264 
if-else 
PHP, 97 
WMLScript, 262 
procedural WMLScript, 262-264 
switch-case, 97 
while,264 
inWML,255 
status codes in PAP, 286-287 
String library, 266, 269-270 
strings in WMLScript statements, 256 
structure ofWMLScript, 255-258 
floats, 255-256 
identifiers naming variables, 
functions, and pragmas, 
257-258 
statements and literals, 255 
strings and character sequences, 256 
<STYLE> tag, 141, 199, 202 
style sheets 
WAP support ofXHTML-MP, 194 
inXHTML-MP, 199-202 
subscribers 
consumer price barriers for services, 
32 
demands for ease of use, 30-31 
expectation of intuitive interface, 
16-17 
mobility of, 16-17 
understanding needs and relation-
ship with, 15-16 
usage patterns of wireless devices, 
31-32 
super phones, 25, 26 
switch-case statements in PHP, 97 
Symbian 
as handheld platform, 312 
software development kit for, 324 
synchronizing Web content, 289-291 
architecture of synchronized 
browsers, 290 
defined, 279 
format of content for synchroni-
zation, 291 
need for up-to-date information and, 
290-291 
overview, 289-290, 300-301 
Index 
377 

Index 
378 
syntax 
DID, 123-124 
learning~L,210-212 
of PAP request, 282 
PHP, 94 
T 
tables 
creating in HTML, 15~ 159 
displaying, 61 
HTML attributes for, 159 
for user interface, 43 
in~L,242-243 
tags 
i-mode heading, 186 
fori-mode text, 18~187 
attributes 
of<card>, 216 
ofHDML <ACTION>, 348 
for HDML card and deck, 340 
ofXML, 119 
author's convention oflisting, 65 
defining 
schema tags in XML namespace, 
127-128,129-130 
~L 
form elements with, 232-233 
HDML,337 
for card input, 355 
for displaying information, 343 
HTML 
<MET~.138-139 
document headings ofi-mode 
applications,184-185 
hyperlinks and images, 153-156 
for idiomatic typography, 150 
for paragraphs in documents, 144 
quotations in, 145 
raw typographic styles, 150-152 
standards, 54-55 
tables, 15~159 
tags to avoid, 165-166 
for wireless Web lists, 14 7 
for wireless Web text blocks, 143 
HTML andXML tag names, 118 
in PHP scripts, 92, 93 
<TITLE>, 137 
unsupported by wireless browsers, 
141 
~1,211 
forformatting,240 
<meta>,215-216 
for navigation, 218 
for organizing, 214 
<select> tag for menus, 218-219 
table tags, 243 
XHTML 
tasks 
assigning XHTML-MP style sheets 
to, 199-202 
for document headings in 
XHTML-BP, 195-196 
XHTML-PP, 198 
HDML 
about,347 
assigning, 347-348 
designing user interface for, 
363-364 
kinds of, 349-350 
~L,219-221 
card timer, 221 
in decks, 212 
hyperlinks and, 219-221 
tags for navigation in, 230-231 
TDMA (Time Division Multiple 
Access), 6 
text 
i-mode text tags, 18~187 
displaying, 60-61 
HTML 
aligning,152-153 
definition lists in, 148-149 
formatting text blocks, 142-145 
idiomatic text styles in, 150 
paragraph tagging, 144 
quotations, 145 
raw typographic styles, 150-152 
restrictions on wireless type styles 
and fonts, 149 
tags for preformatted text, 144 
tags for wireless Web, 143 
presenting in HDML, 343-344 
specifying styles of, 149-153 
style properties in XHTML-MP, 201 
~L 
reserved characters, 212 
typography formatting, 241-242 
text entry, 44 
text extraction by Spyglass Prism, 88 
throughput 
bandwidth and, 30 
user interface design and, 37 
Tidy,321 
Tiger Mapping Service, 112 
time format field flags, 76 
TimePicker WCA form, 175 
<TITLE> tag, 137 
titles of documents, 137 
tools 
client-side, 319-322 
for developing i-mode applications, 
183-184 

evolution of mobile device technolo-
gies and, 307 
HDML, 338-339 
for mobile software development, 
323-324 
Nokia WAP toolkit, 321 
server-side, 322-323 
for XHTML-MP development, 194 
touch screens for user input, 46 
tracking file modifications in Apache, 
75-76 
traditional desktop systems as handheld 
platforms, 313 
transcoding servers, 86--88 
about, 86--87 
IBMWebSphere Transcoding 
Publisher, 87 
overview, 90 
Spyglass Prism, 87-88 
two-dimensional interlacing, 58 
type mask, 234 
typeof operator results in WMLScript, 
261 
typographic tags in HTML, 150-152 
u 
UML (Unified Modeling Language), 
325-333 
class views, 332-333 
collaboration views, 333 
component views, 329-330 
deployment views, 327-328 
model management views, 331-332 
overview, 325 
sequence views, 330-331 
state machine and activity views, 
333 
use case views, 328-329 
views for wireless Web developers, 
326-327 
Unified Modeling Language. See UML 
United States Census Bureau Tiger 
Mapping Service, 112 
unordered lists, 147 
URL library, 270-271 
usability and easy-to-use interface, 
30-31 
use case view in UML, 328-329 
user input, 44-46 
buttons for, 46 
character type definitions for HDML 
input specifiers, 359 
check boxes for, 45 
choice card for, 356-357 
collecting for forms, 162-165 
designing HDML applications for, 
364 
entering locations, 45 
entrycard,358-360 
increasing ease of, 39 
integrating HDML actions and, 
360-362 
limitations on wireless devices, 
206-207 
pick lists for, 44 
sample listing ofWML forms input, 
236-237 
tags for HDML card input, 355 
text entry for, 44 
touch screens for, 46 
user interface, 35-48 
v 
branding of custom interfaces, 305 
brevity of pages, 42 
browser interpretation oflayout, 43 
browser's role in wireless, 37-38 
checking content on simulated user's 
environment, 46-47 
concise writing in, 42 
demands for ease of use, 30-31 
designing in WML, 205-207 
display parameters for wireless 
clients, 47-48 
example ofWML, 236-239 
font selection for, 38 
formatting content for readability, 42 
guidelines for using images, 40-41 
HDML for designing, 362-364 
increasing ease of user input, 39 
input methods for, 44-46 
overview, 35 
presentation tips for wireless Web, 
59-65 
promoting readability of, 43-44 
reducing latency issues in, 36-37 
scrolling, 39 
subscribers' expectation of intuitive, 
16-17 
tables for, 43, 158-159 
throughput and, 37 
WAP interface elements used in WML 
events, 228-229 
validation. See data validation 
variables 
in Apache server directives, 77-78 
conditional flow control by, 78-79 
declaring in WML deck, 211-212 
dollar sign as PHP variable identifier, 
95 
Index 
379 

Index 
380 
variables (continued) 
identifiers namingWMLScript, 
257-258 
PHP rules for arrays and, 94-96 
underscore as PHP identifier, 95 
in WMLScript, 258-259 
versions ofHTML, 135-136 
viewingWML content in browsers, 
209-210 
views for UML developers 
collaboration, 333 
coD1ponen~329-330 
deploym.ent, 327-328 
deploym.ent view of server-assisted 
browser service, 327 
n1odel n1anagen1ent, 331-332 
overview, 326-327 
sequence,330-331 
state n1achine and activity, 333 
use case, 328-329 
Vox:ML (Voice Markup Language), 121 
w 
walled garden structure, 182-183 
WAPForun1 
developn1ent ofWMLScript, 247 
goals of, 22-23 
Web site, 319 
WAP (Wrreless Application Protocol) 
con1patibility ofWML with, 192 
defined,S 
deploym.ent view for WAP services, 
193 
developn1ent of, 22-24 
formsinXHTML-MP, 198 
Nokia WAP toolkit, 321 
overview, 191, 202 
as protocol standard, 191-194 
push request and response in, 
282-284 
push technology and, 279 
style sheets in XHTML-MP, 199-202 
tools for XHTML-MP developn1ent, 
194 
WAP applications written in WML, 205 
XHTMLBasic Profile, 194-198 
XHTML Presentation Profile, 198 
WCA Builder, 176-177 
WCA (Web Clipping Applications), 
169-180,191-202 
tag, 173 
tag argun1ents, 17 4 
tag, 174 
architecture of, 169-171 
creating san1ple APRS/FIND appli-
cation, 177-179 
developing content in, 171-177 
HTML entities for, 171-176 
n1eta entities, 173 
PalD1 WCA viewer, 169-170 
server-side scripting with, 67--68 
WCA Builder, 176-177 
WDP (Wrreless Datagran1 Protocol), 192 
Web Clipping Applications. SeeWCA 
Web content delivery, 279-301 
while staten1ents in WMLScript, 264 
wireless access ternlinals, 4 
Wireless Application Protocol. See WAP 
wireless data n1arket, 28-34. See also 
data 
bandwidth liDlitations of, 29-30 
centralized distribution and, 29 
data n1obility and, 33-34 
potential growth for, 32-33 
price sensitivity of, 32 
subscriber den1ands for ease of use, 
30-31 
usage patterns of wireless devices, 
31-32 
wireless devices. See handheld devices 
Wrreless Markup Language. SeeWML 
wireless networks, 1-10, 11-34. See also 
n1arkup languages 
adapting to subscriber and data 
DlObility, 16-17 
choosing for custon1 applications, 
313-314 
concept of cellular radio coD1Dluni-
cations, 3-4 
content provider partnerships for, 13 
data exchange, 9 
developing new wireless content for, 
14 
exploring hardware options for, 
25-28 
FDMA schen1e for, 5 
FHMA and CDMA spread-spectrunl 
technology, 6-7 
gap between handheld and desktop 
con1puting capacities, 17-18 
growth of industry around, 11 
history of, 1-3 
initial information exchange within 
cellularsystenls,B-9 
integration with n1obile client hard-
ware,315 
n1oven1ent n1onitoring and intersys-
tenl handoff, 9 
network support for third-party 
developers, 316-317 
packet-switched radio networks, 5 
role of subscribers in, 15-16 

selecting for custom applications, 
313-317 
selecting markup options for, 19-25 
server integration with, 316 
service provider partnerships, 13-14 
TDMA scheme for, 6 
unique features of wireless market, 
28--34 
uses for wireless Web, 12 
wireless services 
consumer price barriers for, 32 
i-mode, 21-22 
consumer price barriers for sub-
scribers, 32 
service provider partnerships, 13-14 
wireless Web, 59-65. See also building 
APRS wireless Web site 
buildingAPRS wireless Web site in 
PHP, 101 
bullets and spacers on, 64-65 
designing tables for, 61 
displayingtext,60-61 
form input for, 61-63 
images for, 63-64 
logo images, 65 
PHP and, 91-92 
security on, 59 
synchronizing Web content, 289-291 
uses of, 12 
WML (Wrreless Markup Language), 
203-246. See also WMLScript 
advantages of, 203-205 
attributes oftags, 211 
cards,205-206,216-217 
compatibility with WAP protocol 
standard, 192 
creating "Hello World" in, 208--209 
decks, 205-206 
declaring variables in WML deck, 
211-212 
defined, 121 
designing user interfaces in, 205-207 
development of, 22-24 
document organization in, 213-217 
emerging paradigm for wireless 
screen phones, 206 
events, 224-230 
events and tasks in decks, 212 
font selection in, 38 
format, 239-245 
forms, 232-239 
HDML vs., 337 
hyperlinks and tasks, 219-221 
images display in, 207, 244-245 
interactive nature of tasks and events, 
223-239 
learning syntax for, 210-212 
navigation in, 217-223 
overview, 203 
PHP scripts within, 92 
reserved characters, 212 
<select> tag for menus, 218--219 
selection lists as navigation task, 
221-223 
tables, 242-243 
tagsin,211 
tags used in navigation, 218 
tasks, 230-231 
text regions and alignment on cards, 
242 
transformations and content inde-
pendence of, 89 
typography formatting, 241-242 
user input on wireless devices, 
206-207 
viewing content in, 209-210 
WAP applications in, 205 
WMLBrowser library, 266, 272 
WMLScript, 247-277 
about, 254-255 
character sequences and characters 
in,256 
compact binary representation of, 
249 
creating RPN calculator, 249-253 
data validation in, 247-248 
debugging hints for, 274-276 
development of, 247 
dynamic content generation in, 248, 
276-277 
~ctions,254,264-265 
libraries, 265-272 
native peripheral access, 248 
operators in, 259-261 
overview, 276-277 
procedural logic in, 249 
procedural statements, 262-264 
Reverse Polish Notation, 254 
similarities to ECMAScript, 248--249 
structure of, 255-258 
typeof operator results, 261 
variables and types in, 258--259 
World Wide Web. SeeWWW 
writing. See also content 
formatting content for readability, 42 
for wireless user interface, 42 
WSP (Wrreless Session Protocol), 192 
WWW (World Wide Web), 49-66 
client-server model for, 19-20 
GIF standards for, 56 
HTML and XHTML standards for, 
54-56 
Index 
381 

Index 
382 
WWW (World Wide Web), (continued) 
HTIP standards for, 49-52 
interactive languages for, 58 
X 
JPEG standards for, 57 
PICT, BMP, XBM, and PNG image for-
mats, 57-58 
wireless, 59--65 
additional support required for, 67 
building APRS wireless Web site in 
PHP, 101 
bullets and spacers on, 64-65 
designing tables for, 61 
displaying text, 60-61 
form input for, 61-63 
images for, 63-64 
logo images, 65 
PHP and, 91-92 
presentation tips for, 59--65 
security, 59 
synchronizing Web content, 
289-291 
uses of, 12 
wireless data market vs. market for, 
28--29 
XML standards for, 52-54 
XBM file format, 57-58 
XHTML (eXtensible HyperText Markup 
Language) 
standards for Web, 55-56 
transformations and content inde-
pendence of, 89 
XHTML-BP (eXtensible HyperText 
Markup Language Basic 
Profile), 194-198 
about, 194-195 
changing content to XHTML-MP, 
197-198 
structure of documents, 197-198 
tags for document headings, 195-196 
XHTML-MP (eXtensible HyperText 
Markup Language Mobile 
Profile) 
about, 191, 202 
forms in, 198 
style sheets in, 199-202 
tools for development, 194 
WAP standards and, 193, 194 
XHTML-PP (eXtensible HyperText 
Markup Language 
Presentation Profile), 198 
XML applications, 121 
XML Document Type Definition. See 
DTD 
XML (eXtensible Markup Language), 
117-133 
attribute types for XML elements, 125 
basic features in XML documents, 
117-121 
DTD for application, 122-127 
overview of, 117, 133 
prologue forWML decks in, 213-214 
sample file in, 120--121 
server-side content management 
with, 88--89 
specialized languages for interoper-
abilitywith, 121-122 
standards forWWW, 52-54 
valid tags in, 118 
XML Schema definition language, 
127-133 
XML DTD (Document Type Definition), 
122-127 
sample weather listing in, 126-127 
syntax for, 123-124 
XML Schema definition language, 
127-133 
common data types for, 129 
defining schema tags in XML name-
space,127-128,129-130 
overview, 127, 133 
weather DTD sample listing in, 
130--133 
XSL (eXtensible Stylesheet Language) 
transformations, 89 
y 
Yahoo!lUlyvvhere, 13 
Yospace developer tool, 321-322 

A press Titles 
ISBN 
PRICE 
AUTHOR 
TITLE 
1-893115-73-9 
$34.95 
Abbott 
Voice Enabling Web Applications: 
VoiceXML and Beyond 
1-893115-01-1 
$39.95 
Appleman 
Dan Appleman's Wm32 API Puzzle Book 
and Tutorial for Visual Basic Programmers 
1-893115-23-2 
$29.95 
Appleman 
How Computer Programming Works 
1-893115-97-6 
$39.95 
Appleman 
Moving to VB .NET: Strategies, Concepts, and Code 
1-59059-023-6 
$39.95 
Baker 
Adobe Acrobat 5: The Professional User's Guide 
1-59059-039-2 
$49.95 
Barnaby 
Distributed .NET Programming 
1-893115-09-7 
$29.95 
Baum 
Dave Baum's Definitive Guide 
to LEGO MINDSTORMS 
1-893115-84-4 
$29.95 
Baum, Gasperi, 
Extreme MINDSTORMS: An Advanced Guide 
Hempel, and Villa 
to LEGO MINDSTORMS 
1-893115-82-8 
$59.95 
Ben-Gan/Moreau 
Advanced 'IIansact-SQL for SQL Server 2000 
1-893115-91-7 
$39.95 
Birmingham/Perry 
Software Development on a Leash 
1-893115-48-8 
$29.95 
Bischof 
The .NET Languages: A Quick 'Iranslation Guide 
1-59059-053-8 
$44.95 
Bock/ Stromquist/ 
.NET Security 
Fischer/Smith 
1-893115-67-4 
$49.95 
Borge 
Managing Enterprise Systems with the Wmdows 
Script Host 
1-59059-019-8 
$49.95 
Cagle 
SVG Programming: The Graphical Web 
1-893115-28-3 
$44.95 
Challa/Laksberg 
Essential Guide to Managed Extensions for C++ 
1-893115-39-9 
$44.95 
Chand 
A Programmer's Guide to ADO.NET inC# 
1-59059-015-5 
$39.95 
Clark 
An Introduction to Object Oriented Programming 
with VISual Basic .NET 
1-893115-44-5 
$29.95 
Cook 
Robot Building for Beginners 
1-893115-99-2 
$39.95 
Cornell/Morrison 
Programming VB .NET: 
A Guide for Experienced Programmers 
1-893115-72-0 
$39.95 
Curtin 
Developing 'Irust Online Privacy and Security 
1-59059-014-7 
$44.95 
Drol 
Object-Oriented Macromedia Flash MX 
1-59059-008-2 
$29.95 
Duncan 
The Career Programmer: 
Guerilla Tactics for an Imperfect World 
1-893115-71-2 
$39.95 
Ferguson 
Mobile.NET 
1-893115-90-9 
$49.95 
Finsel 
The Handbook for Reluctant 
Database Administrators 
1-59059-024-4 
$49.95 
Fraser 
Real World ASP.NET: 
Building a Content Management System 
1-893115-42-9 
$44.95 
Foo/Lee 
XML Programming Using the Microsoft XML Parser 
1-893115-55-0 
$34.95 
Frenz 
VJSual Basic and Visual Basic .NET 
for Scientists and Engineers 
1-893115-85-2 
$34.95 
Gilmore 
A Programmer's Introduction to PHP 4.0 
1-893115-36-4 
$34.95 
Goodwill 
Apache Jakarta-Tomcat 
1-893115-17-8 
$59.95 
Gross 
A Programmer's Introduction to Wmdows DNA 
1-893115-62-3 
$39.95 
Gunnerson 
A Programmer's Introduction to C#, Second Edition 
1-59059-009-0 
$49.95 
Harris/Macdonald 
Moving to ASP.NET: 
Web Development with VB .NET 
1-893115-30-5 
$49.95 
Harkins/Reid 
SQL: Access to SQL Server 

ISBN 
PRICE 
AUTHOR 
TITLE 
1-893115-10-0 
$34.95 
Holub 
Taming Java Threads 
1-893115-04-6 
$34.95 
Hyman/Vaddadi 
Mike and Phani's Essential C++ Techniques 
1-893115-96-8 
$59.95 
Jorelid 
J2EE FrontEnd Technologies: 
A Programmer's Guide to Servlets, JavaServer Pages, 
and Enterprise JavaBeans 
1-893115-49-6 
$39.95 
Kilburn 
Palm Programming in Basic 
1-893115-50-X 
$34.95 
Knudsen 
Wrreless Java: Developing with Java 2, Micro Edition 
1-893115-79-8 
$49.95 
Kofler 
Definitive Guide to Excel VBA 
1-893115-57-7 
$39.95 
Kofler 
MySQL 
1-893115-87-9 
$39.95 
Kurata 
DoingWeb Development: Client-Side Techniques 
1-893115-75-5 
$44.95 
Kurniawan 
Internet Programming with VB 
1-893115-38-0 
$24.95 
Lafler 
Power AOL: A Survival Guide 
1-893115-46-1 
$36.95 
Lathrop 
Linux in Small Business: A Practical User's Guide 
1-893115-19-4 
$49.95 
Macdonald 
Serious ADO: Universal Data Access 
with VISual Basic 
1-893115-06-2 
$39.95 
Marquis/Smith 
A VISual Basic 6.0 Programmer's Toolkit 
1-893115-22-4 
$27.95 
McCarter 
David McCarter's VB Tips and Techniques 
1-59059-021-X 
$34.95 
Moore 
Karl Moore's VISual Basic .NET: The Tutorials 
1-893115-27-5 
$49.95 
Morrill 
Tuning and Customizing a Linux System 
1-893115-76-3 
$49.95 
Morrison 
C++ For VB Programmers 
1-59059-003-1 
$39.95 
Nakhimovsky/Meyers 
XML Programming: Web Applications 
and Web Services with JSP and ASP 
1-893115-80-1 
$39.95 
Newmarch 
A Programmer's Guide to Jini Technology 
1-893115-58-5 
$49.95 
Oellermann 
ArchitectingWeb Services 
1-59059-020-1 
$44.95 
Patzer 
JSP Examples and Best Practices 
1-893115-81-X 
$39.95 
Pike 
SQL Server: Common Problems, Tested Solutions 
1-59059-017-1 
$34.95 
Rainwater 
Herding Cats: A Primer for Programmers 
Who Lead Programmers 
1-59059-025-2 
$49.95 
Rammer 
Advanced .NET Remoting (C# Edition) 
1-59059-062-7 
$49.95 
Rammer 
Advanced .NET Remoting in VB .NET 
1-893115-20-8 
$34.95 
Rischpater 
Wrreless Web Development 
1-59059-028-7 
$39.95 
Risch pater 
Wrreless Web Development, Second Edition 
1-893115-93-3 
$34.95 
Risch pater 
Wrreless Web Development with PHP and WAP 
1-893115-89-5 
$59.95 
Shemitz 
Kylix: The Professional Developer's Guide 
and Reference 
1-893115-40-2 
$39.95 
Sill 
The qmail Handbook 
1-893115-24-0 
$49.95 
Sinclair 
From Access to SQL Server 
1-59059-026-0 
$49.95 
Smith 
Writing Add-ins for Visual Studio .NET 
1-893115-94-1 
$29.95 
Spolsky 
User Interface Design for Programmers 
1-893115-53-4 
$44.95 
Sweeney 
Visual Basic for Testers 
1-59059-002-3 
$44.95 
Symmonds 
Internationalization and Localization Using 
Microsoft .NET 
1-59059-010-4 
$54.95 
Thomsen 
Database Programming with C# 
1-893115-29-1 
$44.95 
Thomsen 
Database Programming with VISual Basic .NET 
1-893115-65-8 
$39.95 
Tiffany 
Pocket PC Database Development 
with eMbedded Visual Basic 

ISBN 
PRICE 
AUTHOR 
TITLE 
1-59059-027-9 
$59.95 
Torkelson/Petersen/ 
Programming the Web with Visual Basic .NET 
Torkelson 
1-893115-59-3 
$59.95 
Troelsen 
C# and the .NET Platform 
1-59059-011-2 
$59.95 
Troelsen 
COM and .NET Interoperability 
1-893115-26-7 
$59.95 
Thoelsen 
VISual Basic .NET and the .NET Platform 
1-893115-54-2 
$49.95 
'IIueblood/Lovett 
Data Mining and Statistical Analysis Using SQL 
1-893115-68-2 
$54.95 
Vaughn 
ADO.NET and ADO Examples and Best Practices 
for VB Programmers, Second Edition 
1-59059-012-0 
$49.95 
Vaughn/Blackburn 
ADO.NET Examples and Best Practices 
for C# Programmers 
1-893115-83-6 
$44.95 
Wells 
Code Centric: T-SQL Programming with 
Stored Procedures and 'IIiggers 
1-893115-95-X 
$49.95 
Welschenbach 
Cryptography in C and C++ 
1-893115-05-4 
$39.95 
Williamson 
Writing Cross-Browser Dynamic HfML 
1-893115-78-X 
$49.95 
Zukowski 
Definitive Guide to Swing for Java 2, Second Edition 
1-893115-92-5 
$49.95 
Zukowski 
Java Collections 
1-893115-98-4 
$54.95 
Zukowski 
Learn Java with }Builder 6 
Available at bookstores nationwide or from Springer Verlag New York, Inc. at 1-800-777 -4643; 
fax 1-212-533-3503. Contact us for more information at sales@apress.com. 
Apress Titles Publishing SOONI 
ISBN 
AUTHOR 
TITLE 
1-59059-022-8 
Alapati 
Expert Oracle 9i Database Administration 
1-59059-041-4 
Bock 
CIL Programming: Under the Hood of .NET 
1-59059-000-7 
Cornell 
Programming C# 
1-59059-033-3 
Fraser 
Managed Gt+ and .NET Development 
1-59059-038-4 
GibbotlS 
Java Development to .NET Development 
1-59059-030-9 
Habibi/Camerlengo/ 
Java 1.4 and the Sun Certified Developer Exam 
Patterson 
1-59059-006-6 
Hetland 
ltlStant Python with Ten ltlStant Projects 
1-59059-044-9 
MacDonald 
.NET User Interfaces with VB .NET: 
Wmdows Forms and Custom Controls 
1-59059-001-5 
McMahon 
A Programmer's Introduction to ASP.NETWebForms 
in V'ISual Basic .NET 
1-893115-7 4-7 
Millar 
Enterprise Development: A Programmer's Handbook 
1-893115-43-7 
Stephenson 
Standard VB: An Enterprise Developer's Reference 
for VB 6 and VB .NET 
1-59059-035-X 
Symmonds 
GDI+ Programming in C# and VB .NET 
1-59059-032-5 
Thomsen 
Database Programming with Visual Basic .NET, Second Edition 
1-59059-007-4 
Thomsen 
Building Web Services with VB .NET 
1-59059-018-X 
Ti'egar 
Writing Perl Modules for CPAN 
1-59059-004-X 
Valiaveedu 
SQL Server 2000 and Business Intelligence in an 
XML/.NETWorld 
Available at bookstores nationwide or from Springer Verlag New York, Inc. at 1-800-777 -4643; 
fax 1-212-533-3503. Contact us for more information at sales@apress. com. 

Get Started in 
Amateur Robotics 
with Robot Building for Beginners 
L
EARNING ROBancs by yourself isn't easy. It helps when the encouragement 
comes from someone who's been there. Not only does Robot Building 
for Beginners assist you in understanding component parts of robot 
development, but also it prepares you with techniques to learn new 
discoveries on your own. 
ar 
Tools and parts covered 
include: digital multimeters, 
motors, wheels, resistors, wire 
strippers, needle nose pliers, 
tap and die, alligator clips, 
LEDs, solderless breadboards, 
soldering irons, heat -shrink 
tubing, photoresistors, 
transistors, chips, gears, nut 
drivers, screws, cut -off wheels, 
connectors, and batteries. 
Robot Building for Beginners 
by David Cook 
ISBN: 1-89311~5 $29.95 I 600 p. 
..-.press· 
Books for professionals by professionalsTM 
www.apress.com 
Available at bookstores nationwide or from Springer-Verlag New York. Inc. 
at 1-800.777-4643; fax 1·212-533-3503. 
Contact us for more Information at sales@apress.com. 
ApressrM 

books for professionals by professionals ... 
ApressTM 
About Apress 
Apress, located in Berkeley, CA, is a fast -growing, innovative publishing company devoted to 
meeting the needs of existing and potential programming professionals. Simply put, the "N.' 
in Apress stands for "The Author's Pressm" and its books have "The Expert's Voicem~ 
Apress' unique approach to publishing grew out of conversations between its founders Gary 
Cornell and Dan Appleman, authors of numerous best-selling, highly regarded books for 
programming professionals. In 1998 they set out to create a publishing company that 
emphasized quality above all else. Gary and Dan's vision has resulted in the publication of 
over 50 titles by leading software professionals, all of which have The Expert's Voicem. 
Do You Have What It Takes 
to Write for Apress? 
Apress is rapidly expanding its publishing program. If you can write and refuse to 
compromise on the quality of your work, if you believe in doing more than rehashing existing 
documentation, and if you're looking for opportunities and rewards that go far beyond those 
offered by traditional publishing houses, we want to hear from you! 
Consider these innovations that we offer all of our authors: 
• Top royalties with no hidden switch statements 
Authors typically only receive half of their normal royalty rate on foreign sales. In contrast, 
Apress' royalty rate remains the same for both foreign and domestic sales. 
• A mechanism for authors to obtain equity In Apress 
Unlike the software industry, where stock options are essential to motivate and retain 
software professionals, the publishing industry has adhered to an outdated compensation 
model based on royalties alone. In the spirit of most software companies, Apress reserves a 
significant portion of its equity for authors. 
• Serious treatment of the technical review process 
Each Apress book has a technical reviewing team whose remuneration depends in part on 
the success of the book since they too receive royalties. 
Moreover, through a partnership with Springer-Verlag, New York, Inc., one of the world's 
major publishing houses, Apress has significant venture capital behind it. Thus, we have the 
resources to produce the highest quality books and market them aggressively. 
If you fit the model of the Apress author who can write a book that gives the "professional 
what he or she needs to know""," then please contact one of our Editorial Directors, Gary 
Cornell (gary_cornell@apress.com), Dan Appleman (dan_appleman@apress.com), Peter 
Blackburn (peter_blackbum@apress.com), Jason Gilmore (jason_gilmore@apress.com), Karen 
Watterson (karen_watterson@apress.com), or John Zukowski (john_zukowski@apress.com) 
for more information. 

