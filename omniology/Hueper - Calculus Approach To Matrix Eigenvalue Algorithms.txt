A Calculus Approach to
Matrix Eigenvalue Algorithms
Habilitationsschrift
der Fakult¨at f¨ur Mathematik und Informatik
der Bayerischen Julius-Maximilians-Universit¨at W¨urzburg
f¨ur das Fach Mathematik vorgelegt von
Knut H¨uper
W¨urzburg im Juli 2002

2
Meiner Frau Barbara
und unseren Kindern Lea, Juval und Noa gewidmet

Contents
1
Introduction
5
2
Jacobi-type Algorithms and Cyclic Coordinate Descent
8
2.1
Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
8
2.1.1
Jacobi and Cyclic Coordinate Descent
. . . . . . . . .
9
2.1.2
Block Jacobi and Grouped Variable Cyclic Coordinate
Descent
. . . . . . . . . . . . . . . . . . . . . . . . . .
10
2.1.3
Applications and Examples for 1-dimensional Optimiza-
tion
. . . . . . . . . . . . . . . . . . . . . . . . . . . .
12
2.1.4
Applications and Examples for Block Jacobi . . . . . .
22
2.2
Local Convergence Analysis
. . . . . . . . . . . . . . . . . . .
23
2.3
Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
31
3
Reﬁning Estimates of Invariant Subspaces
32
3.1
Lower Unipotent Block Triangular Transformations . . . . . .
33
3.2
Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
37
3.2.1
Main Ideas
. . . . . . . . . . . . . . . . . . . . . . . .
37
3.2.2
Formulation of the Algorithm . . . . . . . . . . . . . .
40
3.2.3
Local Convergence Analysis . . . . . . . . . . . . . . .
44
3.2.4
Further Insight to Orderings . . . . . . . . . . . . . . .
48
3.3
Orthogonal Transformations . . . . . . . . . . . . . . . . . . .
52
3.3.1
The Algorithm
. . . . . . . . . . . . . . . . . . . . . .
57
3.3.2
Local Convergence Analysis . . . . . . . . . . . . . . .
59
3.3.3
Discussion and Outlook
. . . . . . . . . . . . . . . . .
62
4
Rayleigh Quotient Iteration, QR-Algorithm, and Some Gen-
eralizations
63
4.1
Local Cubic Convergence of RQI
. . . . . . . . . . . . . . . .
64

CONTENTS
4
4.2
Parallel Rayleigh Quotient Iteration or Matrix-valued Shifted
QR-Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . .
69
4.2.1
Discussion . . . . . . . . . . . . . . . . . . . . . . . . .
72
4.3
Local Convergence Properties of the Shifted QR-Algorithm . .
73

Chapter 1
Introduction
The interaction between numerical linear algebra and control theory has cru-
cially inﬂuenced the development of numerical algorithms for linear systems
in the past. Since the performance of a control system can often be mea-
sured in terms of eigenvalues or singular values, matrix eigenvalue methods
have become an important tool for the implementation of control algorithms.
Standard numerical methods for eigenvalue or singular value computations
are based on the QR-algorithm. However, there are a number of compu-
tational problems in control and signal processing that are not amenable to
standard numerical theory or cannot be easily solved using current numerical
software packages. Various examples can be found in the digital ﬁlter design
area. For instance, the task of ﬁnding sensitivity optimal realizations for
ﬁnite word length implementations requires the solution of highly nonlinear
optimization problems for which no standard numerical solution algorithms
exist.
There is thus the need for a new approach to the design of numerical
algorithms that is ﬂexible enough to be applicable to a wide range of com-
putational problems as well as has the potential of leading to eﬃcient and
reliable solution methods. In fact, various tasks in linear algebra and system
theory can be treated in a uniﬁed way as optimization problems of smooth
functions on Lie groups and homogeneous spaces. In this way the powerful
tools of diﬀerential geometry and Lie group theory become available to study
such problems.
Higher order local convergence properties of iterative matrix algorithms
are in many instances proven by means of tricky estimates. E.g., the Jacobi
method, essentially, is an optimization procedure. The idea behind the proof

6
of local quadratic convergence for the cyclic Jacobi method applied to a
Hermitian matrix lies in the fact that one can estimate the amount of descent
per sweep, see Henrici (1958) [Hen58]. Later on, by several authors these
ideas where transferred to similar problems and even reﬁned, e.g., Jacobi
for the symmetric eigenvalue problem, Kogbetliantz (Jacobi) for SVD, skew-
symmetric Jacobi, etc..
The situation seems to be similar for QR-type algorithms. Looking ﬁrst at
Rayleigh quotient iteration, neither Ostrowski (1958/59) [Ost59] nor Parlett
[Par74] use Calculus to prove local cubic convergence.
About ten years ago there appeared a series of papers where the authors
studied the global convergence properties of QR and RQI by means of dy-
namical systems methods, see Batterson and Smillie [BS89a, BS89b, BS90],
Batterson [Bat95], and Shub and Vasquez [SV87]. To our knowledge these
papers where the only ones where Global Analysis was applied to QR-type
algorithms.
From our point of view there is a lack in studying the local convergence
properties of matrix algorithms in a systematic way.
The methodologies
for diﬀerent algorithms are often also diﬀerent. Moreover, the possibility of
considering a matrix algorithm atleast locally as a discrete dynamical system
on a homogenous space is often overseen. In this thesis we will take this
point of view. We are able to (re)prove higher order convergence for several
wellknown algorithms and present some eﬃcient new ones.
This thesis contains three parts.
At ﬁrst we present a Calculus approach to the local convergence analysis
of the Jacobi algorithm. Considering these algorithms as selfmaps on a man-
ifold (i.e., projective space, isospectral or ﬂag manifold, etc.) it turns out,
that under the usual assumptions on the spectrum, they are diﬀerentiable
maps around certain ﬁxed points.
For a wide class of Jacobi-type algo-
rithms this is true due to an application of the Implicit Function Theorem,
see [HH97, HH00, H¨up96, HH95, HHM96]. We then generalize the Jacobi
approach to socalled Block Jacobi methods. Essentially, these methods are
the manifold version of the socalled grouped variable approach to coordinate
descent, wellknown to the optimization community.
In the second chapter we study the nonsymmetric eigenvalue problem
introducing a new algorithm for which we can prove quadratic convergence.
These methods are based on the idea to solve lowdimensional Sylvester equa-
tions again and again for improving estimates of invariant subspaces.

7
At third, we will present a new shifted QR-type algorithm, which is some-
how the true generalization of the Rayleigh Quotien Iteration (RQI) to a full
symmetric matrix, in the sense, that not only one column (row) of the matrix
converges cubically in norm, but the oﬀ-diagonal part as a whole. Rather
than being a scalar, our shift is matrix valued. A prerequisite for studying
this algorithm, called Parallel RQI, is a detailed local analysis of the classi-
cal RQI itself. In addition, at the end of that chapter we discuss the local
convergence properties of the shifted QR-algorithm. Our main result for this
topic is that there cannot exist a smooth shift strategy ensuring quadratic
convergence.
In this thesis we do not answer questions on global convergence. The
algorithms which are presented here are all locally smooth self mappings of
manifolds with vanishing ﬁrst derivative at a ﬁxed point. A standard argu-
ment using the mean value theorem then ensures that there exists an open
neighborhood of that ﬁxed point which is invariant under the iteration of
the algorithm. Applying then the contraction theorem on the closed neigh-
borhood ensures convergence to that ﬁxed point and moreover that the ﬁxed
point is isolated. Most of the algorithms turn out to be discontinous far away
from their ﬁxed points but we will not go into this.
I wish to thank my colleagues in W¨urzburg, Gunther Dirr, Martin Kleins-
teuber, Jochen Trumpf, and Piere-Antoine Absil for many fruitful discussions
we had. I am grateful to Paul Van Dooren, for his support and the discus-
sions we had during my visits to Louvain. Particularly, I am grateful to Uwe
Helmke. Our collaboration on many diﬀerent areas of applied mathematics
is still broadening.

Chapter 2
Jacobi-type Algorithms and
Cyclic Coordinate Descent
In this chapter we will discuss generalizations of the Jacobi algorithm well
known from numerical linear algebra text books for the diagonalization of
real symmetric matrices.
We will relate this algorithm to socalled cyclic
coordinate descent methods known to the optimization community. Under
reasonable assumptions on the objective function to be minimized and on
the step size selection rule to be considered, we will prove local quadratic
convergence.
2.1
Algorithms
Suppose in an optimization problem we want to compute a local minimum
of a smooth function
f : M →R,
(2.1)
deﬁned on a smooth n-dimensional manifold M. Let denote for each x ∈M
{γ(x)
1 , . . . , γ(x)
n }
(2.2)
a family of mappings,
γ(x)
i
: R →M,
γ(x)
i
(0) = x,
(2.3)

2.1 Algorithms
9
such that the set {˙γ(x)
1 (0), . . . , ˙γ(x)
n (0)} forms a basis of the tangent space
TxM. We refer to the smooth mappings
Gi : R × M →M,
Gi(t, x) := γ(x)
i
(t)
(2.4)
as the basic transformations.
2.1.1
Jacobi and Cyclic Coordinate Descent
The proposed algorithm for minimizing a smooth function f : M →R
then consists of a recursive application of socalled sweep operations. The
algorithm is termed a Jacobi-type algorithm.
Algorithm 2.1 (Jacobi Sweep).
Given an xk ∈M deﬁne
x(1)
k
:= G1(t(1)
∗, xk)
x(2)
k
:= G2(t(2)
∗, x(1)
k )
...
x(n)
k
:= Gn(t(n)
∗, x(n−1)
k
)
where for i = 1, . . . , n
t(i)
∗:= arg min
t∈R (f(Gi(t, x(i−1)
k
)))
if
f(Gi(t, x(i−1)
k
)) ̸≡f(x(i−1)
k
)
and
t(i)
∗:= 0
otherwise.

2.1 Algorithms
10
Thus x(i)
k is recursively deﬁned as the minimum of the smooth cost function
f : M →R when restricted to the i-th curve
{Gi(t, x(i−1)
k
) | t ∈R} ⊂M.
The algorithm then consists of the iteration of sweeps.
Algorithm
2.2
(Jacobi-type
Algorithm
on
n-dimensional Manifold).
• Let x0, . . . , xk ∈M be given for k ∈N0.
• Deﬁne the recursive sequence x(1)
k , . . . , x(n)
k
as
above (sweep).
• Set xk+1 := x(n)
k . Proceed with the next sweep.
2.1.2
Block Jacobi and Grouped Variable Cyclic Co-
ordinate Descent
A quite natural generalization of the Jacobi method is the following. In-
stead of minimizing along predetermined curves, one might minimize over
the manifold using more than just one parameter at each algorithmic step.
Let denote
TxM = V (x)
1
⊕· · · ⊕V (x)
m
(2.5)
a direct sum decomposition of the tangent space TxM at x ∈M. We will
not require the subspaces V (x)
i
, dim V (x)
i
= li, to have equal dimension. Let
denote
{γ(x)
1 , . . . , γ(x)
m }
(2.6)
a family of smooth mappings smoothly parameterized by x,
γ(x)
i
: Rli →M,
γ(x)
i
(0) = x,
(2.7)

2.1 Algorithms
11
such that for all i = 1, . . . , m, for the image of the derivative
im D γ(x)
i
(0) = V (x)
i
(2.8)
holds. Again we refer to
Gi : Rli × M →M,
Gi(t, x) := γ(x)
i
(t)
(2.9)
as the basic transformations. Analogously, to the one-dimensional case above,
the proposed algorithm for minimizing a smooth function f : M →R then
consists of a recursive application of socalled grouped variable sweep opera-
tions. The algorithm is termed a Block Jacobi Algorithm.
Algorithm 2.3 (Block Jacobi Sweep).
Given an xk ∈M. Deﬁne
x(1)
k
:= G1(t(1)
∗, xk)
x(2)
k
:= G2(t(2)
∗, x(1)
k )
...
x(m)
k
:= Gm(t(m)
∗
, x(m−1)
k
)
where for i = 1, . . . , m
t(i)
∗:= arg min
t∈Rli(f(Gi(t, x(i−1)
k
)))
if
f(Gi(t, x(i−1)
k
)) ̸≡f(x(i−1)
k
)
and
t(i)
∗:= 0
otherwise.
Thus x(i)
k is recursively deﬁned as the minimum of the smooth cost function
f : M →R when restricted to the i-th li-dimensional subset

2.1 Algorithms
12
{Gi(t, x(i−1)
k
) | t ∈Rli} ⊂M.
The algorithm then consists of the iteration of sweeps.
Algorithm 2.4 (Block Jacobi Algorithm on Man-
ifold).
• Let x0, . . . , xk ∈M be given for k ∈N0.
• Deﬁne the recursive sequence x(1)
k , . . . , x(m)
k
as
above (sweep).
• Set xk+1 := x(m)
k
. Proceed with the next sweep.
The formulation of the above algorithms suﬀer from several things. With-
out further assumptions on the objective function as well as on the mappings
which lead to the basic transformations one hardly can prove anything.
For the applications we have in mind the objective function is always
smooth. The art to choose suitable mappings γ(x)
i
leading to the basic trans-
formations often needs some insight into and intuition for the problem under
consideration. For instance, if the manifold M is noncompact and the ob-
jective function f : M →R+ is smooth and proper a good choice for the
mappings γ(x)
i
is clearly that one which ensures that the restriction f|γ(x)
i
(R)
is also proper for all i and all x ∈M. Moreover, if M = G is a compact
Lie group, say G = SOn, a good choice for γ(x)
i
: R →SOn is one which
ensures γ(x)
i
([0, 2π]) ∼= S1 ∼= SO2.
More generally, one often succeeds in
ﬁnding mappings γ(x)
i
such that optimizing the restriction of f to the image
of these mappings is a problem of the same kind as the original one but of
lower dimension being solvable in closed form. All these situations actually
appear very often in practise. Some of them are brieﬂy reviewed in the next
subsection.
2.1.3
Applications and Examples for 1-dimensional Op-
timization
If M = Rn and Gi(t, x) = x + tei, with ei the i-th standard basis vector
of Rn, one gets the familiar coordinate descent method, cf. [AO82, BSS93,

2.1 Algorithms
13
Lue84, LT92].
Various tasks in linear algebra and system theory can be treated in a
uniﬁed way as optimization problems of smooth functions on Lie groups and
homogeneous spaces. In this way the powerful tools of diﬀerential geometry
and Lie group theory become available to study such problems. With Brock-
ett’s paper [Bro88] as the starting point there has been ongoing success in
tackling diﬃcult computational problems by geometric optimization meth-
ods. We refer to [HM94] and the PhD theses [Smi93, Mah94, Deh95, H¨up96]
for more systematic and comprehensive state of the art descriptions. Some
of the further application areas where our methods are potentially useful
include diverse topics such as frequency estimation, principal component
analysis, perspective motion problems in computer vision, pose estimation,
system approximation, model reduction, computation of canonical forms and
feedback controllers, balanced realizations, Riccati equations, and structured
eigenvalue problems.
In the survey paper [HH97] a generalization of the classical Jacobi method
for symmetric matrix diagonalization, see Jacobi [Jac46], is considered that is
applicable to a wide range of computational problems. Jacobi-type methods
have gained increasing interest, due to superior accuracy properties, [DV92],
and inherent parallelism, [BL85, G¨ot94, Sam71], as compared to QR-based
methods.
The classical Jacobi method successively decreases the sum of
squares of the oﬀ-diagonal elements of a given symmetric matrix to compute
the eigenvalues. Similar extensions exist to compute eigenvalues or singular
values of arbitrary matrices. Instead of using a special cost function such
as the oﬀ-diagonal norm in Jacobi’s method, other classes of cost functions
are feasible as well. In [HH97] a class of perfect Morse-Bott functions on
homogeneous spaces is considered that are deﬁned by unitarily invariant
norm functions or by linear trace functions. In addition to gaining further
generality this choice of functions leads to an elegant theory as well as yielding
improved convergence properties for the resulting algorithms.
Rather than trying to develop the Jacobi method in full generality on
arbitrary homogeneous spaces in [HH97] its applicability by means of exam-
ples from linear algebra and system theory is demonstrated. New classes of
Jacobi-type methods for symmetric matrix diagonalization, balanced realiza-
tion, and sensitivity optimization are obtained. In comparison with standard
numerical methods for matrix diagonalization the new Jacobi-method has the
advantage of achieving automatic sorting of the eigenvalues. This sorting

2.1 Algorithms
14
property is particularly important towards applications in signal processing;
i.e., frequency estimation, estimation of dominant subspaces, independant
component analysis, etc.
Let G be a real reductive Lie group and K ⊂G a maximal compact
subgroup. Let
α : G × V →V,
(g, x) 7→g · x
(2.10)
be a linear algebraic action of G on a ﬁnite dimensional vector space V . Each
orbit G·x of such a real algebraic group action then is a smooth submanifold of
V that is diﬀeomorphic to the homogeneous space G/H, with H := {g ∈G|g·
x = x} the stabilizer subgroup. In [HH97] we are interested in understanding
the structure of critical points of a smooth proper function f : G · x →R+
deﬁned on orbits G · x. Some of the interesting cases actually arise when
f is deﬁned by a norm function on V . Thus given a positive deﬁnite inner
product ⟨, ⟩on V let ∥x∥2 = ⟨x, x⟩denote the associated Hermitian norm.
An Hermitian norm on V is called K−invariant if
⟨k · x, k · y⟩= ⟨x, y⟩
(2.11)
holds for all x, y ∈V and all k ∈K, for K a maximal compact subgroup
of G. Fix any such K−invariant Hermitian norm on V . For any x ∈V we
consider the smooth distance function on G · x deﬁned as
φ: G·x →R+,
φ(g·x) = ∥g·x∥2.
(2.12)
We then have the following result due to Kempf and Ness [KN79]. For an
important generalization to plurisubharmonic functions on complex homoge-
neous spaces, see Azad and Loeb [AL90].
Theorem 2.1.
1. The norm function φ: G·x →R+, φ(g·x)=∥g·x∥2, has
a critical point if and only if the orbit G ·x is a closed subset of V .
2. Let G · x be closed. Every critical point of φ : G · x →R+ is a global
minimum and the set of global minima is a single uniquely determined
K−orbit.
3. If G · x is closed, then φ : G · x →R+ is a perfect Morse-Bott function.
The set of global minima is connected.
□
Theorem 2.1 completely characterizes the critical points of K−invariant
Hermitian norm functions on G−orbits G·x of a reductive Lie group G. Similar

2.1 Algorithms
15
results are available for compact groups. We describe such a result in a special
situation which suﬃces for the subsequent examples. Thus let G now be a
compact semisimple Lie group with Lie algebra g. Let
α: G × g →g,
(g, x) 7→g·x = Ad(g)x
(2.13)
denote the adjoint action of G on its Lie algebra. Let G·x denote an orbit of
the adjoint action and let
(x, y) := −tr(adx ◦ady)
(2.14)
denote the Killing form on g. Then for any element a ∈g the trace function
fa : G·x →R+, fa(g·x) = −tr(ada ◦adg·x)
(2.15)
deﬁnes a smooth function on G·x. For a proof of the following result, formu-
lated for orbits of the co-adjoint action, we refer to Atiyah [Ati82], Guillemin
and Sternberg [GS82].
Theorem 2.2. Let G be a compact, connected, and semisimple Lie group
over C and let fa : G ·x →R+ be the restriction of a linear function on a
co-adjoint orbit, deﬁned via evaluation with an element a of the Lie algebra.
Then
1. fa : G ·x →R is a perfect Morse-Bott function.
2. If fa : G ·x →R has only ﬁnitely many critical points, then there exists
a unique local=global minimum.
All other critical points are saddle
points or maxima.
□
Suppose now in an optimization exercise we want to compute the set of
critical points of a smooth function φ : G · x →R+, deﬁned on an orbit of a
Lie group action. Thus let G denote a compact Lie group acting smoothly
on a ﬁnite dimensional vector space V . For x ∈V let G·x denote an orbit.
Let {Ω1, . . . , ΩN} denote a basis of the Lie algebra g of G, with N = dim G.
Denote by exp(tΩi), t ∈R, the associated one parameter subgroups of G.
We then refer to G1(t),. . . ,GN(t) with Gi(t, x) = exp(tΩi) · x as the basic
transformations of G as above.
Into the latter frame work also the Jacobi algorithm for the real sym-
metric eigenvalue problem from text books on matrix algorithms ﬁts, cf.

2.1 Algorithms
16
[GvL89, SHS72]. If the real symmetric matrix to be diagonalized has dis-
tinct eigenvalues then the isospectral manifold of this matrix is diﬀeomorphic
to the orthogonal group itself. Some advantages of the Jacobi-type method
as compared to other optimization procedures one might see from the fol-
lowing example.
The symmetric eigenvalue problem might be considered
as a constrained optimization task in a Euclidian vector space embedding
the orthogonal group, cf.
[Chu88, Chu91, Chu96, CD90], implying rela-
tively complicated lifting and projection computations in each algorithmic
step. Intrinsic gradient and Newton-type methods for the symmetric eigen-
value problem were ﬁrst and independently published in the Ph.D. theses
[Smi93, Mah94]. The Jacobi approach, in contrast to the above- mentioned
ones, uses predetermined directions to compute geodesics instead of direc-
tions determined by the gradient of the function or by calculations of second
derivatives. One should emphasize the simple calculability of such directions:
the optimization is performed only along closed curves. The bottleneck of the
gradient-based or Newton-type methods with their seemingly good conver-
gence properties is generally caused by the explicit calculation of directions,
the related geodesics, and possibly step size selections. The time required
for these computations may amount to the same order of magnitude as the
whole of the problem. For instance, the computation of the exponential of a
dense skew-symmetric matrix is comparable to the eﬀort of determining its
eigenvalues. The advantage of optimizing along circles will become evident
by the fact that the complete analysis of the restriction of the function to that
closed curve is a problem of considerably smaller dimension and sometimes
can be solved in closed form. For instance, for the real symmetric eigenvalue
problem one has to solve only a quadratic.
A whole class of further examples are developed in [Kle00] generalizing
earlier results from [H¨up96]. There, generalizations of the conventional Ja-
cobi algorithm to the problem of computing diagonalizations in compact Lie
algebras are presented.
We would like two mention two additional applications, namely, (i) the
computation of signature symmetric balancing transformations, being an im-
portant problem in systems and circuit theory, and (ii), the stereo matching
problem without correspondence, having important applications in computer
vision. The results referred to here are developed more detailed in [HHM02],
respectively [HH98].

2.1 Algorithms
17
Signature Symmetric Balancing
From control theory it is well konwn that balanced realizations of symmet-
ric transfer functions are signature symmetric. Wellknown algorithms, e.g.,
[LHPW87, SC89], however, do not preserve the signature symmetry and they
may be sensible to numerical perturbations from the signature symmetric
class. In recent years there is a tremendous interest in structure preserv-
ing (matrix) algorithms. The main motivation for this is twofold. If such
a method can be constructed it usually (i) leads to reduction in complexity
and (ii) often coincidently avoids that in ﬁnite arithmetic physically mean-
ingless results are obtained. Translated to our case that means that (i) as
the appropriate state space transformation group the Lie group O+
pq of spe-
cial pseudo-orthogonal transformations is used instead of GLn. Furthermore,
(ii) at any stage of an algorithm the computed transformation should corre-
spond to a signature symmetric realization if one would have started with
one. Put into other words, the result of each iteration step should have some
physical meaning. Let us very brieﬂy review notions and results on balancing
and signature symmetric realizations. Given any asymptotically stable linear
system (A, B, C), the continuous-time controllability Gramian Wc and the
observability Gramian Wo are deﬁned, respectively, by
Wc =
∞
Z
0
etA BB′ etA′ d t,
Wo =
∞
Z
0
etA′ C′C etA d t.
(2.16)
Thus, assuming controllability and observability, the Gramians Wc, Wo are
symmetric positive deﬁnite matrices. Moreover, a linear change of variables
in the state space by an invertible state space coordinate transformation T
leads to the co- and contravariant transformation law of Gramians as
(Wc, Wo) 7→
¡
TWcT ′, (T ′)−1WoT −1¢
.
(2.17)
Let p, q ∈N0 be integers with p + q = n, Ipq := diag(Ip, −Iq). A realization
(A, B, C) ∈Rn×n × Rn×m × Rm×n is called signature symmetric if

2.1 Algorithms
18
(AIpq)′ = AIpq,
(CIpq)′ = B
(2.18)
holds. Note that every strictly proper symmetric rational (m × m)-transfer
function G(s) = G(s)′ of McMillan degree n has a minimal signature sym-
metric realization and any two such minimal signature symmetric realizations
are similar by a unique state space similarity transformation T ∈Opq. The
set
Opq := {T ∈Rn×n|TIpqT ′ = Ipq}
is the real Lie group of pseudo-orthogonal (n × n)-matrices stabilizing Ipq
by congruence. The set O+
pq denotes the identity component of Opq. Here
p −q is the Cauchy-Maslov index of G(s), see [AB77] and [BD82]. For any
stable signature symmetric realization the controllability and observability
Gramians satisfy
Wo = IpqWcIpq.
(2.19)
As usual, a realization (A, B, C) is called balanced if
Wc = Wo = Σ = diag (σ1, . . . , σn)
(2.20)
where the σ1, . . . , σn are the Hankel singular values. In the sequel we assume
that they are pairwise distinct.
Let
M(Σ) := {TΣT ′ | T ∈O+
pq},
(2.21)
with Σ as in (2.20) assuming pairwise distinct Hankel singular values. Thus
M(Σ) is an orbit of O+
pq and therefore a smooth and connected manifold.
Note that the stabilizer subgroup of a point X ∈M(Σ) is ﬁnite and therefore
M(Σ) is diﬀeomorphic to O+
pq which as a pseudo-orthogonal group of order
n = p + q has dimension n(n −1)/2.
Let N := diag (µ1, . . . , µp, ν1, . . . , νq) with 0 < µ1 < · · · < µp and 0 <
ν1 < · · · < νq. We then consider the smooth cost function
fN : M(Σ) →R,
fN(W) := tr (NW).
(2.22)

2.1 Algorithms
19
This choice is motivated by our previous work on balanced realizations [HH00],
where we studied the smooth function tr (N(Wc+Wo)) with diagonal positive
deﬁnite N having distinct eigenvalues. Now
tr (N(Wc + Wo)) = tr (N(Wc + IpqWcIpq))
= 2tr (NWc)
by the above choice of a diagonal N. The following result summarizes the
basic properties of the cost function fN.
Theorem 2.3. Let N := diag (µ1, . . . , µp, ν1, . . . , νq) with 0 < µ1 < · · · < µp
and 0 < ν1 < · · · < νq. For the smooth cost function fN : M(Σ) →R,
deﬁned by fN(W) := tr (NW), the following holds true.
1. fN : M(Σ) →R has compact sublevel sets and a minimum of fN exists.
2. X ∈M(Σ) is a critical point for fN : M(Σ) →R if and only if X is
diagonal.
3. The global minimum is unique and it is characterized by X = diag (σ1,
. . ., σn), where σ1 > · · · > σp and σp+1 > · · · > σn holds.
4. The Hessian of the function fN at a critical point is nondegenerate.
□
The constraint set for our cost function fN : M(Σ) →R is the Lie group
O+
p,q with Lie algebra opq. We choose a basis of opq as
Ωij := eje′
i −eie′
j
(2.23)
where 1 ≤i < j ≤p or p + 1 ≤i < j ≤n holds and
Ωkl := ele′
k + eke′
l
(2.24)
where 1 ≤k ≤p < l ≤n holds.
These basis elements are deﬁned via
the standard basis vectors e1, . . . , en of Rn. Thus exp(tΩij) is an orthogonal
rotation with (i, j)−th sub matrix
· cos t
−sin t
sin t
cos t
¸
(2.25)

2.1 Algorithms
20
and exp(tΩkl) is a hyperbolic rotation with (k, l)−th sub matrix
· cosh t
sinh t
sinh t
cosh t
¸
.
(2.26)
Let N as in Theorem 2.3 above and let W be symmetric positive deﬁnite.
Consider the smooth function
φ : R →R,
φ(t) := tr
³
N etΩW etΩ′ ´
(2.27)
where Ωdenotes a ﬁxed element of the above basis of opq. We have
Lemma 2.1.
1. For Ω= Ωkl = (Ωkl)′ as in (2.24) the function φ : R →R
deﬁned by (2.27) is proper and bounded from below.
2. A minimum
tΩ:= arg min
t∈R φ(t) ∈R
(2.28)
exists for all Ω= Ωij = −(Ωij)′ where 1 ≤i < j ≤p or p + 1 ≤
i < j ≤n holds, and exists as well for all Ω= Ωkl = (Ωkl)′ where
1 ≤k ≤p < l ≤n holds.
□
In [HHM02] the details are ﬁgured out. Moreover, a Jacobi method is
presented for which local quadratic convergence is shown.
A Problem From Computer Vision
The Lie group G under consideration is the semidirect product G = R ⋉R2.
Here G acts linearly on the projective space RP 2. A Jacobi-type method is
formulated to minimize a smooth cost function f : M →R.
Consider the Lie algebra
g :=


B =


b1
b2
b3
0
0
0
0
0
0

; b1, b2, b3 ∈R



(2.29)

2.1 Algorithms
21
with Lie bracket the matrix commutator. Exponentiating a general B ∈g
gives us the representation of a general Lie group element
exp(B) = I3 + h(b1)B
with
h(b1) :=







eb1 −1
b1
for b1 ̸= 0
1
for b1 = 0
.
(2.30)
A one-parameter subgroup of
G = {A ∈R3×3|A = I3 + h(b1)B, B ∈g}
(2.31)
is the smooth curve
exp(tB) = I3 + t · h(t · b1)B.
(2.32)
Given a 3 × 3-matrix N = N ′ > 0 and let M = {X = ANA′|A ∈G}. Then
M is a smooth and connected manifold. The tangent space of M at X ∈M
is TXM = {BX + XB′|B ∈g}.
The stereo matching problem without correspondences can be formulated
mathematically in the following way. Given two symmetric matrices X, Q ∈
R3×3
X =
k
X
i=1


x1,i
y1,i
1

[x1,i, y1,i, 1],
Q =
k
X
i=1


x2,i
y2,i
1

[x2,i, y2,i, 1].
(2.33)
In the sequel we will always assume that X and Q are positive deﬁnite.
This assumption corresponds to a generic situation in the stereo matching
problem. In the noise free case one can assume that there exists a group
element A ∈G such that
Q −AXA′ = 03.
(2.34)
Our task then is to ﬁnd such a matrix A ∈G. A convenient way to do so is
using a variational approach as follows. Deﬁne the smooth cost function

2.1 Algorithms
22
f : M →R,
f(X) = ∥Q −X∥2,
(2.35)
where ∥Y ∥2 :=
3P
i,j=1
y2
ij. The critical points of f are given by
Lemma 2.2. The unique global minimum Xc of the function f : M →
R, f(X) = ∥Q −X∥2 is characterized by Q = Xc. There are no further
critical points.
□
Following the above approach we ﬁx a basis of the Lie algebra g =
⟨B1, B2, B3⟩with corresponding one-parameter subgroups of G
Ai(t) = etBi, t ∈R,
i = 1, 2, 3.
(2.36)
Using an arbitrary ordering of the A1(t), A2(t), A3(t) the proposed algorithm
then consists of a recursive application of sweep operations. In [HH98] it
is shown that under reasonable assumptions this algorithm will converge
quadratically.
Moreover, numerical experiments indicate that only about
ﬁve iterations are enough to reach the minimum.
2.1.4
Applications and Examples for Block Jacobi
If M = Rn one gets the socalled grouped variable version of the cyclic coor-
dinate descent method, cf. [BHH+87].
For applications with M = On · x or M = (On × Om) · x, cf. [H¨up96].
There, Kogbetliantz algorithms for singular value decompositions (2-dim-
ensional optimization) and Block Jacobi for the real skewsymmetric eigen-
value problem (4-dimensional optimization) are considered. In contrast to the
socalled onesided Jacobi methods for singular value computations, twosided
methods essentially solve in each iteration step an optimization problem with
two parameters. Similarly, as for the real symmetric eigenvalue problem, the
subsets the cost function is restricted to in each step are compact, more-
over, solving the restricted optimization problem is possible in closed form.
The same holds true if one goes one step further, cf. [Hac93, Lut92, Mac95,
Meh02, Paa71, RH95] or section 8.5.11 on Block Jacobi procedures in [GvL89]
and references cited therein. The idea behind applying Block Jacobi methods

2.2 Local Convergence Analysis
23
to matrix eigenvalue problems is the following. Instead of zeroing out exactly
one oﬀdiagonal element (resp. two in the symmetric case) in each step, one
produces a whole block of zeroes simultaneously outside the diagonal. More-
over, each such block is visited once per sweep operation. For all the papers
cited above there exits a reinterpretation by the grouped variable approach,
but this will not ﬁgured out here.
2.2
Local Convergence Analysis
We now come to the main result (Theorem 2.4) of this chapter, giving, under
reasonable smoothness assumptions, suﬃcient conditions for a Jacobi-type
algorithm to be eﬃcient, i.e., being locally at least quadratically convergent.
Assumption 2.1.
1. The cost function f : M →R is smooth. The cost
f has a local minimum, say xf, with nondegenerate Hessian at this
minimum. The function f attains an isolated global minimum when
restricting it to the image of the mappings γ(x)
i
.
2. All the partial algorithmic steps of the algorithm have xf as a ﬁxed
point.
3. All the partial algorithmic steps are smooth mappings in an open neigh-
borhood of the ﬁxed point xf. For this we require the (multi-)step size
selection rule, i.e., computation of the set of t-parameters, to be smooth
around xf.
Remark 2.1. In the sequel of this chapter we will not assume less than C∞-
smoothness properties on mappings involved. This would sometimes obscure
notation, moreover, for applications we have in mind, C∞-smoothness is often
guaranteed.
Theorem 2.4. Consider the Block Jacobi Algorithm 2.4. Assume that As-
sumption 2.1 is fulﬁlled. Then this algorithm is locally quadratically conver-
gent if the vector subspaces Vi from the direct sum decomposition
TxfM = V1 ⊕· · · ⊕Vm
are mutually orthonormal with respect to the Hessian of the cost function f
at the ﬁxed point xf.

2.2 Local Convergence Analysis
24
Proof. The Block Jacobi Algorithm is deﬁned as
s : M →M,
s(x) = (rm ◦· · · ◦r1)(x),
i.e., a sweep consists of block minimzation steps, m in number. To be more
precise, each partial algorithmic step is deﬁned by a basic transformation
x 7→ri(x) = Gi(t, x)|t=t(i)
∗.
(2.37)
For each partial step ri : M →M the ﬁxed point condition holds
ri(xf) = xf,
i = 1, . . . , m.
(2.38)
The smoothness properties of each ri around the ﬁxed point xf allows us
to do analysis on M around xf. The derivative of a sweep at x ∈M is the
linear map
D s(x) : TxM →Ts(x)M
(2.39)
assigning to any ξ ∈TxM by the chain rule the value
D s(x) · ξ = D rm
¡
(rm−1 ◦. . . ◦r1)(x)
¢
· . . . · D r1(x) · ξ.
(2.40)
That is, by the ﬁxed point condition
D s(xf) : TxfM →TxfM,
D s(xf) · ξ = D rm(xf) · . . . · D r1(xf) · ξ
(2.41)
holds. Let us take a closer look to the linear maps
D ri(xf) : TxfM →TxfM.
(2.42)
Omitting for a while any indexing, consider as before the maps of basic
transformations

2.2 Local Convergence Analysis
25
G : Rl × M →M,
G(t, x) := γ(x)(t).
(2.43)
Now
D r(xf) · ξ =
³
D1 G(t, x) · D t(x) · ξ + D2 G(t, x) · ξ
´
x=xf, t=t(xf).
(2.44)
Consider the smooth function
ψ : Rli × M →Rli,
ψ(t, x) : =


∂
∂t1...
∂
∂tli

f(G(t, x)).
(2.45)
By deﬁnition of the multi-step size selection rule it follows that
ψ(t(x), x) ≡0.
(2.46)
Applying the Implicit Function Theorem to (2.46) one can get an expression
for the derivative of the multi-step size, D t(xf) · ξ. We will use the following
abbreviations:
eξj := ˙γ
(xf)
j
(0)
for all
j = 1, . . . , li,
H(eξj, eξi) := D2 f(xf) · (eξj, eξi),
H :=
¡
hij
¢
,
hij := H(eξi, eξj).
Finally, we get, using a hopefully not too awkward notation,

2.2 Local Convergence Analysis
26
D ri(xf) · ξ = ξ −
li
X
j=1
eξj(H−1)j−th row ·


H(eξ1, ξ)
...
H(eξli, ξ)


=


id −
h
eξ1
. . .
eξli
i
H−1


H(eξ1, ( · ))
...
H(eξli, ( · ))





|
{z
}
=:Qi
ξ
(2.47)
Note that eξi := ˙γ
(xf)
i
(0) ∈V
(xf)
i
⊂TxfM. Therefore, by the chain rule,
the derivative of one sweep acting on an arbitrary tangent vector ξ ∈TxfM
evaluated at the ﬁxed point (minimum) xf is as
D s(xf) · ξ = Qm · . . . · Q1 · ξ.
(2.48)
For convenience we will switch now to ordinary matrix vector notation,
eξl1, ξ ∈TxfM
←→
eξl1, ξ ∈Rn,
D2 f(xf) : TxfM × TxfM →R
←→
H = H⊤∈Rn×n,
id : TxfM →TxfM
←→
In.
That is, rewriting the right hand side of (2.47)
Qiξ =



In −
h
eξ1
. . .
eξli
i
|
{z
}
=:eΞi


H(eξ1, eξ1)
· · ·
H(eξ1, eξli)
...
...
H(eξli, eξ1)
· · ·
H(eξli, eξli)


−1 

H(eξ1, ( · ))
...
H(eξli, ( · ))





ξ
=
³
In −eΞi(eΞ⊤
i HeΞi)−1eΞ⊤
i H
´
ξ.
We want to examine under which conditions D s(xf) = 0, i.e., we want to
examine to which conditions on the subspaces V
(xf)
i
the condition
Qm · . . . · Q1 ≡0

2.2 Local Convergence Analysis
27
is equivalent to. It is easily seen that for all i = 1, . . . , m
Pi := H
1
2QiH−1
2
= In −(H
1
2 eΞi)
³
(H
1
2 eΞi)⊤(H
1
2 eΞi)
´−1
(H
1
2 eΞi)⊤,
(2.49)
are orthogonal projection operators, i.e.,
Pi = P 2
i = P ⊤
i ,
for all
i = 1, . . . , m,
(2.50)
holds true. Therefore,
Qm · . . . · Q1 = 0
⇔
Pm · . . . · P1 = 0.
(2.51)
To proceed we need a lemma.
Lemma 2.3. Consider Rn with usual inner product. Consider orthogonal
projection matrices Pi = P ⊤
i = P 2
i , i = 1, . . . , m with m ≤n. We require
rk Pi = n −ki
and
m
X
j=1
kj = n.
(2.52)
Then the following holds true
Pm · Pm−1 · . . . · P2 · P1 = 0
(2.53)
⇔
ker Pi ⊥ker Pj
for all
i ̸= j.
Proof of Lemma 2.3. We prove the “only if”-part, the “if”-part is immediate.
Each projection matrix can be represented as
Pi = In −XiX⊤
i
(2.54)
with Xi ∈Stki,n, i.e., a full rank matrix Xi ∈Rn×ki with orthonormal
columns, X⊤
i Xi = Iki.

2.2 Local Convergence Analysis
28
Claim 2.1. The equation (2.53)
Pm · Pm−1 · . . . · P2 · P1 = 0
holds if and only if there exists Θ ∈On, such that
ePi = ΘPiΘ⊤,
for all
i = 1, . . . , m,
(2.55)
satisfy
1.
ePm · . . . · eP1 = 0,
(2.56)
2.
ePi =
·∗
0
0
In−k1−...−ki
¸
.
(2.57)
Proof of Claim 2.1. Without loss of generality (2.57) holds for i = 1. To see
that (2.57) holds also for i = 2 consider an orthogonal matrix Θ2 ∈On of
block diagonal form
Θ2 :=
·Ik1
0
0
U2
¸
,
with orthogonal submatrix U2 ∈On−k1. Clearly, such a Θ2 stabilizes eP1, i.e.,
Θ2 eP1Θ⊤
2 = eP1.
(2.58)
Moreover, Θ2, (respectively, U2) can be chosen such as to block diagonalize
P2 as
Θ2P2Θ⊤
2 = In −Θ2X2X⊤
2 Θ⊤
2 =
·∗
0
0
In−k1−k2
¸
= eP2,
(2.59)
by requiring the product Θ2X2 to be as
Θ2X2 =
·Ik1
0
0
U2
¸
X2 =
·
∗
0(n−k1−k2)×(k2)
¸
∈Stk2,n .
(2.60)
Recall that n −k1 ≥k2. Now proceeding inductively using

2.2 Local Convergence Analysis
29
ΘlXl =
·Ikl−1
0
0
Ul
¸
Xl =
·
∗
0(n−k1−···−kl)×(kl)
¸
∈Stkl,n
(2.61)
for l = 3, . . . , m −1, with suitably chosen Ul ∈On−k1−···−kl−1 proves (2.57).
By deﬁning Θ ∈On as
Θ := Θm−1 · · · Θ1
where
Θ1P1Θ⊤
1 =
·0k1
0
0
In−k1
¸
= eP1,
Claim 2.1 follows.
Proof of Lemma 2.3 continued. By Claim 2.1 the product ePm−1 ·. . .· eP1 takes
the block diagonal form
ePm−1 · · · eP1 =
·∗
0
0
In−k1−···−km−1
¸
· . . . ·
·∗
0
0
In−k1−k2
¸
·
·0k1
0
0
In−k1
¸
=
·∗
0
0
In−k1−···−km−1
¸
=
·∗
0
0
Ikm
¸
.
(2.62)
Recall that rk ePm = n −km. Therefore we have the implications
ePm · ( ePm−1 · · · eP1) = 0 ⇒
ePm =
·∗
0
0
0km
¸
⇒
ePm =
·In−km
0
0
0km
¸
.
(2.63)
Now we proceed by working oﬀthe remaining product ePm−1 · ( ePm−2 · · · eP1)
from the left.

2.2 Local Convergence Analysis
30
Analogously to (2.62) we have
ePm−2 · · · eP1 =


∗
0
0
0
Ikm−1
0
0
0
Ikm

,
(2.64)
and similarly to (2.63) we have the implications
ePm−1( ePm−2 · · · eP1) =
·0n−km
0
0
Ikm
¸
⇒ePm−1 =


∗
0
0
0
0km−1
0
0
0
Ikm


⇒ePm−1 =


Ik1+...+km−2
0
0
0
0km−1
0
0
0
Ikm

.
The result of Lemma 2.3 follows then by induction, i.e.,
ePi =


Ik1+...+ki−1
0
0
0
0ki
0
0
0
Iki+1+...+km


holds true for all i = 2, . . . , m −1,
eP1 =
·0k1
0
0
In−k1
¸
,
and
ePm =
·In−km
0
0
0km
¸
.
Proof of Theorem 2.4 continued.
Finishing the proof of our theorem we
therefore can state that
D s(xf) · ξ = D rm(xf) · . . . · D r1(xf) = 0
holds true if the direct sum decomposition

2.3 Discussion
31
TxfM = V1 ⊕· · · ⊕Vm
is also orthonormal with respect to the Hessian of our objective function
f at the ﬁxed point (minimum) xf. The result follows by the Taylor-type
argument
∥xk+1 −xf∥≤sup
z∈U
∥D2 s(z)∥· ∥xk −xf∥2.
2.3
Discussion
From our point of view there are several advantages of the calculus approach
we have followed here. It turns out that the ordering partial algorithmic steps
are worked oﬀdo not play a role for the quadratic convergence. Forinstance
for the symmetric eigenvalue problem several papers have been published
to show that row-cyclic and column-cyclic strategies both ensure quadratic
convergence. Our approach now shows that the convergence properties do
not depend on the ordering in general.
Exploiting the diﬀerentiability properties of the algorithmic maps oﬀers
a much more universal methodology for showing quadratic convergence than
sequences of tricky estimates usually do. It is e.g. often the case that es-
timates used for On-related problems may not be applicable to GLn-related
ones and vice versa. On the other hand computing the derivative of an algo-
rithm is always the same type of calculation. But the most important point
seems to be the fact that our approach shows quadratic convergence of a ma-
trix algorithm itself. If one looks in text books on matrix algorithms usually
higher order convergence is understood as a property of a scalar valued cost
function (which can even just the norm of a subblock) rather than being a
property of the algorithm itself considered as a selfmap of some manifold.

Chapter 3
Reﬁning Estimates of Invariant
Subspaces
We are interested in reﬁning estimates of invariant subspaces of real non-
symmetric matrices which are already “nearly” block upper triangular. The
idea is the following. The Lie group of real unipotent lower block triangular
(n × n)-matrices acts by similarity on such a given nearly block upper tri-
angular matrix. We will develop several algorithms consisting on similarity
transformations, such that after each algorithmic step the matrix is closer
to perfect upper block triangular form. We will show that these algorithms
are eﬃcient, meaning that under certain assumptions on the starting ma-
trix, the sequence of similarity transformed matrices will converge locally
quadratically fast to a block upper triangular matrix. The formulation of
these algorithms, as well as their convergence analysis, are presented in a
way, such that the concrete block sizes chosen initially do not matter. Espe-
cially, in applications it is often desirable for complexity reasons that a real
matrix which is close to its real Schur form, cf. p.362 [GvL89], is brought
into real Schur form by using exclusively real similarities instead of switching
to complex ones.
In this chapter we always work over R. The generalization to C is im-
mediate and we state without proof that all the results from this chapter
directly apply to the complex case.
The outline of this chapter is as follows. After introducing some nota-
tion we will focus on an algorithm consisting on similarity transformations
by unipotent lower block triangular matrices. Then we reﬁne this approach
by using orthogonal transformations instead, to improve numerical accuracy.

3.1 Lower Unipotent Block Triangular Transformations
33
The convergence properties of the orthogonal algorithm then will be an im-
mediate consequence of the former one.
3.1
Lower Unipotent Block Triangular Trans-
formations
Let denote V ⊂Rn×n the subvector space of real block upper triangular
(n × n)−matrices
V := {X ∈Rn×n|Xij = 0ni×nj ∀1 ≤j < i ≤r}},
(3.1)
i.e., an arbitrary element X ∈V looks like
X =


X11
· · ·
· · ·
X1r
0
...
...
...
...
...
...
0
· · ·
0
Xrr


(3.2)
the diagonal subblocks Xii ∈Rni×ni, i = 1, . . . , r, being square and therefore
r
X
i=1
ni = n.
Let denote Ln the Lie group of real unipotent lower block triangular (n×n)-
matrices with partitioning according to V
Ln :=
½
X ∈Rn×n
¯¯¯¯
Xkk = Ink
∀1 ≤k ≤r,
Xij = 0ni×nj
∀1 ≤i < j ≤r
¾
,
(3.3)
i.e., an arbitrary element X ∈Ln looks like
X =


In1
0
· · ·
0
X21
...
...
...
...
...
0
Xnr,1
· · ·
Xnr,nr−1
Inr


.
(3.4)
Given a real block upper triangular matrix

3.1 Lower Unipotent Block Triangular Transformations
34
A =


A11
· · ·
· · ·
A1r
0
...
...
...
...
...
...
0
· · ·
0
Arr


(3.5)
consider the orbit MLn of A under similarity action σ of Ln.
σ : Ln × V →Rn×n,
(L, X) 7→LXL−1,
(3.6)
and
MLn := {X ∈Rn×n | X = LAL−1, L ∈Ln}.
(3.7)
In this chapter we will make the following assumptions:
Assumption 3.1. Let A as in (3.5). The spectra of the diagonal subblocks
Aii, for i = 1, . . . , r, of A are mutually disjoint.
Our ﬁrst result shows that any matrix lying in a suﬃciently small neigh-
borhood of A which fulﬁls Assumption 3.1, is then element of an Ln-orbit of
some other matrix, say B, which also fulﬁls Assumption 3.1.
Let A ∈Rn×n fulﬁl Assumption 3.1. Consider the smooth mapping
σ : Ln × V →Rn×n,
σ(L, X) = LXL−1.
(3.8)
Lemma 3.1. The mapping σ deﬁned by (3.8) is locally surjective around
(I, A).
Proof. Let denote ln the Lie algebra of real lower block triangular (n × n)-
matrices
ln :=
½
X ∈Rn×n
¯¯¯¯
Xkk = 0nk
∀1 ≤k ≤r,
Xij = 0ni×nj
∀1 ≤i < j ≤r
¾
,
(3.9)
i.e., an arbitrary element X ∈ln looks like

3.1 Lower Unipotent Block Triangular Transformations
35
X =


0n1
0
· · ·
0
X21
...
...
...
...
...
0
Xnr,1
· · ·
Xnr,nr−1
0nr


.
(3.10)
It is suﬃcient to show that the derivative
D σ(I, A) : ln × V →Rn×n
(3.11)
is locally surjective. For arbitrary l ∈ln and for arbitrary a ∈V the following
holds true
D σ(I, A) · (l, a) = lA −Al + a.
(3.12)
We show that for any h ∈Rn×n the linear system
lA −Al + a = h
(3.13)
has a solution in terms of l ∈ln and a ∈V . By decomposing into block
upper triangular and strictly block lower triangular parts
h = hbl.upp. + hstr.bl.low.
(3.14)
and because a ∈V is already block upper triangular it remains to show that
the strictly lower block triangular part of (3.13)
(lA −Al)str.bl.low = hstr.bl.low.
(3.15)
can be solved for l ∈ln. We partition into “blocks of subblocks”
l =
·l11
0
lf
21
lf
22
¸
,
A =
·A11
Af
12
0
Af
22
¸
,
hstr.low.bl. =
·(h11)str.low.bl.
0
hf
21
(hf
22)str.low.bl.
¸
,
accordingly, i.e., A11 ∈Rn1×n1 and l11 = 0n1 as before. Thus one has to solve
for lf
21 and lf
22. Considering the ( e21)−block of (3.15) gives

3.1 Lower Unipotent Block Triangular Transformations
36
lf
21A11 −Af
22lf
21 = hf
21,
(3.16)
By Assumption 3.1, the Sylvester equation (3.16) can be solved uniquely
for lf
21, i.e., the block lf
21 is therefore ﬁxed now.
Applying an analogous
argumentation to the ( e22)−block of (3.15)
lf
22Af
22 −Af
22lf
22 = −lf
21Af
12 + (hf
22)str.low.,
(3.17)
and by continuing inductively (l := lf
22, A := Af
22, etc.) by partitioning into
smaller blocks of subblocks of the remaining diagonal blocks Aii, i = 2, . . . , r,
gives the result.
Let A ∈Rn×n fulﬁl Assumption 3.1. Let
MLn :=
©
X ∈Rn×n|X = LAL−1, L ∈Ln
ª
.
(3.18)
The next lemma characterizes the Ln-orbit of the matrix A.
Lemma 3.2. MLn is diﬀeomorphic to Ln.
Proof. The set MLn is a smooth manifold, because it is the orbit of a semi-
algebraic group action, see p.353 [Gib79]. We will show that the stabilizer
subgroup stab(A) ⊂Ln equals the identity {I} in Ln, i.e., the only solution
in terms of L ∈Ln for
LAL−1 = A
⇐⇒
[L, A] = 0
(3.19)
is L = I. Partition L into blocks of blocks
L =
·In1
0
Lf
21
Lf
22
¸
where the second diagonal block Lf
22 ∈Ln−n1. Let
A =
·A11
Af
12
0
Af
22
¸
be accordingly to L partitioned. The ( e21)−block of the equation [L, A] = 0
is as
Lf
21A11 −Af
22Lf
21 = 0.
(3.20)

3.2 Algorithms
37
By Assumption 3.1 on the spectrum of A, equation (3.20) implies Lf
21 = 0.
By recursive application of this argumentation to the ( e22)−block of (3.19)
the result follows. Therefore, L = I implies stab(A) = {I} and hence
MLn ∼= Ln/ stab(A) = Ln
(3.21)
3.2
Algorithms
3.2.1
Main Ideas
The algorithms presented in this chapter for the iterative reﬁnement of in-
variant subspaces of nonsymmetric real matrices are driven by the following
ideas.
Let the matrix A be partitioned as in
A =


A11
· · ·
· · ·
A1r
0
...
...
...
...
...
0
· · ·
0
Arr


(3.22)
and fulﬁlling Assumption 3.1. Consider an X ∈MLn, MLn the A-orbit of
the similarity action by Ln. Assume X is suﬃciently close to A, i.e.,
∥X −A∥< ∆λ
(3.23)
holds, where ∥Z∥:=
p
tr(ZZ⊤) and ∆λ denotes the absolute value of the
smallest diﬀerence of two eigenvalues of A which correspond to diﬀerent
diagonal subblocks of A. Obviously,
span




0(n1+...+ni−1)×ni
Ini
0(ni+1+...+nr)×ni




(3.24)
is then for all i = 1, . . . , n a good approximation for an ni-dimensional right
invariant subspace of X, because by assumption (3.23) on X, for all j > i
∥Xji∥
is small.
(3.25)

3.2 Algorithms
38
Consider an L(α) ∈Ln of the following partitioned form
L(α) :=


In1
...
Inα
p(α+1,α)
...
...
...
p(r,α)
Inr


,
(3.26)
where empty blocks are considered to be zero ones. We want to compute
P (α) :=


p(α+1,α)
...
p(r,α)

∈R(nα+1+...+nr)×nα,
(3.27)
such that
LαXL−1
α =


In1+...+nα−1
0
0
0
Inα
0
0
P (α)
Inα+1+...+nr

X


In1+...+nα−1
0
0
0
Inα
0
0
−P (α)
Inα+1+...+nr


= Z,
(3.28)
where Z is of the form
Z =


Z11
· · ·
· · ·
· · ·
· · ·
· · ·
Z1,r
...
...
...
...
Zα−1,α−1
...
...
...
Zα,α
...
...
...
0
Zα+1,α+1
...
...
...
...
...
...
...
Zr1
· · ·
Zr,α−1
0
Zr,α+1
· · ·
Zr,r


,
(3.29)
i.e., the blocks below the diagonal block Zα,α are zero. For convenience we
assume for a while without loss of generality that r = 2. Therefore, we want
to solve the (21)-block of

3.2 Algorithms
39
· I
0
P (1)
I
¸
·
·X11
X12
X21
X22
¸
·
·
I
0
−P (1)
I
¸
=
·Z11
Z12
0
Z22
¸
(3.30)
in terms of P (1), i.e., we want to solve the matrix valued algebraic Riccati
equation
P (1)X11 + X21 −P (1)X12P (1) −X22P (1) = 0.
(3.31)
As a matter of fact, (3.31) is in general not solvable in closed form.
As
a consequence authors have suggested several diﬀerent approaches to solve
(3.31) iteratively. See [Cha84] for Newton-type iterations on the noncompact
Stiefel manifold and [DMW83, Ste73] for iterations like
Pi+1X11 −X22Pi+1 = PiX12Pi −X21,
P0 = 0.
(3.32)
Moreover, see [Dem87] for a comparison of the approaches of the former three
papers. For quantitative results concerning Newton-type iterations to solve
Riccati equations see also [Nai90].
A rather natural idea to solve (3.31) approximately is to ignore the second
order term, −P (1)X12P (1), and solve instead the Sylvester equation
P (1)X11 + X21 −X22P (1) = 0.
(3.33)
Note that by Assumption 3.1 equation (3.33) is uniquely solvable.
Now we switch back to the general case where the number r of invariant
subspaces to be computed is not necessarily equal to 2.
Having in mind
sweep-type algorithms it is natural to formulate an algorithm which solves
an equation like (3.33) for P (1), respecting (3.26)-(3.29), say, then transform
X according to X 7→L1XL−1
1 , do the same for P (2), and so forth. One
can show that such an algorithm would be a diﬀerentiable map around A.
Moreover, local quadratic convergence could be proved by means of analysis.
But the story will not end here as we will see now.
Instead of solving a Sylvester equation for
P (α) =


p(α+1,α)
...
p(r,α)

,
(3.34)

3.2 Algorithms
40
i.e., solving for the corresponding block of (3.28), one could reﬁne the algo-
rithm reducing complexity by solving Sylvester equations of lower dimen-
sion in a cyclic manner, i.e., perform the algorithm block wise on each
p(ij) ∈Rni×nj.
In principle one could reﬁne again and again reaching ﬁ-
nally the scalar case but then, not necessarily all Sylvester equations could
be solved, because within a diagonal block we did not assume anything on
the spectrum. On the other hand, if the block sizes were 1 × 1, e.g., if one
already knew that all the eigenvalues of A were distinct, then the resulting
scalar algebraic Riccati equations were solvable in closed form, being just
quadratics. We would like to mention that such an approach would come
rather close to [BGF91, CD89, Ste86] where the authors studied Jacobi-type
methods for solving the nonsymmetric (gerneralized) eigenvalue problem.
3.2.2
Formulation of the Algorithm
The following algorithm will be analyzed. Given an X ∈MLn and let A fulﬁl
Assumption 3.1. Assume further that X is suﬃciently close to A. Consider
the index set
I := {(ij)}i=2,...,r;j=1,...,r−1
(3.35)
and ﬁx an ordering, i.e., a surjective map
β : I →
½
1, . . . ,
µr
2
¶¾
.
(3.36)
For convenience we rename double indices in the discription of the algorithm
by simple ones by means of Xij 7→Xβ(ij) respecting the ordering β.

3.2 Algorithms
41
Algorithm 3.1 (Sylvester Sweep).
Given an X ∈MLn. Deﬁne
X(1)
k
:= L1XL−1
1
X(2)
k
:= L2X(1)
k L−1
2
...
X(r
2)
k
:= L(r
2)X(r
2)−1
k
L−1
(r
2)
where for l = 1, . . . ,
¡r
2
¢
, the transformation matrix Ll ∈
Ln diﬀers from the identity matrix In only by the ij-th
block, say pl.
Here pl ∈Rnj×ni, β((ij)) = l, and pl solves the Sylvester
equation
pl
³
X(l−1)
k
´
jj −
³
X(l−1)
k
´
ii pl +
³
X(l−1)
k
´
ij = 0.
The overall algorithm then consists of the iteration of sweeps.
Algorithm 3.2 (Reﬁnement of Estimates of Sub-
spaces).
• Let X0, . . . , Xk ∈MLn be given for k ∈N0.
• Deﬁne the recursive sequence X(1)
k , . . . , X(r
2)
k
as
above (sweep).
• Set Xk+1 := X(r
2)
k
. Proceed with the next sweep.
For convenience let us write down one sweep for r = 3. Fixing the ordering

3.2 Algorithms
42
β
¡
(21)
¢
= 1,
β
¡
(31)
¢
= 2,
β
¡
(32)
¢
= 3,
(3.37)
we have for
A =


A11
A12
A13
0
A22
A23
0
0
A33

,
X =


X11
X12
X13
X21
X22
X23
X31
X23
A33

,
X1 =


I
0
0
p1
I
0
0
0
I

X


I
0
0
−p1
I
0
0
0
I

,
X2 =


I
0
0
0
I
0
p2
0
I

X1


I
0
0
0
I
0
−p2
0
I

,
X3 =


I
0
0
0
I
0
0
p3
I

X2


I
0
0
0
I
0
0
−p3
I

.
In contrast to our Jacobi approach in Chapter 2, where the analysis showed
that the ordering, the partial algorithmic steps where worked oﬀ, did not
inﬂuence the quadratic convergence properties, the ordering in the present
case will do.
For the index set
I := {(ij)}i=2,...,r;j=1,...,r−1
we ﬁx the following two diﬀerent orderings. The ﬁrst one is as

3.2 Algorithms
43
βcol : I →
½
1, . . . ,
µr
2
¶¾
,
βcol
¡
(r1)
¢
= 1,
...
βcol
¡
(21)
¢
= r −1,
βcol
¡
(r2)
¢
= r,
...
βcol
¡
(32)
¢
= r −1 + r −2 = 2r −3,
...
...
βcol
¡
(r, r −2)
¢
=
µr
2
¶
−2,
βcol
¡
(r −1, r −2)
¢
=
µr
2
¶
−1,
βcol
¡
(r, r −1)
¢
=
µr
2
¶
,
clariﬁed by the following diagram
r-1
...
2r−3
...
...
...
↑
↑
↑
`r
2
´
−1
1
r
· · ·
`r
2
´
−2
`r
2
´
.
The second ordering is as
βrow : I →
½
1, . . . ,
µr
2
¶¾
,

3.2 Algorithms
44
`r
2
´
`r
2
´
−2
`r
2
´
−1
...
→
...
r
→
· · ·
2r−3
1
→
· · ·
· · ·
r−1
.
Obviously, the two orderings are mapped into each other by just trans-
posing the diagrams with respect to the antidiagonal.
3.2.3
Local Convergence Analysis
The next result shows that our algorithm is locally a smooth map.
Theorem 3.1. Algorithm 3.2
s : MLn →MLn
(3.38)
is a smooth mapping locally around A.
Proof. The algorithm is a composition of partial algorithmic steps
ri : MLn →MLn,
(3.39)
with ri(A) = A for all i. It therefore suﬃces to show smoothness for each ri
around the ﬁxed point A. Typically, for one partial iteration step one has to
compute the subblock p of the unipotent lower block triangular matrix
L =
·I
0
p
I
¸
fulﬁlling the equality
LXL−1 =
·I
0
p
I
¸
·
·X11
X12
X21
X22
¸
·
· I
0
−p
I
¸
=
·
∗
∗
−pX12p
∗
¸
i.e., p has to solve the Sylvester equation
pX11 + X21 −X22p = 0.

3.2 Algorithms
45
By assumption on the spectra of X11 and X22, respectively, the solution of
this Sylvester equation exists and is unique. Moreover, applying the Implicit
Function Theorem to the function
(X, p) 7→f(X, p),
f(X, p) = pX11 + X21 −X22p = 0
(3.40)
implies that X 7→p(X) is smooth around A. Hence all partial iteration steps
are smooth, the result follows.
The above Theorem 3.1 justiﬁes to use calculus for proving higher order
convergence of our algorithm.
We show next that the ﬁrst derivative of
our algorithm s at the ﬁxed point A vanishes identically implying quadratic
convergence if the chosen ordering is either βrow or βcol.
Theorem 3.2. Algorithm 3.2 converges locally quadratically fast if as an
ordering βrow or βcol is chosen.
Proof. We will show that the ﬁrst derivative D s(A) of the algorithm s at the
ﬁxed point A vanishes identically if βcol or βrow is chosen. By the chain rule
we therefore have to compute the D rij(A) for all i > j with 2 ≤i ≤l and
1 ≤j ≤m −1. To be more precise, we have to study the eﬀect of applying
the linear map
D rij(A) : TAMLn →TAMLn
to those tangent vectors [l, A] ∈TAMLn onto which the “earlier” linear maps
D rpq(A) have been already applied to
D s(A) · [l, A] = D rlast(A) · . . . · D rﬁrst(A) · [l, A],
l ∈ln.
Notice that A is not only a ﬁxed point of s but also one of each individual r.
For simplicity but without loss of generality we may assume that the
partitioning consists of 5 by 5 blocks. Typically, an rij(X) = LijXL−1
ij looks
like
rij(X) =


I
0
0
0
0
0
I
0
0
0
0
0
I
0
0
0
pij
0
I
0
0
0
0
0
I


· X ·


I
0
0
0
0
0
I
0
0
0
0
0
I
0
0
0
−pij
0
I
0
0
0
0
0
I


.
(3.41)

3.2 Algorithms
46
Therefore,
D rij(A) · [l, A] = D(LijXL−1
ij ) · [l, X]|X=A = [L′
ij, A] + [l, A]
where
L′
ij := D Lij(A) · [l, A],
and typically
L′
ij =


0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
p′
ij
0
0
0
0
0
0
0
0


with
p′
ij := D pij(X) · [l, X]|X=A.
We already know that pij solves a Sylvester equation, namely
pij(X)Xjj + Xij −Xiipij(X) = 0,
(3.42)
with
pij(X)|X=A = 0.
(3.43)
Taking the derivative of the Sylvester equation (3.42) acting on [l, X] evalu-
ated at X = A gives
p′
ij(A)Ajj + [l, A]ij −Aiip′
ij(A) = 0.
(3.44)
An easy computation veriﬁes that the commutator [L′
ij, A] is of the following
form
[L′
ij, A] =


0
∗
0
0
0
0
∗
0
0
0
0
∗
0
0
0
0
p′
ijAjj −Aiip′
ij
∗
∗
∗
0
0
0
0
0


,

3.2 Algorithms
47
i.e., it diﬀers from zero only by the (ij)-th block as well as by those blocks,
which are to the right to, or which are above to this (ij)-th block. Therefore
by (3.44), for the derivative of the (ij)-th partial step rij we get
D rij(A) · [l, A] =


0
∗
0
0
0
0
∗
0
0
0
0
∗
0
0
0
0
p′
ijAjj −Aiip′
ij
∗
∗
∗
0
0
0
0
0


|
{z
}
[L′
ij,A]
+


∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
[l, A]ij
∗
∗
∗
∗
∗
∗
∗
∗


|
{z
}
[l,A]
.
That is, by (3.44) the ﬁrst derivative annihilates the (ij)−th block, altering
those blocks which are above or to the right to this (ij)−th block, but it
leaves invariant all the other remaining blocks. Apparently, both ordering
strategies now ensure, that after a whole iteration step all those blocks of the
tangent vector [l, A] lying below the main diagonal of blocks are eliminated.
We therefore can conclude that
D rij(A) · [l, A] =


∗
∗
∗
∗
∗
0
∗
∗
∗
∗
0
0
∗
∗
∗
0
0
0
∗
∗
0
0
0
0
∗


.
(3.45)
But we can even conclude more, namely
D rij(A) · [l, A] = 0.
(3.46)
This is easily proved following the argumentation in the proof of Lemma 3.2.
Essentially, Assumption 3.1 ensures that the only Lie algebra element of ln,
which commutes with A into a block upper triangular matrix like A itself, is
the zero matrix.
The result follows by the Taylor-type argument
∥Xk+1 −A∥≤sup
Z∈U
∥D2 s(Z)∥· ∥Xk −A∥2.

3.2 Algorithms
48
3.2.4
Further Insight to Orderings
Quite naturally one might ask if the two orderings βrow and βcol are the only
possible ones ensuring quadratic convergence.
The answer is no, because
somehow “mixtures” of both strategies will also suﬃce as we will demonstrate
by a few low dimensional examples.
Example 3.1. For r = 3 there are two possible orderings ensuring quadratic
convergence for Algorithm 3.2:
3
1
2
and
2
1
3
.
Example 3.2. For r = 4 there are eight possible orderings together with
its “conjugate” counterparts (transposing with respect to the antidiagonal)
ensuring quadratic convergence for Algorithm 3.2:
6
4
5
1
2
3
,
5
4
6
1
2
3
,
6
3
5
1
2
4
,
5
3
6
1
2
4
,
5
3
4
1
2
6
,
6
3
4
1
2
5
,
4
3
5
1
2
6
,
4
3
6
1
2
5
.
Remark 3.1. The possible orderings are related to Young tableaux, or to be
more precise, to standard tableaux. See [Ful97] for the connections between
geometry of ﬂag manifolds, representation theory of GLn, and calculus of
tableaux.

3.2 Algorithms
49
Consequently, as a corollary of Theorem 3.2 we get the following result.
Corollary 3.1. Algorithm 3.2 is quadratic convergent if the ordering is spec-
iﬁed by the following two rules. The integers 1, . . . ,
¡r
2
¢
to be ﬁlled in
1. are strictly increasing across each row,
2. are strictly increasing up each column.
□
We did not comment yet on orderings which are deﬁnitely not leading to
quadratic convergence. It seems to be a cumbersome combinatorial problem
to decide weather some ordering which does not respect Corollary 3.1 is
always bad. To answer this question one needs also information on the ﬁxed
point as we see now by some further examples.
For the following series of examples let the ﬁxed point be given by
A :=


a11
a12
a13
0
a22
a23
0
0
a33

.
(3.47)
The partitioning will be according to n = r = 3, i.e., the block sizes are
always 1 × 1. Therefore, an arbitrary tangent element ξ ∈TAML3 is of the
form
ξ = [l, A]
=


−(a12 l21) −a13 l31
−(a13 l32)
0
a11 l21 −a22 l21 −a23 l31
a12 l21 −a23 l32
a13 l21
a11 l31 −a33 l31
a12 l31 + a22 l32 −a33 l32
a13 l31 + a23 l32


with
l :=


0
0
0
l21
0
0
l31
l32
0

.
(3.48)
Example 3.3. Here we study explicitly the eﬀect of the ordering

3.2 Algorithms
50
1
2
3
We get
D r1(A)ξ =


−
³
(a11 a13−a13 a22+a12 a23) l31
a11−a22
´
−(a13 l32)
0
0
a23 (a12 l31+(−a11+a22) l32)
a11−a22
a13 a23 l31
a11−a22
(a11 −a33) l31
a12 l31 + (a22 −a33) l32
a13 l31 + a23 l32

,
D r2(A) D r1(A)ξ =


a12 a23 l31
−a11+a22
−(a13 l32)
0
a23 l31
a23 (a12 l31+(−a11+a22) l32)
a11−a22
a13 a23 l31
a11−a22
0
(a22 −a33) l32
a23 l32

,
D r3(A) D r2(A) D r1(A)ξ =


a12 a23 l31
−a11+a22
0
0
a23 l31
a12 a23 l31
a11−a22
a13 a23 l31
a11−a22
0
0
0


̸= 0.
But if one assumes that for the entry a23 of the ﬁxed point A
a23 = 0
(3.49)
holds, then even this ordering results in a quadratic convergent algorithm.
□
Example 3.4. Here quadratic convergence is ensured according to Theorem
3.2:
2
1
3

3.2 Algorithms
51
We get
D r1(A)ξ =


−(a12 l21)
−(a13 l32)
0
(a11 −a22) l21
a12 l21 −a23 l32
a13 l21
0
(a22 −a33) l32
a23 l32

,
D r2(A) D r1(A)ξ =


0
−(a13 l32)
0
0
−(a23 l32)
0
0
(a22 −a33) l32
a23 l32

,
D r3(A) D r2(A) D r1(A)ξ =


0
0
0
0
0
0
0
0
0

.
□
Example 3.5. This is another example which ensures quadratic convergence
only under additional assumptions on the structure of the ﬁxed point.
1
3
2
We get
D r1(A)ξ =


−
³
(a11 a13−a13 a22+a12 a23) l31
a11−a22
´
−(a13 l32)
0
0
a23 (a12 l31+(−a11+a22) l32)
a11−a22
a13 a23 l31
a11−a22
(a11 −a33) l31
a12 l31 + (a22 −a33) l32
a13 l31 + a23 l32

,
D r2(A) D r1(A)ξ =


−
³
(a11 a13−a13 a22+a12 a23) l31
a11−a22
´
a12 a13 l31
a22−a33
0
0
a12 a23 (a11−a33) l31
(a11−a22) (a22−a33)
a13 a23 l31
a11−a22
(a11 −a33) l31
0
(−(a12 a23)+a13 (a22−a33)) l31
a22−a33

,

3.3 Orthogonal Transformations
52
D r3(A) D r2(A) D r1(A)ξ =


a12 a23 l31
−a11+a22
a12 a13 l31
a22−a33
0
a23 l31
a12 a23 (a11−a33) l31
(a11−a22) (a22−a33)
a13 a23 l31
a11−a22
0
−(a12 l31)
a12 a23 l31
−a22+a33


̸= 0.
But if one assumes that
a23 = a12 = 0
(3.50)
holds, then even this ordering results in a quadratic convergent algorithm.
□
3.3
Orthogonal Transformations
For numerical reasons it makes more sense to use orthogonal transformations
instead of unipotent lower triangular ones. We therefore reformulate Algo-
rithm 3.2 in terms of orthogonal transformations. The convergence analysis
for this new algorithm will greatly beneﬁt from the calculations we already
did.
For convenience we assume for a while that r = 5. Given
L =


I
0
0
0
0
0
I
0
0
0
0
0
I
0
0
0
p
0
I
0
0
0
0
0
I


,
a quite natural idea is to use instead of L the orthogonal Q-factor from L
after performing Gram-Schmidt, i.e., L = RQ, to the rows of subblocks of L.
We have
R =


I
0
0
0
0
(I + p⊤p)−1
2
0
p⊤(I + pp⊤)−1
2
0
I
0
0
(I + pp⊤)
1
2
0
I


(3.51)

3.3 Orthogonal Transformations
53
and
Q =


I
0
0
0
0
0
(I + p⊤p)−1
2
0
−(I + p⊤p)−1
2p⊤
0
0
0
I
0
0
0
(I + pp⊤)−1
2p
0
(I + pp⊤)−1
2
0
0
0
0
0
I


.
(3.52)
Before we proceed to formulate the orthogonal version of Algorithm 3.2
we need some preliminaries. Namely we have to ﬁx the manifold such an
algorithm is “living” on.
Consider an “Iwasawa Decomposition” of the Lie group Ln. The set of
orthogonal matrices Q coming from an RQ-decomposition as in (3.51) do in
general not generate an orthogonal group with group operation the ordinary
matrix product. To see this we look at the simple 2 × 2-case
·1
0
p
1
¸
=
"
(I + p⊤p)−1
2
p⊤(I + pp⊤)−1
2
0
(I + pp⊤)
1
2
#
·
"
(I + p⊤p)−1
2
−(I + p⊤p)−1
2p⊤
(I + pp⊤)−1
2p
(I + pp⊤)−1
2
#
.
(3.53)
Obviously, the set of orthogonal Q-matrices does not include
eQ :=
·0
−1
1
0
¸
.
(3.54)
Note that
lim
p→±∞L /∈L2.
(3.55)
Nevertheless, we are able to construct atleast locally the space an orthogonal
version of Algorithm 3.2 can be deﬁned on. This construction will then allow
us to use again analysis to prove quadratic convergence.
Consider an arbitrary element L ∈Ln in a suﬃciently small neighbor-
hood ULn(In) of the identity In in Ln, such that L can be parameterized by
exponential coordinates of the second kind, cf. p.86, [Var84]. Let
L = L(r
2) · . . . · L1
= R(r
2)Q(r
2) · . . . · R1Q1.
(3.56)

3.3 Orthogonal Transformations
54
Here the Li are deﬁned as in (3.41). Each Li, for i = 1, . . . ,
¡r
2
¢
, is represented
as
Li = eli
(3.57)
with, e.g., using βrow as an ordering,
l1 =


0
· · ·
· · ·
0
...
...
...
0
...
...
p1
0
· · ·
0


, l2 =


0
· · ·
· · ·
· · ·
0
...
...
...
0
...
...
0
p2
0
· · ·
0


,
etc. . . .
(3.58)
We can therefore study the map
σ : Ln ⊃ULn(In) →SOn,
L 7→Q(r
2)(L) · . . . · Q1(L).
(3.59)
Note that
Qi(In) = In
for all
i = 1, . . . ,
µr
2
¶
holds true. The following series of lemmata characterizes the mapping σ.
Lemma 3.3. The mapping σ deﬁned by (3.59) is smooth.
Proof. See the explicit form of the Qi given as in (3.51).
Lemma 3.4. The mapping σ deﬁned by (3.59) is an immersion at In.
Proof. We have to show that the derivative
D σ(In) : ln →son
is injective.
For arbitrary l =
(r
2)
P
i=1
li ∈ln the following holds true
D σ(In) · l =
(r
2)
X
i=1
D Qi(In) · li
=
(r
2)
X
i=1
(li −l⊤
i )
= l −l⊤,
(3.60)

3.3 Orthogonal Transformations
55
where we have used
d
d ε(I + ε2p⊤p)−1
2
¯¯¯¯
ε=0
= 0
and
d
d ε(I + ε2pp⊤)−1
2
¯¯¯¯
ε=0
= 0.
Equation (3.60) implies injectivity in an obvious manner.
Now we can apply the Immersion Theorem, cf. [AMR88] p.199.
Lemma 3.5. The mapping σ as deﬁned by (3.59) is a diﬀeomorphism of
ULn(In) onto the image σ(ULn(In)).
□
Consider the isospectral manifold
MSOn := {X ∈Rn×n | X = QAQ⊤, Q ∈SOn}
(3.61)
with A as in (3.5) fulﬁlling Assumption 3.1. Deﬁne
α : σ(ULn(In)) →MSOn,
Q 7→QAQ⊤.
(3.62)
Lemma 3.6. The mapping α deﬁned as in (3.62) is smooth.
Proof. The result follows by the explicit construction of an arbitrary Q by
using exponential coordinates of the second kind.
Lemma 3.7. The mapping α deﬁned as in (3.62) is an immersion at In.
Proof. We have to show that the derivative
D α(In) : TInσ(ULn(In)) →TAMSOn
is injective. Arbitrary elements of the tangent space TInσ(ULn(In)) have the
form
(r
2)
X
i=1
(li −l⊤
i ) = l −l⊤,

3.3 Orthogonal Transformations
56
whereas those of the tangent space TAMSOn look like
[l −l⊤, A].
To show injectivity of
D α(In) : TInσ(ULn(In)) →TAMSOn,
l −l⊤7→[l −l⊤, A],
we partition l −l⊤accordingly to A, i.e.,
A =


A11
· · ·
Arr
...
...
Arr

,
l −l⊤=


0
−p⊤
21
· · ·
−p⊤
r1
p21
...
...
...
...
−p⊤
r,r−1
pr1
· · ·
pr,r−1
0


.
Note that
[l −l⊤, A]r1 = pr1A11 −Arrpr1.
Assume the converse, i.e.,
[l −l⊤, A] = [el −el⊤, A]
(3.63)
holds for some el ̸= l with
el :=


0
ep21
...
...
...
epr1
· · ·
epr,r−1
0


∈ln.
Looking at the (r1)-block of (3.63) implies
(pr1 −epr1)A11 −Arr(pr1 −epr1) = 0.
(3.64)
By Assumption 3.1 on the spectra of A11 and Arr, respectively, (3.64) implies
pr1 = epr1.

3.3 Orthogonal Transformations
57
Now by induction on the subdiagonals of blocks, i.e., going from the lower
left corner block of (3.63) to the ﬁrst subdiagonal of blocks, and continuing
to apply recursively the same arguments on the (r −1, 1)-block of (3.63), as
well as on the (r2)-block of (3.63), then imply
pr2 = epr2
and
pr−1,1 = epr−1,1.
Finally, we get
[l −l⊤, A] = [el −el⊤, A]
=⇒
l = l⊤,
a contradiction. Therefore, D α(In) is injective, hence α is an immersion at
In.
Consequently, we have
Lemma 3.8. The composition mapping α ◦σ : ULn(In) →MSOn is a diﬀeo-
morphism of ULn(In) onto the image (α ◦σ)(ULn(In)).
□
3.3.1
The Algorithm
The following algorithm will be analyzed. Given an X ∈(α ◦σ)(ULn(In))
and let A fulﬁl Assumption 3.1. For convenience we abbreviate in the sequel
M := (α ◦σ)(ULn(In)).
(3.65)
Consider the index set
I := {(ij)}i=2,...,r;j=1,...,r−1
(3.66)
and ﬁx an ordering β. For convenience we again rename double indices in
the description of the algorithm by simple ones by means of Xij 7→Xβ(ij)
respecting the ordering β.

3.3 Orthogonal Transformations
58
Algorithm 3.3 (Orthogonal Sylvester Sweep).
Given an X ∈(α ◦σ)(ULn(In)) = M. Deﬁne
X(1)
k
:= Q1XQ⊤
1
X(2)
k
:= Q2X(1)
k Q⊤
2
...
X(r
2)
k
:= Q(r
2)X(r
2)−1
k
Q⊤
(r
2)
where for l = 1, . . . ,
¡r
2
¢
the transformation matrix Ql ∈SOn diﬀers from
the identity matrix In only by 4 subblocks. Namely, the
jj −th block is equal to
(I + p⊤p)−1
2
ji −th block is equal to
−(I + p⊤p)−1
2p⊤
ij −th block is equal to
(I + pp⊤)−1
2p
ii −th block is equal to
(I + pp⊤)−1
2.
Here pl ∈Rnj×ni, β((ij)) = l, and pl solves the Sylvester equation
pl
³
X(l−1)
k
´
jj −
³
X(l−1)
k
´
ii pl +
³
X(l−1)
k
´
ij = 0.
The overall algorithm then consists of the iteration of orthogonal sweeps.
Algorithm 3.4 (Orthogonal Reﬁnement of Estimates of Sub-
spaces).
• Let X0, . . . , Xk ∈M be given for k ∈N0.
• Deﬁne the recursive sequence X(1)
k , . . . , X(r
2)
k
as above (sweep).
• Set Xk+1 := X(r
2)
k
. Proceed with the next sweep.

3.3 Orthogonal Transformations
59
3.3.2
Local Convergence Analysis
Analogously to Theorem 3.1 we have
Theorem 3.3. Algorithm 3.4
s : M →M
(3.67)
is a smooth mapping locally around A.
Proof. The algorithm is a composition of partial algorithmic steps ri. Smooth-
ness of these partial algorithmic steps follows from the smoothness of each
pi already shown.
Theorem 3.4. Algorithm 3.4 converges locally quadratically fast if for work-
ing oﬀthe partial algorithmic steps an ordering is chosen which respects
Corollary 3.1.
Proof. We will compute D rij(A) for all i > j with 2 ≤i ≤l and 1 ≤j ≤m−
1. Without loss of generality we may assume that the partitioning consists of
5 by 5 blocks. Typically, a transformation matrix Qij for rij(X) = QijXQ⊤
ij
looks like
Qij(X) =


I
0
0
0
0
0
Sij(X)
0
−Sij(X)p⊤
ij(X)
0
0
0
I
0
0
0
Tij(X)pij(X)
0
Tij(X)
0
0
0
0
0
I


,
(3.68)
where
Sij(X) = S⊤
ij(X) :=
³
I + p⊤(X)p(X)
´−1
2
and
Tij(X) = T ⊤
ij (X) :=
³
I + p(X)p⊤(X)
´−1
2.
Moreover,
Sij(A) = Ini

3.3 Orthogonal Transformations
60
and
Tij(A) = Inj.
An arbitrary
Ω∈son/(son1 ⊕. . . ⊕sonr)
looks like
Ω=


0
−Ω⊤
21
· · ·
−Ω⊤
r1
Ω21
...
...
...
...
−Ω⊤
r,r−1
Ωr1
· · ·
Ωr,r−1
0


.
The derivative of one partial algorithmic step acting on [Ω, A] ∈TAM is as
D rij(A) · [Ω, A] = [Q′
ij, A] + [Ω, A],
where
Q′
ij := D Qij(A) · [Ω, A],
and typically
Q′
ij =


0
0
0
0
0
0
S′
ij(A)
0
−(p⊤
ij)′(A)
0
0
0
0
0
0
0
p′
ij(A)
0
T ′
ij(A)
0
0
0
0
0
0


with
p′
ij(A) := D pij(X) · [Ω, X]|X=A.
We already know that pij solves a Sylvester equation, namely
pij(X)Xjj + Xij −Xiipij(X) = 0,
(3.69)
with
pij(X)|X=A = 0.
(3.70)

3.3 Orthogonal Transformations
61
Taking the derivative of the Sylvester equation (3.69) acting on [Ω, A] gives
p′
ij(A)Ajj + [Ω, A]ij −Aiip′
ij(A) = 0.
(3.71)
An easy computation veriﬁes that the commutator [Q′
ij, A] is of the following
form
[Q′
ij, A] =


0
∗
∗
∗
∗
0
∗
∗
∗
∗
0
∗
∗
∗
∗
0
p′
ijAjj −Aiip′
ij
∗
∗
∗
0
0
0
0
0


,
i.e., the (ij)-th block equals p′
ijAjj −Aiip′
ij and columns of blocks to the
left as well as rows of blocks below are zero. Therefore by (3.71), for the
derivative of the (ij)-th partial step rij we get
D rij(A) · [Ω, A] =


0
∗
∗
∗
∗
0
∗
∗
∗
∗
0
∗
∗
∗
∗
0
p′
ijAjj −Aiip′
ij
∗
∗
∗
0
0
0
0
0


|
{z
}
[Q′
ij,A]
+


∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
∗
[Ω, A]ij
∗
∗
∗
∗
∗
∗
∗
∗


|
{z
}
[Ω,A]
.
That is, by (3.71) the ﬁrst derivative annihilates the (ij)−th block, altering
eventually those blocks which are above, to the right, or a combination of
both, to this (ij)−th block, but it leaves invariant all the other remaining
blocks. Apparently, all ordering strategies respecting Corollary 3.1 ensure,
that after a whole iteration step all those blocks lying below the main diagonal
of blocks are eliminated. We therefore can conclude that
D rij(A) · [Ω, A] =


∗
∗
∗
∗
∗
0
∗
∗
∗
∗
0
0
∗
∗
∗
0
0
0
∗
∗
0
0
0
0
∗


.
(3.72)
Again we can even conclude more, namely
D rij(A) · [Ω, A] = 0.
(3.73)

3.3 Orthogonal Transformations
62
Following the argumentation in the proof of Lemma 3.2, essentially, As-
sumption 3.1 ensures that the only element of son/(son1 ⊕. . . ⊕sonr), which
commutes with A into a block upper triangular matrix, is the zero matrix.
This can also be seen from the fact that the above Ωequals an l −l⊤where
l ∈ln.
The result follows by the Taylor-type argument
∥Xk+1 −A∥≤sup
Z∈U
∥D2 s(Z)∥· ∥Xk −A∥2.
3.3.3
Discussion and Outlook
Consider a nearly upper triangular matrix over C with distinct eigenvalues.
Assume n = r, i.e., we have to solve
¡n
2
¢
scalar Sylvester equations per
sweep.
Our algorithm leads then to an extremely eﬃcient algorithm for
reﬁning estimates of eigenvectors. Each partial algorithmic step requires just
the solution of a scalar linear equation.
We would like to mention that the methods from this chapter can also be
applied to generalized eigenproblems in a completely straight forward way.
Instead of one Riccati or one Sylvester equation one has to solve a system of
two coupled ones. Everything works ﬁne under a reasonable assumption on
the spectra of subblocks.
It is a challenge to apply our methods also to more structured generalized
eigenvalue problems, say Hamiltonian ones.
If the matrix for which we would like to compute invariant subspaces is
symmetric, our method is related to [G¨ot95]. There, socalled approximate
Givens (or Jacobi) transformations are developed which essentially approx-
imate an exact rotation to zero out a matrix entry. Such an approach has
advantages if one is interested in VLSI-implementations.
Nevertheless, it is an open problem if our algorithm has a reinterpretation
as a Jacobi-type method in the general nonsymmetric case, i.e., if there is a
cost function which is minimized in each step.

Chapter 4
Rayleigh Quotient Iteration,
QR-Algorithm, and Some
Generalizations
A wellknown algorithm for computing a single eigenvector-eigenvalue pair of a
real symmetric matrix is the Rayleigh Quotient Iteration. It was initially used
to improve an approximate eigenvector, see [Par80] and references therein.
Local cubic convergence was ﬁrstly shown in a series of papers by Ostrowski,
cf. [Ost59].
The QR-algorithm for the symmetric eigenvalue problem is known to
be closely related to RQI, see e.g., p. 441 in [GvL89]. The QR-algorithm is
known to be one of the most eﬃcient algorithms. The reason for this is mainly
that one can exploit a banded structure of the matrices under consideration
and furthermore one is able to bring a given matrix in a ﬁnite number of steps
to such a banded form. Nevertheless, from our point of view the convergence
analysis of the QR-algorithm is far from being easy to understand. Moreover,
the fact that in the symmetric tridiagonal case QR using Rayleigh Quotient
shifts or socalled Wilkinson shifts converges locally cubically is somewhat
misleading because it is not the algorithm itself which is converging fast,
merely it is a submatrix or some entry which converges cubically in norm.
Essentially, deﬂating then is necessary to make the algorithm eﬃcient.
In this chapter we will start showing cubic convergence of the classi-
cal Rayleigh Quotient iteration by means of Calculus.
Then we will de-
velop a new algorithm which we call parallel RQI, because its relation to the
RQI is closer than the relation between QR-algorithm and RQI. Essentially,

4.1 Local Cubic Convergence of RQI
64
parallel RQI is an algorithm which is under some mild assumptions locally
well deﬁned, moreover, ulimately it converges in a way that all eigenvalue-
eigenvector pairs converge simultaneously cubically.
In the last section we take a closer look to the local convergence proper-
ties of the shifted QR-algorithm when applied to a real symmetric matrix.
We will show that there exists no smooth shift strategy which ensures that
the algorithm itself, considered as a selfmap on the orthogonal group On,
converges quadratically.
4.1
Local Cubic Convergence of RQI
Given a nonsingular A = A⊤∈Rn×n with distinct eigenvalues the iteration
xk+1 =
(A −x⊤
k AxkIn)−1xk
∥(A −x⊤
k AxkIn)−1xk∥
(4.1)
is known to be locally cubically convergent around each eigenvector of A,
cf. [Ost59, Par80]. Usually, one proves cubic convergence by using tricky
estimates. The diﬀerentiability properties of the map
x 7→
(A −x⊤AxIn)−1x
∥(A −x⊤AxIn)−1x∥
(4.2)
are not exploited for the proof. The main reason for this lack might be that
the map
˜f : Sn−1 →Sn−1
x 7→
(A −x⊤AxIn)−1x
∥(A −x⊤AxIn)−1x∥
(4.3)
has discontinuities at the ﬁxed points of the corresponding dynamical system,
namely at the normalized eigenvectors of A.
By a rather simple idea we remove this discontinuities by deﬁning another
iteration, which we call again Rayleigh Quotient Iteration. Consider the map
f : Sn−1 →Sn−1
x 7→
adj(A −x⊤AxIn)x
∥adj(A −x⊤AxIn)x∥.
(4.4)

4.1 Local Cubic Convergence of RQI
65
Iterating (4.4) obviously has roughly the same dynamics as iterating (4.3).
The diﬀerence is just in the sign of the determinant of (A −x⊤AxIn). The
big advantage of looking at (4.4) instead of (4.3) is that both have the same
ﬁxed points but (4.4) is smooth around the eigenvectors.
Theorem 4.1. Let A = A⊤be nonsingular having distinct eigenvalues. The
mapping f deﬁned by (4.4) is smooth around any eigenvector of A.
Proof. Without loss of generality we may assume that A is diagonal, i.e.,
A = diag(λ1, . . . , λn).
The denominator in (4.4), namely
∥adj(A −x⊤AxIn)x∥
is equal to zero, if and only if x lies in the kernel of adj(A −x⊤AxIn). If x
is an eigenvector, namely x = ei, with ei a standard basis vector of Rn, it
follows that x⊤Ax is the corresponding eigenvalue and therefore A−x⊤AxIn
is singular.
Nevertheless,
adj(A −λiIn) · ei =
Y
j̸=i
(λj −λi)ei
̸= 0
holds true. For x ̸= ei lying in a suﬃciently small neighborhood of ei the
“Rayleigh Quotient” x⊤Ax is never an eigenvalue. The result follows.
By the next result we show that RQI is cubically convergent. For this we
will use the diﬀerentiability properties of (4.4).
Theorem 4.2. Let A = A⊤be nonsingular having distinct eigenvalues. At
any eigenvector x ∈Sn−1 of A, the ﬁrst and second derivatives of f deﬁned
by (4.4) vanish.
Proof. Again without loss of generality we assume A to be diagonal. Deﬁne
F : Sn−1 →Sn−1
F(x) = adj(A −x⊤AxIn)x,
(4.5)

4.1 Local Cubic Convergence of RQI
66
and therefore
f(x) =
F(x)
∥F(x)∥.
(4.6)
Furthermore, deﬁne
G : Rn →Rn
G(x) = adj(A −x⊤AxIn)x,
(4.7)
and
g(x) =
G(x)
∥G(x)∥.
(4.8)
That is
F = G|Sn−1,
f = g|Sn−1.
Now for real α ̸= 0
D g(x)ξ|x=αei =
³
id −g(αei)g⊤(αei)
´D G(αei)ξ
∥G(αei)∥
(4.9)
where
g(αei) =
Q
j̸=i
(λj −λi)αei
∥Q
j̸=i
(λj −λi)αei∥
= ei sign(α
Y
j̸=i
(λj −λi)).
(4.10)
Therefore,
id −g(αei)g⊤(αei) = id −eie⊤
i .
(4.11)
Moreover,
D G(x)ξ|x=αei = D(adj(A −x⊤AxIn)x)ξ|x=αei
= adj(A −x⊤AxIn)ξ|x=αei + (D(adj(A −x⊤AxIn))ξ)x|x=αei.
(4.12)

4.1 Local Cubic Convergence of RQI
67
The ﬁrst summand on the right hand side of the last line of (4.12) gives
adj(A −x⊤AxIn)ξ|x=αei =
Y
j̸=i
(λj −λiα2)ξiei
= K1ei
(4.13)
with constant K1 ∈R.
The second summand of (4.12) is as
(D(adj(A −x⊤AxIn))ξ)x|x=αei = D


Q
j̸=1
(λj −x⊤Ax)
...
Q
j̸=n
(λj −x⊤Ax)

ξ
¯¯¯¯¯¯¯
x=αei
αei
= D
Y
j̸=i
(λj −x⊤Ax)ξ|x=αeiαei
= K2ei
(4.14)
with constant K2 ∈R. Hence,
D g(x)ξ|x=αei = id −eie⊤
i
∥G(αei)∥(K1 + K2)ei
= 0.
(4.15)
That is, we have the implication
D g(ei) = 0
=⇒
D f(ei) = 0.
(4.16)
Now we compute the second derivative. For h ∈Rn we have
D2 g(x)(h, h)|x=αei = D id −g(x)g⊤(x)
∥G(x)∥
h · D G(x) · h|x=αei+
+ id −g(x)g⊤(x)
∥G(x)∥
· D2 G(x) · (h, h)|x=αei.
(4.17)

4.1 Local Cubic Convergence of RQI
68
We claim that the ﬁrst summand in (4.17) is zero. By a tedious computation
one gets that
D id −g(x)g⊤(x)
∥G(x)∥
h|x=αei = const · (id −eie⊤
i ).
(4.18)
But we already know that
D G(ei) · h = const · ei,
(4.19)
therefore the claim is true.
The Hessian of f = g|Sn−1 at ei as a symmetric bilinear form on TeiSn−1×
TeiSn−1 can now be deﬁned as
D2 f(ei)(µ, µ) = id −eie⊤
i
∥F(ei)∥· D2 G(ei)(µ, µ).
(4.20)
It will turn out from the following calculation that
D2 f(ei)(µ, µ) = 0.
(4.21)
For this let us ﬁrst evaluate for h ∈Rn the second derivative of the extended
function G : Rn →Rn deﬁned by (4.7). A lengthy computation gives
D2 G(x)(h, h)|x=αei = 2(D adj(A −x⊤AxIn) · h) · h|x=αei+
+ D2 adj(A −x⊤AxIn)(h, h) · x|x=αei.
(4.22)
Note that the last summand in (4.22) lies in the kernel of id −eie⊤
i , therefore
D2 g(x)(h, h)|x=ei = 2id −eie⊤
i
∥G(ei)∥· (D adj(A −x⊤AxIn) · h) · h|x=ei
= −4e⊤
i hid −eie⊤
i
∥G(ei)∥
Y
j̸=i
(λj −λi)


P
k̸=1
1
λk−λi
...
P
k̸=n
1
λk−λi

·h.
(4.23)
For all µ ∈TeiSn−1 it holds
D2 g(ei)(µ, µ) = 0

4.2 Parallel Rayleigh Quotient Iteration or Matrix-valued Shifted
QR-Algorithms
69
because on the n-sphere e⊤
i µ = 0. The theorem is proved now.
Equation (4.23) is interesting for the following reasons. Firstly, it shows
cubic convergence for the RQI considered as a dynamical system on the
sphere. Secondly, for arbitrary vectors h ̸∈TeiSn−1 the second order deriva-
tive of g is not equal to zero.
As a consequence we can state that RQI considered as a dynamical system
on Rn is only quadratically convergent. An even more tedious calculation
shows that a third variant
xk+1 =
adj
³
A −
x⊤
k Axk
x⊤
k xk
´
xk
°°°adj
³
A −
x⊤
k Axk
x⊤
k xk
´
xk
°°°
(4.24)
is again cubically convergent. These subtleties may have consequences to
the numerical implementation. For RQI considered as an iteration on Rn
nonspherical second order perturbations near an equilibrium point may dis-
turb cubic convergence. Whereas for the iteration (4.24) they will not. All
these considerations may convince the programmer how important correct
normalization might be.
4.2
Parallel Rayleigh Quotient Iteration or
Matrix-valued Shifted QR-Algorithms
A quite natural question one may raise is, if one is able to formulate a QR-
type algorithm which is somehow the true generalization of RQI to a full
matrix. By this we mean an algorithm which ultimately does RQI on each
column individually and even simultaneously. The idea is as follows.

4.2 Parallel Rayleigh Quotient Iteration or Matrix-valued Shifted
QR-Algorithms
70
Algorithm 4.1 (Parallel Rayleigh Quotient Iteration on Stn,k).
Given a nonsingular A = A⊤∈Rn×n with distinct eigenvalues and an
X ∈Stn,k.
1. Solve for Z ∈Rn×k
AZ −Z Diag(X⊤AX) = X
where Diag(A) := diag(a11, . . . , ann) denotes the diagonal part of
A.
2. Set X = (Z)Q, where (Z)Q denotes the Q-factor from a QR-
decomposition of Z, with Q ∈Stn,k and go to 1.
Obviously, for k = 1 this iteration is RQI. For k = n one can interpret this
algorithm as a QR-type algorithm on the orthogonal group On performing
matrix valued shifts, i.e., each column of Z is diﬀerently shifted. For n >
k ≥1 this algorithm is closely related to the recent work, [AMSD02]. One
of the main diﬀerences between Algorithm 4.1 and the iteration presented in
[AMSD02] is that we just take the orthogonal projection on the diagonal, see
step 1. in Algorithm 4.1, whereas Absil et al. need a diagonalization instead.
Moreover, we are able to show that our iteration is well deﬁned even in the
case n = k.
Let us analyze the local convergence properties of parallel RQI. Firstly,
we want to get rid of the discontinuities at the ﬁxed points.
It is easily
seen that the ﬁxed points of the parallel RQI are those X ∈Stn,k where
X⊤AX is diagonal, or equivalently, those points X, the colunmns of which
are eigenvectors of A. We will use the same idea as for standard RQI, see
above.
Let X = [x1, . . . , xk], and Z = [z1, . . . , zk]. If the i−th diagonal entry of
X⊤AX is not equal to an eigenvalue of A, the shifted matrix A−(X ⊤AX)iiIn
is invertible and therefore
AZ −Z Diag(X⊤AX) = X
⇐⇒
zi = (A −(X⊤AX)iiIn)−1xi
(4.25)
for all i = 1, . . . , k. For our analysis we will therefore use for all i

4.2 Parallel Rayleigh Quotient Iteration or Matrix-valued Shifted
QR-Algorithms
71
zi = adj(A −(X⊤AX)iiIn)xi.
(4.26)
Scaling a column zi by the determinant det(A −(X⊤AX)iiIn) is not
necessary because this can be incorporated into the triangular factor R of
the QR-decomposition of Z in the second step of the algorithm.
As a consequence of the RQI analysis from the last section we have
Theorem 4.3. Parallel RQI considered as an iteration on the compact Stiefel
manifold Stn,k using (4.26)
1. is a well deﬁned iteration in an open neighborhood of any ﬁxed point
X,
2. is smooth around such an X,
3. converges locally cubically fast to such an X.
Proof. Without loss of generality we assume A = diag(λ1, . . . , λn). To see
that the algorithm is locally well deﬁned it is enough to prove that the matrix
Z has full rank at a ﬁxed point, but this is trivial because each ﬁxed point
itself is of full rank. Note that for any vector x ∈Rn being suﬃciently close
to an eigenvector ei of A the expression (adj(A −x⊤AxIn))x never equals
zero and therefore the second part of the theorem follows also. To prove the
third part we need to compute the derivative of
Z(X) = Q(Z(X)) · R(Z(X)).
(4.27)
Here
Z : Stn,k →Rn×k,
Q : Rn×k →Stn,k,
R : Rn×k →Uk,
(4.28)
where Uk denotes the Lie group of upper triangular (k × k)-matrices having
positive diagonal entries. The algorithm Parallel RQI can be described by
the map
X 7→Q(Z(X)).
(4.29)

4.2 Parallel Rayleigh Quotient Iteration or Matrix-valued Shifted
QR-Algorithms
72
To prove higher order convergence we therefore need to compute
D Q(Z(Xf)) : TXf Stn,k →TXf Stn,k
(4.30)
which can be done by taking the derivative of (4.27). Using the chain rule
and exploiting the fact that Z(Xf) = Q(Xf) = Xf and R(Xf) = Ik we get
D Z(Xf)ξ =
¡
D Q(Xf) · D Z(Xf) · ξ
¢
R(Xf) + Q(Xf)
¡
D R(Xf) · D Z(Xf) · ξ
¢
.
As a matter of fact
D Z(Xf) = 0
(4.31)
holds true because each “column” of D Z(Xf)·ξ is equal to zero being just the
derivative of an individual RQI on the corresponding column of X evaluated
at Xf. Hence
D Q(Z(Xf)) · D Z(Xf) = 0.
(4.32)
Consequently it makes perfectly sense also to deﬁne second derivatives. The
argumentation is the same and the details are therefore omitted. The result
follows.
4.2.1
Discussion
Each iteration step of parallel RQI requires a solution of a Sylvester equation.
Problems will occur if these solutions will not have full rank. As a conse-
quence the QR-decomposition in the second step of the algorithm would not
be unique. Even worse, the iteration itself would not be well deﬁned. The
following counterexample shows that the property of being well deﬁned does
not globally hold.
Example 4.1. Consider the tridiagonal symmetric matrix
A =


1
√
2
0
√
2
1
1
0
1
0

,
(4.33)
with eigenvalues λ1 = −1 and λ2,3 =
3
2 ±
q
5
4. If one starts the parallel
Rayleigh Quotient Iteration for k = 3 with the identity matrix I3 the columns
of the matrix Z are computed as

4.3 Local Convergence Properties of the Shifted QR-Algorithm 73
z1 = adj(A −a11I3)e1 =


−1
√
2
√
2

,
z2 = adj(A −a22I3)e2 =


√
2
0
0

,
z3 = adj(A −a33I3)e3 =


√
2
−1
−1

.
(4.34)
That is
Z =


−1
√
2
√
2
√
2
0
−1
√
2
0
−1

,
(4.35)
which clearly has only rank 2.
4.3
Local Convergence Properties of the Shifted
QR-Algorithm
We consider the QR-algorithm with any smooth shift strategy. Given A = A⊤
with distinct eigenvalues. Consider the following mapping on the orthogonal
similarity orbit of A
A 7→(A −µ(A)In)⊤
Q(A −µ(A)In)(A −µ(A)In)Q.
(4.36)
Iterating the mapping (4.36) is usually referred to as the shifted QR-algorithm
with shift strategy µ. Alternatevely, one might consider two closely related
versions of the shifted QR-algorithm living on On
X 7→
¡
(A −µ(X)In)X
¢
Q
(4.37)
and

4.3 Local Convergence Properties of the Shifted QR-Algorithm 74
X 7→
¡
(A −µ(X)In)−1X
¢
Q.
(4.38)
Rewrite (4.38) into
σ : X 7→
¡
adj(A −µ(X)In)X
¢
Q.
(4.39)
Without loss of generality we assume A = diag(λ1, . . . , λn). Assume further
that the dynamical system deﬁned by iterating (4.39) on On converges to
X = In. Then for ξ ∈TIOn ∼= son a tedious calculation shows that
D σ(In)ξ = D
³
adj(A −µ(X)I)X
´
Q · ξ
¯¯¯¯
X=In
=
³
D
³
(adj(A −µ(X)I)X
´
· ξ
´
skewsym.
¯¯¯¯
X=In
=





Q
i̸=1(λi −µ(In))
...
Q
i̸=n(λi −µ(In))

· ξ



skewsym.
,
(4.40)
where (Z)skewsym. denotes the skewsymmetric summand from the unique ad-
ditive decomposition of Z into skewsymmetric and upper triangular part.
Obviously, there cannot exist a smooth function µ : On →R, such that
D σ(In) = 0, because this would require that Q
i̸=j(λi −µ(In)) = 0 for all
j = 1, . . . , n, being clearly impossible. We therefore have proved
Theorem 4.4. There exists no smooth scalar shift strategy to ensure quadratic
convergence for the QR-algorithm.
□
This theorem indicates that either deﬂation or a matrix valued shift strat-
egy is necessary for the shifted QR-algorithm to be eﬃcient.

Bibliography
[AB77]
B.D.O. Anderson and R.R. Bitmead. The matrix Cauchy index:
Properties and applications. SIAM J. Appl. Math., 33:655–672,
1977.
[AL90]
H. Azad and J.J. Loeb. On a theorem of Kempf and Ness. Ind.
Univ. Math. J., 39(1):61–65, 1990.
[AMR88]
R. Abraham, J.E. Marsden, and T. Ratiu. Manifolds, Tensor
Analysis, and Applications. Springer, New York, second edition,
1988.
[AMSD02] P.-A. Absil, R. Mahony, R. Sepulchre, and P. Van Dooren. A
Grassmann–Rayleigh quotient iteration for computing invariant
subspaces. SIAM Review, 44(1):57–73, 2002.
[AO82]
T. Abatzoglou and B. O’Donnell. Minimization by coordinate
descent. J. of Optimization Theory and Applications, 36(2):163–
174, February 1982.
[Ati82]
M.F. Atiyah.
Convexity and commuting Hamiltonians.
Bull.
London Math. Soc., 14:1–15, 1982.
[Bat95]
S. Batterson. Dynamical analysis of numerical systems. Numer-
ical Linear Algebra with Applications, 2(3):297–309, 1995.
[BD82]
C.I. Byrnes and T.W. Duncan. On certain topological invariants
arising in system theory. In P.J. Hilton and G.S. Young, editor,
New Directions in Applied Mathematics, pages 29–72. Springer,
New York, 1982.

BIBLIOGRAPHY
76
[BGF91]
A. Bunse-Gerstner and H. Fassbender. On the generalized Schur
decomposition of a matrix pencil for parallel computation. SIAM
J. Sci. Stat. Comput., 12(4):911–939, 1991.
[BHH+87] J.C. Bezdek, R.J. Hathaway, R.E. Howard, C.A. Wilson, and
M.P. Windham. Local convergence analysis of a grouped variable
version of coordinate descent.
J. of Optimization Theory and
Applications, 1987.
[BL85]
R.P. Brent and F.T. Luk. The solution of singular value and
symmetric eigenvalue problems on multiprocessor arrays. SIAM
J. Sci. Stat. Comput., 6(1):69–84, 1985.
[Bro88]
R.W. Brockett. Dynamical systems that sort lists, diagonalize
matrices, and solve linear programming problems. In Proc. IEEE
of the 27th Conference on Decision and Control, pages 799–803,
Austin, TX, 12 1988. See also Lin. Algebra & Applic., 146:79-91,
1991.
[BS89a]
S. Batterson and J. Smillie. The dynamics of Rayleigh quotient
iteration. SIAM J. Num. Anal., 26(3):624–636, 1989.
[BS89b]
S. Batterson and J. Smillie. Rayleigh quotient iteration fails for
nonsymmetric matrices. Appl. Math. Lett., 2(1):19–20, 1989.
[BS90]
S. Batterson and J. Smillie. Rayleigh quotient iteration for non-
symmetric matrices.
Math. of Computation, 55(191):169–178,
1990.
[BSS93]
M.S. Bazaraa, H.D. Sherali, and C.M. Shetty. Nonlinear Pro-
gramming. John Wiley & Sons, New York, second edition, 1993.
[CD89]
J.-P. Charlier and P. Van Dooren. A Jacobi-like algorithm for
computing the generalized Schur form of a regular pencil. Journal
of Computational and Applied Mathematics, 27:17–36, 1989.
[CD90]
M.T. Chu and K.R. Driessel. The projected gradient method for
least squares matrix approximations with spectral constraints.
SIAM J. Num. Anal., 27(4):1050–1060, 1990.

BIBLIOGRAPHY
77
[Cha84]
F. Chatelin. Simultaneous Newton’s iteration for the eigenprob-
lem. Computing, Suppl., 5:67–74, 1984.
[Chu88]
M.T. Chu. On the continuous realization of iterative processes.
SIAM Review, 30:375–387, 1988.
[Chu91]
M.T. Chu. A continuous Jacobi-like approach to the simultaneous
reduction of real matrices. Lin. Algebra & Applic., 147:75–96,
1991.
[Chu96]
M.T. Chu. Continuous realization methods and their applica-
tions, March 1996. Notes prepared for lecture presentations given
at ANU, Canberra, Australia.
[Deh95]
J. Dehaene.
Continuous-time matrix algorithms systolic algo-
rithms and adaptive neural networks.
PhD thesis, Katholieke
Universiteit Leuven, October 1995.
[Dem87]
J. Demmel. Three methods for reﬁning estimates of invariant
subspaces. Computing, 38:43–57, 1987.
[DMW83]
J.J. Dongarra, C.B. Moler, and J.H. Wilkinson. Improving the
accuracy of computed eigenvalues and eigenvectors.
SIAM J.
Num. Anal., 20(1):23–45, 1983.
[DV92]
J. Demmel and K. Veseli´c.
Jacobi’s method is more accurate
than QR. SIAM J. Matrix Anal. Appl., 13:1204–1245, 1992.
[Ful97]
W. Fulton. Young Tableaux. LMS Student Texts 35. Cambridge
Univ. Press, 1997.
[Gib79]
C.G. Gibson.
Singular points of smooth mappings.
Pitman,
Boston, 1979.
[G¨ot94]
J. G¨otze. On the parallel implementation of Jacobi’s and Kog-
betliantz’s algorithms. SIAM J. Sci. Stat. Comput., 15(6):1331–
1348, 1994.
[G¨ot95]
J. G¨otze.
Orthogonale Matrixtransformationen, Parallele Al-
gorithmen,
Architekturen und Anwendungen.
Oldenbourg,
M¨unchen, 1995. in German.

BIBLIOGRAPHY
78
[GS82]
V. Guillemin and S. Sternberg. Convexity properties of the mo-
ment mapping. Inventiones Math., 67:491–513, 1982.
[GvL89]
G. Golub and C. F. van Loan. Matrix Computations. The Johns
Hopkins University Press, Baltimore, 2nd edition, 1989.
[Hac93]
D. Hacon. Jacobi’s method for skew-symmetric matrices. SIAM
J. Matrix Anal. Appl., 14(3):619–628, 1993.
[Hen58]
P. Henrici. On the speed of convergence of cyclic and quasicyclic
Jacobi methods for computing eigenvalues of Hermitian matrices.
J. Soc. Indust. Appl. Math., 6(2):144–162, 1958.
[HH95]
K. H¨uper and U. Helmke.
Geometrical methods for pole as-
signment algorithms. In Proc. IEEE of the 34th Conference on
Decision and Control, New Orleans, USA, 1995.
[HH97]
U. Helmke and K. H¨uper. The Jacobi method: A tool for compu-
tation and control. In C.I. Byrnes, B.N. Datta, C.F. Martin, and
D.S. Gilliam, editors, Systems and Control in the Twenty-First
Century, pages 205–228, Boston, 1997. Birkh¨auser.
[HH98]
K. H¨uper and U. Helmke.
Jacobi-type methods in computer
vision: A case study.
Z. Angew. Math. Mech., 78:S945–S948,
1998.
[HH00]
U. Helmke and K. H¨uper. A Jacobi-type method for computing
balanced realizations. Systems & Control Letters, 39:19–30, 2000.
[HHM96]
K. H¨uper, U. Helmke, and J.B. Moore. Structure and conver-
gence of conventional Jacobi-type methods minimizing the oﬀ-
norm function. In Proc. IEEE of the 35th Conference on Decision
and Control, pages 2124–2128, Kobe, Japan, 1996.
[HHM02]
U. Helmke, K. H¨uper, and J.B. Moore. Computation of signature
symmetric balanced realizations. Journal of Global Optimization,
2002.
[HM94]
U. Helmke and J.B. Moore. Optimization and Dynamical Sys-
tems. CCES. Springer, London, 1994.

BIBLIOGRAPHY
79
[H¨up96]
K. H¨uper. Structure and convergence of Jacobi-type methods for
matrix computations. PhD thesis, Technical University of Mu-
nich, June 1996.
[Jac46]
C.G.J. Jacobi.
¨Uber ein leichtes Verfahren, die in der Theo-
rie der S¨acularst¨orungen vorkommenden Gleichungen numerisch
aufzul¨osen. Crelle’s J. f¨ur die reine und angewandte Mathematik,
30:51–94, 1846.
[Kle00]
M. Kleinsteuber.
Das Jacobi-Verfahren auf kompakten Lie-
Algebren, 2000. Diplomarbeit, Universit¨at W¨urzburg.
[KN79]
G. Kempf and L. Ness. The length of vectors in representation
spaces. Lect. Notes in Math. 732, pages 233–243, 1979.
[LHPW87] A.J. Laub, M.T. Heath, C.C. Paige, and R.C. Ward. Computa-
tion of system balancing transformations and other applications
of simultaneous diagonalization algorithms. IEEE Transactions
on Automatic Control, 32(2):115–122, 1987.
[LT92]
Z.Q. Luo and P. Tseng. On the convergence of the coordinate
descent method for convex diﬀerentiable minimization. J. of Op-
timization Theory and Applications, 72(1):7–35, January 1992.
[Lue84]
D. G. Luenberger, editor. Linear and nonlinear programming.
Addison-Wesley, Reading, 2nd edition, 1984.
[Lut92]
A. Lutoborski. On the convergence of the Euler-Jacobi method.
Numer. Funct. Anal. and Optimiz., 13(1& 2):185–202, 1992.
[Mac95]
N. Mackey. Hamilton and Jacobi meet again: Quaternions and
the eigenvalue problem. SIAM J. Matrix Anal. Appl., 16(2):421–
435, 1995.
[Mah94]
R. Mahony.
Optimization algorithms on homogeneous spaces.
PhD thesis, Australian National University, Canberra, March
1994.
[Meh02]
C. Mehl. Jacobi-like algorithms for the indeﬁnite generalized Her-
mitian eigenvalue problem. Technical Report 738-02, Technische
Universit¨at Berlin, Institut f¨ur Mathematik, June 2002.

BIBLIOGRAPHY
80
[Nai90]
M.T. Nair. Computable error estimates for Newton‘s iterations
for reﬁning invariant subspaces. Indian J. Pure and Appl. Math.,
21(12):1049–1054, December 1990.
[Ost59]
A.M. Ostrowski. On the convergence of the Rayleigh quotient
iteration for the computation of characteristic roots and vectors.
Arch. rational Mech. Anal., 1-4:233–241,423–428,325–340,341–
347,472–481,153–165, 1958/59.
[Paa71]
M.H.C. Paardekooper.
An eigenvalue algorithm for skew-
symmetric matrices. Num. Math., 17:189–202, 1971.
[Par74]
B.N. Parlett.
The Rayleigh quotient iteration and some gen-
eralizations for nonnormal matrices.
Math. of Computation,
28(127):679–693, 1974.
[Par80]
B.N. Parlett. The symmetric eigenvalue problem. Prentice Hall,
1980.
[RH95]
N.H. Rhee and V. Hari.
On the cubic convergence of the
Paardekooper method. BIT, 35:116–132, 1995.
[Sam71]
A. Sameh. On Jacobi and Jacobi-like algorithms for a parallel
computer. Math. of Computation, 25:579–590, 1971.
[SC89]
M.G. Safonov and R.Y. Chiang. A Schur method for balanced-
truncation model reduction. IEEE Transactions on Automatic
Control, 34(7):729–733, 1989.
[SHS72]
H.R. Schwarz, H.Rutishauser, and E. Stiefel.
Numerik sym-
metrischer matrizen. B.G. Teubner, Stuttgart, 1972.
[Smi93]
S.T. Smith. Geometric optimization methods for adaptive ﬁlter-
ing. PhD thesis, Harvard University, Cambridge, May 1993.
[Ste73]
G.W. Stewart.
Error and perturbation bounds for subspaces
associated with certain eigenvalue problems.
SIAM Review,
15(4):727–764, October 1973.
[Ste86]
G.W. Stewart. A Jacobi-like algorithm for computing the Schur
decomposition of a nonhermitian matrix.
SIAM J. Sci. Stat.
Comput., 6(4):853–864, October 1986.

BIBLIOGRAPHY
81
[SV87]
M. Shub and A.T. Vasquez. Some linearly induced Morse-Smale
systems, the QR algorithm and the Toda lattice. Contemporary
Math., 64:181–194, 1987.
[Var84]
V.S. Varadarajan. Lie Groups Lie Algebras, and Their Repre-
sentations. Number 102 in GTM. Springer, New York, 1984.

