I
This book is currently out of print. Upon kind permission of the
M.I.T.-Press, it is available on
ftp.ens.fr/pub/dmi/users/longo/CategTypesStructures
All references should be made to the published book.
CATEGORIES
TYPES
AND STRUCTURES
An Introduction to Category Theory for the working computer scientist
Andrea Asperti
Giuseppe Longo
FOUNDATIONS  OF  COMPUTING  SERIES
M.I.T.  PRESS,  1991

II
INTRODUCTION
The main methodological connection between programming language theory and category theory is
the fact that both theories are essentially “theories of functions.” A crucial point, though, is that the
categorical notion of morphism generalizes the set-theoretical description of function in a very broad
sense, which provides a unified understanding of various aspects of the theory of programs. This is
one of the reasons for the increasing role of category theory in the semantic investigation of programs
if compared, say, to the set-theoretic approach. However, the influence of this mathematical
discipline on computer science goes beyond the methodological issue, as the categorical approach to
mathematical formalization seems to be suitable for focusing concerns in many different areas of
computer science, such as software engineering and artificial intelligence, as well as automata theory
and other theoretical aspects of computation.
This book is mostly inspired by this specific methodological connection and its applications to the
theory of programming languages. More precisely, as expressed by the subtitle, it aims at a self-
contained introduction to general category theory (part I) and at a categorical understanding of the
mathematical structures that constituted, in the last twenty or so years, the theoretical background of
relevant areas of language design (part II). The impact on functional programming, for example, of
the mathematical tools described in part II, is well known, as it ranges from the early dialects of Lisp,
to Edinburgh ML, to the current work in polymorphisms and modularity. Recent applications, such
as CAML, which will be described, use categorical formalization for the purposes of implementation.
In addition to its direct relevance to theoretical knowledge and current applications, category theory
is often used as an (implicit) mathematical jargon rather than for its explicit notions and results.
Indeed, category theory may prove useful in construction of a sound, unifying mathematical
environment, one of the purposes of theoretical investigation. As we have all probably experienced, it
is good to know in which “category” one is working, i.e., which are the acceptable morphisms and
constructions, and the language of categories may provide a powerful standardization of methods and
language. In other words, many different formalisms and structures may be proposed for what is
essentially the same concept; the categorical language and approach may simplify through abstraction,
display the generality of concepts, and help to formulate uniform definitions. This has been the case,
for example, in the early applications of category theory to algebraic geometry.
The first part of this book should encourage even the reader with no specific interest in
programming language theory to acquire at least some familiarity with the categorical way of looking
at formal descriptions.  The explicit use of deeper facts is a further step, which becomes easier with
access to this information. Part II and some chapters in part I are meant to take this further step, at

III
least in one of the possible directions, namely the mathematical semantics of data types and programs
as objects and morphisms of categories.
We were urged to write the general introduction contained in part I, since most available books in
category theory are written for the “working mathematician” and, as the subject is greatly indebted to
algebraic geometry and related disciplines, the examples and motivations can be understood only by
readers with some acquaintance with nontrivial facts in algebra or geometry. For most computer
scientists, it is not much help in the understanding of “natural transformations” to see an involved
example based on tensor products in categories of sheaves. Thus our examples will be based on
elementary mathematical notions, such as the definition of monoid, group, or topological space, say,
and on structures familiar for readers with some acquaintance with the tools in programming language
semantics. In particular, partial orders and the various categories of domains for denotational
semantics will often be mentioned or introduced, as well as basic results from computability theory.
For example, we will try to present the fundamental operation of “currying” for cartesian closed
categories with reference to the connection between the universal function and the g del- numbering
of the partial recursive functions. Partial morphisms will be presented as a generalization of a
common notion in theory of computation.
Category theory may be presented in a very abstract way: as a pure game of arrows and diagrams.
It is useful to reach the point where acquaintance with the formal (essentially, equational) approach is
so firm that it makes sense independently of any “structural” understanding. In this book, though, we
will stress the role of structures, and we will always try to give an independent meaning to abstract
notions and results. Each definition and fact will be exemplified, or even derived, from applications
or structures in some way indebted to computing. However, in order to stress the role of the purely
equational view, the last chapters of each part (essentially chapters 7 and 11) will be largely based on
a formal, computational approach. Indeed, even if mathematically very abstract, the equational
arguments turn out to be particularly relevant from a computer science perspective.
The early versions of this book grew out of two graduate courses taught by Longo in Pisa, in
1984/85, and at Carnegie Mellon University, in 1987/88. Then the book was entirely revised under
the influence of Asperti’s work for his Ph.D. dissertation. In particular, chapters 7 and 11, the
technically most difficult, are part of his dissertation.
We are indebted to several people. The joint work with Simone Martini and Eugenio Moggi in
several papers directly influenced many chapters. Moreover, Eugenio suggested, in handwritten notes
and electronic mail messages, the basic ideas for the categorical understanding of polymorphism via
internal categories and realizability toposes. Their mathematical insights and suggestions also
influenced other parts of the book.
We must acknowledge the influence on our approach of the ideas and work of Dana Scott and
Gordon Plotkin, who also encouraged us and made comments on early drafts. Pino Rosolini helped

IV
us with comments and many suggestions. Jean Yves Girard and Yves Lafont brought to our attention
the tidy categorical meaning of linear logic and its applications to computing. Roberto Amadio and
many students helped us by detecting errors and incompleteness in the presentation. We are looking
forward to aknowledge the readers who will detect the remaining errors.
The first draft of this book was completed while the authors were visiting Carnegie Mellon
University, in 1987/88. Longo would like to thank the Computer Science Dept. of CMU for its very
generous hospitality while he was teaching there that academic year. The circulation of the draft, its
complete revision, and the writing of the final version of the book have been made possible by the
Joint Collaboration Contract ST2J-0374-C (EDB) of the European Economic Community and by the
Italian CNR "Stanford-grant" #89.00002.26. The authors would like to thank INRIA, Rocquencourt,
for a postdoc granted to Asperti while completing this work and l’Ecole Normale Supérieure, Paris,
for inviting Longo to teach a graduate course in 1989/90 based partly on this book.

V
TABLE OF CONTENTS
PART I: Categories and Structures
CATEGORIES ......................................................................................
 
1
1.1 Category: Definition and Examples..................................................
 
1
1.2 Diagrams................................................................................
 
3
1.3 Categories out of Categories .........................................................
 
4
1.4  Monic, Epic, and Principal Morphisms ............................................
 
5
1.5  Subobjects .............................................................................
 
8
CONSTRUCTIONS..............................................................................
 
10
2.1 Initial and Terminal Objects ........................................................
 
10
2.2 Products and Coproducts...........................................................
 
12
2.3 Exponentials..........................................................................
 
15
2.4 Examples of CCC’s .................................................................
 
20
2.4.1 Scott Domains ............................................................
 
20
2.4.2 Coherent Domains........................................................
 
24
2.5 Equalizers and Pullbacks ...........................................................
 
27
2.6  Partial Morphisms and Complete Objects........................................
 
31
2.7 Subobject Classifiers and Topoi ...................................................
 
35
FUNCTORS AND NATURAL TRANSFORMATIONS ...................................
 
40
3.1 Functors ..............................................................................
 
40
3.2 Natural Transformations............................................................
 
45
3.3 Cartesian and Cartesian Closed Categories Revisited ...........................
 
51
3.4 More Examples of CCC’s ..........................................................
 
54
3.4.1 Partial Equivalence Relations ...........................................
 
54
3.4.2 Limit and Filter Spaces ..................................................
 
55
3.5 Yoneda's Lemma ....................................................................
 
58
3.6 Presheaves............................................................................
 
60
CATEGORIES DERIVED FROM FUNCTORS AND
NATURAL TRANSFORMATIONS...........................................................
 
63
4.1 Algebras Derived from Functors...................................................
 
63

VI
4.2 From monoids to monads ..........................................................
 
67
4.3 Monoidal and monoidal closed categories ........................................
 
72
4.4 Monoidal Categories and Linear Logic............................................
 
79
UNIVERSAL ARROWS AND ADJUNCTIONS ............................................
 
88
5.1 Universal arrows ....................................................................
 
89
5.2 From Universal Arrows toward Adjunctions ....................................
 
93
5.3 Adjunctions...........................................................................
 
97
5.4 Adjunctions and Monads ..........................................................
 
104
5.5 More on Linear Logic ..............................................................
 
110
CONES AND LIMITS ..........................................................................
 
120
6.1 Limits and Colimits.................................................................
 
120
6.2 Some Constructions Revisited ....................................................
 
123
6.3 Existence of limits ..................................................................
 
125
6.4 Preservation and Creation of Limits..............................................
 
127
6.5 ω-limits ..............................................................................
 
130
INDEXED AND INTERNAL CATEGORIES...............................................
 
132
7.1 Indexed Categories .................................................................
 
132
7.2 Internal Category Theory ..........................................................
 
136
7.3 Internal Presheaves.................................................................
 
143
7.4 Externalization ......................................................................
 
150
7.5 Internalization .......................................................................
 
156
Appendix .................................................................................
 
158
PART II: Types as Objects
FORMULAE, TYPES, AND OBJECTS .....................................................
 
166
8.1 λ-Notation...........................................................................
 
167
8.2 The Typed λ-Calculus with Explicit Pairs (λβηπt) ............................
 
168
8.3 The Intuitionistic Calculus of Sequents ..........................................
 
171
8.4 The Cut-Elimination Theorem.....................................................
 
176
8.5 Categorical Semantics of Derivations ............................................
 
185
8.6 The Cut-Elimination Theorem Revisited.........................................
 
187
8.7 Categorical Semantics of the Simply Typed Lambda Calculus................
 
191
8.8 Fixpoint Operators and CCCs.....................................................
 
197

VII
REFLEXIVE OBJECTS AND
THE TYPE-FREE LAMBDA CALCULUS..................................................
 
204
9.1 Combinatory Logic.................................................................
 
206
9.2 From Categories to Functionally Complete Applicative Structures...........
 
208
9.3 Categorical Semantics of the λ-Calculus.........................................
 
214
9.4 The Categorical Abstract Machine ................................................
 
217
9.5 From Applicative Structures to Categories ......................................
 
220
9.6 Typed and Applicative Structures: Applications and Examples ...............
 
225
Part 1: Provable isomorphisms of types .....................................
 
226
Part 2: Higher type objects as models of the type-free l-calculus .........
 
234
RECURSIVE DOMAIN EQUATIONS.......................................................
 
241
10.1 The Problem of Contravariant Functors........................................
 
242
10.2 0-Categories .......................................................................
 
245
SECOND ORDER LAMBDA CALCULUS..................................................
 
251
11.1 Syntax ..............................................................................
 
252
11.2 The External Model ...............................................................
 
254
11.3 The External Interpretation.......................................................
 
257
11.4 The Internal Model................................................................
 
258
11.5 The Internal Interpretation........................................................
 
261
11.6 Relating Models ...................................................................
 
263
EXAMPLES OF INTERNAL MODELS .....................................................
 
272
12.1 Provable Retractions..............................................................
 
272
12.2 PER inside ω-Set..................................................................
 
275
12.3 PL-Categories Inside Their Groethendiek Completion .......................
 
277
BIBLIOGRAPHY ...............................................................................
 
283

1. Categories
1
Chapter 1
CATEGORIES
Category Theory studies “objects” and “morphisms” between them. These concepts are both
primitive in Category Theory: objects are not collections of “elements,” and morphisms do not need
to be functions between sets (thus morphisms cannot be applied to “elements” but only composed
with other morphisms). Any immediate access to the internal structure of objects is prevented: all
properties of objects must be specified by properties of morphisms (existence of particular
morphisms, their unicity, validity of some equations among them, and so on). This is quite similar to
considering objects as “abstract data types,” that is, data specifications that are independent of any
particular implementation. The relevance of Category Theory for programming languages comes
from the previous consideration: it offers a highly formalized language especially suited for stating
abstract properties of structures. Thus, it relates to widely used programming methodologies and
provides as well a formal setting for the mathematical investigation of the semantics of programming
languages.
1.1 Category: Definition and Examples
As we have mentioned, Category Theory is a theory of functions, and the only basic operation is
composition. The concept of Category embodies some abstract properties of the composition
operator “˚” for functions that “reasonably” must be guaranteed. In particular, if  g: a→b  and  h:
b→c, then there exist  h ˚ g: a→c; moreover, composition must be associative and an identity must
exist for all objects.
This is the formal definition:
1.1.1 Definition   A  category  C is
- a collection ObC of objects, denoted by a, b . . . A, B . . .
- a collection MorC of morphisms (arrows), denoted by f, g . . . ,
- two operations dom, cod assigning to each arrow f two objects respectively called domain
(source) and codomain (target) of f
- an operation id assigning to each object b a morphism idb (the identity of b) such that
dom(idb) = cod(idb) = b
- an operation “ ˚ ” (composition) assigning to each pair f, g of arrows with dom(f) = cod(g) an
arrow f ˚ g such that  dom( f ˚ g ) = dom(g), cod( f ˚ g ) = cod(f)
- identity and composition, moreover, must satisfy the following conditions:

1. Categories
2
   identity law: for any arrows f, g such that  cod(f) = b = dom(g)
idb ˚ f = f
g ˚ idb = g
   associative law: for any arrows f, g, h such that dom(f) = cod(g) and dom(g) = cod(h)
( f ˚ g ) ˚ h = f ˚ ( g ˚ h )
We write  f: a → b  to denote a morphism whose source and target are respectively  a  and  b. Given
two objects  a  and  b, the collection of all morphisms f such that  f: a → b  is denoted by C[a,b]; the
writing  f∈C[a,b]  is thus a third way to express the fact that  dom(f) = a, and cod(f) = b. For the
moment we shall use one notation or the other indifferently
The following table lists some common categories by specifying their objects and arrows, letting
the definition of their operators as an exercise for the reader:
Category
Objects
Morphisms
Set
sets
functions
Top
topological spaces
continuous functions
Vect
vector spaces
linear transformations
Grp
groups
group homomorphisms
PO
partially ordered sets
monotone functions
The intuition of the notion of “category” suggested by the previous examples is to consider the
objects as a collection of “structured” sets and the morphisms as the “associated” or “acceptable”
functions with respect to the structure. This is too restrictive, though, since no requirement is made in
the definition which may force the morphisms to be “single valued” or to be functions in extenso: a
simple example is the category  Rel with sets as objects and relations as morphisms.
The simplest category has only one object and one arrow (the identity for that object): this
category is usually called 1. Note that, by definition, if C is a category, then every object  b  of C
has an identity  idb: b→b.  The identity is unique, since if  idb'  is  another identity for  b, then for
the identity law,  idb' = idb ° idb' = idb .  A category is called discrete if every arrow is the identity
of some object: in this case a category is fully determined by the collection of its objects. 1 is a
discrete category.
A category is called a preorder if for every pair of objects  a, b  there is at most  one morphism
f: a→b. The reason for the name is that a preorder category is fully determined by a preordering
relation among its objects. Indeed, in a preorder C, there is only one way that composition may be
defined; thus C is known when the collection of morphisms MorC and the operations dom and cod
are known. But every arrow  f: a→b may be identified with the pair (a,b), since once the source and

1. Categories
3
target are known there is no choice about what the arrow is to be; thus, all the information about the
category C is given by the relation  RC = {(a,b) / there is an arrow f∈C[a,b]}, that is, by a preorder
relation.(Exercise: prove that the relation RC is a preorder for every category C ).
Every discrete category is a preorder. The simplest nondiscrete category which is a preorder is
the category 2, which has two objects, let us call them 0 and 1, and three arrows: the two identities
id0, id1 and an arrow (0,1): 0→1. In a similar way we can define for each natural number n a
preorder category n, from the usual ordering on the set {0,1, . . . n-1}. Preorder categories have a
common property: they may have plenty of objects, but given two objects, there exists at most one
morphism between them.
A dual situation is given by monoids, viewed as categories. A monoid is a set having an
associative binary operation and an identity element. A category with just one object yields a monoid,
where composition of morphisms is the binary operation. Conversely, any monoid  (A, . ) is a
category with just one object. For example, the category with the set of natural numbers as unique
object and the recursive functions as morphisms yields the monoid of the recursive functions.
As well as preorders, another example where objects are not necessarily understood as
“structured sets” is given by deductive systems as categories. In these categories propositions are
objects and each morphism  f : a→b  corresponds to (a suitable equivalence class of) a proof of  a |−
b  (a entails b). Observe that a category is obtained easily in the presence of the identical entailment
ia : a→a  and the associative composition of proofs
f : a→b      g : b→c
________________
g ° f : a→c
This approach to deduction is very relevant in the categorical understanding of logics of a
constructive nature, such as Intuitionistic Logic, where the intended interpretation of proofs is given
by (effective) operations. It will be the main paradigm for understanding the relation between types
and objects investigated in the second part of this book.
1.2 Diagrams
An important tool in the practice of Category Theory is the use of diagrams for representing
equations. In a diagram a morphism f∈C[a,b] is drawn as an arrow from a to b labeled f. A diagram
commutes if the composition of the morphism along any path between two fixed objects is equal.
For example, the associative and identity laws of the definition of “category” may be nicely visualized
by the following commuting diagrams:

1. Categories
4
Diagrams are a typical way, in Category Theory, to describe equational reasoning and turn out to
be particularly effective when dealing with several equations at a time. In particular, assertions such
as “if diagram1  and . . . diagramn commute, then diagram  commutes” express conditional
statements about equalities.
We hope that the reader, while using this book, will acquire some familiarity with diagrams and
will learn how to go back and forth from diagrams to equations.  Our extended use of equations in
this book comes from our desire to stress the “computational” nature of most categorical reasoning.
1.3 Categories out of Categories
A main feature of Category Theory is the facility to define new, more structured categories out of
simpler ones. In this section we consider only a few simple constructions; a number of other
examples occur throughout the book.
1.3.1 Definition  A category D is a subcategory of a category C, if
1. ObD ⊆ ObC;
2. for all  a, b  in ObD,  D[a,b] ⊆ C[a,b];
3. composition and identities in D coincide with those of C.
A subcategory is full if for all  a, b  in ObD  D[a,b] = C[a,b].
A full subcategory is fully determined by its collection of objects.
1.3.2 Definition The dual category Cop of a category C has the same objects and the same
morphisms of C, idopb = idb, domop(f) = cod(f), codop(f) = dom(f), and  f °op g = g ° f.
Note that Cop[b,a] = C[a,b] and (Cop)op = C.
Exercise  Setop is a subcategory of Rel, but not of Set. Is it a full subcategory?
Duality is a very powerful technique of Category Theory. If  P  is a generic proposition expressed
in the language of Category Theory, the dual of P (Pop) is the statement obtained by replacing the

1. Categories
5
word “dom” by “cod,” “cod” by “dom,” “g ° h”  by  “h ° g.” If  P is true in a category  C, then  Pop
is true in Cop; if P is true in every category, then also Pop is, since every category is the dual of its
dual.
Duality may be applied to diagrams as well: given a diagram in a category C, the dual diagram in
Cop is obtained by simply reverting the arrows; of course, a dual diagram commutes if and only if
the original one does.
1.3.3 Definition  Given two Categories C and D, the product category C××××D has for objects
the pairs (a,b) where a and b are respectively objects of C and D, and for morphisms pairs (f,g):
(a,b)→(a',b')  where f: a→a' and g: b→b' are respectively morphisms of C and D. Finally, id(a,b)
= (ida,idb)  and  (f,g) ° (f',g') = (f ° f', g ° g').
1.3.4 Definition  Given a category C and an object  a  in ObC, the category C↓a of objects
over  a  is so defined:  ObC↓a = {f∈MorC / cod(f) = a}; given two objects  f: b→a, g: c→a, a
morphism with source  f  and target  g  is an arrow  h∈C[b, c] such that  g ° h  = f. Identities and
composition in C↓a are inherited from C.
In case C is Set in the above definition, it is useful to think of an object  g: B→A  in  Set↓A  as an
A-indexed family of disjoint sets, namely,  {g-1(a)}a∈A  (these sets are the inverse images of
elements in A under g). Then  h: B→B'  is a morphism from  g: B→A  to  g': B'→A   if and only if
it is consistent with the “decomposition” of B and C induced by  g  and  g',  i.e., if and only if (iff)
∀b  b∈g-1(a)  ⇒  h(b)∈g'-1(a).
Since the intended meaning behind the construction of a category  C↓I  is that to consider an
object g: A→I as a collection {{i}×g-1(i)}i∈I, it is usual to call C↓I a slice category over I
(denoted C/I). An object   g: A→I  of the slice category is then called a generalized object of C at
stage I. A section of  g: A→I  is a function  s: I→A  such that  g ° s = idI;  the idea is that  s  gives,
for each index  i∈I, an element s(i)∈g-1(i).
Exercise Define the dual notion, that is, the category  C↑a  of objectsunder  a,  whose objects are
the arrows with source  a.
1.4  Monic, Epic, and Principal Morphisms
A function  f  between two sets  A  and  B  is called “injective” when, for all  a , a' ∈ A , if f(a) =
f(a') then  a = a'. In particular, given any two functions  g, h : C→Α, if for all c∈C  f(g(c)) =
f(h(c)), then for all c∈C  g(c) = h(c) or, also, if  f ° g = f ° h  then  g = h . Thus, every injective
function behaves like a left identity (it is left cancellable). The converse is also true:  given f: A→Β, if

1. Categories
6
for any pair of functions  g, h : C→Α , f ° g = f ° h  implies  g = h , then  f  is injective. For suppose
otherwise: then there are  a  and  a'  such that  f(a) = f(a')  but  a ≠ a' ; define then  g  and  h  by  g(c)
= a  for all  c∈C , and h(c) = a' for all  c∈C; of course  f ° g = f ° h  but  g ≠ h , that is, a
contradiction.
We have proved thus that a function  f  is injective if and only if  f ° g = f ° h  implies  g = h . In a
similar way it is not difficult to prove that  f  is surjective if and only if  g ° f = h ° f  implies  g = h.
These considerations motivate the following definitions.
1.4.1 Definition. Let C be a category and a, b∈ObC. Then
i. an arrow h∈C[a,b] is epic (is an epimorphism) iff
g ˚ h = f ˚ h  ⇒  g = f ;
ii. an arrow h∈C[a,b] is monic (is a monomorphism) iff
h ˚ g = h ˚ f  ⇒  g = f ;
iii. an arrow h∈C[a,b] is iso (is an isomorphism) iff there exists g∈C[b,a] such that
g ˚ h = id  and  h ˚ g = id .
Two objects  a  and  b  are isomorphic (a ≅ b) if there exists an isomorphism  h∈C[a,b]. Clearly,
any isomorphism is monic and epic; the converse, though, does not need to be true (see the example
and the exercises below).
A monic (or epic) h∈C[a,b] (or h'∈C[a,b]) is split if there exist  g∈C[b,a] (or  g'∈C[b,a])
such that  g ˚ h = id (h' ˚ g' = id).
Although the intuition of regarding mono- and epimorphisms as injective and surjective maps is
correct for many interesting categories, sometimes it can be misleading. Consider, say, the category
Mon of monoids and the inclusion inc from ω, the positive integers, into z, the relative ones. Clearly
mono, inc is also epi, though.  As a matter of fact, take g,h∈Mon[z,a] for some monoid a, and write
\g(n)  for g(-n).  Then  g ˚ inc = h ˚ inc  implies  g = h  for  g(-n) = \g(n) =\h(n) = h(-n)  (that is, the
behavior of the monoids’ homomorphism  g  or  h  on  z  is entirely determined by their behavior on
ω). As a side consequence, we may also conclude that not every arrow that is both monic and epic is
an isomorphism: this is clearly in contrast to the set-theoretic intuition.
Exercises
1. Give an epi which is not surjective in Top.
2. Find a counterexample for the following assertion: let C be a category; if f∈C[a,b] and g∈C[b,a]
are mono, then  a  is isomorphic to  b.  (Note that the assertion is true in Set.)
3. Prove that a split monic is an iso.
1.4.2 Definition  Let C be a category and a, b∈ObC. Then
i. an arrow h∈C[a,b] is a principal morphism iff

1. Categories
7
∀f∈C[a,b] ∃g∈C[a,a]  f = h˚ g ;
ii. a pair of arrows f∈C[a,b] and g∈C[b,a] is a retraction pair iff g ˚ f=id. Then,  a  is called a
retract of  b  (a<b) via the retraction pair (f,g).
By diagrams,  h  is principal iff for all  f  there is a  g  such that
Principal morphisms have been inspired by recursion theory; the idea they are based on essentially
corresponds to a classical notion of reducibility (see the category EN in section 2.2 below).
1.4.3 Proposition  Let C be a category and a, b∈ObC. Then
1. if a<b via (i,h), then h is epi and principal, i is mono;
2. if h∈C[a,b] is principal and there exists an epi k∈C[a,b,], then h is epi;
3. if a<b and f∈C[b,a] is principal, then there exists g∈C[a,b] such that a<b via (g,f).
Proof 1. g˚h = f˚h  ⇒  g˚h˚i = f˚h˚i  ⇒  g = f,  for  h˚i = id.
The proof that  h  is principal is a simple diagram chase:
That is, ∀f ∃g f = h˚g. Just take g = i˚f; then  h˚g = h˚i˚f = f.
Finally,  i˚g = i˚f  ⇒  h˚i˚g = h˚i˚f  ⇒  g = f.
2. g˚h = f˚h  ⇒  g˚k = g˚h˚g' = f˚h˚g' = f˚k  (for a suitable  g')  ⇒  g = f .
3. Let a<b via (j,i). Since  f  is principal,  ∃s∈C[b,b]  j = f°s.  Then, for  g = s°i, one has  f°g = j°i =
ida. As a diagram,
♦

1. Categories
8
Exercises
1. Characterize retractions in terms of split monos and epis.
2. Show that, given a category C, one can define a category CRet whose objects are the same of C
and whose morphisms are retraction pairs in C, that is  F∈CRet[a,b] iff F=(f,g) and a<b via (f,g) in
C.
If  (f:a→b, g:b→a)  is a retraction pair, then the function  h = f ° g: b→b  is idempotent, that is,  h ° h
= h .  Indeed,  h ° h = (f ° g) ° (f ° g) = f ° (g ° f) ° g = f ° g = h .  This property suggests the following
definition:
1.4.4 Definition  Given a category C and an object  b∈ObC, the category of idempotents on
b (Retb) is so defined: 
ObRetb = { f∈C[b,b] /  f ° f = f }
MorRetb = { (f, k, g) /  f, g∈ObRetb, k∈C[b,b], k = g ° k ° f }
dom( (f, k, g) ) = f, cod( (f, k, g) ) = g
idf = (f, f, f)
(f, k, g) ° (g', k', f) = (g', k ° k', g)
We leave as an exercise for the reader to check the identity and associative laws for the previous
category.  Retb will be used in several places because of its relevance to this book.
1.5  Subobjects
The concept of subobject  is the categorical version of the set-theoretical subset . The main idea is to
regard a subset  A  of a given object  B  as a monomorphism  f: D→B  (intuitively, a monomorphism
f  such that  “f(D) = A”). Of course, many different monic arrows may define the same subset; thus,
it is necessary to introduce a reasonable equivalence relation, and define subobjects up to this
equivalence.
Let  C be a category.  If  f: b→a  and  g: c→a  are two monic arrows with common target a, then
we say  f ≤ g  if and only if there exists  h: b→c  such that  g ° h = f. Note that in this case, the unique
h  must be monic too, indeed  h ° k = h ° k'  ⇒  g ° h  ° k = g ° h  ° k'  ⇒  f ° k = f ° k'  ⇒  k = k'.
Exercise Prove that the preorder ≤ is the full subcategory of C↓a determined by monomorphisms
only.

1. Categories
9
When f ≤ g  and  g ≤ f  we write  f ≅ g.  Then  ≅  is an equivalence relation among the
monomorphisms with common target  a  (prove it as an exercise); the equivalence classes of this
equivalence relation are called subobjects of a.
1.5.1 Definition  Let  a  be an object of a category C.  A subobject  [f]  of  a  is an equivalence
class of a monomorphism  f: b→a, with respect to the equivalence relation  ≅  defined above.
Very often, we shall make no distinction between equivalence classes and their representatives, and
we shall denote  a subobject with a single monomorphism.
It should be clear that the categorical approach to “subsets” carries more information than the set-
theoretic one. Monomorphisms, like all morphisms, preserve the structural information of the
category.  For example, in the category Grp of groups subobjects are subgroups: (mono)morphisms
must take the identity to the identity and preserve the group operation. Similarly consider the category
of p.o.sets (partially ordered sets) with a bottom element.  A subobject of one such p.o.set must be a
structured subset as well, and it must contain an element smaller than all the others.
References: Any book in Category Theory, such as MacLane (1971) Herrlich and Strecker
(1973), Arbib and Manes (1975), Barr and Wells (1985), Rydeheard and Burstall (1988). The
specific notions and categories introduced (such as retractions) will be used later in more structured
settings, with the appropriate references.

2. Constructions
10
Chapter 2
CONSTRUCTIONS
In this chapter we consider some fundamental categorical constructions, i. e., particular objects (and
morphisms) that satisfy a given set of axioms described in the language of Category Theory. Since in
this language there is no way to look at the internal membership structure of objects, all the concepts
must be defined by their relations with other objects, and these relations are established by the
existence and the equality of particular morphisms. This property of the categorical language, if
compared to the traditional set-theoretic jargon, may be well understood by an analogy with computer
science; namely, as we already mentioned, the categorical description corresponds to an abstract data
specification, while the traditional set-theoretic approach is more similar to a concrete implementation.
2.1 Initial and Terminal Objects
2.1.1 Definition  Let C be a category. An object  0  is initial iff for any b∈ObC there is a unique
f∈C[0,b].
The typical example of an initial object is the empty set ∅ in Set; indeed the empty function (i.e., the
function whose graph is empty) is the unique arrow with ∅ for source.
A more interesting example is the following. Let ΣΣΣΣ be a signature. The class AlgΣΣΣΣ of ΣΣΣΣ-algebras
with ΣΣΣΣ-homomorphisms as arrows forms a category. AlgΣΣΣΣ has an initial object TΣΣΣΣ    which is called ΣΣΣΣ-
word-algebras, or also Herbrand Universe for ΣΣΣΣ. The set  TΣΣΣΣ,s (the carrier of TΣΣΣΣ of sort s) is just the
set of all well-formed expressions of sort s. If ΣΣΣΣ is derived by a context free grammar (that is: sorts
are nonterminals and operator symbols are productions of the grammar), then TΣΣΣΣ,s is the set of all
parse trees for derivations in the grammar from the nonterminal s. In general the initial ΣΣΣΣ-algebra  TΣΣΣΣ
corresponds to the syntax of a language of signature ΣΣΣΣ. Any other ΣΣΣΣ-algebras A in AlgΣΣΣΣ is a possible
semantic domain; the semantic function (interpretation) is the unique homomorphism from  TΣΣΣΣ    to A.
Initiality is the simplest universal notion in Category Theory, since it is given by the existence and
unicity of morphisms satisfying certain properties. This method is used everywhere in Category
Theory.
2.1.2 Proposition  If  0  and  0'  are two initial objects in a category C, then they are isomorphic.

2. Constructions
11
Proof.  Let  i: 0→0', j: 0'→0  the morphisms respectively given by the initiality of  0  and 0'. Then
j ° i:  0→0, but also  id0: 0→0, and since by initiality of  0, there is exactly one morphism in C[0,0],
then  j ° i = id0; in the same way, by initiality of  0' we have  i ° j = id0'.♦
We will now show how duality  can be used to define new concepts and to prove new assertions.
Let P(c) be the property “for any b∈ObC there is a unique f, such that  dom(f) = c, cod(f) = b.” By
definition c is initial iff P(c) holds; that is, P defines initiality. The dual statement of P is Pop(c) =
“for any b∈ObC there is a unique f, such that  cod(f) = c, dom(f) = b.” Usually the dual Qop of a
property Q defines a concept named by prefixing “co-” to the name of the property Q. In our case, we
say that Pop defines coinitiality. An object c such that Pop(c) holds, is called co-initial. Anyway it
is common practice to assign to every coentity an independent name which better expresses its
properties; for example, a coinitial object is known as terminal object. Note that an initial object is
coterminal.
Terminal objects are usually represented with the number 1 or with the letter t. The unique
morphism from an object a to the terminal object t  is usually written !a: a→t.
Any singleton set is terminal in Set. In the category 2 one object is initial and the other one is
terminal. If c is initial in C, then it is terminal in the dual category Cop.
Consider now the statement P1 = “If  0  and  0'  are two initial objects, then they are isomorphic.”
Its dual is: P1op = “If  0  and  0'  are two terminal objects, then they are isomorphic.” (the property
to be an isomorphism is the dual of itself: prove it as an exercise.) By our discussion of duality in
chapter 1 and, since by proposition 2.1.2 P1 holds in every category, P1op also does. We conclude
the following:
2.1.3 Proposition  If  0  and  0'  are two terminal objects in a category C, then they are
isomorphic.
Proof  By duality and by proposition 2.1.2.♦
An object  c  in a category C may be both initial and terminal. An example is the unit group in Grp;
in this case, it is called a zero object.
In Set, a morphism from the singleton  {*} to a set A defines an element of A. For this reason an
arrow from a terminal object  t  to an object  a  in a generic category C is usually called an element
or a point of a. In this case, however, the set-theoretic intuition must be used very carefully, because
it is quite common to work in categories where the categorical notion does not reflect the behavior of
elements in Set.  For example the set-theoretic intuition would suggest that every non-initial object
must have at least one element: but consider the partial order category  3  which has three object  0 ≤
1 ≤ 2; clearly  0  is initial and  2  is terminal,  1  is non-initial but has no elements.  Similarly, in Set
two arrows are equal iff they coincide on all points, or, more formally, given functions  f  and  g,

2. Constructions
12
one has  f ≠ g  iff there is an element  x  of their domain such that  f ° x ≠ g ° x.  However, in a
generic category C with terminal object  t, this is not necessarily true.
2.1.4 Definition.  Let C be a category.  t∈ObC  is a generator iff for all  a,b∈ObC  and all
f,g∈C[a,b],  one has:  f ≠ g  ⇒  ∃h∈C[t,a]  f°h ≠ g°h .
C has enough points (or is well pointed), if there exists a generator  t  that is terminal in the
given category.
In short, a category has enough points when the arrows from the terminal object allow to discriminate
between morphisms, similarly as for elements over Set.  Of course, it is not a surprise that the set-
theoretic notions of “element” and of “extensionality” are somewhat awkward to deal with in the
language of Category Theory.
2.2 Products and Coproducts
The categorical product is merely a “structural” generalization of the notion of Cartesian product of
sets. Given two sets A and B, their cartesian product is:
A×B = {<x,y> / x∈A, y∈B}
Associated with this set there are two special maps  pA: A×B→A , pB: A×B→B  called projections,
such that  for every  <x,y>  in A×B  pA(<x,y>) = x, pB(<x,y>) = y. Note that for every  c  in A×B,
<pA(c), pB(c)> = c.
Let  C  be another set, and f: C→A, g: C→B. Define  <f,g>: C→A×B  by  <f,g>(c) = <f(c),g(c)>
for every c∈C. Then, for every  c∈C,  pA( <f,g>(c) ) = pA( <f(c),g(c)> ) = f(c), that is,  pA ° <f,g>
= f. In the same way, we obtain  pB ° <f,g> = g. Conversely, let  h: C→A×B. Then for every  c∈C,
<pA ° h, pB ° h >(c) = <pA(h(c)), pB(h(c))> = h(c), that is, <pA ° h, pB ° h > = h.
The previous consideration suggests the following definition:
2.2.1 Definition  Let C be a category, and  a,b∈ObC. The categorical product of  a  and  b  is
an object  a×b  together with two morphisms  pa: a×b→a, pb: a×b→b, and for every object c an
operation  < , >c : C[c,a]×C[c,b]→C[c,a×b] such that for all morphisms  f: c→a, g: c→b, h:
c→a×b, the following equations hold:
ia.  pa ° <f,g>c = f ;
ib.  pb ° <f,g>c = g ;
ii.   <pa ° h, pb ° h >c = h .
It is common practice to omit the subscript  c in  < , >c  when its meaning is clear from the context.

2. Constructions
13
The operation  < , > : C[c,a]×C[c,b]→C[c,a×b] of a categorical product is a bijection: its inverse
is the operation that takes every arrow  h∈C[c,a×b]  to the pair  (pa ° h, pb ° h )∈C[c,a]×C[c,b]. 
The proof that these operations are inverse of each other is stated above in definition 2.2.1.
Conversely, given a bijective operation  < , > : C[c,a]×C[c,b]→C[c,a×b]  which satisfies (ia) and
(ib), then (ii) is necessarily true. Indeed, let  h∈C[c,a×b]. Then, since < , >  is bijective, there is a
pair (f,g)∈C[c,a]×C[c,b] such that  h = <f,g>; but  f = pa ° <f,g> = pa ° h and analogously, g = pb °
<f,g> = pb ° h; thus,  h = <pa ° h, pb ° h >.
The last consideration leads us to a more compact but equivalent definition of a categorical
product.
2.2.2 Definition  Let C be a category, and  a,b∈ObC. The categorical product of  a  and  b  is
an object  a×b  together with two morphisms  pa: a×b→a , pb: a×b→b, such that, for any  f∈C[c,a]
and  g∈C[c,b], there exists exactly one  h∈C[c,a×b]  such that the following diagram commutes
2.2.3 Definition For  f∈C[a,c]  and  g∈C[b,d], set  f×g = <f˚pa,g˚pb> : a×b→ c×d.
Exercise Prove that for all arrows  h: e→a  and  k: e→b,  f×g˚<h,k> = <f˚h,g˚k>.
2.2.4 Proposition  In a category, the product is unique (up to isomorphisms), if it exists.
Proof  Let  a⊗b  be an alternative product with projections  qa  and  qb.
Then  <qa,qb> ˚ <pa,pb>  is the unique morphism such that the following diagram commutes:

2. Constructions
14
Since  ida×b  also does the same job,  ida×b = <pa,pb>˚<qa,qb>.
By symmetry, one also has  <pa,pb> ˚ <qa,qb> = ida⊗b .♦
Exercise. Prove the following facts:
1.  a ≅ a'  and  b ≅ b'  imply  a×b ≅ a'×b'.
2.  a×b ≅ b×a.
2.2.5 Definition  A category  C  is  Cartesian (C is a CC)  iff
i.  it contains a terminal object t;
ii. every pair  a,b∈ObC  has a categorical product  (a×b, pa,b,1: a×b→a, pa,b,2: a×b→b)
Exercises
1. Generalize the definition of a product of two objects to arbitrary products.
2. Prove that a Cartesian category C always contains all finite products.
3. Let C be a CC and let  t  be its terminal object. Prove that for all  b  in  ObC, b ≅ t×b ≅ b×t .
Examples  The categories Set, Top, Grp are all Cartesian.
An interesting Cartesian category in Computability Theory is the category EN of numbered sets.
Objects in EN are pairs a = (a,ea), where  a  is a countable set and  ea: ω→a  is an onto map (an
enumeration  of a).  f∈EN[a,b]  iff  for some total recursive  f'  the following diagram commutes:
We say that  f' represents f. The product is easily obtained by using any effective pairing of ω2,
[,]: ω×ω→ω.
A typical numbered set which is worth studying is PR = (PR,φ), the partial recursive functions
with a Goedel numbering φ: ω→PR. Then EN[PR,PR] are exactly the type two recursive
functionals. Of course, this is also a countable set. It is not trivial, though, to construct an
“acceptable” enumeration of it. This will be an important issue in the sequel.
Exercises
1. Let ω = (ω,id) in EN. Then f∈EN[ω,PR] iff ∃f'∈PR f'([x,y]) = f(x)(y). Moreover, g∈
EN[ω,PR] is principal iff  g  is an acceptable Goedel numbering of PR, in the sense of classical
recursion theory.

2. Constructions
15
2. Let C be a CC, and V be an object such that  V×V<V. Then the category of retractions on V (see
definition 1.4.4 ) is a CC.
The dual of the notion of a product is the coproduct  a+b  with embeddings  q1, q2.
2.2.6 Definition.  Let C be a category, and  a,b∈ObC. The coproduct of  a  and  b  is an object
a+b  together with two morphisms  qa: a→a+b, qb: b→a+b  such that, for any  f∈C[a,c]  and
g∈C[b,c], there exists exactly one  h∈C[a+b,c]  such that the following diagram commutes
       
By duality, the coproduct is unique (up to isomorphisms).
Examples
1. In Set the coproduct is the disjoint union.
2. In a preorder P the product is the greatest lower bound, if it exists. The coproduct is the least
upper bound, if it exists.
3. Let CPO be the category of complete partial orders with continuous functions with respect to the
order or Scott topology. CPOS is the subcategory with only strict functions, i.e., morphisms always
take the least element  ⊥  to the least element of the target space.  It is easy to see that both categories
are Cartesian. The coproduct in CPOS is given by the coalesced sum, i.e., the disjoint union except
for the identification of the two least elements. On the other hand, there is no coproduct in CPO.
This may be seen by observing that in CPO one may have  f( ⊥ ) ≠ g( ⊥ ), by which the coalesced
sum fails to give a coproduct; an extra common least element (disjoint sum) may give more than one
extension of the required  <f,g>op.
2.3 Exponentials
In the connection we mentioned between Category Theory and Computation Theory, as “theories of
functions,” a fundamental aspect still has to be taken care of. In either case, we may be interested in
computing with procedures as arguments. That is, we may need to describe higher type functions.
So far we have only become familiar with Cartesian categories, where the object a×b, representing
the product, is defined. Thus, the notion of morphism taking morphisms as arguments doesn't yet
make sense. What we first need, then, is a further closure property, namely, the existence within the

2. Constructions
16
category of an object  ba  which suitably represents the set of morphisms from b to a.  With an
informal reference to typing in programming, the key property of the objects, which represent the
sets of morphisms, provides an interpretation to a common construct in actual programming, namely,
the identification of types such as A×B→C and A→(B→C). This corresponds to the following
important uniformity property of programs of several arguments, which is directly inherited from
classical Recursion Theory.
Let  {φi}i∈ω = PR  be an acceptable Gödel numbering of the partial recursive functions and  [,]:
ω×ω→ω be an effective pairing. Define then, as usual,  f: ω×ω→ω  is a binary partial recursive
function  iff   ∃f'∈PR  f(x,y) = f'([x,y])  (similarly, for  n-ary functions,  n ≥ 2). By this and by the
s-m-n iteration theorem one immediately has f: ω×ω→ω is partial recursive iff ∃s∈R φs(x)(y) =
f(x,y).
Thus, a two-(or more) argument function  f  is computable iff it is computable in each argument
and the function  x |_ f(x,_)  is also “computable,” i.e., ∃s∈R  φs(x) = f(x,_). In other words, in
computability theory,  f  is in  ω×ω→ω  iff  x |_ f(x,_)  is in ω→(ω→ω). Similarly, the category-
theoretic closure property we need concerns the existence, for any  f: c×a→b, of a morphism within
the category, which does the same job as  s  or  x |_ f(x,_)  in recursion theory. We will call it  Λ(f).
Exercise  For n ≥ 2, not every n-ary function which is computable in each argument needs to be
computable. (Hint: take  g  total nonrecursive and set  f(x,y) = g(min{x,y}) ).
2.3.1 Definition  Let C be a Cartesian category, and  a,b∈ObC. The exponent of  a  and  b  is
an object  ba  together with a morphism evala,b: ba×a→b (evaluation map), and for every object c an
operation  Λc : C[c×a,b]→C[c,ba] such that for all morphisms  f: c×a→b,  h: c→ba, the following
equations hold:
β).   evala,b ° (Λ(f)×ida) = f ;
η) .  Λc(evala,b ° (h×ida)) = h .
(We may omit the indices when unambiguous, as usual.)
In  Set  the exponent set of  A  and  B  is  BA = {f / f is a function from  A  to  B}, thus  BA =
Set[A,B].  The function  eval: BA×A→B  is given by the rule:  eval(<f,x>) = f(x) .
Λ: Set[C×A,B]→Set[C,BA]  takes every function  f: C×A→B  to the function  Λ(f): C→BA
defined by  Λ(f)(c) = λa.f(c,a), where  λa.f(c,a)∈ΒΑ=Set[A,B] is the function which takes a∈A to
f(c,a)∈B. The proof of (β) and (η) is almost immediate.
As in the case of the product, observe that in general the operation  Λ: C[c×a,b]→C[c,ba] in
definition 2.3.1 is a bijection. Indeed, by (β) and (η), Λ-1 is the operation which takes every
h∈C[c,ba]  to  evala,b ° (h×ida)∈C[c×a,b].

2. Constructions
17
Conversely, if Λ : C[c×a,b]→C[c,ba]  is a bijection and (β) holds, then (η) is necessarily true.
Indeed,  let h∈C[c,ba] and take f∈C[c×a,b] such that  h = Λ(f); then  Λ(evala,b ° (h×ida)) =
Λ(evala,b ° (Λ(f)×ida)) = Λ(f) = h .
The following is thus an equivalent definition of “exponent”:
2.3.2 Definition  Let C be a Cartesian category and  a,b∈ObC. The exponent of  a  and  b  is an
object  ba  together with a morphism  evala,b: ba×a→b, such that for all morphisms  f: c×a→b, there
exists one and only one  h: c→ba  such that the following diagram commutes:
Exercise By setting Λ(f) = h, give the details of the equivalence proof between the two definitions.
The previous diagram should suggest in which sense ba “represents” C[a,b]. The eval morphism
generalizes the set-theoretic evaluation function  eval(f,x) = f(x). Moreover, take  c = t, the terminal
object.  Then C[t,ba] ≅ C[t×a,b] ≅ C[a,b] as sets.  This is particularly significant if C has enough
points (why?).
2.3.3 Definition.  C is a Cartesian closed category (CCC)  iff
1. C is cartesian,
2. for every pair a,b∈ObC, there is an exponent.
Set is a CCC: the previous definition of exponents in Set clearly holds for every pair of sets.
Another simple CCC is CPO, the category of complete partial orders and continuous maps. As well-
known, given c.p.o.’s  a  and  b, CPO[a,b] is also a c.p.o., with respect to the pointwise ordering.
Moreover, both  eval  and  Λ(f), defined as for Set by using continuous functions, are continuous
and satisfy the required conditions.  Note that the proof uses the well-known fact that in CPO a
function is continuous iff it is so in each argument and the map  x |_ λy.f(x,y)  is continuous.
Actually, even  Λ  is continuous.
Among the various examples of categories mentioned in these notes, an important one does not
satisfy Cartesian closedness: the category EN in section.2.2. Consider, say, ω = (ω,id). Then
EN[ω,ω] (= R, the recursive functions) is surely countable. However, if a numbered set (ωω,ϕ) and

2. Constructions
18
a morphism  eval with the above properties existed, then  u(x,y) = eval(ϕ(x),y)  would be a universal
function for R.
Also, the ω-algebraic c.p.o.’s, that is, the c.p.o.’s with a countable collection of compact elements
approximating all the others (see Scott domains below) and continuous maps as morphisms do not
form a CCC. They contain, though, some fundamental subCCC's for the purposes of denotational
semantics of programming languages and higher type Recursion Theory. They will be explored in the
examples below.
Given a CCC D, it may be interesting to consider specific "structures of types" in it.  That is, for a
collection  A  of objects in D, let DA be the full sub CCC generated by A in D, i.e., the least full
sub category such that  A⊆DA  and  a,b∈DA  ⇒  a×b,ab∈DA.
Exercise  Prove that in any CCC one has  ab×c ≅ (ab)c.
In definition 1.4.2, we introduced the notion of “retract”: in a category C,  a<b  via the retraction
(i,j)  iff  j ˚ i = ida.  In these assumptions,  i  turns out to be mono and  j  epic.  Thus, a retract  a  of
b  is a subobject of  b  in the sense of section 1.5. In the case of Set, nonempty subsets and retracts
happen to coincide, as surjections from a set to a subset are always possible. In more structured
categories this reinforcement of the idea of subset, given by retractions, turns out to be very
informative. In particular, we will discuss categories with nontrivial objects  a  such that  aa<a.  This
is clearly impossible in Set because, by Cantor’s theorem, the cardinality of the exponent  aa , when
a  is not a singleton, is strictly bigger than the cardinality of a. In short, we will put together retracts
and exponents, in a nontrivial way, in order to discuss one of the early relevant applications of
categorical notions to computer science, namely the invention of mathematical (categorical, to be
precise) models of type-free languages. In these languages, programs are viewed as data or,
semantically, exponents may be retracted into (source and target) objects. It is convenient to prove, in
general, some basic properties of exponents and retractions for their relevance and simplicity as well
as for some preliminary training on equational reasononing, which will turn out to be useful to the
reader in the sequel.
2.3.4 Proposition  Let C be a CCC. If a<a' (via  ina: a→a', outa: a'→a), and b<b' (via  inb:
b→b', outb: b'→b), then ba<b'a', via Λ(inb°eval°(id×outa)): ba→b'a', Λ(outb°eval°(id×ina)):
b'a'→ba.
Proof.
Λ(outb°eval°(id×ina)) °°°° Λ(inb°eval°(id×outa)) =
= Λ(outb°eval°(id×ina)°Λ(inb°eval°(id×outa))×id )
= Λ(outb°eval°Λ(inb°eval°(id×outa))×id°(id×ina) )
= Λ(outb°(inb°eval° id×outa )°(id×ina) )
= Λ(eval ° id×(outa°ina) )

2. Constructions
19
= Λ(eval ° id×id)
= id. ♦
2.3.5 Definition  Let C be a CCC. An object  V  of C is  reflexive iff  VV<V.
Before we get to see some reflexive objects in relevant CCC's in the following sections, it is worth
proving two simple, but general, properties of reflexive objects (see chap.8 for applications).
2.3.6 Proposition  Let C be a CCC,  and  V  a reflexive object.  Then  t < V  and  V×V < V .
Proof. Let  (in: VV→V, out: V→VV)  the retraction pair between VV and V. In order to prove that
t<V we must only prove the existence of a morphism from t to V (why?). Let then  p1: t×V→V  be
the projection;  Λ(p1): t→VV, and thus  in ° Λ(p1): t→V.
The proof that  V×V<V is much more complex; we prove that V×V<VV; then  V×V<V follows by
composition.
Let  app = eval°(out×idV): V×V→V, and let αa,b,c be the isomorphism  αa,b,c: (b×c)×a→
(a×b)×c. Then:
app ° (app×id) ° αV,V,V : (V×V)×V→V
and
in1 =  Λ( app ° (app×id) ° α ) : (V×V)→VV.
By proposition 2.3.4 one has (VV)V<VV via
in2  = Λ( in ° eval ° (id×id) ) :  (VV)V→VV
out2  = Λ( out ° eval ° (id×id) ) :  VV→(VV)V.
Let  p2: t×V→V and  pr1:V×V→V, pr2: V×V→V  be the projections respectively associated with the
products  t×V  and  V×V. Then, for i =1,2,  Λ(pri): V→VV and, thus, for Λ(Λ(pri ) ° p2 ) :
t→(VV)V, pi = in ° in2 ° Λ(Λ(pri ) ° p2) : t→V.
Define, then,  out1 = < eval ° <id, p1 ° !VV> , eval ° <id, p2 ° !VV> > : VV→V×V.
We must prove that   out1 ° in1 = idV×V , or equivalently that  for  i = 1,2,  pri ° out1 ° in1 =
pri .
       pri ° out1 ° in1
= eval ° <id, pi ° !VV> ° in1
= eval ° < Λ( app ° (app×id) ° α ), pi ° !V×V>
= app ° (app×id) ° α ° < idV×V, pi ° !V×V>
= app ° < app ° < pi ° !V×V, pr1> , pr2>
= app ° < eval°(out×idV) ° < in°in2°Λ( Λ(pri ) ° p2 ) ° !V×V, pr1>, pr2>
= app ° < eval°<in2°Λ( Λ(pri ) ° p2 ) ° !V×V, pr1>, pr2>
= app ° < eval°< Λ(in°eval°(id×id))°Λ( Λ(pri ) ° p2 ) ° !V×V, pr1>, pr2>
= app ° < eval°< Λ(in°eval°(Λ( Λ(pri ) ° p2 )×id))° !V×V, pr1>, pr2>
= app ° < eval°< Λ(in ° Λ(pri ) ° p2 )° !V×V, pr1>, pr2>
= app ° < in ° Λ(pri ) ° pr1, pr2>
= eval°(out×idV) ° (in ° Λ(pri ))×idV

2. Constructions
20
= eval° (Λ(pri )×idV)
= pri . ♦
Exercises For the following exercises, assume that  C is a CCC.
1. Let V be a reflexive object of C. Prove that the collection RetV of all retracts of V in C is a CCC.
2. (Difficult, see section 8.8)  Let  b  be an object of C. A fixpoint operator for  b  is a morphism
Fixb: bb→b  such that  Fixb = evalb,b° <id,Fixb>. Let  VV<V via  (in,out). Let also
F = eval ° <id, in> : VV→V ;
H = Λ( eval ° (id×(F°out)) ) :  VV→VV.
Prove that  F°H  is a fixpoint operator for V. Define a fixpoint operator for all objects in RetV.
3. Let C be a CCC and suppose that for all a, b in ObC there exists the coproduct  a+b (with
embedding  ina: a→a+b , inb: b→a+b ). Prove that, for all  c  in ObC, (a×c)+(b×c)  is isomorphic to
(a+b)×c, and define explicitly the isomorphism.
Result:  (a×c)+(b×c)  ≅  (a+b)×c  via
i1 = (ina×idc)+(ina×idc):  (a×c)+(b×c) → (a+b)×c
i2 = Λ-1( Λ(ina×c)+Λ(inb×c) ):  (a+b)×c → (a×c)+(b×c)
Proving  i2°i1=id  is easy. For i1°i2 = id, note first that  g°Λ-1(f) = Λ-1(Λ(g°eval)°f).
Then, in a few steps, one obtains
           i1°i2 = Λ-1( Λ(ina×idc)+Λ(inb×idc) )
= Λ-1( Λ(id)°ina+Λ(id)°inb )
= Λ-1( Λ(id) )
= id
2.4 Examples of CCC’s
2.4.1 Scott Domains
In this section and in the following one we introduced two fundamental examples of CCC's, namely,
Scott domains and coherent domains. We define only the exponent object and the  eval  function and
check that they are respectively an object and an arrow of the category.  We leave the problem of
defining the isomorphism  Λ  and checking  (βcat)  and  (ηcat) as an (easy) exercise for the reader.
2.4.1.1 Definition Let  (X,≤)  be a partiallly ordered set (po-set).
D ⊆ X is directed iff it is nonempty and, for any  i,j∈D, there is  k∈D  such that  i ≤ k, j ≤ k. A
p.o.set  (X,≤)  is complete (is a CPO) iff every directed subset  D⊆X  has a least upper bound ∪D
(the least element  ⊥  is the least upper bound of the empty directed set).

2. Constructions
21
A point  x∈X  is compact (finite) if for every directed D such that  x ≤ ∪D , there is an element
y∈D such that x ≤ y.  Let  X0  denote the collection of compact elements of  X.
The c.p.o. (X, ≤) is algebraic if for every  x∈X  the set  x↓ = {x0∈X0 | x0 ≤ x}is directed and
∪(x↓) = x.
A c.p.o. (X,≤) is bounded complete if every bounded subset of X has a least upper bound. A
Scott Domain is a bounded complete algebraic c.p.o..
Exercises
1. Check that  {{y | x0 ≤ y} | x0∈X0} is a basis for a T0 topology on a Scott Domain. This topology
is usually called Scott topology.
2. Prove that the least upper bound of a finite set of finite elements is always finite, if it exists.
3. (Nontrivial) Find counterexamples for the following assertions:
i.  if  x0  is compact then the set  {y | y ≤ x0}  is finite;
ii. if  x0  is compact and  y ≤ x0  then  y  is compact.
2.4.1.2 Definition  Let  (X,≤X), (Y, ≤Y)  be c.p.o.’s.  A function  f: X→Y is monotonic  if it
is order preserving, i.e.,  i ≤X j  implies  f(i) ≤Y f(j) . (We will often omit the subscript X in ≤X.)
A function f: X→Y is continuous if for every directed D⊆X, f(∪D) = ∪d∈Df(d).
Exercise  Let  (X,≤X), (Y, ≤Y)  be Scott domains. Prove that a function  f: X→Y  is continuous
according to the previous definition iff it is continuos with respect to the Scott topology.
2.4.1.3 Definition The category D has Scott domains for objects and continuous functions for
morphisms. Let  X, Y  be objects of D. YX  is just the collection of the continuous functions from
X  to  Y  ordered pointwise.
Of course  YX  is a c.p.o..  We have to prove that it is bounded complete and algebraic.
In order to show that  YX  is bounded complete, assume that  {fi}i∈Ι  has an upper bound  g.
Define then  h  by  h(x) = ∪ i∈Ι{fi(x)}. The function  h  is well defined since the set  {fi(x)}i∈I  is
bounded by  g(x)  and, thus, it has a least upper bound in Y. Moreover, h  is continuous because for
every directed set  D  in  X  one has:
       h(∪D) = ∪ i∈Ι{fi(∪D)}
= ∪ i∈Ι ∪ x∈D {fi(x)}
by the continuity of fi
= ∪ x∈D ∪ i∈Ι {fi(x)}
= ∪ x∈D {h(x)}
It easy to check that  h  is a least upper bound for  {fi}i∈Ι.
To show that  YX  is algebraic, we explicitly define the set  (YX)0  of its compact elements.

2. Constructions
22
2.4.1.4 Definition  A step funcion from X to Y is a function  step-a,b  where a∈X0, b∈Y0,
defined by:  step-a,b (x)  = if a ≤ x then b else  ⊥ .
We claim that the compact element of  YX  are exactly the least upper bound of finite bounded sets of
step functions. In other words, for every  f0∈(YX)0,  (*)  f0 = ∪i∈Ι{step-ai,bi}  for some finite I.
Let us prove first that every function f = ∪i∈Ι{step-ai,bi} is compact, when I is finite and
∪i∈Ι{step-ai,bi} exists, i.e., when for all subset J of I, aJ = ∪i∈J{ai} exists  ⇒  bJ = ∪i∈J{bi}
exists  (We then say that  I  is a compatible set of indices.)
Then, let {gh}h∈D  be a directed family in  YX  such that  f ≤ ∪h∈D{gh}. In particular, for every
J  in  Ι  as above, f(aJ) = bJ ≤ (∪h∈D{gh})(aJ) = ∪h∈D {gh(aJ)}. Clearly, for each  J, bJ is
compact and {gh(aJ)}h∈D is directed. Let then  bJ ≤ gh(J)(aJ)  for some  h(J)∈D. Since  I  is finite
and  {gh}h∈D  is directed, let  gk ,  for  k∈D , be such that  gk ≥ gh(J)  for all  J  in  I. Clearly  f ≤
gk  and we are done.
Prove now for exercise that for every continuous function  f: X→Y, one has
i.  the set  F = { ∪i∈Ι{step-ai,bi}|  I finite, and  bi ≤ f(ai) }  is directed
ii. f = ∪F
Suppose then that  f  is compact. We need to prove that  f = ∪i∈Ι{step-ai,bi}  for some finite
compatible  I. By the exercise, f = ∪F, for F directed; thus, there exists  I  such that ∪i∈Ι{step-
ai,bi}∈F and ∪i∈Ι{step-ai,bi} ≥ f = ∪F ≥ ∪i∈Ι{step-ai,bi}. In conclusion f = ∪i∈Ι{step-ai,bi};
that is, every finite element in  XY has the form (*) and, in particular,  XY is a Scott domain.
The function  evalX,Y:  YX×X→Y  is defined by  evalX,Y(f,x) = f(x). The proof that  eval  is
continuous is straightforward.
Interesting examples of Scott Domains may be found everywhere in the literature of denotational
semantics. Indeed, the Cartesian closedness of the category allows you to construct plenty of them as
products and exponents over commonly used ground types.  That is, consider your preferred types
of data (integers, booleans, strings,etc.). Organize them as flat p.o.sets, i.e., add a least element  ⊥
and set  x ≤ x'  iff  x = ⊥  or  x = x'.  These are clearly objects of D as well as their products and
exponents.
Other relevant examples are given, for example, by the p.o.sets  P  of the partial maps from ω to
ω, the natural numbers, and Pω, the powerset of ω. The partial order, in these cases, is given by set
inclusion, which on  P  means graph inclusion of functions, i.e.,  f ≤ g  iff  ∀n  (f(n)↓  ⇒  g(n) =
f(n)). As an exercise, the reader may check that both  P  and  Pω  live in D.
Interestingly enough, these two familar structures are also reflexive objects in D .  We sketch the
proof of this for  Pω , see section 9.6-2 for more on  P.

2. Constructions
23
Let  {en}n∈ω  be a canonical (bijective and effective) enumeration of the finite subsets of ω and let
< , > : ω×ω→ω  be a canonical coding of pairs. Define then  graph: D[Pω,Pω]→Pω  by  graph(f) =
{<n,m> | m∈f(en)}  and  fun: Pω→D[Pω,Pω]  by  fun(a)(b) = {m | ∃en ⊆ b  <n,m>∈a}. It is a
simple exercise to check that  graph  and  fun  are morphisms in D. Moreover,  fun ˚ graph = id  and,
thus,  PωPω<Pω.
This example, which played a relevant role in denotational semantics, has been directly inspired by
Recursion Theory (see the references). Indeed, the work carried on so far can be naturally
“effectivized.”
2.4.1.5 Definition  A Scott domain  X = (X,≤)  is effectively given if  ∃e0: ω→X0  bijective
and 
1. ∃z∈X  e0(n), e0(m) ≤ z  is decidable in  n, m
2. ∃g∈R  (∃z∈X  e0(n), e0(m) ≤ z  ⇒  e0(g(n,m)) = sup{e0(n),e0(m)}).
Call ED the category of effectively given Scott domains and continuous functions. ED is a CCC. As
a matter of fact, the effectiveness properties are easily inherited at higher types.
Observe that, instead of taking the least upper bounds (l.u.b.’s) of all directed sets, as required in
the definition of ED, one may take only the computable l.u.b.'s, i.e. the l.u.b.'s of directed sets or
ideals in (X0,e0) that are indexed over recursively enumerable (r.e.) sets. (One may independently
choose directed sets or ideals and obtain the same collection of computable elements.)
These limits are computable in a very sound sense. For example,  (Pω, {en}n∈ω, ⊆)  is in ED
and its computable elements are exactly the r.e. sets.
Exercise Prove a similar fact for the set  P of partial maps from  ω  to  ω .
Call constructive domain a domain whose elements are the computable elements in an
effectively given domain. Since ED is Cartesian closed, this may be done in any (higher) type. In
particular, given the constructive domains  Xc, Yc  obtained from  X  and  Y , one may consider the
constructive domain  YXc  of the computable elements of  YX .  Define then the following
2.4.1.6 CD is the category of constructive domains and continuous and computable morphisms.
Exercise One clearly has to check that, for  f∈YXc, ∀x∈Xc  f(x)∈Yc.
By the Cartesian closedness of ED, CD also is a CCC. Observe that each  Xc  is countable and that it
can be effectively enumerated by using an acceptable enumeration of the r.e. sets.  Typical objects in
CD are  RE, the recursively enumerable sets, and PR (= Pc), the partial recursive functions (see the
exercise above).

2. Constructions
24
Thus, in a rather indirect way, that is by topological and order properties, we obtained a CCC of
countable (and numbered) sets. The proof that CD is a full sub-CCC of EN requires an important
generalization, in higher types, of the classical Myhill-Shepherdson theorem for enumeration
operators. The main application of CD is the characterization of the partial (continuous) and
computable functionals as the sub-CCC of CD generated by PR, i.e., taking PR and constructing all
higher types within CD (see also section 8.4-I). Moreover, one can give a countable and effective
interpretation to the recursive definitions of programs and data types within CD (by a constructive
version of the “limit constructions” in chapter 10).
Exercise Prove that  RE  is reflexive in CD (use the full and faithful embedding of CD in EN).
2.4.2 Coherent Domains
2.4.2.1 Definition  A coherent structure is a pair  (|X|,↑), where  |X|  is a set and  ↑  is a
binary, reflexive, symmetric relation on  |X|. The elements of  |X|  are called points, and the relation
↑  is called coherence.
The coherent domain associated with (|X|,↑)  is the collection  X  of subsets of  P(|X|)  whose
points are pairwise coherent. The elements of  X  are ordered by set-inclusion.
Coherence is extended to  X  in the obvious way, that is:  A ↑ B  iff  A∪B∈X.
Exercise Prove, when  X  is a coherent domain, that
1. ∅∈X
2. X  is closed under directed union
3. (A∈X and B ⊆A) ⇒  B∈X
2.4.2.2 Definition Let  X, Y  be two coherent domains.  A function  F: X → Y  is stable iff
i). F  is continuous
ii.∀A, B∈X   A ↑ B  ⇒  F(A∩B) = F(A)∩F(B)
2.4.2.3 Definition The category Stab has coherent domains as objects and stable functions as
morphisms.
Given two coherent domains  X  and  Y, their product  X×Y  is defined by:
i    |X×Y| = {(0,z) /  z∈|X| } ∪ {(1,z) /  z∈|Y| }
ii.  (a,z)↑(a',z')  [mod X×Y]   iff   a = a'  ⇒  z ↑ z' [mod D(a)], where  D(0) = X  and  D(1) = Y.

2. Constructions
25
Exercise Define the projections and check that they are stable, i.e., prove that Stab is Cartesian.
There is simple way to obtain stable functions over coherent domains.
2.4.2.4  Definition  Let  X,Y  be coherent domains. Let also  f  be an injective function from  |X|
to  |Y|  such that, for all  x,x'∈|X|, one has  {x, x'}∈X  ⇔  {f(x), f(x')}∈Y. Define then  f+:X→Y
and  f -: Y→X  by
i.   f+(a) = {f(z) / z∈a }
ii.  f -(b) = {z / f(z)∈b }
It is a matter of a simple exercise to prove that both  f+  and  f-  are stable functions.
We need to construct next an exponent object out of the set of stable maps over coherent domains.
2.4.2.5 Definition Let  F: X→Y  be a stable function. The Trace of  F  is  Tr(F) = {(a,z) / a∈X,
a is finite, z∈|Y|, z∈F(a), (∀a'⊆ a , z∈F(a')  ⇒  a = a')}.
F  is completely determined by its trace by means of the following equation: F(A) = {z∈|Y| /  ∃a ⊆ A
(a,z)∈Tr(F)}.
Exercise  Prove that the correspondence between stable functions and their traces is bijective.
Notation  The symbol  ↑↑  is used to represent strict coherence, i.e., A↑↑Β  iff  A↑Β and A≠B.
2.4.2.6 Definition  Let  |YX| = {(a,z) / a∈X, a is finite, z∈|Y| }. Moreover, let  (a,z) ↑ (a',z')
iff
i.   a ↑↑ a'  [mod X]  ⇒  z ↑↑ z' [mod Y]  and
ii.  a ↑ a'  [mod X]  ⇒  z ↑ z' [mod Y].
Then  YX  is the arrow domain (exponent object).
Exercises
1. Prove that conditions (i) and (ii) may be stated equivalently as
(a,z) = (a',z')   or   z↑↑z'   or   not  a↑a'.
2. Prove that every  element of  YX  is a trace of some stable function from  X  to  Y , and conversely
that if  F: X→Y  is stable then  tr(F)∈YX.
3. Let  f,g : X → Y  be two stable functions.
Define  f ≤B g  (Berry's order)  iff  ∀x,y∈X  x ⊆ y  ⇒  f(x) = f(y)∩g(x)
Prove that  f ≤B g  if and only if Tr(f) ⊆ Tr(g). Let moreover  ≤p  be the pointwise order. Prove that:

2. Constructions
26
i.  f ≤B g   ⇒   f ≤p g
ii.  f↑g   ⇒  (f ≤Bg ⇔ f ≤p g)
4. Let  X,Y  be coherent domains. A stable function  f: X→Y  is linear iff :
i.   a ∪ b∈X  ⇒  f(a ∪ b) = f(a) ∪ f(b)
ii.  f(∅) = ∅
Prove that  f: X→Y  is linear iff its trace is formed of pairs  (a,z), where the component  a  is a
singleton. Observe that the maps  f+  and  f-  in 2.4.2.4 are actually linear. Call Lin the category of
coherent domains and linear maps.
5. Let  f: X→Y, g: X→Y  be two linear functions. Prove that  Tr(f) ⊆ Tr(g)  if and only if for all  x
in X  f(x) ≤ g(x). Deduce as a corollary that on linear functions between coherent domains the order
of Berry coincides with the pointwise order.
2.4.2.7 Definition  The function  evalX,Y:  YX×X→Y  is defined by the following equation:
∀A∈YX, ∀B∈X  evalX,Y(A,B) = {y / ∃(b,y)∈A, b ⊆ Β}.
We prove that evalX,Y is stable. Continuity is trivial. We must only check that if  (A,B)↑(A',B')
[mod YX] then  evalX,Y( (A,B)∩(A',B') ) = evalX,Y( (A,B) ) ∩ evalX,Y( (A',B') ). The inclusion
⊆ is immediate by continuity.
Take then  z  in  evalX,Y( (A,B) ) ∩ evalX,Y( (A',B') ).  This implies  ∃(b,z)∈A, b ⊆ Β  and
∃(b',z)∈A', b' ⊆ Β'. Note that  B↑B'  by hypothesis and, thus,  b↑b'. Moreover, also by
hypothesis,  A↑A'  and then, by definition of consistency mod YX, one has  b = b'. This implies
(b,z)∈A∩A',b ⊆ Β∩B'  ⇔  z∈evalX,Y( (A∩A'),(B∩B') )  ⇔  z∈evalX,Y( (A,B) ∩ (A',B') ).
In conclusion, the category Stab of coherent domains and stable functions is a CCC.
Exercise Let  f+  and  f-  be defined as in 2.4.2.4, over coherent domains  X  and  Y. Prove that  f-
°f+  = idX, i.e., that  X<Y  via ( f+,f-)  in Stab.
By this technique and the following construction, one can easily construct, in each cardinal, a
coherent domain of which all other coherent domains of the same cardinality are retracts. In
particular, it will be so also its own function space.
2.4.2.8 Definition If  X  is a  coherent domain, then  !X  (read of course X) is the coherent
domain defined by
i.   |!X| = {a / a∈X, a finite}
ii.   a ↑ b [mod !X]   iff   a ∪ b ∈X .

2. Constructions
27
Let  T  be the three-element truth value poset {⊥,true, false}, i.e., the “lifting” of {true, false}.  For
simplicity, we look at the cardinal ω. Consider then the ω-power  Tω  of T. That is, take all the
functions from  ω  to  T. When  T  is partially ordered in the usual way, with  ⊥  least and  true  and
false  incomparable, then  Tω  is clearly a  coherent domain.  One may also understand  Tω  as the set
of disjoint subsets of ω.  Of course,  !Tω  is aslo in Stab by the definition just given.
2.4.2.9 Theorem Let D be a coherent domain with a countable  |D|, and let  e: ω→|D|  be a
bijective map. Then there exist an injective function  f  from  |X|  to  |!Tω|  such that, for all  x,x'∈|X|,
one has {x, x'}∈X  ⇔  {f(x), f(x')}∈!Tω.
Proof Let  f: |D| → |!Tω|  be defined in the following way:
f(e(i)) = < {i}, {j /  j ≤ i  and  not e(i)↑e(j)} >
Obviously f is injective. It is also trivial that {e(i),e(j)}∈D implies {f(e(i)),f(e(j))}∈!Tω. Conversely
suppose  not e(i)↑e(j) [mod D] , and let  i ≤ j  (the other case is analogous).  This implies that
i∈f(e(j))1  and then  not f(e(i))↑f(e(j)) [mod !Tω].
2.4.2.10 Corollary Let  f+  and  f-  be as in 2.4.2.4, for  f: |D|→|!Tω|. Then, for any coherent
domain  D  with a countable  |D|, one has  D<!Tω  via  (f+,f-).
The proof easily follows from the exercise above.  Note now that, if  D  is countably based, so is
DD, in Stab (check this for exercise).  Since, in particular,  |!Tω|  is countable, then  !Tω  turns ou to
be a reflexive object, as  !Tω!Tω< !Tω.
2.5 Equalizers and Pullbacks
Let  f,g: A→B  a pair of “parallel” functions in Set, i.e.  f, g  have the same source and target. The
subset  E  of  A  on which  f  and  g  agree, i.e., E = {x / x∈A, and f(x) = g(x)} is called an
equalizer of  f  and  g. We try now to give a categorical characterization of previous set-theoretic
notion. The starting point is that  E  being a subset of  A  it must be represented as a subobject, that
is, as a mono  i: E→A; moreover, i  must enjoy the property  f ° i = g ° i. But  E  is the maximal
subset of  A  on which  f  and  g  agree, and in order to guarantee this condition we require that if  h:
C→A  is any other function such that  f ° h = g ° h, then  h  “factors” uniquely through  i , that is,
there exist a unique  k: C→E  such that  h = i ° k. We now prove that the previous condition is
enough to ensure, in Set, that  i(E)  contains all  the x∈A, such that f(x) = g(x).
Suppose not, then there exist  a∈A, a∉i(E)  such that  f(a) = g(a). Consider the function  l:
E∪{a}→A  defined by  l(e) = i(e)  if  e∈E, l(a) = a. Of course  f ° l = g ° l, and therefore a morphism
k: E∪{a}→E  must exists such that  l = i ° k. But then  a = l(a) = i(k(a))∈i(E); this is a contradiction.

2. Constructions
28
Since this condition of unique factorization also implies that  i  is mono (see proposition 2.5.2
below) we are led to the following definition:
2.5.1 Definition  Given a pair of morphisms  f,g∈C[a,b], an equalizer of  f  and  g is a pair  (e,
i∈C[e,a])  such that :
i.   f° i = g° i
ii.  for all  h∈C[c,a],  f° h'= g° h'  implies  ∃! k∈ C[c,e]  i ° k = h.
Coequalizers are defined dually, that is a coequalizer of  f,g  is a pair  (e, i∈C[b,e])  such that:
i.   i ° f = i ° g
ii.  for all h∈C[b,c],  h ° f = h ° g  implies  ∃! k∈C[e,c]  k ° i = h.
2.5.2 Proposition  Every equalizer is monic.
Proof  Let  i: e→a  be the equalizer of  f, g: a→b.  Let  j, l : c→e, such that  i ° j = i ° l .
Since  f ° (i ° j) = (f ° i) ° j = (g° i ) ° j = g ° (i ° j)  there exists a unique  h: c→e  such that  (i ° j) = i ° h,
hence  j = h = l. ♦
2.5.3 Proposition  Every epic equalizer is iso.
Proof Let  i: e→a  be the equalizer of  f, g: a→b. Since  i  is epic, and  f ° i = g ° i, it follows that f =
g. The identity  ida  equalizes  f and g, and there is a unique morphism  h: a→e  such that  ida = i ° h.
Moreover  i ° h ° i = ida ° i = i ° ida, and since  i  is monic (by proposition 2.5.2), then  h ° i = ida . ♦
We now introduce one of the most powerful notions of Category Theory: the pullback. In a sense,
pullbacks generalize equalizers to pairs of morphisms with different sources.
2.5.4 Definition Given two arrows  f: b→a  and  g: c→a  with common target  a, the pullback
of  (f,g)  is an object  b×ac  and two arrows  p: b×ac→b, q: b×ac→c , such that
1. f ˚ p = g ˚ q: b×ac→a
2. for every other triple  (d, h: d→b, k: d→c) such that  g˚ k = f˚ h, there exists a unique arrow
<h,k>a: d→b×ac  such that  p ˚ <h,k>a = h, and q ˚ <h,k>a = k.
The dual notion is called pushout.

2. Constructions
29
A typical pullback diagram is as follows:
The lower “square” is also called “pullback square.” Note that the notation used for pullbacks is quite
similar to the one used for products; indeed, they behave similarly (products are just a particular case
of pullbacks, see proposition. 2.5.5 below). Note also that the subscript  a  is meant to express the
dependency of  b×ac  and  <h,k>a  on  f  and  g, but  b×f,gc  and  <h,k>f,g, is too heavy a notation:
the subscript must be considered essentially as a warning that we are dealing with a pullback, not just
a product. Usually this omission of information is harmless, because the particular pullback we are
considering is clear from the context.
Example In Set the pullback of  (f: B→A, g: C→A)  is as follows:
({<x,y> / x∈B, y∈C, f(x) = g(y) }, p1, p2)  where  p1(<x,y>) = x  and  p2(<x,y>) = y.
2.6.5 Proposition  Let C be a category with a terminal object t. For any object  a  of C, let  !a  be
the unique morphism in  C[a,t]. If C has pullbacks for every pair of arrows, then it also has products
for every pair of objects.
Proof Hint. Given a,b in C, let  (a×b, p1: a×b→a, p2: a×b→b)  be the pullback of (!a: a→t, !b:
b→t). It is easy to verify that this is a product. ♦
2.6.6 Proposition  If a category C has pullbacks for every pair of arrows and it has terminal
object, then it has an equalizer for every pair of arrows.
Proof  Let  f,g: a→b. Let (c, fst:c→a, snd:c→a) be the pullback of  (<f,ida>: a→b×a, <g,ida>:
a→b×a). Then the equalizer of  f,g  is (c, fst = snd). Indeed, f ˚ fst = p1˚ <f˚fst,fst> = p1˚ <f, ida> ˚
fst  = p2 ˚ <g,ida> ˚ snd = p2 ˚ <g˚snd,snd> = g ˚ snd. Moreover, for any  (c', h:c'→a)  such that  f
˚ h = g ˚ h , also  <f,ida> ˚ h = <g,ida> ˚ h; by definition of pullback, there exists a unque  k: c'→c
such that  fst ˚ k = h. ♦

2. Constructions
30
2.6.7 Pullback Lemma (PBL)  If a diagram of the form
commutes, then
i.  if the two small squares are pullbacks, then the outer rectangle is a pullback;
ii. if the outer rectangle and the right-hand square are pullbacks, then the left-hand square is a
pullback.
Proof Exercise. ♦
2.6.8 Proposition  If the square
is a pullback and  g  is monic, then  p  is monic as well.
Proof: Exercise. ♦
The previous property suggests an interesting generalization of a common set-theoretic construction.
If  f  is a function from a set  A  to a set  B, and  C  is a subset of  B, then the inverse image of  C
under  f, denoted  f-1(C)  is that subset of  A  defined by  f-1(C) = {x/ x∈A, f(x)∈C }.
It is easy to show that the diagram
is a pullback square in Set.

2. Constructions
31
In general, given a monic  g: c→b  and a morphism  f: a→b, the inverse image of  g  under  f
is the subobject of  a  (if it exists) obtained by pulling back  g  along  f.
2.6  Partial Morphisms and Complete Objects
As mentioned in the introduction, the common perspective of Programming Language Theory and
Category Theory is due to the priority given to “functions” with respect to “sets.” The latter notion,
when  required, is a derived notion of the former, in a sense.
There is an other aspect, though, that should be considered. In Computation Theory, as well as in
actual programming, diverging computations cannot be avoided unless a restriction is made to a
subclass of the computable functions.
The notion of partiality has a natural interpretation over sets. Let  f: A→B be a partial function;  the
domain of convergence of  f, call it   f↓,  is just a subset of its “domain” A in the broader sense;
moreover the restriction of  f  to  f↓  is a total map  f|(f↓): f↓→B. Thus a partial map  f  may be
represented by a pair of total functions (i: D→A, h: D→B),  where  D⊆A  is the domain of
convergence of  f, h  is the restriction of  f  to  D, and  i: D→A  is the canonical injection .
If we try to simulate the previous definition in categorical language, it is natural to define a partial
map  f  between two objects  a  and  b  in a category  C  as a pair  (m: d→a , h: d→b),  where  m  is
monic. However, as in the case of subobjects, we have no way to choose  d  in a canonical way, so
we are forced to identify partial morphisms up to isomorphic variations of  d (see section 1.5.)
2.6.1 Definition  Given a category C and two objects  a  and  b, a partial map  [m, h]: a→b  is an
equivalence class of pairs (m: d→a, h: d→b), where  m  is monic, with respect to the following
relation R:  (m: d→a, h: d→b) R (m': d'→a, h': d'→b)  iff  ∃k: d→d', k iso, m' = m ° k , h' = h ° k.
With a little abuse of language, we will often speak about a particular pair  (m: d→a, h: d→b)  when
we actually mean  [(m: d→a, h: d→b)]R.
Our next aim is to define a category pC of partial maps on C. The main problem is in defining
composition. If C has pullbacks for every pair of arrows, then the problem is resolved in the
following way.
Given  (n: e→b, k: e→c)  and  (m: d→a, h: d→b), define  [n, k] ° [m, h]: a→b  as the equivalence
class determined by the outermost sides in the following diagram, i.e., (m˚n': d×be→a, k˚h':
d×be→c) :

2. Constructions
32
where the square is a pullback. Note that by proposition 2.5.8, since  n  is monic,  n'  is monic, too.
Let us see how the previous definition works in Set. For the equivalence relation defined on
partial morphisms, we suppose  d⊆a, e⊆b  and take  m: d→a, n: e→b  as canonical injections. Then
d×be = {(x,y) / x∈d, y∈e, h(x) = n(y) } = {(x,y) / x∈d, y∈e , h(x) = y } ≅ {x / x∈d, h(x)∈e },
that is, the expected domain of convergence of the composed function. The projections  h'  and  n'
associated with the pullback  {x / x∈d, h(x)∈e}  are respectively  h|{x / x∈d, h(x)∈e}  and the
canonical injection  i: {x / x∈d, h(x)∈e}→d. In conclusion, for all  x∈{x / x∈d, h(x)∈e }, one has
k(h'(x)) = k(h(x)) , as we wanted.
Every arrow  f∈C[a,b]  has a natural associated arrow in pC, that is  (id: a→a, f: a→b). We say
that a map in pC is total  iff it has the above form (up to equivalences). (pC)t is the subcategory of
pC of total maps. As will become clearer in the next chapter, C is “isomorphic” to (pC)t.
Exercise  Prove the following assertions:
1.  id is total;
2.  f,g  total  ⇒ f°g  total;
3.  f°g  total  ⇒  g  total;
Example  pSet is the category of sets with partial maps as morphisms. pR = PR is the monoid of
the partial recursive functions. pEN is defined by using partial recursive functions in the diagram
that defines the morphisms, instead of the total ones (see section 2.2). Observe that the diagrams
commutes  iff  eb°f' = f°ea  for f'∈PR and, hence,  ea(n) = ea(m)  and  f'(n)↓  ⇒  f'(m)↓. Clearly,
(pSet)t = Set, PRt = R  and (pEN)t = EN.
Remark  Sometimes, in the construction of the category pC from C, it may be intersting to restrict
our attention to only a subset of the class of monics of C. Consider, for example, the category PO of
p.o.sets: an interesting definition of a partial map  f  between two p.o.sets would also require  f  to be
defined in an upward closed subset. Let C be a category with pullbacks for every pair of arrows. An

2. Constructions
33
admissible family  M  of monics of C, is a family of monics closed under identities,
compositions, and pullbacks. Every admissible M on a category C gives rise to a different category
(M)(pC) of partial maps.
As already recalled, diverging computations play an essential role in the theory of computation.
They also have an obvious interpretation in Set Theory.  However, the set-theoretic understanding of
computations may not suffice. Type-free languages and many typed ones, as we shall see later,
escape a “naive” interpretation as sets and functions.
As a matter of fact, since the early days of denotational semantics of programming languages, the
need to give meaning to (possibly) diverging computations over nontrivial mathematical structures
suggested the introduction of various categories of p.o.sets with least elements. The naive
understanding of this is immediate: add to all required data types, as sets, an extra element and give
them a p.o.set structure as flat p.o.sets (i.e., ⊥  is the least element and all others are incomparable).
We already dealt with this in practice, when presenting various categories of p.o.sets as examples of
CCC's. In a sense, the bottom element  ⊥  provides the first hint of the introduction of approximation
and continuity notions to the mathematical semantics of programs.
As we have demonstrated, this concept is very clear matematically, at least in several specific
categories, such as continuous or algebraic lattices, c.p.o’s, and Scott domains. It is not so simple in
interesting categories for computations such as EN, though.  In order to understand it in a general
setting and avoid any abuse of this simple concept, a category-theoretic perspective may provide a
sound mathematical frame.
Notation  In the rest of this section, C is a category of partial maps, i.e., C = pD for some
category D with pullbacks for every pair of arrows. Ct is the associated category of total maps. Since
Ct  is a subcategory of C, we compose total and partial morphisms by using the same operation of
composition. For typographical reasons, we write  a°  instead of  a⊥.
The set-theoretic idea we try to formalize categorically is that, when an object  a  is “lifted” to a° by
adding an extra least element, then any hom-set of total maps with target  a°  is isomorphic to the
corresponding hom-set with target  a .
2.6.2 Definition. The lifting of a∈ObC is an object a°∈ObCt together with a morphism
exa∈C[a°,a] and for every c∈ObC an operation  τc: C[c,a]→Ct[c,a°] such that, for every  f∈C[c,a]
and for every  g∈Ct[c,a°]  one has
1.  exa ° τc(f) =f
2.  τc( exa ° g ) = g.

2. Constructions
34
The operation  τc: C[c,a]→Ct[c,a°]  is bijective, as  τc-1  is defined by  τc-1(g) = exa ° (g).
Conversely, if  τc  is bijective and (1) holds, then also (2) does. Indeed, let  g∈Ct[c,a°]; since  τc  is
surjective, then there is  f∈C[c,a]  such that  τc(f) = g. That is, τc(exa ° g) = τc(exa ° τc(f)) = τc(f) =
h  Thus, the following is an equivalent definition of the lifting object:
2.6.3 Definition.  The lifting of a∈ObC is an object a°∈ObC together with a morphism exa∈
C[a°,a] such that, for every  f∈C[c,a], there exists one and only one  g∈Ct[c,a°]  satisfying the
equation:  exa ° g = f.
Thus, as we wanted, for all  b, C[b,a] and Ct[b,a°] are isomorphic, since any partial morphism
f∈C[b,a] may be uniquely extended to a total one when the target object is lifted (and the lifting
exists).
Exercise  Prove that the lifting  a°  of an object  a  is unique, if it exists.
2.6.4 Proposition.  Let  a°  be the lifting of  a  and set  ina = τ a(ida) . Then  a  is a retract of  a°  in
C   (notation:  a <p a°)   via  (ina ,exa).
Proof.
      exa° ina = (τ a°)-1(id) ° ina
by definition of  (τ a°)-1
= (τ a)-1(id ° ina)
= (τ a)-1(τa(id))
= id. ♦
2.6.5 Definition.  An object  a∈ObC  is a complete object  iff  a < a°  in  Ct.
The intuition should be clear.  An object is complete when it “already contains,” in a sense, the  extra
⊥ .  Think of an object  d  of pCPO and take its lifting  d° , i.e., add a least element  ⊥  to  d.  Then
d is complete, that is, d < d° via (i,j),  iff  d  already contained a least element,  j(⊥)  to be precise.  It
is actually easy to show that the complete objects in pPO, and likewise in pCPO, are exactly the
partial ordered sets with a least element.
Note that in contrast to the partial retraction  a <p a°  via  (in,ex) in definition 2.6.4, which may be
always given, only complete objects yield total retractions  a < a°.
2.6.6 Lemma.  If  a < a°  via  (i,j)  (in Ct),  then  ∃out∈Ct[a°,a]  a < a°  via  (τa(ida),out).
Proof  Set  out = j ° τ(exa°i°exa). Then
             out ° τa(ida)
= j ° τ(exa°i°exa) ° τa(ida)
= j ° τ(exa°τ(exa°i°exa) ° τa(ida) )
by (2) in def. 2.6.2
= j ° τ(exa ° i ° exa ° τa(ida) )
by (1)

2. Constructions
35
= j ° τ(exa ° i)
by (1)
= j ° i
by (2)
= ida. ♦
Thus we may then assume that, if  a  is complete,  a < a°  via (in=τa(ida),out).
The following fact gives the main motivation for the invention of complete objects: exactly on
complete objects as targets all partial morphisms may be extended to total ones, with the same target.
2.6.7 Definition  f∈Ct[b,a]  extends  f∈C[b,a]  iff  ∀c∈ObC, ∀h∈Ct[c,b],  (f ° h)∈Ct[c,a]
⇒  f ° h = f ° h.
2.6.8 Theorem.  Let  a°  be the lifting of a∈ObC. Then  a < a°  ⇔  ∀b, ∀f∈C[b,a], ∃f∈Ct[b,a]
such that  f  extends  f.
Proof.(⇒)  Set  f = out ° τb(f). Then, for every h∈Ct[c,b], such that  (f ° h)∈Ct[c,a] ,
              f°h = out°τb(f)°h
= out°τc(exa°τb(f)°h )
by (2) in def. 2.6.2
= out°τc(f°h)
by (1)
= out°τc( exa°τa(ida)°f°h )
by (1)
= out°τa(ida)°f°h
by (2)
= f°h
(⇐) just take  ex ∈Ct[a°,a]. ♦
Exercises  Prove the following facts:
1. a° < a°°.
2. b < a < a°  ⇒  b < b°. (Hint:  let  b < a  via  (i,j).  For any  f∈C[c,b]  consider the extension
i°f∈Ct[c,a]  of  i°f∈C[c,a]. Then  j°i°f∈Ct[c,b]  and  ∀h into dom(f)   j°i°f°h = j°(i°f°h) = f°h.)
2.7 Subobject Classifiers and Topoi
Subobjects and partial morphisms already forced some typical set-theoretic notions into the realm of
categories. Let us take now a further step and categorically reconstruct power-sets and related
constructions. By this, it will be possible to relativize these notions to structured sets. As for
subobjects, the categorical version carries the structural information of the intended category.
In Set there is a one-to-one correspondence between subset of a set  A  and functions from  A  to
2={true, false}.  The isomorphism takes every  B⊆A  to its characteristic function  cB:A→2,
defined by the following: cB(a) = true  if  a∈B, cB(a) = false  if  a∉B. This isomorphism may be
expressed in the categorical language by means of a pullback diagram

2. Constructions
36
where  inB: B→A is the subset inclusion, and  true: {*}→{true, false}  takes  *  to “true.”
The above diagram suggests the following definition in Category Theory:
2.7.1 Definition  Let  C  be a category with a terminal object  t. A subobject classifier  is an
object  Ω  together with a morphism  true: t→Ω such that for every monic  i: b→a  there is a unique
arrow  cb: a→Ω  such that the following diagram is a pullback diagram:
Exercise  A subobject classifier, when it exists in C, is unique up to isomorphisms.
The subobject classifier Ω plays a central role in the translation of Set Theory into Category Theory.
It allows the simulation into the categorical language of concepts like intersection, union, and
complement, by the definition of a Heyting algebra of truth-morphisms over Ω.
2.7.2 Definition  A topos  is a category C with a terminal object, a subobject classifier, pullbacks
for every pairs of arrows, and exponents for all pairs of objects.
It will turn out that a topos is a “universe” where we can carry out constructions with almost the same
confidence as we do in Set. Of course, Set itself is a topos.
Exercises
1. Prove that if C is a topos, then C is a CCC.
2. In a topos C, what is the arrow  eval:  Ωa×a→ Ω ?

2. Constructions
37
In the spirit of a categorical description of set-theoretic concepts, one may also talk in topoi of
“relations”, “powersets”, and so forth. Quite generally, given objects  a  and  b, a relation on  a  and
b, is simply a monic  r: d→a×b. In particular, then, one may consider power-objects  P(a)  as given
by a relation   ∈a: d→a×P(a)  with the following universal property:
2.7.3 Definition  Let C be a cartesian category and  a∈ObC. The power-object  P(a)  is an
object of C together with an object  d  and a monic  ∈a: d→a×P(a)  (a membership-relation)
which is universal in the sense that, for any object  b  and monic  m : e→a×b, there is a unique map
r: b→P(a)  and a (forcedly unique) map  g: e→d  to make the following square a pullback:
As  Ω  is the truth value object, the set-theoretic intuition suggests that, in a topos, the object  Ωa
should represent  exactly the power-object of  a.
2.7.4 Proposition  In a topos C every object  a  has a power-object  Ωa.
Proof. Let  ∈a: d→a×P(a)  be defined by the following pullback square:
Then the required universality of  ∈a  is given by the properties
1. of the subobject classifier, i.e. the existence of the characteristic map  ce  of  m;
2. of the map  eval , i.e. the existence and unicity of  Λ(ce);
3. of the above pullback ;
an by an application of the pullback lemma 2.5.7. All this is described by the following commuting
diagram, where the squares are pullbacks:

2. Constructions
38
♦
The reader who has completed exercise (2) above may easily understand the intuitive meaning of
the construction in 2.7.3 and compare it to his set-theoretic understanding.  In particular,  eval  says
whether “an element of  a  is in a given subset of  a .”
Exercises
1. Prove that any topos has lifting.
2. Prove that a category C is a topos if and only if it has a terminal objects, and all pullbacks and
powerobjects.
References  The general notions can be found in the texts mentioned at the end of chapter 1,
though their presentation and notation may be different. For example, in the case of CCC's, this is so
also because these categories play a greater role in the categorical approach to Type Theory, or to
denotational semantics, than in other applications of Category Theory. Notice that Grp and Top are
not CCC's and consider that the origin of Category Theory is largerly indebted to algebraic geometry.
Applications of universal concepts from Category Theory to Programming Language Theory have
been developed by several authors, in particular for program specification.  For instance, the work by
the ADJ group is explicitly based on universal conditions for specification (initial algebras of abstract
data types; see Goguen et al. (1973/78) ). An early insight in the connections between programs and
categories may be found in Burstall and Thatcher (1974). All these aspects go beyond the limited
aims of this book, which privileges “theories of functions” over “algebraic theories.” Some more
notions with an algebraic flavor may be found in chapter 4.
As for the examples we have provided, they originated entire areas of research.  In particular, the
category EN was first introduced by Malcev, as a general setting of Recursion Theory, and widely
used in Ershov (1973/75). Scott domains and related categories are broadly treated in several places,

2. Constructions
39
e.g. Scott (1981/82), Scott and Gunter (1989) or many books in denotational semantics. Scott (1976)
presents Pω as a reflexive object and discusses categories of retractions. The (generalized) Myhill-
Shepherdson theorem and related matters may be found in Scott (1976), Giannini and Longo (1984),
Berger (1986), Rosolini (1986), and Longo (1988a), among others.
Coherent domains are given in Berry (1978) and used in Girard (1986), where linear maps are
introduced (with some relevant consequences, see section 4.4).
There is a broad literature on categories with partial maps.  We partly followed the approach in
DiPaola and Heller (1984), and in Longo and Moggi (1984), where the notions of “complete object”
and partial Cartesian Closed Category were introduced (and applied in Asperti and Longo (1987) ).
The properties of complete objects carry on also when using a more topos-theoretic perspective, as
shown in Moggi (1988), which is devoted to a deeper insight into the concepts just sketched here.
New results and surveys on categories with partial morphisms may be also found in Rosolini (1986),
Moggi (1988a), Robinson and Rosolini (1988) and Curien and Obtulowicz (1988). Independently of
the category-theoretic approach, Plotkin (1984) used the category pCPO for the purposes of
denotational semantics.
Toposes originated by works of Lawvere and Tierney. A (difficult) introduction to Topos Theory
may be found in Johnstone (1977). The reader may also consult Goldblatt (1979) or Barr and Wells
(1985) on this subject.

3. Functors and Natural Transformations
40
Chapter 3
FUNCTORS AND NATURAL TRANSFORMATIONS
The starting point of Category Theory is the premise that every kind of mathematically structured
object comes equipped with a notion of “acceptable” transformation or construction, that is, a
morphism that preserves the structure of the object. This premise holds for categories themselves: a
functor is the “natural” notion of morphisms between categories. By a further step, the question
about what a morphism between functors should look like suggests the notion of natural
transformation.
Of course, this is not a matter of arbitrary generalizations: it is a habit of mathematics to build
constructions on top of constructions, since one may understand in this way, by the uniformity of
methods and language, the reasonableness of specific constructions.  And this theoretical unification,
suggesting power and intellectual unity, is one of the major merits of Category Theory and its
applications.
Moreover, as we shall see in several examples, there are notions which are clarified in an
essential way or even suggeted by the categorical language of functors and natural transformations.
Indeed, there are even too many examples for our purposes, and we will be able to mention only a
few that are easily met in computer science.
3.1 Functors
If a transformation F between two categories C and D must map the categorical structure of C to that
of D, it must take objects and morphisms of C to objects and morphisms of D; moreover, it must
preserve source, target, identities and composition. Such a transformation  F: C→D  is called a
functor.
3.1.1 Definition  Let  C  and  D  be categories.  A (covariant) functor  F : C → D  is a pair of
operations Fob: ObC → ObD , Fmor: MorC → MorD  such that, for each   f: a→b , g: b→c  in C,
-  Fmor(f) : Fob(a)→ Fob(b)
-  Fmor(g ° f) =  Fmor(g) ° Fmor(f)
-  Fmor(ida) = idFob(a).
It is usual practice to omit the subscripts “ob” and “mor” as it is always clear from the context
whether the functor is meant to operate on objects or on morphisms.

3. Functors and Natural Transformations
41
1.2 Examples
1. If C and D are preorders, then a functor  F: C→D  is just a monotone function from the objects of
C to the objects of D, indeed  a <C b  ⇔  ∃f∈C[a,b]  ⇒  F(f)∈D[F(a),F(b)]  ⇔ F(a) <D F(b).
Conversely, given a monotone function  f  between two partial orders C and D, there is of course
only one way to extend  f  to a functor among the categories associated with C and D.
2. The identity functor  I: C→C  is defined by a pair of identity operations both on objects and on
morphisms of C.  Similarly, we define the inclusion functor Inc: C→D when C is a subcategory
of D.
3. If C is a Cartesian category define ××××: C××××C→C as the pair of operations that take (a,b)∈ObC××××C
to ××××(a,b) = a×b∈ObC, and (f,g)∈C××××C[(a,b),(c,d)] to ××××(f,g) = f×g = <f˚p1,g˚p2>∈C[a×b,c×d]. ××××
is a functor. Indeed  ××××  preserves sources and targets and, moreover,
××××(ida,idb) = ida×idb = <pa,pb> = ida×b = id××××(a,b)
××××( (f,g)°(h,k) ) = ××××(f°h,g°k) = (f°h)×(g°k) = (f×g)°(h×k) = ××××(f,g) ° ××××(h,k)
×××× is usually called product functor (since products are only determined up to isomorphisms, we
must assume here a canonical choiche, for each object a, b, of their product a×b).
4. The power-set functor P: Set→Set takes every set A tο its power-set P(A) and every function
f: A→B to the function  P(f): P(A)→P(B)  defined by
∀A'⊆A  P(f)(A') = {y∈B /  ∃x∈A', y = f(x)}.
Note that the set  P(f)(A')  is what is usually called f(A').
A functor  F: C→D  preserves a property P that an arrow  f  may have in C, if  the arrow  F(f) has
the same property in  D. For example, every functor preserves isomorphisms, or the property of
being a component of a retraction pair, as it is stated in the following proposition:
3.1.3 Proposition  Let  F: C→D  be a functor. If  a<b  (a ≅ b)  in C, then  F(a) <F(b)  (F(a) ≅
F(b))  in  D.
Proof.  If  f˚g = id, then  F(f)˚F(g) = F(f˚g) = F(id) = id. ♦
Exercise Does every functor F preserve the property of being monic or epic?
A functor  F: C→D is faithful if for all a,b∈ObC and for all f,g∈C[a,b], F(f) = F(g) implies f = g;
it is full if for all a,b∈ObC and every h∈D[F(a),F(b)] there is g∈C[a,b] such that  h = F(g). A
functor  F: C→D is a full embedding iff it is full and faithful, and it is also injective for objects.
A functor that “forgets” (part of) the intended structure of the objects is called forgetful: typical
examples are the functors from Grp, Top, or PO to Set which assign to each object its set of
elements and to each arrow the function associated with it. This notion is not a precise one, but it is

3. Functors and Natural Transformations
42
usually clear when a functor can be considered “forgetful”; note however that a forgetful functor
should always be faithful (and very rarely full).
The definition of functor we have given preserves also the direction  of the arrows in C. In some
cases, it is interesting to study transformations among categories that reverse such directions, that is,
by mapping sources to targets and vice versa. A transformation of this kind between two categories
C to D may be considered as a functor from the dual category Cop to D, and it is known as
contravariant functor (from C to D). Explicitly, note the following definition
3.1.4 Definition  Let C and D be categories. A contravariant functor  F: C→D  is a pair of
operations Fob: ObC→ObD, Fmor: MorC→MorD such that for each  f: a→b , g: b→c  in C,
-  Fmor(f) : Fob(b)→Fob(a)
-  Fmor(g ° f) =  Fmor(f) ° Fmor(g)
-  Fmor(ida) = idFob(a)
Examples
1. Each functor  F: C→D  defines a  contravariant functor  Fop: Cop→D  that coincides with  F  on
objects and such that  Fop(f) = F(fop),  Fop(g˚f) = Fop(f)˚Fop(g). Of course,  F = (Fop)op.
2. The duality functor  ( )op: C→Cop  is a contravariant functor such that  (a)op = a  for a∈ObC
and  (f)op = f  for f∈MorC.
3. The function that takes every set A tο its power-set P(A) may be also extended in a natural way to
a contravariant power-set functor P: Set→Set. Just define, for  f: A→B, P(f): P(B)→P(A)
as the function that assigns to each  B'⊆B  the set  P(f)(B') = f -1(B') = {x∈A / ∃y∈B', f(x)=y}.
4. Let C be a category with pullbacks, and let  f∈C[a,b]. Then  f  induces a pullback functor  f*:
C↓b→C↓a, whose action is described in the following diagram:
In this diagram, g  and  h  are objects of C↓b, and  k∈C↓b[g,h]; f*(g)  and  f*(h)  are the pullbacks
of  g  and  h  along  f, yielding a unique arrow  f*(k)  making the above diagram commute. The proof
that f* is a functor is a consequence of elementary properties of pullback, and it is left as an exercise
for the reader.

3. Functors and Natural Transformations
43
5. Let C be a CCC. For every c∈ObC the exponent functor expc: C→C is defined as follows.
For every a∈ObC, set expc(a) = ca , and for every f∈C[a,b], expc(f) = Λ(evalb,c ° id×f) : cb→ca.
As a diagram,
In order to check that expc is actually a contravariant functor, we must take these steps:
expc(id)
= Λ(eval ° id×id) = Λ(eval) = id
expc(f ° g) = Λ(eval ° id×( f ° g ) )
= Λ(eval ° id×f ° id×g )
= Λ(eval °Λ(eval ° id×f)×id ° id×g )
by the diagram
= Λ(eval ° id×g  ° Λ(eval ° id×f)×id )
= Λ(eval ° id×g ) ° Λ(eval ° id×f)
= expc(g) ° expc(f). ♦
Note that the composition of two functors is still a functor and that there exists the identity functor
which is right and left invariant w.r.t. composition. Thus, it is sound to define the category Cat
whose objects are categories and whose morphisms are functors. It is worth pointing out that this is a
convenient and unusual algebraic property. The collection of groups is not (naturally) a group;
similarly for topological spaces and so on. The definition of Cat, so similar to the paradoxical “set of
all sets” of Set Theory, must be used with some caution, however. It is not our intention to engage in
foundational questions in this book, but it is time to say a few more words about our “axiomatic”
defintion of Category. So far we have made no assumption at all about the dimension of the classes
ObC  and  MorC; the word “class” itself has been used in an intuitive sense, without any reference to
an underlying Set Theory. From now on, though, the reader may refer to the notions of set and class
as used, say, in Gödel-Bernays Set Theory, in order to make this distinction clear. From this
perspective, a Category C such that  ObC  and  MorC  are sets, is called small. In the sequel, when
we refer to Cat, we mean the category of all small categories; of course, Cat itself is not a small
category, and thus it is not among its own objects.
(Question: which of the categories mentioned so far are small, and which are not?)
If C is a small category, then, for all  a,b∈ObC, C[a,b] is a set, usually called hom-set of  a
and  b  (some authors use the word “hom-set” in an arbitrary category). We say that a category C is
locally small when for all a,b∈ObC, C[a,b]  is a set and not a class.  If C is a locally small

3. Functors and Natural Transformations
44
category, it is possible to define some functors from C to Set, called hom-functors, that play a
central role in the developments of Category Theory. We shall see later that most of this work may be
done at a more abstract level, taking an arbitrary topos D instead of Set.
3.1.5 Definition  Let C be a locally small category. Given a∈ObC, the covariant hom-functor
C[a,_]: C→Set  is given by: 
i.  for every  b∈ObC  C[a,_](b) = C[a,b]∈ObSet;
ii. for every g∈C[b,b'], C[a,_](g): C[a,b]→C[a,b']  is the function that takes f∈C[a,b]  to  (g°f)
∈C[a,b']  that is,
The function  C[a,_](g)  will be denoted in the sequel by  “C[a,g]”  or also by the suggestive  “g ° _”
(some authors use also g*). Note that the drawing above is clearly an implication between diagrams.
Their plain juxtaposition will be used often in the sequel with this meaning, as a special case of the
“conditional equational reasoning” mentioned earlier in section 1.2.
3.1.6 Definition Let C be a locally small category. Given  b∈ObC , the contravariant hom-
functor  C[_,b]: C→Set  is given by: 
i.  for every  a∈ObC   C[_,b](a) = C[a,b]∈ObSet
ii. for every  h∈C[a',a], C[_,b](h): C[a,b]→C[a',b]  is the function that takes  f∈C[a,b]  to  f °
h ∈C[a',b] that is
The function  C[_,b](h)  will be denoted in the sequel by  “C[h,b]”  or by the suggestive  “_ ° h”
(some authors use also  h* .)
3.1.7 Definition  Let  C  be a locally small category. Given  b∈ObC , the hom-functor  C[_,_]:
CopxC→Set  is given by: 

3. Functors and Natural Transformations
45
i.  for every  (a,b)∈ObCxC   C[_,_](a,b) = C[a,b]∈ObSet
ii. for every  h∈C[a',a], g∈C[b,b'], C[_,_](h,g): C[a,b]→C[a',b']  is the function that takes
f∈C[a,b]   to   g ° f ° h ∈C[a',b']
C[_,_] is contravariant in the first argument and covariant in the second.  One may understand how
C[_,_]  works on morphisms by the following commutative diagram:
The function  C[_,_](h,k)  will be denoted by  “C[h,k]”  or by   “g °_ ° h.”
Exercise: prove in details that  C[a,_]  and  C[_,b]  are a covariant and a contravariant functor,
respectively.
Exercise A category C has enough points iff the functor  C[t, -]  is faithful, when  t  is terminal.
3.2 Natural Transformations
The fact that  F  is a functor from a category  C  to a category  D  may be equivalently expressed by
F(id) = id  and, for every  f  and  g  in MorC , by the following (implication between) diagrams:
Consider now two functors  F, G:  C→ D.  A quite reasonable idea of transformation from  F  to  G
is a “translation” as described in the following picture, where the dotted lines should yield
commutative squares

3. Functors and Natural Transformations
46
Thus, the “translation” can be defined by assigning to each object  a∈ObC  an arrow  τa:
F(a)→G(a), with the only condition that, for every  f∈C[a,b],  the following diagram commutes:
The properties described in this diagram are equivalently formalized by the following definition.
3.2.1 Definition.  Let  F,G : C → D  be functors. Then  τ : F → G  is a natural
transformation from  F  to  G  iff: 
i. ∀a∈ObC   τa∈D[F(a),G(a)]
ii. ∀f∈C[a,b]    τb ° F(f) = G(f) ° τa .
3.2.2 Example  Let  C be a small category, and  h∈C[a',a] . The collection (in Set) of
morphisms  {C[h,b] / C[a,b]→C[a',b] }b∈C, defines a natural transformation  C[h,_]  from the
(contravariant) hom-functor  C[a,_]  to  the (contravariant) hom-functor  C[a',_]. Note the following
diagram:

3. Functors and Natural Transformations
47
The same diagram proves that, given k∈C[b,b'], the collection of morphisms {C[a,k] /
C[a,b]→C[a,b'] }a∈C  defines a natural transformation  C[_,k]  from the hom-functor  C[_,b]  to
the hom-functor  C[_,b'].
It is easy to close up natural transformations under composition by setting  (τ˚β)a = (τa)˚(βa). This
composition of natural transformation is usually called vertical, as opposed to the horizontal
composition, defined at the end of this section.  Since the identity transformation from a functor  F
to itself is defined in the obvious way, we have actually constructed a new category, starting from
any two given categories  C  and  D .
The new category is called the category of functors from C to D, (C→D) = Funct(C,D);
its objects are functors and the morphisms are natural transformations.  In particular, if  F,G: C→D,
Funct(C,D)[F,G]  is the collection of all the natural transformations from  F to G;  in the following
we shall use the abbreviation  Nat(F,G) instead of  Funct(C,D)[F,G].
Two functors from  C  to  D  are equivalent (or naturally isomorphic) iff they are isomorphic
as objects of Funct(C,D). For example, it is well understood that any set  A  is isomorphic to  A×1,
where 1 is a singleton.  For arbitrary cartesian categories, this corresponds to saying that the functor
_×1  and the identity functor  Id  are naturally isomorphic.  If F: C→D  is a full embedding, then  C
is isomorphic to a full subcategory of D. The next section will present further examples of natural
isomorphisms.
The concept of natural isomorphism of functors also allows us to define a notion of
“equivalence” between categories, which captures better than the notion of isomorphism the sense
that two categories can be said to be “essentially the same.” Two categories  C  and  D  are
equivalent if and only if there are two functors  F: C→D  and  G : D→C  such that  G ° F ≅  idC
and  F ° G ≅  idD   (note that  C  is isomorphic to  D  iff  G ° F =  idC   and  F ° G = idD).
3.2.3 Proposition Let  F,G : C→D  be functors and  τ : F→G  be a natural transformation from
F  to  G.  Assume that, for each  a∈ObC,  τa ∈ D[F(a),G(a)]  is an isomorphism.  Then  τ   is a
natural isomorphism.

3. Functors and Natural Transformations
48
Proof  Define  τ-1 : G→F  by   τ-1a = (τa)-1.   τ-1  is natural, since  ∀f∈C[a,b]
τ−1b ° G(f) = τb−1 ° G(f) ° τa ° τa-1
= τb−1 ° τb ° F(f) ° τa-1
= G(f) ° τ−1a. ♦
Examples  A simple example of natural transformation may be given by studying “liftings” (see
section 2.6), in various categories. One may actually understand the general notion better, by
completing a little exercise on natural transformations. Indeed, what is hidden behind definition
2.6.2, is the “naturality” of  τc. When writing this down explicitly, the definition is tidier and more
expressive. Let C be a Category of partial maps, Ct be the associated category of total maps, and
Inc: Ct→C be the obvious inclusion. Thus, 2.6.2 may be simply restated as
The lifting of  a∈ObC   is the object  a°  such that the functors  C[_,a] ° Inc, Ct[_,a°] : Ct→Set
are naturally isomorphic.
Then, by definition of natural transformation and hom-functor, this requires the existence of a
function  τ  such that the following diagram commutes, for any object  b  and  c  in C and  f∈Ct[c,b]
That is,  τc(g°f) = τb(g)°f  and  (τc)-1(h°f) = (τb)-1(h)°f , for any total  f, since  τ  is an isomorphism.
With this definition, to prove unicity of liftings is even smoother than in section 2.5. Indeed, let
τ  be the given natural isomorphism, and let a' and β be an alternative lifting and natural
isomorphism. Set  φ = τ ° β-1. Then  Ct[_,a']  and  Ct[_,a°]  are naturally isomorphic via  φ  and, for
f = φa'(id): a'→a°  and  g = ( φa° )-1(id): a°→a', one has:
             g°f = ( φa° )-1(id)°f
= ( φa' )-1(id°f)
by naturality
= ( φa' )-1( φa'(id) )
= id.
Similarly for  f°g = id  (on  a°).
Since we are now familiar with functors, we may look also at lifting as a functor.

3. Functors and Natural Transformations
49
Let C be a pC and assume that for each  a∈ObC  there exists the lifting  a°. Then there is a (unique)
extension of the map  a |_  a°  to a functor  _° : C→Ct  (the lifting functor).
The reader may check this as an exercise (hint: observe that  exa = ( τa°)-1(id): a˚→a  and use the
naturality of  τ ) .
As for specific examples, the lifting functor for pSet is obvious. It can be easily guessed also for
the category pPo of p.o.sets and partial monotone functions with upward closed domains: just add a
fresh least element and the rest is easy for the reader who has completed the last exercise. Note, and it
is crucial, that by monotonicity the lifting functor does not exist if one doesn't assume that the
domains are upward closed.
The category pCPO is given by defining complete partial orders under the assumption that
directed sets are not empty.  Thus, the objects of pCPO do not need to have a bottom element.  As
for morphisms, take the partial continuous functions with open subsets as domains. Clearly, the
lifting functor is defined as it is for pPo.
A more complex example is given by EN, the category of numbered sets in section 2.2. Let
pEN be the partial category of numbered sets in the example before 2.5.2. Given a = (a,e)∈ObpEN,
define  a° = (a°,e°)  by adding a new element  ⊥  to the set  a  and by defining  e°(n) = if  φn(0)
converges  then  e(φn(0))  else  ⊥ . Clearly, e° : ω→a°  is surjective. Let now  b = (b,e')  and
f∈pEN[b,a]. By definition, there exists  f'∈PR  such that  f°e' =e°f'. We define the extension
f∈EN[b,a°] of  f  by giving  f'∈R  which represents  f . That is, set  φf'(n)(0) = f(n). Such an  f'∈R
exists by the s-m-n (iteration) theorem. Thus,
      f(e'(n)) = e°(f'(n))
= if  φf'(n)(0) converges  then  e( φf'(n)(0))  else  ⊥ .
Therefore, if  f(e'(n)) = e(f'(n))  is defined, then φf'(n)(0) converges and, hence,  f(e'(n)) =
e(φf'(n)(0)) = f(e'(n)). Finally, set  τab(f) = f . For each a, τa gives the required natural
isomorphism, as ∀g∈EN[b,a°] ∃!f∈pEN[b,a]  f'(n) = φg'(n)(0). (Exercise: check the due
diagram). By the fact above, this defines the lifting functor in pEN.
Exercise  Define the category ER of equivalence relations on  ω  and effective maps (hint: the
objects are quotient sets on  ω, and the morphisms are induced by total recursive functions similarly
as for EN). Observe that ER and EN are equivalent, but not isomorphic. Indeed, one is small, while
the other is not.
We next discuss ways to derive natural transformations from a given one and, finally, the notion of
horizontal composition.
Let  H: A→B,  F: B→C,  G: B→C,  K: C→D  be functors, and let  τ: F→G  be a natural
transformation as shown in the following diagram:

3. Functors and Natural Transformations
50
τ induces two natural transformations  Kτ: KF→KG,  and  τH: FH→GH,  respectively defined by
(Kτ)b = K(τb) : KF(b)→KG(b);
(τΗ)a = τH(a) : FH(a)→GH(a)
We have, for every  f∈B[b,b'] and every  g∈A[a,a'],
(Kτ)b'° KF(f) = K(τb) ° K(F(f)) = K(τb° F(f) ) = K(G(f) ° τb) = KG(f) ° Kτb = KG(f) ° (Kτ)b
(τH)a'° FH(g) = τH(a') ° F(H(g)) = G(H(g)) ° τH(a) = GH(g) ° (τH)a
that proves the naturality of  Kτ  and  τH .
Consider now categories, functors, and natural transformations as described in the following
diagram:
Then, for the naturality of  σ  with respect to the arrow  τb, the following diagram (in D ) commutes
for every b∈ObB:

3. Functors and Natural Transformations
51
The horizontal composition  of  σ  and  τ  is the natural trasformation  στ: HF→ΚG  defined by,
for every b∈ObB,  στb = σG(b) ° H(τb) = K(τb) ° σF(b).
We check the naturality of  στ .  Let  f∈B[b,b'] , then
στb' ° HF(f) = σG(b') ° H(τb') ° HF(f)
= σG(b') ° H(τb' ° F(f) )
= σG(b) ° H( G(f) ° τb )
by the naturality of  τ
= σG(b) ° H( G(f) ° τb )
by the diagram
= Κ(G(f) ° τb) ° σF(b)
= ΚG(f) ° K(τb) ° σF(b)
= ΚG(f) ° στb
Note that if we identify the functors  K  and  H  with the identity natural transformation  idK  and
idH,  Kτ  and  τH  may be understood as particular cases of the horizontal application between natural
transformations (why?).
Exercise  Prove the following equality among natural transformations (interchange law):
(ν ° µ)(τ ° σ) = (ντ) ° ( µσ) .
3.3 Cartesian and Cartesian Closed Categories Revisited
By definition, a category C is Cartesian  iff it contains a terminal object  t , and for every  a,b∈ObC
there is an object  a×b  together with two morphisms  p1: a×b→a , p2: a×b→b, and for every object c
an isomorphism  < , >c : C[c,a]×C[c,b]→C[c,a×b] such that for all morphisms  f: c→a, g: c→b, h:
c→a×b, the following equations hold:
i.   p1 ° <f,g>c = f
ii.  p2 ° <f,g>c = g
We want now to show that  < , >c  is also “natural in c”, i.e. it satisfies the property:
(nat)   for every  k: c→c'  <f,g>c' ° k = <f ° k, g ° k >c
Indeed, we have    <f,g>c' ° k = <p1 ° <f,g>c' ° k, p2 ° <f,g>c' ° k >c
by  ii)
= < f ° k, g ° k >c  
by  i)
The previous “naturality” property suggests that  < , >  is actually a natural isomorphism. Indeed, let
∆: C→C××××C  the functor defined by  ∆(c) = (c,c),  ∆(f) = (f,f)  (∆ is called the diagonal functor);
then < , > is a natural isomorphism from  C××××C[_,(a,b)] ° ∆  to  C[_,a×b]. Note that  C××××C[_,(a,b)] °
∆  and  C[_,a×b]: C→Set  are contravariant functors.  Conversely  suppose to have for all objects  a
and  b  an  object  a×b  and a natural isomorphism  τ : C××××C[_,(a,b)] ° ∆ ≅ C[_,a×b]. The naturality
of  τ-1  is expressed by the following commutative diagram:

3. Functors and Natural Transformations
52
Let  (q1,q2) = τ-1a×b(ida×b) .  Note that  q1: a×b→a, q2: a×b→b .  We want  to prove that  a×b  is a
product with projections q1  and  q2. Indeed, let  f = τc(h,g): c→a×b  in the above diagram, then we
have  (q1,q2) ° ( τc(h,g), τc(h,g) ) =  τ-1c(ida×b ° τc(h,g) ) = (h,g)  and, in particular,  q1 ° τc(h,g) =
h ;  q2 ° τc(h,g) = g .
The previous considerations suggest another characterization of Cartesian Category:
3.3.1 Proposition  A category C is Cartesian iff it contains a terminal object t, and for every
a,b∈ObC  there is an object  a×b  and a natural isomorphism  < , > : C××××C[_,(a,b)] ° ∆ → C[_,a×b].
The situation is quite similar, and perhaps even simpler, in the case of exponents. Remember that a
category C is a CCC iff it is Cartesian and has exponents for every pair of objects, i.e. for every  a
and  b  in C there is an object  ba  together with a morphism evala,b: ba×a→b (evaluation map) and,
for every object  c , a function Λc : C[c×a,b]→C[c,ba]  such that, for all morphisms  f: c×a→b,  h:
c→ba,  one has
β.  evala,b ° (Λ(f)×ida) = f
η.  Λ(eval°(h×id)) = h
It turns out that  Λc  is “natural in c”, in the sense that for any  f∈C[c×a,b],  g∈C[d,c]
Λc'(f) ° g = Λc(f ° g×id) ,
In order to check this, recall that  (β)  corresponds to:
Thus, by twice (Diag.Eval), the following diagram commutes

3. Functors and Natural Transformations
53
Moreover, set  Λ-1 = eval°(_×id).
Then
Λ-1°Λ = id
by (β)
and
Λ°Λ-1 = id
by (η).
That is, for each  c∈ObC, Λc: C[c×a,b]→C[c,ba]  is an isomorphism. Thus  Λ  is a natural
isomorphism, by proposition 3.2.3.
Note that, formally,  Λ  is a natural transformation from the contravariant functor  C[_,b] ° _×a
to the contravariant functor  C[_,ba]  (where  _×a  is the product functor defined in the obvious way).
We abbreviate  C[_,b] ° _×a   as  C[_×a,b].  Note also that  C[_×a,b], C[_,ba]: C→Set.
Conversely, suppose that, for all objects  a  and  b, there is an  object  ba  and a natural
isomorphism  Λ: C[_×a,b] ≅ C[_,ba]. Then the naturality of  Λ -1  is expressed by the following
commutative diagram:
Set now  evala,b = Λ-1ba (idba)  and note that  evala,b: ba×a→b .  We want  to prove that  ba  is an
exponent with  evala,b  as evaluation map . Indeed, let  f = Λc(g): c→ba  in the above diagram.  Then
we have:
evala,b ° ( Λc(g)×id ) =  Λ-1c(idba ° Λc(g) ) = g
This argument gives the following equivalent characterization of CCC:
3.3.2 Proposition  C is a Cartesian closed category iff it is Cartesian and for every
a,b∈ObC  there is an object  ba  and a natural isomorphism   Λ : C[_×a,b]  → C[_,ba] .

3. Functors and Natural Transformations
54
Observe that definitions 3.3.1 and 3.3.2 require that the category C be locally small, since they are
based on  hom-functors. Thus, in a sense, the equational definition is more general.
3.3.3 Remark  It is easy to prove that the following (natural) isomorphisms hold in all CCC’s, for
any object  A, B, and C:
1.  A ≅ A;
2.  t×A ≅ A;
3.  A×B ≅ B×A;
4.  (A×B)×C ≅ A×(B×C);
5.  (A×B)→C ≅ A→(B→C);
6.  A→(B×C) ≅ (A→B)×(A→C);
7.  t→A ≅A;
8.  A→t ≅ t.
What is worth mentioning, though, is that these are exactly the isomorphisms that hold in all CCC’s,
i.e., no other isomorphism is valid in all CCC's.  The proof of this fact is nontrivial and is a nice
application of lambda calculus to categories (an application in the other direction from what is meant
by the title of this book!). Its key idea will be mentioned in chapter 9.
3.4 More Examples of CCC’s
Both examples here derive from bordering areas of (generalized) computability and Proof Theory.
The first, in particular, like many aspects of these theories, is widely used in the type theoretical
understanding of programming languages constructs.
3.4.1 Partial Equivalence Relations
A very relevant example of CCC is suggested by a long story. It began with Kleene’s realizability
interpretation of intuitionistic logic and continued with the work of Kreisel, Girard and Troelstra in
Proof Theory. The idea is to look at functions as computable ones, as in the case of the category EN,
but by a simple and insightful way cartesian closedness is obtained. The approach is also used in the
“quotient-set” semantics of types, in functional programming. It will give us a paradigmatic structure
in the categorical semantics of polymorphism in PART II.
As usual, let  ϕ: ω→PR  an acceptable goedel numbering of the partial recursive functions. Let
K = (ω,.)  be Kleene's applicative structure, where  . : ω×ω→ω  is the partial application
defined by:  m.n = ϕm(n) .  A partial equivalence relation   R  on a set  V  is a symmetric and
transitive relation, not necessarely reflexive, on  V.
(Notation:  n R m  iff  n  relates to  m  in  R;  {p}R = {q |  q R p} ;  Q(R) = {{p}R |  p R p }) .

3. Functors and Natural Transformations
55
3.4.1.1 Definition The category PER of partial equivalence relations on  ω  has as objects the
symmetric and transitive relations on  ω.  Morphisms are defined by
f∈PER[A,B]   iff   f : Q(A) → Q(B)  and  ∃n  ∀p  (pAp  ⇒  f({p}A) =  {n.p}B ) .
Thus, the morphisms in PER are “computable” because they are fully described by partial
recursive functions, which are total on the domain of the source relation.
Let now  < , >: ω×ω→ω  be an effective and bijective pairing. For  A,B∈ObPER , the product
A×B  is defined by
∀m,n,m',n'  <m,n> A×B <m',n'>   ⇔  ( m A m'  and  n B n').
It is easy to check that this actually defines a product functor in PER.
The exponent object  BA  is defined by
∀m,n,   m (BA) n   ⇔   ∀p,q  (p A q  ⇒  m.p B n.q ) .
Cartesian closedness follows by giving a natural isomorphism  Λ : PER[A×C,B] ≅ PER[A,BC].
Let  s  be the recursive function of the s-m-n (or iteration) theorem, i.e.  ϕs(n,p)(q) = ϕn(p,q). Then
set  Λ(f)({p}A) = {s(n,p)}C→B, where  n  is an index for  f. In other words  {n.<p,q>}B =
{s(n,p).q}B. Observe that  Λ  is a well-defined function from  PER[A×C,B]  to  PER[A,BC], since
s  is computable and, then, any index for the recursive function  p |_ s(n,p), computes
Λ(f)∈PER[A,BC]. As for the naturality of  Λ , one may prove it by the argument above, which also
gives some information on the evaluation map.
Let  evalA,B:  BA×A→B  be defined by  eval( {<m,n>}BA×A ) = {m.n}B.
In order to prove that  evalA,B  is a morphism in the category we must find  eA,B∈ω  such that
eval({<m,n>}BA×A ) = {m.n}B =  {eA,B.(<m,n>)}B
Let  u  be the “universal” function, i.e., the partial recursive function such that  u(<m,n>) = m.n , and
let  e  be an index for it, i.e.,  u = ϕe.  It is easy to observe that one can set  eA,B = e  for all  A, B  in
ObPER, since
{e.(<m,n>)}B = {u(<m,n>)}B = {m.n}B .
Then, (β) is simply
eval({<s(n,p),q>}BA×A ) = {n.<p,q>}B,  by definition of  s .
Similarly for (η).
3.4.2 Limit and Filter Spaces
There is an elegant, unifying way to understand the various approaches to generalized computability
proposed in the 60’s and 70’s.  The connecting point is the  construction of categories of sets where a
suitable notion of limit gives an abstract notion of computability. The idea is to generalize the
technique used when defining the computable elements in Scott domains D (see 2.4.1), in the way
explained below (in short, the computable elements are the limits of recursively enumerable indexed

3. Functors and Natural Transformations
56
sequences.) This suggests several CCC's, such as limit spaces (L-spaces) and filter spaces (FIL)
with their relevant subcategories. They will be introduced here and discussed also in the examples in
section 5.3 and section 8.4, toghether with other ideas for higher type computations.
3.4.2.1 Definition A limit space (L-space) (X,↓) is a set  X  and a relation (convergence)
between countable sequences  {xi}i∈ω ⊆ X  and elements  x∈X  (notation: {xi}↓x)  such that
1.  if all but finitely many  xi  are  x,  i.e., {xi}  is eventually  x, then  {xi}↓x;
2.  if  {xi}↓x  and  k(0) < k(l) < . . . < k(n) < . . . ,  then  {xk(i)}↓x;
3.  if  not({xi}↓x), then there is  k(0) < k(l) < . . . < k(n) < . . .  such that for no subsequence
h(0) < h(l) < . . . < h(n) < . . .   one has  {x(i)}↓x.
An L-space  (X,↓)  has a countable basis (is separable) iff for some given countable  Xo ⊆ X,
∀x∈X  ∃{xi}⊆Xo  {xi}↓x.
From now on we assume that each countably based L-spaces  (X,↓)  comes with a given
surjective enumeration  e: ω→Xo  of the base. An immediate example of separable L-spaces is the set
of real numbers endowed with the usual notion of sequence converge (Cauchy).
3.4.2.2 Definition The hom-set  L[X,Y]  between L-spaces  (X,↓)  and  (Y,↓)  consists of all
continuous functions, i.e.,
f∈L[X,Y]   iff   ∀x∈X  ∀{xi}↓x  {f (xi )}↓f (x),
where convergence is given in the intended spaces.
This category has exponents and products, as  (L[X,Y],↓)  also is an L-space by
{fi}↓f   iff   ∀x∈X, ∀{xi}↓x  {fi(xi)}↓f(x) ,
while products are given by componentwise convergence.
Finally, eval: L[X,Y]×X→Y, with  eval(f,x) = f(x), is continuous. As a matter of fact,
(L[X,Y],↓) is the coarsest limit structure (i.e., with more converging sequences) such that  eval  is
continuous.
One can also show that if  (X,↓)  and  (Y,↓)  are separable, then also  (L[X,Y],↓)  is separable.
Indeed, L-spaces and separable L-spaces, with continuous maps as morphisms, form Cartesian
closed categories.
Yet another CCC of limit spaces may be given by the Moore-Smith net-convergence or,
equivalently, by filter-convergence. Just recall that a filter  Φ  (on a given set X) is a set of (sub)sets
closed by intersection and such that  A∈Φ  and  A ⊆ B  imply  B∈Φ  (e.g., the collection of subsets
of  A  which contain a given  x∈A  is the (ultra)filter generated by  x). A filter base is a non empty
collection of non empty subsets of  X  such that  A∈Φ  and  B∈Φ  imply  ∃C∈Φ  C ⊆ A∩B. A filter
base  Φ  generates a unique filter  [Φ] = {Β ⊆ X  |  ∃A∈Φ  A ⊆ B}. Define then

3. Functors and Natural Transformations
57
3.4.2.3 Definition  (X, F) is a filter space iff  ∀x∈X  F(x)  is a filter of filters such that the
ultrafilter generated by  x  is in  F(x).  Given a filter base  Φ , we write  Φ↓x  iff  [Φ]∈F(x) .
Exercise  Prove that the category FIL of filter spaces with continuous maps (where  f  is
continuous iff  Φ↓x  implies  f(Φ)↓x)  is a CCC.  Give a full and faithful functor  F : FIL→L-
spaces.  (Hint: a filter structure on  FIL[X,Y]  is given by   Ξ↓f  iff  Φ↓x  implies  Ξ(Φ)↓f(x),
where  Ξ(Φ)  is the set of all  W(U)  with  W∈Ξ  and  U∈Φ  and  W(U) = ∪{f(U) | f∈W};
moreover, given a filter  Φ  and a sequence {xi}, define  Con(Φ,{xi})  iff  ∀U∈Φ  ∃k  ∀n≥k  xn∈U
and set  {xi}↓x  iff  ∃Φ↓x Con(Φ,{xi}) ).
A notion of separable filter space is easily given, by taking a countable base of filters (i.e., a
countable collection of sets such that each converging filter is generated by elements of the base).
Clearly, each (separable) topological space  (X, top)  may be turned into a (separable) filter space:
just take, for each point  x , the collection  F(x)  of all filters containing the filter of neighborhoods of
that point. The reader will have a better insight into the “injections”
Top  →  FIL  →  L-spaces
when looking at examples of adjunctions, in section 5.3. As for now, it may suffice to say that there
exist filter spaces whose limit structure is not topological. Some of these filter spaces are among those
needed for the study of the total computable functionals.
In the very general setting of L-spaces we can now hint a notion of computability which
specializes to the one given over Scott domains, when the intended limit structure is derived from the
Scott topology.
Let  R  be the total recursive functions and  (X, X0, e, ↓)  a separable L-space, where  e  is a
given enumeration of the base  X0.  Define then, in a slightly incomplete way (see the comment
below), the collection  Xc ⊆ X  of computable elements by x∈Xc  iff  ∃f∈R  {ef(i)}↓x.
In other words, given a countably based limit structure, an element is computable (or recursive) when
it is the limit of a countable sequence indexed over an r.e. set.
Comment  L-spaces actually carry too little structure to yield a good definition of “recursive” just by
taking arbitrary limits of recursively enumerable converging sequences. Their simplicity and
generality, though, should give an immediate intuition of what is going on. Indeed, the technique in
the definition of computability tidily borrows from similar methods in mathematics. Consider, say,
“smooth manifolds.” They are defined on the base of the familiar notion of differentiability in  Rn,
which is extended by a system of local coordinates to abstract spaces. Similarly here, one takes for
granted the recursive functions and extends computability to an abstract setting (and higher types, in

3. Functors and Natural Transformations
58
particular) by “local” properties of convergence as in the equation above. As we shall see later, too,
the categorical language relates and unifies the various classes of structures where this is done.
L-spaces suggest how to express computability by limits very simply; however, the weakness of
these structures is that limits are far away from being uniquely determined and that there is no
obvious way to characterize “interesting” sequences and limit points.
The point then is to take only “some” limits. This is done by directed sets in Scott domains (see
2.4.1), which are particular converging sequences with a privileged limit, the least upper bound. It
will be described for FIL in the examples at the end of section 5.3.
3.5 Yoneda's Lemma
Let C be a Cartesian closed category. Let  F = C××××C[_,(a,b)] ° ∆ : C→Set, G = C[_×a,b]: C→Set.
In §3.3 we proved that for both  F  and  G  there exists an object, respectively called  a×b  and  ba,
such that   F ≅ C[_,a×b]  and  G ≅ C[_,ba].  In general, functors which enjoy this property are
called (co-)representable. The formal definition, in case of covariant functors, is the following
(note that  F  and G  are contravariant; we leave as an exercise for the reader to derive the dual
definition) :
3.5.1 Definition  A functor K:  C→Set  is representable iff there exist an object  r  in C  and a
natural isomorphism  φ: K ≅ C[r,_].
Exercise Give another definition of  CC  and  CCC  by using the previous notion.
Note that, if  K: C→Set, every natural transformation  ϕ: C[r,_]→K  is fully determined by the
image of the identity  idr . Indeed, for every  f∈C[r,d],  ϕd(f) = ϕd(f ° idr) = K(f) ° ϕr(idr) , by the
following diagram:
3.5.2 Lemma  (Yoneda)  Let  K: C→Set  be a functor. The map  ψr,K: Nat(C[r,_], K)→K(r)
that takes every natural transfomation  ϕ: C[r,_]→K  to  ϕr(idr)∈K(r)  is an isomorphism.
Moreover, it is natural in  r  and  K , that is,

3. Functors and Natural Transformations
59
( where  C[f,_] : C[d,_] → C[r,_]  is the natural transformation defined by  C[f,_]c = C[f,c] = _° f :
C[d,c]→C[r,c]; see example 3.3.2 ), and
Proof  By the Yoneda diagram above and a routine verification of the commutativity of the diagrams
in the definition. ♦
If we take  K  in the previous lemma to be  C[d,_],  where  d  is a generic object in C, this results in
the statement that there is a natural bijection between arrows g∈C[d,r] (that is, elements in
C[d,_](r)) and natural transformations from  C[r,_]  to  C[d,_].
3.5.3 Proposition (Yoneda embedding)
i.  Let  Y  be the map which takes every  r∈ObC  to the hom-functor  C[r,_], and every  g∈C[d,r]  to
the natural transformation C[g,_]: C[r,_]→C[d,_]  defined by  C[g,_]c = C[g,c] = _° g :
C[r,c]→C[d,c].  Then  Y  is a full embedding from  Cop to  Funct(C,Set) .
ii.  Let  Y  be the map which takes every  r∈ObC   to the hom-functor  C[_,r] , and every  g∈C[d,r]
to the natural transformation  C[_,g]: C[_,d]→C[_,r]   defined by   C[_,g] c = C[c,g] = g ° _ :
C[c,d]→C[c,r] .  Then  Y  is a full and faithful covariant functor from C  to  Funct(Cop,Set).
Proof  We prove only (i), since the other proof is dual.
Y(idr) = idC[r,_]  is immediate. Given  g∈C[d,r], f∈C[s,r], Y(f°g): C[s,_]→C[d,_]  is defined
as follows:  for every  c∈ObC   Y(g °f)c = _° f ° g : C[s,c]→C[d,c].  Y  is a functor, as, for every
h∈C[s,c],
                 Y(g ° f)c(h) =  h ° f ° g
 
=  Y(g)c(f ° h)
=  Y(g)c( Y(f)c(h) )

3. Functors and Natural Transformations
60
=  ( Y(g)c ° Y(f)c )(h).
The fact that  Y  is full and faithful follows, as already observed, from the Yoneda lemma with
C[d,_]  instead of  K. ♦
3.6 Presheaves
In the last section we proved that every small category  C  is isomorphic to a full subcategory of
Funct(C op,Set) through the Yoneda embedding Y. For its relevance, the category
Funct(Cop,Set)  has its own name: a functor  F: Cop→Set  is called presheaf on C, and
Funct(Cop,Set)  is the category of presheaves on  C.
The category of presheaves inherits many interesting properties from Set, and in particular it is
itself a topos. For the moment, we only prove the following properties:
3.5.1 Theorem  Given a category C, the category of presheaves on C has pullbacks for every pair
of morphisms and is Cartesian closed.
Proof. The terminal object is the functor  T : Cop→Set, which takes every object  c  in ObC  to the
single set {*} and every arrow to the identity on this set.
Given two natural transformations  η: F→H  and  τ: G→H , their pullback is defined objectwise:
for every  c in ObC  let  (π1,c: Xc→F(c), π2,c: Xc→G(c)  )  be the pullback in Set  of  ηc:
F(c)→H(c)  and  τc: G(c)→H(c) .  Then define a functor   X: Cop→Set   where  X(c) = Xc , and
for every  f:c→d, X(f)  is the only arrow that makes the following diagram commute:
In the same way we define two natural transformations  π1: X→F, π2: X→F, where for every  c  in
ObC,  π1(c) = π1,c  and π2(c) = π2,c.  Then it is easily verified that  ( π1: X→F, π2: X→F )  is the
pullback of  η: F→H  and  τ: G→H.

3. Functors and Natural Transformations
61
As always, the pullback of two functors  F  and  G  on the terminal  T  gives the product  F×G. It
is easy to verify that  F×G(c) = F(c)×G(c)  and  F×G(f) = F(f)×G(f).
Exponents are defined by using the Yoneda lemma.
If  GF is the exponent of  F  and  G, we must have an isomorphism  Nat[H×F,G] ≅ Nat[H,GF]
for every  H. In particular, if  H  is  C[_,c], and since by the Yoneda lemma, Nat[C[_,c],K] ≅ K(c)
for every  K, we have:  Nat[C[_,c]×F,G] ≅ Nat[C[_,c],GF] ≅ GF(c). Thus, we define  GF(c) =
Nat[C[_,c]×F,G].
Given an arrow  f: c→d, we must now define  GF(f): Nat[C[_,d]×F,G]→Nat[C[_,c]×F,G].
Let  σ  be a natural transformation from  C[_,d]×F  to  G; then  GF(f)(σ)  must be a natural
transformation from C[_,c]×F  to  G. We define  GF(f)(σ) = σ ° C[_,f]×idF  (see example 3.2.2  for
the definition of the natural transformation  C[_,f] :  C[_,c]→C[_,d] ).
GF is a functor, indeed  GF(id)(σ) = σ. Moreover :
                     GF(f ° g)(σ) = σ ° C[_, f ° g]×idF
= σ ° C[_,f]×idF ° C[_,g]×idF
= GF(g)(σ ° C[_,f]×idF )
= GF(g)(GF(f)(σ)).
Let us define the natural transformation of evaluation  εF,G: GF×F→G. For every  d in ObC,
εF,G(d): Nat[C[_,d]×F,G]×F(d)→G(d)  is defined by  εF,G(d)(σ,n) = σ(d)(idd,n).
We prove now that for any  H: Cop→Set we have an isomorphism  Θ: Nat[H×F,G] ≅ Nat[H,GF].
Let  τ: H×F→G  be a natural transformation.  For any  c  in ObC, Θ(τ)(c)  ought to be a function
from  H(c) to GF(c) = Nat[C[_,c]×F,G]. By the Yoneda lemma, we have for every  c  in  ObC  an
isomorphism  γc: Nat[C[_,c],H] ≅ H(c); thus,  if m∈H(c),
γc-1(m)∈Nat[C[_,c],H]
τ ° (γ-1(m)×idF) ∈Nat[C[_,c]×F,G].
Define then  Θ(τ)(c) = λm. τ ° ( γc-1(m)×idF): H(c)→GF(c) = Nat[C[_,c]×F,G].
We must prove that, for every  τ: H×F→G, µ: H→GF,
1.   εF,G ° (Θ(τ)×idF) = τ
2.  Θ(εF,G ° (σ×idF)) = σ
For (1) we have, for every d∈ObC, m∈H(d), n∈F(d), the following:
(εF,G(d) ° (Θ(τ)×idF)(d))(m,n) =
= εF,G(d) (Θ(τ)(d)(m),n)
= εF,G(d) ( τ ° (γd-1(m)×idF),n)
by def. of Θ
= (τ ° (γd-1(m)×idF))(d)(idd,n)
by def. of εF,G
= τ (d)(m,n)
as  (γd-1(m))(d)(idd) = m
For (2) we have, for every  d∈ObC, m∈H(d), c∈ObC, h∈C[c,d], n∈F(d), the following:
(Θ(εF,G ° (µ×idF))(d)(m)(c)(h,n) =
= (εF,G ° (µ×idF) ° (γd-1(m)×idF))(c)(h,n) 
by def. of Θ

3. Functors and Natural Transformations
62
= εF,G(c) ( (µ×idF)(c)( γd-1(m)(c)(h), n ) )
= εF,G(c) ( (µ×idF)(c)( H(h)(m), n ) 
by def of γd-1
= εF,G(c) (µ(c)(H(h)(m)), n)
= µ(c)(H(h)(m))(c) (idc,n)
by def. of εF,G(c)
= GF(h)(µ(d)(m))(c) (idc,n)
by naturality of  µ
= (µ(d)(m) ° C[_,h]×idF) (c)(idc,n)
by def. of GF(h)
= (µ(d)(m)(c) ((C[c,h]×idF(c))(idc,n))
= (µ(d)(m)(c)(h,n). ♦
References  We only give some references for the examples we mentioned, as they are not
usually presented in other books and are mostly endebted to the theory of computing.  Partial
equivalence relations as a model for higher type computations were given in Kreisel (1959) and later
applied to the semantics of higher order intuitionistic logic in Girard (1972) and Troelstra (1973c).
They recently came again to the limelight as relevant structures for the semantics of polymorphism in
functional languages (see chapter 12).  Limit spaces and their closure properties can be found in
Kuratowski (1952).  With our perspective, filter spaces are used in Hyland (1979).
For (pre)sheaves and related notions, the reader should consult the previous references for Topos
Theory (as well as Fourman (1977) and Lambek and Scott (1986), among others).  See also Scott
(1980) for an application of Yoneda’s embedding of arbitrary CCC’s (and their reflexive objects, if
any) into topoi of presheaves.

4. Categories Derived from Functors and Natural Transformations
63
Chapter 4
CATEGORIES DERIVED FROM FUNCTORS AND
NATURAL TRANSFORMATIONS
This chapter has two main motivations. One derives from the use of algebraic methods in computer
science, the other from recent developments in (applied) Proof Theory. The two research directions
are brought together nicely by the underlying categorical structures, which tidily generalize two
constructions crucial form the perspective of this book namely, products and exponents. Here, they
will be discussed in the context of monoidal and monoidal closed categories.
As already mentioned, geometry and algebra provided the background and motivations for the
early developments of Category Theory. In these areas, Category Theory often suggested both a
unified language and effective tools for an abstract description or specification of mathematical
structures. This method, which is typical of the categorical approach, has been widely explored in
computer science, in connection with ideas from universal algebra. The point is that, before
performing a complicated task, a programmer needs a clear specification of it.  This may be given, for
example, by a set of equations, or by a logical system, or also by declarations of types (or sorts) and
operations on them. Inference rules may specify a theory.
This abstract approach, in computer science as well as in mathematics, is meant to simplify the
work for a concrete implementation, since only the essential or desired aspects of a task, a problem,
or a mathematical structure are focused on and dealt with. Unstructured lists of goals or properties are
hard to understand, are prone to errors, and may hide the core of the issue.
As we shall recall in section 4.1, algebras are usually described as sets with operations.  Now
(binary) operations need some kind of “product” on the carrier sets to be specified or typed, e.g., a
group operation  “.”  is  .: G×G→G. However,  “×”  does not need to be the familar Cartesian
product, as several relevant examples may be given by using (binary) functors that do not need to
possess projections. One may then ask whether these functors may relate to suitable exponents, in a
way that is similar for CCC’s. This further step will take us to the natural (and fruitful) generalization
of CCC’s as monoidal closed categories and will relate the algebraic perspective to the “functional”
one, which permeates this book.
4.1 Algebras Derived from Functors
An algebra is a set, or carrier, together with a family of functions, or operations, on the carrier.
One may define categories of algebras by taking, as morphisms, well-behaved functions, the
homomorphisms, between algebras of the same kind.

4. Categories Derived from Functors and Natural Transformations
64
More precisely, let  Ω  be a set of operator symbols indexed by their arities.  Ωn , say, is the set
operators of arity  n .
4.1.1 Definition The category AlgΩΩΩΩ , of  ΩΩΩΩ-algebras, has as objects pairs  (A,α), where  A  is a
carrier set and, for each  n  and each operator symbol  ρn ∈Ωn, α  yields a function  αρ : An→A.
An morphism  f  from  (A,α)  to  (A',α')  is a function  f: A→A  such that
f(αρ(a1, . . . ,an)) = α'ρ(f(a1, . . . ,f(an))
for all  n, ρn∈Ωn  and  a1, . . . ,an∈A .
For example, any monoid  (A,.)  is an Ω-algebra, with a binary operation on a carrier set  A.  As an
instance of this, take Kleene's  (PR,°),  i.e., the monoid of the partial recursive functions, is an Ω-
algebra over PR, as carrier, with the binary operation of composition, as operation.
Remark   (Commutative) monoids provide the basic instances of linear and multilinear algebra. In
particular, there is a tensor product  A⊗B  of commutative monoids that can be characterized by a
universal bilinear map  µ: A×B→A⊗B  such that for each bilinear  f: Α×Β→C, there is a unique
monoid homomorphism  g: A⊗B→C  such that  f  = g ° µ . This idea, as well as the generality of
monoids, provide the basic mathematical intuition for the categorical notions developed in this
chapter.
One may specify more, though. For example, over (PR,°) one may require the existence of
distinguished functions, such as constants for the identity, the successor and everywhere constant
functions. The behavior of these elements is specified by a set of well-known equations.
In general, this technique defines a class of Ω-algebras, called a variety.  Varieties form full
subcategories of the intended category AlgΩΩΩΩ.
A well-known generalization of Ω-algebras is given by the many sorted, or heterogeneous, case.
That is, the operators are specified over more than one carrier. The applications of these notions are
nowadays a broadly construed area in computer science. However, until now, they have been more
indebted to universal algebra and Abstract Model Theory than to Category Theory (see the
References).
Example  A stack is made out of finite words over a set  el  of elements  A ∪ {error} .  Let  {tt, ff}
be the boolean values and  A*  the finite words on  A .  The following signature specifies a stack as a
many sorted algebra with sorts el, stack, bool, and operators:
push : stack el → stack;
pop : stack → stack;
top : stack → el;

4. Categories Derived from Functors and Natural Transformations
65
iserrel : el → bool;
iserrstack : stack → bool;
For variables  x: stack  and  e: el, one has to set the following:
empty = λ
push(x,α) = “if  x∈A  and  α∈A*  then  xα  else  error ”
pop( xα ) = “if  x∈A  and  α∈A*  then  α  else  error ”
top( xα ) = “if  x∈A  and  α∈A*  then  x  else  error ”
iserrel(error) = tt
iserrstack(error) = tt
A few more equations specify the behavior of “iserr . . . ” on elements and the stack, in the obvious
way.
Observe now that a set  Ω  of operators determines a functor  T: Set→Set  defined by
T(A) = {ρ(a1, . . . ,an) |  n∈ω, ρ∈Ωn, a1, . . . ,an∈A}.
Then an ω-algebra  (A,α)  determines a set-theoretic function   f : F(A)→A  by
f(ρ(a1, . . . ,an)) = αρ(a1, . . . ,an).
This informal remark suggests another generalization of the notion of Ω-algebra.  Ω-algebras are
based on carriers as sets; we may obtain a more category-theoretic description of the general concept
of algebra by taking endofunctors over arbitrary categories, instead of  T: Set→Set .
4.1.2 Definition  Let  C  be a category and  T: C→C  be an endofunctor. The category  T-alg of
T-algebras is defined as follows: the objects of T-alg are the pairs (c,α) with c∈ObC and
α∈C[T(c),c]; the arrows between two objects  (c,α)  and  (c',α')  are all the arrows h∈C[c,c'] such
that  α'° T(h) = h ° α . Graphically,
Identities and composition are both inherited from C.
Thus Ω-algebras are T-algebras for  T: Set→Set, but T-algebras, in general, are defined over
categories of structured data, not just sets. One may take, for example, a collection of data types
which form a category C and include the type  p  of programs, over those data types, as object.  Then

4. Categories Derived from Functors and Natural Transformations
66
T: C→C  and  α:T(c)→c,  given by  T(c) = p×c  and  α(i,x) = “apply program  i  to input  x ” give a
T-algebra  (c,α) , for each object  c (see example 1, after definition 4.2.3).
Consider now a preorder  (P,≤)  as a category. A functor  T: P→P  is a monotone function.  In
this setting, a T-algebra is a prefixed point for the functor  T  as the mere existence of  α:T(e)→e
corresponds to  T(e) ≤ e, which means exactly that  e  is a prefixed point for  T.  Recall also that the
least  prefixed point of a monotonic function, if it exists, is always the least fixed point as well. This
property has the following correspondent in Category Theory:
4.1.3 Proposition  Let  C  be a category and  T: C→C. If  (c,α)  is an initial T-algebra, then  α  is
an isomorphism from  T(c)  to  c  in  C.
Proof  Consider the following commutative diagram
(T(c),T(α))  is a T-algebra, and  α∈T-alg[(T(c),T(α)),(c,α)]. Let  η∈T-alg[(c,α),(T(c),T(α))]  be
the unique morphism given by initiality. Then α°η and idc are both morphisms in T-alg[(c,α),(c,α)]
and by initiality they must be equal. Moreover,
           η ° α = T(α) ° T(η)
as η∈T-alg[(c,α), (T(c),T(α))]
= T(α ° η)
since T is a functor
= T(idc)
= idc
since T is a functor. ♦
We can now go a step further and extend T-algebras to a more general notion, based on functors that
share only the target category, instead of endofunctors. This further step may be understood in a very
abstract way. Look at the diagrams for definition 4.1.2 and generalize them by using, in the lower
line, new objects  d, d', say, instead of  c, c',  and a different functor instead of the (implicit) identity
functor. This gives comma categories, which we denote by  (F↓G)  instead of the frequently used
(F,G).
4.1.4 Definition  Let  F: C→A,  G: D→A  be functors. The comma category  (F↓G)  is
defined as follows: the objects of  (F↓G)  are the triples  (c,f,d)  with  c∈ObC, d∈ObD,
f∈A[F(c),G(d)]; the arrows between two objects  (c,f,d)  and  (c',f',d')  are all the pairs  (h: c→c',k:
d→d')  such that   f' ° F(h) = G(k) ° f . Graphically,

4. Categories Derived from Functors and Natural Transformations
67
The identity of  (c,f,d)  is  (idc, idd); composition is defined componentwise, that is, (h',k') ° (h,k) =
(h'° h, k'° k).
Observe that by this further abstraction, we hit upun a notion examined in another context.  Indeed, if
a  is an object of  C,  and  Ka: C→C  is the constant functor taking every object to  a, and every
morphism to  ida, then  (Ka↓idC)  is just the category of objects over  a, or slice category, mentioned
in definition 1.3.4.
4.1.5 Example  A (possibly finite) graph G is a triple  (T,∂,V), where  T  is a set of arcs (or
edges),  V  a set of nodes, and  ∂: T→V×V  a function that gives the source and target of each arc.  A
morphism  h  from  G  to  G'  is a pair of functions  <f,g >,  f: T→T'  and  g: V→V'  such that
g ° p0 ° ∂ = p0 ° ∂'° f   and
g ° p1 ° ∂ = p1 ° ∂' ° f ,
where  p0  and  p1  are the projections.
This, with the obvious componentwise composition of morphisms, defines the category  Graph.
Graph is a comma category  (Id↓∆)  defined by the identity and the diagonal functors  Id, ∆:
(Fin)Set→(Fin)Set.
Exercises
1.  Prove that Graph is cartesian.
2.  Observe that a category is a graph with some extra structure: identities for each object (node) and
composition for morphisms (arcs) of the due types.  Give a (forgetful) functor from Cat, the category
of small categories, to Graph.  Is this functor full?
4.2 From monoids to monads
Consider again a monoid (A,.,e), i.e., a carrier A, a binary associative operation and a (specified) left
and right identity for “.”.
The monoid may be described as the set  A  together with two functions  µ: Α×A→A  and
η:1→A, where  1  is the singleton set (or terminal object in Set). The idea is that  µ  describes the

4. Categories Derived from Functors and Natural Transformations
68
internal operation  “.”  and  η  picks up the identity in  A.  Associativity of the application and the
properties of the identity are given by the following commutative diagrams:
A
A2
A2
A3
idx µ
µ
µ
xid
A2
µ
A
xid
η
η
idx 
Ax1
1xA
iso
iso
The abstract specification of monoids above can be generalized in several ways. We consider here the
case where functors are used as carriers, instead of sets.  To this purpose, recall that each endofunctor
T: C→C  has composition  Tn+1=Tn°Τ: C→C.  Moreover, if  µ: T2→Τ  is a natural
transformation, whose components are  µc: T2c→Τc  for every  c∈ObC,  then  Tµ: T3→Τ2  and
µΤ: T3→Τ2  are the natural transformations obtained by horizontal compositions, as in section 3.2.
Their components are  (Tµ)c = T(µc): T3c → Τ2c  and  (µT)c = µTc: T3c → Τ2c , respectively.
The idea is that an endofunctor of a category forms a monoid when the product of sets above is
interpreted as a composition of functors.
4.2.1 Definition A monad over a category  C is a triple  (T, µ, η), where   T: C→C  is a functor,
µ: Τ2→Τ  and  η: Idc→T  are natural transformations, and the following diagrams commute:
2
2
T 3
µ
µ
µ
2
µ
η
η
id
id
T
T
T
T
T
T
T
T
T
T
T
T
T
µ
As in the case of monoids over a set,  η  and µ  give the identity and the internal operation. The
diagrams describe the behaviour of the (left and right) identity and associativity.
Remark Many other names have also been used in literature in place of “monad”: the most common
is “triple,” but sometimes, you will find “triad” or “standard construction.” See Barr and Wells
(1985) for an interesting account of the history of this name.
Examples
1.  Let  M  be a monoid and define  T: Set→Set  by  T(A)=M×A, T(f)=idM×f.  Let  ηA: A→M×A
and  µA: M×M×A→M×A  be, respectively, the functions that take  a  to  (1M,a)  and  (m,n,a)  to
(mn,a). Then the associative and unarity identities follows from those of  M .

4. Categories Derived from Functors and Natural Transformations
69
2.  Let  T  be the covariant power-set functor, i.e., T: Set→Set  as given by  T(A) = P(A), the
powerset of  A , and T(f)(B) = {f(a) | a∈B ⊆ A}  as the image of  B  along  f .  Then  ηA  is the
singleton map  ηA(a) ={a}  and  µA  is the union map  µA(B) = ∪B. As for the next example, it is an
easy exercise to show that  (T, µ, η)  is a monad.
3.  As mentioned below definition 4.1.2, a preorder  (P,≤)  yields a category where endofunctors are
monotone functions.  If one has also a monad (T, µ, η), the natural transformations  η  and µ  give
that, for any a∈P,  a ≤ Ta  and  T(Ta) ≤ Ta,  since  ηa: a→Ta, and µa: T(Ta)→Ta.  By putting
together these inequalities with the monotonicity of T, one has  Ta ≤ T(Ta) ≤ Ta. Therefore, a monad
in a partial order is a closure operator, since, in this case, T(Ta) = Ta.
4.2.2 Definition  A comonad over a category C is a triple (T, δ, ε), where  T: C→C  is a
functor, and  δ: Τ→Τ2  and  ε: T→idC  are natural transformations, such that the following diagrams
commute:
In definition 4.1.2, we defined the notion of T-algebra over a generic endofunctor  T: C→C.  Thus,
one may have T-algebras, if any, over a monad  (T, η, µ ).  In this case, though, it is sound to
impose some extra conditions and ask that the monad’s operation and identity, given by  µ  and  η,
commute with the operation of T-algebra.  That is, a T-algebra  (c, α)  is given by a monad  (T, η,
µ )  over a category C if it also satisfies the following commutative diagrams:
T 2
µ
T
T h
T 
h
h
c
c
c
 c
η
T
h
 c
c
1
c
c
c.
Or, equivalently,
h ° T(h) = h ° µc ;
h ° ηc = idc .

4. Categories Derived from Functors and Natural Transformations
70
When T is the functor of a monad  (T, η, µ ),  we shall simply say T-algebras with the intended
meaning to be derived by the monad.  This collection of T-algebras can be organized in a category by
adopting the same notion of morphism as in definition 4.1.2.
2.3 Definition  Let  (T, η, µ )  be a monad over a category C.  The Eilenberg-Moore
Category  CT associated with the monad has T-algebras for objects, and for morphisms from  (c,
α)  to  (c',α')  all the arrows  h∈C[c,c']  such that  α'° T(h) = h ° α.
Examples
1.  Consider the monad  (T, η, µ )  associated with a monoid  M  as in example 1 above. Then a T-
algebra is a pair  (A, α) where  α: T(A) = M×A→A. Let us write  m*a  in place of  α(m,a);  then, for
every  a∈A  and  m,n∈M, the equations of a T-algebra read:
1*a = a ;
(m n)*a = m*(n*a) .
In other words, an algebra for the monad associated with a monoid M is just what is usually called an
M-set. Moreover the equation for a morphism  h  of T-algebras gives, for every  a∈A  and  m∈M,
h(ma) = m h(a), that is the usual notion of homomorphism of M-sets.
2.  In connection with example 3 above, observe that if the category C is a preorder, then  c ≤ T(c),
by  ηc,  and  T(c) ≤ c,  by  α  of the T-algebra.  Thus, if C also happens to be a partial order, any T-
algebra given by a monad is a fixed point in the p.o.set.
Let  (T, η, µ )  be a monad over a category C.  Then, for every  c∈ObC,  (T(c), µc)  is a T-algebra.
Indeed,
µc ° T(µc) = µc ° µΤ(c)
by the associative law of  (T, η, µ )
µc ° ηΤ(c) = idc
by the unity law of  (T, η, µ )
The algebra  (T(c), µc)  is called the free algebra generated by  c  (with respect to T).
The computational significance of monads has been stressed recently in suggestions that they may
help in understanding programs “as functions from values to computations.” The approach we sketch
here, and which seems very promising, still belongs to a denotational view in program semantics;
however, it suggests an alternative to the conceptual gap between the intensional (operational) and the
extensional (denotational) approach to the semantics of programming languages.  The idea, roughly,
is to give a denotational semantics to computations. The intuition we have been mostly referring to, in
the examples and in the presentation so far, is that objects are data types and morphisms are functions
or programs in extenso. However, one may need a better display of the intensional aspects of
computing and distinguish between values and computations. From this point of view, we can try to
look at programs not as transformations from values to values, but as transformations from values (or

4. Categories Derived from Functors and Natural Transformations
71
programs) to programs. This should be done by stressing the effectiveness and the intensional nature
of actual computations, without losing the insight and the elegance of the intended extensional
approach. That is one should preserve the conceptual unity of the mathematical view (e.g., by
categories and related structures), and without getting lost in the taxonomy and details of the
operational descriptions.
The idea of a monad  (T, η, µ )  as a model for computations is that, for each set of values of type
A,  T(A)  is the object of computations of “type A.” Then one may understand that  ηA: A→ΤA
maps values to computations, and  µA: Τ2A→ΤA  flattens a computation of a computation into a
computation.  If one also requires that  ηA  is a mono for every  A∈C,  then values form a “subset”
of computations (see section 1.5, for subobjects).
Examples
1. The above example of the power-set functor as a monad may give a description of nondeterministic
computations by looking at  nondeterministic computations as sets of values.  ηA  picks up a specific
computation, as  ηA(a)={a},  and  µA  says that a nondeterministic computation over non-
deterministic computations, yields a nondeterministic computation, as  µA(B) = ∪B∈P(A).
2. Even more expressively, computations with side effects may be described by the functor  T(A) =
(A×S)S, where  S is a set of stores. Intuitively a computation takes a store and returns a value
together with the modified store. Then a monad is obtained by setting, for each type (or object) A,
ηA(a) = λs:S.(a, s)  and  µA(f) = λs:S.eval(fs)) .
The meaning of  ηA  should be clear; while for each  f∈(A×S)S, µA(f)  is the computation that, given
a store  s,  first computes the pair  (computation,store)  given by  (f',s') = fs;  then evaluates  f'
applied to  s'  and returns a new pair  (value,store).
In the application of monads the idea is to go from objects, or types, to the image by a functor of an
object.  More specifically, in the examples, programs take values in  A,  say, to computations in  TB .
Kleisli categories provide the right setting to describe this approach.
4.2.4 Definition Given a monad  (T, µ, η) over  C, the  Kleisli category CT, is the category
whose objects are those of C ; the set  CT[A,B]  of morphisms from  A  to  B  in  CT  is  C[A,TB];
the identity in  CT[A,A]  is  η :A→ΤΑ . Moreover, the composition of  f∈CT[A,B]  and  g∈
CT[B,C]  in  CT  is   g° f = µC ° Tg° f : A →ΤΒ → Τ2C→TC .
Exercises
1.  Use the lifting functor  (_)˚  after proposition 3.2.3 and observe that the Kleisli category is the
category of “total maps” over a given category of partial morphisms.
2.  Give the notion of co-Kleisli category (see section 5.5).

4. Categories Derived from Functors and Natural Transformations
72
Eilenberg-Moore and Kleisli categories will be used in the next chapter when discussing adjunctions
and monads, and they will be applied in the semantics of linear logic.
4.3 Monoidal and monoidal closed categories
In section 4.2 we began by describing, with a diagram, the familiar notion of monoid. This motivated
the definition of monads, when Cartesian products in Set are substituted with composition of
functors, as in definition 4.2.1.
In both cases, we worked essentially “up to isomorphisms”. As for monoids, we identified
(A×A)×A  with  A×(A×A), in the upper left vertex of the first diagram in section 4.2, and called both
A3.  Similarly for  T3,  which is short for  T˚(T˚T)  and  (T˚T)˚T,  we followed a similar procedure in
definition 4.2.1.  This is perfectly sound as both Cartesian product and composition are associative.
The next step now is the explicit formalization of these (implicit) properties, including the behavior of
the terminal object  1, as a left and right unit, since they are needed in all categories where it may be
possible to define monoids and derived notions.
4.3.1 Definition  A monoidal category is a category C with a bifunctor  ⊗ :CxC → C, a (left
and right) identity  e∈ObC  and natural isomorphisms, for each  a, b , c∈ObC,
αa,b,c : a⊗(b⊗c)→(a⊗b)⊗c ;
λa : e⊗a→a ;
ρa : a⊗e→a ;
such that the following diagrams commute:
⊗ 
⊗ 
a ⊗ (b
(c
⊗ 
⊗ d))
α
⊗ 
a
(
b )
(c⊗ d)
α
)
⊗ 
a
(
b
(
c ⊗ d
⊗ 
α
1
⊗ α
1
a⊗ 
c
⊗  
⊗ d
)
d
a⊗ (b
c
⊗
⊗ 
))
((b
)
α
)
(
⊗ 
⊗
a
(
c)
α
⊗ 
(a
) ⊗ c
a⊗ c
⊗ id
⊗ 
id
λ
ρ
e
e
Indexes for the natural transformations  α, λ,  and  ρ  will usually be skipped, when they are clear
from the context.

4. Categories Derived from Functors and Natural Transformations
73
Remarks  1 - The “tensor product”  ⊗  in a monoidal category does not need to be unique, in
contrast with the Cartesian product (see the example below in the category Stab and Lin). Observe
also that the dual of a tensor product is, formally, just (another) tensor product, since isomorphisms
define the monoidal structure and the reverse of an isomorphism is still an isomorphism.
2 - The motivation for the two diagrams in definition 4.3.1 originate from a relevant fact, whose
treatment goes beyond our limited aims.  In short, it may be shown that in momoidal categories, as
defined above, any two (natural) isomorphisms built out of  α, λ, ρ  and  id, by using  ⊗  and
composition, actually coincide (“coherence theorem”).  For example, a⊗(b⊗c)⊗(a'⊗b')  and
(a⊗b)⊗(c⊗a'⊗b')  are isomorphic in just one way.
4.3.2 Definition  A symmetric monoidal category  (C, ⊗, e, α, λ, ρ)  is a monoidal category
such that for all objects  a,b  there is a natural isomorphism  γa,b: a⊗b→b⊗a  and
γa,b ° γb,a = idb,a
ρb = λb ° γb,e :  b⊗e→b
and moreover the following diagram commutes:
The diagram in 4.3.2 is motivated by an extension of the coherence theorem mentioned in the remark
above.
Example  Every Cartesian category is a symmetric monoidal category, with respect to the categorical
product, and the obvious choice for the isomorphisms. Roughly, the tensor product, in the sense of
monoidal categories, differs from the Cartesian product in that it has no projections and pairing
functions.
Exercise Let C be a category with a coproduct for every pair of objects (i.e., C is co-Cartesian).
Prove that C is a symmetric monoidal category.
Example In section 2.4.2, we introduced the category Stab of coherent domains and stable
functions.  Any coherent domain  X  is obtained from a set  |X|  of points and a binary relation  ↑ ,

4. Categories Derived from Functors and Natural Transformations
74
coherence, on  |X|.  Stable maps are continuous functions which also preserve intersection of coherent
arguments. Stab is a CCC.
In the same example, we noticed that one could also consider the linear maps between coherent
domains. They are stable ones which also commute with respect to arbitrary unions (see exercise 4
below definition 2.4.2.6). Lin is the category of coherent domains and linear functions. Products in
Lin are defined as for Stab, as the projections happen to be linear maps; thus, Lin is also Cartesian.
However, there is another relevant functor from Lin×Lin to Lin. Given coherent domains  X
and  Y, let  (|X|×|Y|,↑×)  be given by  (x,y)↑×(x',y')  iff  x↑x'  and  y↑y'. Let  X⊗Y  be the coherent
domain obtained from  (|X|×|Y|,↑×). This is not a product in Lin, but the reader may easily check that
it turns Lin into a symmetric monoidal category.
We will mention again the categories Lin and Stab, and their interesting interplay, in section 4.4,
since they inspired Linear Logic.
Exercise  Let  S⊕  be the free commutative monoid generated by a set  S.  Prove then that, for
S⊕⊗S'⊕ = (S×S')⊕,  the freely generated commutative monoids form a symmetric monoidal
category.
Example Our next example is borrowed from recent investigations of parallelism and concurrency,
based on a categorical description of well-known structures for those aspects of computations,
namely, Petri nets.
The category of graphs was defined in the example 4.1.5.  For readability we write  ∂0 = p0 ° ∂
and  ∂1 = p1 ° ∂  and set   (∂0,∂1: T→V)  for the graph   G = (T, ∂, V). Now, every graph  G  may
be turned into a category. Call  C(G)  the category whose objects are the nodes  V  of  G, whose
arrows are generated from the arcs  T  of  G  by adding the identity arc for each node and closing
freely w.r.t. composition  “˚”. Clearly,  C  is a functor from the category Graph in the example 4.1.5
to Cat (this method will be discussed when presenting adjunctions, see example 2 in section 5.3).
A (transition/place) Petri net is a graph  N = (∂0,∂1: T→S⊕), where the arcs are called
transitions and whose nodes are the elements of the free commutative monoid  S⊕, generated by a
(possibly finite) set  S  of labels, the places. Similarly for graphs, we may perform the free
construction of a category C(N), on top of a Petri net  N. However, N  has an extra structure: namely
the monoid structure of  S⊕. Thus we may obtain a monoidal category as follows. Let C⊗(N) be the
category whose objects are the nodes of  N, with  u⊗v = u∪v  in  S⊕,  and whose arrows are freely
generated from the transitions  T  of  N  with respect to composition  “˚”  and the monoidal operation
⊗  as well. In short, for each pair  f: u→u'  and  g: v→v'  one also has  f⊗g: u⊗v→u'⊗v'  in
C⊗(N).  The functoriality of  ⊗: C⊗(N)→C⊗(N)  is expressed by
(1)
(f⊗g)˚(f'⊗g') = (f˚f')⊗(g˚g') .

4. Categories Derived from Functors and Natural Transformations
75
The intended meaning of the monoidal operation  -⊗-  is the parallel composition of arrows, while “˚”
is the sequential composition. Thus, net computations are understood as the closure of the transitions
with respect to the parallel and the sequential composition. (Exercise: discuss the meaning of (1)
above).
Monoidal categories provide the right setting for a generalization of the notion of “monoid”.
4.3.3 Definition  Let  (C, ⊗, e, α, λ, ρ)  a monoidal category. A monoid in C is an object  c
together with two arrows  µ: c⊗c→c  and  η: e→c  such that the following diagrams commute:
A morphism between two monoids  (c, µ, η)  and  (c', µ', η')  is an arrow  f: c→c'  in C such that
f ° µ = µ' ° (f⊗f)  : c⊗c→c'
f ° η = η' : e→c'.
It is easy to prove that with the previous definition of morphisms, monoids over a monoidal category
C form a category MonC.
Examples
1. Set, with a Cartesian product, is monoidal and the monoids in it are exactly the ordinary monoids.
2. Given an arbitrary category C, consider the category of endofunctors CC, with natural
transformations as morphisms. Then composition “°” of functors is a bifunctor from CC×CC to CC
which turns CC into a monoidal category. The reader may easily check for exercise that the monoids
in this category are exactly the monads in definition 4.2.1 and thus understand the elegant conceptual
frame provided by the categorical developments of the notion of monoid.

4. Categories Derived from Functors and Natural Transformations
76
Dually, we have the concept of “comonoid.”
4.3.4 Definition  Let  (C, ⊗, e, α, λ, ρ)  be a monoidal category. A comonoid in C is an object
c together with two arrows  δ: c→ c⊗c, ε: c→e  such that the following diagrams commute:
A morphism between two comonoids  (c, δ, ε)  and  (c', δ', ε')  is an arrow  f: c→c' in C such that
f° δ' = (f⊗f) ° δ  : c→ c'⊗c'
ε' ° f = ε : c→e' .
As we have pointed out, monoidal categories are given by an abstract notion of “product,” described
only in terms of (natural) isomorphisms or, equivalently, in terms of collections of isomorphisms
between objects with no further properties (cartesian products also have projections).
Observe that, in the special case that C is Cartesian, each object is a comonoid: just set  δ =
<id,id>, i.e.,
Similarly to the construction of cartesian closed categories from cartesian ones, one may extend the
abstract or “equational” approach for monoidal categories and give a notion of monoidal closed
categories.

4. Categories Derived from Functors and Natural Transformations
77
4.3.5 Definition  Let C be a symmetric monoidal category, with respect to the bifunctor ⊗. Then
C is monoidal closed if there is also a bifunctor  ⇒: C×C→C  such that, for every object b, there
exists an isomorphism  Λ : C[a⊗b,c] ≅ C[a,b⇒c]  that is natural in a and c.
Clearly, any CCC is monoidal closed.
3.6 Exercise
1. (Important for the purposes of sections 4.4 and 5.5)  Lin, with  ⊗  as in the example below
definition 4.3.2, is symmetric monoidal closed (hint: see section 2.4.2 and use the coherent domain
of traces of linear maps as “⇒”; note that this is not an exponent for the Cartesian product in Lin).
2. Consider the tensor product  ⊗  of monoids given in the remark below definition 4.1.1. There is a
natural isomorphism  A⊗B ≅ B⊗A, and the monoid homomorphisms between two commutative
monoids A and B form a commutative monoid [A→B]. Prove then that there is a natural isomorphism
[(A⊗B)→C] ≅ [A→[B→C]], making the category cMon, of commutative monoids, a symmetric
monoidal closed category.
3. Let  e  be the identity of a monoidal closed category. Prove then that  e⇒α ≅ α  for any object  α.
(Hint: use the diagram
in your proof.)
Example  We already defined Petri nets and turned each individual net into a (monoidal) category.
We could thus view the relation between parallelism and sequentiality as a functorial notion (see the
example below definition 4.3.2). We consider now the collection of Petri nets as a category. The
category Petri, of (transition/place) Petri nets, has Petri nets  (∂0,∂1: T→S⊕)  as objects, where
S⊕  is the free commutative monoid generated by  S.  Morphisms are pairs  <f,g >,  f: T→T'  and  g:
S⊕→S'⊕  as for graphs (see the example 4.1.5), with the extra condition that  g  is monoid
homomorphism.  (Exercise: describe Petri as a comma category).  As the careful reader should
have checked, given two graphs  G = (∂0,∂1: T→V)  and  G' = (∂'0, ∂'1: T'→V'),  their cartesian
product is the graph   G×G' = (∂0×∂'0,∂1×∂'1: T×T'→V×V'). When considering Petri nets  N =
(∂0,∂1: T→S⊕)  and  N' = (∂'0,∂'1: T'→S'⊕),  their product as graphs, that is
N×N' = (∂0×∂'0,∂1×∂'1 : T×T'→S⊕×S'⊕),

4. Categories Derived from Functors and Natural Transformations
78
is also a Petri net, since  S⊕×S'⊕ ≅ (S+S')⊕, i.e., the product of two free commutative monoids
S⊕  and  S'⊕  coincides with the monoid freely generated by  (S+S').  The Petri net  N×N'  is called
the synchronous product  of the nets  N and N'.  Intuitively, the sychronous product of two Petri nets
is the results of a composition operation with synchronization: the places of the result are the union of
the places of the factors, while the transition in the synchronous product are pairs (i.e.,
synchronization) of the given transitions.  Since  S⊕⊕S'⊕ ≅ (S+S')⊕  is valid as well, the category
Petri has also coproducts, namely,
N⊕N' = ([∂0,∂'0],[ ∂1,∂'1] : T+T '→(S+S')⊕),
where  [∂i,∂'i]  denotes the function induced on the coproduct  T+T'  by the functions ∂i  and  ∂'i.
Intuitively, the coproduct of two Petri nets is the result of a composition operation without
synchronization: the two nets laid aside without interaction. The choice is nondeterministic because of
the freedom of choosing an arbitrary initial state.
The initial net has no transition and no places, while the final net has one transition and no places.
As the reader has proved for exercise, the tensor product of free commutative monoids satisfies
S⊕⊗S'⊕ = (S×S')⊕.  Thus, one may define  - ⊗ - : Petri2→Petri, the tensor product  N⊗N'  of
two Petri nets  N  and  N', by taking as transitions the Cartesian product of their transitions, as places
the cartesian product of their places, and using the equation  S⊕⊗S'⊕ = (S×S')⊕  to define nodes
from places.  The unit object  I  is the Petri net  (∂0,∂1: [1]→[1]⊕), with  ∂0 = ∂1  the inclusion of
[1]  in  [1]⊕.  In conclusion  Petri is cartesian, cocartesian and is a monoidal category with a tensor
product  derived from that operation on monoids.
The next step is to discuss the monoidal closed structure. This is easy when considering finite
Petri nets since, whenever  S = {a1, ..., an}  is finite, we have
n
S '
x . . . x S '
 . . .  
S '
S '
n
[S   →S '
] ≅
≅
≅
n
S '+  . . . +S ').
(
Define then the  “⇒”  functor, on finite Petri nets, as follows.  Given Petri nets  N  and  N',  N⇒N'
has as arrows the set of triples
{(h: T→T', g: S⊕→S'⊕, g': S⊕→S'⊕)  /   g,g'  are monoid homomorphisms,  ∂'0 ° h = g ° ∂'0
and ∂'1 ° h = g' ° ∂1 }.
For  S = {a1, ..., an}  the monoid of nodes is the free commutative monoid  (S'+ ... +S')⊕,  n
times,  and  ∂0  and  ∂1  are the second and third projection. It is then clear that (finite) Petri is a
symmetric monoidal closed category.
Monoidal closed categories generalize Cartesian closed ones in that they also possess exponent
objects  a⇒b,  or  ba,  which “internalize” the hom-sets.  One may then ask if there is a way to
describe “internally” the behavior of funtors on morphisms.  That is, given a monoidal closed
category C and a functor  F: C→C,  consider, say,  f∈C[a,b].  Then  F(f)∈C[F(a),F(b)]. Since  ba

4. Categories Derived from Functors and Natural Transformations
79
and  F(b)F(a)  represent  C[a,b]  and  C[F(a),F(b)]  in C, one may study the conditions under which
F  is “represented” by a morphism in  C[ba, F(b)F(a)],  for each  a  and  b.
4.3.7 Definition  Let C be a monoidal closed category.  A functor  F: C→C  is closed if, for
each  a  and  b  in C, there exists  fab∈C[ba, F(b)F(a)]  such that, for all  g∈C[a,b],
fab˚ Λ(g˚λa) =Λ(F(g)˚λF(a))
where  Λ : C[e⊗a,b] ≅ C[e,ba]  and  λa: e⊗a→a  are as in 4.3.1.
The notion of a closed functor soundly formalizes our aim above, in view of proposition.4.3.8
below.  This essentially says that, internally,  fab  takes the identity to the identity and behaves
correctly w.r.t. to composition. We will call  fab  the action of  F  on  ba.
4.3.8 Proposition  Let C be monoidal closed category and  F: C→C  a closed functor.  Then the
collection  {fab | a,b∈ObC}  of its actions is natural in  a  and  b.  Moreover, let  compabc:
ab⊗bc→ac  be the natural transformation which internalizes composition, and IDa: e→aa  be the
natural transformation which “picks up” the identity in  aa, i.e.,  IDa = Λ(λa).  Then the following
equations hold:
i.  faa ˚ IDa = IDF(a)
ii. ∀g: b→a, ∀h: c→b,  fac ˚ comp ˚ Λ(g˚λb)⊗Λ(h˚λc) = comp ˚ fab⊗fbc ˚  Λ(g˚λb)⊗Λ(h˚λc)
Proof  Exercise. ♦
4.3.9 Remark  By similar techniques for monoidal categories, one may define other classes of
categories. In particular, this can be done in order to study very weak frames dealing with a notion of
exponent object. Consider for example a category C, not necessarily monoidal, but with an
“exponent” functor which realizes the following natural isomorphism, C[a,cb] ≅ C[b,ca] satisfying
suitable identities. C is called symmetric closed. Clearly any symmetric monoidal closed category
is symmetric closed. This description of categories by (natural) isomorphisms may remind the reader
of remark 3.3.3, where we described the set of isomorphisms which hold in all CCC's. Those
equations do not characterize CCC's, as cartesian closure requires further structural properties, i.e.
projections. They may be used instead to define the larger class of symmetric monoidal closed
categories with a terminal object. (The reader may try to complete, as an exercise, the
definition of the classes of categories in this remark.)
4.4. Monoidal Categories and Linear Logic
The perspective of this book is to introduce and use Category Theory mainly in order to understand
“types as objects” of (Cartesian Closed) Categories. Indeed, this will be the focus of the chapters in

4. Categories Derived from Functors and Natural Transformations
80
Part II. In the literature, so far, the categorical semantics of types has been mostly applied to the
functional notion of type, in connection with proof theoretic investigations. The link to functional
languages is described by the motto “propositions as types,” which proved successful both in the
mathematical investigation and in concrete applications as the design of new functional languages with
powerful type systems. It seems promising to explore similar analogies for other approaches to
computing, where nonfunctional constructs, e.g., parallel features, are considered. These motivations
and the properties of relevant categories, namely Stab and Lin, the categories of stable and linear
maps widely discussed in section 2.3 and in the previous section, have suggested a new formal
system, linear logic.
The crucial difference between the old and new paradigms may be informally summarized as
follows. When looking at “propositions as objects” one understands “proofs as functions”, while one
of the possible perspectives suggested by linear logic is the description of “proofs as actions”. An
action is roughly an operation which modifies its premises, by a sort of “physical reaction.” In short,
a step of logical inference modifies the state of the premises: for example, when deducing  B  from
A, some resource in  A  is consumed. This is in contrast with classical and intuitionistic logic, which
deal with static situations: if  A implies  B and  A  holds, then we deduce  B, but  A  holds as before,
also after the deductive process. Observe that, when ignoring the reaction, one obtains “proofs as
functions” again, and thus the new approach may be considered a refinement of the “propositions as
objects” analogy.
The proof theoretic description of this difference is based on a rewriting of the structural rules of
deduction.  We present next the core of linear logic and refer the reader to references for further
readings or comparisons with other systems in Proof Theory.
Linear Logic is formally a Gentzen-like logic. The calculus of sequences of Gentzen seems a very
suitable formalism for the study of proofs as dynamic actions; indeed the relevance of the structural
rules, which instead play a quite obscure role in natural deduction, for example, allows a better
formalization of the handling of formulas during the inference process, if one wants to focus on its
dynamic aspects.  The main difference between linear logic and Gentzen calculus of sequences is just
in these structural rules. In particular, linear logic drops weakening and contraction rules, i.e.,
   Γ |- ∆ 
Γ,Α,Α  |- ∆
               
        and
__________
Γ, Α |- ∆
  Γ,Α  |- ∆
Intuitively, formulas can be thought of as resources, and the interpretation of a sequent of the form
A1, . . . , An |- B  is that of a process (action) which consumes  the resourses A1, . . . , An and
produces  B. Thus, resources cannot be freely duplicated or erased; at most, they can be reordered.
Moreover, this lack of structural rules suggests a duplication of the binary connectives of conjunction
and disjunction.  Namely,  ∧  and  ∨  will be described as  ⊗  and  ∪  in the “multiplicative” case and

4. Categories Derived from Functors and Natural Transformations
81
as  ∩  and  ⊕  in the “additive” case below. The reason for this is clearly understood, say, in the
introduction and elimination rules for  ∧ :  in the presence of contraction and weakening, Gentzen
calculus does not distinguish between  (⊗, r)  and (∩, r),  nor between  (⊗, l )  and  (∩, l, 1)  plus
(∩, l, 2).  Similarly for  ∨ , which is also described by two connectives,  ∪  and  ⊕ .
In this section, we define and give categorical meaning to the core of “classical” linear logic by
suggesting the basic structural properties of suitable categories where the reader may carry on the
details of the interpretation.  Other connectives or modalities, essentially the exponential connective
“!” (of course), will be discussed in section 5.5.
4.4.1 Alphabet
1.  atomic propositions, ranged over by  A, B, C, . . .
2.  logical symbol:
2.1.  multiplicative symbols:
constants:  1  (mult. true), ⊥  (mult. false)
unary connective:  ( )⊥  (linear negation)
bynary connectives:  ⊗  (mult. and),  ∪  (mult. or),  __o  (mult. or linear implication).
2.2.  additive symbols:
constants:   T   (add. true),  0  (add. false)
bynary connectives:  ∩  (add. and),  ⊕  (add. or).
The well-formed formulae are defined in the obvious way.
Greek capital letters Γ, ∆, . . . denote finite (possibly empty) sequences of formulas separated by
commas. The expression  Γ |- ∆  is called sequent.
4.4.2 Axioms and rules
Each set of (nonstructural) axioms and rules below begins with axioms and rules which deal with the
identities relative to the specified connective:  1  for  ⊗ ,  ⊥  for  ∪ ,  T  for  ∩ ,  0  for  ⊕.  The other
rules are introduction rules.
1.  structural rules
(id)
A |- A
Γ |- ∆
(exc, r)
            where Γ', ∆' are permutations of  Γ, ∆.
Γ' |- ∆'

4. Categories Derived from Functors and Natural Transformations
82
Γ1|- A, ∆
Α, Γ2 |- ∆'
(cut)
___________________
      Γ1, Γ2 |-  ∆, ∆'
2.  multiplicative rules
  Γ |-  ∆
(1, r)
|- 1
(1, l)
_______
Γ, 1  |-  ∆
   Γ |-  ∆
(⊥, l)
________
(⊥, l)
⊥ |-
Γ |-  ⊥, ∆
Γ1|- A, ∆      Γ2 |- B, ∆'
 Γ, Α, Β |- ∆
(⊗, r)
                                     
(⊗, l)
___________
Γ1, Γ2 |- A⊗B, ∆, ∆'
Γ, A⊗B |- ∆
Γ |- Α, Β, ∆
Γ1, A |- ∆     Γ2, B |- ∆'
(∪, r)
___________
(∪, l )
___________________
Γ |- A∪B, ∆
Γ1, Γ2,  A∪B |- ∆, ∆'
Γ, Α |- B, ∆
Γ1 |- A, ∆      Γ2, B |- ∆'
(   o, r)
___________
(   o, l )
___________________
Γ |- A__oB, ∆
Γ1, Γ2, A__oB |- ∆, ∆'
3. additive rules
(T, r)    Γ |- T, ∆ 
(0, l)
Γ, 0 |- ∆
Γ |-  A, ∆    Γ |- B, ∆ 
  Γ, Α |- ∆
(∩, r)
_________________
(∩, l, 1)
__________
      Γ |- A∩B, ∆
Γ, A∩B |- ∆
  
 Γ, Β |- ∆
(∩, l, 2)
_________
Γ, A∩B |- ∆

4. Categories Derived from Functors and Natural Transformations
83
   Γ |- A, ∆
(⊕,r,1)
__________
Γ |- A⊕B, ∆
   Γ |- B, ∆
Γ, A |- ∆     Γ, B |- ∆
(⊕,r,2)
                      
(⊕, l)
________________
Γ |- A⊕B, ∆
       Γ, A⊕B |- ∆
3.  linear negation
Γ,A |- ∆
Γ |- A, ∆
(⊥,r)
_________
(⊥,l)
________
Γ |- A⊥,∆
Γ, A⊥ |- ∆
As suggested by the rule  (⊗, l),  the comma in the left hand side of a sequent has the same logical
meaning as ⊗, while the commas in the right hand side correspond to the tensor sum  ∪,  the
disjunction which is dual to  ⊗.
Observe that the rules  (⊥, r)  and  (⊥, l)  are equivalent to
   
Γ,A |- B,∆
(contrap)
____________
Γ, B⊥ |- A⊥,∆
(⊥, 1)
1 |- ⊥⊥
and
(⊥, 2)
1⊥ |- ⊥
(Hint:  1,⊥ |- ⊥  gives both  ⊥ |- 1⊥  and  1 |- ⊥⊥ , while  1 |- 1,⊥  gives both  ⊥⊥ |- 1  and  1⊥ |- ⊥;
the rest is obvious).
From the rules one may easily derive the following sequents:
(µAB)   A,B |-  A⊗B
by  (⊗, r)
(evalAB)   A, A__oB |-  B
by  (__o, l )
In a few steps, one also obtains
(αABC)   (A⊗B)⊗C  |-  A⊗(B⊗C)
(α−1ABC)   A⊗(B⊗C)  |-  (A⊗B)⊗C .

4. Categories Derived from Functors and Natural Transformations
84
Exercise  Show the logical equivalence of  (A⊗B)__oC  and  A__o(B__oC).  Derive also that  A |-
(A⊥)⊥  and  (A⊥)⊥ |- A,  i.e.  ( )⊥  is “dualizing”.
This may be enough to suggest that the categorical meaning of linear logic may be found in particular
symmetric monoidal closed categories, where  ⊗  and  __o  are interpreted by the tensorial product
and the bifunctor   ⇒  given in definition 4.3.5, respectively.  Observe that the cartesian product is
needed too, so to provide an interpretation for  ∩  and its identity  T  (see later). Negation and all dual
constructions are taken care of by a “dualizing” endofunctor  (-)*,  which is closed in the sense of
4.3.7.  Indeed, theorem 4.4.6 below shows that this functor, given  ⊗  and  ∩ , immediately yields
their duals.
4.4.4 Definition  A ∗∗∗∗-autonomous category  K  is a symmetric monoidal closed category and a
contravariant closed functor  (-)*: K → ΚΚΚΚ  such that:
-  there exists a natural isomorphism  d : Id  ≅  (-)**
-  the following diagram commutes (where  (-)*  is the action of the functor on exponents)
A ⇒ B
B*⇒ 
(-)*
A** ⇒ B**
(-)*
d
d-1
˚ _ ˚
A*
A ∗-autonomous category is linear if it is also cartesian.
In other words, a linear category has both a monoidal and a Cartesian structure,  ⊗  and  ∩ ,  plus a
dualizing functor  (-)*.
4.4.5 Proposition  Both the vertical and the horizontal arrows in the diagram in definition 4.4.4
are isomorphisms. Moreover,
i.  A* ≅ B*  iff  A ≅ B;
ii.  A* ≅ A⇒1*.
Proof  By definition, the following diagram commutes and  d ˚ _ ˚ d-1  is an isomorphism,
A**
f**
B**
A
B
d-1
d
f

4. Categories Derived from Functors and Natural Transformations
85
Then the horizontal  (-)*, in the diagram in definition 4.4.4, is a split mono (see section 1.4) and the
vertical one is a split epi. Since the latter is an instance of the former, they are both split monos and
split epis as well and, thus, isomorphisms. In conclusion,  Α⇒B ≅ Β*⇒A*. Finally, A* ≅ B*
implies  A ≅ A** ≅ B** ≅ B  and, by exercise 4.3.6.3,  A* ≅ 1⇒A*. Thus, A* ≅ B*  iff  A ≅ B
and, moreover,  A* ≅ Α ⇒ 1*. ♦
4.4.6 Theorem  Let  K be a linear category.  Define
A∪B = (A*⊗B*)*
A⊕B = (A*∩B*)*.
Then  ∪  is a dual to the tensor product and  ⊕ is the coproduct in K.  Their identies are  ⊥ = 1*  and
0 = T*,  respectively.
Proof   ∪  is a well-defined dual to ⊗: just compare with definition 4.3.1 (and the remark
afterwards) and note that
-  A∪⊥ = (A*⊗1)* ≅ A** ≅ A    (similarly for the identity to the left),
-  (A*⊗B*)⊗C* ≅ A*⊗(B*⊗C*)   implies   (A∪B)*⊗C* ≅ A*⊗(B∪C)*   implies
   ((A∪B)*⊗C*)* ≅ (A*⊗(B∪C)*)*   implies   (A∪B)∪C ≅ A∪(B∪C) .
As for the Cartesian coproduct, note that, if  pA*  and  pB*  are the projections for  A*∩B*, then
their images  (pA*)*  and  (pB*)*  via the  (-)*  functor are the injections for  A⊕B. Finally, A∪⊥ =
(A*⊗1)* ≅ A  and  A⊕0 = (A*∩T)* ≅ A. ♦
The results in proposition 4.4.5 and theorem 4.4.6 prove the “dualizing” role of the  (-)*  functor and
of  ⊥ = 1*. In particular, theorem 4.4.6 is a version of De Morgan rules in the semantic structures for
linear logic, when described in categorical terms. Note also that
            A*∪B ≅ (A⊗B*)*
≅ (A⊗B*)⇒⊥
≅ A⇒(B*⇒⊥)
≅ A⇒(1⇒Β)
≅ A⇒B
which gives the “classic” flavor of this fragment of Linear Logic.
The meaning of linear logic as a deductive system is then given by interpreting each entailment  A
|- B  as a morphism between the interpretation of the formulas. Linear categories yield such an
interpretation, which we sketch here, by induction on rules. Here are some of the basic cases. Some
crucial ones are simply the properties corresponding to  (µAB), (evalAB), (αABC) and (α−1ABC),
given before definition 4.4.4, in monoidal closed categories. As for the others,
the rules
are interpreted by
the fact that

4. Categories Derived from Functors and Natural Transformations
86
for  1  and  ⊥
1  and  ⊥  are (the unique) identies for  ⊗  and  ∪, which
are expressed by commas, on the left or right, respectively,
of  |-.
(⊗,r)  and  (∪,l)
⊗  and  ∪  are bifunctors
(∩,r)  and  (⊕,l)
∩  and  ⊕  have pairing and sum of morphisms
(∩,l,1)  and  (∩,l,2)
there exist projections for  ∩
(⊕,r,1)  and  (⊕,r,2)
there exist injections for  ⊕
(contrap)
(-)*  is so defined in linear categories
(⊥,⊥)
⊥ = 1*  and, thus,  ⊥* ≅ 1 .
(By the argument before 4.4.4,  (contrap)  and  (⊥,⊥)  are equivalent to  (⊥,r)  and  (⊥,l) .)
Example The category Lin of coherent domains and linear maps, in 2.4.2, not only provides an
example of linear category, but it has even been the source of inspiration for linear logic, since linear
functions depend on inputs “additively” as deductions from assumptions in this logic. (There is more
than that analogy, though, as this example and section 5.5 should clarify.)
We noticed that Lin is Cartesian in 2.3.7(II). Lin is also co-Cartesian. Indeed, let  (|X|,↑)  and
(|Y|,↑)  be coherent structures.  Define then the coproduct   X⊕Y  as the coherent domain associated
with the coherent structure  ({(0,z) | z∈|X|}∪ {(1,z) | z∈|Y|},↑⊕), where  (a,x)↑⊕(a',y)  iff  a = a'
and  x↑y .  (Note the difference with the product: the support is the same, but the coherence relation
changes. Give the embedding linear maps for exercise.)
The singleton coherent domain  T = 0 = {∅} , associated with the empty coherent structure, is
both terminal and initial in the category. Indeed, it is the identity for both the product and the
coproduct.
In the previous section we turned Lin into a symmetric monoidal closed category (see exercise
4.3.6).  Recall, in particular, that the tensor product  A⊗B  is the coherent domain associated with
the coherent structure  (|A|×|B|, ↑⊗), where  (x,y)↑⊗(x',y')  iff  x↑x'  and  y↑y'.
The dual of the tensor product, is  ∪  given by the tensor sum  A∪B, that is, the coherent
domain associated with the coherent structure  (|A|×|B|, ↑∪), where (x,y)↑∪(x',y')  iff  ( (x,y) =
(x',y')  or  x↑↑x'  or   y↑↑y'). Also in this case, the tensor product and sum have the same support,
but the coherence relation changes.
Notice that the identity for both the tensor product and its dual is the coherent domain  1 = ⊥ =
{∅,{1}}, associated with  ({1}, =).

4. Categories Derived from Functors and Natural Transformations
87
As for the contravariant functor  (-)* , given a coherent structure  (|A|, ↑),  define  A*  as the
coherent domain associated with  (|A|, ↑*), where  x↑*y  iff  ~(x↑y)  in  A . On a linear function  f:
A→B,  f*: B*→A*  is defined in the following way: (y,x)∈Tr(f*)   iff   (x,y)∈Tr(f) .
As one could expect (and easily compute), in coherent domains one has T* = 0 = T  and  1* = ⊥
= 1 . Moreover, the equations in theorem 4.4.6 are realized in Lin.
Memo  For the reader's convenience, we summarize the identities in linear logic (and linear
categories):
1  for  ⊗ ;  ⊥  for  ∪ ;  T  for  ∩ ;  0  for  ⊕
which are interpreted in Lin as  1 = ⊥ = {∅,{1}}  and  T = 0 = {∅}, with the obvious coherent
structure.
References  Textbooks, which stress the applications of Category Theory to computer science
with an algebraic perspective, are Arbib and Manes (1975) and Rydeheard and Burstall (1988).
Goguen and Burstall (1984) contains a survey and references to part of this area, broadly construed,
which ranges from the work in Elgot (1971), to the contributions of the ADJ group (see, at the end of
this volume, the many references which include the names of Goguen, Thatcher, Wagner, or
Wright).
Besides the references to general Category Theory, the reader may consult Barr (1979) and Barr
and Wells (1985) for monoidal categories, monads and their mathematical applications. Further
references, which also discuss Linear Logic, are Barr (1990) and Marti-Oliet and Meseguer (1990).
The recent applications of “monoidal notions” we described are borrowed from Moggi (1989), as for
the understanding of programs as “functions from values to computations”, and from Meseguer and
Montanari (1988) or Degano and al. (1989), as for the examples on Petri nets (see also Marti-Oliet
and Meseguer (1989)).
The main reference for linear logic is Girard (1987). Further work may be found, among others,
in Girard and Lafont (1987), Lafont (1988), DePavia (1987), and Seely (1987), where ∗-autonomous
categories are proposed for its semantics.  Lambek (1968) contains early work on the categorical
significance of logical systems and discusses weakenings of the structural rules.

5. Universal Arrows and Adjunctions
88
Chapter 5
UNIVERSAL ARROWS AND ADJUNCTIONS
In chapter 3, we introduced the notion of functor as a uniform way to describe “acceptable”
constructions in Category Theory. The reader may have noticed that in some cases, for a given
construction  F: C→D, there exists a particular object  c  in C and an arrow  u: F(c)→d , which has
a “universal behaviour” with respect to d, in the sense that every other arrow  f: F(c')→d  uniquely
factorizes through  u , i.e., there exists a unique  f': c→c'  such that  f = u ° F(f')  or the following
diagram commutes:
Consider for example the product functor  _×a: C→C  where C is a CCC and  a∈ObC. The arrow
eval: ba×a→b  is universal with respect to b, in the previous sense, since for every arrow  f: c×a→b
there exists a unique arrow  Λ(f): c→ba  such that   f = eval ° Λ(f), i.e.,
Also the product of two objects may be described in terms of universal arrows. Just take the diagonal
functor  ∆: C→CxC , with  ∆(c) = (c,c)  and  ∆(f) = (f,f)  and observe that the following diagram
commutes:

5. Universal Arrows and Adjunctions
89
The aim of this chapter is to study the concept of universal arrow outlined above, and some of its
implications. In particular we prove that given a functor  F: C→D,  if for every  d∈D  there exists an
universal arrow  ud: F(cd)→d, then the function  g: ObD→ObC  that takes  d  to  cd  may be
extended to a functor  G: D→C. Such a functor  G  is called (right) adjoint to  F. Remarkably, if G
is a (right) adjoint to F, then F is a (left) adjoint to G, in a dual sense, and each one describes the
other up to isomorphism. From another point of view,  F and  G  can be seen as a pair of “mutually
representable” functors.
The notion of adjointness is probably the most profound and original contribution of Category
Theory to mathematics. The reader must not expect to understand its relevance upon first reading the
definition, or the few examples and applications in this chapter: only by a systematic use of
adjunctions will she or he become competent on the subject.
5.1 Universal arrows
In addition to the previous remarks, the careful reader has surely noticed that most of the definitions
of the constructions defined in chapter 2 (products, coproducts, terminal object, exponents . . .) have
the following common pattern:
for all . . .  there exist a unique . . .  such that  . . .  .
As a matter of fact, all those definitions can be seen as particular cases of a same notion (or its dual):
the universal arrow. For historical reasons, universal arrows are defined dually with respect to the
examples just mentioned (exponents, products . . . ). Couniversal maps, to be defined next, will fit
the examples.
5.1.1 Definition.  Let  F: C→D  be a functor and  d∈ObD. Then  <u,cd>  is universal  from  d
to  F  iff  u∈D[d,F(cd)],  cd∈ObC, and ∀c'∈ObC, ∀f∈D[d,F(c')], ∃! f'∈C[cd,c']  f = F(f')° u .
As usual, this may be equivalently visualized by

5. Universal Arrows and Adjunctions
90
Example  <(q1,q2),(a#b,a#b)>  is universal from  (a,b) to  ∆∆∆∆,    where  ∆∆∆∆: C→C×C  is the diagonal
functor.
5.1.2 Definition. Let  F: C→D  be a functor and  d∈ObD. <u,cd>  is (co)universal from  F  to
d  iff  u∈D[F(cd),d], cd∈ObC, and ∀c'∈ObC, ∀f∈D[F(c'),d]  ∃! f'∈C[c',cd]   f = u ° F(f').
The diagrams and examples in the introduction to this chapter refer this “dual” notion. Here are other
interesting examples:
5.1.3 Example  Let !C be the unique functor from the category C to the category 1; if  id1 = u ∈
1[!C(c),1]  is universal, then  c  is terminal in C:
5.1.4 Example  Let C be a category of partial morphisms, Ct be the associated category of total
morphisms, and Inc: Ct→C be the embedding functor (see section 2.6). Recall that, by definition,
the lifting of  a∈ObC  is an object  a°∈ObC  together with a morphism  exa∈Ct[a°,a]  such that for
every  f∈C[c,a] , there exists one and only one  f'∈Ct[c,a°]  satisfying the equation  exa ° f' = f .
This says exactly that  exa: a°→a  is an universal arrow  from  Inc  to  a :

5. Universal Arrows and Adjunctions
91
Exercise  Define an initial object as a universal arrow from  1  to  !C.
5.1.5 Proposition.  Let  F: C→D  be a functor and  d∈ObD .  Assume that   <u,c>  is universal
from  d  to  F . Then
1.  <u',c'>  is universal from  d  to  F   ⇒   c ≅ c' ;
2.  c ≅ c'  via  (h,h-1)   ⇒   <F(h)° u,c'>  is universal from  d  to  F.
Proof
1.  ∃!h∈C[c,c']  ∃!h'∈C[c',c]  u'= F(h)°u = F(h)°F(h')°u'= F(h°h')°u'.  But  u' = F(id) °u'.
By unicity,  h°h' = id .  Similarly,  h'°h = id .
2.  Exercise. ♦
By the proof of proposition 5.1.5, one even has that the isomorphism is unique.  This is a strong
property of universal constructions as a very common tool in mathematics (see the examples below).
It is hard to think of a more suitable language than the categorical one for expressing properties like
this.
We next give two alternative characterizations of the notion of universal arrow: the first one, in
theorem 5.1.6, is of an equational nature; the second one, in theorem 5.1.7, makes use only of the
notion of a natural isomorphism. In a sense, the definition of universal arrow given in definition
5.1.1 is in the middle way: it is based on one equation and on the existence of an isomorphism (does
the reader see any analogy with the various characterizations of products and exponents we have
given?).
5.1.6 Theorem  Let G: C→D be a functor, d∈ObD and cd∈ObC. Then there exists
u∈D[d,G(cd)] such that  <u,cd>  is universal from  d  to  G  iff, for every c∈ObC there is an
operation  τc: D[d,G(c)]→C[cd,c]  such that, for every  f∈D[d,G(c)]  and every  h∈C[cd,c] ,
1.   G(τc(f)) ° u = f
2.   τc(G(h) ° u) = h

5. Universal Arrows and Adjunctions
92
Proof
(⇐) let  <u,cd>  be universal from  d  to  G. For every  f∈D[d,G(c)]  define  τc(f)  as the unique
arrow  f'  such that  G(f') ° u = f.  (1) is then immediate by definition, and (2) follows by unicity.
(⇒)  let  τc: D[d,G(c)]→C[cd,c]  be an operation which satisfies  (1)  and (2) above. We must
only prove that it is an isomorphism.  Define then, for every  h∈C[cd,c]  τc-1(h) = G(h) ° u ; thus,
we have:
τc-1(τc(f)) =  G(τc(f)) ° u = f 
by (1)
τc(τc-1(h)) = τc(G(h) ° u) = h
by (2). ♦
5.1.7 Theorem. Let C, D be locally small categories, G: C→D,  d∈ObD  and  cd∈ObC. Then
there exists  u∈D[d,G(cd)]  such that  <u,cd>  is universal from  d  to  G   iff   C[cd,_] ≅ D[d,G_] .
Proof
(⇐)  For  c'∈ObC  and  f'∈C[cd,c'], set  τc'(f') = G(f') ° u ∈ D[d,Fc'] .
Then  τ: C[cd,_]→D[d,G_]  is a natural transformation, since τc'(g ° h) = G(g ° h) ° u = G(g) ° τc(h).
That is, for  g∈C[c,c'], the following diagram commutes:
Moreover,  ∀f∈D[d,Fc']  ∃!f'∈C[cd,c']  f = τc'(f') , by definition. Thus, by proposition 3.2.3,  τ
is a natural isomorphism.
(⇒)  Let  τ : C[cd,_] ≅ D[d,G_]  and set  u = τcd(id). Then  u∈D[d,G(cd)] . By the naturality of
τ,  for all  c,c'∈ObC , G(g) ° τc(_) = τc'(g°_)  and, hence,  ∀f∈D[d,G(c')]
G(τc'-1(f)) ° u = G(τc'-1(f))°τcd(id)
= τc'(τc'-1(f))
= f .
That is, ∀f∈D[d,G(c')]  ∃!f'(= τc'-1(f))∈C[cd,c']  such that   f = G(f')°u . ♦
Exercise: Give the dual version of theorems 5.1.6 and 5.1.7.
Recall now that a functor  F : C→Set  is representable if there exists a  c∈C  such that  F ≅ C[c,_]
naturally.

5. Universal Arrows and Adjunctions
93
5.1.8 Corollary Let C, D be small categories, G: C→D,  d∈ObD  and  cd∈ObC. Then there
exists  u∈D[d,G(cd)]  such that  <u,cd>  is universal from  d  to  G  iff  the functor D[d,G_]:
C→Set  is representable.
5.2 From Universal Arrows toward Adjunctions
The construction of  a universal  arrow  ud: G(cd)→d  from  G: C→D  to  d  usually depends on  d.
If this construction can always be performed, the function  d |_ cd  can be extended to a functor  F:
D→C. We shall see in the next section that such  G  and  F  relate in an important way called
adjunction; for the moment we concentrate on the construction of the functor  F.
In this and in the following section, we assume that we are dealing with locally small categories.
5.2.1 Theorem.  Let  G: C→D  be a functor such that  ∀d∈ObD  ∃<ud,cd>  universal from  d  to
G  Then there exists a functor  F: D→C such that
i.   F(d) = cd
ii.  C[F_,_] ≅ D[_,G_].
(Note that  C[F_,_], D[_,G_] : Dop×C→Set). Moreover, the functor F is unique, up to
isomorphism.
Proof:  By assumption we know that, for all  f∈D[d,d'] ,
Set then  F(f) = g,  that is,  ud'°f = G(Ff))°ud .  By the uniqueness property,  G(id) = id.
Moreover, by twice the definition of F,

5. Universal Arrows and Adjunctions
94
And again by unicity of  F(h ° f),  one then has  F(f°h) = F(f) ° F(h).
We need now to define a natural isomorphism  ϕ: D[_,G_] ≅ C[F_,_]. Thus we first need to check,
for a suitable ϕ, that for all  g∈D[d',d]  and  h∈C[c,c']  the following diagram commutes:
Equivalently,
1.  ∀f∈D[d,Fc]  ϕ(G(h)°f°g) = h°ϕ(f)°Fg .
Now write  u (u')  for  ud (ud', respectively).  We know then that  ∀f∈D[d,G(c)]  ∃!f'∈C[F(d),c]
f = G(f') ° u . Define  ϕ(f) = f', that is,  f = G(ϕ(f))°u  (compare with the definition of  F ).  ϕ  is
clearly a set-theoretic isomorphism; thus, we have only to prove the naturality (1).
By the definition of the functors  G  and  F, the following diagram commutes:

5. Universal Arrows and Adjunctions
95
That is,  G(ϕ(f°g))°u' = G(ϕ(f)°F(g) )°u' ,  since  G  is a functor.  By unicity,
2.   ϕ(f ° g) = ϕ(f) ° F(g) .
Moreover,  for all  f∈D[d,G(c)],
by the definition of  G .
Therefore,
    (G(h) ° f ° g) = h ° ϕ(f ° g)
by the diagram and unicity
= h ° ϕ(f) ° F(g)
by  (2).
This proves (1), i.e. the naturality of  ϕ , and by proposition 3.2.3 the proof is completed. ♦
Dually, we have the following:
5.2.2 Theorem.  Let  F: D→C  be a functor such that  ∀c∈ObC  ∃<uc,dc>  universal from  F to
c. Then there exists a (unique) functor  G: C→D  such that
i.   G(c) = dc
ii.  C[F_,_] ≅ D[_,G_] .

5. Universal Arrows and Adjunctions
96
Proof The result follows by duality; anyway we explicitly reprove it, but by using a different
technique from the one used above. As the reader will see, the difference is essentially notational, but
she or he is invited to study both proofs since they are good examples of two common proof styles in
Category Theory.
Let  GOb: ObC→ObD  be the function defined by  GOb(c) = dc, where  uc: F(dc)→c  is the
universal arrow. We have
∀f∈C[F(d),c]  ∃!g∈D[d,GOb(c)]   f = uc ° F(g)
Now define, ∀g∈D[d,GOb(c)]  τd,c(g) = uc ° F(g) .
For every  d∈ObD  and  c∈ObC, τd,c:D[d,GOb(c)]→C[F(d),c]  is clearly a set-theoretic
isomorphism. Note that, ∀h∈D[d',d],
1.  τd',c(g ° h) = uc ° F( g ° h ) = uc ° F(g) ° F(h) = τd,c(g) ° F(h)
By taking  τd,c-1(f)  for  g in (1), we have  τd',c( τd,c-1(f) ° h )  = f ° F(h), or equivalently,
2.  τd,c-1(f) ° h  =  τd,c-1( f ° F(h)  )
For simplicity, we now omit the indexes of  τ  and  τ-1 .
Let  GMor: MorC → MorD  be the function defined by
∀k∈C[c,c']   GMor(k) = τ-1(k  ° uc) ∈D[GOb(c), GOb(c')]
We want to prove that  G = (GOb, GMor)  is a functor:
             G(idc) = τ-1(uc)
= τ-1(uc ° idF(G(c)) )
= τ-1(uc ° F(idG(c)) )
= τ-1( τ(idG(c) ) )
= idG(c)
and, for every  f: c'→c", k: c→c',
            G(f ° k) = τ-1( f ° k ° uc)
= τ-1(f  ° uc' ° F( τ-1(k  ° uc) ) )
= τ-1(f  ° uc')  ° τ-1(k  ° uc) 
by (2)
= G(f) ° G(k)
(1) proves the naturality of  τd,c  in the component  d . We have still to prove the naturality in  c, that
is, ∀g∈D[d,GOb(c)], ∀k∈C[c,c']
3.  τd,c'(G(k) ° g ) =  k ° τd,c(g)
We have:
      τ(G(k) ° g ) = τ( τ-1(k  ° uc) ° g )
= τ( τ-1(k  ° uc ° F(g) ) ) 
by (2)
= k ° uc ° F(g)
= k ° τ(g)     
By taking  τd,c-1(f)  for  g  in (3) we obtain  τd,c'(G(k) ° τd,c-1(f) ) =  k ° f , or equivalently:
4.  G(k) ° τd,c-1(f)  =  τd,c'-1(k ° f).

5. Universal Arrows and Adjunctions
97
(2)  and (4)  state the naturality of  τ-1.
Note that since G must satisfies (4) , then
G(k) = G(k) ° id = G(k) ° τ-1(uc)  =  τ-1(k  ° uc)
which shows that the adopted definition for  G  was actually forced.  This proves the unicity of the
functor G. ♦
5.2.3 Example An interesting example of application of theorem 5.2.2 refers to Cartesian closed
categories.  By the previous section, we know that if C is a CCC, then for all  a,b  in  ObC, (p:
a×b→a, p2: a×b→b)  is universal from  ∆  to  (a,b), and  evala,b: ba×a→b  is universal  from  _×a
to  b. Then the functions  _×_: ObC××××C→ObC  and  _a : ObC→ObC  which respectively take  (a,b)
to  a×b and  b  to  ba, can be extended to two functors  _×_: C××××C→C  and  _a : C→C. The explicit
definition is the following:  for every   f: a→c , g: b→d
(_×_)(f,g) = f×g = < f ° p1, g ° p2 > : a×b→c×d
(_a)(g) = Λ(evala,b ° g) : ba→da
For every object  c  in C, even the unique arrow  !c: c→t  may be seen as universal arrow from the
unique functor  !C: C→1  to  t.  In this case, the extension of the function that takes  1∈Ob1  to  t
to a functor  T: 1→C  is trivial, but it is interesting that the existence of the terminal object  t  in C
may be expressed by the natural isomorphism  1[!C(c)=1 ,1] ≅ C[c,T(1)=t].
5.2.4 Example Consider C, Ct and Inc as in example 5.1.4, and assume that for each object
a∈ObC  there exists the lifting  a°.  By example 5.1.4  we know that  exa: a°→a  is an universal
arrow from the embedding functor Inc: Ct→Cp to a. By theorem 5.2.2 the function _°: ObC→ObC
which takes every object  a  to its lifting a°, may be extended to a functor   _°: Cp→Ct. The explicit
definition of the functor   _°  on a partial arrow  f: b→c  is the following
(_°)(f) = f° = τ(f ° exb)∈Ct[b°,c°]
where  τ(f°exa)  is the only arrow such that  exc ° τ(f°exb) = f°exb.
Note that nearly all the facts about partiality and extendability we proved depend directly on
properties of natural transformations and adjunctions. That is, it was not possible to derive the
properties of the lifting of  b  by assuming just a set-theoretic isomorphism between  Cp[a,b]  and
Ct[a,b°]  for all  a, as one may be tempted at first thought. The expressive categorical notion of
natural transformation turns out to be essential for these purposes.
5.3 Adjunctions
In this section we derive a general notion from the previous constructions and say that the functors  F
and  G  in theorems 5.2.1 and 5.2.2 are “adjoint” to one another. The idea is that an adjunction
establishes a relation between two categories C and D through two functors  F: D→C  and  G:

5. Universal Arrows and Adjunctions
98
C→D; this relation creates a bijective correspondence  ϕ  of arrows in the two categories of the kind
described by the following picture:
5.3.1 Definition  Let  F: D→C  and  G: C→D  be functors. Then an adjunction from D to C is
a triple  <F,G,ϕ>  such that  ϕ: C[F_,_] ≅ D[_,G_]  is a natural isomorphism. F is called left
adjoint of G, and G is called right adjoint of F.
The naturality of the isomorphism  ϕ  deserves to be spelled out.  For any  f∈C[F(d),c], k∈C[c,c']
and  h∈D[d',d], we have
1.  ϕd,c'(k ° f) = G(k) ° ϕd,c(f)
2.  ϕd',c(f °F(h) ) = ϕd,c(f) ° h

5. Universal Arrows and Adjunctions
99
It is equivalent to require that  ϕ-1  is natural, that is, for any g∈C[d,G(c)], k∈C[c,c'] and
h∈D[d',d],
3.  ϕ−1d,c'(G(k) ° g) = k ° ϕ−1d,c(g)
4.  ϕ−1d',c(g ° h) = ϕ−1d,c(g) ° F(h)  .
Examples
1.  Let D, C be partial order categories, and (ObD,≤D), (ObC,≤C) the associated p.o.sets. An
adjunction from D to C is a pair of monotone functions  f: ObD→ObC,  g: ObC→ObD  such that,
for every  d∈ObD , c∈ObC,
f(d) ≤C c   ⇔   d ≤D g(d) .
Consider for example the partial order Z of relative numbers, and the partial order R of real
numbers.  Let  I: Z→R  be the obvious inclusion, and  _: R→Z  be the function that takes a real
number  r  to its lower integer part  r. Then  I  and  _  define an adjunction from  Z  to  R , since
 
1.   I(z) ≤R r   ⇔    z ≤Z  r
Conversely let  _: R→Z  be the function that takes a real number  r  to its upper integer part  r.
Then   _  and  I  define an adjunction from  R  to  Z, since
2.   r ≤Z  z    ⇔   r ≤R I(z)
Note that  _  and  _  are respectively the right and left adjoint to the same functor  I. Note,
moreover, that  _  and  _  are the unique functions that respectively satisfy conditions (1)  and (2)
for all  r  and z.
Another interesting example of adjunctions between partial orders as categories is the following:
consider the p.o.set of positive integers N.  For every natural number  n , let  _ .n : N→N  be the
function that takes a natural numbers  m  to the product  m.n .  The right adjoint  to   _ .n   is the the
function  div(_,n):  N→N  that takes  q to (the lower integer part of)  q divides n .
Indeed, for every m, q,  m.n  ≤ q   ⇔   m  ≤ div(q,n)
Analogously the “minus” operation is right adjoint to “plus.”
2. This further example uses familiar notions and applies the categorical understanding of a
fundamental technique in (universal) algebra. Given a category C of structures and a category D of
slightly more general ones, the right adjoint of the forgetful functor from C to D defines the “free
structures” over the objects in the category D. This technique is widely explained in several places
(see references), so that we just hint at it here.
The category Graph was defined in the example 4.1.5. Recall now that a graph  G  is given by:
- a set  V  of objects (nodes)
- a set  T  of arrows (edges)
- a function  ∂1: T→O  which assigns to each arrow  f   its range  ∂1(f)
- a function  ∂2: T→O   which assigns to each arrow  f   its target  ∂2(f) .

5. Universal Arrows and Adjunctions
100
Morphisms of graphs G, G' are pairs  <f,g>, where  f: T→T'  and  g: V→V'  have the properties in
the example 4.1.5. We already mentioned (see the exercise following that example) that each small
category C may be regarded as a graph G = U(C), just forgetting identities and composition. Of
course,  U  takes objects to nodes and arrows to edges.  Moreover, every functor  F: C→D  gives a
morphisms  H = U(F): U(C)→U(D)  between the associated graphs; the reader should have checked
that  U: Cat →Graph  is actually a (forgetful) functor. Conversely every graph G generates a
category  C = C(G) with the same objects of G, and, for arrows, the finite strings  (f1,...,fn)  of
composable arrows of G, i.e., of arrows in the due types (the empty strings are the identities in
C(G)). Composition in C(G) is just string concatenation, that is,
(f1, . . . ,fn) ° (g1, . . . ,gm) = (f1, . . . ,fn,g1, . . . ,gm) .
Note that  (f1,...,fn) = f1 ° . . . ° fn. The category C(G) is called the free category generated by
G.
This construction may be extended to morphisms of graphs: if H: G→G' then C(H):
C(G)→C(G') is the functor that coincides with H on objects, and that is defined on  morphisms by:
C(H)(f1,...,fn) = (H(f1),... H(fn)).
It is easy to prove that C is a functor from Grph to Cat. Actually, we have an adjoint situation, since
there is an isomorphism  Θ : Cat[C(G), C]  ≅  Grph[G, U(C)]  which is natural in G and C. The
isomorphism Θ takes every functor F: C(G)→C to the morphism Θ(F): G→C, which is the
“restriction” of F on G. For the nature of C(G), every functor F: C(G)→C is uniquely determined
by its behavior on the arrows of G, indeed if (f1,. . . ,fn)  is an arrow in C(G), by definition of a
functor,  F((f1,. . . ,fn)) = F( f1 ° . . . ° fn) = F(f1) ° . . . ° F(fn). This proves that Θ is injective. But
Θ is also surjective, since if  H: G→U(C) , we can define a functor  F: C(G)→C  by  F((f1,. . . fn))
= H(f1) ° ... ° H(fn), and clearly Θ(F) = H. We leave it to the reader to prove the naturality of the
isomorphism.
Exercise  In section 4.3 we turned each Petri net  N  into a monoidal category  C⊗(N) .  Describe
C⊗(N) as a freely generated category.
Exercise  Let C and D be discrete categories (i.e., the only morphisms of the categories are
identities). Prove that  <G,F,τ>: C→D is an adjunction if and only if G and F define an
isomorphism between C and D.
In the previous section, we have actually shown how to construct an adjunction when one can
uniformly obtain a universal arrow  <ud,cd>  from each object  d .  Now we show how to obtain
universal arrows out of an adjunction, and put together the two results.
5.3.2 Theorem.  If  < F: D→C , G: C→D ,ϕ >  is an adjunction from  D to C, then
1. < u =ϕ(idF(d)) : d→G(F(d)) , F(d)>   is universal from  d  to  G

5. Universal Arrows and Adjunctions
101
u   is called  unit  of the adjunction
2. <u'=ϕ−1(idG(c)): F(G(c))→c ,G(c) >   is universal from  F  to  c
u'  is called  counit  of the adjunction.
Conversely,  if  G: C→D  is a functor and (1) holds (or  F: D→C  is a functor and (2) holds), then
<F,G,ϕ >  is an adjunction from D to C.
Proof. (1) is given by theorem 5.1.6 (⇐) and the definition of G. Note that (2) follows dually. The
converse is stated in theorems 5.2.1 and 5.2.2. ♦
Thus, if  < F, G ,ϕ >  is an adjunction, then the functor F of theorem 5.2.1 is the left adjoint of G
and, conversely, G in theorem 5.2.2 is the right adjoint of F. In view of the expressive power of the
notion of adjunction, we can now state in one line some of the concepts we introduced in the
previous chapters.
5.3.3 Corollary  Let C be a category. Then
i.   C has a terminal object iff the unique functor  !C: C → 1  has a right adjoint;
ii.  C has finite products  iff  the diagonal functor has a right adjoint;
iii. C is a CCC  iff it is cartesian  (i.e., !C: C→1  and  ∆∆∆∆ : C→C×C  have right adjoints) and, for
each  a∈ObC, the functor  _×a : C→C  has a right adjoint.
Proof. Immediate by theorem 5.2.2 and the considerations in example 5.2.3. ♦
5.3.4 Corollary  Let C be a category of partial morphisms. The lifting functor  _° : C→Ct is the
right adjoint of the embedding functor  Inc: Ct→C.
Proof  Immediate by 5.2.2 and the considerations in example 5.2.4. ♦
As the reader probably expects, it is also possible to give a fully equational characterization of
adjunctions.
5.3.5 Theorem  An adjunction  <F, G,τ> : C→D  is fully determined by the following data:
- the functor  G: D→C
- a function  f: ObC→ObD  such that, for every object c of C,  f(c) = F(c)
- for every object c of C, an arrow  unitc∈C[c, G(f(c))]
- for every object  c of C and d of D, a function  τc,d-1: C[c,G(d)]→D[f(c),d]
such that, for every h∈C[c,G(d)] and k∈D[f(c),d],
1.  G(τc,d-1(h)) ° unitc  = h ;
2.  τc,d-1(G(k) ° unitc ) = k .

5. Universal Arrows and Adjunctions
102
Proof  The theorem is an immediate consequence of theorems 5.3.2 and 5.1.6. A direct proof is not
difficult, and its study is a good exercise for the reader since it summarizes many of the previous
results. Here it is:
The function  f  may be extended to a functor F by setting, for k∈C[c,c'],  F(k) = τc',d-1(unitc' ° k).
Note that
              F(idc) = τc,f(c)-1(unitc)
= τc,f(c)-1(idG(f(c)) ° unitc)
= τc,f(c)-1(G(idf(c)) ° unitc)
= idf(c) .
by (2)
and moreover, omitting the indexes for notational convenience,
            F(h ° k) = τ-1(unit ° h ° k )
= τ-1( G(τ-1(unit ° h)) ° unit ° k )
by (1)
= τ-1( G(τ-1(unit ° h)) ° G(τ-1(unit ° k)) ° unit ) 
by (1)
= τ-1( G( τ-1(unit ° h) ° τ-1(unit ° k) ) ° unit )
= τ-1(unit ° h) ° τ-1(unit ° k) 
by (2)
= F(h) ° F(k) .
Let now, for every object c of C and d of D,  τc,d: D[f(c),d]→C[c,G(d)]  be the function defined by
τc,d(k) = G(k) ° unitc . Equations (1) and (2) express exactly the fact that  τc,d and  τc,d-1 define an
isomorphism. We have still to prove their naturality. Let  k∈D[d,d'],  h∈C[c,G(d)], h'∈C[c',c],
and  k'∈D[f(c),d] ;  then
nat-1.
  τ-1(G(k) ° h ) = τ-1(G(k) ° G(τ-1(h)) ° unitc  )
= τ-1(G(k ° τ-1(h)) ° unitc  )
=  k ° τ-1(h) ;
nat-2.
       τ-1(h ° k ) = τ-1(G(τ-1(h) ) ° unit ° k )
by (1)
= τ-1(h) ° τ-1(unit ° k )
by (nat-1)
= τ-1(h) ° F(k) ;
nat-3.
   τ(k' ° F(h') ) = τ (τ-1(τ(k')) ° F(k) )
= τ (τ-1(τ(k') ° h')
by (nat-2)
= τ(k') ° h' ;
nat-4.
         τ(k ° k' ) = G( k ° k') ° unit
= G( k ) ° G(k') ° unit
= G( k ) ° τ(k'). ♦
5.3.6 Proposition Let  <F,G,τ>: C→D be an adjunction. Then there exist two natural
transformations  η : IdC→GF  and  ε: FG→IdD  such that, for every c in C and d in D,  η(c)  and
ε(d)  are respectively the unit and counit of the adjunction.
Proof: exercise. ♦

5. Universal Arrows and Adjunctions
103
In other words, one may construct the  unit  and  counit  “uniformely” and naturally.   Observe also
that, if  η : IdC→GF  and  ε: FG→IdD  are the natural transformations in proposition 5.3.6, then the
following diagram commutes:
The previous diagrams fully characterize an adjunction: as a matter of fact many authors prefer to
define an adjunction between two categories  C  and  D  as a quadruple  (F, G, η , ε)  where F:
C→D  and  G: D→C  are functors, and  η : IdC→GF , ε: FG→IdD  are natural transformations
such that
(Gε) ° (ηG) = idG ;
(εF) ° (Fη) = idF .
We leave it as an exercise for the reader to prove the equivalence of this notion with the one we have
adopted. We shall use the definition of adjunction as a quadruple in the next section, since it
simplifies the investigation of the relation between adjunctions and monads.
Exercises
1. An adjointness (F, G, η , ε) from  C  to  D  is an adjoint equivalence if and only if  η  and  ε
are natural isomorphisms.  Prove that given two equivalent categories  C  and  D  (see section 3.2)  it
is always possible to define an adjoint equivalence between them.
2. Given an adjointness  (F, G, η, ε)  from  C  to  D, prove the equivalence of the following
statements:
i.    ηGF = GFη;
ii.   ηG is an isomorphism;
iii.  εFG = FGε;
iv.  εF  is an isomorphism.
5.3.7 Example  In section 3.4 we defined the CCCs of limit and filter spaces, L-spaces and FIL
respectively, which generalize topological spaces, Top.  The functorial “embeddings” mentioned in
that example are actually adjunctions.  Recall that  H : Top → FIL  is given by
H((X,top)) = (X,F)  where  F(x)  = {Φ |  Φ  is a filter  and  ∀0∈top (x∈0  ⇒  0∈Φ)}.
H(f) = f  by the definition of continuity. H  has a left adjoint  T : FIL → Top  defined by
T((X, F)) = (X,top)   where  0∈top  iff   ∀x∈0  ∀Φ∈F(x)   0∈Φ .
Also in this case, filter continuity corresponds to topological continuity, i.e., T(f) = f . The reader
may easily define the natural isomorphism  τ .

5. Universal Arrows and Adjunctions
104
In general, limits are not unique in filter spaces. A stronger notion of convergence, to be used for
computability (see the final remark in section 8.4), may be given as follows. For (X,F) in FIL
consider  (X,top)  = T((X, F))  and define
(s-conv.)
Φ↓sx  iff  Φ∈F(x)  and  ∀0∈Φ∩top  x∈0 .
Then  top  is T0  iff s-convergent filters have a unique limit.
Let  N = (ω, F)  be the natural numbers with the filter structure induced by the discrete topology
and  M = NN. With some work (see references) one can show that  MM  is not topological, i.e. for
no  (X,top)  one has  MM = H((X,top)). The idea is that each topological filter space has a least filter
for each  F(x), the neighborhood filter at x; deduce from this that the associated adjointness
(T,H,η,ε)  to  (T,H,τ)  is not an adjoint equivalence (which one of  η  and  ε  is not a natural
isomorphism?).
Exercises (based on the previous example and exercises)
1. Consider the full subcategory of FIL given by the filter spaces  (X,F)  such that, for each x, there
is a least  Φ∈F(x). Give an adjoint equivalence between  Top  and this category.
2. Check that the functors between L-spaces and FIL defined in the exercise in section 3.4.2 yield
an adjunction, which is not an adjoint equivalence.
3. Give directly an adjunction between Top and FIL, and compare the definition with the adjunction
obtained by composition of functors. (Hint for the direct construction:  given an L-space (X,↓),
define  (X,top)  by  0∈top  iff  ∀x∈0, ∀{xi}↓x,  {xi}⊆ 0  eventually.  Conversely, for  (X, top)
topological space, define  (X,↓)  by  {xi}↓x   iff   ∀0∈top  (x∈0  ⇒  {xi}⊆ 0  eventually).
5.4 Adjunctions and Monads
In this section we study the relation between two seemingly distant concepts as adjunction and
monad. As a matter of fact, every adjunction immediately defines a monad, and conversely every
monad can be thought of as generated by an adjunction, called a resolution for the monad (see
5.4.2 below).  Resolutions for a given monad can be build up in a category by introducing a natural
notion of morphism between them; it then happens that the Eilenberg-Moore and the Kleisli
Categories associated with the monad (see definitions 4.2.3 and 4.2.4) are respectively the terminal
and initial object of the category.
The presentation is rather technical; at first reading, the reader may just look at the first theorem,
which will be applied in the next section.
5.4.1 Proposition  Let  (F, G, η , ε)  be an adjunction from C to D; then  (T = GF, η , µ = GεF)
is a monad on C and  (T = FG, δ = GηF, ε)  is a comonad.

5. Universal Arrows and Adjunctions
105
Proof Note first that  GF, η, and GεF have the correct types, i.e.,  T = GF: C→C, η: IdC→GF,
and µ = GεF: GFGF→GF.  We must prove the unity and associative laws for the monad.
As for the unity laws we have
µ ° Tη  = GεF ° GFη = G(εF ° Fη) = G(idF) = idGF
µ ° ηT  = GεF ° ηGF =  (Gε ° ηG)F = idG(F) = idGF
For the associative law, note first that
ε ° εFG = ε ° FGε .
Indeed, for any  d∈ObD , and letting  f = εd: FG(d)→d,
    εd ° εFG(d) = f ° εFG(d)
= εd ° FG(f)
by naturality of  ε
= εd ° FG(εd)
Then one has the following:
             µ ° µT = GεF ° GεFGF
= G(ε ° εFG)(F)
= G(ε ° FGε)(F)
= GεF ° GFGεF
= µ ° Tµ .
The rest is an exercise in duality. ♦
5.4.2 Definition   Let  (T, η , µ)  be a monad over a category C. A resolution for (T, η , µ) is a
category D and an adjunction  (F, G, η , ε)  from C to D such that  T = GF  and  µ = GεF. A
morphism between two resolutions (F, G, η , ε): C→D  and (F', G', η , ε'): C→D'  (for the
same monad) is  a functor  H: D→D'  such that  F' = H ° F, G = G' ° H , and  Hε  =  ε'H.
It is easily proved that resolutions with the associated morphisms form a category. Now we are going
to prove that the Eilenberg-Moore and Kleisli categories associated with a monad (T, η , µ) both give
rise to resolutions. In particular, they are respectively the terminal and initial objects in the category of
all resolutions for that monad.
5.4.3 Proposition  Let  (T, η , µ)  be a monad over a category  C , and let  CT  be the Eilenberg-
Moore category associated with the monad. Then there exists a resolution for  (T, η , µ) which is an
adjunction from  CT to C.
Proof  Let  UT: CT→C  be the forgetful functor that takes every algebra  (c,α)  to  c, and every
morphism of algebras  h  to the same  h  regarded as a morphism in C. Let  FT: C→CT be the
functor which takes every object  c  to its free algebra (T(c),µc), and every morhism  f: c→c' to
FT(f) = T(f). Let  εΤ: FTUT→idCT  be the natural transformation defined by  εΤ(c,α) = α  (note
that  α: T(c)=FTUT(c,α)→c). We want to prove that  (FT, UT, η , εT) is a resolution for (T, η , µ).

5. Universal Arrows and Adjunctions
106
Obviously  UT ° FT = T . UT εT FT = µ, since for any object  c  one has
 (UT εT FT)(c) = UT(εT FT(c))
= UT(εT(T(c), µc))
by def. of  FT
= UT(µc)
by def. of  εT
= µc
by def. of UT
We still haveto prove that  (FT, UT, η , εT)  is an adjunction from  CT to  C, that is,
(UTεT) ° (ηUT) = idUT
(εTFT) ° (FTη) = idFT
One has, for every T-algebra (c,α),
     (UTεT ° ηUT) (c,α) = UT(εT(c,α) ) ° ηUT(c,α)
= α ° ηc
by def. of εT and UT
= idc 
by def. of T-algebra
And for every c∈ObC :
          (εTFT ° FTη) (c) = εTFT(c) ° FT(ηc)
= µc ° T(ηc) 
by def. of εT and FT
= idT(c)
by the unity law of the monad.♦
We say that the resolution  (FT, UT, η , εT) from C to the Eilenberg-Moore category CT, and given
by proposition 5.4.3, is associated with CT.
5.4.4 Proposition  Let  (T, η , µ)  be a monad over a category  C .Then the resolution  (FT, UT,
η, εT): C→CT, associated with the Eilenberg-Moore Category CT, is a terminal object in the
category of all the resolution for the monad (T, η , µ).
Proof  Let  (F, G, η , ε): C→D   be another resolution for (T, η , µ). We must prove that there
exists a unique arrow from  (F, G, η , ε)  to  (FT, UT, η , εT). Remember (cf. definition 5.4.2) that
such an arrow  is a functor  H: D→CT , such that  FT = H ° F, G = UT ° H , and  Hε  =  εTH.
Define, for any object  d, and any morphism  f  of  D,
H(d) = (G(d), G(ε(d)) )
H(f) = G(f).
Then one has, for any c∈ObC, any h∈MorC,
H(F(c)) = (G(F(c)), G(ε(F(c))) ) = (T(c), µc) = FT(c)
H(F(h)) = G(F(h)) = T(h) = FT(h)
that proves the equality  H ° F = FT.
Moreover, for any d∈ObD, and any f∈MorD,
UT(H(d)) = UT(G(d), G(ε(d)) ) = G(d)
UT(H(f)) = UT(G(f)) = G(f),  as  UT  is the identity on morphisms.
That proves the equality  G = UT ° H .

5. Universal Arrows and Adjunctions
107
Finally, for any d∈ObD,
εTH(d) = εT(G(d), G(ε(d)) ) = G(ε(d)) = H(ε(d))
that proves the equality  Hε = εTH.
We have still to prove that  H is the unique morphism from  (F, G, η , ε)  to  (FT, UT, η , εT).
Let  H'  be another morphism; then, for any f∈MorD,
H'(f) = UT(H'(f) = G(f) = UT(H(f) = H(f)
and, for any d∈MorD,
               H'(d) = ( UT(H'(d), εTH'(d))
by def. of UT and εT
= ( G(d), H'(εT(d)) )
as  G = UT ° H'
= ( UT(H(d), H(εT(d)) )
as  H'(f) = H(f)
= ( UT(H'(d), εTH(d))
= H(d).
This completes the proof. ♦
The unique functor to  (FT, UT, η , εT)  in the category of all resolutions for a given monad (T, η ,
µ)  is called comparison functor and it is usually denoted by  KT.
The category of resolutions of a monad has also an initial object, which is based on the Kleisli
category associated with the monad.
5.4.5 Proposition  Let  (T, η , µ)  be a monad over a category C, and let CT be the Kleisli
category associated with the monad. Then there exists a resolution for  (T, η, µ) that is an adjunction
from  CT  to  C.
Proof:  Let  UT: CT→C  be the functor defined by the following:
for any object  c  of  CT (i.e., of C ), and any morphism  h∈CT[c,c']  (and thus  h∈C[c,Τ(c')])
UT(c) = T(c);
UT(h) = µc' ° T(h).
Let  FT: C→CT be functor defined by the following:
for any object  c  of C, and any morphism  f∈C[c,c']
FT(c) = c;
FT(f) = ηc' ° f  ( = T(f) ° ηc ).
Let  εΤ: FTUT→id  be the natural transformation defined by the following:
for any object  c  of CT
εΤ(c) = idT(c)   (in C).
We want to prove that  (FT, UT, η , εT): C→CT  is a resolution for (T, η , µ).
Obviously, UT ° FT = T .
Moreover,  UT εT FT = µ, since for any object  c  one has
 (UT εT FT)(c) = UT(εT (c) )  
by def. of  FT

5. Universal Arrows and Adjunctions
108
= UT(idT(c))  
by def. of  εT
= µc.
by def. of UT
We have still to prove that  (FT, UT, η , εT)  is an adjunction from  C to  CT, that is,
(UTεT) ° (ηUT) = id: UT→UT
(εTFT) ° (FTη) = id: FT→FT
One has, for every object  c of CT:
        (UTεT ° ηUT) (c) = UT(idT(c)) ° ηT(c) 
by def. of εT and UT
= µc ° T(idT(c)) ° ηT(c)
by def. UT on morphisms
= µc ° ηT(c)
as T is a functor
= idc.
by the unity law of the monad
And, for every c∈ObC,
          (εTFT ° FTη) (c) = εT(c) ° (ηΤ(c) ° ηc)
by def. of FT
= idT(c) ° (ηΤ(c) ° ηc)
by def. of εT
= µC ° T(idT(c)) ° ηΤ(c) ° ηc
by def. of composition ° in  CT
= µC ° ηΤ(c) ° ηc
= ηc
by the unity law of the monad
= idc
by def. of the identity in CT. ♦
5.4.6 Proposition  Let (T, η, µ) be a monad over a category C. The resolution  (FT, UT, η , εT):
C→CT associated with the Kleisli Category CT is an initial object in the category of resolutions for
the monad (T, η , µ).
Proof  Let  (F, G, η , ε): C→D   be another resolution for (T, η , µ). We must prove that there
exists a unique arrow from  (FT, UT, η , εΤ)  to  (F, G, η , ε), that is a unique functor  K: CT→D,
such that  F = K ° FT, UT = G ° K , and  KεΤ = εK.
Define, for any object c of CT, and any morphism f∈CT[c,c'],
K(c) = F(c);
K(f) = εF(c') ° F(f).
where  c  and  f  are regarded as object and morphism of C.
Then one has, for any c∈ObC, any h∈C[c,c'],
K(FT(c))  =  K(c) =  F(c)
         K(FT(h)) = K(ηc' ° h)
by def. of FT
= εF(c') ° F(ηc' ° h)
by def. of K
= εF(c') ° F(ηc') ° F(h)
as F is a functor
= F(h)
as (F, G, η , ε) is an adjunction
This proves the equality  K ° FT = F .
Moreover, for any object c of CT, and any morphism f∈CT[c,c'],
G(K(c)) = G(F(c)) = T(c) = UT(c)

5. Universal Arrows and Adjunctions
109
           G(K(f)) = G(εF(c') ° F(f)) 
by def. of K
= G(εF(c')) ° G(F(f)) 
as G is a functor
= µc' ° T(f)
as (F, G, η , ε) is a resolution
= UT(f)
by def. of UT
that proves the equality  UT = G ° K .
Finally, for any d∈ObD,
         K(εΤ(c)) = Κ(idT(c)) 
by def. of εΤ
= εF(c') ° F(idT(c)) 
by def. of K
= εF(c')
as  F  is a functor
= εK(c')
by def. of K
that proves the equality  KεΤ = εK.
We have still to prove that  K is the unique morphism from  (FT, UT, η , εT)  to  (F, G, η , ε).
Let  K': CT→D be another morphism; then, for every object  c of CT,
               K'(c) = K'(FT(c)) 
by def. of FT
= F(c)
as  K' ° FT = F
= K(FT(c)) 
as  K ° FT = F
= K(c)
by def. of FT
and, for any f∈CT[c,c'],
               K'(f) = K'(idc' ° f )
= K'(µc' ° ηT(c') ° f) 
by the unitary law of the monad
= K'(µc' ° T(idT(c')) ° ηT(c') ° f)
= K'(idT(c') ° (ηT(c') ° f) )
by def. of composition ° in CT
= K'(idT(c')) ° K'(ηT(c') ° f) )
as  K' is a functor
= K'(εΤ(c')) ° K'(FT(f)) )
by def. of  εΤ and  FT
= εK'(c') ° F(f)
as K'εΤ=εK' and F=(K'°FT)
= εF(c') ° F(f)
as K'(c) = K(c) = F(c)
= K(f).
by def. of K
This completes the proof. ♦
For consistency with the terminology adopted for the comparison functor, we shall denote by  KT
the unique arrow from the initial object  (FT, UT, η , εT)  in the category of all resolutions for a
monad  (T, η , µ).
Consider now the comparison functor from the initial to the terminal object. Of course, it must be
KT = KT;  let us check this explicitly.
For any object c in CT,
              KT(c) = (UT(c), UT(εΤ(c)) )
by def. of KT
= (T(c), µc ° T(idT(c)) )
by def. of  UT  and εΤ

5. Universal Arrows and Adjunctions
110
= (T(c), µc)
= FT(c)
by def. of FT
= KT(c).
by def. of KT
And for any morphism f∈CT[c,c'],
              KT(f) = UT(f)
by def. of KT
= µc' ° T(f) 
by def. of UT
= εΤ(T(c'), µ(c')) ° T(f)
by def. of εΤ
= εΤFT(c') ° FT(f)
by def. of FT
= KT(f) .
by def. of KT
Exercises
1. Prove that the comparison functor  KT = KT : CT→CT  is full and faithful.
2. Prove that the Kleisli Category is isomorphic to the full subcategory of CT consisting of all free
algebras.
5.5 More on Linear Logic
In this section, we complete an introductory presentation of linear logic and its categorical meaning,
initiated in section 4.4. As already mentioned, the leading idea of this system refers to the “linear” use
of “resources” or logical assumptions. From assuming A, one derives less than from assuming A, A,
i.e., twice A . The logic-oriented reader, mostly used to classical or intuitionistic reasoning, may find
this a little strange. Probably, though, this habit hides a nonconstructive view which may result in a
limitation of our understanding of effective processes.  Indeed, the alternative approach proposed by
linear logic, which enriches and complements the traditional ones, seems to suggest formalizations
and understanding of processes, such as parallel ones, which have so far escaped to a description by
usual tools (see the examples on monoids and Petri nets in section 4.3 and the references, for recent
developments of this idea).
As the reader may recall, the changes in the structural rules motivate a duplication of the
connectives (see section 4.4). However, there is a way to recover the usual possibility, in classical as
well as in intuitionistic logic, of an iterated use of assumptions. The idea is to introduce a connective
“!” (read “of course”), which allows to assume as (finitely) many times one wishes a given
assumption.  This connective has a categorical meaning, which may be given in the terms of
adjunctions and monads, following the previous section. The interesting categorical significance of
this relation to classical and intuitionistic logic, as well as the categorical understanding we described
in section 4.4, via structures such as the categories Stab and Lin, is probably what makes the
difference between linear logic and previous formal experiments with the structural rules in other
areas of logic.

5. Universal Arrows and Adjunctions
111
The rules below are meant to extend the system in section 4.4. Observe that the structural rules of
weakening and contractions apply with respect to the connective !. This is exactly what it is
introduced for: it is meant to allow copies of assumptions and observe that they lead to the same
consequences.  This is expressed also by the rules  (!,r)  and  (!,l) . Following Girard’s work, we
explicitly introduce the dual “?” (read “why not”), of the connective ! . Its operational behaviour is
described by the rules, which mimic those for  !  on the other side of the entailment (cf. the duality of
(-)⊥ in 4.4.3), and by the equivalence of  !A  and  (?(A⊥))⊥, proved below.
The exponential fragment of Linear Logic is as follows:
5.5.1 exponential unary connectives:  !  (of course), ? (why not)
5.5.2 exponential rules
    Γ |- ∆
   Γ |- ∆
(weak-l)
________
(weak-r)
________
Γ,!Α  |- ∆
Γ |- ?A,∆
Γ,!Α,!Α  |- ∆
Γ |- ?A,?A,∆
(contr-l)
___________
(contr-r)
___________
   Γ,!Α  |- ∆
   Γ |- ?A,∆
Γ, Α |- ∆
!Γ |- A,?∆
(!,l)
________
(!,r)
________
Γ,!Α |- ∆
!Γ |- !A,?∆
 !Γ, Α |- ?∆
Γ |- A,∆
(?,l)
_________
(?,r)
_______
!Γ,?Α  |- ?∆
Γ |- ?A,∆
The duality between  !  and  ?  is easily obtained by the following deductions:
    A |- A
    A |- A
(!,l)
  _______
(⊥,r)
  _______
   !A |- A
  |- A⊥, A
(⊥,l)
  _______
(?,r)
  _______
  !A, A⊥ |-
  |- ?A⊥, A
(?,l )
_________
(!,r)
  ________
 !A, ?A⊥ |- 
  |- !A,?A⊥
(⊥,r)
__________
(⊥,l)
__________
!A |- (?A⊥)⊥ 
(?A⊥)⊥ |- !A

5. Universal Arrows and Adjunctions
112
Exercise  Prove that  !(A∩B)  |- !A ⊗!B  and  !A ⊗!B |-!(A∩B).
5.5.3 Remark The connective  “!”  is exactly what is needed to recover the intuitionistic calculus: it
is possible to prove that there is an embedding of intuitionistic (and classical) logic into linear logic.
The embedding maps every intuitionistic formula  A  to a linear formula  A  in the following way:
A = A     
if  A  is an atomic formula
A∧B = A ∩ B
A∨B = !A ⊕ !B
A⇒B = ! A __o B
( !  is supposed to bind tighter than  __o  and  ∪ ).
The absurdum  F  of intuitionistic is translated into  0, the identity for  ⊕ . Thus  ~A = !A__o0.
In other words, the iterated use of the premises, in a linear implication, gives exactly the intuitionistic
implication. Then, if,  Γ |-i A,  in intuitionistic Logic, then  ! Γ |- A  in Linear Logic.
Our aim now is to give categorical meaning to the connective !, of course. By duality, in linear
categories (see definition 4.4.4), we also obtain an interpretation for  ?, why not.
We have already remarked that a resource such as  !A  can be duplicated and erased, and in a
sense these properties characterize the meaning of the connective ! . Thus, at the sematic level, we
expect to have two morphisms  δ: !A→!A ⊗!A , and   ε: !A→1   where  1  is the identity of the
monoidal category.  (Commutative) comonoids in 4.3.4 seem the right structure for this, as they are
characterized by a sort of diagonal map, such as  δ, and a map  ε  which dualizes the map  η  in
definitions 4.2.1 and 4.3.3.
We start then with a monoidal category C. By definition, C must satisfy certain natural
isomorphisms, given in 4.3.1, which we rebaptize in this section, for convenience, with more
suggestive names
1.  assoc:  X ⊗ ( Y ⊗ Z ) ≅ ( X ⊗ Y ) ⊗ Z
2.  ins-l:  X ≅ 1 ⊗ X 
3.  exch:  X ⊗ Y ≅  Y ⊗ X
Let also:
4.  ins-r = exch ° ins-l : X ≅ X ⊗ 1
As mentioned in section 4.4, the connective of linear implication  __o  is interpreted by the right
adjoint to the tensor product  ⊗ , when C is a monoidal closed category, as defined in section 4.3.
Recall that the category CoMonC of commutative comonoids over a monoidal category C, has
as objects, for c in C, (c, δ: c→c⊗c, ε: c→1), and morphisms  f: (c, δ, ε)→(c', δ', ε'),  for each
arrow  f: c→c'  in C , such that
δ' ° f = (f⊗f) ° δ : c→c'⊗c',
ε' ° f = ε: c→1 .

5. Universal Arrows and Adjunctions
113
Given a commutative comonoid  (c, δ: c→c⊗c, ε: c→1)  observe that the following equations hold:
(ε⊗idc) ° δ = ins-l : c→1⊗c
exch ° δ = δ : c→c⊗c
assoc ° (idc⊗δ) ° δ = (δ⊗idc) ° δ : c→(c⊗c)⊗c .
Exercise As pointed out after definition 4.3.6, if C is Cartesian, in the sense that  ⊗  is actually a
cartesian product  ∩  and the isomorphisms are the canonical ones, then all the maps and
isomorphisms above can be constructed for each object in C (in particular, recall that  δ  and  ε  are
canonically given; namely,  δ = <id,id> : c→c∩c  is the diagonal and  ε: c→t  is the unique map to
the terminal object).  Prove that, if C is Cartesian, then C is actually isomorphic to CoMonC.  Does
the converse hold?
5.5.4 Definition  A ! - model is a linear category C and a comonad  (!,D,E)  such that there
exist natural isomorphisms
I : !(A∩ B) ≅ !(A)⊗!(B)
J : !t ≅ 1
where  t  and  1  are the identities for  ∩  and  ⊗ , the Cartesian and tensor products in C.
Indeed, by definition, in a linear category one has both a monoidal and a Cartesian structure. The
relation established by the natural isomorphisms gives the monoids we need.
5.5.5 Lemma  Let  <C,(!,D,E)>  be an !-model.  Then, for each object  c  in C, there exist maps
δ':!c→!c⊗!c  and  ε': !c→1,  such that  (!c, δ', ε')  is a comonoid.
Proof.  Just set 
δ'= Ι˚!δ : !c →!(c∩c) →!c⊗!c
ε'= Ι˚!ε : !c → !t →1
where  δ = <id,id> : c→c∩c  and  ε: c→t  are the monoidal maps in the remark above, w.r.t. the
Cartesian product  ∩.  The rest is easy.♦
Thus, the comonad  (!: C→C, D: !→!°!, Ε: !→IdC )  associated with a !-model gives all the
ingredients for the interpretation of the connective  !,  of course.  In view of the above lemma, we can
define the functor  !: C → CoMonC  by
!(c) = (!c, δ':!c →!c⊗!c, ε': !c →1) .
This gives the required monoids, while the natural transformations  D  and  E  uniformly yield maps
Dc : !c →!°!c  and  Εc : !c →c,  which are needed to interpret the rules in  (!,r)  and  (!,l).
We already mentioned in section 4.4 that the idea of the interpretation relies on viewing
entailments as morphisms.  In short, observe that, with an informal blend of syntax and semantics,

5. Universal Arrows and Adjunctions
114
the rules
are interpreted by 
the fact that
(weakenings)
each morphism  f: 1→∆
gives a morphism  f˚εa: !a→∆
(contractions)
each morphism  f: !a⊗!a→∆
gives a morphism  f˚δa: !a→∆
(!,l)
each morphism  f: a→∆
gives a morphism  f˚Ea: !a→∆
(!,r)
each morphism  f: !c→a
gives a morphism  !f˚Dc: !c→!a .
As for the rules which contain  ?,  their meaning is easily derivable by duality.  The idea is to define a
functor  ? : C→C  by
 ? = * ˚ ! ˚ *
that is  ?A = (!A*)*. Then the following theorem gives the categorical meaning of the modality  ?,
why not.
5.5.6 Theorem  Let  <C,(!,D,E)>  be an !-model. Then there exist a monad  (?, D': ?˚ ?→?, E':
Id→?)  and natural isomorphisms
I': ?(A⊕B) ≅ ?(A)∪?(B)
J': ?0 ≅ ⊥ ,
where  0  and  ⊥  are the identities for  ⊕  and  ∪,  the duals of the Cartesian and tensor products in
C.
Proof.  Set  ? = * ˚ ! ˚ * : C → C  and, for each object  A,  D'A = (DA*)*  and  E'A = (EA*)*.  As
D: !→!°!,  one has
DA*: !A*→!°!A*
(DA*)*: (!°!A*)*→(!A*)*
by def.of  (-)*
(DA*)*: (!°*°*°!A*)*→(!A*)*
by  Id ≅ (-)**
D'A: ?°?A→?A
Each of these steps is an isomorphism, uniform in  A, and gives a natural transformation  D': ?˚?→?.
Similarly, from  Ε: !→IdC  one has  EA*: !A*→A*  and, thus,  E'A = (EA*)*: A→?A. The
properties required for a monad follow by duality.
As for the natural isomorphisms, compute
          ?(A⊕B) = * ˚ ! ˚ *(A⊕B)
= * ˚ !(A*∩B*)
by theorem 4.4.6

5. Universal Arrows and Adjunctions
115
≅ (!(A*)⊗!(B*))*
by def. of !-model
= ?A∪?B
by theorem 4.4.6.
Finally,  ?0 = * ˚ ! ˚ *0 ≅ * ˚ ! t ≅ 1* ≅ ⊥ ,  by definition and theorem 4.4.6. ♦
Exercise  Endow a structure of monoid over each object in a monoidal category whose tensor
product is actually a Cartesian coproduct. Then give the details of the interpretation of the rules for  ?.
Next we find, within any categorical model of linear logic, an interpretation for the intuitionistic
connectives  ∩  and  ⇒, by using the comonad construction in the !-model. Namely, given an !-
model C, one may interpret intuitionistic “and” and “implication” by Cartesian product and
exponential in a suitable category derived from C. As the purpose of the iterator  !  was to take us
back to intuitionistic logic, we use its categorical meaning to construct this new category.
As a matter of fact, in the remark 5.5.3, we hinted how to derive intuitionistic connectives from
linear ones, once the connective  !  is available.  The following result gives the categorical counterpart
of that construction.
Observe that in general, given a comonad  (T, δ, ε)  over C, the co-Kleisli category K is the
category whose objects are those of C, and the set  K[A,B]  of morphisms from  A  to  B  in K is
C[T(A),B]. The identity in K[A,A] is  εΑ: T(A)→Α. The composition of f∈K[A,B] and g∈K[B,C]
in K is
gof = g ° T(f) ° δA : T(A)→Τ2(Α)→Τ(Β)→C
(see definition 4.2.4 where Kleisli categories over monads were defined).
5.5.7 Theorem  If C be an !-model. Then the co-Kleisli category K associated with the comonad
(!,D,E)  is Cartesian closed.
Proof  (hint) The exponent of two objects  B  and  C  is  (!B__oC). We then have the following
chain of isomorphisms:
            K[A∩B, C] ≅ C[!(A∩B), C] 
by definition of  K
≅ C[!(A)⊗!(B), C]
as !(A∩B) ≅ !(A)⊗!(B)
≅ C[!(A), !B__oC ] 
as C is monoidal closed
≅ K[A, !B__oC ] 
by definition of  K. ♦
Example  In section 2.4.2 we defined the category Stab of coherent domains and stable functions.
In that section (see exercise 4) the subcategory Lin, with linear maps, was also introduced and, later
(see section 4.4), it was given as an example of linear category.  We also defined a function  !  on
coherent domains as follows: if X is a  coherent domain, then  !X  is the coherent domain defined by:
i.   |!X| = {a / a∈X, a finite};
ii.  a↑b [mod !X]  iff  a∪b∈X.

5. Universal Arrows and Adjunctions
116
We need now to extend it to a functor  ! : Stab→Lin. Recall that a linear map  g: Z→Z'  is uniquely
determined by its behavior on the points of the coherent domain  Z,  i.e., on the elements of  |Z|.
Moreover, any stable map may be equivalently described in terms of its trace. Set then, for each
stable map  f : X→Y,
Tr(!f) = {({a}, b)  |  b∈Y,  b  finite, a∈X,  a  finite and least such   b ⊆ f(a) }.
Next, we define an adjunction between  !  and the obvious inclusion functor Inc from Lin into
Stab. This is given by a natural isomorphism
(iso)
ϕ : Lin[!A,B] ≅ Stab[A,B]
where the inclusion functor  is omitted.
Once more we use traces, that is, for each  g∈Lin[!A,B]  set
Tr(ϕ(g)) = {(a, y) |  ({a}, y)∈Tr(g) } .
The reader may prove for exercise the naturality of  ϕ. In particular, the unit and counit of the
adjunction are given, as usual, by
ηA = ϕ(id!A) : A→!A   where  Tr(ηA) = {(a, a) |  a∈A  finite }
εA = ϕ−1(idA) : !A→A   where  Tr(εA) = {({x}, x)  |  x∈|A| }.
Exercise  Check, by actual computations in the structure, that  !f = ϕ−1(ηA˚f)  and  f = ϕ(εA˚!f).
Following theorem 5.4.1,  (!, Inc, η, ε)  yields a comonad
(! = !˚Inc: Lin→Lin, D = !ηInc: !→!°!, Ε = ε: !→IdC )
as required to turn Lin into an !-model.  Moreover, it is a matter of a simple observation on the
“hardware” of coherent domains to show that the isomorphisms needed to complete the definition
hold in Lin, namely, that  !(A∩B) ≅ !(A)⊗!(B)  and  !t ≅ 1  are uniformly valid in this model (see
the example in section 4.4).
Interestingly enough, by (iso) above, Stab is the co-Kleisli category associated with the
comonad  (!, D, Ε)  on Lin.
We conclude this section by identifying a class of categories which yield an interesting interpretation
of the modality  ! . The idea is to interpret  !A  as the commutative comonoid freely cogenerated by A,
not just as a comonoid in the intended linear category.
5.5.8 Definition  Let C be a linear category and U: CoMonC→C be the forgetful functor which
takes  (c, δ, ε)  to  c.  Then C is a free !-model if there exists a right adjoint to U, that is a functor
! : C→CoMonC  and a natural isomorphism  Ω: C[c,a] ≅ CoMonC[(c,δ,ε), !(a)] .
We need to show that free !-models are indeed !-models. This follows from the simple, but
powerful, adjointness property stated in 5.5.8. As already recalled, by proposition 5.4.1, each

5. Universal Arrows and Adjunctions
117
adjunction yields a comonad. We explicitly reconstruct the units and counits as they bear some
information.
5.5.9 Lemma  Let  C be a  free !-model and  <U,!,ΩΩΩΩ>  be the given adjunction. Then, for  ! =
U°!, there exist natural transformations  D: !→!°!   and  Ε: !→IdC  such that
(!: C→C, D: !→!°!, Ε: !→IdC )
is the comonad associated with C, in the sense of proposition 5.4.1.
Proof  By the definition of morphism in CoMonC, for every h∈C[c,a], the morphism Ω(h)∈
CoMonC[(c,δ,ε),!(a)]  satisfies the following equations:
hom-1.   δa ° Ω(h) = ( Ω(h)⊗Ω(h) ) ° δ  : c→!a⊗!a ;
hom-2.   εa ° Ω(h) = ε : c→1 .
Moreover, the naturality of  Ω  is expressed by the following equations:
for every h∈C[c,a] , f∈C[a,b] , g∈CoMonC[(c',δ',ε'), (c,δ,ε)] :
nat-1.   Ω(f ° h) = !(f) ° Ω(h) ;
nat-2.   Ω(h ° U(g)) = Ω(h) ° g .
The counits of the adjunction  (Ω, U, !): CoMonC→C, are arrows  Εc=Ω-1(id!(c)): !c→c.  By
equation (nat-1) above, for h = Εc, we obtain !(f) = Ω(f ° Εc), and by equation (nat-2), Εc ° U(Ω(h))
= h .  The family of arrows  {Εc}c∈C  defines a natural transformation  Ε: (U ° !)→I. Dually the
units of the adjunction define a natural transformation  Η : I→(! ° U), where:  Η(c,δ,ε) = Ω(idc) :
(c,δ,ε)→!c. The adjunction between CoMonC and C is thus equivalently expressed by the
parameters  (U, ! , Η: I→(! ° U), Ε: (U ° !)→ I ).
Remember now that a comonad over a category C is a comonoid in the category of endofunctors
from C to C (with composition as product, see 4.2.2).
By proposition 5.4.1, every adjunction  (F, G, η: IdC→G°F, ε: F°G→IdC')  from C to C'
determines a comonad  (T = F°G, δ = FηG: T→ T°T, ε : T→IdC')  over C'.
In particular the adjunction  (U, ! , Η: I→(! ° U), Ε: (U ° !)→ I ): CoMonC→C, defines a
comonad  (! = U ° ! , D = UΗ! : ! → ! ° ! , Ε : ! →IdC )  over the !-model  C. ♦
Finally we derive the natural isomorphisms in definition 5.5.4.
5.5.10 Theorem  Let  C  be a free !-model and  (!: C→C, D: !→!°!, Ε: !→IdC)  be the comonad
associated with it by the lemma.  Then there exist natural isomorphisms
I: !(A∩B) ≅ !(A)⊗!(B)
J: !t ≅ 1
where  t  and  1  are the identities for  ∩ and  ⊗ , the Cartesian and tensor products in C.
Proof   Consider the comonoid  (!(A)⊗!(B),δ,ε)  where
δ = mix ° (δA⊗δB) : !(A)⊗!(B) → (!(A)⊗!(B))⊗(!(A)⊗!(B))

5. Universal Arrows and Adjunctions
118
ε = ins-r-1 ° (εA⊗εB) : !(A)⊗!(B) → 1
and
mix : (!(A)⊗!(A))⊗(!(B)⊗!(B)) → (!(A)⊗!(B))⊗(!(A)⊗!(B))
is the obvious isomorphism.
Then, by hypothesis, we have an isomorphism
Ω: C[!(A)⊗!(B),A∩B] ≅ CoMonC[ (!(A)⊗!(B),δ,ε), !(A∩B) ]
The isomorphism  IA,B  from  !(A∩B)  to  !(A)⊗!(B), which we write  I for short, is given by
I = (!fst ⊗!snd) ° δA∩B : !(A∩B) → !(A)⊗!(B)
Note that  I  is a morphism of comonoids, that is, as it is easily verified,
δ ° I = (I⊗I) ° δA∩B
ε ° I = εA∩B
The inverse image of  I  is defined in the following way.
Let
k1 = ΕA ° ins-r-1 ° (id!A ⊗ εB): !(A)⊗!(B)→A
k2 = ΕB ° ins-l-1 ° (εA ⊗ idB): !(A)⊗!(B)→B
and
k = <k1, k2> : !(A)⊗!(B)→A∩B
Then the inverse image of  I  is   U(Ω(k)) = Ω(k) : !(A)⊗!(B)→!(A∩B), indeed:
Ω(k) ° I =
= Ω(k ° I)
by (nat-2)
= Ω( <k1, k2> ° I )
by def. of k
= Ω( <k1 ° I, k2 ° I >)
= Ω( <ΕA°ins-r-1°(id!A⊗εB)°(!fst⊗!snd)°δA∩B, ΕB°ins-l-1°(εA⊗idB)°(!fst⊗!snd) ° δA∩B >)
by def. of  k1, k2  and  I
= Ω( <ΕA°ins-r-1°(id!A⊗εA)°(!fst⊗!fst)°δA∩B, ΕB°ins-l-1°(εB⊗idB)°(!snd⊗!snd) ° δA∩B >)
as εB°!snd = εA∩B = εA°!fst
= Ω( < ΕA ° ins-r-1 ° (id!A⊗εA) ° δA ° !fst, ΕB ° ins-l-1 ° (εB⊗idB) ° δB ° !snd >)
as !fst and !snd are comonoid morphisms
= Ω( < ΕA ° !fst, EB °  !snd >) 
by properties of comonoids
= Ω( < fst ° ΕA∩B, snd ° ΕA∩B >) 
by naturality of E
= Ω( ΕA∩B)
= id!(A∩B) . 
by def. of  E
I ° Ω(k) =
= (!fst ⊗!snd) ° δA∩B ° Ω(k)
= (!fst ⊗!snd) ° ( Ω(k)⊗Ω(k) ) ° δ 
by (hom-1)
= (!fst ° Ω(k) )⊗(!snd ° Ω(k) ) ° δ

5. Universal Arrows and Adjunctions
119
= ( Ω( fst ° k) )⊗( Ω( fst ° k) ) ° δ
by (nat-1)
= ( Ω(k1) )⊗( Ω(k2) ) ° δ
by def. of  k
= ( Ω( ΕA ° ins-r-1 ° (id!A ⊗ εB) )⊗( Ω(EB ° ins-l-1 ° (εA ⊗ idB) ) ° δ
by def. of k1 and  k2
= ( ins-r-1 ° (id!A ⊗ εB) )⊗( ins-l-1 ° (εA ⊗ idB) ) ° δ
by (nat-2) and def. of  Ε
= ( ins-r-1 ° (id!A ⊗ εB) )⊗( ins-l-1 ° (εA ⊗ idB) ) ° mix ° (δA⊗δB)
by def. of  δ
= ( ins-r-1 ° (id!A ⊗ εA) )⊗( ins-l-1 ° (εB ⊗ idB) ) ° (δA⊗δB)
by application of  mix
= ( ins-r-1 ° (id!A ⊗ εA) ° δA )⊗( ins-l-1 ° (εB ⊗ idB)  ° δB)
by properties of comonoids
= id!(A)⊗id!(B)
= id!(A)⊗!(B) .
The construction is clearly uniform in  A  and  B.
As for the natural isomorphism  J,  note that  !A ≅ !(A∩t) ≅ !A⊗!t , !A ≅ !(t∩A) ≅ !t⊗!A  and
that the right and left identity, in a monoidal category, are unique. ♦
References  Universal arrows and adjunctions are fundamental notions in Category Theory.
Their treatment, in various forms, and references to their origin may be found in all textbooks we
mentioned in the previous chapters. References for Linear Logic have been given in chapter 4.

6. Cones and Limits
120
Chapter 6
CONES AND LIMITS
In chapter 2, we learned how common constructions can be defined in the language of Category
Theory by means of equations between arrows of given objects. In chapter 4, we saw that those
definitions were based on the existence of an universal arrow to a given functor. The category-
theoretic notion of limit is merely a generalization of those particular constructions, as it stresses their
common universal character. From another point of view, the limit is a particular and important case
of universal arrow, where the involved functor is a “diagonal,” or “constant” functor, as we shall
see. To help the reader become confident with this new notion, we begin this chapter by looking back
at the constructions of chapter 2 and we regard them as particular instances of limits. Then we study
some relevant properties concerning existence, creation, and preservation of limits. As for computer
science, limits have been brought to the limelight mainly by the semantic investigation of recursive
definition of data types: this particular application of the material in this chapter will be discussed in
chapter 10.
6.1 Limits and Colimits
The concept of limit embodies the general idea of universal construction, that is, of an entity which
has a privileged behavior amongt a class of objects that satisfy a certain property. The only way to
define a property in the categorical language is by specifying the existence and equality of certain
arrows, that is, essentially by imposing the existence of a particular commutative diagram amongt
objects inside the category.
6.1.1 Definition  A diagram  D  in a category C is a directed graph whose vertices  i∈I  are
labeled by objects  di   and whose edges  e∈E  are labeled by morphisms  fe.
A diagram D  in C is similar to a subcategory of C; however, it does not need to contain identities,
nor must it be closed under composition of morphisms.
More formally, a diagram in a category  C  should be defined as a graph homomorphism  D
from an index graph  I  to the (graph underlyng the) category  C . Such a diagram is called “of type
I”. For the adjunction between graphs and categories, this is exactly the same as a functor from the
category  I  freely generated by the graph I (the index category)  to C.  A graph is called small when
the index category is small.

6. Cones and Limits
121
6.1.2 Definition.  Let C be a category and  D  a diagram with objects  di, i∈I .  Then a cone to
D  is an object  c  and a family of morphisms  {fi∈C[c,di] | i∈I }  such that
∀i,j∈I  ∀e∈E   fe∈C[di,dj]   ⇒   fe ° fi = fj .
A cone may be visualized by
Cocones are defined dually.
Example  In a partial order P, cones correspond to lower bounds, cocones to upper bounds.
Note now that, given a diagram  D, the cones to  D  form a category, call it  ConesC,D .  Just take
as morphisms from  (c,{fi∈C[c,di] | i∈I})  to  (c',{hi∈C[c',di] | i∈I})  any  g∈C[c,c']  such that
∀i∈I  hi ° g = fi.  That is,
Clearly, ConesC,D   is a category.  Dually one defines the category CoconesC,D .
6.1.3 Definition.  Let C be a category and  D  a diagram. Then a limit for  D  is a terminal object
in  ConesC,D . Colimits are defined dually.
(c,{fi∈C[di,c] | i∈I}) is the initial object in CoconesC,D, it may be visualized by the following
commutative diagram:

6. Cones and Limits
122
Limits are also called universal cones, as any other cone uniquely factorizes via them. Dually,
colimits are called universal cocones.
Examples
1. Let P be a partial order. Then limits correspond to greater lower bounds, while colimits
correspond to least upper bounds.
2. Let  D = ({di}i∈ω, {fi∈Set[di, di+1]}i∈ω )  be a diagram in Set such that di ⊆ di+1, and fi =
incl (the set-theoretic inclusion).  Then the colimit of  d0 →.......di → di+1 →.....   is  ∪{di}
(exercise: what is the limit of the same diagram?) .
Exercise  Prove that the colimits in C are the limits in Cop of the dual diagram.
Consider now a diagram as a functor from an index category  I  to  C.  Note first that any object  c
of the category C is the image of a constant functor  Kc: I→C,  and so  Kc  can be regarded as a
degenerate diagram of type  I  in  C.  Once diagrams are defined as functors, it makes sense to
consider natural transformations between diagrams.  If  D  and  D'  are two diagrams of type I,  a
natural transformation from  D  to  D'  is a family of arrows  fi  indexed on objects in  I  such that for
each arrow e  in  I  (each edge of the graph of type I)
A cone for a diagram  D  of type  I  from an object  c  is then a natural transformation from the
constant  diagram  Kc  to  D

6. Cones and Limits
123
Dually, a cocone for a diagram   D  of type  I  to an object  c is a natural transformation from  D  to
the constant  diagram  Kc .
6.2 Some Constructions Revisited
Let  D  be an empty diagram, that is a diagram with no objects and no arrows.  By definition, a cone
in C to  D  is then just an object  c  of  C,  with no other structure (and every object of C can be seen
as a cone).  A limit for the empty diagram is then an object  t  such that for any other object  c  there is
exactly one arrow from  c  to  t,  i.e., it is a terminal object.  Dually, the initial object is the colimit
of the empty diagram.
A graph is called discrete if it has no arrows.  For example the set  {1,2}  can be regarded as a
discrete graph.  A diagram of type  {1,2}  in a category  C  is an ordered pair of objects,  (c1,c2).  A
limit for such a diagram is an object  d, together with two arrows  f1: d→c1  and  f2: d→c2,  such
that for any other cone  (d',{gi∈C[d',ci] | i∈{1,2} })  there exists exactly one arrow  h: d'→d,  with
fi ° h = gi  for  i∈{1,2}.
But this is just the definition of product  d  of  c1  and  c2  with  f1: d→c1  and  f2: d→c2  as
projections.
Dually, the coproduct  ci#cj,  if it exists, is just the the colimit of the diagram  {ci,cj}.
The product of any indexed collection of objects in a category is defined analogously as the limit
of the diagram  D: I→C  where  I  is the index set considered as a discrete graph.  This product is
usually denoted by  Πi∈IDi,  although explicit mention of the index set is often omitted.
Consider the graph  I  with two vertices and two edges
A diagram of type  I  in a category  C  is a pair of objects,  a  and  b,  and a pair of parallel arrows
f,g∈C[a,b].  A cone for this diagram consists of an object  d,  and two arrows  h∈C[d,a]  and
k∈C[d,b]  such that  g ° h = k  and  f ° h = k.  A limit is a cone  (d,{h,k})  that is universal, that is,
for any other cone  (d',{h',k'})  there exists exactly one arrow  l: d'→d  such that  h ° l = h',  and  k °
l = k'.

6. Cones and Limits
124
Note now that the existence of two arrows,  h  and  k,  such that  g ° h = k  and  f ° h = k,  is
equivalent to the existence of an arrow  h  such that  g ° h = f ° h.  Moreover, h ° l = h' implies   k ° l =
k',  since  k ° l = f ° h ° l = f ° h' = k',  thus the above limit is just the equalizer of  f  and  g .
Dually, coequalizers are the colimits for the same diagram.
Consider now the following graph:
A diagram of this type in a category C is a given by three objects,  a, c,  and  b,  and two morphisms,
f∈C[a,c]  and  g∈C[b,c].  A cone to this diagram is an object  d, together with three morphisms
ha∈C[d,a],  hc∈C[d,c]  and  hb∈C[d,b],  such that the following diagram commutes:
A cone  (d, {ha, hb, hc})  is a limit, if for any other cone  (d', {h'a, h'b, h'c})  there exists a unique
arrow  k: d'→d  such that  h'i = hi ° k,  for  i∈{a,b,c}.
The commutativity of the previous diagram implies that  f ° ha =  g ° hb;  conversely, given two
arrows  ha  and  hb  such that  f ° ha =  g ° hb, one obtains a cone by defining  hc = f ° ha = g ° hb.
Thus, the diagram for the cone  (d, {ha, hb, hc})  is equivalently expressed by giving only the outer
commutative “square”, i.e., by giving  (d, {ha, hb}).  In conclusion, a universal cone for a diagram
of this type turns out to be just a pullback.
As usual, by taking the colimit of the same diagram we obtain the dual notion of pushout.

6. Cones and Limits
125
6.3 Existence of limits
In this secton, we study the important question about the existence of limits in a given category.
Starting with the familiar category of sets, we generalise a common construction that allows the
existence of complex limits to be states, provided that simpler ones exist.
Note first that every diagram  D  has limit in Set.  It is obtained as follows.
Let  {Di}i∈I  be a family of objects in  D  and consider the object  Πi∈IDi,  i.e., the product
indexed by  I.  The elements of  Πi∈IDi  are tuples  {x0, x1, x2, ...}  such that  xi∈Di, for all i∈I,
or equivalently functions f : I→∪i∈IDi, such that  f(i)∈Di .
Πi∈IDi  has projections  pi : Πi∈IDi→Di  for all  i∈I,  defined by  pi({x0,x1,x2, ...}) = xi.  In
general these projections do not form a cone on  D,  that is, if  fe: Di→Dj  is an edge of  D,  one may
have  pj ≠ fe°pi .  The idea is to take the subset  L  of  Πi∈IDi  of all the tuples that satisfy the
condition  pj = fe°pi.  That is,  {x0, x1, x2, ...}∈L  if and only if, for all edges  fe: Di→Dj,  one has
xj = fe(xi).  Let then  γi  be the projection  pi  restricted to  L.  Then  (L,{ γi ∈ C[L,Di] |  i ∈ I})  is
the limit  (prove it as an exercise).
This set-theoretic construction is better formalized in Category Theory in the following way.
Let  Π(Dj / ∃i∈I ∃e∈E fe: Di→Dj )  be the product of all codomains of edges in  D, with
projections  πj: Π(Dj / ∃i∈I ∃e∈E fe: Di→Dj ) → Dj.  By definition of product, there is a unique
function
ψ1: Πi∈IDi→ Π(Dj / ∃i∈I ∃e∈E fe: Di→Dj )
such that  pj = πj°ψ1  for any edge  fe: Di→Dj  of  D.  Analogously there is a unique function
ψ2: Πi∈IDi→ Π(Dj / ∃i∈I ∃e∈E fe: Di→Dj )
such that   fe°pi = πj°ψ2   for any edge  fe: Di→Dj   of  D.
This is visualized in the following diagram:
Note now that, in set-theoretic terms, for all the tuples  {x0, x1, x2, ...}  in  Πi∈IDi  the following
properties are equivalent:
1. for all edges  fe: Di→Dj,   xj = fe(xi)
2. ψ1({x0, x1, x2, ...}) = ψ2({x0, x1, x2, ...})

6. Cones and Limits
126
Then, what we are looking for is the maximal subset  L  of  Πi∈IDi  whose elements satisfy (2), but
we aleady know that this is none other than the equalizer of  ψ1  and  ψ2.  By a diagram,
We are now ready to generalize to every category C the previous construction of limits in Set.
6.3.1 Theorem  Let  D  be a diagram in C with sets  I  of vertices and  E  of edges. If every I-
indexed family and every E-indexed family of objects has a product, and every pair of morphisms
has an equalizer, then  D  has a limit.
Proof Exercise (use the previous diagrams). ♦
6.3.2 Corollary If a category C has arbitrary products, and equalizers for every pair of
morphisms, then every diagram has a limit.
6.3.3 Corollary  If a category C has all finite products, and coequalizers for every pair of
morphisms, then every finite diagram has a limit.
The relevance of theorem 6.3.1 is that, in general, it is simpler to check the existence of products and
equalizers than to prove directly the existence of limits.
Example  Corollary 6.3.2 may be used to prove that every diagram has a limit in CPO.  If  {Ci}i∈I
is a family of c.p.o.’s, let  Πi∈ICi  be the product indexed by  I .  Πi∈ICi  may be given a c.p.o.
structure by the componentwise order, that is,  (ci)i∈I ≤ (di)i∈I  iff  ∀ i∈I  ci ≤ di.  The projections
pi: Πi∈I(Ci)→Ci  are defined by  pi( (ci)i∈I ) = ci .  It is easy to prove that  Πi∈I(Ci)  is indeed a
cpo, that the projections are continuous, and that  Πi∈I(Ci)  satisfies the universal property of the
product.
Given  f,g : A→B , their equalizer is  h: A'→A,  where  A' = {a∈A / f(a) = g(a)}  with the
ordering inherited by  A,  and  h  is the injection.  A'  is a c.p.o.  Indeed, let  D  be a direct subset of

6. Cones and Limits
127
A';  then  D  is also a direct subset of  A,  and thus  f(∪D)= ∪a∈Df(a) = ∪a∈Dg(a) = g(∪D).  By
this,  ∪D∈A'.  The continuity of  h  and the universal property for equalizers are easy to prove.
In propositions 2.5.5 and 2.5.6 we showed how to define products and equalizers from terminal
objects and pullbacks. This suggests an even simpler sufficient (and necessary) condition for the
existence of all finite limits.
6.3.4 Corollary If C has a terminal objects and pullbacks for every pair of morphisms, then it has
all finite limits.
Exercise  State the dual versions of theorem 6.3.1 and corollaries 6.3.1 to 6.3.4.
6.4 Preservation and Creation of Limits
In this section we study some cases of functors which “preserve” the property of objects to be limits
of a diagram.
6.4.1 Definition Let G: A→X be a functor, and let  (a,{τi ∈ A[a,di] | i∈I})  be an universal cone
from  a  on the diagram  D  in  A. We then say that  G  preserves the limit  (a,{τi ∈ A[a,di] |
i∈I}) if and only if  (Ga,{Gτi ∈ X[Ga,Gdi] | i∈I})  is an universal cone from  Ga  on the diagram
G(D)  in  X .  Preservation of colimits  is defined dually.
6.4.2 Theorem  If the functor  G: A→X  has a left adjoint  F: X→A,  and the diagram  D =
({di}i∈I, {fe}e∈E)  in  A has limit  (a, {τi∈A[a,di] | i∈I} ),  then  G(D) = ({Gdi}i∈I, {Gfe}e∈E )
has a limit in X, and the limit is  (Ga,{Gτi∈X[Ga,Gdi] | i∈I}).
Proof By the properties of functors,  ({Gdi}i∈I, {Gfe}e∈E )  is a cone; we only need to prove that
it is universal.  Let  (x,{σi∈X[x,Gdi] | i∈I})  be another cone, and let  ϕ: A[Fx,di] ≅ X[x,Gdi] be
the isomorphism of the adjunction.  Then  (Fx, {ϕ−1(σi)∈A[Fx,di] | i∈I})  is a cone.  Indeed, for all
fe: di→dj  one has
                   fe°ϕ−1(σi) = ϕ−1(G(fe)°σi)
by naturality
= ϕ−1(σj)
because  (σi)  is a cone on  G(D) .
By the universality of  (a, {τi∈A[a,di] | i∈I} )  there exists a unique arrow  h: Fx→a  such that
∀i∈I  τi°h = ϕ−1(σi).  Take then  ϕ(h): x→Ga.  Since  Gτi°ϕ(h) = ϕ(τi°h) = σi,  one has that  ϕ(h)  is
a mediating morphism between the cones  (x, {σi∈X[x,Gdi] | i∈I})  and  (Ga, {Gτi∈X[Ga,Gdi] |
i∈I}).

6. Cones and Limits
128
Moreover,  ϕ(h)  is unique, for, if  ϕ(h')  is another mediating morphism, then  h'  is a mediating
morphism between  (Fx,{ϕ−1(σi)∈A[Fx,di] | i∈I})  and  (a, {τi∈A[a,di] | i∈I} ).  By universality,
h' = h  (see the diagram below). ♦
The proof of theorem 6.4.2 may be visualized by the following commutative diagrams:
Exercise Give the dual statement of theorem 6.4.2 .
An example of application of (the dual of) theorem 6.4.2 is the following.
6.4.3 Theorem  In every Cartesian closed category C, products distribute over colimits.
Proof  Just note that by definition of CCC the functor  -×a: C→C has a right adjoint for each
a∈ObC, and apply the dual of theorem 6.4.2. ♦
6.4.4 Corollary  Let C be a CCC. Suppose, moreover, that it contains an initial object 0, and
coproducts for each pair of objects. Then, for all  X,Y,Z∈ObC, one has
i.   0 x Z ≅ Z
ii.  (X + Y) x Z ≅ (X x Z) + (Y x Z)
Exercises (Huwig-Poigné)  A category C has fixpoints if for every morphism  f: X×X'→X'
there exists a morphism  Y(f): X→X'  such that  f ° <idX,Y(f)> = Y(f).  Prove then the following
facts:
1. CPO has fixpoints.
2. If C is a CCC and it has an initial object  0  and fixpoints, then it is inconsistent , i.e. all objects
are isomorphic.  (Hint: let  t the terminal object, and consider the projection  p2: tx0→0.  Then
Y(p2): t→0.  Deduce from this an isomorhism between  0  and  t ...) .
3. (difficult) If C is a CCC and it has fixpoints and binary coproducts, then C is inconsistent. Hint:
consider the object  2=t+t  and interpret the injection  tt: t→2  and  ff: t→2  as denoting “truth” and

6. Cones and Limits
129
“falsehood.”  Then all finitary truth tables can be expressed by morphisms in  2×2×....×2 →2. The
existence of a fixpoint for “not” induces the following identities:
tt = Y(not) or not(Y(not)) = Y(not) or Y(not) = Y(not)
ff = Y(not) and not(Y(not)) = Y(not) and Y(not) = Y(not)
Hence the injections  tt , ff : t→2  are identified. As, for all objects  X  in C,  X+X = (t×X) + (t×X)
= (t+t)×X , one may deduce the equality of the coproduct injections  u,v: X→X×X  for all  X .  By
this it is easy to obtain the inconsistency.
Fixed points will be widely discussed in chapter 8.  The reader may already understand, though,
that from the point of view of denotational semantics, this is a negative result: coproducts (i.e.
disjoint sums) are incompatible with fixed point operators.  As is well known, both constructions are
rather relevant in semantic domains.
Another important case of limit-preserving functor is the hom-functor.
6.4.5 Theorem  Let  C  be a small category. For any object  c∈ObC, the hom-functor hom[c,_]:
C→Set  preserves limits.
Proof:  Consider the diagram  D = ( {di}i∈I, {fe}e∈E)  in C, and let  (a, {τi∈A[a,di] | i∈I} )  be a
limit.  We must prove that the diagram  S = ({hom[c,di]}i∈I, {fe ° _}e∈E )  has a limit in Set.
Take  L = (hom[c,a],{τi ° _ : hom[c,a]→hom[c,di] | i∈I})  as a limit.
Since  hom[c,_]  is a functor,  L  is a cone for  S.  We have only to prove that it is universal.
Suppose then that  L' = ( X, {γi : X→hom[c,di] | i∈I})  is another cone for  S.  This means that for
any  fe: di→dj,  and any  x∈X,  fe ° γi(x) = γj(x).  For any  x∈X,  ( c, {γi(x): c→di | i∈I})  is then a
cone for  D, and by universality of  (a, {τi∈A[a,di] | i∈I} ), there exists a unique morphism  hx:
c→a  in C  such that  γi(x) = τi ° hx  for all  i.  Define then  h: X→hom[c,a]  by  h(x) = hx.  We have
(τi ° _) ° h = γi,  since for every  x∈X ,  τi ° h(x) = τi ° hx = γi(x).  Unicity follows by unicity of  hx
for any x. ♦
Exercise Use theorem 6.4.5 and prove theorem 6.4.2 in case the categories considered are small.
4.6 Definition  A functor  F: A→X  creates limits for a given diagram D if, whenever  (x,
{σi∈X[x,F(di)] | i∈I})  is a limit for  F(D)  in X, then there exists a unique cone  (a, {τi ∈A[a,di] |
i∈I})  over  D  in  A, such that  F(a) = x  and  F(τi ) = σi   for every  i∈I,  and  (a,{τi ∈ A[a,di] |
i∈I})  is a limit.
Example The forgetful functor  U  from Grp to Set creates all limits.  For instance, the fact that it
creates products is another way of stating that, given two groups  G  and  G',  there is a unique
group structure on  U(G)×U(G'), which gives their product in Grp.

6. Cones and Limits
130
6.5 ωωωω -limits
An important case of diagrams in a category C is that of infinite chains of objects.  These diagrams,
and the associated limits, are particularly relevant for the denotational semantics of programming
languages, since they provide the base for the solution of recursive domain equations with the so-
called least fixed point technique (see chapter 10)
6.5.1 Definition
i) An ωωωω-diagram in a category C is a diagram with the following structure:
(dually, one defines ωωωωOP-diagrams by just reversing the arrows).
ii.  A category C is ωωωω-complete (ωωωω-cocomplete) iff it has limits (colimits) for all ω-diagrams.
iii. A functor  F: C→C  is ωωωω-continuous iff it preserves all colimits of ω-diagrams.
If C is a partial order then,
i.   an ω-diagram in C is an ω-chain
ii.  C is ω-cocomplete if and only if C is a cpo
iii. a functor  F: C→C  is ω-continuous iff the associated function on object of C is continuous.
6.5.2 Theorem  Let C be a category with initial object  0.  Let  F: C→C  be an ω-continuos
(covariant) functor and  z∈C[0,F(0)]  be the unique arrows defined by the initiality of  0.  Assume
also that   (c, {τi∈C[Fi(0),c]i∈ω})  is a colimit for the ω-diagram  ({Fi(0)}i∈ω , Fi(z)}i∈ω ),
where F0(0) = 0  and  F0(z) = z.  Then  c ≅ Fc .
Proof By the hypothesis, one has that  (Fc, {Fτi∈C[Fi+1(0),Fc]i∈ω})  is a limit for
({Fi+1(0)}i∈ω, {Fi+1(z)}i∈ω)  and  (c, {τi+1∈C[Fi+1(0),c]i∈ω})  is a cone for the same diagram.
Thus, by universality, there exists a unique arrow  h: Fc→c  such that  ∀i∈ω  h ° Fτi = τi+1.  Now
add to  (Fc, {Fτi∈C[Fi+1(0),Fc]i∈ω})  the unique arrow  zFc∈C[0,Fc].  This gives a cone for
({Fi(0)}i∈ω, {Fi(z)}i∈ω)  and, by the universality of  (c,{τi ∈ C[Fi(0),c]i∈ω}),  there exists a
unique arrow  k: c→Fc  such that  ∀i∈ω  k ° τi+1 = Fτi  (of course  k ° τ0 = zFc ).  But, then,  ∀i∈ω
h ° k ° τi+1 = h ° Fτi =τi+1  (and  h ° k ° τ0 = τ0),  thus  h°k  is a mediating morphism between  (c,
{τi∈C[Fi(0),c]i∈ω})  and itself.  Thus, by unicity,  h°k = id.
In the same way, one proves that  k ° h = id. ♦
This is all summarized by the following diagram:

6. Cones and Limits
131
Theorem 6.5.2 tells us how to give meaning to recursive definitions of data types under certain
circumstances.  Very informally, assume that types are interpreted as objects of a category.  Then in a
recursive definition  X = [...X...]  of a data type of data  X,  the transformation  [... _ ...]  may be
understood as an endofunctor  F(_)  for which we are seeking a fixed point.  Indeed, if  F  satisfies
the properties in theorem 6.5.2, then the theorem “solves” the equation  (or recursive definition)  X =
[...X...].  In a sense, this construction gives meaning to  X = [...X...],  over a suitable categorical
structure, in the same way that the equation  x = x2+7  is “given meaning” over the complex numbers
by finding a solution for it.
However, the assumptions on  F  are too strong and leave out several significant cases (e.g.,
hom-functors or exponents). Chapter 10 is entirely devoted to a nontrivial extension of this technique
in order to handle a more relevant class of recursive definitions of data types.
References  Main textbooks.

7. Indexed and Internal Categories
132
Chapter 7
INDEXED AND INTERNAL CATEGORIES
7.1 Indexed Categories
In this section we introduce the basic notions of the Theory of Indexed Categories. In order to
improve readability, the following exposition is an (over)simplification of the usual, and more
general, approach. In particular, many of the concepts we define up to equality can be defined up to a
fixed collection of canonical isomorphisms. In this case, the indexed notions introduced in the theory
are required to satisfy a suitable set of coherence conditions, which play a quite marginal role, but
conversely can easily puzzle the reader who is approaching the Theory of Indexed Categories for the
first time. The reader who is interested in more notions in this branch of Category Theory should
consult the References.
7.1.1 Definition  Let CAT be the (meta)category of all categories, and S be a category. An S-
indexed category  is a functor  A: Sop→CAT .
More explicitly, an S-indexed category A is defined by the following data:
i.   for every object s of S, a category A(s), called the category of s-indexed families of objects of A;
ii. for every morphism f: s→s' of S, a functor A(f): F(s')→F(s), called the substitution functor
determined by f, and frequently denoted as f*.
Example A simple but important example is the S-indexing S/: Sop→CAT  of S itself. S/ takes
every object r of S to the comma category S/r. Remember that the objects of S/s are arrows  h: s→r
with codomain  r.  These arrows should be intuitively thought of as families {h-1(i)/ i∈r}.  If  f:
s→s'  is an arrow of  S,  then  f*: S/s'→S/s  is the pulling back functor. Note that pullbacks are
usually defined only up to isomorphism, while we are here implicitly supposing a canonical choice.
As a matter of fact, the pullback and the associated “functor” are the basic examples of notions
profitably defined up to isomorphism, which we mentioned in the introduction.
7.1.2 Definition Let  A, B: Sop→CAT  be two S-indexed categories.
1. The product category  A×B: Sop→CAT  is defined by
A×B(s) = A(s)×B(s)
A×B(f) = A(f)×B(f);
2. The dual category  Aop: Sop→CAT  is defined by
Aop(s) = A(s)op

7. Indexed and Internal Categories
133
Aop(f) = A(f)op
where  A(f)op : A(s')op→A(s)op  is the defined in the obvious way;
3. If  r  is an object of  S, the S-indexed category Ar is defined by
Ar(s) = A(r×s)
A(f) = A(idr×f).
7.1.3 Definition  Let A, B be two S-indexed categories. An S-indexed functor  H: A→B  is a
natural transformation from  A: Sop→CAT  to  B: Sop→CAT.
Thus, an S-indexed functor H: A→B is a collection of functors H(s): A(s)→B(s), for s object of
S, such that for any f: s→s' in S, H(s) ° A(f) = B(f) ° H(s')  (H(s) ° f* = f* ° H(s').
Given two indexed functors H: A→B and K: B→C, their composition K ° H : A→C is defined
component-wise (being the composition of natural transformations), i.e., (K ° H)(s) = K(s) ° H(s).
The identity idA: A→A, is the identity natural transformation from A to A.
7.1.4 Definition  Let  H: A→B, K: A→B, be two S-indexed functors. An S-indexed natural
transformation  τ: H→K consists of a natural transformation  τ(s): H(s)→K(s)  for any object  s
of  S  such that, for any  f: s→s'  in S,
(†)
τ(s) ° A(f) = B(f) ° τ(s')      (τ(s) ° f* = f* ° τ(s')  ) .
The previous definition is more complex than it seems at first sight. Note that  τ(s): H(s)→K(s),
τ(s'): H(s')→K(s')  are natural transformations, while  A(f): A(s')→A(s)  and  B(f): B(s')→B(s)  are
functors. We are thus composing natural transformations and functors in the way described at the end
of section 3.2.  τ(s) ° A(f)  and  B(f) ° τ(s')  are natural transformations of the following type:
τ(s) ° A(f) : H(s) ° A(f) → K(s) ° A(f)
B(f) ° τ(s') : B(f) ° H(s') → B(f) ° K(s').
But, according to the definition of S-indexed functors, for any  f: s→s',  one has  H(s) ° A(f) = B(f) °
H(s')  and  K(s) ° A(f) = B(f) ° K(s'),  thus equation (†) is well typed.
Spelling out the composition of natural transformations and functors in (†), we have for any f:
s→s'  in  S  and any object  a  in  A(s'),
τ(s)A(f)(a) = B(f)(τ(s')a)
where the previous equation holds in the category B(s).
The previous situation can be summarized in the following diagram:

7. Indexed and Internal Categories
134
(Vertical) composition of S-indexed natural transformations is defined componentwise, that is, given
H, K, L : A→B,τ: H→K  and  ρ: K→L, ρ ° τ: H→L  is given by  (ρ ° τ)(s) = ρ(s) ° τ(s).  This is a
good definition since, for any  f: s→s'  in S and any object  a  in  A(s'),
       (ρ ° τ)(s)A(f)(a) =  (ρ(s) ° τ(s))A(f)(a)
=  ρ(s)A(f)(a) ° τ(s)A(f)(a)
=  B(f)(ρ(s')a) ° B(f)(τ(s')a)
=  B(f)(ρ(s')a ° τ(s')a)
=  B(f)((ρ ° τ)(s')a).
7.1.5 Definition Let A, B be S-indexed categories,  H: A→B, K: B→A  be S-indexed functors,
and  η: idA→K°H,  ε: Η°K→idB  be S-indexed natural transformations. <H, K, η, ε> : A→B  is an
S-indexed adjunction if and only if
(Kε) ° (ηK) = idK
(εH) ° (Hη) = idH .
The notion of indexed adjunction is the obvious generalization of the usual notion of adjunction. In
particular it is easy to check that for any object  s  of  S,  <H(s), K(s), η(s), ε(s)> : A(s)→B(s)  is an
adjunction in the usual sense.
The main problem with the definition of adjunction as a quadruple  <H, K, η, ε> : A→B  is in its
generalization of the case with parameters (remember that the definition of exponents requires an
adjunction of this kind). As a triple, an indexed adjunction can be defined in the following, somewhat
informal, way:
7.1.6 Definition  Let A, B be S-indexed categories, and H: A→B, K: B→A be S-indexed
functors.  <H, K, φ> : A→B is an S-indexed adjunction if and only if, for every f: s→s' in S,

7. Indexed and Internal Categories
135
i.   <H(s), K(s), φ(s)> : A(s)→B(s)  is an adjunction
ii.  φ(s) ° B(f) = A(f) ° φ(s')
( φ(s) ° f* = f* ° φ(s')  )
Equation ii expresses the naturality of the isomorphism  φ  with respect to the index  s.  Spelling out
the composition in ii, we can say that for any  f: s→s', a in A(s'), b in B(s'), and g: H(s')(a)→b  in
B(s'),
φ(s)A(f)(a),B(f)(b) (B(f)(g)) = A(f) (φ(s')a,b(g))
Suppose we have an adjunction  <H, K, η, ε> : A→B.  Then we obtain φ in definition 7.1.6 by
letting, for any  a  in  A(s),  b  in  B(s), and  g: H(s)(a)→b  in  B(s),
     φ(s)a,b(g) =  ε(s)b ° H(s)(g)
As we know from chapter 5, for any s in S, φ(s)a,b: B(s)[H(s)(a),b]→A(s)[a,K(s)(b)]  is an
isomorphism. We now prove that the previous definition of  φ(s)  satisfies equation ii in definition
7.1.6. For any  f: s→s',  a  in  A(s'),  b  in  B(s'), and  g: H(s')(a)→b  in  B(s'), we have
     A(f) (φ(s')a,b(g)) =  A(f) (ε(s')b ° H(s)(g)) 
by def. of φ(s')
=  A(f) (ε(s')b) ° A(f) (H(s)(g))
since A(f) is a functor
=  ε(s)B(f)(b) ° H(s)(B(f)(g))
by naturality of ε and H
=  φ(s)A(f)(a),B(f)(b) (B(f)(g))
by def. of  φ(s)
Conversely, given an adjunction  <H, K, φ> : A→B,  we obviously obtain  η, ε  by the following:
η(s)a = φ(s)a,H(s)(a)(idH(s)(a)) : a→K(s)H(s)a
ε(s)b = φ(s)−1K(s)(b),b(idK(s)(b)) : H(s)K(s)b→b.
Definition 7.1.6 has a straightforward generalization to the case with parameters.
7.1.7 Definition  Let  A, B, D  be S-indexed categories, and  H: A×D→B, K: Dop×B→A  be S-
indexed functors.  <H, K, φ> : A→B  is an S-indexed adjunction with parameters in D if
and only if, for every  f: s→s'  in  S,
i.   <H(s), K(s), φ(s)> : A(s)→B(s)   is an adjunction with parameters in D(s);
ii.  φ(s) ° B(f) = A(f) ° φ(s')
( φ(s) ° f* = f* ° φ(s')  ).

7. Indexed and Internal Categories
136
7.2 Internal Category Theory
A category C is small when the collection MorC of its morphisms is a set. Clearly, then, the
collection ObC of objects of C is also a set. Moreover, there are set-theoretic functions DOM,COD:
MorC→ObC  that specify source and target of every morphism, a function  ID: ObC→MorC  that
defines the identity morphism for every object, and a partial function  COMP: MorC×MorC→MorC
for the composition. Given two morphisms f and g, their composition is defined if and only if
DOM(f) = COD(g);  the domain of COMP is thus the set  {(f,g) | DOM(f) = COD(g)},  that is, the
pullback of the two functions DOM,COD: MorC→ObC. All these functions must also satisfy the
obvious equations stating the behavior of the identity morphism with respect to composition, the
associativity law for compositition, and the rules which specify domain and target for the identity
morphism and for the result of a composition. Thus every small category may be completely
described internally  to the category Set, which becomes a sort of “universe of discourse.” The
previous discussion, however, has made very little use of the specific structure of Set; we only
needed the existence of pullbacks in order to define the correct domain of the function COMP. In this
section, we will show that most of the basic definitions of Category Theory, such as category,
functor, natural transformation and so on, can be recasted inside  any category with all finite limits.
This means that any such a category may be considered a fairly big universe inside which we can
carry out constructions with almost the same confidence as we do in Set. This branch of Category
Theory is known as “internal,” since it describes notions of Category Theory by using the categorical
language as a metalanguage.
For many fields of mathematics, from Set Theory to Algebra and Geometry, treatments in the
language of Category Theory, even of well-known results, have never been worthless since most of
the time they created a new, sometimes unexpected, sense of explanation. The same holds for
Category Theory itself: in a sense, Internal Category Theory plays with respect to the general theory
the same role that Category Theory plays with respect to Set Theory. If a notion of Category Theory
cannot be described internally in a simple way, then there is surely something in that notion that is
worth spelling out. As we shall see, this is, for example, the case of the hom-functor and, more
generally, of every presheaf.
Internal Category Theory allows us to work in different universes than Set. This possibility
turns out to be very relevant in several cases, and in particular for the application we aim at in chapter
11, where Internal Category Theory will be applied to the study of categorical models for the
polymorphic lambda calculus. In that case, the possibility of working in more constructive categories
than Set turns out to be essential, as it is known that the standard set-theoretic interpretation of the
first order typed lambda calculus cannot be extended to a model of the second order typed lambda
calculus.

7. Indexed and Internal Categories
137
In the following, E will always denote a category with all finite limits. Our first step is to mimic
within E the presentation, within Set, of a small category. Thus the collections of objects and
morphisms will be viewed as objects of E.
Notation  We write X×0Y (instead of X×ZY) for the pullback of X and Y along morphisms with
common target Z;  <,>0  will be used as a “pullback pairing” map, that is, given (suitable)  h:W→X
and  k:W→Y,  we have  <h,k>0:W→X×0Y;  the pullback projections will be usually (but not
always) denoted by the upper case Greek letter Π, indexed with a number or some other symbol.
7.2.1 Definition c = (c0,c1,DOM,COD,COMP, ID) is an internal category of E (c∈Cat(E))
iff:
c0, c1∈ObE
DOM, COD :  c1 → c0
COMP :  c1 ×0 c1 → c1    where  c1 ×0 c1  is the pullback of  DOM, COD :  c1→c0
ID :  c0 → c1
and moreover

7. Indexed and Internal Categories
138
Note that in the diagram expressing the associativity of composition there is an implicit isomorphism
between  c1×0 (c1×0 c1) and  (c1×0 c1) ×0 c1.  Indeed,
COMP ˚ (COMP ×0 id) :  (c1 ×0 c1) ×0 c1 →  c1
COMP ˚ (id ×0 COMP) :  c1 ×0 (c1 ×0 c1) →  c1.
In the following, this isomorphism will be always skipped in order to maintain the notation at a
simpler level.
7.2.2 Examples  1. Given an object  e  in  E,  the internal discrete category associated with  e
is  (e,e,ide,ide,ide,ide).
2. Let  E  be a CCC with all finite limits, and let  A  be an object of  E.  It is possible to define
internally to  E  a category that plays the role of the category of retractions over  A.
Let  m = Λ( eval ˚ (id×eval) ) : AA×AA →AA  the internal composition map, that is let  m
=λ(f,g).g ˚ f.  Since  E  has all finite limits, it has equalizers for every pair of morphisms. Let then
(X, ξ)  be the equalizer of
id : AA → AA
m ˚ <id,id> : AA →AA
The function  m ˚ <id,id> : AA →AA  is  λf. f ˚ f;  thus the object  X  represents the subset of  AA  of
all those functions  f  such that  f = f ˚ f , i.e., X  is an internalization for the set of retractions in  AA.
X  plays the role of  c0  in the internal category we are defining.
Intuitively, a morphism between two retractions  g  and  h  is a triple  (f,g,h),  where  f  is a
function from  A  to  A  such that   f = h ˚ f ˚ g.
In order to internalize this definition we use the equalizer  (Y,ψ)  of
p1 : AA×X×X → AA
m ˚ (m×id) ˚ < ξ ˚ p3 , p1, ξ ˚ p2 >  : AA×X×X → AA
Note that  m ˚ (m×id) ˚ < ξ ˚ p3 , p1, ξ ˚ p2 >  is just   λfgh. ξ(h) ˚ f ˚ ξ(g).

7. Indexed and Internal Categories
139
COD and DOM are obviously defined by the following equations:
DOM = p2 ˚ ψ
COD = p3 ˚ ψ
For  ID,  note first that by definition of  ξ ,  m ˚ < ξ, ξ > = id ˚ ξ = ξ   and, therefore,
(λfgh. ξ(h) ˚ f ˚ ξ(g) ) ˚ < ξ, id, id > = ξ.
Thus  < ξ, id, id >: X →AA×X×X  equalizes p1  and  λfgh. ξ(h) ˚ f ˚ ξ(g), and  ID: X →Y  is the
unique arrow such that  ψ ˚ ID = < ξ, id, id >.  Note that
DOM ˚ ID = p2 ˚ ψ ˚ ID = p2 ˚ < ξ, id, id > = id
COD ˚  ID = p3 ˚ ψ ˚ ID = p3 ˚ < ξ, id, id > = id.
Finally, we must define  COMP: Y×0Y→Y.  The idea is that  (f,g,h) ˚ (f',k,g) = ( f ˚ f', k, h ).  We
start defining an arrow  M: Y×0Y→ AA×X×X  such that  M((f,g,h), (f',k,g)) =  ( f ˚ f', k, h );  next
we prove that  M  equalizes p1  and  λfgh. ξ(h) ˚ f ˚ ξ(g).  Then COMP is the unique arrow from
Y×0Y  to  Y  such that  ψ ˚ COMP = M.
3. Given a function f: U→C, consider the C-indexed collection of sets {G(c) = f-1(c)}c∈C.  We can
form a small category C, which has C as set of objects, and with hom-sets C[c,c'] =
Set[G(c),G(c')].  Composition and identities are inherited from Set.  The previous construction can
be generalized to a generic topos  E:   given  f: U→C  in  E,  there is an internal category  Full(f) that
plays the role of the full subcategory generated by the fibers of  f.  Full(f)0  is C;  Full(f)1,  together
with the map  <DOM,COD>: Full(f)1→C×C,  is defined as the exponent  p1*(f)p2*(f)  in the slice
category  E/C×C,  where 
p1*(f) = f×id: U×C→C×C
p2*(f) = id×f: C×U→C×C
are respectively the pullbaks of f along the first and second projections. Composition is obtained from
the internal composition map  m: p2*(f)p1*(f)×p3*(f)p2*(f)→p3*(f)p1*(f)  in the slice category
E/C×C×C. Similarly, the identity morphism ID: C→Full(f)1 is obtained from the “inclusion of
identities”  Λ(idf): idC→ff  in the slice category E/C.
Our exposition of Internal Category Theory proceeds with the definition of “internal functor.” Again,
the intuition of a standard functor helps in the understanding of the following definition; a functor  F
between two small categories C and D is a pair of functions in Set, F = (F0, F1), where  F0:
ObC→ObD,  F1: MorC→MorD;  moreover  F1  distributes with respect to composition and
preserves identity.
7.2.3 Definition Let  c,d∈Cat(E).  F  is an internal functor from  c  to  d  (F: c→d)  iff  F =
(f0, f1)  with  f0∈E[c0,d0],  f1∈E[c1, d1],  and  F  satisfies

7. Indexed and Internal Categories
140
7.2.4 Definition The category Cat(E) has as objects the internal categories of E and as
morphisms the internal functors. Composition of functors is defined in the obvious way; that is,
given  F = (f0,f1)  and  G = (g0,g1),  F ˚ G = (f0 ˚ g0, f1 ˚ g1).
For example, Cat(Set) is the category Cat of all small categories, i.e., of all those categories
whose class of morphisms is a set.
It is easy to carry out the usual constructions on categories inside Cat(E). For example, given  c
= (c0, c1, DOM, COD, COMP, ID),  we can define the dual category cop = (c0, c1, COD, DOM,
COMP˚α, ID), where  α = <Π2,Π1>0 : c1×0 c1 ↔ c1×0'c1.  _op : Cat(E) → Cat(E)  is a
functor.
The product of two internal categories c and d is the category c×d = (c0×d0, c1×d1,
DOMc×DOMd, CODc×CODd, (COMPc×COMPd) ˚ β, IDc×IDd)  where β is the isomorphism
(c1×0c1)×(d1×0d1) ↔ (c1×d1)×0(c1×d1).  Clearly,  _×_ : Cat(E)×Cat(E) → Cat(E)  is a
functor.
7.2.5 Definition Let  F = (f0,f1)  and  G = (g0,g1)  be two internal functors from  c  to  d.  τ  is
an internal natural transformation from  F  to  G  (τ: F→G)  iff  τ∈E[c0, d1]   and satisfies

7. Indexed and Internal Categories
141
7.2.6 Definition Given two internal categories  c  and  d,  Nat(c,d)  is the category that has
internal functors from  c  to  d  as objects, and internal natural transformations as arrows.  Given  σ:
F → G  and  τ: G→H,  τ ˚  σ = COMPd ˚  <τ,σ>0  : F → H
7.2.7 Example  In this example we define PER as an internal category of ω-Set. PER  is the
category of partial equivalence relations constructed over Kleene’s applicative structure (ω,.).
Remember that the partial application  . : ω×ω→ω  is defined by  m.n = ϕm(n),  where  ϕ: ω→PR  is
an acceptable gödel numbering of the partial recursive functions. We will use the following notation:
n A m   iff   n  is related to  m  by  A ,
{n}A = {m |  m A n } the equivalence class of  n  with respect to  A,
Q(A) = {{n}A | n ∈ dom(A)}    where  dom(A) = {n/ nAn} .
The morphisms of the category are defined by
f∈PER[A,B]   iff   f : Q(A)→Q(B)  and  ∃n  ∀p  (pAp  ⇒  f({p}A) = {n.p}B ) .
Thus the morphisms in PER are “computable” in the sense that they are fully described by partial
recursive functions, which are total on the domain of the source relation.
Note that PER is a small category, as the partial equivalence relations (p.e.r.’s) form a set as
well as their morphisms; thus Set contains PER as an internal category. Though, since a crucial
property of PER is that its morphisms are “computable,” we are interested in introducing a similar
notion in the category of sets by a realizability relation  “|_”  with respect to numbers.
The category  ωωωω−−−−Set  is defined as follows:
objects:   (A,|_)∈ωωωω−−−−Set  iff
A  is a set and  |_ ⊆ ω×Α,  such that  ∀a∈A ∃n |_ a .
morphisms :  f∈ωωωω−−−−Set[A,B]   iff

7. Indexed and Internal Categories
142
f : A→B  and  ∃n  ∀a∈A ∀p |_A a    n.p |_B f(a)
(notation :   n |_A→B f   and we say that  n  realizes  f ).
Similarly as for PER, each morphism in ωωωω−−−−Set  is “computed” by a partial recursive function,
which is total on   { p |  p |_Aa }  for each  a∈A .
It is not difficult to prove that  ωωωω−−−−Set is a CCC with all finite limits. The terminal object is
simply  (1, |_1) , where  1  is the singleton set and  |_1 = ω×1.  If  [ , ]  is a coding of pairs of
numbers, then  (A×B, |_A×B)  is given by  [n,m] |_A×B (a,b)  iff  n |_A a  and  m |_B b . As for
exponents, let  [A→B] = ({f: A → B | f∈ωωωω-Set [A,B] }, |_A→B), where  |_A→B  is given as
above.
There is a simple way to embed Set into ωωωω-Set.  Let  Σ : Set→ωωωω-Set  be given by
Σ(S) = (S, |_S)   with    |_S = ω×S , the “full” relation.
Σ  is defined as the identity on morphisms, since by the definition of  |_S , all functions are realized
by all numbers for total recursive functions. Σ  is a full and faithful functor, which preserves all finite
limits and exponents.
This embedding suggests how to turn PER into an internal category of  ωωωω-Set  (recall that the
exponent of  A  and  B  in PER is given by   m (A→B) n   ⇔  ∀p,q (p A q  ⇒  m.p B n.q)  ).
Indeed,  M = (Mo,M1,domM,codM,idM,compM)  is defined by
1.  Mo = (PER, |_M)  where  |_M = ω× PER;
2.  M1 = ({<{n}A→B,A,B)> |  A,B∈M, n (A→B) n },  |_1)
where  m |_1 < {n}A→B,A,B>   iff   m (A→B) n ;
3.  domM(<{n}A→B,A,B)>) = A;
4.  codM(<{n}A→B,A,B)>) = B;
5.  idM(A) = <{i}A→A,A,A)>
where  i = λx.x  is a number for the identity function;
6.  compM(<{n}A→B,A,B)>,<{m}B→C,B,C>) = <{b.m.n}A→C,A,C)>
where  b = λxyz.x(yz).
We have to check that M is an internal category of ωωωω-Set.  It will be easy, in view of the set-theoretic
nature of its morphisms. Essentially, one has to prove that the required morphisms are functions that
happen to be realized.
Note first that  ωωωω-Set[A,Σ(S)] = Set[A,S]  for  any  A = (A, |_A)  in ωωωω-Set and any set S, since
|_S  is the full relation and, hence, any function is realized by any index. Thus, the set-theoretic
functions  domM, codM  are also morphisms in ωωωω-Set.
M1 is a set of triples: equivalence class, domain, and codomain. The realizability relation in M1
is nontrivial and, hence, one needs to give explicitly the realizers of  idM  and  compM. Indeed, idM
is realized by  λx.i,  the constant function equal to an index  i  for the identity function.  As for
compM, it is defined as usual only on a subset of  M1×M1, namely, where the target of the first
morphism coincides with the source of the second. In the general setting, this is expressed by the use

7. Indexed and Internal Categories
143
of a pullback as a source object for  COMP. In this specific case, that pullback becomes simply the
set of pairs such as  (<{n}A→B,A,B)>,<{m}B→C,B,C>). Then the realizer for  compM  is  b', for
b'[n,m] = bnm, where  b  is an index for the composition of functions, an operation that may be
uniformly and effectively given over  (ω,.) .
7.3 Internal Presheaves
We have already remarked that every small category may be regarded as an internal category in Set.
However, in Set we are accustomed to considering not only functors from one small category to
another, but also, for example, functors from a small category to a large one and in particular to Set
itself. A significant example is hom-functor from a small category to Set. Surprisingly, it is possible
to cope at the internal level also with this problem, by means of the notion of internal presheaf.
If  F  is a functor from Cop to Set, then the component  FOb  of  F is a collection  {F(c)}  of sets
indexed on objects of  C. Such a collection can be regarded as a function  ρ0: X→ObC,  where   X =
{(c,m)/ m∈F(c)}  and  ρ0(c,m) = c.  Then  FOb(c) ≅ ρ0-1(c).  Now, given an arrow  f: d→c,  and
an object  (c,m)∈ρ0-1(c),  define a function  ρ1  by  ρ1((c,m),f) = (d,F(f)(m)).  The function  ρ1
describes the behavior of  F  on morphisms. Note that  ρ1((c,m),f)  is defined if and only if  cod(f) =
ρ0(c,m) = c;  thus, the domain of  ρ1  is the pullback  Z  (in Set) of  cod: MorC→ObC  and  ρ0:
X→ObC.  Let  Π2: Z→MorC  and  Π1: Z→X,  be the associated projections.  Note that
1. ρ0( ρ1((c,m), f) ) = ρ0( (d,F(f)(m)) ) = d = dom(f) = dom( Π2(f,(c,m)) ) ;
2. ρ1((c,m),f°f') = (d,F(f°f')(m)) = (d,F(f')(F(f)(m))) = ρ1((d',F(f)(m)),f') =
    
= ρ1(ρ1(f,(c,m)),f');
3. ρ1((c,m), idc) = (c,F(idc)(m)) = (c, m).
That is, more concisely:
i.   ρ0 ° ρ1 = dom  ° Π2  : Z→ObC;
ii.  ρ1 ° (idX ×0 comp) = ρ1 ° ( ρ1 ×0 idMorC) : X×0MorC×0MorC → MorC;
iii. ρ1 ° <idX, ID ° ρ0>0 = idX,
where  ×0  denotes pullback product and  ID: ObC→MorC  is the function that takes an object  c  to
idc.  Conversely, given a small category C, and a triple (X, ρ0: X→ObC, ρ1: X×0ObC→MorC )
that satisfies equations i-iii above, it is possible to define a presheaf  F: Cop→Set  by letting
∀c∈ObC
F(c) = ρ0-1(c)
∀f∈C[c',c], ∀(c,m)∈F(c)
F(f)(c,m) = ρ1((c,m),f).
Equation i states that  ρ1((c,m),f)  is in  F(c'),  indeed  c' = dom(f) = dom(Π2((c,m),f)) =
ρ0(ρ1((c,m),f)),  and thus, by definition of  F,  F(f)(c,m)=ρ1((c,m),f)∈F(c').
Equations ii and iii express the fact that  F  is a contravariant functor.  Indeed,
F(f˚g)(c,m) = ρ1((c,m),comp(f,g))
by def. of F
= ρ1( ρ1((c,m),f), g)
by (ii)

7. Indexed and Internal Categories
144
= F(g)( ρ1((c,m),f))
by def. of F
= F(g)(F(f)((c,m)))
by def. of F
and
F(idc)(c,m) = ρ1((c,m), idc) 
by def. of F
= (c,m)
by (iii)
7.3.1 Definition  X  is an internal presheaf on  c∈Cat(E)  iff  X = (X, ρ0, ρ1)  with,
ρ0: X→c0
ρ1: X×0c1→X   where  X×0c1  is the pullback of  ρ0: X→c0  and COD: c1→c0,
and X satisfies the following:
Example Let  c∈Cat(E),  and  e  an object of  E.  The constant-e diagram is the internal presheaves
(e×c0, snd: e×c0→c0, ide×DOM: e×c1→e×c0). Note that  e×c1  is the pullback of  snd: e×c0→c0
and  COD: c1→c0.  Moreover, the previous morphism satisfies the requested conditions of definition
7.3.1, since
i.   snd ° ide×DOM = DOM ° snd : e×c1→c0 ;
ii.  ide×DOM ° (ide×COMP) =
= ide×(DOM ° COMP)
= ide×(DOM ° Π2)

7. Indexed and Internal Categories
145
= ide×DOM ° ( ide×Π2)
= ide×DOM ° ( ide×DOM ×0 id) : e×c1×0c1→e×c0 ;
iii. ide×DOM ° (ide×ID) = ide×c0 : e×c0→e×c0 .
The intuition behind the previous definition is that of a collection, indexed by  c,  of objects  e.
Indeed, consider the case of an internal category C in Set (i.e., a small category) and let E be a set.
By applying the above “externalization,” we obtain
∀c∈ObC
F(c) = ρ0-1(c) = E×{c}
∀f∈C[c',c], ∀(e,c)∈F(c)
F(f)(e,c) = ρ1((e,c),f) = (e,DOM(f)) = (e,c') .
Another major example of a presheaf is given by the hom-functor.
7.3.2 Definition  Let  c∈Cat(E). The internal hom-functor  homc  is the presheaf  (c1, ρ0,
ρ1)  on  c×cop,  where
ρ0 = <DOM,COD> : c1→c0×c0
ρ1 = COMP ˚ < p2 ˚ Π1, COMP ˚ (id ×0 p1) >0 :  c1×0(c1×c1)→c1
(Informally,  ρ1 =  λfgh. h ˚ f ˚  g ),  and
7.3.3 Definition  Let  X = (X, ρ0 ,ρ1), Y = (Y, σ0 ,σ1)  be two presheaves on  c∈Cat(E).  η  is
a morphism of presheaves from  X  to  Y  ( η : X→Y)  iff  η∈E[X,Y]  and the following
diagrams commute:
The following definition allows to compose an internal presheaf on  c  with an internal functor  F:
d→c,  yielding a new presheaf on  d.
7.3.4 Definition Let  X = (X, ρ0, ρ1) be an internal presheaf on c∈Cat(E), and F: d→c be an
internal functor. The pullback of X along F is the presheaf  F*(X) = (Y, σ0, σ1)  on  d  defined
by the following commutative diagrams, where the squares are pullbacks:

7. Indexed and Internal Categories
146
Suppose that the internal presheaf  X “internalizes” the functor  G: Cop→Set  (and  F: d→c  is an
“internalization” for  F: D→C).  Then,  G(F(a)) = {x∈X | ρ0(x)=f0(a)} = {y∈Y | σ0(y)=a}  by
definition of the pullback for  Y,  and, if  h: a→b,  one has  G(F(h)) = λx∈F(b).ρ1(x,f1(h)) =
λx∈F(b).σ1(x,h)  by definition of  σ1.
All the definitions given so far were directed towards the following crucial notion, which will enable
us to define the concept of internal Cartesian closed category.
7.3.5 Definition  < F, G, φ > : c→d  is an internal adjunction from  c  to  d  iff  F  is an
internal functor from  c  to  d,  G  is an internal functor from  d  to  c  and
φ :  (F×Iddop)*(homd) → (Idc×Gop)*(homc)
is an isomorphism between presheaves on  c×dop.
The definition of adjunction in 7.3.5 is now easily generalized to the case with parameters.
7.3.6 Definition  < F, G, φ > : c→d  is an  internal adjunction from  c  to  d  with
parameters in  a  iff  F  is an internal functor from  c×a  in  d,  G  is an internal functor from  aop×d
in  c  and
φ :  (F×Iddop)*(homd) → (Idc×Gop)*(homc)
is an isomorphism between presheaves on  c×a×dop.

7. Indexed and Internal Categories
147
We can also give an “equational” characterization of internal adjunctions, in the spirit of theorem
5.3.5.
7.3.7 Theorem Every internal adjunction  < F, G, φ > : c → d  is fully determined by the
following data in (i) or (ii):
i. 
- the functor G: d→c
- an arrow  f0: c0→d0
- an arrow Unit: c0→c1  such that  DOM ˚ Unit = id , COD ˚ Unit = g0 ˚ f0
- an arrow  φ−1: Y→X, where X and Y are respectively the pullbacks of
<DOM,COD> : d1→d0×d0 ,  f0×id: c0×d0→d0×d0
<DOM,COD> : c1→c0×c0 ,  id×g0: c0×d0→c0×c0
and, moreover, the previous functions satisfy the following equations:
a.  < ρ0, COMP ˚ < g1 ˚ ΠX, Unit ˚ p1˚  ρ0 >0 >0 ˚  φ−1= idY
b.  φ−1˚ < ρ0, COMP ˚ < g1 ˚ ΠX, Unit ˚ p1˚  ρ0 >0 >0  = idX
ii. - the functor F: c→d,
- an arrow  g0: d0→c0,
- an arrow Counit: d0→d1   such that   DOM ˚ Counit = f0 ˚ g0 , COD ˚ Counit = id
- an arrow  φ: X→Y, where X and Y are respectively the pullbacks of
<DOM,COD> : d1→d0×d0 ,  f0×id : c0×d0→d0×d0
<DOM,COD> : c1→c0×c0 ,  id×g0 : c0×d0→c0×c0
and moreover the previous functions satisfy the following equations:
a.  < ρ0', COMP ˚ < Counit ˚ p2˚  ρ0', f1 ˚ ΠY>0 >0 ˚  φ = idX
b.   φ ˚ < ρ0', COMP ˚ < Counit ˚ p2˚  ρ0', f1 ˚ ΠY>0 >0 = idY
Proof  See the appendix to this chapter.
We are finally ready to define internal Cartesian closed categories.
7.3.8 Definition  An internal Cartesian closed category is a category  c∈Cat(E)  with three
adjunctions, the third one with parameter in c:
1.  < O, T, 0 > : c→1 , where 1 is the internal terminal category.
2. < ∆, x, <,>  > : c→c×c , where ∆  is the internal diagonal functor.
3. < x, [,]  , Λ  > : c→c , where this adjunction has parameters in c.
7.3.9 Examples  1. In example 2 in 7.2.2, we defined the internal category RetA∈Cat(E) of
retractions on a generic object A of E, where E is a CCC with all finite limits. We now prove that if A
is a reflexive object, that is, if  AA < A, then RetA is Cartesian closed.

7. Indexed and Internal Categories
148
Let  AA < A  via  (in,out). By theorem 2.3.6 we know that  t < A  and  A×A < A. Call these
retractions  (in',out')  and  (in",out"),  respectively.
Let us begin with the internal terminal object in RetA. The idea is that every constant function is
a terminal object in a category of retractions. Since t < A  via  (in',out'), in': t → A  is a point of A
and, thus, we can take   in'˚ out':  A→A  as the constant function we are looking for;  moreover,  c =
Λ(in'˚ out'˚ p2) : t → AA  is the point in  AA  that represent it.  Then the internal terminal object  t0: t
→ X  is defined by the following:
We leave it to the reader to check the soundness of the previous definition, as well as the definition of
internal products, and we move on to exponents.
The first notion we must define is the arrow  [,]0: X×X→X. The idea is that, given two
retractions  f, g,  their exponent is the retraction  [f,g]0=λa.in(ξ(g)˚out(a)˚ξ(f)).  Let 
H = λ(f,g)λa. in( ξ(g)˚out(a)˚ξ(f) ) :  (X×X)×A→A .
Then  [,]0: X×X→X  is formally defined by the following diagram:
The function  EVAL: X×X→Y  is the internal Counit of the adjunction; it takes two retractions  f
and  g,  and gives a morphism  EVALf,g  from the retraction  [f,g]0x0f  to the retraction  g  (where
x0 is the internal product on objects).  More specifically, if
E = λ(f,g)λa:[f,g]0x0f. out(FST(a))(SND(a)): X×X×A→A
(where  λa:h.M  is shorthand for  λa.[h(a)/a]M,  and FST, SND are the internal projections)
E1 = Λ(E): X×X→AA
E2 = x0˚<[,]0,p1>: X×X→X.
Then  EVAL: X×X→Y  is defined by the following commutative diagram:

7. Indexed and Internal Categories
149
We must now define  ΛΛΛΛ: U → W,  where U and W are the pullbacks in the following diagram:
Informally  ΛΛΛΛ    works on tuples of the kind  (f,g,h, (r, fx0g, h))  where  f,g,h  are retractions and  r
is a morphism from  fx0g  to  h, that is  r: A→A  such that   r = h ˚ r ˚ fx0g.
Now, let  Curry(r) = λy.in( λz.(r ˚ in")(z,y)): A→A.  Then  Curry(r)  is a morphism from  g  to
[f,h]0: indeed, by omitting for simplicity the function  ξ: X→AA,  we have
[f,h]0 ˚ λy.in( λz.(r ˚ in")(z,y)) ˚ g =
= λa.in( h ˚ out(a) ˚ f ) ˚ λy.in( λz.(r ˚ in")(z,g(y)) )
= λy.in( h ˚ λz.(r ˚ in")(z,g(y)) ˚ f )
= λy.in( λz.( h ˚ r ˚ in")(f(z),g(y)) )
= λy.in( λz.(h ˚ r ˚ fx0g ˚ in")(z,y) )
= λy.in( λz.(r ˚ in")(z,y) )
Let  Curry = λr.λy.in( λz.(r ˚ in")(z,y)): AA →AA.
Then  F = < Curry ˚ p1 ˚ ψ ˚ ΠU,  id×[,]0 ˚ σ > : U→AA×X×X .
But we have already verified that
p1 ˚ F = ( λfgh. ξ(h) ˚ f ˚ ξ(g) ) ˚ F
and, thus, there exists a unique morphism  F: U→Y  such that   F =  ψ ˚ F.
Finally   ΛΛΛΛ= <s, F>0 : U → W.
2. This example continues example 7.2.7, where we defined PER as an internal category of the
category ωωωω-Set. We still need to check that the internal category PER of ωωωω-Set is an internal CCC.
In general, observe that in order to “internalize” a categorical construction, as we did for the category

7. Indexed and Internal Categories
150
of retractions, say, one has to turn implicit set-theoretic functional dependencies into morphisms of
the intended global category E.  For example, consider the map  ΛΛΛΛ  that gives the internal natural
isomorphism for Cartesian closure.  Externally,  ΛΛΛΛ  is implicitly indexed by objects  a, b,  for
instance,  and the map  a,b  |_ ΛΛΛΛa,b  is simply a function in Set.  The internal version, requires only
that the map  ΛΛΛΛ, depending also on  a  and  b,  is a morphism in E.
The result, that M is an internal CCC of ωωωω-Set, then follows by the uniformity and effectiveness
of the argument for the Cartesian closure of PER.  Namely, one only has to observe that  evalA,B  is
realized by any index  e  of the partial recursive universal function (and hence we could set   eA,B = e
in the example). Thus, not only  evalA,B  is realized, but the construction is internal to ωωωω-Set as it
depends on  A,B  by a constant function (or  e  is independent of  A, B).  Thuis is also the case for
ΛΛΛΛA,B , since it is uniformly realized by any index of the function s of the s-m-n iteration theorem,
independently of  A, B.
7.4 Externalization
In this section, we define the process of externalization  of an internal category via hom-functors that
correspond, essentially, to the Yoneda embedding.  Since for any object  e  of  E  the hom functor
[e,_]: E→Set  preserves pullbacks, it transforms an internal category  c = (c0, c1, DOM, COD,
COMP, ID)∈Cat(E)  into a small category [e,c] = ([e,c0], [e,c1], [e,DOM], [e,COD], [e,COMP],
[e,ID]).
More generally, if  c∈Cat(E),  then  [_,c]∈Cat(Eop→Set),  and, for the uniform behavior with
respect to the indexes in E, [_,c]  can be also regarded as an E-indexed category, that is, a functor
Eop→Cat.  In the next section we show that, conversely, every E-indexed category can be regarded
as an internal category in  Eop→Set.
7.4.1 Definition  Let  c = (c0, c1, DOM, COD, COMP, ID) ∈ Cat(E), then  [e,c] = ([e,c0],
[e,c1], [e,DOM], [e,COD], [e,COMP], [e,ID]).
The objects of  [e,c]  are the arrows  σ∈ E[e, c0]. Given two objects  σ, τ,  a morphism  f: σ→τ
in  [e,c]  is an arrow  f∈E[e, c1]  such that  DOM ˚ f = σ,  COD ˚ f = τ . The identity of  σ  is  idσ =
ID ˚  σ.  Let  c2  be the object of composable maps of  c,  that is the pullback  c1×0c1  of COD and
DOM. Since the hom-functor  [e,_]: E→Set  preserves pullbacks,  [e,c2]  is the pullback of
[e,COD]  and  [e,DOM],  and  [e,COMP]: [e,c2]→[e,c1]  has the expected type. Given  two arrows
f: σ→τ,  g: τ→γ  in  [e,c],  their composition by  [e,COMP]  is  g o f = COMP ˚ <g,f>0.  In case the
ambient category E has small hom-sets, the category [e,c] is obviously small.
Note that, if  c,d∈Cat(E),  then  [e,c×d] ≅ [e,c]×[e,d]  and  [e,cop] ≅ [e,c]op.

7. Indexed and Internal Categories
151
In the previous definition,  e  can be regarded as a parameter, yielding a functor  [_,c] :
Eop→Cat,  that is, an E-indexed category.
7.4.2 Definition  Let  c∈Cat(E). The functor  [_,c] : Eop→Cat  is defined in the following way:
on objects  e∈E      
[_,c]  = [e,c]
on arrows  σ: e'→e 
[_,c](σ) = [σ,c]  is the functor from  [e,c]  in  [e',c]  that is defined as 
[σ,c0]  on objects and as  [σ,c1]  on arrows.
More explicitly, the functor  [σ,c]  takes every  τ∈[e,c]  (i.e., τ: e→c0)  to  τ ˚ σ,  and every  g: τ→τ'
to  g ˚ σ.
We have to prove as follows that the previous definition makes sense:
1.  ∀σ: e'→e,   [σ,c]: [e,c] → [e',c]  is a functor, for
1.1.  ∀τ: e→c0      [σ,c](idτ )  =  [σ,c](ID ˚ τ )  =  ID ˚ τ ˚ σ  =  idτ o σ
1.2.  ∀f: δ→γ  , ∀g: ρ→δ  in [e,c]
         [σ,c](f o g) = COMP ˚ < f, g > ˚ σ = COMP ˚ < f ˚ σ, g ˚ σ > = [σ,c](f) o  [σ,c](g)
2.  [_,c] : Eop → Cat  is a functor, for
2.1.  ∀e [_,c] (ide) = I : [e,c] → [e,c]   (immediate by definition of [_,c]  )
2.2.  ∀σ: e→e' , ∀τ: e'→e",  [_,c](τ ˚ σ) = [_,c](σ) ˚ [_,c](τ ) : [e,c] → [e",c];  indeed,
2.2.1.  on objects γ∈[e,c]: [_,c](τ ˚ σ)(γ) = γ ˚ τ ˚ σ = [_,c](σ)([_,c](τ )(γ))
2.2.1.  on arrows g τ→τ' in [_,c]:  [_,c](τ ˚ σ)(g) = g ˚ τ ˚ σ = [_,c](σ)([_,c](τ )(g))
Note that if  c = (c0, c1, DOM, COD, COMP, ID)  is an internal category in E, then  ([_,c0], [_,c1],
[_,DOM], [_,COD], [_,COMP], [_,ID])  is an internal category in  Eop→Set.
Definitions 7.4.3 and 7.4.4 show how to externalize, respectively, an internal functor, an internal
natural transformation, and an internal presheaf. Again these definitions, as well as others in the
sequel, are parametric with respect to the object  e  of  E .
7.4.3 Definition  Let  c,d∈Cat(E),  F = (f0,f1): c→d  be an internal functor, and let  e  be an
object of E. The functor  [e,F]:  [e,c]→ [e,d]  is defined as  [e,f0]  on objects, and as  [e,f1]  on
arrows.
That is, the functor  [e,F]: [e,c] → [e,d]  takes every object  σ  in  [e,c]  to  f0 ˚ σ  in  [e,d],  and
every arrow  g: σ→τ  in  [e,c]  to  f1˚ g: (f0 ˚ σ)→(f0 ˚ τ)  in  [e,d].

7. Indexed and Internal Categories
152
7.4.4 Definition  Let  c,d∈Cat(E)  and let  F = (f0,f1): c→d  be an internal functor. The E-
indexed functor  [_,F]:  [_,c]→[_,d]  is the natural transformation defined by  [_,F](e) = [e,F],  for
every object  e  of  E.
We must prove the naturality in  e  of the previous definition; that is, for any  σ: e'→e,
[e',F] ˚ [σ,c] = [σ,d] ˚ [e,F] .
We have, for any object  τ  of  [e,c] (i.e, τ: e→c0),
[e,F][σ,c](τ) =  [e',F](τ ˚ σ)
by def. of [σ,c]
=  f0 ˚ τ ˚ σ
by def. of [e',F]
= [σ,d] ˚ f0 ˚ τ
by def. of [σ,d]
= [σ,d] ˚ [e,F]
by def. of [e,F].
7.4.5 Definition Let   τ: F→G  be an internal natural transformation, where  F,G: c→d.  The
natural transformation  [e,τ]: [e,F]→[e,G]  is defined as the homonimous function  [e,τ]:
[e,c0]→[e,d1];  that is, it takes every object  σ  of  [e,c]  to  [e,τ](σ) = τ ˚ σ : (f0 ˚ σ)→(g0 ˚ σ)
(where the last “typing” is in  [e,c]).
Exercise  Prove that the previous definition makes sense, that is:
1.  [e,τ](σ) : [e,F](σ) → [e,G](σ)
2.  for every  h: σ→γ  in  [e,c],  [e,G](h) o[e,τ](σ) = [e,τ](γ) o[e,F](h).
7.4.6 Definition Let  τ: F→G be an internal natural transformation, where F,G: c→d. The E-
indexed natural transformation [_,τ]: [_,F]→[_,G] is defined by the following: for any object e of E,
[e,τ]: [e,F]→[e,G].
Now we will show how to externalize the notion of morphism of presheaves.
7.4.7 Definition Let X=(X, ρ0, ρ1) be an internal presheaf on c∈Cat(E). The functor [e,X]:
[e,c]op→Set   is defined by:
∀σ∈[e,c] ,  
[e,X](σ) = { f∈E[e,X] / ρ0 ˚ f = σ }
∀g: τ→σ in [e,c], 
[e,X](g) : [e,X](σ)→[e,X](τ)   is given by:
∀f∈[e,X](σ)    [e,X](g)(f) = ρ1˚ <f, g>0 ∈[e,X](τ)
(note that ρ0 ˚ [e,X](g) (f) = ρ0 ˚ ρ1˚ <f,g>0 = DOM ˚ Π2˚ <f,g>0 = DOM ˚ g = τ )
We have chosen the name  [e,X] as an analogy for the previous constructions, but in this case it
no longer has a direct relation with the Yoneda embedding. The same holds below for the
externalization [e,η]  of a morphism of presheaves  η.

7. Indexed and Internal Categories
153
Next we check that by externalizing an internal  homc  on  c×cop  we just obtain the hom-functor
from  [e,c]op×[e,c]  to  Set.
7.4.8 Proposition  Let  c∈Cat(E)  and let  homc = (c1, ρ0, ρ1)  be the internal hom-functor on
c×cop. Then, for every  e∈ObE,  [e,homc] = hom[e,c]: [e,c]op×[e,c]→Set  (to within the implicit
isomorphism  [e,c]op×[e,c] ≅ [e,cop×c] ).
Proof
- on objects:   let  <σ,τ>: e → c0×c0
    [e,homc](<σ,τ>) =  {f: e→c1 /  ρ0 ˚ f = <σ,τ> }
=  {f: e→c1 /  <DOM,COD> ˚ f = <σ,τ> }
=  hom[e,c](σ,τ);
- on morphisms:   let  <f,g> : <σ,τ>→ <γ,δ>  in  [e,cop×c].  ∀h∈[e,homc](<γ,δ>), i.e., for all
h: e→c1  such that   <DOM,COD> ˚ h = <γ,δ>,  we have
[e,homc](<f,g>)(h) =  ρ1 ˚ <h, <f,g>>0
=  COMP ˚ < p2 ˚ Π2, COMP ˚ (id ×0 p1) >0 ˚ <h, <f,g>>0
=  COMP ˚ < g, COMP ˚ <h, f>0 >0
=  g o h o f .  ♦
The next definition finally externalizes the notion of morphism of presheaf that simply becomes a
natural transformation. Proposition 7.4.10 states that the composition of an internal functor with a
morphism of presheaf, given by the pulling back construction of definition 7.3.3, externalizes to the
composition of the two associated external functors.
7.4.9 Definition  Let  η  be a morphism of presheaves from  X = (X, ρ0 ,ρ1)  to  Y = (Y,
σ0,σ1), where X an Y are internal presheaves on c.  The natural transformation  [e,η]: [e,X]→[e,Y]
(where [e,X], [e,Y]: [e,c]op→Set )  is defined in the following way: ∀γ∈[e,c], ∀f∈[e,X](γ),
[e,η](γ)(f) = η ˚ f  (note that  [e,η](γ)(f) ∈[e,Y](γ),  since   σ0 ˚ η ˚ f = ρ0 ˚ f = γ ).
[e,η] is indeed a natural transformation, since, ∀g: τ→γ  in [e,c], ∀f∈[e,X](γ)
    [e,Y](g) ([e,η](γ)(f) ) =  [e,Y](g) (η ˚ f)
by def. of [e,η]
=  σ1 ˚  <η ˚ f, g>0
by def. of [e,Y](g)
=  σ1 ˚  η×0id ˚ <f, g>0
=  η ˚ ρ1 ˚ <f, g>0
by the “naturality” of η
=  η ˚ ([e,X](g)(f) ) 
by def. of [e,X](g)
=  [e,η](τ) ([e,X](g)(f) ) 
by def. of [e,η]

7. Indexed and Internal Categories
154
7.4.10 Proposition  Let  F: d→c  be an internal functor,  X = (X, ρ0, ρ1)  an internal presheaf
on  c,  and  F*(X) = (Y, σ0, σ1).  For every object  e  of E, the functors  [e,F*(X)]  and
[e,X]˚[e,F]op: [e,d]op→Set  are naturally isomorphic.  The isomorphism is
ητ =  λg. ΠX ˚ g  :  [e,F*(X)](τ) → [e,X]([e,F]op(τ))
ητ-1 = λh.<τ, h>0 : [e,X]([e,F]op(τ)) → [e,F*(X)](τ)
Proof  Let us check first that  ητ  and  ητ-1  have the correct types.
By definition  [e,F*(X)](τ) = {g∈E[e,Y] / σ0 ˚ g = τ }.  Let  g∈[e,F*(X)](τ).  Then the following
diagram commutes:
Thus  ΠX ˚ g ∈ [e,X](f0 ˚ τ)  =  [e,X]([e,F]op(τ))
Conversely, let h∈[e,X]([e,F]op(τ)). Then the arrow <τ, h>0: e→Y  is well defined, because ρ0
˚ h = f0 ˚ τ . By definition  of  σ0,  σ0 ˚ <τ, h>0 = τ  which implies  <τ, h>0∈[e,F*(X)](τ).
We now prove the naturality of ητ and ητ-1. Let k: γ→τ  in [e,d]op; for every  g∈[e,F*(X)](τ)
  [e,X]([e,F]op(k))(ητ(g)) =  [e,X]( f1 ˚ k ) (ΠX ˚ g) 
by def. of [e,F]op
=  ρ1˚ <ΠX ˚ g, f1 ˚ k >0
by def. of [e,X]
=  ρ1˚ ΠX×0f1 ˚ < g, k >0
=  ΠX ˚ σ1 ˚ < g, k >0
by def. of ρ1
=  ΠX ˚ ([e,F*(X)](k) (g) ) 
by def. of [e,F*(X)]
 
=  ηγ( [e,F*(X)](k) (g) ) 
by def. of η
Conversely, for every k:  γ→τ  in [e,d]op and every h∈[e,X]([e,F]op(τ)):
[e,F*(X)](k) ( ητ-1(h) )  = σ1 ˚ < ητ-1(h) , k >0 = σ1 ˚ < <τ, h >0 , k >0
Thus:
ΠX ˚ ([e,F*(X)](k) ( ητ-1(h) ) ) =  ΠX ˚ σ1 ˚ < <τ, h >0 , k >0
= ΠX ˚ σ1 ˚ < <τ, h >0 , k >0
= ρ1˚ ΠX×0f1˚ < <τ, h >0 , k >0
= ρ1˚ < ΠX ˚ <τ, h >0, f1˚ k >0
= ρ1˚ < h, f1 ˚ k >0
and
σ0 ˚ ([e,F*(X)](k) ( ητ-1(h) ) ) = σ0 ˚ σ1 ˚ < <τ, h >0 , k >0
= DOM ˚ Π2 ˚ < <τ, h >0 , k >0
= DOM ˚ k
=  γ
And since  f = <σ0 ˚ f, ΠX ˚ f >, then for every f :  e→Y,

7. Indexed and Internal Categories
155
[e,F*(X)](k) ( ητ-1(h) ) = <γ, ρ1˚ < h, f1 ˚ k >0 >0
= <γ, [e,X]([e,F]op(k)) (h) >0
= ηγ-1( [e,X]([e,F]op(k)) (h) ).   ♦
7.4.11 Proposition  Let  < F, G, φ > : c→d  be an internal adjunction. For every  e  in  E, define
Θe = η'˚ [e,φ] ˚ η−1,  where
η :  [e,(F×Iddop)*(homd)]  →  [e, homd] ˚ [e,Fop×Id]
η':  [e,(Idc×Gop)*(homc)] →  [e, homc] ˚ [e,Id×Gop]
are the isomorphisms of proposition  7.4.10 .
Then  <[_,F], [_,G], Θ > : [_,c]→[_,d] is an E-indexed adjunction.
Proof  For every object e of E, we have
hom[e,d][[e,F](_), _ ] =  [e, homd] ˚ [e,Fop×Id]
≅  [e,(F×Iddop)*(homd)]
via  η−1
≅  [e,(Idc×Gop)*(homc)]
via  [e,φ]
≅  [e, homc] ˚ [e,Id×Gop]
via  η'
=  hom[e,c][_, Ee,G(_) ].
Moreover, the previous adjunction is “natural in  e,” that is,
∀f∈E[e',e]   Θe' ˚ [_,d](f)  = [_,c](f) ˚ Θe .
More explicitly, we must check that, for every  f∈E[e',e],  σ object of  [e,c],  τ  object of  [e,d],  and
g: (f0 ˚ σ)→τ  in  [e,d],  one has
Θe' <σ ˚ f, τ ˚ f> ([_,d](f) ) (g) = ([_,c](f) ) Θe<σ,τ> (g)
We have
Θe' <σ ˚ f, τ ˚ f> ([_,d](f) ) (g) = Θe' <σ ˚ f, τ ˚ f> (g ˚ f )
by def. of [_,d]
= Θe' <σ ˚ f, τ ˚ f> (g ˚ f )
= ΠX ˚ φ ˚ <<σ ˚ f,τ ˚ f >, g ˚ f >0 
by def. of Θe'
= ΠX ˚ φ ˚ <<σ,τ>, g >0 ˚ f
= (Θe<σ,τ> (g) ) ˚ f 
by def. of Θe
= ([_,c](f) ) Θe<σ,τ> (g)
by def of  [_,c].   ♦
7.4.12 Exercise  Prove that if  <F, G, φ > : c→d  is an internal adjunction, and Unit and Counit
are the arrows in theorem 7.3.7, than for every object  σ: e→d0  in  [e,d], Unit ˚ σ, Counit ˚ σ  are
respectively unit and counit for  σ  in the associated external adjunction  <[e,F], [e,G], Θe >:
[e,c]→[e,d].

7. Indexed and Internal Categories
156
7.5 Internalization
In this section we show how to translate (small) E-indexed notions to internal ones in the topos of
presheaves  Eop→Set.
7.5.1 Definition  Let  A: Eop→Cat  be an E-indexed category, where all the indexed categories
are small. The internal category  A = (A0, A1, DOM, COD, COMP, ID)∈Cat(Eop→Set)  is defined
as follows: for all objects  e, e'  and arrows  f: e'→e  in E,
-  A0: Eop→Set   is the functor defined by
A0(e) = ObA(e)
A0(f) = A(f)ob : ObA(e)→ObA(e')
-  A1: Eop→Set   is the functor defined by
A1(e) = MorA(e)
A1(f) = A(f)mor : MorA(e)→MorA(e')
- DOM: A1→A0  is the natural transformation whose components are the domain maps in the
local categories, i.e.,  for  e∈ObE,  DOMe: MorA(e)→ObA(e)  is defined by  DOMe(h:σ→τ)
= σ.
-  COD, ID  and  COMP  are defined analogously, “fiberwise”.
The claimed naturality for  DOM, COD, ID, COMP  is immediate, since  A  is a functor.  For
instance, let  f∈E[e',e]  and  h∈A(e)[σ,τ];  then  DOMe'(A(f)mor(h)) = A(f)ob ˚ DOMe(h).  The
reader can check the other cases as an exercise.
7.5.2 Definition  Let  A, B  be two E-indexed categories, and let  H: A→B  be an E-indexed
functor.The associated internal functor  H = (H0,H1): A→B  in Eop→Set,  is defined in the
following way:
- H0: A0→B0  is the natural transformation given by  H0(e) = H(e)ob
- H1: A1→B1  is the natural transformation given by  H1(e) = H(e)mor
The naturality of H0 and H1 is an immediate consequence of the “naturality” of  H: A→B, that is
H(s) ° A(f) = B(f) ° H(s').   The equations in definition 7.2.3 easily follow from the fact that for every
e,  H(e)  is a functor.
7.5.3 Definition  Let  H: A→B, K: A→B  be two E-indexed functors, and let τ: H→K  be an E-
indexed natural transformation. Then the associated internal natural transformation  τ: H→K  in
Eop→Set  is the natural transformation  τ: A0→B1  such that, for any  e  in  E,  and any  a  in  A(e),
τe(a) = τ(e)a.

7. Indexed and Internal Categories
157
Recall that  τ: H→K  consists of a natural transformation  τ(e): H(s)→K(e)  for any object  e  of
E,  such that, for any  f: e→e'  in  E,  and any object  a  in  A(e'),  τ(e)A(f)(a) = B(f)(τ(e')a) .
As a consequence,  τe(A0(f)(a)) = B1(f)(τe'(a)),  which gives the naturality of   τ .
7.5.4 Proposition  Let  A, B  be E-indexed categories,  H: A→B, K: B→A  be E-indexed
functors, and <H, K, φ> : A→B  be an E-indexed adjunction. Then  <H, K, φ = φ> : A→B  is an
internal adjunction in  Eop→Set .
Proof Exercise.
The picture is finally completed by the following result, which shows that by applying the
externalization process of section 7.4 to an internal category  A,  derived from an E-indexed category
A,  we obtain an indexed category equivalent to  A.  However, when we externalize  A,  we do not
want a category indexed over all  functors from E into Set. Since we are interested in a category
indexed over E, we must externalize only with respect to a full subcategory of  Eop→Set  equivalent
to  E. The obvious choice is to consider the image  Y(E)  of  E  under the Yoneda embedding  Y(e) =
E[_, e]  (recall that  Y(E)  is a full subcategory of  Eop→Set ).  We will then obtain an indexed
category  A# : Eop→Cat.  Recall though that the “internalization” can take place only if the indexed
category takes small categories as values, while internal categoies do not need to live in small ambient
categories.  Thus, the circle is closed by the following theorem, provided that the assumption is made
that E is small.
7.5.5 Theorem Let A: Eop→Cat be an E-indexed category, with E small, and let
A∈Cat(Eop→Set)  be its associated internal category. Then the indexed categories  A# = [Y(_), A] :
Eop→Cat  and A are equivalent.
Proof Let  e∈ObE. Then  A#(e) = [Y(e), A] is, by definition, the category with
Objects:
Nat[E[_,e], A0]
Morphisms:
g: σ→τ in [Y(e), A] iff
g∈Nat[E[_,e], A1] , DOM ˚ g =  σ, COD ˚ g =  τ
Now let  f∈E[e',e];  by definition one has
A#(f) = [Y(f), A] : A#(e)→ A#(e')
A#(f)(σ) = σ ˚ Y(f) for σ∈Nat[E[_,e], A0]
A#(f)(g) = g ˚ Y(f)
for g∈Nat[E[_,e], A1]
The natural isomorphism between  A  and  A#  is given by the Yoneda lemma: for every  e  in  E,  we
have natural isomorphisms  Ψ0(e): Nat[E[_,e], A0]→A0(e)  and  Ψ1(e): Nat[E[_,e], A0]→A1(e).
Ψ0 and Ψ1 define the components on objects and morphisms of an indexed functor Ψ(e):
A#(e)→A(e).  Explicitly,
Ψ(e)(σ) = σe(ide)
for  σ∈Nat[E[_,e],  A0]
Ψ(e)(g) = ge(ide)
for  g∈Nat[E[_,e],  A1].

7. Indexed and Internal Categories
158
Then the due diagrams commute, by the usual Yoneda argument.
Our final result shows that, by following the other path (from internal to internal, via external),
one obtains equivalent categories:
7.5.6 Theorem Let  c∈Cat(E)  be an internal category,  C = [_,c]: Eop→Cat  be as in definition
7.4.2, and  Y: E→Y(E)  be the Yoneda embedding. Then  C∈Cat(Y(E)).
Proof Let c = (c0, c1, DOM, COD, COMP, ID); note first that, by definition of C, for the internal
category C = (d0, d1, DOM', COD', COMP', ID')∈Cat(Eop→Set) we have
d0 = E[_, c0] = Y(c0)
d1 = E[_, c1] = Y(c1)
and hence C∈Cat(Y(E)), since Y is full. That  C is an internal category, follows by the fact that Y
preserves pullbacks.
♦
Appendix
We now study in more details the notions of internal adjunction and internal CCC.  The details are
rather complex and this appendix may be skipped at first reading.
By definition, an internal adjunction < F, G, φ > : c→d  is given by two internal functors  F:
c→d,   G: d→c,  and an isomorphism
φ : (F×Iddop)*(homd) →  (Idc×Gop)*(homc)
between presheaves on  c×dop.
Graphically, the notion of internal adjunction is represented by the following complex diagram:

7. Indexed and Internal Categories
159
where  (d1,σ0,σ1)  is the internal hom-functor of  d, and  (c1,σ0',σ1')  is the internal hom-functor of
c.  In particular,
σ0  = <DOM,COD> : d1 → d0×d0  and
σ0' = <DOM,COD> : c1 → c0×c0
respectively represent  d1  and  c1  as indexed collections of morphisms over  d0×d0  and  c0×c0.
The formal definition of  σ1  and  σ1'  is:
σ1 = COMP ˚ < p2 ˚ Π2, COMP ˚ (id ×0 p1) >0 :  d1×0(d1×d1) → d1
σ1' = COMP ˚ < p2 ˚ Π2, COMP ˚ (id ×0 p1) >0 :  c1×0(c1×c1) → c1
More intuitively, they are both described by the lambda term  λfgh. h ˚ f ˚ g  (recall that  hom[f,g](h)
= h ˚ f ˚ g).
Note also that  DOM: c1×d1→ c0×d0  = DOMc×CODd  because we are working in  c×dop.
X  and  Y  are respectively the pullbacks of
σ0 = <DOM,COD> : d1 → d0×d0 ,  f0×id : c0×d0 → d0×d0  and
σ0' = <DOM,COD> : c1 → c0×c0 ,  id×g0 : c0×d0 → d0×d0
Thus, informally,
X = { (a,b,h) ∈ c0×d0×d1 |  h : f0(a) → b }  =  d[f0(a), b]
Y = { (a,b,k) ∈ c0×d0×c1 |  k : a → g0(b) }  =  c[a, g0(b)].
φ : X → Y  is the natural isomorphism of the adjunction.
φ  works on triples of the kind  (a,b,h)∈c0×d0×d1  where  h: f0(a)→b.  The first two
components a and b are the indexes of the natural trasformation: since  ρ0'˚ φ = ρ0,  these indexes are
left unchanged by  φ,  and an “external-like” writing for  φ(a,b,h)  would be  φa,b(h).  At the external
level, it is common practice to omit these indexes; the formal complexity of the internal theory is
mostly due to the necessity of coping with these details.
The naturality of  φ  is expressed by the property,
(†)     
φ ˚ ρ1 = ρ1'˚ φ×0id  .
Still using our informal notation, by (†), for all  (a,b,h)  in  X, k  in  c1  and  l  in d1, such that :
cod(k) = a   ( that implies  cod(f0(k)) = f0(a) = dom(h) )
dom( l ) = b = cod(h)
cod( l ) = b'
we have
(∗)  
φa',b'( l ˚ h ˚ f1(k) ) = g1( l ) ˚ φa,b(h) ˚ k,
that is the familiar way the naturality of φ is expressed at the external level. Let us show, in this
informal notation, that  (†)  implies  (*)
φa',b'( l ˚ h ˚ f1(k) ) =
= (ΠY ˚ φ)( a', b' , l ˚ h ˚ f1(k)  ) 

7. Indexed and Internal Categories
160
= (ΠY ˚ φ)( a', b' , σ1(h, f1(k), l )  )
by def. of σ1
= (ΠY ˚ φ ˚ ρ1) ((a,b,h), k, l )
by the diagram for the adjunction
= (ΠY ˚ ρ1'˚ φ×0id) ( (a,b,h), k, l )
by (†)
= (σ1'˚ ΠY×0(id×g1) ˚ φ×0id) ( (a,b,h), k, l ) by the diagram for the adjunction
= σ1'( (ΠY˚φ)(a,b,h), k, g1( l ) )
= σ1'( φa,b(h), k,  g1( l ) )
= g1( l ) ˚ φa,b(h) ˚ k 
by def. of σ1'.
Given an adjunction  < F, G, φ > : C→D,  the arrows  φa,F(a)(idF(a))  and  φG(b),b-1(idG(b))  are
respectively called Unit and Counit of the adjunction (for a and b). Units and Counits fully specify
the behaviour of  φ  and  φ−1  since:
φ( l ) = φ( l ˚ id ) = g1( l ) ˚ φ(id) =  g1( l ) ˚ Unit
φ−1(k) = φ−1(id ˚ k) = φ−1(id) ˚ F(k) = Counit ˚ F(k) .
These properties allow to give at the external level the well-known equational characterization of the
notion of adjunction. In particular, the definition of Cartesian closed category based on the counits of
the adjunctions, plays a central role in the semantic investigation of the lambda calculus, since it
provides the underlying applicative structure needed for the interpretation. Remember that the counits
of the adjunctions defining products and exponents are respectively the projections associated with
the products and the evaluation functions associated with the function spaces.
Now we show how to mimic the same work at the internal level.
7.A.1 Definition  Let  < F, G, φ > : c→d  be an internal adjunction from  c  to  d.  Define then:
IDF = <<id,f0>, ID ˚ f0 >0 : c0→X;
IDG = <<g0,id>, ID ˚ g0 >0 : d0→Y;
Unit =  ΠY ˚ φ ˚ IDF : c0→c1;
Counit = ΠX ˚ φ−1 ˚ IDG : d0→d1.
Where X and Y are as in the diagram for the definition of adjunction.
Note that  IDF  takes an element a in c0 and gives the associated identity  idF(a)  as an element in X.
The definition of Unit, is then clear. As one expects, Unit is an internal natural transformation from  I
= (id,id)  to  G ˚ F,  and  Counit : d0→d1  is an internal natural transformation from  F ˚ G  to  I =
(id,id).  The proof is left as an exercise for the reader.
It is now not difficult to prove that every internal adjunction  < F, G, φ > : c→d  is fully
determined by the following data:
the functor  G: d→c;
an arrow  f0: c0→d0;
an arrow  Unit: c0→c1   such that   DOM ˚ Unit = id , COD ˚ Unit = g0 ˚ f0;

7. Indexed and Internal Categories
161
an arrow   φ−1: Y→X,  where  X  and  Y  are respectively the pullbacks of
<DOM,COD> : d1→d0×d0,  f0×id: c0×d0→d0×d0,  and
<DOM,COD> : c1→c0×c0,  id×g0: c0×d0→c0×c0;
and, moreover, the previous functions satisfy the following equations:
a.   < ρ0, COMP ˚ < g1 ˚ ΠX, Unit ˚ p1˚  ρ0 >0 >0 ˚  φ−1= idY;
b.   φ−1˚ < ρ0, COMP ˚ < g1 ˚ ΠX, Unit ˚ p1˚  ρ0 >0 >0  = idX.
Indeed the arrow  f0: c0→d0  can be extended to a functor  F = (f0, f1): c→d  by
f1 = ΠX ˚ φ−1˚ << DOM, f0 ˚ COD >, COMP ˚ < Unit ˚ COD, id >0 >0:  c1→d1.
The inverse of  φ−1  is
φ = < ρ0, COMP ˚ < g1 ˚ ΠX, Unit ˚ p1˚  ρ0 >0 >0.
Note that, by  (a)  and  (b),  φ  and  φ−1  define an isomorphism.  The non trivial fact is to prove that
they are morphisms of presheaves (i.e., to prove their naturality), but again the prof is a mere internal
rewriting of the corresponding “external” result.
Dually, if we have the following data:
a functor  F: c→d;
an arrow  g0: d0→c;
an arrow  Counit: d0→d1  such that   DOM ˚ Counit = f0 ˚ g0 , COD ˚ Counit = id;
an arrow  φ: X→Y, where  X  and  Y  are respectively the pullbacks of
<DOM,COD> : d1→d0×d0,  f0×id: c0×d0→d0×d0,  and
<DOM,COD> : c1→c0×c0,  id×g0: c0×d0→c0×c0;
and, moreover, the previous functions satisfy the following equations:
a.   < ρ0', COMP ˚ < Counit ˚ p2˚  ρ0', f1 ˚ ΠY>0 >0 ˚  φ = idX,
b.   φ ˚ < ρ0', COMP ˚ < Counit ˚ p2˚  ρ0', f1 ˚ ΠY>0 >0 = idY,
then we define an adjunction  < F, G, φ > : c→d,  in the following way.
The arrow  g0: d0→c0  can be extended to a functor  G = (g0,g1): c→d,  by
g1 =  ΠY˚ φ ˚ << g0 ˚ DOM, COD >, COMP ˚ < id, Counit ˚ DOM >0 >0:  d1→c1 .
The inverse of  φ  is
φ−1 = < ρ0', COMP ˚ < Counit ˚ p2 ˚ ρ0' , f1˚ ΠY >0 >0 : Y→X.
We are now in a position to study internal Cartesian closed categories from an “equational” point of
view. This work is needed to exploit the applicative structure underlying the notion of an internal
CCC. Recall that an internal Cartesian closed category is a category  c∈Cat(E)  with three adjunctions
1.  < O, T, 0 > : c→1,  where 1 is the internal terminal category;
2.  < ∆, x, <,>  > : c→c×c,  where ∆  is the internal diagonal functor;
3.   < x, [,]  , Λ  > : c→c,  where this adjunction has parameters in c.

7. Indexed and Internal Categories
162
By the previous results, we can explicitate the three adjunctions of these definitions by means of their
counits:
7.A.2 Definition  An internal terminal object in  c∈Cat(E)  is specified by:
an arrow  t0: t → c0;
an arrow  0: c0 → Z, where Z is the pullback of
<DOM,COD> : c1 → c0×c0 ,
id×t0 :  c0×t → c0×c0;
and, moreover,
a.  0 ˚ <γ',!Z >0 = 0 ˚ p1˚ γ' = idZ;
b.  < γ',!Z >0 ˚  0  = p1˚ γ'˚  0 = idc0;
where !Z  is the unique morphism in  E  from  Z  to the terminal object  t .
Intuitively  t0: t → c0 points to that element in  c0  that is the terminal object.  Z  is the subset of
c1  of all those morphisms that have the terminal object as target;  Z  must then be in a bijective
relation  0  with  c0;   0  takes an object  a  in  c0  to the unique morphism  !a  in  Z  from  a  to the
terminal object.
The previous diagram can be greatly simplified. As a matter of fact, it amounts to say that there is
an arrow  t0: t→c0  such that the following diagram is a pullback (prove it as an exercise):
The arrow  in: c0→c1  is the operation that takes every element a in c0 to the unique arrow !a in c1
whose target is the terminal object; in terms of the previous diagram,  in = ΠZ ° 0 .

7. Indexed and Internal Categories
163
7.A.3 Definition  An internal category  c  has products, iff there exist
an arrow  x0: c0×c0 → c0;
two arrows  FST: c0×c0 → c1,  SND: c0×c0 → c1  such that
DOM˚ FST = DOM ˚ SND = x0,
COD˚ FST = p1; COD˚ SND = p2,
(Notation:  FSTa,b = FST˚ <a,b>;  SNDa,b = SND˚ <a,b>);
an arrow  <,> : X→Y,  where  X  and  Y  are the pullbacks in the following diagram  (∆0 =
<id,id>):
and, moreover,
c0. ρ' ˚  <,> = ρ;
c1. (FST˚ p2 ˚ ρ) o( ΠY ˚  <,> )  =  p1 ˚ ΠX;
c2. (SND ˚ p2 ˚ ρ) o (ΠY ˚  <,> ) = p2 ˚ ΠX;
d. <,> ˚ < ρ', < (FST˚ p2˚ ρ') o ΠY , (SND˚ p2˚ ρ') o ΠY > >0 = idY ,
    where   f o g = COMP ˚ < f, g >0.
7.A.4 Definition  An internal category is Cartesian iff it has a terminal object and products.
As the definition  f×g = <f ˚ p1, g ˚ p2>  extends  ×  to a functor from C×C to C for any Cartesian C,
also the internal  x0  can also be extended to morphisms.
7.A.5 Proposition  Let  x1 : c1×c1 → c1 be defined by the following:
x1 = ΠY ˚  <,>˚ < <x0˚ DOMc×c, CODc×c >, <id o (FST˚ DOMc×c),id o (SND˚ DOMc×c) >0
where as above,  f o g = COMP ˚ <f,g>0 . Then  x = (x0, x1): c×c→c  is an internal functor.
Proof: Exercise.
Note that,  if f,g: e→c1, DOM ˚ f = a,  COD ˚ f = c, DOM ˚ g = b, COD ˚ g = d, then:  x1˚ <f,g> =
ΠY ˚ <,> ˚ < < x0˚<a,b>,<c,d>>,< f o FSTa,b , g o SNDa,b > >0.

7. Indexed and Internal Categories
164
7.A.6 Definition  An internal Cartesian category has exponents iff there exist :
an arrow  [,]0: c0×c0 → c0;
an arrow  EVAL: c0×c0 → c1   such that
DOM˚ EVAL = ×0 ˚ <[,]0, p1>,
COD˚ EVAL = p2 ,
(Notation:  EVALa,b = EVAL ˚ <a,b> );
an arrow  Λ: X'→ Y',  where  X'  and  Y'  are the pullbacks in the following diagram:
and, moreover,
e0. σ' ˚ Λ = σ     (to within the isomorphism  (a×b)×c ≅ a×(b×c) );
e1. (eval ˚ p1˚ σ) o ( x1˚ < ΠY' ˚ Λ, ID ˚ p2 ˚ p1 ˚ σ> ) = ΠX';
f.  Λ ˚ < σ', ( eval ˚ p2 ˚ σ') o ( x1˚ < ΠY', ID ˚ p1˚ p2 ˚ σ'> ) >0 = idY',
   where   f o g = COMP ˚ < f, g >0 ,  and  x1  is the morphism in proposition A.5.
7.A.7 Definition An internal Cartesian closed category is an internal Cartesian category
with exponents.
References  The introduction of indexed notions in Category Theory has been a slow process,
which started to develop into a detailed theory around the beginning of the 1970s, with the
independent work of F. W. Lawvere, J. Penon, J. Bénabou.  The Theory of Indexed Category owes
much of its actual settlement to R. Paré and D. Schumacher (1978), and to their introductory book,
written in collaboration with P. T. Johnstone, R. D. Rosebrugh, R. J. Wood and G. C. Wraith.
The first significant study of the Theory of Internal categories is due to R. Diaconescu. Further
developments were made by J. Bénabou, though, most of the time, they never appeared as published
works. Notions of Internal Category Theory can be found in many books of topos theory, for
instance, in those of Johnstone (1977) and Barr and Wells (1985).

7. Indexed and Internal Categories
165
Our development of the arguments in this chapter has been essentially inspired by Paré and
Schumacher (1978), Johnstone (1977), and some private communications of E. Moggi. The
definition of the internal category in definition 7.5.1 has been pointed out to us by B. Jacobs.

8. Formulae, Types, and Objects
166
Chapter 8
FORMULAE, TYPES, AND OBJECTS
During the last two decades, computer science has turned the Proof Theory of mathematical logic
from a philosophical investigation of the foundations of human reasoning into an applied sector of
mathematics. Many important logical systems of the beginning of the 1970s, which “fifteen years
later” proved of great relevance for computer science, were invented by logicians such as Girard,
Martin-Löf and Troelstra, who were mostly interested in constructive approaches to mathematics and
foundational problems. Still in 1975, in the first pages of his book on Proof Theory, Takeuti
introduced “the formalization of the proofs of mathematics, and the investigation of the structure of
these proofs” as a mere “fruitful method in investigating mathematics.” Moreover, he himself
remarked that “while set theory has already contributed essentially to the development of modern
mathematics, it remains to be seen what influence proof theory will have on mathematics”.
If not on mathematics, Proof Theory has surely proved since that time his influence on theoretical
computer science. The modern theory of functional languages and lambda calculus owes much of his
actual settlement to mathematical logic, and what until a few years ago was known as the
“denotational semantics of programming languages” has grown under the direct influence of Proof
Theory, and together with the understanding of the logical aspects of Category Theory. But far from
being only a rich field for applications, computer science has also been for mathematical logic an
inexhaustible source of mutual enrichment. The leading theme of this stimulating relation, as for the
topic presented in this chapter, has been the so called Curry-Howard correspondence, which exploits
the connections between Proof Theory and Type Theory. This correspondence, also known by the
suggestive name of “formulae-as-types analogy”, has been a main methodological tool both for
understanding the relations between intuitionistic logic and typed lambda calculus, and for the design
of new functional languages with powerful type systems. The main idea of the Curry-Howard
correspondence, is that logical formulae can be interpreted as types in a suitable type theory; a proof
of a formula is then associated with a λ-term of the proper type, and the reduction of a proof by cut-
elimination corresponds to the normalization of the associated λ-term. As a consequence, if a formula
is derivable in a certain logical system, then the corresponding type is inhabited in the associated type
theory. The Curry-Howard correspondence works only for logical systems of Intuitionistic Logic.
This restriction should be clear, since the constructive, procedural interpretation of the notion of proof
was the very basis of Brower's approach to mathematics, which inspired Heyting's formalization of
intuitionistic logic. Moreover, although the formulae-as-types analogy can also be applied to logical
systems based on axioms and inference rules, such as that of Hilbert, just switching from λ-terms to
combinators in the associated type theory, it has a more elegant application to systems of Natural
Deduction. Indeed the procedural understanding of a logical proof is more clear in a system like

8. Formulae, Types, and Objects
167
Natural Deduction, where one proceeds by the method of drawing inferences from assumptions, than
in Hilbert's system, where one draw inferences from axioms. Furthermore, especially in Gentzen's
variant of Natural Deduction, the inference rules of the calculus are closely related to the intuitive
“operational” interpretation of the logical signs, and this fact allows one to proceed in the construction
of the proof in a certain direct fashion, affording an interesting normal form for deductions which has
no clear counterpart in Hilbert's system.
8.1 λλλλ-Notation
Consider the following mathematical definition of the function  f: N→N :
f(x) = 5∗x + 3 .
Note that it is not “f” that has been actually defined, but  “f(x),” that is the result of the application of
f  to a formal parameter  x  which is supposed to range over the integers.
f(x) is not a function: it is a polynomial, that is, an operational description of the behavior of  f
when applied to  x. The mechanism that allows us to “abstract” from the formal parameter  x,  and
thus to pass from the knowledge of “how the function works” to the knowledge of “what the function
is,” is called lambda abstraction (λλλλ-abstraction).  The function  f  in the example above is
defined by the lambda abstraction of  5x + 3  with respect to x, and is denoted by  λx. 5∗x+3.
The complementary action to λ-abstraction is called application. The application of two terms M
and N is usually represented by their justaposition (MN). From the computational point of view, λ-
abstraction and application are related by the following rule, known as β-reduction:
(λx.M)N → [N/x]M
where [N/x]M means the substitution of N instead of x in the term M.
For example,
(λx. 5∗x+3)4  →  5∗4+3  =  23
The lambda notation was explicitly introduced by the logician Alonzo Church in the lambda
calculus (λ-calculus), a formalism invented to develop a general theory of computable functions,
and to extend that theory with logical notions providing a foundation for (part of) mathematics.
In computer science, the lambda notation made its first appearance in the programming language
LISP; this was also the first language to use procedures as objects of the language. Like the early
lambda calculus, LISP is an untyped language; that is, programs and data are not distinguished, but
they are all elements of a unique untyped universe: the universe of λ-terms for the λ-calculus, the
universe of S-expressions for LISP (see next chapter). Anyway, as every computer scientist knows
from his or her own programming practice, types arise naturally, even starting from untyped
universes, when objects are categorized according to their usage and behavior. The ultimate question
is whether it wouldn't be better to consider types as an a priori  schema of human knowledge, instead
of an attempt to organize subsets of objects with uniform properties out of an untyped universe. In

8. Formulae, Types, and Objects
168
computer science, the debate about typed and untyped languages is very lively today, since it reflects
the unresolvable conflict between reliability and flexibility of the language. Nowadays, the practical
success of a language is often due to the the more or less successful attempt to compromise security
and freedom; in this respect, the language ML is probably one of the most interesting examples.
Anyway, since the first appearance of types in Algol 60, when typing of variables was introduced to
check at compile time the connections of instances of use with associated declarations, typing has
been considered more and more an essential discipline that must not only help, but guide the
programmer in the design of code.
8.2 The Typed λλλλ-Calculus with Explicit Pairs (λλλλββββηηηηππππt)
The collection Tp of type labels, over a ground set  At of atomic type symbols, is inductively defined
by
i.   At ⊆ Tp;
ii.  if  A,B∈Tp,  then  A→B∈Tp;
iii. if  A,B∈Tp,  then  A×B∈Tp.
For every type  A  there exists a denumerable number of variables, ranged over by lower case
letters near the end of the alphabet.  We use upper case letters M, N, P, . . . , as metavariables for
terms. The fact that a term  M has type A will be denoted with the expression “M: A.”
The well typed (λλλλ-)terms (w.t.t.) and their associated types, are defined according to the
following formation rules:
1. every variable  x: A  is a w.t.t.;
2. if  x: A  is a variable, and  M: B  is a w.t.t, then  λx:A.M: A→B  is a w.t.t.;
3. if  M: A→B  is a w.t.t and  N: A  is a w.t.t, then  MN: B  is a w.t.t.;
4. if  M: A  is a w.t.t  and  N: B  is a w.t.t, then  <M,N>: A×B  is a w.t.t.;
5. if  M: A×B  is a w.t.t, then  fst(M): A  is a w.t.t.;
6. if  M: A×B  is a w.t.t, then  snd(M): B  is a w.t.t.
Given a w.t.t  M: B, the set FV(M) of the free variables of M, is defined as follows:
1. if  M ≡ x, then FV(M) = {x};
2. if  M ≡ λx:A.N, then  FV(M) = FV(N)-{x};
3. if  M ≡ NP, then  FV(M) = FV(N)∪FV(P);
4. if  M ≡ <N,P>, then  FV(M) = FV(N)∪FV(P);
5. if  M ≡ fst(N), then  FV(M) = FV(N);
6. if  M ≡ snd(N), then  FV(M) = FV(N).
The substitution  [M/x]N: B  of a proof  M: A  for a generic  x: A  in a proof  N: B is defined in
the following way:

8. Formulae, Types, and Objects
169
1. if  N: B ≡ x: A  then  [M/x]N: B ≡  M: A;
2. if  N: B ≡ y: A , x≠y ,  then  [M/x]N: B ≡  N: B;
3. if  N: B ≡ λx:C.P : B, then  [M/x]N: B ≡ λx:C.P : B;
4. if  N: B ≡ λy:C.P : B, x≠y, y∉FV(M), then  [M/x]N: B ≡ λy:C.[M/x]P : B;
5. if  N: B ≡ PQ : B, then  [M/x]N: B ≡  [M/x]P[M/x]Q : B;
6. if  N: B ≡ <P,Q> : B, then  [M/x]N: B ≡  <[M/x]P,[M/x]Q> : B;
7. if  N: B ≡ fst(P) : B, then  [M/x]N: B ≡  fst([M/x]P) : B;
8. if  N: B ≡ snd(P) : B, then  [M/x]N: B ≡  snd([M/x]P) : B.
As an easy consequence of the definition above, it follows that if  x∉FV(N),  then  [M/x]N: B ≡ N:
B.  Note also that, if x∉FV(N), then  [P/x][M/y]N: B ≡  [([P/x]M)/y]N: B .
Given a sequence  M = M1,..., Mn  of terms, and sequence  x = x1, . . . , xn  of variables,
[M/x]N  denotes the simultaneous substitution of every term  Mi  for the variable  xi  in the term  N.
We also use the notation  [M/x]N  to express the simultaneous substitution of the term  M  for all the
variables in x.
We consider an equational theory of proofs, defined as the minimal congruence relation “=” which
satisfies the following axiom schemas:
(α)
λx:A.M = λy:A.[y/x]M
(→β)
(λx:A.M)N = [N/x]M
(→η)
λx:A.(Mx) = M, if  x∉FV(M)
(× β1) fst(<M,N>) = M
(× β2) snd(<M,N>) = N
(× η)
<fst(P),snd(P)> = P.
The previous equations may be read from left to right : then one obtains a rewriting system, which
defines the operational semantics of lambda calculus as a programming language. Explicitly, we
define a reduction relation  ⇒  as the minimal relation between with respect to terms such that
(→β)
(λx:A.M)N ⇒ [N/x]M
(× β1) fst(<M,N>) ⇒ M
(× β2) snd(<M,N>) ⇒ N
Μ ⇒ M'   implies   ΜΝ ⇒ M'N
Μ ⇒ M'   implies   ΝΜ ⇒ NM'
Μ ⇒ M'   implies   λx:A.M⇒λx:A.M'
Μ ⇒ M'   implies   fst(Μ) ⇒ fst(M')
Μ ⇒ M'   implies   snd(Μ) ⇒ snd(M')
(→η)
λx:A.(Mx) ⇒ M, if  x∉FV(M)
(× η)
<fst(P),snd(P)> ⇒ P.

8. Formulae, Types, and Objects
170
The rewriting rules associated with  (→β ), (× β1)  and  (× β2)  are called β-reductions, and those
associated with  (→η) and (× η)  are called η-reductions. We put the η-reductions aside, because of
their lesser computational interest. In the following section we shall see that from the point of view of
the Curry-Howard correspondence both β− and η-reductions have an interpretation in terms of proof
normalization. Also in this context, however, the β-rules play a major role.
A term is in normal form (respectively β-normal form), if it is no more reducible (respectively
β-reducible). The (β-)reduction relation is confluent and noetherian.
Let us now look at some simple examples of programs written in the typed lambda calculus. As
usual, when considering the formal expressiveness of a calculus, we compare it with the problem of
representing integers and arithmetic functions.
Given a type σ, we call  Nσσσσ= (σ→σ)→(σ→σ)  the type of σσσσ-iterators (σσσσ-numerals). The
reason for the name is that in the type  (σ→σ)→(σ→σ)  we have all the terms with the following
structure:
0σ ≡ λxσ→σ λyσ.y
1σ ≡ λxσ→σ λyσ.xy
...
nσ ≡ λxσ→σ λyσ.xny, where   xny = x(...(xy))   “n times”.
The effect of the term  nσ is to take a function  x  of type  σ→σ,  a term y of type  σ,  and iterate the
application of  x  to y  n times. It is possible to show that if  σ  is an atomic type, then the terms of the
form nσ, together with  the identity   λxσ→σ.xσ→σ  are the only closed terms in normal form of
type σ.
We can now define the function  succσ ≡ λn: Nσ λxσ→σ λyσ. x(nxy).
The term  succσ  has type Nσ→Nσ and its effect is to increase the iteration of one unit. For example,
       succσ 0σ
= (λn: Nσ λxσ→σ λyσ. x(nxy) ) 0σ
= λxσ→σ λyσ. x( 0σxy)
=  λxσ→σ λyσ. x(y)
= 1σ
Define now  addσ: Nσ×Nσ→Nσ  by  addσ ≡ λz: Nσ×Nσ λfσ→σ λyσ. fst z f (snd z f y )
For example, we have:
  addσ <1σ,1σ> = (λz: Nσ×Nσ λfσ→σ λyσ. fst z f (snd z f y ) ) <1σ,1σ>
= λfσ→σ λyσ. fst <1σ,1σ> f (snd <1σ,1σ> f y )
= λfσ→σ λyσ. 1σ f (1σ f y )
= λfσ→σ λyσ. f ( f y )
= 2σ.
Analogously,  multσ: Nσ×Nσ→Nσ  is given by
multσ ≡ λz: Nσ×Nσ λfσ→σλyσ. fst z (snd z f ) y.
As an example of computation, we have

8. Formulae, Types, and Objects
171
    multσ <2σ,2σ> = (λz: Nσ×Nσ λfσ→σ λyσ. fst z (snd z f ) y ) <2σ,2σ>
= λfσ→σ λyσ. fst <2σ,2σ> (snd <2σ,2σ> f ) y
= λfσ→σ λyσ. 2σ (2σ f ) y
= λfσ→σ λyσ. (2σ f )( 2σ f  y )
= λfσ→σ λyσ. f ( f( f ( f  y ) ) ) )
= 4σ.
As a final example, we present a test to  0σ. That is, we want to define a term  test 0σ  that takes
two terms  M  and  N  of type  σ  and a σ-numeral  n;  if  n = 0σ  then the function yields  M  as
result; otherwise, it outputs  N.  Here it is:  test 0σ ≡  λz: σ×σ λn: Nσ. n( λyσ.(snd z) )(fst z).
It is possible to prove (see references) that these are essentially all the arithmetic functions we can
compute by the (pure!) simply typed λ-calculus, that is, all the functions that are defined by
composition of the previous ones. For example the predecessor function is not representable.
The simply typed λ-calculus cannot be considered as a real programming language, but only as a
paradigm for strongly typed (functional) languages, which allow us to point out their main common
properties. In the last section of this chapter we shall consider an extension of the language by
fixpoint operators. The combined use of these operators with a reasonable set of arithmetic primitives
gives to the language its full computational power.
8.3 The Intuitionistic Calculus of Sequents
Among the many variants of intuitionistic logic expressed in systems of Natural Deduction, Gentzen's
calculi of cequents has recently gained much popularity among the computer science community. In
the first place, one of the main aspects of the procedural interpretations of proofs is that of making
explicit the assumptions on which a formula occurrence in a deduction depends, and this is just what
the notion of sequent is meant for. Moreover, since the calculi of sequents can be understood as
metacalculi for the deducibility relation in the corresponding system of natural deduction, it seems to
be the best instrument for the investigation of the structure and the properties of proofs. Note,
however, that even when handling sequents, the dependencies of a formula by its premises can be
quite hard to understand, if one adopts some common choices on the structure of the sequent, such as
avoiding repetitions of formulae in the antecedent, or fixing a certain alphabetic order for them. This
is very clear if we consider a sequent as an effective process for transforming proofs of the premises
into a proof of the consequence. It seems not only reasonable, but fair to guarantee the ability of
handling two or more different proofs for a same formula. In particular, this means allowing
repetitions for a formula in the antecedent of a sequent, each one with an associated hypothetical
distinct proof. From the same point of view, even the idea of an ordering among the formulae does
not make any sense; what one really needs, are rather some explicit rules in the calculus which allow
us “to move formulae around” (exchange rules).  The presence of repetitions of formulae requires a

8. Formulae, Types, and Objects
172
new rule too, stating that two proofs of a formula can actually be assumed to be the same, and thus
affording to discharge one of them (contraction rule).  These rules, together with the so-called
weakening rule, that allows for adding new assumptions to a sequent, are usually referred to as
“structural rules.” The reason for this name should be clear, since these rules have nothing to do with
logical signs and their meanings, but only with the structures of the derivations in the calculi. This
property of the structural rules has been often misunderstood, and regarded as a sign of their lesser
logical interest: Takeuti called them “weak inferences,” with respect to the “strong inferences” of
introduction of the logical connectives. The very recent revival of the structural rules, and the analysis
of their impact on the logical systems is mostly due to Girard, and to the invention of linear logic (see
chapter 4).
The calculi of sequents for classical and intuitionistic logic were introduced by Gentzen at the
beginning of the 1930s, who called them L systems. In these systems the elementary statements are
statements of deducibility. Each statement  Γ |- B  (called a sequent) has a conclusion  B  and a
collection  Γ, possibly void, of premises, and it is interpreted as stating the existence of a proof
leading to the stated conclusion and having no uncanceled premises other than some of those stated.
We consider only the subcalculus that deals with the two connectives of conjunction and
implication, and that will be referred to as “positive calculus.” The principal connective of the system
is implication; the role of conjunction is rather minor, but its analysis will help in clarifying some
issues we will be concerned with in the rest of this chapter.
The following presentation of the positive intuitionistic calculus of sequents is slightly different
from the usual one. In particular, every formula  A  will be equipped with an associated proof,
formally represented by a lambda term  M: A. This association between proofs (λ-terms) and
formulae is defined in the inference rules of the calculus. If there is a derivation of the sequnt  Γ |- M:
B, the proof  M  keeps a trace of the derivation tree. On the other hand, the so-modified inference
rules can be understood as metarules for proof manipulation. This understanding of the calculus of
sequents as a metacalculus for the deducibility relation is one of the most peculiar aspect of this formal
system.
8.3.1 Logical Alphabet
1. atomic propositions, ranged over by  A, B, C, . . .;
2. logical symbols:  ×, → .
8.3.2 W.F.Formulae (Types)
1. every atomic proposition is a formula;
2. if  A, B are formulae, then  A×B  is a formula;
3. if  A, B are formulae, then  A→B  is a formula.

8. Formulae, Types, and Objects
173
There is a bijective correspondence between formulae and types of the typed lambda calculus with
explicit pairs. We can go further, and associate every formula  B  with a λ-term  M  of the respective
type, which intuitively represents its proofs. In particular, if  x1: A1,..., xn: An  are the free variables
in  M,  then  M: B  is a proof of  M  depending on the hypothesis  A1,..., An.  The previous approach
is sound with the intuitionistic interpretation of the notion of proof as an effective procedure that
shows the validity of the conclusion B, as soon as one has a proof of the validity of the premises.
Thus, if  M  is a proof of B, possibly depending on a generic proof  x: A, one gets a proof of  A→B
by “abstraction on  x: A,” that is  λx:A.M: A→B.  Juxtaposition of proofs corresponds intuitively to
their sequential application. In particular, if we have a proof  M: A→B,  and we apply it to a proof  N:
A,  then  we obtain a proof  MN  of  B.  A proof of  A×B  is given by a pair of distinct proofs for  A
and  B.  Moreover, having a proof of  A×B,  one can select the two proofs of  A  and  B by means of
the projections  fst  and  snd .
The inference rules of the calculus exactly formalize this process of constructiing complex proofs
by means of simpler ones.
A (well-typed) term  M: A,  will be called a proof when it is regarded from a logical viewpoint. A
variable  x: A,  will be called a generic proof of  A.
An intuitionistic sequent  has the following syntactic structure:
x1: A1, . . . , xn: An  |- M: B
where  x1: A1, . . . , xn: An  is a finite (possibly empty) list of distinct  generic proofs, and  M: B  is a
proof of  B  whose free variables are among  x1, . . . , xn.  Every formula in the left-hand-side
(l.h.s.) has an associated distinct variable; thus no confusion can arise between formulae, even if they
have the same name.
The intuitive interpretation of the sequent   x1: A1, . . . , xn: An  |- M: B  is that of a process which
builds a proof  M  of  B, as soon as it has proofs for   A1, . . . , An,  that is, a function  f  of type
A1× . . . ×An→B, or equivalently,  A1→( . . . (An→B) . . . ),  which can be obtained by functional
completeness from the polynomial  M.
Since the name of a generic proof is not relevant, we assume that sequents which differ only by a
renaming of variables are syntactically identified. This is consistent with the α-conversion rule of
proofs, in view of the intuitive interpretation of sequents sketched above.
We use Greek capital letters Γ, ∆, . . . to denote finite sequences of generic proofs in the left hand
side of a sequent. A sequent thus has the form  Γ |- M: B.
An inference is an expression
 S1
S1         S2
____
__________
  S
        S

8. Formulae, Types, and Objects
174
where  S1, S2,  and  S  are sequents.  S1  and  S2  are called the upper sequents and  S  is called the
lower sequent of the inference. Intuitively, this means that when  S1  (S1 and S2) is (are) asserted,
one can infer  S  from it (them).
We always suppose that the variables in the l.h.s. of the upper sequents are distinct. This is not a
problem, since the variables of the upper sequents S1 and S2 that contribute to form the l.h.s. of the
lower sequent  S  can be conveniently renamed.
The logical system restricts the legal inferences to those obtained from the following rules.
8.3.3  Axioms and Rules
(axiom)         
x: A |- x: A
Γ, x: A, y: B,  Γ1 |- M: C
(exchange)
____________________
Γ, y: B, x: A,  Γ1 |- M: C
     Γ |- M: B
(weakening)  
____________
Γ, x: Α  |- M: B
   Γ, x: Α, y: Α  |- M: B
(contraction)  ____________________
 Γ, z: Α  |- [z/x][z/y]M: B
Γ|- M: A       Γ1, x: Α, Γ2 |- N: B
(cut)
__________________________
       
 Γ1, Γ, Γ2 |-  [M/x]N: B
   Γ, x: Α |-  M: B
Γ1 |- M: A       Γ2, x: B |- N: C
(→, r)
_______________
(→, l ) _________________________
Γ |-  λx:A.M: A→B
Γ1, Γ2, y: A→B |- [yM/x]N: C
Γ |- M: Α      Γ |- N: B  
         Γ, x: Α |- M: C
(×, r)
_________________ 
(×, l, 1) _____________________
Γ |-  <M,N> : A×B
Γ, z: A×B |- [fst(z)/x]M: C
         Γ, y: Β |- M: C
(×, l, 2) ______________________
Γ, z: A×B |- [snd(z)/x]M: C
Remark  Note the identification of the premises of the upper sequents in the rule (×, r).

8. Formulae, Types, and Objects
175
The formula Α in the weakening rule is called the weakening formula (of the inference).
Similarly, we define the cut formula. In the case of the contraction rule we distinguish between the
contracting formulae  x: A, y: A  and the contracted formula  z: A.  The formulae  A→B  and
A×B  in the logical rules of introduction of the respective connectives, are called the principal
formulae of the inference;  A  and  B  are called the auxiliary formulae.
Unlike the usual approach, we intend the previous definition to refer only to the specific
occurrences of the formulae pointed out in the inference rules. For instance, consider the following
application of the rule  (→, l ):
Γ1 |- M: A       w: A→B, x: B |- N: C
(→, l )
______________________________
Γ1, w: A→B, y: A→B |- [yM/x]N: C
The (occurrence of the) formula  A→B  associated with the proof  y  is a principal formula of this
inference, but that associated with  w  is not.
It is easy to check that, for every rule of inference, the proof in the right-hand side of the lower
sequents is well formed, if those of the upper sequents are  as well. A derivation  D  is a tree of
sequents satisfying the following conditions:
1. the topmost sequents of  D  are axioms;
2. every sequent in  D  except the lowest one (the root) is an upper sequent of an inference whose
lower sequent is also in  D.
The lower sequent in a derivation  D  is called the end-sequent of  D.  A path in a derivation  D
from a leaf to the root is called a thread.  A derivation without the cut rule is called cut-free.
Examples  The following is a derivation:
     x: Α |- x: Α
y: Β  |- y: Β
______________
_______________
z: Α×Β |- fst(z): Α
z: Α×Β |- snd(z): Β
__________________________________
        z: Α×Β |- <fst(z),snd(z)>: Α×Β
The sequence
x: Α |- x: Α
z: Α×Β |- fst(z): Α
z: Α×Β |- <fst(z),snd(z)>: Α×Β
is a thread.

8. Formulae, Types, and Objects
176
The tidy display of the introduction of new formulae during a derivation in Gentzen’s calculus of
sequent, allows us to follow the entire “life” of a formula, from the moment it is “created” (by an
axiom, a weakening, or as a principal formula of a logical rule) to the moment it is “consumed” (by a
cut, or as an auxiliary formula in a logical rule). Note in particular that a step of contraction must not
be regarded as a consumption, but as an identification of a formula  A  in the lower sequent, with two
formulae of the same name in the upper sequent.
Given a thread  T  and an occurrence of a formula  A  in the final sequent of  T,  we call rank of
A  in  T  the number of consecutive sequents in  T,  counting upward, that contain the same
occurrence of the formula  A  (or a formula which has been contracted to it).
For instance, consider again the thread
x: Α |- x: Α
z: Α×Β |- fst(z): Α
z: Α×Β |- <fst(z),snd(z)>: Α×Β
of the previous example. The rank of the formula  Α×Β  in the l.h.s. of the end sequent is 2, while
the rank of the formula  Α×Β  in the r.h.s. is 1.
8.4 The Cut-Elimination Theorem
One of the more interesting properties of Gentzen’s calculus of sequent is the cut-elimination theorem,
also known as Gentzen’s Hauptsatz. This result proves that every derivation in the calculus can be
effectively transformed in a “natural normal form” which does not contain any application of the cut
rule. Moreover we show that this process of reduction of the derivations toward a normal form is in
parallel to the β-reduction of the associated proofs.
The identification of the derivations reducible to a same normal form is the base of the so-called
“semantics of proofs,” and, a posteriori, it provides a justification for the equational theory we have
introduced over the language of proofs (at least for the β-conversions).
The following presentation of the cut-elimination theorem is meant to study the relations between a
derivation ending in the sequent  Γ |- M: A  and the proof  M: A.  Indeed, it should be clear that given
a proof  M: A,  with  FV(M) ⊆ Γ,  it is possible to obtain a derivation of the sequent Γ |- M: A  by
building a sort of “parse tree” for the term  M: A . Anyway, this correspondence between derivations
and proofs is not a bijection: the problems arise with the structural rules, since their application is not
reflected in the terms. In particular, it is not possible to recover the order in which the structural rules
have been applied during the derivation.
The exact formalization of the equivalence of derivations that differ only in “structural details” is
not at all trivial, and it is the main goal of Girard’s research of “a geometry of interaction”. From this
respect, the language of proofs is a very handy formalism that allows us to abstract from such
structural details.

8. Formulae, Types, and Objects
177
Before the cut-elimination theorem, we state a first, simple result that relates cut-free derivations
and proofs in  β-normal form.
8.4.1 Proposition   Let   Γ |- M: A   be the end sequent of a cut-free derivation. Then the proof  M:
A  is in β-normal form.
Proof  Exercise. Hint:  Show, by induction on the length of the derivation, that the proof  M: A
cannot contain any of the following subterms:
1. (λx:B.N)P: C
2. fst(<N,P>)
3. snd(<N,P>). ♦
One of the aims of this chapter is to put in evidence the logical aspects underlying functional type
theories. For this reason we state and prove Gentzen’s Hauptsatz and stress the equivalence of the
normalization of a derivation  D  ending in a sequent   Γ |- M: A  and the β-reduction of M.
8.4.2 Theorem (The Cut-Elimination Theorem)  Let  D  be a derivation of the sequent  Γ |-
M: A . Then there exists a cut-free derivation  D'  of the sequent  Γ |- N: A,  where  N  is the β-normal
form of  M.
It is difficult to appreciate at first sight the cut-elimination theorem in its whole meaning. Indeed, it
looks like a mere result about the redundancy of one of the inference rules in the calculus, and one
would expect, as a next step, to drop the cut rule from the logical system.  This is not at all the case.
The fact is that the cut rule is a very relevant and deep attempt to express one of the crucial
methodological aspects of reasoning, that is, the decomposition of a complex problem in simpler
subproblems: in order to prove  Γ |- B , we can prove two lemmas  Γ |- A  and  Α |- B. This is very
clear from the computer science point of view, where the emphasis is not on the results - that is, the
terms in normal form - but on the program’s synthesis, and its reduction (computation) when applied
to data.
An important consequence of the cut-elimination theorem is the following. One can easily see that
in any rule of inference except a cut, the lower sequent is no less complicated than the upper
sequent(s). More precisely, every formula occurring in an upper sequent is a subformula of some
formula occurring in the lower sequent. Hence a proof without a cut contains only subformulae of the
formulae occurring in the end sequent (subformula property). From this observation, the
consistency of the logical system immediately follows.  Suppose indeed that the empty sequent  |-
were provable.  Then by the cut-elimination theorem, it would be provable without a cut; but this is
impossible, by the subformula property of cut-free proofs.

8. Formulae, Types, and Objects
178
In order to prove theorem 8.4.2, it is convenient to introduce a new rule of inference called a mix.
The mix rule is logically equivalent to the cut rule, but it helps deal with the contraction rules, whose
behavior during the cut elimination is rather annoying. We shall discuss again this problem at the end
of the proof.
A mix is an inference of the following form:
Γ|- M: A       Γ1 |- N: B
__________________
  Γ, Γ1* |-  [M/x]N: B
where  x  is a vector of variables in  Γ1,  Γ1*  is obtained from  Γ1  by erasing all the assumption  x:
A  with  x∈x,  and  [M/x]N  denotes the simultaneous substitution of  M  for all variables in  x,
inside the term  N.
The previous notion of mix rule is slightly different from the usual one. In particular the formula
A  can still appear in the lower sequent  Γ1*.
An occurrence of  A  in the upper sequents of a mix rule is called a mix formula  (of the
inference) if and only if it satisfies one of the two following conditions:
1. it is in the r.h.s. of the left upper sequent;
2. it is in the l.h.s. of the right upper sequent, and it is associated with a proof  x:A , with x∈x.
Clearly a cut is a particular case of mix, where the vector  x  contains only one variable. Moreover,
every mix can be simply obtained by a sequence of exchanges and contractions, a cut, and another
series of exchanges.
Since a proof without a mix is also a proof without a cut, theorem 8.4.2 is proved if we prove the
following:
8.4.3 Theorem (The Mix-Elimination Theorem)  Let  D  be a derivation of the sequent  Γ |-
M: A. Then there exists a mix-free derivation  D'  of the sequent  Γ |- N: A,  where  N  is the β-
normal form of  M.
Theorem 8.4.3 is easily obtained from the following lemma, by induction on the number of the mix
rules occurring in the derivation D.
8.4.4 Lemma  Let  D  be a derivation of the sequent  Γ |- M: A  that contains only one cut rule
occurring as the last inference.  Then there exists a cut-free derivation  D'  of the sequent  Γ |- N: A,
where  N  is the β-normal form of  M.
The rest of this section is devoted to the proof of this lemma.

8. Formulae, Types, and Objects
179
We define two scales for measuring the complexity of a proof. The grade of a formula A
(denoted by g(A) ) is the number of logical symbols contained in A. The grade of a mix is the grade
of the mix formula. When a derivation  D  has only one cut as the last inference, we define the grade
of  D  (denoted by g(D) ) to be the grade of this mix.
Let  D  be a derivation which contains a mix
Γ|- M: A       Γ1 |- N: B
__________________
  Γ, Γ1* |-  [M/x]N: B
as the last inference. We call a thread in  D  a left (right) thread if it contains the left (right) upper
sequent of the mix. The rank of a thread is the number of consecutive sequents in D (counting
upward from the upper sequents of the cut rule) that contain the mix formula or a formula which has
been contracted to it.  The rank of every thread is at least 1.  The left (right) rank of a derivation  D  is
the maximum among the ranks of the left (right) threads in  D.  The rank of a derivation  D  is the sum
of its left and right ranks. The rank of a derivation is at least 2.
We prove the lemma by double induction on the grade  g  and rank  r  of the derivation  D.  The
proof is subdivided into two main cases, namely  r = 2  and  r > 2.
Case 1 :  r = 2
We distinguish cases according to the forms of the proofs of the upper sequents of the cut rule.
1.1. The left upper sequent  S1  is an initial sequent.  In this case  D  is of the form
y: A |- y: A       Γ |- N: B
____________________
      Γ1* |-  [y/x]N: B
And we obtain the same proof by a series of contractions starting from the sequent  Γ |- N: B.
1.2. The right upper sequent  S2  is an initial sequent. Similarly.
1.3. Neither  S1  nor  S2  is an initial sequent, and  S1  is the lower sequent of a structural inference.
It is easy to check that, in case  r = 2,  this is not possible.
1.4. Neither  S1  nor  S2  is an initial sequent, and  S2  is the lower sequent of a structural inference.
The structural inference must be a weakening, whose weakening formula is  A.  The derivation  D
has the structure

8. Formulae, Types, and Objects
180
Γ1 |- N: B
        ____________
Γ |- M: A          x: Α, Γ1 |- N: B
________________________
         Γ, Γ1 |-  [M/x]N: B
Since  x∉FV(N),  [M/x]N ≡ N,  and we obtain the same proof  N: B  as follows:
Γ1 |- N: B
______________
some weakenings
______________
  Γ, Γ1 |-  N: B
1.5. Both  S1  and  S2  are the lower sequents of logical inferences. Since the left and right ranks of
D  are 1, the cut formulae on each side are the principal formulae of the logical inferences, and the mix
is actually a cut between these two formulae.
We use induction on the grade and distinguish two cases according to the outermost logical
symbol of  A.
(→)  the derivation  D  has the structure
   Γ, x: Α |-  M: B
Γ1 |- N: A       Γ2, y: B |- P: C
_______________
________________________
Γ |-  λx:A.M: A→B
Γ1, Γ2, z: A→B |- [zN/y]P: C
___________________________________________
Γ, Γ1, Γ2 |- [λx:A.M/z][zN/y]P: C
where, by assumption, the proofs ending with  Γ, x: Α |-  M: B, Γ1 |- N: A  or  Γ2, y: B |- P: C  do
not contain any cut. Note now that
[λx:A.M/z][zN/x]P: C  ≡  [(λx:A.M)N/y]P: C  =  [ ([N/x]M) /y]P: C,
which also suggests how to build the new derivation.
First consider the derivation
Γ1 |- N: A   
Γ, x: Α |-  M: B
_________________________
Γ1,  Γ |-  [N/x]M: B
This proof contains only one mix as its last inference. Furthermore, the grade of the mix formula is
less than  g(A→B).  By induction hypothesis, there exists a derivation  D'  of the sequent   Γ1, Γ |-
M': B, where  M'  is the β-normal form of  [N/x]M. Then, with another mix we get

8. Formulae, Types, and Objects
181
Γ1, Γ |- M': B
Γ2, y: B |- P: C
______________________________
Γ, Γ1, Γ2 |- [M'/z]P: C
Again we can apply the induction hypothesis, obtaining the requested derivation.
(×) we only consider the case in which the right upper sequent is obtained by a (×,r,1), the other case
being completely analogous. The derivation has the structure
Γ |- M: Α     Γ |- N: B  
         Γ1, x: Α |- P: C
_________________
_____________________
  Γ |-  <M,N> : A×B
Γ1, z: A×B |- [fst(z)/x]P: C
_____________________________________________
Γ, Γ1 |- [<M,N>/z][fst(z)/x]P: C
where by assumption the proofs ending with   Γ |- M: Α ,  Γ |- N: B   or   Γ1, x: Α |- P: C  do not
contain any mix. We have
[<M,N>/z][fst(z)/x]P: C  ≡  [fst(<M,N>)/x]P: C  =  [M/x]P: C.
Consider the derivation:
Γ |- M: Α            Γ1, x: Α |- P: C
__________________________
     Γ, Γ1, z: A×B |- [M/x]P: C
This proof contains only one mix as its last inference. Furthermore the grade of the cut formula is less
than  g(A×B).  By induction hypothesis, we have the requested cut-free derivation  D'.
Case 2 :  r > 2
The induction hypothesis is that we can eliminate the cut from every derivation  D'  that contains only
one cut as the last inference, and that satisfies either  g(D') < g(D),  or  g(D') = g(D)  and rank(D') <
rank(D).
There are two main cases, namely,  rankr(D) > 1  and  rankl(D) > 1 (with rankr(D) = 1).
2.1. rankr(D) > 1:  we distinguish several subcases according to the logical inference whose lower
sequent is S2.
2.1.1. The sequent  S2  is the lower sequent of a weakening rule, whose weakening formula is not
the cut formula. The derivation  D  has the structure

8. Formulae, Types, and Objects
182
    Γ1 |- N: B
_____________
Γ |- M: A       
y: C, Γ1 |- N: B
___________________________
Γ, y: C, Γ1* |-  [M/x]N: B
Consider the derivation  D'
Γ |- M: A
            Γ1 |- N: B
___________________________
Γ, Γ1* |-  [M/x]N: B
where the grade of  D'  is the same of  D,  namely  g(A).  Moreover, the two derivations have the
same left rank, while  rankr(D') = rankr(D) - 1;  thus we can apply the induction hypothesis. With a
weakening and some exchanges we obtain the requested mix-free derivation.
2.1.2. The sequent  S2  is the lower sequent of an exchange rule. Similarly.
2.1.3. The sequent  S2  is the lower sequent of a contraction rule. This is the main source of problems
with the cut rule (see discussion at the end of the proof). With the mix rule, everything is instead very
easy. For instance, let us consider the case when the contracted formula is a cut formula (the other
case is even simpler). The derivation has the structure
   Γ1, x: Α, y: A |- N: B
____________________
Γ |- M: A
Γ1, z: Α |- [z/x][z/y]N: B
_______________________________
Γ, Γ1* |-  [M/x][z/x][z/y]N: B
where  z∈x .
Consider the derivation D'
Γ |- M: A
 Γ1, x: Α, y: A |- N: B
______________________________
Γ, Γ1* |- [M/x']N: B
where  x'  is obtained from  x  by erasing  z  and adding  x, y.
The grade of  D'  is the same of  D,  namely  g(A).  Moreover,  the two derivations have the same
left rank, while  rankr(D') = rankr(D) - 1;  thus we can apply the induction hypothesis, and we obtain
a cut-free derivation  D"  of  Γ, Γ1* |- N': B, where  N'  is the β-normal form of  [M/x']N: B. Since
[M/x][z/x][z/y]N: B ≡ [M/x']N: B, the proof is completed.
2.1.4. The sequent  S2  is the lower sequent of a logical inference  J,  whose principal formula is not
a cut formula.

8. Formulae, Types, and Objects
183
The last part of the derivation  D  looks like
Γ1 |- N: B
________   J
Γ |- M: A       Γ2 |- P: C
____________________
     Γ, Γ2* |-  [M/x]P: C
where the derivations of  Γ |- M: A   and  Γ1 |- N: B  contains no mixes, and  Γ1  contains all the cut
formulae of  Γ2.  Consider the following derivation  D':
Γ |- M: A
Γ1 |- N: B
_____________________
    Γ, Γ1* |-  [M/x]N: B
The grade of  D'  is the same as that of  D,  namely  g(A).  Moreover, the two derivations have the
same left rank, while  rankr(D') = rankr(D) - 1;  thus we can apply the induction hypothesis, and we
obtain a cut-free derivation  D"  of  Γ, Γ1* |- N': B,  where  N'  is the β-normal form of  [M/x]N: B.
Now we can apply the  J  rule to get:
Γ, Γ1* |-  N': B
_____________    J
Γ, Γ2* |-  P': C
and clearly  P'  is the β-normal form of  [M/x]P: C  (the inference rules are sound w.r.t. equality of
proofs).
2.1.5. The sequent  S2  is the lower sequent of a logical inference J, whose principal formula is a cut
formula. We treat only the case of the arrow.
(→)  the derivation  D  has the structure
Γ1 |- N: A       Γ2, y: B |- P: C
________________________
Γ |-  M: A→B
Γ1, Γ2, z: A→B |- [zN/y]P: C
___________________________________________
Γ, Γ1*, Γ2* |- [M/x][zN/y]P: C
where  z∈x.
Let  v1, v2  be the variables of  x,  which are respectively in  Γ1  and  Γ2.  Note that  v1 and v2
cannot be both empty by the hypothesis about rank.
If  v1, v2  are both nonempty, consider the following derivations  D1  and  D2:

8. Formulae, Types, and Objects
184
D1:
     D2:
Γ |-  M: A→B    Γ1 |- N: A
Γ |-  M: A→B
Γ2, y: B |- P: C
_____________________
_____________________________
    Γ, Γ1* |- [M/v1]N: A
        Γ, Γ2*, y: B |- [M/v2]P: C
If  v1 (v2)  is empty, and thus  Γ1 = Γ1* (Γ2 = Γ2*),  let  D1 (D2)  be as follows:
D1:
D2:
   Γ1 |- N: A
   Γ2, y: B |- P: C
 __________
   ____________
  weakenings
      weakenings
___________
_______________
Γ, Γ1* |- N: A
Γ, Γ2*, y: B |- P: C
The grade of  D1  and  D2  is the same as that of  D,  namely   g(A→B).  Moreover,  rankl(D1) =
rankl(D1) = rankl(D),  and  rankr(D1) = rankr(D1) = rankr(D) - 1.  Hence, by induction hypothesis,
there exist two derivations  D1'  and  D2'  respectively ending in the sequents
Γ, Γ1* |- N1: A
with  N1 β-normal form of  [M/v1]N: A
Γ, Γ2*, y: B |- P1: C 
with  P1  β-normal form of  [M/v2]P: C.
Let  w  be the vector of variables in  Γ,  and let  w', w"  be two vectors of fresh variables of the
same length.  Let   Γ' = [w'/w]Γ,  Γ" =[w"/w]Γ  be the sequences of assumptions obtained by
renaming the variables in  Γ.  Let also  N1' ≡ [w'/w]N1  and  P1' ≡ [w'/w]P1  be the results of the
same operation on the two terms  N1  and  P1.
Consider the derivation  D'
Γ', Γ1* |- N1': A 
    Γ", Γ2*, y: B |-  P1': C
_______________________________________
Γ |-  M: A→B
 Γ', Γ1*, Γ", Γ2*, z: A→B |- [z(N1')/y](P1'): C
_________________________________________________________
Γ, Γ', Γ1*, Γ", Γ2* |- [M/z][zN1'/y]P1': C.
The grade of  D'  is the same of  D, namely,  g(A→B). Moreover,  rankl(D') = rankl(D), and
rankr(D') = 1,  since  z: A→B  is the only cut formula. We can apply again the induction hypothesis,
getting a mix-free derivation of the final sequent
Γ, Γ', Γ1*, Γ", Γ2* |-  P2: C      with   P2  β-normal form of  [M/z][zN1'/y]P1'.
Identifying by means of contractions (and exchanges) the variables in  Γ, Γ',  Γ",  we get a mix-free
derivation of  Γ, Γ1*, Γ2* |-  P3: C , where  P3  is a β-normal form of  [w/w'][w/w"]P2.
Note now that:
    [w/w'][w/w"]P2 =  [w/w'][w/w"][M/z][zN1'/y]P1'
≡  [M/z][z([w/w']N1')/y]([w/w"]P1')

8. Formulae, Types, and Objects
185
≡  [M/z][zN1/y]P1
=  [M/z][z([M/v1]N)/y]([M/v2]P)
≡  [M/z][M/v1][M/v2][zN/y]P
≡  [M/x][zN/y]P: C.
2.2. rankl(D) > 1  (and rankr(D) = 1)
This case is proved in the same way as is 2.1 above.
This completes the proof of lemma 8.4.4  and, hence, of the cut-elimination theorem. ♦
8.5 Categorical Semantics of Derivations
In this section we will study the categorical semantics of the intuitionistic proof theory developed in
the last section.  The main idea is that a formula  A  is interpreted as an object  I(A)  in a category C.
A provable sequent  B1,..., Bn |- A  is then associated with a morphism  f: I(B1)⊗...⊗I(Bn)→I(A),
where  ⊗: C×C→C  is a suitable bifunctor that gives meaning to the comma in the l.h.s. of the
sequent. Since the comma is associative and commutative, ⊗ is a symmetric tensor product.
Moreover, we need some sort of projections for the weakening rule, and a diagonal map in the
contraction rule. Actually, all these morphisms, together with a few reasonable equations, turn  ⊗
into a categorical product.
Since  C |- A⇒B  iff  C, A |- B,  it is natural to interpret the implication  ⇒  as the right adjoint to
the functor  ⊗.
Also the binary connective  ×  is bifunctor of the category. In particular, the fact that  C |- A×B  iff
(C |- A  and  C |- B)  suggests that  ×  should be interpreted as a categorical product. As a
consequence  ⊗  and  ×  coincide to within isomorphism, that is consistent with the well-known fact
that the comma in the l.h.s. of a sequent has the same logical meaning of a conjunction. Anyway,
since they are different concept, we prefer to maintain the distinction at the semantical level.
8.5.1 Definition  A categorical model of the positive intuitionistic calculus is a pair  (C,IAt),
where C is a Cartesian closed category (possibly with two specified products ⊗ and × ), and  IAt   is
a map that takes every atomic formula to an object of C.
Notation  In the rest of this chapter, we shall use the same symbols  ⇒  and  ×  for indicating both
the connectives of the calculus and the associated functors of the category: the intended meaning is
clear from the context.

8. Formulae, Types, and Objects
186
The analysis of the cut-elimination theorem will provide a more convincing justification for the
previous notion of model. Now we concentrate on the interpretation.
I  is extended to all the formulae in the following way:
I(A) = IAt(A)
if A is atomic
I(A⇒C) = I(A)⇒I(C)
I(A×C) = I(A)×I(C)
The categorical interpretation does not give meanings to sequents, but to derivations. Every derivation
D  whose final sequent is  B1, . . . , Bn |- A  is interpreted by a morphism
I(D) = f:  I(B1)⊗ . . . ⊗I(Bn) → I(A)
Before giving the details of the interpretation, we recall a few results about Cartesian closed
categories, and fix the notation.
We call  weak-lA,B: A⊗B→B, weak-rA,B: A⊗B→A  the projections associated with the product
⊗,  and  fstA,B: A×B→B,  sndA,B: A×B→A  the projections associated with the product ×.
We have the natural isomorphisms assocA,B,C: (A⊗B)⊗C→A⊗(B⊗C) and exchA,B:
A⊗B→B⊗A,  given by the symmetric monoidal structure associated with  ⊗.  Moreover, we have a
diagonal map  ∆A = <idA,idA>: A→A⊗A  and an the evaluation map  evalA,C: (A⇒C)⊗A→C.
The interpretation is given by induction on the length of the derivation. We define it in a somewhat
informal but suggestive (and concise) way, associating with every inference rule of the calculus in
8.3.4 a respective semantic rule.  This will be enough as for the categorical meaning of the
intuitionistic system in section 8.3.
8.5.2 Interpretation
(axiom)
idA  : A → A
         f:  A⊗(B⊗C) → D
(associativity)
_________________________
f ° assocA,B,C:  (A⊗B)⊗C → D
      f:  B⊗A → C
(exchange)
___________________
f ° exchA,B:  A⊗B → C
             f: B → C
(weakening)  
_____________________
f ° weak-lA,B:  A⊗B  → C

8. Formulae, Types, and Objects
187
     f:  (Α⊗Α)⊗B → C
(contraction)  
____________________
f ° ∆A⊗idB:  A⊗B → C
f:  B → A      g: Α⊗D → C
(cut)
______________________
    g ° f⊗idD :  B⊗D → C
   f:  B⊗Α  → C
  f: E → A       
  g: C → D
(→, r)
_____________
(→, l ) _____________________________
Λ(f):  B → A⇒C
            g ° evalA,C ° id⊗f:   (A⇒C)⊗E → D
f:  C → Α      g: C → B  
             f:    A⊗C → D
(×, r)
__________________ 
(×, l, 1) _________________________
   <f,g>:  C → A×B
f ° fstA,B⊗idC: (A×B)⊗C → D
             f:    B⊗C → D
(×, l, 2) __________________________
f ° sndA,B⊗idC: (A×B)⊗C → D.
8.6 The Cut-Elimination Theorem Revisited
In this section, we look at the cut elimination theorem from the categorical point of view. Our goal is
to provide a more convincing justification of the categorical notion of model, not a further proof of
cut-elimination. Indeed the notion of CCC imposes some identifications between derivations that are
not evident at the logical level of the inference rules. The fact is that we are not interested in giving
semantics to the provability relation among formulae, but more generally to the whole proof system,
with its associated normalization procedures. The point is that the equalities, which define CCC's,
reflect the identity of derivations up to normalization. In particular, we have the following result.
8.6.1 Theorem (The Cut-Elimination Theorem)  Let  D  be a derivation of the sequent  A |-
B.  Then there exists a cut-free derivation  D'  whose final sequent is  A |- B,  and such that in every
model  I(D) = I(D').
We do not prove the previous result, but instead analyze in detail some examples of derivations
identified by the cut-elimination process. Our aim is to show that the Cartesian closed structure is
imposed by this identification of proofs up to normalization. The examples are instrumental to this.

8. Formulae, Types, and Objects
188
8.6.2 Example  If in the following derivation the left upper sequent  A |- A  is an initial sequent,
the cut is eliminated by taking the derivation of the right upper sequent
A |- A                    A |- B
____________________
A |- B
At the semantic level, we have the situation:
idA: A → A       f:  A → B
_____________________
f ° idA:  A → B
thus a model must satisfy the equation  f ° idA = f .  Analogously, when the right upper sequent is an
axiom, we derive the equation  idA ° f = f
8.6.3 Example  Consider a derivation whose final part looks like
  B |- C
________
D |- A
A, B |- C
___________________
D, B |- C
the cut is eliminated in the following way:
  B |- C
________
D, B |- C
At the semantic level we have the following situation:
f: B → C
_____________________
g:  D → A
 f ° weak-lA,B:  A⊗B → C
__________________________________
       f ° weak-lA,B ° g⊗idB:  D⊗B → C
and
f: B → C
_____________________
f ° weak-lD,B:  D⊗B → C
thus, for every  g: D→A,  we must have
weak-lD,B = weak-lA,B ° g⊗idB : D⊗B→C
(*)

8. Formulae, Types, and Objects
189
The previous equation is clearly true if  ⊗  is a categorical product, and  weak-lD,B  is the associated
right projection.
8.6.4 Example  Consider a derivation whose final part looks like
A, A  |- B
________
D |- A
   A |- B
__________________
D |- B
This is the annoying case of the contraction. With the help of a mix rule, the derivation reduces to
D |- A
A, A  |- B
___________________
D  |- B
Regarding the mix as a simple abbreviation of a series of cuts and structural inferences, the previous
derivation is logically equivalent to
D |- A
A, A  |- B
___________________
D |- A 
D, A  |- B
___________________
D, D  |- B
_________
D |- B
At the semantic level we have
  f: A⊗A  → B
______________
g:  D → A       f ° ∆A :  A → B
________________________
f ° ∆A ° g:  D→ B
which reduces to
g:  D → A          f: A⊗A → B
________________________
g:  D → A 
      f ° g⊗idA :  D⊗A → B
___________________________________
f ° g⊗idA ° idA⊗g : D⊗D → B
__________________________
    f ° g⊗g ° ∆D : D⊗D → B

8. Formulae, Types, and Objects
190
This implies that in a model we expect
∆A ° g = g⊗g ° ∆D
(+)
that is the naturality of  ∆ .
8.6.5 Example  Consider the derivation
B, Α  |- C
E |- A       C |- D
________
_____________
B |- A⇒C
 (A⇒C), E |- D
________________________________
B, E |- D
The last cut is eliminated by introducing two other cuts of lesser grade, namely
B, Α  |- C       C |- D
________________
E |- A
       B, A |- D
______________________________
     B, E  |- D
At the semantic level this gives
  h:  B⊗Α → C
     f: E → A
    g: C → D
_____________
_____________________________
Λ(h):  B → A⇒C
g ° evalA,C ° id⊗f:   (A⇒C)⊗E → D
________________________________________________
g ° evalA,C ° id⊗f ° Λ(h)⊗id:   B⊗E → D
that reduces to
h:  B⊗Α → C       g: C → D
______________________
 f: E → A
        g ° h :  B⊗Α → D
_______________________________________
g ° h ° id⊗f : B, E → D
Note that in a Cartesian closed category, by the  β-axiom of exponents, one has
g ° evalA,C ° id⊗f ° Λ(h)⊗id = g ° evalA,C ° Λ(h)⊗id ° id⊗f  = g ° h ° id⊗f.
This completes the observation that the Cartesian closure may be described in terms of equivalence of
proofs, up to normalization.

8. Formulae, Types, and Objects
191
8.7 Categorical Semantics of the Simply Typed Lambda Calculus
In sections 8.3 and 8.4, we have investigated the relation between typed lambda calculus and
intuitionistic logic, and in sections 8.5 and 8.6 we have established the connection between
intuitionistic logic and Cartesian closed categories. In this section we want now to “fill the triangle”
among typed lambda calculus, intuitionistic logic and Cartesian closed categories, studying the
missing edge - namely the categorical semantics of the Typed Lambda Calculus, over CCC's.
The main idea of the categorical semantics of the typed lambda calculus is to interpret types as
objects and terms as morphisms of a category C. In particular, the reader has probably noted some
analogy between the axioms of  λβηπt  and the axioms defining products and exponents in Cartesian
closed categories. The relation is quite evident in the case of products: fstσ×τ→σ  and  sndσ×τ→τ
are easily understood as the projections associated with the categorical product of  σ  and  τ.  Apart
from the problem of switching from “application” to “composition,” the axioms of  λβηπt  regarding
the product are essentially identical to the axioms in definition 1.3.3 of categorical product.  Less
immediate is the connection between  β  (and  η)  and the rules defining the exponents of a CCC: the
main problem is that the definition in the calculus is based on the process of substitution, for which
we do not have any immediate equivalent in Category Theory.  Let us look a little closer at our
tentative interpretation: the intuitive idea is that a term  Mτ  with free variables among   x1σ1, ...,xnσn
should be interpreted as a morphism Mτ  from   ∆ = σ1×...×σn  to  τ.  Suppose now that we have
two terms  Mτ  and  Nγ,  such that the free variables of  [Nγ/ xγ]Mτ  are in  ∆= σ1×...×σn.  Then
look at  Mτ  like an arrow from  ∆×γ  to  τ, and at  Nγ  like an arrow from  ∆  to  γ.  The effect of
substituting  Nγ  for  xγ  in  Mτ  is simply achieved  by composing  Mτ  with   < id∆, Nγ  >.
These considerations are formalized in substitution lemma 8.7.6 below, which plays a central role in
the semantics of functional languages.  Note now that in every CCC, one has
(βcat)    eval ° <Λ(f),g> = eval ° Λ(f)×id ° <id,g> = f ° <id,g>
which, by our interpretation of substitution, is just the categorical equivalent of β-conversion in λ-
calculus.

8. Formulae, Types, and Objects
192
We now begin a formal discussion on the categorical interpetation of typed λ-calculus, by
outlining a simple and very intuitive, set-theoretic definition of model for  λβηπt.  This is just a
definition and will be instrumental to the categorical characterization below. In particular, it will allow
us to relate the category-theoretic approach to the Tarskian view in semantics. For a more direct
connection between  λβηπt  and CCC's, see the references.
The collection  Tp  of types over a set  At  of ground types has been defined in section 8.2.  As
types will be largely used as indexes (of terms), in this section we go back to the use of small greek
letters  σ,τ....  as metavariables for types.
8.7.1 Definition  Let  C = {Ci | i∈At}  be a collection of sets. Then  TSC = {Cσ}σ∈Tp  is a
type structure over  C  iff, for all  σ,τ∈Tp,
Cσ→τ  ⊆ Cσ → Cτ (= Set[Cσ,Cτ])
Cσ×τ  = Cσ×Cτ .
8.7.2 Definition A type structure  TSA = ({Aσ}σ∈Tp, [ ])  is a model of typed λ-calculus (with
products) iff  [ ]  yields an interpretation for  λβη(π)t.  That is, for any environment  h: Var →
Uσ∈Tp (Aσ} with  h(xσ)∈Aσ, one has  [Mρ]]]]h∈Aρ,  for each  ρ∈Tp   and for  [ ]  defined by
Var.
[xσ]]]]h = h(xσ)
App.
[Mσ→τNσ]h = [Mσ→τ]h ([Nσ]h)
β.
[λxσ.Mτ]h(a) = [Mτ]]]]h[a/xσ]    for  a ∈ Aσ
π.
[ fstσ×τ→στ]h  = p1   ,   [ sndσ×τ→στ]h = p2
where  p1, p2   are the set-theoretic projections (of proper types).
This is a good definition of model, i.e., the axioms and rules are realized and, given a model  TSA
λβη(π)t,  one actually has
λβη(π)t | Mσ = Nσ  ⇒  TSA |= Mσ = Nσ.
Indeed, the reader will be asked to check the validity of axiom  (β)  in the exercise before 8.7.7.
Note also that, in a model, axiom  (η)  and rule  (ξ)  trivially hold, since λ-terms are interpreted as
functions in extenso and, hence, one has
η.  ∀a   [λyσ.Mσ→τyσ]]]]h(a) = [Mσ→τ]]]]h(a)  , for  yσ∉FV(Mσ→τ),   and
ξ.  ∀a   [Mτ]]]]h[a/xσ] = [Nτ]]]]h[a/xσ]   ⇒   [λxσ.Mτ]]]]h = [[[[λxσ.Nτ]]]]h ,
by  (β)  and by   [λxσ.Pτ]h∈Aσ→τ  ⊆ Aσ→Aτ.
The properties of projections and pairing, in case one considers λβηπt, are trivially realized by
the definition of product.
Thus a type-structure TSA is a model of  λβη(π)t  iff
λβη(π)t | Mσ = Nσ  ⇒  TSA |= Mσ = Nσ.

8. Formulae, Types, and Objects
193
Since the previous definition of model is set-theoretic, a suitable notion of “concreteness” for
categories can help in studying categories as models. The minor loss of generality, in this case, is
balanced by the gain in intuition.
In general, concrete categories are widely used in denotational semantics; they are (usually)
defined by an  “enough points” requirement.
8.7.3 Definition.  Let C be a category.  t∈ObC is a generator iff for all  a,b∈ObC  and all
f,g∈C[a,b],  f ≠ g  ⇒  ∃h∈C[t,a]  f°h ≠ g°h .
C has enough points if there exists a generator  t  that is terminal in the given category.
The terminology derives from the idea that the arrows in C[t,a], when  t  is terminal, may be
understood as the points (or elements) of  a.  Indeed, we can associate with each category C having
enough points a category of sets Cset as follows.  For  a,b∈ObC and  t  terminal
objects:  |a| = C[t,a]
morphisms:  f∈Cset[|a|,|b|]  iff  ∃f'∈C[a,b]  f = f'° _ .
Observe that  f'  is unique once  f  is given.
8.7.4 Proposition.  If C is a CCC with enough points, then Cset is also a CCC with enough
points.
Proof  If  cσ→τ  and  cσ×τ  are the exponent and product objects, in C, of  cσ  and  cτ, then  |cσ→τ|
and  |cσ×τ|  are the exponent and product objects, in Cset, of  |cσ|  and  |cτ|. As for the exponent, just
set  evalset = eval°_ , and  Λset(f) = Λ(f')°_ , where  f'  defines  f  as above. The rest is easy. ♦
Note that one obtains type structures from all categories with enough points That is, let K be a CCC
with enough points and  C = {ki | i∈At} ⊆ ObK. Let also  kσ→τ  and  kσ×τ  be the exponent and
product objects, in K, of  kσ  and  kτ. Then  KC = {K[T,kσ] |  σ∈Tp }  is the type structure
generated by K and C.
Examples.  The simplest type structures are the “full” type-structures and the “term model” of
λβη(π)t .  That is, SetC, where C is a collection of sets, and Term = ({Termσ}σ∈Tp, [ ] ), where
Termσ  is the set of terms of type  σ  modulo  βη  convertibility.
8.7.5 Definition  Let C be a CCC, with terminal object  t  and projections  fst, snd.  Suppose one
has a map  I  associating every atomic type  A  with an object of  C.  Then the categorical
interpretation is as follows:
- Types:
[σ] = I(σ)  
if  σ  is atomic
[σ→τ] = [τ][σ]

8. Formulae, Types, and Objects
194
[σ×τ] = [σ] × [τ]
- Terms:  let  Mσ  be a term of  λβηπt,  with  FV(Mσ) ⊆ ∆ = {xσ1,…,xσn},  and assume that
A, A1,…,An interpret  σ, σ1,…,σn  (we omit typing, when unambiguous, and write
pi∈C[t×A1×...×An ,Ai]  for the projection  pi : t×A1×...×An  → Ai ).  Then  [Mσ]∆  is the
morphism in  C[t×A1×...×An,A]  defined by
[xσi]∆ = pi
[MN]∆ = eval ° <[M]∆, [N]∆>
[λxτ.M]∆ = Λ([M]∆∪{xτ} )
[<M, N>]∆ = <[M]∆, [N]∆ >
[fst (M)]∆ = fst ° [M]∆
[snd (M)]∆ = snd ° [M]∆ .
8.7.6 Substitution Lemma
i.   If  yσ∉FV(N) ,  then  [N]∆∪{yσ} = [N]∆ ° fst
ii.  [ [N/xσ]M ]∆ =  [M]∆∪{xσ} ° <id,[N]∆>  (types are omitted when unambiguous).
Proof
i. By induction on  M. The following is the typical case:
[λxτ.P]∆∪{yσ} = Λ([P]∆∪{yσ, xτ} )
= Λ([P]∆∪{xτ,yσ}°ξ)
for  ξ: (a∆×aσ)×aτ ≅  (a∆×aτ)×aσ
= Λ([P]∆∪{xτ}°fst°ξ )
by induction
= Λ([P]∆∪{xτ}°fst×id)
as  fst°ξ = fst×id
= Λ([P]∆∪{xτ}) ° fst 
by the naturality of  Λ.
ii. By induction on  M:
M ≡ xσ
[xσ]∆∪{xσ} ° <id,[N]∆> =  snd ° <id,[N]∆>
=  [N]∆
=  [ [N/ xσ ] xσ ]∆
M ≡ xσi
[xσi]∆∪{xσ} ° <id,[N]∆> = pi ° fstT×A1×...×An ,A ° <id, [N]∆>   (σi≠σ)
= pi
= [xσi]∆
M ≡ QP
[QP]∆∪{xσ} ° <id,[N]∆> = eval ° <[Q]∆∪{xσ},[P]∆∪{xσ} > ° <id,[N]∆>
= eval ° <[Q]∆∪{xσ}°<id,[N]∆>,[P]∆∪{xσ}>°<id,[N]∆>
= eval ° <[ [N/xσ] Q ]∆,[ [N/xσ]P ]∆>
= [ [N/xσ] PQ ]∆

8. Formulae, Types, and Objects
195
M  ≡ λyτ.P
             [ [N/xσ] λyτ.P ]∆=  Λ([ [N/xσ]P ]∆∪{yτ})
= Λ([P]∆∪{yτ,xσ}° <id,[N]∆∪{yτ}>) by induction
= Λ([P]∆∪{yτ,xσ}° <id,[N]∆°fst>)
by  (i)
= Λ([P]∆∪{xσ,yτ}) ° <id,[N]∆>
by naturality (as in (i))
= [λyτ.P]∆∪{xσ} ° <id,[N]∆>.
As for pairing and projection, the computation is easy and is left for exercise. ♦
The lemma may suffice to give an interpretation of  λβηπt  over an arbitrary CCC. Indeed, nothing
else is required from a purely categorical perspective, i.e., adopting a more suitable notion of model.
In particular, it is worth noting that the previous categorical semantics of the typed lambda calculus
really “fills the triangle” we talked about at the beginning of this section. We leave it as an exercise for
the reader to verify that a term and its categorical interpretation with respect to the previous definition
are actually associated with the same derivation in intuitionistic logic.
However, as many, since Tarski, are used to interpreting formal systems into mathematical
structures by first assigning values to variables by means of environments as set-theoretic maps, we
complete the construction of models (as defined at the beginning of the section) with the following
exercise and theorem.
Exercise  Prove a version of lemma 8.7.6 in the style of definition 8.7.2.  That is, show that in any
model and for any environment  h,  one has (we omit types for simplicity)
[M]h[[N]h/xσ] = [ [N/xσ]M ]h .
This gives axiom  (β)  in the model.
8.7.7 Theorem  Any CCC with enough points C and any collection  {ai}i∈At   of objects in C
yield a model of λβηπt .
Proof Let C be the given category and let  A = {|ai| / i∈At}  be the collection of sets in  Cset  that
interpret the atomic types.  Then the model is given by the type structure  TSA = CsetA,  i.e., the
higher types are interpreted by  |cσ×τ|  and  |cσ→τ| .  As a matter of fact, let  h : Var → Uσ∈Tp{|cσ|}
be an environment.  Fix   Mσ   and let  FV(Mσ) ⊆ ∆ = {xσ1,…,xσn} .  By definition,  h(xσi)∈|cσi|,
then set  h∆ = <id,h(xσ1),...,h(xσn)>∈C[t,t×cσ1×...×cσn]  and define
[Mσ]h = [Mσ]∆°h∆∈ |cσ|.
It is now easy to check that the map  Fh,  defined by  Fh(e) = h[e/x]∆,  for  e∈|cσ|,  is in
Cset[|cσ|,|cσ1×...×cσn| ].  Thus, there exists  h'∈C[cσ,cσ1×...×cσn]  such that  Fh = h'°_  and,
hence,  h[e/x]∆ = h'° e. This fact and the substitution lemma guarantee that  [ _ ]  is a well-defined
interpretation map and, thus, that  CsetA  is a model. ♦

8. Formulae, Types, and Objects
196
We now need to prove the converse and construct a CCC out of every model of λβηπt.  Observe first
that by functional application, over a type structure, one may define algebraic functions as follows.
8.7.8 Definition  Given a type-structure  TSC = {Cσ}σ∈Tp,  the typed monomials over TSC
are defined by
constants
aσ∈Cσ, ...   are typed monomials, for all  σ∈Tp
variables 
xσ, yσ,....   are typed monomials, for all  σ∈Tp
application
Mσ→τ(Nσ)  is a typed monomial, when  Mσ→τ and  Nσ are typed monomials.
A function  f : Cσ→Cτ   is algebraic  if  f(aσ) = [aσ/xσ]Mτ  for some typed monomial  Mτ .
The intuition is that algebraic functions will give the morphisms of a “rich enough” category as to
interpret typed λ-terms.  It is clear, for example, that projections are algebraic functions:  just set
send((xσ, yτ)) = xσ,  then  snd : Cσ×τ →Cτ  is the second projection.
8.7.9 Lemma  Given a type-structure  TSA = {Aσ}σ∈Tp ,  one obtains a category with enough
points by taking the singleton set, the  Aσ 's  as objects and the algebraic functions as morphisms.
Call this category CTSA.
Proof  Exercise. ♦
8.7.10 Theorem  Let  TSA = {Aσ}σ∈Tp x  be a model of  λβηπt  and let  CTSA  be as in the
lemma.  Then CTSA is a CCC.
Proof Products are defined by taking   Aσ×Aτ = Aσ×τ.  Then, if the typed monomial  M  defines  f
and  N  defines  g,  <M,N>  defines  <f,g>,  as the formal pairing and projections behave as required
in Cartesian categories.
As for exponents, set  AτAσ = Aσ→τ .  Then
eval :  Aτ→ρ×Aτ→Aρ   is defined by  x |_  fst xτ→ρ×τ(snd xτ→ρ×τ).
Moreover, if  f : Aσ×Aτ→Aρ  is defined by  M,
Λ(f) : Aσ→AρAτ  is defined by  λxτ.M.
Finally observe that axiom  (β)  gives  (βcat)  in definition 2.3.1, while  (η)  gives  (ηcat). ♦
By the following exercise we let the careful reader relate the two interpretations of λ-terms given so
far.
Exercise  Compare in detail the categorical and set-theoretic meanings of terms.  Namely, start with
a TSA, which is a model, and construct a CTSA as in 8.7.9.  (Note that in this construction, lots of
- irrelevant - morphisms may be lost).  Then construct a new TS'A as in 8.7.7 (this will be a
“substructure” of  TSA, up to an obvious identification).  Consider now an interpretation  [ - ]]]]h  over

8. Formulae, Types, and Objects
197
TSA, where the range of  h,  though, is restricted to TS'A.  Define  [ - ]∆  as in 8.7.5 over CTSA
and, finally, give  [ - ]]]]'h  over TS'A by using  h  and  [ - ]∆  as in 8.7.7.  Prove then that  [ - ]]]]h
and  [ - ]]]]'h  coincide.  Thus, we moved from TSA to CTSA and to TS'A, preserving the meaning
of terms.
Conversely, by an even longer and more tedious proof, go from an interpretation  [ - ]∆  over a
Cartesian closed category C, to a model TSA, where the interpretation  [ - ]]]]h  is given by 8.7.7.
Construct then a CTSA as in 8.7.9 and observe that it may be faithfully embedded into C.  Relate by
this  [ - ]∆,  over C, and the interpretation  [ - ]'∆,  given as in 8.7.5, over CTSA.  (The connection
between set-theoretic and categorical meaning of terms will be more closely investigated for the type-
free case in the next chapter).
8.8 Fixpoint Operators and CCCs
The typed lambda calculus is strongly normalizable, that is:
1.  every computation terminates, and
2.  the computation is independent from the evaluation strategy.
The latter property is surely very attractive for a computational language since it greatly simplifies its
semantics: the programmer, in the design of the code, does not have to fuss over the operational
evolution of reduction, but can concentrate on the denotation of the program in its strongest meaning.
Considered by itself, the first property also seems to be quite interesting, but it has the rather
annoying corollary that not all “computable” functions (e.g., Turing-computable) will be computable
in the language. The problem is not only related to the abstract expressiveness of the language; in
today’s computer science, the idea of “general purpose” language is no longer considered as central as
it was twenty years ago, and the loss of the ability to compute, for example, the Ackermann function,
does not worry anybody: primitive recursive functions are surely enough for most interesting
applications. What makes the general recursive formalism more attractive than the primitive recursive
one, is that it is much easier to write code in the general formalism (also for computing a primitive
recursive function).
Coming back to the typed lambda calculus, it is otherwise too poor for any application, so we face
the problem of extending the language with more powerful constructs. In chapter 11, we shall study
the “second order” or “polymorphic” extension, which still has the nice property of strong
normalization together with a great formal expressiveness (although, as a programming language, it
imposes on the programmer a completely new approach to the design of the code). We study for the
moment a simple extension by means of fixpoint operators, which enables us to write recursive
definitions of functions.
The reader should be aware, though, that a price must be paid when extending typed languages by
fixpoint operators. The problem is related to the Curry-Howard analogy (see section 8.3). Remember

8. Formulae, Types, and Objects
198
that a (constructive) proof of a formula  A  corresponds with a closed λ-term of type  A  in type
theory, and, thus, a formula is provable in the logic if and only if the corresponding type is
“inhabited” in type theory.  The existence of fixpoint operators has as a consequence that all types are
inhabited, or, from the logical point of view, that all formulae are provable (see later).  Thus fixpoint
operators have no logical correspondent; nevertheless, the calculus they originate is not inconsistent
from the point of view of the equational theory of programs (that is, not all terms happen to be
provably equal).  This is shown by the models below.
In conclusion, the programmer, in the present context, must decide whether to acquire the full
expressive power and the elegance of programming by “recursive definitions” or to preserve the
advantages of the “types as formulae” paradigm.  This choice depends on the specific applications he
or she has in mind.
8.8.1 Definition  A fixpoint operator of type  σ  is a term  Θσ  of type  (σ→σ)→σ  such that , for
every term   Mσ→σ  one has
Mσ→σ (Θσ Mσ→σ) = Θσ Mσ→σ.
By fixpoint operators one can simulate recursive definitions in the following way:
letrec  fσ  be  Mσ[f]  in  Nγ[f]
becomes
(λhσ.Nγ) ( Θσ(λ fσ.Mσ))
Note that for every type  σ  we have at least an object of that type, obtained as a fixpoint of the
identity
Θσ (λxσ.xσ).
We consider next the problem of giving an interpretation to fixpoint operators. As we need to
interpret typed λ-calculi, this will be done in suitable CCC's.
8.8.2 Definition  Let  b  be an object of a CCC  C. A fixpoint operator for  b  is a morphism
Fixb: bb→b  such that  Fixb = evalb,b° <id,Fixb>.  A category has fixpoint operators if each
object  b  has a fixpoint operator  Fixb .
In every CCC with fixpoint operators, it is easy to give meaning to the axiom
fix.   Mσ→σ ( Θσ Mσ→σ) = Θσ Mσ→σ
by letting
{Θσ}∆ = Λ( Fixσ ° snd) ° !∆,
where  snd: t×σσ→σσ,  and  !∆  is the unique arrow from  ∆  to the terminal object  t.
Indeed, one has the following:

8. Formulae, Types, and Objects
199
{ M(Θσ M) }∆= eval ° <{M}∆, { (Θσ M) }∆>
= eval ° <{M}∆, eval ° < Λ( Fixσ ° snd) ° !∆, {M}∆> >
= eval ° <{M}∆, Fixσ ° {M}∆ >
= eval ° < id, Fixσ > ° {M}∆
=  Fixσ ° {M}∆
= eval ° < Λ( Fixσ ° snd) ° !∆, {M}∆>
= { (Θσ M) }∆.
It is not difficult to find CCC’s with fixpoint operators. The most well-known example is
probably the category CPO, with complete partial order for objects and continuous functions for
morphisms (remember that, in CPO,   f: A→B   is continuous if and only if  f  is monotonic and for
every directed subset  D  of  A,  f(∪(D)) = ∪f(D); every c.p.o.has a least element,  ⊥ = ∪∅ ).
Observe that, given a c.p.o.  C  and a continuous function  f , we can form a chain
{fn(⊥C)}n∈ω  =  ⊥C  ≤  f(⊥C)  ≤  f(f(⊥C))  ≤  ....  ≤  fn(⊥C)  ≤ ....
starting from the bottom element  ⊥C.  The next two results develop this example.
8.8.3 Theorem  Let  C  be a CPO, let  ⊥C  be its least element, and let  f: C→C  be a continuous
function. Then  ∪{fn(⊥C)}n∈ω   is the least fixed point of  f .
Proof:   Note that   ∪{fn(⊥C)}n∈ω =  ∪{fn+1(⊥C)}n∈ω .  Then
                f(∪{fn(⊥C)}n∈ω) = ∪f{fn(⊥C)}n∈ω)
= ∪{fn+1(⊥C)}n∈ω).
Moreover, if  c  is another fixed point, then we prove by induction that, for all  n,  fn(⊥C) ≤ c.
Indeed,
⊥C ≤ c
fn(⊥C) ≤ c  ⇒ fn+1(⊥C) ≤ f(c) = c.
Then, by definition of least upper bound,  ∪{fn(⊥C)}n∈ω ≤ c. ♦
8.8.4 Definition   Let  C  be a c.p.o.  Define then  FixC: CC→C  the function that takes every
continuous function  f: C→C  to  ∪{fn(⊥C)}n∈ω .
8.8.5 Proposition   FIXC: CC→C  is continuous.
Proof Exercise.  ♦
In a more general setting, the existence of exponents, in CCC's, suggests the investigation of
those “paradoxical” objects that “contain,” as a retract, their own function space; namely, the reflexive
objects of section 2.3 (see also below). They will turn out to be rather relevant in the next chapter,
where examples are given, and in chapter 10, where the idea will be generalized to fixpoint
constructions over types, namely to the categorical counterpart of recursive definitions of data types.

8. Formulae, Types, and Objects
200
Remember (see definition 1.4.2) that in a category C,  a < b  via the retraction  (i,j)  iff  j ˚ i = ida.
In these assumptions,  i  turns out to be mono and  j  epic.  Thus a retract  a  of  b  is a subobject of
b, up to isomorphisms. An object  V  is reflexive iff  VV < V  (see definition 2.3.5). We next show
how to construct another simple model of the typed lambda calculus with fixpoint operators, by using
the category RetV of retracts over a reflexive object V. Recall that, given an object  V  in a category
C, the category  RetV  is defined as follows (see definition 1.4.4):
ObRetV = { f∈C[V,V] |  f ° f = f }
MorRetV = { (f, k, g) |  f, g∈ObRetV , k∈C[V,V] , k = g ° k ° f }
dom( (f, k, g) ) = f , cod( (f, k, g) ) = g
idf = (f, f, f)
(f, k, g) ° (g', k', f) = (g', k ° k', g)
Proposition 8.8.6 below proves that, if V is a reflexive object in a CCC C, then RetV is Cartesian
closed too.  In theorem 8.8.8 we will prove that, given a reflexive object  V  in an arbitrary CCC,
every object  f  in RetV  has a fixpoint operator  Fixf .
8.8.6 Proposition  If  C  is a CCC  and  V  is a reflexive object in C, then RetV  is a CCC.
Proof  By proposition  2.3.6, we know that the terminal object  t  and V×V are both retracts of  V
(by definition of reflexive object  also  VV<V ).  Suppose the following:
t < V   
via   in, out
V×V < V  
via   in', out'
VV < V
via   in", out".
Let   1= in ° out : V→V.  1 ° 1=  in ° out ° in ° out = in ° out = 1.  1  is the terminal object of RetV .  If
f  is an object in  RetV, then !f: f→1  is (f,1,1).  Note that  (f,1,1) is a well-defined morphism, since
1= 1 ° 1 ° f   for the terminality of  t.  Moreover, if  (f,g,1)  is another morphism, then  g = 1 ° g ° f =
1,  again for the terminality of  t .
Given two objects  f  and  g  in  RetV,  their product is  f⊗g = in' ° f×g ° out': V→V. (In the
present proof only,  ⊗  has this meaning)
Note that
f⊗g ° f⊗g =  in' ° f×g ° out'° in' ° f×g ° out'
= in' ° f×g ° f×g ° out'
= in' ° f×g ° out'
= f⊗g.
The projections are  ( f⊗g, fst, f), ( f⊗g, snd, g)  where
fst = p1 ° out' ° f⊗g : V→V
snd = p2 ° out'° f⊗g : V→V
and  p1, p2 are the projections associated in C to the product  V×V.
The pairing operation  <,>ret  is defined as follows: given two morphisms  (c,h,f)  and (c,k,g)  set

8. Formulae, Types, and Objects
201
< (c,h,f), (c,k,g) >ret = (c, in'° <h,k>,f⊗g)
where <,> is the pairing in C.
This is a good definition, since
      f⊗g ° in'° <h,k> °  c = in' ° f×g ° out' ° in'° <h ° c, k °  c >
by def. of  f⊗g
= in' ° f×g ° <h ° c, k °  c >
= in'° <f ° h ° c, g°  k °  c >
= in'° <h, k >.
We have still to prove the equations associated with the product; we only prove that
( f⊗g, fst, f) ° < (c,h,f), (c,k,g) >ret = (c,h,f)
and leave the other proofs as an exercise for the reader. We have the following:
( f⊗g, fst, f) ° < (c,h,f), (c,k,g) >ret =
= ( f⊗g, fst, f) ° (c, in'° <h,k>,f⊗g)
= ( c, fst ° in'° <h,k>, f) 
by composition in RetV
= ( c, p1 ° out' ° f⊗g  ° in'° <h,k>, f)
by def. of  fst
= ( c, p1 ° out' ° in' ° f×g ° out'  ° in'° <h,k>, f)
by def. of  f⊗g
= ( c, p1 ° f×g ° <h,k>, f) = (c,h,f).
The functor  ⊗  is defined on morphisms in the usual way (namely,  f×g = <p1 ° f, p2 ° g> ).
Specifically, given two morphisms  (c,h,f)  and  (d,k,g):
(c,h,f) ⊗ (d,k,g) = < (c,h,f) ° (c⊗d, fst , c), (d,k,g) ° ( c⊗d, snd, d) >ret
= < (c⊗d, h ° fst , f), ( c⊗d, k° snd, g) >ret 
by composition in RetV
= ( c⊗d, in' ° < h ° fst, k° snd >, f⊗g )
by def. of  <,>ret
= ( c⊗d, in' ° < h ° p1 ° out' ° c⊗d, k ° p2 ° out'° c⊗d >, f⊗g ) by def. of fst, snd
= ( c⊗d, in' ° < h ° p1, k ° p2> ° out' ° c⊗d, f⊗g )
= ( c⊗d, in' ° h×k ° out' ° c⊗d, f⊗g ).
We are now in a position to define the exponents.  If  h, k : V→V,  let  [h,k] = Λ(k ° evalV,V °
(id×h)) : VV→VV.  Given two objects  f  and  g  in  RetV,  their exponent is:
gf =  in" ° [f,g] ° out": V→V.
This is a good definition, since
 gf ° gf =  in" ° [f,g] ° out" ° in" ° [f,g] ° out"
by def. of gf
=  in" ° [f,g] ° [f,g] ° out"
=  in" ° Λ(g ° evalV,V ° (id×f)) ° Λ(g ° evalV,V ° (id×f)) ° out"
by def. of [f,g]
=  in" ° Λ(g ° evalV,V ° (id×f) ° Λ(g ° evalV,V ° (id×f))×id ) ° out"
=  in" ° Λ(g ° evalV,V ° Λ(g ° evalV,V ° (id×f))×id ° (id×f) ) ° out"
=  in" ° Λ(g ° g ° evalV,V ° (id×f) ° (id×f) ) ° out"
by (β)
=  in" ° Λ(g ° evalV,V ° (id×f) ) ° out"
since  g, f are retractions
=  in" ° [f,g] ° out"
by def. of [f,g]
=  gf
by def. of gf.

8. Formulae, Types, and Objects
202
The evaluation function is  ( gf⊗f, ev, g)  where
ev = evalV,V ° (out"×id) °  out' ° gf⊗f
The currying operation  ΛΛΛΛret  is so defined: given a morphism  (c⊗f,h,g),
ΛΛΛΛret(c⊗f,h,g) = (c, in"° Λ(h ° in'), gf ).
This is a good definition of morphism in RetV; indeed
gf ° in"° Λ(h ° in') ° c =
= in" ° Λ(g ° evalV,V ° (id×f) ) ° out" ° in"° Λ(h ° in') ° c
by def. of gf
= in" ° Λ(g ° evalV,V ° (id×f) ) ° Λ(h ° in' ° c×id)out" ° in" = id
= in" ° Λ(g ° evalV,V ° (id×f) ° Λ(h ° in' ° c×id)×id)
= in" ° Λ(g ° evalV,V ° Λ(h ° in' ° c×id)×id ° (id×f) )
= in" ° Λ(g ° h ° in' ° c×id ° id×f )
by (β)
= in" ° Λ(g ° h ° in' ° c×f)
= in"° Λ( g ° h ° c⊗f ° in')
by def. of  c⊗f
= in"° Λ(h ° in').
We only prove the axiom β, and leave as an exercise for the reader to prove η .
(gf⊗f, ev, g) ° ( ΛΛΛΛret(c⊗f,h,g) ⊗ (f, f, f) ) =
= (gf⊗f, ev, g) ° ( (c, in"° Λ(h ° in'), gf ) ⊗ (f, f, f) ) 
by def. of ΛΛΛΛret
= (gf⊗f, ev, g) ° ( c⊗f, in' ° (in"° Λ(h ° in'))×f ° out' ° c⊗f , gf⊗f)
by def. of ⊗ on arrows
= (c⊗f, ev ° in' ° (in"° Λ(h ° in'))×f ° out' ° c⊗f , g)
by composition in RetV
= (c⊗f, evalV,V ° (out"×id) °  out' ° gf⊗f ° in' ° (in"° Λ(h ° in'))×f ° out' ° c⊗f, g)
by def. of  ev
= (c⊗f, evalV,V ° (out"×id) °  gf×f  ° (in"° Λ(h ° in'))×f ° out' ° c⊗f , g)
by def. of  gf⊗f
= (c⊗f, evalV,V ° (out" ° gf ° in"° Λ(h ° in'))×f ° out' ° c⊗f , g )
as  f ° f = f
= (c⊗f, evalV,V ° (Λ(g ° evalV,V ° (id×f)) ° Λ(h ° in'))×f ° out' ° c⊗f , g)
by def. of  gf
= (c⊗f, evalV,V ° ( Λ(g ° evalV,V ° Λ(h ° in')×id ° (id×f) )×f ° out' ° c⊗f , g)
= (c⊗f, evalV,V ° Λ(g ° h ° in'° id×f )×f ° out' ° c⊗f , g)
by  β
= (c⊗f, g ° h ° in'° id×f ° c×f ° out' , g)
by  β
= (c⊗f, g ° h ° c⊗f , g)
= (c⊗f,h,g).
This completes the proof that RetV is a CCC. ♦
8.8.7 Lemma  If  V  is a reflexive object in a CCC  C,  then there is a fixpoint operator  Fix:
VV→V.
Proof  Let
F = eval ° <id, in"> :  VV→V
H = Λ( eval ° (id×(F°out")) ) :  VV→VV
Fix = F°H  is a fixpoint operator for  V;  indeed,

8. Formulae, Types, and Objects
203
F°H = eval ° <id, in"> ° Λ( eval ° (id×(F°out")) )
= eval ° Λ( eval ° (id×(F°out")) )×id ° <id, in" ° Λ( eval ° (id×(F°out")) ) >
= eval ° id×(F°out") ° <id, in" ° Λ( eval ° (id×(F°out")) ) >
= eval ° <id, F ° Λ( eval ° (id×(F°out")) ) >
= eval ° <id, F°H >. ♦
8.8.8 Theorem  Every object  f  in RetV  has a fixpoint operator Fixf .
Proof   Let  Fix: VV→V  be a fixpoint operator for V. Define
Fixf = (ff, Fix ° out" ° ff , f).
We leave it to the reader to prove that this is a good definition, that is:
(*)  Fix ° out" ° ff = f ° Fix ° out" ° ff ° ff.
We must prove that
Fixf = ( ff⊗f, ev, f) ° < (ff, ff, ff), Fixf>,
where  ev = evalV,V ° (out"×id) ° out' ° ff⊗f.
Compute then
Fixf = (ff, evalV,V° <id,Fix> ° out" ° ff, f)
by def. of  Fixf
= (ff, evalV,V ° < out" ° ff, f ° Fix ° out" ° ff>, f)
by  (*)
= (ff, evalV,V ° (out"×id) ° ff×f ° < ff, Fix ° out" ° ff>, f)
= (ff, evalV,V ° (out"×id) °  out' ° ff⊗f ° in' ° < ff, Fix ° out" ° ff>, f −)
by def. of  ff⊗f
= (ff, ev ° in' ° < ff, Fix ° out" ° ff>, f)
by def. of  ev
= ( ff⊗f, ev, f) ° (ff, in' ° < ff, Fix ° out" ° ff>, ff⊗f)
by composition in RetV
= ( ff⊗f, ev, f) ° < (ff, ff, ff), (ff, Fix ° out" ° ff, f) >
by pairing <,> in RetV
= ( ff⊗f, ev, f) ° < (ff, ff, ff), Fixf >. ♦
References.  For an introduction to Proof Theory, natural deduction, and intuitionisitic logic, the
reader can consult Prawitz (1965) and Takeuti (1975). In particular, the latter inspired our
presentation of the cut-elimination theorem. The “formulae as types” analogy is explained in Howard
(1980), but the main ideas go back to work of Curry. The connections between λ-calculus and
CCC’s were first explored by Lambek. The equivalence is shown in Lambek (1980) and Scott
(1980). A full account of the relation between λ-calculus, CCC’s, and Proof Theory may be found in
Lambek and Scott (1986). We tried here to complement that work by relating it to Tarskian semantics
and emphasizing the role of “structures,” for the convenience of the reader who may begin with our
approach and continue with further, more abstract readings. In section 8.7, we dealt only with
CCC's, i.e., with the models of λλλλββββηηηηππππt. Weaker calculi, that is, typed combinatory logic and λλλλββββππππt,
are discussed in Hayashi (1985) and Martini (1988), which introduce various notions of “weak
Cartesian closedness” for this purpose.

9. Reflexive Objects and the Type-Free Lambda Calculus
204
Chapter 9
REFLEXIVE OBJECTS AND
THE TYPE-FREE LAMBDA CALCULUS
The main aim of this book is to present category theoretic tools for the understanding of some
common constructions in computer science. This is largely done in the perspective of denotational
semantics, in particular in this second part of the book. It is commonly agreed that a fruitful area of
application of denotational semantics has been the understanding and, in some cases, the design of
functional languages. This is exactly because the theory of the intended structures is a “theory of
functions,” indeed Category Theory.
Functional languages are based on the notion of application and functional abstraction. That is
programs are “applied,” like functions, to data and, given the formal, algebraic definition of a
function, it may be turned into an applicative program by “functional completeness” or “lambda
abstraction.” Observe that the expressive power is mostly based on recursive definitions, even though
a different approach is suggested by the higher order calculi discussed in chapter 11.
The aim of this chapter is to clarify the categorical significance of the quoted expressions in the
previous paragraph, e.g., “applied”, “functional completeness”, “lambda abstraction”, “uniform”,
“recursive definition”, in the context of a “type-free” programming style. In the previous chapter we
dealt with the typed λ-calculus, and we discussed typed functional “application” and “abstraction”
which have an immediate interpretation in CCC's. As already mentioned, it is easy to conceive a
variant of the previous calculus by just erasing all type restrictions in the term formation rules. This
defines the (type-free or un(i)typed) λλλλ-calculus, where there is no distinction between functions
and data. (In remark 9.5.12 we will suggest some good reasons by which one may better like to
consider the type-free λ-calculus as a typed calculus with just one type: a unityped calculus). The set
Λ  of terms of the λ-calculus is thus defined by means of the following rules, starting by a given set
of (type-free) variables  V:
Variables
if  x∈V,  then  x∈Λ;
Application
if  M∈Λ,  and  N∈Λ  then   MN∈Λ;
Abstraction
if  M∈Λ,  then  λx.M∈Λ.
Free and bound occurences of a variable in a term, and the substitution  [N/x]M  of a term  N  for a
variable  x  in  M,  are defined as for the typed calculus. As usual, we identify terms that differ from
each other only for the names of bound variables (α-conversion).
The λλλλ-theory deals with the convertibility  M = N  of two terms  M  and  N.  It is axiomatized
by the rules
β.   (λx.M)N = [N/x]M  ,  for  x  free for  N  in  M
η.   λy.My = M  ,  for  y  not free in  M  (write  y∈FV(M) )

9. Reflexive Objects and the Type-Free Lambda Calculus
205
toghether with the axioms and rules needed for turning  “=”  into a congruence relation.
The λ-calculus is the prototype of every untyped functional programming language. Many
functional languages were directly derived from the λ-calculus, from Landin's ISWIM (a notational
variant of λ-calculus with an explicit recursive operator) to Edinburgh ML. Even McCarthy’s
language LISP, the first running functional programming language, and still one of the most used in
several applications of computer science, is greatly endebted to the λ-calculus. Besides the λ-
notation, LISP inherits from λ-calculus both the formal elegance and the concise syntax, essentially
adding only a few primitives for list manipulation.  The main difference is in the binding strategy for
variables, which is static for λ-calculus and dynamic for LISP. For example, without taking into
account the inessential syntactic differences between the two formalisms, let us see how the following
expression is evaluated in the two languages:
(λz. (λy. (λz.yM)N ) (λx.xz) )P
In  λ-calculus, we have the following reduction sequence of reductions:
(λz. (λy. (λz.yM)N ) (λx.xz) )P → λy. (λz.yM)N ) (λx.xP)
→ λz. (λx.xP)M)N
→ (λx.xP)M
→ MP
In contrast to this, LISP will first bind  z  to  P,  then bind  y  to  λx.xz; next  z  will be rebound to
N,  and finally  yM  will be evaluated.  This means that  x  will be bound to  M,  and then  Mz is
evaluated. Since LISP uses dynamic binding, the latest active bindings of the variable  z  is used,
i.e., the evaluation of  (λz. (λy. (λz.yM)N ) (λx.xz) )P  is reduced to the evaluation of  MN.
This has been often considered as an anomaly of LISP: in many LISP dialects, there are syntactic
constructs for defining functions that guarantee a static binding for their formal parameters and,
moreover, some recent LISP-like languages have completely converted to static binding (e.g.,
Scheme). A first consequence of dynamic binding is that the rule of α-conversion does not hold any
more: in the example above, if we replace  z  with another variable in  λz.yM, we obtain a different
behavior. LISP violates referential transparency, while λ-calculus does satisfy it. This is not only a
merely theoretical property: in programming terms, referential transparency means that, in order to
understand a structured program, we need only to understand the denotation of the subprograms, and
not their connotations (for example, we do not need to be concerned with the naming of variables
used within the programs). These ideas are expressed in the philosophy of modular programming,
that is of the programming style that requires the construction of program segments as self-contained
boxes, or modules, with well-defined interfaces. We shall discuss in the last chapters of this book
how this philosophy applies so well to strongly typed polymorphic languages.
The current treatment of both programming concepts of referential transparency and modularity
provides a relevant example of an area that is greatly indebted to twenty-odd years work of in
denotational semantics.  We present in this chapter the categorical understanding of the semantics of

9. Reflexive Objects and the Type-Free Lambda Calculus
206
type-free Combinatory Logic and λ-calculus, whose challenging mathematical meaning actually
started that work. In section 9.4, we hint at how the categorical approach suggested a new set of
combinators and a simple abstract machine for implementig head reduction (CAM).
9.1 Combinatory Logic
Combinatory Logic (CL) is based on an even simpler language than λ-calculus: it just contains
variables and two constant symbols  K  and  S.  Their operational behaviour is axiomatized by the
rules for equality and
k.   Kxy = x
s.    Sxyz = xz(yz)
where, as for the λ-calculus,  M1M2...Mn   stands for  (...(M1M2)...Mn).
The expressive power of λ-calculus and CL is due to their combinatorial completeness. That is,
for any variable  x  and term  M  in their languages, there exists  <x>M  such that
abs.   (<x>M)N = [N/x]M , and  x∉FV(<x>M).
For the λ-calculus, this comes with the definition: just set  <x>M = λx.M. As for CL, define
inductively
<x>x = Ι ≡ SKK;
<x>M = KM,  if  M  does not contain x;
<x>MN = S(<x>M)(<x>N).
(In general, for  x  = x1, ...,xn,  set  <x>M = <x1>...(<xn>M)  ).
As a matter of fact, CL is the simplest type-free language which is functionally complete;
moreover, and surprisingly enough, in 1936 Kleene proved that CL is powerful enough to compute
all partial recursive functions.
Note that in type-free universes, there is no distinction between data and functions. In set-
theoretic terms, this means that it is possible to apply one to the other in an undistinguished
applicative structure (X,.), i.e., a set X with a binary operation . .
9.1.1 Definition  A model  (X,., K, S)  of CL, called Combinatory Algebra, is an applicative
structure (X,.) with two distinguished elements  K, S∈X  such that
∀x,y 
(K.x).y = x
∀x,y,z ((S.x).y).z = (x.z).(y.z) .
As usual, we suppose that the operation . of the applicative structure associate to the left; moreover
we shall usually omit it when writing terms. For instance,  (K.x).y  will be simply written as  Kxy.

9. Reflexive Objects and the Type-Free Lambda Calculus
207
9.1.2 Definition Given an environment ξ , that is a map from the set of variables of CL to X, the
interpretation [M]ξ of a combinatory term M in ξ, is inductively defined as follows:
[K]ξ = K
[S]ξ = S
[x]ξ = ξ(x)
[MN]ξ = [M]ξ[N]ξ .
An interesting semantic consequence of (abs) is the following lemma which will be used later on.
9.1.3 Lemma  Let  ( X,., K, S)  be a Combinatory Algebra. For any combinatory term  M,  any
environment  ξ  and any  a∈X,
[<x>M]ξ .a  =  [M]ξ(x=a)
where  ξ(x=a)  is the environment defined by :  ξ(x=a)(z) = if  x=z  then  a  else  ξ(z) .
Proof    [<x>M]ξ . a =  [<x>M]ξ .[x]ξ(x=a)
=  [<x>M]ξ(x=a) .[x]ξ(x=a)
since x do not occur in <x>M
=  [(<x>M)x]ξ(x=a)
=  [M]ξ(x=a)
by (abs). ♦
Clearly, the λ-calculus is at least as expressive as CL, since  Kλ ≡ λxy.x  and  Sλ ≡ λxyz.xz(yz)
represent  K  and  S  in λ-calculus (and do the same job). By this definition of  K  and  S  we obtain a
sound translation form CL to λ-calculus, i.e., a translation which preserves term equalities. In the
other direction, the abstraction mechanism  <x>M  described above naturally suggests the following
translation.
9.1.4 Definition  Given a λ-term M, the associated term MCL in Combinatory Logic is
inductively defined by
xCL = x
(MN)CL = MCLNCL
(λx.M)CL = <x>MCL.
Unfortunately, this translation is not sound, that is, not all the equations provable in the λ-theory still
hold after the translation. Consider for example the two equal terms  M ≡ λy.x  and  N ≡ λy.(λz.z)x.
Their translation by means of combinators is, respectively:
               MCL = (λy.x)CL
= <y>xCL
= <y>x
= Kx

9. Reflexive Objects and the Type-Free Lambda Calculus
208
               NCL = (λy.(λz.z)x)CL
= <y>((λz.z)x)CL
= <y>((λz.z)CLxCL)
= <y>((SKK)x)
= S((<y>(SKK)) <y>x )
= S((Κ(SKK))Kx)
and  Kx ≠ S((Κ(SKK))Kx).
The problem derives from the fact that in Combinatory Logic  M = N  does not imply  <x>M =
<x>N.  This fact is independent from the particular abstraction mechanism adopted and it is actually
related to the absence of a “canonical” choice for  <x>M  (see references).
From the point of view of computer science, the interest in Combinatory Logic derives more from
implementation then from semantics. Indeed, β-conversion, as it is formulated in the λ-calculus, give
rise to the well-known, conceptually simple, but syntactically fastidious problem of name clashes.
For instance,  M ≡ (λxy.x)y  does not reduce to  λy.y,  but to  λz.y.  This kind of problems does not
sussist in Cominatory Logic, which thus provides a convenient intermediate code where the λ-
calculus can be compiled before execution. For example, the previous term  M  is compiled as:
            MCL = ((λxy.x)y)CL
= (λxy.x)CL (y)CL
= (<x>Kx)y
= S(KK)(SKK)y
and its reduction, using, say, an innermost-leftmost strategy, yields:
                      S(KK)(SKK)y =  (KKy)(SKKy)
=  K(SKKy)
=  K((Ky(Ky))
=  Ky  .
9.2 From Categories to Functionally Complete Applicative Structures
In this section, we suggest how to understand, in categorical terms, the difference between
“functional completeness” and “lambda abstraction” and, later, characterize both notions, in absence
of type constraints.  As mentioned in the introduction, CL is the simplest type-free language that is
functionally complete, since, for every term  M, there exists  <x>M  that satisfies (abs). In case the
choice of  <x>M  is “uniform in M”, one has lambda abstraction and λ-calculus: i.e., <x>M  is
canonically given by  λx.M.
In order to give categorical meaning to this complex situation, we proceed as follows: we start
with recovering applicative structures, in particular functionally complete ones, in Cartesian

9. Reflexive Objects and the Type-Free Lambda Calculus
209
categories (see 9.2.1-9.2.5); then we shift to the realm of Cartesian closed categories, where the
existence of function spaces (exponents) allows a better understanding of the notion of functional
completeness (9.2.6-9.2.7) and lambda-abstraction (9.2.8-9.2.12). In section 5, we will give a fully
categorical characterization of models of these type-free calculi.
9.2.1 Definition  Let  C  be a Cartesian category,  T  its terminal object, and  U  an object in  C,
with  T < U  and  u∈C[U×U,U].  The applicative structure associated to  u,  A(u),  is given
by  A(u) = (C[T,U],.),  where  a.b = u° <a,b>.
In a category with a terminal object  T,  T < U  simply generalizes the set-theoretic notion that  U  is
“not empty”. Clearly,  A(u)  is nontrivial  (i.e., it contains at least two elements)  iff  T < U  is strict,
i.e., is not an isomorphism.
9.2.2 Definition  Let C be a cartesian category.  Then  u∈C[X×Y,Z]  is Kleene-universal  (K-
universal) if  ∀f∈C[X×Y,Z]  ∃s∈C[X,X]   f = u° (s×id) , i.e.,
Kleene-universality is a weak (co)universality property, since no unicity of  s  is required. It has an
obvious recursion-theoretic meaning: indeed K-universality generalizes the s-m-n  (iteration) theorem,
with  X = Y = Z = ω  and  with  f  a (total) recursive function, i.e., a morphism from  (ω,id)×(ω,id)
to  (ω,id),  in the category EN of numbered sets.
9.2.3 Definition  Let C be Cartesian and  u∈C[X×X,X]. Then  u(n)∈C[X×Xn,X]  is inductively
defined by  u(0) = id,  u(n+1) = u(n)° (u×idn),  that is,
u×idn
u(n)
u(n+1): X×X×Xn _______> X×Xn ______> X ,   where Xn+1 = X×Xn.
It is easy to observe that  u(n)  corresponds exactly to the application of  n+1  arguments, from left to
right, e.g.  u(2)°<a,b,c> = u°(u×id)°<a,b,c,> = u°<u°<a.b>,c>.  We write  a.b.c  for  (a.b).c .
9.2.4 Lemma  Let C be Cartesian. Assume that, for some  U  in C,  U×U < U  and there is a K-
universal  u∈C[U×U,U].  Then  ∀n  u(n)∈C[U×Un,U]  is K-universal.

9. Reflexive Objects and the Type-Free Lambda Calculus
210
Proof  By assumption, this is true for n = 1.  Let  U×U < U  via  (i,j)  and   f∈C[U×Un+1,U].
Then, by the inductive hypotesis, for some  s(n)∈C[U,U]  the following diagram commutes:
By assumption, for some  s∈C[U,U]  one also has
Then compute      f =  f ° (j × idn ) ° (i × idn )
=  u(n) ° (s(n) × idn) ° (i × idn)
by (1)
=  u(n) ° (u × idn) ° (s × idn+1)
by (2)
=  u(n+1) ° (s × idn+1). ♦
9.2.5 Theorem  Let C be a Cartesian category.  Assume that, for some object U,  one has  T < U,
U×U < U  and there exists a K-universal  u∈C[U×U,U].  Then  A(u)  is a combinatory algebra.
Proof  Let  T < U  via  (iT,jT).  Then, by lemma 9.2.4, ∀n, ∀f∈C[Un,U] ∃s∈C[U,U] such that
the following diagram commutes, with  [f] = s ° iT  (we write  i  and  j  for  iT  and  jT):
Thus, u(n)°[f]×dn = idT×f = f. Since  u(n) is the application, from left to right, of its n+1 arguments,
[f]  “represents”  f,  with respect to application. By 9.2.1, we only need to define  f∈C[U2,U]  and
g∈C[U3,U]  such that  [f]  and  [g]  represent  K  and  S,  respectively. For this purpose, take  f =
pr21∈C[U2,U]  and  g = u°<u°<pr31,pr33>,u°<pr32,pr33>>∈C[U3,U]. ♦
Theorem 9.2.5  provides sufficient conditions in order to construct “functionally complete” objects.
Theorem 9.5.6 will show that these conditions are also necessary.

9. Reflexive Objects and the Type-Free Lambda Calculus
211
A further insight, though, into functional completeness may be given in CCC's. The advantage of
dealing with CCC's is that for any object  X  one may consider its “function space” or exponent  XX,
as an object. As a matter of fact, functional completeness, in its various forms of increasing strength
(combinatory algebras, λ-algebras, λ-models (see below)), expresses some sort of privileged relation
between an object in a category and its “function space”: its representability, say, in the sense
expressed in the proof of theorem 9.2.5. In CCC's K-universal morphisms and principal morphisms
are related as follows:
9.2.6 Proposition  Let C be a CCC and  Λ  be the isomorphism  C[X×Y,Z] ≅ C[X,ZY]. Then
u∈C[X×Y,Z]  is K-universal  iff   Λ(u)∈C[X,ZY]  is principal.
Proof  The isomorphism  Λ  implies, by definition, the equivalence of the following diagrams:
and we are done. ♦
The connection between K-universal and principal morphisms should remind the reader that the latter
correspond to (acceptable) Gödel numberings from  ω  to  PR,  the partial recursive functions, when
these are viewed as objects in the category EN of numbered sets (see section 2.2). Note though that
Kleene’s  (ω, .)  is a partial combinatory algebra and does not yield a model of Combinatory Logic.
Total combinatory algebras turn out to be nontrivial constructions and may be obtained, for instance,
in higher types, as it will be shown later. The categorical description, in terms of K-universal maps or
principal morphisms, sheds some light on the connections between Gödel numberings and
combinatory completeness. As a matter of fact, by proposition 9.2.6 one may then restate theorem
9.2.5 in terms of CCC's and principal morphisms.
9.2.7 Proposition  Let C be a  CCC. Assume that, for some  U  in C,  T < U, U×U < U  and
there exists a principal  p∈C[U,UU]. Then  A(Λ-1(p))  is a combinatory algebra.
The previous proposition suggests more explicitly the connection between the definition of
application and the morphism  eval  in CCC's. Just observe that, by definition of “.”, one has in a
CCC
a.b = Λ-1(p)°<a,b> = eval°(p×id)°<a,b> = eval°((p°a)×b).

9. Reflexive Objects and the Type-Free Lambda Calculus
212
Informally, the equation above means “transform  a  into a morphism, by  p,  then apply it to  b.”
This process generalizes the way Gödel numberings associate functions to numbers. Similarly as
for the partial recursive functions, there is in general no “canonical” way to go backwards, that is to
choose uniformely and effectively a representative for each representable function. That is, this
representative does not need to be unique and it is not possible to choose a representative for each
representable function in a “uniform”  way, i.e., by a morphism in the category. This is, though,
possible in λ-models. We define them here in a first order manner, as particular combinatory
algebras, with a suitable “choice” operator.
9.2.8 Definition  Let  A = (X, .)  be an applicative structure. Then
i.  A  is a λλλλ-model if for some  k,s,ε∈X  one has:
k.
∀x,y
kxy = x ;
s.
∀x,y,z sxyz = xz(yz) ;
ε1.
∀x,y
εxy = xy ;
ε2.
∀x,y
(∀z xz = yz)  ⇒  εx = εy ;
ε3.
εε = ε .
ii.  A  is an extensional λ-model if one also has  ∀x  εx = x .
ε  has to be understood as a choice operator that picks up a canonical representative for each
representable function.  ε  coincides with the canonical representative of the function it represents, by
axiom  (ε3).  In extensional λ-models, there is just one representative and (ε1), (ε3) are derived.
Note that   A = (X, .)  is an extensional λ-model iff  A  is a combinatory algebra and ∀x,y  (∀z xz =
yz)   ⇒  x = y .
There exists an obvious formal system of combinators  K, S, ε  associated to the previous notion
of λ-model, which we shall call CLεεεε (we gave priority to the notion of model because we mainly
focus here on semantical aspects). The interpretation of CLε in λ-models is straighforward.  Note
also that CLε may be easily and soundly translated into λ-calculus, by taking  ε  to  λxy.xy.
Conversely, the combinator ε can be used to “clean” the translation of a lambda term by means of
combinators described in definition 9.1.4 :
9.2.9 Definition  Given a λ-term  M, the associated term MCLεεεε  in CLε is inductively defined by
xCLε = x
(MN)CLε = MCLεNCLε
(λx.M)CLε = ε .<x>MCLε.
This “refinement” is completely worthless from an implementative point of view, since the reduction
process is essentially unaffected by the combinator ε, as it is stated by equation (ε1). On the contrary,

9. Reflexive Objects and the Type-Free Lambda Calculus
213
it is relevant in semantics, since it allows a simple definition of a sound interpretation of λ−terms in
λ-models, as follows:
9.2.10 Definition  Let  A = (X, .,k,s,ε)  be a λ-model.  The interpretation  [M]ξ  of a λ-term  M
in  A  with respect to an environment  ξ  is the semantics of the associated combinatorial term  MCLε,
i.e.,
[M]ξ = [MCLε ]ξ.
We omit the soundness proof, which is technically straightforward and almoust evident from the
previous discussions.
In the next two results we show how to derive λ-models from reflexive objects in categories with
enough points.
9.2.11 Theorem  Let  C  be a  CCC  with enough points. Assume that, for some  U  in  C,  one
has  UU < U  via  (ψ, φ).  Then, for  ε = ψ°Λ(ψ°φ°snd) ,  Α = (Α(Λ-1(φ)),ε)  is a λ-model.
Proof  φ∈C[U,UU]  is principal; moreover by 2.3.6,  T < U  and  U×U < U.  Thus, for  a.b =
eval°<(φ°a),b> = eval°(φ×id)°<a,b>)  and some suitable  K  and  S,  (Α(Λ-1(φ)),.,K,S)  is a
combinatory algebra, i.e. (k)  and (s) in 9.2.8 hold.  Define now  ε = ψ°Λ(ψ°φ°snd) : Τ→U  (that is,
informally,  ε = ψ(ψ°φ)  ).  Note first that, for any  a,
(†) 
ε . a =  ψ ° φ ° a
indeed:
                  ε.a =  (ψ°Λ(ψ°φ°snd)).a
by def. of  ε
=  eval°<(φ°ψ°Λ(ψ°φ°snd)),a> 
by def. of  “.”
=  eval°<(Λ(ψ°φ°snd)),a> 
since   φ°ψ = id
=  eval°(Λ(ψ°φ°snd)×id)°<id×a>
=  ψ°φ°snd°<id×a>
=  ψ°φ°a
Then one has:
ε1.                ε.a.b = (ψ°φ°a).b
by (†)
= eval°<(φ°ψ°φ°a),b>
by def. of  “.”
= eval°<(φ°a),b>
since  φ°ψ = id
= a.b
by def. of  “.”
ε2. Suppose that  ∀z  az = bz.  Then, since
a.z = eval°<(φ°a),z> = eval°((φ°a)×id)°<id,z>,
b.z = eval°<(φ°b),z> = eval°((φ°b)×id)°<id,z>,
and since C has enough points, we have  eval°((φ°a)×id) = eval°((φ°b)×id), and thus  φ°a = φ°b.
Then ε.a =  ψ°φ°a = ψ°φ°b = ε.b.

9. Reflexive Objects and the Type-Free Lambda Calculus
214
ε3.
ε.ε =  ψ°φ°ψ°Λ(ψ°φ°snd) =ψ°Λ(ψ°φ°snd) = ε. ♦
The definition of  ε  should be clear. Just note that  ψ°φ : U→UU→U, i.e., φ  gives a morphism for
each point  a  in  U  and  ψ  chooses a “canonical” one, representing φ(a), as  φ°ψ = id. Then  ε =
ψ°Λ(ψ°φ°snd): Τ→U ,  internalizes  ψ°φ  as a point in  U.
9.2.12 Corollary  Let C be a CCC with enough points.
i. If, for some  U  in  C,  UU < U  via  (i,j)  and there exists  u∈C[U×U,U]  K-universal, then also
A(u)  can be turned into a λ-model.
ii. If  UU ≅ U  via  (ψ,φ), then  A(u)  is an extensional λ-model.
Proof
i.   By theorems 9.2.6 and 9.2.11 and the definiton of principal morphism.
ii.  ε.a =ψ°φ°a = a. ♦
9.3 Categorical Semantics of the λλλλ-Calculus
In theorem 9.2.11 we proved that if C is a CCC with enough points, and  U∈ObC  is a reflexive
object  (i.e., UU<U  via  (ψ, φ) )  then, for  ε=ψ°Λ(ψ°φ°snd) : Τ→U,  (Α(Λ-1(φ)),ε)  is a λ-model.
We can thus give an interpretation of the lambda calculus as in definition 9.2.10.
In this section we define a more direct interpretation of the lambda calculus over such an object
U,  and relate the two interpretations.
9.3.1 Definition  Let C be a CCC with terminal object  T.  Let  U∈ObC  be a reflexive object via
the retraction pair  (ψ: UU→U, φ: U→UU) . Let  M  be a λ-term with  FV(M) ⊆ ∆ = {x1,…,xn}.
Define then  [M]∆∈C[Un,U],  where  Un = (...(T×U)×...)×U  with  n  copies of  U,  as follows
(we use the two projections  fst  and  snd  in a polymorphic fashion, and we omit the indexes):
[xi]∆ = snd ° fstn-i = prni
[MN]∆ = eval ° < φ ° [M]∆, [N]∆>
[λx.M]∆ =  ψ ° Λ([M]∆∪{x} ).
We do not prove the soundness of the interpretation; the reader interested in this result may consult
the references.
Examples
1.  Let  M = λx.xx.
          [λx.xx] = ψ ° Λ([xx]{x})

9. Reflexive Objects and the Type-Free Lambda Calculus
215
= ψ ° Λ( eval ° < φ ° [x]{x}, [x]{x}> )
= ψ ° Λ( eval ° < φ ° snd, snd > ) : T→U .
2. Consider the term   Y = λx.(λy.x(yy)(λy.x(yy)). This is a fixpoint operator, since for every M,
                       YM = (λx.(λy.x(yy)(λy.x(yy)))M
= (λy.M(yy)(λy.M(yy))
= M( (λy.M(yy))(λy.M(yy)) )
= M(YM)
Let us interpret  Y.  We proceed by stages
   [ λy.x(yy) ]{x} =  ψ ° Λ([x(yy)]{x,y} )
=  ψ ° Λ( eval ° < φ ° [x]{x,y}, [yy]{x,y}>  )
=  ψ ° Λ( eval ° < φ ° snd ° fst, eval ° < φ ° [y]{x,y}, [y]{x,y} > >
=  ψ ° Λ( eval ° < φ ° snd ° fst, eval ° < φ ° snd, snd > >
Let  P =  ψ ° Λ( eval ° < φ ° snd ° fst, eval ° < φ ° snd, snd > >  .
Then we have
                 [Y] = [ λx.(λy.x(yy)(λy.x(yy)) ]
= ψ ° Λ( [(λy.x(yy)(λy.x(yy)) )]{x})
= ψ ° Λ( eval ° < φ ° P ° snd, P ° snd > ): T→U
It is not difficult to prove that   Λ -1(φ ° [Y] ) °  <!UU, ψ>  = eval ° < φ ° P ° ψ, P ° ψ > : UU→U  is
a categorical fixpoint operator (see definition 8.8.2).
We now relate the two notions of categorical semantics given in 9.2.10 and 9.3.1. As a matter of fact
they are essentially equivalent, the only difference being that the one in definition 9.3.1 does not need
the concept of environment.
9.3.2 Definition  Let  ξ: Var→ Α(Λ-1(φ))  be an environment .  Let  ∆ = {x1,…,xn}  be a finite
set of variables. Then
ξ'∆  = <...<idT, ξ(x1)>… ,ξ(xn)> : T → T×U...×U
We shall usually omit the subscript  ∆  in  ξ'∆  when it will be clear from the context.
9.3.3 Theorem  Let C be a CCC with enough points, UU < U  via  (ψ, φ) ), and  A  be the
associated λ-model as in proposition 9.2.11. Let  [ ]  and  [ ]  be the interpretations respectively
defined in 9.2.10 and 9.3.1. Then, for any term  M  with free variables in  ∆ = {x1,…,xn}  and any
environment  ξ: Var→ Α(Λ-1(φ)) ,  one has
[M]∆ °  ξ'∆  =  [M]ξ.
Proof  The proof is by induction on the structure of  M.
- case  M = x.  Suppose  ξ(x) = a : T→U.  Then   ξ'∆ = < idT, a >.  We have:
                   [x]{x} ° ξ'∆=  snd ° < idT, a >

9. Reflexive Objects and the Type-Free Lambda Calculus
216
=  a
=  ξ(x)
=  [x]ξ
- case  M = PQ
                         [PQ]∆ ° ξ'∆=  eval ° < φ ° [P]∆, [Q]∆> °  ξ'∆
=  eval ° < φ ° [P]∆ ° ξ'∆, [Q]∆ ° ξ'∆>
=  eval ° < φ °  [P]ξ, [Q]ξ > by induction hypothesis
=  [P]ξ [Q]ξ
by def. of application
=  [PQ]ξ
- case M = λxn+1.Ν
Note first that, for any  a : T→U,
      (*)         [<xn+1>NCLε]ξ . a =  [N]∆∪{xn+1}° < ξ'∆, a >.
Indeed:
                    [<xn+1>NCLε]ξ . a =  [NCLε]ξ(xn+1=a) 
by lemma 14.1.3
=  [N]ξ(xn+1=a) 
by definition of [ ]
=  [N]∆∪{xn+1}° < ξ'∆, a > by induction hypothesis.
Note now that:
                    [<xn+1>NCLε]ξ . a =  eval ° < φ ° [<xn+1>NCLε]ξ, a >
=  eval ° ( (φ ° [<xn+1>NCLε]ξ)×id) ° < idT, a >,
and
      [N]∆∪{xn+1}° < ξ'∆, a > =  [N]∆∪{xn+1}°  ξ'∆×id ° < idT, a >.
Since C has enough points, and all the points in T×U are of the kind  < idT, a >, from (*) we have:
        [N]∆∪{xn+1}° ξ'∆×id =  eval ° ( (φ ° [<xn+1>NCLε]ξ)×id).
Applyng Λ to both the members, and composing with  ψ, we get:
   ψ ° Λ([N]∆∪{xn+1}° ξ'∆=  ψ ° φ ° [<xn+1>NCLε]ξ.
By definition, ψ ° Λ([N]∆∪{xn+1}° ξ'∆ = [λx.N]∆° ξ'∆
Moreover,
      [λx.N]ξ =  [(λxn+1.N)CLε]ξ
=  [ε . <xn+1>NCLε]ξ
=  ε . [<xn+1>NCLε]ξ
=  ψ ° φ ° [<xn+1>NCLε]ξ.
This conludes the proof. ♦

9. Reflexive Objects and the Type-Free Lambda Calculus
217
9.4 The Categorical Abstract Machine
The categorical interpretation in definition 9.3.1 suggests a very simple and nevertheless efficient
implementation of the lambda calculus. The implementation is based on a call-by-value, leftmost
strategy of evaluation, and it is performed by an abstract environment machine called CAM (see
refernces). The first step toward the implementation is the compilation of lambda calculus in a
language of categorical combinators.
Note that  [MN]∆ = eval ° < φ ° [M]∆, [N]∆> = Λ−1(φ) ° < [M]∆, [N]∆>. Λ−1(φ): U×U→U  is
just the application  u  of the underlyng combinatory algebra. We shall write  app  instead  Λ−1(φ).
Moreover, let  cur(f) = ψ ° Λ(f),  and write  f ; g  instead of  g ° f. Then the equations which define
the semantic interpretation of the lambda calculus are rewritten as follows:
[xi]∆ = fst; . . . ; fst; snd      where fst  appears  n-i  times
[MN]∆ = < [M]∆, [N]∆> ; app
[λx.M]∆ =  cur([M]∆∪{x} ).
This provides a “compilation” of the λ−calculus in a language where all the variables have been
replaced with “access paths” to the information they refer to (note the use of the “dummy” enviroment
∆  during the compilation).
One of the main characteristic of the categorical semantical approach is that we can essentially use
the same language for representing both the code and the environment. An evaluation of the code  C
in an environment  ξ  is then the process of reduction of the term  ξ ; C. The reduction is defined by a
set of rewriting rules. The general idea is that the environment should correspond to a categorical term
in some normal form (typically, a weak head normal form). The reductions preserve this property of
the environment, executing one instruction (i.e. one categorical combinator) of the code, and updating
at the same time the program pointer to the following instruction.
For  fst  and  snd  we have the following rules, whose meaning is clear:
<α,β> ; (fst ; C1)  ⇒  α ; C1
<α,β> ; (snd ; C1)  ⇒  β ; C1
In the left hand side of the previous rules, <α,β> is the environment and the rest is the code. We
shall use parenthesis in such a way that the main semicolon in the expression will distinguish between
the environment at its left, and the code at its right.
For  cur(C1)  we use the associative law of composition and delay the evaluation to another time:
ξ ; (cur(C1); C2)  ⇒  (ξ ; cur(C1) ) ; C2
The structure  (ξ ; cur(C1) )  corresponds to what is usually called a closure.
The right time for evaluating a term of the kind  cur(C)  is when it is applied to an actual parameter α.
We then have:
<(ξ ; cur(C1)), α > ; (app; C2)  ⇒  <ξ, α> ; (C1; C2)
The previous rule is just a rewriting of the equation
Λ−1(φ) ° <ψ ° Λ(C1) ° ξ, α > = eval ° <Λ(C1) ° ξ, α > = C1 ° <ξ, α>

9. Reflexive Objects and the Type-Free Lambda Calculus
218
that proves the semantical soundness of the previous rule.
Finally, we must consider the evaluation of a term of the kind  <C1,C2>; C3. We have the formal
equation:
ξ ; (<C1,C2>; C3) = < ξ ; C1, ξ ; C2> ; C3
but we cannot simply use it for defining a reduction, since we want also to reduce   ξ ; C1  and  ξ ;
C2.  We must first carry out independently the reductions of  ξ ; C1  and  ξ ; C2 , and then put them
together again building the new environment.
A simple solution on a sequential machine may be given by using a stack and working as follows:
first save the actual environment  ξ  by a push operation, then evaluate  ξ ; C1  (that yields a new
environment  ξ1);  next swap the environment  ξ1 with the head of the stack (i.e. with  ξ);  now we
can evaluate  ξ ; C2  obtaining  ξ2;  finally build a pair  <ξ1,ξ2>  with the head of the stack  ξ1  and
the actual environment  ξ2  (that is a cons  operation).  An interesting and elegant property is that, if
we just write at compile time  <C1,C2>  as  “push; C1; swap; C2; cons”, then the above behaviour is
obtained by a sequential execution of this code.
9.4.1 Definition The compilation by means of categorical combinators of a λ-term M in a
“dummy” environment ∆ = (...(nil, x1),…), xn )   is inductively defined as follows:
[x](∆,x) = snd
[y](∆,x) = fst; [y]∆
[MN]∆ = push; [M]∆; swap; [N]∆; cons; app
[λx.M]∆ =  cur([M](∆,x)) .
Examples
1. The closed term  M = λx.xx  has the following compilation:
       [λx.xx]nil = cur([xx](nil,x) )
= cur(push; [x](nil,x); swap; [x](nil,x); cons; app)
= cur(push; snd; swap; snd; cons; app).
2. The term  (λx.x)(λx.x) is so compiled:
  [(λx.x)(λx.x)]nil = push; [λx.x]nil; swap; [λx.x]nil; cons; app
= push; cur([x](nil,x) ); swap; cur([x](nil,x) ); cons; app
= push; cur(snd); swap; cur(snd); cons; app.
9.4.2 Definition  The reduction of the compiled code is  summarized by the following table:

9. Reflexive Objects and the Type-Free Lambda Calculus
219
BEFORE
AFTER
Environment 
Code
Stack
Environment
Code
Stack
<α,β>
fst; C
S
α
C
S
<α,β>
snd; C
S
β
C
S
ξ
cur(C1); C2
S
ξ; cur(C1) 
C2
S
<ξ;cur(C1),α> app; C2
S
<ξ,α>
C1;C2
S
ξ
push; C
S
ξ
C
ξ.S
ξ1
swap; C
ξ2.S
ξ2
C
ξ1.S
ξ1
cons; C
ξ2.S
<ξ2, ξ1>
C
S.
Example The code “push; cur(snd); swap; cur(snd); cons; app” corresponding to the λ-term
(λx.x)(λx.x)  gives rise to the following computation:
ENV. 
= nil
CODE 
= push; cur(snd); swap; cur(snd); cons; app
STACK = nil
ENV. 
= nil
CODE 
= cur(snd); swap; cur(snd); cons; app
STACK = nil . nil
ENV. 
= nil; cur(snd)
CODE 
= swap; cur(snd); cons; app
STACK = nil . nil
ENV. 
= nil
CODE 
= cur(snd); cons; app
STACK = nil; cur(snd) . nil
ENV. 
= nil; cur(snd)
CODE 
= cons; app
STACK = nil; cur(snd) . nil
ENV. 
= <nil; cur(snd), nil; cur(snd) >
CODE 
= app
STACK = nil

9. Reflexive Objects and the Type-Free Lambda Calculus
220
ENV. 
= <nil, nil; cur(snd) >
CODE 
= snd
STACK = nil
ENV. 
= nil; cur(snd)
CODE 
=
STACK = nil
Note that  “cur(snd)”  is the compilation of  λx.x.
9.5 From Applicative Structures to Categories
We want now to “go backwards”, with respect to section 9.2, where we described how to find
models of a type-free language within type structures, i.e., within CCC. Namely, we will see how to
construct typed models, in particular a CCC, out of type-free structures. This has an important
motivation from Programming Language Theory, since it is the semantic counterpart of the following
relevant methodology in functional languages.
We already mentioned, as an example, that one of the main features of Edinburgh ML is its
automatic treatment of type assignment. That is, the programmer may write programs without taking
care of the tedious details of assigning types. The type checker decides whether the given program is
typable and, if so, assigns a type to it (actually, the “most general type”).
This effective interactive feature of ML provides a partial check for correctness, as one may
automatically control whether type errors occur. This is similar to what physicists call “dimensional
analysis” for equations when they verify, say, whether a force faces a force, etc. Of course, a lot
must be settled. For example, the actual decidability of the type assignment and the existence of “type
schemes” such that all types of a given program are instances of these. The identity function, for
example, has type  A → A  for all instances of  A.
As for the semantics, one must first be able to interpret the type-free language, as handled by the
programmer, and then interpret types as objects of suitable CCC constructed over the type-free
model.  In other words, one must be able to obtain an interpretation of types out of a model for the
type-free calculus. “Soundness” then means that a program, once it is assigned a type, is actually
interpreted as an “element” of the interpretation of its type. Decidability and soundness have been
positively clarified by a mathematical investigation of computability and programming, which goes
beyond the scope of this book (see references).

9. Reflexive Objects and the Type-Free Lambda Calculus
221
Our present purpose is to survey the main “type structures” (categories) one may construct out of
type-free models and to complete, in this way, the categorical understanding of typed versus type-free
calculi, as required for the semantics of the type assignment process. Most of the work may be done
over an arbitrary combinatory algebra  (X, . ), i.e., over an arbitrary model of Combinatory Logic.
Indeed, it is even not required that  "." ,  the application in  X,  is a total operation. As already
mentioned, if  “.”  is not always defined,  (X, .)  is no longer a model of CL. However, the
categories constructed below still have the same properties (products, exponents, whenever
possible...), which the reader should check as an exercise.
9.5.1 Definition  Let  Α = (X,.)  be an applicative structure.
i.  The set of monomials over  A  is inductively defined by
x,y....x1,x2...(variables)...are monomials
a,b....a1,a2....(constants from  X )... are monomials
MN  is a monomial if  M  and  N  are monomials.
Substitution of constants for variables, i.e. M[a/x],  in monomials is defined by induction in the usual
way.   M1M2...Mn   stands for  (...(M1M2)...Mn) .
ii.  f: Xn→X  is algebraic  if  f(a) = M[a/x]  for some monomial  M  and any   a = (a1,... ,an)∈Xn
and  x  of length  n. (That is, the set  Pn(A) = P[Xn,X]  of algebraic functions of n-arguments is
defined by the monomials over  X,  with at most  n  variables, modulo extensional equality.)
iii.  Given  (X,.),  call  f : Xn→ X  representable if  ∃a∈X ∀b∈Xn  f(b)= a.b1.....bn.
By using algebraic functions, one may define a simple category over an arbitrary applicative
structure.
9.5.2 Definition  Let  A = (X, .)  be an applicative structure. The category  PA  of polynomials
over  A,  has as
objects:          Xn∈PA,  for all  n ∈ ω;
morphisms:   f∈PA[Xn,Xm]  iff  f: Xn→Xm  and  ∀i<m  prmi°f∈Pn, with  prmi  i-th  projection.
(If there is no ambiguity  write  P[Xn,Xm]  for  PA[Xn,Xm]).
For example,  f(x,y) = (xb(xax),yxa)  for  a,b∈X,  is in  P[X2,X2].  By substitution, one may easily
show that morphisms are closed under composition; moreover,  prni∈P[Xn,X] = Pn  and, thus,  PA
is a category.
Exercise (Curry-Shoenfinkel)  Prove that exactly in combinatory algebras every algebraic function
is representable (hint:  use the argument which translates a λ-term  λx.M  into an S-K-term  <x>M  in
the introduction).

9. Reflexive Objects and the Type-Free Lambda Calculus
222
If  Α  is a combinatory algebra, then, by the exercise, PA may be considered the category of
representable morphisms.
9.5.3 Lemma Let  A = (X,.)  be an applicative structure. Then PA is a cartesian category with
enough points.  Moreover, if C is a CC with enough points and C,  U  and  A(u)  are as in definition
9.2.1, then  PA(u)  is a full sub-cartesian category of  C.
Proof.  Set   Xn×Xm = Xn+m  and  T = X0 (= a singleton set) for the terminal object. The
projections  pri 's  are given above. Clearly, PA  has enough points. The rest easily follows from
definition 9.2.1 and the assumption that  C  has enough points. The reader may complete the proof as
an exercise. ♦
Given a category C,  U  and  A(u)  as in lemma 9.5.3, we say that  g∈C[Un,U]  induces  f :
A(u)→A(u)  if  f(h) = g°h  for all h∈C[T,U]. It is straightforward to prove that all algebraic
functions defined by a monomial in  n  variables over  A(u), and no constants, are induced by
morphisms in  C[Un,U]. One only has to interpret variables as projections (see section 9.3) and
argue by induction on the structure of the “algebraic term” defining the function. For example, for
f(x1,x2,x3) = (x3.x1).x2  write
u°<pr3,pr1> :  U3 → U×U → U  , which is  x3.x1 , and then
u°<u°<pr3, pr1>,pr2> :  U3 → UxU → U,  which induces  f.
Next, we generalize a definition of category given over a specific applicative structure in example
3.4.1. The definition is slightly different (besides being more general). Since it is an important
construction, it is worth seeing it again, under a different and more general viewpoint.
9.5.4  Definition  Let  A = (X,.)  be an applicative structure. Define then:
1. The category  PERA of partial equivalence relations given by:
objects:
R∈PERA  iff  R  is an equivalence relation on a subset  XR  of  X,  i.e., XR = dom R
= range R.
morphisms: for  R∈PERA  let  πR(n) = {m | nRm }; then  f∈PER[R,S]  iff  ∃f'∈P[X,X]  f ° πR
= πS ° f'  on  XR,  i.e., the following diagram commutes:
(we then say that  f'  computes  f ).

9. Reflexive Objects and the Type-Free Lambda Calculus
223
2.  The category  ERA  of (total)  equivalence relations is given as above by using equivalence
relations on  X  (i.e., XR = X  in 1.).
PERA and ERA are clearly categories. Similarly as for PA we write (P)ER[R,S] for (P)ERA[R,S]
when unambiguous.
Exercise  Let  A  be an applicative structure. Give a terminal object for PERA and ERA, and prove
that they have enough points. (Hint: recall that the constant functions are algebraic).
9.5.5 Proposition  Let  A = (X,.)  be an applicative structure. Then, if  X×X < X  in PA, ERA
and PERA are CCs (with enough points). Moreover, PA and ERA are full sub-CC's of PERA.
Proof  Let  X×X < X  via  ([-,-],<p1,p2>).  Then  R×S  may be defined componentwise, by
a(R×S)b   iff   (p1(a))R(p1(b))  and  (p2(a))S(p2(b)).
This turns ERA and PERA into  CC's.
Observe now that  ∀n  Xn < X  via  ([-,...,-],<p1,...,pn>)  in PA, by iterating  X×X < X. Thus
PA may be faithfully embedded in PERA by taking, for each  Xn,  the identity relation restricted to
the image of  Xn  in  X  via  [-,...,-].  Call this restricted identity  idn.  Moreover,  PA  is full in
PERA,  since  P[Xn,Xm] ≅ PER[idn, idm],  as sets, by the following isomorphism   G  (take  m =
1,  for the sake of simplicity).  Let  g∈P[Xn,X],  then, for  x = [x1,...,xn], define  G(g)∈PER[idn,
id]  by  G(g)(x) = g(p1(x),...,pn(x)) = g(x1,...,xn).  G(g)  is computed, in the sense of  9.5.4, by
g°<p1,... ,pn> : X → Xn → X.
G  is an isomorphism, whose reverse map is given as follows:  if  h∈PER[idn, id]  is computed
by  h'∈P[X,X],  then  G-1(h) = h'°[-,... ,-] : Xn → X → X.  By definition, ERA is a full sub-CC
of PERA, and both categories have enough points, by the exercise. ♦
The next theorem proves the converse of theorem 9.2.5 and, moreover, it shows that, by applying
the construction in definition 9.2.1 and theorem 9.2.5 to a combinatory algebra, one gets back to the
given combinatory algebra.
9.5.6 Theorem  Let  A = (X,.)  be a combinatory algebra and PA be the category of polynomials
over A. Then  T < X, XxX < X  in PA and, for  u(x,y) = x.y, u∈P[X2,X] is K-universal in the
category PA. Moreover, A(u) = A.
Proof  T < X  trivially holds, for  X≠∅.  Clearly,  XxX  exists in PA, by lemma 9.5.3. Let then
c,c1,c2∈X  represent  λxyz.zxy, λxy.x, λxy.y, respectively, in the sense of definition 9.5.1(iii).  c
is the element that codes pairs (they are commonly coded in this way in λ-calculus), while  c1, c2
will be used to define projections. Thus, for  [x,y] = cxy  and  pi(x) = xci, one has  [-,-] ∈P[X2,X],
pi∈P[X,X]  and  X×X < X  via  ([-,-],<p1,p2>). Finally, assume that  f∈P[X2,X]  and that  a∈X

9. Reflexive Objects and the Type-Free Lambda Calculus
224
represents  f.  Then  f = u°((λx.ax)×id)  and, hence,  u  is K-universal. It is easy to check from the
definition that  A(u) = A. ♦
9.5.7 Corollary  Let  A = (X,.)  be an applicative structure.  Then  A  is a combinatory algebra iff,
in  PA,  one has  T < X, X×X < X  and, for  u(x,y) = x.y,  u  is K-universal.
Proof (⇒)  by theorem 9.5.6;  (⇐) by theorem 9.2.6. ♦
As already pointed out, one needs CCC's in order to take care of λ−models. However, also
combinatory algebras are tidely characterized within CCC's. The following immediate consequence
of theorem 9.5.6 and proposition 9.2.6, plus proposition 9.2.7, fully characterizes the least
requirement for functional completeness in CCC's.
9.5.8 Corollary  Let  A = (X,.)  be a combinatory algebra.  Then PERA is a  CCC, where  T < X,
X×X <  X  and, for  u(x,y) = x.y,  Λ(u)∈PER[X,XX]  is principal.  Moreover  A(u) = A.
Proof.  In view of theorem 9.5.6 and proposition 9.5.5, we only need to define the object  SR  in
PERA,  which represents  PER[R,S]. Set then
aSRb   iff   ∀x,y∈X (xRy ⇒ (ax)S(by)).
Recall now that, by assumption, each function in  P[X,X]  is representable. The rest of the proof that
PERA is a CCC is an obvious generalization of example 3.4.1. ♦
9.5.9 Remark  While completing the proof that PERA is a CCC, in corollary 9.5.8, one may
notice that it is only required, for all  R, S  and all  f∈PER[R,S],  that  f  has a representative in  X.
This is the point which allows the generalization to the partial case (see section 9.6, besides PERω in
example 3.4.1).
The next result proves the converse of corollary 9.1.12 and completes our categorical understanding
of λ-models.
9.5.10 Theorem Let  A = (X, ., ε)  be a  λ-model. Then, in the  CCC  PERA,  there exist
ψ∈PER[XX,X]  and  φ∈PER[X, XX]  such that   XX < X  via  (ψ, φ).  Moreover,  (X,.) ≅ Α(Λ-
1(φ)),  and  ε = ψ(ψ°φ).  If  A  is extensional, then   XX ≅ X  .
Proof  Let   f∈PER[X,X]  and  a∈X  be a representative for  f.  Define then  ψ(f) = εa.  By  (ε2), ψ
is well defined.  Recall also that  XX  is the exponent representing PER[X,X]  in PERA, hence
ψ∈PER[XX,X].
As for  φ,  define  φ(a) = λx.ax  for any  a∈X.  Clearly   φ∈PER[X,XX].  Compute then
            φ(ψ(f)) = λx.εax
if  a  represents  f
= f
by  (ε1).

9. Reflexive Objects and the Type-Free Lambda Calculus
225
Thus  XX < X,  via  (ψ, φ).
Finally,  (X,.) ≅ A(Λ-1(φ)),  since  φ(a)(b) = ab.  Moreover  ψ(φ(a)) = εa  and, hence,  ε
represents  ψ°φ.  Thus
       ψ(ψ°φ) 
= εε   
by definition of  ψ
= ε     
by  (ε3).
Finally, if  a = εa = ψ(φ(a))   for all  a , then  ψ°φ = id  and, hence,  XX ≅ X. ♦
We conclude this part by summarizing the connections between type-free λ-calculus and categories
with enough points obtained so far. This provides a unified framework for the topic.
9.5.11 Theorem Let C be a CCC and  A  an object of C. Then
1.  AA ≅ A   ⇒   Α  is an extensional  λ-model;
2.  AA < A   ⇒   A  is a λ-model;
3.  ∃p∈C[A, A A] principal, T < A  and  A×A < A   ⇒   Α is a combinatory algebra.
  Conversely,
1.  Α  is an extensional λ-model   ⇒   AA ≅ A  in  PERA;
2.  A  is a λ-model   ⇒   AA < Α  in  PERA;
3.  Α  is a combinatory algebra   ⇒   ∃p∈PERA[A,A A]  principal, T < A  and  A×A < A  in PERA.
9.5.12 Remark  In the categorical semantics of lambda calculus, we have to deal with Cartesian
(closed) categories, and thus with products and projections. Without much increasing the complexity
of the semantics, it is thus possible to consider also a type-free λ-calculus with explicit pairing,
λβηπ, in analogy to the typed case, see section 8.2. We leave to the reader the task of defining, as an
exercise, this calculus and giving its semantics on a reflexive object  U  in a CCC C. As a matter of
fact, one only needs to add  A×A ≅ A  to (1) and (2) in theorem 9.5.11 in order to obtain
characterizations of the models of λβ(η)π.
In conclusion, the diligent reader will notice that the models of λβηπ are exactly the CCC with
e.p. and with a unique object nonisomorphic to the terminal one. It may be fair, then, to call λβηπ
the “unityped” λ-calculus.
9.6 Typed and Applicative Structures: Applications and Examples
In the first part of this section, we sketch a recent application of the typed and type-free λ−calculus to
category theory.  In a sense, this application goes in the other direction with respect to our prevailing
perspective, as, so far, we mostly applied categorical tools to the understanding of deductive systems
and their calculus of proofs (λ−calculus).

9. Reflexive Objects and the Type-Free Lambda Calculus
226
The question we answer here may be simply stated, in categorical terms:
  (1)  which isomorphisms hold in all CCC's ?
The motivation is clear, as a simple and decidable equational theory of types will allow us to detect
provably isomorphic types or, equivalently, valid isomorphisms in all models. In functional
programming, for example, when retrieving programs from a library where they are collected
according to their types, the search should be done “up to provable isomorphisms”, as the same
program may have been coded under isomorphic types; for example, a search program for lists of a
given length, may be typed by  INT×LISTS → LISTS  or, equivalently, by  LISTS→ (INT →
LISTS)  (see references).  The result turns out to be an application of λ−calculus to categories, as we
look at the problem from a proof-theoretic view point and, by the work done in chapter 8, we actually
answer to the following equivalent question.
Consider the intuitionistic calculus of sequents, in section 8.3, and suppose that proofs of  A
B  and of  A B  are given.  Then one may ask
  (2)  in which cases the composition of  A B  and  B A  (and of  B A  and  A B)
reduce, by cut-elimination, to the axiom  A A  (and  B B,  respectively) ?
Clearly, (2) corresponds to (1) when types are understood as objects.  The point is that the
deductions in (2) are coded by λ-terms,  M  and  N,  say, as described in section 8.3.  By this, and
by a lot of (hinted) hacking on λ-terms, we will characterize valid isomorphisms by looking at the
structure of  M  and  N  such that  M°N = IA  and  N°M = IB,  by β−conversion.
The second part develops little general Category Theory since it essentially gives more examples of
CCC's and of λ−models.  The structures presented will be combinatory algebras and models of type-
free λβ, since models of  λβη  may be derived from the general results in chapter 10.  In particular,
we introduce a few relevant categories of complete partial orders as well as their “effective” versions
and hint how they relate to the various categories of quotients or PER's that we largely used in the
previous sections.
Part 1: Provable isomorphisms of types
Consider the following equational theory of types.  It is given by axiom schemata plus the obvious
inference rules that turn  “=”  into a congruence relation.
9.6.1 Definition  Th  is axiomatized as follows, where  T  is a constant symbol:
1.
A × T = A
2.
A × B = B × A
3.
A × (B × C) = (A × B) × C
4.
(A × B)→ C = A → (B → C)

9. Reflexive Objects and the Type-Free Lambda Calculus
227
5.
A→ (B × C) = (A → B) × (A → C)
6.
A→T = T
7.
T→A = A.
In remark 3.3.3, we already asked the reader to prove that, when  →  and  ×  are interpreted as
cartesian product and exponent, the provable equations of Th hold as isomorphisms in any CCC.
Note, though, that there are categorical models which realize Th, but are not CCC's.  Take, say, a
cartesian category and a bifunctor  “→”  that is constant in the second argument.
We next hint how to prove the non trivial fact that Th characterizes exactly the valid
isomorphisms in all CCC's, by using λ-calculus.
As pointed out in section 8, the typed λ-calculus is, at the same time:
a - the “theory” of CCC's;
b - the calculus of proofs of the intuitionistic calculus of sequents.
Thus the theorem is shown by observing that the isomorphic types in the (closed) term model of
typed λ-calculus are provably equal in  Th .  This answers to (2) in the introduction above and, thus,
to (1).
A term model is closed, when terms in it contain no free variables.
9.6.2 Definition  Given (an extension of) the typed λ-calculus, λλλλ, the (closed) term model is the
type structure
|λλλλ| = {| M: A|  /  M  is a (closed) term of type  A}
where  |M: A| = { N /  λλλλ M = N }.
Clearly, the type structure is non trivial, if a collection of ground or atomic types is given.  The (pure)
λ-calculus may be extended by adding fresh types and constants as well as consistent sets of
equations.  Consider now the extension of λβηπt  in section 8.3 by adding:
1 - a special atomic type  T  (the terminal object);
2 - an axiom schema
*A: A → T
which gives a constant of that type;
3 - a rule
M: A → T
_______
  M = *A
that gives the unicity of  *A.

9. Reflexive Objects and the Type-Free Lambda Calculus
228
Call  λλλλββββηηηηππππ*t  this extended calculus and  Tp*  its collection of types.  The point is that the closed
term model of  λβηπ*t  (and its extensions) forms a CCC, as the reader may check as an exercise.
Then the provable equations of Th  are realized in  |λβηπ*t|,  as isomorphisms.  We give an explicit
name to these isomorphisms, as λ-terms provide the basic working tools.
9.6.3 Definition  Let  A,B∈Tp*.  Then  A  and  B  are provably isomorphic  (A ≅p B)  iff
there exist closed λ-terms  M : A → B  and  N : B → A  such that  λβηπ*t |– M ˚ N = IB  and
λβηπ*t |– N ˚ M =  IA, where   IA  and   IB  are the identities of type  A  and  B.  We then say that
M  and  N  are invertible terms in  λβηπ*t .
9.6.4 Remark  By general categorical facts, we then have the easy implication of the equivalence
we want to show; namely,   Th  |− A = Β   ⇒   A ≅p B.  It may be worth for the reader to work out
the details and construct the λ-terms which actually give the isomorphisms.  Indeed, they include the
“abstract” verification of cartesian closure; for example, “currying” is realized by  λz.λx.λy.z<x,y>
with inverse  λz.λx.z(p1 x)(p2 x),  that prove  (A × B)→ C ≅p A → (B → C);  the term  λz.<λx.(p1
(zx)),λx.(p2 (zx))>  with inverse  λz.λx.<(p1 z)x,(p2 z) x>  prove  A→ (B × C) ≅p (A → B) × (A
→ C).  The others are easily derived.
The proof of the other implication, i.e.,  A ≅p B   ⇒   Th  |− A = Β,  roughly goes as follows.  As a
first step, types are reduced to “type normal forms”, in a “type rewrite” system.  This will eliminate
terminal types and bring products at the outermost level.  Then one needs to show that isomorphisms
between type normal forms yield componentwise isomorphisms.  This takes us to the pure typed λ-
calculus (i.e., no products nor  T's).  Then a characterization of the invertible terms of the pure type-
free calculus is easily applied in the typed case, as the invertible type-free terms happen to be typable.
The syntactique structure of the invertible terms gives the result.
The axioms of Th suggest the following rewrite system R for types (essentially Th “from left to
right ”, with no commutativity):
9.6.5 Definition (Type rewriting R )   Let  ">"  be the transitive and substitutive type-reduction
relation given by:
1.
A × T > A
1'. T × A > A
3.
A × (B × C) > (A × B) × C
4.
(A × B)→ C > A → (B → C)
5.
A→ (B × C) > (A → B) × (A → C)
6.
A→T > T
7.
T→A > A .

9. Reflexive Objects and the Type-Free Lambda Calculus
229
The system  R  yields an obvious notion of normal form for types (type normal form), i.e.,
when no type reduction can be applied.  Note that 1, 1', 6 and 7 “eliminate the  T's”, while 4 and 5
“bring outside  ×”.  It is then easy to observe that each type normal form is identical to  T  or has the
structure  S1× ... ×Sn  where each  Si  does not contain  T  nor  "×".   We write  nf(S)  for the
normal form of S  (there is exactly one, see 1.6) and say that a normal form is non trivial if it is not
T.
9.6.6 Proposition R is Church-Rosser and each type has a unique type normal form in R .
Proof  Easy exercise.  ♦
By the implication discussed in remark 9.6.4, since  R |− S > R  implies  Th  |− S = R , it is clear that
any reduction  R |− S > R  is wittnessed by an invertible term of type  S→R.
9.6.7 Corollary  Given types  S  and  R,  one has:
1 -  Th  |− S = nf(S)  and, thus,
2 -  Th  |− S = R  ⇔   Th  |− nf(S) = nf(R).
In conclusion, when  Th  |− S = R,  either we have  nf(S) ≡ T ≡ nf(R),  or  Th  |− nf(S) ≡ (S1× ...
×Sn) = (R1× ... ×Rm) ≡ nf(R).  A crucial lemma below shows that, in this case, one also has  n =
m.
The assertion in the corollary can be reformulated for invertible terms in a very convenient way:
9.6.8 Proposition (commuting diagram)  Given types  A  and  B, assume that  F: A→nf(A)  and
G: Β→nf(Β)  prove the reductions to type n.f..  Then a term  M: A→Β  is invertible iff there exist an
invertible term  M': nf(A)→nf(Β),   such that  M = G-1°M'°F.
Proof.  ⇐)  Set   M-1 ≡ (G-1°M'°F)-1 ≡ F-1°M'-1°G,  then  M  is invertible.
⇒) Just set  M' = G°M°F-1.  Then  M'-1 ≡ F°M-1°G-1  and  M'  is invertible.  ♦
A diagram easily represents the situation in the proposition:

9. Reflexive Objects and the Type-Free Lambda Calculus
230
A
B
A1
n
A
×
×
:
B1
m
B
×
×
:
M
M'
F
G
We now state a few lemmas that should guide the reader through the basic ideas of this application of
λ-calculus to category theory.  Most technical proofs, indeed λ-calculus proofs, are omitted (and the
reader should consult the references).
Recall first that, when  Th  |− S = R,  one has
nf(S) ≡ T ≡ nf(R),  or  Th  |− nf(S) ≡ (S1× ... ×Sn) = (R1× ... ×Rm) ≡ nf(R).
Notice that, in the latter case, there cannot be any occurrence of  T  in either type.  Indeed, a non
trivial type normal form cannot be provably equated to  T,  as it can be easily pointed out by taking a
non trivial model. Thus it may suffice to look at equations such as  (S1× ... ×Sn) = (R1× ... ×Rm)
with no occurrences of  T  and, hence, to invertible terms with no occurrences of the type constant  T
in their types. We can show that these terms do not contain any occurrence of  *Α  either, for no type
Α,  via the following lemma.
9.6.9 Lemma  Let  M  be a term of λβηπ*t  in n.f..
1 -  (Terms of a product type) If  M: A×B,  then either  M ≡ <M1, M2>,  or there is  x:C  such that
x∈FV(M)  and  A×B is a type subexpression of  C.
2 - (Every term, whose type contains no  T,  has no occurrence of *Α constants)  Assume that in  M
there is an occurrence of  *Α,  for some type  Α.  Then there is some occurrence of the type constant
T  in the type of  M  or in the type of some free variable of  M.
Proof.  By induction on the structure of  M.  ♦
Note now that (the equational theory of)  λβηπ*t  is a conservative extension of (the equational
theory of)  λβηπt.  Similarly for  λβηπt  w.r.t.  λβηt.  Thus, invertibility in the extended theory,
given by terms of a purer one, holds in the latter.
9.6.10 Proposition (Isomorphisms between type normal forms are given by terms in λβηπt)
Assume that   S  and  R  are non trivial type normal forms.  If the closed terms  M  and  N  prove  S
≅p R  in λβηπ*t, then their normal forms contain no occurrences of the constants  *Α.  (Thus,  M
and  N  are actually in λβηπt).

9. Reflexive Objects and the Type-Free Lambda Calculus
231
Proof  By the previous lemma, as the terms are closed and no  T  occurs in their type.  ♦
So we have factored out the class of constants  *Α,  and we restricted the attention to λβηπt.  By the
next step, we reduce the problem to the pure calculus, i.e., we eliminate pairing as well, in a sense.
9.6.11 Proposition  (Isomorphic type normal forms have equal lenght ) Let  S ≡ S1× ... ×Sm
and  R ≡ R1× ... ×Rn  be type normal forms.  Then  S ≅p R   iff
n = m  and there exist  M1,...,Mn ; N1,...,Nn  such that
x1: S1, ..xn: Sn  |- <M1,...,Mn>: (R1× ... ×Rn)
y1: R1, ..yn  : Rn  |- <N1,...,Nn>: (S1× ... ×Sn)
with 
Mi[ x := N] =βη yi ,  for  1 ≤ i ≤ n
Nj[ y := M] =βη xj ,  for  1 ≤ j ≤ n
and there exist permutations  σ, π  over  n  such that
Mi = λui.xσi Pi  and  Nj = λvj.yπj Qj
( M  is a vector of terms; substitution of vectors of equal lenght is meant componentwise).
Proof (Not obvious, see references).  ♦
By induction, one may easily observe that terms of λβηπt whose type is arrow-only belong to λβηt.
Thus, one may look componentwise at terms that prove an isomorphism.  The next point is to show
that each component, indeed a term of  λβηt, yields an isomorphism.  This will be done by using a
characterization of invertible terms in the pure calculus.  The same result will be applied once more in
order to obtain the result we aim at.
The characterization below has been given in the type-free calculus, as an answer to an old
question of Church on the group of type-free terms.  We follow the type-free notation, also for
notational convenience.
9.6.12 Definition  Let  M  be a type-free term. Then  M  is a finite hereditary permutation
(f.h.p.) iff either
(i)  λβη |–u M = λx.x , or
(ii)  λβη |–u M = λz. λx.zNσ , where if  |x| = n  then  σ  is a permutation over  n  and  zNσ =
zNσ1Nσ2… Nσn ,  such that, for  1 ≤ i ≤ n,  λxi.Ni   is a finite hereditary permutation.
For example,  λz.λx1.λx2.zx2x1  and  λz.λx1.λx2.zx2(λx3.λx4.x1x4x3)  are f.h.p.'s.  The
structure of f.h.p.'s is tidily desplayed by Böhm-trees.  The Böhm-tree of a term  M  is
(informally) given by:
   BT(M) = Ω    if  M  has no head normal form
   BT(M) = λx1 ... xn. y                    if  M =β λx1...xn. y M1 ... Mp

9. Reflexive Objects and the Type-Free Lambda Calculus
232
                                      /  ... \
                           BT(M1)      BT(Mp)
(see references).
It is easy to observe that a  BT(M)  is finite and Ω-free iff  M  has a normal form.  Then one may
look at f.h.p.'s as Böhm-trees, as follows:
    λz x. z
λy1. xσ1    . . . 
λyn. xσn
:                      
:
and so on, up to a finite depth (note that  yi  may be an empty string of variables).  Clearly, the
f.h.p.'s are closed terms and possess a normal form.  In particular, exactly the abstracted variables at
level  n+1  appear at level  n+2,  modulo some permutation of the order (note the special case of  z  at
level  0).  The importance of f.h.p.'s arises from the following classic theorem of λ-calculus.
(Clearly, the notion of invertible term given in 9.6.3 easily translates to type-free λ-calculi).
9.6.13 Theorem  Let  M  be an untyped term possessing normal form. Then  M  is λβη-invertible
iff  M  is a  f.h.p..
Recall now that all typed terms possess a (unique) normal form (see references).  Let then  M  be a
typed λ-term and write  e(M)  for the erasure of  M,  i.e. for  M  with all type labels erased.
Remark  Observe that the erasures of all axioms and rules of the typed lambda calculus are
themselves axioms and rules of the type-free lambda calculus.  Then, if   M  and  N  are terms of
λβηt  and  λβηt |– M = N,  one has λβη |– e(M) = e(N).  Thus, in particular, if  M : σ → τ  and  N :
τ → σ  are invertible terms in  λβηt,  e(M)  and  e(N)  are f.h.p.'s.
Exercise  Show that the f.h.p.'s are typable terms (Hint: Just follow the inductive definition and
give  z,  for instance, type  A1 → (A2..... → B),  where the  Ai's  are the types of the  Nσi.)  Then,
by the a small abuse of language, we may talk also of typed f.h.p.'s.  Observe that these are exactly
the typed invertible terms in definition 9.6.3.
The first application of 9.6.13 we need is the following.

9. Reflexive Objects and the Type-Free Lambda Calculus
233
9.6.14 Proposition  Let  M1, ... Mn , N1, ... ,Nn  and permutation  σ  be as in lemma 9.6.11.
Then, for all  i,  λxσi.Mi : Sσi→Ri  and  λyi.Nσi : Ri→Sσi  are invertible terms.
Proof.  For a suitable typing of the variables it is possible to build the following terms of λβηt (we
erase types for convenience):
M = λzx1...xn.zM1 ... Mn
N = λzy1...yn.z N1 ... Nn  .
It is an easy computation to check, by the definition of the  Mi's  and of the Ni's, that  M  and  N  are
invertible.  Moreover, they are (by construction) in normal form, thus, by theorem 9.6.13,  M and N
are f.h.p.'s. This is enough to show that every  Mi  has only one occurrence of the  xi's  (namely
xσi);  similarly for the  Ni's.
Thus we obtain
Mi[x := N] ≡ Mi[ xσ(i) := Nσ(i)] =βη yi,  for  1 ≤ i ≤ n
Ni[y := M] ≡ Ni[ yπ(i) := Mπ(i)] =βη xi,  for  1 ≤ i ≤ n
and, hence, for each  i,  λxσ(i).Mi : Sσ(i)→Ri  and  λyi.Nσ(i) : Ri→Sσ(i)  are invertible. ♦
As a result of the work done so far, we can then focus on invertible terms whose types contain only
“→” i.e., investigate componentwise the isomorphisms of type normal forms.  Of course, these
isomorphisms will be given just by a fragment of theory Th.
Call S the subtheory of Th given by just one proper axiom (plus the usual axioms and rules for
“=”),  namely
(swap)      A→(B→C) = (B→(A→C)) .
S  is a subtheory of Th by axioms 2 and 4 of Th.
9.6.15 Proposition  Let  Α, Β  be type expressions with no occurences of  T  nor  ×.  Then
Α ≅p Β   ⇒   S |–Α = Β.
Proof  Suppose  Α ≅p Β  via  M  and  N.  As usual, we may assume without loss of generality that
M  and  N  are in normal form.  By lemma 9.6.9 and the remark after 9.6.11,  M  and  N  actually
live in  λβηt  and, by theorem 9.6.13, they are f.h.p.'s.  We prove   S |– Α = Β  by induction on the
depth of the Böhm-tree of  M.
Depth 1:  M ≡ λz : C. z.  Thus  M : C →  C, and    S |– C = C  by reflexivity.
Depth n+1:  M ≡ λz : E. λx : D. zNσ.  Recall  zNσ = zNσ1 ... Nσn  where if the ith abstraction in
λx : D  is  λxi : Di  then the erasure of  λxi : Di.Nσi  is a f.h.p.. Thus  λxi : Di.Nσi  gives (half of) a
provable isomorphism from  Di  to some  Fi.  Hence the type of  Nσi  is  Fi.  In order to type check,
we must have  E = (Fσ1 → ... →  Fσn → Β)  for some  Β.  Thus the type of  M  is  ( Fσ1 → ... →
Fσn → Β) → (D1 → ... → Dn → Β).  By induction, since the height of the Böhm tree of (the
erasure of) each  λxi : Di. Nσi  is less than the height of the Böhm tree of  M,  ona has   S |–  Di =
Fi  for  1 ≤ i ≤ n.  By a repeated use of the rules for "=", we get

9. Reflexive Objects and the Type-Free Lambda Calculus
234
 S |– ( Fσ1 → ... →  Fσn → Β) = ( Dσ1 → ... →  Dσn → Β).
Hence it suffices to show
 S |– ( Dσ1 → ... →  Dσn → Β) = ( D1 → ... →  Dn → Β).
This is quite simple to show by a repeated use of axiom (swap) above in conjunction with the rules.
♦
Clearly, also the converse of proposition 9.6.15 holds, since the  "⇐"  part in 9.6.15 is provable by
a fragment of the proof hinted in 9.6.4.  Thus one has:
S |– Α = Β   ⇔   Α ≅p Β   by terms in  λβηt.
The result we aim at, is just the extension of this fact to  Th  and  λβηπ∗t.
9.6.16 Main Theorem  S ≅p R  ⇔  Th|- S = R
Proof.  In view of 9.6.4, we only need to prove   S ≅p R  ⇒  Th |- S = R.  As we know, this is
equivalent to proving   nf(S) ≅ nf(R)  ⇒   Th |- nf(S) = nf(R).
Now, by proposition 9.6.11, for  nf(S) ≡ (S1× ... ×Sn)  and  (R1× ... ×Rm) ≡ nf(R), we have
  
nf(S) ≅ nf(R)   ⇒   n = m  and there exist  M1, ..., Mn , N1, ..., Nn
and a permutation  σ  such that  λxσi.Mi : Sσi→Ri  and  λyi.Nσi : Ri→Sσi .
By 9.6.14, these terms are invertible, for each  i.  Thus, by 9.6.15,  S |- Ri = Sσi  and, hence, by
the rules,  Th |- S = R.   ♦
This concludes the proof of the main theorem of this part.
9.6.17 Corollary  Given types  A  and  B,  it is decidable whether they are (their interpretation
yields) isomorphic (objects) in all CCC's.
Proof (Hint) Reduce  A  and  B  to type normal form.  Check that these have an equal number of
factors.  If so, observe that theory S does not change the lenght of types and perfom the required
swaps to check the equality, in that theory, of each component.  ♦
Exercise  Check the complexity of the theory of provable isomorphisms.
Part 2: Higher type objects as models of the type-free    λλλλ-calculus
We give here some examples of categories and objects with the properties mentioned in the previous
sections and discuss connections to Higher Type Recursion Theory, a highly developed topic to
which denotational semantics of programming languages is greatly indebted. This theory suggested
the early structures for a “generalized theory of computation,” stressed the role of CCC's and, jointly

9. Reflexive Objects and the Type-Free Lambda Calculus
235
with category theory, set the basis for the construction of the early models of (type-free) λ-calculus
and, thus, of functional programming languages.
We first mention a simple way to obtain lots of type-free models in CCC's with reflexive objects.
Then we apply this construction to the main type structures for higher type recursion: the partial
continuous and computable functionals in all finite higher types. Well-established results allow to
recover from those structures the various hierarchies of total functionals, which actually started the
topic (see references).
In section 2.4 we already gave two examples of reflexive objects in different CCC and, thus, of
λ-models. When presenting the first, Pω, in 2.4.1, we promised to show the reflexivity of another
very familiar Scott domain: the collection  P(R)  of the partial (recursive) functions from  ω  to  ω . Its
reflexivity, see theorem 9.5.2, will be a consequence of a stronger property, with respect to a suitable
category.
Exercise  Let  C be a CCC and  T  be a terminal object. Then  ∀X,Y∈ObC,  if  T < Y,  one has  X
< XY.
(Solution:  The retraction  (i,j)  is given by  i = Λ(pr1)∈C[X,XY]  and  j = eval°(id×t)∈C[XY,X]
for some fixed  t∈C[T, X]. Indeed, j°i = j°(i×dT) = eval°(id×t)°(i×dT) = eval°(i×id)°(id×t) =
eval°(Λ(pr1)×id)°(id×t) = pr1°id×t = id .)
Let the set of type symbols,  Tp,  contain at least the atomic type 1.  Then, for  X  in a CCC C, set
X1 = X,  and, for  A = Xσ  and  B = Xτ,  set  Xσ→τ = BA  and  Xσ×τ = A×B.
9.6.18 Lemma Let  U  be a reflexive object in a CCC C.  Then, for  {Uσ}σ∈Τp  as above
∀σ, τ∈Tp   Uσ < Uτ  in  C
In particular, then,  ∀σ∈Tp  Uσ→σ < Uσ.
Proof  Assume, by induction on the syntactic structure of types, that  U < Uσ  and  U < Uτ.
Clearly,  U×U < Uσ×τ.  It is also easy to check that  UU < Uσ→τ. Similarly, from the inductive
assumptions  Uσ < U  and Uτ < U, one has Uσ→τ < UU < U, as  U  is a reflexive object, and
Uσ×τ < U×U < U,  by proposition 2.3.6.  Finally,  U < U×U  and  U < UU, by  T < U and the
exercise.  Therefore,  ∀σ,τ∈Tp   Uσ < U < Uτ  in C. ♦
As already shown, Scott domains, coherent domains and other categories of continuous functions
have nontrivial reflexive objects. By the lemma, in these categories there are lots of λ−models, one in
each higher type σ,  over the reflexive object.  We consider here yet another simple category with a
reflexive object, namely the category pcD of ω-algebraic pair-consistent c.p.o.’s, and the object  P
of partial functions from integer to integer.

9. Reflexive Objects and the Type-Free Lambda Calculus
236
Call first a subset  D  of a p.o.set  (X,≤)  pairwise consistent if any pair of elements in  D  has
an upper bound in  X  (and write  x⇑y  for  ∃z∈X  x,y ≤ z ) .  (X,≤)  is pair-consistent if any
pairwise consistent subset has a l.u.b. Call pcD the category of ω-algebraic pair-consistent c.p.o.’s
(cf. examples in 2.4.1), with continuous maps as morphisms.
Exercise Prove that pcD is a full subCCC of the category D of Scott domains in 2.4.1.
9.6.19 Theorem Let  P  be the set of the partial number-theoretic functions. Then for any object
X  in pcD,  X < P .  In particular,  P  is reflexive.
Proof. Let  X = (X, X0, < )  be in pcD, and let e: ω→X0  be an enumeration of the compact
elements of  X. Define  ϕ: X→P  by  setting, for all n∈ω,
        ϕ(x)(n) =  if  e(n) ≤ x then  0
else   if   ~(x⇑e(n))  then  1
                                else  ⊥ .
Equivalently,  ϕ(x)∈P  is uniquely determined by the ordered pair in which its domain splits
〈{ n∈ω | ϕ(x)(n) = 0}, {n∈ω |  ϕ(x)(n) = 1} 〉 = 〈{n∈ω |  e(n) ≤ x}, {n∈ω |  ~(x⇑e(n)) }〉.
It is easy to prove that  ϕ  is continuous.
In order to define  ψ: P→X , for any  f∈P, set
Xf = {e(i) |  f(i) = 0  and  ∀j <  i, ~(e(i)⇑e(j)) → f(j) ≠ 0}.
First,  Xf  is pairwise consistent. Let  i, j  be such that  e(i), e(j)∈Xf.  Then  f(i) = f(j) = 0. Suppose
that  ~(e(i)⇑e(j)). Then  i < j    ⇒   f(i) ≠ 0   and   j < i  ⇒  f(j) ≠ 0 , which is impossible. Thus
e(i)⇑e(j),  so Xf   is pairwise-consistent.  By the consistency property of  X , we can define  ψ: P→X
by  ψ(f) = supX(Xf).  It is a simple exercise to prove that  ψ  is continuous and that  ψ°ϕ(x) = x  for
all  x∈X. Therefore  X  is a retract of  P. ♦
It is clear that computability is at hand. As a matter of fact, the categories and results described so far
can be “effectivized,” in analogy to the examples in 2.4.1, e.g., the category ED. Denote by  Xo  the
collection of the compact elements of  (X,≤)  in pcD.
9.6.20 Definition  Let  X = (X,Xo ,eo,≤)  be in pcD and  eo: ω→Xo (bijective).  Then  X  is
effectively given if
1.   eo(n)⇑eo(m)    is a decidable predicate
2.   ∃g∈R ∀n,m ( eo(n)⇑eo(m)  ⇒  eo (g(n,m)) = sup{eo(n), eo(m)} ).
It is easy to show that if  X  and  Y  are effectively given, then also the space of continuous functions
from  X  to  Y  is effectively given.  Indeed, the category of effectively given ω-algebraic pair-
consistent c.p.o.’s and continuous functions is cartesian closed (similarly to ED).

9. Reflexive Objects and the Type-Free Lambda Calculus
237
Recall that ideals are downward closed directed subsets of a poset  (X,≤). As in the definition of
the category CD of constructive domains in 2.4.1, the idea now is to take, within an effectively given
(X,Xo ,eo,≤), only the l.u.b of those ideals of Xo, which are indexed over a recursively enumerable
set. Call computable elements the l.u.b of the r.e. indexed ideals. Clearly, the computable elements
of  P  are exactly the partial recursive functions, PR.
9.6.21 Definition  A sub-p.o.set  Xc  of an effectively given  X = (X,Xo ,eo,≤)  is a
constructive and pair-consistent domain (ccd) if for any ideal  D ⊆ Xo  one has:
D  is principal in  Xc  iff  eo-1(D)  is a recursively enumerable set.
Thus  Xc  contains exactly the computable elements of  X , e.g., Pc = PR.  By the following
exercise, this gives yet another interesting CCC.
Exercises
i.  Let CCD be the category whose objects are ccd's and whose morphisms are the continuous and
computable functions (computable as elements of the function spaces). Prove that CCD is cartesian
closed.
ii.  Prove 9.6.19 above for  PR  instead of  P, i.e., prove that also  PR  is reflexive in CCD.
Consider now the type structure  {PRσ}σ∈Tp  constructed over  PR  in CCD.  These are known as
the (higher type) partial recursive functionals.  By the exercise and lemma 9.6.18, they yield a (type-
free) λ-model in any finite type, as  PRσ→σ < PRσ .
CCD tidily relates to categories defined in the previous section, provided that a minor
generalization is made. So far, we have only been dealing with total applicative structures, i.e.,
where “.” is everywhere defined, as combinatory algebras are total structures. There exist, though,
interesting partial applicative structures: for example, Kleene's K = (ω,.), where  n.m = φn(m)  for
some acceptable Gödel numbering  φ: ω→PR  of the partial recursive functions.
In general, given a partial applicative structure  B = (X,.),  i.e., “.”  may be a partial binary
operation, one can define the categories PB, ERB and PERB as in definitions 9.5.2 and 9.5.4, with
a minor caution. Since we deal here with categories of total morphisms, we consider only total
polynomials in each P[Xn,Xm]; in particular in P[X,X], when defining ER[R,S] in definition 9.5.4.
As for PER[R,S], each f∈PER[R,S] is “computed,” in the sense of 9.5.4, by a (possibly partial)
g∈P[X,X] which must be total on  domR, though. In conclusion, by the exercise before 9.5.3 and
remark 9.5.9, if  X×X < X  in PB, then proposition 9.5.5 applies similarly and PB and ERB are
full sub-CC of the CC PERB. Moreover, if  B  is a partial combinatory algebra, then PERB is a
CCC by corollary 9.5.8 and what follows. The remaining results carry on similarly.

9. Reflexive Objects and the Type-Free Lambda Calculus
238
This remark has already been (implicitly) applied when defining PER over ω. As a matter of fact,
Kleene’s  K = (ω,.)  is a partial combinatory algebra, as it contains (indices for) partial  k  and  s.
Thus, the properties of PER (= PERK and ER = ERK) could be derived also by the work in this
chapter.
Exercise  The reader has already checked that the category EN of numbered sets (see the examples
in section 2.2) is equivalent to ERK. He or she may try to give now an extension of EN which is
cartesian closed and equivalent to PERK.
We already mentioned, in example 2.4.1, an important theorem, the Generalized Myhill-
Shepherdson Theorem, which related constructive domains and EN. In this frame, it may be restated
as “CCD is equivalent, as a category, to a full subCCC of ERK.” Jointly to the exercise, this
provides interesting embeddings, up to equivalence, of CCD into ERK into PERK.
It should be clear why Kleene's  K  is only a partial combinatory algebra and not a total one. If
ωω  represents  PER[ω,ω] = P[ω,ω],  then there is no principal p∈PER[ω,ωω], as there is no
Gödel-numbering or effective enumeration of  P[ω,ω] = R,  the recursive functions.
One may try another way to turn  K  into a combinatory algebra. Consider first the category
CCDp of ccd's and partial morphisms, i.e., partial continuous maps with open domain.  Let  _⊥ =
_°  be the lifting functor defined in example 5.2.4.  CCD[ω⊥,ω⊥], then, coincides with  PR  plus
the everywhere constant function on  ω⊥.  From any acceptable Gödel-numbering of  PR  it is easy to
construct a principal  p'∈CCD[ω⊥,PR];  however,  ω⊥×ω⊥ < ω⊥  in CCD fails, by a simple
continuity argument. Thus also  (ω⊥,.)  does not yield a combinatory algebra. However, by
PRσ→σ < PRσ  in CCD and 9.5.10, λ-models may be found at any finite higher type.
Note that  p'  above or the Gödel-numberings are principal morphisms which cannot be turned
into retractions, by the latter observation or because, given a partial recursive function, there is no
uniform effective choice of one of its indices, by the Rice theorem. More examples could be given by
taking combinatory algebras which cannot be turned into λ-models.  Indeed, a simple example is
given by the term model of Combinatory Logic, i.e., by a “model” constructed by purely syntactic
tools.
Remark (Partial vs. total maps)  The reader may have noticed that there are various notions of
partiality mentioned in these sections. As for the last, it poses no problem: a partial applicative
structure has a (possibly) partial application. One may construct over it, though, categories of total
maps, such as EN, ERK (cf. the definition of morphisms in these categories).
Note now that we called {PRσ}σ∈Tp  the partial continuous and computable functionals, even
though, at any type higher then  1,  these are total, i.e., always defined, continuous (and computable)
maps. Why are they called partial, in the literature?  The intuition should be clear, but the categorical

9. Reflexive Objects and the Type-Free Lambda Calculus
239
notion of complete object (see definition 2.5.6) may provide a better or more rigorous understanding.
As for the intuition, PR contains partial maps, in the ordinary sense, and each of the higher types
contains a least element: the empty set in PR, the constantly empty map in PRPR and so on.
Intuitively, these least elements give the “undefined value” in the intended type. Categorically, this is
understood by observing that, by this, each higher type, except for type 0 ( i.e., ω) is a complete
object in the intended category of partial maps, in the sense of section 2.5. The point is that these
objects, by theorem 2.5.9, are exactly those such that the partial morphisms may be extended, and
indeed viewed, as total ones.
Remark (On total functionals)  Consider now  ω  and the total maps from  ω  to  ω. We hint now at
how to move to higher types and preserve totality of morphisms, in a categorical environment where
it is possible to give a good notion of computability.
In sections 3.4 and 5.3 we presented the CCC (sep-)FIL of (separable) filter spaces and
discussed some of its categorical properties. We also mentioned that this category is essentially
nontopological, as some relevant types are not in the range of the embedding functor  H: Top→FIL,
defined in example 5.3.7. In particular, FIL-ω, the sub-CCC of sep-FIL generated by  ω, endowed
with (the convergence induced by) the discrete topology, contains non topological types. The objects
in FIL-ω are the sets of total continuous functionals.
On separable filter spaces, with an enumeration {Ui}i∈ω of the base, one may consider the
effectively given objects by generalizing the technique for domains in example 2.4.1 and definition
9.6.3.  In short, one has to require that the base is decidable in the sense that
{ i |  Ui = ∅ }  and  { (i1,..., im,k1,...,kn) |  Ui1∩...∩Uim ⊆ Uk1∩...∩Ukn }
are recursive (uniformely in  n  and  m). Then the computable elements are defined as limits of r.e.
indexed filters.  More precisely, let  ↓s  be the notion of convergence over filter spaces given in  (s-
conv.) in 5.3.7.  Then set, for  (X,F)∈sep-FIL with a decidable base,
x∈X  is computable  iff   ∃Φ↓sx   { i |  Ui∈Φ }  is r.e..
In higher types, this defines total computable functionals.
Exercise  Embedd the category ED, as topogical spaces, in 2.4.1 into sep-FIL by the functor H :
Top→FIL  in 5.3.7 and describe how  H  and its left adjoint behave on computable elements. The
computable elements of FIL-ω are the (Kleene-Kreisel) total continuous and computable functionals
(see references).
As a final connection to the other categories of effective maps we used here, we just mention that
a complex quotienting technique, which hereditarily defines total elements as the functions that take
total elements to total elements, allows us to establish adjoint equivalences between  ED-ωωωω⊥, the sub-
CCC generated by  ωωωω⊥ in ED, and PERK-ω, the sub-CCC generated by  (ω,id)  in PERK.

9. Reflexive Objects and the Type-Free Lambda Calculus
240
Similarly, the subCCC PERPω-ω in PERPω, the category of p.e.r.’s over the reflexive object  Pω,
corresponds to FIL-ω. (See references).
References  The original construction in Scott (1972) gives a non trivial isomorphism  AA ≅ A  in
a CCC of lattices. The general notion of categorical model of the type-free calculus λλλλββββηηηη and λλλλββββ are
investigated in Berry (1979), Obtulowicz and Wiweger (1982), Koymans (1982), by using, though,
the category of retractions, which does not need to have e.p., instead of PER (see Barendregt (1984)
for a survey).  By this one may deal with a weaker notion of model, the λ-algebras. λ-algebras,
originally called pseudo-λ-models in Hindley and Longo (1980), are exactly the models of
Combinatory Logic with β-equality (see also Barendregt (1984) or Hindley and Seldin (1986)). They
are characterized as in theorem 9.5.11(2), by dropping the assumption that C has enough points and
they are in between combinatory algebras and λ-models (in Barendregt and Koymans (1980) it is
shown that the term model of CL cannot be turned into a λ-algebra.) However, retractions do not
form a CCC on combinatory algebras and do not help in the categorical understanding of CL Thus we
used PER, as in Longo and Moggi (1990), which we largely followed and where the models of CL
were first characterized.  The use of a choice operator  ε  in order to extend combinatory algebras to
λ-models, which we followed here, is formalized in Meyer (1982).
Cousineau and al. (1985) and Curien (1986) introduce the categorical abstract machine.
The valid isomorphisms in Cartesian Closed categories are characterized in Bruce and DiCosmo
and Longo (1990) (by a different proof, they where also given in Soloviev (1983)).  The invertibility
theorem 9.6.13, for the type-free λ-calculus, is due to Dezani (1976). Rittri (1989) applies
isomorphisms in all CCC's to retrieval methods in libraries of programs.
Finally, pairwise consistent domains and the properties of Tω are investigated in Plotkin (1978).
Filter spaces and related categories are used, for higher type recursion theory, in Hyland (1979).
Ershov (1973-76) and Longo and Moggi (1984-84a) establish the relation between various classes of
total and partial functionals.

10. Recursive Domain Equations
241
Chapter 10
RECURSIVE DOMAIN EQUATIONS
One of the early applications of Category Theory to computer science was the solution of recursive
domain equations. This kind of equation is typical of every language that allows an explicit or implicit
form of self-application of its data types (such as a recursive procedure call, say).
For example, by theorem 9.5.10 we already know that in order to give semantics to the pure λ-
calculus we need a domain isomorphic to its own function space; moreover, if we are interested in
computing over a fixed domain  A  of atoms, we need a solution to the equation
(*)    X ≅ A+(X→X).
In general, recursive specification of domains can be seen as a particular case of recursive
definition of data types that is an even more important topic in computer science. For example every
programmer is used to considering the data type of all the lists of objects of type A as a solution to the
following recursive equation:
A_List = Nil + A×(A_list)
where  Nil  is a one-element data type.
In many respects, the general and unified theory of this kind of equation, mainly developed in the
framework of Category Theory, has provided the base for the elimination, in most modern
languages, of many unreasonable restrictions in the definition of recursive data types that existed in
older languages. Note that these restrictions were not always motivated by implementation problems,
but often by a real misunderstanding of the semantics of recursive definitions.
The first mathematical difficulty in giving a meaning to recursive specifications of data types is
that they do not always have a set-theoretic solution. For example, equation (*) above has no solution
in Set by obvious cardinality reasons: the arrow-domain  A→Β  cannot be interpreted as the
collection of all functions between  A  and  B.  The natural choice is to consider categories other than
Set, with fewer morphisms but sufficiently many as to include all “computable functions” over the
intended data types.  The relevance of morphisms suggests why the categorial framework arises so
naturally in this context.  Note that the intended category C must be still Cartesian closed, in order to
give the correct interpretation to the function space constuction.  Once C is fixed, the idea for solving
recursive domain equations is to use some sort of fixed point technique.  To be more specific, in the
categorical approach, the general form of equations such as  (*)  above, looks like
(**)   X ≅ F(X)
where  X  ranges over the object of a category C and  F: C→C  is a covariant endofunctor of the
category.  If C is ω-cocomplete, C has an initial object, and F is ω-continuous, then theorem 6.5.2

10. Recursive Domain Equations
242
gives a solution to  (**).  The main problem is that an obvious definition does not always exist for
such an  F,  as we are going to show in the next section.
10.1 The Problem of Contravariant Functors
Consider again the equation
(*)    X ≅ A+(X→X)
in the introduction.  In order to apply theorem 6.5.2, we need to work in a ω-cocomplete category C.
Moreover, the category must be Cartesian closed and have coproducts, so that we can give the
expected interpretation to the operators  →  and  +, which appear in (*).
Such a category is not difficult to find: an example is the category  CPOS of c.p.o.’s with a least
(bottom) element and strict (bottom-preserving) continuous functions for morphisms.  The next step
is to define a covariant functor  F: C→C  such that, for any object  X  of C,  F(X) = A+(X→X).
The first idea would be to express  F  as a composition of the functors of  sum  and  exponentiation
associated to the closure properties of C.  For example, if  A+_: C→C  is the functor which takes  B
to  A+B,  and  f  to idA+f,  exp is the exponentiation functor, and  ∆  is the diagonal functor, we
could be tempted to define
F = (A+_) ° exp ° ∆
Unfortunately, this is not possible since  exp  is contravariant in the first component and cannot be
composed with the diagonal function; in other words, since  exp:  Cop××××C→C ,  and  ∆: C→C××××C,
the previous equation is ill typed.
We would like to have a way of transforming every functor  F  in an associated functor  F*  with
the same behavior on objects, but covariant on morphisms, in all its components.
Unfortunately this is not possible in general, but still there is a very simple way, as we will see,
to turn a contravariant endofunctor  F: C→C  into a covariant endofunctor  F*  in an associated
category C*, which has the same objects of C, and such that isomorphisms in C* give isomorphisms
in  C.
Then, if  C* is ω-cocomplete and has a terminal object, and  F* is ω-continuous, we can apply
theorem 6.5.2, find a solution in  C*, and then derive a solution in  C.  Note that the category C*
does not need to be cartesian closed, neither it must be closed under coproducts, since we already
know how to give a meaning to the constuctions of new objects in  C.
We shall define C* as a suitable subcategory of the following category C+-.
10.1.1 Definition  Given a category C, the category C+- has the same object of C and
f ∈C+-[A, B]   iff   f = (f+,f-)  with  f+∈C[A, B]  and  f-∈C[B, A].
Composition is defined by  (f+,f-) ° (g+,g-) = (f+° g+, g-° f-).

10. Recursive Domain Equations
243
An intuitive way to regard the category C+- is the following.  Consider the objects as data types;
there is a morphism from  A  to  B  if and only if a pair of “coercions” is given in order to go from
one to the other.  Note also that two objects are isomorphic in C+- iff they are isomorphic in C.
We next show how to define covariant functors on C+- from arbitrary functors on C.  For
simplicity, we reduce the definition to the case of a bifunctor  F  covariant in the first component and
contravariant in the second.
10.1.2 Definition  Given a category C, and a functor  F: CxC → C  contravariant in the first
component and covariant in the second, the covariant functor F+-: C+-xC+- → C+- is defined by
F+-(A,B) = F(A,B).
F+-((f+,f-), (g+,g-)) = (F(f-,g+), F(f+,g-)).
One problem with the category C+- is that it is very unlikely to have colimits for all ω-chains.  The
interesting fact, though, is that the idea upon which definition 10.1.2 is based, works in every
subcategory  C* of C+-,  provided that only those functors  F such that   (F(f-,g+), F(f+,g-))  is still
a morphism in  C* are considered.
Our goal, now, is to find a subcategory C* of C+- such that simple and common properties on
C (such as, for example, the existence of limits for all diagrams) are enough to guarantee the
existence of colimits for all ω-chains in C*.
In the search for such a category C*, we can be helped by some intuition.
When in theorem 6.5.2 we considered the ω-diagram  ({Fi(0)}i∈ω, {Fi(z)}i∈ω ),  we had in
mind that it is a chain of increasingly finer approximations of the limit.  Thus, a morphism  Fi(0),  in
a sense, must explain why  Fi(z) is less than  Fi+1(z):  no information must be lost passing from
Fi(z)  to  Fi+1(z).  Reasonably, we may try to define a subcategory D of C+- whose morphisms
express this kind of relation between objects.
Among the subcategories of C+- that seem to satisfy this condition, an important one is CRet,
whose morphisms  (f+,f-)  have the property that  f-° f+ = id  (in C).
CRet is also very attractive becauseevery functor  F  on C may be still turned into a covariant
functor  F+-  on CRet by means of definition 10.1.2.
Indeed, consider for example a bifunctor  F  contravariant in the first component and covariant in
the second one.  Then one has
               F(f+,g-) ° F(f-,g+) = F( (f+,g-) ° (f-,g+) )
= F(f-° f+, g- ° g+)
by composition in  Cop××××C
= F(id, id)
as  (f+,f-), (g+,g-)  are morphisms of CRet
= id.
Thus  F+-((f+,f-), (g+,g-)) = (F(f-,g+), F(f+,g-))  is well defined as  (F(f-,g+), F(f+,g-))  is a
retraction pair.

10. Recursive Domain Equations
244
Unfortunately, CRet does not seem to suffice for our purposes.  For example, up to now, there
is no known nontrivial Cartesian closed category  C  such that  CRet  has colimits for every ω-chain.
Indeed, this is poses a very interesting problem: whether it is possible to find such a category, or
prove that it cannot exist.
It is very instructive to understand where the difficulty arises in general.
Suppose that the category C has limits for every diagram (this property holds in many interesting
CCC's; see chapter 6 for some examples) and let  ({Di}i∈ω , {fi}i∈ω )  be an ω-chain in CRet.
Then  ({Di}i∈ω , {fi-}i∈ω )  is an ω-chain in C, and it has a limit  (L,{γi}i∈ω ).  The object  L
seems to be a good candidate as a limit also for the chain  ({Di}i∈ω , {fi}i∈ω )  in CRet.  Indeed,
the following theorem holds:
10.1.3 Theorem  Let  {Di}i∈ω ,{fi}i∈ω )  be a ω-chain in CRet.  If  (L, {γi} i∈ω )  is a limit for
({Di}i∈ω , {fi-}i∈ω)  in C, then there is a cone  ( L, {(δi,γi)} i∈ω )  for  ({Di}i∈ω , {fi}i∈ω )  in
CRet  (that is, every  γi  is a right member of a retraction pair).
Proof: Fix  Dj.  For every  i  define  fj,i : Dj → Di  by:
fj,i = fi-° fi+1-° ... ° fj-1-
if  i < j
fi,i = id
fj,i = fi-1+° ... ° fj+1+° fj+
if  i > j .
(Dj, {fj,i}i∈ω)  is a cone for  ({Di}i∈ω , {fi-}i∈ω ), since  fi- ° fj,i+1= fj,i  as it is easy to check.
Thus there exists a unique morphism  δj: Dj→ L  such that  ∀i∈ω  γi ° δj = fj,i.  In case  i = j,   γj ° δj
= fj,j = id.
We still have to check that   ∀j∈ω  (fj+,fj-)°(δj+1,γj+1) = (δj,γj) .
Now,  fj-° γj+1= γj  by the definition of cone in C.  In order to prove that  δj+1°fj+= δj,  note that
∀i∈ω  γi ° δj+1° fi+ = fj+1,i ° fj+ = fj,j = γi ° δj,  and the result follows by unicity.
By a diagram, for  i > j :
♦

10. Recursive Domain Equations
245
Unfortunately, we have no way to prove that the cone  (L, {δi,γi}i∈ω )  is universal.  Indeed let  (L',
{gi}i∈ω )  be a cone for the ω-chain  ({Di}i∈ω, {fi}i∈ω )  in CRet.  Then  (L',{gi-}i∈ω )  is a
cone in C for  ({Di}i∈ω, {fi-}i∈ω )  and there exists a unique morphism  h  in C from  L'  to  L
such that  ∀i∈ω   h ° γi = gi-  and  γi ° h = gi+.  In other words:
However, there is in general no reasonable way to define a morphism  k  from  L  to  L'  such that
h ° k = id.  In the next section, we will see a way out of this problem.
10.2 0-Categories
Consider the class of morphisms  {gi+° γi}i∈ω  from  L  to  L' defined by the diagram at the end of
the previous section.  The morphism  gi+ ° γi: L→ L'  describes how the approximation of  L  up to
the ith-level may be represented inside  L'.  Intuitively, one may  expect that, in some sense,  gi+ ° γi
≤ gi+1+ ° γi+1.    Moreover, if
1.  the hom-sets in the category C are c.p.o.’s  and
2.  the class {gi+ ° γi}i∈ω  is an ω-chain,
then we could soundly define  k = ∪i∈ω{gi+ ° γi},  and  k  would play the role required at the end of
the previous section.  This takes us to the notion of “0-category.”
10.2.1 Definition  A category C is a 0-category  iff
i.   every hom-set  C[a,b]  is a cpo, with a least element  0a,b ;
ii.  composition of morphisms is a continuous operation with respect to the partial order;
iii. for every  f∈C[a,b] ,  0b,c ° f = 0a,c .
Then, by definition, every 0-category satisfies (1) above. Our next problem is to ensure condition
(2).  Note first that   gi+ °  γi =  gi+1+ ° fi+° fi- ° γi+1.  Moreover, if  fi+° fi- ≤ id,  then  gi+ °  γi  ≤
gi+1+ ° γi+1. This suggests the refinement we need in the category CRet.

10. Recursive Domain Equations
246
10.2.2 Definition  Let C be a 0-category, and let  i: D→E, j: E→D  be two morphisms in C.
Then  (i,j)  is a projection pair (from  D  to  E )  iff  j ° i = idD   and  i ° j ≤ idE .  (If  (i,j)  is a
projection pair,  i  is an embedding and  j  is a projection.)
Exercises  Prove the following statements:
1. If  (i,j)  is a projection pair from D to E, and (i',j') is another projection pair for the same two
objects, then  i ≤ i'  iff  j ≥ j'.
2. Every embedding  i  has a unique associated projection  j = iR;  conversely every projection  j  has
a unique associated embedding  i = jL.
10.2.3 Definition  Let C be a 0-category.  The category CPrj has the same objects as C, and
projection pairs as morphisms.
Remark  CPrj is a subcategory of CRet, and thus also of C+-.   By the fact that every embedding
i has a unique associated projection  j = iR  (and, conversely, every projection  j  has a unique
associated embedding i = jL),  CPrj is isomorphic to a subcategory CE of C that has embeddings as
morphisms (as well to a subcategory CP of C which has projections as morphisms).  We prefer to
work in CPrj since it looks more natural and carries more explicit information.  Note, however, the
following dualities:  (CE)op ≅ CP ≅ (Cop)E  (and, of course,  (CP)op ≅ CE ≅ (Cop)P ).
Exercise  Let C be a 0-category with terminal object  t. Prove that  t  is terminal in  CPrj  too. (Use
property 10.2.1.(iii) in the definition of 0-category).
10.2.4 Theorem  Let C be a 0-category with all ωop-limits. Let ({Di}i∈ω,{(fi+,fi-)}i∈ω )  be an
ω-chain in CPrj (and thus in CRet ) and  (L, {(δi,γi)} i∈ω )  be the cone in CRet defined by
theorem 10.1.3.  Then  (L, {(δi,γi)} i∈ω )  is a cone also in  CPrj.  Moreover it is universal in this
category.
Proof  In order to prove that  (L, {(δi,γi)}i∈ω )  is a cone in CPrj we must show that,∀i∈ω,  δi ° γi
≤ id.  Note that  ∀i∈ω  δi °  γi =  δi+1 ° fi+° fi- ° γi+1 ≤ δi+1 ° γi+1.  Thus, {δi ° γi}i∈ω  is a chain
and its limit  Θ = ∪i∈ω{δi ° γi}  must exist.  We prove that  Θ = id  and, thus, that ∀i∈ω  δi ° γi ≤ Θ
= id.  Θ = id  since  Θ  is a mediating morphism between  (L, {γi}i∈ω )  and itself in C.  Indeed,
∀j∈ω,
γj ° Θ = γj ° ∪i∈ω{δi ° γi}
= γj ° ∪i ≥ j{δi ° γi}
= ∪i ≥ j{(γj ° δi) ° γi}
= ∪i ≥ j{fi,j ° γi}

10. Recursive Domain Equations
247
= ∪i ≥ j{fi,j ° γi}
= γj.
We prove next that  the cone  (L, {(δi,γi)}i∈ω )  is universal in CPrj.
Let  (L',{(gi+,gi-)}i∈ω )  be another cone for  ({Di}i∈ω ,{(fi+,fi-)}i∈ω ).  That is,
∀i∈ω    gi+°  γi =  gi+1+° fi+° fi- ° γi+1 ≤  gi+1+°  γi+1
∀i∈ω    δi °  gi- =  δi+1 ° fi+° fi- ° gi+1- ≤  δi+1 °  gi+1-.
Define then
h = ∪i∈ω{gi+ ° γi} :  L → L'
k = ∪i∈ω{δi °  gi-} :  L' → L.
Observe that  (h,k)  is a projection pair, for
  k ° h = ∪i∈ω{δi °  gi-} ° ∪i∈ω{gi+ ° γi}
= ∪i∈ω{δi °  (gi- ° gi+) ° γi}
= ∪i∈ω{δi  ° γi}
= Θ = id
and
  h ° k = ∪i∈ω{gi+ ° γi } ° ∪i∈ω{δi °  gi-}
= ∪i∈ω{gi+ ° (γi ° δi ) °  gi-}
= ∪i∈ω{gi+ °  gi-}
≤ id.
Moreover,  (h,k)  is a mediating morphism between  (L, {(δi,γi)}i∈ω )  and  (L',{(gi+,gi-)}i∈ω ),
since ∀j∈ω
(h,k) ° (δj,γj) = (h ° δj , γj ° k )
= ( ∪i∈ω{gi+ ° γi} ° δj , γj ° ∪i∈ω{δi °  gi-})
= ( ∪i ≥ j{gi+ ° γi ° δj} ,  ∪ i ≥ j { γj ° δi °  gi-})
= ( ∪i ≥ j{gi+ ° fj,i} ,  ∪ i ≥ j { fi,j °  gi-})
= (gj+,gj-)
(h,k)  is unique, because, if  (h',k')  is another mediating morhism, then
(h',k') = (h'° id, id ° k')
= (h'° Θ, Θ ° k')
= (h'° ∪i∈ω{δi  ° γi}, ∪i∈ω{δi  ° γi} ° k')
= (∪i∈ω{h'° δi  ° γi}, ∪i∈ω{δi  ° γi ° k'})
= (∪i∈ω{gi+ ° γi}, ∪i∈ω{δi  ° gi-})
= (h,k) . ♦
A useful characterization of ω-colimits in the category CPrj is the following:

10. Recursive Domain Equations
248
10.2.5 Proposition  The cone  (L, {(δi,γi)}i∈ω )  for the ω-chain  ({Di}i∈ω , {(fi+,fi-)}i∈ω )
in CPrj  is universal  iff   Θ = ∪i∈ω{δi ° γi} = id .
Proof  Exercise. ♦
Up to now, we have shown that, if C is a 0-category with all ωop-limits, then the category CPrj has
colimits for every ω-chain.
The next point is to understand what we have lost with regard to the possibility of applying the
construction in definition 10.1.2, which turns contravariant functors into covariant ones.  Indeed,
there is no reason to believe that the functor F+- of this definition transforms projection pairs within
projection pairs.
Recall now that a two-argument endofunctor  F  over C, which is contravariant in the first
argument and covariant in the second one, has type  F: Cop××××C →C .
10.2.6 Definition  Let C be a 0-category. A functor  F: Cop××××C →C  is locally monotonic iff
it is monotonic on the hom-sets; that is, for  f, f'∈Cop[A, Β]  and  g, g'∈C[C, D],  one has
f ≤ f' ,  g ≤ g'   ⇒   F(f,g) ≤ F(f',g').
10.2.7 Proposition  If  F: Cop××××C →C  is locally monotonic and  (f+,f-) , (g+,g-)  are projection
pairs, then also  F+-((f+,f-),(g+,g-))  is also a projection pair.
Proof:  By definition   F+-((f+,f-),(g+,g-)) = (F(f-,g+), F(f+,g-)).  Compute then
F(f+,g-) ° F(f-,g+) = F( (f+,g-) ° (f-,g+) )
= F( f-° f+, g- ° g+)
= F( id, id )
= id
and
F(f-,g+) ° F(f+,g-) = F( (f-,g+) ° (f+,g-) )
= F( f+° f-, g+ ° g-)
≤ F( id, id )
= id. ♦
The last step is to see if we can find some simple condition on the functor  F  in C such that the
associated functor  F+-  in CPrj is ω-continuous.
10.2.8 Definition  Let C be a 0-category. A functor  F: Cop××××C →C  is locally continuous
(0-functor) iff it is ω-continuous on the hom-sets.  That is, for every directed set  {fi }i∈ω   in
Cop[A, Β],  and every directed set  {gi }i∈ω   in  C[C, D], one has
F(∪i∈ω{fi }, ∪i∈ω{gi ) ) = ∪i∈ω F(fi,gi ) .

10. Recursive Domain Equations
249
Of course, if F is locally continuous, then it is also locally monotonic.
Exercise Prove that the composition of two locally nonotonic (continuous) functors is still
monotonic (continuous).
10.2.9 Theorem  Let C be a 0-category with all ωop-limits. Let also  F: Cop××××C→C   be a locally
continuous functor. Then the functor  F+-: CPrj××××CPrj→CPrj  is ω-continuous.
Proof  Let  ({Ai}i∈ω, {(fi+,fi-)}i∈ω )  and  ( {Bi}i∈ω, {(gi+,gi-)}i∈ω )  be two ω-chains in
CPrj and let  (L, {(ρi+,ρi-)}i∈ω )  and  (M, {(σi+,σi-)}i∈ω )  be the respective limits.  Then, by
proposition 10.2.5,
Θ = ∪i∈ω{ρi+ ° ρi-} = id;
Ψ = ∪i∈ω{σi+ ° σi-} = id.
We must show that
(F+-(L,M), {F+-((ρi+,ρi-), (σi+,σi-)) }i∈ω ) = (F(L,M), {F(ρi-,σi+), F(ρi+,σi-))}i∈ω )
is a limit in CPrj for the ω-chain
( {F+-(Ai,Bi)}i∈ω, {F+-((fi+,fi-), (gi+,gi-)) }i∈ω ).
It is clearly a cone, by the property of functors.  We show that it is universal by proving that
∪i∈ω{ F(ρi-,σi+) ° F(ρi+,σi-) } = id.  The result then follows by proposition 10.2.5. We have the
following:
    ∪i∈ω{ F(ρi-,σi+) ° F(ρi+,σi-)} = ∪i∈ω{ F( ρi+ ° ρi-, σi+ ° σi-) }
= F(∪i∈ω{ρi+ ° ρi-}, ∪i∈ω{ σi+ ° σi- } )
= F( Θ, Ψ )
= F( id, id )
= id. ♦
In conclusion, we have described a way to turn arbitrary functors into covariant functors on suitably
derived categories. Then we set the condition under which it is possible to obtain ω-continuous
functors.  The solution of equations, such as  (*)  at the beginning of this chapter, is thus immediately
found for these functors.
Example In the introduction to this section we mentioned the important categorical equation X ≅
A+(X→X). If we wish to find a solution to equations of this kind in some category C based on
c.p.o.s (such as CPO, CPOS, Scott Domains, and so on), we are generally forced to relax the
interpretation of at least one of the two symbols + and →. Indeed, for their nature, all these categories
usually have fixpoints for all objects, and we know that this is inconsistent with having at the same
time coproducts and cartesian closedness. A typical way for avoiding the problem is to content

10. Recursive Domain Equations
250
ourselves with the interpretation of + as a weak coproduct. A weak coproduct is essentially defined
as a coproduct in definition 2.2.6, but no unicity is requested for the commuting arrow h.
The category CPO of c.p.o.’s with least (bottom) element and continuous functions for morphisms
is a 0-category with respect to the pointwise ordering of morphisms. CPO is a CCC with weak
coproducts A+B given by the coalesced sum (i.e. by identifying the two bottom elements of A and
B). Since it has coequalizers for every pair of objects, it has limits for every diagram.(see chapters 2
and 6). The functors  A+_  : CPO→CPO and →  : CPO××××CPO→CPO, respectively defined by:
A+_ (B)  = A+B,  A+_ ( f ) = idA+ f,
→(A,B) = BA,  →( f, g) = λh. g ° h ° f,
are both locally continuous.
The diagonal functor  ∆ : CPO→CPO××××CPO,  defined by  ∆(A) = (A,A)  and  ∆(f) = (f,f) , is
locally continuous too.  Thus we can apply theorem 10.2.9 and conclude that the associated functors
a.  (A+_)+- : (CPO)Prj → (CPO)Prj
     (A+_)+-(f+, f-) = (idA+f+, idA+f-)
b.  (→)+- : (CPO)Prj××××(CPO)Prj → (CPO)Prj,
     (→)+- ((f+, f-), (g+,g-)) = ( λh. g+ ° h ° f-, λh. g- ° h ° f+ )
c.  (∆)+-  : (CPO)Prj → (CPO)Prj××××(CPO)Prj
    (∆)+-(f+, f-) = ( (f+, f-) , (f+, f-) )
are ω-continuous.  But composition of ω-continuous functors is still a ω-continuous functor; thus,
the functor  F = (A+_)+-° (→)+- ° (∆)+- : (CPO)Prj → (CPO)Prj  is ω-continuous.  Explicitly,  F
is defined by
F(X)
=  A+XX
F(f+,f-) =  (idA+ λh. f+ ° h ° f-, idA+ λh. f- ° h ° f+).
Thus, for every  A,  there exists  X  such that   X ≅ A+XX.
References  For an early computer scientific introduction to recursive domain equations, the
reader should consult Stoy (1977).  The first solution to the problem of finding a domain isomorphic
with its own function space, as required for the type-free λ-calculus, was given in Scott (1972)
which basically started the mathematical discussion on recursive definitions of data types and, more
generally, the so called area of “denotational semantics”.  The categorical approach exposed in the
present chapter is a direct generalization of Scott’s method and is essentailly due to Wand (1979),
Lehmann and Smith (1981) and Smith and Plotkin (1982).  An introductory presentation may be also
found in Plotkin (1978).  Gunter (1985) investigates the notion of embedding as a particular case of
adjunction and, thus, sets the base for an interesting generalization of the categorial approach.

11. Second Order Lambda Calculus
251
Chapter 11
SECOND ORDER LAMBDA CALCULUS
The system λ2, or second order λ-calculus, has been introduced by Girard for the sake of Proof
Theory. It was meant to prove, in particular, a normalization theorem for second order arithmetic,
PA2 (also considered a sound formalization of analysis, by proof theorists). The key points are that
(second order) λ-terms code proofs in (second order) systems based on natural deduction and, quite
generally, that cut elimination corresponds to β reduction for λ-terms. Thus normal proofs for and
consistency of PA2 follow from the normalization theorem for λ2 (see chapter 8 and references).
This calculus was later rediscovered by Reynolds and, since then, it has received great attention,
mostly within the computer science community, from both the syntactic (typing, consistent
extensions, etc.) and semantic points of view. The main novelty of λ2, over the simply typed
calculus, is the possibility of abstracting a term with respect to type variables; by this, λ2 represents
“polymorphic” functions, that is, functions that may have several types or, more precisely, that may
update their own type.
It is largely agreed that this specific formalization of the broad notion of polymorphism in
programming focuses most of the main concerns of the programmers who apply these methods and
suggests relevant implementations of modularity in functional programming.
The type system of λ2 is an extension of the simple types in section 8.2, and it is meant to
provide a type for polymorphic functions (i.e., terms obtained by type abstraction). As we said, this
is achieved by introducing type variables and allowing a quantification (informally, a product) over all
types. The type  ∀X:Tp.T  is the type of all those terms that, when applied to a type  S,  yield a new
term of type  [S/X]T.  Types are defined impredicatively since in the inductive definition of the
collection  Tp  of all types one has to use  Tp  itself, which is being defined.  For example, Tp is used
when defining ∀X:Tp.T  as a type or, also,  ∀X:Tp.T  is said to be a type, while it contains a
quantification over all types, including itself. The “dimensional clash” (and the semantic difficulty)
which derives from impredicativity is evident when considering that a term of type  ∀X:Tp.T  can be
applied to its own type. This circularity, very common in mathematics (e.g., for least upper bounds
and related notions) comes with the expressive power of the system and is reflected in the difficulty
of finding sound mathematical models for it. It is our opinion that Internal Category Theory provides
significant tools for this semantic investigation. First, it allows the explicit use of “constructive”
universes, as an alternative to the (usually intended) set-theoretic frame for (small) categories, where
the constructions below would provide trivial models. Second, it reflects and gives meaning to the
circularity of impredicativity by a mathematically clear closure property of some internal categories.

11. Second Order Lambda Calculus
252
11.1 Syntax
Types and (rough) terms are first defined in BN-form.  The typing rules will pick up, among the
rough terms, the legal ones.  Types are built up from type variables, ranged by X, Y, Z…; terms are
built up from (term) variables, ranged by x, y,…:
Type expressions:       T := X | (T → S) | (∀X:Tp.T )
Term expressions:       e := x | (ee) | (eT) | (λx:T.e) | (ΛX:Tp.e).
We use capital letters  T,S,... as metavariables for type expressions.
Conventions:  λ, Λ  and ∀ are all variable binders.  An unbound variable  x  in  e  is  free in  e
(notation:  x∈FV(e) ).  The substitution of  a  for  x  in  e  ([a/x]e) is defined by induction,
provided that  a  is free for  x  in  e,  as usual.
A context is a finite set  Γ of type variables; ΓX stands for Γ∪{X}. A type T is legal in  Γ  iff
FV(T) ⊆ Γ.  A type assignment in  Γ  is a finite list  E = (x1:T1),…, (xn:Tn)  such that any  Ti  is
legal in  Γ.
The typing relation  Γ;E |- e: T,  where  E  is a type assignment legal in  Γ,  e  is a term expression
and  T  is a type expression, is defined as follows:
(assumption)
Γ;E |_  x:T      if  (x:T)∈E
       Γ;E(x:T)  |_   e: S
(→I)
_____________________
Γ;E  |_  (λx:T.e) : (T→S)
Γ;E |- f: (T→S)    Γ;E |- e: T
(→E)
________________________
           Γ;E |- (fe) : S
                 ΓX; E  |_  e : T
(∀I)
___________________________ 
(*)
Γ;E  |_  (ΛX: Tp. e) : (∀X : Tp. T)
*  if there is no variable in  FV(e)  whose type depends on X
Γ;E  |_  f : (∀X : Tp . T)        Γ |_  S : Tp
(∀E)
________________________________
              Γ;E  |_  (fS) : [S/X]T

11. Second Order Lambda Calculus
253
Conversion   Equations among well-typed terms are defined by the following axioms:
β.
(λx:A .b) e = [e/x]b
β2.
(ΛX:Tp .b) A = [A/X]b
η.
λx:A .bx = b
if x∉FV(b)
η2.
ΛX:Tp .bX = b
if X∉FV(b)
and by the usual rules that turn  “=”  into a congruence relation.
Before starting the formal definition of the models for such a system, it is worthwhile to say a few
words about its interpretation, and to try to explain the following work by a naive presentation of the
categorical meaning of λ2.  Note also that this chapter is followed by one entirely dedicated to
examples of the abstract categorical treatment which we follow here.  The reader may find convenient
to check hi/her understanding of it against the structures presented in chapter 12.
As pointed out in chapter 8, any Cartesian closed category C can be used to give a categorical
semantics to the simply typed lambda calculus: types (which are just constant types or “arrow types”)
are interpreted by objects of C; terms of type  T,  with free variables  x1:T1,…, xn:Tn,  are
interpreted as morphisms from  T1×…× Tn  to  T.  The categorical interpretation of the second order
calculus generalizes this semantics; in this case, however, the collection of types Tp must be closed
not only under the arrow construction, but also under universal quantification. If we write  ∀X:Tp.T
as  ∀(λX:Tp.T),  where  λ  is an informal lambda notation for functions,  ∀  may be readily
understood as a map from   (Tp → Tp)  to  Tp, as it turns the map  λX:Tp.T  in  (Tp→Tp)  into a
type.  Thus, the interpretation of  ∀  should be a map from  ObC→ObC  to  ObC. The problem is that
this map has to be represented internally in some ambient category. A natural choice is to have some
sort of metacategory  E  such that C may be regarded as an internal category of  E,  in the sense of
section 7.2.  Recall, in short, that C must consist of a pair  (c0, c1)  of objects of  E  such that,
informally,  ObC = c0  and  MorC = c1.  If  E  is Cartesian closed, then  ∀  may typed as  ∀:
c0c0→c0.
Objects of the kind  Tp→Tp  (i.e. “points,” or “elements” of  c0c0)  are usually called variable
types. As we have already seen, if  σ  is a variable type, the type  ∀(σ)  represents intuitively the
collection of all the polymorphic terms  e  such that, for all types  T,  (eT) : σ(T).  This is equivalent
to saying that  ∀(σ)  is a dependent product that is, a product of different copies of  c0  indexed by  σ
on elements of c0 itself. The projections of this dependent product yield the instances of the
polymorphic terms in  ∀(σ)  with respect to particular types. In other words, there will be in the
model an operation  proj: (c0→c0)×c0→c1  that takes a variable type  σ: c0→c0,  a type T, and gives
a morphism  projσ(T): ∀(σ)→σ(T);  projσ(T)  describes how a polymorphic term of type  ∀(σ)  can
be instantiated into the type  σ(T),  thus modeling the application of a term  e  in  ∀(σ)  to a type  T.
By the definition of a dependent product, we will also have an isomorphism between the
polymorphic terms in  ∀(σ)  and the collection of all the families  {eT: σ(T)}T∈c0  of terms indexed

11. Second Order Lambda Calculus
254
over all types. Let us call  ∆  this isomorphism, which relates a family of terms  {eT: σ(T)}T∈c0  to
the polymorphic term   ∆({eT: σ(T)}T∈c0) = ΛT:Tp.eT : ∀(σ).  The functions  proj  and  ∆  satisfy
the following equations:
1.   projσ(S) ( ∆({eT}T∈c0) ) = eS ;
2.   ∆({projσ(T)(e)}T∈c0) = e ;
whose meaning may be sketched as follows:
1.  if we define a polymorphic function from the collection of functions  {eT}T∈c0,  and then we
consider the particular instance relative to the type S, this is equal to the original function eS;
2. if, given a polymorphic function e, we consider the collection of all its instances
{projσ(T)(e)}T∈c0  and then we use this collection to rebuild a polymorphic function, we obtain  e
again.
Equations 1. and 2. above are the key facts allowing the interpretation of rules β and η,
respectively, for second order abstraction and application.
Exercise  Compare equations 1 and 2 above with the equations for the categorical Cartesian product
pi ˚ <f1,f2> = fi   for  i = 1,2 ;
< p1 ˚ f, p2 ˚ f > = f .
11.2 The External Model
The informal discussion of the previous section should have motivated the use of internal concepts in
describing the semantics of λ2. The model definition inspired by these ideas will be the main object
of study in this chapter and it is presented in the following section. We introduce here a different
notion of categorical model that does not require the use of internal concepts. It is based on an
algebraic generalization of the semantics of the simply typed lambda calculus in a bidimensional
universe of Cartesian closed categories indexed over another (global) CCC. We will call this model
“external.” In this model the collection of types is represented by a single object of the global
category, say c0 (or Ω, as it is usually denoted in this approach), but no requirement is made in order
to have an internal category with  c0  as an object of objects. This fact, however, must be heavily
compensated for by a number of particular conditions that relate “on the nose” categorical properties
of indexed categories, which are not very intuitive. Thus, on one hand, the external model is more
manageable then the internal one; on the other, it is less limpid and, in a sense, less suggestive. We
claim that both these properties of the external model are due to the fact that it is a particularly simple
instance of the internal notion. More specifically, we will show that an external model is just an
internal one whose ambient category is a topos of presheaves, and whose object of objects  c0  is a
representable functor  [_,Ω]. The understanding we propose of the external model also sheds some

11. Second Order Lambda Calculus
255
light on the interplay among the different conditions in its definition and gives a new justification for
some apparently ad hoc  requirements.
At the base of the external notion of a model for λ2, there is the notion of a class of small
categories indexed over another (global) category  E  - essentially a contravariant functor  G  from  E
to Cat.  E  is a Cartesian category with a distinguished object  Ω, which interprets the collection of
types. Products  Ωn  are used to give meaning to contexts. Arrows in  E[Ωn,Ω]  represent types with
at most  n  free variables in the context  Ωn .
The functor  G: E→Cat  takes every context  Ωn  in  E  to a (local) category  G(Ωn)  whose
objects are the types legal in that context. Thus these types appear both as arrows in  E  and as objects
in the local categories, and it is natural to require  Obj(G(e)) = homE(e, Ω).  The arrows between two
types  σ  and  τ  in a local category  G(Ωn)  correspond to terms of type  τ  and free variables in  σ.
Every local category is required to be a model of a simply typed lambda calculus and, thus, it is
Cartesian closed. As for the interpretation of the polymorphic product it is described by an adjoint
situation between local categories; moreover this adjointness must be natural with respect to the global
parameter given by the context.
11.2.1 Definition   An  external λλλλ2 model  (PL category) is a triple  (E, G, Ω )  where:
1. E  is a Cartesian closed category (global category);
2. Ω  is a distinct object in  E;
3. G: Eop → Cat   is a functor such that
i.  for each object  e  in  E,  Obj(G(e)) = homE(e, Ω),  and, for each morphism  σ∈E[e',e], the
functor  G(σ): G(e) → G(e')  acts on the objects of  G(e)  as  homE(σ,Ω).
ii. for each object  e  in  E,  the (local) category  G(e)  is Cartesian closed; for every  σ∈E[e',e],
the functor  G(σ): G(e) → G(e')  preserves the Cartesian closed structure “on the nose” (and
not just up to isomorphism); that is, for  a,b∈ObjG(e) = homE(e, Ω)  it satisfies:
a. G(σ)( tG(e) ) = tG(e'),  where  tG(e)  is the terminal object in  G(e)
G(σ)( !a ) = !G(σ)(a)
b. G(σ)( a × G(e) b) = G(σ)(a) ×G(e') G(σ)(b),  where  ×G(e)  is the product in  G(e)
G(σ)(fsta,b) = fstG( σ)(a),G( σ)(b)
G(σ)(snda,b) = sndG( σ)(a),G( σ)(b)
c. G(σ)([a,b]G(e)) = [G(σ)(a), G(σ)(b)]G(e'),  where  [,]G(e)  is the exponent in  G(e)
G(σ)(evala,b) = evalG( σ)(a),G( σ)(b)
iii.  an E-indexed adjunction  < Fst, ∀, ∆ > : G → GΩ, where
a. GΩ : Eop → Cat  (see definition 7.1.2) is the functor defined by
∀e∈ObE       GΩ(e) = G(e×Ω)
∀σ∈E[e',e]   GΩ( σ) = G( σ×idΩ)
b. ∀e∈ObE , Fst(e) = G(fste,Ω ) : G(e) → GΩ(e) = G(e×Ω) (with fste,Ω: e×Ω→e).

11. Second Order Lambda Calculus
256
By definition 7.1.6 of an E-indexed adjunction, we have, for every object  e  in  E,  an adjunction
< G(fste,Ω), ∀(e), ∆(e) > : G(e) → G(e×Ω)
and, moreover,
∆(e') ˚ G(σ×idΩ) = G(σ) ˚ ∆(e)
11.2.2 Remark   If  (E,G)  is an external λ2 model, then we have the following natural
transformations:
×G(_):
homE×E(K2(_), ( Ω ,Ω)) → homE(_, Ω),
[,]G(_):
homE×E(K2(_), ( Ω ,Ω)) → homE(_, Ω),
∀:
homE(_×Ω, Ω) → homE(_, Ω),
where   Κ2  is the diagonal functor.
Indeed conditions 3.ii.b and 3.ii.c in definition 11.2.1 express exactly the naturality of  ×G(_)
and  [,]G(_),  while by definition  ∀  is natural from  GΩ  to  G  and, a fortiori, also from
homE(_×Ω, Ω )  to  homE(_, Ω).
11.2.3 Lemma  For every object  a  in  E  there are morphisms
x0   : ΩxΩ → Ω
[,]0 : ΩxΩ → Ω
∀0:  ΩΩ → Ω
such that, for each object  e  of  E  and for all objects   σ,τ  of  G(e),
x0 ˚ <σ,τ> =  σ ×G(e)τ
[,]0 ˚ <σ,τ> =  [σ,τ]G(e)
and, for each object  ρ  of  G(e×Ω),
∀0 ˚ Λ(ρ) = ∀(e)(ρ)
Proof We have the following natural transformations
ε1 = ×G(_)  ˚  <,> −1   : homE(_, Ω×Ω) → homE(_, Ω)
ε2 = [,]G(_)  ˚  <,> −1 : homE(_, Ω×Ω) → homE(_, Ω)
ε3 = ∀ ˚  Λ −1  :  homE(_, ΩΩ) → homE(_, Ω)
where
×G(_):
homE×E( Κ2(_), (Ω,Ω) ) → homE(_, Ω)
[,]G(_): homE×E( Κ2(_), (Ω,Ω) ) → homE(_, Ω)
∀:
homE(_×Ω, Ω) → homE(_, Ω)
are the natural transformations of remark 11.2.2 and
<,>−1:
homE(_, Ω×Ω) → homE×E( Κ2(_), (Ω,Ω) )
Λ −1:
homE(_, ΩΩ) → homE(_×Ω, Ω)
are the natural isomorphisms given by the Cartesian closure of E.

11. Second Order Lambda Calculus
257
Then, by the Yoneda lemma, the arrows x0, [,]0, ∀0 with the requested properties are obtained
by setting
x0 =  ε1(Ω×Ω)(idΩ×Ω)
[,]0 = ε2(Ω×Ω)(idΩ×Ω)
∀0 = ε3(ΩΩ)(idΩΩ)
For example, we have, for σ,τ: e → Ω,
x0 ˚ <σ,τ> = ε1(Ω×Ω)(idΩ×Ω) ˚ <σ,τ>
= homE[<σ,τ>, Ω×Ω] (ε1(Ω×Ω)(idΩ×Ω))
= ε1(e)(homE[<σ,τ>, Ω×Ω](idΩ×Ω))
= ε1(e) <σ,τ>
= σ ×G(e)τ.
The other equations are proved similarly. ♦
11.3 The External Interpretation
In this section we define, in several steps, the “external” interpretation of the second order lambda
calculus.
11.3.1 Type Expressions  A type expression T legal in a context  Γ = {X1,...,Xn}  is
interpreted by a morphism  [T]Γ: [Γ]→[A]  in  E  (where [Γ] = c0n=((t×c0)×…×c0),  inductively
defined as follows:
1.
[Xi]Γ = snd˚fstn-i;
2.
[S→T]Γ = [,]0 ˚ < [S] Γ, [T] Γ >;
3.
[∀X:Tp.T]Γ = ∀0 ˚ Λ([T]ΓX ).
Note that, as in the simply typed λ-calculus, variables are projections and arrows are exponents.
Morover, impredicative types are interpreted by formalizing (externally) the informal discussion at the
end of 11.2 (see also 11.5.1).
11.3.2 Type assignment  A legal type assignment  E = (z1: S1)... (zn: Sn),  in a context  Γ,  is
interpreted by the product (local in  G([Γ]) )
[E]Γ = (...(tG([Γ]) ×[S1]Γ)...)×[Sn]Γ = xon ˚ <...<tG([Γ]),[S1]Γ>...,[Sn]Γ >
where tG([Γ])  is the terminal object in the local category G([Γ]).
11.3.3 Terms  A legal term  M  such that
Γ = X1,...,Xn ;  E = (z1: S1)... (zn: Sn)   |-   M : T
is interpreted by a morphism

11. Second Order Lambda Calculus
258
[M]ΓE :  [E]Γ→[T]Γ  in the local category   G([Γ]) .
The inductive definition is
1.
[zi]ΓE = snd ˚ fstn-i;
2.
[MN]ΓE = eval ˚ <[M]ΓE, [N]ΓE>;
3.
[λx:S.M]ΓE = Λ([M]ΓE[x:S] );
4.
[ΛX:Tp.M]ΓE =  ∆([M]ΓX;E);
5.
[M[T]]ΓE = G(<id, [T] Γ >) (Proj([Γ])) ˚ [M]ΓE,
where  Proje  is the counit of the adjunction  < G(fste,Ω), ∀(e), ∆(e) > : G(e)→G(e×Ω),  i.e., Proje
= ∆(e)-1(id).
11.3.4 Remark The interpretation we have just given is somewhat informal. Indeed we should
always specify in which local category we are working in, and we should add a lot of indices for the
natural transformations. Note also that the interpretation is not, as it could seem, by induction on the
syntactical structure of terms, but on the lenghth of the proof of their derivation (the proof that the
terms are well typed).  For example, a fully specified interpretation for  [ΛX:Tp.M]ΓE  would be:  if
ΓX; E |- M: T  and  τ = [T]ΓX  then  [ΛX:Tp.M]ΓE = (∆([Γ])([E]Γ, τ ) ) ([M]ΓX;E).
11.4 The Internal Model
In this section we define the notion of internal λ2 model. The intuition is to require for an internal
Cartesian closed category  c∈Cat(E)  the existence of the arrow  ∀0: c0c0→c0,  which gives the
depended product, in a such a way that equations 1 and 2 of section 11.1 are verified. We obtain by
this a characterization of internal models by means of ground  equations, with the consequence that
internal models are preserved by limit- and exponent-preserving functors.
In what follows, we always assume that the ambient category  E  is Cartesian closed and has finite
limits.
11.4.1 Definition  Let  a  be an object of  E.  |a|  is the internal category  (a, a, id, id, id, id ).
The internal  |a|  represents (internalizes) the discrete category with exactly one morphism (the
identity) for each point in  a.
11.4.2 Definition  Let  c = (c0, c1, DOM, COD, COMP, ID)∈Cat(E).  Define then:
c* = (c0c0, c1c0, DOM*, COD*, COMP*, ID*)  with
DOM* =  Λ(DOM ˚ eval)
COD*  =  Λ(COD ˚ eval)
COMP* = Λ(COMP ˚ eval×0eval ˚ p)

11. Second Order Lambda Calculus
259
ID* = Λ(ID ˚ eval)
where  p = <<Π1° p1, p2>, <Π2° p1, p2>>0 :  (c1c0 ×0 c1c0) × c0 → (c1c0 × c0) ×0 (c1c0 × c0).
The idea behind the previous definition is that the object  c*  represents internally the category of
functors from  |c0|  to  c.  Note that, as  |c0|  is a discrete category, the functors  F  from  |c0|  to  c  are
fully determined by their functions  f0  on objects. In effect, this informal idea may be formalized by
the following remark:  if  E  is Cartesian closed, so it is  Cat(E). The object  c*  of the previous
definition is isomorphic in  Cat(E)  to the exponent of  |c0|  and  c.  The category  c*  may be also
regarded as the collection of all tuples of elements of  c  indexed by elements in  c0,  for  |c0|  is a
discrete category.
11.4.3 Definition  The constant internal functor  K : c→c*  is  K = (k0, k1)  with
k0 = Λ(fst) : c0→c0c0    where  fst: c0×c0→c0  is the projection
k1 = Λ(fst) : c1→c1c0    where  fst: c1×c0→c1  is the projection.
K : c→c*  must be considered as a sort of diagonal functor. Informally, given an object  b  in  c0,  its
image under  K  is the tuple (indexed on  c0)  of all-b elements (i.e., the constant-b function from c0
to  c0).  As a right adjoint to the diagonal functor  Κ2: C→C2  yields the categorical product,
similarly, a right adjoint to the functor  K : c→c*  yields the (categorical) dependent product indexed
over c0.
11.4.4 Definition   A model for  λλλλ2222  is given by
1. a Cartesian closed category  E  with all finite limits (global category);
2. an internal Cartesian closed category  c = (c0,c1,DOM,COD,COMP,ID)∈Cat(E);
3. a right (internal) adjoint to  K: c → c* .
The requirements on the global category E in the previous definition could be slightly relaxed: the
notion of internal category can be also given in interesting ambient categories without all  limits (see
the next chapter for an example). Similarly, for a model of λ2 we actually need only exponents of the
form  ec0  in  E. Our requirements are very close to those needed for models of the stronger calculus
Fω. In this case the only further condition is that of having a right (internal) adjoint to  Ke: c→ce  for
every object  e  of  E,  where  ce = (c0e, c1e, DOMe, CODe, COMPe, IDe)  represents the category
of functors from  |e|  to c, and  Ke: c→ce  is the internal functor defined by
Ke = (ke,0 = Λ(fst): c0→c0e,  ke,1 = Λ(fst): c1→c1e).
By theorem 7.3.7,  a right adjoint to  K: c → c*  is fully determined by
i.   an arrow  ∀0:  c0c0→ c0,

11. Second Order Lambda Calculus
260
ii.  an arrow  PROJ: c0c0→ c1c0   such that   DOM* ˚ PROJ = k0 ˚ ∀0 , COD* ˚ PROJ = id.
      (if  h: e → c0c0 ,  we use the abbreviation  PROJh  for  PROJ ˚ h )
iii. an arrow   ∆: X"→ Y"  where  X"  and Y"  are respectively the pullbacks of
< DOM* , COD* > : c1c0→ c0c0×c0c0,  k0×id : c0×c0c0→ c0c0×c0c0
< DOM,COD > : c1→ c0×c0,  id×∀0 : c0×c0c0→c0×c0
such that:
g0.
γ' ˚  ∆ = γ
g1.
(PROJ ˚ p2 ˚ γ)  * ( Λ(fst) ˚ ΠY" ˚ ∆ )  = ΠX"
h.
∆ ˚ < γ',  (PROJ˚  p2 ˚ γ')  * ( Λ(fst) ˚ ΠY" ) >0 = idY"
where  h*k = COMP* ˚  <h,k>0 = Λ( Λ-1(h) oΛ-1(k) ),  and  fst: c1×c0→c1  is the projection.
PROJ  is the counit of the adjunction. In order to understand its meaning, it is useful to compare it
with the counit of the Cartesian product. In that case, the counit is
(p(a1,a2),1, p(a1,a2),2) ∈ C2[ (K2(a1×a2), (a1,a2) ]
where  K2  is the diagonal functor. That is, the counit is a collection of morphisms  p(a1,a2),i  in  C,
indexed over objects  (a1,a2)  of  C2 and objects  i = 1,2  in the category 2, such that each  p(a1,a2),i
has domain  a1×a2  and codomain  ai. Analogously,  PROJ: c0c0→c1c0 ≅ c0c0×c0→c1  is a
collection of morphisms  PROJσ(T)  in  c1  indexed over objects  σ  of  c*  and objects  T  of  c
(which now corresponds to the category 2 above), such that each projection  PROJσ(T)  has domain
∀0(σ)  and codomain  σ(T).
Consider now two points  f: t→c1c0,  g: t→c1  in  c1c0  and  c1.  Informally,  f  is a family of
terms in  c1  indexed by objects in  c0,  and  g  is a term in  c1.  If there exists some  a  such that
DOM ˚ f = Κ0 ˚ a,  that is if all the terms represented by  f  have a common domain  a : t→c0,  then
we can “apply” the isomorphism  ∆ and obtain the polymorphic term  ∆˚f  (note the usual confusion
between application and composition resulting from reasoning about points). Conversely, if there
exists  b  such that   COD ˚ g = ∀0 ˚ b,  then   g  is a polymorphic term of type  ∀0˚b.
Formally, for every  e  in E, given  f: e → c1c0  and  g: e→ c1  such that
DOM ˚ f = Κ0 ˚ a
COD ˚ f = b
DOM ˚ g = a
COD ˚ g = ∀a0 ˚ b

11. Second Order Lambda Calculus
261
equations (g1) and (h) above give
g1.
PROJb * ( Λ(fst) ˚ ΠY" ˚ ∆ ˚ <<a,b>,f>0 )  = f
h.
∆ ˚ < <a,b>, PROJb * ( Λ(fst) ˚ g ) >0 = <<a,b>,g>0
and with easy manipulations, recalling that  h*k = COMP* ˚ <h,k>0 = Λ( Λ-1(h) o Λ-1(k) ), one
obtains
g1'.
Λ( (eval ˚ PROJb×idc0)o(ΠY" ˚ ∆ ˚ <<a,b>,f>0 ˚ fst) ) = f
h'.
∆ ˚ < <a,b>, Λ( (eval ˚ PROJb×idc0)o(g ˚ fst) ) >0 = <<a,b>,g>0
which are the formalization of equations 1 and 2 of our informal discussion about second order
models in section 11.1.
11.5 The Internal Interpretation
Let us now summarize some of the data that come with an internal model. All these objects,
morphisms, and functions will be used to give an explicit definition of the interpretation for second
order terms as follows:
i. For the global category  E:
- a terminal object  T,  products and exponents
- projections:  fst,  snd
- evaluation morphism: eval   (used for defining COMP*)
- pairing function:  <,>
- “currying” function:  Λ
ii. For the internal category:
- an arrow  t0: T → c0  defining the internal terminal object
- an arrow  x0 : c0×c0 → c0  defining the internal product
- an arrow  [,]0 : c0×c0 → c0  defining the internal exponent
- an arrow  ∀0: c0c0 → c0  defining the dependent product
- internal projections:  FST: c0×c0 → c1 , SND: c0×c0 → c1
- internal evaluation morphism:  EVAL: c0×c0 → c1
- instantiation morphism:  PROJ: c0c0 → c1c0  of the dependent product
- internal pairing:  <,>: (c0×c0×c0) ×0 (c1×c1)→(c0×c0×c0) ×0 c1
<,>(a,b,c, f: a→b, g:a→c) = (a,b,c, pairing(f,g): a→b×c )
- internal currying function:  Λ: (c0×c0×c0) ×0 c1→ (c0×c0×c0) ×0 c1
Λ(a,b,c, f:a×b→c) = (a,b,c, curry(f): a→cb)
- dependent pairing:   ∆: (c0×c0c0) ×0 c1c0 → (c0×c0c0) ×0 c1
∆( a, σ,{eT: a→σ(Τ)} ) = (a, σ, dep_pairing({eΤ}): a→∀(σ)  ).

11. Second Order Lambda Calculus
262
We point out that an internal model is completely determined by (pullbacks and) a set of ground
equations, that is, equations without (quantified) free variables; this contrasts with external models
(or with standard, “external” Cartesian closed categories, for that matter). An important consequence
of this is that internal models are preserved by limit- and exponent- preserving functors (that is
functors preserving the structure for sources and targets of the data defining the model). This fact will
be used later on to relate internal and external models.
Notation  For  e∈ObE,  en = (((t×e)×e)×…×e)  where  t  is the terminal object of  E  and  e  appears
n  times.
11.5.1 Type Expressions  A type expression T legal in a context  Γ = {X1, ..., Xn}  is
interpreted by a morphism  [T]Γ : c0n→c0  in  E.  In particular:
1.
[Xi]Γ = snd ˚ fstn-i
2.
[S→T]Γ = [,]0 ˚ < [S]Γ, [T]Γ >
3.
[∀X:Tp.T]Γ = ∀0 ˚ Λ([T]ΓX )
11.5.2 Type Assignments  A type assignment  E = (z1: S1)...(zm: Sm)  legal in a context  Γ
={X1,...,Xn}  is interpreted by the product
[E]Γ = x0m ˚ <...<t0 ° !c0n,[S1]Γ>...,[Sm]Γ> : c0n → c0
where x01 = x0 and, for i>1,  x0i = x0 ˚ (x0i-1×id).
11.5.3.Terms  A legal term  e  such that
Γ = {X1,...,Xn};  E = [z1: S1]... [zm: Sm]  |-   e : T
is interpreted by a morphism
[e]ΓE :  c0n → c1
such that 
DOM ˚ [e]ΓE = [E]Γ : c0n → c0
COD ˚ [e]ΓE  = [T]Γ : c0n → c0
In particular,
1.
[zi]ΓE = SND o FSTn-i
(where for simplicity we omit the “indexes” for FST and SND);
2.
if   Γ;E |- f: S→Τ ,   Γ;E |- e:S,   σ = [S]Γ ,  τ = [T]Γ, then
[fe]ΓE = EVALσ,τ o ( <,> ˚ < <<[E]Γ,[S→Τ]Γ>, σ>0 , <[f]ΓE,[e]ΓE> >0);
3.
if   Γ;E(x:S) |- e: T ,  σ = [S]Γ , τ = [T]Γ, then
[λx:S.e]ΓE = Πy' ˚ Λ ˚ < <[E]Γ,σ,τ>, [e]ΓE(x:S) >0 ;
4.
if   ΓX; E |- e: T   and   τ = [T]ΓX, then
[ΛX:Tp.e]ΓE = ΠY" ˚ ∆ ˚ < <[E]Γ,Λ(τ)>, Λ([e]ΓX;E)>0 ;

11. Second Order Lambda Calculus
263
5.
if   Γ,E |- e: ∀X:Tp.S   and   σ = Λ([S] ΓX), then
[eT]ΓE  =  Λ−1(PROJσ * ( Λ(fst) ˚ [e]ΓE  ) ) ˚ <id, [T]Γ>
=  ( Λ-1(PROJσ) o ([e]ΓE ˚ fst) ) ˚ <id, [T]Γ>
(where  h * k  = COMP* ˚ <h,k>  ;  h o k  = COMP ˚ <h,k>).
Given the above definitions, the proof of a soundness theorem, with the required substitution
lemmas, is a routine check (as straightforward as it is tedious and laborious).
11.6 Relating Models
In the previous sections, two different notions of model have been introduced. We are now interested
in the relation between them. It will turn out that the two notions are not as distant as they may seem.
We start by an analysis of how we can define an external model from an internal one. The
construction is based on the externalization process of an internal category via hom-functors
presented in chapter 7, which corresponds, essentially, to the Yoneda embedding. Since the hom-
functor preserves pullbacks and exponents, we will be able to show that any internal model yields an
“equivalent” external one.
Suppose that  c = (c0,c1,DOM,COD,COMP,ID)∈Cat(E)  is an internal model.  As the reader has
probably imagined, the functor  [_,c] : Eop→Cat  of definition 7.4.2  plays the role of  G  in the
external approach. For ease of reference, we recall here that definition.
11.6.1 Definition  Let  c∈Cat(E).  The functor  G = [_,c] : Eop→ Cat  is defined in the following
way:
on objects  e∈E      
[_,c]  = [e,c] ;
on arrows  σ: e'→e [_,c](σ) = [σ,c]  is the functor from  [e,c]  in  [e',c]  which is defined as
[σ,c0]  on objects and as  [σ,c1]  on arrows.
11.6.2 Lemma ∀ σ: e'→e,  G(σ) = [σ,c]: [e,c]→[e',c]  acts on the objects of  [e,c]  (i.e., on
E[e,c0])  as  E[σ,c0].
Proof  By definition. ♦
11.6.3 Lemma   If  c  is (internally) Cartesian closed, then, for every  e  in  E,  Ee,c  is Cartesian
closed.
Proof  (sketch)
Let 1. < O, T, ο > : c → 1
2. < ∆, x, <,> > : c → c×c
3. < x, [,]  , Λ > : c → c

11. Second Order Lambda Calculus
264
be the internal adjunctions given by the Cartesian closure of  c.  Then  <[_,F], [_,G], Θ > :
[_,c]→[_,d]  is an E-indexed adjunction. By proposition 7.4.11 there are three E-indexed adjunctions
1'. <[_,O], [_,T], o' > : [_,c]→[_,1]
2'. <[_,∆], [_,x],  <,>' > : [_,c]→[_,c×c] ≅ [_,c]×[_,c]
3'. <[_,x], [_, [,] ], Λ' > : [_,c]→[_,c]  with parameters in [_,c].
Hence for every  e  in E,  [e,c]  is Cartesian closed, since  [e,1]  is the terminal category in Cat and
[e,∆] : [_,c]→[_,c]×[_,c]  is the diagonal functor. ♦
Propositions 7.4.10 and 7.4.11 allow us to give an explicit definition for the natural
isomorphisms in (1')-(3') above. In particular,
given  σ,τ, γ : e→c0,  and  f: e →c1×c1  such that  DOM ˚ f = ∆0 ˚ σ,  COD ˚ f  = < τ, γ >
<,>'(f) = Πy ˚ <,> ˚ (< <σ, <τ, γ> >,  f >0 ) :  e → c1;
given  σ,τ, γ : e→c0, and  g: e→c1 such that  DOM ˚ g = σ, COD ˚ f  = x0 ˚ < τ, γ >
<,>'-1(g) = Πx ˚ <,>−1˚ (< < σ, <τ,γ> >,  g >0 ) :  e → c1×c1;
given  σ,τ, γ : e→ c0  and  f: e→ c1  such that   DOM ˚ f = x0 ˚ < σ,τ >,  COD ˚ f = γ
Λ'(f) = Πy' ˚ Λ ˚ (< <<σ,τ>, γ >,  f ) : e → c1;
given σ,τ, γ : e → c0  and g: e→ c1 such that  DOM ˚ g =  σ, COD ˚ g = [,]0 ˚ <τ, γ >
Λ'-1(g) = Πx' ˚ Λ−1 ˚ (< <σ,<τ, γ >,  g ) : e → c1.
By exercise 7.4.12,  given  σ,τ : e→c0, the projections associated to  <,>'  are derived from the
internal projections FST and SND by
FSTσ,τ = FST ˚ <σ,τ> :  e→c1
SNDσ,τ = SND ˚ <σ,τ>:  e→c1.
Note that 
DOM ˚ FSTσ,τ =  x0 ˚ <σ,τ>
COD ˚ FSTσ,τ  =  σ
DOM ˚ SNDσ,τ = x0 ˚ <σ,τ>
COD ˚ SNDσ,τ  =  τ.
Analogously, given  σ,τ : e → c0,  the counit  EVALσ,τ  of  Λ'  for the object   [,]0˚<σ,τ>  is
EVALσ,τ = EVAL ˚ <σ,τ>  : e → c1
where EVAL is the internal evaluation map.
Note that
DOM ˚ EVALσ,τ = x0 ˚ <[,]0˚ <σ,τ>, σ >
COD ˚ EVALσ,τ  = τ .
11.6.4 Lemma  Let  c be (internally) Cartesian closed. ∀σ: e'→e,  [σ,c]: [e,c]→[e,c']  preserves
the Cartesian closed structure "on the nose".

11. Second Order Lambda Calculus
265
Proof  We only consider the product; the other cases are similar.
∀τ,γ in [e,c]  [σ,c](τ×γ) = [σ,c]( [e,x](τ,γ) )
= [σ,c]( x0 ˚ <τ,γ> )
by def. of  [e,x]
= x0 ˚ <τ,γ> ˚ σ
= x0 ˚ <τ ˚ σ, γ ˚ σ >
= x0 ˚ < [σ,c](τ), [σ,c](γ) >
= [e,x]( [σ,c](τ), [σ,c](γ) )
= [σ,c](τ) × [σ,c](γ)
by def. of  [e,x]. ♦
11.6.5 Lemma  For every  e, a  objects of E,   [e,c|a|]  ≅  [e×a,c] .
Proof  E is Cartesian closed, thus there are the isomorphisms
Λe,c0: E[e×a, c0] ≅ E[e, c0a]
Λe,c1: E[e×a, c1] ≅ E[e, c1a].
Λe,c0 and Λe,c1 are respectively the functions on objects and on arrows of a functor  ΛΛΛΛ from  [e×a,c]
to [e,c|a|] . Indeed, for every σ:  e×a→c0
Λe,c1(idσ) = Λe,c1(ID ˚ σ)
= Λe,c1(ID ˚ eval ˚ Λe,c0(σ)×id )
= Λe,c1(ID ˚ eval) ˚ Λe,c0(σ)
= IDc|a| ˚ Λe,c0(σ)
= idΛ(σ)
and for every f, g:  e×a→c1
                  Λe,c1(g  o  f) = Λe,c1(COMP ˚ <g,f>)
= Λ(COMP ˚ <eval ˚ Λe,c1(g)×id, eval ˚ Λe,c1(f)×id> )
= Λ(COMP˚ eval×eval ˚ <Λe,c1(g)×id, Λe,c1(f)×id> )
= Λ(COMP˚ eval×eval ˚ p ˚ <Λe,c1(g), Λe,c1(f) >×id)
= Λ(COMP˚eval×eval˚p) ˚ <Λe,c1(g), Λe,c1(f) >
= COMPc|a| ˚ <Λe,c1(g), Λe,c1(f) >
= Λe,c1(g)  o  Λe,c1(f)
Similarly,  Λe,c0-1  and  Λe,c1-1  define the functions on objects and on arrows of  ΛΛΛΛ−1,
respectively. ♦
11.6.6 Lemma  Let K: c→c* be the functor of definition 11.4.3. For every e in E,  ΛΛΛΛ−1 ˚ [e,K] =
G(fst) = [fst,c] : [e,c]→[e,c|a|].
Proof  On objects σ: e→c0
    (Λ−1 ˚ [e,K])(σ)
= Λ−1([e,K](σ) )
= Λ−1(k0 ˚ σ )
by def. of [e,K]
= Λ−1(k0) ˚ σ×id

11. Second Order Lambda Calculus
266
= fst ˚ σ×id 
by def. of k0
= σ ˚ fst
= [fst,c](σ) 
by def. of [fst,c].
On arrows  f: e→c1
     (Λ−1 ˚ [e,K])(f)
= Λ−1([e,K]( f ) )
= Λ−1(k1 ˚ f )
by def. of [e,K]
= Λ−1(k1) ˚ f ×id
= fst ˚ f ×id 
by def. of k1
= f ˚ fst
= [fst,c]( f ) 
by def. of [fst,c]. ♦
11.6.7 Corollary  Let  Ω = c0 . Then for every  e  in  E,  <[fst,c], [e,∀] ˚ ΛΛΛΛ, ∆'˚ Λe,c1> :
[e,c]→[e×Ω,c]  is an adjunction.
Proof  By lemma 11.6.6,  [fst,c] = ΛΛΛΛ−1˚ [e,K] . Then we have the isomorphisms
Λe,c1
∆'
[e×Ω,c][Λe,c0-1([e,K](σ)), τ]    ≅    [e,c*][ [e,K](σ), Λe,c0(τ)]
≅    [e,c][ σ, [e,∀](Λe,c0(τ))]. ♦
Note that, given σ: e→c0 ,τ: e×a→c0 , and  f:  e×a→c1  such that
DOM ˚ f = Λ−1([e,K](σ) ) = σ ˚ fst
COD ˚ f  = τ,
we have  ∆'˚ Λe,c1(f) = ΠY" ˚ ∆ ˚ (<<σ, τ >,  Λ(f) >0 ) :  e→c1, where  ΠY"  is as in the diagram
after definition 11.4.4.
Analogously, given  σ: e→c0, τ: e×a→c0,  and  g:  e→c1  such that
DOM ˚ g =  σ
COD ˚ f  = [e,∀](Λ(τ) ) = ∀0 ˚ Λ(τ)
we have the following:
(∆'˚ Λe,c1)-1(g) =
= Λe,c1-1 (∆'-1(g))
= Λ−1(ΠX" ˚ ∆'−1 ˚ (<<σ, τ >, g >0 ) )
= eval ˚ (ΠX" ˚ ∆'−1 ˚ (<<σ, τ >, g >0  ) )×id:  e×a→c1.
In particular, given  σ : e → c0c0,  the counit  (∆'˚ Λe,c1)-1(id[e,∀](Λ(τ)) )  is
      Projσ,τ =  eval ˚ (ΠX" ˚ ∆'−1 ˚ (< <σ, τ >, ID ˚ ∀0 ˚ Λ(σ) >0 ) )×id:  e×c0 → c1
= eval ˚ (PROJ ˚ <s,t>)×id
=  Λ-1( (PROJ ˚ <s,t>)
where PROJ  is the internal counit.

11. Second Order Lambda Calculus
267
11.6.8 Lemma The isomorphism of the adjunction in corollary 11.6.7 is also natural in  e;  that is,
for every  γ: e→e',  [γ,c] ˚ ( ∆'˚ Λe,c1 ) = ( ∆'˚ Λe,c1) ˚ [γ×id,c].
Proof  For every  γ: e→e',  and  f:  e×a→c1  such that
DOM ˚ f = Λ−1([e,K](σ) ) = σ ˚ fst
COD ˚ f  = τ     ( where σ: e → c0 ,τ: e×a → c0 )
   ([γ,c] ˚ (∆'˚ Λe,c1))(f) = [γ,c] ( ∆'(Λe,c1(f) ) )
= [γ,c] ( Πy" ˚ ∆ ˚  <<σ, τ >,  Λ(f) >0  )
= ΠY" ˚ ∆ ˚  <<σ, τ >,  Λ(f) >0  ˚ γ
= ΠY" ˚ ∆ ˚  <<σ ˚ γ , τ ˚ γ >,  Λ(f)˚ γ  >0
= ΠY" ˚ ∆ ˚  <<σ ˚ γ , τ ˚ γ >,  Λ(f ˚ γ×id) >0
= (∆'˚ Λe,c1) (f ˚ γ×id)
= ((∆'˚ Λe,c1) ([γ×id,c](f) )
= ((∆'˚ Λe,c1) ˚ [γ×id,c]) (f). ♦
11.6.9 Theorem  If  (E,c)  is an internal λ2-model, then  (E, c0, G=[_,c])  is an external λ2-
model. Moreover, for any legal expression  Q  of  λ2,  the internal interpretation of  Q  in ( E,c)
coincides with the external interpretation of  Q  in  (E, c0, G=[_,c]); t hat is, they are the same arrow
in  E.
Proof  Easy, by the previous lemmas. ♦
Now we prove that, using the “internalization” technique of chapter 7, we obtain from any external
model  G:Eop→Cat  an internal model in the topos of presheaves  Eop→Set.  The translation
shows that, essentially, any PL-category is nothing else but an internal category in the category of
presheaves having as object of objects the contravariant hom-functor. Recall (see definition 7.5.1)
that given an E-indexed category  G: Eop→Cat , we can build an internal category  G = (G0, G1,
DOM, COD, COMP, ID)∈Cat(Eop→Set)  in the following way:
for all objects e, e' and arrows  f: e'→e  in E:
- G0: Eop→Set   is the functor defined by
G0(e) = ObG(e)
G0(f) = G(f)ob : ObG(e)→ObG(e')
- G1: Eop→Set   is the functor defined by
G1(e) = MorA(e)
G1(f) = G(f)mor : MorG(e)→MorG(e')
- DOM: G1→G0  is the natural transformation whose components are the domain maps in the
local categories, i.e., for  e∈ObE,  DOMe: MorG(e)→ObG(e)  is defined by
DOMe(h:σ→τ) = σ.
-  COD, ID  and  COMP  are defined analogously, “fiber-wise.”

11. Second Order Lambda Calculus
268
Note in particular that if  (E, c0, G)  is a PL category, then  G0= E[_, Ω].
11.6.10 Proposition  If (E, c0, G) is a PL category, then  G  is an internal Cartesian closed
category.
Proof By proposition 7.5.4. ♦
Before showing that  G  also has an internal dependent product, it is useful to take a closer look at the
structure of the involved exponents in  Eop→Set.
11.6.11 Lemma Let H: Eop→Set be any functor, and let G0 = E[_, Ω]. Then their exponent
HG0: Eop→Set  is given, up to isomorphisms, by the following data:
a. HG0(e) = H(e×Ω)
HG0(f) = H(f×idΩ);
b. eval : HG0× G0 → H
evale(m,f) = H(<ide, f>)(m), for e∈ObE, m∈H(e×Ω), f∈E[e,Ω];
c. Λ : Nat[F×G0, H] ≅ Nat[F, HG0]
Λ(τ)(e)(m) = τe×Ω(F(fst)(m),snd),
where  τ: F×G0→H,  e∈ObE,  m∈F(e),  fst:e×Ω→e,  snd: e×Ω→Ω.
Proof We use the usual definition of exponents in the category of presheaves (see section 3.5) and
prove that the one given above is equivalent up to isomorphisms. Remember that
HF(e) = Nat[E[_,e]×F, H]
HF (f:e'→e)(σ) = σ ˚ E[_,f]×idF
where  E[_,f]  is the natural transformation from  E[_,e']  into  E[_,e]  defined by  E[_,f] = f ˚ _ .
When  F = G0 = E[_, Ω],  we can use Yoneda's lemma and have
HG0(e)  = Nat[E[_,e]×E[_, Ω], H] ≅ Nat [E[_,e×Ω], H] ≅ H(e×Ω).
Let now  f∈E[e',e]:
HG0 (f) ( σ ) = σ ˚ E[_,f]×E[_,idΩ] ≅ σ ˚ E[_,f×idΩ]∈Nat[E[_,e'×Ω], H] ≅ H(e'×Ω)
Hence, the Yoneda isomorphism yields  HG0(f) ≅ H(f×idΩ).
Let us check that the above expressions for eval and Λ satisfy the equations for the exponents. We
have to prove that   eval ˚ Λ(τ)×id = τ  and  Λ(eval ˚ h×id) = h;  let  m∈F(e)  and  f∈c0(e):
evale((Λ(τ)e×ide)(m,f)) =
= evale(τe×Ω (F(fst)(m), snd), f)
by def. of Λ
= H(<ide, f>)( τe×Ω (F(fst)(m), snd) )
by def. of eval
= τe(F(<ide, f>)(F(fst)(m)),  snd ˚ <ide, f> ),
by naturality of τ
= τe(F(fst ˚ <ide, f>)(m), f)
for F functor
= τe(m, f)

11. Second Order Lambda Calculus
269
Λ(eval ˚ h×id)e (m) =
= (evale×Ω ˚ he×Ω×ide×Ω) (F(fst)(m), snd)
by def. of Λ
= evale×Ω( he×Ω(F(fst)(m)), snd))
= H(<ide×Ω, snd>)( he×Ω(F(fst)(m)) )
by def. of eval
= H(<ide×Ω, snd>)(H(fst×idΩ)(he(m)))
by naturality of h
= H( fst×idΩ ˚  <ide×Ω, snd>)( he(m) )
for G functor
= H(<fst,snd>) ( he(m) )
= he(m). ♦
The following lemma exploits the results above in order to give an explicit definition of the constant
internal functor  K: G → G*,  whose right adjoint will give the depended product:
11.6.12 Lemma The internal functor  K = (k0, k1): G→ G*  of definition 11.4.3 is given in
Eop→Set  by
k0(e) = G(fst)obj
k1(e) = G(fst)mor
where  fst:e×Ω→e  in E.
Proof Definition 11.4.3 gives the following for K
k0 = Λ(fst) : G0→G0G0
where  fst: G0×G0→G0  in  Eop→Set
k1 = Λ(fst) : G1→G1G0
where  fst: G1×G0→G1  in  Eop→Set.
Note first that, for  e∈ObE,  the components of the natural transformations fst above behave as the
first projections. Now let  h∈c0(e);  then
     k0(e)(h) = Λ(fst)(e)(h)
= fste×Ω( G0(fst)(h), snd ) by lemma 11.6.12, where fst:e×Ω→e in E
= G0(fst)(h)
= G(fst)(h).
Analogously, for any  g∈c1(e):
     k1(e)(g) = Λ(fst)(e)(g)
= fste×Ω( c1(fst)(g), snd )
= G1(fst)(g)
= G(fst)(g). ♦
11.6.13 Theorem Let  (E, G, Ω)  be an external model; then  G  is an internal model. Moreover,
for any legal expression  Q  of  λ2 ,  the external interpretation of  Q  in  (E, G, Ω)  coincides with the
internal interpretation of  Q  in  G ;  that is, they are the same arrow in E.

11. Second Order Lambda Calculus
270
Proof  G  is Cartesian closed, by proposition 11.6.11. By definition of an external model, the
functor  G(fst)  has a right adjoint  ∀:GΩ→G.  In view of lemma 11.6.12, this is all we need for the
proof.♦
By the previous theorem, and by the particularly simple way the category  G  is defined from the
indexed category  (E, G, Ω),  every external model can be thought of as an internal model. We could
even say that external models are the internal categories in the topos of presheaves that have the
(contravariant) hom-functor as object of objects (and that have the required internal structure, of
course). In this sense, external models are less general than internal ones, since they result from
fixing some data in an internal model. Note that we have also obtained a posteriori a justification of
the apparent simplicity of the external model. This is due to the choice of the well-known topos of
presheaves as ambient category and of the hom-functor as canonical object of objects for the internal
categories in this topos. This approach, though not fully general, allows a great simplification in the
definitions of the involved exponents.
A final comparison between the two approaches is suggetsted by the following remark. Note first
that any internal model in a presheaves topos “is” an indexed category; thus, one can think as well of
a definition of indexed category model in which also the indexing functor is not representable. On the
other hand, if the indexing functor is chosen to be representable, as in the external model, one may
wonder why only the object of objects should enjoy this privileged condition. Note that if we
suppose that also the object of morphisms is representable, i.e., c1 = E[_, Ω1], then by the Yoneda
embedding, we have an internal model  c = ( Ω, Ω1, ...)  in  E.
References  The polymorphic lambda calculus was defined in Girard (1971) in his investigation
of foundational problems in mathematics. Three years later it was reinvented by Reynolds (1974),
who was mainly interested in the type structure of programming languages, testifying the relevance of
this formalism for computer science.  References to protoype programming languages, where
polymorphism is formalized in terms of second order λ-calculi, and a recent application may be found
in Cardelli and Longo (1990).
The model definition based on the internal approach is due to Moggi (1985). Unfortunately, since
at that time there was no known concrete model that could be described “internally,” his idea was
never published, and for some years it remained known only to a restricted number of specialists and
collaborators (see Hyland (1987)). Meanwhile a different and in a sense simpler notion of model
based on indexed categories was proposed in Seely (1987). Both models are based on the idea in
Lawvere (1970) of expressing logical quantifications by means of categorical adjunctions. Further
discussions on categorical models of λ2 may be found in Reynolds (1984), Bainbridge et al. (1987),

11. Second Order Lambda Calculus
271
Hyland and Pitts (1987), Pitts (1987), Longo and Moggi (1988), Scedrov (1988), Reynolds and
Plotkin (1988) and Meseguer (1988), among others.
This chapter is derived largely from Asperti and Martini (1989).

12. Examples of Internal Models
272
Chapter 12
EXAMPLES OF INTERNAL MODELS
In this chapter we present three examples of internal models: provable retractions inside a PER
model, PER inside ωωωω-Set, and PL-Categories inside their Grothendieck completion. The general
categorical investigation of internal models developed in the previous chapter allows a deeper and
unified analysis of the different aspects of these models, which brings, in our view, to in an original
understanding of all of them.
12.1 Provable Retractions
This example continues the analysys of an internal model of retractions developed in chapter 7 (see
examples 7.2.2.2, 7.3.9.1.)
12.1.1 Definition λβ(η)p        is  λβ(η)  plus a fresh constant  p  such that
1.    pp = p
2.    (px)˚  (px) = px      where  s˚ r = λx.s(rx)
          a ˚  a = a
R.     ________
           pa = a
1+2  imply  p ˚ p = p  and, hence,  p is a retraction whose range contains exactly the provable
retractions: range(r) = {a |  λβηp |__  ra = a }.  The model constructed over this simple type-free
theory is the “distilled” (syntactic) version of the various models in the literature based on categories
of retractions: closures, finitary projections, etc. (see the references). It focuses on the general idea of
“types as retractions” and, thus, clarifies the basic constructions in these models where “type is a
type” (i.e.,  p  itself is a retraction).  This extension of type-free λ-calculus is provably non Church-
Rosser, w.r.t. the obvious reduction relation, but it is consistent (see references).  Consider then the
term model of  λβηp:  it is an applicative structure  T = (T, . ),  where  [M]∈T  iff  [M] = { N |
λβηp |_  M = N }  and   [M] . [N] = [MN].  Sometimes, for semplicity, we will make no distinction
between a term and is equivalence class.
Of course,  T  is an extensional λ-model and, thus, by theorem 9.5.10,  TT ≅ T  in  PERT
(remember that by definition   [M] T [N]   iff  λβηp |__  M = N ) .

12. Examples of Internal Models
273
It is easy to show that  this isomorphism is actually an identity, that is  TT = T,  indeed:
           [M] TT [N] iff   ∀[P],∀[Q]   [P] T [Q]   implies   [MP] T [MQ]
iff    ∀P,∀Q    λβηp |_  P = Q   implies   λβηp |_  MP = NQ
iff    λβηp |_  Mx = Nx
iff    λβηp |_  M = N
iff   [M] T [N]
As already pointed out,  PERT  is a Cartesian closed category with all finite limits.
Let  RETT = (R0, R1, dom, cod, comp, id)∈Cat(PERT)  be the internal category of retractions
on T.  As we proved in the example 7.3.9.1,  RETT  is Cartesian closed; we want to prove that
RETT  yields an (internal) λ2-model.
We start by giving the explicit definition of  R0  and  R1.  Remember that in  PERT  the equalizer
of a pair of morphisms   f,g: P → Q  is  (E, h: E→P)  where  aEb   iff   ( aPb   and  f(a)Qg(b) )  and
h  is the injection from  E  to  P.  Note also that  dom(E) = dom(P) ∩ {a | f(a) Q g(a)},  and on this
domain E coincides with P.  Then it is easy to verify that   [M] R0 [N]   iff   ( [M] T [N]  and  λβηp
|_  M ˚ M = M.)  In other words  R0  coincides with  T  but is restricted to those terms which are
provable retractions.
The domain of  R1  are (λβηp-equivalence classes of) triples  <M, F, G>,  where  < , >  is the
standard encoding of tuples in λ-calculus,  F  and  G  are provable retractions, and  M  is a morphism
from  F  to  G,  that is,  λβηp |__ G ˚ M ˚ F = M.  Formally:
dom(R1) = { [<M, F, G>]  |  F ˚ F =λβηp F ;   G ˚ G =λβηp G ;   G ˚ M ˚ F =λβηp M },
[<M, F, G>] R1 [<M', F', G'>]   iff   [<M, F, G>] T [<M', F', G'>]
Note moreover that   [<M, F, G>] T [<M', F', G'>]   iff  M =λβηp M', F =λβηp F', G =λβηp G'.
Let  RETT* = (R0R0, R1R0, dom*, cod*, comp*, id*)  be as in definition 11.4.2. We must
prove that the costant functor  K: RETT → RETT *  has a right adjoint ∀ = (∀0: R0R0→R0, ∀1:
R1R0→R1).  ∀0  is the function realized by   λFλzt.F(pt)(z(pt)).  Thus, we need to show that
1. if  F  is in the domain of R0R0  then ∀0(F) is in the domain of R0 ;
2. ∀0 takes elements that are equivalent in  R0R0  to elements  that are equivalent in  R0.
As for (1) we have
             ∀0F ˚ ∀0F = λx( λzt.F(pt)(z(pt)) )( λt.F(pt)(x(pt)) )
= λx( λt.F(pt)( λt.F(pt)(x(pt)) (pt)) )
= λx( λt.F(pt)( F(pt)(x(pt))) )
= λxλt. F(pt)(x(pt))           because  F(pt)  is a retraction by hypothesis
= ∀0F
(2) is evident.
An element in  R1R0  is a triple  < T, F, G >,  where  F  and  G  are in the domain of  R0R0,  T
is in the domain of  T R0 ,  and for every retraction  M,  one has  TM = GM ˚ TM ˚ FM.

12. Examples of Internal Models
274
∀1 is the function that takes (an equivalence class in  R1R0  of) a triple  < T, F, G >  in (the
equivalence class in  R1  of) the triple  < λtλm .T(pm)(∀0Ft ),∀0(F), ∀0(G) >.
Note that  λtλm .T(pm)(∀0Ft ))  is a morphism from the retraction  ∀0F  to the retraction  ∀0G;
indeed,
∀0G ˚  λtλm .T(pm)(∀0Ft ) ˚ ∀0F =
= λz.∀0G(λm .T(pm)(∀0Fz) )
= λz. (λxλt.G(pt)(x(pt)) ) (λm .T(pm)(∀0Fz) )
= λz. λt.G(pt)( (λm .T(pm)(∀0Fz) ) (pt))
= λz. λt.G(pt)( (T(pt)(∀0Fz)  )
= λz. λt.T(pt)(∀0Fz)             because  G(pt) ˚ T(pt) = T(pt)   by hypothesis
It should be clear that  ∀1  is indeed a morphism in  PERT  its realizer is simply obtained by
abstraction on  < T, F, G >.
Given a variable type  G  in  R0R0  and a type  N  in  R0,  the projection  projG(N)  from  ∀0G
to  G(N)  is realized by the term  λx.xN.  Indeed, if  S  has type  ∀0G  that is,  S = (∀0G)S,  then
SN = ∀0GSN = G(N)(SN),  and thus  SN  has type  G(N).
We define now the isomorphism  ∆  of the adjunction.
Let   < T, λx.M, G >  be an element in  R1R0,  where  M  is a retraction and  λx.M = K0(M).
Define then  ∆M,G( < T, λx.M, G > ) = < λtλm .T(pm)t,  M,  ∀0G >.
Conversely, given  < S, M, ∀0(G) >  in  R1,  define ∆M,G-1( < S, M, ∀0(G) > ) = <
λmλt.Stm, λx.M, G >.  Note that  λm.λt.Stm  = λm.(λx.xm ˚ S)  = λm.( projG(m) ˚ S ).  Thus,
for every retraction  N,  one has
G(N) ˚ λt.StN ˚ M  =  projG(N) ˚ S ˚ M  =  G(N) ˚ projG(N) ˚ S ˚ M  =  λt.StN .
Moreover,
∆M,G-1( ∆M,G( < T, λx.M, G > ) ) =
= ∆M,G-1( < λtλm .T(pm)t , M, ∀0(G) > )
= <  λmλt.T(pm)t, λx.M, G >
= <  λm.T(pm), λx.M, G >
and clearly  T  and  λm.T(pm)  are equivalent in T R0.
As for the converse, note first that if  S = ∀0(G) ˚ S,  then
St(pm) = ∀0(G)(St)(pm) = (λm.G(pm)(St(pm)))(pm) = G(pm)(St(pm)) = Stm
Thus:
∆M,G( ∆M,G-1( < S, M, ∀0(G) > ) ) =
= ∆M,G( <  λmλt.Stm, λx.M, G > )
= < λtλm .St(pm) , M, ∀0G >
= < λtλm .Stm , M, ∀0G >
= < S, M, ∀0G >

12. Examples of Internal Models
275
Define then
∆ ( < M,G, < T, λx.M, G > > ) = < M, G, < λtλm .T(pm)t , M, ∀0G > >
and
∆-1( < M,G, < S, M, ∀0G > > ) = <M,G, < λmλt.Stm, λx.M, G > >.
12.1.2 Remark  It is possible to give an elegant categorical characterisation of the models of
λβ(η)p.  Let  A  be a reflexive object  ( AA ≅ A )  in some category  C,  and let  RETA = (R0, R1,
dom, cod, comp, id)  be the internal category of retractions on   A  in  PERA. Let  ξ: R0→AA  be as
usual the equalizer of the identity and  λf. f ˚ f.   All we need to turn  RETA  in a model for  λβ(η)p
is that there exist  p: AA→R0  such that  R0  is a retract of  AA  via  (ξ,p).  Then, in a sense, since
R0  represents all the retractions on  A,  we can say that the collection of objects of  RETA  is itself an
object of  RETA:  more formally, that  RETA  is internal to  RETA  w.r.t.  PERA.  We have thus the
following facts:
1.
(AA < A  in  a CCC  C   and   RETA  internal to  RETA  with respect to  PERA )
imply     A  |=  λβp .
2.    A  |=  λβp   implies
( AA < A  in  PERA  and   RETA  internal to  RETA  w.r.t.  PERA ).
The reader should complete the details for exercise.
12.2 PER inside ωωωω-Set
This example continues our presentation of PER an an internal category M of ωωωω-Set (see examples
7.2.7 and 7.3.9.2, where it is shown that the construction gives also an internal model.)
Let  M*  be defined as  c*  in 11.4.2.  We next define an internal right adjoint to the constant
functor  K : M → M*, that by def. 11.4.4  will complete the construction of a model for  λ2.
Again, we shall take advantage of the wise blend of set-theory and computability on which ωωωω-Set
is based, in order to avoid the most formal details.
The following lemma motivates the definition of  ∀  below.
12.2.2 Lemma  If  <τ,F,G>∈ωωωω-Set[Mo,M1]   then   ∃n  ∀A∈Mo  τ(A) = {n}F(A)→G(A) .
Proof. Suppose that  m |__ <τ,F,G>.  Since  0 |__ A  for any  A∈PER ,  then take  n = m.0  and
observe that  n |__ <τ(Α),F(A),G(A)>.  Thus  τ(A) = {n}F(A)→G(A). ♦
As for the definition of  ∀0,  observe that the intersection of any collection  {Ai}i∈I  of objects in
PER is still in PER, by viewing them as sets of pairs (of numbers).  That is, set
n (∩ i∈I Ai) m     iff     ∀i∈I  (n Ai m ).

12. Examples of Internal Models
276
12.2.3 Definition
1. ∀o : [Mo → Mo] → Mo, is given by  ∀o(F) = ∩A∈MoF(A),
2. ∀1: [Mo → M1] → M1  is defined as follows.  If  m |_ <τ,F,G>∈ωωωω-Set[Mo,M1], set
∀1(<τ,F,G>) = <{m.0}∀o(F)→∀ο(G) ,∀o(F),∀o(G)> .
12.2.4 Proposition.  ∀  in definition 12.2.3 is well defined.  In particular, ∀1  is realized by any
number  p  such that , for all  m ,  p.m = m.0 .
Proof.  By definition, if  F : Mo→Mo,  then  ∀o(F)  is in Mo.  ∀o  is realized by (any index of)
any total recursive function.  By lemma 12.2.2, ∀1  is well defined as its definition does not depend
on the choice of the realizer  m  for  <F,τ,G>.  Therefore we only need to show that  ∀1  is realized
by  p.  Namely, that if
1.  m1,m2 |__ <τ,F,G>
2.  n1 ∀o(F) n2
3.  A∈Mo
then one has  (p.m1.n1) G(A) (p.m2.n2).  Indeed,
4.  p.m1 = m1.0 (F(A)→G(A)) m2.0 = p.m2 ,   by (1)
5.  n1 F(A) n2  ,  by (2) and (3),
and thus   (p.m1.n1) G(A) (p.m2.n2)  by (4), (5) and the definition of  (F(A)→G(A))∈Mo. ♦
12.2.5 Remark.  It should be clear that lemma 12.2.2 is a very simple but crucial lemma.  Note
first that the morphisms in  ωωωω-Set[Mo,M1]  are described as triples,  <τ,F,G>,  where  τ: Mo →
∪A∈MoQ(F(A)→G(A))  is such that  τ(A)∈Q(F(A)→G(A))  and  F, G: Mo → Mo  give the source
and target of  τ(A).  This is a sound description, since  M* = ( [Mo→Mo], [M1→M1],...)  may be
viewed as the internal category of functors from the discrete category, whose object of objects is Mo,
to M.  Thus  [Mo→M1]  or  ωωωω-Set[Mo,M1]  are internal natural transformations. By lemma
12.2.2, now, there is a uniform  n  which realizes  τ(A)  for all  A.  In a sense these internal natural
transformations are “almost” constant maps and only depend on the source and target objects.
We need now to prove that there exists an internal natural isomorphism  ∆, which gives the
adjunction between  ∀  and  K.  We can use the simplicity of the intended universe and perform the
construction directly.  As in the proof of the internal Cartesian closure of M, the point is to show that
the functional dependencies, usually implicit in the external world (or given by “indexes”: recall  a,b
|_  Λa,b),  can be turned into internal constructions.  Once more, this will be straightforward to check
within ωωωω-Set, as the realizers for the natural isomorphism and its inverse will not depend on their
“indexes.”
Let  K,  with components  ko  and  k1,  be the internal constant functor in definition 11.4.3.

12. Examples of Internal Models
277
12.2.6 Definition.  For   m |__ < τ,ko(B),G>∈ωωωω-Set[Mo,M1] ,  set
∆B,G (< τ,ko(B),G>) = < {m.0}Β→∀ο(G) ,Β,∀o(G)> ∈M1 .
and
∆−1B,G ( <{m}Β→∀ο(G) ,Β,∀o(G)> )
= < λX∈Mo.{m}Β→G(X) ,ko(B),G>∈ωωωω-Set[Mo,M1].
12.2.7 Proposition. ∆B,G  and  ∆−1B,G  in 12.2.6 are well defined, for all  B∈Mo. and  G:
Mo→Mo  (= [Mo → Mo]).  Moreover, they are realized by  p  and  k  (respectively), such that
p.m = m.0  and  k.m.n = m  .
Proof:  By lemma 12.2.2,  ∆B,G  does not depend on the choice of the particular realizer  m.  As for
∆−1B,G,  note that, if  m(Β→∀ο(G))m,  then  ∀n,q ( nBq ⇒ m.n (∩A∈MoG(A)) n.q), by
definition of  ∀ο,  and hence   m.n G(A) n.q,  for all  A∈Mo.  Therefore,  m (Β → G(A)) m  for all
A∈Mo  and  ∆−1B,G  too is well defined.  By definition, they are uniformly realized by  p  and  k
as above.  In particular,  p  and  k  compute  ∆B,G  and  ∆−1B,G  for all  B  and  G. ♦
12.3 PL-Categories Inside Their Groethendiek Completion
This example show another way for obtaining an internal model from a PL-category, different from
the internalization process of chapter 11.
12.3.1 Definition. Given any E-indexed category  G, define the category ∫∫∫∫G, the Grothendieck
completion of G, having as objects the pairs  (e, σ)  with  e∈ObjE  and  σ∈ObjG(e)  and as
morphisms pairs  (α, f)  such that:
(α, f)∈∫G[(e, σ), (e', τ)]    iff    α∈E[e,e']  and  f∈G(e)[σ,G(α)(τ)].
The identity of  (e, σ)  is  (ide, idσ);  the composition of  (α, f)∈∫∫∫∫G[(e,σ),(e',τ)]  and  (β,
g)∈∫∫∫∫G[(e',τ), (d,ρ)]  is  (β, g) ˚ (α, f) = ( β ˚ α, G(α)(g) ˚ f).
Let  (E, G, Ω)  be an external model (that is an indexed category with the additional requirements
on functor  G  in 12.2.1);  then the Grothendieck completion ∫∫∫∫G assumes a particularly simple form
Objects:
(e, σ)∈∫∫∫∫G  iff  σ∈ObjG(e) = E[e, Ω]
(hence we can identify objects of  ∫G  with arrows  σ: e→Ω)
Morphisms: 
(α,f)∈∫∫∫∫G[σ:e→Ω,τ:e'→Ω]  iff
α∈E[e,e']  and  f∈G(e)[σ,G(α)(τ)] = G(e)[σ,τ ˚ α].
The point is that  ∫∫∫∫G contains an internal category which, in a sense, internalizes the external model
(E, G, Ω).

12. Examples of Internal Models
278
Warning We are here forcing our terminology, since the category ∫∫∫∫G does not need to have all finite
limits, at least not in general, and hence we could not speak of “internal categories in ∫∫∫∫G.” However,
all the needed pullback diagrams exist in ∫∫∫∫G, as pointed out below.
The internal category  Γ = (c0, c1, DOM, COD, COMP ,ID)∈Cat(∫∫∫∫G)  is defined as follows:
c0 = tG(Ω) : Ω→Ω
the terminal object in G(Ω)
c1 = [,]0 : Ω×Ω→Ω
[,]0  is given in lemma 11.2.3
DOM = (fst, !)
! is the unique arrow from  c1 to  c0˚fst  in  G(Ω×Ω)
COD = (snd, !)
ID = (<idΩ, idΩ>, ΛG(Ω)(snd))
snd∈G(Ω)[tG(Ω)×idΩ, idΩ],  hence
Λ(snd)∈ G(Ω)[tG(Ω), idΩ→idΩ], where idΩ→idΩ 
The situation for COMP is more delicate, since ∫∫∫∫G does not have all finite limits. However, the
pullback of  DOM: c1→c0,  COD: c1→c0  does exist, and it is given by
c2 = (p2→p3)×(p1→p2),
where product and exponents are in the fiber  G(Ω×Ω×Ω)  and pi∈E[Ω×Ω×Ω, Ω];  the pullback
projections  ∏1, ∏2 : c2→c1  are
∏1 = (<p2,p3>, id)
∏2 = (<p1,p2>, id).
In order to define COMP, remember that in any CCC, given three objects  A, B, C,  there exists a
morphism  cmp∈Hom[CB×BA, CA]  that internalizes the composition, namely
cmp = Λ(eval ˚ id×eval ˚ p)
for  p: (CB×BA)×A→CB×(BA×A)  an isomorphism.
Define then
COMP = (<p1,p3>, cmp)
for  cmp∈G(Ω×Ω×Ω)[ c2, p1→p3]
(recall that, in  G(Ω×Ω×Ω),  p1→p3 = [,]0 ˚ <p1,p3>).
The verification that these data define an internal category is straightforward.
We now prove that if  (E, G, Ω)  is an external model, than ∫∫∫∫G is Cartesian closed.
The terminal object is given by  tG(t),  the terminal object of the local category G(t) (for t terminal in
E).  As for products, they can be defined by using the Cartesian structure of the local categories:
(f:e→Ω)×∫G(g:d→Ω) := x0 ˚ f×Eg,  where  x0: Ω×Ω→Ω  is the arrow obtained in lemma 11.2.3;
hence  f ×∫G g = (f ˚ fst)×G(e×d)(g ˚ snd).  Projections are obtained as follows.  We need  FST:
c0×c0→c1,  where  FST = (α, f)  for some  α:Ω×Ω→Ω×Ω  and  f∈G(Ω×Ω)[c0×c0, c1˚ α].  As for
α, which intuitively takes a pair of objects  (σ, τ)  to  (σ×τ, σ),  we can take  α = <x0, fst>:
Ω×Ω→Ω×Ω.
In order to define f∈G(Ω×Ω)[ tG(Ω×Ω), x0→fst], we can use again the Cartesian closed
structure of  G(Ω×Ω)  and the fact that, by lemma 11.2.3, one has
x0 = x0 ° id = x0 ° <fst,snd> =  fst ×G(Ω×Ω) snd.
Define then  f = Λ(fst)  where  fst∈G(Ω×Ω)[fst×snd, fst].  SND is defined analogously.

12. Examples of Internal Models
279
It remains to give the pairing isomorphism  <,>;  note first of all that the required pullbacks (see
definition 7.3.6, and also appendix A at the end of chapter 7) are given by the following data:
X = [,]0×∫G[,]0 ˚  <id×fst, id×snd> : Ω×(Ω×Ω)→Ω
∏X : X→c1×c1 (that is  X → [,]0 ×∫G [,]0)
∏X = ( <id×fst, id×snd>, id )
ρ : X → c0×c0×c0 (that is  X → tG(Ω×Ω×Ω))
ρ = (id, !)
Y = [,]0 ˚ id×x0 :  Ω×(Ω×Ω)→Ω
∏Y : Y→c1  (that is Y → [,]0 )
∏Y = ( id×x0, id)
ρ' : Y → tG(Ω×Ω×Ω)
ρ' = (id, !)
Observe now that, as we are dealing with objects of  G(Ω×(Ω×Ω)),  by interpreting all products and
exponentials locally in  G(Ω×(Ω×Ω)) ),  one has
X = (fst → fst ˚ snd)×(fst → snd ˚ snd)
Y = fst → ((fst ˚ snd)×(snd ˚ snd))
and hence  X ≅ Y,  since  G(Ω×(Ω×Ω))  is Cartesian closed.
The isomorphism  <,>: X→Y  (in ∫∫∫∫G)  is then given by  <,> = (id,f),  where f is the
isomorphism between  X  and  Y  in  G(Ω×(Ω×Ω)).  The required equations are now easily verified.
Let us now come to the exponents   ⇒0 = ( [,]0 , !) : c0×c0→c0,  where  [,]0  is given again by
lemma 11.2.3.
EVAL :  c0×c0→c1  is given by a pair:  EVAL = (α,f),  for  α:Ω×Ω→Ω×Ω  and
f∈G(Ω×Ω)[c0×c0, c1˚ α].  As for α, whose intuitive content is to send a pair of objects  (σ, τ)  into
(τσ×σ, τ),  we can set   α = <x0 ˚ < [,]0, fst>, snd>.
We need now  f∈G(Ω×Ω)[tG(Ω×Ω),  [,]0 ˚ <×0 ˚ < [,]0, fst>, snd>];  observe that
[,]0 ˚ <x0 ˚ < [,]0, fst>, snd> =
= (x0 ˚ < [,]0, fst>) → snd
in G(Ω×Ω)
= ([,]0 × fst) → snd
= ((fst→snd) × fst) → snd.
Take then  evalfst,snd∈G(Ω×Ω)[(fst→snd) × fst, snd]  and set
f = Λ(evalfst,snd)∈G(Ω×Ω)[tG(Ω×Ω), ((fst→snd) × fst) → snd].
Before giving the isomorphism  Λ,  we need to express the pullback diagrams of theorem 7.3.7 (see
also appendix A).  They can be instantiated as

12. Examples of Internal Models
280
where:
X' = [,]0 ˚ (x0× idΩ) 
Y' = [,]0 ˚ ( idΩ × [,]0 )
∏X' = ( x0× idΩ, id) 
∏Y' =  ( idΩ×[,]0, id)
σ = (idΩ×Ω×Ω, !) 
σ' =  (idΩ×Ω×Ω, !)
As before, observe that
X' = fst×(fst ˚ snd)→(snd˚ snd)
Y' = fst → ((fst ˚ snd)→(snd˚ snd)).
Therefore  X' ≅ Y',  by the Cartesian closure of  G(Ω×(Ω×Ω)) .
The internal Cartesian closed category   Γ∈Cat(∫∫∫∫G)  is actually an internal model when  (E, G, Ω)  is
an external one. In order to define the required adjunction, we need first to show that we can indeed
construct the internal category  Γ*;  that is, the exponents  c0c0  and  c1c0  exist in ∫∫∫∫G (as for the
limits, not all the exponents exist in ∫∫∫∫G).
12.3.2 Lemma
i.  For any object  e  of  E,  c0tG(e)  exists in ∫∫∫∫G and it is given by  tG(Ωe).
ii.For any object  e  of  E,  c1tG(e)  exists in ∫∫∫∫G and it is given by  ∀([,]0  ˚ eval).
Proof Set  σ = tG(e).
i. Note first that in ∫∫∫∫G, for any  e'  and  τ,  every arrow  (β,g):τ→tG(e')  has  g = !.  We must then
show that, for  c0σ = tG(Ωe),  the following diagram commutes, for any object  τ  and arrow  (α,!):
which is immediate.

12. Examples of Internal Models
281
ii. Let τ: e'→Ω be any object of ∫∫∫∫G; we are looking for the unique  Λ(α, f)  such that the following
diagram commutes:
Since  α: e'×e→Ω×Ω,  if we set  Λ(α,f) = (α,f),  a natural choice for  α   is  α = Λ(α):e'→(Ω×Ω)e.
Moreover, for  (α, f):τ×σ→[,]0,  we have the following:
f∈G(e'×e)[τ×σ, [,]0˚α ] ≅
≅ G(e'×e)[τ˚ fst, [,]0˚ α]
by  σ = tG(e)  and the definition of product in ∫∫∫∫G
≅ G(e')[τ˚ fst, ∀([,]0˚ α)]
via the isomorphism  ∆  of the adjuction giving the
external model
≅ G(e')[τ˚ fst, ∀([,]0˚ eval) ˚ Λ(α)] by naturality of  ∀.
We can then define
c1σ = ∀([,]0  ˚ eval) : (Ω×Ω)e→Ω
and take  f = ∆(f);  the previous diagram then commutes for  eval = (eval, projc0σ).
We can eventually give the data for the adjunction
∀0 : c0c0 → c0
∀0 = (∀0 : ΩΩ → Ω, !).
As for  PROJ = (α, f):  c0c0→c1c0,  we need  α : ΩΩ→(Ω×Ω)Ω  and  f∈G(ΩΩ)[c0c0, c1c0˚ α].
For  eval : ΩΩ×Ω→Ω  and  fst: ΩΩ×Ω→ΩΩ,  set α = Λ(<∀0 ˚ fst, eval>).  As for  f,  note first that
   c0c0 = tG(ΩΩ)
and
     c1c0˚ α = ∀([,]0  ˚ eval) ˚ Λ(<∀0 ˚ fst, eval>)
= ∀([,]0  ˚ <∀0 ˚ fst, eval>)
by naturality of ∀
= ∀((∀0 ˚ fst) → eval)
by the usual isomorphims.
We are then looking for  f∈G(ΩΩ)[tG(ΩΩ), ∀((∀0 ˚ fst) → eval) ];  as we did in the proof of the
previous lemma, let us look for an arrow  h∈G(ΩΩ×Ω)[tG(ΩΩ)˚ fst, (∀0 ˚ fst) → eval].  Then the  f
we need will then be  ∆(h).  Observe now that  projeval∈G(ΩΩ×Ω)[∀0 ˚ fst, eval];  this immediately
gives the required  h  in the following diagram:

12. Examples of Internal Models
282
In conclusion, the Grothendieck completion provides yet another example of the general categorical
construction of model in chapter 11.  Moreover, it gives further insight into the external versus
internal approach by giving a setting where the external models may be viewed as internal
constructions.
References The examples in this chapter may be found, in part, in the many papers mentioned at the
end of the previous chapter.  Since Moggi's hint for the small completeness of the PER construction,
in particular, these models have been thoroughly explored by many authors.  The three sections above
develop the ideas in Amadio and Longo (1986) and in Longo and Moggi (1988), and follow Asperti
and Martini (1989), respectively.  By this, the first two sections extend to higher order the
understanding of simple types as partial equivalence relations and retractions in Scott (1976).  The
consistency of λβηp is shown in Berardi (1988).

Bibliography
283
BIBLIOGRAPHY
Adachi T. [1983] “A categorical characterization of lambda-calculus models” Dept. of Info. Sci.
Tokyo Inst. Tech., n. C-49.
Amadio R., Bruce K., Longo G. [1986] “The finitary projections model and the solution of higher
order domain equations” IEEE Conference on Logic in Computer Science, LICS'86
Boston.
Amadio R., Longo G. [1986] “Type free compiling of parametric types”, IFIP Conference, in
Formal Description  of Programming Concepts-III, M. Wirsing (ed.), Ebberup (DK),
North-Holland, 1987.
Arbib M., Manes E. [1975] Arrows Structures and functors: The Categorical Imperative,
Academic Press, London.
Arbib M., Manes E. [1975a] “Adjoint Machines, State-Behavior Machines and Duality” J. Pure
and Applied Algebra, 6, (313-344).
Asperti A.  [1988] “Stability and Computability in Coherent domains” Info&Comp. (to appear).
Asperti A., Longo G. [1987] “Categories of partial morphism and the relation between type-
structures” Semester on Theory of Computation, Banach Center Publications, vol. 21,
Warsaw.
Asperti A., Martini S. [1989] “Categorical models of polimorphism” Note interne, Dip. di
Informatica, Università di Pisa.
Bainbridge E., Freyd P., Scedrov A., Scott P.J. [1990] “Functorial Polymorphism” Theoretical
Comp. Sci. 70, 35-64.
Barendregt H.P., Koymans K. [1980] Comparing some classes of lambda calculus
models, in Hindley and Seldin, (287-302).
Barendregt H. [1984] The Lambda Calculus; its syntax and semantics, Revised and
expanded edition, North Holland.
Barr M. [1979] *-Autonomous Categories, Springer Lecture Notes in Mathematics 752, Berlin.
Barr M. [1990] “*-Autonomous Categories and Linear Logic”, Mathematical Structures in
Computer Science, to appear.
Barr M., Wells C.F. [1985] “Toposes and Theories” Gundlehren der Mathematiscgen
Wissenschaffen, 273, Springer-Verlag, New York.

Bibliography
284
Beeson M.  [1980] Foundations of Constructive Mathematics, Springer -Verlag.
Bénabou J. [1985] “Fibered Categories and the Foundations of Naive Category Theory” J.
Symbolic Logic 50, 1, (1o-37).
Berger U.  [1986] Berechenbarkeit in Hoheren Typen Nach Einem Ansatz Von Ju.L.
Ersov, dissertation Munchen.
Berry G. [1978]  Stable models of typed λλλλ-calculi. Proc. 5th ICALP. LNCS 62, (72-89).
Berry G. [1979] “Some Syntactic and categorical Constructions of Lambda Calculus Models”
INRIA, Valbonne.
Berry G.  [1981] “On the definition of  lambda-calculus models” Proc. Int. Coll. on  Formalization
of Programming Concepts, LNCS 107, (218-230).
Bruce K., Di Cosmo R., Longo G. [1990] “Provable Isomorphisms of Types” Symposium on
Symbolic Computation, E.T.H., Zuerich (CH), March 1990; to appear.
Bruce K., Longo G.  [1988] “Modest models for inheritance and explicit polymorphism” CMU
report CS-88-126,  IEEE Conference on Logic in Computer Science, LICS '88,
Edinburgh, (Info.&Comp., to appear).
Carboni A., Freyd P., Scedrov A. [1988] “A categorical approach to realizability and polymorphic
types” 3rd ACM Symp. on Math. Found of Language Semantics, New Orleans, Main
(ed), Springer LNCS 298, (23-42).
Cartmell J. [1978] “Generalised Algebraic Theories and Contextual Categories”, PhD Thesis,
Oxford.
Coquand T., Gunter C., Winskel G. [1989] “Domain theoretic models of polymorphism”
Information and Computation 81,123--167.
Cousineau G., Curien P.L., Mauny M. [1985] “The categorical Abstract machine” in  Functional
Programming Languages and Computer Architecture, J.P. Jouannaud (ed.), Lecture
Notes in Computer Science 201, (Springer, Berlin), (130-139).
Curien P.L. [1986] Categorical Combinators and Functional Programming, Pitman.
Curien P.L., Obtulowicz A. [1988] “Partiality, Cartesian Closedness and Toposes”, Info&Comp.,
Vol. 80, (50-95).
Degano P., Meseguer J., Montanari U. [1989] “Axiomating Net Computation and Processes”, IEEE
Conference on Logic in Computer Science, LICS'89.
Dezani M.  [1976] “Characterization of  normal forms possessing an inverse in the λβη-calculus”,
Theor. Comp. Sci., 2 (323-337).

Bibliography
285
Di Paola A., Heller A.  [1984] “Dominical Categories”, City Univ. New York.
Ehrhard T. [1988] “A Categorical Semantics of Constructions” IEEE Conference on Logic in
Computer Science, LICS'88, Edinburgh.
Ehrig H, Kiermeier K.D., Kreowski H.J., Kuehnel W.  [1974] “Universal Theory of Automata: A
Categorical Approach” B.G. Teubner, Stuttgard.
Eilenberg S., Moore J.C. [1965] “Adjoint Functors and Triples”, Illinois J. Math. 9, (381-398).
Eilenberg S., Kelly M.G. [1966] “Closed Categories” Proc. Conf. Categorical Algebra, in S.
Eilemberg et al. (eds.) (La Jolla 1965). Springer-Verlag.
Elgot C.C. [1971] “Algebraic Theories and programs Schemes”, Symp. on the Semantics of
Algorithmic Languages,  in Engeler (ed.) LNM 188, (71-88).
Ershov, Ju.L. [1973]  “Theorie der Numerierungen I”, Zeischr. f. math. Logik un Grundl. d.
math., Bd. 19.
Ershov, Ju.L. [1975]  “Theorie der Numerierungen II”, Zeischr. f. math. Logik un Grundl.
d. math., Bd. 21.
Ershov, Ju. [1976] “Hereditarily Effective Operations”, Algebra i Logika, Vol. 15.
Feferman S. [1969] “Set-Theoretical Foundations of Category Theory”, Reports of the Mid-
West Category Seminar III, in S. Mac Lane (ed.), LNM 106, (201-247).
Fourman M.P., Scott D.S. [1979] “Sheaves and Logic”, Applications of Sheaves, Springer, LNM
753, (302-401).
Freyd P. [1964] Abelian Categories: An Introduction to the Theory of Functors, Harper
& Row, New York.
Freyd P., Girard J.Y., Scedrov A., Scott P.J. [1988] “Semantic Parametricity in Polymorphic
Lambda-Calculus” IEEE Conference on Logic in Computer Science, LICS'88,
Edinburgh.
Germano G., Mazzanti S. [1987] “Loose Diagrams, Semigroupoids, Categories, Groupoids and
Iteration”, 1st Workshop on Computer Science Logic, E. Börger et al. (eds.), LNCS
273.
Giannini P., Longo G. [1984] “Effectively given domains and lambda calculus sematics”,
Information and Control, 62, 1 (36-63).
Gierz G., Hofmann K.H., Keimel K., Lawson J.D., Mislove M., Scott D.S. [1980] A
compendium of continuous lattices, Springer-Verlag.

Bibliography
286
Girard J.Y. [1971] “Une extension de l'interpretation de Gödel a l'analyse, et son application a
l'elimination des coupures dans l'analyse et la theorie des types”. In 2nd Scandinavian Logic
Symposium, J.E. Festand (ed.), North-Holland, Amsterdam, (63-92).
Girard J.Y. [1972] “Interpretation fonctionelle et elimination des coupure dans l'arithmetic d'odre
superieur”, These de Doctorat d'Etat, paris.
Girard J.Y.  [1986] “The system F of variable types, fifteen years later”, Theor. Comp. Sci., 45,
(159-192).
Girard J.Y.  [1987] “Linear Logic” Theor. Comp. Sci., 50, (1-102).
Girard J.Y., Lafont Y.  [1987] “Linear Logic and Lazy Computation” Tapsoft '87, Pisa, LNCS
250, Springer Verlag.
Goguen J.A., Thatcher J.W., Wagner E.G.,  Wright J.B.  [1973] “A junction between computer
science and category theory: I, Basic definitions and concepts” Technical Report RC-4526,
IBM Research, September, (part 1).
Goguen J.A., Thatcher J.W., Wagner E.G.,  Wright J.B. [1976] “A junction between computer
science and category theory: II, Basic definitions and concepts” Technical Report RC-5908,
IBM Research, March, (part 2).
Goguen J.A., Thatcher J.W., Wagner E.G., Wright J.B.  [1975] “An introduction to Categories,
Algebraic Theories and Algebras” Technical Report RC-5369, IBM Research, April.
Yorktown Heights.
Goguen J.A., Thatcher J.W., Wagner E.G., Wright J.B. [1977] “Initial Algebra Semantics and
Continuous Algebras” J. ACM, 24(1), (68-95).
Goguen J.A., Ginali S.  [1978] “A Categorical Approach to General Systems Theory”. Applied
General Systems Research (257-270) in G. Klir (ed.), Plenum, New York.
Goguen J.A., Thatcher J.W., Wagner E.G. [1978] “An Initial Algebra Approach to the
Specification, Correctness and Implementation of Abstract data Types”. Current Trends in
Programming Methodology, in R. Yeth (ed.), Prentice Hall, NJ (80-149).
Goguen J.A., Burstall R.M., [1984] “Some Foundamental Tools for the Semantics of Computation,
Part 1: Comma categories, Colimits, Signatures and Theories”. Theor. Comp. Sci., 31, (175-
209).
Goldblatt R. [1979] Topoi-The Categorial Analysis of Logic, North Holland, Amsterdam.
Gunter C. [1985] “Profinite solutions for recursive Domain Equations”, Ph.D. Thesis, Comp. Sci.
Dept., C.M.U..
Hayashi S. [1985] “Adjunction of semifunctors: categorical structures in non-extensional lambda-
calculus”, Theor. Comp. Sci., 4.

Bibliography
287
Herrlich H., Strecker G.E. [1973]  Category Theory, Allyn and Bacon.
Hindley R., Longo G.  [1980] “Lambda-calculus models and extensionally”, Zeit. Math. Logik
Grund. Math. n.2, Vol. 26 (289-310).
Hindley R., Seldin J., (ed.) [1980] To H.B. Curry: Essays in Combinatory Logic,
Lambda calculus and formalism, Academic Press.
Hindley R., Seldin J.  [1986] Introduction to Combinators and Lambda-Calculus, London
Mathematical Society.
Hyland J.M.E. [1977] “Filter Space and Continuous Functionals” Annals of Mathematical
Logic 16, (101-143).
Hyland J.M.E. [1982] “The effective Topos”, in  The Brouwer Symposium, (Troelstra, Van
Dalen eds.), North Holland.
Hyland J.M.E. [1987] “A small complete category”, Lecture delivered at the Conference Church's
Thesis after 50 years, Zeiss (NL), June 1986 (Ann. Pure Appl. Logic, to appear).
Hyland J.M.E., Johnstone P., Pitts A. [1980] “Tripos Theory”, Math. Proc. Camb. Phil.
Soc., 88 (205-232).
Hyland J.M.E., Pitts A. [1987] “The Theory of Constructions: categorical semantics and topos
theoretic models”, Categories in Computer Science and Logic, Boulder (AMS notes).
Hyland J.M.E., Robinson E., Rosolini P. [1990] “The descrete objects in the effective topos”,
Proc. London Math. Soc. (3) 60,1-36.
Huet G.  [1986] “Formal Structures for Computation and Deduction” Lecture Notes, C.M.U..
Jacobs B. [1989] “Some Notes on Fibred Categories and the Semantics of Dependent Types”,
Università di Pisa, Projects ST2-0374-C of the European Communitee.
Johnstone P.T.  [1977] Topos Theory. Academic Press, London.
Jones N. [1980] (ed.) Semantics-Directed Compiler Generation, LNCS 94, Springer-Verlag.
Kan D.M.  [1958] “Adjoint Functors” Trans. Am. Math. Soc., 87, (294-329).
Kasangian S., Labella A.  [1988] “Enriched Categorical Semantics for Distributed Calculi”, Univ. di
Roma “La Sapienza”, (preprint).
Kelly G.M. [1964] “On MacLane's Conditions for Coherence of Natural Associativities,
Commutativities, ect.” J. Algebra 1 (397-402).
Kelly G.M.  [1982] Basic Concepts of Enriched Category Theory, Cambridge University
Press.

Bibliography
288
Kock A.  [1972] “Strong Functors and Monoidal Modas”, Archiv. der Mathematik, 23.
Koymans K.  [1982] “Models of the lambda calculus”, Information and Control, 52, (306-332).
Kreisel G.  [1959] “Interpretation of analysis by means of constructive functionals of finite type”,
Constructivity in Mathematics,  A. Heyting  N-H (ed.), (101-128).
Kuratowski C.  [1952] Topologie, Vol. 1, Warsaw.
Lafont Y.  [1988] “The Linear Abstract Machine”, Theoretical Computer Science 59, 157-180.
Lafont Y.  [1988] “Introduction to Linear Logic” Lecture Notes of the School on Constructive
Logics and Category Theory (Isle of Thorns, August 1988).
Lambek J.  [1968] “Deductive systems and categories”, I. J. Math. Systems Theory, 2, (278-
318).
Lambek J.  [1974] “Functional completeness of cartesian categories”, Ann. Math. Logic, 6, (252-
292).
Lambek J.  [1980] “From lambda-calculus to cartesian closed categories”, in  J.R. Hindley and J.P.
Seldin (eds.) to H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and
Formalism, Academic Press, (375-402).
Lambek J.  [1985] “Cartesian Closed Categories and typed lambda calculi”, in Guy Cousineau,
Pierre-Luis Curien and Bernard Robinet (eds.) Combinators and Functional Programming
languages, LNCS 242, Springer-Verlag.
Lambek J., Scott P.J. [1974] “Aspects of higher order categorical logic” Contemporary
Mathematics, 30, (145-174).
Lambek J., Scott P.J. [1980] “Intuitionist type theory and the free topos”, J. Pure Appl.
Algebra, 19, (215-257).
Lambek J., Scott P.J.  [1986] Introduction to higher order Categorical Logic, Cambridge
University Press.
Lawvere F.W.  [1966] “The Category of categories as a Foundation for Mathematics”, in  Proc.
Conf. on Categorical Algebra, S. Eilemberg et al. (eds.), La Jolla, 1965, Springer-Verlag.
Lawvere F.W.  [1976] “Variable quantities and variable structures in topoi”, in  Algebra Topology
and Category Theory: a collection of papers in honor of Samuel Eilenberg, A. Heller and M.
Tierney (eds.), Academic Press, (101-131).
Lehman D., Smyth M. [1981] “Algebraic specification of data types: a synthetic approach”,
Mathematical Systems Theory, 14, (97-139).

Bibliography
289
Longo G. [1983] “Set-Theoretical Models of Lambda-Calculus: Theories, Expansions,
Isomorphisms”, Annals Pure Applied Logic, 24, (153-188).
Longo G. [1984] “Limits, higher computability and type free languages”, MFCS'84, Prague
(Chytil, Koubek eds.), LNCS 176, Springer-Verlag, (96-114).
Longo G.  [1986] “On Church's Formal Theory of functions and functionals”, Church's Thesis
after 50 years,  Zeiss (NL), June 1986, (Ann. Pure Appl. Logic., 40, 1988, (93-133)).
Longo G. [1988]  From type-structures to Type Theories, Lecture Notes, Spring semester
1987/8, Computer Science dept., C.M.U..
Longo G., Moggi E. [1984] “The Hereditary Partial Recursive Functionals and recursion Theory in
higher types”, J. Symb. Logic, vol. 94, 4 (1319-1332).
Longo G., Moggi E. [1984a] “Cartesian Closed Categories of Enumerations and effective Type
Structures”, Symposium on Semantics of Data Types (Khan, MacQueen, Plotkin eds.)
LNCS 173, Springer-Verlag, (235-247).
Longo G., Moggi E. [1990] “A category-theoretic characterization of functional completeness”
Theoretical Computer Science vol. 70, 2 (193-211)
Longo G., Moggi E.  [1988] “Constructive Natural Deduction and its ω-Set Interpretation” CMU
Report  CS-88-131, Mathematical Structures in Computer Science, vol.1, n.2, 1991.
Mac Lane S. [1971] Categories for the Working Mathematician, Springer-Verlag, New
York.
Mac Lane S. [1982] “Why Commutative Diagrams Coincide with Equivalent Proofs?”,
Contemporary Mathematics, 13, (387-401).
Manes E.G. [1976] Algebraic Theories, Springer-Verlag, New York.
Makkai M., Reyes G.E.  [1977] “First order Categorical Logic”, Lecture Notes in Math., 611.
Margharia I., Zacchi M.  [1983] “Right and left invertibility in λβ-calculus”, R.A.I.R.O., 17,
no.1, (71-88).
Marti-Oliet N., Meseguer J. [1989] “From Petri Nets to Linear Logic”, Category Theory and
Computer Science, Manchester, Pitt et al. (eds.) LNCS 389, Springer Verlag.
Marti-Oliet N., Meseguer J. [1990] “Duality in Closed and Linear Categories”, Mathematical
Structures in Computer Science, to appear.
Martini S. [1987] “An interval model for second order lambda calculus”, Category Theory and
Computer Science, Edimburgo, Pitt et al. (eds.) LNCS 283, Spriger-Verlag.

Bibliography
290
Martini S. [1988] “Modelli non estensionali del polimorfismo in programmazione funzionale”, Tesi di
Dottorato, Dipartimento di Informatica, Pisa.
Martini S. [1988] “Bounded quantifiers have interval models”, ACM Conference on Lisp and
Functional Programming Languages, Snowbird, Utah.
Mauny M., Suarez A. [1986] “Implementig functional languages in the categorical abstract machine”,
Proc. Lisp and Functional Programming Conf., ACM, Boston.
Meseguer J., Montanari U. [1988] “Petri Nets are Monoids: A New Algebraic Foundation for net
Theory”, IEEE Conference on Logic in Computer Science , LICS'88, Edinburgh.
Meseguer J.  [1988] “Relating Models of Polymorphism”, SRI-CSL-88-13, October, SRI Projects
2316, 4415 and 6729, Comp. Sci. Lab., SRI International.
Meyer A.R. [1982] “What is a model of the lambda calculus?”, Information and Control, 52,
(87-122).
Mints G.E. [1981] “Closed Categories and the Theory of Proofs”, Journal of Soviet Math.,
N.V., 15, (45-63).
Mitchell B. [1965] Theory of Categories, Academic Press.
Mitchell  J. [1984] “Semantic Models for Second-Order Lambda Calculus”, in  Proc. 25th IEEE
Symp. on Foundations of CS, (289-299).
Mitchell J., Harper R. [1988] “The essence of ML”, Proc. ACM-POPL 88.
Moggi E. [1987] “Interpretation of second order lambda-calculus in categories” unpublished
manuscript, underground Edinburgh/Pisa.
Moggi E. [1988] “Partial Morphism in Categories of Effective Objects”, Info&Comp., 76, 2/3,
(250-277).
Moggi E. [1988a] “The partial lambda-calculus”, Ph.D. Thesis, Edinburgh.
Moggi E. [1989] “Computational Lambda-Calculus and Monads”,  IEEE Conference on Logic
in Computer Science, LICS'89, Asilomar (Ca).
Obtulowicz A., Wiweger A. [1982] “Categorical Functorial and Algebraic Aspects of the Type-Free
Lambda-Calculus”, Universal Algebra and Applications, Banach Center Publications, 9, (399-422)
PWN-Polish Scientific Publishers, Warszawa.
Ohori A.  [1987] “Orderings and types in databases”, Proc. of the Workshop on Database
Programming Languages, Roscoff, France, September.
Oles F.J.  [1985] “Type algebras, functor categories, and block structure”. In  Algebraic Methods
in Semantics, Maurice Nivat and John C. Reynolds (Eds.), Cambridge University Press.

Bibliography
291
de Paiva V.C.V. [1987] “The Dialectica Categories”, Conference in Category Theory,
Computer Science and Logic, Boulder (AMS notes).
Pitt D.H., Abramsky S., Poigné A., Rydeheard D.E., (Eds.), [1985] Category Theory and
Computer Programming, LNCS 240, Springer-Verlag.
Pitt D.H., Abramsky S., Poigné A., Rydeheard D.E., (Eds.) [1987] Category Theory and
Computer Science, LNCS 283, Springer-Verlag.
Pitts A. [1987] “Polymorphism in Set Theoretic Constructively” Symposium on Category Theory
and Comp. Sci., LNCS 283 (Pitt et al. eds.), Edinburgh.
Plotkin G.  [1978] “Tω as a universal domain”, J. Comp. Syst. Sci., 17, (209-236).
Plotkin G. [1980/4] “Domains”, Lecture Notes, C.S. Dept., Edinburgh.
Reynolds J.  [1980] “Using category theory to design implicit conversion and generic operators”.  In
Proceedings of the Aarhus Workshop on Semantics Directed Compiler Generation,
N.D. Jones (ed.), Springer-Verlag, January, LNCS 94.
Reynolds J. [1984] “Polymorphism is not set-theoretic”, Symposium on Semantics of Data
Types, Kahn, MacQueen, Plotkin (eds.) LNCS 173, Springer-Verlag.
Reynolds J.C., Plotkin G. [1988] “On functors expressible in the polymorphic typed lambda
calculus”, CMU report CS 88-125, in Logical Foundations of Functional programming,
G. Huet (ed.), Addison-Wesley, 1990, 127-152.
Rittri M. [1990] “Using types as Search Keys in Function Libraries” Journal of Functional
Programming, vol. 1.
Robinson E., Rosolini P.  [1988] “Categories of partial maps”, Info&Comp., 79, (95-130).
Rosolini G. [1986] “Continuity and Effectiveness in Topoi” D. Phil. Thesis, Oxford University.
Rydeheard D.E., Burstall R.M. [1988] “Computational Category Theory”, Prentice Hall
International Series in Computer Science, C.A.R. Hoare Series Editor.
Scedrov A. [1988] “A Guide to Polymorphic Types”, CIME Lectures, Montecatini Terme, June
1988 (revised version).
Scott D. [1972] “Continuous lattices”, Toposes, Algebraic Geometry and Logic, Lawvere
(ed.) SLNM 274, (97-136) Springer-Verlag.
Scott D.  [1976] “Data types as lattices”, SIAM Journal of Computing, 5, (522-587).
Scott D.  [1979] “Identity and Existence in Intutionistic Logik”, In  Applications of Sheaves,
LNM 753, Springer-Verlag (660-696).

Bibliography
292
Scott D.  [1980] “Relating theories of the lambda-calculus”, In  Hindley/Seldin .
Scott D.  [1980a] “Lambda-calculus, some models, some philosophy”, The Kleene Symposium,
Barwise et al. (eds.), North-Holland.
Scott D.  [1980b] “A space of retracts”, manuscript, Bremen.
Scott D.  [1981] “Lectures on a mathematical theory of computation”, Oxford Univ. Comp. Lab.,
Tech. Mon. PRG-19.
Scott D.  [1982] “Some ordered sets in Computer Science”, In  Ordered Sets, Rival (ed.), Reidel.
Scott D.  [1982] “Domain for denotational semantics”, (preliminary version), Proceedings ICALP
82, LNCS 140, Springer-Verlag.
Scott D. and Gunter C. [1990] “Semantic Domains” Handbook of Theoretical Computer
Science, J. van Leeuwen (ed), North Holland, to appear.
Scott P.J.  [1978] “The “dialectica” interpretation and categories”, Zeitschr. f. Math. Logik und
Grundlagen d. Math., 24, (553-573).
Seely R.A.G.  [1987] “Categorical semantics for higher order polymorphic lambda calculus”,
Journal Symb. Logic, 52, n.4, (969-989).
Seely R.A.G.  [1987] “Linear Logic*-Autonomous Categoires and Cofree Coalgebras”, Categories
in Computer Science and Logic, Boulder (AMS notes).
Smyth M.  [1977] “Effectively Given Domains”, Theoret. Comp. Sci., 5, (255-272).
Smyth M., Plotkin G.  [1982] “The category theoretic solution of recursive domain equations”,
SIAM Journal of Computing, 11, (761-783).
Soloviev S.V. [1983] “The category of finite sets and cartesian closed categories” Journal of
Soviet Math., 22, 3.
Stoy J.  [1977] Denotational Semantics, M.I.T. Press.
Tatsuya H.  [1987] “A typed lambda calculus with categorical type constructors”, In D.H. Pitt et al.
(eds.)
Taylor P.  [1986] “Recursive Domains, Indexed Category Theory and Polymorphism”, Ph.D.
Thesis, Cambridge University, London.
Troelstra A.S. [1973] “Notes in intutionistic second order arithmetic”, Summer School in Math
Logic, LNM 337, Cambridge, Springer-Verlag, (171-203).
Wand M. [1979] “Fixed-point Construction in Order-enriched Categories”, Theor. Comp. Sci.,
(13-30).

Bibliography
293
Winskel G. [1986] “Category Theory and Models of Parallel Computation”, Proc. Summer
Workshop on Category and Computer Programming, Surrey, LNCS 240, (266-281).
Wiweger A. [1984] “Pre-adjunctions and lambda-algebraic theories”, Coll. Math. XLVIII,
Warszava, (153-165).

