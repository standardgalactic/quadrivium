
s o l u t i o n s @ s y n g r e s s . c o m
With more than 1,500,000 copies of our MCSE, MCSD, CompTIA, and Cisco
study guides in print, we continue to look for ways we can better serve the
information needs of our readers. One way we do that is by listening.
Readers like yourself have been telling us they want an Internet-based ser-
vice that would extend and enhance the value of our books. Based on
reader feedback and our own strategic plan, we have created a Web site
that we hope will exceed your expectations.
Solutions@syngress.com is an interactive treasure trove of useful infor-
mation focusing on our book topics and related technologies. The site
offers the following features:
■
One-year warranty against content obsolescence due to vendor
product upgrades. You can access online updates for any affected
chapters.
■
“Ask the Author” customer query forms that enable you to post
questions to our authors and editors.
■
Exclusive monthly mailings in which our experts provide answers to
reader queries and clear explanations of complex material. 
■
Regularly updated links to sites specially selected by our editors for
readers desiring additional reliable information on key topics.
Best of all, the book you’re now holding is your key to this amazing site.
Just go to www.syngress.com/solutions, and keep this book handy when
you register to verify your purchase.
Thank you for giving us the opportunity to serve your needs. And be sure
to let us know if there’s anything else we can do to help you get the 
maximum value from your investment. We’re listening.
www.syngress.com/solutions


1 YEAR UPGRADE
B U Y E R  P R O T E C T I O N  P L A N
Developing
Web Services with
Java APIs
for XML Using WSDP
Jerry Foster
Mick Porter
Dreamtech Software, Inc.
Natalie Wear
Bob Hablutzel
Technical Editor

Syngress Publishing, Inc., the author(s), and any person or ﬁrm involved in the writing, editing, or
production (collectively “M akers”) of this book (“the Work”) do not guarantee or warrant the results
to be obtained from the Work.
T here is no guarantee of any kind, expressed or implied, regarding the Work or its contents.T he Work
is sold AS IS and W IT H O U T  WAR R AN T Y. You may have other legal rights, which vary from state
to state.
In no event will M akers be liable to you for damages, including any loss of proﬁts, lost savings, or
other incidental or consequential damages arising out from the Work or its contents. Because some
states do not allow the exclusion or limitation of liability for consequential or incidental damages, the
above limitation may not apply to you.
You should always use reasonable care, including backup and other appropriate precautions, when
working with computers, networks, data, and ﬁles.
Syngress M edia®, Syngress®,“C areer Advancement T hrough Skill Enhancement®,” and “Ask the
Author U PDAT E®,” are registered trademarks of Syngress Publishing, Inc. “M ission C ritical™,” “H ack
Prooﬁng®,” and “T he O nly Way to Stop a H acker is to T hink Like O ne™” are trademarks of Syngress
Publishing, Inc. Brands and product names mentioned in this book are trademarks or service marks of
their respective companies.
KEY
SERIAL NUMBER
001
945T5GHD4T
002
MPET4AKRT4
003
3VN54NMER6
004
B39UNGD3S4
005
U6N7VH8U8M
006
NTE4NFMG4R
007
TBR46TWBVH
008
565M2PRB9R
009
R4BA3N58MS
010
2ZFCG6YTH2
PU BLISH ED BY
Syngress Publishing, Inc.
800 H ingham Street
R ockland, M A 02370
Developing Web Services with Java APIs for XML Using WSDP
C opyright © 2002 by Syngress Publishing, Inc.All rights reserved. Printed in the U nited States of
America. Except as permitted under the C opyright Act of 1976, no part of this publication may be
reproduced or distributed in any form or by any means, or stored in a database or retrieval system,
without the prior written permission of the publisher, with the exception that the program listings
may be entered, stored, and executed in a computer system, but they may not be reproduced for
publication.
Printed in the U nited States of America
1  2  3  4  5  6  7  8  9  0
ISBN : 1-928994-85-7
Technical Editor: Bob H ablutzel
C over D esigner: M ichael K avish
Technical R eviewer:Alex C eponkus 
Page Layout and Art by: Shannon Tozier 
Acquisitions Editor: Jonathan Babcock
C opy Editor: M ike M cGee and Jesse C orbeil
Indexer: Jennifer C oker
Distributed by Publishers Group West in the U nited States and Jaguar Book Group in C anada.

v
Acknowledgments
v
We would like to acknowledge the following people for their kindness and support
in making this book possible.
R alph Troupe, R honda St. John, Emlyn R hodes, and the team at C allisma for their
invaluable insight into the challenges of designing, deploying and supporting world-
class enterprise networks.
K aren C ross, Lance T ilford, M eaghan C unningham, K im Wylie, H arry K irchner,
Kevin Votel, Kent Anderson, Frida Yara, Jon M ayes, John M esjak, Peg O ’Donnell,
Sandra Patterson, Betty R edmond, R oy R emer, R on Shapiro, Patricia K elly,Andrea
Tetrick, Jennifer Pascal, Doug R eil, David Dahl, Janis C arpenter, and Susan Fryer of
Publishers Group West for sharing their incredible marketing experience and
expertise.
Jacquie Shanahan,AnnH elen Lindeholm, David Burton, Febea M arinetti, and R osie
M oss of Elsevier Science for making certain that our vision remains worldwide in
scope.
Annabel Dent and Paul Barry of Elsevier Science/ H arcourt Australia for all their help.
David Buckland,Wendi Wong, M arie C hieng, Lucy C hong, Leslie Lim,Audrey Gan,
and Joseph C han of Transquest Publishers for the enthusiasm with which they receive
our books.And welcome back to Daniel Loh— glad to have you back Daniel!
K won Sung June at Acorn Publishing for his support.
Ethan Atkin at C ranbury International for his help in expanding the Syngress
program.
Jackie Gross, Gayle Voycey,Alexia Penny,Anik R obitaille, C raig Siddall, Darlene
M orrow, Iolanda M iller, Jane M ackay, and M arie Skelly at Jackie Gross & Associates
for all their help and enthusiasm representing our product in C anada.
Lois Fraser, C onnie M cM enemy, Shannon R ussell, and the rest of the great folks at
Jaguar Book Group for their help with distribution of Syngress books in C anada.

vi
Contributors
Jay Foster has been an IT  professional since 1989. H is areas of expertise
include object-oriented design and modeling, software engineering,Web
based application design/ development, extranet/ intranet security, and N -
tier application development. H e has extensive experience in the fol-
lowing technologies: Java Servlets, Enterprise JavaBeans (EJB), Java Server
Pages (JSP), Java Database C onnectivity (JDBC ), R emote M ethod
Invocation (R M I), Java Foundation C lasses (JFC ), Swing, O O A/ O O D/
O O P using the U niﬁed M odeling Language (U M L), C O R BA,Web
Services, .N ET  Framework, C #,ASP.N ET,Web Security and Enterprise
Application Integration. Jay has been developing object-oriented systems
in Java since 1996 and is a Sun C ertiﬁed Java Programmer. Jay has
authored several books on various Java programming topics.
Mick Porter (SSJC P, M C P) is a Senior Technical Architect for Logica, a
global systems integrator. M ick specializes in the design and implementa-
tion of wireless and mobile commerce systems.W ith 15 years of experi-
ence in the IT  industry, M ick has worked on an enormous variety of
systems and projects, and over the last few years, he has delivered a
number of major e-commerce systems. M ick holds a bachelor’s degree in
C omputer Science, and became a Sun C ertiﬁed Java Programmer ﬁve
years ago, as well as having passed eight M icrosoft C ertiﬁed Professional
exams. M ick lives in Sydney,Australia, with his wife,Andrea, and children,
H olly and Anthony.
Jonothon Ortiz is Vice President of X next, Inc. in W inter H aven, FL.
X next, Inc. is a small, privately owned company that develops Web sites
and applications for prestigious companies such as the N ew York T imes. H e
has been a professional developer for over nine years now and has been
exposed to a wide range of programming languages and styles. H e uses
JSP extensively to perform transformations of X M L data in conjunction
with other languages. Jonothon lives with his wife, C arla, in Lakeland, FL.

vii
Dreamtech Software India Inc. is a software solution and service
provider that provides a broad range of services and offers a dynamic
blend of consultancy and system integration to help corporations build
and implement innovative e-business strategies.A futuristic vision moti-
vates the globally acclaimed software products of Dreamtech Software.
Dreamtech has already distinguished itself with an excellent track record
of publishing books on advanced technologies including X M L and X SLT,
WAP, Bluetooth, 3G , peer-to-peer networking, C #, and Java.T he success
of Dreamtech’s endeavors to provide world-class software products can be
gauged by the fact that its clientele includes some of the most distin-
guished names in IT-related publishing and solutions.
Natalie S.Wear is a Senior Java Developer and Systems Engineer at
Telecommunications Services, Inc. in Tampa, FL. She creates code designs,
provides architecture recommendations, and writes software for the Java
applications used within her department. Such applications are primarily
centered on back-end integration using X M L and wireless industry-stan-
dard APIs. H er specialties include e-commerce, C O R BA implementation,
back-end system integration, and internet/ intranet development. N atalie’s
background includes positions as Senior Java Engineer at Verizon W ireless
and as an instructor of Vitria at PriceWaterhouseC oopers, LLP. She also
teaches an undergraduate course on Java at the U niversity of South
Florida. N atalie holds a bachelor’s degree in Political Science and another
bachelor’s degree in M anagement Information Systems (M IS) from the
U niversity of South Florida. She holds a master’s degree in Business
Administration (M BA) from the U niversity of South Florida.
Greg Bylenok is a Software Engineer with iC onverse. In his role at
iC onverse, Greg is involved in the design and development of products
for the mobile industry. H e has been using Java, J2EE, and X M L tech-
nologies in his daily work for over three years.

viii
Technical Editor and Contributor
Bob Hablutzel is a Senior C onsultant with 20 years experience in
enterprise-scale software systems. H e is currently a Founding Partner in
InﬂexionPoint, a consultancy whose practice spans the full cycle of a soft-
ware product, from business needs analysis through architecture, develop-
ment, debugging, and deployment. Bob is particularly interested in the
efﬁciency and accuracy of large systems and has advised numerous pro-
jects on the identiﬁcation and elimination of bottlenecks and errors. H is
background also includes time as C T O  and Principle Architect of various
startup companies. Bob’s Web Services experience includes being a
founding member of the X AM L (X M L-based business transactions)
working group and implementing high-availability and clustering for the
Bowstreet X M L-based application server. H is Java experience includes
implementation of Java bytecode compilers and contributing to the book
Sun C ertiﬁed P rogrammer for Java 2. Bob lives in N ew H ampshire with his
wife,Trish, and daughters,Anna and K atie.

Contents
ix
Foreword
xxiii
Chapter 1 Introduction to the JWSDP
1
Introduction
2
JW SDP H istory
3
JAX P
3
JAX M
4
JAX -R PC
5
JAX R
6
JSSE
6
JST L
7
Ant and Tomcat
7
Summary
9
Solutions Fast Track
9
Frequently Asked Q uestions
12
Chapter 2 Processing XML Documents 
with SAX
13
Introduction
14
U nderstanding Event-Based X M L Parsing
14
T he SAX  Event M odel
15
O verview of Event Processing
15
H istory of SAX
16
Basic SAX  Events
17
Example Parse Events
18
U nderstanding Event H andlers
18
O verview of H andlers
18
Basic SAX  C allbacks
19
Example Event H andler
22
Answers to You
Frequently asked
Questions
Q: What is the JWSDP?
A: The JWSDP is a
collection of libraries,
tools, and standard
interfaces designed to
ease the development
of XML-based Web
services in the Java
programming
language.

x
Contents
C reating a SAX  Parser 
26
SAX  Interfaces and SAX  Implementations
26
JAX P and U nderlying SAX  Engines
27
Introducing the JAX P package
27
U sing the SAX ParserFactory
27
Selecting a SAX  parser with the
plugability interface
28
Parsing Data with a SAX  Parser
31
Input Sources
31
InputSource
31
An Example Servlet
32
Servlets and M ultithreading 
36
C onfiguring the Parser
38
Enabling Validation
39
Enabling N amespaces
39
N amespaces and Events
40
Enabling O ther Features
41
Features and Properties
42
Setting Features
43
Setting Properties
43
H andling Advanced Events
44
C ontentH andler
44
ErrorH andler
45
SAX 2 Extensions
47
LexicalH andler
47
DeclH andler
48
Summary
49
Solutions Fast Track
50
Frequently Asked Q uestions
51
Chapter 3 Processing XML Documents 
with DOM
53
Introduction
54
T he Document O bject M odel
54
T he DO M  Tree
55
T he Basic C lasses
57
Document
58
Selecting a SAX Parser
The newInstance() method
searches the target
environment at runtime
for a suitable SAX engine.
It searches the following
places in order:
1. System property space
2. JAXP properties file
3. JAR metafile

Contents
xi
Element
58
Text
58
Attribute
59
N ode
59
N odeList
59
Interrelationships
60
H ierarchy imposed by the Document/
Element/ Attribute/ Text classes
60
R elationship between Elements in
a DO M  hierarchy
61
JAX P and U nderlying DO M  Engines
62
C reating a DO M  Parser
65
T he DocumentBuilderFactory class
66
O btaining a new instance of the 
DocumentBuilderFactory
66
U sing the DocumentBuilderFactory
to create a DocumentBuilder
66
Setting parser attributes
67
C reating a coalescing, validating,
namespace aware DO M  parser.
69
Parsing X M L into a DO M
73
Input source types
73
InputSource
74
File-based source
74
InputStream-based sources
74
String
75
EntityR esolvers
75
M anipulating DO M  O bjects
77
Walking a DO M  C onstellation
77
O btaining the document root
80
Walking the hierarchy
80
A servlet to write out name/ value
pairs from example schema
82
Finding lists of nodes
89
Servlet to write out all node names
that contain a specific value.
94
C hanging the contents of a node
96
NOTE
The ParsingXML servlet
uses the GET method
(in which the servlet
receives data in the
form of a query string)
for the request.
However, the
ParsingXML servlet does
not read any data using
the HTTPServletRequest
object, since data is
being read from a file-
based source. Thus, the
use of doGet() or
doPost() is figurative
and not practically rele-
vant to this particular
servlet.

xii
Contents
AdditionInX M L Servlet to modify
nodes in the DO M  tree
104
Advanced Topics
108
M ulti-threaded applications
109
Safe routines
109
U nsafe routines
115
Parser Attributes
115
Selecting a DO M  Parser with the
Plugability Interface
117
DO M  Parser search path
117
Error H andling
118
Summary
120
Solutions Fast Track
120
Frequently Asked Q uestions
121
Chapter 4 XML Transformations
123
Introduction
124
R eviewing X SL and X SLT
124
X Path and X SLT
128
Axes and Locations
129
Procedural X SLT
130
<xsl:template>
130
<xsl:apply-template>
131
<xsl:for-each>
132
<xsl:if>
134
<xsl:choose>, <xsl:when>,
<xsl:otherwise>
137
<xsl:sort>
138
<xsl:value-of>
138
<xsl:output>
138
JAX -P and U nderlying X SL Engines
139
U sing JAX -P C lasses
140
C reating a Transformer
140
Source and R esult
144
Transformer
145
Templates
149
M iscellaneous JAX -P for X SL Issues
152
JAX-P and Underlying
XSL Engines
■
JAX-P is not an
XSL/XSLT engine; it is
actually a layer that
allows a developer to
use JAX-P regardless of
the XSL/XSLT engine
that lies beneath.
■
Current popular
XSL/XSLT engines
include SAXON and
Xalan.
■
Since JAX-P has to
provide a proper layer
over all available
XSL/XSLT engines it can
only support common
functionality.

Contents
xiii
Error H andling
152
ErrorListener
152
SourceLocator
153
U R IR esolver
153
T hread Safety
154
Plugability
155
Summary
156
Solutions Fast Track
156
Frequently Asked Q uestions
158
Chapter 5 Using JSTL (JSP Standard 
Tag Library)
159
Introduction
160
Expression Languages
160
W hy Expression Languages?
161
Supported Expression Languages
161
Simplest Possible Expression
Language (SPEL)
161
EC M AScript
163
JX Path
164
Selecting an Expression Languge
164
Application-W ide
164
C ode Section Explicit
165
Expression Languages and Tag Library
Selection
166
Future C ompatibility with Expression
Languages
166
C ore Tags
167
Expression Language
167
c:out
169
c:set
170
Iterations
171
c:forEach
171
c:forTokens
172
C onditional Expressions
173
c:if
173
c:choose
173
c:when
173
XML Support Tags
■
All expressions in the
XML Tag Library use
XPath expressions.
■
JSTL provides XML
transformation
capabilities via the
x:transform action.
■
By using the
x:transformer action
you can define a
transformer instance
that is reusable against
multiple XML
documents within the
same page.

xiv
Contents
c:otherwise
174
Importing External R esources
174
c:import
174
c:param
175
U R L M anipulation
175
c:urlEncode
175
c:redirect
176
SQ L Q uery Tags
176
Setting up a driver
176
sql:driver
177
Executing queries
177
sql:query
177
sql:param
177
Executing updates
179
sql:update
179
Denoting transactional boundaries
180
sql:transaction
180
Internationalization Tags
182
Defining the Locale
183
Browser Specified
183
JSP Specified
184
Defining the T imezone
184
fmt:timeZone
184
Specifying a R esource Bundle
185
fmt:bundle
186
Locating the resource bundle
186
U sing Internationalized M essages
187
O btaining Simple Internationalized
M essages
187
Performing Parameter Substitution
188
Exception Localization
190
Parsing and formatting
192
fmt:formatN umber
192
fmt:parseN umber
194
fmt:formatDate
194
fmt:parseDate
195
X M L Support Tags
195

Contents
xv
Parsing and searching
195
x:parse
195
x:out
196
x:set
196
Iteration
196
x:forEach
196
Flow C ontrol
197
x:if
197
x:choose
197
x:when
197
x:otherwise
197
Translation and X SLT
198
Summary
199
Solutions Fast Track
199
Frequently Asked Q uestions
201
Chapter 6 Writing SOAP Clients
203
Introduction
204
U nderstanding SO AP
204
Envelopes
205
H eaders
206
Bodies
207
Attachments
208
SO APElement and JAX M  DO M
209
SO APElement
209
Attributes
210
C hild Elements
210
Text N odes
212
N ame
213
Text
214
JAX M  SO AP Elements
214
SO APM essage
214
M IM E encoding
215
SO APPart 
217
SO APEnvelope
219
SO APH eader & SO APH eaderElement
220
SO APBody, SO APBodyElement and
SO APFault
222
The Components of a
SOAP Message
SOAP Message
Envelope
Header
(Optional)
Attachment 1
(Only in SOAP Messages
with Attachments)
Body
Attachment 1
(Only in SOAP Messages
with Attachments)

xvi
Contents
C reating a SO AP M essage
223
M essageFactory
224
C reating SO AP Parts, Envelopes,
H eaders and Bodies
226
Adding Attachments to M essages
228
Bringing it all Together— A C omplete
SO AP C lient
230
C onnecting to a SO AP service
230
Summary
248
Solutions Fast Track
248
Frequently Asked Q uestions
250
Chapter 7 Writing SOAP Servers
253
Introduction
254
M essage R outing
254
Asynchronous messages
255
O ne-Way M essages
256
Delayed R esponse M essages
257
State in Asynchronous Servers
258
M essage R outing
259
Incoming M essage R outing
260
O utgoing M essage R outing
262
Establishing a C onnection to a JAX M  Provider
263
ProviderC onnections
266
U sing the ProviderC onnection to C reate
a M essage
267
U sing ProviderC onnection to Send
a M essage
267
Profiles
269
W riting a SO AP Server Servlet
270
JAX M Servlet
271
R equired O verrides
273
H andling M essages
274
W riting a SO AP EJB
275
O verriding M essageDrivenBean and
O newayListener
277
Example SO AP Servlet
277
Unboxing
Unboxing is the act of
converting an object back
into a value type. The
syntax for this process
looks very similar to
explicit casting in Java, as
the following C# code
demonstrates:
int x = 29;
object xObj = x; // 
Boxing
int x1 = (int)xObj; // 
Unboxing

Contents
xvii
R eceiving and Processing SO AP M essages
278
Summary
300
Solutions Fast Track
300
Frequently Asked Q uestions
302
Chapter 8 Using XML-based RPC
303
Introduction
304
JAX -R PC  Summary
304
U nderstanding Stubs and T ies
305
Sending a X M L-R PC  M essage
306
M apping Java Data Types
307
Supported Java data types
307
Data Type to X M L/ W SDL Definition Tables
308
Primitives
308
O bject Types
308
Arrays
309
Application C lasses
310
Arbitrary Java C lasses
311
Serializers
311
Deserializers
312
H older C lasses
312
C onversion Between Java C lasses and W SDL
313
W SDL Generator
313
C ommand Line O ptions
313
Tool C onfiguration File
314
Server C onfiguration File
316
U sing C lasses Generated by the Stub
Generator
317
C reating a JAX -R PC  C lient
317
C reating a connection to a remote server
318
Invoking methods on a remote server
318
C reating a JAX -R PC  Server
319
C reating the Service Definition Interface 
319
C reating the xrpcc C onfig File
319
Developing the Service Implementation
320
Building the Server WAR  File
320
C reating a Simple X M L-R PC  Server and C lient
321
ProviderConnections
ProviderConnection
objects essentially perform
three different tasks:
1. Allow information
(meta data) about the
Provider to be queried.
2. Provide
MessageFactory objects
that can produce
messages specific to a
certain profile.
3. Pass messages to the
Provider to be sent
asynchronously.

xviii
Contents
Summary
328
Solutions Fast Track
329
Frequently Asked Q uestions
331
Chapter 9 Locating Web Services
333
Introduction
334
R egistries
334
Storage of M etadata about Services
334
C ategories 
335
Locations
336
M ajor R egistry Standards
336
U DDI
337
ebX M L
339
C ategorizing Web Services
342
C ategory H ierarchies
342
Example H ierarchies
343
O rganization, U ser
343
C onnecting to a R egistry
344
U sing the Default R egistry
347
Adding an O rganization
348
Q uerying the R egistry
351
Q uerying the R egistry
353
Finding a Service U sing a Simple Q uery
353
Finding a Service U sing a C omplex Q uery 
357
U nderstanding the Q uery R esults
363
M etadata R eturned
363
External Data
364
W SDL Documents
364
Structure of a W SDL Document
365
Example W SDL Document
368
T he <definitions> Element
370
T he <message> Element
370
T he <portType> Element
371
T he <binding> Element
371
T he <service> Element
372
Storing Information in a R egistry
372
Adding N ew R egistry R ecords
372
NOTE
WSDL supports four
basic types of opera-
tions. These are:
■
One-way, in which
the service receives
a message.
■
Request-Response,
in which the service
receives a message
and sends a
response. 
■
Solicit-Response, in
which the service
(not the client) initi-
ates communication
by sending a mes-
sage and receives a
response. 
■
Notification, in
which the service
sends a message
and seeks no
response. 

Contents
xix
U pdating R ecords
381
Deprecating and Deleting Existing R ecords
386
Security R equirements
393
Summary
395
Solutions Fast Track
395
Frequently Asked Q uestions
398
Chapter 10 Java Secure Sockets Layer
401
Introduction
402
C onfiguring JSSE
402
Download JSSE and Extract the Files
403
Install the .jar Files
403
R egister the SunJSSE Provider
403
C onfigure T he U R L H andler
404
Install a JSSE-Specific cacerts file
(O ptional C onfiguration Step).
405
Introduction to Keys and C ertificates
405
U sing keytool to C reate a Keystore
407
C reating a keystore 
408
U sing keytool to C reate/ install a C ertificate
409
Importing a C ertificate
409
Generating a self-signed C ertificate
410
Importing a C ertificate From an
Identity Database
411
R eferring to keystores with JSSE properties
411
T he KeyStore C lass
412
T he C ertificate C lass
413
U sing JSSE Properties to R efer to
the keystore
414
U sing H T T PS U R L H andlers
416
C onfiguring U R L H andler for JSSE
416
C reating a H T T PS C onnection
418
U sing the U R L H andler
418
U sing SocketFactories
420
C reating Sockets and ServerSockets (by hand)
420
T he ServerSocket C lass
420
T he Socket C lass
421
Answers to You
Frequently asked
Questions
Q: What version of SSL
does JSSE support?
A: JSSE 1.0.2 supports SSL
version 3.
Q: Can JSSE perform RSA
encryption?
A: Yes, JSSE 1.0.2 per-
forms RSA encryption.

xx
Contents
U sing SocketFactories and
ServerSocketFactories
421
T he SocketFactory C lass
421
T he ServerSocketFactory C lass
422
Advantages of SocketFactories
422
Determining Default and Installed
C ipher Suites
422
Determining the Installed C ipher Suites
423
U sing Secure Server Sockets
424
Getting the Secure Socket Factory
425
R egistering a Secure Server Socket
426
Accepting C onnections
426
R eading Data
426
W riting Data
427
C losing C onnections
427
U sing Secure C lient Sockets
429
C onnecting to a R emote Secure Server
430
W riting Data
430
R eading Data
431
C losing the C onnection
431
U sing JSSE Applications with W SDP
437
U sing the U R LH andler in a Web Service
440
C lient-Server Web Service
443
Summary
448
Solutions Fast Track
448
Frequently Asked Q uestions
450
Chapter 11 Using JWSDP Tools
453
Introduction
454
JW SDP U DDI R egistry
454
Installing
455
M icrosoft W indows Installation
Instructions
455
U nix, Linux Installation Instructions
455
C onfiguring
460
Activating
460
Limitations 
461

Contents
xxi
Selecting as the R egistry
462
O rganization
464
Primary C ontact Information
464
C lassifications
465
Tomcat
467
Installing
467
W indows
467
Linux
467
Environmental Variables
468
C onfiguring
468
Server.xml
468
T he webapps Directory and WAR  files
469
Activating
471
Starting Tomcat under W indows N T
M anually
471
Starting Tomcat under W indows N T
as a Service
471
Starting Tomcat under Linux M anually
471
Starting Tomcat under Linux at
Startup T ime
472
R elationship to Apache Servers
472
Acting Standalone
472
Proxied behind Apache Servers
472
Ant
472
Structure of an Ant Input File
472
Projects
473
Targets
473
Tasks
474
Invoking AN T
475
Invoking from the C ommand Line
475
Integrating with IDEs
476
An Ant Example
476
Summary
479
Solutions Fast Track
479
Frequently Asked Q uestions
481
Limitations 
JWSDP does not support
the following messages
within the Registry Server: 
■
add_publisher
Assertions
■
delete_publisher
Assertions
■
get_assertionStatus
Report
■
get_publisherAssertions
■
find_relatedBusiness


It should come as no surprise to someone reading this foreword that two of the most
inﬂuential forces in information systems over the last few years have been Java and
X M L. Java provides a stable, industrial-strength language that runs on a variety of
platforms, while X M L offers a simple format for the exchange of information across
a variety of platforms.Together, they showcase tools for developing numerous appli-
cations: from reaching back into legacy computer systems, to reaching out to users
and partners on the World W ide Web.
Lately, it has become popular to combine these two technologies in a highly-dis-
tributed architectural technique called W eb services. Broadly speaking, a Web service is
the exposure of a business process over a network.T he connotation is generally that
X M L-based trafﬁc is being moved on a public network (the Internet) via the H T T P
protocol. H owever,Web services can also be useful internally to an organization, as a
mechanism for encapsulating and exposing the business logic inherent in legacy sys-
tems. N ew applications can then utilize this Web service interface to leverage the
complex business logic that has been reﬁned, sometimes for decades, in these legacy
systems.T his allows for the reuse of systems at the logical level, without regard to
physical conﬁguration.
T here is nothing speciﬁc to Java in Web services. In fact, the whole point of Web
services is that any language, and any platform, can be used. I’ve written Web services
in languages as varied as Java, C ++, C #, and Perl, but the features that make Java
attractive for general server programming (rich libraries, straightforward execution
model, and portability) are the same ones that make Java attractive when writing new
Web-service-based systems as well.
U ntil recently, Java programmers wanting to use X M L-based Web services have
been faced with a variety of libraries, each presenting a slightly different API and func-
tionality.Web service standards such as SOAP, U DDI, and ebX M L appeared (being key
for next-generation Web-based applications), but had no direct support in Java.
xxiii
Foreword

xxiv
Foreword
T his recently changed with the introduction of the Java W eb Services D eveloper
Pack (JW SD P ).T he JW SDP was designed to create or endorse standard interfaces for
the Java processing of X M L.T he name is somewhat misleading in that the JW SDP
can be used for applications that have nothing to do with Web services. H owever, it
does focus on the presentation of business logic over a network:Web services.
JW SDP is a rich collection of existing interfaces and libraries that Java endorsed,
new standards developed under the Java C ommunity Process, and code that Sun
developed internally to support Web services.At the time this book was written, the
most recent release was the EA2 (Early Access 2) version, which is the version
focused on in these pages.As updates become available, check the Syngress Web site
for amendments to this book.
T he ﬁrst chapter is intended to introduce you to the components of the JW SDP.
It introduces the history of the JW SDP, and the components that make up the
package. It’s a good idea to read chapter one before skipping to any of the other
chapters, just to get an overview of how the parts interoperate.
Since processing X M L is key to Web services, the next three chapters take an in-
depth look at processing X M L in Java, each covering a different aspect of the process.
C hapter 2 tackles parsing X M L using SAX — the Simple API for X M L. C hapter 3
covers parsing again, but this time for the Document O bject M odel. SAX  and DO M
are the two dominant mechanisms for processing X M L in Java, and after reading
these chapters you’ll be able to decide which best ﬁts your application needs.
C hapter 4 explores X M L processing using X SL, a powerful system for trans-
forming X M L data, while C hapter 5 concentrates on the new APIs contained in the
JW SDP.After reading C hapter 4, you’ll be set to begin applying your X SL stylesheets
to the X M L you parsed in C hapters 2 and 3.
W hile X M L is the core of a Web-services-based system, you need to be able to
present those services externally. Its frequently the case that these services need to be
presented directly to end users, and in J2EE that often means JSP. C hapter 5 also
introduces the JSP Standard Tab Library, a component of the JW SDP designed to
facilitate the development of complex JSPs.
N ext, C hapters 6 and 7 turn to computer-to-computer communication, each dis-
cussing the SO AP (Simple O bject Access Protocol) support built into JW SDP.
C hapter 6 concentrates on writing SO AP clients— requesting a remote service (per-
haps one of those wrapped legacy systems) perform some business logic, while
C hapter 7 explores the ﬂip side: writing SO AP servers to provide encapsulated busi-
ness logic to remote clients.T hese chapters also introduce the concepts of SO AP
www.syngress.com

www.syngress.com
providers, which can supply reliable routing of SO AP messages, and/ or simplify the
development of systems that rely on higher-level, SO AP-based protocols such as
ebX M L.
W hile message passing works well for many Web service systems, there are times
where you want to be able to encapsulate the functionality of a remote service and
present it as an object in your local application.T his technique, known as remote proce-
dure calls, is nothing new— U nix systems have provided this functionality for years, as
have middleware tools such as C O M  and C O R BA. H owever, with X M L-based
R PC, the remote system can be wildly different from the local machine— and doesn’t
even have to run a speciﬁc middleware tool. C hapter 8 investigates the X M L-based
R PC  systems, and shows how you can develop applications that act as clients or
servers.
C hapter 9 addresses the issue of ﬁnding and describing Web services. It covers the
JW SDP interfaces to U DDI and ebX M L registries, which are the dominant mecha-
nisms for describing Web services. R egistries were originally conceived as a global
resource— a mechanism for ﬁnding an electronic business partner on the Internet—
but the advent of low-cost registries such as the JW SDP R egistry tool and jU DDI
have made it practical for organizations to deploy registries for internal systems as
well.After reading C hapter 9, you will be ready to dynamically describe and locate
Web service descriptions a variety of ways.
For applications that do communicate with external partners, security is always a
concern. C hapter 10 addresses the JSSE (Java Secure Sockets Extension). JSSE intro-
duces a portable (and exportable) API for securing the point-to-point transfer of
information. U sing JSSE ensures that the messages you send are not intercepted or
viewed by unintended audiences.
Finally, C hapter 11 addresses some of the miscellaneous tools included in the
JW SDP.T hese tools, including Tomcat,Ant, and the JW SDP R egistry, are designed to
provide a development environment for building and testing Web-service-based
applications.Again, these tools are complex, and could easily be a book topic on their
own. C hapter 11 strives to introduce just enough of them for you to use them in
conjunction with the JW SDP.
W riting a book, like an enterprise-class application, is an exercise in changing
priorities, requirements, and scope.T his is particularly true when writing about
emerging technologies such as the JW SDP.T he contributing authors and I have
striven to produce a book that is as current as possible without being speculative, and
useful in the real-world application of the JW SDP libraries.We hope that this book
Foreword
xxv

Foreword
xxvi
serves as both an introduction and a reference when writing Web-service-based sys-
tems in Java.
I want to give thanks to my editor, Jonathan Babcock, who made my ﬁrst tech-
nical editing job easier than I expected. O n a personal note, I want to thank my
ever-supportive wife,Trish, and my daughters,Anna and K atie.W ithout Anna and
K atie, larger portions of the book would have been done in daylight hours, but the
laughter they bring more than makes up for any lost sleep.And without Trish, there
would be no laughter or daylight at all.
— B ob H ablutzel, Technical E ditor and C ontributor
Sun C ertiﬁed Java A rchitect
C onsultant and F ounding Partner, InﬂexionP oint
www.syngress.com

Introduction 
to the JWSDP
Solutions in this chapter:
■
JWSDP History
■
JAXP
■
JAXM
■
JAX-RPC
■
JAXR
■
JSSE
■
JSTL
■
Ant and Tomcat
Chapter 1
1
 Summary
 Solutions Fast Track
 Frequently Asked Questions

2
Chapter 1 • Introduction to the JWSDP
Introduction
T he Java Web Services Developer Pack (JW SDP) is a collection of tools and
libraries designed to make the development of Web services in Java as painless as
possible. First introduced in January 2002 as an Early Access (EA) release, the
JW SDP brings together X M L parsers, SO AP support, service containers, and
build tools that can be used to create and consume widely distributed services
based on X M L protocols.
At the time of this writing, the current release is EA2, which contains the
following components:
■
T he JAX P X M L processing libraries
■
T he JAX M  X M L messaging libraries
■
T he JAX -R PC  X M L R emote Procedure C all libraries
■
T he JAX R  libraries for accessing X M L registries
■
T he Java Secure Sockets (JSSE) library
■
JSP Standard Tag Libraries
■
T he Apache/ Jakarta Ant build tool
■
T he Apache/ Jakarta Tomcat servlet container
■
A simple U DDI registry (W SDP R egistry tool)
■
T he Web Application Deployment tool
You probably noticed that parts of the JW SDP were not written by Sun. In
fact, the JW SDP is mostly a collection of existing products; the JW SDP acts to
package these tools in a form convenient to download and install.Also, with the
JW SDP you know you have versions of the tools that work together, saving a lot
of frustration when trying to get some code working.
T his book covers the components of the JW SDP in detail. H owever, in order
to make the book something you can actually lift without heavy machinery, some
background information has been excluded. Speciﬁcally, this book won’t teach
you how to program Java (it’s assumed you already know that). It won’t teach you
details about X M L, SO AP, or other related protocols, although there will be some
coverage of those topics in order to make points clear.
T his book is focused on the libraries and tools that come with the JW SDP, and
using these tools for real-world applications.After reading this book, you should be
ready to begin writing and using Web services and X M L documents in Java.
www.syngress.com

www.syngress.com
JWSDP History
As just mentioned, the JW SDP is a collection of existing tools, and is, in some
sense, a marketing response to M icrosoft’s .N et initiative, gathering and high-
lighting existing technologies, and giving them a common name.
In most cases, this works to the beneﬁt of the user.You no longer have to
worry about what APIs are going to survive in the long run; the APIs in the
JW SDP have Sun’s blessing and are good choices to standardize on.You also don’t
have to wonder about version compatibility between different libraries; so long as
the libraries all come with the JW SDP, you shouldn’t have compatibility problems.
T here are a few places where the gathering of libraries results in some oddi-
ties. In particular, the JAX M , JAX P, and JAX -R PC  libraries were developed as
separate initiatives by the Apache X M L project and the Java C ommunity Process.
Because they were developed separately, there are places where the APIs
overlap— for instance, some functionalities in the JAX M  is also provided in JAX P.
T hese places are pointed out in the text. It remains unclear if future versions of
the JW SDP will address these issues.
T he other aspect that can be confusing about the JW SDP is that some parts
of it are available in different forms on the Web. For example, the JAX P libraries
are shipped as a part of the JDK  1.4 release. JW SDP includes these libraries for
capability with older versions of the JDK , especially as it will take some time for
vendors to migrate to supporting the newer JDK  releases.
H aving said all that, it’s worth looking at the individual components of the
JW DSP.
JAXP
T he Java API for X M L Processing (JAX P) provides standardized interfaces for
parsing and transforming X M L documents. JAX P is designed to ﬁll a hole in the
X M L standard interfaces: there are standard interfaces for transforming and parsing
X M L, but no standard interfaces for obtaining the transformers and parsers.
W hen X M L ﬁrst started gaining popularity, there were no standards for pro-
cessing it.As time went on, standards developed for processing X M L, but these
standards were all interface-based— they did not contain any required classes.
Libraries meeting the standards did so by implementing the standard interfaces
and adding their own proprietary mechanisms for creating instances of those
implementing classes. So, while your X M L processing code, based in the inter-
faces, might be portable, the small bits of code used to create those objects were
Introduction to the JWSDP • Chapter 1
3

4
Chapter 1 • Introduction to the JWSDP
not.T his meant X M L libraries could not be swapped in and out without making
small changes to the application code.
JAX P provides a standard set of interfaces, and more importantly classes, that
allow for the creation of these implementation objects. JAX P does not redeﬁne
X M L standards; instead, it leverages those standards (DO M , SAX , X SLT ) that
already have wide acceptance. JAX P ensures that code utilizing the standards will
not have to be changed if the X M L library supporting the standard interfaces is
changed.
Because JAX P does not deﬁne X M L interfaces on its own, you will ﬁnd that
some interfaces exposed in JAX P are not in the java or javax packages. Instead,
Sun chose to adopt those standards already in wide use.T his means that modi-
fying code to use JAX P will hopefully be limited to those sections of code that
create the parsers and transformers.
T he next three chapters of the book cover the three aspects of JAX P: parsing
using SAX  and DO M  parsers, and processing X M L through X SLT  transforms.
JAXM
T he Java API for X M L messaging addresses a similar problem: when the SO AP
(Simple O bject Access Protocol) standard was proposed, it did not have a standard
set of libraries for Java. N ot particularly surprising, given M icrosoft’s involvement
in the creation of the standard, but still a problem for Java programmers. JAX M
addresses this issue by providing a standard interface for SO AP 1.1 and the SO AP
with Attachments, so that Java programmers can easily send and receive SO AP
messages.
JAX M  provides a number of features above just the implementation of the
SO AP standards. It gives vendors a mechanism for supporting reliable delivery of
messages, and for partial population of SO AP messages for speciﬁc SO AP-based
protocols (such as ebX M L).
It was earlier mentioned that some areas of the JW SDP overlap. JAX M  is one
example of this. Parts of JAX M  provide a simple implementation for manipu-
lating X M L documents— an example of what JAX P provides in greater detail,
and with standard interfaces. Ideally, JAX M  would just leverage the interfaces
provided by JAX P, but it doesn’t.
T his is because JAX M  and JAX P were developed in parallel, by separate Java
C ommunity Process teams. It’s unfortunate and confusing, however, and makes the
processing of X M L documents with both JAX M  and JAX P harder. If you have to
receive a message via SO AP, and process it further (for example, with X SLT  trans-
forms), you have to transform the document from one representation to another.
www.syngress.com

Introduction to the JWSDP • Chapter 1
5
Sun has not, to my knowledge, publicly discussed this issue. H owever, one can
hope that future JAX M  releases will ﬁx this problem.
JAX M  is discussed in detail in C hapters 6 and 7 of this book.
JAX-RPC
T he Java API for X M L-based R emote Procedure C alls (JAX -R PC ) provides a
mechanism for making what appear to be object calls across a network via
SO AP-based messages. JAX -R PC  allows for the implementation of Web services
described by W SDL (Web Service Deﬁnition Language) documents— the
apparent standard for describing Web services.
W ith JAX -R PC, the implementation of what appears to be a Java object can,
in reality, be hosted on a machine across a network (including the Internet), in
any language that supports SO AP.T his gives a powerful mechanism for decou-
pling business systems. U nlike other distributed systems (C O M , C O R BA), X M L-
based R PC  can span architectures without requiring a large investment in
common support software.All that is required is you process X M L documents at
each end.T he mechanism for processing them, and the underlying system, are
completely unimportant.
JAX -R PC  acts much like R M I in that stub objects are created for use in
invoking remote objects. C onceptually, you use the two systems identically.W hat
differs between JAX -R PC  and R M I is the format of the data transferred
between the two machines. R M I uses low-level, Java-speciﬁc protocols (or
C O R BA IIO P), while JAX -R PC  uses X M L. Because of this, R M I may be
faster— since the protocols are more efﬁcient— but it is important to remember
that JAX -R PC  isn’t about performance, it’s about interoperability.
JAX -R PC, like JAX M , was a Java C ommunity Process project, and was devel-
oped in parallel. H owever, JAX -R PC  does a better job of hiding the implemen-
tation details. It does not need to expose the underlying X M L structures as much
as JAX M  did.T he current reference implementation does not appear to use
JAX P, but implementations from other vendors could (as could the reference
implementation in future releases).Again, this is a legacy from when JAX -R PC
might have been downloaded without downloading JAX P— a problem the
JW SDP (and JDK  1.4) eliminates.
JAX -R PC  is covered in C hapter 8 of this book.
www.syngress.com

6
Chapter 1 • Introduction to the JWSDP
JAXR
O nce Web services have been deﬁned via W SDL, there needs to be a mechanism
for ﬁnding them.W SDL documents are often published in registries, which pro-
vide a mechanism for the storage and retrieval of service descriptions. R egistries
allow users to search for services that will fulﬁll their needs, and download the
speciﬁcations for those services.
T he most common registry interfaces right now are the U niversal
Description Discovery and Integration (U DDI) and the ebX M L (Electronic
Business using X M L) R egistry and R epository. JAX R , the Java API for X M L
R egistries, provides an abstract interface for querying registries; JAX R  can be
used to isolate the user from having to know the speciﬁcs of either U DDI or
ebX M L R egR ep.
R egistries provide rich, complex mechanisms for categorizing services.A
large part of the JAX R  API is targeted toward providing a standardized view of
these categories.T his is the main reason JAX R  was created as a separate library,
rather than extending JN DI (Java N aming and Directory Interface, which pro-
vides a similar functionality).T he categories used by JAX R  would be meaningless
to most JN DI users, so it did not make sense to include them in the JN DI
package. O n the other hand, it isn’t possible to use W SDL registries without these
categories, therefore JAX R  is a package that stands on its own.
JAX R , like packages discussed previously, was developed in parallel. H owever,
the JAX R  committee did a good job of watching the other Java C ommunity
Process efforts, and has come up with a speciﬁcation that can be implemented
using JAX -R PC, JAX M , and JAX P.
JAX R  is covered in C hapter 9 of this book.
JSSE
At this point, you might have the impression that the JW SDP is nothing but
X M L processing.T hat isn’t really true. JW SDP is closely related to the Java X M L
pack, which is limited to those packages discussed earlier. H owever, the JW SDP
includes additional packages useful for creating Web-based applications.
T he Java Secure Socket Extension (JSSE) is a good example of this. JSSE pro-
vides a mechanism for communicating over encrypted network connections and
managing the keys associated with that encryption.
JSSE provides a royalty free implementation of SSL (Secure Sockets Layer) v3
and T LS (Transport Layer Security) 1.0 support. M ore importantly, the JSSE
www.syngress.com

Introduction to the JWSDP • Chapter 1
7
implementation may be exported from the U nited States, dramatically easing the
adoption of secure communication in worldwide organizations.
In addition to providing low-level socket support for encryption, JSSE pro-
vides additional U R L handlers, so that the java.net.U R L class can understand and
process H T T P U R Ls.T his means that Web services, which require transport-level
security, can be easily implemented in Java.
T he JSSE is discussed in C hapter 10.
JSTL
Just as Web services are not only about X M L, they are not only about business
processing.T here needs to be a mechanism for presenting functionality to end
users, as well as to remote machines. It’s common to use Java Server Pages (JSPs)
to encapsulate the user interface of an application; this provides a simpler inter-
face than coding servlets by hand.
H owever, JSPs have traditionally had to include either direct Java code or
custom-written tag libraries in order to access the underlying business function-
ality.T he JSP Standard Tag Library (JST L) is designed to help ease this burden.
JST L provides a standard set of tags for common JSP tasks, such as iterating over
a collection of objects, making database queries, and internationalizing text.
JST L also provides for expression languages, which allow the user to directly
access business objects with a simple expression. JST L currently provides support
for not one but a number of expression languages.T his allows the user to choose
the language that best suits their needs, but more importantly, protects the user
from an upcoming JSP standard that should directly include expression languages.
JST L comes directly from an Apache Jakarta project of the same name, which
later came under the Java C ommunity Process. JST L is covered in C hapter 5.
Ant and Tomcat
Like JST L,Ant comes from Apache Jakarta.Ant isn’t a Java library— rather, it’s a
build tool. It’s included with the JW SDP simply because it makes writing and
bundling Java applications easy to do.Ant comes with built-in tasks for creating
WAR  (Web Application aR chive), which are the default packing for Java Web
Services.Ant is an open-source project, whose sources can be found on
www.apache.org
Similarly,Apache Jakarta’s Tomcat is a reference implementation of the JSP
and servlet standards.As such, it allows for the development hosting of servlet-based
www.syngress.com

8
Chapter 1 • Introduction to the JWSDP
Web services, such as JAX M  supports. U nlike Ant, you likely will not use 
Tomcat for production deployments; it does not support failover, reliable 
message delivery, EJBs, or a host of other production features. H owever, it is 
free, fast, and lightweight to install; you can easily run Tomcat as a test server on
your development machine. Like Ant,Tomcat is open-source and available at
www.jakarta.apache.org/ ant.
Along with Ant and Tomcat, JW SDP includes the W SDP (Web Services
Developer Package) R egistry server.T his is a simple U DDI server, again for
development and testing use. U nlike Ant and Tomcat,W SDP is a Sun project and
is not open-source.
Ant,Tomcat, and W SDP R egistry are covered in C hapter 11.
www.syngress.com

Introduction to the JWSDP • Chapter 1
9
Summary
T he JW SDP provides a collection of libraries and tools designed to give you
everything you need to begin developing and testing Web services. In addition to
the standard interface libraries, reference implementations for each library are
provided. In some cases (JAX P), these reference implementations are production
quality; in other cases (JAX M ), they are sufﬁcient for development. In all cases,
the interfaces are designed to allow for the replacement of the reference imple-
mentations with alternative versions.
JW SDP also provides some tools to ease the development of Web services.
T hey may not replace production servers (such as IBM  WebSphere or BEA
WebLogic) and other tools, but they will allow you to begin developing Web 
services.
O nce you download the JW SDP, you have everything you need to develop
Web services.T he following chapters will walk you through all the pieces in
detail, explaining how they work and how to use them.After ﬁnishing this book,
you will be able to quickly develop high-quality Web services in Java.
Solutions Fast Track
JW SDP H istory
 T he JW SDP is a collection of existing tools.
 JW SDP is, in some sense, a marketing response to M icrosoft’s .N et
initiative— it gathers and highlights existing technologies, and gives them
a common name.
 T he JAX M , JAX P, and JAX -R PC  libraries were developed as separate
initiatives by the Apache Jakarta project and the Java C ommunity
Process. Because they were developed separately, there are places where
the APIs overlap.
JAX P
 T he Java API for X M L Processing (JAX P) provides standardized
interfaces for parsing and transforming X M L documents.
www.syngress.com

10
Chapter 1 • Introduction to the JWSDP
 Because JAX P does not deﬁne X M L interfaces on its own, you will ﬁnd
that some interfaces exposed in JAX P are not in the Java or javax
packages. Instead, Sun chose to adopt standards already widely used.T his
means that modifying code to use JAX P will hopefully be limited to
those sections of code that create the parsers and transformers.
JAX M
 JAX M  provides a standard interface for SO AP 1.1 and SO AP with
Attachments, so that Java programmers can easily send and receive SO AP
messages.
 JAX M  gives vendors a mechanism for supporting the reliable delivery of
messages, and for partial population of SO AP messages for speciﬁc
SO AP-based protocols (such as ebX M L).
JAX -R PC
 T he Java API for X M L-based R emote Procedure C alls (JAX -R PC )
provides a mechanism for making what appear to be object calls across a
network via SO AP-based messages.
 W ith JAX -R PC, the implementation of what appears to be a Java object
can, in reality, be hosted on a machine across a network (including the
Internet), in any language that supports SO AP.
 JAX -R PC  acts much like R M I in that stub objects are created to invoke
remote objects. C onceptually, you use the two systems identically.W hat
differs between JAX -R PC  and R M I is the format of the data transferred
between the two machines. R M I uses low-level, Java-speciﬁc protocols
(or C O R BA IIO P), while JAX -R PC  uses X M L.
JAX R
 JAX R , the Java API for X M L R egistries, provides an abstract interface
for querying registries; JAX R  can be used to isolate the user from
having to know the speciﬁcs of either U DDI or ebX M L R egR ep.
 T he JAX R  committee did a good job of watching the other Java
C ommunity Process efforts, and has come up with a speciﬁcation that
can be implemented using JAX -R PC, JAX M , and JAX P.
www.syngress.com

Introduction to the JWSDP • Chapter 1
11
JSSE
 JSSE provides a mechanism for communicating over encrypted network
connections and managing the keys associated with that encryption.
 JSSE provides a royalty-free implementation of SSL (Secure Sockets
Layer) v3 and T LS (Transport Layer Security) 1.0 support.
 In addition to providing low-level socket support for encryption, JSSE
provides additional U R L handlers, so that the java.net.U R L class can
understand and process H T T P U R Ls.
JST L
 JST L provides a standard set of tags for common JSP tasks, such as
iterating over a collection of objects, making database queries, and
internationalizing text.
 JST L also provides for expression languages, which allow the user to
directly access business objects with a simple expression.
 JST L currently provides support for not one but a number of expression
languages.T his allows the user to choose the language that best suits
their needs, but more importantly, protects the user from an upcoming
JSP standard that should directly include expression languages.
Ant and Tomcat
 Ant is an open-source build tool that comes with built in tasks for
creating WAR  (Web Application aR chives), which are the default
packing for Java Web Services.
 Tomcat is a reference implementation of the JSP and servlet standards.As
such, it allows for the development hosting of servlet-based Web
services, such as those JAX M  supports.
 JW SDP also includes the W SDP (Web Services Developer Package)
R egistry server.T his is a simple U DDI server, used for development 
and testing.
www.syngress.com

12
Chapter 1 • Introduction to the JWSDP
Q: W hat is the JW SDP?
A: T he JW SDP is a collection of libraries, tools, and standard interfaces designed
to ease the development of X M L-based Web services in the Java program-
ming language.
Q: H ow do I obtain JW SDP?
A: T he JW SDP can be obtained from the following Web site:
http:/ / java.sun.com/ Webservices/ Webservicespack.html.
Q: W hat version of the JW SDP does this book cover?
A: At the time this book was written, the current version of the JW SDP was the
EA2 release.T hat release is the one covered here.
Q: Is JW SDP new technology?
A: N o, in most cases the JW SDP is a consistent packaging of existing technolo-
gies. Some portions, such as the W SDP registry, are unique to the JW SDP.
Q: Is JW SDP Sun’s answer to .N et?
A: JW SDP is one aspect of the overall Java programming environment. It pro-
vides some features that compete with features in the .N et platform. O ther
parts of the Java programming environment, especially the J2EE speciﬁcation,
are equally important to consider when compared against .N et.
Q: Is there a charge for JW SDP?
A: N o, JW SDP can be downloaded free from the site listed earlier in these 
questions.
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

Processing 
XML Documents
with SAX
Solutions in this chapter:
■
Understanding Event-Based XML Parsing
■
Creating a SAX Parser
■
Parsing Data with a SAX Parser
■
Conﬁguring the Parser
■
Handling Advanced Events
Chapter 2
13
 Summary
 Solutions Fast Track
 Frequently Asked Questions

14
Chapter 2 • Processing XML Documents with SAX
Introduction
JAX P provides wrappers around two different mechanisms for processing X M L
data.T he ﬁrst is the Simple API for X M L or SAX , and is covered in this chapter.
T he second, the Document O bject M odel (DO M ), is covered in the next.
In the SAX  model, X M L documents are provided to the application as a
series of events, with each event representing one transition in the X M L docu-
ment. For example, the beginning of a new element counts as an event, as does
the appearance of text inside that element.A SAX  parser reads through the X M L
document one time, reporting each event to the application exactly once in the
order it appears in the document.
Event-based parsing has strengths and weaknesses.Very large documents can
be processed with events; there is no need to read the entire document into
memory at once. H owever, working with sections of an X M L document (a
record made up of many elements, for example) can become complicated
because the application developer has to track all the events for a given section.
SAX  is a widely used standard, but is not controlled by any industry group.
R ather, it is a de facto standard that was originally developed by a single developer
(David M egginson) and by others in the X M L community and is now supported
by an open source project (http:/ / www.saxproject.org).
T he SAX  wrapper provided by JAX P allows for plugging in different SAX
parsers without concern for the underlying implementation.T his feature is some-
what moot because there aren’t that many SAX  parsers in widespread use today.
H owever, it does provide for safeguards against changes in future versions.
Understanding Event-Based XML Parsing
O ne beneﬁt of using X M L is its inherent readability.You can take an X M L docu-
ment, print it out on paper, and show it to someone, who’ll likely make some
sense of its contents. M ost X M L documents provide some amount of context.
You can probably discern a document of product inventory levels from a docu-
ment of account balances just by looking at the tag names.
Although it helps in sharing information, sometimes all those tag names just
get in the way.T his is especially true within the conﬁnes of some programs. For
example, your program may involve reading a document of account balances, and
you may already have business objects deﬁned for Accounts and C ustomers. In
Java, you may ﬁnd it easier to work directly with objects rather than raw tags and
text.T his is where a parser can assist you.A parser takes the raw text and converts
it into something directly useable by a program.
www.syngress.com

www.syngress.com
The SAX Event Model
M ost X M L parsers fall into one of two main categories: tree-based or event-
based. Each kind of parser represents X M L information slightly differently.A
tree-based parser converts an X M L document into a tree of objects (You will
learn more about tree-based parsers in the next chapter).An event-based parser
presents a document as a series of events, each representing a transition in the
document.Taken together, these events provide your program with a complete
picture of the document.
O verview of Event Processing
Imagine again that we have printed out an X M L document. H ow would you
begin to read the document? You would probably begin at the top of the page
and continue line by line, left to right. Since you are familiar with X M L, you
know that the tags have speciﬁc meanings.You would likely take notice of where
one element ends and another begins; and with each new element you would
gain a better understanding of the complete document.
Event-based parsers work in much the same way.An event-based parser scans
through a document from top to bottom.As it scans, the parser takes notice of
interesting points in the document. For example, it would notice where one ele-
ment ends and another begins.T he parser then alerts your program, giving it the
opportunity to respond to the transition. In parser terminology, the alert is called
an event and your program’s response is a callback.A complete document parse
may consist of hundreds or even thousands of events in series. Each event pro-
vides further information about the document.
H andling hundreds or thousands of events sounds overwhelming, and there’s no
doubt that it can get complicated. Event-based parsing suits some situations better
than others.T he simpler the DT D associated with a document is, the easier it will
be to use event-based processing. O ftentimes these documents contain repeating
groups of elements, where each group is to be processed the same way. Poor candi-
date documents are much the opposite.T hey are loosely-structured or contain deep
and complex hierarchies.You may also want to avoid documents where elements
are reused throughout multiple levels of a hierarchy. For these types of documents,
consider the tree-based parsers discussed elsewhere in this book.
If you are interested in using an event-based parser, then you will need to
learn the SAX  API. Luckily, the S in SAX  stands for “Simple.” T he SAX  API
deﬁnes a simple means for interacting with event-based parsers. SAX  is a standard
part of the JAX P package; so all JAX P parsers follow the SAX  API.T he rest of
this chapter describes the SAX  API in more detail.
Processing XML Documents with SAX • Chapter 2
15

16
Chapter 2 • Processing XML Documents with SAX
H istory of SAX
SAX  was one of the ﬁrst X M L technologies for Java. It has evolved only slightly
since it was ﬁrst released, and it has certainly proven itself a stable foundation for
building X M L applications in Java. Part of its success lies in how it was developed.
It was conceived by an early group of X M L users in an open, collaborative forum.
X M L’s creators addressed a common problem: systems from one vendor could
not easily communicate with systems from another. X M L breaks down those bar-
riers by introducing a standard way to represent data. O nce the standard was in
place, early X M L users began to focus on the problem of reading and incorpo-
rating X M L into their applications.
It soon became clear that there was room for more than one parser, and quite
a few companies developed their own implementations. Some of these parsers
adopted the same basic approach, relying on an event-based model to parse docu-
ments.Although early parsers read X M L documents just ﬁne, they each presented
results in a proprietary manner, and it became difﬁcult to compare the various
parsers one-on-one, especially for conformance with the X M L spec. M ore
importantly, users needed to learn new APIs for each parser. Suddenly, a tech-
nology created for interoperability was under threat of fragmentation by propri-
etary implementations.
Parser developers agreed that interoperability was a good idea for parsers, too.
O ne early parser implementer, David M egginson, proposed a scheme for stan-
dardizing the interface to all event-based parsers. H e solicited input from other
interested members of the X M L community, and then demonstrated the new
scheme in his own early parser, Æ lfred.T he scheme was donated to the X M L
developer community as the Simple API for X M L Processing.
SAX  was primarily the work of one driving individual and several interested
contributors. It was released without the backing of a formal sponsor or standards
body. It found success, however, because it addressed a clear need in the X M L
community. Parser developers could write to one half of the API, and parser users
could write to the other half.T his leveled the playing ﬁeld for parser imple-
menters and parser users alike. Furthermore, SAX  was simple to understand and
to implement. It made learning the technologies less confusing and encouraged
further adoption of X M L.
SAX  caught on and is now maintained by an open-source community, which
can be found at http:/ / www.saxproject.org.T he community’s job is to evolve the
standard as X M L itself evolves. For example, after the initial release, it soon
became clear that X M L namespaces would take an important role in X M L’s
www.syngress.com

Processing XML Documents with SAX • Chapter 2
17
future.T he SAX  community responded by publishing SAX  Version 2.0 with
better support for namespaces. Since then, little has changed in the core of SAX
except minor clariﬁcations and bug ﬁxes. O ver time, it has proven to be a com-
plete and stable package.
Basic SAX  Events
T he X M L language allows us to build very complex documents while learning
only a few simple rules. For example, all X M L documents must start with one
root element. Elements in turn may contain more elements, attributes, and text in
any number of combinations.T here are only a handful of other concepts - namely
entities, namespaces, and Document Type Deﬁnitions.T hese latter concepts are
indeed important, but they are secondary to understanding and using X M L.
Elements, attributes, and text remain the foundation of any X M L document.
SAX  includes at least one event for each of the basic X M L structures, and
since there are only a handful of basic X M L structures, there are only a handful
of SAX  events.T his is part of what makes SAX  simple to learn and use; a real
world X M L document may be large and complex, but it can still be broken
down into the basic events outlined below.
H ere are the basic SAX  events:
D ocument E vents
Document events notify your program of the beginning and end of an X M L
document.A SAX  parse always begins with a start document event and ends with
an end document event.T he end document event is particularly useful because it’s
the SAX  parser’s signal that the parse is complete.
E lement E vents
Element events notify your program of the beginning and end of each element.
T he SAX  parser creates a start element event for each opening tag in the docu-
ment. Likewise, it will create an end element event for each closing tag it ﬁnds.
Empty elements, or those without content, may not have distinct start and
end tags. H owever, the SAX  parser will still create both a start and end event for
any empty element.
C haracter E vents
C haracter events notify your program of any character data found between ele-
ments. C haracter data includes any text, entities, and C DATA sections.
www.syngress.com

18
Chapter 2 • Processing XML Documents with SAX
SAX  includes a few other events that are useful in special situations.T hese
advanced events cover some of X M L’s advanced concepts, including:
■
namespaces
■
entities and entity declarations
■
ignorable whitespace
■
processing instructions 
We will cover the advanced events in greater depth further in this chapter.
Example Parse Events
Figure 2.1 shows a clearer picture of how events ﬁt together. It illustrates an
example X M L document and the event sequence created by the SAX  parser.As
you can see, even a simple X M L document results in quite a number of events.
Understanding Event Handlers
Events by themselves aren’t very interesting, especially if nothing listens for the
events.W hen the parser creates an event, however, your program has the oppor-
tunity to respond. It’s up to you as the programmer to supply the logic to handle
the events.You provide that logic by writing an event handler.
O verview of H andlers
T he SAX  parser and the event handler work in unison to parse an X M L docu-
ment. First, the SAX  parser notiﬁes the event handler of every event it creates.
www.syngress.com
Figure 2.1 Example XML with Associated Parse Events
<?xml version="1.0">
<root>
      <item>
             This is an
             example item.
     </item>
     <notes/>
</root>
1. start document
3. start element “item”
6. start element “notes”
7. end element “notes”
8. end element “root”
9. end document
5. end element “item”
4. character (1 or more)
2. start element “root”

Processing XML Documents with SAX • Chapter 2
19
T he event handler then services the event before passing control back to the
parser. In servicing the event, your event handler can interpret the event in what-
ever manner you see ﬁt. Parsing an X M L document thus shifts back and forth
between the parser and the event handler.
C ontentH andler
T he C ontentH andler is the core interface of any SAX  parser. It deﬁnes the most
frequently used callbacks in the SAX  API. O nce you have a class that implements
the C ontentH andler interface, you are ready to begin using SAX  in your programs.
C ontentH andler deﬁnes ten distinct callbacks, so you would need to write ten dis-
tinct methods to implement your own C ontent H andler.
D efaultH andler
You can easily create a class to implement all the SAX  callbacks, but there’s an
even easier way to get started.T he SAX  package includes the D efaultH andler class
to get you up and running quickly.You have already learned that SAX  includes
both frequently used events and less frequently used events.T he D efaultH andler
class allows you to concentrate on the frequently used events that are most inter-
esting for your purposes.
T he D efaultH andler serves as a concrete implementation of the C ontentH andler
interface, and deﬁnes simple callbacks for every event. H owever, the callbacks 
do nothing more than consume the events, making it an extremely basic imple-
mentation.
To create a more interesting event handler for your program, extend the
D efaultH andler with your own subclass.You can provide your own implementa-
tion for only those callbacks that interest you most and ignore the other, less fre-
quently used callbacks. If you do not implement a callback for a particular event,
then the D efaultH andler’s callback will take care of it.
Basic SAX  C allbacks
You have already learned about the basic SAX  events; here we describe the basic
SAX  callbacks. Each SAX  event requires its own corresponding callback.W hen
the SAX  parser creates a particular event, the parser will call the appropriate call-
back method, as outlined below.
D ocument C allbacks
Document callbacks handle the corresponding document events that occur at the
beginning and end of an X M L document.T he SAX  parser begins every parse
www.syngress.com

20
Chapter 2 • Processing XML Documents with SAX
with a call to the startD ocument() callback method.T he startD ocument() callback is
an excellent place to perform any necessary initialization before continuing with
the parse.
public void startDocument() throws SAXException;
public void endDocument() throws SAXException;
Likewise, the parser ends with a call to endD ocument(). T his is the ﬁnal event
provided by the SAX  parser, and signals that the parse is complete.
E lement C allbacks
T he element callbacks execute at the beginning and end of each element.T he ele-
ment callbacks are much more interesting than the document callbacks because the
SAX  parser includes information parsed right out of the X M L document.T his
information includes the element’s name, namespace U R I, and attributes.
public void startElement(String uri, String localName,
String qName, Attributes atts) 
throws SAXException
public void endElement(String uri, String localName,
String qName) throws SAXException
T he element’s name is probably of most immediate interest. It gives some
sense of the parser’s progress through the document.You ﬁnd the name of the
parsed element in one of two parameters: the localN ame or the qN ame, which are
each used in slightly different situations.T he localN ame is interesting only while
processing namespaces. Since namespace processing is disabled by default, we’ll
ignore the localN ame for now. Instead, look for the element name in the qN ame
parameter.We’ll discuss the differences between the localN ame and qN ame when
we explore namespace processing later in this chapter.
A typical callback method will begin by interpreting the current element’s
name. Different elements may require different actions, so the callback must
choose an action based on the element’s name. H ere is a simple example:
public void startElement(String uri, String localName,
String qName, Attributes atts) 
throws SAXException
{
if (qName.equals("order"))  
{
www.syngress.com

Processing XML Documents with SAX • Chapter 2
21
//code to handle <order> element
}
else if (qName.equals("orderItem"))
{
//code to handle <orderItem> element
}
}
If the element includes any attributes, the event will provide an A ttributes
object.T he A ttributes object contains the names and values of any element
attributes.To ﬁnd the value of an attribute, simply refer to a speciﬁc attribute by
name. For example:
String value = atts.getValue("id"); // return the value of
// the "id" attribute 
C haracters C allback
T he characters callback handles any character events from the parser.As it scans
the document, the SAX  parser reads characters into an array.T his includes text,
entities, and C DATA sections.T he parser then passes the array to the characters()
callback method.
Importantly, the SAX  parser may reuse the array between calls, so it may con-
tain more than just the characters for the most recent event.T he start and length
parameters help you ﬁnd the valid characters.T he start parameter provides the
offset into the array, while the length parameter provides the number of characters
for the most recent event.
public void characters(char[] ch, int start,
int length) throws SAXException
U nlike other events, it’s difﬁcult to predict just when or how many character
events will occur. For any group of characters, the SAX  parser is free to decide
how many events to create. You cannot assume the parser will report a group of
characters with one event; it may choose to report the characters with one event
per line, or even one event per character.T he SAX  standard provides a lot of
freedom here for parser implementations, so we cannot expect all parsers to
behave identically.T he example below describes  a technique for dealing with this.
www.syngress.com

22
Chapter 2 • Processing XML Documents with SAX
Example Event H andler
To get a better idea of how the callbacks ﬁt together, we’ll implement a basic
SAX  event handler and associated callbacks. H owever, before we can even begin
to design an event handler, we must ﬁrst understand the structure of the X M L
document to be parsed. In this example, we will be building part of an applica-
tion to help manage a company’s inventory. H ere is an typical X M L document
containing information about the example company’s wares and its inventory:
<?xml version="1.0" encoding="UTF-8"?>
<INVENTORY>
<ITEM>
<SKU>3956</SKU>
<DESCRIPTION>widget</DESCRIPTION>
<QUANTITY>108</QUANTITY>           
</ITEM>
<ITEM>
<SKU>5783</SKU>
<DESCRIPTION>gadget</DESCRIPTION>
<QUANTITY>32</QUANTITY>            
</ITEM>
<ITEM>
<SKU>6583</SKU>
<DESCRIPTION>sprocket</DESCRIPTION>
<QUANTITY>7</QUANTITY>         
</ITEM>
</INVENTORY>
O ur example handler will read the X M L document above and convert it into
something more useful. In this example, we’ll construct an object representation
of the items in the company’s inventory. O ur business objects (of type “Item”)
simply hold the values from the X M L document.After parsing, the business
objects may then be manipulated further by the client application. C onverting
X M L into objects is a very common application of SAX , so you may ﬁnd these
techniques useful for your own programs.
H ere is the example event handler with its callbacks:
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.SAXException;
import org.xml.sax.Attributes;
www.syngress.com

Processing XML Documents with SAX • Chapter 2
23
/**
*  This class implements a SAX event handler for parsing
*  item inventory levels from an XML document.
*/
public class InventoryHandler extends DefaultHandler
{
private Item currentItem;     //item model object
private ItemCollection items; //parse results holder
private StringBuffer characters; //buffer for element content
/**
* SAX callback to handle character events
*/
public void characters(char[] ch, int start, int length) 
throws SAXException
{
characters.append(ch,start,length);
}
/**
* SAX callback to handle start of document
*/
public void startDocument() throws SAXException
{
// Initialize before parsing this document
characters = new StringBuffer();
items = new ItemCollection();
}
/**
* SAX callback to handle start of each element.
*/
public void startElement(String uri, String localName, 
String qName, Attributes aAttribs)
throws SAXException
www.syngress.com

24
Chapter 2 • Processing XML Documents with SAX
{
if (qName.equals("ITEM"))
{
//Create a new Item object to hold Item data
currentItem = new Item();
}
//Prepare character buffer for element content
characters = new StringBuffer();
}
/**
* SAX callback to handle end of each element.
*/
public void endElement(String uri, String localName, 
String qName) throws SAXException
{
//read element contents from buffer
String content = characters.toString();
if (qName.equals("SKU"))
{
//We have just parsed a SKU
currentItem.setSKU(content);
}
else if (qName.equals("QUANTITY"))
{
//We have just parsed a QUANTITY
currentItem.setQuantity(content);
}
else if (qName.equals("ITEM"))
{
//We have ﬁnished parsing one item. Save in
//collection before we parse another.
items.add(currentItem);
}
}
}
www.syngress.com

Processing XML Documents with SAX • Chapter 2
25
T he event handler code may be difﬁcult to follow until you consider the
original X M L document.T he X M L document itself drives the sequence of
events created by the parser.W ith each event, the parser will call the appropriate
callback method. Each callback in turn processes a small portion of the docu-
ment.To better understand the order of execution, it helps to envision the parser
as it scans the X M L document. C onsider the parser’s progress through the
example document:
1. Document start T he parser triggers the startD ocument callback.We
begin by initializing any data structures needed for the parse.
2. <INVENTORY> element T he parser triggers its ﬁrst startE lement
callback.T he inventory element doesn’t tell us anything useful, so we
move on without performing any special processing.
3. <ITEM> element T he parser triggers a second startE lement callback.
We are now parsing information about a particular item.T his is our
opportunity to create a new data structure to hold information about
the coming item.
4. <SKU> element T he parser triggers yet another startE lement callback.
We are about to read information about the SK U, but we must wait for
a subsequent character event for the SK U  itself.
5. Element content T he parser passes in the SK U  data itself through one
or more calls to the characters callback. R emember, the element content
may all appear in one callback, or it may be broken up into multiple
callbacks.T hus, we collect the character data in a buffer.
6. </ SKU> end element T he parser triggers its ﬁrst endE lement callback,
letting us know that we have ﬁnished reading in the element content.
We interpret the content as a SK U  and add it to our model object.
7. <QUANTITY/ > and <DESCRIPTION/ > elements T he parser
handles these in much the same way as the <SK U / > element, repeating
steps 4 through 6 for each element. For this particular example, our code
ignores the <D E SC R IP T IO N / > element completely.T his is one of the
key beneﬁts of event-based parsing. SAX  allows us to save some parts of
the document while ﬁltering out others completely.
8. </ ITEM> W ith the endE lement callback, we have completely read one
item.We add the completed item to a collection to be retrieved later.
www.syngress.com

26
Chapter 2 • Processing XML Documents with SAX
9. <ITEM/ > If the document contains additional items, then steps 3
through 8 will be repeated until all items have been read.
10.
</ INVENTORY> T he parser triggers one last endE lement callback.
11.
Finally, the parser terminates with an endD ocument callback.We defer to
the D efaultH andler’s implementation since our handler does not provide
its own implementation.T he D efaultH andler simply consumes the event.
W hen the parse is complete, the InventoryH andler will have created a 
complete object representation of the original X M L document. R unning this
InventoryH andler against an X M L document requires a few more pieces, however. It
must be combined with a SAX  parser and a source of X M L data.We’ll pick up this
example in later sections, adding the other components to complete the picture.
Creating a SAX Parser 
T he SAX  parser does much of the heavy lifting in reading an X M L document,
while you only need to provide a simple event handler. In this section, you’ll
learn how to instantiate the parser itself.
SAX Interfaces and SAX Implementations
Interoperability among parsers was one of the original design goals of SAX .T he
SAX  creators wanted to make it easy for developers to swap in one parser for
another.T his is accomplished through heavy use of interfaces, which are an
excellent way to shield developers from underlying implementations. In SAX , this
shield works two ways: It protects both the SAX  user and the parser.
We’ve already seen how this works with the event handler interface described
in the previous section.As a SAX  user, you implement the C ontentH andler inter-
face yourself.W henever the parser needs to communicate with your application,
it does so only through the narrowly deﬁned C ontentH andler interface.T he SAX
parser never concerns itself with the speciﬁcs of your implementation; it simply
creates events and passes them through the C ontentH andler interface.
SAX  deﬁnes another interface speciﬁcally for SAX  parser implementers. H ere
the roles are reversed:T he SAX  parser implements the X M L R eader interface,
through which you communicate with the parser.T he X M L R eader is the main
SAX  interface to the underlying parse engine: it deﬁnes every action you can
perform with the parser, such as providing it with an X M L document or initi-
ating a parse.
www.syngress.com

Processing XML Documents with SAX • Chapter 2
27
W ith these two interfaces, the parser and the event handler remain virtually
decoupled.T hey can each proceed without ever acknowledging one another’s con-
crete implementation, which is an excellent quality because it allows you to write
applications that are independent of the underlying SAX  engine. In fact, you can
write an entire SAX  application without ever referring to a speciﬁc SAX  parser.
JAXP and Underlying SAX Engines
So far we’ve talked a lot about SAX  but not a lot about JAX P.T he reason for this
is simple: SAX  is very much complete and usable in and of itself.T hat being said,
JAX P adds some important reﬁnements that merit discussion.
Introducing the JAX P Package
JAX P essentially bundles a number of existing X M L technologies into one con-
venient and uniﬁed framework. M ost of these technologies— including SAX —
predate JAX P itself. Further, existing applications may be using SAX
independently of JAX P, so JAX P strives to ensure backwards compatibility. O ne
result is that under JAX P, existing X M L classes maintain their original naming
conventions.T his can be rather confusing at ﬁrst, so it helps to understand how
things are organized.
First, the core SAX  classes are located in their original SAX  packages.T hese
are found in the following packages:
org.xml.sax.*
org.xml.sax.helpers.*
JAX P introduces several new classes in several new packages.T he classes for
working with SAX  parsers are located here:
javax.xml.parsers.*
T he new JAX P classes add a “plugability layer” over the existing SAX  inter-
faces.W ith JAX P, you can plug a SAX  engine into the Java runtime and then
refer back to it through the JAX P API. H ere, we’ll see how to use this plugability
layer to create applications that are portable across SAX  engines.
U sing the SA X ParserF actory
T he core SAX  API merely provides an interface to the underlying SAX  parser. If
you’ve worked with interfaces before, you know that you can’t create an object
instance directly from an interface. H owever, you could always instantiate a SAX
www.syngress.com

28
Chapter 2 • Processing XML Documents with SAX
parser by name if you knew about the underlying implementation and its con-
structors.T his latter approach would make your code dependent on a speciﬁc
SAX  parser.
Fortunately, JAX P allows us to construct parsers in a manner that is com-
pletely portable. It provides an abstract factory mechanism for constructing
parsers irrespective of the underlying implementation. U se the abstract factory
class, called SA X ParserF actory, to construct an instance of a parser. It is actually a
two-step process:You ﬁrst, obtain an instance of the concrete factory, and then
you obtain a concrete parser from the concrete factory:
SAXParserFactory factory = SAXParserFactory.newInstance();
SAXParser parser = factory.newSAXParser();
By applying the factory, we avoid referencing any speciﬁc SAX  engine by name,
which helps to keep things portable.T he JAX P factory’s newInstance() method
ends up returning a concrete SAX  factory for a speciﬁc SAX  engine, but we
never concern ourselves with the concrete implementation’s details. In the next
section, you’ll learn how the newInstance() method makes its selection.
W ith the concrete factory in hand, we can begin to build concrete instances
of the parser.T he newSA X Parser() factory method creates instances of JAX P’s
SA X Parser class.T he SA X Parser class is just a simple wrapper over the SAX ’s stan-
dard X M L R eader parser class. It also provides a few convenience methods for
interacting with the underlying parser.
NOTE
Although SAX originally included its own parser factory, only the new
JAXP factories provide for plugability. Use JAXP’s SAXParserFactory to
instantiate a parser, and ignore SAX’s older XMLReaderFactory.
Selecting a SAX  Parser with the Plugability Interface
T he JAX P plugability layer always provides a valid SAX  engine, but how do we
know exactly which engine it provides? T he answer lies within SA X ParserF actory’s
newInstance() method.T he newInstance() method searches the target environment at
runtime for a suitable SAX  engine. It searches the following places in order:
1.
System property space
2.
JAX P properties ﬁle
www.syngress.com

Processing XML Documents with SAX • Chapter 2
29
3.
JAR  metaﬁle
4.
Platform default 
System P roperty Space
JAX P begins its search by querying for a system property named javax.xml
.parsers.SA X ParserF actory.To force JAX P to use a particular engine, simply set the
property to the name of a speciﬁc SAX  implementation.You can set this at run-
time through the command line. For example, starting Java as follows will force
JAX P to use the X erces X M L parser:
java -Djavax.xml.parsers.SAXParserFactory=
org.apache.xerces.jaxp.SAXParserFactoryImpl  <your main class>
JA X P  P roperties F ile
If you choose not to set the system property, JAX P will look in a speciﬁc proper-
ties ﬁle for the information.T he properties ﬁle, called jaxp.properties, must be
installed as a Java extension. Simply create a properties ﬁle with the same key and
value as above and save it to your Java runtime environment’s JR E/ lib directory.
T his is convenient because you only need to go through this once; there’s no
need to set system properties everytime you run.
JA R  M etaﬁle
JAX P provides a third method that is more complicated but more powerful than
the ﬁrst two methods.T his is where JAX P will most likely ﬁnd its parser, so it is
important to understand how it works. Basically, JAX P looks for a preferred SAX
engine within each JAR  ﬁle in the classpath.T he name of the preferred SAX
engine is tucked away in a metaﬁle within the JAR  ﬁle itself. C onveniently, most
JAX P parsers already contain this metaﬁle.T hus, the simple act of adding your
parser’s JAR  ﬁle to the classpath is all that’s needed to access this functionality. If
you’d like to introduce a new parser, simply place it somewhere forward in the
classpath and JAX P will automatically conﬁgure itself to use the parser, without
forcing you to explicitly set any properties.
P latform D efault
Finally, some Java environments offer a default SAX  engine.T his is the case with
Sun’s new Java Development K it version 1.4, which bundles a number of X M L
technologies.W hen all else fails, JAX P will use the platform’s default SAX  engine.
www.syngress.com

30
Chapter 2 • Processing XML Documents with SAX
JAX P plugability can simplify the task of distributing SAX  applications, because
you don’t necessarily need to bundle a SAX  parser.As long as your code follows
www.syngress.com
Parser Proliferation
If XML continues to grow in popularity, XML parsers may eventually
become ubiquitous. Already, XML is an integral part of many products.
These products may bundle their own XML parsers; if these are Java
products, then chances are the XML parsers use SAX. For example, if you
are using a modern Integrated Development Environment, it likely
includes a SAX parser, soyou may already have a SAX-compliant parser
in your possession without even realizing it.
As you begin to work with XML, here are some of the parsers you
will likely encounter:
■
Xerces 1 Xerces 1 is the workhorse of modern parsers. It is
SAX 2.0 compliant but does not support the JAXP plugability
layer. Even so, many XML tools, development environments,
and application servers still depend on the Xerces parser. If
you are developing for a server-side environment, check to
see if your application server requires you to use Xerces.
■
Crimson Sun originally developed this parser as a tech-
nology demonstration, then donated it to the open-source
community. Now it has found its way back into Sun’s
product fold. Crimson is the standard parser in JAXP 1.1, 
and it is the standard parser bundled with Sun’s Java
Development Kit version 1.4. 
■
Xerces 2 Xerces 2 is a next-generation, high performance
XML parser. Xerces 2 is the standard parser included with
JAXP 1.2, which makes it a sign of things to come.
Eventually, it should replace both Xerces 1 and Crimson in
Sun’s lineup.
As XML standards continue to evolve, we can expect XML parsers
to evolve with the standards. Newer parsers may offer extra features,
like schema-based validation in the Xerces parser. JAXP insulates you
from these changes without preventing you from using them to full
effect.
Developing & Deploying…

Processing XML Documents with SAX • Chapter 2
31
the SAX  standard, you can be reasonably conﬁdent it will work with whatever
SAX  engine is available. O f course, it is always best to test your application thor-
oughly with each parser. If you notice any difference, you can always bundle a SAX
parser with your application and conﬁgure JAX P to use your preferred parser.
Parsing Data with a SAX Parser
Parsing with SAX  requires three things: an event handler, a parser instance, and an
X M L document to be parsed.You’ve already learned how to write an event han-
dler and how to create a parser instance; this section describes how to combine
an event handler and parser along with an X M L document itself.
Input Sources
X M L documents may be static or dynamic. Static documents may be stored in a
ﬁle system or document repository, whereas dynamic documents may be assem-
bled on the ﬂy from databases or other enterprise systems. Either may be trans-
mitted electronically through any number of networking protocols.W hatever its
source, you can ﬁnd a way to parse the document with SAX .
InputSource
U se the SAX  InputSource class to pass the X M L document to a parser.T he
InputSource object allows the parser to locate the X M L data.
U R I-based Sources
If you know the X M L document’s exact location, you can create an InputSource
directly from a U niform R esource Identiﬁer (U R I).T his method works particu-
larly well for reading in static documents from your local ﬁle system.You can also
read documents over the Internet using the H T T P protocol:
InputSource fromFile = new InputSource("ﬁle:///"+aFilename); 
InputSource fromWeb  = new InputSource("http://www…");
Stream-based Sources
M any applications may not deal with static X M L documents on a physical disk.
T his is particularly true of web services, where X M L messages may be con-
structed on the ﬂy and passed electronically. For these types of sources, you may
construct an InputSource directly from a stream:
www.syngress.com

32
Chapter 2 • Processing XML Documents with SAX
InputSource byteSource = new InputSource( someInputStream );
InputSource charSource = new InputSource( someReader );
Stream-based sources provide a lot of ﬂexibility, but they also come with
some additional responsibility.W ith stream-based sources, you may need to pro-
vide additional information to help the parser correctly interpret the source. For
example, when working with byte streams, the parser must convert the bytes into
characters. It then becomes important to tell the parser how the characters are
encoded. If you’ve set the character encoding within the document’s X M L decla-
ration, then the parser should be able make the conversion on its own. H owever,
if you’ve failed to set the encoding within the document, you should set it on the
InputSource itself. For example, to set the stream’s encoding to U T F-8, use the fol-
lowing method:
byteSource.setEncoding("UTF-8");
C haracter encodings can get quite complex and SAX  parsers are not required to
support all encodings known to man. Generally, parsers support at least the
common encodings, including U S-ASC II, ISO -Latin-1, and U T F-8. If you are
working with international content, make sure that your X M L parser can under-
stand the encoding for your content.
An Example Servlet
You’ve just about learned everything needed to begin building SAX  applications.
You’ve learned how to construct a parser, create an event handler, and locate an
input source. N ow we will demonstrate how to put these pieces together into a
complete application.T he example application is part of a ﬁctitious company’s
inventory management system.
Earlier in this chapter, we created an event handler to read information about
the company’s inventory.T his example picks up where the ﬁrst example left off: it
adds a source of X M L data and a parser instance to the original event handler.
T he three pieces are combined within a servlet, providing web-based access to
the company’s inventory.
In continuing this example, we’ve made some slight alterations to the original
event handler. M ost importantly, we’ve added a method to retrieve the parsed
results from the event handler.T he servlet itself calls this method after completing
the parse. Secondly, the event handler no longer skips anything from the example
X M L document. It now reads all information for each inventory item, including
its full description. Figure 2.2 shows the servlet’s complete output.
www.syngress.com

Processing XML Documents with SAX • Chapter 2
33
Below you’ll ﬁnd the code for the servlet that produced the output in Figure
2.2.W hen examining the code, begin with the servlet’s init() method. If you are
familiar with servlets, you know that the init() method is a good place to perform
any initialization work. In our case, it’s a perfect place to instantiate a parser fac-
tory from JAX P’s abstract factory.T he init() method is only called once, so we
save the factory within a member variable.
After initialization, the servlet waits for any user requests. Each request to the
servlet invokes the servlet’s get() method.T he get() method is where the servlet
constructs an event handler, a parser, and an input source.After running the
parser, the servlet obtains the results of the parse from within the event handler.
Finally, it iterates through the parsed results and displays them in a simple table.
import java.util.Iterator;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
www.syngress.com
Figure 2.2 Example Servlet Output

34
Chapter 2 • Processing XML Documents with SAX
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.ParserConﬁgurationException;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
public class InventoryServlet extends HttpServlet
{
//share one instance of the parser factory
private SAXParserFactory parserFactory;
/**
* Initializes the servlet. The servlet container
* will only call this method once!
*/
public void init() throws ServletException
{
//instantiate a concrete factory
parserFactory = SAXParserFactory.newInstance();
}
/**
* Handles a GET request to this servlet.
*/
public void doGet(HttpServletRequest request, 
HttpServletResponse response)
throws IOException, ServletException
{
//contruct custom event handler
InventoryHandler eventHandler = new InventoryHandler();
//obtain SAX parser instance
SAXParser parser = null;
try
{
www.syngress.com

Processing XML Documents with SAX • Chapter 2
35
parser = parserFactory.newSAXParser();
}
catch (ParserConﬁgurationException pce)
{
throw new ServletException("Error constructing parser.", pce);
}
catch (SAXException se)
{
throw new ServletException("Error constructing parser.", se);
}
try
{
//provide XML document
String uri = 
"ﬁle:///C:/samples/inventory.xml";
InputSource sourceDoc = new InputSource(uri);
//initiate the parse
parser.parse(sourceDoc,eventHandler);
}
catch (SAXException se)
{
throw new ServletException("Error parsing inventory.", se);
}
//retrieve and print results
ItemCollection items = eventHandler.getParseResults();
printItems( items, response.getOutputStream() );
}
/**
* Prints output as HTML.
*/
private void printItems(ItemCollection items, 
ServletOutputStream out)
throws IOException
www.syngress.com

36
Chapter 2 • Processing XML Documents with SAX
{
Iterator iter = items.iterator();
//set up the HTML
out.println("<HTML><BODY><H2>Inventory Summary:</H2>");
out.println("<TABLE><TR ALIGN='CENTER'>");
out.println("<TH WIDTH='30%'>SKU</TH>");
out.println("<TH WIDTH='40%'>Description</TH>");
out.println("<TH WIDTH='30%'>Inventory Level</TH></TR>");
//print a table row for each item
while (iter.hasNext())
{
Item currentItem = (Item) iter.next();
out.println("<TR ALIGN='CENTER'>");
out.println("<TD>"+currentItem.getSKU()+"</TD>");
out.println("<TD>"+currentItem.getDescription()+"</TD>");
out.println("<TD>"+currentItem.getQuantity()+"</TD>");
out.println("<TR>");
}
//close out the HTML
out.println("</TABLE></HTML>");
out.ﬂush();
}
}
Servlets and M ultithreading 
Servlet-based applications are multithreaded by nature so it is important to keep
multithreading in mind when working with servlets.T he example servlet demon-
strates how to apply SAX  within a multithreaded environment.T he most impor-
tant thing to remember is that SAX  parsers are not thread safe.Although you may
reuse one parser to parse several documents, you can’t reuse it to parse several
documents at the same time. O ur servlet’s get() method therefore constructs a
new parser with each user request, allowing the servlet to handle multiple users
simultaneously.
www.syngress.com

Processing XML Documents with SAX • Chapter 2
37
Parser instances cannot be shared between threads, but the SA X ParserF actory
can be shared under certain circumstances.T he example servlet maintains only
one instance of the factory, and it refers back to that instance over and over again
within the servlet’s get() method.T his works ﬁne in a multithreaded environment
because the SA X ParserF actory’s newSA X Parser() method is declared to be thread
safe. C onsequently, we can safely use the factory object in many threads at once.
www.syngress.com
Using Locators to Aid Debugging
XML applications are often data-driven, and this can make them espe-
cially difﬁcult to debug. Your program’s execution depends not only on
the correctness of your code, but also the that of every XML document
processed. If your event handler is not doing what you expect, start by
getting a better understanding of the event sequence. Once you under-
stand the parser’s progress through the XML document, you can begin
to diagnose the problem.
Traces are a basic technique for understanding the event sequence.
Within your event handler, create a trace routine that prints out mes-
sages to the screen or to a log ﬁle. Then, call the trace routine at the
start of every event callback. The trace output should give you a clearer
picture of the event sequence, much like that shown in Figure 2.1.
While tracing is useful for debugging small documents, it can
quickly become unwieldy; a large document may produce thousands of
events, so following the event trace may be overly tedious. For complex
documents, correlating the trace with the original document may still
pose challenges. Fortunately, SAX includes a mechanism to help you
make better sense of your trace output.
Use the Locator mechanism to make tracing even more effective.
The Locator object provides the parser’s exact location as it scans
through the XML document. It will help you zero in on the position of
events within the document. To begin using the Locator within your
event handler, ﬁrst implement the setDocumentLocator() method to
save a reference to the Locator itself. (The SAX parser calls this method
to hand you the Locator.) During the parse, query the Locator whenever
you need to know the parser’s position:
Debugging…
Continued

38
Chapter 2 • Processing XML Documents with SAX
Conﬁguring the Parser
R eal world X M L documents are rarely as simple as those demonstrated in Figure
2.2.T his is especially true in web services, where X M L documents often partake
in complex exchanges.Web services present a couple of challenges: First, the
X M L documents must conform to an agreed-upon structure. Second, the
meaning of each tag must not be misinterpreted.
Two X M L features help deal with each of these challenges. First, Document
Type Deﬁnitions (DT D) allow you to validate a document’s structure. Second,
namespaces allow you to associate elements with speciﬁc X M L grammars.T hese
features are used prominently in web services.Together, they help keep commu-
nications running smoothly.
All SAX -compliant parsers include support for both DT Ds and namespaces,
whereas speciﬁc SAX  parsers may provide other special capabilities as well.T his
section describes how to enable these features and use them in your applications.
www.syngress.com
private void traceEvent(String eventMessage)
{
System.out.print("Event:"+eventMessage);
// if locator is set, print line and column
if (this.locator != null)
{
int line = this.locator.getLineNumber();
int column = this.locator.getColumnNumber();
System.out.println(" at line: "+line+
" and column: "+column);
}
}
Ofﬁcially, the Locator mechanism is an optional part of SAX. As
with any optional feature in SAX, it’s a good idea to check that the
parser supports it. Thus, the code above ﬁrst checks for the Locator’s
presence. You will ﬁnd that most common parsers supply a Locator,
simply because it’s so useful.

Processing XML Documents with SAX • Chapter 2
39
Enabling Validation
If your X M L document refers to a DT D, you may want to enable DT D valida-
tion.W ith DT D validation, the SAX  parser will check the structure of the docu-
ment against the DT D as it parses; if the document’s structure does not match
the DT D, the parser responds with an error.
U se JAX P’s SA X ParserF actory class to enable validation. O nce enabled, the val-
idating option will apply until it is changed.Any new parsers created through the
factory will perform DT D validation.Try the following code to create one or
more validating parsers:
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setValidating(true);
SAXParser validatingParser = factory.newSAXParser();
SAX  provides a couple of other mechanisms that work hand-in-hand with
DT D validation.W hen using validation, you may want to specify a D T D H andler
and an E rrorH andler in along with your usual event handler.T he D T D H andler
assists in parsing the DT D itself, while the E rrorH andler can deal with any valida-
tion errors. N either of these is necessary to use DT D validation, but we’ll get
back to these in the next section.
Finally, you should understand that validation incurs a performance penalty
because validating a document is simply extra work for the parser. If performance
is a critical part of your application, you may want to reconsider using any valida-
tion.As a tradeoff, consider turning on validation during testing and turning it off
during production.
Enabling Namespaces
SAX  includes support for processing X M L namespaces. Like DT D validation,
namespace processing is a special feature that must be explicitly enabled. U se
JAX P’s SA X ParserF actory class to enable namespace processing. O nce enabled, any
new parsers created through the factory will read and interpret any namespace
declarations and namespace preﬁxes used in the document.Try the following
code to create a namespace-aware parser:
SAXParserFactory factory = SAXParserFactory.newInstance();
factory.setNamespaceAware(true);
SAXParser validatingParser = factory.newSAXParser()
www.syngress.com

40
Chapter 2 • Processing XML Documents with SAX
NOTE
JAXP disables namespace processing by default. This is in slight contrast
with the stand-alone SAX package, where namespace processing is
enabled.
N amespaces and Events
N amespace processing makes SAX  parsing a little more complicated. N amespaces
are an extra piece of information to juggle, both for you and for the parser.W ith
namespaces enabled, the SAX  parser reads any namespace declarations from the
document and locates the corresponding namespace for each and every element
in the document. Finally, it interprets the namespace preﬁxes with each element
or attribute.T he SAX  parser provides all this information to you through stan-
dard SAX  callbacks, and its up to you to make sense of it all.
H ere is how namespaces inﬂuence the SAX  callbacks:
E lement C allbacks
We’ve already discussed the element callbacks earlier in the chapter, but we now
have a chance to explore them in depth. H ere is the element callback once again:
public void startElement(String uri, String localName,
String qName, Attributes atts) 
throws SAXException
T he element callback provides several pieces of information about each ele-
ment.T hese include the element’s U R I, its localN ame, and its qN ame.W hen we
originally discussed the element callback, we focused mostly on the qN ame, But
now that we are processing namespaces, the other two parameters take on new
signiﬁcance.
T he U R I parameter is simply the namespace U R I of the current element.
T he U R I is important because it uniquely identiﬁes the element’s namespace. If
your document contains more than one namespace, you may want to break your
callback logic into parts, where each part handles processing for one particular
namespace.
T he localN ame and qN ame each provide the name of the current element.T he
two are similar, but the localN ame omits the namespace preﬁx provided in the
www.syngress.com

Processing XML Documents with SAX • Chapter 2
41
qN ame.T his is actually a good thing, because the namespace preﬁx usually just
gets in the way; you already know the particular namespace’s U R I, which does a
much better job at uniquely identifying the namespace.T he local name will be
most frequently used, but the qN ame can be used for clariﬁciation when
embedded namespaces have identically named elements.
It does little harm to enable namespace processing, even if your document
contains no namespaces.You may continue to use the localN ame parameter as long
as namespace processing is enabled. For any elements without a namespace,
simply expect the U R I parameter to be empty.
P reﬁx M apping C allbacks
For documents that contain more than one namespace deﬁnition, it may be
important to track where one namespace begins and another ends. SAX  includes
another callback speciﬁcally for this purpose.W hen namespace processing is
enabled, the SAX  parser will automatically recognize any change in namespace. It
then notiﬁes your event handler via a special namespace event.You can add the
following callbacks to your event handler to pick up these events:
public void startPreﬁxMapping(String preﬁx, String uri) ;
public void endPreﬁxMapping(String preﬁx);
If an element declares a namespace, the namespace takes effect for that ele-
ment as well as any child elements.As it scans the document, the parser will
move in and out of different namespaces. U se the preﬁx mapping callbacks to
keep track of where one namespace begins and another ends.
Enabling Other Features
T he SAX  creators tried to keep the SAX  standard as simple as possible by lim-
iting the standard to a core of common features that would be useful to a wide
audience.You have already learned about two of these features: namespace pro-
cessing and validation via DT Ds.A parser must offer both of these features to be
considered SAX -compliant.
W hile the SAX  standard was kept simple, it was also made ﬂexible. It allows
SAX  parsers to add their own innovations. Some parsers may very well offer pro-
prietary features that you might ﬁnd useful for your applications.T hough these
new capabilities are not mandated by the SAX  standard, they are still welcome
within SAX  applications.
T he X erces parser, included with JAX P 1.2, is a perfect example. In addition
to validating from a DT D, the X erces parser can also validate from an X M L
www.syngress.com

42
Chapter 2 • Processing XML Documents with SAX
Schema. X M L Schemas hold promise because they are more powerful and more
ﬂexible than traditional DT Ds. For now, however, X M L Schemas remain an
emerging technology. U ntil X M L Schemas become ubiquitous, we cannot expect
all SAX  parsers to offer this same innovation.
Features and Properties
SAX  organizes parser capabilities into two categories: SAX  parser features and
SAX  parser properties. From a practical standpoint, the differences between these
two are minor.T here’s little sense in getting hung up on terminology, but here
are some guidelines to help you understand the difference:
■
U se features to control parser behavior.
■
U se properties to control parser state.
SAX  deﬁnes a few core features and properties for all SAX  engines.T hese are
described further in Table 2.1 and Table 2.2.You’ll need to refer to your speciﬁc
parser’s documentation to learn about any additional proprietary features and
properties that it may offer. Before trying to use any features or properties, make
sure they are actually implemented by your particular parser.
Table 2.1 Core SAX Features 
Feature Name
Description
http://xml.org/sax/features/namespaces
Turns namespace pro-
cessing on or off.
http://xml.org/sax/features/namespace-preﬁxes
Reports namespace
preﬁxes
http://xml.org/sax/features/string-interning
Uses string interning
(see java.util.String
.intern() for details)
http://xml.org/sax/features/validation 
Turns validation on 
or off.
http://xml.org/sax/features/external-general-entities
Includes or skips
external text entities.
http://xml.org/sax/features/external-parameter-entities Includes or skips
external parameter
entities.
www.syngress.com

Processing XML Documents with SAX • Chapter 2
43
Table 2.2 Core SAX Properties 
Property Name
Description
http://xml.org/sax/properties/dom-node Retrieves the current DOM node
under parse. This is only useful when
using SAX over a DOM parser.
http://xml.org/sax/properties/xml-string
Retrieves the raw string of characters
responsible for the current event.
Setting Features
SAX  offers a standard way to access all of a parser’s features, even if the features
themselves are proprietary. If a SAX  parser supports a particular feature, it will
expose the feature through the SA X ParserF actory object. In JAX P, features are set
on the factory rather than on the parser. O nce you enable a particular feature,
any new parsers created through the factory will exhibit the new behavior.
To turn a feature on or off, you need to know the unique name of the feature.
For example, here is how you would enable X erces’ schema-based validation:
try {
parserFactory.setFeature(
"http://apache.org/xml/features/validation/schema",
true);
} catch (SAXException e) {
System.err.println("Implementation does not" + 
"include schema support."); 
}
R emember, not all parsers will support a given proprietary feature.T he parser
factory will throw an exception if it does not support your requested feature.
Setting Properties
SAX  properties work in much the same way as SAX  features, but there are a
couple of slight differences. First and foremost, SAX  properties work at the parser
level rather than the factory level, which means that your setting is only valid for
one particular parser instance. SAX  properties are often used to expose the
internal state of the parser, so it makes sense to work with one parser instance at a
time. Secondly, properties are not limited the simple on/ off style logic of SAX  fea-
tures.You can set or retrieve complete objects directly through a SAX  property.
www.syngress.com

44
Chapter 2 • Processing XML Documents with SAX
H ere is an example of SAX  property that returns a String value. Q uery this
property during a parse to ﬁnd the parse event’s string literal:
try {
String currentLiteral = parser.getProperty(
"http://xml.org/sax/properties/xml-string ",
true);
} catch (SAXException e) {
System.err.println("Parser does not support "+
"literal property."); 
}
T he SAX  standard speciﬁes only a couple of SAX  properties, but does not
require SAX  parsers to support any of them.As before, the parser will throw an
exception if it does not recognize a particular property. If you expect the prop-
erty to be available, you’ll have to handle any exception accordingly.
Handling Advanced Events
So far, you’ve learned about some basic SAX  events.T he basic events covered the
basic structures of X M L: documents, elements, and characters. H owever, there’s a
lot more to X M L than these three basic structures. X M L documents may contain
more advanced structures, such as processing instructions and entity declarations.
Eventually, you are bound to run into an X M L document that contains one of
these advanced structures.
SAX  includes additional event handlers for dealing with advanced X M L
structures.To use these event handlers, follow the same basic pattern as we have
been exploring: C reate a class that implements the handler, add logic for the han-
dler’s callback methods, and register the event handler with the parser.
C ontentH andler
In addition to the basic SAX  callbacks and namespace callbacks, the
C ontentH andler deﬁnes a few more useful callbacks:
public void ignorableWhitespace(char[] ch, int start, int length) 
throws SAXException
U se the ignorableW hitespace() callback to capture non-essential document
whitespace. In normal processing, the parser reports all whitespace characters
through the C ontentH andler’s own characters() callback. H owever, if you’ve added a
www.syngress.com

Processing XML Documents with SAX • Chapter 2
45
DT D to the document, the parser behaves slightly differently: the DT D provides
enough semantic information to allow the parser to distinguish signiﬁcant and
insigniﬁcant whitespace.T he parser always reports signiﬁcant whitespace through
the usual characters() callback.W hile using a DT D, the parser reports any other
whitespace through the ignorableW hitespace() callback. If you wish to preserve the
insigniﬁcant whitespace during parsing, be sure to catch the whitespace through
the ignorableW hitespace() callback:
public void processingInstruction(String target,
String data) throws SAXException
If your document contains any X M L processing instructions, you may need
to implement the processingInstruction() callback.A processing instruction is a spe-
cial X M L directive intended for the X M L parser.T he target parameter is simply
the name of the processing instruction.T he data parameter includes everything
after the processing instruction’s name. Processing instructions are completely
open-ended, so it’s up to you to parse and interpret any data as you see ﬁt.
public void skippedEntity(String name) throws SAXException
Implementing the skippedE ntities() callback is usually unnecessary. In most cases,
the parser will resolve any entities automatically through one of the other
C ontentH andler callbacks. H owever, the parser may skip over some entities if you
explicitly tell it not to resolve references. (See the http:/ / xml.org/ sax/ features/
external-general-entities and http:/ / xml.org/ sax/ features/ external-parameter-entities prop-
erties.) Implement the skippedE ntity() callback to record any skipped X M L entities.
ErrorH andler
Implement the SAX  E rrorH andler interface to catch and trap different types of
X M L parsing errors. If a parser has difﬁculty parsing a document, it will trigger
an exception error. Some parsing errors are more serious than others.T he
E rrorH andler allows you to distinguish serious parse errors from less serious ones.
For less serious errors, you may wish to record the error and continue on parsing.
Each type of error may be handled in its own way.T he E rrorH andler deﬁnes three
callbacks for the three different types of parsing errors:
public void fatalError(SAXParseException exception) throws SAXException
public void error(SAXParseException exception) throws SAXException
public void warning(SAXParseException exception) throws SAXException
www.syngress.com

46
Chapter 2 • Processing XML Documents with SAX
F atal errors are the most serious types of parse errors, and unfortunately they
are the ones you will encounter most frequently. Fatal errors occur when a parser
tries to read an X M L document that is not well formed. For example, if your
document is missing an end tag or your document contains a syntax error, the
parser will respond with a fatal error.T he fatal error lets you know that the parser
cannot continue.
H owever, there are situations where you may be able to recover from a parse
error and continue parsing. E rrors are non-fatal parsing situations where the parser
cannot determine whether to continue or terminate. For example, if validating,
the parser will trigger an error when the document does not match the DT D. In
such a scenario, the parser gives you the opportunity to record the error and
continue parsing, or re-throw the error and terminate the parse. W arnings are
non-fatal situations that are less serious than errors.
T he E rrorH andler interface only includes three methods, so it’s a very easy
class to implement. H owever, there is an easier way to get started with the
E rrorH andler: the D efaultH andler class implements the E rrorH andler interface as well
as the core C ontentH andler interface.T he D efaultH andler serves as a very rudimen-
tary E rrorH andler. It only reports SAX  fatal errors, and it completely consumes
SAX  errors and warnings. If you want to report all errors, simply override the
D efaultH andler’s methods with your own versions.
You may also prefer to keep your error handling code separate from your
event handling code. If so, simply implement the E rrorH andler and D efaultH andler
in completely separate classes.T his approach has one downside: registering and
using the handlers becomes slightly more involved. JAX P does not allow you to
register an E rrorH andler directly with a parser, so you’ll need to work through the
underlying X M L R eader instance.T he following code demonstrates how to reg-
ister each handler and invoke parsing through the X M L R eader:
//contruct handlers
ErrorHandler errorHandler = new MyErrorHandler();
ContentHandler defaultHandler = new DefaultHandler();
//obtain XMLReader from SAXParser
XMLReader xmlReader = ((SAXParser)parser).getXMLReader();
xmlReader.setContentHandler( defaultHandler );
xmlReader.setErrorHandler( errorHandler);
//invoke parsing
xmlReader.parse (someInputSource);
www.syngress.com

Processing XML Documents with SAX • Chapter 2
47
NOTE
If you have implemented a separate ErrorHandler class, do not use the
SAXParser.parse() method provided through JAXP. The SAXParser.parse()
method automatically resets the ErrorHandler, so use the
XMLReader.parser() method instead.
SAX2 Extensions
Although SAX  includes quite a few different event handlers, these handlers are
by no means comprehensive. X M L documents may contain a variety of structures
not covered in the core SAX  event handlers. Eventually, you may run up against
some of these limitations in your own work. For example, SAX  can’t help you if
you’re interested in parsing an X M L document’s comments. Basic SAX  parsers
will skip right over comments without triggering any events. Luckily, SAX  still
gives you some alternatives for handling these cases.
If you’ve found SAX  event handlers too limiting, try making use of SA X 2
E xtensions.T he SAX 2 Extensions add two new event handlers to the core SAX
library.T hese new event handlers add almost a dozen new SAX  events. If your
parser supports these extensions, then you’ll be able to handle most X M L parsing
challenges.
T he SAX 2 Extensions are an optional part of SAX , so not every parser can
be expected to support them. H owever, they are so useful that most common
parsers support them anyway. If you’re using the standard parsers included in
JAX P, then you have everything you need to begin using the SAX 2 Extensions.
H ere are the new event handlers included with SAX 2 Extensions:
L exicalH andler
T he L exicalH andler provides greater lexical information about an X M L document.
It deﬁnes callbacks for reading X M L comments and ﬁnding the beginnings and
endings of DT D declarations.Additionally, the L exicalH andler provides a ﬁner grain
of control over X M L character events.You may recall that the SAX  C ontentH andler
interface includes basic support for character data, but it passes all types of charac-
ters through one character() callback. It does not allow you to distinguish normal
characters from others, like entities and C DATA.T he L exicalH andler corrects this
shortfall. It provides distinct events for entities and C DATA characters.
www.syngress.com

48
Chapter 2 • Processing XML Documents with SAX
D eclH andler
If you need to parse a DT D, use the D eclH andler interface. It’s easy to confuse this
class with the D T D H andler included in the core of SAX .T he D eclH andler reports
all element, attribute, and entity declarations.T he D T D H andler only reports nota-
tion declarations and unparsed entities.You’ll likely need both the D eclH andler
and D T D H andler to fully parse a DT D.
U sing the two extension event handlers is much like using core SAX  event
handlers. First, create a class that implements the appropriate handler interface,
then add logic for each callback method. Finally, register the event handler with
your parser instance.
R egistering an extension event handler is slightly more work than registering
a core SAX  event handler.T he extension handlers are registered through the
SAX  Property mechanism you learned about earlier. SAX  deﬁnes two new prop-
erties for setting the respective handlers. Simply set the appropriate property,
passing in the extension handler as its value:
try
{   
//create and register a LexicalHandler
LexicalHandler lexHandler = new MyLexicalHandler (); 
saxParser.setProperty(
"http://xml.org/sax/properties/lexical-handler", lexHandler);
//create and register a DeclHandler
DeclHandler decHandler = new MyDeclHandler (); 
saxParser.setProperty(
"http://xml.org/sax/properties/declaration-handler", decHandler);
}
catch (SAXException se)
{
System.err.println("SAX2 Extensions not supported");
}
SAX 2 Extensions are an optional part of SAX , and not all parsers may support
the extensions.T he above code simply catches any exceptions in case the exten-
sions are unavailable.
www.syngress.com

Processing XML Documents with SAX • Chapter 2
49
Summary
In the SAX  model, X M L documents are provided to the application as a series of
events.T he SAX  parser scans an X M L document once from beginning to end.As
it scans, the parser reports each document transition as an event.W ith each event,
the application has a chance to respond to the change in the document
Event-based parsing has strengths and weaknesses.Very large documents can
be processed with events, as there is no need to read the entire document into
memory at once. H owever, working with sections of an X M L document can be
complicated because the application developer must track all the events for that
section. For documents with complex hierarchies, consider using DO M  parsing
instead.
SAX  deﬁnes a number of interfaces for interacting with the SAX  parser.T he
event handler interfaces provide callbacks for handling each event.As a conve-
nience, extend the D efaultH andler class rather than implementing the full
C ontentH andler interface.W ithin your class, simply implement those callbacks you
ﬁnd most interesting.You will most likely want to implement the character call-
back, the element callbacks, and possibly the document callbacks.
O nce you have created an event handler, combine it with an actual parser.
U se JAX P’s abstract factory mechanism to create concrete parser instances.T he
abstract factory allows you to instantiate a parser without referring to any one
parser in particular.T his keeps your code portable, should parser technology
change in the future. If you’d like to try out a new parser, set a system-wide
property naming the SA X ParserF actory implementation class.Alternatively, simply
replace your old parser on the classpath with a new parser.
SAX  parsers provide additional capabilities beyond basic event handling. SAX
parsers are namespace-aware, but namespace processing must be explicitly
enabled.Additionally, SAX  parsers can validate documents as they parse. U se the
SA X ParserF actory to activate both of these features.
SAX  parsers may implement features beyond the original API. Some of these
features are strictly optional, like the event handlers provided by the SAX 2
Extensions package. O ther features are proprietary, like X erces’ validation through
X M L Schema.All of these features are accessed indirectly because they are not
part of the core API. W ith ﬂexibility built into the standard itself, SAX  should
remain a part of the X M L landscape for years to come.
www.syngress.com

50
Chapter 2 • Processing XML Documents with SAX
Solutions Fast Track
U nderstanding Event-Based X M L Parsing
 T he SAX  parser scans an X M L document once from beginning to end,
creating events for each document transition.
 W ith each event, the SAX  parser calls an event handler.T he event
handler contains callbacks for each type of event.
 To quickly create an event handler, simply extend the SAX
D efaultH andler class. Provide implementations for only those callbacks
you ﬁnd interesting.
C reating a SAX  Parser
 To keep your applications portable, avoid writing to a speciﬁc parser
implementation. Instead, work through the SAX  interfaces.
 U se the abstract factories provided by JAX P rather than SAX  to create
parser instances.T he JAX P factories are preferred because they are more
portable.
 Follow the JAX P search path to ﬁgure out what parser is instantiated.
Parsing Data with a SAX  Parser
 To parse a document, you need three things: a parser, an event handler,
and an X M L input source.
 W rap your X M L document from a stream or ﬁle with an InputSource
object. If it’s not speciﬁed within the X M L itself, set the character
encoding properly.
 SAX  parsers are not thread-safe. If you are working with servlets or
other multithreaded applications, create a new parser for each thread.
C onﬁguring the Parser
 Enable DT D validation and namespaces through convenience methods
on the JAX P SA X ParserF actory class
www.syngress.com

Processing XML Documents with SAX • Chapter 2
51
 W ith namespace processing enabled, rework your event handler callbacks
to use the element’s localN ame and namespace U R I.
 Enable other SAX  features and properties through methods on either
the SA X ParserF actory or SA X Parser classes, respectively.
H andling Advanced Events
 Implement the C ontentH andler callbacks to detect ignorable whitespace,
processing instructions, and skipped entities.
 R egister an E rrorH andler to detect different types of errors. Some errors
may be recoverable, so you may be able to continue parsing.
 U se the SAX 2 Extension interfaces to parse and detect X M L comments,
DT Ds, C DATA, and entities.
Q: W hen should I choose SAX  parsing over DO M  parsing?
A: U se SAX  parsing when performance is critical.Also use SAX  parsing on very
large documents. SAX -based parsing is generally quicker and consumes far
less memory than building a DO M  tree.
Q: W hen the SAX  parser reads my X M L document, some of the characters
show up as garbage.W hy?
A: M ake sure you are setting the document’s character encoding properly.T his is
best done through the X M L declaration within the document itself. If you do
not specify a character encoding, the X M L parser will assume the document
uses U T F-8 encoding.
Q: I can open my X M L document ﬁne in Internet Explorer, but my SAX  parser
can’t parse it.W hat’s wrong? 
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

52
Chapter 2 • Processing XML Documents with SAX
A: Internet Explorer does a good job of correcting some minor errors in your
document when it does not impact the document meaning. M ake sure in
particular that your document does not have whitespace before the X M L
declaration.
Q: M y SAX  parser is reporting an attribute value that I don’t see in the docu-
ment.W here is it coming from?
A: If your document contains a DT D, the DT D may specify a default value for
some attributes. SAX  parsers will automatically report any default attributes
in the startE lement() callback.
Q: M y X M L document references an external DT D, but the SAX  parser can’t
seem to locate the DT D.W hat can I do? 
A: Some SAX  parsers will automatically try to read external DT Ds.T his can be
inconvenient, especially when you are off the network and can’t reach the
DT D. C ertain parsers allow you to control loading of DT Ds, but this is a pro-
prietary feature of each parser. For the X erces parser in JAX P 1.2, turn the
http:/ / apache.org/ xml/ features/ nonvalidating/ load-external-dtd feature off.
Q: W here can I ﬁnd out more about speciﬁc SAX  parsers?
A: T he two parsers discussed in this chapter (X erces and C rimson), are main-
tained by the Apache open source community.You can ﬁnd the project’s
homepage and a wealth of information at http:/ / xml.apache.org/ .
www.syngress.com

Processing 
XML Documents
with DOM
Solutions in this chapter:
■
The Document Object Model
■
JAXP and Underlying DOM Engines
■
Creating a DOM Parser
■
Parsing XML into a DOM
■
Manipulating DOM Objects
■
Advanced Topics
Chapter 3
53
 Summary
 Solutions Fast Track
 Frequently Asked Questions

54
Chapter 3 • Processing XML Documents with DOM
Introduction
In the last chapter we discussed event-based parsing. Event-based parsing has
some limitations. For instance, one cannot manipulate entire sections of a docu-
ment at once.Also, multiple passes over the document data calls for multiple runs
through the parser. O ften, it would be more efﬁcient if an entire document could
be read into the memory and manipulated as an in-memory representation.
T his can be achieved using the Document O bject M odel (DO M ), which is
by far the most widely used among the various standards proposed for in-
memory representation of X M L documents.A standard speciﬁed by the World
W ide Web C onsortium (W 3C ), the DO M  speciﬁes an abstract mapping of X M L
elements into runtime objects. Binding this speciﬁcation to various languages,
including Java, has been implemented by a variety of vendors.
In the DO M , every X M L document is represented as a hierarchy of objects.
T his hierarchy forms a tree structure that mimics the structure of the X M L doc-
ument. O nce you are familiar with X M L and DO M , translating between the two
becomes a simple matter.
O ne thing the current DO M  speciﬁcation omits is an API for the parsing of
an X M L document into a DO M .T his is left to the individual vendor when
writing a DO M  parser.T he latest DO M  speciﬁcation (DO M  3) seeks to address
this issue too, but until it gains in popularity, application developers have to take
into account the prospects of modifying their code when moving to a different
parser. JAX P solves this problem by presenting a standardized interface for parsing
X M L data; the result of this parsing is an object that conforms to the standard
W 3C  DO M  Document interface.
T his chapter presents a discussion on the reading, writing, and simple manip-
ulations of a DO M  representation. M ore complex manipulations, such as those
pertaining to stylesheets, will be discussed in the next chapter.
The Document Object Model
T he Document O bject M odel (DO M ) is a World W ide Web consortium (W 3C )
speciﬁcation that provides a programming interface for both X M L and H T M L
documents.T he basic objective of W 3C  DO M  is to provide a standard, cross-
platform, that is, cross-language programming interface that can be used in a wide
variety of environments and with any programming language. U sing a DO M ,
you can dynamically create or modify the structure or the contents of a docu-
ment, add or delete its elements and navigate through its structure.T he DO M
www.syngress.com

www.syngress.com
focuses upon the model of a document and not upon the methods, interfaces etc.
which may be required only to deﬁne and implement a DO M . C onsequently, to
use DO M  in Java or in any other language, the appropriate language binding
must be developed.T hese language bindings would serve as the APIs that can be
used to create and manipulate document as per the DO M  speciﬁcations.
In the DO M , documents have a logical structure that is usually depicted as a
tree.T he DO M  is akin to the traditional object-oriented design concept since it
models a document using objects.All these objects have methods and properties
associated with them. Let us consider an example to illustrate the concept of
DO M .
The DOM Tree
Figure 3.1 is an X M L ﬁle that contains an objective type question along with
two answer options, only one of which is correct.T he correct option is marked Y
while the incorrect option is marked N . Such an X M L ﬁle may be used for, say,
dynamically generating questions for an online examination.
Figure 3.1 A Simple XML
<ROOT>
<question>
<questionid>1</questionid> 
<questiontext>The earth revolves around the sun (State True or False)
</questiontext> 
<option>False</option> 
<optionno>1</optionno> 
<correct>N</correct> 
<option>True</option> 
<optionno>2</optionno> 
<correct>Y</correct> 
</question>
</ROOT>
If we were to represent this X M L graphically using the DO M , it would be as
shown in Figure 3.2.
In the DO M  tree structure, each X M L tag (and its value) is viewed as a node
object. In Figure 3.2, we have numbered each of these node objects from 1 to 18
Processing XML Documents with DOM • Chapter 3
55

56
Chapter 3 • Processing XML Documents with DOM
for ease of explanation. In an actual DO M  document, these nodes will not be
numbered.
T he <RO O T > tag (see N ode1 in Figure 3.2) forms the root node of the tree,
and is referred to as the ﬁrst child of the document.T he <question> tag is a child
node for the root node. <questionid>, <questiontext>, <option>, <optionno> and
<correct> are child nodes for the question node.T hese nodes representing the
X M L tags are element nodes. N ode 1, N ode 2, N ode 3, N ode 5, N ode 7, N ode 9,
N ode 11, N ode 13, N ode 15 and N ode 17 in Figure 3.2 represent element nodes.
T he DO M  tree also represents the values of various elements (C orresponding to
www.syngress.com
Figure 3.2 DOM Tree for XML of Figure 3.1
Node 1
“ROOT”
“question”
“questionid”
“1”
“questiontext”
“The Earth revolves around the sun
(State True or False)“
“Option”
“False”
“Optionno”
“Correct”
“N”
“True”
“Optionno”
“2”
“Y”
“1”
“Option”
“Correct”
Node 18
Node 16
Node 14
Node 12
Node 10
Node 8
Node 6
Node 4
Node 17
Node 15
Node 13
Node 11
Node 9
Node 7
Node 5
Node 3
Node 2

Processing XML Documents with DOM • Chapter 3
57
C DATA in X M L) as nodes, except that these values are represented by text nodes
(N ode 4, N ode 6, N ode 8, N ode 10, N ode 12, N ode 14, N ode 16 and N ode 18 all
represent text nodes).T his is because in most DO M  parsers, C D A T A nodes are
reserved for text that is explicitly marked as C DATA.
NOTE
The text within quotes (“ROOT”, “question” etc.) given alongside each
node in Figure 3.2, has been given solely to correlate the node with its cor-
responding XML tag, attribute or value (as the case may be). In actuality,
this text is embedded within the DOM tree as node names or node values.
For example, the node name for Node 1 will be “ROOT” while Node 4 is a
text node that represents the value (“1”) of the <questionid> tag.
T he DO M  is organized into Levels instead of versions. Level 1 (C ore) of the
DO M  represents the hierarchy of content within a document. Level 2 (C ore)
improves upon the general structure speciﬁed in Level 1 by providing a set of
core interfaces and modules that are meant for content-speciﬁc models. For
example, Level 2 contains specialized interfaces that are dedicated to X M L.We
shall limit our discussions in this section to Level 1 only.
The Basic Classes
As shown in Figure 3.2, Level 1 of the DO M  represents documents in a hierar-
chical structure of N ode objects. Each of these nodes (except for Text and
C D A T A nodes, which will be covered further later) may have zero or more child
nodes of various types and may form a sub-tree under it. If a node has no child
nodes under it, it is referred to as a leaf node.T here are different types of nodes
such as an E lement nodes, a Text node, an A ttribute nodes and so on.
T he Java API for X M L processing (JAX P) provides various interfaces to pro-
cess the different types of elements in an X M L document.We shall now discuss,
in brief, the fundamental JAX P interfaces that are contained in a DO M  imple-
mentation. H owever, you should bear in mind that these interfaces are a part of
the DO M  Level 1 speciﬁcation as developed and recommended by the World
W ide Web C onsortium (W 3C ) and are not speciﬁc to JAX P.T his is to say that to
manipulate DO M  documents, JAX P deﬁnes interfaces/ classes with names same as
(or similar to) W 3C ’s standard DO M  interfaces. For example,W 3C  has deﬁned
the standard interface D ocument that encompasses a complete document.To make
www.syngress.com

58
Chapter 3 • Processing XML Documents with DOM
use of the D ocument W 3C  interface with JAX P’s data structures and APIs, JAX P
has developed its own interface with the same name.T hus, D ocument is a generic
interface that may be supported by various vendors to make it interoperable with
their proprietary APIs.
Document
T he D ocument interface speciﬁes the top node of the DO M  tree and encompasses
an entire document (X M L or H T M L). It provides access to the document’s ele-
ments and data. Since every other node has to be within the document, this
interface contains methods to create other nodes as well as methods for manipu-
lating the document structure and its properties.T he D ocument interface extends
the N ode interface inherits various properties and methods from it.
Element
T he E lement interface represents an X M L or H T M L element.A document’s data
is contained within its elements.An element may also have attributes providing
additional content information.T he E lement interface provides methods to set or
retrieve the attributes of an element as an A ttr (attribute) object or as an attribute
value.T his interface also inherits from the N ode interface.
R eferring back to the X M L in Figure 3.1, each of the tags will be repre-
sented by an Element; for instance, question, questionid, option, optionno and correct
will all be elements in a DO M  document.
Text
T his interface represents the text content (character data in X M L) of an element
or an attribute value.T his interface is also implemented as a node on the DO M
tree structure; that is, as a child node of the element containing the text data
(R efer to Figure 3.2).T he content/ text of an element may or may not contain
markup. If there is no markup, the Text interface implements the text content as a
single node object. If any markup is present, it is further broken down into ele-
ments, comments. with the markup constituents forming a sub-tree under the
text node that represents the original text data.T he Text interface inherits from
both the N ode interface and the C haracterD ata Interface.
As mentioned during our discussions on the DO M  tree in Figure 3.2, the
value of an X M L value tag or the value of an attribute are represented as text
nodes and not as C D A T A nodes. M ost DO M  parsers reserve C D A T A nodes for
text explicitly marked as C DATA.
www.syngress.com

Processing XML Documents with DOM • Chapter 3
59
Attribute
T he A ttribute object represents the attributes of an element in the document.T he
Java API deﬁnes the A ttr interface for the attributes of an element.T hough the
A ttr interfaces inherit from the N ode interface, the DO M  treats them not as sepa-
rate entities, but as properties of the element with which they are associated.
T hus, attributes are not accessed through the document tree.T his also implies
that node attributes like parent node, next or previous sibling will have a null value
for the A ttr object.T his is because attributes do not form child nodes of the ele-
ment they describe.
An attribute may contain a simple text value or an entity reference (as in
X M L). H owever, the DO M  does not distinguish between attribute types. It treats
all attribute values as strings.
N ode
T he N ode interface is central to the DO M  tree. N ode objects form the core struc-
ture of a DO M  tree.T he entire concept of a DO M  tree is based on the node
object contained in the N ode interface. N ote that all the DO M  data types dis-
cussed above; D ocument, E lement, Text and A ttribute are represented in the DO M
tree as nodes.W hile some properties and methods of these nodes are common,
others are speciﬁc to the speciﬁc node’s type. For example, the Text node does
not have child nodes while the Attribute node has no parent or sibling nodes.
T he N ode interface provides methods to retrieve information about a node,
such as the node name, the node value, the node attributes, the child nodes asso-
ciated with a node, and so on.Additionally, it also provides a mechanism for
obtaining and manipulating information about a node’s  child nodes.
N odeList
T he N odeL ist interface represents a collection of node objects.T his interface pro-
vides a mechanism to access a document’s node structure as an indexed list of
nodes beginning at 0.T his allows for iteration through the nodes collection.Any
changes made to a document’s structure, say by adding or removing a node, are
immediately reﬂected in the N ode list.T he N ode list is an abstract entity in the
sense that it does not consider the implementation of the nodes collection or the
types of nodes within the collection. H owever, it provides a convenient means to
gloss over a document’s DO M  structure and can be especially useful for docu-
ments whose structure (number of nodes and their attributes, for instance) are
not known.
www.syngress.com

60
Chapter 3 • Processing XML Documents with DOM
Interrelationships
In a DO M  tree, various nodes are related to one another as child-nodes, parent-
nodes, sibling-nodes and so on.T he possibility of placing one type of node below
the other, . whether or not one type of node can form the child node of another
type, for instance, is an area that calls for careful consideration. In this section, we
will explore the relationships of elements with other elements, as well as with
their own character data and attributes.
H ierarchy Imposed by the
D ocument/ E lement/ A ttribute/ Text C lasses
T he different objects of a DO M  structure are interrelated in a hierarchical pattern.
T his hierarchy can be represented in its very basic form as shown in Figure 3.3.
T he D ocument object lies at the top of the hierarchy, which is obvious consid-
ering that no data or content that lies outside a document is relevant to it.All
elements, text data, processing instructions, or comments have to lie within the
context of a document.A document is composed of E lement objects, which pro-
vide a structure and meaning to a document by separating the document’s con-
tent into a readable and logical format. Elements within a document may further
be nested to deﬁne a document’s content structure. Elements that lie directly
below another element are called its child elements.T he upper element forms the
parent node for the underlying elements. Elements that lie directly under the
www.syngress.com
Figure 3.3 Hierarchy of DOM Objects
Document
Element 1
Element 2
Element n
Text
Attribute 1
Attribute 2
Attribute n
Entity Reference in (XML)
Text

Processing XML Documents with DOM • Chapter 3
61
same parent node are called siblings.T he actual data or text content of the docu-
ment is stored as Text objects, which may represent either element data or an
attribute value.Attributes are used to provide additional information about an
element (apart from the data content).Attribute values are also represented as text
objects. It is important to note that objects in the DO M  structure cannot be
placed haphazardly, for example, a document object cannot be placed under an
attribute object.T he nesting of elements follows a logical and orderly manner
that conforms to the DO M  speciﬁcations.
Let us now consider a modiﬁed version of Figure 3.1 for a better under-
standing of the relationship among elements in a DO M  hierarchy.
R elationship between Elements in a DO M  H ierarchy
In the X M L ﬁle given in Figure 3.4, the questionid tag has been removed.T his tag
is now being represented as an attribute of the question element. Similarly, optionno
and correct have been made into attributes of the O ption element.
Figure 3.4 An XML with Attributes
<ROOT>
<question questionid="1">
<questiontext>The earth revolves around the sun (State True or False)
</questiontext> 
<option optionno="1" correct="N">False</option>
<option optionno="2" correct="Y">True</option> 
</question>
</ROOT>
T he DO M  structure for this X M L document will follow the hierarchy
shown in Figure 3.5
Figure 3.5 clearly shows that E lement 1 is a child element of the RO O T ele-
ment, which is the root element for the document. E lement 2, E lement 3 and
E lement 4 in turn form child elements for E lement 1. E lement 2, E lement 3 and
E lement 4 are siblings. E lement 1 also has an attribute object under it, named
A ttribute 11, as shown in Figure 3.3.T his attribute represents the questionid
attribute of the question element.
E lement 2 has a child of type Text, named Text 1 (as seen in Figure 3.3).
E lement 3 and E lement 4 represent the two option tags and each have two attribute
nodes under them.T hus, the DO M  maintains the hierarchy as explained in the
www.syngress.com

62
Chapter 3 • Processing XML Documents with DOM
above section.T he following sections clarify concepts of DO M  with regard to
Java’s API for X M L parsing, JAX P.
JAXP and Underlying DOM Engines
Sun’s Java API for X M L Processing (JAX P) provides classes and methods to parse
X M L documents, irrespective of which X M L processing implementation is used.
JAX P supports X M L processing using SAX , X SLT  and DO M , and attempts to
provide cohesiveness to the SAX  and DO M  APIs.W hile it does not alter any of
these, it does add some convenient methods for making the X M L APIs easier to
use for java developers
JAX P does not redeﬁne DO M  and SAX , but ensures that parsers can be
accessed in a Java application through a pluggable interface.T he principles of
using JAX P and DO M  are similar to those of SAX . For example, just as we use
SA X Parser and SA X ParserF actory in SAX , we use D ocumentB uilder and
D ocumentF actoryB uilder in JAX P. In fact, these two interfaces use the SAX  API
www.syngress.com
Figure 3.5 DOM Hierarchy for the XML Document
Document
Root Element
name = “ROOT”
Element 1
name = “question”
Attribute 11
name = “questionid”
value = “1”
Element 2
Text 1
“The Earth revolves around the Sun
(State True or False)”
Element 3
name = “Option”
Attribute 13
name = “optionno”
value = “1”
Attribute 23
name = “Correct”
value = “N”
Element 4
name = “Option”
Attribute 14
name = “optionno”
value = “2”
Attribute 24
name = “Correct”
value = “Y”

Processing XML Documents with DOM • Chapter 3
63
internally and hence throw the same Exceptions as well. Figure 3.6 illustrates the
way the two interfaces work .
As shown in Figure 3.6, the D ocumentB uilderF actory class is used to create a
document builder.T he document builder receives the input X M L and parses it to
create its DO M  Document.
www.syngress.com
JWSDP EA2
JWSDP can be downloaded for free from http://java.sun.com/webservices/
downloads/webservicespack.html
The Java Web Services Developer Pack (Java WSDP) download will
contain the following technologies:
■JavaServer Pages Standard Tag Library (JSTL) 
■Java XML Pack, which includes: Java API for XML Messaging
(JAXM), Java API for XML Processing (JAXP), Java API for XML
Registries (JAXR), and Java API for XML-based RPC (JAX-RPC) 
■Tomcat (Java servlet and JavaServer PagesTM container and
tools) 
■Ant build tool 
Developing & Deploying…
Figure 3.6 The JAXP DOM API
Create
Parse
Document Builder
Input XML
Document (DOM)
Object
Object
Object
Object
DocumentBuilderFactory
Parse
Continued

64
Chapter 3 • Processing XML Documents with DOM
Let us illustrate the JAX P parser with the help of an example.T he sample
code is shown in Figure 3.7:
Figure 3.7 Sample Code for a JAXP Parser
import java.io.*;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.xml.sax.helpers.*;
import org.w3c.dom.*;
public class parserDemo
{
// Step 1: Create an instance of the DocumentBuildefactory class
DocumentBuilderFactory documentFactory;
documentFactory = DocumentBuilderFactory.newInstance();
// Step 2: create a DocumentBuilder that satisﬁes the 
// constraints speciﬁed by the DocumentBuilderFactory
DocumentBuilder myDocumentBuilder = null;
try {
myDocumentBuilder = documentFactory.newDocumentBuilder();
} catch (ParserConﬁgurationException pce) {
System.err.println(pce);
www.syngress.com
■The deploytool web application deployment utility 
■Registry Server 
When the Java WSDP is installed, it automatically sets the
JAVA_HOME 
and 
CATALINA_HOME 
environment 
variables 
in
JWSDP_HOME/bin/setenv.bat (in Windows) to the current locations of
the J2SE SDK and the Java WSDP. The start scripts in JWSDP_HOME/
bin call setenv. If you change your J2SE SDK installation, update setenv
to reﬂect the new location if it is different than the previous location.
Adding JWSDP_HOME/bin to the front of your path will ensure that the
Java WSDP scripts are used instead of any other installations. 
Your WSDP pack is now ready to be used. 
Continued

Processing XML Documents with DOM • Chapter 3
65
System.exit(1);
}
// Sets the Error Handler..
myDocumentBuilder.setErrorHandler(new MyErrorHandler());
// Step 3: parse the input ﬁle
Document parsedDocument = null;
try {
parsedDocument = myDocumentBuilder.parse(new File(FileName));
} catch (SAXException se) {
System.err.println(se.getMessage());
System.exit(1);
} catch (IOException ioe) {
System.err.println(ioe);
System.exit(1);
}
}
Even a cursory glance over the import statements is enough to make out that
the code does not contain any vendor-speciﬁc details. O therwise the code is
quite similar to that for any other parser. N ote that the parser, though created
using JAX P, throws the same SA X E xception.T his is because internally JAX P uses
many of the classes used by SAX .We may now proceed to discuss the core issues
involved in building a practical JAX P parser.
Creating a DOM Parser
To build a document’s DO M  tree structure, the document should be parsed and
nodes corresponding to each element should be placed systematically in the
DO M  tree.T he nesting of elements should conform to the DO M  speciﬁcations.
T he Java X M L processing API deﬁnes the D ocumentB uilderF actory class to parse
X M L documents and obtain their DO M  tree structure.
The DocumentBuilderFactory Class
T he D ocumentB uilderF actory class deﬁnes methods and properties that allow the
user to create DO M  parsers.An instance of the D ocumentB uilderF actory class is
www.syngress.com
Figure 3.7 Continued

66
Chapter 3 • Processing XML Documents with DOM
created,then used to obtain instances of the D ocumentB uilder class to parse the
X M L and extract DO M  document instances from it.
WARNING
The DocumentBuilderFactory class is not thread safe. Though an applica-
tion can use the same instance of the DocumentBuilderFactory class to
create instances of DocumentBuilder, it is incumbent upon the application
developer to ensure that the instance of the DocumentBuilderFactory class
is not used by more than one thread at a time.
T he following section goes into the various steps involved in creating a JAX P
parser, then integrates these steps to build a practical parser.
O btaining a N ew Instance 
of the D ocumentB uilderF actory
A D ocumentB uilderF actory class instance can be obtained by using the newInstance()
method, which creates a new factory instance.
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
T he newInstance() method is deﬁned as a static method that throws a
F actoryC onﬁgurationE rror exception if the factory implementation is not available
or cannot be instantiated.
public static DocumentBuilderFactory newInstance() throws 
FactoryConﬁgurationError
As mentioned earlier, an application may use the same factory instance to
create multiple D ocumentB uilder instances, or it may create one factory instance
per thread. H owever, in either case it is the responsibility of the application devel-
oper to ensure that only one thread uses the factory instance at a time.
U sing the D ocumentB uilderF actory
to C reate a D ocumentB uilder
T he D ocumentB uilder class is actually used to obtain the DO M  document from a
given X M L ﬁle. O nce this class is instantiated, it can be used to parse the X M L,
which may be available in the form of an input stream, a ﬁle, a U R L, or other
www.syngress.com

Processing XML Documents with DOM • Chapter 3
67
data source (Detailed discussions on various input sources are included later in
this chapter).An instance of the D ocumentB uilder class can be created using the
D ocumentB uilderF actory instance:
DocumentBuilder db = null;
try {
db = dbf.newDocumentBuilder();
} catch (ParserConﬁgurationException pce) {}    
H ere, dbf is the factory instance. If the D ocumentB uilder cannot be created, a
ParserC onﬁgurationE xception exception is thrown.As in the case of a factory instance,
the same D ocumentB uilder instance should not be concurrently used by two threads.
An application developer should either create one D ocumentB uilder instance per
thread or ensure that two threads do not use the same D ocumentB uilder instance at
the same time. It would be worthwhile to mention here that several classes from
the SAX  API are reused by the D ocumentB uilder class. H owever, this does not neces-
sitate the use of a SAX  parser to parse the X M L for which the DO M  implementa-
tion is being implemented.
Setting Parser Attributes
T he D ocumentB uilderF actory instance can be used to conﬁgure the parser by set-
ting its attributes.T hese attributes deﬁne what the parser considers and what it
ignores while traversing through an X M L ﬁle. H ere, we’ll discuss the major parser
attributes that can be set using the factory instance.Take note that to be effective,
these properties need to be set before a document builder is requisitioned. Say, if
the properties are set after a document builder (db1, for instance) has been instan-
tiated, then the document builder  will not be automatically updated; instead, it
will parse X M L documents using the default property values for any properties
that had not been explicitly set when it was created. H owever, subsequent builder
instances will use the property values set by the factory class.
C oalescing
T his attribute speciﬁes whether or not the parser will convert character data
(C DATA) into Text nodes. If this attribute is set to true, the parser converts each
C D AT A node to a Text node and appends it to an adjacent text node, if one exists.
T he following line of code may be used to set the coalescing property to true:
dbf.setCoalescing(true);
www.syngress.com

68
Chapter 3 • Processing XML Documents with DOM
In this code line, dbf is the factory instance.T he coalescing property is set to
false by default.
E xpandE ntityR eferences
T his property, if set to true, instructs the parser to expand entity reference nodes.
T he following line of code conﬁgures the parser to expand entity reference nodes:
dbf.setExpandEntityReferences(true);
T hough we assume that readers would be aware of the concept of entities in
X M L, we are repeating it to explain the E xpandE ntityR eferences property’s func-
tionality.An entity in an X M L ﬁle may refer either to a certain piece of text or
to an entire document. For example, we deﬁne an entity as follows:
<!ENTITY JAXPentity "Java API for XML Processing, JAXP">
We now call this entity in an X M L tag as follows:
<info>Welcome to &JAXPentity; - manipulating DOM objects the Java way
</info>
W hen this text is retrieved from the <info> tag, the JA X P entity entity gets
expanded and the tag value is read as “Welcome to Java API for X M L Processing,
JAX P – manipulating DO M  objects the Java way.”
If we set E xpandE ntityR eferences to true while parsing the X M L, the document
builder expands (replaces with its deﬁned value) JA X P entity in the <info> tag
above.T he concept of expanding entity references will become clearer later in
the chapter when we discuss E ntityR esolvers in the Input Source Types section
(See the examples in Figure 3.11 and Figure 3.12).
IgnoreC omments
T his property speciﬁes whether or not the parser should ignore comments given
in an X M L.T his property may be set using the following line of code:
dbf.setIgnoringComments(true);
IgnoreE lementC ontentW hitespace
T he IgnoreE lementC ontentW hitespace property applies to the insigniﬁcant white
spaces in an X M L ﬁle, while ignoring the signiﬁcant white spaces such as spaces
internal to a text block.W hen this property is set, the parser eliminates ignorable
white spaces in the X M L.T he following line of code sets this property:
dbf.setIgnoringElementContentWhitespace(true);
www.syngress.com

Processing XML Documents with DOM • Chapter 3
69
N amespaceA ware
T he N amespaceA ware property speciﬁes whether or not the parser is namespace
aware.T he factory instance can be used to make the parser namespace aware:
dbf.setNamespaceAware(true);
Any parsers created by the factory after setting this property will support
name spaces in the X M L.
Validating
T his property is set to true for conﬁguring the parser such that it validates the
X M L ﬁle while parsing it.T he following line sets this property to true:
dbf.setValidating(true);
We now integrate the methods and properties listed above to conﬁgure JAX -
P to be validating, coalescing, and namespace-aware.
C reating a C oalescing,Validating,
N amespace Aware DO M  Parser
To perform a validating parse, we choose an X M L ﬁle with a D O C T Y P E decla-
ration to check whether the parser validates the X M L.T he ﬁle TempDT D.xml is
used as the source X M L.T he X M L in ﬁle TempDT D.xml, is listed in Figure 3.8.
Figure 3.8 An XML with a DTD
<?xml version='1.0' encoding="ISO-8859-1" standalone="yes"?>
<!DOCTYPE ROOT [
<!ELEMENT ROOT (questionid)>
<!ELEMENT questionid (#PCDATA)>
]>
<ROOT>
<questionid>9</questionid>
</ROOT>
We call our parser class E xample1 whose code is listed in Figure 3.9.
Figure 3.9 The Parser Class
import java.io.*;
import javax.xml.parsers.*;
www.syngress.com
Continued

70
Chapter 3 • Processing XML Documents with DOM
import org.xml.sax.*;
import org.xml.sax.helpers.*;
import org.w3c.dom.*;
public class Example1  
{
String  result = new String();
String ﬁlename = new String();
// Constructor..
// 1. File Name of the File To Be Parsed
Example1(String ﬁlename)
{
this.ﬁlename = ﬁlename;
// Step 1: create a DocumentBuilderFactory and conﬁgure it
DocumentBuilderFactory documentFactory;
documentFactory = DocumentBuilderFactory.newInstance();
// Optional: set various conﬁguration options
documentFactory.setValidating(true);
documentFactory.setIgnoringComments(true);
documentFactory.setIgnoringElementContentWhitespace(true);
documentFactory.setNamespaceAware(true);
// The opposite of creating entity ref nodes is expanding them inline
documentFactory.setExpandEntityReferences(true);
//At this point the DocumentBuilderFactory instance can be saved
//and reused to create any number of DocumentBuilder instances
//with the same conﬁguration options.
//Step 2:create a DocumentBuilder that satisﬁes the constraints
//speciﬁed by the DocumentBuilderFactory
DocumentBuilder myDocumentBuilder = null;
try {
www.syngress.com
Figure 3.9 Continued
Continued

Processing XML Documents with DOM • Chapter 3
71
myDocumentBuilder = documentFactory.newDocumentBuilder();
} catch (ParserConﬁgurationException pce) {
System.err.println(pce);
System.exit(1);
}
// Sets the Error Handler..
myDocumentBuilder.setErrorHandler(new MyErrorHandler());
// Step 3: parse the input ﬁle
Document parsedDocument = null;
try {
parsedDocument = myDocumentBuilder.parse(new File(ﬁlename));
} catch (SAXException se) {
System.err.println(se.getMessage());
System.exit(1);
} catch (IOException ioe) {
System.err.println(ioe);
System.exit(1);
}
// Store the DOM tree in a String Object
storeResult(parsedDocument);
}
void storeResult(Node node)
{
// The function is responsible for Traversing the DOM Tree and 
// storing the result in the Object of the Class String
}
String returnResult()
{
// This function is responsible for returning the result to 
// the calling program.
}
www.syngress.com
Figure 3.9 Continued
Continued

72
Chapter 3 • Processing XML Documents with DOM
// Error Handler Implementation....
private static class MyErrorHandler implements ErrorHandler
{
/**
* Returns a string describing parse exception details
*/
private String getParseExceptionInfo(SAXParseException spe)    {
String systemid = spe.getSystemId();
if (systemid == null) {
systemid = "null";
}
String info = "URI=" + systemid +
" Line=" + spe.getLineNumber() +
": " + spe.getMessage();
return info;
}
// The following methods are standard SAX ErrorHandler methods.
// See SAX documentation for more info.
public void warning(SAXParseException spe) throws SAXException {
System.out.println("Warning: " + getParseExceptionInfo(spe));
}
public void error(SAXParseException spe) throws SAXException {
String message = "Error: " + getParseExceptionInfo(spe);
throw new SAXException(message);
}
public void fatalError(SAXParseException spe) throws SAXException {
String message = "Fatal Error: " + getParseExceptionInfo(spe);
throw new SAXException(message);
}
}
www.syngress.com
Figure 3.9 Continued
Continued

Processing XML Documents with DOM • Chapter 3
73
public static void main(String args[])
{
// Main Program...
}
}
T he M yE rrorH andler class takes care of the X M L validation. It contains the
getParseE xceptionInfo() method that prints out the U R I for the source that caused
the exception, the description of the exception and the line number within the
source that caused the exception to be thrown.T he warning(), error() and fatalE rror()
methods are used for the respective types of error.T he storeR esult()method is called
for each node in the DO M  tree, and the corresponding node name and value are
appended to the result string variable.T he storeR esult() method will be discussed
later when we build a complete working parser (See X M L Parser.java class of 
Figure 3.16 ).
Parsing XML into a DOM
Before we commence our discussion on how an X M L ﬁle can be parsed into a
DO M  tree, we discuss the various possible input sources for the X M L ﬁle to be
parsed. JAX P handles each of the input source types differently..
Input Source Types
An input source refers to the resource (a U R L, a string, a ﬁle and so on) that
provides a parser with the X M L to be parsed.T he source X M L can be made
available to a parser from various types of sources.T hese sources include an X M L
ﬁle (for example, myX M L.xml) that needs to be read by the parser, a string (O ne
method calls a parsing function and passes the source X M L to it as a string
parameter value), an input stream (T he X M L is being read from a remote source
using a socket), an entity (when the entity within an X M L refers to another
complete X M L document) and so on. In this section we focus on how JAX P 
can be used to read/ receive X M L from various sources.
www.syngress.com
Figure 3.9 Continued

74
Chapter 3 • Processing XML Documents with DOM
InputSource
T his class encompasses input from a single source object; for example, a byte
stream or a character stream.T his input source is passed on to the parser’s parse()
method. H ow the JAX P parser reads the X M L depends upon the input stream.
For example, if the input source is a character stream, it will be read directly.
O therwise, the parser will try to read it using a byte stream. If the input is neither
a byte stream nor a character stream, the parser will try to open a U R L connec-
tion to the identiﬁed resource. N ote that this is also true in the case of SAX
parsers.As mentioned earlier, this is because the JAX P parsers build the DO M
based on SAX  events.
T he class uses the method getB yteStream() if the input is in the form of a byte
stream, the method getC haracterStream() if the input is a character stream, else, it
uses the getSystemId() method to read from the input source.
File-based Source
If the X M L is in the form of a ﬁle (say myﬁle.xml), the ﬁle can be directly passed
to the the JAX P parser’s parse() method in the following form:
parserObject.parse(new File("myﬁle.xml"))
T his command’s return value will be a D ocument object containing the parsed
X M L’s DO M  tree.
InputStream-based Sources
In InputStream-based sources, a connection is opened to an X M L source and the
input stream associated with the X M L source is obtained.T his InputStream is
passed to the parser class. For example, if the X M L ﬁle is named Temp.xml, we
obtain the input stream using the following code:
String urlName = "http://localhost:8080/examples/Temp.xml";
URL url = new URL(urlName);
URLConnection connection = url.openConnection();
InputStream XMLStream  = connection.getInputStream(); 
We pass this input stream to the parse() method as follows:
parserObject.parse(XMLStream); 
T he parse() method now uses X M L Stream to parse the X M L.
www.syngress.com

Processing XML Documents with DOM • Chapter 3
75
String
If a piece of X M L code is assigned to a String variable, this variable can straight-
away be passed to the parse() method for parsing. For example, if the X M L is
assigned to the X M L String variable, the following line of code will cause the
parser class to parse the X M L and return its D ocument object:
parserObject.parse(XMLString);
E ntityR esolvers
An X M L document may contain a reference to an external entity.W hen parsed,
this entity is resolved and loaded in the original document. Figure 3.10 shows
X M L in that contains reference to an external entity.
Figure 3.10 An XML ﬁle with an External Entity
<!-- Sample2.xml -->
<!DOCTYPE poem [
<!ENTITY ext1 SYSTEM "Sample2.xml">
]>
<poem>
<verse>Take Care To Get What You Like.</verse>
<verse>OtherWise you'll be Forced to like what you Get.</verse>
&ext1;
<verse>Don't worry about pressure..</verse>
<verse>Remember it is the pressure that makes diamond out of coal.</verse>
</poem>
Ext1 contains the reference to the external entity that is an X M L ﬁle named
Sample2.xml. Sample2.xml contains the code given in Figure 3.11.
Figure 3.11 File Sample2.xml
<!-- Sample2.xml (Sample2.xml) -->
<verse>May Lord Almighty be with you Always.</verse>
<verse>May Lord Almighty help in Difﬁcult times.</verse>
W hen the ﬁrst X M L ﬁle is run, the entity ext1 is resolved and the output is as
shown in Figure 3.12.
www.syngress.com

76
Chapter 3 • Processing XML Documents with DOM
N ote that the output reﬂects the X M L from ﬁle Sample2.xml. If an applica-
tion needs to handle any external entities, it must implement the E ntityR esolver
interface and register with the SAX  driver. O nly then will the X M L reader allow
the class to implement customized handling for these entities (For example an
external DT D subset).T his is typically required when the X M L is being gener-
ated from a database or the input is from specialized sources such as U R I types
other than U R Ls. For example, if you need to generate an X M L entity at run-
time as per a speciﬁc DT D and you wish to deﬁne your own customized handler
for this entity, then you need to implement the E ntityR esolver interface. If, how-
ever, you do not require any customized handling for the entities and thus decide
not to implement the E ntityR esolver, then the parser will use the default entity
resolving mechanism.
T he class uses the resolveE ntity() method to resolve external entities.T his
method returns an InputSource associated with the entity.
public InputSource resolveEntity(String publicId, String systemId) throws
SAXException, IOException
If the entity cannot be resolved, a SA X E xception is thrown. If the designated
entity cannot be reached, an IO E xception is thrown.
An important facet however, is that JAX P SAX  wrappers do not resolve
external entity references.T he same applies to non-validating parsers.W hen a
parser cannot resolve an entity, it may simply skip it or generate an error. If an
entity is skipped, a callback is issued that gives the name of the skipped entity.T his
enables another parser with the required resolving features to resolve the entity.
T he skippedE ntity() method can be used to retrieve the name of the skipped
entity.
public void skippedEntity(String name) throws SAXException
www.syngress.com
Figure 3.12 The XML Output with a Resolved External Entity

Processing XML Documents with DOM • Chapter 3
77
T he name parameter contains the name of the skipped entity.
NOTE
Established parsers like Apache Xerces, even if they are non-validating,
will not skip entities. Instead they will expand entity references and
include them in the parsed results. However, be careful when using
another parse engine. Also take care that the parameter passed to the
skippedEntity() method does not contain the leading ampersand and the
trailing semicolon that are used to denote an entity. (For example,
“&ext1;” in Figure 3.10 would be passed as “ext1”)
Manipulating DOM Objects
O nce an X M L ﬁle has been parsed and its DO M  tree constructed, simple func-
tions can be created to traverse through the DO M  tree.T he N ode interface pro-
vides ample methods and properties to separately obtain each node object in the
DO M  tree and its respective text values, its attributes and its child nodes. Each 
of the nodes can be processed further down until the leaf nodes (those with
nothing below them) are reached. In the following sections, we shall discuss how
this is done.
Walking a DOM Constellation
To create a DO M  tree, we ﬁrst need to parse an X M L ﬁle and create the
D ocument object. R eaders may recall that the document object is representative of
the complete parsed X M L ﬁle, with all the X M L elements and data contained
within it.Assuming that the X M L source is a ﬁle, the following code will create a
D ocument from the X M L:
Document doc = null;
try {
doc = db.parse(new File(ﬁlename));
} catch (SAXException se) {}
} catch (IOException ioe) {}
H ere, db is the D ocumentB uilder object created from the instance of the
D ocumentB uilderF actory class. N ote that a SA X E xception is thrown if the X M L
cannot be parsed and an IO E xception is thrown if the X M L ﬁle cannot be read.
www.syngress.com

78
Chapter 3 • Processing XML Documents with DOM
We now list an echo() function that accepts the document object, doc, as a
parameter.
private void echo(Node n) {
int type = n.getNodeType();
switch (type) {
case Node.ATTRIBUTE_NODE:
// Check if the node represents an attribute
System.out.println("Attribute Node");
break;
case Node.CDATA_SECTION_NODE:
// Check if the node represents a CDATA section
System.out.println("CDATA Section Node");
break;
case Node.COMMENT_NODE:
// Check if the node represents a Comment
System.out.println("Comment Node");
break;
case Node.DOCUMENT_FRAGMENT_NODE:
// Check if the node represents a Document Fragment
System.out.println("Document Fragment Node");
break;
case Node.DOCUMENT_NODE:
// Check if the node represents a Document Node
System.out.println("Document Node");
break;
case Node.DOCUMENT_TYPE_NODE:
// Check if the node represents a node that deﬁnes the type
// of document
System.out.println("Document Type Node");
// If the node deﬁnes the document type, obtain its NodeMap 
NamedNodeMap nodeMap = ((DocumentType)n).getEntities();
indent += 2;
for (int i = 0; i < nodeMap.getLength(); i++) {
Entity entity = (Entity)nodeMap.item(i);
echo(entity);
www.syngress.com

Processing XML Documents with DOM • Chapter 3
79
}
break;
case Node.ELEMENT_NODE:
// Check if the node represents an element
System.out.println("Element Node");
// If the node represents an element, obtain its attributes
// using its NodeMap
NamedNodeMap atts = n.getAttributes();
for (int i = 0; i < atts.getLength(); i++) {
Node att = atts.item(i);
echo(att);
}
break;
case Node.ENTITY_NODE:
// Check if the node represents an Entity
System.out.println("Entity Node");
break;
case Node.ENTITY_REFERENCE_NODE:
// Check if the node represents an Entity Reference
System.out.println("Entity Reference Node");
break;
case Node.PROCESSING_INSTRUCTION_NODE:
// Check if the node represents a Processing Instruction
System.out.println("Processing Instruction Node");
break;
case Node.TEXT_NODE:
// Check if the node represents a Text Node
System.out.println("Text Node");
break;
default:
// Check if the node type is not recognised
System.out.println("Unrecognised Node Type");
break;
}
// Run a for loop to obtain the children if any for the node 
// passed a Parameter to the echo() method
www.syngress.com

80
Chapter 3 • Processing XML Documents with DOM
for (Node child = n.getFirstChild(); child != null;
child = child.getNextSibling()) {
echo(child);
}
}
N ote that doc is being passed to the echo() method as a N ode object.T his is
because the D ocument object is treated as a node in the DO M  tree. (R efer to the
discussions in the previous sections for clariﬁcation.)
We quote snippets from the echo() method to analyze how the DO M  tree is
traversed.
O btaining the Document R oot
N otice the code line:
case Node.DOCUMENT_NODE:
T his line retrieves the document node when it is encountered.T his docu-
ment node is the root node of the document from where further processing
down the DO M  tree begins.T he document node will be the ﬁrst node encoun-
tered when the document object (doc), is ﬁrst passed to the echo() method.
Walking the H ierarchy
T he echo() method uses the in-order technique to traverse the DO M  tree. In the
in-order technique, when a node (N ode A, for example) is encountered, the pro-
cessing sequence follows the path under that node until the leaf nodes are
reached, and then the processing resumes at the node’s next sibling.We redraw
part of Figure 3.2 as Figure 3.13 to explain the sequence in which the DO M  tree
is traversed.
R oot E lement is the ﬁrst one to be obtained.T he program then goes to
E lement 1 and retrieves its attribute as given by A ttribute 11. E lement 2 is fetched
next, followed by its text value, Text 1.T he next in sequence is E lement 3. Its
attributes, A ttribute 13 and A ttribute 23, are obtained and the program goes to
E lement 4 and so on.T he Path arrows in Figure 3.13 have been numbered to rep-
resent the path followed.
Since the focus in this chapter is on JAX P rather than on DO M , other
traversal techniques like left-to-right (LT R ) are not being explained. Interested
www.syngress.com

Processing XML Documents with DOM • Chapter 3
81
readers may refer to relevant material when using a parser that uses a different
traversal technique.
F inding sibling and child nodes
C onsider the following for loop of the echo() method
for (Node child = n.getFirstChild(); child != null;
child = child.getNextSibling()) {
echo(child);
}
}
W hen the document object is passed to the echo() method, the ﬁrst execution
of the loop returns R oot E lement (See Figure 3.6) as the ﬁrst child of the doc
object,.T he echo() function is recalled, except that this time the node object 
being passed to echo() is R oot E lement.T he next pass through this for loop returns
E lement 1 as the child element of R oot E lement and passes it as a parameter to 
the echo() method. Since E lement 1 is an E lement node, the case statement, case
www.syngress.com
Figure 3.13 Traversing the DOM Tree
Root Element
Element 1
Attribute 11
Element 2
Text 1
Element 3
Attribute 13
Attribute 23
Element 4
Path 1
Path 2
Path 3
Path 4
Path 5
Path 6
Path 7
Path 8

82
Chapter 3 • Processing XML Documents with DOM
N ode.E L E M E N T _ N O D E :, causes the N amedN odeM ap of E lement 1’s attributes to
be created through the following code:
NamedNodeMap atts = n.getAttributes();
for (int i = 0; i < atts.getLength(); i++) {
Node att = atts.item(i);
echo(att);
}
T he ﬁrst pass through the main for loop invokes this code against E lement 1.
T he next pass through the for loop returns E lement 2 as the child for E lement 1.
Again, the echo() method is called and E lement ‘s 2 attributes are retrieved.T he
next pass through the for loop returns E lement 3 as the next sibling of E lement 2.
T he processing thus follows the in-order sequence discussed above.
T he following discussion clariﬁes the concept of walking the DO M  tree.
A Servlet to W rite O ut N ame/ Value 
Pairs from Example Schema
First of all, Figure 3.14 lists the X M L that is being parsed. N ote that we shall be
using the same X M L for further examples, so Figure 3.14 will be referenced in
future discussions.
Figure 3.14 XML Code for Parsing
<?xml version='1.0'?><ROOT>
<question>
<questionid>1</questionid>
<questiontext>Type Any Question Here ?</questiontext>
<option>Option 1</option>
<optionno>1</optionno>
<correct>N</correct>
<option>Option 2</option>
<optionno>2</optionno>
<correct>Y</correct>
<option>Option 3</option>
<optionno>3</optionno>
<correct>N</correct>
<option>Option 4</option>
<optionno>4</optionno>
www.syngress.com
Continued

Processing XML Documents with DOM • Chapter 3
83
<correct>N</correct>
</question>
</ROOT>
Assuming that this X M L is available as a ﬁle named Temp.xml, we now create
the ParsingX M L.java  servlet (Figure 3.15), to open a connection to the
Temp.xml ﬁle using Java’s U R L C onnection object.We also assume that Temp.xml
lies within the examples folder in the servlet’s document root.
Figure 3.15 The ParsingXML.java Servlet
import java.io.*;
import java.net.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class  ParsingXML extends HttpServlet
{
InputStream xmlStream;
public void doGet(HttpServletRequest request, 
HttpServletResponse response) 
throws ServletException, IOException 
{
PrintWriter outputWriter = response.getWriter();
response.setContentType("text/html");
// Providing the urlName of the XML File..
String urlname = "http://localhost:8080/examples/Temp.xml";
URL url = new URL(urlname);
URLConnection connection = url.openConnection();
xmlStream  = connection.getInputStream();  
// Calling the Class XMLParser with the Stream of the XML File,
// to parse the XML File. 
www.syngress.com
Figure 3.14 Continued
Continued

84
Chapter 3 • Processing XML Documents with DOM
XMLParser myParser = new XMLParser(xmlStream);
// Obtaining the result from the Class.
String returnValue = myParser.returnResult();
outputWriter.println("<center><h1>Result of Parsing</center>");
outputWriter.println("<h4> "+returnValue);
outputWriter.close();
xmlStream.close();
}
}
T he ParsingX M L servlet extends the H T T PServlet used for the H T T P pro-
tocol.T he ParsingX M L servlet calls the X M L Parser class within its doG et()
method.T he servlet passes the contents of the Temp.xml ﬁle to the parser class
using the data stream stored in the xmlstream variable.
NOTE
The ParsingXML servlet uses the GET method (in which the servlet
receives data in the form of a query string) for the request. However, the
ParsingXML servlet does not read any data using the HTTPServletRequest
object, since data is being read from a ﬁle-based source. Thus, the use of
doGet() or doPost() is ﬁgurative and not practically relevant to this partic-
ular servlet.
T he X M L Parser class is responsible for creating instances of the
D ocumentB uilderF actory class and D ocumentB uilder class to create the X M L’s 
DO M  tree.T he code for the X M L Parser class is listed in Figure 3.16:
Figure 3.16 The XMLParser.java Class
import java.io.*;
import javax.xml.parsers.*;
import org.xml.sax.*;
www.syngress.com
Figure 3.15 Continued
Continued

Processing XML Documents with DOM • Chapter 3
85
import org.xml.sax.helpers.*;
import org.w3c.dom.*;
public class XMLParser  
{
String  result = new String();
// Constructor..
// 1. InputStream of the File to be parsed..
XMLParser(InputStream xmlStream)
{
// Step 1: create a DocumentBuilderFactory and conﬁgure it
DocumentBuilderFactory documentFactory;
documentFactory = DocumentBuilderFactory.newInstance();
// Optional: set various conﬁguration options
documentFactory.setValidating(false);
documentFactory.setIgnoringComments(true);
documentFactory.setIgnoringElementContentWhitespace(true);
documentFactory.setCoalescing(true);
// The opposite of creating entity ref nodes is expanding them inline
documentFactory.setExpandEntityReferences(true);
// At this point the DocumentBuilderFactory instance can be saved and 
//reused to create any number of DocumentBuilder instances with the
// same conﬁguration options.
// Step 2: create a DocumentBuilder that satisﬁes the constraints 
// speciﬁed by the DocumentBuilderFactory
DocumentBuilder myDocumentBuilder = null;
try {
myDocumentBuilder = documentFactory.newDocumentBuilder();
} catch (ParserConﬁgurationException pce) {
System.err.println(pce);
www.syngress.com
Figure 3.16 Continued
Continued

86
Chapter 3 • Processing XML Documents with DOM
System.exit(1);
}
// Step 3: parse the input ﬁle
Document parsedDocument = null;
try {
parsedDocument = myDocumentBuilder.parse(xmlStream);
} catch (SAXException se) {
System.err.println(se.getMessage());
System.exit(1);
} catch (IOException ioe) {
System.err.println(ioe);
System.exit(1);
}
// Store the DOM tree in a String Object
storeResult(parsedDocument);
}
// The function is responsible for Traversing the DOM Tree and storing 
// the result in the Object of the Class String (result). During the 
// Traversal special HTML tags as also added along with the Node 
// Name/Value to as to facilitate understanding.
void storeResult(Node node)
{
String val = node.getNodeValue();
if (val == null)
{
result += "<Font color = \"//ff0000\">Name :</Font> "+ 
node.getNodeName();
result += "<BR>";         
}
else if (val.trim().equals(""))
www.syngress.com
Figure 3.16 Continued
Continued

Processing XML Documents with DOM • Chapter 3
87
{
// Simple Ignore...
}
else
{
result += "<Font color = \"//ff0000\">Name :</Font> "+ 
node.getNodeName();
result += "<Font color = \"//0000FF\">&nbsp;&nbsp;&nbsp;Value :" +
"</Font>" + val+ "<BR>"; 
}
for (Node child = node.getFirstChild(); child != null;
child = child.getNextSibling()) 
storeResult(child);
}
// This function is responsible for returning the result to the 
//Calling program.
String returnResult()
{
return(result);
}
}
T he constructor of the X M L Parser class accepts the servlet’s input stream.
T he constructor instantiates the D ocumentB uilderF actory class and uses this 
instance to create a document builder object. N ote the parser attributes: it 
is non-validating (documentfactory.setValidating(false);), ignores comments 
(documentfactory.setIgnoringC omments(true);), ignores white spaces
(documentfactory.setIgnoringE lementC ontentW hitespace(true);), is a coalescing 
parser (documentfactory.setC oalescing(true);) and expands entity references 
(documentfactory.setE xpandE ntityR eferences(true);).
www.syngress.com
Figure 3.16 Continued

88
Chapter 3 • Processing XML Documents with DOM
T he document builder’s parse() method parses the X M L stream and creates a
document from it as shown by the following code line:
parseddocument = mydocumentbuilder.parse(xmlstream);
In the above line parseddocument is a D ocument object that contains the DO M
structure for the X M L given by xmlstream.
T he storeR esult() method accepts a node object and obtains the node name
(node.getN odeN ame();) and the node value (node.getN odeValue();). If the node value
is null, only the node name is appended to the result string. O therwise, both the
node’s name and value are appended to result.T he H T M L <Font> and <BR >
tags are being used to present the node names and values in a readable format
and hold no other signiﬁcance for the parsing result.
NOTE
The storeResult()method accepts a Node object as parameter. However,
the XMLParser class’ constructor makes the ﬁrst call to storeResult() by
passing a Document object to it (Note the code line “storeResult(parsed-
document);”). Recollect from our discussion on the Document interface
(“The Basic Classes” sub-section under “The Document Object Model”)
that Document extends the Node interface. This is equivalent to saying
that the Document object is also a Node object. Therefore, the call to
storeResult() with a Document object as parameter is perfectly valid. 
We now examine the following for loop within the storeR esult() method:
for (Node child = node.getFirstChild(); child != null;
child = child.getNextSibling()) 
storeResult(child);
T he ﬁrst node returned by the loop will be the node representing the
<R O O T > tag, which happens to be the ﬁrst child for the D ocument object given
by parseddocument.T his node (RO O T ) is passed to the storeR esult() method.T his
means that during the second execution, the for loop will return the ﬁrst child of
the RO O T node  (the node that represents <questionid>).T he third execution
returns the node that represents the tag <questiontext> and is a sibling of the
questioned node and so on.T hus, the for loop executes until all nodes within the
D ocument are covered.
www.syngress.com

Processing XML Documents with DOM • Chapter 3
89
T he returnString()method returns the string variable to the calling servlet
(ParsingX M L).
T he output of the ParsingX M L class is shown in Figure 3.17.
Finding Lists of N odes
T he DO M  tree can be searched for speciﬁc nodes by supplying the node name.
T he N ode interface provides the getN odeN ame() and getN odeValue() methods to
obtain the name and value of a node, respectively.T hese node names andvalues
may then be compared against a speciﬁed name/ value to be searched.A loop can
be run to iterate through nodes with matching names/ values.
Figure 3.18 illustrates searching a DO M  tree for nodes that contain a speci-
ﬁed value.We shall use the DO M  tree from Figure 3.1for our example. First of
all, we create an H T M L form with an input ﬁeld in which to type the value for
which we’ll search. Let us call it searchForm.html (see Figure 3.18)
Figure 3.18 Code for searchForm.html:
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
www.syngress.com
Figure 3.17 Output from ParsingXML.java
Continued

90
Chapter 3 • Processing XML Documents with DOM
</head>
<body bgcolor="//FFFFFF" text="#000000">
<form name="form1" method="get" 
action="http://localhost:8080/examples/servlet/SearchInXML">
Enter the Search Criteria Here...
<input type="Text" name="NodeToSearch" size = "20"><br><br>
<center>
<input type="submit" name="Submit" value="Click to Find The Node">
</center>
</form>
</body>
</html> 
T he form of searchForm.html appears in the browser as shown in Figure 3.19.
F inding a L ist of N odes that M atch a Particular C riteria
We now create a class that accepts two parameters: a search word and an X M L
input stream that is to be searched for the search word.T his class, D O M X M L ,
uses the D ocumentB uilder class to parse the X M L and build its DO M  tree. It then
searches the resulting DO M  tree for the speciﬁed search value (see Figure 3.20).
Figure 3.20 Code for DomXML.java
import java.io.*;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.xml.sax.helpers.*;
import org.w3c.dom.*;
www.syngress.com
Figure 3.18 Continued
Figure 3.19 The Search Form
Continued

Processing XML Documents with DOM • Chapter 3
91
public class DOMXML
{
String result = new String();
String searchCriteria = new String();
boolean found = false;
int valueNo = 1;
// Constructor..
//  1. InputStream of the File to be parsed..
//  2. Node Value to be searched.
DOMXML(InputStream xmlStream, String searchCriteria)
{
this.searchCriteria = searchCriteria;  
// Step 1: create a DocumentBuilderFactory and conﬁgure it
DocumentBuilderFactory documentFactory;
DocumentFactory = DocumentBuilderFactory.newInstance();
// Optional: set various conﬁguration options
documentFactory.setValidating(false);
documentFactory.setIgnoringComments(true);
documentFactory.setIgnoringElementContentWhitespace(true);
documentFactory.setCoalescing(true);
// The opposite of creating entity ref nodes is expanding them inline
documentFactory.setExpandEntityReferences(true);
// At this point the DocumentBuilderFactory instance can be saved and 
//reused to create any number of DocumentBuilder instances with the 
//same conﬁguration options.
// Step 2: create a DocumentBuilder that satisﬁes the constraints 
//speciﬁed by the DocumentBuilderFactory
DocumentBuilder myDocumentBuilder = null;
try {
www.syngress.com
Figure 3.20 Continued
Continued

92
Chapter 3 • Processing XML Documents with DOM
myDocumentBuilder = documentFactory.newDocumentBuilder();
} catch (ParserConﬁgurationException pce) {
System.err.println(pce);
System.exit(1);
}
// Step 3: parse the input ﬁle
Document parsedDocument = null;
try {
parsedDocument = myDocumentBuilder.parse(xmlStream);
} catch (SAXException se) {
System.err.println(se.getMessage());
System.exit(1);
} catch (IOException ioe) {
System.err.println(ioe);
System.exit(1);
}
// Store the DOM tree in a String Object
storeResult(parsedDocument);
}
// The function is responsible for Traversing the DOM Tree and storing
//the result in the Object of the Class String (result). During the 
//Traversal special HTML tags as also added along with the Node 
//Name/Value to as to facilitate understanding.
void storeResult(Node node)
{
String val = node.getNodeValue();
if (val != null)
{
val = val.trim();
if (val.equalsIgnoreCase(searchCriteria))
{ 
found = true;
www.syngress.com
Figure 3.20 Continued
Continued

Processing XML Documents with DOM • Chapter 3
93
result += valueno+".  " +node.getParentNode().getNodeName()+"<br>"; 
valueNo++;
}
}
for (Node child = node.getFirstChild(); child != null;
child = child.getNextSibling()) 
storeResult(child);
}
// This function is responsible for returning the result to the Calling 
//program.If the Flag found is false that is no name for a speciﬁc value
// is found then the String Object (result) is assigned a value "Empty".
String returnResult()
{
if (!found)
result = "Empty";
return(result);
}
}
T he name of the node whose value matches the search criterion is appended
to the result output String variable.T he storeR esult() method is repeatedly called
for all nodes in the DO M  tree to check for those with matching value entries. If
no match is found, the E mpty string is assigned to the result variable.
N ow we create a servlet to read the search value from the H T M L form and
pass it to the D omX M L class for searching.T he servlet will also print out the
search results it receives from the D omX M L class.We call this servlet SearchInX M L .
SearchInX M L’s code displayed in Figure 3.21.
Servlet to W rite O ut All N ode 
N ames that C ontain a Speciﬁc Value
T he SearchInX M L servlet opens a connection to the Temp.xml ﬁle, which 
contains the X M L to be searched. It also reads the search word from
www.syngress.com
Figure 3.20 Continued

94
Chapter 3 • Processing XML Documents with DOM
searchForm.html using the getParameter() method.T he servlet then passes the
X M L stream and the search word to a D omX M L object (Figure 3.21).
Figure 3.21 The SearchInXML Servlet
import java.io.*;
import java.net.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class  SearchInXML extends HttpServlet
{
InputStream xmlStream;
String searchCriteria = new String();
public void doGet(HttpServletRequest request, 
HttpServletResponse response) 
throws ServletException, IOException 
{
PrintWriter outputWriter = response.getWriter();
response.setContentType("text/html");
//  Storing the parameter passed to the servlet in a string variable.
searchCriteria = request.getParameter("NodeToSearch");
// Providing the urlName of the XML File..
String urlName = "http://localhost:8080/examples/Temp.xml";
URL url = new URL(urlName);
URLConnection connection = url.openConnection();
xmlStream  = connection.getInputStream();  
// Calling the Class DomXML with the Stream of the XML File and a 
//particular search criteria to search in the XML File.
DOMXML  myParser = new DOMXML( xmlStream, searchCriteria);
// Obtaining the result from the Class.
String returnValue = myParser.returnResult();
outputWriter.println("<center><h1>Result of Searching</center>");
www.syngress.com
Continued

Processing XML Documents with DOM • Chapter 3
95
// Displaying the result in appropriate format.
if (returnvalue.equals("Empty"))
outputWriter.println("<h4> <font color=\"#FF0000\" align=\"left\">"
+ "<b> Search Yielded 0 result(s). </font> ");
else
{
StringTokenizer tokens = new StringTokenizer(returnValue, "<br>");
int numberOfTokens = tokens.countTokens();
outputWriter.println("<h4> <font color=\"#FF0000\" align=\"left\">"
+ "<b> Search Yielded "+ numberOfTokens + " result(s). </font> ");
outputWriter.print("<h4> "+returnValue);
}
outputWriter.close();
xmlStream.close();
}
}
If returnValue contains “Empty,” it outputs the message “Search Y ielded 0
result(s).” O therwise, returnValue is split using the H T M L <BR > tag that was
appended after each matching entry by the D omX M L class.Assuming that the user
entered the value “1” into searchForm.html’s input ﬁeld (See Figure 3.21), the
node names satisfying the search criterion are displayed as shown in Figure 3.22.
www.syngress.com
Figure 3.21 Continued
Figure 3.22 Node Names that Match the Search Criterion

96
Chapter 3 • Processing XML Documents with DOM
C hanging the C ontents of a N ode
T he DO M  tree can be used not only to read node names or their values, but also
to modify an X M L ﬁle.T his modiﬁcation could take the form of appending
nodes, changing node values or deleting nodes. O nce again, the various methods
provided by the N ode interface come into play while modifying the DO M  tree.
We start by creating a single user interface in the form of an H T M L form
that accepts a node name and the corresponding node value in input ﬁelds and
provides two buttons, one to empty the DO M  tree (by removing all nodes in the
tree) and the other to modify the node value or to append a new node.We call
this ﬁle modifyForm.html. Figure 3.23 shows the code for this ﬁle:
Figure 3.23 The modifyForm.html Code
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>
<body bgcolor="#FFFFFF" text="#000000">
<form name="form1" method="get" action="http://localhost:8080/examples/
servlet/AdditionInXML">
Enter the Node Name Here..<input type="Text" name="NodeToAdd" size =
"20"><br>
Enter the Node Value Here..<input type="Text" name="ValueToAdd" size =
"20"> <br><br>
<center><input type="submit" name="Submit" value="Click to Add/Change 
Node in The XML">
</center>
</form>
<form name="form1" method="post" action="http://localhost:8080/examples
/servlet/EmptyXML">
<input type="submit" name="Submit" value="Empty the Entire DOM">  
</form>
</body>
</html> 
www.syngress.com

Processing XML Documents with DOM • Chapter 3
97
C onsider the form displayed in Figure 3.24, where we have assumed that the
user has added O ption as the name of the new node and N ew O ption as the value
of the node after opening the modifyForm.html ﬁle in the browser.
C reating and U pdating E lements and Text N odes
We create a single class, M odifyX M L .java, that matches the node name passed to
its constructor with all the nodes in the DO M  tree. If the node name is found, its
value is updated using the node value passed as another parameter to the con-
structor function. If the node is not found, a new node with the given name and
value is appended to the root of the DO M  tree. C ode for M odifyX M L .java is
shown in Figure 3.25.
Figure 3.25 The ModifyXML.java Class
import java.io.*;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.xml.sax.helpers.*;
import org.w3c.dom.*;
public class ModifyXML
{
String result = new String();
String nodeName = new String();
String nodeValue = new String();
int empty = 0;
boolean found = false;
www.syngress.com
Figure 3.24 The Form for Modifying the DOM Tree
Continued

98
Chapter 3 • Processing XML Documents with DOM
boolean addedAtEnd = false;
int valueNo = 1;
// Constructor..
// 1. InputStream of the File to be parsed..
// 2. Node name which is to be affected.
// 3. New Node value of the Node name which is to be affected.
// 4. Flag empty which is used to Empty out the entire DOM Tree..
ModifyXML(InputStream xmlStream, String nodeName,
String nodeValue, int empty)
{
this.nodeName = nodeName;
this.nodeValue = nodeValue;
// Step 1: create a DocumentBuilderFactory and conﬁgure it
DocumentBuilderFactory documentFactory;
DocumentFactory = DocumentBuilderFactory.newInstance();
// Optional: set various conﬁguration options
documentFactory.setValidating(false);
documentFactory.setIgnoringComments(true);
documentFactory.setIgnoringElementContentWhitespace(true);
documentFactory.setCoalescing(true);
// The opposite of creating entity ref nodes is expanding them inline
documentFactory.setExpandEntityReferences(true);
// At this point the DocumentBuilderFactory instance can be saved and 
//reused to create any number of DocumentBuilder instances with the 
//same conﬁguration options.
// Step 2: create a DocumentBuilder that satisﬁes the constraints
// speciﬁed by the DocumentBuilderFactory
DocumentBuilder myDocumentBuilder = null;
try {
www.syngress.com
Figure 3.25 Continued
Continued

Processing XML Documents with DOM • Chapter 3
99
myDocumentBuilder = documentFactory.newDocumentBuilder();
} catch (ParserConﬁgurationException pce) {
System.err.println(pce);
System.exit(1);
}
// Step 3: parse the input ﬁle
Document parsedDocument = null;
try {
parsedDocument = myDocumentBuilder.parse(xmlStream);
} catch (SAXException se) {
System.err.println(se.getMessage());
System.exit(1);
} catch (IOException ioe) {
System.err.println(ioe);
System.exit(1);
}
if (empty == 1)
{
Document emptyDocument = null;
parsedDocument = emptyDocument;
showResult(parsedDocument);
}
else
{
storeResult(parsedDocument);
//  If a node of a particular name is not found then call 
//  the Function "AddNewNode" to create a new Node at the End.
if (!found)
{
addedAtEnd = true;
Element newNode  = parsedDocument.createElement(nodeName);
Text textNode = parsedDocument.createTextNode(nodeValue);
www.syngress.com
Figure 3.25 Continued
Continued

100
Chapter 3 • Processing XML Documents with DOM
parsedDocument = addNewNode(parsedDocument,newNode,textNode);
}
// Store the DOM tree in a String Object
showResult(parsedDocument);
}
}
// The function is responsible for Traversing the DOM Tree and checking
// whether a Node of a particular name is present or not. If it is 
// present then the value of the node is replaced buy the new Value
// and a ﬂag "Found" is set to be true.
void storeResult(Node node)
{
String val = node.getNodeName();
val = val.trim();
if (val.equalsIgnoreCase(nodeName))
{
found = true;
Node childNode = node.getFirstChild();
childNode.setNodeValue(nodeValue);
}
for (Node child = node.getFirstChild(); child != null;
child = child.getNextSibling()) 
storeResult(child);
}
// The function is responsible for Traversing the DOM Tree and storing 
// the result in the Object of the Class String (result). During the 
// Traversal special HTML tags as also added along with the Node 
// Name/Value to as to facilitate understanding.
void showResult(Node node)
{
www.syngress.com
Figure 3.25 Continued
Continued

Processing XML Documents with DOM • Chapter 3
101
if (node == null)
{
result = "Empty";
}
else
{
String val = node.getNodeValue();
if (val == null)
{
result += "<Font color = \"#ff0000\">Name :</Font> "+ 
node.getNodeName();
result += "<BR>";         
}
else if (val.trim().equals(""))
{
// Simple Ignore...
}
else if(val.equalsIgnoreCase(nodeValue))
{
if (addedAtEnd)
{
result += "<Font color = \"#FF0000\">Name :</Font>"+ 
node.getNodeName();
result += "<Font color = \"#008000\">&nbsp;&nbsp;&nbsp;" + 
"Value : "+ val + "</Font><BR>"; 
}
else
{
result += "<Font color = \"#FF0000\">Name :</Font> "+ 
node.getNodeName();
result += "<Font color = \"#FF00FF\">&nbsp;&nbsp;&nbsp;" + 
"Value : "+ val+"</Font><BR>"; 
}
}
else
www.syngress.com
Figure 3.25 Continued
Continued

102
Chapter 3 • Processing XML Documents with DOM
{
result += "<Font color = \"#ff0000\">Name :</Font> "+ 
node.getNodeName();
result += "<Font color = \"#0000FF\">&nbsp;&nbsp;&nbsp;" + 
"Value : </Font>" + val+"<BR>"; 
}
for (Node child = node.getFirstChild(); child != null;
child = child.getNextSibling()) 
showResult(child);
}
}
// This function is responsible for returning the result to the Calling
//program.
String returnResult()
{
return(result);
}
// This function "AddNewNode" is responsible for adding a new Node to
// theDOM Tree it takes as parameter three Objects of the Type Node..
// 1. The original Dom Tree..
// 2. The Name of the Node to be added..
// 3. The value of the Node to be added..
// The return type of this function is the updated DOM Document.
Document addNewNode(Node original, Node nodeElement, Node nodeText)
{
Node position = original.getLastChild();
if (position.getNodeType() != Node.TEXT_NODE)
{
www.syngress.com
Figure 3.25 Continued
Continued

Processing XML Documents with DOM • Chapter 3
103
position.appendChild(nodeElement);
position.appendChild(nodeText);
}
else
while(position.getNodeType() == Node.TEXT_NODE)
{
for (Node child = position.getFirstChild(); child != null;
child = child.getNextSibling()) 
if (child.getNodeType() != Node.TEXT_NODE)
{
child = child.appendChild(nodeelement);
child = child.appendChild(nodetext);
original.appendChild(child);
break;
}
}
return((Document)original);  
}
}
T he code iterates through the storeR esult() method to check if the node name
given by the nodeN ame variable exists in the DO M  tree. If it does, the
setN odeValue() method is called to set its value to that passed to the constructor as
the nodeValue variable. If the node is not found, the addN ewN ode() method is
called to append the node to the end of the DO M  tree.
If the value of the integer being passed to the constructor is 1, the M odifyX M L
class sets the value of the parsed document objectto null.T his automatically
removes all the nodes in the document.
AdditionInX M L Servlet to 
M odify N odes in the DO M  Tree
We now list the servlet (AdditionInX M L), that reads the node name and the
value entered by the user and calls the M odifyX M L class to change the value of
the node if it exists, or to append the node name and value if the node does not
exist.T he code for A dditionInX M L is shown in Figure 3.26.
www.syngress.com
Figure 3.25 Continued

104
Chapter 3 • Processing XML Documents with DOM
Figure 3.26 The AdditionInXML Servlet
import java.io.*;
import java.net.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class AdditionInXML extends HttpServlet
{
InputStream xmlStream;
String nodeName = new String();
String nodeValue = new String();
public void doGet(HttpServletRequest request, 
HttpServletResponse response) 
throws ServletException, IOException 
{
PrintWriter outputWriter = response.getWriter();
response.setContentType("text/html");
//  Storing the parameters passed to the servlet in  string variables. 
nodeName = request.getParameter("NodeToAdd");
nodeValue = request.getParameter("ValueToAdd");
// Providing the urlName of the XML File..
String urlname = "http://localhost:8080/examples/Temp.xml";
URL url = new URL(urlname);
URLConnection connection = url.openConnection();
xmlStream = connection.getInputStream();  
// Calling the Class ModifyXML with the Stream of the XML File, nodeName 
//and nodeValue of the node to be replaced/appended.
ModifyXML myParser = new ModifyXML(xmlStream, nodeName, nodeValue, 0);
// Obtaining the result from the Class.
String returnValue = myParser.returnResult();
outputWriter.println("<center><h1>Result of Modiﬁcation</center>");
www.syngress.com
Continued

Processing XML Documents with DOM • Chapter 3
105
outputWriter.print("<h4> "+returnvalue);
outputWriter.close();
xmlStream.close();
}
}
T he servlet uses the H T T P ServletR equest object to read the values of the form
(Figure 3.23) ﬁelds in its doG et() method. N ote that the form named F orm1 in
Figure 3.23 speciﬁes “get” as the value of its method attribute.
WARNING
The AdditionInXML servlet uses the doGet() method to obtain informa-
tion entered by the user, in the form of query string variables. Since the
information being passed in this example is not sensitive in nature, the
get method is acceptable. If, however, you are accepting conﬁdential
information from the user, say, a user name and password pair, then use
the HTTPServlet’s doPost() method instead. This will also require
changing the method attribute of Form1 in Figure 3.23 to “post.” In case
you wish to only use the doGet() method, be sure to encode the values
being passed in the query string. 
Assuming that the user puts the option string  in the node-name input ﬁeld
and the N ew O ption string  in the node-value input ﬁeld, the output from
AdditionInX M L will be as shown in Figure 3.27.
O bserve that the value of all the existing nodes named “option” in the DO M
tree has been changed to “N ew O ption.”
N ow, if the user enters a node name, say “N ew N ode,” that does not exist in
the DO M  tree, the new node and its value will be appended to the end of the
document root as shown in Figure 3.28.
T he EmptyX M L.java servlet is called when the user clicks on the E mpty the
E ntire D O M  button in modifyForm.html (See the action attribute of F orm1 in
Figure 3.23).T he servlet contains the code in Figure 3.29.
www.syngress.com
Figure 3.26 Continued

106
Chapter 3 • Processing XML Documents with DOM
www.syngress.com
Figure 3.27 Modifying the Value of an Existing Node
Figure 3.28 Adding a New Node to the DOM Tree

Processing XML Documents with DOM • Chapter 3
107
Figure 3.29 The EmptyXML Servlet
import java.io.*;
import java.net.*;
import java.util.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class EmptyXML extends HttpServlet
{
InputStream xmlStream;
String nodeName = new String();
String nodeValue = new String();
public void doGet(HttpServletRequest request, 
HttpServletResponse response) 
throws ServletException, IOException 
{
PrintWriter outputWriter = response.getWriter();
response.setContentType("text/html");
nodeName = request.getParameter("NodeToAdd");
nodeValue = request.getParameter("ValueToAdd");
// Providing the urlName of the XML File..
String urlname = "http://localhost:8080/examples/Temp.xml";
URL url = new URL(urlname);
URLConnection connection = url.openConnection();
xmlStream  = connection.getInputStream();  
// Calling the Class ModifyXML with the Stream of the XML File, and last
// parameter 1 indicating that DomTree is to be emptied.
ModifyXML myParser = new ModifyXML(xmlStream, nodeName, nodeValue, 1);
// Obtaining the result from the Class.
String returnValue = myParser.returnResult();
outputWriter.println("<center><h1>DOM TREE DESTROYED</center>");
www.syngress.com
Continued

108
Chapter 3 • Processing XML Documents with DOM
outputWriter.close();
xmlStream.close();
}
}
T his servlet calls the M odifyX M L class; however, it passes the value 1 to the
integer parameter, empty.T he output from this servlet is a single line saying
“DO M  T R EE DEST R OY ED” as shown in Figure 3.30.
Advanced Topics
T his completes our discussion on using JAX P to create, modify and manipulate
X M L documents based on the DO M  model.We will now brieﬂy discuss certain
advanced topics relevant to developing and deploying JAX P applications practically.
Multi-threaded Applications
As mentioned in the previous discussions, the D ocumentB uilderF actory class is not
thread-safe. Practical applications, however, are likely to be multi-threaded with var-
ious threads requesting the D ocumentB uilderF actory class simultaneously. In all of this
chapter’s examples, the object of the parsing class is being created in the servlet’s
doG et() method (See Figure 3.15). Since the doG et() method is called for each
request to the servlet, this ensures that each thread creates and uses its own instance
of the D ocumetnB uilderF actory class, which makes these examples thread-safe.
public void doGet(HttpServletRequest request , HttpServletResponse 
response) throws ServletException, IOException 
{
……………………………………………………………………….
……………………………………………………………………….
www.syngress.com
Figure 3.29 Continued
Figure 3.30 Destroying the DOM Tree

Processing XML Documents with DOM • Chapter 3
109
XMLParser  myparser = new XMLParser(xmlstream);
……………………………………………………………………….
……………………………………………………………………….
}
Another way of developing thread-safe applications would be to create only
one object of the D ocumentB uilderF actory class per application and ensure that
only one thread at a time can use the instance.We explain this concept with an
example.
Safe R outines
Let us instantiate the parsing class in the servlet’s init() method. Since the init()
method is called only once (when the servlet is loaded or called for the ﬁrst
time), only one instance of the D ocumentB uilderF actory is created and will be used
by every subsequent call to the service() method.T he handling of parsing func-
tions by a single thread at any instance is implemented via the synchronized()
method as shown in the T hreadSafe.java servlet example (Figure 3.31).
Figure 3.31 The ThreadSafe Servlet
import java.io.*;
import java.util.*;
import java.net.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class ThreadUnsafe extends HttpServlet
{
UnsafeParser myParser;
PrintWriter  outputWriter;
InputStream  xmlStream;
String returnValue;
public void init()
{
myParser  = new UnsafeParser();
}
www.syngress.com
Continued

110
Chapter 3 • Processing XML Documents with DOM
public void doGet(HttpServletRequest request, 
HttpServletResponse response) 
throws IOException, ServletException
{
outputWriter = response.getWriter();
response.setContentType(" text/html ");
String urlname = "http://localhost:8080/examples/Temp.xml";
URL url = new URL(urlname);
URLConnection connection = url.openConnection();
xmlStream  = connection.getInputStream();  
synchronized(this)
{
myParser.parseNow(xmlStream);
returnValue = myParser.returnResult();
}
outputWriter.println("<center><h1>Result of Parsing</center>");
outputWriter.println("<h4> "+returnvalue);
outputWriter.close();
xmlStream.close();
}
}
We list the U nsafeParser class before moving on to the explanation.T he
change made to the parsing code is that the D ocumentB uilder class is being instan-
tiated in a new method called parseN ow().T his prevents the constructor of the
U nsafeParser class from being called for every request, thereby ensuring that the
D ocumentB uilderF actory class is instantiated only once (when the constructor of
U nsafeParser class is created during servlet initialization). R emember that we are
using this code just to explain how the threading issues can be addressed.T his
may not necessarily be code that you should use for practical applications (see
Figure 3.32).
U nsafeParser is an odd name in a section on thread safety.You can alternately
call it “U nsychronizedParser” or something similar that implies that it is assuming
the externalization of synchronization policy.
www.syngress.com
Figure 3.31 Continued

Processing XML Documents with DOM • Chapter 3
111
Figure 3.32 The UnsafeParser.java Class
import java.io.*;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.xml.sax.helpers.*;
import org.w3c.dom.*;
public class UnsafeParser  
{
String result = new String();
DocumentBuilderFactory documentFactory;
DocumentBuilder myDocumentBuilder = null;
Document parsedDocument = null;
// Constructor..
UnsafeParser()
{
documentFactory = DocumentBuilderFactory.newInstance();
// Optional: set various conﬁguration options
documentFactory.setValidating(false);
documentFactory.setIgnoringComments(true);
documentFactory.setIgnoringElementContentWhitespace(true);
documentFactory.setCoalescing(true);
// The opposite of creating entity ref nodes is expanding them inline
documentFactory.setExpandEntityReferences(true);
}
void parseNow(InputStream xmlStream)
{  
try {
myDocumentBuilder = documentFactory.newDocumentBuilder();
} catch (ParserConﬁgurationException pce) {
www.syngress.com
Continued

112
Chapter 3 • Processing XML Documents with DOM
System.err.println(pce);
System.exit(1);
}
try {
parsedDocument = myDocumentBuilder.parse(xmlStream);
} catch (SAXException se) {
System.err.println(se.getMessage());
System.exit(1);
} catch (IOException ioe) {
System.err.println(ioe);
System.exit(1);
}
// Store the DOM tree in a String Object
storeResult(parsedDocument);
}
// The function is responsible for Traversing the DOM Tree and storing
// the result in the Object of the Class String (result). During the 
// Traversal special HTML tags as also added along with the Node 
// Name/Value to as to facilitate understanding.
void storeResult(Node node)
{
String val = node.getNodeValue();
if (val == null)
{
result += "<Font color = \"#ff0000\">Name :</Font> "+ 
node.getNodeName();
result += "<BR>";         
}
else if (val.trim().equals(""))
{
www.syngress.com
Figure 3.32 Continued
Continued

Processing XML Documents with DOM • Chapter 3
113
// Simple Ignore...
}
else
{
result += "<Font color = \"#ff0000\">Name :</Font> " + 
node.getNodeName();
result += "<Font color = \"#0000FF\">&nbsp;&nbsp;&nbsp;Value " +
":</Font>" + val+"<BR>"; 
}
for (Node child = node.getFirstChild(); child != null;
child = child.getNextSibling()) 
storeResult(child);
}
// This function is responsible for returning the result to the Calling 
//program.
String returnResult()
{
return(result);
}
}
T he parsing class, U nsafeParser (we call it “unsafe” because this class in itself
does not address the issue of threading.T he T hreadSafe servlet calls it in a thread-
safe manner) is instantiated by the servlet’s init() method.
public void init()
{
myparser  = new UnsafeParser();
}
Since the init() method is called only once, the U nsafeParser class’s constructor
is likewise invoked once.T his in turn means that only one instance of the
www.syngress.com
Figure 3.32 Continued

114
Chapter 3 • Processing XML Documents with DOM
D ocumentB uilderF actory class (created when the constructor of U nsafeParser class is
called), is being created as shown in the code snippet below:
UnsafeParser()
{
documentfactory = DocumentBuilderFactory.newInstance();
……………………………………………………………………….
……………………………………………………………………….
}
N ote that the servlet’s doG et() method uses this instance using a synchronized()
block:
synchronized(this)
{
myParser.parseNow(xmlstream);
returnValue = myParser.returnResult();
}
T he synchronized() block ensures that only one thread at a time executes the
code given within it.T hus, even if multiple threads are needed to use the parser,
they are forced to do so in a thread-safe manner.
U nsafe R outines
In Figure 3.31 if we do not enclose the call to the parseN ow() method within a
synchronized() block, it is possible that more than one thread will try to use the
myParser object simultaneously. Since there is only one instance of the
D ocumentB uilderF actory class (D ocumentF actory), the parser’s parseN ow() method tries
to use this instance for creating more instances of the D ocumentB uilder class:
void parseNow(InputStream xmlStream)
{
try {
myDocumentBuilder = documentFactory.newDocumentBuilder();
}
……………………………………………………………………….
……………………………………………………………………….
Since the D ocumentB uilderF actory class in itself is not thread-safe, the code may
behave erratically or exceptions/ errors may be thrown.
www.syngress.com

Processing XML Documents with DOM • Chapter 3
115
Parser Attributes
SAX  parsers are conﬁgured by setting their features and properties.A feature has a
B oolean value (true or false), while a property has an object value.T he X M L R eader
interface provides the getF eature() and setF eature() methods respectively to obtain
and to set the value of a feature:
public void setFeature(String name, boolean value) throws 
SAXNotRecognizedException, SAXNotSupportedException
public Boolean getFeature(String name) throws SAXNotRecognizedException,
SAXNotSupportedException
Standard feature names begin with http:/ / xml.org/ sax/ features/ . For
example, the following code sets the validating feature to true:
parserObject.setFeature("http://xml.org/sax/features/validation", true);
If the parser cannot recognize a feature, the SA X N otR ecognizedE xception
is thrown. If the parser is not equipped to support the feature, a
SA X N otSupportedE xception is thrown.
SAX  parsers do not have any of the properties required. H owever, the
X M L R eader interface provides two methods, setP roperty() and getP roperty(),to set
and to retrieve the parser properties:
public void setProperty(String name, Object value) throws
SAXNotRecognizedException, SAXNotSupportedException
public Object getProperty(String name) throws SAXNotRecognizedException,
SAXNotSupportedException
For example, to set the schema location for elements that are not in any
namespace of http:/ / www.propertyexample.com/ schema.xsd, the following code
may be used:
parserObject.setProperty(http://apache.org/xml/properties/schema + 
"external-noNamespaceSchemaLocation", "http://www.propertyexample.com
/schema.xsd");
As against the SAX  parsers discussed above, the parsers used in the various
examples in this chapter set validation, namespace-awareness, and so on as parser
attributes and not as parser properties or features. H owever, these are not
attributes in the X M L sense.Attributes, as deﬁned in X M L, are name-value pairs
providing additional content information.T he parser attributes, however, are
boolean values that can be turned on or off.
www.syngress.com

116
Chapter 3 • Processing XML Documents with DOM
U nlike the SAX  parsers, JAX P-aware parsers do not have a standardized set of
features. Instead, they support various custom and vendor-speciﬁc features. For
example, X erces, has a http:/ / apache.org/ xml/ features/ dom/ create-entity-ref-nodes fea-
ture that lets you choose whether or not to include entity reference nodes in the
DO M  tree.T his is different from deciding whether or not to expand entity refer-
ences, which determines whether or not the entity nodes that are placed in the
tree have children representing their replacement text.
JAX P allows you to get and set these custom features as objects of the appro-
priate type using the following two methods:
public Object getAttribute(String name) throws IllegalArgumentException
public void setAttribute(String name, Object value) throws 
IllegalArgumentException
Suppose you are using X erces and you do not want to include entity refer-
ence nodes. Since they are included by default, you need to set http:/ / apache.org/
xml/ features/ dom/ create-entity-ref-nodes to false.You may use setA ttribute() on the
D ocumentB uilderF actory, as in the following:
DocumentBuilderFactory factory; 
factory = DocumentBuilderFactory.newInstance();
factory.setAttribute(
"http://apache.org/xml/features/dom/create-entity-ref-nodes", 
new Boolean(false)
);
T he naming conventions for both attribute names and values depend on the
underlying parser. X erces uses U R I strings like SAX  feature names. O ther parsers
may do something different. JAX P 1.2 will add a couple of standard attributes
related to schema validation.
Selecting a DOM Parser with 
the Plugability Interface
JAX P is reasonably parser-independent.T he parser that a JAX P program uses
depends on which parsers are installed in your class path and how certain system
properties are set.T he default is to use the class named by the javax.xml.parsers
.D ocumentB uilderF actory system property. For example, if you want to make sure
that X erces is used to parse documents, then you would run Example1.java as per
the following code:
www.syngress.com

Processing XML Documents with DOM • Chapter 3
117
D:\books\XMLJAVA>java-Djavax.xml.parsers.DocumentBuilderFactory=org.apache.
xerces.jaxp.DocumentBuilderFactoryImpl Example1 
If you want to consistently use a certain DO M  parser, gnu.xml.dom
.JA X P F actory for instance, place the following line in the M ETA-IN F.mf ﬁle of
the JAX P package:
javax.xml.parsers.DocumentBuilderFactory=gnu.xml.dom.JAXPFactory
If this fails to locate a parser, JAX P looks for a M ETA-IN F/ services/
javax.xml.parsers.DocumentBuilderFactory ﬁle in all JAR  ﬁles available at run-
time to ﬁnd the name of the concrete D ocumentB uilderF actory subclass.
If that also fails, the D ocumentB uilderF actory.newInstance() returns a default class,
generally the parser from the vendor who provided the JAX P classes. For example,
the JDK  JAX P classes pick org.apache.crimson.jaxp.D ocumentB uilderF actoryImpl by
default.T hus, JAX P implementation provides parsers with sufﬁcient plugability
options.
DOM Parser Search Path
W hen the D ocumentB uilderF actory class is instantiated, it checks the C lasspath vari-
able to locate the X M L parser implementation. If the C lasspath has not been
updated to point to the X M L parser implementation, or if no parser implementa-
tion is provided, an instance of the D ocumentB uilderF actory class cannot be created.
Trying to do so throws a F actoryC onﬁgurationE xception Exception:
public class FactoryConﬁgurationException extends Error{
public FactoryConﬁgurationError();
public FactoryConﬁgurationError(String msg);
public FactoryConﬁgurationError(Exception e);
public FactoryConﬁgurationError(Exception e, String msg);
public Exception getException();
}
T he F actoryC onﬁgurationE rror() method is used to handle the exception.
As already discussed, the object of the D ocumentB uilderF actory class is used to
set the parser’s attributes. If the parser cannot be constructed with the validation
and namespace-awareness settings as speciﬁed by the parser code, a
ParserC onﬁgurationE xception exception is thrown.
public class ParserConﬁgurationException extends Exception{
public ParserConﬁgurationException();
www.syngress.com

118
Chapter 3 • Processing XML Documents with DOM
public ParserConﬁgurationException(String msg);
}
ParserC onﬁgurationE xception may be thrown if the X M L parser implementation
speciﬁes contrary conﬁgurations settings.
Error Handling
T he readers were introduced to error handling in Figure 3.9.T he E xample1.java
class, which is a validating DO M  parser, contains the M yE rrorH andler class that
implements the E rrorH andler interface.T he E rrorH andler interface is implemented
for customized error handling. R efer to the following line of code in T he
E xample1.java class (Figure 3.9)
MyDocumentBuilder.setErrorHandler(new MyErrorHandler());
T his line sets the Error handler by registering its instance with the X M L
reader.
WARNING
If the instance of Error handler is not registered with the XML reader,
XML parsing errors will go unreported and the program code may
behave unpredictably.
R egistration of the error handler’s instance with the X M L reader enables the
SAX  driver to report parsing errors, warnings and fatal errors through this inter-
face instead of throwing exceptions.T he three methods error(), warning() and
fatalE rror() call the error handler class to report errors, receive a SA X ParseE xception
object.T he error() method is used for notiﬁcation of recoverable errors, the
warning() method reports warnings and the fatalE rror() method reports non-recov-
erable errors.
www.syngress.com

Processing XML Documents with DOM • Chapter 3
119
Summary
In this chapter we introduced the concept of DO M  structures for X M L docu-
ments.We showed how a DO M  tree is built from an X M L ﬁle, using relevant
examples.We then discussed the basic interfaces given in W 3C ’s speciﬁcation for
the DO M  model.T his was followed by traversing the hierarchy imposed by the
objects of DO M  interfaces and exploring the interrelationship among various
DO M  objects, again with relevant examples.After sufﬁcient information on DO M
was provided, we moved on to discuss DO M  in the context of JAX P. In this sec-
tion, we discussed the JAX P DO M  API and its deployment.We followed this up
with examples on how to use JAX P classes such as D ocumentB uilderF actory,
D ocumentB uilder and so on, to build DO M  parsers and to set the parser attributes.
We then delved into the issue of handling various X M L input sources (ﬁles,
streams and so on) using JAX P.T hereafter, we walked down a DO M  constellation
to see what its constituents (the root document, the elements, the attributes,
attribute values and so on) are and how they can be obtained.
T he chapter contains complete working program codes for: building a DO M
parser, searching the DO M  tree for speciﬁc nodes, modifying the DO M  tree
nodes/ node values, and so on.We critically examined and explained these codes
to enumerate the code execution and to show the ease with which DO M  docu-
ments can be manipulated. In the end of the chapter, we addressed issues of
multi-threading and how the thread-unsafe D ocumentB uilderF actory class can be
used to build thread-safe parsers, conﬁguring SAX  parsers using the X M L R eader
class, conﬁguring the C lasspath to ensure that the proper X M L parser implemen-
tation is used by JAX P classes, and error handling in JAX P parsers.After going
through this chapter, you should be in a position to build customized DO M
parsers using JAX P to handle the processing requirements of X M L documents.
Solutions Fast Track
T he Document O bject M odel
 T he Document O bject M odel (DO M ) is a World W ide Web consortium
(W 3C ) speciﬁcation that provides a programming interface for both
X M L and H T M L documents.
www.syngress.com

120
Chapter 3 • Processing XML Documents with DOM

DO M  provides a cross-language, cross-platform object-based model for
documents that can be used in a wide variety of environments and with
any programming language.
 T he Tree-based model is easy to navigate, modify and update.
 T he DO M  is efﬁcient for repeated use of a single X M L ﬁle.
JAX P and U nderlying DO M  Engines
 JAX P supports X M L processing using DO M  and provides some
convenient methods to make the X M L APIs easier to use for java
developers.
 T he D ocumentB uilderF actory and D ocumentB uilder interfaces are available
for creating DO M  parsers using JAX P.
C reating a DO M  Parser
 T he newInstance() method creates an instance of the
D ocumentB uilderF actory class; this instance can then be used with the
newD ocumentB uilder() method to create a document builder.
 Various methods such as setIgnoringC omments(),
setE xpandE ntityR eferences(), setC oalescing() and so on can be used to set
the attributes for a JAX P parser.
 An X M L can be parsed using the D ocumentB uilder class’ parse() method
to create a DO M  document.
Parsing X M L into a DO M
 T he parse() method of JAX P’s D ocumentB uilder class accepts different type
of parameters, for example strings, input streams, ﬁles and so on to
accept X M L input from different types of sources.
 T he D ocumentB uilder class’ parse() method converts the X M L into a
DO M  tree.
www.syngress.com

Processing XML Documents with DOM • Chapter 3
121
M anipulating DO M  O bjects
 T he node object provides methods such as getN odeN ame(),
getN odeValue(), getF irstC hild() and so on that can be used to 
navigate through the DO M  constellation.
 T he nodeN ame and nodeValue properties are used to add new nodes or to
modify existing node values in a DO M  tree.
 T he DO M  tree can be destroyed by setting the document object value
to E mptyD ocument.
Advanced Topics
 In a multi-threaded environment, the thread-unsafe
D ocumentB uilderF actory class can be used in a thread-safe manner by
calling the parser within a synchronized() block.
 An error handler can be set using the setE rrorH andler() method of the
D ocumentB uilder class for customized error handling.
Q: W hy should I use the DO M ?
A: T he DO M  model provides a standardized view of a document’s contents. By
implementing the DO M  API, the data from one program can be manipulated
by other routines.Additionally, these manipulations can be reused with other
DO M s.T his interoperability justiﬁes the use of DO M  implementations.
Q: H ow is JAX P different from DO M  and SAX ?
A: DO M  and SAX  represent two standard approaches to handling X M L docu-
ments: in-memory and event-driven. Both DO M  and SAX  omit a deﬁnition
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

122
Chapter 3 • Processing XML Documents with DOM
of how to create a compliant parser; JAX -P provides this standard factory
interface.
Q: W here do I ﬁnd JAX P? 
A: JAX P can be downloaded free of cost from the ofﬁcial Java website at
http:/ / java.sun.com/ jaxp/ .
Q: C an I append a node to any other node in an existing DO M  tree?
A: Yes, you can append a node to any other existing node, except to a Text node.
Trying to do so will result in a D O M E xception being raised.
Q: W hat happens if a parser’s setValidating attribute is set to true, but no error
handling mechanism is deﬁned in the parser?
A: T he code executes normally in such a case. H owever, the X M L parser gener-
ates a warning that the default error handling mechanism will be used, since
one has not been deﬁned by the developer.
www.syngress.com

XML
Transformations
Solutions in this chapter:
■
Reviewing XSL and XSLT
■
JAXP and Underlying XSL Engines
■
Using JAXP Classes
■
Miscellaneous JAXP for XSL Issues
Chapter 4
123
 Summary
 Solutions Fast Track
 Frequently Asked Questions

124
Chapter 4 • XML Transformations
Introduction
In the previous two chapters, we discussed the parsing of X M L data, as well as
some simple X M L manipulations.T he ﬁnal component of JAX P encapsulates
more complicated X M L manipulations. Speciﬁcally, it is designed to provide an
interface to X SLT  and stylesheets.
X SLT  and stylesheets provide a mechanism for automating the transformation
of X M L from one form to another.W hile most frequently used to transform
X M L into H T M L, it can also be used to transform equivalent X M L data between
schemas, or to output data in other browser formats (such as VoiceX M L).
X SLT  and stylesheets are often associated with client-side browsers, not
server-side programming. H owever, nothing in their design limits them to client-
side.T here are often good reasons to perform these manipulations on the server:
to support browsers that do not support X SLT, or to transform X M L between
schemas.
JAX P provides a very thin layer over X SL engines.T he Transformation classes
in JAX P aren’t really designed to be general-purpose X M L transformation
classes, so writing your own Transformer subclass can be a bit tricky.
Reviewing XSL and XSLT
X M L, as you may have noticed, requires a lot of work for it to be properly parsed
through and then displayed accurately on an H T M L page. Proper code needs to
be written to make sure that the values display the correct color scheme, proper
spacing between areas, and the correct information displayed row-by-row or even
table-by-table. X SL provides a mechanism for encapsulating the transformation of
X M L into H T M L in a language speciﬁcally designed for this task, and moving
this task out of the Java code can make the system easier to maintain and under-
stand. (We won’t go into a full review of X SLT / X Path since it’s outside the scope
of this book.)
X SL is the actual recommendation from the W C  3, and consists of two parts:
X SLT  and X SLFO. X SLFO  stands for X SL Formatting O bjects, which are an
X SL speciﬁcation used to control the formatting of printed documents. X SLT, or
X SL for Transformations, is what we’ll primarily deal with here.
T here is another recommendation which comes into play with X SL as well:
X Path. X Path is the recommendation used within X SL to locate the tags, ele-
ments, and attributes within an X M L document.
Let’s take a small X M L ﬁle and transform it through X SLT. Figure 4.1 shows
our X M L ﬁle.
www.syngress.com

www.syngress.com
Figure 4.1 text.XML
01: <?xml version="1.0" encoding="ISO-8859-1"?>
02:  <article>
03:   <title>Top Story</title>
04:   <author>Lydia Gonzalez</author>
05:   <text>
06:    Many children today in Churches
07:    may say the verse "I am the Son
08:    of God" out loud without reading
09:    because they are unable to read.
10:
11:    In tomorrow's edition: see why this
12:    Church has began an outreach program
13:    to parents in low income areas to
14:    provide their children with reading
15:    assistance.
16:   </text>
17:  </article>
Let’s take a look at how our X M L ﬁle appears on a browser without X SL
applied to it (Figure 4.2).
XML Transformations • Chapter 4
125
Figure 4.2 text.XML without XSL/XSLT

126
Chapter 4 • XML Transformations
Pretty much like your normal X M L ﬁle in Explorer, right? N ow let’s take a
look at it via X SL in Figure 4.3.
Pretty neat huh? We’ve taken a lifeless X M L ﬁle, added a reference to the
X SL/ X SLT  ﬁle, and voilà— we get something that, while not perfect, isn’t as
much of an eyesore. O nly one line was added to the X M L ﬁle. Let’s take a look
at the revised header:
<?xml version="1.0" encoding="ISO-8859-1"?>
<?xml-stylesheet type="text/xsl" href="demo.xsl"?>
If you’ve seen C SS/ DH T M L code before, you may notice a similarity
between the xml-stylesheet tag and the src tag. In both cases, the main ﬁle is
calling a stylesheet to transform tags or, in this case, transform the page com-
pletely to another output. In case you’re curious, Figure 4.4 has the X SL/ X SLT
code used to display Figure 4.3.
Figure 4.4 demo.xsl 
00: <?xml version="1.0" encoding="ISO-8859-1"?>
01: <xsl:stylesheet version="1.0"
02:      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
03:  <xsl:template match="/">
04:   <html>
05:    <head>
06:     <title>
www.syngress.com
Figure 4.3 text.XML with XSL/XSLT
Continued

XML Transformations • Chapter 4
127
07:      <xsl:value-of select="article/title"/>
08:     </title>
09:    </head>
10:    <body>
11:     <center>
12:      <b>
13:       <font face="Arial" size="3">
14:        <xsl:value-of select="article/title"/>
15:       </font>
16:      </b>
17:      <br/>
18:      <b>
19:       <i>
20:        <font face="Arial" size="2" color="#FF0000">
21:          by <xsl:value-of select="article/author"/>
22:        </font>
23:       </i>
24:      </b>
25:      <table bgcolor="#003366" width="300">
26:       <tr>
27:        <td>
28:         <font face="Arial" size="3" color="#FFFFFF">
29:          <xsl:value-of select="article/text"/>
30:         </font>
31:        </td>
32:       </tr>
33:      </table>
34:     </center>
35:    </body>
36:   </html>
37:  </xsl:template>
38: </xsl:stylesheet>
Take a quick look at lines 06, 14, 21, and 29 in the previous ﬁgure.You may
have noticed that these lines don’t contain anything that may ﬁt with either
www.syngress.com
Figure 4.4 Continued

128
Chapter 4 • XML Transformations
H T M L or even X M L, but sound like they are “matching” something.T hey are,
in fact, X Path expressions used with X SL/ X SLT  to locate the items in the X M L
ﬁle that will be displayed, and fall under the Procedural X SL category.
XPath and XSLT
Before we look at just how X SLT  works, we need to ﬁrst understand what X SLT
uses to ﬁnd its information. X Path is a W 3C  recommendation made speciﬁcally
for locating nodes, attributes, and their values within an X M L ﬁle for an X SLT
processor to transform. X Path uses notation similar to a directory structure nota-
tion in order to locate nodes.
An X Path picks out a set of target nodes by specifying how to match nodes
down the X M L hierarchy. Each successive level of the hierarchy is speciﬁed by
one part of the X Path, much like directories and subdirectories are speciﬁed in
U nix. Similar to U nix, the root of the X M L ﬁle is deﬁned as a single forward
slash (/ ). Each successive level of the hierarchy is separated by another forward
slash.T he complete speciﬁcation is referred to as a location path, and serves to
identify the X M L nodes to use in the transformation.
X Path requires that the name of the root node of the X M L ﬁle be deﬁned
when used within X SLT. Back in Figure 4.4 in line 03 we deﬁned the root node
as “/ ” within our X SLT ; this allowed us to use the root as a relative path in lines
06, 14, 21, and 29.
U sing the X M L in Figure 4.1 as our example X M L, we can think of the “/ ”
root as pointing to the overall X M L document.T herefore, lines 06, 14, 21, and 29
pointed to various speciﬁc areas within the X M L.Table 4.1 has a listing of the
referenced nodes and what they point to.
Table 4.1 XPath Node Reference
Line
Complete XPath
Points to:
06
/article/title
Line 03 of Figure 4.1
14
/article/title
Line 03 of Figure 4.1
21
/article/author
Line 04 of Figure 4.1
29
/article/text
Lines 05 through 09 of Figure 4.1
We can also use a double forward slash (/ / ) to indicate multiple matches. For
example,“/ / text” would locate all text elements anywhere below the article node.
T he wildcard symbol (*) can be used within X Path.Assuming we had a second-
www.syngress.com

XML Transformations • Chapter 4
129
level to the X M L in Figure 4.1 we could also match all the nodes named “text”
within the X M L by using / articles/ */ text.
You may be wondering right about now what the difference is between using
“/ / ” and the “*” character.T he “/ / ” will match all nodes that match the search
criteria, while the “*” will match all nodes based on the proceeding path. So, if
you wanted to locate all of the nodes within an X M L ﬁle you can’t just do “/ / ”
or “/ *” you would have to do “/ / *”, which would match all elements with all
names. X Path is able to do all this thanks to its use of axes.
Axes and Locations
In the simplest sense, an axis is a symbolic link to the parent node that it is cur-
rently selected, and contains all the immediate child nodes. Based on this one
axis, several other axes can be determined.Table 4.2 displays the list of axes that
are exposed.
Table 4.2 Exposed Axes
Axis
Description
Ancestor
All the parents of the current node up to and including
the root of the topmost parent node; it will display any
grandparents, and so on. The “//” is an alias for ancestor.
Ancestor-or-self
The parents of the current node but also includes its posi-
tion relative to the root node; it will display any grand-
parents, and so on.
Attribute
An XML attribute of the current node, if any. “@” is an
alias for attribute.
Child
An immediate child of the current node. Child is the
default and can be omitted.
Descendant
All nodes descending from the current node; does not
include namespace or attributes.
Descendant-or-self All nodes descending from the current node; does not
include namespace or attributes. Always includes the cur-
rent node.
Following
All nodes after the current node in the document, in the
order the nodes appear in the source document. Does not
include descendant, namespace, or attribute nodes.
Following-sibling
Same as following but only on nodes with same imme-
diate parent as current node. Does not include name-
space or attribute nodes.
www.syngress.com
Continued

130
Chapter 4 • XML Transformations
Namespace
Any namespace child nodes within current node.
Parent
Immediate parent of the current node if it’s available.
Returns a single-parent only. The “..” character is an alias
for parent.
Preceding
All preceding nodes listed, including root, excluding
attribute and namespace nodes, in the order they appear
in the source document.
Preceding-sibling
All preceding nodes of the current node that share the
same parent. Namespace and attribute nodes are
excluded.
Self
The current node. The “.” character is an alias for self.
A location step, a construct to select a node based on the information from the
axis, is then used to do the actual node selection behind the scenes.A complete
location step contains the axis, two colons, the node-test and a set of predicates
within brackets.T he predicates act as a ﬁlter within the location step.T hink of a
node-test as a conditional statement.A location step can also use certain functions
allowed by X Path.We won’t be going into long detail about X Path functions and
how they work since it’s outside the scope of this book.You can ﬁnd more infor-
mation about them at www.w3.org/ T R / xpath#section-Function-C alls.We will,
however, go through the more common functions as we work through X SL
before looking at JAX -P.
Procedural XSLT
N ow that we have a better idea of how X Path works, we can start to view how
X SLT  works with X Path. X Path, as we noticed in the X SLT  example, usually is
called from an X SLT  procedure. R emember, X SLT  works as a procedure, exe-
cuting transformations when called.
<xsl:template>
<xsl:template> is perhaps the procedure you’ll most often work with. It allows
you to deﬁne a template to match node items directly.You always use 
<xsl:template> to deﬁne the template applied with <xsl:apply-template>.
<xsl:template> can take the following attributes:
www.syngress.com
Table 4.2 Continued
Axis
Description

XML Transformations • Chapter 4
131
■
match  T his can be any node or location path.An example might be:
<xsl:template match=“ node” > where “node” is where you want the match
to take place. For example, <xsl:template match=“ / ” > starts the match
from the root of the document.
■
mode  mode is used with match to allow multiple matches that require
different implementation.An example might be: <xsl:template match=
“ node” mode=“ mode” >. M odes are used to match xsl:templates to
xsl:apply-templates, allowing you to control which templates are used for
a given element. For example, a mode could be “ set1” , which would
mean that the template would apply its values to elements that have the
mode “ set1” .
■
name  name is used to deﬁne a called template and is used in conjunc-
tion with <xsl:with-param> and <xsl:call-template>.An example might
be: <xsl:template name=“ demoTemplate” >.
■
priority  priority is rarely used. Its main purpose is to give a template a
higher priority and is only truly useful when working with multiple
X SL stylesheets that happen to have similar matches or names. Generally
speaking, however, whenever you work with multiple stylesheets you
will always want to avoid conﬂicting matches.T his can also be used for
single stylesheets but I think we all agree that conﬂicting matches on
purpose are a bad thing.An example might be: <xsl:template priority=
“ 10” >.
<xsl:apply-template>
T his is the procedure used to apply the template deﬁned by <xsl:template>. It can
also use the mode attribute.
■
select Declares which X M L pattern will be matched; can use any loca-
tion path combination.An example might be <xsl:apply-template
select=“ / ” >, which  states that the template should be applied to the root
of the X M L tree.T his is often used with X M L, that generates H T M L to
replace the entire output tree into H T M L format.
■
mode  M atches the mode given in the xsl:template that is being
applied.
www.syngress.com

132
Chapter 4 • XML Transformations
<xsl:for-each>
As the name implies, this X SL procedure handles a standard for-each loop. It uses
the same select attribute that <xsl:apply-template> has.
T he basic syntax is:
<xsl:for-each select="node or location path">
..transformation here
</xsl:for-each>
Looking back at Figure 4.1, we can see that if our X M L contained multiple
authors, the X SL would not work.We’d need to use a <xsl:for-each> loop to gen-
erate individual tables for each item. Let’s modify the X SL in Figure 4.4 to
include a <xsl:for-each> loop. Figure 4.5 has our modiﬁed X SL code and Figure
4.6 contains a new X M L, displaying a new root element “articles” with each
news item listed as an “article”.
Figure 4.5 demo2.xsl
01: <?xml version="1.0" encoding="ISO-8859-1"?>
02: <xsl:stylesheet version="1.0"
03:     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
04:  <xsl:template match="/">
05:   <html>
06:    <head>
07:     <title>Articles</title>
08:    </head>
09:    <body>
10:     <center>
11:      <xsl:for-each select="articles/article">
12:       <table border="0">
13:        <tr>
14:         <b>
15:          <font face="Arial" size="3">
16:           <xsl:value-of select="title"/>
17:          </font>
18:         </b>
19:         <br/>
20:         <b>
21:          <i>
www.syngress.com
Continued

XML Transformations • Chapter 4
133
22:           <font face="Arial" size="2" color="#FF0000">
23:            by <xsl:value-of select="author"/>
24:           </font>
25:          </i>
26:         </b>
27:        </tr>
28:       </table>
29:       <table bgcolor="#003366" width="300">
30:        <tr>
31:         <td>
32:          <font face="Arial" size="3" color="#FFFFFF">
33:           <xsl:value-of select="text"/>
34:          </font>
35:         </td>
36:        </tr>
37:       </table>
38:      </xsl:for-each>
39:     </center>
40:    </body>
41:   </html>
42:  </xsl:template>
43: </xsl:stylesheet>
Figure 4.6 text2.xml
01: <?xml version="1.0" encoding="ISO-8859-1"?>
02: <?xml-stylesheet type="text/xsl" href="demo2.xsl" ?>
03: <articles>
04:  <article>
05:   <title>Top Story</title>
06:   <author>Lydia Gonzalez</author>
07:   <text>
08:    Many children today in Churches
09:   may say the verse "I am the Son
10:    of God" out loud without reading
www.syngress.com
Figure 4.5 Continued
Continued

134
Chapter 4 • XML Transformations
11:    because they are unable to read.
12: 
13:    See why this Church has began
14:    an outreach program to parents in
15:    low income areas to provide their
16:    children with reading assistance in
17:    tomorrow's edition.
18:   </text>
19:  </article>
20:  <article>
21:   <title>Another Idea</title>
22:   <author>Luis Gonazalez Sr.</author>
23:   <text>
24:    We will continue to explore the
25:    ﬁndings at this Church as the
26:    story continues to develop.
27:   </text>
28:  </article>
29: </articles>
T he resulting H T M L displayed is shown in Figure 4.7.
<xsl:if>
T his X SL procedure handles a standard if-then test. <xsl:if> only has one
attribute, test, which speciﬁes the value to test against, and is then converted to a
true-false value. O ften, the value of a node is checked and then the necessary
changes or effects applied.T he syntax for <xsl:if> is the following:
<xsl:if test="test procedure>"
.. transformation here
</xsl:if>
H ere’s an example. Let’s assume the X M L in Figure 4.1 had multiple news
items, with one written by the editor. Because of this, you’d probably want to see
the editor’s title in a different color below the name.To get this effect, all we’d
have to do is modify the code in lines 22 and 23.We’ll use the same X M L shown
previously in Figure 4.6. Figure 4.8, meanwhile, shows the modiﬁed xsl ﬁle.
www.syngress.com
Figure 4.6 Continued

XML Transformations • Chapter 4
135
Figure 4.8 demo-if.xsl
01: <?xml version="1.0" encoding="ISO-8859-1"?>
02: <xsl:stylesheet version="1.0"
03:     xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
04:  <xsl:template match="/">
05:   <html>
06:    <head>
07:     <title>Articles</title>
08:    </head>
09:    <body>
10:    <center>
11:      <xsl:for-each select="articles/article">
12:       <table border="0">
13:        <tr>
14:         <b>
www.syngress.com
Figure 4.7 HTML Resulting from Code in Figure 4.6
Continued

136
Chapter 4 • XML Transformations
15:          <font face="Arial" size="3">
16:           <xsl:value-of select="title"/>
17:          </font>
18:         </b>
19:         <br/>
20:         <b>
21:          <i>
22:           <font face="Arial" size="2" color="#FF0000">
23:            by <xsl:value-of select="author"/>
24:            <xsl:if test="author='Luis Gonazalez Sr.'">
25:             <br/>
26:             <b>News Editor</b>
27:            </xsl:if>
28:           </font>
29:          </i>
30:         </b>
31:        </tr>
32:       </table>
33:       <table bgcolor="#003366" width="300">
34:        <tr>
35:         <td>
36:          <font face="Arial" size="3" color="#FFFFFF">
37:           <xsl:value-of select="text"/>
38:          </font>
39:         </td>
40:        </tr>
41:       </table>
42:      </xsl:for-each>
43:     </center>
44:    </body>
45:   </html>
46:  </xsl:template>
47: </xsl:stylesheet>
Figure 4.9 shows how the document would now be displayed.
www.syngress.com
Figure 4.8 Continued

XML Transformations • Chapter 4
137
<xsl:choose>, <xsl:when>, <xsl:otherwise>
T hese three procedures work together to form a multitest conditional statement.
T hese statements are similar to the switch statement in Java, as shown in the fol-
lowing example:
<xsl:choose>
<xsl:when test="test"
.. transformation
</xsl:when>
<xsl:otherwise 
.. transformation
</xsl:otherwise>
</xsl:choose
You can have multiple <xsl:when> within the choose. M eanwhile, the
<xsl:otherwise> handles any cases that don’t match.
www.syngress.com
Figure 4.9 Result of Adding the xsl:if Clause to Our XSL

138
Chapter 4 • XML Transformations
<xsl:sort>
<xsl:sort> allows a simple sort to be run on the X M L ﬁle, and can take the fol-
lowing attributes:
■
select  Declares which X M L pattern will be matched; can use any loca-
tion path combination.An example might be: <xsl:apply-template
select=“ node or location path” >.
■
lang  T his is a language declaration for use in multilanguage sorts and
uses the same values deﬁned in R FC  1766
(www.ietf.org/ rfc/ rfc1766.txt).
■
data-type  T his deﬁnes the data type we are sorting for. It can be text,
number, or qname (see www.w3.org/ T R / xslt#qname for more infor-
mation).T he default is text.
■
order  Deﬁnes the order in which the sort is displayed; can be either
ascending or descending. Default is descending.
■
case-order Deﬁnes which case type takes priority when working with
text. upper-ﬁrst gives priority to uppercase letters and lower-ﬁrst gives pri-
ority to lower case letters.
H ere is an example:
<xsl:sort select="article/author" 
lang = "en-us" data-type="text" 
order="descending" case-order="uppercase" />
N ote that <xsl:sort> is a standalone procedure.
<xsl:value-of>
<xsl:value-of> allows us to query a particular element and retrieve its value. Back
in Figure 4.4, we used it to display the values of the title, author, and text ele-
ments.
<xsl:output>
X SLT  supports various output types called output trees.Technically, this is just the
method you chose within your X SLT  code that the X M L is output as.You can
choose from H T M L, X M L,T EX T, or Q N ame.You can then deﬁne the output tree
type within X SL using the <xsl:output> procedure.T his is a top-level procedure so
www.syngress.com

XML Transformations • Chapter 4
139
you have to have it at the beginning of your X M SLT  ﬁle, preferably before the
<xsl:template match=“ / ” > line.
H ere is an example of the output:
<xsl:output
method = "HTML"
version = "4.0"
encoding="ISO-8859-1"
standalone="yes" />
<xsl:output> supports the following attributes:
■
method  Sets which type of ﬁle to output to; can be H T M L, X M L,
T EX T, or Q name.
■
version  Sets which version of the selected method to use.
■
encoding  Sets which language encoding to display.
■
omit-xml-declaration  Determines whether or not an X M L declara-
tion should be output; can be yes or no.
■
standalone  Determines whether or not a standalone document decla-
ration should be output; can be yes or no.
■
doctype-public  Sets the public identiﬁer to be used in the dtd.
■
doctype-system  Sets the system identiﬁer to be used in the dtd.
■
cdata-section-elements  Speciﬁes qnames that need to be output as
C DATA sections.
■
indent  Determines whether or not additional whitespace is included
when outputting the ﬁle. C an be yes or no.
■
media-type  Deﬁnes the M IM E content type of the output data.
N ow that we are done with our review of basic X SLT  concepts, we can turn
our attention to the matter at hand: the JAX P interfaces for Java.
JAXP and Underlying XSL Engines
W hile the X SL language is standardized, the X SL engines for Java are not.
Engines like SAX O N  and X alan have a lot of functionality, but do so with pro-
prietary interfaces. Java developers need an API that is compatible with Java but
can work with pre-existing engines that already have widespread support and
www.syngress.com

140
Chapter 4 • XML Transformations
usage within the Java community. JAX -P, the Java API for X M L Processing, was
built with this type of interface in mind. JAX P itself originates from a previous
project named TrAX  that was incorporated into JAX -P.
As in the parsing capabilities of JAX -P, the X SLT  capabilities are a series of
interfaces that wrap an underlying engine.T he engine provides the functionality,
while the APIs provide a regular mechanism for accessing this functionality.T his
allows code to be written that leverages an X SLT  engine, without becoming
dependant on its proprietary APIs.
In order for X SLT  engines to be swapped in and out, JAX P introduces a
transformer factory class.T he factory class returns an instance of a class speciﬁc to
an X SLT  implementation; this class acts as the bridge between the underlying
functionality and the generic API.
T he plugability interfaces will be discussed more later. In general, however,
you don’t have to worry about them, so long as you have a JAX -P-compliant
library available.T he library will automatically conﬁgure the system to use its
own implementation classes. It’s only if you have multiple X SLT  libraries avail-
able, or if you want to try to mix and match X SLT  and parsing capabilities across
libraries, that you have to worry about plugability.T hese cases are discussed next.
Using JAXP Classes
T he JAX P classes for transformation are almost all contained in the java.xml
.transform package, which provides the basic functionality for X SLT  transforma-
tions.T hree additional packages, javax.xml.transform.dom, javax.xml.transform.sax,
and javax.xml.transform.stream provide some additional classes for specifying how
the X SLT  engine should read input and write output.
T his section will cover the basic JAX P X SLT  classes: the javax.xml.transform
package. Later, we’ll discuss the supporting packages for input and output, and
show a complete example program.
Creating a Transformer
A transformation is the process of applying an X SL ﬁle to an X M L ﬁle and then
producing the output. In order to isolate the application from the speciﬁcs of cre-
ating transformation-supporting code in a speciﬁc X SLT  engine, JAX P uses the
TransformerFactory class.TransformerFactorys are used to create Tranformer and
Template instances (more about these in the following) from classes the engines
implement.
www.syngress.com

XML Transformations • Chapter 4
141
T he ﬁrst thing you have to do for any X SLT  transformation using JAX P is
obtain a TransformerFactory.TransformerFactory is an abstract class provided by
the JAX P library, and has two purposes.A static method of this class is used to
obtain an instance of a concrete subclass provided by an X SLT  engine. O nce this
concrete instance is obtained, methods deﬁned by the abstract class and imple-
mented by the concrete can be used to create the Transformers and Templates
used to handle the transformations.
Sound confusing? It really isn’t, once you see an example.T he following pro-
gram (shown in Figure 4.10) obtains a TransformerFactory, and then uses it to
create a new Transformer.T he Transformer would then be used to process an
X SL stylesheet, but that isn’t included in this example.
Figure 4.10 Our ﬁrst JAX-P/XSL Example Program
package com.syngress.jwsdp.xsl;
import javax.xml.transform.*;
public class Example1
{
public static void main( String args[] )
{
try
{
// Obtain a new TransformerFactory
TransformerFactory factory;
factory = TransformerFactory.newInstance();
// Use it to create a new transformer
Transformer transformer;
transformer = factory.newTransformer();
}
catch (TransformerFactoryConﬁgurationError tfce)
{
System.out.println( "Could not obtain factory" );
tfce.printStackTrace();
}
catch (TransformerConﬁgurationException tce)
www.syngress.com
Continued

142
Chapter 4 • XML Transformations
{
System.out.println( "Could not create transformer" );
tce.printStackTrace();
}
}
}
You’ll note in the preceding code that we had to catch two exceptions.T he
ﬁrst,TransformationFactoryC onﬁgurationException, is thrown if the concrete fac-
tory class can’t be found or instantiated.T his will generally be due to not having a
X SLT  library in the classpath, but could potentially have other causes as well.T he
second, TransformerC onﬁgurationE xception, will generally be because you have
requested the factory (via the following methods) to create a Transformer with
speciﬁc properties, but those properties are not supported.
NOTE
The newTransformer() method that follows actually returns a default
Transformer object that just copies XML from one place to another. This
is not generally a useful transformation, but since we are just trying to
illustrate the use of the TransformerFactory in this example, it’s a handy
simpliﬁcation.
Table 4.3 describes the list of methods available to TransformerF actory.
Table 4.3 TransformerFactory Methods
Methods
Description
getAssociatedStylesheet(Source, Gets stylesheet that matches the xml-
String, String, String)
stylesheet processing tag.
getAttribute(String)
Gets the attributes of the implementation 
in use.
getErrorListener()
Returns the error event handler.
GetFeature(String)
Returns the value of the feature.
www.syngress.com
Figure 4.10 Continued
Continued

XML Transformations • Chapter 4
143
getURIResolver()
Returns the default object used to resolve a
URI found in <xsl:import>, <xsl:include>,
or document().
newInstance()
Creates a new TransformerFactory instance.
newTemplates(Source)
Returns a new Template associated with the
given source.
newTransformer()
Creates a new Transformer instance.
newTransformer(Source)
Creates a new Transformer instance for a
given source.
setAttribute(String, Object)
Deﬁnes attributes in the underlying imple-
mentation.
setErrorListener(ErrorListener)
Used in conjunction with class ErrorListener;
sets the error event listener for a
TransformerFactory object.
setURIResolver(URIResolver)
Sets the URIResolver object to be used with
the current TransformerFactory.
N ote that newInstance was already introduced earlier in the chapter.T he
newTemplates and newTransformer methods are used to create Templates and
Transformers, respectively, and are discussed later in this chapter.
T he getA ssociatedStylesheet method is used to scan through an X SL document
that contains multiple embedded stylesheets. It attempts to ﬁnd the best match
for the given criteria, which can specify the media, title, and character set.
U sing getAssociatedStylesheet allows you to maintain a collection of stylesheets
which have the same purpose (but for different environments) in a single master
document.
T he getA ttribute and setA ttribute methods should be used with caution.T hey
give you access to setting attributes of the underlying implementation, and as
such, bind your code to that implementation. If you switch to a different imple-
mentation that does not support that attribute, an IllegalA rgumentE xception will be
thrown. Since this may happen long after you decide to use get/ setA ttribute, and
only at the point in time that you change X SLT  libraries, you may confuse this
with errors in the underlying X SLT  engine. Proceed with caution with these
methods, and document the code that uses them carefully.
www.syngress.com
Table 4.3 Continued
Methods
Description

144
Chapter 4 • XML Transformations
Similarly, getF eature can be used to query the underlying X SLT  engine.T he
getF eature method accepts a string representing a U R I, and returns a Boolean
result.W hile the U R I passed in could be any valid U R I, there are a few prede-
ﬁned ones. For example, in the javax.xml.transform.dom.D O M Source class, a public
static variable F eature is deﬁned.T his can be used to query the underlying X SLT
engine to ensure that DO M -based sources are supported. If they are, the method
will return True, otherwise it will return False.
T he getE rrorL istener and setE rrorL istener methods manipulate the E rrorL istener
objects associated with the factory. E rrorL isteners are discussed in further detail
later, but to summarize them brieﬂy they provide a mechanism for responding to
errors encountered while performing the X SL processing. getE rrorL istener returns
the E rrorL istener currently in use, while setE rrorL istener changes to a new one.T he
error listeners on the factory should not be confused with the error listeners
associated with Transformers or Templates; the error listener associated with the 
factory is used when processing transformation instructions, not while processing
the transformation itself.
T he getU R IR esolver and setU R IR esolver methods manipulate U R IR esolver
objects associated with the factory.T hese objects are used when processing X SL
constructs that reference external stylesheets (the xsl:import and xsl:include tags,
and the document() method). U R IR esolvers have the chance to perform custom
code to resolve the location of these entities. U nlike E rrorL isteners, the
U R IR esolver associated with the factory does effect the Transformers and
Templates created by a factory; the U R IR esolver associated with a factory will 
be the default U R IR esolver for all Templates/ Transformers that are created after
the call to setU R IR esolver.
Source and R esult
Before we can talk about the Transformer and Templates classes (which perform
the actual X SL processing), we should discuss how the input and output of the
processing are communicated to the underlying engine.T he Source class and
R esult class handle exactly what their name suggests— the source X M L ﬁle or
transformation instructions, and the result of the transformation, respectively.
T he Source and R esult interfaces are little more than markers, allowing for
the setting and getting of a system ID (a unique identiﬁer associated with the
location of the data), but nothing else.You won’t ever create an instance of
Source or R esult directly; rather you will create an instance of D O M Source,
D O M R esult, SA X Source, SA X R esult, StreamSource, or StreamR esult.T hese 
www.syngress.com

XML Transformations • Chapter 4
145
classes provide the mechanisms for wrapping DO M -based data, SAX -based data,
and Stream-based data, respectively.T hey do this by accepting an instance of the
data they are wrapping in their constructors. For example, DO M Source takes a
org.w3c.dom.N ode object in its constructor, while StreamR esult can take an instance
of O utputStream.
D O M Source and D O M R esult are members of the javax.xml.transform.dom
package. SA X Source and SA X R esult are members of javax.xml.transform.sax, while
StreamSource and StreamR esult are members of javax.xml.transform.stream. X SLT
engines are not required to support all these data types, but most will.
Data types can be freely mixed and matched (so long as they are supported).
For example, you can specify a DO M Source and a StreamR esult.T he X SLT
engine would then read data from a DO M  in memory, and write data to an
O utputStream.
You might be tempted to ask about creating your own R esult and Source
classes to support some other data type. U nfortunately, you can’t.T he X SLT
engine will actually check the Source/ R esult object via the instanceof operator,
comparing it to the well-known implementing classes. If it isn’t one of those
classes, the engine will not know what to do. Generally, however, you can use the
StreamSource and StreamR esult classes for most types of data— for example, you can
specify U R L-based data (with the stream return from U R L .openStream), ﬁle-based
data (with a F ileInputStream or F ileO utputStream), and so forth.
Transformer
N ow that we’ve looked at how to create a factory, and how to specify the source
and result locations, we need to look at the actual classes used for performing
transformations.T he ﬁrst of these is the Transformer class; we will look at this class
ﬁrst and defer discussing the other class (Templates) for just a bit.
Transformer deﬁnes a class for performing X SL transformations.T he
Transformer class itself is abstract; the actual object you get back from the
TransformerF actory is a concrete implementation class speciﬁc to the X SLT  
engine. H owever, you don’t have to worry about that; you can just use the object
through the public interface of Transformer.
T he main method of Transformer is the transform method.T he transform
method accepts a source object (the input X M L document) and a result object
(the resulting X M L document).T he X SL stylesheet associated with the transfor-
mation is inherent in the Transformer object; when you create a Transformer with
www.syngress.com

146
Chapter 4 • XML Transformations
a TransformerF actory, you specify a Source object that represents the X SL stylesheet
to use.
T his means you can use the same Transformer multiple times to transform
multiple sources. H owever, as we’ll see in just a moment, there are some serious
limitations when doing this. Shortly, we’ll introduce the Templates class, which is
more useful for repeated transformations.
As we’ve mentioned, the transform method is the one you will use most often
with the Transformer class. H owever, there are some other methods of interest.
T he getParameter, setParameter, and clearParameters methods are used to get, set,
and clear all parameters, respectively.T hese routines allow you to specify values
for xsl:param tags in your templates; specifying values for parameters allows you to
pass values into the stylesheet.
Like TransformerF actory, you can use setE rrorL istener and getE rrorL istener, as well
as setU R IR esolver and getU R IR esolver. T he U R I resolver methods act as you might
expect; they override the default U R I resolvers set at the factory level with
Transformer-speciﬁc instances.T he error listener methods do the same, but you
have to remember that the error listener set at the factory level is not the default
for the Transformer; it only applies to the factory itself. So if you need U R I
resolvers for your Transformers, you can set a default at the factory level and be
done. H owever, if you need an error listener for your Transformers, you have to
set it explicitly for each Transformer you create.
T he remaining methods of Transformer manipulate the output properties set
for the stylesheet.T hese properties, initially deﬁned in an xsl:output tag, specify
how the output is to be rendered. (See the earlier section on xsl:output.) You can
use getO utputP roperty to retrieve a speciﬁc property, or getO utputP roperties to
retrieve all the properties currently deﬁned.To change the properties (which
overrides the defaults set in the stylesheet), you can use setO utputP roperty to set a
speciﬁc property, or setO utputP roperties to change them all at once.
Table 4.4 summarizes the Transformer methods.
Table 4.4 Transformer Methods
Methods
Description
clearParameters()
Flushes parameters that have been set with
setParameters().
getErrorListener
Sets the error listener object
getParameter(String)
Gets the value of a parameter.
getOutputProperties()
Returns a copy of output properties.
www.syngress.com
Continued

XML Transformations • Chapter 4
147
getOutputProperty(String)
Returns one output property.
getURIResolver()
Returns the object used to resolve a URI
found in <xsl:import>, <xsl:include>, or
document().
setErrorListener(ErrorListener)
Sets the error listener for a Transformer
object.
setOutputProperties(Properties)
Sets the output properties.
setOutputProperty(String, String) Sets one output property.
setParameter(String, Object)
Sets the value of a parameter.
setURIResolver(URIResolver)
Sets the URIResolver object that will be used
with the current Transformer.
transform(Source, Result)
Actual transformation using the current
source tree in the Source object to output
to the Result object.
N ow we will look at an example program that creates a Transformer based on
the demo.xsl ﬁle we introduced earlier.T he code looks similar to the preceding
example program, except for some additional imports, until about line 18.At that
point, instead of creating the default Transformer object, we create a Transformer
that is associated with the demo.xsl ﬁle.
We do this by ﬁrst creating a F ileInputStream associated with the ﬁle, and then
wrapping that in a StreamSource.As mentioned previously, StreamSource allows you
to pass the source for a document into the X SL transform engine via an input
stream. O nce we’ve wrapped the X SL ﬁle stream in a StreamSource, we use the
factory newTransformer method to obtain a Transformer that is based on that X SL
stylesheet.
O n lines 24 through 26, we do something similar for the ﬁle output stream
that speciﬁes the result: we wrap it in a StreamR esult object so we can pass it into
the X SL engine. Lines 28 through 30 wrap the source X M L, and we are ready to
invoke the transform.We do this on line 32, by using the transform method of the
Transformer class.
You’ll also note that we added some additional exception handling. Lines 45
through 54 are there to handle exceptions thrown by the java.io libraries, or the
stream wrappers. (See Figure 4.11.)
www.syngress.com
Table 4.4 Continued
Methods
Description

148
Chapter 4 • XML Transformations
Figure 4.11 A Working JAX-P/XSL Example
01: package com.syngress.jwsdp.xsl;
02: 
03: import java.io.*;
04: import javax.xml.transform.*;
05: import javax.xml.transform.stream.*;
06: 
07: public class Example2
08: {
09:  public static void main( String args[] )
10:  {
11:   try
12:   {
13:    // Obtain a new TransformerFactory
14:    TransformerFactory factory;
15:    factory = TransformerFactory.newInstance();
16: 
17:    // Use it to create a new transformer
18:    Transformer transformer;
19:    InputStream xslInput;
20:    xslInput = new FileInputStream( "demo.xsl" );
21:    Source xslSource = new StreamSource( xslInput );
22:    transformer = factory.newTransformer( xslSource );
23: 
24:    OutputStream resultStream;
25:    resultStream = new FileOutputStream( "result.html" );
26:    Result result = new StreamResult( resultStream );
27: 
28:    InputStream sourceStream;
29:    sourceStream = new FileInputStream( "text.xml" );
30:    Source source = new StreamSource( sourceStream );
31: 
32:    transformer.transform( source, result );
33: 
34:   }
35:   catch (TransformerFactoryConﬁgurationError tfce)
www.syngress.com
Continued

XML Transformations • Chapter 4
149
36:   {
37:    System.out.println( "Could not obtain factory" );
38:    tfce.printStackTrace();
39:   }
40:   catch (TransformerConﬁgurationException tce)
41:   {
42:    System.out.println( "Could not create transformer" );
43:    tce.printStackTrace();
44:   }
45:   catch (FileNotFoundException fnf)
46:   {
47:    System.out.println( "File not found" );
48:    fnf.printStackTrace();
49:   }
50:   catch (TransformerException te)
51:   {
52:    System.out.println( "Transformer exception" );
53:    te.printStackTrace();
54:   }
55:  }
56: }
Templates
It isn’t practical to use Transformers alone in high volume, multithreaded applica-
tions. For one thing, the TransformerF actory.newTransformer method parses the X SL
source each time, which can be a signiﬁcant overhead. M ore to the point,
Transformers aren’t thread-safe, so in a multi-threaded application you either have
to manage the thread safety yourself, or use Templates.
Templates are designed to solve many of the problems that Transformers have.
T hey parse the X SL one time, and keep a parsed copy of it internally. From that
internal copy, they can create multiple Transformers— in a thread-safe manner. So,
you can create a single Template object and use it to create multiple Transformers,
one for each thread.T his can result in signiﬁcant performance improvements in a
heavily-used application.
www.syngress.com
Figure 4.11 Continued

150
Chapter 4 • XML Transformations
U sing Templates is pretty straightforward.You basically have a single extra set in
our code from using Transformers directly. Instead of calling the newTransformer
method of TransformerFactory, you call newTemplates with the same arguments.T his
returns a Templates object. O nce you have this object, you can call newTransformer
on it (which takes no arguments) to obtain a Transformer object you can use.
T he only other method on the Templates interface is the getO utputP roperties
method, which can be used to retrieve the output properties deﬁned in an
xsl:output tag in the stylesheet associated with Templates.
T he code that follows (Figure 4.12) shows the example program modiﬁed to
use Templates. O f course, in the real world you would only do this for a multi-
threaded application; there isn’t any beneﬁt to using Templates in a single-
threaded one.Also, you would probably want to synchronize the creation of the
Templates object, so it’s only created by one thread.
Figure 4.12 Using Templates in JAX-P
01: package com.syngress.jwsdp.xsl;
02: 
03: import java.io.*;
04: import javax.xml.transform.*;
05: import javax.xml.transform.stream.*;
06: 
07: public class Example3
08: {
09:  public static void main( String args[] )
10:  {
11:   try
12:   {
13:    // Obtain a new TransformerFactory
14:    TransformerFactory factory;
15:    factory = TransformerFactory.newInstance();
16: 
17:    // Use it to create a new transformer
18:    Templates templates;
19:    Transformer transformer;
20:    InputStream xslInput;
21:    xslInput = new FileInputStream( "demo.xsl" );
22:    Source xslSource = new StreamSource( xslInput );
www.syngress.com
Continued

XML Transformations • Chapter 4
151
23:    templates = factory.newTemplates( xslSource );
24: 
25:    OutputStream resultStream;
26:    resultStream = new FileOutputStream( "result.html" );
27:    Result result = new StreamResult( resultStream );
28: 
29:    InputStream sourceStream;
30:    sourceStream = new FileInputStream( "text.xml" );
31:    Source source = new StreamSource( sourceStream );
32: 
33:    transformer = templates.newTransformer();
34:    transformer.transform( source, result );
35: 
36:   }
37:   catch (TransformerFactoryConﬁgurationError tfce)
38:   {
39:    System.out.println( "Could not obtain factory" );
40:    tfce.printStackTrace();
41:   }
42:   catch (TransformerConﬁgurationException tce)
43:   {
44:    System.out.println( "Could not create transformer" );
45:    tce.printStackTrace();
46:   }
47:   catch (FileNotFoundException fnf)
48:   {
49:    System.out.println( "File not found" );
50:    fnf.printStackTrace();
51:   }
52:   catch (TransformerException te)
53:   {
54:    System.out.println( "Transformer exception" );
55:    te.printStackTrace();
56:   }
57:  }
58: }
www.syngress.com
Figure 4.12 Continued

152
Chapter 4 • XML Transformations
T he main changes to the application from Figure 4.11 are on lines 23, and 33
through 34. O n line 23, I create a Templates object rather than a Transformer
object. O n lines 33 and 34, I use the Templates object to create a Transformer,
and then use the Transformer to perform the transformation. I moved the cre-
ation of the Transformer close to the usage in order to emphasize how you will
generally use Templates: you will create the Template object ﬁrst, then create the
Transformer object on the ﬂy from it as necessary.
Miscellaneous JAXP for XSL Issues
O ur exploration of JAX P is almost complete.T here are only a few things left to
cover, including error handling, resolving U R Is, thread safety, and the plugability
interface.We’ll discuss error handling ﬁrst.
Error Handling
In JAX -P, error handling is carried out by the E rrorL istener and SourceL ocator
classes. E rrorL istener provides a way to output all errors while SourceL ocator is used
to locate errors within an X SL source.
ErrorListener
In JAX -P, error messages are typically reported to System.err, which is ﬁne when
you are working from the command line.W hen you do need to redirect the
error messages to a more agreeable output, you can use E rrorL istener. In order to
use ErrorListener, you need to implement an E rrorL istener object and pass it to
the setE rrorL istener method in Transformer.Table 4.5 displays the methods for
E rrorL istener.
Table 4.5 ErrorListener Methods
Methods
Description
error(TransformerException)
Used to report an error.
fatalError(TransformerException)
Used to report a fatal error.
warning(TransformerException)
Used to report a warning.
If you choose, you can throw the exceptions that are passed in to you— or
any other exception, for that matter. If you do nothing, the X SL engine will con-
tinue to process, with one caveat:T he engine is not required to continue to pro-
cess after fatal errors are reported (even though it may anyway).
www.syngress.com

XML Transformations • Chapter 4
153
SourceLocator
SourceLocators are used in conjunction with the TransformerE xception class.
SourceLocators may be provided by the underlying X SL engine to report the
location of the error— the ﬁle, line, and column number that the X SL engine had
trouble understanding.T hese locations will be approximate— they may be off by a
line or two— but can be very useful in determining how to respond to errors.
You will never create SourceLocator objects yourself (unless you write an
X SL engine). SourceLocators are created for you, and obtained through a
TransformerException.Table 4.6 lists the SourceLocator methods.
Table 4.6 SourceLocator Methods
Methods
Description
getSystemId()
Returns the system ID for the document.
GetPublicId
Gets the public ID for the document.
getColumnNumber()
Returns the ﬁrst character of the area where the error
was found.
GetLineNumber
Returns the line number where the error was found.
URIResolver
U R IR esolver allows developers to create a custom implementation of how U R I
references in X SLT  stylesheets are resolved. U R IR esolver has only one method:
resolve.T he resolve method expects two string items to be passed to it; the ﬁrst one
is href (U R I) and the second one is a base.T he base may sound a bit compli-
cated, but it just refers to the domain (location) that the href (U R I) needs to be
checked against. For example:
<!- - and - ->
<xsl:variable name="item" select="document('test.xml')"/>
T his snippet of X SLT  code basically states that the document is named
test.xml, but doesn’t state how this document should be found. By default, it 
is found relative to the U R I used to locate the original document; so if the orig-
inal document and the included document are not in the same location, problems
can arise.
T he U R IR esolver class is given both the document requested (the href param-
eter) and the current base U R I (the base parameter). It returns a fully-qualiﬁed
www.syngress.com

154
Chapter 4 • XML Transformations
U R I for locating the document.T he following example resolve method resolves
all documents to a directory in the Syngress Web site. N ote that it ignores the
base U R I passed in.
public Source resolve(String href, String base)
{
String URI = "http://www.syngress.com/xsl/" + href;
return new StreamSource( URI );
}
U R IR esolvers can be very useful when the X SL stylesheets for your applica-
tion are stored somewhere other than the default working directory. In this case,
it is not a problem to ﬁnd the main X SL; you just create a F ileInputStream with
the full path name to the X SL ﬁle, and wrap that in a StreamSource. H owever, if
you include other X SLs from that main X SL, you have two options: you can
code the entire path in the xsl:include tag (which severely reduces the portability
of your application), or provide a U R IR esolver.T he U R IR esolver would then add
the path for the X SL directory to the ﬁle name provided, and use that to create a
F ileInputStream (and then a StreamSource).
U R IR esolver has only a single method, resolve(String, String).T his method is
called by the processor when it ﬁnds an xsl:include, xsl:import, or document() func-
tion and deﬁnes how the processor should behave.
Thread Safety
We’ve mentioned thread safety a few times. It is important to understand the
threading limitations of the JAX P interfaces, since understanding what threading
JAX P allows for can make your application more stable and perform better.
T he TransformerFactory class is never thread-safe.You will always have to
synchronize usage of TransformerFactory instances, or create a new instance for
each thread.
Transformer classes are not thread-safe either.You will generally want to
create a separate Transformer instance for each thread— generally through use of a
Templates object.
Templates objects are thread-safe.T he Transformers they create are not, of
course, so you will generally use them to create a new Transformer each time.
www.syngress.com

XML Transformations • Chapter 4
155
Plugability
In general, all you will have to do to use JAX P is make sure a JAX -P-compliant
library is in your classpath. H owever, there are times when you want to change
which X SL engine is used, or ensure that a particular one is used regardless of
classpath order.
In these cases, you can use the plugability features of JAX -P. Plugability allows
you to specify a particular X SL engine to use, and is actually the mechanism used
by X SL libraries to announce themselves to the TransformerF actory class.
T he key to the plugability interface is the system property javax.xml.trans-
form.TransformerF actory.T his shouldn’t be confused with the class of the same
name.T he name of the property was intentionally chosen to be the name of the
class in order to minimize changes of collision with existing properties.
T he property javax.xml.transform.TransformerF actory contains the fully-qualiﬁed
class name of the X SL engine’s implementation of the
javax.xml.transform.TransformerF actory abstract class. If you have a speciﬁc X SL
engine you want to use, you can explicitly set this property (either through a
System.setProperty call, or through the -D command-line option).
If the system property is not set, then the system will look for a ﬁle
jaxp.properties, located in the lib subdirectory of the active JR E home. If this ﬁle
exists, it is expected to be a properties ﬁle containing at least one property: the
javax.xml.transform.TransformerF actory (along with the class name you want associ-
ated with it).
If this ﬁle can’t be found, then the Services API is used to ﬁnd any ﬁles
named javax.xml.transform. TransformerF actory in the services subdirectory under
M ETA-IN F for all jar ﬁles in the class path. (Technically, it’s the effective class
path for the object that is making the call, but that’s beyond the scope of this
book.) If this ﬁle is found, it should again contain a single line: the name of the
fully-qualiﬁed class name for the TransformerF actory implementation.
And should all else fail, there is a platform-dependent default
TranformerFactory class that is used. For the JW SDP EA2 release, this is the
X alan class org.apache.xalan.processor.TransformerF actoryImpl. For other releases, this
default value could change.
www.syngress.com

156
Chapter 4 • XML Transformations
Summary
JAX P has come a long way since its conception as TrAX . M any changes have
been applied and many more are sure to come as more users begin to use JAX P
for their X M L/ X SLT  needs.
W hat Sun is doing now is basically creating an item to ﬁll the void within
the X M L community.W hile there are a number of X SL processors available to
Java programmers, they all come with a proprietary interface, which makes the
code dependent on a speciﬁc library.T his makes it hard to change processors if
the need arises.
JAX P circumvents this problem by providing a standardized interface.T his
interface, while somewhat less powerful than the native X SL library interfaces,
provides the basic functionality needed to transform X M L documents with X SL.
U sing the JAX P interfaces protects your code from future library API changes.
Solutions Fast Track
R eviewing X SL and X SLT  
 X SL is a speciﬁcation made up of three different recommendations:
X SLT, X SL-FO, and X Path.
 X SLT  handles the actual transformation sequence that takes places with
an X SL stylesheet and an X M L ﬁle. X SLT  procedures are also used
within the X SL stylesheet.
 X SL-FO  deals with transformation X M L data to print formats, such 
as PDF.
 X Path is the recommendation that controls how X M L data is located
and queried through X SL/ X SLT.
JAX P and U nderlying X SL Engines
 JAX P is not an X SL/ X SLT  engine. It is actually a layer that allows a
developer to use JAX P regardless of the X SL/ X SLT  engine that lies
beneath.
 C urrent popular X SL/ X SLT  engines include SAX O N  and X alan.
www.syngress.com

XML Transformations • Chapter 4
157
 Since JAX P has to provide a proper layer over all available X SL/ X SLT
engines, it can only support common functionality.
U sing JAX P C lasses
 Basic transformations can be done through Transformers created by a
TransformerF actory.Transformer instances implicitly contain the source
X SL, and receive the Source X M L and a result to output the
transformed ﬁle.

TransformerF actory may cause data corruption in high-load situations due
to its poor threading ability. In these cases, it is best to use Templates,
which creates a copy of the output from TransformerF actory and can be
threaded into separate Transformer instances.
M iscellaneous JAX P for X SL Issues

E rrorL istener can be set to gracefully handle error messages that the
servlet/ java may throw while running the transformation.

SourceL ocator is used to pass the location of the error as part of a
TransformerE xception.

U R IR esolver allows developers to create a custom implementation of
how U R I references in X SLT  stylesheets are resolved.
 M ultithreaded applications should consider using Templates because
Templates are thread-safe.

TransformerF actory packages are currently not developed to be thread-safe,
and should not be used in threading situations.
 Plugability allows you to specify a particular X SL engine to use, and is
actually the mechanism used by X SL libraries to announce themselves to
the TransformerF actory class.
www.syngress.com

158
Chapter 4 • XML Transformations
Q: W hy are some parts of JAX P unable to properly thread?
A: U nfortunately, due to some construct issues when dealing with the plugability
layer, the TransformerFactory packages can’t be made thread-safe. H owever,
both of these items can be properly implemented so they are thread-safe.
TransformerFactory often doesn’t need to be used several times, and can
instead be used in conjunction with a Template, which is thread-safe and can
be used to store the output from TransformerFactory.You would want to then
access Templates to retrieve the information.
Q: W hy does JAX P only provide basic support for the underlying parser?
A: Every parser has its own level of support. By restricting the support to just
the basics, JAX P can ensure developers that an interface that will not only
abide by W 3C speciﬁcations but also be ﬂexible enough to not be locked in a
speciﬁc parser.
Q: W hich is the best default parser for JAX -P?
A: T his question is asked quite a bit and people have always felt the need to pro-
mote their favorite. H owever, JAX P was not created to be a layer that oper-
ates best with a speciﬁc parser but to be the best layer for any parser.T he
easiest way to decide whether you need JAX P is to optimize your machine
for the parser of your choice.
Q: Is JAX P still in beta?
A: N o. H owever, JAX P can be considered a work in progress, even though it is
not still in beta. Issues have been raised regarding how JAX P should behave
and what functionality it should have. Expect more changes throughout the
year as additional user input is generated. (JAX P saw two releases within three
months!) 
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

Using JSTL 
(JSP Standard 
Tag Library)
Solutions in this chapter:
■
Expression Languages
■
Core Tags
■
SQL Query Tags
■
Internationalization Tags
■
XML Support Tags
Chapter 5
159
 Summary
 Solutions Fast Track
 Frequently Asked Questions

160
Chapter 5 • Using JSTL (JSP Standard Tag Library)
Introduction
T he JSP Standard Tag Library (JST L) provides a standard tag library (actually sev-
eral of them) that can be used by JSP writers to handle certain frequent tasks.
T he JST L, like much of the W SDP, comes out of the Apache Jakata project; ear-
lier releases of JST L were available through Apache before it became part of the
JC P (and from there, the W SDP).
JST L is still in its early stages, and is likely to change in the future. If you read
this book and are dealing with a later version of JST L, you may want to check
the Syngress website for the latest information and updates.
In particular, the support of expression languages within JST L is slated to
change. Expression languages give JSP developers a mechanism for embedding
expressions to be evaluated in the place of constants and are scheduled to be
added to the JSP speciﬁcation itself. JST L’s designers have added a temporary
mechanism for using expression languages within JST L, but have also committed
to supporting the JSP standard once it is established.
JST L consists four libraries— and if you get down to it, it’s really eight.T he
four libraries provide X M L support, structured language support, SQ L support,
and internationalization (i18n). Each of these provides a regular and an expression
language version, for a total of eight libraries.
Expression Languages
Before we delve into the tag libraries that comprise the JST L, it behooves us to go
over one of the JST L’s most important new features, Expression Languages (EL).
Since expression language support is pervasive across all of the tag libraries it makes
sense to understand them before proceeding into the tag libraries themselves.
JavaServer Pages (JSP) came into existence to alleviate the problem of cre-
ating Java Servlets that generated more than a small amount of presentation code.
T hose of you who have had to “escape sequence” what seemed like hundreds of
quotation marks in a Java Servlet will know exactly what I mean.W ith JSPs, you
could deﬁne a web page (for example) using what resembles regular H T M L.T he
JSP is then converted to a Java Servlet in Java code and compiled.
It has long been considered a good design practice to separate out the logic
of a presentation into the three components: M odel,View and C ontroller.T his
paradigm, abbreviated as M VC, is the cornerstone of many current-day web
applications.To extend this paradigm into the Java realm, the servlet would act as
the controller, the JSP as the view and the various JavaBeans as the model.
www.syngress.com

www.syngress.com
Why Expression Languages?
N ow that the parts of a presentation have been separated into their respective
model, view and controller components, there remains the issue of communicating
among them.T he issue of communication between the controller/ business logic
and the view, represented as a JSP, is of particular importance.Typically, the division
of reasonability in a web development effort has different teams working on the
controller/ business logic and the views, and there is no guarantee that the view
team is as familiar with programming languages as the business logic development
team. H ow then to facilitate the communication between these components?
In the past there have been two methods used to achieve this communica-
tion: the ﬁrst has been the use of scriptlet code.T his scriptlet code is pure Java
code embedded directly into the JSP ﬁle.W hile serving the purpose of commu-
nication between components, this method  did assume a certain level of knowl-
edge on the syntax and use of the Java language on the developer’s part.T he
second method was the use of a custom tag library.T his custom tag library would
facilitate the communication in the form of tags that resemble H T M L.T his
approach, while cleaner in its implementation, was not standardized; and each
implementation could be vastly different than another.
Expression languages use scoped attributes of JSPs to convey information
from the underlying business logic (such as JavaBeans) to the presentation layer, in
this case JavaServer Pages.T his offers the distinct advantage of being able to access
that business logic from JSPs without having to resort to confusing scriptlet code
or expression statements.
Supported Expression Languages
All indicators point to future versions of the JavaServer Page Speciﬁcation being
standardized on one expression language.W ith this ﬁrst release of the JST L, how-
ever, there is built-in support for a number of expression languages, including
SPEL, EC M AScript, and JX Path.
Simplest Possible Expression Language (SPEL)
T he Simplest Possible Expression Language (SPEL) is just that. It was designed
and developed to serve as an expression language with the minimum number of
features needed to be useful in that capacity. Its biggest appeal is its simplicity,
which makes it easy to learn and to use.
Using JSTL (JSP Standard Tag Library) • Chapter 5
161

162
Chapter 5 • Using JSTL (JSP Standard Tag Library)
A SPEL notation can take the form of a value or an expression.A value is
evaluated literally and an expression is evaluated according to the rules of the
SPEL speciﬁcation.
Each attribute is accessible by a name. Each attribute’s properties are refer-
enced with the “.” operator and may be nested as appropriate.T hese attributes
may also be scoped.T he allowable scope values are:
■
page T his puts or retrieves the attribute from the Page scope and is thus
available during the lifecycle of the currently executing JavaServer Page.
T he Page scope is analogous to calling the PageC ontext.getA ttribute() and
PageC ontext.setA ttribute() methods.
■
request T his puts or retrieves the attribute from the R equest scope and
is thus available during the lifecycle of the current H T T P request, pos-
sibly spanning multiple JavaServer Pages and Servlets.T his R equest
scope is analogous to calling the ServletR equest.getA ttribute() and
ServletR equest.setA ttribute() methods.
■
session T his puts or retrieves the attribute from the Session scope and is
thus available during the current user browser session’s lifecycle.T his
scope is analogous to calling the H ttpSession.getA ttribute() and
H ttpSession.setA ttribute() methods.
■
app T his puts or retrieves the attribute from the A pplication scope and is
thus available during the lifecycle of the application as a whole. Every
session and servlet will have access to these attributes.T his scope is anal-
ogous to calling the ServletC ontext.getA ttribute() and
ServletC ontext.setA ttribute() methods.
■
header T his retrieves the attribute from the header information that is
part of the current H T T P request.T he H eader scope is analogous to
calling the H ttpServletR equest.getH eader() method.
■
param T his retrieves the attribute from the R equest scope as a sub-
mitted parameter of that request.T he Param scope is analogous to calling
the ServletR equest.getParameter() method.
■
paramvalues T his retrieves the attributes from the R equest scope as
submitted parameters of that request.T he ParamValues scope is analogous
to calling the ServletR equest.getParameterValues() method.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
163
If no scope is speciﬁed, the attribute is located according to the rules gov-
erning the search for an attribute as deﬁned by the PageC ontext.ﬁndA ttribute()
method.T his essentially means that the ﬁndA ttribute() method will search for the
named attribute in the following context order: Page, R equest, Session and
A pplication.As soon as it ﬁnds an attribute with the speciﬁed name, the search
stops.T herefore if you have two different attributes with the same name but dif-
ferent contexts, and you attempt to retrieve their values without specifying the
appropriate context, the value of the one that’s stored in the broader scope will
always be used.T he following example will echo out the request parameter
named username with the value that was entered in the submitting form.
<c:out value="${param:username}"/>
N ote the use of the param scope notation to alert the JSP that the username
attribute can be found as a request parameter.T he next example shows how you
can use the app scope to set applicable attributes across the entire web application.
<c:set var="log"
value="${app:conﬁg.logﬁle}"
scope="page"/>
In this case we are pulling an attribute that refers to an instance for logging,
and assigning it to a var visible for the currently executing JSP’s lifecycle.
U sing L iterals
You can use literal values (as opposed to expression values) in your JST L
attributes.Anything in the attribute of a JST L tag that is not encapsulated by the
${… } characters is treated as a literal notation.To use the dollar $ sign as a literal
value you escape it with the backslash “\ ” character.
<c:set var="amount" value="\$1,000,000"/>
EC M AScript
E C M A Script was borne out of the chaos that was (and some would say still is) the
confusion of browser support for JavaScript. EC M AScript is a standardized
scripting language that has its roots in JavaScript version 1.2.T he JW SDP frame-
work supports, and expects, expression languages to be in EC M AScript unless
speciﬁed otherwise.
www.syngress.com

164
Chapter 5 • Using JSTL (JSP Standard Tag Library)
JX Path
JX Path is a powerful and feature-rich scripting technology that provides support
for X Path expressions. It provides graph traversal to retrieve property values by
name or map elements by a key. By specifying an index or search criterion you
can retrieve elements from a collection as well. JX Path also provides support for
logical, arithmetic, character and collection manipulation.
Selecting an Expression Languge
T he choice of an expression language depends on your particular needs. O nce
determined, there are two methods of denoting which expression language to use
when evaluating the attributes of JST L tags.T hese two methods are A pplication-
W ide and C ode Section E xplicit.
Application-W ide
As mentioned earlier the default expression language is EC M AScript.To use an
expression language other than this, you have to set the appropriate context
parameter in your web application’s web.xml deployment descriptor.
T he following example will set up your application to use the JX Path expres-
sion language evaluator.
<context-param>
<param-name>
javax.servlet.jsp.jstl.temp.ExpressionEvaluatorClass
</param-name>
<param-value>
org.apache.taglibs.standard.lang.jxpath.JXPathExressionEvaluator
</param-value>
</context-param>
NOTE
Support for the web.xml deployment descriptor became mandatory with
the Java Servlet Speciﬁcation version 2.2. Web servers that do not sup-
port this version of the speciﬁcation will not be able to execute
JavaServer Pages with tag libraries.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
165
C ode Section Explicit
It is conceivable that you will wish to override the expression language evaluator
for certain parts of your application. JST L does provide a means to accomplish this.
c:expressionL anguage
T he expression language can also be explicitly set at the code level.T his involves
the use of the expressionL anguage action from the core tag Library. If, for example,
you wanted to override the application-wide setting for a particular code block
in order to use JX Path as the expression language you would use the following
notation:
<c:expressionLanguageclass="org.apache.taglibs.standard.lang.jxpath.
JXPathExressionEvaluator">
</c:expressionLanguage>
If SPEL was your expression language choice, you would set it using the fol-
lowing notation:
<c:expressionLanguage class="org.apache.taglibs.standard.lang.spel.
ExpressionEvaluatorClass">
</c:expressionLanguage>
And ﬁnally if EC M AScript was the desired EL then you would set it as 
follows:
<c:expressionLanguage class="org.apache.taglibs.standard.lang.javascript.
JavascriptExpressionEvaluator">
</c:expressionLanguage>
T he expressionL anguage action’s child tags will inherit the evaluator class that
was speciﬁed during the evaluation of any expressions encountered during page
rendering.
NOTE
Be advised that if JSTL does standardize on a single expression language,
support for this action will most likely disappear.
www.syngress.com

166
Chapter 5 • Using JSTL (JSP Standard Tag Library)
Expression Languages and Tag Library Selection
T he JW SDP comes with both the EL support and non-EL support versions of
the four tag libraries.T he non-EL tag libraries will have an “-rt” sufﬁx in the ﬁle-
name.T he EL support tag libraries will have no such sufﬁx.
T he non-EL tag libraries function the same way as you have come to expect
tag libraries to function, according to the JavaServer Page Speciﬁcation version
1.1.T he runtime expressions of the tag attributes are evaluated in the JSP
scripting language.You may elect to use the non-EL tag libraries should the
expression language support not contain the necessary functionality you need to
implement your application.
If you do choose to use the EL support tag libraries you will not be allowed
to use the JSP scripting language to derive attribute values.
Future Compatibility with Expression Languages
As mentioned earlier, the speciﬁcations that make up the JW SDP are still in a
state of ﬂux.As a result, the support for expression languages will no doubt
undergo modiﬁcations. H owever, there have been assurances from the group
responsible for the JW SDP that future versions will be backwards compatible.
www.syngress.com
Conﬁguring Your Web Application to use the JSTL
JSTL comes as a optional tool for the JWSDP. The class packages and sup-
porting TLD ﬁles are located at <JWSDP_HOME>/tools/jstl. To use some
or all of the tag libraries deﬁned there you must do three things: First
you must copy the two JAR ﬁles, jstl.jar and standard.jar, to your web
application’s /WEB-INF/lib directory. Second, you must copy the TLD ﬁles
for the tag libraries you wish to use to the /WEB-INF directory. Last, you
must add a reference to each of the TLD ﬁles copied to your web.xml
deployment descriptor as separate <taglib> elements.
Developing & Deploying…

Using JSTL (JSP Standard Tag Library) • Chapter 5
167
Core Tags
N ow that we have an understanding of the syntax and use of expression lan-
guages we can go over the meat of the JST L, the tag libraries themselves.
T he core tag library of JST L represents the basic functionality used in the
development of JavaServer pages.T his basic functionality can be broken down
into three groups: expression language, ﬂow control, and importing.
NOTE
The subsequent sections in this chapter provide examples of the actions
available from the four tag libraries that comprise the JSTL. We show
these examples using the standard naming conventions as used in the
speciﬁcation itself. As a result the core tag library is assigned a c: preﬁx ,
the SQL tag library is assigned an sql: preﬁx of, the internationalization
tag library is assigned an fmt: preﬁx and ﬁnally the XML tag library is
assigned an x: preﬁx of. Using these preﬁxes keeps the examples in this
chapter consistent with the speciﬁcation.
Expression Language
T he JST L core tag library offers support for the evaluation and manipulation of
expressions.T he validation of expressions is governed by the rules mandated by
the expression evaluator speciﬁed in either the deployment descriptor or explic-
itly within the JSP using the expressionL anguage action.
T he values of the attributes in the expression can be retrieved from any of a
web application’s associated valid scopes. Scoped attributes can be set in the
web.xml deployment descriptor and retrieved using the app scope notation.T hey
can be set in a request as form parameters. If you use JavaBeans in your JSP ﬁles
then you can reference the properties of those beans using expression language.
In a nutshell, the expression language is used to retrieve and set an applica-
tion’s attributes using a simple notation to denote the name and scope of the
desired attribute.T his removes the necessity of putting scriptlet code that might
be confusing to follow into your JSP.An example of this would be to access the
properties of a bean. C onsider a JavaBean with the following semantics:
import java.beans.*;
www.syngress.com

168
Chapter 5 • Using JSTL (JSP Standard Tag Library)
public class Person extends java.lang.Object
implements java.io.Serializable
{
private String fn;
private String ln;
private String mi;
public String getFN()
{
return this.fn;
}
public void setFN( String value )
{
this.fn = value;
}
public String getLN()
{
return this.ln;
}
public void setLN( String value )
{
this.ln = value;
}
public String getMI()
{
return this.mi;
}
public void setMI( String value )
{
this.mi = value;
}
}
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
169
U sing the traditional JSP scripting language to access these bean properties, a
JSP page that uses this bean might look like the following example:
<%@ page contentType="text/html" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<html>
<head><title>Show Person</title></head>
<body>
<jsp:useBean id="person" class="Person" scope="session"/>
Welcome <%= person.getFN(); %> 
</body>
</html>
W ith the introduction of expression languages, the effort to access and use
attributes such as the JavaBean to which we have been referring, become much
simpler to develop and follow.
<%@ page contentType="text/html" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<html>
<head><title>Show Person</title></head>
<body>
<jsp:useBean id="person" class="Person" scope="session"/>
Welcome <c:out value="${session:person.fn}"/> 
</body>
</html>
Expression languages have provided a means of deﬁning the values of tag
attributes as scoped JSP attributes, greatly simplifying the notation.
c:out
T he out action takes the expression speciﬁed in its value attribute and evaluates it.
T he result of the evaluation is sent to the JspW riter object of the currently exe-
cuting JSP.
www.syngress.com

170
Chapter 5 • Using JSTL (JSP Standard Tag Library)
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<html>
<head>
<title>c:out</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>c:out (cont)</h2>
<p>The following parameters were retrieved from PARAM scoped attributes
via the <span class="code">c:out</span> tag.</p>
<ul>
<li>street = <c:out value="${param:street}"/></li>
<li>city = <c:out value="${param:city}"/></li>
<li>zipCode = <c:out value="${param:zipCode}"/></li>
</ul>
</body>
</html>
c:set
T he set action sets the value of an attribute.T he name of the attribute is denoted
by the id attribute.T he optional scope attribute is used to set the scope visibility of
the attribute.To specify the value of the attribute you can either use the value
attribute or the body of the set action.
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<html>
<head>
<title>c:set example</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
171
<h2>c:set</h2>
<p></p>
<hr/>
<c:set var="requri" scope="page">
<%= request.getRequestURI() %>
</c:set>
<h3>The RequestURI was parsed from the request object and set to the var 
"requri". The value found is "<c:out value="${requri}"/>".
</body>
</html>
Iterations
T he capability to loop or iterate through a collection of object is offered by
Iterations. JST L’s core tag library provides two actions to support such iterations:
forE ach and forTokens.
c:forE ach
T he forE ach action allows a developer to iterate over a collection of objects
within the JSP.T he items attribute (which refers to the collection to iterate over),
can be one of the following data types.
■
Arrays of either primitive or object types. Primitive arrays are automati-
cally converted into their respective wrapper class instances.
■
An instance of a class that is deﬁned as implementing one of the fol-
lowing interfaces: java.util.C ollection, java.util.Iterator, java.util.E numeration
or java.util.M ap.
■
A java.lang.String instance containing comma delimited ﬁelds.
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ page import="CompanyBean" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<html>
<head>
<title>c:forEach example</title>
www.syngress.com

172
Chapter 5 • Using JSTL (JSP Standard Tag Library)
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>c:forEach</h2>
<p></p>
<hr/>
<jsp:useBean id="company" class="CompanyBean" scope="page"/>
<c:set var="departments" value="${page:company.departments}"/>
<table>
<tr><th>Department</th></tr>
<c:forEach var="dept" items="${departments}">
<tr><td><c:out value="${dept}"/></td><?tr>
</c:forEach>
</table>
</body>
</html>
c:forTokens
T he forTokens action allows a developer to iterate over a set of tokens using a
speciﬁed delimiter.T he difference between this action and the forE ach action is
that the forTokens action will allow you to deﬁne a delimited collection using one
or more delimiters of your choice.
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ page import="CompanyBean" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<html>
<head>
<title>c:forTokens example</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>c:forTokens</h2>
<p></p>
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
173
<hr/>
<c:set var="tokens" value="Welcome,About Us,Services,Opportunities"/>
<h3>Menu Items</h3>
<ol>
<c:forTokens items="${tokens}" delims="," var="menuItem">
<li><c:out value="${menuItem}"/>
</c:forTokens>
</ol>
</body>
</html>
Conditional Expressions
C onditional expressions are a means to conditionally execute blocks of code
depending upon the result of an expression evaluation. JST L’s core tag libraries
contains two sets of conditional expressions: if and choose/ when/ otherwise.
c:if
T he if action provides conditional execution support within the JSP.T he body of
the <if> tag is evaluated if the condition denoted by the test attribute evaluates to
true.
<c:if test="${session:sessionData.loggedIn == true}">
<%-- Perform some conditional action --%>
</c:if>
c:choose
T he choose action encapsulates a series of nested when actions.T he choose action is
therefore analogous to the switch statement in Java.
c:when
T he when action is a child tag of a choose action. Each when action has a test
attribute that when evaluated as true executes its body.
www.syngress.com

174
Chapter 5 • Using JSTL (JSP Standard Tag Library)
c:otherwise
T he otherwise action is the last child element of a choose action.T his action only
executes its body content if all proceeding when actions evaluated as false.
T he following is an example of how to use these tags to personalize an order
processing JSP according to the customer’s age.
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<html>
<body>
<h2>Order Status</h2>
<c:choose>
<c:when test="${session:personBean.age < 18}">
You must get parental permission to complete the purchase process.
</c:when>
<c:when test="${session:personBean.age > 65}">
You are entitled to a senior discount on your purchase.
<c:otherwise>
Thank you for your order. Please shop with us again.
</c:otherwise>
</c:choose>
</body>
</html>
Importing External Resources
JST L’s core tag library extends the inherent capability of the JSP to incorporate
external resources into the currently executing JSP.
c:import
T he import action is used to combine the output from an external resource into
the currently executing JSP.T his resource can be accessible from either a relative
or an absolute U R L.T he contents of this external resource can be stored in a
variable denoted by a var attribute, a reader object denoted by a varR eader
attribute, or simply to the page itself.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
175
T he key difference between this JST L action and the standard JSP script
action jsp:include is that the latter can’t reference a U R L that is external to the
currently executing web application. U se of JST L’s import action also does not
involve the buffering inherent in the traditional jsp:import action.
T he following is an example of using the JST L import action.
<table>
<tr><th>Your Weather</th></tr>
<tr><td>
<c:import url="/portlet-weather.jsp" >
<c:param name="zipcode" value="${session:person.zipCode}/>
</c:import>
</td></tr>
</table>
c:param
T he param action works as a nested tag of the import action.T hese nested param
actions allow you to set additional parameters to which the external resource can
have access. Each param action will add one more parameter to the U R L of the
request, in the same manner as the get request.T he following example shows how
this param action could be used:
<c:import url="/orderform.jsp>
<c:param name="shippingZipCode" 
value="34050-1010"/>
</c:import>
In this example, the invoked U R L would be modiﬁed from / orderform.jsp to
/ orderform.jsp?shippingZ ipC ode=34050-1010.
URL Manipulation
JST L offers the ability to encode a string to be used as a U R L.
c:urlE ncode
T he urlE ncode action takes a value as represented by its value attribute and
encodes it as x-www-form-urlencoded.T he following is an example of the usage
of this action:
www.syngress.com

176
Chapter 5 • Using JSTL (JSP Standard Tag Library)
<a href="<c:urlEncode value="http:/myserver.com/servlet1?name=
John Doe&address=123 Main Street, Suite 17"/>">Add User</a>
W hen executed, the resultant H T M L will contain an anchor tag (<a>) that
looks like the following:
<a href="http:/myserver.com/servlet1?name=John Doe&address=
123%20Main Street,%20Suite%2017">Add User</a>
T his is useful when programmatically constructing a U R L for constructs
requiring one, for example an anchor tag.
c:redirect
T he redirect action sends an H T T P redirect command to the client.As with the
import action, you may specify optional param actions to add embedded parame-
ters to the U R L.T his action’s behavior is analogous to the
H ttpServletR esponse.sendR edirect() method.
SQL Query Tags
JST L provides support for simplistic database interaction from within a JSP using
the SQ L Tag Library package. Support for SQ L commands in JST L was not
intended to replace the proper placement of database interactions in business
objects like JavaBeans and Enterprise JavaBeans. R ather the SQ L Tag Library was
provided to allow for quick prototyping of database-enabled applications. If the
business application is simple enough these SQ L actions may sufﬁce. It is up to
the developer’s discretion to decide if this approach is prudent. R ecklessly
inserting database interaction logic into a JSP tends to complicate the JSP and
make it harder to follow.T he addition of SQ L statements in the JSP also tends to
deviate from the desired M VC  architecture in web application design.
Setting up a Driver
JST L allows the driver being used for SQ L database interaction to be deﬁned in a
couple different ways.T he data source to be used can also be speciﬁed in the
web.xml deployment descriptor in a resource-ref element, as shown in the following
example:
<resource-ref>
<res-ref-name>jdbc/LibraryDB</res-ref-name>
<res-type>javax.sql.DataSource</res-type>
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
177
<res-auth>Container</res-auth>
</resource-ref>
Your application code will then take this data source and place it in the
javax.servlet.jsp.jstl.sql.dataSource scoped attribute.
sql:driver
T he driver action is provided to set up a data source from with the JSP. It is
important to note here that this scheme should only be used for prototyping;
there are more appropriate places to establish a data source, such as creating a data
source from within servlet initialization and placing the data source with the
application context for multiple sources to use.
NOTE
It is not recommended to use the <driver> tag in a production 
environment.
Executing Queries
JST L provides functionality to query a database and return the results.T his is pri-
marily used with simple query statements like the SE L E C T command. R esults
from the query are returned via an instance of the javax.servlet.jsp.jstl.sql.R esult
interface.
sql:query
T he query action executes an SQ L query statement as speciﬁed in the sql attribute
or in the body of the query action itself.
sql:param
T he param action supplies parameters to be used in an enclosing query action.
<sql:query var="results" dataSource="${app:pool.dataSource}">
SELECT * FROM EMPLOYEES WHERE SSN = ?
<sql:param value="${param:ssn}" />
</sql:query>
www.syngress.com

178
Chapter 5 • Using JSTL (JSP Standard Tag Library)
T he result set from a query can be stored within a JSP scoped variable as
speciﬁed in the query action’s var attribute. In the above example the results from
the query against the EM PLOY EE table will be stored in theresults instance.T he
R esult class has a getR ows method, which will return a R ow array . Each R ow
instance has a getC olumns method that returns a C olumn array.T he actual value of
that C olumn instance can be acquired using the getValue method.
U sing the SPEL as our expression language evaluator we can create queries
and display the results in a JSP:
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<%@ taglib uri="/jstl-sql" preﬁx="sql" %>
<html>
<head>
<title>c:query example</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>c:query</h2>
<p></p>
<hr/>
<sql:driver var="ds" 
driver="sun.jdbc.odbc.JdbcOdbcDriver" 
url="//localhost/db">
<sql:query datasource="ds" var="result">
SELECT * FROM EMPOYEES
</sql:query>
</sql:driver>
<h3>Employee List</h3>
<table>
<c:forEach var="employee" items="${result.rows}">
<tr><td><c:out value="${employee.lastName}"/>,
<c:out value="${employee.ﬁrstName}"/></td></tr>
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
179
</c:forEach>
</table>
</body>
</html>
In this example, the JSP ﬁrst establishes a JDBC  driver using the driver action.
A nested query action performs the SE L E C T query as speciﬁed, storing the
results in a result instance held in the var named result.T he next group of tags
takes that result collection and iterates through it to create a table with each row
containing one row of the result.
Executing Updates
T he JST L provides the functionality to update databases.T his is primarily for use
with simple update statements like the U P D A T E command, although any SQ L
command that does not return results can be used in this action.
sql:update
T he update action essentially allows you to execute an SQ L command that returns
no data.T he most common SQ L commands used in this context are IN SE RT,
U P D A T E and D E L E T E .As it is with the query action the update action can also
contain nested param actions that affect the behavior of the SQ L command.
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<%@ taglib uri="/jstl-sql" preﬁx="sql" %>
<html>
<head>
<title>sql:update example</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>sql:update</h2>
<p></p>
<hr/>
<c:set var="tableName" value="$param:tableName"/>
www.syngress.com

180
Chapter 5 • Using JSTL (JSP Standard Tag Library)
<sql:driver var="ds" 
driver="sun.jdbc.odbc.JdbcOdbcDriver" 
url="//localhost/db">
<sql:update datasource="ds">
DROP <c:out value="$tableName"/>
</sql:update>
</sql:driver>
Table <c:out value="$tableName"/> has been dropped.
</body>
</html>
In the preceding example the JSP reads the tableN ame attribute, which exists
as a request parameter, submitted in the current request. O nce the attribute has
been retrieved, the driver action creates a data source. N ested within this action is
the update action that executes the D RO P command, effectively erasing the table
from the database. U pon successful completion of the table drop the user is pre-
sented with a message stating that the operation was successful.
Denoting Transactional Boundaries
It is often desirable to execute several database functions within the context of a
single transaction.An example of this would be a bank funds transfer: an amount
would be withdrawn from one account in the ﬁrst database function, and the
same amount would be added to another account in a second database function.
T he success of both functions is critical if the transfer is to be completed success-
fully. If the amount was withdrawn from the ﬁrst account but an exception
occurred while depositing that amount into the recipient account, then the
transfer should fail and the amount be credited back to the ﬁrst account.
sql:transaction
T he transaction action is used to nest database actions within the boundaries of a
single transaction.
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<%@ taglib uri="/jstl-sql" preﬁx="sql" %>
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
181
<html>
<head>
<title>c:transaction example</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>c: transaction</h2>
<p></p>
<hr/>
<c:set var="checkAmount" value="${param:checkAmount}"/>
<c:set var="fromAccount" value="${param:fromAccount}"/>
<c:set var="toAccount" value="${param:toAccount}"/>
<sql:driver var="ds" 
driver="sun.jdbc.odbc.JdbcOdbcDriver" 
url="//localhost/db">
<sql:transaction datasource="ds">
<sql:update datasource="ds">
UPDATE bankAccounts SET currentBalance = currentBalance - ?
WHERE account = ?
<sql:param value="${checkAmount}"/>
<sql:param value="${fromAccount}"/>
</sql:update>
<sql:update datasource="ds">
UPDATE bankAccounts SET currentBalance = currentBalance + ?
WHERE account = ?
<sql:param value="${checkAmount}"/>
<sql:param value="${toAccount}"/>
</sql:update>
</sql:transaction>
</sql:driver>
Transaction Completed
</body>
</html>
www.syngress.com

182
Chapter 5 • Using JSTL (JSP Standard Tag Library)
T he preceding example illustrates how a transaction action can group related
and interdependent SQ L commands so that the sequence of commands is treated
as one event. In this example (a variant of the previous banking example), we
have a JSP that receives a request from some other source.T his request contains
three parameters of interest: the number of the checking account withdrawing
the amount, the number of the checking account depositing the amount, and the
amount of the transaction itself. O nce this data has been retrieved the driver
action establishes a data source, presumably the database holding the account
information.An encapsulating transaction action is used to hold the two
U P D A T E commands that remove the amount from one checking account and
deposit it into the other account. Failure of either U P D A T E will result in a roll-
back of the entire transaction.
Internationalization Tags
W hen web-based application development was in its infancy (circa 1995) devel-
opers did not have to concern themselves with support for multiple languages
and locales.Typically the scope and reach of an application was limited to a cer-
tain group communicating in a common language.T his is no longer the case;
nowadays these same developers must be cognizant of the implications of
deploying an internationalized application that is capable of supporting multiple
languages and locales. O ne approach is to port an application developed in one
language such that multiple copies of the application exist, each catering to the
speciﬁc needs of a particular language or area. N eedless to say, this approach is
extremely costly, both in terms of development and maintenance.
NOTE
The process of enabling an application to work with multiple locales is
known as Internationalization (I18N). When you insert the various for-
matting actions into the JSP ﬁles you are performing I18N. The process
of actually creating the content speciﬁc to each locale is known as
Localization (L10N). When you create a resource bundle you are per-
forming L10N.
Fortunately the JST L provides a mechanism to support multiple languages
and locales from within the same code base.T his mechanism allows the developer
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
183
to remove all textual messages, formatting, and layout instructions and place them
into a resource bundle.T he resource bundle is where the developer places custom
tags designed to specify a locale and to retrieve certain information or perform
certain tasks based on the value of the locale that was either received from the
client’s browser or calculated internally in the web application itself.
Deﬁning the Locale
T here are two methods by which a locale can be speciﬁed:T he ﬁrst is by the
client’s browser, and the second is by the web application itself.T he ﬁrst method
is more common as the support for specifying a desired language is built into the
browser software and frees the developer from the burden of implementing lan-
guage preference functionality.T he second method is used less frequently; some
web applications will let a user select a language, typically from a list of languages
that have been implemented in the form of resource bundles, and store the selec-
tion.T his storage is either session-based or persisted to a datastore.
Browser Speciﬁed
Web browsers allow the user to compile a list of their preferred languages and
store that information locally on the user’s computer.W hen the browser makes
an H T T P request, it passes the preferred language settings within the headers of
that request to the web server. During the course of execution, JSP ﬁles that
invoke any of the custom tag actions from the fmt.tld tag library descriptor will
use a locale derived from that header information as the basis for the resource
bundle lookup.
Figure 5.1 is a screen capture of the language selection dialog from Internet
Explorer.
www.syngress.com
Figure 5.1 Browser Language Selection

184
Chapter 5 • Using JSTL (JSP Standard Tag Library)
You may enter multiple languages in this dialog and arrange them into the
order of precedence that you wish.
JSP Speciﬁed
T he JSP ﬁles do have the capability to explicitly set the locale to use when
looking up internationalized messages.
fmt:locale
T his locale action sets the locale to use when attempting to discover the best
resource bundle match or when using the various formatX X X X or parseX X X X
actions as discussed later.
<fmt:locale value="de-DE" variant="EURO"/>
In this example we are setting the locale of the currently executing JSP to the
German language with a variant of EU R O.
Deﬁning the Timezone
T he JST L uses the javax.servlet.jsp.jstl.i18n.timeZ one scoped JSP attribute to
denote the time zone with which to format data representing a date and time.
T his attribute can be set either by the application (using a formula), through 
user selection, or it can be explicitly stated within the JSP itself using the
<timeZ one> tag.
fmt:timeZ one
To explicitly set the time zone from within the JSP you would use the timeZ one
action as seen in the following example.T his example would set the time zone to
Eastern Standard T ime.
<fmt:timeZone value="GMT-5:00"> 
... other date and time formatting tags ... 
</fmt:timeZone>
If you set the time zone by this method, there are several different types of
values you could use in the value parameter.T hese value types are:
■
Abbreviation As shown in the example above, you could use the stan-
dard abbreviation for the time zone. Examples include PST, M DT  and
EDT.T he ofﬁcial Java documentation discourages the use of such abbre-
viations in lieu of the F ull N ame.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
185
■
Full Name T his is the full name of the time zone.
■
Custom You can specify a custom time zone by denoting the delta
from GM T. Examples of this include GM T-5:00, GM T +2:00, etc.
If you are interested in seeing all of the T ime Zones that are deﬁned in Java
you can run the following program:
import java.util.*;
public class ListTimeZones extends java.lang.Object
{
public static void main( String[] args )
{
String[] ids = TimeZone.getAvailableIDs();
for( int i = 0; i < ids.length; i++ )
{
String id = ids[i];
System.out.print( "id="+id );
TimeZone tz = TimeZone.getTimeZone( id );
System.out.println( ", timezone="+
tz.getDisplayName() );
}
}
}
Specifying a Resource Bundle
T here are two ways to set the base name of the resource bundle you wish to use
when localizing messages, dates and times.T he ﬁrst way is to set it at the applica-
tion level through a context parameter in the web.xml deployment descriptor.
<context-param>
<param-name>
javax.servlet.jsp.jstl.i18n.basename
</param-name>
<param-value>
i18n.Messages
</param-value>
</context-param>
T he other way is to use the <bundle> tag from the core library.
www.syngress.com

186
Chapter 5 • Using JSTL (JSP Standard Tag Library)
fmt:bundle
T he bundle action allows you to explicitly load a particular resource bundle.T his
bundle is then valid for the remaining parts (after the bundle action) of the cur-
rently executing JSP.
<fmt:bundle basename="Application"/>
Locating the Resource Bundle
A resource bundle contains thelocalization information that deﬁnes the speciﬁc
messages and the formatting of those messages, based upon a speciﬁc locale.
W hen an application is asked to display internationalized information it must ﬁrst
locate the resource bundle in which that information is contained.
A resource bundle may take the form of a class ﬁle or a properties ﬁle.T he
names of these ﬁles must follow a deﬁned pattern if the application is to ﬁnd the
correct one.T here are four parts to a resource bundle’s ﬁlename.T hese parts are:
■
Base Name An arbitrary identiﬁer selected bythe web application’s
developer, and which is commonly used to communicate the contents
or consumer of the resource bundle. Examples of this are E rrorM essages
or O rderP rocessing.
■
Language A twolower-case letter language code.T his code must be
ISO -639-compliant.
■
Country A two upper-case letter code that denotes the country.T his
code must be ISO -3166-compliant.
■
Variant T his code consists of one or more underscore-separated tokens
that are speciﬁc to a particular vendor or browser.
W hen put all four parts together, the resource bundle ﬁlename will look like:
<<basename>>_<<languageCode>>_<<countryCode>>_<<variant>>
A search for a resource bundle always starts with the base name.T he search
mechanism will take the list of desired locales (as supplied by the client’s browser)
or the explicitly deﬁned locale (as set programmatically by the application) and
search for the best possible match against all available resource bundles.T he best
possible match refers to how closely the available resource bundles’ ﬁlenames pair
up with the desired resource bundle ﬁle name as calculated from the base name
and the speciﬁed locale.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
187
As deﬁned by the speciﬁcation, the JVM  will search for a resource bundle by
looking for names in the following order.W hen a match is found the search stops.
■
basename+“_”+languageC ode+“_”+countryC ode+“_”+variant
■
basename+“_”+languageC ode+“_”+countryC ode+“_”+variant+
“.properties”
■
basename+“_”+languageC ode+“_”+countryC ode
■
basename+“_”+languageC ode+“_”+countryC ode+“.properties”
■
basename+“_”+languageC ode
■
basename+“_”+languageC ode +“.properties”
As the list suggests, R esourceB undles will take precedence over
P ropertyR esourceB undles of the same name.An example of a resource bundle 
created to hold localized messages for Germany might look like so:
ElectronicsSales_de_DE_EURO
In this example, the E lectronicSales is the base name.All resource bundles will
start with this name.T he lowercase de is the language identiﬁer for German.T he
uppercase D E is the country identiﬁer for Germany.T he variant in this case is
denoted by E U RO .
Using Internationalized Messages
T he use of internationalized messages within a web application is realized by 
the two sets of tags provided by JST L for that purpose.T hese two sets are
<M essaging> and <F ormatting>.T hese tags are deﬁned within the fmt.tld tag
library descriptor (with EL support) and the fmt-rt.tld tag library descriptor (with
no EL support).
O btaining Simple Internationalized M essages
O nce a resource bundle has been created and placed where the web application
can locate it in the C LASSPAT H , it is a simple matter to access the international-
ized messages contained therein.
www.syngress.com

188
Chapter 5 • Using JSTL (JSP Standard Tag Library)
fmt:message
T he message action is the easiest means with which you can access international-
ized messages.T he following code shows how you will use this page directive to
enable the use of the I18N  tags.
<%@ taglib uri="/jstl-fmt preﬁx="fmt" %>
As mentioned earlier, internationalized messages are stored in resource bun-
dles. Before initiating lookups of internationalized messages you must specify
which resource bundle contains the messages you want. If you did not specify a
basename as a context parameter in your web.xml deployment descriptor you
must include a reference to the desired bundle within the JSP itself using the
fmt:bundle …
action.
N ow, somewhere else in your JSP you will want to place the actual 
<message> tag with a speciﬁed key to substitute with the internationalized 
message. U sing this key, the <message> tag will lookup the following:
<span class="page.message">
<fmt:message key="greeting"/>
</span>
Performing Parameter Substitution
T here are instances where simple message replacement will not sufﬁce. C onsider
the problem of rendering complete phrases or sentences containing proper
names.T hese proper names appear in vastly different positions depending on the
locale in which the sentence is being rendered.T he JST L provides a means with
which to perform this. It is called parameter substitution, and is accomplished
using the <messageF ormat> tag with one or more child <messageA rg> tags.
fmt:messageF ormat
T he messageF ormat action provides the web application developer with a means of
deﬁning how a message is formatted when key elements of the message are
arranged differently, depending upon the locale in which the message is rendered.
T his action takes parameters which it them substitutes within a pattern string.
T his pattern string is obtained from the value attribute of the action or, if missing,
from the body of the action itself.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
189
fmt:messageA rg
T he messageA rg action is used to specify the argument of a parent message or
messageF ormat action. For each variable in the parent action there must be a cor-
responding messageA rg action. Substitution occurs in the order that the messageA rg
actions are speciﬁed.
An example of how all this works together might look as follows.Assuming
that you have a R esource Bundle named M essages that had an entry of:
welcome=Welcome {0} {1} from {2} to our corporate web site.
You could use the following JSP to display a custom welcome message using
data submitted with the request:
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ taglib uri="/jstl-fmt" preﬁx="fmt" %>
<html>
<head>
<title>fmt:message</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>fmt:message</h2>
<h2>fmt:messageArg</h2>
<fmt:bundle basename="Messages" var="i18n"/>
<fmt:message key="welcome" bundle="${i18n}">
<fmt:messageArg value="${param:fn}"/>
<fmt:messageArg value="${param:ln}"/>
<fmt:messageArg value="${param:state}"/>
</fmt:message>
</body>
</html>
In this example we wish to welcome a person to a web site with a cus-
tomized greeting.T he bundle action sets the basename of the resource bundle we
use to lookup localized messages.T he subsequent message action retrieves the
www.syngress.com

190
Chapter 5 • Using JSTL (JSP Standard Tag Library)
desired localized message, passing substitution variables in the form of nested
messageA rg actions.
Exception Localization
T he custom exception classes that derive from the java.lang.E xception class come
with built-in support for the localization of exception messages.T he localization
of exceptions is accomplished by overriding the getL ocalizedM essage method of
the java.lang.T hrowable class.T he default behavior of this method is to call the
getM essage method of the same class. So out of the box the two methods return
the same result.T he getL ocalizedM essage method can be overridden in your
custom exception class to perform a lookup against a resource bundle:
import java.util.ResourceBundle;
import java.util.MissingResourceException;
public class LocalizedException extends java.lang.Exception
{
private String messageKey;
/**
* Constructor
* Creates a new <code>LocalizedException</code>
* without a detail message.
* @param msg The detailed message for this exception.
*/
public LocalizedException( String key )
{
super();
this.messageKey = key;
}
/**
* Overrides the getLocalizedMessage of the parent
* java.lang.Throwable class.
*/
public String getLocalizedMessage()
{
try
{
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
191
ResourceBundle rb = ResourceBundle.getBundle(
"i18n.ErrorMessages" );
String message = rb.getString( messageKey );
return message;
}
catch( MissingResourceException mre )
{
mre.printStackTrace();
return this.messageKey;
}
}
}
In the example, the constructor of this exception takes a single String argu-
ment.T his String argument represents the key to use when performing a lookup
against a resource bundle.T he constructor takes this key, performs the lookup and
stores, in a private member variable, the internationalized message to associate
with this instance.
W hen an E xception class is designed in this manner and used in conjunction
with a JSP Error page it becomes possible to display an internationalized error
message, generated by the exception and stored within a resource bundle.
<%@ page contentType="text/html" %>
<%@ page isErrorPage="true" %>
<html>
<head><title>Error Page</title></head>
<body>
<span class="error.message">
<% exception.getLocalizedMessage() %>
</span>
</body>
</html>
H ere we have set up a JSP to serve as an error page using the isE rrorPage
directive. U sing this directive affords us access to the exception implicit object
within the JSP. In this example we call the getL ocalizedM essage method on that
exception instance to return a localized error message.
www.syngress.com

192
Chapter 5 • Using JSTL (JSP Standard Tag Library)
R emember that the default behavior of the getL ocalizedM essage method is to
return the same value as getM essage, so if this error page gets called with an excep-
tion that is not an instance of our L ocalizedE xception class (or a derived class
thereof) then the usual message will appear in place of of an internationalized one.
fmt:exception
T he JST L provides additional support for the localization of exception messages.
T he exception action is designed to display an exception in a localized form as
denoted by its value attribute.
<fmt:exception value="{request:exception}"/>
Even if value attribute is missing, the exception action can still be used in a JSP
that has been slated as an error page by using the isE rrorPage directive. U nder
these circumstances the exception action will display the localized value of the
implicit exception variable.
<%@ page contentType="text/html" %>
<%@ page isErrorPage="true" %>
<%@ taglib uri="/jstl-fmt" preﬁx="fmt" %>
<html>
<head><title>Error</title></head>
<body>
<h2 class="errorTitle">An error has occured</h2>
<h3 class="errorMessage"><fmt:exception/></h3>
</body>
</html>
Parsing and Formatting
T he JST L provides actions that parse data and format strings.T hese actions
include formatN umber, parseN umber, formatD ate and parseD ate.W ith these actions
you can localize numerical values such as currencies and date-time notations.
fmt:formatN umber
T he formatN umber action is used to localize the formatting of numbers.
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ page import="CompanyBean" %>
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
193
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<%@ taglib uri="/jstl-fmt" preﬁx="fmt" %>
<html>
<head>
<title>c:formatNumber example</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>c:formatNumber</h2>
<p></p>
<hr/>
<c:set var="number" value="1250000.50"/>
Examples of the <span class="code">>c:formatNumber</span> action used 
on the numerical value of <c:out value="${number}"/>
<table>
<tr>
<th>Locale</th>
<th>Formatted Number</th>
</tr>
<tr>
<td>en_US</td>
<td><fmt:formatNumber value="${number}" 
type="currency" 
parseLocale="en_US"/>
</td>
</tr>
<tr>
<td>de_DE</td>
<td><fmt:formatNumber value="${number}" 
type="currency" 
parseLocale="de_DE"/></td>
</tr>
<tr>
<td>es_MX</td>
www.syngress.com

194
Chapter 5 • Using JSTL (JSP Standard Tag Library)
<td><fmt:formatNumber value="${number}" 
type="currency" 
parseLocale="es_MX"/></td>
</tr>
<tr>
<td>ja</td>
<td><fmt:formatNumber value="${number}" 
type="currency" 
parseLocale="ja"/></td>
</tr>
</table>
</body>
</html>
Allowable values for the type attribute are number, currency and percentage.
fmt:parseN umber
T he parseN umber action takes a string value from the value attribute and parses it
as a number, currency or a percentage, however denoted in the type attribute.
<fmt:parseNumber value="100.00" type="currency" var="cost" scope="page"/>
fmt:formatD ate
T he formatD ate action formats a date (or time).T he style and pattern attributes
dictate the ﬁnal format of the date (or time).
<%@ page contentType="text/html" %>
<%@ page errorPage="error.jsp" %>
<%@ page import="CompanyBean" %>
<%@ taglib uri="/jstl-c" preﬁx="c" %>
<%@ taglib uri="/jstl-fmt" preﬁx="fmt" %>
<html>
<head>
<title>c:formatDate example</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css">
</head>
<body>
<h2>c:formatDate</h2>
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
195
<p></p>
<hr/>
Current Date/Time in Helsinki:<p>
<fmt:timeZone value="Europe/Helsinki">
<fmt:formatDate timeStyle="long" dateStyle="long"/>
</fmt:timeZone>
</body>
</html>
fmt:parseD ate
T he parseD ate action performs in a similar fashion to the parseN umber action in
that it takes a string and parses it for a D ate object.
XML Support Tags
X M L support tags provide a means to easily access and manipulate the contents
of an X M L document. JST L X M L tags use X Path expressions to perform their
functions.
Parsing and Searching
JST L provides actions that allow you to parse X M L documents and perform a
search for data meeting speciﬁed criteria.T hese actions include parseand expr.
x:parse
T he parse action retrieves the content from an X M L document.T his X M L docu-
ment can be speciﬁed by either the source attribute or from the body of the
<parse> tag itself.A var attribute speciﬁes the JSP scoped attribute in which to
save the result.
<x:parse var="library">
<library>
<book checkedout="true">
<title>Book Title 1</title>
<isbn>0130894680</isbn>
<type>Fiction</type>
</book>
<book checkedout="false">
www.syngress.com

196
Chapter 5 • Using JSTL (JSP Standard Tag Library)
<title>Book Title 2</title>
<isbn>0210504683</isbn>
<type>Non-Fiction</type>
</book>
<book checkedout="false">
<title>Book Title 3</title>
<isbn>0140911380</isbn>
<type>Non-Fiction</type>
</book>
</library>
</x:parse>
x:out
T he out action enables the developer to denote X Path expressions when working
with X M L documents.T he expression speciﬁed is applied to the current node
and the result is sent to the current JspW riter object.
<x:out select="${library/book/title}"/>
x:set
T he set action also evaluates a X Path expression on the current node. In this case
the result is assigned to a JSP scoped attribute as denoted by the var attribute.
<x:set var="isbns" select="${library/book/isbn}"/>
Iteration
JST L provides functionality for iterating over a collection of X M L elements.T he
tag for this X M L element iteration is the forE ach action.
x:forE ach
T he forE ach action allows you to iterate over a collection of X M L elements.T he
set of X M L elements to use is speciﬁed by the select attribute.T his select attribute
contains a valid X SL statement with which to ﬁlter the X M L document.
<h2>Library Contents</h2>
<x:forEach select="${library/book}">
Title: <x:valueof select="title"/> 
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
197
ISBN: <x:valueof select="isbn"/>
</x:forEach>
Flow Control
JST L provides functionality to conditionally branch execution of the current JSP
document based upon an X Path expression.T he action provided by the X M L
Tag Library includes the if action and the choose/ when/ otherwise actions.
x:if
T he if action is a conditional operator that executes its body only if the X Path
expression denoted by the select attribute evaluates to true.
<x:forEach select="${library/book}">
<x:if select="[@checkedout='false']">
<x:valueof select="$title"/> is available for checkout
</x:if>
</x:forEach>
x:choose
T he choose action encapsulates a series of nested <when> tags.T he choose action
therefore acts like the switch statement in Java.T his tag functions identically to the
action of the same name in the core package.
x:when
T he when action is a child tag of a choose action. Each when action has a select
attribute containing an X Path expression that, when evaluated to true, executes 
its body.
x:otherwise
T he otherwise action is the last of the choose action’s child elements.T his action
only executes its body content if all proceeding when actions evaluated to false.
<x:forEach select="${library/book}">
<x:choose>
<x:when test="$[type='Fiction']">
<x:valueof select="$title"/> is in the Fiction section.
</x:when>
www.syngress.com

198
Chapter 5 • Using JSTL (JSP Standard Tag Library)
<x:when test="$[type='Non-Fiction']">
<x:valueof select="$title"/> is in the Non-Fiction section.
</x:when>
<x:otherwise>
I do not know where <x:valueof select="$title"/> is.
</x:otherwise>
</x:choose>
</x:forEach>
In our example we have an X M L document holding data representing books
in a library.T he forE ach action will iterate over each book, the location of which
is speciﬁed in the select attribute. For each book element found the type is com-
pared to expected values, in this case a type equal to F iction or N on-F iction, and an
appropriate message is displayed. Failure to identify the type will result in an error
message from the JSP.
Translation and X SLT
JST L provides actions that perform translations of X M L documents.T his gives
you the ability to modify X M L that is structured according to one schema into a
new X M L document conforming to a different schema.
x:transform
T he transform action applies a transformation to an X M L document.T he xslt
attribute points to the X SL template to use for deﬁning the transformation.T he
X M L document itself can be speciﬁed either in the source attribute or within the
body of the transform action itself.
<x:transform source="library.xml" xslt="showCheckedOut.xsl"/>
T he result can end up in one of three places.; in lieu of any explicit destina-
tion notation, the output goes directly to the page content. If the result attribute
is present in the action, the output gets stored as a javax.xml.transform.R esult
instance named with the value of the result attribute. Finally, the output can be
saved as an instance of org.w3c.dom.D ocument when the var and scope attributes are
speciﬁed.
x:param
T he param action is used to pass parameters to the Transformer object of a 
<transform> tag.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
199
Summary
T he Java Standard Tag Library (JST L) represents a major step forward in the stan-
dardization of JSP tag library functionality. JST L provides ready-made, commonly
used functionality to a web application; including collection iteration, ﬂow con-
trol, attribute manipulation, X M L parsing and searching, and basic database sup-
port using SQ L and internationalization and localization. U sing JST L will
facilitate a wider deployment of your application across web servers that support
the JST L speciﬁcation.
T he support for Expression Languages (EL) further de-couples the presenta-
tion logic from the business logic. By providing access to business methods and
scoped data from an expression we lessen the need to resort to scriptlet code and
proprietary custom tag libraries.T he use of expression languages is by no means
mandatory, however. For every EL-supporting tag library provided, there is a twin
tag library that supports attribute expression evaluation using the standard JSP
scripting language.
Again, it is important to remember that these speciﬁcations are still largely
being formed. M odiﬁcations to the number, type and attributes of tags may
change by the time of the ﬁnal release.T herefore, care must be taken to not
deploy applications that rely too heavily on JST L at this time.
Solutions Fast Track
Expression Languages
 Expression Languages (EL) facilitate communication between business
logic and JSPs through scoped JSP attributes.
 Although the initial release of the JW SDP supports several different
Expression Languages, the direction is to eventually standardize on a
single EL.
 Each of the four tag libraries that make up JST L come in both EL and
non-EL versions.T he non-EL versions possess an “-rt” sufﬁx on their 
tag library descriptors.
www.syngress.com

200
Chapter 5 • Using JSTL (JSP Standard Tag Library)
C ore Tags
 JST L’s core tag library provides the c:out and c:set actions to manipulate
JSP scoped attributes using expressions.
 T he c:forE ach action is used to iterate over collections of objects.
 T he c:forTokens action is used to iterate over a series of tokens using a
speciﬁed delimiter.
 C onditional expressions are realized by the c:if, c:choose, c:when and
c:otherwise actions.
 T he c:choose body is only executed if all preceding c:when actions
evaluate their expressions to false.
 T he c:import and c:param actions are used to incorporate external
resources into the current JSP document.
 T he c:encodeU R L action will encode a string according to the 
www-form-urlencoded format.
SQ L Q uery Tags
 T he <driver> tag should not be used in production. Instead, create your
data source within some business logic and store it within the
appropriate context.
 T he <transaction> tag is used to bundle consecutive SQ L statements
within the same transactional context.
 T he SQ L Tag Library contains <query> and <update> tags to perform
those respective functions.
Internationalization Tags
 Internationalized messages and formatting instructions are stored in
resource bundles.
 T he resource bundle ﬁlename follows a naming convention that is used
during a search for the best possible match.
 T he best possible match for a resource bundle will not necessarily be an
exact match.T he best match is based upon the available resource bundles.
www.syngress.com

Using JSTL (JSP Standard Tag Library) • Chapter 5
201
 T he <message> and <messageF ormat> tags are used to retrieve and
format internationalized messages, respectively.
 T he messages associated with classes that are derived from
java.lang.T hrowable can be internationalized by overriding the
getL ocalizedM essage method.
X M L Support Tags
 All expressions in the X M L Tag Library use X Path expressions.
 JST L provides X M L transformation capabilities via the x:transform
action.
 By using the x:transformer action you can deﬁne a transformer instance
that is reusable against multiple X M L documents within the same page.
Q: H ow do I deﬁne the expression language evaluator that I wish to use within
my application?
A: You can either add a context parameter in the web.xml deployment descriptor
called javax.servlet.jsp.jstl.temp.E xpressionE valuatorC lass and give it a value equal
to the full package name of the appropriate evaluation class, or you can
specify it at the page level using the c:expressionL anguage action.
Q: H ow do I set the basename of the resource bundle I want to use when local-
izing messages?
A: You can either add a context parameter in the web.xml deployment descriptor
called javax.servlet.jsp.jstl.i18n.basename and give it a value equal to the base
name of the desired resource bundle or you can specify it at the page level
using the fmt:bundle action.
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

202
Chapter 5 • Using JSTL (JSP Standard Tag Library)
Q: H ow can I reuse an X SLT  for multiple X M L documents?
A: Deﬁne a Transformer (X SLT ) using the fmt:transformer action.
Q: Do I need to use expression languages to programmatically set the attributes
of JST L actions?
A: N o, you can use JST L without enabling EL support by using those tag
libraries that have an “-rt” sufﬁx in their ﬁlename.
Q: Does the use of X Path expressions in the X M L tag library actions conﬂict
with my choice of a global expression language?
A: T he only attribute of the X M L Tag Library actions to use the X Path expres-
sion language is the select attribute.You cannot mix expression languages in
this attribute, whichavoids any conﬂict regarding EL evaluation.
Q: H ow can I set a default data source for all JSP ﬁles in my web application,
with the option to override locally?
A: Somewhere in your application code, set the javax.servlet.jsp.jstl.sql.dataSource
scoped attribute to point to the desired D ataSource object.
www.syngress.com

Writing SOAP
Clients
Solutions in this chapter:
■
Understanding SOAP
■
SOAPElement and JAXM DOM
■
JAXM SOAP Elements
■
Creating a SOAP Message
■
Bringing it all Together—A Complete 
SOAP Client
Chapter 6
203
 Summary
 Solutions Fast Track
 Frequently Asked Questions

204
Chapter 6 • Writing SOAP Clients
Introduction
For the next few chapter, we will explore the development of SO AP communi-
cations using the Java Web Services Developers Pack.T his chapter will provide a
brief introduction to SO AP, which  is an X M L-based protocol for communi-
cating between distributed systems and can be extended with attachments con-
taining essentially any media type.
T he Java API for X M L M essaging (JAX M ) provides an API and speciﬁcation
for supporting services that enable developers to implement SO AP communica-
tions in Java.T his chapter will cover the implementation of SO AP clients using
JAX M  (that is, consumers of web services), and the next chapter will cover the
implementation of SO AP servers (that is, providers of web services).
U nlike most of the scenarios covered in this book, it is possible to implement
synchronous communications (that is, request/ reply) without the aid of a servlet
or EJB container, and this chapter will fully describe an example of such a stan-
dalone Java application that functions as a SO AP client.
Understanding SOAP
T he Simple O bject Access Protocol (SO AP) is an X M L-based protocol that is
designed to be a lightweight method for exchanging information between dis-
tributed systems. It is very much a cross-platform and cross-vendor technology,
and has the backing of a very wide range of companies.We will discuss two ﬂa-
vors of SO AP documents: plain SO AP, which is a pure X M L message, and SO AP
with Attachments, which allows for many types of data to be transmitted with a
SO AP message.
SO AP is a fairly unique technology for use in distributed computing; it has
some things in common with other mechanisms such as R M I, but it also has a
number of differentiating features.T hese differences stem largely from the fact
that SO AP is designed as a simple protocol— it has been deliberately designed to
be lightweight, and for this reason it does not support such features as passing
objects by reference.
SO AP is also designed to be extensible, and these goals of simplicity and
extensibility have meant that the use of SO AP does not imply any particular pro-
gramming models; a given implementation’s semantics are extremely ﬂexible.
T here are a number of possible models for exchanging messages, as well as mech-
anisms for exchanging data of application-deﬁned types and for performing
remote procedure calls and responses.
www.syngress.com

www.syngress.com
SOAP messages do not need to be bound to a particular protocol; H T T P is an
obvious choice for many situations (and will be used for the examples in this
chapter and the next), but there are many other possibilities. Likewise the model for
exchanging messages is essentially a one-way transmission between two peers; the
sender sends a message to the receiver. H owever this model can be extended—
“request-response” is an obvious possibility, as are one-to-many transmissions and
asynchronous transmission or reception via some form of queuing mechanism.
A complete study of the SO AP speciﬁcations is well beyond the scope of 
this book.We would recommend the following documents for more detailed
information:
■
Simple Object Access Protocol (SOAP) 1.1 www.w3.org/
T R / SO AP
■
SOAP Messages with Attachments www.w3.org/ T R /
SO AP-attachments
Additionally, there are a number of tutorials and books available.T he
soaprpc.com site is a good place to look for information; it contains a list of links
to SO AP tutorials at www.soaprpc.com/ tutorials/ .
Envelopes
Although SO AP M essages with Attachments can contain attachments of various
content types, a simple SO AP message is an X M L document that contains the
elements displayed in Figure 6.1.
T he SO AP Envelope is the top element of the X M L document; as such, it
must be present in every SO AP message. If present, the H eader will exist as an
element within the Envelope; the Body will also be present as an element within
the Envelope.An empty envelope would look as follows:
<soap-env:Envelope xmlns:soap-
env="http://schemas.xmlsoap.org/soap/envelope/">
</soap-env:Envelope>
Because it doesn’t contain a Body element, this envelope would not be a valid
SO AP message, but it illustrates an important point about namespaces in SO AP
messages:T he SO AP namespace is deﬁned by this envelope as having a U R I of
“ http:/ / schemas.xmlsoap.org/ soap/ envelope/ ” and a preﬁx of “ soap-env” .T his is
because the SO AP speciﬁcation states that all of the elements in a SO AP message
must be qualiﬁed by this very namespace— an element named “ H eader” that was
Writing SOAP Clients • Chapter 6
205

206
Chapter 6 • Writing SOAP Clients
either locally-named or qualiﬁed by a different namespace would not be recog-
nized as a SO AP H eader element.
Headers
T he H eader is an optional element that may exist in the envelope. H eader ele-
ments are used to transmit additional information along with a message, such as
authentication or transaction information. H eader elements can also contain cer-
tain attributes. O ne of these is the mustU nderstand attribute, which can be used to
specify that the recipient of the message must be able to process that header ele-
ment. If the mustU nderstand attribute is not set, or contains a value of 0 rather
than 1, it implies that the recipient of the message is free to ignore the header
element if it does not know how to process it.
An envelope that contains a header specifying an ignorable authentication ID
could look like this:
<soap-env:Envelope xmlns:soap-
env="http://schemas.xmlsoap.org/soap/envelope/">
<soap-env:Header>
<auth:AuthID xmlns:auth="my-URI">
Admin
www.syngress.com
Figure 6.1 The Components of a SOAP Message
SOAP Message
Envelope
Header
(Optional)
Attachment 1
(Only in SOAP Messages
with Attachments)
Body
Attachment 1
(Only in SOAP Messages
with Attachments)

Writing SOAP Clients • Chapter 6
207
</auth:AuthID>
</soap-env:Header>
</soap-env:Envelope>
In this example, you can see the use of the soap-env namespace preﬁx against
the H eader element, allowing it to be recognized as a SO AP header.W ithin the
header is an additional element deﬁning a new namespace with a preﬁx “ auth”
and a U R I of “ my-U R I” . Such a namespace can be deﬁned by anybody.T he
main thing is that, though it is preferable that the namespace will be globally
unique, it must at least be unique within the environment in which it will be
used. For this reason, our example code will make use of a namespace U R I
“ www.syngress.com/ JW SD P / soap-example” — this can be relied on as being globally
unique as long as someone within the Syngress organization ensures that it is
locally unique.
T he actual element name used in this example (A uthID ) indicates that it con-
tains authentication information. If the message’s receiver understands what the
A uthID element means (within the deﬁned namespace), it should process the ele-
ment, in this case by checking that A dmin is an authorized account name. If the
receiver of this message does not know how to process the element, it can be
ignored.
Bodies
T he Body element must exist in a SO AP message (as an immediate child element
of the Envelope), and can contain various kinds of information such as informa-
tion being requested or returned, or error information. If error information is
being transmitted in a SO AP message, it is carried using an optional entry within
the Body element known as a SO AP F ault.
An envelope containing a simple B ody element containing the time may look
like this:
<soap-env:Envelope xmlns:soap-
env="http://schemas.xmlsoap.org/soap/envelope/">
<soap-env:Body>
<x:CurrentTime xmlns:x="my-URI">
23:12:17
</x:CurrentTime>
</soap-env:Body>
</soap-env:Envelope>
www.syngress.com

208
Chapter 6 • Writing SOAP Clients
Attachments
SO AP M essages with Attachments extend SO AP’s basic model of a single X M L
document by adding one or more attachments, each of which can contain con-
tent that is not restricted to being X M L.
You may wonder why it is so important for a message to contain attach-
ments.T he answer lies in the fact that a standard SO AP message must contain
only X M L, and that sometimes it may be desirable for a message to contain
another form of data.
As an example, consider a web service that provides information on the surf
conditions for beaches local to a particular city.You can readily imagine SO AP
being employed to allow people to send a message that requested the conditions
at a particular beach; the response could very easily contain a textual description
along the lines of “C omfortable water temperature, waves up to 3 feet, no wind”
or “Treacherous conditions— BEAC H  C LO SED.”
Imagine then if this very useful web service was to be upgraded; M aybe the
town council installed digital cameras at each of the beaches.T he web service
would then provide not only a textual description of the surﬁng conditions, but a
snapshot photograph of the beach as well, transmitted as a JPEG binary.T hat’s all
well and good, but how do you transmit a JPEG within a SO AP message?
O bviously there’s no problem sending such photographs over H T T P using M IM E
encoding, but the X M L-only nature of the SO AP standard doesn’t allow for it.
T he answer is the optional use of attachments. If a message can be transmitted
as a pure SO AP message containing only X M L, then the SO A P M essage will con-
tain just the SO AP content. H owever, if the message is to also contain attach-
ments, the SO A P M essage will actually be a M IM E-encoded message containing
the SO AP content and one or more attachments of any type. So SO AP messages
effectively fall into two distinct categories:
■
M essages that contain only X M L content and are not M IM E-encoded.
■
M essages that are M IM E-encoded, and that contain an initial X M L pay-
load as well as any number of attachments.T hese attachments could each
contain any kind of data; it may be text data, it may be images, it may be
audio, video— anything.
www.syngress.com

Writing SOAP Clients • Chapter 6
209
SOAPElement and JAXM DOM
As soon as you start working with JAX M ’s DO M  implementation you will
notice some similarities and some very obvious differences between it and the
W 3C  DO M  implementation as used by JAX P. It seems perhaps unnecessary to
have this additional DO M  implementation when a W 3C  DO M  implementation
will most likely will be available along with any JAX M  implementation.T he
reason for this is purely historical; the JAX M  work was performed as a JC P effort
in parallel to the JAX P work. H owever, until such time as the JAX M  API sup-
ports JAX P more closely you will have to learn this additional speciﬁcation if you
intend to program with JAX M .
SOAPElement
T he java.xml.soap.SO A P E lement interface is a key interface in the JAX M  DO M
API. SO A P E lement has a lot in common with the org.w3c.dom.E lement interface
that was covered in the chapter on JAX P.As mentioned, however, there are a
number of differences.
W hen you ﬁrst look at the two interfaces side by side, some differences
become immediately obvious.T hese include differences in the names of methods
(addA ttribute in SO A P E lement versus setA ttribute in E lement).Another difference is
that the org.w3c.dom.E lement interface contains a number of near-duplicate
methods (those with the “N S” sufﬁxes) for supporting operations involving
namespace-qualiﬁed names rather than local names; the SO A P E lement approach is
to use a single method for each operation and to use a N ame parameter to repre-
sent either a local name or a namespace-qualiﬁed name (although there is some
inconsistency in this, as there are overloaded variants of the addC hildE lement
method for specifying local names or namespace-qualiﬁed names).T he N ame
interface will be examined below.
SO A P E lement is the direct superinterface for most of the SO AP objects in 
the JAX M  API.We have already seen that a SO AP message contains such compo-
nents as an envelope, a header (perhaps), and a body; we will shortly see that the
JAX M  API represents these with interfaces named SO A P E nvelope, SO A P H eader,
SO A P B ody and the like. Each of these interfaces is a subinterface of SO A P E lement
and therefore most of the work you do in manipulating and reading from these
components will be done via methods of the SO A P E lement interface.
www.syngress.com

210
Chapter 6 • Writing SOAP Clients
Attributes
T he SO A P E lement interface provides several methods for adding, retrieving and
removing attributes of an element— Table 6.1 lists these methods.
Table 6.1 SOAPElement Methods for Adding, Retrieving and 
Removing Attributes
Method
Description
SOAPElement addAttribute(Name name, 
Add a new attribute to an 
java.lang.String value)
element. As already men-
tioned, the name parameter
allows either a local name or
a namespace-qualiﬁed name
to be speciﬁed.
java.util.Iterator getAllAttributes()
Retrieves the list of all
attributes of an element by
returning an iterator over
the names of those
attributes. For each of those
names, getAttributeValue
can be used to retrieve the
values individually. Each ele-
ment returned by the iter-
ator will be an object of
type Name.
java.lang.String getAttributeValue(Name name)
Retrieves the value of an
attribute by local or name-
space-qualiﬁed name.
boolean removeAttribute(Name name)
Deletes an attribute by local
or namespace-qualiﬁed
name.
C hild Elements
T he JAX M  DO M  implementation also provides a set of methods for adding,
retrieving and removing child elements of an SO A P E lement, as listed in Table 6.2.
www.syngress.com

Writing SOAP Clients • Chapter 6
211
Table 6.2 SOAPElement Methods for Adding, Retrieving and Removing 
Child Elements
Method
Description
SOAPElement addChildElement(Name name)
Adds a new child element to
an SOAPElement with either
a local name or a namespace-
qualiﬁed name.
SOAPElement addChildElement(SOAPElement 
Takes an already-created 
element)  
SOAPElement object and
adds it as a child element.
SOAPElement addChildElement(java.lang.String Adds a new child element to 
localName)  
an SOAPElement with a local
name.
SOAPElement addChildElement(java.lang.String 
Adds a new child element to 
localName, java.lang.String preﬁx)
an SOAPElement with a local
name and namespace preﬁx.
SOAPElement addChildElement(java.lang.String Adds a new child element to 
localName, java.lang.String preﬁx, 
an SOAPElement with a 
java.lang.String uri)
namespace-qualiﬁed name.
java.util.Iterator getChildElements()  
Gets all of the child elements
of an SOAPElement by
returning an iterator over the
elements.
java.util.Iterator getChildElements(Name name) Gets all of the child elements
of an SOAPElement that
match a certain name (local
or namespace-qualiﬁed) by
returning an iterator over the
matching elements.
void detachNode()
Inherited from the
javax.xml.soap.Node interface
(which is the direct superin-
terface of SOAPElement),
allows an element to be
deleted from the tree.
void recycleNode()
Also inherited from Node,
this method should only be
called after calling
detachNode, and notiﬁes the
JAXM implementation that
the object is no longer being
www.syngress.com
Continued

212
Chapter 6 • Writing SOAP Clients
used and can be re-used for
elements that may be created
in the future.
void setParentElement(SOAPElement parent)
By setting the parent element
of a child element, it is pos-
sible to move a child element
around within the tree.
As an example, the following code can be used to remove from a SO AP
Body all of the child elements that have the local name “ category” :
// soapMsg is an SOAPMessage object
SOAPPart part = soapMsg.getSOAPPart();
SOAPEnvelope env = part.getEnvelope();
SOAPBody body = env.getBody();
Name nm = env.createName("category");
Iterator it = body.getChildElements(nm);
while (it.hasNext()) {
SOAPElement child = (SOAPElement)it.next();
child.detachNode();
child.recycleNode();
}
Text N odes
Text nodes are another area where the JAX M  DO M  implementation differs from
that of JAX P.A text node is added to a SO A P E lement by calling the addTextN ode
method and passing in the text data as the parameter.T he data can be read out of
a text node by calling the getValue method.As an example, the following code
adds a child element with a local name of “ bodytype” and a text node of “ saloon” .
// body is an SOAPBody object
SOAPElement child;
child = body.addChildElement("bodytype");
child.addTextNode("saloon");
www.syngress.com
Table 6.2 Continued
Method
Description

Writing SOAP Clients • Chapter 6
213
After this code has been executed, the child object will represent the 
following X M L:
<bodytype>saloon</bodytype>
Likewise, to read the data back from this text node, you would call getValue
against the immediate parent element of the text node, in this case the child
object as follows:
String textVal = child.getValue();
T he getValue method will only return data if the immediate child element is a
text node, otherwise it will return null.
Name
N ame objects represent X M L names, which may be either local names , or
namespace-qualiﬁed.As mentioned above, the use of the N ame interface in the
JAX M  API simpliﬁes the DO M  implementation(especially in terms of the
number of methods required for the SO A P E lement interface).
N ame objects need to be created using a SO A P E nvelope object, which will be
described below.T he SO A P E nvelope object represents the E nvelope in a SO AP
message; whether you are building a SO AP message to transmit or are parsing a
received SO AP message you will always have access to a SO A P E nvelope object.
T he following code can be used to create both local and namespace-qualiﬁed
N ame objects:
// soapMsg is an SOAPMessage
SOAPPart part = soapMsg.getSOAPPart();
SOAPEnvelope env = part.getEnvelope();
Name localName = env.createName("model");
Name nsName = env.createName(
"RequestMakeAndModel", 
"mkt", 
"http://www.mydomain.com/market");
In the example above, the localN ame object will represent the local name
“ model” .T he nsN ame object, on the other hand, will represent a namespace-
qualiﬁed name with a local name of “ R equestM akeA ndM odel” , a preﬁx of “ mkt” ,
www.syngress.com

214
Chapter 6 • Writing SOAP Clients
and a U R I of “ http:/ / www.mydomain.com/ market” .T his would be represented in
X M L as:
<mkt:RequestMakeAndModel xmlns:mkt="http://www.mydomain.com/market">
Text
T he Text interface models text nodes; the Text object is created when a text node
is added to an element via the addTextN ode method. It is also possible for a Text
object to represent a comment; the isC omment method is available to determine
whether this is the case.
JAXM SOAP Elements
T he SO AP speciﬁcation deﬁnes a very clear structure of elements: E nvelope,
H eader, B ody, F ault, and the like; the speciﬁcation for SO AP M essages with
Attachments extends this structure. In this section we will cover the JAX M  API’s
representation of all of these elements as Java types, and we will also see that
JAX M  provides a few additional elements that do not map exactly to elements
within the SO AP speciﬁcation but which are used to enable messages, both with
and without attachments, to be represented in a uniﬁed object structure.
SOAPMessage
T he javax.xml.soap.SO A P M essage class is the root class for all JAX M  SO AP mes-
sages.T he SO A P M essage class is slightly different to the majority of the JAX M
SO AP classes in that it doesn’t map directly to the SO AP standard hierarchy— in
fact, it represents a layer on top of the SO AP standard with one speciﬁc purpose:
to allow a message to contain attachments, conforming to the SO A P  M essages
with A ttachments speciﬁcation.
Figure 6.2 shows an example of the ﬁrst kind of message— it contains SO AP
content as X M L and is not M IM E encoded.
www.syngress.com
Figure 6.2 SOAPMessage Containing Only SOAP Content
SOAPMessage
SOAP content -
XML format

Writing SOAP Clients • Chapter 6
215
Figure 6.3 shows the second kind of message.T he message is M IM E encoded
and contains SO AP content followed by at least one attachment of any multi-
media type.
M IM E encoding
M ulti-purpose Internet M ail Extensions (M IM E) is a set of speciﬁcations with
the purpose of transferring text using different character sets, as well as transfer-
ring multi-media data between computers.
As its name implies, M IM E was originally designed to facilitate the transfer of
data via e-mail; it is M IM E that allows all kinds of multimedia e-mail attachments
to be transmitted. H owever, M IM E is also very useful for the interchange of data
via other means, from the downloading of various types of data to web browsers
through to such uses as transmitting various attachments with  SO AP messages.
If you examine a M IM E-encoded message, you will see that M IM E is really a
way of labeling parts of a message so that they can be handled in the correct way.
For example, if a web browser sees M IM E content marked as image/ jpeg, it knows
that the content is to be displayed as a binary JPEG image.
O ne of the great features of M IM E encoding is that various parts of a mes-
sage can be labeled as having different content types, and it is this feature that
www.syngress.com
Figure 6.3 SOAPMessage Containing One or More Attachments
SOAPMessage - MIME
Encoded
SOAP content -
XML format
Attachment 1
Attachment 2
Attachment n
= Required
= Optional

216
Chapter 6 • Writing SOAP Clients
allows multiple attachments of varying content types to co-exist in a SO AP mes-
sage. Some of the many possible content types are listed in Table 6.3.
Table 6.3 Examples of MIME Content Types
Content Type/Subtype
Description
text/xml
XML text. This will always be the content type
for the SOAP part of the message; it is also a
valid type for attachments.
text/plain 
Plain text.
application/octet-stream
A stream of bytes representing raw binary data;
serves as a default type for binary data.
image/gif
GIF image data.
video/mpeg
MPEG-encoded video.
If we create an SO A P M essage and populate it with very simple data, then add
some kind of attachment, the message will immediately be M IM E-encoded: the
SO AP part will be marked with a content type of text/ xml, while the attachment
will be marked with its appropriate type.
N ote that within a multipart M IM E-encoded message, there can be several
different types of M IM E headers: the C ontent-Type header deﬁnes the M IM E
type, while the C ontent-ID header allows the part to be referenced by other
M IM E parts, whereas the C ontent-L ocation header can be used to enable a M IM E
part to be referenced by H T M L M IM E parts. For this reason, SO A P Part contains
methods for manipulating the C ontent-ID and C ontent-L ocation headers, but does
not provide for manipulation of the C ontent-Type header since the M IM E type is
ﬁxed to text/ xml.
T he following output shows the content of a sample message.T here are
clearly two parts to this message; the ﬁrst is obviously the SO AP content itself 
(in this case with some added formatting for clarity) and the second part is
marked as plain text and carries the Sample attachment content data:
------=_Part_0_7615385.1014026663603
Content-Type: text/xml
<soap-env:Envelope xmlns:soap-env="http://schemas.xmlsoap.org/soap/
envelope/">
<soap-env:Header/>
<soap-env:Body>
www.syngress.com

Writing SOAP Clients • Chapter 6
217
<sample:SimpleExample xmlns:sample="http://my.domain/myuri/">
<name>example</name>
</sample:SimpleExample>
</soap-env:Body>
</soap-env:Envelope>
------=_Part_0_7615385.1014026663603
Content-Type: text/plain
Sample attachment content
------=_Part_0_7615385.1014026663603--
In contrast to the above message, a message with no attachments will actually
contain no M IM E information at all, as shown in this sample content:
<soap-env:Envelope xmlns:soap-
env="http://schemas.xmlsoap.org/soap/envelope/">
<soap-env:Header/>
<soap-env:Body>
<sample:SimpleExample xmlns:sample="http://my.domain/myuri/">
<name>example</name>
</sample:SimpleExample>
</soap-env:Body>
</soap-env:Envelope>
NOTE
The above examples demonstrate messages that can clearly be sent as
text. However, what happens if we need to add an attachment that
clearly does not contain text data (such as a JPEG image)? The answer is
that the data will be Base64-encoded; Base 64 is a scheme that uses four
characters to encode each group of three bytes, thus enabling binary
data to be represented by all variants of ASCII and EBCDIC text encoding.
SOAPPart
T he javax.xml.soap.SO A P Part class is very similar to the SO A P M essage class in
that it does not map directly to an element within the SO AP speciﬁcation.
www.syngress.com

218
Chapter 6 • Writing SOAP Clients
Instead, SO A P Part represents the part of a message carrying the SO AP payload, as
opposed to any attachments that may be carried by the message.
Every SO AP M essage must contain a SO A P Part. Furthermore, since the
SO AP component of a message must be in X M L format, the SO A P Part will
always contain a C ontent-Type M IM E header with a value of “text/ xml.” N ote
that you do not need to explicitly create the SO A P Part; once an SO A P M essage is
created, you can simply retrieve the SO A P Part from it.
T he SO A P Part interface, as well as extending the SO A P E lement interface
described above, deﬁnes the methods listed in Table 6.4. N ote also that, in
common with the SO A P M essage class, SO A P Part is an abstract class; you should
always obtain a SO A P Part object from a corresponding SO A P M essage object.
Table 6.4 SOAPPart Methods
Method
Description
void addMimeHeader(java.lang.String 
Creates a new MimeHeader object 
name, java.lang.String value)
and adds it to the SOAPPart.
Java.util.Iterator getAllMimeHeaders()
Returns an iterator over all of the
MimeHeader objects attached to this
SOAPPart.
Source getContent()  
Returns the SOAPEnvelope content
as a javax.xml.transform.Source
object, as covered in the chapter on
JAXP.
java.lang.String getContentId()  
Retrieves the value of a speciﬁc
MIME Header—that with the name
“Content-Id”
java.lang.String getContentLocation()  
Retrieves the value of a speciﬁc
MIME Header—that with the name
“Content-Location”
SOAPEnvelope getEnvelope()  
Returns the SOAPEnvelope object.
java.util.Iterator 
Returns an iterator over all of the 
getMatchingMimeHeaders
MimeHeader objects that match one 
(java.lang.String[] names)
of the names in the array.
java.lang.String[] 
Returns an array of values for MIME 
getMimeHeader(java.lang.String name) Headers that match the name.
java.util.Iterator 
Returns an iterator over all of the 
getNonMatchingMimeHeaders
MimeHeader objects that do not
(java.lang.String[] names)
match one of the names in the array.
www.syngress.com
Continued

Writing SOAP Clients • Chapter 6
219
Void removeAllMimeHeaders()  
Removes all of the MimeHeader
objects from the SOAPPart.
void removeMimeHeader
Remove any MimeHeader objects 
(java.lang.String header)  
that match the name.
Void setContent(Source source)  
Populates the content of the SOAP
Envelope from a JAXP Source object.
void setContentId(java.lang.String 
Sets the value of a speciﬁc MIME 
contentId)  
Header—that with the name
“Content-Id”
void setContentLocation
Sets the value of a speciﬁc MIME 
(java.lang.String contentLocation)
Header—that with the name
“Content-Location”
void setMimeHeader(java.lang.String 
Sets the value of the ﬁrst matching 
name, java.lang.String value)  
existing MIME Header matching a
certain name to a certain value. If no
matching header exists, a new one
will be created and added.
SOAPEnvelope
U nlike SO A P M essage and SO A P Part, both of which do not strictly map to the
SO AP speciﬁcation, the interface javax.xml.soap.SO A P E nvelope maps to the speci-
ﬁcation exactly— a SO A P E nvelope object is a representation of a SO AP Envelope.
Just as the SO AP speciﬁcation states that an Envelope may contain a header
and must contain a body, a SO A P E nvelope can contain objects representing the
header and body.A newly-created message’s default behavior is that it will con-
tain a SO A P E nvelope that in turn will contain an empty header and  body. In the
following chapter we will show that Proﬁles can be used to generate messages
that adhere to higher-level protocols (such as ebX M L), and that such messages
may be generated with additional elements speciﬁc to that protocol.
T he SO A P E nvelope is a subtype of SO A P E lement and therefore inherits the
DO M  functionality of that interface.Additionally, an SO A P E nvelope object will
implement the methods listed in Table 6.5.
www.syngress.com
Table 6.4 Continued
Method
Description

220
Chapter 6 • Writing SOAP Clients
Table 6.5 SOAPEnvelope Methods
Method
Description
SOAPBody addBody()
Adds a new Body to the Envelope if none
already exists, otherwise throws an exception.
You would not normally need to call this
explicitly as the Envelope should contain a
Body by default after creation.
SOAPHeader addHeader()  
Adds a new Header to the Envelope if none
already exists, otherwise throws an exception.
You would not normally need to call this
explicitly as the Envelope should contain a
Header by default after creation.
Name createName
As described above, the Name object can 
(java.lang.String localName)
represent a local or a namespace-qualiﬁed
name. This method will create a local name.
Name createName
Creates a namespace-qualiﬁed name.
(java.lang.String localName, 
java.lang.String preﬁx, 
java.lang.String uri)
SOAPBody getBody()  
Provides access to the Body element.
SOAPHeader getHeader()  
Provides access to the Header element.
SOAPHeader and SOAPHeaderElement
T he javax.xml.soap.SO A P H eader interface is designed to represent a SO AP
H eader, and accordingly, the javax.xml.soap.SO A P H eaderE lement interface repre-
sents elements within that H eader.
SO A P H eader, in common with all of the SO AP element interfaces, is a sub-
type of SO A P E lement, but in addition it deﬁnes a number of methods that are
described in Table 6.6.
Table 6.6 SOAPHeader Methods
Method
Description
SOAPHeaderElement 
Creates a new Header Element, initialized with 
addHeaderElement
the local or namespace-qualiﬁed name, and 
(Name name)  
inserts it into the Header.
java.util.Iterator 
Returns an iterator over all of the Header
examineHeaderElements
Elements that match the speciﬁed actor.
(java.lang.String actor)  
www.syngress.com
Continued

Writing SOAP Clients • Chapter 6
221
java.util.Iterator 
Returns an iterator over the exact same set of 
extractHeaderElements
Header Elements as the above method, but 
(java.lang.String actor)
additionally detaches them from the Header.
Similarly to SO A P H eader, SO A P H eaderE lement deﬁnes certain methods in
addition to those deﬁned by SO A P E lement, as listed in Table 6.7
Table 6.7 SOAPHeaderElement Methods
Method
Description
java.lang.String getActor()  
Returns the URI representation of the
actor associated with this element.
Boolean getMustUnderstand()  
Returns the value of the
mustUnderstand attribute for this
element. A value of 1 represents
true; a value of 0 or a non-existent
attribute represents false.
void setActor(java.lang.String actorURI) Sets the URI representation of the
actor associated with this element.
void setMustUnderstand(boolean 
Sets the value of the 
mustUnderstand)
mustUnderstand attribute for this
element. A value of 1 represents
true; a value of 0 or a non-existent
attribute represents false.
T his is the ﬁrst time we have mentioned the term A ctor.An Actor simply
describes to whom an element in a SO AP H eader is addressed. It is speciﬁed as
an attribute of the element (called actor), and its value is a U R I. In an asyn-
chronous message which is routed via multiple parties,Actors can be used to
specify that certain header elements in the message are addressed to certain par-
ties even though the message itself is ultimately being sent to another destination.
For more information on Actors, refer to the SO AP speciﬁcation.
In order to add content to a header Element you would generally use the
JAX M  DO M  implementation, as deﬁned through the SO A P E lement interface, in
combination with the speciﬁc methods in the SO A P H eaderE lement interface for
setting certain attributes (namely the actor and mustU nderstand attributes).
www.syngress.com
Table 6.6 Continued
Method
Description

222
Chapter 6 • Writing SOAP Clients
SOAPBody, SOAPBodyElement and SOAPFault
As with the interfaces described above for dealing with SO AP H eaders, the
javax.xml.soap.SO A P B ody interface is intended to model the Body within a
SO AP M essage and the javax.xml.soap.SO A P B odyE lement interface is designed to
model elements within that SO AP Body.
In the same way as the interfaces that model the other elements of a SO AP
M essage, the SO A P B ody and SO A P B odyE lement interfaces are subtypes of
SO A P E lement, although only SO A P B ody deﬁnes additional methods.Table 6.8
lists the methods deﬁned by SO A P B ody.
Table 6.8 SOAPBody Methods
Method
Description
SOAPBodyElement 
Creates a new Body Element, initialized with 
addBodyElement(Name name)  
the local or namespace-qualiﬁed name, and
inserts it into the Body.
SOAPFault addFault()  
Creates a new Fault and inserts it into the
Body. There should only ever be one SOAP
Fault in any message.
SOAPFault getFault()  
Returns the SOAPFault object that is
attached to the Body if one exists, otherwise
returns null.
boolean hasFault()  
Returns true if the Body contains a SOAP
Fault, otherwise returns false.
You will recall from the introductory discussion above that each SO AP
M essage may convey error information in the form of a Fault, and a maximum of
one Fault element may exist in a particular SO AP M essage.Also, if a SO AP Fault
element does exist, it will exist as a direct child element of the Body.
javax.xml.soap.SO A P F ault models a SO AP element.T his interface is a direct
subinterface of SO A P B odyE lement and as such also extends the SO A P E lement
interface. H owever, unlike SO A P B odyE lement, SO A P F ault deﬁnes a number of
additional methods, which are listed in Table 6.9.
www.syngress.com

Writing SOAP Clients • Chapter 6
223
Table 6.9 SOAPFault Methods
Method
Description
Detail addDetail()  
Creates a new Detail object and adds it to
the Fault. There may only be one Detail
object attached to a Fault.
Detail getDetail()  
Returns the Detail object attached to the
Fault.
java.lang.String getFaultActor()  
Returns the URI of the Actor to which the
Fault is addressed.
java.lang.String getFaultCode()  
Returns the Fault Code of the Fault.
java.lang.String getFaultString()  
Returns the Fault String of the Fault.
void setFaultActor
Sets the URI of the Actor to which the 
(java.lang.String faultActor)  
Fault is addressed.
void setFaultCode
Sets the Fault Code.
(java.lang.String faultCode)  
void setFaultString
Sets the Fault String.
(java.lang.String faultString)
T he D etail object will be an instance of the javax.xml.soap.D etail interface,
which allows any number of Detail Entries to be added through the addD etailE ntry
method, and also returns an iterator over those entries via the getD etailE ntries
method.T he example code in this chapter will demonstrate how to extract infor-
mation from a SOAP Fault. and You will see how to add this Fault information to a
SOAP M essage when we develop the SOAP Sevice in the next chapter.
Creating a SOAP Message
As well as providing the above API, JAX M  also deﬁnes the concept of a P rovider.
A JAX M  Provider is a type of service that can provide several tasks, including
providing a store-and-forward mechanism for guaranteeing delivery of asyn-
chronous SO AP M essages.A P rovider is not actually part of the API; it will nor-
mally exist as a servlet or some other form of service within your J2EE
container.T he JAX M  API provides mechanisms that enable your container-
hosted application to connect to a Provider and send messages to it, and the
provider will route incoming messages to your application. H owever, the actual
implementation of the Provider and its capabilities are up to the speciﬁc vendor.
A JAX M  Provider can only be used by applications running in a container.
Does this mean that standalone Java programs cannot communicate using SO AP?
www.syngress.com

224
Chapter 6 • Writing SOAP Clients
N ot at all; it simply means that they are restricted to not using a Provider and
therefore must communicate synchronously.T his chapter focuses on these types
of applications— in the next chapter we will deal with interacting with JAX M
Providers in more detail.
Since the JAX M  classes we have just looked at cannot be directly instantiated
(SO A P M essage is an abstract class, SO A P H eader, SO A P B ody etc. are interfaces),
there is a requirement for a factory to produce the objects to build a usable
SO AP message, in much the same way as factories are used with JAX P.
JAX M  factories are provided by the underlying implementation to provide
objects of implementation-speciﬁc classes; the interface types (Java interfaces or
abstract classes) represent the speciﬁcation, and what comes out of the factory is
an object that conforms to that speciﬁcation, though the actual implementation
of that object may vary wildly from one vendor’s implementation to another.We
know that the object we request from the factory will implement all of the
behaviors described above; exactly how it implements these and therefore how it
may perform in terms of speed, memory usage, or any number of characteristics
is entirely determined by the speciﬁc implementation of the JAX M  API.
MessageFactory
T he actual factory that will produce our SO A P M essage objects is called
M essageF actory.A M essageF actory object is capable of producing SO A P M essage
objects, which will each contain a certain set of objects (such as SO A P H eader).
Additional objects are created in a hierarchical fashion, so that
SO A P H eaderE lement objects are created by SO A P H eader objects, for example.
T he ﬁrst step in constructing a JAX M  SO AP message is to obtain a
M essageF actory.T his can be done a couple of ways:
■
If the application is running in a container and making use of a JAX M
Provider, the application will use its connection with the Provider to
request a message factory.T his scenario will be covered in the following
chapter.
■
If the application is not using a Provider, a static member of the
M essageF actory class can be called to return a message factory instance.
T his is the scenario on which we will focus in this chapter.
U sing the static member, we can create the factory as follows:
MessageFactory msgFactory = MessageFactory.newInstance();
www.syngress.com

Writing SOAP Clients • Chapter 6
225
A M essageF actory instance is used to generate SO AP messages (instances of
SO A P M essage), and these messages will be formatted according to the properties
of the M essageF actory itself.To create a message, the following code can be called:
SOAPMessage soapMsg = msgFactory.createMessage();
A successful call to createM essage() will always generate a SO A P M essage object
with the following properties:
■
A SO A P Part object (containing the SO A P E nvelope object).
■
A SO A P E nvelope object (containing the SO A P H eader and SO A P B ody
objects).
■
A SO A P H eader object, which may contain different information
depending on the proﬁle conﬁgured for the M essageF actory, so the header
will be different for a SO AP message than for an ebX M L message.
■
A SO A P B ody object.
www.syngress.com
Message Factories—Where can I get one?
Not only do JAXM Providers implement a store-and-forward mechanism
for taking care of routing asynchronous messages to their destination
and guaranteeing their delivery, but they also provide a concept known
as Proﬁles—that is, they can manage the various protocols (such as
ebXML) that are built on top of SOAP.
In this chapter we examine how to obtain a MessageFactory object
by calling the MessageFactory.newInstance method. However, this is
really only half the story. Such a factory object can only be used by JAXM
applications that are communicating synchronously without the services
of a JAXM Provider (such as the client application example described in
this chapter).
However, if an application wishes to create messages that will 
be routed via a JAXM Provider, the application will have to use a dif-
ferent mechanism to obtain a MessageFactory object. The JAXM API 
provides a way for applications to communicate with Providers via 
a ProviderConnection object. This connection can then be used to
request a M essageFactory instance; this is done by calling the
Developing & Deploying…
Continued

226
Chapter 6 • Writing SOAP Clients
Creating SOAP Parts, 
Envelopes, Headers and Bodies
For a standard SO AP proﬁle, the M essageF actory will return a message object 
that has a skeleton body and header, as well as their enclosing envelope and
SO A P Part.T he actual SO AP X M L will look like this (some carriage returns have
been added for clarity):
<soap-env:Envelope xmlns:soap-
env="http://schemas.xmlsoap.org/soap/envelope/">
<soap-env:Header/>
<soap-env:Body/>
</soap-env:Envelope>
T herefore, we do not need to actually create these elements, but rather popu-
late them with meaningful information.
Since the message factory will return messages that always create a SO A P Part
object, we simply need to access that object through the message itself.T his is
done as follows:
SOAPPart soapPart = soapMsg.getSOAPPart();
O nce we have accessed the SO A P Part object, we can use it to access the
envelope as in this piece of code:
SOAPEnvelope soapEnvelope = soapPart.getEnvelope();
Likewise, the envelope can be used to access both the header and the body.To
access the header:
SOAPHeader soapHeader = soapEnvelope.getHeader();
T he SO AP 1.1 speciﬁcation describes an example header element that speci-
ﬁes a transaction.T he name of the element is “ Transaction” (qualiﬁed by a names-
pace with a preﬁx of “ t” and a U R I of “ some-U R I” ), it contains a
www.syngress.com
ProviderConnection.createMessageFactory method. In the next chapter
we will examine more speciﬁcally how to create a connection to a
Provider, and how to use the connection to request a factory. In this
chapter we will continue to focus on applications that do not make use
of a Provider.

Writing SOAP Clients • Chapter 6
227
mustU nderstand attribute of 1, and a value of 5.T he X M L representation of a
SO AP H eader containing such an element would look like this:
<soap-env:Header>
<t:Transaction xmlns:t="some-URI" soap-env:mustUnderstand="1">
5
</t:Transaction>
</soap-env:Header>
To add such an element to the header object obtained above using the JAX M
API we could do the following:
// Use the Envelope to create a new
// namespace-qualiﬁed name.
Name elementName = soapEnvelope.createName("Transaction", "t", "some-URI");
// Add a new element to the Header
// using the name we just created.
SOAPHeaderElement headerElement = soapHeader.addHeaderElement(elementName);
// The SOAPHeaderElement interface
// provides a method for manipulating
// the mustUndertsand attribute.
headerElement.setMustUnderstand(true);
// The value is added as a text node.
headerElement.addTextNode("5");
From this code you can see the combined usage of specialist methods such as
setM ustU nderstand alongside the generic DO M  methods from the SO A P E lement
interface, such as addTextN ode.
As previously mentioned, the Envelope is also used to access the Body:
SOAPBody soapBody = soapEnvelope.getBody();
Adding elements to the Body is very similar to adding elements to the
H eader, although apart from SO AP Faults (which are a speciﬁc form of SO AP
Body Element), all of the manipulation of these elements must be directly done
through JAX M ’s DO M  implementation.
www.syngress.com

228
Chapter 6 • Writing SOAP Clients
Adding Attachments to Messages
As discussed above, attachments are optional components of SO AP messages.
T hey can essentially be of any format, but with some restrictions:
■
T hey must conform to the M IM E standards; refer to R FC 2045 at
www.ietf.org/ rfc/ rfc2045.txt for more details.T his R FC  deﬁnes,
amongst other things, how binary data is to be formatted and the 
speciﬁcation of the M IM E header.
■
T hey must contain some form of content; an empty attachment is 
not valid.
■
Each attachment must be preceded by the correct M IM E header.
In terms of the JAX M  API, attachments contain A ttachmentPart objects, which
are added to the SO A P M essage object.W hen the message is sent over the net-
work, the A ttachmentPart objects will follow the SO A P Part (which is the manda-
tory part of the message).You can add as many A ttachmentPart objects as you like
to a message, and the attachments can be of different M IM E types.
Because attachments do not come into being by default when the factory
spawns a new message, they must always be speciﬁcally created.T he following
code will add a new attachment to an existing message:
AttachmentPart attachmentPart = soapMsg.createAttachmentPart();
As already discussed, this is not yet a valid SO AP attachment because it does
not have any content or a M IM E header.
O nce the A ttachmentPart object has been created, we will have to populate its
content and M IM E header. Both of these actions can be accomplished with a call
to a single method, deﬁned as follows:
setContent(java.lang.Object object,
java.lang.String contentType)
T he object parameter represents the content, and the contentType parameter will
be used to determine how the object parameter is interpreted and to form the
variable part of the C ontent-Type M IM E header.As an example, the following
code could be used to add a plain text attachment:
String contentString
// contentString populated with some data
. . .
attachmentPart.setContent(contentString, "text/plain");
www.syngress.com

Writing SOAP Clients • Chapter 6
229
In the above example, the string contents of contentString will form the attach-
ment’s content, and it will have a single header that looks like this:
Content-Type: text/plain
For other types of content (JPEG images for example), it is a little less
obvious what form the content object should take; the solution to this will be
covered below.
T he JAX M  speciﬁcation requires that a minimum set of M IM E types be sup-
ported, and that these map directly to certain Java types. In the above example we
passed in a java.lang.String content object, along with a text/ plain content type.
T his was possible because text/ plain is one of the types that is required by the
JAX M  speciﬁcation, and also because the speciﬁcation states that this type maps
to the Java type of java.lang.String.T he full set of required M IM E types and their
corresponding Java types is listed in Table 6.10.
Table 6.10 MIME Types Required to be Implemented by the JAXM
Speciﬁcation
MIME Type
Java Type
text/plain 
java.lang.String
multipart/*
javax.mail.internet.MimeMultipart
text/xml
javax.xml.transform.Source
application/xml
javax.xml.transform.Source
T he JavaBeans Activation Framework (JAF) was developed as a standard Java
extension to enable Java programs to bind appropriate components to typed data
in much the same way as a web browser does when it automatically renders
JPEG data as an image. JAX M  relies on parts of the JAF to provide extensible
support for M IM E types, potentially providing for the use of many more types
than those listed above.
Each A ttachmentPart object contains a javax.activation.D ataH andler member,
which is typically created automatically by the call to setC ontent on the attach-
ment. It is also possible to explicitly create the D ataH andler object and assign it
using a call to setD ataH andler on the A ttachmentPart object.T he JAF ties data han-
dlers to C ommandM ap objects; a command map is essentially a list of the available
command objects registered on the system.T hrough this mechanism, additional
M IM E types can be supported. N ote that more information on the JAF can be
found at http:/ / java.sun.com/ products/ javabeans/ glasgow/ jaf.html.
www.syngress.com

230
Chapter 6 • Writing SOAP Clients
It is also possible to create an attachment of any M IM E type at all (assuming
that the service to which you are sending the attachment knows how to interpret
it) through the use of input streams.T he InputStream class and its subclasses can be
used to create objects that represent the data as bytes. R ecall from the example
above that we were able to pass a String object into the ﬁrst parameter of
setC ontent when the second parameter speciﬁed a M IM E Type of “text/ plain.” It
is also possible to pass an instance of InputStream as the ﬁrst parameter and to
specify an appropriate M IM E Type in the second parameter.As an example, a
F ileInputStream could be used to read a JPEG image ﬁle from disk and populate
an attachment:
try {
FileInputStream jpegData = 
new FileInputStream("image.jpg");
attachmentPart.setContent(FileInputStream, 
"image/jpeg");
} catch (IOException e) {
...
}
It is also possible to manually set the value of an existing C ontent-Type M IM E
H eader on an attachment by calling setC ontentType.
In terms of clearing out the contents of an A ttachmentPart object, the
clearC ontent method can be called to remove the actual data from the attachment
whil retaining the M IM E H eaders.
Bringing it all Together—
A Complete SOAP Client
In this section we will look at a real example of a SO AP client application. In the
next chapter we will cover the server side of this example, so unfortunately you
will have to wait until then to test the client.
Connecting to a SOAP service
T his example will be a simple program that takes a single parameter, a name for
which to search, and sends this to the server as a request parameter in a SO AP
message.T he server example in the next chapter will perform a search against the
example X M L ﬁle for the name, and if found return the corresponding value. If
www.syngress.com

Writing SOAP Clients • Chapter 6
231
the name is not found in the X M L ﬁle it will return a SO AP fault.T he client
will then display the returned value or fault details.
Even though this seems like a fairly simple example, it shows how readily a
web service could be implemented using JAX M  to perform any number of tasks.
Instead of looking up a value in an X M L ﬁle, it is easy to imagine a service that
registers a new subscriber or looks up and returns the time that the next bus is
due at a particular bus stop.W hatever the functionality of the service itself, the
sending and receiving of SO AP messages is a similar process.
O ne thing that should be noted at this time is that SO AP services and clients
can fall into several different categories; those that use a provider and those that do
not, and those that run within a container and those that do not.
T his example client application will neither make use of a provider nor run
in a container, and is thus known as a standalone application.T his is different to
many of the examples in this book in that it can be implemented in J2SE and
does not require any form of servlet or EJB container.T here are a couple of limi-
tations to standalone JAX M  applications (since they do not have the beneﬁt of a
provider’s functionality):
■
Standalone applications can only send point-to-point; a single message
can only be sent directly to a single service.
■
Standalone applications can only send in a request/ reply model; the
client will send a message and block until a reply is received.
■
Standalone applications cannot function as SO AP services; they can only
operate as clients.
■
Standalone applications can only communicate with a running service;
since they do not access a provider, there is no store and forward 
mechanism.
T he client will format and send a SO AP message containing a single request
parameter, the name against which the service will look up a value.T he message
will comprise several parts:
■
T he SO AP envelope, which is the enclosing object.
■
An empty SO AP header.T his is not strictly required at all in the SO AP
speciﬁcation if no header information is being transmitted; however the
JAX M  implementation always creates a header when a new message is
generated.
www.syngress.com

232
Chapter 6 • Writing SOAP Clients
■
A SO AP body.
■
Inside the body, the request parameter.T he request will be called
G etValueB yN ame, and we will specify an arbitrary namespace U R I of
www.syngress.com/ JW SD P / soap-example.A child element called name will
enclose a text element with the name itself.
T he example below requests a look up of the name M ickey:
<soap-env:Envelope xmlns:soap-
env="http://schemas.xmlsoap.org/soap/envelope/">
<soap-env:Header/>
<soap-env:Body>
<myns:GetValueByName xmlns:myns="www.syngress.com/JWSDP/soap-
example">
<name>Mickey</name>
</myns:GetValueByName>
</soap-env:Body>
</soap-env:Envelope>
T he response schema is similar, with the response being called
G etValueB yN ameR esponse.T he response to the example shown above should 
look like this:
<soap-env:Envelope xmlns:soap-
env="http://schemas.xmlsoap.org/soap/envelope/">
<soap-env:Header/>
<soap-env:Body>
<myns:GetValueByNameResponse
xmlns:myns="www.syngress.com/JWSDP/soap-example">
<value>Mouse</value>
</myns:GetValueByNameResponse>
</soap-env:Body>
</soap-env:Envelope>
T his example contains ﬁve Java source ﬁles. Because it is a standalone client
and does not require a container, you should be able to compile it in a J2SE
environment as long as you have the required libraries, which are available in
Sun’s Java Web Services Developer Pack.All of the classes have been organized
into a single package (com.syngress.jwsdp.soap.client), and can be accessed from
the Syngress Web site.
www.syngress.com

Writing SOAP Clients • Chapter 6
233
T he executable class for this example will be called C lient, in the package
com.syngress.jwsdp.soap.client.T he example will expect one (and only one) com-
mand-line parameter, which is the name that we are requesting the service to
look up. If it does not receive a single parameter, the example will report an error
and abort.
Assuming that the command-line parameter was successfully passed in, the
C lient constructor will go on to create a point-to-point connection specifying 
the service’s U R L as the endpoint.T his connection is created by using a
C onnectionF actory and also by specifying a U R L E ndpoint object constructed from 
a U R L represented as a string. In the next chapter we will examine this process
more closely and also contrast this with the process for sending messages via a
JAX M  Provider.
T he outgoing message will then be created and an attempt made to send it 
to the service. R emember that because this example is not using a provider, it 
can only send synchronously and will block until it receives a response from the
service.
O nce a response is received, it is tested for the presence of a SO AP Fault. If
fault information is found, the speciﬁcs of the fault are extracted and displayed. If
no fault information is found then the lookup has been successful and the
returned value is parsed out of the message and displayed.
/**
* Client.java
*
*/
package com.syngress.jwsdp.soap.client;
import javax.xml.messaging.URLEndpoint;
import javax.xml.soap.SOAPConnectionFactory;
import javax.xml.soap.SOAPConnection;
import javax.xml.soap.SOAPMessage;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Source;
import javax.xml.transform.stream.StreamResult;
import com.syngress.jwsdp.soap.client.Fault;
import com.syngress.jwsdp.soap.client.RequestMessage;
www.syngress.com

234
Chapter 6 • Writing SOAP Clients
public class Client {
// Deﬁne the location of the service endpoint. 
// This will be determined by where you deploy 
// the servlet that will be developed in the 
// example in the next chapter.
static ﬁnal String SERVICE_ENDPOINT = 
"http://localhost:8888/Chapter8/servlet/chapter8.ReceiverServlet";
public static void main(String args[]) {
// We are expecting a single
// command line argument; the
// name to look up.
if (1 != args.length) {
System.err.println(
"Usage: java " +
"com.syngress.jwsdp.soap.client.Client <name>");
} else {
new Client(args[0]);
}
}
public Client(String name) {
try {
// For a standalone client we need
// to specify the URL of the
// service.         
URLEndpoint endpoint = 
new URLEndpoint(
SERVICE_ENDPOINT);
// A standalone client does not
// use a provider; create a 
www.syngress.com

Writing SOAP Clients • Chapter 6
235
// connection from a connection
// factory.         
SOAPConnectionFactory scf = 
SOAPConnectionFactory.
newInstance();
SOAPConnection connection = 
scf.createConnection();
// Create the request message using
// the command line parameter as
// the name to look up.
RequestMessage reqMsg =
new RequestMessage();
reqMsg.setName(name);
// The call method will block
// until something is returned
// from the service.
SOAPMessage replySOAP = 
connection.call(
reqMsg.getMessage(),
endpoint);
// Test for the presence of
// fault information in the
// response.
if (Fault.hasFault(replySOAP)) {
// Fault information exists,
// indicating an error
// response from the service.
Fault fault = 
new Fault(replySOAP);
System.err.println(
"Received SOAP Fault");
System.err.println(
www.syngress.com

236
Chapter 6 • Writing SOAP Clients
"Fault code: " + 
fault.getFaultCode());
System.err.println(
"Fault string: " + 
fault.getFaultString());
System.err.println(
"Fault detail: " + 
fault.getFaultDetail());
} else {
ResponseMessage respMsg = new ResponseMessage(replySOAP);
String responseValue = null;
try {
responseValue = respMsg.getValue();
System.out.println("Response: " + responseValue);
} catch(SchemaException e) {
System.err.println("Parsing error");
}
}
connection.close();
} catch(Exception e) {
System.err.println(e.toString());
}
}
}
T he outgoing SO AP message is constructed in the com.syngress.jwsdp.soap
.client.R equestM essage class.T his example is a standalone client (making use of nei-
ther a J2EE container nor a JAX M  provider), and therefore it will create messages
using the default message factory.
O nce the SO AP message is created, we need to add the request parameter to
the Body. If we were performing a lookup against the name M ickey, the following
content needs to be added to the Body:
www.syngress.com

Writing SOAP Clients • Chapter 6
237
<myns:GetValueByName xmlns:myns="www.syngress.com/JWSDP/soap-example">
<name>Mickey</name>
</myns:GetValueByName>
To add this content to the body using the JAX M  DO M  implementation,
perform the following steps:
1.
Add a new child element to the SO A P B ody object with a 
name of G etValueB yN ame, a preﬁx of myns, and a U R I of 
www.syngress.com/ JW SD P / soap-example.
2.
Add a new child element to the element just added, with a local name
of “name”.
3.
To that child element, add a text node with a value of M ickey.
/**
* RequestMessage.java
*
*/
package com.syngress.jwsdp.soap.client;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPElement;
import javax.xml.soap.SOAPException;
public class RequestMessage {
// class to represent an outgoing
// SOAP message that will request
// a lookup of a value by a name.
protected SOAPMessage soapMessage = null;
public RequestMessage()
www.syngress.com

238
Chapter 6 • Writing SOAP Clients
throws SOAPException {
MessageFactory mf = 
MessageFactory.newInstance();
// Because a standalone client does not
// use a provider, the message is created
// from the message factory.
soapMessage = mf.createMessage();
}
public void setName(String name)
throws SOAPException {
// Set the request paramaeter; this
// represents the name that we will
// be requesting the service to look up.
// Traverse the hierarchy of SOAP
// objects to obtain the body.
SOAPPart soapPart = 
soapMessage.getSOAPPart();
SOAPEnvelope envelope = 
soapPart.getEnvelope();
SOAPBody body = 
envelope.getBody();
// Add the request element to the body,
// using a namespace-qualiﬁed name.
SOAPElement requestElement;
requestElement = body.addChildElement(
envelope.createName(
"GetValueByName",
"myns",
"www.syngress.com/JWSDP/soap-example"));
www.syngress.com

Writing SOAP Clients • Chapter 6
239
// The value of the name to look up
// is added as a text node as a child of the
// request element using a local name.
SOAPElement paramElement;
paramElement = 
requestElement.addChildElement("name");
paramElement.addTextNode(name);
}
public SOAPMessage getMessage() {
// Get the SOAP message
return soapMessage;
}
}
A result containing a valid response is processed in the com.syngress.jwsdp.soap
.client.R esponseM essage class.T he getValue method of this class will validate that the
received message adheres to the expected schema, and if it does so it will extract
the value returned from the service.
/**
* ResponseMessage.java
*
*/
package com.syngress.jwsdp.soap.client;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPElement;
import javax.xml.soap.Name;
import java.util.Iterator;
import com.syngress.jwsdp.soap.client.SchemaException;
www.syngress.com

240
Chapter 6 • Writing SOAP Clients
public class ResponseMessage {
// Represents a SOAP message received
// as a response from a service.
protected SOAPMessage soapMessage = null;
public ResponseMessage(SOAPMessage soapMessage) {
this.soapMessage = soapMessage;
}
public String getValue()
throws SchemaException,
SOAPException {
// Get the value returned for
// the request.
String resp = null;
// Navigate the hierarchy
// of SOAP objects to
// access the body.
SOAPPart soapPart = 
soapMessage.getSOAPPart();
SOAPEnvelope soapEnvelope = 
soapPart.getEnvelope();
SOAPBody soapBody = 
soapEnvelope.getBody();
// Search for the namespace-qualiﬁed
// response element.
Name name;
name = soapEnvelope.createName(
"GetValueByNameResponse",
"myns",
"www.syngress.com/JWSDP/soap-example");
www.syngress.com

Writing SOAP Clients • Chapter 6
241
// Ensure there is at least one
// such element.
Iterator valueRequests = 
soapBody.getChildElements(name);
if (! valueRequests.hasNext()) {
// Schema is not valid
throw(new SchemaException());
}
// Retrieve the ﬁrst element
// and ensure it was the only
// one.
SOAPElement soapElement = 
(SOAPElement)valueRequests.next();
if (valueRequests.hasNext()) {
// Schema is not valid
throw(new SchemaException());
}
// The value should be in a 
// child element of this one, with
// a local name of "value".
name = soapEnvelope.createName("value");
Iterator params;
params = soapElement.getChildElements(name);
if (! params.hasNext()) {
// Schema is not valid
throw(new SchemaException());
}
// Ensure there is only one such element.
SOAPElement paramElement = 
(SOAPElement)params.next();
if (params.hasNext()) {
www.syngress.com

242
Chapter 6 • Writing SOAP Clients
// Schema is not valid
throw(new SchemaException());
}
// Extract the parameter.
resp = paramElement.
getValue();
if (null == resp) {
// Schema is not valid
throw(new SchemaException());
}
// Schema was successfully validated
// and the response parameter can
// be returned.
return resp;
}   
}
T he method getR esponseValue() throws the exception SchemaE xception.T his
exception is used to represent an error in parsing the incoming message— the
message did not comply with the expected schema:
/**
* SchemaException.java
*
*/
package com.syngress.jwsdp.soap.client;
public class SchemaException extends Exception {
// This exception is used to
// indicate that the XML being
// parsed did not conform to
// the appropriate schema.
}
www.syngress.com

Writing SOAP Clients • Chapter 6
243
O n the other hand, messages containing a fault will be processed by the
com.syngress.jwsdp.soap.client.F ault class.You will recall that the SO AP speciﬁcation
requires that error information be transmitted within a SO AP Fault, which is an
optional child envelope in a SO AP Envelope.A SO AP Fault is implemented by
the JAX M  API as an SO A P F ault object, which is obtained by calling the getF ault
method of the body object; this method will not throw an exception if there is no
fault information present, but will rather return a null.
T he F ault class listed below includes the static hasF ault method that is called
ﬁrst with the received message as the parameter. If this returns true we know the
message is carrying fault information and we should construct a F ault object,
then query it using the getF aultC ode, getF aultString, and getF aultD etail methods to
return the fault code, fault string, and possibly the fault detail— if one exists.A
SO AP Fault can carry a number of detail records; for the sake of this sample we
can assume that the service will never return more than one.Also, a SO AP Fault
will not carry a detail unless the error resulted from the processing of the mes-
sage’s B ody element.
/**
* Fault.java
*
*/
package com.syngress.jwsdp.soap.client;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPFault;
import javax.xml.soap.SOAPException;
import javax.xml.soap.Detail;
import javax.xml.soap.DetailEntry;
import java.util.Iterator;
public class Fault {
// Fault class should usually be
// instantiated only if the message
www.syngress.com

244
Chapter 6 • Writing SOAP Clients
// contains fault information; use
// Fault.hasFault to test for this.
protected SOAPFault soapFault;
public Fault(SOAPMessage msg)
throws SOAPException {
// Navigate the hierarchy of
// SOAP objects to store
// a reference to the fault objects
// as it is commonly used within the class.
SOAPPart soapPart = msg.getSOAPPart();
SOAPEnvelope soapEnvelope = 
soapPart.getEnvelope();
SOAPBody soapBody = soapEnvelope.getBody();
soapFault = soapBody.getFault();
}
public static boolean hasFault(SOAPMessage msg)
throws SOAPException {
// Static utility function to determine
// whether a SOAP message contains
// fault information.
// Navigate the hierarchy of
// SOAP objects.
SOAPPart soapPart = msg.getSOAPPart();
SOAPEnvelope soapEnvelope = 
soapPart.getEnvelope();
SOAPBody soapBody = soapEnvelope.getBody();
// Query whether the Body contains
// a SOAP Fault.
return soapBody.hasFault();
www.syngress.com

Writing SOAP Clients • Chapter 6
245
}
public String getFaultCode() {
// Get the SOAP fault code
return soapFault.getFaultCode();
}
public String getFaultString() {
// Get the SOAP fault string
return soapFault.getFaultString();
}
public String getFaultDetail() {
// Get the SOAP fault detail.
String ret = null;
Detail detail = soapFault.getDetail();
if (null != detail) {
Iterator it = 
detail.getDetailEntries();
// A fault can contain 
// multiple detail entries.
// For the sake of the example,
// assume there is a maximum of
// one detail entry.
if (it.hasNext()) {
DetailEntry detEntry = 
(DetailEntry)it.next();
ret = detEntry.getValue();
}
}
www.syngress.com

246
Chapter 6 • Writing SOAP Clients
return ret;
}
}
Since this example is a standalone JAX M  client that adheres to the request/
reply model, you will not be able to run it until the service is running.T he ser-
vice will be covered in the next chapter, and once it is running you can run the
client by executing:
java com.syngress.jwsdp.soap.client.Client <name>
Figure 6.4 shows the output from a successful execution; the client sent a
request to the service to look up M ickey and the service responded with M ouse.
O n the other hand, Figure 6.5 shows the results when a request is made to
look up a name that cannot be found by the service; the client sent a request for
D onald, and the service returned a SO AP Fault in its response.
www.syngress.com
Figure 6.4 A Successful Execution of the Client

Writing SOAP Clients • Chapter 6
247
www.syngress.com
Figure 6.5 SOAP Fault Returned from the Service
Standalone JAXM Applications
One of the great advantages to building a standalone JAXM application,
like the example developed in this chapter, is the simplicity of debug-
ging. Because the application communicates synchronously by making a
request and then waiting for a response message, issues such as trying
to match up an incoming message with an outgoing request or debug-
ging multiple threads do not need to be taken into account.
To debug the example from this chapter, you should be able to set
a breakpoint at any appropriate point in Client.java and start the
debugger. Just make sure that you conﬁgure the debugger to pass in the
desired command-line parameter (specifying the name to send in the
request), and make sure that the IDE is conﬁgured to use the libraries
distributed with the Java Web Services Developer Pack.
Debugging…

248
Chapter 6 • Writing SOAP Clients
Summary
In this chapter we covered an overview of SO AP, as well as looking in detail at
how SO AP client applications can be developed using the JAX M  API.We also
developed a complete SO AP client application that communicates using the
request-response model.
SO AP is an X M L-based protocol that enjoys widespread industry support
and that can enable information to be exchanged among distributed systems.
Even though SO AP is X M L-based, there is an additional speciﬁcation that allows
SO AP messages to contain attachments in a wide variety of formats including
X M L, plain text, or audio, picture, or video content.
JAX M , the Java API for X M L M essaging, provides a uniﬁed API for creating
either standard SO AP M essages or SO AP M essages with Attachments. JAX M
provides an independent implementation of an X M L document object model,
which differs from that used by JAX P while maintaining similar capabilities.T he
API also provides a set of Java types that map directly to the elements of a SO AP
message.
If a SO AP client does not use a container, it is known as a standalone applica-
tion and it must communicate with a service synchronously (request/ reply).We
have explored an example of such an application, one that formats a request mes-
sage and sends it to a service, then waits for a response.T he response is decoded
and either the returned value is displayed or any SO AP Fault information is
extracted and displayed. In the next chapter we will cover an example service
that can be used in conjunction with the client application.
Solutions Fast Track
U nderstanding SO AP
 SO AP is a lightweight X M L-based protocol for information exchange
among systems in a distributed environment.
 It is possible for SO AP to be used with many protocols (including
T C P/ IP), although its most common binding is with H T T P.
 Because of the lightweight nature of the SO AP protocol, it does not
include a number of features found in some of the more complex
distributed technologies.
www.syngress.com

Writing SOAP Clients • Chapter 6
249
 T here is another speciﬁcation known as SO A P  M essages with A ttachments,
which enables SO AP messages to be carried within M IM E multipart/
related messages and thus carry attachments in a similar way to email.
SO APElement and JAX M  DO M
 JAX M  provides its own DO M  implementation that is independent of
the org.w3c.dom speciﬁcation used by JAX P.
 T he SO A P E lement interface represents an X M L element within a
document and provides all of the methods required to manipulate such
an element.
 All JAX M  interfaces that represent elements of a SO AP message are
subtypes of the SO A P E lement interface.
JAX M  SO AP Elements
 JAX M  provides several interfaces, such as SO A P M essage and SO A P Part,
to represent a SO AP M essage that may or may not contain an
attachment, as well as the actual SO AP part of such a message.
 O ther elements, such as SO A P E nvelope, SO A P H eader, SO A P B ody and
the like, map directly to objects within the SO AP speciﬁcation and can
be manipulated via methods of the SO A P E lement interface, as well as by
some additional methods for speciﬁc functions.
 JAX M  provides M IM E functionality for adding and processing attach-
ments through the use of the JavaBeans Activation Framework (JAF).
C reating a SO AP M essage
 A SO A P M essage object needs to be created through a factory object, and
the other elements can each be created by their parent elements.
 W hen an SO A P M essage object is created, it will contain an Envelope
with an empty H eader and a Body.
www.syngress.com

250
Chapter 6 • Writing SOAP Clients
Bringing it all Together— A C omplete SO AP C lient
 T he example client was created to run independently of a JAX M
Provider or a container. Such a standalone client can only communicate
using a synchronous request/ reply model.
 T he client application creates a new SO AP message requesting a value
lookup against a command line-speciﬁed name, and waits to process the
response from the server.
 T he server-side of the example will be covered in the next chapter.
Q: Is SO AP speciﬁc to any particular vendor, platform, or programming language?
A: T he answer to all of these is “N o.” SO AP enjoys the support of a very wide
array of vendors, including Sun, M icrosoft, IBM , O racle, and many more.
Additionally, any mainstream programming language could be used to imple-
ment SO AP communications. Implementations are available for such a diverse
set of languages as Java, C ++, Perl, Python,ADA,Visual Basic, and more.
Q: Does SO AP provide a security model?
A: T he SO AP speciﬁcation provides very little in the way of security considera-
tions, but this does not mean that SO AP communications are inherently inse-
cure. If SO AP is bound to H T T P, the same potential security vulnerabilities
exist as with most other H T T P communications, but likewise the same secu-
rity mechanisms (such as the use of Secure Sockets Layer, or SSL) can be used.
Q: Does SO AP have to operate over H T T P?
A: N o, it is not mandatory for SO AP to be bound to H T T P; a SO AP message
could readily be transmitted over SM T P or even a proprietary middleware
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

Writing SOAP Clients • Chapter 6
251
protocol such as IBM ’s M Q  Series. H owever, this would be dependant upon
the ability for your JAX M  Provider to support these bindings.
Q: Are there any SO AP mailing lists?
A: Yes, there are several; a good one is at http:/ / discuss.develop.com/ soap.html
Q: Are there any tools available to test SO AP services?
A: An organization called PushToTest publishes a free open-source framework
called TestM aker, as well as a commercial product.T heir website is at
www.pushtotest.com
Q: W here can I ﬁnd more detailed information on securing SO AP 
communications?
A: T he IBM  developerWorks site contains a very detailed article at 
www-106.ibm.com/ developerworks/ webservices/ library/ ws-soapsec/
www.syngress.com


Writing SOAP
Servers
Solutions in this chapter:
■
Message Routing
■
Establishing a Connection to a JAXM
Provider
■
ProviderConnections
■
Writing a SOAP Server Servlet
■
Writing a SOAP EJB
■
Example SOAP Servlet
Chapter 7
253
 Summary
 Solutions Fast Track
 Frequently Asked Questions

254
Chapter 7 • Writing SOAP Servers
Introduction
Just as the last chapter looked at standalone SO AP clients, this chapter will
explore hosted SO AP servers.You may recall we talked about the synchronous
request-response model being the only model supported for standalone servers;
this is because JAX M  leverages a Java 2 Enterprise Edition (J2EE) container
when routing messages for the more complicated SO AP usages. In particular,
JAX M  supports the routing of messages to message-driven EJBs and servlets.
In the JAX M  model, the J2EE container has the additional responsibility of
either being or hosting a SO AP Provider. SO AP providers form the underlying
infrastructure for the routing of messages from remote clients to the message
responder.T hey also provide for routing messages from the message responder to
a different remote host; in this way J2EE-based SO AP servers can also act as
SO AP clients.
In this chapter, we are going to explore the hosted SO AP environment,
including connections to JAX M  providers. Further, we will discuss imposing a
standard set of body and header elements on a SO AP message. K nown in JAX M
as a proﬁle, this allows for an explicit contract between a client and server without
which there is no guarantee that a SO AP message would contain meaningful data
in well-known locations. Proﬁles simplify the use of higher-level protocols such
as ebX M L; the proﬁle acts to make sure that meaningful information is provided
in a manner that is clear to both parties.
Message Routing
In the last chapter we focused on synchronous message routing (known as request-
response), where the client sent a request message and blocked until some form of
response came back from the service.We also saw that this request-response
model was the only model supported for a standalone client (a JAX M  SO AP
client that did not run in an EJB or servlet container). In this section we will
examine another model for SO AP communication using JAX M — asynchronous
messaging.We will discuss the advantages of using an asynchronous message
model, such as the ability to obtain guaranteed delivery and delayed responses;
and we will also look at some of the complexities in the development of systems
that implement this model.
www.syngress.com

www.syngress.com
Asynchronous messages
In terms of the actual SO AP speciﬁcation, asynchronous SO AP messages are the
more basic case; the fundamental mechanism for communicating via SO AP is
one-way messaging, in which one system sends a message to another system
without waiting for a response.T here is nothing to say that an asynchronous
system cannot include responses to messages; it is just that the sender is not
reliant on an immediate response.
Figure 7.1 shows an example of a synchronous messaging system.T he
example shows a very familiar scenario: a web browser requesting a web page. In
this scenario, the browser submits an H T T P request to the web server, requesting
a speciﬁc H T M L page. O nce it has sent the request, the browser then waits until
one of three things happens:
■
It receives the H T T P response containing the H T M L data.
■
It receives an error, which could come from a number of sources, such
as the web server or a proxy server.
■
T he request times out.
An example of an asynchronous messaging system is shown in Figure 7.2.
T his example should also be a very familiar scenario; Dave sends an e-mail to
Writing SOAP Servers • Chapter 7
255
Figure 7.1 Example of Synchronous Messaging
Web Browser
Web Server
HTTP
Request
Response
containing
HTML Page

256
Chapter 7 • Writing SOAP Servers
Jean, asking if she’d like to meet for lunch. Jean is away from her computer for a
few days and doesn’t get to read the e-mail until the following week. During this
time Dave (unless he is very anxious about the response to the e-mail) does not
sit waiting for the response; he and his e-mail software are both free to do other
things. Finally, Jean reads the e-mail and decides to send a response to Dave; yes,
she would like to meet for lunch next Tuesday.
Asynchronous SO AP messaging can be quite similar to e-mail messaging (and
in fact it is possible to use SM T P as a bearer for SO AP messages).T he similarities
are that messages are sent via a store-and-forward mechanism (such as a JAX M
provider) and that the sender does not halt all other processing while it waits for
a response.T his clearly provides a number of advantages but also raises a few hur-
dles that will be discussed in the following section.
O ne-Way M essages
T he simplest case of asynchronous messaging involves one-way messages. In this
model, a system sends a message to another system— end of story.T here is no
expectation of a response, and no response will ever be sent.
You may wonder when a real-life scenario would work in this way. In fact, it’s
quite a common scenario, especially in terms of alerting and notiﬁcation. Imagine
a C R M  (C ustomer R elationship M anagement) system that is used to collect and
maintain information about the customers of an electricity company. If a cus-
tomer rings up and asks for their address to be changed, we may want the C R M
system to automatically notify the billing system of the change so that the cus-
tomer’s bills will be printed out with the correct address.T his notiﬁcation could
www.syngress.com
Figure 7.2 Example of Asynchronous Messaging
Dave sends an email
J ean may respond at
some point in the future

Writing SOAP Servers • Chapter 7
257
certainly be done using a one-way SO AP message, and since we can rely on our
JAX M  provider to deliver the message, there is no need to expect any kind of
response from the billing system.
T his kind of example (where applications exchange data within an enterprise)
is known as Enterprise Application Integration (EAI), and is increasingly
becoming known as A2A (Application to Application) communication.T his is
deﬁnitely an area in which Web Services will be seen to play an increasing role in
the near future.
Delayed R esponse M essages
N ot all asynchronous messaging is truly one-way.T here are many cases where
asynchronous messaging involves sending a message and possibly receiving a
response; this response may come almost immediately or after a very long delay,
so under the asynchronous model we will not pause other processing while we
wait for it.
C onsider the case of an electronic marketplace, where a buyer submits an
order to purchase 300 pencils.After a certain amount of time, the marketplace
receives a message from the pencil supplier agreeing to fulﬁll the order, and later
a message is received that says the supplier has shipped the order.At this point the
marketplace may have to transfer funds between buyer and supplier and update
the status of the order.
N ow consider that there could be many thousands of buyers and suppliers all
active in submitting and fulﬁlling orders, and that the delay between the submis-
sion of an order and its fulﬁllment could extend into weeks. It is very clear that
asynchronous messaging is required; the marketplace could not afford to cease
functioning for days or weeks while it waited for a response to any given message.
O n the other hand, the messages are clearly not one-way; a fulﬁllment message is a
speciﬁc response to an order request message— but it is a delayed response.
A major difference in the implementation of these two models lies in how
they wait for responses. In the synchronous case, the client sends a message and
then waits for a response on the same connection— the understanding is that the
only possible returning message will be the response to the request.
T he difference with the asynchronous case is that it is essentially always
expecting messages, but when a message arrives it must match it up with the 
corresponding sent message.
Another major difference between the implementation of the two models lies
in the routing of messages.T his is readily explained through an analogy with
www.syngress.com

258
Chapter 7 • Writing SOAP Servers
some common interpersonal communication technologies: telephone and e-mail.
If you think about using a telephone, you dial somebody’s number and, if they
are available at the time, they will answer the phone and a conversation begins—
this is similar to the synchronous case.
O n the other hand, if you send your friend an e-mail, it will be delivered to a
mail server; the next time your friend runs their mail client, the message will be
routed to them (probably via either the PO P or IM AP protocol), and they will
be free to respond to the message at their leisure. It is the existence of the mail
server that allows e-mail to work asynchronously; without the mail server, you
could only send e-mails to your friend at times when he or she was online.
Asynchronous SO AP messages require a very similar mechanism; for messages
to be truly asynchronous there must be a routing mechanism receiving messages
and then routing them to the message handler when the handler becomes avail-
able.T his mechanism is the J2EE container, with its implementation of a JAX M
Provider.
State in Asynchronous Servers
In the e-mail example from Figure 7.2, Dave sent an e-mail and received a
response after several days. In this example, when a response ﬁnally came back
from Jean accepting Dave’s invitation, Dave remembered that he had sent Jean 
an e-mail inviting her to lunch. In the interim, Dave may have received many 
e-mails from other people including a certain number of unsolicited advertising
e-mails (or Spam), but when he received Jean’s e-mail he knew its context— that
it was a response to an earlier request he had sent her.
In this case, Dave has the ability to mentally store “state” about various mes-
sages he has sent and to which he is expecting responses, so that when he
receives various responses he remembers that he was expecting them. Likewise, if
he doesn’t receive a message from Jean within a week he may decide to take
some other action— send Jean a reminder e-mail, or perhaps try phoning her.
T he developer of an asynchronous messaging system will have to implement
certain abilities that are similar to what Dave is doing mentally; that is, to have a
record of state so that the context of incoming messages is known, and perhaps to
trigger a timeout condition (such as sending a followup message) if an expected
response has not been received after a certain amount of time.
In practice, how do you go about implementing this? T here are a multitude
of possibilities; some are good ideas, and some are probably not. For instance, for
every message that was sent out it would be possible to spawn a thread (a con-
current unit of process execution) that could wait for the corresponding reply
www.syngress.com

Writing SOAP Servers • Chapter 7
259
and perhaps handle the timeout condition if it did not receive the reply within a
certain timeframe. H owever, unless there were very few messages ever sent out,
the resource overheads of so many threads being created would be prohibitively
inefﬁcient.
A better method would be to implement a session mechanism in much the
same way as many web servers do. In the web server example, an identiﬁer is
passed to the server with each page request; either in the form of a cookie or
embedded as a U R L parameter. Either way, the web server can recognize the
unique identiﬁer and match the request to the browser instance.T he web server
stores the state of each current session either in memory or in a persistent
database, and can tell certain things about the incoming requests. For example, a
request to display a shopping cart page is coming from a user who is logged into
the site and has three items in his or her shopping cart. O nce a session has timed
out (there have been no page requests from that browser instance for a certain
amount of time), its session data may be removed from memory.
Storing session state in an asynchronous messaging system can be done in a
similar manner, although the identiﬁer would generally be associated with a mes-
sage rather than a user.T his identiﬁer may be an order identiﬁer, for example.
Picture again the electronic marketplace scenario; for each order request sent to a
supplier, an entry with that order number could be inserted into the database.
W hen a fulﬁllment message is received, it could be matched against the appro-
priate request and acted on accordingly. If a fulﬁllment message is received that
does not match any known order request, an alert is raised for manual investiga-
tion.A background task could likewise run periodically to scan the database for
order requests that have not been matched with a fulﬁllment message within a
certain timeframe, and raise alerts for appropriate action to be taken.
Message Routing
As well as having to cope with storing state, asynchronous messaging systems also
need to manage the routing of messages.T his effectively means delivering the
messages to their ﬁnal destination, possibly via a number of intermediate destina-
tions. In this section we will discuss the main message routing scenarios and how
they may be implemented in a system that uses JAX M .
Figure 7.3 shows a fairly simplistic view of the message routing scenario for a
synchronous JAX M  request-response scenario. It is simplistic in the sense that it
does not include the container in which the server is running— this is because
the container is fairly transparent to the solution. In a scenario such as this, the
www.syngress.com

260
Chapter 7 • Writing SOAP Servers
client directly speciﬁes the server’s U R L when sending the request and the server
returns the response message to the client in the same connection; the message
cannot be routed elsewhere.
In contrast, Figure 7.4 shows a similar form of diagram, this time describing
the minimum message routing required for delivery of an asynchronous message
from a client to a server when both client and server are running JAX M
Providers.You can see from this diagram that there are at least three levels of
routing involved:
■
T he message must be routed from the client to its provider.
■
T he sending provider must know how to deliver the message to the
receiving provider.
■
T he receiving provider must in turn know how to route the message to
the server application.
Incoming M essage R outing
JAX M  Servers (that is, consumers of incoming messages) may be implemented as
either EJBs or servlets, although they are restricted to being implemented as
servlets  under the current release of the JAX M  R eference Implementation and
most commercial containers.As we will cover in more detail, they will still imple-
ment the same listener interfaces regardless of whether they are implemented as
servlets or EJBs:
www.syngress.com
Figure 7.3 Message Routing for a Synchronous Message
Synchronous
Client
Synchronous
Server
Request
Message
Response
Message
Figure 7.4 Message Routing for an Asynchronous Message
Asynchronous
Client
Asynchronous
Server
J AXM
Provider
J AXM
Provider

Writing SOAP Servers • Chapter 7
261
■
For asynchronous servers using a Provider (EJB or servlet), they will
implement O neW ayL istener.
■
For synchronous servers not using a Provider (servlet only), they will
implement R eqR espL istener.
Both of these listener interfaces deﬁne an onM essage method; the version in
O neW ayL istner has a void return value, whereas the version in R eqR espL istener
must return a message that will be routed back to the client.
In the case of the synchronous scenario (where the servlet implements
R eqR espL istener), the incoming message routing is quite straightforward: the client
will address the message directly to the U R L of the deployed servlet, and the
servlet container will route the message to the onM essage method. Likewise the
return value from this method will be returned directly to the calling client.
In the case of the asynchronous scenario (where either a servlet or EJB imple-
ments O neW ayL istener), things work a little differently. In this case, the sending
Provider will have delivered the message to the server’s JAX M  Provider.T his
Provider has to know the servlet (or EJB) to which the message must be routed.
T his routing from the incoming Provider to the actual server application is
achieved because of registration information that every client of a JAX M
provider must provide at deployment time. N ote here that a Provider’s “client”
could be either a client or a server in the SO AP scenarios discussed above;
whether it sends, receives or both, it is a client of the Provider.
Take for example the “R emote” sample that is deployed as part of the Java
Web Services Developer Pack from Sun.T his sample does a round-trip send (and
asynchronous response) using the ebX M L proﬁle. If you examine the copy of
client.xml that is deployed with this sample you should see that it looks as follows:
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE ClientConﬁg
PUBLIC "-//Sun Microsystems, Inc.//DTD JAXM Client//EN"
"http://java.sun.com/xml/dtds/jaxm_client_1_0.dtd">
<ClientConﬁg>
<Endpoint>
http://www.wombats.com/remote/sender
</Endpoint>
<CallbackURL>
http://localhost:8080/jaxm-remote/receiver
www.syngress.com

262
Chapter 7 • Writing SOAP Servers
</CallbackURL>
<Provider>
<URI>http://java.sun.com/xml/jaxm/provider</URI>
<URL>http://127.0.0.1:8081/jaxm-provider/sender</URL>
</Provider>
</ClientConﬁg>
Every application that makes use of a JAX M  Provider must provide a
client.xml instance in its deployment; this ﬁle may either be created manually or
your development environment may automate its creation— either way, the ﬁle
will contain the same content.
You can see that the client conﬁguration provides three distinct pieces of
information:
■
An endpoint, expressed as a U R I.
■
A callback U R L, which in this case is the U R L of the servlet.
■
Provider information as a U R I and U R L.
It is this information that the provider uses to route the incoming asyn-
chronous message: the message will have been addressed to a speciﬁc U R I as a
destination; the Provider will then map that U R I to the corresponding callback
U R L and ensure that the message is routed to the server’s onM essage method.
O utgoing M essage R outing
For messages outgoing via a JAX M  Provider, a store-and-forward mechanism is
used.T his means that the message will be somehow logged (stored) and then
delivered (forwarded) to the destination party.T his is similar to mailing a letter;
you place the letter in the post box and assume that the postal service will deliver
it to its destination. In a similar way, an application can deposit the message with
the Provider and trust the Provider to deliver it.
M ost commercial JAX M  implementations should implement the concept of
guaranteed delivery; that is, the message will eventually be delivered to its destina-
tion, regardless of how long it takes. So if the delivery fails many times due to a
serious problem with a communications link, the Provider will continue to retry
delivery until it is successful. Likewise, even if the server on which the Provider is
running is rebooted, the message will be stored in some form of reliable persis-
tent storage; attempts to deliver the message will resume once the server is up
and running again.
www.syngress.com

Writing SOAP Servers • Chapter 7
263
T he JAX M  R eference Implementation provides some of this functionality, but
stops short of providing guaranteed delivery.As you can see from Figure 7.5, the
reference implementation provides an application for conﬁguring the JAX M
Provider, and that the conﬁgurable parameters instantly give away several secrets
about the implementation. First, you can see that there is a limited number of
retries; this could be set to higher than 3, but eventually if a message cannot be
delivered the Provider will give up trying.T he second indication that delivery may
not be guaranteed is that the messages are stored in a log ﬁle on the ﬁle system.
W hile information stored this way will likely survive a reboot (and the Provider
will continue attempting to resend messages after such an incident), ﬁles on the ﬁle
system are much less reliable than using something like the R elational Database
M anagement System (R DBM S) used in many commercial implementations.
Establishing a Connection 
to a JAXM Provider
T he JAX M  Provider will typically be distributed as part of the J2EE container
with which you are working; it is up to the vendor to determine how the
Provider will be implemented. Generally, the JAX M  Provider will be imple-
mented as a servlet, although the implementation of the store-and-forward mech-
anisms will vary greatly. For example, the Provider reference implementation
www.syngress.com
Figure 7.5 Conﬁguring the JAXM Provider Properties in the Reference
Implementation

264
Chapter 7 • Writing SOAP Servers
stores messages in a logﬁle directory whereas commercial implementations may
well use R DBM S-based queuing mechanisms and accordingly enjoy a higher
level of reliability. R egardless of the JAX M  Provider implementation however,
you will still use the JAX M  API to establish a connection and make use of its
services.
T he JAX M  Provider is not only responsible for routing inbound messages to
your SO AP server, but is also responsible for routing outbound messages to their
destinations.Your application essentially hands the message over to the Provider,
which then ensures that the message is delivered, retrying the delivery until suc-
cessful.
T he basic steps for sending a message via a Provider are:
1.
R etrieve a provider connection factory as registered with a JN DI
naming service.
2.
U se the factory to generate a connection with the JAX M  Provider.
3.
U se the connection to generate a message factory.
4.
U se the message factory to generate a message, specifying a proﬁle.
5.
Populate the message.
6.
U se the connection with the JAX M  Provider to send the message; this
will send asynchronously and will not wait for a response.
J2EE introduced the concept of the naming service based on the Java
N aming and Directory Interface (JN DI) API.A naming service is a form of
repository or directory that, among other things, allows various objects to be reg-
istered by name so that applications can look them up through the service and
make use of them.A common use of such naming services is the registration of
EJBs; this is the mechanism through which an application can access a bean.
Similar to the EJB case, JAX M  Providers are registered using a unique name.
Your application can then look up the Provider, using the JN DI API and pro-
viding the exact name with which the Provider was registered; thus retrieving a
P roviderC onnectionF actory object that can be used to connect to the Provider in
question.
T herefore, the ﬁrst requirement in this scenario is that the name of the
Provider must be well known to the system that registers the Provider (probably
the J2EE container) and to any applications that require connections to the
Provider.T he vendor may dictate this name, or it may be conﬁgurable as a prop-
erty in the container’s conﬁguration ﬁles.
www.syngress.com

Writing SOAP Servers • Chapter 7
265
As mentioned above, you will need to use the JN DI API to look up the
provider.T his is done in two steps: a C ontext object is created, then the lookup
method of that object is called, passing in the Provider’s name.T his will return a
P roviderC onnectionF actory object, as shown in the following code:
Context context = new InitialContext();
ProviderConnectionFactory factory;
factory = (ProviderConnectionFactory)context.lookup("MyProvider");
It is actually possible to obtain a P roviderC onnectionF actory without using a
naming service lookup (and therefore without using the JN DI API); this is the
www.syngress.com
Deploying Provider Clients
In a somewhat confusing mix of terminology, a JAXM Provider’s “client”
may operate as either client or a server (or both) in a SOAP implemen-
tation.
Clients of Providers must not only be deployed with the usual
descriptor ﬁles required by servlet containers, but also with additional
deployment information contained in a ﬁle named “client.xml.”
Under the JAXM Reference Implementation, this XML descriptor ﬁle
must be manually created and included in the WAR ﬁle when the client
is deployed. Commercial implementations will most likely include tools
for automating the generation of these descriptors.
The XML ﬁle must adhere to a schema that is deﬁned in jaxm-
client.dtd and contains the following information:
■
Endpoint A string identifying the client as a URI.
■
CallbackURL This is used by the JAXM Provider to route
received messages to the client. The received message will be
addressed to a URI; the Provider will compare that URI to the
registered Endpoint of each client and route the message to
the CallbackURL of the matching client, retrying the delivery
until successful.
■
Provider’s URI and URL Used by the client to obtain a con-
nection to the Provider. 
Developing & Deploying…

266
Chapter 7 • Writing SOAP Servers
case where the default factory is used by calling the P roviderC onnectionF actory’s
static newInstance method, as shown in this code fragment:
ProviderConnectionFactory factory = ProviderConnectionFactory.newInstance();
T he factory that is returned from this call will generate connections to the
default Provider conﬁguration.
C reating the connection to the JAX M  Provider from the factory object is
very straightforward using the factory’s createC onnection method, as the following
code demonstrates:
ProviderConnection connection;
connection = factory.createConnection();
ProviderConnections
P roviderC onnection objects essentially perform three different tasks:
1.
Allow information (meta data) about the Provider to be queried.
2.
Provide M essageF actory objects that can produce messages speciﬁc to a
certain proﬁle.
3.
Pass messages to the Provider to be sent asynchronously.
Table 7.1 describes the four methods deﬁned in the P roviderC onnection
interface:
Table 7.1 ProviderConnection Methods
Method
Description
void close()
Closes the connection when it is no
longer required.
MessageFactory createMessageFactory Creates a message factory that will 
(java.lang.String proﬁle)
produce messages according to the
speciﬁed proﬁle (for example, ebXML).
ProviderMetaData getMetaData()
Returns information about the JAXM
Provider itself, including the sup-
ported proﬁles.
void send(SOAPMessage message)
Sends a message asynchronously via
the Provider.
www.syngress.com

Writing SOAP Servers • Chapter 7
267
Using the ProviderConnection
to Create a Message
W hen working with a JAX M  Provider, you will create messages using a message
factory generated from the provider connection.T his method allows you to
create a message according to any one of the speciﬁc proﬁles supported by your
JAX M  Provider.An example would be the generation of ebX M L messages using
a JAX M  Provider that supported an ebX M L proﬁle.T he following code demon-
strates how such a message factory and subsequent message would be generated,
having ﬁrst created the provider connection object connection as described above:
MessageFactory msgFactory = connection.createMessageFactory("ebxml");
SOAPMessage myMsg = msgFactory.createMessage();
Using ProviderConnection to Send a Message
You will recall from the previous chapter that a synchronous message was sent
using the call method of an SO A P C onnection object:
SOAPMessage req;
// Populate request message
. . .
URLEndpoint endpoint = new URLEndpoint("http://destination");
SOAPMessage resp = myConnection.call(req, endpoint);
H owever, when sending an asynchronous message via a Provider, the process
is a little different:
SOAPMessage req;
// Populate request message
. . .
myProviderConn.send(req);
You will immediately observe two major differences between the process of
sending messages without and with a Provider:
1.
T he provider connection’s send method does not return a response mes-
sage (as we would expect, since this is an asynchronous model).
2.
T he provider connection’s send method does not take a U R L E ndpoint
parameter.
www.syngress.com

268
Chapter 7 • Writing SOAP Servers
If no endpoint is passed to the send method, how does the Provider know
where to send the message? T he answer to this is speciﬁc to both the Provider
and the Proﬁle used.T he R eference Implementation Provider provides two
Proﬁles: ebX M L and SO APR P.T hese Proﬁles represent protocols built upon
SO AP and each speciﬁes a number of mandatory ﬁelds that must be provided in
the SO AP H eader. Speciﬁcally, both of these protocols specify that the header
contain “to” elements which specify a U R I for the message destination.
Figure 7.6 shows the Provider Admin application for the JAX M  R eference
Implementation being used to conﬁgure the ebX M L/ H T T P Proﬁle. From this
screenshot you can see that the proﬁle can contain a number of E ndpoint
M appings that are used to map U R Is with destination U R Ls. In this case a single
mapping exists: the U R I http:/ / www.wombats.com/ remote/ sender is mapped to the
U R L http:/ / 127.0.0.1:8081/ jaxm-provider/ receiver/ ebxml.
T he outbound routing scenario is therefore as follows:
1.
T he routing of the message from the application to the JAX M  Provider
is implicit in the P roviderC onnection object, as described above.
2.
T he routing of the message from the outgoing JAX M  Provider to the
destination Provider is achieved by examining the message’s SO AP
www.syngress.com
Figure 7.6 JAXM Provider Endpoint Mappings

Writing SOAP Servers • Chapter 7
269
H eader to extract a destination U R I, and then using an Endpoint
M apping to map that U R I to a U R L.
3.
T he routing of the message from the receiving JAX M  Provider to the
destination servlet is achieved by mapping the destination U R I to a call-
back U R L via the deployment information provided in client.xml, as pre-
viously described.
Proﬁles
A number of protocols have already been built on top of SO AP— that is, they are
protocols that comply with SO AP and specify a number of speciﬁc elements,
usually with the SO AP H eader.T hese protocols are known as proﬁles, and it is
quite likely that more will be deﬁned in the future.
In order to facilitate the use of these protocols, JAX M  Providers may provide
implementations of the proﬁles.T he Provider will allow speciﬁc conﬁguration of
the properties associated with each proﬁle (as seen in Figure 7.6), and an applica-
tion may specify a particular proﬁle (if the Provider supports it) when requesting
a message factory.
An example of a proﬁle is ebX M L, which is a protocol commonly used in
business-to-business (B2B) implementations, and which is built on top of SO AP.
As said earlier, the following code can be used to request a message factory from
a provider connection and create a message from this factory:
MessageFactory msgFactory = connection.createMessageFactory("ebxml");
SOAPMessage myMsg = msgFactory.createMessage();
As long as the Provider supports a proﬁle named “ebxml”, this code would
have returned a message factory object that would in turn have created a slightly
different SO AP message object than the one we created in the previous chapter.
In that example we saw that a default message factory generates messages with an
empty header. In the case of the ebX M L proﬁle, the message factory will actually
generate pre-conﬁgured messages with a number of header elements inserted in
accordance with mandatory requirements of the ebX M L protocol.
If a Proﬁle is speciﬁed, the subsequent message factory may not only produce
message objects that are pre-conﬁgured with certain X M L content, but these
message objects may themselves be subtypes of SO A P M essage, and provide addi-
tional members.
Any such message class will not come from the JAX M  API; they will be spe-
ciﬁc classes distributed with the JAX M  Provider.As an example, the JAX M
www.syngress.com

270
Chapter 7 • Writing SOAP Servers
R eference Implementation provides two distinct proﬁles; ebX M L and SO APR P.
T he R eference Implementation also ships with two corresponding messaging
classes; com.sun.xml.messaging.ebxml.E bX M L M essageImpl and
com.sun.xml.messaging.soaprp.SO A P R P M essageImpl.T hese classes are distributed in
jaxm-client..jar.
T he E bX M L M essageImpl class provides a number of get and set methods to
support reading and writing a number of elements in an edX M L message H eader
and Body.An example is the method:
void setConversationId(java.lang.String conversationId)
T he setC onversationId method (as its name implies) allows the conversation ID
parameter to be set in the message header; this is a mandatory element in an
ebX M L message.
Similarly, the SO A P R P M essageImpl class provides a number of methods for
reading and writing various elements within a SO APR P message, such as the fol-
lowing method, which retrieves the “reverse path” from the SO APR P message
header:
java.util.Vector getSOAPRPRevMessagePath()
Writing a SOAP Server Servlet
U sing JAX M , there are a couple of ways that you can implement a SO AP service
that runs in a container and makes use of a JAX M  provider; either as a servlet
(running in a servlet container), or as a message-driven bean (running in an EJB
container).
Figure 7.7 shows how a servlet may be used to implement a SO AP Server.
You can see that even within a container, the use of a JAX M Provider can be
optional depending upon the model of SO AP communication used and the fea-
tures required. For example, a SO AP Server that communicates with a standalone
client via the request-response model and which does not need features such as
an ebX M L proﬁle, does not need to use a JAX M  Provider; the servlet will
receive the request message from the client (via the servlet container), process the
message, and return the response message to the client. O n the other hand, more
complex message routing and the use of JAX M  proﬁles will require the use of
the JAX M  Provider.
www.syngress.com

Writing SOAP Servers • Chapter 7
271
JAXMServlet
T he superclass provided by the JAX M  API for implementing SO AP Servers using
servlets is javax.xml.messaging.JA X M Servlet.T his is an abstract class, meaning that
you cannot directly instantiate objects of this type; you must ﬁrst create a base
class that extends JA X M Servlet and that implements  either the javax.xml.mes-
saging.O newayL istener or javax.xml.messaging.R eqR espL istener interface. N ote also
that there is no actual requirement to extend JA X M Servlet; you could create your
own servlet class that provided similar functionality as long as it implemented
O newayL istener or R eqR espL istener; however JA X M Servlet offers a certain conve-
nience.As an example of a situation where you may not wish to use the
JA X M Servlet class, imagine that you wanted to implement SO AP communications
bound to a protocol other than H T T P; since JA X M Servlet extends H T T P Servlet, it
can only be used for SO AP bound to H T T P. N ote that the dispatch method of
JA X M Servlet checks that the this object implements either O newayL istener or
R eqR espL istener in order to correctly route the message. For this reason, your
JA X M Servlet subclass must implement one of these two possible interfaces.
T he O newayL istener interface is implemented by servlets that are designed to
perform asynchronous SO AP communication; that is, they will receive a message
with no response required. Such a servlet may never send a response message, it
may send one immediately, or it may send one in a few days’ time.
O n the other hand, the R eqR espL istener interface should be implemented by
servlets that will participate in synchronous SO AP communication; the servlet
will receive a message, perform some processing of it, and make a response of
some sort.
www.syngress.com
Figure 7.7 The Use of a Servlet as a SOAP Server
Servlet container (e.g. Tomcat)
J AXM Provider
Servlet
(extending
J AXMServlet)
SOAP Client

272
Chapter 7 • Writing SOAP Servers
We have already established that the JA X M Servlet class extends H T T P Servlet;
furthermore, it provides an overridden implementation of doP ost. If you are
familiar with writing H T T P servlets for regular browser-based web pages and the
like, you may be tempted to override the doP ost method and attempt to work
with the H ttpServletR equest and H ttpServletR esponse objects directly. H owever, this
is usually not a good idea; the JAX M  listener interfaces (R eqR espL istener and
O newayL istener) are designed to abstract the processing of JAX M  messages to a
level that is independent of whether the server is implemented as a servlet or an
EJB.As we shall shortly see, these interfaces provide the appropriate mechanism
for handling messages.
Another best-practice recommendation is that a servlet derived from
JA X M Servlet should not be used for functionality that is unrelated to SO AP pro-
cessing; the JA X M Servlet class is speciﬁcally designed for consuming and possibly
sending SO AP messages. If, for example, you wished to provide a browser-based
web page with parallel functionality to a web service, it would be best to create
two independent servlets of appropriate types, and perhaps move common busi-
ness logic into the EJB layer.T he architecture for this kind of approach is shown
in Figure 7.8.
www.syngress.com
Figure 7.8 Using the JAXMServlet Subclass Only for SOAP Processing
J 2EE
Container
Web Browser
SOAP Client
Servlet
extending
J AXMServlet
Servlet
extending
HTTPServlet
EJ Bs

Writing SOAP Servers • Chapter 7
273
R equired O verrides
T he JA X M Servlet class does not require you to override any speciﬁc methods.T he
most likely method for overriding within this superclass is the init method, which
allows you to perform some processing when the servlet is ﬁrst initialized— this
could be very useful in performing any resource-hungry processing that only
needs to be run once.To override this method you would do the following:
public class MyServlet
extends JAXMServlet
implements OnewayListener {
public void init(ServletConﬁg servletConﬁg)
throws ServletException {
// Be sure to call the superclass method
super.init(servletConﬁg);
// Perform once-off initialization
// processing here
. . .
}
. . .
}
Even though the JA X M Servlet class does not require you to override speciﬁc
methods, you will have to implement either the O newayL istener or R eqR espL istener
interface, both of which have a single onM essage method, although these methods
differ in their return types.
If you develop an asynchronous SO AP server using a servlet that implements
O newayL istener, you will have to provide an onM essage method implementation
that looks like this:
public void onMessage(SOAPMessage message) {
// Process the incoming message
. . .
}
www.syngress.com

274
Chapter 7 • Writing SOAP Servers
H owever, if you develop a synchronous SO AP server using a servlet that
implements R eqR espL istener, you will need to provide a slightly different imple-
mentation of onM essage:
public SOAPMessage onMessage(SOAPMessage soapMsg) {
// Process the request message
. . .
SOAPMessage myResponse;
// Create and populate the response message
. . .
return myResponse;
}
N otice that the two versions of onM essage differ in their return types: a
O newayL istener implementation does not need to return a value from the
onM essage method, whereas an implementation of R eqR espL istener requires that a
SO A P M essage is returned from onM essage; this returned message is the response
message in the synchronous request-response model and will be routed back to
the client.
H andling M essages
As discussed above, regardless of the chosen listener interface it is the onM essage
method that will be implemented to handle messages; in the case of the
O newayL istener this will apply purely to inbound messages, whereas the
R eqR espL istener will handle both the inbound (request) and outbound 
(response) messages.
T his is not to say that a servlet that implements O newayL istener cannot send
outgoing messages; it certainly can.T he situation is just that these outgoing mes-
sages will be asynchronous; they are not sent back as responses to the incoming
messages, but rather as unsolicited messages sent either to the originating SO AP
client or to another destination altogether.
Later on in this chapter we will complete the example started in the previous
chapter and implement a service to look up the requested name and return the
value. Because our example follows the synchronous model (standalone JAX M
clients can only communicate this way), we will create a servlet that implements
R eqR espL istener.
www.syngress.com

Writing SOAP Servers • Chapter 7
275
Writing a SOAP EJB
T he other method for creating a SO AP server using JAX M  is with an EJB.T his
relies on the EJB 2.1 speciﬁcation, which provides for message-driven beans that
can be bound to a JAX M  provider.
T he EJB 2.0 speciﬁcation ﬁrst introduced the concept of message-driven beans.
T hese are a variant of the Enterprise Java Beans (EJBs) that are in turn similar to
stateless session beans, but with the following major differences:
■
M essage driven beans do not have a home, local or remote interface.
■
T he container passes messages to the bean and the bean processes them.
Prior to the concept of message-driven beans, the task of receiving messages,
invoking a bean and passing the messages to the bean had to be handled by a
custom-developed process (or daemon) which would be responsible for receiving
messages and then creating a stateless session bean, then communicating via the
bean’s remote interface, generally using R M I over IIO P (as shown in Figure 7.9).
T he obvious disadvantages of this are the need to develop a custom daemon and
the fact that the daemon runs outside of the EJB container and must communi-
cate with the bean using R M I.
Figure 7.10 shows a simpliﬁed view of a scenario that is similar but that
makes use of a message-driven bean. In this case there is no requirement for a
www.syngress.com
Figure 7.9 Traditional Method of Passing Messages to EJBs
EJ B Container
Daemon for receiving
messages
Stateles session bean
Incoming message
RMI/ IIOP
RMI/ IIOP
RMI/ IIOP

276
Chapter 7 • Writing SOAP Servers
process to stand outside of the container and remotely invoke the EJB; instead
the container will ensure that the messages are delivered to the bean. In fact,
since the bean has neither a remote interface nor a home interface, it cannot be
accessed by another application. N ote however that there must be some form of
asynchronous messaging technology involved; in EJB 2.0 the messages can only
be JM S messages; in EJB 2.1 implementations the messages could be asyn-
chronous SO AP messages passing through a JAX M  provider.
T he EJB 2.0 message-driven beans are based on the Java M essage Service
(JM S) API.W hen a JM S message is received, the container routes the message
directly to the bean.T his provides a very useful mechanism for decoupling the
EJB from applications; an application can send a JM S message that will be pro-
cessed asynchronously by the message-driven bean at some point. It is the EJB
2.0 version of message-driven beans that is implemented by most commercial
J2EE containers at the time of this writing.
T he EJB 2.1 speciﬁcation extends the concept of the message-driven bean to
cater for beans that are bound to JAX M  providers.T his means that an EJB can be
invoked directly by the container and passed an incoming asynchronous SO AP
message, similar to the way that a servlet implementing O newayL istener receives
SO AP messages.T he implication of this is that it enables EJBs to be directly
exposed as web services across the internet, and through the functionality pro-
vided by the JAX M  provider and the EJB container, such features as asyn-
chronous and guaranteed delivery of the messages to the bean are enabled.
www.syngress.com
Figure 7.10 The Use of Message-driven Beans
EJ B Container
Message-driven bean
Incoming message

Writing SOAP Servers • Chapter 7
277
Overriding MessageDrivenBean
and OnewayListener
A message-driven bean should always implement the M essageD rivenB ean interface.
T his interface contains two methods that must be implemented, as listed in 
Table 7.2.
Table 7.2 Methods that Must be Implemented in MessageDrivenBean
Method
Description
void ejbRemove()  
The container will invoke this before the bean
is removed; perform any required clean-up
action within this method.
void setMessageDrivenContext This method will be invoked after the instance 
(MessageDrivenContext ctx)
of the bean has been created, to provide the
bean with its context object. The implementa-
tion of this method should usually store a
copy of the context object in an instance 
variable.
M essage-driven beans that will be SO AP message handlers must also imple-
ment O newayL istener. In doing so, they become similar in their implementation to
the JAX M  servlets that implement this same interface.
You may be wondering why message-driven beans can implement
O newayL istener but do not have the option of implementing R eqR espL istener; the
answer is that message-driven beans can only operate asynchronously via a
provider— a message-driven bean does not listen on a U R L in the way a servlet
does and so cannot receive messages directly; all messages are routed to it by the
JAX M  Provider.
For further information on the speciﬁcs of implementing message-driven
beans that respond to JAX M  messages, refer to the documentation provided by
the vendor of the container to be used. R emember that this form of message-
driven bean requires a container that complies with EJB 2.1, and that most of the
commercially-available containers at the time of writing comply with EJB 2.0.
Example SOAP Servlet
In this section we will develop a functioning SO AP service that will complete
the example begun with the previous chapter’s standalone SO AP client.You will
recall that the client application sent a SO AP message to a service requesting a
www.syngress.com

278
Chapter 7 • Writing SOAP Servers
value to be looked up by a name; this service will do the lookup and return the
value to the client. If there are any errors in this process, whether from parsing
the incoming message or looking up the value, the error information will be
returned to the client in the form of a SO AP Fault.
Receiving and Processing SOAP Messages
T his example will be implemented as a servlet; it will override both JA X M Servlet
and R eqR espL istener.W hy does it override R eqR espL istener and not
O newayL istener? Because our client, developed in the previous chapter, is a stan-
dalone application sending messages synchronously, so we are bound to the
request-response model.
T he schema of the request and response messages was outlined in the pre-
vious chapter.You will remember that the client sends a name in a request, and
that the server is expected to look up a value against that name and return the
matching value (if found).
T he actual lookup will be done against the sample X M L that will be read in
from a ﬁle during the servlet’s initialization.You will recall that our sample X M L
ﬁle looks like this:
<entries>
<entry>
<name>foo</name>
<value>bar</value>
</entry>
<entry>
<name>Mickey</name>
<value>Mouse</value>
</entry>
</entries>
So if the client requested a lookup of the name M ickey, we would return the
value M ouse, whereas a lookup of P eter (or even mickey without the capital M )
would need to generate a SO AP fault in the response.
O ur example will be based on a servlet that extends JA X M Servlet, so it obvi-
ously needs to run in a container. Since we are using a standalone client we are
bound to the request-response model; the client sends a request and blocks,
waiting until we send some kind of response back. For this reason we will imple-
ment R eqR esponseL istener.
www.syngress.com

Writing SOAP Servers • Chapter 7
279
O ur servlet will only override two methods: init, which allows us to perform
a couple of one-off tasks (including reading the sample X M L ﬁle from disk), and
onM essage, which is called by the container each time a SO AP message is sent to
our servlet.T he version of onM essage that is deﬁned in the R eqR esponseL istener
interface is passed a SO A P M essage object when it is called by the container; this is
the request message that was sent from the client. It must also return a
SO A P M essage object, which will be sent back to the client as the response.
/**
* ReceiverServlet.java
*
*/
package com.syngress.jwsdp.soap.server;
import javax.xml.messaging.JAXMServlet;
import javax.xml.messaging.ReqRespListener;
import javax.xml.messaging.JAXMException;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPException;
import javax.servlet.ServletConﬁg;
import javax.servlet.ServletException;
import com.syngress.jwsdp.soap.server.ReceivedMessage;
import com.syngress.jwsdp.soap.server.LoadXMLException;
import com.syngress.jwsdp.soap.server.LookupException;
import com.syngress.jwsdp.soap.server.FaultMessage;
import com.syngress.jwsdp.soap.server.SchemaException;
import com.syngress.jwsdp.soap.server.NameValueLookup;
import com.syngress.jwsdp.soap.server.ReplyMessage;
public class ReceiverServlet
extends JAXMServlet
implements ReqRespListener {
// Instance variables that will be populated
// by the init method.
www.syngress.com

280
Chapter 7 • Writing SOAP Servers
protected MessageFactory messageFactory = null;
protected NameValueLookup lookUpper = null;
// All SOAP messages are routed to the onMessage
// method.
public SOAPMessage onMessage(SOAPMessage soapMsg) {
SOAPMessage retMsg = null;
ReceivedMessage recMsg = null;
ReplyMessage replyMsg = null;
String name = null;
String value = null;
try {
// Initialize the ReceivedMessage object
// with the incoming request message.
recMsg = new ReceivedMessage(soapMsg);
// Parse the message to extract the
// requested name parameter.
name = recMsg.getRequestedName();
// Attempt to retrieve the value
// that matches the name from the 
// sample XML.
value = lookUpper.lookup(name);
// Construct the response message.
replyMsg = new ReplyMessage(
messageFactory);
// Set the response parameter
// in the outgoing message.
replyMsg.setValue(value);
www.syngress.com

Writing SOAP Servers • Chapter 7
281
retMsg = replyMsg.getMessage();
} catch(SchemaException e) {
// There was an error parsing the
// request message.
try {
FaultMessage faultMsg = 
new FaultMessage(
messageFactory);
faultMsg.setFaultCode(
"Server");
faultMsg.setFaultString(
"Invalid Schema");
faultMsg.setFaultDetail(
"SchemaException");
retMsg = faultMsg.getMessage();
} catch(Exception ex) {
// Ignore errors generating
// fault and allow a 
// null return.
}
} catch(SOAPException e) {
try {
FaultMessage faultMsg = 
new FaultMessage(
messageFactory);
faultMsg.setFaultCode(
"Server");
faultMsg.setFaultString(
"SOAP Exception");
faultMsg.setFaultDetail(
"SOAPException");
www.syngress.com

282
Chapter 7 • Writing SOAP Servers
retMsg = faultMsg.getMessage();
} catch(Exception ex) {
// Ignore errors generating
// fault and allow a 
// null return.
}
} catch(LookupException e) {
// This should indicate that the
// requested name was not found
// in the XML.
try {
FaultMessage faultMsg = 
new FaultMessage(
messageFactory);
faultMsg.setFaultString(
"");
faultMsg.setFaultCode(
"Server");
faultMsg.setFaultString(
"Error looking up value");
faultMsg.setFaultDetail(
"LookupException");
retMsg = faultMsg.getMessage();
} catch(Exception ex) {
// Ignore errors generating
// fault and allow a 
// null return.
}
} catch(Exception e) {
// All other errors.
try {
FaultMessage faultMsg = 
new FaultMessage(
www.syngress.com

Writing SOAP Servers • Chapter 7
283
messageFactory);
faultMsg.setFaultString(
"");
faultMsg.setFaultCode(
"Server");
faultMsg.setFaultString(
"General server error");
retMsg = faultMsg.getMessage();
} catch(Exception ex) {
// Ignore errors generating
// fault and allow a 
// null return.
}
} ﬁnally {
// Since this is called synchronously,
// the message will be sent directly as
// a response to the original request.
return retMsg;
}
}
public void init(ServletConﬁg servletConﬁg)
throws ServletException {
// Method performs once-off initialization.
// Be sure to call the superclass
// implementation.
super.init(servletConﬁg);
// Attempt to create a new message factory.
try {
messageFactory = 
MessageFactory.newInstance();
www.syngress.com

284
Chapter 7 • Writing SOAP Servers
} catch(JAXMException e) {
e.printStackTrace();
} catch(SOAPException e) {
e.printStackTrace();
}
// Attempt to create an object that will
// look up values by name in the XML.
try {
lookUpper = new NameValueLookup();
} catch(LoadXMLException e) {
e.printStackTrace();
System.exit(1);
}
}
}
T he incoming message is represented by the class R eceivedM essage, which uses
the JAX M  DO M  implementation to parse the request and extract the appro-
priate parameter.
/**
* ReceivedMessage.java
*
*/
package com.syngress.jwsdp.soap.server;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPElement;
import javax.xml.soap.Name;
import java.util.Iterator;
import com.syngress.jwsdp.soap.server.SchemaException;
www.syngress.com

Writing SOAP Servers • Chapter 7
285
public class ReceivedMessage {
// Class represents a SOAP message received from
// a client, which should contain
// a valid request to look up a name.
protected SOAPMessage soapMessage = null;
public ReceivedMessage(SOAPMessage soapMessage) {
this.soapMessage = soapMessage;
}
public String getRequestedName()
throws SchemaException, SOAPException {
// Get the name parameter that was
// reuested for lookup. This will perform
// some validation of the XML.
String resp = null;
SOAPPart soapPart;
SOAPEnvelope soapEnvelope;
SOAPBody soapBody;
Name name;
// Traverse the hierarchy of SOAP 
// objects to obtain the body.
soapPart = soapMessage.getSOAPPart();
soapEnvelope = soapPart.getEnvelope();
soapBody = soapEnvelope.getBody();
// Search for an element
// with the correct 
// namespace-qualiﬁed name.
name = soapEnvelope.createName(
"GetValueByName",
www.syngress.com

286
Chapter 7 • Writing SOAP Servers
"myns",
"www.syngress.com/JWSDP/soap-example");
// Check there's at least one such 
// element.
Iterator valueRequests = 
soapBody.getChildElements(name);
if (! valueRequests.hasNext()) {
// Schema is not valid
throw(new SchemaException());
};
// Check there's no more than one
// such element.
SOAPElement soapElement = 
(SOAPElement)valueRequests.next();
if (valueRequests.hasNext()) {
// Schema is not valid
throw(new SchemaException());
}
// Look for the appropriate child
// element containing the name parameter.
name = soapEnvelope.createName(
"name");
Iterator params = 
soapElement.getChildElements(
name);
if (! params.hasNext()) {
// Schema is not valid
www.syngress.com

Writing SOAP Servers • Chapter 7
287
throw(new SchemaException());
}
// Ensure there's only one such element.
SOAPElement paramElement = 
(SOAPElement)params.next();
if (params.hasNext()) {
// Schema is not valid
throw(new SchemaException());
}
// Attempt to read out the value of the
// name parameter.
resp = paramElement.getValue();
if (null == resp) {
// Schema is not valid
throw(new SchemaException());
}
// Schema is valid.     
return resp;
}   
}
T he N ameValueL ookup class provides the functionality to load the X M L ﬁle
from disk into a DO M  document and to search that document for a value
matching a requested name. N ote that this class makes use of the JAX P DO M
implementation, which adheres to the org.w3c.dom speciﬁcation.
/**
* NameValueLookup.java
*
*/
www.syngress.com

288
Chapter 7 • Writing SOAP Servers
package com.syngress.jwsdp.soap.server;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConﬁgurationException;
import java.io.FileReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import com.syngress.jwsdp.soap.server.LookupException;
import com.syngress.jwsdp.soap.server.LoadXMLException;
public class NameValueLookup {
// Class represents an in-memory instance
// of the sample XML ﬁle and
// can perform a name/value lookup.
// Uses the DOM for parsing.
// Assumes that the XML ﬁle is stored
// in the root directory of the primary
// HDD on a Windows system; adjust for
// different systems.
protected static ﬁnal String docSource = 
"c:\\sample.xml";
protected Document domDoc = null;
public NameValueLookup()
throws LoadXMLException {
// Create a document builder
// for loading the ﬁle into the
www.syngress.com

Writing SOAP Servers • Chapter 7
289
// DOM document.        
DocumentBuilderFactory dbFactory = 
DocumentBuilderFactory.newInstance();
DocumentBuilder docBuilder = null;
try {
docBuilder = 
dbFactory.newDocumentBuilder();
} catch(ParserConﬁgurationException e) {
throw new LoadXMLException();
}
// Use a FileReader to access the
// ﬁle from disk.
FileReader reader = null;
try {
reader = new FileReader(docSource);
} catch(FileNotFoundException e) {
throw new LoadXMLException();
}
// Attempt to parse the XML
// ﬁle into the DOM document.
InputSource source = new InputSource(reader);
try {
domDoc = docBuilder.parse(source);
} catch(IOException e) {
throw new LoadXMLException();
} catch(SAXException e) {
throw new LoadXMLException();
}
}
public String lookup(String name)
www.syngress.com

290
Chapter 7 • Writing SOAP Servers
throws LookupException {
// Looks up the value corresponding
// to the name parameter.
String value = null;
try {
NodeList nameNodes;
// Retrieve all of the elements
// named "name".
nameNodes = 
domDoc.getElementsByTagName(
"name");
int len = nameNodes.getLength();
// Iterate through the matching
// elements.
for (int ix=0; 
ix < nameNodes.getLength(); 
ix++) {
// Compare the name with the
// value of the ﬁrst child
// node.
if (nameNodes.
item(ix).
getChildNodes().
item(0).
getNodeValue().
equals(name)) {
// We have a match on
// the name; need to
// retrieve the value.
www.syngress.com

Writing SOAP Servers • Chapter 7
291
NodeList childNodes;
Node parent = 
nameNodes.
item(ix).
getParentNode();
childNodes = 
parent.getChildNodes();
for (int iy = 0; 
iy < childNodes.getLength(); 
iy++) {
// Look for a child node
// with a name of "value".
if (childNodes.
item(iy).
getNodeName().
equals("value")
) {
// Retrieve the value
// of the ﬁrst child
// node.
value = 
childNodes.
item(iy).
getChildNodes().
item(0).
getNodeValue();
// We have now
// successfully looked
// up the value.
break;
}
www.syngress.com

292
Chapter 7 • Writing SOAP Servers
}
break;
}
}
} catch(Exception e) {
throw new LookupException();
}
// Throw an exception if we didn't ﬁnd
// a value.        
if (null == value) {
throw new LookupException();
}
return value;
}
}
T he R eplyM essage class is used to model a response message to be returned to
the client.T his class contains the functionality to insert the value that was found
in the lookup into the correct schema.
/**
* ReplyMessage.java
*
*/
package com.syngress.jwsdp.soap.server;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPElement;
www.syngress.com

Writing SOAP Servers • Chapter 7
293
public class ReplyMessage {
// Class represents a SOAP message
// to be returned back to the client.
protected SOAPMessage soapMessage = null;
public ReplyMessage(MessageFactory messageFactory)
throws SOAPException {
// Create a new message from the
// message factory passed in.
soapMessage = messageFactory.createMessage();
}
public void setValue(String value)
throws SOAPException {
// Set the response value
// to be returned.
SOAPPart soapPart;
SOAPEnvelope soapEnvelope;
SOAPBody soapBody;
// Traverse the hierarchy of
// SOAP objects to obtain the
// body. 
soapPart = soapMessage.getSOAPPart();
soapEnvelope = soapPart.getEnvelope();
soapBody = soapEnvelope.getBody();
// Add the response element to the body,
// using a namespace-qualiﬁed name.
SOAPElement responseElement = 
soapBody.addChildElement(
soapEnvelope.createName(
www.syngress.com

294
Chapter 7 • Writing SOAP Servers
"GetValueByNameResponse",
"myns",
"www.syngress.com/JWSDP/soap-example"));
// The value to be returned
// is added as a text node as a child of the
// response element using a local name.
SOAPElement paramElement = null;
paramElement = responseElement.
addChildElement("value");
paramElement.addTextNode(value);
soapMessage.saveChanges();
}
public SOAPMessage getMessage() {
// Get the SOAP Message.
return soapMessage;
}
}
Several exception classes are used in the example. SchemaE xception is used to
indicate that the request message did not adhere to the agreed schema.
/**
* SchemaException.java
*
*/
package com.syngress.jwsdp.soap.server;
public class SchemaException extends Exception {
// This exception is used to
www.syngress.com

Writing SOAP Servers • Chapter 7
295
// indicate that the XML being
// parsed did not conform to
// the appropriate schema.
}
T he L oadX M L E xception is used to indicate that an error occurred in loading
the sample X M L ﬁle from disk into the DO M  document.
/**
* LoadXMLException.java
*
*/
package com.syngress.jwsdp.soap.server;
public class LoadXMLException extends Exception {
// This exception is used to
// indicate any error in loading
// the sample XML data from the
// ﬁle.
}
T he L ookupE xception is used to indicate that the requested name could not be
found in the sample X M L.
/**
* LookupException.java
*
*/
package com.syngress.jwsdp.soap.server;
public class LookupException extends Exception {
// This exception is used to
// indicate that no value could
// be found corresponding to the
// requested name.
}
www.syngress.com

296
Chapter 7 • Writing SOAP Servers
As you will remember from the previous chapter, errors transported in SO AP
M essages take the form of a SO AP Fault.T he F aultM essage class is used to model
a response to return fault information to the client.
/**
* FaultMessage.java
*
*/
package com.syngress.jwsdp.soap.server;
import javax.xml.soap.MessageFactory;
import javax.xml.soap.SOAPMessage;
import javax.xml.soap.SOAPPart;
import javax.xml.soap.SOAPEnvelope;
import javax.xml.soap.SOAPBody;
import javax.xml.soap.SOAPException;
import javax.xml.soap.SOAPElement;
import javax.xml.soap.SOAPFault;
import javax.xml.soap.Name;
import javax.xml.soap.Detail;
import javax.xml.soap.DetailEntry;
import java.util.Iterator;
public class FaultMessage {
// Class represents a message containing
// fault information to be returned
// to the client.
SOAPMessage message;
SOAPFault fault;
public FaultMessage(MessageFactory messageFactory)
throws SOAPException {
// Create a new message from the
www.syngress.com

Writing SOAP Servers • Chapter 7
297
// message factory passed in.
message = messageFactory.createMessage();
SOAPPart soapPart;
SOAPEnvelope soapEnvelope;
SOAPBody soapBody;
// Traverse the hierarchy of
// SOAP objects to obtain the
// body. 
soapPart = message.getSOAPPart();
soapEnvelope = soapPart.getEnvelope();
soapBody = soapEnvelope.getBody();
// Add a SOAP Fault to the
// body.
fault = soapBody.addFault();
}
public void setFaultCode(String faultCode)
throws SOAPException {
// Set the fault code in the SOAP Fault.
fault.setFaultCode(faultCode);
}
public void setFaultString(String faultString)
throws SOAPException {
// Set the fault string in the SOAP Fault.
fault.setFaultString(faultString);
}
public void setFaultDetail(String faultDetail)
throws SOAPException {
// Set the fault detail in the SOAP Fault.
www.syngress.com

298
Chapter 7 • Writing SOAP Servers
// This will be added as a single
// detail entry under a 
// namespace-qualiﬁed name.
SOAPEnvelope soapEnvelope = 
message.getSOAPPart().getEnvelope();
Detail detail = fault.addDetail();
Name name = soapEnvelope.createName(
"FaultDetail",
"myns",
"www.syngress.com/JWSDP/soap-example");
DetailEntry entry = 
detail.addDetailEntry(name);
entry.addTextNode(faultDetail);
}
public SOAPMessage getMessage() {
// Retrieve the underlying
// SOAPMEssage object.
return message;
}
}
O nce the servlet is compiled, you will need to deploy it in a servlet con-
tainer.T his is done exactly as you have deployed servlets in the past: because 
the servlet does not make use of a JAX M  Provider, there is no need for any
JAX M -speciﬁc deployment information (that is, you do not need to provide a
client.xml ﬁle).
You should be able to test the servlet with the client developed in the pre-
vious chapter. Ensure that you recompile C lient.java with the U R L of your
newly-deployed servlet assigned to the SE RV IC E _ E N D P O IN T variable and
there should be little else to do; run the client with an appropriate name as a
command-line parameter and observe the results.
www.syngress.com

Writing SOAP Servers • Chapter 7
299
www.syngress.com
End-to-End Debugging
The examples developed in this chapter and the previous one form an
end-to-end system. In the previous chapter we developed a SOAP client
application, and in this chapter we developed a matching server appli-
cation as a servlet.
It should be perfectly feasible to debug the entire system as an end-
to-end solution, by using two instances of the debugger. In order to do
this you would start up a debugger instance on the machine that will
run the SOAP client, and catch the execution at a breakpoint somewhere
prior to the request message being sent out. Then you would use
another debugger instance on the machine running the server in the
servlet container—you may require information provided by the vendor
of your servlet container on how to do this. The idea is to set a break-
point within the ReceiverServlet class’ onMessage method. You should
be able to place a breakpoint at the ﬁrst line of code within the method.
From this point on, you can continue to step line-by-line through
the client’s code execution until the request message is sent out. Once
that happens you should be able to move back over to the server
debugger instance; the servlet should have received the message and
the breakpoint should have interrupted execution. You can then step
through the server code until a response message is returned from the
onMessage method, when execution will resume on the client.
Debugging…

300
Chapter 7 • Writing SOAP Servers
Summary
In this chapter we examined in more detail what a JAX M  Provider is, and how
an application can work with a JAX M  Provider to send and receive messages
asynchronously. Such an application must be hosted within a container, either as a
servlet or as a message-driven bean. For outgoing messages the Provider will be
responsible for routing the message to its destination and ensuring it is delivered
using a store and forward mechanism. For incoming messages the JAX M  Provider
will be responsible for receiving the messages and then routing them to the
appropriate servlet or EJB.
We also developed a SO AP server (as a servlet) that will respond to requests
made by the client from the previous chapter, look up a value from the sample
X M L ﬁle, and return either the value or a SO AP Fault error message. Because
the client was developed as a standalone application, the server will operate syn-
chronously (and the servlet will implement R eqR espL istener).
Solutions Fast Track
M essage R outing
 Applications that use a JAX M  Provider can communicate using
asynchronous communications.
 T he use of a JAX M  Provider means that messages’ delivery can be
guaranteed, even if the receiver is inactive at the time a given message is
sent.T his is achieved using a store and forward mechanism.
 An asynchronous model using JAX M  Providers requires that outgoing
messages be routed to their destination, and that incoming messages
received by a JAX M  Provider be routed to the appropriate service.
Establishing a C onnection to a JAX M  Provider
 A JAX M  Provider is registered with a naming service.
 An application that wishes to make use of a JAX M  Provider uses the
JN DI API to look up the Provider in much the same way as an EJB
lookup is performed.
www.syngress.com

Writing SOAP Servers • Chapter 7
301
P roviderC onnections
 T he P roviderC onnection object is used to obtain a M essageFactory.
 An application sends asynchronous messages via the P roviderC onnection.
Such a request does not specify a destination U R L, nor does it wait for a
response.
 T he JAX M  Provider will determine the destination from a U R I in the
message header, in combination with endpoint mappings conﬁgured
within the JAX M  Provider which map U R Is to U R Ls.
W riting a SO AP Server Servlet
 JAX M  SO AP servers can be implemented either as servlets or as EJBs,
although currently only servlets are supported by most vendors.
 A SO AP Server servlet can either receive synchronous messages
(request-reply) or asynchronous messages.
 A servlet that will operate synchronously (without a JAX M  Provider)
should implement R eqR espL istener.
 A servlet that will operate asynchronously (with a JAX M  Provider)
should implement O newayL istener.
W riting a SO AP EJB
 A SO AP EJB is a form of message-driven bean, and should implement
the M essageD rivenB ean interface.
 A SO AP message-driven bean cannot operate synchronously; it must
implement O newayL istener.
 T he processing of O newayL istener.onM essage in a message-driven bean is
very similar to that within an asynchronous SO AP servlet.
Example SO AP Servlet
 We covered the development of a service that can be called by the client
described in the previous chapter. Because that client is a standalone
application operating synchronously, the service must also operate
without a JAX M  Provider.
www.syngress.com

302
Chapter 7 • Writing SOAP Servers
 T he service uses the sample X M L that we use throughout this book to
look up a value against a name speciﬁed in the request.
 If there is a failure in decoding the request or looking up the name, the
service returns SO AP Fault information in the response message.
Q: W hat is ebX M L?
A: ebX M L is a set of B2B speciﬁcations for enabling enterprises to conduct
business over the Internet. ebX M L is a set of B2B speciﬁcations for enabling
enterprises to conduct business over the Internet. ebX M L is backed by
O ASIS (the O rganization for the Advancement of Structured Information
Standards) and U N / C EFAC T  (the U nited N ations C enter for Trade
Facilitation and Electronic Business).
Q: H ow do I conﬁgure the R eference Implementation JAX M  Provider?
A: If you have installed the Java Web Services Developer Pack, the Provider Admin
tool will by default be installed to http:/ / servername:8081/ jaxm-provider
admin.You will need to ensure that Tomcat is already running (through the
startup.bat or startup.sh scripts).T he admin tool is password-protected; you will
need to modify the tomcat-users.xml ﬁle to remove the comments around the
entry with the username “jaxm-provideradmin;” it would also be a good idea
to change the password from “changeme” to something more unique.
Q: W hy are SO AP Server EJBs restricted to implementing O newayL istener when
servlets may implement either O newayL istener or R eqR espL istener?
A: A servlet has the option of operating with or without a JAX M  Provider; if it
operates without a Provider, client sending the request accesses it directly by
its U R L. O n the other hand, an EJB cannot be directly addressed by a
U R L— it has no U R L, and can only operate in an asynchronous mode where
a JAX M  Provider receives the messages and routes them to the EJB.
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

Using XML-based
RPC
Solutions in this chapter:
■
JAX-RPC Summary
■
Mapping Java Data Types
■
Conversion Between Java Classes 
and WSDL
■
Creating a JAX-RPC Client
■
Creating a JAX-RPC Server
■
Creating a Simple XML-RPC Server 
and Client
Chapter 8
303
 Summary
 Solutions Fast Track
 Frequently Asked Questions

304
Chapter 8 • Using XML-based RPC
Introduction
You might think that the last thing the world needs is another remote procedure
call protocol; after all, there are dozens already in existence.T hat’s largely a true
statement, and for many situations, X M L-based R PC  offers few advantages over
existing remote procedure call interfaces. Further, encoding the request into
X M L makes the calls less efﬁcient than direct (binary) interfaces.
H owever, there are times when X M L-based R PC  solves a business problem.
You might have to communicate via an R PC  mechanism across organizational
boundaries through ﬁrewalls, for instance.Alternately, you might be communi-
cating with wildly disparate systems— a mainframe speaking PL/ 1 and a desktop
speaking Java.You might even be creating a server system where you have no way
of knowing the remote client, let alone controlling it. X M L-based R PC  also pro-
vides some resilience in the face of change. Since the published interfaces are
X M L-based instead of binary, elements can sometimes be added or removed
without breaking the connection between the server and existing clients.
JAX -R PC  uses two industry standards surrounding X M L-based R PC : SO AP
and W SDL. SO AP (covered in chapters 6 & 7) is used for the transfer of data
between end points.Web Service Description Language (W SDL) is the functional
analog of IDL ﬁles in other remote procedure systems: it provides a common lan-
guage for describing the inputs, outputs and semantics of remote client services.
JAX-RPC Summary
T he Java API for X M L-based R PC  (JAX -R PC ) is an API used to facilitate
remote procedure calls. R emote procedure calls are nothing new; the technology
has been around for years, but the difference between JAX -R PC  and older R PC
mechanisms is the data exchange format. U nlike with older implementations,
method calls and subsequent return values in JAX -R PC  are passed back and
forth as SO AP messages.T he SO AP speciﬁcation contains provisions for repre-
senting remote procedure calls and the subsequent responses of those calls.T hese
SO AP messages usually use H T T P as the transport layer.T he combination of
these technologies opens new doors in the area of interoperability and EAI. Since
both the data exchange format and the transport mechanism are both built upon
platform-neutral  standards, clients and servers deployed on disparate platforms
and operating systems can now use the same set of services.
www.syngress.com

www.syngress.com
JAX -R PC  manifests itself as specialized X M L messages; the clients invoking
the R PC  and the servers hosting the R PC ’s functionality operate in a syn-
chronous manner. Execution of the client is delayed until such time that the
R PC  has returned a response.
NOTE
It is important to note that while most other XML messages request a
service in a decoupled manner, XML-RPC deﬁnes function call semantics.
These function call semantics deﬁne the name of the method to invoke,
the number and type of parameters to pass to the method, and the
return value type.
Understanding Stubs and Ties
T he process of taking method calls and translating them into the appropriate
format for transmission, then translating them back on the server end is imple-
mented by stubs and ties .T his process is ofﬁcially known as marshaling and unmar-
shaling. Figure 8.1 illustrates where these stubs and ties ﬁt into the X M L-R PC
architecture.
Both the stubs and ties work with the core JAX -R PC  APIs to transmit
SO AP encoded X M L using standard H T T P.
If you use the JW SDP to create a web service application then the stubs and
ties are created by the xrpcc tool.T his tool can take either the Service Deﬁnition
Interface (SDI) or a W SDL conﬁguration ﬁle and generate the appropriate stubs
and ties. xtpcc is discussed in greater detail later in this chapter.
Using XML-based RPC • Chapter 8
305
Figure 8.1 XML-RPC using JAX-RPC Overview
Client
Server
Stubs
J AX-RPC
Ties
J AX-RPC
SOAP/ HTTP

306
Chapter 8 • Using XML-based RPC
W hen you create your client, you will use the generated stub class(es) to
invoke your web service on the server side.T he stub then acts as a service proxy,
masking the marshalling and remote procedure call from the client.
W hen you create your service deﬁnition and implementation you do not
need to explicitly work with the tie class(es).T he JAX -R PC  framework will use
behind-the-scenes ties to unmarshall the data and invoke the appropriate method
in your service.
Sending a XML-RPC Message
T he sending and receiving of X M L-R PC  messages involves some fairly complex
functionality.T he JAX -R PC  API shields us from those complexities and leaves us
to focus on business needs.T he process of sending these X M L-R PC  messages
involves the following steps. Since X M L-R PC  is a synchronous process, each of
these steps will be executed in turn. Granted, there is more going on behind the
scenes than the list suggests, but it does cover the high-level milestones in the
R PC  process.
1. Client—Creation T he client application will create an instance of the
stub class that serves a proxy for the desired functionality.
2. Client—Invocation T he client will then invoke the business methods
through this proxy by specifying the method, its parameters and the ser-
vice endpoint.
3. Client—Conversion to SOAP Message T he stub class will take the
method name and speciﬁed parameters, and create a SO AP message that
embodies that data.
4. Client—Message Transport T his SO AP message is then sent over
H T T P by virtue of a PO ST  request to the service endpoint.
5. Server—Remote Listener T he H T T P web server located at the
U R L deﬁned by the endpoint receives the request and passes it on to an
X M L-R PC  listener.
6. Server—Message Parsing T his listener parses the SO AP message to
retrieve the method name and parameters of that method. O nce parsed,
the listener calls that method, passing in those parameters.
7. Server—Method Response T he method returns a value to the lis-
tener.T his listener will package the response as an X M L document.A
SO AP message is created from this X M L document.
www.syngress.com

Using XML-based RPC • Chapter 8
307
8. Server—Response Transmission T he H T T P server will return the
SO AP message, encapsulating the method call’s response in its response
to the original H T T P PO ST  request.
9. Client—Message Receipt T he originating client receives the response 
JAX -R PC  offers distinct advantages over other R PC  technologies. By virtue
of using H T T P to transmit X M L-based remote procedure calls, the invoking
platform and the service-hosting platform need not be of the same type.
W indows-based clients written in Visual Basic can invoke procedure calls on ser-
vices written in Perl running on Solaris machines.
JAX -R PC  places no restrictions on the physical location of the client and
server boxes, so a great distance could separate clients and servers, provided the
server is reachable by the client and that the network latency associated with the
established connection does not adversely affect client performance.
T he use of JAX -R PC  enables you to use a truly distributed heterogeneous
enterprise platform.You as the developer or architect of a system can choose
best-of-breed solutions without being necessarily limited due to platform-com-
patibility issues when choosing your products.Admittedly, this is oversimplifying
the matter a bit, but the truth remains that X M L is becoming the standard for
data exchange. Since data exchanges are using a standard format and being trans-
mitted using a common protocol (H T T P), you can achieve platform indepen-
dence when designing and implementing your system.
Mapping Java Data Types
T he JAX -R PC  speciﬁcation spells out the mapping that occurs when translating
Java data types to the appropriate X M L representation. Support presently exists
for most of the data types in Java, as well as the facilities to create your own
wrappers for unsupported types.
Supported Java Data Types
T he JAX -R PC  speciﬁcation mandates support for most of the Java primitive data
types.T he sole exception is the char type.All others, including boolean, byte, short,
int, long, ﬂoat and double are supported. JAX -R PC  also supports the wrapper
classes for this list of primitives (java.lang.Integer, for example).
T he JAX -R PC  speciﬁcation also provides support of a small set of classes
from the standard JR E class library.T his set consists of:
www.syngress.com

308
Chapter 8 • Using XML-based RPC
■
java.lang.String
■
java.util.D ate
■
java.util.C alendar
■
java.math.B igInteger
■
java.math.B igD ecimal
T here is also support for arrays. Supported arrays must consist of a previously
deﬁned supported Java data type or class.T he speciﬁcation also calls for support
of arrays of type java.lang.O bject.
Data Type to XML/WSDL Deﬁnition Tables
T his section covers the mapping of Java data types to their corresponding types
for the X M L/ W SDL deﬁnition. In the current version of the JW SDP there is
support for the mapping of both primitive and object data types.
Primitives
Table 8.1 illustrates the mapping of supported primitive Java data types to the
corresponding X M L data type.
Table 8.1 Primitive Type Mapping
Primitive Data Type
XML Data Type
boolean 
xsd:boolean
byte
xsd:byte
double
xsd:double
ﬂoat
xsd:ﬂoat
int
xsd:int
long
xsd:long
short
xsd:short
O bject Types
T he JAX -R PC  also supports the following Java classes shown in Table 8.2. N ote
that the Java wrapper classes are mapped to their corresponding SO AP encoded
type.
www.syngress.com

Using XML-based RPC • Chapter 8
309
Table 8.2 Object Type Mapping
Object Data Type
XML Data Type
java.lang.String
xsd:String
java.lang.Boolean 
xsd:boolean
java.lang.Byte
xsd:byte
java.lang.Double
xsd:double
java.lang.Float
xsd:ﬂoat
java.lang.Integer
xsd:int
java.lang.Long
xsd:long
java.lang.Short
xsd:short
java.math.BigDecimal
xsd:decimal
java.math.BigInteger
xsd:integer
java.util.Calendar
xsd:dateTime
java.util.Date
xsd:dateTime
Arrays
T he JAX -R PC  speciﬁcation supports arrays, provided they are of a type already
supported by JAX -R PC. For example, the following code represents a perfectly
valid service deﬁnition interface. Both the String O bject type and the int primi-
tive data type are supported, so an array of those types is likewise supported.
import java.rmi.Remote;
import java.rmi.RemoteException;
public interface LoanApplicationIF extends Remote
{
public String[] getCreditRating( int[] ids )
throws RemoteException;
}
T he JAX -R PC  also provides support for multi-dimensional arrays.Again the
constraint is that the data type of the array must be of a supported type.
import java.rmi.Remote;
import java.rmi.RemoteException;
www.syngress.com

310
Chapter 8 • Using XML-based RPC
public interface WorkingHoursCalculateIF extends Remote
{
public int[][] getWorkingHours( int year )
throws RemoteException;
}
Application C lasses
Typically, when you design an O O  application you create custom classes that rep-
resent objects.T hese objects can be C ustomers, O rders, TroubleT ickets, E mployees, or
whatever you need.T hese classes encapsulate the state of each instance of those
objects.An E mployee class might hold a ﬁrst name, last name, social security
number, hire date and so on.
JAX -R PC  provides support for these types of classes. In the JAX -R PC  speci-
ﬁcation these classes are referred to as Value Types.T hat name was assigned
because the class passes its state (values) from the client to the server and back.
T he application class can be treated as a value type under the following 
conditions.
■
T he application class must have a public no-argument (default) 
constructor.
■
N either the application class nor any of its super classes may implement
the java.rmi.R emote interface.
■
All members of the application class must be of one of the supported
types.
Assuming that these requirements are satisﬁed, the application class may have
any of the following characteristics:
■
T he members of the application can have any of the deﬁned scope
modiﬁers; public, private, protected, and the default (package).
■
T he application class is free to implement any interface except for
java.rmi.R emote.
■
T he application class may extend any other class, so long as it does not
derive from a class that implements java.rmi.R emote.
■
T he application class may contain transient members.
■
T he application class may contain static members.
www.syngress.com

Using XML-based RPC • Chapter 8
311
If your application class has been created as a JavaBean, the JAX -R PC  API
can still support it.T he requirements for JavaBean support are that the bean fol-
lows the standard naming convention for its accessors and mutators. JAX -R PC
adds the restriction that the properties of that bean must be of one of the sup-
ported types.
NOTE
The use of the java.rmi.Remote interface when creating your service
interfaces marks them as remote objects that may be invoked from a
remote virtual machine.
Arbitrary Java Classes
T he JAX -R PC  speciﬁcation provides an extensible type-mapping framework that
allows developers to add support for mapping between X M L types and Java types
that are not supported in the default conﬁguration.T his mapping framework is
implemented by serializers and deserializers.T hese serializers and deserializers are
plugged into the framework and provide the mapping between any arbitrary Java
type and X M L type.
Serializers
A serializer is a Java class that can transform a Java data type to SO AP-encoded
X M L.T his serializer implements a method called serialize which is invoked by a
container (stub or tie) when a Java data type needs to be converted to its X M L
representation.
T here are several requirements that a serializer must satisfy in order to be
used within the JAX -R PC  framework.T he following list highlights those
requirements:
■
T he serializer must implement the SO A P Serializer interface.
■
T he serializer must be stateless.
■
T he serializer must be thread-safe.
www.syngress.com

312
Chapter 8 • Using XML-based RPC
Deserializers
A deserializer is a Java class that can recreate instances of a Java data type that were
SOAP-encoded during serialiazation.A deserializer performs the following steps.
1
T he object represented by an X M L element is opened.
2.
Each of that object’s members are deserialized.
3.
T he appropriate Java data type is created and initialized with the 
deserialized members.
4.
T he new object instance is passed back as the return value of the 
deserialize method.
T here are several requirements that a deserializer must satisfy in order to be
used within the JAX -R PC  framework.T he following list highlights those
requirements.
■
T he deserializer must implement the SO A P D eserializer interface.
■
T he deserializer must be stateless.
■
T he deserializer must be thread-safe.
T hese requirements are basically the same as those of the serializers, except
that deserializers implement a different interface.
Holder Classes
H older classes are used to enable the Java to W SDL mapping to preserve the
wsdl:operation signature and parameters.
Each holder class has the same characteristics.T hese characteristics are as 
follows.
■
T he holder class will be deﬁned as implementing the javax.xml.rpc
.holders.H older interface.
■
A public member named value that is of a type consistent with a valid
mapped Java type.
■
A default no-argument constructor.T his constructor will initialize the
value member.
■
A constructor that has a single parameter of the same type as the value
member.T his constructor should set the value member to the speciﬁed
value.T he JAX -R PC  speciﬁcation provides holder classes for the primitive
www.syngress.com

Using XML-based RPC • Chapter 8
313
data types in the javax.xml.rpc.holders package.T he name of these pre-
deﬁned holder classes is derived by taking the name of the primitive type
and adding a H older sufﬁx.
NOTE
Holder classes are deﬁned with greater detail in the JAX-RPC
Speciﬁcation, presently at version PFD 0.8, section 4.3.5.
Conversion Between 
Java Classes and WSDL
A W SDL ﬁle is an X M L document used to describe a Web Service. It contains the
deﬁnitions of all methods available, the parameters’ data types and the data type of
the return value.T hese W SDL ﬁles can get complex in a hurry. Fortunately the
JW SDP has provided a tool to facilitate the creation of these ﬁles.
WSDL Generator
T he JW SDP comes with a command-line tool called xrpcc that automates the
tasks of creating client stubs, server ties and W SDL ﬁles.T his tool is located at
<JW SD P _ H O M E >/ bin.T he tool accepts several command-line options that
affect what it generates. It can create R M I Interfaces or a W SDL Document,
depending on what is speciﬁed in its conﬁg ﬁle.T he xrpcc tool has the following
syntax.
xrpcc.extension [options] conﬁg_ﬁlename
H ere, extension will be bat for W indows and sh for U N IX .
C ommand Line O ptions
T he xrpcc command-line tool has several options.T hese options determine its
runtime behavior.Table 8.3 list the command-line options.
www.syngress.com

314
Chapter 8 • Using XML-based RPC
Table 8.3 xrpcc tool command line options
Option 
Description
-server
Generates all server artifacts. This includes Ties, Server
Conﬁguration File, and WSDL ﬁle or a Service Deﬁnition
Interface (whichever of the two is not deﬁned)
-client
Generates all client artifacts. This includes stubs, the
Service Interface, Implementation Classes and possibly
the Remote Interface.
-both
Instructs the xrpcc tool to generate both the server and
the client artifacts listed above.
-classpath classpath
Explicitly sets the classpath that the tool will use during
execution.
-d directory
Denotes the directory where the output of the tool
should go.
-keep
Instructs the tool to keep the Java source ﬁles generated
after they have been compiled. The default behavior is
to remove these source ﬁles after compilation.
-version 
Instructs the tool to display the version number of the
JAX-RPC API.
Tool C onﬁguration File
T he following example illustrates one of the two general structures of the xrpcc
conﬁg ﬁle. In this case we are assuming that we have the R M I interfaces and
wish to generate the W SDL ﬁle (along with the stubs and ties).
<conﬁguration xmlns="http://java.sun.com/jax-rpc-ri/xrpcc-conﬁg">
<rmi name="..." targetNamespace="..."
typeNamespace="...">
<service name="..." packageName="...">
<interface name="..." servantName="..."
soapAction="..."
soapActionBase=""/>
</service>
<typeMappingRegistry>
...
</typeMappingRegistry>
</rmi>
</conﬁguration>
www.syngress.com

Using XML-based RPC • Chapter 8
315
Table 8.4 shows the conﬁg ﬁle elements for R M I-based generation.
Table 8.4 conﬁg ﬁle elements for RMI based generation
Element
Attribute
Description
rmi
name
This attribute denotes the name
you have given this model.
targetNamespace
This attribute denotes the target
namespace for the generated
WSDL ﬁle.
typeNamespace
This attribute denotes the target
namespace for the schema section
of the generated WSDL ﬁle.
service
name
This attribute denotes the name
you have given this service.
packageName
This attribute denotes the full
package name to give the gener-
ated classes.
interface
name
The fully qualiﬁed package name
of the Service Deﬁnition Interface.
servantName
The fully qualiﬁed package name
of the Service Implementation
class.
soapAction 
This optional attribute allows you
to specify a String to be used as
the SOAPAction for all actions.
soapActionBase
This optional attribute allows you
to specify a String value that will
be used as a preﬁx for the
SOAPAction strings.
typeMappingRegistry
N/A
This elements body is where you
would place optional type map-
ping information.
T he DT D that deﬁnes this document dictates that there only be one rmi ele-
ment. M ultiple service elements containing one or more interface child element(s)
are permissible, however.
T he following is the general structure of the xrpcc conﬁg ﬁle for those
instances where you have the W SDL ﬁle and wish to generate the R M I inter-
faces (along with the stubs and ties).
<conﬁguration xmlns="http://java.sun.com/jax-rpc-ri/xrpcc-conﬁg">
<wsdl name="..." location="..." packageName="...">
www.syngress.com

316
Chapter 8 • Using XML-based RPC
<typeMappingRegistry>
</typeMappingRegistry>
</wsdl>
</conﬁguration>
Table 8.5 shows the conﬁg ﬁle elements for W SDL-based generation.
Table 8.5 conﬁg ﬁle elements for WSDL based generation
Element
Attribute
Description
wsdl
name
This attribute denotes the name you 
have given this model.
location 
This attribute denotes a URL that 
points to a WSDL document.
packageName
This attribute denotes the fully quali-
ﬁed package name for the generated
classes and interfaces.
typeMappingRegistry
N/A
This element’s body is where you
would place optional type mapping
information.
For this document the DT D speciﬁes that one and only one wsdl element
may exist.
Server C onﬁguration File
T he xrpcc tool also generates a properties ﬁle, which is used to conﬁgure the
server web application during its initialization.A reference is placed to this prop-
erties ﬁle within the initialization parameters for the service endpoint servlet,
which is in turn within the server web application’s web.xml deployment
descriptor.
<init-param>
<param-name>conﬁguration.ﬁle</param-name>
<param-value>/WEB-INF/ServiceName_Conﬁg.properties</param-value>
</init-param>
T he name of the generated properties ﬁle is derived by applying the Service
N ame found in the Tool C onﬁguration ﬁle to the following formula.
<Service Name>_Conﬁg.properties.
www.syngress.com

Using XML-based RPC • Chapter 8
317
A typical properties ﬁle will contain information similar to the following
example.
port0.tie=websvc.accounting.IAccountsPayable_Tie
port0.servant=websvc.accounting.AccountsPayableImpl
port0.name=IAccountsPayable
port0.wsdl.targetNamespace=http://mybusiness.org/wsdl
port0.wsdl.serviceName=AccountPayable
port0.wsdl.portName=AccountPayablePort
port1.tie=websvc.accounting.IAccountsReceivable_Tie
port1.servant=websvc.accounting.AccountsReceivableImpl
port1.name=IAccountsReceivable
port1.wsdl.targetNamespace=http://mybusiness.org/wsdl
port1.wsdl.serviceName=AccountsReceivable
port1.wsdl.portName=AccountsReceivablePort
portcount=2
NOTE
The conﬁg ﬁle used to deﬁne the runtime behavior of the xrpcc com-
mand-line tool, as well as the tool itself, are not actually part of the JAX-
RPC speciﬁcation. Therefore it is safe to assume that the syntax of the
tool may change by the ﬁnal release of the speciﬁcation.
Using Classes Generated by the Stub Generator
T he server-speciﬁc classes generated by the tool must be packaged into the WAR
ﬁle containing the service implementation. For the client to use the classes gener-
ated by the xrpcc tool, they only need to be in the C LASSPAT H  environment
variable that is accessible by your client application.
Creating a JAX-RPC Client
A JAX -R PC  C lient is an application that invokes methods through a proxy hosted
at a service endpoint. U sing the tools provided by the JW SDP, the creation of a
JAX -R PC  client is not that complicated.You will most certainly possess or have
www.syngress.com

318
Chapter 8 • Using XML-based RPC
access to the W SDL ﬁle that describes the services available, or you may have the
stubs that were generated using the W SDL (or xrpcc conﬁg ﬁle).
Your client C LASSPAT H  will have to contain the service stub classes gener-
ated by the xrpcc tool described earlier.
Before the client can invoke service methods it will have to get an instance of
the service stub.T his service stub acts as a proxy to the service implementation.
O nce an instance of this stub is created, calls can be made on this stub as if the
service was a local object.
O nce the client has been coded, you can simply compile it and run. If all
works correctly your client application will be able to invoke methods on remote
service objects and return the results.
Creating a Connection to a Remote Server
T he client starts the process of invoking a remote method by ﬁrst instantiating
the appropriate stub class.T he name of the required stub class will conform to
the following naming convention: <Service D eﬁnition Interface N ame>_ Stub.class.
T his class is generated automatically by the xrpcc tool. If you use the – keep
option on this tool when you generate the stubs the source ﬁle will remain on
your ﬁle system. If you examine this source ﬁle, you will see that it is deﬁned 
as implementing the SDI methods.T he generated implementations of those
methods contain the code necessary to establish a connection, send a SO AP 
message, and retrieve a result (if necessary).
O nce a stub instance has been created it needs to be directed as to where to
locate the remote service.T his is accomplished by calling the _ setP roperty ( String,
String ) method of the stub instance.T he ﬁrst String parameter should denote the
name of the property for the endpoint, in this case accessible as the class member
javax.xml.rpc.Stub.E N D P O IN T _ A D D R E SS_ P RO P E RT Y , and the second String
parameter should contain the service endpoint, or location, that is hosting the
functionality desired.
Invoking Methods on a Remote Server
T he stub class contains the same methods as the SDI. O nce the stub has been
instantiated you may invoke the same methods deﬁned in that interface.T he
parameters are passed to the service endpoint, the target method is executed and
the resulting data (if any) is returned to the client that invoked the method in the
ﬁrst place. From the client’s perspective, the process looks the same as a local
method call.
www.syngress.com

Using XML-based RPC • Chapter 8
319
T here are other issues that need to be considered here. Since you are making
a call over the network, latency needs to be addressed.T he remote procedure calls
are synchronous, so it is imperative that you design your application with this in
mind.You may want to consider passing as much data as you can back and forth
over the wire with as few calls as possible.
Creating a JAX-RPC Server
T he JAX -R PC  Server provides business logic that is accessible as a remote proce-
dure call.T his server is hosted by a web server and is invoked by the client as a
U R L passing SO AP messages back and forth.
Creating the Service Deﬁnition Interface 
T he creation of a JAX -R PC  Server starts with the design and development of
the SDI. It is through this interface that all business functions are called.T he fol-
lowing are examples of what these interfaces might look like.
import java.rmi.Remote;
import java.rmi.RemoteException;
public interface ISchoolAdministration extends Remote
{
public String[] studentList( String class )
throws RemoteException;
public double gpa( String student )
throws RemoteException;
public boolean enroll( String student )
throws RemoteException;
public boolean graduate( String student )
throws RemoteException;
}
H ere we have deﬁned several business methods that a school administrator
might want to invoke.
Creating the xrpcc Conﬁg File
T he xrpcc command-line tool is used to generate ﬁles for the JAX -R PC  API.
Given a W SDL ﬁle, it can create a set of R M I classes, and vice-versa.A conﬁg ﬁle
www.syngress.com

320
Chapter 8 • Using XML-based RPC
called conﬁg.xml is used to determine the various parameters that dictate the tool’s
output.
Developing the Service Implementation
T he next step is to create the actual service implementation.T his class will be
deﬁned as implementing the service interface deﬁned above.T he implementation
will also need the services of ties and other classes to communicate with the
client.T hese classes are generated by xrpcc  passing in the -server argument. X rpcc
will use the conﬁg ﬁle created in the previous step to generate the necessary
classes.
Building the Server WAR File
T he service deﬁnition is packaged as a Web Archive (WAR ) ﬁle.T his WAR  ﬁle is
a specialized JAR  package whose directory structure and mandatory contents are
deﬁned in the Java Servlet Speciﬁcation version 2.3. By packaging a service deﬁ-
nition in this manner it becomes possible to deploy the Service across a wide
variety of platforms.
T he Service Deﬁnition WAR  package contains the following mandatory
items:
■
All service deﬁnition interfaces, each with exactly one interface to
describe the methods available.
■
All implementing classes of these service deﬁnition interfaces.
■
All resources of the service implementations.A resource may include
graphics, static content (such as H T M L), X M L documents and so on.
■
the web.xml deployment descriptor, whose content conforms with that
speciﬁed in the Java Servlet Speciﬁcation version 2.3.T his deployment
descriptor must be within the / W EB-IN F folder relative to the package
root.
T he Service Deﬁnition WAR  package may also contain the following
optional items:
■
Any Serializers or De-serializers to be used for custom data type 
mapping.
■
A W SDL ﬁle that describes the service to be deployed.
www.syngress.com

Using XML-based RPC • Chapter 8
321
O nce packaged into a WAR  ﬁle the web application can be deployed to any
Servlet 2.3-compliant web server.
Creating a Simple 
XML-RPC Server and Client
N ow we will go through the entire process of creating a web service with a
client application to call it.T he ﬁrst step will be to design and create the SDI.As
described earlier in this chapter, this interface will deﬁne those business methods
we will want to make accessible via an R PC  from a remote client.
In this example we will use an on-line library.T his library will offer the
ability to search for books that contain keywords in the titles and return a list 
of books that match.T his service should also offer the ability to check books in
and out.
T he following is an SDI that satisﬁes our business requirements.
import java.rmi.Remote;
import java.rmi.RemoteException;
www.syngress.com
Developing and Deploying a Web 
Service made with the JAX-RPC API
The development and deployment of a Web Service that is built upon
the JAX-RPC API can be summarized in the following steps.
1. Deﬁne your service provider interface.
2. Create an implementation based on that interface.
3. Create a conﬁg ﬁle that describes your web service to xrpcc.
4. Generate the server ties and related classes using xrpcc.
5. Package the server into a WAR ﬁle as per the Servlet 2.3
Speciﬁcation.
6. Deploy the WAR ﬁle to your web server.
Developing & Deploying…

322
Chapter 8 • Using XML-based RPC
public interface ILibrary extends Remote
{
/**
* Performs a search for a book (or books) whose title
* contains the key speciﬁed. Returns a String array
* containing the ISBN numbers of books that matched.
*/
public String[] searchForBook( String key )
throws RemoteException;
/**
* Performs a checkout of a book denoted by the ISBN
* parameter and using the library card number
* provided.
* Returns true the book was checked out successfully.
*/
public Boolean checkOutBook( String ISBN, 
String cardNumber )
throws RemoteException;
/**
* Performs a checkin of a book denoted by the ISBN
* parameter.
* Returns true the book was checked in successfully.
*/
public Boolean checkInBook( String ISBN )
throws RemoteException;
}
H aving completed our service deﬁnition, you need to make the actual service
implementation.T his example does not go into detail as to how to perform the
lookup of the books. Presumably you will have some sort of data store (probably
a relational database) that this class will search for the library book information.
public class LibraryImpl implements ILibrary
{
/**
* Performs a search for a book (or books) whose
www.syngress.com

Using XML-based RPC • Chapter 8
323
* title contains the key speciﬁed.
* Returns a String array containing the
* ISBN numbers of books that matched.
*/
public String[] searchForBook(String key)
{
/*
* Perform the lookup an return the results.
*/
}
/**
* Performs a checkout of a book denoted by the
* ISBN parameter and using the library card number
* provided.
* Returns true the book was checked out successfully.
*/
public Boolean checkOutBook(String ISBN,
String cardNumber)
{
/*
* Checkout the book and return status.
*/
}
/**
* Performs a checkout of a book denoted by the ISBN
* parameter.
* Returns true the book was checked in successfully.
*/
public Boolean checkInBook(String ISBN)
{
/*
* Check in the book and return status.
*/
}
}
www.syngress.com

324
Chapter 8 • Using XML-based RPC
We will use the xrpcc command-line tool that comes with the JW SDP to
generate the stubs, ties and the W SDL ﬁle that will describe our library Web ser-
vice.To conﬁgure xrpcc’s runtime behavior, we will need to create a conﬁg.xml
ﬁle that describes the service and what the tool needs to generate.
In our example we will need to create the following X M L ﬁle:
<?xml version="1.0" encoding="UTF-8"?>
<conﬁguration xmlns="http://java.sun.com/jax-rpc-ri/xrpcc-conﬁg">
<rmi name="LibraryService" targetNamespace="http://210-ch08.org/wsdl"
typeNamespace="http://210-ch08.org/types">
<service name="Library" packageName="websvc">
<interface name="websvc.ILibrary" servantName="websvc.
LibraryImpl"/>
</service>
</rmi>
</conﬁguration>
By virtue of including a child <rmi> element, we have effectively told xrpcc
that we have the R M I class (service deﬁnition interface) and we wish it to gen-
erate the W SDL ﬁle (as well as the usual client stubs and server ties).
U se xrpcc’s -server option to generate only those ties and classes necessary for
the server implementation. O nce this is complete, you should have a list of gen-
erated classes that look like this:
ILibrary_Tie.class
Library_SerializerRegistry.class
CheckInBook_RequestStruct.class
CheckInBook_RequestStruct_SOAPSerializer.class
CheckInBook_ResponseStruct.class
CheckInBook_ResponseStruct_SOAPSerializer.class
CheckOutBook_RequestStruct.class
CheckOutBook_RequestStruct_SOAPSerializer.class
CheckOutBook_ResponseStruct.class
CheckOutBook_ResponseStruct_SOAPSerializer.class
SearchForBook_RequestStruct.class
SearchForBook_RequestStruct_SOAPSerializer.class
SearchForBook_ResponseStruct.class
SearchForBook_ResponseStruct_SOAPBuilder.class
SearchForBook_ResponseStruct_SOAPSerializer.class
www.syngress.com

Using XML-based RPC • Chapter 8
325
Finally, you will want to create a client capable of invoking the service.T he
following is an example of a client application that serves an access point to the
library service. Since the client will reference the stubs for this service, you have
to generate them using xrpcc’s -client option.T his will give you a list of generated
classes that looks like this:
ILibrary_Stub.class
Library.class
Library_Impl.class
Library_SerializerRegistry.class
CheckInBook_RequestStruct.class
CheckInBook_RequestStruct_SOAPSerializer.class
CheckInBook_ResponseStruct.class
CheckInBook_ResponseStruct_SOAPSerializer.class
CheckOutBook_RequestStruct.class
CheckOutBook_RequestStruct_SOAPSerializer.class
CheckOutBook_ResponseStruct.class
CheckOutBook_ResponseStruct_SOAPSerializer.class
SearchForBook_RequestStruct.class
SearchForBook_RequestStruct_SOAPSerializer.class
SearchForBook_ResponseStruct.class
SearchForBook_ResponseStruct_SOAPBuilder.class
SearchForBook_ResponseStruct_SOAPSerializer.class
T he stub class, conspicuously named with the _ Stub sufﬁx, will be the proxy
class through which the client will invoke library functions.
package websvc;
public class LibraryClient
{
private ILibrary_Stub stub;
public LibraryClient( String endpoint ) throws Exception
{
stub = (ILibrary_Stub)( new Library_Impl().getILibrary() );
stub._setProperty( javax.xml.rpc.Stub.ENDPOINT_ADDRESS_PROPERTY,
endpoint );
}
www.syngress.com

326
Chapter 8 • Using XML-based RPC
public String[] searchForBook( String Key )
{
String[] result = null;
try
{
result = stub.searchForBook( Key );
}
catch( Exception e )
{
e.printStackTrace();
}
return result;
}
public boolean checkOutBook( String ISBN, 
String cardNumber )
{
try
{
stub.checkOutBook( ISBN, cardNumber );
}
catch( Exception e )
{
e.printStackTrace();
}                   
}
public boolean checkInBook( String ISBN, 
String cardNumber )
{
try
{
stub.checkInBook( ISBN, cardNumber );
}
www.syngress.com

Using XML-based RPC • Chapter 8
327
catch( Exception e )
{
e.printStackTrace();
}                   
}
}
O nce the client has been compiled and packaged it may be deployed any-
where that it can access the web server hosting the web service we created earlier.
NOTE
These examples were developed against the JAX-RPC speciﬁcation 
version 0.8 PFD.
www.syngress.com

328
Chapter 8 • Using XML-based RPC
Summary
T he JAX -R PC  API offers a fast way to incorporate remote procedure calls into
your distributed heterogeneous application.T his functionality is realized via a
framework that creates remote procedure calls using synchronous X M L messages,
which contain function-call semantics.T hese web services are built on the Java
language and can be deployed on multiple platforms.
T he interface that deﬁnes the methods to be made available as a web service
is called the service deﬁnition.T his interface must extend java.rmi.R emote, and each
method must be declared to throw java.rmi.R emoteE xception.
T he client that wishes to invoke methods on the server and receive execution
results does so through a stub.A stub is a class that serves as a service proxy for
the client.T he server that wishes to be enabled for remote procedure calls must
have a tie class.T his tie class acts as a client proxy for the server. Both the stubs
and ties translate method calls and return values to SO AP-encoded X M L for
transmission over H T T P.
A Web Service Description Language (W SDL) ﬁle describes a Web Service.
T his description includes the service methods and their associated semantics, as
well as the location of the service provider.A client that wishes to use a Web
Service can then use this W SDL ﬁle to determine the service offerings and the
syntax to invoke them.
T he JW SDP provides a command-line driven tool called xrpcc that facilitates
the creation of stubs, ties and the other artifacts necessary to develop web ser-
vices.T his tool is conﬁgured using an X M L ﬁle. Given the SDI or the W SDL
ﬁle, xrpcc can generate all necessary ﬁles.
T he SDI, ties and other generated server artifacts are packaged together in a
Web Archive (WAR ) ﬁle with an internal directory structure and including a
deployment descriptor as deﬁned by the Java Servlet Speciﬁcation version 2.3.
T his WAR  ﬁle, which effectively contains the entire Web Service, may be
deployed on a web server that has been prepared so as to include the necessary
libraries from the JW SDP.
O nce deployed, your Web Service may be invoked by any client, including
(but not limited to) Java based clients.T his interoperability is possible due to the
support for SO AP over H T T P and W SDL in the JAX -R PC.
www.syngress.com

Using XML-based RPC • Chapter 8
329
Solutions Fast Track
JAX -R PC  Summary
 JAX -R PC  API is an API for building web services.
 JAX -R PC  is facilitated by using synchronous X M L messages using
SO AP over H T T P.
M apping Java Data Types
 All Java primitive types (except char) are supported.
 Java classes that are not supported out of the box can be supported using
custom serializers and deserializers.
 JavaBeans are supported by the JAX -R PC  API.
C onversion Between Java C lasses and W SDL
 T he xrpcc command-line tool can create the W SDL service deﬁnition
ﬁle from a proprietary conﬁg ﬁle and a service deﬁnition interface.
 X rpcc and the conﬁg ﬁle that supports it are not part of the JAX -R PC
speciﬁcation and are subject to change in future releases.
 If the W SDL ﬁle already exists, then the R M I class can be generated
from it.
 If the R M I classes already exist, then the W SDL ﬁle can be generated
from them.
C reating a JAX -R PC  C lient
 JAX -R PC  C lients use stubs to communicate with the server.
 T he stubs needed for communication can be generated using xrpcc with
the optional -client argument.
www.syngress.com

330
Chapter 8 • Using XML-based RPC
C reating a JAX -R PC  Server
 JAX -R PC  Servers use ties created by xrpcc to communicate with 
the client.
 T he SDI is that interface which deﬁnes the methods to be published by
the web service.
 A server deﬁnes an endpoint to access the desired service.T his endpoint
is basically a U R L that gets mapped to the service implementation.
C reating a Simple X M L-R PC  Server and C lient
 We created a web service with an asociated client application.T he ﬁrst
step was to design and create the SDI, which deﬁned those business
methods we wanted to make accessible via an R PC  from a remote client.
 We used the xrpcc command-line tool that comes with the JW SDP to
generate the stubs, ties and the W SDL ﬁle to describe our Library Web
Service.To conﬁgure xrpcc’s runtime behavior, we had to create a
conﬁg.xml ﬁle to describe the service and what the tool needed to
generate.
 We included a child <rmi> element to tell the xrpcc tool that we had
the R M I class (SDI) and we wished it to generate the W SDL ﬁle (as
well as the usual client stubs and server ties).
 O nce the client was compiled and packaged, it could be deployed
anywhere that it could access the web server hosting the web service we
created earlier.
www.syngress.com

Using XML-based RPC • Chapter 8
331
Q: W hat are some of the JAX -R PC  API-related concerns that I might need to
address in the design of my application?
A: X M L-R PC  is a synchronous communication framework.T herefore, your
remote method calls will block until the result of the method invocation
comes back over the wire.Architecture considerations include designing your
remote method calls to pass as much data as possible in order to minimize the
number of connections you’ll need to make.Another consideration is to
make those classes that perform the actual remote method invocation
threaded and/ or pooled so as to provide some measure of decoupling with
the rest of the client application.
Q: H ow can I improve the speed or efﬁciency of my client’s remote 
procedure calls?
A: A common technique for improving efﬁciency is to design your SDI to per-
form several functions with one method call. By bundling functionality over a
single H T T P request you can improve your client’s overall performance of.
Another approach would be to pool instances that call the service.
Q: C an I obtain the source code for the generated ties and stubs?
A: T he xrpcc command-line tool will normally remove any generated Java
source ﬁles after successful compilation.You can override this behavior by
using the -keep argument.T his will instruct the tool to leave the source ﬁles
where it compiled the class ﬁles.
Q: H ow can I use web services built with the JAX -R PC  API if I do not know
the signatures of the methods I want to call until runtime?
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

332
Chapter 8 • Using XML-based RPC
A: T he use of Dynamic Invocation Interfaces (DII) would solve your problem.
Due to the complexity and difﬁculty in debugging such clients, it is not gen-
erally recommended to use DII unless there is no other alternative.T he JAX -
R PC  speciﬁcation covers this functionality in greater detail.
Q: W hat are the differences between stubs and ties?
A: Both deal with the marshalling and unmarshalling of data.T hey both take
data in the form of X M L containing method call semantics and convert the
data to and from network transport formats.T he stubs perform this function
on the C lient side and the ties perform this function on the Server side.
www.syngress.com

Locating Web
Services
Solutions in this chapter:
■
Registries
■
Categorizing Web Services
■
Connecting to a Registry
■
Querying the Registry
■
WSDL Documents
■
Storing Information in a Registry
Chapter 9
333
 Summary
 Solutions Fast Track
 Frequently Asked Questions

334
Chapter 9 • Locating Web Services
Introduction
To call a Web service, several pieces of information are required. In particular, the
location (U R L) of the service and the schema to pass requests in are critical for a
message to be understood by the right remote service.
T he simplest means of deriving this information is by hand.You can, for
instance, communicate with a fellow programmer or use Web sites such as
www.xmethods.com to ﬁnd out the relevant information. H owever, the problem
with this method is that with the Web being a ﬂuid environment, new services
are added and old ones removed continually. C onsequently, evaluating the con-
nection protocol for a Web service by hand calls for a lot of maintenance work to
ensure the system continues to run smoothly.
To solve this problem,Web services can be published to registries.A registry is
a collection of meta-information about Web services such as their location, the
protocol used to contact them and so forth.W hile registries were originally seen
as a global mechanism— where companies published Web services for anonymous
business partners to ﬁnd— more commonly, registries are being used internally by
organizations to render service-based architectures more resilient and reliable.
In this chapter, we will explore JAX R , the Web Services Developer Pack
component employed for communicating with registries.Additionally, we will
introduce W SDL, the standard mechanism for describing the schema with which
to call a remote service.
Registries
As mentioned in the introductory paragraph, a Web service registry contains
information about Web services and their providers.T he utility of registries lies in
the fact that they can be searched by Web service clients to obtain data on avail-
able Web services. In this section, we discuss how the metadata about services is
stored and also the standards upon which the registries are built.
Storage of Metadata about Services
A registry entry stores information about an organization such as:
■
T he name of the organization 
■
T he description of the organization
■
A collection of services offered by the organization
www.syngress.com

www.syngress.com
■
T he name of the person who is the primary contact for the organization
■
T he postal address of the organization
■
A key object that represents the ID through which an organization entry
is uniquely identiﬁed by the registry and so on 
In most cases, a service seeker or client would be looking for services per-
taining to a speciﬁc industry sector.T hus, the client is less likely to search for a
speciﬁc organization by name; instead, he is more likely to choose an industry
sector to search for organizations that offer the desired services in that sector. In
view of this, the registry uses classiﬁcations to categorize the information in the
registry database.We now discuss how information in the registry is categorized.
C ategories 
T he N AIC S (N orth American Industry C lassiﬁcation System) is used for catego-
rizing various businesses/  services, classifying business establishments on the basis
of their major economic activity.T he classiﬁcation is production-oriented in the
sense that it groups similar services or production processes.
N AIC S groups services into 20 broad economic activity categories such as
M anufacturing,W holesale Trade, Information, Finance, Insurance, and so on.
T hese economic activity categories are subdivided into subsectors. For example,
M anufacturing has Food M anufacturing as a subsector. Each subsector is divided
into industry groups. For example, Bakery and Tortilla M anufacturing is an
industry group under the Food M anufacturing subsector.An industry group is
ﬁnally divided into various N AIC S industries.T hough there are no further sub-
classiﬁcations beyond this level, the N AIC S industries may be further divided to
accommodate variations in U.S., C anadian, and M exican industry nomenclatures.
Figure 9.1 illustrates this classiﬁcation of services concept.
T hus, categories are subdivided and organized in a tree hierarchy until they
can be subdivided no further. (C ategorizing concepts will be clariﬁed further
when we choose a classiﬁcation for our organization in the section,“U sing the
Default R egistry.” See Figure 9.4 later in the chapter for an illustration of this).
T here are a total of 1,170 N AIC S categories, out of which 474 lie in the
M anufacturing sector. N AIC S uses a standard coding structure for assigning codes
to the categories. Each industry is assigned a six-digit code.T he ﬁrst two digits of
this code specify the economic activity category, the third digit speciﬁes the sub-
sector, the fourth digit the industry group, the ﬁfth digit the N AIC S industry, and
the sixth digit is for U.S., C anadian, and M exican industries.
We shall now discuss categorizing of services on the basis of location.
Locating Web Services • Chapter 9
335

336
Chapter 9 • Locating Web Services
Locations
T he geographical location of the service provider is an important criterion for
the service seeker.T his is especially true in the case of business transactions that
will eventually involve transportation of physical goods from the manufacturer to
the buyer because, the geographical location will determine to a great extent the
transportation cost as well as the delivery schedules in terms of time required for
transportation.
T he iso-ch:3166:1999 taxonomy for geographical regions is followed for clas-
sifying the location for a service.T his taxonomy divides the physical locations on
the basis of continents such as Asia, Europe, N orth America, and so on, or major
continent-regions such as the C aribbean, the M iddle East, and so on.T hese con-
tinents/ continent-regions are subdivided into countries. For example, N orth
America is subcategorized into the following N orth American countries: the
U.S.A., C anada, and M exico.
Major Registry Standards
In order to understand JAX R , you must ﬁrst understand that it provides a stan-
dardized interface to common registry standards. JAX R  simpliﬁes the utilization
of these registries, and ensures that code written for one registry can be moved
transparently to another. In particular, JAX R  provides interfaces for the most
commonly used registry standards for Web services: U DDI and ebX M L R egR ep.
www.syngress.com
Figure 9.1 Categorizing Business Services in a Registry
Manufacturing
Economic Activity Category
Food Manufacturing
Subsector
Bakeries and Tortilla
Manufacturing
Industry Group
Cookie, Cracker, and
Pasta Manufacturing
NAICS Industry
Cookie and Cracker
Manufacturing
U.S./ Canadian/ Mexican Industry

Locating Web Services • Chapter 9
337
U DDI
U niversal Description, Discovery, and Integration (U DDI) is an open speciﬁca-
tion that strives to implement a universal business registry capable of integrating
electronic commerce sites. U DDI is a project initiated by the concerned industry
sectors and businesses.T he aim of U DDI is to create a platform-independent,
global, and open speciﬁcation for the following purposes:
■
To enable vendors to offer/ describe their services and businesses
■
To enable potential buyers to search for these services and businesses
■
To integrate these services and businesses over the Web
In short, U DDI aims at propelling the growth of business-to-business (B2B)
e-commerce. U DDI does not concentrate on the listing and ﬁnding of services
alone. It also addresses the problem of the lack of a standard mechanism to con-
duct business, once a buyer has found a suitable service provider. U DDI tackles
this issue by enabling vendors to programmatically specify their preferred business
practices and procedures.
T he U DDI speciﬁcation is implemented as the public U DDI Business
R egistry that is elemental to the infrastructure that supports e-commerce.T he
U DDI Business R egistry is implemented as a set of distributed registries on Web-
enabled media.Vendors can register their services and businesses with these reg-
istries and buyers can browse them to search for vendors and/ or services.T he
distributed U DDI registries are maintained as registry nodes, where each node is
managed by an operator who is bound by an agreement to follow the policy and
quality of service guidelines formulated by an O perator’s C ouncil (IBM  and
M icrosoft are two such operators who are currently operating registry nodes).
Each registry node contains a complete set of the records registered with all the
registry nodes taken together.T his is achieved by regularly replicating the regis-
trations across all the nodes.T he operators use a common set of APIs to ensure
that all the nodes can exchange information with one another.
T hough the original intent of U DDI was to have global registries accessible
over the Internet, organizations are implementing private registries, compliant
with the U DDI speciﬁcation, on their intranets, extranets, or private networks on
the Internet.T hese private registries may offer functionality and services tailored
for speciﬁc authorized users. For example, a private registry may catalog an orga-
nization’s services that can be located over the organization’s private networks
with trading partners, or be used for internal reference purposes.
www.syngress.com

338
Chapter 9 • Locating Web Services
T he U DDI Business R egistry structure categorizes information under the
following headings:
■
Business-Entity A business entity is a unique identiﬁer for an entry in
the registry. Besides this, it contains the following information:
■
T he name of the business.
■
A short description of the service/ business.
■
Basic contact information regarding the vendor.
■
A list of categories that describe the service/ business.
■
A U R L that provides more information about the service/ business.
■
Business Service T he business service lists the services/ businesses
offered by an entity. Each of these service/ business entries contain the
following information:
■
A description of the service/ business.
■
A list of categories that describe the service/ business.
■
A list of pointers pointing to locations where related information
about the service/ business can be found.
■
Speciﬁcation Pointers Each business service entry contains a list of
speciﬁcation pointers.T hese speciﬁcation pointers serve a dual purpose.
■
T hey point to those U R Ls where information related to a business
service can be found.T hese U R Ls, in turn, may contain information
on how to invoke a service.
■
T hey associate a business service entry with a particular service type.
■
Service Types A service type deﬁnes the nature of a business service,
and can include multiple categories. It is deﬁned by a tM odel, which
contains the following information:
■
T he name of the tM odel.
■
T he name of the organization that published the tM odel.
■
A list of categories that describe the service type.
■
Technical speciﬁcations for the service type such as protocols, inter-
face deﬁnitions, message formats and so on.
www.syngress.com

Locating Web Services • Chapter 9
339
U DDI uses the Simple O bject Access Protocol (SO AP). H owever, a service
registered with U DDI can use any Internet protocol such as SO AP, C O M +,
ebX M L M essage Service, C O R BA, Java R M I, and so on for its service interface
(T he interface that is used to invoke the service).
NOTE
A UDDI registry, though searchable, is very different from a search
engine. Search engines are meant to search unstructured and random
data related to any ﬁeld, such as education, industry, society, and so on.
A UDDI registry, however, is highly structured and is speciﬁcally meant
for offering services and businesses. Instead of a random search, it sup-
ports one focused on industry, product category, and geographical loca-
tion. A search engine, however, can use the UDDI registry as a source
while producing search results.
ebX M L
ebX M L is a suite of speciﬁcations that deﬁnes standard methods to enable busi-
ness transactions over the Web. It details methods for deﬁning and registering
business processes, exchanging business data and messages and conducting busi-
ness relationships, and includes searchable public repositories (like the U DDI
R egistry) where services/  businesses can be registered. ebX M L is designed to be
platform-independent so that any system that supports X M L, the standard
Internet protocols, and, of course, ebX M L, can transact e-business using ebX M L.
ebX M L is an initiative backed by U N / C EFAC T  (U nited N ations C entre for
Trade Facilitation and Electronic Business) and O ASIS (O rganization for the
Advancement of Structured Information Standards). (U N / C EFAC T  is a U nited
N ations body whose mission is to facilitate international transactions by standard-
izing business procedures and harmonizing information ﬂow. O ASIS, on the
other hand, is a global consortium that develops standards for Web services, elec-
tronic publishing, business transactions on the Internet and elsewhere, and
encourages adoption of e-business standards.)
Extensible M arkup Language (X M L) is at the core of ebX M L, and was
chosen for ebX M L because it allows exchange of structured data like the data
stored in databases and is a freely available standard for information exchange
www.syngress.com

340
Chapter 9 • Locating Web Services
widely supported by the industry.Another advantage is that X M L supports
U nicode that can display most of the world’s languages.
T he ebX M L architecture is composed of two parts:
1. Product Architecture T he product architecture constitutes the tech-
nical infrastructure of the software. It consists of the following elements:
■
Messaging Service T his is a protocol-neutral service that standard-
izes the way business messages are exchanged between trading orga-
nizations.T his messaging service is secure and reliable and also allows
for routing a message to an internal application once an organization
has received it.Any standard protocol such as FT P, H T T P, SM T P
and so on can be employed for ﬁle transfer while using the mes-
saging service.Additionally, all communications with the R egistry
are possible only through the use of the ebX M L messaging service.
■
Registry An ebX M L R egistry is akin to the user interface of a
repository.T he registry stores information about items that are actu-
ally stored in the repository.T he repository items can be created,
modiﬁed or deleted through requests made to the registry. ebX M L
speciﬁes a minimum information model (that deﬁnes the types of
information stored in the registry) and the manner in which other
applications interact with the registry, but it does not specify the
implementation of the registry or repository.T he registry contains
information such as business documents or agreements, component-
deﬁnition for business process modeling, and so on.T he ebX M L
R egistry is a single one as against the distributed registry network of
U DDI (which can be used to locate an ebX M L registry).
■
Trading Partner Information T he C ollaboration Proﬁle Protocol
(C PP) is used to deﬁne an X M L document that details the manner
in which an organization can conduct e-business.T hese details
include information about the organization such as the types of pro-
tocol used by it, security implementations, network addresses, and
business procedures.T he C ollaboration Protocol Agreement (C PA)
speciﬁes how two trading partners have agreed to conduct business
electronically.T he ebX M L speciﬁcation includes issues involved in
creating a C PA from the C PPs of the two parties that intend to con-
duct business, though it does not specify the algorithm for gener-
ating the C PA.
www.syngress.com

Locating Web Services • Chapter 9
341
■
Business Process Speciﬁcation Schema (BPSS) T his schema
deﬁnes an X M L document (as an X M L DT D) to describe how an
organization conducts its business. N ote that C PP or C PA deals with
how an organization conducts e-business while BPSS deals with the
actual business process.T his includes the business transactions, docu-
ment ﬂow, business level acknowledgements, legal and security aspects,
and so on.T he BPSS can be used by an application to conﬁgure the
details of conducting e-business with a chosen business partner.
2. Process Architecture T he process architecture is meant for analysis
and development.T his architecture provides the following contributions:
■
Business Process Analysis Worksheet and Guidelines T he
Business process Analysis worksheets and the guidelines for using them
assist in collecting the information necessary to describe a business
process.T his information can be used to create a BPSS X M L docu-
ment. Business Process Editors can be developed on the basis of the
worksheets.T hese editors can guide the user in collecting information
and automatically generating the X M L business process speciﬁcation.
■
Catalog of Common Business Processes T his catalog contains
description of common business processes being used by various
organizations.
■
E-Commerce Patterns T he e-commerce patterns contain descrip-
tions and examples of the common business patterns.To date, only one
pattern has been listed, which is for simple contract formation.
■
Core Components T he core components are the basic informa-
tion elements used in business messages.T he type of information for
these core elements may vary with industry, geographical location,
and so on.T he core components are developed from existing or new
business documents and analyzed so as to standardize them for use in
speciﬁc industries or regions.T hese business messages and documents
exchanged in a business process are composed of the core compo-
nents that are also known as “business information objects.”
T he product and process architecture are linked through the BPSS that is a
machine or software application interpretable encoding of a business process.
T hus, ebX M L provides a standard structure and syntax on which developers
can build packaged applications for the smooth exchange of business data.
www.syngress.com

342
Chapter 9 • Locating Web Services
R eaders should note that though U DDI and ebX M L R egR ep address the
same issue, U DDI is a speciﬁcation backed by an industry-led consortium,
whereas ebX M L is an open standard.
Categorizing Web Services
Web services receive, process (if required), and respond to requests from Web-
clients.T hey encompass any self-contained software component/ application or
piece of code that can be deployed on a Web server, and subsequently be invoked
over the Web by Web-clients.T he realm of Web services varies from simple
acknowledgement of a client’s request to complex business processes. If Web ser-
vices are to cater to businesses, it is imperative that data on Web services should
be categorized to create a semblance of order to make them searchable. In this
section, we discuss how Web services can be categorized.
Category Hierarchies
As mentioned in the section,“Storage of M etadata about Services,” categorization
is crucial for proper organization and maintenance of a business registry. Since
JAX R  APIs are speciﬁcally meant for use with business registries, they obviously
contain provisions to categorize registry objects.
T he C lassiﬁcationScheme interface in the javax.xml.registry.infomodel package is a
subinterface of the R egistryO bject interface and is used to represent a taxonomy
that may be used to categorize R egistryO bject instances.T he R egistryO bject class is
an abstract class that provides the minimal metadata for various registry objects.
For example, in Figure 9.1, Industry is the classiﬁcation scheme that has been used
to categorize the services. If we categorize services or organizations on the basis
of their geographical location, then G eography would be the classiﬁcation scheme.
A C lassiﬁcationScheme instance can be used to obtain, add, or remove child con-
cepts from a classiﬁcation scheme. (A concept, meanwhile, is used in JAX R  to hold
the information about a speciﬁcation.) T he C lassiﬁcationScheme interface provides
numerous methods to set or retrieve information about classiﬁcation schemes.
Some of these methods, whose names are self-explanatory, are addC hildC oncepts(),
getC hildC oncepts(), addC lassiﬁcations(), removeC lassifcations(), and so on.
W hile the C lassiﬁcationScheme interface refers to a classiﬁcation scheme, the
C lassiﬁcation interface is used for actual classiﬁcation of R egistryO bject instances.
Adding C lassiﬁcation instances to the R egistryO bject classiﬁes the R egistryO bject
www.syngress.com

Locating Web Services • Chapter 9
343
along multiple dimensions.T hese dimensions could be the industry, the products,
and the geographical location.
T he C lassiﬁcation interface allows the classiﬁcation of R egistryO bjects using a
C lassiﬁcationScheme.T his C lassiﬁcationScheme may represent an internal taxonomy
(in which the taxonomy elements and their structural relationship with one
another is represented within the registry provider) or an external taxonomy (in
which the taxonomy elements and their structural relationship with one another
is represented outside the registry provider).A C lassiﬁcation instance that uses a
C lassiﬁcationScheme representing an internal taxonomy is known as an internal
classiﬁcation.W hereas, a C lassiﬁcation instance that uses a C lassiﬁcationScheme rep-
resenting an external taxonomy is known as an external classiﬁcation.T he
C lassiﬁcation interface provides a number of methods to set or retrieve classiﬁca-
tion schemes and information related to a registry object.T hese methods include
getC lassiﬁcationScheme(), setC lassiﬁcationScheme(), getC oncept(), setC oncept(),
getC lassiﬁedO bject(), and so on.
Example Hierarchies
T he most common and widely-known example of a classiﬁcation scheme is the
classiﬁcation of the world into living and non-living objects. Living things are
further classiﬁed into plants and animals, animals are classiﬁed into mammals, and
so on.T hus, living things are classiﬁed under a tree-like structure.
Another example, more appropriate to the current discussion, is that of the
N AIC S (N orth American Industry C lassiﬁcation System) used to classify busi-
nesses and services on the basis of the industry to which they belong.As
explained in the subsection,“C ategories,” under the section,“Storing M etadata
about Services,” the N AIC S breaks up a broad industry sector into subsectors, in
a hierarchical pattern, right up to the point where the industry narrows down to
its smallest logical unit.
Organization, User
An organization is the physical entity that represents an entry in a business reg-
istry.T he Web services being offered and searched for in a registry are eventually
offered by an organization that makes it possible for the requested service to be
executed.
T he javax.xml.registry.infomodel provides the O rganiz ation interface to encom-
pass this physical entity (the organization).As mentioned in the section,“Storing
M etadata about Services,” an organization has distinguished parameters such as
www.syngress.com

344
Chapter 9 • Locating Web Services
the name of the organization, its description, its postal address, the primary con-
tact person in the organization, telephone number, e-mail address for the contact,
services offered by the organization, and so on.T hus, the O rganization interface
that represents an organization provides methods to retrieve this organizational
information when a registry is searched.T hese methods include getN ame(),
getD escription(), getServices(), getP rimaryC ontact(), and so on.
A vendor who uses a business registry to offer services, submits the relevant
information to the registry in the form of an O rganiz ation instance. H ence, the
O rganiz ation interface also encompasses methods to create an organization and set
its data such as name, description (setD escription()), services (addServices()), and so on.
T hough an organization is a physical entity, it remains abstract in nature. It is
the people working in the organization that give it a deﬁnitive structure and a tan-
gible physical form.T herefore, a primary contact person, his/ her telephone
number/ e-mail address, and so forth are a part of the organizational data stored in a
business registry.To add the primary contact person information to an organization,
the javax.xml.registry.infomodel package provides the U ser interface.T he U ser interface
supplies methods to set the primary contact information, such as the person’s name
(setP ersonN ame()), his/ her telephone number (setTelephoneN umbers()), e-mail ID
(setE mailA ddresses()), and so on. O n the querying side, the U ser interface provides
methods to retrieve information about the primary contact using methods such as
getP ersonN ame(), getTelephoneN umbers(), getE mailA ddresses(), and so on.
N ote that the U ser interface is closely connected to the O rganiz ation interface
and the contact person information is automatically retrieved within the
O rganiz ation instances returned upon searching a registry. Similarly, after a U ser
instance is created and relevant information is added to it, the setP rimaryC ontact()
method of the O rganiz ation interface is used to set the U ser instance information
within the current O rganiz ation instance.W hen the O rganiz ation instance is sub-
mitted to the registry, the U ser information is also submitted.
Connecting to a Registry
T he ﬁrst step in searching a business registry is connecting to it. In this section,
we discuss how various interfaces/ classes in the Java API for X M L R egistries,
JAX R  can be used to programmatically connect to a business registry.
To connect to a registry, we create a client program using JAX R .T he client
program begins by setting properties that deﬁne the U R L for the registry being
accessed and the class that implements the connection factory for the registry. For
www.syngress.com

Locating Web Services • Chapter 9
345
example, the following lines of code set the U R L for IBM ’s test query registry
(U DDI registry) that we shall be using for the examples in this chapter:
Properties props = new Properties();
String curl = "http://www-3.ibm.com/services/uddi/v2beta/inquiryapi";
props.setProperty("javax.xml.registry.queryManagerURL", curl);
We now set the class for the connection factory implementation of the
U DDI registry through the following line of code:
props.setProperty("javax.xml.registry.factoryClass",            
"com.sun.xml.registry.uddi.ConnectionFactoryImpl");
T he next step is to instantiate the factory class and set its property as follows:
ConnectionFactory factory = ConnectionFactory.newInstance();
factory.setProperties(props);
T he javax.xml.registry package in JAX R  provides the C onnection interface
that actually initiates a connection or session with the registry provider.We use
the connection factory instance to create the connection as in the following line
of code:
Connection connection = factory.createConnection();
If the client is behind a ﬁrewall, then to access the registry, you must specify
the proxy host address and port on which the proxy service is running.T his can
be achieved by setting the proxy host and proxy port properties as shown in the
following lines of code:
String httpProxyHost = "HostIPAddress";
String httpProxyPort = "ProxyPortOnHost";
props.setProperty("javax.xml.registry.http.proxyHost", httpProxyHost);
props.setProperty("javax.xml.registry.http.proxyPort", httpProxyPort);
All the preceding steps performed by the client to connect to the registry
have been combined into the method connection() that has been included in the
class D oconnect that returns a C onnection object.T he code for the D oconnect class is
listed in Figure 9.2.
www.syngress.com

346
Chapter 9 • Locating Web Services
Figure 9.2 Connecting to a Registry Using the Doconnect Class
import javax.xml.registry.*; 
import javax.xml.registry.infomodel.*; 
import java.net.*;
import java.util.*;
public class Doconnect
{
Connection connection1;
public Doconnect()
{}
/* This method will make a connection to the Registry server. This will
use the IBM UDDI registry server*/
public Connection connection()
{
/* Use these two string values to provide the ProxyHost and Proxyport*/
String httpProxyHost = "";
String httpProxyPort = "";
String curl = "http://www-3.ibm.com/services/uddi/v2beta/inquiryapi";
String purl = 
"https://www-3.ibm.com/services/uddi/v2beta/protect/publishapi";
Properties props = new Properties();
props.setProperty("javax.xml.registry.queryManagerURL", curl);
props.setProperty("javax.xml.registry.lifeCycleManagerURL", purl);
props.setProperty("javax.xml.registry.factoryClass", 
"com.sun.xml.registry.uddi.ConnectionFactoryImpl");
props.setProperty("javax.xml.registry.http.proxyHost", httpProxyHost);
props.setProperty("javax.xml.registry.http.proxyPort", httpProxyPort);
try 
{
// Create the connection, passing it the 
// conﬁguration properties
ConnectionFactory factory = ConnectionFactory.newInstance();
www.syngress.com
Continued

Locating Web Services • Chapter 9
347
factory.setProperties(props);
connection1 = factory.createConnection();
System.out.println("Created connection to registry" + 
connection1);
}
catch (Exception e) 
{
e.printStackTrace();
}
return connection1;
}
}
T he class D oconnect has been used in the SimpleQ uery class listed later in the
chapter in Figure 9.9 (and also in subsequent classes) to connect to the registry.
T he conﬁrmation line that the connection() method in the D oconnect class outputs
upon successfully connecting to the registry can be seen in Figure 9.10 that
shows the output for the SimpleQ uery class. (N ote the line C reated C onnection to
registrycom.sun.xml.registry.uddi.C onnectionImpl@ e83912 in Figure 9.10.)
Using the Default Registry
T he Java W SDP package comes complete with a W SDP R egistry Server that
deﬁnes the default R egistry.To use this default registry, you need to perform the
following steps:
1.
Place the bin directory of your JW SDP installation in your PAT H  vari-
able, or, go to this directory at the command prompt.
2.
Start Tomcat using the command startup for W indows and startup.sh
for a U nix system. Start the X indice database using xindice-start on
W indows and xindice-start.sh on U nix.
3.
Start the JAX R  R egistry Browser (the R egistry Browser acts as a 
JAX R  client that can be used to search registries and submit data to 
the registries) using the command jaxr-browser on W indows and 
jaxr-browser.sh on U nix. N ote that if you are using the default registry,
www.syngress.com
Figure 9.2 Continued

348
Chapter 9 • Locating Web Services
you need not specify the proxy host and proxy port as command-line
arguments.
4.
In the R egistry Location drop-down list on the browser, choose the
U R L: http:/ / localhost:8080/ registry-server/ RegistryServerServlet.
You need not change the localhost setting for the default registry server
running on your computer.
You can now add an organization to the default registry, delete an organiza-
tion from it, or query it.
NOTE
As of the time of writing this chapter, a bug in the Default Registry pre-
vents the username and password from being authenticated. A fatal
error is reported when you try to submit the authentication information.
Therefore, we are using the IBM registry to explain the process of adding
an organization to the registry and querying the registry. 
Adding an O rganization
We use the IBM  test registry to show how you can add an organization 
to the IBM  registry using the R egistry Browser. C hoose the U R L 
https:/ / www-3.ibm.com/ services/ uddi/ v2beta/ protect/ publishapi
from the Registry Location drop-down list.T his will bring up a user inter-
face (as shown in Figure 9.3) that seeks information about the organization
(chieﬂy, the name, description, primary contact, phone, e-mail, and so on).
Leave the Id ﬁeld blank, the ID will be allocated to you by the registry upon
successful submission. C lick the Add button under the C lassiﬁcations label to add
classiﬁcations.T his prompts a pop-up window, as shown in Figure 9.4.
T he classiﬁcations follow the N AIC S (N orth American Industry
C lassiﬁcation System) that classiﬁes various industry/ service sectors.T he classiﬁ-
cations window also allows classiﬁcation on the basis of location. C lick the label
ntis-gov:naics:1997 in the classiﬁcations window and choose the sector that
best describes your company services.You can choose only one industry sector
for classiﬁcation. If, however, your company activities lie in multiple sectors, you
need to create a separate entry for each sector. C lick the label iso-ch:3166:1999
in the classiﬁcations window to specify the location. Just as for the industry
www.syngress.com

Locating Web Services • Chapter 9
349
sector, you can choose only one location for an entry. If your company is active
at more than one geographical location, you have to make an entry for each of
the locations separately. C licking the Add button in the classiﬁcations window
will include your organization in the chosen industry sector/ location as can be
seen from the two text ﬁelds under the C lassiﬁcations Add/ R emove button in
Figure 9.3 (T he number 51121 given against the text Software P ublishers is a value
that uniquely identiﬁes an industry sector in the N AIC S taxonomy). N ow click
the Submit button (see Figure 9.3) to submit your organization information to
the registry.T his will result in a pop-up window that asks for a username and
password, as shown in Figure 9.5.
www.syngress.com
Figure 9.3 The Registry Browser’s User Interface
Figure 9.4 Choosing an Industry Sector for Classiﬁcation

350
Chapter 9 • Locating Web Services
NOTE
To publish to the IBM registry, you are required to ﬁrst obtain a username
and password. To obtain the username and password, go to the URL
https://www-3.ibm.com/services/uddi/v2beta/protect/registry.html
and click the Get An IBM ID And Password link. The resulting page pro-
vides you with the option of registering for an IBM UDDI Account. Follow
the guidelines provided on this page and obtain an IBM ID and password.
As in the case of a mail account, your username should be unique to the
registry.
Enter the username and password for your IBM  U DDI Account. O nce the
registry accepts your submission, you will be required to provide this username
and password for authentication every time you seek to modify your organiza-
tion’s information in the registry. C licking the OK button in the authentication
window will submit your registration information to the registry and you will
receive a conﬁrmation of successful registration along with a unique ID as shown
in Figure 9.6.
T his key uniquely identiﬁes your organization’s entry in the registry.To check
that your organization has been added to the registry, you can query the registry
by entering your organization’s name in the query interface (See the next sec-
tion,“Q uerying the R egistry” to ﬁnd out how you can query the registry). For
example, when we entered Syngress Test (this was the organization name we gave
to the submission we made to the IBM  registry) as the search criterion in the
organization-name ﬁeld, we obtained query results as shown in Figure 9.7.
www.syngress.com
Figure 9.5 The Authentication Window 
Figure 9.6 The Conﬁrmation Message When an Organization Is Added to 
the Registry

Locating Web Services • Chapter 9
351
N ote that the N ame and D escription column (see Figure 9.7) contain the name
and description of our organization as entered by us while registering our orga-
nization with the registry.Also, the key value under the K ey column is the one
that the message box (Figure 9.6) had displayed on successful submission of our
entry.
NOTE
The Registry Browser allows you to add or delete organizations, but does
not support modifying organizations. If you try to modify an organiza-
tion, a new organization is created when you submit the modiﬁed data. 
Q uerying the R egistry
To query the IBM  test registry, choose the U R L http:/ / www-3.ibm.com/
services/ uddi/ v2beta/ inquiryapi from the Registry Location drop-down
list.T his brings up a search interface that allows you to query the registry based on
the name of an organization or on a classiﬁcation (see the Find By option in Figure
9.8). Let us assume that we search for organizations by name and enter the letter I
as the search criterion. Enter I in the text ﬁeld labeled N ame (see Figure 9.8).T he
query returns organizations whose name begins with the letter I (as shown in the
same ﬁgure).
T he R egistry Browser displays the name and description for the organizations
returned in the query results.T he K ey column in Figure 9.8 lists the key that
uniquely identiﬁes an entry of an organization in the registry.
www.syngress.com
Figure 9.7 Searching for Your Organization in the Registry

352
Chapter 9 • Locating Web Services
To query the registry on the basis of C lassiﬁcations, choose the
Classiﬁcations option from the options against the F ind by label in Figure 9.8.
You may choose a classiﬁcation on the basis of an industry sector or on the basis
of location (just as we had done while adding an organization). C licking the
Search button displays results based on the classiﬁcation you choose.
NOTE
The default registry uses a single URL http://localhost:8080/registry-server/
RegistryServerServlet for both adding an organization, as well as querying
the registry. You can switch between the two options by clicking the
Submissions and Browse buttons, respectively (see Figure 9.3). The pro-
cedure for adding an organization or querying the default registry is the
same as what we used in the case of the IBM test registry. 
However, note that the default registry does not allow wild card 
pattern matching for the search criterion. For example, if you specify
%software% in the case of the IBM test registry, it will search for organi-
zations in whose name software occurs anywhere. The default registry,
however, does not allow the use of the percent (%) sign for pattern
matching. 
www.syngress.com
Figure 9.8 Querying the Registry

Locating Web Services • Chapter 9
353
Querying the Registry
U pon successful connection with a registry, the next step is to query the 
registry to locate speciﬁc vendors and/ or services.T he ServiceR egistry interface 
in the javax.xml.registry package enables the client program to obtain the 
interfaces being used by the C onnection class to connect to the registry.T he
B usinessQ ueryM anager interface in the javax.xml.registry package supports various
methods to search for data in a registry using the JAX R  information model. In
this section, we discuss how these interfaces can be used to query a registry.
Finding a Service Using a Simple Query
We begin with a simple query that tries to search for organizations in the 
IBM  registry whose name begins with the letter A . First of all, we obtain the
ServiceR egistry object and use it to create a B usinessQ ueryM anager object as shown
in the following lines of code:
RegistryService myservice = connection.getRegistryService(); 
BusinessQueryManager bqmanager = myservice.getBusinessQueryManager();
H ere, connection is the connection object used to connect to the registry.We
now create two C ollection objects, the ﬁrst one storing the sorting order for the
search results, and the second one the pattern that we want to search for in an
organization’s name:
Collection ﬁndQualiﬁer = new ArrayList();
ﬁndQualiﬁer.add(FindQualiﬁer.SORT_BY_NAME_DESC);
Collection namePattern = new ArrayList();
namePattern.add("A");
T he preceding code speciﬁes that the results be sorted alphabetically and des-
ignates A as the string pattern we are searching for. N ext, we use the
ﬁndO rganiz ations() method of the B usinessQ ueryM anager object to search the reg-
istry.T he ﬁndO rganiz ations() method returns a B ulkR esponse object (which is a
collection of objects) as shown next:
BulkResponse response = bqmanager.ﬁndOrganizations(
ﬁndQualiﬁer, namePattern, 
null, null, 
null, null);
www.syngress.com

354
Chapter 9 • Locating Web Services
T he ﬁndO rganiz ation() method accepts the collections, ﬁndQ ualiﬁer and
namePattern, that respectively specify the qualiﬁers for the search and pattern to be
matched.T he remaining four parameters (speciﬁed as null) are also collections
that may specify classiﬁcations, speciﬁcations, external identiﬁers, and external
links for the organizations.T he method searches for organizations that satisfy all
the search conditions speciﬁed by the collections passed to it as parameter values.
Since the BulkR esponse received is a collection of objects, we retrieve it in a
C ollection variable as follows:
Collection orgs = response.getCollection();
U sing an Iterator object, we loop through the collection, obtaining names of
organizations and the services offered by them as shown in the following code
snippet:
Iterator orgIter = orgs.iterator();
while (orgIter.hasNext()) 
{
Organization org = (Organization) orgIter.next();
String name = (org.getName()).getValue();
}
T he services offered by an organization are obtained using the getServices()
method that returns a collection of services.T he following code snippet iterates
through the services for an organization:
Collection services = org.getServices();
Iterator svcIter = services.iterator();
while (svcIter.hasNext()) 
{
Service svc = (Service)svcIter.next();
String sname = (svc.getName()).getValue();
}
Figure 9.9 lists the code for the class SimpleQ uery that executes a simple
query using its query() method. N ote that the SimpleQ uery class instantiates the
D oconnect class to connect to the registry using the following lines of code:
Doconnect myconnection = new Doconnect();
connection = myconnection.connection();
www.syngress.com

Locating Web Services • Chapter 9
355
If the connection is successful, the D oconnect class (Figure 9.2) returns a
C onnection object that is subsequently used to create a ServiceR egistry object.
Figure 9.9 Using a Simple Query to Search the Registry 
import javax.xml.registry.*; 
import javax.xml.registry.infomodel.*; 
import java.net.*;
import java.util.*;
public class SimpleQuery
{
static Connection connection = null;
public SimpleQuery()
{}
public static void main(String[] args) 
{
SimpleQuery squery = new SimpleQuery();
//This part of Code will make a connection to the Registry Server
Doconnect myconnection = new Doconnect();
connection = myconnection.connection();
squery.query();
}
/*This method will make a query to the Registry Server*/
public void query()
{
try
{
RegistryService myservice = connection.getRegistryService(); 
BusinessQueryManager bqmanager;
Bqmanager = myservice.getBusinessQueryManager();
www.syngress.com
Continued

356
Chapter 9 • Locating Web Services
Collection ﬁndQualiﬁer = new ArrayList();
ﬁndQualiﬁer.add(FindQualiﬁer.SORT_BY_NAME_DESC);
Collection namePattern = new ArrayList();
namePattern.add("A");
BulkResponse response;
response = bqmanager.ﬁndOrganizations( ﬁndQualiﬁer, 
namePattern, null, 
null, null, null);
Collection orgs = response.getCollection();
Iterator orgIter = orgs.iterator();
while (orgIter.hasNext()) 
{
Organization org = (Organization) orgIter.next();
String name = (org.getName()).getValue();
System.out.println("This is the organisation name  :" + 
name + '\n');
String key = (org.getKey()).getId();
System.out.println("This is the organisation Key  :" + 
key + '\n');
Collection services = org.getServices();
Iterator svcIter = services.iterator();
while (svcIter.hasNext()) 
{
Service svc = (Service)svcIter.next();
String sname = (svc.getName()).getValue();
System.out.println(
"This is the organisation service name  :" + 
sname + '\n');
}
}
}
catch(Exception ex)
{
www.syngress.com
Figure 9.9 Continued
Continued

Locating Web Services • Chapter 9
357
ex.printStackTrace();
}
}
}
Q uerying the registry using the query() method of the code listing in Figure 9.9
produces the output shown in Figure 9.10.
T he output prints the names of organizations that begin with the letter A ,
their respective key values and the services offered by them.
Finding a Service Using a Complex Query 
We now use a complex query to ﬁnd organizations in the registry on the 
basis of classiﬁcation. For complex queries, we need to implement both the
B usinessQ ueryM anager and the B usinessL ifeC ycleM anager. In our example of a 
complex query, we use the B usinessL ifecycleM anager to create a classiﬁcation on
the basis of a speciﬁed classiﬁcation scheme as shown in the code snippet that
follows:
www.syngress.com
Figure 9.9 Continued
Figure 9.10 The Results of a Simple Query

358
Chapter 9 • Locating Web Services
BusinessLifeCycleManager blcm = rs.getBusinessLifeCycleManager();
String schemeName = "uddi-org:types";
ClassiﬁcationScheme uddiOrgTypes;
UddiOrgTypse = bqm.ﬁndClassiﬁcationSchemeByName(schemeName);
Classiﬁcation wsdlSpecClassiﬁcation;
wsdlSpecClassiﬁcation = blcm.createClassiﬁcation(uddiOrgTypes, 
"wsdlSpec", 
"wsdlSpec");
T he ﬁrst argument uddiO rgTypes is the classiﬁcation scheme, while the second
and third arguments, wsdlSpec, are the taxonomy name and value, respectively,
deﬁned by the U DDI speciﬁcation for a W SDL (Web Services Description
Language) document.We assign the classiﬁcation to a collection and use the
ﬁndC oncepts() method of the business query manager:
Collection classiﬁcations = new ArrayList();
classiﬁcations.add(wsdlSpecClassiﬁcation);
BulkResponse br;
br = bqm.ﬁndConcepts(null, null, classiﬁcations, null, null);
W hen we pass the classiﬁcation created by the business life cycle manager to
the ﬁndC oncepts() method, it ensures that only those concepts are returned for
which the services offered are based on W SDL or whose technical speciﬁcations
conform to W SDL.T he ﬁndC oncepts() method returns a collection of concepts (a
concept is used in JAX R  to hold the information about a speciﬁcation).We can
now iterate through the concept collection to obtain the search results as given in
the following code snippet:
Collection specConcepts = br.getCollection();                    
Iterator iter = specConcepts.iterator();     
while (iter.hasNext()) 
{
Concept concept = (Concept) iter.next();
String name = (concept.getName()).getValue();
Collection links = concept.getExternalLinks();
System.out.println( "\nSpeciﬁcation Concept:\n\tName: " + name + 
"\n\tKey: " + concept.getKey().getId() + 
"\n\tDescription: " + 
(concept.getDescription()).getValue());
www.syngress.com

Locating Web Services • Chapter 9
359
if (links.size() > 0) 
{
ExternalLink link = (ExternalLink) links.iterator().next();
System.out.println("\tURL of WSDL document: '" +
link.getExternalURI() + "'");
}
}
T he getValue() method returns a taxonomy code associated with the 
concept.T he getK ey() method returns a key that represents the universally 
unique ID (U U ID) for the concept.T he getID () method returns this U U ID.
T he getD escription() method returns a text that describes the concept.T he
getE xternalL inks() method returns a collection of links outside the registry that
contain additional information about the concept.
T he organizations that satisfy a concept speciﬁcation can be found using the
ﬁndO rganiz ations() method as shown next:
Collection specConcepts1 = new ArrayList();
specConcepts1.add(concept);
br = bqm.ﬁndOrganizations(null, null, null, specConcepts1, null, null);
As in the previous example of a simple query, we can iterate through the col-
lection of organizations returned by the ﬁndO rganiz ations() method and retrieve
information pertaining to these organizations.T he code listing of Figure 9.11
uses the C omplexQ uery class that contains the method wsdlQ uery() for querying a
registry based on a classiﬁcation.T he C omplexQ uery class also instantiates the
D oconnect class (Figure 9.2) to obtain a connection with the registry.
Figure 9.11 Using Classiﬁcations to Query the Registry
import javax.xml.registry.*;
import javax.xml.registry.infomodel.*;
import java.net.*;
import java.util.*;
public class ComplexQuery
{
static Connection connection = null;
public ComplexQuery()
{}
www.syngress.com
Continued

360
Chapter 9 • Locating Web Services
public static void main(String[] args) 
{
ComplexQuery cquery = new ComplexQuery();
// This part of Code will make a connection to the Registry Server
Doconnect myconnection = new Doconnect();
connection = myconnection.connection();
cquery.query();
}
public void query() 
{
try 
{
RegistryService myservice;
BusinessQueryManager bqmanager;
BusinessLifeCycleManager blmanager;
ClassiﬁcationScheme uddiOrgTypes;
Classiﬁcation wsdlSpecClassiﬁcation;
BulkResponse br;
myservice = connection.getRegistryService();
bqmanager = myservice.getBusinessQueryManager();
blmanager = myservice.getBusinessLifeCycleManager();
System.out.println("Got registry service, query " + 
"manager, and lifecycle manager");
String sName = "uddi-org:types";
uddiOrgTypes = bqmanager.ﬁndClassiﬁcationSchemeByName(sName);
wsdlSpecClassiﬁcation = blmanager.createClassiﬁcation(
uddiOrgTypes, 
"wsdlSpec", 
"wsdlSpec");
www.syngress.com
Figure 9.11 Continued
Continued

Locating Web Services • Chapter 9
361
Collection classiﬁcations = new ArrayList();
classiﬁcations.add(wsdlSpecClassiﬁcation);
br = bqmanager.ﬁndConcepts( null, null, classiﬁcations, 
null, null);
Collection specConcepts = br.getCollection();
Iterator iter = specConcepts.iterator();
if (!iter.hasNext()) 
{
System.out.println("No WSDL speciﬁcation concepts found");
} 
else 
{
while (iter.hasNext()) 
{
Concept concept = (Concept) iter.next();
String name = (concept.getName()).getValue();
Collection links = concept.getExternalLinks();
System.out.println("\nSpeciﬁcation Concept:\n\tName: " +
name + "\n\tKey: " + 
concept.getKey().getId() + 
"\n\tDescription: " + 
(concept.getDescription()).getValue());
if (links.size() > 0) 
{
ExternalLink link = (ExternalLink) links.iterator().next();
System.out.println("\tURL of WSDL document: '" +
link.getExternalURI() + "'");
}
// Find organizations using this concept
Collection specConcepts1 = new ArrayList();
specConcepts1.add(concept);
www.syngress.com
Figure 9.11 Continued
Continued

362
Chapter 9 • Locating Web Services
br = bqmanager.ﬁndOrganizations( null, null, null, 
specConcepts1, null, null);
Collection orgs = br.getCollection();
// Display information about organizations
Iterator orgIter = orgs.iterator();
if (orgIter.hasNext()) 
{
System.out.println("Organizations using the '" +
name + "' WSDL Speciﬁcation:");
}
else 
{
System.out.println("No Organizations using the '" +
name + "' WSDL Speciﬁcation");
}
while (orgIter.hasNext()) 
{
Organization org = (Organization) orgIter.next();
System.out.println("\tName: " + (org.getName()).getValue() + 
"\n\tKey: " + org.getKey().getId() +
"\n\tDescription: " + 
(org.getDescription()).getValue());
}
}
}
} 
catch (Exception e) 
{
e.printStackTrace();
}
}
}
www.syngress.com
Figure 9.11 Continued

Locating Web Services • Chapter 9
363
T he output of the C omplexQ uery class is as shown in Figure 9.12.
Understanding the Query Results
In this section, we use the query results of the simple and complex queries dis-
cussed in the previous sections to highlight the information that can be obtained
by querying a business registry.
M etadata R eturned
T he M etadata returned by the query is in the form of details about the organiza-
tion that are contained in the registry database.T his information includes:
■
A N ame object that contains the name of the organization. N ote that
the organization name in the preceding queries was obtained by type-
casting an Iterator object into an organization object and using the code
org.getN ame().getValue(), where org is the O rganization object.
■
A Description object that gives the description of the organization
org.getD escription().getValue().
■
A collection of Service objects that contain the services offered by the
organizations; this collection being obtained using the getServices()
method.
www.syngress.com
Figure 9.12 Results from the Complex Query

364
Chapter 9 • Locating Web Services
Additionally, you can also obtain the following information from the query
results using the respective method of the O rganization Interface:
■
A K ey object that represents the ID through which an organization
entry is uniquely identiﬁed by the registry.
■
A Primary C ontact object that can be used to obtain the name of the
person who is the primary contact for an organization.T his can be done
using the getP rimaryC ontact() method— namely, org.getP rimaryC ontact()
.getP ersonN ame().
■
Postal Address of the organization by using the getP ostalA dress() method.
■
A C ollection object for the users afﬁliated to the organization by using
the getU sers() method.
■
A collection of child organizations of an organization by using the
getC hildO rganiz ations() method, and so on.
External Data
T he external data derived from the preceding queries is in the form of external
links obtained using the code concept.getE xternalL inks().T hese external links are
U R Ls from where the services offered by an organization can be accessed.T he
U R L obtained as an external link may also contain content outside a registry—
for example, an organization may put its home page link in the registry informa-
tion.Additionally, these external links may point to W SDL documents that deﬁne
the X M L format for transacting business with the company (see the links against
the U R L of the W SDL document label in Figure 9.12).
WSDL Documents
Web Services Description Language (W SDL) is a part of U DDI’s initiative to
provide business directories and service descriptions for online services.Akin to
X M L grammar for Web services,W DSL is a speciﬁcation frequently used to
describe networked X M L-based services, allowing service providers to describe
the basic format of requests that can be sent to their systems irrespective of the
protocol (such as SO AP) or encoding (such as M ultipurpose Internet M essaging
Extensions) being used. In this section, we discuss the structure of a W SDL 
document and create an example document.
www.syngress.com

Locating Web Services • Chapter 9
365
Structure of a WSDL Document
In essence,W SDL deﬁnes a standardized format for data exchange to facilitate 
e-business. Structurally, a W SDL document has a <deﬁnitions> element as the
root, like that shown next:
<deﬁnitions name="nmtoken" targetNamespace="uri">
<-- put deﬁnitions here -->
</deﬁnitions>
T he <deﬁnitions> element deﬁnes the name of the Web service. It also
declares multiple namespaces used in other elements in the document.T he 
<deﬁnitions> element contains a set of related services.W SDL deﬁnes these ser-
vices using the following six main elements:
■
Types T he <types> element speciﬁes the low-level data types used for
the procedure contents or the messages being transmitted between the
client and the server.W 3C  X M L Schema speciﬁcation is W SDL’s default
choice for the type-system.T hus, if a service uses only the simple built-in
type of the X M L schema (strings, integers, and so on), the <types> ele-
ment is not required.T he format for the <types> element is as follows:
<types>
<schema targetNamespace="http://namespaces.myURL.com"
xmlns="http://www.w3.org/1999/XMLSchema">
…………………………………………………
…………………………………………………
</types> 
■
Message T he <message> element deﬁnes the data format for a message.
T he message could be a client request message or a server response mes-
sage.T he message element deﬁnes the name of the message and may
contain one or more <part> elements which can refer to message
parameters or to message return values.T he syntax for deﬁning a mes-
sage is as follows:
<message name="msgName">
<part name="myPart" element="myElement?" type=
"myns:partNS "?/> 
</message>
www.syngress.com

366
Chapter 9 • Locating Web Services
■
PortType T he <portType> element is used to group messages that form
a single logical operation.A single logical operation is a complete client-
server communication that encloses both a client request to the server
and the server response to this request. For example, a request may
trigger a response, or in case of error or exception, an error or excep-
tion.T his request-response or request-exception exchange can be
grouped together into a W SDL port type.T his is equivalent to saying
that the <portType> element deﬁnes what operations or functions the
service described by the W SDL document will support.A single
<portType> element can deﬁne more than one operation.T he syntax for
the <portType> element is as follows:
<portType name="myPort">
<operation name="myOperation"> 
<input message= "inputMSG" name="myInput"/>
<output message = "outputMSG" name="myOutput"/>
<fault message = "errorMSGs" name="myError"/>
</operation>
</portType>
NOTE
WSDL supports four basic types of operations. These are:
■
One-way The service receives a message. This would mean that
only the <input> element shown earlier will be present. 
■
Request-Response The service receives a message and sends a
response. Thus the operation will have an <input> element, fol-
lowed by an <output> element as given in the <portType>
syntax. The <fault> element is optional. The request-response
pattern is most commonly used in SOAP services.
■
Solicit-Response The service (not the client) initiates communi-
cation by sending a message and receives a response. Hence,
this operation will have an <output> element followed by an
<input> element. The <fault> element is optional. 
■
Notiﬁcation The service sends a message and seeks no
response. The operation will therefore, have a single <output>
element only. 
Figure 9.13 shows these four operations.
www.syngress.com

Locating Web Services • Chapter 9
367
T he number in brackets (1 or 2) at the end of the <input>/  <output> tag
indicates the order in which the operation occurs.
■
Binding T he <binding> element describes the concrete speciﬁcs of
how the service will be practically implemented. It deﬁnes the message
format and the protocol details (say, SO AP-speciﬁc information) for the
operations and messages deﬁned by a particular portType.A given
portType may have any number of bindings.T he syntax is as follows:
<binding name="myBinding" type="myPort">
<operation name="myOperation">
<input name="myInput">
…………………………….
</input>
<output name="myOutput">
…………………………….
</output>
<fault name="myError">
…………………………….
</fault>
</operation>
</binding>
■
Port A <port> element deﬁnes a single address for a binding.A port
must not specify more than one binding and should contain only the
www.syngress.com
Figure 9.13 The Basic Operations Supported by WSDL
Client
Web Service
<input>(1)
<output>(2)
<output>(1)
One Way
Request-Response
Solicit-Response
Notification
<input>(1)
<input>(2)
<output>(1)
Client
Client
Client
Web Service
Web Service
Web Service

368
Chapter 9 • Locating Web Services
address information for the binding.T he syntax of this element is as 
follows:
<port name="myPort" binding="myBinding"> 
…………………………….
</port>
■
Service T he <service> element provides the location of the service (in
other words, the U R L from which the service may be invoked).T his
normally is the Web address or the U R I for a provider of the described
service.T he <service> element uses a port and its speciﬁed binding to
deﬁne a physical location for a communication end point.T he syntax of
this element is as follows:
<service name="nmtoken"> 
<port name="myPort" .... />
</service>
Example WSDL Document
We now use the elements described in the “Structure of a W SDL Document”
section to develop a sample W SDL document, shown in Figure 9.14.
Figure 9.14 Example of a WSDL Document
<?xml version="1.0" encoding="UTF-8"?>
<deﬁnitions name="TestService"
targetNamespace="http://www.syngress.com/wsdlDocs/TestService.wsdl"
xmlns="http://schemas.xmlsoap.org/wsdl/"
xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
xmlns:tns="http://www.syngress.com/wsdl/TestService.wsdl"
xmlns:xsd="http://www.w3.org/2001/XMLSchema">
<message name="clientRequest">
<part name="ﬁrstName" type="xsd:string"/>
</message>
<message name="ServerResponse">
<part name="welcomeMessage" type="xsd:string"/>
</message>
www.syngress.com
Continued

Locating Web Services • Chapter 9
369
<portType name="testPortType">
<operation name="welcomeClient">
<input message="tns:clientRequest"/>
<output message="tns:ServerResponse"/>
</operation>
</portType>
<binding name="testBinding" type="tns:testPortType">
<soap:binding style="rpc" 
transport="http://schemas.xmlsoap.org/soap/http"/>
<operation name="welcomeClient">
<soap:operation soapAction="welcomeClient"/>
<input>
<soap:body
encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
namespace="urn:examples:testservice"
use="encoded"/>
</input>
<output>
<soap:body
encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
namespace="urn:examples:testservice"
use="encoded"/>
</output>
</operation>
</binding>
<service name="testService">
<port binding="tns:testBinding" name="testPort">
<soap:address 
location="http://localhost:8080/soap/servlet/rpcrouter"/>
</port>
</service>
</deﬁnitions>
www.syngress.com
Figure 9.14 Continued

370
Chapter 9 • Locating Web Services
Let us now analyze the sample W SDL document of Figure 9.14 on the basis
of our discussion in the section,“Structure of a W SDL Document.”
T he <deﬁnitions> Element
T he <deﬁnitions> element in the listing of Figure 9.14 speciﬁes that this Web ser-
vice is called the TestService.T he <deﬁnitions> element also speciﬁes a number of
namespaces that have been used in further elements of the W SDL document.T he
use of namespaces enables the W SDL document to reference multiple external
speciﬁcations such as the W SDL speciﬁcation, the SO AP speciﬁcation, the X M L
Schema speciﬁcation, and so on.
N ote the targetN amespace attribute in the <deﬁnitions> element:
<deﬁnitions name="SyngressTestService"
targetNamespace="http://www.syngress.com/wsdlDocs/TestService.wsdl" ….>
T he targetN amespace is an X M L Schema convention that enables the W SDL
document to refer to itself.
T he deﬁnitions element also speciﬁes a default namespace as follows:
xmlns=“ http:/ / schemas.xmlsoap.org/ wsdl/ ” . Elements such as <message> that do 
not have a namespace preﬁx are therefore assumed to be part of the default
W SDL namespace.
T he <message> Element
T he listing of Figure 9.14 deﬁnes two message elements, a request message
named clientR equest from the client, and a response message named serverR esponse
from the server. N ote the <part> element within the <message> element:
<message name="clientRequest">
<part name="ﬁrstName" type="xsd:string"/>
</message>
<message name="serverResponse">
<part name="welcomeMessages" type="xsd:string"/>
</message>
T he <part> element for the client request speciﬁes a single request (message)
parameter— that is, a ﬁrstN ame parameter.T he <part> element for the response
speciﬁes a return value that happens to be a welcome message for the client in
our case.T he type attribute of the <part> element speciﬁes an X M L Schema data
type. N ote that the value of the type attribute must be namespace-qualiﬁed, hence
the use of xsd as a preﬁx (xsd references the namespace for X M L Schema).
www.syngress.com

Locating Web Services • Chapter 9
371
T he <portType> Element
T he <portType> element deﬁnes a single operation named welcomeC lient.T his
operation consists of the client’s request message, named clientR equest and the
server’s response message named serverR esponse. N ote that the message attribute 
in the code snippet that follows should also be speciﬁed with reference to a
namespace:
<portType name="testPortType">
<operation name="welcomeClient">
<input message="tns:clientRequest"/>
<output message="tns:ServerResponse"/>
</operation>
</portType>
For example, the message attribute of the <input> element has the preﬁx tns
that references the targetN amespace deﬁned in the deﬁnitions element.T hus, as
already mentioned while describing the <deﬁnitions> element of the sample
W SDL document, the targetN amespace attribute is used for self-referencing.
T he <binding> Element
T he <binding> element speciﬁes how the portType operation (welcomeC lient) will
actually be transmitted over the wire. H T T P GET, H T T P PO ST, and SO AP are
some of the protocols that can be used for transporting the Bindings over the
network.
T he <binding> element itself speciﬁes the binding name and a type attribute
that refers to the portType named testP ortType, using the self-referencing
targetN amespace:
<binding name="Hello_Binding" type="tns:Hello_PortType">
T he <soap:binding> element indicates that the binding will be made available
via SO AP (W SDL has built-in extensions for SO AP that enables you to specify
SO AP-speciﬁc details such as SO AP headers, SO AP encoding styles, and the
SO A PA ction H T T P header).T he value rpc for the style attribute of the
<soap:binding> element speciﬁes an R PC  format.T his means that the function
parameters will be embedded inside a wrapper X M L element.T his wrapper
X M L element will indicate the function name and will be included within the
body of the SO AP request. Similarly, the body of the SO AP response will contain
a wrapper element within which the function parameters will be embedded.
www.syngress.com

372
Chapter 9 • Locating Web Services
T he value of the transport attribute, http:/ / schemas.xmlsoap.org/ soap/ http, indi-
cates the SO AP H T T P transport, whereas http:/ / schemas.xmlsoap.org/ soap/ smtp
indicates the SO AP SM T P transport.
T he <soap:operation> element indicates the binding of a particular operation
to a speciﬁc SO AP implementation.T he soapA ction attribute speciﬁes that the
SO A PA ction H T T P header be used for identifying the service.
T he <soap:body> element is used to specify the details of the input and
output messages such as the SO AP encoding style, the namespace associated with
the speciﬁed service, and so on.
T he <service> Element
T he <service> element speciﬁes the location of the service. Since our W SDL doc-
ument speciﬁes a SO AP service, we have used the <soap:address> element and
speciﬁed the local host address for the Apache SO AP rpcrouter servlet— that is,
http:/ / localhost:8080/ soap/ servlet/ rpcrouter.
T his concludes our discussion on W SDL documents.We’ll now talk about
how we can add data to, delete data from, or modify data in the registry using
JW SDP.
Storing Information in a Registry
In the section,“U sing the Default R egistry,” we explained how the R egistry
Browser can be used for adding an organization to the registry. In this section, we
perform the tasks of adding/ deleting an organization to/ from the registry and
modifying existing records using JW SDP classes.We use IBM ’s test registry in the
examples given in this section.
Adding New Registry Records
We again begin by making a connection to the registry using the connection()
method. (Please refer to the section,“C onnecting to a R egistry,” to review how
the connection() method works.) T he ﬁrst step in creating an organization is pro-
viding a username and password to the registry for authentication.T he authenti-
cation information is used to set the credentials for the connection object as
shown in the following code snippet:
String username = "Yash1";
String password = "yashraj1";
www.syngress.com

Locating Web Services • Chapter 9
373
PasswordAuthentication userdetail;
userdetail = new PasswordAuthentication (username, passw.toCharArray());
Set user = new HashSet();
user.add(userdetail);
connection.setCredentials(user);
R ecollect from the discussions in the “U sing the Default R egistry” section
that you need to create an IBM  U DDI Account to obtain the username and
password.
N ext, we create a business life cycle manager to create an organization that
we can submit to the registry:
BusinessLifeCycleManager blmanager;
blmanager = myservice.getBusinessLifeCycleManager();
We use a B usinessL ifeC ycleM anager object since it provides methods that are
required to set the necessary information pertaining to an organization, as will be
clear from the following discussions.
We use the createO rganiz ation() method of the business life cycle manager to
create an O rganization object as shown in the following line of code:
Organization org;
org = blmanager.createOrganization("Dreamtech Software India Inc.");
T his sets “Dreamtech Software India Inc.” as the name of the organization.To
add a description for the organization, we use the following code:
InternationalString s;
s = blmanager.createInternationalString(
"Where Dreams Become Technology");
org.setDescription(s);
To create a primary contact for the organization, we use the createU ser()
method of the business life cycle manager as shown next:
User primaryContact = blmanager.createUser();
PersonName pName = blmanager.createPersonName("Yash");
primaryContact.setPersonName(pName);
T he setP ersonN ame() method sets the name of the primary contact. In a sim-
ilar manner, we can set the telephone number for the primary contact as shown
in the following:
TelephoneNumber tNum = blmanager.createTelephoneNumber();
www.syngress.com

374
Chapter 9 • Locating Web Services
tNum.setNumber("(91) 011-3243077");
Collection phoneNums = new ArrayList();
phoneNums.add(tNum);
primaryContact.setTelephoneNumbers(phoneNums);
T he createE mailA ddress() and setE mailA ddress() methods are used in a similar
fashion to set the e-mail for the primary contact:
EmailAddress emailAddr;
emailAddr = blmanager.createEmailAddress("yash@dreamtechsoftware.com");
Collection emailAddresses = new ArrayList();
emailAddresses.add(emailAddr);
primaryContact.setEmailAddresses(emailAddresses);
We now add the primary contact to the organization (“org,” created earlier)
using the following line of code:
org.setPrimaryContact(primaryContact);
After providing organizational information, we turn to the classiﬁcations that
we need to choose for the organization.We use the ntis-gov:naics scheme to add
classiﬁcation to our organization, as shown in the following lines of code:
Classiﬁcation classiﬁcation;
classiﬁcation = (Classiﬁcation) blmanager.createClassiﬁcation(
cScheme, 
"Software Publishers",          
"51121");
Collection classiﬁcations = new ArrayList();
classiﬁcations.add(classiﬁcation);
org.addClassiﬁcations(classiﬁcations);
R ecollect from the discussions in the using the Default R egistry section that
the N AIC S taxonomy classiﬁes various industry sectors such as Agriculture, Food
Processing, and so on (see Figure 9.4). N otice that in the createC lassiﬁcations()
method, we have passed “Software Publishers” as the classiﬁcation name and
51121 as the value that uniquely identiﬁes this sector (these values are the same
as were obtained using the R egistry Browser in Figure 9.3).
After classiﬁcation, we add services and service descriptions to our organiza-
tion, once again using the methods of the business life cycle manager as shown in
the code snippet that follows:
www.syngress.com

Locating Web Services • Chapter 9
375
Collection services = new ArrayList();
Service service = blmanager.createService("My Service Name");
InternationalString is;
is = blmanager.createInternationalString("My Service Description");
service.setDescription(is);
T he next step is to create service bindings that bind the service to a U R L
from where that service can be accessed, as shown here:
Collection serviceBindings = new ArrayList();
ServiceBinding binding = blmanager.createServiceBinding();
is = blmanager.createInternationalString(
"My Service Binding Description");
binding.setDescription(is);
binding.setAccessURI("http://dreamtechsoftware.com");
serviceBindings.add(binding);
service.addServiceBindings(serviceBindings);
We now add these services to the organization:
services.add(service);
org.addServices(services);
We are now ready to submit our organization to the registry.We do this by
using the following lines of code:
Collection orgs = new ArrayList();
orgs.add(org);
BulkResponse response = blmanager.saveOrganizations(orgs);
T he saveO rganiz ations() method will return an exception if the organization
cannot be submitted, else the response contains the unique ID key that is
assigned to the organization upon successful submission (see Figure 9.6).
T his key can be retrieved by iterating through the response collection.
Figure 9.15 lists the code for the P ublishE ntry class that submits an organization
to the registry and prints the ID if the organization is successfully submitted;
otherwise, it prints out the exceptions that caused the submission process to fail.
www.syngress.com

376
Chapter 9 • Locating Web Services
Figure 9.15 Using the PublishEntry Class to Add an Organization to 
the Registry
import javax.xml.registry.*; 
import javax.xml.registry.infomodel.*; 
import java.net.*;
import java.security.*;
import java.util.*;
public class PublishEntry
{
static Connection connection = null;
public PublishEntry()
{}
public static void main(String[] args) 
{
String username = "Yash1";
String password = "yashraj1";
PublishEntry publishdoc = new PublishEntry();
//This part of Code will make a connection to the Registry Server
Doconnect myconnection = new Doconnect();
connection = myconnection.connection();
publishdoc.publishentry(username, password);
}
public void publishentry(String username, String passw)
{
RegistryService myservice = null;
BusinessLifeCycleManager blmanager = null;
BusinessQueryManager bqmanager = null;
try 
{ 
www.syngress.com
Continued

Locating Web Services • Chapter 9
377
myservice = connection.getRegistryService();
blmanager = myservice.getBusinessLifeCycleManager();
bqmanager = myservice.getBusinessQueryManager();
System.out.println(
"Got registry service, query manager, and life cycle manager");
PasswordAuthentication userdetail;
userdetail = new PasswordAuthentication(username, 
passw.toCharArray());
Set user = new HashSet();
user.add(userdetail);
connection.setCredentials(user);
System.out.println("Checked Security Issues User Logged ON");
// Create organization name and description
Organization org;
org = blmanager.createOrganization(
"Dreamtech Software India Inc.");
InternationalString s;
s = blmanager.createInternationalString(
"Where Dreams Become Technology");
org.setDescription(s);
// Create primary contact, set name
User primaryContact = blmanager.createUser();
PersonName pName = blmanager.createPersonName("Yash");
primaryContact.setPersonName(pName);
// Set primary contact phone number
TelephoneNumber tNum = blmanager.createTelephoneNumber();
tNum.setNumber("(91) 011-3243077");
Collection phoneNums = new ArrayList();
phoneNums.add(tNum);
primaryContact.setTelephoneNumbers(phoneNums);
www.syngress.com
Figure 9.15 Continued
Continued

378
Chapter 9 • Locating Web Services
// Set primary contact email address
EmailAddress emailAddr;
emailAddr =blmanager.createEmailAddress(
"yash@dreamtechsoftware.com");
Collection emailAddresses = new ArrayList();
emailAddresses.add(emailAddr);
primaryContact.setEmailAddresses(emailAddresses);
// Set primary contact for organization
org.setPrimaryContact(primaryContact);
// Set classiﬁcation scheme to NAICS
ClassiﬁcationScheme cScheme;
cScheme = bqmanager.ﬁndClassiﬁcationSchemeByName(
"ntis-gov:naics");
// Create and add classiﬁcation
Classiﬁcation classiﬁcation;
classiﬁcation = (Classiﬁcation) blmanager.createClassiﬁcation( 
cScheme, 
"A Software Development Company", 
"722213");
Collection classiﬁcations = new ArrayList();
classiﬁcations.add(classiﬁcation);
org.addClassiﬁcations(classiﬁcations);
// Create services and service
Collection services = new ArrayList();
Service service = blmanager.createService("My Service Name");
InternationalString is;
is = blmanager.createInternationalString("My Service Description");
service.setDescription(is);
// Create service bindings
www.syngress.com
Figure 9.15 Continued
Continued

Locating Web Services • Chapter 9
379
Collection serviceBindings = new ArrayList();
ServiceBinding binding = blmanager.createServiceBinding();
is = blmanager.createInternationalString(
"My Service Binding Description");
binding.setDescription(is);
binding.setAccessURI("http://dreamtechsoftware.com");
serviceBindings.add(binding);
// Add service bindings to service
service.addServiceBindings(serviceBindings);
// Add service to services, then add services to organization
services.add(service);
org.addServices(services);
// Add organization and submit to registry
// Retrieve key if successful
Collection orgs = new ArrayList();
orgs.add(org);
BulkResponse response = blmanager.saveOrganizations(orgs);
Collection exceptions = response.getException();
if (exceptions == null) 
{
System.out.println("Organization saved");
Collection keys = response.getCollection();
Iterator keyIter = keys.iterator();
if (keyIter.hasNext()) 
{
javax.xml.registry.infomodel.Key orgKey;
orgKey = (javax.xml.registry.infomodel.Key) keyIter.next();
String id = orgKey.getId();
System.out.println("Organization key is " + id);
org.setKey(orgKey);
}
www.syngress.com
Figure 9.15 Continued
Continued

380
Chapter 9 • Locating Web Services
}
else 
{
Iterator excIter = exceptions.iterator();
Exception exception = null;
while (excIter.hasNext()) 
{
exception = (Exception) excIter.next();
System.err.println("Exception on save: " + 
exception.toString());
}
}
}
}
catch (Exception e) 
{
e.printStackTrace();
if (connection != null) 
{
try 
{
connection.close();
}
catch (JAXRException je) 
{
System.err.println("Connection close failed");
}
}
}
}
}
T he output for the P ublishE ntry class is shown in Figure 9.16.
N ote that the output in Figure 9.16 shows a successful operation that prints
out the organization key.
www.syngress.com
Figure 9.15 Continued

Locating Web Services • Chapter 9
381
Updating Records
O nce we add our organization to the registry, it is also possible to update the
information to reﬂect any changes made to the organization’s general informa-
tion, such as the primary contact, telephone numbers, and so on, or changes in
the services offered by the organization.
As an example, let’s delete the service we added in the P ublishE ntry class and
instead add a new service to our organization.We begin by querying the registry
to search for our organization. For this, we set the name of our organization as
the name pattern to be searched, as shown in the code fragment that follows:
String businessname = "Dreamtech Software India Inc.";
Collection namePatterns = new ArrayList();
namePatterns.add(businessname);
We now use the business query manager’s getO rganiz ations() method to search
for our organization, as in the following code:
BulkResponse response;
response = bqm.ﬁndOrganizations(ﬁndQualiﬁers, namePatterns, null, 
null, null, null);
H ere, bqm is the business query manager.
We iterate through the bulk response (see the explanation in the section,
“Q uerying the R egistry”) and obtain the services offered by our organization
using the getServices() method:
services = org.getServices();
www.syngress.com
Figure 9.16 Output of an Add-Organization Request

382
Chapter 9 • Locating Web Services
H ere, org is the organization object that refers to our organization.We loop
through the services to obtain the key associated with the services by using the
following while loop:
while(serIter.hasNext())
{
Service serve = (Service)serIter.next();
System.out.println("This is the service name to be deleted " + 
(serve.getName()).getValue() + '\n');
mykey = serve.getKey();
System.out.println("This is the service key to be deleted " + 
mykey.getId() + '\n');
}
We now delete the service speciﬁed by the key value in the variable, mykey.
Since we added only one service, we shall have only one record for services. If
more than one service was added, at the end of the while loop, the mykey variable
would contain the key for the last service listed for our organization.We use the
business life cycle manager, blmanager, to delete the service, as shown in the fol-
lowing code snippet:
Collection keys = new ArrayList();
keys.add(mykey);
BulkResponse response1 = blmanager.deleteServices(keys);
System.out.println("Deleted Service" + '\n');
N ote that while the querying process requires no authentication, deleting a
service requires authentication.T herefore, we authenticate ourselves with our
username and password, just as we had done while adding our organization to
the registry (see the code listing in Figure 9.16).
After deleting the service, we add a new service using the createService()
method to create the service, as in the following code:
Collection newservices = new ArrayList();
Service service = blmanager.createService("Test Service Name");
InternationalString is;
is = blmanager.createInternationalString("This is Service Description");
service.setDescription(is);
We now set this service to our organization and save it using the saveServices()
method of the business life cycle manager:
www.syngress.com

Locating Web Services • Chapter 9
383
service.setOrganization(org);
newservices.add(service);
BulkResponse response2 = blmanager.saveServices(newservices);
T his completes our updates.T he entire code for the U pdate class is listed in
Figure 9.17.
Figure 9.17 Using the Update Class to Update Registry Records
import javax.xml.registry.*; 
import javax.xml.registry.infomodel.*; 
import java.net.*;
import java.security.*;
import java.util.*;
public class Update
{
static Connection connection = null;
public Update()
{}
public static void main(String[] args) 
{
String username = "Yash1";
String passw = "yashraj1";
String businessname = "Dreamtech Software India Inc.";
Update updatedata = new Update();
//This part of Code will make a connection to the Registry Server
Doconnect myconnection = new Doconnect();
connection = myconnection.connection();
updatedata.update(username, passw, businessname);
}
public void update(String username, String pass, String businessname)
{
www.syngress.com
Continued

384
Chapter 9 • Locating Web Services
Collection services = null;
javax.xml.registry.infomodel.Key mykey = null;
javax.xml.registry.infomodel.Key depkey = null;
Organization org = null;
try
{
RegistryService rs = connection.getRegistryService();
BusinessQueryManager bqm = rs.getBusinessQueryManager();
BusinessLifeCycleManager blmanager;
blmanager = rs. getBusinessLifeCycleManager();
System.out.println("Got registry service and query manager");
// Deﬁne ﬁnd qualiﬁers and name patterns
Collection ﬁndQualiﬁers = new ArrayList();
ﬁndQualiﬁers.add(FindQualiﬁer.SORT_BY_NAME_DESC);
Collection namePatterns = new ArrayList();
namePatterns.add(businessname);
BulkResponse response;
response = bqm.ﬁndOrganizations(ﬁndQualiﬁers, namePatterns, 
null, null, null, null);
Collection orgs = response.getCollection();
Iterator orgIter = orgs.iterator();
while (orgIter.hasNext()) 
{
org = (Organization)orgIter.next();
System.out.println((org.getKey()).getId() + '\n');
String name = (org.getName()).getValue();
System.out.println("This is the organisation name  :" + 
name + '\n');
services = org.getServices();
}
//This part of code will authenticate the user
www.syngress.com
Figure 9.17 Continued
Continued

Locating Web Services • Chapter 9
385
PasswordAuthentication userdetail;
userdetail = new PasswordAuthentication(username, 
pass.toCharArray());
Set user = new HashSet();
user.add(userdetail);
connection.setCredentials(user);
System.out.println("Checked Security Issues User Logged ON");
//This part of code will delete a service
Iterator serIter = services.iterator();
while(serIter.hasNext())
{
Service serve = (Service)serIter.next();
System.out.println("This is the service name to be deleted " + 
(serve.getName()).getValue() + '\n');
mykey = serve.getKey();
System.out.println("This is the service key to be deleted " + 
mykey.getId() + '\n');
}
Collection keys = new ArrayList();
keys.add(mykey);
BulkResponse response1 = blmanager.deleteServices(keys);
System.out.println("Deleted Service" + '\n');
//This part of code will add a service
Collection newservices = new ArrayList();
Service service = blmanager.createService("Test Service Name");
InternationalString is;
is = blmanager.createInternationalString(
"This is Service Description");
service.setDescription(is);
service.setOrganization(org);
newservices.add(service);
BulkResponse response2 = blmanager.saveServices(newservices);
System.out.println("Service Added" + '\n');
www.syngress.com
Figure 9.17 Continued
Continued

386
Chapter 9 • Locating Web Services
}
catch(Exception e)
{
e.printStackTrace();
}
}
}
T he output from the U pdate class is shown in Figure 9.18.T he U pdate class
also calls the D oconnect class (Figure 9.2) to connect to the registry.
T he output from the U pdate class (as shown in Figure 9.18) prints status mes-
sages that conﬁrm that the service named Test Service N ame has been deleted and
a new service has been added.T he organization records thus stand updated.
Deprecating and Deleting Existing Records
We have seen how to add an organization to the registry and how to modify and
update registry records.We now discuss how these records can be deprecated or
deleted.
Deprecation is equivalent to saying that the services of an organization are no
longer available.T he difference between deprecating an organization record and
deleting an organization record is that, when you delete an organization, you 
www.syngress.com
Figure 9.17 Continued
Figure 9.18 The Output from the Update Class

Locating Web Services • Chapter 9
387
permanently remove access to its services, until you re-create and resubmit the
organization. Deprecating, on the other hand, is temporary in nature, since you
can un-deprecate a deprecated organization at any time to put it back in business.
A deprecated organization, however, will not be listed in the query results of a
registry until it is un-deprecated.
We now build a class, the D eleteE ntry class that contains methods both to
deprecate and delete an organization (see the methods deprecateE ntry() and
deleteE ntry(), respectively, in the code listing of Figure 9.19).
Just as for updating records, we begin by querying the registry using our
organization’s name as follows:
Collection namePatterns = new ArrayList();
namePatterns.add(busName);
BulkResponse response;
response = bqmanager.ﬁndOrganizations(ﬁndQualiﬁers, namePatterns, null,
null, null, null);
H ere the variable busN ame contains the string “Dreamtech Software India Inc.”
O nce again, we authenticate the user information by furnishing our user-
name and password, as shown in the following code:
PasswordAuthentication userdetail;
userdetail = new PasswordAuthentication(username, 
password.toCharArray());
Set user = new HashSet();
user.add(userdetail);
connection.setCredentials(user);
We obtain the organization key by iterating through the bulk response
returned by the query results.We now pass this key to the deprecateO bjects()
method of the business life cycle manager to deprecate the organization as 
shown in the following lines of code:
String keyname = key.getId();
Collection keys = new ArrayList();
keys.add(key);
BulkResponse response = blmanager.deprecateObjects(keys);
H ere key is the organization key that is passed to the method deprecateE ntry()
as a parameter.
www.syngress.com

388
Chapter 9 • Locating Web Services
Similarly, we pass this key to the deleteE ntry() method as a parameter and use
the deleteO rganiz ations() method to delete the organization as in the following
lines of code:
String keyname = key.getId();
Collection keys = new ArrayList();
keys.add(key);
BulkResponse response = blmanager.deleteOrganizations(keys);
T he complete code for the D eleteE ntry class is listed in Figure 9.19.Again, we
use the D oconnect class (Figure 9.2) to connect to the registry.
Figure 9.19 Using the DeleteEntry Class for Deprecating and Deleting
Existing Records
import javax.xml.registry.*; 
import javax.xml.registry.infomodel.*; 
import java.net.*;
import java.security.*;
import java.util.*;
public class DeleteEntry
{
static Connection connection = null;
RegistryService rs = null;
public DeleteEntry()
{}
public static void main(String[] args) 
{
String username = "Yash1";
String password = "yashraj1";
String bname = "Dreamtech Software";
javax.xml.registry.infomodel.Key key1 = null;
DeleteEntry myentry = new DeleteEntry();
//This part of Code will make a connection to the Registry Server
www.syngress.com
Continued

Locating Web Services • Chapter 9
389
Doconnect myconnection = new Doconnect();
connection = myconnection.connection();
key1 = myentry.query(bname);
myentry.deleteEntry(key1,username,password);
}
public javax.xml.registry.infomodel.Key query(String busName) 
{
BusinessQueryManager bqmanager = null;
javax.xml.registry.infomodel.Key organisationKey = null;
try 
{
rs = connection.getRegistryService();
bqmanager = rs.getBusinessQueryManager();
System.out.println("Got registry service and " + "query manager");
// Deﬁne ﬁnd qualiﬁers and name patterns
Collection ﬁndQualiﬁers = new ArrayList();
ﬁndQualiﬁers.add(FindQualiﬁer.SORT_BY_NAME_DESC);
Collection namePatterns = new ArrayList();
namePatterns.add(busName);
// Find using the name
BulkResponse response;
response = bqmanager.ﬁndOrganizations(ﬁndQualiﬁers, 
namePatterns, null, 
null, null, null);
Collection organisation = response.getCollection();
Iterator organisationIT = organisation.iterator();
while(organisationIT.hasNext())
{
Organization myorg = (Organization)organisationIT.next();
System.out.println(" Found Organisation " + '\n');
organisationKey = myorg.getKey();
www.syngress.com
Figure 9.19 Continued
Continued

390
Chapter 9 • Locating Web Services
String id = organisationKey.getId();
System.out.println(" This is the organisation ID " + id + '\n');
}
}
catch(Exception e)
{
e.printStackTrace();
}  
return organisationKey;
}
public void deprecateEntry( String username, 
String password, 
String bname)
{
javax.xml.registry.infomodel.Key mykey = null;
BusinessQueryManager bqmanager = null;
BusinessLifeCycleManager blmanager = null;
Collection Services = null;
String keyname = null;
try 
{
bqmanager = rs.getBusinessQueryManager();
Collection ﬁndQualiﬁers = new ArrayList();
ﬁndQualiﬁers.add(FindQualiﬁer.SORT_BY_NAME_DESC);
Collection namePatterns = new ArrayList();
namePatterns.add(bname);
BulkResponse response;
response = bqmanager.ﬁndOrganizations(ﬁndQualiﬁers,
namePatterns, null, 
null, null, null);
Collection organisation = response.getCollection();
Iterator organisationIT = organisation.iterator();
www.syngress.com
Figure 9.19 Continued
Continued

Locating Web Services • Chapter 9
391
while(organisationIT.hasNext())
{
Organization myorg = (Organization)organisationIT.next();
System.out.println(" Found Organisation " + '\n');
Services = myorg.getServices();
}
blmanager = rs.getBusinessLifeCycleManager();
PasswordAuthentication userdetail;
userdetail = new PasswordAuthentication(username,
password.toCharArray());
Set user = new HashSet();
user.add(userdetail);
connection.setCredentials(user);
System.out.println("Checked Security Issues User Logged ON");
Iterator serIter = Services.iterator();
while(serIter.hasNext())
{
Service serve = (Service)serIter.next();
System.out.println("This is the service name to be deleted " +
(serve.getName()).getValue() + '\n');
mykey = serve.getKey();
System.out.println("This is the service key to be deleted " + 
mykey.getId() + '\n');
}
keyname = mykey.getId();
System.out.println("Deprecating Organisation with ID " + 
keyname + '\n');
Collection keys = new ArrayList();
keys.add(mykey);
BulkResponse response1 = blmanager.deprecateObjects(keys);
System.out.println("Depricated service" + '\n');
}
www.syngress.com
Figure 9.19 Continued
Continued

392
Chapter 9 • Locating Web Services
catch(Exception ex)
{
ex.printStackTrace();
}
}
public void deleteEntry(javax.xml.registry.infomodel.Key key, 
String username, 
String password)
{
BusinessLifeCycleManager blmanager = null;
try 
{
blmanager = rs.getBusinessLifeCycleManager();
PasswordAuthentication userdetail;
userdetail = new PasswordAuthentication(username, 
password.toCharArray());
Set user = new HashSet();
user.add(userdetail);
connection.setCredentials(user);
System.out.println("Checked Security Issues User Logged ON");
String keyname = key.getId();
Collection keys = new ArrayList();
keys.add(key);
BulkResponse response = blmanager.deleteOrganizations(keys);
System.out.println("Deleted service of the following Key " + 
keyname + '\n');
}
catch(Exception ex)
{
ex.printStackTrace();
}
}
}
www.syngress.com
Figure 9.19 Continued

Locating Web Services • Chapter 9
393
T he output for the D eleteE ntry class is shown in Figure 9.20. It lists the key
for the organization that has been deleted.
NOTE
As of the time of writing this book, the deprecateObjects() method (see
code listing of Figure 9.19) generates an UnsupportedCapabilityException,
perhaps due to some unresolved compatibility issues between the registry
and the JAXR pack.
Security Requirements
In each of the classes listed earlier, P ublishE ntry, U pdateR egistry, and D eleteE ntry,
we have supplied a username and password to authenticate ourselves before we
can add, modify, or delete our organization’s information in the registry. Each of
the code listings in Figure 9.15, Figure 9.17, and Figure 9.19 contain the fol-
lowing code snippet:
PasswordAuthentication userdetail;
userdetail = new PasswordAuthentication(username, 
password.toCharArray());
Set user = new HashSet();
user.add(userdetail);
connection.setCredentials(user);
www.syngress.com
Figure 9.20 The Output for the DeleteEntry Class

394
Chapter 9 • Locating Web Services
T his code snippet is a must since without verifying the user’s credentials, the
registry does not allow addition, modiﬁcation, or deletion of data. In the “U sing
the Default R egistry” section too, where we had used the R egistry Browser, we
were asked for our username and password when trying to submit our organiza-
tion to the registry (see Figure 9.5).T his ensures that the information in the reg-
istry is secure and no one can change the registry information without proper
authorization.
www.syngress.com

Locating Web Services • Chapter 9
395
Summary
T his chapter focused on business registries, their classiﬁcation, and methods to
access and search business registries.We discussed the categorization of services in
business registries on the basis of industry sectors and on the basis of location that
makes them easily searchable.We also explained protocols such as SO AP and the
major registry standards such as U DDI and ebX M L R egR ep.After reviewing the
structure of registries, we explored the default registry that comes with the
JW SDP pack and is used for testing and development purposes.We explained
how the R egistry Browser, also a part of the JW SDP pack, is used to access a
registry and search it, as well as add an organization to it.
Q uerying techniques were elaborated at length since the major purpose of
business registries is to let vendors register themselves and let buyers search them.
To clarify the process of querying, we used an example of a simple query that
matches a name string pattern and a complex query that searches the registry on
the basis of classiﬁcation. In the process, we described the major JAX R  interfaces,
classes, and methods that make querying the registry possible.Towards the end of
the chapter, we took up JW SDP interfaces, classes, and so on that allow you to
programmatically add/ delete an organization to/ from a registry, and update
existing information in the registry. In a nutshell, this chapter covered all aspects
relevant to business registries.
Solutions Fast Track
R egistries
 A registry is a collection of meta-information about Web services and
their providers.
 Information in a registry is categorized on the basis of industry sector
and geographical location.
 SO AP is the major protocol used for accessing and communicating with
registries.
 U DDI and ebX M L are two industry initiatives that seek to standardize
the way business is conducted over the Internet.
www.syngress.com

396
Chapter 9 • Locating Web Services
C ategorizing Web Services
 Web services are those that receive, process (if required), and respond to
requests from Web-clients.Web services encompass any self-contained
software component/ application or piece of code that can be deployed
on a Web server, and subsequently be invoked over the Web by Web-
clients.
 C ategorization is crucial for proper organization and maintenance of a
business registry.
C onnecting to a R egistry
 T he C onnectionF actory class in the JAX R  API is used to establish a
connection with the registry.
 C onnecting to the registry entails setting the appropriate query U R L for
querying the registry, or publish U R L for submitting an organization to
the registry.
 T he proxy host and proxy port needs to be appropriately set if you are
connecting to the registry from behind a ﬁrewall.
Q uerying the R egistry
 T he registry can be queried on the basis of organization name-pattern,
or on the basis of classiﬁcation (industrywise or locationwise).
 T he business query manager and business life cycle manager provide
methods to query the registry based on name patterns and classiﬁcation
schemes.
 T he javax.xml.registry package provides various methods, such as
ﬁndO rganiz ations(), ﬁndServices(), ﬁndC oncepts(), and so on, to query a
registry.
 Q uerying the registry returns a collection of objects that provide
information about the organizations that match the search criteria such
as organization name, primary contact, services offered, and so on.
www.syngress.com

Locating Web Services • Chapter 9
397
W SDL Documents
 W SDL is U DDI’s initiative to provide X M L grammar for Web services
so that the format for data and message exchange for e-business are
standardized.
 A W SDL document deﬁnes the X M L grammar within a <deﬁnitions>
tag and the services are deﬁned using the six major elements, <types>,
<message>, <portType>, <binding>, <port>, and <service>.
 An example was shown of a W SDL document that deﬁnes a business
message process involving receipt of a ﬁrst name in the client request
and which sends back a welcome message to the client using SO AP.
Storing Information in a R egistry
 T he B usinessL ifeC ycleM anager interface in the javax.xml.registry package
provides various methods required to create an organization and add to
it information such as the organization name, contact person, telephone
numbers, services offered, and so on.
 A username and password are required for authentication to store
information in the registry or to modify existing information.
 Existing records in the registry can be updated— for example, the
deleteServices() method can be used to delete a service or the saveServices()
method can be used to save a new service created. U pdating requires
proper authentication using the username and password submitted for
the organization being updated.
 An existing organization in the registry can be deleted using the
deleteO bjects() method, or deprecated using the deprecateO bjects() method.
Both operations require proper authentication (username and password).
www.syngress.com

398
Chapter 9 • Locating Web Services
Q: W hy do we need business registries when so many search engines are avail-
able on the Web?
A: Search engines are meant to search unstructured and random data related to a
variety of ﬁelds such as education, industry, society, and so on that is available
at any U R L on the World W ide Web. By contrast, a business registry is highly
structured and is speciﬁcally meant for offering services and businesses.A reg-
istry enables a focused search on the basis of industry, product category, and
geographical location.Additionally, registries provide links to U R Ls from
where services being offered over the Web can be invoked.
Q: W hat is the purpose of standards like U DDI and ebX M L?
A: Standards such as U DDI and ebX M L strive to standardize the format of busi-
ness messages and business data exchanged between clients and service
providers over the Internet. Such globally accepted standards will make 
e-business simpler for trading parties by eliminating incompatibility between
their various data and message formats.
Q: H ow can I invoke a desired service after I have found a vendor for it while
searching the registry?
A: M ore often than not, the organization information in the registry contains
links in the form of U R Ls that can be used to invoke a particular service.
T hese links usually refer to a W SDL document that provides the request
format for calling the service.
Q: W hat is JAX R ?
A: JAX R  is a pack that comes clubbed with the JW SDP pack and provides an
API to access a variety of X M L registries. Programs written using the JAX R
API are portable across different registries.
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

Locating Web Services • Chapter 9
399
Q: W hat is the Java W SDP R egistry Server? 
A: T he JW SDP R egistry Server serves the same purpose as an actual business
registry does, except that it contains no actual data on service providers and
cannot be searched by actual clients over the Internet.T his is a test registry
server that can be used by developers to test their programs that use JAX R
classes to access and query business registries.
Q: W hat is the purpose of W SDL?
A: Web Services Description Language (or W SDL) is an attempt at standardizing
the request-response messages transmitted between trading parties over the
Internet.W SDL allows service providers to specify formats that can be used
to send requests to their services irrespective of the underlying protocol.
www.syngress.com


Java Secure 
Sockets Layer
Solutions in this chapter:
■
Conﬁguring JSSE
■
Using HTTPS URL Handlers
■
Using SocketFactories
■
Using Secure Server Sockets
■
Using Secure Client Sockets
■
Using JSSE Applications with WSDP
Chapter 10
401
 Summary
 Solutions Fast Track
 Frequently Asked Questions

402
Chapter 10 • Java Secure Sockets Layer
Introduction
T he Java Secure Sockets Extension (JSSE) is an odd addition to the Web Services
Developer Pack; it was added on somewhat late, and was made available as a Java
platform extension. H owever, JSSE is a standard component of J2SE as of version
1.4. So you only need to include JSSE in an environment that uses a JVM  release
prior to 1.4 provided that the version is 1.2.1 or later.
JSSE provides a standard mechanism for establishing secure communication
among T C P/ IP sockets. It supports the Secure Socket Layer (SSL) and Transport
Layer Security (T LS) security protocols. JSSE is designed to provide a standard,
royalty-free implementation of these protocols for commercial applications.
W hat is interesting about JSSE is its approach: JSSE introduces the concept of
a socket factory (and a server socket factory). Socket factories are helper classes that
return socket instances; the socket instances in turn depend upon the socket fac-
tory used.T he default socket factory, for example, returns insecure sockets; the
default SSL F actory returns SSL Sockets. U sing SSL Socket automatically handles the
handshaking required by the SSL protocol.
T he user subsequently has to update the code to use socket factories instead
of creating sockets directly. O nce this is done, the application is ready for secure
communication.
T he use of SSL for transferring secure content over a network entails the use
of private and public keys and their associated security certiﬁcates. T his intro-
duces the concept of a keystore, which is used to store the key and information
regarding the certiﬁcates. JSSE retrievs this information from the keystore for rel-
evant purposes.We’ll discuss the keytool utility (that is used to create and manage
a keystore) below. But ﬁrst, let us discuss the process of conﬁguring JSSE.
Conﬁguring JSSE
T his book deals speciﬁcally with JSSE version 1.0.2, which is available as an
extension to the Java platform.JSSE must be conﬁgured before you can use it.
T he Java C ryptography Architecture security provider class, SunJSSE , is used to
implement JSSE. Installation of JSSE requires the prior installation of Java 2 SDK
version 1.2.1 or later and Java R untime Environment (JR E) version 1.2.1 or
later.T he steps for installing and conﬁguring JSSE are discussed below.
www.syngress.com

www.syngress.com
Download JSSE and Extract the Files
Download the JSSE package and save it in any directory on your system.
Extracting the downloaded ﬁle will create a directory named jsse1.0.2 in which
you will ﬁnd two subdirectories: doc and lib. N ote that the JSSE packages and
properties can also be used with the W SDP, as we shall see in the “U sing JSSE
Applications with W SDP” section.
Install the .jar Files
T he lib subdirectory contains the following extension ﬁles:
■
jsse.jar
■
jcert.jar
■
jnet.jar
Place these three in the java-home/ lib/ ext directory.
R egister the SunJSSE Provider
You need to explicitly register the SunJSSE provider before accessing its services.
T his registration can be done in two possible ways: static or dynamic.
Static R egistration
Edit the security property ﬁle. for W IN 32, this ﬁle is as follows:
<java-home>\lib\security\java.security
For any U nix-based system ( Solaris, Linux and so on), this ﬁle is as follows:
<java-home>/lib/security/java.security
T he java.security ﬁle contains one property of the type:
security.provider.n=providerClassName
T his property declares a provider and sets its preference order (n). If no spe-
ciﬁc provider is requested, the preference order determines the order in which
providers will be searched. Set this property as follows:
security.provider.1=com.sun.net.ssl.internal.ssl.Provider
security.provider.2=sun.security.provider.Sun
SunJSSE will now be the ﬁrst preferred provider.
Java Secure Sockets Layer • Chapter 10
403

404
Chapter 10 • Java Secure Sockets Layer
D ynamic R egistration
Programmatically, dynamic registration is done by adding the following line of
code to the program seeking to use JSSE services:
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
T his line of code should be added to a program before using JSSE, preferably
in the application or servlet’s initialization method.T he provider is now added
dynamically at runtime using the java.net.Security class.
R eaders should note that when the provider is set statically, it is available to
any JSSE program on the system. O n the other hand, if the property is not set
statically, every program using JSSE classes will have to essentially include code to
conﬁgure the provider.
C onﬁgure T he U R L H andler
C onﬁguring the U R L handler enables JSSE programs to access U R Ls working
on the H T T PS (Secure H T T P) protocol. Like the provider, the U R L handler
can be conﬁgured either statically or dynamically at runtime.
Static C onﬁguration
T he U R L handler can be statically conﬁgured via the java.protocol.handler.pkgs
property.To set this property, execute the following command at the command
line:
java -D java.protocol.handler.pkgs=\com.sun.net.ssl.internal.
www.protocol.
O nce the property is set statically, you need not conﬁgure it in JSSE code
again. Instead, U R Ls that use H T T PS can directly be accessed using the
U R L C onnection class.
D ynamic C onﬁguration
To set the U R L handler programmatically, use the java.lang.System class as follows:
System.setProperty("java.protocol.handler.pkgs", "com.sun.net.ssl.
internal.www.protocol");
N ote that the ﬁrst parameter (java.protocol.handler.pkgs) refers to the property,
while the second parameter (com.sun.net.ssl.internal.www.protocol) is the value
assigned to this property.T his is the same as in static conﬁguration, except that
www.syngress.com

Java Secure Sockets Layer • Chapter 10
405
here we use the java.lang.System class instead of executing a command on the
command line.
R eaders should be aware that conﬁguring the U R L handler programmatically
at runtime does not set the corresponding system property.T his means that if you
have not conﬁgured the U R L handler statically, every JSSE program seeking to
use the U R L handler will have to necessarily use the above line of code in order
to connect to H T T PS U R Ls. O n the other hand, when this property is set stati-
cally through the command line, any JSSE program on the system can use it to
access H T T PS U R Ls with no need to set the property through code.
Install a JSSE-Speciﬁc cacerts ﬁle 
(O ptional C onﬁguration Step)
T he Java2 SDK  contains a default security certiﬁcate. H owever, if required, you can
provide a JSSE-speciﬁc set of trusted root certiﬁcates.W hen JSSE implementation
creates a default TrustM anager, it checks for alternate cacert ﬁles before resorting to
the standard cacerts ﬁle. If a ﬁle is speciﬁed by javax.net.ssl.trustStore, it is used as the
trust store, otherwise the implementation looks for <java-home>/ lib/ security/
jssecacerts and <java-home>/ lib/ security/ cacerts in that order.
Introduction to Keys and Certiﬁcates
A key is an algorithmically-generated number that is associated with a particular
entity, say a company or an individual.A key uniquely identiﬁes an entity, and
hence provides a mechanism to verify that entity.A key can be private or public;
a private key is supposed to be known only to the entity to whom it belongs. O n
the other hand, a public key is meant to be made available to anyone who
intends to have authenticated/ trusted interaction with the entity that owns it.
Public and private keys exist in pairs, with a private key corresponding to exactly
one public key.A key is what uniquely identiﬁes each entry made in a keystore
(T his will be discussed in the next section).
A certiﬁcate is what certiﬁes a key; it is a digital entity that is used by its
issuer to vouch for certain information being provided from another party (the
owner of the certiﬁcate). For example, the issuer conﬁrms that an entity’s public
key as given by the certiﬁcate has a certain speciﬁed value.T he ﬁrst party (the
issuer) is generally a C ertiﬁcation Authority (C A) who is bound by legal agree-
ments to create and issue valid and reliable certiﬁcates. Examples of C As are
VeriSign and T hawte.
www.syngress.com

406
Chapter 10 • Java Secure Sockets Layer
A certiﬁcate contains information on the its issuer and the digital signature of
the entity referred to by the certiﬁcate.Apart from this, a certiﬁcate contains
additional information, such as:
■
T he certiﬁcate serial number (that uniquely identiﬁes the certiﬁcate and
is assigned by the entity that created the certiﬁcate).
■
T he X .509 version (v1, v2 and v3). X .509 is a standard that deﬁnes what
information can be stored in a certiﬁcate and its data format.
■
T he  issuer of the certiﬁcate.
■
T he certiﬁcate’s validity period.
■
T he algorithm used by the C A to sign the certiﬁcate.
■
T he subject name (the name of the entity whose public key is speciﬁed
by the certiﬁcate).
■
Public key information of the subject, and so on.
For all practical purposes, a key is certiﬁed, not by one certiﬁcate alone, but by
a chain of certiﬁcates.A certiﬁcate chain consists of say, a certiﬁcate from authority
B, certifying the key of entity A , followed by a certiﬁcate from authority C ,
vouching for the integrity of information from authority B, followed by a certiﬁ-
cate from authority D , that certiﬁes the certiﬁcate from authority C and so on.
W hen a new key is added to the keystore using the -genkey command (which
is explained in the next section), a self-signed certiﬁcate is added to form the ﬁrst
element of the certiﬁcation chain. In a self-signed certiﬁcate, the issuer is the same
as the subject name (the name of the entity whose public key is speciﬁed by the
certiﬁcate).After a certiﬁcate signing request is sent to a C A and the certiﬁcate is
received, it replaces the self-signed certiﬁcate.T he certiﬁcate for the C A’s public
key is also appended to the key’s certiﬁcate chain.Apart from the original, there
could be more certiﬁcates in the chain from different C As, with each authority
certifying the certiﬁcate of the authority right above it in the chain.T he certiﬁcate
chain thus grows until a self-signed root certiﬁcate is reached.
NOTE
It is worth mentioning the fact that most chains end in a certiﬁcate self-
signed by a well-known and trusted CA. Chains that end in unknown
CAs are the genesis of some IE security warning messages.
www.syngress.com

Java Secure Sockets Layer • Chapter 10
407
Using keytool to Create a Keystore
T he keytool is a key and certiﬁcate management utility that allows users to
administer their own public or private key pairs and associated certiﬁcates.T he
keytool facilitates use of digital signatures for authentication services like self-
authentication. In other words, the user authenticates himself/ herself to other
users.T he keytool stores the keys and certiﬁcates in a keystore. By default, this
keystore is implemented as a ﬁle (the private keys are protected with a password).
Information from this keystore is used by the jarsigner tool to generate or verify
digital signatures for Java Archive (JAR ) ﬁles.
NOTE
The keytool and jarsigner together replace the javakey tool in JDK 1.1.
The keystore architecture replaces the identity database created and
managed by javakey. It also provides more features than javakey, pass-
word protection for private keys and  veriﬁcation of digital signatures,
for example.
A keystore contains two types of entries:
■
key entries A key entry typically consists of a secret or private key
with associated certiﬁcate chain information. Since such a key contains
sensitive information, it is saved in a protected format.T he keytool and
jarsigner handle private keys only.
■
trusted certiﬁcate entries A trusted certiﬁcate entry is a public key
certiﬁcate that contains the identity of the owner of the certiﬁcate. It is
called “trusted” because the keystore owner trusts that it conforms to the
identity prescribed by the certiﬁcate.
T he keystore entries are accessed using aliases. Each keystore entry has a
unique, case-insensitive alias.An alias is speciﬁed when making an entry to the
keystore. Subsequent keytool commands must use the same alias when referring
to the entry being considered. (Aliases will be clariﬁed by the subsequent discus-
sions on generating keystore entries.)
www.syngress.com

408
Chapter 10 • Java Secure Sockets Layer
C reating a Keystore 
T he default location for the keystore is the .keystore ﬁle in the user’s home
directory.T he home directory is determined by the user.home system property.
T his property varies with operating system conﬁguration. For example, on a
multi-user W indows 95 system, user.home defaults to C :\ W indows\ Proﬁles\
username. H owever, for a single-user W indows 95, system user.home defaults to
C :\ W indows.
A keystore is created when any of the following commands are used to make
an entry to a keystore that does not as yet exist:
■
-genkey T he -genkey command generates a key pair. C onsider the 
following command:
keytool –genkey –alias myKey –keypass mykeyPassword
T his command generates a key with the alias myK ey and the pass-
word mykeyPassword that is subsequently required to access the key.As
mentioned earlier, the alias is used when referring to the key. For
example, if the password for this key is to be changed to, say,
newPassword, the following command might be used:
keytool –keypasswd –alias myKey –keypass newPassword
N ote that the alias myK ey or mykey will both refer to the same key
since aliases are case-insensitive.T he keystore location can be speciﬁed
using the -keystore option. If this option is not speciﬁed, it defaults to the
.keystore ﬁle in the user’s home directory as given by the user.home
system property.
WARNING
A password should not be speciﬁed on the command line unless you are
on a secure system. When you do not specify the password option on
the command line, you are prompted for it. The password typed at this
prompt is echoed as it is; displayed in plain alphanumeric characters,
exactly as typed (no “*” characters are used!). Hence, care should be
exercised to ensure privacy while typing the password.
www.syngress.com

Java Secure Sockets Layer • Chapter 10
409
■
-import T he -import command imports an entry from a speciﬁed cer-
tiﬁcate ﬁle, into the keystore and stores it against the speciﬁed alias.T he
data to be imported should either be binary encoded or Base64
encoded.
■
-identitydb T his command reads all the entries from a JDK 1.1 identity
database (as created by the javakey tool) and adds these entries into the
keystore. If the keystore does not exist, it creates one.
Apart from using the above commands, a keystore can also be created by
specifying a new one using the -keystore option.
Using Keytool to Create/Install a Certiﬁcate
U sing keytool, it is possible to create or import a certiﬁcate to the keystore. key-
tool currently handles X .509 certiﬁcates.All X 509 certiﬁcates contain the signa-
ture of the entity referred to by the certiﬁcate, the certiﬁcate serial number, the
signature algorithm identiﬁer, the issuer’s name, the certiﬁcate’s validity period,
the subject name, the subject’s public key information and the X 509 version.
As mentioned earlier, the keytool can create and manage key entries in the
keystore, each of which contains a private key and its associated certiﬁcate chain.
T he public key corresponding to the private key entry in the keystore forms the
ﬁrst certiﬁcate in the chain.We now discuss how certiﬁcates can be generated
and/ or imported into the keystore.
Importing a C ertiﬁcate
T he keytool is used to import certiﬁcates associated with a key using the -import
command.As mentioned in the previous section, the -import command uses a
certiﬁcate ﬁle name to identify the certiﬁcate’s source and an alias name to iden-
tify the destination key.T he imported certiﬁcates are added to the destination
key’s certiﬁcate chain. C onsider the following command:
keytool –import –alias destinationKeyName –ﬁle certiﬁcateFileName.cer
T his command will import the certiﬁcate speciﬁed by the certiﬁcateFileN ame
ﬁle and add it to the certiﬁcate chain of the key known by the destinationK eyN ame
alias.T he keytool can import certiﬁcates with X .509 versions 1, 2, or 3.T he gen-
eral form of an -import command is as follows:
-import {-alias aliasName} {-ﬁle certiﬁcateFile} [-keypass keyPassword]
{-noprompt} {-tustcacerts} {-storetype storetype} {-keystore keystore}
www.syngress.com

410
Chapter 10 • Java Secure Sockets Layer
[-storepass storePassword] [-provider providerClassName] {-v} 
{-Jjavaoption option}
Lets take a look at the code parts involved here:
■
-storetype deﬁnes the type of store that is given by the keystore.type prop-
erty.T he default keystore type is jks, which is proprietary to Sun
M icrosystems.You may choose any other type for the keystore, say a 
type like SyngressK S, which is descriptive of a keystore type created by
Syngress.
■
-provider speciﬁes the name of the service provider’s master ﬁle, if that
name is not already listed in the securities property ﬁle.
■
-v indicates verbose mode, whereby detailed information regarding the
certiﬁcate is output.
■
-Jjavaoption passes the <javaoption> to the Java interpreter.T his can be
used for changing JVM  parameters; for example, you could ask the JVM
to allocate additional memory for more efﬁcient execution.
T he rest of the options are self-explanatory or have been explained earlier.
N ote that when a new trusted certiﬁcate is being imported, the key identiﬁed by
the alias name should not exist in the keystore. If the alias name already exists in
the keystore, the new certiﬁcate chain will replace the old one associated with
the alias. H owever, this requires that the password being used to protect the
already existing alias entry in the keystore be supplied to the -keypass option
when importing. If you have not supplied the password, you will be prompted for
it; without supplying the valid password, you cannot change the certiﬁcate chain
of the previous alias entry.Also, you cannot create a duplicate alias entry in the
keystore while importing certiﬁcates. If you are determined to use the same alias
for your entry, ﬁrst delete the existing alias using the -delete option (“keytool 
-delete -alias IwantT hisA lias”) and then import the certiﬁcate.
Generating a Self-Signed C ertiﬁcate
A self-signed certiﬁcate can be generated using the -selfcert keytool:
keytool -selfcert {-alias aliasName} {-sigalg signatureAlgorith}
{-dname distinguishedName} {-validity validityDays} [-keypass 
keyPassword] {-storetype storetype} {-keystore keystore} 
[-storepass storePassword] [-provider providerClassName] {-v}
{-Jjavaoption option}
www.syngress.com

Java Secure Sockets Layer • Chapter 10
411
■
-sigalg denotes the algorithm used to sign the certiﬁcate.
■
-dname is the X .500 distinguished name for the C A.
For example, the following command replaces the certiﬁcate chain entry for
the myAlias key with a self-signed certiﬁcate from an authority with a speciﬁed
X .500 distinguished name:
keytool -selfcert -alias myAlias -keypass myPassword -dname "CN=myName,
OU=myUnit, O=muOrganization, L= myCity, S=myState, C=US"
N ote the values for the -dname option:
■
C N denotes common name of a person
■
O U denotes the department, division or unit
■
O denotes the name of the organization
■
L denotes the city
■
S denotes the state or province
■
C denotes the two-letter country code
Importing a C ertiﬁcate From an Identity Database
T he -identitydb keytool option is used to import keys and certiﬁcates from a
JDK 1.1 identity database managed by the javakey tool:
keytool -identitydb {-ﬁle idbFile} {-storetype storetype} {-keystore
keystore} [-storepass storePassword][-provider providerClassName]
{-v} {-Jjavaoption option}
H ere, the -ﬁle option speciﬁes the identity database ﬁle.An identity in the
identity database may have more than one certiﬁcate. H owever, while importing,
only an identity’s ﬁrst certiﬁcate is imported into the keystore.
Referring to Keystores with JSSE Properties
T he Java API’s K eyStore class can be used to refer to the information kept in the
keystore.T his class allows information about keys and certiﬁcates to be accessed
and used in a program. Let us examine this class in detail.
www.syngress.com

412
Chapter 10 • Java Secure Sockets Layer
T he K eyStore C lass
T he K eyStore class is a part of the java.security package.T his class represents the
collection of keys and certiﬁcates contained in the keystore. Since the keystore
contains the two types of entries (keys and certiﬁcates), this class is capable of
managing both.T he K eyStore class’ getInstance() method is used to instantiate it.
T his method has two forms:
getInstance(String keystoreType)
T he ﬁrst form is:
KeyStore ksInstance = KeyStore.getInstance("JKS");
N ote that we are providing the default keystore type (jks).T he above code
will check for a jks keystore implementation  in the environment.
T he second form is:
getInstance(String keystoreType, Provider provider)
T he provider can also be provided with the keystore type when instantiating
the K eyStore class as in the following code:
KeyStore ksInstance = KeyStore.getInstance("JKS", "SUN");
T he system will now determine whether the keystore implementation of the
speciﬁed type exists in the provider package.
Before a keystore can be accessed, the keystore must be loaded; an input
stream is passed to the load() method, which loads the keystore.T his can be
achieved with the following line of code:
ksInstance.load(new FileInputStream(ﬁleName), password);
T he parameter password causes the keystore integrity to be veriﬁed before 
it is loaded. If a null is passed as the input stream parameter, it creates an empty
keystore.
U pon a successful loading, the keystore information can be accessed using
various methods provided by the K eyStore class. M ethods are also available to
modify or delete keystore entries.We discuss some of these methods below:
■
size() T his method returns an integer that gives the number of entries
in the keystore.
■
aliases() T his method returns an E numeration object that contains all
the aliases listed in the keystore.T hese aliases can further be used to
obtain individual information about them.
www.syngress.com

Java Secure Sockets Layer • Chapter 10
413
■
getCertiﬁcate(String aliasName) T his method returns the certiﬁcate
associated with the given alias.
■
getCertiﬁcateChain(String aliasName) T his returns the certiﬁcate
chain associated with the key entry as recognized by the speciﬁed alias
name.
■
getKey(String aliasName, char[] password) T his method returns
the key that is identiﬁed by the given alias.T he password is required to
retrieve the key.
■
containsAlias(String aliasName) T his method returns a Boolean
value that indicates whether the given name exists in the keystore.
■
deleteEntry(String aliasName) T his method deletes the entry corre-
sponding to the given alias.
■
setKeyEntry(String aliasName, Key key, char[] password,
Certiﬁcate[] certChain) T his method assigns the key speciﬁed by key
to the alias given by aliasN ame.T his key entry is protected by the pass-
word given by password while certC hain provides the certiﬁcate chain
associated with the key.
■
setCertiﬁcateEntry(String aliasName, Certiﬁcate cert) T his
method assigns the certiﬁcate given by cert to the key entry recognized
by the alias, aliasN ame.
■
getProvider() T his method returns the provider of the keystore.
■
getType() T his method returns the type of the keystore.
T he C ertiﬁcate C lass
Apart from the K eyStore class, the C ertiﬁcate class in the java.security.cert package
can also be used for getting speciﬁc information on the certiﬁcate entries in the
keystore. For example, when the K eyStore class’ getC ertiﬁcateC hain() method is
called, it returns an array of certiﬁcate objects.T he information and properties
associated with each of these certiﬁcate objects can then be obtained using the
methods given in the C ertiﬁcate class.
T he constructor of the C ertiﬁcate class can be used to create a certiﬁcate by
specifying the type of certiﬁcate.
Certiﬁcate(String certType);
www.syngress.com

414
Chapter 10 • Java Secure Sockets Layer
H ere are some methods of the C ertiﬁcate class:
■
getPublicKey() T his method returns the public key for the certiﬁcate.
■
getType() T his method returns the type of the certiﬁcate.
■
verify(PublicKey key) T his method veriﬁes that the certiﬁcate was
signed using the private key for the public key speciﬁed by key.
■
getEncoded() T his method returns the encoded certiﬁcate.
Let us conclude our discussion by examining some sample code that uses
these JSSE properties to keystore entries.
U sing JSSE Properties to R efer to the keystore
We call our class TestK eys.java.T his class obtains information stored in a keystore
and prints out the information it reads.T he code for TestK eys.java is given in
Figure 10.1.
Figure 10.1 The TestKeys Class
import java.net.*;
import javax.net.ssl.*;
import java.security.*;
import javax.security.cert.X509Certiﬁcate;
import com.sun.net.ssl.*;
import java.io.*;
import java.util.*;
import java.security.cert.*;
public class TestKeys
{
public static void main(String[] args) throws Exception
{
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
char[] passphrase = "passphrase".toCharArray();
KeyManagerFactory kmf = KeyManagerFactory.getInstance
(KeyManagerFactory.getDefaultAlgorithm());
KeyStore ks = KeyStore.getInstance("JKS");
ks.load(new FileInputStream("keys"), passphrase);
System.out.println(ks.getType());
www.syngress.com
Continued

Java Secure Sockets Layer • Chapter 10
415
Enumeration enum = ks.aliases();
while(enum.hasMoreElements())
{
System.out.println("This is the allias " + (String)
enum.nextElement());
}
System.out.println((ks.getProvider()).toString());
System.out.println((ks.getKey("duke", passphrase)).getAlgorithm());
System.out.println((ks.getKey("duke", passphrase)).getFormat());
java.security.cert.Certiﬁcate[] cera = ks.getCertiﬁcateChain("duke");
for (int i = 0; i < cera.length; i++) 
{
System.out.println((cera[i]).getType());
}
}
}
N ote that the code uses the getInstance() method, which receives only the
store type parameter.T he K eyStore instance thus created is loaded using the ﬁle
input stream that points to the ﬁle named “keys”.T he keystore is validated since
the load method is supplied with a password given by passphrase.T he code begins
by obtaining the keystore’s type. It then obtains the E numeration array for all the
entries in the keystore, and prints them to the console. N ote the code fragments:
ks.getKey("duke", passphrase)).getAlgorithm();
ks.getKey("duke", passphrase)).getFormat()
T he ﬁrst fragment uses the getA lgorithm() method to obtain the algorithm
used for the key entry identiﬁed by its alias,“duke.” T he second fragment obtains
the associated format using the getF ormat() method.T he following code obtains
the certiﬁcate chain associated with the key identiﬁed by the alias “duke” in a
certiﬁcate array:
You might be wondering why the key is named duke? Duke is the name of
the java triangle guy! 
ks.getCertiﬁcateChain("duke");
www.syngress.com
Figure 10.1 Continued

416
Chapter 10 • Java Secure Sockets Layer
T he type of each certiﬁcate in this certiﬁcate chain is then printed to the
console using the following line of code:
System.out.println((cera[i]).getType());
H ere cera[i] gives the element at the ith position of the certiﬁcate array.
T he output of the TestK eys class is as given in Figure 10.2.
Using HTTPS URL Handlers
As mentioned in the section on conﬁguring JSSE, the JSSE implementation con-
tains a U R L handler for U R L requests that use the H T T PS  protocol.T his han-
dler can be used only after its implementation package name has been added to
the list of packages searched by the java.net.U R L class.T his can be done statically
by setting the java.protocol.handler.pkgs system property, or dynamically at runtime.
W hen using the H T T PS protocol through proxy servers, you need to set the
https.proxyH ost and https.proxyP ort system properties to point them to the proxy
server’s host name and port, respectively.T his can be achieved by executing the
following code:
java –Dhttp.proxySet=true –Dhttps.proxyHost=proxyMachineName
–Dhttps.proxyPort=8000 
proxyM achineN ame is the name of the host that is serving as the proxy server.
Conﬁguring URL Handler for JSSE
T he java.protocol.handler.pkgs property can be set by specifying the following java
command option at the command line:
java -Djava.
java.protocol.handler.pkgs=\com.sun.net.ssl.internal.www.protocol.
To set the property programmatically, ﬁrst check for any previously conﬁg-
ured protocol handlers. If none are found, just set the java.protocol.handler.pkgs
www.syngress.com
Figure 10.2 Output from TestKeys Class

Java Secure Sockets Layer • Chapter 10
417
property. If a previously conﬁgured protocol handler exists, append the U R L
handler to the existing handlers as shown in the code snippet below:
String prop = System.getProperty("java.protocol.handler.pkgs");
if (prop != null)
prop += "com.sun.net.ssl.internal.www.protocol";
else
prop = "com.sun.net.ssl.internal.www.protocol";
System.setProperty("java.protocol.handler.pkgs",prop);
NOTE
The code listings in this chapter do not check for previously conﬁgured
URL providers since we did not have any other protocol handlers conﬁg-
ured on our system. The code listings directly conﬁgure the URL handler
using the following code line: 
System.setProperty("java.protocol.handler.pkgs","com.sun.net.ssl.
internal.www.protocol");
However, it is advisable to make a check as given in the above code
snippet.
Let us now consider a sample code that conﬁgures the U R L handler for
JSSE. It uses the class A ddproperty.java as in Figure 10.3.
Figure 10.3 Conﬁguring the URL Handler
import java.security.*;
public class Addproperty
{
public static void main(String[] args) 
{
try
{
//This line of code Conﬁgures the HTTPS URL handler
System.setProperty("java.protocol.handler.pkgs", "com.sun.net.ssl.
internal.www.protocol");
//This property registers the SunJSSE provider.
www.syngress.com
Continued

418
Chapter 10 • Java Secure Sockets Layer
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
}
catch(Exception ex)
{
ex.printStackTrace();
}
}
}
T his is evidently a two-line code that sets the U R L handler and sets the
provider (See the section on conﬁguring JSSE for details)
Creating a HTTPS Connection
We’ll now examine an example that illustrates conﬁguring the U R L handler for
JSSE and using it to connect to a U R L using H T T PS.
U sing the U R L H andler
We use the U R L H andler class to implement the JSSE U R L handler dynamically
at runtime. It then connects to a U R L using H T T PS and creates a B ufferedR eader
instance to read data from the U R L.T he data so read is then echoed as output.
C ode for the U R L H andler class is shown in Figure 10.4.
Figure 10.4 The URLHandler Class
import java.net.*;
import java.io.*;
import javax.net.ssl.*;
import java.security.*;
public class URLHandler {
public static void main(String[] args) throws Exception {
System.setProperty("java.protocol.handler.pkgs", "com.sun.net.ssl.
internal.www.protocol");
URL verisign = new URL("https://netbanking");
www.syngress.com
Figure 10.3 Continued
Continued

Java Secure Sockets Layer • Chapter 10
419
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
BufferedReader in = new BufferedReader(new InputStreamReader
(verisign.openStream()));
System.out.println("Testing the code");
String inputLine;
while ((inputLine = in.readLine()) != null)
System.out.println(inputLine);
in.close();
}
}
T he output from the U R L H andler class is as shown in Figure 10.5. N ote that
this output represents the H T M L content returned by the U R L.
Figure 10.4 clearly shows that once the U R L handler has been implemented,
the java.net.U R L class can be used to create a U R L that uses the H T T PS.
URL verisign = new URL("https://netbanking");
T his U R L can then be used to open an input stream from the U R L, just as is
done when creating an H T T P connection. Data can be read using any of the
methods available to the reader instance associated with the input stream.T he
U R L H andler class in Figure 10.4 uses the readL ine() method to read one line at a
time from the H T T PS connection.
T hus, with the exception of setting the JSSE U R L handler, the process
involved in securing an H T T PS connection is the same as for an H T T P U R L
connection.
www.syngress.com
Figure 10.4 Continued
Figure 10.5 Output from the URLHandler Class

420
Chapter 10 • Java Secure Sockets Layer
Using SocketFactories
T he U R Ls discussed in the previous section provide a high-level mechanism for
connections over a network. Sockets on the other hand, provide a lower-level
interface for making connections and accessing resources over a network. Let us
discuss the various classes available for creating sockets. Sockets are mainly used
for client-server applications where multiple clients connect to a single server
over a network.T he server implements the socket-server, which is capable of
accepting multiple client connections. Let us explore the concept of sockets.
Creating Sockets and ServerSockets (By Hand)
T he java.net package provides two classes: the Socket class and the ServerSocket
class implement the client side and server side of the sockets, respectively.
T he ServerSocket C lass
Another class from the java.net package, the ServerSocket class implements the lis-
tener service on the server.T he ServerSocket class listens at a speciﬁed port for
client requests and accepts them. Since a request is always initiated by a client, the
server needs to be a listening program, hence the need for a server socket.T he
following line of code creates a server socket that listens at the port 5555:
ServerSocket serverSocket = new ServerSocket (5555);
WARNING
Before implementing a server socket, ensure that the port at which the
listener listens is not being used by any other application on the server
machine. Also, socket numbers 1-1024 are reserved for system functions
and should generally not be used by applications.
In the code line above, port 5555, becomes dedicated to the listener program
implementing the server socket.T his server socket can be used to accept client
connections:
Socket clientConnection = serverSocket.accept();
T he above code would open a new socket on the server machine to send
data to the client or receive data from the client. R eaders should note that if a
class fails to create a socket, it throws an IO E xception error.
www.syngress.com

Java Secure Sockets Layer • Chapter 10
421
T he Socket C lass
T he Socket class in the java.net package is used to create the client socket.T he
communication is through the input and output streams associated with the
socket.A socket can be created as follows:
Socket clientSocket = new Socket(localhost, 5555);
T his creates a socket on the local machine by connecting to the listening port
(in this case, 5555) on the server machine (localhost). R eaders should replace
localhost with the name of their computer.To read from a socket, an input stream
can be opened using the socket instance:
BufferedInputStream clientIPStream = new
BufferedInputStream(clientSocket.getInputStream());
Similarly, output streams can be created to use the socket for writing:
BufferedOutputStream clientOPStream = new
BufferedOutputStream(clientSocket.getOutputStream());
T hese streams can now be used by the client to read or write data using the
clientSocket instance.
Using SocketFactories and
ServerSocketFactories
Another method of creating sockets and server sockets is by using the factory
classes, SocketF actory and ServerSocketF actory, respectively.
T he SocketF actory C lass
T he SocketF actory class is an abstract class that extends the java.lang.O bject class:
public abstract class SocketFactory extends Object
T his class provides the createSocket() method to create sockets:
public abstract Socket createSocket(String hostMachine, int port) throws
IOException,                                 UnknownHostException
If the host computer referred by hostM achine is unreachable, an IO E xception
is thrown, and if the name given by hostM achine cannot be resolved, an
U nknownH ostE xception is thrown. N ow, suppose we want to create a socket at
port 2022 using the Socket class.T he following line of code may be used:
Socket factorySocket = SocketFactory.createSocket(localhost, 2022);
www.syngress.com

422
Chapter 10 • Java Secure Sockets Layer
T he ServerSocketF actory C lass
T his class is also an abstract class that extends the java.lang.O bject class as follows:
public abstract class ServerSocketFactory extends Object
It can be used to create server sockets using the createServerSocket() method,
which returns a server socket bound to the speciﬁed port on the server machine.
public abstract ServerSocket createServerSocket(int port)
throws IOException
To create a server socket at port 5555, the following line of code may be used:
ServerSocket factoryServerSocket = ServerSocketFactory.
createServerSocket(5555);
Advantages of SocketFactories
Socket factories offer the following advantages:
■
Both factories and sockets show polymorphism.T his enables an applica-
tion to use different types of sockets by passing different kinds of factories.
■
T he parameters used in socket construction can be used to customize
factories. Practical use of such customization could be to obtain sockets
with different networking timeouts
■
T he sockets created by using factory classes can expose features like
statistics collection, compression, and so on.
Determining Default and Installed Cipher Suites
C onnecting to a U R L using H T T PS requires a handshaking mechanism.
H andshaking ensures that the two connecting machines support compatible
cipher suites, which are required to transmit and receive data over a secure con-
nection.T he cipher suites installed on a machine may differ from the cipher suits
it supports. (T his is equivalent to a feature being supported by a machine but not
being installed on it.) During the handshaking process, the two connecting
machines exchange cipher suite information to determine if they can connect
using a secure connection.T he cipher suites installed on a machine can be
obtained using the getC ipherSuites() method, which returns the available cipher
suits in the form of an array of string values. Let us illustrate this concept with 
an example.
www.syngress.com

Java Secure Sockets Layer • Chapter 10
423
Determining the Installed C ipher Suites
We create a class called JSSE _ install_ check.java, which prints out the installed
cipher suites.T he code for this class is given in Figure 10.6.
Figure 10.6 The JSSE_install_check.java Class
import java.net.*;
import javax.net.ssl.*;
import java.security.*;
public class JSSE_install_check 
{
public static void main(String[] args) throws Exception 
{
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
SSLServerSocketFactory myfactory = (SSLServerSocketFactory)
SSLServerSocketFactory.getDefault();
SSLServerSocket mysslSocket = (SSLServerSocket)
myfactory.createServerSocket( 5757 );
String [] cipherSuites = mysslSocket.getEnabledCipherSuites();
for (int i = 0; i < cipherSuites.length; i++) 
{
System.out.println(cipherSuites[i]);
}
}
}
N ote that since cipher suites constitute an SSL concept, the SunJSSE provider
is being conﬁgured at runtime.T he SSL ServerSocketF actory class is being instanti-
ated using its getD efault() method.T his instance is then being used to create a
ServerSocket at port 5757.T he getE nabledC ipherSuites() method is used by the
www.syngress.com

424
Chapter 10 • Java Secure Sockets Layer
instance of the server socket (mysslSocket) to obtain the installed cipher suites.T he
output for this class is shown in Figure 10.7.
Using Secure Server Sockets
We have already seen how server sockets are created and what purpose they
serve. N ow let us examine the process of securing server sockets.A secure socket
is one that supports data transmission between a client and server over SSL.
Secure sockets behave like normal sockets, except that they add a security layer to
the underlying transport protocol  (T C P) being used on the client-server net-
work.T his security layer provides protection as entailed in the SSL protocol.T he
protection provided covers the following:
■
Data Integrity SSL protects against the modiﬁcation of messages
during transmission.
■
Authentication SSL provides for server authentication as well as client
authentication (if requested by the server).T his ensures that data is being
sent to or received from a bonaﬁde resource that is authorized to receive
or send the data.
■
Conﬁdentiality/ Privacy SSL encrypts the data being exchanged 
over the network.T his ensures that wiretapping measures cannot access
sensitive/ conﬁdential data, such as a user’s personal information.
We will now describe the process of creating secure server sockets; and
explain how secure server sockets accept connections and how secure content
can be read or written using them.T hese concepts will then be consolidated with
the help of an example.
www.syngress.com
Figure 10.7 Printing the Available Cipher Suites

Java Secure Sockets Layer • Chapter 10
425
Getting the Secure Socket Factory
T he SSL ServerSocketF actory class in the javax.net.ssl package acts as the factory 
that creates secure server sockets.T his is an abstract class that extends the
ServerSocketF actory class.
public abstract class SSLServerSocketFactory extends ServerSocketFactory
T he fact that the SSL ServerSocketF actory class extends the ServerSocketF atory
class should come as no surprise.T he basic purpose and working of a secure
socket remain the same as for an ordinary socket, except that secure content can
be transmitted through it.T he secure server factory encompasses the details of
creating and conﬁguring secure sockets.T hese details, in turn, include informa-
tion on authentication keys, cipher suites, certiﬁcate validation etc.
T he secure server socket factory can be obtained as follows:
■
By calling the getD efault() method, which returns the default implemen-
tation of the SSL ServerSocketF actory.
SSLServerSocketFactory.getDefault();
T he value of the SSL .ServerSocketF actory.provider security property in
the Java security properties ﬁle determines the default factory imple-
mentation; this property can be set to a desired class. Finally, an instantia-
tion exception is thrown if SSL has not been properly conﬁgured for a
virtual machine.
■
By using an instance of the SSL C ontext class.T he SSL C ontext class
encapsulates state information (session state information, for example)
that is shared by all sockets created under that context.T he SSL C ontext
can be instantiated as follows:
SSLContext SSLContextInstance = SSLContext.getInstance("SSL");
Information on conﬁguring the context instance and associated
methods shall be discussed later with reference to Figure 10.8. For the
time being, we use this context instance to obtain a factory instance
using the following code.
SSLServerSocketFactory factoryInstance =  SSLContextInstance.
getServerSocketFactory();
We will now use this factory instance to create a secure server socket.
www.syngress.com

426
Chapter 10 • Java Secure Sockets Layer
Registering a Secure Server Socket
T he SSL ServerSocket class in the javax.net.ssl package creates a server socket that
is protected using the SSL protocol.
public abstract class SSLServerSocket extends ServerSocket
As expected, this class provides methods that are speciﬁc to secure sockets.A
secure server socket can be created by using an instance of the factory class.
SSLServerSocket mysslSocket = (SSLServerSocket)factoryInstance.
createServerSocket(5757);
T he above code creates a secure socket server on port 5757 of the host
machine, using the instance of SSL server socket factory class, factoryInstance.
Accepting Connections
Just as with server sockets, a secure server socket can be used to accept secure
connections from clients.T he SSL ServerSocket class uses the accept() method of its
super class (the ServerSocket class) to accept client connections.T he secure server
socket listens for communication from clients and accepts a connection when
requested by a client.
Socket mySocket = mysslSocket.accept();
Accepting a connection returns a socket on the client machine. If the con-
nection cannot be accepted, the accept() method throws an IO E xception or a
SecurityE xception.T he SecurityE xception is thrown when an existing security man-
ager disallows connections from the requesting client machine.
Reading Data
T he secure server socket is similar to a server socket, except for the additional
security it provides.T hus, it uses the same reader and input stream classes for
reading client data as are used by the server sockets. For example, let us create a
B ufferedR eader using the InputStream associated with the mySocket socket created
above.
BufferedReader readdata = new BufferedReader(new
InputStreamReader(mySocket.getInputStream()));
T his B ufferedR eader can now be used to read data from the client, using any of
the available methods of the B ufferedR eader class.
www.syngress.com

Java Secure Sockets Layer • Chapter 10
427
Writing Data
In a manner similar to that for reading data, we can write data back to the client
using an output stream.All methods associated with output streams will be avail-
able to the server socket.A print stream is created for the secure server socket in
the following line of code:
PrintStream send = new PrintStream(mysocket.getOutputStream());
T he send object of the P rintStream type can now be used to write data to a
client as follows:
send.println("This text is response from server");
send.ﬂush();
T he ﬂush() method commits the response.
Closing Connections
T he input and output streams associated with a secure server socket can be closed
using their respective close() methods.T he secure server socket also inherits the
close() method from any ServerSocket class that closes a socket. Each of these close
methods close their respective streams/ sockets and free up the system resources
being utilized by them.
send.close(); // closes the output stream
readdata.close(); // closes the input stream
mysocket.close(); // closes the socket
We will now consider an example in which a secure server socket is created
and used to accept a connection from a client, read data from that client, and
write data back to it in Figure 10.8.
Figure 10.8 The SecureServer Class
import java.net.*;
import javax.net.ssl.*;
import java.security.*;
import java.io.*;
import javax.security.cert.X509Certiﬁcate;
import com.sun.net.ssl.*;
public class SecureServer 
{
www.syngress.com
Continued

428
Chapter 10 • Java Secure Sockets Layer
public static void main(String[] args) throws Exception 
{
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
char[] passphrase = "passphrase".toCharArray();
SSLContext ctx = SSLContext.getInstance("SSL");
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
KeyStore ks = KeyStore.getInstance("JKS");
ks.load(new FileInputStream("keys"), passphrase);
kmf.init(ks, passphrase);
ctx.init(kmf.getKeyManagers(), null, null);
SSLServerSocketFactory myfactory = ctx.getServerSocketFactory();
SSLServerSocket mysslSocket = SSLServerSocket)
myfactory.createServerSocket(5757);
System.out.println("Server Started");
SSLSocket mysocket = (SSLSocket)mysslSocket.accept();
PrintStream send = new PrintStream(mysocket.getOutputStream());
BufferedReader readdata = new BufferedReader(
new InputStreamReader(mysocket.getInputStream()));
String myrequest = readdata.readLine(); 
System.out.println(myrequest);
send.println("This text is response from server");
send.ﬂush();
send.close();
readdata.close();
mysocket.close();
}
}
www.syngress.com
Figure 10.8 Continued

Java Secure Sockets Layer • Chapter 10
429
Figure 10.8 introduces another concept, that of the K eyM anagerF actory class.
T his class acts as a factory for creating key managers, depending upon a source of
key material. Each key manager manages a speciﬁc type of key material that is
provider-speciﬁc or based on a keystore. H ere the line of code K eyM anagerF actory
.getInstance(“ SunX 509” ); generates an instance of the K eyM anagerF actory class by
passing the name of the algorithm,“SunX 509” to its getInstance() method.T he
code fragment, kmf.getK eyM anagers(), generates one key manager for each type 
of key material.
T he K eyStore class is instantiated and the keystore is loaded (T hese steps 
have already been discussed in the “R eferring to keystores with JSSE properties”
section).
T he SSL C ontext class is invoked by passing the protocol SSL as a parameter.
T his creates an SSL context object that implements the SSL protocol; the 
init() method initializes the SSL context.T he array of key managers generated
using the getK eyM anagers() method is passed to the SSL C ontext object to 
initialize it. N ote that we are using the SSL context instance to instantiate the
SSL ServerSocketF actory class.T he secure server socket created using the factory
class is then used to print out the enabled cipher suites on the server.T his socket,
mysslSocket, is also used to read data from the client.T he text “T his text is
response from server” is written back to the client.
Using Secure Client Sockets
A secure client socket can be created in two ways.
■
By using the SSL SocketF actory class.T he factory class is ﬁrst instantiated
using its getD efault() method:
SSLSocketFactory.getDefault();
T his returns the default implementation of the factory class.T he fac-
tory class’ createSocket() method can be used to create a secure socket
using the following code:
FactoryInstance.createSocket(Socket s, Sting hostname, int
portNumber);
T his returns a secure socket on the port of the host speciﬁed by
hostname.
www.syngress.com

430
Chapter 10 • Java Secure Sockets Layer
■
T hrough the accept() method of the SSL ServerSocket.W hen a secure
server socket accepts a client connection, it returns a secure socket on
the client machine using the following code:
SSLSocket secureSocket = mysslSocket.accept();
H ere, mysslSocket is the server socket instance.
Connecting to a Remote Secure Server
First, a secure server is created on the client machine using the factory instance.
T his secure socket is then used to obtain the set of supported cipher suites. N ote
that this is important because the creation of a secure connection requires the use
of these cipher suites during the handshake process.
SSLSocket socket = (SSLSocket)factory.createSocket("localhost", 5757);
String [] cipherSuites = socket.getSupportedCipherSuites();
socket.setEnabledCipherSuites(cipherSuites);
T he actual connection is created when the socket’s startH andshake() method is
called.T his method starts an SSL handshake between the client and server
machines, including the exchange of information pertaining to the cipher suites,
encryption keys, and so on.
socket.startHandshake();
If a network error is encountered, the method throws an IO E xception.
Writing Data
Data can be written from the client to the server by using the getO utputStream()
method associated with a secure client socket. N ote that this method is inherited
from SSL Sockets’s super class, the Socket class, and hence the returned stream
behaves exactly as an output stream would. C onsequently, all methods associated
with output streams (write(), ﬂush(), close()) are available to the secure socket.
T he following lines of code write the text “T his text is sent by the client as
request to the server” to the server:
String str1 = "This text is sent by the client as request to the server";
PrintStream send = new PrintStream(socket.getOutputStream());
send.println(str1);
send.ﬂush();
www.syngress.com

Java Secure Sockets Layer • Chapter 10
431
Reading Data
As with writing data, a secure socket uses the Socket class’s getInputStream()
method for reading data from the server. C onsequently, all methods associated
with input streams (read(), close(), skip()) are available to the secure socket.
T he following lines of code read data from the server and print it to the 
console:
BufferedReader readdata = new BufferedReader(new InputStreamReader
(socket.getInputStream()));
String str = readdata.readLine();
System.out.println(str);
Closing the Connection
T he input/ output streams associated with the socket can be closed using their
respective close() methods.T he secure socket also inherits the close() method from
the Socket class.T he close() method frees the system resources being used by the
object (input/ output stream or socket) on which it is called.
send.close(); // closes the output stream
readdata.close(); // closes the input stream
mysslsocket.close(); // closes the socket
We now create the client side for the secure server socket.T he code for the
SecureC lient class is given in Figure 10.9.
Figure 10.9 Code for SecureClient
import java.net.*;
import java.io.*;
import javax.net.ssl.*;
import java.security.*;
import javax.security.cert.X509Certiﬁcate;
import com.sun.net.ssl.*;
public class SecureClient
{
public static void main(String[] args) throws Exception 
{
www.syngress.com
Continued

432
Chapter 10 • Java Secure Sockets Layer
Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
try 
{
char[] passphrase = "passphrase".toCharArray();
SSLContext ctx = SSLContext.getInstance("SSL");
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
KeyStore ks = KeyStore.getInstance("JKS");
ks.load(new FileInputStream("keys"), passphrase);
kmf.init(ks, passphrase);
ctx.init(kmf.getKeyManagers(), null, null);
SSLSocketFactory factory = ctx.getSocketFactory();
SSLSocket socket = (SSLSocket)factory.createSocket("localhost", 5757);
String [] cipherSuites = socket.getSupportedCipherSuites();
socket.setEnabledCipherSuites(cipherSuites);
socket.startHandshake();
String str1 = 
"This text is sent by the client as request to the server";
PrintStream send = new PrintStream(socket.getOutputStream());
send.println(str1);
send.ﬂush();
BufferedReader readdata = new BufferedReader(
new InputStreamReader(socket.getInputStream()));
String str = readdata.readLine(); 
System.out.println(str);
}
catch(Exception ex)
{
ex.printStackTrace();
}
}
}
www.syngress.com
Figure 10.9 Continued

Java Secure Sockets Layer • Chapter 10
433
R un the secure server socket and the secure client socket from Figure10.8
and Figure 10.9, respectively. Start by running the server ﬁrst. U se the java
SecureServer java command, at the command prompt to run the server.W hen you
see the“Server Started” string message (See Figure 10.10) on the server console,
run the client using the SecureC lient java command in another command-line
window.T he client will now try to connect to the server. U pon accepting the
client connection, the server console will show the message “T his text is sent by
the client as request to the server” as shown in Figure 10.10.T his is the message
that the client sends to the server.T he server will now send the string message
“T his text is response from server” to the client.T he client, upon reading this
message, will print it to the client console as shown in Figure 10.11.
www.syngress.com
Conﬁguring the Cacerts File
To ensure that the client-server programs in Figure 10.8 and Figure 10.9
work properly, the following procedure may be adopted:
1. Locate the ﬁle titled “samplecacerts” in your JSSE directory. It
is likely to be found in the JSSE/Samples directory. 
2. Copy the “samplecacerts” ﬁle into the  Program
Files/JavaSoft/JRE 1.2.1/Security/ directory. 
3. Rename the “samplecacerts” ﬁle to “jssecacerts.”
When the server/client is run, the program tries to locate this ﬁle to
obtain certiﬁcate information. Not performing this step may result in the
code not working properly.
Developing & Deploying…
Figure 10.10 The Server Console

434
Chapter 10 • Java Secure Sockets Layer
www.syngress.com
Figure 10.11 The Client Console
Using the Debug Mode
The output for the client-server classes, SecureServer and SecureClient
are as shown in Figure 10.10 and Figure 10.11, respectively. The mes-
sage that is read by the client/server gets printed to the console aswould
have happened if the client and server were connected without using
SSL. Yet there is a difference, which will become apparent when these
two programs are run in the debug mode as explained below.
To enable debugging, compile and run the following code (just as
you run a java program in the normal mode):
import com.sun.net.ssl.*;
public class DebugHelp
{
public static void main(String[] args)
{
com.sun.net.ssl.internal.ssl.Debug.Help() ;
}
}
After you have run this program, use the following command to
run the server:
java –Djavax.net.debug=all SecureServer
When you run this command, you will ﬁnd a huge amount of data
scrolling up the server console. This information includes information on
the truststore location, truststore type, key information from the trust-
store, associated certiﬁcate information from the “jssecacert” ﬁle, and
so on. To obtain details of the information being printed on the server
console, you may save this information as a text ﬁle using the following
command:
Debugging…
Continued

Java Secure Sockets Layer • Chapter 10
435
www.syngress.com
java –Djavax.net.debug=all SecureServer>server.txt
This will create the ﬁle “server.txt” in the same directory that con-
tains the SecureServer class ﬁle.
While going through the “server.txt” ﬁle you will come across infor-
mation on the key known as “duke”, and that happens to be the only
key entry in our keystore. This will be followed by the key’s certiﬁcate
chain. Details of each certiﬁcate, like the signature algorithm, validity
period, the issuer of the certiﬁcate, and the serial number. will be enu-
merated. (If the keystore had contained any other keys, information on
their certiﬁcates would also have been printed). After all the certiﬁcates
are read, the server is ready to service client requests. The text message
“Server Started” will appear at the end of the information on the cer-
tiﬁcates in the certiﬁcate chain of the keystore entry known as “duke”.
Now run the client using the following command:
java –Djavax.net.debug=all SecureClient.
The client output will also begin with the listing of certiﬁcates as in
the case of the server. This output can be saved in a text ﬁle using the
following command:
java –Djavax.net.debug=all SecureClient>client.txt
client.txt will now contain the complete output from the client 
console.
Going beyond the line “Server Started” in server.txt, you will ﬁnd
phrases like “ClientHello” and “ServerHello” followed by information on
cipher suites and compression methods. Interspersed with the certiﬁcate
information being exchanged between the client and the server, you may
find 
text 
information 
like 
“ServerHelloDone,” 
“Handshake,”
“ClientKeyExchange,” “SESSION KEYGEN,” “CONNECTION KEYGEN” and
so on that gives an idea about the process followed during the handshake.
The console outputs for the server and client are shown in Figure
10.12 and Figure 10.13 respectively. Since these images do not list the
complete console output, it is recommended that you refer to server.txt
and client.txt.
Note that data sent from the client to the server and back is
encrypted. This data is decrypted at the receiving end and thet resprec-
tive text messages are displayed. The server ﬁle will contain phrases 
such as “Plaintext after DECRYPTION:  len = 77” and “Plaintext before
ENCRYPTION:  len = 54,” followed by the encrypted/ decrypted mes-
sage. The client request will appear as a string message.
Continued

436
Chapter 10 • Java Secure Sockets Layer
www.syngress.com
The client ﬁle will also contain similar information regarding
client/server hello and handshaking, except that it will be listed in the
order that is appropriate for the client side.
Figure 10.12 Server Output in Debug Mode
Figure 10.13 Client Output in Debug Mode

Java Secure Sockets Layer • Chapter 10
437
Using JSSE Applications with WSDP
T he JSSE examples covered in previous sections run as Java programs using the
command line. H owever, JSSE can also be used to create secure Web services.
T herefore, in this section we present modiﬁed codes from previous examples and
their associated Java Server Pages (JSP) to run them as Web services.T hese Web
services are compatible with the latest Java Web Service Developers Pack
(W SDP) release (W SDP/ 1.0-ea2).
We begin with the TestK eys.java class from Figure 10.1, which appears in a
modiﬁed version in Figure 10.14. C ode modiﬁcation is imperative since the code
of Figure 10.1 (and subsequent examples given in this chapter) use the main()
method to print the output to the console. H owever, a Web service requires that
the output be displayed in a browser/ web-client.T hus, the code should be modi-
ﬁed so that it may be called in a JSP page (whose output is sent to the browser)
as a Java Bean.
T he modiﬁed version of TestK eys.java uses JSSE properties in a manner sim-
ilar to the listing in Figure 10.1.T he difference is that we have removed the
main() method and its System.out.println() statements. Instead, we retrieve all the
key and certiﬁcate properties within a method, named getValues(), that returns a
string buffer.T his string buffer contains the key, keystore, and certiﬁcate informa-
tion retrieved using JSSE.T he modiﬁed code is as follows:
Figure 10.14 Modiﬁed Version of TestKeys.java
import java.net.*;
import javax.net.ssl.*;
import java.security.*;
import javax.security.cert.X509Certiﬁcate;
import java.io.*;
import java.util.*;
import java.security.cert.*;
public class TestKeys
{
public StringBuffer getValues() throws Exception
{
//Security.addProvider(new com.sun.net.ssl.internal.ssl.Provider());
StringBuffer str = new StringBuffer();
char[] passphrase = "passphrase".toCharArray();
www.syngress.com
Continued

438
Chapter 10 • Java Secure Sockets Layer
KeyManagerFactory kmf = KeyManagerFactory.getInstance(
KeyManagerFactory.getDefaultAlgorithm();
KeyStore ks = KeyStore.getInstance("JKS");
ks.load(new FileInputStream("keys"), passphrase);
str = str.append("This is the Type of KeyStore :" + ks.getType() + "|");
Enumeration enum = ks.aliases();
while(enum.hasMoreElements())
{
str = str.append("This is the allias " + (String)enum.
nextElement() + "|" );
}
str = str.append("This is the provider of the KeyStore: " + 
(ks.getProvider()).toString() + "|");
str = str.append("This is the algorithm used: " + 
(ks.getKey( "duke", passphrase )).getAlgorithm() + "|");
str = str.append("This is the keys Format: " + 
(ks.getKey("duke", passphrase)).getFormat() + "|");
java.security.cert.Certiﬁcate[] cera = ks.getCertiﬁcateChain("duke");
for (int i = 0; i < cera.length; i++) 
{
str = str.append("This is the certiﬁcate type: " +   
(cera[i]).getType() + "|");
}
return str;
}
}
T he getValues() method appends the retrieved information to the string buffer
variable (str) with each entry separated by the pipe (| ) character.T his enables the
calling JSP page to split the returned string buffer into individual properties.
Figure 10.15 lists the testKeys.jsp, which makes use of the TestK eys class from
Figure 10.14.
www.syngress.com
Figure 10.14 Continued

Java Secure Sockets Layer • Chapter 10
439
Figure 10.15 Calling the TestKeys Class in the testKeys.jsp page
<%@ page import="java.util.*" %>
<%@ page import="TestKeys" %>
<%@ page contentType="text/html; charset=ISO-8859-5" %>
<html>
<head>
<title>Socket Server Application</title>
</head>
<body bgcolor="white">
<jsp:useBean id="mykeys" scope="application" class="TestKeys"/>
<h1><FONT FACE="ARIAL" SIZE=12>TestKeys Application JSP page</FONT></h1>
<hr>
<% 
StringBuffer str1 = mykeys.getValues();
String mystring = str1.toString();
StringTokenizer token = new StringTokenizer(mystring,"|");
while(token.hasMoreTokens())
{
%>
<p><FONT FACE="ARIAL" SIZE=6><%=token.nextToken()%>
<% } %>
</body>
</html>
testK eys.jsp imports the TestK eys class and uses it as a bean with the ID
mykeys.T he following code line calls the getValues() method of the TestK eys class
and stores the string buffer returned by it in the str1:variable.
StringBuffer str1 = mykeys.getValues();
T he string buffer variable is converted to a string using the toString() method.
T his string is broken into tokens using the StringTokenizer class as given in the
following code line:
StringTokenizer token = new StringTokenizer(mystring,"|");
A while loop is then run to display all these tokens in the browser using the
output directive <%=token.nextToken()%>.T he testKeys.jsp page when run in
the browser displays the output as shown in Figure 10.16.
www.syngress.com

440
Chapter 10 • Java Secure Sockets Layer
N ote that this output is similar to the console output shown in Figure 10.2,
except that it contains a description string preﬁxed to each property value.
U sing the U R LH andler in a Web Service
O nce again, we modify the code listing of Figure 10.4 to add a pdata() method to
the U R L H andler.java class to return a string buffer.T he pdata() method is as fol-
lows (It is left to the readers to incorporate this method into a U R L H andler.java
class in order to run the JSP from Figure 10.17):
public StringBuffer pdata()
{
StringBuffer str = new StringBuffer();
try
{
URL verisign = new URL("https://www.verisign.com");
BufferedReader in = new BufferedReader(
new InputStreamReader(verisign.openStream()));
String inputLine;
while ((inputLine = in.readLine()) != null)
{
str = str.append(inputLine);
}
in.close();
}
catch(Exception ex)
www.syngress.com
Figure 10.16 Output of testKeys.jsp

Java Secure Sockets Layer • Chapter 10
441
{
System.out.println(ex);
}
return str;
}
T he code, for urlhandler.jsp, that calls the modiﬁed U R L H andler.java class is
given in Figure 10.17.
Figure 10.17 The urlhandler.jsp page
<%@ page import="java.util.*" %>
<%@ page import="URLHandler" %>
<%@ page contentType="text/html; charset=ISO-8859-5" %>
<jsp:useBean id="myURLHandler" scope="application" class="URLHandler"/>
<% 
StringBuffer str1 = myURLHandler.pdata();
%>
<%=str1.toString()%>
Akin to the U R L H andler class from Figure 10.4, urlhandler.jsp shows the
H T M L content from the invoked site (www.verisign.com). Since the output here
appears not on the console but on the browser, the H T M L is decoded by the
browser and the content of the H T M L page is displayed as shown in Figure 10.18.
www.syngress.com
Figure 10.18 Output from the urlhandler.jsp page

442
Chapter 10 • Java Secure Sockets Layer
NOTE
The output of urlhandler.jsp, when displayed in the browser, does not
show most of the images. This is because most of the image tags in the
source HTML contain relative URLs for the src (image source) property. If
you use the browser’s View-Source menu to see the source HTML, you
will come across image tags in the following format:
<img src=”/images/…/abc.gif”>
The src property in the above tag does not give the physical path of
the images directory in whose subfolder(s) the images reside. Instead, it
deﬁnes the path of images directory relative to the root of the web site.
When you read the HTML content as a stream and display it using a JSP
output directive, the browser tends to look for the images directory in
the default JSP root folder on the local machine. Since the actual images
are on the verisign web server and not on the local machine, the browser
fails to locate them. If the src property of an <img> tag contains a com-
plete URL of the form http://www.verisign.com/images/…/abc.gif, then
the browser will retrieve the image from the verisign server (provided
you are online) and display it.
Displaying the Installed C ipher 
Suites through a Web Service
To display the cipher suites in a browser using a Web service, we create a JSP
called security.jsp. Instead of modifying the existing java class install_ check.java of
Figure 10.6 and calling it as a bean in security.jsp, we include the actual code
fragments within the JSP page to obtain the enabled cipher suites and to output
them. (T he same methodology of including java code in JSP pages can also be
used in the code listings of Figure 10.15 and Figure 10.17). Figure 10.19 contains
code listing for security.jsp.
Figure 10.19 Code for security.jsp
<%@ page import="java.net.*" %>
<%@ page import="javax.net.ssl.*" %>
<%@ page import="java.security.*" %>
<%@ page contentType="text/html; charset=ISO-8859-5" %>
<html>
www.syngress.com
Continued

Java Secure Sockets Layer • Chapter 10
443
<head>
<title>Security Check Application</title>
</head>
<body bgcolor="white">
<h1><FONT FACE="ARIAL" SIZE=6>
Security Check Application JSP page
</FONT></h1>
<%
SSLServerSocketFactory myfactory = 
(SSLServerSocketFactory)
SSLServerSocketFactory.getDefault();
SSLServerSocket mysslSocket = 
(SSLServerSocket)myfactory.createServerSocket(5757);
String [] cipherSuites = mysslSocket.getEnabledCipherSuites();
for (int i = 0; i < cipherSuites.length; i++) 
{
%>
<p><FONT FACE="ARIAL" SIZE=2><%=cipherSuites[i]%>
<% 
} 
%>
</body>
</html>
T his code needs no explanation since it contains fragments from the
install_ check.java class that have already been explained (See code listing in 
Figure 10.6).T he output directive <%=cipherSuites[i]%> displays the cipher 
suites on the browser as shown in Figure 10.20.
C lient-Server Web Service
O nce again we use the modiﬁed forms of SecureServer.java and SecureC lient.java as
beans in their respective JSPs.T he modiﬁed version of SecureServer.java is listed in
Figure 10.21 and encloses the working code (previously within the main()
method) in a user deﬁned method named startServer().
www.syngress.com
Figure 10.19 Continued

444
Chapter 10 • Java Secure Sockets Layer
Figure 10.21 Modiﬁed Version of SecureServer.java
import java.net.*;
import javax.net.ssl.*;
import java.security.*;
import java.io.*;
import javax.security.cert.X509Certiﬁcate;
//import com.sun.net.ssl.*;
import java.util.*;
public class SecureServer 
{
public StringBuffer startServer() throws Exception
{
StringBuffer str = new StringBuffer();
char[] passphrase = "passphrase".toCharArray();
SSLContext ctx = SSLContext.getInstance("SSL");
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
KeyStore ks = KeyStore.getInstance("JKS");
ks.load(new FileInputStream("keys"), passphrase);
kmf.init(ks, passphrase);
ctx.init(kmf.getKeyManagers(), null, null);
www.syngress.com
Figure 10.20 Output of security.jsp
Continued

Java Secure Sockets Layer • Chapter 10
445
SSLServerSocketFactory myfactory = ctx.getServerSocketFactory();
SSLServerSocket mysslSocket = 
(SSLServerSocket)myfactory.createServerSocket(5757);
str = str.append("Server Started" + "|");
SSLSocket mysocket = (SSLSocket)mysslSocket.accept();
PrintStream send = new PrintStream(mysocket.getOutputStream());
BufferedReader readdata = new BufferedReader(
new InputStreamReader(mysocket.getInputStream()));
String myrequest = readdata.readLine(); 
str = str.append(myrequest);
send.println("This text is response from server\n");
send.ﬂush();
send.close();
readdata.close();
mysocket.close();
return str;
}
T he startServer() method returns a string buffer containing the message that
was received from the client.T his method is called in the server.jsp page as shown
in Figure 10.22.
Figure 10.22 Calling SecureServer.java from server.jsp
<%@ page import="java.util.*" %>
<%@ page import="SecureServer" %>
<%@ page contentType="text/html; charset=ISO-8859-5" %>
<html>
<head>
<title>Socket Server Application</title>
</head>
www.syngress.com
Figure 10.21 Continued
Continued

446
Chapter 10 • Java Secure Sockets Layer
<body bgcolor="white">
<jsp:useBean id="myServer" scope="application" class="SecureServer"/>
<h1><FONT FACE="ARIAL" SIZE=12>Server Application JSP page</FONT></h1>
<hr>
<% 
StringBuffer str1 = myServer.startServer();
String mystring = str1.toString();
StringTokenizer token = new StringTokenizer(mystring,"|");
while(token.hasMoreTokens())
{
%>
<p><FONT FACE="ARIAL" SIZE=6><%=token.nextToken()%>
<% } %>
</body>
</html>
T he server.jsp program obtains the string buffer returned by SecureServer.java
in the str1 variable, converts it into a string and breaks the string into tokens
using the pipe (| ) character as delimiter.T he tokens so obtained are displayed in
the browser using the output directive, <%=token.nextToken()%>.T he output
appears in Figure 10.23.
A similar client.jsp uses the SecureC lient.java’s startC lient() method to output
messages received by the client  to the browser window.We leave it to the reader
to modify the SecureC lient.java class from Figure 10.9 and replace its main()
method with the startC lient() method. C ode for client.jsp is given in Figure 10.24.
www.syngress.com
Figure 10.23 Output of server.jsp
Figure 10.22 Continued

Java Secure Sockets Layer • Chapter 10
447
Figure 10.24 Calling the SecureClient Class in client.jsp
<%@ page import="java.util.*" %>
<%@ page import="SecureClient" %>
<%@ page contentType="text/html; charset=ISO-8859-5" %>
<html>
<head>
<title>Socket Client Application</title>
</head>
<body bgcolor="white">
<jsp:useBean id="myClient" scope="application" class="SecureClient"/>
<h1><FONT FACE="ARIAL" SIZE=12>Client Application JSP page</FONT></h1>
<hr>
<% 
String str1 = myClient.startClient();
%>
<p><FONT FACE="ARIAL" SIZE=6><%=str1.toString()%>
</body>
</html>
T he output of client.jsp is shown in Figure 10.25. N ote that this is the mes-
sage that the client receives back from the server.
www.syngress.com
Figure 10.25 Output of client.jsp

448
Chapter 10 • Java Secure Sockets Layer
Summary
In this chapter we introduced the concept of a keystore containing the keys and
associated certiﬁcates that are used in secure communications over a network
using SSL.We also explained at length the structure of certiﬁcates and the role
they play in certifying information in a secure-communication environment.We
then discussed the keytool utility that can be used to create a keystore and
administer its keys and associated certiﬁcate chains.We explained the -import,
-selfcert and -identitydb commands as provided by the keytool utility to create 
certiﬁcates in the keystore.
T he rest of the chapter was devoted to JSSE and various classes in the
java.security, java.security.cert, javax.net.ssl and other JSSE packages that are used
to secure information from a keystore or add information to one.We began with
a discussion on how JSSE can be installed and conﬁgured, was followed by a dis-
cussion on using JSSE properties to obtain information about the keystore, such
as the number of aliases in the keystore, their associated certiﬁcate chains, the
keystore type and so on.We then showed how to conﬁgure a U R L handler for
communication using H T T PS by setting the java.protocol.handler.pkgs property.
T hereafter, we brieﬂy discussed the basic classes such as Socket, ServerSocket,
ServerSocketF actory, SocketF actory and the subclasses that are used for secure com-
munications, such as SSL ServerSocketF actory, SSL SocketF actory, SSL ServerSocket and
SSL Socket. In the remainder of the chapter we used examples and working code
listings to explain how these sockets and socket factories can be used to develop a
client-server application using SSL.We also included in the chapter a complete
description of how you can see the list of certiﬁcates being exchanged between a
client and server during a secure communication cycle, and how data is
encrypted at the transmitting end and decrypted at the receiving end. In essence,
this chapter provided a basic guide to secure communications using JSSE.
Solutions Fast Track
C onﬁguring JSSE
 T he JSSE can be conﬁgured by setting the SunJSSE provider and
conﬁguring the U R L handler for JSSE.
 T he keytool utility is used to create and manage keystore aliases and
their associated certiﬁcate chains, for example, the -genkey command can
www.syngress.com

Java Secure Sockets Layer • Chapter 10
449
be used to create a key entry in a keystore while the -import, -selfcert and
-identitydb commands can be used to generate or import certiﬁcates.
 T he java.security and java.security.cert packages provide various methods
such as getK ey(), getC ertiﬁcateC hain(), getP rovider(), getType() and so on that
can be used to retrieve information about a keystore.
U sing H T T PS U R L H andlers
 T he U R L handler for JSSE can be conﬁgured by setting the
java.protocol.handler.pkgs property.
 T he U R L handler for JSSE can be used to connect to a U R L using
H T T PS; and data can then be read over this secure connection using a
buffered input stream.
U sing SocketFactories
 Socket factory classes are used to create sockets on both the server
(ServerSocketF actory) and client (SocketF actory) sides.
 T he getC ipherSuites() method of an SSL ServerSocket object can be used to
read the cipher suites installed on a machine.
U sing Secure Server Sockets
 T he SSL ServerSocket class plays the same role in secure communications
as is played by the ServerSocket class in traditional programming: creating
secure server sockets.T he SSL ServerSocketF actory class provides the
createServerSocket() method to create server sockets.
 T he secure server socket can be used to read and/ or write data using
input and/ or output streams. H owever, the data being read or written
will remain secure.
U sing Secure C lient Sockets
 T he SSL SocketF actory class’ createSocket() method is used to create secure
client sockets.
www.syngress.com

450
Chapter 10 • Java Secure Sockets Layer
 T he SSL Socket class’ startH andshake() method begins the process of
exchanging certiﬁcates and establishing a connection with a server upon
veriﬁcation of the certiﬁcate information.
 Input and output streams can be used to read/ write data using a secure
socket.
 T he SSL Socket class’ close() method is used to close the socket that
automatically closes the connection with the server.
U sing JSSE Applications with W SDP
 W hile using W SDP, JSSE classes and properties can be used in servlets/
JSPs in exactly the same manner as they are used in a traditional java
program.
 A traditional java program that uses JSSE can be converted into a Java
Bean with minimal modiﬁcation by removing the main() method and
incorporating the code in a user-deﬁned method that returns values
retrieved using JSSE to the calling JSP page.
Q: W hat versions of the JDK  does JSSE 1.0.2 support?
A: It supports Java 2 SDK , Standard Edition, version 1.2.1 or later.T he JSSE API
can be implemented on either JDK  1.1.x or JavaT M  2 Platform, Standard
Edition.
Q: W hat version of SSL does JSSE support?
A: JSSE 1.0.2 supports SSL version 3.
Q: C an JSSE perform R SA encryption?
A: Yes, JSSE 1.0.2 performs R SA encryption
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.

Java Secure Sockets Layer • Chapter 10
451
Q: W hen I compile my JSSE program, I get the following error: Package
javax.net.ssl not found in import.W hat could be the possible reason?
A: If you install JSSE in accordance to the installation instructions in this
chapter, its JAR  ﬁles are automatically installed. H owever, if you are using
JSSE as a bundled extension with an application, you need to point your
C LASSPAT H  variable to the JSSE JAR  ﬁles. O therwise you’ll get the above
error.
Q: W hen I run my JSSE program, I get the following exception:
Exception in thread "main":
SSL implementation not available.
Do you know of any remedies?
A: T he following could be the possible reasons:
■
You may not have registered the SunJSSE provider. (See the section on
conﬁguring JSSE.)
■
T he keystore may be corrupted or invalid. (T he keytool may be used to
check for a valid keystore.)
www.syngress.com


Using JWSDP Tools
Solutions in this chapter:
■
JWSDP UDDI Registry
■
Tomcat
■
Ant
Chapter 11
453
 Summary
 Solutions Fast Track
 Frequently Asked Questions

454
Chapter 11 • Using JWSDP Tools
Introduction
Included in the JW SDP are a set of tools that can be used in the development or
deployment of Web services.T hese tools can be employed to support a develop-
ment server, and can even be used for some production releases.T he tools include
a U DDI registry (Java W SDP registry server), a servlet/ JSP container (Tomcat),
and a build tool (Ant).
T he Java W SDP registry server is least likely to be used in production envi-
ronments— at least in its current form. It has limitations in the scope of U DDI
supported, its capability to provide highly available services, and in its perfor-
mance.T hese will likely be addressed in future releases, so it will be interesting to
see if it eventually evolves into a production-level tool.
Tomcat is a much more capable tool. Behind IBM ’s WebSphere and BEA’s
WebLogic, it represents one of the most accomplished and up-to-date servlet
engines. It may even be suitable for small production environments.T his depends
on your overall willingness to assume risk, of course.Tomcat is generally sup-
ported by open-source volunteers, and does not provide high-availability features.
If used in development,Ant is the tool you would likely continue to use as
you moved toward production.As a build tool, the issues of high availability are
moot.Ant is as capable a tool for Web services as any other make utility— perhaps
even more so. Keep in mind that it’s a very different tool than standard make util-
ities, and does take some getting used to.
JWSDP UDDI Registry
T he U niversal Description Discovery and Integration Protocol (U DDI) is an
infrastructure that allows Web services to register, or become publicly known by, a
registry.T he registry used by Java W SDP is known as the U DDI R egistry. O nce
these Web services are known to the registry, they are then made available to any
client request.T he U DDI R egistry contents are X M L-based and are accessed in a
directory tree-style.
In order to deploy your Web services, you will need to set up the U DDI
R egistry, enabling you to add your Web services to the registry.To begin, down-
load the Java Web Services Developer Pack, containing the R egistry Server,
from the following U R L: http:/ / java.sun.com/ webservices/ downloads/
webservicespack.html.T his link will prompt you to download the following 
executable for M icrosoft W indows: jwsdp-1_0-ea2-win.exe. For U nix or Linux
users, you will download this executable: jwsdp-1_0-ea2-unix.sh.
www.syngress.com

www.syngress.com
Installing
Prior to installing the JW SDP, you must have the Java 2 SDK  or R untime
Environment of version 1.3.1 or later already installed on your computer.
M icrosoft W indows Installation Instructions
JW SDP is supported on M icrosoft W indows 2000 and X P only. M icrosoft
W indows 95, 98, M E, and N T  4.0 are unsupported. Double-click the self-
extracting executable jwsdp-1_0-ea2-win.exe.
U nix, Linux Installation Instructions
JW SDP is supported on Solaris and Linux, but is not supported on M ac O S X
and other U nix platforms. Execute the following command against the self-
installing executable % / bin/ sh jwsdp-1_0-ea2-Unix.sh.
Both these methods will bring up the InstallShield W izard shown in Figure
11.1 to assist in installing JW SDP to your computer. O nce you have reached this
screen, perform the following steps:
1.
From the InstallShield W izard screen (Figure 11.1) click Next.
2.
T his will bring up the Evaluation Agreement screen shown in 
Figure 11.2.You must agree with it to proceed, so check Approve,
then click Next.
3.
T he InstallShield W izard will automatically detect the JDK 1.3.1 installa-
tion on your computer (Figure 11.3). C lick Next.
Using JWSDP Tools • Chapter 11
455
UDDI Registry
The UDDI Registry Server is automatically installed along with Tomcat
and some additional administrative tools to assist you in deploying your
Web services. 
Developing & Deploying…

456
Chapter 11 • Using JWSDP Tools
www.syngress.com
Figure 11.1 Welcome Screen of the InstallShield Wizard
Figure 11.2 Evaluation Agreement Screen

Using JWSDP Tools • Chapter 11
457
4.
Fill in a username and password to administer Tomcat, as shown in
Figure 11.4. C lick Next.
5.
You now must specify which directory to install in, as shown in 
Figure 11.5. U se the default directory setting and click Next.
www.syngress.com
Figure 11.3 JDK Version Selection Screen
Figure 11.4 Creation of Tomcat Administrative User Screen

458
Chapter 11 • Using JWSDP Tools
NOTE
The rest of this chapter will assume you have installed in c:\jwsdp-1_0-ea2
(Windows) or /home/myuserid/jwsdp-1_0-ea2 (Linux/Unix). If you install
into different directories, you will have to adjust the paths given in this
chapter accordingly.
6.
T his will bring you to the C onﬁrmation screen prior to installation
(Figure 11.6). C lick Next.
www.syngress.com
Figure 11.5 Destination Directory Screen
Figure 11.6 Location Conﬁrmation and Size Screen

Using JWSDP Tools • Chapter 11
459
7.
N ow the actual installation begins.You should see the screen displayed in
Figure 11.7, which shows the progress of the install.
8.
O nce the install has completed, you will see the screen (shown in Figure
11.8) telling you that the install has completed successfully. C lick Next.
9.
You will now be brought to the ﬁnal install screen, shown in Figure 11.9.
Select Yes, restart my system and click Finish.
www.syngress.com
Figure 11.7 Installing JWDP Screen
Figure 11.8 Successful Installation Screen

460
Chapter 11 • Using JWSDP Tools
Conﬁguring
You need to add the / bin directory of the JW SDP to the PAT H  variable in your
environment.T his will then  allow you to run any of the JW SDP executables
from any directory. For M icrosoft W indows users, modify your PAT H  variable
through the Control Panel |  System |  Advanced |  Environmental
Variables section. O nce this section is accessed, modify the existing PAT H  set-
ting by appending the following directory path: c:\ jwsdp-1_0-ea2\ bin. C heck
your M icrosoft W indows manual on instructions for conﬁguring environmental
variables for your version of W indows. For U nix and Linux users, modify your
PAT H  variable by appending the following directory to the existing PAT H :
/ home/ myuserid/ jwsdp-1_0-ea2/ bin.
Activating
O nce the JW SDP is installed and conﬁgured, the JAX R  R egistry Server can be
easily launched in W indows by executing the startup script for the Tomcat server,
which is located under the / bin directory. O r, it can be launched from the Start
|  Programs |  Java Web Services Developer Pack |  Startup Tomcat
menu as shown in Figure 11.10. U nix and Linux users execute the startup.sh
script, whereas the M icrosoft W indows users execute the startup.bat batch ﬁle.
Likewise, the Server can be shut down in the same manner using the shutdown
xindice script for both platforms.
www.syngress.com
Figure 11.9 Restart Computer Screen

Using JWSDP Tools • Chapter 11
461
Limitations 
JW SDP does not support the following versions of M icrosoft W indows:W indows
95, 98, M E, and N T  4.0. In addition, JW SDP does not support the following
versions of U nix: M ac O S X  and other U nix platforms. Please see the R EADM E
text of the JW SDP R egistry for the latest limitations if you are using a version
later than EA2.
Also, the following messages are not yet supported within the R egistry
Server:
■
add_ publisherA ssertions
■
delete_ publisherA ssertions
■
get_ assertionStatusR eport
■
get_ publisherA ssertions
■
ﬁnd_ relatedB usiness
Likewise, the uploadR egisters argument is not supported within the save_ business
and save_ tM odel messages.
www.syngress.com
Figure 11.10 Activation of the Tomcat Server

462
Chapter 11 • Using JWSDP Tools
Limitations exist regarding the ﬁnd_ * messages.T he following arguments are
not supported when attempting a search:
■
ﬁndQ ualiﬁers
■
identiﬁerB ag
■
categoryB ag
■
tM odelB ag
■
discoveryU R L s
After creating an organization, you can search for the organization name;
however, the query of the R egistry is case-sensitive. In addition, when searching
for organization names, the percent sign (% ), indicating the string can occur any-
where in the name, does not work.You cannot use multiple <name> values in
searches, as this is not supported.
N o connection pooling or indexing are available for performance optimiza-
tions in this release.
Selecting as the Registry
T he R egistry Server has a browser-based tool used to administer the server. Prior
to activating the R egistry Browser, make sure Tomcat is running. See the Tomcat
section in this chapter for instructions on starting your Tomcat server.You can
activate the R egistry Browser by one of two methods.T he ﬁrst is to execute the
jaxr-browser.bat (or jaxr-browser.sh) program at a DO S prompt.T his program is
located under $JW SDP_H O M E\ bin directory.T he second method is to launch
the R egistry Browser from the Start |  Programs |  Java Web Services
Developer Pack |  JAXR Registry Browser menu.T he dialog box shown 
in Figure 11.11 will appear.
Select a registry using the dialog box drop-down list.You will be able to
access the last registry in the list, provided that Tomcat is currently running.T he
last registry in the list provides U DDI R egistry samples. If Tomcat is running, you
will be able to access these samples from the drop-down list using this U R L:
http:/ / localhost:8080/ registry-server/ R egistryServerServlet. Several other reg-
istries are listed in the drop-down list as well, which Sun M icrosystems makes
available as test registries.Administration of any R egistry Server requires some
level of authentication. If you are interested in adding Web services to these reg-
istries, you must go to one (or both) of these sites and become a registered user
with a username and password: http:/ / uddi.microsoft.com or http:/ / www-3.ibm
.com/ services. Figure 11.12 shows a listing of the test registries.
www.syngress.com

Using JWSDP Tools • Chapter 11
463
U sing this browser menu, you can select the Submissions tab (Figure 11.13)
to add, modify, edit, or delete Web services to within your R egistry Server.
C lients attempting to connect to your Web services will query the R egistry
Server to ﬁnd the names of registered objects.T he properties associated with each
Web service are collectively known as the organization.After you enter the spe-
ciﬁc information pertaining to a particular organization, click Add service to
activate the next menu which allows you to add your organization name to the
list of registered objects.T his list of registered objects is collectively known as
Services.
www.syngress.com
Figure 11.11 The JAXR (UDDI) Registry Browser
Figure 11.12 Selection of Registry Locations from the Drop-down List

464
Chapter 11 • Using JWSDP Tools
N ext is an overview of the ﬁeld names and their deﬁnitions.
O rganization
T here are three properties available in the registry that provide identiﬁcation for
your Web services object.T hey include the following: name, ID, and description.
■
Name Any name you would like to associate with this object
■
Id T his becomes the unique key the registry uses to ﬁnd your object;
this is internally generated by the server itself
■
Description H ere you can provide any text describing your object
Primary C ontact Information
Each Web Service object registered within the registry needs to be administered
by an authorized user.T he R egistry Browser provides properties to identify and
associate the authorized user with the organization.T he three pieces of contact
information that need to be supplied are:
■
Name T he name of the user authorized to use this registry
■
Phone T he phone number of the authorized user
■
Email T he e-mail address of the authorized user
www.syngress.com
Figure 11.13 The Submissions Input Area in the Registry Browser

Using JWSDP Tools • Chapter 11
465
C lassiﬁcations
If you want to group your organization with other organizations under the same
general heading, you can use what is known as a classiﬁcation. M ultiple organiza-
tions that have some relationship to each other are collected under a classiﬁcation
name.To add your organization to a classiﬁcation, select the classiﬁcation you want
to add your organization to and click Add as shown in Figure 11.14.T his is only
possible if classiﬁcations are already available within your R egistry Server.W hen
you ﬁrst install your R egistry Server, no classiﬁcations are listed. If you wish to add
a new classiﬁcation, you can do so within the Add Service textboxes.Adding your
organization to a classiﬁcation group is an optional feature.
T he next step is to add your organization to the registry in order to make it
available to client requests.T his is known as adding Service objects to the registry.
To begin the process, click Add Service.A new set of textboxes appear, as
shown in Figure 11.15.T he following are the ﬁeld names and their deﬁnitions:
■
Name T he Service object name 
■
Id T he unique key that identiﬁes the Service object; it’s generated by
the R egistry Server
■
Description Any text describing the Service object
www.syngress.com
Figure 11.14 Adding an Organization to a Classiﬁcation Grouping

466
Chapter 11 • Using JWSDP Tools
O nce you identify the Service object’s name and description, click Edit
Bindings to have the R egistry Server bind your object within its registry.A
small dialog box appears, as shown in Figure 11.16. C lick Add Binding.
Each Service Binding must be made publicly available to clients through a
U R I.A description can also be provided.T his information is entered in the
appropriate textboxes of the dialog box shown in Figure 11.17.
W hen ﬁnished, click Done.You will be prompted for authorization informa-
tion. Enter your username and password, then click OK.You have successfully
added a Web Service object to your registry.You can now return to the Browse
tab (see Figure 11.18) to see your newly created object. From this Browse tab,
www.syngress.com
Figure 11.15 Adding Your Web Service to the Registry
Figure 11.16 Adding/Editing Service Bindings Listed within the Registry
Figure 11.17 Adding/Removing a Service Binding within the Registry

Using JWSDP Tools • Chapter 11
467
you can query for Web services based on organization name or classiﬁcation
name.To do so, enter the name to search for in the textbox, then click Search.
Tomcat
Tomcat is an open-source Web server freely available through the Jakarta Project
(http:/ / jakarta.apache.org).T he Tomcat Web server can serve H T M L pages, Java
Server Pages, and Java Servlets.T his is made possible by the inclusion of a
servlet/ JSP container (or engine) within the Web server itself.
Installing
Bundled within the JW SDP is a fully-working Tomcat Web server with the
servlet/ JSP container. By following the instructions for installing the JW SDP
(under Section JWSDP UDDI Registry |  Installing),Tomcat is automati-
cally installed to your computer. N o additional installation is required.
W indows
See the installation instructions for M icrosoft W indows users under the section
entitled JWSDP UDDI Registry |  Installing.
Linux
Installation instructions for U nix and Linux users can be found under the section
entitled JWSDP UDDI Registry |  Installing.
www.syngress.com
Figure 11.18 Browsing/Searching Web Services within the Registry

468
Chapter 11 • Using JWSDP Tools
Environmental Variables
T he following environmental variables need to be set up on your computer:
JAVA _ H O M E , C A T A L IN A _ H O M E . C reate a JAVA _ H O M E environmental
variable to point to the location of your JDK  installation. M ake sure the
$JAVA _ H O M E / bin path is added to your PA T H environmental variable,
so you can run Java commands at the command line. Finally, create a
C A T A L IN A _ H O M E environmental variable to point to the location of 
your Tomcat installation. Since JW SDP bundles Tomcat within it, this variable
will point to a location similar to the following: c:\jwsdp-1_ 0.
Any modiﬁcations required to the C L A SSPA T H environmental variable are
done for you during the installation process. H owever, if you are setting your
variables up manually, add $JAVA _ H O M E \lib\tools.jar to your C L A SSPA T H envi-
ronmental variable.
Conﬁguring
All conﬁgurations required for the running of Tomcat are automatically set
during the installation process. N o additional conﬁgurations are necessary.
Server.xml
T he server.xml ﬁle is the main ﬁle that Tomcat provides to allow server conﬁgu-
rations.T hese conﬁgurations can modify the behavior of the servlet/ JSP con-
tainer.T he server.xml ﬁle is located under the $JW SDP_H O M E\ conf directory.
T he structure of the ﬁle is nested tags, beginning with the top-level parent tag of
Server representing the entire JVM . M ultiple service instances can be contained
within the Server tag.A Service instance is denoted with the nested tag called
Service.A service represents a group of connectors associated with an engine.
W ithin a service tag,Web applications and other services are made available to
clients on speciﬁed port numbers. Such services are known as connectors and are
denoted by a tag of the same name.T hese connectors act as interfaces between
external clients and the services themselves, providing the ability to receive and
respond to those client requests. It is within these connector tags that you can set
up various port numbers to listen for particular client requests and subsequently
invoke the appropriate Java class at runtime.
An example of a connector within a service tag shows how you can enable
SSL to run on port 8443.T he following entry deﬁnes the connector class that
Tomcat provides to support an SSL connection.Various details are conﬁgured
www.syngress.com

Using JWSDP Tools • Chapter 11
469
within this tag, including port number, the minimum and maximum number of
processors, the scheme, and the toggling of the secure value.
<!-- Deﬁne an SSL HTTP/1.1 Connector on port 8443 -->
<Connector className="org.apache.catalina.connector.http.HttpConnector"
port="8443" minProcessors="5" maxProcessors="75" scheme="https"
secure="true">
</Connector>
T he Engine or C ontainer tag speciﬁes various listeners that can be conﬁg-
ured to handle numerous client requests. For example, the standard engine for
handling H T T P requests runs on port 8080 under the engine name of “local-
host.” W ithin the conﬁguration of this engine, a host tag is conﬁgured for the
webapps directory used as the document root directory.
<!-- Default Virtual Host -->
<Host    name="localhost" appBase="Webapps" debug="0" unpackWARs="false">
</Host>
T he webapps Directory and WAR  ﬁles
T he default document root directory for the Tomcat Web server is the webapps
directory.T he Web server serves up H T M L pages from this directory, therefore
any new Web applications can easily be added to the server thru the creation of
new subdirectories under webapps. Such subdirectories are known as context paths
to your application.Additionally, you can invoke Java classes from your Web appli-
cation which require the creation of another directory called W EB-IN F and a
subdirectory of classes.
W eb A R chive (WAR ) ﬁles are ﬁles that contain a packed version of an entire
tree directory structure and all nested ﬁle types contained within the tree. Such
ﬁle types can include H T M L, JSP, C LASS, and C SS.WAR  ﬁles are used for ease
of deployment.
Structure of a webapps D irectory
In order to create a correctly-formatted WAR  ﬁle, a particular structure is
required.You will need to “pack up” or arrange your WAR  ﬁle in the same order
that Tomcat will later use to execute that WAR  ﬁle.T herefore, starting with your
document root directory (also known as context path), you will have the structure
shown in Figure 11.19 when constructing your WAR  ﬁle.
www.syngress.com

470
Chapter 11 • Using JWSDP Tools
T he complete syntax and semantics for the deployment descriptor is deﬁned
in C hapter 13 of the Servlet API Speciﬁcation, version 2.2. O ver time, it is
expected that development tools will be provided that create and edit the deploy-
ment descriptor for you. In the meantime, to provide a starting point, a basic
web.xml ﬁle is provided.T his ﬁle includes comments that describe the purpose of
each included element.
W here to P ut W A R  F iles
In order for Tomcat to unpack a WAR  ﬁle, it must be placed within the webapps
directory.Tomcat automatically unpacks the WAR  ﬁle upon startup making the
application available for client requests.
W hen to U se E ach
If you require your application to be deployed on multiple servers, it is recom-
mended you pack up your tree directory within a WAR  ﬁle. It will be portable
and easily deployable to other Web servers. H owever, if your application resides
on the same server and same ﬂavor of Web server (for instance,Tomcat), then use
the server.xml conﬁguration.
www.syngress.com
Figure 11.19 Structure When Constructing Your WAR File
webapps
myrootdocdir
WEB-INF
*.html
*.jsp
*.css (if any stylesheets are used)
classes
lib
web.xml
*.class
*.jar

Using JWSDP Tools • Chapter 11
471
T he web.xml C onﬁguration F ile
T he web.xml ﬁle is located under the webapps\ mydocumentrootdirectory\
W EB-IN F\ web.xml (for Linux and U nix users this is the webapps/
mydocumentrootdirectory/ W EB-IN F/ web.xml).T his ﬁle is used to assist in 
the installation of a WAR  ﬁle. It contains a deployment descriptor that deﬁnes 
all aspects of your application that Tomcat needs to know for executing purposes.
Such details described within this ﬁle include all servlet names, servlet mappings,
servlet session conﬁgurations, and general application information such as the
application name.
Activating
Tomcat can be started manually or automatically under either platform.
Instructions for setting up and activating the Tomcat server are described next.
Starting Tomcat under W indows N T  M anually
To start the Tomcat server, open a DO S-prompt and change to the following
directory: $JW SDP_H O M E\ bin. Execute the following batch ﬁle: startup.bat.
Starting Tomcat under W indows N T  as a Service
To have Tomcat start up as an N T  service, open the Control Panel |  Services
menu.T hen, add $JWSDP_HOME\ bin\ startup.bat as a service. Do the same
for the shutdown.
Starting Tomcat under Linux M anually
To start the Tomcat server at the command line, change to the following direc-
tory: $JWSDP_HOME/ bin.T hen execute the following batch ﬁle: startup.sh
www.syngress.com
WAR File Redeployment
If you decide to modify the WAR ﬁle and redeploy to Tomcat, make sure
you delete the old WAR ﬁle and the old unpacked directory, then stop
and restart Tomcat.
Debugging…

472
Chapter 11 • Using JWSDP Tools
Starting Tomcat under Linux at Startup T ime
T he Tomcat server can automatically start up on Linux platforms by placing the
startup.sh script within the / etc/ rcN / init directory which is owned by root.
Relationship to Apache Servers
Apache servers can be used in conjunction with Tomcat servers for delegating
services and load-balancing needs.You can conﬁgure an Apache Web server, used
to handle static content of H T M L, and images to delegate all JSP and Servlet
requests to Tomcat that contain a servlet/ JSP container. By establishing multiple
Tomcat servers between the Apache server, an application can perform load bal-
ancing of client requests among the multiple resources available.
Acting Standalone
Tomcat contains an H T T P Web server along with a servlet/ JSP container.
Although the Web server can serve up H T M L and other static content, it’s
lacking in speed. H owever, the setup of a Tomcat server is relatively simple.
Proxied behind Apache Servers
Tomcat server can be proxied behind multiple Apache servers for scalability, secu-
rity and performance reasons.T he Apache 1.3 server provides the ability to proxy
client requests through to the Tomcat 4 servers.T his is useful in masking the
hostname and IP address of the actual server that contains the content. Likewise,
SSL can be conﬁgured to provide an encrypted session between the proxy server
and Tomcat.
Ant
Ant is an open-source build tool developed by Jakarta (http:/ / jakarta.apache.org)
that uses X M L-based ﬁles to conﬁgure target directories.W ritten in Java, it uses
classes for the actual compilation and execution of a variety of build-related 
commands.
Structure of an Ant Input File
T he structure of an Ant input ﬁle contains a project deﬁnition, target directories,
and any tasks that need to be performed during the build.
www.syngress.com

Using JWSDP Tools • Chapter 11
473
Projects
Each X M L-based Ant build ﬁle contains one project.
P roject D eﬁnition
Projects have three attributes: name, default, and basedir.
R equired E lements
At a minimum, you must specify a default directory that will be used in cases
where no target directory is provided.
O ptional E lements
T he attributes of name and basedir are optional.
D eﬁning P roject P roperties
A project can contain a set of properties which can be used as a source in path-
names or conﬁguration ﬁles.A property is set up as a name/ value pair and can be
sourced within the Ant ﬁle using the dollar sign and opening and closing curly
braces with the name of the property contained between the braces. For instance,
${ﬁle.separator} will evaluate out to a “\ ” or “/ ” depending upon the platform
where the build ﬁle is run.
Targets
A project can be set up to contain one or more targets which have ﬁve attributes:
name, depends, if, unless, and description. O nly the name attribute is required.
D ependencies between Tasks
Each target deﬁnes one or more tasks you can set to be executed. U pon the
startup of Ant, you can specify which targets you wish executed.
O rdering of D ependencies
Targets can be dependent upon other targets. For instance, if you plan on dis-
tributing your code in a WAR  ﬁle after compilation, then the construction of
that distribution ﬁle is dependent upon the ﬁrst target of compilation.T his
dependency is set up within the build ﬁle using the attribute called depends.
www.syngress.com

474
Chapter 11 • Using JWSDP Tools
Specifying Target L ocations
W hen specifying target locations, it is possible to check for the setting of a prop-
erty value prior to execution of the target.T his provides you with more control
over the build in regards to external variables.T his conditional check is done
with the use of the if attribute within the target declaration tag (for instance,
<target name=“ my-build-example” if=“ property-A -is-set” / >). Execution of the target
is guaranteed in the absence of an if attribute.
Tasks
Tasks are deﬁned within the target tags and direct some piece of code to execute.
T he type of code could be of a variety of languages. For example, the task could
be the DO S command of echo, done to display a message to the user screen, or
it could be the execution of a Java class using the java command.
Structure of a Task E ntry
T he structure of the task entry begins with an opening tag followed by the 
name of the task (which really could be a command) immediately followed 
by an attribute name which will equal the value of that attribute. For example,
<echo message=“ -- R unning C L I client to process request: ${request} --” / >
Ant provides many built-in and optional tasks described next.
B uilt-in Tasks
Some of the built-in tasks provided by Ant that might be of interest to you
include javac, jar, and war.T he javac task is used to compile Java source code or
*.java ﬁles.T he jar and war tasks are available to pack up ﬁles in either a JAR  or
WAR  ﬁle.
O ptional Tasks
M any other tasks are provided by Ant as optional tasks to be used with other
technologies. Please consult the list of optional tasks located at the following
U R L: http:/ / jakarta.apache.org/ ant/ manual/ index.html.
D eﬁning Tasks
Ant also provides the capability for you to write your own tasks. See the section
entitled “Developing with Ant” for more information on this at the following
U R L: http:/ / jakarta.apache.org/ ant/ manual/ index.html.
www.syngress.com

Using JWSDP Tools • Chapter 11
475
Invoking ANT
T he following section describes how to invoke the Ant script from the com-
mand-line.T here are a variety of options that can be added as additional argu-
ments to the invocation of the program.
Invoking from the C ommand Line
O nce you are ready to compile, all you need to do is invoke the ant command at
the command line from the project source directory. M ake sure the following
ﬁles are added to your C LASSPAT H : ant.jar, crimson.jar, and jaxp.jar.W hen you
execute this command and do not use the -buildﬁle option,Ant will look in the
current directory for a build.xml ﬁle. H ere is a summary of the usage statement
along with all available options:
ant [options] [target [target2 [target3] ...]]
Options:
-help                  print this message
-projecthelp           print project help information
-version               print the version information and exit
-quiet                 be extra quiet
-verbose               be extra verbose
-debug                 print debugging information
-emacs                 produce logging information without adornments
-logﬁle ﬁle
use given ﬁle for log output
-logger classname
the class that is to perform logging
-listener classname
add an instance of class as a project listener
-buildﬁle ﬁle
use speciﬁed buildﬁle
-ﬁnd ﬁle
search for buildﬁle towards the root of the 
ﬁlesystem and use the ﬁrst one found
-Dproperty=value       set property to value
Specifying or D efaulting a B uild F ile
By default,Ant will look for a build.xml ﬁle in the current directory. If no ﬁle is
found and the -ﬁnd option is turned on,Ant will continue looking up the direc-
tory tree until it reaches the root of your ﬁlesystem. If you would like to override
the default behavior, specify a buildﬁle using the -buildﬁle ﬁle option where ﬁle is
the name of your build ﬁle.
www.syngress.com

476
Chapter 11 • Using JWSDP Tools
Invoking Speciﬁc Targets
Ant provides the capability to invoke several targets within a project. H owever, if
no targets are speciﬁed, then Ant will default to use the target deﬁned within the
default attribute of the <project> tag.
Setting P roperties
If you would like to override the properties that are sourced in from the
build.properties ﬁle, simply use the -D property=value as an option to the ant
command.
Integrating with IDEs
T here are several open-source projects available that provide the ability to incor-
porate Ant inside of an IDE. If you are interested in exploring this further, go to
the following Web site: http:/ / jakarta.apache.org/ ant/ manual/ index.html.
An Ant Example
We will now demonstrate an example of a simple Ant ﬁle that compiles a servlet,
builds a WAR , and deploys that WAR  ﬁle to the Tomcat container.
In order to run this example successfully, you will ﬁrst need to create a ﬁle
called build.properties which contains variables to be sourced into the build.xml ﬁle.
H ere is a sample:
appname=samplebuildﬁle
wars.dir=../../warﬁles
appname.home=../newhome
For this example, in order to create a WAR  ﬁle, you need to generate a ﬁle
called web.xml which contains information about your servlet code. H ere is a
sample:
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE web-app
PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.2//EN"
"http://java.sun.com/j2ee/dtds/web-app_2_2.dtd">
<web-app>
<display-name>Sample Build File</display-name>
www.syngress.com

Using JWSDP Tools • Chapter 11
477
<description>no description</description>
<servlet>
<servlet-name>HelloWorldServlet</servlet-name>
<display-name>HelloWorldServlet</display-name>
<description>no description</description>
<servlet-class>HelloWorldServlet</servlet-class>
</servlet>
<servlet-mapping>
<servlet-name>HelloWorldServlet</servlet-name>
<url-pattern>/servlet/HelloWorldServlet</url-pattern>
</servlet-mapping>
</web-app> 
Finally, you will need to create your build.xml ﬁle which is what Ant will ini-
tially look to ﬁnd when invoked.T he following shows how your build.xml ﬁle
should look:
<project name="samplebuildﬁle" default="unwar" basedir=".">
<!-- Lookup all of the webapps currently conﬁgured on Tomcat -->
<property ﬁle="../../build.properties"/>          <!-- For all webapps -->
<!-- Classpath:  need to have servlet.jar to compile a servlet -->
<path id="samples.classpath">
<ﬁleset dir="../../common/lib" includes="servlet.jar"/>
</path>
<target name="compile">
<echo message="Compiling the servlet source code..."/>
<javac classpathref="samples.classpath"
srcdir="${basedir}/WEB-INF/src"
destdir="${basedir}/WEB-INF/classes">        
</javac>
</target>
<!-- Create a WAR ﬁle -->
<target name="war" 
description="Creating the WAR ﬁle" 
www.syngress.com

478
Chapter 11 • Using JWSDP Tools
if="wars.dir"
depends="compile">
<echo message="Creating WAR ﬁle..."/>
<mkdir dir="${wars.dir}" />
<war warﬁle="${wars.dir}/${appname}.war" webxml="WEB-INF/web.xml">
<zipﬁleset dir="."/>   
</war>
</target>
<!-- Deploy WAR to Tomcat container -->
<target name="unwar" depends="war">
<unwar src="${wars.dir}/${appname}.war" dest="${appname.home}" />
<echo message="Deploying WAR ﬁle..."/>
</target>
</project>
R unning the Sample
To run the sample, turn the verbose option on to see messages to the console:
$ant  -v
www.syngress.com

Using JWSDP Tools • Chapter 11
479
Summary
After installing the JW SDP from the self-extracting executable, you will have the
following tools available on your computer: the U DDI R egistry Server, the
Tomcat Web server, samples, and services. Installation instructs are carefully
detailed in this chapter for ease of use.T he JW SDP contains several tools that
assist you in deploying your Web services.An integral piece to deploying Web
services is registering your Web services within a registry. JW SDP provides a
U DDI R egistry Server as well as an easy-to-use browser tool for administration
of the server.W ithin this registry browser, you can set up your Web services by
identifying them as organizations.T hose organizations can be stand-alone or asso-
ciated with a classiﬁcation.T hen you can easily add your service to the registry
with the click of a button. Browsing your available Web services is made easy
within the Browse tab of the tool. In addition to the registry server, a full version
of Tomcat is provided, enabling you to deploy your WAR  ﬁles to this server
which can execute them.Tomcat also provides a fully-functioning Web server to
serve H T M L pages, and a servlet/ JSP container for the handling of servlet or Java
Server Pages requests. Finally, the pack includes several Ant build ﬁle samples
which you can use to easily compile and build your WAR  or JAR  ﬁles for distri-
bution of your Web applications to the Tomcat Web server or other ﬂavors of
Web servers.Ant is easy to use and provides many capabilities in the creation of
build ﬁles for your Web applications. M any options are available to be added as
arguments to the command-line invocation of Ant in order to provide extra
functionality.
Solutions Fast Track
T he JW SDP U DDI R egistry
 T he U DDI R egistry requires the startup of the Tomcat server ﬁrst.
 T he U DDI R egistry can be administered through the command line or
through a browser-based tool.
 T here are sample registries available within the R egistry Browser for
more practice.
www.syngress.com

480
Chapter 11 • Using JWSDP Tools
Tomcat
 T he Tomcat Server can be started or stopped through the command line
or from a menu.
 T he Tomcat Server is relatively easy to install and includes a quick
environmental setup.
 Tomcat enables the deployment and redeployment of WAR  ﬁles.
 Tomcat executes WAR  ﬁles by unpacking them into the Tomcat Web
applications structure.
Ant
 Ant uses X M L-based ﬁles to conﬁgure target directories.W ritten in Java,
it uses classes for the actual compilation and execution of a variety of
build-related commands.
 Ant enables multiple targets to be built within one project or build ﬁle.
 T he Ant build tool provides many useful built-in tasks offering a
multitude of options  within the build ﬁle.
www.syngress.com

Using JWSDP Tools • Chapter 11
481
Q: W hat version of Ant should I be using?
A: T he JW SDP recommends you use Ant 1.4 or later.
Q: W hy isn’t there a separate startup command for the U DDI R egistry Server?
A: T he U DDI R egistry Server is actually a special servlet that is run as a Web
application within Tomcat.T hus, you must start Tomcat in order to use the
registry.
Q: C an Tomcat be used in a production environment?
A: N o. Since Tomcat is open-source, there is no support provided for the
product in the traditional vendor support manner. H owever, it could be used
in a small production environment so long as the risk is assumed.
Q: I’m new to servlets and Java Server Pages.W here can I go to learn more
about them?
A: Go to the Sun M icrosystems Trail M aps Web site at http:/ / java.sun.com/
docs/ books/ tutorial.
Q: H ow does Ant know how to compile my source code just by using the
<javac></ javac> tag?
A: Ant is actually written in Java so all the tags you use actually invoke 
Java classes that take in your value between the tags as arguments.You 
can learn more about how Ant works at the Jakarta-Ant Web site at
http:/ / jakarta.apache.org/ ant/ index.html.
www.syngress.com
Frequently Asked Questions
The following Frequently Asked Questions, answered by the authors of this book,
are designed to both measure your understanding of the concepts presented in 
this chapter and to assist you with real-life implementation of these concepts. To
have your questions about this chapter answered by the author, browse to
www.syngress.com/solutions and click on the “Ask the Author” form.


483
Index
$ (JST L literal notation), 163
A
accept( ) method, 426, 429
Actors, 221
addA ttribute( ) method, 209, 210
addB ody( ) method, 220
addC hildC oncepts( ) method, 342
addC hildE lement( ) method, 209, 211
addC lassifications( ) method, 342
addH eader( ) method, 220
AdditionInX M L servlet, 103–105
A ddproperty.java class, 417
addTextN ode( ) method, 212, 214
AELfred parser. See SAX  (Simple API for
X M L)
alert and notification systems, 256–257
aliases, 407
importing certificates and, 410
key generation and, 408
listing of keystore, 412
aliases( ) method, 412
Ant build tool, 7, 8, 63, 454, 472–478
Ant input file structure, 472–474
example Ant file, 476–478
invoking Ant scripts, 475–476
Apache Jakarta, 7
Ant build tool. See Ant build tool
Tomcat. SeeTomcat
Apache servers,Tomcat and, 472
application classes, JAX -R PC  support of,
310–311
A pplication scope, SPEL, 162
arrays, JAX -R PC  support of, 308, 309–310
asynchronous messaging, SO AP and, 254–299
creating SO AP messages, 266, 267
delayed response messaging, 257–258
e-mail messaging vs., 256
example of, 255–256
JAX M  Provider connections and, 263–266
message routing, 255–256, 260–263
one-way messaging, 256–257
Profiles and, 269–270
recording of message state, 258–259
sending messages with P roviderC onnection,
267–269
SO AP EJB implementation for, 270, 275–277
SO AP server servlet for, 270–274, 277–298
See also synchronous message routing, SO AP
and
A ttachmentPart objects, 228
attachments, message, 204, 208, 215–217
adding to SO AP messages, 228–230
InputStream class and, 230
JavaBeans Activation Framework (JAF) and,
229
SO AP M essages with Attachments and, 204,
208, 214
A ttr DO M  interface, 59
attributes
setting DO M  parser, 67–69
SO APElement methods for, 210
X M L, 59
Attributes objects, SAX  and, 21
axes, node, 129–130
B
<binding> element,W SDL document, 367,
371–372
Body elements, SO AP message, 205, 207
adding elements to, 226–227
SO A P B ody methods for, 222
SO A P F ault methods for, 222–223
boolean data type, 307, 308
BPSS. See Business Process Specification
Schema (BPSS)
B ufferedR eader class, 426
bundle action, JST L tags for, 186
business entity, U DDI Business R egistry, 338
business information objects, ebX M L, 341
Business Process Analysis Worksheet, ebX M L,
341
Business Process Editors, ebX M L, 341
Business Process Specification Schema (BPSS),
ebX M L, 341
business service, U DDI Business R egistry, 338
business-to-business e-commerce
facilitation of by ebX M L, 339–342
facilitation of by U DDI, 337
businesses
classification by geographical location, 336
C lassificationScheme interface for classification
of, 343–344
N AIC S registry categories for, 335, 343
representation of in registry by O rganiz ation
interface, 343–344

484
Index
storage of information on in Web registries,
334–336, 343–344
U DDI Business R egistry for, 337, 338–339
updating information on in registry records,
381–386
See also organizations
B usinessL ifeC ycleM anager interface, 357–358,
373
B usinessQ ueryM anager interface, 353–364
byte data type, 307, 308
C
cacerts file, installation of, 405, 433
callbacks, 15
characters callbacks, 21, 25, 45
C ontentH andler interface and, 19, 44–45
D efaultH andler interface and, 19
document callbacks, 19–20
element callbacks, 20–21, 40–41
error processing, 45–46
example event handler and callbacks, 22–26
ignorableW hitespace( ) callback, 44–45
namespaces and, 40–41
prefix mapping callbacks, 41
processingInstruction( ) callback, 45
skippedE ntities( ) callback, 45
C atalog of C ommon Business Processes,
ebX M L, 341
categories, business/ service registry
C lassificationScheme interface for, 342–343
N AIC S, 335, 343
Web service register queries based on,
357–363
c:choose action, JST L core tag library, 173
C DATA characters, 47
C DATA nodes, 57, 58, 67–68
C ertificate class, 413–414
certificates, security, 402, 405–406
accessing information on with K eyStore class,
411–413
chains of, 406
generating self-signed, 410–411
importing to keystores, 409–410, 411
information contained by, 406
installation of JSSE-specific, 405
X .509 standard for, 406, 409
C ertification Authority (C A), 405
c:expressionL anguage action, JST L core tag
library, 165
c:forE ach action, JST L core tag library, 171–172
c:forTokens action, JST L core tag library,
172–173
char data type, 307
character encodings, SAX  parsers and, 32
character events, SAX , 17
characters( ) callback method, 21, 25, 45
child elements, 60, 210–212
child nodes, DO M , 56, 81–82
choose action, JST L core tag library, 173
c:if action, JST L core tag library, 173
c:import action, JST L core tag library, 174–175
cipher suites, 422–424
displaying via a Web service, 442–443
printing with JSSE _ install_ check.java class,
422–424
classification,Web registry
by business/ service category, 335, 343
C lassificationScheme interface for, 342–343
external, 343
by geographical location, 336
internal, 343
N AIC S framework for, 335, 343
queries based on, 357–363
C lassificationScheme interface, 342–343
C lasspath variables, 117
clearParameters( ) method, 146
client-server connections
client sockets for, 420, 421, 422
debugging, 434–436
secure client sockets for, 429–433
secure server sockets for, 424–429
server sockets for, 420, 421
client-server Web service, 443–447
client sockets
creation of by hand, 421
creation of with SocketF actory, 421
secure, 429–434
client.jsp, 447
close( ) method, 427, 431
coalescing attribute, DO M  parser, 67–68
C ollaboration Profile Protocol (C PP), 340
C ollaboration Protocol Agreement (C PA), 340
comments, parsing X M L, 47, 68
C omplexQ uery class, 359
com.sun.net.ssl.internal.www.protocol parameter,
404
conditional expressions, JST L X M L Tag
Library, 173–174, 196–197
configuration file, generation of server by
xrpcc, 316–317

Index
485
C onnection interface, 345
containsA lias( ) method, 413
C ontent-ID M IM E header, 216
C ontent-Location M IM E header, 216
C ontent-Type M IM E header, 216
C ontentH andler interface, 19, 26, 44–45
core components, ebX M L, 341
c:otherwise action, JST L core tag library, 174
c:out action, JST L core tag library, 169–170
C PA. See C ollaboration Protocol Agreement
(C PA)
c:param action, JST L core tag library, 175
C PP. See C ollaboration Profile Protocol (C PP)
createE mailA ddress( ) method, 374
createM essage( ) method, 225
createM essageF actory( ) method, 266
createN ame( ) method, 220
createO rganiz ation( ) method, 373
createServerSocket( ) method, 422
createService( ) method, 382
createSocket( ) method, 421, 429
c:redirect action, JST L core tag library, 176
C rimson X M L parser, 30
c:set action, JST L core tag library, 170–171
c:urlE ncode action, JST L core tag library,
175–176
c:when action, JST L core tag library, 173
D
data types
JAX -R PC  support, 307
mapping of to X M L data types, 308
transformation of via serializers/ deserializers,
311–312
D ataH andler object, 229
dates, localizing format of, 194–195
debugging
of client-server applications, 434–436
end-to-end, 299
of standalone JAX M  applications and, 247
D eclH andler class, 48
Default R egistry
adding organizations to, 348–351
bug in, 348
defining of by W SDP R egistry Server,
347–348
querying, 351–352
D efaultH andler class, SAX , 19
<definitions> element,W SDL document, 365,
370
delayed response messaging, SO AP messages
and, 257–258
D E L E T E  SQ L command, 179
D eleteE ntry class, 387–393
deleteE ntry( ) method, 388, 413
deleteO rganiz ation( ) method, 388
deploytool web application deployment utility,
64
deprecateE ntry( ) method, 387
deprecateO bjects( ) method, 393
deprecation, registry record, 386–393
deserializers, 312
detachN ode( ) method, 211
D etail object, SO AP, 223
D oconnect class, connecting to registries via,
345–447
DO C T Y PE declaration, X M L validation and,
69
document callbacks, 19–20
endD ocument( ), 20
startD ocument( ), 19–20
D ocument DO M  interface, 57–58
Document nodes, retrieving, 80
Document O bject M odel (DO M ). See DO M
(Document O bject M odel)
D ocument objects, DO M
creation of from X M L file, 77–80
DO M  hierarchy and, 60
Document Type Definitions (DT Ds), 38, 39,
44–45, 48
D ocumentB uilder interface, 62–63, 66–67
D ocumentB uilderF actory interface, 62–63, 65–73
creating D ocumentB uilder with, 66–67
multithreading and, 66, 108–114
obtaining new instance of, 66
setting DO M  parser attributes with, 67–69
doG et( ) method, 84, 105, 108
DO M  (Document O bject M odel), 54–62, 209
constellation creation, 77–80
DO M  tree structure, 55–57
hierarchy of DO M  objects, 57, 60–62
JAX P implementation of. See JAX P (Java API
for X M L Processing)
levels of, 57
node objects in, 55–57
overview of, 54–55
DO M  parsers
building with D ocumentB uilderF actory class,
65–67
coalescing property in, 67–68

486
Index
creation of D ocument object from X M L file,
77–80
custom features of, 115–116
error handling and, 73, 118
expansion of entity reference nodes by, 68
namespace awareness and, 69
plugability interfaces and, 116–117
sample code for, 64–65, 69–73
search path settings and, 117–118
validation of X M L file by, 69, 73
X M L comments and, 68
X M L input sources and, 73–77
X M L whitespace and, 68
See also SAX  parsers
DO M  trees, 55–57
A ttr interface and, 59
changing contents of nodes in, 96–105
creation of from X M L file, 77–80
D ocument interface and, 57–58
document root, obtaining, 80
E lement interface and, 58
emptying of, 105, 107–108
hierarchy of DO M  objects in, 57, 60–62
modifying content of nodes in, 96–108
N ode interface and, 59
node objects in, 55–56
N odeL ist interface and, 59
ParsingX M L.java servlet for, 82–84
searching for nodes in, 89–95
Text interface and, 58
traversal of, 80–82
X M L Parser class and, 84–88
D omX M L  class, 90–93
double data type, 307, 308
driver action, SQ L Tag Library, 177
D RO P  SQ L command, 180
DT D (Document Type Definitions)
enabling SAX  parser validation of, 38, 39
parsing of and D eclH andler class, 48
parsing of and D T D H andler class, 39
whitespace characters and, 44–45
D T D H andler class, 39
E
e-commerce patterns, ebX M L, 341
e-mail messaging
M IM E encoding and, 215
similarity of to asynchronous SO AP
messaging, 256
ebX M L (Electronic Business using X M L), 6,
339–342
ebX M L profile, 268, 269–270
ebX M L registry, 340
process architecture components, 341
product architecture components, 340–341
X M L and, 339–340
E bX M L M essageImpl class, 270
echo( ) function, 77
EC M AScript, 163
economic activity categories, N AIC S, 335, 343
ejbR emove( ) method, 277
Electronic Business using X M L. See ebX M L
(Electronic Business using X M L)
element callbacks, 20–21, 40–41
element events, SAX , 17
E lement interface, w3c DO M , 58, 209
element nodes, DO M , 56–57
E lement objects, DO M  hierarchy of, 60–62
elements,W SDL document, 365–368, 370–372
<binding>, 367, 371–372
<definitions>, 365, 370
<message>, 365, 370
<part>, 365
<port>, 367–368
<portType>, 366, 371
<service>, 368, 372
<types>, 365
EmptyX M L.java servlet, 105, 107–108
encrypted network connections, JSSE and, 6, 7
end document event, 17
end element event, 17
end-to-end debugging solutions, 299
endD ocument( ) callback method, 20, 26
endE lement( ) callback method, 20, 25
endpoint mappings, JAX M  Provider, 268–269
Enterprise Application Integration (EAI), 257
entities, skipped, 76–77
entity reference nodes, DO M , 68
E ntityR esolver interface, 76
Envelope, SO AP, 205–206
adding elements to, 226–227
N ame objects and, 213
SO A P E nvelope interface and, 219–220
error handling
callbacks and, 45–46
DO M  parsers and, 73, 118
event-based X M L parsing and, 45–47
fatal parsing errors, 45, 46, 118
JAX P and, 73, 118, 152–153
SO AP messaging and, 222, 223, 294–298
error( ) method, 73, 118, 152
E rrorH andler interface, 39, 45–47, 118

Index
487
E rrorL istener interface, 152
event-based X M L parsing, 14–26
development of SAX  for, 16–17
error handling and, 45–47
event handlers and, 18–26
example SAX  servlet for, 32–36
good/ bad documents for, 15
multithreading and, 36–37
overview of, 15
SAX  event handlers and, 18–26
SAX  events for, 17–18
SAX  features and properties and, 42–44
SAX  InputSource class for, 31–32
SAX  interfaces for, 26–31
SAX  parser DT D validation and, 39
SAX  parser namespace support and, 39–41
SAX 2 Extensions and, 47–48
strengths and weaknesses of, 14, 54
whitespace characters and, 44–45
See also SAX  parsers
event handlers, SAX , 18–26
basic callbacks, 19–21
C ontentH andler interface, 19, 26, 44–45
D efaultH andler class, 19
example handler with callbacks, 22–26
extension event handlers, 47–48
events, SAX , 17–18
character events, 17
end document, 17
end element, 17
example X M L with associated events, 18
start document, 17
start element, 17
exception actions, 192
exceptions, localization of, 190–192
E xpandE ntityR eferences property, DO M  parser,
68
export rules, JSSE and, 7
Expression Languages (ELs), 7, 160–166
application-wide settings, 164
EC M AScript, 163
future backward compatibility of, 166
JST L core tags for manipulation of
expressions, 167–171
JX Path, 164
setting for specific sections of code, 165
Simplest Possible Expression Language
(SPEL), 161–163
expressionL anguage action, JST L core tag library,
165, 167
expressions, JST L core tags for, 167–171
extension event handlers, 47–48
D eclH andler, 48
L exicalH andler, 47
registration of, 48
external classification, 343
external entities, DO M  parsing of, 75–77
external links, query results and, 364
external resources, incorporating into JSPs,
174–175
F
F actoryC onfigurationE rror( ) method, 117
F actoryC onfigurationE xception exception, 117
fatal parsing errors, 45, 46, 118
fatalE rror( ) method, 73, 118, 152
F aultM essage class, 296
Faults, SO AP, 222, 223, 296–298
features, SAX  parser, 42, 43
file-based X M L sources, passing to DO M
parser, 74
findC oncepts( ) method, 358
findO rganiz ations( ) method, 353–354, 359
first child node, DO M , 56
float data type, 307, 308
flush( ) method, 427
fmt:bundle action, 186
fmt:exception action, 192
fmt:formatD ate action, 194–195
fmt:formatN umber action, 192–194
fmt:locale action, 184
fmt:message action, 188
fmt:messageA rg action, 189–190
fmt:messageF ormat action, 188
fmt:parseN umber action, 194
fmt:timeZ one, JST L tags for, 184–185
forE ach action, JST L core tag library, 171–172,
196–197
formatD ate action, 194–195
formatN umber action, 192–194
forTokens JST L action, JST L core tag library,
172–173
G
-genkey command, 406, 408
geographic location, classification of service
providers by, 336
get( ) method, 33, 36, 84
getA lgorithm method, 415
getA llA ttributes( ) method, 210
getA ssociatedStyleSheet( ) method, 142, 143

488
Index
getA ttribute( ) method, 142, 143
getA ttributeValue( ) method, 210
getB ody( ) method, 220
getC ertificate( ) method, 412
getC ertificateC hain( ) method, 413
getC hildC oncepts( ) method, 342
getC hildE lements( ) method, 211
getC ipherSuites( ) method, 422–424
getC lassificationScheme( ) method, 343
getC lassifiedO bject( ) method, 343
getC olumnN umber( ) method, 153
getC oncept( ) method, 343
getC ontent( ) method, 218
getC ontentId( ) method, 218
getC ontentL ocation( ) method, 218
getD efault( ) method, 423, 425, 429
getD escription( ) method, 344, 359
getE nabledC ipherSuites( ) method, 423
getE ncoded( ) method, 414
getE nvelope( ) method, 218
getE rrorL istener( ) method, 142, 144, 146
getE xternalL inks( ) method, 359
getF eature( ) method, 115, 142, 144
getF ormat( ) method, 415
getH eader( ) method, 220
getID ( ) method, 359
getInputStream( ) method, 431
getInstance( ) method, 412, 415, 429
getK ey( ) method, 359, 413
getK eyM anagers( ) method, 429
getL ineN umber( ) method, 153
getL ocalizedM essage( ) method, 190, 191
getM etaD ata( ) method, 266
getM imeH eader( ) method, 218
getN ame( ) method, 344
getN onM atchingM imeH eaders( ) method, 218
getO rganiz ations( ) method, 381
getO utputP roperties( ) method, 146, 147
getO utputStream( ) method, 430
getParameter( ) method, 146
getParseE xceptionInfo( ) method, 73
getP rimaryC ontact( ) method, 344
getP roperty( ) method, 115
getP rovider( ) method, 413
getP ublicId( ) method, 153
getP ublicK ey( ) method, 414
getServices( ) method, 344, 381
getSystemId( ) method, 153
getType( ) method, 413, 414
getU R IR esolver( ) method, 143, 144, 146, 147
getValue method, 359
getValue( ) method, 212, 213
getValues( ) method, 437–438
guaranteed delivery, JAX M  Provider and,
262–263
H
handshaking mechanisms, cipher suites and,
422–424
H eader scope, SPEL, 162
H eader, SO AP, 205–207
adding elements to, 226–227
SO A P H eader interface for, 220–221
SO A P H eaderE lement interface for, 220, 221
headers, M IM E, 216
holder classes, JAX -R PC, 312–313
H T M L documents
DO M  programming interface for, 54–55, 58
parsing of. See X M L parsers
H T T P U R Ls, 7
H T T PS protocol, 404
handshake mechanisms and cipher suites,
422–424
U R L handlers and, 404, 416, 418–419
H T T P Servlet interface, 84, 271, 272
H T T P ServletR equest object, 105
H ttpServletR esponse.sendR edirect( ) method, 176
H ttpServlet.setA ttribute( ) method, 162
H ttpSession.getA ttribute( ) method, 162
H ttpSession.setA ttribute( ) method, 162
I
IBM  test registry
adding organizations to, 348–351
querying, 351–352
identity database, JDK 1.1, 409, 411
-identitydb command, 409
if action, JST L core tag library, 173, 197
ignorable whitespaces, X M L, 44–45
ignorableW hitespace  callback, 44–45
IgnoreC omments property, DO M  parser, 68
IgnoreE lementC ontentW hitespace property, DO M
parser, 68
import action, JST L core tag library, 174–175
-import command, 409–410
in-order traversal technique, 80–82
init( ) method, 33, 109
input sources, X M L, 73–77
passing file-based to JAX P parser, 74
passing InputStream-based to JAX P parser, 74
passing to JAX P parser via InputSource class,
74

Index
489
passing to SAX  parser via InputSource class,
31–32
input stream, passing X M L to DO M  parser, 74
InputSource class, 31–32
InputStream-based X M L sources, passing to
DO M  parser, 74
InputStream class, M IM E-encoded SO AP
attachments and, 230
insecure sockets, JSSE and, 402
IN SE RT  SQ L command, 179
instances, creation of SAX  parser, 26–31
int data type, 308
internal classification, 343
Internationalization (L18N ), 182–195
accessing internationalized messages, 187–188
exception localization, 190–192
localizing numerical values, 192–195
parameter substitution in internationalized
messages, 188–190
resource bundles, locating, 186–187
resource bundles, specifying, 185–186
setting Web browser language, 183–184
time zone settings, 184–185
IO E xception exception, 77
ISO -Latin-1 encoding, 32
iso.ch:3166:1999 taxonomy for geographical
regions, 336
iterations
JST L support of over objects, 171–173
JST L support of over X M L elements, 196
J
J2EE container, 254, 258
JAF. See JavaBeans Activation Framework (JAF)
JAR  metafiles, 29
jarsigner tool, 407
Java API for X M L-based R emote Procedure
C alls. See JAX -R PC  (Java API for X M L-
based R emote Procedure C alls)
Java API for X M L M essaging. See JAX M  (Java
API for X M L M essaging)
Java API for X M L Processing. See JAX P (Java
API for X M L Processing)
Java API for X M L R egistries. See JAX R  (Java
API for X M L R egistries)
Java classes
conversion between W SDL with xrpcc,
313–317
holder classes for W SDL mapping, 312–313
mapping of to X M L data types, 308–309
non-standard, support of via
serializers/ deserializers, 311–312
ValueTypes (application classes), 310–311
See also specific classes
Java C ryptography Architecture, 402
Java data types
JAX -R PC  support of, 307
mapping of to X M L data types, 308
transformation of via serializers/ deserializers,
311–312
Java M essage Service (JM S) API, 276
Java N aming and Directory Interface (JN DI),
264, 265
Java Secure Sockets Extension. See JSSE (Java
Secure Sockets Extension)
Java Server Pages (JSPs), 7, 160, 161
conditional execution support in, 173–174
importing external resources into, 174–175
internationalization and localization JST L
tags for, 182–195
iteration support, 171–173
referencing expressions in, 167–171
SPEL scope values and, 162–163
SQ L query tags for, 176–182
Java Web Services Developer Pack (JW SDP).
See JW SDP (Java Web Services
Developer Pack)
Java W SDP R egistry Server. SeeW SDP
R egistry Server
Java X M L Pack, 63
JavaBeans
JavaBeans Activation Framework (JAF) and,
229
JAX -R PC  and, 311
javakey tool, 407
java.lang.String getA ttributeValue( ) method, 210
java.lang.String interface, 171, 308
java.lang.System interface, 404, 405
java.lan.T hrowable interface, 190
java.math.B igD ecimal interface, 308
java.math.B igInteger interface, 308
java.net.U R L  interface, 7
java.protocol.handler.pkgs property, 404, 416–417
java.rmi.R emote interface, 311
java.util.C alendar interface, 308
java.util.C ollection interface, 171
java.util.D ate interface, 308
java.util.E numeration interface, 171
java.util.Iterator getA llA ttributes( ) method, 210
java.util.Iterator interface, 171

490
Index
javax.activation.D ataH andler object, 229
java.xml.transform package, 140
javax.servlet.jsp.jstl.i18n.timeZ one JSP attibute,
184
javax.servlet.jsp.jstl.sql.R esult interface, 177
javax.xml.parsers.*  package, 27
javax.xml.soap.D etail interface, 223
javax.xml.soap.N ode interface, 211
javax.xml.soap.SO A P B ody interface, 222
javax.xml.soap.SO A P B odyE lement interface, 222
javax.xml.soap.SO A P E nvelope interface,
219–220
javax.xml.soap.SO A P H eader interface, 220–221
javax.xml.soap.SO A P H eaderE lement interface,
220, 221
javax.xml.soap.SO A P M essage class, 214–217
javax.xml.soap.SO A P Part class, 217–219
JAX -R PC  (Java API for X M L-based R emote
Procedure C alls), 5, 63, 304–313
advantages of over other R PC  methods, 307
array support by, 308, 309–310
function call semantics and, 305
holder classes for W SDL mapping, 312–313
Java data types supported by, 307
JAX -R PC  C lient, creation of, 317–319
JAX -R PC  Server, creation of, 319–321
JR E class library support, 307–308
non-standard classes, serializers/ deserializers
for, 311–312
object type mappings, 308–309
sending a X M L-R PC  message with,
306–307
stubs and ties in, 305–306
synchronous X M L SO AP messaging in,
304–305
ValueTypes (application classes) and, 310–311
JAX -R PC  C lient, 317–319
connecting to remote server via stubs, 318,
325
example server, 325–327
invoking remote server methods, 318–319,
325–327
JAX -R PC  Server, 319–321
example server, 321–324
Service Definition Interface (SDI) for, 319,
321–322
service implementation class for, 320,
322–323, 324
WAR  files for, 320–321
xrpcc config file for, 319–320, 324
JAX M  (Java API for X M L M essaging), 4–5, 63,
204
DO M  API. See JAX M  (Java API for X M L
M essaging) DO M  API
guaranteed delivery and, 263
JavaBeans Activation Framework (JAF) and,
229
SO AP EJB implementation, 270, 275–277
SO AP message generation with
M essageF actory, 224–226
SO AP server servlet implementation,
270–274
standalone SO AP client example, 231–247
JAX M  (Java API for X M L M essaging) DO M
API, 204, 209
adding attachments to SO AP messages,
228–230
creating N ame objects, 213–214
creating Text objects, 214
JAX M  Provider and. See JAX M  Provider
methods for adding/ reading text nodes,
212–213
methods for manipulating SO A P E lement
attributes, 210
methods for manipulating SO A P E lement
child elements, 210–212
M IM E-encoded SO AP attachments and,
208, 214, 215–217
SO A P E lement interface, 209–214
SO A P E nvelope interface, 219–220
SO A P H eader interface, 220–221
SO A P H eaderE lement interface, 220, 221
SO A P M essage interface, 214–217
SO A P Part interface, 217–219
X M L-only SO AP messages, 214–215
JAX M  Profiles, 225, 254, 269–270
JAX M  Provider, 223–224, 254, 258, 260, 261
deployment of Provider clients, 265
endpoint mappings, 268–269
establishing connection to, 263–266
incoming message routing and, 260, 261–262
message creation with P roviderC onnection
objects, 266
message-driven beans and, 270, 275–277
obtaining M essageF actory class, 224, 225–226
Profiles and, 269–270
sending messages with P roviderC onnection
objects, 266, 267–269
SO AP EJB and, 270, 275–277
SO AP server servlet and, 270–274

Index
491
steps for sending messages via, 264
JAX M  R eference Implementation, 263, 268
JAX M  Servers
incoming message routing, 260–262
outgoing message routing, 262–263
JA X M Servlet interface, 270–274
JAX P (Java API for X M L Processing), 3–4,
62, 63
DO M  interfaces provided by, 57–59, 62–63
error handling and, 152–153
multithreading and, 36–37, 66, 108–114, 154
plugability interfaces and, 27, 28–31, 62, 140,
155
resolution of U R I references and stylesheets
by, 153–154
sample code for JAX P parser, 64–65
SAX  classes and packages in, 27
SAX  parser instances, creation of, 27–31
templates for X SL processing, 149–152
transformers for X SL processing, 145–149
X M L file transformation classes, 140–152
X SL and X LST  and, 124–139
X SL engines and, 124, 139–140
See also DO M  (Document O bject M odel);
SAX  (Simple API for X M L)
JAX P parsers
building, 65–73
custom features of, 115–116
error handling and, 73, 118
plugability interfaces and, 116–117
sample code for, 64–65
search path settings and, 117–118
X M L input sources and, 73–77
JA X P entity entity, 68
JAX R  (Java API for X M L R egistries), 6, 63,
334, 336
adding new registry records with, 372–381
B usinessL ifeC ycleM anager interface, 357–358
B usinessQ ueryM anager interface, 353–364
connecting to registries with D oconnect class,
345–347
deprecating and deleting registry records
with, 386–393
interfaces for categorization of registry
objects, 342–343
JAX R  R egistry Server activation, 460–461
O rganiz ation interface, 343–344
updating registry records with, 381–386
U ser interface, 344
JDK 1.1 identity database, 409, 411
JM S (Java M essage Service) API, 276
JN DI (Java N aming and Directory Interface),
264, 265
JPEG images, attaching to SO AP messages,
217, 229
JSP Standard Tag Library (JST L). See JST L (JSP
Standard Tag Library)
jsp:import action, 175
jsp:include action, 175
JSPs (Java Server Pages). See Java Server Pages
(JSPs)
JspW riter object, 169
JSSE (Java Secure Sockets Extension), 6–7, 402
cacerts file for, 405, 433
cipher suites and, 422–424
client sockets and, 420, 421
creating keystores with keytool, 407–409
generating self-signed certificates with
keytool, 410–411
importing certificates with keytool, 409–410,
411
installation and configuration of, 402–405
keystores, referring to with JSSE, 411–416
secure client sockets and, 429–434
secure server sockets and, 424–429
server sockets and, 402, 420, 422
SSL support by, 402
T LS support by, 402
U R L handlers and, 404–405, 416–419
W SDP and, 437–447
JSSE _ install_ check.java class, 422–424
JST L (JSP Standard Tag Library), 7, 63, 160,
197
configuring Web application for, 166
core tags containing conditional expressions,
173–174
core tags for encoding strings as U R Ls,
175–176
core tags for evaluation and manipulation of
expressions, 167–171
core tags for importing external resources,
174–175
core tags supporting iterations, 171–173
Expression Languages (ELs) and, 160–166
internationalization and localization tags,
182–195
non-Expression Language libraries, 166
number of libraries, 160
SPEL attribute literal values, 163
SPEL attribute scope values, 162–163

492
Index
SQ L Tag Library package, 176–182
X M L support tags, 195–198
JW SDP (Java Web Services Developer Pack)
Ant build tool and. See Ant build tool
configuration of, 460
downloading and installing, 12, 63–64, 454,
455–460
limitations of, 461–462
operating systems supported by, 461
overlapping APIs in, 3, 4
overview of components of, 2, 3–8
R egistry Server activation in, 460–461
as response to .N et initiative, 3
SO AP example client libraries, 232–233
Tomcat tool and. SeeTomcat
U DDI R egistry and. See U DDI R egistry
using JSSE applications with, 437–447
See also specific components
JX Path, 164
K
key managers, 429
K eyM anagerF actory class, 429
keys, 402, 405–406
accessing information on with C ertificate
class, 414
accessing information on with K eyStore class,
411–413
certificates for, 405–406
generation of keystore with -genkey
command, 408
private, 405
public, 405
storage of in keystore, 407
K eyStore class, 429
-keystore command, 409
keystores, 402, 405, 407
C ertificate class and, 413–414
creating with keytool utility, 408–409
importing certificates to, 409–410, 411
K eyStore class and, 411–413
referring to with JSEE properties, 411–416
types of entries in, 407
keytool utility, 402, 407
creating keystores with, 408–409
importing certificates with, 409–410, 411
L
leaf node, DO M , 57
left-to-right (LT R ) traversal, 80
Levels, DO M , 57
L exicalH andler interface, 47
Linux
JW SDP installation on, 455, 456–460
Tomcat installation on, 467
literal JST L attribute values, 163
locale action, JST L tags for, 184
Localization (L10N ), 182. See also
Internationalization (L18N )
localN ame objects, 213
localN ame parameter, 20, 40–41
L ocalX M L E xception class, 295
L ocator mechanism, debugging X M L with,
37–38
long data type, 307, 308
M
marshaling, X M L-R PC  and, 305
M egginson, David, 16
message action, JST L, 188
message-driven beans, SO AP EJB and, 270,
275–277
<message> element,W SDL document, 365, 370
messageA rg action, 189–190
M essageD rivenB ean interface, 277
M essageF actory createM essageF actory( ) method,
266
M essageF actory interface
obtaining, 224, 225–226
SO AP message generation with, 225, 266
M essageF actory.newInstance( ) method, 224, 225
messageF ormat action, 188
messaging service, ebX M L, 340
M icrosoft W indows
installation of JW SDP with, 455, 456–460
Tomcat installation with, 467
versions supported by JW SDP, 461
M IM E (M ulti-purpose Internet M ail
Extensions), 215–216
content types supported by, 216
JavaBeans Activation Framework (JAF) and,
229
M IM E-encoded SO AP attachments, 208,
214, 215–217, 228–230
M IM E headers, 216, 218–219
M IM E types that must be implemented by
JAX M , 229
SO A P Part class and, 218–219
M imeH eader objects, SO A P Part methods for,
218–219
modifyForm.html code, 96
M odifyX M L .java class, 97–103

Index
493
multi-dimensional arrays, JAX -R PC  support
for, 309–310
multithreading, 154
JAX P and, 36–37, 66, 108–114, 154
SAX  servlets and, 36–37
mustU nderstand attribute, SO AP header, 206
M VC  components, 160
M yE rrorH andler interface, 73, 118
N
N AIC S. See N orth American Industry
C lassification System (N AIC S)
N ame interface, 209, 213
N ame objects, 213
name/ value pairs, printing node object, 82–89
N amespaceA ware property, DO M  parser, 69
namespaces, X M L, 20
element callbacks and, 40–41
enabling DO M  parser support of, 69
enabling SAX  parser support of, 38, 39–40
prefix mapping callbacks and, 41
SAX  Version 2.0 and, 17
SO AP messages and, 205–206, 207
N ameValueL ookup class, 287
naming services, JN DI API and, 264
nested database transactions, 180–182
newInstance( ) method, 28, 143
newSA X Parser( ) method, 28
newTemplates( ) method, 143
newTransformer( ) method, 142, 143
N ode interface, 59, 211
node objects, 55–57, 90–93
element nodes, 56–57
finding root object, 80
first child nodes, 56
generating lists of based on search
parameters, 89–95
hierarchy of, 57
locating sibling and child, 81–82
location of by X Path, 128–130
modifying content of, 96–108
node axes, 129–130
printing name/ value pairs, 82–89
text nodes, 57
traversal of, 80–81
N odeL ist interface, 59
non-fatal parsing errors, 46, 118
N orth American Industry C lassification System
(N AIC S), 335, 343
notification operations,W SDL, 366, 367
nsN ame objects, 213–214
numbers, localizing the formatting of, 192–194
O
O ASIS, 339
objects, mapping of to X M L data type,
308–309
one-way operations,W SDL, 366, 367
one-way SO AP messages, 256–257
O newayL istener interface, 261, 271, 273, 274,
278
onM essage( ) method, 261
operating systems, JW SDP support of, 461
O rganiz aiton interface, 343–344
organizations, 343
adding to registries with JW SDP classes,
372–381
adding to registries with R egistry Browser,
348–351
C lassificationScheme interface for, 342–343
deprecating and deleting records of in
registries, 386–393
N AIC S registry categories for by economic
activity, 335, 343
registry classification by geographical
location, 336
representation of by O rganiz ation interface,
343–344
storage of information on in Web registries,
334–336, 343–344
U DDI Business R egistry for, 337, 338–339
updating information on in registry records,
381–386
org.xml.sax.* SAX  package, 27
org.xml.sax.helpers.* SAX  package, 27
otherwise action, JST L tag library, 174, 197–198
out action, JST L tag library, 169–170, 196
P
packages, SAX , 27
Page scope, SPEL, 162
PageC ontent.getA ttribute( ) method, 162
PageC ontext.findA ttribute( ) method, 163
PageC ontext.setA ttribute( ) method, 162
param action, JST L tag library, 175, 177–179
Param scope, SPEL, 162, 163
ParamValues scope, SPEL, 162
parent node, DO M , 60–61
parse action, JST L tag Library, 195–196
parse( ) method, 74
parseN ow( ) method, 110

494
Index
parseN umber action, 194
parser factory, JAX P, 27–28
ParserC onfigurationE xception exception, 67,
117–118
parsers, X M L. See X M L parsers
ParsingX M L.java servlet, 83–84, 88
<part> element,W SDL document, 365
passwords
specifying key, 408
Web service registry, 393–394
pdata( ) method, 440
platform defaults, JAX P parser searches based
on, 29
plugability interfaces
DO M  parsers and, 116–117
SAX  parsers and, 27, 28–31
TransformerF actory interface and, 155
<port> element,W SDL document, 367–368
<portType> element,W SDL document, 366,
371
prefix mapping callbacks, 41
primitive data types, 307, 308
private keys, 402, 405
procedures, X SL, 128, 131–139
processing instructions, parsing of, 45
processingInstruction callback, 45
Profiles, JAX M . See JAX M  Profile
projects,Ant build file, 473
properties
JAX P parser searches based on, 29
SAX  parser, 42, 43–44
P rovideC onnection.createM essageF actory( ) method,
225–226
Provider, JAX M . See JAX M  Provider
P roviderC onnection objects, 225, 266–270
P roviderC onnectionF actory object, 264, 265–266
P roviderM etaD ata getM etaD ata( ) method, 266
proxy servers, H T T PS and, 416
public keys, 402, 405
P ublishE ntry class, 375–381
Q
qN ame parameter, 20, 40–41
queries,Web register
of IBM  test registry with R egistry Browser,
351–352
locating services via complex, 357–363
locating services via simple, 353–357
understanding results obtained by, 363–364
query action, SQ L Tag Library, 177
query( ) method, 354, 357
R
R DBM S. See R elational Database M anagement
System (R DBM S)
R eceivedM essage class, 284
recycleN ode( ) method, 211–212
redirect action, JST L core tag library, 176
registries,Web service, 6, 334
adding organizations to with JW SDP classes,
372–381
adding organizations with R egistry Browser,
348–351, 462–467
categorization of businesses/ services, 335,
342–343
connecting to with connection( ), 345, 372
connecting to with D oconnect class, 345–347
Default R egistry, 347–352
deprecating and deleting records in, 386–393
ebX M L specification for, 6, 339–342
queries, simple, 353–357
querying based on classification, 357–363
querying with R egistry Browser, 351–352
representation of entities in by O rganiz ation
interface, 343–344
results of queries of, 363–364
storage of service metadata in, 334–336
taxonomy for geographical services in, 336
U DDI specification for, 6, 337–339
updating records in, 381–386
username and password protection of,
393–394
R egistry Browser,W SDP, 462–467
adding organizations to classifications via,
465–467
adding organizations to Default R egistry via,
348–351
launching, 347–348
querying Default R egister with, 351–352
registry selection with, 462–463
R egistry Server, JW SDP. SeeW SDP R egistry
Server
R egistryO bject interface, 342–343
R elational Database M anagement System
(R DBM S), 263
remote procedure calls. See JAX -R PC  (Java
API for X M L-based R emote Procedure
C alls)
removeA llM imeH eaders( ) method, 219
removeA ttribute( ) method, 210
removeC lassifications( ) method, 342
removeM imeH eader( ) method, 219

Index
495
R eplyM essage interface, 292
R eqR espL istener interface, 261, 271, 273, 274,
278
request-response messaging
SO AP and. See synchronous message routing
W SDL and, 366, 367
R equest scope, SPEL, 162
resolve( ) method, 153
resolveE ntity( ) method, 76
resource bundles
filename parts, 186
locating, 186–187
specifying, 185–186
R esult interface, 144–145
R M I, 5, 313, 315–316
R PC s, X M L-based. See JAX -R PC  (JAX -R PC
(Java API for X M L-based R emote
Procedure C alls)); X M L-based R PC
S
saveO rganiz ations( ) method, 375
saveServices( ) method, 382
SAX  (Simple API for X M L)
basic events in, 17–18
C ontentH andler interface and, 19, 26, 44–45
debugging documents L ocator mechanism,
37–38
D efaultH andler interface, 19
E rrorH andler interface, 45–47
event-based X M L parsing with, 14, 15
event handlers and, 18–26
example servlet application, 32–36
example X M L with associated events, 18
history of, 16–17
multithreading and, 36–37
organization of in JAX P, 27
plugability layers and, 27
SAX 2 Extensions, 47–48
Web site for, 14, 16
X M L R eader interface and, 26–27, 46, 115
SAX  parsers, 15
basic events and, 17–18
character encodings and, 32
configuration of, 42–44, 115
C ontentH andler interface and, 19, 26, 44–45
C rimson, 30
determining position of in document, 37–38
development of standard interface for, 16–17
DT D validation and, 38, 39
error handling by, 45–47
event handlers and, 18–26
example SAX  application using, 32–36
example X M L with associated events created
by, 18
features of, 42, 43, 115
instantiation of, 27–31
multithreading and, 36–37
passing documents to with InputSource class,
31–32
plugability interfaces and, 27, 28–31
properties of, 42, 43–44, 115
searching environment for suitable, 28–31
X erces, 30
X M L namespaces and, 38, 39–41
X M L processing instructions and, 45
SAX 2 Extensions, 47–48
SA X E xception exception, 76, 77
SA X N otR ecognizedE xception exception, 115
SA X N otSupportedE xception exception, 115
SAX O N  X SL engine, 139
SA X Parser interface, 28
SA X ParserF actory interface
creation of parser instances via, 27–28
enabling DT D validation through, 39
enabling SAX  parser support of namespaces
with, 39–40
multithreading and, 37
setting parser features with, 43
SA X Parser.parse( ) method, 47
SchemaE xception class, 294
SDI. See Service Definition Interface (SDI)
search engines, vs. U DDI registries, 339
searchForm.html, 89–90
SearchInX M L servlet, 93–95
secure client sockets, 429–434
client-server Web service and, 443–447
closing server connections, 431
connecting to secure server, 430
creation of, 429–430
reading server data, 431
SecureC lient class for, 431–533
writing data to server, 430
Secure H T T P (H T T PS) protocol, 404
handshake mechanisms and cipher suites,
422–424
U R L handlers and, 404, 416, 418–419
secure server sockets, 424–429
acceptance of client connections by, 426
client-server Web service and, 443–447
closing client connections, 427

496
Index
creating, 425
reading data from clients, 426
registration of, 426
writing of data to clients, 427
Secure Socket Layer (SSL), 6, 402, 424. See also
secure server clients; secure server sockets
SecureC lient interface, 431–433
SecureC lient.java, 443, 446–447
SecureServer interface, 427–429
SecureServer.java, 443, 444–446
security certificates, 402, 405–406
accessing information on with K eyStore class,
411–413
chains of, 406
generating self-signed, 410–411
importing to keystores, 409–410, 411
information contained by, 406
installation of JSSE-specific, 405
X .509 standard for, 406, 409
security.jsp, 442–443
SE L E C T  SQ L command, 177
self-signed certificates, 410–411
-selfcert command, 410–411
send( ) method, 266
serializers, 311
server sockets, 402
creation of, 420, 422
secure, 424–429
server.jsp, 445–446
ServerSocket interface, 420
ServerSocketFactories, JSSE, 420, 422
server.xml file,Tomcat, 468–469
Service Definition Interface (SDI), 305, 319
Service Definition WAR  package, 320–321
<service> element,W SDL document, 368, 372
service registries. See registries,Web service
services type, U DDI Business R egistry, 338
ServletC ontext.getA ttribute( ) method, 162
ServletC ontext.setA ttribute( ) method, 162
ServletR equest.getA ttribute( ) method, 162
ServletR equest.getParameter( ) method, 162
ServletR equest.getParameterValue( ) method, 162
ServletR equest.setA ttribute( ) method, 162
servlets
AdditionInX M L servlet, 103–105
EmptyX M L.java, 105, 107–108
example servlet, 32–36
multithreading and, 36–37
ParsingX M L.java, 83–84, 88
SearchInX M L servlet, 93–95
SO AP server servlet, 270–274, 277–298
T hreadSafe.java servlet, 109–110
X M O Parser.java, 84–88
Session scope, SPEL, 162
session states, asynchronous messaging and,
258–259
set action, JST L tag library, 170–171, 196
setA ttribute( ) method, 143, 209
setC ertificateE ntry( ) method, 413
setC lassificationScheme( ) method, 343
setC oncept( ) method, 343
setC ontentL ocation( ) method, 219
setC onversationID  method, 270
setE mailA ddress( ) method, 374
setE rrorL istener( ) method, 143, 144, 146, 147
setF eature( ) method, 115
setK eyE ntry( ) method, 413
setM essageD rivenC ontent( ) method, 277
setM imeH eader( ) method, 219
setN odeValue( ) method, 103
setO utputP roperties( ) method, 147
setO utputP roperty( ) method, 147
setParameter( ) method, 146, 147
setP ersonN ame( ) method, 373–374
setP roperty( ) method, 115
setU R IR esolver( ) method, 143, 144, 146, 147
short data type, 308
sibling nodes, 61, 81–82
Simple O bject Access Protocol. See SO AP
(Simple O bject Access Protocol)
SimpleQ uery interface, 354
Simplest Possible Expression Language (SPEL),
161–163
allowable attribute scope values, 162
literal attribute values, 163
searching for attributes, 163
size( ) method, 412
skipped entities, 45, 76–77
skippedE ntities( ) callback, 45
skippedentity( ) method, 76–77
SO AP (Simple O bject Access Protocol), 4–5,
204–207
asynchronous messaging and. See SO AP
messages, asynchronous
binding elements and, 367, 371–372
producing SO AP messages with
M essageF actory, 224–226
SO AP example client, 231–247
SO AP message components, 205–207
SO AP M essages with Attachments, 208

Index
497
SO A P B ody interface, 222
SO A P E lement interface, 209–214
SO A P E nvelope interface, 219–220
SO A P F ault interface, 222–223
SO A P H eader interface, 220–221
SO A P H eaderE lement interface, 220, 221
SO A P M essage interface, 214–217
SO A P Part interface, 217–219
synchronous messages. See SO AP messages,
synchronous
U DDI specification and, 339
SO AP Body, 205, 207, 212
SO AP clients, 204, 230–247
debugging, 247
execution of requests by, 232–246
output from successful execution of, 246
SO AP Fault response, 246, 247
standalone, 231
SO AP EJB, 270, 275–277
SO AP Envelope, 205–206
adding elements to, 226–227
N ame objects and, 213
SO A P E nvelope interface and, 219–220
SO AP Faults, 222, 223, 296–298
SO AP H eader, 205–207
adding elements to, 226–227
SO A P H eader interface, 220–221
SO A P H eaderE lement interface, 220, 221
SO AP messages, asynchronous, 255–259
creating with P roviderC onnection, 266, 267
delayed response messaging, 257–258
example SO AP servlet for, 277–298
one-way messaging, 256–257
recording of state of, 258–259
routing of, 255–256, 260–263
sending with P roviderC onnection, 267–269
SO AP EJB implementation for, 270, 275–277
SO AP server servlet for, 270–273, 277–298
SO AP messages, synchronous, 204, 254,
255–256, 257–258
adding attachments to, 228–230
Body element in, 205, 207, 222–223
Envelope in, 205–206, 219–220
example of, 230–247, 255
Faults in, 222, 223
H eader in, 205–207, 220–221
JAX -R PC  and, 304–305
message routing, 259–260, 261
M IM E-encoded SO AP attachments to, 208,
215–217
namespaces in, 205–206
populating components of, 226–227
producing with M essageF actory, 224–227
routing of, 259–260, 261
SO AP M essages with Attachments and, 208
SO AP server servlet for, 274
SO A P Part class and, 217–219
X M L-only SO AP messages, 208, 214–215
See also SO AP messages, asynchronous;
X M L-based R PC
SO AP M essages with Attachments, 204, 208,
214
SO AP Providers, 223–224, 254
SO AP-R PC, 304
SO AP server servlet, 270–274
deployment of in servlet container, 298
example of, 277–298
exception handling by, 294–298
JA X M Servlet class for, 271–272
message handling by, 274
overriding of methods in, 273–274
SO AP servers, 254–299, 277–298
incoming message routing, 260–262
JAX M  Provider connections, 263–266
recording of state and, 258–259
SO AP EJB for, 270, 275–277
SO AP server servlet for, 270–274, 277–298
SO A P B ody interface, 209, 222
SO A P E lement addA ttribute( ) method, 210
SO A P E lement interface, 209–214
creating N ame objects, 213–214
creating Text objects, 214
methods for adding/ reading text nodes,
212–213
methods for manipulating attributes, 210
methods for manipulating child elements,
210–212
SO A P B ody subinterface, 209
SO A P E nvelope subinterface, 209
SO A P H eader subinterface, 209
SO A P E nvelope interface, 209, 219–220
SO A P E nvelope object, 213–214
SO A P F ault interface, 222–223
SO A P H eader interface, 209, 220
SO A P H eaderE lement interface, 220, 221
SO A P M essage interface, 214–217
M essageF actory interface and, 224–227
M IM E-encoded SO AP attachments and,
215–217, 228–230
X M L-content only SO AP messages and,
214–215
SO A P Part interface, 217–219, 226

498
Index
SO APR P profile, 268, 270
SO A P R P M essageImpl interface, 270
SO A P Serializer interface, 311
Socket interface, 420, 421
SocketFactories, JSSE, 402, 420, 421, 422
sockets, 402
creation of, 420
creation of client side, 421
creation of server side, 420, 421
using secure client, 429–434
using secure server, 424–429
solicit-response operations,W SDL, 366, 367
Source interface, 144–145
SourceL ocator interface, 153
specification pointers, U DDI Business R egistry,
338
SPEL. See Simplest Possible Expression
Language (SPEL)
SQ L databases, 176–182
defining data sources, 176–177
nesting of SQ L transactions, 180–182
query execution, 177–179
updating, 179–180
SQ L Tag Library package, 176–182
executing queries, 177–179
nesting of SQ L transactions, 180–182
setting up the database driver, 176–177
updating databases, 179–180
sql:driver action, SQ L Tag Library, 177
sql:param action, SQ L Tag Library, 177–179
sql:query action, SQ L Tag Library, 177
sql:transaction action, SQ L Tag Library, 180–182
sql:update action, SQ L Tag Library, 179–180
SSL. See Secure Socket Layer (SSL)
SSL C ontext interface, 425, 429
SSL F actory interface, 402
SSL ServerSocket interface, 426
SSL ServerSocketF actory interface, 423, 425
SSL SocketF actory interface, 429
SSL Sockets interface, 402
standalone JAX M  applications
debugging, 247
example SO AP application, 231–247
limitations of, 231
start document event, 17
start element event, 17
startC lient( ) method, 446
startD ocument( ) method, 19–20, 25
startE lement( ) method, 20, 25
startH andshake( ) method, 429
startServer( ) method, 445
storeR esult( ) method, 73, 88, 103
stream-based sources, passing to X M L parser,
31
String argument, 191
String variable, DO M  parsing of, 75
stubs, X M L-R PC  and, 305–306
stylesheets, X SL, 124
scanning, 143
Transformer interface and, 145–146
SunJSSE  provider, 402
dynamic registration of, 404
static registration of, 403
synchronized( ) method, 109
system property, JAX P parser searches based
on, 29
T
tag library, JSP. See JST L (JSP Standard Tag
Library)
targets,Ant build file, 473–474
tasks,Ant build file, 474
TempDT D.xml, 69
Templates, JAX P and, 149–152
TestK eys.java class, 414–416, 437–440
text attachments, SO AP message, 228–229
Text interface, 58, 214
Text nodes, 57, 58, 61, 67–68, 214
T hreadSafe.java servlet, 109–110
ties, X M L-R PC  and, 305–306
time, localization of format of, 194–195
time zone settings, JST L tags for, 184–185
timeZ one action, JST L tags for, 184–185
T LS (Transport Layer Security), 6
tM odel, U DDI Business R egistry, 338
Tomcat, 7–8, 63, 454, 467–472
activation of Tomcat server, 460–461, 462,
471–472
environmental variables needed by, 468
installation of, 467
relationship to Apache servers, 472
server.xml files for, 468–469
WAR  files for, 469–471
webapps directory for, 469
web.xml configuration file, 471
tracing, debugging and, 37
transaction action, SQ L Tag Library, 180–182
transform action, JST L X M L Tag Library, 198
transform( ) method, 145–146, 147
transformation, X M L, 140–152

Index
499
creation of X SLT  transformation code for,
140–144
input and output processing, 144–145
templates for, 149–152
transformers for, 145–149
Transformer interface, 145–149
generation of with TransformerF actory,
140–144
methods in, 146–147
multithreading and, 149, 154
TransformerF actory class, 140–144
transformers, X SLT, 140–144, 145–149
Transport Layer Security (T LS), 6, 402
traversal, DO M  tree, 80–82
trusted certificate entries, keystore, 407
TrustM anager, 405
<types> element,W SDL document, 365
U
U DDI R egistry, 454
connecting to with D oconnect class, 345–347
installation of JW SDP for, 455–460
messages not supported by, 461–462
registry selection with R egistry Browser,
462–467
U DDI Business R egistry, 337, 338–339
U DDI registries vs. search engines, 339
See also W SDP R egistry Server
U DDI specification, 6, 337–339, 454
connecting to registries with D oconnect class,
345–347
protocols supported by, 339
registry nodes and, 337
U DDI Business R egistry, 337, 338–339
U N / C EFAC T, 339
U niform R esource Indentifier (U R I), 31
U nix, 455, 456–460, 461
unmarshaling, X M L-R PC  and, 305, 306
U nsafeParser interface, 110, 111–114
update action, SQ L Tag Library, 179–180
U pdate interface, 383–386
U P D A T E  SQ L command, 179, 182
updates, registry record, 381–386
U R I-based sources, passing to X M L parser, 31
U R I parameter, 40
U R IR esolver interface, 153–154
U R L handlers, 416–419
configuration of, 404, 416–418
creating a H T T PS connection with, 418–419
dynamic configuration of, 404–405
JSSE and, 7
using in Web services, 440–442
U R L C onnection interface, 404
U R L C onnection object, 83
urlE ncode action, JST L core tag library, 175–176
U R L H andler interface, 418–419, 440, 441
urlhandler.jsp, 441, 442
U R Ls
connecting to using H T T Ps, 418–419
encoding of strings via JST L, 175–176
H T T P U R Ls, 7
U R L handlers and. See U R L handlers
U S-ASC II encoding, 32
U ser interface, 344
user names,Web service registries and, 393–394
user.home system property, 408
U T F-8 encoding, 32
V
ValueTypes (application classes), 310–311
verify( ) method, 414
void addM imeH eader( ) method, 218
void close( ) method, 266
void detachN ode( ) method, 211
void ejbR emove( ) method, 277
void recycleN ode( ) method, 211–212
void removeA llM imeH eaders( ) method, 219
void send( ) method, 266
void setC ontentL ocation( ) method, 219
void setM essageD rivenC ontent( ) method, 277
void setM imeH eader( ) method, 219
W
WAR  files, 7, 317, 320–321, 469–471
warning( ) method, 73, 118, 152
Web browsers, language selection in, 183–184
Web Service Definition Language documents.
SeeW SDL (Web Service Definition
Language)
Web service providers
C lassificationScheme interface for
categorization of, 342–343
N AIC S registry categories for by economic
activity, 335, 343
registry classification by geographical
location, 336
representation of registry by O rganiz ation
interface, 343–344
storage of metadata on in registries, 334–336
Web service registries, 334

500
Index
adding organizations with JW SDP classes,
372–381
adding organizations with R egistry Browser,
348–351, 462–467
categorization of businesses/ services, 335,
342–343
connecting to with connection( ), 345, 372
connecting to with D oconnect class, 345–347
deprecating and deleting records in, 386–393
ebX M L specification for, 339–342
queries, simple, 353–357, 363–364
querying based on classification, 357–363
querying with R egistry Browser, 351–352
representation of entities in by O rganiz ation
interface, 343–344
storage of service metadata in, 334–336
taxonomy for geographical services in, 336
U DDI specification for, 337–339
updating records in, 381–386
username and password protection of,
393–394
Web services, 342
cipher suites, displaying installied through,
442–443
client-server Web service, 443–447
creation of with JSSE, 437–447
evaluating connection protocols by hand, 334
JAX -R PC  API development and deployment
of, 304, 319–321
registries of. SeeWeb service registries
searching for in registries, 353–364
storing of session states, 259
U R L handlers and. See U R L handlers
Web Services Description Language. See
W SDL (Web Services Description
Language)
Web Services Developer Package R egistry. See
W SDP R egistry
web.xml deployment descriptor, 164, 167
when action, JST L tag library, 173, 197
whitespace characters, parsing of, 44–45, 68
World W ide Web C onsortium (W 3C ), 54
wrapper classes, JAX -R PC  support of, 307
W SDL (Web Service Definition Language)
description of Web services by, 5
W SDL (Web Services Description Language),
304, 305, 364–372
elements in W SDL documents, 365–368,
370–372
example W SDL document, 368–369
JAX -R PC  holder classes for, 312–313
operations supported by, 366, 367
W SDL file generation via xrpcc, 313–315
xrpcc command-line tool and, 313–317
W SDP. See Java Web Services Developer Pack
(JW SDP)
W SDP R egistry Browser, 462–467
adding organizations to classifications,
465–467
adding organizations to Default R egistry via,
348–351
launching, 347–348
querying Default R egister with, 351–352
registry selection with, 462–463
W SDP R egistry Server, 454
adding organization to default registry with,
348–351
configuration of, 462–467
installation of JW SDP and, 454, 455
messages not supported by, 461–462
querying default registry with, 351–352
setup of, 347–348
See also U DDI R egistry
X
X .509 standard, 406, 409
X alan X SL engine, 139
X erces, 30, 41–42, 77
x:forE ach action, JST L tag library, 196–197
X M L-based R PC, 304–313
conversion between Java classes and W SDL
and, 313–317
function call semantics and, 305
JAX -R PC  client and, 317–319, 325–327
JAX -R PC  server and, 319–324
sending messages with JAX -R PC, 306–307
stubs and ties in, 305–306
X M L data types, mapping, 308
X M L documents
comments in, 47, 68
debugging with SAX  L ocator mechanism,
37–38
DO M  hierarchy for, 60–62
DO M  interfaces for elements of, 57–60
DO M  trees for, 55–57
event-based parsing of, 14–15, 17–26
example servlet for parsing, 32–36
JAX P and. See JAX P (Java API for X M L
Processing)
JST L X M L tags for, 195–198

Index
501
parsing of for DO M  tree structure, 65–73
parsing of into a DO M  tree, 72–77
passing to parsers with SAX  InputSource class,
31–32
processing instructions in, 45
SAX  event handlers and, 18–26
SAX  events for, 17–18
tag element nodes, 56–57
transforming through X SLT, 124–128,
145–152
whitespace characters in, 44–45, 68
X Path and, 128–130
X M L JST L tags
conditional execution support by, 197–198
for iterating over X M L elements, 196–197
for parsing and searching, 195–196
translation of and X SLT, 198
X M L messaging, JAX M  and. See JAX M  (Java
API for X M L M essaging)
X M L namespaces. See namespaces, X M L
X M L-only SO AP messages, 208, 214–215
X M L parsers, 14, 15
callbacks and, 15
character encodings and, 32
C rimson, 30
development of SAX  standard for, 16–17
DO M  parsers. See DO M  parsers
error handling by, 45–47
event handlers and, 18–19
events and, 15
function of, 14
SAX  parsers. See SAX  parsers
tree-based, 14
X erces 1, 30, 41–42
X erces 2, 30, 41–42
X M L Schemas, 41–42
X M L Parser interface, 84–88
X M L R eader interface, 26–27, 28, 46, 115
X M L R eader.parser( ) method, 47
X M L String variable, DO M  parsing of, 75
X M O Parser.java servlet, 84–88
x:otherwise action, JST L tag library, 197–198
x:out action, JST L tag library, 196
x:parse action, JST L tag library, 195–196
X Path, 124, 128–130, 164, 195
xrpcc command-line tool, 305, 313–317
command line options, 314
packaging of services as WAR  files, 317,
320–321
R M I interface generation, 315–316
server configuration file generation, 316–317,
319–320
W SDL file generation, 313, 314–315
x:set action, JST L tag library, 196
X SL, 124
transforming X M L files through X SLT,
124–128
X Path and, 124
X SLFO  and, 124
X SLT  and, 124
X SL engines, 124, 139–140
X SL for Transformations. See X SLT
<xsl:apply-template> procedure, 131
<xsl:choose> procedure, 137
X SLFO, 124
<xsl:for-each> procedure, 132–134
<xsl:if> procedure, 134–137
<xsl:output> procedure, 138–139
<xsl:sort> procedure, 138
X SLT, 124–128
<xsl:apply-template> procedure, 131
<xsl:choose> procedure, 137
<xsl:for-each> procedure, 132–134
<xsl:if> procedure, 134–137
<xsl:output> procedure, 138–139
<xsl:sort> procedure, 138
<xsl:template> procedure, 130–131
<xsl:value-of> procedure, 138
<xsl:when> procedure, 137
creation of X SLT  transformation code for,
140–144
input and output processing in, 144–145
templates and, 149–152
transformers and, 145–149
X Path and, 128–130
<xsl:template> procedure, 130–131
<xsl:value-of> procedure, 138
<xsl:when> procedure, 137
x:transform action, JST L X M L Tag Library, 198
x:when action, JST L X M L Tag Library, 197

SYNGRESS SOLUTIONS…
s o l u t i o n s @ s y n g r e s s . c o m
AVAILABLE NOW!
ORDER at
www.syngress.com
AVAILABLE JULY 2002!
ORDER at
www.syngress.com
Hack Proofing XML
Hack Proofing XM L will allow W eb developers and database administrators to take
advantage of the limitless possibilities of XM L without sacrificing the integrity, confi-
dentiality, and security of their information. Readers will be given hands-on instruc-
tion on how to encrypt and authenticate their XM L data using prescribed
standards, digital signatures, and various vendors’ software.
ISBN : 1-931836-50-7
Price: $49.95 USA , $77.95 CA N
C# for Java Programmers
.N ET is M icrosoft’s answer to the J2EE platform for Enterprise W eb Services. It is
essential that developers know C# if they are to program for the .N ET platform. C#
for Java Programmers is not an introductory guide to C#, rather it builds on what
Java programmers already know about object-oriented languages to give them an
efficient means to master the .N ET framework. This book will compare and contrast
many of the advantages and drawbacks of Java and C#, allowing programmers to
make informed, intelligent decisions based on the unique uses of each language.
ISBN : 1-931836-54-X
Price: $49.95 USA , $77.95 CA N
AVAILABLE NOW!
ORDER at
www.syngress.com
Programming LEGO Mindstorms with Java
Programming LEG O  M indstorms with Java is as much about robotics programming as
it is about Java programming. This book is for all levels of M indstorms users, from
hobbyists to the serious M indstorms aficionados. This book is also appropriate for a
variety of programming levels; those with only a modicum of Java knowledge as well
as those at an advanced level will find much to learn within these pages. You will
cover all the basics of programming the RCX, beginning with the introduction of the
available Java A PIs used to communicate remotely to the RCX using its default firm-
ware, all the way through the advanced topics of embedded programming using a
custom Java Virtual M achine (JVM ).
ISBN : 1-928994-55-5
Price: $29.95 USA , $46.95 CA N


