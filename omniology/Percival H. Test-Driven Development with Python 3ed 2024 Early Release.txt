
Test-Driven Development with
Python
THIRD EDITION
Obey the Testing Goat: Using Django, Selenium, and JavaScript
With Early Release ebooks, you get books in their earliest form—the
author’s raw and unedited content as they write—so you can take advantage
of these technologies long before the official release of these titles.
Harry J.W. Percival

Test-Driven Development with
Python
by Harry J.W. Percival
Copyright © 2024 Harry Percival. All rights reserved.
Printed in the United States of America.
Published by O’Reilly Media, Inc., 1005 Gravenstein Highway
North, Sebastopol, CA 95472.
O’Reilly books may be purchased for educational, business, or
sales promotional use. Online editions are also available for
most titles (http://oreilly.com). For more information, contact
our corporate/institutional sales department: 800-998-9938 or
corporate@oreilly.com.
Acquisitions Editor: Brian Guerin
Development Editor: Rita Fernando
Production Editor: Christopher Faucher
Interior Designer: David Futato
Cover Designer: Karen Montgomery

June 2014: First Edition
August 2017: Second Edition
June 2025: Third Edition
Revision History for the Early
Release
2023-07-19: First Release
2023-10-20: Second Release
2024-03-12: Third Release
2024-05-16: Fourth Release
See http://oreilly.com/catalog/errata.csp?isbn=9781098148713 for
release details.
The O’Reilly logo is a registered trademark of O’Reilly Media,
Inc. Test-Driven Development with Python, the cover image, and
related trade dress are trademarks of O’Reilly Media, Inc.
While the publisher and the author have used good faith eﬀorts
to ensure that the information and instructions contained in
this work are accurate, the publisher and the author disclaim all
responsibility for errors or omissions, including without
limitation responsibility for damages resulting from the use of

or reliance on this work. Use of the information and
instructions contained in this work is at your own risk. If any
code samples or other technology this work contains or
describes is subject to open source licenses or the intellectual
property rights of others, it is your responsibility to ensure that
your use thereof complies with such licenses and/or rights.
978-1-098-14865-2
[LSI]

Brief Table of Contents (Not Yet
Final)
Preface (AVAILABLE)
Prerequisites and Assumptions (AVAILABLE)
Companion Video (AVAILABLE)
Acknowledgments (UNAVAILABLE)
Part 1: The Basics of TDD and Django (AVAILABLE)
Chapter 1: Getting Django Set Up Using a Functional Test
(AVAILABLE)
Chapter 2: Extending Our Functional Test Using the unittest
Module (AVAILABLE)
Chapter 3: Testing a Simple Home Page with Unit Tests
(AVAILABLE)
Chapter 4: What Are We Doing with All These Tests? (And,
Refactoring) (AVAILABLE)
Chapter 5: Saving User Input: Testing the Database (AVAILABLE)

Chapter 6: Improving Functional Tests: Ensuring Isolation and
Removing Voodoo Sleeps (AVAILABLE)
Chapter 7: Working Incrementally (AVAILABLE)
Part 2: Web Development Sine Qua Nons (AVAILABLE)
Chapter 8: Prettiﬁcation: Layout and Styling, and What to Test
About It (AVAILABLE)
Chapter 9: Deployment Part 1: Containerization akaDocker
(AVAILABLE)
Chapter 10: Getting to a Production-Ready Deployment
(AVAILABLE)
Chapter 11: Infrastructure As Code: Automated Deployments
With Ansible (AVAILABLE)
Chapter 12: Splitting Our Tests into Multiple Files, and a Generic
Wait Helper (UNAVAILABLE)
Chapter 13: Validation at the Database Layer (UNAVAILABLE)
Chapter 14: A Simple Form (UNAVAILABLE)
Chapter 15: More Advanced Forms (UNAVAILABLE)

Chapter 16: Dipping Our Toes, Very Tentatively, into JavaScript
(UNAVAILABLE)
Chapter 17: Deploying Our New Code (UNAVAILABLE)
Part 3: More Advanced Topics in Testing (UNAVAILABLE)
Chapter 18: User Authentication, Spiking, and De-Spiking
(UNAVAILABLE)
Chapter 19: Using Mocks to Test External Dependencies or Reduce
Duplication (UNAVAILABLE)
Chapter 20: Test Fixtures and a Decorator for Explicit Waits
(UNAVAILABLE)
Chapter 21: Server-Side Debugging (UNAVAILABLE)
Chapter 22: Finishing “My Lists”: Outside-In TDD
(UNAVAILABLE)
Chapter 23: Test Isolation, and “Listening to Your Tests”
(UNAVAILABLE)
Chapter 24: Continuous Integration (CI) (UNAVAILABLE)

Chapter 25: The Token Social Bit, the Page Pattern, and an
Exercise for the Reader (UNAVAILABLE)
Chapter 26: Fast Tests, Slow Tests, and Hot Lava (UNAVAILABLE)
Back Matter: Obey the Testing Goat! (UNAVAILABLE)
App A: PythonAnywhere (UNAVAILABLE)
App B: Django Class-Based Views (UNAVAILABLE)
App C: Provisioning with Ansible (UNAVAILABLE)
App D: Testing Database Migrations (UNAVAILABLE)
App E: Behaviour-Driven Development (BDD) (UNAVAILABLE)
App F: Building a REST API: JSON, Ajax, and Mocking with
JavaScript (UNAVAILABLE)
App G: Django-Rest-Framework (UNAVAILABLE)
App H: Cheat Sheet (UNAVAILABLE)
App I: What to Do Next (UNAVAILABLE)
App J: Source Code Examples (UNAVAILABLE)

Bibliography (UNAVAILABLE)

Preface
This book is my attempt to share with the world the journey I’ve
taken from “hacking” to “software engineering”. It’s mainly
about testing, but there’s a lot more to it, as you’ll soon see.
I want to thank you for reading it.
If you bought a copy, then I’m very grateful. If you’re reading
the free online version, then I’m still grateful that you’ve
decided it’s worth spending some of your time on. Who knows,
perhaps once you get to the end, you’ll decide it’s good enough
to buy a real copy for yourself or for a friend.
If you have any comments, questions, or suggestions, I’d love to
hear from you. You can reach me directly via
obeythetestinggoat@gmail.com, or on Mastodon + Twitter
@hjwp. You can also check out the website and my blog, and
there’s a mailing list.
I hope you’ll enjoy reading this book as much as I enjoyed
writing it.

THIRD EDITION EARLY RELEASE INFORMATION
If you can see this, you are reading an early release of the third
edition, either via www.obeythetestinggoat.com, or via the
O’Reilly Learning site. Congratulations!
At the time of writing, the whole of Part 1 of the book (the ﬁrst 7
chapters), and the bulk of Part 2 (chapter 8-14) have been
updated for the third edition. They’ve been upgraded to Python
3.12, Django 4, and the text up to chapter 12 has been
comprehensively reviewed.
Chapters 15 and above are still on Python 3.7 / Django 1.x.
If you’re following through the code examples in rest of the
book, you have two choices:
Muddle through and try and ﬁgure out how to translate the
example code to the new version of Django
Save all your work, and then use my book example repo to
reset your code to the canonical versions. This is probably the
low risk option, but more boring.
Thanks for reading, and please do send any and all feedback! At
this early release stage, feedback is more important than ever.
You can reach me via obeythetestinggoat@gmail.com

Why I Wrote a Book About Test-
Driven Development
`‘Who are you, why have you written this book, and why should I
read it?’' I hear you ask.
I was lucky enough, early on in my career, to fall in with a
bunch of TDD fanatics, and it made such a big impact on my
programming that I was burning to share it with everyone. You
might say I had the enthusiasm of a recent convert, and the
learning experience was still a recent memory for me, so that’s
what led to the ﬁrst edition, back in 2014.
When I ﬁrst learned Python (from Mark Pilgrim’s excellent Dive
Into Python), I came across the concept of TDD, and thought
“Yes. I can deﬁnitely see the sense in that.” Perhaps you had a
similar reaction when you ﬁrst heard about TDD? It sounds like
a really sensible approach, a really good habit to get into— like
regularly ﬂossing your teeth.
Then came my ﬁrst big project, and you can guess what
happened— there was a client, there were deadlines, there was
lots to do, and any good intentions about TDD went straight out
of the window.

And, actually, it was ﬁne. I was ﬁne.
At ﬁrst.
At ﬁrst I knew I didn’t really need TDD because it was a small
website, and I could easily test whether things worked by just
manually checking it out. Click this link here, choose that drop-
down item there, and this should happen. Easy. This whole
writing tests thing sounded like it would have taken ages, and
besides, I fancied myself, from the full height of my three weeks
of adult coding experience, as being a pretty good programmer.
I could handle it. Easy.
Then came the fearful goddess Complexity. She soon showed
me the limits of my experience.
The project grew. Parts of the system started to depend on other
parts. I did my best to follow good principles like DRY (Don’t
Repeat Yourself), but that just led to some pretty dangerous
territory. Soon I was playing with multiple inheritance. Class
hierarchies eight levels deep. eval  statements.
I became scared of making changes to my code. I was no longer
sure what depended on what, and what might happen if I
changed this code over here, oh gosh, I think that bit over there
inherits from it— no, it doesn’t, it’s overriden. Oh, but it depends

on that class variable. Right, well, as long as I override the
override it should be ﬁne. I’ll just check— but checking was
getting much harder. There were lots of sections to the site now,
and clicking through them all manually was starting to get
impractical. Better to leave well enough alone, forget
refactoring, just make do.
Soon I had a hideous, ugly mess of code. New development
became painful.
Not too long after this, I was lucky enough to get a job with a
company called Resolver Systems (now PythonAnywhere),
where Extreme Programming (XP) was the norm. They
introduced me to rigorous TDD.
Although my previous experience had certainly opened my
mind to the possible beneﬁts of automated testing, I still
dragged my feet at every stage. “I mean, testing in general might
be a good idea, but really? All these tests? Some of them seem
like a total waste of time… What? Functional tests as well as unit
tests? Come on, that’s overdoing it! And this TDD test/minimal-
code-change/test cycle? This is just silly! We don’t need all these
baby steps! Come on, we can see what the right answer is, why
don’t we just skip to the end?”

Believe me, I second-guessed every rule, I suggested every
shortcut, I demanded justiﬁcations for every seemingly
pointless aspect of TDD, and I came out seeing the wisdom of it
all. I’ve lost count of the number of times I’ve thought “Thanks,
tests”, as a functional test uncovers a regression we would
never have predicted, or a unit test saves me from making a
really silly logic error. Psychologically, it’s made development a
much less stressful process. It produces code that’s a pleasure to
work with.
So, let me tell you all about it!
Aims of This Book
My main aim is to impart a methodology— a way of doing web
development, which I think makes for better web apps and
happier developers. There’s not much point in a book that just
covers material you could ﬁnd by Googling, so this book isn’t a
guide to Python syntax, or a tutorial on web development per
se. Instead, I hope to teach you how to use TDD to get more
reliably to our shared, holy goal: clean code that works.
With that said: I will constantly refer to a real practical example,
by building a web app from scratch using tools like Django,

Selenium, jQuery, and Mocks. I’m not assuming any prior
knowledge of any of these, so you should come out of the other
end of this book with a decent introduction to those tools, as
well as the discipline of TDD.
In Extreme Programming we always pair-program, so I’ve
imagined writing this book as if I was pairing with my previous
self, having to explain how the tools work and answer
questions about why we code in this particular way. So, if I ever
take a bit of a patronising tone, it’s because I’m not all that
smart, and I have to be very patient with myself. And if I ever
sound defensive, it’s because I’m the kind of annoying person
that systematically disagrees with whatever anyone else says, so
sometimes it takes a lot of justifying to convince myself of
anything.
Outline
I’ve split this book into three parts.
Part I (Chapters 1–7): The basics
Dives straight into building a simple web app using TDD. We
start by writing a functional test (with Selenium), and then
we go through the basics of Django— models, views,

templates— with rigorous unit testing at every stage. I also
introduce the Testing Goat.
Part II (Chapters 8–[Link to Come]): Web development
essentials
Covers some of the trickier but unavoidable aspects of web
development, and shows how testing can help us with them:
static ﬁles, deployment to production, form data validation,
database migrations, and the dreaded JavaScript.
[Link to Come] (Chapters [Link to Come]–[Link to Come]): More
advanced testing topics
Mocking, integrating a third-party system, test ﬁxtures,
Outside-In TDD, and Continuous Integration (CI).
On to a little housekeeping… 
Conventions Used in This Book
The following typographical conventions are used in this book:
Italic
Indicates new terms, URLs, email addresses, ﬁlenames, and
ﬁle extensions.
Constant width

Used for program listings, as well as within paragraphs to
refer to program elements such as variable or function
names, databases, data types, environment variables,
statements, and keywords.
Constant width bold
Shows commands or other text that should be typed literally
by the user.
Occasionally I will use the symbol:
[...]
to signify that some of the content has been skipped, to shorten
long bits of output, or to skip down to a relevant section.
TIP
This element signiﬁes a tip or suggestion.
NOTE
This element signiﬁes a general note or aside.

WARNING
This element indicates a warning or caution.
Submitting Errata
Spotted a mistake or a typo? The sources for this book are
available on GitHub, and I’m always very happy to receive
issues and pull requests: https://github.com/hjwp/Book-TDD-Web-
Dev-Python/.
Using Code Examples
Code examples are available at https://github.com/hjwp/book-
example/; you’ll ﬁnd branches for each chapter there (e.g.,
https://github.com/hjwp/book-
example/tree/chapter_03_unit_test_ﬁrst_view). You’ll ﬁnd a full
list, and some suggestions on ways of working with this
repository, in [Link to Come].
This book is here to help you get your job done. In general, if
example code is oﬀered with this book, you may use it in your
programs and documentation. You do not need to contact us for
permission unless you’re reproducing a signiﬁcant portion of

the code. For example, writing a program that uses several
chunks of code from this book does not require permission.
Selling or distributing examples from O’Reilly books does
require permission. Answering a question by citing this book
and quoting example code does not require permission.
Incorporating a signiﬁcant amount of example code from this
book into your product’s documentation does require
permission.
We appreciate, but do not require, attribution. An attribution
usually includes the title, author, publisher, and ISBN. For
example: “Test-Driven Development with Python, 3rd edition, by
Harry J.W. Percival (O’Reilly). Copyright 2024 Harry Percival,
978-1-098-14871-3.”
If you feel your use of code examples falls outside fair use or the
permission given above, feel free to contact us at
permissions@oreilly.com.
O’Reilly Online Learning
NOTE
For more than 40 years, O’Reilly Media has provided technology and business
training, knowledge, and insight to help companies succeed.

Our unique network of experts and innovators share their
knowledge and expertise through books, articles, and our
online learning platform. O’Reilly’s online learning platform
gives you on-demand access to live training courses, in-depth
learning paths, interactive coding environments, and a vast
collection of text and video from O’Reilly and 200+ other
publishers. For more information, visit https://oreilly.com.
How to Contact Us
Please address comments and questions concerning this book
to the publisher:
O’Reilly Media, Inc.
1005 Gravenstein Highway North
Sebastopol, CA 95472
800-889-8969 (in the United States or Canada)
707-829-7019 (international or local)
707-829-0104 (fax)
support@oreilly.com
https://www.oreilly.com/about/contact.html

We have a web page for this book, where we list errata,
examples, and any additional information. You can access this
page at
https://learning.oreilly.com/library/view/~/9781098148706.
For news and information about our books and courses, visit
https://oreilly.com.
Find us on LinkedIn: https://linkedin.com/company/oreilly-media
Follow us on Twitter: https://twitter.com/oreillymedia
Watch us on YouTube: https://youtube.com/oreillymedia
License for the free edition
If you’re reading the free edition of this book hosted at
http://www.obeythetestinggoat.com, then the license is Creative
Commons Attribution-NonCommercial-NoDerivatives . I want
to thank O’Reilly for their fantastic attitude towards licensing,
most publishers aren’t so forward-thinking.
I see this as a “try-before-you-buy” scheme really. If you’re
reading this book it’s for professional reasons, so I hope that if
you like it, you’ll buy a copy— if not for yourself, then for a
1

friend! O’Reilly have been great, they deserve your support.
You’ll ﬁnd links to buy back on the homepage.
 (The no-derivs clause is there because O’Reilly want to
maintain some control over derivative works, but they often do
grant permissions for things, so don’t hesitate to get in touch if
you want to build something based on this book.)
1

Prerequisites and Assumptions
Here’s an outline of what I’m assuming about you and what you
already know, as well as what software you’ll need ready and
installed on your computer.
Python 3 and Programming
I’ve tried to write this book with beginners in mind, but if you’re
new to programming, I’m assuming that you’ve already learned
the basics of Python. So if you haven’t already, do run through a
Python beginner’s tutorial or get an introductory book like The
Quick Python Book or Think Python, or, just for fun, Invent Your
Own Computer Games with Python, all of which are excellent
introductions.
If you’re an experienced programmer but new to Python, you
should get along just ﬁne. Python is joyously simple to
understand.
You should be able to follow this book on Mac, Windows, or
Linux. Detailed installation instructions for each OS follow.

TIP
This book was tested against Python 3.12. If you’re on an earlier version, you will
ﬁnd minor diﬀerences in the way things look in my command output listings
(tracebacks won’t have the ^^^^^^  carets marking error locations for example) so
you’re best oﬀ upgrading, ideally, if you can.
If you are thinking of using PythonAnywhere rather than a
locally installed Python, you should go and take a quick look at
[Link to Come] before you get started.
In any case, I expect you to have access to Python, to know how
to launch it from a command line, and to know how to edit a
Python ﬁle and run it. Again, have a look at the three books I
recommended previously if you’re in any doubt.
How HTML Works
I’m also assuming you have a basic grasp of how the web works
— what HTML is, what a POST request is, and so on. If you’re not
sure about those, you’ll need to ﬁnd a basic HTML tutorial;
there are a few at http://www.webplatform.org/. If you can ﬁgure
out how to create an HTML page on your PC and look at it in
your browser, and understand what a form is and how it might
work, then you’re probably OK.

Django
The book uses the Django framework, which is (probably) the
most well-established web framework in the Python world. I’ve
written the book assuming that the reader has no prior
knowledge of Django, but if you’re new to Python and new to
web development and new to testing, you may occasionally ﬁnd
that there’s just one too many topics and sets of concepts to try
and take on board. If that’s the case, I recommend taking a
break from the book, and taking a look at a Django tutorial.
DjangoGirls is the best, most beginner-friendly tutorial I know
of. The oﬃcial tutorial is also excellent for more experienced
programmers.
JavaScript
There’s a little bit of JavaScript in the second half of the book. If
you don’t know JavaScript, don’t worry about it until then, and
if you ﬁnd yourself a little confused, I’ll recommend a couple of
guides at that point.
Read on for installation instructions.

Required Software Installations
Aside from Python, you’ll need:
The Firefox web browser
Selenium can actually drive any of the major browsers, but I
chose Firefox because it’s the least in hock to corporate
interests.
The Git version control system
This is available for any platform, at http://git-scm.com/. On
Windows, it comes with the Bash command line, which is
needed for the book. See “Windows Notes”.
A virtualenv with Python 3.12, Django 4.2, and Selenium 4 in it
Python’s virtualenv and pip tools now come bundled with
Python (they didn’t always used to, so this is a big hooray).
Detailed instructions for preparing your virtualenv follow.

WINDOWS NOTES
Windows users can sometimes feel a little neglected in the open
source world, since MacOS and Linux are so prevalent, making
it easy to forget there’s a world outside the Unix paradigm.
Backslashes as directory separators? Drive letters? What? Still, it

is absolutely possible to follow along with this book on
Windows. Here are a few tips:
1. When you install Git for Windows, it will include “Git Bash”.
Use this as your main command prompt throughout the
book, and you’ll get all the useful GNU command-line tools
like ls , touch , and grep , plus forward-slash directory
separators.
2. During the Git installation, you’ll get the option to choose the
default editor used by Git. Unless you’re already a Vim user
(or are desperate to learn), I’d suggest using a more familiar
editor, even just Notepad! See Figure P-1.
3. Also in the Git installer, choose “Use Windows’ default
console”; otherwise, Python won’t work properly in the Git-
Bash window.
4. When you install Python, tick the option that says “Add
python.exe to PATH” as in Figure P-2, so that you can easily
run Python from the command line.


FIGURE P-1. CHOOSE A NICE DEFAULT EDITOR FOR GIT
FIGURE P-2. ADD PYTHON TO THE SYSTEM PATH FROM THE INSTALLER
The test for all this is that you should be able to go to a Git-Bash
command prompt and just run python  or pip  from any folder.

MACOS NOTES
MacOS installations for Python and Git are relatively
straightforward:
Python 3.12 should install without a fuss from its
downloadable installer. It will automatically install pip , too.
Git’s installer should also “just work”.
Similarly to Windows, the test for all this is that you should be
able to open a terminal and just run git , python3 , or pip
from anywhere. If you run into any trouble, the search terms
“system path” and “command not found” should provide good
troubleshooting resources.
TIP
You might also want to check out Homebrew. It’s a fairly reliable way of
installing common Unixy tools on a Mac.  Although the normal Python
installer is now ﬁne, you may ﬁnd Homebrew useful in future. It does
require you to download all 1.1 GB of Xcode, but that also gives you a C
compiler, which is a useful side eﬀect.
1

LINUX NOTES
If you’re on Linux, I’m assuming you’re already a glutton for
punishment, so you don’t need detailed installation
instructions. But in brief, if Python 3.12 isn’t available directly
from your package manager,
On Ubuntu you can install the Deadsnakes PPA. Make sure
you apt install python3.12-venv  as well as just
python3.12  to un-break the default Debian version of
Python.
Alternatively, pyenv is a tool that lets you manage multiple
Python versions on the same machine, but it is one more
thing to have to learn and remember.
Alternatively, compiling Python from source is actually
surprisingly easy!
However you install it, make sure you can run Python 3.12 from
a terminal.
Installing Firefox
Firefox is available as a download for Windows and MacOS
from https://www.mozilla.org/ﬁrefox/. On Linux, you probably

already have it installed, but otherwise your package manager
will have it.
Make sure you have the latest version, so that the
“geckodriver” browser automation module is available.
Setting Up Your Virtualenv
A Python virtualenv (short for virtual environment) is how you
set up your environment for diﬀerent Python projects. It allows
you to use diﬀerent packages (e.g., diﬀerent versions of Django,
and even diﬀerent versions of Python) in each project. And
because you’re not installing things system-wide, it means you
don’t need root permissions.
Let’s create a virtualenv. I’m assuming you’re working in a
folder called goat-book, but you can name your work folder
whatever you like. Stick to the name “.venv” for the virtualenv,
though.
$ cd goat-book 
$ py -3.12 -m venv .venv

On Windows, the py  executable is a shortcut for diﬀerent
Python versions. On Mac or Linux, we use python3.12 :
$ cd goat-book 
$ python3.12 -m venv .venv
Activating and Deactivating the Virtualenv
Whenever you’re working through the book, you’ll want to
make sure your virtualenv has been “activated”. You can
always tell when your virtualenv is active because you’ll see
(.venv)  in parentheses, in your prompt. But you can also
check by running which python  to check whether Python is
currently the system-installed one, or the virtualenv one.
The command to activate the virtualenv is source
.venv/Scripts/activate  on Windows and source
.venv/bin/activate  on Mac/Linux. The command to
deactivate is just deactivate .
Try it out like this:
$ source .venv/Scripts/activate 
(.venv)$ 
(.venv)$ which python 
/C/Users/harry/goat-book/.venv/Scripts/python 

$ source .venv/bin/activate 
(.venv)$ 
(.venv)$ which python 
/home/myusername/goat-book/.venv/bin/python 
(.venv)$ deactivate 
$ 
$ which python 
/usr/bin/python
TIP
Always make sure your virtualenv is active when working on the book. Look out for
the (.venv)  in your prompt, or run which python  to check.
y g
p
py
(.venv)$ deactivate 
$ 
$ which python 
/c/Users/harry/AppData/Local/Programs/Python/Python31

VIRTUALENVS AND IDES
If you’re using an IDE like Pycharm or Visual Studio Code, you
should be able to conﬁgure them to use the virtualenv as the
default Python interpreter for the project.
You should then be able to launch a terminal inside the IDE
with the virtualenv already activated.

ACTIVATE NOT WORKING ON WINDOWS?
If you see an error like this:
First, double-check you’re in the right folder. Assuming you are,
or if you see an error like this:
Then you’ve probably run into a old bug where Python
wouldn’t install an activate script that was compatible with Git-
Bash. Reinstall the latest Python 3, then delete and re-create
your virtualenv.
Installing Django and Selenium
We’ll install Django 4.2 and the latest Selenium . Remember to
make sure your virtualenv is active ﬁrst!
bash: .venv/Scripts/activate: No such file or directo
bash: @echo: command not found 
bash: .venv/Scripts/activate.bat: line 4: 
      syntax error near unexpected token `( 
bash: .venv/Scripts/activate.bat: line 4: `if not def
( venv) $ pip install "django<4 3" "selenium"
2

Checking it works:
this should pop open a Firefox web browser, which you’ll then
need to close.
TIP
If you see an error, you’ll need to debug it before you go further. On Linux/Ubuntu,
I ran into this bug which you need to ﬁx by setting an environment variable called
TMPDIR .
(.venv) $ pip install "django<4.3" "selenium" 
Collecting django<4.3 
  Downloading Django-4.2.7-py3-none-any.whl (8.0 MB) 
     ---------------------------------------- 8.1/8.1
Collecting selenium 
  Downloading selenium-4.15.0-py3-none-any.whl (6.5 M
     ---------------------------------------- 6.5/6.5
Installing collected packages: django, selenium 
Successfully installed [...] django-4.2.7 [...] selen
(.venv) $ python -c "from selenium import webdrive

WARNING, DJANGO 4 UPGRADE IN PROGRESS!
If you’re reading this message, then you’re currently reading a
preview version of the third edition of TDDwP. I’m currently
working on upgrading the book to Python 3.12 and Django 4.x.
At the time of writing, this was completed up to the end of Part 1
/ Chapter 7, but parts 2 and 3, ie chapters 8 and up, are still on
Django 1.11.
Some Error Messages You’re Likely to See
When You Inevitably Fail to Activate Your
Virtualenv
If you’re new to virtualenvs— or even if you’re not, to be honest
— at some point you’re guaranteed to forget to activate it, and
then you’ll be staring at an error message. Happens to me all
the time. Here are some of the things to look out for:
ModuleNotFoundError: No module named 'selenium'
Or:
ImportError: No module named django.core.management

As always, look out for that (.venv)  in your command prompt,
and a quick source .venv/Scripts/activate  or source
.venv/bin/activate  is probably what you need to get it
working again.
Here’s a couple more, for good measure:
This means you’re not currently in the right directory for
working on the project. Try a cd goat-book , or similar.
Alternatively, if you’re sure you’re in the right place, you may
have run into a bug from an older version of Python, where it
wouldn’t install an activate script that was compatible with Git-
Bash. Reinstall Python 3, and make sure you have version 3.6.3
or later, and then delete and re-create your virtualenv.
If you see something like this, it’s probably the same issue, you
need to upgrade Python:
bash: .venv/Scripts/activate: No such file or directo
bash: @echo: command not found 
bash: .venv/Scripts/activate.bat: line 4: 
      syntax error near unexpected token `( 
bash:
venv/Scripts/activate bat: line 4: `if not def

Final one! If you see this:
It’s because you’ve launched the default Windows command
prompt, cmd , instead of Git-Bash. Close it and open the latter.
ON ANACONDA
Anaconda is another tool for managing diﬀerent Python
environments. It’s particularly popular on Windows and for
scientiﬁc computing, where it can be hard to get some of the
compiled libraries to install.
In the world of web programming it’s much less necessary, so I
recommend you do not use Anaconda for this book.
Apart from anything else I don’t know enough about it to help
you debug any problems with it if they occur!
Happy coding!
bash: .venv/Scripts/activate.bat: line 4: if not def
'source' is not recognized as an internal or external
operable program or batch file.

NOTE
Did these instructions not work for you? Or have you got better ones? Get in touch:
obeythetestinggoat@gmail.com!
 I wouldn’t recommend installing Firefox via Homebrew
though: brew  puts the Firefox binary in a strange location, and
it confuses Selenium. You can work around it, but it’s simpler to
just install Firefox in the normal way.
 You might be wondering why I’m not mentioning a speciﬁc
version of Selenium. It’s because Selenium is constantly being
updated to keep up with changes in web browsers, and since we
can’t really pin our browser to a speciﬁc version, we’re best oﬀ
using the latest Selenium. It was version 4.9 at the time of
writing.
1
2

Companion Video
I’ve recorded a 10-part video series to accompany this book.  It
covers the content of Part I. If you ﬁnd you learn well from
video-based material, then I encourage you to check it out. Over
and above what’s in the book, it should give you a feel for what
the “ﬂow” of TDD is like, ﬂicking between tests and code,
explaining the thought process as we go.
Plus I’m wearing a delightful yellow T-shirt.
1


 The video has not been updated for the third edition, but
the content is all mostly the same.
1

Part I. The Basics of TDD and
Django
In this ﬁrst part, I’m going to introduce the basics of Test-Driven
Development (TDD). We’ll build a real web application from
scratch, writing tests ﬁrst at every stage.
We’ll cover functional testing with Selenium, as well as unit
testing, and see the diﬀerence between the two. I’ll introduce
the TDD workﬂow, Red/Green/Refactor.
I’ll also be using a version control system (Git). We’ll discuss
how and when to do commits and integrate them with the TDD
and web development workﬂow.
We’ll be using Django, the Python world’s most popular web
framework (probably). I’ve tried to introduce the Django
concepts slowly and one at a time, and provide lots of links to
further reading. If you’re a total beginner to Django, I
thoroughly recommend taking the time to read them. If you
ﬁnd yourself feeling a bit lost, take a couple of hours to go
through the oﬃcial Django tutorial and then come back to the
book.

In Part 1 you’ll also get to meet the Testing Goat… 
BE CAREFUL W ITH COPY AND PASTE
If you’re working from a digital version of the book, it’s natural to want to copy and
paste code listings from the book as you’re working through it. It’s much better if
you don’t: typing things in by hand gets them into your muscle memory, and just
feels much more real. You also inevitably make the occasional typo, and debugging
them is an important thing to learn.
Quite apart from that, you’ll ﬁnd that the quirks of the PDF format mean that weird
stuﬀ often happens when you try to copy/paste from it… 

Chapter 1. Getting Django Set Up
Using a Functional Test
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 1st chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
TDD isn’t something that comes naturally. It’s a discipline, like a
martial art, and just like in a Kung Fu movie, you need a bad-
tempered and unreasonable master to force you to learn the
discipline. Ours is the Testing Goat.

Obey the Testing Goat! Do Nothing
Until You Have a Test
The Testing Goat is the unoﬃcial mascot  of TDD in the Python
testing community. It probably means diﬀerent things to
diﬀerent people, but, to me, the Testing Goat is a voice inside my
head that keeps me on the True Path of Testing— like one of
those little angels or demons that pop up above your shoulder
in the cartoons, but with a very niche set of concerns. I hope,
with this book, to install the Testing Goat inside your head too.
So we’ve decided to build a web app, even if we’re not quite
sure what it’s going to do yet. Normally the ﬁrst step in web
development is getting your web framework installed and
conﬁgured. Download this, install that, conﬁgure the other, run
the script… but TDD requires a diﬀerent mindset. When you’re
doing TDD, you always have the Testing Goat inside your head
— single-minded as goats are— bleating “Test ﬁrst, test ﬁrst!”
In TDD the ﬁrst step is always the same: write a test.
First we write the test; then we run it and check that it fails as
expected. Only then do we go ahead and build some of our app.
Repeat that to yourself in a goat-like voice. I know I do.
1

Another thing about goats is that they take one step at a time.
That’s why they seldom fall oﬀ things, see, no matter how steep
they are. As you can see in Figure 1-1.

Figure 1-1. Goats are more agile than you think (source: Caitlin Stewart, on Flickr)
We’ll proceed with nice small steps; we’re going to use Django,
which is a popular Python web framework, to build our app.

The ﬁrst thing we want to do is check that we’ve got Django
installed and that it’s ready for us to work with. The way we’ll
check is by conﬁrming that we can spin up Django’s
development server and actually see it serving up a web page,
in our web browser, on our local computer. We’ll use the
Selenium browser automation tool for this.
Create a new Python ﬁle called functional_tests.py, wherever
you want to keep the code for your project, and enter the
following code. If you feel like making a few little goat noises as
you do it, it may help:
functional_tests.py
from selenium import webdriver 
 
browser = webdriver.Firefox()
browser.get("http://localhost:8000") 
 
assert "Congratulations!" in browser.title
print("OK")
That’s our ﬁrst functional test (FT); I’ll talk more about what I
mean by functional tests, and how they contrast with unit tests,
in a bit. For now, it’s enough to assure ourselves that we
understand what it’s doing:

Starting a Selenium “webdriver” to pop up a real Firefox
browser window.
Using it to open up a web page which we’re expecting to be
served from the local computer.
Checking (making a test assertion) that the page has the word
“Congratulations!” in its title.
If all goes well we print OK.
Let’s try running it:
$ python functional_tests.py 
Traceback (most recent call last): 
  File "...goat-book/functional_tests.py", line 4, in
    browser.get("http://localhost:8000") 
  File ".../selenium/webdriver/remote/webdriver.py", 
    self.execute(Command.GET, {"url": url}) 
  File ".../selenium/webdriver/remote/webdriver.py", 
    self.error_handler.check_response(response) 
  File ".../selenium/webdriver/remote/errorhandler.py
check_response 
    raise exception_class(message, screen, stacktrace
selenium.common.exceptions.WebDriverException: Messag
ut:neterror?e=connectionFailure&u=http%3A//localhost%
Stacktrace: 
RemoteError@chrome://remote/content/shared/RemoteErro
WebDriverError@chrome://remote/content/shared/webdriv

You should see a browser window pop up and try to open
localhost:8000, and show the “Unable to connect” error page. If
you switch back to your console, you’ll see the big ugly error
message, telling us that Selenium hit an error page. And then,
you will probably be irritated at the fact that it left the Firefox
window lying around your desktop for you to tidy up. We’ll ﬁx
that later!
NOTE
If, instead, you see an error trying to import Selenium, or an error trying to ﬁnd
something called “geckodriver”, you might need to go back and have another look at
the "Prerequisites and Assumptions" section.
For now though, we have a failing test, so that means we’re
allowed to start building our app.
UnknownError@chrome://remote/content/shared/webdriver
[...]

ADIEU TO ROMAN NUMERALS!
So many introductions to TDD use Roman numerals as an
example that it has become a running joke— I even started
writing one myself. If you’re curious, you can ﬁnd it on my
GitHub page.
Roman numerals, as an example, are both good and bad. It’s a
nice “toy” problem, reasonably limited in scope, and you can
explain the core of TDD quite well with it.
The problem is that it can be hard to relate to the real world.
That’s why I’ve decided to use building a real web app, starting
from nothing, as my example. Although it’s a simple web app,
my hope is that it will be easier for you to carry across to your
next real project.
Getting Django Up and Running
Since you’ve deﬁnitely read “Prerequisites and Assumptions” by
now, you’ve already got Django installed (right?). The ﬁrst step
in getting Django up and running is to create a project, which
will be the main container for our site. Django provides a little
command-line tool for this:

$ django-admin startproject superlists .
Don’t forget that “.” at the end; it’s important!
That will create a ﬁle called manage.py in your current folder,
and a subfolder called superlists, with more stuﬀ inside it:
. 
├── functional_tests.py 
├── manage.py 
└── superlists 
    ├── __init__.py 
    ├── asgi.py 
    ├── settings.py 
    ├── urls.py 
    └── wsgi.py
NOTE
Make sure your project folder looks exactly like this! If you see two nested folders
called superlists, it’s because you forgot the “.” above. Delete them and try again, or
there will be lots of confusion with paths and working directories.
The superlists folder is intended for stuﬀ that applies to the
whole project— like settings.py, for example, which is used to
store global conﬁguration information for the site.

But the main thing to notice is manage.py. That’s Django’s Swiss
Army knife, and one of the things it can do is run a
development server. Let’s try that now:
That’s Django’s development server now up and running on our
machine.
NOTE
It’s safe to ignore that message about “unapplied migrations” for now. We’ll look at
migrations in Chapter 5.
$ python manage.py runserver 
Watching for file changes with StatReloader 
Performing system checks... 
 
System check identified no issues (0 silenced). 
 
You have 18 unapplied migration(s). Your project may 
you apply the migrations for app(s): admin, auth, con
Run 'python manage.py migrate' to apply them. 
March 17, 2023 - 18:07:30 
Django version 4.2, using settings 'superlists.settin
Starting development server at http://127.0.0.1:800
Quit the server with CONTROL-C.

Leave it there and open another command shell. Navigate to
your project folder, activate your virtualenv, and then try
running our test again:
$ python functional_tests.py 
OK
Not much action on the command line, but you should notice
two things: ﬁrstly, there was no ugly AssertionError  and
secondly, the Firefox window that Selenium popped up had a
diﬀerent-looking page on it.
TIP
If you see an error saying “no module named selenium”, you’ve forgotten to activate
your virtualenv. Check the Prerequisites and Assumptions section again if you need
to.
Well, it may not look like much, but that was our ﬁrst ever
passing test! Hooray!
If it all feels a bit too much like magic, like it wasn’t quite real,
why not go and take a look at the dev server manually, by
opening a web browser yourself and visiting
http://localhost:8000? You should see something like Figure 1-2.

You can quit the development server now if you like, back in
the original shell, using Ctrl-C.


Figure 1-2. It worked!
Starting a Git Repository
There’s one last thing to do before we ﬁnish the chapter: start to
commit our work to a version control system (VCS). If you’re an
experienced programmer you don’t need to hear me preaching
about version control, but if you’re new to it please believe me
when I say that VCS is a must-have. As soon as your project gets
to be more than a few weeks old and a few lines of code, having
a tool available to look back over old versions of code, revert
changes, explore new ideas safely, even just as a backup… It’s
hard to overstate how useful that is. TDD goes hand in hand
with version control, so I want to make sure I impart how it ﬁts
into the workﬂow.
So, our ﬁrst commit! If anything it’s a bit late; shame on us.
We’re using Git as our VCS, ’cos it’s the best.
Let’s start by doing the git init  to start the repository:
$ ls 
db.sqlite3  functional_tests.py  manage.py  superlist
 
$ git init . 
Initialised empty Git repository in
goat book/ git

OUR WORKING DIRECTORY IS ALWAYS THE FOLDER THAT CONTAINS
MANAGE.PY
We’ll be using this same folder throughout the book as our
working directory— if in doubt, it’s the one that contains
manage.py.
(For simplicity, in my command listings, I’ll always show it as … 
goat-book/, although it will probably actually be something like
/home/kind-reader-username/my-python-projects/goat-book/.)
Whenever I show a command to type in, it will assume we’re in
this directory. Similarly, if I mention a path to a ﬁle, it will be
relative to this directory. So for example, superlists/settings.py
means the settings.py inside the superlists folder.
Now let’s take a look and see what ﬁles we want to commit:
Initialised empty Git repository in ...goat-book/.git
$ ls 
db.sqlite3 functional_tests.py manage.py superlists

There are a few things in here that we don’t want under version
control: db.sqlite3 is the database ﬁle, and our virtualenv
shouldn’t be in git either. We’ll add all of them to a special ﬁle
called .gitignore which, um, tells Git what to ignore:
$ echo "db.sqlite3" >> .gitignore 
$ echo ".venv" >> .gitignore
Next we can add the rest of the contents of the current folder,
“.”:
$ git add . 
$ git status 
On branch main 
 
No commits yet 
 
Changes to be committed: 
  (use "git rm --cached <file>..." to unstage) 
 
        new file:   .gitignore 
        new file:   functional_tests.py 
        new file:   manage.py 
        new file:   superlists/__init__.py 
        new file:   superlists/__pycache__/__init__.c
        new file:   superlists/__pycache__/settings.c
fil
li
/
h
/
l
h

Oops! We’ve got a bunch of .pyc ﬁles in there; it’s pointless to
commit those. Let’s remove them from Git and add them to
.gitignore too:
Now let’s see where we are… 
        new file:   superlists/__pycache__/urls.cpyth
        new file:   superlists/__pycache__/wsgi.cpyth
        new file:   superlists/asgi.py 
        new file:   superlists/settings.py 
        new file:   superlists/urls.py 
        new file:   superlists/wsgi.py
$ git rm -r --cached superlists/__pycache__ 
rm 'superlists/__pycache__/__init__.cpython-312.pyc' 
rm 'superlists/__pycache__/settings.cpython-312.pyc' 
rm 'superlists/__pycache__/urls.cpython-312.pyc' 
rm 'superlists/__pycache__/wsgi.cpython-312.pyc' 
$ echo "__pycache__" >> .gitignore 
$ echo "*.pyc" >> .gitignore
$ git status 
On branch main 
 
i i l
i

TIP
You’ll see I’m using git status  a lot— so much so that I often alias it to git st … 
I’m not telling you how to do that though; I leave you to discover the secrets of Git
aliases on your own!
Looking good— we’re ready to do our ﬁrst commit!
Initial commit 
 
Changes to be committed: 
  (use "git rm --cached <file>..." to unstage) 
 
        new file:   .gitignore 
        new file:   functional_tests.py 
        new file:   manage.py 
        new file:   superlists/__init__.py 
        new file:   superlists/asgi.py 
        new file:   superlists/settings.py 
        new file:   superlists/urls.py 
        new file:   superlists/wsgi.py 
 
Changes not staged for commit: 
  (use "git add <file>..." to update what will be com
  (use "git restore <file>..." to discard changes in 
 
        modified:   .gitignore

$ git add .gitignore 
$ git commit
When you type git commit , it will pop up an editor window for
you to write your commit message in. Mine looked like
Figure 1-3.
Figure 1-3. First Git commit
2

NOTE
If you want to really go to town on Git, this is the time to also learn about how to
push your work to a cloud-based VCS hosting service like GitHub or GitLab. They’ll
be useful if you think you want to follow along with this book on diﬀerent
computers. I leave it to you to ﬁnd out how they work; they have excellent
documentation. Alternatively, you can wait until Chapter 9 when we’ll be using one
for deployment.
That’s it for the VCS lecture. Congratulations! You’ve written a
functional test using Selenium, and you’ve gotten Django
installed and running, in a certiﬁable, test-ﬁrst, goat-approved
TDD way. Give yourself a well-deserved pat on the back before
moving on to Chapter 2.
 OK more of a minor running joke from Pycon in the mid
’10s, which I am single-handedly trying to make into a Thing.
 Did a strange terminal-based editor (the dreaded vim) pop
up and you had no idea what to do? Or did you see a message
about account identity and git config --global
user.username ? Check out the Git manual and its basic
conﬁguration section. PS - to quit vim, it’s Esc, then :q!
1
2

Chapter 2. Extending Our
Functional Test Using the unittest
Module
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 2nd chapter of the ﬁnal book. The GitHub repo
is available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
Let’s adapt our test, which currently checks for the default
Django “it worked” page, and check instead for some of the
things we want to see on the real front page of our site.

Time to reveal what kind of web app we’re building: a to-do lists
site! I know, I know, every other web dev tutorial online is also
a to-do lists app, or maybe a blog or a polls app. I’m very much
following fashion.
The reason is that a to-do list is a really nice example. At its most
basic it is very simple indeed— just a list of text strings— so it’s
easy to get a “minimum viable” list app up and running. But it
can be extended in all sorts of ways— diﬀerent persistence
models, adding deadlines, reminders, sharing with other users,
and improving the client-side UI. There’s no reason to be limited
to just “to-do” lists either; they could be any kind of lists. But the
point is that it should allow me to demonstrate all of the main
aspects of web programming, and how you apply TDD to them.
Using a Functional Test to Scope
Out a Minimum Viable App
Tests that use Selenium let us drive a real web browser, so they
really let us see how the application functions from the user’s
point of view. That’s why they’re called functional tests.
This means that an FT can be a sort of speciﬁcation for your
application. It tends to track what you might call a User Story,

and follows how the user might work with a particular feature
and how the app should respond to them.
TERMINOLOGY: 
FUNCTIONAL TEST == ACCEPTANCE TEST == END-TO-END TEST
What I call functional tests, some people prefer to call
acceptance tests, or end-to-end tests. The main point is that these
kinds of tests look at how the whole application functions, from
the outside. Another names are black box test or closed box test
because the test doesn’t know anything about the internals of
the system under test.
FTs should have a human-readable story that we can follow. We
make it explicit using comments that accompany the test code.
When creating a new FT, we can write the comments ﬁrst, to
capture the key points of the User Story. Being human-readable,
you could even share them with nonprogrammers, as a way of
discussing the requirements and features of your app.
TDD and agile or lean software development methodologies
often go together, and one of the things we often talk about is
the minimum viable app; what is the simplest thing we can
build that is still useful? Let’s start by building that, so that we
can test the water as quickly as possible.

A minimum viable to-do list really only needs to let the user
enter some to-do items, and remember them for their next visit.
Open up functional_tests.py and write a story a bit like this one:
functional_tests.py (ch02l001)
from selenium import webdriver 
 
browser = webdriver.Firefox() 
 
# Edith has heard about a cool new online to-do app.
# She goes to check out its homepage
browser.get("http://localhost:8000") 
 
# She notices the page title and header mention to-do
assert "To-Do" in browser.title 
 
# She is invited to enter a to-do item straight away 
 
# She types "Buy peacock feathers" into a text box
# (Edith's hobby is tying fly-fishing lures) 
 
# When she hits enter, the page updates, and now the 
# "1: Buy peacock feathers" as an item in a to-do lis
 
# There is still a text box inviting her to add anoth
# She enters "Use peacock feathers to make a fly" (Ed

 
# The page updates again, and now shows both items on
 
# Satisfied, she goes back to sleep 
 
browser.quit()

WE HAVE A WORD FOR COMMENTS… 
When I ﬁrst started at PythonAnywhere, I used to virtuously
pepper my code with nice descriptive comments. My colleagues
said to me: “Harry, we have a word for comments. We call them
lies.” I was shocked! I learned in school that comments are good
practice?
They were exaggerating for eﬀect. There is deﬁnitely a place for
comments that add context and intention. But my colleagues
were pointing out that comments aren’t always as useful as you
hope. For starters, it’s pointless to write a comment that just
repeats what you’re doing with the code:
# increment wibble by 1
wibble += 1
Not only is it pointless, but there’s a danger that you’ll forget to
update the comments when you update the code, and they end
up being misleading— lies! The ideal is to strive to make your
code so readable, to use such good variable names and function
names, and to structure it so well that you no longer need any
comments to explain what the code is doing. Just a few here and
there to explain why.

There are other places where comments are very useful. We’ll
see that Django uses them a lot in the ﬁles it generates for us to
use as a way of suggesting helpful bits of its API.
And, of course, we use comments to explain the User Story in
our functional tests— by forcing us to make a coherent story out
of the test, it makes sure we’re always testing from the point of
view of the user.
There is more fun to be had in this area, things like Behaviour-
Driven Development (see [Link to Come]) and building Domain-
Speciﬁc Languages (DSLs) for testing, but they’re topics for
other booksfootnote: Check out this video by the great Dave
Farley if you want a taste: https://youtu.be/JDD5EEJgpHU?t=272 ].
For more on comments, I recommend John Ousterhoudt’s A
Philosophy of Software Design, which you can get a taste of by
reading his lecture notes from the chapter on comments.
You’ll notice that, apart from writing the test out as comments,
I’ve updated the assert  to look for the word “To-Do” instead of
Django’s “Congratulations”. That means we expect the test to
fail now. Let’s try running it.
First, start up the server:

$ python manage.py runserver
And then, in another terminal, run the tests:
That’s what we call an expected fail, which is actually good news
— not quite as good as a test that passes, but at least it’s failing
for the right reason; we can have some conﬁdence we’ve
written the test correctly.
The Python Standard Library’s
unittest Module
There are a couple of little annoyances we should probably deal
with. Firstly, the message “AssertionError” isn’t very helpful— it
would be nice if the test told us what it actually found as the
browser title. Also, it’s left a Firefox window hanging around the
$ python functional_tests.py 
Traceback (most recent call last): 
  File "...goat-book/functional_tests.py", line 10, i
    assert "To-Do" in browser.title 
AssertionError

desktop, so it would be nice if that got cleared up for us
automatically.
One option would be to use the second parameter of the
assert  keyword, something like:
And we could also use a try/finally  to clean up the old
Firefox window.
But these sorts of problems are quite common in testing, and
there are some ready-made solutions for us in the standard
library’s unittest  module. Let’s use that! In functional_tests.py:
functional_tests.py (ch02l003)
assert "To-Do" in browser.title, f"Browser title was 
import unittest
from selenium import webdriver
class NewVisitorTest(unittest.TestCase):  
    def setUp(self):  
        self.browser = webdriver.Firefox()  
    def tearDown(self):  

You’ll probably notice a few things here:
Tests are organised into classes, which inherit from
unittest.TestCase .
The main body of the test is in a method called
test_can_start_a_todo_list . Any method whose name
        self.browser.quit()
    def test_can_start_a_todo_list(self):  
        # Edith has heard about a cool new online to-
        # She goes to check out its homepage
        self.browser.get("http://localhost:8000")  
        # She notices the page title and header menti
        self.assertIn("To-Do", self.browser.title)  
        # She is invited to enter a to-do item straig
        self.fail("Finish the test!")  
        [...]
        # Satisfied, she goes back to sleep
if __name__ == "__main__":  
    unittest.main()  

starts with test_  is a test method, and will be run by the test
runner. You can have more than one test_  method per
class. Nice descriptive names for our test methods are a good
idea too.
setUp  and tearDown  are special methods which get run
before and after each test. I’m using them to start and stop
our browser. They’re a bit like a try/finally , in that
tearDown  will run even if there’s an error during the test
itself.  No more Firefox windows left lying around!
browser , which was previously a global variable, becomes
self.browser , an attribute of the test class. This lets us pass
it between setUp , tearDown , and the test method itself.
We use self.assertIn  instead of just assert  to make our
test assertions. unittest  provides lots of helper functions
like this to make test assertions, like assertEqual ,
assertTrue , assertFalse , and so on. You can ﬁnd more in
the unittest  documentation.
self.fail  just fails no matter what, producing the error
message given. I’m using it as a reminder to ﬁnish the test.
Finally, we have the if __name__ == '__main__'  clause (if
you’ve not seen it before, that’s how a Python script checks if
it’s been executed from the command line, rather than just
imported by another script). We call unittest.main() ,
which launches the unittest  test runner, which will
1

automatically ﬁnd test classes and methods in the ﬁle and
run them.
NOTE
If you’ve read the Django testing documentation, you might have seen something
called LiveServerTestCase , and are wondering whether we should use it now. Full
points to you for reading the friendly manual! LiveServerTestCase  is a bit too
complicated for now, but I promise I’ll use it in a later chapter.
Let’s try out our new and improved FT!
$ python functional_tests.py 
F 
=====================================================
FAIL: test_can_start_a_todo_list 
(__main__.NewVisitorTest.test_can_start_a_todo_list) 
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests.py", line 18, i
test_can_start_a_todo_list 
    self.assertIn("To-Do", self.browser.title) 
AssertionError: 'To-Do' not found in 'The install wor
Congratulations!' 
 
 ----------------------------------------------------
Ran 1 test in 1.747s 
 
2

That’s a bit nicer, isn’t it? It tidied up our Firefox window, it
gives us a nicely formatted report of how many tests were run
and how many failed, and the assertIn  has given us a helpful
error message with useful debugging info. Bonzer!
NOTE
If you see some error messages saying ResourceWarning  about “unclosed ﬁles”, it’s
safe to ignore those. They seem to come and go, every few selenium releases. They
don’t aﬀect the important things to look for in our tracebacks and test results.
FAILED (failures=1)

PYTEST VS UNITTEST
The Python world is increasingly turning from the standard-
library provided unittest  module towards a third party tool
called pytest . I’m a big fan too!
The Django project has a bunch of helpful tools designed to
work with unittest. Although it is possible to get them to work
with pytest, it felt like one thing too many to include in this
book.
Read Brian Okken’s Python Testing with pytest for an excellent,
comprehensive guide to Pytest instead.
Commit
This is a good point to do a commit; it’s a nicely self-contained
change. We’ve expanded our functional test to include
comments that describe the task we’re setting ourselves, our
minimum viable to-do list. We’ve also rewritten it to use the
Python unittest  module and its various testing helper
functions.
Do a git status —that should assure you that the only ﬁle that
has changed is functional_tests.py. Then do a git diff -w ,

which shows you the diﬀerence between the last commit and
what’s currently on disk, with the -w  saying “ignore whitespace
changes”.
That should tell you that functional_tests.py has changed quite
substantially:
$ git diff -w 
diff --git a/functional_tests.py b/functional_tests.p
index d333591..b0f22dc 100644 
--- a/functional_tests.py 
+++ b/functional_tests.py 
@@ -1,15 +1,24 @@ 
+import unittest 
 from selenium import webdriver 
 
-browser = webdriver.Firefox() 
 
+class NewVisitorTest(unittest.TestCase): 
+    def setUp(self): 
+        self.browser = webdriver.Firefox() 
+ 
+    def tearDown(self): 
+        self.browser.quit() 
+ 
+    def test_can_start_a_todo_list(self): 
         # Edith has heard about a cool new online to

Now let’s do a:
$ git commit -a
The -a  means “automatically add any changes to tracked ﬁles”
(i.e., any ﬁles that we’ve committed before). It won’t add any
brand new ﬁles (you have to explicitly git add  them yourself),
but often, as in this case, there aren’t any new ﬁles, so it’s a
useful shortcut.
When the editor pops up, add a descriptive commit message,
like “First FT specced out in comments, and now uses unittest.”
         # She goes to check out its homepage 
-browser.get("http://localhost:8000") 
+        self.browser.get("http://localhost:8000") 
 
         # She notices the page title and header ment
-assert "To-Do" in browser.title 
+        self.assertIn("To-Do", self.browser.title) 
 
         # She is invited to enter a to-do item strai
+        self.fail("Finish the test!") 
 
[...]

Now that our FT uses a real test framework, and that we’ve got
placeholder comments for what we want it to do, we’re in an
excellent position to start writing some real code for our lists
app. Read on!
USEFUL TDD CONCEPTS
User Story
A description of how the application will work from the point
of view of the user. Used to structure a functional test.
Expected failure
When a test fails in the way that we expected it to.
 The only exception is if you have an exception inside
setUp , then tearDown  doesn’t run.
 Are you unable to move on because you’re wondering
what those ch02l00x things are, next to some of the code
listings? They refer to speciﬁc commits in the book’s example
repo. It’s all to do with my book’s own tests. You know, the tests
for the tests in the book about testing. They have tests of their
own, naturally.
1
2

Chapter 3. Testing a Simple Home
Page with Unit Tests
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 3rd chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
We ﬁnished the last chapter with a functional test failing, telling
us that it wanted the home page for our site to have “To-Do” in
its title. It’s time to start working on our application. In this
chapter, we’ll build our ﬁrst HTML page, ﬁnd out about URL
handling, and creating responses to HTTP requests with
Django’s view functions.


WARNING: THINGS ARE ABOUT TO GET REAL
The ﬁrst two chapters were intentionally nice and light. From
now on, we get into some more meaty coding. Here’s a
prediction: at some point, things are going to go wrong. You’re
going to see diﬀerent results from what I say you should see.
This is a Good Thing, because it will be a genuine character-
building Learning Experience™.
One possibility is that I’ve given some ambiguous explanations,
and you’ve done something diﬀerent from what I intended. Step
back and have a think about what we’re trying to achieve at this
point in the book. Which ﬁle are we editing, what do we want
the user to be able to do, what are we testing and why? It may
be that you’ve edited the wrong ﬁle or function, or are running
the wrong tests. I reckon you’ll learn more about TDD from
these “stop and think” moments than you do from all the times
when following instructions and copy-pasting goes smoothly.
Or it may be a real bug. Be tenacious, read the error message
carefully (see “Reading Tracebacks” a little later on in the
chapter), and you’ll get to the bottom of it. It’s probably just a
missing comma, or trailing slash, or maybe a missing s in one of
the Selenium ﬁnd methods. But, as Zed Shaw memorably
insisted in Learn Python The Hard Way, this kind of debugging
is also an absolutely vital part of learning, so do stick it out!

You can always drop me an email (or try the Google Group) if
you get really stuck. Happy debugging!
Our First Django App, and Our First
Unit Test
Django encourages you to structure your code into apps: the
theory is that one project can have many apps, you can use
third-party apps developed by other people, and you might even
reuse one of your own apps in a diﬀerent project… although I
admit I’ve never actually managed it myself! Still, apps are a
good way to keep your code organised.
Let’s start an app for our to-do lists:
$ python manage.py startapp lists
That will create a folder called lists, next to manage.py and the
existing superlists folder, and within it a number of placeholder
ﬁles for things like models, views, and, of immediate interest to
us, tests:

. 
├── db.sqlite3 
├── functional_tests.py 
├── lists 
│   ├── __init__.py 
│   ├── admin.py 
│   ├── apps.py 
│   ├── migrations 
│   │   └── __init__.py 
│   ├── models.py 
│   ├── tests.py 
│   └── views.py 
├── manage.py 
└── superlists 
    ├── __init__.py 
    ├── asgi.py 
    ├── settings.py 
    ├── urls.py 
    └── wsgi.py
Unit Tests, and How They Diﬀer
from Functional Tests
As with so many of the labels we put on things, the line between
unit tests and functional tests can become a little blurry at

times. The basic distinction, though, is that functional tests test
the application from the outside, from the user’s point of view.
Unit tests test the application from the inside, from the
programmer’s point of view.
The TDD approach I’m demonstrating uses both types of test to
drive the development of our application, and ensure its
correctness. Our workﬂow will look a bit like this:
1. We start by writing a functional test, describing a typical
example of our new functionality from the user’s point of
view.
2. Once we have a functional test that fails, we start to think
about how to write code that can get it to pass (or at least to
get past its current failure). We now use one or more unit
tests to deﬁne how we want our code to behave— the idea is
that each line of production code we write should be tested
by (at least) one of our unit tests.
3. Once we have a failing unit test, we write the smallest
amount of application code we can, just enough to get the
unit test to pass. We may iterate between steps 2 and 3 a few
times, until we think the functional test will get a little
further.
4. Now we can rerun our functional tests and see if they pass, or
get a little further. That may prompt us to write some new

unit tests, and some new code, and so on.
5. Once we’re comfortable that the core functionality works
end-to-end, we can extend out to cover more permutations
and edge cases, using just unit tests now.
You can see that, all the way through, the functional tests are
driving what development we do from a high level, while the
unit tests drive what we do at a low level.
The functional tests don’t aim to cover every single tiny detail of
our app’s behaviour, they are there to reassure us that
everything is wired up correctly. The unit tests are there to
exhaustively check all the lower level details and corner cases.
NOTE
Functional tests should help you build an application that actually works, and
guarantee you never accidentally break it. Unit tests should help you to write code
that’s clean and bug free.
Enough theory for now—let’s see how it looks in practice.

Table 3-1. FTs vs Unit Tests
FTs
Unit Tests
One test per feature / user story
Many tests per
feature
Test from the user’s point of
view
Test the code, ie the
programmer’s point
of view
Can test that the UI “really”
works
Tests the internals,
individual functions
or classes
Provides conﬁdence that
everything is wired together
correctly, works end-to-end
Can exhaustively
check permutations,
details, edge cases
Unit Testing in Django
Let’s see how to write a unit test for our home page view. Open
up the new ﬁle at lists/tests.py, and you’ll see something like

this:
lists/tests.py
from django.test import TestCase 
 
# Create your tests here.
Django has helpfully suggested we use a special version of
TestCase , which it provides. It’s an augmented version of the
standard unittest.TestCase , with some additional Django-
speciﬁc features, which we’ll discover over the next few
chapters.
You’ve already seen that the TDD cycle involves starting with a
test that fails, then writing code to get it to pass. Well, before we
can even get that far, we want to know that the unit test we’re
writing will deﬁnitely be run by our automated test runner,
whatever it is. In the case of functional_tests.py, we’re running it
directly, but this ﬁle made by Django is a bit more like magic. So,
just to make sure, let’s make a deliberately silly failing test:
lists/tests.py (ch03l002)
from django.test import TestCase 
 

 
class SmokeTest(TestCase): 
    def test_bad_maths(self): 
        self.assertEqual(1 + 1, 3)
Now let’s invoke this mysterious Django test runner. As usual,
it’s a manage.py command:
$ python manage.py test 
Creating test database for alias 'default'... 
Found 1 test(s). 
System check identified no issues (0 silenced). 
F 
=====================================================
FAIL: test_bad_maths (lists.tests.SmokeTest.test_bad_
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/lists/tests.py", line 6, in test
    self.assertEqual(1 + 1, 3) 
AssertionError: 2 != 3 
 
 ----------------------------------------------------
Ran 1 test in 0.001s 
 
FAILED (failures=1) 
Destroying test database for alias 'default'...

Excellent. The machinery seems to be working. This is a good
point for a commit:
As you’ve no doubt guessed, the -m  ﬂag lets you pass in a
commit message at the command line, so you don’t need to use
an editor. It’s up to you to pick the way you like to use the Git
command line; I’ll just show you the main ones I’ve seen used.
For me the main big of VCS hygiene is: make sure you always
review what you’re about to commit before you do it.
Django’s MVC, URLs, and View
Functions
Django is structured along a classic Model-View-Controller
(MVC) pattern. Well, broadly. It deﬁnitely does have models, but
what Django calls views are really controllers, and the view part
is actually provided by the templates, but you can see the
general idea is there!
$ git status  # should show you lists/ is untracked 
$ git add lists 
$ git diff --staged  # will show you the diff that y
$ git commit -m "Add app for lists, with delibera

If you’re interested, you can look up the ﬁner points of the
discussion in the Django FAQs.
Irrespective of any of that, as with any web server, Django’s
main job is to decide what to do when a user asks for a
particular URL on our site. Django’s workﬂow goes something
like this:
1. An HTTP request comes in for a particular URL.
2. Django uses some rules to decide which view function should
deal with the request (this is referred to as resolving the URL).
3. The view function processes the request and returns an HTTP
response.
So, we want to test two things:
Can we make this view function return the HTML we need?
Can we tell Django to use this view function when we make a
request for the root of the site (“/”)?
Let’s start with the ﬁrst.
Unit Testing a View

Open up lists/tests.py, and change our silly test to something like
this:
lists/tests.py (ch03l003)
What’s going on in this new test? Well, remember, a view
function takes an HTTP request as input, and produces an HTTP
response. So, to test that:
We import the HttpRequest  class so that we can then create
a request object within our test. This is the kind of object that
Django will create when a user’s browser asks for a page.
from django.test import TestCase
from django.http import HttpRequest  
from lists.views import home_page
class HomePageTest(TestCase):
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()  
        response = home_page(request)  
        html = response.content.decode("utf8")  
        self.assertIn("<title>To-Do lists</title>", h
        self.assertTrue(html.startswith("<html>"))  
        self.assertTrue(html.endswith("</html>"))  

We pass the HttpRequest  object to our home_page  view,
which gives us a response. You won’t be surprised to hear
that the response is an instance of a class called
HttpResponse .
Then, we extract the .content  of the response. These are
the raw bytes, the ones and zeros that would be sent down
the wire to the user’s browser. We call .decode()  to convert
them into the string of HTML that’s being sent to the user.
Now we can make some assertions: we know we want an
html <title>  tag somewhere in there, with the words “To-
Do lists” in it— because that’s what we speciﬁed in our
functional test.
And we can do a vague sanity check that it’s valid html, by
checking that it starts with an <html>  tag which gets closed
at the end.
So, what do you think will happen when we run the tests?
$ python manage.py test 
Found 1 test(s). 
System check identified no issues (0 silenced). 
E 
=====================================================
ERROR: lists.tests (unittest.loader._FailedTest.lists
 ----------------------------------------------------
ImportError: Failed to import test module: lists.test

It’s a very predictable and uninteresting error: we tried to
import something we haven’t even written yet. But it’s still good
news— for the purposes of TDD, an exception which was
predicted counts as an expected failure. Since we have both a
failing functional test and a failing unit test, we have the Testing
Goat’s full blessing to code away.
At Last! We Actually Write Some
Application Code!
It is exciting, isn’t it? Be warned, TDD means that long periods of
anticipation are only defused very gradually, and by tiny
increments. Especially since we’re learning and only just
starting out, we only allow ourselves to change (or add) one line
of code at a time— and each time, we make just the minimal
change required to address the current test failure.
I’m being deliberately extreme here, but what’s our current test
failure? We can’t import home_page  from lists.views ? OK,
Traceback (most recent call last): 
[...] 
  File "...goat-book/lists/tests.py", line 3, in <mod
    from lists.views import home_page 
ImportError: cannot import name 'home_page' from 'lis

let’s ﬁx that— and only that. In lists/views.py:
lists/views.py (ch03l004)
from django.shortcuts import render 
 
# Create your views here.
home_page = None
“You must be joking!” I can hear you say.
I can hear you because it’s what I used to say (with feeling)
when my colleagues ﬁrst demonstrated TDD to me. Well, bear
with me, and we’ll talk about whether or not this is all taking it
too far in a little while. But for now, let yourself follow along,
even if it’s with some exasperation, and see if our tests can help
us write the correct code, one tiny step at a time.
Let’s run the tests again:
[...] 
  File "...goat-book/lists/tests.py", line 9, in 
test_home_page_returns_correct_html 
    response = home_page(request) 
               ^^^^^^^^^^^^^^^^^^ 
TypeError: 'NoneType' object is not callable

We still get an error, but it’s moved on a bit. Instead of an
import error, our tests are telling us that our home_page
“function” is not callable. That gives us a justiﬁcation for
changing it from being None  to being an actual function. At the
very smallest level of detail, every single code change can be
driven by the tests!
Back in lists/views.py:
lists/views.py (ch03l005)
from django.shortcuts import render 
 
 
def home_page(): 
    pass
Again, we’re making the smallest, dumbest change we can
possibly make, that addresses precisely the current test failure.
Our tests wanted something callable, so we gave them the
simplest possible callable thing, a function that takes no
arguments and returns nothing.
Let’s run the tests again and see what they think:
    response = home_page(request) 

Once more, our error message has changed slightly, and is
guiding us towards ﬁxing the next thing that’s wrong.
The Unit-Test/Code Cycle
We can start to settle into the TDD unit-test/code cycle now:
1. In the terminal, run the unit tests and see how they fail.
2. In the editor, make a minimal code change to address the
current test failure.
And repeat!
The more nervous we are about getting our code right, the
smaller and more minimal we make each code change— the
idea is to be absolutely sure that each bit of code is justiﬁed by a
test.
This may seem laborious, and at ﬁrst, it will be. But once you get
into the swing of things, you’ll ﬁnd yourself coding quickly even
if you take microscopic steps— this is how we write all of our
production code at work.
               ^^^^^^^^^^^^^^^^^^ 
TypeError: home_page() takes 0 positional arguments b

Let’s see how fast we can get this cycle going:
Minimal code change:
lists/views.py (ch03l006)
def home_page(request): 
    pass
Tests:
Code— we use django.http.HttpResponse , as predicted:
lists/views.py (ch03l007)
from django.http import HttpResponse 
 
 
def home_page(request): 
    return HttpResponse()
Tests again:
    html = response.content.decode("utf8") 
           ^^^^^^^^^^^^^^^^ 
AttributeError: 'NoneType' object has no attribute 

Code again:
lists/views.py (ch03l008)
Tests yet again:
    self.assertTrue(html.startswith("<html>")) 
AssertionError: False is not true
Code yet again:
lists/views.py (ch03l009)
Tests— almost there?
    self.assertTrue(html.endswith("</html>")) 
AssertionError: False is not true
AssertionError: '<title>To-Do lists</title>' not fo
def home_page(request): 
    return HttpResponse("<title>To-Do lists</title>
def home_page(request): 
    return HttpResponse("<html><title>To-Do lists</

Come on, one last eﬀort:
lists/views.py (ch03l010)
Surely?
Hooray! Our ﬁrst ever unit test pass! That’s so momentous that I
think it’s worthy of a commit:
def home_page(request): 
    return HttpResponse("<html><title>To-Do lists</
$ python manage.py test 
Creating test database for alias 'default'... 
Found 1 test(s). 
System check identified no issues (0 silenced). 
. 
 --------------------------------------------------
Ran 1 test in 0.001s 
 
OK 
Destroying test database for alias 'default'...
$ git diff  # should show changes to tests.py, and v
$ git commit -am "First unit test and view functi

That was the last variation on git commit  I’ll show, the a  and
m  ﬂags together, which adds all changes to tracked ﬁles and
uses the commit message from the command line.
WARNING
git commit -am  is the quickest formulation, but also gives you the least feedback
about what’s being committed, so make sure you’ve done a git status  and a git
diff  beforehand, and are clear on what changes are about to go in.
Our functional tests tell us we’re
not quite done yet.
We’ve got our unit test passing, so let’s go back to running our
functional tests to see if we’ve made progress. Don’t forget to
spin up the dev server again, if it’s not still running.
$ python functional_tests.py 
F 
=====================================================
FAIL: test_can_start_a_todo_list 
(__main__.NewVisitorTest.test_can_start_a_todo_list) 
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests.py", line 18, i

Looks like something isn’t quite right. This is the reason we
have functional tests!
Do you remember at the beginning of the chapter, we said we
needed to do two things, ﬁrstly create a view function to
produce responses for requests, and secondly tell the server
which functions should respond to which URLs? Thanks to our
FT, we have been reminded that we still need to do the second
thing.
How can we write a test for URL resolution? At the moment we
just test the view function directly by importing it and calling it.
But we want to test more layers of the Django stack. Django, like
most web frameworks, supplies a tool for doing just that, called
the Django Test Client.
test_can_start_a_todo_list 
    self.assertIn("To-Do", self.browser.title) 
AssertionError: 'To-Do' not found in 'The install wor
Congratulations!' 
 
 ----------------------------------------------------
Ran 1 test in 1.609s 
 
FAILED (failures=1)

Let’s see how to use it by adding a second, alternative test to our
unit tests:
lists/tests.py (ch03l011)
We can access the tests client via self.client , which is
available on any test that uses django.test.TestCase . It
provides methods like .get()  which simulate a browser
making http requests, and take a URL as their ﬁrst parameter.
We use this instead of manually creating a request object and
calling the view function directly
Django also provides some assertion helpers like
assertContains  that save us from having to manually
class HomePageTest(TestCase):
    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        html = response.content.decode("utf8")
        self.assertIn("<title>To-Do lists</title>", h
        self.assertTrue(html.startswith("<html>"))
        self.assertTrue(html.endswith("</html>"))
    def test_home_page_returns_correct_html_2(self):
        response = self.client.get("/")  
        self.assertContains(response, "<title>To-Do l

extract and decode response content, and have some other
nice properties besides, as we’ll see.
Let’s see how that works:
$ python manage.py test 
Found 2 test(s). 
Creating test database for alias 'default'... 
System check identified no issues (0 silenced). 
.F 
=====================================================
FAIL: test_home_page_returns_correct_html_2 
(lists.tests.HomePageTest.test_home_page_returns_corr
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/lists/tests.py", line 17, in 
test_home_page_returns_correct_html_2 
    self.assertContains(response, "<title>To-Do lists
[...] 
AssertionError: 404 != 200 : Couldn't retrieve conten
(expected 200) 
 
 ----------------------------------------------------
Ran 2 tests in 0.004s 
 
FAILED (failures=1) 
Destroying test database for alias 'default'...

Hmm, something about 404s? Let’s dig into it.
Reading Tracebacks
Let’s spend a moment talking about how to read tracebacks,
since it’s something we have to do a lot in TDD. You soon learn
to scan through them and pick up relevant clues:
=====================================================
FAIL: test_home_page_returns_correct_html_2   
(lists.tests.HomePageTest.test_home_page_returns_corr
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/lists/tests.py", line 17, in 
test_home_page_returns_correct_html_2 
    self.assertContains(response, "<title>To-Do lists
  File ".../django/test/testcases.py", line 647, in a
    text_repr, real_count, msg_prefix = self._assert_
                                        ^^^^^^^^^^^^^
  File ".../django/test/testcases.py", line 610, in _
    self.assertEqual( 
AssertionError: 404 != 200 : Couldn't retrieve conten
(expected 200) 
 
 ----------------------------------------------------

The ﬁrst place you look is usually the error itself. Sometimes
that’s all you need to see, and it will let you identify the
problem immediately. But sometimes, like in this case, it’s not
quite self-evident.
The next thing to double-check is: which test is failing? Is it
deﬁnitely the one we expected— that is, the one we just
wrote? In this case, the answer is yes.
Then we look for the place in our test code that kicked oﬀ the
failure. We work our way down from the top of the
traceback, looking for the ﬁlename of the tests ﬁle, to check
which test function, and what line of code, the failure is
coming from. In this case it’s the line where we call the
assertContains  method.
In Python 3.11 and later, you can also look out for the string
of carets, which try to tell you exactly where the exception
came from. This is more useful for unexpected exceptions
than for assertion failures like we have now.
There is ordinarily a ﬁfth step, where we look further down for
any of our own application code which was involved with the
problem. In this case it’s all Django code, but we’ll see plenty of
examples of this ﬁfth step later in the book.
[...]

Pulling it all together, we interpret the traceback as telling us
that, when we tried to do our assertion on the content of the
response, Django’s test helpers failed saying that they could not
do that, because the response is an HTML 404 “Not Found” error
instead of a normal 200 OK response.
In other words, Django isn’t yet conﬁgured to respond to
requests for the root URL (“/”) of our site. Let’s make that
happen now.
urls.py
Django uses a ﬁle called urls.py to map URLs to view functions.
This mapping is also called routing. There’s a main urls.py for
the whole site in the superlists folder. Let’s go take a look:
superlists/urls.py
"""
URL configuration for superlists project. 
 
The `urlpatterns` list routes URLs to views. For more
    https://docs.djangoproject.com/en/4.2/topics/http
Examples:
Function views
    1. Add an import:  from my_app import views

WARNING
If your urls.py looks diﬀerent or if it mentions a function called url()  instead of
path() , it’s because you’ve got the wrong version of Django. This book is written
for Django v4. Take another look at the Prerequisites and Assumptions section and
get the right version before you go any further.
As usual, lots of helpful comments and default suggestions from
Django. In fact, that very ﬁrst example is pretty much exactly
what we want! Let’s use that, with some minor changes.
superlists/urls.py (ch03l012)
    2. Add a URL to urlpatterns:  path('', views.home
Class-based views
    1. Add an import:  from other_app.views import Ho
    2. Add a URL to urlpatterns:  path('', Home.as_vi
Including another URLconf
    1. Import the include() function: from django.url
    2. Add a URL to urlpatterns:  path('blog/', inclu
"""
from django.contrib import admin
from django.urls import path 
 
urlpatterns = [ 
    path("admin/", admin.site.urls),
]

from django.urls import path  
from lists.views import home_page  
urlpatterns = [
    path("", home_page, name="home"),  
]
No need to import admin  from django.contrib . Django’s
admin site is amazing, but it’s a topic for another book.
But we will import our home page view function.
And we wire it up here, as a path()  entry in the
urlpatterns  global. Django strips the leading slash from all
urls, so "/url/path/to"  becomes "url/path/to"  and the
base URL is just the empty string, "" . So this conﬁg says, the
“base url should point to our home page view”
Now we can run our unit tests again, with python manage.py
test :
[...] 
.. 
 ----------------------------------------------------
Ran 2 tests in 0.003s 
 
OK

Hooray!
Time for a little tidy-up. We don’t need two separate tests, let’s
move everything out of our low-level test that calls the view
function directly, into the test that uses the Django test client:
lists/tests.py (ch03l013)
class HomePageTest(TestCase): 
    def test_home_page_returns_correct_html(self): 
        response = self.client.get("/") 
        self.assertContains(response, "<title>To-Do l
        self.assertContains(response, "<html>") 
        self.assertContains(response, "</html>")

WHY DIDN’T WE JUST USE THE DJANGO TEST CLIENT ALL ALONG?
You may be asking yourself, “Why didn’t we just use the Django
Test Client from the very beginning?” In real life, that’s what I
would do. But I wanted to show you the “manual” way of doing
it ﬁrst for a couple of reasons. Firstly because it allowed me to
introduce concepts one by one, and keep the learning curve as
shallow as possible. Secondly, because you may not always be
using Django to build your apps, and testing tools may not
always be available— but calling functions directly and
examining their responses is always possible!
The Django Test Client does also have disadvantages; later in
the book (in [Link to Come]) we’ll discuss the diﬀerence
between fully isolated unit tests and the “integrated” tests that
the test client pushes us towards. But for now, it’s very much
the pragmatic choice.
But now the moment of truth, will our functional tests pass?
$ python functional_tests.py 
[...] 
=====================================================
FAIL: test_can_start_a_todo_list 
(__main__.NewVisitorTest.test_can_start_a_todo_list) 
----------------------------------------------------

Failed? What? Oh, it’s just our little reminder? Yes? Yes! We have
a web page!
Ahem. Well, I thought it was a thrilling end to the chapter. You
may still be a little baﬄed, perhaps keen to hear a justiﬁcation
for all these tests, and don’t worry, all that will come, but I hope
you felt just a tinge of excitement near the end there.
Just a little commit to calm down, and reﬂect on what we’ve
covered:
That was quite a chapter! Why not try typing git log , possibly
using the --oneline  ﬂag, for a reminder of what we got up to:
 
Traceback (most recent call last): 
  File "...goat-book/functional_tests.py", line 21, i
test_can_start_a_todo_list 
    self.fail("Finish the test!") 
AssertionError: Finish the test!
$ git diff  # should show our modified test in tests
$ git commit -am "url config, map / to home_page 

Not bad— we covered:
Starting a Django app
The Django unit test runner
The diﬀerence between functional-, and unit tests
Django view functions, request and response objects
Django URL resolving and urls.py
The Django Test Client
And returning basic HTML from a view.
$ git log --oneline 
a6e6cc9 url config, map / to home_page view 
450c0f3 First unit test and view function 
ea2b037 Add app for lists, with deliberately failing 
[...]

USEFUL COMMANDS AND CONCEPTS
Running the Django dev server
python manage.py runserver
Running the functional tests
python functional_tests.py
Running the unit tests
python manage.py test
The unit-test/code cycle
1. Run the unit tests in the terminal.
2. Make a minimal code change in the editor.
3. Repeat!

Chapter 4. What Are We Doing with
All These Tests? (And, Refactoring)
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 4th chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
Now that we’ve seen the basics of TDD in action, it’s time to
pause and talk about why we’re doing it.
I’m imagining several of you, dear readers, have been holding
back some seething frustration— perhaps some of you have

done a bit of unit testing before, and perhaps some of you are
just in a hurry. You’ve been biting back questions like:
Aren’t all these tests a bit excessive?
Surely some of them are redundant? There’s duplication
between the functional tests and the unit tests.
Those unit tests seemed way too trivial— testing a one-line
function that returns a constant! Isn’t that just a waste of
time? Shouldn’t we save our tests for more complex things?
What about all those tiny changes during the unit-test/code
cycle? Couldn’t we just skip to the end? I mean, home_page =
None !? Really?
You’re not telling me you actually code like this in real life?
Ah, young grasshopper. I too was once full of questions like
these. But only because they’re perfectly good questions. In fact,
I still ask myself questions like these, all the time. Does all this
stuﬀ really have value? Is this a bit of a cargo cult?
Programming Is Like Pulling a
Bucket of Water Up from a Well
Ultimately, programming is hard. Often, we are smart, so we
succeed. TDD is there to help us out when we’re not so smart.

Kent Beck (who basically invented TDD) uses the metaphor of
lifting a bucket of water out of a well with a rope: when the well
isn’t too deep, and the bucket isn’t very full, it’s easy. And even
lifting a full bucket is pretty easy at ﬁrst. But after a while,
you’re going to get tired. TDD is like having a ratchet that lets
you save your progress, so you can take a break, and make sure
you never slip backwards.
That way you don’t have to be smart all the time.
Figure 4-1. Test ALL the things (original illustration source: Allie Brosh, Hyperbole
and a Half)
OK, perhaps in general, you’re prepared to concede that TDD is
a good idea, but maybe you still think I’m overdoing it? Testing
the tiniest thing, and taking ridiculously many small steps?
TDD is a discipline, and that means it’s not something that
comes naturally; because many of the payoﬀs aren’t immediate
but only come in the longer term, you have to force yourself to

do it in the moment. That’s what the image of the Testing Goat is
supposed to represent— you need to be a bit bloody-minded
about it.

ON THE MERITS OF TRIVIAL TESTS FOR TRIVIAL FUNCTIONS
In the short term it may feel a bit silly to write tests for simple
functions and constants.
It’s perfectly possible to imagine still doing “mostly” TDD, but
following more relaxed rules where you don’t unit test
absolutely everything. But in this book my aim is to demonstrate
full, rigorous TDD. Like a kata in a martial art, the idea is to
learn the motions in a controlled context, when there is no
adversity, so that the techniques are part of your muscle
memory. It seems trivial now, because we’ve started with a very
simple example. The problem comes when your application
gets complex— that’s when you really need your tests. And the
danger is that complexity tends to sneak up on you, gradually.
You may not notice it happening, but soon you’re a boiled frog.
There are two other things to say in favour of tiny, simple tests
for simple functions.
Firstly, if they’re really trivial tests, then they won’t take you
that long to write them. So stop moaning and just write them
already.
Secondly, it’s always good to have a placeholder. Having a test
there for a simple function means it’s that much less of a

psychological barrier to overcome when the simple function
gets a tiny bit more complex— perhaps it grows an if . Then a
few weeks later it grows a for  loop. Before you know it, it’s a
recursive metaclass-based polymorphic tree parser factory. But
because it’s had tests from the very beginning, adding a new test
each time has felt quite natural, and it’s well tested. The
alternative involves trying to decide when a function becomes
“complicated enough”, which is highly subjective; but worse,
because there’s no placeholder it feels like that much more
eﬀort to start, and you’re tempted each time to put it oﬀ… Pretty
soon— frog soup!
Instead of trying to ﬁgure out some hand-wavy subjective rules
for when you should write tests, and when you can get away
with not bothering, I suggest following the discipline for now— 
as with any discipline, you have to take the time to learn the
rules before you can break them.
Now, let us return to our muttons.
Using Selenium to Test User
Interactions

Where were we at the end of the last chapter? Let’s rerun the
test and ﬁnd out:
Did you try it, and get an error saying Problem loading page or
Unable to connect? So did I. It’s because we forgot to spin up the
dev server ﬁrst using manage.py runserver . Do that, and you’ll
get the failure message we’re after.
$ python functional_tests.py 
F 
=====================================================
FAIL: test_can_start_a_todo_list 
(__main__.NewVisitorTest.test_can_start_a_todo_list) 
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests.py", line 21, i
test_can_start_a_todo_list 
    self.fail("Finish the test!") 
AssertionError: Finish the test! 
 
 ----------------------------------------------------
Ran 1 test in 1.609s 
 
FAILED (failures=1)

NOTE
One of the great things about TDD is that you never have to worry about forgetting
what to do next— just rerun your tests and they will tell you what you need to work
on.
“Finish the test”, it says, so let’s do just that! Open up
functional_tests.py and we’ll extend our FT:
functional_tests.py (ch04l001)
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import time
import unittest
class NewVisitorTest(unittest.TestCase):
    def setUp(self):
        self.browser = webdriver.Firefox()
    def tearDown(self):
        self.browser.quit()
    def test_can_start_a_todo_list(self):
        # Edith has heard about a cool new online to-
        # She goes to check out its homepage

        self.browser.get("http://localhost:8000")
        # She notices the page title and header menti
        self.assertIn("To-Do", self.browser.title)
        header_text = self.browser.find_element(By.TA
        self.assertIn("To-Do", header_text)
        # She is invited to enter a to-do item straig
        inputbox = self.browser.find_element(By.ID, "
        self.assertEqual(inputbox.get_attribute("plac
        # She types "Buy peacock feathers" into a tex
        # (Edith's hobby is tying fly-fishing lures)
        inputbox.send_keys("Buy peacock feathers")  
        # When she hits enter, the page updates, and 
        # "1: Buy peacock feathers" as an item in a t
        inputbox.send_keys(Keys.ENTER)  
        time.sleep(1)  
        table = self.browser.find_element(By.ID, "id_
        rows = table.find_elements(By.TAG_NAME, "tr")
        self.assertTrue(any(row.text == "1: Buy peaco
        # There is still a text box inviting her to a
        # She enters "Use peacock feathers to make a 
        # (Edith is very methodical)
        self.fail("Finish the test!")

We’re using the two methods that Selenium provides to
examine web pages: find_element  and find_elements
(notice the extra s , which means it will return several
elements rather than just one). Each one is parameterized
with a By.SOMETHING  which lets us search using diﬀerent
HTML properties and attributes.
We also use send_keys , which is Selenium’s way of typing
into input elements.
The Keys  class (don’t forget to import it) lets us send special
keys like Enter.
When we hit Enter, the page will refresh. The time.sleep  is
there to make sure the browser has ﬁnished loading before
we make any assertions about the new page. This is called an
“explicit wait” (a very simple one; we’ll improve it in
Chapter 6).
TIP
Watch out for the diﬀerence between the Selenium find_element()  and
find_elements()  functions. One returns an element and raises an exception if it
can’t ﬁnd it, whereas the other returns a list, which may be empty.
        # The page updates again, and now shows both 
        [...]
1

Also, just look at that any()  function. It’s a little-known Python
built-in. I don’t even need to explain it, do I? Python is such a
joy.
NOTE
If you’re one of my readers who doesn’t know Python, what’s happening inside the
any()  may need some explaining. The basic syntax is that of a list comprehension,
and if you haven’t learned about them, you should do so immediately! Trey
Hunner’s explanation is excellent. In point of fact, because we’re omitting the
square brackets, we’re actually using a generator expression rather than a list
comprehension. It’s probably less important to understand the diﬀerence between
those two, but if you’re curious, check out this blog post by Guido himself
explaining the diﬀerence.
Let’s see how it gets on:
Decoding that, the test is saying it can’t ﬁnd an <h1>  element
on the page. Let’s see what we can do to add that to the HTML of
our home page.
$ python functional_tests.py 
[...] 
selenium.common.exceptions.NoSuchElementException: Me
element: h1; For documentation on this error, please 
2

Big changes to a functional test are usually a good thing to
commit on their own. I failed to do so when I was ﬁrst working
out the code for this chapter, and I regretted it later when I
changed my mind and had the change mixed up with a bunch
of others. The more atomic your commits, the better:
The “Don’t Test Constants” Rule,
and Templates to the Rescue
Let’s take a look at our unit tests, lists/tests.py. Currently we’re
looking for speciﬁc HTML strings, but that’s not a particularly
eﬃcient way of testing HTML. In general, one of the rules of
unit testing is Don’t test constants, and testing HTML as text is a
lot like testing a constant.
In other words, if you have some code that says:
wibble = 3
There’s not much point in a test that says:
$ git diff  # should show changes to functional_test
$ git commit -am "Functional test now checks we c

from myprogram import wibble
assert wibble == 3
Unit tests are really about testing logic, ﬂow control, and
conﬁguration. Making assertions about exactly what sequence
of characters we have in our HTML strings isn’t doing that.
It’s not quite that simple, since HTML is code after all, and we do
want something to check that we’ve written code that works,
but that’s our FT’s job, not the unit tests’.
In any case, mangling raw strings in Python really isn’t a great
way of dealing with HTML. There’s a much better solution,
which is to use templates. Quite apart from anything else, if we
can keep HTML to one side in a ﬁle whose name ends in .html,
we’ll get better syntax highlighting! There are lots of Python
templating frameworks out there, and Django has its own
which works very well. Let’s use that.
Refactoring to Use a Template
What we want to do now is make our view function return
exactly the same HTML, but just using a diﬀerent process. That’s
a refactor— when we try to improve the code without changing
its functionality.

That last bit is really important. If you try to add new
functionality at the same time as refactoring, you’re much more
likely to run into trouble. Refactoring is actually a whole
discipline in itself, and it even has a reference book: Martin
Fowler’s Refactoring.
The ﬁrst rule is that you can’t refactor without tests. Thankfully,
we’re doing TDD, so we’re way ahead of the game. Let’s check
that our tests pass; they will be what makes sure that our
refactoring is behaviour-preserving:
$ python manage.py test 
[...] 
OK
Great! We’ll start by taking our HTML string and putting it into
its own ﬁle. Create a directory called lists/templates to keep
templates in, and then open a ﬁle at lists/templates/home.html,
to which we’ll transfer our HTML:
lists/templates/home.html (ch04l002)
<html> 
  <title>To-Do lists</title>
</html>
3

Mmmh, syntax-highlighted… much nicer! Now to change our
view function:
lists/views.py (ch04l003)
from django.shortcuts import render 
 
 
def home_page(request): 
    return render(request, "home.html")
Instead of building our own HttpResponse , we now use the
Django render()  function. It takes the request as its ﬁrst
parameter (for reasons we’ll go into later) and the name of the
template to render. Django will automatically search folders
called templates inside any of your apps’ directories. Then it
builds an HttpResponse  for you, based on the content of the
template.
NOTE
Templates are a very powerful feature of Django’s, and their main strength consists
of substituting Python variables into HTML text. We’re not using this feature yet, but
we will in future chapters. That’s why we use render()  rather than, say, manually
reading the ﬁle from disk with the built-in open() .

Let’s see if it works:
$ python manage.py test 
[...] 
=====================================================
ERROR: test_home_page_returns_correct_html 
(lists.tests.HomePageTest.test_home_page_returns_corr
-----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/lists/tests.py", line 7, in test
    response = self.client.get("/")   
               ^^^^^^^^^^^^^^^^^^^^ 
[...] 
  File "...goat-book/lists/views.py", line 4, in home
    return render(request, "home.html")   
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
  File ".../django/shortcuts.py", line 24, in render 
    content = loader.render_to_string(template_name, 
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ".../django/template/loader.py", line 61, in r
    template = get_template(template_name, using=usin
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File ".../django/template/loader.py", line 19, in g
    raise TemplateDoesNotExist(template_name, chain=c
django.template.exceptions.TemplateDoesNotExist: home
 
-----------------------------------------------------
Ran 1 test in 0 074s

Another chance to analyse a traceback:
We start with the error: it can’t ﬁnd the template.
Then we double-check what test is failing: sure enough, it’s
our test of the view HTML.
Then we ﬁnd the line in our tests that caused the failure: it’s
when we request the root URL (“/”).
Finally, we look for the part of our own application code that
caused the failure: it’s when we try to call render .
So why can’t Django ﬁnd the template? It’s right where it’s
supposed to be, in the lists/templates folder.
The thing is that we haven’t yet oࢃcially registered our lists app
with Django. Unfortunately, just running the startapp
command and having what is obviously an app in your project
folder isn’t quite enough. You have to tell Django that you really
mean it, and add it to settings.py as well. Belt and braces. Open it
up and look for a variable called INSTALLED_APPS , to which
we’ll add lists :
superlists/settings.py (ch04l004)
Ran 1 test in 0.074s

# Application definition 
 
INSTALLED_APPS = [ 
    "django.contrib.admin", 
    "django.contrib.auth", 
    "django.contrib.contenttypes", 
    "django.contrib.sessions", 
    "django.contrib.messages", 
    "django.contrib.staticfiles", 
    "lists",
]
You can see there’s lots of apps already in there by default. We
just need to add ours to the bottom of the list. Don’t forget the
trailing comma— it may not be required, but one day you’ll be
really annoyed when you forget it and Python concatenates two
strings on diﬀerent lines… 
Now we can try running the tests again:
$ python manage.py test 
[...] 
OK
Our refactor of the code is now complete, and the tests mean
we’re happy that behaviour is preserved. Now we can change

the tests so that they’re no longer testing constants; instead,
they should just check that we’re rendering the right template.
Checking template rendering
The Django test client has a method, assertTemplateUsed ,
which can do just what we want:
lists/tests.py (ch04l005)
We’ll leave the old tests there for now, just to make sure
everything is working the way we think it is.
.assertTemplateUsed  lets us check what template was used
to render a response (NB: it will only work for responses that
were retrieved by the test client).
And that test will still pass:
def test_home_page_returns_correct_html(self):
    response = self.client.get("/")
    self.assertContains(response, "<title>To-Do lists
    self.assertContains(response, "<html>")
    self.assertContains(response, "</html>")
    self.assertTemplateUsed(response, "home.html")  

Ran 1 tests in 0.016s 
 
OK
Just because I’m always suspicious of a test I haven’t seen fail,
let’s deliberately break it:
lists/tests.py (ch04l006)
self.assertTemplateUsed(response, "wrong.html")
That way we’ll also learn what its error messages look like:
That’s very helpful! Let’s change the assert back to the right
thing. While we’re at it, we can delete our old assertions, and
give the test method a more speciﬁc name:
lists/tests.py (ch04l007)
AssertionError: False is not true : Template 'wrong.h
used to render the response. Actual template(s) used:
from django.test import TestCase 

The main point, though, is that instead of testing constants
we’re testing our implementation. Great!
On Refactoring
That was an absolutely trivial example of refactoring. But, as
Kent Beck puts it in Test-Driven Development: By Example, “Am I
recommending that you actually work this way? No. I’m
recommending that you be able to work this way”.
In fact, as I was writing this my ﬁrst instinct was to dive in and
change the test ﬁrst— make it use the assertTemplateUsed
function straight away; delete the three superﬂuous assertions,
leaving just a check of the contents against the expected render;
and then go ahead and make the code change. But notice how
that actually would have left space for me to break things: I
could have deﬁned the template as containing any arbitrary
 
 
class HomePageTest(TestCase): 
    def test_uses_home_template(self): 
        response = self.client.get("/") 
        self.assertTemplateUsed(response, "home.html"

string, instead of the string with the right <html>  and <title>
tags.
TIP
When refactoring, work on either the code or the tests, but not both at once.
There’s always a tendency to skip ahead a couple of steps, to
make a couple of tweaks to the behaviour while you’re
refactoring, but pretty soon you’ve got changes to half a dozen
diﬀerent ﬁles, you’ve totally lost track of where you are, and
nothing works any more. If you don’t want to end up like
Refactoring Cat (Figure 4-2), stick to small steps; keep
refactoring and functionality changes entirely separate.

Figure 4-2. Refactoring Cat— be sure to look up the full animated GIF (source:
4GIFs.com)
NOTE
We’ll come across “Refactoring Cat” again during this book, as an example of what
happens when we get carried away and want to change too many things at once.
Think of it as the little cartoon demon counterpart to the Testing Goat, popping up
over your other shoulder and giving you bad advice.

It’s a good idea to do a commit after any refactoring:
A Little More of Our Front Page
In the meantime, our functional test is still failing. Let’s now
make an actual code change to get it passing. Because our
HTML is now in a template, we can feel free to make changes to
it, without needing to write any extra unit tests.
NOTE
This is another distinction between FTs and unit tests; Because the FTs use a real
web browser, we use them as the primary tool for testing our UI, and the HTML that
implements it.
So, we wanted an <h1> :
lists/templates/home.html (ch04l008)
$ git status # see tests.py, views.py, settings.py, 
$ git add .  # will also add the untracked templates
$ git diff --staged # review the changes we're about
$ git commit -m "Refactor home page view to use a

<html> 
  <head> 
    <title>To-Do lists</title> 
  </head> 
  <body> 
    <h1>Your To-Do list</h1> 
  </body>
</html>
Let’s see if our functional test likes it a little better:
OK, let’s add an input with that ID:
lists/templates/home.html (ch04l009)
  [...] 
  <body> 
    <h1>Your To-Do list</h1> 
    <input id="id_new_item" /> 
  </body>
</html>
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_new_item"]; For documentation on thi

And now what does the FT say?
AssertionError: '' != 'Enter a to-do item'
We add our placeholder text… 
lists/templates/home.html (ch04l010)
Which gives:
So we can go ahead and put the table onto the page. At this
stage it’ll just be empty:
lists/templates/home.html (ch04l011)
    <input id="id_new_item" placeholder="Enter a to-d
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_list_table"]; [...]
    <input id="id_new_item" placeholder="Enter a to-d
    <table id="id_list_table"> 
    </table> 
  </body>

What does the FT think?
Slightly cryptic! We can use the line number to track it down,
and it turns out it’s that any()  function I was so smug about
earlier— or, more precisely, the assertTrue , which doesn’t
have a very explicit failure message. We can pass a custom
error message as an argument to most assertX  methods in
unittest :
functional_tests.py (ch04l012)
If you run the FT again, you should see our helpful message:
  File "...goat-book/functional_tests.py", line 40, i
test_can_start_a_todo_list 
    self.assertTrue(any(row.text == "1: Buy peacock f
AssertionError: False is not true
    self.assertTrue( 
        any(row.text == "1: Buy peacock feathers" for
        "New to-do item did not appear in table", 
    )

But now, to get this to pass, we will need to actually process the
user’s form submission. And that’s a topic for the next chapter.
For now let’s do a commit:
Thanks to a bit of refactoring, we’ve got our view set up to
render a template, we’ve stopped testing constants, and we’re
now well placed to start processing user input.
Recap: The TDD Process
We’ve now seen all the main aspects of the TDD process, in
practice:
Functional tests
Unit tests
The unit-test/code cycle
Refactoring
AssertionError: False is not true : New to-do item di
$ git diff 
$ git commit -am "Front page HTML now generated f

It’s time for a little recap, and perhaps even some ﬂowcharts
(forgive me, my years misspent as a management consultant
have ruined me. On the plus side, said ﬂowcharts will feature
recursion!)
What does the overall TDD process look like?
We write a test.
We run the test and see it fail.
We write some minimal code to get it a little further.
We rerun the test and repeat until it passes (the unit test /
code cycle)
Then, we look for opportunities to refactor our code, using
our tests to make sure we don’t break anything.
And start again from the top!
See Figure 4-3.


Figure 4-3. TDD process as a ﬂowchart, including the unit test / code cycle
It’s very common to talk about this process using the three
words Red, Green, Refactor. See Figure 4-4.
Figure 4-4. Red, Green, Refactor
We write a test, and see it fail (“Red”).
We cycle between code and tests until the test passes:
“Green”.
Then, we look for opportunities to refactor.
Repeat as required!

Double-loop TDD
But how does this apply when we have functional tests and unit
tests? Well, you can think of the functional test as driving a
higher-level version of the same cycle, with an inner
red/green/refactor loop being required to get an FT from Red to
Green; see ee Figure 4-5.


Figure 4-5. Double-Loop TDD: Inner and Outer Loops
When a new feature or business requirement comes along, we
write a new (failing) FT to capture a high level view of the
requirement. It may not cover every last edge case, but it should
be enough to reassure ourselves that things are working.
To get that functional test to green, we then enter into the
lower-level unit tests cycle, where we put together all the
moving parts required, and add tests for all the edge cases. Any
time we get to green & refactored at the unit tests level, we can
pop back up to the FT level to guide us towards the next thing
we need to work. Once both levels are green, we can do any
extra refactoring or work on edge cases.
We’ll explore all of the diﬀerent parts of this workﬂow in more
detail over the coming chapters.

HOW TO “CHECK” YOUR CODE, OR SKIP AHEAD (IF YOU MUST)
All of the code examples I’ve used in the book are available in
my repo on GitHub. So, if you ever want to compare your code
against mine, you can take a look at it there.
Each chapter has its own branch which is named after its short
name. The one for this chapter is here, for example. It is a
snapshot of the code as it should be at the end of the chapter.
You can ﬁnd a full list of them in [Link to Come], as well as
instructions on how to download them or use Git to compare
your code to mine.
Obviously I can’t possibly condone it, but you can also use my
repo to “skip ahead” and check out the code to let you work on
a later chapter without having worked through all the earlier
chapters yourself. You’re only cheating yourself you know!
 You could also just use the string "\n" , but Keys  also lets
you send special keys like Ctrl so I thought I’d show it.
 Python is most deﬁnitely a joy, but if you think I’m being a
bit smug here, I don’t blame you! Actually I wish I’d picked up
on this feeling of self-satisfaction and seen it as a warning sign
1
2

that I was being a little too clever. In the next chapter, you’ll see
I get my comeuppance.
 Some people like to use another subfolder named after the
app (i.e., lists/templates/lists) and then refer to the template as
lists/home.html. This is called “template namespacing”. I ﬁgured
it was overcomplicated for this small project, but it may be
worth it on larger projects. There’s more in the Django tutorial.
3

Chapter 5. Saving User Input:
Testing the Database
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 5th chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
So far we’ve managed to return a static HTML page with an
input box in it. Next we want to take the text that the user types
into that input box and send it to the server, so that we can save
it somehow and display it back to her later.

The ﬁrst time I started writing code for this chapter, I
immediately wanted to skip to what I thought was the right
design: multiple database tables for lists and list items, a bunch
of diﬀerent URLs for adding new lists and items, three new view
functions, and about half a dozen new unit tests for all of the
above. But I stopped myself. Although I was pretty sure I was
smart enough to handle coding all those problems at once, the
point of TDD is to allow you to do one thing at a time, when you
need to. So I decided to be deliberately short-sighted, and at any
given moment only do what was necessary to get the functional
tests a little further.
This will be a demonstration of how TDD can support an
incremental, iterative style of development— it may not be the
quickest route, but you do get there in the end . There’s a neat
side beneﬁt, which is that it allows me to introduce new
concepts like models, dealing with POST requests, Django
template tags, and so on, one at a time rather than having to
dump them on you all at once.
None of this says that you shouldn’t try to think ahead, and be
clever. In the next chapter we’ll use a bit more design and up-
front thinking, and show how that ﬁts in with TDD. But for now
let’s plough on mindlessly and just do what the tests tell us to.
1

Wiring Up Our Form to Send a
POST Request
At the end of the last chapter, the tests were telling us we
weren’t able to save the user’s input:
To get it to the server, for now we’ll use a standard HTML POST
request. A little boring, but also nice and easy to deliver— we
can use all sorts of sexy HTML5 and JavaScript later in the book.
To get our browser to send a POST request, we need to do two
things:
1. Give the <input>  element a name=  attribute.
2. Wrap it in a <form>  tag  with method="POST" .
Let’s adjust our template at lists/templates/home.html:
lists/templates/home.html (ch05l001)
  File "...goat-book/functional_tests.py", line 40, i
test_can_start_a_todo_list 
[...] 
AssertionError: False is not true : New to-do item di
2

Now, running our FTs gives us a slightly cryptic, unexpected
error:
Oh dear, we’re now failing two lines earlier, after we submit the
form, but before we are able to do the assert. Selenium seems to
be unable to ﬁnd our list table. Why on Earth would that
happen? Let’s take another look at our code:
functional_tests.py
    <h1>Your To-Do list</h1> 
    <form method="POST"> 
      <input name="item_text" id="id_new_item" placeh
    </form> 
    <table id="id_list_table">
$ python functional_tests.py 
[...] 
Traceback (most recent call last): 
  File "...goat-book/functional_tests.py", line 38, i
test_can_start_a_todo_list 
    table = self.browser.find_element(By.ID, "id_list
[...] 
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_list_table"]; [...]

Our test unexpectedly fails on this line. How do we ﬁgure out
what’s going on?
Debugging functional tests
When a functional test fails with an unexpected failure, there
are several things we can do to debug it:
Add print  statements, to show, for example, what the
current page text is.
Improve the error message to show more info about the
current state.
Manually visit the site yourself.
        # When she hits enter, the page updates, and 
        # "1: Buy peacock feathers" as an item in a t
        inputbox.send_keys(Keys.ENTER)
        time.sleep(1)
        table = self.browser.find_element(By.ID, "id_
        rows = table.find_elements(By.TAG_NAME, "tr")
        self.assertTrue(
            any(row.text == "1: Buy peacock feathers"
            "New to-do item did not appear in table",
        )

Use time.sleep  to pause the test during execution so you
can inspect what was happening.
We’ll look at all of these over the course of this book, but the
time.sleep  option is the one that leaps to mind with this kind
of error in an FT. Let’s try it now.
Conveniently, we’ve already got a sleep just before the error
occurs; let’s just extend it a little:
functional_tests.py (ch05l003)
Depending on how fast Selenium runs on your PC, you may
have caught a glimpse of this already, but when we run the
functional tests again, we’ve got time to see what’s going on:
you should see a page that looks like Figure 5-1, with lots of
Django debug information.
    # When she hits enter, the page updates, and now 
    # "1: Buy peacock feathers" as an item in a to-do
    inputbox.send_keys(Keys.ENTER) 
    time.sleep(10) 
 
    table = self.browser.find_element(By.ID, "id_list
3

Figure 5-1. Django DEBUG page showing CSRF error

SECURITY: SURPRISINGLY FUN!
If you’ve never heard of a Cross-Site Request Forgery exploit,
why not look it up now? Like all security exploits, it’s
entertaining to read about, being an ingenious use of a system
in unexpected ways.
When I went to university to get my Computer Science degree, I
signed up for the Security module out of a sense of duty: Oh
well, it’ll probably be very dry and boring, but I suppose I’d better
take it. Eat your vegetables, and so forth. It turned out to be one
of the most fascinating modules of the whole course! Absolutely
full of the joy of hacking, of the particular mindset it takes to
think about how systems can be used in unintended ways.
I want to recommend the textbook from that course, Ross
Anderson’s Security Engineering_. It’s quite light on pure crypto,
but it’s absolutely full of interesting discussions of unexpected
topics like lock picking, forging bank notes, inkjet printer
cartridge economics, and spooﬁng South African Air Force jets
with replay attacks. It’s a huge tome, about three inches thick,
and I promise you it’s an absolute page-turner.
Django’s CSRF protection involves placing a little auto-
generated unique token into each generated form, to be able to

verify that POST requests have deﬁnitely come from the form
generated by the server. So far our template has been pure
HTML, and in this step we make the ﬁrst use of Django’s
template magic. To add the CSRF token we use a template tag,
which has the curly-bracket/percent syntax, {% ... %} —
famous for being the world’s most annoying two-key touch-
typing combination:
lists/templates/home.html (ch05l004)
Django will substitute the template tag during rendering with
an <input type="hidden">  containing the CSRF token.
Rerunning the functional test will now bring us back to our
previous (expected) failure:
  <form method="POST"> 
    <input name="item_text" id="id_new_item" placehol
    {% csrf_token %} 
  </form>
  File "...goat-book/functional_tests.py", line 40, i
test_can_start_a_todo_list 
[...] 
AssertionError: False is not true : New to-do item di

Since our long time.sleep  is still there, the test will pause on
the ﬁnal screen, showing us that the new item text disappears
after the form is submitted, and the page refreshes to show an
empty form again. That’s because we haven’t wired up our
server to deal with the POST request yet— it just ignores it and
displays the normal home page.
We can put our normal short time.sleep  back now though:
functional_tests.py (ch05l005)
Processing a POST Request on the
Server
Because we haven’t speciﬁed an action=  attribute in the form,
it is submitting back to the same URL it was rendered from by
default (i.e., / ), which is dealt with by our home_page  function.
    # "1: Buy peacock feathers" as an item in a to-do
    inputbox.send_keys(Keys.ENTER) 
    time.sleep(1) 
 
    table = self.browser.find_element(By.ID, "id_list

That’s ﬁne for now, let’s adapt the view to be able to deal with a
POST request.
That means a new unit test for the home_page  view. Open up
lists/tests.py, and add a new method to HomePageTest :
lists/tests.py (ch05l006)
To do a POST, we call self.client.post , and as you can see it
takes a data  argument which contains the form data we want
to send. Then we check that the text from our POST request
ends up in the rendered HTML. That gives us our expected fail:
class HomePageTest(TestCase): 
    def test_uses_home_template(self): 
        response = self.client.get("/") 
        self.assertTemplateUsed(response, "home.html"
 
    def test_can_save_a_POST_request(self): 
        response = self.client.post("/", data={"item_
        self.assertContains(response, "A new list ite
$ python manage.py test 
[...] 
AssertionError: False is not true : Couldn't find 'A 

In (slightly exaggerated) TDD style, we can single-mindedly do
“the simplest thing that could possibly work” to address this test
failure, which is to add an if  and a new code path for POST
requests, with a deliberately silly return value:
lists/views.py (ch05l007)
OK that gets our unit tests passing, but it’s not really what we
want.
What we really want to do is add the POST submission to the
todo items table in the home page template.
Passing Python Variables to Be
Rendered in the Template
from django.http import HttpResponse
from django.shortcuts import render 
 
 
def home_page(request): 
    if request.method == "POST": 
        return HttpResponse("You submitted: " + reque
    return render(request, "home.html")
4

We’ve already had a hint of it, and now it’s time to start to get to
know the real power of the Django template syntax, which is to
pass variables from our Python view code into HTML templates.
Let’s start by seeing how the template syntax lets us include a
Python object in our template. The notation is {{ ... }} ,
which displays the object as a string:
lists/templates/home.html (ch05l008)
Here’s our template variable. new_item_text  will be the
variable name for the user input we display in the template.
Let’s adjust our unit test so that it checks whether we are still
using the template:
<body> 
  <h1>Your To-Do list</h1> 
  <form method="POST"> 
    <input name="item_text" id="id_new_item" placehol
    {% csrf_token %} 
  </form> 
  <table id="id_list_table"> 
    <tr><td>{{ new_item_text }}</td></tr>   
  </table>
</body>

lists/tests.py (ch05l009)
And that will fail as expected:
Good, our deliberately silly return value is now no longer
fooling our tests, so we are allowed to rewrite our view, and tell
it to pass the POST parameter to the template. The render
function takes, as its third argument, a dictionary which maps
template variable names to their values.
In theory we can use it for the POST case as well as the default
GET case, so let’s remove the if request.method == "POST"
and simplify our view right down to:
lists/views.py (ch05l010)
    def test_can_save_a_POST_request(self): 
        response = self.client.post("/", data={"item_
        self.assertContains(response, "A new list ite
        self.assertTemplateUsed(response, "home.html"
AssertionError: No templates used to render the respo
def home_page(request): 
return render(

What do the tests think?
An Unexpected Failure
Oops, an unexpected failure.
If you remember the rules for reading tracebacks, you’ll spot
that it’s actually a failure in a diﬀerent test. We got the actual test
we were working on to pass, but the unit tests have picked up
    return render( 
        request, 
        "home.html", 
        {"new_item_text": request.POST["item_text"]},
    )
ERROR: test_uses_home_template 
(lists.tests.HomePageTest.test_uses_home_template) 
 
[...] 
    {"new_item_text": request.POST["item_text"]}, 
                      ~~~~~~~~~~~~^^^^^^^^^^^^^ 
[...] 
django.utils.datastructures.MultiValueDictKeyError: '

an unexpected consequence, a regression: we broke the code
path where there is no POST request.
This is the whole point of having tests. Yes, perhaps we could
have predicted this would happen, but imagine if we’d been
having a bad day or weren’t paying attention: our tests have
just saved us from accidentally breaking our application, and,
because we’re using TDD, we found out immediately. We didn’t
have to wait for a QA team, or switch to a web browser and click
through our site manually, and we can get on with ﬁxing it
straight away. Here’s how:
lists/views.py (ch05l011)
We use dict.get  to supply a default value, for the case where
we are doing a normal GET request, when the POST dictionary
is empty.
def home_page(request): 
    return render( 
        request, 
        "home.html", 
        {"new_item_text": request.POST.get("item_text
    )

The unit tests should now pass. Let’s see what the functional
tests say:
TIP
If your functional tests show you a diﬀerent error at this point, or at any point in
this chapter, complaining about a StaleElementReferenceException , you may need
to increase the time.sleep  explicit wait— try 2 or 3 seconds instead of 1; then read
on to the next chapter for a more robust solution.
Hmm, not a wonderfully helpful error. Let’s use another of our
FT debugging techniques: improving the error message. This is
probably the most constructive technique, because those
improved error messages stay around to help debug any future
errors:
functional_tests.py (ch05l012)
AssertionError: False is not true : New to-do item di
self.assertTrue( 
    any(row.text == "1: Buy peacock feathers" for row
    f"New to-do item did not appear in table. Content
)

That gives us a more helpful error message:
Actually, you know what would be even better? Making that
assertion a bit less clever! As you may remember from
Chapter 4, I was very pleased with myself for using the any()
function, but one of my Early Release readers (thanks, Jason!)
suggested a much simpler implementation. We can replace all
four lines of the assertTrue  with a single assertIn :
functional_tests.py (ch05l013)
Much better. You should always be very worried whenever you
think you’re being clever, because what you’re probably being
is overcomplicated.
Now we get the error message for free:
AssertionError: False is not true : New to-do item di
Contents were: 
Buy peacock feathers
    self.assertIn("1: Buy peacock feathers", [row.tex

Consider me suitably chastened.
TIP
If, instead, your FT seems to be saying the table is empty (“not found in ['']”), check
your <input>  tag— does it have the correct name="item_text"  attribute? And does it
have method="POST" ? Without them, the user’s input won’t be in the right place in
request.POST .
The point is that the FT wants us to enumerate list items with a
“1:” at the beginning of the ﬁrst list item.
The fastest way to get that to pass is with another quick
“cheating” change to the template:
lists/templates/home.html (ch05l014)
    <tr><td>1: {{ new_item_text }}</td></tr>
    self.assertIn("1: Buy peacock feathers", [row.tex
AssertionError: '1: Buy peacock feathers' not found i

WHEN SHOULD YOU STOP CHEATING? DON’T REPEAT YOURSELF (DRY)
VS TRIANGULATION
People often ask about when it’s OK to “stop cheating”, and
change from an implementation we know to be wrong, to one
we’re happy with.
One justiﬁcation is eliminate duplication aka Don’t Repeat
Yourself (DRY), which (with some caveats) is a good guideline
for any kind of code.
If your test uses a magic constant (like the “1:” in front of our
list item), and your application code also uses it, some people
say that counts as duplication, so it justiﬁes refactoring.
Removing the magic constant from the application code usually
means you have to stop cheating.
It’s a judgment call, but I feel that this is stretching the deﬁnition
of “repetition” a little, so I often like to use a second technique,
which is called triangulation: if your tests let you get away with
writing “cheating” code that you’re not happy with (like
returning a magic constant), then write another test that forces
you to write some better code. That’s what we’re doing when
we extend the FT to check that we get a “2:” when inputting a
second list item.

See also “Three Strikes and Refactor” for a further note of
caution on applying DRY too quickly.
Now we get to the self.fail('Finish the test!') . If we get
rid of that and ﬁnish writing our FT, to add the check for adding
a second item to the table (copy and paste is our friend), we
begin to see that our ﬁrst cut solution really isn’t going to, um,
cut it:
functional_tests.py (ch05l015)
    # There is still a text box inviting her to add a
    # She enters "Use peacock feathers to make a fly"
    # (Edith is very methodical) 
    inputbox = self.browser.find_element(By.ID, "id_n
    inputbox.send_keys("Use peacock feathers to make 
    inputbox.send_keys(Keys.ENTER) 
    time.sleep(1) 
 
    # The page updates again, and now shows both item
    table = self.browser.find_element(By.ID, "id_list
    rows = table.find_elements(By.TAG_NAME, "tr") 
    self.assertIn( 
        "1: Buy peacock feathers", 
        [row.text for row in rows], 
    ) 

Sure enough, the functional tests return an error:
Three Strikes and Refactor
But before we go further— we’ve got a bad code smell  in this FT.
We have three almost identical code blocks checking for new
items in the list table. When we want to apply the DRY principle,
I like to follow the mantra three strikes and refactor. You can
copy and paste code once, and it may be premature to try to
remove the duplication it causes, but once you get three
occurrences, it’s time to tidy up.
Let’s start by committing what we have so far. Even though we
know our site has a major ﬂaw— it can only handle one list item
    self.assertIn( 
        "2: Use peacock feathers to make a fly", 
        [row.text for row in rows], 
    ) 
 
    # Satisfied, she goes back to sleep
AssertionError: '1: Buy peacock feathers' not found i
feathers to make a fly']
5

— it’s still further ahead than it was. We may have to rewrite it
all, and we may not, but the rule is that before you do any
refactoring, always do a commit:
TIP
Always do a commit before embarking on a refactor.
Onto our functional test refactor: let’s use a helper method— 
remember, only methods that begin with test_  will get run as
tests, so you can use other methods for your own purposes:
functional_tests.py (ch05l016)
$ git diff 
# should show changes to functional_tests.py, home.ht
# tests.py and views.py 
$ git commit -a
    def tearDown(self): 
        self.browser.quit() 
 
    def check_for_row_in_list_table(self, row_text): 
        table = self.browser.find_element(By.ID, "id_
        rows = table.find_elements(By.TAG_NAME, "tr")

I like to put helper methods near the top of the class, between
the tearDown  and the ﬁrst test. Let’s use it in the FT:
functional_tests.py (ch05l017)
        self.assertIn(row_text, [row.text for row in 
 
    def test_can_start_a_todo_list(self): 
        [...]
    # When she hits enter, the page updates, and now 
    # "1: Buy peacock feathers" as an item in a to-do
    inputbox.send_keys(Keys.ENTER) 
    time.sleep(1) 
    self.check_for_row_in_list_table("1: Buy peacock 
 
    # There is still a text box inviting her to add a
    # She enters "Use peacock feathers to make a fly"
    # (Edith is very methodical) 
    inputbox = self.browser.find_element(By.ID, "id_n
    inputbox.send_keys("Use peacock feathers to make 
    inputbox.send_keys(Keys.ENTER) 
    time.sleep(1) 
 
    # The page updates again, and now shows both item
    self.check_for_row_in_list_table("1: Buy peacock 
    self.check_for_row_in_list_table("2: Use peacock 

We run the FT again to check that it still behaves in the same
way… 
Good. Now we can commit the FT refactor as its own small,
atomic change:
And back to work. If we’re ever going to handle more than one
list item, we’re going to need some kind of persistence, and
databases are a stalwart solution in this area.
The Django ORM and Our First
Model
 
    # Satisfied, she goes back to sleep
AssertionError: '1: Buy peacock feathers' not found i
feathers to make a fly']
$ git diff # check the changes to functional_tests.p
$ git commit -a

An Object-Relational Mapper (ORM) is a layer of abstraction for
data stored in a database with tables, rows, and columns. It lets
us work with databases using familiar object-oriented
metaphors which work well with code. Classes map to database
tables, attributes map to columns, and an individual instance of
the class represents a row of data in the database.
Django comes with an excellent ORM, and writing a unit test
that uses it is actually an excellent way of learning it, since it
exercises code by specifying how we want it to work.
Let’s create a new class in lists/tests.py:
lists/tests.py (ch05l018)
from django.test import TestCase
from lists.models import Item 
 
 
class HomePageTest(TestCase): 
    [...] 
 
 
class ItemModelTest(TestCase): 
    def test_saving_and_retrieving_items(self): 
        first_item = Item() 
        first_item.text = "The first (ever) list item

You can see that creating a new record in the database is a
relatively simple matter of creating an object, assigning some
attributes, and calling a .save()  function. Django also gives us
an API for querying the database via a class attribute,
.objects , and we use the simplest possible query, .all() ,
which retrieves all the records for that table. The results are
returned as a list-like object called a QuerySet , from which we
can extract individual objects, and also call further functions,
like .count() . We then check the objects as saved to the
database, to check whether the right information was saved.
        first_item.save() 
 
        second_item = Item() 
        second_item.text = "Item the second" 
        second_item.save() 
 
        saved_items = Item.objects.all() 
        self.assertEqual(saved_items.count(), 2) 
 
        first_saved_item = saved_items[0] 
        second_saved_item = saved_items[1] 
        self.assertEqual(first_saved_item.text, "The 
        self.assertEqual(second_saved_item.text, "Ite

Django’s ORM has many other helpful and intuitive features;
this might be a good time to skim through the Django tutorial,
which has an excellent intro to them.
NOTE
I’ve written this unit test in a very verbose style, as a way of introducing the Django
ORM. I wouldn’t recommend writing your model tests like this “in real life”, because
it’s testing the framework, rather than testing our own code. We’ll actually rewrite
this test to be much more concise in [Link to Come] (speciﬁcally, at [Link to Come]).

UNIT TESTS VERSUS INTEGRATED/INTEGRATION TESTS, AND THE
DATABASE
Some people will tell you that a “real” unit test should never
touch the database, and that the test I’ve just written should be
more properly called an “integrated” test, or “integration” test,
because it doesn’t only test our code, but also relies on an
external system— that is, a database.
It’s OK to ignore this distinction for now— we have two types of
test, the high-level functional tests which test the application
from the user’s point of view, and these lower-level tests which
test it from the programmer’s point of view.
We’ll come back to this topic and talk about the diﬀerences
between unit tests, integrated tests, integration tests, and more
in [Link to Come], towards the end of the book.
Let’s try running the unit test. Here comes another unit-
test/code cycle:
Very well, let’s give it something to import from lists/models.py.
We’re feeling conﬁdent so we’ll skip the Item = None  step, and
ImportError: cannot import name 'Item' from 'lists.mo

go straight to creating a class:
lists/models.py (ch05l019)
from django.db import models 
 
# Create your models here.
class Item: 
    pass
That gets our test as far as:
To give our Item  class a save  method, and to make it into a
real Django model, we make it inherit from the Model  class:
lists/models.py (ch05l020)
from django.db import models 
 
[...] 
  File "...goat-book/lists/tests.py", line 20, in 
test_saving_and_retrieving_items 
    first_item.save() 
    ^^^^^^^^^^^^^^^ 
AttributeError: 'Item' object has no attribute 'save'

 
class Item(models.Model): 
    pass
Our First Database Migration
The next thing that happens is a huuuuge traceback, the long
and short of which is that there’s a problem with the database:
In Django, the ORM’s job is to model and read and write from
database tables, but there’s a second system that’s in charge of
actually creating the tables in the database called “migrations”.
Its job is to let you to add, remove, and modify tables and
columns, based on changes you make to your models.py ﬁles.
One way to think of it is as a version control system for your
database. As we’ll see later, it comes in particularly useful when
we need to upgrade a database that’s deployed on a live server.
For now all we need to know is how to build our ﬁrst database
migration, which we do using the makemigrations  command:
django.db.utils.OperationalError: no such table: list
6

$ python manage.py makemigrations 
Migrations for 'lists': 
  lists/migrations/0001_initial.py 
    - Create model Item 
$ ls lists/migrations 
0001_initial.py  __init__.py  __pycache__
If you’re curious, you can go and take a look in the migrations
ﬁle, and you’ll see it’s a representation of our additions to
models.py.
In the meantime, we should ﬁnd our tests get a little further.
The Test Gets Surprisingly Far
The test actually gets surprisingly far:
That’s a full eight lines later than the last failure— we’ve been all
the way through saving the two Item s, and we’ve checked that
$ python manage.py test 
[...] 
    self.assertEqual(first_saved_item.text, "The firs
                     ^^^^^^^^^^^^^^^^^^^^^ 
AttributeError: 'Item' object has no attribute 'text'

they’re saved in the database, but Django just doesn’t seem to
have “remembered” the .text  attribute.
If you’re new to Python, you might have been surprised that we
were allowed to assign the .text  attribute at all. In a language
like Java, you would probably get a compilation error. Python is
more relaxed.
Classes that inherit from models.Model  map to tables in the
database. By default they get an auto-generated id  attribute,
which will be a primary key column  in the database, but you
have to deﬁne any other columns and attributes you want
explicitly; here’s how we set up a text column:
lists/models.py (ch05l022)
class Item(models.Model): 
    text = models.TextField()
Django has many other ﬁeld types, like IntegerField ,
CharField , DateField , and so on. I’ve chosen TextField
rather than CharField  because the latter requires a length
restriction, which seems arbitrary at this point. You can read
more on ﬁeld types in the Django tutorial and in the
documentation.
7

A New Field Means a New Migration
Running the tests gives us another database error:
It’s because we’ve added another new ﬁeld to our database,
which means we need to create another migration. Nice of our
tests to let us know!
Let’s try it:
Ah. It won’t let us add the column without a default value. Let’s
pick option 2 and set a default in models.py. I think you’ll ﬁnd
django.db.utils.OperationalError: table lists_item ha
$ python manage.py makemigrations 
It is impossible to add a non-nullable field 'text' t
a default. This is because the database needs somethi
rows. 
Please select a fix: 
 1) Provide a one-off default now (will be set on all
value for this column) 
 2) Quit and manually define a default value in model
Select an option:2

the syntax reasonably self-explanatory:
lists/models.py (ch05l023)
class Item(models.Model): 
    text = models.TextField(default="")
And now the migration should complete:
$ python manage.py makemigrations 
Migrations for 'lists': 
  lists/migrations/0002_item_text.py 
    - Add field text to item
So, two new lines in models.py, two database migrations, and as
a result, the .text  attribute on our model objects is now
recognised as a special attribute, so it does get saved to the
database, and the tests pass… 
$ python manage.py test 
[...] 
 
Ran 3 tests in 0.010s 
OK

So let’s do a commit for our ﬁrst ever model!
Saving the POST to the Database
Let’s adjust the test for our home page POST request, and say we
want the view to save a new item to the database instead of just
passing it through to its response. We can do that by adding
three new lines to the existing test called
test_can_save_a_POST_request :
lists/tests.py (ch05l025)
$ git status # see tests.py, models.py, and 2 untrac
$ git diff # review changes to tests.py and models.p
$ git add lists 
$ git commit -m "Model for list Items and associa
def test_can_save_a_POST_request(self):
    response = self.client.post("/", data={"item_text
    self.assertEqual(Item.objects.count(), 1)  
    new_item = Item.objects.first()  
    self.assertEqual(new_item.text, "A new list item"
    self.assertContains(response, "A new list item")

We check that one new Item  has been saved to the database.
objects.count()  is a shorthand for
objects.all().count() .
objects.first()  is the same as doing objects.all()[0] .
We check that the item’s text is correct.
This test is getting a little long-winded. It seems to be testing lots
of diﬀerent things. That’s another code smell—a long unit test
either needs to be broken into two, or it may be an indication
that the thing you’re testing is too complicated. Let’s add that to
a little to-do list of our own, perhaps on a piece of scrap paper:
Code smell: POST test is too long?
Writing it down on a scratchpad like this reassures us that we
won’t forget, so we are comfortable getting back to what we
were working on. We rerun the tests and see an expected
failure:
    self.assertEqual(Item.objects.count(), 1) 
AssertionError: 0 != 1
    self.assertTemplateUsed(response, "home.html")

Let’s adjust our view:
lists/views.py (ch05l026)
I’ve coded a very naive solution and you can probably spot a
very obvious problem, which is that we’re going to be saving
empty items with every request to the home page. Let’s add that
to our list of things to ﬁx later. You know, along with the
painfully obvious fact that we currently have no way at all of
having diﬀerent lists for diﬀerent people. That we’ll keep
ignoring for now.
from django.shortcuts import render
from lists.models import Item 
 
 
def home_page(request): 
    item = Item() 
    item.text = request.POST.get("item_text", "") 
    item.save() 
 
    return render( 
        request, 
        "home.html", 
        {"new_item_text": request.POST.get("item_text
    )

Remember, I’m not saying you should always ignore glaring
problems like this in “real life”. Whenever we spot problems in
advance, there’s a judgement call to make over whether to stop
what you’re doing and start again, or leave them until later.
Sometimes ﬁnishing oﬀ what you’re doing is still worth it, and
sometimes the problem may be so major as to warrant a stop
and rethink.
Let’s see how the unit tests get on… 
Ran 3 tests in 0.010s 
 
OK
They pass! Good. Let’s have a little look at our scratchpad. I’ve
added a couple of the other things that are on our mind:
Don’t save blank items for every request
Code smell: POST test is too long?
Display multiple items in the table
Support more than one list!

Let’s start with the ﬁrst scratch pad item: Don’t save blank items
for every request. We could tack on an assertion to an existing
test, but it’s best to keep unit tests to testing one thing at a time,
so let’s add a new one:
lists/tests.py (ch05l027)
That gives us a 1 != 0  failure. Let’s ﬁx it by bringing the if
request.method  check back and putting the Item creation in
there:
lists/views.py (ch05l028)
class HomePageTest(TestCase): 
    def test_uses_home_template(self): 
        [...] 
 
    def test_can_save_a_POST_request(self): 
        [...] 
 
    def test_only_saves_items_when_necessary(self): 
        self.client.get("/") 
        self.assertEqual(Item.objects.count(), 0)
def home_page(request): 
if request method == "POST":

And that gets the test passing:
Ran 4 tests in 0.010s 
 
OK
Redirect After a POST
But, yuck, those duplicated request.POST  accesses are making
me pretty unhappy. Thankfully we are about to have the
opportunity to ﬁx it. A view function has two jobs: processing
user input, and returning an appropriate response. We’ve taken
care of the ﬁrst part, which is saving the user’s input to the
database, so now let’s work on the second part.
    if request.method == POST : 
        item = Item() 
        item.text = request.POST["item_text"] 
        item.save() 
 
    return render( 
        request, 
        "home.html", 
        {"new_item_text": request.POST.get("item_text
    )

Always redirect after a POST, they say, so let’s do that. Once
again we change our unit test for saving a POST request: instead
of expecting a response with the item in it, we want it to expect
a redirect back to the home page.
lists/tests.py (ch05l029)
We no longer expect a response with HTML content rendered
by a template, so we lose the assertContains  calls that
looked at that. Instead, we use Django’s assertRedirects
helper which checks that we return an HTTP 302 redirect,
back to the home URL.
That gives us this expected failure:
    def test_can_save_a_POST_request(self):
        response = self.client.post("/", data={"item_
        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, "A new list i
        self.assertRedirects(response, "/")  
    def test_only_saves_items_when_necessary(self):
        [...]

We can now tidy up our view substantially:
lists/views.py (ch05l030)
And the tests should now pass:
AssertionError: 200 != 302 : Response didn't redirect
code was 200 (expected 302)
from django.shortcuts import redirect, render
from lists.models import Item 
 
 
def home_page(request): 
    if request.method == "POST": 
        item = Item() 
        item.text = request.POST["item_text"] 
        item.save() 
        return redirect("/") 
 
    return render( 
        request, 
        "home.html", 
        {"new_item_text": request.POST.get("item_text
    )

Ran 4 tests in 0.010s 
 
OK
We’re at green, time for a little refactor!
Let’s have a look at views.py and see what opportunities for
improvement there might be:
lists/views.py
There’s a quicker way to do these 3 lines with
.objects.create()
def home_page(request):
    if request.method == "POST":
        item = Item()  
        item.text = request.POST["item_text"]  
        item.save()  
        return redirect("/")
    return render(
        request,
        "home.html",
        {"new_item_text": request.POST.get("item_text
    )

This line doesn’t seem quite right now, in fact it won’t work at
all. Let’s make a note on our scratchpad to sort out passing
list items to the template. It’s actually closely related to
“Display multiple items”, so we’ll put it just before that one:
Don’t save blank items for every request
Code smell: POST test is too long?
Pass existing list items to the template somehow
Display multiple items in the table
Support more than one list!
And here’s the refactored version of views.py using the
.objects.create()  helper method that Django provides, for
one-line creation of objects:
lists/views.py (ch05l031)
def home_page(request): 
    if request.method == "POST": 
        Item.objects.create(text=request.POST["item_t
        return redirect("/") 
 
    return render( 
        request, 

Better Unit Testing Practice: Each
Test Should Test One Thing
Let’s address the “POST test is too long” code smell.
Good unit testing practice says that each test should only test
one thing. The reason is that it makes it easier to track down
bugs. Having multiple assertions in a test means that, if the test
fails on an early assertion, you don’t know what the statuses of
the later assertions are. As we’ll see in the next chapter, if we
ever break this view accidentally, we want to know whether it’s
the saving of objects that’s broken, or the type of response.
You may not always write perfect unit tests with single
assertions on your ﬁrst go, but now feels like a good time to
separate out our concerns:
lists/tests.py (ch05l032)
        "home.html", 
        {"new_item_text": request.POST.get("item_text
    )
    def test_can_save_a_POST_request(self): 
lf
li
("/"
d
{"i
"
"

And we should now see ﬁve tests pass instead of four:
Ran 5 tests in 0.010s 
 
OK
Rendering Items in the Template
Much better! Back to our to-do list:
        self.client.post("/", data={"item_text": "A n
        self.assertEqual(Item.objects.count(), 1) 
        new_item = Item.objects.first() 
        self.assertEqual(new_item.text, "A new list i
 
    def test_redirects_after_POST(self): 
        response = self.client.post("/", data={"item_
        self.assertRedirects(response, "/")

Don’t save blank items for every request
Code smell: POST test is too long?
Pass existing list items to the template somehow
Display multiple items in the table
Support more than one list!
Crossing things oﬀ the list is almost as satisfying as seeing tests
pass!
The third and fourth items are the last of the “easy” ones. Our
view now does the right thing for POST requests, it saves new
list items to the database. Now we want GET requests to load all
currently existing list items, and pass them to the template for
rendering. Let’s have a new unit test for that:
lists/tests.py (ch05l033)
class HomePageTest(TestCase): 
    def test_uses_home_template(self): 
        [...] 
 
    def test_displays_all_list_items(self): 
        Item.objects.create(text="itemey 1") 
        Item.objects.create(text="itemey 2") 

        response = self.client.get("/") 
        self.assertContains(response, "itemey 1") 
        self.assertContains(response, "itemey 2") 
 
    def test_can_save_a_POST_request(self): 
        [...]
That fails as expected:
The Django template syntax has a tag for iterating through lists,
{% for .. in .. %} ; we can use it like this:
lists/templates/home.html (ch05l034)
<table id="id_list_table"> 
  {% for item in items %} 
    <tr><td>1: {{ item.text }}</td></tr> 
  {% endfor %} 
</table>
This is one of the major strengths of the templating system. Now
the template will render with multiple <tr>  rows, one for each
item in the variable items . Pretty neat! I’ll introduce a few
AssertionError: False is not true : Couldn't find 'it

more bits of Django template magic as we go, but at some point
you’ll want to go and read up on the rest of them in the Django
docs.
Just changing the template doesn’t get our tests to green; we
need to actually pass the items to it from our home page view:
lists/views.py (ch05l035)
That does get the unit tests to pass… moment of truth, will the
functional test pass?
def home_page(request): 
    if request.method == "POST": 
        Item.objects.create(text=request.POST["item_t
        return redirect("/") 
 
    items = Item.objects.all() 
    return render(request, "home.html", {"items": ite
$ python functional_tests.py 
[...] 
AssertionError: 'To-Do' not found in 'OperationalErro

Oops, apparently not. Let’s use another functional test
debugging technique, and it’s one of the most straightforward:
manually visiting the site! Open up http://localhost:8000 in your
web browser, and you’ll see a Django debug page saying “no
such table: lists_item”, as in Figure 5-2.
Figure 5-2. Another helpful debug message

Creating Our Production Database
with migrate
Another helpful error message from Django, which is basically
complaining that we haven’t set up the database properly. How
come everything worked ﬁne in the unit tests, I hear you ask?
Because Django creates a special test database for unit tests; it’s
one of the magical things that Django’s TestCase  does.
To set up our “real” database, we need to explicitly create it.
SQLite databases are just a ﬁle on disk, and you’ll see in
settings.py that Django, by default, will just put it in a ﬁle called
db.sqlite3 in the base project directory:
superlists/settings.py
[...]
# Database
# https://docs.djangoproject.com/en/4.2/ref/settings/
 
DATABASES = { 
    "default": { 
        "ENGINE": "django.db.backends.sqlite3", 
        "NAME": BASE_DIR / "db.sqlite3", 
    }

We’ve told Django everything it needs to create the database,
ﬁrst via models.py and then when we created the migrations
ﬁle. To actually apply it to creating a real database, we use
another Django Swiss Army knife manage.py command,
migrate :
}
$ python manage.py migrate 
Operations to perform: 
  Apply all migrations: admin, auth, contenttypes, li
Running migrations: 
  Applying contenttypes.0001_initial... OK 
  Applying auth.0001_initial... OK 
  Applying admin.0001_initial... OK 
  Applying admin.0002_logentry_remove_auto_add... OK 
  Applying admin.0003_logentry_add_action_flag_choice
  Applying contenttypes.0002_remove_content_type_name
  Applying auth.0002_alter_permission_name_max_length
  Applying auth.0003_alter_user_email_max_length... O
  Applying auth.0004_alter_user_username_opts... OK 
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK 
  Applying auth.0007_alter_validators_add_error_messa
  Applying auth.0008_alter_user_username_max_length..
  Applying auth.0009_alter_user_last_name_max_length.
Applying auth 0010 alter group name max length
O

Now we can refresh the page on localhost, see that our error is
gone, and try running the functional tests again:
So close! We just need to get our list numbering right. Another
awesome Django template tag, forloop.counter , will help
here:
lists/templates/home.html (ch05l036)
If you try it again, you should now see the FT gets to the end:
  Applying auth.0010_alter_group_name_max_length... O
  Applying auth.0011_update_proxy_permissions... OK 
  Applying auth.0012_alter_user_first_name_max_length
  Applying lists.0001_initial... OK 
  Applying lists.0002_item_text... OK 
  Applying sessions.0001_initial... OK
AssertionError: '2: Use peacock feathers to make a fl
peacock feathers', '1: Use peacock feathers to make a
  {% for item in items %} 
    <tr><td>{{ forloop.counter }}: {{ item.text }}</t
  {% endfor %}
8

Hooray!
But, as it’s running, you may notice something is amiss, like in
Figure 5-3.
$ python functional_tests.py 
. 
 ----------------------------------------------------
Ran 1 test in 5.036s 
 
OK

Figure 5-3. There are list items left over from the last run of the test
Oh dear. It looks like previous runs of the test are leaving stuﬀ
lying around in our database. In fact, if you run the tests again,
you’ll see it gets worse:
1: Buy peacock feathers 
2: Use peacock feathers to make a fly 

3: Buy peacock feathers 
4: Use peacock feathers to make a fly 
5: Buy peacock feathers 
6: Use peacock feathers to make a fly
Grrr. We’re so close! We’re going to need some kind of
automated way of tidying up after ourselves. For now, if you
feel like it, you can do it manually, by deleting the database and
re-creating it fresh with migrate  (you’ll need to shut down
your Django server ﬁrst):
$ rm db.sqlite3 
$ python manage.py migrate --noinput
And then (after restarting your server!) reassure yourself that
the FT still passes.
Apart from that little bug in our functional testing, we’ve got
some code that’s more or less working. Let’s do a commit.
Start by doing a git status  and a git diff , and you should
see changes to home.html, tests.py, and views.py. Let’s add them:
$ git add lists 
$ git commit -m "Redirect after POST, and show al

TIP
You might ﬁnd it useful to add markers for the end of each chapter, like git tag
end-of-chapter-05 .
Recap
Where are we? How is progress on our app, and what have we
learned?
We’ve got a form set up to add new items to the list using
POST.
We’ve set up a simple model in the database to save list items.
We’ve learned about creating database migrations, both for
the test database (where they’re applied automatically) and
for the real database (where we have to apply them
manually).
We’ve used our ﬁrst couple of Django template tags: {%
csrf_token %}  and the {% for ... endfor %}  loop.
And we’ve used two diﬀerent FT debugging techniques:
time.sleep s, and improving the error messages.
But we’ve got a couple of items on our own to-do list, namely
getting the FT to clean up after itself, and perhaps more

critically, adding support for more than one list.
Don’t save blank items for every request
Code smell: POST test is too long?
‘Pass existing list items to the template somehow
Display multiple items in the table
Clean up after FT runs
Support more than one list!
I mean, we could ship the site as it is, but people might ﬁnd it
strange that the entire human population has to share a single
to-do list. I suppose it might get people to stop and think about
how connected we all are to one another, how we all share a
common destiny here on Spaceship Earth, and how we must all
work together to solve the global problems that we face.
But in practical terms, the site wouldn’t be very useful.
Ah well.

USEFUL TDD CONCEPTS
Regression
When a change unexpectedly breaks some aspect of the
application which used to work.
Unexpected failure
When a test fails in a way we weren’t expecting. This either
means that we’ve made a mistake in our tests, or that the
tests have helped us ﬁnd a regression, and we need to ﬁx
something in our code.
Triangulation
Adding a test case with a new speciﬁc example for some
existing code, to justify generalising the implementation
(which may be a “cheat” until that point).
Three strikes and refactor
A rule of thumb for when to remove duplication from code.
When two pieces of code look very similar, it often pays to
wait until you see a third use case, so that you’re more sure
about what part of the code really is the common, re-usable
part to refactor out.
The scratchpad to-do list

A place to write down things that occur to us as we’re coding,
so that we can ﬁnish up what we’re doing and come back to
them later.
 “Geepaw” Hill, another one of the TDD OGs, has a series of
blog posts advocating for taking “Many More Much Smaller
Steps (MMMSS)”. In this chapter I’m being unrealistically short-
sighted for eﬀect, so don’t do that! But Geepaw argues that in
the real world, when you slice your work into tiny increments,
not only do you get there in the end, but you end up delivering
business value faster.
 Did you know that you don’t need a button to make a form
submit? I can’t remember when I learned that, but readers have
mentioned that it’s unusual so I thought I’d draw your attention
to it.
 Another common technique for debugging tests is to use
breakpoint()  to drop into a debugger like pdb . This is more
useful for unit tests rather than FTs though, because in an FT
you usually can’t step into actual application code. Personally I
only ﬁnd debuggers useful for really ﬁddly algorithms, which
we won’t see in this book.)
1
2
3

 But we did learn about request.method  and
request.POST  right? I know it might seem that I’m overdoing
it, but doing things in tiny little steps really does have a lot of
advantages, and one of them is that you can really think about
(or in this case, learn) one thing at a time.
 If you’ve not come across the concept, a “code smell” is
something about a piece of code that makes you want to rewrite
it. Jeﬀ Atwood has a compilation on his blog Coding Horror. The
more experience you gain as a programmer, the more ﬁne-
tuned your nose becomes to code smells… 
 If you’ve done a bit of Django before, you may be
wondering about when we’re going to run “migrate” as well as
“makemigrations”? Read on; that’s coming up later in the
chapter.
 Database tables usually have a special column called a
“primary key”, which is the unique identiﬁer for each row in
the table. It’s worth brushing up on a tiny bit of relational
database theory, if you’re not familiar with the concept or why
it’s useful. The top three articles I found when searching for
“introduction to databases” all seemed pretty good, at the time
of writing.
4
5
6
7

 If you get a diﬀerent error at this point, try restarting your
dev server— it may have gotten confused by the changes to the
database happening under its feet.
8

Chapter 6. Improving Functional
Tests: Ensuring Isolation and
Removing Voodoo Sleeps
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 6th chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
Before we dive in and ﬁx our single-global-list problem, let’s
take care of a couple of housekeeping items. At the end of the
last chapter, we made a note that diﬀerent test runs were
interfering with each other, so we’ll ﬁx that. I’m also not happy

with all these time.sleep s peppered through the code; they
seem a bit unscientiﬁc, so we’ll replace them with something
more reliable.
Clean up after FT runs
Remove time.sleeps
Both of these changes will be moving us towards testing “best
practices”, making our tests more deterministic and more
reliable.
Ensuring Test Isolation in
Functional Tests
We ended the last chapter with a classic testing problem: how to
ensure isolation between tests. Each run of our functional tests
was leaving list items lying around in the database, and that
would interfere with the test results when you next ran the
tests.
When we run unit tests, the Django test runner automatically
creates a brand new test database (separate from the real one),

which it can safely reset before each individual test is run, and
then throw away at the end. But our functional tests currently
run against the “real” database, db.sqlite3.
One way to tackle this would be to “roll our own” solution, and
add some code to functional_tests.py which would do the
cleaning up. The setUp  and tearDown  methods are perfect for
this sort of thing.
But since this is a common problem, Django supplies a test class
called LiveServerTestCase  which addresses this issue. It will
automatically create a test database (just like in a unit test run),
and start up a development server for the functional tests to
run against. Although as a tool it has some limitations which
we’ll need to work around later, it’s dead useful at this stage, so
let’s check it out.
LiveServerTestCase  expects to be run by the Django test
runner using manage.py, which will run tests from any ﬁles
whose name begins with test_. To keep things neat and tidy, let’s
make a folder for our functional tests, so that it looks a bit like
an app. All Django needs is for it to be a valid Python package
directory (i.e., one with a ___init___.py in it):

$ mkdir functional_tests 
$ touch functional_tests/__init__.py
Now we want to move our functional tests, from being a
standalone ﬁle called functional_tests.py, to being the tests.py of
the functional_tests  app. We use git mv  so that Git keeps
track of the fact that this is the same ﬁle and should have a
single history.
At this point your directory tree should look like this:
. 
├── db.sqlite3 
├── functional_tests 
│   ├── __init__.py 
│   └── tests.py 
├── lists 
│   ├── __init__.py 
│   ├── admin.py 
│   ├── apps.py 
│   ├── migrations 
│   │   ├── 0001_initial.py 
$ git mv functional_tests.py functional_tests/tes
$ git status # shows the rename to functional_tests/

│   │   ├── 0002_item_text.py 
│   │   └── __init__.py 
│   ├── models.py 
│   ├── templates 
│   │   └── home.html 
│   ├── tests.py 
│   └── views.py 
├── manage.py 
└── superlists 
    ├── __init__.py 
    ├── asgi.py 
    ├── settings.py 
    ├── urls.py 
    └── wsgi.py
functional_tests.py is gone, and has turned into
functional_tests/tests.py. Now, whenever we want to run our
functional tests, instead of running python
functional_tests.py , we will use python manage.py test
functional_tests .
NOTE
You could mix your functional tests into the tests for the lists  app. I tend to prefer
to keep them separate, because functional tests usually have cross-cutting concerns
that run across diﬀerent apps. FTs are meant to see things from the point of view of
your users, and your users don’t care about how you’ve split work between diﬀerent
apps!

Now let’s edit functional_tests/tests.py and change our
NewVisitorTest  class to make it use LiveServerTestCase :
functional_tests/tests.py (ch06l001)
from django.test import LiveServerTestCase
from selenium import webdriver
[...] 
 
 
class NewVisitorTest(LiveServerTestCase): 
    def setUp(self): 
        [...]
Next, instead of hardcoding the visit to localhost port 8000,
LiveServerTestCase  gives us an attribute called
live_server_url :
functional_tests/tests.py (ch06l002)
    def test_can_start_a_todo_list(self): 
        # Edith has heard about a cool new online to-
        # She goes to check out its homepage 
        self.browser.get(self.live_server_url)

We can also remove the if __name__ == '__main__'  from the
end if we want, since we’ll be using the Django test runner to
launch the FT.
TODO — FIXES FROM HERE
Now we are able to run our functional tests using the Django
test runner, by telling it to run just the tests for our new
functional_tests  app:
The FT still passes, reassuring us that our refactor didn’t break
anything. You’ll also notice that if you run the tests a second
time, there aren’t any old list items lying around from the
previous test— it has cleaned up after itself. Success! We should
commit it as an atomic change:
$ python manage.py test functional_tests 
Creating test database for alias 'default'... 
Found 1 test(s). 
System check identified no issues (0 silenced). 
. 
 ----------------------------------------------------
Ran 1 test in 10.519s 
 
OK 
Destroying test database for alias 'default'...

Running Just the Unit Tests
Now if we run manage.py test , Django will run both the
functional and the unit tests:
In order to run just the unit tests, we can specify that we want
to only run the tests for the lists  app:
$ git status # functional_tests.py renamed + modifie
$ git add functional_tests 
$ git diff --staged 
$ git commit  # msg eg "make functional_tests an app
$ python manage.py test 
Creating test database for alias 'default'... 
Found 7 test(s). 
System check identified no issues (0 silenced). 
....... 
 ----------------------------------------------------
Ran 7 tests in 10.859s 
 
OK 
Destroying test database for alias 'default'...
$ python manage.py test lists 

USEFUL COMMANDS UPDATED
To run the functional tests
python manage.py test functional_tests
To run the unit tests
python manage.py test lists
What to do if I say “run the tests”, and you’re not sure which
ones I mean? Have another look at the ﬂowchart at the end of
Chapter 4, and try to ﬁgure out where we are. As a rule of
thumb, we usually only run the functional tests once all the unit
tests are passing, so if in doubt, try both!
Creating test database for alias 'default'... 
Found 6 test(s). 
System check identified no issues (0 silenced). 
...... 
 ----------------------------------------------------
Ran 6 tests in 0.009s 
 
OK 
Destroying test database for alias 'default'...

Aside: Upgrading Selenium and
Geckodriver
As I was running through this chapter again today, I found the
FTs hung when I tried to run them.
It turns out that Firefox had auto-updated itself overnight, and
my versions of Selenium and Geckodriver needed upgrading
too. A quick visit to the geckodriver releases page conﬁrmed
there was a new version out. So a few downloads and upgrades
were in order:
A quick pip install --upgrade selenium  ﬁrst.
Then a quick download of the new geckodriver.
I saved a backup copy of the old one somewhere, and put the
new one in its place somewhere on the PATH .
And a quick check with geckodriver --version  conﬁrms
the new one was ready to go.
The FTs were then back to running the way I expected them to.
There was no particular reason that it happened at this point in
the book; indeed, it’s quite unlikely that it’ll happen right now
for you, but it may happen at some point, and this seemed as

good a place as any to talk about it, since we’re doing some
housekeeping.
It’s one of the things you have to put up with when using
Selenium. Although it is possible to pin your browser and
Selenium versions (on a CI server, for example), browser
versions don’t stand still out in the real world, and you need to
keep up with what your users have.
NOTE
If something strange is going on with your FTs, it’s always worth trying to upgrade
Selenium.
Back to our regular programming now.
On Implicit and Explicit Waits, and
Voodoo time.sleeps
Let’s talk about the time.sleep  in our FT:
functional_tests/tests.py
        # When she hits enter, the page updates, and 
# "1: Buy peacock feathers" as an item in a t

This is what’s called an “explicit wait”. That’s by contrast with
“implicit waits”: in certain cases, Selenium tries to wait
“automatically” for you, when it thinks the page is loading. It
even provides a method called implicitly_wait  that lets you
control how long it will wait if you ask it for an element that
doesn’t seem to be on the page yet.
In fact, in the ﬁrst edition, I was able to rely entirely on implicit
waits. The problem is that implicit waits are always a little
ﬂakey, and with the release of Selenium 4, implicit waits were
disabled by default. At the same time, the general opinion from
the Selenium team was that implicit waits were just a bad idea,
and to be avoided.
So this edition has explicit waits from the very beginning. But
the problem is that those time.sleep s have their own issues.
Currently we’re waiting for one second, but who’s to say that’s
the right amount of time? For most tests we run against our
own machine, one second is way too long, and it’s going to
        # 1: Buy peacock feathers  as an item in a t
        inputbox.send_keys(Keys.ENTER) 
        time.sleep(1) 
 
        self.check_for_row_in_list_table("1: Buy peac

really slow down our FT runs. 0.1s would be ﬁne. But the
problem is that if you set it that low, every so often you’re going
to get a spurious failure because, for whatever reason, the
laptop was being a bit slow just then. And even at 1s you can
never be quite sure you’re not going to get random failures that
don’t indicate a real problem, and false positives in tests are a
real annoyance (there’s lots more on this in an article by Martin
Fowler).
TIP: Unexpected NoSuchElementException  and
StaleElementException  errors are often a sign that you need
an explicit wait.
So let’s replace our sleeps with a tool that will wait for just as
long as is needed, up to a nice long timeout to catch any
glitches. We’ll rename check_for_row_in_list_table  to
wait_for_row_in_list_table , and add some polling/retry
logic to it:
functional_tests/tests.py (ch06l004)
[...]
from selenium.common.exceptions import WebDriverExcep
import time
MAX_WAIT = 5  

We’ll use a constant called MAX_WAIT  to set the maximum
amount of time we’re prepared to wait. 5 seconds should be
enough to catch any glitches or random slowness.
Here’s the loop, which will keep going forever, unless we get
to one of two possible exit routes.
class NewVisitorTest(LiveServerTestCase):
    def setUp(self):
        [...]
    def tearDown(self):
        [...]
    def wait_for_row_in_list_table(self, row_text):
        start_time = time.time()
        while True:  
            try:
                table = self.browser.find_element(By.
                rows = table.find_elements(By.TAG_NAM
                self.assertIn(row_text, [row.text for
                return  
            except (AssertionError, WebDriverExceptio
                if time.time() - start_time > MAX_WAI
                    raise  
                time.sleep(0.5)  

Here are our three lines of assertions from the old version of
the method.
If we get through them and our assertion passes, we return
from the function and escape the loop.
But if we catch an exception, we wait a short amount of time
and loop around to retry. There are two types of exceptions
we want to catch: WebDriverException  for when the page
hasn’t loaded and Selenium can’t ﬁnd the table element on
the page, and AssertionError  for when the table is there,
but it’s perhaps a table from before the page reloads, so it
doesn’t have our row in yet.
Here’s our second escape route. If we get to this point, that
means our code kept raising exceptions every time we tried it
until we exceeded our timeout. So this time, we re-raise the
exception and let it bubble up to our test, and most likely end
up in our traceback, telling us why the test failed.
Are you thinking this code is a little ugly, and makes it a bit
harder to see exactly what we’re doing? I agree. Later on ([Link
to Come]), we’ll refactor out a general wait_for  helper, to
separate the timing and re-raising logic from the test assertions.
But we’ll wait until we need it in multiple places.

NOTE
If you’ve used Selenium before, you may know that it has a few helper functions to
do waits. I’m not a big fan of them, though not for any objective reason really. Over
the course of the book we’ll build a couple of wait helper tools which I think will
make for nice, readable code, but of course you should check out the homegrown
Selenium waits in your own time, and see if you prefer them.
Now we can rename our method calls, and remove the voodoo
time.sleep s:
functional_tests/tests.py (ch06l005)
    [...] 
    # When she hits enter, the page updates, and now 
    # "1: Buy peacock feathers" as an item in a to-do
    inputbox.send_keys(Keys.ENTER) 
    self.wait_for_row_in_list_table("1: Buy peacock f
 
    # There is still a text box inviting her to add a
    # She enters "Use peacock feathers to make a fly"
    # (Edith is very methodical) 
    inputbox = self.browser.find_element(By.ID, "id_n
    inputbox.send_keys("Use peacock feathers to make 
    inputbox.send_keys(Keys.ENTER) 
 
    # The page updates again, and now shows both item
    self.wait_for_row_in_list_table("1: Buy peacock f

And rerun the tests:
Hooray we’re back to passing, and notice we’ve shaved a couple
of seconds oﬀ the execution time too. That might not seem like
a lot right now, but it all adds up.
Just to check we’ve done the right thing, let’s deliberately break
the test in a couple of ways and see some errors. First let’s check
that if we look for some row text that will never appear, we get
the right error:
    self.wait_for_row_in_list_table("2: Use peacock f
    [...]
$ python manage.py test 
Creating test database for alias 'default'... 
Found 7 test(s). 
System check identified no issues (0 silenced). 
....... 
 ----------------------------------------------------
Ran 7 tests in 4.552s 
 
OK 
Destroying test database for alias 'default'...

functional_tests/tests.py (ch06l006)
We see we still get a nice self-explanatory test failure message:
NOTE
Did you get a bit bored waiting 5 seconds for the test to fail? That’s one of the
downsides of explicit waits. There’s a tricky tradeoﬀ between waiting long enough
that little glitches don’t throw you, versus waiting so long that expected failures are
painfully slow to watch. Making MAX_WAIT conﬁgurable so that it’s fast in local dev,
but more conservative on Continuous Integration (CI) servers can be a good idea.
See [Link to Come] for an introduction to CI.
Let’s put that back the way it was and break something else:
functional_tests/tests.py (ch06l007)
def wait_for_row_in_list_table(self, row_text): 
    [...] 
        rows = table.find_elements(By.TAG_NAME, "tr")
        self.assertIn("foo", [row.text for row in row
        return
    self.assertIn("foo", [row.text for row in rows]) 
AssertionError: 'foo' not found in ['1: Buy peacock f

Sure enough, we get the errors for when the page doesn’t
contain the element we’re looking for too:
Everything seems to be in order. Let’s put our code back to way
it should be, and do one ﬁnal test run:
$ python manage.py test 
[...] 
OK
Great. With that little interlude over, let’s crack on with getting
our application actually working for multiple lists. Don’t forget
to commit ﬁrst!
    try: 
        table = self.browser.find_element(By.ID, "id_
        rows = table.find_elements(By.TAG_NAME, "tr")
        self.assertIn(row_text, [row.text for row in 
        return 
    [...]
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_nothing"]; For documentation on this

TESTING “BEST PRACTICES” APPLIED IN THIS CHAPTER
Ensuring test isolation and managing global state
Diﬀerent tests shouldn’t aﬀect one another. This means we
need to reset any permanent state at the end of each test.
Django’s test runner helps us do this by creating a test
database, which it wipes clean in between each test. (See also
[Link to Come].)
Avoid “voodoo” sleeps
Whenever we need to wait for something to load, it’s always
tempting to throw in a quick-and-dirty time.sleep . But the
problem is that the length of time we wait is always a bit of a
shot in the dark, either too short and vulnerable to spurious
failures, or too long and it’ll slow down our test runs. Prefer a
retry loop that polls our app and moves on as soon as
possible.
Don’t rely on Selenium’s implicit waits
Selenium does theoretically do some “implicit” waits, but the
implementation varies between browsers, and is not always
reliable. “Explicit is better than implicit”, as the Zen of Python
says, so prefer explicit waits.

Chapter 7. Working Incrementally
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 7th chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
Now let’s address our real problem, which is that our design
only allows for one global list. In this chapter I’ll demonstrate a
critical TDD technique: how to adapt existing code using an
incremental, step-by-step process which takes you from
working state to working state. Testing Goat, not Refactoring
Cat!

Small Design When Necessary
Let’s have a think about how we want support for multiple lists
to work.
At the moment the only URL for our site is the homepage, and
that’s why there’s only one global list. The most obvious way to
support multiple lists is to say that each list gets its own URL, so
that people can start multiple lists, or so that diﬀerent people
can have diﬀerent lists. How might that work?
Not Big Design Up Front
TDD is closely associated with the agile movement in software
development, which includes a reaction against Big Design Up
Front, the traditional software engineering practice whereby,
after a lengthy requirements gathering exercise, there is an
equally lengthy design stage where the software is planned out
on paper. The agile philosophy is that you learn more from
solving problems in practice than in theory, especially when
you confront your application with real users as soon as
possible. Instead of a long up-front design phase, we try to put a
minimum viable application out there early, and let the design
evolve gradually based on feedback from real-world usage.

But that doesn’t mean that thinking about design is outright
banned! In the last big chapter we saw how just blundering
ahead without thinking can eventually get us to the right
answer, but often a little thinking about design can help us get
there faster. So, let’s think about our minimum viable lists app,
and what kind of design we’ll need to deliver it:
We want each user to be able to store their own list— at least
one, for now.
A list is made up of several items, whose primary attribute is
a bit of descriptive text.
We need to save lists from one visit to the next. For now, we
can give each user a unique URL for their list. Later on we
may want some way of automatically recognising users and
showing them their lists.
To deliver the “for now” items, we’re going to have to store lists
and their items in a database. Each list will have a unique URL,
and each list item will be a bit of descriptive text, associated
with a particular list.
YAGNI!
Once you start thinking about design, it can be hard to stop. All
sorts of other thoughts are occurring to us— we might want to

give each list a name or title, we might want to recognise users
using usernames and passwords, we might want to add a longer
notes ﬁeld as well as short descriptions to our list, we might
want to store some kind of ordering, and so on. But we should
obey another tenet of the agile gospel: “YAGNI” (pronounced
yag-knee), which stands for “You ain’t gonna need it!” As
software developers, we have fun creating things, and
sometimes it’s hard to resist the urge to build things just
because an idea occurred to us and we might need it. The
trouble is that more often than not, no matter how cool the idea
was, you won’t end up using it. Instead you have a load of
unused code, adding to the complexity of your application.
YAGNI is the mantra we use to resist our overenthusiastic
creative urges.
REST (ish)
We have an idea of the data structure we want— the Model part
of Model-View-Controller (MVC). What about the View and
Controller parts? How should the user interact with List s and
their Item s using a web browser?
Representational State Transfer (REST) is an approach to web
design that’s usually used to guide the design of web-based APIs.

When designing a user-facing site, it’s not possible to stick
strictly to the REST rules, but they still provide some useful
inspiration (skip ahead to [Link to Come] if you want to see a
real REST API).
REST suggests that we have a URL structure that matches our
data structure, in this case lists and list items. Each list can have
its own URL:
    /lists/<list identifier>/
That will fulﬁll the requirement we’ve speciﬁed in our FT. To
view a list, we use a GET request (a normal browser visit to the
page).
To create a brand new list, we’ll have a special URL that accepts
POST requests:
    /lists/new
To add a new item to an existing list, we’ll have a separate URL,
to which we can send POST requests:
    /lists/<list identifier>/add_item

(Again, we’re not trying to perfectly follow the rules of REST,
which would use a PUT request here— we’re just using REST for
inspiration. Apart from anything else, you can’t use PUT in a
standard HTML form.)
In summary, our scratchpad for this chapter looks something
like this:
Adjust model so that items are associated with diﬀerent lists
Add unique URLs for each list
Add a URL for creating a new list via POST
Add URLs for adding a new item to an existing list via POST
Implementing the New Design
Incrementally Using TDD
How do we use TDD to implement the new design? Let’s take
another look at the ﬂowchart for the TDD process in Figure 7-1.
At the top level, we’re going to use a combination of adding new
functionality (by adding a new FT and writing new application
code), and refactoring our application— that is, rewriting some

of the existing implementation so that it delivers the same
functionality to the user but using aspects of our new design.
We’ll be able to use the existing functional test to verify we
don’t break what already works, and the new functional test to
drive the new features.
At the unit test level, we’ll be adding new tests or modifying
existing ones to test for the changes we want, and we’ll be able
to similarly use the unit tests we don’t touch to help make sure
we don’t break anything in the process.


Figure 7-1. The TDD Process With Both Functional and Unit Tests
Ensuring We Have a Regression
Test
Let’s translate our scratchpad into a new functional test
method, which introduces a second user and checks that their
to-do list is separate from Edith’s.
We’ll start out very similarly to the ﬁrst. Edith adds a ﬁrst item
to create a to-do list, but we introduce our ﬁrst new assertion—
Edith’s list should live at its own, unique URL:
functional_tests/tests.py (ch07l005)
def test_can_start_a_todo_list(self):
    # Edith has heard about a cool new online to-do a
    [...]
    # Satisfied, she goes back to sleep
def test_multiple_users_can_start_lists_at_different_
    # Edith starts a new to-do list
    self.browser.get(self.live_server_url)
    inputbox = self.browser.find_element(By.ID, "id_n
    inputbox.send_keys("Buy peacock feathers")

assertRegex  is a helper function from unittest  that
checks whether a string matches a regular expression. We
use it to check that our new REST-ish design has been
implemented. Find out more in the unittest
documentation.
Next we imagine a new user coming along. We want to check
that they don’t see any of Edith’s items when they visit the
home page, and that they get their own unique URL for their
list:
functional_tests/tests.py (ch07l006)
    inputbox.send_keys(Keys.ENTER)
    self.wait_for_row_in_list_table("1: Buy peacock f
    # She notices that her list has a unique URL
    edith_list_url = self.browser.current_url
    self.assertRegex(edith_list_url, "/lists/.+")  
    [...]
    self.assertRegex(edith_list_url, "/lists/.+")
    # Now a new user, Francis, comes along to the sit
    ## We delete all the browser's cookies

    ## as a way of simulating a brand new user sessio
    self.browser.delete_all_cookies()
    # Francis visits the home page.  There is no sign
    # list
    self.browser.get(self.live_server_url)
    page_text = self.browser.find_element(By.TAG_NAME
    self.assertNotIn("Buy peacock feathers", page_tex
    self.assertNotIn("make a fly", page_text)
    # Francis starts a new list by entering a new ite
    # is less interesting than Edith...
    inputbox = self.browser.find_element(By.ID, "id_n
    inputbox.send_keys("Buy milk")
    inputbox.send_keys(Keys.ENTER)
    self.wait_for_row_in_list_table("1: Buy milk")
    # Francis gets his own unique URL
    francis_list_url = self.browser.current_url
    self.assertRegex(francis_list_url, "/lists/.+")
    self.assertNotEqual(francis_list_url, edith_list_
    # Again, there is no trace of Edith's list
    page_text = self.browser.find_element(By.TAG_NAME
    self.assertNotIn("Buy peacock feathers", page_tex
    self.assertIn("Buy milk", page_text)
    # Satisfied, they both go back to sleep

I’m using the convention of double-hashes ( ## ) to indicate
“meta-comments”—comments about how the test is working
and why— so that we can distinguish them from regular
comments in FTs which explain the User Story. They’re a
message to our future selves, which might otherwise be
wondering why we’re faﬃng about deleting cookies… 
Other than that, the new test is fairly self-explanatory. Let’s see
how we do when we run our FTs:
$ python manage.py test functional_tests 
[...] 
.F 
=====================================================
FAIL: test_multiple_users_can_start_lists_at_differen
ests.NewVisitorTest.test_multiple_users_can_start_lis
 
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests/tests.py", line
test_multiple_users_can_start_lists_at_different_urls
    self.assertRegex(edith_list_url, "/lists/.+") 
AssertionError: Regex didn't match: '/lists/.+' not f
'http://localhost:8081/' 
 
 ----------------------------------------------------

Good, our ﬁrst test still passes, and the second one fails where
we might expect. Let’s do a commit, and then go and build some
new models and views:
$ git commit -a
Iterating Towards the New Design
Being all excited about our new design, I had an overwhelming
urge to dive in at this point and start changing models.py, which
would have broken half the unit tests, and then pile in and
change almost every single line of code, all in one go. That’s a
natural urge, and TDD, as a discipline, is a constant ﬁght against
it. Obey the Testing Goat, not Refactoring Cat! We don’t need to
implement our new, shiny design in a single big bang. Let’s
make small changes that take us from a working state to a
working state, with our design guiding us gently at each stage.
Ran 2 tests in 5.786s 
 
FAILED (failures=1)

There are four items on our to-do list. The FT, with its Regex
didn't match  error, is suggesting to us that the second item— 
giving lists their own URL and identiﬁer— is the one we should
work on next. Let’s have a go at ﬁxing that, and only that.
The URL comes from the redirect after POST. In lists/tests.py,
let’s ﬁnd test_redirects_after_POST , and change the
expected redirect location:
lists/tests.py (ch07l007)
Does that seem slightly strange? Clearly, /lists/the-only-list-in-the-
world isn’t a URL that’s going to feature in the ﬁnal design of our
application. But we’re committed to changing one thing at a
time. While our application only supports one list, this is the
only URL that makes sense. We’re still moving forwards, in that
we’ll have a diﬀerent URL for our list and our home page, which
is a step along the way to a more REST-ful design. Later, when
we have multiple lists, it will be easy to change.
def test_redirects_after_POST(self): 
    response = self.client.post("/", data={"item_text
    self.assertRedirects(response, "/lists/the-only-l

NOTE
Another way of thinking about it is as a problem-solving technique: our new URL
design is currently not implemented, so it works for 0 items. Ultimately, we want to
solve for n items, but solving for 1 item is a good step along the way.
Running the unit tests gives us an expected fail:
We can go adjust our home_page  view in lists/views.py:
lists/views.py (ch07l008)
$ python manage.py test lists 
[...] 
AssertionError: '/' != '/lists/the-only-list-in-the-w
[...]
def home_page(request): 
    if request.method == "POST": 
        Item.objects.create(text=request.POST["item_t
        return redirect("/lists/the-only-list-in-the-
 
    items = Item.objects.all() 
    return render(request, "home.html", {"items": ite

Django’s unit test runner picks up on the fact that this is not a
real URL yet:
Taking a First, Self-Contained Step:
One New URL
Our singleton list URL doesn’t exist yet. We ﬁx that in
superlists/urls.py.
superlists/urls.py (ch07l009)
$ python3 manage.py test lists 
[...] 
AssertionError: 404 != 200 : Couldn't retrieve redire
'/lists/the-only-list-in-the-world/': response code w
from django.urls import path
from lists import views
urlpatterns = [
    path("", views.home_page, name="home"),
    path("lists/the-only-list-in-the-world/", views.h
]

We’ll just point our new URL at the existing home page view.
This is the minimal change.
TIP
Watch out for trailing slashes in URLs, both here in urls.py and in the tests. They’re a
common source of bugs.
That gets our unit tests passing:
$ python3 manage.py test lists 
[...] 
OK
What do the FTs think?
Good, they get a little further along, we now conﬁrm that we
have a new URL, but the actual page content is still the same, it
$ python3 manage.py test functional_tests 
[...] 
AssertionError: 'Buy peacock feathers' unexpectedly f
list\n1: Buy peacock feathers'

shows the old list.
Separating out our home page and list
view functionality
We now have two URLs, but they’re actually doing the exact
same thing. Under the hood, they’re just pointing at the same
function. Continuing to work incrementally, we can start to
break apart the responsibilities for these two diﬀerent URLs:
the home page only needs to display and react to creating a
brand new list based on its ﬁrst item.
the list view page needs to be able to display existing list
items and add new items to the list
Let’s split out some tests for our new URL.
Open up lists/tests.py, and add a new test class called
ListViewTest . Then move the method called
test_displays_all_list_items  across from HomePageTest
into our new class, changing just the URL that is invoked by
self.client.get() :
lists/tests.py (ch07l010)
class HomePageTest(TestCase): 
(
)

Let’s try running this test now:
$ python3 manage.py test lists 
OK
It passes, because the URL is still pointing at the home_page
view.
Let’s make it point at a new view:
superlists/urls.py (ch07l011)
    def test_uses_home_template(self): 
        [...] 
    def test_can_save_a_POST_request(self): 
        [...] 
    def test_redirects_after_POST(self): 
        [...] 
 
 
class ListViewTest(TestCase): 
    def test_displays_all_list_items(self): 
        Item.objects.create(text="itemey 1") 
        Item.objects.create(text="itemey 2") 
        response = self.client.get("/lists/the-only-l
        self.assertContains(response, "itemey 1") 
        self.assertContains(response, "itemey 2")

That predictably fails because there is no such view function
yet:
A New View Function
Fair enough. Let’s create a dummy view function in
lists/views.py:
lists/views.py (ch07l012-0)
from django.urls import path
from lists import views 
 
urlpatterns = [ 
    path("", views.home_page, name="home"), 
    path("lists/the-only-list-in-the-world/", views.v
]
$ python3 manage.py test lists 
[...] 
    path("lists/the-only-list-in-the-world/", views.v
name="view_list"), 
                                              ^^^^^^^
AttributeError: module 'lists.views' has no attribute

def view_list(request): 
    pass
Not quite good enough:
Looking for the minimal code change, let’s just make the view
return our existing home.html template, but with nothing in it:
lists/views.py (ch07l012-1)
def view_list(request): 
    return render(request, "home.html")
Now the tests guide us to making sure that our list view shows
existing list items:
ValueError: The view lists.views.view_list didn't ret
object. It returned None instead. 
 
[...] 
FAILED (errors=2)
AssertionError: False is not true : Couldn't find 'it

So let’s copy the last two lines from home_page  more directly:
lists/views.py (ch07l012)
That gets us to passing unit tests!
Ran 6 tests in 0.035s 
 
OK
The FTs detect a regression
As always when we get to passing unit tests, we run the
functional tests to check how things are doing “in real life”:
def view_list(request): 
    items = Item.objects.all() 
    return render(request, "home.html", {"items": ite
$ python manage.py test functional_tests 
[...] 
FF 
=====================================================

Not only is our new test failing, but the old one is too. That tells
us we’ve introduced a regression.
What are they trying to tell us?
FAIL: test_can_start_a_todo_list 
(functional_tests.tests.NewVisitorTest.test_can_start
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests/tests.py", line
test_can_start_a_todo_list 
[...] 
AssertionError: '2: Use peacock feathers to make a fl
peacock feathers'] 
 
=====================================================
FAIL: test_multiple_users_can_start_lists_at_differen
ests.NewVisitorTest.test_multiple_users_can_start_lis
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests/tests.py", line
test_multiple_users_can_start_lists_at_different_urls
    self.assertNotIn("Buy peacock feathers", page_tex
AssertionError: 'Buy peacock feathers' unexpectedly f
list\n1: Buy peacock feathers'

Both tests are failing when we try to add the second item. We
have to put our debugging hats on here. We know the home
page is working, because the test has got all the way down to
line 63 in the ﬁrst FT, so we’ve at least added a ﬁrst item. And
our unit tests are all passing, so we’re pretty sure the URLs and
views that we do have are doing what they should. Let’s have a
quick look at those unit tests to see what they tell us:
The home page displays the right template, and can handle
POST requests, and the /only-list-in-the-world/ view knows how
to display all items… but it doesn’t know how to handle POST
requests. Ah, that gives us a clue.
$ grep -E "class|def" lists/tests.py 
class HomePageTest(TestCase): 
    def test_uses_home_template(self): 
    def test_can_save_a_POST_request(self): 
    def test_redirects_after_POST(self): 
    def test_only_saves_items_when_necessary(self): 
class ListViewTest(TestCase): 
    def test_displays_all_list_items(self): 
class ItemModelTest(TestCase): 
    def test_saving_and_retrieving_items(self):

A second clue is the rule of thumb that, when all the unit tests
are passing but the functional tests aren’t, it’s often pointing at a
problem that’s not covered by the unit tests, and in our case,
that’s often a template problem.
The answer is that our home.html input form currently doesn’t
specify an explicit URL to POST to:
lists/templates/home.html
        <form method="POST">
By default the browser sends the POST data back to the same
URL it’s currently on. When we’re on the home page that works
ﬁne, but when we’re on our /only-list-in-the-world/ page, it
doesn’t.
Getting Back to a Working State as Quickly
as Possible
Now we could dive in and add POST request handling to our
new view, but that would involve writing a bunch more tests
and code, and at this point we’d like to get back to a working
state as quickly as possible. Actually the quickest thing we can

do to get things ﬁxed is to just use the existing home page view,
which already works, for all POST requests:
lists/templates/home.html (ch07l013)
    <form method="POST" action="/">
Try that, and we’ll see our FTs get back to a happier place:
Our regression test passes once again, so we know we’re back to
a working state. The new functionality may not be working yet,
but at least the old stuﬀ works as well as it used to.
Green? Refactor
Time for a little tidying up.
FAIL: test_multiple_users_can_start_lists_at_differen
ests.NewVisitorTest.test_multiple_users_can_start_lis
[...] 
AssertionError: 'Buy peacock feathers' unexpectedly f
list\n1: Buy peacock feathers' 
 
Ran 2 tests in 8.541s 
FAILED (failures=1)

In the Red/Green/Refactor dance, we’ve arrived at green, so we
should see what needs a refactor. We now have two views, one
for the home page, and one for an individual list. Both are
currently using the same template, and passing it all the list
items currently in the database. Post requests are only handled
by the home page though.
It feels like the responsibilities of our two views are a little
tangled up. Let’s try and disentangle them a little.
Another Small Step: A Separate
Template for Viewing Lists
Since the home page and the list view are now quite distinct
pages, they should be using diﬀerent HTML templates;
home.html can have the single input box, whereas a new
template, list.html, can take care of showing the table of existing
items.
Let’s add a new test to check that it’s using a diﬀerent template:
lists/tests.py (ch07l014)
class ListViewTest(TestCase): 
def test uses list template(self):

Let’s see what it says:
Looks about right, let’s change the view:
lists/views.py (ch07l015)
But, obviously, that template doesn’t exist yet. If we run the unit
tests, we get:
    def test_uses_list_template(self): 
        response = self.client.get("/lists/the-only-l
        self.assertTemplateUsed(response, "list.html"
 
    def test_displays_all_list_items(self): 
        [...]
AssertionError: False is not true : Template 'list.ht
used to render the response. Actual template(s) used:
def view_list(request): 
    items = Item.objects.all() 
    return render(request, "list.html", {"items": ite
django.template.exceptions.TemplateDoesNotExist: list

Let’s create a new ﬁle at lists/templates/list.html:
$ touch lists/templates/list.html
A blank template, which gives us this error— good to know the
tests are there to make sure we ﬁll it in:
The template for an individual list will reuse quite a lot of the
stuﬀ we currently have in home.html, so we can start by just
copying that:
That gets the tests back to passing (green).
$ python manage.py test lists 
[...] 
OK
Now let’s do a little more tidying up (refactoring). We said the
home page doesn’t need to list items, it only needs the new list
AssertionError: False is not true : Couldn't find 'it
$ cp lists/templates/home.html lists/templates/li

input ﬁeld, so we can remove some lines from
lists/templates/home.html, and maybe slightly tweak the h1  to
say “Start a new To-Do list”:
I’ll present the code change as a diﬀ, which hopefully shows a
bit more clearly what we need to modify:
lists/templates/home.html (ch07l018)
We rerun the unit tests to check that hasn’t broken anything… 
OK
   <body>
-    <h1>Your To-Do list</h1>
+    <h1>Start a new To-Do list</h1>
     <form method="POST" action="/">
       <input name="item_text" id="id_new_item" place
       {% csrf_token %}
     </form>
-    <table id="id_list_table">
-      {% for item in items %}
-        <tr><td>{{ forloop.counter }}: {{ item.text 
-      {% endfor %}
-    </table>
   </body>

Good.
Now there’s actually no need to pass all the items to the
home.html template in our home_page  view, so we can simplify
that and delete a couple of lines:
lists/views.py (ch07l019)
Rerun the unit tests once more; they still pass:
OK
Time to run the functional tests:
     if request.method == "POST":
         Item.objects.create(text=request.POST["item_
         return redirect("/lists/the-only-list-in-the
-
-    items = Item.objects.all()
-    return render(request, "home.html", {"items": it
+    return render(request, "home.html")
AssertionError: '1: Buy milk' not found in ['1: Buy p
milk']

Not bad! Our regression test (the ﬁrst FT) is passing, and our
new test is now getting slightly further forwards— it’s telling us
that Francis isn’t getting his own list page (because he still sees
some of Edith’s list items).
It may feel like we haven’t made much headway since,
functionally, the site still behaves almost exactly like it did when
we started the chapter, but this really is progress. We’ve started
on the road to our new design, and we’ve implemented a
number of stepping stones without making anything worse than
it was before. Let’s commit our progress so far:
$ git status # should show 5 changed files and 1 new
$ git add lists/templates/list.html 
$ git diff # should show we've simplified home.html, 
           # moved one test to a new class in lists/t
           # in views.py, and simplified home_page an
           # moved one test to a new class in lists/t
           # added a new view and simplified home_pag
           # and added a line to urls.py. 
$ git commit -a # add a message summarising the abov
                # "new URL, view and template to disp

A Third Small Step: A New URL for
Adding List Items
Where are we with our own to-do list?
Adjust model so that items are associated with diﬀerent lists
Add unique URLs for each list … 
Add a URL for creating a new list via POST
Add URLs for adding a new item to an existing list via POST
We’ve sort of made progress on the second item, even if there’s
still only one list in the world. The ﬁrst item is a bit scary. Can
we do something about items 3 or 4?
Let’s have a new URL for adding new list items at /lists/new: If
nothing else, it’ll simplify the home page view.
A Test Class for New List Creation
Open up lists/tests.py, and move the
test_can_save_a_POST_request  and

test_redirects_after_POST  methods into a new class, then
change the URL they POST to:
lists/tests.py (ch07l020)
TIP
This is another place to pay attention to trailing slashes, incidentally. It’s
/lists/new , with no trailing slash. The convention I’m using is that URLs without a
trailing slash are “action” URLs which modify the database.
Try running that:
class NewListTest(TestCase): 
    def test_can_save_a_POST_request(self): 
        self.client.post("/lists/new", data={"item_te
        self.assertEqual(Item.objects.count(), 1) 
        new_item = Item.objects.get() 
        self.assertEqual(new_item.text, "A new list i
 
    def test_redirects_after_POST(self): 
        response = self.client.post("/lists/new", dat
        self.assertRedirects(response, "/lists/the-on
    self.assertEqual(Item.objects.count(), 1) 
AssertionError: 0 != 1 

The ﬁrst failure tells us we’re not saving a new item to the
database, and the second says that, instead of returning a 302
redirect, our view is returning a 404. That’s because we haven’t
built a URL for /lists/new, so the client.post  is just getting a
“not found” response.
NOTE
Do you remember how we split this out into two tests earlier? If we only had one
test that checked both the saving and the redirect, it would have failed on the 0 !=
1  failure, which would have been much harder to debug. Ask me how I know this.
A URL and View for New List Creation
Let’s build our new URL now:
superlists/urls.py (ch07l021)
[...] 
    self.assertRedirects(response, "/lists/the-only-l
[...] 
AssertionError: 404 != 302 : Response didn't redirect
code was 404 (expected 302)
urlpatterns = [ 
    path("", views.home_page, name="home"), 

Next we get a no attribute 'new_list' , so let’s ﬁx that, in
lists/views.py:
lists/views.py (ch07l022)
def new_list(request): 
    pass
Then we get “The view lists.views.new_list didn’t return an
HttpResponse object”. (This is getting rather familiar!) We could
return a raw HttpResponse , but since we know we’ll need a
redirect, let’s borrow a line from home_page :
lists/views.py (ch07l023)
That gives:
    path("lists/new", views.new_list, name="new_list"
    path("lists/the-only-list-in-the-world/", views.v
]
def new_list(request): 
    return redirect("/lists/the-only-list-in-the-worl

    self.assertEqual(Item.objects.count(), 1) 
AssertionError: 0 != 1
Seems reasonably straightforward. We borrow another line
from home_page :
lists/views.py (ch07l024)
And everything now passes:
Ran 7 tests in 0.030s 
 
OK
And we can run the FTs to check that we’re still in the same
place: our regression test passes, and the new FT gets to the
same point.
def new_list(request): 
    Item.objects.create(text=request.POST["item_text"
    return redirect("/lists/the-only-list-in-the-worl
[...] 
AssertionError: '1: Buy milk' not found in ['1: Buy p

Removing Now-Redundant Code and Tests
We’re looking good. Since our new views are now doing most of
the work that home_page  used to do, we should be able to
massively simplify it. Can we remove the whole if
request.method == 'POST'  section, for example?
lists/views.py (ch07l025)
def home_page(request): 
    return render(request, "home.html")
Yep! The unit tests pass:
OK
And while we’re at it, we can remove the now-redundant
test_only_saves_ items_when_necessary  test too!
Doesn’t that feel good? The view functions are looking much
simpler. We rerun the tests to make sure… 
milk'] 
Ran 2 tests in 8.972s 
FAILED (failures=1)

Ran 6 tests in 0.016s 
OK
and the FTs?
A Regression! Pointing Our Forms at the
New URL
Oops. When we run the FTs:
ERROR: test_can_start_a_todo_list 
[...] 
  File "...goat-book/functional_tests/tests.py", line
test_can_start_a_todo_list 
[...] 
    self.wait_for_row_in_list_table("1: Buy peacock f
[...] 
    table = self.browser.find_element(By.ID, "id_list
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[...] 
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_list_table"]; For documentation [...
 
ERROR: test_multiple_users_can_start_lists_at_differe
tests.NewVisitorTest.test_multiple_users_can_start_li
[...] 

Once again, the FTs pick up a tricky little bug, something that
our unit tests alone would ﬁnd it hard to catch.
It’s because our forms are still pointing to the old URL. In both
home.html and lists.html, let’s change them to:
lists/templates/home.html, lists/templates/list.html
    <form method="POST" action="/lists/new">
And that should get us back to working again:
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_list_table"]; For documentation [...
[...] 
 
Ran 2 tests in 11.592s 
FAILED (errors=2)
AssertionError: '1: Buy milk' not found in ['1: Buy p
milk'] 
[...] 
FAILED (failures=1)

That’s another nicely self-contained commit, in that we’ve made
a bunch of changes to our URLs, our views.py is looking much
neater and tidier, and we’re sure the application is still working
as well as it was before. We’re getting good at this working-
state-to-working-state malarkey!
And we can cross out an item on the to-do list:
Adjust model so that items are associated with diﬀerent lists
Add unique URLs for each list
Add a URL for creating a new list via POST
Add URLs for adding a new item to an existing list via POST
Biting the Bullet: Adjusting Our
Models
$ git status # 5 changed files 
$ git diff # URLs for forms x2, moved code in views 
$ git commit -a

Enough housekeeping with our URLs. It’s time to bite the bullet
and change our models. Let’s adjust the model unit test. Again,
I’ll use a diﬀ to show you the changes:
lists/tests.py (ch07l029)
@@ -1,5 +1,5 @@
 from django.test import TestCase
-from lists.models import Item
+from lists.models import Item, List 
 
 
 class HomePageTest(TestCase):
@@ -35,20 +35,30 @@ class ListViewTest(TestCase):
         self.assertContains(response, "itemey 2") 
 
 
-class ItemModelTest(TestCase):
+class ListAndItemModelsTest(TestCase):
     def test_saving_and_retrieving_items(self):
+        mylist = List()
+        mylist.save()
+
         first_item = Item()
         first_item.text = "The first (ever) list ite
+        first_item.list = mylist
         first_item.save() 
 

We create a new List  object and then we assign each item to it
by setting it as its .list  property. We check that the list is
properly saved, and we check that the two items have also
saved their relationship to the list. You’ll also notice that we can
compare list objects with each other directly ( saved_list  and
mylist )—behind the scenes, these will compare themselves by
checking that their primary key (the .id  attribute) is the same.
         second_item = Item()
         second_item.text = "Item the second"
+        second_item.list = mylist
         second_item.save() 
 
+        saved_list = List.objects.get()
+        self.assertEqual(saved_list, mylist)
+
         saved_items = Item.objects.all()
         self.assertEqual(saved_items.count(), 2) 
 
         first_saved_item = saved_items[0]
         second_saved_item = saved_items[1]
         self.assertEqual(first_saved_item.text, "The
+        self.assertEqual(first_saved_item.list, myli
         self.assertEqual(second_saved_item.text, "It
+        self.assertEqual(second_saved_item.list, myl

Time for another unit-test/code cycle.
For the ﬁrst couple of iterations, rather than explicitly showing
you what code to enter in between every test run, I’m only
going to show you the expected error messages from running
the tests. I’ll let you ﬁgure out what each minimal code change
should be, on your own.
TIP
Need a hint? Go back and take a look at the steps we took to introduce the Item
model in the chapter before last.
Your ﬁrst error should be:
Fix that, and then you should see:
Next you should see:
ImportError: cannot import name 'List' from 'lists.mo
AttributeError: 'List' object has no attribute 'save'
django.db.utils.OperationalError: no such table: list

So we run a makemigrations :
$ python manage.py makemigrations 
Migrations for 'lists': 
  lists/migrations/0003_list.py 
    - Create model List
And then you should see:
A Foreign Key Relationship
How do we give our Item  a list attribute? Let’s just try naively
making it like the text  attribute (and here’s your chance to see
whether your solution so far looks like mine, by the way):
lists/models.py (ch07l033)
from django.db import models 
 
 
class List(models.Model): 
    self.assertEqual(first_saved_item.list, mylist) 
AttributeError: 'Item' object has no attribute 'list'

    pass 
 
 
class Item(models.Model): 
    text = models.TextField(default="") 
    list = models.TextField(default="")
As usual, the tests tell us we need a migration:
Let’s see what that gives us:
We’re not quite there. Look closely at each side of the != . Do
you see the quotes ( ' )? Django has only saved the string
$ python manage.py test lists 
[...] 
django.db.utils.OperationalError: no such column: lis
 
$ python manage.py makemigrations 
Migrations for 'lists': 
  lists/migrations/0004_item_list.py 
    - Add field list to item
AssertionError: 'List object (1)' != <List: List obje

representation of the List  object. To save the relationship to
the object itself, we tell Django about the relationship between
the two classes using a ForeignKey :
lists/models.py (ch07l035)
That’ll need a migration too. Since the last one was a red
herring, let’s delete it and replace it with a new one:
$ rm lists/migrations/0004_item_list.py 
$ python manage.py makemigrations 
Migrations for 'lists': 
  lists/migrations/0004_item_list.py 
    - Add field list to item
class Item(models.Model): 
    text = models.TextField(default="") 
    list = models.ForeignKey(List, default=None, on_d

WARNING
Deleting migrations is dangerous. Now and again it’s nice to do it to keep things tidy,
because we don’t always get our models code right on the ﬁrst go! But if you delete a
migration that’s already been applied to a database somewhere, Django will be
confused about what state it’s in, and won’t be able to apply future migrations. You
should only do it when you’re sure the migration hasn’t been used. A good rule of
thumb is that you should never delete or modify a migration that’s already been
committed to your VCS.
Adjusting the Rest of the World to Our New
Models
Back in our tests, now what happens?
$ python manage.py test lists 
[...] 
ERROR: test_displays_all_list_items 
django.db.utils.IntegrityError: NOT NULL constraint f
[...] 
ERROR: test_redirects_after_POST 
django.db.utils.IntegrityError: NOT NULL constraint f
[...] 
ERROR: test_can_save_a_POST_request 
django.db.utils.IntegrityError: NOT NULL constraint f
 
Ran 6 tests in 0.021s 

Oh dear!
There is some good news. Although it’s hard to see, our model
tests are passing. But three of our view tests are failing nastily.
The cause is the new relationship we’ve introduced between
Item s and List s, which requires each item to have a parent
list, and which our old tests and code aren’t prepared for.
Still, this is exactly why we have tests! Let’s get them working
again. The easiest is the ListViewTest ; we just create a parent
list for our two test items:
lists/tests.py (ch07l038)
 
FAILED (errors=3)
class ListViewTest(TestCase): 
    [...] 
    def test_displays_all_list_items(self): 
        mylist = List.objects.create() 
        Item.objects.create(text="itemey 1", list=myl
        Item.objects.create(text="itemey 2", list=myl

That gets us down to two failing tests, both on tests that try to
POST to our new_list  view. Decoding the tracebacks using our
usual technique, working back from error to line of test code to,
buried in there somewhere, the line of our own code that
caused the failure:
It’s when we try to create an item without a parent list. So we
make a similar change in the view:
lists/views.py (ch07l039)
  File "...goat-book/lists/tests.py", line 19, in tes
    response = self.client.post("/lists/new", data={"
item"}) 
[...] 
  File "...goat-book/lists/views.py", line 10, in new
    Item.objects.create(text=request.POST["item_text"
from lists.models import Item, List
[...] 
 
def new_list(request): 
    nulist = List.objects.create() 
    Item.objects.create(text=request.POST["item_text"
    return redirect("/lists/the-only-list-in-the-worl

And that
gets our tests passing again:
Ran 6 tests in 0.030s 
 
OK
Are you cringing internally at this point? Arg! This feels so
wrong; we create a new list for every single new item submission,
and we’re still just displaying all items as if they belong to the
same list! I know, I feel the same. The step-by-step approach, in
which you go from working code to working code, is
counterintuitive. I always feel like just diving in and trying to ﬁx
everything all in one go, instead of going from one weird half-
ﬁnished state to another. But remember the Testing Goat! When
you’re up a mountain, you want to think very carefully about
where you put each foot, and take one step at a time, checking
at each stage that the place you’ve put it hasn’t caused you to
fall oﬀ a cliﬀ.
So just to reassure ourselves that things have worked, we rerun
the FT:
1

Sure enough, it gets all the way through to where we were
before. We haven’t broken anything, and we’ve made a big
change to the database. That’s something to be pleased with!
Let’s commit:
$ git status # 3 changed files, plus 2 migrations 
$ git add lists 
$ git diff --staged 
$ git commit
And we can cross out another item on the to-do list:
Adjust model so that items are associated with diﬀerent lists
Add unique URLs for each list
Add a URL for creating a new list via POST
Add URLs for adding a new item to an existing list via POST
Each List Should Have Its Own URL
AssertionError: '1: Buy milk' not found in ['1: Buy p
milk'] 
[...]

We can get rid of the silly the-only-list-in-the-world  URL,
but what shall we use as the unique identiﬁer for our lists?
Probably the simplest thing, for now, is just to use the auto-
generated id  ﬁeld from the database. Let’s change
ListViewTest  so that the two tests point at new URLs.
We’ll also change the old test_displays_all_list_items  test
and call it test_displays_only_items_for_that_list  instead,
making it check that only the items for a speciﬁc list are
displayed:
lists/tests.py (ch07l040)
class ListViewTest(TestCase): 
    def test_uses_list_template(self): 
        mylist = List.objects.create() 
        response = self.client.get(f"/lists/{mylist.i
        self.assertTemplateUsed(response, "list.html"
 
    def test_displays_only_items_for_that_list(self):
        correct_list = List.objects.create() 
        Item.objects.create(text="itemey 1", list=cor
        Item.objects.create(text="itemey 2", list=cor
        other_list = List.objects.create() 
        Item.objects.create(text="other list item", l
 
        response = self.client.get(f"/lists/{correct_

NOTE
Are you wondering about the line spacing in the test? I’m grouping together ﬁve
lines at the beginning which set up the test, one line in the middle which actually
calls the code under test, and the assertions at the end. This isn’t obligatory, but it
does help see the structure of the test. Some people refer to this structure as
Arrange-Act-Assert, or Given-When-Then: Given the database contains our list with
two items, and another list, When I make a GET request for our list, Then I see the
items in our list, but not the items in the other list.
Running the unit tests gives an expected 404, and another
related error:
Capturing Parameters from URLs
 
        self.assertContains(response, "itemey 1") 
        self.assertContains(response, "itemey 2") 
        self.assertNotContains(response, "other list 
FAIL: test_displays_only_items_for_that_list 
AssertionError: 404 != 200 : Couldn't retrieve conten
(expected 200) 
[...] 
FAIL: test_uses_list_template 
AssertionError: No templates used to render the respo

It’s time to learn how we can pass parameters from URLs to
views:
superlists/urls.py (ch07l041-0)
We adjust the regular expression for our URL to include a
capture group, <int:list_id> , which will match any
numerical characters, up to the following / , The captured id
will get passed to the view as an argument.
In other words, if we go to the URL /lists/1/, view_list  will get a
second argument after the normal request  argument, namely
the integer 1 .
But our view doesn’t expect an argument yet! Sure enough, this
causes problems:
urlpatterns = [ 
    path("", views.home_page, name="home"), 
    path("lists/new", views.new_list, name="new_list"
    path("lists/<int:list_id>/", views.view_list, nam
]
ERROR: test_displays_only_items_for_that_list 
[...] 
TypeError: view_list() got an unexpected keyword argu

We can ﬁx that easily with a dummy parameter in views.py:
lists/views.py (ch07l041)
def view_list(request, list_id): 
    [...]
That takes us down to our expected failure, plus an only-list-in-
the-world that’s still hanging around somewhere, which I’m
sure we can ﬁx later.
[...] 
ERROR: test_uses_list_template 
[...] 
TypeError: view_list() got an unexpected keyword argu
[...] 
FAIL: test_redirects_after_POST 
[...] 
AssertionError: 404 != 200 : Couldn't retrieve redire
'/lists/the-only-list-in-the-world/': response code w
[...] 
FAILED (failures=1, errors=2)
FAIL: test_displays_only_items_for_that_list 
[...] 
AssertionError: 1 !
0 : Response should not contain

Let’s make our list view discriminate over which items it sends
to the template:
lists/views.py (ch07l042)
Adjusting new_list to the New World
It’s time to address the only-list-in-the-world failure:
AssertionError: 1 != 0 : Response should not contain 
[...] 
FAIL: test_redirects_after_POST 
AssertionError: 404 != 200 : Couldn't retrieve redire
'/lists/the-only-list-in-the-world/': response code w
def view_list(request, list_id): 
    our_list = List.objects.get(id=list_id) 
    items = Item.objects.filter(list=our_list) 
    return render(request, "list.html", {"items": ite
FAIL: test_redirects_after_POST 
[...] 

Let’s have a little look and ﬁnd the test that’s moaning:
lists/tests.py
It looks like it hasn’t been adjusted to the new world of List s
and Item s. The test should be saying that this view redirects to
the URL of the speciﬁc new list it just created.
lists/tests.py (ch07l043)
AssertionError: 404 != 200 : Couldn't retrieve redire
'/lists/the-only-list-in-the-world/': response code w
class NewListTest(TestCase): 
    [...] 
 
    def test_redirects_after_POST(self): 
        response = self.client.post("/lists/new", dat
        self.assertRedirects(response, "/lists/the-on
    def test_redirects_after_POST(self): 
        response = self.client.post("/lists/new", dat
        new_list = List.objects.get() 
        self.assertRedirects(response, f"/lists/{new_

The test still fails, but we can now take a look at the view itself,
and change it so it redirects to the right place:
lists/views.py (ch07l044)
That gets us back to passing unit tests:
What about the functional tests? We must be almost there?
def new_list(request): 
    nulist = List.objects.create() 
    Item.objects.create(text=request.POST["item_text"
    return redirect(f"/lists/{nulist.id}/")
$ python3 manage.py test lists 
[...] 
...... 
 ----------------------------------------------------
Ran 6 tests in 0.033s 
 
OK

The Functional Tests Detect
Another Regression
Well, almost. When we run the FTs, we get:
Our new FT is actually passing: diﬀerent users can get diﬀerent
lists. But the old test is warning us of a regression. It looks like
F. 
=====================================================
FAIL: test_can_start_a_todo_list 
(functional_tests.tests.NewVisitorTest.test_can_start
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests/tests.py", line
test_can_start_a_todo_list 
    self.wait_for_row_in_list_table("2: Use peacock f
[...] 
AssertionError: '2: Use peacock feathers to make a fl
peacock feathers to make a fly'] 
 
 ----------------------------------------------------
Ran 2 tests in 8.617s 
 
FAILED (failures=1)

you can’t add a second item to a list any more. It’s because of
our quick-and-dirty hack where we create a new list for every
single POST submission. This is exactly what we have functional
tests for!
And it correlates nicely with the last item on our to-do list:
Adjust model so that items are associated with diﬀerent lists
Add unique URLs for each list
Add a URL for creating a new list via POST
Add URLs for adding a new item to an existing list via POST
One More View to Handle Adding
Items to an Existing List
We need a URL and view to handle adding a new item to an
existing list (/lists/<list_id>/add_item). We’re getting pretty good
at these now, so let’s knock one together quickly:
lists/tests.py (ch07l045)
class NewItemTest(TestCase): 
def test can save a POST request to an existing l

    def test_can_save_a_POST_request_to_an_existing_l
        other_list = List.objects.create() 
        correct_list = List.objects.create() 
 
        self.client.post( 
            f"/lists/{correct_list.id}/add_item", 
            data={"item_text": "A new item for an exi
        ) 
 
        self.assertEqual(Item.objects.count(), 1) 
        new_item = Item.objects.get() 
        self.assertEqual(new_item.text, "A new item f
        self.assertEqual(new_item.list, correct_list)
 
    def test_redirects_to_list_view(self): 
        other_list = List.objects.create() 
        correct_list = List.objects.create() 
 
        response = self.client.post( 
            f"/lists/{correct_list.id}/add_item", 
            data={"item_text": "A new item for an exi
        ) 
 
        self.assertRedirects(response, f"/lists/{corr

NOTE
Are you wondering about other_list ? A bit like in the tests for viewing a speciﬁc
list, it’s important that we add items to a speciﬁc list. Adding this second object to the
database prevents me from using a hack like List.objects.first()  in the
implementation. Yes, that would be a stupid thing to do, and you can go too far down
the road of testing for all the stupid things you must not do (there are an inﬁnite
number of those, after all). It’s a judgement call, but this one feels worth it. There’s
some more discussion of this in [Link to Come].
So that fails as expected, the list item is not saved, and the new
URL currently returns a 404:
The Last New URL
Now we’ve got our expected 404, let’s add a new URL for adding
new items to existing lists:
superlists/urls.py (ch07l046)
AssertionError: 0 != 1 
[...] 
AssertionError: 404 != 302 : Response didn't redirect
code was 404 (expected 302)
urlpatterns = [ 
path(""
views home page
name="home")

Three very similar-looking URLs there. Let’s make a note on our
to-do list; they look like good candidates for a refactoring:
Adjust model so that items are associated with diﬀerent lists
Add unique URLs for each list
Add a URL for creating a new list via POST
Add URLs for adding a new item to an existing list via POST
Refactor away some duplication in urls.py
Back to the tests, we get the usual missing module view objects:
The Last New View
Let’s try:
    path(
, views.home_page, name= home ), 
    path("lists/new", views.new_list, name="new_list"
    path("lists/<int:list_id>/", views.view_list, nam
    path("lists/<int:list_id>/add_item", views.add_it
]
AttributeError: module 'lists.views' has no attribute

lists/views.py (ch07l047)
def add_item(request): 
    pass
Aha:
lists/views.py (ch07l048)
def add_item(request, list_id): 
    pass
And then:
We can copy the redirect()  from new_list  and the
List.objects.get()  from view_list :
lists/views.py (ch07l049)
TypeError: add_item() got an unexpected keyword argum
ValueError: The view lists.views.add_item didn't retu
It returned None instead.

def add_item(request, list_id): 
    our_list = List.objects.get(id=list_id) 
    return redirect(f"/lists/{our_list.id}/")
That takes us to:
    self.assertEqual(Item.objects.count(), 1) 
AssertionError: 0 != 1
Finally we make it save our new list item:
lists/views.py (ch07l050)
And we’re back to passing tests.
Ran 8 tests in 0.050s 
 
OK
def add_item(request, list_id): 
    our_list = List.objects.get(id=list_id) 
    Item.objects.create(text=request.POST["item_text"
    return redirect(f"/lists/{our_list.id}/")

Testing Template Context Directly
We’ve got our new view and URL for adding items to existing
lists; now we just need to actually use it in our list.html
template. So we open it up to adjust the form tag… 
lists/templates/list.html
… oh. To get the URL for adding to the current list, the template
needs to know what list it’s rendering, as well as what the items
are.
We want to be able to do something like this:
lists/templates/list.html
For that to work, the view will have to pass the list to the
template. Let’s create a new unit test in ListViewTest :
lists/tests.py (ch07l051)
    <form method="POST" action="but what should we pu
    <form method="POST" action="/lists/{{ list.id }}/

response.context  represents the context we’re going to
pass into the render function— the Django Test Client puts it
on the response  object for us, to help with testing.
That gives us:
because we’re not passing list  into the template. It actually
gives us an opportunity to simplify a little:
lists/views.py (ch07l052)
    def test_passes_correct_list_to_template(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()
        response = self.client.get(f"/lists/{correct_
        self.assertEqual(response.context["list"], co
    self.assertEqual(response.context["list"], correc
                     ~~~~~~~~~~~~~~~~^^^^^^^^ 
[...] 
KeyError: 'list'
def view_list(request, list_id): 
    our_list = List.objects.get(id=list_id) 
    return render(request, "list.html", {"list": our_

That, of course, introduces a bug, because the template needed
items :
But we can ﬁx it in list.html, as well as adjusting the form’s POST
action, which is what we were trying to do anyway:
lists/templates/list.html (ch07l053)
There’s our new form action.
.item_set  is called a reverse lookup. It’s one of Django’s
incredibly useful bits of ORM that lets you look up an object’s
related items from a diﬀerent table.
FAIL: test_displays_only_items_for_that_list 
[...] 
AssertionError: False is not true : Couldn't find 'it
    <form method="POST" action="/lists/{{ list.id }}/
      [...] 
 
      {% for item in list.item_set.all %}   
        <tr><td>{{ forloop.counter }}: {{ item.text }
      {% endfor %}

So that gets the unit tests to pass:
Ran 9 tests in 0.040s 
 
OK
How about the FTs?
HOORAY! Oh, and a quick check on our to-do list:
Adjust model so that items are associated with diﬀerent lists
Add unique URLs for each list
Add a URL for creating a new list via POST
Add URLs for adding a new item to an existing list via POST
Refactor away some duplication in urls.py
$ python manage.py test functional_tests 
[...] 
.. 
 ----------------------------------------------------
Ran 2 tests in 9.771s 
 
OK

Irritatingly, the Testing Goat is a stickler for tying up loose ends
too, so we’ve got to do one ﬁnal thing.
Before we start, we’ll do a commit— always make sure you’ve
got a commit of a working state before embarking on a refactor:
A Final Refactor Using URL includes
superlists/urls.py is really meant for URLs that apply to your
entire site. For URLs that only apply to the lists  app, Django
encourages us to use a separate lists/urls.py, to make the app
more self-contained. The simplest way to make one is to use a
copy of the existing urls.py:
$ cp superlists/urls.py lists/
Then we replace the three list-speciﬁc lines in superlists/urls.py
with an include() :
superlists/urls.py (ch07l055)
$ git diff 
$ git commit -am "new URL + view for adding to ex

from django.urls import include, path
from lists import views as list_views  
urlpatterns = [
    path("", list_views.home_page, name="home"),
    path("lists/", include("lists.urls")),  
]
While we’re at it, we use the import x as y  syntax to alias
views  This is good practice in your top-level urls.py, because
it will let us import views from multiple apps if we want— and
indeed we will need to later on in the book.
Here’s the include . Notice that it can take a part of a URL as
a preﬁx, which will be applied to all the included URLs (this is
the bit where we reduce duplication, as well as giving our
code a better structure).
Back in lists/urls.py we can trim down to only include the latter
part of our three URLs, and none of the other stuﬀ from the
parent urls.py:
lists/urls.py (ch07l056)
from django.urls import path
from lists import views

Rerun the unit tests to check that everything worked.
Ran 9 tests in 0.040s 
 
OK
When I saw that it passed, I couldn’t quite believe I did it
correctly on the ﬁrst go. It always pays to be skeptical of your
own abilities, so I deliberately changed one of the URLs slightly,
just to check if it broke a test. It did. We’re covered.
Feel free to try it yourself! Remember to change it back, check
that the tests all pass again, and then do a ﬁnal commit:
$ git status 
$ git add lists/urls.py 
$ git add superlists/urls.py 
from lists import views 
 
urlpatterns = [ 
    path("new", views.new_list, name="new_list"), 
    path("<int:list_id>/", views.view_list, name="vie
    path("<int:list_id>/add_item", views.add_item, na
]

$ git diff --staged 
$ git commit
Phew. This was a marathon chapter. But we covered a number
of important topics, starting with some thinking about design.
We covered rules of thumb like “YAGNI” and “three strikes then
refactor”. But, most importantly, we saw how to adapt an
existing codebase step by step, going from working state to
working state, in order to iterate towards a new design.
I’d say we’re pretty close to being able to ship this site, as the
very ﬁrst beta of the superlists website that’s going to take over
the world. Maybe it needs a little prettiﬁcation ﬁrst… let’s look at
what we need to do to deploy it in the next couple of chapters.

SOME MORE TDD PHILOSOPHY
Working State to Working State (aka The Testing Goat vs.
Refactoring Cat)
Our natural urge is often to dive in and ﬁx everything at
once… but if we’re not careful, we’ll end up like Refactoring
Cat, in a situation with loads of changes to our code and
nothing working. The Testing Goat encourages us to take one
step at a time, and go from working state to working state.
Split work out into small, achievable tasks
Sometimes this means starting with “boring” work rather
than diving straight in with the fun stuﬀ, but you’ll have to
trust that YOLO-you in the parallel universe is probably
having a bad time, having broken everything, and struggling
to get the app working again.
YAGNI
You ain’t gonna need it! Avoid the temptation to write code
that you think might be useful, just because it suggests itself
at the time. Chances are, you won’t use it, or you won’t have
anticipated your future requirements correctly. See [Link to
Come] for one methodology that helps us avoid this trap.

 Are you wondering about the strange spelling of the
“nulist” variable? Other options are “list”, which would shadow
the built-in list()  function, and new_list , which would
shadow the name of the function that contains it. Or list1  or
listey  or mylist , but none are particularly satisfactory.
1

Part II. Web Development Sine Qua
Nons
Real developers ship.
—Jeﬀ Atwood
If this were just a guide to TDD in a normal programming ﬁeld,
we might be able to congratulate ourselves about now. After all,
we’ve got some solid basics of TDD and Django under our belts;
we’ve got all we need to start building a website.
But, real developers ship, and in order to ship, we’re going to
have to tackle some of the trickier but unavoidable aspects of
web development: static ﬁles, form data validation, the dreaded
JavaScript, but most hairy of all, deployment to a production
server.
At every stage, TDD can help us to get these things right too.
In this section, I’m still trying to keep the learning curve
relatively soft, but we will meet several major new concepts and
technologies. I’ll only be able to dip lightly into each one— I
hope to demonstrate enough of each to get you started when
you get to your own project, but you will also need to do your

own reading around when you start to apply these topics in
“real life”.
For example, if you weren’t familiar with Django before starting
on the book, you may ﬁnd that taking a little time to run
through the oﬃcial Django tutorial at this point would
complement what you’ve learned so far nicely, and will leave
you more conﬁdent with the Django stuﬀ over the next few
chapters, so you can focus on the core concepts.
Oh, but there’s lots of fun stuﬀ coming up! Just you wait!

Chapter 8. Prettiﬁcation: Layout
and Styling, and What to Test About
It
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 8th chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
We’re starting to think about releasing the ﬁrst version of our
site, but we’re a bit embarrassed by how ugly it looks at the
moment. In this chapter, we’ll cover some of the basics of
styling, including integrating an HTML/CSS framework called

Bootstrap. We’ll learn how static ﬁles work in Django, and what
we need to do about testing them.
Testing Layout and Style
Our site is undeniably a bit unattractive at the moment
(Figure 8-1).
NOTE
If you spin up your dev server with manage.py runserver , you may run into a
database error, something like this: “table lists_item has no column named list_id”.
You need to update your local database to reﬂect the changes we made in models.py.
Use manage.py migrate . If it gives you any grief about IntegrityErrors , just delete
the database ﬁle  and try again.
We can’t be adding to Python’s reputation for being ugly, so let’s
do a tiny bit of polishing. Here are a few things we might want:
A nice large input ﬁeld for adding new and existing lists
A large, attention-grabbing, centered box to put it in
How do we apply TDD to these things? Most people will tell you
you shouldn’t test aesthetics, and they’re right. It’s a bit like
testing a constant, in that tests usually wouldn’t add any value.
1


Figure 8-1. Our home page, looking a little ugly… 
But we can test the essential behaviour of our aesthetics, i.e.,
that we have any at all. All we want to do is reassure ourselves
that things are working. For example, we’re going to use
Cascading Style Sheets (CSS) for our styling, and they are loaded
as static ﬁles. Static ﬁles can be a bit tricky to conﬁgure
(especially, as we’ll see later, when you move oﬀ your own
computer and onto a hosting site), so we’ll want some kind of
simple “smoke test” that the CSS has loaded. We don’t have to
test fonts and colours and every single pixel, but we can do a
quick check that the main input box is aligned the way we want
it on each page, and that will give us conﬁdence that the rest of
the styling for that page is probably loaded too.
Let’s add a new test method inside our functional test:
functional_tests/tests.py (ch08l001)
class NewVisitorTest(LiveServerTestCase): 
    [...] 
 
 
    def test_layout_and_styling(self): 
        # Edith goes to the home page, 
        self.browser.get(self.live_server_url) 

A few new things here. We start by setting the window size to a
ﬁxed size. We then ﬁnd the input element, look at its size and
location, and do a little maths to check whether it seems to be
positioned in the middle of the page. assertAlmostEqual  helps
us to deal with rounding errors and the occasional weirdness
due to scrollbars and the like, by letting us specify that we want
our arithmetic to work to within plus or minus 10 pixels.
If we run the functional tests, we get:
 
        # Her browser window is set to a very specifi
        self.browser.set_window_size(1024, 768) 
 
        # She notices the input box is nicely centere
        inputbox = self.browser.find_element(By.ID, "
        self.assertAlmostEqual( 
            inputbox.location["x"] + inputbox.size["w
            512, 
            delta=10, 
        )
$ python manage.py test functional_tests 
[...] 
.F. 
=====================================================
FAIL: test layout and styling

That’s the expected failure. Still, this kind of FT is easy to get
wrong, so let’s use a quick-and-dirty “cheat” solution, to check
that the FT deﬁnitely passes when the input box is centered.
We’ll delete this code again almost as soon as we’ve used it to
check the FT:
lists/templates/home.html (ch08l002)
FAIL: test_layout_and_styling 
(functional_tests.tests.NewVisitorTest.test_layout_an
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests/tests.py", line
test_layout_and_styling 
    self.assertAlmostEqual( 
AssertionError: 102.5 != 512 within 10 delta (409.5 d
 
 ----------------------------------------------------
Ran 3 tests in 9.188s 
 
FAILED (failures=1)
<form method="POST" action="/lists/new"> 
  <p style="text-align: center;"> 
    <input name="item_text" id="id_new_item" placehol
  </p> 

That passes, which means the FT works. Let’s extend it to make
sure that the input box is also center-aligned on the page for a
new list:
functional_tests/tests.py (ch08l003)
That gives us another test failure:
  {% csrf_token %} 
</form>
    # She starts a new list and sees the input is nic
    # centered there too 
    inputbox.send_keys("testing") 
    inputbox.send_keys(Keys.ENTER) 
    self.wait_for_row_in_list_table("1: testing") 
    inputbox = self.browser.find_element(By.ID, "id_n
    self.assertAlmostEqual( 
        inputbox.location["x"] + inputbox.size["width
        512, 
        delta=10, 
    )
  File "...goat-book/functional_tests/tests.py", line
test_layout_and_styling 
    self.assertAlmostEqual( 

Let’s commit just the FT:
Now it feels like we’re justiﬁed in ﬁnding a “proper” solution to
our need for some better styling for our site. We can back out
our hacky text-align: center :
$ git reset --hard
WARNING: git reset --hard  is the “take oﬀ and nuke the site
from orbit” Git command, so be careful with it— it blows away
all your un-committed changes. Unlike almost everything else
you can do with Git, there’s no way of going back after this one.
Prettiﬁcation: Using a CSS
Framework
q
(
AssertionError: 102.5 != 512 within 10 delta (409.5 d
$ git add functional_tests/tests.py 
$ git commit -m "first steps of FT for layout + s

UI design is hard, and doubly so now that we have to deal with
mobile, tablets, and so forth. That’s why many programmers,
particularly lazy ones like me, turn to CSS frameworks to solve
some of those problems for them. There are lots of frameworks
out there, but one of the earliest and most popular still, is
Bootstrap. Let’s use that.
You can ﬁnd bootstrap at getbootstrap.com.
We’ll download it and put it in a new folder called static inside
the lists  app:
Bootstrap comes with a plain, uncustomised installation in the
dist folder. We’re going to use that for now, but you should
really never do this for a real site— vanilla Bootstrap is instantly
recognisable, and a big signal to anyone in the know that you
couldn’t be bothered to style your site. Learn how to use Sass
$ wget -O bootstrap.zip https://github.com/twbs/b
v5.3.0/bootstrap-5.3.0-dist.zip 
$ unzip bootstrap.zip 
$ mkdir lists/static 
$ mv bootstrap-5.3.0-dist lists/static/bootstrap 
$ rm bootstrap.zip
2

and change the font, if nothing else! There is info in Bootstrap’s
docs, or read an introductory guide.
Our lists folder will end up looking like this:
$ tree lists 
lists 
├── __init__.py 
├── admin.py 
├── apps.py 
├── migrations 
│   ├── [...] 
├── models.py 
├── static 
│   └── bootstrap 
│       ├── css 
│       │   ├── bootstrap-grid.css 
│       │   ├── bootstrap-grid.css.map 
│       │   ├── [...] 
│       │   └── bootstrap.rtl.min.css.map 
│       └── js 
│           ├── bootstrap.bundle.js 
│           ├── bootstrap.bundle.js.map 
│           ├── [...] 
│           └── bootstrap.min.js.map 
├── templates 
│   ├── home.html 

│   └── list.html 
├── [...]
Look at the “Getting Started” section of the Bootstrap
documentation; you’ll see it wants our HTML template to
include something like this:
We already have two HTML templates. We don’t want to be
adding a whole load of boilerplate code to each, so now feels
like the right time to apply the “Don’t repeat yourself” rule, and
bring all the common parts together. Thankfully, the Django
template language makes that easy using something called
template inheritance.
<!doctype html>
<html lang="en"> 
  <head> 
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width
    <title>Bootstrap demo</title> 
  </head> 
  <body> 
    <h1>Hello, world!</h1> 
  </body>
</html>

Django Template Inheritance
Let’s have a little review of what the diﬀerences are between
home.html and list.html:
They have diﬀerent header texts, and their forms use diﬀerent
URLs. On top of that, list.html has the additional <table>
element.
Now that we’re clear on what’s in common and what’s not, we
can make the two templates inherit from a common
“superclass” template. We’ll start by making a copy of list.html:
$ diff lists/templates/home.html lists/templates/
<     <h1>Start a new To-Do list</h1> 
<     <form method="POST" action="/lists/new"> 
--- 
>     <h1>Your To-Do list</h1> 
>     <form method="POST" action="/lists/{{ list.id }
[...] 
>     <table id="id_list_table"> 
>       {% for item in list.item_set.all %} 
>         <tr><td>{{ forloop.counter }}: {{ item.text
>       {% endfor %} 
>     </table>

We make this into a base template which just contains the
common boilerplate, and mark out the “blocks”, places where
child templates can customise it:
lists/templates/base.html (ch08l007)
$ cp lists/templates/list.html lists/templates/ba
<html> 
  <head> 
    <title>To-Do lists</title> 
  </head> 
 
  <body> 
    <h1>{% block header_text %}{% endblock %}</h1> 
 
    <form method="POST" action="{% block form_action 
      <input name="item_text" id="id_new_item" placeh
      {% csrf_token %} 
    </form> 
 
    {% block table %} 
    {% endblock %} 
  </body> 
 
</html>

The base template deﬁnes a series of areas called “blocks”,
which will be places that other templates can hook in and add
their own content. Let’s see how that works in practice, by
changing home.html so that it “inherits from” base.html:
lists/templates/home.html (ch08l008)
You can see that lots of the boilerplate HTML disappears, and
we just concentrate on the bits we want to customise. We do the
same for list.html:
lists/templates/list.html (ch08l009)
{% extends 'base.html' %} 
 
{% block header_text %}Start a new To-Do list{% endbl
 
{% block form_action %}/lists/new{% endblock %}
{% extends 'base.html' %} 
 
{% block header_text %}Your To-Do list{% endblock %} 
 
{% block form_action %}/lists/{{ list.id }}/add_item{

That’s a refactor of the way our templates work. We rerun the
FTs to make sure we haven’t broken anything:
Sure enough, they’re still getting to exactly where they were
before.
That’s worthy of a commit:
 
{% block table %} 
  <table id="id_list_table"> 
    {% for item in list.item_set.all %} 
      <tr><td>{{ forloop.counter }}: {{ item.text }}<
    {% endfor %} 
  </table> 
{% endblock %}
AssertionError: 102.5 != 512 within 10 delta (409.5 d
$ git diff -w 
# the -w means ignore whitespace, useful since we've 
$ git status 
$ git add lists/templates # leave static, for now 
$ git commit -m "refactor templates to use a base

Integrating Bootstrap
Now it’s much easier to integrate the boilerplate code that
Bootstrap wants— we won’t add the JavaScript yet, just the CSS:
lists/templates/base.html (ch08l010)
Rows and Columns
Finally, let’s actually use some of the Bootstrap magic! You’ll
have to read the documentation yourself, but we should be able
to use a combination of the grid system and the justify-
content-center  class to get what we want:
<!doctype html>
<html lang="en"> 
 
  <head> 
    <title>To-Do lists</title> 
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width
    <link href="css/bootstrap.min.css" rel="styleshee
  </head> 
[...]

lists/templates/base.html (ch08l011)
  <body> 
    <div class="container"> 
 
      <div class="row justify-content-center"> 
        <div class="col-lg-6 text-center"> 
          <h1>{% block header_text %}{% endblock %}</
 
          <form method="POST" action="{% block form_a
            <input 
              name="item_text" 
              id="id_new_item" 
              placeholder="Enter a to-do item" 
            /> 
            {% csrf_token %} 
          </form> 
        </div> 
      </div> 
 
      <div class="row justify-content-center"> 
        <div class="col-lg-6"> 
          {% block table %} 
          {% endblock %} 
        </div> 
      </div> 
 

(If you’ve never seen an HTML tag broken up over several lines,
that <input>  may be a little shocking. It is deﬁnitely valid, but
you don’t have to use it if you ﬁnd it oﬀensive. ;)
TIP
Take the time to browse through the Bootstrap documentation, if you’ve never seen
it before. It’s a shopping trolley brimming full of useful tools to use in your site.
Does that work?
Hmm. No. Why isn’t our CSS loading?
Static Files in Django
Django, and indeed any web server, needs to know two things
to deal with static ﬁles:
    </div> 
  </body>
AssertionError: 102.5 != 512 within 10 delta (409.5 d

1. How to tell when a URL request is for a static ﬁle, as opposed
to for some HTML that’s going to be served via a view
function
2. Where to ﬁnd the static ﬁle the user wants
In other words, static ﬁles are a mapping from URLs to ﬁles on
disk.
For item 1, Django lets us deﬁne a URL “preﬁx” to say that any
URLs which start with that preﬁx should be treated as requests
for static ﬁles. By default, the preﬁx is /static/. It’s deﬁned in
settings.py:
superlists/settings.py
The rest of the settings we will add to this section all have to do
with item 2: ﬁnding the actual static ﬁles on disk.
[...] 
 
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-
 
STATIC_URL = "static/"

While we’re using the Django development server ( manage.py
runserver ), we can rely on Django to magically ﬁnd static ﬁles
for us— it’ll just look in any subfolder of one of our apps called
static.
You now see why we put all the Bootstrap static ﬁles into
lists/static. So why are they not working at the moment? It’s
because we’re not using the /static/  URL preﬁx. Have
another look at the link to the CSS in base.html:
That href  is just what happened to be in the bootstrap docs. To
get it to work, we need to change it to:
lists/templates/base.html (ch08l012)
Now when runserver  sees the request, it knows that it’s for a
static ﬁle because it begins with /static/ . It then tries to ﬁnd a
ﬁle called bootstrap/css/bootstrap.min.css, looking in each of our
app folders for subfolders called static, and it should ﬁnd it at
lists/static/bootstrap/css/bootstrap.min.css.
    <link href="css/bootstrap.min.css" rel="styleshee
    <link href="/static/bootstrap/css/bootstrap.min.c

So if you take a look manually, you should see it works, as in
Figure 8-2.


Figure 8-2. Our site starts to look a little better… 
Switching to StaticLiveServerTestCase
If you run the FT though, annoyingly, it still won’t pass:
That’s because, although runserver  automagically ﬁnds static
ﬁles, LiveServerTestCase  doesn’t. Never fear, though: the
Django developers have made an even more magical test class
called StaticLiveServerTestCase  (see the docs).
Let’s switch to that:
functional_tests/tests.py (ch08l013)
AssertionError: 102.5 != 512 within 10 delta (409.5 d
@@ -1,14 +1,14 @@
-from django.test import LiveServerTestCase
+from django.contrib.staticfiles.testing import Stati
 from selenium import webdriver
 from selenium.common.exceptions import WebDriverExce
 from selenium.webdriver.common.keys import Keys
 import time 
 
 MAX_WAIT = 10 

And now it will ﬁnd the new CSS, which will get our test to pass:
Hooray!
Using Bootstrap Components to
Improve the Look of the Site
Let’s see if we can do even better, using some of the other tools
in Bootstrap’s panoply.
Jumbotron!
 
 
-class NewVisitorTest(LiveServerTestCase):
+class NewVisitorTest(StaticLiveServerTestCase): 
 
     def setUp(self):
$ python manage.py test functional_tests 
Creating test database for alias 'default'... 
... 
 ----------------------------------------------------
Ran 3 tests in 9.764s

The ﬁrst version of Bootstrap used to ship with a class called
jumbotron  for things that are meant to be particularly
prominent on the page. It doesn’t exist any more, but old-timers
like me still pine for it, so they have a speciﬁc page in the docs
that tells you how to recreate it.
Essentially, we massively embiggen the main page header and
the input form, putting it into a grey box with nice rounded
corners:
lists/templates/base.html (ch08l014)
That ends up looking something like Figure 8-3:
  <body> 
    <div class="container"> 
 
      <div class="row justify-content-center p-5 bg-b
        <div class="col-lg-6 text-center"> 
          <h1 class="display-1 mb-4">{% block header_
          [...]


Figure 8-3. A big grey box at the top of the page
TIP
When hacking about with design and layout, it’s best to have a window open that we
can hit refresh on, frequently. Use python manage.py runserver  to spin up the dev
server, and then browse to http://localhost:8000 to see your work as we go.
Large Inputs
The jumbotron is a good start, but now the input box has tiny
text compared to everything else. Thankfully, Bootstrap’s form
control classes oﬀer an option to set an input to be “large”:
lists/templates/base.html (ch08l015)
    <input 
      class="form-control form-control-lg" 
      name="item_text" 
      id="id_new_item" 
      placeholder="Enter a to-do item" 
    />
Table Styling

The table text also looks too small compared to the rest of the
page now. Adding the Bootstrap table  class improves things,
over in list.html:
lists/templates/list.html (ch08l016)
  <table class="table" id="id_list_table">
Dark Modeeeeeee
In contrast to my greybeard nostalgia for the Jumbotron, here’s
something relatively new to Bootstrap, Dark Mode!
lists/templates/base.html (ch08l017)
<!doctype html>
<html lang="en" data-bs-theme="dark">
Take a look at Figure 8-4. I think that looks great!


Figure 8-4. The lists page goes dark
But it’s very much a matter of personal preference, and my
editor will kill me if I make all the rest of my screenshots use so
much ink, so I’m going to revert it for now. You’re free to keep
dark mode on if you like!
A semi-decent page
All that took me a few goes, but I’m reasonably happy with it
now (Figure 8-5).

Figure 8-5. The lists page, looking good enough for now.
If you want to go further with customising Bootstrap, you need
to get into compiling Sass. I’ve said it already, but I deﬁnitely
recommend taking the time to do that some day. Sass/SCSS is a

great improvement on plain old CSS, and a useful tool even if
you don’t use Bootstrap.
A last run of the functional tests, to see if everything still works
OK:
That’s it! Deﬁnitely time for a commit:
$ python manage.py test functional_tests 
[...] 
... 
 ----------------------------------------------------
Ran 3 tests in 10.084s 
 
OK
$ git status # changes tests.py, base.html, list.htm
$ git add . 
$ git status # will now show all the bootstrap addit
$ git commit -m "Use Bootstrap to improve layout"

What We Glossed Over: collectstatic
and Other Static Directories
We saw earlier that the Django dev server will magically ﬁnd all
your static ﬁles inside app folders, and serve them for you.
That’s ﬁne during development, but when you’re running on a
real web server, you don’t want Django serving your static
content— using Python to serve raw ﬁles is slow and ineﬃcient,
and a web server like Apache or Nginx can do this all for you.
You might even decide to upload all your static ﬁles to a CDN,
instead of hosting them yourself.
For these reasons, you want to be able to gather up all your
static ﬁles from inside their various app folders, and copy them
into a single location, ready for deployment. This is what the
collectstatic  command is for.
The destination, the place where the collected static ﬁles go,
needs to be deﬁned in settings.py as STATIC_ROOT . In the next
chapter we’ll be doing some deployment, so let’s actually
experiment with that now. A common and straightforward
place to put it is in a folder called “static” in the root of our repo:

. 
├── db.sqlite3 
├── functional_tests/ 
├── lists/ 
├── manage.py 
├── static/ 
└── superlists/
Here’s a neat way of specifying that folder, making it relative to
the location of the project base directory:
superlists/settings.py (ch08l019)
Take a look at the top of the settings ﬁle, and you’ll see how that
BASE_DIR  variable is helpfully deﬁned for us, using
pathlib.Path  and __file__  (both really nice Python
builtins) .
Anyway, let’s try running collectstatic :
# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.2/howto/static-
 
STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "static"
3

$ python manage.py collectstatic 
 
169 static files copied to '...goat-book/static'.
And if we look in ./static, we’ll ﬁnd all our CSS ﬁles:
$ tree static/ 
static/ 
├── admin 
│   ├── css 
│   │   ├── autocomplete.css 
│   │   ├── [...] 
[...] 
│               └── xregexp.min.js 
└── bootstrap 
    ├── css 
    │   ├── bootstrap-grid.css 
    │   ├── [...] 
    │   └── bootstrap.rtl.min.css.map 
    └── js 
        ├── bootstrap.bundle.js 
        ├── [...] 
        └── bootstrap.min.js.map 
 
16 directories, 169 files

collectstatic  has also picked up all the CSS for the admin
site. The admin site is one of Django’s powerful features, but we
don’t need it for our simple site, so let’s disable it for now:
superlists/settings.py
INSTALLED_APPS = [ 
    # "django.contrib.admin", 
    "django.contrib.auth", 
    "django.contrib.contenttypes", 
    "django.contrib.sessions", 
    "django.contrib.messages", 
    "django.contrib.staticfiles", 
    "lists",
]
And we try again:
$ rm -rf static/ 
$ python manage.py collectstatic 
 
44 static files copied to '...goat-book/static'.
Much better.

Now we know how to collect all the static ﬁles into a single
folder, where it’s easy for a web server to ﬁnd them. We’ll ﬁnd
out all about that, including how to test it, in the next chapter!
For now let’s save our changes to settings.py. We’ll also add the
top-level static folder to our gitignore, since it will only contain
copies of ﬁles we actually keep in individual apps’ static folders.
A Few Things That Didn’t Make It
Inevitably this was only a whirlwind tour of styling and CSS, and
there were several topics that I’d considered covering that
didn’t make it. Here are a few candidates for further study:
The {% static %}  template tag, for more DRY and fewer
hardcoded URLs
Client-side packaging tools, like npm  and bower
Customising bootstrap with SASS
$ git diff # should show changes in settings.py 
$ echo /static >> .gitignore 
$ git commit -am "set STATIC_ROOT in settings and

RECAP: ON TESTING DESIGN AND LAYOUT
The short answer is: you shouldn’t write tests for design and
layout per se. It’s too much like testing a constant, and the tests
you write are often brittle.
With that said, the implementation of design and layout involves
something quite tricky: CSS and static ﬁles. As a result, it is
valuable to have some kind of minimal “smoke test” which
checks that your static ﬁles and CSS are working. As we’ll see in
the next chapter, it can help pick up problems when you deploy
your code to production.
Similarly, if a particular piece of styling required a lot of client-
side JavaScript code to get it to work (dynamic resizing is one
I’ve spent a bit of time on), you’ll deﬁnitely want some tests for
that.
Try to write the minimal tests that will give you conﬁdence that
your design and layout is working, without testing what it
actually is. Aim to leave yourself in a position where you can
freely make changes to the design and layout, without having to
go back and adjust tests all the time.

 What? Delete the database? Are you crazy? Not completely.
The local dev database often gets out of sync with its migrations
as we go back and forth in our development, and it doesn’t have
any important data in it, so it’s OK to blow it away now and
again. We’ll be much more careful once we have a “production”
database on the server. More on this in [Link to Come].
 On Windows, you may not have wget  and unzip , but I’m
sure you can ﬁgure out how to download Bootstrap, unzip it,
and put the contents of the dist folder into the
lists/static/bootstrap folder.
 Notice in the Pathlib  wrangling of __file__  that the
.resolve()  happens before anything else. Always follow this
pattern when working with __file__ , otherwise you can see
unpredictable behaviours depending on how the ﬁle is
imported. Thanks to Green Nathan for that tip!
1
2
3

Chapter 9. Containerization aka
Docker
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 9th chapter of the ﬁnal book. The GitHub repo is
available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
Is all fun and game until you are need of put it in production.
—Devops Borat
It’s time to deploy the ﬁrst version of our site and make it
public. They say that if you wait until you feel ready to ship,

then you’ve waited too long.
Is our site usable? Is it better than nothing? Can we make lists
on it? Yes, yes, yes.
No, you can’t log in yet. No, you can’t mark tasks as completed.
But do we really need any of that stuﬀ? Not really— and you can
never be sure what your users are actually going to do with
your site once they get their hands on it. We think our users
want to use the site for to-do lists, but maybe they actually want
to use it to make “top 10 best ﬂy-ﬁshing spots” lists, for which
you don’t need any kind of “mark completed” function. We
won’t know until we put it out there.
Over the next couple of chapters we’re going to go through and
actually deploy our site to a real, live web server.
You might be tempted to skip this bit— there’s lots of daunting
stuﬀ in it, and maybe you think this isn’t what you signed up
for. But I strongly urge you to give it a go. This is one of the
sections of the book I’m most pleased with, and it’s one that
people often write to me saying they were really glad they stuck
through it.
If you’ve never done a server deployment before, it will
demystify a whole world for you, and there’s nothing like the

feeling of seeing your site live on the actual internet. Give it a
buzzword name like “DevOps” if that’s what it takes to convince
you it’s worth it.


WARNING, CHAPTER UNDER CONSTRUCTION
As part of my work on the third edition of the book, I’m making
big changes to the deployment chapters, and this is a very new
draft.
What that means is that I’d, really, really love feedback from
readers. Please have a go at following along and let me know
what you think! I’m obeythetestinggoat@gmail.com, or you can
open up GitHub Issue or Pull Requests.
Let me know how you got on, if you get stuck on anything, if
any explanations don’t make sense, or if any of the instructions
don’t work for you.
I hope you enjoy the new version!
TDD and the Danger Areas of
Deployment
Deploying a site to a live web server can be a tricky topic. Oft-
heard is the forlorn cry “but it works on my machine!”
Some of the danger areas of deployment include:

Networking
Once we’re oﬀ our own machine, networking issues come in:
making sure that DNS is routing our domain to the correct IP
address for our server, making sure our server is conﬁgured
to listen to traﬃc coming in from the world, making sure it’s
using the right ports, and making sure any ﬁrewalls in the
way are conﬁgured to let traﬃc through.
Dependencies
We need to make sure that the packages our software relies
on (Python, Django, and so on) are installed on the server,
and have the correct versions.
The database
There can be permissions and path issues, and we need to be
careful about preserving data between deploys.
Static ﬁles (CSS, JavaScript, images, etc.)
Web servers usually need special conﬁguration for serving
these.
Security and Conﬁguration
Once we’re on the public internet, we need to worry more
about security. Various settings that are really useful for local
development (like the Django debug page) become

dangerous in production (because they expose our source
code in tracebacks).
One way to approach the problem is to get a server and start
manually conﬁguring and installing everything, hacking about
until it works, and maybe think about automating things later .
But if there’s one thing we’ve learned in the world of agile/lean
software development, it’s that taking smaller steps usually pays
oﬀ.
How can we take smaller, safer steps towards a production
deployment? Can we simulate the process of moving to a server
so that we can iron out all the bugs before we actually take the
plunge? Can we then make small changes one at a time, solving
problems one by one, rather than having to bite oﬀ everything
in one mouthful?
Absolutely we can. And from the title of the chapter, I’m sure
you’re already guessing that Docker is going to be part of the
answer.
Docker, Containers and
Virtualization
1

Docker is a commercial product that wraps several free and
open source technologies from the world of Linux, sometimes
referred to as “containerization”. (Feel free to skip this section if
you already know all about Docker.)
You may have already heard of the idea of “virtualization”,
which allows a single physical computer to pretend to be
several machines. Pioneered by IBM (amongst others) on
mainframes in the 1960s, it rose to mainstream adoption in the
90s, where it was sold as a way to optimise resource usage in
datacentres. AWS, for example, was an oﬀshoot of Amazon,
who were using virtualization already, and realised they could
sell some spare capacity on their servers to customers outside
the business.
So when you come to deploy your code to a real server in a
datacentre, it will be using virtualization. And, actually, you can
use virtualization on your own machine, with software like
Virtualbox or KVM.
But that can be ﬁddly to set up! And nowadays, thanks to
containerization, we can do better because containerization is a
kind of even-more-virtual virtualization.

Conceptually, “regular” virtualization works at the hardware
level: it gives you multiple virtual machines (VMs) that pretend
to be physical computers, on a single real machine. So you can
run multiple operating systems using separate VMs on the same
physical box.
Containerization works at the operating system level: it gives
you multiple virtual operating systems that all run on a single
real OS. It lets us pack the source code and its dependencies
together-- the entire environment required to run the
application. This allows you to run programs inside separate
virtual environments, using a single real host operating system
and kernel.
Have a look at Docker’s resources on containers for more
explanation. The upshot of this is that containers are much
“cheaper”. You can start one up in milliseconds, and you can
run hundreds on the same machine.
Docker and your CV
That’s all well and good for the theoretical justiﬁcation, but let’s
get to the real reason for using this technology, which, as
always, is: “it’s fashionable so it’s going to look good on my CV.”

For the purposes of this book, that’s not such a bad justiﬁcation
really!
Yes, I think it’s going to be a nice way to have a “pretend”
deployment on our own machine, before we try the real one— 
but also, containers are so popular nowadays, that it’s very
likely that you’re going to encounter them at work (if you
haven’t already). For many working developers, a container
image is the ﬁnal artifact of their work, it’s what they “deliver”,
and most of the rest of the deployment process is taken care of
by someone else.
Docker and the Danger Areas of
Deployment
How will containerizing our software help with the danger
areas?
Containers can be like little virtual servers and this is how we
will use them, so they will force us to address many of the
problems like dependency management and conﬁguration.
We can use the containers to package up as much of the
functionality of our application as possible, like a production-
ready web server and static ﬁles system. This in turn will

minimise the amount of conﬁguration we need to do to our
actual servers.
We can test our containers work by running our functional
tests against them.
Later, when we deploy our containers to a staging server, we
can run the FTs against that too.
If we automate container creation and deployment to staging,
and we’ve tested both those things, then we will have
minimised the risk of deployment to production.
An Overview of Our Deployment
Procedure
Over the next three chapters, I’m going to go through a
deployment procedure. It isn’t meant to be the perfect
deployment procedure, so please don’t take it as being best
practice, or a recommendation— it’s meant to be an illustration,
to show the kinds of issues involved in putting code into
production, and where testing ﬁts in.
This chapter: Containerizing our software
Adapt our FTs so they can run against a container.

Build a minimal Dockerﬁle with everything we need to run
our site.
Learn how to build and run a container on our machine.
Learn how to run our FTs against our container.
Get a ﬁrst cut of our code up and running inside Docker, with
passing tests.
Next chapter: Moving to a production-ready conﬁguration
Gradually, incrementally change the container conﬁguration
to make it production-ready.
Regularly re-run the FTs to check we didn’t break anything.
Address issues to do with the database, static ﬁles, and so on.
Third chapter: Automating deployment to real servers
Gradually build up an Ansible playbook to deploy our
containers on a real server.
Again, use our FTs to check for any problems.
Learn how to SSH in to the server to debug things, where to
ﬁnd logs and other useful information.
Use Ansible to build an automated script that can deploy our
container to staging.
Conﬁdently deploy to production once we have a working
deployment script for staging.

As Always, Start with a Test
Let’s adapt our functional tests slightly so that they can run
against a standalone server, instead of the one that
LiveServerTestCase  creates for us. We’ll do it by checking for
an environment variable called TEST_SERVER :
functional_tests/tests.py (ch09l001)
Do you remember I said that LiveServerTestCase  had certain
limitations? Well, one is that it always assumes you want to use
its own test server, which it makes available at
self.live_server_url . I still want to be able to do that
import os
[...]
class NewVisitorTest(StaticLiveServerTestCase):
    def setUp(self):
        self.browser = webdriver.Firefox()
        test_server = os.environ.get("TEST_SERVER")  
        if test_server:
            self.live_server_url = "http://" + test_s

sometimes, but I also want to be able to selectively tell it not to
bother, and to use a real server instead.
The way I decided to do it is using an environment variable
called TEST_SERVER .
Here’s the hack: we replace self.live_server_url  with the
address of our “real” server.
NOTE
A clariﬁcation: when we say we run tests against our Docker container, or against
our staging server, that doesn’t mean we run the tests from Docker or from our
staging server. We still run the tests from our own laptop, but they target the place
that’s running our code.
We test that said hack hasn’t broken anything by running the
functional tests “normally”:
$ python manage.py test functional_tests 
[...] 
Ran 3 tests in 8.544s 
 
OK
And now we can try them against our docker server URL, which
once we’ve done the right docker magic, will be at
http://localhost:8888

TIP
I’m deliberately choosing a diﬀerent port to run Dockerised Django on (8888) from
the default port that a local manage.py runserver  would choose (8080), to avoid
getting in the situation where I (or the tests) think we’re looking at Docker, when
we’re actually looking at a local runserver  that I’ve left running in some terminal
somewhere.
I’ll use the --failfast  option to exit as soon as a single test
fails:
$ TEST_SERVER=localhost:8888 ./manage.py test fun
    --failfast 
[...] 
E 
=====================================================
ERROR: test_can_start_a_todo_list 
(functional_tests.tests.NewVisitorTest.test_can_start
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/functional_tests/tests.py", line
test_can_start_a_todo_list 
    self.browser.get(self.live_server_url) 
[...] 
 
selenium.common.exceptions.WebDriverException: Messag
ut:neterror?e=connectionFailure&u=http%3A//localhost%
 

NOTE
If, on Windows, you see an error saying something like “TEST_SERVER is not
recognized as a command”, it’s probably because you’re not using Git-Bash. Take
another look at the Prerequisites and Assumptions section.
You can see that our tests are failing, as expected, since we’re
not running Docker yet. Selenium reports that Firefox is seeing
an error and “cannot establish connection to the server”, and
you can see localhost:8888 in there too.
The FT seems to be testing the right things, so let’s commit:
 
Ran 1 tests in 5.518s 
 
FAILED (errors=1)
$ git diff # should show changes to functional_tests
$ git commit -am "Hack FT runner to be able to te

TIP
Don’t use export  to set the TEST_SERVER environment variable; otherwise, all your
subsequent test runs in that terminal will be against staging, and that can be very
confusing if you’re not expecting it. Setting it explicitly inline each time you run the
FTs is best.
Making an src Folder
When preparing a codebase for deployment, it’s often
convenient to separate out the actual source code of our
production app, from the rest of the ﬁles that you need in the
project. A folder called src is a common convention.
Currently, all our code is source code really, so we move
everything into src (we’ll be seeing some new ﬁles appearing
outside src shortly).
Installing Docker
$ mkdir src 
$ git mv functional_tests lists superlists manage
$ git commit -m "Move all our code into a src fol
2

The Docker documentation is pretty good, and you’ll ﬁnd
detailed installation instructions for Windows, Mac, and Linux.
Follow those, and then test your installation by running:
$ docker run busybox echo hello world 
Unable to find image 'busybox:latest' locally 
[...] 
latest: Pulling from library/busybox 
[...]: Pull complete 
Digest: sha256:[...] 
Status: Downloaded newer image for busybox:latest 
hello world
What’s happened there is that Docker has:
Searched for a local copy of the “busybox” image and not
found it
Downloaded the image from DockerHub
Created a container based on that image
Started up that container, telling it to run echo hello world
And we can see it worked!
Cool! We’ll ﬁnd out more about all of these steps as the chapter
progresses.

PODMAN, A DOCKER ALTERNATIVE
Impartiality commands me to also recommend Podman, which
is a like-for-like replacement for Docker.
It’s pretty much exactly the same as Docker, arguably with a few
advantages even, but I won’t go into detail here.
I actually tried it out on early drafts of this chapter and it
worked perfectly well. But it’s a little less well established and
documented, (the Windows installation instructions are a little
more DIY for example), and in the end, although I’m a fan of a
plucky upstart, Docker is open source too, so I decided to stick
with it. But you could deﬁnitely check it out!
You can follow along all the instructions in the book by just
substituting the docker  binary for podman  in all the CLI
instructions, e.g.
$ docker run busybox echo hello 
# becomes 
$ podman run busybox echo hello 
# similarly with podman build, podman ps, etc.

Building a Docker Image and
Running a Docker Container
Docker has the concepts of images as well as containers. An
image is essentially a pre-prepared root ﬁlesystem, including
the operating system, dependencies, and any code you want to
run.
Once you have an image, you can run one or many containers
that use the same image.
A First Cut of a Dockerﬁle
Think of a Dockerﬁle as instructions for setting up a brand new
computer, that we’re going to use to run our Django server on.
What do we need to do? Something like this, right?
1. Install an operating system
2. Make sure it has Python on it
3. Get our source code onto it
4. Run python manage.py runserver
We create a new ﬁle called Dockerﬁle in the base folder of our
repo, next to the src/  directory we made earlier:

Dockerﬁle (ch09l003)
FROM python:slim  
COPY src /src  
WORKDIR /src  
CMD python manage.py runserver  
The FROM  line is usually the ﬁrst thing in a Dockerﬁle, and it
says which base image we are starting from. Docker images
are built from other Docker images! It’s not quite turtles all
the way down, but almost. So this is the equivalent of
choosing a base operating system, but images can actually
have lots of software preinstalled too. You can browse
various base images on DockerHub, we’re using one that’s
published by the Python Software Foundation, called “slim”
because it’s as small as possible. It’s based on a popular
version of Linux called Debian, and of course it comes with
Python already installed on it.
The COPY  instruction (the uppercase words are called
“instructions”) lets you copy ﬁles from your own computer
into the container image. We use it to copy all our source
code from the newly-created src folder, into a similarly-
named folder at the root of the container image.

WORKDIR  sets the current working directory for all
subsequent commands. It’s a bit like doing cd /src .
Finally the CMD  instruction tells docker which command you
want it to run by default, when you start a container based on
that image.
It’s probably worth just showing a directory tree, to make sure
everything is in the right place? All our source code is in a folder
called src , next to our Dockerfile :
. 
├── Dockerfile 
├── db.sqlite3 
├── src 
│   ├── functional_tests 
│   │   ├── [...] 
│   ├── lists 
│   │   ├── [...] 
│   ├── manage.py 
│   └── superlists 
│       ├── [...] 
└── static 
    └── [...]
Docker Build

You build an image with docker build <path-containing-
dockerfile>  and we’ll use the -t <tagname>  argument to
“tag” our image with a memorable name.
It’s typical to invoke docker build  from the folder that
contains your Dockerﬁle, so the last argument is usually . :
Now we can see our image in the list of docker images on the
system:
$ docker build -t superlists . 
[+] Building 1.2s (8/8) FINISHED                     
 => [internal] load build definition from Dockerfile 
 => => transferring dockerfile: 115B                 
 => [internal] load .dockerignore                    
 => => transferring context: 2B                      
 => [internal] load metadata for docker.io/library/py
 => [internal] load build context                    
 => => transferring context: 68.54kB                 
 => [1/3] FROM docker.io/library/python:slim         
 => [2/3] COPY src /src                              
 => [3/3] WORKDIR /src                               
 => exporting to image                               
 => => exporting layers                              
 => => writing image sha256:7b8e1c9fa68e7bad7994fa41e
 => => naming to docker.io/library/superlists        

NOTE
If you see an error about failed to solve / compute cache key  and src: not
found  it may be because you saved the Dockerﬁle into the wrong place. Have
another look at the directory tree from earlier ???.
Docker Run
Once you’ve built an image, you can run one or more
containers based on that image, using docker run . What
happens when we run ours?
$ docker images 
REPOSITORY   TAG       IMAGE ID       CREATED        
[...] 
superlists   latest    522824a399de   2 minutes ago  
$ docker run superlists 
Traceback (most recent call last): 
  File "/src/manage.py", line 11, in main 
    from django.core.management import execute_from_c
ModuleNotFoundError: No module named 'django' 
 
The above exception was the direct cause of the follo
 

Ah, we forgot that we need to install Django.
Installing Django into our
Virtualenv
Just like on our own machine, a virtualenv is useful in a
deployed environment to make sure we have full control over
the packages installed for a particular project.
We can create a virtualenv in our Dockerﬁle just like we did on
our own machine with python -m venv , and then we can use
pip install  to get Django:
Dockerﬁle (ch09l004)
Traceback (most recent call last): 
  File "/src/manage.py", line 22, in <module> 
    main() 
  File "/src/manage.py", line 13, in main 
    raise ImportError( 
ImportError: Couldn't import Django. Are you sure it'
on your PYTHONPATH environment variable? Did you forg
environment?

FROM python:slim
RUN python -m venv /venv  
ENV PATH="/venv/bin:$PATH"  
RUN pip install "django<5" 
COPY src /src
WORKDIR /src
CMD python manage.py runserver
Here’s where we create our virtualenv
You can’t really “activate” a virtualenv inside a Dockerﬁle, so
instead we change the system PATH so that the venv versions
of pip  and python  become the default ones (this is actually
one of the things that activate  does, under the hood).
We install Django with pip install , just like we do locally.
Successful Run
Let’s do the build  and run  in a single line. This is a pattern I
used quite often when developing a Dockerﬁle, to be able to
quickly rebuild and see the eﬀect of a change:
$ docker build -t superlists . && docker run -it 

[+] Building 0.2s (11/11) FINISHED                   
[...] 
 => [internal] load .dockerignore                    
 => => transferring context: 2B                      
 => [internal] load build definition from Dockerfile 
 => => transferring dockerfile: 246B                 
 => [internal] load metadata for docker.io/library/py
 => CACHED [1/5] FROM docker.io/library/python:slim  
 => [internal] load build context                    
 => => transferring context: 4.75kB                  
 => [2/5] RUN python -m venv /venv                   
 => [3/5] pip install "django<5"                     
 => [4/5] COPY src /src                              
 => [5/5] WORKDIR /src                               
 => exporting to image                               
 => => exporting layers                              
 => => writing image sha256:[...]                    
 => => naming to docker.io/library/superlists        
Watching for file changes with StatReloader 
Performing system checks... 
 
System check identified no issues (0 silenced). 
 
You have 19 unapplied migration(s). Your project may 
[...] 
Django version 4.2.7, using settings superlists.sett
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

OK, scanning through that, it looks like the server is running!
WARNING
Make sure you use the -it  ﬂags to the Docker run  command when running
runserver , or any other tool that expects to be run in an interactive terminal
session, otherwise you’ll get strange behaviours, including not being able to
interrupt the docker process with Ctrl-C. See “How to Stop a Docker Container” for
an escape hatch.

HOW TO STOP A DOCKER CONTAINER
If you’ve got a container that’s “hanging” in a terminal window,
you can kill it from another one.
The docker daemon lets you list all the currently running
containers with docker ps :
This tells us a bit about each container, including a unique ID,
and a randomly-generated name (you can override that if you
want to).
We can use the ID or the name to kill the container with docker
kill :
$ docker kill 0818e1b8e9bf 
0818e1b8e9bf
And if you go back to your other terminal window, you should
ﬁnd the docker process has been terminated.
$ *docker ps* 
CONTAINER ID   IMAGE        COMMAND                  
0818e1b8e9bf   superlists   "/bin/sh -c 'python …"   

Using the FT to Check That Our
Container Works
Let’s see what our FTs think about this Docker version of our
site:
What’s going on here? Time for a little debugging.
Debugging a Container Networking
Problems
First, let’s try and take a look ourselves, in our browser, by
going to http://localhost:8888/:
$ TEST_SERVER=localhost:8888 ./src/manage.py test
    --failfast 
[...] 
selenium.common.exceptions.WebDriverException: Messag
ut:neterror?e=connectionFailure&u=http%3A//localhost%

Figure 9-1. Cannot connect on that port
Now let’s take another look at the output from our docker run .
Here’s what appeared right at the end:
Aha! We notice that we’re using the wrong port, the default
8000  instead of the 8888  that we speciﬁed in the TEST_SERVER
env var.
Let’s ﬁx that by amending the CMD  instruction in the Dockerﬁle:
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.

Dockerﬁle (ch09l005)
[...]
WORKDIR /src 
 
CMD python manage.py runserver 8888
Ctrl+C the current dockerized container process if it’s still
running in your terminal, then give it another build && run :
Debugging Web Server Connectivity With
“curl”
A quick run of the FT or check in our browser will show us that
nope, that doesn’t work either. Let’s try an even lower-level
smoke test, the traditional Unix utility curl . It’s a command-
line tool for making HTTP requests. Try it on your own
computer ﬁrst:
$ docker build -t superlists . && docker run -it 
[...] 
Starting development server at http://127.0.0.1:8888/
$ curl -iv localhost:8888 
*   Trying 127.0.0.1:8888... 

TIP
The -iv  ﬂag to curl is useful for debugging. It prints verbose output, as well as full
HTTP headers.
Running code “inside” the
container with docker exec
So, we can’t see Django running on port 8888 when we’re
outside the container. What do we see if we run things from
inside the container?
We can use docker exec  to run commands inside a running
container. First we need to get the name or ID of the container:
y
g
* connect to 127.0.0.1 port 8888 failed: Connection r
*   Trying [::1]:8888... 
* connect to ::1 port 8888 failed: Connection refused
* Failed to connect to localhost port 8888 after 0 ms
server 
* Closing connection 
[...] 
curl: (7) Failed to connect to localhost port 8888 af
to server

Your values for CONTAINER_ID  and NAMES  will be diﬀerent
from mine, because they’re randomly generated. But, make a
note of one or the other, and then run docker exec -it
<container-id> bash . On most platforms, you can use tab-
completion for the container id or name.
Let’s try it now. Notice that the shell prompt will change from
your default Bash prompt to root@container-id . Watch out
for those in future listings, so that you can be sure of what’s
being run inside vs outside containers.
$ docker ps 
CONTAINER ID   IMAGE        COMMAND                  
5ed84681fdf8   superlists   "/bin/sh -c 'python …"   
$ docker exec -it container-id-or-name bash 
root@5ed84681fdf8:/src# apt-get update && apt-get i
Get:1 http://deb.debian.org/debian bookworm InRelease
Get:2 http://deb.debian.org/debian bookworm-updates I
[...] 
Reading package lists... Done 
Building dependency tree... Done 
Reading state information... Done 
The following additional packages will be installed: 
  libbrotli1 libcurl4 libldap-2.5-0 libldap-common li

p
p
[...] 
root@5ed84681fdf8:/src# curl -iv http://localhost:8
*   Trying 127.0.0.1:8888... 
* Connected to localhost (127.0.0.1) port 8888 (#0) 
> GET / HTTP/1.1 
> Host: localhost:8888 
> User-Agent: curl/7.88.1 
> Accept: */* 
> 
< HTTP/1.1 200 OK 
HTTP/1.1 200 OK 
[...] 
<!doctype html> 
<html lang="en"> 
 
  <head> 
    <title>To-Do lists</title> 
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width
    <link href="/static/bootstrap/css/bootstrap.min.c
  </head> 
 
  <body> 
    [...] 
  </body> 
 
</html>

That’s deﬁnitely some HTML! And the <title>To-Do
lists</title>  looks like it’s our html, too.
So, we can see Django is serving our site inside the container,
why can’t we see it outside??
Docker Port Mapping
The pythonspeed guide to Docker’s very ﬁrst section is called
Connection Refused, so I’ll refer you there once again for an
excellent, detailed explanation.
But in short, Docker runs in its own little world, speciﬁcally it
has its own little network, so the ports inside the container are
diﬀerent from the ports outside the container, the ones we can
see on our host machine.
So we need to tell Docker to connect the internal ports to the
outside ones, to “publish” or “map” them, in Docker
terminology.
docker run  takes a -p  argument, with the syntax
OUTSIDE:INSIDE . So you can actually map a diﬀerent port
number on the inside and outside. But we’re just mapping 8888
to 8888, and that will look like this:
$ d
k
b ild
t
li t
d
k
8

Now that will change the error we see, but only quite subtly (see
Figure 9-2). Things clearly aren’t working yet.
$ docker build -t superlists . && docker run -p 8


Figure 9-2. Cannot connect on that port
Similarly, if you try our curl -iv  (outside the container) once
again, you’ll see the error has changed from “Failed to connect”,
to “Empty reply”:
$ curl -iv localhost:8888 
*   Trying 127.0.0.1:8888... 
* Connected to localhost (127.0.0.1) port 8888 
> GET / HTTP/1.1 
> Host: localhost:8888 
> User-Agent: curl/7.88.1 
> Accept: */* 
[...] 
* Empty reply from server 
* Closing connection 0 
curl: (52) Empty reply from server
Essential Googling the Error Message
The need to map ports and the -p  argument to docker run
are something you just learn, fairly early on in learning Docker.
But the next debugging step is quite a bit more obscure
(although admittedly Itamar does address it in his docker
networking article, did I already mention how excellent it is?).

But if we haven’t read that, we can always resort to the tried
and tested “Googling the error message” technique instead
(Figure 9-3).
Figure 9-3. An indispensable publication (source: https://news.ycombinator.com/item?
id=11459601)
Everyone’s search results are a little diﬀerent, and mine are
perhaps shaped by years of working with Docker and Django,
but I found the answer in my very ﬁrst result (see Figure 9-4),

when I searched for “cannot access django runserver inside
docker”, and the result was was a stackoverﬂow post, saying
something about needing to specify 0.0.0.0  as the IP address.
Figure 9-4. Google can still deliver results
We’re nearing the edges of my understanding of Docker now,
but as I understand it, runserver  binds to 127.0.0.1  by
default, but that IP address doesn’t correspond to the network
adapter inside the container that’s actually connected to the
outside world, via the port mapping we deﬁned earlier.
The long and short of it is that we need use the long-form
ipaddr:port  version of the runserver  command, using the
magic “wilcard” IP address 0.0.0.0 :
Example 9-5. Dockerﬁle (ch09l007)

[...]
WORKDIR /src 
 
CMD python manage.py runserver 0.0.0.0:8888
Rebuild and re-run your server, and if you have eagle eyes,
you’ll spot it’s binding to 0.0.0.0  instead of 127.0.0.1 :
We can verify it’s working with curl :
$ docker build -t superlists . && docker run -p 8
[...] 
Starting development server at http://0.0.0.0:8888/
$ curl -iv localhost:8888 
*   Trying 127.0.0.1:8888... 
* Connected to localhost (127.0.0.1) port 8888 (#0) 
[...] 
 
  </body> 
 
</html> 
* Connection #0 to host localhost left intact

Looking good!
ON DEBUGGING
Let me let you in on a little secret. I’m actually bad at debugging.
We all have our psychological strengths and weaknesses, and
one of my weaknesses is that when I run into a problem I can’t
see an obvious solution to, I want to throw up my hands way
too soon and say “well, this is hopeless, it can’t be ﬁxed”, and
give up.
Thankfully I have had some good role models over the years
who are much better at it than me (hi, Glenn!). Debugging
needs the patience and tenacity of a bloodhound. If at ﬁrst you
don’t succeed, you need to systematically rule out options,
check your assumptions, eliminate various aspects of the
problem and simplify things down, ﬁnd the parts that do and
don’t work, until you eventually ﬁnd the cause.
It always seems hopeless at ﬁrst! But eventually you get there.
Database migrations
A quick visual inspection conﬁrms— the site is up (Figure 9-5)!

Figure 9-5. The site in Docker is up!
Let’s see what our functional tests say:
$ TEST_SERVER=localhost:8888 ./src/manage.py test
f ilf
t

Although the FTs can connect happily and interact with our site,
they are failing as soon as they try to submit a new item.
It’s because we haven’t set up the database (which, as you may
remember, we highlighted as one of the “danger areas” of
deployment). You might have spotted the yellow Django debug
page (Figure 9-6) telling us as much, or if you tried it manually.
    --failfast 
[...] 
E 
=====================================================
ERROR: test_can_start_a_todo_list 
(functional_tests.tests.NewVisitorTest.test_can_start
 ----------------------------------------------------
Traceback (most recent call last): 
  File "...goat-book/src/functional_tests/tests.py", 
test_can_start_a_todo_list 
    self.wait_for_row_in_list_table("1: Buy peacock f
  File "...goat-book/src/functional_tests/tests.py", 
wait_for_row_in_list_table 
    table = self.browser.find_element(By.ID, "id_list
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
[...] 
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_list_table"]; For documentation [...

NOTE
The tests saved us from potential embarrassment there. The site looked ﬁne when
we loaded its front page. If we’d been a little hasty and only testing manually, we
might have thought we were done, and it would have been the ﬁrst users that
discovered that nasty Django DEBUG page. Okay, slight exaggeration for eﬀect,
maybe we would have checked, but what happens as the site gets bigger and more
complex? You can’t check everything. The tests can.


Figure 9-6. But the database isn’t
To be fair, if you look back through the runserver  command
output each time we’ve been starting our container, you’ll see
it’s been warning us about this issue:
NOTE
If you don’t see this error, it’s because your src folder had the database ﬁle in it,
unlike mine. For the sake of argument, run rm src/db.sqlite3  and re-run the build
& run commands, and you should be able to reproduce the error. I promise it’s
instructive!
Should we run “migrate” inside the
Dockerﬁle? No. // JAN: Not sure I
understand this line. You’re saying that we
shouldn’t run migrate inside our
Dockerﬁle, but then in the next line you do
exactly that
You have 19 unapplied migration(s). Your project may 
you apply the migrations for app(s): auth, contenttyp
Run 'python manage.py migrate' to apply them.

So, should we include manage.py migrate  in our Dockerﬁle?
If you try it, you’ll ﬁnd it certainly ﬁxes the problem:
Dockerﬁle (ch09l008)
[...]
WORKDIR /src
RUN python manage.py migrate --noinput  
CMD python manage.py runserver 0.0.0.0:8888
We run migrate  using the --noinput  argument to suppress
any little “are you sure” prompts.
If we rebuild the image and try our FTs again, they all pass!
$ TEST_SERVER=localhost:8888 ./src/manage.py test
    --failfast 
Found 3 test(s). 
Creating test database for alias 'default'... 
System check identified no issues (0 silenced). 
... 
 ----------------------------------------------------
Ran 3 tests in 26.965s 
 
OK

Mounting ﬁles inside the container.
But we don’t actually want to package up our database inside
the image, do we? We want the database on the server to have
totally separate data from the one on our machine.
In most deployments, you’d probably be talking to a separate
database server, like postgres.
For the purposes of this book, the easiest analogy to a server
that’s “outside” our container, is to access the database from the
ﬁlesystem outside the container.
That also gives us a convenient excuse to talk about mounting
ﬁles in Docker, which is a very Useful Thing to be Able to Do ™.
First let’s revert our change:
Dockerﬁle (ch09l009)
[...]
WORKDIR /src 
 
CMD python manage.py runserver 0.0.0.0:8888

Let’s start by re-creating the database with migrate  (when we
moved everything into ./src , we left the database ﬁle behind):
Let’s make sure to .gitignore the new location of the DB ﬁle:
$ echo src/db.sqlite3 >> .gitignore
Now let’s try mounting our database ﬁle. The extra ﬂag to add to
the Docker run command is --mount , where we specify
type=bind , the source  path on our machine, and the target
path inside the container:
$ ./src/manage.py migrate --noinput 
Operations to perform: 
  Apply all migrations: auth, contenttypes, lists, se
Running migrations: 
  Applying contenttypes.0001_initial... OK 
[...] 
  Applying sessions.0001_initial... OK
$ docker build -t superlists . && docker run \ 
  -p 8888:8888 \ 
  --mount type=bind,source=./src/db.sqlite3,targe
  -it superlists

TIP
The old syntax for mounts was -v . One of the advantages of the new --mount
syntax is that it will fail hard if the path you’re trying to mount into the container
does not exist (it says something like bind source path does not exist ) This
avoids a lot of pain, ask me how I know this.
And we check the FTs again.
AMAZING IT ACTUALLY WORKSSSSSSSS.
Ahem, that’s deﬁnitely good enough for now! Let’s commit.
$ git add Dockerfile 
$ git commit -m"First cut of a Dockerfile"
$ TEST_SERVER=localhost:8888 ./src/manage.py test
    --failfast 
Found 3 test(s). 
Creating test database for alias 'default'... 
System check identified no issues (0 silenced). 
... 
 ----------------------------------------------------
Ran 3 tests in 26.965s 
 
OK

Phew. Well, it took a bit of hacking about, but now we can be
reassured that the basic Docker plumbing works. Notice that
the FT was able to guide us incrementally towards a working
conﬁg, and spot problems early on (like the missing database).
But we really can’t be using the Django dev server in
production, or running on port 8888 forever. In the next
chapter, we’ll make our hacky image more production-ready.
But ﬁrst, time for a well-earned tea break I think, and perhaps a
chocolate biscuit.

TEST-DRIVING SERVER CONFIGURATION AND DEPLOYMENT
Tests and small steps take some of the uncertainty out of
deployment
For developers, ops and infra work is always “fun”, by which
I mean a process full of fear, uncertainty and surprises. My
aim during this chapter was to show that a step-by-step
approach helps to minimise risk, especially when allied to a
functional test suite that can help us to catch errors early.
Some typical pain points— networking, ports, static ﬁles, and
the database
Moving from the local django development server to a
container is chance to rehearse the ﬁddliness of conﬁguring
networking in a deployed environment. It’s also a chance to
think about persistence and the database, and some
conﬁguration issues like static ﬁles.
 This was, more or less, the approach I took in earlier
editions of the book. With a fair bit of testing thrown in of
course.
 A common thing to ﬁnd outside of the src folder is a folder
called tests. We won’t be doing that while we’re relying on the
1
2

standard Django test framework, but it’s a good thing to do if
you’re using pytest, for example.

Chapter 10. Making Our App
Production-Ready
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 10th chapter of the ﬁnal book. The GitHub repo
is available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
Our container is working ﬁne but it’s not production-ready. Let’s
try to get it there, using the tests to keep us safe.
In a way we’re applying the Red-Green-Refactor cycle to our
productionisation process. Our hacky container conﬁg got us to
Green, and now we’re going to Refactor, working incrementally

(just as we would while coding), trying to move from working
state to working state, and using the FTs to detect any
regressions.


WARNING, CHAPTER UNDER CONSTRUCTION
As part of my work on the third edition of the book, I’m making
big changes to the deployment chapters. This chapter is still
very fresh, but the content is all there, so you should be able to
follow along.
But as always I really, really need feedback. So please hit me up
at obeythetestinggoat@gmail.com, or via GitHub Issues and Pull
Requests.
What We Need to Do
What’s wrong with our hacky container image? A few things:
ﬁrst, we need to host our app on the “normal” port 80 so that
people can access it using a regular URL.
Perhaps more importantly, we shouldn’t use the Django dev
server for production; it’s not designed for real-life workloads.
Instead, we’ll use the popular Gunicorn Python WSGI HTTP
server.

NOTE
Django’s runserver  is built and optimised for local development and debugging. It’s
designed to handle one user at a time, it handles automatic reloading upon saving of
the source code, but it isn’t optimised for performance, nor has it been hardened
against security vulnerabilities.
In addition, several options in settings.py are currently
unacceptable. DEBUG=True , is strongly discouraged for
production, we’ll want to set a unique SECRET_KEY , and, as we’ll
see, other things will come up.
NOTE
DEBUG=True is considered a security risk, because the django debug page will
display sensitive information like the values of variables, and most of the settings in
settings.py.
Let’s go through and see if we can ﬁx things one by one.
Switching to Gunicorn
Do you know why the Django mascot is a pony? The story is that
Django comes with so many things you want: an ORM, all sorts
of middleware, the admin site… “What else do you want, a

pony?” Well, Gunicorn stands for “Green Unicorn”, which I
guess is what you’d want next if you already had a pony… 
We’ll need to ﬁrst install Gunicorn into our container, and then
use it instead of runserver :
$ pip install gunicorn 
Collecting gunicorn 
[...] 
Successfully installed gunicorn-21.2.0

WHAT IS WSGI?
Gunicorn is a WSGI (usually pronounced as whizgee) HTTP
server. Let’s go through what this means:
An HTTP server handles incoming HTTP requests and sends
back responses to the clients.
WSGI, the Web Server Gateway Interface, is a set of rules
deﬁning how an HTTP server (which can be Gunicorn itself,
or Nginx, Apache, etc) and a Python program should
communicate.
So, Gunicorn is an HTTP server that knows and uses the WSGI
to “talk” to Python programs. And these Python programs are
likewise expected to work in a speciﬁc way. You can check out a
simple example on Gunicorn’s website under “Installation”.
If you are interested, you can read the entire speciﬁcation here.
Gunicorn will need to know a path to a “WSGI server” (see
“What is WSGI?”), which is usually a function called
application . Django provides one in superlists/wsgi.py. Let’s
change the command our image runs:
Dockerﬁle (ch10l001)

Installation is a standard pip install.
Gunicorn has its own command line, gunicorn . It needs to
know a path to a WSGI server, which is usually a function
called application . Django provides one in
superlists/wsgi.py.
As in the previous chapter, we can use the docker build &&
docker run  pattern to try out our changes by rebuilding and
rerunning our container:
The FTs catch a problem with static ﬁles
[...]
RUN pip install "django<5" gunicorn  
COPY src /src
WORKDIR /src
CMD gunicorn --bind :8888 superlists.wsgi:application
$ docker build -t superlists . && docker run \ 
  -p 8888:8888 \ 
  --mount type=bind,source=./src/db.sqlite3,targe
  -it superlists

As we run the functional tests, you’ll see them warning us of a
problem, once again. The test for adding list items passes
happily, but the test for layout + styling fails. Good job, tests!
And indeed, if you take a look at the site, you’ll ﬁnd the CSS is all
broken, as in Figure 10-1.
The reason that we have no CSS is that although the Django dev
server will serve static ﬁles magically for you, Gunicorn doesn’t.
$ TEST_SERVER=localhost:8888 python src/manage.py
  --failfast 
[...] 
AssertionError: 102.5 != 512 within 10 delta (409.5 d
FAILED (failures=1)

Figure 10-1. Broken CSS
One step forward, one step backward, but once again we’ve
identiﬁed the problem nice and early. Moving on!

Serving Static Files with Whitenoise
Serving static ﬁles is very diﬀerent from serving dynamically
rendered content from Python and Django. There are many
ways to serve them in production: you can use a web server like
Nginx, or a CDN like Amazon S3, but in our case, the most
straightforward thing to do is to use Whitenoise, a Python
library expressly designed for serving static  ﬁles from Python.
This is how we tell Django to enable it, in settings.py:
src/superlists/settings.py (ch10l002)
And if you take another manual look at your site after
rebuilding the container, things should look much healthier.
And then we need to add it to our pip installs in the Dockerﬁle:
Example 10-3. Dockerﬁle (ch10l003)
MIDDLEWARE = [ 
    "django.middleware.security.SecurityMiddleware", 
    "whitenoise.middleware.WhiteNoiseMiddleware", 
    "django.contrib.sessions.middleware.SessionMiddle
    [...]
1

RUN pip install "django<5" gunicorn whitenoise
This manual list of pip installs is getting a little ﬁddly! We’ll
come back to that in a moment. First let’s rebuild and try re-
running our FTs:
And if you take another manual look at your site, things should
look much healthier. Let’s rerun our FTs to conﬁrm:
$ docker build -t superlists . && docker run \ 
  -p 8888:8888 \ 
  --mount type=bind,source=./src/db.sqlite3,targe
  -it superlists
$ TEST_SERVER=localhost:8888 python src/manage.py
  --failfast 
[...] 
 
... 
 ----------------------------------------------------
Ran 3 tests in 10.718s 
 
OK

Phew. Let’s commit that:
Using requirements.txt
Let’s deal with that ﬁddly list of pip installs.
To reproduce our local virtualenv, rather than just manually pip
installing things one by one, and having to remember to sync
things between local dev and docker, we can “save” the list of
packages we’re using by creating a requirements.txt ﬁle.
The pip freeze  command will show us everything that’s
installed in our virtualenv at the moment:
$ pip freeze 
asgiref==3.8.1 
attrs==23.2.0 
certifi==2024.2.2 
django==4.2.11 
gunicorn==21.2.0 
h11==0.14.0 
idna==3.6 
outcome==1.3.0.post0 
$ git commit -am"Switch to Gunicorn and Whitenois
2

packaging==24.0 
pysocks==1.7.1 
selenium==4.18.1 
sniffio==1.3.1 
sortedcontainers==2.4.0 
sqlparse==0.4.4 
trio==0.25.0 
trio-websocket==0.11.1 
typing-extensions==4.10.0 
urllib3==2.2.1 
whitenoise==6.6.0 
wsproto==1.2.0
That shows all the packages in our virtualenv, along with their
version numbers. Let’s pull out just the “top-level”
dependencies, Django, Gunicorn and Whitenoise:
That should give us a requirements.txt ﬁle that looks like this:
$ pip freeze | grep -i django 
Django==4.2.11 
 
$ pip freeze | grep -i django >> requirements.txt
$ pip freeze | grep -i gunicorn >> requirements.t
$ pip freeze | grep -i whitenoise >> requirements

requirements.txt (ch10l004)
django==4.2.11
gunicorn==21.2.0
whitenoise==6.6.0
That’s a good ﬁrst cut, let’s commit it:
You may be wondering why we didn’t add our other
dependency, Selenium, to our requirements, or why we didn’t
just add all the dependencies, including the “transitive” ones
(eg, Django has its own dependencies like asgiref  and
sqlparse  etc).
As always, I have to gloss over some nuance and tradeoﬀs, but
the short answer is ﬁrst, Selenium is only a dependency for the
tests, not the application code; we’re never going to run the
tests directly on our production servers. As to transitive
dependencies, they’re ﬁddly to manage without bringing in
more tools, and I didn’t want to do that for this book.
$ *git add requirements.txt* 
$ *git commit -m "Add a requirements.txt with Django,
3

TIP
Itamar Turner-Traurig has a great guide to Docker Packaging for Python Developers,
which I cannot recommend highly enough. Read that before you’re too much older.
Now let’s see how we use that requirements ﬁle in our
Dockerﬁle:
Example 10-5. Dockerﬁle (ch10l005)
FROM python:slim
RUN python -m venv /venv
ENV PATH="/venv/bin:$PATH"
COPY requirements.txt requirements.txt  
RUN pip install -r requirements.txt  
COPY src /src
WORKDIR /src
CMD python manage.py runserver
We COPY our requirements ﬁle in, just like the src folder.
Now instead of just installing Django, we install all our
dependencies by pointing pip at the requirements.txt using
the -r  ﬂag. Notice the -r .

TIP
Forgetting the -r  and running pip install requirements.txt  is such a common
error, that I recommend you do it right now and get familiar with the error message
(which is thankfully much more helpful than it used to be). It’s a mistake I still
make, all the time.
Let’s do a build & run & test to check everything still works:
Using Environment Variables to
Adjust Settings for Production
We know there are several things in settings.py that we want to
change for production:
DEBUG  mode is all very well for hacking about on your own
server, but it isn’t secure. For example, exposing raw
tracebacks to the world is a bad idea.
$ docker build -t superlists . && docker run \ 
  -p 8888:8888 \ 
  --mount type=bind,source=./src/db.sqlite3,targe
  -it superlists

SECRET_KEY  is used by Django for some of its crypto— things
like cookies and CSRF protection. It’s good practice to make
sure the secret key in production is diﬀerent from the one in
your source code repo, because that code might be visible to
strangers. We’ll want to generate a new, random one but
then keep it the same for the foreseeable future (ﬁnd out
more in the Django docs).
Development, staging and production sites always have some
diﬀerences in their conﬁguration. Environment variables are a
good place to store those diﬀerent settings. See “The 12-Factor
App”.
Setting DEBUG=True and SECRET_KEY
There are lots of ways you might do this.
Here’s what I propose; it may seem a little ﬁddly, but I’ll provide
a little justiﬁcation for each choice. Let them be an inspiration
(but not a template) for your own choices!
superlists/settings.py (ch10l006)
import os
[
]
4

We say we’ll use an environment variable called
DJANGO_DEBUG_FALSE  to switch debug mode oﬀ, and in eﬀect
require production settings (it doesn’t matter what we set it
to, just that it’s there).
And now we say that, if debug mode is oﬀ, we require the
SECRET_KEY  to be set by a second environment variable.
Otherwise we fall-back to the insecure, debug mode settings
that are useful for Dev.
The end result is that you don’t need to set any env vars for dev,
but production needs both to be set explicitly, and it will error if
any are missing. I think this gives us a little bit of protection
against accidentally forgetting to set one.
TIP
Better to fail hard than allow a typo in an environment variable name to leave you
running with insecure settings.
[...]
if "DJANGO_DEBUG_FALSE" in os.environ:  
    DEBUG = False
    SECRET_KEY = os.environ["DJANGO_SECRET_KEY"]  
else:
    DEBUG = True  
    SECRET_KEY = "insecure-key-for-dev"

Setting environment variables inside the
Dockerﬁle
Now let’s set that environment variable in our Dockerﬁle using
the ENV  directive:
Dockerﬁle (ch10l007)
And try it out… 
WORKDIR /src 
 
ENV DJANGO_DEBUG_FALSE=1
CMD gunicorn --bind :8888 superlists.wsgi:application
$ docker build -t superlists . && docker run \ 
  -p 8888:8888 \ 
  --mount type=bind,source=./src/db.sqlite3,targe
  -it superlists 
 
[...] 
  File "/src/superlists/settings.py", line 22, in <mo
    SECRET_KEY = os.environ["DJANGO_SECRET_KEY"] 
                 ~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^ 
  File "<frozen os>", line 685, in __getitem__ 
KeyError: 'DJANGO_SECRET_KEY'

Oops. I forgot to set said secret key env var, mere seconds after
having dreamt it up!
Setting Environment Variables at the
Docker Command Line
We’ve said we can’t keep the secret key in our source code, so
the Dockerﬁle isn’t an option; where else can we put it?
For now, we can set it at the command line using the -e  ﬂag for
docker run :
With that running, we can use our FT again to see if we’re back
to a working state.
$ docker build -t superlists . && docker run \ 
  -p 8888:8888 \ 
  --mount type=bind,source=./src/db.sqlite3,targe
  -e DJANGO_SECRET_KEY=sekrit \ 
  -it superlists
$ TEST_SERVER=localhost:8888 python src/manage.py
  --failfast 
[
]

ALLOWED_HOSTS is Required When
Debug Mode is Turned Oﬀ
It’s not quite working yet! Let’s take a look manually: Figure 10-
2.
[...] 
AssertionError: 'To-Do' not found in 'Bad Request (40

Figure 10-2. An ugly 400 error
We’ve set our two environment variables but doing so seems to
have broken things. But once again, by running our FTs
frequently, we’re able to identify the problem early, before
we’ve changed too many things at the same time. We’ve only
changed two settings—which one might be at fault?

Let’s use the “Googling the error message” technique again,
with the search terms “django debug false” and “400 bad
request”.
Well, the very ﬁrst link in my search results was Stackoverﬂow
suggesting that a 400 error is usually to do with
ALLOWED_HOSTS , and the second was the oﬃcial Django docs,
which takes a bit more scrolling, but conﬁrms it (see Figure 10-
3).


Figure 10-3. Search results for “django debug false 400 bad request”
ALLOWED_HOSTS  is a security setting designed to reject requests
that are likely to be forged, broken or malicious because they
don’t appear to be asking for your site (HTTP requests contain
the address they were intended for in a header called “Host”).
By default, when DEBUG=True, ALLOWED_HOSTS  eﬀectively
allows localhost, our own machine, so that’s why it was working
OK until now.
There’s more information in the Django docs.
The upshot is that we need to adjust ALLOWED_HOSTS  in
settings.py. Let’s use another environment variable for that:
superlists/settings.py (ch10l008)
if "DJANGO_DEBUG_FALSE" in os.environ: 
    DEBUG = False 
    SECRET_KEY = os.environ["DJANGO_SECRET_KEY"] 
    ALLOWED_HOSTS = [os.environ["DJANGO_ALLOWED_HOST"
else: 
    DEBUG = True 
    SECRET_KEY = "insecure-key-for-dev" 
    ALLOWED_HOSTS = []

This is a setting that we want to change, depending on whether
our Docker image is running locally, or on a server, so we’ll use
the -e  ﬂag again:
Collectstatic is Required when Debug is
Turned Oﬀ
An FT run (or just looking at the site) reveals that we’ve had a
regression in our static ﬁles:
$ docker build -t superlists . && docker run \ 
    -p 8888:8888 \ 
    --mount type=bind,source=./src/db.sqlite3,tar
    -e DJANGO_SECRET_KEY=sekrit \ 
    -e DJANGO_ALLOWED_HOST=localhost \ 
    -it superlists
$ TEST_SERVER=localhost:8888 python src/manage.py
  --failfast 
[...] 
AssertionError: 102.5 != 512 within 10 delta (409.5 d
FAILED (failures=1)

We saw this before when switching from the Django dev server
to Gunicorn, so we introduced Whitenoise. Similarly, when we
switch DEBUG oﬀ, Whitenoise stops automagically ﬁnding static
ﬁles in our code, and instead we need to run collectstatic :
Dockerﬁle (ch10l009)
Well, it was ﬁddly, but that should get us to passing tests!
We’re nearly ready to ship to production!
Let’s quickly adjust our gitignore, since the static folder is in a
new place:
WORKDIR /src 
 
RUN python manage.py collectstatic 
 
ENV DJANGO_DEBUG_FALSE=1
CMD gunicorn --bind :8888 superlists.wsgi:application
$ TEST_SERVER=localhost:8888 python src/manage.py
  --failfast 
[...] 
OK

Switching to a nonroot user
TODO: WIP, this is deﬁnitely a good idea for security, needs
writing up.
Dockerﬁle should gain some lines a bit like this:
Example 10-10. Dockerﬁle (ch10l0XX)
Conﬁguring logging
$ git status 
# should show dockerfile and untracked src/static fol
$ echo src/static >> .gitignore 
$ git status 
# should now be clean 
$ git commit -am "Add collectstatic to dockerfile
RUN addgroup --system nonroot && adduser --system --g
 
USER nonroot

One last thing we’ll want to do is make sure that we can get logs
out of our server. If things go wrong, we want to be able to get
to the tracebacks, and as we’ll soon see, switching DEBUG oﬀ
means that Django’s default logging conﬁguration changes.
Provoking a deliberate error
To test this, we’ll provoke a deliberate error by deleting the
database ﬁle.
Now if you run the tests, you’ll see they fail;
And you might spot in the browser that we just see a minimal
error page, with no debug info (try it manually if you like):
$ rm src/db.sqlite3 
$ touch src/db.sqlite3  # otherwise the --mount typ
$ TEST_SERVER=localhost:8888 python src/manage.py
  --failfast 
[...] 
 
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_list_table"]; [...]

Figure 10-4. Minimal default server error 500
But if you look in your docker terminal, you’ll see there is no
traceback:
[2024-02-28 10:41:53 +0000] [7] [INFO] Starting gunic
[2024-02-28 10:41:53 +0000] [7] [INFO] Listening at: 

Where have the tracebacks gone? You might have been
expecting that the django debug page and its tracebacks would
disappear from our web browser, but it’s more of shock to see
that they are no longer appearing in the terminal either! If
you’re like me you might ﬁnd yourself wondering if we really
did see them earlier and starting to doubt your own sanity. But
the explanation is that Django’s default logging conﬁguration
changes when DEBUG is turned oﬀ:
This means we need to interact with the standard library’s
logging  module, unfortunately one of the most ﬁddly parts of
the Python standard library .
Here’s pretty much the simplest possible logging conﬁg which
just prints everything to the console (i.e. standard out).
src/superlists/settings.py (ch10l011)
[2024-02-28 10:41:53 +0000] [7] [INFO] Using worker: 
[2024-02-28 10:41:53 +0000] [8] [INFO] Booting worker
LOGGING = { 
    "version": 1, 
    "disable_existing_loggers": False, 
    "handlers": { 
        "console": {"class": "logging.StreamHandler"}
5

Rebuild and restart our container, try the FT again (or
submitting a new list item manually) and we now should see a
clear error message:
    }, 
    "loggers": { 
        "root": {"handlers": ["console"], "level": "I
    },
}
Internal Server Error: /lists/new 
Traceback (most recent call last): 
[...] 
  File "/src/lists/views.py", line 10, in new_list 
    nulist = List.objects.create() 
             ^^^^^^^^^^^^^^^^^^^^^ 
[...] 
  File "/venv/lib/python3.12/site-packages/django/db/
  line 328, in execute 
    return super().execute(query, params) 
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
django.db.utils.OperationalError: no such table: list

Re-create the database with ./src/manage.py migrate  and
we’ll be back to a working state.
Don’t forget to commit our changes to settings.py and
Dockerﬁle, and I think we can call it job done! We’ve at least
touched on many or most of the things you might need to think
about when considering production-readiness, we’ve worked in
small steps and used our tests all the way along, and we’re now
ready to deploy our container to a real server!
Find out how, in our next exciting installment… 

PRODUCTION-READINESS CONFIG
A few things to think about when trying to prepare a
production-ready conﬁguration:
Don’t use the Django dev server in production
Something like Gunicorn or uWSGI is a better tool for
running Django; it will let you run multiple workers, for
example.
Decide how to serve your static ﬁles
Static ﬁles aren’t the same kind of things as the dynamic
content that comes from Django and your webapp, so they
need to be treated diﬀerently. WhiteNoise is just one example
of how you might do that.
Check your settings.py for dev-only conﬁg
DEBUG=True , ALLOWED_HOSTS  and SECRET_KEY  are the ones
we came across, but you will probably have others (we’ll see
more when we start to send emails from the server).
Change things one at a time and rerun your tests frequently
Whenever we make a change to our server conﬁguration, we
can rerun the test suite, and either be conﬁdent that
everything works as well as it did before, or ﬁnd out
immediately if we did something wrong.

Think about logging and observability
When things go wrong, you need to be able to ﬁnd out what
happened. At a minimum you need a way of getting logs and
tracebacks out of your server, and in more advanced
environments you’ll want to think about metrics and tracing
too. But we can’t cover all that in this book!
 Believe it or not, this pun didn’t actually hit me until I was
rewriting this chapter. For 10 years it was right under my nose. I
think that makes it funnier actually.
 There are many other dependency management tools these
days so requirements.txt is not the only way to do it, although it
is one of the oldest and best established. As you continue your
Python adventures I’m sure you’ll come across many others.
 When you have a moment, you might want to do some
further reading on “lockﬁles”, pyproject.toml, hard pinning vs
soft pining, and immediate vs transitive dependencies. If I
absolutely had to recommend a python dependency
management tool, it would be pip-tools, which is a fairly
minimal one.
1
2
3

 Another common way of handling this is to have diﬀerent
versions of settings.py for dev and prod. That can work ﬁne too,
but it can get confusing to manage. Environment variables also
have the advantage of working for non-Django stuﬀ too.
 It’s not necessarily for bad reasons, but it is all very Java-ey
and enterprisey. I mean, yes, separating the concepts of
handlers and loggers and ﬁlters, and making it all conﬁgurable
in a nested hierarchy is all well and good and covers every
possible use case, but sometimes you just wanna say “just print
stuﬀ to stdout pls”, and you wish that conﬁguring the simplest
thing was a little easier.
4
5

Chapter 11. Infrastructure As Code:
Automated Deployments With
Ansible
A NOTE FOR EARLY RELEASE READERS
With Early Release ebooks, you get books in their earliest form
—the author’s raw and unedited content as they write—so you
can take advantage of these technologies long before the oﬃcial
release of these titles.
This will be the 11th chapter of the ﬁnal book. The GitHub repo
is available at https://github.com/hjwp/book-example.
If you have comments about how we might improve the
content and/or examples in this book, or if you notice missing
material within this chapter, please reach out to the author at
obeythetestinggoat@gmail.com.
Automate, automate, automate.
—Cay Horstman

In this chapter we’re going to spin up an actual server, make it
accessible on the Internet with a real domain name, and then
we’re going to install our app on it, using our container.
We could do all these things manually, but a key insight of the
modern infrastructure management is that automation really
pays oﬀ in reducing maintenance burdens.
It’s also key to making sure our tests give us true conﬁdence
over our deployments. If we go to the trouble of building a
staging server,  we want to make sure that it’s as similar as
possible to the production environment. By automating the way
we deploy, and using the same automation for staging and prod,
we give ourselves much more conﬁdence.
The buzzword for automating your deployments these days is
“Infrastructure as Code” (IaC).
NOTE
Why not ping me a note once your site is live on the web, and send me the URL? It
always gives me a warm and fuzzy feeling… Email me at
obeythetestinggoat@gmail.com.
1


WARNING, CHAPTER UNDER CONSTRUCTION
As part of my work on the third edition of the book, I’m making
big changes to the deployment chapters. This chapter is still
very fresh, but the content is all there, so you should be able to
follow along.
But as always I really, really need feedback. So please hit me up
at obeythetestinggoat@gmail.com, or via GitHub Issues and Pull
Requests.
I hope you enjoy the new version!
Getting a Domain Name
We’re going to need a couple of domain names at this point in
the book— they can both be subdomains of a single domain. I’m
going to use superlists.ottg.co.uk and staging.ottg.co.uk. If you
don’t already own a domain, this is the time to register one!
Again, this is something I really want you to actually do. If
you’ve never registered a domain before, just pick any old
registrar and buy a cheap one— it should only cost you $5 or so,
and you can even ﬁnd free ones. I promise seeing your site on a
“real” website will be a thrill.

Manually Provisioning a Server to
Host Our Site
We can separate out “deployment” into two tasks:
Provisioning a new server to be able to host the code
Deploying a new version of the code to an existing server
Infrastructure-as-code tools can let you automate both of these,
but the provisioning parts tend to be quite vendor-speciﬁc, so
for the purposes of this book, we can live with manual
provisioning.
NOTE
I should probably stress once more that deployment is something that varies a lot,
and that as a result there are few universal best practices for how to do it. So, rather
than trying to remember the speciﬁcs of what I’m doing here, you should be trying
to understand the rationale, so that you can apply the same kind of thinking in the
speciﬁc future circumstances you encounter.
Choosing Where to Host Our Site
There are loads of diﬀerent solutions out there these days, but
they broadly fall into two camps:

Running your own (probably virtual) server
Using a Platform-As-A-Service (PaaS) oﬀering like Heroku or
my old employers, PythonAnywhere.
Particularly for small sites, a PaaS oﬀers a lot of advantages, and
I would deﬁnitely recommend looking into them. We’re not
going to use a PaaS in this book however, for several reasons.
The main reason is that I want to avoid endorsing speciﬁc
commercial providers. Secondly, all the PaaS oﬀerings are quite
diﬀerent, and the procedures to deploy to each vary a lot— 
learning about one doesn’t necessarily tell you about the others.
Any one of them might radically change their process or
business model by the time you get to read this book.
Instead, we’ll learn just a tiny bit of good old-fashioned server
admin, including SSH and manual server conﬁg. They’re
unlikely to ever go away, and knowing a bit about them will get
you some respect from all the grizzled dinosaurs out there.
Spinning Up a Server
I’m not going to dictate how you spin up a server— whether you
choose Amazon AWS, Rackspace, Digital Ocean, your own
server in a data centre, or a Raspberry Pi in a cupboard under
the stairs, any solution should be ﬁne, as long as:

Your server is running Ubuntu 22.04 (aka “Jammy/LTS”).
You have root access to it.
It’s on the public internet.
You can SSH into it.
I’m recommending Ubuntu as a distro because it’s popular and
I’m used to it. If you know what you’re doing, you can probably
get away with using something else, but I won’t be able to help
you as much if you get stuck.
If you’ve never started a Linux server before and you have
absolutely no idea where to start, I wrote a very brief guide on
GitHub.
NOTE
Some people get to this chapter, and are tempted to skip the domain bit, and the
“getting a real server” bit, and just use a VM on their own PC. Don’t do this. It’s not
the same, and you’ll have more diﬃculty following the instructions, which are
complicated enough as it is. If you’re worried about cost, have a look at the guide I
wrote for free options.
User Accounts, SSH, and Privileges
In the following instructions, I’m assuming that you have a
nonroot user account set up, and that it has “sudo” privileges,

so whenever we need to do something that requires root access,
we use sudo, (or “become” in Ansible terminology), and I’m
explicit about that in the various instructions that follow.
My user is called “elspeth”, but you can call yours whatever you
like! Just remember to substitute it in all the places I’ve
hardcoded it. See the guide I wrote if you need tips on creating a
sudo user.
SECURITY
A serious discussion of server security is beyond the scope of
this book, and I’d warn against running your own servers
without learning a good bit more about it. (One reason people
choose to use a PaaS to host their code is that it means a slightly
fewer security issues to worry about.) If you’d like a place to
start, here’s as good a place as any:
https://www.jamesonricks.com/re-post-my-ﬁrst-5-minutes-on-a-
server-or-essential-security-for-linux-servers/
I can deﬁnitely recommend the eye-opening experience of
installing fail2ban and watching its logﬁles to see just how
quickly it picks up on random drive-by attempts to brute force
your SSH login. The internet is a wild place!

Conﬁguring Domains for Staging
and Live
We don’t want to be messing about with IP addresses all the
time, so we should point our staging and live domains to the
server. At my registrar, the control screens looked a bit like
Figure 11-1.


Figure 11-1. Domain setup
In the DNS system, pointing a domain at a speciﬁc IP address is
called an “A-Record”. All registrars are slightly diﬀerent, but a
bit of clicking around should get you to the right screen in
yours. You’ll need two A-records: one for the staging address
and one for the live one. No need to worry about any other type
of record.
DNS records take some time to “propagate” around the world
(it’s controlled by a setting called “TTL”, Time To Live), so once
you’ve set up your A-record, you can check its progress on a
“propagation checking” service like this one:
https://www.whatsmydns.net/#A/staging.ottg.co.uk.
I’m planning to host my staging server at staging.ottg.co.uk
Ansible
Infrastructure-as-code tools, also called “conﬁguration
management” tools, come in lots of shapes and sizes. Chef and
Puppet were two of the original ones, and you’ll probably come
across Terraform, which is particularly strong on managing
cloud services like AWS.

We’re going to use Ansible, because it’s relatively popular,
because it can do everything we need it to, because I’m biased
that it happens to be written in Python, and because it’s
probably the one I’m personally most familiar with.
Another tool could probably have worked just as well! The
main thing to remember is the concept, which is that, as much
as possible we want to manage our server conﬁguration
declaratively, by expressing the desired state of the server in a
particular conﬁg syntax, rather than specifying a procedural
series of steps to be followed one by one.
Installing Ansible
Take a look at the
https://docs.ansible.com/ansible/latest/installation_guide/intro_ins
tallation.html [documentation] for instructions on how to install
Ansible.
The simplest thing to do is to install Ansible into the virtualenv
on our local machine:
$ pip install ansible 
# we also need the Docker SDK for the ansible/docker 
$ pip install docker

A First Cut of an Ansible Playbook
Let’s dip our toes into Ansible, and see if we can get it to run a
simple “hello world” container on our server.
Here’s what’s called a “playbook” in Ansible terminology. It’s in
a format called YAML (Yet Another Markup Language), which, if
you’ve never come across before, you will soon develop a love-
hate relationship  for.
.infra/ansible-provision.yaml (ch11l001)
Example 11-1.
---
- hosts: all 
 
  tasks: 
 
    - name: Install docker  
      ansible.builtin.apt:  
        name: docker.io  
        state: latest
        update_cache: true
      become: true 
 
2

    - name: Run test container
      community.docker.docker_container:
        name: testcontainer
        state: started
        image: busybox
        command: echo hello world
      become: true
The one described here is much closer to Docker’s installation
guide: https://www.digitalocean.com/community/tutorials/how-
to-use-ansible-to-install-and-set-up-docker-on-ubuntu-22-04
An Ansible playbook is a series of “tasks” (so in that sense it’s
still quite sequential and procedural), but the individual tasks
themselves are quite declarative. Each one usually has a
human-readable name  attribute.
Each task uses an Ansible “module” to do its work. This one
uses the builtin.apt  module which provides a wrapper
around the apt  Debian & Ubuntu package management tool.
Each module then provides a bunch of parameters which
control how it works. Here we specify the name  of the
package we want to install (“docker.io” ) and tell it to update
its cache ﬁrst, which is required on a fresh server.
Most Ansible modules have pretty good documentation, check
out the builtin.apt  one for example. I often skip to the
3

Examples section.
$ ansible-playbook --user=elspeth -i staging.ottg
ansible-playbook [core 2.16.3] 
  config file = None 
  [...] 
No config file found; using defaults 
BECOME password: 
Skipping callback default, as we already have a stdo
Skipping callback minimal, as we already have a stdo
Skipping callback oneline, as we already have a stdo
 
PLAYBOOK: ansible-provision.yaml  
1 plays in infra/ansible-provision.yaml 
 
PLAY [all]  
 
TASK [Gathering Facts] * 
task path: ...goat-book/superlists/infra/ansible-
ok: [staging.ottg.co.uk] 
PLAYBOOK: ansible-provision.yaml * 
1 plays in infra/ansible-provision.yaml 
 
TASK [Install docker]  
task path: ...goat-book/superlists/infra/ansible-
ok: [staging.ottg.co.uk] => {"cache_update_time"
 
 

I don’t know about you, but whenever I make a terminal spew
out a stream of output, I like to make little brrp brrp brrp noises,
a bit like the computer Mother, in Alien. Ansible scripts are
particularly satisfying in this regard.
TIP
You may need to use the --ask-become-pass  argument to ansible-playbook  if you
get an error “Missing sudo password”.
TASK [Install docker] * 
task path: ...goat-book/superlists/infra/ansible-
changed: [staging.ottg.co.uk] => {"cache_update_t
"cache_updated": true, "changed": true, "stderr"
"stdout": "Reading package lists...\nBuilding dep
information...\nThe following additional packages
wmdocker\nThe following NEW packages will be inst
 
TASK [Run test container]  
task path: ...goat-book/superlists/infra/ansible-prov
changed: [staging.ottg.co.uk] => {"changed": true, "c
{"AppArmorProfile": "docker-default", "Args": ["hello
[...] 
 
PLAY RECAP ** 
staging.ottg.co.uk         : ok=3    changed=2    unr
skipped=0    rescued=0    ignored=0

SSHing Into the Server and Viewing
Container Logs
Time to get into some good old-fashioned sysadmin! Let’s SSH
into our server and see if we can see any evidence that our
container has run.
We use docker ps -a  to view all containers, including
old/stopped ones, and we can use docker logs  to view the
output from one of them:
$ ssh elspeth@staging.superlists.ottg.co.uk 
Welcome to Ubuntu 22.04.4 LTS (GNU/Linux 5.15.0-67-ge
 [...] 
 
elspeth@server$ docker ps -a 
CONTAINER ID   IMAGE     COMMAND              CREATED
PORTS     NAMES 
3a2e600fbe77   busybox   "echo hello world"   2 days 
minutes ago             testcontainer 
 
elspeth@server:$ docker logs testcontainer 
hello world

TIP
Look out for that elspeth@server  in the command-line listings in this chapter. It
indicates commands that must be run on the server, as opposed to commands you
run on your own PC.
SSHing in to check things worked is a key server debugging
skill! It’s something we want to practice on our staging server,
because ideally we’ll want to avoid doing it on production
machines.
Let’s move on to trying to get our actual docker container
running on the server. As we go through, you’ll see that we’re
going to work through very similar issues to the ones we’ve
already ﬁgured our way through in the last couple of chapters:
Conﬁguration
Networking
And the database.
Getting our image onto the server
Typically, you can “push” and “pull” container images to a
“container registry" — Docker oﬀers a public one called

DockerHub, and organisations will often run private ones,
hosted by cloud providers like AWS.
So your process of getting an image onto a server is usually
Push the image from your machine to the registry
Pull the image from the registry onto the server. Usually this
step is implicit, in that you just specify the image name in the
format registry-url/image-name:tag, and then docker run
takes care of pulling down the image for you.
But I don’t want to ask you to create a DockerHub account, or
implicitly endorse any particular provider, so we’re going to
“simulate” this process by doing it manually.
It turns out you can “export” a container image to an archive
format, manually copy that to the server, and then re-import it.
In Ansible conﬁg, it looks like this:
infra/ansible-provision.yaml (ch11l002)
---
- hosts: all 
 
  tasks:
    - name: Install docker
      ansible.builtin.apt:

        name: docker.io
        state: latest
      become: true 
 
    - name: Export container image locally  
      community.docker.docker_image:
        name: superlists
        archive_path: /tmp/superlists-img.tar
        source: local
      delegate_to: 127.0.0.1 
 
    - name: Upload image to server  
      ansible.builtin.copy:
        src: /tmp/superlists-img.tar
        dest: /tmp/superlists-img.tar 
 
    - name: Import container image on server  
      community.docker.docker_image:
        name: superlists
        load_path: /tmp/superlists-img.tar
        source: load
        state: present
      become: true 
 
    - name: Run container
      community.docker.docker_container:
        name: superlists
        image: superlists

        state: started
        recreate: true
We export the docker image to a .tar  ﬁle by using the
docker_image  module with the archive_path  set to temp
ﬁle, and setting the delegate_to  attribute to say we’re
running that command on our local machine rather than the
server.
We then use the copy  module to upload the tarﬁle to the
server
And we use docker_image  again but this time with
load_path  and source: load  to import the image back on
the server
$ ansible-playbook --user=elspeth -i staging.ottg
[...] 
 
PLAYBOOK: ansible-provision.yaml  
1 plays in infra/ansible-provision.yaml 
 
PLAY [all]  
 
TASK [Gathering Facts] * 
task path: ...goat-book/superlists/infra/ansible-
ok: [staging.ottg.co.uk] 
 
TASK [Install docker]  

task path: ...goat-book/superlists/infra/ansible-prov
ok: [staging.ottg.co.uk] => {"cache_update_time": 170
 
TASK [Export container image locally] * 
task path: ...goat-book/superlists/infra/ansible-prov
changed: [staging.ottg.co.uk -> 127.0.0.1] => {"actio
superlists:latest to /tmp/superlists-img.tar, overwri
11ff3b83873f0fea93f8ed01bb4bf8b3a02afa15637ce45d71eca
superlists:latest"], "changed": true, "image": {"Arch
[...] 
 
TASK [Upload image to server] * 
task path: ...goat-book/superlists/infra/ansible-
changed: [staging.ottg.co.uk] => {"changed": true
"313602fc0c056c9255eec52e38283522745b612c", "dest
[...] 
 
TASK [Import container image on server]  
task path: ...goat-book/superlists/infra/ansible-
changed: [staging.ottg.co.uk] => {"actions": ["Lo
from /tmp/superlists-img.tar"], "changed": true, 
"amd64", "Author": "", "Comment": "buildkit.docke
[...] 
 
TASK [Run container] * 
task path: ...goat-book/superlists/infra/ansible-prov
changed: [staging.ottg.co.uk] => {"changed": true, "c
{"AppArmorProfile": "docker-default", "Args": ["--bin
"superlists.wsgi:application"], "Config": {"AttachStd

For completeness, let’s also add a step to explicitly build the
image locally. This means we don’t have a dependency on
having run docker build  locally.
infra/ansible-provision.yaml (ch11l003)
    - name: Install docker
      [...] 
 
    - name: Build container image locally
      community.docker.docker_image:
        name: superlists
        source: build
        state: present
        build:
          path: ..
          platform: linux/amd64  
        force_source: true
      delegate_to: 127.0.0.1 
 
    - name: Export container image locally
      [...]
superlists.wsgi:application ], Config : { AttachStd
false, "AttachStdout": true, "Cmd": ["gunicorn", "--b
"superlists.wsgi:application"], "Domainname": "", "En
[...]

I needed this platform  attribute to work around an issue
with compatibility between Apple’s new ARM-based chips
and our server’s x86/amd64 architecture. You could also use
this platform:  to cross-build docker images for a Rasberry
Pi from a regular PC, or vice-versa. It does no harm in any
case.
Now let’s see if it works!
$ ssh elspeth@staging.superlists.ottg.co.uk 
Welcome to Ubuntu 22.04.4 LTS (GNU/Linux 5.15.0-67-ge
 [...] 
 
elspeth@server$ docker ps -a 
CONTAINER ID   IMAGE     COMMAND              CREATED
PORTS     NAMES 
3a2e600fbe77   busybox   "echo hello world"   2 days 
minutes ago             testcontainer 
129e36a42190   superlists   "/bin/sh -c 'gunicor…"   
 
elspeth@server:$ docker logs superlists 
[2024-02-26 22:19:15 +0000] [1] [INFO] Starting gunic
[2024-02-26 22:19:15 +0000] [1] [INFO] Listening at: 
[2024-02-26 22:19:15 +0000] [1] [INFO] Using worker: 
[...] 
  File "/src/superlists/settings.py", line 22, in <mo
    SECRET_KEY = os.environ["DJANGO_SECRET_KEY"] 
^^^^^^^

Whoops, we need to set those environment variables on the
server too.
NOTE
If you see an error saying “Error connecting: Error while fetching server API
version”, it may be because the Python Docker SDK can’t ﬁnd your docker daemon.
Try restarting Docker Desktop if you’re on Windows or a Mac. If you’re not using the
standard docker engine, with Colima for example, you may need to set the
DOCKER_HOST  environment variable or use a symlink to point to the right place. See
the Colima FAQ.
Using an env File to Store Our
Environment Variables
When we run our container manually locally, we can pass in
environment variables with the -e  ﬂag. But we don’t want to
                 
~
 
  File "<frozen os>", line 685, in getitem 
KeyError: 'DJANGO_SECRET_KEY' 
[2024-02-26 22:19:15 +0000] [7] [INFO] Worker exiting
[2024-02-26 22:19:15 +0000] [1] [ERROR] Worker (pid:7
[2024-02-26 22:19:15 +0000] [1] [ERROR] Shutting down
[2024-02-26 22:19:15 +0000] [1] [ERROR] Reason: Worke
~~~

hard-code secrets like SECRET_KEY into our Ansible ﬁles and
commit them to our repo!
Instead, we can use Ansible to automate the creation of a secret
key, and then save it to a ﬁle on the server, where it ill be
_relatively secure (better than saving it to version control and
pushing it to GitHub in any case!)
We can use a so-called “env ﬁle” to store environment
variables. Env ﬁles are essentially a list of key-value pairs using
shell syntax, a bit like you’d use with export .
One extra subtlety is that we want to vary the actual contents of
the env ﬁle, depending on where we’re deploying to. Each
server should get its own unique secret key, and we want
diﬀerent conﬁg for staging and prod, for example.
So, just as we inject variables into our html templates in Django,
we can use a templating language called “jinja2” to have
variables in our env ﬁle. It’s a common tool in Ansible scripts,
and the syntax is very similar to Django’s.
Here’s what our template for the env ﬁle will look like:
infra/env.j2 (ch11l004)

DJANGO_DEBUG_FALSE=1
DJANGO_SECRET_KEY={{ secret_key }}
DJANGO_ALLOWED_HOSTS={{ host }}
And here’s how we use it in the provisioning script:
infra/ansible-provision.yaml (ch11l005)
    - name: Import container image on server
      [...] 
 
    - name: Ensure .env file exists
      ansible.builtin.template:  
        src: env.j2
        dest: ~/superlists.env
        force: false  # do not recreate file if it al
      vars:  
        host: "{{ inventory_hostname }}"  
        secret_key: "{{ lookup('password', '/dev/null
 
    - name: Run container
      community.docker.docker_container:
        name: superlists
        image: superlists
        state: started
        recreate: true
        env_file: ~/superlists.env  

We use ansible.builtin.template  to specify the local
template ﬁle to use ( src ), and the destination ( dest ) on the
server
force: false  means we will only write the ﬁle once. So
after the ﬁrst time we generate our secret key, it won’t
change.
The vars  section deﬁnes the variables we’ll inject into our
template.
We actually use a built-in Ansible variable called
inventory_hostname . This variable would actually be
available in the template already, but I’m renaming it for
clarity.
This lookup('password')  thing I copy-pasted from
StackOverﬂow. Come on there’s no shame in that.
Here’s where Ansible tells Docker to use our env ﬁle when it
runs our container.
NOTE
Using an env ﬁle to store secrets is deﬁnitely better than committing it to version
control, but it’s maybe not the state of the art either. You’ll probably come across
more advanced alternatives from various cloud providers, or Hashicorp’s Vault tool.

IDEMPOTENCE AND DECLARATIVE CONFIGURATION
Infrastructure-as-code tools like Ansible aim to be “declarative”,
meaning that, as much as possible, you specify the desired state
that you want, rather than specifying a series of steps to get
there.
This concept goes along with the idea of “idempotence”, which
is is when you want a thing that has the same eﬀect, whether it
is run just once, or multiple times.
An example is the apt  module that we used to install docker. It
doesn’t crash if docker is already installed, and in fact, Ansible is
smart enough to check ﬁrst before trying to install anything.
There is some subtlety here, for example, our templated env ﬁle
will only be written once, so the step is idempotent in the sense
that it doesn’t overwrite the ﬁle with a new random secret key
every time you run it. But that does come with the downside
that you can’t easily add new variables to the ﬁle.
Probably a more sophisticated solution involving separate ﬁles
for the secret and other parts of the conﬁg would be better, but I
wanted to keep this (already long) chapter as simple as possible.

Let’s run the latest version of our playbook and see how our
tests get on:
$ ansible-playbook --user=elspeth -i staging.ottg
[...] 
PLAYBOOK: ansible-provision.yaml  
1 plays in infra/ansible-provision.yaml 
 
PLAY [all]  
 
TASK [Gathering Facts] * 
ok: [staging.ottg.co.uk] 
 
TASK [Install docker]  
ok: [staging.ottg.co.uk] => {"cache_update_time": 170
false, "changed": false} 
 
TASK [Build container image locally]  
changed: [staging.ottg.co.uk -> 127.0.0.1] => {"a
 
TASK [Export container image locally] * 
changed: [staging.ottg.co.uk -> 127.0.0.1] => {"a
 
TASK [Upload image to server]  
changed: [staging.ottg.co.uk] => {"changed": true
 
TASK [Import container image on server]  

Looks good! What do our tests think?
More debugging
We run our tests as usual and run into a new problem:
That neterror  makes me think it’s another networking
problem.
changed: [staging.ottg.co.uk] => {"actions": ["Lo
 
TASK [Ensure .env file exists]  
changed: [staging.ottg.co.uk] => {"changed": true, [.
 
TASK [Run container]  
changed: [staging.ottg.co.uk] => {"changed": true
 
PLAY RECAP  
staging.ottg.co.uk         : ok=8    changed=6    unr
skipped=0    rescued=0    ignored=0
$ TEST_SERVER=staging.ottg.co.uk python src/manag
[...] 
selenium.common.exceptions.WebDriverException: Messag
about:neterror?e=connectionFailure&u=http%3A//staging

NOTE
If your domain provider puts up a temporary holding page, you may get a 404 rather
than a connection error at this point, and the traceback might have
NoSuchElementException instead.
Let’s try our standard debugging technique, of using curl  both
locally and then from inside the container on the server. First,
on our own machine:
NOTE
Similarly, depending on your domain/hosting provider, you may see “Host not
found” here instead.
Now let’s ssh in to our server and take a look at the docker logs:
$ curl -iv staging.ottg.co.uk 
[...] 
curl: (7) Failed to connect to staging.ottg.co.uk por
connect to server
elspeth@server$ docker logs superlists 
[2024-02-28 22:14:43 +0000] [7] [INFO] Starting gunic
[2024-02-28 22:14:43 +0000] [7] [INFO] Listening at: 
[2024-02-28 22:14:43 +0000] [7] [INFO] Using worker: 

No errors there. Let’s try our curl :
Hmm, curl  fails on the server too. But all this talk of port 80 ,
both locally and on the server, might be giving us a clue. Let’s
check docker ps :
[2024-02-28 22:14:43 +0000] [8] [INFO] Booting worker
elspeth@server$ curl -iv localhost 
*   Trying 127.0.0.1:80... 
* connect to 127.0.0.1 port 80 failed: Connection ref
*   Trying ::1:80... 
* connect to ::1 port 80 failed: Connection refused 
* Failed to connect to localhost port 80 after 0 ms: 
* Closing connection 0 
curl: (7) Failed to connect to localhost port 80 afte
$ docker ps 
CONTAINER ID   IMAGE        COMMAND                  
PORTS     NAMES 
1dd87cbfa874   superlists   "/bin/sh -c 'gunicor…"   
minutes             superlists

This might be ringing a bell now— we forgot the ports.
We want to map port 8888 inside the container as port 80 (the
default web/http port) on the server:
infra/ansible-provision.yaml (ch11l006)
    - name: Run container
      community.docker.docker_container:
        name: superlists
        image: superlists
        state: started
        recreate: true
        env_file: ~/superlists.env
        ports: 80:8888
That gets us to:
Mounting the database on the
server and running migrations
selenium.common.exceptions.NoSuchElementException: Me
element: [id="id_list_table"]; [...]

Taking a look at the logs from the server, we can see that the
database is not initialised:
Here’s how
$ ssh elspeth@server docker logs superlists 
[...] 
django.db.utils.OperationalError: no such table: list
$ ansible-playbook --user=elspeth -i staging.ottg
[...] 
TASK [Run migration inside container] * 
changed: [staging.ottg.co.uk] => {"changed": true, "r
"stderr_lines": [], "stdout": "Operations to perform:
auth, contenttypes, lists, sessions\nRunning migratio
contenttypes.0001_initial... OK\n  Applying 
contenttypes.0002_remove_content_type_name... OK\n  A
auth.0001_initial... OK\n  Applying 
auth.0002_alter_permission_name_max_length... OK\n  A
[...] 
PLAY RECAP ** 
staging.ottg.co.uk         : ok=9    changed=2    unr
skipped=0    rescued=0    ignored=0

infra/ansible-provision.yaml (ch11l007)
We use file  with state=touch  to make sure a placeholder
ﬁle exists before we try and mount it in
    - name: Ensure db.sqlite3 file exists outside con
      ansible.builtin.file:
        path: /home/elspeth/db.sqlite3
        state: touch  
    - name: Run migration inside container
      community.docker.docker_container_exec:  
        container: superlists
        command: ./manage.py migrate
    - name: Run container
      community.docker.docker_container:
        name: superlists
        image: superlists
        state: started
        recreate: true
        env_file: ~/superlists.env
        mounts:  
          - type: bind
            source: /home/elspeth/db.sqlite3
            target: /src/db.sqlite3
        ports: 80:8888

And we use the API for docker exec  to run the migration
command inside the container.
Here is the mounts  conﬁg, which works a lot like the --
mount  ﬂag to docker run .
It workssss
Hooray
$ TEST_SERVER=staging.ottg.co.uk python src/manag
Found 3 test(s). 
[...] 
 
... 
 ----------------------------------------------------
Ran 3 tests in 13.537s 
OK

MORE DEBUGGING TIPS AND COMMANDS
A few more places to look and things to try, now that we’ve
introduced Docker into the mix, should things not go according
to plan— all of these should be run on the server, inside an SSH
session:
You can check the Container logs using docker logs
superlists .
You can get detailed info on the Container using docker
inspect superlists . This is a good place to go check on
environment variables, port mappings, and exactly which
image was running, for example.
You can inspect the image with docker image inspect
superlists . You might need this to check the exact image
hash, to make sure it’s the same one you built locally.
You now have a live website! Tell all your friends! Tell your
mum, if no one else is interested! And, in the next chapter, it’s
back to coding again.
Further Reading

There’s no such thing as the One True Way in deployment; I’ve
tried to set you oﬀ on a reasonably sane path, but there are
plenty of things you could do diﬀerently, and lots, lots more to
learn besides. Here are some resources I used for inspiration:
The 12-factor App by the Heroku team
Solid Python Deployments for Everybody by Hynek
Schlawack
The deployment chapter of Two Scoops of Django by Dan
Greenfeld and Audrey Roy

AUTOMATED DEPLOYMENT RECAP
Here’s a brief recap of what we’ve been through, which are a
fairly typical set of steps for deployment in general
1. Provisioning a server. This tends to be vendor-speciﬁc, so we
didn’t automate it, but you absolutely can!
2. Installing system dependencies - in our case, it was mainly
Docker, but inside the Docker image, we also had some
system dependencies too, like Python itself.
3. Getting our application code (or “artifacts”) onto the server.
In our case, since we’re using Docker, the thing we needed to
transfer was a Docker image. We used a manual process, but
typically you’d push and pull to an image repository.
4. Setting environment variables and secrets. Depending on
how you need to vary them, you can set environment
variables on your local PC, in a Dockerﬁle, in your Ansible
scripts, or on the server itself. Figuring out which to use in
which case is a big part of deployment.
5. Attaching to the Database. In our case we mount a ﬁle from
the local ﬁlesystem. More typically, you’d be supplying some
environment variables and secrets to deﬁne a host, port,
username and password to use for accessing a database
server.

6. Conﬁguring networking and port mapping. This includes
DNS conﬁg, as well as Docker conﬁguration. Web apps need
to be able to talk to the outside world!
7. Running Database migrations. We’ll revisit this later in the
book, but migrations are one of the most risky part of a
deployment, and automating them is a key part of reducing
that risk.
8. Switching across to the new version of our application. In
our case, we stop the old container and start a new one. In
more advanced setups, you might be trying to achieve zero-
downtime deploys, and looking into techniques like red-
green deployments.
Every single aspect of deployment can and probably should be
automated. Here are a couple of general principles to think
about when implementing infrastructure-as-code:
Idempotence
If your deployment script is deploying to existing servers, you
need to design them so that they work against a fresh
installation and against a server that’s already conﬁgured.
Declarative
As much as possible, we want to try and specify what we
want the state to be on the server, rather than how we should

get there. This goes hand-in-hand with the idea of
idempotence above.
 What I’m calling a “staging” server, some people would call
a “development” server, and some others would also like to
distinguish “preproduction” servers. Whatever we call it, the
point is to have somewhere we can try our code out in an
environment that’s as similar as possible to the real production
server.
 The “love” part is that yaml is very easy to read and scan
through at a glance. The “hate” part is that the actual syntax is
surprisingly ﬁddly to get right: the diﬀerence between lists and
key/value maps is subtle and I can never quite remember it
honestly.
 In the oﬃcial docker installation instructions, you’ll see a
recommendation to install docker via a private package
repository. I wanted to avoid that complexity for the book, but
you should probably follow those instructions in a real-world
scenario.
1
2
3

About the Author
After an idyllic childhood spent playing with BASIC on French 8-
bit computers like the Thomson T-07 whose keys go “boop”
when you press them, Harry spent a few years being deeply
unhappy with economics and management consultancy. Soon
he rediscovered his true geek nature, and was lucky enough to
fall in with a bunch of XP fanatics, working on the pioneering
but sadly defunct Resolver One spreadsheet. He now works at
PythonAnywhere LLP, and spreads the gospel of TDD worldwide
at talks, workshops, and conferences, with all the passion and
enthusiasm of a recent convert.

