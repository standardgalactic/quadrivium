
INTRODUCTION
Want to learn how to program? Want to learn Rust? Have no idea what those
questions mean, but you’re still interested? Awesome! You’re in the right
place.
Begin Rust is targeted at getting people of all experience levels up and
running with programming with the Rust programming language. Don’t
know what programming, a language, or Rust are? That’s fine, we’ll be
addressing all of those questions. Age wise, we’re targeting this book to be
applicable to young teenagers (13 years old) and up. It should be fine for
adults too.

Instructions
This book is going to be interactive. If you want to learn Rust, you need to
follow along with the exercises. Just reading this will not be enough.
To make it easy to get started, you can use the online Rust Playground for
running the examples. There are other ways to do things, but we want to
focus on the important stuff. You should probably open that link and
bookmark it, you’ll be using it a lot. You’ll also probably want to put this
book in a window next to the playground so you can read and code at the
same time.
When I tell you to work on some code, you should avoid copy-pasting.
Instead, type it in by hand. Is that slower? Yes. But it will train you to get
comfortable with Rust. Especially for new programmers, you’ll want to get
used to all the weird characters we use, like { and ;. That way, when we get
to the more complicated stuff in this book, you won’t be thinking about
typing, you’ll be thinking about the hard stuff.
Finally, you should explore. If you have an idea, and you’re curious if it will
work: try it and see what happens! You can’t break anything. The worst that
will happen is you’ll get a confusing message.

Exercise solutions
We don’t provide exercise solutions in the book. This is very much an
intentional decision: providing solutions here makes it too easy to keep
"cheating" and looking ahead, without trying to solve it yourself. But we also
know that there will be times when you need some help.
We’ve created an online forum at https://chat.beginrust.com/ where you can
discuss the book content with other learners, and the authors too. If you’re
stuck, we recommend reaching out over there, or checking if someone has
already asked the question.

▪
▪
Existing programmers
Initially, the concept of this book was to target new programmers explicitly.
While writing, we made sure to explain concepts from the ground up, not
assuming prior programming knowledge. We’ve also avoided making
comparisons to other programming languages while writing. However, to our
surprise, we found that a lot of existing programmers were interested in a
book teaching Rust in this style, and so we’ve added this little section to help
such programmers out.
There will be some parts of this book that will be pretty easy for an existing
programmer. Boolean logic, for example, is probably something you don’t
need much of a refresher on. Feel free to skim through those sections, we
won’t hold it against you. You may still find it useful to do all of the
exercises, though, just to get more comfortable with the syntax.
There are a few parts of Rust covered in this book that will be especially
unusual compared to other programming languages. Here’s what we’ve
found needs quite a bit of focus from experienced programmers:
The concept of blocks, semicolons, and everything-is-an-expression is
pretty different in Rust. These concepts almost make Rust feel like a
functional programming language… but not quite. Rust really sits in its
own world here, and it’s worth preparing yourself for that mental shift.
Going along with this: you’ll end up returning values from functions
without using the return keyword. A lot. For Rubyists and Haskellers,
this may be natural. For C++ or Java developers, it will likely feel foreign.

▪Immutable-by-default can be a big curve ball. If you’re used to languages
with all variables being mutable, you may find it surprising just how much
you can get done without mutability.
There are probably others as well. To reiterate though: to keep the flow of the
book easy for those without programming experience, we will not be calling
out these points in the text of the book itself.

1. HELLO WORLD AND
VARIABLES
It’s customary when you learn a new programming language to start with
what we call "Hello World." It’s a simple program that prints the message
"Hello World". Not only is it fun to write your first program, but it makes
sure you know how to run programs.
Remember what I said in the introduction: you can use the Rust Playground
for doing this. Go to that page, and then delete whatever is there right now so
you get a clean slate. Then type in the following code:
fn main() {
    println!("Hello, world!");
}
Then, in the top left of the screen, click on the "Run" button. If everything
goes correctly, you’ll see a message at the bottom of your screen that says
"Hello, world!" If so, congratulations, you’ve written your first program! If
not, you should fix this before moving on.
㇀
Even when you write a successful program, you’ll see something in your output that says
"Standard error." This is normal, and can be ignored. It’s just the way that Rust

Playground displays things.
Here’s a screenshot of what it looks like on my computer after successfully
running the program:

Don’t be confused by the "standard error" at the bottom, it’s just the way the
Rust playground outputs some extra information that we don’t need right
now.

1.1. What did that mean?
There are a number of things to learn here. We’ll be going into a lot more
depth on all of this throughout the tutorial. But to make it easier to talk about,
we’ll start with some basic terms. If some of this seems confusing, don’t
worry too much. We’ll be working with these things much more through the
tutorial, and it will start to make even more sense.
fn
The fn is short for "function." In Rust (and most other programming
languages), a function means "tell me some information, and I’ll do some
things and give you an answer."
main
The main function is a special function: it’s where your program starts.
()
These parentheses are the parameter list for this function. It’s empty right
now, meaning there are no parameters. Don’t worry about this yet. We’ll
see plenty of functions later that do have parameters.
{ }
These are called curly braces or brackets. Now that we’ve said "hey,
we’re going to make the main function," we actually need to give it a
body. The body lives inside these braces. The body will say what the
main function actually does.
println!

This is a macro. It means "print and add a new line." Macros are very
similar to functions. And for now, you can think of println as a
function. The difference is that it ends with an exclamation point (!).
("Hello, world!")
This is the parameter list for the macro call. You see, we’re saying "call
this macro called println with these parameters." Yes, this is just like
how the main function has a parameter list. Except the println macro
actually has a parameter. We’ll see more about it later.
"Hello, world!"
This is a string. Strings are a bunch of letters (or characters) put together.
We put them inside the double quotes (") to mark them as strings. Then
we can pass them around for macros like println!, and lots of other
functions we’ll play with later.
;
This is a semicolon. It completes what’s called a statement. Statements do
something specific. In this case, it’s calling the macro. There are other
kinds of statements as well, which we’ll start to see soon.
Again, don’t worry too much about all these terms and what they mean. The
best way to learn how to program is to actually program!

1.2. Interpolation
That’s a big word! But it’s not hard to show what interpolation means. Our
first program printed out a simple message, "Hello, world!" But what if we
want to build up a more complicated message? You can interpolate other
values into the output. Let’s demonstrate:
fn main() {
    println!("My name is {}", "Michael");
}
We’re now passing two parameters to the println macro: the first string is
"My name is {}". The println macro has special support for the {}
braces. It means: hey, you see that next parameter? Stick it in here. This
program is going to print "My name is Michael". And we separate the
parameters by putting a comma.

EXERCISE
Modify this program so that it says your name and age. For example, "My name is Michael and
I am 34 years old." Try both with and without the double quotes around the age and see what
works. Hint: you’ll end up with 3 parameters to println!, separated by 2 commas.

1.3. Variables
Often, we don’t want to put all of the values we care about on one line like
that. It can be more pleasant to define variables: convenient names that refer
to the values we care about. We do that with let:
fn main() {
    let name = "Michael";
    println!("My name is {}", name);
}
Now, name is pointing at the string "Michael", and we can refer to that
when we call println!. Variables are a core part of programming, and
we’re not going to be able to explain all of their uses here. But get ready to
see a lot of them!
So far, we’ve just played with strings. But computers are really good at math,
and they can play with numbers too. Let’s see this in action.
㇀
You haven’t forgotten that you’re supposed to be typing all of these code snippets into the
Rust Playground and running them, have you?
fn main() {
    let apples = 10;
    println!("I have {} apples", apples);
}

Notice how I didn’t put the double quotes around the number 10? You can go
ahead and do that, and the program will have the same output. But they mean
different things. Right now, apples is a number. But with the double
quotes, it’s a string. If all we’re going to do is output them, the difference
isn’t that important. But let’s actually do some math.
fn main() {
    let apples = 10 + 5;
    println!("I have {} apples", apples);
}
As you’d probably guess, this is going to print out "I have 15 apples".
However, if you instead wrapped it all with double quotes:
fn main() {
    let apples = "10 + 5";
    println!("I have {} apples", apples);
}
Now it says "I have 10 + 5 apples." And you can get even worse with code
like this, which isn’t going to work at all:
fn main() {
    let apples = "10" + "5";
    println!("I have {} apples", apples);
}
Go ahead and put that in the Rust Playground and run it. You’ll get an error
message that looks something like this:
error[E0369]: binary operation `+` cannot be applied to type 
`&str`
 --> src/main.rs:2:23

  |
2 |     let apples = "10" + "5";
  |                  ---- ^ --- &str
  |                  |    |
  |                  |    `+` cannot be used to concatenate two 
`&str` strings
  |                  &str
This looks big and scary. Eventually we’ll understand what this all means.
For now, you need to know that when you press run, something called the
compiler is checking to make sure your program makes sense. And if it
doesn’t, it will give you an error message.

1.4. More math!
Let’s use Rust to do a bit of arithmetic. The basic operations are:
+
addition
-
subtraction
*
multiplication
/
division

EXERCISE
Try to guess what the answer will be before running this program:
fn main() {
    let answer = 6 / 2 + 4 * 3;
    println!("The answer is: {}", answer);
}
If you guessed 21: sorry, you’re out of luck. The answer is 15, because of
the order of operations. Rust follows standard arithmetic rules, so it does 6 /
2 = 3, then 4 * 3 = 12, then 3 + 12 = 15.
But what if I want to force it to do 6 / 2 = 3, then 3 + 4 = 7, then 7
* 3 = 21? You need to use parentheses to do that.

EXERCISE
Add a left parenthesis ( and a right parenthesis ) to the program above so that the answer it
prints is 21.

1.5. Multiple variables
We’re not limited to just one variable. It’s fine to define as many as we’d
like:
fn main() {
    let x = 5;
    let y = 10;
    let name = "Michael";
    println!("My name is {}, and the answer is {}", name, x + y);
}
We can also use this technique to break up larger computations into smaller
pieces:
fn main() {
    let x = 5 + 3;
    let y = 2 - 1;
    let z = x * y;
    println!("The answer is {}", z);
}

EXERCISE
Use multiple variables, and no parentheses, to compute (6 / 2 + 4) * 3.
You’re also allowed to reuse variable names. This mostly works the way you
would expect. Try to guess the output of this program:
fn main() {
    let x = 5 + 3;
    let x = x * 2;
    let x = x - 6;
    let x = x / 2;
    println!("The answer is {}", x);
}
Each time we reuse a variable name, we are creating a brand new variable,
not modifying the previous one. We call this shadowing: the new variable
with the same name shadows the old variable, so you can’t access the old one
anymore.

1.6. Types
We’ve spoken about numbers and strings. In Rust, every value has some type
which tells you what kind of thing it is. When you have a string literal
(something between double quotes) like "Hello, world!", its type is
&str.
When you use let to declare a variable, you can give its type as well, like
this:
fn main() {
    let name: &str = "Michael";
    println!("My name is {}", name);
}
Rust has something called type inference, which means that in many cases,
you can skip putting in the type, and the compiler will figure it out for you.
Sometimes though, we like to write the type out. It can make it easier to read
code sometimes, and can help the compiler catch our mistakes better. But
usually with simple things, we just skip it.
There’s a little bit more to numbers to talk about. The first thing is about
integers versus floating point. Integers are whole numbers, like 5, -2, 0, etc.
They are numbers that don’t have a decimal point or a fractional part.
Floating point numbers can have decimal points. For now, we’re just going to
talk about integers.
Within integers, there are signed and unsigned. Signed integers can have a
negative sign, and can be positive or negative. Unsigned, as you might guess,

cannot have a negative sign, and must be 0 or greater.
And finally, there’s the size of an integer, measured in terms of bits. A bit is
either a 0 or 1, and makes up the basis of computers. If you have an 8-bit
unsigned integer, you can have the numbers 0 through 255. An 8-bit signed
integer, on the other hand, can have the numbers -128 to 127. If you look
closely, it’s the same total count (256 possibilities), but one includes
negatives, the other doesn’t.
In Rust, the way we talk about the types of these integers is i8 (for signed 8-
bit integer), u32 (for unsigned 32-bit integer), etc. You can use 8, 16, 32, and
64. There’s also some support for 128, but you’ll almost never need it.
There’s also a special isize and usize, which means "use whatever size
the computer I’m on likes." These days, that’s usually 64.
Alright, that’s lots of funny business. Let’s get back to some actual code! For
now, we’re going to pretend like all the numbers we work with are i32. Why
that? It’s pretty commonly used. Eventually, we’ll deal with converting
between different types of numbers and things like that. But we’ll keep it
simple for now.

EXERCISE
Fix the program below by changing the type.
fn main() {
    let name: &str = "Michael";
    let age: &str = 34;
    println!("My name is {} and I am {} years old", name, 
age);
}

▪
▪
▪
▪
▪
▪
1.7. Summary
Every Rust program starts at the main function
Inside the main function, you can do things like call println
The println macro lets us do interpolation to produce output
We can define variables that hold onto values using let
We can perform basic arithmetic using +, -, *, and /
Each value has a type, which says what kinds of things it can hold
1. A &str is the type of a string literal, like "Michael"
2. There are lots of different number types, but we’ll mostly use i32

1.8. Exercises
1. Write a program from scratch that prints "Hello World." Try to avoid
looking at the examples in this lesson. This will help you nail down all
the different symbols and words you need to write normal Rust code.
2. Modify the program below by changing the FIXMEs into the correct
types to make this compile.
fn main() {
    let x: FIXME = -5;
    let y: FIXME = 7;
    let name: FIXME = "Michael";
    println!("My name is {}, and the answer is {}", name, x * 
y);
}
3. Write a program that prints the result of doing 5 + 3, then 6 - 2, then
multiplying the two results together.
a. Do it once using multiple variables.
b. Do it once using a single variable.
c. Do it once using no variables at all.
4. Write a program that generates this output:
Hello, world!
I have 10 apples.
Goodbye!

▪
▪
▪
2. ANATOMY OF RUST
We’re going to learn about a lot of different things in Rust: functions, strings,
and numbers are just some examples we’ve seen so far. As you program in
Rust, you’re going to need to assemble these together into something that the
language allows.
The purpose of this lesson is to give you an overall look at how Rust
programs are correctly put together. We want to:
Cover the names of different things so we can refer to them
Give an idea of how all these things fit together
Start explaining rules of the right way to type them into the computer

▪
▪
▪
2.1. Pairing and nesting
A lot of Rust involves lots of special symbols. Let’s look at our "Hello,
world!" program again:
fn main() {
    println!("Hello, world!");
}
We have the left parenthesis (, right parenthesis ), left curly brace {, right
curly brace }, semicolon ;, and double quotes ". Ignore the semicolon for
now, we’ll discuss it a bit later. The others all come in pairs in our program:
Every left parenthesis has a matching right
Every left curly brace has a matching right
There’s no "left double quote" and "right double quote," but there are two
double quotes which form a pair
This is pretty common in Rust. We use these special symbols to group stuff
together. For example, the curly braces group together the body of the
function. The second set of parentheses group the parameter list passed to the
println! macro. And the double quotes group together the string
parameter.
The other important part of all of this is that these pairs nest. In other words,
you can put one pair of symbols inside another. And notice in the program
above, we always close off the inner pair before closing the outer pair. In
other words, the code above is correct, but this code is incorrect:

fn main() {
    println!("Hello, world!"});
By moving the right curly brace before the right parenthesis, we’ve messed
up the nesting, and our code is no longer valid. In order to write correct code,
make sure that you close off each pair of symbols in the correct order.

EXERCISE
Fix this program by adding the closing symbols for each pair in the right order.
fn main() {
    {
        {
            println!("Hello nesting!

2.2. Layout
Look at this piece of code:
fn main() {
    println!("Hello, world!");
    {
        let name = "Michael";
        println!("Nice to meet you, {}!", name);
    }
    println!("Have a great day");
}
Now compare it to this one:
fn main(){println!("Hello, world!"
)
;{
 let name = "Michael"; println!(
"Nice to meet you, {}!", name
);
               } println!("Have a great day")
; }
These programs both do exactly the same thing, but the first is significantly
easier to read, and frankly prettier. That’s because it’s following Rust’s
recommended rules of layout and indentation. The computer doesn’t care
about these rules at all. They’re entirely to make the code easier to work with
for you, the dear programmer.

There are lots of different recommended rules for layout, like: within a pair of
curly braces, indent each line by four extra spaces at the beginning of the
line. This makes it easier for a programmer to see how things are grouped
together in those pairs of symbols. Another common thing is putting spaces
around operators. For example, instead of let x=2+3, we’ll normally write
let x = 2 + 3.
Again, the computer doesn’t care: it just looks at the symbols to figure it out.
But our fragile human brains tend to like things spaced out visually.
Fortunately, the computer isn’t indifferent to our suffering. In the Rust
Playground, under the "tools" button at the top, there’s an option called
"Rustfmt." This runs the rustfmt tool, which automatically applies Rust
layout rules to your code to make it easier to read. The fmt is short for
"format."
You should get in the habit of trying to follow layout rules, like indentation,
and spacing between symbols, and so on. I won’t be spelling them out
explicitly all the time, but I will be demonstrating best practice. But you can
always double-check yourself by running Rustfmt on your code.

EXERCISE
Try to fix the bad version of the code above to look correct. First, do it manually, and then ask
Rustfmt to clean up any problems that are still there.

2.3. Comments
Going along with â€œthe computer doesn’t careâ€ is something called
comments. Comments are a way for you to add in some kind of message for
other programmers who are reading it. Sometimes those other programmers
are just you in six months, when you’ve forgotten everything about the code.
So writing good comments can be helpful for both you and others.
There are two ways to write comments in Rust. The first is to use two
forward slashes //. Then, everything up until the end of the line is ignored
by the compiler. For example:
fn main() {
    // This line is entirely ignored
    println!("Hello, world!"); // This printed a message
    // All done, bye!
}
The other way is to use a pair of /* and */. The advantage of this kind of
comment is that it allows you to put comments in the middle of a line of
code, and makes it easy to write multi-line comments. The downside is that
for lots of common cases, you have to type in more characters than just //.
Let’s see it in action:
fn main(/* hey, I can do this! */) {
    /* This line is entirely ignored */
    println!("Hello, world!" /* sneaky comment */);
    /* All done, bye!
       I had a great time programming with you.
     */
}

Use whichever feels more comfortable in the situation.
Another thing we sometimes do is comment out code, where we turn a line of
code we don’t like into a comment. For example, in this program:
fn main() {
    println!("Hello, world!");
    println!("I want to comment this out");
}
I can comment out the second println! with:
fn main() {
    println!("Hello, world!");
    //println!("I want to comment this out");
}
I’ll use comments throughout the code snippets to give you extra information
and hints.

EXERCISE
Comment out the first and third println! calls below.
fn main() {
    println!("Hello, world!");
    println!("Still alive!");
    println!("I'm tired, good night!");
}

2.4. Expressions, values, and types
Let me give you a statement that will govern a lot of our time in Rust. Then
let’s explore what it means:
An expression is evaluated to a value of a specific
type
A lot of the work we do in programming is producing and using values.
Values can be something like the number 9, true, the words "Hello world",
and more. Your computer will end up storing these values somewhere in
memory, and then you’ll use them in things like calling functions or macros.
Each and every value you produce will have a type. Types help the computer
out a lot with things like knowing how much space to set up in memory to
hold a value. But they also help out the programmer a lot by making sure we
don’t do stupid things. For example, types help prevent us from trying to add
the number 5 and the string "banana" together.
The way we produce values in Rust is with expressions. There are many
different kinds of expressions, and we’ll be learning about them over the
course of our lessons. An expression is a recipe you, the programmer, give to
the computer for how to produce a value.
Let me give you some examples. The expression 3 + 4 says "computer,
please add the numbers 3 and 4 together to make a new value." The
expression apples * 2 says "get the value contained in the variable

named apples and multiply it by the number 2." And here’s another
interesting one: the expression 5 says "hey, give me the number 5." That’s
called a literal, which means that it’s an expression that doesn’t need to be
evaluated into a value. And finally, add(7, 8) is an expression that says
"call the function add on the values 7 and 8."
More complex expressions can be built up by combining simpler expressions.
For example, we can combine the ideas above with:
add(3 + 4, apples * 2)
Instead of using the literal number 7 as the first parameter to the add
function, we can provide our own expression, 3 + 4. Instead of the number
8, we can say apples * 2. And assuming the variable apples has the
number 4 in it, these two expressions mean exactly the same thing.
The process of turning an expression into a value is called evaluation. You
can think of the expression above as a tree:
      add
     /   \
  (+)     (*)
 /   \    / \
3     4  2  apples
Evaluation starts at the bottom of this tree and works its way up. The
expressions 3 and 4 are already values, so they don’t need to be evaluated
further. Then we move up the tree to the + operator and apply it to those
values. We end up with the new tree:

      add
     /   \
    7     (*)
          / \
         2  apples
Then we look at the expressions 2 and apples. 2 is already a value, but for
apples, we need to evaluate it by looking up the value in the variable.
Assuming it’s 4, we get the new tree:
      add
     /   \
    7     (*)
          / \
         2   4
Then we can apply the * operator to get:
      add
     /   \
    7     8
And finally we can call the add function on the parameters 7 and 8 to get 15,
and our evaluation is complete.
Rust is a language that puts a high emphasis on expressions. Get ready to see
a lot of them!

EXERCISE
Take a piece of paper and draw out an expression tree for the expression:
(3 + 4) * (1 + (5 - 2))
Then evaluate the tree yourself from the bottom up.

2.5. Variables, again
One common purpose for variables is to provide a convenient name to refer
to values. For example, take this program:
fn main() {
    println!(
        "In the year {}, you'll turn {} if you're born in {}",
        2020,
        2020 - 1985,
        1985,
    );
}
We’ve used the numbers 2020 and 1985 twice each, and we have an
expression 2020 - 1985 in the middle without a clear meaning. We can
use variables to help us out:
fn main() {
    let current_year = 2020;
    let birth_year = 1985;
    let age = current_year - birth_year;
    println!(
        "In the year {}, you'll turn {} if you're born in {}",
        current_year,
        age,
        birth_year,
    );
}
The two programs do the same thing, but the second is arguably much clearer
to understand. The reason this works is that each variable evaluates to the

value stored inside it. Naming these values with variables helps us keep track
of what the values mean, either years or age in this case.
Using variables is great practice in a lot of Rust code. For example, if you
want to see how old someone will be in 2030, you now only have to change
the year once, instead of needing to change it twice in the original version.
Same thing with changing the birth year.
That said, throughout our upcoming lessons, a lot of the exercises will
involve removing variables to make sure you stay comfortable with the idea
of sticking expressions inside other expressions.

EXERCISE
Get rid of all of the variables in this program:
fn main() {
    let x = 5 + 2;
    let y = 7 * 3;
    let z = y - x;
    println!("{}", z);
}

2.6. Effects versus results
What is the value of this expression?
println!("Hello, world!")
Most people would think that it’s the string "Hello, world!" But that’s not
actually the case. We need to talk about the difference between an effect and
a result.
An effect is something that is caused when you evaluate an expression. In our
example above, the macro call println! causes output to be printed to the
screen. You could have a program that talks to Amazon with a function call
order_pokeballs(12) which causes 12 Pokeballs to be sent to your
house. That would be the effect of evaluating that expression.
On the other hand, the expression 2 + 3 has no effect. Instead, it has a
result. With the expression 2 + 3, only your program itself knows when the
expression has been evaluated. However, it produces the value 5 which can
be used by the rest of the program. I can capture the result of 2 + 3 in a
variable with:
let x = 2 + 3;
Or I can use it directly in another expression, like a function call:
some_function(2 + 3)

It’s 
tempting 
to 
think 
that 
the 
expression println!("Hello,
world!") has no result at all. However, remember the rule I stated above:
An expression is evaluated to a value of a specific
type
Every expression must evaluate to a value. So the println! macro call
must produce a result. The thing is, it doesn’t have anything useful to
produce.
Rust has a special type for that case. It’s called unit, and perhaps confusingly,
it’s written in Rust as a pair of parentheses (). This is for both the type and
the value unit. Let’s see what this looks like in code:
fn main() {
    let x: () = ();
    let y: () = println!("Hello, world!");
    assert_eq!(x, y);
    println!("All units are the same!");
}
() is a unit literal, and can be placed on the right hand side of the equal sign,
which is how we define the x variable. We also give x an explicit type with :
(). See: () works for both the type and the value.
Next, we define y as the result of the println macro call. This immediately
evaluates the macro, produces the output, generates the unit result value, and
stores it in y. The next line is a new macro, assert_eq!, which checks to

▪
▪
make sure two values are the same. It’s really useful for testing that your
code does what you think it does. Here’s how it works:
If the two values you pass to assert_eq are the same, nothing happens.
If they’re different, your program exits with something called a panic.
To sum up: every expression produces a value. But if it doesn’t have
anything useful to produce, it produces unit ().

EXERCISE
Add in types for all of the variables in the next bit of code, and guess what the output of this
program will be before running it. I put an underscore (_) in front of some variable names
because they are not used, and I don’t want the compiler to warn you about them. Feel free to
remove those underscores if you like.
fn main() {
    let name = "Michael";
    let x = println!("My name is {}", name);
    let this_year = 2019;
    let birth_year = 1985;
    let age = this_year - birth_year;
    let y = println!("I turned {} in {}", age, this_year);
    assert_eq!(x, y);
    let _z = println!("Thanks for chatting with me!");
}

2.7. Blocks and statements
Let’s revisit our Hello World program and build up from there:
fn main() {
    println!("Hello, world!");
}
The curly braces part is called a block. And as you’ve already seen in other
examples above, you’re not limited to just one println! macro call. You
can have as many as you like:
fn main() {
    println!("Hello, world!");
    println!("Still alive!");
    println!("I'm tired, good night!");
}

EXERCISE
Comment out all three of the println! calls and see what happens.
Let’s look at another program:
fn main() {
    let x: i32 = 4 + 5;
    println!("4 + 5 == {}", x);
}
Just for kicks, I’m going to wrap the right hand side of let x = in curly
braces:
fn main() {
    let x: i32 = { 4 + 5 };
    println!("4 + 5 == {}", x);
}
What we’ve done here is created a new block, and put the expression 4 + 5
inside of it. Blocks themselves are expressions, and evaluating them
evaluates the expression inside. So x still ends up holding the value 9.
We can even make our block more complicated:
fn main() {
    let x: i32 = {
        println!("I'm inside a block");
        4 + 5
    };
    println!("4 + 5 == {}", x);
}

Now, when we evaluate that block, we first evaluate the println! macro
call, and then we evaluate 4 + 5. The semicolon is separating the two
expressions inside our block. We can even put in more expressions:
fn main() {
    let x: i32 = {
        println!("I'm inside a block");
        println!("Still inside");
        4 + 5
    };
    println!("4 + 5 == {}", x);
}
And we can even put in expressions that don’t have any effects:
fn main() {
    let x: i32 = {
        println!("I'm inside a block");
        6 + 7; // where did the 13 go?!?
        println!("Still inside");
        4 + 5
    };
    println!("4 + 5 == {}", x);
}
What happens to the value produced by evaluating these expressions? The
semicolon causes them to be thrown away. Let’s see this in practice with a
broken program:
fn main() {
    let x: i32 = {
        println!("I'm inside a block");
        4 + 5;
    };
    println!("4 + 5 == {}", x);

}
This generates the error message:
error[E0308]: mismatched types
 --> main.rs:2:18
  |
2 |       let x: i32 = {
  |  __________________^
3 | |         println!("I'm inside a block");
4 | |         4 + 5;
  | |              - help: consider removing this semicolon
5 | |     };
  | |_____^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
Now, the resulting i32 value 9 that was produced by evaluating 4 + 5 is
thrown away. Since there’s no other expression afterwards, the entire block
ends up producing the dummy "nothing interesting" value unit (). But we
told the computer that our x value will hold an i32 value, so it complains
that the types don’t match up.
Fortunately, the compiler is able to help us out here, and figured out that we
probably didn’t want that semicolon. And sure enough, removing it fixes the
problem.
Each of those expressions ending with a semicolon is known in Rust as a
statement. And a block is made up of 0 or more of these statements, followed
by 0 or 1 expressions. When you evaluate a block, it will evaluate all of the
statements in order. Then, if there is no expression at the end, it will produce

a unit value. If there is an expression at the end, it will evaluate that
expression and produce that value as the block’s result.
There are other kinds of statements than expressions with semicolons. One
kind that you’ve seen is a let statement, which creates a new variable. We’ll
see more kinds of statements as we continue with Rust.
Finally, you should pay attention to pairs and nesting within a statement.
Each statement should have properly paired symbols like braces, parentheses,
and double quotes, and these should nest correctly.

EXERCISE
What order do the output messages appear in this program? Can you explain why they occur in
that order?
fn main() {
    let apples: i32 = {
        println!("I'm about to figure out how many apples 
there are");
        let x = 10 + 5;
        println!("Now I know how many apples there are");
        x
    };
    println!("I have {} apples", apples);
}

▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
2.8. Summary
Rust uses a lot of special symbols like { and )
Many of these symbols come in pairs
These pairs of symbols need to nest inside each other
It’s good practice to follow layout rules to make your code easier to read
The rustfmt tool can help you get the layout right
You can use // or /* */ for adding comments to your code
An expression is evaluated to a value of a specific type
Most of our Rust code is writing expressions
You can draw out expressions as trees, and then evaluate from the bottom
up
Variables can be a convenient way to capture expression results and give
them useful names
Some expressions cause effects to happen
All expressions produce a result
But when an expression has nothing useful to produce, it produces (), aka
unit
The body of a function is a block
Blocks can contain multiple statements, and end with an optional
expression
The semicolon throws away the result of an expression

▪If you end your block with an expression without a semicolon, it will
produce that value, otherwise it produces unit

2.9. Exercises
1. Will the program compile? Why or why not? If not, try to fix it.
fn main() {
    let name = {
        "Michael"
    };
    println!("My name is {}", name);
}
2. Add the closing pair to all of the unclosed symbols:
fn main( {
    println!("4 + 5 == {}, {{ 4 + 5
3. Write a Hello World program, but include a comment before the main
function.
4. Correct the indentation and general format of the following program. Use
the rustfmt tool to check your work.
fn main() {
let pikachu
= "yellow"; let charmander =
"orange";
let
squirtle = "blue and green"
; println!
("Pikachu is {}, Charmander is {}, and Squirtle is {}.",
            pikachu,
                charmander,
                    squirtle)
    ;}

▪
▪
5. Look through the following program and answer these questions for
yourself. Then run the program and see if you were right.
What do the expressions evaluate to?
Will there be effects? If so, what?
fn main() {
    println!("Far over the Misty Mountains cold");
    "Dragon!!!";
    let dwarves: i32 = 13;
    let hobbit: i32 = {
        "Not a wizard";
        5 - 4
    };
    dwarves - 3;
    println!("The Company of Thorin has {} dwarves and {} 
hobbit, {} members in all.", dwarves, hobbit, dwarves + 
hobbit);
    println!("After the Battle of the Five Armies, there 
were only {} dwarves remaining.", dwarves - 3);
}

3. FUNCTIONS
So far, our programs have all had exactly one function in them, called main.
As we said, main is the entry point to our program. But main is also a
boring function: it doesn’t take any parameters, and it doesn’t produce any
result value (at least, not the way we’ve seen it so far).
In this lesson, we’re going to work on defining and calling new functions.

3.1. Hello World, again
We’re going to rewrite our Hello World program, but this time it will use a
basically useless helper function:
fn say_hello() {
    println!("Hello, world!");
}
fn main() {
    say_hello();
}
We define say_hello just like we define main, no surprises there. Then,
inside the body for main, we call the function by putting the name, followed
by parentheses, followed by a semicolon. It’s very similar to how we call the
println macro.

EXERCISE
Define another helper function say_goodbye, that says some kind of goodbye message. Then
print hello and goodbye 4 times each.
The exercise begins to show you one advantage of a function. If you’re going
to do things repeatedly, defining a helper function lets you skip rewriting the
same thing over and over. (Though in this case, we have even better
techniques we’ll learn about another time.)

3.2. Function parameters
Let’s bump up the power of our functions, and allow them to take parameters.
A parameter (also known as an argument) is a value passed into a function
from its caller. Parameters allow a function to do different things based on
how they are called.
fn say_apples(apples: i32) {
    println!("I have {} apples", apples);
}
fn main() {
    say_apples(10);
}
We finally have something inside the parentheses! Our function
say_apples takes a single parameter. We name that parameter apples,
and it’s now a variable we can use inside the say_apples function. When
we define a parameter to a function, we also need to give it a type. Here,
we’ve said that the type of apples is a signed 32-bit integer, or an i32.

EXERCISE
Modify the program above so that it produces this output:
I have 10 apples
I ate an apple!
I have 9 apples
I ate an apple!
I have 8 apples

3.3. Function results
So far, we’ve been pretending like all functions produce no result. But this
isn’t true. In fact, it’s the opposite: every function produces a result value. By
default, the result type of a function is the trusty old unit () we became so
familiar with in the last lesson.
How do we say what the result type of a function is? We use an "arrow":
fn main() -> () {
    println!("Hello, world!");
}
Adding the -> () to our main function’s definition doesn’t change
anything. The default result type is unit, and now we’ve explicitly said that
it’s unit.
But returning unit values is boring! Let’s write a function that doubles any
number you give it. This is going to take an i32 and give you back an i32.
We can talk about the function’s signature as what it looks like from the
outside:
fn double(x: i32) -> i32
Nice. The way we read this is "double is a function which takes one
parameter, an i32, and gives you back an i32 as the result."
But how do we produce a result from the function. Watch closely, and see if
you can see the trick:

▪
▪
▪
fn double(x: i32) -> i32 {
    x * 2
}
fn main() -> () {
    println!("3 * 2 == {}", double(3));
}
Do you see a missing symbol in the body of double? That’s right, there’s
no semicolon after x * 2. Let’s remember a few important things from the
last lesson:
A function body is a block
A block may optionally end with an expression
If a block ends with an expression, then evaluating the block results in the
value of that expression
And suddenly the world comes full circle. If you want your function to result
in a specific value, you provide an expression at the end with the value you
want.
And now let’s see what a nice friend the compiler is. Let’s say you got
confused, and you accidentally added that semicolon after x * 2. You’ll get
an error message including:
1 | fn double(x: i32) -> i32 {
  |    ------            ^^^ expected i32, found ()
  |    |
  |    implicitly returns `()` as its body has no tail or `return` 
expression
2 |     x * 2;
  |          - help: consider removing this semicolon

The last line I quoted is the useful one: the compiler knows you probably
don’t want the semicolon. It understands that you’re writing a function that
has a non-unit value, so of course you can’t end your function with a
statement!

EXERCISE
Modify the double function so that, before returning a result, it says "I’m going to double X"
(filling in the value provided).

3.4. Other parameters
We’re not limited to just accepting a single numeric parameter. Functions can
take multiple parameters, and they can take other types like strings. Just like
when we call functions or macros, we separate multiple parameters with
commas. And as a reminder, the type we have for string literals is &str.
Let’s see an example of this in practice:
fn eat(count: i32, food: &str) {
    println!("You ate {} helpings of {}", count, food);
}
fn main() {
    eat(5, "apples");
    eat(8, "bananas");
}
The eat function has a parameter list that takes two parameters. The first is a
variable called count of type i32. The second is a variable called food of
type &str. We separate the two parameters in the parameter list with a
comma. And when we call eat inside main, we separate the parameters we
pass in with a comma.

EXERCISE
Fix the following program to make it produce the output below. You should not modify the
main function at all. Instead, you’ll want to add a parameter list to greet, and then use those
variables inside the function body.
fn greet() {
    println!("This isn't going to work yet");
}
fn main() {
    greet("Alice", 10);
    greet("Bob", 8);
    greet("Charlie", 6);
}
Hello Alice, you can have 10 apples.
Hello Bob, you can have 8 apples.
Hello Charlie, you can have 6 apples.

3.5. Variable and parameter scope
Let’s look at one of our examples from earlier:
fn say_apples(apples: i32) {
    println!("I have {} apples", apples);
}
fn main() {
    say_apples(10);
}
We have apples in the parameter list for say_apples. This means that
we’re allowed to use the name apples inside the body of the say_apples
function. However, we can’t use it inside the body of the main function.
This program will not compile:
fn say_apples(apples: i32) {
    println!("I have {} apples", apples);
}
fn main() {
    say_apples(10);
    println!("apples == {}", apples);
}
Variable names are only visible inside a certain scope. When you have the
function say_apples with apples in the parameter list, we end up with a
variable named apples which is scoped to the body of the say_apples
function. Each block in Rust creates its own scope for variable names. That
block automatically gets everything from the parent scope. Let’s see how that
works:

fn say_apples(apples: i32) {
    println!("I can use apples here: {}", apples);
    {
        let bananas = 20;
        println!("I can use apples here too: {}", apples);
        println!("And I can use bananas: {}", bananas);
    }
    println!("But I can't use bananas here {}", bananas);
}
fn main() {
    say_apples(10);
    println!("I can't use either here {} {}", apples, bananas);
}
Notice that inside the inner block in say_apples, we can use the apples
variable from the parent block. We can also define a new bananas variable.
But we can’t use that bananas variable outside of that block.

EXERCISE
Fix that program by commenting out the lines that don’t compile.
Here’s another thing about scope: you can shadow variable names.
Shadowing hides an old variable with a new one with the same name. For
example, try to guess the output of this program:
fn main() {
    let apples = 10;
    println!("apples == {}", apples);
    let apples = 20;
    println!("apples == {}", apples);
}
There’s one interesting impact of how blocks and shadowing work together.
You can shadow a variable in one scope, but it may remain unshadowed in
another scope. That’s abstract, so let’s see some code:
fn main() {
    let apples = 10; // apples is 10
    println!("apples == {}", apples);
    {
        let apples = 20; // shadow apples in this scope
        println!("apples == {}", apples);
    }
    // That block's scope is done
    // Now our original apples is back in scope
    // What do you think this will output?
    println!("apples == {}", apples);
}
This program will output:

▪
▪
▪
▪
▪
▪
▪
apples == 10
apples == 20
apples == 10
This is because we:
Create a new variable apples with the value 10
Print out its value
Create a new scope inside a new block
Create a new variable apples which shadows the first apples, with the
value 20
Print out the new value
Exit the block, exiting that scope and losing the new apples value
Now, back in the first scope, we can only see the original apples value,
and print that

EXERCISE
What will this output?
fn main() {
    let apples = 10;
    println!("Before the block, I have {} apples", apples);
    {
        let apples = apples + 5;
        println!("Inside the block, I have {} apples", 
apples);
    }
    println!("After the block, I have {} apples", apples);
}

3.6. Anatomy of a function
Alright, time to review what we know about functions and how they’re put
together. From what we’ve seen, functions consist of:
1. The keyword fn to say "hey, get ready for a function!"
2. The name of the function
3. An opening parenthesis ( to begin the parameter list
4. 0 or more parameters, separated by commas. Each parameter consists of:
a. A variable name to capture the parameter
b. A colon :
c. A type name
5. A closing parenthesis ) to end the parameter list
6. An optional result (or return) type for the function, given by the arrow -
> followed by a type.
a. If you do not include a return type, the implied return type is unit ()
7. A block for the function body
a. Inside the block, you can use any of the variables named in the
parameter list
b. If you want to return a value from the function, you should end your
block with an expression that has the return value
Let’s look at some examples of this:

fn subtract(x: i32, y: i32) -> i32 {
    x - y
}
The function name is subtract. It has a parameter list with two
parameters. The first is named x and is an i32. The second is named y and
is an i32. The function returns an i32. The body of the function uses both
the x and y parameters. And if we wanted to call this function, we would use
something like subtract(5, 2).

EXERCISE
What would be the result of calling subtract(5, 2)? Can you write a main function that
prints the result of subtract to prove that you have the right answer?
Here’s another example:
fn greet(name: &str) {
    println!("Hello {}", name);
}
This time, the function name is greet, and it only takes one parameter. The
parameter is called name and is a &str. There’s no explicit return type, so
this function returns a unit value. The block performs a single statement,
calling the println! macro to produce some output.

EXERCISE
Go back over other functions we’ve defined so far and make sure you can identify these various
parts.

3.7. Calling functions
Let’s go into a bit more depth on how to call a function. Let’s see an
example:
fn greet(name: &str) {
    println!("Hello {}", name);
}
fn main() {
    greet("Michael");
}
In order to call a function, we put the name of the function, followed by an
open parenthesis, followed by the parameter list, followed by a close
parenthesis. A function call itself is an expression, a fact we’ll exploit in a
little bit.
The parameter list when calling a function is a comma-separated list of
expressions. So instead of passing in a string literal above, we could do:
fn main() {
    let foo = "Michael";
    greet(foo);
}
The names we use in calling a function have nothing to do with the names for
the parameters inside the function. In this example, we made a variable in
main called foo. But when we call greet, greet will refer to it as name.
We can also call functions multiple times with different parameters. And each
time we do that, the variable in the function refers to a different value:

fn main() {
    greet("Michael");
    greet("Miriam");
}
We can also use more complicated expressions in parameter lists. For
example, we can use math operations inside the parameter list itself:
fn subtract(x: i32, y: i32) -> i32 {
    x - y
}
fn main() {
    println!("{}", subtract(5 + 2, 1 + 3));
}
And, since function calls themselves are expressions, we can use them inside
function calls. Let’s start with something a bit more verbose using a helper
variable:
fn add(x: i32, y: i32) -> i32 {
    x + y
}
fn subtract(x: i32, y: i32) -> i32 {
    x - y
}
fn main() {
    let a = add(5, 2);
    let b = add(1, 3);
    println!("{}", subtract(a, b));
}

We can get rid of the variable a by replacing its usage in subtract
parameter list with the call to add itself:
fn main() {
    let b = add(1, 3);
    println!("{}", subtract(add(5, 2), b));
}

EXERCISE
Get rid of the variable b above in the same way we got rid of add.

3.8. Is main special?
Is the main function special? Well, yes and no. On the "no" side: main is
defined just like any other function. The name it has isn’t off limits in any
way, it can be used like any other name in Rust.
fn main() {
    let main = "I can reuse the name main";
    println!("main == {}", main);
}
However, main is special in a different way: it’s the entry point to your
program, or the first thing that’s run. It has to have a specific signature. For
example, if you define your main function to take a parameter, things break,
since the compiler doesn’t know where to get that value from:
fn main(_x: i32) {
}
Additionally, main is only allowed to return some types. It can return unit,
which we’ve seen already. But if we try to return some other things, e.g.:
fn main() -> i32 {
    42
}
We get an error message:
error[E0277]: `main` has invalid return type `i32`
 --> src/main.rs:1:14
  |

1 | fn main() -> i32 {
  |              ^^^ `main` can only return types that implement 
`std::process::Termination`
  |
  = help: consider using `()`, or a `Result`
That message is a bit more complicated than we’re ready to deal with. It’s
referring to a "trait" called Termination. And it’s referring to a type called
Result. We’ll get to traits and Results later. For now, consider main a
function which is only allowed to return unit.

▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
◦
◦
▪
3.9. Summary
The main we’ve seen so far is one example of a function.
We can define multiple other functions.
We can call functions similar to how we call macros (for example,
println!).
Functions may take parameters, which are passed in from the caller.
Function parameters can be used as variables inside the body of a function.
Functions may return results of different types.
By default, functions return the unit () type.
A function body is a block, and may end with an expression, which will be
its result value.
Function parameters are scoped to the function body.
Blocks create scopes for variables defined inside of them.
main is a normal function, but has some special rules:
It cannot take any parameters.
It can only have some special result types.

3.10. Exercises
1. Will the program compile? Why or why not? If not, try to fix it.
fn main() {
    42
}
2. Will the program compile? Why or why not? If not, try to fix it.
fn main() {
    println!("{}", 42)
}
3. What is the output of this program?
fn main() {
    let x = 5;
    {
        let x = 6;
        println!("First time: {}", x);
    }
    println!("Second time: {}", x);
}
4. Add the helper functions needed to make this program pass. Do not
modify the main function itself.
fn main() {
    let x = (5 + 3) * (6 + 4);
    let y = times(add_3(5), add_4(6));
    assert_eq!(x, y);
    println!("Good job!");
}

5. Rewrite the main function to not use any variables. You’ll still want to
call both the double and triple function.
fn double(x: i32) -> i32 {
    x * 2
}
fn triple(x: i32) -> i32 {
    x * 3
}
fn main() {
    let x = double(5);
    let y = triple(x);
    println!("Answer: {}", y);
}
6. Using only two println! calls, write a program that produces the
following output:
I'm counting to 10. Currently at: 1.
I'm counting to 10. Currently at: 2.
I'm counting to 10. Currently at: 3.
I'm counting to 10. Currently at: 4.
I'm counting to 10. Currently at: 5.
I'm counting to 10. Currently at: 6.
I'm counting to 10. Currently at: 7.
I'm counting to 10. Currently at: 8.
I'm counting to 10. Currently at: 9.
Bored now!
7. Define a quadruple function, which results in the input value times 4,
built by calling the double function twice. To help you out, here’s a
skeleton you should make work. assert_eq! is a way to make sure
you’re producing the right output.

fn double(x: i32) -> i32 {
    x * 2
}
fn quadruple() {
}
fn main() -> () {
    assert_eq!(4, quadruple(1));
    assert_eq!(8, quadruple(2));
    assert_eq!(12, quadruple(3));
    assert_eq!(48, quadruple(quadruple(3)));
    println!("Success!")
}
You’ll need to modify the parameter list, return type, and body of the
quadruple function.

4. BOOLEANS
Computer programs need to make lots of decisions. "Should I download that
file?" "Should I send that email?" "Should I fire the nukes?" We generally
call these conditionals: we do something on condition that something is true.
We’ll cover conditionals themselves in the next lesson. Today, we’re going to
focus on the "something is true" part. Booleans (or bools) are values which
are either true or false. We use them a lot in computer programming.
In this lesson, weâ€™re going to dive into this type, its operations, and logic
around it. This will prepare us to start making more intelligent programs in
our next lesson, which will build conditionals on top of booleans.

▪
▪
4.1. Equality
Let me ask you a question: does 2 + 3 equal 5? Hopefully you can figure that
out. But here’s a question: can you ask your computer to figure it out for
you? It turns out you can!
fn main() {
    let result: bool = 2 + 3 == 5;
    println!("{}", result);
}
We just used the == operator, which is the equals operator. This is different
from the single equals sign, which (perhaps confusingly) is the assignment
operator. In other words:
=
Stick a value in a variable
==
See if two values are the same
Anyway, back to our example above. We have a left and right side of the ==
operator. The left is the expression 2 + 3, and the right is 5. What Rust
does here is:
Evaluates 2 + 3 to 5
Evaluates 5 == 5 to true

Then, this value gets shoved into the result variable, thanks to the
assignment operator. We gave it a type of bool. Finally, we use our trusty
old println to print out result.

EXERCISE
Change the example above so that it produces false instead of true.

4.2. Assertions
We can do more than simply print out bools. One example is the assert!
macro, which makes sure that something is true. For example, let’s write a
program to make sure we know how to do math correctly:
fn main() {
    assert!(4 + 7 == 11);
    println!("If we got here, I guess it worked!");
}
This is very similar to the assert_eq! macro we’ve seen before. If the
expression evaluates to false, the program exits with an error message.
And if it evaluates to true, nothing happens. But why would we ever want
to use assert! instead of assert_eq!? Well, maybe because we want to
work with other comparison operators:
fn main() {
    assert!(4 + 7 < 12);
    println!("Success!");
}
Here we’re using the < operator, which means "less than." We wouldn’t be
able to do the same thing with assert_eq!.
So why exactly do we need assert_eq!? It turns out it gives better error
messages. This program:
fn main() {
    let x = 2;
    let y = 3;

    assert!(x == y);
}
Results in an error message:
thread 'main' panicked at 'assertion failed: x == y', main.rs:4:5
That’s pretty unhelpful. assert_eq! can give you more information.

EXERCISE
Rewrite the program above to use assert_eq!(x, y) instead, and compare the error
message.

▪
4.3. Comparison operators
We’ve seen == and < so far. Let’s document all six of the comparison
operators we have at our disposal.
==
equals
!=
not equals
>
greater than
<
less than
>=
greater than or equals
<=
less than or equals
Comparison operators can work on lots of different types. The exact rules are
a bit beyond us right now, as they tie into traits, which we haven’t learned
yet. For now, it’s enough to know that:
Strings, numbers, booleans, and unit can all be compared with equals and
not equals

▪Numbers can all be compared with the other four operator as well
And we can see these in action using assert!, together with
assert_eq! and its not-equal counterpart assert_ne!:
fn main() {
    // These two things are basically the same
    assert!("apple" != "banana");
    assert_ne!("apple", "banana");
    assert!(5 == 5);
    assert_eq!(5, 5);
    assert!(() == ());
    // Oh, did I mention that we can use true and false like this?
    // They're also literals!
    assert!(true == true);
    assert!(true != false);
    assert!(6 != 3);
    assert!(6 > 3);
    assert!(3 < 6);
    assert!(6 >= 3);
    println!("Success!");
}

EXERCISE
What will happen if you use assert!(true)? How about assert!(false)? Try it and
see if it’s what you expected.

4.4. Functions returning booleans
Since bool is a type just like i32, we can return it from functions.
fn temperature() -> i32 {
    15 // feel free to change this!
}
fn is_hot() -> bool {
    temperature() > 30
}
fn main() {
    assert!(is_hot() == false);
    println!("Success!");
}
Here, we have a temperature function which pretends to get the current
temperature. Then our is_hot function checks if the current temperature is
greater than 30 to determine if it’s hot. (For confused Americans: this is in
Celsius.) Then, in the main function, we check to make sure is_hot() is
false.

EXERCISE
Change the temperature in the program to make the assertion fail. Then change the assertion to
make it work again.

EXERCISE
Add an is_cold function that checks if it’s less than 5 degrees.

EXERCISE
Rewrite the original assertion is_hot() == false to use the not equals operator. You’ll
need to replace false with something else.

4.5. The not operator
Personally, I find is_hot() == false to be a bit weird to read. If we
were having a conversation, I wouldn’t say "make sure that it is hot is false."
I wouldn’t say "make sure that it is hot is not true." A more normal way to
say this is "make sure that it is not hot." The not is the important bit. It would
sure be nice if there was a way in Rust to say not… wouldn’t it?
Well, with that kind of an introduction, and the name of this subsection, I’m
sure you can see what’s coming next… I’d like to introduce you to the not
operator! So far, the operators we’ve seen have been binary operators,
meaning they work on two values at once. For example, with ==, we say
something like x == y, comparing the values x and y. The not operator is
unary, meaning it only works on one value. Let’s see it in action:
fn main() {
    let x = true;
    let y = !x; // not x
    let z = !y; // not y
    // All three of the following do the same thing
    assert!(z == true);
    assert_eq!(z, true);
    assert!(z);
    // Same for these three
    assert!(y == false);
    assert_eq!(y, false);
    assert!(!y);
    println!("Woohoo!");
}

The not operator is the exclamation point !. It changes true into false
and false into true. That’s really all there is to it!

EXERCISE
What will the expressions !!true and !!false evaluate to? Write a program to test if
you’re right.
As a reminder from above, == is "equals" and != is "not equals." Now that
you know that ! is "not," using != for "not equals" is hopefully a bit easier to
remember.

4.6. Not-ing other comparison operators
It may seem a bit weird to you that we have six comparison operators, but
only two of them form a pair. Sure, we have "equals" going with "not
equals." But why don’t we have "less than" and "not less than," using a
symbol like !<? It turns out that this isn’t necessary at all, because we
already have a "not less than" operator. And it’s already mentioned in this
lesson. Take a moment and see if you can figure out what it is.
The answer is that the opposite of "less than" < is "greater than or equal" >=.
Similarly, the opposite of "greater than" > is "less than or equal" <=.

EXERCISE
Make sure you’re comfortable with the opposites claim I just made. Test it out— either with a
program or on paper— on a few different sets of numbers to make sure you’re convinced that
these operators really are opposites.

4.7. And/or
Let’s say I’m selling movie tickets, and we give a discount to people under
18, as well as to people 65 and older. I’d like to write a function "gets
discount." I can state the requirement in almost-code as age < 18 OR
age >= 65. Unfortunately, that OR isn’t real Rust code. Instead, it’s time to
introduce the or operator, which is two pipes || (hold shift and hit the
backslash key on most keyboards).

EXERCISE
Implement the gets_discount function correctly to make this program pass.
fn gets_discount(age: u32) -> bool {
    unimplemented!() // replace this!
}
fn main() {
    // Kids
    assert_eq!(gets_discount(7), true);
    assert!(gets_discount(8));
    assert!(gets_discount(17));
    // Adults
    assert_eq!(gets_discount(18), false);
    assert!(!gets_discount(30));
    assert!(!gets_discount(64));
    // Seniors
    assert!(gets_discount(65));
    assert!(gets_discount(70));
    println!("Success!");
}
The or operator is binary, so it takes two values. There are a few different
ways to explain how it works.
1. If either or both values is true, it evaluates to true, otherwise it evaluates
to false.
2. If both values are false, it evaluates to false, otherwise it evaluates to
true.

3. If the first value is true, it’s true, otherwise it’s the result of the second
value.
4. Or we can just put it in a table!
Table 1. Or operator
x
y
x || y
true
true
true
true
false
true
false
true
true
false
false
false
Going back to our example above: we wrote a gets_discount function.
Let’s say we want the opposite of that, a pays_full_price function. One
easy way to write that is to piggy-back on gets_discount:
fn pays_full_price(age: u32) -> bool {
    !gets_discount(age)
}
fn main() {
    assert!(!pays_full_price(17));
    assert!(pays_full_price(18));
    assert!(pays_full_price(64));
    assert!(!pays_full_price(65));
}
This is actually good programming practice: instead of duplicating our logic,
we define our new logic on top of our old stuff by saying "you pay full price

if you’re not getting a discount." This means that if in the future we change
our discount policy, both functions will get updated at the same time.
However, let’s be stubborn and write out the function without using
gets_discount. Why? Because I want to teach you something!
Let’s take a really lazy approach. The body of gets_discount is age <
18 || age >= 65. We want to do "not that." So one possible
implementation of pays_full_price is:
fn pays_full_price(age: u32) -> bool {
    !(age < 18 || age >= 65)
}
This can be read as "not (less than 18 or at least 65)". Maybe with slightly
nicer English, it would be "neither less than 18 nor at least 65." However, to
me, this logic feels backwards. We’re still thinking about this in terms of the
opposite of the people who get a discount.
There’s another way to think about this: you pay full price if your age is
between 18 and 64. Or said another way, if your age is at least 18 and less
than 65. Notice that word "and?" Time to learn a new operator: &&. Using
that, we can implement pays_full_price.

EXERCISE
Implement pays_full_price using the operators >=, &&, and <.
Like the or operator, the and operator is binary. I’ll give the mirror ways of
explaining and just like I explained or above.
1. If both values are true, it evaluates to true, otherwise it evaluates to false.
2. If either or both values is false, it evaluates to false, otherwise it
evaluates to true.
3. If the first value is false, it’s false, otherwise it’s the result of the second
value.
4. Or the table again!
Table 2. And operator
x
y
x && y
true
true
true
true
false
false
false
true
false
false
false
false

EXERCISE
Figure out what each of these expressions evaluates to. Write a program to make sure you got
the right answer.
1. true && false
2. false || true
3. true && true
4. true && (true || false)
5. false && false
6. !true || true
7. (true && false) || !false

▪
▪
▪
▪
▪
▪
▪
▪
4.8. Summary
bool is a type with two possible values: true and false
true and false are both literals
You can use the assert! macro to make sure expressions evaluate to
true
You can use the six comparison operators to compare values and get bool
results
Functions can return bools, just like they can return i32s and other types
The ! is the not operator, and it changes true to false and false to
true
The six comparison operators form three pairs of operators which are the
opposite of each other
&& is the and operator, and || is the or operator

4.9. Exercises
1. Write a function that implements the logic "Michael is allowed to drive if
he’s 18 or older. Anyone else can drive if they are 16 or older." Complete
the program below by replacing the /* FIXME */ comments and
make it succeed:
fn can_drive(name: &str, age: u32) -> bool {
    (name != "Michael" && age /* FIXME */) ||
    (/* FIXME */)
}
fn main() {
    assert!(can_drive("Michael", 18));
    assert!(!can_drive("Michael", 17));
    assert!(can_drive("Miriam", 16));
    assert!(!can_drive("Miriam", 15));
    println!("Success!");
}
2. Write a function that implements the logic "you can see the movie if you
are 17 or older, or you’re 13 or older and have a parent’s permission."
You can test it with this main:
fn main() {
    assert!(can_see_movie(17, false));
    assert!(can_see_movie(21, false));
    assert!(!can_see_movie(13, false));
    assert!(can_see_movie(13, true));
    assert!(!can_see_movie(12, true));
}

5. CONDITIONALS
Now that we’re comfortable with booleans, we’re ready to jump into
conditionals. The term conditional refers to making decisions in your
program on what to do. In other words, you’ll do something conditionally
based on some value. The most common word used for this in programming
is if. If something is true, then do something else.

5.1. Hello If
Let’s dive right in with an example:
fn main() {
    let is_hot = true;
    if is_hot {
        println!("It's hot!");
    }
}
We declare a bool variable called is_hot. Then we use that variable to
create an if expression. If is_hot evaluates to true--which it definitely
does here— this will print out the message "It’s hot!" If is_hot evaluates to
false, then this program will produce no output.

EXERCISE
Change is_hot to be false and confirm that nothing happens.
We can put more complex expression in our if condition if we want:
fn main() {
    let temp = 20;
    if temp > 15 && temp < 27 {
        println!("It's fairly comfortable in here!");
    }
}
And the body of the if expression is a block, which conforms with all of the
normal rules of a block in Rust. We can put in multiple statements:
fn main() {
    let temp = 20;
    if temp > 15 && temp < 27 {
        println!("It's fairly comfortable in here!");
        println!("Would you like a drink?");
    }
}
And you can even put ifs inside other ifs:
fn main() {
    let temp = 20;
    if temp > 15 && temp < 27 {
        println!("It's fairly comfortable in here!");
        if temp < 20 {
            println!("But it could be a bit warmer.");
        }
    }

}
However, there is one restriction in the kind of if expressions we’ve seen so
far. They must evaluate to unit (). The following program will not compile:
fn main() {
    let temp = 20;
    if temp > 15 && temp < 27 {
        println!("It's fairly comfortable in here!");
        "Hello, world!"
    }
}
We end up with the error message:
error[E0308]: mismatched types
 --> main.rs:5:9
  |
1 | fn main() {
  |           - expected `()` because of default return type
...
5 |         "Hello, world!"
  |         ^^^^^^^^^^^^^^^ expected (), found reference
  |
  = note: expected type `()`
             found type `&'static str`
The reason why this restriction has to exist is that, if the condition turns out
to be false, the compiler has no way to conjure up a string response. The
only kind of value that the compiler can make up out of thin air is a unit
value. And therefore, with our if expressions, we need to return unit
exclusively.

We’ll see in a bit how we can return a non-unit value out of an if
expression.

5.2. A note on semicolons
If you remember back from lesson 2, we said that any expression can be
converted into an expression statement by putting a semicolon at the end.
That’s what happens with all of our println! macro calls: the println!
part is an expression, and following it with a semicolon turns it into a
statement. But if you look at the example above, I never put a semicolon after
the if expression. Technically, you can put them there if you want, but that’s
not recommended style in Rust.
There’s one other rule about expression statements that I didn’t mention
previously. If you have a block-like expression (such as an if expression),
and if that expression evaluates to unit, you’re allowed to leave off the
semicolon. We’ve actually been doing that in a lot of examples already, but
just haven’t made a big deal about it. For example, we’ve seen code like this
with blocks quite a bit:
fn main() {
    {
        println!("Hello, world!");
    }
    {
        println!("Goodbye!");
    }
}

EXERCISE
Remove all of the semicolons from the example above. Does it still compile? Can you explain
why it still compiles?
There are two times when you must keep the semicolon after a block-like
expression. The first is when the block evaluates to something besides unit.
For example, it’s impossible to remove the semicolon here:
fn main() {
    {
        "Hello, world!"
    };
    {
        println!("Goodbye!")
    }
}
The other case, which we see a lot, is when a block-like expression is on the
right hand side of a let statement. In those cases, you still need the
semicolon in order to complete the let statement. Once again, we must have
the semicolon here:
fn main() {
    let message = {
        "Hello, world!"
    };
    println!("{}", message)
}

5.3. Else
Alright, I want a program that says "it’s hot" if it’s hot, and "it’s not hot" if
it’s not hot. We can do this with two ifs with opposite conditions:
fn main() {
    let is_hot = false;
    if is_hot {
        println!("It's hot!");
    }
    if !is_hot {
        println!("It's not hot!");
    }
}
But that code doesn’t really feel nice. This "do this or do this" concept is
pretty common, and so we have something built in: else. Each if can be
followed by an else, like this:
fn main() {
    let is_hot = false;
    if is_hot {
        println!("It's hot!");
    } else {
        println!("It's not hot!");
    }
}
The Rusty way of writing the code is to put the else { on the same line that
the previous } is on, like I’ve done above.

EXERCISE
Write a function tell_temperature that says "It’s hot!" if the temperature is at least 30,
and otherwise says "It’s not hot!" Test it with this main function:
fn main() {
    tell_temperature(10);
    tell_temperature(20);
    tell_temperature(30);
    tell_temperature(40);
}
The output should be:
It's not hot!
It's not hot!
It's hot!
It's hot!

▪
▪
▪
▪
5.4. Else if
Alright, let’s get a bit more sophisticated. I want to print out a bunch of
different messages depending on the temperature:
If it’s 10 or under, we say "it’s cold"
If it’s between 11 and 25, we say "it’s nice"
If it’s between 26 and 30, we say "it’s warm"
If it’s over 30, we say "it’s hot"
We could do this with just our if and else approach, by nesting ifs inside
our elses. If you want a challenge exercise, try to do that yourself now.
Here’s my solution:
fn tell_temperature(temp: i32) {
    if temp <= 10 {
        println!("It's cold!");
    } else {
        if temp <= 25 {
            println!("It's nice");
        } else {
            if temp <= 30 {
                println!("It's warm");
            } else {
                println!("It's hot!")
            }
        }
    }
}

This code is hard to read and understand. It has the ever-increasing-indent
problem. We typically don’t like to make our nesting level deep like this.
Fortunately, there’s one more addition to our if/else story that makes this
look beautiful: else if. Let’s see it in action.
fn tell_temperature(temp: i32) {
    if temp <= 10 {
        println!("It's cold!");
    } else if temp <= 25 {
        println!("It's nice");
    } else if temp <= 30 {
        println!("It's warm");
    } else {
        println!("It's hot!")
    }
}

▪
▪
5.5. Evaluating to values
I mentioned that an if is an expression. And if you remember from lesson 2:
An expression is evaluated to a value of a specific
type
So far, every if expression we’ve had evaluates to unit. However, we can
have it evaluate to something else, with the following restriction:
There must be an else at the end
Each block for each if, else, and else if in the expression must
evaluate to the same type
So, for example, this code is good:
fn tell_temperature(temp: i32) {
    let message = if temp <= 10 {
        "It's cold!"
    } else if temp <= 25 {
        "It's nice"
    } else if temp <= 30 {
        "It's warm"
    } else {
        "It's hot!"
    };
    println!("{}", message);
}
However, this code does not work, since it’s missing the else:

fn tell_temperature(temp: i32) {
    let message = if temp <= 10 {
        "It's cold!"
    } else if temp <= 25 {
        "It's nice"
    } else if temp <= 30 {
        "It's warm"
    };
    println!("{}", message);
}
And this code doesn’t compile because one of the branches evaluates to unit
() and the others evaluate to a string &str:
fn tell_temperature(temp: i32) {
    let message = if temp <= 10 {
        "It's cold!"
    } else if temp <= 25 {
        "It's nice"
    } else if temp <= 30 {
        println!("It's warm");
    } else {
        "It's hot!"
    };
    println!("{}", message);
}
We can use the result of evaluating an if expression like we have here to set
a variable. Or we can use it directly inside any location that needs an
expression, such as a macro call. We can rewrite the code above to:
fn tell_temperature(temp: i32) {
    println!(
        "{}",

        if temp <= 10 {
            "It's cold!"
        } else if temp <= 25 {
            "It's nice"
        } else if temp <= 30 {
            "It's warm"
        } else {
            "It's hot!"
        }
    );
}
Notice that we made sure that the braces and parentheses nest correctly. We
finished off all of the curly braces and then closed off the parameter list for
the println! call. Also notice how rustfmt recommends aligning and
indenting the code to make it easier to read. Remember, the alignment
doesn’t help the computer at all, but it does help you, the programmer.

▪
▪
5.6. Factorial
Now that we have conditionals, we can start to put together far more
sophisticated programs than we’ve seen so far. Let’s write a function to
compute factorials. Factorials multiply all the numbers down to 1. For
example, the factorial of 5 is 5 * 4 * 3 * 2 * 1. But there’s a different
way of defining factorials that also works.
The factorial of 0 is 1.
The factorial of x is x times the factorial of x - 1
㇀
We’re ignoring negative numbers and non-integers.
And in fact, we can write exactly that code in Rust. If you’re brave, give a
shot at writing a function called fact (short for factorial) that uses an
if/else and calls itself. If you’re not brave, or when you want to check
your answer, I’ve included a solution below.
// Used a u32 instead of i32 since we don't support negatives
fn fact(x: u32) -> u32 {
    if x == 0 {
        1
    } else {
        x * fact(x - 1)
    }
}
fn main() {

    println!("Fact of 5: {}", fact(5));
}
The concept of a function calling itself is known as recursion. Recursion is
possible in Rust, but it’s not really encouraged. Instead, Rust favors
something called iteration, also known as looping. We’ll be going into that
much more in the next lesson.

▪
▪
▪
▪
▪
▪
5.7. Summary
The if expression can be used to only perform an effect if a condition is
true
An else branch can be added to an if to do something if the condition is
false
You can build up more complex series of conditions with if/else
if/else
If you provide an else, and all branches evaluate to the same type, you
can evaluate to a value from your if expression
Functions can call themselves using recursion, which combined with
conditionals can allow for more sophisticated programs
Block-like expressions that evaluate to unit do not need a semicolon to be
turned into statements

5.8. Exercises
1. What is the output of this program?
fn main() {
    if 5 == 5 {
        println!("5 == 5 is true");
    }
    if 5 > 5 {
        println!("5 > 5 is true");
    }
    if 5 >= 5 {
        println!("5 >= 5 is true");
    }
}
2. Replace all four FIXMEs below with the correct type:
fn want_apples() -> bool {
    true
}
fn want_five() -> bool {
    false
}
fn talk_about_fruit() -> bool {
    true
}
fn talk_about_numbers() -> bool {
    false
}
fn main() {

    let fruit: FIXME = if want_apples() {
        "apple"
    } else {
        "banana"
    };
    let number: FIXME = if want_five() {
        5
    } else {
        6
    };
    let _x: FIXME = if talk_about_fruit() {
        println!("The fruit is {}", fruit);
    };
    let _y: FIXME = if talk_about_numbers() {
        println!("The number is {}", number);
    };
}
3. Rewrite the program below to not use any lets.
fn comment(apples: i32) {
    let message = if apples > 10 {
        "lots of"
    } else {
        "very few"
    };
    println!("You have {} apples", message);
}
fn main() {
    comment(5);
    comment(100);
}

Reminder: you can put any expression inside a macro call’s parameter
list.
4. Write a new function, is_hot, which always returns the opposite of
is_cold. Use the program below to test your new function.
fn is_cold() -> bool {
    true // feel free to change this to false
}
fn main() {
    assert_ne!(is_cold(), is_hot());
    println!("Success!");
}
5. The exercise will be a reminder of both last lesson’s boolean’s and cover
conditionals. I want to write a program that tells the kids whether or not
they can go outside. The kids are allowed to go outside if it’s not raining,
or if the temperature is at least 10 degrees. Complete the program below
by replacing the unimplemented!() macro calls with the right logic.
Do not modify the main function. The output should be:
Sorry, it's too cold and it's raining
You can go outside
You can go outside
You can go outside
fn can_go_outside(is_raining: bool, temp: i32) -> bool {
    unimplemented!()
}
fn tell_kids(is_raining: bool, temp: i32) {
    let msg: &str = unimplemented!();

    println!("{}", msg);
}
fn main() {
    tell_kids(true, 9);
    tell_kids(true, 10);
    tell_kids(false, 9);
    tell_kids(false, 10);
}
6. Fix the program below so that it compiles and produces the output:
I NEED APPLES!!!
I NEED APPLES!!!
I have enough apples
fn helper(apples: i32) {
    let x = if apples > 10 {
        "I have enough apples"
    } else {
        false
    };
    println!("{}", x);
}
fn main() {
    helper(9);
    helper(10);
    helper(11);
}
7. Modify the look_at_apples function below so that this program
produces the output:
Count: normal consecutive apples

Count: good number of apples
Count: lots of apples
Count: over nine thousand
fn look_at_apples(apples: i32) {
    let count = if apples > 9000 {
        "over nine thousand"
    } else {
        "normal consecutive apples"
    };
    println!("Count: {}", count);
}
fn main() {
    look_at_apples(10);
    look_at_apples(100);
    look_at_apples(1000);
    look_at_apples(9001);
}

6. MUTABLE VARIABLES AND
WHILE LOOPS
At the end of the last lesson, we saw recursion. That allowed us to do
something more than once. However, in Rust, recursion isn’t the preferred
way to make that happen. Instead, Rust prefers something called iteration.
Iteration is a more direct way to say "do this more than once" than recursion.
Iteration all but requires the usage of mutation. So far, all of the variables
we’ve looked at in Rust have been immutable: once created, you can’t change
them. With shadowing and function calls, the exact value for a given name at
a specific point in your code may appear to be different. But you’re never
changing the actual underlying thing, just reusing the same name to point at
something else.
In this lesson, we’re going to cover the basics of both mutation and iteration.
There is much more to cover in both of these topics, and we’ll hit more
aspects of them in later lessons. Our goal now is to get the bare minimum so
we can start getting into more fun stuff in Rust.
To start this all off, we’ll want to motivate why we’d want to be able to
mutate things.

6.1. while expressions/loops
Let’s remember the simple statement form of an if expression, which can let
us optionally do something:
if is_raining() {
    println!("Hey, it's raining!");
}
One way of describing the effect of this if is that the body will be evaluated
zero or one times. This can be limiting: what if we want to do something
more than just once? That’s where a while comes into play. while is
another expression in Rust, and it lets you evaluate the body zero or more
times. It looks almost identical to the if above, you just swap out the initial
words:
while is_raining() {
    println!("Hey, it's raining!");
}
This will:
1. Evaluate the expression is_raining()
2. If the expression is false, it will stop
3. If it is true, it will:
a. Evaluate the body/block
b. Go back to step 1

▪
▪
There’s one major problem with this. What do you think the is_raining
function will look like? From what we’ve learned so far, it can really only:
Perform some actions, like printing out messages
Return either true or false
Let’s see an example:
fn is_raining() -> bool {
    false
}
If this is our is_raining function, our while expression will be pretty
boring. Since this function always returns false, our while expression
will never do anything! However, let’s consider this possibility:
fn is_raining() -> bool {
    true
}
This function will always return true. This is a good way to create an
infinite loop: the program will keep evaluating is_raining to true, and
will keep running the body of the while expression over and over. That’s
probably not what we want either. We need some way to create an expression
that can sometimes be true, and sometimes be false. We don’t know how
to do that yet.

▪
▪
▪
COMEDIC INTERLUDE
One day a programmer was found dead in the shower. The detectives investigated the cause of
death, and noticed that the programmer was clutching an empty bottle of shampoo. They
investigated, and found the following three words:
Lather
Rinse
Repeat
They ruled the cause of death to be iteration.

6.2. Failed attempt: shadowing
Let’s try to use the tools we already have in our toolbox to make a while
loop that exits. We’ll create a variable keep_going. It will start off as
true, and then we’ll make the variable equal to false inside the body of
the while using name shadowing. As a reminder, name shadowing lets us
create a new variable with the same name as the one before, e.g.:
let x = 5;
let x = 6;
if x == 6 {
    let x = 7;
}
let x = 8;
Using this technique, we can try to make a while loop that evaluates its
body just once.
Â
You probably don’t want to run this first example. Try to see why before I give the
explanation below.
fn main() {
    let keep_going = true;
    while keep_going {
        println!("Inside the while loop");
        let keep_going = false;
    }
}

If you run this on your local machine, it will print the line "Inside the while
loop" forever. If you use the online Rust playground, it will eventually stop,
but only because your program is taking too long to run. This program is an
infinite loop. The question is: can you explain why?
The compiler generates a warning that may help explain this:
warning: unused variable: `keep_going`
 --> main.rs:5:13
  |
5 |         let keep_going = false;
  |             ^^^^^^^^^^ help: consider prefixing with an 
underscore: `_keep_going`
  |
  = note: `#[warn(unused_variables)]` on by default
Interesting: the keep_going we define inside our while loop’s body is
never used. This has to do with scoping. The boolean expression immediately
after the word while cannot refer to any variables inside the body of the
while expression. Instead, the body has its own, smaller scope. You can
play around with variables inside there all you want, but the while
expression itself, or the main function for that matter, won’t see any of that.
The changes are entirely contained inside the block.
What we want to do is have the body of the while expression change the
original keep_going variable, not simply create a new variable with the
same name.

6.3. Almost correct: assignment
A let statement defines a new variable. What if we did the same let
keep_going = false;, but without the let? In other words, what if
our program looks like this:
fn main() {
    let keep_going = true;
    while keep_going {
        println!("Inside the while loop");
        keep_going = false;
    }
}
This is close, but no cigar: Rust complains with the following error message:
error[E0384]: cannot assign twice to immutable variable 
`keep_going`
 --> main.rs:5:9
  |
2 |     let keep_going = true;
  |         ----------
  |         |
  |         first assignment to `keep_going`
  |         help: make this binding mutable: `mut keep_going`
...
5 |         keep_going = false;
  |         ^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable 
variable
Those words mutable and immutable sure look interesting, especially since
this lesson’s name says mutable! In Rust, all variables are immutable by
default. That means that, once you give them a value, that value stays the

same forever. Sure, you can shadow a variable with a new one, but the
original stays the same.
By contrast, with mutable variables, you are allowed to assign new values to
the same variable multiple times.

EXERCISE
Following the error message above, figure out how to modify your let statement so that the
program above compiles and prints "Inside the while loop" once.
You may be wondering: why should variables be immutable by default? This
turns out to be a great sanity-saving technique in programming. It’s generally
speaking much easier to think about what’s happening in a program when
there are less moving parts. Making things immutable by default, and then
explicitly changing them to mutable, makes it much easier to see where you
need to focus your attention.

6.4. More than once!
If you squint at the program above, our while loop isn’t much of a loop: it
still only runs the body once. Can we modify it so that it prints "Inside the
while loop" four times, while only using one println! call? Yes we can!

CHALLENGE EXERCISE
I’ll show you the answer in a second, but try to figure out the solution yourself. If you’re
stumped, here’s a hint: instead of a mutable bool variable, you’ll probably want a mutable
i32 variable.
Our mutable keep_going only has two states: true and false. That’s
too limiting for trying to get the loop to run four times. Instead, let’s keep a
counter of how many times we’ve gone through the loop already:
let mut counter: i32 = 0;
We want to keep looping as long as we haven’t gotten to a count of 4, so we
can change our conditional to:
while counter < 4
And then, after we call println!, we need to increment counter, or
make it one bigger:
counter = counter + 1;
However, this "modify a mutable variable by adding a value to it" is so
common that it has a special operator in Rust:
counter += 1;
And as you may guess, there are also -=, *=, and /= or subtraction,
multiplication, and division, respectively.

EXERCISE
Put together all of the code snippets above into a working example that prints the sentence
"Inside the while loop" 4 times.

EXERCISE
Modify the program above so that it tells you how many times it’s already looped. The output
should be:
Inside the while loop, already looped 0 times
Inside the while loop, already looped 1 times
Inside the while loop, already looped 2 times
Inside the while loop, already looped 3 times
Yes, "1 times" is bad grammar. If you’re really pedantic, you can try to fix that too!

▪
▪
6.5. Counting
One of the common bugs in computer programming is an off-by-one error.
Often times, we end up writing programs that do things either one too many
or one too few times. Let’s see if you can predict the output of this program:
fn main() {
    let mut i = 1;
    while i < 10 {
        println!("i == {}", i);
        i += 1;
    }
}
It kind of looks like it will print i == 1 all the way up to i == 10.
However, it actually stops at 9, since we keep looping as long as i is less
than, but not equal to, 10. There are two one-character changes to fix this:
Change i < 10 to i <= 10
Change i < 10 to i < 11
Make sure you can explain to yourself why both of these work!
㇀
This way of counting from 1 to 10 is actually pretty tedious by Rust standards. There’s a
better kind of loop for this, a for loop. We’re going to learn about that one later.

EXERCISE
How many times will the message "Hello, world!" get printed here? Once you think you’re
sure, count. If you got it wrong, try to figure out why.
fn main() {
    let mut i = 0;
    while i < 10 {
        println!("Hello, world!");
        i += 1;
    }
}

6.6. Sum
So far, we’ve just used one mutable variable to keep track of where we are,
so to say, in the loop. But we’re not limited to that. We can also use a
mutable variable to keep track of a result. This is sometimes known as an
accumulator, since we’re accumulating a result value at each iteration. We
can use this technique to add up the numbers from 1 to 10.
fn main() {
    let mut total = 0;
    let mut i = 1;
    while i <= 10 {
        total += i;
        i += 1;
    }
    println!("The total is {} ", total);
}

EXERCISE
Write a generalized sum function that will add up all of the numbers from the "low" to "high"
number, inclusive. In other words, sum(1, 3) should add the numbers 1, 2, and 3. Here’s a
template to get you started and test your work:
fn sum(low: i32, high: i32) -> i32 {
    unimplemented!()
}
fn main() {
    assert_eq!(3, sum(1, 2));
    assert_eq!(2, sum(2, 2));
    assert_eq!(55, sum(1, 10));
    println!("Success!");
}

6.7. Nested loops
A common technique in programming is nested loops, where you put one
loop inside another loop. For example, maybe we want to print up the sum of
the numbers between 1 and 10, and between 1 and 11, and between 1 and 12,
all the way up to 1 and 20. This is a perfect use case for a nested loop:
fn main() {
    // Loop over the high values running from 10 to 20
    let mut high = 10;
    while high <= 20 {
        // Each time we have a new high value,
        // we start a new sum. Start the total
        // at 0, and start adding from 1.
        let mut i = 1;
        let mut total = 0;
        // Now, get all the numbers from 1 to
        // the high number and add them to total.
        while i <= high {
            total += i;
            i += 1;
        }
        // Print out the result...
        println!("sum(1, {}) == {}", high, total);
        // And go on to the next high
        high += 1;
    }
}
Or we could print out a square size 10 by 10, with a diagonal line of Xs
through it. We’ll use the print! macro to make this happen. It’s just like

the println! macro, but it doesn’t start a new line after its output.
fn main() {
    let mut row = 0;
    while row < 10 {
        let mut col = 0;
        while col < 10 {
            print!("{}", if row == col { "X" } else { "O" });
            col += 1;
        }
        println!("");
        row += 1;
    }
}

EXERCISE
Extract the body of main into its own function, and replace 10 with an argument to that
function. The following main function should work:
fn main() {
    print_square(10);
    print_square(15);
}

6.8. Mutation and shadowing
We’ve seen that mutation and shadowing can in some ways serve the same
goal: making the same name mean different things at different points in your
code. However, it’s important to remember that these are different concepts.
For example, you can shadow an immutable variable with a mutable one:
fn main() {
    let x = 5;
    {
        let mut x = 6;
        assert_eq!(x, 6);
        x += 1;
        assert_eq!(x, 7);
        x = 8;
        assert_eq!(x, 8);
    }
    assert_eq!(x, 5);
}

EXERCISE
What is the output of this program?
fn main() {
    let mut x = 5;
    println!("x == {}", x);
    x += 2;
    {
        let x = 20;
        println!("x == {}", x);
    }
    println!("x == {}", x);
}

▪
▪
6.9. let without assignment
So far, we’ve always immediately assigned to variables with let. However,
it’s valid in Rust to separate these steps out. For example:
fn main() {
    let x;
    x = 5;
    println!("x == {}", x);
    let mut y;
    y = 5;
    y += 1;
    println!("y == {}", y);
}
I point this out now because it may be surprising that:
x is an immutable variable
But we’re allowed to say x = 5
The rule is: if you have an immutable variable, you can only assign to it once.
Usually that will be at the same time as you use let, but it can be later. If
you have a mutable variable, you can assign as many times as you want.
Why might you want to do that? Well, it can be convenient in some cases to
assign inside a conditional, e.g.:
fn is_raining() -> bool {
    true
}

fn main() {
    let x;
    if is_raining() {
        x = 5;
    } else {
        x = 6;
    }
    println!("x == {}", x);
}
However, in these cases it’s usually better to use the if as part of the
assignment directly, e.g.:
let x = if is_raining() {
    5
} else {
    6
};
There’s also a major downside to separating a let declaration and
assignment: you can end up with unassigned variables which can’t be used.
For example, it’s all too easy to write something like:
let x;
if is_raining() {
    x = 5;
}
println!("x == {}", x);
This code will fail to compile, however, since if is_raining() returns
false, you end up with an unassigned x variable.

▪
▪
▪
With all of that said, my strong recommendation is: for immutable variables,
you should only ever assign on the same line that you have a let. You
should never have a let varname; sitting on its own. Summing up the
rules:
For immutable variables, you can assign once, either with the let or
separately.
For mutable variables, you can assign multiple times.
You can only use a variable if Rust can prove its been assigned to already.

▪
▪
▪
▪
▪
▪
▪
6.10. Summary
Variables in Rust are, by default, immutable. Immutable variables can be
shadowed, but never changed.
You can make a variable mutable with the mut keyword in its let
statement.
Once mutable, you can change the value of a variable with assignment
(e.g. x = 5;) and mutation operators (e.g. x += 2;).
Mutation is almost always necessary to perform iteration.
A while expression is like an if expression, but continues to evaluate
the body as long as the condition remains true.
You can nest loops inside each other to create more powerful loops.
You can use let to declare variables without assigning, though you
probably don’t want to.

6.11. Exercises
1. Last time, we implemented a factorial function using recursion. As a
reminder, a factorial multiplies all the numbers from 1 up to the target, so
fact(5) == 1 * 2 * 3 * 4 * 5. Write a fact function using
iteration and a while loop instead of recursion.
2. Write a program that uses nested while loops to produce this output:
X
XX
XXX
XXXX
XXXXX
XXXXXX
XXXXXXX
XXXXXXXX
XXXXXXXXX
XXXXXXXXXX
3. Write a function that prints a border made out of asterisks (*) for a given
number of rows and columns. For example, with the main function:
fn main() {
    print_border(6, 5);
}
We should get the output
*****
*   *
*   *
*   *

▪
▪
▪
▪
*   *
*****
Hint: while there are multiple ways to approach this, I would
recommend:
Write a helper function print_top_bottom that prints the top and
bottom rows
Write a helper function print_middle that prints a middle row
Have 
two 
calls 
to print_top_bottom, and one call to
print_middle, in your print_border function.
And a final helper question: if there are 10 total rows in the square,
how many middle rows will there be?
4. Using a while loop, write "99 bottles of beer on the wall." The output
should look like this:
99 bottles of beer on the wall,
99 bottles of beer.
You take one down, pass it around.
98 bottles of beer on the wall.
98 bottles of beer on the wall,
98 bottles of beer.
You take one down, pass it around.
97 bottles of beer on the wall.
...
2 bottles of beer on the wall,
2 bottles of beer.
You take one down, pass it around.
1 bottle of beer on the wall.
1 bottle of beer on the wall,

1 bottle of beer.
You take one down, pass it around.
No bottles of beer on the wall.
Extra credit if you get the difference between "bottle" and "bottles"
correct, and if you say "No bottles" instead of "0 bottles" at the end.
5. Print multiples of 5 from 5 to 100.
6. Write a program that prints the numbers 10 down to 1.

7. STRUCTS AND OWNERSHIP
This lesson will start off by learning about structs, short for structures.
structs give us a way to create new types, and to combine together
logically related data. This will be a great launch point for introducing one of
the most core concepts in all of Rust: ownership. Ownership is a Really Big
Deal in Rust, and we’re just going to get our feet wet.
One thing to know about this lesson: you’re going to see a lot of annoying
ways of doing things. Don’t worry, this is not the True Rust Way. This lesson
will be setting up some pain points so that in the next lesson, we can learn the
real solutions to these problems.

7.1. All this fruit!
Let’s say I sell fruit. I need to know how many apples and bananas I have.
Since I’m a Rustacean, I write a program to tell me:
fn count_fruit(apples: i32, bananas: i32) {
    println!("I've got {} apples and {} bananas", apples, 
bananas);
}
fn main() {
    count_fruit(10, 5);
}
Easy enough. I’m a little annoyed about this program though. Look at the
main function’s body all on its own:
count_fruit(10, 5);
What do 10 and 5 mean? I have to go and look at the definition of
count_fruit to realize this means 10 apples and 5 bananas. But fine, I’m
going to just leave that. Now I realize I need to check how much my stock is
worth. It turns out I can sell an apple for 8 cents, and a banana for 12 cents.
So I write a helper function called price_fruit that returns the price of
all my fruit:
fn price_fruit(apples: i32, bananas: i32) -> i32 {
    apples * 8 + bananas * 12
}
And then I can call it in the main function:

▪
▪
▪
fn main() {
    count_fruit(10, 5);
    let price = price_fruit(10, 5);
    println!("I can make {} cents", price);
}
Alright, now I’m doubly annoyed. Not only do I have that 10 and 5 hanging
out there like that, but I have it twice! This is not my idea of a good time.
Let’s make it just a little bit worse. I’m considering increasing my inventory,
by doubling my apples and tripling my bananas. So I want to get the price of
all my fruit after such an increase. One way to do this would be to do the
multiplication in main:
fn main() {
    count_fruit(10, 5);
    let price = price_fruit(10, 5);
    println!("I can make {} cents", price);
    let increased_price = price_fruit(10 * 2, 5 * 3);
    println!("I can make {} cents from more fruit", 
increased_price);
}
Ugh, that’s even worse! This all feels wrong. What I’d like is:
The ability to see easily which number means apples, and which means
bananas
The ability to reuse the combination of apples and bananas
Some way to just increase that combined information about apples and
bananas

With that motivation, let’s dive into structs!

7.2. Struct
A struct in Rust allows you to create a new data type made up of values
from other data types. So far, we’ve worked with primitives--things built into
the language— like an i32. But we can combine these primitives into larger,
custom types. In this case, I want to define a new data type called Fruit,
which tells me how many apples and bananas I have. Let’s see what that
looks like:
struct Fruit {
    apples: i32,
    bananas: i32,
}
struct starts a declaration, similar to how fn starts a declaration. In the
case of fn, we’re declaring a new function name. In the case of a struct,
we’re declaring a new type name. In this case, our data type is called Fruit.
(We’ll talk about why this is Fruit and not fruit in a little bit.)
After the type name, we have an open curly brace, followed by a comma-
separated list of fields. For example, apples: i32 is a field. The field has
a name, a colon, and then a type. This is really similar to what a parameter
list in a function looks like.
Next: how do you use a struct? Here we get to introduce a new kind of
expression: a field access expression. When you have a value of some
struct, you can access it with value.field syntax. Let’s see how we
would implement our count_fruit function, now powered by a struct:

fn count_fruit(fruit: Fruit) {
    println!(
        "I've got {} apples and {} bananas",
        fruit.apples, fruit.bananas
    );
}
Our parameter list now receives a single parameter, named fruit, with type
Fruit. The println! has the same format string as before. But instead of
giving it the parameters apples and bananas, we have to access those
fields 
on 
the fruit 
value. 
So 
we 
use fruit.apples and
fruit.bananas.

I split up this macro call onto multiple lines to make it easier to read. If you use the
rustfmt tool in the Rust Playground, it will do this kind of thing for you automatically.
And finally, we need to know how to call the count_fruit function. And
in order to do so we’ll need to learn one more expression type: a struct
expression. This resembles the struct declaration itself quite closely, and
looks like this:
let fruit = Fruit {
    apples: 10,
    bananas: 5,
};
We give the name of the struct, followed by an opening curly brace,
followed by a comma-separated list of struct field expressions. In the struct

declaration, we used name: type, such as apples: i32. Now that
we’re constructing a value, we instead use name: value, such as
apples: 10.
Finally, calling the count_fruit function looks just like passing in any
other parameter to a function:
count_fruit(fruit);

EXERCISE
Put together all of the snippets in this section to make a working example. Then add a new field
to your Fruit struct. You get to choose which fruit you want to use.
Hint: the let fruit and count_fruit both need to go into the main function.
This certainly solved one of our main problems from before, namely that we
couldn’t tell what the 10 and 5 meant inside the main function. Now that we
have code like apples: 10, it’s much harder to get confused about what’s
going on.

7.3. Call another function
Go ahead and take out the extra fruit field you put into the exercise above,
we’ll go back to just apples and bananas. Now it’s time to define our
price_fruit function. For the moment, comment out the count_fruit
function call in main by putting // in front of it. Then add the following to
main:
let price = price_fruit(fruit);
println!("I can make {} cents", price);

CHALLENGE EXERCISE
We’re about to implement the price_fruit function. Before I show you the solution, can
you define it yourself? Remember, an apples costs 8 cents, and a banana costs 12.
price_fruit is going to take a single Fruit parameter, and return an
i32. The body will look just like our original price_fruit from above,
except now we’ll use field access expressions to get the count of apples and
bananas:
fn price_fruit(fruit: Fruit) -> i32 {
    fruit.apples * 8 + fruit.bananas * 12
}
Make sure this program runs and tells you that you can make 140 cents.
But it was a bit weird that I asked you to comment out the call to
count_fruit, wasn’t it? In fact, you got a warning from the compiler
about how we never used count_fruit. Let’s try and make the compiler
happy. Please uncomment the count_fruit call and try to run the
program. You’re going to get a great error message:
error[E0382]: use of moved value: `fruit`
  --> main.rs:39:29
   |
34 |     let fruit = Fruit {
   |         ----- move occurs because `fruit` has type `Fruit`, 
which does not implement the `Copy` trait
...
38 |     count_fruit(fruit);
   |                 ----- value moved here

39 |     let price = price_fruit(fruit);
   |                             ^^^^^ value used here after move
Wait, what?

7.4. Ownership and moving
It’s time to introduce one of the most core concepts in all of Rust: ownership.
We’ll discuss the motivation for this another time. But every value in Rust
has exactly one owner. For example, in this program:
fn main() {
    let x: i32 = 5;
    println!("{}", x);
}
The x variable points to the value 5, and the value 5 is owned by the main
function. Blocks can also be owners. So for example:
fn main() {
    {
        let x: i32 = 5;
        println!("{}", x);
    }
}
main owns that block, and the block owns the value 5. And values can even
own other values. Our fruit value above owns the 10 and 5 in the apples
and bananas fields.
Remember that you can only have one owner for a value at a time. In our
broken program, we call count_fruit on the value fruit. This causes
the owner of that value to change from the main function to the
count_fruit function. In Rust, we call this moving. In other words, the
value moved from main to count_fruit. That’s fine, and it works great.

The problem is what happens next. When we try to call price_fruit,
we’re giving it a moved value, or a value we don’t own anymore. And we’re
not allowed to give away something we don’t own. And therefore, the
compiler complains about use of moved value.
We’ll get back to solving that in a bit. Let’s take a quick detour and analyze a
question: why haven’t we seen this before?

7.5. Copy values
OK, I get it. A value has an owner, and you can’t use a value after it’s been
moved to a new owner. Awesome. Then why does this code work?
fn count(apples: i32) {
    println!("You have {} apples", apples);
}
fn price(apples: i32) -> i32 {
    apples * 8
}
fn main() {
    let apples: i32 = 10;
    count(apples);
    let price = price(apples);
    println!("The apples are worth {} cents", price);
}
We create the value 10, owned by the main function, and put it in the
apples variable. Then we call count(apples), which moves the value
into the count function. Then we call price(apples), and use the
already moved value apples. This looks just like our previous example
with count_fruit and price_fruit. Why does Rust allow this with
apples and not with fruit?
I want to repeat a part of the error message we saw before:
move occurs because `fruit` has type `Fruit`, which does not 
implement the `Copy` trait

Here come those pesky traits again! Copy is a trait in Rust that says "this
thing is so incredibly cheap to make a copy of, that each time you try to move
it, it’s fine to just make a copy and move that new copy instead." And i32 is
an example of a type which is so cheap. Therefore, in our code here,
count(apples) doesn’t move the value into count. Instead, it makes a
copy of the value 10, and moves that copy into count. But the original 10
inside the apples variable remains unchanged.
By contrast, Fruit does not implement the Copy trait. Rust doesn’t believe
that Fruit is super-cheap to copy. And therefore, it won’t do it for you
automatically.
Well, that detour gave me an idea on how to fix our program.

7.6. Make a copy
One simple way to fix this is to have two separate Fruit values, which have
the exact same data inside. Let’s see what that might look like:
fn main() {
    let fruit1 = Fruit {
        apples: 10,
        bananas: 5,
    };
    count_fruit(fruit1);
    let fruit2 = Fruit {
        apples: 10,
        bananas: 5,
    };
    let price = price_fruit(fruit2);
    println!("I can make {} cents", price);
}
We make a fruit1 variable, and move its value into count_fruit.
Then, we make a brand new fruit2 variable with a brand new value inside
of it, and move that value into price_fruit. No problem!

EXERCISE
Using name shadowing, we don’t actually have to call these fruit1 and fruit2. Change
this code so that both variables are called fruit.
This is not a great solution. We have to type in exactly the same code twice,
which is both boring and likely to result in errors. Additionally, making two
copies of the same data is more expensive for the computer than just one. It’s
not such a big deal for Fruit, because it’s so tiny. But it’s not good
practice, and would make our programs much slower if we always worked
like this.
Let’s see another trick we can use for this.

7.7. Move out!
We moved the Fruit value into the count_fruit function. Let’s move it
back out by using a return type! Up until now, we’ve implicitly been
returning a () unit value. Instead, let’s return the Fruit value itself.

EXERCISE
Modify the count_fruit function so that it returns the same Fruit value it received as a
parameter.
With that modified count_fruit function in place, we can do a really
awkward dance in the main function.
fn main() {
    let fruit = Fruit {
        apples: 10,
        bananas: 5,
    };
    let fruit = count_fruit(fruit);
    let price = price_fruit(fruit);
    println!("I can make {} cents", price);
}
We make our initial fruit variable like normal, using a struct expression.
We call count_fruit(fruit) as before, moving fruit into the
count_fruit function. But then we capture the return value from that
function into a new fruit variable. Once again, main owns the value. Then
we can move that value into price_fruit.
Does this feel a little bit painful? It should, this isn’t good Rust code! But
we’re going to use it for now. In the next lesson, we’ll learn a much better
solution to this problem by using references.

But we still haven’t dealt with increasing the values inside Fruit. We’ll tie
up with that for this lesson.

7.8. Increasing fruit
Our count_fruit function received a Fruit parameter and returned a
Fruit result. And it gave back exactly the same amount. Now we’ll want to
make a new, modified value. First, let’s see what we want our main function
to look like:
fn main() {
    let fruit = Fruit {
        apples: 10,
        bananas: 5,
    };
    let fruit = count_fruit(fruit);
    let fruit = increase_fruit(fruit);
    let price = price_fruit(fruit);
    println!("I can make {} cents for more fruit", price);
}
We’re not going to bother with getting the price for the original, non-
increased fruit amounts, since we’d have to deal with somehow moving the
Fruit value back out of that function. We’ll leave that to an exercise later.
Instead, we just want to focus on the increase_fruit function itself. The
type signature looks simple enough:
fn increase_fruit(fruit: Fruit) -> Fruit {
    unimplemented!()
}
But what should the body look like? One approach would be: we need to
create a new Fruit value, based on the fields in the original Fruit value.

CHALLENGE EXERCISE
Using one struct expression, and two field access expressions, can you implement
increase_fruit?
This solution would look like:
fn increase_fruit(fruit: Fruit) -> Fruit {
    Fruit {
        apples: fruit.apples * 2,
        bananas: fruit.bananas * 3,
    }
}
But there’s another approach we can take. We learned about mutable
variables last time for the purposes of iteration. But we can also use mutation
to change fields within a struct. I’ll get you started:
fn increase_fruit(fruit: Fruit) -> Fruit {
    fruit.apples *= 2;
    fruit // return it from the function
}

EXERCISE
Fix the compiler error from the function above, and fix the implementation so that it tells you
that you can make 340 cents from the increased fruit.
Also: yes, you can put mut there. Cool!

▪
▪
7.9. Upper and lower case
When to use upper vs lower case in Rust is guided by pretty strong
conventions. Convention here means: you’re not forced to do it, but it’s well
accepted that you should follow these rules.
Variable and function names start with a lower case, and if you have
multiple words, you separate them with an under score. For example,
first_name. This is known as "snake case" because it’s kind of like a
snake slithering on the ground.
Types (besides primitives like i32 and str) should start with a capital
letter, and each new word should have another capital letter. For example,
FirstName. This is known as "upper camel case," since it starts with an
upper case, and each new word kind of looks like a camel’s hump.
If you use the wrong capitalization scheme, you’ll get a warning from the
compiler encouraging you to change it.

▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
7.10. Summary
You can create new types with a struct declaration
structs allow you to combine multiple values into a larger value
You can create a new value using a struct expression
You can access the fields of a struct using a field access expression
Every value in Rust has exactly one owner
You can move a value from one owner to another
The compiler will automatically make copies of some "copyable" types,
marked by the Copy trait
You can move values out of a function in its return value
You can mutate fields in a struct as long as the variable holding the
struct is marked mut
It’s really irritating to move values in and out of functions all the time,
there must be a better way!

7.11. Exercises
For these exercises, don’t feel bad about using copy-paste. You’ve already
typed similar enough code plenty of times above.
1. Modify this program to get rid of all let statements. Remember: struct
expressions are just another kind of expression!
struct Fruit {
    apples: i32,
    bananas: i32,
}
fn increase_fruit(fruit: Fruit) -> Fruit {
    let fruit = Fruit {
        apples: fruit.apples * 2,
        bananas: fruit.bananas * 3,
    };
    fruit
}
fn new_fruit() -> Fruit {
    let fruit = Fruit {
        apples: 10,
        bananas: 5,
    };
    fruit
}
fn print_fruit(fruit: Fruit) {
    println!("You have {} apples and {} bananas", 
fruit.apples, fruit.bananas);
}
fn main() {
    let fruit = new_fruit();
    let fruit = increase_fruit(fruit);

    print_fruit(fruit);
}
2. We originally wanted to be able to print the price for both the original
and increased fruit amounts. In order to make that work, we need to be
able to return both the original Fruit value and the price from the
price_fruit function. Fix up the program below to make it work.
The expected output is:
I've got 10 apples and 5 bananas
Original price: 140
I can make 340 cents for more fruit
I’ve added FIXME comments in all places that need to be modified. The
compiler can also be a great help in figuring out how to fix things.
struct Fruit {
    apples: i32,
    bananas: i32,
}
struct FruitAndPrice {
    fruit: Fruit,
    // FIXME
}
fn count_fruit(fruit: Fruit) -> Fruit {
    println!(
        "I've got {} apples and {} bananas",
        fruit.apples, fruit.bananas
    );
    // FIXME
}
fn price_fruit(fruit: Fruit) -> FruitAndPrice {
    let price = fruit.apples * 8 + fruit.bananas * 12;

    // FIXME you need to make a FruitAndPrice value here
}
fn increase_fruit(/* FIXME */ fruit: Fruit) -> Fruit {
    fruit.apples *= 2;
    fruit.bananas *= 3;
    // FIXME
}
fn main() {
    let fruit = Fruit {
        apples: 10,
        bananas: 5,
    };
    let fruit = count_fruit(fruit);
    let fruit_and_price = price_fruit(fruit);
    println!("Original price: {}", fruit_and_price.price);
    let fruit = increase_fruit(fruit_and_price.fruit);
    let fruit_and_price = price_fruit(fruit);
    println!("I can make {} cents for more fruit", 
fruit_and_price.price);
}
3. Modify the solution above to find out what the result would be if we
increased the amount of fruit a second time.
4. Fix the warnings in this code by changing the names around.
struct point {
    X: i32,
    Y: i32,
}
fn PrintPoint(Point: point) {
    println!("x == {}, y == {}", Point.X, Point.Y);
}

fn main() {
    PrintPoint(point { X: 3, Y: -6 });
}

8. REFERENCES
This lesson builds pretty directly on the last lesson. Last time, we spent a lot
of time playing around with ownership and moving. And we found it really
annoying (or, at least, I did) that we had to keep moving values into functions
and then back out. It would be nice to have a better solution for it. And with
that kind of introduction, you better bet that’s what we’re about to learn.

8.1. Borrow
Let’s look at some of that move-in-move-out code we had before:
struct Fruit {
    apples: i32,
    bananas: i32,
}
fn increase_fruit(mut fruit: Fruit) -> Fruit {
    fruit.apples *= 2;
    fruit.bananas *= 3;
    fruit
}
fn print_fruit(fruit: Fruit) -> Fruit {
    println!("You have {} apples and {} bananas", fruit.apples, 
fruit.bananas);
    fruit
}
fn main() {
    let fruit = Fruit {
        apples: 10,
        bananas: 5,
    };
    let fruit = print_fruit(fruit);
    let fruit = increase_fruit(fruit);
    print_fruit(fruit);
}
And in particular, this line really bothers me:
let fruit = print_fruit(fruit);

I don’t want to have to move the value in and back out. Instead, I’d like to be
able to let print_fruit borrow the value I own in main, without moving
it completely. And Rust supports exactly that! Let’s work through changing
the code, and then we’ll explain some details.
First, instead of passing print_fruit the fruit value itself, we need to
pass it a borrowed reference. There’s a new unary operator to learn for this:
&.
㇀
Does that look familiar with &str? It should. We’ll touch on that similarity in an
upcoming lesson.
OK, so instead of print_fruit(fruit), change the code above to
print_fruit(&fruit). This isn’t going to work though. We get the
error message:
error[E0308]: mismatched types
  --> main.rs:24:29
   |
24 |     let fruit = print_fruit(&fruit);
   |                             ^^^^^^
   |                             |
   |                             expected struct `Fruit`, found 
&Fruit
   |                             help: consider removing the 
borrow: `fruit`
   |
   = note: expected type `Fruit`
              found type `&Fruit`

▪
▪
In this case, Rust’s help message is not correct. Even the compiler
eventually runs out of mind-reading abilities!
Anyway, this is a type mismatch. It turns out that when you borrow a value of
type Fruit, you don’t get back a Fruit. Instead, you get a &Fruit. That
& at the beginning of the type means "a reference to." In other words, & has
two different but related meanings:
When on a value: borrow a reference to this value
When on a type: a reference to this type
Anyway, the help message from the compiler recommends changing how
we call print_fruit. But in fact, we want to change print_fruit
itself instead. Right now, the type of the parameter to print_fruit is
Fruit. This requires that the value be moved into print_fruit. Instead,
let’s change that so that it’s a reference to a Fruit, or &Fruit:
fn print_fruit(fruit: &Fruit) -> Fruit
This generates two error messages. The second one is easier to deal with: it’s
complaining that our second print_fruit call has the wrong type. Go
ahead and borrow a reference in the second call as well. Then we’re left with
just one error message:
error[E0308]: mismatched types
  --> main.rs:15:5
   |
13 | fn print_fruit(fruit: &Fruit) -> Fruit {
   |                                  ----- expected `Fruit` 
because of return type

▪
▪
14 |     println!("You have {} apples and {} bananas", 
fruit.apples, fruit.bananas);
15 |     fruit
   |     ^^^^^ expected struct `Fruit`, found &Fruit
   |
   = note: expected type `Fruit`
              found type `&Fruit`
print_fruit is supposed to return a Fruit. However, we end up
returning the value fruit, which has the type &Fruit instead. There are
two semi-obvious solutions to this:
Construct a new Fruit value at the end of print_fruit and return
that new value
Modify the return value from Fruit to &Fruit
However, neither of these is the solution we want. The only reason we were
returning a Fruit in the first place was to deal with moving and ownership.
But we don’t actually need that anymore! So instead, let’s get rid of the
return value entirely:
fn print_fruit(fruit: &Fruit) {
    println!("You have {} apples and {} bananas", fruit.apples, 
fruit.bananas);
}
This generates just one final error message:
error[E0308]: mismatched types
  --> main.rs:24:32
   |
24 |     let fruit = increase_fruit(fruit);
   |                                ^^^^^ expected struct `Fruit`, 

found ()
   |
   = note: expected type `Fruit`
              found type `()`
And that’s because on the previous line, we capture the result of
print_fruit 
into 
the fruit variable. But now, the result of
print_fruit is (), not Fruit! To fix that, we replace:
let fruit = print_fruit(&fruit);
With:
print_fruit(&fruit);
And just like that, our code works again! Not only that, but I’d argue that the
code is much better than before. All of that weird noise about moving the
Fruit values around is gone, at least from the usages of print_fruit.
But increase_fruit is still annoying.

8.2. Mutable references
We want to be able to modify the fruit using the increase_fruit
function. To make this work, we need to introduce a second kind of
reference: a mutable reference. While an immutable reference is &, a mutable
reference is &mut. It looks like:
fn increase_fruit(fruit: &mut Fruit) {
    fruit.apples *= 2;
    fruit.bananas *= 3;
}
Note that we put the mut after the & symbol, not before the fruit
parameter name. We’ll give a little more explanation on this in the next
section.
We’re almost out of the woods. At this point, the compiler tells us:
error[E0308]: mismatched types
  --> main.rs:22:20
   |
22 |     increase_fruit(&fruit);
   |                    ^^^^^^ types differ in mutability
   |
   = note: expected type `&mut Fruit`
              found type `&Fruit`
It turns out that &Fruit and &mut Fruit are really different types. And
therefore, we need a different operator to borrow a mutable reference than an
immutable reference. And this operator is &mut. So we rewrite our function
call from our original:

let fruit = increase_fruit(fruit);
To our new mutable-reference-powered:
increase_fruit(&mut fruit);
This gives us one final error message to deal with:
error[E0596]: cannot borrow `fruit` as mutable, as it is not 
declared as mutable
  --> main.rs:22:20
   |
16 |     let fruit = Fruit {
   |         ----- help: consider changing this to be mutable: 
`mut fruit`
...
22 |     increase_fruit(&mut fruit);
   |                    ^^^^^^^^^^ cannot borrow as mutable
You’re not allowed to borrow a mutable reference to an immutable variable.
If you could do that, you’d be able to cheat the compiler and change things
that you’re not supposed to be able to. The fix is easy: stick a mut in front of
the original fruit variable name.
With that in place, our program finally compiles and runs. And now all of the
insanity around moving in and out is completely gone. Hurrah!

EXERCISE
Add back the price_fruit function we worked on in the last lesson, and call it from main.
You’ll want to modify it to work with references now.

▪
▪
▪
▪
8.3. What’s in a reference?
Every value in Rust lives somewhere in your computer’s memory. And every
place in computer memory has an address. It’s possible to use println and
the special {:p} syntax to the address itself:
fn main() {
    let x: i32 = 5;
    println!("x == {}, located at {:p}", x, &x);
}
On 
my 
computer, 
this 
prints x 
== 
5, 
located 
at
0x7ffeeb9b68f4. A reference can be thought of as a pointer: it’s an
address pointing at a value that lives somewhere else. That’s also why we use
the letter p in the format string to print the address.
When you have a variable like let y: &i32 = &x, what this means is:
y is an immutable variable
That variable holds an address
That address points to an i32
The reference is immutable, so we can’t change the value of the i32
On the other hand, let y: &mut i32 = &mut x is almost exactly the
same thing, except for the last point. Since the reference is mutable, we can
change the i32 value.

▪
▪
▪
▪
▪
▪
It’s technically possible to do things like let mut y: &i32 = &x. But
what this would mean is that you can change the address that’s in y, not the
value the address points to. There may be some cases where that’s useful, and
the language allows it. But for the most part, you just don’t want to do it. In
practice in Rust, therefore, you’ll usually end up with one of four variable
types:
An immutable variable holding a value directly, e.g. let fruit:
Fruit = Fruit { …  };
A mutable variable holding a value directly, e.g. let mut fruit:
Fruit = Fruit { …  };
An immutable variable holding an immutable reference, e.g. let
fruit_ref: &Fruit = &fruit;
An immutable variable holding a mutable reference, e.g. let
fruit_ref: &mut Fruit = &mut fruit;
The other two possibilities, which we almost never want, are:
A mutable variable holding an immutable reference, e.g. let mut
fruit_ref: &Fruit = &fruit;
A mutable variable holding a mutable reference, e.g. let mut
fruit_ref: &mut Fruit = &mut fruit;
In other words, don’t make variables mutable when they’re holding
references.

8.4. Deref
Alright, I’m tired of fruit. Let’s talk about plain old numbers again. Consider
this program, which only uses mutable variables, no references:
fn main() {
    let x: i32 = 5;
    let mut y: i32 = 6;
    y -= 1;
    assert_eq!(x, y);
    println!("Success");
}
What this means is: create a new immutable variable x holding 5. Then create
a mutable variable y holding 6. Subtract 1 from y. And then make sure x and
y are the same. Hurrah.
But modifying values directly is so two lessons ago. I want to use my cool
new mutable references! Let’s add in a new mutable reference z, and try to
use it:
fn main() {
    let x: i32 = 5;
    let mut y: i32 = 6;
    let z: &mut i32 = &mut y;
    z -= 1;
    assert_eq!(x, y);
    println!("Success");
}
This doesn’t work:

error[E0368]: binary assignment operation `-=` cannot be applied 
to type `&mut i32`
 --> main.rs:6:5
  |
6 |     z -= 1;
  |     -^^^^^
  |     |
  |     cannot use `-=` on type `&mut i32`
  |
help: `-=` can be used on 'i32', you can dereference `z`
  |
6 |     *z -= 1;
  |     ^^
The problem is that we’re trying to use the -= operator on a &mut i32
value. And remember that the reference is really just an address, not an i32.
We don’t want to subtract 1 from an address. We want to subtract 1 from the
value behind the reference. Rust provides another unary operator to talk
about the thing behind a reference. It’s called the deref— short for dereference
— operator, and is *. And in fact, if you look at the help message above, the
compiler told us how to fix this already!

EXERCISE
Fix the program above by using the dereference operator.

8.5. Lifetimes of references
There’s an important restriction on references, both mutable and immutable:
they cannot live longer than the values they are referencing. Let’s see an
example:
fn main() {
    let x: &i32 = {
        let y = 5;
        &y
    };
    println!("x == {}", x);
}
This program defines a new variable y inside a block. That block then returns
a reference to y. This program fails to compile:
error[E0597]: `y` does not live long enough
 --> main.rs:4:9
  |
2 |     let x: &i32 = {
  |         - borrow later stored here
3 |         let y = 5;
4 |         &y
  |         ^^ borrowed value does not live long enough
5 |     };
  |     - `y` dropped here while still borrowed
The problem here is that y is dropped as soon as the block finishes. The
block itself was the owner for y. And when an owner goes away, the value is
dropped, and cannot be used anymore. However, we return a reference to y,

which would allow us to keep using y after it’s gone. That would be really
dangerous, and so Rust doesn’t let that happen.
All values and references in Rust have a lifetime. We’re usually able to move
about our normal business without talking about the lifetimes explicitly.
That’s due to a fancy-sounding thing called lifetime elision. This just means
that, when Rust is able to figure out the lifetime of the values, it will. We’ll
see some cases in the future where we need to give our lifetime parameters
explicitly. For now, if you see 'a or '_ in your error messages, you’ll know
it’s talking about a lifetime.

8.6. Mutating and borrowing
A lot of problems in software come about from things changing when you
don’t expect them to. That’s why Rust defaults to having immutable
variables: it’s easier to think about things when they can’t change. That’s a
pretty big deal in Rust. It means that if I have an immutable value, and I print
it twice, I know it will give me the same value. This applies to immutable
references too.
fn main() {
    let x = 5;
    let y = &x;
    println!("x == {}, y == {}", x, y);
    // I can do anything I want here...
    // And then this will produce the same output
    println!("x == {}, y == {}", x, y);
}
But now, let’s tweak the example above just a bit. Instead of let x = 5,
we’ll have let mut x = 5. Is that allowed? Certainly! You’ll get a
warning about the unneeded mut, but just ignore that for now.
Now, in the "I can do anything I want here" bit, let’s change x to be 10 with a
simple:
x = 10;

Now we’re in trouble. It’s OK that the value in x changed in our program: we
marked it as being mutable. But y looks totally immutable. And now it’s
going to produce a different output. That’s no good!
Fortunately, this program doesn’t actually compile. We get the error message:
error[E0506]: cannot assign to `x` because it is borrowed
  --> main.rs:7:5
   |
3  |     let y = &x;
   |             -- borrow of `x` occurs here
...
7  |     x = 10;
   |     ^^^^^^ assignment to borrowed `x` occurs here
...
10 |     println!("x == {}, y == {}", x, y);
   |                                     - borrow later used here
This is a new rule about references: as long as a value is borrowed, it can’t be
mutated.

EXERCISE
Figure out where in your program you can use the line x = 10. There are two places I can
think of, though one of them will give you a warning. The two places will end up giving you
different output.

8.7. Multiple references
You’re allowed to have lots of immutable references to a value. And you can
create these references either by borrowing from the same value multiple
times, or by copying an existing reference. Let’s see this in action.
fn main() {
    let a: i32 = 5;
    // borrow
    let b: &i32 = &a;
    // borrow again
    let c: &i32 = &a;
    // copy an existing reference
    let d: &i32 = c;
    // copy a copy of the reference
    let e: &i32 = d;
    println!("{} {} {} {} {}", a, b, c, d, e);
}
㇀
If you remember our discussion of the Copy trait when discussing ownership, this means
that references are copyable.

EXERCISE
Write a function add that takes two &i32 parameters and adds them together, and a function
double that takes an i32 and uses add on the same value. You can use this to get started:
fn add(/* FIXME */) -> i32 {
    x + y
}
fn double(x: i32) -> i32 {
    unimplemented!()
}
fn main() {
    assert_eq!(double(5), 10);
    println!("Success!");
}

8.8. Single mutable reference
Rust is really picky about all this mutation stuff. We already mentioned that
you can’t mutate a value that’s borrowed. This same basic logic extends to
mutable references. If you have a mutable reference to a value, you can’t
mutate or read that value anywhere else in your program. We call this
freezing. To demonstrate: this program is fine:
fn main() {
    let mut x = 5;
    let y = &mut x; // freeze
    *y *= 2; // unfreeze
    println!("x == {}", x);
}
The reason: we create y as a mutable reference, use it, and then it disappears.
That’s because after the *y *= 2, the y variable is never used referenced
again. That mutable borrow disappears, x is unfrozen, and we’re allowed to
use x directly.
However, this program fails to compile:
fn main() {
    let mut x = 5;
    let y = &mut x; // freeze
    x *= 2;
    *y *= 2; // unfreeze
    println!("x == {}", x);
}

The error says "cannot use x because it was mutably borrowed." We can’t
even do this:
fn main() {
    let mut x = 5;
    let y = &mut x; // freeze
    println!("x == {}", x);
    *y *= 2; // unfreeze
    println!("x == {}", x);
}
And we can’t do this:
fn main() {
    let mut x = 5;
    let y = &mut x; // freeze
    let z = &x;
    *y *= 2; // unfreeze
    println!("x == {}", x);
}
We’ll summarize all of these rules about references in the summary.

8.9. Mutable to immutable
Does the following program compile?
fn printme(x: &i32) {
    println!("{}", x);
}
fn main() {
    printme(&5);
}
It sure does: we only read from the immutable reference x, and therefore
everything is fine. How about this program?
fn printme(x: &mut i32) {
    println!("{}", x);
}
fn main() {
    printme(&mut 5);
}
Yes, this is fine as well. We have a mutable reference x, which allows both
reading and writing values. Even though using the println! macro only
uses the read capability here, the code is completely valid.
㇀
When we used mutable owned values, e.g. mut x: i32, the compiler was able to warn
us about the unnecessary mut. For reasons I don’t fully understand myself, the compiler
doesn’t warn about overly mutable references in the same way.

OK, one more:
fn printme(x: &mut i32) {
    println!("{}", x);
}
fn main() {
    printme(&5);
}
This program doesn’t compile due to a type mismatch. Our printme
function needs a mutable reference, but in main we borrow an immutable
reference. That’s no good! And one final example:
fn printme(x: &i32) {
    println!("{}", x);
}
fn main() {
    printme(&mut 5);
}
This looks like the same problem as above. But if you run this program,
you’ll find that it works. Why is that? It’s because Rust can automatically
convert any mutable reference to an immutable reference. The reason is that
mutable references are simply immutable references with more power.
Immutable references can only read, while mutable can read and write. By
converting to an immutable reference, the compiler is simply stripping away
the power to write/mutate the data.

▪
▪
▪
▪
▪
▪
▪
▪
▪
◦
◦
◦
▪
▪
8.10. Summary
You are allowed to borrow references to values
Borrowing a reference does not move ownership
Borrowing is the preferred way to solve the "move in move out" problem
we encountered previously
References have their own type, and i32 is different than &i32
We also have mutable references such as &mut i32, which allow the
values behind the reference to be changed
Mutable references can only be borrowed from mutable values
References are essentially addresses for where the original value lives in
memory
If you want to operate directly on the value behind a reference, you can
dereference using the * operator
A reference cannot outlive the value it refers to
To avoid insanity around mutation and references, Rust has some rules you
need to abide by
You cannot mutate a value if there is a reference to it
You can have multiple immutable references to a value
You can only have one mutable reference to a value, and then no other
immutable references to it, or access the value directly
You can create an immutable reference from a mutable reference, but not

the other way around.

8.11. Exercises
1. The is_five function below has a bug. You can fix it by either adding
in a borrow (&) or deref (*). Try fixing it both ways.
fn is_five(x: &i32) -> bool {
    x == 5
}
fn main() {
    assert!(is_five(&5));
    assert!(!is_five(&6));
    println!("Success!");
}
2. Fix the call to the add function inside main below.
fn add(x: &i32, y: &i32) -> i32 {
    x + y
}
fn main() {
    let result = add(5, 6);
    assert_eq!(result, 11);
    println!("Success!");
}
3. The program below compiles (with warnings), but panics because the
assertion fails. Modify both the triple function and the call to
triple in main so that the warnings go away and the program prints
"Success".
fn triple(mut x: i32) {

    x *= 3;
}
fn main() {
    let mut x = 5;
    triple(x);
    assert_eq!(x, 15);
    println!("Success!");
}
4. Fix the program below. Ideally, figure out what the problem is before
asking the compiler what the problem is.
fn main() {
    let mut x: i32 = 5;
    let y: &mut i32 = &mut x;
    y += 1;
    assert_eq!(x, 6);
    println!("Success!");
}
5. Write a modified sum function that takes a mutable reference for the
destination of the sum from low to high. You can test it with this main
function:
fn main() {
    let mut total = 0;
    sum(&mut total, 1, 10);
    assert_eq!(total, 55);
    let mut total = 10;
    sum(&mut total, 1, 10);
    assert_eq!(total, 65);
    println!("Success!");

}
6. The following program won’t compile due to a borrow error. Try to
figure out what the error is before asking the compiler. Then fix the error
by rearranging two statements.
fn main() {
    let mut x: i32 = 5;
    let y: &mut i32 = &mut x;
    *y += 1;
    assert_eq!(x, 6);
    assert_eq!(y, &6);
    println!("Success!");
}
7. Let’s write a program that calculates the average of a series of values you
provide it. The expected output is:
I don't have any values yet!
4
6
Complete the program below to make it generate that output.
struct RunningTotal {
    total: i32,
    count: i32,
}
fn new_running_total() -> RunningTotal {
    // FIXME
}
fn print_average(rt: &RunningTotal) {

    // FIXME
}
fn add_value(rt: /* FIXME */ RunningTotal, value: i32) {
    rt.total += value;
    rt.count += 1;
}
fn main() {
    let mut rt = new_running_total();
    print_average(/* FIXME, and below */ rt);
    add_value(rt, 5);
    add_value(rt, 3);
    print_average(rt);
    add_value(rt, 10);
    print_average(rt);
}

▪
▪
▪
9. METHODS
In the last two lessons, we’ve learned three fundamental concepts in Rust:
How to create our own data types using struct
How ownership and moving works
How to use references and mutable references
So far, we’ve demonstrated these concepts using functions. We pass
ownership of a value from one function to another. Or we borrow a reference
and pass that reference into a function.
There’s another concept in Rust which is very close to functions, called
methods. We’re going to introduce methods now. We’ll see that they can
sometimes be nicer to use than functions.

▪
▪
9.1. Hello method calls!
When we’ve learned about functions, we had two sides to the coin:
How do you call a function
How do you define or implement a function
We have the same two sides in Rust. We’ll first demonstrate what a method
call looks like, using some methods on types you’re already familiar with.
How long is the string "Hello"? You can count the letters and tell me 5.
But programmers are lazy! Why should we do work when the computer can
do it instead? You might imagine that we’d have a length or len function.
But it turns out we don’t. Instead, we have a len method:
fn main() {
    let hello = "Hello";
    let len = hello.len();
    println!("The string {} has length {}", hello, len);
}
A method call is another kind of expression, and looks very similar to a
function call. However, a method call works on a specific value, known as
the self. You’ll see how that works below. Here, we’re calling the len
method 
on 
the hello value. All method calls look like this:
value.method_name(parameter, list). This is very similar to
field access expressions, except its name is followed by parentheses and a
parameter list.

EXERCISE
Rewrite the example above to not create the variable len. Instead, call the method inside the
println! macro call. This works because a method call is an expression, just like so many
other things we’ve seen.
Methods aren’t limited to strings. The i32 we’ve been using so far has many
different methods, such as abs, which returns the absolute value of the
number:
㇀
For those not familiar, an absolute value means "the absolute distance from 0." Or said
more easily: it’s the number without a negative on it. So the absolute value of 2 is 2, and
the absolute value of -3 is 3.
fn main() {
    let x: i32 = -5;
    let y = x.abs();
    println!("Absolute value of {} is {}", x, y);
}
And we’re not limited to method calls on variables. You can use a method
call on any expression, including a literal. For example:
fn main() {
    println!("Hello is {} letters", "Hello".len());
}

So why is it better to make an abs or a len method than a function? There
are multiple advantages, which we’ll explore throughout this lesson. The first
one to introduce is name reuse. Let’s take that abs method. It makes sense to
take the absolute value of any signed integer, including i8, i16, i32, and
i64. If we defined abs as a function, then those names would conflict with
each other. We’d have to do something like calling them abs_i8,
abs_i16, etc. That’s just annoying. With methods, you can use the same
method name on multiple different types.

9.2. Type inference
When we use a let to declare a new variable, we can optionally give it a
type. In other words, both of the lets below are valid Rust:
fn main() {
    let x: i32 = 5;
    let x = 5;
    println!("x == {}", x);
}
We call the : i32 a type annotation, and so far it’s been entirely optional.
The reason is that Rust does something called type inference: it infers, or
figures out, the type for any expression. This is pretty easy with, for example,
a string literal or a boolean literal. They must be of type &str or bool,
respectively.
However, now that we’ve learned about methods, we’re ready to watch type
inference fail us for the first time. We saw the abs method above on an i32.
And we use let x: i32 = 5;. However, let’s try leaving off the type
annotation and see what happens:
fn main() {
    let x = 5;
    println!("x == {}", x.abs());
}
We get a new and mysterious error message:

error[E0599]: no method named `abs` found for type `{integer}` in 
the current scope
What is this {integer} thing?!? It turns out that the 5 literal can be lots of
different types. It could be an i32, or a u32, or an i64, or a number of
others. The compiler can’t be certain. In some cases, like 5 + 3, the
compiler will fall back to i32 if it’s not sure which specific integer type to
use.
However, in some other cases, it won’t do this fallback. Instead, it complains
loudly that it doesn’t really know which type you’re using, and it can’t be
sure that the specific type you’re using has a method named abs.
One way to solve this is to add the type annotations back. But there’s a
special integer literal syntax which can be convenient in some cases:
fn main() {
    let x = 5i32;
    println!("x == {}", x.abs());
}
That’s right, you can just stick the integer type right after the literal value.

EXERCISE
Change the code above so that x is a 64-bit signed integer. Then try an unsigned integer and see
what happens. Why do you think that one doesn’t compile?
Why would you want to do this instead of a type annotation? One great
reason is that you can use this to bypass a let declaration.

EXERCISE
Rewrite the program above to not use any lets, but still call the abs method on a 32-bit,
signed value.

9.3. Side note: underscores in numbers
This is just a little readability hack in Rust. Quick, tell me if 80000000 is
eighty million, eight million, or eight hundred million. It’s hard, isn’t it? How
about 80,000,000? Much easier. Separating numbers up like that is a great
usability improvement. Rust allows you to do this, except you have to use an
underscore instead of a comma. For example:
fn main() {
    let x = 80_000_000;
    let y = 5_000_000;
    println!("{}", x - y);
}
Why am I mentioning this now? Some people find it easier to separate the
type at the end of a number with an underscore. For example, instead of
5i32 they’ll use 5_i32. That’s the style we’ll be using going forward.

EXERCISE
Add an underscore into one of the examples above that used 5i32.

▪
▪
▪
9.4. Negative numbers are annoying
What’s the absolute value of -5? The answer is 5. So Rust should say the
same thing, right? Let’s find out!
fn main() {
    println!("x == {}", -5_i32.abs());
}
If you’re expecting the output of this program to be x == 5, you’re in for a
surprise. Instead, the answer is the exact opposite of what we hoped for: x
== -5. Can you see why?
The problem is that the negative sign applies after the method call. In other
words, Rust is looking at our program like this:
5_i32 is an integer literal
Take the absolute value of that, and get 5
Now apply the negative sign to make a -5
One way to fix this would be to put the -5 inside a variable using let. But
another way is to using parentheses to wrap up the literal.

EXERCISE
Add open and close parentheses to make the output of the program above be x == 5.

▪
▪
▪
9.5. Hello method implementations!
OK, back to methods! Implementing methods is very similar to implementing
functions. There are three main differences:
You can only implement methods for types you’ve created yourself
It must appear inside an impl block
The first parameter must be self, or something like self
Let’s see an example and explain it. We’ll go back to our old favorite data
type, Fruit:
struct Fruit {
    apples: i32,
    bananas: i32,
}
impl Fruit {
    fn price(self) -> i32 {
        self.apples * 8 + self.bananas * 12
    }
}
fn new_fruit() -> Fruit {
    Fruit { apples: 10, bananas: 5 }
}
fn main() {
    let fruit = new_fruit();
    let price = fruit.price();
    println!("Price is {}", price);
}

The first new thing is impl Fruit. An impl block means "I’m about to
implement things specific to this type." Inside, you can define any methods
you want.
Inside the impl block, we have what looks like almost a normal function.
The only difference is that the first parameter is self. This is a special
parameter, and it means "hey, I’m defining a method, and the first thing must
have the type of whatever impl block I’m in the middle of." In other words,
inside impl Fruit, a parameter of self means "give me a Fruit."
The rest of the code should look familiar, make sure you’re comfortable with
what you’re seeing.

9.6. Methods by reference
Unfortunately, this price method isn’t great. If you remember from the last
two lessons, we ran into problems when we moved the Fruit value into the
price_fruit function. When you have a parameter named self, it
means "move it into this method." Fortunately, methods work with references
as well.

▪
▪
EXERCISE
Change self to &self and make sure your program still compiles and works.
The fact that changing self to &self works is actually a bit strange. When
we changed price_fruit to take a reference, we had to make two
changes at once:
Change the definition of price_fruit
At the call sites for price_fruit, borrow a reference to fruit instead
of passing in fruit itself
However, we didn’t need to use the borrow operator in the
fruit.price() method call at all. This brings us to our second advantage
with methods: method calls in many cases will automatically borrow a
reference when you need it. This can make it much more convenient to work
with such code.
And as you may have guessed, if you want a mutable reference, you can use
&mut self.

EXERCISE
Implement and call an increase method on the Fruit type, which will double the number
of apples and triple the number of bananas.

9.7. Static methods
It’s great that we can move our price and increase functionality from
standalone functions into the Fruit type itself. Like I mentioned above, this
means we’re not cluttering up everything with extra function names.
However, we still have one annoying function just sitting around:
new_fruit. It would be repetitive to have a new_fruit, new_book,
new_missiles, etc set of functions all over the place.
There’s another concept inside an impl block which will help with this:
static methods. A static method is a method that doesn’t take a self as the
first parameter. So, for example, we can change new_fruit into a new
static method with the code:
impl Fruit {
    fn new() -> Fruit {
        Fruit { apples: 10, bananas: 5 }
    }
}
The only question then is: how do you call this method? We use a special
operator, ::, to say "get the static method inside of this type." In other
words, instead of calling new_fruit(), we call Fruit::new().

EXERCISE
Rewrite the Fruit code to use a new static method and make sure it compiles and runs
correctly.
Static methods aren’t quite as useful as normal methods, but they are a nice
thing to use. More importantly, they are used a lot in common Rust libraries,
so you’ll need to be familiar with them!

EXERCISE
Rewrite the average value program from the previous lesson to use methods for
new_running_total, print_average, and add_value. Here’s my solution to that
exercise:
struct RunningTotal {
    total: i32,
    count: i32,
}
fn new_running_total() -> RunningTotal {
    RunningTotal {
        total: 0,
        count: 0,
    }
}
fn print_average(rt: &RunningTotal) {
    if rt.count == 0 {
        println!("I don't have any values yet!");
    } else {
        println!("{}", rt.total / rt.count);
    }
}
fn add_value(rt: &mut RunningTotal, value: i32) {
    rt.total += value;
    rt.count += 1;
}
fn main() {
    let mut rt = new_running_total();
    print_average(&rt);
    add_value(&mut rt, 5);
    add_value(&mut rt, 3);

    print_average(&rt);
    add_value(&mut rt, 10);
    print_average(&rt);
}

9.8. The Self type
This is a minor point for now. Let’s look at our new static method again:
impl Fruit {
    fn new() -> Fruit {
        Fruit { apples: 10, bananas: 5 }
    }
}
We had to mention the type Fruit three times: in the impl block itself, the
return type from new(), and in the struct expression that creates the Fruit
value. When you get to large type names, it can be irritating to have to repeat
the type name. So within an impl block, you can use the special type name
Self to refer to the type being implement right now. In other words, this is
also valid Rust, and means exactly the same thing as the previous code:
impl Fruit {
    fn new() -> Self {
        Self { apples: 10, bananas: 5 }
    }
}
In practice, it’s pretty unusual to use Self in a struct expression, but pretty
common to use it for return types like this. Why is that? Mostly common
practice.
This bit about Self is only a convenience when dealing with normal
methods. But in the next lesson, when we finally discuss traits, Self will be
far more important.

9.9. Method call chaining
Two lessons ago, we had an exercise to rewrite this main function to not use
any let statements:
fn main() {
    let fruit = new_fruit();
    let fruit = increase_fruit(fruit);
    print_fruit(fruit);
}
The solution to this exercise is:
fn main() {
    print_fruit(increase_fruit(new_fruit()));
}
Lots of people consider this kind of code backwards or inside out. We want
to create a new Fruit value, then increase the value, then print it. However,
the code reads backwards: the first thing you see is printing, then increasing,
then creating. However, with methods and a technique known as method
chaining, we can fix that.
First, we’ll need to rewrite the function calls as method calls. As a challenge
exercise, jump back to that exercise and rewrite the code yourself. I’ll
demonstrate the solution here:
struct Fruit {
    apples: i32,
    bananas: i32,
}

▪
▪
impl Fruit {
    fn new() -> Fruit {
        Fruit {
            apples: 10,
            bananas: 5,
        }
    }
    fn increase(mut self) -> Self {
        self.apples *= 2;
        self.bananas *= 3;
        self
    }
    fn print(&self) {
        println!("You have {} apples and {} bananas", self.apples, 
self.bananas);
    }
}
With that in place, our main function becomes:
fn main() {
    Fruit::new().increase().print();
}
Between the shorter method names and the left-to-right reading, I personally
think this code is much easier to read. Note also a few interesting things
about the implementation above:
It’s fine to use mut self and then mutate a moved value.
The move-in-move-out approach feels more natural with method calls than
it did with function calls.

▪
▪
▪
▪
▪
▪
▪
▪
▪
9.10. Summary
Method calls are another type of expression, very similar to function and
macro calls
Sometimes in Rust, such as with method calls, we have to help the
compiler know exactly which type we’re using
We can be explicit about which integral type we want by putting the type
at the end of the number, e.g. 5_i32
We can stick underscores anywhere in a number literal we want, e.g.
80_000_000_u64
The negative sign operator will be applied after method calls in general,
but you can use parentheses to change the order in which it’s applied, e.g.
(-5_i32).abs()
The first parameter in a method declaration must be self, &self, or
&mut self
You can have static methods inside an impl block, called by
TypeName::method_name
You can use the special type Self inside an impl block
You can chain method calls together to build up more complex expressions

9.11. Exercises
1. Use the len method on a string literal to compute the combined length
of the two strings "Hello" and "World". Bonus points if you do it
without any helper variables.
2. Th e pow method lets you raise a number to a certain power. For
example, 2_i32.pow(2) will compute two squared. What is five
squared plus three cubed equal to?

10. STRINGS
The very first program we wrote, "Hello World!", included strings. So it’s a
bit weird that this lesson is claiming to cover strings again. However, we’ve
only covered the very basics of strings as string literals so far. Now that we
know about ownership and references, it’s time to go into much more depth.
To motivate that idea: the type of a number literal is i32. The type of a
boolean literal is bool. But the type of a string literal is &str. Now that we
know about references, we can ask an important question: why do string
literals need to be a reference when number and boolean literals don’t?
A little bit of backstory before we dive in. (No pun intended.)

10.1. Bits, bytes, and memory
A bit is the most basic unit on a computer, and is either 0 or 1. When we put
8 bits together, we get a byte. We’ve used i32s a lot. Those take up 32 bits
in memory, or 32 / 8 = 4 → 4 bytes.
For the moment, we’re going to assume that a single character, like the letter
H in "Hello", takes up 1 byte. The story is a bit more complicated, but this
will do for the moment.
In the lesson on references, we mentioned that references hold addresses.
Below, it’s going to be important to know how much memory an address
takes up. It turns out that this depends on the machine we’re on. A 32-bit
machine uses 32-bit addresses, and a 64-bit machine uses 64-bit addresses.
The important thing is that, when compiling your program, the compiler
knows which machine it’s compiling for, and knows the size of the addresses.
For our purposes in this lesson, we’re going to pretend like addresses are
always 64 bits, or 8 bytes.
Every piece of data we work with in our program has to be somewhere in
memory. We’ve just kind of treated let x = 5 as meaning "x has 5
somewhere." For this lesson, it will be important to think about where.
OK, with that backstory, we can dive into what makes strings special.

10.2. Dynamically Sized Types
When you create a new value in Rust, it lives in a part of memory called the
stack. It’s called a stack because it gets built up from bottom to top, like a
stack of boxes. And like a stack of boxes, it’s easy to add things on top, and
take things off the top. The stack turns out to be a great place to store a lot of
data in Rust.
However, there’s a limitation with Rust’s stack. Each one of those boxes has
to be a statically sized type. That means the compiler needs to know exactly
how much memory the value is going to take based only on its type.
Let’s take an example. The value 5_i32 is a 32-bit signed integer. That
means it takes up exactly 4 bytes. So Rust can store that on the stack.
Let’s take another example. Consider our beloved Fruit type:
struct Fruit {
    apples: i32,
    bananas: i32,
}
The apples and bananas fields each take up 4 bytes, for a total of 8
bytes.
And let’s take one final example: the value let y: &i32 = &x. The
reference holds an address, which is 64 bits, or 8 bytes.

In these examples, we can look at just the type of the value, and know exactly
how much stack space to set aside for it.
Now let’s take a string literal, "Hello". We can read the word, count the
letters, and figure out that it will take up 5 bytes. Then we can look at the
string literal "Michael" and figure out that it will take up 7 bytes. The
problem is that both of these have the same type, str. Therefore, it’s
impossible to know, from just looking at the type, how much space to set
aside on the stack.
This is what we call a dynamically sized type, or DST. DSTs have a few
restrictions, but the big one is: they can’t be stored on the stack. However,
since a reference takes up a fixed amount of space, a reference to an str can
live on the stack. Which is why string literals end up being &strs instead of
strs.
But that still leaves us with one question: if they don’t live on the stack,
where exactly do string literals live?

10.3. Program memory
I’ve talked about the compiler a lot. So far, your interaction with it has been
that, each time you hit "run" in the Rust Playground, the compiler checks to
make sure your code is correct. And if your code is wrong, it yells at you.
However, I haven’t told you much about what happens if your code is
correct. The compiler will turn your correct code into an executable. The
executable contains a list of instructions to your computer, like "add these
two numbers" and "check if this number is bigger than this number." This
executable can be run, which will load all of those instructions into memory
and start executing them.
But there’s more to your executable than just instructions. Your executable
can also have additional data included. And that’s where your string literals
live: in program memory itself! Then, the compiler creates a reference to that
piece of memory, and that’s what ends up living on the stack, inside the
&str values.
A str is known more formally as a string slice. And a &str is technically a
reference to a string slice. Though Rustaceans will often be sloppy with both
of these terms, and refer to &str as "string slices" or even just "strings."

10.4. Lifetimes of string literals
When we covered references, we mentioned the idea of a lifetime of a
reference, and that a reference could not outlive the data it was borrowing.
There’s something cool about string literals. Since the data they reference is
part of the program itself, we know that a reference to them will be valid as
long as the program is running. Therefore, we give these things a special
lifetime, called 'static. Lifetimes are usually optional, but we’re free to
add them in if desired:
fn main() {
    let name: &'static str = "Michael";
    println!("Name is {}", name);
}
One place that lifetimes are not optional is in the fields of a struct. We may
want to create a struct to represent a person like this:
struct Person {
    name: &str,
    age: i32,
}
fn main() {
    let michael = Person {
        name: "Michael",
        age: 35,
    };
    println!("{} is {} years old", michael.name, michael.age);
}
However, the compiler will reject this:

error[E0106]: missing lifetime specifier
 --> main.rs:2:11
  |
2 |     name: &str,
  |           ^ expected lifetime parameter
Now that we know the lifetime of a string literal, you can fix this program.

EXERCISE
Add in the 'static lifetime parameter to make the program above compile.

10.5. Owned strings
There’s a big restriction on program memory versus stack: once the compiler
creates your executable, the program memory is frozen. When your
executable is running, it cannot change data in program memory, or add new
things there.
Let’s give a simple program we’d like to make work somehow. I’d like to
create a new string which combines my first and last name together. Naively,
I would try to write something like this:
fn main() {
    let first_name = "Michael";
    let last_name = " Snoyman";
    let full_name = first_name + last_name;
    println!("Full name is {}", full_name);
}
This program doesn’t work. We’ll look at the compiler error in a bit to get
help on fixing it. But first, let me ask you a basic question: where should the
full_name value live in memory? We know it can’t live in program
memory, since this string is going to be created while the program is running,
after the compiler has frozen the program memory data. And it can’t live on
the stack, since this is a dynamically sized type.
It’s time to introduce the third part of memory: the heap. The heap allows for
dynamic allocation. This means that you can ask for a certain amount of
memory, and be handed an address to that memory. You can then work with
that memory as much as you want, and when you don’t need it anymore, you

▪
▪
▪
▪
▪
can free it so that it can be used again by your program or another program
running on your computer.
What we would need to do in order to create full_name is:
Count up the size of "Michael", which is 7
Count up the size of " Snoyman", which is 8
Ask for a chunk of 15 bytes on the heap to store all that data
Copy in the first name at the beginning of that chunk
Copy in the last name after the first 7 bytes of that chunk
Fortunately for us, that’s exactly what an owned string, or the String data
type, does. The String data type manages a chunk of data from the heap for
you. It holds onto the address of that piece of heap address and does all of
that data copying.
And here’s the great part: since the address it holds has a static size, String
is a statically sized type, meaning it can live in the stack. In other words, an
owned string lets you own a chunk of memory that can be created
dynamically.
OK, let’s go back to that broken program above, and let the compiler tell us
how to fix it. The error message our program generates is very helpful:
error[E0369]: binary operation `+` cannot be applied to type 
`&str`
 --> main.rs:4:32
  |
4 |     let full_name = first_name + last_name;

  |                     ---------- ^ --------- &str
  |                     |          |
  |                     |          `+` cannot be used to 
concatenate two `&str` strings
  |                     &str
  |
help: `to_owned()` can be used to create an owned `String` from a 
string reference. String concatenation appends the string on the 
right to the string on the left and may require reallocation. This 
requires ownership of the string on the left
  |
4 |     let full_name = first_name.to_owned() + last_name;
The + operator does not work on references to string slices. However, the
compiler mentions the method to_owned(). And it even tells you how to
rewrite your program to use to_owned.

EXERCISE
Follow the advice of the compiler and fix your program. The output should be:
Full name is Michael Snoyman

10.6. The type of owned strings
The type of an owned string is String. You can test this by modifying the
program above to have a type annotation, e.g.:
let full_name: String = first_name.to_owned() + last_name;
However, when you get a type error, the compiler will usually give you a
slightly more verbose name. If I make a mistake and say i32 instead of
String, I’ll get this error message:
error[E0308]: mismatched types
 --> main.rs:4:26
  |
4 |     let full_name: i32 = first_name.to_owned() + last_name;
  |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
expected i32, found struct `std::string::String`
  |
  = note: expected type `i32`
             found type `std::string::String`
What exactly is this std::string::String? We’ve seen the ::
operator before with static methods, and it meant "grab the method inside this
struct." It turns out that :: generally means "grab this thing inside something
else." std is short for "standard," and it’s a crate. A crate is a collection of
functions, types, and other things you can use in Rust. The std crate
contains all of the standard stuff you can use out of the box. Inside the std
crate, we have the string module. A module is a way of grouping together
related stuff. Inside the std::string module, we have the String struct.

You’re allowed to use either String or std::string::String, since
String is a special struct that is automatically available for your use all the
time. But the compiler will sometimes give the longer type, so it’s worth
knowing about that.

EXERCISE
Rewrite the program so that full_name has the full type std::string::String in its
type annotation.

10.7. Moving strings
Does this program compile?
fn greet(name: String) {
    println!("Hello {}", name);
}
fn main() {
    let first_name = "Michael";
    let last_name = " Snoyman";
    let full_name: String = first_name.to_owned() + last_name;
    greet(full_name);
}
Sure, no problem! We construct a new String value, store it in the
full_name variable, and then move it into the greet function. But what
happens if we call greet(full_name) a second time? We get an error
about using a moved value:
error[E0382]: use of moved value: `full_name`
  --> main.rs:11:11
   |
8  |     let full_name: String = first_name.to_owned() + 
last_name;
   |         --------- move occurs because `full_name` has type 
`std::string::String`, which does not implement the `Copy` trait
9  |
10 |     greet(full_name); // first call
   |           --------- value moved here
11 |     greet(full_name); // second call
   |           ^^^^^^^^^ value used here after move

One possible solution here is to use the clone method on String to create
an extra String that can be moved into greet:
greet(full_name.clone()); // first call
greet(full_name); // second call
However, this isn’t great: cloning a String takes time. Not a huge amount
of time, but we like our code to be fast.

10.8. Borrowing a String
A better solution to the above problem is to modify greet to take a
reference.

EXERCISE
Get rid of the .clone() method call, and modify greet to accept a &String parameter.
Then fix the calls to the greet function in main.
That’s all well and good, but let’s make our example a little bit more
involved. Now we want to greet a few different people:
fn greet(name: &String) {
    println!("Hello {}", name);
}
fn main() {
    let snoyman: &str = " Snoyman";
    let michael: String = "Michael".to_owned() + snoyman;
    let miriam: String = "Miriam".to_owned() + snoyman;
    let alice: &str = "Alice Smith";
    greet(&michael);
    greet(&miriam);
    greet(alice);
}
Both michael and miriam contain owned Strings, and therefore the
first two calls to greet work just fine. However, we get an error on the call
to greet(alice):
error[E0308]: mismatched types
  --> main.rs:13:11
   |
13 |     greet(alice);
   |           ^^^^^ expected struct `std::string::String`, found 
str
   |

   = note: expected type `&std::string::String`
              found type `&str`
A reference to a string slice isn’t the same as a reference to an owned
String, which is why this fails. One solution to this would be to convert
alice into an owned String and then borrow a reference to that:
greet(&alice.to_owned());
However, this is suboptimal: it forces a heap allocation and memory copy for
alice. It turns out that there’s an even simpler solution to this: change
greet's parameter from &String to &str. In other words:
fn greet(name: &str) {
    println!("Hello {}", name);
}
fn main() {
    let snoyman: &str = " Snoyman";
    let michael: String = "Michael".to_owned() + snoyman;
    let miriam: String = "Miriam".to_owned() + snoyman;
    let alice: &str = "Alice Smith";
    greet(&michael);
    greet(&miriam);
    greet(alice);
}
But why on Earth does that work?!? We already said that a reference to a
string slice (&str) is different than a reference to an owned string
(&String). But we’re quite blatantly calling greet on a borrowed
String with both greet(&michael) and greet(&miriam).

It turns out that there’s a special feature in Rust called deref coercion. We
don’t care about all of its details now. What we do care about is that it will
allow us to automatically convert a reference to an owned String into a
reference to a string slice, though not the other way around. The reason is that
a string slice is simply a chunk of memory with a string in it. And it doesn’t
matter if that chunk is on the heap or in program memory.
We’ll see more examples of deref coercion in later lessons. For now, the
important takeaway is: it’s almost always better to write your function
parameters as a &str instead of a &String.

10.9. A better person
Earlier, we declared a Person struct as:
struct Person {
    name: &'static str,
    age: i32,
}
This is incredibly limiting: only string literals can produce a &str with a
'static lifetime. Therefore, this Person can only store names that are
written as string literals and known when you’re writing your program. We
could try to store a string reference with a different lifetime parameter, but it
gets tricky. What lifetime parameter should it have? And who owns the data?
In most real-life Rust code, you don’t want to store references inside a struct.
It makes it too difficult to deal with lifetimes of values. Instead, we tend to
prefer putting owned values in there instead. So a better Person would use a
String for the name. For example:
struct Person {
    name: String,
    age: i32,
}
impl Person {
    fn say_info(&self) {
        println!("{} is {} years old", self.name, self.age);
    }
}
fn main() {
    let snoyman: &str = " Snoyman";

    let michael = Person {
        name: "Michael".to_owned() + snoyman,
        age: 35
    };
    let alice = Person {
        name: "Alice Smith".to_owned(),
        age: 30,
    };
    michael.say_info();
    alice.say_info();
}
This isn’t ideal from a performance standpoint: we had to call to_owned()
o n "Alice Smith", even though we aren’t doing any dynamic string
creation. This means that we’re creating an almost useless copy of the string
literal from program memory into the heap. But this is still the recommended
Rust approach most of the time.

EXERCISE
Create another person named Bob Johnson, aged 25, and say his info too.

10.10. The format! macro
We’ve used the println! and print! macros previously to generate and
print output. There’s another macro that goes along with them: the format!
macro. It works in almost exactly the same way, but instead of printing the
output, it generates a String value. For example:
fn main() {
    let name = "Michael";
    let age = 35;
    let message = format!("My name is {} and I am {} years old", 
name, age);
    println!("{}", message);
}
This can be nicer to read than lots of + operators. It can also sometimes be
faster than using a bunch of + operators when you’re combining lots of
values together.

EXERCISE
Write the body of the make_full_name function using a format! macro call.
fn make_full_name(first: &str, last: &str) -> String {
    // FIXME!
}
fn main() {
    assert_eq!(&make_full_name("Michael", "Snoyman"), 
"Michael Snoyman");
    assert_eq!(&make_full_name("Alice", "Smith"), "Alice 
Smith");
    println!("Success!");
}

10.11. Freeing
You don’t need this section to understand how to use strings correctly. But it
does help you understand why ownership is so important in Rust, and why
Rust is such an awesome language.
Above, I very briefly mentioned to you the concept of freeing memory. When
you allocate memory on the heap, what you’re doing is asking the dynamic
memory allocator to set aside a bit of the computer’s memory for you to use.
While you’re using that memory, nothing else can use it. The dynamic
allocator marks it as off limits, and will neither give it to your program to use,
or to some other program to use. That’s a good thing: it would be terrible if
we asked for a piece of memory, started using it, and then some other
function or program wrote over that data with something else entirely!
However, there’s a problem with this. If we keep asking for more memory,
we’ll eventually run out. Our computers have lots of memory available
(somewhere in the ballpark for 8 billion bytes usually). But if all the
programs on your computer never bother to free their memory, this will get
used up quickly. Freeing is a mechanism where you tell the dynamic
allocation: hey, I’m all done with this memory, you can let something else
use it now.
Lots of programs in the world written in languages like C and C++ have bugs
where they don’t free memory. This can happen for various uninteresting
reasons. The impact of this is that your computer runs out of memory, starts
running more slowly as the computer tries to find workarounds for the

unavailable memory, and eventually things just start breaking. That’s not
good.
But there’s something even worse. Let’s say you do free some memory, and
tell the dynamic allocator it can reuse it. But then, by mistake, you keep using
that memory again. Now your code, and something else, will both be
accessing the same bit of memory. If you’re lucky, the operating system may
detect that two different programs are trying to use the same bit of memory
and just kill your program. Yes, the best case scenario here is that your
program crashes.
In the worst case, you may end up with a major security bug. One function in
your program may write some secure data, like a password, into a bit of
memory. And another function will think that that piece of memory is
holding onto something that’s not security sensitive, like a username, and
send it to another machine. There have been lots of bugs like this in the
history of computers.
Rust is automatically protecting you from all of these bugs. Ownership
ensures that there’s always one thing in your program that is responsible for a
value. If there’s a dynamic allocation, like with a String, that one thing is
responsible for freeing the memory, and will do so for you automatically.
You can’t use the value after it’s been dropped based on the move rules. And
you can’t keep a reference to a dropped value based on the borrowing rules.
You may get frustrated at some points in your Rust career with ownership
and borrowing rules. But the alternative is far, far worse.

▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
10.12. Summary
Everything we use in our program must be stored in memory
The stack is the primary place where our values are stored
The stack cannot hold Dynamically Sized Types
Strings are Dynamically Sized Types, and therefore we store references to
them on the stack
String literals get stored in program memory
References to string literals have a special reference lifetime, 'static
You can heap allocate memory for strings
The String struct wraps up a heap allocation in a type that can be stored
on the stack
The String struct is also known as an owned string, while str is a
string slice
You can use the + operator to combine owned strings
The long name for String is std::string::String, which you’ll
sometimes see in error messages
Thanks to deref coercion, when you borrow a String, you can get either
a &String or a &str
When you write functions, it’s better to use &str rather than &String as
parameters so that your functions work on both owned strings and string
literals

▪
▪
▪
It’s typically best practice to store owned Strings in structs rather than
references
You can use the format! macro to construct Strings
Owned Strings automatically handle freeing of memory, and prevent a
lot of very common bugs

10.13. Exercises
1. Fix the program below so that it compiles and produces the output
"Hello, world!". Try to fix it without asking the compiler for a hint.
fn main() {
    let hello = "Hello, ";
    let world = "world!";
    let helloworld = hello + world;
    println!("{}", helloworld);
}
2. Numbers allow you to use + to add them together, or += to mutate a
variable. The same applies to Strings. Fix this program. Again, try to
figure out what the problem is without asking the compiler.
fn main() {
    let hello = "Hello, ".to_owned();
    hello += "world!";
    println!("{}", hello);
}
3. Make the program below compile.
fn say_hi(name: String) {
    println!("Hi {}", name);
}
fn main() {
    let name = "Michael".to_owned();
    say_hi(name);
    say_hi(name);
}

4. Write the function add_snoyman and say_hi to make this program
compile:
fn main() {
    let michael: String = add_snoyman("Michael");
    let miriam: String = add_snoyman("Miriam");
    let john: &'static str = "John Doe";
    say_hi(&michael);
    say_hi(&miriam);
    say_hi(john);
}
The output should be:
Hi Michael Snoyman
Hi Miriam Snoyman
Hi John Doe

11. ARRAYS, VECS, AND SLICES
We’ve spent a lot of time with strings. That makes sense: we want our
programs to interact with human beings, and human beings tend to like words
and sentences. We can logically think about strings as a sequence of
characters. However, strings are just one kind of a sequence of values. What
if we want a sequence of numbers, or people, or something else?
In this lesson, we’re going to learn about sequences of generic values. We’ll
start off with arrays, which almost magically live on the stack. We’ll talk
about Vecs (short for vector), which are dynamically allocated like
Strings. And we’ll learn about slices, and see how they related to the string
slices we’ve been using up until now.

11.1. Arrays
Time to learn about a new expression: array expressions. We write these with
square brackets containing a comma-separated list of values.
fn main() {
    let numbers = [2, 3, 8, 1, 9];
    println!("{:?}", numbers);
}
The {:?} is a new bit of syntax for format strings. It says that Rust should
use the "debug" version of output. There’s no obvious way to display arrays
in a user-friendly way, so they can’t use the normal {} display. But with
{:?}, we’re telling Rust: hey, I just want to see something, spit it out. This
program produces the output:
[2, 3, 8, 1, 9]
numbers is an array of values. Let’s add in a type signature:
let numbers: [i32; 5] = [2, 3, 8, 1, 9];
This means "I have 5 i32s." It may at first seem strange that the number of
values in the array appears in the type signature. However, let’s remember
what we learned in the last lesson: you can only store something on the stack
if it has a known size, based on the type. If we said "I’ve got a bunch of
i32s," it would be unclear how much size that should take on the stack, and

so we couldn’t do this. Arrays are special: they tell us exactly what size they
are.
An i32 takes up 32 bits, or 4 bytes. Therefore, 5 of them takes up 20 bytes
total.

11.2. Indexing
Arrays provide a handy method, len(), which tells you how many items
they contain. They also support an indexing operator. An array has a
sequence of values, numbered 0, 1, 2, and up. Each of these numbers is
known as the index. The indexing operator takes the index and gives you the
value at its position. Note that, since indices start at 0, an array of size 5
would have indices 0, 1, 2, 3, and 4, but does not have index 5.
This program will print out all of the values in the array:
fn main() {
    let numbers: [i32; 5] = [2, 3, 8, 1, 9];
    let mut i = 0;
    while i < numbers.len() {
        println!("numbers[{}] == {}", i, numbers[i]);
        i += 1;
    }
}
We can use indexing into an array to mutate it as well. For example, I can set
the value at index 2 to 10 with:
numbers[2] = 10;

EXERCISE
Add that line before the while loop. The code won’t compile; can you guess why before
asking the compiler? Also, try to predict what the output of the program will be.

EXERCISE
Write a function sum that will add up all the values in an array. You can test it with:
fn main() {
    let numbers: [i32; 5] = [2, 3, 8, 1, 9];
    assert_eq!(23, sum(numbers));
    println!("Good job!");
}
Bonus: modify that function take a reference to the array instead of the array itself.

11.3. Slices
Let’s add another number to our array. Can you find the bug?
let numbers: [i32; 5] = [2, 3, 8, 1, 9, 4];
The bug is that our type still says that the array should have 5 values, but it
has 6. So you dutifully oblige the compiler and update the type. All well and
good. But let’s go back to that sum function exercise. Assuming you did the
bonus, you probably ended up with a type signature that looks like:
fn sum(array: &[i32; 5]) -> i32
So, you think to yourself, I’ll just update that to be 6 instead of 5 too. But
what if you want to sum up more than one array, and they’re different sizes?
Having to define a sum_5, sum_6, and so on seems pretty bad.
Fortunately Rust isn’t that cruel. There is a generalization of all "sequences of
the same value" called a slice. (Yes, we said string slice in the last lesson,
we’ll get back to that.) The syntax for a slice looks like [i32]. Let’s try that
out.
fn main() {
    let numbers: [i32] = [2, 3, 8, 1, 9, 4];
    println!("{:?}", numbers);
}
Unfortunately, the compiler is not impressed.
error[E0308]: mismatched types

  --> foo.rs:10:26
   |
10 |     let numbers: [i32] = [2, 3, 8, 1, 9, 4];
   |                          ^^^^^^^^^^^^^^^^^^ expected slice, 
found array of 6 elements
   |
   = note: expected type `[i32]`
              found type `[i32; 6]`
error[E0277]: the size for values of type `[i32]` cannot be known 
at compilation time
  --> foo.rs:10:9
   |
10 |     let numbers: [i32] = [2, 3, 8, 1, 9, 4];
   |         ^^^^^^^ doesn't have a size known at compile-time
   |
   = help: the trait `std::marker::Sized` is not implemented for 
`[i32]`
   = note: to learn more, visit <https://doc.rust-
lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-
and-the-sized-trait>
   = note: all local variables must have a statically known size
   = help: unsized locals are gated as an unstable feature
Tackling the first message first. Our [x, y, z] syntax is specifically for
creating an array. An array isn’t a slice, and so we’ve got a basic type
mismatch. The second error message is more interesting, and goes back to
what we learned last time. A slice has no specific size. It could have 5 values,
6 values, no values, or 1,000. Since we don’t know the size, we can’t store it
on the stack.
We can solve both problems in the same way. We don’t store slices in values.
Instead, just like with strings, we store references to slices. So let’s change
the type to &[i32]. This solves the second problem. And now the error
message we get is really helpful:

10 |     let numbers: &[i32] = [2, 3, 8, 1, 9, 4];
   |                           ^^^^^^^^^^^^^^^^^^
   |                           |
   |                           expected &[i32], found array of 6 
elements
   |                           help: consider borrowing here: `&
[2, 3, 8, 1, 9, 4]`
   |
   = note: expected type `&[i32]`
              found type `[{integer}; 6]`
We can’t treat an array as a slice reference. However, we can borrow an array
to get a reference. And thanks to the same deref coercion we mentioned last
time, we can borrow a slice reference &[i32] instead of a reference to an
array &[i32; 6]. Go ahead and stick an ampersand & in front of the array
expression, and the code will work!

EXERCISE
Modify our solution from before to use slices in all type signatures instead of arrays.
fn sum(numbers: &[i32; 5]) -> i32 {
    let mut total = 0;
    let mut i = 0;
    while i < numbers.len() {
        total += numbers[i];
        i += 1
    }
    total
}
fn main() {
    let numbers: [i32; 5] = [2, 3, 8, 1, 9, 4];
    assert_eq!(27, sum(&numbers));
    println!("Good job!");
}

▪
▪
▪
11.4. The relation to string slices
This next bit isn’t strictly necessary to understand most programming in Rust,
but I think it’s helpful.
There’s a data type we haven’t directly talked about yet, called a char. It
represents a single character. This could be the letter A, or the @ sign, or the
Hebrew letter Alef (× ). Or many more things. We’ll get back to that part. In
Rust (and many other languages), a character literal is a character surrounded
by single quotes, e.g. 'A'.
A string, logically, is a sequence of characters. You can think of "Hello" as
['H', 'e', 'l', 'l', 'o']. However, that’s not the way Rust
actually represents a string. Instead, it does something totally different. Let’s
see why.
There are a lot of characters in the world. I mentioned the Latin alphabet, like
the letter A. I mentioned symbols, like the @ sign. I mentioned other
languages, like Hebrew. There are many, many thousands of characters we
would like to deal with. There’s a group called Unicode, who give a numeric
representation for all of these characters. For example:
A is U+0041
× is U+05D0
ðŸ˜¼ is U+1F63C

As of Unicode 12.1, there are 137,994 characters in Unicode. The question
then is: how big must a char be to hold all of those different potential
values? It turns out that the minimum size is 4 bytes.
If we used that array-of-chars representation for a string, then the word
"Hello" would take up 20 bytes. Considering that a large amount of the work
that computers do involves mostly-Latin data, it would be nice to make that
smaller.
Thankfully, there’s an encoding called UTF-8 that helps with that. An
encoding says how to represent a sequence of characters as binary data. UTF-
8 is cool for many reasons, but for our purpose: it takes only 1 byte to store
each Latin character. For many other common scripts, it uses only 2 or 3
bytes. And the most it ever uses is 4 bytes. So UTF-8 never takes up more
memory than an array of chars, and usually takes up much less.
There are downsides to treating a string as UTF-8. For example, you can’t
easily say "jump to the 5th character." You have to read all the data at the
beginning, because each character may take up a different amount of space.
But overall, this is a great trade-off.
So what exactly is a string slice? It’s a slice of bytes (u8s) which is
guaranteed to be valid UTF-8 data. It disallows some operations that other
slices allow. When we learn about iterators and for loops, we’ll see how we
can use the .chars() and .bytes() methods to access the character and
byte data inside a string slice.

11.5. Vec
Arrays offer a fixed-size collection of values on the stack. Slices allow you to
talk about any collection of values, regardless of where they’re stored or how
many of them there are. What if we want to have a dynamic size? Just like we
need a special struct String to hold heap-allocated strings, we need a
special struct Vec to hold heap-allocated collections of arbitrary data.
I already bored you to death with the UTF-8 talk above. I’ll say this one
much more succinctly: a String is a thin wrapper around a Vec of u8
values, with the guarantee that the data is valid UTF-8. Tada!
But how exactly do we say "a Vec of u8 values?" How do we distinguish a
Vec of u32s from a Vec of bools? We need to introduce something called
type parameters. A struct in Rust is allowed to take extra information about
which types to use. And the way we say that is with the less than and greater
than signs, also known as angle brackets. Or said with code, a vector of bytes
is a Vec<u8>. A vector of bools is a Vec<bool>.
㇀
We can use type parameters for lots of things. We’ll see how to define structs, functions,
and other things that use them in later chapters. For now, we’ll stick to using preexisting
types in Rust like Vec that use them.
Alright, let’s finally see some Vec code!
fn main() {

    let numbers = vec!(2, 3, 8, 1, 9, 4);
    println!("{:?}", numbers);
}
The vec! macro is a helper for creating a new Vec. It has to be a macro
instead of a function because it can take as many parameters as you want. But
you’ll almost never see that macro written that way. Instead, Rustaceans
prefer to replace the parentheses with square brackets:
let numbers = vec![2, 3, 8, 1, 9, 4];
Why? Probably because it feels closer to the array expression syntax. It’s not
important or a big deal, you can use either parentheses or square brackets on
all macro calls. And yes, that means if you want to you can do things like
println!["Hello, world!"];. But please don’t :).

CHALLENGE EXERCISE
Based on our discussion of type parameters above, can you put a type annotation on let
numbers so that it’s a Vec of i32s? Solution follows.
The way we add a type annotation for a Vec is:
let numbers: Vec<i32> = vec![2, 3, 8, 1, 9, 4];
Remember, we put the type parameters inside the angle brackets.
It’s boring to just have a statically sized Vec. Let’s go ahead and add a new
value to the end:
numbers.push(10);

EXERCISE
Add this before the println! macro call. The program won’t compile. Figure out why and
fix it.

11.6. Slicing a slice
We’ve been using the term slice for a bit now. But we haven’t talked about
why they’re called slices. It turns out there’s a good reason: you can slice up a
slice! Often times, we want to look at a smaller piece of a collection. And
Rust has slice syntax to allow talking about these smaller pieces.
It’s easiest to see this in action:
fn main() {
    let numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    println!("{:?}", &numbers[1..4]);
}
We take our original array numbers, stick [1..4] at the end, and take a
reference to the new slice. The output from this program is [1, 2, 3].
The 1 in 1..4 means "start at index 1," and the 4 means "go up to, but don’t
include, index 4."
㇀
There’s a common error in programming known as an "off by one error." Indexing and
slicing are good avenues to make such a mistake. This often occurs when you
miscalculate which index you are beginning or ending with, resulting in one too many or
one too few.
You can use slice syntax on arrays. But you can also use it on Vecs:
fn main() {

    let numbers = vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    println!("{:?}", &numbers[1..4]);
}
Or on slices themselves:
fn main() {
    let numbers = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    println!("{:?}", &numbers[1..4]);
}
There are some additional things to this syntax. For example, you can say
"give me everything from the beginning" by leaving off the first number:
println!("{:?}", &numbers[..4]);
But this is basically the same thing as using 0 as the first number. The second
trick is cooler: if you leave off the second number it will get everything up to
the end:
println!("{:?}", &numbers[6..]);
And finally, you can leave off both numbers to say "give me the entire slice."
This can be a more explicit way to get a slice reference from an array or a
Vec than simply borrowing a reference:
println!("{:?}", &numbers[..]);

▪
▪
▪
▪
▪
▪
▪
▪
▪
11.7. Summary
An array stores a fixed sized collection of values on the stack
You can use index syntax to access and mutate values in an array
A slice is a non-fixed sized collection of values, which may live anywhere
in memory
You can borrow a slice from an array
A string slice is a thin wrapper around a byte slice which guarantees valid
UTF-8 data
A Vec is a heap allocated collection of values which can have dynamic
size
Vecs take a type parameter to indicate which type they contain
A String is a thin wrapper around a Vec<u8>
You can slice up a slice using slice syntax

11.8. Exercises
1. Fill out an implementation of the maximum function to return the
maximum value in the provided slice. If provided with an empty slice,
you can return 0.
fn maximum(numbers: &[u32]) -> u32 {
  // FIXME
}
fn main() {
    assert_eq!(maximum(&[1, 2, 3]), 3);
    assert_eq!(maximum(&[1, 8, 3]), 8);
    assert_eq!(maximum(&[1, 1, 1]), 1);
    assert_eq!(maximum(&[]), 0);
    println!("Success!");
}
2. Fill out an implementation of the reverse function to make this
program succeed. Note that you’ll want to use the push method and a
while loop that moves backwards through the numbers parameter:
fn reverse(numbers: &[i32]) -> Vec<i32> {
    // FIXME
}
fn main() {
    let numbers = &[4, 5, 2, 8];
    assert_eq!(reverse(numbers), &[8, 2, 5, 4]);
    println!("Success!");
}
3. The Fibonacci sequence starts with the numbers 1 and 1. Then, each

number after that is the sum of the previous two numbers. For example,
the next number is 2 (1 + 1), followed by 3 (1 + 2), followed by 5 (2 +
3).
Fill out the fibs function so that it produces a vector of Fibonacci
numbers of the given size.
fn fibs(count: usize) -> Vec<u32> {
    // FIXME
}
fn main() {
    assert_eq!(fibs(5), &[1, 1, 2, 3, 5]);
    assert_eq!(fibs(1), &[1]);
    assert_eq!(fibs(8), &[1, 1, 2, 3, 5, 8, 13, 21]);
    println!("Success!");
}

12. TYPE PARAMETERS
When we looked at the Vec struct, we learned about type parameters. Those
are the things that go inside the angle brackets, e.g. Vec<i32> has a type
parameter of i32. Type parameters are very common in Rust, and can show
up in many different parts of your code. They allow you to generalize structs,
functions, and more from working on one single type to an entire family of
types. Vec was just the tip of the iceberg. Let’s demonstrate how and why
they are used.

12.1. Structs
Let’s take our trusty old Fruit struct as an example:
struct Fruit {
    apples: u32,
    bananas: u32,
}
We’ve hard-coded the fields to be u32s. But maybe I want to use i32. Or
perhaps u64. Or maybe something totally different, like a String or
Kilograms. We could define additional copies of the struct for each of
these under a different name:
struct Fruit_i32 {
    apples: i32,
    bananas: i32,
}
struct Fruit_String {
    apples: String,
    bananas: String,
}
But this is repetitive and tedious. And when we get to functions and methods
with type parameters, we’ll see that it’s even worse than it seems right now.
Type parameters let us define and use structs which have "placeholder"
fields, to be filled by a concrete type. Let’s redefine our Fruit struct to use
a type parameter:
struct Fruit<T> {

    apples: T,
    bananas: T,
}
By introducing the angle brackets, we are saying "hey, this struct has a type
parameter." If you have a single type parameter, it’s fairly common to use the
type parameter name T to represent "type." Then, within the struct definition,
we have the type T in scope to mean "whatever type parameter is passed in."
This is very similar to normal function parameters, where the caller supplies a
value and we can use it in the body of the function.
With that struct in place, let’s see how we can use it in our main
function:
struct Fruit<T> {
    apples: T,
    bananas: T,
}
fn main() {
    let _fruit32: Fruit<i32> = Fruit {
        apples: 5_i32,
        bananas: 10_i32,
    };
    let _fruit64: Fruit<i64> = Fruit {
        apples: 5_i64,
        bananas: 10_i64,
    };
    let _fruitstr: Fruit<String> = Fruit {
        apples: "5".to_owned(),
        bananas: "10".to_owned(),
    };
}

We’re able to fill in that T type parameter with whatever type we want: an
i32, i64, or even a String. The only really restriction we run into is
consistency: since we use the same T for both apples and bananas, we
need to ensure that we provide values of the same type to both.

EXERCISE
Generate some compiler errors by changing the types of the values and the type parameters in
the code above. Try putting in other things like strings and booleans for the values of apples
and bananas. See what happens. Be creative, and have fun!
We’re not limited to taking just a single type parameter. Like function
parameter lists, you can separate type parameter lists with commas:
struct Person<Name, Age> {
    name: Name,
    age: Age,
}
fn main() {
    let _alice: Person<String, u32> = Person {
        name: "Alice".to_owned(),
        age: 30_u32,
    };
    let _bob: Person<String, u64> = Person {
        name: "Bob".to_owned(),
        age: 35_u64,
    };
}
Note that, like struct names, type parameter names are expected to be in
UpperCamelCase. The compiler will remind you of this if you forget:
warning: type parameter `name` should have an upper camel case 
name
 --> src/main.rs:1:15
  |
1 | struct Person<name, Age> {
  |               ^^^^ help: convert the identifier to upper camel 

case: `Name`
  |
  = note: `#[warn(non_camel_case_types)]` on by default

12.2. Parameterized functions
I want to say hi to Alice and Bob. But for now, at least, I’m going to be polite
and not mention how old they are. How exactly do we write that function?
Let’s first write a version that works for Alice. This code won’t compile; try
to see if you can figure out why.
struct Person<Name, Age> {
    name: Name,
    age: Age,
}
fn greet(person: &Person<String, u32>) {
    println!("Hello, {}", person.name);
}
fn main() {
    let alice: Person<String, u32> = Person {
        name: "Alice".to_owned(),
        age: 30_u32,
    };
    greet(&alice);
    let bob: Person<String, u64> = Person {
        name: "Bob".to_owned(),
        age: 35_u64,
    };
    greet(&bob);
}
The compiler gives us the following error message:
error[E0308]: mismatched types
  --> src/main.rs:21:11
   |
21 |     greet(&bob);

   |           ^^^^ expected u32, found u64
   |
   = note: expected type `&Person<std::string::String, u32>`
              found type `&Person<std::string::String, u64>`
Our greet function says it works on a &Person<String, u32>. But
Bob keeps his age as a u64, not a u32, so of course this doesn’t compile!
We could change the function to a u64, but then it wouldn’t work for Alice.
Or we could write two copies of the function: a greet_u32 and a
greet_u64. But we don’t want to have to duplicate our code like that!
What’s especially irritating here is that we aren’t even using the age. We
don’t care what it is. It could be anything! What we need is some way to say
"this function works for any age type parameter." Fortunately, we can do this
for functions just like we can for structs. Behold: a function type parameter!
fn greet<Age>(person: &Person<String, Age>) {
    println!("Hello, {}", person.name);
}
We’re now saying "greet is a function that takes a first parameter of type
&Person<String, Age>, where Age can be any type the caller sends
me." Sweet!

EXERCISE
Modify the code above to not use .to_owned() on the string literals. Instead, work directly
with the string slice references.

▪
▪
▪
▪
12.3. Parameterized impl blocks
Using greet as a function is a bit clunky. It would feel more natural to
define it as a method. However, it in order to make that work, we’ll need to
put type parameters on an impl block. In my opinion at least, this example
of type parameters looks a little unusual, because it uses two sets of angle
brackets. But the logic makes perfect sense once explained. First, let’s look at
the working code, and then we’ll explain how it works:
impl<T> Person<String, T> {
    fn greet(&self) {
        println!("Hello, {}", self.name);
    }
}
Here’s the explanation:
We first put in the impl keyword to say "hey, here comes an impl!"
Next, we follow it up with the first set of angle brackets. This declares
which type parameters need to be available. In our case, we just have one
type variable, T.
Next, we say which type we’re defining the impl block for. In our case,
we’re using the type Person<String, Age>. This means "this impl
block works for a Person when the Name type variable is specifically a
String, but the Age type variable is T." And since T itself is a type
variable, that means that Age can be anything.
Finally, inside the impl block itself, we can use self and Self like

normal, which refers to Person<String, Age>.
Once we have all of this in place, rewriting our main function is easy:
fn main() {
    let alice: Person<String, u32> = Person {
        name: "Alice".to_owned(),
        age: 30_u32,
    };
    alice.greet();
    let bob: Person<String, u64> = Person {
        name: "Bob".to_owned(),
        age: 35_u64,
    };
    bob.greet();
}

EXERCISE
Modify the code above to include Alice and Bob’s weight as an additional parameter to
Person. Alice weighs 65kg and Bob weighs 75kg. We’re going to stay polite, though, and not
mention it in the greet function.

12.4. Turbofish!
Let’s go back to fruit. We can write static methods just as easily as normal
methods. Behold, my new fruit!
struct Fruit<T> {
    apples: T,
    bananas: T,
}
impl Fruit<i32> {
    fn new() -> Self {
        Fruit {
            apples: 5,
            bananas: 10,
        }
    }
}
fn main() {
    let fruit = Fruit::new();
    assert_eq!(fruit.apples, 5);
    assert_eq!(fruit.bananas, 10);
    println!("Success!");
}
Pop quiz: what’s the type of the fruit variable in main? Given that we
have an impl block for a Fruit<i32>, it seems a fair guess that the type
is Fruit<i32>. And you’d be right. But how did Rust know you wanted
that? Why not give you a Fruit<String>? That’s because there was only
one static method on Fruit available called new, and it returned a
Fruit<i32>. However, if I add the following block to my code:

impl Fruit<i64> {
    fn new() -> Self {
        Fruit {
            apples: 5,
            bananas: 10,
        }
    }
}
Suddenly, the compiler is at a loss: did I want to use the i32 or the i64
version of new? It says as much with its error message:
error[E0034]: multiple applicable items in scope
  --> src/main.rs:25:17
   |
25 |     let fruit = Fruit::new();
   |                 ^^^^^^^^^^ multiple `new` found
   |
note: candidate #1 is defined in an impl for the type `Fruit<i32>`
  --> src/main.rs:7:5
   |
7  |     fn new() -> Self {
   |     ^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl for the type `Fruit<i64>`
  --> src/main.rs:16:5
   |
16 |     fn new() -> Self {
   |     ^^^^^^^^^^^^^^^^
In these kinds of situations, Rust needs a little bit of guidance about what
types you want to work with. Fortunately, there’s syntax to explicitly say "I
want you to use these type parameters." It is affectionately known as the
turbofish, because it somewhat resembles a fish. Why turbo? Maybe it looks
like a fast fish? I really don’t know. But I like the name. Also, maybe the
unofficial turbofish website can help.

Anyway, the syntax for turbofish is ::<TypeParam1, TypeParam2,
… >. We can use it in our main function above to get the code to compile:
fn main() {
    let fruit = Fruit::<i64>::new();
    assert_eq!(fruit.apples, 5_i64);
    assert_eq!(fruit.bananas, 10_i64);
    println!("Success!");
}
This doesn’t just apply to structs. You can also provide type parameters to
functions. For example, there’s a std::mem::size_of function that tells
us how much memory a data type takes. If we use it on its own, e.g.:
fn main() {
    let size = std::mem::size_of();
    println!("Size: {}", size);
}
We get the error message:
error[E0282]: type annotations needed
 --> src/main.rs:2:16
  |
2 |     let size = std::mem::size_of();
  |                ^^^^^^^^^^^^^^^^^ cannot infer type for `T`
Instead, we need to tell the compiler which type we want to get the size for
using the turbofish:
fn main() {
    let size = std::mem::size_of::<i32>();
    println!("Size: {}", size);
}

EXERCISE
Use size_of to determine the size of an array of 5 i32 values. Check earlier lessons if
you’ve forgotten the syntax for an array.

▪
▪
▪
▪
▪
▪
▪
▪
12.5. Summary
Type parameters are placed inside angle brackets
Type parameters can be used on structs, functions, impl blocks, and more
Type parameters allow you to create placeholders that will be filled in with
concrete types, instead of duplicating your definitions
Type parameters can be a comma separated list, and are supposed to be
UpperCamelCased
When you use type parameters in defining a struct, you put the angle
brackets immediately following the struct’s name
When you use type parameters in defining a function, you put the angle
brackets immediately following the function’s name
When you use type parameters in an impl block, you declare the type
parameters immediately after the impl keyword, and then use the type
parameters in angle brackets with the struct’s name
When you need to disambiguate a type, you can use the ::
<Turbofish>

12.6. Exercises
1. The identity function is a function which always returns whatever
value is passed to it. Add an identity function to this program so that
the main function prints "Success!" without modifying main:
fn main() {
    assert_eq!(identity("foo"), "foo");
    assert_eq!(identity(5_i32), 5);
    assert_eq!(identity(6_i64), 6);
    assert_eq!(identity(true), true);
    println!("Success!");
}
2. Like the previous exercise, we’ll look at the just_second function.
It’s like identity, but it ignores the first argument and returns the
second. Write an implementation of it:
fn main() {
    assert_eq!(just_second((), "foo"), "foo");
    assert_eq!(just_second(true, 5_i32), 5);
    assert_eq!(just_second("ignored", 6_i64), 6);
    assert_eq!(just_second(5_u8, true), true);
    println!("Success!");
}
3. Write 
a stringy method that converts a Fruit<i32> into a
Fruit<String>. You can use format! to implement this.
struct Fruit<T> {
    apples: T,
    bananas: T,
}

impl Fruit<i32> {
    fn new() -> Self {
        Fruit {
            apples: 5,
            bananas: 10,
        }
    }
    // FIXME add the method here
}
fn main() {
    let fruit_i32: Fruit<i32> = Fruit::new();
    let fruit_str: Fruit<String> = fruit_i32.stringy();
    assert_eq!(fruit_str.apples, "5".to_owned());
    assert_eq!(fruit_str.bananas, "10".to_owned());
    println!("Success!");
}
Bonus: we haven’t discussed it before, but there’s a to_string
method available on many types, including i32s. You can try using that
instead of the format macro.

13. TRAITS
Traits show up so much in Rust that we’ve already mentioned them multiple
times in our previous lessons. It’s time to finally dive into this topic. We’ll
start off with some simpler examples of traits. Then, we’ll get into some
stronger motivation for using traits, focusing on some limitations we cleverly
avoided with type parameters in the last chapter.

13.1. Double double
I want to write a function that can double both i32s and i64s. I’m going to
start off by using the ugly "add the type to the name" approach and end up
with two functions:
fn double_i32(x: i32) -> i32 {
    x * 2
}
fn double_i64(x: i64) -> i64 {
    x * 2
}
fn main() {
    println!("double 5_i32 == {}", double_i32(5_i32));
    println!("double 5_i64 == {}", double_i64(5_i64));
}
But I don’t like that at all! This feels like something that would be much
more pleasant if:
1. I had the same name for both types
2. I could use method syntax
So let’s go ahead and try to write two impl blocks:
impl i32 {
    fn double(&self) -> Self {
        self * 2
    }
}

impl i64 {
    fn double(&self) -> Self {
        self * 2
    }
}
fn main() {
    println!("double 5_i32 == {}", 5_i32.double());
    println!("double 5_i64 == {}", 5_i64.double());
}
Unfortunately, this doesn’t work. And perhaps more unfortunately, the
compiler’s error message about this is more confusing than helpful:
error[E0390]: only a single inherent implementation marked with `#
[lang = "i32"]` is allowed for the `i32` primitive
So ignore the error message. I’m going to teach you a new rule: you can’t
define impl blocks for types that are defined elsewhere. If you write a
struct, you control it yourself, and you can add any methods to it. But if
something comes from std (like i32, or String, or Vec), you’re not
allowed to add methods to it.
But have no fear! There’s still a way that you can add a method to a type, just
not directly. And this is where we’ll first introduce traits. Traits introduce a
set of functionality that isn’t tied to a specific type. Instead, it can be
implemented for lots of different types. Our doubling concept is a great
example: we can double an i32, or an i64, or even a Fruit value.
㇀

▪
▪
You may be wondering: why this limitation? We’re not going to get into these kinds of
"why" questions here. At the time of writing, there is some material online you can read
regarding this if you’re curious.
OK, let’s see what a trait definition looks like:
trait Double {
    fn double(&self) -> Self;
}
We start off pretty similarly to some of our other top level items like a struct
or impl block. We use the keyword trait to say "here comes a trait." Then
we give the trait a name, and then the body of the trait.
Inside that body, we have 0 or more trait items. In our example, we have just
one: a method signature. This looks almost like a method in an impl block.
However, two important things to notice:
We don’t provide a body of the method. Instead, we just slap a semicolon
at the end. When defining a trait, we’re saying "there has to be a way to
double this value." We’re not yet saying how to do that. The
implementation will come later.
We always refer to Self and self when talking about the type we’re
implementing a trait for. Unlike in an impl block, the Self here is
working almost like a type parameter, and will match all of the different
implementations.
We’ve said implementation a few times. Now that we’ve defined our trait,
it’s time to implement it. This looks almost identical to the impl blocks

▪
▪
we’ve seen before:
impl Double for i32 {
    fn double(&self) -> Self {
        self * 2
    }
}
impl Double for i64 {
    fn double(&self) -> Self {
        self * 2
    }
}
There are two important things to note about a trait implementation versus a
normal impl block:
We start it off with impl TraitName for TypeName instead of
impl TypeName
The methods we define here must match the signature in the trait definition
perfectly
Finally, we are now able to use double as a method. Here’s a complete
example:
trait Double {
    fn double(&self) -> Self;
}
impl Double for i32 {
    fn double(&self) -> Self {
        self * 2
    }
}

impl Double for i64 {
    fn double(&self) -> Self {
        self * 2
    }
}
fn main() {
    println!("double 5_i32 == {}", 5_i32.double());
    println!("double 5_i64 == {}", 5_i64.double());
}
㇀
In the impl blocks we return Self, but we could just as easily return the specific type
for that impl block, such as
impl Double for i32 {
    fn double(&self) -> i32 {
        self * 2
    }
}
impl Double for i64 {
    fn double(&self) -> i64 {
        self * 2
    }
}
Both of these approaches are correct.

EXERCISE
Start playing with the code above and tweaking some of the implementations. Add some
additional methods, change signatures, and so on. See what kinds of error messages the
compiler gives you. The goal here is to get comfortable with the fact that implementations and
definitions need to match up perfectly.

13.2. Trait bounds
I want to quadruple my numbers. I could do * 4, but that’s so pedestrian.
I’ve already got a double method. So why not simple call it twice?
fn quadruple(x: i32) -> i32 {
    x.double().double()
}
fn main() {
    println!("quadruple 5_i32 == {}", quadruple(5_i32));
}
That’s great, but it only works for an i32. If I try to call quadruple on an
i64 I’ll get an error message about mismatched types. Fortunately, we’ve
already learned all about type parameters. So let’s say that our quadruple
function works on any type:
fn quadruple<T>(x: T) -> T {
    x.double().double()
}
fn main() {
    println!("quadruple 5_i32 == {}", quadruple(5_i32));
    println!("quadruple 5_i64 == {}", quadruple(5_i64));
}
The compiler does not like this, but it gives us some really helpful
information:
error[E0599]: no method named `double` found for type `T` in the 
current scope
  --> src/main.rs:18:7

▪
▪
▪
▪
   |
18 |     x.double().double()
   |       ^^^^^^ method not found in `T`
   |
   = help: items from traits can only be used if the type 
parameter is bounded by the trait
help: the following trait defines an item `double`, perhaps you 
need to restrict type parameter `T` with it:
   |
17 | fn quadruple<T: Double>(x: T) -> T {
   |              ^^^^^^^^^
Translating this out:
You said that quadruple works on any type T
Since whoever calls this functions gets to decide what T is, I have no way
of knowing if T is going to have a method called double on it
I noticed that there’s this trait called Double which provides a double
method, maybe that’s what you wanted to use?
If so, you need to introduce a trait bound
Trait bounds introduce a restriction on the types that a caller can use when
using type parameters. Up until now, we’ve seen unbounded type parameters,
which mean "you can use whatever type you want." However, with
quadruple, we don’t want to be so accepting. Instead, we want to say
"OK, you can give me lots of different Ts, but just make sure they implement
the Double trait." And there’s a nice, easy way to do that:
fn quadruple<T: Double>(x: T) -> T {
    x.double().double()
}

▪
▪
All I’ve done is added : Double after the definition of the type parameter
inside the angle brackets. This introduces a shift in two places:
Inside the definition of the quadruple function, we’re allowed to
assume that T has a double method
When calling the quadruple function, we have a responsibility to make
sure the type we’re using has an implementation of Double

EXERCISE
Modify the signature of the print_double function to use a type parameter so that this
program compiles and runs successfully.
trait DoubleString {
    fn double_string(&self) -> String;
}
impl DoubleString for i32 {
    fn double_string(&self) -> String {
        format!("{}", self * 2)
    }
}
impl DoubleString for i64 {
    fn double_string(&self) -> String {
        format!("{}", self * 2)
    }
}
fn print_double(x: i32) {
    println!("The doubled value is {}", x.double_string());
}
fn main() {
    print_double(5_i32);
    print_double(20_i64);
}

13.3. Parameterized fruit
I said we were allowed to write a trait implementation for types we created
ourselves. Let’s write a Fruit struct and provide it a Double
implementation:
struct Fruit {
    apples: i32,
    bananas: i32,
}
impl Double for Fruit {
    fn double(&self) -> Self {
        Fruit {
            apples: self.apples.double(),
            bananas: self.bananas.double(),
        }
    }
}
And look at that, we were even able to reuse our double trait method inside
the implementation of double for Fruit. How convenient! But after we
learned about parameterized structs, it feels a bit limiting to tie ourselves
down to an i32. Can we parameterized Fruit? Let’s try it.
struct Fruit<T> {
    apples: T,
    bananas: T,
}
impl Double for Fruit {
    fn double(&self) -> Self {
        Fruit {
            apples: self.apples.double(),

            bananas: self.bananas.double(),
        }
    }
}
This doesn’t compile:
error[E0107]: wrong number of type arguments: expected 1, found 0
  --> src/main.rs:26:17
   |
26 | impl Double for Fruit {
   |                 ^^^^^ expected 1 type argument
Well, that makes sense. We need to provide some kind of type parameter
there. The question is: what should it be? We can get back our old
functionality by providing an i32:
impl Double for Fruit<i32> {
    fn double(&self) -> Self {
        Fruit {
            apples: self.apples.double(),
            bananas: self.bananas.double(),
        }
    }
}
This works, but now we can only double a Fruit<i32>. If I have a
Fruit<i64>, I’m out of luck. We could define an implementation for each
of those, but that’s repetitive. Instead, can we use type parameters when
writing the trait implementation itself? Sure!
trait Double {
    fn double(&self) -> Self;
}

struct Fruit<T> {
    apples: T,
    bananas: T,
}
impl<T> Double for Fruit<T> {
    fn double(&self) -> Self {
        Fruit {
            apples: self.apples.double(),
            bananas: self.bananas.double(),
        }
    }
}
This looks quite a bit like the impl blocks we looked at previously. We define
the type parameters right after the impl keyword, and then use them when
providing the type. Unfortunately though, this code doesn’t compile:
error[E0599]: no method named `double` found for type `T` in the 
current scope
  --> src/main.rs:29:33
   |
29 |             apples: self.apples.double(),
   |                                 ^^^^^^ method not found in 
`T`
This is the same problem we ran into before with the quadruple function.
We’ve stated "hey, I can implemented the Double trait for a Fruit with
any type parameter T." But that’s not actually true. We need to know that T
itself has an implementation of Double, since we rely on the double
method in the implementation. To solve this, we can use a trait bound.

EXERCISE
Add a trait bound to the trait implementation above to make it compile. Your trait bound will
need to say "the type parameter T must have an implementation of the Double trait." If you’re
not sure where exactly to put the bound, play around with it and ask the compiler to check your
work.

13.4. Display
Using the format macro, I can write a function that turns an i32 into a
String:
fn stringy(x: i32) -> String {
    format!("{}", x)
}
fn main() {
    assert_eq!(stringy(42), "42".to_owned());
    println!("Success!");
}
But we’re all about type parameters these days. Can we generalize this to any
type T?
fn stringy<T>(x: T) -> String {
    format!("{}", x)
}
Not like that apparently:
error[E0277]: `T` doesn't implement `std::fmt::Display`
 --> src/main.rs:2:19
  |
2 |     format!("{}", x)
  |                   ^ `T` cannot be formatted with the default 
formatter
  |
  = help: the trait `std::fmt::Display` is not implemented for `T`
  = note: in format strings you may be able to use `{:?}` (or 
{:#?} for pretty-print) instead
  = help: consider adding a `where T: std::fmt::Display` bound
  = note: required because of the requirements on the impl of 

`std::fmt::Display` for `&T`
  = note: required by `std::fmt::Display::fmt`
Up until now, we’ve glossed over an important question: how is it that
println and format allow you to use lots of different types inside
interpolations? The answer is that under the surface, it’s using a trait called
Display. Display is in the std crate, inside the fmt module, so its full
name is std::fmt::Display.

EXERCISE
Add a trait bound to stringy to make the code below compile and print "Success!" without
modifying the main function.
fn stringy<T>(x: T) -> String {
    format!("{}", x)
}
fn main() {
    assert_eq!(stringy(42), "42".to_owned());
    assert_eq!(stringy(true), "true".to_owned());
    assert_eq!(stringy("hello"), "hello".to_owned());
    println!("Success!");
}
Typing in long names like std::fmt::Display all over the place can be
an annoyance. Using a use, you can bring names like that into scope to make
them easier to work with. For example, we can alternatively solve the
exercise above with:
use std::fmt::Display;
fn stringy<T: Display>(x: T) -> String {
    format!("{}", x)
}
As it happens, you don’t need to write this function, ever. The std crate
already provides a ToString trait which provides a to_string method.
And this trait uses Display under the surface itself. You can see it in action
here:

fn main() {
    assert_eq!(42.to_string(), "42".to_owned());
    assert_eq!(true.to_string(), "true".to_owned());
    assert_eq!("hello".to_string(), "hello".to_owned());
    println!("Success!");
}
If you’re curious: yes, to_string and to_owned have exactly the same
behavior when applied to a string slice. Which one you use is entirely up to
you. The compiler recommends to_owned, which is why we started with it.
But in real life Rust code, you’ll likely see to_string more often.

13.5. Clone and derive
We’ve seen the clone() method for Strings as a way to create a
duplicate of an owned String. In some cases, this can be relevant for
dealing with ownership issues. As a reminder, this code fails due to usage of
a moved value:
struct Fruit {
    apples: i32,
    bananas: i32,
}
// Should use a reference, but I'm proving a point
fn print_fruit(fruit: Fruit) {
    println!("Apples: {}, bananas: {}", fruit.apples, 
fruit.bananas);
}
fn main() {
    let mut fruit = Fruit { apples: 5, bananas: 10 };
    print_fruit(fruit); // moved here
    fruit.apples *= 2; // this will fail
    fruit.bananas *= 3;
    print_fruit(fruit);
}
We can fix this by implementing a clone method on Fruit:
impl Fruit {
    fn clone(&self) -> Fruit {
        Fruit {
            apples: self.apples.clone(),
            bananas: self.bananas.clone(),
        }
    }

}
And then we can fix the code above by adding .clone() in the first call to
print_fruit.

EXERCISE
Go ahead and use this impl Fruit block and .clone() call to fix the program above.
As it turns out, this need to clone is common enough that there’s a trait for it,
unimaginatively called Clone. We can change our impl Fruit to impl
Clone for Fruit and the program will still work.
But even this is annoying. All we’re doing is calling .clone() on each of
the fields inside our struct. This is very common, and very tedious.
Fortunately, the kind people behind Rust have had mercy on us. There’s a
feature in Rust called deriving that lets us automatically create these
instances. The syntax is a bit different than what we’ve seen so far, but it’s
pretty easy:
#[derive(Clone)]
struct Fruit {
    apples: i32,
    bananas: i32,
}
And boom! We’ve got a Clone implementation.

EXERCISE
Deriving works when you’ve got type parameters too. Finish converting this code over to a
parameterized Fruit:
struct Fruit<T> {
    apples: T,
    bananas: T,
}
// Should use a reference, but I'm proving a point
fn print_fruit(fruit: Fruit) {
    println!("Apples: {}, bananas: {}", fruit.apples, 
fruit.bananas);
}
fn main() {
    let mut fruit = Fruit { apples: 5, bananas: 10 };
    print_fruit(fruit.clone());
    fruit.apples *= 2;
    fruit.bananas *= 3;
    print_fruit(fruit);
}

13.6. Copy and marker traits
We’ve previously talked about copyable types. As a reminder, those are types
that are so cheap to clone that the compiler will do it for you automatically.
Rust identifies these types with a special trait called Copy. Copy is known
as a marker trait. That means it’s a trait that doesn’t provide any functionality
on its own. Instead, it provides information to the compiler about a type, such
as "this type is cheap enough to copy."
As an example, we could implement the Copy trait for our parameterized
Fruit type like this:
#[derive(Clone)]
struct Fruit<T> {
    apples: T,
    bananas: T,
}
impl<T: Copy> Copy for Fruit<T> {}
This means that "as long as the type parameter itself can be copied, Fruit
can be copied." But of course, this is so boring to write that the Rust creators
had mercy on us and let us write:
#[derive(Clone, Copy)]
struct Fruit<T> {
    apples: T,
    bananas: T,
}

Finally, Copy is a subtrait of Clone. That means that you can only provide
a Copy implementation if there’s also a Clone implementation.

EXERCISE
Generate a compile-time error message by removing the Clone deriving.

13.7. Debug
Debugging is the process of figuring out and fixing bugs in your software.
Often times, in order to aid in the debugging, we like to be able to print out
some values. The Display trait is intended for user-friendly output. And
there’s no way to derive a Display trait. For debugging, we’re often
happy to let the compiler just generate some kind of output. To facilitate this,
we have the Debug trait, which supports deriving. Let’s see this in practice:
#[derive(Debug)]
struct Fruit {
    apples: i32,
    bananas: i32,
}
fn main() {
    let fruit = Fruit { apples: 5, bananas: 10 };
    println!("{:?}", fruit);
}
In the format string, we use {:?} to indicate "please use the Debug trait
instead of Display trait to print this out." When we used this format string
previously with slices and vectors, we were using the Debug trait without
knowing it.

▪
▪
▪
▪
▪
▪
▪
▪
13.8. Partial equal, partial order
The next four traits we’re going to deal with are about equality and ordering.
Rust breaks each of these down into a partial and total trait. The reason for
this has to do with mathematical theory, reflexivity and equality, and the way
that computers represent non-integer values (like f32 and f64). The details
aren’t vital to our understanding, so we’re going to skip over them. If you’re
curious, Wikipedia has some articles on the top:
Total order
Partially ordered set
Partial equivalence relation
Equivalence relation
For us, the important bit is:
If you want to use == and !=, you need to derive the PartialEq trait
If you derive the PartialEq trait, and are allowed to derive the Eq trait,
you should derive that one too
If you want to use the comparison operators, you need to derive both the
PartialEq and PartialOrd traits
If you derive those two traits and are allowed to derive the Eq and Ord
traits, you should derive those two as well
Enough theory, let’s see some of this in practice:

▪
▪
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
struct Person {
    name: String,
    age: u32,
}
fn main() {
    let alice = Person {
        name: "Alice".to_owned(),
        age: 30,
    };
    let also_alice = alice.clone();
    assert_eq!(alice, also_alice);
    assert!(alice >= also_alice);
    assert!(alice <= also_alice);
    let bob = Person {
        name: "Bob".to_owned(),
        age: 25,
    };
    assert_ne!(alice, bob);
    // What do you think is bigger, Alice or Bob?
    println!("{:?} > {:?} == {}", alice, bob, alice > bob);
}
Most of that is pretty straightforward. A Person equals another Person if
the name and age are the same. Fair enough. But how do you compare if one
Person is bigger than another? The rule that Rust’s deriving uses is:
Compare one field at a time
The earlier the field is defined, the more important it is

In our case, name is defined before age, so we compare on the name first.
Since Bob would come later in the dictionary than Alice (since B comes
after A), it’s considered bigger. Therefore, alice > bob is false.

EXERCISE
Change the order the fields are defined above, and see if alice is bigger than bob now.

13.9. Using traits from std
Inside the std crate, there’s a module called ops. Most of the operators we
use, like + or *, are backed up by traits in that module. This allows us to use
these operators on lots of different types. It also means that, if we feel like it,
we can bypass the operators and use trait methods directly instead. However,
we’re going to run into a new restriction, which is exactly why we’re
discussing this topic now.
Let’s try to add two numbers together using the add method:
fn main() {
    let x = 2_i32.add(3);
    println!("x == {}", x);
}
This produces an error message:
error[E0599]: no method named `add` found for type `i32` in the 
current scope
 --> src/main.rs:2:19
  |
2 |     let x = 2_i32.add(3);
  |                   ^^^ method not found in `i32`
  |
  = help: items from traits can only be used if the trait is in 
scope
help: the following trait is implemented but not in scope; perhaps 
add a `use` for it:
  |
1 | use std::ops::Add;
  |

This is one of those times that the error message says it all. But I’ll say it
again anyway! You can only use a trait method if the trait itself is in scope. In
the case of traits, you bring them in scope by using a use. In this case, the
compiler has a good idea of which trait we were trying to use, and so it gives
a nice recommendation.

EXERCISE
Fix the program above by adding the use recommended by the error message. Play around and
see where you’re allowed to add that use.
You may be wondering: why were we able to use other trait methods before
without pulling them into scope? For example, how did we get away with
to_string and to_owned? The answer is that those traits are in
something called the prelude. The prelude is a module that contains a bunch
of commonly used things, and is in scope automatically. That’s why we’re
able to get away with using things like String without having to say the
full std::ops::String name.

13.10. Multiple bounds
I want to write a function info that prints out some information about a
number. It’s easier if I just show it to you:
trait Double {
    fn double(self) -> Self;
}
impl Double for i32 {
    fn double(self) -> i32 { self * 2 }
}
fn info(x: i32) {
    println!("Original number: {}", x);
    println!("Doubled number: {}", x.double());
    println!("Quadrupled number: {}", x.double().double());
}
fn main() {
    info(5);
}
Since our info is defined in terms of the double method only, though, it
seems like we should be able to parameterize. Try changing the signature
from i32 to a type parameter:
fn info<T: Double>(x: T)
This generates an error message:
error[E0277]: `T` doesn't implement `std::fmt::Display`
  --> src/main.rs:10:37
   |

9  | fn info<T: Double>(x: T) {
   |         -- help: consider further restricting this bound: `T: 
std::fmt::Display +`
10 |     println!("Original number: {}", x);
   |                                     ^ `T` cannot be formatted 
with the default formatter
   |
   = help: the trait `std::fmt::Display` is not implemented for 
`T`
   = note: in format strings you may be able to use `{:?}` (or 
{:#?} for pretty-print) instead
   = note: required by `std::fmt::Display::fmt`
Oh, of course! We tried to use println! to print a T, but we don’t know
that T implements std::fmt::Display. But we already have a trait
bound on T: the Double trait. Can we add two trait bounds on a type
parameter? Absolutely! We just add them together.
fn info<T: Double + std::fmt::Display>(x: T)
Even this generates an error message:
error[E0382]: use of moved value: `x`
  --> src/main.rs:12:39
   |
9  | fn info<T: Double + std::fmt::Display>(x: T) {
   |         -                              - move occurs because 
`x` has type `T`, which does not implement the `Copy` trait
   |         |
   |         consider adding a `Copy` constraint to this type 
argument
10 |     println!("Original number: {}", x);
11 |     println!("Doubled number: {}", x.double());
   |                                    - value moved here
12 |     println!("Quadrupled number: {}", x.double().double());
   |                                       ^ value used here after 
move

That’s because the double method moves the value passed in. This worked
just fine when we were working with i32, since it implements the Copy
trait. But it fails with T, since we don’t know that T is copyable.

EXERCISE
Fix the program above by adding the Copy trait as a bound on T.
It may start to feel a little cramped with all of those trait bounds in the type
parameter list. Rust allows for an alternative way of writing trait bounds:
using a where clause. It’s easier to just show it:
fn info<T>(x: T)
where
    T: Double + std::fmt::Display + Copy,
{
    println!("Original number: {}", x);
    println!("Doubled number: {}", x.double());
    println!("Quadrupled number: {}", x.double().double());
}
When should you use a where versus putting the trait bounds in the
parameter list? It’s mostly a matter of style. I’d say a good rule of thumb is if
you have more than two trait bounds, you should switch to a where clause.

13.11. Associated types
I want to calculate how far my car will travel in 3 hours if it’s going at a
certain speed. I live in a country that uses the metric system, so I’m going to
define two helper structs: Kmh (kilometers per hour) and Km (kilometers).
#[derive(Debug, Clone, Copy)]
struct Kmh {
    value: u32
}
#[derive(Debug, Clone, Copy)]
struct Km {
    value: u32
}
Defining a struct with a single field like this is a great way to protect against
programmer error. Now it’s impossible to accidentally compare Kmh (a unit
of speed) against Km (a unit of distance). In any event, I can now write a
method on Kmh to tell me how far my car has gone in three hours:
impl Kmh {
    fn in_three_hours(&self) -> Km {
        Km { value: self.value * 3 }
    }
}
And then you can use this in main:
fn main() {
    let speed = Kmh { value: 90 };
    let distance = speed.in_three_hours();
    println!("At {:?}, you will travel {:?} in 3 hours", speed, 

distance);
}
But my friends who live in the United States are out of luck. They don’t
know what a kilometer is. They want to know about miles. We’re nice guys
here, so we’ll help them out.

EXERCISE
Write the structs Mph and Miles and a in_three_hours method on the Mph struct. Then
use them in main.
It feels a bit weird that we have these two almost mirror implementations
without unifying them. It seems like a perfect use case for a trait. Let’s try
and define a InThreeHours trait:
trait InThreeHours {
    fn in_three_hours(&self) -> Km;
}
impl InThreeHours for Kmh {
    fn in_three_hours(&self) -> Km {
        Km { value: self.value * 3 }
    }
}
This works fine for Kmh. But it hardcodes the return type from
in_three_hours to Km. This won’t work for Mph. We need some way to
let the distance type be different based on which speed type we’re using. And
fortunately, we can do just that with associated types. Associated types say
"this other type is somehow associated via this trait." Let’s see it in practice:
trait InThreeHours {
    type Distance;
    fn in_three_hours(&self) -> Self::Distance;
}

We define a new trait item called Distance. This type is associated with
the type we’re defining the trait for. We can then refer to it in the body of the
trait definition via Self::Distance.
Inside our implementations of this trait, we also need to provide a definition
of this type. Fortunately, that’s fairly straightforward:
impl InThreeHours for Kmh {
    type Distance = Km;
    fn in_three_hours(&self) -> Km {
        Km { value: self.value * 3 }
    }
}
impl InThreeHours for Mph {
    type Distance = Miles;
    fn in_three_hours(&self) -> Miles {
        Miles { value: self.value * 3 }
    }
}
By stating type Distance = Km;, we’re saying "the Distance type
associated with Kmh is Km."

EXERCISE
1. Put all of this code together with a working main function and make sure it compiles and
runs
2. Modify the implementations so that instead of -> Km 
and -> Miles, it uses
Self::Distance
Associated types appear quite a bit in the Rust standard library. They are part
of the arithmetic operations (like + and *). They play a big role in the
Iterator trait, which we’ll see in a later lesson. They may not be the first
tool you reach for in your day to day Rust coding, but they allow for a lot of
really great code.

▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
13.12. Summary
Traits define behavior that can be implemented by lots of different types
You can put restrictions on type parameters by adding trait bounds
Trait bounds can be added for functions, impl blocks, and more
The Display trait is used by println!, format!, and related macros
A number of common traits can be derived, so you don’t have to write
them by hand
Clone is a derivable trait that lets you make a copy
Copy is a derivable marker trait that tells the compiler "it’s really cheap to
clone"
Debug is a derivable trait that produces output useful for debugging your
code
PartialEq and Eq control the == and != operators
PartialOrd and Ord control the four other comparison operators
In order to use a trait, the trait must be in scope
You can bring a trait into scope with use
You can place multiple bounds on a type paramter by using +
Traits can define associated types

13.13. Exercises
1. We previously had the program below, and said that we would be polite
and not mention someone’s age. Modify the greet function so that it
says how old the person is.
struct Person<Name, Age> {
    name: Name,
    age: Age,
}
fn greet<Age>(person: &Person<String, Age>) {
    println!("Hello, {}", person.name);
}
fn main() {
    let alice: Person<String, u32> = Person {
        name: "Alice".to_owned(),
        age: 30_u32,
    };
    greet(&alice);
    let bob = Person {
        name: "Bob".to_owned(),
        age: 35_u64,
    };
    greet(&bob);
}
2. Modify the program above so that greet works for more than just a
String for the name. You can test it with this main function:
fn main() {
    let alice = Person {
        name: "Alice".to_owned(),

        age: 30_u32,
    };
    greet(&alice);
    let bob = Person {
        name: "Bob",
        age: 35_u64,
    };
    greet(&bob);
}
3. Modify the add_one method to take a &mut self and modify the
value in place. You’ll need to change the trait method’s parameter list
and return type, the two trait implementations, and the call site inside the
older method.
struct Person<Name, Age> {
    name: Name,
    age: Age,
}
impl<Name, Age> Person<Name, Age>
where
    Name: std::fmt::Display,
    Age: std::fmt::Display,
{
    fn greet(&self) {
        println!("Hello, {}. You are {} years old.", 
self.name, self.age);
    }
}
trait AddOne {
    fn add_one(&self) -> Self;
}
impl AddOne for u32 {
    fn add_one(&self) -> Self {

        self + 1
    }
}
impl AddOne for u64 {
    fn add_one(&self) -> Self {
        self + 1
    }
}
impl<Name, Age: AddOne> Person<Name, Age> {
    fn older(&mut self) {
        self.age = self.age.add_one();
    }
}
fn main() {
    let mut alice: Person<String, u32> = Person {
        name: "Alice".to_owned(),
        age: 30_u32,
    };
    alice.older();
    alice.greet();
    let mut bob: Person<String, u64> = Person {
        name: "Bob".to_owned(),
        age: 35_u64,
    };
    bob.older();
    bob.greet();
}
4. Modify 
the stringify function (without modifying the main
function) to use type parameters and trait bounds and make this program
print Success!:
fn stringify(x: i32) -> String {
    format!("{}", x)

}
fn main() {
    assert_eq!(stringify(5), "5".to_owned());
    assert_eq!(stringify(true), "true".to_owned());
    assert_eq!(stringify("Hello"), "Hello".to_owned());
    println!("Success!");
}
5. Write a Double trait and implementations for enough types so that the
following works:
fn main() {
    assert_eq!(10, 5_i32.double());
    assert_eq!(10, 5_i64.double());
    println!("Success!");
}
6. A previous exercise had you write a reverse function, that was
specialized to slices of i32s. Now that we know about type parameters
and traits, generalize the reverse function below so that the program
will succeed.
fn reverse(numbers: &[i32]) -> Vec<i32> {
    let mut res = vec![];
    let mut i = numbers.len();
    while i > 0 {
        i -= 1;
        res.push(numbers[i]);
    }
    res
}
fn main() {
    assert_eq!(reverse(&[4, 5, 2, 8]), &[8, 2, 5, 4]);
    assert_eq!(reverse(&[true, false, true, false]), &[false, 

true, false, true]);
    assert_eq!(reverse(&[(), ()]), &[(), ()]);
    println!("Success!");
}

14. ENUMS
We’ve seen primitive types, like i32, bool, or str. We’ve seen structs,
which let you create more complex types by combining together other types.
Now it’s time to introduce a third kind of types: enums, which let you create
something which maybe be one of many different things. We’ll start with
simple examples, then build up more sophisticated cases.

14.1. Get me a job
We’ve played around with a struct called Person for a while now.
We’ve given this person fields like name and age. Let’s add a new field: the
person’s job. The question is: how do we represent a job? One way would be
to use a String:
struct Person {
    name: String,
    age: u32,
    job: String,
}
The problem with this kind of approach is it allows anything to end up in the
job field. Maybe this is good in some cases. But in many cases, it would be
nicer to limit the list of allowed values significantly. For example, let’s say
that the only jobs we care about are teachers and scientists. What we’d like to
have is a way to say "the job can be only one of these choices." And
fortunately, Rust has a way to do exactly that.
enum is short for enumeration, which means "a way to list things." An enum
creates a new type, just like a struct does. However, unlike a struct, an
enum has a bunch of different variants which it can be. Let’s see our first
example:
enum Job {
    Teacher,
    Scientist,
}

Now we have a type called Job. That Job can be one of two different
things: the variant Teacher, or the variant Scientist. We can use this
when we define the Person struct:
struct Person {
    name: String,
    age: u32,
    job: Job,
}
In order to create a Job value, we need to use one of the variants. We’re
going to use the :: operator to access the variants that are inside of the Job
type. Let’s see this in practice:
fn main() {
    let alice = Person {
        name: "Alice".to_owned(),
        age: 30,
        job: Job::Scientist,
    };
}
Just like with a struct, we can use #[derive(… )] to derive trait
implementations. An obvious one here would be to derive PartialEq and
Eq to see if two jobs are the same:
#[derive(PartialEq, Eq)]
enum Job {
    Teacher,
    Scientist,
}
And now we can use the == and != operators on Job values.

EXERCISE
Implement the same_job method so that the program below succeeds.
#[derive(PartialEq, Eq)]
enum Job {
    Teacher,
    Scientist,
}
struct Person {
    name: String,
    age: u32,
    job: Job,
}
impl Person {
    fn same_job(&self, other: &Person) -> bool {
        unimplemented!()
    }
}
fn main() {
    let alice = Person {
        name: "Alice".to_owned(),
        age: 30,
        job: Job::Scientist,
    };
    let bob = Person {
        name: "Bob".to_owned(),
        age: 35,
        job: Job::Scientist,
    };
    let charlie = Person {
        name: "Charlie".to_owned(),
        age: 40,
        job: Job::Teacher,
    };

    assert!(alice.same_job(&bob));
    assert!(!alice.same_job(&charlie));
    println!("Success!");
}

14.2. Using variants
In some cases, having to remember to put Job:: in front of all the variants
can be annoying. If you want, you can use the use statement to bring the
variants into scope. For example, we can rewrite the main function from the
exercise above as:
fn main() {
    use Job::Scientist;
    use Job::Teacher;
    let alice = Person {
        name: "Alice".to_owned(),
        age: 30,
        job: Scientist,
    };
    let bob = Person {
        name: "Bob".to_owned(),
        age: 35,
        job: Scientist,
    };
    let charlie = Person {
        name: "Charlie".to_owned(),
        age: 40,
        job: Teacher,
    };
    assert!(alice.same_job(&bob));
    assert!(!alice.same_job(&charlie));
    println!("Success!");
}
Since having to write a separate use for each variant is annoying, there are
some shortcuts available too. You can rewrite this:

use Job::Scientist;
use Job::Teacher;
as:
use Job::{Scientist, Teacher};
Alternatively, you can say "just give me all the variants" with the special *
operator:
use Job::*;
When you later start working with more crates and modules, being able to
use things like this will become even more helpful.

▪
▪
14.3. Pattern matching
Let’s write a function to produce a greeting for someone based on their job.
Here’s one naive approach using if/else:
impl Person {
    fn greeting(&self) -> String {
        if self.job == Job::Teacher {
            format!("Hello, you're a teacher named {}", self.name)
        } else if self.job == Job::Scientist {
            format!("Hello, you're a scientist named {}", 
self.name)
        } else {
            format!("Huh, this shouldn't be possible...")
        }
    }
}
There are two problems with this approach:
I had to add a bogus else clause at the end to handle the possibility that
the person is neither a teacher nor a scientist. However, we know that can
never happen! Nonetheless, if I leave that off, the compiler complains.
That’s annoying.
If in the future you decide to add a new job (maybe a plumber), you may
end up forgetting to update this method.
Fortunately, there’s a much better way to do this: using a match expression.
Let’s first see it in practice:
match self.job {
    Job::Teacher => {

        format!("Hello, you're a teacher named {}", self.name)
    },
    Job::Scientist => {
        format!("Hello, you're a scientist named {}", self.name)
    },
}
This looks pretty different from other expressions we’ve seen, so let’s break
down the structure. We start with the word match, followed by an
expression we want to look at. This expression is known as the scrutinee,
since we’re scrutinizing it to see what it matches. In our case, we’re
scrutinizing the expression self.job. Next, we use a pair of brackets to
contain the body of the match. Within the brackets, we have the arms of the
match.
Each arm is a combination of a pattern, the => symbol (sometimes called a
fat arrow), and an expression. The pattern is something we are trying to
match the scrutinee against. When we find the matching pattern, the match
expression itself evaluates to the expression related to that pattern.
Or, said much more simply, Job::Teacher has an arrow => pointing at an
expression. If the pattern matches, then we use that expression. If it doesn’t,
we try the next pattern.
Anyway, this is where the power of an enum really comes into play. The
compiler knows that self.job has type Job. It also knows that there are
only 
two 
possible 
options 
for 
that 
value: Job::Teacher and
Job::Scientist. If you try to put a different pattern in there, it will

▪
▪
complain. If you try to leave one of those patterns out, it will complain. This
addresses both of our concerns above:
With a match, there’s no need for the bogus else clause.
If you add another variant to the Job type, then the compiler will tell you
to add another arm to the match expression.

EXERCISE
Modify the Job enum below to include a third job, maybe Chef, and see what error message
you get. Then fix that error message.
enum Job {
    Teacher,
    Scientist,
}
struct Person {
    name: String,
    age: u32,
    job: Job,
}
impl Person {
    fn greeting(&self) -> String {
        match self.job {
            Job::Teacher => {
                format!("Hello, you're a teacher named {}", 
self.name)
            },
            Job::Scientist => {
                format!("Hello, you're a scientist named {}", 
self.name)
            },
        }
    }
}
fn main() {
    let alice = Person {
        name: "Alice".to_owned(),
        age: 30,
        job: Job::Chef,
    };
    println!("{}", alice.greeting());

}

14.4. Commas and braces
There are some funny details about the arms of a match expression worth
covering. We saw one way of writing them above: the expressions were
blocks (surrounded by their own expressions), and they had commas after
each block. As a reminder:
match self.job {
    Job::Teacher => {
        format!("Hello, you're a teacher named {}", self.name)
    },
    Job::Scientist => {
        format!("Hello, you're a scientist named {}", self.name)
    },
}
There are two legal ways you can change this. In our case, we don’t have any
statements inside those blocks, and so the blocks aren’t needed at all. Instead,
we can write the above as:
match self.job {
    Job::Teacher => format!("Hello, you're a teacher named {}", 
self.name),
    Job::Scientist => format!("Hello, you're a scientist named 
{}", self.name),
}
This is the most common way to write a match when the expressions are
simple. However, there’s another tweak you can make: when the expressions
are blocks, the commas are optional. If it helps you feel comfortable with it,
think of it as being similar to how putting a semicolon after an expression
statement is optional if the expression is a block. This looks like:

match self.job {
    Job::Teacher => {
        format!("Hello, you're a teacher named {}", self.name)
    }
    Job::Scientist => {
        format!("Hello, you're a scientist named {}", self.name)
    }
}
In other words, in our code above, you can remove the commas or you can
remove the braces. However, you can’t remove both.

EXERCISE
Try mixing these two styles, and having one block expression and one with a comma.
㇀
The last comma in a set of arms is always optional, even if it’s not a block expression.
Rust allows you to add the extra optional comma to make it easier to add more arms later.
This same rule applies to most cases of commas, such as in array expressions. I
recommend keeping that extra comma.

14.5. More teachers
I’m not happy with just talking about teachers. I want to know if the teacher
is teaching math or art. Fair enough: let’s rewrite our Job type as:
enum Job {
    ArtTeacher,
    MathTeacher,
    Scientist,
}
This works, but I don’t like it that much. And I’ll give you two reasons why.
First, let’s say that I want to write a method is_teacher. With the enum
above, I can write something like:
impl Person {
    fn is_teacher(&self) -> bool {
        match self.job {
            Job::ArtTeacher => true,
            Job::MathTeacher => true,
            Job::Scientist => false,
        }
    }
}
As I started adding physics, economics, and other teachers, this is just going
to keep growing. I don’t like that. There’s nothing in the Job enum telling
me that there’s some relationship between an ArtTeacher and a
MathTeacher. Next, let’s say that I want to create a student type with the
student’s subject. This might look something like:
enum Student {

    ArtStudent,
    MathSudent,
}
Now I have to maintain the list of subjects in two places. And there’s no way
to connect an ArtTeacher with an ArtStudent automatically. In order
to solve this nicely, we want to have more powerful enums. Up until now, an
enum is just a collection of variants. But it turns out we can make our
variants more powerful, by giving them fields. Let’s see what this looks like:
enum Subject {
    Art,
    Math,
}
enum Job {
    Teacher(Subject),
    Scientist,
}
struct Person {
    name: String,
    age: u32,
    job: Job,
}
We’ve defined a new enum called Subject, which has two variants: Art
and Math. Those variants have no fields, just like our previous Job enum.
And the Scientist variant of Job still has no fields. But the Teacher
variant is different: it now has a single field called Subject.
Now let’s use this new field in a method. Inside an impl Person, we can
create 
a greeting method like before. However, our patterns for

Teacher are now going to include the subject:
fn greeting(&self) -> String {
    match self.job {
        Job::Teacher(Subject::Art) => {
            format!("Hello, you're an art teacher named {}", 
self.name)
        }
        Job::Teacher(Subject::Math) => {
            format!("Hello, you're a math teacher named {}", 
self.name)
        }
        Job::Scientist => {
            format!("Hello, you're a scientist named {}", 
self.name)
        }
    }
}
And we can now more easily write our is_teacher method. To do this,
we’ll use a wildcard pattern, which will simply match anything, to represent
the idea that "I don’t care which subject the teacher is teaching." We use the
underscore _ symbol for that:
fn is_teacher(&self) -> bool {
    match self.job {
        Job::Teacher(_) => true,
        Job::Scientist => false,
    }
}

EXERCISE
Create a new enum called Science, with variants Physics and Biology. Then give a
scientist a field of type Science. Modify the greeting and is_teacher methods to
handle those cases. You can test this with a main function like the following:
fn main() {
    let rick = Person {
        name: "Rick".to_owned(),
        age: 60,
        job: Job::Scientist(Science::Physics),
    };
    assert!(!rick.is_teacher());
    assert_eq!(
        "Hello, you're a physicist named Rick".to_owned(),
        rick.greeting(),
    );
    println!("Success, I'm pickle Rick!");
}
By the way, we’re not limited to having a single field for each variant. You
can have a comma separated list of fields. For example, in the United States
Congress, members are either representatives from a specific state and district
number, or a senator from a state, which is either junior or senior. We can
represent that in Rust as:
enum CongressPerson {
    Representative(State, District),
    Senator(State, Seniority),
}
enum State {
    Alabama,

    Alaska,
    // this could take a while
    Wyoming,
}
struct District {
    number: u32,
}
enum Seniority {
    Junior,
    Senior,
}

14.6. Methods for enums
In the previous sections, we had impl blocks set up for the Person
struct. You’re just as easily able to write an impl for an enum:
impl Job {
    fn is_teacher(&self) -> bool {
        match self {
            Job::Teacher(_) => true,
            Job::Scientist => false,
        }
    }
}
And, for that matter, we can implement traits for enums.

EXERCISE
Add the missing trait implementations to the example below so that we can call is_teacher
on both Job and Person. Bonus points: only use a single match expression by having one of
the trait implementations call the other one.
enum Subject {
    Art,
    Math,
}
enum Job {
    Teacher(Subject),
    Scientist,
}
trait IsTeacher {
    fn is_teacher(&self) -> bool;
}
struct Person {
    name: String,
    age: u32,
    job: Job,
}
fn main() {
    assert!(Job::Teacher(Subject::Math).is_teacher());
    assert!(!Job::Scientist.is_teacher());
    let alice = Person {
        name: "Alice".to_owned(),
        age: 30,
        job: Job::Teacher(Subject::Math),
    };
    assert!(alice.is_teacher());
    println!("Success!");
}


14.7. Optional results
The Loch Ness monster lives in Scotland. Dracula lives in Transylvania. But
no one knows where Bigfoot or aliens live. Let’s write some code for this:
enum Monster {
    LochNess,
    Dracula,
    Bigfoot,
    Alien,
}
enum Place {
    Scotland,
    Transylvania,
}
impl Monster {
    fn lives(&self) -> Place {
        use Monster::*;
        use Place::*;
        match self {
            LochNess => Scotland,
            Dracula => Transylvania,
        }
    }
}
This won’t compile. We haven’t handled the cases of bigfoot and alien. The
compiler tells us this:
error[E0004]: non-exhaustive patterns: `&Bigfoot` and `&Alien` not 
covered
  --> src/main.rs:20:15
   |

2  | / enum Monster {
3  | |     LochNess,
4  | |     Dracula,
5  | |     Bigfoot,
   | |     ------- not covered
6  | |     Alien,
   | |     ----- not covered
7  | | }
   | |_- `Monster` defined here
...
20 |           match self {
   |                 ^^^^ patterns `&Bigfoot` and `&Alien` not 
covered
   |
   = help: ensure that all possible cases are being handled, 
possibly by adding wildcards or more match arms
We need to give some response for those other monsters. One possibility
would be to add an Unknown variant to Place:
enum Place {
    Scotland,
    Transylvania,
    Unknown,
}
match self {
    LochNess => Scotland,
    Dracula => Transylvania,
    Bigfoot => Unknown,
    Alien => Unknown,
}
But this doesn’t feel quite right: Unknown isn’t a place like Scotland.
We’re mixing up two different concepts. Instead, the Rust way to handle this
would be with an extra wrapper enum type, like this:

enum Place {
    Scotland,
    Transylvania,
}
enum OptionalPlace {
    Known(Place),
    Unknown,
}
impl Monster {
    fn lives(&self) -> OptionalPlace {
        use Monster::*;
        use Place::*;
        use OptionalPlace::*;
        match self {
            LochNess => Known(Scotland),
            Dracula => Known(Transylvania),
            Bigfoot => Unknown,
            Alien => Unknown,
        }
    }
}
Cool, that works. Now let’s talk about the food our monsters eat. Dracula eats
blood, and aliens eat cows (I guess). But we don’t know about the other two
monsters. We can write up two new enums to help:
enum Food {
    Blood,
    Cows,
}
enum OptionalFood {
    Known(Food),
    Unknown,
}

But our OptionalFood and OptionalPlace look really similar! It
would be nice if there was some way to unify them into a single type. And
thinking back to type parameters, we can try using a type parameter and
creating an Optional enum:
enum Optional<T> {
    Known(T),
    Unknown,
}
fn lives(&self) -> Optional<Place> {
    use Monster::*;
    use Place::*;
    use Optional::*;
    match self {
        LochNess => Known(Scotland),
        Dracula => Known(Transylvania),
        Bigfoot => Unknown,
        Alien => Unknown,
    }
}
In fact, this kind of thing is so common in Rust, that the std crate and its
prelude provide an enum for this purpose out of the box. It’s called Option,
and it has two variants: Some (like our Known) and None (like our
Unknown). Rewriting our lives method to use it makes our code more
idiomatic (or normal) Rust:
fn lives(&self) -> Option<Place> {
    use Monster::*;
    use Place::*;
    match self {

        LochNess => Some(Scotland),
        Dracula => Some(Transylvania),
        Bigfoot => None,
        Alien => None,
    }
}
㇀
Very astute readers may be asking: why did we get to say Some instead of
Option::Some. There’s no use Option::*; statement! The answer is that
Option, Some, and None are such common parts of Rust programming that the
prelude automatically adds the use for all three of them.

EXERCISE
Implement the eats method so that the program below succeeds. Don’t modify the main
function.
enum Monster {
    LochNess,
    Dracula,
    Bigfoot,
    Alien,
}
#[derive(PartialEq, Eq, Debug)]
enum Food {
    Blood,
    Cows,
}
impl Monster {
    // FIXME add eats here
}
fn main() {
    use Monster::*;
    use Food::*;
    assert_eq!(Dracula.eats(), Some(Blood));
    assert_eq!(Alien.eats(), Some(Cows));
    assert_eq!(Bigfoot.eats(), None);
    assert_eq!(LochNess.eats(), None);
}

▪
▪
14.8. Capturing with match
Previously, we did two different things with fields during a match
expression:
Matched on them, e.g. Teacher(Art)
Used a wild card and ignored them, e.g. Teacher(_)
There’s another highly useful thing you can do: capture the field’s value in a
variable. Then you can use that variable inside the expression. It’s easiest to
see this in an example. So behold my power levels!
enum Hero {
    Goku,
    Vegeta,
    Superman,
}
impl Hero {
    fn power_level(&self) -> Option<u32> {
        match self {
            Hero::Goku => Some(9001),
            Hero::Vegeta => Some(18000),
            Hero::Superman => None,
        }
    }
    fn name(&self) -> &'static str {
        match self {
            Hero::Goku => "Goku",
            Hero::Vegeta => "Vegeta",
            Hero::Superman => "Superman",
        }
    }

    fn print_power(&self) {
        match self.power_level() {
            None => {
                println!("I don't know {}'s power level", 
self.name());
            }
            Some(level) => {
                println!("{}'s power level is {}", self.name(), 
level);
            }
        }
    }
}
fn main() {
    Hero::Goku.print_power();
    Hero::Vegeta.print_power();
    Hero::Superman.print_power();
}
The important bit is right here:
Some(level) => {
    println!("{}'s power level is {}", self.name(), level);
}
We capture the power level value inside the level variable, and then use it
in the println! macro call.

▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
▪
14.9. Summary
An enum creates a new data type
An enum data type can have different variants
Each enum value is always one of those variants
The variants can have 0 or more fields
Using the match expression, you can pattern match against values to
determine which variant you’re using
Match arms have a pattern, a fat arrow =>, and an expression
If your arm’s expression is a block, the comma following the block is
optional
enums can have impl blocks, trait implementations, and can derive traits
enums can have type parameters
A common pattern in Rust is to use the Option<T> enum to represent an
optional result
Using match expressions, you can capture the values in fields into a
variable

14.10. Exercises
1. Make the example below compile and print success by defining a Size
enum, adding a necessary #[derive(… )] attribute, and implementing
the vehicle_size function. Do not change the main function.
fn vehicle_size(seats: u32) -> Size {
    unimplemented!()
}
fn main() {
    use Size::*;
    assert_eq!(Small,  vehicle_size(1));
    assert_eq!(Small,  vehicle_size(2));
    assert_eq!(Small,  vehicle_size(3));
    assert_eq!(Medium, vehicle_size(4));
    assert_eq!(Medium, vehicle_size(5));
    assert_eq!(Medium, vehicle_size(6));
    assert_eq!(Medium, vehicle_size(7));
    assert_eq!(Large,  vehicle_size(8));
    assert_eq!(Large,  vehicle_size(9));
    assert_eq!(Large,  vehicle_size(10));
    println!("Success!");
}
2. Write the necessary enums and fill in the implementation of the
salary method so that this program prints success. Do not modify
main.
impl Job {
    fn salary(&self) -> u32 {
        unimplemented!()
    }

}
fn main() {
    use Job::*;
    use School::*;
    use Science::*;
    assert_eq!(Teacher(Elementary).salary(), 100);
    assert_eq!(Teacher(Middle).salary(), 150);
    assert_eq!(Teacher(High).salary(), 200);
    assert_eq!(Scientist(Physics).salary(), 180);
    assert_eq!(Scientist(Biology).salary(), 220);
    assert_eq!(Electrician.salary(), 250);
    println!("Success!");
}
3. I want to write a minus function that subtracts two unsigned numbers. If
the result would be negative, I want to return a None instead. Modify the
result type of minus and its implementation so this program succeeds,
without changing main.
fn minus(x: u32, y: u32) -> u32 {
    x - y
}
fn main() {
    assert_eq!(minus(5, 2), Some(3));
    assert_eq!(minus(3, 2), Some(1));
    assert_eq!(minus(2, 2), Some(0));
    assert_eq!(minus(1, 2), None);
    println!("Success!");
}

15. ITERATORS AND FOR LOOPS
We’ve been using while for looping for a while now. It’s taken a lot of self
restraint to not bring up for loops yet. However, to properly understand
them, you need to know about traits, enums, and Option. Fortunately, now
that we’ve covered these, we can finally use for loops.
Anything you can do with a for loop can also be done with a while loop.
However, as you’ll see shortly, the for loop approach is usually much more
pleasant to work with. You’re about to have a lot of fun simplifying some
code.

▪
◦
▪
▪
▪
15.1. Count to 10
Let’s write a program that’s going to count from 1 to 10 using a while loop.
If you want to take a challenge exercise, implement it yourself before looking
at the code below.
fn main() {
    let mut i = 1;
    while i < 11 {
        println!("i == {}", i);
        i += 1;
    }
}
I don’t like this for a few reasons:
I have to remember to include the i += 1 at the end of the while loop
body. I bet you’ve forgotten that many times yourself.
I don’t like having to think about mutable variables. I told you before that
iteration basically requires mutation. But that doesn’t mean I like writing
let mut i all the time.
Also, the i is mutable inside the body of the while loop. I don’t want
to be able to accidentally mutate that variable.
The i variable is still available after the while loop, holding the number
11, which I never really wanted.
I have to read three lines of code to see the fact that I’m iterating from 1 to
10.

With that backstory, let me show you a for loop solution to the same
problem. Then we’ll dive into understanding how it works:
fn main() {
    for i in 1..11 {
        println!("i == {}", i);
    }
}
This code eliminates all of the complaints I had about the while loop.
Awesome! It’s built up using two new kinds of expressions. Let’s start with
the 1..11 bit first. This is called a range expression. It produces a value that
somehow (we’ll see the details in a bit) represents the numbers starting with 1
and going up to 11, not including the 11.
The range expression is just a convenient way to create a struct called
std::ops::Range. We could rewrite our program above to use that
struct directly:
fn main() {
    let range = std::ops::Range { start: 1, end: 11 };
    for i in range {
        println!("i == {}", i);
    }
}
But the more interesting expression is the for loop itself. You write this
expression by using the word for, followed by a pattern, followed by the
word in, followed by an iterator expression, followed by a block. The
pattern is usually just a variable name, like we had here (the variable i).
We’ll dive into the concept of an iterator expression much more in a second.

The block works much like the block on a while loop: it gets run for each
new value.

EXERCISE
Complete the program below using a for loop to figure out the sum of the numbers between 1
and 10, inclusive.
fn main() {
    let mut total = 0;
    // FIXME add code here
    assert_eq!(total, 55);
    println!("Success!");
}

15.2. Iterators
The engine powering for loops under the hood is the Iterator trait. Let’s
think about what we want to do. Each time we step through the for loop, we
need to get the next item in a stream of values. We need some way to stop
when there are no more items available. And for each Iterator, we need
to know the type of the items. To handle all this, we’re going to use a trait
called Iterator. Let’s look at a simplified version of it:
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}
The type Item; is an associated type saying what items are in the stream
for this specific Iterator implementation. The next method takes a
mutable reference to self, and returns an Option<Self::Item>. This
method can return the Some variant to provide the next item in the stream,
and None if there are no values left. And it can also mutate the Iterator
value itself.
Let’s go ahead and write our own Iterator that can iterate through the
numbers 1 to 10 to see this in practice.
struct OneToTen {
    // This will be the next value when we call next
    next_val: u32,
}
impl OneToTen {

    // Start off at 1
    fn new() -> Self {
        OneToTen { next_val: 1 }
    }
}
impl Iterator for OneToTen {
    // Creating a stream of u32 values
    type Item = u32;
    // Could also be -> Option<u32>
    fn next(&mut self) -> Option<Self::Item> {
        if self.next_val > 10 {
            // Already got to 10, stop
            None
        } else {
            // Capture the current value in a variable
            let result = Some(self.next_val);
            // Increase the next value by 1. This is where we
            // see mutation happening.
            self.next_val += 1;
            // Return the previously captured value.
            result
        }
    }
}
fn main() {
    let mut total = 0;
    // Works just like 1..11
    for i in OneToTen::new() {
        total += i;
    }
    assert_eq!(total, 55);
    println!("Success!");
}

EXERCISE
Following the basic idea of the example above, write an iterator called TenToOne that counts
down from 10 to 1.

15.3. Inclusive range expressions
This is little more than a footnote, but a potentially useful one. We’ve so far
seen for i in 1..11 to mean "iterate the numbers starting with 1 and
ending just before 11." That’s what we call an exclusive range, since it
excludes the final value (11) from being iterated. There’s also something
called an inclusive range, which looks like this:
for i in 1..=10
That = converts the range into something inclusive, and has the exact same
meaning as 1..11. Which one you use depends on your personal preference.
You’ll end up seeing both in the wild, so it’s worth being aware of both of
them.

▪
▪
15.4. Iterating over a Vec
To build up our practice with Iterator, and to build some understanding
for the next section on IntoIterator, let’s write an Iterator for a
Vec. What we’re going to need is a struct that holds onto two values:
The Vec we’re iterating over
The next position in the Vec we want to look at
If you remember from covering Vecs and slices, the data type we use for
indexing in a Vec is a usize (machine sized unsigned integer). So we can
write our VecIter as:
struct VecIter {
    vec: Vec<u32>,
    index: usize,
}
Implementing Iterator for this type involves comparing the index field
against the length of the Vec:
impl Iterator for VecIter {
    type Item = u32;
    fn next(&mut self) -> Option<u32> {
        if self.index >= self.vec.len() {
            None
        } else {
            let res = Some(self.vec[self.index]);
            self.index += 1;
            res
        }

    }
}
And then we can use this iterator in our main function:
fn main() {
    let fibs: Vec<u32> = vec![1, 1, 2, 3, 5, 8, 13];
    let iter = VecIter {
        vec: fibs,
        index: 0,
    };
    for x in iter {
        println!("{}", x);
    }
}

EXERCISE
Generalize the VecIter struct to work on more than just a u32. You’ll need to include a
trait bound to make the code compile.

15.5. IntoIterator
Here’s an important takeaway from our VecIter above: a Vec on its own
doesn’t have enough information to be iterated over. We need to know the
current position in the iteration, and a Vec doesn’t have that information.
Therefore, it’s impossible to have an Iterator implementation for Vec.
And sure enough, there is no such implementation available. We can even
demonstrate that by trying to use the next method directly on a Vec:
fn main() {
    let mut fibs: Vec<u32> = vec![1, 1, 2, 3, 5, 8, 13];
    Iterator::next(&mut fibs);
}
This produces the error message:
error[E0277]: `std::vec::Vec<u32>` is not an iterator
 --> src/main.rs:4:20
  |
4 |     Iterator::next(&mut fibs);
  |                    ^^^^^^^^^ `std::vec::Vec<u32>` is not an 
iterator
  |
  = help: the trait `std::iter::Iterator` is not implemented for 
`std::vec::Vec<u32>`
  = note: required by `std::iter::Iterator::next`
Thankfully, Rust has got our backs on this one. In addition to the Iterator
trait, 
there’s another trait that’s actually used by for expressions.
IntoIterator is a trait for things that can be converted into Iterators.

And fortunately, many things (including Vecs) have implementations of
IntoIterator. So instead of all of the runaround with VecIter above,
we can write something much more direct to iterate over a Vec:
fn main() {
    let fibs: Vec<u32> = vec![1, 1, 2, 3, 5, 8, 13];
    for x in fibs {
        println!("{}", x);
    }
}
This may seem a bit convoluted, but it plays into one of the design goals for
Rust: ergonomics. Ergonomics means that it should be easy to use the
language on a day to day basis. That means that sometimes, the language
design includes some extra-complicated stuff behind the scenes to make other
code really easy to use (such as trivially iterating over Vecs). Most of the
time, this extra complexity gets hidden away from you. In those cases, you
get to happily run along writing simpler code.
Every once in a while, though, that complexity pops up and you have to deal
with it. So it’s important to understand what’s happening under the surface.

15.6. The rule of 3
There are three different ways to pass a value into a function: move it, pass
by reference, and pass by mutable reference. We see this in method calls as
self, &self, and &mut self. This pattern of 3 appears in more places in
Rust, including in iterators.
Let’s say we want to iterate over a Vec, and then use it again. Perhaps we’d
write some code like this:
fn main() {
    let fibs = vec![1, 1, 2, 3, 5, 8, 13];
    for x in fibs {
        println!("{}", x);
    }
    println!("{:?}", fibs);
}
Unfortunately, this is going to fail:
error[E0382]: borrow of moved value: `fibs`
 --> src/main.rs:8:22
  |
2 |     let fibs = vec![1, 1, 2, 3, 5, 8, 13];
  |         ---- move occurs because `fibs` has type 
`std::vec::Vec<i32>`, which does not implement the `Copy` trait
3 |
4 |     for x in fibs {
  |              ----
  |              |
  |              value moved here
  |              help: consider borrowing to avoid moving into the 

for loop: `&fibs`
...
8 |     println!("{:?}", fibs);
  |                      ^^^^ value borrowed here after move
Using a Vec like this moves it into the iterator, and then the Vec can’t be
used again. If we want to be able to reuse fibs, we would need to borrow
the Vec:
fn main() {
    let fibs = vec![1, 1, 2, 3, 5, 8, 13];
    for x in &fibs {
        println!("{}", x);
    }
    println!("{:?}", fibs);
}
There’s a very important difference to be aware of here: the x inside the for
loop is no longer an i32. It’s now a reference to an i32, or a &i32.
But now, let’s say we’d like to use a for loop to modify the values in a Vec.
We might try something like:
fn main() {
    let fibs = vec![1, 1, 2, 3, 5, 8, 13];
    for x in &fibs {
        println!("{}", x);
        *x *= 2;
    }
    println!("{:?}", fibs);
}

This errors out. And in classic Rust fashion, the error message tells us exactly
how to fix it:
error[E0594]: cannot assign to `*x` which is behind a `&` 
reference
 --> src/main.rs:6:9
  |
4 |     for x in &fibs {
  |              ----- help: consider changing this to be a 
mutable reference: `&mut fibs`
5 |         println!("{}", x);
6 |         *x *= 2;
  |         ^^^^^^^ `x` is a `&` reference, so the data it refers 
to cannot be written

▪
▪
▪
▪
▪
▪
EXERCISE
Modify the code above to borrow mutably so that the example works.
So we have three different types of iterators.
On a normal Vec, we get an iterator that moves the Vec and iterates over
the actual values.
On a reference to a Vec, we borrow the Vec and iterate over references to
the values inside it.
On a mutable reference, we mutably borrow the Vec and iterate over
mutable references to the values inside it.
On top of all this, each of these three ways of iterating has a name associated
with it:
into_iter does the move approach
iter does the borrow approach
iter_mut does the mutable borrow approach
In other words, I can rewrite our example above as:
fn main() {
    let mut fibs = vec![1, 1, 2, 3, 5, 8, 13];
    for x in fibs.iter_mut() {
        println!("{}", x);
        *x *= 2;
    }

    println!("{:?}", fibs);
}
Whether you write for x in &vec or for x in vec.iter() is a
matter of taste. The first approach is more commonly used in the Rust world.
I personally prefer the second approach, since it’s a bit more explicit about
what you’re trying to do. But feel free to use either approach.

▪
▪
15.7. Arrays and slices
For some complicated reasons that I don’t personally understand, you can’t
directly iterate over an array. In other words, this code doesn’t compile:
fn main() {
    let fibs = [1, 1, 2, 3, 5, 8, 13];
    for x in fibs {
        println!("{}", x);
    }
}
Fortunately, we have two different approaches to make this code compile:
You can borrow a slice to the array with &, which will give an iterator over
borrowed values.
You can use the .iter() method on the array to get an iterator.
Slices don’t have this restriction, and can be directly iterated over.

EXERCISE
Fix the code above in two different ways.
㇀
Just like there are complicated reasons why you can’t directly iterate over an array, there
are equally complicated reasons why you shouldn’t use .into_iter() on an array. If
you’re curious, go ahead and try using .into_iter() into of .iter().

▪
◦
▪
15.8. Iterating on Strings
Strings and string slices behave a bit strangely with iteration as well. Let’s
have a look at why:
fn main() {
    let name = "Michael";
    for x in name {
        println!("{}", x);
    }
}
This results in the error message:
error[E0277]: `&str` is not an iterator
 --> src/main.rs:4:14
  |
4 |     for x in name {
  |              ^^^^ `&str` is not an iterator; try calling 
`.chars()` or `.bytes()`
  |
  = help: the trait `std::iter::Iterator` is not implemented for 
`&str`
  = note: required by `std::iter::IntoIterator::into_iter`
The issue is that a String can be viewed in two different ways:
A list of characters
A list of bytes in the UTF-8 character encoding of the string
We briefly talked about UTF-8 and character encoding when discussing
Vec originally.

Therefore, Strings and string slices have two different ways of iterating
over them: either the characters themselves using the chars() method, or
the bytes using the bytes() method. We can get our program above to
compile with:
fn main() {
    let name = "Michael";
    for x in name.chars() {
        println!("{}", x);
    }
}

EXERCISE
Put some special characters into the string above, such as a Hebrew letter alef × or an emoji.
Then run the program. Try again with .bytes() instead of .chars() and see what
happens.

15.9. Generic Iterator functions
Let’s write a function that will print out each value in a slice:
use std::fmt::Display;
fn print_them_all<T: Display>(slice: &[T]) {
    for x in slice {
        println!("{}", x);
    }
}
fn main() {
    print_them_all(&[1, 1, 2, 3, 5, 8, 13]);
}
But this function is a bit limiting. For example, even though the for loop
inside print_them_all is happy to work on a range expression, we can’t
use our function that way. In other words, this main function:
fn main() {
    print_them_all(1..11);
}
will result in the error message:
error[E0308]: mismatched types
  --> src/main.rs:10:20
   |
10 |     print_them_all(1..11);
   |                    ^^^^^ expected &[_], found struct 
`std::ops::Range`
   |
   = note: expected type `&[_]`
              found type `std::ops::Range<{integer}>`

Let’s stumble our way through making our function more generic. Let’s start
off by replacing the T type variable and the &[T] function parameter with a
new type parameter, I. This is short for Iterator.
fn print_them_all<I>(iter: I) {
    for x in iter {
        println!("{}", x);
    }
}
This fails with the error message:
error[E0277]: `I` is not an iterator
 --> src/main.rs:4:14
  |
3 | fn print_them_all<I>(iter: I) {
  |                   - help: consider restricting this bound: `I: 
std::iter::Iterator`
4 |     for x in iter {
  |              ^^^^ `I` is not an iterator
Given what we know about trait bounds, that doesn’t seem hard to solve. We
can add a trait bound like so:
fn print_them_all<I: Iterator>(iter: I) {
    for x in iter {
        println!("{}", x);
    }
}
However, we don’t know anything about the item produced by the iterator,
and therefore we don’t know if it has a Display implementation. So the
compiler complains:

error[E0277]: `<I as std::iter::Iterator>::Item` doesn't implement 
`std::fmt::Display`
 --> src/main.rs:5:24
  |
3 | fn print_them_all<I: Iterator>(iter: I) {
  |                                        - help: consider 
further restricting the associated type: `where <I as 
std::iter::Iterator>::Item: std::fmt::Display`
4 |     for x in iter {
5 |         println!("{}", x);
  |                        ^ `<I as std::iter::Iterator>::Item` 
cannot be formatted with the default formatter
What this is saying is that we need to applying a trait bound to the associated
Item type. These are the kinds of cases that start to get a little hairy in
specifying trait bounds. We can get this code to work with:
fn print_them_all<I: Iterator>(iter: I)
where
    I::Item: Display,
{
    for x in iter {
        println!("{}", x);
    }
}
Or, you may find it more convenient to put all of the bounds together in the
where, like this:
fn print_them_all<I>(iter: I)
where
    I: Iterator,
    I::Item: Display,
{
    for x in iter {
        println!("{}", x);

    }
}
However, there’s one more trick you may want to use: the ability to say
exactly what type the item should be. For this, you can use an associated type
binding, and force Item to equal a specific type. For example, to force usage
of i32, we can use the code:
fn print_them_all<I>(iter: I)
where
    I: Iterator<Item=i32>,
{
    for x in iter {
        println!("{}", x);
    }
}
Or, moving this back into the type parameter list:
fn print_them_all<I: Iterator<Item = i32>>(iter: I) {
    for x in iter {
        println!("{}", x);
    }
}

EXERCISE
Make this program compile by changing the sum function to work on any Iterator of u32s.
fn sum(vals: Vec<u32>) -> u32 {
    let mut total = 0;
    for val in vals {
        total += val;
    }
    total
}
fn main() {
    assert_eq!(sum(vec![1, 2, 3, 4].into_iter()), 10);
    assert_eq!(sum(1..=4), 10);
    println!("Success!");
}

▪
▪
▪
▪
◦
◦
◦
▪
▪
▪
▪
15.10. Summary
for loops iterate over the values in an Iterator
Iterator is a trait that represents a stream of values
Range expressions like 1..11 or 1..=10 are one kind of Iterator
Many types provide an IntoIterator implementation, including Vec
and slices
With the rule of 3, you can get:
Moved iterators of values (.into_iter())
Reference iterators (borrow the value, or .iter())
Mutable 
reference 
iterators 
(mutably 
borrow 
the 
value, 
or
.iter_mut())
To iterate on a string slice, you need to choose either .chars() or
.bytes()
You can write generic iterator functions using Iterator as a trait bound
Iterators have a lot more power for the future, allowing a lot of functional
programming

15.11. Exercises
1. Implement a factorial using a for loop.
fn fact(x: u32) -> u32 {
    unimplemented!()
}
fn main() {
    assert_eq!(fact(0), 1);
    assert_eq!(fact(1), 1);
    assert_eq!(fact(2), 2);
    assert_eq!(fact(3), 6);
    assert_eq!(fact(4), 24);
    assert_eq!(fact(5), 120);
    println!("Success!");
}
2. Using for loops, write a function that prints out borders. With the main
function:
fn main() {
    print_border(6, 5);
}
You should get the output:
*****
*   *
*   *
*   *
*   *
*****

3. Use a for loop to write a function which prints the name given to it
vertically. In addition, tell us the position of each letter. Using this main
function:
fn main() {
    print_vertical("Alice");
}
You should get the output:
A = 1 out of 5
l = 2 out of 5
i = 3 out of 5
c = 4 out of 5
e = 5 out of 5
4. The .rev() method call allows us to iterate backwards through an
Iterator. Using this, write a function which prints a name vertically
in reverse order. Using this main function:
fn main() {
    vertical_backwards_name("Alice");
}
You should get the output:
e
c
i
l
A
5. The program below has a missing implementation of average, as well

as a bug due to using a moved value. You’ll need to (a) implement the
average function, (b) change the type signature of the average
function, and (c) change the average function calls.
fn average(scores: Vec<usize>) -> usize {
    unimplemented!()
}
fn main() {
    let physics = vec![53, 64, 73, 36, 96, 100, 45, 81, 88, 
64];
    let biology = vec![68, 29, 87, 34, 89, 95];
    let chemistry = vec![100, 81, 68, 60, 86, 79, 88, 94];
    assert_eq!(average(physics), 70);
    println!("The average score on the physics exam was {}.", 
average(physics));
    assert_eq!(average(biology), 67);
    println!("The average score on the biology exam was {}.", 
average(biology));
    assert_eq!(average(chemistry), 82);
    println!("The average score on the chemistry exam was 
{}.", average(chemistry));
}
Hint: You probably want to use a borrow.

16. EARLY EXIT
Sometimes when we’re programming, we like to exit our loops and functions
early. There are a number of reasons to do it, but a common one is error
handling. When we covered functions and loops before, we skipped over this
ability. We’re going to finally introduce it here. We’re also going to introduce
how error handling works in Rust, which will set you up for interacting with
lots of library functions in the future.

16.1. Time for a break
Let’s say I’ve got a simple program that prints out the first 10 primes. It
might look something like this:
fn main() {
    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
    for prime in &primes {
        println!("{}", prime);
    }
}
But now I only want to print out the prime numbers less than 10. Easy
enough you might think, just use an if:
fn main() {
    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
    for prime in &primes {
        if *prime < 10 {
            println!("{}", prime);
        }
    }
}
That certainly works, but it’s not great. You see, the for loop is still going to
go through every single number in the array of primes. That means that it’s
going to loop through 10 numbers instead of just 5 (the 4 less than 10, and
one more to discover that 11 is greater than 10). It would be nice to say "hey,
if the next prime number is 10 or more, just give it a break." Fortunately, we
can do exactly that, using the expression break:
fn main() {

    let primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];
    for prime in &primes {
        if *prime >= 10 {
            break;
        }
        println!("{}", prime);
    }
}
This has the exact same output as the program above. However, this program
will only ever look at the first 5 values in the array.

16.2. Go on… 
Let’s look at another example. I want to loop over a bunch of people. I want
to say hi to all of the doctors, but not the scientists. Sounds easy enough:
enum Job {
    Doctor,
    Scientist,
}
struct Person {
    name: String,
    job: Job,
}
fn main() {
    let people = [
        Person { name: "Alice".to_owned(), job: Job::Doctor },
        Person { name: "Bob".to_owned(), job: Job::Scientist },
        Person { name: "Charlie".to_owned(), job: Job::Doctor },
    ];
    for person in &people {
        match person.job {
            Job::Doctor => {
                println!("Hello, {}", person.name);
            }
            Job::Scientist => {
                // don't do anything
            }
        }
    }
}
But now, let’s say that I want to add a new job type, Teacher. And I want
to greet the teachers too. My first inclination may be to write down code like

this:
for person in &people {
    match person.job {
        Job::Doctor => {
            println!("Hello, {}", person.name);
        }
        Job::Scientist => {
            // don't do anything
        }
        Job::Teacher => {
            println!("Hello, {}", person.name);
        }
    }
}
But this feels wrong: we now have identical code in two arms of the match.
We could write a helper function to minimize the duplication, but that’s
annoying.
Instead, there’s a sibling keyword to break, called continue. While
break makes the loop exit entirely, continue says "move on to the next
run of the loop." That happens to solve this problem perfectly, by saying
"skip over the rest of the loop body." We can rewrite our program above as:
for person in &people {
    match person.job {
        Job::Doctor => (),
        Job::Scientist => {
            continue;
        }
        Job::Teacher => (),
    }
    println!("Hello, {}", person.name);
}

Using continue like this also means that we don’t have to indent our code
as much, which can make it a bit easier to fit on a screen. So some people
really like this style. Other people prefer to avoid continue like this, since
in many ways it’s easier to understand a loop that doesn’t have any early
exits. My recommendation: overall, you should avoid continue. But since
you’re likely to see people using it, you should be aware of it.

16.3. Replacing for with while
When introducing for loops, we mentioned that you can always use a
while loop instead of a for loop. That’s pretty tricky to do without
break. However, with break, it’s much easier. The basic idea is that we
want to break as soon as we encounter a None.
fn main() {
    let mut iter = 1..10;
    while true {
        match iter.next() {
            None => break,
            Some(x) => println!("{}", x),
        }
    }
}
Doing this generates a warning:
warning: denote infinite loops with `loop { ... }`
 --> src/main.rs:3:5
  |
3 |     while true {
  |     ^^^^^^^^^^ help: use `loop`
  |
Without break, the concept of an infinite loop is pretty useless: it just does
things forever. However, now that we have break, we have a way of exiting
a so called infinite loop. In Rust, instead of using while true, the
recommended way of writing an infinite loop is to use the loop keyword.

▪
EXERCISE
Modify the program above to use the loop keyword.
Remember how we said that continue was nice, because it let us avoid
indenting our code too much? Well, it would certainly be nice to do the same
thing here. Let’s demonstrate one more cool trick we have with break, and
then we’ll explain why it works:
fn main() {
    let mut iter = 1..10;
    loop {
        let x = match iter.next() {
            None => break,
            Some(x) => x,
        };
        println!("{}", x);
    }
}
Our match expression is allowed to evaluate to a value. And all arms are
required to evaluate to the same type. The Some arm evaluates to an i32.
But what about the None branch? What exactly does break evaluate to?
break and continue are special: neither one of them ever actually
evaluates to a value! That’s the essence of an early exit. Just before we need
the value that would come from that expression, our loop either exits or
restarts. In other words, the code above means:
Hey, I want to put a value in the variable x

▪
▪
▪
In order to get the value for x, look at the iter.next() value
If it’s a Some variant, grab the value inside the Some
If it’s a None variant, poof I’m no longer here

EXERCISE
What error message will you get if you remove the mut before iter? Can you guess before
asking the compiler? Can you understand the compiler’s error message?

16.4. Returning the favor
Alright, we’ve seen early exit for loops. How about functions? To do that, we
use the return keyword. Let’s see how we can use return to bypass extra
indentation. Take this code, which politely doesn’t tell people 30 and older
how old they are:
fn greet(name: &str, age: i32) {
    println!("Hello, {}", name);
    if age < 30 {
        println!("{}, you are {} years old", name, age);
    }
}
fn main() {
    greet("Alice", 30);
    greet("Bob", 25);
}
We can rewrite our greet function to instead use return like this:
fn greet(name: &str, age: i32) {
    println!("Hello, {}", name);
    if age >= 30 {
        return;
    }
    println!("{}, you are {} years old", name, age);
}
Is this an improvement? Not really. The original code was easier to
understand and follow. But this is certainly possible.

Here’s an important bit though. That word return sounds a lot like the
return type of a function. That’s not accidental. Not only can you use the
return keyword to exit a function early, but you can also return a value
when you do so. For example, we can write a safe minus function like that:
fn minus(x: u32, y: u32) -> Option<u32> {
    if x < y {
        return None;
    }
    Some(x - y)
}
fn main() {
    println!("{:?}", minus(7, 6));
    println!("{:?}", minus(2, 6));
}
And now we’re beginning to get to use cases where return is really useful.
Let’s continue (no pun intended) down that rabbit hole.

16.5. Salaries
Let’s say that teachers make $50. Scientists make $70. And students don’t
make any money. We can write a method to help with that:
enum Job {
    Teacher,
    Scientist,
    Student,
}
impl Job {
    fn salary(&self) -> Option<u32> {
        match self {
            Job::Teacher => Some(50),
            Job::Scientist => Some(70),
            Job::Student => None,
        }
    }
}
We want to find out how much money two people will make together. But if
either of them is a student, we want to return None. We can do that with
some matching:
fn two_salaries(x: &Job, y: &Job) -> Option<u32> {
    match x.salary() {
        None => None,
        Some(salary1) => {
            match y.salary() {
                None => None,
                Some(salary2) => Some(salary1 + salary2),
            }
        }
    }

}
That’s pretty hard to follow. We’ve put together a bunch of logic in nested
match expressions, which is hard to keep track of. And this is a relatively
simple example! In real world code, these things can end up much more
complicated. This kind of thing is exactly where return can be very
powerful.

BONUS EXERCISE
Before looking at the example below, try taking a crack at rewriting two_salaries to use
return, and not use any nested match expressions.
The trick to make this work is to capture the salaries into some variables, like
so:
fn two_salaries(x: &Job, y: &Job) -> Option<u32> {
    let salary1 = match x.salary() {
        Some(salary1) => salary1,
        None => return None,
    };
    let salary2 = match y.salary() {
        Some(salary2) => salary2,
        None => return None,
    };
    Some(salary1 + salary2)
}
This makes the code much easier to follow: we’ve untangled the matching on
the two different salaries, and we get to avoid lots of indentation. Yay!

16.6. Let me ask you a question
That code above looks a little repetitive, doesn’t it? Match on an Option,
check if the option is None, if it’s None, then return None. If it’s Some,
then evaluate to that value. Wouldn’t it be great if there was a nice, easy way
to capture that idea in a much shorter amount of code?
Fortunately, there is! This idea of "None propagation" is so common in Rust
that it’s captured in a single character: ?. Observe:
fn two_salaries(x: &Job, y: &Job) -> Option<u32> {
    let salary1 = x.salary()?;
    let salary2 = y.salary()?;
    Some(salary1 + salary2)
}
When you put ? at the end of any expression, you’re saying "please pattern
match, return None if it’s a None, otherwise evaluate to the value inside
Some." That’s really nice!

EXERCISE
Rewrite the two_salaries implementation above to not use any let statements.

▪
▪
▪
16.7. Failing with style
It may seem weird that this None propagation thing is considered so
important in Rust that it gets its own special ? thingy. But here’s the next
piece in the puzzle: ? works for more than just Option. A very common
thing to do in real world programmers is to deal with errors. Let’s get a nice
example to make sense of that.
Let’s say I’m running the ticket booth for a roller coaster. Families come up,
and I need to figure out how much it will cost them to ride. The rule is:
18 years old and under cost 5
19 years old to 65 years old cost 8
66 years old and up cost 7
However, there’s one more thing: no one under 10, or shorter than 80
centimeters, can ride. Let’s first write a data type and function that figures out
the price for a single person:
struct Person {
    name: String,
    age: u32,    // in years
    height: u32, // in centimeters
}
impl Person {
    // Price to ride the roller coaster
    fn price(&self) -> Option<u32> {
        if self.age < 10 {
            return None;
        }

        if self.height < 80 {
            return None;
        }
        Some(if self.age < 18 {
            5
        } else if self.age < 66 {
            8
        } else {
            7
        })
    }
}
This isn’t really great: we know that someone can or can’t ride the roller
coaster, but we don’t know why. But let’s ignore that for now. Next, we want
to write a function that will add up the price for more than one person. Using
?, we can do this pretty nicely:
fn price_people(people: &[Person]) -> Option<u32> {
    let mut price = 0;
    for person in people {
        price += person.price()?;
    }
    Some(price)
}
That’s really nice, but the output leaves something to be desired. With this
main function:
fn main() {
    let family = [
        Person { name: "Alice".to_owned(), age: 30, height: 160 },
        Person { name: "Bob".to_owned(), age: 35, height: 170 },
        Person { name: "Charlie".to_owned(), age: 8, height: 100 
},
        Person { name: "David".to_owned(), age: 12, height: 75 },

    ];
    println!("{:?}", price_people(&family));
}
We get the output None. It doesn’t tell us who wasn’t allowed on, or why
not. We’d really like to be able to handle that.
This is where error handling comes in with Rust. The Option type says
"something returned a value or None." But we don’t want to just deal with
None. We want to introduce an error result as well. First, we’re going to
define our own enum that explains why someone can’t ride:
#[derive(Debug)] // for the output later
enum CantRide {
    TooShort(String),
    TooYoung(String),
}
Next, we need to introduce a new enum from the standard library: Result.
Result is like Option, but allows an error value to be captured as well.
We’ll show you what it looks like, but don’t copy it into your code:
enum Result<T, E> {
    Ok(T),
    Err(E),
}
Next, we can rewrite the price method to return a Result:
fn price(&self) -> Result<u32, CantRide> {
    if self.age < 10 {
        return Err(CantRide::TooYoung(self.name.clone()));

    }
    if self.height < 80 {
        return Err(CantRide::TooShort(self.name.clone()));
    }
    Ok(if self.age < 18 {
        5
    } else if self.age < 66 {
        8
    } else {
        7
    })
}
And finally, we need to tweak the price_people function to return a
Result:
fn price_people(people: &[Person]) -> Result<u32, CantRide> {
    let mut price = 0;
    for person in people {
        price += person.price()?;
    }
    Ok(price)
}
Great! Now we can see who can’t ride, and why. But it looks a little messy.
Let’s clean it up.

16.8. Errors in main
Quite a while ago, we mentioned that main can return a few things besides
unit (). Now that we’ve learned about Result, it’s about time we
demonstrated that. Behold: our error-inducing main function!
fn main() -> Result<(), CantRide> {
    let family = [
        Person { name: "Alice".to_owned(), age: 30, height: 160 },
        Person { name: "Bob".to_owned(), age: 35, height: 170 },
        Person { name: "Charlie".to_owned(), age: 8, height: 100 
},
        Person { name: "David".to_owned(), age: 12, height: 75 },
    ];
    println!("The price is {}", price_people(&family)?);
    Ok(())
}
There are three important things to point out here:
1. The result type of main is Result<(), CantRide>. This is saying:
if everything goes OK, I’ll produce a unit value. But if there’s a problem,
I’ll produce a CantRide. Returning the unit value for the Ok variant is
pretty common in Rust error handling code.
2. Inside the println! macro call, we’ve stuck a ? right after the
price_people function call.
3. That last line, Ok(()), is really interesting. Our main function needs to
return a value of type Result<(), CantRide>, and so we need to
make sure we provide it. You’ll end up seeing a lot of code in Rust that

includes lines like that as the last line in the function.
The 
program 
above 
will 
produce 
the 
output Error:
TooYoung("Charlie"). If you comment out the Charlie line, then you’ll
get Error: TooShort("David"). And finally, if you comment out
David too, you’ll get the output The price is 16. Hurrah!

▪
▪
▪
▪
▪
▪
▪
▪
16.9. Summary
The break expression causes a for, while or loop expression to exit
immediately
The continue expression causes for, while, and loop expressions
to stop processing the current body, and continue with the next iteration
The return keyword causes a function to exit immediately
The return keyword can take a value to return from the function
If return is used without a value, it returns unit ()
The ? operator can be appended to any expression, and causes "None
propagation"
The ? operator also works on other types, such as Result
The main function is allowed to return a Result, which can be used to
indicate that a program failed

16.10. Exercises
1. I’m looking for a yellow animal at the zoo. When I find it, I want to stop
looking. Implement the find_yellow_animal function so that
main compiles and produces the following output:
The Fox is not yellow.
The Monkey is not yellow.
The Polar Bear is not yellow.
I found a yellow Giraffe. Now I'm done looking.
#[derive(PartialEq, Eq, Debug)]
struct Animal {
    name: String,
    color: Color,
}
#[derive(PartialEq, Eq, Debug)]
enum Color {
    Red,
    Yellow,
    Blue,
    Brown,
    White,
}
fn find_yellow_animal(animals: &[Animal]) {
    unimplemented!()
}
fn main() {
    let zoo = [
        Animal { name: "Fox".to_owned(), color: Color::Red },
        Animal { name: "Monkey".to_owned(), color: 
Color::Brown },
        Animal { name: "Polar Bear".to_owned(), color: 

Color::White },
        Animal { name: "Giraffe".to_owned(), color: 
Color::Yellow },
        Animal { name: "Canary".to_owned(), color: 
Color::Yellow },
        Animal { name: "Dolphin".to_owned(), color: 
Color::Blue },
    ];
    find_yellow_animal(&zoo);
}
2. The 
previous 
example 
produced 
output 
from 
the
find_yellow_animal function. Instead, in this exercise, we’re
going to return a value from the function. Implement the new
find_yellow_animal so that the program compiles and executes
successfully.
#[derive(PartialEq, Eq, Debug)]
struct Animal {
    name: String,
    color: Color,
}
#[derive(PartialEq, Eq, Debug)]
enum Color {
    Red,
    Yellow,
    Blue,
    Brown,
    White,
}
fn find_yellow_animal(animals: &[Animal]) -> Option<&Animal> {
    unimplemented!()
}

fn main() {
    let zoo = [
        Animal { name: "Fox".to_owned(), color: Color::Red },
        Animal { name: "Monkey".to_owned(), color: 
Color::Brown },
        Animal { name: "Polar Bear".to_owned(), color: 
Color::White },
        Animal { name: "Giraffe".to_owned(), color: 
Color::Yellow },
        Animal { name: "Canary".to_owned(), color: 
Color::Yellow },
        Animal { name: "Dolphin".to_owned(), color: 
Color::Blue },
    ];
    assert_eq!(Some(&zoo[3]), find_yellow_animal(&zoo));
    assert_eq!(None, find_yellow_animal(&[]));
    println!("Success!");
}
3. I want to know more about Alice. But I may not know her age and
height. Implement the display method so that the program compiles
and runs correctly. Hint: what symbol does this question end with?
struct Person {
    name: String,
    age: Option<u32>,
    height: Option<u32>,
}
impl Person {
    fn display(&self) -> Option<String> {
        unimplemented!()
    }
}
fn main() {
    let mut alice = Person {

        name: "Alice".to_owned(),
        age: None,
        height: None,
    };
    assert_eq!(alice.display(), None);
    alice.age = Some(30);
    assert_eq!(alice.display(), None);
    alice.height = Some(170);
    assert_eq!(
        alice.display(),
        Some("Alice is 30 years old and 170cm 
tall".to_owned())
    );
    alice.age = None;
    assert_eq!(alice.display(), None);
    println!("Success");
}

17. WHAT’S NEXT?
There is much more to learn on your programming journey. You have many
more programs to write. Maybe you want to create a web app, or a mobile
game, or something else entirely. You should definitely pursue it all, and
learn much more!
What you’ve learned so far covers a solid basis of programming. You know
the core of what’s needed to program. You have the lingo. You know enough
to start spreading your wings, explore the internet, and learn specific topics
you’re interested in.
We may follow this book up with another one going deeper into real world
topics. If people are interested in seeing that, please do let us know! For now,
we’re going to leave you with some advice on what to do next.

17.1. Install Rust on your local machine
So far, everything we’ve done has been inside the Rust Playground. This is
great for learning, but doesn’t let you write real programs very effectively.
The next thing to do is to install the tools on your own machine.
We held off on including this in the book, since it can be very different for
each person’s computer. You need to learn a bit about the terminal, text
editors, files and directories, and installing tools. For this step, if you’re not
already familiar with these concepts, try to find a friend or family member to
sit down with you and help you get started. It’s much easier to have someone
show you the way on your computer than to learn from a book.
When you’re ready, you can learn about installing Rust from the install Rust
page.

▪
▪
17.2. Do more exercises
There are lots of exercises available online for improving your programming
skills. Some of these will reinforce what we’ve already learned. Some of
them will force you to learn new things.
Some sites I’d recommend:
Project Euler (more math-heavy challenges)
Exercism

▪
▪
▪
▪
17.3. Get involved
It can be both exciting and intimidating to get more involved in the Rust
community. It’s very active, and there are lots of advanced things going on
all the time. Maybe in the future we’ll carve out a "Rust for new
programmers" corner. For now, here are some of the most popular
community areas:
Rust Homepage
Rust Subreddit
This Week in Rust
Users forum

17.4. Thank you!
That’s it for Begin Rust! We hope you enjoyed learning from our book. All
the best!

