 
Memory Dump Analysis Anthology 
Volume 7 
 
Dmitry Vostokov                                            
Software Diagnostics Institute 
 
 
 
 
 
 
 
 
 
OpenTask 

2     
Published by OpenTask, Republic of Ireland 
Copyright © 2014 by Dmitry Vostokov 
Copyright © 2014 by Software Diagnostics Institute 
All rights reserved. No part of this book may be reproduced, stored in a retrieval system, 
or transmitted, in any form or by any means, without the prior written permission of the 
publisher.  
You must not circulate this book in any other binding or cover, and you must impose the 
same condition on any acquirer. 
OpenTask books are available through booksellers and distributors worldwide. For 
further information or comments send requests to press@opentask.com. 
Product and company names mentioned in this book may be trademarks of their 
owners.  
A CIP catalog record for this book is available from the British Library. 
ISBN-13: 978-1-908043-51-1 (Paperback) 
ISBN-13: 978-1-908043-52-8 (Hardback) 
First printing, 2014 
Revision 2 (July 2015) 
 
 
 

    3 
Summary of Contents 
Preface ............................................................................................................................. 23 
Acknowledgements.......................................................................................................... 25 
PART 1: Professional Crash Dump Analysis and Debugging ............................................. 27 
PART 2: Crash Dump Analysis Patterns ............................................................................ 65 
PART 3: Core Dump Analysis Patterns (Mac OS X) ......................................................... 201 
PART 4: Malware Analysis Patterns ............................................................................... 239 
PART 5: A Bit of Science and Philosophy ........................................................................ 259 
PART 6: Software Trace Analysis Patterns ..................................................................... 279 
PART 7: Fun with Crash Dumps ...................................................................................... 355 
PART 8: Software Narratology ....................................................................................... 383 
PART 9: Software Diagnostics, Troubleshooting, and Debugging .................................. 399 
PART 10: Art and Visualization ....................................................................................... 451 
PART 11: Miscellaneous ................................................................................................. 497 
Appendix ........................................................................................................................ 505 
Index of WinDbg Commands ......................................................................................... 519 
About the Author ........................................................................................................... 521 
Notes .............................................................................................................................. 522 
Cover Images.................................................................................................................. 523 
 

4     
0:007> !address 
                                      
Mapping file section regions... 
Mapping parts regions... 
Mapping page regions... 
Mapping appendix regions... 
Mapping WinDbg commands regions... 
 
    BaseAddress     EndAddress+1        RegionSize     Protect            
------------------------------------------------------------------------ 
    0`00000000      0`0020B000          0`0020B000     PAGE_EXECUTE_READ    
 
 
0:007> !address -summary 
 
--- Usage Summary ---------------- RgnCount %ofTotal 
crash dump analysis patterns             66   24.44% 
log and trace analysis patterns          48   17.77% 
core dump analysis patterns              18    6.66% 
malware analysis patterns                10    3.70% 
other patterns                            7    2.59% 
and more 
 
 
 
    120   44.84% 
 
 
7: kd> !memusage 
 loading PFN database 
loading (100% complete) 
Compiling memory usage data (99% Complete). 
        Crash dump analysis patterns:  135 
     Trace and log analysis patterns:   75 
         Core dump analysis patterns:   38 
           Malware analysis patterns:   20 
  Software diagnostics and debugging:   90 
                Software narratology:   16 
                          Philosophy:   20               
                                 Art:   45 
                                 Fun:   30 
                          Transition:   36  
                                Zero:   18 
                             Unknown:    0  
                               TOTAL:  523 
 
 
 

    5 
Contents 
Preface ............................................................................................................................. 23 
Acknowledgements.......................................................................................................... 25 
PART 1: Professional Crash Dump Analysis and Debugging ............................................. 27 
WinDbg Shortcuts ....................................................................................................... 27 
.ecxr ......................................................................................................................... 27 
!heap -x -v ............................................................................................................... 29 
!sw and !k ................................................................................................................ 31 
Two WinDbg Scripts That Changed the World ............................................................ 32 
Raw Stack Dump of All Threads (Kernel Space) .......................................................... 37 
The Design of Memory Dump Analysis: 7 Steps of Highly Successful Analysts ........... 38 
Postmortem Effects of -g ............................................................................................ 39 
Event Owners .............................................................................................................. 42 
Improbable Occurrence .............................................................................................. 48 
Pattern Cooperation ................................................................................................... 49 
Page Heap Implementation ........................................................................................ 54 
More Common Mistakes in Memory Analysis ............................................................ 60 
Memory Dump Analysis Best Practices ....................................................................... 63 
PART 2: Crash Dump Analysis Patterns ............................................................................ 65 
FPU Exception ............................................................................................................. 65 

6     
Hidden Parameter ....................................................................................................... 67 
Memory Leak (Page Tables) ........................................................................................ 69 
Unrecognizable Symbolic Information ........................................................................ 76 
Network Packet Buildup.............................................................................................. 82 
Disconnected Network Adapter .................................................................................. 83 
Problem Module ......................................................................................................... 85 
Empty Stack Trace ....................................................................................................... 86 
Debugger Bug .............................................................................................................. 90 
Value References ........................................................................................................ 92 
Self-Diagnosis (Registry) .............................................................................................. 93 
System Object ............................................................................................................. 95 
Module Variable .......................................................................................................... 98 
Stack Trace Collection (Predicate) ............................................................................ 100 
Stack Trace Collection (I/O Requests) ....................................................................... 101 
Regular Data .............................................................................................................. 106 
Translated Exception ................................................................................................. 107 
Blocked DPC .............................................................................................................. 108 
Late Crash Dump ....................................................................................................... 109 
Blocked Thread (Timeout) ......................................................................................... 110 
Punctuated Memory Leak ......................................................................................... 111 

    7 
Insufficient Memory (Reserved Virtual Memory) ..................................................... 114 
Coincidental Error Code ............................................................................................ 117 
Stored Exception ....................................................................................................... 119 
Activity Resonance .................................................................................................... 120 
Value Adding Process ................................................................................................ 122 
Memory Leak (I/O Completion Packets) ................................................................... 123 
No Current Thread .................................................................................................... 124 
Unloaded Module ..................................................................................................... 126 
Stack Trace Change ................................................................................................... 131 
Spike Interval............................................................................................................. 132 
Deviant Module......................................................................................................... 133 
Hidden Exception (Kernel Space) .............................................................................. 140 
Handled Exception (Kernel Space) ............................................................................ 141 
High Contention (.NET CLR Monitors) ....................................................................... 142 
Frozen Process .......................................................................................................... 145 
Incomplete Session ................................................................................................... 150 
Error Reporting Fault ................................................................................................ 152 
First Fault Stack Trace ............................................................................................... 155 
Hidden Process .......................................................................................................... 156 
Disk Packet Buildup ................................................................................................... 158 

8     
Deviant Token ........................................................................................................... 161 
Module Collection ..................................................................................................... 162 
Handle Leak ............................................................................................................... 164 
Critical Stack Trace .................................................................................................... 165 
Debugger Omission ................................................................................................... 166 
Broken Link................................................................................................................ 168 
Wait Chain (Pushlocks) .............................................................................................. 170 
Insufficient Memory (Session Pool) .......................................................................... 172 
Step Dumps ............................................................................................................... 173 
Reduced Symbolic Information ................................................................................. 174 
Injected Symbols ....................................................................................................... 175 
Glued Stack Trace ...................................................................................................... 178 
Distributed Wait Chain .............................................................................................. 182 
Ubiquitous Component (Kernel Space) ..................................................................... 184 
One-Thread Process .................................................................................................. 187 
Module Product Process ........................................................................................... 189 
Crash Signature Invariant .......................................................................................... 190 
Small Values .............................................................................................................. 191 
Shared Structure ....................................................................................................... 193 
Wait Chain (CLR Monitors) ........................................................................................ 194 

    9 
Thread Cluster ........................................................................................................... 195 
Module Collection (Predicate) .................................................................................. 196 
False Effective Address ............................................................................................. 197 
Screwbolt Wait Chain ................................................................................................ 198 
PART 3: Core Dump Analysis Patterns (Mac OS X) ......................................................... 201 
GDB for WinDbg Users .............................................................................................. 201 
Stack Trace ................................................................................................................ 203 
GDB Annoyances: Incomplete Stack Trace ............................................................... 205 
NULL Pointer (Data) .................................................................................................. 206 
Shared Buffer Overwrite ........................................................................................... 207 
Multiple Exceptions................................................................................................... 211 
Double Free (Process Heap) ...................................................................................... 213 
Dynamic Memory Corruption (Process Heap) .......................................................... 214 
Spiking Thread ........................................................................................................... 216 
NULL Pointer (Code) .................................................................................................. 218 
Execution Residue ..................................................................................................... 220 
Coincidental Symbolic Information ........................................................................... 223 
Paratext ..................................................................................................................... 225 
Truncated Dump ....................................................................................................... 227 
C++ Exception ............................................................................................................ 228 

10     
Local Buffer Overflow ............................................................................................... 229 
Divide by Zero (User Mode) ...................................................................................... 231 
Stack Overflow (User Mode) ..................................................................................... 232 
Active Thread ............................................................................................................ 236 
PART 4: Malware Analysis Patterns ............................................................................... 239 
Malware: A Definition ............................................................................................... 239 
Fake Module ............................................................................................................. 240 
RIP Stack Trace .......................................................................................................... 244 
Driver Device Collection ............................................................................................ 246 
Pre-Obfuscation Residue ........................................................................................... 247 
Packed Code .............................................................................................................. 248 
Raw Pointer ............................................................................................................... 251 
Out-of-Module Pointer ............................................................................................. 252 
Patched Code ............................................................................................................ 253 
String Hint ................................................................................................................. 254 
Namespace ................................................................................................................ 257 
PART 5: A Bit of Science and Philosophy ........................................................................ 259 
On Matter ................................................................................................................. 259 
Commodities as Memories ....................................................................................... 260 
Software as Means of Production ............................................................................. 261 

    11 
Notes on Memoidealism ........................................................................................... 262 
The Confluence of Computers, Philosophy, and Religion ......................................... 264 
Analytic Memory Dump - A Mathematical Definition............................................... 265 
Sorting and Early Greek Philosophers ....................................................................... 266 
General Abnormal Patterns of Structure and Behavior ............................................ 267 
On Matter and Substances........................................................................................ 268 
M-Memory ................................................................................................................ 269 
Ontology of Memoidealism ...................................................................................... 270 
Philosophies of Persistence....................................................................................... 273 
Information as Arrow ................................................................................................ 275 
Dialectical Triad in Memoidealism ............................................................................ 276 
PART 6: Software Trace Analysis Patterns ..................................................................... 279 
Software Trace Diagrams (STDiagrams) .................................................................... 279 
Macrofunction .......................................................................................................... 283 
Linked Messages ....................................................................................................... 284 
Marked Message ....................................................................................................... 285 
Trace Frames ............................................................................................................. 286 
Counter Value ........................................................................................................... 288 
Message Context ....................................................................................................... 289 
Error Distribution ...................................................................................................... 290 

12     
Break-in Activity ........................................................................................................ 291 
Resume Activity......................................................................................................... 292 
Fiber Bundle .............................................................................................................. 294 
Data Flow .................................................................................................................. 296 
Empty Trace .............................................................................................................. 298 
Error Message ........................................................................................................... 299 
Periodic Message Block ............................................................................................. 300 
Visibility Limit ............................................................................................................ 301 
Relative Density ........................................................................................................ 302 
Sparse Trace .............................................................................................................. 303 
Opposition Messages ................................................................................................ 304 
Split Trace .................................................................................................................. 305 
Message Interleave ................................................................................................... 306 
Sheaf of Activities ...................................................................................................... 307 
Indexical Trace .......................................................................................................... 310 
Abnormal Value ........................................................................................................ 311 
Dominant Event Sequence ........................................................................................ 313 
Pivot Message ........................................................................................................... 314 
Traces of Individuality ............................................................................................... 318 
Indirect Facts ............................................................................................................. 319 

    13 
Hidden Error .............................................................................................................. 320 
Last Activity ............................................................................................................... 322 
State and Event ......................................................................................................... 324 
Dialogue .................................................................................................................... 326 
Motif ......................................................................................................................... 329 
Exception Stack Trace (Java) ..................................................................................... 330 
Correlated Discontinuity ........................................................................................... 332 
Piecewise Activity ...................................................................................................... 333 
Density Distribution .................................................................................................. 335 
Factor Group ............................................................................................................. 336 
Silent Messages ......................................................................................................... 339 
Shared Point .............................................................................................................. 341 
Meta Trace ................................................................................................................ 343 
Data Association........................................................................................................ 344 
State Dump ............................................................................................................... 346 
Message Cover .......................................................................................................... 347 
Message Set .............................................................................................................. 349 
Error Thread .............................................................................................................. 351 
Activity Divergence ................................................................................................... 352 
PART 7: Fun with Crash Dumps ...................................................................................... 355 

14     
Debugging Slang ........................................................................................................ 355 
LoL ......................................................................................................................... 355 
Watching a Movie ................................................................................................. 356 
PonOS .................................................................................................................... 357 
Typology, Typological ............................................................................................ 358 
Memorandum ....................................................................................................... 359 
HELL ....................................................................................................................... 360 
FBI ......................................................................................................................... 361 
poo ........................................................................................................................ 362 
STaMPs .................................................................................................................. 363 
A NoSQL Problem .................................................................................................. 364 
Matrix .................................................................................................................... 365 
Fool ....................................................................................................................... 366 
B2B, B2C, H2H ....................................................................................................... 367 
New Year Eve Debugging .......................................................................................... 368 
Happy New Spiking Year of Software Trace Analysis ................................................ 369 
Happy New Year (from Windows 8) .......................................................................... 370 
Music for Debugging ................................................................................................. 372 
Going Romantic ..................................................................................................... 372 
Make It through This Trace ................................................................................... 373 

    15 
Fiction for Debugging ................................................................................................ 374 
The Problem and The Solution .............................................................................. 374 
Pilgrimage to Harvard University .............................................................................. 375 
Welcome to Ki* and Ke* ........................................................................................... 376 
I Memory Dump ........................................................................................................ 377 
A Blue Screen Watch ................................................................................................. 379 
Poetry ........................................................................................................................ 380 
Surfaces in Nature ..................................................................................................... 381 
PART 8: Software Narratology ....................................................................................... 383 
Software Anti-Narrative ............................................................................................ 383 
Software Narratology Helps Fiction Writers ............................................................. 384 
Narremes in Software Narratology ........................................................................... 386 
Narralog - A Software Trace Modeling Language ..................................................... 387 
What is a Software Narrative? .................................................................................. 388 
Software Narrative Planes ........................................................................................ 389 
Software Narratology Square .................................................................................... 391 
Writing and Validation of Historical Narratives ........................................................ 392 
Software Trace Analysis Patterns Domain Hierarchy ................................................ 393 
Process Monitor as Modeling Tool ........................................................................... 394 
Generalized Software Narrative and Trace ............................................................... 395 

16     
Unified Computer Diagnostics: Incorporating Hardware Narratology ..................... 396 
Introducing Software Narratology of Things (Software NT) ..................................... 397 
PART 9: Software Diagnostics, Troubleshooting, and Debugging .................................. 399 
Unified and Generative Debugging ........................................................................... 399 
Analysis, Architectural, Design, Implementation and Usage Debugging Patterns 399 
Software Problem Description Language .................................................................. 401 
What are Software Trace and Memory Dump Analysis? A One Sentence Definition402 
Software Problem Solving Tools as a Service ............................................................ 403 
Software Problem Description Patterns ................................................................... 404 
Software Behavior Pattern Prediction ...................................................................... 405 
Patterns of Software Diagnostics .............................................................................. 406 
First Fault .............................................................................................................. 406 
Highly Effective Diagnostics ...................................................................................... 407 
Network Trace Analysis Patterns .............................................................................. 408 
Software Diagnostics Services ................................................................................... 411 
Architecture of Process Memory Dump Capture Done Right ................................... 412 
An Introduction to General Systems Thinking (Book Review) .................................. 413 
Software Diagnostics Institute Logo ......................................................................... 414 
User Interface Problem Analysis Patterns................................................................. 415 
Unresponsive Window .......................................................................................... 415 

    17 
Pattern-Based Software Diagnostics ......................................................................... 418 
Software Diagnostics Discipline ................................................................................ 419 
Architecture of memCPU .......................................................................................... 420 
Phenomenology of Software Diagnostics: A First Sketch.......................................... 421 
Software Diagnostics Report Schemes...................................................................... 422 
Missing Cause Trace .............................................................................................. 422 
Software Diagnostics Training: Two Approaches ...................................................... 423 
Software Disruption Patterns .................................................................................... 425 
Space Precondition ............................................................................................... 425 
Static Code Analysis Patterns .................................................................................... 426 
Loop Construct ...................................................................................................... 426 
The Structure of Software Problem Solving Organization ........................................ 427 
Bridging the Great Divide .......................................................................................... 428 
Elementary Software Diagnostics Patterns ............................................................... 429 
Zero Fault Software Diagnostics ............................................................................... 430 
Agile Software Diagnostics ........................................................................................ 432 
ADDR Pattern Catalogue ........................................................................................... 433 
Thinking-Based Software Diagnostics ....................................................................... 434 
Memory Acquisition Pattern Catalog ........................................................................ 436 
Trace Acquisition Pattern Catalog ............................................................................. 437 

18     
Patterns of Software Diagnostics Architecture ......................................................... 438 
Detecting and Predicting the Unknown .................................................................... 440 
Software Diagnostics Metaphors .............................................................................. 442 
Software Diagnostics as Psychology ..................................................................... 442 
Software Diagnostics as Literary Criticism ............................................................ 443 
Rapid Software Diagnostics Process (RSDP) .............................................................. 444 
Right First Time Software Diagnosis .......................................................................... 445 
Software Diagnosis Codes ......................................................................................... 446 
Vulnerability Analysis Patterns (VAP)........................................................................ 447 
Versioned Namespace .......................................................................................... 449 
PART 10: Art and Visualization ....................................................................................... 451 
2012 (Pessimistic) ..................................................................................................... 451 
2012 (Optimistic)....................................................................................................... 452 
A Bug in a Bag (Collections, Ex-hi-bit 1) .................................................................... 453 
A Bug Meets a Bug (The Clash of Civilizations) ......................................................... 454 
A Bug Catcher ............................................................................................................ 455 
The Second Generation of CARE System (Trademark) .............................................. 456 
RawStackGram .......................................................................................................... 457 
A Memory Window ................................................................................................... 458 
Liquid Memory .......................................................................................................... 459 

    19 
Computer Brain ......................................................................................................... 460 
Computer Evolution .................................................................................................. 461 
M Spaces ................................................................................................................... 462 
Happy Hellowin! ........................................................................................................ 463 
Pointers in Nature ..................................................................................................... 464 
Drink Sensibly Before The End Of The World! .......................................................... 465 
MM=DD=YY ............................................................................................................... 466 
Process Monitor Log Visualized ................................................................................ 468 
Holes Infinity (HI OS) ................................................................................................. 472 
Cyber Vostok Missions .............................................................................................. 473 
A Dump Machine ...................................................................................................... 474 
The Power of Simplicity............................................................................................. 475 
Happy St. Patrick’s Screen ......................................................................................... 476 
Happy New Year 2014! ............................................................................................. 477 
I Love Software Diagnostics ...................................................................................... 478 
Puree Windows Cooking ........................................................................................... 479 
Salad Winterminal ................................................................................................. 479 
Kernel Soup ........................................................................................................... 481 
Neolithic Soup ....................................................................................................... 482 
Food Subsystems .................................................................................................. 483 

20     
An Accident of Creation ........................................................................................ 484 
So Chi Salad, 2014 ................................................................................................. 485 
Self-Organized Window-ed soup .......................................................................... 486 
Political Computicarts ............................................................................................... 487 
Needs Non-Invasive Debugging! ........................................................................... 487 
Russian Spaces ...................................................................................................... 488 
The Day I Quit ............................................................................................................ 489 
Hero of Dump Analysis, a Medal for Labor Day ........................................................ 490 
Diagnosed by Vostokov®TM ........................................................................................ 491 
Stack Trace Shapes .................................................................................................... 492 
The Art of Internals ................................................................................................... 494 
Threadinking ............................................................................................................. 495 
PART 11: Miscellaneous ................................................................................................. 497 
C and C++ Programming Books That Made a Great Impression on the Author........ 497 
Outside ...................................................................................................................... 499 
After Debugging ........................................................................................................ 500 
Crash Dumps, Acquisitions, and Layoffs ................................................................... 501 
Cadaver Worm: An Exercise in Malware Fiction ....................................................... 502 
WinDbg as UNICODE to ASCII Converter .................................................................. 504 
Appendix ........................................................................................................................ 505 

    21 
Falsity and Coincidence Patterns .............................................................................. 505 
Process Patterns ........................................................................................................ 506 
Thread Patterns......................................................................................................... 507 
Optimization Patterns ............................................................................................... 508 
Exception Patterns .................................................................................................... 509 
Module Patterns ....................................................................................................... 510 
RPC, LPC and ALPC Patterns and Case Studies .......................................................... 511 
ERESOURCE Patterns and Case Studies ..................................................................... 513 
Meta-Memory Dump Patterns .................................................................................. 515 
Crash Dump Analysis Checklist.................................................................................. 516 
Index of WinDbg Commands ......................................................................................... 519 
About the Author ........................................................................................................... 521 
Notes .............................................................................................................................. 522 
Cover Images.................................................................................................................. 523 
 
  
 
 

22     
[This page is intentionally left blank] 
 
 

    23 
Preface 
This reference volume consists of revised, edited, cross-referenced, and thematically 
organized articles from Software Diagnostics Institute (DumpAnalysis.org) and Software 
Diagnostics Library (former Crash Dump Analysis blog, DumpAnalysis.org/blog) written 
in November 2011 - May 2014.  
We hope this reference is useful for: 
 
Software engineers developing and maintaining products on Windows 
platforms; 
 
Technical support and escalation engineers dealing with complex software 
issues; 
 
Quality assurance engineers testing software on Windows platforms; 
 
Security researchers, reverse engineers, malware and memory forensics 
analysts; 
 
Trace and log analysis articles will be of interest to users of any platform. 
If you encounter any error, please contact me using this form  
http://www.dumpanalysis.org/contact 
or send me a personal message using this contact e-mail: 
dmitry.vostokov@dumpanalysis.org 
Alternatively, via Twitter @DumpAnalysis 
Facebook page and group: 
http://www.facebook.com/DumpAnalysis 
http://www.facebook.com/TraceAnalysis 
http://www.facebook.com/groups/dumpanalysis 
 
 
 

24    Preface 
[This page is intentionally left blank] 
  
 
 

    25 
Acknowledgements 
Thousands of people reviewed DumpAnalysis.org content, and I would like to thank all 
of them. 
Special thanks to Tony Donegan for the front cover design. 
 
 

26    Acknowledgements 
[This page is intentionally left blank] 
 
 
 
 

WinDbg Shortcuts    27 
PART 1: Professional Crash Dump Analysis and Debugging 
WinDbg Shortcuts 
.ecxr 
If we are impatient with !analyze -v command we can always use a replacement that 
shows and sets the context for the current exception so we can quickly get to the 
possible crashing point (Crash Signature, Volume 6, page 37): 
0:000> .ecxr 
eax=00000000 ebx=00000001 ecx=00000000 edx=0018fe40 esi=00426310 edi=00000111 
eip=0041ff21 esp=0018f81c ebp=0018f850 iopl=0 nv up ei pl zr na pe nc 
cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010246 
*** ERROR: Module load completed but symbols could not be loaded for TestWER.exe 
TestWER+0x1ff21: 
0041ff21 c7050000000000000000 mov dword ptr ds:[0],0 ds:002b:00000000=???????? 
0:000> kL 
*** Stack trace for last set context - .thread/.cxr resets it 
ChildEBP RetAddr 
WARNING: Stack unwind information not available. Following frames may be 
wrong. 
0018f850 00403620 TestWER+0x1ff21 
0018f860 0040382f TestWER+0x3620 
0018f890 00402df6 TestWER+0x382f 
0018f8b4 00409ef8 TestWER+0x2df6 
0018f904 0040a792 TestWER+0x9ef8 
0018f9a0 00406dea TestWER+0xa792 
0018f9c0 00409713 TestWER+0x6dea 
0018fa28 004097a2 TestWER+0x9713 
0018fa48 76f66238 TestWER+0x97a2 
0018fa74 76f668ea user32!InternalCallWinProc+0x23 
0018faec 76f6cd1a user32!UserCallWinProcCheckWow+0x109 
0018fb30 76f6cd81 user32!SendMessageWorker+0x581 
0018fb54 74fb4e95 user32!SendMessageW+0x7f 
0018fb74 74fb4ef7 comctl32!Button_NotifyParent+0x3d 
0018fb90 74fb4d89 comctl32!Button_ReleaseCapture+0x113 
0018fbf0 76f66238 comctl32!Button_WndProc+0xa18 
0018fc1c 76f668ea user32!InternalCallWinProc+0x23 
0018fc94 76f67d31 user32!UserCallWinProcCheckWow+0x109 
0018fcf4 76f67dfa user32!DispatchMessageWorker+0x3bc 
0018fd04 76f82292 user32!DispatchMessageW+0xf 
0018fd30 0040618c user32!IsDialogMessageW+0x5f6 
0018fd44 004071e2 TestWER+0x618c 
0018fd50 00402dd3 TestWER+0x71e2 
0018fd64 00408dc1 TestWER+0x2dd3 
0018fd78 00403f35 TestWER+0x8dc1 
0018fd90 00404090 TestWER+0x3f35 
0018fd9c 00403f80 TestWER+0x4090 

28    PART 1: Professional Crash Dump Analysis and Debugging 
0018fda8 004040dd TestWER+0x3f80 
0018fde0 00403440 TestWER+0x40dd 
0018fe2c 004204ee TestWER+0x3440 
0018fee4 0041fdf5 TestWER+0x204ee 
0018fef8 0040fc3e TestWER+0x1fdf5 
0018ff88 76ce3677 TestWER+0xfc3e 
0018ff94 77b89f02 kernel32!BaseThreadInitThunk+0xe 
0018ffd4 77b89ed5 ntdll!__RtlUserThreadStart+0x70 
0018ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
However, in the case of Multiple Exceptions (Volume 1, page 255) we still need 
to do Stack Trace Collection analysis (Volume 1, page 409): 
0:000> .ecxr 
eax=00000030 ebx=7efde000 ecx=750d2dd9 edx=00000000 esi=00000000 
edi=00000000 
eip=770d280c esp=0037f828 ebp=0037f870 iopl=0 nv up ei pl nz na po nc 
cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000202 
KERNELBASE!DebugBreak+0x2: 
770d280c cc int 3 
0:000> ~*k 6 
. 0 Id: f00.f04 Suspend: 0 Teb: 7efdd000 Unfrozen 
ChildEBP RetAddr 
0037f1a4 770d0bdd ntdll!NtWaitForMultipleObjects+0x15 
0037f240 7529162d KERNELBASE!WaitForMultipleObjectsEx+0x100 
0037f288 75291921 kernel32!WaitForMultipleObjectsExImplementation+0xe0 
0037f2a4 752b9b2d kernel32!WaitForMultipleObjects+0x18 
0037f310 752b9bca kernel32!WerpReportFaultInternal+0x186 
0037f324 752b98f8 kernel32!WerpReportFault+0×70 
1 Id: f00.f18 Suspend: 1 Teb: 7efda000 Unfrozen 
ChildEBP RetAddr 
0080f9ac 770d31bb ntdll!NtDelayExecution+0x15 
0080fa14 770d3a8b KERNELBASE!SleepEx+0x65 
0080fa24 752d28dd KERNELBASE!Sleep+0xf 
0080fa38 752b98f8 kernel32!WerpReportFault+0×3f 
0080fa48 752b9875 kernel32!BasepReportFault+0×20 
0080fad4 77b10df7 kernel32!UnhandledExceptionFilter+0×1af 
2 Id: f00.f1c Suspend: 1 Teb: 7efd7000 Unfrozen 
ChildEBP RetAddr 
00abf640 770d31bb ntdll!NtDelayExecution+0x15 
00abf6a8 770d3a8b KERNELBASE!SleepEx+0x65 
00abf6b8 752d28dd KERNELBASE!Sleep+0xf 
00abf6cc 752b98f8 kernel32!WerpReportFault+0×3f 
00abf6dc 752b9875 kernel32!BasepReportFault+0×20 
00abf768 77b10df7 kernel32!UnhandledExceptionFilter+0×1af 
 
 

WinDbg Shortcuts    29 
!heap -x -v 
The following command is useful for searching process virtual space for any value 
references (page 92): 
!heap -x -v <value> ”will search the entire virtual memory space of the current 
process for pointers to this” value (from WinDbg help1). 
Example: 
0:000> !heap -x -v 6e412d82 
Search VM for address range 6e412d82 - 6e412d82 : 778042bc (6e412d82), 
0:000> dp 778042bc l1 
778042bc 6e412d82 
0:000> !heap -x -v c0000005 
Search VM for address range c0000005 - c0000005 : 014df8d0 (c0000005), 
014dfe8c (c0000005), 0155d908 (c0000005), 0155dd10 (c0000005), 0155ddc8 
(c0000005), 0155dfa8 (c0000005), 0155dff0 (c0000005), 0155ea20 (c0000005), 
6d000f9c (c0000005), 70d44054 (c0000005), 725c30d4 (c0000005), 7270d20c 
(c0000005), 7282ef74 (c0000005), 7449a878 (c0000005), 74511958 (c0000005), 
74562ec4 (c0000005), 74563280 (c0000005), 74564fc8 (c0000005), 7456562c 
(c0000005), 74565748 (c0000005), 745664a8 (c0000005), 74566a30 (c0000005), 
74566ad8 (c0000005), 747f6730 (c0000005), 747f682c (c0000005), 74861ef0 
(c0000005), 7488743c (c0000005), 748aea68 (c0000005), 748b2830 (c0000005), 
748c5118 (c0000005), 74935068 (c0000005), 749412a8 (c0000005), 7495caf0 
(c0000005), 74a3a780 (c0000005), 74aa462c (c0000005), 74b19b68 (c0000005), 
74b61060 (c0000005), 74b8fb44 (c0000005), 74b9d1c8 (c0000005), 74be1ad8 
(c0000005), 74be72c8 (c0000005), 74c14b60 (c0000005), 74c83b84 (c0000005), 
74c83b88 (c0000005), 74c83b9c (c0000005), 74c83ba0 (c0000005), 74c83ba4 
(c0000005), 74c83ba8 (c0000005), 74c83bac (c0000005), 74c83bb0 (c0000005), 
74c83bb4 (c0000005), 74c83bb8 (c0000005), 74c83bbc (c0000005), 74c83bc0 
(c0000005), 74c83bc8 (c0000005), 74c83bcc (c0000005), 74c83bd0 (c0000005), 
74c83bd4 (c0000005), 74c83bd8 (c0000005), 74c83bdc (c0000005), 74c83be0 
(c0000005), 74c83be4 (c0000005), 74c83be8 (c0000005), 74c83bec (c0000005), 
74c83bf0 (c0000005), 74c83bf4 (c0000005), 74c83bf8 (c0000005), 74c83bfc 
(c0000005), 74c83c00 (c0000005), 74c83c04 (c0000005), 74c83c08 (c0000005), 
74c83c0c (c0000005), 74c83c10 (c0000005), 74c83c14 (c0000005), 74c83c18 
(c0000005), 74c83c1c (c0000005), 74c83c20 (c0000005), 74c83c24 (c0000005), 
74c83c28 (c0000005), 74c83c2c (c0000005), 74c83c34 (c0000005), 74c83c38 
(c0000005), 74c83c3c (c0000005), 74c8c7ac (c0000005), 75019298 (c0000005), 
750ff7b0 (c0000005), 751c1adc (c0000005), 751c2514 (c0000005), 7522c530 
(c0000005), 752c311c (c0000005), 752d4734 (c0000005), 752d4ae8 (c0000005), 
752d534c (c0000005), 752d7038 (c0000005), 752d7e9c (c0000005), 752eda04 
                                                                 
1 http://msdn.microsoft.com/en-us/library/ff563189.aspx 

30    PART 1: Professional Crash Dump Analysis and Debugging 
(c0000005), 752edab0 (c0000005), 756d6624 (c0000005), 7571adc0 (c0000005), 
7571addc (c0000005), 75723780 (c0000005), 757af774 (c0000005), 759c0f10 
(c0000005), 76702360 (c0000005), 76703a30 (c0000005), 76d437ac (c0000005), 
76d527ec (c0000005), 76dd0fa4 (c0000005), 77581f2c (c0000005), 777a33c0 
(c0000005), 777c8b14 (c0000005), 
 
 

WinDbg Shortcuts    31 
!sw and !k 
There is an extension shortcut to the usual WinDbg command .effmach for 64-bit 
memory dumps of 32-bit processes: 
0:000> .load wow64exts 
 
0:000> !sw 
Switched to 32bit mode 
 
0:000:x86> !sw 
Switched to 64bit mode 
Also !k command will display both thread stacks (32-bit and 64-bit): 
0:000> !k 
Walking 64bit Stack... 
Child-SP          RetAddr           Call Site 
00000000`0016e018 00000000`74f9aea8 wow64win!NtUserGetMessage+0xa 
00000000`0016e020 00000000`74fecf87 wow64win!whNtUserGetMessage+0x30 
00000000`0016e080 00000000`74f72776 wow64!Wow64SystemServiceEx+0xd7 
00000000`0016e940 00000000`74fed07e wow64cpu!ServiceNoTurbo+0x2d 
00000000`0016ea00 00000000`74fec549 wow64!RunCpuSimulation+0xa 
00000000`0016ea50 00000000`77c54956 wow64!Wow64LdrpInitialize+0x429 
00000000`0016efa0 00000000`77c51a17 ntdll!LdrpInitializeProcess+0x17e4 
00000000`0016f490 00000000`77c3c32e ntdll! ?? ::FNODOBFM::`string'+0x29220 
00000000`0016f500 00000000`00000000 ntdll!LdrInitializeThunk+0xe 
Walking 32bit Stack... 
ChildEBP RetAddr 
002cf6a0 76ba790d user32!NtUserGetMessage+0x15 
002cf6bc 0048148a user32!GetMessageW+0x33 
002cf6fc 004816ec notepad!WinMain+0xe6 
002cf78c 755533aa notepad!_initterm_e+0x1a1 
002cf798 77e29ef2 kernel32!BaseThreadInitThunk+0xe 
002cf7d8 77e29ec5 ntdll_77df0000!__RtlUserThreadStart+0x70 
002cf7f0 00000000 ntdll_77df0000!_RtlUserThreadStart+0x1b 
However, we don’t recommend its usage in iterative scripts (Volume 5, page 
30) because if something goes wrong at one iteration then all subsequent !sw 
commands will trigger the wrong machine mode but the explicit .effmach command will 
set the correct one. 
 
 

32    PART 1: Professional Crash Dump Analysis and Debugging 
Two WinDbg Scripts That Changed the World 
One of the readers if this Anthology asked whether there was !runaway WinDbg 
command equivalent for kernel and complete memory dumps to diagnose Spiking 
Thread pattern (Volume 1, page 305) faster. So, after some thinking we gave it a try 
especially in the context of WinDbg scripting exercises designed for Advanced Windows 
Memory Dump Analysis training2. As a result, we wrote two scripts initially. Their output 
here is taken from a complete memory dump we used for Fundamentals of Complete 
Crash and Hang Memory Dump Analysis presentation3.  
The first one dumps the most CPU consuming threads for user and kernel mode: 
$$ 
$$ krunawaymost.wds 
$$ Copyright (c) 2011 Software Diagnostics Services 
$$ GNU GENERAL PUBLIC LICENSE 
$$ http://www.gnu.org/licenses/gpl-3.0.txt 
$$ 
r $t0 = 0 
!for_each_thread “r $t1 = dwo( @#Thread + @@c++(#FIELD_OFFSET(nt!_KTHREAD, 
UserTime)) ); .if (@$t1 > @$t0) {r $t0 = @$t1; r $t2 = @#Thread}” 
.echo “The largest UserTime value: ” 
? @$t0 
!thread @$t2 3f 
r $t0 = 0 
!for_each_thread “r $t1 = dwo( @#Thread + @@c++(#FIELD_OFFSET(nt!_KTHREAD, 
KernelTime)) ); .if (@$t1 > @$t0) {r $t0 = @$t1; r $t2 = @#Thread}” 
.echo “The largest KernelTime value: ” 
? @$t0 
!thread @$t2 3f 
 
 
                                                                 
2 http://www.patterndiagnostics.com/advanced-windows-memory-dump-analysis 
3 http://www.patterndiagnostics.com/FCMDA-materials-Rev2 

Two WinDbg Scripts That Changed the World    33 
0: kd> $$><c:\Scripts\krunawaymost.wds 
The largest UserTime value: 
Evaluate expression: 5470 = 00000000`0000155e 
THREAD fffffa800451d720 Cid 1418.17fc Teb: 000007fffffdc000 Win32Thread: 0000000000000000 
RUNNING on processor 2 
Not impersonating 
DeviceMap                 fffff8a001ce6b90 
Owning Process            fffffa800442ab30       Image:         ApplicationE.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      22295          Ticks: 0 
Context Switch Count      27960             
UserTime                  00:01:25.332 
KernelTime                00:00:00.015 
*** ERROR: Module load completed but symbols could not be loaded for ApplicationE.exe 
Win32 Start Address ApplicationE (0×000000013f0f1578) 
Stack Init fffff8800723cc70 Current fffff8800723c960 
Base fffff8800723d000 Limit fffff88007237000 Call 0 
Priority 8 BasePriority 8 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 
00000000`0021f9e0 00000000`00000000 ApplicationE+0×6cd3 
The largest KernelTime value: 
Evaluate expression: 187 = 00000000`000000bb 
THREAD fffffa80098d7b60 Cid 07bc.0a14 Teb: 000007fffffd7000 Win32Thread: fffff900c2ca0c20 
WAIT: (UserRequest) KernelMode Non-Alertable 
fffffa8008a4a030 NotificationEvent 
Not impersonating 
DeviceMap                 fffff8a001ce6b90 
Owning Process            fffffa80096beb30       Image:         dwm.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      22294          Ticks: 1 (0:00:00:00.015) 
Context Switch Count      15473                 LargeStack 
UserTime                  00:00:06.801 
KernelTime                00:00:02.917 
Win32 Start Address dwmcore!CPartitionThread::ThreadMain (0×000007fef8a1f0d8) 
Stack Init fffff8800d3d5c70 Current fffff8800d3d5740 
Base fffff8800d3d6000 Limit fffff8800d3cf000 Call 0 
Priority 15 BasePriority 15 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff880`0d3d5780 fffff800`02ee6f32 nt!KiSwapContext+0×7a 
fffff880`0d3d58c0 fffff800`02ee974f nt!KiCommitThreadWait+0×1d2 
fffff880`0d3d5950 fffff880`0fef65b3 nt!KeWaitForSingleObject+0×19f 
fffff880`0d3d59f0 fffff960`001fedea dxgkrnl!DxgkWaitForVerticalBlankEvent+0×53f 
fffff880`0d3d5ab0 fffff800`02ee0ed3 win32k!NtGdiDdDDIWaitForVerticalBlankEvent+0×12 
fffff880`0d3d5ae0 000007fe`ff1d143a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`0d3d5ae0) 
00000000`0287f778 000007fe`f8791da1 GDI32!NtGdiDdDDIWaitForVerticalBlankEvent+0xa 
00000000`0287f780 000007fe`f89e1b6e dxgi!CDXGIOutput::WaitForVBlank+0×51 
00000000`0287f7c0 000007fe`f89e1ae9 dwmcore!CD3DDeviceLevel1::WaitForVBlank+0×1f9 
00000000`0287f810 000007fe`f89e1a9d dwmcore!CHwDisplayRenderTarget::WaitForVBlank+0×39 
00000000`0287f850 000007fe`f89e1a4c dwmcore!CDesktopRenderTarget::WaitForVBlank+0×40 
00000000`0287f880 000007fe`f89d3513 dwmcore!CSlaveHWndRenderTarget::WaitForVBlank+0×2c 
00000000`0287f8c0 000007fe`f89d3584 dwmcore!CRenderTargetManager::WaitForVBlank+0×7d 
00000000`0287f900 000007fe`f89d2661 
dwmcore!CPartitionVerticalBlankScheduler::WaitForVBlank+0×7c 
00000000`0287f950 000007fe`f8a1f0f4 dwmcore!CPartitionVerticalBlankScheduler::Run+0xe5 
00000000`0287f9b0 00000000`7719652d dwmcore!CPartitionThread::ThreadMain+0×1c 
00000000`0287f9e0 00000000`772cc521 kernel32!BaseThreadInitThunk+0xd 
00000000`0287fa10 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
The second script takes two arguments and shows all threads that have UserTime 
and KernelTime ticks values greater than these arguments: 

34    PART 1: Professional Crash Dump Analysis and Debugging 
$$ 
$$ krunawaygt.wds 
$$ Copyright (c) 2011 Software Diagnostics Services 
$$ GNU GENERAL PUBLIC LICENSE 
$$ http://www.gnu.org/licenses/gpl-3.0.txt 
$$ 
!for_each_thread “r $t1 = dwo( @#Thread + @@c++(#FIELD_OFFSET(nt!_KTHREAD, 
UserTime)) ); r $t0 = $arg1; .if (@$t1 > @$t0) {!thread @#Thread 3f}” 
!for_each_thread “r $t1 = dwo( @#Thread + @@c++(#FIELD_OFFSET(nt!_KTHREAD, 
KernelTime)) ); r $t0 = $arg2; .if (@$t1 > @$t0) {!thread @#Thread 3f}” 
Using hints from the previous script run (the largest UserTime ticks value is 
0×155e) we now get threads that spent more than 0×100 ticks in user mode: 
0: kd> $$>a<c:\Scripts\krunawaygt.wds 100 100 
THREAD fffffa800843e060  Cid 03f4.0658  Teb: 000007fffff90000 Win32Thread: 0000000000000000 
WAIT: (WrQueue) UserMode Non-Alertable 
    fffffa800843c2c0  QueueObject 
Not impersonating 
DeviceMap                 fffff8a000008aa0 
Owning Process            fffffa800916b060       Image:         MsMpEng.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      21211          Ticks: 1084 (0:00:00:16.910) 
Context Switch Count      6028             
UserTime                  00:00:10.140 
KernelTime                00:00:00.296 
Win32 Start Address msvcrt!endthreadex (0×000007feff5173fc) 
Stack Init fffff88009d4bc70 Current fffff88009d4b660 
Base fffff88009d4c000 Limit fffff88009d46000 Call 0 
Priority 9 BasePriority 8 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for mprtp.dll - 
Child-SP          RetAddr           Call Site 
fffff880`09d4b6a0 fffff800`02ee6f32 nt!KiSwapContext+0×7a 
fffff880`09d4b7e0 fffff800`02ee9f93 nt!KiCommitThreadWait+0×1d2 
fffff880`09d4b870 fffff800`031ca647 nt!KeRemoveQueueEx+0×323 
fffff880`09d4b930 fffff800`0319cae5 nt!IoRemoveIoCompletion+0×47 
fffff880`09d4b9c0 fffff800`02ee0ed3 nt!NtRemoveIoCompletion+0×145 
fffff880`09d4ba70 00000000`772f13aa nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`09d4bae0) 
00000000`0209fb08 000007fe`fd9e169d ntdll!ZwRemoveIoCompletion+0xa 
00000000`0209fb10 00000000`7718a4e1 KERNELBASE!GetQueuedCompletionStatus+0×39 
00000000`0209fb70 00000000`748f2c74 kernel32!GetQueuedCompletionStatusStub+0×11 
00000000`0209fbb0 00000000`0045cbc0 mprtp!MpPluginSignatureChange+0×3e170 
00000000`0209fbb8 000007fe`fbac25ff 0×45cbc0 
00000000`0209fbc0 00000000`00466610 FLTLIB!FilterGetMessage+0×2b 
00000000`0209fc20 00000000`00000000 0×466610 
THREAD fffffa800845c060  Cid 03f4.065c  Teb: 000007fffff8e000 Win32Thread: 0000000000000000 
WAIT: (WrQueue) UserMode Non-Alertable 
    fffffa800843c2c0  QueueObject 
Not impersonating 
DeviceMap                 fffff8a000008aa0 
Owning Process            fffffa800916b060       Image:         MsMpEng.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      21520          Ticks: 775 (0:00:00:12.090) 
Context Switch Count      4979             
UserTime                  00:00:04.149 
KernelTime                00:00:00.156 
Win32 Start Address msvcrt!endthreadex (0×000007feff5173fc) 
Stack Init fffff88009d52c70 Current fffff88009d52660 
Base fffff88009d53000 Limit fffff88009d4d000 Call 0 
Priority 8 BasePriority 8 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
*** ERROR: Symbol file could not be found.  Defaulted to export symbols for mprtp.dll - 
Child-SP          RetAddr           Call Site 
fffff880`09d526a0 fffff800`02ee6f32 nt!KiSwapContext+0×7a 
fffff880`09d527e0 fffff800`02ee9f93 nt!KiCommitThreadWait+0×1d2 
fffff880`09d52870 fffff800`031ca647 nt!KeRemoveQueueEx+0×323 
fffff880`09d52930 fffff800`0319cae5 nt!IoRemoveIoCompletion+0×47 

Two WinDbg Scripts That Changed the World    35 
fffff880`09d529c0 fffff800`02ee0ed3 nt!NtRemoveIoCompletion+0×145 
fffff880`09d52a70 00000000`772f13aa nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`09d52ae0) 
00000000`01ccf498 000007fe`fd9e169d ntdll!ZwRemoveIoCompletion+0xa 
00000000`01ccf4a0 00000000`7718a4e1 KERNELBASE!GetQueuedCompletionStatus+0×39 
00000000`01ccf500 00000000`748f2c74 kernel32!GetQueuedCompletionStatusStub+0×11 
00000000`01ccf540 00000000`0045d030 mprtp!MpPluginSignatureChange+0×3e170 
00000000`01ccf548 000007fe`fbac25ff 0×45d030 
00000000`01ccf550 00000000`004666b0 FLTLIB!FilterGetMessage+0×2b 
00000000`01ccf5b0 00000000`00000000 0×4666b0 
THREAD fffffa80092b7060  Cid 03f4.1268  Teb: 000007fffff6a000 Win32Thread: 0000000000000000 
WAIT: (WrQueue) UserMode Alertable 
    fffffa8009299140  QueueObject 
Not impersonating 
DeviceMap                 fffff8a000008aa0 
Owning Process            fffffa800916b060       Image:         MsMpEng.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      7762           Ticks: 14533 (0:00:03:46.716) 
Context Switch Count      3297             
UserTime                  00:00:06.489 
KernelTime                00:00:00.499 
Win32 Start Address ntdll!TppWorkerThread (0×00000000772bfbc0) 
Stack Init fffff8800e620c70 Current fffff8800e620680 
Base fffff8800e621000 Limit fffff8800e61b000 Call 0 
Priority 8 BasePriority 8 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff880`0e6206c0 fffff800`02ee6f32 nt!KiSwapContext+0×7a 
fffff880`0e620800 fffff800`02ee9f93 nt!KiCommitThreadWait+0×1d2 
fffff880`0e620890 fffff800`031ca647 nt!KeRemoveQueueEx+0×323 
fffff880`0e620950 fffff800`02ecdb36 nt!IoRemoveIoCompletion+0×47 
fffff880`0e6209e0 fffff800`02ee0ed3 nt!NtWaitForWorkViaWorkerFactory+0×285 
fffff880`0e620ae0 00000000`772f2c1a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`0e620ae0) 
00000000`0540f998 00000000`772bfe0b ntdll!ZwWaitForWorkViaWorkerFactory+0xa 
00000000`0540f9a0 00000000`7719652d ntdll!TppWorkerThread+0×2c9 
00000000`0540fca0 00000000`772cc521 kernel32!BaseThreadInitThunk+0xd 
00000000`0540fcd0 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
THREAD fffffa80098d7b60  Cid 07bc.0a14  Teb: 000007fffffd7000 Win32Thread: fffff900c2ca0c20 
WAIT: (UserRequest) KernelMode Non-Alertable 
    fffffa8008a4a030  NotificationEvent 
Not impersonating 
DeviceMap                 fffff8a001ce6b90 
Owning Process            fffffa80096beb30       Image:         dwm.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      22294          Ticks: 1 (0:00:00:00.015) 
Context Switch Count      15473                 LargeStack 
UserTime                  00:00:06.801 
KernelTime                00:00:02.917 
Win32 Start Address dwmcore!CPartitionThread::ThreadMain (0×000007fef8a1f0d8) 
Stack Init fffff8800d3d5c70 Current fffff8800d3d5740 
Base fffff8800d3d6000 Limit fffff8800d3cf000 Call 0 
Priority 15 BasePriority 15 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff880`0d3d5780 fffff800`02ee6f32 nt!KiSwapContext+0×7a 
fffff880`0d3d58c0 fffff800`02ee974f nt!KiCommitThreadWait+0×1d2 
fffff880`0d3d5950 fffff880`0fef65b3 nt!KeWaitForSingleObject+0×19f 
fffff880`0d3d59f0 fffff960`001fedea dxgkrnl!DxgkWaitForVerticalBlankEvent+0×53f 
fffff880`0d3d5ab0 fffff800`02ee0ed3 win32k!NtGdiDdDDIWaitForVerticalBlankEvent+0×12 
fffff880`0d3d5ae0 000007fe`ff1d143a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`0d3d5ae0) 
00000000`0287f778 000007fe`f8791da1 GDI32!NtGdiDdDDIWaitForVerticalBlankEvent+0xa 
00000000`0287f780 000007fe`f89e1b6e dxgi!CDXGIOutput::WaitForVBlank+0×51 
00000000`0287f7c0 000007fe`f89e1ae9 dwmcore!CD3DDeviceLevel1::WaitForVBlank+0×1f9 
00000000`0287f810 000007fe`f89e1a9d dwmcore!CHwDisplayRenderTarget::WaitForVBlank+0×39 
00000000`0287f850 000007fe`f89e1a4c dwmcore!CDesktopRenderTarget::WaitForVBlank+0×40 
00000000`0287f880 000007fe`f89d3513 dwmcore!CSlaveHWndRenderTarget::WaitForVBlank+0×2c 
00000000`0287f8c0 000007fe`f89d3584 dwmcore!CRenderTargetManager::WaitForVBlank+0×7d 
00000000`0287f900 000007fe`f89d2661 
dwmcore!CPartitionVerticalBlankScheduler::WaitForVBlank+0×7c 
00000000`0287f950 000007fe`f8a1f0f4 dwmcore!CPartitionVerticalBlankScheduler::Run+0xe5 
00000000`0287f9b0 00000000`7719652d dwmcore!CPartitionThread::ThreadMain+0×1c 
00000000`0287f9e0 00000000`772cc521 kernel32!BaseThreadInitThunk+0xd 
00000000`0287fa10 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 

36    PART 1: Professional Crash Dump Analysis and Debugging 
THREAD fffffa800451d720  Cid 1418.17fc  Teb: 000007fffffdc000 Win32Thread: 0000000000000000 
RUNNING on processor 2 
Not impersonating 
DeviceMap                 fffff8a001ce6b90 
Owning Process            fffffa800442ab30       Image:         ApplicationE.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      22295          Ticks: 0 
Context Switch Count      27960             
UserTime                  00:01:25.332 
KernelTime                00:00:00.015 
*** ERROR: Module load completed but symbols could not be loaded for ApplicationE.exe 
Win32 Start Address ApplicationE (0×000000013f0f1578) 
Stack Init fffff8800723cc70 Current fffff8800723c960 
Base fffff8800723d000 Limit fffff88007237000 Call 0 
Priority 8 BasePriority 8 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 
00000000`0021f9e0 00000000`00000000 ApplicationE+0×6cd3 
 
 

Raw Stack Dump of All Threads (Kernel Space)    37 
Raw Stack Dump of All Threads (Kernel Space) 
Having done in the past with user space raw stack data analysis for 32-bit complete 
memory dumps (Volume 1, page 236) we found today the need to look at kernel raw 
stack data from all threads and created this fast script: 
!for_each_thread "!thread @#Thread; r? $t1 = ((nt!_KTHREAD *) @#Thread )-
>StackLimit; r? $t2 = ((nt!_KTHREAD *) @#Thread )->InitialStack; dps @$t1 
@$t2" 
It can be run for kernel and complete memory dumps from both x86 and x64 
systems. If we need correct symbolic mapping for user space in kernel space data, we 
need to modify it a bit, and it will be slower to run. 
!for_each_thread "!thread @#Thread 3f; .thread /r /p @#Thread; r? $t1 = 
((nt!_KTHREAD *) @#Thread )->StackLimit; r? $t2 = ((nt!_KTHREAD *) 
@#Thread )->InitialStack; dps @$t1 @$t2" 
 
 

38    PART 1: Professional Crash Dump Analysis and Debugging 
The Design of Memory Dump Analysis: 7 Steps of Highly Successful 
Analysts 
We were recently asked to outline a simple approach to proceed after opening a 
memory dump. So we came up with these 7 steps: 
1. !analyze -v [-hang] 
2. Exception (Bugcheck): stack trace analysis with d* and lmv 
3. !locks 
4. !runaway f (!running) 
5. Dump all (processes and) thread stack traces [with 32-bit] ~*kv (!process 0 3f) 
6. Search for signs/patterns of abnormal behavior (exceptions, wait chains, 
message boxes [, from your custom checklist4]) 
7. Narrow analysis down to a specific thread and dump raw stack data if needed 
[repeat*] 
(Commands / options in brackets denote kernel/complete dump variation) 
[Notes in square brackets denote additional options, such as x64 specifics, your product 
details, etc.] 
 
 
                                                                 
4 http://www.dumpanalysis.org/windows-memory-analysis-checklist 

Postmortem Effects of -g    39 
Postmortem Effects of -g 
One of attendees of our Accelerated Memory Dump Analysis training5 pointed us to the 
possible effects of -g option for AeDebug custom postmortem debugger (Volume 1, 
page 618) command line for CDB, NTSD or WinDbg. So we tested that with x64 TestWER 
tool6 (should be the same with an x86 version) and indeed there are differences. 
With -g option with have this stack trace: 
AeDebug\Debugger = "C:\Program Files\Debugging Tools for Windows 
(x64)\windbg.exe" -p %ld -e %ld -g 
0:000> kL 
Child-SP RetAddr Call Site 
00000000`0012f210 00000001`40004148 
TestWER64!CTestDefaultDebuggerDlg::OnBnClickedButton1+0x7e 
00000000`0012f250 00000001`40004388 TestWER64!_AfxDispatchCmdMsg+0xc4 
00000000`0012f280 00000001`40003552 TestWER64!CCmdTarget::OnCmdMsg+0x180 
00000000`0012f2e0 00000001`4000cc44 TestWER64!CDialog::OnCmdMsg+0x32 
00000000`0012f320 00000001`4000d877 TestWER64!CWnd::OnCommand+0xcc 
00000000`0012f3b0 00000001`40008c2c TestWER64!CWnd::OnWndMsg+0x5f 
00000000`0012f4f0 00000001`4000c272 TestWER64!CWnd::WindowProc+0x38 
00000000`0012f530 00000001`4000c32d TestWER64!AfxCallWndProc+0xfe 
00000000`0012f5d0 00000000`77519bd1 TestWER64!AfxWndProc+0x59 
00000000`0012f610 00000000`77516aa8 USER32!UserCallWinProcCheckWow+0x1ad 
00000000`0012f6d0 00000000`77516bad USER32!SendMessageWorker+0x682 
00000000`0012f760 000007fe`fccb0bbf USER32!SendMessageW+0x5c 
00000000`0012f7b0 000007fe`fccb47df COMCTL32!Button_ReleaseCapture+0x157 
00000000`0012f7f0 00000000`77519bd1 COMCTL32!Button_WndProc+0xcbf 
00000000`0012f8b0 00000000`775198da USER32!UserCallWinProcCheckWow+0x1ad 
00000000`0012f970 00000000`775167c2 USER32!DispatchMessageWorker+0x3b5 
00000000`0012f9f0 00000001`400079cc USER32!IsDialogMessageW+0x153 
00000000`0012fa80 00000001`40009148 TestWER64!CWnd::IsDialogMessageW+0x38 
00000000`0012fab0 00000001`40003513 TestWER64!CWnd::PreTranslateInput+0x28 
00000000`0012fae0 00000001`4000b696 TestWER64!CDialog::PreTranslateMessage+0xc3 
00000000`0012fb10 00000001`40004c1f TestWER64!CWnd::WalkPreTranslateTree+0x3a 
00000000`0012fb40 00000001`40004c7f TestWER64!AfxInternalPreTranslateMessage+0x67 
00000000`0012fb70 00000001`40004e26 TestWER64!AfxPreTranslateMessage+0x23 
00000000`0012fba0 00000001`40004e6b TestWER64!AfxInternalPumpMessage+0x3a 
00000000`0012fbd0 00000001`4000aba6 TestWER64!AfxPumpMessage+0x1b 
00000000`0012fc00 00000001`40003e4a TestWER64!CWnd::RunModalLoop+0xea 
00000000`0012fc60 00000001`40024da4 TestWER64!CDialog::DoModal+0x1c6 
00000000`0012fd10 00000001`40024625 
TestWER64!CTestDefaultDebuggerApp::InitInstance+0xc4 
00000000`0012fe70 00000001`400153c2 TestWER64!AfxWinMain+0x75 
00000000`0012feb0 00000000`77ad652d TestWER64!__tmainCRTStartup+0x186 
                                                                 
5 http://www.patterndiagnostics.com/accelerated-windows-memory-dump-analysis 
6 http://support.citrix.com/article/CTX111901 

40    PART 1: Professional Crash Dump Analysis and Debugging 
00000000`0012ff60 00000000`77c0c521 kernel32!BaseThreadInitThunk+0xd 
00000000`0012ff90 00000000`00000000 ntdll!RtlUserThreadStart+0x1d 
0:000> r 
rax=0000000000000000 rbx=0000000000000001 rcx=000000000012fd50 
rdx=00000000000003e8 rsi=000000000012fd50 rdi=000000014002daa0 
rip=00000001400247ae rsp=000000000012f210 rbp=0000000000000111 
r8=0000000000000000 r9=0000000140024730 r10=0000000140024730 
r11=000000000012f310 r12=0000000000000000 r13=00000000000003e8 
r14=0000000000000110 r15=0000000000000001 
iopl=0 nv up ei pl zr na po nc 
cs=0033 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00010244 
TestWER64!CTestDefaultDebuggerDlg::OnBnClickedButton1+0x7e: 
00000001`400247ae c704250000000000000000 mov dword ptr [0],0 
ds:00000000`00000000=???????? 
Without -g option we also see exception processing (highlighted in bold): 
AeDebugger\Debugger = "C:\Program Files\Debugging Tools for Windows 
(x64)\windbg.exe" -p %ld -e %ld 
0:000> kL 
Child-SP RetAddr Call Site 
00000000`0012e368 000007fe`fe301420 ntdll!ZwWaitForMultipleObjects+0xa 
00000000`0012e370 00000000`77ae2cf3 KERNELBASE!WaitForMultipleObjectsEx+0xe8 
00000000`0012e470 00000000`77b590f5 
kernel32!WaitForMultipleObjectsExImplementation+0xb3 
00000000`0012e500 00000000`77b59277 kernel32!WerpReportFaultInternal+0×215 
00000000`0012e5a0 00000000`77b592cf kernel32!WerpReportFault+0×77 
00000000`0012e5d0 00000000`77b594ec kernel32!BasepReportFault+0×1f 
00000000`0012e600 00000000`77c743b8 kernel32!UnhandledExceptionFilter+0×1fc 
00000000`0012e6e0 00000000`77bf85a8 ntdll! ?? ::FNODOBFM::`string’+0×2365 
00000000`0012e710 00000000`77c09d0d ntdll!_C_specific_handler+0×8c 
00000000`0012e780 00000000`77bf91af ntdll!RtlpExecuteHandlerForException+0xd 
00000000`0012e7b0 00000000`77c31278 ntdll!RtlDispatchException+0×45a 
00000000`0012ee90 00000001`400247ae ntdll!KiUserExceptionDispatcher+0×2e 
00000000`0012f450 00000001`40004148 
TestWER64!CTestDefaultDebuggerDlg::OnBnClickedButton1+0×7e 
00000000`0012f490 00000001`40004388 TestWER64!_AfxDispatchCmdMsg+0xc4 
00000000`0012f4c0 00000001`40003552 TestWER64!CCmdTarget::OnCmdMsg+0×180 
00000000`0012f520 00000001`4000cc44 TestWER64!CDialog::OnCmdMsg+0×32 
00000000`0012f560 00000001`4000d877 TestWER64!CWnd::OnCommand+0xcc 
00000000`0012f5f0 00000001`40008c2c TestWER64!CWnd::OnWndMsg+0×5f 
00000000`0012f730 00000001`4000c272 TestWER64!CWnd::WindowProc+0×38 
00000000`0012f770 00000001`4000c32d TestWER64!AfxCallWndProc+0xfe 
00000000`0012f810 00000000`77519bd1 TestWER64!AfxWndProc+0×59 
00000000`0012f850 00000000`77516aa8 USER32!UserCallWinProcCheckWow+0×1ad 
00000000`0012f910 00000000`77516bad USER32!SendMessageWorker+0×682 
00000000`0012f9a0 00000000`7751eda7 USER32!SendMessageW+0×5c 
00000000`0012f9f0 00000001`400079cc USER32!IsDialogMessageW+0×85f 
00000000`0012fa80 00000001`40009148 TestWER64!CWnd::IsDialogMessageW+0×38 
00000000`0012fab0 00000001`40003513 TestWER64!CWnd::PreTranslateInput+0×28 
00000000`0012fae0 00000001`4000b696 TestWER64!CDialog::PreTranslateMessage+0xc3 
00000000`0012fb10 00000001`40004c1f TestWER64!CWnd::WalkPreTranslateTree+0×3a 
00000000`0012fb40 00000001`40004c7f TestWER64!AfxInternalPreTranslateMessage+0×67 
00000000`0012fb70 00000001`40004e26 TestWER64!AfxPreTranslateMessage+0×23 
00000000`0012fba0 00000001`40004e6b TestWER64!AfxInternalPumpMessage+0×3a 
00000000`0012fbd0 00000001`4000aba6 TestWER64!AfxPumpMessage+0×1b 
00000000`0012fc00 00000001`40003e4a TestWER64!CWnd::RunModalLoop+0xea 

Postmortem Effects of -g    41 
00000000`0012fc60 00000001`40024da4 TestWER64!CDialog::DoModal+0×1c6 
00000000`0012fd10 00000001`40024625 
TestWER64!CTestDefaultDebuggerApp::InitInstance+0xc4 
00000000`0012fe70 00000001`400153c2 TestWER64!AfxWinMain+0×75 
00000000`0012feb0 00000000`77ad652d TestWER64!__tmainCRTStartup+0×186 
00000000`0012ff60 00000000`77c0c521 kernel32!BaseThreadInitThunk+0xd 
00000000`0012ff90 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
We now prefer omitting -g option to get stack traces equivalent to manual 
crash dumps saved by userdump.exe on pre-Vista platforms and Task Manager on later 
platforms. 
 
 

42    PART 1: Professional Crash Dump Analysis and Debugging 
Event Owners 
When we dump Stack Trace Collection (Volume 1, page 409) from a complete or kernel 
memory dump we see lots of synchronization and notification events, for example: 
THREAD fffffa8003d33120  Cid 0734.0868  Teb: 000007fffffd4000 Win32Thread: 
fffff900c07182e0 WAIT: (UserRequest) UserMode Alertable 
fffffa8003413d20  NotificationEvent 
fffffa80020b5170  NotificationEvent 
fffffa80017f31e0  NotificationEvent 
fffffa80013f8cf0  NotificationEvent 
fffffa8002547ee0  NotificationEvent 
fffffa8002547e80  NotificationEvent 
fffffa8004186100  NotificationEvent 
fffffa8003dcfa80  NotificationEvent 
fffffa8003df6870  NotificationEvent 
fffffa8003bbd5e0  NotificationEvent 
fffffa8003b5d4e0  NotificationEvent 
fffffa800390c690  NotificationEvent 
fffffa8003dbc410  NotificationEvent 
fffffa8003dbc3b0  NotificationEvent 
fffffa8004041040  NotificationEvent 
fffffa8003dde8a0  NotificationEvent 
fffffa80038f4530  NotificationEvent 
fffffa800401fa50  NotificationEvent 
fffffa800398a550  NotificationEvent 
fffffa8003b587e0  NotificationEvent 
fffffa800398d200  SynchronizationEvent 
IRP List: 
fffffa800150b010: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa80015c1010: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa80017f53a0: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa80014ccca0: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa80011fa710: (0006,03a0) Flags: 00060000  Mdl: 00000000 
fffffa80011d6070: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa80030b5450: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa8004149810: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa800419b500: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa80040c2520: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa8003b75520: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa8004082ca0: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa8004082010: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa800403aa40: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa800403a010: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa8003dbc9d0: (0006,0358) Flags: 00060000  Mdl: 00000000 
fffffa8003dbc010: (0006,0358) Flags: 00060000  Mdl: 00000000 
Not impersonating 
DeviceMap                 fffff88001697690 
Owning Process            fffffa80039bac10       Image:         explorer.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      41897          Ticks: 561 (0:00:00:08.765) 
Context Switch Count      4744                 LargeStack 
UserTime                  00:00:00.187 
KernelTime                00:00:01.218 
Win32 Start Address SHLWAPI!WrapperThreadProc (0×000007fefe854f20) 
Stack Init fffff9800ef2fdb0 Current fffff9800ef2f260 
Base fffff9800ef30000 Limit fffff9800ef27000 Call 0 
Priority 12 BasePriority 8 PriorityDecrement 2 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 

Event Owners    43 
fffff980`0ef2f2a0 fffff800`0185d695 nt!KiSwapContext+0×84 
fffff980`0ef2f3e0 fffff800`0185ad2f nt!KiSwapThread+0×125 
fffff980`0ef2f440 fffff800`01ac1813 nt!KeWaitForMultipleObjects+0×703 
fffff980`0ef2f4b0 fffff800`01ac1a03 nt!ObpWaitForMultipleObjects+0×216 
fffff980`0ef2f960 fffff800`0184dcf3 nt!NtWaitForMultipleObjects+0xe2 
fffff980`0ef2fbb0 00000000`776f082a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff980`0ef2fc20) 
00000000`03acf718 00000000`774ced73 ntdll!NtWaitForMultipleObjects+0xa 
00000000`03acf720 00000000`775ee97d kernel32!WaitForMultipleObjectsEx+0×10b 
00000000`03acf830 00000000`775ee86e USER32!RealMsgWaitForMultipleObjectsEx+0×129 
00000000`03acf8d0 000007fe`fed47a9a USER32!MsgWaitForMultipleObjectsEx+0×46 
00000000`03acf910 000007fe`fe854d48 SHELL32!CChangeNotify::ThreadProc+0xba 
00000000`03acfb90 00000000`774ccdcd SHLWAPI!WrapperThreadProc+0xfc 
00000000`03acfc70 00000000`776ec6e1 kernel32!BaseThreadInitThunk+0xd 
00000000`03acfca0 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
The problem with such synchronization objects as events is that they don’t have 
an owner field as in other structures: 
1: kd> dt -r _KEVENT 
ntdll!_KEVENT 
+0x000 Header           : _DISPATCHER_HEADER 
+0x000 Type             : UChar 
+0x001 Abandoned        : UChar 
+0x001 Absolute         : UChar 
+0x001 NpxIrql          : UChar 
+0x001 Signalling       : UChar 
+0x002 Size             : UChar 
+0x002 Hand             : UChar 
+0x003 Inserted         : UChar 
+0x003 DebugActive      : UChar 
+0x003 DpcActive        : UChar 
+0x000 Lock             : Int4B 
+0x004 SignalState      : Int4B 
+0x008 WaitListHead     : _LIST_ENTRY 
+0x000 Flink            : Ptr64 _LIST_ENTRY 
+0x008 Blink            : Ptr64 _LIST_ENTRY 
1: kd> dt _KMUTANT 
nt!_KMUTANT 
+0x000 Header           : _DISPATCHER_HEADER 
+0x018 MutantListEntry  : _LIST_ENTRY 
+0×028 OwnerThread      : Ptr64 _KTHREAD 
+0×030 Abandoned        : UChar 
+0×031 ApcDisable       : UChar 
Fortunately, many of such events are created to wait for asynchronous I/O and 
their addresses are stored in IRP structures that also have an associated thread. For 
example, in the thread above we find one of notification events, fffffa80020b5170, in an 
IRP fffffa800150b010: 

44    PART 1: Professional Crash Dump Analysis and Debugging 
1: kd> !irp fffffa800150b010 -v 
Irp is active with 9 stacks 9 is current (= 0xfffffa800150b320) 
No Mdl: No System Buffer: Thread fffffa8003d33120:  Irp stack trace. 
Flags = 00060000 
ThreadListEntry.Flink = fffffa80015c1030 
ThreadListEntry.Blink = fffffa8003d334d8 
IoStatus.Status = 00000000 
IoStatus.Information = fffff88002ac09c0 
RequestorMode = 00000001 
Cancel = 00 
CancelIrql = 0 
ApcEnvironment = 00 
UserIosb = 04127ca0 
UserEvent = fffffa80020b5170 
Overlay.AsynchronousParameters.UserApcRoutine = 00000000 
Overlay.AsynchronousParameters.UserApcContext = 04127ca0 
Overlay.AllocationSize = 00000000 - 00000000 
CancelRoutine = fffff80001912fc0   nt!FsRtlCancelNotify 
UserBuffer = 04127498 
& Tail.Overlay.DeviceQueueEntry = fffffa800150b088 
Tail.Overlay.Thread = fffffa8003d33120 
Tail.Overlay.AuxiliaryBuffer = 00000000 
Tail.Overlay.ListEntry.Flink = fffff88002ac0a00 
Tail.Overlay.ListEntry.Blink = fffff88002ac0a00 
Tail.Overlay.CurrentStackLocation = fffffa800150b320 
Tail.Overlay.OriginalFileObject = fffffa8002390770 
Tail.Apc = 00000000 
Tail.CompletionKey = 00000000 
cmd  flg cl Device   File     Completion-Context 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
> [  c, 2]   0  1 fffffa8001bcb030 fffffa8002390770 00000000-
00000000    pending 
\FileSystem\Ntfs 
Args: 00000800 00000015 00000000 00000000 
Another example is when IRP fffffa80022d4410 was created by one thread 
fffffa8002119700, but another thread fffffa8001fda450 is waiting for its associated 
event fffffa8002093190: 

Event Owners    45 
1: kd> !irpfind 
Irp    [ Thread ] irpStack: (Mj,Mn)   DevObj  [Driver]         MDL Process 
fffffa8002f2d980 [00000000] irpStack: ( f, 0)  fffffa8002f6f050 [ \Driver\usbehci] 
fffffa800200dc40 [fffffa80030a0710] irpStack: ( d, 0)  fffffa8001f192d0 [ 
\FileSystem\Npfs] 
fffffa800203d280 [fffffa80035b1b10] irpStack: ( e, 0)  fffffa8001c09b50 [ 
\Driver\netbt] 0xfffffa8002f10970 
fffffa800228e4e0 [00000000] irpStack: ( e, 0)  fffffa8002be1840 [ \Driver\CmBatt] 
fffffa800229c6a0 [00000000] irpStack: ( f, 0)  fffffa8002f2c050 [ \Driver\usbuhci] 
fffffa800229a6a0 [00000000] irpStack: ( f, 0)  fffffa8002f2c050 [ \Driver\usbuhci] 
fffffa80022946a0 [00000000] irpStack: ( f, 0)  fffffa8002f2c050 [ \Driver\usbuhci] 
fffffa80022a28a0 [00000000] irpStack: ( f, 0)  fffffa80022d04c0 [ \Driver\usbhub] 
fffffa80022a6230 [00000000] irpStack: ( f, 0)  fffffa8002f2c050 [ \Driver\usbuhci] 
fffffa80022d4410 [fffffa8002119700] irpStack: ( e,2d)  fffffa80022ee720 [ 
\Driver\AFD] 
[...] 
1: kd> !irp fffffa80022d4410 -v 
Irp is active with 4 stacks 4 is current (= 0xfffffa80022d45b8) 
No Mdl: System buffer=fffffa8001fda150: Thread fffffa8002119700:  Irp 
stack trace. 
Flags = 00060030 
ThreadListEntry.Flink = fffffa8002396c80 
ThreadListEntry.Blink = fffffa8002119ab8 
IoStatus.Status = 00000000 
IoStatus.Information = 00000000 
RequestorMode = 00000001 
Cancel = 00 
CancelIrql = 0 
ApcEnvironment = 00 
UserIosb = 7fefc914858 
UserEvent = fffffa8002093190 
Overlay.AsynchronousParameters.UserApcRoutine = 00000000 
Overlay.AsynchronousParameters.UserApcContext = 7fefc914858 
Overlay.AllocationSize = 00000000 - 00000000 
CancelRoutine = fffff980044ad250   afd!AfdCancelAddressListChange 
UserBuffer = 00000000 
& Tail.Overlay.DeviceQueueEntry = fffffa80022d4488 
Tail.Overlay.Thread = fffffa8002119700 
Tail.Overlay.AuxiliaryBuffer = 00000000 
Tail.Overlay.ListEntry.Flink = 00000000 
Tail.Overlay.ListEntry.Blink = 00000000 
Tail.Overlay.CurrentStackLocation = fffffa80022d45b8 
Tail.Overlay.OriginalFileObject = fffffa8002bbe050 
Tail.Apc = 00000000 
Tail.CompletionKey = 00000000 
cmd  flg cl Device   File     Completion-Context 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
Args: 00000000 00000000 00000000 00000000 
> [  e,2d]   5  1 fffffa80022ee720 fffffa8002bbe050 00000000-
00000000    pending 

46    PART 1: Professional Crash Dump Analysis and Debugging 
\Driver\AFD 
Args: fffffa8002bbef50 fffffa8002bbef50 fffff9800446cf00 fffffa800250d220 
THREAD fffffa8002119700  Cid 0310.0318  Teb: 000007fffffdc000 Win32Thread: 
fffff900c07b6d60 WAIT: (DelayExecution) UserMode Non-Alertable 
fffffa80021197b8  NotificationTimer 
IRP List: 
fffffa80022d4410: (0006,03a0) Flags: 00060030  Mdl: 00000000 
fffffa8002396c60: (0006,03a0) Flags: 00060030  Mdl: 00000000 
Not impersonating 
DeviceMap                 fffff880017b4c70 
Owning Process            fffffa800209f880       Image:         svchost.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      42336          Ticks: 122 (0:00:00:01.906) 
Context Switch Count      159                 LargeStack 
UserTime                  00:00:00.031 
KernelTime                00:00:00.140 
Win32 Start Address ADVAPI32!ScSvcctrlThreadW (0×000007fefe2b4bd0) 
Stack Init fffff9800ccabdb0 Current fffff9800ccab990 
Base fffff9800ccac000 Limit fffff9800cca6000 Call 0 
Priority 9 BasePriority 8 PriorityDecrement 0 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff980`0ccab9d0 fffff800`0185d695 nt!KiSwapContext+0×84 
fffff980`0ccabb10 fffff800`0185bbe9 nt!KiSwapThread+0×125 
fffff980`0ccabb70 fffff800`01a8b1cd nt!KeDelayExecutionThread+0×339 
fffff980`0ccabbf0 fffff800`0184dcf3 nt!NtDelayExecution+0×5c 
fffff980`0ccabc20 00000000`776f05ba nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff980`0ccabc20) 
00000000`000ff9d8 00000000`774cd908 ntdll!NtDelayExecution+0xa 
00000000`000ff9e0 000007fe`fc8ba8c0 kernel32!SleepEx+0×84 
00000000`000ffa60 000007fe`fc8b17bd rpcss!ObjectExporterWorkerThread+0×50b 
00000000`000ffb30 000007fe`fc8b27f2 rpcss!ScmServiceMain+0xe4 
00000000`000ffb60 00000000`ffaa1771 rpcss!ServiceMain+0×251 
00000000`000ffe20 000007fe`fe2b4bf5 svchost!ServiceStarter+0×1ea 
00000000`000ffeb0 00000000`774ccdcd ADVAPI32!ScSvcctrlThreadW+0×25 
00000000`000ffee0 00000000`776ec6e1 kernel32!BaseThreadInitThunk+0xd 
00000000`000fff10 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
THREAD fffffa8001fda450  Cid 0310.031c  Teb: 000007fffffda000 Win32Thread: 
0000000000000000 WAIT: (UserRequest) UserMode Alertable 
fffffa8002012ef0  SynchronizationTimer 
fffffa800208d7a0  SynchronizationEvent 
fffffa80023bb820  SynchronizationEvent 
fffffa80023bb740  SynchronizationEvent 
fffffa8001fd9730  SynchronizationEvent 
fffffa8002093190  SynchronizationEvent 
fffffa8001a0eee0  SynchronizationEvent 
Not impersonating 
DeviceMap                 fffff880017b4c70 
Owning Process            fffffa800209f880       Image:         svchost.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      5767           Ticks: 36691 (0:00:09:33.296) 
Context Switch Count      8 
UserTime                  00:00:00.000 
KernelTime                00:00:00.000 
Win32 Start Address ntdll!TppWaiterpThread (0×00000000776c6930) 
Stack Init fffff9800d2c0db0 Current fffff9800d2c0260 
Base fffff9800d2c1000 Limit fffff9800d2bb000 Call 0 
Priority 10 BasePriority 8 PriorityDecrement 0 IoPriority 2 PagePriority 5 
Kernel stack not resident. 
Child-SP          RetAddr           Call Site 

Event Owners    47 
fffff980`0d2c02a0 fffff800`0185d695 nt!KiSwapContext+0×84 
fffff980`0d2c03e0 fffff800`0185ad2f nt!KiSwapThread+0×125 
fffff980`0d2c0440 fffff800`01ac1813 nt!KeWaitForMultipleObjects+0×703 
fffff980`0d2c04b0 fffff800`01ac1a03 nt!ObpWaitForMultipleObjects+0×216 
fffff980`0d2c0960 fffff800`0184dcf3 nt!NtWaitForMultipleObjects+0xe2 
fffff980`0d2c0bb0 00000000`776f082a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff980`0d2c0c20) 
00000000`00d1fb08 00000000`776c6b07 ntdll!NtWaitForMultipleObjects+0xa 
00000000`00d1fb10 00000000`774ccdcd ntdll!TppWaiterpThread+0×14d 
00000000`00d1fdb0 00000000`776ec6e1 kernel32!BaseThreadInitThunk+0xd 
00000000`00d1fde0 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
 
 

48    PART 1: Professional Crash Dump Analysis and Debugging 
Improbable Occurrence 
We were analyzing a raw thread stack when came upon this symbolic address which we 
thought was Coincidental (Volume 1, page 390): 
363b0030 77777777 advapi32!LsaEnumerateAccountRights+0×56 
Forward disassembly makes sense here, and every instruction has a purpose: 
0:000> u 77777777 
advapi32!LsaEnumerateAccountRights+0×56: 
77777777 a4  
 
movs byte ptr es:[edi],byte ptr [esi] 
77777778 fc  
 
cld 
77777779 ffc3   
inc ebx 
7777777b 8b65e8  
mov esp,dword ptr [ebp-18h] 
7777777e ff75e0  
push dword ptr [ebp-20h] 
77777781 ff15e4187377  call dword ptr [advapi32!_imp__I_RpcMapWin32Status 
(777318e4)] 
77777787 50  
 
push eax 
77777788 e8c6f6fbff  
call advapi32!LsapApiReturnResult (77736e53) 
 
 

Pattern Cooperation    49 
Pattern Cooperation 
Here is another case study involving multiple patterns (most of them were published in 
the previous volumes): Incomplete Session, ALPC and critical section Wait Chains, 
Blocked Thread, and Dialog Box.  
It was reported that a user couldn’t start a session. A complete memory dump 
was generated, and we found 3 sessions there. Looking at the last one we found it 
Incomplete (page 150) with only 3 processes (a normal running user session after 
initialization was expected to have more than 3 processes): 
0: kd> !session 
Sessions on machine: 3 
Valid Sessions: 0 1 2 
0: kd> !sprocess 2 
Dumping Session 2 
_MM_SESSION_SPACE fffffa600a3e1000 
_MMSESSION fffffa600a3e1b40 
PROCESS fffffa8007f6c040 
SessionId: 2 Cid: 242c Peb: 7fffffd8000 ParentCid: 2374 
DirBase: 58350000 ObjectTable: fffff8800f485630 HandleCount: 192. 
Image: csrss.exe 
PROCESS fffffa8007de8130 
SessionId: 2 Cid: 1a48 Peb: 7fffffde000 ParentCid: 2374 
DirBase: 15755000 ObjectTable: fffff8800c742010 HandleCount: 240. 
Image: winlogon.exe 
PROCESS fffffa8004c2e4a0 
SessionId: 2 Cid: 17b8 Peb: 7efdf000 ParentCid: 144c 
DirBase: a3b80000 ObjectTable: fffff8800bf1d350 HandleCount: 168. 
Image: AppA.exe 
Looking at AppA process we find its Main Thread (Volume 1, page 437) blocked 
in ALPC request (Wait Chain, Volume 3, page 97) directed to ServiceA process: 
 
 

50    PART 1: Professional Crash Dump Analysis and Debugging 
0: kd> !process fffffa8004c2e4a0 3f 
PROCESS fffffa8004c2e4a0 
SessionId: 2  Cid: 17b8    Peb: 7efdf000  ParentCid: 144c 
DirBase: a3b80000  ObjectTable: fffff8800bf1d350  HandleCount: 168. 
Image: AppA.exe 
VadRoot fffffa8006d7f310 Vads 192 Clone 0 Private 572. Modified 2. Locked 0. 
DeviceMap fffff88015685f30 
Token                             fffff8800a245050 
ElapsedTime                       01:58:00.200 
UserTime                          00:00:00.000 
KernelTime                        00:00:00.015 
QuotaPoolUsage[PagedPool]         140256 
QuotaPoolUsage[NonPagedPool]      18368 
Working Set Sizes (now,min,max)  (2025, 50, 345) (8100KB, 200KB, 1380KB) 
PeakWorkingSetSize                2087 
VirtualSize                       74 Mb 
PeakVirtualSize                   79 Mb 
PageFaultCount                    2351 
MemoryPriority                    BACKGROUND 
BasePriority                      8 
CommitCharge                      741 
Job                               fffffa80063de710 
THREAD fffffa8006db8440  Cid 17b8.20e0  Teb: 000000007efdb000 Win32Thread: 
fffff900c0b0c4f0 WAIT: (WrLpcReply) UserMode Non-Alertable 
fffffa8006db87d0  Semaphore Limit 0x1 
Waiting for reply to ALPC Message fffff8800f487cf0 : queued at port fffffa8004b37d90 
: owned by process fffffa8004b11c10 
Not impersonating 
DeviceMap                 fffff88015685f30 
Owning Process            fffffa8004c2e4a0       Image:         AppA.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      4244174        Ticks: 453096 (0:01:57:59.625) 
Context Switch Count      132                 LargeStack 
UserTime                  00:00:00.031 
KernelTime                00:00:00.109 
Win32 Start Address AppA!WinMainCRTStartup (0×00000000658c9866) 
Stack Init fffffa6008832db0 Current fffffa6008832670 
Base fffffa6008833000 Limit fffffa600882a000 Call 0 
Priority 10 BasePriority 8 PriorityDecrement 0 IoPriority 2 PagePriority 5 
Kernel stack not resident. 
Child-SP          RetAddr           Call Site 
fffffa60`088326b0 fffff800`01e5ccfa nt!KiSwapContext+0×7f 
fffffa60`088327f0 fffff800`01e519bb nt!KiSwapThread+0×13a 
fffffa60`08832860 fffff800`01e86b12 nt!KeWaitForSingleObject+0×2cb 
fffffa60`088328f0 fffff800`020d40b4 nt!AlpcpSignalAndWait+0×92 
fffffa60`08832980 fffff800`020d0b46 nt!AlpcpReceiveSynchronousReply+0×44 
fffffa60`088329e0 fffff800`020c06ef nt!AlpcpProcessSynchronousRequest+0×24f 
fffffa60`08832b00 fffff800`01e5a573 nt!NtAlpcSendWaitReceivePort+0×19f 
fffffa60`08832bb0 00000000`77cb76ca nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffffa60`08832c20) 
00000000`000be3f8 00000000`7578993f ntdll!ZwAlpcSendWaitReceivePort+0xa 
00000000`000be400 00000000`7577a996 wow64!whNtAlpcSendWaitReceivePort+0×5f 
00000000`000be450 00000000`75813688 wow64!Wow64SystemServiceEx+0xca 
00000000`000bed00 00000000`7577ab46 wow64cpu!ServiceNoTurbo+0×28 
00000000`000bed90 00000000`7577a14c wow64!RunCpuSimulation+0xa 
00000000`000bedc0 00000000`77cabbb3 wow64!Wow64LdrpInitialize+0×4b4 
00000000`000bf320 00000000`77cab83c ntdll!LdrpInitializeProcess+0×13eb 
00000000`000bf5c0 00000000`77c9660e ntdll! ?? ::FNODOBFM::`string’+0×1fbc9 
00000000`000bf670 00000000`00000000 ntdll!LdrInitializeThunk+0xe 

Pattern Cooperation    51 
0: kd> !alpc /m fffff8800f487cf0 
Message @ fffff8800f487cf0 
MessageID             : 0x0640 (1600) 
CallbackID            : 0x36C184 (3588484) 
SequenceNumber        : 0x00000002 (2) 
Type                  : LPC_REQUEST 
DataLength            : 0x0048 (72) 
TotalLength           : 0x0070 (112) 
Canceled              : No 
Release               : No 
ReplyWaitReply        : No 
Continuation          : Yes 
OwnerPort             : fffffa80061946c0 [ALPC_CLIENT_COMMUNICATION_PORT] 
WaitingThread         : fffffa8006db8440 
QueueType             : ALPC_MSGQUEUE_PENDING 
QueuePort             : fffffa8004b37d90 [ALPC_CONNECTION_PORT] 
QueuePortOwnerProcess : fffffa8004b11c10 (ServiceA.exe) 
ServerThread          : fffffa80066d44b0 
QuotaCharged          : No 
CancelQueuePort       : 0000000000000000 
CancelSequencePort    : 0000000000000000 
CancelSequenceNumber  : 0×00000000 (0) 
ClientContext         : 00000000007a5630 
ServerContext         : 0000000000000000 
PortContext           : 0000000005aa3ef0 
CancelPortContext     : 0000000000000000 
SecurityData          : 0000000000000000 
View                  : 0000000000000000 
0: kd> !thread fffffa80066d44b0 3f 
THREAD fffffa80066d44b0  Cid 07d0.1bec  Teb: 000007fffffa2000 Win32Thread: 
0000000000000000 WAIT: (UserRequest) UserMode Non-Alertable 
fffffa800728e420  SynchronizationEvent 
Impersonation token:  fffff8800a245050 (Level Impersonation) 
DeviceMap                 fffff88015685f30 
Owning Process            fffffa8004b11c10       Image:         ServiceA.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      4244188        Ticks: 453082 (0:01:57:59.406) 
Context Switch Count      43 
UserTime                  00:00:00.015 
KernelTime                00:00:00.000 
Win32 Start Address RPCRT4!ThreadStartRoutine (0×000007feff787780) 
Stack Init fffffa6009abbdb0 Current fffffa6009abb940 
Base fffffa6009abc000 Limit fffffa6009ab6000 Call 0 
Priority 10 BasePriority 8 PriorityDecrement 0 IoPriority 2 PagePriority 5 
Kernel stack not resident. 
Child-SP          RetAddr           Call Site 
fffffa60`09abb980 fffff800`01e5ccfa nt!KiSwapContext+0×7f 
fffffa60`09abbac0 fffff800`01e519bb nt!KiSwapThread+0×13a 
fffffa60`09abbb30 fffff800`020be7c8 nt!KeWaitForSingleObject+0×2cb 
fffffa60`09abbbc0 fffff800`01e5a573 nt!NtWaitForSingleObject+0×98 
fffffa60`09abbc20 00000000`77cb6eba nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffffa60`09abbc20) 
00000000`096eedb8 00000000`77c9577a ntdll!ZwWaitForSingleObject+0xa 
00000000`096eedc0 00000000`77c95671 ntdll!RtlpWaitOnCriticalSection+0xea 
00000000`096eee70 00000000`667dfe24 ntdll!RtlEnterCriticalSection+0xf4 
[...] 
 

52    PART 1: Professional Crash Dump Analysis and Debugging 
If we examine ServiceA process, we find critical section Wait Chain (Volume 1, 
page 490) where an endpoint is blocked in Dialog Box (Volume 6, page 63): 
0: kd> .process /r /p fffffa8004b11c10 
Implicit process is now fffffa80`04b11c10 
Loading User Symbols 
0: kd> !cs -l -o -s 
----------------------------------------- 
DebugInfo          = 0x00000000003a4880 
Critical section   = 0x000000006684d4c0 
LOCKED 
LockCount          = 0×3 
WaiterWoken        = No 
OwningThread       = 0×00000000000023f0 
RecursionCount     = 0×1 
LockSemaphore      = 0×608 
SpinCount          = 0×0000000000000000 
OwningThread       = .thread fffffa8006948650 
ntdll!RtlpStackTraceDataBase is NULL. Probably the stack traces are not 
enabled. 
—————————————– 
DebugInfo          = 0×00000000003b7140 
Critical section   = 0×000000000023f188 (+0×23F188) 
LOCKED 
LockCount          = 0×2 
WaiterWoken        = No 
OwningThread       = 0×0000000000000a38 
RecursionCount     = 0×1 
LockSemaphore      = 0×344 
SpinCount          = 0×0000000000000000 
OwningThread       = .thread fffffa8005d3ebb0 
ntdll!RtlpStackTraceDataBase is NULL. Probably the stack traces are not 
enabled. 
0: kd> .thread /r /p fffffa8006948650 
Implicit thread is now fffffa80`06948650 
Implicit process is now fffffa80`04b11c10 
Loading User Symbols 
0: kd> k 
*** Stack trace for last set context - .thread/.cxr resets it 
Child-SP          RetAddr           Call Site 
fffffa60`0b5ed980 fffff800`01e5ccfa nt!KiSwapContext+0x7f 
fffffa60`0b5edac0 fffff800`01e519bb nt!KiSwapThread+0x13a 
fffffa60`0b5edb30 fffff800`020be7c8 nt!KeWaitForSingleObject+0x2cb 
fffffa60`0b5edbc0 fffff800`01e5a573 nt!NtWaitForSingleObject+0x98 
fffffa60`0b5edc20 00000000`77cb6eba nt!KiSystemServiceCopyEnd+0x13 
00000000`089cef08 00000000`77c9577a ntdll!ZwWaitForSingleObject+0xa 
00000000`089cef10 00000000`77c95671 ntdll!RtlpWaitOnCriticalSection+0xea 
00000000`089cefc0 00000000`667e0ad7 ntdll!RtlEnterCriticalSection+0xf4 
[...] 

Pattern Cooperation    53 
0: kd> .thread /r /p fffffa8005d3ebb0 
Implicit thread is now fffffa80`05d3ebb0 
Implicit process is now fffffa80`04b11c10 
Loading User Symbols 
0: kd> k 
*** Stack trace for last set context - .thread/.cxr resets it 
Child-SP          RetAddr           Call Site 
fffffa60`02ed4c50 fffff800`01e5ccfa nt!KiSwapContext+0x7f 
fffffa60`02ed4d90 fffff800`01e625eb nt!KiSwapThread+0x13a 
fffffa60`02ed4e00 fffff800`020bfc2e nt!KeWaitForMultipleObjects+0x2eb 
fffffa60`02ed4e80 fffff800`020c0273 nt!ObpWaitForMultipleObjects+0x26e 
fffffa60`02ed5340 fffff800`01e5a573 nt!NtWaitForMultipleObjects+0xe2 
fffffa60`02ed5590 00000000`77cb742a nt!KiSystemServiceCopyEnd+0x13 
00000000`034de248 00000000`77a8aff3 ntdll!NtWaitForMultipleObjects+0xa 
00000000`034de250 00000000`77bbe2b5 
kernel32!WaitForMultipleObjectsEx+0x10b 
00000000`034de360 000007fe`fc3d14f2 
USER32!RealMsgWaitForMultipleObjectsEx+0x129 
00000000`034de400 000007fe`fc3d190f DUser!CoreSC::Wait+0x62 
00000000`034de450 000007fe`fc3d188a DUser!CoreSC::WaitMessage+0x6f 
00000000`034de490 00000000`77bc538e DUser!MphWaitMessageEx+0x36 
00000000`034de4c0 00000000`77cb6db6 USER32!_ClientWaitMessageExMPH+0x1a 
00000000`034de510 00000000`77bbd2ba ntdll!KiUserCallbackDispatcherContinue 
00000000`034de578 00000000`77bc5118 USER32!NtUserWaitMessage+0xa 
00000000`034de580 00000000`77bc5770 USER32!DialogBox2+0×261 
00000000`034de600 00000000`77bc57e6 USER32!InternalDialogBox+0×134 
00000000`034de660 00000000`77bc5e18 USER32!DialogBoxIndirectParamAorW+0×58 
00000000`034de6a0 000007fe`fcf349a6 USER32!DialogBoxIndirectParamW+0×18 
[...] 
 
 
 
 

54    PART 1: Professional Crash Dump Analysis and Debugging 
Page Heap Implementation 
It is a well-known fact that page heap is implemented by placing allocations at the end 
of pages with the next non-accessible page to catch buffer overruns leading to heap 
corruption (Dynamic Memory Corruption, Volume 1, page 257). The best way to see it 
is to use !address command that dumps all such allocations: 
0:004> !gflag 
Current NtGlobalFlag contents: 0x02000000 
hpa - Place heap allocations at ends of pages 
0:004> !address 
[...] 
20b10000 20b11000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b11000 20b12000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b12000 20b13000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b13000 20b14000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b14000 20b15000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b15000 20b1a000     5000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b1a000 20b1b000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b1b000 20b1c000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b1c000 20b1d000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b1d000 20b1e000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b1e000 20b1f000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b1f000 20b20000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
+ 20b20000 20b21000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b21000 20b26000     5000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b26000 20b27000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b27000 20b28000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b28000 20b29000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b29000 20b2a000     1000 MEM_PRIVATE 

Page Heap Implementation    55 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b2a000 20b2b000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b2b000 20b2f000     4000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b2f000 20b30000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b30000 20b3f000     f000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b3f000 20b40000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b40000 20b41000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b41000 20b42000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b42000 20b45000     3000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b45000 20b46000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b46000 20b4b000     5000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b4b000 20b4c000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b4c000 20b4d000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b4d000 20b4e000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b4e000 20b4f000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b4f000 20b50000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b50000 20b51000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b51000 20b52000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b52000 20b57000     5000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b57000 20b58000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b58000 20b5d000     5000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b5d000 20b5e000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b5e000 20b5f000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b5f000 20b60000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b60000 20b61000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 

56    PART 1: Professional Crash Dump Analysis and Debugging 
1f410000] 
20b61000 20b62000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b62000 20b6b000     9000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b6b000 20b6f000     4000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b6f000 20b71000     2000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b71000 20b72000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b72000 20b73000     1000 MEM_PRIVATE 
MEM_RESERVE                                    PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
20b73000 20b74000     1000 MEM_PRIVATE 
MEM_COMMIT  PAGE_READWRITE                     PageHeap   [PageHeap: 1f241000; NormalHeap: 
1f410000] 
[...] 
0:004> dc 20b26000 20b27000 
20b26000  00000000 00000000 00000000 00000000  ................ 
20b26010  00000000 00000000 00000000 00000000  ................ 
20b26020  00000000 00000000 00000000 00000000  ................ 
20b26030  00000000 00000000 00000000 00000000  ................ 
20b26040  00000000 00000000 00000000 00000000  ................ 
20b26050  00000000 00000000 00000000 00000000  ................ 
20b26060  00000000 00000000 00000000 00000000  ................ 
20b26070  00000000 00000000 00000000 00000000  ................ 
20b26080  00000000 00000000 00000000 00000000  ................ 
20b26090  00000000 00000000 00000000 00000000  ................ 
20b260a0  00000000 00000000 00000000 00000000  ................ 
20b260b0  00000000 00000000 00000000 00000000  ................ 
20b260c0  00000000 00000000 00000000 00000000  ................ 
20b260d0  00000000 00000000 00000000 00000000  ................ 
20b260e0  00000000 00000000 00000000 00000000  ................ 
20b260f0  00000000 00000000 00000000 00000000  ................ 
20b26100  00000000 00000000 00000000 00000000  ................ 
20b26110  00000000 00000000 00000000 00000000  ................ 
20b26120  00000000 00000000 00000000 00000000  ................ 
20b26130  00000000 00000000 00000000 00000000  ................ 
20b26140  00000000 00000000 00000000 00000000  ................ 
20b26150  00000000 00000000 00000000 00000000  ................ 
20b26160  00000000 00000000 00000000 00000000  ................ 
20b26170  00000000 00000000 00000000 00000000  ................ 
20b26180  00000000 00000000 00000000 00000000  ................ 
20b26190  00000000 00000000 00000000 00000000  ................ 
20b261a0  00000000 00000000 00000000 00000000  ................ 
20b261b0  00000000 00000000 00000000 00000000  ................ 
20b261c0  00000000 00000000 00000000 00000000  ................ 
20b261d0  00000000 00000000 00000000 00000000  ................ 
20b261e0  00000000 00000000 00000000 00000000  ................ 
20b261f0  00000000 00000000 00000000 00000000  ................ 
20b26200  00000000 00000000 00000000 00000000  ................ 
20b26210  00000000 00000000 00000000 00000000  ................ 
20b26220  00000000 00000000 00000000 00000000  ................ 
20b26230  00000000 00000000 00000000 00000000  ................ 
20b26240  00000000 00000000 00000000 00000000  ................ 
20b26250  00000000 00000000 00000000 00000000  ................ 
20b26260  00000000 00000000 00000000 00000000  ................ 
20b26270  00000000 00000000 00000000 00000000  ................ 
20b26280  00000000 00000000 00000000 00000000  ................ 
20b26290  00000000 00000000 00000000 00000000  ................ 
20b262a0  00000000 00000000 00000000 00000000  ................ 
20b262b0  00000000 00000000 00000000 00000000  ................ 
20b262c0  00000000 00000000 00000000 00000000  ................ 
20b262d0  00000000 00000000 00000000 00000000  ................ 
20b262e0  00000000 00000000 00000000 00000000  ................ 

Page Heap Implementation    57 
20b262f0  00000000 00000000 00000000 00000000  ................ 
20b26300  00000000 00000000 00000000 00000000  ................ 
20b26310  00000000 00000000 00000000 00000000  ................ 
20b26320  00000000 00000000 00000000 00000000  ................ 
20b26330  00000000 00000000 00000000 00000000  ................ 
20b26340  00000000 00000000 00000000 00000000  ................ 
20b26350  00000000 00000000 00000000 00000000  ................ 
20b26360  00000000 00000000 00000000 00000000  ................ 
20b26370  00000000 00000000 00000000 00000000  ................ 
20b26380  00000000 00000000 00000000 00000000  ................ 
20b26390  00000000 00000000 00000000 00000000  ................ 
20b263a0  00000000 00000000 00000000 00000000  ................ 
20b263b0  00000000 00000000 00000000 00000000  ................ 
20b263c0  00000000 00000000 00000000 00000000  ................ 
20b263d0  00000000 00000000 00000000 00000000  ................ 
20b263e0  00000000 00000000 00000000 00000000  ................ 
20b263f0  00000000 00000000 00000000 00000000  ................ 
20b26400  00000000 00000000 00000000 00000000  ................ 
20b26410  00000000 00000000 00000000 00000000  ................ 
20b26420  00000000 00000000 00000000 00000000  ................ 
20b26430  00000000 00000000 00000000 00000000  ................ 
20b26440  00000000 00000000 00000000 00000000  ................ 
20b26450  00000000 00000000 00000000 00000000  ................ 
20b26460  00000000 00000000 00000000 00000000  ................ 
20b26470  00000000 00000000 00000000 00000000  ................ 
20b26480  00000000 00000000 00000000 00000000  ................ 
20b26490  00000000 00000000 00000000 00000000  ................ 
20b264a0  00000000 00000000 00000000 00000000  ................ 
20b264b0  00000000 00000000 00000000 00000000  ................ 
20b264c0  00000000 00000000 00000000 00000000  ................ 
20b264d0  00000000 00000000 00000000 00000000  ................ 
20b264e0  00000000 00000000 00000000 00000000  ................ 
20b264f0  00000000 00000000 00000000 00000000  ................ 
20b26500  00000000 00000000 00000000 00000000  ................ 
20b26510  00000000 00000000 00000000 00000000  ................ 
20b26520  00000000 00000000 00000000 00000000  ................ 
20b26530  00000000 00000000 00000000 00000000  ................ 
20b26540  00000000 00000000 00000000 00000000  ................ 
20b26550  00000000 00000000 00000000 00000000  ................ 
20b26560  00000000 00000000 00000000 00000000  ................ 
20b26570  00000000 00000000 00000000 00000000  ................ 
20b26580  00000000 00000000 00000000 00000000  ................ 
20b26590  00000000 00000000 00000000 00000000  ................ 
20b265a0  00000000 00000000 00000000 00000000  ................ 
20b265b0  00000000 00000000 00000000 00000000  ................ 
20b265c0  00000000 00000000 00000000 00000000  ................ 
20b265d0  00000000 00000000 00000000 00000000  ................ 
20b265e0  00000000 00000000 00000000 00000000  ................ 
20b265f0  00000000 00000000 00000000 00000000  ................ 
20b26600  00000000 00000000 00000000 00000000  ................ 
20b26610  00000000 00000000 00000000 00000000  ................ 
20b26620  00000000 00000000 00000000 00000000  ................ 
20b26630  00000000 00000000 00000000 00000000  ................ 
20b26640  00000000 00000000 00000000 00000000  ................ 
20b26650  00000000 00000000 00000000 00000000  ................ 
20b26660  00000000 00000000 00000000 00000000  ................ 
20b26670  00000000 00000000 00000000 00000000  ................ 
20b26680  00000000 00000000 00000000 00000000  ................ 
20b26690  00000000 00000000 00000000 00000000  ................ 
20b266a0  00000000 00000000 00000000 00000000  ................ 
20b266b0  00000000 00000000 00000000 00000000  ................ 
20b266c0  00000000 00000000 00000000 00000000  ................ 
20b266d0  00000000 00000000 00000000 00000000  ................ 
20b266e0  00000000 00000000 00000000 00000000  ................ 
20b266f0  00000000 00000000 00000000 00000000  ................ 
20b26700  00000000 00000000 00000000 00000000  ................ 
20b26710  00000000 00000000 00000000 00000000  ................ 
20b26720  00000000 00000000 00000000 00000000  ................ 
20b26730  00000000 00000000 00000000 00000000  ................ 
20b26740  00000000 00000000 00000000 00000000  ................ 
20b26750  00000000 00000000 00000000 00000000  ................ 
20b26760  00000000 00000000 00000000 00000000  ................ 
20b26770  00000000 00000000 00000000 00000000  ................ 

58    PART 1: Professional Crash Dump Analysis and Debugging 
20b26780  00000000 00000000 00000000 00000000  ................ 
20b26790  00000000 00000000 00000000 00000000  ................ 
20b267a0  00000000 00000000 00000000 00000000  ................ 
20b267b0  00000000 00000000 00000000 00000000  ................ 
20b267c0  00000000 00000000 00000000 00000000  ................ 
20b267d0  00000000 00000000 00000000 00000000  ................ 
20b267e0  00000000 00000000 00000000 00000000  ................ 
20b267f0  00000000 00000000 00000000 00000000  ................ 
20b26800  00000000 00000000 00000000 00000000  ................ 
20b26810  00000000 00000000 00000000 00000000  ................ 
20b26820  00000000 00000000 00000000 00000000  ................ 
20b26830  00000000 00000000 00000000 00000000  ................ 
20b26840  00000000 00000000 00000000 00000000  ................ 
20b26850  00000000 00000000 00000000 00000000  ................ 
20b26860  00000000 00000000 00000000 00000000  ................ 
20b26870  00000000 00000000 00000000 00000000  ................ 
20b26880  00000000 00000000 00000000 00000000  ................ 
20b26890  00000000 00000000 00000000 00000000  ................ 
20b268a0  00000000 00000000 00000000 00000000  ................ 
20b268b0  00000000 00000000 00000000 00000000  ................ 
20b268c0  00000000 00000000 00000000 00000000  ................ 
20b268d0  00000000 00000000 00000000 00000000  ................ 
20b268e0  00000000 00000000 00000000 00000000  ................ 
20b268f0  00000000 00000000 00000000 00000000  ................ 
20b26900  00000000 00000000 00000000 00000000  ................ 
20b26910  00000000 00000000 00000000 00000000  ................ 
20b26920  00000000 00000000 00000000 00000000  ................ 
20b26930  00000000 00000000 00000000 00000000  ................ 
20b26940  00000000 00000000 00000000 00000000  ................ 
20b26950  00000000 00000000 00000000 00000000  ................ 
20b26960  00000000 00000000 00000000 00000000  ................ 
20b26970  00000000 00000000 00000000 00000000  ................ 
20b26980  00000000 00000000 00000000 00000000  ................ 
20b26990  00000000 00000000 00000000 00000000  ................ 
20b269a0  00000000 00000000 00000000 00000000  ................ 
20b269b0  00000000 00000000 00000000 00000000  ................ 
20b269c0  00000000 00000000 00000000 00000000  ................ 
20b269d0  00000000 00000000 00000000 00000000  ................ 
20b269e0  00000000 00000000 00000000 00000000  ................ 
20b269f0  00000000 00000000 00000000 00000000  ................ 
20b26a00  00000000 00000000 00000000 00000000  ................ 
20b26a10  00000000 00000000 00000000 00000000  ................ 
20b26a20  00000000 00000000 00000000 00000000  ................ 
20b26a30  00000000 00000000 00000000 00000000  ................ 
20b26a40  00000000 00000000 00000000 00000000  ................ 
20b26a50  00000000 00000000 00000000 00000000  ................ 
20b26a60  00000000 00000000 00000000 00000000  ................ 
20b26a70  00000000 00000000 00000000 00000000  ................ 
20b26a80  00000000 00000000 00000000 00000000  ................ 
20b26a90  00000000 00000000 00000000 00000000  ................ 
20b26aa0  00000000 00000000 00000000 00000000  ................ 
20b26ab0  00000000 00000000 00000000 00000000  ................ 
20b26ac0  00000000 00000000 00000000 00000000  ................ 
20b26ad0  00000000 00000000 00000000 00000000  ................ 
20b26ae0  00000000 00000000 00000000 00000000  ................ 
20b26af0  00000000 00000000 00000000 00000000  ................ 
20b26b00  00000000 00000000 00000000 00000000  ................ 
20b26b10  00000000 00000000 00000000 00000000  ................ 
20b26b20  00000000 00000000 00000000 00000000  ................ 
20b26b30  00000000 00000000 00000000 00000000  ................ 
20b26b40  00000000 00000000 00000000 00000000  ................ 
20b26b50  00000000 00000000 00000000 00000000  ................ 
20b26b60  00000000 00000000 00000000 00000000  ................ 
20b26b70  00000000 00000000 00000000 00000000  ................ 
20b26b80  00000000 00000000 00000000 00000000  ................ 
20b26b90  00000000 00000000 00000000 00000000  ................ 
20b26ba0  00000000 00000000 00000000 00000000  ................ 
20b26bb0  00000000 00000000 00000000 00000000  ................ 
20b26bc0  00000000 00000000 00000000 00000000  ................ 
20b26bd0  00000000 00000000 00000000 00000000  ................ 
20b26be0  00000000 00000000 00000000 00000000  ................ 
20b26bf0  00000000 00000000 00000000 00000000  ................ 
20b26c00  00000000 00000000 00000000 00000000  ................ 

Page Heap Implementation    59 
20b26c10  00000000 00000000 00000000 00000000  ................ 
20b26c20  00000000 00000000 00000000 00000000  ................ 
20b26c30  00000000 00000000 00000000 00000000  ................ 
20b26c40  00000000 00000000 00000000 00000000  ................ 
20b26c50  00000000 00000000 00000000 00000000  ................ 
20b26c60  00000000 00000000 00000000 00000000  ................ 
20b26c70  00000000 00000000 00000000 00000000  ................ 
20b26c80  00000000 00000000 00000000 00000000  ................ 
20b26c90  00000000 00000000 00000000 00000000  ................ 
20b26ca0  00000000 00000000 00000000 00000000  ................ 
20b26cb0  00000000 00000000 00000000 00000000  ................ 
20b26cc0  00000000 00000000 00000000 00000000  ................ 
20b26cd0  00000000 00000000 00000000 00000000  ................ 
20b26ce0  00000000 00000000 00000000 00000000  ................ 
20b26cf0  00000000 00000000 00000000 00000000  ................ 
20b26d00  00000000 00000000 00000000 00000000  ................ 
20b26d10  00000000 00000000 00000000 00000000  ................ 
20b26d20  00000000 00000000 00000000 00000000  ................ 
20b26d30  00000000 00000000 00000000 00000000  ................ 
20b26d40  00000000 00000000 00000000 00000000  ................ 
20b26d50  00000000 00000000 00000000 00000000  ................ 
20b26d60  00000000 00000000 00000000 00000000  ................ 
20b26d70  00000000 00000000 00000000 00000000  ................ 
20b26d80  00000000 00000000 00000000 00000000  ................ 
20b26d90  00000000 00000000 00000000 00000000  ................ 
20b26da0  00000000 00000000 00000000 00000000  ................ 
20b26db0  00000000 00000000 00000000 00000000  ................ 
20b26dc0  00000000 00000000 00000000 00000000  ................ 
20b26dd0  00000000 00000000 00000000 00000000  ................ 
20b26de0  00000000 00000000 00000000 00000000  ................ 
20b26df0  00000000 00000000 00000000 00000000  ................ 
20b26e00  00000000 00000000 00000000 00000000  ................ 
20b26e10  00000000 00000000 00000000 00000000  ................ 
20b26e20  00000000 00000000 00000000 00000000  ................ 
20b26e30  00000000 00000000 00000000 00000000  ................ 
20b26e40  00000000 00000000 00000000 00000000  ................ 
20b26e50  00000000 00000000 00000000 00000000  ................ 
20b26e60  00000000 00000000 00000000 00000000  ................ 
20b26e70  00000000 00000000 00000000 00000000  ................ 
20b26e80  00000000 00000000 00000000 00000000  ................ 
20b26e90  00000000 00000000 00000000 00000000  ................ 
20b26ea0  00000000 00000000 00000000 00000000  ................ 
20b26eb0  00000000 00000000 00000000 00000000  ................ 
20b26ec0  00000000 00000000 00000000 00000000  ................ 
20b26ed0  00000000 00000000 abcdbbbb 1f241000  ..............$. 
20b26ee0  00000108 00000108 00000000 00000000  ................ 
20b26ef0  011c6b10 dcbabbbb 1f1bc8b4 00000002  .k.............. 
20b26f00  20b79fd0 20b85fd0 20b28fe8 20b2ffe0  ... ._. ... ... 
20b26f10  20b3ffe0 20b4bfe8 20b51fe8 20b57fe8  ... ... ... ... 
20b26f20  00000000 00000000 20b5dfa8 00000000  ........... .... 
20b26f30  00000000 00000000 1f1bcbf0 00000000  ................ 
20b26f40  20b71ff8 00000010 1f1bcbf0 00000000  ... ............ 
20b26f50  20b73ff8 00000010 1f1bcbf0 00000000  .?. ............ 
20b26f60  20b75ff8 00000010 1f1bcbf0 00000000  ._. ............ 
20b26f70  20b77ff8 00000010 00000000 00000000  ... ............ 
20b26f80  c0c0c001 00000000 c0c00000 00000002  ................ 
20b26f90  01000000 00000101 00000000 00000000  ................ 
20b26fa0  00000000 c0c0c000 00000000 00000001  ................ 
20b26fb0  00000000 00000000 00000000 00000000  ................ 
20b26fc0  00000000 00000000 00000000 00000000  ................ 
20b26fd0  00000000 00000000 00000000 00000000  ................ 
20b26fe0  00000000 00000000 00000000 00000000  ................ 
20b26ff0  00000000 00000000 00000000 c0c0c000  ................ 
20b27000 ???????? ???? 
 
 

60    PART 1: Professional Crash Dump Analysis and Debugging 
More Common Mistakes in Memory Analysis 
Because we finished the list of 10 common mistakes (Part 1 in Volumes 2 - 6) some time 
ago, we continue with “more” series. We discovered the need to pay attention to 
differences between 32-bit and 64-bit versions of critical section structures and the 
need for explicit symbol qualification in x86 mode to avoid mistakes. Suppose we see 
the address of a critical section in 32-bit stack trace output: 
0:000:x86> kv 
ChildEBP RetAddr  Args to Child 
0044f40c 774e8dd4 00000a94 00000000 00000000 ntdll_774b0000!ZwWaitForSingleObject+0x15 
0044f470 774e8cb8 00000000 00000000 041f4b78 ntdll_774b0000!RtlpWaitOnCriticalSection+0x13e 
0044f498 0123f70c 010d97c0 8c62ec9c 010cc5fc ntdll_774b0000!RtlEnterCriticalSection+0×150 
0:000:x86> dt _RTL_CRITICAL_SECTION 010d97c0 
ntdll!_RTL_CRITICAL_SECTION 
+0x000 DebugInfo        : 0x00862680 _RTL_CRITICAL_SECTION_DEBUG 
+0x008 LockCount        : 0n1 
+0x00c RecursionCount   : 0n103356 
+0×010 OwningThread     : 0×00000a94 Void 
+0×018 LockSemaphore    : 0×0817d72d Void 
+0×020 SpinCount        : 0×6130910c`010d9840 
Its owner thread has a94 TID, but we don’t see it in the thread list: 
0:000:x86> ~ 
.  0  Id: 19508.17944 Suspend: 0 Teb: 7efdb000 Unfrozen 
1  Id: 19508.1922c Suspend: 0 Teb: 7efd8000 Unfrozen 
2  Id: 19508.195d4 Suspend: 0 Teb: 7efd5000 Unfrozen 
3  Id: 19508.19a80 Suspend: 0 Teb: 7efa7000 Unfrozen 
4  Id: 19508.19544 Suspend: 0 Teb: 7efa4000 Unfrozen 
5  Id: 19508.1925c Suspend: 0 Teb: 7efa1000 Unfrozen 
6  Id: 19508.193d4 Suspend: 0 Teb: 7ef9d000 Unfrozen 
7  Id: 19508.19b18 Suspend: 0 Teb: 7ef9a000 Unfrozen 
8  Id: 19508.19bfc Suspend: 0 Teb: 7ef97000 Unfrozen 
9  Id: 19508.19bc4 Suspend: 0 Teb: 7ef94000 Unfrozen 
10  Id: 19508.19a90 Suspend: 0 Teb: 7ef91000 Unfrozen 
11  Id: 19508.189c0 Suspend: 0 Teb: 7ef8d000 Unfrozen 
12  Id: 19508.193bc Suspend: 0 Teb: 7ef8a000 Unfrozen 
13  Id: 19508.18f3c Suspend: 0 Teb: 7ef87000 Unfrozen 
14  Id: 19508.18834 Suspend: 0 Teb: 7ef84000 Unfrozen 
15  Id: 19508.19aec Suspend: 0 Teb: 7ef81000 Unfrozen 
16  Id: 19508.180f4 Suspend: 0 Teb: 7ef7d000 Unfrozen 
17  Id: 19508.19a3c Suspend: 0 Teb: 7ef7a000 Unfrozen 
18  Id: 19508.1916c Suspend: 0 Teb: 7ef77000 Unfrozen 
19  Id: 19508.19324 Suspend: 0 Teb: 7ef74000 Unfrozen 
20  Id: 19508.19a78 Suspend: 0 Teb: 7ef71000 Unfrozen 
21  Id: 19508.19ad4 Suspend: 0 Teb: 7ef6d000 Unfrozen 
22  Id: 19508.19834 Suspend: 0 Teb: 7ef6a000 Unfrozen 
23  Id: 19508.19754 Suspend: 0 Teb: 7ef67000 Unfrozen 
24  Id: 19508.19aa0 Suspend: 0 Teb: 7ef64000 Unfrozen 

More Common Mistakes in Memory Analysis    61 
25  Id: 19508.19bd0 Suspend: 0 Teb: 7ef61000 Unfrozen 
26  Id: 19508.19384 Suspend: 0 Teb: 7ef5d000 Unfrozen 
27  Id: 19508.1734c Suspend: 0 Teb: 7ef5a000 Unfrozen 
28  Id: 19508.19148 Suspend: 0 Teb: 7ef57000 Unfrozen 
29  Id: 19508.19b74 Suspend: 0 Teb: 7ef54000 Unfrozen 
30  Id: 19508.18290 Suspend: 0 Teb: 7ef51000 Unfrozen 
31  Id: 19508.19a4c Suspend: 0 Teb: 7ef4d000 Unfrozen 
32  Id: 19508.19bc0 Suspend: 0 Teb: 7ef4a000 Unfrozen 
33  Id: 19508.18bf0 Suspend: 0 Teb: 7ef47000 Unfrozen 
34  Id: 19508.1895c Suspend: 0 Teb: 7ef44000 Unfrozen 
35  Id: 19508.19314 Suspend: 0 Teb: 7ef41000 Unfrozen 
36  Id: 19508.19934 Suspend: 0 Teb: 7ef3a000 Unfrozen 
37  Id: 19508.197b0 Suspend: 0 Teb: 7ef31000 Unfrozen 
38  Id: 19508.1962c Suspend: 0 Teb: 7ef2d000 Unfrozen 
39  Id: 19508.191e0 Suspend: 0 Teb: 7ef2a000 Unfrozen 
40  Id: 19508.19438 Suspend: 0 Teb: 7ef27000 Unfrozen 
41  Id: 19508.197e8 Suspend: 0 Teb: 7ef24000 Unfrozen 
42  Id: 19508.18c38 Suspend: 0 Teb: 7ef21000 Unfrozen 
43  Id: 19508.197b4 Suspend: 0 Teb: 7ef1d000 Unfrozen 
44  Id: 19508.1978c Suspend: 0 Teb: 7ef1a000 Unfrozen 
45  Id: 19508.19b84 Suspend: 0 Teb: 7ef17000 Unfrozen 
46  Id: 19508.197a8 Suspend: 0 Teb: 7ef14000 Unfrozen 
47  Id: 19508.19660 Suspend: 0 Teb: 7ef3d000 Unfrozen 
48  Id: 19508.18574 Suspend: 0 Teb: 7efad000 Unfrozen 
49  Id: 19508.17a04 Suspend: 0 Teb: 7efaa000 Unfrozen 
We see the correct result only if we specify a different structure: 
0:000:x86> dt CRITICAL_SECTION 010d97c0 
ModuleA!CRITICAL_SECTION 
+0x000 DebugInfo        : 0x00862680 _RTL_CRITICAL_SECTION_DEBUG 
+0x004 LockCount        : 0n-6 
+0x008 RecursionCount   : 0n1 
+0×00c OwningThread     : 0×000193bc Void 
+0×010 LockSemaphore    : 0×00000a94 Void 
+0×014 SpinCount        : 0 
This is because the structure definition is from a 32-bit module: 
0:000:x86> dt ModuleA!CRITICAL_SECTION 
ModuleA!CRITICAL_SECTION 
+0x000 DebugInfo        : Ptr32 _RTL_CRITICAL_SECTION_DEBUG 
+0x004 LockCount        : Int4B 
+0x008 RecursionCount   : Int4B 
+0×00c OwningThread     : Ptr32 Void 
+0×010 LockSemaphore    : Ptr32 Void 
+0×014 SpinCount        : Uint4B 
However, the structure we used first is from a 64-bit module and has a different 
offset and size for OwningThread field: 

62    PART 1: Professional Crash Dump Analysis and Debugging 
0:000:x86> dt ntdll!_RTL_CRITICAL_SECTION 
+0x000 DebugInfo        : Ptr64 _RTL_CRITICAL_SECTION_DEBUG 
+0x008 LockCount        : Int4B 
+0x00c RecursionCount   : Int4B 
+0×010 OwningThread     : Ptr64 Void 
+0×018 LockSemaphore    : Ptr64 Void 
+0×020 SpinCount        : Uint8B 
Because a different 32-bit ntdll module is also loaded we can use it for explicit 
symbol qualification: 
0:000:x86> dt ntdll_774b0000!_RTL_CRITICAL_SECTION 
+0×000 DebugInfo        : Ptr32 _RTL_CRITICAL_SECTION_DEBUG 
+0×004 LockCount        : Int4B 
+0×008 RecursionCount   : Int4B 
+0×00c OwningThread     : Ptr32 Void 
+0×010 LockSemaphore    : Ptr32 Void 
+0×014 SpinCount        : Uint4B 
 
 

Memory Dump Analysis Best Practices    63 
Memory Dump Analysis Best Practices 
We continue with best practices; the previous was SCP (Volume 6, page 19). The second 
best practice is to check the system for additional patterns after the main pattern was 
found (similar to avoiding common mistake #8, Volume 5, page 24). For example, in the 
case of a bug check resulted from NULL pointer dereference or any other exception in 
some 3rd-party driver code don’t stop but look at all CPUs, processes and threads to 
find any other patterns such as Spiking Threads (Volume 1, page 305), Busy System 
(Volume 1, page 449), and Contention (Volume 5, page 423). Inspection of associated 
thread stack traces might reveal the same module and/or give additional clues to 
system behavior prior to the fault. 
Another best practice that is directly related to productivity is a parallel 
processing of the same memory dump especially in the case of complete memory 
dumps. Here an analysis might start with running time-consuming scripts that dump all 
process and threads in the variety of formats such as x64 and x86 thread stack traces. 
However, if the nature of the problem is such that it is possible to start with some 
pattern and continue unfolding its analysis, then we can do that in parallel. One of the 
examples may be discovered Incomplete Session (page 150) with an ALPC Wait Chain 
(Volume 3, page 97). Here we can follow such a wait chain while another WinDbg 
instance dumps all threads for the later pattern search. 
 
 

64    PART 1: Professional Crash Dump Analysis and Debugging 
[This page is intentionally left blank] 
 
 

FPU Exception    65 
PART 2: Crash Dump Analysis Patterns  
FPU Exception 
This pattern sometimes happens where we least expect it. Here’s an extract from one 
crash dump raw  stack analysis showing exception context, record and the usage of r 
WinDbg command variant to display FPU registers: 
0:002> dps 056c1000 057c0000  
[...] 
057bdee0 00000008 
057bdee4 00000000 
057bdee8 057bed6c 
057bdeec 0d6e3130 
057bdef0 057c0000 
057bdef4 057b9000 
057bdef8 006e3138 
057bdefc 057be200 
057bdf00 7c90e48a ntdll!KiUserExceptionDispatcher+0xe 
057bdf04 057bed6c 
057bdf08 057bdf2c 
057bdf0c 057bdf14 
057bdf10 057bdf2c 
057bdf14 c0000090 
057bdf18 00000010 
057bdf1c 00000000 
057bdf20 79098cc0 mscorjit!Compiler::FlatFPIsSameAsFloat+0xd 
057bdf24 00000001 
057bdf28 00000000 
057bdf2c 0001003f 
057bdf30 00000000 
057bdf34 00000000 
057bdf38 00000000 
057bdf3c 00000000 
057bdf40 00000000 
057bdf44 00000000 
057bdf48 ffff1372 
057bdf4c fffffda1 
057bdf50 ffffbfff  
[...] 
0:002> .cxr 057bdf2c 
eax=c0000090 ebx=00000000 ecx=c0000090 edx=00000000 esi=057be244 
edi=001d4388 
eip=79f5236b esp=057be1f8 ebp=057be200 iopl=0 nv up ei ng nz ac pe cy 
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010297 
mscorwks!SOTolerantBoundaryFilter+0x22: 
79f5236b d9059823f579 fld dword ptr [mscorwks!_real (79f52398)] 
ds:0023:79f52398=40800000 

66    PART 2: Crash Dump Analysis Patterns 
0:002> .exr 057bdf14 
ExceptionAddress: 79098cc0 
(mscorjit!Compiler::FlatFPIsSameAsFloat+0x0000000d) 
ExceptionCode: c0000090 
ExceptionFlags: 00000010 
NumberParameters: 1 
Parameter[0]: 00000000 
0:002> !error c0000090 
Error code: (NTSTATUS) 0xc0000090 (3221225616) - {EXCEPTION} Floating-
point invalid operation. 
0:002> rMF 
Last set context: 
eax=c0000090 ebx=00000000 ecx=c0000090 edx=00000000 esi=057be244 
edi=001d4388 
eip=79f5236b esp=057be1f8 ebp=057be200 iopl=0 nv up ei ng nz ac pe cy 
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00010297 
fpcw=1372: rn 64 pu–d- fpsw=FDA1: top=7 cc=1101 b-p—-i fptw=BFFF 
fopcode=045D fpip=001b:79098cc0 fpdp=0023:057bea7c 
st0=-1.#IND00000000000000000e+0000 st1= 0.006980626232475338220e-4916 
st2= 6.543831490564206840810e-4932 st3=-0.003025663186207448300e+2614 
st4= 2.000000000000000000000e+0000 st5= 6.291456000000000000000e+0006 
st6= 1.000000000000000000000e+0000 st7= 2.500000000000000000000e-0001 
mscorwks!SOTolerantBoundaryFilter+0×22: 
79f5236b d9059823f579 fld dword ptr [mscorwks!_real (79f52398)] 
ds:0023:79f52398=40800000 
 
 

Hidden Parameter    67 
Hidden Parameter 
This pattern is a variant of Execution Residue (Volume 2, page 239) and String 
Parameter (Volume 6, page 49) where we have parameters left out from stack trace due 
to register calling conventions and compiler optimizations. However, using raw stack 
analysis of a region around stack frames of interest we find what we are looking for. 
Here’s an example from an x64 system blocked thread waiting for data from a named 
pipe: 
0: kd> kL 
*** Stack trace for last set context - .thread/.cxr resets it 
Child-SP          RetAddr           Call Site 
fffffa60`2c3627d0 fffff800`018b90fa nt!KiSwapContext+0x7f 
fffffa60`2c362910 fffff800`018add3b nt!KiSwapThread+0x13a 
fffffa60`2c362980 fffff800`01b2121f nt!KeWaitForSingleObject+0x2cb 
fffffa60`2c362a10 fffff800`01b319b6 nt!IopXxxControlFile+0xdeb 
fffffa60`2c362b40 fffff800`018b68f3 nt!NtFsControlFile+0x56 
fffffa60`2c362bb0 00000000`778d6eaa nt!KiSystemServiceCopyEnd+0x13 
00000000`11f4da68 00000000`77767b6e ntdll!ZwFsControlFile+0xa 
00000000`11f4da70 000007fe`ff94abc8 kernel32!WaitNamedPipeW+0×22f 
00000000`11f4db60 000007fe`ff98a32d RPCRT4!NdrProxyForwardingFunction255+0×814d 
00000000`11f4dc30 000007fe`ff98918b RPCRT4!OSF_CCONNECTION::TransOpen+0xcd 
00000000`11f4dcc0 000007fe`ff988f9b RPCRT4!OSF_CCONNECTION::OpenConnectionAndBind+0×17b 
00000000`11f4dd90 000007fe`ff988ec6 RPCRT4!OSF_CCALL::BindToServer+0xbb 
00000000`11f4de40 000007fe`ff983368 RPCRT4!OSF_BINDING_HANDLE::InitCCallWithAssociation+0xa5 
00000000`11f4dea0 000007fe`ff983220 RPCRT4!OSF_BINDING_HANDLE::AllocateCCall+0×118 
00000000`11f4dfd0 000007fe`ffa1f740 RPCRT4!OSF_BINDING_HANDLE::NegotiateTransferSyntax+0×30 
00000000`11f4e020 000007fe`ffa1fecb RPCRT4!Ndr64pClientSetupTransferSyntax+0×200 
00000000`11f4e080 000007fe`ffa20281 RPCRT4!NdrpClientCall3+0×6b 
00000000`11f4e2d0 000007fe`fe087c8c RPCRT4!NdrClientCall3+0xdd 
[...] 
Even if we disassemble the return address of a caller of WaitNamedPipeW 
function we won’t easily find the passed first string parameter (named pipe name) 
unless we do a substantial reverse engineering and data flow analysis: 
0: kd> ub 000007fe`ff94abc8 
RPCRT4!_imp_load_getaddrinfo+0×7: 
000007fe`ff94ab9f jmp RPCRT4!_tailMerge_WS2_32_dll (000007fe`ff94cef8) 
000007fe`ff94aba4 call qword ptr [RPCRT4!_imp_GetLastError (000007fe`ffa2d528)] 
000007fe`ff94abaa mov r12d,eax 
000007fe`ff94abad cmp r12d,0E7h 
000007fe`ff94abb4 jne RPCRT4!NdrProxyForwardingFunction255+0×8193 (000007fe`ff99c8fb) 
000007fe`ff94abba mov edx,3E8h 
000007fe`ff94abbf mov rcx,rsi 
000007fe`ff94abc2 call qword ptr [RPCRT4!_imp_WaitNamedPipeW (000007fe`ffa2d3f8)] 
However, dumping raw stack data around corresponding frames gives us pipe 
name clue and possible service name to look further: 
 
 

68    PART 2: Crash Dump Analysis Patterns 
0: kd> dpu 00000000`11f4da70 
00000000`11f4da70 00000000`11f4dba8 “\\.\PIPE\ServiceArpc” 
00000000`11f4da78 00000000`00000000 
00000000`11f4da80 00000000`00000000 
00000000`11f4da88 00000000`000003e8 
00000000`11f4da90 00000000`11f4db30 
00000000`11f4da98 00000000`00110018 
00000000`11f4daa0 00000000`0d9001a0 
00000000`11f4daa8 00000000`0000001a 
00000000`11f4dab0 00000000`00000000 
00000000`11f4dab8 00000000`00000000 
00000000`11f4dac0 00000000`0020000c 
00000000`11f4dac8 00000000`0d9001e2 “ServiceArpc” 
00000000`11f4dad0 00000000`00000000 
00000000`11f4dad8 00000000`00000000 
00000000`11f4dae0 00000000`00240022 
 
 

Memory Leak (Page Tables)    69 
Memory Leak (Page Tables) 
Sometimes we have memory leaks related to the growing number of page tables. One 
reason for that could be the growing number of Zombie Processes (Volume 2, page 196) 
noticeable with tens of thousands of them. 
1: kd> !process 0 0 
[...]  
PROCESS fffffa80266bd6f0 
    SessionId: 0 Cid: 0a6c Peb: 7fffffdc000 ParentCid: 03ac 
    DirBase: 9d35a000 ObjectTable: fffff8a00170ac80 HandleCount: 152. 
    Image: svchost.exe 
[...]  
PROCESS fffffa8027de9b30 
    SessionId: 0 Cid: 21d0 Peb: 7fffffdf000 ParentCid: 02e0 
    DirBase: 37881000 ObjectTable: 00000000 HandleCount: 0. 
    Image: conhost.exe 
[...]  
PROCESS fffffa8028eb0600 
    SessionId: 0 Cid: ab88 Peb: 7fffffdf000 ParentCid: 02e0 
    DirBase: 27a2f000 ObjectTable: 00000000 HandleCount: 0. 
    Image: conhost.exe 
[...] 
Even zombies have at least one remaining page (page directory) from the former 
page tables of their virtual to physical memory mapping (!dd is the same as dd WinDbg 
command but for physical memory): 
1: kd> !dd 9d35a000 
#9d35a000 9dd62867 03c00000 00000000 00000000 
#9d35a010 00000000 00000000 00000000 00000000 
#9d35a020 00000000 00000000 00000000 00000000 
#9d35a030 00000000 00000000 00000000 00000000 
#9d35a040 00000000 00000000 00000000 00000000 
#9d35a050 00000000 00000000 00000000 00000000 
#9d35a060 00000000 00000000 00000000 00000000 
#9d35a070 00000000 00000000 9d45e867 49500000 
1: kd> !dd 37881000 
#37881000 00000000 00000000 00000000 00000000 
#37881010 00000000 00000000 00000000 00000000 
#37881020 00000000 00000000 00000000 00000000 
#37881030 00000000 00000000 00000000 00000000 
#37881040 00000000 00000000 00000000 00000000 
#37881050 00000000 00000000 00000000 00000000 
#37881060 00000000 00000000 00000000 00000000 
#37881070 00000000 00000000 00000000 00000000 

70    PART 2: Crash Dump Analysis Patterns 
1: kd> !dd 27a2f000 
#27a2f000 00000000 00000000 00000000 00000000 
#27a2f010 00000000 00000000 00000000 00000000 
#27a2f020 00000000 00000000 00000000 00000000 
#27a2f030 00000000 00000000 00000000 00000000 
#27a2f040 00000000 00000000 00000000 00000000 
#27a2f050 00000000 00000000 00000000 00000000 
#27a2f060 00000000 00000000 00000000 00000000 
#27a2f070 00000000 00000000 00000000 00000000 
We also see that two conhost.exe processes have identical physical to virtual 
mapping because their user space mappings are no longer valid (zeroed) and 
svchost.exe process has user space mapping: 
1: kd> !ptov 27a2f000 
Amd64PtoV: pagedir 27a2f000 
27a2f000 fffff6fb`7dbed000 
71530000 fffff6fb`7dbee000 
19d000 fffff6fb`7dbef000 
199000 fffff6fb`7dbf0000 
b6a04000 fffff6fb`7dbf1000 
b1f57000 fffff6fb`7dbf2000 
29c4000 fffff6fb`7dbf3000 
1c53000 fffff6fb`7dbf5000  
[...] 
2e4d8000 fffffa80`28f2d000 
2c3d7000 fffffa80`28f2e000 
30ed6000 fffffa80`28f2f000 
2efd5000 fffffa80`28f30000 
2ded4000 fffffa80`28f31000 
2a5d3000 fffffa80`28f32000 
bb400000 fffffa80`29600000 (large page) 
bb200000 fffffa80`29800000 (large page) 
100000 ffffffff`ffd00000 
105000 ffffffff`ffd01000 
101000 ffffffff`ffd02000 
102000 ffffffff`ffd03000 
103000 ffffffff`ffd04000 
104000 ffffffff`ffd05000 
fec00000 ffffffff`ffd06000 
1000 ffffffff`ffd07000 
106000 ffffffff`ffd08000 
123000 ffffffff`ffd09000 
0 ffffffff`ffd0a000 
124000 ffffffff`ffd0b000 
2000 ffffffff`ffd0c000 
e00c7000 ffffffff`ffd0d000 
e0080000 ffffffff`ffd0e000 
107000 ffffffff`ffd25000 
108000 ffffffff`ffd26000 
109000 ffffffff`ffd27000 
10a000 ffffffff`ffd28000 
10b000 ffffffff`ffd29000 

Memory Leak (Page Tables)    71 
10c000 ffffffff`ffd2a000 
10d000 ffffffff`ffd2b000 
10e000 ffffffff`ffd2c000 
10f000 ffffffff`ffd2d000 
110000 ffffffff`ffd2e000 
111000 ffffffff`ffd2f000 
112000 ffffffff`ffd30000 
113000 ffffffff`ffd31000 
114000 ffffffff`ffd32000 
115000 ffffffff`ffd33000 
116000 ffffffff`ffd34000 
117000 ffffffff`ffd35000 
118000 ffffffff`ffd36000 
119000 ffffffff`ffd37000 
11a000 ffffffff`ffd38000 
11b000 ffffffff`ffd39000 
11c000 ffffffff`ffd3a000 
11d000 ffffffff`ffd3b000 
11e000 ffffffff`ffd3c000 
11f000 ffffffff`ffd3d000 
120000 ffffffff`ffd3e000 
121000 ffffffff`ffd3f000 
122000 ffffffff`ffd40000 
fee00000 ffffffff`fffe0000 
1: kd> !ptov 37881000 
Amd64PtoV: pagedir 37881000 
37881000 fffff6fb`7dbed000 
8d482000 fffff6fb`7dbee000 
19d000 fffff6fb`7dbef000 
199000 fffff6fb`7dbf0000 
b6a04000 fffff6fb`7dbf1000 
b1f57000 fffff6fb`7dbf2000 
29c4000 fffff6fb`7dbf3000 
1c53000 fffff6fb`7dbf5000 
[...] 
2e4d8000 fffffa80`28f2d000 
2c3d7000 fffffa80`28f2e000 
30ed6000 fffffa80`28f2f000 
2efd5000 fffffa80`28f30000 
2ded4000 fffffa80`28f31000 
2a5d3000 fffffa80`28f32000 
bb400000 fffffa80`29600000 (large page) 
bb200000 fffffa80`29800000 (large page) 
100000 ffffffff`ffd00000 
105000 ffffffff`ffd01000 
101000 ffffffff`ffd02000 
102000 ffffffff`ffd03000 
103000 ffffffff`ffd04000 
104000 ffffffff`ffd05000 
fec00000 ffffffff`ffd06000 
1000 ffffffff`ffd07000 
106000 ffffffff`ffd08000 
123000 ffffffff`ffd09000 

72    PART 2: Crash Dump Analysis Patterns 
0 ffffffff`ffd0a000 
124000 ffffffff`ffd0b000 
2000 ffffffff`ffd0c000 
e00c7000 ffffffff`ffd0d000 
e0080000 ffffffff`ffd0e000 
107000 ffffffff`ffd25000 
108000 ffffffff`ffd26000 
109000 ffffffff`ffd27000 
10a000 ffffffff`ffd28000 
10b000 ffffffff`ffd29000 
10c000 ffffffff`ffd2a000 
10d000 ffffffff`ffd2b000 
10e000 ffffffff`ffd2c000 
10f000 ffffffff`ffd2d000 
110000 ffffffff`ffd2e000 
111000 ffffffff`ffd2f000 
112000 ffffffff`ffd30000 
113000 ffffffff`ffd31000 
114000 ffffffff`ffd32000 
115000 ffffffff`ffd33000 
116000 ffffffff`ffd34000 
117000 ffffffff`ffd35000 
118000 ffffffff`ffd36000 
119000 ffffffff`ffd37000 
11a000 ffffffff`ffd38000 
11b000 ffffffff`ffd39000 
11c000 ffffffff`ffd3a000 
11d000 ffffffff`ffd3b000 
11e000 ffffffff`ffd3c000 
11f000 ffffffff`ffd3d000 
120000 ffffffff`ffd3e000 
121000 ffffffff`ffd3f000 
122000 ffffffff`ffd40000 
fee00000 ffffffff`fffe0000 
1: kd> !ptov 9d35a000 
Amd64PtoV: pagedir 9d35a000 
9E587000 10000 
6871E000 20000 
AF5AA000 30000 
AF5AB000 31000 
AFAAC000 32000 
AFBAD000 33000 
AF2F5000 40000 
9D66B000 50000 
22199000 60000 
9D962000 E5000 
9D261000 E6000 
9DC60000 E7000 
9D256000 EA000 
9D84F000 EB000 
9E4EC000 EC000 
9E081000 ED000 
9D876000 EE000 

Memory Leak (Page Tables)    73 
9E271000 EF000 
B8BFD000 F0000 
B8EFE000 F1000 
B86FF000 F2000 
B5302000 F3000 
B5202000 F4000 
B5502000 F5000 
B7F03000 F6000 
B8404000 F7000 
B8415000 100000 
B8B16000 101000 
B1B17000 102000 
[...] 
2CD4000 77512000 
5D7000 77515000 
5D8000 77516000 
4D9000 77517000 
B358F000 77590000 
AEF04000 77591000 
68624000 77592000 
64B26000 77593000 
AF4C6000 77595000 
B2042000 7EFE0000 
B2143000 7EFE1000 
B1A56000 7EFE2000 
B1A57000 7EFE3000 
B1B58000 7EFE4000 
1BA000 7FFE0000 
9DA69000 BFEB0000 
AEEAE000 FFEA0000 
AF191000 FFEA1000 
9D76A000 FFEA2000 
AE793000 FFEA3000 
9DC8E000 FFEA5000 
B7EB7000 FFEA6000 
9DFFC000 FFEA7000 
[...] 
2e4d8000 fffffa80`28f2d000 
2c3d7000 fffffa80`28f2e000 
30ed6000 fffffa80`28f2f000 
2efd5000 fffffa80`28f30000 
2ded4000 fffffa80`28f31000 
2a5d3000 fffffa80`28f32000 
bb400000 fffffa80`29600000 (large page) 
bb200000 fffffa80`29800000 (large page) 
100000 ffffffff`ffd00000 
105000 ffffffff`ffd01000 
101000 ffffffff`ffd02000 
102000 ffffffff`ffd03000 
103000 ffffffff`ffd04000 
104000 ffffffff`ffd05000 
fec00000 ffffffff`ffd06000 
1000 ffffffff`ffd07000 
106000 ffffffff`ffd08000 

74    PART 2: Crash Dump Analysis Patterns 
123000 ffffffff`ffd09000 
0 ffffffff`ffd0a000 
124000 ffffffff`ffd0b000 
2000 ffffffff`ffd0c000 
e00c7000 ffffffff`ffd0d000 
e0080000 ffffffff`ffd0e000 
107000 ffffffff`ffd25000 
108000 ffffffff`ffd26000 
109000 ffffffff`ffd27000 
10a000 ffffffff`ffd28000 
10b000 ffffffff`ffd29000 
10c000 ffffffff`ffd2a000 
10d000 ffffffff`ffd2b000 
10e000 ffffffff`ffd2c000 
10f000 ffffffff`ffd2d000 
110000 ffffffff`ffd2e000 
111000 ffffffff`ffd2f000 
112000 ffffffff`ffd30000 
113000 ffffffff`ffd31000 
114000 ffffffff`ffd32000 
115000 ffffffff`ffd33000 
116000 ffffffff`ffd34000 
117000 ffffffff`ffd35000 
118000 ffffffff`ffd36000 
119000 ffffffff`ffd37000 
11a000 ffffffff`ffd38000 
11b000 ffffffff`ffd39000 
11c000 ffffffff`ffd3a000 
11d000 ffffffff`ffd3b000 
11e000 ffffffff`ffd3c000 
11f000 ffffffff`ffd3d000 
120000 ffffffff`ffd3e000 
121000 ffffffff`ffd3f000 
122000 ffffffff`ffd40000 
fee00000 ffffffff`fffe0000 
In order to check user space virtual addresses we have to switch to the 
corresponding process context: 
1: kd> !pte fffffa80`28f2d000 
VA fffffa8028f2d000 
PXE at FFFFF6FB7DBEDFA8 PPE at FFFFF6FB7DBF5000 PDE at FFFFF6FB7EA00A38 
PTE at FFFFF6FD40147968 
contains 0000000001C53863 contains 0000000001C54863 contains 
0000000049320863 contains 000000002E4D8963 
pfn 1c53 —DA–KWEV pfn 1c54 —DA–KWEV pfn 49320 —DA–KWEV pfn 2e4d8 -G-DA–
KWEV 
1: kd> .process /r /p fffffa80266bd6f0 
Implicit process is now fffffa80`266bd6f0 
Loading User Symbols 

Memory Leak (Page Tables)    75 
1: kd> !pte 10000 
VA 0000000000010000 
PXE at FFFFF6FB7DBED000 PPE at FFFFF6FB7DA00000 PDE at FFFFF6FB40000000 
PTE at FFFFF68000000080 
contains 03C000009DD62867 contains 031000009D865867 contains 
7C2000009DD66867 contains 9CB000009E587867 
pfn 9dd62 —DA–UWEV pfn 9d865 —DA–UWEV pfn 9dd66 —DA–UWEV pfn 9e587 —DA–UW-
V 
This pattern came to our attention after seeing memory dumps generated after 
the growing number of memory allocated for page tables exceeded a gigabyte. 
 
 

76    PART 2: Crash Dump Analysis Patterns 
Unrecognizable Symbolic Information 
Sometimes debugging information is absent from module information in memory 
dumps and a debugger can’t recognize and automatically load symbol files. For example, 
we see this stack trace without loaded component symbols: 
THREAD 8a17c6d8  Cid 02ec.02f0  Teb: 7ffdf000 Win32Thread: e17b4420 WAIT: 
(UserRequest) UserMode Non-Alertable 
     89873d00  SynchronizationEvent 
IRP List: 
     89d9fd20: (0006,0094) Flags: 00000800  Mdl: 00000000 
Not impersonating 
DeviceMap                 e10086c8 
Owning Process            0       Image:         <Unknown> 
Attached Process          8a17cda0       Image:         ApplicationA.exe 
Wait Start TickCount      8164394        Ticks: 2884 (0:00:00:45.062) 
Context Switch Count      1769160                 LargeStack 
UserTime                  00:00:55.250 
KernelTime                00:01:56.109 
Start Address 0×0103e5e1 
Stack Init ba390000 Current ba38fca0 Base ba390000 Limit ba38b000 Call 0 
Priority 15 BasePriority 15 PriorityDecrement 0 DecrementCount 0 
*** ERROR: Module load completed but symbols could not be loaded for 
ModuleA.dll 
ChildEBP RetAddr  
ba38fcb8 80503836 nt!KiSwapContext+0×2f 
ba38fcc4 804fb068 nt!KiSwapThread+0×8a 
ba38fcec 805c0750 nt!KeWaitForSingleObject+0×1c2 
ba38fd50 8054161c nt!NtWaitForSingleObject+0×9a 
ba38fd50 7c90e4f4 nt!KiFastCallEntry+0xfc (TrapFrame @ ba38fd64) 
0006f648 7c90df3c ntdll!KiFastSystemCallRet 
0006f64c 7c91b22b ntdll!NtWaitForSingleObject+0xc 
0006f6d4 7c901046 ntdll!RtlpWaitForCriticalSection+0×132 
0006f6dc 01373df7 ntdll!RtlEnterCriticalSection+0×46 
WARNING: Stack unwind information not available. Following frames may be 
wrong. 
0006f7a4 0132b785 ModuleA+0×53df7 
0006f7cc 0132c728 ModuleA+0xb785 
0006f7e4 01346426 ModuleA+0xc728 
0006f848 7e418734 ModuleA+0×26426 
0006f874 7e418816 USER32!InternalCallWinProc+0×28 
0006f8dc 7e4189cd USER32!UserCallWinProcCheckWow+0×150 
0006f93c 7e418a10 USER32!DispatchMessageWorker+0×306 
0006f94c 0084367e USER32!DispatchMessageW+0xf 
0: kd> .process /r /p 8a17cda0 
Implicit process is now 8a17cda0 
Loading User Symbols 
 
 

Unrecognizable Symbolic Information    77 
0: kd> lmv m ModuleA 
start    end        module name 
01320000 013bb000   ModuleA   (deferred)             
    Image path: C:\Program Files\VendorA\ModuleA.dll 
    Image name: ModuleA.dll 
    Timestamp:        Thu Aug 11 21:42:08 2011 (4E4484F0) 
    CheckSum:         000A9C8B 
    ImageSize:        0009B000 
    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4 
0: kd> !lmi ModuleA 
Loaded Module Info: [ModuleA] 
         Module: ModuleA 
   Base Address: 01320000 
     Image Name: ModuleA.dll 
   Machine Type: 332 (I386) 
     Time Stamp: 4e4484f0 Thu Aug 11 21:42:08 2011 
           Size: 9b000 
       CheckSum: a9c8b 
Characteristics: 2102  
Debug Data Dirs: Type  Size     VA  Pointer 
             CODEVIEW    5e, 830a0,   830a0 [Debug data not mapped] - 
can’t validate symbols, if present. 
    Symbol Type: DEFERRED - No error - symbol load deferred 
    Load Report: no symbols loaded 
However, in Stack Trace Collection (Volume 1, page 409, !process 0 3f WinDbg 
command) we find another stack trace from a different process but with loaded symbol 
files for ModuleA: 
THREAD 89703020  Cid 1068.1430  Teb: 7ffdf000 Win32Thread: e34d43a8 WAIT: 
(UserRequest) UserMode Non-Alertable 
89a3ac58  NotificationEvent 
89703110  NotificationTimer 
IRP List: 
899ab488: (0006,0094) Flags: 00000900  Mdl: 00000000 
Not impersonating 
DeviceMap                 e10086c8 
Owning Process            0       Image:         <Unknown> 
Attached Process          89825020       Image:         ApplicationB.exe 
Wait Start TickCount      8164457        Ticks: 2821 (0:00:00:44.078) 
Context Switch Count      552                 LargeStack 
UserTime                  00:00:00.296 
KernelTime                00:00:00.890 
Start Address 0×0103e5e1 
Stack Init b8796000 Current b8795ca0 Base b8796000 Limit b8791000 Call 0 
Priority 15 BasePriority 15 PriorityDecrement 0 DecrementCount 0 
ChildEBP RetAddr 
b8795cb8 80503836 nt!KiSwapContext+0×2f 
b8795cc4 804fb068 nt!KiSwapThread+0×8a 
b8795cec 805c0750 nt!KeWaitForSingleObject+0×1c2 
b8795d50 8054161c nt!NtWaitForSingleObject+0×9a 

78    PART 2: Crash Dump Analysis Patterns 
b8795d50 7c90e4f4 nt!KiFastCallEntry+0xfc (TrapFrame @ b8795d64) 
0006fa1c 7c90df3c ntdll!KiFastSystemCallRet 
0006fa20 7c8025db ntdll!NtWaitForSingleObject+0xc 
0006fa84 010ae96a kernel32!WaitForSingleObjectEx+0xa8 
0006fafc 010aeaaf ModuleA!Wait+0xaa 
0006fb38 010b84ce ModuleA!Read+0×6f 
[...] 
0: kd> !lmi ModuleA 
Loaded Module Info: [ModuleA] 
Module: ModuleA 
Base Address: 01090000 
Image Name: ModuleA.dll 
Machine Type: 332 (I386) 
Time Stamp: 4e4484f0 Thu Aug 11 21:42:08 2011 
Size: 9b000 
CheckSum: a9c8b 
Characteristics: 2102 
Debug Data Dirs: Type  Size     VA  Pointer 
CODEVIEW    5e, 830a0,   830a0 RSDS - GUID: {C14E734A-367F-4DD0-974D-
FA47C1194F28} 
Age: 1, Pdb: Y:\src\...\ModuleA.pdb 
Symbol Type: DEFERRED - No error - symbol load deferred 
Load Report: no symbols loaded 
0: kd> lmv m ModuleA 
start    end        module name 
01090000 0112b000   ModuleA   (deferred) 
Image path: C:\Program Files\VendorA\ModuleA.dll 
Image name: ModuleA.dll 
Timestamp:        Thu Aug 11 21:42:08 2011 (4E4484F0) 
CheckSum:         000A9C8B 
ImageSize:        0009B000 
File version:     1.3.0.0 
Product version:  1.3.0.0 
File flags:       8 (Mask 3F) Private 
File OS:          40004 NT Win32 
File type:        2.0 Dll 
File date:        00000000.00000000 
Translations:     0409.04b0 
CompanyName:      VendorA 
ProductName:      VendorA 
InternalName:     ModuleA.dll 
OriginalFilename: ModuleA.dll 
ProductVersion:   1.3 
FileVersion:      1.3.0.0 
FileDescription:  ModuleA GUI 
LegalCopyright:   Copyright VendorA 
 
 

Unrecognizable Symbolic Information    79 
So we switch to that thread (with the new process context) to get the needed 
symbol path: 
0: kd> .thread /r /p 89703020 
Implicit thread is now 89703020 
Implicit process is now 89825020 
Loading User Symbols 
0: kd> kL 
*** Stack trace for last set context - .thread/.cxr resets it 
ChildEBP RetAddr 
b8795cb8 80503836 nt!KiSwapContext+0x2f 
b8795cc4 804fb068 nt!KiSwapThread+0x8a 
b8795cec 805c0750 nt!KeWaitForSingleObject+0x1c2 
b8795d50 8054161c nt!NtWaitForSingleObject+0x9a 
b8795d50 7c90e4f4 nt!KiFastCallEntry+0xfc 
0006fa1c 7c90df3c ntdll!KiFastSystemCallRet 
0006fa20 7c8025db ntdll!NtWaitForSingleObject+0xc 
0006fa84 010ae96a kernel32!WaitForSingleObjectEx+0xa8 
0006fafc 010aeaaf ModuleA!Wait+0xaa 
0006fb38 010b84ce ModuleA!Read+0×6f 
[...] 
0: kd> lmv m ModuleA 
start    end        module name 
01090000 0112b000   ModuleA   (private pdb 
symbols)  c:\sym\ModuleA.pdb\C14E734A367F4DD0974DFA47C1194F281\ModuleA.pdb 
Loaded symbol image file: ModuleA.dll 
[...] 
Now we switch back to our problem stack trace and set the found symbol path 
explicitly: 
0: kd> .thread /r /p 8a17c6d8 
Implicit thread is now 8a17c6d8 
Implicit process is now 8a17cda0 
Loading User Symbols 
 
 

80    PART 2: Crash Dump Analysis Patterns 
0: kd> kL 
*** Stack trace for last set context - .thread/.cxr resets it 
ChildEBP RetAddr 
ba38fcb8 80503836 nt!KiSwapContext+0x2f 
ba38fcc4 804fb068 nt!KiSwapThread+0x8a 
ba38fcec 805c0750 nt!KeWaitForSingleObject+0x1c2 
ba38fd50 8054161c nt!NtWaitForSingleObject+0x9a 
ba38fd50 7c90e4f4 nt!KiFastCallEntry+0xfc 
0006f648 7c90df3c ntdll!KiFastSystemCallRet 
0006f64c 7c91b22b ntdll!NtWaitForSingleObject+0xc 
0006f6d4 7c901046 ntdll!RtlpWaitForCriticalSection+0x132 
*** ERROR: Module load completed but symbols could not be loaded for 
ModuleA.dll 
0006f6dc 01373df7 ntdll!RtlEnterCriticalSection+0x46 
WARNING: Stack unwind information not available. Following frames may be 
wrong. 
0006f7a4 0132b785 ModuleA+0×53df7 
0006f7cc 0132c728 ModuleA+0xb785 
0006f7e4 01346426 ModuleA+0xc728 
0006f848 7e418734 ModuleA+0×26426 
0006f874 7e418816 USER32!InternalCallWinProc+0×28 
0006f8dc 7e4189cd USER32!UserCallWinProcCheckWow+0×150 
0006f93c 7e418a10 USER32!DispatchMessageWorker+0×306 
0006f94c 0084367e USER32!DispatchMessageW+0xf 
[...] 
0: kd> .sympath+ c:\sym\ModuleA.pdb\C14E734A367F4DD0974DFA47C1194F281 
Symbol search path is: 
SRV*c:\mss*http://msdl.microsoft.com/download/symbols; 
c:\sym\ModuleA.pdb\C14E734A367F4DD0974DFA47C1194F281 
[...] 
0: kd> .reload 
Loading Kernel Symbols 
Loading User Symbols 
Loading unloaded module list 
 
 

Unrecognizable Symbolic Information    81 
0: kd> kL 
*** Stack trace for last set context - .thread/.cxr resets it 
ChildEBP RetAddr 
ba38fcb8 80503836 nt!KiSwapContext+0x2f 
ba38fcc4 804fb068 nt!KiSwapThread+0x8a 
ba38fcec 805c0750 nt!KeWaitForSingleObject+0x1c2 
ba38fd50 8054161c nt!NtWaitForSingleObject+0x9a 
ba38fd50 7c90e4f4 nt!KiFastCallEntry+0xfc 
0006f648 7c90df3c ntdll!KiFastSystemCallRet 
0006f64c 7c91b22b ntdll!NtWaitForSingleObject+0xc 
0006f6d4 7c901046 ntdll!RtlpWaitForCriticalSection+0x132 
0006f6dc 01373df7 ntdll!RtlEnterCriticalSection+0x46 
0006f6e4 0132b22e ModuleA!CSLock+0×7 
0006f7a4 0132b785 ModuleA!SignalEvent+0×5e 
[...] 
0006f848 7e418734 ModuleA!WindowProc+0×136 
0006f874 7e418816 USER32!InternalCallWinProc+0×28 
0006f8dc 7e4189cd USER32!UserCallWinProcCheckWow+0×150 
0006f93c 7e418a10 USER32!DispatchMessageWorker+0×306 
0006f94c 0084367e USER32!DispatchMessageW+0xf 
[...] 
 
 
 

82    PART 2: Crash Dump Analysis Patterns 
Network Packet Buildup 
When looking at network packet pools using NDIS WinDbg extension we might see 
increased number of allocated blocks possibly correlated with network problems, for 
example: 
0: kd> !ndiskd.pktpools * normal 
Pool     Allocator BlocksAllocated BlockSize PktsPerBlock PacketLength 
8a467e20 b9090f96  0×1             0×1000    0×14         0xc8   tcpip!ARPRegister+119 
8a491460 ba4eea56  0×1             0×1000    0×14         0xc8   wanarp!WanpInitializeNdis+a8 
8a466508 b905d368  0×1             0×1000    0xd          0×138  tcpip!InitForwardingPools+53 
8a373578 b905becb  0×3             0×1000    0×11         0xe8   tcpip!AllocIPPacketList+59 
8a466580 b9095ac5  0×1             0×1000    0xe          0×118  tcpip!IPInit+e0 
8a460958 bac40a97  0xb             0×1000    0×14         0xc8   vmxnet+a97 
0: kd> !ndiskd.pktpools * no sent packets 
Pool     Allocator BlocksAllocated BlockSize PktsPerBlock PacketLength 
8a467e20 b9090f96  0×1             0×1000    0×14         0xc8 tcpip!ARPRegister+119 
8a491460 ba4eea56  0×1             0×1000    0×14         0xc8 wanarp!WanpInitializeNdis+a8 
8a466508 b905d368  0×1             0×1000    0xd          0×138 tcpip!InitForwardingPools+53 
8a373578 b905becb  0xa3            0×1000    0×11         0xe8 tcpip!AllocIPPacketList+59 
8a466580 b9095ac5  0×1             0×1000    0xe          0×118 tcpip!IPInit+e0 
8a460958 bac40a97  0×9b            0×1000    0×14         0xc8 vmxnet+a97 
 
 
 

Disconnected Network Adapter    83 
Disconnected Network Adapter 
Sometimes we need to check network adapters (miniports) to see whether they are up, 
down, connected or disconnected. This can be done using ndiskd WinDbg extension and 
its commands. Here is an example from a kernel memory dump: 
1: kd> !ndiskd.miniports 
raspptp.sys, v0.0 
  88453360 NetLuidIndex  1, IfIndex  3,  WAN Miniport (PPTP) 
raspppoe.sys, v0.0 
  884860e8 NetLuidIndex  0, IfIndex  4,  WAN Miniport (PPPOE) 
ndiswan.sys, v0.0 
  8842f0e8 NetLuidIndex  0, IfIndex  5,  WAN Miniport (IPv6) 
  8842e0e8 NetLuidIndex  3, IfIndex  6,  WAN Miniport (IP) 
rasl2tp.sys, v0.0 
  8842b0e8 NetLuidIndex  0, IfIndex  2,  WAN Miniport (L2TP) 
E1G60I32.sys, v8.1 
  84b730e8 NetLuidIndex  4, IfIndex  8,  Intel(R) PRO/1000 MT Network 
Connection 
tunnel.sys, v1.0 
  84b370e8 NetLuidIndex  2, IfIndex  9,  isatap.{0DC6D9AD-70DC-41CE-9798-
F71D1A8C899F} 
1: kd> !ndiskd.miniport 84b730e8 
MINIPORT 
    Intel(R) PRO/1000 MT Network Connection 
    Ndis Handle        84b730e8 
    Ndis API Version   v6.0 
    Adapter Context    88460008 
    Miniport Driver    84b44938 - E1G60I32.sys  v8.1 
    Ndis Verifier      [No flags set] 
    Media Type         802.3 
    Physical Medium    802.3 
    Device 
Path        \??\PCI#VEN_8086&DEV_100F&SUBSYS_075015AD&REV_01#4&b70f118&0&0
888#{ad498944-762f-11d0-8dcb-00c04fc3358c}\{0DC6D9AD-70DC-41CE-9798-
F71D1A8C899F} 
    Device Object      84b73030 
    MAC Address        00-0c-29-b1-7d-39 
STATE 
    Miniport           Running 
    Device PnP         Started 
    Datapath           00000002          ← 

84    PART 2: Crash Dump Analysis Patterns 
DIVERTED_BECAUSE_MEDIA_DISCONNECTED 
    NBL Status         NDIS_STATUS_MEDIA_DISCONNECTED 
    Operational status DOWN 
    Operational flags  00000002          ← DOWN_NOT_CONNECTED 
    Admin status       ADMIN_UP 
    Media              MediaDisconnected 
    Power              D0 
    References         6 
    User Handles       0 
    Total Resets       0 
    Pending OID        None 
    Flags              0c452218 
        ↑ BUS_MASTER, 64BIT_DMA, SG_DMA, DEFAULT_PORT_ACTIVATED, 
        SUPPORTS_MEDIA_SENSE, DOES_NOT_DO_LOOPBACK, NOT_MEDIA_CONNECTED 
    PnPFlags           00210021 
        ↑ PM_SUPPORTED, DEVICE_POWER_ENABLED, RECEIVED_START, 
HARDWARE_DEVICE 
BINDINGS 
    Filter List        Filter              Filter 
Driver      Context          _ 
    QoS Packet Scheduler-0000 
                       88e453d8            88e18938           88e1ed60 
    Open 
List          Open                Protocol           Context          _ 
    RSPNDR             8bcbb470            8bd23ac8           8bcbb820 
    LLTDIO             8bcb8c00            8bd15980           8bd153f8 
    TCPIP6             88e528e8            88e02350           88e52c98 
    TCPIP              88e1c078            88e02aa8           88e1e6a8 
MORE INFORMATION 
     → Driver handlers                      → Task offloads 
     → Power management 
     → Pending OIDs                         → Timers 
                                            → Receive Side Throttling 
     → Wake-on-LAN (WoL)                    → Packet filter 
     → NDIS ports 
Another example from a different complete memory dump:  
STATE 
    Device PnP         Started 
    Datapath           00000002          ← 
DIVERTED_BECAUSE_MEDIA_DISCONNECTED 
    Packet Status      NDIS_STATUS_NO_CABLE 
    Media              Not Connected 
  [...] 

Problem Module    85 
Problem Module 
Sometimes this pattern can help in troubleshooting. Problem Modules (including 
process names) are components that due to their value adding behavior might break 
normal software behavior and, therefore, require some troubleshooting workarounds 
from minor configuration changes to their complete removal. Typical examples include 
memory optimization services7 for terminal services environments or hooksware8. We 
can see main process modules in the output of !vm or !process 0 0 WinDbg commands. 
lm command will list module names such as DLLs from a process memory dump, lmk 
command can give us the list of kernel space modules (for example, drivers) from kernel 
and complete memory dumps, and the following command lists all user space modules 
for each process in a complete memory dump: 
!for_each_process ".process /r /p @#Process; lmu" 
Of course, we can also try various lm command variants if we are interested in 
timestamps and module information. 
 
 
                                                                 
7 http://support.citrix.com/article/CTX128286 
8 Volume 2, page 63 

86    PART 2: Crash Dump Analysis Patterns 
Empty Stack Trace 
This is another stack trace9 related pattern. Here we might need to do manual stack 
trace reconstruction (Volume 1, page 157) like shown in the following example: 
0:002> ~2s 
eax=00000070 ebx=0110fb94 ecx=00000010 edx=005725d8 esi=0110fe58 
edi=00000d80 
eip=7c82847c esp=0110efe0 ebp=0110eff0 iopl=0 nv up ei pl zr na pe nc 
cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00000246 
ntdll!KiFastSystemCallRet: 
7c82847c c3 ret 
0:002> kL 
ChildEBP RetAddr 
0110efdc 00000000 ntdll!KiFastSystemCallRet 
0:002> !teb 
TEB at  7ffdc000 
ExceptionList:  
0110f980 
StackBase:  
 
01110000 
StackLimit:  
 
0110d000 
SubSystemTib:   
00000000 
FiberData:  
 
00001e00 
ArbitraryUserPointer: 00000000 
Self:   
 
7ffdc000 
EnvironmentPointer:  
00000000 
ClientId:  
 
00000b04 . 00000bd0 
RpcHandle:  
 
00000000 
Tls Storage:   
00000000 
PEB Address:   
7ffda000 
LastErrorValue:  
87 
LastStatusValue:  
c000000d 
Count Owned Locks:  
0 
HardErrorMode:  
0 
0:002> dps 0110d000 01110000 
0110d000 00000000 
0110d004 00000000 
[...] 
0110f640 0110f64c 
0110f644 02b91ea8 
0110f648 00001000 
0110f64c 00000004 
0110f650 0110f6f0 
0110f654 0374669d DbgHelp!WriteFullMemory+0×3cd 
                                                                 
9 Volume 6, page 294 

Empty Stack Trace    87 
0110f658 ffffffff 
0110f65c 0110d000 
0110f660 00000000 
0110f664 0480f5c0 
0110f668 00003000 
0110f66c 0110f7b0 
0110f670 0110d000 
0110f674 00000000 
0110f678 00000065 
0110f67c 00003000 
0110f680 0110d000 
0110f684 00000000 
0110f688 01010000 
0110f68c 00000000 
0110f690 00000004 
0110f694 00060002 
0110f698 00003000 
0110f69c 00000000 
0110f6a0 00001000 
0110f6a4 00000004 
0110f6a8 00020000 
0110f6ac 00040004 
0110f6b0 7ffe0000 SharedUserData 
0110f6b4 00000000 
0110f6b8 00001000 
0110f6bc 00000000 
0110f6c0 0480f5c0 
0110f6c4 00000000 
0110f6c8 04c4a000 
0110f6cc 00000000 
0110f6d0 000003c7 
0110f6d4 00000000 
0110f6d8 00023b17 
0110f6dc 00000000 
0110f6e0 01110000 
0110f6e4 00000000 
0110f6e8 0099f000 
0110f6ec 00000000 
0110f6f0 0110f704 
0110f6f4 037469d6 DbgHelp!WriteDumpData+0×206 
0110f6f8 0110f738 
0110f6fc 0110f7b0 
0110f700 00000000 
0110f704 0110f868 
0110f708 03747449 DbgHelp!MiniDumpProvideDump+0×359 
0110f70c 0110f738 
0110f710 0110f7b0 
0110f714 02b91fb0 
0110f718 00000000 
0110f71c 00000000 
0110f720 00000000 
0110f724 02b91fb0 
0110f728 00000000 
0110f72c 00000000 

88    PART 2: Crash Dump Analysis Patterns 
[...] 
0110ff1c 00000001 
0110ff20 00000008 
0110ff24 0000000a 
0110ff28 33017f51 ModuleA!Run+0xde 
0110ff2c 00000001 
0110ff30 0110ff74 
0110ff34 00f08898 
0110ff38 00000000 
0110ff3c 00f082a8 
0110ff40 00000000 
0110ff44 00000001 
0110ff48 33017e33 ModuleA!ThreadProc+0×2c 
0110ff4c a9b21e1e 
0110ff50 00000000 
0110ff54 00000000 
0110ff58 00f08898 
0110ff5c 0110ff4c 
0110ff60 0110ffac 
0110ff64 0110ff9c 
0110ff68 33054245 
0110ff6c 9ba52ad2 
0110ff70 00000000 
0110ff74 0110ffac 
0110ff78 78543433 msvcr90!_endthreadex+0×44 
0110ff7c 00f082a8 
0110ff80 a9b2b0d3 
0110ff84 00000000 
0110ff88 00000000 
0110ff8c 00f08898 
0110ff90 0110ff80 
0110ff94 0110ff80 
0110ff98 0110ffdc 
0110ff9c 0110ffdc 
0110ffa0 7858cf5e msvcr90!_except_handler4 
0110ffa4 d0f887df 
0110ffa8 00000000 
0110ffac 0110ffb8 
0110ffb0 785434c7 msvcr90!_endthreadex+0xd8 
0110ffb4 00000000 
0110ffb8 0110ffec 
0110ffbc 77e6482f kernel32!BaseThreadStart+0×34 
0110ffc0 00f08898 
0110ffc4 00000000 
0110ffc8 00000000 
0110ffcc 00f08898 
0110ffd0 00000000 
0110ffd4 0110ffc4 
0110ffd8 80833bcc 
0110ffdc ffffffff 
0110ffe0 77e61a60 kernel32!_except_handler3 
0110ffe4 77e64838 kernel32!`string’+0×98 
0110ffe8 00000000 
0110ffec 00000000 

Empty Stack Trace    89 
0110fff0 00000000 
0110fff4 7854345e msvcr90!_endthreadex+0×6f 
0110fff8 00f08898 
0110fffc 00000000 
01110000 00000130 
0:002> k L=0110f650 0110f650 0110f650 
ChildEBP RetAddr 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
0110f650 0374669d 0x110f650 
0110f6f0 037469d6 DbgHelp!WriteFullMemory+0x3cd 
0110f704 03747449 DbgHelp!WriteDumpData+0x206 
0110f868 03747662 DbgHelp!MiniDumpProvideDump+0x359 
0110f8dc 33050dd9 DbgHelp!MiniDumpWriteDump+0x1b2 
[...] 
0110fdfc 33031726 ModuleA!WriteExceptionMiniDump+0x50 
0110fea0 33018c81 ModuleA!ThreadHung+0x6c 
[...] 
0110ff44 33017e33 ModuleA!Run+0xde 
00000000 00000000 ModuleA!ThreadProc+0x2c 
 
 

90    PART 2: Crash Dump Analysis Patterns 
Debugger Bug 
When doing a software behavior artifact collection, live debugging or postmortem 
memory dump analysis we must also take into consideration the possibility of Debugger 
Bugs. We classify them into hard and soft bugs. The former are those software defects 
and behavioral problems that result in further abnormal software behavior incidents like 
crashes and hangs. One example is this Microsoft KB article about DebugDiag10. Soft 
debugger bugs usually manifest themselves as glitches in data output, nonsense or false 
positive diagnostics, for example, the following excessive non-paged pool usage 
message in the output from !vm WinDbg command (see the corresponding MS KB 
article11): 
1: kd> !vm 
*** Virtual Memory Usage *** 
Physical Memory:     1031581 (   4126324 Kb) 
Page File: \??\C:\pagefile.sys 
Current:   4433524 Kb  Free Space:   4433520 Kb 
Minimum:   4433524 Kb  Maximum:     12378972 Kb 
Unimplemented error for MiSystemVaTypeCount 
Available Pages:      817652 (   3270608 Kb) 
ResAvail Pages:       965229 (   3860916 Kb) 
Locked IO Pages:           0 (         0 Kb) 
Free System PTEs:   33555714 ( 134222856 Kb) 
Modified Pages:        15794 (     63176 Kb) 
Modified PF Pages:     15793 (     63172 Kb) 
NonPagedPool Usage: 88079121 ( 352316484 Kb) 
NonPagedPoolNx Usage:  12885 (     51540 Kb) 
NonPagedPool Max:     764094 (   3056376 Kb) 
********** Excessive NonPaged Pool Usage ***** 
PagedPool 0 Usage:     35435 (    141740 Kb) 
PagedPool 1 Usage:      3620 (     14480 Kb) 
PagedPool 2 Usage:       573 (      2292 Kb) 
PagedPool 3 Usage:       535 (      2140 Kb) 
PagedPool 4 Usage:       538 (      2152 Kb) 
PagedPool Usage:       40701 (    162804 Kb) 
PagedPool Maximum:  33554432 ( 134217728 Kb) 
Session Commit:         9309 (     37236 Kb) 
Shared Commit:          6460 (     25840 Kb) 
Special Pool:              0 (         0 Kb) 
Shared Process:         5760 (     23040 Kb) 
                                                                 
10 http://support.microsoft.com/kb/970107/ 
11 http://support.microsoft.com/kb/2509968/ 

Debugger Bug    91 
PagedPool Commit:      40765 (    163060 Kb) 
Driver Commit:          2805 (     11220 Kb) 
Committed pages:      212472 (    849888 Kb) 
Commit limit:        2139487 (   8557948 Kb) 
 
 

92    PART 2: Crash Dump Analysis Patterns 
Value References 
Sometimes we have a value or a pointer or a handle and would like to know all memory 
addresses that reference it. This can be done by virtual memory search (s WinDbg 
command). If we look for references in code (for example, for pool tags, please see the 
case study in Volume 1, page 206) we can combine search with !for_each_module 
WinDbg extension command. There is also !search command for physical pages. We 
cover this Value References pattern in Advanced Windows Memory Dump Analysis 
training12 with a step-by-step complete memory dump analysis exercise. For object 
references there is also recently added !obtrace command with good examples in 
WinDbg help. 
 
 
                                                                 
12 http://www.patterndiagnostics.com/advanced-windows-memory-dump-analysis 

Self-Diagnosis (Registry)    93 
Self-Diagnosis (Registry) 
This is a variant of Self-Diagnosis (kernel mode) pattern (Volume 6, page 89) for system 
configuration database (registry). Sometimes it is possible to see which part of it (hive) 
caused the problem. Here’s an example involving possibly corrupt user profiles: 
REGISTRY_ERROR (51) 
Something has gone badly wrong with the registry. If a kernel debugger is 
available, get a stack trace. It can also indicate that the registry got 
an I/O error while trying to read one of its files, so it can be caused by 
hardware problems or filesystem corruption. It may occur due to a failure 
in a refresh operation, which is used only in by the security system, and 
then only when resource limits are encountered. 
Arguments: 
Arg1: 00000003, (reserved) 
Arg2: 00000004, (reserved) 
Arg3: e82372f8, depends on where Windows bugchecked, may be pointer to 
hive 
Arg4: 00000000, depends on where Windows bugchecked, may be return code of 
HvCheckHive if the hive is corrupt. 
0: kd> !reg hivelist 
---------------------------------------------------------------------------------------------------------------------- 
| HiveAddr |Stable Length|Stable Map|Volatile Length|Volatile Map|MappedViews|PinnedViews|U(Cnt)| BaseBlock | FileName 
---------------------------------------------------------------------------------------------------------------------- 
| e1008a68 | 13000 | e1008ac8 | 1000 | e1008c04 | 0 | 0 | 0| e1015000 | <NONAME> 
| e101a4e0 | 901000 | e1023000 | 40000 | e101a67c | 202 | 0 | 0| e101e000 | SYSTEM 
| e1938188 | d000 | e19381e8 | 4000 | e1938324 | 0 | 0 | 0| e193a000 | <NONAME> 
| e1968290 | 8000 | e19682f0 | 0 | 00000000 | 3 | 0 | 0| e1d39000 | \SystemRoot\System32\Config\SAM 
| e1cab270 | 3d000 | e1cab2d0 | 1000 | e1cab40c | 16 | 0 | 0| e1d32000 | emRoot\System32\Config\SECURITY 
| e1c9f448 | 3f70000 | e1e37000 | 1000 | e1c9f5e4 | 256 | 0 | 0| e1d71000 | temRoot\System32\Config\DEFAULT 
| e1d75a80 | 7d5d000 | e1ee3000 | 23000 | e1d75c1c | 254 | 12 | 0| e1d37000 | emRoot\System32\Config\SOFTWARE 
| e1ba30d0 | 37000 | e1ba3130 | 1000 | e1ba326c | 17 | 0 | 0| e1b9e000 | tings\NetworkService\ntuser.dat 
| e1ba8060 | 1000 | e1ba80c0 | 0 | 00000000 | 1 | 0 | 0| e1b8e000 | \Microsoft\Windows\UsrClass.dat 
| e1afc068 | 3b000 | e1afc0c8 | 1000 | e1afc204 | 17 | 0 | 0| e1b3d000 | ettings\LocalService\ntuser.dat 
| e1d6e2a0 | 1000 | e1d6e300 | 0 | 00000000 | 1 | 0 | 0| e1b39000 | \Microsoft\Windows\UsrClass.dat 
[...] 
| e82372f8 | 106000 | e8237358 | 0 | 00000000 | 55 | 4 | 0| e514c000 | ings\User123\NTUSER.DAT 
[...] 
0: kd> dt _CMHIVE e82372f8 
nt!_CMHIVE 
+0x000 Hive : _HHIVE 
+0x2d0 FileHandles : [3] 0x80002234 Void 
+0x2dc NotifyList : _LIST_ENTRY [ 0x0 - 0x0 ] 
+0x2e4 HiveList : _LIST_ENTRY [ 0xe7a38d64 - 0xe4d9fc9c ] 
+0x2ec HiveLock : _EX_PUSH_LOCK 
+0x2f0 ViewLock : 0x877b0120 _KGUARDED_MUTEX 
+0x2f4 WriterLock : _EX_PUSH_LOCK 
+0x2f8 FlusherLock : _EX_PUSH_LOCK 
+0x2fc SecurityLock : _EX_PUSH_LOCK 
+0x300 LRUViewListHead : _LIST_ENTRY [ 0xe6160170 - 0xe3d71978 ] 
+0x308 PinViewListHead : _LIST_ENTRY [ 0xe2714fe0 - 0xe108d9e0 ] 
+0x310 FileObject : 0x89ecf310 _FILE_OBJECT 
+0x314 FileFullPath : _UNICODE_STRING "\Device\HarddiskVolumeX\Documents 
and Settings\User123\NTUSER.DAT" 

94    PART 2: Crash Dump Analysis Patterns 
+0×31c FileUserName : _UNICODE_STRING “\??\E:\Documents and 
Settings\User123\NTUSER.DAT” 
+0×324 MappedViews : 0×37 
+0×326 PinnedViews : 4 
+0×328 UseCount : 0 
+0×32c SecurityCount : 9 
+0×330 SecurityCacheSize : 9 
+0×334 SecurityHitHint : 0n0 
+0×338 SecurityCache : 0xe74d5008 _CM_KEY_SECURITY_CACHE_ENTRY 
+0×33c SecurityHash : [64] _LIST_ENTRY [ 0xe3f80228 - 0xe5901ef0 ] 
+0×53c UnloadEvent : (null) 
+0×540 RootKcb : (null) 
+0×544 Frozen : 0 ” 
+0×548 UnloadWorkItem : (null) 
+0×54c GrowOnlyMode : 0 ” 
+0×550 GrowOffset : 0 
+0×554 KcbConvertListHead : _LIST_ENTRY [ 0xe823784c - 0xe823784c ] 
+0×55c KnodeConvertListHead : _LIST_ENTRY [ 0xe8237854 - 0xe8237854 ] 
+0×564 CellRemapArray : (null) 
+0×568 Flags : 1 
+0×56c TrustClassEntry : _LIST_ENTRY [ 0xe8237864 - 0xe8237864 ] 
+0×574 FlushCount : 0 
+0×578 CreatorOwner : (null) 
 
 

System Object    95 
System Object 
Certain System Objects can be found in object directory and can be useful to see the 
additional system and other product activity. For example, in a complete memory dump 
we see that LowCommitCondition event is signaled: 
1: kd> !object \KernelObjects 
Object: 85a08030 Type: (82b38ed0) Directory 
ObjectHeader: 85a08018 (old version) 
HandleCount: 0 PointerCount: 19 
Directory Object: 85a074c0 Name: KernelObjects 
Hash Address  Type       Name 
---- -------  ----       ---- 
02   82b7b0b8 Event      HighCommitCondition 
04   82b7b780 Event      HighMemoryCondition 
10   82b7b178 Event      LowNonPagedPoolCondition 
11   82b7b138 Event      HighNonPagedPoolCondition 
17   82b7b0f8 Event      LowCommitCondition 
20   82b78d08 Event      SuperfetchParametersChanged 
     82b6eb58 Event      BootLoaderTraceReady 
23   84bfdd58 Session    Session0 
     82b78c88 Event      PrefetchTracesReady 
24   84b7d1f8 Session    Session1 
25   82b78cc8 Event      SuperfetchScenarioNotify 
     82b7b740 Event      LowPagedPoolCondition 
26   82b7b1b8 Event      HighPagedPoolCondition 
     82b7a030 Event      MemoryErrors 
28   82b78c48 Event      SuperfetchTracesReady 
32   82b7b7c0 Event      LowMemoryCondition 
     85a09d00 KeyedEvent CritSecOutOfMemoryEvent 
34   82b7b078 Event      MaximumCommitCondition 
1: kd> dt _DISPATCHER_HEADER 82b7b0f8 
ntdll!_DISPATCHER_HEADER 
+0x000 Type :   
0 '' 
+0x001 Abandoned :  
0 '' 
+0x001 Absolute :  
0 '' 
+0x001 NpxIrql :  
0 '' 
+0x001 Signalling :  
0 '' 
+0x002 Size :   
0x4 '' 
+0x002 Hand :   
0x4 '' 
+0x003 Inserted :  
0 '' 
+0x003 DebugActive :  0 '' 
+0x003 DpcActive :  
0 '' 
+0x000 Lock :   
0n262144 
+0×004 SignalState :  0n1 
+0×008 WaitListHead : _LIST_ENTRY [ 0×82b7b100 - 0×82b7b100 ] 

96    PART 2: Crash Dump Analysis Patterns 
If we check virtual memory statistics we see a lot of free space in the current 
physical memory and page file:  
1: kd> !vm 
*** Virtual Memory Usage *** 
Physical Memory: 261872 ( 1047488 Kb) 
Page File: \??\C:\pagefile.sys 
Current: 1354688 Kb  
Free Space: 53120 Kb 
Minimum: 1354688 Kb  
Maximum: 4194304 Kb 
Available Pages:  
180984 (  723936 Kb) 
ResAvail Pages:  
216475 (  865900 Kb) 
Locked IO Pages:  
     0 (       0 Kb) 
Free System PTEs:  
352925 ( 1411700 Kb) 
Modified Pages:  
   129 (     516 Kb) 
Modified PF Pages:  
    94 (     376 Kb) 
NonPagedPool Usage: 
     0 (       0 Kb) 
NonPagedPoolNx Usage:   16894 (   67576 Kb) 
NonPagedPool Max:  
192350 (  769400 Kb) 
PagedPool 0 Usage:  
  5957 (   23828 Kb) 
PagedPool 1 Usage:  
  3218 (   12872 Kb) 
PagedPool 2 Usage:  
   965 (    3860 Kb) 
PagedPool 3 Usage: 
  1311 (    5244 Kb) 
PagedPool 4 Usage:  
  1064 (    4256 Kb) 
PagedPool Usage:  
 12515 (   50060 Kb) 
PagedPool Maximum:  
523264 ( 2093056 Kb) 
Session Commit:  
  5021 (   20084 Kb) 
Shared Commit:  
 15023 (   60092 Kb) 
Special Pool:   
     0 (       0 Kb) 
Shared Process:  
  1938 (    7752 Kb) 
PagedPool Commit:  
 12523 (   50092 Kb) 
Driver Commit:  
  2592 (   10368 Kb) 
Committed pages:  
402494 ( 1609976 Kb) 
Commit limit:   
589254 ( 2357016 Kb) 
[...] 
Another example is from Windows 7 memory dump. Here we can find WER 
reporting mutant in session 1 object directory and get problem PID from its name: 
0: kd> !object \Sessions\1\BaseNamedObjects\ 
Object: fffff8a0016eb290 Type: (fffffa800426df30) Directory 
ObjectHeader: fffff8a0016eb260 (new version) 
HandleCount: 57 PointerCount: 217 
Directory Object: fffff8a0016e9220 Name: BaseNamedObjects 
 
 

System Object    97 
Hash Address          Type    Name 
---- -------          ----    ---- 
00   fffffa8008437670 Event   STOP_HOOKING64 
[...] 
08   fffffa80044baa40 Mutant  WERReportingForProcess1788 
[...] 
0: kd> !process 0n1788 1 
Searching for Process with Cid == 6fc 
Cid handle table at fffff8a00180b000 with 21248 entries in use 
PROCESS fffffa8004364060 
SessionId: 1 Cid: 06fc Peb: 7fffffd4000 ParentCid: 0840 
DirBase: 5fbc2000 ObjectTable: fffff8a004c8e930 HandleCount: 16. 
Image: ApplicationD.exe 
VadRoot fffffa8009d85170 Vads 34 Clone 0 Private 206. Modified 0. Locked 
0. 
DeviceMap  
fffff8a001ce6b90 
Token   
fffff8a003eab060 
ElapsedTime  
00:01:51.543 
UserTime  
00:00:00.000 
KernelTime  
00:00:00.000 
QuotaPoolUsage[PagedPool]  
0 
QuotaPoolUsage[NonPagedPool]  0 
Working Set Sizes (now,min,max) (483, 50, 345) (1932KB, 200KB, 1380KB) 
PeakWorkingSetSize 483 
VirtualSize  
    13 Mb 
PeakVirtualSize    13 Mb 
PageFaultCount     481 
MemoryPriority     BACKGROUND 
BasePriority      8 
CommitCharge      231 
 
 

98    PART 2: Crash Dump Analysis Patterns 
Module Variable 
In addition to functions, we also have module variables like nt!MmPagedPoolCommit 
in Windows 7: 
0: kd> x nt!MmPagedPool* 
fffff800`031148d0 nt!MmPagedPoolInfo = <no type information> 
fffff800`03092d20 nt!MmPagedPoolCommit = <no type information> 
fffff800`031141a0 nt!MmPagedPoolEnd = <no type information> 
fffff800`031175c0 nt!MmPagedPoolWs = <no type information> 
If we are not sure whether we have a function or Module Variable we can try to 
disassemble its address: 
0: kd> u nt!MmPagedPoolCommit 
nt!MmPagedPoolCommit: 
fffff800`03092d20 e3b2 jrcxz nt!MmTotalNonPagedPoolQuota+0x4 
(fffff800`03092cd4) 
fffff800`03092d22 0000 add byte ptr [rax],al 
fffff800`03092d24 0000 add byte ptr [rax],al 
fffff800`03092d26 0000 add byte ptr [rax],al 
fffff800`03092d28 0000 add byte ptr [rax],al 
fffff800`03092d2a 0000 add byte ptr [rax],al 
fffff800`03092d2c 0000 add byte ptr [rax],al 
fffff800`03092d2e 0000 add byte ptr [rax],al 
Here the value is probably in pages, so we multiply by 4 to get value in Kb and 
compare to the output of !vm command: 
0: kd> dp nt!MmPagedPoolCommit 
fffff800`03092d20 00000000`0000b2e3 00000000`00000000 
fffff800`03092d30 00000000`00000000 00000000`00000000 
fffff800`03092d40 00000000`00000001 00000000`00000000 
fffff800`03092d50 00000000`00000000 00000000`00060107 
fffff800`03092d60 fffff800`03092d60 fffff800`03092d60 
fffff800`03092d70 00000000`00000000 00000000`0001e972 
fffff800`03092d80 fffff900`c0000000 00000000`00000002 
fffff800`03092d90 fffff880`071dc0a8 fffff880`057340a8 
0: kd> ? b2e3 * 4 
Evaluate expression: 183180 = 00000000`0002cb8c 
 
 

Module Variable    99 
0: kd> !vm 
*** Virtual Memory Usage *** 
Physical Memory:  
1035228 ( 4140912 Kb) 
Page File:  
 
\??\C:\pagefile.sys 
Current: 4448112 Kb  
Free Space: 4448108 Kb 
Minimum: 4448112 Kb  
Maximum: 12422736 Kb 
Unimplemented error for MiSystemVaTypeCount 
Available Pages:  
  594029 (   2376116 Kb) 
ResAvail Pages:  
  889795 (   3559180 Kb) 
Locked IO Pages:  
       0 (  
    0 Kb) 
Free System PTEs:  
33556870 ( 134227480 Kb) 
Modified Pages:  
   20079 (     80316 Kb) 
Modified PF Pages:  
   19441 (     77764 Kb) 
NonPagedPool Usage:  
50865104 ( 203460416 Kb) 
NonPagedPoolNx Usage:     28163 (    112652 Kb) 
NonPagedPool Max:  
  763396 (   3053584 Kb) 
********** Excessive NonPaged Pool Usage ***** 
PagedPool 0 Usage:  
   39420 (    157680 Kb) 
PagedPool 1 Usage:  
    5194 (     20776 Kb) 
PagedPool 2 Usage:  
     367 (      1468 Kb) 
PagedPool 3 Usage:  
     338 (      1352 Kb) 
PagedPool 4 Usage:  
     440 (      1760 Kb) 
PagedPool Usage:  
   45759 (    183036 Kb) 
PagedPool Maximum:  
33554432 ( 134217728 Kb) 
Session Commit:  
    8112 (     32448 Kb) 
Shared Commit:  
   31802 (    127208 Kb) 
Special Pool:   
       0 (         0 Kb) 
Shared Process:  
   10765 (     43060 Kb) 
PagedPool Commit:  
   45795 (    183180 Kb) 
Driver Commit:  
   13773 (     55092 Kb) 
Committed pages:  
  540998 (   2163992 Kb) 
Commit limit:   
 2146794 (   8587176 Kb) 
[...] 
Knowledge of available Module Variables is useful because some of them are not 
included in WinDbg extension command output. For their list, please consult Windows 
Internals book. Useful variables can also be found in other modules as well, for example, 
srv!srvcomputername (Volume 1, page 616): 
0: kd> dS srv!srvcomputername 
fffff8a0`0344b090 "MYNOTEBOOK" 
 
 

100    PART 2: Crash Dump Analysis Patterns 
Stack Trace Collection (Predicate) 
Sometimes we need to narrow general stack trace collection to a few threads that 
satisfy some predicate13, for example, all threads with kernel time spent greater than 
some value, or all suspended threads, or all threads that wait for a specific 
synchronization object type. This can be implemented using WinDbg scripts (page 32) 
and / or debugger extensions. 
 
 
                                                                 
13 http://en.wikipedia.org/wiki/Predicate_(mathematical_logic) 

Stack Trace Collection (I/O Requests)    101 
Stack Trace Collection (I/O Requests) 
In addition to stack trace collections for threads (unmanaged 14, managed 15 and 
predicate, page 100) we introduce an additional pattern for I/O requests. Such requests 
are implemented via the so-called I/O request packets (IRP) that “travel” from a device 
driver to a device driver similar to a C++ class method to another C++ class method 
(where a device object address is similar to a C++ object instance address). An IRP stack 
is used to keep a track of the current driver processing an IRP that is reused between 
device drivers. It is basically an array of structures describing how a particular driver 
function was called with appropriate parameters similar to a call frame on an execution 
thread stack. A long time ago we created a UML diagram depicting the flow of an IRP 
through the driver (device) stack (diagram #3, Volume 1, page 700). An I/O stack 
location pointer is decremented (from the bottom to the top) as a thread stack pointer 
(ESP or RSP). We can list active and completed I/O requests with their stack traces using 
!irpfind -v WinDbg command: 
1: kd> !irpfind -v 
Scanning large pool allocation table for Tag: Irp? (832c7000 : 833c7000) 
Irp    [ Thread ] irpStack: (Mj,Mn)   DevObj  [Driver]         MDL Process 
8883dc18: Irp is active with 1 stacks 1 is current (= 0x8883dc88) 
 No Mdl: No System Buffer: Thread 888f8950:  Irp stack trace. 
      cmd  flg cl Device   File     Completion-Context 
> [  d, 0]   5  1 88515ae8 888f82f0 00000000-00000000    pending 
             \FileSystem\Npfs 
                   Args: 00000000 00000000 00110008 00000000 
891204c8: Irp is active with 1 stacks 1 is current (= 0x89120538) 
 No Mdl: No System Buffer: Thread 889635b0:  Irp stack trace. 
      cmd  flg cl Device   File     Completion-Context 
> [  3, 0]   0  1 88515ae8 84752028 00000000-00000000    pending 
             \FileSystem\Npfs 
                   Args: 0000022a 00000000 00000000 00000000 
 
 
                                                                 
14 Volume 1, page 409 
15 Volume 6, page 127 

102    PART 2: Crash Dump Analysis Patterns 
89120ce8: Irp is active with 1 stacks 1 is current (= 0x89120d58) 
 No Mdl: No System Buffer: Thread 89212030:  Irp stack trace. 
      cmd  flg cl Device   File     Completion-Context 
> [  3, 0]   0  1 88515ae8 8921be00 00000000-00000000    pending 
             \FileSystem\Npfs 
                   Args: 0000022a 00000000 00000000 00000000 
Searching NonPaged pool (80000000 : ffc00000) for Tag: Irp? 
[...] 
892cbe48: Irp is active with 9 stacks 9 is current (= 0x892cbfd8) 
 No Mdl: No System Buffer: Thread 892add78:  Irp stack trace. 
    cmd  flg cl Device   File     Completion-Context 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
> [  c, 2]   0  1 8474a020 892c8c80 00000000-00000000    pending 
             \FileSystem\Ntfs 
                 Args: 00000800 00000002 00000000 00000000 
 
 

Stack Trace Collection (I/O Requests)    103 
892daa88: Irp is active with 4 stacks 4 is current (= 0x892dab64) 
 No Mdl: System buffer=831559c8: Thread 8322c8e8:  Irp stack trace. 
    cmd  flg cl Device   File     Completion-Context 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
> [  e,2d]   5  1 884ba750 83190c40 00000000-00000000    pending 
             \Driver\AFD 
                 Args: 890cbc44 890cbc44 88e55297 8943b6c8 
892ea4e8: Irp is active with 4 stacks 4 is current (= 0x892ea5c4) 
 No Mdl: No System Buffer: Thread 00000000:  Irp stack trace.  Pending has 
been returned 
    cmd  flg cl Device   File     Completion-Context 
[  0, 0]   0  2 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 c0000185 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  f, 0]   0  2 83a34bb0 00000000 84d779ed-88958050 
              \Driver\atapi CLASSPNP!ClasspMediaChangeDetectionCompletion 
                 Args: 88958050 00000000 00000000 83992d10 
> [  0, 0]   2  0 891ee030 00000000 00000000-00000000 
              \Driver\cdrom 
                 Args: 00000000 00000000 00000000 00000000 
8933fcb0: Irp is active with 1 stacks 1 is current (= 0x8933fd20) 
 No Mdl: No System Buffer: Thread 84753d78:  Irp stack trace. 
      cmd  flg cl Device   File     Completion-Context 
> [  3, 0]   0  1 88515ae8 84759f40 00000000-00000000    pending 
               \FileSystem\Npfs 
                   Args: 0000022a 00000000 00000000 00000000 
893cf550: Irp is active with 1 stacks 1 is current (= 0x893cf5c0) 
 No Mdl: No System Buffer: Thread 888fd3b8:  Irp stack trace. 
      cmd  flg cl Device   File     Completion-Context 
> [  3, 0]   0  1 88515ae8 834d30d0 00000000-00000000    pending 
               \FileSystem\Npfs 
                   Args: 00000400 00000000 00000000 00000000 
 
 

104    PART 2: Crash Dump Analysis Patterns 
893da468: Irp is active with 6 stacks 7 is current (= 0x893da5b0) 
 Mdl=892878f0: No System Buffer: Thread 00000000:  Irp is 
completed.  Pending has been returned 
    cmd  flg cl Device   File     Completion-Context 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  f, 0]   0  0 84b3e028 00000000 9747fcd0-00000000 
              \Driver\usbehci USBSTOR!USBSTOR_CswCompletion 
                 Args: 00000000 00000000 00000000 00000000 
[  f, 0]   0  0 892ba8f8 00000000 84d780ce-8328e0f0 
              \Driver\USBSTOR CLASSPNP!TransferPktComplete 
                 Args: 00000000 00000000 00000000 00000000 
893efb00: Irp is active with 10 stacks 11 is current (= 0x893efcd8) 
 Mdl=83159378: No System Buffer: Thread 82b7f828:  Irp is 
completed.  Pending has been returned 
    cmd  flg cl Device   File     Completion-Context 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  0, 0]   0  0 00000000 00000000 00000000-00000000 
                 Args: 00000000 00000000 00000000 00000000 
[  3, 0]   0  0 885a55b8 00000000 81614138-00000000 
             \Driver\disk partmgr!PmReadWriteCompletion 
                 Args: 00000000 00000000 00000000 00000000 
[  3, 0]   0  0 89257c90 00000000 8042e4d4-831caab0 
             \Driver\partmgr volmgr!VmpReadWriteCompletionRoutine 
                 Args: 00000000 00000000 00000000 00000000 

Stack Trace Collection (I/O Requests)    105 
[  3, 0]   0  0 831ca9f8 00000000 84dad0be-00000000 
             \Driver\volmgr ecache!EcDispatchReadWriteCompletion 
                 Args: 00000000 00000000 00000000 00000000 
[  3, 0]   0  0 8319c020 00000000 84dcc4d4-8576f8ac 
             \Driver\Ecache volsnap!VspSignalCompletion 
                 Args: 00000000 00000000 00000000 00000000 
 
 

106    PART 2: Crash Dump Analysis Patterns 
Regular Data 
This pattern generalizes ASCII and UNICODE-type (00xx00yy) data found in memory to 
domain-specific data formats such as bitmaps and vector data. An example of the latter 
could be a sequence of ...0xxx0yyy... (xxx are triplets of hex digits). A typical usage of 
this pattern is an analysis of corrupt dynamic memory blocks (process heap, kernel pool) 
where continuity of regular data across block boundary points to possible Shared Buffer 
Overwrite (Volume 5, page 120). 
 
 

Translated Exception    107 
Translated Exception 
Runtime software exceptions (such as C++ Exceptions, Volume 3, page 84) can be 
translated by Custom Exception Handlers (Volume 1, page 471) into other exceptions by 
changing exception data. This is different from Nested Exceptions (Volume 2, page 305) 
where another exception is thrown. One example of such possible translation we 
recently encountered when looked at raw stack data (!teb -> dps) having signs of 
Hidden Exceptions (multiple RaiseException calls, Volume 1, page 271) and also CLR 
Execution Residue (valid return addresses of clr module, Volume 2, page 239). In 
addition to final Invalid Handle exception (Volume 2, page 269) and one hidden access 
violation there were many exception codes c0000027. Google search pointed to the 
article about skipped C++ destructors16 that prompted me to introduce this pattern. 
 
 
                                                                 
16 http://www.codeproject.com/Articles/46294/When-a-C-destructor-did-not-run-Part-2 

108    PART 2: Crash Dump Analysis Patterns 
Blocked DPC 
In this pattern, we have blocked per-processor Deferred Procedure Call17 queues 
because of threads running on processors with IRQL > DISPATCH_LEVEL. For example, 
on the processor 11 (0×0b): 
11: kd> !dpcs 
CPU Type KDPC Function 
3: Normal : 0x8accacec 0xf710567a DriverA 
5: Normal : 0x89f449e4 0xf595b83a DriverB 
7: Normal : 0x8a63664c 0xf59e3f04 USBPORT!USBPORT_IsrDpc 
11: Normal : 0x8acb2cec 0xf710567a DriverA 
11: Normal : 0x8b5e955c 0xf73484e6 ACPI!ACPIInterruptServiceRoutineDPC 
11: kd> !thread 
THREAD 89806428  Cid 0934.0944  Teb: 7ffdb000 Win32Thread: bc17dda0 
RUNNING on processor b 
Not impersonating 
DeviceMap                 e1002258 
Owning Process            89972290       Image:         ApplicationA.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      2863772        Ticks: 368905 (0:01:36:04.140) 
Context Switch Count      145085                 LargeStack 
UserTime                  00:00:00.015 
KernelTime                01:36:04.203 
Win32 Start Address MSVCR90!_threadstartex (0×7854345e) 
Start Address kernel32!BaseThreadStartThunk (0×77e617ec) 
Stack Init f3f63000 Current f3f62c4c Base f3f63000 Limit f3f5f000 Call 0 
Priority 10 BasePriority 10 PriorityDecrement 0 
ChildEBP RetAddr  Args to Child 
f777d3b0 f3f62d28 00000010 00000000 00000000 
hal!KeAcquireInStackQueuedSpinLockRaiseToSynch+0×36 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
f777d3b4 00000000 00000000 00000000 00000000 0xf3f62d28 
 
 
                                                                 
17 http://en.wikipedia.org/wiki/Deferred_Procedure_Call 

Late Crash Dump    109 
Late Crash Dump 
This is a binary opposition counterpart to Early Crash Dump pattern (Volume 1, page 
466). It is usually saved when patterns representing a problem such as an exception 
thread stack trace are already gone. Most often we see one thread with process 
termination functions (Special Stack Trace pattern, Volume 1, page 479): 
0:000> ~*k 
ChildEBP RetAddr 
0037fcf0 770bd55c ntdll!ZwTerminateProcess+0x12 
0037fd0c 750f79f4 ntdll!RtlExitUserProcess+0x85 
0037fdf8 750f339a kernel32!ExitProcessStub+0x12 
0037fe04 770a9ef2 kernel32!BaseThreadInitThunk+0xe 
0037fe44 770a9ec5 ntdll!__RtlUserThreadStart+0x70 
0037fe5c 00000000 ntdll!_RtlUserThreadStart+0x1b 
0:000> ~*k 
ChildEBP RetAddr 
0032faf0 77a9d55c ntdll!ZwTerminateProcess+0x12 
0032fb0c 775579f4 ntdll!RtlExitUserProcess+0x85 
0032fb20 74ac1720 kernel32!ExitProcessStub+0x12 
0032fb28 74ac1a03 msvcr80!__crtExitProcess+0x14 
0032fb64 74ac1a4b msvcr80!_cinit+0x101 
0032fb74 01339bb3 msvcr80!exit+0xd 
0032fbf8 7755339a App!__tmainCRTStartup+0x155 
0032fc04 77a89ef2 kernel32!BaseThreadInitThunk+0xe 
0032fc44 77a89ec5 ntdll!__RtlUserThreadStart+0x70 
0032fc5c 00000000 ntdll!_RtlUserThreadStart+0x1b 
However, sometimes it is possible to see some Execution Residue (Volume 2, 
page 239) left on a raw stack such as Hidden Exceptions (Volume 1, page 239), Module 
Hints (Volume 6, page 92), error codes and Handled Exceptions (Volume 6, page 141) 
that might shed light on possible problem causes. 
Another variant of this pattern is when a memory dump is saved after a problem 
message box is dismissed or potentially disastrous exceptions such as access violations 
are handled until the fault in exception handling mechanism or severe corruption 
resulted in unresponsive process or system (hang). 
 
 

110    PART 2: Crash Dump Analysis Patterns 
Blocked Thread (Timeout) 
This is a special variant of Blocked Thread pattern (Volume 2, page 184) where we have 
a timeout value: a thread is temporarily blocked. For example, this Main Thread 
(Volume 1, page 437) is blocked while waiting for beep sound to finish after a minute: 
0:000> kvL 
ChildEBP RetAddr Args to Child 
0291f354 7c90d21a 7c8023f1 00000001 0291f388 ntdll!KiFastSystemCallRet 
0291f358 7c8023f1 00000001 0291f388 7c90d27e ntdll!NtDelayExecution+0xc 
0291f3b0 7c837beb 0000ea60 00000001 00000004 kernel32!SleepEx+0×61 
0291f404 004952a2 00000370 0000ea60 004d6ae2 kernel32!Beep+0×1b3 
0291f410 004d6ae2 00000370 0000ea60 004d6ed4 Application!DoBeep+0×16 
[...] 
0291ffec 00000000 0045aad0 00e470a0 00000000 kernel32!BaseThreadStart+0×37 
0:000> ? ea60/0n1000 
Evaluate expression: 60 = 0000003c 
 
 

Punctuated Memory Leak    111 
Punctuated Memory Leak 
An example of this pattern is somewhat similar to a large block allocation leak for 
process heap (please see a modeling example in Volume 5, page 315). An application 
has some functionality and after each command its committed memory was increasing 
by 50 - 60 Mb. 3 process memory dumps were taken with one before failures and then 
after each failure: 
// Before failures 
0:000> !address -summary 
--- Usage Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
Free                                    267          76c50000 (   1.856 Gb)           92.79% 
<unclassified>                          270           4d6f000 (  77.434 Mb)  52.45%    3.78% 
Image                                   620           31bf000 (  49.746 Mb)  33.70%    2.43% 
Stack                                    60           1400000 (  20.000 Mb)  13.55%    0.98% 
ActivationContextData                    48             35000 ( 212.000 kb)   0.14%    0.01% 
NlsTables                                 1             23000 ( 140.000 kb)   0.09%    0.01% 
TEB                                      20             14000 (  80.000 kb)   0.05%    0.00% 
CsrSharedMemory                           1              5000 (  20.000 kb)   0.01%    0.00% 
PEB                                       1              1000 (   4.000 kb)   0.00%    0.00% 
--- Type Summary (for busy) ------ RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_PRIVATE                             296           3bca000 (  59.789 Mb)  40.50%    2.92% 
MEM_IMAGE                               647           340c000 (  52.047 Mb)  35.26%    2.54% 
MEM_MAPPED                               78           23ca000 (  35.789 Mb)  24.24%    1.75% 
--- State Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_FREE                                267          76c50000 (   1.856 Gb)           92.79% 
MEM_RESERVE                             125           5006000 (  80.023 Mb)  54.21%    3.91% 
MEM_COMMIT                              896           439a000 (  67.602 Mb)  45.79%    3.30% 
--- Protect Summary (for commit) - RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
PAGE_EXECUTE_READ                       125           1f2c000 (  31.172 Mb)  21.12%    1.52% 
PAGE_READONLY                           363           1ee5000 (  30.895 Mb)  20.93%    1.51% 
PAGE_READWRITE                          309            4c2000 (   4.758 Mb)   3.22%    0.23% 
PAGE_WRITECOPY                           43             6a000 ( 424.000 kb)   0.28%    0.02% 
PAGE_READWRITE|PAGE_GUARD                40             4b000 ( 300.000 kb)   0.20%    0.01% 
PAGE_EXECUTE_READWRITE                   15             11000 (  68.000 kb)   0.04%    0.00% 
PAGE_EXECUTE                              1              1000 (   4.000 kb)   0.00%    0.00% 
--- Largest Region by Usage ----------- Base Address -------- Region Size ---------- 
Free                                         6130000          5fb70000 (   1.496 Gb) 
<unclassified>                                abf000           13d1000 (  19.816 Mb) 
Image                                       75141000            879000 (   8.473 Mb) 
Stack                                        3290000             fd000 (1012.000 kb) 
ActivationContextData                          50000              4000 (  16.000 kb) 
NlsTables                                   7efb0000             23000 ( 140.000 kb) 
TEB                                         7ef6f000              1000 (   4.000 kb) 
CsrSharedMemory                             7efe0000              5000 (  20.000 kb) 
PEB                                         7efde000              1000 (   4.000 kb) 
 
 

112    PART 2: Crash Dump Analysis Patterns 
// After the 1st failure 
0:000> !address -summary 
--- Usage Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
Free                                    267          7388c000 (   1.805 Gb)           90.26% 
<unclassified>                          272           8133000 ( 129.199 Mb)  64.80%    6.31% 
Image                                   614           31bf000 (  49.746 Mb)  24.95%    2.43% 
Stack                                    60           1400000 (  20.000 Mb)  10.03%    0.98% 
ActivationContextData                    48             35000 ( 212.000 kb)   0.10%    0.01% 
NlsTables                                 1             23000 ( 140.000 kb)   0.07%    0.01% 
TEB                                      20             14000 (  80.000 kb)   0.04%    0.00% 
CsrSharedMemory                           1              5000 (  20.000 kb)   0.01%    0.00% 
PEB                                       1              1000 (   4.000 kb)   0.00%    0.00% 
--- Type Summary (for busy) ------ RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_PRIVATE                             297           6f8e000 ( 111.555 Mb)  55.95%    5.45% 
MEM_IMAGE                               642           340c000 (  52.047 Mb)  26.10%    2.54% 
MEM_MAPPED                               78           23ca000 (  35.789 Mb)  17.95%    1.75% 
--- State Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_FREE                                267          7388c000 (   1.805 Gb)           90.26% 
MEM_COMMIT                              892           775e000 ( 119.367 Mb)  59.87%    5.83% 
MEM_RESERVE                             125           5006000 (  80.023 Mb)  40.13%    3.91% 
--- Protect Summary (for commit) - RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
PAGE_READWRITE                          314           38a3000 (  56.637 Mb)  28.40%    2.77% 
PAGE_EXECUTE_READ                       125           1f2c000 (  31.172 Mb)  15.63%    1.52% 
PAGE_READONLY                           363           1ee5000 (  30.895 Mb)  15.49%    1.51% 
PAGE_WRITECOPY                           34             4d000 ( 308.000 kb)   0.15%    0.01% 
PAGE_READWRITE|PAGE_GUARD                40             4b000 ( 300.000 kb)   0.15%    0.01% 
PAGE_EXECUTE_READWRITE                   15             11000 (  68.000 kb)   0.03%    0.00% 
PAGE_EXECUTE                              1              1000 (   4.000 kb)   0.00%    0.00% 
--- Largest Region by Usage ----------- Base Address -------- Region Size ---------- 
Free                                         94f4000          5c7ac000 (   1.445 Gb) 
<unclassified>                               6130000           33c4000 (  51.766 Mb) 
Image                                       75141000            879000 (   8.473 Mb) 
Stack                                        3290000             fd000 (1012.000 kb) 
ActivationContextData                          50000              4000 (  16.000 kb) 
NlsTables                                   7efb0000             23000 ( 140.000 kb) 
TEB                                         7ef6f000              1000 (   4.000 kb) 
CsrSharedMemory                             7efe0000              5000 (  20.000 kb) 
PEB                                         7efde000              1000 (   4.000 kb) 
0:000> !address -f:VAR 
BaseAddr EndAddr+1 RgnSize     Type       State                 Protect             Usage 
------------------------------------------------------------------------------------------- 
[...] 
5e82000  5f70000    ee000 MEM_PRIVATE MEM_RESERVE                                    <unclassified> 
6130000  94f4000  33c4000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     <unclassified> 
74220000 74221000    1000 MEM_IMAGE   MEM_COMMIT  PAGE_READONLY                      <unclassified> 
[...] 
0:000> ? 33c4000/0n1024 
Evaluate expression: 53008 = 0000cf10 
 
 

Punctuated Memory Leak    113 
// After the 2nd failure 
0:000> !address -summary 
--- Usage Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
Free                                    268          704c8000 (   1.755 Gb)           87.74% 
<unclassified>                          273           b4f7000 ( 180.965 Mb)  72.05%    8.84% 
Image                                   614           31bf000 (  49.746 Mb)  19.81%    2.43% 
Stack                                    60           1400000 (  20.000 Mb)   7.96%    0.98% 
ActivationContextData                    48             35000 ( 212.000 kb)   0.08%    0.01% 
NlsTables                                 1             23000 ( 140.000 kb)   0.05%    0.01% 
TEB                                      20             14000 (  80.000 kb)   0.03%    0.00% 
CsrSharedMemory                           1              5000 (  20.000 kb)   0.01%    0.00% 
PEB                                       1              1000 (   4.000 kb)   0.00%    0.00% 
--- Type Summary (for busy) ------ RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_PRIVATE                             298           a352000 ( 163.320 Mb)  65.03%    7.97% 
MEM_IMAGE                               642           340c000 (  52.047 Mb)  20.72%    2.54% 
MEM_MAPPED                               78           23ca000 (  35.789 Mb)  14.25%    1.75% 
--- State Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_FREE                                268          704c8000 (   1.755 Gb)           87.74% 
MEM_COMMIT                              893           ab22000 ( 171.133 Mb)  68.14%    8.36% 
MEM_RESERVE                             125           5006000 (  80.023 Mb)  31.86%    3.91% 
--- Protect Summary (for commit) - RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
PAGE_READWRITE                          315           6c67000 ( 108.402 Mb)  43.16%    5.29% 
PAGE_EXECUTE_READ                       125           1f2c000 (  31.172 Mb)  12.41%    1.52% 
PAGE_READONLY                           363           1ee5000 (  30.895 Mb)  12.30%    1.51% 
PAGE_WRITECOPY                           34             4d000 ( 308.000 kb)   0.12%    0.01% 
PAGE_READWRITE|PAGE_GUARD                40             4b000 ( 300.000 kb)   0.12%    0.01% 
PAGE_EXECUTE_READWRITE                   15             11000 (  68.000 kb)   0.03%    0.00% 
PAGE_EXECUTE                              1              1000 (   4.000 kb)   0.00%    0.00% 
--- Largest Region by Usage ----------- Base Address -------- Region Size ---------- 
Free                                         c8c4000          593dc000 (   1.394 Gb) 
<unclassified>                               6130000           33c4000 (  51.766 Mb) 
Image                                       75141000            879000 (   8.473 Mb) 
Stack                                        3290000             fd000 (1012.000 kb) 
ActivationContextData                          50000              4000 (  16.000 kb) 
NlsTables                                   7efb0000             23000 ( 140.000 kb) 
TEB                                         7ef6f000              1000 (   4.000 kb) 
CsrSharedMemory                             7efe0000              5000 (  20.000 kb) 
PEB                                         7efde000              1000 (   4.000 kb) 
0:000> !address -f:VAR 
BaseAddr EndAddr+1 RgnSize     Type       State                 Protect             Usage 
------------------------------------------------------------------------------------------- 
5e82000  5f70000    ee000 MEM_PRIVATE MEM_RESERVE                                    <unclassified> 
6130000  94f4000  33c4000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     <unclassified> 
9500000  c8c4000  33c4000 MEM_PRIVATE MEM_COMMIT  PAGE_READWRITE                     <unclassified> 
74220000 74221000     1000 
MEM_IMAGE   MEM_COMMIT  PAGE_READONLY                      <unclassified> 
[...] 
The name of this pattern comes from the process of discrete large memory 
allocations that happen after specific actions or events. Between them, there are no 
visible or substantial increases in memory usage. 
 
 

114    PART 2: Crash Dump Analysis Patterns 
Insufficient Memory (Reserved Virtual Memory) 
Allocated dynamic memory such as process heap can remain reserved after 
deallocation, and its virtual memory region might become unavailable for usage. One 
example of this we encountered while debugging a .NET service. During peak usage, it 
reported various out-of-memory events but its managed heap was healthy and didn’t 
consume much. However, its process heap statistics showed a large reserved heap 
segment missing in a similar memory dump from a development environment. 
Remaining allocated entries in that heap segment contained specific Module Hint 
(Volume 6, page 92) that allowed us to suggest removing a 3rd-party product from a 
production environment. 
In order to provide a proof of that possible scenario of reserved heap regions we 
created a special modeling application: 
int _tmain(int argc, _TCHAR* argv[]) 
{ 
    static char *pAlloc[1000000]; 
    for (int i = 0; i < 1000000; i++) 
    { 
        pAlloc[i] = (char *)malloc (1000); 
    } 
    getc(stdin); 
    for (int i = 0; i < 1000000; i++) 
    { 
        free(pAlloc[i]); 
    } 
    getc(stdin); 
    return 0; 
} 
Here’s the debugging log: 
0:001> .symfix c:\mss 
0:001> .reload 
Reloading current modules 
..... 
 
 

Insufficient Memory (Reserved Virtual Memory)    115 
After allocation: 
0:001> !heap -s 
LFH Key : 0x156356e0 
Termination on corruption : ENABLED 
Heap      Flags   Reserv  Commit  Virt    Free   List  UCR Virt Lock Fast 
(k)       (k)     (k)     (k)     length  blocks cont. heap 
------------------------------------------------------------------------- 
00520000 00000002 1024    112     1024    8      1     1    0   0    LFH 
007e0000 00001002 1019328 1012444 1019328 131    68    67   0   0    LFH 
------------------------------------------------------------------------- 
0:001> g 
(1588.14b0): Break instruction exception - code 80000003 (first chance) 
eax=7efda000 ebx=00000000 ecx=00000000 edx=770ff85a esi=00000000 
edi=00000000 
eip=7707000c esp=00f0f7e4 ebp=00f0f810 iopl=0 nv up ei pl zr na pe nc 
cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00000246 
ntdll!DbgBreakPoint: 
7707000c cc int 3 
After deallocation: 
0:001> !heap -s 
LFH Key : 0x156356e0 
Termination on corruption : ENABLED 
Heap     Flags    Reserv  Commit Virt    Free   List  UCR  Virt Lock Fast 
(k)      (k)      (k)     (k)    length  blocks cont. heap 
------------------------------------------------------------------------- 
00520000 00000002 1024    112    1024    8      1     1    0 0 LFH 
007e0000 00001002 1019328 73040  1019328 71365  419   165  0 0 LFH 
External fragmentation 97 % (419 free blocks) 
Virtual address fragmentation 92 % (165 uncommited ranges) 
------------------------------------------------------------------------- 
0:001> !address -summary 
--- Usage Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
Free                               26              3fbe7000 (1019.902 Mb)           49.80% 
<unclassified>                     752             3f8ec000 (1016.922 Mb)   98.92%  49.66% 
Image                              41              76b000 ( 7.418 Mb)       0.72%   0.36% 
Stack                              6               200000 ( 2.000 Mb)       0.19%   0.10% 
MemoryMappedFile                   8               1af000 ( 1.684 Mb)       0.16%   0.08% 
TEB                                2               2000 ( 8.000 kb)         0.00%   0.00% 
PEB                                1               1000 ( 4.000 kb)         0.00%   0.00% 
--- Type Summary (for busy) ------ RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_PRIVATE                        734             3f8a2000 (1016.633 Mb)   98.89%  49.64% 
MEM_IMAGE                          68              9b8000   ( 9.719 Mb)     0.95%   0.47% 
MEM_MAPPED                         8               1af000   ( 1.684 Mb)     0.16%   0.08% 
--- State Summary ---------------- RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
MEM_FREE                           26              3fbe7000 (1019.902 Mb)           49.80% 
MEM_RESERVE                        374             3f6e8000 (1014.906 Mb)   98.72%  49.56% 
MEM_COMMIT                         436             d21000 ( 13.129 Mb)      1.28%   0.64% 

116    PART 2: Crash Dump Analysis Patterns 
--- Protect Summary (for commit) - RgnCount ----------- Total Size -------- %ofBusy %ofTotal 
PAGE_READWRITE                     383             725000 ( 7.145 Mb)       0.69%   0.35% 
PAGE_EXECUTE_READ                  10              414000 ( 4.078 Mb)       0.40%   0.20% 
PAGE_READONLY                      29              1cd000 ( 1.801 Mb)       0.18%   0.09% 
PAGE_WRITECOPY                     10              12000  ( 72.000 kb)      0.01%   0.00% 
PAGE_READWRITE|PAGE_GUARD          4               9000 ( 36.000 kb)        0.00%   0.00% 
--- Largest Region by Usage ----------- Base Address -------- Region Size ---------- 
Free                                    3f0c0000              33050000 ( 816.313 Mb) 
<unclassified>                          158a1000              fcf000 ( 15.809 Mb) 
Image                                   1083000               3d1000 ( 3.816 Mb) 
Stack                                   200000                fd000 (1012.000 kb) 
MemoryMappedFile                        7efe5000              fb000 (1004.000 kb) 
TEB                                     7efda000              1000 ( 4.000 kb) 
PEB                                     7efde000              1000 ( 4.000 kb) 
We see that free memory available for allocation was only 816 Mb. 
 
 

Coincidental Error Code    117 
Coincidental Error Code 
Address space-wide search for errors and status codes (page 29) may show coincidental 
error codes: 
0:000> !heap -x -v c0000005 
Search VM for address range c0000005 - c0000005 : 028690b8 (c0000005), 
[...] 
0:000> dd 028690b8 l1 
028690b8 c0000005 
In such cases we need to check whether the addresses belong to volatile regions 
such as stack because it is possible to have such values as legitimate code and image 
data: 
0:000> !address 028690b8 
Usage:   
 
Image 
Allocation Base:  
02700000 
Base Address:   
02869000 
End Address:   
02874000 
Region Size:   
0000b000 
Type:   
 
01000000 MEM_IMAGE 
State:   
 
00001000 MEM_COMMIT 
Protect:  
 
00000002 PAGE_READONLY 
More info: lmv m ModuleA 
More info: !lmi ModuleA 
More info: ln 0×28690b8 
0:000> u 028690b8 
ModuleA!ComputeB: 
028690b8 050000c000 add eax,0C00000h 
[...] 
Another example (x64): 
0:000> !heap -x -v c0000005 
Search VM for address range 00000000c0000005 - 00000000c0000005 : 
7feff63ab60 (c0000005), 
 
 

118    PART 2: Crash Dump Analysis Patterns 
0:000> !address 7feff63ab60 
Usage: Image 
Allocation Base: 000007fe`ff460000 
Base Address:    000007fe`ff635000 
End Address:     000007fe`ff63c000 
Region Size:     00000000`00007000 
Type:            01000000 MEM_IMAGE 
State:           00001000 MEM_COMMIT 
Protect:         00000004 PAGE_READWRITE 
More info: lmv m ole32 
More info: !lmi ole32 
More info: ln 0×7feff63ab60 
0:000> dp 7feff63ab60 
000007fe`ff63ab60 00000000`c0000005 c0000194`00000001 
000007fe`ff63ab70 00000001`00000000 00000000`c00000aa 
000007fe`ff63ab80 80000002`00000001 00000001`00000000 
000007fe`ff63ab90 00000000`c0000096 c000001d`00000001 
000007fe`ff63aba0 00000001`00000000 00000000`80000003 
000007fe`ff63abb0 c00000fd`00000001 00000001`00000000 
000007fe`ff63abc0 00000000`c0000235 c0000006`00000001 
000007fe`ff63abd0 00000001`00000000 00000000`c0000420 
In the latter case, the data structure suggests a table of errors: 
0:000> ln 7feff63ab60 
(000007fe`ff63ab60) ole32!gReportedExceptions 
 
 

Stored Exception    119 
Stored Exception 
This pattern is mostly useful when an exception thread is not present in the dump like in 
this rare example: 
ERROR: Unable to find system thread 9B7E 
ERROR: The thread being debugged has either exited or cannot be accessed 
ERROR: Many commands will not work properly 
This dump file has an exception of interest stored in it. 
The stored exception information can be accessed via .ecxr. 
ERROR: Exception C0000005 occurred on unknown thread 9B7E 
(95f4.9b7e): Access violation - code c0000005 (first/second chance not 
available) 
.ecxr command will not work here, but the exception record is available via .exr 
command: 
0:???> .exr -1 
ExceptionAddress: 08a9ae18 (DllB.dll+0x001cae18) 
ExceptionCode:    c0000005 (Access violation) 
ExceptionFlags:   00000001 
NumberParameters: 1 
Parameter[0]:     00000008 
 
 

120    PART 2: Crash Dump Analysis Patterns 
Activity Resonance 
This pattern is observed when two products from different vendors compete in some 
functional domain such malware detection. In the example below ApplicationA and AV-
DriverA modules belong to Vendor A and AV-B module belongs to Vendor B. Both 
threads are Spiking Threads (Volume 1, page 305) blocking all other activity in the 
system: 
0: kd> !running 
System Processors: (0000000000000003) 
Idle Processors: (0000000000000000) (0000000000000000) (0000000000000000) 
(0000000000000000) 
Prcbs             Current           Next 
0    fffff80001845e80  fffffa8004350060                    ................ 
1    fffff880009c4180  fffffa80028e7060                    ................ 
0: kd> !thread fffffa8004350060 3f 
THREAD fffffa8004350060  Cid 14424.14b34  Teb: 000000007efdb000 Win32Thread: 
fffff900c1d32c30 RUNNING on processor 0 
Not impersonating 
DeviceMap                 fffff8a00148fe80 
Owning Process            fffffa8003d6cb30       Image:         ApplicationA.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      10568630       Ticks: 0 
Context Switch Count      345                 LargeStack 
UserTime                  00:02:21.360 
KernelTime                01:09:32.130 
Win32 Start Address ApplicationA!mainCRTStartup (0×0000000000404c1b) 
Stack Init fffff88006c71db0 Current fffff88006c71670 
Base fffff88006c72000 Limit fffff88006c6a000 Call 0 
Priority 9 BasePriority 8 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 
5 
Child-SP          RetAddr           Call Site 
fffff880`06c70ec0 fffff880`0197d53c AVDriverA+0×15d69 
fffff880`06c70f10 fffff880`01988556 AVDriverA+0×1453c 
fffff880`06c70fd0 fffff880`019886a8 AVDriverA+0×1f556 
fffff880`06c71000 fffff800`0198ebfd AVDriverA+0×1f6a8 
fffff880`06c71060 fffff800`019bf4f2 nt! ?? ::NNGAKEGL::`string’+0×2a6fd 
fffff880`06c711e0 fffff800`019c3385 nt!PspCreateThread+0×246 
fffff880`06c71460 fffff800`016d28d3 nt!NtCreateThreadEx+0×25d 
fffff880`06c71bb0 00000000`76e61d9a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`06c71c20) 
00000000`0008e178 00000000`74990411 ntdll!ZwCreateThreadEx+0xa 
00000000`0008e180 00000000`7497cf87 wow64!whNtCreateThreadEx+0×815 
00000000`0008e350 00000000`748c2776 wow64!Wow64SystemServiceEx+0xd7 
00000000`0008ec10 00000000`7497d07e wow64cpu!TurboDispatchJumpAddressEnd+0×2d 
00000000`0008ecd0 00000000`7497c549 wow64!RunCpuSimulation+0xa 
00000000`0008ed20 00000000`76e54956 wow64!Wow64LdrpInitialize+0×429 
00000000`0008f270 00000000`76e51a17 ntdll!LdrpInitializeProcess+0×17e4 
00000000`0008f760 00000000`76e3c32e ntdll! ?? ::FNODOBFM::`string’+0×29220 
00000000`0008f7d0 00000000`00000000 ntdll!LdrInitializeThunk+0xe 

Activity Resonance    121 
0: kd> !thread fffffa80028e7060 3f 
THREAD fffffa80028e7060  Cid 0dc4.0e5c  Teb: 000000007efa4000 Win32Thread: 
0000000000000000 RUNNING on processor 1 
Not impersonating 
DeviceMap                 fffff8a000008b30 
Owning Process            fffffa8002817060       Image:         AV-B.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      10568617       Ticks: 13 (0:00:00:00.203) 
Context Switch Count      1763138 
UserTime                  00:04:26.765 
KernelTime                03:09:31.140 
Win32 Start Address AV-B (0×00000000004289f2) 
Stack Init fffff88003b88db0 Current fffff88003b88900 
Base fffff88003b89000 Limit fffff88003b83000 Call 0 
Priority 15 BasePriority 15 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 
PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff880`03b88660 fffff800`019919a9 nt!ObReferenceObjectSafe+0xf 
fffff880`03b88690 fffff800`01991201 nt!PsGetNextProcess+0×81 
fffff880`03b886e0 fffff800`019dcef6 nt!ExpGetProcessInformation+0×774 
fffff880`03b88830 fffff800`019dd949 nt!ExpQuerySystemInformation+0xfb4 
fffff880`03b88be0 fffff800`016d28d3 nt!NtQuerySystemInformation+0×4d 
fffff880`03b88c20 00000000`76e6167a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`03b88c20) 
00000000`0118e708 00000000`74987da7 ntdll!NtQuerySystemInformation+0xa 
00000000`0118e710 00000000`74988636 wow64!whNT32QuerySystemProcessInformationEx+0×93 
00000000`0118e760 00000000`7498a0e9 
wow64!whNtQuerySystemInformation_SpecialQueryCase+0×466 
00000000`0118e800 00000000`7497cf87 wow64!whNtQuerySystemInformation+0xf1 
00000000`0118e840 00000000`748c2776 wow64!Wow64SystemServiceEx+0xd7 
00000000`0118f100 00000000`7497d07e wow64cpu!TurboDispatchJumpAddressEnd+0×2d 
00000000`0118f1c0 00000000`7497c549 wow64!RunCpuSimulation+0xa 
00000000`0118f210 00000000`76e8e707 wow64!Wow64LdrpInitialize+0×429 
00000000`0118f760 00000000`76e3c32e ntdll! ?? ::FNODOBFM::`string’+0×29364 
00000000`0118f7d0 00000000`00000000 ntdll!LdrInitializeThunk+0xe 
 
 

122    PART 2: Crash Dump Analysis Patterns 
Value Adding Process 
This is a frequently observed pattern in terminal services environments when we see 
one or several process names listed in each session but not necessarily required. They 
are usually running to provide some user experience enhancements. In such cases if 
observed functional problems correspond to the purpose of running additional 
processes we might want to eliminate them for testing and troubleshooting purposes. 
0: kd> !sprocess 12 
Dumping Session 12 
_MM_SESSION_SPACE fffff8800e5d5000 
_MMSESSION fffff8800e5d5b40 
PROCESS fffffa8008d50b30 
SessionId: 12 Cid: 0b04 Peb: 7fffffdc000 ParentCid: 1478 
DirBase: 6bb77000 ObjectTable: fffff8a003f280b0 HandleCount: 158. 
Image: csrss.exe 
PROCESS fffffa80030c7060 
SessionId: 12 Cid: 1a48 Peb: 7fffffd8000 ParentCid: 1478 
DirBase: 0a33c000 ObjectTable: fffff8a003c46c00 HandleCount: 179. 
Image: winlogon.exe 
PROCESS fffffa8008250b30 
SessionId: 12 Cid: 18c8 Peb: 7fffffdf000 ParentCid: 1a48 
DirBase: 0350d000 ObjectTable: fffff8a0025b6840 HandleCount: 226. 
Image: LogonUI.exe 
PROCESS fffffa8008b00530 
SessionId: 12 Cid: 1508 Peb: 7fffffdf000 ParentCid: 02f0 
DirBase: 02f65000 ObjectTable: fffff8a003b7e530 HandleCount: 197. 
Image: ExcitingFeatureX.exe 
[...] 
 
 

Memory Leak (I/O Completion Packets)    123 
Memory Leak (I/O Completion Packets) 
This is a specialization of Insufficient Memory (kernel pool) pattern (Volume 1, page 
441). The currently unique diagnostics this pattern provides in comparison to other 
kernel pool tags is that the pool allocation entries show the leaking process: 
0: kd> !poolused 3 
Sorting by NonPaged Pool Consumed 
Pool Used: 
NonPaged                    Paged 
Tag    Allocs    Frees     Diff     Used   Allocs    Frees     Diff     Used 
Icp   1294074    42875  1251199 96642976        0        0        0        0 I/O completion packets 
queue on a completion ports 
[...] 
0: kd> !poolfind Icp 
Scanning large pool allocation table for Tag: Icp (fffffa8013e00000 : fffffa8014100000) 
*fffffa800e188260 size: 50 previous size: 40 (Allocated) Icp Process: fffffa800899dc40 
*fffffa800e1882e0 size: 50 previous size: 30 (Allocated) Icp Process: fffffa800899dc40 
*fffffa800e188330 size: 50 previous size: 50 (Allocated) Icp Process: fffffa800899dc40 
*fffffa800e188380 size: 50 previous size: 50 (Allocated) Icp Process: fffffa800899dc40 
*fffffa800e1883d0 size: 50 previous size: 50 (Allocated) Icp Process: fffffa800899dc40 
*fffffa800e188420 size: 50 previous size: 50 (Allocated) Icp Process: fffffa800899dc40 
*fffffa800e188470 size: 50 previous size: 50 (Allocated) Icp Process: fffffa800899dc40 
*fffffa800e1884c0 size: 50 previous size: 50 (Allocated) Icp Process: fffffa800899dc40 
0: kd> !process fffffa800899dc40 1 
PROCESS fffffa800899dc40 
SessionId: 0  Cid: 43a4    Peb: 7efdf000  ParentCid: 0412 
DirBase: 09d6b000  ObjectTable: fffff8a0046c8c10  HandleCount: 1068. 
Image: ServiceA.exe 
[...] 
 
 
 

124    PART 2: Crash Dump Analysis Patterns 
No Current Thread 
Recently I observed a few occurrences of rare No Current Thread pattern in a large set 
of process memory dumps: 
0:???> k 
WARNING: The debugger does not have a current process or thread 
WARNING: Many commands will not work 
^ Illegal thread error in ‘k’ 
0:???> ~ 
WARNING: The debugger does not have a current process or thread 
WARNING: Many commands will not work 
0 Id: 95f4.6780 Suspend: 1 Teb: 7efdd000 Unfrozen 
Setting a current thread helps: 
0:???> ~0s 
WARNING: The debugger does not have a current process or thread 
WARNING: Many commands will not work 
eax=037d0010 ebx=0002bda0 ecx=03b1a010 edx=00000007 esi=037d0010 
edi=03b069fc 
eip=0397939f esp=0018fd98 ebp=0018fdd8 iopl=0 nv up ei pl nz na po nc 
cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00200202 
DllA+0×939f: 
0397939f 8b10 mov edx,dword ptr [eax] ds:002b:037d0010=03b1a010 
0:000> k 
ChildEBP RetAddr 
WARNING: Stack unwind information not available. Following frames may be 
wrong. 
0018fdd8 03975257 DllA+0x939f 
0018fdf8 03975577 DllA+0x5257 
0018fe58 772bb9a0 DllA+0x5577 
0018fe78 772d9b96 ntdll!LdrpCallInitRoutine+0x14 
0018ff1c 772d9a38 ntdll!LdrShutdownProcess+0x1aa 
0018ff30 752279f4 ntdll!RtlExitUserProcess+0x74 
0018ff44 0040625d kernel32!ExitProcessStub+0x12 
0018ff5c 012528e5 Application+0x625d 
0018ff88 7522339a Application!foo+0xdc88f1 
0018ff94 772bbf42 kernel32!BaseThreadInitThunk+0xe 
0018ffd4 772bbf15 ntdll!__RtlUserThreadStart+0x70 
0018ffec 00000000 ntdll!_RtlUserThreadStart+0x1b 
However, EIP of the new current thread doesn’t point to any access violation, and 
the dereferenced address is valid: 
 
 

No Current Thread    125 
0:000> !address 037d0010 
Usage:                  <unclassified> 
Allocation Base:        037d0000 
Base Address:           037d0000 
End Address:            038dd000 
Region Size:            0010d000 
Type:                   00020000 MEM_PRIVATE 
State:                  00001000 MEM_COMMIT 
Protect:                00000004 PAGE_READWRITE 
Also, if we inspect the raw stack data, we won’t find any Hidden Exceptions 
(Volume 1, page 271) there. So we conclude that the missing thread was exceptional. 
Indeed, there is a saved exception context in the process memory dump: 
0:000> .exr -1 
ExceptionAddress: 08a9ae18 (<Unloaded_DllB.dll>+0x001cae18) 
ExceptionCode: c0000005 (Access violation) 
ExceptionFlags: 00000001 
NumberParameters: 1 
Parameter[0]: 00000008 
 
 

126    PART 2: Crash Dump Analysis Patterns 
Unloaded Module 
One of the frequent problems is an access violation at an address that belongs to an 
unloaded module. Here’s an example that recently happened on our machine during an 
auto-update of the popular software package, so we immediately attached a debugger 
after seeing a WER dialog box: 
0:000> ~*k 
. 0 Id: bc8.bcc Suspend: 1 Teb: 7efdd000 Unfrozen 
ChildEBP RetAddr 
0035f1c4 771a0bdd ntdll!ZwWaitForMultipleObjects+0x15 
0035f260 75771a2c KERNELBASE!WaitForMultipleObjectsEx+0x100 
0035f2a8 75774208 kernel32!WaitForMultipleObjectsExImplementation+0xe0 
0035f2c4 757980a4 kernel32!WaitForMultipleObjects+0x18 
0035f330 75797f63 kernel32!WerpReportFaultInternal+0x186 
0035f344 75797858 kernel32!WerpReportFault+0x70 
0035f354 757977d7 kernel32!BasepReportFault+0x20 
0035f3e0 77ec74df kernel32!UnhandledExceptionFilter+0x1af 
0035f3e8 77ec73bc ntdll!__RtlUserThreadStart+0x62 
0035f3fc 77ec7261 ntdll!_EH4_CallFilterFunc+0x12 
0035f424 77eab459 ntdll!_except_handler4+0x8e 
0035f448 77eab42b ntdll!ExecuteHandler2+0x26 
0035f46c 77eab3ce ntdll!ExecuteHandler+0x24 
0035f4f8 77e60133 ntdll!RtlDispatchException+0x127 
0035f4f8 73eb2200 ntdll!KiUserExceptionDispatcher+0xf 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
0035f844 76e462fa <Unloaded_fpb.tmp>+0×12200 
0035f870 76e46d3a USER32!InternalCallWinProc+0×23 
0035f8e8 76e4965e USER32!UserCallWinProcCheckWow+0×109 
0035f92c 76e496c5 USER32!SendMessageWorker+0×581 
0035f950 7269c05c USER32!SendMessageW+0×7f 
0035f9ec 7270be62 comctl32!CCSendNotify+0xc19 
0035fa28 75f6f52a comctl32!SendNotify+0×36 
0035fa4c 75f61d66 SHELL32!SetAppStartingCursor+0×6d 
0035fa64 75f61ee2 SHELL32!CShellExecute::ExecuteNormal+0×16 
0035fa78 75f61e70 SHELL32!ShellExecuteNormal+0×33 
0035fa90 75f53cd0 SHELL32!ShellExecuteExW+0×62 
0035fae4 003e2211 SHELL32!ShellExecuteW+0×77 
0035fbc4 77e838be InstallFlashPlayer+0×2211 
0035fcb4 77e83492 ntdll!RtlpFreeHeap+0xbb1 
0035fcd4 757714dd ntdll!RtlFreeHeap+0×142 
0035fce8 003f0324 kernel32!HeapFree+0×14 
0035fd80 003f0241 InstallFlashPlayer+0×10324 
0035fe10 7577339a InstallFlashPlayer+0×10241 
0035fe1c 77e89ef2 kernel32!BaseThreadInitThunk+0xe 
0035fe5c 77e89ec5 ntdll!__RtlUserThreadStart+0×70 
0035fe74 00000000 ntdll!_RtlUserThreadStart+0×1b 

Unloaded Module    127 
1 Id: bc8.6b0 Suspend: 2 Teb: 7efda000 Unfrozen 
ChildEBP RetAddr 
03e1f9e0 77ea2f51 ntdll!ZwWaitForMultipleObjects+0x15 
03e1fb74 7577339a ntdll!TppWaiterpThread+0x33d 
03e1fb80 77e89ef2 kernel32!BaseThreadInitThunk+0xe 
03e1fbc0 77e89ec5 ntdll!__RtlUserThreadStart+0x70 
03e1fbd8 00000000 ntdll!_RtlUserThreadStart+0x1b 
2 Id: bc8.8dc Suspend: 2 Teb: 7efd7000 Unfrozen 
ChildEBP RetAddr 
03f5fd50 77ea3352 ntdll!NtWaitForWorkViaWorkerFactory+0x12 
03f5feb0 7577339a ntdll!TppWorkerThread+0x216 
03f5febc 77e89ef2 kernel32!BaseThreadInitThunk+0xe 
03f5fefc 77e89ec5 ntdll!__RtlUserThreadStart+0x70 
03f5ff14 00000000 ntdll!_RtlUserThreadStart+0x1b 
3 Id: bc8.944 Suspend: 2 Teb: 7efaf000 Unfrozen 
ChildEBP RetAddr 
0416f8b4 77ea3352 ntdll!NtWaitForWorkViaWorkerFactory+0x12 
0416fa14 7577339a ntdll!TppWorkerThread+0x216 
0416fa20 77e89ef2 kernel32!BaseThreadInitThunk+0xe 
0416fa60 77e89ec5 ntdll!__RtlUserThreadStart+0x70 
0416fa78 00000000 ntdll!_RtlUserThreadStart+0x1b 
The exception thread shows fpb.tmp module as unloaded: 
0:000> lmv m fpb.tmp 
start    end        module name 
Unloaded modules: 
00cb0000 00d5a000   fpb.tmp 
Timestamp: Fri Jun 01 02:56:00 2012 (4FC82130) 
Checksum:  000B0CD5 
ImageSize:  000AA000 
73ea0000 73f15000   fpb.tmp 
Timestamp: Fri Jun 01 02:49:25 2012 (4FC81FA5) 
Checksum:  0007A7CE 
ImageSize:  00075000 
 
 

128    PART 2: Crash Dump Analysis Patterns 
We change the exception thread context to get registers at the time of the exception: 
0:000> kv 
ChildEBP RetAddr Args to Child 
0035f1c4 771a0bdd 00000002 0035f214 00000001 ntdll!ZwWaitForMultipleObjects+0x15 
0035f260 75771a2c 0035f214 0035f288 00000000 
KERNELBASE!WaitForMultipleObjectsEx+0x100 
0035f2a8 75774208 00000002 7efde000 00000000 
kernel32!WaitForMultipleObjectsExImplementation+0xe0 
0035f2c4 757980a4 00000002 0035f2f8 00000000 kernel32!WaitForMultipleObjects+0x18 
0035f330 75797f63 0035f410 00000001 00000001 kernel32!WerpReportFaultInternal+0x186 
0035f344 75797858 0035f410 00000001 0035f3e0 kernel32!WerpReportFault+0x70 
0035f354 757977d7 0035f410 00000001 658587c7 kernel32!BasepReportFault+0x20 
0035f3e0 77ec74df 00000000 77ec73bc 00000000 kernel32!UnhandledExceptionFilter+0x1af 
0035f3e8 77ec73bc 00000000 0035fe5c 77e7c530 ntdll!__RtlUserThreadStart+0x62 
0035f3fc 77ec7261 00000000 00000000 00000000 ntdll!_EH4_CallFilterFunc+0x12 
0035f424 77eab459 fffffffe 0035fe4c 0035f560 ntdll!_except_handler4+0x8e 
0035f448 77eab42b 0035f510 0035fe4c 0035f560 ntdll!ExecuteHandler2+0x26 
0035f46c 77eab3ce 0035f510 0035fe4c 0035f560 ntdll!ExecuteHandler+0x24 
0035f4f8 77e60133 0135f510 0035f560 0035f510 ntdll!RtlDispatchException+0x127 
0035f4f8 73eb2200 0135f510 0035f560 0035f510 ntdll!KiUserExceptionDispatcher+0xf 
(CONTEXT @ 0035f560) 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
0035f844 76e462fa 000201ce 0000004e 00000000 <Unloaded_fpb.tmp>+0×12200 
0035f870 76e46d3a 73eb2200 000201ce 0000004e USER32!InternalCallWinProc+0×23 
0035f8e8 76e4965e 00000000 73eb2200 000201ce USER32!UserCallWinProcCheckWow+0×109 
0035f92c 76e496c5 013907f0 00000000 73eb2200 USER32!SendMessageWorker+0×581 
0035f950 7269c05c 000201ce 0000004e 00000000 USER32!SendMessageW+0×7f 
0035f9ec 7270be62 0035fa00 fffffff7 00000000 comctl32!CCSendNotify+0xc19 
0035fa28 75f6f52a 000201ce 00000000 fffffff7 comctl32!SendNotify+0×36 
0035fa4c 75f61d66 000201ce 00000001 00001500 SHELL32!SetAppStartingCursor+0×6d 
0035fa64 75f61ee2 0035faa4 00001500 0035faa4 
SHELL32!CShellExecute::ExecuteNormal+0×16 
0035fa78 75f61e70 0035faa4 00001500 00000200 SHELL32!ShellExecuteNormal+0×33 
0035fa90 75f53cd0 0035faa4 003fb654 003fa554 SHELL32!ShellExecuteExW+0×62 
0035fae4 003e2211 000201ce 003fa554 0035fb14 SHELL32!ShellExecuteW+0×77 
0035fbc4 77e838be 00da0138 77e8389a 77c467ad InstallFlashPlayer+0×2211 
0035fcb4 77e83492 00000000 00da2320 00da2320 ntdll!RtlpFreeHeap+0xbb1 
0035fcd4 757714dd 00da0000 00000000 00da2320 ntdll!RtlFreeHeap+0×142 
0035fce8 003f0324 00da0000 00000000 003f0343 kernel32!HeapFree+0×14 
0035fd80 003f0241 003e0000 00000000 010d3135 InstallFlashPlayer+0×10324 
0035fe10 7577339a 7efde000 0035fe5c 77e89ef2 InstallFlashPlayer+0×10241 
0035fe1c 77e89ef2 7efde000 77c46545 00000000 kernel32!BaseThreadInitThunk+0xe 
0035fe5c 77e89ec5 003f02ac 7efde000 ffffffff ntdll!__RtlUserThreadStart+0×70 
0035fe74 00000000 003f02ac 7efde000 00000000 ntdll!_RtlUserThreadStart+0×1b 
0:000> .cxr 0035f560 
eax=73eb2200 ebx=00000000 ecx=01080d68 edx=00000000 esi=73eb2200 
edi=00000000 
eip=73eb2200 esp=0035f848 ebp=0035f870 iopl=0 nv up ei pl nz na pe nc 
cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00210206 
<Unloaded_fpb.tmp>+0×12200: 
73eb2200 ?? ??? 
Then we double check that a window procedure was indeed called from that 
module range: 

Unloaded Module    129 
0:000> kv 
*** Stack trace for last set context - .thread/.cxr resets it 
ChildEBP RetAddr Args to Child 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
0035f844 76e462fa 000201ce 0000004e 00000000 <Unloaded_fpb.tmp>+0×12200 
0035f870 76e46d3a 73eb2200 000201ce 0000004e USER32!InternalCallWinProc+0×23 
0035f8e8 76e4965e 00000000 73eb2200 000201ce USER32!UserCallWinProcCheckWow+0×109 
0035f92c 76e496c5 013907f0 00000000 73eb2200 USER32!SendMessageWorker+0×581 
0035f950 7269c05c 000201ce 0000004e 00000000 USER32!SendMessageW+0×7f 
0035f9ec 7270be62 0035fa00 fffffff7 00000000 comctl32!CCSendNotify+0xc19 
0035fa28 75f6f52a 000201ce 00000000 fffffff7 comctl32!SendNotify+0×36 
0035fa4c 75f61d66 000201ce 00000001 00001500 SHELL32!SetAppStartingCursor+0×6d 
0035fa64 75f61ee2 0035faa4 00001500 0035faa4 
SHELL32!CShellExecute::ExecuteNormal+0×16 
0035fa78 75f61e70 0035faa4 00001500 00000200 SHELL32!ShellExecuteNormal+0×33 
0035fa90 75f53cd0 0035faa4 003fb654 003fa554 SHELL32!ShellExecuteExW+0×62 
0035fae4 003e2211 000201ce 003fa554 0035fb14 SHELL32!ShellExecuteW+0×77 
0035fbc4 77e838be 00da0138 77e8389a 77c467ad InstallFlashPlayer+0×2211 
0035fcb4 77e83492 00000000 00da2320 00da2320 ntdll!RtlpFreeHeap+0xbb1 
00da15a0 00000000 00da1780 02971450 003e1000 ntdll!RtlFreeHeap+0×142 
0:000> ub 76e462fa 
USER32!InternalCallWinProc+0×6: 
76e462dd 68cdabbadc      push    0DCBAABCDh 
76e462e2 56              push    esi 
76e462e3 ff7518          push    dword ptr [ebp+18h] 
76e462e6 ff7514          push    dword ptr [ebp+14h] 
76e462e9 ff7510          push    dword ptr [ebp+10h] 
76e462ec ff750c          push    dword ptr [ebp+0Ch] 
76e462ef 64800dca0f000001 or      byte ptr fs:[0FCAh],1 
76e462f7 ff5508          call    dword ptr [ebp+8] 
We now get a memory value pointed to by an EBP+8 address: 
0:000> r 
Last set context: 
eax=73eb2200 ebx=00000000 ecx=01080d68 edx=00000000 esi=73eb2200 
edi=00000000 
eip=73eb2200 esp=0035f848 ebp=0035f870 iopl=0 nv up ei pl nz na pe nc 
cs=0023 ss=002b ds=002b es=002b fs=0053 gs=002b efl=00210206 
<Unloaded_fpb.tmp>+0×12200: 
73eb2200 ?? ??? 
0:000> dp 0035f870+8 l1 
0035f878 73eb2200 
0:000> dd 73eb2200 
73eb2200 ???????? ???????? ???????? ???????? 
73eb2210 ???????? ???????? ???????? ???????? 
73eb2220 ???????? ???????? ???????? ???????? 
73eb2230 ???????? ???????? ???????? ???????? 
73eb2240 ???????? ???????? ???????? ???????? 
73eb2250 ???????? ???????? ???????? ???????? 
73eb2260 ???????? ???????? ???????? ???????? 
73eb2270 ???????? ???????? ???????? ???????? 

130    PART 2: Crash Dump Analysis Patterns 
The value indeed belongs to unloaded fpb.tmp module address range: 
0:000> ln 73eb2200 
(73eb2200) <Unloaded_fpb.tmp>+0×12200 
 
 

Stack Trace Change    131 
Stack Trace Change 
This is an important pattern for differential memory dump analysis, for example, when 
memory dumps were generated before and after a problem such as a CPU spike or 
hang. In the example below we have a normally expected thread stack trace from a 
memory dump saved before an application was reported unresponsive and another 
different thread stack trace after: 
3 Id: 24b8.24e4 Suspend: 0 Teb: 7efa1000 Unfrozen 
ChildEBP RetAddr 
037dfadc 75210bdd ntdll!ZwWaitForMultipleObjects+0x15 
037dfb78 75791a2c KERNELBASE!WaitForMultipleObjectsEx+0x100 
037dfbc0 7511086a kernel32!WaitForMultipleObjectsExImplementation+0xe0 
037dfc14 00d17c1d user32!RealMsgWaitForMultipleObjectsEx+0x14d 
037dfc3c 00ce161d ApplicationA!MsgWaitForMultipleObjects+0x2d 
037dfc60 00cdc757 ApplicationA!WaitForSignal+0x1d 
037dfc80 00cdaaf6 ApplicationA!WorkLoop+0x57 
037dfca4 7579339a ApplicationA!ThreadStart+0x26 
037dfcb0 77699ef2 kernel32!BaseThreadInitThunk+0xe 
037dfcf0 77699ec5 ntdll!__RtlUserThreadStart+0x70 
037dfd08 00000000 ntdll!_RtlUserThreadStart+0x1b 
3 Id: 24b8.24e4 Suspend: 0 Teb: 7efa1000 Unfrozen 
ChildEBP RetAddr 
037df38c 752131bb ntdll!ZwDelayExecution+0x15 
037df3f4 75213a8b KERNELBASE!SleepEx+0x65 
037df404 00d1670b KERNELBASE!Sleep+0xf 
037df40c 00d350ef ApplicationA!Sleep+0xb 
037df430 6a868aab ApplicationA!PutData+0xbf 
037df444 6a8662ec ModuleA!OutputData+0x1b 
037df464 00d351de ModuleA!ProcessData+0x16c 
037df4a4 00ca8cb4 ApplicationA!SendData+0xbe 
[...] 
 
 
 

132    PART 2: Crash Dump Analysis Patterns 
Spike Interval 
Sometimes, when an application is sluggish, periodically consumes CPU, it is possible to 
create a set of consecutive memory dumps of the same process to see the temporal 
development of any thread CPU consumption and figure out potential spike interval(s). 
For example, the following diagram was plotted from !runaway WinDbg command 
output for thread #1: 
00.437
00.629
14.629
00.937
      
27.629
06.515
39.629
07.125
50.629
10.625
14.578
01:01.629
UserTime
Thread
Elapsed 
Time
 
The 3rd and the 5th user process memory dumps in addition to increased CPU 
consumption also had corresponding non-waiting stack trace frames caught while 
executing some CPU instructions in ModuleA (not preempted with saved context). The 
first memory dump (the first left bar) with 437 ms user time spent out of 629 ms 
elapsed time also had a non-waiting stack trace, but we consider it a normal application 
startup CPU consumption spike. 
 
 

Deviant Module    133 
Deviant Module 
When looking at the module list (lmv), searching for modules (.imgscan) or examining 
the particular module (!address, !dh) we may notice one of them as deviant. The 
deviation may be in (but not limited to as anything is possible): 
 
suspicious module name 
 
suspicious protection 
 
suspicious module load address 
0:005> .imgscan 
MZ at 00040000, prot 00000040, type 00020000 - size 1d000 
MZ at 00340000, prot 00000002, type 01000000 - size 9c000 
Name: iexplore.exe 
MZ at 02250000, prot 00000002, type 00040000 - size 2000 
MZ at 023b0000, prot 00000002, type 01000000 - size b000 
Name: msimtf.dll 
MZ at 03f80000, prot 00000002, type 00040000 - size 2000 
MZ at 10000000, prot 00000004, type 00020000 - size 5000 
Name: screens_dll.dll 
MZ at 16080000, prot 00000002, type 01000000 - size 25000 
Name: mdnsNSP.dll 
MZ at 6ab50000, prot 00000002, type 01000000 - size 26000 
Name: DSSENH.dll 
MZ at 6b030000, prot 00000002, type 01000000 - size 5b0000 
Name: MSHTML.dll 
MZ at 6ba10000, prot 00000002, type 01000000 - size b4000 
Name: JSCRIPT.dll 
MZ at 6cec0000, prot 00000002, type 01000000 - size 1b000 
Name: CRYPTNET.dll 
MZ at 6d260000, prot 00000002, type 01000000 - size e000 
Name: PNGFILTER.DLL 
MZ at 6d2f0000, prot 00000002, type 01000000 - size 29000 
Name: msls31.dll 
MZ at 6d700000, prot 00000002, type 01000000 - size 30000 
Name: MLANG.dll 
MZ at 6d740000, prot 00000002, type 01000000 - size 4d000 
Name: SSV.DLL 
MZ at 6d7b0000, prot 00000002, type 01000000 - size c000 
Name: ImgUtil.dll 
MZ at 6ddb0000, prot 00000002, type 01000000 - size 2f000 
Name: iepeers.DLL 
MZ at 6df20000, prot 00000002, type 01000000 - size 33000 
Name: IEShims.dll 
MZ at 6eb80000, prot 00000002, type 01000000 - size a94000 
Name: IEFRAME.dll 
MZ at 703b0000, prot 00000002, type 01000000 - size 53000 
Name: SWEEPRX.dll 
MZ at 70740000, prot 00000002, type 01000000 - size 40000 
Name: SWEEPRX.dll 

134    PART 2: Crash Dump Analysis Patterns 
MZ at 725a0000, prot 00000002, type 01000000 - size 12000 
Name: PNRPNSP.dll 
MZ at 725d0000, prot 00000002, type 01000000 - size 8000 
Name: WINRNR.dll 
MZ at 725e0000, prot 00000002, type 01000000 - size 136000 
Name: MSXML3.dll 
MZ at 72720000, prot 00000002, type 01000000 - size c000 
Name: wshbth.dll 
MZ at 72730000, prot 00000002, type 01000000 - size f000 
Name: NAPINSP.dll 
MZ at 72890000, prot 00000002, type 01000000 - size 6000 
Name: SensApi.dll 
MZ at 72ec0000, prot 00000002, type 01000000 - size 42000 
Name: WINSPOOL.DRV 
MZ at 734b0000, prot 00000002, type 01000000 - size 6000 
Name: rasadhlp.dll 
MZ at 736b0000, prot 00000002, type 01000000 - size 85000 
Name: COMCTL32.dll 
MZ at 73ac0000, prot 00000002, type 01000000 - size 7000 
Name: MIDIMAP.dll 
MZ at 73ae0000, prot 00000002, type 01000000 - size 14000 
Name: MSACM32.dll 
MZ at 73b00000, prot 00000002, type 01000000 - size 66000 
Name: audioeng.dll 
MZ at 73c30000, prot 00000002, type 01000000 - size 9000 
Name: MSACM32.DRV 
MZ at 73c60000, prot 00000002, type 01000000 - size 21000 
Name: AudioSes.DLL 
MZ at 73c90000, prot 00000002, type 01000000 - size 2f000 
Name: WINMMDRV.dll 
MZ at 74290000, prot 00000002, type 01000000 - size bb000 
Name: PROPSYS.dll 
MZ at 74390000, prot 00000002, type 01000000 - size f000 
Name: nlaapi.dll 
MZ at 743a0000, prot 00000002, type 01000000 - size 4000 
Name: ksuser.dll 
MZ at 74430000, prot 00000002, type 01000000 - size 15000 
Name: Cabinet.dll 
MZ at 74450000, prot 00000002, type 01000000 - size 3d000 
Name: OLEACC.dll 
MZ at 74490000, prot 00000002, type 01000000 - size 1ab000 
Name: gdiplus.dll 
MZ at 74640000, prot 00000002, type 01000000 - size 28000 
Name: MMDevAPI.DLL 
MZ at 74670000, prot 00000002, type 01000000 - size 32000 
Name: WINMM.dll 
MZ at 746b0000, prot 00000002, type 01000000 - size 31000 
Name: TAPI32.dll 
MZ at 749e0000, prot 00000002, type 01000000 - size 19e000 
Name: COMCTL32.dll 
MZ at 74b80000, prot 00000002, type 01000000 - size 7000 
Name: AVRT.dll 
MZ at 74ba0000, prot 00000002, type 01000000 - size 4a000 
Name: RASAPI32.dll 

Deviant Module    135 
MZ at 74ce0000, prot 00000002, type 01000000 - size 3f000 
Name: UxTheme.dll 
MZ at 74de0000, prot 00000002, type 01000000 - size 2d000 
Name: WINTRUST.dll 
MZ at 74ea0000, prot 00000002, type 01000000 - size 14000 
Name: rasman.dll 
MZ at 74f70000, prot 00000002, type 01000000 - size c000 
Name: rtutils.dll 
MZ at 74f80000, prot 00000002, type 01000000 - size 5000 
Name: WSHTCPIP.dll 
MZ at 74fb0000, prot 00000002, type 01000000 - size 21000 
Name: NTMARTA.dll 
MZ at 75010000, prot 00000002, type 01000000 - size 3b000 
Name: RSAENH.dll 
MZ at 75050000, prot 00000002, type 01000000 - size 5000 
Name: MSIMG32.dll 
MZ at 75060000, prot 00000002, type 01000000 - size 15000 
Name: GPAPI.dll 
MZ at 750a0000, prot 00000002, type 01000000 - size 46000 
Name: SCHANNEL.dll 
MZ at 752b0000, prot 00000002, type 01000000 - size 3b000 
Name: MSWSOCK.dll 
MZ at 75370000, prot 00000002, type 01000000 - size 45000 
Name: bcrypt.dll 
MZ at 753f0000, prot 00000002, type 01000000 - size 5000 
Name: WSHIP6.dll 
MZ at 75400000, prot 00000002, type 01000000 - size 8000 
Name: VERSION.dll 
MZ at 75420000, prot 00000002, type 01000000 - size 7000 
Name: CREDSSP.dll 
MZ at 75430000, prot 00000002, type 01000000 - size 35000 
Name: ncrypt.dll 
MZ at 75480000, prot 00000002, type 01000000 - size 22000 
Name: dhcpcsvc6.DLL 
MZ at 754b0000, prot 00000002, type 01000000 - size 7000 
Name: WINNSI.DLL 
MZ at 754c0000, prot 00000002, type 01000000 - size 35000 
Name: dhcpcsvc.DLL 
MZ at 75500000, prot 00000002, type 01000000 - size 19000 
Name: IPHLPAPI.DLL 
MZ at 75590000, prot 00000002, type 01000000 - size 3a000 
Name: slc.dll 
MZ at 755d0000, prot 00000002, type 01000000 - size f2000 
Name: CRYPT32.dll 
MZ at 75740000, prot 00000002, type 01000000 - size 12000 
Name: MSASN1.dll 
MZ at 75760000, prot 00000002, type 01000000 - size 11000 
Name: SAMLIB.dll 
MZ at 75780000, prot 00000002, type 01000000 - size 76000 
Name: NETAPI32.dll 
MZ at 75800000, prot 00000002, type 01000000 - size 2c000 
Name: DNSAPI.dll 
MZ at 75a70000, prot 00000002, type 01000000 - size 5f000 
Name: sxs.dll 

136    PART 2: Crash Dump Analysis Patterns 
MZ at 75ad0000, prot 00000002, type 01000000 - size 2c000 
Name: apphelp.dll 
MZ at 75b30000, prot 00000002, type 01000000 - size 14000 
Name: Secur32.dll 
MZ at 75b50000, prot 00000002, type 01000000 - size 1e000 
Name: USERENV.dll 
MZ at 75c90000, prot 00000002, type 01000000 - size 7000 
Name: PSAPI.DLL 
MZ at 75ca0000, prot 00000002, type 01000000 - size c3000 
Name: RPCRT4.dll 
MZ at 75d70000, prot 00000002, type 01000000 - size 73000 
Name: COMDLG32.dll 
MZ at 75df0000, prot 00000002, type 01000000 - size 9000 
Name: LPK.dll 
MZ at 75e00000, prot 00000002, type 01000000 - size dc000 
Name: KERNEL32.dll 
MZ at 75ee0000, prot 00000002, type 01000000 - size aa000 
Name: msvcrt.dll 
MZ at 75f90000, prot 00000002, type 01000000 - size 1e8000 
Name: iertutil.dll 
MZ at 76180000, prot 00000002, type 01000000 - size 29000 
Name: imagehlp.dll 
MZ at 761b0000, prot 00000002, type 01000000 - size 6000 
Name: NSI.dll 
MZ at 761c0000, prot 00000002, type 01000000 - size 84000 
Name: CLBCatQ.DLL 
MZ at 76250000, prot 00000002, type 01000000 - size 49000 
Name: WLDAP32.dll 
MZ at 762a0000, prot 00000002, type 01000000 - size c6000 
Name: ADVAPI32.dll 
MZ at 76370000, prot 00000002, type 01000000 - size 4b000 
Name: GDI32.dll 
MZ at 763c0000, prot 00000002, type 01000000 - size 59000 
Name: SHLWAPI.dll 
MZ at 76420000, prot 00000002, type 01000000 - size e6000 
Name: WININET.dll 
MZ at 76510000, prot 00000002, type 01000000 - size b10000 
Name: SHELL32.dll 
MZ at 77020000, prot 00000002, type 01000000 - size 145000 
Name: ole32.dll 
MZ at 77170000, prot 00000002, type 01000000 - size 7d000 
Name: USP10.dll 
MZ at 771f0000, prot 00000002, type 01000000 - size 8d000 
Name: OLEAUT32.dll 
MZ at 77280000, prot 00000002, type 01000000 - size 18a000 
Name: SETUPAPI.dll 
MZ at 77410000, prot 00000002, type 01000000 - size 9d000 
Name: USER32.dll 
MZ at 774b0000, prot 00000002, type 01000000 - size 133000 
Name: urlmon.dll 
MZ at 775f0000, prot 00000002, type 01000000 - size 127000 
Name: ntdll.dll 
MZ at 77720000, prot 00000002, type 01000000 - size 3000 
Name: Normaliz.dll 

Deviant Module    137 
MZ at 77730000, prot 00000002, type 01000000 - size 2d000 
Name: WS2_32.dll 
MZ at 77760000, prot 00000002, type 01000000 - size 1e000 
Name: IMM32.dll 
MZ at 77780000, prot 00000002, type 01000000 - size c8000 
Name: MSCTF.dll 
MZ at 7c340000, prot 00000002, type 01000000 - size 56000 
Name: MSVCR71.dll 
0:005> !address 00040000 
Usage:                  <unclassified> 
Allocation Base:        00040000 
Base Address:           00040000 
End Address:            0005d000 
Region Size:            0001d000 
Type:                   00020000 MEM_PRIVATE 
State:                  00001000 MEM_COMMIT 
Protect:                00000040 PAGE_EXECUTE_READWRITE 
0:005> !address 10000000 
Usage:                  <unclassified> 
Allocation Base:        10000000 
Base Address:           10000000 
End Address:            10001000 
Region Size:            00001000 
Type:                   00020000 MEM_PRIVATE 
State:                  00001000 MEM_COMMIT 
Protect:                00000004 PAGE_READWRITE 
 
suspicious text inside 
See Volume 5, page 406 for a case study example. 
 
suspicious import table (for example, screen grabbing) or its absence (dynamic 
imports) 
0:005> !dh 10000000 
[...] 
2330 [      50] address [size] of Export Directory 
20E0 [      78] address [size] of Import Directory 
0 [       0] address [size] of Resource Directory 
0 [       0] address [size] of Exception Directory 
0 [       0] address [size] of Security Directory 
4000 [      34] address [size] of Base Relocation Directory 
2060 [      1C] address [size] of Debug Directory 
0 [       0] address [size] of Description Directory 
0 [       0] address [size] of Special Directory 
0 [       0] address [size] of Thread Storage Directory 
0 [       0] address [size] of Load Configuration Directory 
0 [       0] address [size] of Bound Import Directory 
2000 [      58] address [size] of Import Address Table Directory 

138    PART 2: Crash Dump Analysis Patterns 
0 [       0] address [size] of Delay Import Directory 
0 [       0] address [size] of COR20 Header Directory 
0 [       0] address [size] of Reserved Directory 
[...] 
0:005> dps 10000000+2000 10000000+2000+58 
10002000 76376101 gdi32!CreateCompatibleDC 
10002004 763793d6 gdi32!StretchBlt 
10002008 76377461 gdi32!CreateDIBSection 
1000200c 763762a0 gdi32!SelectObject 
10002010 00000000 
10002014 75e4a411 kernel32!lstrcmpW 
10002018 75e440aa kernel32!VirtualFree 
1000201c 75e4ad55 kernel32!VirtualAlloc 
10002020 00000000 
10002024 77429ced user32!ReleaseDC 
10002028 77423ba7 user32!NtUserGetWindowDC 
1000202c 77430e21 user32!GetWindowRect 
10002030 00000000 
10002034 744a75e9 GdiPlus!GdiplusStartup 
10002038 744976dd GdiPlus!GdipSaveImageToStream 
1000203c 744cdd38 GdiPlus!GdipGetImageEncodersSize 
10002040 744971cf GdiPlus!GdipDisposeImage 
10002044 744a8591 GdiPlus!GdipCreateBitmapFromHBITMAP 
10002048 744cdbae GdiPlus!GdipGetImageEncoders 
1000204c 00000000 
10002050 7707d51b ole32!CreateStreamOnHGlobal 
10002054 00000000 
10002058 00000000 
0:000> !dh 012a0000 
[...] 
0 [       0] address [size] of Export Directory 
0 [       0] address [size] of Import Directory 
0 [       0] address [size] of Resource Directory 
0 [       0] address [size] of Exception Directory 
0 [       0] address [size] of Security Directory 
8000 [      FC] address [size] of Base Relocation Directory 
4000 [      1C] address [size] of Debug Directory 
0 [       0] address [size] of Description Directory 
0 [       0] address [size] of Special Directory 
0 [       0] address [size] of Thread Storage Directory 
0 [       0] address [size] of Load Configuration Directory 
0 [       0] address [size] of Bound Import Directory 
0 [       0] address [size] of Import Address Table Directory 
0 [       0] address [size] of Delay Import Directory 
0 [       0] address [size] of COR20 Header Directory 
0 [       0] address [size] of Reserved Directory 
[...] 
 
 

Deviant Module    139 
 
suspicious path names 
Age: 7, Pdb: 
d:\work\BekConnekt\Client_src_code_New\Release\Blackjoe_new.pdb 
Debug Directories(1) 
Type Size Address Pointer 
cv 46 2094 894 Format: RSDS, guid, 1, 
C:\MyWork\screens_dll\Release\screens_dll.pdb 
 
suspicious image path (although it could be dynamic code generation for .NET 
assemblies) 
 
uninitialized image resources 
0:002> lmv m C6DC 
start    end        module name 
012a0000 012a9000   C6DC     C (no symbols) 
Loaded symbol image file: C6DC.tmp 
Image path: C:\Users\User\AppData\Local\Temp\C6DC.tmp 
Image name: C6DC.tmp 
Timestamp:        Sun May 30 20:18:32 2010 (4C02BA08) 
CheckSum:         00000000 
ImageSize:        00009000 
File version:     0.0.0.0 
Product version:  0.0.0.0 
File flags:       0 (Mask 0) 
File OS:          0 Unknown Base 
File type:        0.0 Unknown 
File date:        00000000.00000000 
Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4 
 
 

140    PART 2: Crash Dump Analysis Patterns 
Hidden Exception (Kernel Space) 
This is an example of Hidden Exception pattern (Volume 1, page 271) in kernel space: 
0: kd> !thread 
THREAD fffffa800d4bf9c0  Cid 0e88.56e0  Teb: 000007fffffd8000 Win32Thread: 
0000000000000000 RUNNING on processor 0 
Not impersonating 
DeviceMap                 fffff8a001e91950 
Owning 
Process            fffffa800b33cb30       Image:         svchost.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      13154529       Ticks: 0 
Context Switch Count      1426 
UserTime                  00:00:00.015 
KernelTime                00:00:00.124 
Win32 Start Address 0x0000000077728d20 
Stack Init fffff8800a83fdb0 Current fffff8800a83eb90 
Base fffff8800a840000 Limit fffff8800a83a000 Call 0 
Priority 10 BasePriority 10 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 
PagePriority 5 
[...] 
0: kd> dps fffff8800a83a000 fffff8800a840000 
[...] 
fffff880`0a83e180 fffff880`0a83ea10 
fffff880`0a83e188 fffff880`0a83e6d0 
fffff880`0a83e190 fffff880`0a83e968 
fffff880`0a83e198 fffff800`016c88cf nt!KiDispatchException+0×16f 
fffff880`0a83e1a0 fffff880`0a83e968 
fffff880`0a83e1a8 fffff880`0a83e1d0 
fffff880`0a83e1b0 fffff880`00000000 
fffff880`0a83e1b8 00000000`00000000 
fffff880`0a83e1c0 00000000`00000000 
fffff880`0a83e1c8 00000000`00000000 
[...] 
0: kd> .cxr fffff880`0a83e1d0 
rax=0000000000000009 rbx=fffffa800d4c1de0 rcx=0000000000000000 
rdx=fffff8800a83ece0 rsi=0000000000000000 rdi=0000000000000000 
rip=fffff800016ad74f rsp=fffff8800a83eba0 rbp=00000000a000000c 
r8=fffff8800a83ecd8 r9=fffff8800a83ecc0 r10=0000000000000000 
r11=fffff8800a83ed58 r12=0000000000000000 r13=0000000000000000 
r14=fffffa800d4bf9c0 r15=fffffa800d4c1ea0 
iopl=0 nv up ei pl zr na po nc 
cs=0010 ss=0018 ds=002b es=002b fs=0053 gs=002b efl=00010246 
nt!IopCompleteRequest+0x12f: 
fffff800`016ad74f 48894108 mov qword ptr [rcx+8],rax 
ds:002b:00000000`00000008=???????????????? 
 
 

Handled Exception (Kernel Space)    141 
Handled Exception (Kernel Space) 
This is a variant of Handled Exception pattern in kernel space similar to user (Volume 6, 
page 141) and managed spaces (Volume 6, page 144). The crash dump was the same as 
in Hidden Exception in kernel space pattern (page 140): 
fffff880`0a83d910 00000000`00000000 
fffff880`0a83d918 fffff6fc`40054fd8 
fffff880`0a83d920 fffff880`0a83dca0 
fffff880`0a83d928 fffff800`016bcc1c nt!_C_specific_handler+0xcc 
fffff880`0a83d930 00000000`00000000 
fffff880`0a83d938 00000000`00000000 
fffff880`0a83d940 00000000`00000000 
fffff880`0a83d948 00000000`00000000 
fffff880`0a83d950 fffff800`0189ee38 nt!BBTBuffer <PERF> (nt+0x280e38) 
fffff880`0a83d958 fffff880`0a83e940 
fffff880`0a83d960 fffff800`016ad767 nt!IopCompleteRequest+0x147 
fffff880`0a83d968 fffff880`0a83de40 
fffff880`0a83d970 fffff800`01665e40 nt!_GSHandlerCheck_SEH 
fffff880`0a83d978 fffff800`017e5338 
nt!_imp_NtOpenSymbolicLinkObject+0xfe30 
fffff880`0a83d980 fffff880`0a83e310 
fffff880`0a83d988 00000000`00000000 
fffff880`0a83d990 00000000`00000000 
fffff880`0a83d998 fffff800`016b42dd nt!RtlpExecuteHandlerForException+0xd 
fffff880`0a83d9a0 fffff800`017d7d0c 
nt!_imp_NtOpenSymbolicLinkObject+0×2804 
fffff880`0a83d9a8 fffff880`0a83eab0 
fffff880`0a83d9b0 00000000`00000000 
0: kd> ub fffff800`016b42dd 
nt!RtlpExceptionHandler+0x24: 
fffff800`016b42c4 cc   
int 3 
fffff800`016b42c5 cc   
int 3 
fffff800`016b42c6 cc   
int 3 
fffff800`016b42c7 cc   
int 3 
fffff800`016b42c8 0f1f840000000000 nop dword ptr [rax+rax] 
nt!RtlpExecuteHandlerForException: 
fffff800`016b42d0 4883ec28  
sub rsp,28h 
fffff800`016b42d4 4c894c2420  mov qword ptr [rsp+20h],r9 
fffff800`016b42d9 41ff5130  
call qword ptr [r9+30h] 
 
 

142    PART 2: Crash Dump Analysis Patterns 
High Contention (.NET CLR Monitors) 
This is a high contention pattern variant where the contention is around a monitor 
object. For example, we have Distributed Spike (Volume 5, page 99) for some threads: 
0:000> !runaway 
 User Mode Time 
  Thread       Time 
   9:6ff4      0 days 0:07:39.019 
  12:6b88      0 days 0:06:19.786 
  11:6bf0      0 days 0:06:13.889 
  10:6930      0 days 0:06:09.240 
  16:3964      0 days 0:05:44.483 
  17:6854      0 days 0:05:35.326 
  13:668c      0 days 0:05:35.123 
  14:5594      0 days 0:05:34.858 
  15:7248      0 days 0:05:23.111 
   2:c54       0 days 0:00:41.215 
   4:1080      0 days 0:00:00.349 
   7:10f0      0 days 0:00:00.302 
   0:c3c       0 days 0:00:00.271 
[...] 
If we look at their stack traces, we find them all blocked trying to enter a 
monitor, for example: 
0:000> ~*k 
[...] 
12 Id: d50.6b88 Suspend: 0 Teb: 000007ff`fffd8000 Unfrozen 
Child-SP RetAddr Call Site 
00000000`1a98e798 000007fe`fd0c1420 ntdll!ZwWaitForMultipleObjects+0xa 
00000000`1a98e7a0 00000000`76e82cf3 KERNELBASE!WaitForMultipleObjectsEx+0xe8 
00000000`1a98e8a0 000007fe`f82e0669 kernel32!WaitForMultipleObjectsExImplementation+0xb3 
00000000`1a98e930 000007fe`f82dbec9 mscorwks!WaitForMultipleObjectsEx_SO_TOLERANT+0xc1 
00000000`1a98e9d0 000007fe`f82a0569 mscorwks!Thread::DoAppropriateAptStateWait+0x41 
00000000`1a98ea30 000007fe`f82beaec mscorwks!Thread::DoAppropriateWaitWorker+0x191 
00000000`1a98eb30 000007fe`f81f1b9a mscorwks!Thread::DoAppropriateWait+0x5c 
00000000`1a98eba0 000007fe`f82fd3c9 mscorwks!CLREvent::WaitEx+0xbe 
00000000`1a98ec50 000007fe`f81ac6be mscorwks!AwareLock::EnterEpilog+0xc9 
00000000`1a98ed20 000007fe`f81c7b2b mscorwks!AwareLock::Enter+0x72 
00000000`1a98ed50 000007fe`f87946af mscorwks!AwareLock::Contention+0x1fb 
00000000`1a98ee20 000007ff`00161528 mscorwks!JITutil_MonContention+0xdf 
00000000`1a98efd0 000007ff`0016140e 0×7ff`00161528 
00000000`1a98f040 000007ff`00167271 0×7ff`0016140e 
00000000`1a98f0a0 000007fe`f74e2bbb 0×7ff`00167271 
00000000`1a98f130 000007fe`f753ed76 mscorlib_ni+0×2f2bbb 
00000000`1a98f180 000007fe`f8390282 mscorlib_ni+0×34ed76 
00000000`1a98f1d0 000007fe`f8274363 mscorwks!CallDescrWorker+0×82 
00000000`1a98f220 000007fe`f8274216 mscorwks!CallDescrWorkerWithHandler+0xd3 
00000000`1a98f2c0 000007fe`f81c96a7 mscorwks!DispatchCallDebuggerWrapper+0×3e 
00000000`1a98f320 000007fe`f830ae42 mscorwks!DispatchCallNoEH+0×5f 
00000000`1a98f3a0 000007fe`f81bdc00 mscorwks!AddTimerCallback_Worker+0×92 
00000000`1a98f430 000007fe`f82a41a5 mscorwks!ManagedThreadCallState::IsAppDomainEqual+0×4c 
00000000`1a98f480 000007fe`f82df199 mscorwks!SVR::gc_heap::make_heap_segment+0×155 
00000000`1a98f550 000007fe`f82ececa mscorwks!DoOpenIAssemblyStress::DoOpenIAssemblyStress+0×99 

High Contention (.NET CLR Monitors)    143 
00000000`1a98f590 000007fe`f830c0db mscorwks!AddTimerCallbackEx+0xba 
00000000`1a98f650 000007fe`f81ebb37 mscorwks!ThreadpoolMgr::AsyncTimerCallbackCompletion+0×53 
00000000`1a98f6b0 000007fe`f81fe92a mscorwks!UnManagedPerAppDomainTPCount::DispatchWorkItem+0×157 
00000000`1a98f750 000007fe`f81bb1fc mscorwks!ThreadpoolMgr::WorkerThreadStart+0×1ba 
00000000`1a98f7f0 00000000`76e7652d mscorwks!Thread::intermediateThreadProc+0×78 
00000000`1a98fcc0 00000000`76fac521 kernel32!BaseThreadInitThunk+0xd 
00000000`1a98fcf0 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
[...] 
15 Id: d50.7248 Suspend: 0 Teb: 000007ff`ffee6000 Unfrozen 
Child-SP RetAddr Call Site 
00000000`1c16e6f0 000007fe`f87946af mscorwks!AwareLock::Contention+0×13b 
00000000`1c16e7c0 000007ff`0016135e mscorwks!JITutil_MonContention+0xdf 
00000000`1c16e970 000007ff`0016726b 0×7ff`0016135e 
00000000`1c16e9c0 000007fe`f74e2bbb 0×7ff`0016726b 
00000000`1c16ea50 000007fe`f753ed76 mscorlib_ni+0×2f2bbb 
00000000`1c16eaa0 000007fe`f8390282 mscorlib_ni+0×34ed76 
00000000`1c16eaf0 000007fe`f8274363 mscorwks!CallDescrWorker+0×82 
00000000`1c16eb40 000007fe`f8274216 mscorwks!CallDescrWorkerWithHandler+0xd3 
00000000`1c16ebe0 000007fe`f81c96a7 mscorwks!DispatchCallDebuggerWrapper+0×3e 
00000000`1c16ec40 000007fe`f830ae42 mscorwks!DispatchCallNoEH+0×5f 
00000000`1c16ecc0 000007fe`f81bdc00 mscorwks!AddTimerCallback_Worker+0×92 
00000000`1c16ed50 000007fe`f82a41a5 mscorwks!ManagedThreadCallState::IsAppDomainEqual+0×4c 
00000000`1c16eda0 000007fe`f82df199 mscorwks!SVR::gc_heap::make_heap_segment+0×155 
00000000`1c16ee70 000007fe`f82ececa mscorwks!DoOpenIAssemblyStress::DoOpenIAssemblyStress+0×99 
00000000`1c16eeb0 000007fe`f830c0db mscorwks!AddTimerCallbackEx+0xba 
00000000`1c16ef70 000007fe`f81ebb37 mscorwks!ThreadpoolMgr::AsyncTimerCallbackCompletion+0×53 
00000000`1c16efd0 000007fe`f81fe92a mscorwks!UnManagedPerAppDomainTPCount::DispatchWorkItem+0×157 
00000000`1c16f070 000007fe`f81bb1fc mscorwks!ThreadpoolMgr::WorkerThreadStart+0×1ba 
00000000`1c16f110 00000000`76e7652d mscorwks!Thread::intermediateThreadProc+0×78 
00000000`1c16f9e0 00000000`76fac521 kernel32!BaseThreadInitThunk+0xd 
00000000`1c16fa10 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
[...] 
Thread #15 seems was caught at the time when it was trying to enter and not 
waiting yet. If we check a monitor object the thread #12 tries to enter we see it has an 
address 01af0be8: 
0:000> !u 000007ff`00161528 
Normal JIT generated code 
[...] 
000007ff`00161505 90              nop 
000007ff`00161506 48b8f089ae1100000000 mov rax,11AE89F0h 
000007ff`00161510 488b00          mov     rax,qword ptr [rax] 
000007ff`00161513 48894528        mov     qword ptr [rbp+28h],rax 
000007ff`00161517 488b4528        mov     rax,qword ptr [rbp+28h] 
000007ff`0016151b 48894518        mov     qword ptr [rbp+18h],rax 
000007ff`0016151f 488b4d28        mov     rcx,qword ptr [rbp+28h] 
000007ff`00161523 e8b8d422f8      call    mscorwks!JIT_MonEnter 
(000007fe`f838e9e0) 
>>> 000007ff`00161528 90              nop 
000007ff`00161529 90              nop 
000007ff`0016152a 90              nop 
[...] 
000007ff`001615d2 4883c430        add     rsp,30h 
000007ff`001615d6 5d              pop     rbp 
000007ff`001615d7 f3c3            rep ret 

144    PART 2: Crash Dump Analysis Patterns 
0:000> dps 11AE89F0h l1 
00000000`11ae89f0  00000000`01af0be8 
This object seems to be owned by the thread #17: 
0:000> !syncblk 
Index         SyncBlock MonitorHeld Recursion Owning Thread Info          SyncBlock Owner 
 1362 000000001ba7b6c0           15         1 000000001c0173b0  6854  17   0000000001af0be8 
System.Object 
[...] 
This thread seems to be blocked in ALPC: 
0:017> k 
Child-SP RetAddr Call Site 
00000000`1d55c9e8 000007fe`fee1a776 ntdll!NtAlpcSendWaitReceivePort+0xa 
00000000`1d55c9f0 000007fe`fee14e42 rpcrt4!LRPC_CCALL::SendReceive+0x156 
00000000`1d55cab0 000007fe`ff0828c0 rpcrt4!I_RpcSendReceive+0x42 
00000000`1d55cae0 000007fe`ff08282f ole32!ThreadSendReceive+0x40 
00000000`1d55cb30 000007fe`ff08265b ole32!CRpcChannelBuffer::SwitchAptAndDispatchCall+0xa3 
00000000`1d55cbd0 000007fe`fef3daaa ole32!CRpcChannelBuffer::SendReceive2+0x11b 
00000000`1d55cd90 000007fe`fef3da0c ole32!CAptRpcChnl::SendReceive+0x52 
00000000`1d55ce60 000007fe`ff08205d ole32!CCtxComChnl::SendReceive+0x68 
00000000`1d55cf10 000007fe`feebfd61 ole32!NdrExtpProxySendReceive+0x45 
00000000`1d55cf40 000007fe`ff07f82f rpcrt4!NdrpClientCall2+0x9ea 
00000000`1d55d6b0 000007fe`fef3d8a2 ole32!ObjectStublessClient+0x1ad 
00000000`1d55da40 000007fe`fa511ba8 ole32!ObjectStubless+0x42 
[...]  
 
 

Frozen Process    145 
Frozen Process 
Looks like Windows 8 reuses the debugging concept of a frozen thread for the so called 
a “deeply frozen” process: 
0: kd> !sprocess 2 
Dumping Session 2 
[...] 
PROCESS fffffa8002cb2940 
SessionId: 2 Cid: 0c80 Peb: 7f6c41dd000 ParentCid: 0288 
DeepFreeze 
DirBase: 2ef45000 ObjectTable: fffff8a002f215c0 HandleCount: <Data Not 
Accessible> 
Image: iexplore.exe 
[...] 
0: kd> dt nt!_KPROCESS fffffa8002cb2940 
+0x000 Header           : _DISPATCHER_HEADER 
+0x018 ProfileListHead  : _LIST_ENTRY [ 0xfffffa80`02cb2958 - 
0xfffffa80`02cb2958 ] 
+0x028 DirectoryTableBase : 0x2ef45000 
+0x030 ThreadListHead   : _LIST_ENTRY [ 0xfffffa80`01e4edf8 - 
0xfffffa80`01f5bbf8 ] 
+0x040 ProcessLock      : 0 
+0x044 Spare0           : 0 
+0x048 Affinity         : _KAFFINITY_EX 
+0x0f0 ReadyListHead    : _LIST_ENTRY [ 0xfffffa80`02cb2a30 - 
0xfffffa80`02cb2a30 ] 
+0x100 SwapListEntry    : _SINGLE_LIST_ENTRY 
+0x108 ActiveProcessors : _KAFFINITY_EX 
+0x1b0 AutoAlignment    : 0y0 
+0x1b0 DisableBoost     : 0y0 
+0x1b0 DisableQuantum   : 0y0 
+0x1b0 AffinitySet      : 0y0 
+0×1b0 DeepFreeze       : 0y1 
+0×1b0 TimerVirtualization : 0y1 
+0×1b0 ActiveGroupsMask : 0y00000000000000000001 (0×1) 
+0×1b0 ReservedFlags    : 0y000000 (0) 
+0×1b0 ProcessFlags     : 0n112 
+0×1b4 BasePriority     : 8 ” 
+0×1b5 QuantumReset     : 6 ” 
+0×1b6 Visited          : 0 ” 
+0×1b7 Flags            : _KEXECUTE_OPTIONS 
+0×1b8 ThreadSeed       : [20] 0 
+0×208 IdealNode        : [20] 0 
+0×230 IdealGlobalNode  : 0 
+0×232 Spare1           : 0 
+0×234 StackCount       : _KSTACK_COUNT 
+0×238 ProcessListEntry : _LIST_ENTRY [ 0xfffffa80`03816b78 - 
0xfffffa80`02cc2b78 ] 
+0×248 CycleTime        : 0×225078 
+0×250 ContextSwitches  : 0×22 

146    PART 2: Crash Dump Analysis Patterns 
+0×258 SchedulingGroup  : (null) 
+0×260 FreezeCount      : 0 
+0×264 KernelTime       : 0 
+0×268 UserTime         : 0 
+0×26c LdtFreeSelectorHint : 0 
+0×26e LdtTableLength   : 0 
+0×270 LdtSystemDescriptor : _KGDTENTRY64 
+0×280 LdtBaseAddress   : (null) 
+0×288 LdtProcessLock   : _FAST_MUTEX 
+0×2c0 InstrumentationCallback : (null) 
We also see that all its threads have a freeze count 1: 
0: kd> !process fffffa8002cb2940 2 
[...] 
THREAD fffffa8001e4eb00 Cid 0c80.0514 Teb: 000007f6c41de000 Win32Thread: 
fffff901000e5b90 WAIT: (Suspended) KernelMode Non-Alertable 
FreezeCount 1 
fffffa8001e4ede0 NotificationEvent 
THREAD fffffa800219c080 Cid 0c80.0d88 Teb: 000007f6c41db000 Win32Thread: 
fffff90103f206e0 WAIT: (Suspended) KernelMode Non-Alertable 
FreezeCount 1 
fffffa800219c360 NotificationEvent 
[...] 
0: kd> dt _KTHREAD fffffa800219c080 
nt!_KTHREAD 
+0x000 Header           : _DISPATCHER_HEADER 
+0x018 SListFaultAddress : (null) 
+0x020 QuantumTarget    : 0x18c26200 
+0x028 InitialStack     : 0xfffff880`1548ddd0 Void 
+0x030 StackLimit       : 0xfffff880`15488000 Void 
+0x038 StackBase        : 0xfffff880`1548e000 Void 
+0x040 ThreadLock       : 0 
+0x048 CycleTime        : 0x15ca97c8 
+0x050 CurrentRunTime   : 0 
+0x054 ExpectedRunTime  : 0xd77e 
+0x058 KernelStack      : 0xfffff880`1548d430 Void 
+0x060 StateSaveArea    : 0xfffff880`1548de00 _XSAVE_FORMAT 
+0x068 SchedulingGroup  : (null) 
+0x070 WaitRegister     : _KWAIT_STATUS_REGISTER 
+0x071 Running          : 0 '' 
+0x072 Alerted          : [2]  "" 
+0x074 KernelStackResident : 0y1 
+0x074 ReadyTransition  : 0y0 
+0x074 ProcessReadyQueue : 0y0 
+0x074 WaitNext         : 0y0 
+0x074 SystemAffinityActive : 0y0 
+0x074 Alertable        : 0y0 
+0x074 CodePatchInProgress : 0y0 
+0x074 UserStackWalkActive : 0y0 
+0x074 ApcInterruptRequest : 0y0 

Frozen Process    147 
+0x074 QuantumEndMigrate : 0y0 
+0x074 UmsDirectedSwitchEnable : 0y0 
+0x074 TimerActive      : 0y0 
+0x074 SystemThread     : 0y0 
+0x074 ProcessDetachActive : 0y0 
+0x074 CalloutActive    : 0y0 
+0x074 ScbReadyQueue    : 0y0 
+0x074 ApcQueueable     : 0y1 
+0x074 ReservedStackInUse : 0y0 
+0x074 UmsPerformingSyscall : 0y0 
+0x074 Reserved         : 0y0000000000000 (0) 
+0x074 MiscFlags        : 0n65537 
+0x078 AutoAlignment    : 0y0 
+0x078 DisableBoost     : 0y0 
+0x078 UserAffinitySet  : 0y0 
+0x078 AlertedByThreadId : 0y0 
+0x078 QuantumDonation  : 0y0 
+0x078 EnableStackSwap  : 0y1 
+0x078 GuiThread        : 0y1 
+0x078 DisableQuantum   : 0y0 
+0x078 ChargeOnlyGroup  : 0y0 
+0x078 DeferPreemption  : 0y0 
+0x078 QueueDeferPreemption : 0y0 
+0x078 ForceDeferSchedule : 0y0 
+0x078 ExplicitIdealProcessor : 0y0 
+0×078 FreezeCount      : 0y1 
+0×078 EtwStackTraceApcInserted : 0y00000000 (0) 
+0×078 ReservedFlags    : 0y0000000000 (0) 
+0×078 ThreadFlags      : 0n8288 
+0×07c Spare0           : 0 
+0×080 SystemCallNumber : 0×87 
+0×084 Spare1           : 0 
+0×088 FirstArgument    : 0×00000000`0000017c Void 
+0×090 TrapFrame        : (null) 
+0×098 ApcState         : _KAPC_STATE 
+0×098 ApcStateFill     : [43]  “???” 
+0×0c3 Priority         : 8 ” 
+0×0c4 UserIdealProcessor : 1 
+0×0c8 WaitStatus       : 0n256 
+0×0d0 WaitBlockList    : 0xfffffa80`0219c1c0 _KWAIT_BLOCK 
+0×0d8 WaitListEntry    : _LIST_ENTRY [ 0xfffffa80`0418a458 - 
0xfffff880`009eb300 ] 
+0×0d8 SwapListEntry    : _SINGLE_LIST_ENTRY 
+0×0e8 Queue            : 0xfffffa80`03da4bc0 _KQUEUE 
+0×0f0 Teb              : 0×000007f6`c41db000 Void 
+0×0f8 RelativeTimerBias : 0×00000001`8b165f54 
+0×100 Timer            : _KTIMER 
+0×140 WaitBlock        : [4] _KWAIT_BLOCK 
+0×140 WaitBlockFill4   : [20]  “h???” 
+0×154 ContextSwitches  : 0×1817 
+0×140 WaitBlockFill5   : [68]  “h???” 
+0×184 State            : 0×5 ” 
+0×185 NpxState         : 1 ” 
+0×186 WaitIrql         : 0 ” 

148    PART 2: Crash Dump Analysis Patterns 
+0×187 WaitMode         : 0 ” 
+0×140 WaitBlockFill6   : [116]  “h???” 
+0×1b4 WaitTime         : 0xf0172e 
+0×140 WaitBlockFill7   : [164]  “h???” 
+0×1e4 KernelApcDisable : 0n0 
+0×1e6 SpecialApcDisable : 0n0 
+0×1e4 CombinedApcDisable : 0 
+0×140 WaitBlockFill8   : [40]  “h???” 
+0×168 ThreadCounters   : (null) 
+0×140 WaitBlockFill9   : [88]  “h???” 
+0×198 XStateSave       : (null) 
+0×140 WaitBlockFill10  : [136]  “h???” 
+0×1c8 Win32Thread      : 0xfffff901`03f206e0 Void 
+0×140 WaitBlockFill11  : [176]  “h???” 
+0×1f0 Ucb              : (null) 
+0×1f8 Uch              : (null) 
+0×200 TebMappedLowVa   : (null) 
+0×208 QueueListEntry   : _LIST_ENTRY [ 0xfffffa80`02ccf408 - 
0xfffffa80`03da4bf0 ] 
+0×218 NextProcessor    : 0 
+0×21c DeferredProcessor : 1 
+0×220 Process          : 0xfffffa80`02cb2940 _KPROCESS 
+0×228 UserAffinity     : _GROUP_AFFINITY 
+0×228 UserAffinityFill : [10]  “???” 
+0×232 PreviousMode     : 1 ” 
+0×233 BasePriority     : 8 ” 
+0×234 PriorityDecrement : 0 ” 
+0×234 ForegroundBoost  : 0y0000 
+0×234 UnusualBoost     : 0y0000 
+0×235 Preempted        : 0 ” 
+0×236 AdjustReason     : 0 ” 
+0×237 AdjustIncrement  : 0 ” 
+0×238 Affinity         : _GROUP_AFFINITY 
+0×238 AffinityFill     : [10]  “???” 
+0×242 ApcStateIndex    : 0 ” 
+0×243 WaitBlockCount   : 0×1 ” 
+0×244 IdealProcessor   : 1 
+0×248 ApcStatePointer  : [2] 0xfffffa80`0219c118 _KAPC_STATE 
+0×258 SavedApcState    : _KAPC_STATE 
+0×258 SavedApcStateFill : [43]  “???” 
+0×283 WaitReason       : 0×5 ” 
+0×284 SuspendCount     : 0 ” 
+0×285 Saturation       : 0 ” 
+0×286 SListFaultCount  : 0 
+0×288 SchedulerApc     : _KAPC 
+0×288 SchedulerApcFill0 : [1]  “??????” 
+0×289 ResourceIndex    : 0×1 ” 
+0×288 SchedulerApcFill1 : [3]  “???” 
+0×28b QuantumReset     : 0×6 ” 
+0×288 SchedulerApcFill2 : [4]  “???” 
+0×28c KernelTime       : 7 
+0×288 SchedulerApcFill3 : [64]  “???” 
+0×2c8 WaitPrcb         : (null) 
+0×288 SchedulerApcFill4 : [72]  “???” 

Frozen Process    149 
+0×2d0 LegoData         : (null) 
+0×288 SchedulerApcFill5 : [83]  “???” 
+0×2db CallbackNestingLevel : 0 ” 
+0×2dc UserTime         : 0xa 
+0×2e0 SuspendEvent     : _KEVENT 
+0×2f8 ThreadListEntry  : _LIST_ENTRY [ 0xfffffa80`01c41378 - 
0xfffffa80`01e4edf8 ] 
+0×308 MutantListHead   : _LIST_ENTRY [ 0xfffffa80`0219c388 - 
0xfffffa80`0219c388 ] 
+0×318 ReadOperationCount : 0n392 
+0×320 WriteOperationCount : 0n321 
+0×328 OtherOperationCount : 0n240 
+0×330 ReadTransferCount : 0n1849338 
+0×338 WriteTransferCount : 0n1197496 
+0×340 OtherTransferCount : 0n4972 
This is different when a process is under a debugger, and all its threads are frozen 
except the one that communicates to the debugger like in the case study from Volume 
4, page 204. In Windows 8 this happens, for example, when we switch to a desktop from 
IE launched from the start page. Then we would see shortly that iexplore.exe process 
changes from Running to Suspended in Task Manager Details page. This pattern covers 
both the new feature and a debugged process case. 
 
 

150    PART 2: Crash Dump Analysis Patterns 
Incomplete Session 
It is a useful pattern for the analysis of memory dumps from terminal services 
environments. Normally, session processes include csrss.exe, winlogon.exe, wfshell.exe 
(in the case of some Citrix products), explorer.exe and a few user defined processes 
such as winword.exe, for example: 
0: kd> !session 
Sessions on machine: 6 
Valid Sessions: 0 1 3 5 6 8 
0: kd> !sprocess 6 
Dumping Session 6 
_MM_SESSION_SPACE fffffa6009447000 
_MMSESSION fffffa6009447b40 
PROCESS fffffa800fcee630 
SessionId: 6 Cid: 1974 Peb: 7fffffd5000 ParentCid: 147c 
DirBase: 158baf000 ObjectTable: fffff8801ef13b00 HandleCount: 532. 
Image: csrss.exe 
PROCESS fffffa800fc77040 
SessionId: 6 Cid: 1ae4 Peb: 7fffffde000 ParentCid: 147c 
DirBase: 15d2b4000 ObjectTable: fffff8802084b570 HandleCount: 238. 
Image: winlogon.exe 
PROCESS fffffa800fe61040 
SessionId: 6 Cid: 1edc Peb: 7efdf000 ParentCid: 1ec8 
DirBase: 14df74000 ObjectTable: fffff88020f486e0 HandleCount: 313. 
Image: wfshell.exe 
PROCESS fffffa800ff5a660 
SessionId: 6 Cid: 2054 Peb: 7fffffdf000 ParentCid: 1dbc 
DirBase: 201a81000 ObjectTable: fffff88020dd56e0 HandleCount: 447. 
Image: explorer.exe 
PROCESS fffffa800fe28040 
SessionId: 6 Cid: 1ce4 Peb: 7efdf000 ParentCid: 13a8 
DirBase: 11f552000 ObjectTable: fffff8801fe96990 HandleCount: 1842. 
Image: WINWORD.EXE 
PROCESS fffffa800f119c10 
SessionId: 6 Cid: 2074 Peb: 7efdf000 ParentCid: 2054 
DirBase: 2d994f000 ObjectTable: fffff8801e76aec0 HandleCount: 673. 
Image: iexplore.exe 
 
 

Incomplete Session    151 
If we compare with the last session #8 we see that the latter has only two processes: 
0: kd> !sprocess 8 
Dumping Session 8 
_MM_SESSION_SPACE fffffa600bafc000 
_MMSESSION fffffa600bafcb40 
PROCESS fffffa80103a4480 
SessionId: 8 Cid: 2858 Peb: 7fffffdf000 ParentCid: 2660 
DirBase: a04bb000 ObjectTable: fffff8801cb926a0 HandleCount: 534. 
Image: csrss.exe 
PROCESS fffffa801065b770 
SessionId: 8 Cid: 2878 Peb: 7fffffdf000 ParentCid: 2660 
DirBase: 5da40000 ObjectTable: fffff8801ce5e440 HandleCount: 235. 
Image: winlogon.exe 
Such anomalies may point to a disconnected session that failed to terminate due 
to some unresponsive session process or a session that is stuck in session initialization 
process launch sequence due to threads blocked in wait chains. Here process threads 
need to be analyzed. 
 
 

152    PART 2: Crash Dump Analysis Patterns 
Error Reporting Fault 
This pattern is about the faults in error reporting infrastructure. The latter should be 
guarded against such faults to avoid recursion. Here is a summary example of such a 
pattern on Windows platforms that involve Windows Error Reporting (WER). 
In a complete memory dump, we notice thousands of WerFault.exe processes: 
0: kd> !process 0 0 
[...] 
PROCESS fffffa8058010380 
SessionId: 2 Cid: 488f0 Peb: 7efdf000 ParentCid: 27cb8 
DirBase: 25640c000 ObjectTable: fffff8a06cd2ac50 HandleCount: 54. 
Image: WerFault.exe 
PROCESS fffffa805bbd5970 
SessionId: 2 Cid: 4801c Peb: 7efdf000 ParentCid: 27cb8 
DirBase: 2c3f69000 ObjectTable: fffff8a040563af0 HandleCount: 54. 
Image: WerFault.exe 
PROCESS fffffa8078aec060 
SessionId: 2 Cid: 3feac Peb: 7efdf000 ParentCid: 488f0 
DirBase: abd200000 ObjectTable: fffff8a07851a0a0 HandleCount: 59. 
Image: WerFault.exe 
PROCESS fffffa805bbe9a10 
SessionId: 2 Cid: 3d8b8 Peb: 7efdf000 ParentCid: 4801c 
DirBase: 261f91000 ObjectTable: fffff8a02d864d40 HandleCount: 56. 
Image: WerFault.exe 
PROCESS fffffa805bd29060 
SessionId: 2 Cid: 1142c Peb: 7efdf000 ParentCid: 3feac 
DirBase: 429fb3000 ObjectTable: fffff8a0355b42e0 HandleCount: 58. 
Image: WerFault.exe 
PROCESS fffffa8053d853d0 
SessionId: 2 Cid: 1fc4c Peb: 7efdf000 ParentCid: 3d8b8 
DirBase: 714371000 ObjectTable: fffff8a01cb6bba0 HandleCount: 58. 
Image: WerFault.exe 
[...] 
Each process has only one thread running through WOW64 modules (Virtualized 
Process, Volume 1, page 400), so we get its 32-bit stack trace: 
 
 

Error Reporting Fault    153 
0: kd> !process fffffa8075c21b30 3f 
[...] 
THREAD fffffa807c183b60 Cid 2d3c8.4334c Teb: 000000007efdb000 Win32Thread: 
fffff900c3f71010 WAIT: (UserRequest) UserMode Non-Alertable 
[...] 
0: kd> .load wow64exts 
0: kd> .process /r /p fffffa8075c21b30 
Implicit process is now fffffa80`75c21b30 
Loading User Symbols 
Loading Wow64 Symbols 
0: kd> .thread /w fffffa807c183b60 
Implicit thread is now fffffa80`7c183b60 
x86 context set 
0: kd:x86> k 
*** Stack trace for last set context - .thread/.cxr resets it 
ChildEBP RetAddr 
000bf474 77080bdd ntdll!ZwWaitForMultipleObjects+0x15 
000bf510 76bb1a2c KERNELBASE!WaitForMultipleObjectsEx+0x100 
000bf558 76bb4208 kernel32!WaitForMultipleObjectsExImplementation+0xe0 
000bf574 76bd80a4 kernel32!WaitForMultipleObjects+0x18 
000bf5e0 76bd7f63 kernel32!WerpReportFaultInternal+0x186 
000bf5f4 76bd7858 kernel32!WerpReportFault+0x70 
000bf604 76bd77d7 kernel32!BasepReportFault+0x20 
000bf690 776674df kernel32!UnhandledExceptionFilter+0x1af 
000bf698 776673bc ntdll!__RtlUserThreadStart+0x62 
000bf6ac 77667261 ntdll!_EH4_CallFilterFunc+0x12 
000bf6d4 7764b459 ntdll!_except_handler4+0x8e 
000bf6f8 7764b42b ntdll!ExecuteHandler2+0x26 
000bf71c 7764b3ce ntdll!ExecuteHandler+0x24 
000bf7a8 77600133 ntdll!RtlDispatchException+0x127 
000bf7b4 000bf7c0 ntdll!KiUserExceptionDispatcher+0xf 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
000bfb00 77629ef2 0xbf7c0 
[...] 
We find exception processing (Exception Stack Trace, Volume 5, page 93) and 
binary value on the stack trace (return address belongs to the stack range). This thread 
is waiting for another process, and it is WerFault.exe too: 
0: kd:x86> .effmach AMD64 
0: kd> !process fffffa8075c21b30 3f 
[...] 
THREAD fffffa807c183b60 Cid 2d3c8.4334c Teb: 000000007efdb000 Win32Thread: 
fffff900c3f71010 WAIT: (UserRequest) UserMode Non-Alertable 
fffffa80809c44e0 ProcessObject 
[...] 

154    PART 2: Crash Dump Analysis Patterns 
0: kd> !process fffffa80809c44e0 
PROCESS fffffa80809c44e0 
SessionId: 2 Cid: 33844 Peb: 7efdf000 ParentCid: 2d3c8 
DirBase: 9c53f0000 ObjectTable: fffff8a0423d4170 HandleCount: 978. 
Image: WerFault.exe 
[...] 
We go back to our original WerFault process and in its PEB data we find it was 
called to report a fault from another process with PID 0n189240: 
0: kd> !process fffffa8075c21b30 3f 
[...] 
CommandLine: 'C:\Windows\SysWOW64\WerFault.exe -u -p 189240 -s 3888′ 
[...] 
And it’s WerFault.exe too: 
0: kd> !process 0n189240 
Searching for Process with Cid == 2e338 
PROCESS fffffa8078b659e0 
SessionId: 2 Cid: 2e338 Peb: 7efdf000 ParentCid: 47608 
DirBase: 201796000 ObjectTable: fffff8a02e664380 HandleCount: 974. 
Image: WerFault.exe 
[...] 
So we see a chain of WerFault.exe processes each processing a fault in the 
previous one. So there should be a first fault somewhere which we can find in Stack 
Trace Collection (Volume 1, page 409, including 32-bit stack traces for this example, 
Volume 5, page 30) unless that exception stack trace was Paged Out (Volume 3, page 
118) due to insufficient memory occupied by WerFault.exe processes. 
 
 

First Fault Stack Trace    155 
First Fault Stack Trace 
The case of Error Reporting Fault chain (page 152) led me to this pattern that 
corresponds to First Fault software diagnostics pattern proper (page 406). Here the 
term first fault is used for an exception that was either ignored by surrounding code or 
led to other exceptions or error message boxes with stack traces that masked the first 
one. Typical examples where it is sometimes possible to get a first exception stack trace 
include but not limited to: 
 
Fault in error reporting (page 152) started as a fault in some other process  
 
Hidden Exception in user (Volume 1, page 271) or kernel (page 140) space  
 
Double Fault (Volume 1, page 314) 
 
Nested Exception in unmanaged (Volume 2, page 305) and managed (Volume 
2, page 310) code  
 
Nested Offender (Volume 4, page 120) 
It is also sometimes possible unless a stack region was paged out (Volume 3, page 
118) to get partial stack traces from Execution Residue (Volume 2, page 239) when the 
sequence of return addresses was partially overwritten by subsequently executed code. 
 
 

156    PART 2: Crash Dump Analysis Patterns 
Hidden Process 
Not all processes are linked into a list that some commands traverse such as !process 0 
0. A process may unlink itself or be in an initialization stage. However, a process 
structure is allocated from the nonpaged pool, and such pool can be searched for ”Proc” 
pool tag (unless a process changes that in memory). For example: 
0: kd> !poolfind Proc 
Searching NonPaged pool (83c3c000 : 8bc00000) for Tag: Proc 
*87b15000 size:  298 previous size:    0  (Free)      Pro. 
*87b18370 size:  298 previous size:   98  (Allocated) Proc (Protected) 
[...] 
*8a35e900 size:  298 previous size:   30  (Allocated) Proc (Protected) 
*8a484000 size:  298 previous size:    0  (Allocated) Proc (Protected) 
*8a4a2d68 size:  298 previous size:   28  (Allocated) Proc (Protected) 
[...] 
One such structure is missing from active process linked list (note that it has a 
parent PID): 
0: kd> !process 8a484000+20 
PROCESS 8a484020  SessionId: 0  Cid: 05a0    Peb: 00000000  ParentCid: 
0244 
DirBase: bffc2200  ObjectTable: e17e6a78  HandleCount:   0. 
Image: AppChild.exe 
VadRoot 8a574f80 Vads 4 Clone 0 Private 3. Modified 0. Locked 0. 
DeviceMap e1002898 
Token                             e1a36030 
ElapsedTime                       00:00:00.000 
UserTime                          00:00:00.000 
KernelTime                        419 Days 13:24:16.625 
QuotaPoolUsage[PagedPool]         7580 
QuotaPoolUsage[NonPagedPool]      160 
Working Set Sizes (now,min,max)  (12, 50, 345) (48KB, 200KB, 1380KB) 
PeakWorkingSetSize                12 
VirtualSize                       1 Mb 
PeakVirtualSize                   1 Mb 
PageFaultCount                    5 
MemoryPriority                    BACKGROUND 
BasePriority                      8 
CommitCharge                      156 
No active threads 
We may think that this process is zombie (note that unlike terminated processes 
it has a non-zero data such as VAD and object table and zero PEB and elapsed time) but 

Hidden Process    157 
inspection of its parent process thread stacks reveals that it was in the process of 
creation (note an attached process field): 
THREAD 8a35dad8  Cid 0244.0248  Teb: 7ffdd000 Win32Thread: bc3aa688 WAIT: 
(Unknown) KernelMode Non-Alertable 
ba971608  NotificationEvent 
Impersonation token:  e2285030 (Level Impersonation) 
DeviceMap                 e1a31a58 
Owning Process            8a35e920       Image:         AppParent.exe 
Attached Process          8a484020       Image:         AppChild.exe 
Wait Start TickCount      2099           Ticks: 1 (0:00:00:00.015) 
Context Switch Count      279                 LargeStack 
UserTime                  00:00:00.046 
KernelTime                00:00:00.046 
Win32 Start Address AppParent!mainCRTStartup (0×0100d303) 
Start Address kernel32!BaseProcessStartThunk (0×77e617f8) 
Stack Init ba972000 Current ba971364 Base ba972000 Limit ba96e000 Call 0 
Priority 8 BasePriority 8 PriorityDecrement 0 
ChildEBP RetAddr 
ba97137c 80833f2d nt!KiSwapContext+0×26 
ba9713a8 80829c72 nt!KiSwapThread+0×2e5 
ba9713f0 bad3c9db nt!KeWaitForSingleObject+0×346 
[...] 
ba971b94 8094cfc3 nt!MmCreatePeb+0×2cc 
ba971ce4 8094d42d nt!PspCreateProcess+0×5a9 
ba971d38 8088b4ac nt!NtCreateProcessEx+0×77 
ba971d38 7c82845c nt!KiFastCallEntry+0xfc (TrapFrame @ ba971d64) 
0006f498 7c826d09 ntdll!KiFastSystemCallRet 
0006f49c 77e6cf95 ntdll!ZwCreateProcessEx+0xc 
0006fcc0 7d1ec670 kernel32!CreateProcessInternalW+0×15e5 
0006fd0c 01008bcf ADVAPI32!CreateProcessAsUserW+0×108 
[...] 
 
 

158    PART 2: Crash Dump Analysis Patterns 
Disk Packet Buildup 
This is similar to Network Packet Buildup (page 82) pattern. It can be detectable either 
through SCSI WinDbg extension or using IRP Distribution Anomaly (Volume 1, page 459) 
pattern: 
0: kd> .load scsikd 
0: kd> !scsikd.classext 
Storage class devices: 
* !classext fffffa80026395b0 [1,2] SAMSUNG HS082HB Paging Disk 
Usage: !classext <class device> <level [0-2]> 
0: kd> !scsikd.classext fffffa80026395b0 
Storage class device fffffa80026395b0 with extension at fffffa8002639700 
Classpnp Internal Information at fffffa8002648010 
-- dt classpnp!_CLASS_PRIVATE_FDO_DATA fffffa8002648010 -- 
Classpnp External Information at fffffa8002639700 
SAMSUNG HS082HB NL100-01 S140JR0SA00025 
Minidriver information at fffffa8002639bc0 
Attached device object at fffffa80017ecda0 
Physical device object at fffffa80024ab060 
Media Geometry: 
Bytes in a Sector = 512 
Sectors per Track = 63 
Tracks / Cylinder = 255 
Media Length      = 80026361856 bytes = ~74 GB 
-- dt classpnp!_FUNCTIONAL_DEVICE_EXTENSION fffffa8002639700 -- 
This is a normal case: 
0: kd> !scsikd.classext fffffa80026395b0 2 
Storage class device fffffa80026395b0 with extension at fffffa8002639700 
Classpnp Internal Information at fffffa8002648010 

Disk Packet Buildup    159 
Transfer Packet Engine: 
Packet          Status  DL Irp          Opcode  Sector/ListId   UL Irp 
--------         ------ --------         ------ --------------- -------- 
fffffa8002648e80  Free  fffffa800249eac0 
fffffa8002644220  Free  fffffa80024aa4f0 
fffffa80026898a0  Free  fffffa80019d2b30 
fffffa800267ad40  Free  fffffa8001801b90 
fffffa800267aa60  Free  fffffa8001835e10 
fffffa8002679010  Free  fffffa80019fac40 
fffffa8002679770  Free  fffffa8002679500 
fffffa80027659a0  Free  fffffa8002764e10 
fffffa8002790e80  Free  fffffa800267a6a0 
fffffa800278f5e0  Free  fffffa80019d53c0 
fffffa8002599410  Free  fffffa8002785600 
fffffa80027f7490  Free  fffffa800278ea00 
fffffa80027f6e80  Free  fffffa80027f6c80 
fffffa80027f69a0  Free  fffffa80027f67a0 
fffffa80027f64c0  Free  fffffa80027f62c0 
fffffa8002dd4440  Free  fffffa80027fc600 
fffffa8002dced30  Free  fffffa8002dceb30 
fffffa8002dce850  Free  fffffa8002ddc010 
fffffa8002ddc530  Free  fffffa8002ddc330 
fffffa8002de2d30  Free  fffffa8002de2b30 
fffffa8002de2850  Free  fffffa8002de2650 
fffffa8002de2370  Free  fffffa8002de2170 
fffffa8002ddbe80  Free  fffffa8002ddbc80 
fffffa8002ddb9a0  Free  fffffa8002ddb7a0 
fffffa8002dda010  Free  fffffa8002ddae10 
[...] 
This is not: 
0: kd> !scsikd.classext fffffa80026395b0 2 
Storage class device fffffa80026395b0 with extension at fffffa8002639700 
Classpnp Internal Information at fffffa8002648010 
Transfer Packet Engine: 
Packet           Status DL Irp           Opcode Sector   UL Irp 
--------         ------ --------         ------ -------- -------- 
fffffa80c71d9560 Queued fffffa80c71d9360   2a   03cbb948 fffffa80c4f269d0 \FileName 
fffffa80c77a3360 Queued fffffa80c77a3160   2a   0400f0a8 fffffa80c59c1010 \FileName 
fffffa80c6cefe60 Queued fffffa80c6cefc60   2a   0400f128 fffffa80c59c1010 \FileName 
fffffa80c6e92260 Queued fffffa80c4f80010   2a   0400f1e8 fffffa80c59c1010 \FileName 
fffffa80c79dbca0 Queued fffffa80c79dbaa0   2a   0400c4e8 fffffa80c59c1010 \FileName 
fffffa80c83f2d90 Queued fffffa80c3b23bc0   2a   0400f168 fffffa80c59c1010 \FileName 
fffffa80c4a94640 Queued fffffa80c4a94440   2a   0400d5e8 fffffa80c59c1010 \FileName 
fffffa80c7984010 Queued fffffa80c7984210   2a   0400d328 fffffa80c59c1010 \FileName 
fffffa80c6e52be0 Queued fffffa80c6e529e0   2a   0400f1a8 fffffa80c59c1010 \FileName 
fffffa80c7afada0 Queued fffffa80c7afaba0   2a   04010268 fffffa80c59c1010 \FileName 
fffffa80c7c19d90 Queued fffffa80ca2c5e10   2a   0400c628 fffffa80c59c1010 \FileName 

160    PART 2: Crash Dump Analysis Patterns 
fffffa80c6182d60 Queued fffffa80c6182b60   2a   0400f9a8 fffffa80c59c1010 \FileName 
fffffa80c8695ba0 Queued fffffa80c86959a0   2a   0400d128 fffffa80c59c1010 \FileName 
fffffa80c6b42b40 Queued fffffa80c6b42940   2a   0400ed28 fffffa80c59c1010 \FileName 
fffffa80c5e1ab00 Queued fffffa80c5e1a900   2a   0400eee8 fffffa80c59c1010 \FileName 
fffffa80c5d80a30 Queued fffffa80c4841e10   2a   0400fba8 fffffa80c59c1010 \FileName 
fffffa80c48255d0 Queued fffffa80c48253d0   2a   040119e8 fffffa80c59c1010 \FileName 
fffffa80c718a270 Queued fffffa80c47d0010   2a   0400d1e8 fffffa80c59c1010 \FileName 
fffffa80c51a94b0 Queued fffffa80c51a92b0   2a   0400bd28 fffffa80c59c1010 \FileName 
fffffa80ca280990 Queued fffffa80c52b2930   2a   0400d268 fffffa80c59c1010 \FileName 
fffffa80c586f280 Queued fffffa80c551fe10   2a   0400f068 fffffa80c59c1010 \FileName 
fffffa80c8413540 Queued fffffa80c544ae10   2a   04011a68 fffffa80c59c1010 \FileName 
fffffa80c544ac60 Queued fffffa80c535ba90   2a   0400e7e8 fffffa80c59c1010 \FileName 
fffffa80c4678010 Queued fffffa80c4678230   2a   04011168 fffffa80c59c1010 \FileName 
fffffa80c9d94be0 Queued fffffa80c59205e0   2a   0400d4a8 fffffa80c59c1010 \FileName 
fffffa80c5920430 Queued fffffa80c59248f0   2a   0400ea68 fffffa80c59c1010 \FileName 
fffffa80c737e8f0 Queued fffffa80c737e6f0   2a   0400fee8 fffffa80c59c1010 \FileName 
fffffa80c4797c60 Queued fffffa80c5d31800   2a   0400f328 fffffa80c59c1010 \FileName 
fffffa80c711d270 Queued fffffa80c76ee390   2a   0400eaa8 fffffa80c59c1010 \FileName 
fffffa80c872dba0 Queued fffffa80c872d9a0   2a   0400eb28 fffffa80c59c1010 \FileName 
fffffa80c9e67d10 Queued fffffa80c9e67b10   2a   04012168 fffffa80c59c1010 \FileName 
fffffa80ca3bb350 Queued fffffa80c66e4370   2a   0400c928 fffffa80c59c1010 \FileName 
fffffa80c5894ab0 Queued fffffa80c58948b0   2a   0400c368 fffffa80c59c1010 \FileName 
fffffa80c305fe60 Queued fffffa80c305fc60   2a   04013168 fffffa80c59c1010 \FileName 
fffffa80c496cce0 Queued fffffa80c496cae0   2a   0400d168 fffffa80c59c1010 \FileName 
fffffa80c5e78c60 Queued fffffa80c905c7f0   2a   0400f8a8 fffffa80c59c1010 \FileName 
fffffa80c905c640 Queued fffffa80c5c1c410   2a   0400f428 fffffa80c59c1010 \FileName 
fffffa80c68ffc40 Queued fffffa80c68ffa40   2a   0400f468 fffffa80c59c1010 \FileName 
fffffa80c3aa3e60 Queued fffffa80c3aa3c60   2a   0400c7a8 fffffa80c59c1010 \FileName 
fffffa80c5e8dc60 Queued fffffa80c8852cf0   2a   0400f4a8 fffffa80c59c1010 \FileName 
fffffa80c90082b0 Queued fffffa80c7907440   2a   04013428 fffffa80c59c1010 \FileName 
fffffa80c7907290 Queued fffffa80c67aea80   2a   0400fe68 fffffa80c59c1010 \FileName 
fffffa80c67ae8d0 Queued fffffa80c9383cf0   2a   0400f3a8 fffffa80c59c1010 \FileName 
fffffa80c8497010 Queued fffffa80c8497270   2a   0400c5e8 fffffa80c59c1010 \FileName 
fffffa80c78c7480 Queued fffffa80c78c7280   2a   0400c3e8 fffffa80c59c1010 \FileName 
fffffa80c7f37d90 Queued fffffa80c618b480   2a   0400cce8 fffffa80c59c1010 \FileName 
fffffa80c618b2d0 Queued fffffa80ca2e9e10   2a   0400ee28 fffffa80c59c1010 \FileName 
fffffa80ca2e9c60 Queued fffffa80c5e783f0   2a   0400d8e8 fffffa80c59c1010 \FileName 
fffffa80c64e1650 Queued fffffa80c64e1450   2a   0400d0e8 fffffa80c59c1010 \FileName 
fffffa80c684dd60 Queued fffffa80c684db60   2a   0400c6a8 fffffa80c59c1010 \FileName 
fffffa80c3b2bac0 Queued fffffa80c3b2b8c0   2a   040127a8 fffffa80c59c1010 \FileName 
fffffa80c5ff64d0 Queued fffffa80c5ff62d0   2a   0400de68 fffffa80c59c1010 \FileName 
fffffa80c99a84b0 Queued fffffa80c99a82b0   2a   0400cfe8 fffffa80c59c1010 \FileName 
fffffa80ca300510 Queued fffffa80ca300310   2a   0400c168 fffffa80c59c1010 \FileName 
[...] 
 
 

Deviant Token    161 
Deviant Token 
Sometimes we need to check under what security principal or group we run a process or 
what privileges it has or whether it has impersonating threads. We may find an 
unexpected token with a different security identifier, for example, Network Service 
instead of Local System (SID: S-1-5-18): 
PROCESS 8f218d88  SessionId: 0  Cid: 09c4    Peb: 7ffdf000  ParentCid: 
0240 
DirBase: bffd4260  ObjectTable: e10eae90  HandleCount:  93. 
Image: ServiceA.exe 
VadRoot 8f1f70e8 Vads 141 Clone 0 Private 477. Modified 2. Locked 0. 
DeviceMap e10038d8 
Token                             e10ff5d8 
[...] 
0: kd> !token e10ff5d8 
_TOKEN e10ff5d8 
TS Session ID: 0 
User: S-1-5-20 
[...] 
Well-known SIDs can be found in this MS article:  
http://support.microsoft.com/kb/243330 
 
 

162    PART 2: Crash Dump Analysis Patterns 
Module Collection 
In addition to Stack Trace Collection (Volume 1, page 409) we often are interested in 
Module Collection (we initially called this pattern Vendor Collection), especially if we 
would like to check whether a particular vendor DLL is present in some process address 
space in a complete memory dump (kernel module list or module list from a process 
memory dump is trivial). Or we need to check for some vendor information from a 
problem description (lmv command). If we have a complete memory dump from x64 
system then listing modules for each process is not enough. For example, we might have 
this: 
0: kd> lmu 
start             end                 module name 
00000000`00ab0000 00000000`00ae8000   AppA    (deferred) 
00000000`74fe0000 00000000`7502e000   wow64win   (deferred) 
00000000`75030000 00000000`75075000   wow64      (deferred) 
00000000`750c0000 00000000`750c9000   wow64cpu   (deferred) 
00000000`77b70000 00000000`77cf7000   ntdll      (pdb symbols) 
AppA is a 32-bit process and has an additional 32-bit module list that is more 
useful. We can set x86 context for a thread from that process and get the list of 32-bit 
modules: 
0: kd> .load wow64exts 
0: kd> .thread /w fffffa800e372060 
Implicit thread is now fffffa80`0e372060 
x86 context set 
0: kd:x86> .reload 
Loading Kernel Symbols 
Loading User Symbols 
Loading unloaded module list 
Loading Wow64 Symbols 
0: kd:x86> lmu 
start             end                 module name 
00000000`00ab0000 00000000`00ae8000   AppA    (deferred) 
00000000`73490000 00000000`73515000   COMCTL32   (deferred) 
00000000`73520000 00000000`735c3000   MSVCR90    (deferred) 
00000000`735d0000 00000000`7365e000   MSVCP90    (deferred) 
00000000`74920000 00000000`7493e000   USERENV    (deferred) 
00000000`74940000 00000000`74ade000   comctl32_74940000   (deferred) 
00000000`74af0000 00000000`74b02000   MSASN1     (deferred) 
00000000`74b10000 00000000`74c03000   CRYPT32    (deferred) 
00000000`74dc0000 00000000`74e5b000   MSVCR80    (deferred) 
00000000`74f60000 00000000`74fd6000   NETAPI32   (deferred) 

Module Collection    163 
00000000`74fe0000 00000000`7502e000   wow64win   (deferred) 
00000000`75030000 00000000`75075000   wow64      (deferred) 
00000000`750b0000 00000000`750ba000   WTSAPI32   (deferred) 
00000000`750c0000 00000000`750c9000   wow64cpu   (deferred) 
00000000`75cf0000 00000000`75d50000   Secur32    (deferred) 
00000000`75d50000 00000000`76861000   SHELL32    (deferred) 
00000000`76a10000 00000000`76aa0000   GDI32      (deferred) 
00000000`76b30000 00000000`76b90000   IMM32      (deferred) 
00000000`76be0000 00000000`76cf0000   kernel32   (deferred) 
00000000`76e30000 00000000`76f75000   ole32      (deferred) 
00000000`76f80000 00000000`7702a000   msvcrt     (deferred) 
00000000`77030000 00000000`77037000   PSAPI      (deferred) 
00000000`77040000 00000000`77110000   USER32     (deferred) 
00000000`77110000 00000000`77169000   SHLWAPI    (deferred) 
00000000`77170000 00000000`771ed000   USP10      (deferred) 
00000000`77380000 00000000`7740d000   OLEAUT32   (deferred) 
00000000`77640000 00000000`77649000   LPK        (deferred) 
00000000`776e0000 00000000`777d0000   RPCRT4     (deferred) 
00000000`777d0000 00000000`77898000   MSCTF      (deferred) 
00000000`778a0000 00000000`77966000   ADVAPI32   (deferred) 
00000000`77b70000 00000000`77cf7000   ntdll      (pdb symbols) 
00000000`77d30000 00000000`77e90000   ntdll_77d30000 # (pdb symbols) 
So it looks like we need to dump modules for each thread. However, the output 
would be enormous unless we skip threads having the same PID. After some tinkering 
we wrote this WinDbg script with moderate output volume: 
.load wow64exts 
!for_each_thread ".thread @#Thread; .if (@$t0 != @@c++(@$thread-
>Cid.UniqueProcess)) {.reload /user;lmvu;.thread /w @#Thread;.reload 
/user;lmvu;r $t0 = @@c++(@$thread->Cid.UniqueProcess);.effmach AMD64; }" 
 
 

164    PART 2: Crash Dump Analysis Patterns 
Handle Leak 
Although a handle leak may lead to Insufficient Memory (Volume 1, page 327), it is not 
always the case especially if pool structures are small such as events. So we describe 
another pattern called Handle Leak that covers high memory usage (including fat 
structures), high handle counts and also abnormal differences in allocations and 
deallocations. As an example of the latter here is a nonpaged pool leak of Event 
objects and correlated pooltag ABCD. Although memory usage footprint is small 
compared with other nonleaking pooltags we see that the difference between Allocs 
and Frees is surely abnormal and correlating with high handle counts: 
0: kd> !poolused 3 
Sorting by  NonPaged Pool Consumed 
Pool Used: 
NonPaged                    Paged 
Tag    Allocs    Frees     Diff     Used   Allocs    Frees     Diff     Used 
[...] 
ABCD  1778517  1704538    73979  4734656        0        0        0        0 UNKNOWN 
pooltag ‘ABCD’, please update pooltag.txt 
Even  6129633  6063728    65905  4224528        0        0        0        0 Event 
objects 
[...] 
0: kd> !process 0 0 
[...] 
PROCESS d2b85360  SessionId: 2  Cid: 1bf4    Peb: 7ffdf000  ParentCid: 
1688 
DirBase: 7d778dc0  ObjectTable: e53dda08  HandleCount: 18539. 
Image: AppA.exe 
PROCESS b2fcd670  SessionId: 2  Cid: 0818    Peb: 
7ffd4000  ParentCid: 1688 
DirBase: 7d778400  ObjectTable: b3ffd8c0  HandleCount: 36252. 
Image: AppB.exe 
[...] 
 
 

Critical Stack Trace    165 
Critical Stack Trace 
This pattern addresses abnormal behavior such as page fault processing or any other 
critical system activity that is waiting for too long. Such activity either finishes quickly or 
leads to normal bugcheck processing code. For example, this thread is stuck in page 
fault processing for 32 minutes while loading a resource: 
THREAD fffffa80f0603c00  Cid 376.3d6  Teb: 000007fffffd6000 Win32Thread: fffff900c09e0640 WAIT: 
(Executive) KernelMode Non-Alertable 
[...] 
Wait Start TickCount      6281298        Ticks: 123391 (0:00:32:04.102) 
[...] 
Child-SP          RetAddr           Call Site 
fffff880`3fc99030 fffff800`01882bd2 nt!KiSwapContext+0×7a 
fffff880`3fc99170 fffff800`01893f8f nt!KiCommitThreadWait+0×1d2 
fffff880`3fc99200 fffff880`016283ff nt!KeWaitForSingleObject+0×19f 
fffff880`3fc992a0 fffff880`01620fc6 Ntfs!NtfsNonCachedIo+0×23f 
fffff880`3fc99470 fffff880`01622a68 Ntfs!NtfsCommonRead+0×7a6 
fffff880`3fc99610 fffff880`00fb4bcf Ntfs!NtfsFsdRead+0×1b8 
fffff880`3fc99820 fffff880`00fb36df fltmgr!FltpLegacyProcessingAfterPreCallbacksCompleted+0×24f 
fffff880`3fc998b0 fffff800`018b44f5 fltmgr!FltpDispatch+0xcf 
fffff880`3fc999a0 fffff800`018b3fc9 nt!IoPageRead+0×255 
fffff880`3fc99a30 fffff800`0189a85a nt!MiIssueHardFault+0×255 
fffff880`3fc99ac0 fffff800`0188b2ee nt!MmAccessFault+0×146a 
fffff880`3fc99c20 00000000`779da643 nt!KiPageFault+0×16e (TrapFrame @ fffff880`3fd99c20) 
00000000`039ff4f0 00000000`779d8b1e ntdll!LdrpGetRcConfig+0xcd 
00000000`039ff580 00000000`779da222 ntdll!LdrIsResItemExist+0×1e 
00000000`039ff5c0 00000000`779f82c4 ntdll!LdrpSearchResourceSection_U+0xa4 
00000000`039ff6e0 000007fe`fe0075c1 ntdll!LdrFindResource_U+0×44 
00000000`039ff720 000007fe`fb217777 KERNELBASE!FindResourceExW+0×85 
[...] 
The Top (Volume 6, page 62) Blocking Module (Volume 6, page 64) is NTFS so we 
might want to look for other similar stack traces from Stack Trace Collection (Volume 6, 
page 409). 
 
 

166    PART 2: Crash Dump Analysis Patterns 
Debugger Omission 
Whereas some false positives can be considered soft Debugger Bugs (page 90) false 
negatives can have more severe impact on software behavior analysis especially in 
malware analysis. A typical example here is the current version of .imgscan command 
which according to the documentation should by default scan virtual process space for 
MZ/PE signatures. Unfortunately it doesn’t detect such signatures in resource pages (we 
haven’t checked stack regions yet): 
0000000000fd0000 image base 
SECTION HEADER #4 
.rsrc name 
6430 virtual size 
4000 virtual address 
6600 size of raw data 
1600 file pointer to raw data 
0 file pointer to relocation table 
0 file pointer to line numbers 
0 number of relocations 
0 number of line numbers 
40000040 flags 
Initialized Data 
(no align specified) 
Read Only 
0:000> .imgscan /r 00000000`00fd4000 L200 
0:000> s -[l2]sa 00000000`00fd4000 l200 
00000000`00fd40b0  "MZ" 
00000000`00fd40fd  "!This program cannot be run in D" 
00000000`00fd411d  "OS mode." 
00000000`00fd4188  "Rich" 
00000000`00fd4198  "PE" 
0:000> !dh 00000000`00fd40b0 
File Type: DLL 
FILE HEADER VALUES 
14C machine (i386) 
3 number of sections 
time date stamp Fri Jan 18 21:27:25 2013 
0 file pointer to symbol table 
0 number of symbols 
E0 size of optional header 
2102 characteristics 
Executable 

Debugger Omission    167 
32 bit word machine 
DLL 
[...] 
Other analysis scenarios include !analyze -v that shows us a breakpoint instead of 
an exception violation from a parallel thread. 
 
 

168    PART 2: Crash Dump Analysis Patterns 
Broken Link 
Sometimes we have a broken linked list for some reason, either from memory 
corruption, Lateral Damage (Volume 1, page 264) or Truncated Dump (Volume 1, page 
340). For example, an active process list enumeration stopped after showing some 
processes (!for_each_thread and !vm also don’t work): 
0: kd> !process 0 3f 
[...] 
TYPE mismatch for process object at fffffa80041da5c0 
0: kd> !validatelist nt!PsActiveProcessHead 
Blink at address fffffa80041da748 does not point back to previous at fffffa8005bc8cb8 
Here we can either try to repair or navigate links manually or use other means 
such as dumping pool allocations for process structures with Proc pool tag: 
0: kd> !poolfind Proc 
Searching NonPaged pool (fffffa80032fc000 : ffffffe000000000) for Tag: Proc 
*fffffa80033879a0 size:  510 previous size:   a0  (Allocated) Proc (Protected) 
*fffffa80033ffad0 size:  530 previous size:  280  (Allocated) Proc (Protected) 
*fffffa80041a2af0 size:  510 previous size:   90  (Allocated) Proc (Protected) 
*fffffa800439c5c0 size:  530 previous size:   80  (Allocated) Proc (Protected) 
[...] 
*fffffa8007475ad0 size:  530 previous size:   30  (Allocated) Proc (Protected) 
*fffffa80074e8490 size:  530 previous size:  100  (Allocated) Proc (Protected) 
*fffffa80075ee0b0 size:  530 previous size:   b0  (Free)      Pro. 
*fffffa800761d000 size:  530 previous size:    0  (Free)      Pro. 
*fffffa8007645ad0 size:  530 previous size:   b0  (Allocated) Proc (Protected) 
0: kd> dc fffffa8007645ad0 
fffffa80`07645ad0  0253000b e36f7250 07644030 fffffa80  ..S.Pro.0.d..... 
fffffa80`07645ae0  00001000 00000528 00000068 fffff800  ....(...h....... 
fffffa80`07645af0  01a1a940 fffff800 00080090 00490024  @...........$.I. 
fffffa80`07645b00  000000c4 00000000 00000008 00000000  ................ 
fffffa80`07645b10  00000000 00000000 00080007 00300033  ............3.0. 
fffffa80`07645b20  01a1a940 fffff800 013cfeae fffff8a0  @.........<..... 
fffffa80`07645b30  00580003 00000000 05ba19a0 fffffa80  ..X............. 
fffffa80`07645b40  05ba19a0 fffffa80 07645b48 fffffa80  ........H[d..... 
 
 

Broken Link    169 
0: kd> !process fffffa80`07645b30 3f 
PROCESS fffffa8007645b30 
SessionId: 0  Cid: 14c4    Peb: 7fffffd4000  ParentCid: 02c4 
DirBase: 7233e000  ObjectTable: fffff8a0014d4220  HandleCount: 399. 
Image: AppA.exe 
VadRoot fffffa80072bc5b0 Vads 239 Clone 0 Private 24675. Modified 23838. Locked 0. 
DeviceMap fffff8a0000088f0 
Token                             fffff8a000f28060 
ElapsedTime                       00:00:53.066 
UserTime                          00:00:00.000 
KernelTime                        00:00:00.000 
QuotaPoolUsage[PagedPool]         0 
QuotaPoolUsage[NonPagedPool]      0 
Working Set Sizes (now,min,max)  (11960, 50, 345) (47840KB, 200KB, 1380KB) 
PeakWorkingSetSize                74346 
VirtualSize                       331 Mb 
PeakVirtualSize                   478 Mb 
PageFaultCount                    92214 
MemoryPriority                    BACKGROUND 
BasePriority                      8 
CommitCharge                      25905 
[...] 
 
 

170    PART 2: Crash Dump Analysis Patterns 
Wait Chain (Pushlocks) 
Here we provide examples of threads waiting for pushlocks18 as they are not normally 
seen in crash dumps: 
THREAD fffffa80033b5b50  Cid 0004.0030  Teb: 0000000000000000 Win32Thread: 
0000000000000000 WAIT: (WrPushLock) KernelMode Non-Alertable 
fffff880021d9750  SynchronizationEvent 
Not impersonating 
DeviceMap                 fffff8a0000088f0 
Owning Process            fffffa80033879e0       Image:         System 
Attached Process          fffffa800439c620       Image:         AppA.exe 
Wait Start TickCount      30819          Ticks: 14746574 (2:15:54:08.028) 
Context Switch Count      2800 
UserTime                  00:00:00.000 
KernelTime                00:00:00.374 
Win32 Start Address nt!ExpWorkerThread (0xfffff8000189e530) 
Stack Init fffff880021d9db0 Current fffff880021d9470 
Base fffff880021da000 Limit fffff880021d4000 Call 0 
Priority 12 BasePriority 12 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 
PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff880`021d94b0 fffff800`0188aa32 nt!KiSwapContext+0×7a 
fffff880`021d95f0 fffff800`0189bd8f nt!KiCommitThreadWait+0×1d2 
fffff880`021d9680 fffff800`018c4bf8 nt!KeWaitForSingleObject+0×19f 
fffff880`021d9720 fffff800`01c2915d nt!ExfAcquirePushLockShared+0×138 
fffff880`021d97a0 fffff800`01c6da31 nt!MmEnumerateAndReferenceImages+0×6d 
[...] 
fffff880`021d9cb0 fffff800`01b2be5a nt!ExpWorkerThread+0×111 
fffff880`021d9d40 fffff800`01885d26 nt!PspSystemThreadStartup+0×5a 
fffff880`021d9d80 00000000`00000000 nt!KxStartSystemThread+0×16 
 
 
                                                                 
18  http://blogs.msdn.com/b/ntdebugging/archive/2009/09/02/push-locks-what-
are-they.aspx 

Wait Chain (Pushlocks)    171 
THREAD fffffa8003c9d600  Cid 0004.00ac  Teb: 0000000000000000 Win32Thread: 
0000000000000000 WAIT: (WrPushLock) KernelMode Non-Alertable 
fffff880023d1b30  SynchronizationEvent 
Not impersonating 
DeviceMap                 fffff8a0000088f0 
Owning Process            fffffa80033879e0       Image:         System 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      177686         Ticks: 14599707 (2:15:15:56.888) 
Context Switch Count      1590 
UserTime                  00:00:00.000 
KernelTime                00:00:00.124 
Win32 Start Address 0xfffff80001bac754 
Stack Init fffff880023d1db0 Current fffff880023d1850 
Base fffff880023d2000 Limit fffff880023cc000 Call 0 
Priority 15 BasePriority 15 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 
PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff880`023d1890 fffff800`0188aa32 nt!KiSwapContext+0×7a 
fffff880`023d19d0 fffff800`0189bd8f nt!KiCommitThreadWait+0×1d2 
fffff880`023d1a60 fffff800`01886183 nt!KeWaitForSingleObject+0×19f 
fffff880`023d1b00 fffff800`01cd9982 nt!ExfAcquirePushLockExclusive+0×188 
[...] 
fffff880`023d1d40 fffff800`01885d26 nt!PspSystemThreadStartup+0×5a 
fffff880`023d1d80 00000000`00000000 nt!KxStartSystemThread+0×16 
 
 

172    PART 2: Crash Dump Analysis Patterns 
Insufficient Memory (Session Pool) 
Although we briefly mentioned session pool in Insufficient Memory (kernel pool) 
pattern (Volume 1, page 441) we decided to factor it into a separate (sub)pattern and 
provide WinDbg commands to analyze possible leaks. The following output shows the 
sequence of commands that gives you an idea although the example itself was taken 
from a healthy dump so no bold emphasis (we had seen leaks in session pool happening 
mostly in 32-bit cases): 
1: kd> !vm 4 
Terminal Server Memory Usage By Session: 
Session ID 0 @ fffff8800324d000: 
Paged Pool Usage:        4128K 
Commit Usage:            7488K 
Session ID 1 @ fffff88002f65000: 
Paged Pool Usage:       32852K 
Commit Usage:           36488K 
1: kd> !session 
Sessions on machine: 2 
Valid Sessions: 0 1 
Error in reading current session 
1: kd> !session -s 1 
Sessions on machine: 2 
Implicit process is now fffffa80`07d79730 
Using session 1 
1: kd> !poolused 8 
Sorting by Session Tag 
Pool Used: 
NonPaged            Paged 
Tag    Allocs     Used    Allocs     Used 
TOTAL           4     4208      9500 33475120 
[...] 
 
 

Step Dumps    173 
Step Dumps 
It is common to get dozens of process memory dumps saved sequentially, for example,  
after each second. Then we can first analyze memory dumps corresponding to changes 
in their file sizes ignoring plateaus to save analysis time. This pattern is called by analogy 
with step functions19. For example, we have this dump set with comments from WinDbg 
analysis sessions (it was reported that an application was freezing for some time until its 
disappearance from a user screen): 
C:\MemoryDumps>dir 
[...] 
12/30/2012  8:33 PM  218,252,862 AppA-1.dmp // normal 
12/30/2012  8:34 PM  218,541,762 AppA-2.dmp // slightly increased CPU 
consumption for thread #11 
12/30/2012  8:37 PM  218,735,848 AppA-3.dmp // spiking thread #11 
12/30/2012  8:38 PM  218,735,848 AppA-4.dmp 
12/30/2012  8:38 PM  218,735,848 AppA-5.dmp 
12/30/2012  8:39 PM  218,735,848 AppA-6.dmp 
12/30/2012  8:39 PM  218,735,848 AppA-7.dmp 
12/30/2012  8:39 PM  218,735,848 AppA-8.dmp 
12/30/2012  8:40 PM  218,735,848 AppA-9.dmp 
12/30/2012  8:40 PM  218,735,848 AppA-10.dmp 
12/30/2012  8:41 PM  218,735,848 AppA-11.dmp  
12/30/2012  8:41 PM  218,735,848 AppA-12.dmp // spiking thread #11 
12/30/2012  8:42 PM  219,749,040 AppA-13.dmp // spiking thread 
#11, another thread blocked in ALPC 
12/30/2012  8:42 PM  219,048,842 AppA-14.dmp // only one thread left 
[...] 
 
 
                                                                 
19 http://en.wikipedia.org/wiki/Step_function 

174    PART 2: Crash Dump Analysis Patterns 
Reduced Symbolic Information 
Sometimes we have reduced symbolic information for modules which can range from 
stripped or public symbol files to exported only function names. In such cases we can 
use API function prototypes, structure definitions and possible String Parameters 
(Volume 6, page 49) to make sense of function arguments: 
0:000:x86> kv 
ChildEBP RetAddr  Args to Child 
0013fe34 75a1790d 0013fe74 00000000 00000000 user32!NtUserGetMessage+0x15 
0013fe50 00fc148a 0013fe74 00000000 00000000 user32!GetMessageW+0×33 
0013fe90 00fc16ec 00fc0000 00000000 00354082 notepad!WinMain+0xe6 
0013ff20 758233aa 7efde000 0013ff6c 77059ef2 notepad!_initterm_e+0×1a1 
0013ff2c 77059ef2 7efde000 57785ae5 00000000 kernel32!BaseThreadInitThunk+0xe 
0013ff6c 77059ec5 00fc3689 7efde000 00000000 ntdll_77020000!__RtlUserThreadStart+0×70 
0013ff84 00000000 00fc3689 7efde000 00000000 ntdll_77020000!_RtlUserThreadStart+0×1b 
The first parameter of GetMessage API is a pointer to MSG structure: 
0:000:x86> dt MSG 0013fe74 
Symbol MSG not found. 
From MSDN, we find this structure definition: 
typedef struct tagMSG { 
    HWND   hwnd; 
    UINT   message; 
    WPARAM wParam; 
    LPARAM lParam; 
    DWORD  time; 
    POINT  pt; 
} MSG, *PMSG, *LPMSG; 
 
0:000:x86> dc 0013fe74 L7 
0013fe74  0007149c 00000113 0038a508 7287c5d6  ..........8....r 
0013fe84  2079a177 00000539 000001c0           w.y 9....... 
 
 

Injected Symbols    175 
Injected Symbols 
This pattern can be used to add missing symbols when we have Reduced Symbolic 
Information (page 174) as it was done previously in this old case study (Volume 1, page 
199). For example, TestWER20 module was compiled with static MFC and CRT libraries 
and its private PDB file contains all necessary symbols including MSG structure. We can 
load that module into notepad.exe process space and apply symbols: 
0:000:x86> lm 
start             end                 module name 
00fc0000 00ff0000   notepad    (pdb 
symbols)          c:\mss\notepad.pdb\E325F5195AE94FAEB58D25C9DF8C0CFD2\notepad.pdb 
10000000 10039000   WinCRT     (deferred) 
727f0000 7298e000   comctl32   (deferred) 
72aa0000 72af1000   winspool   (deferred) 
72b10000 72b19000   version    (deferred) 
72e40000 72e48000   wow64cpu   (deferred) 
72e50000 72eac000   wow64win   (pdb 
symbols)          c:\mss\wow64win.pdb\B2D08CC152D64E71B79167DC0A0A53E91\wow64win.pdb 
72eb0000 72eef000   wow64      (deferred) 
733d0000 733e3000   dwmapi     (deferred) 
735b0000 73606000   uxtheme    (deferred) 
746f0000 746fc000   CRYPTBASE   (deferred) 
74700000 74760000   sspicli    (deferred) 
747c0000 74817000   shlwapi    (deferred) 
74830000 7547a000   shell32    (deferred) 
755d0000 7564b000   comdlg32   (deferred) 
75650000 7567e000   imm32      (deferred) 
75770000 75810000   advapi32   (deferred) 
75810000 75920000   kernel32   (pdb 
symbols)         c:\mss\wkernel32.pdb\1C690A8592304467BB15A09CEA7180FA2\wkernel32.pdb 
75920000 759b0000   gdi32      (deferred) 
759b0000 759f7000   KERNELBASE   (deferred) 
75a00000 75b00000   user32     (pdb 
symbols)          c:\mss\wuser32.pdb\0FCE9CC301ED4567A819705B2718E1D62\wuser32.pdb 
75b00000 75b8f000   oleaut32   (deferred) 
75be0000 75c7d000   usp10      (deferred) 
75ff0000 76009000   sechost    (deferred) 
76010000 76100000   rpcrt4     (deferred) 
76230000 762dc000   msvcrt     (deferred) 
76470000 7647a000   lpk        (deferred) 
76480000 7654c000   msctf      (deferred) 
76550000 766ac000   ole32      (deferred) 
766d0000 76753000   clbcatq    (deferred) 
76e40000 76fe9000   ntdll      (deferred) 
77020000 771a0000   ntdll_77020000   (pdb 
symbols)          c:\mss\wntdll.pdb\D74F79EB1F8D4A45ABCD2F476CCABACC2\wntdll.pdb 
 
 
                                                                 
20 http://support.citrix.com/article/CTX111901 

176    PART 2: Crash Dump Analysis Patterns 
0:000:x86> .sympath+ C:\DebuggingTV\TestWER\x86 
Symbol search path is: srv*;C:\DebuggingTV\TestWER\x86 
Expanded Symbol search path is: 
SRV*c:\mss*http://msdl.microsoft.com/download/symbols;c:\debuggingtv\testwer\x86 
0:000:x86> .reload /f /i C:\DebuggingTV\TestWER\x86\TestWER.exe=10000000 
0:000:x86> lm 
start             end                 module name 
00fc0000 00ff0000   notepad    (pdb 
symbols)          c:\mss\notepad.pdb\E325F5195AE94FAEB58D25C9DF8C0CFD2\notepad.pdb 
10000000 10039000   TestWER    (private pdb 
symbols)  c:\debuggingtv\testwer\x86\TestWER.pdb 
727f0000 7298e000   comctl32   (deferred) 
72aa0000 72af1000   winspool   (deferred) 
72b10000 72b19000   version    (deferred) 
72e40000 72e48000   wow64cpu   (deferred) 
72e50000 72eac000   wow64win   (pdb 
symbols)          c:\mss\wow64win.pdb\B2D08CC152D64E71B79167DC0A0A53E91\wow64win.pdb 
72eb0000 72eef000   wow64      (deferred) 
733d0000 733e3000   dwmapi     (deferred) 
735b0000 73606000   uxtheme    (deferred) 
746f0000 746fc000   CRYPTBASE   (deferred) 
74700000 74760000   sspicli    (deferred) 
747c0000 74817000   shlwapi    (deferred) 
74830000 7547a000   shell32    (deferred) 
755d0000 7564b000   comdlg32   (deferred) 
75650000 7567e000   imm32      (deferred) 
75770000 75810000   advapi32   (deferred) 
75810000 75920000   kernel32   (pdb 
symbols)         c:\mss\wkernel32.pdb\1C690A8592304467BB15A09CEA7180FA2\wkernel32.pdb 
75920000 759b0000   gdi32      (deferred) 
759b0000 759f7000   KERNELBASE   (deferred) 
75a00000 75b00000   user32     (pdb 
symbols)          c:\mss\wuser32.pdb\0FCE9CC301ED4567A819705B2718E1D62\wuser32.pdb 
75b00000 75b8f000   oleaut32   (deferred) 
75be0000 75c7d000   usp10      (deferred) 
75ff0000 76009000   sechost    (deferred) 
76010000 76100000   rpcrt4     (deferred) 
76230000 762dc000   msvcrt     (deferred) 
76470000 7647a000   lpk        (deferred) 
76480000 7654c000   msctf      (deferred) 
76550000 766ac000   ole32      (deferred) 
766d0000 76753000   clbcatq    (deferred) 
76e40000 76fe9000   ntdll      (deferred) 
77020000 771a0000   ntdll_77020000   (pdb 
symbols)          c:\mss\wntdll.pdb\D74F79EB1F8D4A45ABCD2F476CCABACC2\wntdll.pdb 
0:000:x86> kv 
ChildEBP RetAddr  Args to Child 
0013fe34 75a1790d 0013fe74 00000000 00000000 user32!NtUserGetMessage+0x15 
0013fe50 00fc148a 0013fe74 00000000 00000000 user32!GetMessageW+0×33 
0013fe90 00fc16ec 00fc0000 00000000 00354082 notepad!WinMain+0xe6 
0013ff20 758233aa 7efde000 0013ff6c 77059ef2 notepad!_initterm_e+0×1a1 
0013ff2c 77059ef2 7efde000 57785ae5 00000000 kernel32!BaseThreadInitThunk+0xe 
0013ff6c 77059ec5 00fc3689 7efde000 00000000 ntdll_77020000!__RtlUserThreadStart+0×70 
0013ff84 00000000 00fc3689 7efde000 00000000 ntdll_77020000!_RtlUserThreadStart+0×1b 
 
 

Injected Symbols    177 
0:000:x86> dt -r MSG 0013fe74 
TestWER!MSG 
  +0x000 hwnd             : 0x0007149c HWND__ 
    +0x000 unused           : ?? 
  +0×004 message          : 0×113 
  +0×008 wParam           : 0×38a508 
  +0×00c lParam           : 0n1921500630 
  +0×010 time             : 0×2079a177 
  +0×014 pt               : tagPOINT 
    +0×000 x                : 0n1337 
    +0×004 y                : 0n448 
 
 

178    PART 2: Crash Dump Analysis Patterns 
Glued Stack Trace 
Sometimes we have Truncated Stack Trace (Volume 6, page 86) and need to perform 
manual stack trace reconstruction (Volume 1, page 157) of the missing part to get 
approximate full stack trace. Often we are only able to reconstruct some parts and glue 
them together perhaps with some missing intermediate frames: 

Glued Stack Trace    179 
Stack Limit
Stack Base
 

180    PART 2: Crash Dump Analysis Patterns 
For example, we have this truncated stack trace due to the lack of symbols: 
1: kd> k 
ChildEBP RetAddr 
97543b6c 85adf579 nt!KiTrap0E+0x2ac 
WARNING: Stack unwind information not available. Following frames may be 
wrong. 
97543be8 85adf770 myfault+0x579 
97543bf4 85adf7fc myfault+0x770 
97543c2c 81827ecf myfault+0x7fc 
97543c44 81988f65 nt!IofCallDriver+0x63 
97543c64 81989f25 nt!IopSynchronousServiceTail+0x1e0 
97543d00 8198ee8d nt!IopXxxControlFile+0x6b7 
97543d34 8188c96a nt!NtDeviceIoControlFile+0x2a 
97543d34 77510f34 nt!KiFastCallEntry+0x12a 
0012f9a0 7750f850 ntdll!KiFastSystemCallRet 
0012f9a4 77417c92 ntdll!NtDeviceIoControlFile+0xc 
0012fa04 00401a5b kernel32!DeviceIoControl+0x14a 
0012fa94 7700becf NotMyfault+0x1a5b 
0012facc 00000000 USER32!xxxDrawButton+0xc1 
Manual stack reconstruction brings this fragment: 
1: kd> k L=0012fb94 0012fb94 0012fb94 
ChildEBP RetAddr 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
0012fb94 77001ae8 0x12fb94 
0012fc0c 7700286a USER32!UserCallWinProcCheckWow+0x14b 
0012fc4c 77002bba USER32!SendMessageWorker+0x4b7 
0012fc6c 7700c6b4 USER32!SendMessageW+0x7c 
0012fc84 7700c7c9 USER32!xxxButtonNotifyParent+0x41 
0012fca0 7700c7e8 USER32!xxxBNReleaseCapture+0xf7 
0012fd24 7701632e USER32!ButtonWndProcWorker+0x910 
0012fd44 77001a10 USER32!ButtonWndProcA+0x4c 
0012fd70 77001ae8 USER32!InternalCallWinProc+0x23 
0012fde8 77002a47 USER32!UserCallWinProcCheckWow+0x14b 
0012fe4c 77002a98 USER32!DispatchMessageWorker+0x322 
0012fe5c 76ff11fc USER32!DispatchMessageW+0xf 
0012fe80 76fe98d2 USER32!IsDialogMessageW+0x586 
0012fea0 00401cc9 USER32!IsDialogMessageA+0xff 
0012ff10 004022ec NotMyfault+0x1cc9 
00000000 00000000 NotMyfault+0x22ec 
And finally we get the 3rd usual thread start fragment: 
1: kd> k L=0012ffa0 0012ffa0 0012ffa0 
ChildEBP RetAddr 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
0012ffa0 77413833 0x12ffa0 
0012ffac 774ea9bd kernel32!BaseThreadInitThunk+0xe 
0012ffec 00000000 ntdll!_RtlUserThreadStart+0x23 

Glued Stack Trace    181 
Gluing them together we get this approx. stack trace: 
97543b6c 85adf579 nt!KiTrap0E+0x2ac 
WARNING: Stack unwind information not available. Following frames may be 
wrong. 
97543be8 85adf770 myfault+0x579 
97543bf4 85adf7fc myfault+0x770 
97543c2c 81827ecf myfault+0x7fc 
97543c44 81988f65 nt!IofCallDriver+0x63 
97543c64 81989f25 nt!IopSynchronousServiceTail+0x1e0 
97543d00 8198ee8d nt!IopXxxControlFile+0x6b7 
97543d34 8188c96a nt!NtDeviceIoControlFile+0x2a 
97543d34 77510f34 nt!KiFastCallEntry+0x12a 
0012f9a0 7750f850 ntdll!KiFastSystemCallRet 
0012f9a4 77417c92 ntdll!NtDeviceIoControlFile+0xc 
0012fa04 00401a5b kernel32!DeviceIoControl+0x14a 
0012fa94 7700becf NotMyfault+0x1a5b 
0012fc0c 7700286a USER32!UserCallWinProcCheckWow+0x14b 
0012fc4c 77002bba USER32!SendMessageWorker+0x4b7 
0012fc6c 7700c6b4 USER32!SendMessageW+0x7c 
0012fc84 7700c7c9 USER32!xxxButtonNotifyParent+0x41 
0012fca0 7700c7e8 USER32!xxxBNReleaseCapture+0xf7 
0012fd24 7701632e USER32!ButtonWndProcWorker+0x910 
0012fd44 77001a10 USER32!ButtonWndProcA+0x4c 
0012fd70 77001ae8 USER32!InternalCallWinProc+0x23 
0012fde8 77002a47 USER32!UserCallWinProcCheckWow+0x14b 
0012fe4c 77002a98 USER32!DispatchMessageWorker+0x322 
0012fe5c 76ff11fc USER32!DispatchMessageW+0xf 
0012fe80 76fe98d2 USER32!IsDialogMessageW+0x586 
0012fea0 00401cc9 USER32!IsDialogMessageA+0xff 
0012ff10 004022ec NotMyfault+0x1cc9 
0012ffac 774ea9bd kernel32!BaseThreadInitThunk+0xe 
0012ffec 00000000 ntdll!_RtlUserThreadStart+0x23 
 
 

182    PART 2: Crash Dump Analysis Patterns 
Distributed Wait Chain 
All previous Wait Chain patterns (Volume 3, page 383) were about single wait chains. 
However, it is often a case when there are many different wait chains in a memory 
dump, especially in terminal services environments. There can be ALPC and critical 
section wait chains at the same time. They can be related or completely disjoint. 
Distributed Wait Chain pattern covers a special case of several wait chains having the 
same structure (and possibly pointing in one direction). One such example we put 
below. In Stack Trace Collection (Volume 1, page 409) from a complete memory dump 
from a hanging system we found several explorer.exe processes with critical section 
Wait Chains (Volume 1, page 490) having the same structure and endpoint of Top 
(Volume 6, page 62) and Blocking (Volume 6, page 54) ModuleA: 
THREAD fffffa80137cf060  Cid 4884.4f9c  Teb: 000007fffffaa000 Win32Thread: fffff900c0fb98b0 WAIT: 
(UserRequest) UserMode Non-Alertable 
    fffffa8013570dc0  SynchronizationEvent 
Not impersonating 
DeviceMap                 fffff8a014e21d90 
Owning Process            fffffa80131a75d0       Image:         explorer.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      274752         Ticks: 212448 (0:00:55:19.500) 
Context Switch Count      9889                 LargeStack 
UserTime                  00:00:00.093 
KernelTime                00:00:00.171 
Win32 Start Address SHLWAPI!WrapperThreadProc (0×000007fefdafc608) 
Stack Init fffff88013c25db0 Current fffff88013c25900 
Base fffff88013c26000 Limit fffff88013c1b000 Call 0 
Priority 11 BasePriority 9 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
Kernel stack not resident. 
Child-SP          RetAddr           Call Site 
fffff880`13c25940 fffff800`01873652 nt!KiSwapContext+0×7a 
fffff880`13c25a80 fffff800`01884a9f nt!KiCommitThreadWait+0×1d2 
fffff880`13c25b10 fffff800`01b7768e nt!KeWaitForSingleObject+0×19f 
fffff880`13c25bb0 fffff800`0187ced3 nt!NtWaitForSingleObject+0xde 
fffff880`13c25c20 00000000`76d8135a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ fffff880`13c25c20) 
00000000`0489e518 00000000`76d7e4e8 ntdll!ZwWaitForSingleObject+0xa 
00000000`0489e520 00000000`76d7e3db ntdll!RtlpWaitOnCriticalSection+0xe8 
00000000`0489e5d0 000007fe`fdf8ff50 ntdll!RtlEnterCriticalSection+0xd1 
00000000`0489e600 000007fe`fdf8fbd3 SHELL32!CFSFolder::GetIconOf+0×24b 
00000000`0489f3a0 000007fe`fdf903d3 SHELL32!SHGetIconIndexFromPIDL+0×3f 
00000000`0489f3d0 00000000`ff900328 SHELL32!SHMapIDListToSystemImageListIndexAsync+0×73 
00000000`0489f470 00000000`ff8fff4b Explorer!SFTBarHost::AddImageForItem+0×9c 
00000000`0489f4d0 00000000`ff8fd2f1 Explorer!SFTBarHost::_InternalRepopulateList+0×4ad 
00000000`0489f5d0 00000000`ff8fd0b4 Explorer!SFTBarHost::_RepopulateList+0×1f3 
00000000`0489f600 00000000`ff8fcccd Explorer!SFTBarHost::_OnBackgroundEnumDone+0xc1 
00000000`0489f630 00000000`ff8fc9e2 Explorer!SFTBarHost::_WndProc+0×451 
00000000`0489f680 00000000`76669bd1 Explorer!SFTBarHost::_WndProc_ProgramsMFU+0×1b 
00000000`0489f6b0 00000000`766698da USER32!UserCallWinProcCheckWow+0×1ad 
00000000`0489f770 00000000`ff8f1177 USER32!DispatchMessageWorker+0×3b5 
00000000`0489f7f0 00000000`ff9130e9 Explorer!CTray::_MessageLoop+0×446 
00000000`0489f880 000007fe`fdafc71e Explorer!CTray::MainThreadProc+0×8a 
00000000`0489f8b0 00000000`76c2652d SHLWAPI!WrapperThreadProc+0×19b 
00000000`0489f9b0 00000000`76d5c521 kernel32!BaseThreadInitThunk+0xd 
00000000`0489f9e0 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
0: kd> .process /r /p fffffa80131a75d0 
Implicit process is now fffffa80`131a75d0 
Loading User Symbols 

Distributed Wait Chain    183 
0: kd> !cs -l -o -s 
----------------------------------------- 
DebugInfo          = 0x0000000000499d90 
Critical section   = 0x000007fefe3d5900 (SHELL32!g_csIconCache+0x0) 
LOCKED 
LockCount          = 0×2 
WaiterWoken        = No 
OwningThread       = 0×0000000000002b34 
RecursionCount     = 0×1 
LockSemaphore      = 0×7F8 
SpinCount          = 0×0000000000000000 
OwningThread       = .thread fffffa8013dc3b00 
THREAD fffffa8013dc3b00  Cid 4884.2b34  Teb: 000007fffffac000 Win32Thread: fffff900c2bc1010 WAIT: 
(Executive) KernelMode Non-Alertable 
    fffff88011c03600  SynchronizationEvent 
IRP List: 
    fffffa800f8fc790: (0006,0430) Flags: 00000404  Mdl: 00000000 
Not impersonating 
DeviceMap                 fffff8a014e21d90 
Owning Process            fffffa80131a75d0       Image:         explorer.exe 
Attached Process          N/A            Image:         N/A 
Wait Start TickCount      170052         Ticks: 317148 (0:01:22:35.437) 
Context Switch Count      2                 LargeStack 
UserTime                  00:00:00.000 
KernelTime                00:00:00.000 
Win32 Start Address SHELL32!ShutdownThreadProc (0x000007fefe13ef54) 
Stack Init fffff88011c03db0 Current fffff88011c03320 
Base fffff88011c04000 Limit fffff88011bfd000 Call 0 
Priority 11 BasePriority 8 UnusualBoost 0 ForegroundBoost 2 IoPriority 2 PagePriority 5 
Child-SP          RetAddr           Call Site 
fffff880`11c03360 fffff800`01873652 nt!KiSwapContext+0x7a 
fffff880`11c034a0 fffff800`01884a9f nt!KiCommitThreadWait+0x1d2 
fffff880`11c03530 fffff880`05c12383 nt!KeWaitForSingleObject+0x19f 
fffff880`11c035d0 fffff880`012b9288 ModuleA+0×12468 
fffff880`11c03750 fffff880`012b7d1b fltmgr!FltpPerformPostCallbacks+0×368 
fffff880`11c03820 fffff880`012b66df fltmgr!FltpLegacyProcessingAfterPreCallbacksCompleted+0×39b 
fffff880`11c038b0 fffff880`01b895ff fltmgr!FltpDispatch+0xcf 
fffff880`11c03a30 fffff800`01b783b4 nt!IopCloseFile+0×11f 
fffff880`11c03ac0 fffff800`01b78171 nt!ObpDecrementHandleCount+0xb4 
fffff880`11c03b40 fffff800`01b78734 nt!ObpCloseHandleTableEntry+0xb1 
fffff880`11c03bd0 fffff800`0187ced3 nt!ObpCloseHandle+0×94 
fffff880`11c03c20 00000000`76d8140a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ fffff880`11c03c20) 
00000000`0754f348 000007fe`fd341873 ntdll!NtClose+0xa 
00000000`0754f350 00000000`76c32f51 KERNELBASE!CloseHandle+0×13 
00000000`0754f380 000007fe`fdaf9690 kernel32!CloseHandleImplementation+0×3d 
00000000`0754f490 000007fe`fe191d7f SHLWAPI!CFileStream::Release+0×84 
00000000`0754f4c0 000007fe`fe13ed57 SHELL32!IconCacheSave+0×2b7 
00000000`0754f780 000007fe`fe13f0c6 SHELL32!CommonRestart+0×2f 
00000000`0754f7f0 00000000`76c2652d SHELL32!ShutdownThreadProc+0×172 
00000000`0754f820 00000000`76d5c521 kernel32!BaseThreadInitThunk+0xd 
00000000`0754f850 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
 
 

184    PART 2: Crash Dump Analysis Patterns 
Ubiquitous Component (Kernel Space) 
This is a kernel space counterpart of Ubiquitous Component (Volume 4, page 94) 
pattern. Such a component (especially when it is Top Module, Volume 6, page 62) can 
be a sign of Wait Chain(s) (Volume 1, page 482) and Blocking Module (Volume 6, page 
54) and if it is present in the same process names - a sign of Distributed Wait Chain 
(page 182). 
0: kd> !stacks 0 ModuleA 
Proc.Thread  .Thread  Ticks   ThreadState Blocker 
                            [fffffa800e673b30 svchost.exe] 
 534.006240  fffffa801388f5f0 fffd41d9 Blocked    ModuleA+0x12468 
                            [fffffa800e705b30 svchost.exe] 
 630.000e14  fffffa800edacb50 fffdcf7a Blocked    ModuleA+0x12468 
 630.000f04  fffffa8012c2fb50 fffdcf49 Blocked    ModuleA+0x12468 
 630.006610  fffffa80134f5b50 fffdcf46 Blocked    ModuleA+0x12468 
 630.001cfc  fffffa800f55a2d0 fffdcf44 Blocked    ModuleA+0x12468 
 630.003db8  fffffa80121f1540 fffdcf43 Blocked    ModuleA+0x12468 
 630.000b9c  fffffa80133d1780 fffdcf3c Blocked    ModuleA+0x12468 
 630.0041c4  fffffa8013c77b50 fffdcf43 Blocked    ModuleA+0x12468 
 630.00641c  fffffa8012476b50 fffdcf43 Blocked    ModuleA+0x12468 
 630.006424  fffffa8013207b50 fffdcf40 Blocked    ModuleA+0x12468 
 630.002fcc  fffffa80128f9060 fffdcf3e Blocked    ModuleA+0x12468 
 630.003de8  fffffa80139edb50 fffdcf3d Blocked    ModuleA+0x12468 
 630.0062c4  fffffa800f5ff2d0 fffdcf3c Blocked    ModuleA+0x12468 
 630.0065e8  fffffa80139dcb50 fffdcf3b Blocked    ModuleA+0x12468 
 630.004524  fffffa8011e51b50 fffdcf3a Blocked    ModuleA+0x12468 
 630.004570  fffffa801346b060 fffdcf39 Blocked    ModuleA+0x12468 
 630.00173c  fffffa8010b99b50 fffdcf39 Blocked    ModuleA+0x12468 
                            [fffffa800f63db30 iexplore.exe] 
24c4.0024c8  fffffa800fe854e0 fffcb6cf Blocked    ModuleA+0x12468 
                            [fffffa8010b9ab30 explorer.exe] 
2b64.0043d0  fffffa8012e8ab00 fffd9095 Blocked    ModuleA+0x12468 
                            [fffffa800fe55060 explorer.exe] 
2c80.002e58  fffffa8012e75060 fffba7af Blocked    ModuleA+0x12468 
                            [fffffa8010c54b30 iexplore.exe] 
2e3c.002e98  fffffa8010c75620 fffcbb7f Blocked    ModuleA+0x12468 
                            [fffffa80111c3720 iexplore.exe] 
32d8.003230  fffffa80111b1b00 fffd41d9 Blocked    ModuleA+0x12468 

Ubiquitous Component (Kernel Space)    185 
                            [fffffa80110cb690 iexplore.exe] 
2e74.002854  fffffa8011121b00 fffbe8a4 Blocked    ModuleA+0x12468 
                            [fffffa801146cb30 OUTLOOK.EXE] 
35cc.0035e8  fffffa8013831b00 fffaf33a Blocked    ModuleA+0x12468 
                            [fffffa80105a5640 OUTLOOK.EXE] 
3858.00385c  fffffa801133ab00 fffd3691 Blocked    ModuleA+0x12468 
                            [fffffa8011998060 explorer.exe] 
3d70.004a0c  fffffa80139ddb00 fffd0482 Blocked    ModuleA+0x12468 
                            [fffffa8010ff5850 OUTLOOK.EXE] 
3540.000458  fffffa8011052b00 fffbd007 Blocked    ModuleA+0x12468 
                            [fffffa8011d3d060 OUTLOOK.EXE] 
49f8.0049fc  fffffa8011c78060 fffdbbf9 Blocked    ModuleA+0x12468 
                            [fffffa801241b060 OUTLOOK.EXE] 
4888.005af0  fffffa8012e8eab0 fffae442 Blocked    ModuleA+0x12468 
4888.003d24  fffffa800eca7b00 fffae443 Blocked    ModuleA+0x12468 
                            [fffffa8012687b30 explorer.exe] 
5048.0051fc  fffffa801129cb00 fffca8bf Blocked    ModuleA+0x12468 
                            [fffffa8011c1e060 OUTLOOK.EXE] 
52c4.00117c  fffffa80130f8710 fffaa157 Blocked    ModuleA+0x12468 
52c4.0045fc  fffffa801374f060 fffaa15e Blocked    ModuleA+0x12468 
                            [fffffa8011c42b30 explorer.exe] 
5898.0001ec  fffffa80137a1b00 fffd8da0 Blocked    ModuleA+0x12468 
                            [fffffa8012e04b30 OUTLOOK.EXE] 
5a74.004954  fffffa8012e05060 fffa9ff8 Blocked    ModuleA+0x12468 
                            [fffffa8010908b30 spoolsv.exe] 
2724.004190  fffffa8011ea1060 fffdcafb Blocked    ModuleA+0x12468 
                            [fffffa801206eb30 WerFault.exe] 
3e50.005424  fffffa8013c5eb00 fffdcf39 Blocked    ModuleA+0x12468 
                            [fffffa800f8cf2a0 WerFault.exe] 
 9f4.00570c  fffffa8013c8ab00 fffdca9f Blocked    ModuleA+0x12468 
                            [fffffa8013af1060 WerFault.exe] 
3c74.002b80  fffffa8013c5c060 fffd9dc8 Blocked    ModuleA+0x12468 
                            [fffffa800f8053a0 WINWORD.EXE] 
3dd0.0066a8  fffffa800ce618c0 fffd7c02 Blocked    ModuleA+0x12468 

186    PART 2: Crash Dump Analysis Patterns 
                            [fffffa8010b66b30 WINWORD.EXE] 
62a4.001934  fffffa801368c430 fffd7ce7 Blocked    ModuleA+0x12468 
                            [fffffa80141dc060 WerFault.exe] 
17d0.0052e4  fffffa801347a060 fffd57b8 Blocked    ModuleA+0x12468 
                            [fffffa8012629760 WerFault.exe] 
621c.005b64  fffffa8011e395d0 fffc8dc2 Blocked    ModuleA+0x12468 
                            [fffffa80131a75d0 explorer.exe] 
4884.002b34  fffffa8013dc3b00 fffd67bc Blocked    ModuleA+0x12468 
[...] 
Threads Processed: 5948 
 
 

One-Thread Process    187 
One-Thread Process 
Processes with one thread like Notepad are rare. Such a process is always suspicious 
especially if it is a service or belongs to a complex product. Usually, this happens when 
all other threads terminated, and the remaining thread is blocked in some wait chain. 
For example, this process has a thread which is blocked (Volume 6, page 34) in an ALPC 
request to itself (the same process): 
0: kd> !process fffffa8013ed9b30 3f 
PROCESS fffffa8013ed9b30 
    SessionId: 0  Cid: 44b4    Peb: 7fffffd8000  ParentCid: 0114 
    DirBase: 2da448000  ObjectTable: fffff8a01948c670  HandleCount: 660. 
    Image: ServiceA.exe 
    VadRoot fffffa801356dd10 Vads 398 Clone 0 Private 5795. Modified 204253. Locked 0. 
    DeviceMap fffff8a000008340 
    Token                             fffff8a01b546060 
    ElapsedTime                       01:32:37.622 
    UserTime                          00:00:01.421 
    KernelTime                        00:00:01.578 
    QuotaPoolUsage[PagedPool]         0 
    QuotaPoolUsage[NonPagedPool]      0 
    Working Set Sizes (now,min,max)  (1525, 50, 345) (6100KB, 200KB, 1380KB) 
    PeakWorkingSetSize                7607 
    VirtualSize                       178 Mb 
    PeakVirtualSize                   182 Mb 
    PageFaultCount                    752709 
    MemoryPriority                    BACKGROUND 
    BasePriority                      8 
    CommitCharge                      8043 
        THREAD fffffa8012caab50  Cid 44b4.4f70  Teb: 000007fffff5a000 Win32Thread: 0000000000000000 
WAIT: (WrLpcReply) KernelMode Non-Alertable 
            fffffa8012caaf18  Semaphore Limit 0x1 
        Waiting for reply to ALPC Message fffff8a0194d4780 : queued at port fffffa8012911c80 : 
owned by process fffffa8013ed9b30 
        IRP List: 
            fffffa8013923300: (0006,0118) Flags: 00060000  Mdl: 00000000 
        Not impersonating 
        DeviceMap                 fffff8a000008340 
        Owning Process            fffffa8013ed9b30       Image:         ServiceA.exe 
        Attached Process          N/A            Image:         N/A 
        Wait Start TickCount      139828         Ticks: 347372 (0:01:30:27.687) 
        Context Switch Count      7380             
        UserTime                  00:00:00.031 
        KernelTime                00:00:04.890 
        Win32 Start Address ServiceA (0×00000001401156e0) 
        Stack Init fffff88014c9ddb0 Current fffff88014c9c6b0 
        Base fffff88014c9e000 Limit fffff88014c98000 Call 0 
        Priority 8 BasePriority 8 UnusualBoost 0 ForegroundBoost 0 IoPriority 2 PagePriority 5 
        Child-SP          RetAddr           Call Site 
        fffff880`14c9c6f0 fffff800`01873652 nt!KiSwapContext+0×7a 
        fffff880`14c9c830 fffff800`01884a9f nt!KiCommitThreadWait+0×1d2 
        fffff880`14c9c8c0 fffff800`0189f04f nt!KeWaitForSingleObject+0×19f 
        fffff880`14c9c960 fffff800`01b919f6 nt!AlpcpSignalAndWait+0×8f 
        fffff880`14c9ca10 fffff800`01b910f0 nt!AlpcpReceiveSynchronousReply+0×46 
        fffff880`14c9ca70 fffff800`01b9519d nt!AlpcpProcessSynchronousRequest+0×33d 
        fffff880`14c9cbb0 fffff800`01b95276 nt!LpcpRequestWaitReplyPort+0×9c 
        fffff880`14c9cc10 fffff800`0187ced3 nt!NtRequestWaitReplyPort+0×76 
        fffff880`14c9cc60 fffff800`01879490 nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`14c9cc60) 
        fffff880`14c9cdf8 fffff880`05c31050 nt!KiServiceLinkage 
        fffff880`14c9ce70 fffff880`045ce005 ModuleA+0×12468 
        [...] 
        fffff880`14c9da10 fffff800`01b9d3b6 nt!IopXxxControlFile+0×607 

188    PART 2: Crash Dump Analysis Patterns 
        fffff880`14c9db40 fffff800`0187ced3 nt!NtDeviceIoControlFile+0×56 
        fffff880`14c9dbb0 00000000`76d8138a nt!KiSystemServiceCopyEnd+0×13 (TrapFrame @ 
fffff880`14c9dc20) 
        00000000`082af028 000007fe`fd366cf6 ntdll!NtDeviceIoControlFile+0xa 
        00000000`082af030 00000000`76c2683f KERNELBASE!TlsGetValue+0×1a36 
        00000000`082af0a0 00000001`4019d38c kernel32!DeviceIoControlImplementation+0×7f 
        [...] 
 
 
 

Module Product Process    189 
Module Product Process 
If we found module related patterns (page 510) in a complete memory dump and 
suspect a particular module it may be worth looking at module product related process 
if it exists especially if this module (component, DLL) has product information or some 
related hint (lmv or !lmi commands). In complex environments, such modules may be 
loaded not only by hooking mechanisms but also as plugins. If we are not sure whether 
there is such a process the best way is to get Module Collection (page 162) and find a 
process module that has the same vendor as the module in question. Then such process 
should also be analyzed for anomalies. 
 
 

190    PART 2: Crash Dump Analysis Patterns 
Crash Signature Invariant 
Sometimes there are crashes in multiplatform products where only some portion 
of Crash Signature (Volume 6, page 37) is similar, for example: 
x86: cmp dword ptr [eax], 1 
x64: cmp dword ptr [r10]. 1 
One crash dump had the following condensed stack trace:  
0: kd> kc 
DriverA 
win32k!DrvSetMonitorPowerState 
win32k!xxxSysCommand 
win32k!xxxRealDefWindowProc 
win32k!NtUserfnNCDESTROY 
win32k!NtUserMessageCall 
nt!KiSystemServiceCopyEnd 
With the following faulting instruction: 
DriverA+0x1234: 
cmp     dword ptr [r11],1 ds:002b:00000000`00000000=???????? 
A search for DriverA led to this x86 crash analyzed some time ago: 
0: kd> kc 
DriverA 
nt!IopfCallDriver 
win32k!GreDeviceIoControl 
win32k!DrvSetMonitorPowerState 
win32k!xxxSysCommand 
win32k!xxxRealDefWindowProc 
win32k!xxxWrapRealDefWindowProc 
win32k!NtUserfnNCDESTROY 
win32k!NtUserMessageCall 
nt!KiSystemServicePostCall 
0: kd> r 
DtiverA+0x1423: 
cmp     dword ptr [ecx],1    ds:0023:00000000=???????? 
We see common function names on both stack traces and overall flow is the 
same (only three functions are omitted in x64 trace); we see the same NULL pointer 
dereference for the same comparison instruction with the same comparison operand, 
#1. 

Small Values    191 
Small Values 
Sometimes we see the so-called Small Values in memory (such as on raw stack) or in 
CPU registers which can be ASCII or UNICODE value, some ID or even a handle. When in 
aggregates, they can form a certain Semantic Structure (Volume 6, page 73) such as a 
PID.TID example or Regular Data (page 106) pattern. Here we illustrate a handle 
example (also an example of Wait Chain analysis in user space, Volume 1, page 482): 
0:000> kv 
Child-SP          RetAddr           : Args to 
Child                                                           : Call Site 
00000000`0016de78 000007fe`fcf010dc : 00000000`02c79fa0 00000000`08c3faf0 
00000000`021551f0 00000000`08c3fb00 : ntdll!NtWaitForSingleObject+0xa 
00000000`0016de80 000007fe`f90e6d7f : 00000000`10b40010 00000000`10b40010 
00000000`00000000 00000000`000007e0 : KERNELBASE!WaitForSingleObjectEx+0×79 
[...] 
0:000> !handle 00000000`000007e0 ff 
Handle 00000000000007d0 
  Type          Thread 
  Attributes    0 
  GrantedAccess 0x1fffff: 
         Delete,ReadControl,WriteDac,WriteOwner,Synch 
         Terminate,Suspend,Alert,GetContext,SetContext,SetInfo,QueryInfo,SetToken, 
Impersonate,DirectImpersonate 
  HandleCount   5 
  PointerCount  9 
  Name          <none> 
  Object specific information 
    Thread Id   278c.a58 
    Priority    13 
    Base Priority 0 
0:000> ~~[a58]s 
ntdll!NtWaitForMultipleObjects+0xa: 
00000000`770c186a c3              ret 
0:002> kv 
Child-SP          RetAddr           : Args to 
Child                                                           : Call Site 
00000000`0f6af758 000007fe`fcf01430 : 00000000`00000025 00000000`00000000 
00000000`00000000 000007fe`e35a1fb0 : ntdll!NtWaitForMultipleObjects+0xa 
00000000`0f6af760 00000000`76e61220 : 00000000`0f6af8a8 00000000`0f6af890 
00000000`00000000 00000000`00000000 : KERNELBASE!WaitForMultipleObjectsEx+0xe8 
[...] 
0:002> dp 00000000`0f6af890 L4 
00000000`0f6af890  00000000`00000dbc 00000000`000007c0 
00000000`0f6af8a0  00000000`00000000 00000000`00000000 
 
 

192    PART 2: Crash Dump Analysis Patterns 
0:002> !handle dbc ff 
Handle 0000000000000dbc 
  Type          Thread 
  Attributes    0 
  GrantedAccess 0x1fffff: 
         Delete,ReadControl,WriteDac,WriteOwner,Synch 
         Terminate,Suspend,Alert,GetContext,SetContext,SetInfo,QueryInfo,SetToken, 
Impersonate,DirectImpersonate 
  HandleCount   2 
  PointerCount  4 
  Name          <none> 
  Object specific information 
    Thread Id   278c.24ac 
    Priority    14 
    Base Priority 0 
0:002> !handle 7c0 ff 
Handle 00000000000007c0 
  Type          Thread 
  Attributes    0 
  GrantedAccess 0x1fffff: 
         Delete,ReadControl,WriteDac,WriteOwner,Synch 
         Terminate,Suspend,Alert,GetContext,SetContext,SetInfo,QueryInfo,SetToken, 
Impersonate,DirectImpersonate 
  HandleCount   2 
  PointerCount  4 
  Name          <none> 
  Object specific information 
    Thread Id   278c.628 
    Priority    14 
    Base Priority 0 
 
 

Shared Structure    193 
Shared Structure 
Sometimes we look at Stack Trace Collection (Volume 1, page 409) or it’s predicate 
subset (page 100) and recognize that one of the parameters is actually the same 
structure address or handle. In x64 case we may possibly see it from the return address 
backward disassembly (ub WinDbg command) but in x86 case most of the time we can 
spot that directly from the verbose stack trace, like in the snippet below (unless a 
parameter memory slot was reused, Optimized Code, Volume 1, page 265): 
THREAD 830f9990 Cid 0428.0e94 Teb: 7ffdf000 Win32Thread: 00000000 WAIT: (UserRequest) 
UserMode Non-Alertable 
[...] 
ChildEBP RetAddr  Args to Child 
0031f74c 7784b071 00000000 00000000 7ffdb000 ntdll!RtlpWaitOnCriticalSection+0x154 
0031f774 00a91150 00a9b7a8 00000000 00a91452 ntdll!RtlEnterCriticalSection+0×152 
WARNING: Stack unwind information not available. Following frames may be wrong. 
0031f7c8 76113833 7ffdb000 0031f814 7784a9bd Application+0×1150 
0031f7d4 7784a9bd 7ffdb000 003114bf 00000000 kernel32!BaseThreadInitThunk+0xe 
0031f814 00000000 00a914a9 7ffdb000 00000000 ntdll!_RtlUserThreadStart+0×23 
THREAD 886ee030 Cid 0428.0ef4 Teb: 7ffde000 Win32Thread: 00000000 WAIT: (UserRequest) 
UserMode Non-Alertable 
[...] 
ChildEBP RetAddr  Args to Child 
0098fcb8 77f881b1 00000000 00000000 001614a0 ntdll!RtlpUnWaitCriticalSection+0x1b 
0098fce0 00a9102e 00a9b7a8 00000000 00000000 ntdll!RtlEnterCriticalSection+0×152 
WARNING: Stack unwind information not available. Following frames may be wrong. 
0098fd28 00a91275 0098fd3c 76113833 001614a0 Application+0×102e 
0098fd30 76113833 001614a0 0098fd7c 7784a9bd Application+0×1275 
0098fd3c 7784a9bd 001614a0 009811d7 00000000 kernel32!BaseThreadInitThunk+0xe 
0098fd7c 00000000 00a911ff 001614a0 00000000 ntdll!_RtlUserThreadStart+0×23 
In the case of Multiple Exceptions (Volume 1, page 255) or even a single 
exception on one thread involving invalid access to a structure field the reference to the 
same structure on a different thread may point to possible synchronization problems. 
 
 

194    PART 2: Crash Dump Analysis Patterns 
Wait Chain (CLR Monitors) 
This is a variation of a general Wait Chain (Volume 1, page 482) pattern related to CLR 
threads. When looking at Stack Trace Collection (Volume 1, page 409) from a complete 
memory dump we may find threads using a monitor synchronization mechanism: 
[... 32-bit ...] 
09d2e908 6ba4d409 clr!CLREvent::WaitEx+0x106 
09d2e91c 6bb90160 clr!CLREvent::Wait+0x19 
09d2e9ac 6bb90256 clr!AwareLock::EnterEpilogHelper+0xa8 
09d2e9ec 6bb9029b clr!AwareLock::EnterEpilog+0x42 
09d2ea0c 6ba90f78 clr!AwareLock::Enter+0x5f 
09d2eaa8 05952499 clr!JIT_MonEnterWorker_Portable+0xf8 
[...] 
or 
[... 64-bit ...] 
00000000`2094e230 000007fe`eedc3e3a clr!CLREvent::WaitEx+0xc1 
00000000`2094e2d0 000007fe`eedc3d43 clr!AwareLock::EnterEpilogHelper+0xca 
00000000`2094e3a0 000007fe`eee3e613 clr!AwareLock::EnterEpilog+0x63 
00000000`2094e400 000007ff`007f4c38 clr!JIT_MonEnterWorker_Portable+0×14f 
[...] 
When seeing such threads, we may ask for a process memory dump to perform 
.NET memory dump analysis using SOS or other WinDbg extensions such as in Deadlock 
(Volume 6, page 135) pattern example for CLR 2 (mscorwks). 
 
 

Thread Cluster    195 
Thread Cluster 
One of the useful patterns for analysis of system hangs is Waiting Thread Time (Volume 
1, page 343). If there are many such threads of interest, they can be partitioned by 
waiting time and modules of interest (page 510) from their Stack Traces (Volume 1, 
page 395). Modules of interest may include Directing (Volume 6, page 80), Coupled 
(Volume 6, page 114), Blocking (Volume 6, page 54), Top (Volume 6, page 62), and/or 
Problem Modules (page 85) depending on the problem description. Extra-dimensional 
information can also be added such as the number of threads having the same or similar 
waiting time and other attributes by using different colors. For example, on the 
following diagram illustrating a real system hang we see clustering of threads running 
through one 3rd-party module of interest and having the longest waiting time. Also we 
are able to identify possibly coupled (semantically related) threads running through 
another module of interest: 
Thread Waiting Time
Module
 
 
 

196    PART 2: Crash Dump Analysis Patterns 
Module Collection (Predicate) 
While working on Thread Cluster (page 195) pattern we realized that we need a 
predicate version of Module Collection (page 162) pattern, similar to the predicate 
version of Stack Trace Collection (page 100) pattern. A predicate can be anything: 
company vendors, semantic proximity, functionality such as printing, remote file 
management, and so on. Such module sub-collections can be used instead of modules in 
more complex patterns: an example of software diagnostics pattern substitution and 
composition. For example, we might be able to identify a possible coupling between two 
semantically different module groups explained by IPC Wait Chains (Volume 3, page 
387) such as on this diagram: 
Thread Waiting Time
Module 
Collection 
Predicate
 
 
 

False Effective Address    197 
False Effective Address 
When calculating effective addresses such as [r10+10h] or [rax+rcx*12h+40h] to show 
their value in the output of some commands such as .trap or .cxr a debugger uses CPU 
register values from a saved trap frame or context structure. If such information is 
invalid the reported effective address doesn’t correspond to the real one during code 
execution. This analysis pattern is similar to False Function Parameters (Volume 2, page 
173). Therefore, if a fault address is saved during bugcheck or exception processing, it 
may not correspond to the output of some commands where such calculation is 
necessary. For example, in a bugcheck parameter we have this referenced memory 
address: 
Arg1: fffffadda17d001d, memory referenced 
But the output of .trap command shows NULL Pointer (Volume 3, page 131) address: 
NOTE: The trap frame does not contain all registers. 
Some register values may be zeroed or incorrect. 
rax=0000000000000000 rbx=0000000000000000 rcx=0000000000000000 
[...] 
movzx eax,word ptr [rax+10h] 0010=???? 
Usually, we are lucky, and an effective address is correct despite such warning 
such as in pattern example from Volume 6, page 94 and pattern interaction case study 
from Volume 4, page 201. 
 
 

198    PART 2: Crash Dump Analysis Patterns 
Screwbolt Wait Chain 
Here we introduce another Wait Chain (Volume 1, page 482) pattern where a client 
thread makes a request and a created server thread servicing the request makes 
another request to the client which creates a new client thread to service the server 
request. The new client thread makes a request to the server again, and a new server 
thread is created which makes a new client request, and so on. The additional signs here 
may be an abnormal number of threads and possibly Handle Leak (page 164) pattern 
although the latter may be present only in a client or server process only. Thread Age 
(Volume 6, page 111), Waiting Thread Time (Volume 1, page 343), and common 
Blocking Module (Volume 6, page 54) patterns may be used to unwind the chain and 
diagnose the possible problem module and corresponding Module Product Process 
(page 189). The pattern is illustrated in this diagram: 

Screwbolt Wait Chain    199 
CID A.1
CID B.2
CID A.3
CID B.4
CID A.5
CID B.6
CID A.7
...
 
Although we initially found this pattern related to LPC /ALPC IPC (Wait Chain, 
Volume 3, page 97) we think it is not limited to it and can occur in different client-server 
communication implementations. 
 
 

200    PART 2: Crash Dump Analysis Patterns 
[This page is intentionally left blank] 
 
 

GDB for WinDbg Users    201 
PART 3: Core Dump Analysis Patterns (Mac OS X) 
GDB for WinDbg Users 
With memory dump analysis pattern examples for Mac OS X we resume our table of 
command correspondence between WinDbg and GDB we started in Volume 1 providing 
some corrections on the way. For example, in the previous version of the table we 
omitted a correspondence to ub WinDbg command. Now we provide such an equivalent 
(by default offsets are decimal): 
(gdb) bt 
[...] 
#1 0×000000010e8cce73 in bar (ps=0×7fff6e4cbac0) 
[...] 
(gdb) disas 0×000000010e8cce73-10 0×000000010e8cce73 
Dump of assembler code from 0×10e8cce69 to 0×10e8cce73: 
0×000000010e8cce69 : mov %edi,-0×8(%rbp) 
0×000000010e8cce6c : mov -0×8(%rbp),%rdi 
0×000000010e8cce70 : callq *0×8(%rdi) 
End of assembler dump. 
Please note that the beginning of assembly will be dependent on how good we 
guessed the offset: 
(gdb) disas 0x000000010e8cce73-0×10 0×000000010e8cce73 
Dump of assembler code from 0×10e8cce63 to 0×10e8cce73: 
0×000000010e8cce63 : in $0×48,%eax 
0×000000010e8cce65 : sub $0×10,%esp 
0×000000010e8cce68 : mov %rdi,-0×8(%rbp) 
0×000000010e8cce6c : mov -0×8(%rbp),%rdi 
0×000000010e8cce70 : callq *0×8(%rdi) 
End of assembler dump. 
(gdb) disas 0x000000010e8cce73-0×13 0×000000010e8cce73 
Dump of assembler code from 0×10e8cce60 to 0×10e8cce73: 
0×000000010e8cce60 : push %rbp 
0×000000010e8cce61 : mov %rsp,%rbp 
0×000000010e8cce64 : sub $0×10,%rsp 
0×000000010e8cce68 : mov %rdi,-0×8(%rbp) 
0×000000010e8cce6c : mov -0×8(%rbp),%rdi 
0×000000010e8cce70 : callq *0×8(%rdi) 
End of assembler dump. 

202    PART 3: Core Dump Analysis Patterns (Mac OS X) 
However, we can ignore that because usually when analyzing raw stack data 
symbolic references our goal is to check whether a CPU instruction before a return 
address is a call. 
Additional commands we add are x/<N>bc for db (WinDbg), thread <N> for 
~<N>s (WinDbg, process dumps), maintenance info sections for !address (WinDbg), 
add-symbol-file for .reload (WinDbg), info r for r (WinDbg). 
Action                      | GDB                 | WinDbg 
---------------------------------------------------------------- 
Start the process           | run                 | g 
Exit                        | (q)uit              | q 
Disassemble (forward)       | (disas)semble       | uf, u 
Disassemble N instructions  | x/<N>i              | - 
Disassemble (backward)      | disas <a-o> <a>     | ub 
Stack trace                 | backtrace (bt)      | k 
Full stack trace            | bt full             | kv 
Stack trace with parameters | bt full             | kP 
Partial trace (innermost)   | bt <N>              | k <N> 
Partial trace (outermost)   | bt -<N>             | - 
Stack trace for all threads | thread apply all bt | ~*k 
Breakpoint                  | break               | bp 
Frame numbers               | any bt command      | kn 
Select frame                | frame               | .frame 
Display parameters          | info args           | dv /t /i /V 
Display locals              | info locals         | dv /t /i /V 
Dump byte char array        | x/<N>bc             | db 
Switch to thread            | thread <N>          | ~<N>s 
Sections/regions            | maint info sections | !address 
Load symbol file            | add-symbol-file     | .reload 
CPU registers               | i(nfo) r            | r 
Note: In Mac OS X Mavericks GDB was replaced by LLDB and Software Diagnostics 
Services updated its Mac OS X Core Dump Analysis training course21. 
 
 
                                                                 
21 Accelerated Mac OS X Core Dump Analysis, Second Edition: Training Course 
Transcript with GDB and LLDB Practice Exercises (ISBN: 9781908043719) 

Stack Trace    203 
Stack Trace 
This is a Mac OS X / GDB counterpart to Stack Trace pattern previously described for 
Windows platforms (Volume 1, page 395). Here we first show a stack trace when 
symbols are not available and then show how to apply symbols: 
(gdb) bt 
#0 0×000000010d3b0e90 in ?? () 
#1 0×000000010d3b0ea9 in ?? () 
#2 0×000000010d3b0ec4 in ?? () 
#3 0×000000010d3b0e74 in ?? () 
(gdb) maintenance info sections 
Exec file: 
[...] 
Core file: 
`/cores/core.262', file type mach-o-le. 
0×000000010d3b0000->0×000000010d3b1000 at 0×00001000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3b1000->0×000000010d3b2000 at 0×00002000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3b2000->0×000000010d3b3000 at 0×00003000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3b3000->0×000000010d3b4000 at 0×00004000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3b4000->0×000000010d3b5000 at 0×00005000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3b5000->0×000000010d3b6000 at 0×00006000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3b6000->0×000000010d3cb000 at 0×00007000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3cb000->0×000000010d3cc000 at 0×0001c000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3cc000->0×000000010d3cd000 at 0×0001d000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3cd000->0×000000010d3e2000 at 0×0001e000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3e2000->0×000000010d3e3000 at 0×00033000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d3e3000->0×000000010d3e4000 at 0×00034000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
0×000000010d400000->0×000000010d500000 at 0×00035000: LC_SEGMENT. ALLOC 
LOAD CODE HAS_CONTENTS 
[...] 
 
 

204    PART 3: Core Dump Analysis Patterns (Mac OS X) 
(gdb) add-symbol-file ~/Documents/Work/Test.sym 0×000000010d3b0000 
add symbol table from file “/Users/DumpAnalysis/Documents/Work/Test.sym” 
at 
 
LC_SEGMENT.__TEXT = 0×10d3b0000 
(y or n) y 
Reading symbols from /Users/DumpAnalysis/Documents/Work/Test.sym...done. 
(gdb) bt 
#0 0x000000010d3b0e90 in bar () at main.c:15 
#1 0x000000010d3b0ea9 in foo () at main.c:20 
#2 0x000000010d3b0ec4 in main (argc=1, 
argv=0x7fff6cfafbf8) at main.c:25 
 
 

GDB Annoyances: Incomplete Stack Trace    205 
GDB Annoyances: Incomplete Stack Trace 
Users of WinDbg debugger accustomed to full thread stack traces will wonder whether a 
thread starts from main: 
(gdb) where 
#0 0x000000010d3b0e90 in bar () at main.c:15 
#1 0x000000010d3b0ea9 in foo () at main.c:20 
#2 0x000000010d3b0ec4 in main (argc=1, 
argv=0x7fff6cfafbf8) at main.c:25 
Of course, it doesn’t, and a stack trace is shown starting from main function by 
default. We can change this behavior by using the following command: 
(gdb) set backtrace past-main 
Now we see an additional frame: 
(gdb) where 
#0 0x000000010d3b0e90 in bar () at main.c:15 
#1 0x000000010d3b0ea9 in foo () at main.c:20 
#2 0x000000010d3b0ec4 in main (argc=1, 
argv=0x7fff6cfafbf8) at main.c:25 
#3 0×000000010d3b0e74 in start () 
 
 

206    PART 3: Core Dump Analysis Patterns (Mac OS X) 
NULL Pointer (Data) 
This is a Mac OS X / GDB counterpart to NULL Pointer (Data) pattern previously 
described for Windows platforms (Volume 3, page 131): 
(gdb) bt 
#0 0×000000010d3b0e90 in bar () at main.c:15 
#1 0×000000010d3b0ea9 in foo () at main.c:20 
#2 0×000000010d3b0ec4 in main (argc=1, 
argv=0×7fff6cfafbf8) at main.c:25 
(gdb) disassemble 
Dump of assembler code for function bar: 
0x000000010d3b0e80 <bar+0>: 
push %rbp 
0×000000010d3b0e81 <bar+1>: 
mov %rsp,%rbp 
0×000000010d3b0e84 <bar+4>: 
movq $0×0,-0×8(%rbp) 
0×000000010d3b0e8c <bar+12>: mov -0×8(%rbp),%rax 
0×000000010d3b0e90 <bar+16>: movl $0×1,(%rax) 
0×000000010d3b0e96 <bar+22>: pop %bp 
0×000000010d3b0e97 <bar+23>: retq 
End of assembler dump. 
(gdb) p/x $rax 
$1 = 0×0 
 
 

Shared Buffer Overwrite    207 
Shared Buffer Overwrite 
This is a Mac OS X example of Shared Buffer Overwrite pattern (Volume 5, page 120). 
Originally we wanted to construct a default C runtime heap corruption example using 
malloc / free functions. Unfortunately, we couldn’t get heap corrupted as easily as was 
possible in Windows Visual C++ environment by writing before or after allocated block. 
Desperately we printed allocated pointers and they all pointed to memory blocks laid 
out one after another without any headers in between (could be just a default Apple 
LLVM C runtime implementation and we have to check that with GCC). Therefore, any 
subsequent reallocation didn’t cause corruption either. So all this naturally fits into 
shared buffer overwrites or underwrites where corruption is only detectable when the 
overwritten data is used such as a pointer dereference. 
int main(int argc, const char * argv[]) 
{ 
char *p1 = (char *) malloc (1024); 
strcpy(p1, “Hello World!”); 
printf(“p1 = %p\n”, p1); 
printf(“*p1 = %s\n”, p1); 
 
char *p2 = (char *) malloc (1024); 
strcpy(p2, “Hello World!”); 
printf(“p2 = %p\n”, p2); 
printf(“*p2 = %s\n”, p2); 
 
char *p3 = (char *) malloc (1024); 
strcpy(p3, “Hello World!”); 
printf(“p3 = %p\n”, p3); 
printf(“*p3 = %s\n”, p3); 
 
strcpy(p2-sizeof(p2), “Hello Crash!”); 
strcpy(p3-sizeof(p3), “Hello Crash!”); 
p2 = (char *)realloc(p2, 2048); 
printf(“p2 = %p\n”, p2); 
printf(“*p2 = %s\n”, p2); 
 
char *p4 = (char *) malloc (1024); 
strcpy(p4-sizeof(p4), “Hello Crash!”); 
printf(“p4 = %p\n”, p4); 
printf(“*p4 = %s\n”, p4); 
 
p3 = (char *)realloc(p3, 2048); 
printf(“p3 = %p\n”, p3); 
printf(“*p3 = %s\n”, p3); 
 
char *p5 = NULL; // to force a core dump 
*p5 = 0; 

208    PART 3: Core Dump Analysis Patterns (Mac OS X) 
free (p4); 
free (p3); 
free (p2); 
free (p1); 
 
return 0; 
} 
When we run the program above we get this output: 
p1 = 0x7fc6d9000000 
*p1 = Hello World! 
p2 = 0×7fc6d9001400 
*p2 = Hello World! 
p3 = 0×7fc6d9001800 
*p3 = Hello World! 
p2 = 0×7fc6d9001c00 
*p2 = ash! 
p4 = 0×7fc6d9001400 
*p4 = ash! 
p3 = 0×7fc6d9002400 
*p3 = ash! 
Segmentation fault: 11 (core dumped) 
Now is GDB output: 
(gdb) x/1024bc p1 
0x7fc6d9000000: 72 ‘H’ 101 ‘e’ 108 ‘l’ 108 ‘l’ 111 ‘o’ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9000008: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9000010: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
[...] 
0×7fc6d90003e8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d90003f0: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d90003f8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/32bc p1+1024-sizeof(p1) 
0×7fc6d90003f8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9000400: 42 ‘*’ 112 ‘p’ 51 ‘3′ 32 ‘ ‘ 61 ‘=’ 32 ‘ ‘ 97 ‘a’ 115 ’s’ 
0×7fc6d9000408: 104 ‘h’ 33 ‘!’ 10 ‘\n’ 100 ‘d’ 57 ‘9′ 48 ‘0′ 48 ‘0′ 50 ‘2′ 
0×7fc6d9000410: 52 ‘4′ 48 ‘0′ 48 ‘0′ 10 ‘\n’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/2048bc p2 
0×7fc6d9001c00: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9001c08: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001c10: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
[...] 
0×7fc6d9001fe8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001ff0: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001ff8: 72 ‘H’ 101 ‘e’ 108 ‘l’ 108 ‘l’ 111 ‘o’ 32 ‘ ‘ 67 ‘C’ 114 ‘r’ 
0×7fc6d9002000: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002008: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
[...] 
0×7fc6d90023e8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 

Shared Buffer Overwrite    209 
0×7fc6d90023f0: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d90023f8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/64bc p2-sizeof(p2) 
0×7fc6d9001bf8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001c00: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9001c08: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001c10: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001c18: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001c20: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001c28: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001c30: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/64bc p2+2048-sizeof(p2) 
0×7fc6d90023f8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002400: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9002408: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002410: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002418: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002420: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002428: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002430: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/1024bc p3 
0×7fc6d9002400: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9002408: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002410: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
[...] 
0×7fc6d90027e8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d90027f0: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d90027f8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/64bc p3-sizeof(p3) 
0×7fc6d90023f8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002400: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9002408: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002410: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002418: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002420: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002428: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002430: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/64bc p3+1024-sizeof(p3) 
0×7fc6d90027f8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002800: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002808: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002810: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002818: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002820: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002828: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9002830: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
(gdb) x/1024bc p4 
0×7fc6d9001400: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9001408: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001410: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
[...] 
0×7fc6d90017e8: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d90017f0: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d90017f8: 72 ‘H’ 101 ‘e’ 108 ‘l’ 108 ‘l’ 111 ‘o’ 32 ‘ ‘ 67 ‘C’ 114 ‘r’ 

210    PART 3: Core Dump Analysis Patterns (Mac OS X) 
(gdb) x/64bc p4-sizeof(p4) 
0×7fc6d90013f8: 72 ‘H’ 101 ‘e’ 108 ‘l’ 108 ‘l’ 111 ‘o’ 32 ‘ ‘ 67 ‘C’ 114 ‘r’ 
0×7fc6d9001400: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9001408: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001410: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001418: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001420: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001428: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001430: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
 
(gdb) x/64bc p4+1024-sizeof(p4) 
0×7fc6d90017f8: 72 ‘H’ 101 ‘e’ 108 ‘l’ 108 ‘l’ 111 ‘o’ 32 ‘ ‘ 67 ‘C’ 114 ‘r’ 
0×7fc6d9001800: 97 ‘a’ 115 ’s’ 104 ‘h’ 33 ‘!’ 0 ‘\0′ 32 ‘ ‘ 87 ‘W’ 111 ‘o’ 
0×7fc6d9001808: 114 ‘r’ 108 ‘l’ 100 ‘d’ 33 ‘!’ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001810: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001818: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001820: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001828: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
0×7fc6d9001830: 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 0 ‘\0′ 
 
 

Multiple Exceptions    211 
Multiple Exceptions 
The first Windows pattern in user mode (Volume 1, page 255) now has Mac OS X 
equivalent. In the example below there are 3 threads, and two of them experienced 
data NULL Pointer (page 206) access violation exception: 
(gdb) thread apply all bt full 
Thread 3 (core thread 2): 
#0 0x00000001062ffe4e in thread_two (arg=0x0) 
at main.c:24 
 
p = (int *) 0×0 
#1 0×00007fff8abf58bf in _pthread_start () 
No symbol table info available. 
#2 0×00007fff8abf8b75 in thread_start () 
No symbol table info available. 
Thread 2 (core thread 1): 
#0 0x00000001062ffe1e in thread_one (arg=0x0) 
at main.c:16 
 
p = (int *) 0×0 
#1 0×00007fff8abf58bf in _pthread_start () 
No symbol table info available. 
#2 0×00007fff8abf8b75 in thread_start () 
No symbol table info available. 
Thread 1 (core thread 0): 
#0 0x00007fff854e0e42 in __semwait_signal () 
No symbol table info available. 
#1 0x00007fff8ababdea in nanosleep () 
No symbol table info available. 
#2 0x00007fff8ababc2c in sleep () 
No symbol table info available. 
#3 0x00000001062ffec3 in main (argc=1, argv=0x7fff65efeab8) 
at main.c:36 
 
threadID_one = (pthread_t) 0×1063b4000 
 
threadID_two = (pthread_t) 0×106581000 
(gdb) thread 2 
[Switching to thread 2 (core thread 1)] 
0x00000001062ffe1e in thread_one (arg=0x0) 
at main.c:16 
16 
 *p = 1; 
(gdb) p/x p 
$1 = 0×0 
 
 

212    PART 3: Core Dump Analysis Patterns (Mac OS X) 
(gdb) thread 3 
[Switching to thread 3 (core thread 2)] 
0x00000001062ffe4e in thread_two (arg=0x0) 
at main.c:24 
24 
 *p = 2; 
(gdb) p/x p 
$2 = 0×0 
 
 

Double Free (Process Heap)    213 
Double Free (Process Heap) 
This is a Mac OS X / GDB counterpart to a pattern previously described for Windows 
platforms (Volume 1, page 378): 
(gdb) bt 
#0 0x00007fff8479582a in __kill () 
#1 0x00007fff8e0e0a9c in abort () 
#2 0x00007fff8e13f84c in free () 
#3 0x00000001035a8ef4 in main (argc=1, argv=0x7fff631a7b20) 
(gdb) x/2i 0x00000001035a8ef4-8 
0x1035a8eec : mov -0×20(%rbp),%edi 
0×1035a8eef : callq 0×1035a8f06  
(gdb) frame 3 
#3 0x00000001035a8ef4 in main (argc=1, argv=0x7fff631a7b20) 
at .../DoubleFree/main.c:23 
23 free(p2); 
Current language: auto; currently minimal 
(gdb) x/g $rbp-0x20 
0x7fff631a7ae0: 0x00007fe6a8801400 
(gdb) x/2w 0x00007fe6a8801400 
0x7fe6a8801400: 0x00000000 0xb0000000 
Here’s the source code of the modeling application: 
int main(int argc, const char * argv[]) 
{ 
char *p1 = (char *) malloc (1024); 
 
printf(“p1 = %p\n”, p1); 
 
char *p2 = (char *) malloc (1024); 
printf(“p2 = %p\n”, p2); 
 
free(p2); 
free(p1); 
free(p2); 
 
return 0; 
}  
 
 

214    PART 3: Core Dump Analysis Patterns (Mac OS X) 
Dynamic Memory Corruption (Process Heap) 
This is a Mac OS X / GDB counterpart to Dynamic Memory Corruption (process heap) 
pattern (Volume 1, page 257) previously described for Windows platforms: 
(gdb) bt 
#0 0x00007fff8479582a in __kill () 
#1 0x00007fff8e0e0a9c in abort () 
#2 0x00007fff8e1024ac in szone_error () 
#3 0x00007fff8e1024e8 in free_list_checksum_botch () 
#4 0x00007fff8e102a7b in small_free_list_remove_ptr () 
#5 0x00007fff8e106bf7 in szone_free_definite_size () 
#6 0x00007fff8e13f789 in free () 
#7 0x000000010afafe23 in main (argc=1, argv=0x7fff6abaeb08) 
Here’s the source code of the modeling application: 
int main(int argc, const char * argv[]) 
{ 
char *p1 = (char *) malloc (1024); 
printf(“p1 = %p\n”, p1); 
 
char *p2 = (char *) malloc (1024); 
printf(“p2 = %p\n”, p2); 
 
char *p3 = (char *) malloc (1024); 
printf(“p3 = %p\n”, p3); 
 
char *p4 = (char *) malloc (1024); 
printf(“p4 = %p\n”, p4); 
 
char *p5 = (char *) malloc (1024); 
printf(“p5 = %p\n”, p5); 
 
char *p6 = (char *) malloc (1024); 
printf(“p6 = %p\n”, p6); 
 
char *p7 = (char *) malloc (1024); 
printf(“p7 = %p\n”, p7); 
 
free(p6); 
free(p4); 
free(p2); 
 
printf(“Hello Crash!\n”);  
strcpy(p2, “Hello Crash!”); 
strcpy(p4, “Hello Crash!”); 
strcpy(p6, “Hello Crash!”); 
 
p2 = (char *) malloc (512); 
printf(“p2 = %p\n”, p2); 

Dynamic Memory Corruption (Process Heap)    215 
p4 = (char *) malloc (1024); 
printf(“p4 = %p\n”, p4); 
 
p6 = (char *) malloc (512); 
printf(“p6 = %p\n”, p6); 
 
free (p7); 
free (p6); 
free (p5); 
free (p4); 
free (p3); 
free (p2); 
free (p1); 
 
return 0; 
} 
 
 

216    PART 3: Core Dump Analysis Patterns (Mac OS X) 
Spiking Thread 
This is a Mac OS X / GDB counterpart to Spiking Thread pattern previously described for 
Windows platforms (Volume 1, page 305): 
(gdb) info threads 
4 0×00007fff85b542df in sqrt$fenv_access_off () 
3 0×00007fff8616ee42 in __semwait_signal () 
2 0×00007fff8616ee42 in __semwait_signal () 
* 1 0×00007fff8616ee42 in __semwait_signal () 
We notice a non-waiting thread and switch to it: 
(gdb) thread 4 
[Switching to thread 4 (core thread 3)] 
0x00007fff85b542df in sqrt$fenv_access_off () 
(gdb) bt 
#0 0x00007fff85b542df in sqrt$fenv_access_off () 
#1 0×000000010cc85dc9 in thread_three (arg=0×7fff6c884ac0) 
#2 0×00007fff8fac68bf in _pthread_start () 
#3 0×00007fff8fac9b75 in thread_start () 
If we disassemble the return address for thread_three function called from sqrt 
call we see an infinite loop: 
(gdb) disass 0x000000010cc85dc9 
Dump of assembler code for function thread_three: 
0x000000010cc85db0 <thread_three+0>: push %rbp 
0×000000010cc85db1 <thread_three+1>: mov %rsp,%rbp 
0×000000010cc85db4 <thread_three+4>: sub $0×10,%rsp 
0×000000010cc85db8 <thread_three+8>: mov %rdi,-0×10(%rbp) 
0×000000010cc85dbc <thread_three+12>: mov -0×10(%rbp),%ax 
0×000000010cc85dc0 <thread_three+16>: movsd (%rax),%xmm0 
0×000000010cc85dc4 <thread_three+20>: callq 0×10cc85eac <dyld_stub_sqrt> 
0×000000010cc85dc9 <thread_three+25>: mov -0×10(%rbp),%rax 
0×000000010cc85dcd <thread_three+29>: movsd %xmm0,(%rax) 
0×000000010cc85dd1 <thread_three+33>: jmpq 0×10cc85dbc <thread_three+12> 
End of assembler dump. 
 
 

Spiking Thread    217 
Here’s the source code of the modeling application: 
void * thread_one (void *arg) 
{ 
while (1) 
{ 
    sleep (1); 
} 
 
return 0; 
} 
 
void * thread_two (void *arg) 
{ 
while (1) 
{ 
    sleep (2); 
} 
 
return 0; 
} 
 
void * thread_three (void *arg) 
{ 
while (1) 
{ 
    *(double*)arg=sqrt(*(double *)arg); 
} 
 
return 0; 
} 
 
int main(int argc, const char * argv[]) 
{ 
pthread_t threadID_one, threadID_two, threadID_three; 
double result = 0xffffffff; 
 
pthread_create (&threadID_one, NULL, thread_one, NULL); 
pthread_create (&threadID_two, NULL, thread_two, NULL); 
pthread_create (&threadID_three, NULL, thread_three, 
&result); 
pthread_join(threadID_three, NULL); 
 
return 0; 
} 
 
 
 

218    PART 3: Core Dump Analysis Patterns (Mac OS X) 
NULL Pointer (Code) 
This is a Mac OS X / GDB counterpart to NULL Pointer (code) pattern previously 
described for Windows platforms (Volume 2, page 237): 
(gdb) bt 
#0 0×0000000000000000 in ?? () 
#1 0×000000010e8cce73 in bar (ps=0×7fff6e4cbac0) 
#2 0×000000010e8cce95 in foo (ps=0×7fff6e4cbac0) 
#3 0×000000010e8cced5 in main (argc=1, argv=0×7fff6e4cbb08) 
(gdb) disass 0×000000010e8cce73-3 0×000000010e8cce73 
Dump of assembler code from 0×10e8cce70 to 0×10e8cce73: 
0×000000010e8cce70 : callq *0×8(%rdi) 
End of assembler dump. 
(gdb) info r rdi 
rdi 0x7fff6e4cbac0 140735043910336 
(gdb) x/2 0x7fff6e4cbac0 
0x7fff6e4cbac0: 0x0000000a 0×00000000 
(gdb) p/x *($rdi+8) 
$7 = 0×0 
(gdb) bt 
#0 0x0000000000000000 in ?? () 
#1 0x000000010e8cce73 in bar (ps=0×7fff6e4cbac0) 
#2 0×000000010e8cce95 in foo (ps=0×7fff6e4cbac0) 
#3 0×000000010e8cced5 in main (argc=1, argv=0×7fff6e4cbb08) 
(gdb) ptype MYSTRUCT 
type = struct _MyStruct_tag { 
int data; 
PFUNC pfunc; 
} 
(gdb) print {MYSTRUCT}0×7fff6e4cbac0 
$2 = {data = 10, pfunc = 0} 
 
 

NULL Pointer (Code)    219 
Here’s the source code of the modeling application: 
typedef void (*PFUNC)(void); 
 
typedef struct _MyStruct_tag 
{ 
int data; 
PFUNC pfunc; 
} MYSTRUCT; 
 
void bar(MYSTRUCT *ps) 
{ 
ps->pfunc(); 
} 
 
void foo(MYSTRUCT *ps) 
{ 
bar(ps); 
} 
 
int main(int argc, const char * argv[]) 
{ 
MYSTRUCT pstruct = {10, NULL}; 
 
foo(&pstruct); 
 
return 0; 
}  
 
 
 

220    PART 3: Core Dump Analysis Patterns (Mac OS X) 
Execution Residue 
This is a Mac OS X / GDB counterpart to Execution Residue pattern previously described 
for Windows platforms (Volume 2, page 239): 
(gdb) bt 
#0 0x00007fff8616e82a in __kill () 
#1 0x00007fff8fab9a9c in abort () 
#2 0x000000010269dc29 in bar_5 () 
#3 0x000000010269dc39 in bar_4 () 
#4 0x000000010269dc49 in bar_3 () 
#5 0x000000010269dc59 in bar_2 () 
#6 0x000000010269dc69 in bar_1 () 
#7 0x000000010269dc79 in bar () 
#8 0x000000010269dca0 in main (argc=1, argv=0x7fff6229cb00) 
(gdb) x $rsp 
0x7fff6229ca38: 0x8fab9a9c 
(gdb) x/1000a 0x7fff6229c000 
0×7fff6229c000: 0×7fff8947b000 0×7fff8947b570 
0×7fff6229c010: 0×4f3ee10c 0×7fff90cb0000 
0×7fff6229c020: 0×7fff90cb04d0 0×4e938b16 
[...] 
0×7fff6229c5f0: 0×7fff622d8d80 0×10269d640 
0×7fff6229c600: 0×7fff6229cad0 0×7fff622a460b 
0×7fff6229c610: 0×100000000 0×269d000 
0×7fff6229c620: 0×7fff6229c630 0×10269db59 <foo_8+9> 
0×7fff6229c630: 0×7fff6229c640 0×10269db69 <foo_7+9> 
0×7fff6229c640: 0×7fff6229c650 0×10269db79 <foo_6+9> 
0×7fff6229c650: 0×7fff6229c660 0×10269db89 <foo_5+9> 
0×7fff6229c660: 0×7fff6229c670 0×10269db99 <foo_4+9> 
0×7fff6229c670: 0×7fff6229c680 0×10269dba9 <foo_3+9> 
0×7fff6229c680: 0×7fff6229c690 0×10269dbb9 <foo_2+9> 
0×7fff6229c690: 0×7fff6229c6a0 0×10269dbc9 <foo_1+9> 
0×7fff6229c6a0: 0×7fff6229cac0 0×10269dbee <foo+30> 
0×7fff6229c6b0: 0×0 0×0 
0×7fff6229c6c0: 0×0 0×0 
0×7fff6229c6d0: 0×0 0×0 
0×7fff6229c6e0: 0×0 0×0 
[...] 
0×7fff6229c8d0: 0×7fff6229c960 0×7fff622b49cd 
0×7fff6229c8e0: 0×10269f05c 0×0 
0×7fff6229c8f0: 0×7fff622c465c 0×7fff8a31e5c0 <_Z21dyldGlobalLockReleasev> 
0×7fff6229c900: 0×7fff8fab99eb <abort> 0×10269f05c 
0×7fff6229c910: 0×101000000000000 0×7fff622d2110 
0×7fff6229c920: 0×7fff622d8d80 0×10269f078 
0×7fff6229c930: 0×7fff622daac8 0×18 
0×7fff6229c940: 0×0 0×0 
0×7fff6229c950: 0×10269e030 0×0 
0×7fff6229c960: 0×7fff6229c980 0×7fff622a1922 

Execution Residue    221 
0×7fff6229c970: 0×0 0×0 
0×7fff6229c980: 0×7fff6229ca50 0×7fff8a31e716 <dyld_stub_binder_+13> 
0×7fff6229c990: 0×1 0×7fff6229cb00 
0×7fff6229c9a0: 0×7fff6229cb10 0xe223ea612ddc10b7 
0×7fff6229c9b0: 0×8 0×0 
0×7fff6229c9c0: 0xe223ea612ddc10b7 0×0 
0×7fff6229c9d0: 0×0 0×0 
0×7fff6229c9e0: 0×585f5f00474e414c 0×20435058005f4350 
0×7fff6229c9f0: 0×0 0×0 
0×7fff6229ca00: 0×0 0×0 
0×7fff6229ca10: 0×0 0×0 
0×7fff6229ca20: 0×0 0×0 
0×7fff6229ca30: 0×7fff6229ca60 0×7fff8fab9a9c <abort+177> 
0×7fff6229ca40: 0×0 0×0 
0×7fff6229ca50: 0×7fffffffffdf 0×0 
0×7fff6229ca60: 0×7fff6229ca70 0×10269dc29 <bar_5+9> 
0×7fff6229ca70: 0×7fff6229ca80 0×10269dc39 <bar_4+9> 
0×7fff6229ca80: 0×7fff6229ca90 0×10269dc49 <bar_3+9> 
0×7fff6229ca90: 0×7fff6229caa0 0×10269dc59 <bar_2+9> 
0×7fff6229caa0: 0×7fff6229cab0 0×10269dc69 <bar_1+9> 
0×7fff6229cab0: 0×7fff6229cac0 0×10269dc79 <bar+9> 
0×7fff6229cac0: 0×7fff6229cae0 0×10269dca0 <main+32> 
0×7fff6229cad0: 0×7fff6229cb00 0×1 
0×7fff6229cae0: 0×7fff6229caf0 0×10269db34 <start+52> 
0×7fff6229caf0: 0×0 0×1 
0×7fff6229cb00: 0×7fff6229cc48 0×0 
0×7fff6229cb10: 0×7fff6229ccae 0×7fff6229ccca 
[...] 
Here’s the source code of the modeling application: 
#define def_call(name,x,y) void name##_##x() { name##_##y(); } 
#define def_final(name,x) void name##_##x() { } 
#define def_final_abort(name,x) void name##_##x() { abort(); } 
#define def_init(name,y) void name() { name##_##y(); } 
#define def_init_alloc(name,y,size) void name() { int arr[size]; 
name##_##y(); *arr=0; } 
 
def_final(foo,9) 
def_call(foo,8,9) 
def_call(foo,7,8) 
def_call(foo,6,7) 
def_call(foo,5,6) 
def_call(foo,4,5) 
def_call(foo,3,4) 
def_call(foo,2,3) 
def_call(foo,1,2) 
def_init_alloc(foo,1,256) 
def_final_abort(bar,5) 
def_call(bar,4,5) 
def_call(bar,3,4) 
def_call(bar,2,3) 
def_call(bar,1,2) 

222    PART 3: Core Dump Analysis Patterns (Mac OS X) 
def_init(bar,1) 
 
int main(int argc, const char * argv[]) 
{ 
foo(); 
bar(); 
}  
 
 
 

Coincidental Symbolic Information    223 
Coincidental Symbolic Information 
This is a Mac OS X / GDB counterpart to Coincidental Symbolic Information pattern 
previously described for Windows platforms (Volume 1, page 390). The idea is the same: 
to disassemble the address to see if the preceding instruction is a call. If it is indeed then 
most likely the symbolic address is a return address from past Execution Residue (page 
220):  
(gdb) x $rsp 
0x7fff6a162a38: 0x8fab9a9c 
(gdb) x/1000a 0x7fff6a162000 
[...] 
0x7fff6a162960: 0x7fff6a162980 0x7fff6a167922 
0x7fff6a162970: 0x0 0x0 
0x7fff6a162980: 0x7fff6a162a50 0×7fff8a31e716 <dyld_stub_binder_+13> 
0×7fff6a162990: 0×1 0×7fff6a162b00 
0×7fff6a1629a0: 0×7fff6a162b10 0×7fff6a162bc0 
0×7fff6a1629b0: 0×8 0×0 
[...] 
0×7fff6a162a00: 0×0 0×0 
0×7fff6a162a10: 0×0 0×0 
0×7fff6a162a20: 0×0 0×0 
0×7fff6a162a30: 0×7fff6a162a60 0×7fff8fab9a9c <abort+177> 
0×7fff6a162a40: 0×0 0×0 
0×7fff6a162a50: 0×7fffffffffdf 0×0 
[...] 
0×7fff6a163040: 0×35000 0×0 
0×7fff6a163050: 0×35000 0×500000007 
0×7fff6a163060: 0×7 0×747865745f5f 
0×7fff6a163070: 0×0 0×545845545f5f 
0×7fff6a163080: 0×0 0×7fff5fc01000 <__dyld_stub_binding_helper> 
0×7fff6a163090: 0×22c9d 0xc00001000 
0×7fff6a1630a0: 0×0 0×80000400 
[...] 
(gdb) disass 0×7fff8a31e716 
Dump of assembler code for function dyld_stub_binder_: 
0×00007fff8a31e709 <dyld_stub_binder_+0>: mov 0×8(%rbp),%rdi 
0×00007fff8a31e70d <dyld_stub_binder_+4>: mov 0×10(%rbp),%rsi 
0×00007fff8a31e711 <dyld_stub_binder_+8>: callq 0×7fff8a31e86d 
<_Z21_dyld_fast_stub_entryPvl> 
0×00007fff8a31e716 <dyld_stub_binder_+13>: mov %rax,%r11 
0×00007fff8a31e719 <dyld_stub_binder_+16>: movdqa 0×40(%rsp),%xmm0 
0×00007fff8a31e71f <dyld_stub_binder_+22>: movdqa 0×50(%rsp),%xmm1 
0×00007fff8a31e725 <dyld_stub_binder_+28>: movdqa 0×60(%rsp),%xmm2 
0×00007fff8a31e72b <dyld_stub_binder_+34>: movdqa 0×70(%rsp),%xmm3 
0×00007fff8a31e731 <dyld_stub_binder_+40>: movdqa 0×80(%rsp),%xmm4 
0×00007fff8a31e73a <dyld_stub_binder_+49>: movdqa 0×90(%rsp),%xmm5 
0×00007fff8a31e743 <dyld_stub_binder_+58>: movdqa 0xa0(%rsp),%xmm6 

224    PART 3: Core Dump Analysis Patterns (Mac OS X) 
0×00007fff8a31e74c <dyld_stub_binder_+67>: movdqa 0xb0(%rsp),%xmm7 
0×00007fff8a31e755 <dyld_stub_binder_+76>: mov (%rsp),%rdi 
0×00007fff8a31e759 <dyld_stub_binder_+80>: mov 0×8(%rsp),%rsi 
0×00007fff8a31e75e <dyld_stub_binder_+85>: mov 0×10(%rsp),%rdx 
0×00007fff8a31e763 <dyld_stub_binder_+90>: mov 0×18(%rsp),%rcx 
0×00007fff8a31e768 <dyld_stub_binder_+95>: mov 0×20(%rsp),%r8 
0×00007fff8a31e76d <dyld_stub_binder_+100>: mov 0×28(%rsp),%r9 
0×00007fff8a31e772 <dyld_stub_binder_+105>: mov 0×30(%rsp),%rax 
0×00007fff8a31e777 <dyld_stub_binder_+110>: add $0xc0,%rsp 
0×00007fff8a31e77e <dyld_stub_binder_+117>: pop %rbp 
0×00007fff8a31e77f <dyld_stub_binder_+118>: add $0×10,%rsp 
0×00007fff8a31e783 <dyld_stub_binder_+122>: jmpq *%r11 
(gdb) x/2i 0×7fff8fab9a9c 
0×7fff8fab9a9c <abort+177>: mov $0×2710,%edi 
0×7fff8fab9aa1 <abort+182>: callq 0×7fff8fab9c43 <usleep$nocancel> 
(gdb) disass 0×7fff8fab9a9c-5 0×7fff8fab9a9c 
Dump of assembler code from 0×7fff8fab9a97 to 0×7fff8fab9a9c: 
0×00007fff8fab9a97 <abort+172>: callq 0×7fff8fb1f54a <dyld_stub_kill> 
End of assembler dump. 
(gdb) disass 0×7fff5fc01000 
Dump of assembler code for function __dyld_stub_binding_helper: 
0×00007fff5fc01000 <__dyld_stub_binding_helper+0>: add %al,(%rax) 
0×00007fff5fc01002 <__dyld_stub_binding_helper+2>: add %al,(%rax) 
0×00007fff5fc01004 <__dyld_stub_binding_helper+4>: add %al,(%rax) 
0×00007fff5fc01006 <__dyld_stub_binding_helper+6>: add %al,(%rax) 
End of assembler dump. 
(gdb) x/10 0×7fff5fc01000-0×10 
0×7fff5fc00ff0: 0×00000000 0×00000000 0×00000000 0×00000000 
0×7fff5fc01000 <__dyld_stub_binding_helper>: 0×00000000 0×00000000 
0×00000000 0×00000000 
0×7fff5fc01010 <__dyld_offset_to_dyld_all_image_infos>: 0×00000000 
0×00000000 
 
 

Paratext    225 
Paratext 
This is the first pattern that emerged after applying pattern-driven software diagnostics 
methodology developed first on Windows platforms to Mac OS X. We had problems 
using GDB which is so portable that hardly has operating system support like WinDbg 
debugger has. Fortunately, we found a workaround by complementing core dumps with 
logs and reports from OS such as crash reports and vmmap data. The name of this 
pattern was borrowed from the concept of an extended software trace (Volume 5, page 
277) and software narratology22 where it borrowed the same concept from literary 
interpretation (paratext23). Typical examples of such pattern usage can be the list of 
modules with version and path info, application crash specific information, memory 
region names with attribution and boundaries: 
// from .crash reports 
0x108f99000 - 0x109044ff7 com.apple.FontBook (198.4 - 198) <7244D36E-4563-3E42-BA46-1F279D30A6CE> 
/Applications/Font Book.app/Contents/MacOS/Font Book 
Exception Type: EXC_BAD_INSTRUCTION (SIGILL) 
Exception Codes: 0x0000000000000001, 0x0000000000000000 
Application Specific Information: 
objc[195]: garbage collection is OFF 
*** error for object 0x7fd7fb818e08: incorrect checksum for freed object - object was probably 
modified after being freed. 
// from vmmap logs 
[...] 
==== Writable regions for process 966 
[...] 
Stack 0000000101f71000-0000000101ff3000 [ 520K] rw-/rwx SM=PRV thread 1 
MALLOC_LARGE 0000000103998000-00000001039b8000 [ 128K] rw-/rwx SM=PRV DefaultMallocZone_0x101e6e000 
MALLOC_SMALL (freed) 00000001039b9000-00000001039bb000 [ 8K] rw-/rwx SM=PRV 
mapped file 0000000103a05000-0000000103f32000 [ 5300K] rw-/rwx SM=COW 
...box.framework/Versions/A/Resources/Extras2.rsrc 
mapped file 0000000104409000-00000001046d2000 [ 2852K] rw-/rwx SM=COW 
/System/Library/Fonts/Helvetica.dfont 
MALLOC_LARGE 0000000104f6e000-0000000104f8e000 [ 128K] rw-/rwx SM=PRV DefaultMallocZone_0x101e6e000 
MALLOC_LARGE (freed) 0000000108413000-0000000108540000 [ 1204K] rw-/rwx SM=COW 
MALLOC_LARGE (freed) 0000000108540000-0000000108541000 [ 4K] rw-/rwx SM=PRV 
MALLOC_TINY 00007fefe0c00000-00007fefe0d00000 [ 1024K] rw-/rwx SM=COW DefaultMallocZone_0x101e6e000 
MALLOC_TINY 00007fefe0d00000-00007fefe0e00000 [ 1024K] rw-/rwx SM=PRV 
DispatchContinuations_0x101f38000 
MALLOC_TINY 00007fefe0e00000-00007fefe0f00000 [ 1024K] rw-/rwx SM=COW DefaultMallocZone_0x101e6e000 
                                                                 
22 http://www.patterndiagnostics.com/Introduction-Software-Narratology-materials 
23 http://en.wikipedia.org/wiki/Paratext 

226    PART 3: Core Dump Analysis Patterns (Mac OS X) 
MALLOC_SMALL 00007fefe1000000-00007fefe107b000 [ 492K] rw-/rwx SM=ZER DefaultMallocZone_0x101e6e000 
MALLOC_SMALL 00007fefe107b000-00007fefe1083000 [ 32K] rw-/rwx SM=PRV DefaultMallocZone_0x101e6e000 
MALLOC_SMALL 00007fefe1083000-00007fefe1149000 [ 792K] rw-/rwx SM=ZER DefaultMallocZone_0x101e6e000 
MALLOC_SMALL (freed) 00007fefe1149000-00007fefe1166000 [ 116K] rw-/rwx SM=PRV 
DefaultMallocZone_0x101e6e000 
MALLOC_SMALL (freed) 00007fefe1166000-00007fefe1800000 [ 6760K] rw-/rwx SM=ZER 
DefaultMallocZone_0x101e6e000 
MALLOC_SMALL 00007fefe1800000-00007fefe18ff000 [ 1020K] rw-/rwx SM=ZER 
DefaultMallocZone_0x101e6e000 
MALLOC_SMALL (freed) 00007fefe18ff000-00007fefe1901000 [ 8K] rw-/rwx SM=PRV 
DefaultMallocZone_0x101e6e000 
MALLOC_SMALL 00007fefe1901000-00007fefe2000000 [ 7164K] rw-/rwx SM=ZER 
DefaultMallocZone_0x101e6e000 
MALLOC_TINY (freed) 00007fefe2000000-00007fefe2100000 [ 1024K] rw-/rwx SM=PRV 
DispatchContinuations_0x101f38000 
MALLOC_TINY 00007fefe2100000-00007fefe2200000 [ 1024K] rw-/rwx SM=PRV DefaultMallocZone_0x101e6e000 
Stack 00007fff61186000-00007fff61985000 [ 8188K] rw-/rwx SM=ZER thread 0 
Stack 00007fff61985000-00007fff61986000 [ 4K] rw-/rwx SM=COW 
[...] 
 
 

Truncated Dump    227 
Truncated Dump 
This is a Mac OS X / GDB counterpart to Truncated Dump pattern previously described 
for Windows platforms (Volume 1, page 340): 
(gdb) info threads 
Cannot access memory at address 0x7fff885e9e42 
4 0x00007fff885e9e42 in ?? () 
3 0x00007fff885e9e42 in ?? () 
2 0x00007fff885e9e42 in ?? () 
* 1 0x00007fff885e9e42 in ?? () 
warning: Couldn't restore frame in current thread, at frame 0 
0x00007fff885e9e42 in ?? () 
(gdb) disass 0x00007fff885e9e42 
No function contains specified address. 
(gdb) info r rsp 
rsp 0x7fff67fe8a18 0x7fff67fe8a18 
(gdb) x/100a 0x7fff67fe8a18 
0x7fff67fe8a18: Cannot access memory at address 0x7fff67fe8a18 
This often happens if there is no space to save a full core dump. 
 
 

228    PART 3: Core Dump Analysis Patterns (Mac OS X) 
C++ Exception 
This is a Mac OS X / GDB counterpart to C++ Exception pattern previously described for 
Windows platforms (Volume 3, page 84): 
(gdb) bt 
#0 0x00007fff88bd582a in __kill () 
#1 0x00007fff8c184a9c in abort () 
#2 0x00007fff852f57bc in abort_message () 
#3 0x00007fff852f2fcf in default_terminate () 
#4 0x00007fff852f3001 in safe_handler_caller () 
#5 0x00007fff852f305c in std::terminate () 
#6 0×00007fff852f4152 in __cxa_throw () 
#7 0×000000010e402be8 in bar () 
#8 0×000000010e402c99 in foo () 
#9 0×000000010e402cbb in main (argc=1, argv=0×7fff6e001b18) 
The modeling application source code: 
class Exception 
{ 
int code; 
std::string description; 
public: 
Exception(int _code, std::string _desc) : code(_code),  
    description(_desc) {} 
}; 
 
void bar() 
{ 
throw new Exception(5, “Access Denied”); 
} 
 
void foo() 
{ 
bar(); 
} 
 
int main(int argc, const char * argv[]) 
{ 
foo(); 
return 0; 
}  
 
 

Local Buffer Overflow    229 
Local Buffer Overflow 
This is a Mac OS X / GDB counterpart to Local Buffer Overflow pattern previously 
described for Windows platforms (Volume 1, page 460). Most of the time simple 
mistakes in using memory and string manipulation functions are easily detected by 
runtime: 
(gdb) bt 
#0 0x00007fff885e982a in __kill () 
#1 0x00007fff83288b6c in __abort () 
#2 0×00007fff8325a89f in __chk_fail () 
#3 0×00007fff8325a83e in __memcpy_chk () 
#4 0×000000010914edf3 in bar () 
#5 0×000000010914ee5e in foo () 
#6 0×000000010914ee9b in main (argc=1, argv=0×7fff68d4daf0) 
This detection happens in a default optimized release version as well: 
(gdb) bt 
#0 0x00007fff885e982a in __kill () 
#1 0x00007fff83288b6c in __abort () 
#2 0×00007fff8325a89f in __chk_fail () 
#3 0×00007fff8325a83e in __memcpy_chk () 
#4 0×000000010f59cea8 in bar [inlined] () 
#5 0×000000010f59cea8 in foo [inlined] () 
#6 0×000000010f59cea8 in main (argc=, 
argv=) 
The more sophisticated example which overwrites stack trace without being 
detected involves overwriting indirectly via a pointer to a local buffer passed to a called 
function. In such cases we might see incorrect and truncated stack traces: 
(gdb) bt 
#0 0x00007fff885e982a in __kill () 
#1 0x00007fff83288b6c in __abort () 
#2 0×00007fff83285070 in __stack_chk_fail () 
#3 0×000000010524de77 in foo () 
#4 0xca4000007fff64e5 in ?? () 
(gdb) bt 
#0 0x00007fff885e982a in __kill () 
#1 0x00007fff83288b6c in __abort () 
#2 0×00007fff83285070 in __stack_chk_fail () 
#3 0×0000000105ad8df7 in foo () 
Inspection of the raw stack shows ASCII-like memory values around foo symbolic 
reference instead of expected main and start functions: 

230    PART 3: Core Dump Analysis Patterns (Mac OS X) 
(gdb) info r rsp 
rsp 0x7fff656d79d8 0x7fff656d79d8 
(gdb) x/100a 0x7fff656d79d8 
0x7fff656d79d8: 0x7fff83288b6c <__abort+193> 0x0 
0x7fff656d79e8: 0x0 0xffffffdf 
0x7fff656d79f8: 0x7fff656d7a40 0x7fff656d7a80 
0x7fff656d7a08: 0x7fff83285070 <__guard_setup> 0x6675426c61636f4c 
0x7fff656d7a18: 0x7265764f726566 0x0 
0x7fff656d7a28: 0x0 0x0 
0x7fff656d7a38: 0x0 0x73205d343336325b 
0x7fff656d7a48: 0x65766f206b636174 0x776f6c6672 
0x7fff656d7a58: 0x0 0x0 
0x7fff656d7a68: 0x0 0x343336326d7ab0 
0x7fff656d7a78: 0x0 0x7fff656d7ab0 
0x7fff656d7a88: 0x105ad8df7 0xb1887b8452358ac4 
0×7fff656d7a98: 0×794d000000000000 0×6769422077654e20 
0×7fff656d7aa8: 0×6666754220726567 0×7265 
0×7fff656d7ab8: 0×0 0×0 
0×7fff656d7ac8: 0×0 0×0 
0×7fff656d7ad8: 0×0 0×0 
0×7fff656d7ae8: 0×0 0×0 
[...] 
The modeling application source code: 
void bar(char *buffer) 
{ 
char data[100] = “My New Bigger Buffer”;  
memcpy (buffer, data, sizeof(data)); 
} 
 
void foo() 
{ 
char data[10] = “My Buffer”; 
bar(data); 
} 
 
int main(int argc, const char * argv[]) 
{ 
foo(); 
return 0; 
} 
 
 
 

Divide by Zero (User Mode)    231 
Divide by Zero (User Mode) 
This is a Mac OS X / GDB counterpart to Divide by Zero (user mode) pattern previously 
described for Windows platforms (Volume 2, page 96): 
(gdb) bt 
#0 0×000000010d3ebe9e in bar (a=1, b=0) 
#1 0×000000010d3ebec3 in foo () 
#2 0×000000010d3ebeeb in main (argc=1, argv=0×7fff6cfeab18) 
(gdb) x/i 0×000000010d3ebe9e 
0×10d3ebe9e : idiv %esi 
(gdb) info r rsi 
rsi 0×0 0 
The modeling application source code: 
int bar(int a, int b) 
{ 
return a/b; 
} 
 
int foo() 
{ 
return bar(1,0); 
} 
 
int main(int argc, const char * argv[]) 
{ 
return foo(); 
} 
 
 

232    PART 3: Core Dump Analysis Patterns (Mac OS X) 
Stack Overflow (User Mode) 
This is a Mac OS X / GDB counterpart to Stack Overflow (user mode) pattern previously 
described for Windows platforms (Volume 1, page 279): 
(gdb) bt 10 
#0 0x0000000105dafea8 in bar (i=0) 
#1 0x0000000105dafeb9 in bar (i=262102) 
#2 0x0000000105dafeb9 in bar (i=262101) 
#3 0x0000000105dafeb9 in bar (i=262100) 
#4 0x0000000105dafeb9 in bar (i=262099) 
#5 0x0000000105dafeb9 in bar (i=262098) 
#6 0x0000000105dafeb9 in bar (i=262097) 
#7 0x0000000105dafeb9 in bar (i=262096) 
#8 0x0000000105dafeb9 in bar (i=262095) 
#9 0x0000000105dafeb9 in bar (i=262094) 
(More stack frames follow...) 
There are at least 262,102 frames, so we don’t attempt to list them all. What 
we’d like to do is to get stack trace boundaries from the list of sections based on the 
current stack pointer address and dump the upper part of it (the stack grows from 
higher addresses to the lower ones) to get bottom initial stack traces: 
(gdb) x $rsp 
0×7fff651aeff0: 0×00000000 
Because this is a stack overflow we expect that RSP went out of page bounds, 
and we expect the lowest address to be 0×7fff651af000. 
(gdb) maint info sections 
[...] 
Core file: 
`/cores/core.2763', file type mach-o-le. 
[...] 
0x0000000105e00000->0x0000000105f00000 at 0x00035000: LC_SEGMENT. ALLOC LOAD CODE HAS_CONTENTS 
0x00007fff619af000->0x00007fff651af000 at 0x00135000: LC_SEGMENT. ALLOC LOAD CODE HAS_CONTENTS 
0×00007fff651af000->0×00007fff659af000 at 0×03935000: LC_SEGMENT. ALLOC LOAD CODE HAS_CONTENTS 
0×00007fff659af000->0×00007fff659e4000 at 0×04135000: LC_SEGMENT. ALLOC LOAD CODE HAS_CONTENTS 
0×00007fff659e4000->0×00007fff659e6000 at 0×0416a000: LC_SEGMENT. ALLOC LOAD CODE HAS_CONTENTS 
[...] 
(gdb) x/250a 0×00007fff659af000-2000 
0×7fff659ae830: 0×0 0×1500000000 
0×7fff659ae840: 0×7fff659ae860 0×105dafeb9 <bar+25> 
0×7fff659ae850: 0×0 0×1400000000 
0×7fff659ae860: 0×7fff659ae880 0×105dafeb9 <bar+25> 
0×7fff659ae870: 0×0 0×1300000000 
0×7fff659ae880: 0×7fff659ae8a0 0×105dafeb9 <bar+25> 
0×7fff659ae890: 0×0 0×1200000000 
0×7fff659ae8a0: 0×7fff659ae8c0 0×105dafeb9 <bar+25> 
0×7fff659ae8b0: 0×0 0×1100000000 

Stack Overflow (User Mode)    233 
0×7fff659ae8c0: 0×7fff659ae8e0 0×105dafeb9 <bar+25> 
0×7fff659ae8d0: 0×0 0×1000000000 
0×7fff659ae8e0: 0×7fff659ae900 0×105dafeb9 <bar+25> 
0×7fff659ae8f0: 0×0 0xf00000000 
0×7fff659ae900: 0×7fff659ae920 0×105dafeb9 <bar+25> 
0×7fff659ae910: 0×0 0xe00000000 
0×7fff659ae920: 0×7fff659ae940 0×105dafeb9 <bar+25> 
0×7fff659ae930: 0×0 0xd00000000 
0×7fff659ae940: 0×7fff659ae960 0×105dafeb9 <bar+25> 
0×7fff659ae950: 0×0 0xc00000000 
0×7fff659ae960: 0×7fff659ae980 0×105dafeb9 <bar+25> 
0×7fff659ae970: 0×0 0xb00000000 
0×7fff659ae980: 0×7fff659ae9a0 0×105dafeb9 <bar+25> 
0×7fff659ae990: 0×0 0xa00000000 
0×7fff659ae9a0: 0×7fff659ae9c0 0×105dafeb9 <bar+25> 
0×7fff659ae9b0: 0×0 0×900000000 
0×7fff659ae9c0: 0×7fff659ae9e0 0×105dafeb9 <bar+25> 
0×7fff659ae9d0: 0×0 0×800000000 
0×7fff659ae9e0: 0×7fff659aea00 0×105dafeb9 <bar+25> 
0×7fff659ae9f0: 0×0 0×700000000 
0×7fff659aea00: 0×7fff659aea20 0×105dafeb9 <bar+25> 
0×7fff659aea10: 0×0 0×600000000 
0×7fff659aea20: 0×7fff659aea40 0×105dafeb9 <bar+25> 
0×7fff659aea30: 0×0 0×5659b9fe0 
0×7fff659aea40: 0×7fff659aea60 0×105dafeb9 <bar+25 
0×7fff659aea50: 0×7fff659aea70 0×4659bd31f 
0×7fff659aea60: 0×7fff659aea80 0×105dafeb9 <bar+25> 
0×7fff659aea70: 0×7fff659aeaf0 0×3659b031a 
0×7fff659aea80: 0×7fff659aeaa0 0×105dafeb9 <bar+25> 
0×7fff659aea90: 0×7fff659af5c0 0×200000000 
0×7fff659aeaa0: 0×7fff659aeac0 0×105dafeb9 <bar+25> 
0×7fff659aeab0: 0×100000000 0×1659aeb18 
0×7fff659aeac0: 0×7fff659aead0 0×105dafece <foo+14> 
0×7fff659aead0: 0×7fff659aeaf0 0×105dafeeb <main+27> 
0×7fff659aeae0: 0×7fff659aeb18 0×1 
—Type to continue, or q to quit— 
0×7fff659aeaf0: 0×7fff659aeb08 0×105dafe94 <start+52> 
0×7fff659aeb00: 0×0 0×0 
[...] 
0×7fff659aeff0: 0×3139336561303363 0×316235 
Interesting, if we set the lowest frame down and try to get register info GDB core 
dumps: 
(gdb) frame 262102 
#262102 0x0000000105dafeb9 in bar (i=1) 
13 bar(i+1); 
(gdb) info r 
Segmentation fault: 11 (core dumped) 
 
 

234    PART 3: Core Dump Analysis Patterns (Mac OS X) 
Looking at its core dump shows that it also experienced stack overflow: 
(gdb) bt 
#0 0x00007fff8c1bacf0 in __sfvwrite () 
#1 0x00007fff8c189947 in __vfprintf () 
#2 0x00007fff8c184edb in vsnprintf_l () 
#3 0x00007fff8c1566be in __sprintf_chk () 
#4 0x000000010bd14d15 in print_displacement () 
#5 0x000000010bd10ddf in OP_E () 
#6 0x000000010bd13f9b in print_insn () 
#7 0x000000010bc164ce in length_of_this_instruction () 
#8 0x000000010bc9e296 in x86_analyze_prologue () 
#9 0x000000010bc9f1f3 in x86_frame_prev_register () 
#10 0x000000010bc91d70 in frame_register_unwind () 
#11 0x000000010bc92015 in frame_unwind_register () 
#12 0x000000010bc91d70 in frame_register_unwind () 
#13 0x000000010bc92015 in frame_unwind_register () 
#14 0x000000010bc91d70 in frame_register_unwind () 
#15 0x000000010bc92015 in frame_unwind_register () 
#16 0x000000010bc91d70 in frame_register_unwind () 
#17 0x000000010bc92015 in frame_unwind_register () 
#18 0x000000010bc91d70 in frame_register_unwind () 
#19 0x000000010bc92015 in frame_unwind_register () 
#20 0x000000010bc91d70 in frame_register_unwind () 
#21 0x000000010bc92015 in frame_unwind_register () 
#22 0x000000010bc91d70 in frame_register_unwind () 
#23 0x000000010bc92015 in frame_unwind_register () 
#24 0x000000010bc91d70 in frame_register_unwind () 
#25 0x000000010bc92015 in frame_unwind_register () 
#26 0x000000010bc91d70 in frame_register_unwind () 
#27 0x000000010bc92015 in frame_unwind_register () 
#28 0x000000010bc91d70 in frame_register_unwind () 
#29 0x000000010bc92015 in frame_unwind_register () 
#30 0x000000010bc91d70 in frame_register_unwind () 
#31 0x000000010bc92015 in frame_unwind_register () 
#32 0x000000010bc91d70 in frame_register_unwind () 
#33 0x000000010bc92015 in frame_unwind_register () 
#34 0x000000010bc91d70 in frame_register_unwind () 
#35 0x000000010bc92015 in frame_unwind_register () 
#36 0x000000010bc91d70 in frame_register_unwind () 
#37 0x000000010bc92015 in frame_unwind_register () 
#38 0x000000010bc91d70 in frame_register_unwind () 
#39 0x000000010bc92015 in frame_unwind_register () 
#40 0x000000010bc91d70 in frame_register_unwind () 
#41 0x000000010bc92015 in frame_unwind_register () 
#42 0x000000010bc91d70 in frame_register_unwind () 
#43 0x000000010bc92015 in frame_unwind_register () 
 
 

Stack Overflow (User Mode)    235 
The source code of our modeling application: 
void bar(int i) 
{ 
bar(i+1); 
} 
 
void foo() 
{ 
bar(1); 
} 
 
int main(int argc, const char * argv[]) 
{ 
foo(); 
return 0; 
} 
 
 

236    PART 3: Core Dump Analysis Patterns (Mac OS X) 
Active Thread 
This pattern was introduced in Accelerated Mac OS X Core Dump Analysis24 training. 
Basically, it is a thread that is not waiting or suspended (most threads are). However, 
from a memory dump it is not possible to find out whether it was Spiking Thread 
(Volume 1, page 305) at the dump generation time (unless we have a set of memory 
snapshots and in each one we have the same or similar backtrace) and we don’t have 
any Paratext (page 225) with CPU consumption stats for threads. For example, in one 
core dump we have these threads: 
(gdb) info threads 
12 0x98c450ee in __workq_kernreturn () 
11 0x98c4280e in semaphore_wait_trap () 
10 0x98c448e2 in __psynch_cvwait () 
9 0×00110171 in std::_Rb_tree<int, std::pair<int const, _iCapture*>, 
std::_Select1st<std::pair<int const, _iCapture*> >, std::less<int>, 
std::allocator<std::pair<int const, _iCapture*> > >::find () 
8 0×98c428e6 in mach_wait_until () 
7 0×98c448e2 in __psynch_cvwait () 
6 0×98c427d2 in mach_msg_trap () 
5 0×98c427d2 in mach_msg_trap () 
4 0×98c428e6 in mach_wait_until () 
3 0×98c427d2 in mach_msg_trap () 
2 0×98c459ae in kevent () 
*  1 0×014bcee0 in cgGLGetLatestProfile () 
Threads #9 and #1 are not waiting so we inspect their backtraces: 
(gdb) bt 
#0  0x014bcee0 in cgGLGetLatestProfile () 
#1  0x99060dd5 in exit () 
#2  0x001ef859 in os_exit () 
#3  0x001dc873 in luaD_precall () 
#4  0x001e7d9e in luaV_execute () 
#5  0x001dc18b in luaD_rawrunprotected () 
#6  0x001dced4 in lua_resume () 
#7  0x0058a526 in ticLuaManager::executeProgram () 
#8  0x005a09af in ticLuaScript::_execute () 
#9  0x003a6480 in darcScript::execute () 
#10 0x003af4d8 in darcTimeline::execute () 
#11 0x0034a2ba in darcSequenceur::executeAll () 
#12 0x0036904b in darcEventManager::ExecuteEventHandler () 
#13 0x003a37d2 in darcScene::process () 
                                                                 
24  http://www.patterndiagnostics.com/accelerated-macosx-core-dump-analysis-
book 

Active Thread    237 
#14 0x0034a2ba in darcSequenceur::executeAll () 
#15 0x0036904b in darcEventManager::ExecuteEventHandler () 
#16 0x00343ec0 in darcContext::process () 
#17 0x00347339 in darcContext::main () 
#18 0x003cf73d in darcPlayerImpl::renderOneFrame () 
#19 0x003cf078 in darcPlayerImpl::render () 
#20 0x000b1f6f in Run () 
#21 0x000b1fe9 in tiMain () 
#22 0x000c73ee in main () 
(gdb) thread 9 
[Switching to thread 9 (core thread 8)] 
0x00110171 in std::_Rb_tree<int, std::pair<int const, _iCapture*>, 
std::_Select1st<std::pair<int const, _iCapture*> >, std::less<int>, 
std::allocator<std::pair<int const, _iCapture*> > >::find () 
(gdb) bt 
#0  0x00110171 in std::_Rb_tree<int, std::pair<int const, _iCapture*>, 
std::_Select1st<std::pair<int const, _iCapture*> >, std::less<int>, 
std::allocator<std::pair<int const, _iCapture*> > >::find () 
#1  0x0010f936 in ticVideoManager::isPaused () 
#2  0x00201801 in ticMLT_VideoCapture::Execute () 
#3  0x0020aa0b in ticModuleGraph::runOnce () 
#4  0x002632be in TrackingApp::ProcessTracking () 
#5  0x005b2f5d in ticMLTTracking::processInternal () 
#6  0x005b322d in ticMLTTracking::processThread () 
#7  0x005b36f3 in trackingThread () 
#8  0x004eaf1e in ticThread::threadFunc () 
#9  0x99023557 in _pthread_start () 
#10 0x9900dcee in thread_start () 
Windows equivalent would be a process memory dump which doesn’t have any 
information saved for !runaway WinDbg command. 
 
 

238    PART 3: Core Dump Analysis Patterns (Mac OS X) 
[This page is intentionally left blank] 
 
 

Malware: A Definition    239 
PART 4: Malware Analysis Patterns 
Malware: A Definition 
Here we provide a definition of malware that highlights the importance of structural and 
behavioral patterns: 
Malware: software that uses planned alteration of structure and behavior of 
software to serve malicious purposes. 
Notice the recursive character of that definition that includes self-modifying malware 
and also rootkits where a malicious purpose is to conceal. 
 
 

240    PART 4: Malware Analysis Patterns 
Fake Module 
We started cataloging elemental malware detection and analysis patterns. The first such 
a pattern is called Deviant Module (page 133). In Fake Module pattern, one of the 
loaded modules masquerades as a legitimate system DLL or a widely known value 
adding DLL from some popular 3rd-party product. To illustrate this pattern we modeled 
it as Victimware: a process crashed after loading a malware module: 
0:000> k 
*** Stack trace for last set context - .thread/.cxr resets it 
Child-SP          RetAddr           Call Site 
00000000`0026f978 00000001`3f89103a 0x0 
00000000`0026f980 00000001`3f8911c4 FakeModule!wmain+0x3a 
00000000`0026f9c0 00000000`76e3652d FakeModule!__tmainCRTStartup+0x144 
00000000`0026fa00 00000000`7752c521 kernel32!BaseThreadInitThunk+0xd 
00000000`0026fa30 00000000`00000000 ntdll!RtlUserThreadStart+0x1d 
When we inspected loaded modules we didn’t find anything suspicious: 
0:000> lmp 
start             end                 module name 
00000000`76e20000 00000000`76f3f000   kernel32 <none> 
00000000`77500000 00000000`776a9000   ntdll    <none> 
00000001`3f890000 00000001`3f8a6000   FakeModule <none> 
000007fe`f8cb0000 000007fe`f8cc7000   winspool <none> 
000007fe`fdb30000 000007fe`fdb9c000   KERNELBASE <none> 
However, when checking module images for any modifications we find that 
winspool module was not compared with the corresponding existing binary from 
Microsoft symbol server: 
0:000> !for_each_module "!chkimg -v -d @#ModuleName" 
Searching for module with expression: kernel32 
Will apply relocation fixups to file used for comparison 
Will ignore NOP/LOCK errors 
Will ignore patched instructions 
Image specific ignores will be applied 
Comparison image path: 
C:\WSDK8\Debuggers\x64\sym\kernel32.dll\503285C111f000\kernel32.dll 
No range specified 
Scanning section:    .text 
Size: 633485 
Range to scan: 76e21000-76ebba8d 
Total bytes compared: 633485(100%) 
Number of errors: 0 
0 errors : kernel32 
Searching for module with expression: ntdll 

Fake Module    241 
Will apply relocation fixups to file used for comparison 
Will ignore NOP/LOCK errors 
Will ignore patched instructions 
Image specific ignores will be applied 
Comparison image path: 
C:\WSDK8\Debuggers\x64\sym\ntdll.dll\4EC4AA8E1a9000\ntdll.dll 
No range specified 
Scanning section:    .text 
Size: 1049210 
Range to scan: 77501000-7760127a 
Total bytes compared: 1049210(100%) 
Number of errors: 0 
Scanning section:       RT 
Size: 474 
Range to scan: 77602000-776021da 
Total bytes compared: 474(100%) 
Number of errors: 0 
0 errors : ntdll 
Searching for module with expression: FakeModule 
Error for FakeModule: Could not find image file for the module. Make sure 
binaries are included in the symbol path. 
Searching for module with expression: winspool 
Error for winspool: Could not find image file for the module. Make sure 
binaries are included in the symbol path. 
Searching for module with expression: KERNELBASE 
Will apply relocation fixups to file used for comparison 
Will ignore NOP/LOCK errors 
Will ignore patched instructions 
Image specific ignores will be applied 
Comparison image path: 
C:\WSDK8\Debuggers\x64\sym\KERNELBASE.dll\503285C26c000\KERNELBASE.dll 
No range specified 
Scanning section:    .text 
Size: 302047 
Range to scan: 7fefdb31000-7fefdb7abdf 
Total bytes compared: 302047(100%) 
Number of errors: 0 
0 errors : KERNELBASE 
Checking module data reveals that it was loaded not from System32 folder and 
also doesn’t have any version information: 
 
 

242    PART 4: Malware Analysis Patterns 
0:000> lmv m winspool 
start             end                 module name 
000007fe`f8cb0000 000007fe`f8cc7000   winspool   (deferred) 
Image path: C:\Work\AWMA\FakeModule\x64\Release\winspool.drv 
Image name: winspool.drv 
Timestamp:        Fri Dec 28 22:22:42 2012 (50DE1BB2) 
CheckSum:         00000000 
ImageSize:        00017000 
File version:     0.0.0.0 
Product version:  0.0.0.0 
File flags:       0 (Mask 0) 
File OS:          0 Unknown Base 
File type:        0.0 Unknown 
File date:        00000000.00000000 
Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4 
We could see that path from running the following command as well: 
0:000> !for_each_module 
00: 0000000076e20000  0000000076f3f000         kernel32 
C:\Windows\System32\kernel32.dll                      kernel32.dll 
01: 0000000077500000  00000000776a9000            ntdll 
C:\Windows\System32\ntdll.dll                            ntdll.dll 
02: 000000013f890000  000000013f8a6000       FakeModule 
C:\Work\AWMA\FakeModule\x64\Release\FakeModule.exe  FakeModule.exe 
03: 000007fef8cb0000  000007fef8cc7000         winspool 
C:\Work\AWMA\FakeModule\x64\Release\winspool.drv 
04: 000007fefdb30000  000007fefdb9c000       KERNELBASE 
C:\Windows\System32\KERNELBASE.dll                  KERNELBASE.dll 
Or from PEB: 
0:000> !peb 
PEB at 000007fffffdf000 
[...] 
7fef8cb0000 50de1bb2 Dec 28 22:22:42 2012 
C:\Work\AWMA\FakeModule\x64\Release\winspool.drv 
[...] 
Another sign is the module size in memory which is much smaller than the real 
winspool.drv: 
0:000> ? 000007fe`f8cc7000 - 000007fe`f8cb0000 
Evaluate expression: 94208 = 00000000`0001700 
Module size can help if legitimate module from the well-known folder was 
replaced. Module debug directory, and the size of export and import directories are also 
different with the original one revealing the development folder: 

Fake Module    243 
0:000> !dh 000007fe`f8cb0000 
[...] 
   0 [       0] address [size] of Export Directory 
[...] 
9000 [     208] address [size] of Import Address Table Directory 
[...] 
Debug Directories(2) 
Type       Size     Address  Pointer 
cv           49        e2c0     cac0 Format: RSDS, guid, 1, 
C:\Work\AWMA\FakeModule\x64\Release\winspool.pdb 
This can also be seen from the output of !lmi command: 
0:000> !lmi 7fef8cb0000 
Loaded Module Info: [7fef8cb0000] 
Module: winspool 
Base Address: 000007fef8cb0000 
Image Name: winspool.drv 
Machine Type: 34404 (X64) 
Time Stamp: 50de1bb2 Fri Dec 28 22:22:42 2012 
Size: 17000 
CheckSum: 0 
Characteristics: 2022 
Debug Data Dirs: Type  Size     VA  Pointer 
CODEVIEW    49,  e2c0,    cac0 RSDS - GUID: {29D85193-1C9D-4997-95BA-
DD190FA3C1BF} 
Age: 1, Pdb: C:\Work\AWMA\FakeModule\x64\Release\winspool.pdb 
??    10,  e30c,    cb0c [Data not mapped] 
Symbol Type: DEFERRED - No error - symbol load deferred 
Load Report: no symbols loaded 
 
 

244    PART 4: Malware Analysis Patterns 
RIP Stack Trace 
Injected code address may not be in address ranges of loaded modules. In such cases, 
in the execution call history we would see plain EIP and RIP return addresses on stack 
traces. We call this pattern RIP Stack Trace partly because we have seen these 
addresses after something had gone wrong, and a process crashed: 
0:005> k 
ChildEBP RetAddr 
02aec974 77655620 ntdll!KiFastSystemCallRet 
02aec978 77683c62 ntdll!NtWaitForSingleObject+0xc 
02aec9fc 77683d4b ntdll!RtlReportExceptionEx+0x14b 
02aeca3c 7769fa87 ntdll!RtlReportException+0x3c 
02aeca50 7769fb0d ntdll!RtlpTerminateFailureFilter+0x14 
02aeca5c 775f9bdc ntdll!RtlReportCriticalFailure+0x6b 
02aeca70 775f4067 ntdll!_EH4_CallFilterFunc+0x12 
02aeca98 77655f79 ntdll!_except_handler4+0x8e 
02aecabc 77655f4b ntdll!ExecuteHandler2+0x26 
02aecb6c 77655dd7 ntdll!ExecuteHandler+0x24 
02aecb6c 7769faf8 ntdll!KiUserExceptionDispatcher+0xf 
02aecee0 776a0704 ntdll!RtlReportCriticalFailure+0x5b 
02aecef0 776a07f2 ntdll!RtlpReportHeapFailure+0x21 
02aecf24 7766b1a5 ntdll!RtlpLogHeapFailure+0xa1 
02aecf6c 7765730a ntdll!RtlpCoalesceFreeBlocks+0x4b9 
02aed064 77657545 ntdll!RtlpFreeHeap+0x1e2 
02aed080 75e47e4b ntdll!RtlFreeHeap+0x14e 
02aed0c8 77037277 kernel32!GlobalFree+0x47 
02aed0dc 774b4a1f ole32!ReleaseStgMedium+0x124 
02aed0f0 77517feb urlmon!ReleaseBindInfo+0x4c 
02aed100 774d9a87 urlmon!CINet::ReleaseCNetObjects+0x3d 
02aed118 774d93f0 urlmon!CINetHttp::OnWininetRequestHandleClosing+0x60 
02aed12c 76432078 urlmon!CINet::CINetCallback+0x2de 
02aed274 76438f5d wininet!InternetIndicateStatus+0xfc 
02aed2a4 7643937a wininet!HANDLE_OBJECT::~HANDLE_OBJECT+0xc9 
02aed2c0 7643916b 
wininet!INTERNET_CONNECT_HANDLE_OBJECT::~INTERNET_CONNECT_HANDLE_OBJECT+0x
209 
02aed2cc 76438d5e wininet!HTTP_REQUEST_HANDLE_OBJECT::`vector deleting 
destructor'+0xd 
02aed2dc 76434e72 wininet!HANDLE_OBJECT::Dereference+0x22 
02aed2e8 76439419 wininet!DereferenceObject+0x21 
02aed310 76439114 wininet!_InternetCloseHandle+0x9d 
02aed330 0004aaaf wininet!InternetCloseHandle+0x11e 
WARNING: Frame IP not in any known module. Following frames may be wrong. 
02aed33c 774c5d25 0×4aaaf 
02aed358 774c5d95 urlmon!CINet::TerminateRequest+0×82 
02aed364 774c5d7c urlmon!CINet::MyUnlockRequest+0×10 
02aed370 774c5d63 urlmon!CINetProtImpl::UnlockRequest+0×10 
02aed37c 774c5d49 urlmon!CINetEmbdFilter::UnlockRequest+0×11 
02aed388 774b743d urlmon!CINet::UnlockRequest+0×13 
02aed394 774b73e1 urlmon!COInetProt::UnlockRequest+0×11 

RIP Stack Trace    245 
02aed3a8 774b7530 urlmon!CTransaction::UnlockRequest+0×36 
02aed3b4 774b74e0 urlmon!CTransData::~CTransData+0×3a 
02aed3c0 774b74c9 urlmon!CTransData::`scalar deleting destructor’+0xd 
02aed3d8 774e221f urlmon!CTransData::Release+0×25 
02aed3e0 774b6d0a 
urlmon!CReadOnlyStreamDirect::~CReadOnlyStreamDirect+0×1a 
02aed3ec 774b7319 urlmon!CReadOnlyStreamDirect::`vector deleting 
destructor’+0xd 
02aed404 774b72be urlmon!CReadOnlyStreamDirect::Release+0×25 
02aed410 774b71f4 urlmon!CBinding::~CBinding+0xb9 
02aed41c 774b71dd urlmon!CBinding::`scalar deleting destructor’+0xd 
02aed434 6b20b0e8 urlmon!CBinding::Release+0×25 
02aed448 6b20b0ba mshtml!ATL::AtlComPtrAssign+0×2b 
02aed458 6b20b8de 
mshtml!ATL::CComPtr<IBindCallbackInternal>::operator=+0×15 
02aed464 6b20b8aa mshtml!CBindingXSSFilter::TearDown+0×2b 
02aed46c 6b20b887 mshtml!BindingXSSFilter_TearDown+0×19 
02aed478 6b0da61a mshtml!CStreamProxy::Passivate+0×12 
02aed484 6b0ddf3a mshtml!CBaseFT::Release+0×1d 
02aed4ac 6b0e0b70 mshtml!CDwnBindData::TerminateBind+0×11d 
02aed4b8 6b11a2a9 mshtml!CDwnBindData::TerminateOnApt+0×14 
02aed4ec 6b105066 mshtml!GlobalWndOnMethodCall+0xfb 
02aed50c 7742fd72 mshtml!GlobalWndProc+0×183 
02aed538 7742fe4a user32!InternalCallWinProc+0×23 
02aed5b0 7743018d user32!UserCallWinProcCheckWow+0×14b 
02aed614 7743022b user32!DispatchMessageWorker+0×322 
02aed624 6ecac1d5 user32!DispatchMessageW+0xf 
02aef72c 6ec5337e ieframe!CTabWindow::_TabWindowThreadProc+0×54c 
02aef7e4 760f426d ieframe!LCIETab_ThreadProc+0×2c1 
02aef7f4 75e4d0e9 iertutil!CIsoScope::RegisterThread+0xab 
02aef800 776319bb kernel32!BaseThreadInitThunk+0xe 
02aef840 7763198e ntdll!__RtlUserThreadStart+0×23 
02aef858 00000000 ntdll!_RtlUserThreadStart+0×1b 
However, such addresses need to be checked whether they belong to .NET CLR 
JIT Code (Volume 3, page 132). 
 
 

246    PART 4: Malware Analysis Patterns 
Driver Device Collection 
This pattern can be used to compare the current list of device and driver objects with 
some saved reference list to find out any changes. This listing can be done by using 
!object command: 
0: kd> !object \Driver 
[...] 
0: kd> !object \FileSystem 
[...] 
0: kd> !object \Device 
[...] 
Note that the collection is called Driver Device and not Device Driver. 
 
 

Pre-Obfuscation Residue    247 
Pre-Obfuscation Residue 
This pattern is closely linked to packed and/or obfuscated code. Depending on a level of 
obfuscation and/or packing some initial code and data structures and patterns including 
fragments of strings may leak in post-obfuscation data giving a clue to intended 
software behavior: 
0:000> s-sa 00000000`00fd4000 L6000 
[...] 
00000000`00fd943d  "o__" 
00000000`00fd9449  "91!We" 
00000000`00fd945d  "H5!" 
00000000`00fd94d2  "zQ@" 
00000000`00fd94dd  "ommandS" 
00000000`00fd94f4  "IsDeb" 
00000000`00fd94fd  "uggerP" 
00000000`00fd9507  "Enc" 
00000000`00fd950c  "v)3Po4t" 
00000000`00fd9515  "DeXU" 
00000000`00fd9520  "xFe" 
00000000`00fd952a  "5Eb" 
00000000`00fd9533  "SI=l8kev" 
00000000`00fd953e  "Z_1m" 
00000000`00fd9547  "@IF" 
[...] 
 
 

248    PART 4: Malware Analysis Patterns 
Packed Code 
Packed Code is a frequent ingredient of armored malware. Here we demonstrate a few 
WinDbg commands to detect UPX packed modules with little or no expected strings: 
0:000> !dh 00000000`00fd40b0 
File Type: DLL 
FILE HEADER VALUES 
14C machine (i386) 
3 number of sections 
time date stamp Fri Jan 18 21:27:25 2013 
0 file pointer to symbol table 
0 number of symbols 
E0 size of optional header 
2102 characteristics 
Executable 
32 bit word machine 
DLL 
OPTIONAL HEADER VALUES 
10B magic # 
11.00 linker version 
6000 size of code 
1000 size of initialized data 
F000 size of uninitialized data 
15600 address of entry point 
10000 base of code 
----- new ----- 
0000000010000000 image base 
1000 section alignment 
200 file alignment 
2 subsystem (Windows GUI) 
6.00 operating system version 
0.00 image version 
6.00 subsystem version 
17000 size of image 
1000 size of headers 
0 checksum 
0000000000100000 size of stack reserve 
0000000000001000 size of stack commit 
0000000000100000 size of heap reserve 
0000000000001000 size of heap commit 
140  DLL characteristics 
Dynamic base 
NX compatible 
16274 [      AC] address [size] of Export Directory 
161DC [      98] address [size] of Import Directory 
16000 [     1DC] address [size] of Resource Directory 
0 [       0] address [size] of Exception Directory 

Packed Code    249 
0 [       0] address [size] of Security Directory 
16320 [      10] address [size] of Base Relocation Directory 
0 [       0] address [size] of Debug Directory 
0 [       0] address [size] of Description Directory 
0 [       0] address [size] of Special Directory 
0 [       0] address [size] of Thread Storage Directory 
157CC [      48] address [size] of Load Configuration Directory 
0 [       0] address [size] of Bound Import Directory 
0 [       0] address [size] of Import Address Table Directory 
0 [       0] address [size] of Delay Import Directory 
0 [       0] address [size] of COR20 Header Directory 
0 [       0] address [size] of Reserved Directory 
SECTION HEADER #1 
UPX0 name 
F000 virtual size 
1000 virtual address 
0 size of raw data 
400 file pointer to raw data 
0 file pointer to relocation table 
0 file pointer to line numbers 
0 number of relocations 
0 number of line numbers 
E0000080 flags 
Uninitialized Data 
(no align specified) 
Execute Read Write 
SECTION HEADER #2 
UPX1 name 
6000 virtual size 
10000 virtual address 
5A00 size of raw data 
400 file pointer to raw data 
0 file pointer to relocation table 
0 file pointer to line numbers 
0 number of relocations 
0 number of line numbers 
E0000040 flags 
Initialized Data 
(no align specified) 
Execute Read Write 
SECTION HEADER #3 
.rsrc name 
1000 virtual size 
16000 virtual address 
400 size of raw data 
5E00 file pointer to raw data 
0 file pointer to relocation table 
0 file pointer to line numbers 
0 number of relocations 
0 number of line numbers 

250    PART 4: Malware Analysis Patterns 
C0000040 flags 
Initialized Data 
(no align specified) 
Read Write 
0:000> s-sa 00000000`00fd40b0 L6600 
00000000`00fd40fd  "!This program cannot be run in D" 
00000000`00fd411d  "OS mode." 
00000000`00fd4188  "Rich" 
00000000`00fd4290  "UPX0" 
00000000`00fd42b8  "UPX1" 
00000000`00fd42e0  ".rsrc" 
00000000`00fd448b  "3.08" 
00000000`00fd4490  "UPX! " 
00000000`00fd449b  "YhHM4" 
00000000`00fd44d1  "vqx" 
[...] 
Such in-memory modules (not yet initialized by a loader) can be saved to disk 
using .writemem command and unpacked. Once loaded and relocated to some address 
they still have UPX sections but they now have more strings: 
0:000> s-sa 00000000`691c0000 L300 
00000000`691c004d  "!This program cannot be run in D" 
00000000`691c006d  "OS mode." 
00000000`691c00d8  "Rich" 
00000000`691c01e0  "UPX0" 
00000000`691c0207  "`UPX1" 
00000000`691c022f  "`.rsrc" 
[...] 
00000000`691d620b  "uGC" 
00000000`691d621c  "KERNEL32.DLL" 
00000000`691d622a  "LoadLibraryA" 
00000000`691d6238  "GetProcAddress" 
00000000`691d6248  "VirtualProtect" 
00000000`691d6258  "VirtualAlloc" 
00000000`691d6266  "VirtualFree" 
[...] 
0:000> s-su 00000000`691c0000 L(00000000`691d7000-00000000`691c0000) 
[...] 
00000000`691c8178  “http://www.patterndiagnostics.com” 
00000000`691c8260  “mscoree.dll” 
[...] 
 
 

Raw Pointer    251 
Raw Pointer 
This pattern is about pointers without matching symbol files. They may be in the 
expected module range or in some other known module range in the form of module + 
offset or can be completely out of range of any module from the loaded module list and 
therefore just a number. For example, usually we have certain structures or arrays 
(tables) where we expect pointers with matching symbols such as IAT, IDT and 32-bit 
SSDT where an occurrence of a raw pointer immediately triggers a suspicion such as in 
this Import Address Table from ProcessA: 
[...] 
00000001`3f8a9048 00000000`76e282d0 ntdll!RtlSizeHeap 
00000001`3f8a9050 00000000`76bf9070 kernel32!GetStringTypeWStub 
00000001`3f8a9058 00000000`76c03580 kernel32!WideCharToMultiByteStub 
00000001`3f8a9060 00000000`76e33f20 ntdll!RtlReAllocateHeap 
00000001`3f8a9068 00000000`76e533a0 ntdll!RtlAllocateHeap 
00000001`3f8a9070 00000000`76bfc420 kernel32!GetCommandLineWStub 
00000001`3f8a9078 00000001`3f8a1638 ProcessA+0×10ac 
00000001`3f8a9080 00000000`76c2cc50 kernel32!IsProcessorFeaturePresent 
00000001`3f8a9088 00000000`76c02d60 kernel32!GetLastErrorStub 
00000001`3f8a9090 00000000`76c02d80 kernel32!SetLastError 
00000001`3f8a9098 00000000`76bf3ee0 kernel32!GetCurrentThreadIdStub 
[...] 
Note that structures are not limited to the above and can me any OS or even 
application specific structure where we have symbol files. Raw pointers that are outside 
of expected module range are covered in the next pattern. 
 
 

252    PART 4: Malware Analysis Patterns 
Out-of-Module Pointer 
This pattern is about pointers to addresses outside the container module range. A 
typical example here would be some kernel table or structure, for example, a driver IRP 
dispatch table having pointers to outside that driver module address range. Other 
examples may include 32-bit SSDT pointing outside nt module range and IDT entries 
pointing outside hal and expected drivers: 
[...] 
818809dc 8193c4e7 nt!NtQueryOpenSubKeys 
818809e0 8193c76b nt!NtQueryOpenSubKeysEx 
818809e4 81a909b0 nt!NtQueryPerformanceCounter 
818809e8 819920e7 nt!NtQueryQuotaInformationFile 
818809ec 819e34f2 nt!NtQuerySection 
818809f0 819f470b nt!NtQuerySecurityObject 
818809f4 81a882fe nt!NtQuerySemaphore 
818809f8 819eff54 nt!NtQuerySymbolicLinkObject 
818809fc 81a8a223 nt!NtQuerySystemEnvironmentValue 
81880a00 81a8a831 nt!NtQuerySystemEnvironmentValueEx 
81880a04 96ca1a73 
81880a08 81a7ac06 nt!NtQuerySystemTime 
81880a0c 81a8f913 nt!NtQueryTimer 
81880a10 81a7aeeb nt!NtQueryTimerResolution 
81880a14 8193985a nt!NtQueryValueKey 
81880a18 819e9273 nt!NtQueryVirtualMemory 
81880a1c 8199274e nt!NtQueryVolumeInformationFile 
81880a20 81a1a655 nt!NtQueueApcThread 
[...] 
0: kd> lm m nt 
start end module name 
81800000 81ba1000 nt 
Such pointers may also be Raw Pointers (page 251) but it also could be the 
case that all pointers are raw in the absence of symbols with only a few outside 
of the expected range. 
 
 

Patched Code    253 
Patched Code 
Hooksware (Volume 2, page 63) pattern originally came from memory dump analysis 
pattern catalog and is too general for malware analysis pattern catalog. So we decided 
to factor out 3 separate patterns. The first one includes cases such as in-place patching: 
0:004> u ntdll!ZwQueryDirectoryFile 
ntdll!ZwQueryDirectoryFile: 
77814db4 b8da000000      mov     eax,0DAh 
77814db9 bae8af0500      mov     edx,5AFE8h 
77814dbe ff12            call    dword ptr [edx] 
77814dc0 c22c00          ret     2Ch 
77814dc3 90              nop 
ntdll!NtQueryDirectoryObject: 
77814dc4 b8db000000      mov     eax,0DBh 
77814dc9 ba0003fe7f      mov     edx,offset SharedUserData!SystemCallStub 
(7ffe0300) 
77814dce ff12            call    dword ptr [edx] 
And detour patching: 
0:004> u wininet!InternetReadFile 
wininet!InternetReadFile: 
7758654b e98044ac88      jmp     0004a9d0 
77586550 83ec24          sub     esp,24h 
77586553 53              push    ebx 
77586554 56              push    esi 
77586555 57              push    edi 
77586556 33ff            xor     edi,edi 
77586558 393db8116277    cmp     dword ptr [wininet!GlobalDataInitialized 
(776211b8)],edi 
7758655e 897df4          mov     dword ptr [ebp-0Ch],edi 
In case of WinDbg, such pattern is usually detected on the crash spot such as 
from RIP Stack Trace (page 244) or from !chkimg command output. 
 
 

254    PART 4: Malware Analysis Patterns 
String Hint 
This pattern covers traces of ASCII and UNICODE strings that look suspicious such as 
website, password and HTTP forms or strange names that intuitively shouldn’t be 
present according to the purpose of a module or its container process (example is taken 
from Victimware presentation case study25): 
0:005> s-sa 00040000 L1d000 
0004004d  "!This program cannot be run in D" 
0004006d  "OS mode." 
00040081  "3y@" 
000400b8  "Rich" 
000401d0  ".text" 
000401f7  "`.rdata" 
0004021f  "@.data" 
00040248  ".reloc" 
[...] 
00054018  "GET /stat?uptime=%d&downlink=%d&" 
00054038  "uplink=%d&id=%s&statpass=%s&comm" 
00054058  "ent=%s HTTP/1.0" 
000540ac  "%s%s%s" 
000540d8  "ftp://%s:%s@%s:%d" 
000540fc  "Accept-Encoding:" 
00054118  "Accept-Encoding:" 
00054130  "0123456789ABCDEF" 
00054144  "://" 
00054160  "POST %s HTTP/1.0" 
00054172  "Host: %s" 
0005417c  "User-Agent: %s" 
0005418c  "Accept: text/html" 
0005419f  "Connection: Close" 
000541b2  "Content-Type: application/x-www-" 
000541d2  "form-urlencoded" 
000541e3  "Content-Length: %d" 
000541fc  "id=" 
00054208  "POST %s HTTP/1.1" 
0005421a  "Host: %s" 
00054224  "User-Agent: %s" 
00054234  "Accept: text/html" 
00054247  "Connection: Close" 
0005425a  "Content-Type: application/x-www-" 
0005427a  "form-urlencoded" 
0005428b  "Content-Length: %d" 
000542a4  "id=%s&base=" 
000542b8  "id=%s&brw=%d&type=%d&data=" 
000542d8  "POST %s HTTP/1.1" 
                                                                 
25 http://www.patterndiagnostics.com/Victimware-materials 

String Hint    255 
000542ea  "Host: %s" 
000542f4  "User-Agent: %s" 
00054304  "Accept: text/html" 
00054317  "Connection: Close" 
0005432a  "Content-Type: application/x-www-" 
0005434a  "form-urlencoded" 
0005435b  "Content-Length: %d" 
00054378  "id=%s&os=%s&plist=" 
00054390  "POST %s HTTP/1.1" 
000543a2  "Host: %s" 
000543ac  "User-Agent: %s" 
000543bc  "Accept: text/html" 
000543cf  "Connection: Close" 
000543e2  "Content-Type: application/x-www-" 
00054402  "form-urlencoded" 
00054413  "Content-Length: %d" 
00054430  "id=%s&data=%s" 
00054440  "POST %s HTTP/1.1" 
00054452  "Host: %s" 
0005445c  "User-Agent: %s" 
0005446c  "Accept: text/html" 
0005447f  "Connection: Close" 
00054492  "Content-Type: application/x-www-" 
000544b2  "form-urlencoded" 
000544c3  "Content-Length: %d" 
000544e0  "GET %s HTTP/1.0" 
000544f1  "Host: %s" 
000544fb  "User-Agent: %s" 
0005450b  "Connection: close" 
00054528  "POST /get/scr.html HTTP/1.0" 
00054545  "Host: %s" 
0005454f  "User-Agent: %s" 
0005455f  "Connection: close" 
00054572  "Content-Length: %d" 
00054586  "Content-Type: multipart/form-dat" 
000545a6  "a; boundary=--------------------" 
000545c6  "-------%d" 
000545d4  "-----------------------------%d" 
000545f8  "%sContent-Disposition: form-data" 
00054618  "; name="id"" 
00054630  "%sContent-Disposition: form-data" 
00054650  "; name="screen"; filename="%d"" 
00054670  "Content-Type: application/octet-" 
00054690  "stream" 
000546a0  "%s(%d) : %s" 
000546ac  "%s failed with error %d: %s" 
000546c8  "%02X" 
000546d8  "BlackwoodPRO" 
000546e8  "FinamDirect" 
000546f4  "GrayBox" 
000546fc  "MbtPRO" 
00054704  "Laser" 
0005470c  "LightSpeed" 
00054718  "LTGroup" 

256    PART 4: Malware Analysis Patterns 
00054720  "Mbt" 
00054724  "ScotTrader" 
00054730  "SaxoTrader" 
00054740  "Program:   %s" 
0005474f  "Username:  %s" 
0005475e  "Password:  %s" 
0005476d  "AccountNO: %s" 
[...] 
 
 

Namespace    257 
Namespace 
As usual a new pattern arises with the need to communicate analysis findings. Most 
often when analyzing malware, we don’t have symbol files (No Component Symbols, 
Volume 1, page 298) for Unknown Module (Volume 1, page 367). By looking at IAT (if 
any present), we can guess the module purpose. Sometimes a module itself is not 
malicious but is used in a larger malicious context such as screen grabbing: 
[...] 
10002000  76376101 gdi32!CreateCompatibleDC 
10002004  763793d6 gdi32!StretchBlt 
10002008  76377461 gdi32!CreateDIBSection 
1000200c  763762a0 gdi32!SelectObject 
10002010  00000000 
10002024  77429ced user32!ReleaseDC 
10002028  77423ba7 user32!NtUserGetWindowDC 
1000202c  77430e21 user32!GetWindowRect 
10002030  00000000 
10002034  744a75e9 GdiPlus!GdiplusStartup 
10002038  744976dd GdiPlus!GdipSaveImageToStream 
1000203c  744cdd38 GdiPlus!GdipGetImageEncodersSize 
10002040  744971cf GdiPlus!GdipDisposeImage 
10002044  744a8591 GdiPlus!GdipCreateBitmapFromHBITMAP 
10002048  744cdbae GdiPlus!GdipGetImageEncoders 
[...] 
There are also cases where these API names are not in IAT but found as String 
Hint (page 254) in raw data such LoadLibrary / GetProcAddress and even a group of 
modules themselves as a collective API: 
[...] 
00058e20  "kernel32.dll" 
00058e3c  "user32.dll" 
00058e54  "ws2_32.dll" 
00058e6c  "ntdll.dll" 
00058e80  "wininet.dll" 
00058e98  "nspr4.dll" 
00058eac  "ssl3.dll" 
[...] 
 
 

258    PART 4: Malware Analysis Patterns 
[This page is intentionally left blank] 
 
 

On Matter    259 
PART 5: A Bit of Science and Philosophy 
On Matter 
If memory is the foundation of everything and first principle (Volume 5, page 222) then 
what we can say about matter? We can view matter as the curvature of memory 
(currently metaphorically) and also as a constraining “filter” device that limits (and 
processes) memories. The latter view of limits is similar to some theories viewing brain 
(body) as a constraining device for mental reality (consciousness)26. 
 
 
                                                                 
26 Irreducible Mind (Kelly & Kelly et al.), pp. 28-29  

260    PART 5: A Bit of Science and Philosophy 
Commodities as Memories 
Whereas Marx considered commodities as having surplus values and Baudrillard27 
considered them as semiotic signs, philosophy of Memoidealism considers them as 
containing memories and linked by memories. People use commodities to evoke 
memories (either personal or collective) and use them for further communication. You 
can find such examples everywhere. The use of memories (including superstructure and 
means of production memories used to store the personal ones) has increased 
dramatically. We call this analysis XRAM to distinguish from original Marx analysis and 
its derivatives and extensions. In the future memories will also have exchange value and 
replace money. 
 
 
                                                                 
27 http://en.wikipedia.org/wiki/Jean_Baudrillard 

Software as Means of Production    261 
Software as Means of Production 
The cover of one Economist issue arrived someday picturing a third industrial revolution 
prompted us to write about Software as means of production that we were thinking for 
some time and even created Software Generalist Party28 that you are welcome to join. 
Software generalists are the future driving force of society change and we started 
working on a treatise comparable to Marx’s Capital called Software, Volume 1 subtitled 
as A Critical Analysis of Industrial Production (ISBN: 978-1908043375). It will also include 
an analysis of the new emerging commodities such as memories (page 260). 
 
 
                                                                 
28 http://www.facebook.com/SoftwareGeneralists 

262    PART 5: A Bit of Science and Philosophy 
Notes on Memoidealism 
We continue our notes from Volume 3 (page 303), Volume 4 (page 246), Volume 5 (page 
217), and Volume 6 (page 177). 
Here we try to map memoidealistic epistemological counterparts (Volume 5, 
page 222) to Locke’s theory of perception29. 
1. Ideas of sensation: 
Sense organs receive memory snapshots from other memories. 
2. Ideas of reflection: 
Memory snapshots from mind reflect snapshots from other 
memories. 
3. Substance: 
Memory is a foundation of Universe. 
4. Primary qualities: 
Qualities associated with Memory as a substance. 
5. Secondary qualities: 
Qualities associated with memories as parts of Memory. 
Next we map objections (and further development) of Berkeley30 to Locke’s 
epistemology outlined above: 
 
 
                                                                 
29 http://en.wikipedia.org/wiki/John_Locke 
30 http://en.wikipedia.org/wiki/George_Berkeley 

Notes on Memoidealism    263 
1. There is no need for the special substance to contain primary qualities. 
Memory is of the same substance as memories. 
2. Ideas exist independently of us in God. 
Ideas not contained in memories of specific individuals can be 
contained either in memories of other individuals or outside memories 
in Memory. 
In the book “Memory, History, Justice in Hegel” Angelica Nuzzo discusses 
absolute memory of Hegel’s Sprit and how it reconciles personal and collective 
memories and manifested in creations of art and other works and representations. In 
Memoidealism Memory can be considered as Sprit itself as in hyper-dialectical triad 
(page 276). Also in Memorianity31 (memory religion) Memory consists of memories 
(Memorianic Prophecy 0m3). The notion of different representations of Memory at 
large was proposed as parameterized science (Volume 3, page 301). 
 
 
 
                                                                 
31 http://www.memoryreligion.com/2013/02/21/all-pages-from-core-testament/ 

264    PART 5: A Bit of Science and Philosophy 
The Confluence of Computers, Philosophy, and Religion 
We extend the old notion of confluence of Theism and Philosophy. The new confluence 
of Religion, Philosophy, and Computers resulted in revealed Memory Religion 
(Memorianity, Volume 5, page 347): 
 
 
 
 

Analytic Memory Dump - A Mathematical Definition    265 
Analytic Memory Dump - A Mathematical Definition 
The previous mathematical definition of a memory dump (Volume 1, page 501) is for 
raw memory dumps. They are not really useful because they require symbol files. Each 
symbol file entry conceptually is a correspondence between a memory address and a 
direct sum or product of letters from some alphabet: 
00000000`76e82c40: kernel32!WaitForMultipleObjectsExImplementation 
So we propose an analytical definition of a memory dump as a direct sum of 
disjoint memory areas Mt taken during some time interval (t0, ..., tn) where we replace stk 
having values from Z2 with Stq having values from Zp and cardinality of Zp depending on a 
platform (32, 64, ...) plus a symbolic description ∏Di for each Stq with cardinality of ”i” 
set sufficient enough to accommodate the largest symbolic name: 
M = ∑Mt where Mt = ∑(Stq+∏Di) 
Or simply: 
M = ∑∑(Stq+∏Di) 
This can be visualized as a linear memory space such as a virtual memory space 
when symbol files are applied to modules one after another. However, all this is not 
necessary because a symbol from a virtual address can also be mapped to a physical 
address if necessary. ∏Di, in fact, refers to any symbolic description. 
 
 
 
 

266    PART 5: A Bit of Science and Philosophy 
Sorting and Early Greek Philosophers 
Who was the first: Anaximander32 or Anaximenes33? Alphabetical sorting34 helps us to 
remember that Anaximenes was after Anaximander. 
 
 
                                                                 
32 http://en.wikipedia.org/wiki/Anaximander 
33 http://en.wikipedia.org/wiki/Anaximenes_of_Miletus 
34 http://en.wikipedia.org/wiki/Alphabetical_order 

General Abnormal Patterns of Structure and Behavior    267 
General Abnormal Patterns of Structure and Behavior 
Memory Analysis Patterns (MAPs) including memory dump, malware, software 
trace (TAPs), and other patterns and pattern catalogs from Software Diagnostics 
Institute 35 form the very rich semantic network. Now it is possible (by using a 
metaphorical bijection, Volume 4, page 241) to create a catalog of General Patterns of 
Abnormal Structure and Behavior including software, hardware, biological behavior 
including animal (ethology) and human behavior, sociological and historical behavior 
including economics, business and finance, ethics and law, and even behavior of 
chemical and physical systems. Such “GAPs of Structure and Behavior” may include wait 
chains, spikes, deadlocks, etc. So we are a few steps closer to realization of our old 
dangerous idea (Volume 3, page 301) of a parameterized science of universal memory 
dumps by the so-called science files or might even a general diagnostics discipline. 
General Abnormal Patterns of Structure and Behavior
Software
Hardware
Ethology
Sociology
History
Economics
Law
Chemistry
Physics
 
 
 
                                                                 
35 http://www.dumpanalysis.org/ 

268    PART 5: A Bit of Science and Philosophy 
On Matter and Substances 
What is a role of perceived memory deficient matter in Memorianity36 where Memory 
consists of memories (Memorianic Prophecy 0m337)? Matter is boundaries of memories 
as illustrated in this schematic diagram: 
 Memory
memory
memory
memory
Matter
 
We can also reverse monistic aspect pluralism (Volume 4, page 237) of 
Memoidealism and consider substances as boundaries of memories too. 
 
 
                                                                 
36 http://www.facebook.com/Memorianity 
37 http://www.memoryreligion.com/ 

M-Memory    269 
M-Memory 
Memorianic prophecy 0m3 says38: “Memory is an infinitude of memories.” In monistic 
aspect plural interpretation of Memoidealism (Volume 4, page 237) memory is also an 
attribute of itself. Memorianity considers all memories of the same substance as eternal 
Memory. All memories are distinct, yet they are one essence. There is only one Memory 
in memories. Each memory is only distinct in relation to other memories. In M-Memory 
M stands for Multiplicity. One analogy here is the concept of Trinity39 with the infinite 
number of hypostases40 instead of just 3. 
 
 
                                                                 
38 http://www.memoryreligion.com/2013/02/21/all-pages-from-core-testament/ 
39 http://en.wikipedia.org/wiki/Trinity 
40 http://en.wikipedia.org/wiki/Hypostasis_(philosophy_and_religion) 

270    PART 5: A Bit of Science and Philosophy 
Ontology of Memoidealism 
We devised ontology of Memoidealism based on mathematics, on category theory41. It 
is a hierarchy of categories which consists of collections of objects and arrows between 
them. We chose category theory instead of set theory for our ontology in order to have 
the concept of Time represented intrinsically by arrows which are a part of any 
category. The first level is a simple MemS category of memuons as memory objects and 
arrows between them: 
 
Metaphorically this can be considered as a single memory state. The next level is 
a MemL category with MemS objects and arrows between them. This is essentially a 
functor, and it can be considered as a single memory line or memory life constructed 
from memory states: 
                                                                 
41 https://en.wikipedia.org/wiki/Category_theory 

Ontology of Memoidealism    271 
 
The next level is a functor category42 MemW with MemL functors and natural 
transformations between them. It can be considered as a single memory world 
constructed from memory lines (or lives): 
 
                                                                 
42 https://en.wikipedia.org/wiki/Functor_category 

272    PART 5: A Bit of Science and Philosophy 
Going higher there is also MemU category of memory worlds and it can be 
considered as a memory universe and even higher categories of memory universes. 
 
 

Philosophies of Persistence    273 
Philosophies of Persistence 
Memoidealism, as a philosophical foundation of Memory Religion, is a philosophy of The 
Persistence because it considers Memory as the primitive, primordial and basic element 
of everything. There are different versions of Memoidealism, for example, one considers 
Memory not only as an attribute (traditional thinking) but also as an attribute of itself. 
Another reductionist version views it as infinite (or an immense) number of memory 
particles, “memuons” which can be put into a “memorized” relation. So all these can be 
separate different philosophies of The Persistence, and any new might come anytime. 
What is the relationship of these new philosophies to the old ones? We consider the 
first philosophies around the 5th century BCE such as Pre-Socratic as philosophies of The 
Beginning and adopt the traditional view of philosophies of the 20th century such as 
Heidegger’s and Rozenzweig’s as philosophies of The End. The 21st century will witness 
the new philosophies of The Persistence mainly due to the proliferation of Software (as 
a model of Memory), and Memoidealism flavors are among them. Here’s a diagram that 
depicts this unfolding in Time: 

274    PART 5: A Bit of Science and Philosophy 
Philosophies of The Beginning
Philosophies of The End
XX
XXI
Philosophies of The Persistence: 
Memoidealism
-V
 
 
 

Information as Arrow    275 
Information as Arrow 
In Memoidealistic ontology (page 270) based on category theory arrows between 
objects (normal category), between categories (functor) and between arrows 
themselves (2-category) can serve the definition of information which is traditionally 
based on set theory. All this can be generalized further to natural transformations, n-
categories and beyond bringing the notion of information even to higher realms. We call 
such information as in-formation to outline it as a process as well. All this new 
interpretation is illustrated in the picture below, and we provide more elaboration later 
on: 
 Category Mem*
In-formation
 Category Mem*
In-formation
In-formation
In-formation
In-formation (2-category)
Functor
 
 
 
 

276    PART 5: A Bit of Science and Philosophy 
Dialectical Triad in Memoidealism 
-> Dream -> Reality -> Memory -> (as past, present, and future in Hegelian 43 
philosophies of Cieszkowski44 and Feuerbach45). Memory as synthesis of dreams and 
reality together with two other triads (Memory -> Dream -> Reality and Reality -> 
Memory -> Dream) constitutes a hyper or super dialectical triad for shifting memories 
that represents Memory as a foundation or “Sprit”: 
                                                                 
43 http://en.wikipedia.org/wiki/Georg_Wilhelm_Friedrich_Hegel 
44 http://en.wikipedia.org/wiki/August_Cieszkowski 
45 http://en.wikipedia.org/wiki/Ludwig_Feuerbach 

Dialectical Triad in Memoidealism    277 
 
Reality
Dream
Memory
Memory
...
Dream
...
 

278    PART 5: A Bit of Science and Philosophy 
[This page is intentionally left blank] 
 
 

Software Trace Diagrams (STDiagrams)    279 
PART 6: Software Trace Analysis Patterns 
Software Trace Diagrams (STDiagrams) 
When depicting trace analysis patterns we used two-dimensional diagrams based on 
CDF (ETW) traces such as this one for Bifurcation Point (Volume 4, page 343): 
Time
#   PID TID Time                  Message
 
While working on a new pattern we needed a new expressive way to graphically 
illustrate the same idea of trace bifurcation points but without too much drawing. 

280    PART 6: Software Trace Analysis Patterns 
Traces from particle chambers and scattering diagrams came to my imagination after 
draw the first few diagrams illustrating bifurcation points: 
 
Time directional arrow end can be omitted: 
 
 
 

Software Trace Diagrams (STDiagrams)    281 
Trace variation after a bifurcation point can be indicated by angle partition: 
 
The case when a variation also happens before is illustrated in this diagram: 
 
 
 

282    PART 6: Software Trace Analysis Patterns 
And the case with several bifurcations: 
 
Are N-bifurcations like on the diagram below possible? 
 
Yes, they are, if the course of execution depends on some non-binary trace 
message parameter such as a loaded module that implements a required interface 
differently. 

Macrofunction    283 
Macrofunction 
This is a single semantic unit of several trace messages where individual messages serve 
the role of microfunctions. We borrowed this idea and distinction from functionalist 
linguistics. An example would be a software trace fragment where messages log an 
attempt to update a database: 
#     Module   PID  TID   Time         Message 
[...] 
42582 DBClient 5492 9476  11:04:33.398 Opening connection 
[...] 
42585 DBClient 5492 9476  11:04:33.398 Sending SQL command 
[...] 
42589 DBServer 6480 10288 11:04:33.399 Executing SQL command 
[...] 
42592 DBClient 5492 9476  11:04:33.400 Closing connection 
[...] 
These macrofunctions need not be from the same ATID (Glued Activity,      
Volume 6, page 250) in the traditional sense as in the example above unless we form 
adjoint threads from certain fragments like “DB”. 
 
 

284    PART 6: Software Trace Analysis Patterns 
Linked Messages 
Sometimes we have Linked Messages through some common parameter or attribute. 
One such example can be found in ETW traces related to kernel process creation 
notifications. Here we got Adjoint Thread (Volume 5, page 283) for module PIDNotify: 
#      Module    PID  TID  Time         Message 
[...] 
128762 PIDNotify 1260 6208 15:53:15.691 Create: ParentID 0x000004EC PID 0×000018D4 
[...] 
128785 PIDNotify 6356 6388 15:53:15.693 Load: ImageName 
\Device\HarddiskVolume1\Windows\System32\abscript.exe PID 0×000018D4 
[...] 
131137 PIDNotify 6356 4568 15:53:15.936 Create: ParentID 0×000018D4 PID 0×00001888 
[...] 
131239 PIDNotify 6280 6376 15:53:15.958 Load: ImageName 
\Device\HarddiskVolume1\Windows\System32\wscript.exe PID 0×00001888 
[...] 
132899 PIDNotify 6356 5704 15:53:16.462 Create: ParentID 0×000018D4 PID 0×00001FD0 
[...] 
132906 PIDNotify 8144 7900 15:53:16.464 Load: ImageName 
\Device\HarddiskVolume1\Windows\System32\cmd.exe PID 0×00001FD0 
[...] 
We see that messages 128762 and 128785 are linked through PID parameter and 
linked to messages 131137 and 132899 through PID - ParentID parameter relationship. 
Similar linkages exist for messages 131137 / 131239 and 132899 / 132906. 
 
 

Marked Message    285 
Marked Message 
Based on ideas of Roman Jakobson46 about “marked” and “unmarked” categories we 
propose this pattern that groups trace messages based on having some feature or 
property. For example, marked messages may point to some domain of software activity 
such related to functional requirements and, therefore, may help in troubleshooting and 
debugging. Unmarked messages include all other messages that don’t say anything 
about such activities (although may include messages pointing to such activities 
indirectly we unaware of) or messages that say explicitly that no such activity has 
occurred. We can even borrow a notation of distinctive features47 from phonology48 and 
annotate any trace or log after analysis to compare it with Master Trace (Volume 6, 
page 247), for example, compose the following list of software trace distinctive features: 
session database queries  
[+] 
session initialization  
[-] 
socket activity  
 
[+] 
process A launched  
 
[+] 
process B launched  
 
[-] 
process A exited  
 
[-] 
[...] 
Here [+] means the activity is present in the trace, and [-] means the activity is 
either undetected or definitely not present. Sometimes a non-present activity can be a 
marked activity corresponding to all inclusive unmarked present activity (see, for 
example, No Activity pattern, Volume 5, page 297). 
 
 
                                                                 
46 http://en.wikipedia.org/wiki/Roman_Jakobson 
47 http://en.wikipedia.org/wiki/Distinctive_features 
48 http://en.wikipedia.org/wiki/Phonology 

286    PART 6: Software Trace Analysis Patterns 
Trace Frames 
Narrative theory distinguishes between frame types such as (Fludernik, McHale, Nelles, 
Wolf): 
 
Introductory framing (missing end frame) [—————————- 
 
Terminal framing (missing opening frame) —————————-] 
 
[—————————-] 
 
Interpolated framing [—-[ ]—-[ ]——–] 
At the level of the software trace or Adjoint Thread (Volume 5, page 283) as a 
whole the first three types correspond to various types of the pattern Trace Partition 
(Volume 5, page 299) where certain parts are missing such as Head, Prologue, Core, 
Epilogue, or Tail. The first two types can also be instances of Truncated Trace pattern 
(Volume 5, page 301). Interpolated framing can be an instance of multiple 
Discontinuities (Volume 4, page 341). All 4 types also correspond to Foreground 
Component messages (Volume 5, page 287) and in general we have multiple Trace 
Frames as depicted: 

Trace Frames    287 
Time
#   Src Dst Time                  Message
 
 
 
 

288    PART 6: Software Trace Analysis Patterns 
Counter Value 
This pattern covers performance monitoring and its logs. A counter value is some 
variable in memory, for example, Module Variable (page 98), that is updated 
periodically to reflect some aspect of state or it can be calculated from different 
variables and presented in trace messages. Such messages can also be organized in a 
similar format as ETW based traces we usually consider as examples for our trace 
patterns: 
Source  PID TID   Function         Value 
================================================= 
[...] 
System    0   0   Committed Memory 12,002,234,654 
Process 844   0   Private Bytes    345,206,456 
System    0   0   Committed Memory 12,002,236,654 
Process 844   0   Working Set      122,160,068 
[...] 
Therefore, all other trace patterns such as Adjoint Thread (Volume 5, page 283, 
can be visualized via different colors on a graph), Focus of Tracing (Volume 6, page 243), 
Characteristic Message Block (Volume 4, page 345, for graphs), Activity Region (Volume 
4, page 348), Significant Event (Volume 5, page 281), and others can be applicable here. 
There are also some specific patterns such as Global Monotonicity and Constant Value 
that we discuss with examples later. 
 
 

Message Context    289 
Message Context 
In some cases, it is useful to consider Message Context: a set of surrounding messages 
having some relation to the chosen message: 
Time
#   PID TID Time                  Message
Message
Context
 
 
 

290    PART 6: Software Trace Analysis Patterns 
Error Distribution 
Sometimes we need to pay attention to Error Distribution, for example, the distribution 
of the same error across a software log space or different error messages in different 
parts of the same software log or trace (providing effective partition): 
Time
#   PID TID Time                  Message
 
 
 

Break-in Activity    291 
Break-in Activity 
This is a message or a set of messages that surface just before the end of Discontinuity 
(Volume 4, page 341) of Adjoint Thread (Volume 5, page 283) and possibly triggered it: 
Time
#   PID TID Time                  Message
                  Discontinuity
 
 
 

292    PART 6: Software Trace Analysis Patterns 
Resume Activity 
If Break-in Activity (page 291) is usually unrelated to Thread of Activity (Volume 4, page 
339) or Adjoint Thread of Activity (Volume 5, page 283) which has a discontinuity then 
Resume Activity pattern highlights messages from that thread: 
Time
#   PID TID Time                  Message
                  Discontinuity
 
The difference can be seen in the following graphical representation of the two 
traces where in a working trace a break-in preceded resume activity whereas in a non-
working trace both patterns were absent: 

Resume Activity    293 
Time
#   PID TID Time                  Message
               Discontinuity
Time
#   PID TID Time                  Message
                  Discontinuity
 
 
 
 

294    PART 6: Software Trace Analysis Patterns 
Fiber Bundle 
The modern software trace recording, visualization and analysis tools such as Process 
Monitor, Xperf, WPR, and WPA provide stack traces associated with trace messages. 
Consider stack traces as software traces we have, in a more general case, traces (fibers) 
bundled together on (attached to) a base software trace. For example, a trace message, 
that mentions an IRP can have its I/O stack attached together with the thread stack 
trace with function calls leading to a function that emitted the trace message. Another 
example is an association of different types of traces with trace messages such as 
managed and unmanaged ones. This general trace analysis pattern needed a name, so 
we opted for Fiber Bundle as an analogy with a fiber bundle49 from mathematics. Here’s 
a graphical representation of stack traces recorded for each trace message where one 
message has also an associated I/O stack trace: 
                                                                 
49 http://en.wikipedia.org/wiki/Fiber_bundle 

Fiber Bundle    295 
I/O stack
Thread stack trace
Trace 
messages
 

296    PART 6: Software Trace Analysis Patterns 
Data Flow 
If trace messages contain some character or formatted data that is passed from module 
to module or between threads and processes it is possible to trace that data and form a 
Data Flow thread similar to Adjoint Thread (Volume 5, page 283) we have when we 
filter by a specific message. However, in the former case we have different message 
types. 
#   PID TID Time                  Message
Time
 

Data Flow    297 
[This page is intentionally left blank] 
 
 
 

298    PART 6: Software Trace Analysis Patterns 
Empty Trace 
This is another trivial missing pattern that we need to add to make software log analysis 
pattern system complete. It ranges from a totally empty trace message list where only a 
meta-trace header (if any) describing overall trace structure is present to a few 
messages where we expect thousands. This is also an extreme case of Truncated Trace 
(Volume 5, page 301), No Activity (Volume 5, page 297) and Missing Component 
(Volume 4, page 342) patterns for a trace taken as a whole. Note that an empty trace 
file doesn’t necessarily have a zero file size because a tracing architecture may 
preallocate some file space for block data writing. 
 
 

Error Message    299 
Error Message 
While working on Accelerated Windows Software Trace Analysis training 50  we 
discovered some missing patterns needed for completeness despite their triviality. One 
of them is called Error Message. Here an error is reported either explicitly (”operation 
failed”) or implicitly as an operation status result such as 0xC00000XX. Sometimes, a 
trace message designer specifies that the number value is supplied for information only 
and should be ignored. Some error messages may contain information that is not 
relevant to the current software incident, the so-called False Positive Errors (Volume 5, 
page 303). Some tracing architectures and tools include a message information category 
for errors, such as Citrix CDF (ETW-based), where we can filter by error category51 to get 
Adjoint Thread (Volume 5, page 283). Please note that the association of a trace 
statement with an error category is left at the discretion of an engineer writing code and 
information category messages may contain implicit errors such as last error and return 
status reports. 
 
 
                                                                 
50 http://www.patterndiagnostics.com/accelerated-software-trace-analysis 
51 http://support.citrix.com/article/CTX122741 

300    PART 6: Software Trace Analysis Patterns 
Periodic Message Block 
This pattern is similar to Periodic Error (Volume 3, page 344) but not limited to errors or 
failure reports. One such example we recently encountered is when some adjoint 
activity (such as messages from specific PID, Volume 5, page 283) stops appearing after 
the middle of the trace, and after that, there are repeated blocks of similar messages 
(Message Invariant, Volume 6, page 251) from different PIDs with their threads 
checking some condition (waiting for an event and reporting timeouts): 
Time
#   PID TID Time                  Message
 
 
 

Visibility Limit    301 
Visibility Limit 
Often it is not possible to trace from the very beginning of software execution. 
Obviously, internal application tracing cannot trace anything before that application 
start and its early initialization. The same is for system-wide tracing which cannot trace 
before the tracing subsystem or service starts. Therefore, each log has its visibility limit 
in addition to possible truncation (Truncated Trace, Volume 5, page 301) or Missing 
Components (Volume 4, page 342): 
Time
#   PID TID Time                  Message
r
 
One of the solutions would be to use different tracing tools and Inter-Correlation 
(Volume 4, page 350) to glue activities, for example, Process Monitor and CDFControl. 
 
 

302    PART 6: Software Trace Analysis Patterns 
Relative Density 
This pattern describes anomalies in semantically related pairs of trace messages, for 
example, “data arrival” and “data display”. Their Statement Densities (Volume 4, page 
335) can be put in a ratio (also called specific gravity52) and compared between working 
and non-working scenarios. Because the total numbers of trace messages cancel each 
other, we have just the mutual ratio of two message types. In our hypothetical “data” 
example, the increased ratio of “data arrival” to “data display” messages accounts for 
reported visual data loss and sluggish GUI. 
#   PID TID Time                  Message
Time
#   PID TID Time                  Message
Time
1 / 1
3 / 1
 
                                                                 
52 http://en.wikipedia.org/wiki/Relative_density 

Sparse Trace    303 
Sparse Trace 
Sometimes we don’t see anything in the trace or see very little because particular 
source code fragment was not covered by trace statements (see also PLOTs, Volume 5, 
page 272): 
Time
#   PID TID Time                  Message
Missing
L 
 
This pattern Sparse Trace is different from Missing Component (Volume 4, page 
342) pattern where some modules are not included for tracing explicitly although 
there is tracing code there or Visibility Limit (page 301) pattern where tracing is 
intrinsically impossible. Often technical support and escalation engineers request to add 
more trace statements and software engineers extend tracing coverage iteratively as 
needed. 

304    PART 6: Software Trace Analysis Patterns 
Opposition Messages 
This pattern name is borrowed from binary opposition 53 originated in Saussure’s 
structuralism54). It covers the following pairs of messages usually found in software 
traces and logs such as: 
 
open / close 
 
create / destroy 
 
allocate / free (deallocate) 
 
call / return 
 
enter / exit (leave) 
 
load / unload 
 
save / load 
 
lock / unlock 
 
map / unmap 
The absence of an opposite may point to some problems such as synchronization 
and leaks or Incomplete History (Volume 5, page 286, for example, wait chains). There 
can always be a possibility that a second term is missing due to Sparse Trace (page 303) 
but this is a poor implementation choice that leads to confusion during troubleshooting 
and debugging. 
 
 
                                                                 
53 http://en.wikipedia.org/wiki/Binary_opposition 
54 http://en.wikipedia.org/wiki/Ferdinand_de_Saussure 

Split Trace    305 
Split Trace 
Some tracing tools such as Citrix CDFControl55 have the option to split software traces 
and logs into several files during long recording. Although this should be done 
judiciously it is really necessary sometimes. What to do if we get several trace files 
and we want to use some other analysis tool such as Citrix CDFAnalyzer56? If we 
know that the problem happened just before the tracing was stopped we can look at 
the last few such files from the file sequence (although we recommend Circular Trace 
here, Volume 3, page 346). Otherwise, we can convert them into CVS files and import 
into Excel, which also supports adjoint threading57. 
 
 
                                                                 
55 http://support.citrix.com/article/CTX111961 
56 http://support.citrix.com/article/CTX122741 
57 http://www.debugging.tv/Frames/0x14/DebuggingTV_Frame_0x14.pdf 

306    PART 6: Software Trace Analysis Patterns 
Message Interleave 
We factored out Anchor Messages (Volume 5, page 293) example of message interleave 
into this pattern. It covers superposition of different anchor messages, for example, 
process launch and exit, or DLL load and unload: 
Time
# PID TID Time                  Message
 
 
 

Sheaf of Activities    307 
Sheaf of Activities 
Inter-Correlation (Volume 4, page 350) analysis between a normal and a problem 
logs to find Bifurcation Point (Volume 4, page 343, and a possible root cause) becomes 
a difficult task when both traces come from different environments with widely differing 
Background Components (Volume 5, page 287). Here a new analysis pattern with a 
name borrowed from sheaves58 from mathematics can help. Basically, this pattern is 
also a tool for tracking properties of trace message subsets. First we find out important 
message types around some Activity Region (Volume 4, page 348) where we hope to 
find a difference between two traces: 
                                                                 
58 http://en.wikipedia.org/wiki/Sheaf_(mathematics) 

308    PART 6: Software Trace Analysis Patterns 
Time
#   PID TID Time   Operation    Details
CreateFileMapping
LoadImage
QueryBasicInformationFile
 
Then we create several Adjoint Threads (Volume 5, page 283) from different 
message types, for example, based on operation type or function name: 

Sheaf of Activities    309 
Time
#   PID TID Time   Operation    Details
Time
#   PID TID Time   Operation    Details
Time
#   PID TID Time   Operation    Details
 
Then we analyze subtraces separately to find out a bifurcation point in each of 
them and then use this knowledge to find out differences between the original full 
traces. 
 
 
 

310    PART 6: Software Trace Analysis Patterns 
Indexical Trace 
This pattern describes Inter-Correlation (Volume 4, page 350) pattern variant when we 
have a trace that has messages of interest pointing to specific activity regions in another 
trace. The latter trace can be very huge, from another computer and split into many 
parts (Split Trace, page 305). This pattern is very helpful when the problem needs to be 
diagnosed in the large split trace, but we don’t know when it happened. Then an index 
trace that may have recorded software execution account (for example, in the case of a 
broker-like architecture) can point to the right trace fragment from the split trace. 
 
 
 

Abnormal Value    311 
Abnormal Value 
While preparing a presentation on malware narratives59, we found that one essential 
pattern was missing from the current log analysis pattern catalog. Most of the time we 
see some abnormal or unexpected value in a software trace or log such as a network 
address outside the expected range, and this triggers further investigation. The message 
structure may be the same having the same Message Invariant (Volume 6, page 251) 
but the variable part may contain such values as depicted graphically: 
                                                                 
59 http://www.patterndiagnostics.com/malware-narratives-materials 

312    PART 6: Software Trace Analysis Patterns 
Time
#   PID TID Time                  Message
 
Please note that we also have Significant Event (Volume 5, page 281) pattern 
that is more general and also covers messages without variable part or just suspicious 
log entries. 
 
 

Dominant Event Sequence    313 
Dominant Event Sequence 
Sometimes we have insufficiently detailed problem description and/or there are several 
similar parallel user activities going on simultaneously, for example, several sessions are 
launched in a terminal services environment. In such cases when tracing is done for the 
duration of a specific user activity, this pattern may help. Here we select the most 
inclusive sequence of events or event sequence based on some Basic Facts (Volume 3, 
page 345). For example, if a session ID was missing in the problem description we can 
choose the longest and fullest process launch sequence (Volume 2, page 387) and 
assume that its session id was the one missing: 
Time
#   PID TID Time                  Message
Start
Start
End
Start
End
 
 
 

314    PART 6: Software Trace Analysis Patterns 
Pivot Message 
Suppose we form Adjoint Thread (Volume 5, page 283) based on some message or 
operation type or some other attribute: 
Time
Time
#   PID TID Time    Func                  Message
 
 
 

Pivot Message    315 
But we do not know where to start to look backward for any anomalies relevant 
to our problem: 
Time
#   PID TID Time    Func                     Message
 
 
 

316    PART 6: Software Trace Analysis Patterns 
We go back to our full trace and find a problem message: 
Time
#   PID TID Time    Func                  Message
 
 
 

Pivot Message    317 
Although it is not in our adjoint thread we formed previously it is still considered 
as Pivot Message helping us to go backward there: 
Time
#   PID TID Time    Func                     Message
 
 
 

318    PART 6: Software Trace Analysis Patterns 
Traces of Individuality 
If Implementation Discourse (Volume 6, page 245) focuses on objective technology 
specific discourse, then this pattern focuses on subjective elements in a software log 
and its messages. Here we mean some specific naming or tracing conventions either 
from an individual engineer habit or from some corporate coding standard. As an 
example of it consider a trace message from a catch statement: 
"Surprise, surprise, should have never been caught" 
 
 

Indirect Facts    319 
Indirect Facts 
Sometimes in the case of missing Basic Facts (Volume 3, page 345) we can discern 
indirect facts from the message text and even from other patterns. For example, in one 
incident we were interested in all messages from the certain process name but its PID 
was missing from the problem description. Fortunately, we were able to get its PID from 
one of the individual messages from completely different source: 
Time
#   PID TID Time    Func                     Message
                                 App.exe  PID 234 
    234
    234
    234
 
 
 

320    PART 6: Software Trace Analysis Patterns 
Hidden Error 
Sometimes we look at a trace or log and instead of Error Messages (page 299) we only 
see their “signs” such as a DLL load event for error or fault reporting module or a 
module that is related to symbol files such diasymreader.dll. This pattern is called by 
analogy to Hidden Exception (Volume 1, page 271) in memory dump analysis pattern 
catalog although sometimes we can see such modules in memory dump Module 
Collection (page 162). For example, the presence of diasymreader module may 
signify an unreported .NET exception and suggest a dump collection strategy. 
Time
#   PID TID Time    Func                     Message
Load: faultreport.dll
   
                 Load: diasymreader.dll
 

Hidden Error    321 
[This page is intentionally left blank] 
 
 
 

322    PART 6: Software Trace Analysis Patterns 
Last Activity 
Sometimes we need to analyze the last activity before Significant Event (Volume 5, page 
281) or Discontinuity (Volume 4, page 341). By this pattern, we mean a loose semantic 
collection of messages before process exit, for example. This might give some clues to 
further troubleshooting. In one incident, a process was suddenly exiting. Its own 
detailed trace didn’t have any messages explaining that probably due to insufficient 
tracing coverage (Sparse Trace, page 303). Fortunately, a different external trace (from 
Process Monitor) was collected (Inter-Correlation, Volume 4, page 350) and it had LDAP 
network communication messages just before thread and process exit events. 
#   PID TID Time                  Message
                  Discontinuity
 

Last Activity    323 
[This page is intentionally left blank] 
 
 
 

324    PART 6: Software Trace Analysis Patterns 
State and Event 
For the event- or message-driven architectures it is important to differentiate between 
event and state messages (including state transition). For example, a system may be 
doing some work while being in some particular state with a lot of tracing and respond 
to various external events with each of them having a corresponding trace message. 
Upon such an event, the system transitions to some other state with its own set of 
possible trace messages. We call such a pattern State and Event. Typical example here is 
a windowing terminal services system and WM_ENDSESSION event illustrated in the 
following abstract trace diagram with a corresponding state transition diagram below it: 
Time
#   PID TID Time    Func                     Message
                                 WM_ENDSESSION 
 

State and Event    325 
State A
q  
State B
q  
WM_ENDSESSION
 
 
 

326    PART 6: Software Trace Analysis Patterns 
Dialogue 
This is an important pattern, especially in network trace analysis. It usually involves a 
message source, a different message target (although both can be the same) and some 
alternation between them as shown on this abstract trace diagram: 
Time
#   Src Dst Time                  Message
 
Message and source are not only IP addresses or port numbers. They can be 
window handles, for example. Sometimes, the roles of source and target play different 
Process ID and Thread ID combinations (Client ID, CID). In such cases some parts of a 
message text may signify reply and response as shown graphically: 

Dialogue    327 
Time
#   PID TID Time                  Message
 
The similar illustration can be done for multi-computer trace, for example, when 
several traces from different servers are combined into one, where a combination of CID 
and a computer ID (Co) or just CO can play the roles of source and target. 

328    PART 6: Software Trace Analysis Patterns 
Time
#   CID Co  Time                  Message
 
Note that on all illustrations above the 3rd request doesn’t have a reply message: 
a possible Incomplete History (Volume 5, page 286) pattern. 
 
 

Motif    329 
Motif 
Often, when we look at software trace fragments, we recognize certain motifs such as 
client-server interaction, publisher-subscriber notifications, database queries, plugin 
sequence initialization, etc. The idea of this pattern name comes from motives60 in 
mathematics. It is different from Master Trace (Volume 6, page 247) which corresponds 
to a normal use-case or working software scenario and may actually contain several 
Motifs as it usually happens in complex software environments. On the other side of the 
spectrum, there are software narremes (basic narrative units, page 386) and 
Macrofunctions (single semantic units, page 283). Motifs help to further bridge the 
great divide between software construction and software diagnostics with software 
narremes corresponding to implementation patterns, macrofunctions to design 
patterns, and motifs to architectural patterns although an overlap between these 
categories is possible. 
 
 
                                                                 
60 http://en.wikipedia.org/wiki/Motive_(algebraic_geometry) 

330    PART 6: Software Trace Analysis Patterns 
Exception Stack Trace (Java) 
While working on Mobile Software Diagnostics webinar61 and exploring the richness of 
Android platform and similarity of its LogCat traces (Eclipse representation) to Minimal 
Trace Graphs (please see a corresponding slide in trace analysis pattern reference62) we 
recognized the time had come to provide a Java implementation of general software 
narratological pattern-oriented trace analysis approach and see what memory analysis 
patterns can be applied there. Here by implementation we mean concrete platform 
examples. For example, in the past we did similar implementations of memory analysis 
patterns (originally developed for unmanaged and native Windows code) for .NET 
(WinDbg) and Mac OS X (GDB and now for LLDB63). The first trace analysis pattern we 
cover here is very obvious and simple and called Exception Stack Trace (Volume 4, page 
337). In the original pattern example a stack trace was inside a single trace message but 
can also be split such as each frame has its own message (date and time columns were 
removed for clarity): 
E/AndroidRuntime(31416): java.lang.NullPointerException 
E/AndroidRuntime(31416):  at android.view.MotionEvent.writeToParcel(MotionEvent.java:1596) 
E/AndroidRuntime(31416):  at 
com.example.nullpointer.FullscreenActivity$1.onTouch(FullscreenActivity.java:139) 
E/AndroidRuntime(31416):  at android.view.View.dispatchTouchEvent(View.java:3881) 
E/AndroidRuntime(31416):  at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:869) 
E/AndroidRuntime(31416):  at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:869) 
E/AndroidRuntime(31416):  at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:869) 
E/AndroidRuntime(31416):  at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:869) 
E/AndroidRuntime(31416):  at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:869) 
E/AndroidRuntime(31416):  at 
com.android.internal.policy.impl.PhoneWindow$DecorView.superDispatchTouchEvent(PhoneWindow.java:175
0) 
E/AndroidRuntime(31416):  at 
com.android.internal.policy.impl.PhoneWindow.superDispatchTouchEvent(PhoneWindow.java:1135) 
E/AndroidRuntime(31416):  at android.app.Activity.dispatchTouchEvent(Activity.java:2096) 
E/AndroidRuntime(31416):  at 
com.android.internal.policy.impl.PhoneWindow$DecorView.dispatchTouchEvent(PhoneWindow.java:1734) 
E/AndroidRuntime(31416):  at android.view.ViewRoot.deliverPointerEvent(ViewRoot.java:2216) 
E/AndroidRuntime(31416):  at android.view.ViewRoot.handleMessage(ViewRoot.java:1887) 
E/AndroidRuntime(31416):  at android.os.Handler.dispatchMessage(Handler.java:99) 
E/AndroidRuntime(31416):  at android.os.Looper.loop(Looper.java:130) 
E/AndroidRuntime(31416):  at android.app.ActivityThread.main(ActivityThread.java:3687) 
E/AndroidRuntime(31416):  at java.lang.reflect.Method.invokeNative(Native Method) 
E/AndroidRuntime(31416):  at java.lang.reflect.Method.invoke(Method.java:507) 
E/AndroidRuntime(31416):  at 
com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:867) 
E/AndroidRuntime(31416):  at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:625) 
E/AndroidRuntime(31416):  at dalvik.system.NativeStart.main(Native Method) 
                                                                 
61 http://www.patterndiagnostics.com/mobile-software-diagnostics-materials 
62 http://www.dumpanalysis.com/Training/Accelerated-Windows-Software-Trace-Analysis-Public.pdf 
63 http://www.patterndiagnostics.com/accelerated-macosx-core-dump-analysis-book 

Exception Stack Trace (Java)    331 
Since many memory analysis patterns are based on stack traces here we 
also have similarity with the following patterns as Managed Code Exception (Volume 1, 
page 331) and Managed Stack Trace (Volume 6, page 115). We hope that in the 
subsequent pattern implementation examples we show more complex patterns of 
abnormal software behavior and may also discover any missing ones. 
 
 

332    PART 6: Software Trace Analysis Patterns 
Correlated Discontinuity 
When analyzing Inter-Correlation (Volume 4, page 350) or Intra-Correlation (Volume 3. 
page 347) and finding Discontinuities (Volume 4, page 341) in one part or in a different 
trace (for example, in client-server environments) it is useful to see if there are 
corresponding correlated discontinuities in another part of the same trace (for example, 
in a different Thread of Activity, Volume 4, page 339) or in a different trace. Such 
pattern may point to the underlying communication problem and may suggest gathering 
a different trace (for example, a network trace) for further analysis. 
Time
#   PID TID Time                  Message
Time
#   PID TID Time                  Message
 
 
 

Piecewise Activity    333 
Piecewise Activity 
Activity Regions (Volume 4, page 348) or blocks of messages having the same TID or PID 
usually follow each other in a typical complex software trace. Such following can be 
completely random and independent, or it may be linear based on IPC or some inter-
thread communication mechanism. For example, after filtering out Background 
Components (Volume 5, page 287) we may find that an RPC client call setup is followed 
by messages from an RPC server: 
                RPC call exit
 
 
PID 0x102
Time
              PID 0x102
               RPC call enter
              PID 0x204
#   PID TID Time                  Message
 
Using coordinate approach with message number and PID axes we can reformat 
this minimal trace diagram: 

334    PART 6: Software Trace Analysis Patterns 
#
PID
 
The name for this pattern was borrowed from the concept of a piecewise linear 
function 64 in mathematics (and piecewise continuity). In some problem software 
behavior scenarios where we encountered such analysis pattern, it was complemented 
by Discontinuity (Volume 4, page 341) pattern. For example, an RPC call may be 
blocked, and we don’t see client messages after that break until the end of the trace. In 
such cases, we always recommend forcing a complete memory dump to check for Wait 
Chain memory analysis patterns (Volume 3, page 387). 
 
 
                                                                 
64 http://en.wikipedia.org/wiki/Piecewise_linear_function 

Density Distribution    335 
Density Distribution 
Sometimes we find a grouping of some messages in one trace and then we are 
interested in the same groupings either in the same trace (Intra-Correlation, Volume 3, 
page 347) or in another trace (Inter-Correlation, Volume 4, page 350). We may consider 
such grouping as having some local density compared to global Message Density 
(Volume 4, page 335) pattern. Then we might be interested in that selected message 
grouping density distribution as illustrated on this minimal trace graph: 
Time
#   PID TID Time                  Message
 
  

336    PART 6: Software Trace Analysis Patterns 
Factor Group 
The next trace and log analysis pattern name is borrowed from factor groups in 
mathematics (or quotient groups65). Here a group is, of course, not a mathematical 
group66 but just a group (or set) of log messages or trace statements. However, every 
trace message has variable and invariant parts (Message Invariant, Volume 6, page 
251). Variable parts usually contain some values, addresses or status bits. They can even 
be string values. Such values form a set too and can be partitioned into disjoint (non-
overlapping) subsets. For example, a window foreground status can be either true or 
false. And we can group messages into disjoint factor groups each one having either 
only true or only false foreground status. The following trace graph illustrates a 
WindowHistory6467 log where it was reported that one window was periodically losing 
and gaining focus: 
                                                                 
65 http://en.wikipedia.org/wiki/Quotient_group 
66 http://en.wikipedia.org/wiki/Group_(mathematics) 
67 http://support.citrix.com/article/CTX109235 

Factor Group    337 
|M/     |
|M/     |
= 1
 
We found messages related to the reported process window title. By using 
Density Distribution (page 335) pattern, another such group of messages was found for 
another process window. Then a factor group was formed with two subgroups and their 
Relative Density (page 302) was compared. For correlated alternating values, it was 
expected to be 1. This was a very simple case, of course, which was analyzed just by 
looking at a textual log but in more complex cases computer assistance is required. A 

338    PART 6: Software Trace Analysis Patterns 
member of a factor group can also be generalized as a message subset 
with messages having variable part values from some domain subset or even calculated 
from it (some sort of a predicate): Mi = { m | P(m) }, where the original group of 
messages is a disjoint union of such message subsets: M = U Mi. 
 
 
 

Silent Messages    339 
Silent Messages 
We mostly analyze real messages in software traces and logs. In such message streams 
we may see easily detectable Discontinuity (Volume 4, page 341) patterns. However, in 
some cases it is beneficial to analyze the absence of messages. The message stream is 
not uniform; there may be different Statement Currents (Volume 4, page 335). If time 
resolution is 1 ms, for example, then we may have current N msg/ms or in the case of 
lesser current, such as, 0.5 msg/ms we have the so-called Silent Messages (----): 
[...] 
11 ms: message 
12 ms: ---- 
13 ms: message 
14 ms: ---- 
15 ms: message 
16 ms: message 
17 ms: ---- 
18 ms: ---- 
19 ms: message 
[...] 
So, by a silent message we understand the possible message that would occupy 
the minimal time resolution gap. If we look at the following illustration, we would see 
that the whole pattern analysis apparatus can be applied to the analysis of the 
distribution of silent messages. 

340    PART 6: Software Trace Analysis Patterns 
Time
 
This pattern is different from Discontinuity pattern because the latter is about 
large unexpected silences and is different from Sparse Trace (page 303) which is about 
missing trace statements from source code. 
 
 

Shared Point    341 
Shared Point 
Sometimes we know from Basic Facts (Volume 3, page 345) some data or activity we 
seek to identify in different traces collected together to perform Inter-Correlational 
analysis (Volume 4, page 350). It can be a shared file name, a named synchronization 
object, a locked file with sharing violations, a common virtual address in kernel space, or 
just some activity notification. This pattern is called by analogy with intersecting curves 
in some abstract space. 
Time
Time
 

342    PART 6: Software Trace Analysis Patterns 
It is similar to Linked Messages (page 284) pattern but is more high level and not 
confined to a common parameter (can be an action description). 
 
 

Meta Trace    343 
Meta Trace 
So far we have been discussing trace analysis patterns related to the execution of a 
particular software version. However, software code changes and also its tracing and 
logging output: from large-scale changes where components are replaced to small scale 
code refactoring affecting message structure and format. On a software narratological 
level, this corresponds to a narrative about a software trace or log, its evolution. Such an 
analysis pattern is different from Master Trace (Volume 6, page 247) pattern where the 
latter is similar to what Metanarrative68 is usually meant in narratology: a master or 
grand idea: an expected trace if all functional requirements were correctly identified 
and implemented during software construction and non-functional ones are met during 
software execution. 
Time
Time
Time
 
                                                                 
68 http://en.wikipedia.org/wiki/Metanarrative 

344    PART 6: Software Trace Analysis Patterns 
Data Association 
Sometimes we are interested in changes in particular {property, value} pairs or in tuples 
{x1, x2, x3, ...) in general where xi can be a number or a substring. This is more general 
pattern than Message Change (Volume 5, page 305) because such tuples can be from 
different sources and belong to different messages: 
#   PID TID Time                  Message
Time
 
This pattern is also different from Data Flow (page 296) where a value stays 
constant across different sources and messages. It is also different from Gossip (Volume 

Data Association    345 
6, page 248) pattern which involves more semantic changes. Metaphorically we can 
think of this pattern as a partial derivative69. 
 
 
                                                                 
69 http://en.wikipedia.org/wiki/Partial_derivative 

346    PART 6: Software Trace Analysis Patterns 
State Dump 
Introduced in Debugging TV70 Frames episode 0×32 about Android / Java debugging this 
pattern solves the problem of program state analysis when memory dump generation is 
not available or doesn’t help or complicated as in the case of interpreted code. Basically, 
a developer identifies a set of state variables and periodically prints their values to the 
output logging stream. Such output may also include but not limited to Counter Values 
(page 288). 
Time
 
                                                                 
70 http://www.debugging.tv/ 

Message Cover    347 
Message Cover 
One of the powerful trace analysis techniques is using Adjoint Threads of Activity 
(Volume 5, page 283) to filter various linear message activities (as a generalization of 
Thread of Activity, Volume 4, page 339). Such filtered activities can then be analyzed 
either separately (Sheaf of Activities, page 307) or together such as a new pattern we 
introduce here. If we identify parallel ATIDs (ATID is Adjoint TID, see an example in 
Volume 5, page 279) and see that one covers the other we can then make a hypothesis 
that they are Intra-Correlated (Volume 3, page 347). Here is a graphical example of a 
Periodic Message Block (page 300) largely composed from various Error Messages 
(page 299) that covers periodic Discontinuities (Volume 4, page 341) from another ATID 
(we can also consider the latter as periodic message blocks consisted from Silent 
Messages, page 339): 

348    PART 6: Software Trace Analysis Patterns 
ATID 1
Time
ATID 2
 
This is analogous to a cover71 in topology. 
 
 
                                                                 
71 http://en.wikipedia.org/wiki/Cover_(topology) 

Message Set    349 
Message Set 
Most of the time, especially for large software logs, we need to select messages based 
on some criteria be it a set of Error Messages (page 299), a set of messages containing 
Basic Facts (Volume 3, page 345), or some other predicate. Then we can use selected 
messages from that message set as Anchor Messages (Volume 5, page 293) or reverse 
Pivot Messages (page 314) as an aid in further analysis. 

350    PART 6: Software Trace Analysis Patterns 
#   PID TID Time                  Message
Time
Fact A:
Fact B:
Problem Description
{ m# | Fact A & Fact B }
 
 
 

Error Thread    351 
Error Thread 
When we see Error Message (page 299) or Exception Stack Trace (Volume 4, page 337) 
in a log file we might want to explore the sequence of messages from the same Thread 
of Activity (Volume 4, page 339) that led to the error. Such Message Set (page 349) has 
an analogy with memory analysis patterns such as Execution Residue (of partial stack 
traces without overwrites, Volume 2, page 239) and Stack Trace (Volume 1, page 395, 
where the error message is a top stack frame): 
Time
#   PID TID                       Message
Time
            Execution Residue
#   PID TID                               Message
Stack Trace
 
 
 

352    PART 6: Software Trace Analysis Patterns 
Activity Divergence 
Sometimes we have several Threads of Activity (Volume 4, page 339, for example, from 
the same process) visible for a certain period of time and then suddenly we see only one 
such thread till the end of a trace (or even none). This may be an indication of an 
application hang or some other abnormal behavior if several active threads doing 
logging are normal. If we consider such activities (including Adjoint Threads, Volume 5, 
page 283) as vectors running through some temporal “surface” we can use an analogy 
of a divergence72: 
                                                                 
72 http://en.wikipedia.org/wiki/Divergence 

Activity Divergence    353 
t1
t2
t3
Time
# PID TID Time                  Message
TID
TID
TID
 
 
 

354    PART 6: Software Trace Analysis Patterns 
[This page is intentionally left blank] 
 
 

Debugging Slang    355 
PART 7: Fun with Crash Dumps 
Debugging Slang 
LoL 
LoL - Law of Large 
Example: Q. How did you resolve this support case? A. By a LoL number! 
Explanation: The more support incidents you get, the larger their tracking numbers 
become. So at some stage the law of large numbers comes into effect: there is always a 
similar incident in the past. Don’t confuse with LOL73. 
 
 
                                                                 
73 http://en.wikipedia.org/wiki/LOL 

356    PART 7: Fun with Crash Dumps 
Watching a Movie 
Watching a Movie - Watching the prodigious output of some debugging commands and 
scripts in real time. 
Examples: Watching the output of !process 0 3f WinDbg command. Watching the 
output of user stack trace database and breaking in when it becomes uniform. 
 
 

Debugging Slang    357 
PonOS 
PonOS - Earlier stages of OS development (from Ancient Greek ponos74, ordeal). 
 
 
                                                                 
74 http://en.wikipedia.org/wiki/Ponos 

358    PART 7: Fun with Crash Dumps 
Typology, Typological 
Typology - the logic of typos in software. Typological - a logical typo. 
Examples: A typology of defects in source code. An engineer committed a grave 
typological mistake. 
 
 

Debugging Slang    359 
Memorandum 
Memorandum - when memory ran dump. 
Example: We got a few memorandums from that market leader. 
 
 

360    PART 7: Fun with Crash Dumps 
HELL 
HELL – High Exception Level Language. 
Example: This product was written in HELL. 
 
 

Debugging Slang    361 
FBI 
FBI - Fighting Bugs Inside. 
Example: I’m doing an FBI work now! 
 
 

362    PART 7: Fun with Crash Dumps 
poo 
poo - a function that follows foo and bar with a purpose to trigger a crash event, a 
breakpoint, or save memory state. 
Example: void main() { foo(); } void foo() { poo(); } void poo() { asm int 3; } 
 
 

Debugging Slang    363 
STaMPs 
STaMPs - Software Trace and Memory Patterns. Stack Trace and Memory Patterns. 
Examples: Got a few visible stamps on this trace. And more stamps on that crash dump. 
 
 

364    PART 7: Fun with Crash Dumps 
 
A NoSQL Problem 
A NoSQL Problem - when nothing appears on a refresh. 
Example: I got a NoSQL problem when I signed into that social web site. 
 
 

Debugging Slang    365 
Matrix 
Matrix – Memory analysis trix (tricks). 
Example: This component is Matrix-aware at runtime. 
 
 

366    PART 7: Fun with Crash Dumps 
Fool 
Fool - The long version of foo program used in C and C++ tutorials. 
Example: What a foolish program! 
 
 

Debugging Slang    367 
B2B, B2C, H2H 
A software diagnostics view: Boot 2 Boot; Boot 2 Crash; Hang 2 Hang; ...  
 
 
 

368    PART 7: Fun with Crash Dumps 
New Year Eve Debugging 
A WinDbg snippet from a multithreaded service: 
0:2011> ~2012s 
0:2012> 
 
 

Happy New Spiking Year of Software Trace Analysis    369 
Happy New Spiking Year of Software Trace Analysis 
We created a special picture based on CPU and memory timing diagram (an optimistic 
version of the original computicart, page 451): 
 
 
 

370    PART 7: Fun with Crash Dumps 
Happy New Year (from Windows 8) 
This is a seasonal greetings postcard with Windows 8 blue screen theme: 
 
 
 

Happy New Year (from Windows 8)    371 
[This page is intentionally left blank] 
 
 

372    PART 7: Fun with Crash Dumps 
Music for Debugging 
Going Romantic 
We have discovered that Romantic era music is good for debugging, memory dump, and 
software trace analysis sessions. Previously we included Beethoven (Volume 3, page 
315) and now suggest listening to symphonies of Schumann75. 
 
 
                                                                 
75 http://en.wikipedia.org/wiki/Robert_Schumann 

Music for Debugging    373 
Make It through This Trace 
Software trace analysis is notoriously difficult, so a bit of folk music is needed to make 
debugging sessions less boring. Make It Through This World album came to our 
attention in a local library and after listening to it we recommend it for software log 
analysis sessions.Here’s our own track title interpretation: 
1. Dream Away The Defects 
2. This I’d Analyze 
3. A Magnifier 
4. Make It Through This Trace 
5. Don’t Let It Go Unanalyzed 
6. Request-Reply Pair 
7. I Love It When It’s Short 
8. No Higher Specs 
9. Said, Said. 
10. When I Think Of You, My Customers 
11. Close to The Defect 
12. A Debugger For You Now 
 
 

374    PART 7: Fun with Crash Dumps 
Fiction for Debugging 
The Problem and The Solution 
After writing about music for debugging and founding software narratology, we decided 
to start writing about fiction. The first masterpiece to introduce is The Sound and The 
Fury76 by William Faulkner77. When we saw a color version published by Folio Society (an 
original idea by Faulkner now fulfilled by modern printing technology), we immediately 
recognized its importance for software trace analysis. We’re pretty sure Faulkner would 
have been delighted to see trace analysis patterns and how they may help in writing 
fiction (page 384). 
 
 
                                                                 
76 http://en.wikipedia.org/wiki/The_Sound_and_the_Fury 
77 http://en.wikipedia.org/wiki/William_Faulkner 

Pilgrimage to Harvard University    375 
Pilgrimage to Harvard University 
If you have plans for a debugging tour to visit famous debugging places around the 
world then according to Wikipedia78 you have to start with Harvard University where 
the first bug was found. 
 
 
                                                                 
78 http://en.wikipedia.org/wiki/Debugging 

376    PART 7: Fun with Crash Dumps 
Welcome to Ki* and Ke* 
Not long ago (at the time of this writing) the author became the proud owner of Ke* 
parrot named after OS kernel functions. It didn’t behave as we expected (heavily used 
Reflection API), so Ki* parrot counterpart was brought into space. They now behave and 
communicate happily ever after: 
 
They also inspired a Computicart (Computical Art) composition: What is to be done? 
(Volume 6, page 274). 

I Memory Dump    377 
 I Memory Dump 
This is both a game and serious philosophical and religious tool to guide your life. 
Basically, you need either 32 coin flips to construct a 32-bit pointer (or 64 flips for wide 
coverage) or 16 flips using a dice where each throw can generate at least 2 bits. Any 
device can help if you can get a random pointer. Then you use your favorite memory 
dump and symbol files for interpretation. Double, triple and multiple dereferences from 
a pointer can also be used to construe a path. For example, we just played and got: 
0:000> ? 0y10010111111000100100011011100111 
Evaluate expression: -1746778393 = 97e246e7 
0:000> !address 97e246e7 
Address 97e246e7 could not be mapped in any available regions 
If the address is inaccessible, then switch to another memory dump or continue 
flips and shift digits to the left. This way we got: 
0:000> ? 0y00101111110001001000110111001111 
Evaluate expression: 801410511 = 2fc48dcf 
0:000> !address 02fc48dcf 
Usage:   
Free 
Base Address:  1f858000 
End Address:  58c30000 
Region Size:  393d8000 
Type:   
00000000 
State:   
00010000 MEM_FREE 
Protect:  
00000001 PAGE_NOACCESS 
Continue flip and shift until you get an output with symbol signs: 
0:000> ? 0y01011111100010010001101110011110 
Evaluate expression: 1602821022 = 5f891b9e 
0:000> dp 5F891B9E 
5f891b9e ???????? ???????? ???????? ???????? 
5f891bae ???????? ???????? ???????? ???????? 
5f891bbe ???????? ???????? ???????? ???????? 
5f891bce ???????? ???????? ???????? ???????? 
5f891bde ???????? ???????? ???????? ???????? 
5f891bee ???????? ???????? ???????? ???????? 
5f891bfe ???????? ???????? ???????? ???????? 
5f891c0e ???????? ???????? ???????? ???????? 
 
 

378    PART 7: Fun with Crash Dumps 
0:000> !address 5F891B9E 
Usage:   
Free 
Base Address:  5eb8a000 
End Address:  60080000 
Region Size:  014f6000 
Type:   
00000000 
State:   
00010000 MEM_FREE 
Protect:  
00000001 PAGE_NOACCESS 
Unloaded modules that overlapped the region in the past: 
BaseAddr EndAddr Size 
5ebc0000 5ebcd000 d000 Perfctrs.dll 
We now have the dump output for thinking: “In the past - perfect control; 
performance was counted; now - free”. 
 
 

A Blue Screen Watch    379 
A Blue Screen Watch 
The following watch came to my attention when I saw an ad at Zurich airport (Tissot 
Seastar Blue Dial): 
 
It’s definitely for memory space navigators and also a good complement to a 
digital one (Volume 1, page 560). 
 
 

380    PART 7: Fun with Crash Dumps 
Poetry 
If your system hangs today, 
Don't panic, don't dump, 
Read a book, prepare drink, 
Spend a break, and then restart.  
 
 

Surfaces in Nature    381 
Surfaces in Nature 
 
 
 

382    PART 7: Fun with Crash Dumps 
[This page is intentionally left blank] 
 
 

Software Anti-Narrative    383 
PART 8: Software Narratology 
Software Anti-Narrative 
In narratology, anti-narrative denotes a narrative which has sequences of events 
impossible in reality. In software traces, such sequences usually depict abnormal 
software behavior. Here are some parallels with corresponding trace analysis patterns: 
Fiction                     | Software Trace 
================================================================= 
Repeated unrepeatable       | Periodic Error79 (?)  
Denarration (erasure)       | No Activity80 / Incomplete History81 
Chronological contradiction | Impossible Trace82 
The question mark means that possibly another pattern is needed there. 
 
 
                                                                 
79 Volume 3, page 344 
80 Volume 5, page 297 
81 Volume 5, page 286 
82 Volume 6, page 249 

384    PART 8: Software Narratology 
Software Narratology Helps Fiction Writers 
Any DA+TA (Volume 3, page 330) source (dump artifact + trace artifact) can be used to 
generate and validate narrative fiction where memory dump components provide 
fiction structure and software trace components provide behavior (plot and story): 
Any DA+TA
Memory 
Dump
Fiction 
Structure
Software 
Trace
Fiction
(Story, 
Plot)
 
The author already uses such help in writing fiction books83 (”computational” 
novels) and uses trace analysis patterns in validating historical narratives84 (with Excel 
and software trace viewers as tools). Here fiction is in no way different from software 
fictions outlined in the article about software stories (Volume 5, page 278). Please also 
note two other fields along with software narratology (Volume 3, page 278; SN was 
defined in mid 2009 where the first pattern appeared earlier in 2009, Volume 3, page 
344) that are under development: software chorology and chorography (Volume 5, page 
                                                                 
83 http://www.opentask.com/fiction-titles 
84 http://www.opentask.com/history-titles 

Software Narratology Helps Fiction Writers    385 
229). Adjoint threads (Volume 4, page 330) and trace analysis patterns85 are the major 
contributions from SN. 
Because we consider memory dumps in a general sense (e.g. philosophy of 
memoidealism86 where any data is a memory dump) and software trace narremes (page 
386) as small memory dumps (Volume 3, page 308) any data stream can be potentially 
represented as some fictional or real story. And vice versa, any story can be transformed 
into corresponding computer memory dumps and software traces (for example, the 
narralog language87 is being designed to model software stories). 
 
 
                                                                 
85 Software Trace and Log Analysis: A Pattern Reference (ISBN: 978-1908043801) 
86 Volume 2, page 349 
87 Page 90 

386    PART 8: Software Narratology 
Narremes in Software Narratology 
Reading about narremes88 suggested us to elaborate on a basic software trace (log) unit. 
One candidate is a trace message invariant, a skeleton trace message similar to a format 
string. There is also a corresponding software trace analysis pattern called Message 
Invariant (Volume 6, page 251). Although this might be too an elementary unit akin to a 
sentence level and another possible candidate is a macromessage, a combination of 
several messages serving some semantic function. There is a corresponding general 
pattern Macrofunction (page 279) and an example of a concrete analysis pattern called 
Exception Stack Trace (Volume 4, page 337). The actual software narreme might be 
situated between these two extremes: invariants and macrofunctions. 
If you are new to a software narratology field, please look at these articles placed 
in chronological order (except a pattern catalog): 
 
Software Narratology: A Definition (Volume 3, page 342)  
 
Basic Software PLOTs (Volume 5, page 272)  
 
Two Readings of a Software Trace (Volume 5, page 274) 
 
The Extended Software Trace (Volume 5, page 277) 
 
Presenting a Software Story (Volume 5, page 278) 
 
Close and Deconstructive Readings of a Software Trace (Volume 6, page 240) 
 
Software Trace Analysis Pattern Catalog89  
 
 
                                                                 
88 http://en.wikipedia.org/wiki/Narreme 
89 Software Trace and Log Analysis: A Pattern Reference (ISBN: 978-1908043801) 

Narralog - A Software Trace Modeling Language    387 
Narralog - A Software Trace Modeling Language 
Teaching Accelerated Software Trace Analysis training90 requires extensive real life like 
software logs with multiple software behavior patterns. The similar accelerated memory 
dump analysis training courses (unmanaged / native Windows91 and .NET92) also require 
good memory dumps but this problem was solved by modeling patterns of abnormal 
software behavior in an appropriate implementation language such as C, C++, and C#. 
Modeling software traces with hundreds of software components, processes and 
threads would require enormous programming efforts. Therefore, the natural approach 
is to describe a desired software trace in some declarative language (or minimally 
imperative) and get a million line software log that models a specific combination of 
trace analysis patterns. So, welcome to such a language called Narralog: Software 
Narrative Log or Narrative Logic. This language is different from Riemann programming 
language (Volume 3, page 299) which is a language to describe software problems and 
generate software problem-solving tools. 
 
 
                                                                 
90 http://www.patterndiagnostics.com/accelerated-software-trace-analysis 
91 http://www.patterndiagnostics.com/accelerated-windows-memory-dump-analysis 
92 http://www.patterndiagnostics.com/accelerated-net-memory-dump-analysis 

388    PART 8: Software Narratology 
What is a Software Narrative? 
The previous definition (Volume 3, page 342) of software narratology was restricted to 
software traces and logs (the top left quadrant on a software narrative square (page 
391). Now with the broadening of the domain of software narratology to the whole 
world of software narrative stories including actor interactions with software in 
construction requirements use cases and post-construction incidents we give another 
definition: 
Software narrative is a representation of software events and changes of state. 
Software Narratology is a discipline that studies such software narratives 
(software narrative science). 
 
 

Software Narrative Planes    389 
Software Narrative Planes 
Using an idea of expression and content planes from glossematics93 and a basic unit of 
glosseme we can organize software traces with corresponding patterns and software 
trace narremes (basic units of software narrative such as traces and event logs, page 
386) into two planes: software trace narrative plane (expression plane) with narremes 
and the corresponding program lines of traces (PLOTs, Volume 5, page 272) source code 
and design plane (content plane) with their own set of construction narremes such as 
related to collaboration of software constructs. All this corresponds to the following 
diagram: 
Software Construction 
Narrative
Design and Implementation 
Patterns and Narremes
Software Post-construction 
Narrative
Software Trace
Patterns and Narremes
 
 
 
                                                                 
93 http://en.wikipedia.org/wiki/Glossematics 

390    PART 8: Software Narratology 
The same can be said about actor interaction level of software construction 
(what ought to be) and post-construction (what is) phases having their own 
construction and post-construction narratives, patterns and narremes such as in 
requirements (use cases) and in problem and software incident descriptions: 
Software Construction
Narrative
Requirements 
Patterns and Narremes
Software Post-construction 
Narrative
Actor Interaction 
Patterns and Narremes
 
 
 
 

Software Narratology Square    391 
Software Narratology Square 
After introducing software narrative planes (page 389), it is logical to expand the field of 
software narratology (Volume 3, page 342) to cover the whole domain of software 
construction and post-construction. We, therefore, combine both pairs of planes to 
create a narratological square: 
Software Construction
Narrative
Requirements 
Patterns and Narremes
Software Construction 
Narrative
Design and Implementation 
Patterns and Narremes
Software Post-construction 
Narrative
Software Trace
Patterns and Narremes
Software Post-construction 
Narrative
Actor Interaction 
Patterns and Narremes
 
 
 

392    PART 8: Software Narratology 
Writing and Validation of Historical Narratives 
Software narratological approach can be useful for writing, analyzing and validating 
historical narratives. Trace and event log messages play the role of historical events 
where process IDs are assigned to particular historical institutions and their 
representatives. Threads serve the role of historical entities like persons. Modules play 
the role of shared ideologies. We already use this approach for writing history books94. 
This can also work on a different level such as analyzing a history of debugging as 
a sequence of troubleshooting and debugging stories. Another example is how software 
narratology and memoretics (the study of memory snapshots) help fiction writers (page 
384). 
 
 
                                                                 
94 http://www.opentask.com/history-titles 

Software Trace Analysis Patterns Domain Hierarchy    393 
Software Trace Analysis Patterns Domain Hierarchy 
We get many questions on whether software log analysis patterns from Software 
Diagnostics Institute95 are OS or platform or product specific. Our answer is that they 
are independent of all of them because they are based on viewing software logs as 
stories of computation and were discovered by application of narratological analysis 
(software narratology96). In addition to these patterns there exist domain specific 
problem patterns such as wrong hotfix level or specific product error code during 
software installation or execution. 
Windows log
Citrix log
Mac OS X log
Software Trace and Log Analysis Patterns
SQL Server log
Web Server log
Network trace
GUI message log
 
 
 
                                                                 
95 http://www.dumpanalysis.org/ 
96 http://www.patterndiagnostics.com/Introduction-Software-Narratology-materials 

394    PART 8: Software Narratology 
Process Monitor as Modeling Tool 
If we need various real life software traces with millions of lines from complex software 
environments to learn pattern-driven software log analysis, we can use Process 
Monitor97 as a modeling tool. Here we can abstract from their “monitoring” and API 
interception context and consider trace messages as emitted from various processes 
and threads (like Citrix CDF traces). This approach was used in Accelerated Windows 
Software Trace Analysis training98 and Debugging TV Frames episode 0×1999. 
 
 
                                                                 
97 http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx 
98 http://www.patterndiagnostics.com/accelerated-software-trace-analysis 
99 http://www.debugging.tv/ 

Generalized Software Narrative and Trace    395 
Generalized Software Narrative and Trace 
In the past, we viewed software traces and logs as temporarily ordered event 
sequences. Since events are just memory data we have a map: 
T  -> M 
This can be seen in the definition of a software trace (Volume 3, page 308). Here 
we generalize the domain to any arbitrary set, for example, it can be a list of indexes or 
pointers or even memory itself. The latter map can give us narrative chains such as: 
M -> M -> M -> M 
And even give us a grand unification of memory and log analysis and the 
possibility to apply software narratology to memory dump analysis as well. 
 
 

396    PART 8: Software Narratology 
Unified Computer Diagnostics: Incorporating Hardware Narratology  
Interpreting hardware signals as messages and messages as signals allows us to apply 
Software Narratology and software trace analysis patterns to the domain of hardware 
diagnostics: 
Unified Computer Diagnostics
Generalized Trace Analysis Patterns
Computer Narratology
(Hardware-Software Narratology)
 
Generalized trace analysis patterns and narrative extends the view of hardware-
software traces and logs as temporarily ordered event sequences. The time domain is 
generalized to any arbitrary set such as a list of indexes or pointers or even memory 
itself. This gives a unification of memory and log analysis and application of Computer 
Narratology to memory dump analysis as well. 
We call the application of methods of literary narratology to computer trace 
and log analysis and computer-related stories in general as Hardware-Software 
Narratology or simply Computer Narratology as it was originally done in Volume 3 
when we first introduced Software Narratology (page 342). 
 
 

Introducing Software Narratology of Things (Software NT)    397 
Introducing Software Narratology of Things (Software NT) 
This is the further development of Software Narratology (T -> M) and Generalized 
Software Narratives (M -> M -> M -> ..., page 395). Now it incorporates devices (things) 
and IoT. Whereas the general narrative space is 2M1T: 
Memory Address
Memory Value
Time
 
The narrative space of NT is "complex" 2M2T: 
Memory Address
Memory Value
Things
Time
 
Narratology of Things also incorporates Hardware Narratology (page 396). 

398    PART 8: Software Narratology 
[This page is intentionally left blank] 
 
 

Unified and Generative Debugging    399 
PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Unified and Generative Debugging 
Analysis, Architectural, Design, Implementation and Usage 
Debugging Patterns 
This is another tracing example of unified debugging patterns introduced previously in 
Volume 6 (page 172). 
 
Analysis Patterns 
Focus of Tracing (Volume 6, page 243) 
 
Architectural Patterns 
Debug Event Subscription / Notification 
 
Design Patterns 
Shared Debug Event State 
 
Implementation Patterns 
Shared Variable 
 
Usage Patterns 
Saving a memory address obtained at a breakpoint event in a debugger 
pseudo-register for use at later breakpoint events 
 
 

400    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Debugging TV 100 published a case study for tracing window messages in 
WinDbg101. There a pseudo-register is used to save a buffer address before GetMessage 
call and then to reuse it after the call. Please look at Event State Management slide on 
Frames episode 0×06 presentation102. The full WinDbg log and the recording are 
available there too103. 
 
 
                                                                 
100 www.debugging.tv 
 
101 http://www.youtube.com/watch?v=ACHO2pYngMw 
102 http://www.debugging.tv/Frames/0x06/DebuggingTV_Frame_0x06.pdf 
103 http://www.debugging.tv/Frames/0x06/DebuggingTV_Frame_0x06.txt 

Software Problem Description Language    401 
Software Problem Description Language 
The purpose of SPDL (Software Problem Description Language) is an automatic 
generation of a software troubleshooting tool based on the description of a problem. 
Here software problem means a post-construction problem as outlined in Introduction 
to Pattern-Driven Software Problem Solving104. The tool construction will utilize an 
expanded set of DebugWare105 and Workaround106 patterns together with the refined 
version of RADII107 software development process. This will also provide necessary 
effectiveness, efficiency and enhanced problem-solving capabilities to existing TaaS 
(Tools as a Service) implementations that are limited in the number of tools they offer. 
 
 
                                                                 
104 http://www.dumpanalysis.com/PDSPSI-materials 
105 See Volume 2, page 391; Volume 4, page 307; Volume 6, page 255 
106 See Volume 4, page 321; Volume 6, page 258 
107 http://www.dumpanalysis.org/RADII+process 

402    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
What are Software Trace and Memory Dump Analysis? A One 
Sentence Definition 
Many years passed since we provided a longer structuralist definition (Volume 1, page 
506). Recently we came to recognize pattern-driven iterative and incremental nature of 
memory and software trace analysis 108  and post-construction software problem 
solving 109 in general and therefore a one sentence definition became necessary: 
recognition and interpretation of patterns of software behavior. 
 
 
                                                                 
108 http://www.patterndiagnostics.com/STMDA-materials 
109 http://www.patterndiagnostics.com/PDSPSI-materials 

Software Problem Solving Tools as a Service    403 
Software Problem Solving Tools as a Service 
A software problem incident is described using software problem description language. 
Its program interpretation or compilation results in a published software problem-
solving tool. Tools can be reused, parameterized, aggregated and organized into 
hierarchical catalogs. Welcome to the TaaS of the future! 
 
 
 

404    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Software Problem Description Patterns 
The development of SPDL (page 399) requires extending pattern-driven analysis 
approach to software problems such as software defect and software incident 
descriptions. Such a pattern language should help with accurate problem identification 
and problem resolution through software behavior analysis and with choosing, for 
example, appropriate workaround patterns110 or, for a debugging strategy, unified 
debugging patterns 111. This can also be applicable to software security incident 
descriptions as well.  
We introduce the first pattern called Problem Summary. This is a very short 
description that summarizes the essence of the problem from a submitter point of view 
such as a software user or a technical support engineer. Whether it is correct or 
incorrect is another problem itself but the missing summary usually requires close 
reading of the whole problem description text and analyze together various relevant 
parts to reconstruct the summary. 
 
 
                                                                 
110 See Volume 4, page 321; Volume 6, page 258 
111 Volume 6, page 172 

Software Behavior Pattern Prediction    405 
Software Behavior Pattern Prediction 
Sometimes we hear voices saying that Linux, FreeBSD, and Mac OS X core dumps are 
uninteresting. This is not true. If you haven’t seen anything interesting there it just 
simply means that you only encountered a limited amount of abnormal software 
behavior. The widespread usage of Windows OS means that most patterns have been 
diagnosed and described first for it, and other operating systems are waiting for their 
turn. 
Our goal is to have a pattern catalog with examples from different OS. For 
example, currently all Mac OS X patterns we provide are just examples to existing 
Windows pattern names. All operating systems share the same structure and behavior, 
for example, structural memory analysis patterns112 and the same computational model. 
Although structural patterns are different from behavioral patterns, we also plan 
extending the structural list significantly especially in relation to memory forensics 
training113. Regarding behavioral patterns it is possible to model and predict specific 
pattern examples for another OS by using the already existing catalog. 
 
 
                                                                 
112 Volume 5, page 343 
113 http://www.patterndiagnostics.com/accelerated-windows-memory-forensics 

406    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Patterns of Software Diagnostics 
First Fault 
While preparing a seminar on Software Diagnostics,114 we made a lot of notes and 
realized that a system of patterns, corresponding vocabulary and pattern language are 
needed for this discipline. Here patterns are supposed to be broad in nature and 
different from patterns for specific artifacts such as memory dumps115 and software 
traces116. So the first pattern addresses a diagnostic encounter with a First Fault in 
comparison to subsequent faults where the problem becomes noticeable and diagnostic 
resources are allocated. Such faults should not be dismissed. Dan Skwire is a passionate 
advocate of first fault software problem solving and wrote a book: First Fault Software 
Problem Solving: A Guide for Engineers, Managers and Users117. 
The following paper proposes distributed control flow reconstruction for first 
fault diagnosis: TraceBack: First Fault Diagnosis by Reconstruction of Distributed Control 
Flow118.  
Software Diagnostics Services (former Memory Dump Analysis Services) uses 
patterns of abnormal software behavior for its first fault diagnostics that doesn’t require 
any special instrumentation: Join Debugging Diagnostics Revolution!119 
 
 
                                                                 
114 http://www.patterndiagnostics.com/Introduction-Software-Diagnostics-materials 
115 http://www.dumpanalysis.org/encyclopedia-crash-dump-analysis-patterns 
116 http://www.dumpanalysis.org/trace-log-analysis-pattern-reference 
117 http://www.dumpanalysis.org/First+Fault+Software+Problem+Solving 
118 http://www.cs.utexas.edu/~witchel/pubs/pldi05ayers.pdf 
119 http://www.patterndiagnostics.com/debugging-diagnostics-revolution 

Highly Effective Diagnostics    407 
Highly Effective Diagnostics 
Motivated by an article 7 Habits of Highly Effective Debuggers120 we would like to reflect 
on a distinction between diagnostics and problem solving as separate processes 
(although highly related). First, we reverse the precept from that article because stories 
such as software logs and traces are of primary importance to software diagnostics (and 
not only). And without diagnostics there is no effective debugging (treatment, problem 
solving, etc.).  
The principle precept of diagnostics: stories, not statistics secure certainty. 
 
 
 
                                                                 
120 http://www.waveclaw.net:8080/~jdpowell/texts/7-habits.html 

408    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Network Trace Analysis Patterns 
We can apply the software trace analysis pattern approach to network trace analysis 
which lacks a unified pattern language. Here we consider a network trace as essentially 
a software trace where packet headers represent software trace messages coupled with 
associated transmitted data: 
 
Since we have a trace message stream formatted by a network trace visualization 
tool we can apply most if not all trace analysis patterns for diagnostics121 including 
software narratology122 for interpretation, discourse, and different representations. We 
provide a few trivial examples here, and more is covered in the separate seminar123. The 
first example is Discontinuity pattern (Volume 4, page 341): 
                                                                 
121 http://www.patterndiagnostics.com/Introduction-Software-Diagnostics-materials 
122 http://www.patterndiagnostics.com/Introduction-Software-Narratology-materials 
123 http://www.patterndiagnostics.com/pattern-oriented-network-trace-analysis-materials 

Network Trace Analysis Patterns    409 
 
Other similar patterns are No Activity (Volume 5, page 297), Truncated Trace 
(Volume 5, page 301) and Time Delta (Volume 5, page 282). The second example is 
Anchor Messages (Volume 5, page 293): 
 
Additional examples there include Significant Event (Volume 5, page 281) and 
Bifurcation Point (Volume 4, page 343) patterns. Layered protocols are represented by 
Embedded Message pattern (to be described and added to the pattern list). Such traces 
can be filtered for their embedded protocol headers and therefore naturally represent 
Adjoint Thread pattern (Volume 5, page 283, for the more detailed description of 
adjoint threads as extension of multithreading please see the article What is an Adjoint 
Thread124): 
                                                                 
124 http://www.debuggingexperts.com/adjoint-thread 

410    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
 
 
 

Software Diagnostics Services    411 
Software Diagnostics Services 
For some time, we were struggling with finding a good name for memory dump and 
software trace analysis activities. The name Memoretics we used for the science of 
memory dump analysis (that also incorporates software traces) seemed not so good to 
describe the whole practical activity that should be transparent to everyone in IT. 
Fortunately, we timely understood that all these activities constitute the essence of 
software diagnostics that previously lacked any solid foundation. Thus, Software 
Diagnostics Institute125 was reborn from the previous Crash Dump Analysis Portal. This 
institute does pure and applied scientific research activities and in recent years was 
funded mainly from OpenTask publisher126 and recently from Memory Dump Analysis 
Services127. The latter company also recognized that the broadening of its commercial 
activities required a new name. So, Software Diagnostics Services was reborn128. 
 
 
                                                                 
125 http://www.DumpAnalysis.org 
126 http://www.OpenTask.com 
127 http://www.DumpAnalysis.com 
128 http://www.patterndiagnostics.com/software-diagnostics-services 

412    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Architecture of Process Memory Dump Capture Done Right 
Sometimes we get requests to review application memory dump capture design. Of 
course, such requests usually come only when such designs don’t work, or there are 
problems with loading saved crash dumps. The common blueprint of such architectures 
is a top-level exception handler that uses some API to capture and save process memory 
state. However, such designs forget why separate processes were introduced in the first 
place: to guard process memory space of different unrelated tasks (for related tasks 
there are threads). The data of the module (and its thread state) that does process 
memory capture may also be corrupt. The right design would be to show a message box 
with information on how to use external process memory dumper such as Task 
Manager. If we need automation, then the right thing is to rely on WER features. Let 
separate processes do their work in separate spaces. 
 
 

An Introduction to General Systems Thinking (Book Review)    413 
An Introduction to General Systems Thinking (Book Review) 
We bought this book written by Gerald M. Weinberg some time ago when we 
recognized that systems approach was needed for memory dump analysis. However, we 
read it only recently while preparing to talk on systemic software diagnostics129. While 
reading we realized that we already applied some systems theory ideas, for example, 
about isomorphism of disciplines as systems (which we named as metaphorical 
bijection): from literary narratology to software narratology and from that to network 
trace analysis. So if you are interested in systems either computer software ones or 
human organizational, then we would greatly recommend this book as an introduction. 
The recommended literature in exercises is also useful. 
 
 
                                                                 
129 http://www.patterndiagnostics.com/systemic-diagnostics-materials 

414    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Software Diagnostics Institute Logo 
Software Diagnostics Institute130 main page now features the brand new medical-style 
logo with UML 2 components and interface sinks: 
 
 
 
                                                                 
130 http://www.DumpAnalysis.org 

User Interface Problem Analysis Patterns    415 
User Interface Problem Analysis Patterns 
Unresponsive Window 
The previous pattern from this problem pattern category was Error Message Box (Vol-
ume 6, page 259). Here we discuss another pattern related to unresponsive GUI. We all 
see hang windows from time to time. This can happen, for example, from Main Thread 
(Volume 1, page 437) blocked in Wait Chain (Volume 6, page 55). Some windows 
become unresponsive only temporary, for example, when a window message loop 
results in a CPU intensive window procedure code path. When we open large WinDbg 
logs generated by WinDbg scripts running against a complete memory dump in Notepad 
it opens up a frozen window for some seconds and sometimes for a minute or two. To 
get an unresponsive window for a longer time, we opened a PDF file with a size of a few 
MB and attached WinDbg. Then we got this stack trace: 
0:000> k 
Child-SP RetAddr Call Site 
00000000`001ecce0 000007fe`ff9fdf89 
USP10!otlCacheManager::GetNextLookup+0x12a 
00000000`001ecd40 000007fe`ff9fa134 USP10!ApplyFeatures+0x489 
00000000`001ed000 000007fe`ff9e1600 USP10!SubstituteOtlGlyphs+0x224 
00000000`001ed0b0 000007fe`ff9d4b60 USP10!GenericEngineGetGlyphs+0x1000 
00000000`001ed450 000007fe`ff9989c5 USP10!ShlShape+0x7a0 
00000000`001ed670 000007fe`ff9a7363 USP10!ScriptShape+0x205 
00000000`001ed710 000007fe`ff9a8ac9 USP10!RenderItemNoFallback+0x433 
00000000`001ed7d0 000007fe`ff9a8d86 USP10!RenderItemWithFallback+0x129 
00000000`001ed820 000007fe`ff9aa5f7 USP10!RenderItem+0x36 
00000000`001ed870 000007fe`ff99b2c9 USP10!ScriptStringAnalyzeGlyphs+0x277 
00000000`001ed910 000007fe`ff30285c USP10!ScriptStringAnalyse+0x399 
00000000`001ed990 000007fe`ff3031c1 LPK!EditStringAnalyse+0x1d4 
00000000`001eda70 000007fe`fc876c05 LPK!EditCchInWidth+0x4e 
00000000`001edad0 000007fe`fc85862e COMCTL32!EditML_BuildchLines+0x221 
00000000`001edba0 000007fe`fc878f56 COMCTL32!Edit_ResetTextInfo+0x82 
00000000`001edbe0 000007fe`fc85a566 COMCTL32!EditML_WndProc+0x456 
00000000`001edcd0 00000000`77a19bd1 COMCTL32!Edit_WndProc+0xe0a 
00000000`001edd70 00000000`77a16aa8 USER32!UserCallWinProcCheckWow+0x1ad 
00000000`001ede30 00000000`77a16bad USER32!SendMessageWorker+0x682 
00000000`001edec0 00000000`ff7f4256 USER32!SendMessageW+0x5c 
00000000`001edf10 00000000`ff7f43d6 NOTEPAD!LoadFile+0x7cb 
00000000`001ee260 00000000`ff7f1018 NOTEPAD!NPInit+0x802 
00000000`001efbb0 00000000`ff7f133c NOTEPAD!WinMain+0xc7 
00000000`001efc30 00000000`7764652d 
NOTEPAD!DisplayNonGenuineDlgWorker+0x2da 
00000000`001efcf0 00000000`77b2c521 kernel32!BaseThreadInitThunk+0xd 
00000000`001efd20 00000000`00000000 ntdll!RtlUserThreadStart+0x1d 
 
 

416    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Another notepad.exe instance had a similar stack trace: 
0:000> k 
Child-SP RetAddr Call Site 
00000000`0015ca60 000007fe`ff9e2152 
USP10!ShapingLibraryInternal::RestoreCharMap+0x12 
00000000`0015cab0 000007fe`ff9d80b8 
USP10!GenericEngineGetGlyphPositions+0x2a2 
00000000`0015ce60 000007fe`ff9d548e USP10!ShapingGetGlyphPositions+0x8c8 
00000000`0015d030 000007fe`ff998c72 USP10!ShlPlace+0x2de 
00000000`0015d1e0 000007fe`ff9a742d USP10!ScriptPlace+0x1f2 
00000000`0015d270 000007fe`ff9a8ac9 USP10!RenderItemNoFallback+0x4fd 
00000000`0015d330 000007fe`ff9a8d86 USP10!RenderItemWithFallback+0x129 
00000000`0015d380 000007fe`ff9aa5f7 USP10!RenderItem+0x36 
00000000`0015d3d0 000007fe`ff99b2c9 USP10!ScriptStringAnalyzeGlyphs+0x277 
00000000`0015d470 000007fe`ff30285c USP10!ScriptStringAnalyse+0x399 
00000000`0015d4f0 000007fe`ff3031c1 LPK!EditStringAnalyse+0x1d4 
00000000`0015d5d0 000007fe`fc876c05 LPK!EditCchInWidth+0x4e 
00000000`0015d630 000007fe`fc85862e COMCTL32!EditML_BuildchLines+0x221 
00000000`0015d700 000007fe`fc878f56 COMCTL32!Edit_ResetTextInfo+0x82 
00000000`0015d740 000007fe`fc85a566 COMCTL32!EditML_WndProc+0x456 
00000000`0015d830 00000000`77a19bd1 COMCTL32!Edit_WndProc+0xe0a 
00000000`0015d8d0 00000000`77a16aa8 USER32!UserCallWinProcCheckWow+0x1ad 
00000000`0015d990 00000000`77a16bad USER32!SendMessageWorker+0x682 
00000000`0015da20 00000000`ff7f4256 USER32!SendMessageW+0x5c 
00000000`0015da70 00000000`ff7f43d6 NOTEPAD!LoadFile+0×7cb 
00000000`0015ddc0 00000000`ff7f1018 NOTEPAD!NPInit+0×802 
00000000`0015f710 00000000`ff7f133c NOTEPAD!WinMain+0xc7 
00000000`0015f790 00000000`7764652d 
NOTEPAD!DisplayNonGenuineDlgWorker+0×2da 
00000000`0015f850 00000000`77b2c521 kernel32!BaseThreadInitThunk+0xd 
00000000`0015f880 00000000`00000000 ntdll!RtlUserThreadStart+0×1d 
This thread was also Spiking (Volume 1, page 305) and all work was done in a 
Unicode script processor because the PDF file was obviously not an ASCII text file: 
0:000> !runaway f 
User Mode Time 
Thread       Time 
0:fa0       0 days 0:00:12.402 
Kernel Mode Time 
Thread       Time 
0:fa0       0 days 0:00:10.826 
Elapsed Time 
Thread       Time 
0:fa0       0 days 0:00:34.654 
 
 

User Interface Problem Analysis Patterns    417 
0:000> lmv m USP10 
start             end                 module name 
000007fe`ff990000 000007fe`ffa59000   USP10      (pdb 
symbols)          c:\mss\usp10.pdb\DB4EC1196F91457FBB0A462D9D0AFEC31\usp10.pdb 
Loaded symbol image file: C:\Windows\system32\USP10.dll 
Image path: C:\Windows\system32\USP10.dll 
Image name: USP10.dll 
Timestamp:        Sat Nov 20 13:15:33 2010 (4CE7C9F5) 
CheckSum:         000C4B61 
ImageSize:        000C9000 
File version:     1.626.7601.17514 
Product version:  1.626.7601.17514 
File flags:       0 (Mask 3F) 
File OS:          40004 NT Win32 
File type:        2.0 Dll 
File date:        00000000.00000000 
Translations:     0409.04b0 
CompanyName:      Microsoft Corporation 
ProductName:      Microsoft(R) Uniscribe Unicode script processor 
InternalName:     Uniscribe 
OriginalFilename: Uniscribe 
ProductVersion:   1.0626.7601.17514 
FileVersion:      1.0626.7601.17514 (win7sp1_rtm.101119-1850) 
FileDescription:  Uniscribe Unicode script processor 
LegalCopyright:   © Microsoft Corporation. All rights reserved. 
We see LoadFile function and find a file name from Execution Residue (Volume 2, 
page 239) on the raw stack: 
0:000> dpu 00000000`0015da70 
00000000`0015da70 00000000`00000000 
00000000`0015da78 00000000`00000000 
00000000`0015da80 00000000`00000000 
00000000`0015da88 00000000`00000000 
00000000`0015da90 00000000`02b40040 "%PDF-1.4..%µµµµ..1 0 obj..<</Type/Catalog/Pages 2 0 R/L" 
00000000`0015da98 00000000`00576a62 
00000000`0015daa0 00000000`00000000 
00000000`0015daa8 00000000`00000000 
00000000`0015dab0 00000000`025c0000 
00000000`0015dab8 00000000`00000000 
00000000`0015dac0 00000000`00000000 
00000000`0015dac8 00000000`00000100 
00000000`0015dad0 00000000`00000000 
00000000`0015dad8 00000000`025c0000 
00000000`0015dae0 00000000`00000265 
00000000`0015dae8 00000000`ff800b40 "C:\DL\History-Russian-Literature-VIII-Volume2.pdf" 
[...] 
 
 

418    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Pattern-Based Software Diagnostics 
Pattern-driven131 software post-construction problem solving involves using preexisting 
pattern languages and pattern catalogs for software diagnostics, troubleshooting and 
debugging. Pattern-based software post-construction problem solving addresses PLS 
(Pattern Life Cycle) - from the discovery of a new pattern through its integration into an 
existing catalog and language, testing, packaging and delivering to pattern consumers 
with subsequent usage, refactoring and writing case studies: 
Pattern Catalog
Incident 
Artifact
(memory dump, 
software log)
Discovery
New Pattern
Integration
Packaging
Usage
Pattern-Driven
Software 
Diagnostics
System
Pattern-Based
Software 
Diagnostics
 
 
 
                                                                 
131 http://www.patterndiagnostics.com/PDSPSI-materials 

Software Diagnostics Discipline    419 
Software Diagnostics Discipline 
Let’s define software diagnostics as a discipline studying abnormal software structure 
and behavior in software execution artifacts (such as memory dumps, software and 
network traces and logs) using pattern-driven132, systemic133 and pattern-based134 
analysis methodologies. 
 
 
 
 
                                                                 
132 http://www.patterndiagnostics.com/Introduction-Software-Diagnostics-materials 
133 http://www.patterndiagnostics.com/systemic-diagnostics-materials 
134 http://www.patterndiagnostics.com/pattern-based-diagnostics-materials 

420    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Architecture of memCPU 
In addition to MemOS (Memory OS), we propose memCPU architecture where software 
diagnostics is built from the very start. Every CPU instruction from memISA (Memory 
Instruction Set Architecture) has its previous memory state saved in a memory dump. 
Plus there are special instructions to facilitate software tracing. Here is a conceptual 
diagram depicting data and code input streams and continuous output memory dump 
stream: 
 
 
 
 

Phenomenology of Software Diagnostics: A First Sketch    421 
Phenomenology of Software Diagnostics: A First Sketch 
Influenced by stages of Husserlian135 phenomenological investigation we propose the 
following stages of the investigation of phenomena as it appears in software execution 
artifacts such as memory dumps, traces, and logs: 
1. Bracketing the outside source code as a reduction to patterns of phenomena 
independent from causal software engineering explanations. 
2. Constructing the computational world for the given incident (the so-called 
horizon of computation). 
3. Comparing with “computed-in” experience of past computational worlds from 
which all universal patterns of computational structural and behavioral 
phenomena emerged. 
According to the above, software diagnostics is a phenomenological science of 
patterns. Here’s a funny coincidence. The first step in a phenomenological method is the 
so-called epoché. We provide our own interpretation of this - “exception processing of 
crash” hypothetical episteme. This sounds similar to EPOCH (Volume 4, page 271) 
metaphysical grand conjecture that our World is just one enormous exception 
processing handler after Big Bang. 
 
 
                                                                 
135 http://en.wikipedia.org/wiki/Edmund_Husserl 

422    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Software Diagnostics Report Schemes 
Missing Cause Trace 
Report schemes are important meta-patterns of monitoring and software problem 
analysis reports. It is often the case that we have software artifacts and some problem 
description, and we need to provide recommendations on further troubleshooting. 
Most of the time such an analysis and associated response fit into abstract schemes 
where we can just substitute variables for concrete states, actions, artifacts, and 
behavioral descriptions. Sometimes we also have difficulty to write such analysis 
reports, so we hope report schemes is of help here to provide organizing templates for 
thought process.  
Here’s the first such scheme: 
1. If Action then Behavior  
2. We have a trace of Behavior  
3. We need a trace of Action and Behavior  
The difference with Truncated Trace (Volume 5, page 301) pattern here is that in 
a truncated trace it was intended to trace certain behavior but the tracing session was 
stopped prematurely or started too late. In a missing cause trace, only a part of 
necessary activity was traced, and the missing part wasn’t thought of or considered for 
tracing. 
 
 

Software Diagnostics Training: Two Approaches    423 
Software Diagnostics Training: Two Approaches 
Doing memory dump analysis training for several years we found that students are 
divided into 2 types: those who prefer to see source code first and those who want to 
see a memory dump first. We actually prefer to show a memory dump first and then 
explore it to find certain patterns of abnormal structure and behavior. Software 
Diagnostics Services136 used this approach to design its Accelerated Windows Memory 
Dump Analysis137 and Accelerated .NET Memory Dump Analysis138 courses. Students 
explore memory dumps and debugger logs to find memory dump analysis patterns 
which are introduced when necessary. After that, they can check the source code of 
modeling applications if they have development experience. Accelerated Windows 
Software Trace Analysis139 course uses a different approach. It introduces all software 
trace analysis patterns at once because they are patterns from software narratology140 
independent from programming languages and software platforms. After that, they 
explore and analyze software traces and logs. We can summarize these 2 approaches on 
this diagram: 
                                                                 
136 http://www.patterndiagnostics.com/ 
137 http://www.patterndiagnostics.com/accelerated-windows-memory-dump-analysis 
138 http://www.patterndiagnostics.com/accelerated-net-memory-dump-analysis 
139 http://www.patterndiagnostics.com/accelerated-software-trace-analysis 
140 http://www.patterndiagnostics.com/Introduction-Software-Narratology-materials 

424    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
 
 
 

Software Disruption Patterns    425 
Software Disruption Patterns 
Space Precondition 
These are not really testing patterns but patterns of user or program behavior resulting 
in abnormalities such as colored screens (blue and grey), crash dumps and other support 
artefacts including performance alerts and UI problem patterns (page 415).  
It is often a case that a process checks for free disk space before proceeding, for 
example, with updates. This precondition may be violated by a user filling disk after the 
check but before or during installation. Such was the case with our recent Mac OS X 
update where we did some copying in the background while the update was 
downloaded that resulted in insufficient space after reboot, then a grey screen after 
that and subsequent disk corruption and finally OS reinstallation and loss of several 
hours better spent on other pattern categories. 
 
 

426    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Static Code Analysis Patterns 
Loop Construct 
Static program analysis141 is used to eliminate certain coding errors that may lead 
to abnormal software behavior. Therefore, it is naturally a part of software diagnostics 
but at source code level. Our goal here is to identify certain patterns directly linkable to 
patterns we see in memory dumps and software logs and collect them into a catalog. 
One such pattern candidate covers conditional and unconditional loops, for example, in 
one of the modern languages: 
extern bool soonToBeTrue;  
int mediumValue = ...; 
 
while (true) 
{ 
  TRACE("Waiting"); 
  sleep(mediumValue); 
  if (soonToBeTrue) 
  { 
    break; 
  } 
  doHeavyWork(); 
} 
 
while (--pControl->aFewPasses) 
{ 
  TRACE("Waiting"); 
  sleep(mediumValue); 
  doHeavyWork(); 
} 
Such loops may potentially lead to Spiking Thread (Volume 1, page 305) memory 
dump analysis and High Message Current and Statement Density (Volume 4, page 335) 
trace analysis patterns. Of course, we shouldn’t suspect every loop but only some that 
have potential to be altered by Local Buffer Overflow (Volume 1, page 460, for 
mediumValue) 
or 
Shared 
Buffer 
Overwrite 
(Volume 
5, 
page 
120, 
for 
Control.aFewPasses) or by a race condition (soonToBeTrue). 
We expect things to get more interesting when we start associating source code 
that uses certain API with patterns of abnormal behavior. 
                                                                 
141 http://en.wikipedia.org/wiki/Static_program_analysis 

The Structure of Software Problem Solving Organization    427 
The Structure of Software Problem Solving Organization 
Based on the separation of problem-solving powers we propose the following software 
problem-solving triangle with a separate software diagnostics department: 
Technical 
Support 
Department
Software 
Diagnostics 
Department
Software 
Maintenance 
Department
 
 
 

428    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Bridging the Great Divide 
In Pattern-Based Software Diagnostics142 presentation, we proposed to use pattern 
catalogs to bridge the separation of software construction and memory dump software 
diagnostics. With an introduction of Motifs (page 329) to trace and log analysis pattern 
catalog it is now possible (at least conceptually) to bridge construction and trace 
analysis too: 
Software Narremes
Implementation
Macrofunctions
Design
Motifs
Architecture
Software Trace Analysis
Software Construction
 
 
 
                                                                 
142 http://www.patterndiagnostics.com/pattern-based-diagnostics-materials 

Elementary Software Diagnostics Patterns    429 
Elementary Software Diagnostics Patterns 
These are patterns of abnormal software behavior that affect software users and trigger 
the application of pattern-oriented software diagnostics and debugging if necessary. The 
initial list of relevant elementary patterns includes: 
 
Functional  
 
 Use-case Deviation  
 
 
Non-functional  
 
 Crash  
 Hang (includes delays)  
 Counter Value (includes resource leaks, CPU spikes)  
 Error Message  
In choosing the pattern vocabulary we decided to use ordinary names, for 
example, Hang was chosen instead of Response Delay. 
 
 

430    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Zero Fault Software Diagnostics 
Software diagnostics is used whenever there is a fault that triggers some kind of an 
artifact such as a memory dump or a software trace. It is also used proactively in 
software and network monitoring. We combine all these uses with our pattern-oriented 
approach to anticipating faults before their occurrence: 
Software Trace Patterns
Memory Dump  Patterns
General Software 
Structure and Behaviour 
Pattern Catalogues
Product Vendor Problems 
Operating System Problems 
Vendor and Product 
Problem Catalogues
Live Monitoring
Pre-mortem Analysis
 
Such preventive software diagnostics consists of 4 interrelated parts: 
 
General software structure and behavior pattern catalogs  
 
Domain, vendor and product specific problem catalogues  
 
Live monitoring  
 
Pre-mortem analysis  
Pre-mortem here means preventive memory dump analysis. It is similar to post-
mortem analysis, but artifacts are collected and analyzed proactively before any actual 

Zero Fault Software Diagnostics    431 
problem. In some sense, pre-mortem analysis is a part of live monitoring but we confine 
the latter to software trace and log analysis. 
Zero Fault Software Diagnostics becomes a part of pattern-oriented Software 
Prognostics discipline. 
 

432    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Agile Software Diagnostics 
We introduce this method based on iterative and incremental pattern-oriented 
diagnostics we founded and developed during the last few years. It is currently based on 
5 principles: 
 
Patterns are the principal measure of quality  
 
Attention to detail through checklists  
 
Analysis is done by motivated expertise-driven trusted individuals 
 
Customer satisfaction by useful analysis delivered in the shortest possible 
time  
 
Analysis audit as a pair diagnostics  
 
 

ADDR Pattern Catalogue    433 
ADDR Pattern Catalogue 
In addition to existing pattern catalogs, we introduce patterns (and their schemas) of 
disassembly (decompilation), reversing and reconstruction (deconstruction). Here's the 
current list in the order of their appearance in Accelerated Disassembly, Reconstruction 
and Reversing training143: 
 
Universal Pointer 
 
Symbolic Pointer S2 
 
Interpreted Pointer S3 
 
Context Pyramid 
 
Potential Functionality 
 
Function Skeleton 
 
Function Call 
 
Call Path 
 
Local Variable 
 
Static Variable 
 
Pointer Dereference 
 
Function Prologue 
 
Function Epilogue 
 
Variable Initialization 
 
Memory Copy 
 
Call Prologue 
 
Call Parameter 
 
Call Epilogue 
 
Call Result 
 
Control Path 
 
Function Parameter 
 
Structure Field 
 
Last Call 
 
Loop 
 
Separator Frames 
 
Virtual Call 
 
Component Dependencies 
 
API Trace 
 
 
                                                                 
143 http://www.patterndiagnostics.com/Training/Accelerated-Disassembly-Reconstruction-Reversing-
Public.pdf 

434    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Thinking-Based Software Diagnostics 
This is a new type of software diagnostics in addition to pattern-oriented and systemic.  
It is based on: 
 
Critical thinking 
 
Systemic thinking 
 
Semiotic thinking 
And uses: 
 
Inductive reasoning 
 
Deductive reasoning 
 
Abductive reasoning 

Thinking-Based Software Diagnostics    435 
Critical Thinking
Systemic Thinking
Semiotic Thinking
Deductive Reasoning
Inductive Reasoning
Abductive Reasoning
Thinking-Based
Systemic
Pattern-Oriented
 
 
 

436    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Memory Acquisition Pattern Catalog 
Software: the parts of a computer that can be dumped. 
In addition to existing pattern catalogs such as for memory analysis, we introduce 
patterns of memory acquisition as a general platform and product independent, 
reusable solutions to commonly occurring memory acquisition problems applicable in 
specific contexts. Here's the current list with their classification: 
Structural Space Patterns 
 
General 
 
 State Summary Dump 
 Region Memory Dump 
 
 
Volatile 
 
 Process Memory Dump 
 Kernel memory Dump 
 Physical Memory Dump 
 Hyper Memory Dump 
 Fiber Bundle Dump 
 
 
Persistent  
 
 File Memory Dump 
 Storage Memory Dump 
Acquisition Strategy Patterns 
 External Dump 
 Self-Dump 
 Conditional Dump 
 Dump Sequence 
 
 

Trace Acquisition Pattern Catalog    437 
Trace Acquisition Pattern Catalog 
In addition to existing pattern catalogs such as for trace analysis, we introduce patterns 
of trace acquisition as a general platform and product independent, reusable solutions 
to commonly occurring tracing and logging problems applicable in specific contexts. 
Here's the current list applicable to both software and network tracing: 
 Trace Placing Map 
 Trace Timing Plan 
 Use Case Coverage 
 Supplemental System Tracing 
 Supplemental Network Tracing 
 Supplemental Memory Acquisition 
 Full Capture Tracing 
 Tuned Capture Tracing 
 First Occurrence Tracing 
 Differential Strategy Tracing 
 
 
 

438    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Patterns of Software Diagnostics Architecture 
In the Debugging TV144 episode 0x1A, we introduced a vision of software diagnostics 
architecture and its architectural patterns. The latter are usual patterns of software 
architecture if we design software diagnostics software. However, if we consider a 
software diagnostics system architecture in a wider context involving its users and 
human-assisted pattern-orientation there is a need to devise new patterns such as 
Patterns - View - Controller (PVC) where: 
Patterns - represent pattern catalogs from pattern-driven and pattern-based 
software diagnostics methodology. It corresponds to Model in the traditional Model - 
View - Controller software architecture pattern. 
View - represents pattern catalog(s) view which might include concrete pattern 
implementations such as OS and product specifics. A view can also be based on an 
intersection of several pattern catalogs, for example, memory analysis, malware 
analysis, and trace analysis. A user diagnostician sees such views. Any updates to 
underlying pattern catalogs are reflected in pattern views. 
Controller - represents software diagnostics tools architecture and designed 
using software construction patterns. Such tools may include automated diagnostics or 
human-assisted debuggers and problem analysis tools. A user diagnostician uses such 
controllers. Such use may result in updates to underlying pattern catalogs when a new 
pattern is discovered, for example. 
 
 
                                                                 
144 http://www.debugging.tv/ 

Patterns of Software Diagnostics Architecture    439 
This software diagnostics architecture pattern is illustrated in the following diagram: 
Patterns
Pattern Catalogues
View
Catalogue Views
Controller
Diagnostics Tools
Diagnostician
Sees
Uses
Updates
Updates
 
 
 

440    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Detecting and Predicting the Unknown 
A. The approach of Victimware145 (which includes abnormal behavior of Malware such 
as crashes, hangs, resource leaks, CPU spikes) together with memory, malware, and log 
analysis pattern catalogues allows detecting unknown malware in software diagnostics 
and digital forensics artefacts such as memory dumps, crash reports, and software 
traces and logs: pattern-driven software diagnostics146 and forensics147. 
B. Structural and behavioral patterns found on one operating system and/or processor 
architecture can be predicted for another: pattern-based software diagnostics148 and 
forensics. 
                                                                 
145 http://www.patterndiagnostics.com/Victimware-materials 
146 http://www.patterndiagnostics.com/Introduction-Software-Diagnostics-materials 
147 http://www.patterndiagnostics.com/pattern-oriented-software-forensics-materials 
148 http://www.patterndiagnostics.com/pattern-based-diagnostics-materials 

Detecting and Predicting the Unknown    441 
Pattern-Oriented
Software Diagnostics
Victimware
Analysis
Memory Analysis 
Pattern Catalogue
Memory Dumps
Crash Reports
Logs and Traces
Malware Analysis 
Pattern Catalogue
Windows
Linux
Mac OS X
...
x86/x64
ARM
Bytecode
...
Trace Analysis
Pattern Catalogue
 
 
 

442    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Software Diagnostics Metaphors 
Software Diagnostics as Psychology 
Analogy: studying how code construction ideas are executed 
 
Philosophy - Software Construction 
 
Psychology - Software Diagnostics 
 
Physiology - Software Execution 
Philosophy
Psychology
Physiology
Software Construction
Software Diagnostics
Software Execution
 
 
 

Software Diagnostics Metaphors    443 
Software Diagnostics as Literary Criticism 
Analogy: studying patterns across software execution artifacts such as software 
narratives (traces and logs) and memory snapshots. 
 
Writing Fiction - Software Construction 
 
Reading Fiction - Software Execution 
 
Reviewing Fiction - Traditional Software Diagnostics 
 
Literary Criticism - Pattern-Oriented Software Diagnostics 
Writing Fiction
Reviewing Fiction
Literary Criticism
Software Construction
Traditional
Software Diagnostics
Pattern-Oriented
Software Diagnostics
Reading Fiction
Software Execution
 
 
 
 
 

444    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Rapid Software Diagnostics Process (RSDP) 
Increased complexity of software incidents and their growing numbers require fast 
responses. We reviewed and partitioned our pattern catalogs into two tiers. The first 
tier requires fewer analysis efforts and provides faster response time than the second 
tier.  
First Tier Patterns
Second Tier Patterns
Diagnostics
Analysis
Level
Rapid Software Diagnostics Process
Copyright © 2014 by Software Diagnostics Institute
DumpAnalysis.org + TraceAnalysis.org
Diagnostics
Response
Time
 
 
 

Right First Time Software Diagnosis    445 
Right First Time Software Diagnosis 
It is based on pattern-oriented diagnostics process and pattern catalogs. 
aPattern
           Pattern
  
    
           Pattern    
aPattern
aPattern
Right First Time 
Software Diagnosis
 
 
 

446    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
Software Diagnosis Codes 
While working on Diagnostic Manual of Software Problems149 (DMS) we found the need 
to introduce software diagnostic codes. The proposed natural candidate schema is 
based on pattern orientation and pattern catalogs. It consists of major and minor codes. 
The major code is a combination of one letter software artifact type, three letter 
structural classifier, and 3-letter behavioral pattern classifier: 
Artifact Type - Structural Pattern - Behavioral Pattern 
For example: 
M-THR-SPK 
Memory - Thread - Spike, which corresponds to Spiking Thread (Volume 1, page 305) 
pattern from the memory analysis catalog. 
The optional minor code is not currently specified but may include pattern 
implementation such as an operating system platform including CPU architecture, for, 
example: WIN.X32 or OSX.X64. So the final code may look like: 
M-THR-SPK.WIN.X64 
 
 
                                                                 
149 http://www.dumpanalysis.org/diagnostics-manual-software-problems 

Vulnerability Analysis Patterns (VAP)    447 
Vulnerability Analysis Patterns (VAP) 
These are general patterns of software vulnerability: synthesis of analysis patterns from 
these software diagnostics catalogs: 
 
MAP  
- Memory Analysis Patterns (include behavioral and structural  
                  patterns) 
 
TAP  
- Trace Analysis Patterns 
 
CAP  
- Code Analysis Patterns (previously introduced as Static Code Analysis  
                  Patterns, page 426) 
 
ADDR  - Deconstruction, Disassembly, and Reversing (binary equivalent of  
  CAP) Patterns (the current list is available on page 433) 
Also:  
VEC  
 
- Vulnerability, Exploit, and Control of Victimware 
Victimware  
- bugs of software (including bugs of malware) +   
  vulnerabilities (provocative and precipitative victimware) 
For victimware classification, please look at this presentation: 
http://www.patterndiagnostics.com/Victimware-materials 
The following easy to remember diagram combines all these acronyms and terminology: 

448    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
V
A
P
MAP
TAP
CAP
Victimware
VEC
A
D
D
R
A
D
D
R
 
 
 

Vulnerability Analysis Patterns (VAP)    449 
Versioned Namespace 
This pattern is similar to Namespace (page 257) malware analysis pattern but covers 
victimware side. Not only some API sets seen from source code and binaries but their 
versions also have importance. Again, this proposed new catalog contains general 
analysis patterns, not specific operating system and product patterns. More patterns 
will be added later according to our pattern-based software diagnostics incremental and 
iterative methodology. 
 
 

450    PART 9: Software Diagnostics, Troubleshooting, and Debugging 
[This page is intentionally left blank] 
 
 

2012 (Pessimistic)    451 
PART 10: Art and Visualization 
2012 (Pessimistic) 
Those in the know will instantly recognize a processor timing diagram: 
 
 
 

452    PART 10: Art and Visualization 
2012 (Optimistic) 
 
 
 

A Bug in a Bag (Collections, Ex-hi-bit 1)    453 
A Bug in a Bag (Collections, Ex-hi-bit 1) 
 
 
 

454    PART 10: Art and Visualization 
A Bug Meets a Bug (The Clash of Civilizations) 
 
 
 

A Bug Catcher    455 
A Bug Catcher 
An organic creature that catches bugs: 
 
If you compare it with a 2CARE2 trademark (page 456), you would recognize A, R 
and E as Phenyl, Methyl, and Ethyl groups. 
 
 

456    PART 10: Art and Visualization 
The Second Generation of CARE System (Trademark) 
2CARE2 system (Crash Analysis Report Environment, 2nd generation) trademark 
represents client and server parts holistically as an aromatic-like compound: 
 
 
 

RawStackGram    457 
RawStackGram 
 
 
 

458    PART 10: Art and Visualization 
A Memory Window 
 
 
 

Liquid Memory    459 
Liquid Memory 
 
 
 

460    PART 10: Art and Visualization 
Computer Brain 
 
 
 

Computer Evolution    461 
Computer Evolution 
Cube -> Surface -> Point 
 
 
 

462    PART 10: Art and Visualization 
M Spaces 
This is a collage image based on colors and layout of Software Diagnostics Services 
training course logos such as Accelerated150 and Advanced151 Windows Memory Dump 
Analysis plus 8, 16, 32, and 64 pt Consolas font sizes symbolizing different memory 
pointer sizes. Colors symbolize kernel, user, managed and physical memory spaces. 
 
 
 
                                                                 
150 http://www.patterndiagnostics.com/accelerated-windows-memory-dump-analysis 
151 http://www.patterndiagnostics.com/advanced-windows-memory-dump-analysis 

Happy Hellowin!    463 
Happy Hellowin! 
A postcard for the occasion. 
 
 
 

464    PART 10: Art and Visualization 
Pointers in Nature 
 
 
 

Drink Sensibly Before The End Of The World!    465 
Drink Sensibly Before The End Of The World! 
As there was no shape for a pint in Visio, we resorted to a message box for the occasion. 
 
 
 

466    PART 10: Art and Visualization 
MM=DD=YY 
To celebrate the last unique occurrence of 12.12.12 in this Century we created a 
Computical Art (Computicart) picture that uses minimalist software trace analysis 
diagrams from trace and log analysis patterns and Accelerated Windows Software Trace 
Analysis course152. The following diagram symbolizes several patterns. Suppose we trace 
personal or world events each year and form Adjoint Thread (Volume 5, page 283) with 
messages having DD=MM=YY timestamp invariant (or filter them). Then we clearly see 
Discontinuity (Volume 4, page 341) before the next Century with much bigger Time 
Delta (Volume 5, page 282) than between such messages. Also, these messages form 
Periodic Message Block (page 300) in relation to the full trace. 
                                                                 
152 http://www.patterndiagnostics.com/accelerated-software-trace-analysis 

MM=DD=YY    467 
 
 
 

468    PART 10: Art and Visualization 
Process Monitor Log Visualized 
Whereas, when naturally visualized with Dump2Picture (Volume 1, page 532), a Citrix 
CDF trace looks like a sea with embedded library (Volume 3, page 372), a process 
monitor log looks more like a fragment from a memory dump with some large-scale 
internal structure: 
 
 
 

Process Monitor Log Visualized    469 
Its 450×1280 slice: 
 

470    PART 10: Art and Visualization 
Top and bottom of x4 magnified image: 
 
... 

Process Monitor Log Visualized    471 
 
 
 

472    PART 10: Art and Visualization 
Holes Infinity (HI OS) 
This is an operating system for inter-universe flight in the year 1000001. Simple inter-
galactic space flight was already achieved in deep past. Its operating system name was 
lost. 
 
Disclaimer: Due to so distant future no connection with existing current operating systems is assumed. 
 
 

Cyber Vostok Missions    473 
Cyber Vostok Missions 
Software Diagnostics Services153 launched its first cyber satellite to survey the state of 
cyberspace and mine its patterns. A satellite logo has a UML 2.0 interface sink similar to 
Software Diagnostics Institute logo154: 
 
 
 
                                                                 
153 http://www.patterndiagnostics.com/cybervostok 
154 http://www.dumpanalysis.org/Software-Behavior-Patterns-Headline 

474    PART 10: Art and Visualization 
A Dump Machine 
 
 
 

The Power of Simplicity    475 
The Power of Simplicity 
 
 
 

476    PART 10: Art and Visualization 
Happy St. Patrick’s Screen 
 
 
 
 

Happy New Year 2014!    477 
Happy New Year 2014! 
We break our tradition to greet in the memory dump analysis style. This New Year we 
post a software trace diagram similar to what we use to illustrate trace and log analysis 
patterns: 
                    2014
Time
                    2013
#   PID TID Time                  Message
 
 
 

478    PART 10: Art and Visualization 
I Love Software Diagnostics 
 
 
 

Puree Windows Cooking    479 
Puree Windows Cooking 
Salad Winterminal 
 

480    PART 10: Art and Visualization 
[This page is intentionally left blank] 
 
 

Puree Windows Cooking    481 
Kernel Soup 
 
 
 

482    PART 10: Art and Visualization 
Neolithic Soup 
 
 
 

Puree Windows Cooking    483 
Food Subsystems 
 
 
 

484    PART 10: Art and Visualization 
An Accident of Creation 
 
 
 

Puree Windows Cooking    485 
So Chi Salad, 2014 
 
 
 

486    PART 10: Art and Visualization 
Self-Organized Window-ed soup 
 
 
 

Political Computicarts    487 
Political Computicarts 
Needs Non-Invasive Debugging! 
 
 
 

488    PART 10: Art and Visualization 
Russian Spaces 
On interpretation of red, blue, and white: 
 
 
 

The Day I Quit    489 
The Day I Quit 
 
 
 

490    PART 10: Art and Visualization 
Hero of Dump Analysis, a Medal for Labor Day 
 
 
 

Diagnosed by Vostokov®TM    491 
Diagnosed by Vostokov®TM 
 
 
 

492    PART 10: Art and Visualization 
Stack Trace Shapes 
 

Stack Trace Shapes    493 
[This page is intentionally left blank] 
 
 

494    PART 10: Art and Visualization 
The Art of Internals 
 
 
 

Threadinking    495 
Threadinking 
 
 
 

496    PART 10: Art and Visualization 
[This page is intentionally left blank] 
 
 

C and C++ Programming Books That Made a Great Impression on the Author    497 
PART 11: Miscellaneous 
C and C++ Programming Books That Made a Great Impression on the 
Author 
There are many lists of great books, but we’d like to share the one that have a more 
personal touch. These books we wanted to read on the first sight and devoured them 
when we had an occasion. 
The first book that made a great impression on me was C Programming 
Language which we saw and read in 1987 (in Russian translation with very nice 
hardcover binding). There was a C implementation available on a PDP-11 clone we 
worked with at that time. 
Another book that reinforced our better function prototype reading and pointer 
declarations was Expert C Programming. 
We confess we had a trouble understanding C++ long back ago despite reading 
The C++ Programming Language by Bjarne Stroustrup (reading several editions) and 
Effective C++ series by Scott Meyers partly because of our long practice of Win32 
programming using C and partly because we didn’t understand why we needed C++ to 
do the same. Popular books such as C++ for Real Programmers (in Russian translation) 
terrified us with their complexity (although we made honest efforts to read them from 
cover to cover). However, when we saw and started reading the book Advanced CORBA 
Programming with C++ we really understood why we needed C++ and how it all 
worked. After that, rereading The C++ Programming Language and (More) Effective C++ 
books was a great pleasure. 
The other part of C++, STL was greatly clarified by reading the following book in 
2003 from cover to cover (at that time the first edition): The C++ Standard Library: A 
Tutorial and Reference. 
Inside the C++ Object Model book clarified C++ implementation issues and 
helped later with crash dump analysis of C++ programs. 
We plan to continue this “Great Impression” series with other topics and also to 
publish a recommended reading list for C++ based on books from our personal library 
that started growing when the author was an employee at Programming Research in 
2001 - 2003: 

498    PART 11: Miscellaneous 
 
The row of books is all about C++. Except the big thick red book about English 
language grammar (at that time we became interested in other grammars than C++): 
The Cambridge Grammar of the English Language. 
 
 

Outside    499 
Outside 
 
 
 

500    PART 11: Miscellaneous 
After Debugging 
 
 
 
 

Crash Dumps, Acquisitions, and Layoffs    501 
Crash Dumps, Acquisitions, and Layoffs 
This is a story we would like to present here. A leading debugging services company A 
was contacted by a company B to analyze dozens of crash dumps for a modest fee155. No 
NDA was signed, and the work was done promptly. Unfortunately, there was no 
response to an invoice and after some time a representative from the company A 
contacted the company B and got an immediate reply that they were bought by a 
company C. The new invoice was requested and promptly sent by the company A to the 
company C. More time passed beyond any reasonable time frame, and a representative 
from the company A contacted the company C again and didn’t get an immediate reply 
as before. After some time out of the blue came a group reply from all high execs saying 
that the modest fee cannot be paid because it had to be done by the company B that 
they bought. And by the way, all guys from the company B dealing with the company A 
were no longer with the company C. The company A pointed out that by an implicit 
agreement an act of nonpayment from the company B due to unforeseen circumstances 
automatically made all crash dumps submitted to the company A a property of the 
company A. Many would say please contact a lawyer but the modest fee doesn’t worth 
such a contact. 
 
 
 
                                                                 
155 An average one day executive salary or less. 

502    PART 11: Miscellaneous 
Cadaver Worm: An Exercise in Malware Fiction 
The discovery of a “black hole horizon” in a complete memory dump inspired this 
fictitious malware. There, in a dump, we discovered an innocuous ASCII message: 
fffff880`15925010  fffff880`159250d0 "Dumping physical memory to disk:  80% ." 
A little thought and we realized that this page was saved to a page file at the time 
when only 80% of memory was dumped. So we do not know what was in that page 
during the remaining time (and would never know). We guess that Cadaver Worms live 
there spreading from PC to PC and causing blue screens immediately upon infection to 
minimize discovery. They are not in crash dumps because they relocate themselves 
during the system dump procedure. They thaw frozen CPUs and send themselves to 
network. Who would suspect a computer showing a blue screen sending network 
packets? 

Cadaver Worm: An Exercise in Malware Fiction    503 
Memory
Already Dumped
Memory
To Be Dumped
Cadaver Worm
Dumping time
Relocation
 
 
 

504    PART 11: Miscellaneous 
WinDbg as UNICODE to ASCII Converter 
Steps: 
1. Open a crash dump or attach WinDbg to a process you can sacrifice. 
2. Enter this command: eb rsp <UNICODE STRING> [00 00] 
0: kd> eb rsp 42 00 65 00 65 00 74 00 68 00 6F 00 76 00 65 00 6E 00 3A 00 
20 00 53 00 79 00 6D 00 70 00 68 00 6F 00 6E 00 69 00 65 00 73 00 20 00 31 
00 20 00 61 00 6E 00 64 00 20 00 33 00 00 00 
Note: use esp for a 32-bit dump. Last NULL terminators 00 00 are not necessary if 
the string already has them. 
3. Enter this command: du rsp 
0: kd> du rsp 
fffff880`15925ae8  "Beethoven: Symphonies 1 and 3" 
 
 

Falsity and Coincidence Patterns    505 
Appendix 
Falsity and Coincidence Patterns 
 
False Positive Dump (Volume 1, page 259) 
 
False Function Parameters (Volume 2, page 173) 
 
False Effective Address (page 197) 
 
Coincidental Symbolic Information (Volume 1, page 390) 
 
Coincidental Frames (Volume 5, page 55) 
 
Coincidental Error Code (page 117) 
 
 

506    Appendix 
Process Patterns 
 
Virtualized Process (WOW64, Volume 1, page 400)   
 
Coupled Processes (strong, Volume 1, page 419) 
 
Coupled Processes (weak, Volume 5, page 60) 
 
Coupled Processes (semantics, Volume 5, page 87) 
 
Manual Dump (process, Volume 1, page 487) 
 
Wait Chain (process objects, Volume 5, page 49) 
 
No Process Dumps (Volume 2, page 157) 
 
Special Process (Volume 2, page 164) 
 
Zombie Processes (Volume 2, page 196) 
 
Process Factory (Volume 3, page 112) 
 
Missing Process (Volume 4, page 154) 
 
Fat Process Dump (Volume 6, page 33)  
 
Value Adding Process (page 122) 
 
Frozen Process (page 145) 
 
Hidden Process (page 156) 
 
One-Thread Process (page 187) 
 
 

Thread Patterns    507 
Thread Patterns 
 
Spiking Thread (Volume 1, page 305) 
 
Waiting Thread Time (kernel dumps, Volume 1, page 343) 
 
Waiting Thread Time (user dumps, Volume 2, page 319) 
 
Missing Thread (Volume 1, page 362) 
 
Passive Thread (user space, Volume 1, page 430) 
 
Passive System Thread (kernel space, Volume 1, page 462) 
 
Main Thread (Volume 1, page 437) 
 
Wait Chain (thread objects, Volume 3, page 92) 
 
Suspended Thread (Volume 2, page 161) 
 
Blocked Thread (software, Volume 2, page 184) 
 
Blocked Thread (hardware, Volume 5, page 79) 
 
Blocked Thread (timeout, page 110) 
 
Thread Starvation (realtime priority, Volume 2, page 274) 
 
Thread Starvation (normal priority, Volume 5, page 85) 
 
Affine Thread (Volume 2, page 314) 
 
CLR Thread (Volume 4, page 163) 
 
Thread Age (Volume 6, page 111) 
 
Special Thread (.NET CLR, Volume 6, page 123) 
 
No Current Thread (page 124) 
 
Active Thread (page 236) 
 
One-Thread Process (page 187) 
 
Thread Cluster (page 195) 
 
 

508    Appendix 
Optimization Patterns 
 
Optimized Code (Volume 1, page 265) 
 
OMAP Code Optimization (Volume 1, page 294) 
 
Optimized VM Layout (Volume 2, page 267) 
 
Inline Function Optimization (unmanaged code, Volume 2, page 322) 
 
Inline Function Optimization (managed code, Volume 6, page 155) 
 
False Function Parameters (Volume 2, page 173) 
 
Hidden Parameter (page 67) 
 
 

Exception Patterns    509 
Exception Patterns 
 
Multiple Exceptions (user mode, Volume 1, page 255) 
 
Multiple Exceptions (kernel mode, Volume 3, page 78)  
 
Multiple Exceptions (managed space, Volume 6, page 104)  
 
Hidden Exception (user space, Volume 1, page 271)  
 
Hidden Exception (kernel space, page 140)  
 
Managed Code Exception (Volume 1, page 331) 
 
Custom Exception Handler (user space, Volume 1, page 471)  
 
Custom Exception Handler (kernel space, Volume 6, page 94)  
 
Nested Exceptions (unmanaged code, Volume 2, page 305)  
 
Nested Exceptions (managed code, Volume 2, page 310)  
 
C++ Exception (Volume 3, page 84) 
 
Mixed Exception (Volume 4, page 145) 
 
Exception Stack Trace (Volume 5, page 93) 
 
Invalid Exception Information (Volume 5, page 116) 
 
Problem Exception Handler (Volume 5, page 126) 
 
Handled Exception (user space, Volume 6, page 141)  
 
Handled Exception (.NET CLR, Volume 6, page 144)  
 
Handled Exception (kernel space, page 141)  
 
FPU Exception (page 65) 
 
Translated Exception (page 107) 
 
Stored Exception (page 119) 
 
 
 

510    Appendix 
Module Patterns 
 
Duplicated Module (Volume 2, page 294)  
 
Unloaded Module (page 126) 
 
Module Variety (Volume 1, page 310) 
 
Hidden Module (Volume 2, page 339) 
 
Template Module (Volume 5, page 112) 
 
Well-Tested Module (Volume 6, page 48) 
 
Blocking Module (Volume 6, page 54) 
 
Top Module (Volume 6, page 62) 
 
Directing Module (Volume 6, page 80) 
 
Module Hint (Volume 6, page 92) 
 
Coupled Modules (Volume 6, page 114)  
 
Problem Module (page 85) 
 
Unknown Component (Volume 1, page 367) 
 
No Component Symbols (Volume 1, page 298) 
 
Missing Component (general, Volume 2, page 233)  
 
Missing Component (static linking, user mode, Volume 2, page 283)  
 
Ubiquitous Component (Volume 4, page 94) 
 
Nested Offender (Volume 4, page 120) 
 
Effect Component (Volume 4, page 137) 
 
Deviant Module (page 133) 
 
Module Collection (page 162) 
 
Module Product Process (page 189) 
 
Module Collection (predicate, page 196) 
 
 
 

RPC, LPC and ALPC Patterns and Case Studies    511 
RPC, LPC and ALPC Patterns and Case Studies 
The following patterns and case studies may help in an analysis of (A)LPC wait chains 
and the output of !lpc and !alpc WinDbg commands from the kernel and complete 
memory dumps. 
Patterns: 
 
LPC Deadlock (Volume 1, page 474) 
 
LPC Wait Chain (Volume 3, page 97) 
 
Paged Out Data (Volume 3, page 118) 
 
Process Object Wait Chain (+ ALPC, Volume 5, page 49)  
 
Blocked Queue (ALPC, Volume 6, page 34)  
 
Semantic Structures (ALPC, Volume 6, page 73)  
 
RPC Wait Chain (+ how to distinguish between LPC and RPC, Volume 5, page 
95)  
 
Screwbolt Wait Chain (page 198) 
 
 

512    Appendix 
LPC case studies: 
 
Blocked GUI Thread, Wait Chain and Virtualized Process (Volume 3, page 170) 
 
Insufficient Memory, Handle Leak, Wait Chain, Deadlock, Inconsistent Dump 
and Overaged System (Volume 3, page 175) 
 
Coupled Processes, Wait chains, Message Box, Waiting Thread Time, Paged Out 
Data, Incorrect Stack Trace, Hidden Exception, Unknown Component and 
Execution Residue (Volume 3, page 228) 
 
Inconsistent Dump, Blocked Threads, Wait Chains, Incorrect Stack Trace and 
Process Factory (Volume 3, page 279) 
 
Stack Trace Collection, Suspended Threads, Not My Version, Special Process, 
Main Thread and Blocked LPC Chain Threads (Volume 4, page 204) 
 
Stack Trace Collection, Missing Threads, Waiting Time, Critical Section and LPC 
Wait Chains (Volume 4, page 226)  
 
Inconsistent Dump, Stack Trace Collection, LPC, Thread, Process, Executive 
Resource Wait Chains, Missing Threads and Waiting Thread Time (Volume 5, 
page 133) 
 
Stack Trace Collection, Special Process, LPC and Critical Section Wait Chains, 
Blocked Thread, Coupled Machines, Thread Waiting Time and IRP Distribution 
Anomaly (Volume 5, page 188) 
ALPC case studies: 
 
ALPC Wait Chain, Missing Threads, Message Box, Zombie and Special Processes 
(Volume 4, page 214) 
 
ALPC Wait Chains, Missing Threads, Waiting Thread Time and Semantic Process 
Coupling (Volume 5, page 200) 
RPC target:  
In Search of Lost CID (Volume 2, page 136) 
 
 

ERESOURCE Patterns and Case Studies    513 
ERESOURCE Patterns and Case Studies 
These patterns and case studies may help in an analysis of the output of !locks WinDbg 
command from the kernel and complete memory dumps. 
Patterns: 
 
_ERESOURCE Deadlock (Volume 1, page 323) 
 
Mixed Object Deadlock (Volume 1, page 348) 
 
High Contention (Volume 1, page 421 ) 
 
Accidental Lock (Volume 1, page 423) 
 
_ERESOURCE Wait Chain (Volume 2, page 147) 
 
Swarm of Shared Locks (Volume 3, page 107) 
 
Semantic Split (Volume 3, page 120) 
 
Livelock (Volume 6, page 70) 
 
 

514    Appendix 
Case studies: 
 
Multiple Patterns (Volume 2, page 50) 
 
Common Mistakes: Not Looking at All Stack Traces (Volume 3, page 24) 
 
Wait Chain and Spiking Thread (Volume 3, page 167) 
 
Insufficient Memory, Handle Leak, Process Factory, High Contention and Busy 
System (Volume 3, page 209) 
 
Busy System, Blocked Threads, Wait Chains and Deadlock (Volume 3, page 215) 
 
Wait Chain, Blocked Thread, Waiting Thread Time, IRP Distribution Anomaly 
and Stack Trace Collection (Volume 4, page 231) 
 
Inconsistent Dump, Stack Trace Collection, LPC, Thread, Process, Executive 
Resource Wait Chains, Missing Threads and Waiting Thread Time (Volume 5, 
page 133) 
 
Succession of Patterns (Volume 5, page 43) 
 
 

Meta-Memory Dump Patterns    515 
Meta-Memory Dump Patterns 
 
False Positive Dump (Volume 1, page 259) 
 
Inconsistent Dump (Volume 1, page 269) 
 
Truncated Dump (Volume 1, page 340) 
 
Early Crash Dump (Volume 1, page 466) 
 
Manual Dump (kernel, Volume 1, page 480)  
 
Manual Dump (process, Volume 1, page 487)  
 
Corrupt Dump (Volume 2, page 151) 
 
No Process Dumps (Volume 2, page 157) 
 
No System Dumps (Volume 2, page 158) 
 
Self-Dump (Volume 2, page 181) 
 
Abridged Dump (Volume 5, page 88) 
 
Fat Process Dump (Volume 6, page 33) 
 
Unsynchronized Dumps (Volume 6, page 113) 
 
Quiet Dump (Volume 6, page 109) 
 
Late Crash Dump (page 109) 
 
 

516    Appendix 
Crash Dump Analysis Checklist 
General: 
 
Symbol servers (.symfix) 
 
Internal database(s) search 
 
Google or Microsoft search for suspected components as this could be a known 
issue. Sometimes a simple search immediately points to the fix on a vendor’s 
site 
 
The tool used to save a dump (to flag false positive, incomplete or inconsistent 
dumps) 
 
OS/SP version (version) 
 
Language 
 
Debug time 
 
System uptime 
 
Computer name (dS srv!srvcomputername or !envvar COMPUTERNAME) 
 
List of loaded and unloaded modules (lmv or !dlls) 
 
Hardware configuration (!sysinfo) 
 
.kframes 1000 
Application or service: 
 
Default analysis (!analyze -v or !analyze -v -hang for hangs) 
 
Critical sections (!cs -s -l -o, !locks) for both crashes and hangs 
 
Component timestamps, duplication and paths. DLL Hell? (lmv and !dlls) 
 
Do any newer components exist? 
 
Process threads (~*kv or !uniqstack) for multiple exceptions and blocking 
functions 
 
Process uptime 
 
Your components on the full raw stack of the problem thread 
 
Your components on the full raw stack of the main application thread 
 
Process size 
 
Number of threads 
 
Gflags value (!gflag) 
 
Time consumed by threads (!runaway) 
 
Environment (!peb) 
 
Import table (!dh) 
 
Hooked functions (!chkimg) 
 
Exception handlers (!exchain) 
 
Computer name (!envvar COMPUTERNAME) 
 
Process heap stats and validation (!heap -s, !heap -s -v) 

Crash Dump Analysis Checklist    517 
 
CLR threads? (mscorwks or clr modules on stack traces) Yes: use .NET checklist 
below 
 
Hidden (unhandled and handled) exceptions on thread raw stacks  
System hang: 
 
Default analysis (!analyze -v -hang) 
 
ERESOURCE contention (!locks) 
 
Processes and virtual memory including session space (!vm 4) 
 
Important services are present and not hanging (for example, terminal or IMA 
services for Citrix environments) 
 
Pools (!poolused) 
 
Waiting threads (!stacks) 
 
Critical system queues (!exqueue f) 
 
I/O (!irpfind) 
 
The list of all thread stack traces (!process 0 3f) 
 
LPC/ALPC chain for suspected threads (!lpc message or !alpc /m after search for 
"Waiting for reply to LPC" or "Waiting for reply to ALPC" in !process 0 3f output) 
 
Mutants (search for "Mutants - owning thread" in !process 0 3f output) 
 
Critical sections for suspected processes (!cs -l -o -s) 
 
Sessions, session processes (!session, !sprocess) 
 
Processes (size, handle table size) (!process 0 0) 
 
Running threads (!running) 
 
Ready threads (!ready) 
 
DPC queues (!dpcs) 
 
The list of APCs (!apc) 
 
Internal queued spinlocks (!qlocks) 
 
Computer name (dS srv!srvcomputername) 
 
File cache, VACB (!filecache) 
 
File objects for blocked thread IRPs (!irp -> !fileobj) 
 
Network (!ndiskd.miniports and !ndiskd.pktpools) 
 
Disk (!scsikd.classext -> !scsikd.classext class_device 2) 
BSOD: 
 
Default analysis (!analyze -v) 
 
Pool address (!pool) 
 
Component timestamps (lmv) 
 
Processes and virtual memory (!vm 4) 
 
Current threads on other processors 
 
Raw stack 
 
Bugcheck description (including ln exception address for corrupt or truncated 
dumps) 

518    Appendix 
 
Bugcheck callback data (!bugdump for systems prior to Windows XP SP1) 
 
Bugcheck secondary callback data (.enumtag) 
 
Computer name (dS srv!srvcomputername) 
 
Hardware configuration (!sysinfo) 
.NET application or service: 
 
CLR module and SOS extension versions (lmv and .chain) 
 
Managed exceptions (~*e !pe) 
 
Nested managed exceptions (!pe -nested) 
 
Managed threads (!Threads -special) 
 
Managed stack traces (~*e !CLRStack) 
 
Managed execution residue (~*e !DumpStackObjects and !DumpRuntimeTypes) 
 
Managed heap (!VerifyHeap, !DumpHeap -stat and !eeheap -gc) 
 
GC handles (!GCHandles, !GCHandleLeaks) 
 
Finalizer queue (!FinalizeQueue) 
 
Sync blocks (!syncblk)  
 

    519 
Index of WinDbg Commands 
  
!address, 54, 111, 112, 113, 115, 117, 118, 
125, 133, 137, 202, 377, 378 
!alpc, 51, 511, 517 
!analyze, 27, 38, 167, 516, 517 
!bugdump, 518 
!chkimg, 240, 253, 516 
!CLRStack, 518 
!cs, 52, 183, 516, 517 
!dd, 69, 70 
!dh, 133, 137, 138, 166, 243, 248, 516 
!dlls, 516 
!dpcs, 108, 517 
!DumpHeap, 518 
!DumpRuntimeTypes, 518 
!DumpStackObjects, 518 
!eeheap, 518 
!envvar, 516 
!error, 66 
!exchain, 516 
!exqueue, 517 
!filecache, 517 
!fileobj, 517 
!FinalizeQueue, 518 
!for_each_module, 92, 240, 242 
!for_each_process, 85 
!for_each_thread, 32, 34, 37, 163, 168 
!GCHandleLeaks, 518 
!GCHandles, 518 
!gflag, 54, 516 
!handle, 191, 192 
!heap, 29, 115, 117, 516 
!irp, 44, 45, 517 
!irpfind, 45, 101, 517 
!k, 31 
!lmi, 77, 78, 117, 118, 189, 243 
!locks, 38, 513, 516, 517 
!lpc, 511, 517 
!ndiskd.miniport, 83 
!ndiskd.miniports, 83, 517 
!ndiskd.pktpools, 82, 517 
!object, 95, 96, 246 
!pe, 518 
!peb, 242, 516 
!pool, 517 
!poolfind, 123, 156, 168 
!poolused, 123, 164, 172, 517 
!process, 38, 50, 69, 77, 85, 97, 123, 146, 
152, 153, 154, 156, 164, 168, 169, 187, 
356, 517 
!pte, 74, 75 
!ptov, 70, 71, 72 
!qlocks, 517 
!ready, 517 
!reg, 93 
!runaway, 32, 38, 132, 142, 237, 416, 516 
!running, 38, 120, 517 
!scsikd.classext, 158, 159, 517 
!session, 49, 150, 172, 517 
!sprocess, 49, 122, 145, 150, 151, 517 
!stacks, 184, 517 
!sw, 31 
!syncblk, 144, 518 
!sysinfo, 516, 518 
!teb, 86, 107 
!thread, 32, 34, 37, 51, 108, 120, 121, 140 
!Threads, 518 
!token, 161 
!uniqstack, 516 
!VerifyHeap, 518 
!vm, 85, 90, 96, 98, 99, 168, 172, 517 
.chain, 518 
.cxr, 27, 52, 53, 65, 67, 79, 80, 81, 128, 129, 
140, 153, 197, 240 
.echo, 32 
.ecxr, 27, 28, 119 
.effmach, 31, 153, 163 
.enumtag, 518 
.exr, 66, 119, 125 
.imgscan, 133, 166 
.kframes, 516 

520    Index of WinDbg Commands 
.load, 31, 153, 158, 162, 163 
.process, 52, 74, 76, 85, 153, 182 
.reload, 80, 114, 162, 163, 176, 202 
.symfix, 114, 516 
.sympath+, 80, 176 
.thread, 27, 37, 52, 53, 67, 79, 80, 81, 129, 
153, 162, 163, 183, 240 
~, 28, 38, 60, 109, 124, 126, 142, 191, 202, 
204, 516, 518 
~*k, 28, 109, 126, 142, 202 
~*kv, 38, 516 
Checklist, 516 
d*, 38 
dc, 56, 168, 174 
dd, 69, 117, 129 
dp, 29, 98, 118, 129, 191, 377 
dps, 37, 65, 86, 107, 138, 140, 144 
dpu, 68, 417 
dS, 99, 516, 517, 518 
dt, 43, 60, 61, 62, 93, 95, 145, 146, 158, 
174, 177 
du, 504 
eb, 504 
g, 39, 40, 41, 115, 183, 202, 213, 385 
k, 52, 53, 59, 89, 115, 124, 144, 153, 180, 
202, 240, 244, 415, 416 
kc, 190 
kL, 27, 39, 40, 67, 79, 80, 81, 86 
kv, 60, 128, 129, 174, 176, 191, 202 
kvL, 110 
lm, 85, 175, 176, 252 
lmp, 240 
lmu, 85, 162 
lmv, 38, 77, 78, 79, 117, 118, 127, 133, 139, 
162, 189, 242, 417, 516, 517, 518 
ln, 117, 118, 130, 517 
rMF, 66 
u, 48, 98, 117, 143, 154, 202, 253 
ub, 67, 129, 141, 193, 201, 202 
 
 

    521 
About the Author 
Dmitry Vostokov is an internationally recognized 
expert, speaker, educator, scientist and author. 
He is the founder of pattern-oriented software 
diagnostics, forensics and prognostics discipline, 
and Software Diagnostics Institute (DA+TA: 
DumpAnalysis.org + TraceAnalysis.org). Vostokov 
has also authored more than 30 books on 
software diagnostics, forensics, and problem-
solving, memory dump analysis, debugging, 
software 
trace 
and 
log 
analysis, 
reverse 
engineering, and malware analysis. He has more 
than 20 years of experience in software 
architecture, design, development and maintenance in a variety of industries including 
leadership, technical and people management roles. Dmitry also founded OpenTask 
Iterative and Incremental Publishing (OpenTask.com), Software Diagnostics Services 
(former Memory Dump Analysis Services) PatternDiagnostics.com and Software 
Prognostics. In his spare time, he presents various topics on Debugging.TV and explores 
Software Narratology, an applied science of software stories that he pioneered. 

522    Notes 
Notes 
 

    523 
Cover Images 
Back cover features a "liquid memory" image created with Photoshop from contents of 
computer memory. 

