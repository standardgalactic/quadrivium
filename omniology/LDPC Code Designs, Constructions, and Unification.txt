Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
LDPC CODE DESIGNS, CONSTRUCTIONS,
AND UNIFICATION
Written by leading experts, this self-contained text provides systematic coverage
of low-density parity-check (LDPC) codes and their construction techniques,
unifying both algebraic- and graph-based approaches into a single theoretical
framework (the superposition construction). An algebraic method for constructing
protograph LDPC codes is described, and entirely new codes and techniques are
presented. These include a new class of LDPC codes with doubly quasi-cyclic
structure, as well as algebraic methods for constructing spatially and globally
coupled LDPC codes.
Authoritative, yet written using accessible language, this is essential reading
for electrical engineers, computer scientists, and mathematicians working in
communications and information theory.
J UA N E L I is a postdoctoral researcher in the Department of Electrical and
Computer Engineering at the University of California, Davis. Her current research
interests are channel coding for communications and storage systems, and
hardware implementation of encoders and decoders for LDPC codes.
S H U L I N is an Adjunct Professor in the Department of Electrical and Computer
Engineering at the University of California, Davis, and an IEEE Life Fellow. He
is the co-author of Channel Codes: Classical and Modern (Cambridge, 2009) and
Error Control Coding: Fundamentals and Applications (2nd ed., Prentice Hall,
2004).
K H A L E D
A B D E L- G H A FFA R is a Professor of Electrical and Computer
Engineering at the University of California, Davis. He has held research positions
at the IBM Almaden Research Center, Delft University of Technology, and the
University of Bergen.
W I L L I A M E. RYA N is an IEEE Fellow and currently works for Zeta Associates,
USA. He was previously a Professor at New Mexico State University and the
University of Arizona. He is the co-author of the book Channel Codes: Classical
and Modern (Cambridge, 2009).
DA N I E L
J. C O S T E L L O, J R. is the Leonard Bettex Professor Emeritus of
Electrical Engineering at the University of Notre Dame, Indiana, and an IEEE
Fellow. He is the co-author of the textbook Error Control Coding: Fundamentals
and Applications (2nd ed., Prentice Hall, 2004).

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
“This book provides an in-depth survey of recently developed quasi-cyclic LDPC
codes. It is a treasured reference on practical channel coding methods for both
theorists and practitioners working in communications and information theory.”
Lara Dolecek, University of California, Los Angeles
“The importance of LDPC codes in numerous applications and their capacity-
approaching performance has led to an explosion in research into their construction
and analysis over the past decade. The numerous effective constructions of them
can be broadly classiﬁed as algebraic and graphical, including the important
superposition, protograph, and spatial coupling techniques.
This timely volume explains, uniﬁes, and greatly clariﬁes these diverse approaches
and lays a solid foundation that will be invaluable to researchers, practitioners, and
students alike.”
Ian F. Blake, University of British Columbia
“A book from the leaders in the ﬁeld of error-correcting codes. Superposition –
a uniﬁed framework for low-density parity check code construction – makes a
description of codes of various classes rather simple.”
Bane Vasic, University of Arizona, Tucson

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
LDPC CODE DESIGNS,
CONSTRUCTIONS, AND
UNIFICATION
JUANE LI
University of California, Davis
SHU LIN
University of California, Davis
KHALED ABDEL-GHAFFAR
University of California, Davis
WILLIAM E. RYAN
Zeta Associates, Colorado
DANIEL J. COSTELLO, JR.
University of Notre Dame, Indiana

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
University Printing House, Cambridge CB2 8BS, United Kingdom
Cambridge University Press is part of the University of Cambridge.
It furthers the University’s mission by disseminating knowledge in the pursuit of
education, learning, and research at the highest international levels of excellence.
www.cambridge.org
Information on this title: www.cambridge.org/9781107175686
10.1017/9781316780152
c⃝Cambridge University Press 2017
This publication is in copyright. Subject to statutory exception
and to the provisions of relevant collective licensing agreements,
no reproduction of any part may take place without the written
permission of Cambridge University Press.
First published 2017
Printed in the United Kingdom by TJ International Ltd. Padstow Cornwall
A catalog record for this publication is available from the British Library.
Library of Congress Cataloging-in-Publication Data
Names: Li, Juane, author.
Title: LDPC code designs, constructions, and uniﬁcation / Juane Li,
University of California, Davis [and 4 others].
Other titles: Low-density parity-check code designs,
constructions, and uniﬁcation
Description: New York : Cambridge University Press, 2017. |
Includes bibliographical references and index.
Identiﬁers: LCCN 2016032809 | ISBN 9781107175686 (hardback)
Subjects: LCSH: Error-correcting codes (Information theory) | Coding theory.
Classiﬁcation: LCC QA268 .L53 2017 | DDC 005.7/17–dc23
LC record available at https://lccn.loc.gov/2016032809
ISBN 978-1-107-17568-6 Hardback
Cambridge University Press has no responsibility for the persistence or accuracy of
URLs for external or third-party internet websites referred to in this publication
and does not guarantee that any content on such websites is, or will remain,
accurate or appropriate.

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
Contents
Preface
page viii
1 Introduction
1
2 Deﬁnitions, Concepts, and Fundamental
Characteristics of LDPC Codes
6
2.1
Matrices and Matrix Dispersions of Finite Field Elements
6
2.2
Fundamental Structural Properties and Performance
Characteristics of LDPC Codes
8
2.3
Discussion and Remarks
14
3 A Review of PTG-Based Construction of LDPC Codes
16
3.1
PTG-LDPC Code Construction
16
3.2
Conclusion and Remarks
20
4 An Algebraic Method for Constructing
QC-PTG-LDPC Codes and Code Ensembles
21
4.1
Construction of QC-PTG-LDPC Codes by Decomposing
Base Matrices
21
4.2
Construction of RC-Constrained PTG Parity-Check Matrices
26
4.3
Examples
28
4.4
Construction of the Ensemble of PTG-LDPC Codes from an
Algebraic Point of View
38
4.5
Discussion and Remarks
40
5 Superposition Construction of LDPC Codes
41
5.1
SP-Construction of LDPC Codes and Its Graphical Interpretation
41
5.2
Ensembles of SP-LDPC Codes
43
5.3
Constraints on the Construction of SP-LDPC Codes Free of
Cycles of Length 4
44
5.4
SP-Construction of QC-LDPC Codes
48
v

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
vi
Contents
5.5
SP-Base Matrices over Nonnegative Integers
49
5.6
Discussion and Remarks
50
6 Construction of Base Matrices and RC-Constrained Replacement
Sets for SP-Construction
51
6.1
RC-Constrained Base Matrices
51
6.2
Construction of RC-Constrained Replacement Sets Based
on Hamming Codes
53
6.3
Construction of RC-Constrained Replacement Sets Based on
m-dimensional Euclidean Geometry EG(m,2) over GF(2)
59
6.4
Construction of RC-Constrained Replacement Sets Based on
RC-Constrained Arrays of CPMs
62
6.5
Discussion and Remarks
69
7 SP-Construction of QC-LDPC Codes Using Matrix
Dispersion and Masking
72
7.1
A Deterministic SP-Construction of QC-LDPC Codes
72
7.2
Conditions on Girth of CPM-QC-SP-LDPC Codes
73
7.3
A Finite Field Construction of 2 × 2 SM-Constrained SP-Base
Matrices and Their Associated CPM-QC-SP-LDPC Codes
74
7.4
Masking
77
7.5
Design of Masking Matrices
84
7.6
Construction of CPM-QC-SP-LDPC Codes for Correcting
Bursts of Erasures by Masking
92
7.7
Discussion and Remarks
95
8 Doubly QC-LDPC Codes
98
8.1
Base Matrices with Cyclic Structure
98
8.2
CPM-D-SP-Construction of Doubly QC-LDPC Codes
100
8.3
Masking and Variations
104
8.4
SP-Construction of CPM-QC-SP-LDPC Codes
108
8.5
Discussion and Remarks
108
9 SP-Construction of Spatially Coupled
QC-LDPC Codes
111
9.1
Base Matrices and Their Structural Properties
112
9.2
Type-1 QC-SC-LDPC Codes
114
9.3
Type-2 QC-SC-LDPC Codes
120
9.4
Terminated and Tailbiting CPM-QC-SC-LDPC Codes
123
9.5
A More General Construction of Type-1 CPM-QC-SC-LDPC Codes
129
9.6
A More General Construction of Type-2 CPM-QC-SC-LDPC Codes
134
9.7
Discussion and Remarks
135

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
Contents
vii
10 Globally Coupled QC-LDPC Codes
138
10.1 Construction of CN-Based QC-GC-LDPC Codes: Method-1
138
10.2 A Local/Global Two-Phase Decoding of CN-Based
CPM-QC-GC-LDPC Codes
146
10.3 Construction of CN-Based GC-LDPC Codes: Method-2
149
10.4 CPM-Dispersion Construction of CN-Based Product
QC-GC-LDPC Codes
154
10.5 Discussion and Remarks
162
11 SP-Construction of Nonbinary LDPC Codes
166
11.1 General SP-Construction of NB LDPC Codes Using Binary
Base Matrices
166
11.2 SP-Construction of NB QC-LDPC Codes
167
11.3 Construction of NB QC-SP-LDPC Codes Using q-ary
CPM-Dispersion
173
11.4 CPM-D Construction of NB CPM-QC-SP-LDPC Codes Using
Binary-to-Nonbinary Replacement
175
11.5 Algebraic Construction of NB QC-PTG-LDPC Codes
182
11.6 Construction of NB LDPC Codes from Reed–Solomon Codes
193
11.7 Construction of NB QC-SP-LDPC Codes based on RS Codes
197
11.8 Discussion and Remarks
205
12 Conclusion and Remarks
209
Appendices
215
A RC-Constrained Arrays of CPMs Constructed
Based on Partial Geometries
217
A.1
RC-Constrained Arrays of CPMs Constructed Based on
Two-Dimensional Euclidean Geometries over Finite Fields
218
A.2
RC-Constrained Arrays of CPMs Based on Partial Geometries
Constructed from Prime Fields
223
B An Algorithm for Searching Compatible Masking and
Base Matrices for the CPM-Dispersion Construction of
QC-LDPC Codes
225
C Iterative Decoding Algorithm for NB LDPC Codes
228
C.1
Introduction
228
C.2
Algorithm Derivation
229
C.3
The NB LDPC Decoding Algorithm
235
References
237
Index
244

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
Preface
Error control codes protect the accuracy of data in modern information sys-
tems, including computing, communication, and storage systems. Low-density
parity-check (LDPC) codes and their relatives represent the state of the art in
error control coding and are renowned for their ability to perform close to
the theoretical limits. This book presents recent results on various LDPC code
designs, making strong connections between two prominent design approaches,
the algebraic-based and the graph-theoretic-based constructions. New codes and
code construction techniques are presented.
Most methods for constructing LDPC codes can be classiﬁed into two general
categories, the algebraic-based and the graph-theoretic-based constructions. The
two best-known graph-theoretic-based construction methods are the progressive
edge-growth (PEG) and the protograph-based (PTG-based) methods, devised in
2001 and 2003, respectively. Both of these techniques involve computer-aided
design. One of the earliest algebraic-based methods for constructing LDPC codes
is the superposition (SP) construction, proposed in 2002. In this book, the
algebraic-based construction method is re-interpreted from both the algebraic and
the graph-theoretic perspectives. From the algebraic point of view, it is shown that
the SP-construction of LDPC codes includes, as special cases, most of the major
algebraic construction methods developed since 2002. From the graph-theoretic
point of view, it is shown that the SP-construction also includes the PTG-based
construction as a special case. Based on this PTG/SP connection, an algebraic
method is developed here to construct PTG-based LDPC codes.
There are advantages to putting the algebraic-based and the PTG-based
constructions into a single framework, the SP framework. One advantage is that
SP descriptions of codes tend to be relatively compact, enabling simple code
speciﬁcations in standards and textbooks. Another advantage to studying LDPC
codes under the SP framework is that students and practitioners need only learn
viii

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Frontmatter
More Information
www.cambridge.org
© in this web service Cambridge University Press
Preface
ix
a single code design approach rather than the myriad approaches that exist in the
published literature.
Both binary and nonbinary code constructions will be presented under the SP
framework. The SP-construction also leads to a new class of LDPC codes with a
doubly quasi-cyclic (QC) structure as well as algebraic methods for constructing
spatially and globally coupled LDPC codes. The globally coupled codes will be
shown to possess a highly effective burst-erasure correction capability.
A good number of new LDPC codes are constructed and simulated over the
binary-input additive white Gaussian noise channel and the binary erasure channel.
This book will open the door for readers to understand many topics in modern
LDPC codes that are scattered in the literature. It is intended as a self-study
guide for students, researchers, and engineers interested in LDPC codes and their
variations. The book explains the different design methodologies in detail and
provides an ample number of code constructions along with simulations. The book
shows that code design and construction are more of an art rather than science.
Hopefully, after reading this book, the reader may gain enough artistic experience
to produce codes that not only meet required speciﬁcations but also improve upon
those reported here. To make the material widely accessible, the authors have
kept the presentation as clear as possible and assumed only basic knowledge of
terminology and results that are commonly covered in textbooks on coding theory.
Acknowledgment
This book is the climax of more than ﬁfteen years of work on LDPC codes by
graduate students of the last four authors. In particular, the second and third
authors would like to thank Drs. Lei Chen, Qiuju Diao, Ivana Djurdjevic, Qin
Huang, Jingyu Kang, Yu Kou, Lan Lan, Keke Liu, Shumei Song, Ying Yu Tai,
Heng Tang, Jun Xu, Lingqi Zeng, Li Zhang, and Bo Zhou. Each of them spent
thousands of hours investigating choices of code parameters in order to optimize
performance. We are also grateful to the federal agencies NASA and NSF and
to the industrial support from Cadence, Denali Software, Intel, LSI, Northrop
Grumman Space Technology, and San Disk. Many thanks to Dr. Julie Lancashire at
Cambridge University Press for her constant encouragement to write this book. We
also acknowledge Ms. Isabella Yeh, whose painting on the front cover was created
speciﬁcally for this book. Finally, the ﬁrst author would like to thank her father
and mother for their love, and the last four authors would like to thank their wives
for their patience and understanding. To the six of them, this work is dedicated.

Preface
Error control codes protect the accuracy of data in modern information sys-
tems, including computing, communication, and storage systems. Low-density
parity-check (LDPC) codes and their relatives represent the state of the art in
error control coding and are renowned for their ability to perform close to
the theoretical limits. This book presents recent results on various LDPC code
designs, making strong connections between two prominent design approaches,
the algebraic-based and the graph-theoretic-based constructions. New codes and
code construction techniques are presented.
Most methods for constructing LDPC codes can be classiﬁed into two general
categories, the algebraic-based and the graph-theoretic-based constructions. The
two best-known graph-theoretic-based construction methods are the progressive
edge-growth (PEG) and the protograph-based (PTG-based) methods, devised in
2001 and 2003, respectively. Both of these techniques involve computer-aided
design. One of the earliest algebraic-based methods for constructing LDPC codes
is the superposition (SP) construction, proposed in 2002. In this book, the
algebraic-based construction method is re-interpreted from both the algebraic and
the graph-theoretic perspectives. From the algebraic point of view, it is shown that
the SP-construction of LDPC codes includes, as special cases, most of the major
algebraic construction methods developed since 2002. From the graph-theoretic
point of view, it is shown that the SP-construction also includes the PTG-based
construction as a special case. Based on this PTG/SP connection, an algebraic
method is developed here to construct PTG-based LDPC codes.
There are advantages to putting the algebraic-based and the PTG-based
constructions into a single framework, the SP framework. One advantage is that
SP descriptions of codes tend to be relatively compact, enabling simple code
speciﬁcations in standards and textbooks. Another advantage to studying LDPC
codes under the SP framework is that students and practitioners need only learn
viii
01
12:22:22, subject to the Cambridge Core terms of use,

Preface
ix
a single code design approach rather than the myriad approaches that exist in the
published literature.
Both binary and nonbinary code constructions will be presented under the SP
framework. The SP-construction also leads to a new class of LDPC codes with a
doubly quasi-cyclic (QC) structure as well as algebraic methods for constructing
spatially and globally coupled LDPC codes. The globally coupled codes will be
shown to possess a highly effective burst-erasure correction capability.
A good number of new LDPC codes are constructed and simulated over the
binary-input additive white Gaussian noise channel and the binary erasure channel.
This book will open the door for readers to understand many topics in modern
LDPC codes that are scattered in the literature. It is intended as a self-study
guide for students, researchers, and engineers interested in LDPC codes and their
variations. The book explains the different design methodologies in detail and
provides an ample number of code constructions along with simulations. The book
shows that code design and construction are more of an art rather than science.
Hopefully, after reading this book, the reader may gain enough artistic experience
to produce codes that not only meet required speciﬁcations but also improve upon
those reported here. To make the material widely accessible, the authors have
kept the presentation as clear as possible and assumed only basic knowledge of
terminology and results that are commonly covered in textbooks on coding theory.
Acknowledgment
This book is the climax of more than ﬁfteen years of work on LDPC codes by
graduate students of the last four authors. In particular, the second and third
authors would like to thank Drs. Lei Chen, Qiuju Diao, Ivana Djurdjevic, Qin
Huang, Jingyu Kang, Yu Kou, Lan Lan, Keke Liu, Shumei Song, Ying Yu Tai,
Heng Tang, Jun Xu, Lingqi Zeng, Li Zhang, and Bo Zhou. Each of them spent
thousands of hours investigating choices of code parameters in order to optimize
performance. We are also grateful to the federal agencies NASA and NSF and
to the industrial support from Cadence, Denali Software, Intel, LSI, Northrop
Grumman Space Technology, and San Disk. Many thanks to Dr. Julie Lancashire at
Cambridge University Press for her constant encouragement to write this book. We
also acknowledge Ms. Isabella Yeh, whose painting on the front cover was created
speciﬁcally for this book. Finally, the ﬁrst author would like to thank her father
and mother for their love, and the last four authors would like to thank their wives
for their patience and understanding. To the six of them, this work is dedicated.
01
12:22:22, subject to the Cambridge Core terms of use,

01
12:22:22, subject to the Cambridge Core terms of use,

1
Introduction
The ever-growing need for cheaper, faster, and more reliable communication
and storage systems has forced many researchers to seek means to attain the
ultimate limits on reliable information transmission and storage. Low-density
parity-check (LDPC) codes are currently the most promising coding technique
to achieve the channel capacities (or Shannon limits) for a wide range of
channels. Discovered by Gallager in 1962 [40], these codes were rediscovered
in the late 1990s [83, 81]. Ever since their rediscovery, a great deal of research
effort has been expended in design, construction, encoding, decoding algorithms,
structural analysis, performance analysis, generalizations, and applications of
these remarkable codes. Many LDPC codes have been adopted as standard codes
for various current and next-generation communication systems, such as wireless,
optical, satellite, space, digital video broadcast (DVB), multi-media broadcast
(MMB) systems, and others. Applications to high-density data storage systems,
such as ﬂash memories, are now being seriously investigated. In fact, they appear
in some recent data storage products. This rapid dominance of LDPC codes
in applications is due to their capacity-approaching performance, which can be
achieved with practically implementable iterative decoding algorithms. More
applications of these codes are expected to come and their future is promising.
However, further research is needed to better understand the structural properties
and performance characteristics of these codes.
Most methods to construct LDPC codes can be classiﬁed into two general cat-
egories: graph-theoretic-based and algebraic-based (or matrix-theoretic-based)
methods. The best-known graph-theoretic-based construction methods are the
progressive edge-growth (PEG) [43, 44] and the protograph (PTG) based methods
[105]. The algebraic-based methods for constructing LDPC codes were ﬁrst
introduced in 2000 [56, 55, 38, 57]. Since then, various algebraic methods for
constructing LDPC codes, binary and nonbinary, have been developed using
mathematical tools such as ﬁnite geometries, ﬁnite ﬁelds, and combinatorial
1
02
12:23:43, subject to the Cambridge Core terms of use,

2
1 Introduction
designs [58, 76, 110, 109, 35, 107, 3, 19, 39, 74, 111, 102, 101, 112, 64,
65, 116, 97, 100, 50, 99, 113, 114, 25, 46, 26, 70, 68, 77, 78]. Most of
the algebraic constructions have several important ingredients including base
matrices, matrix dispersion (or matrix expansion), and masking. By a proper
choice and combination of these ingredients, algebraic LDPC codes with excellent
overall error performance can be constructed. Algebraic LDPC codes have, in
general, much lower error-ﬂoors than randomly constructed LDPC codes. For
example, algebraic LDPC codes have been recently reported that can achieve a
decoded bit error rate as low as 10−15 without visible error-ﬂoors over the additive
white Gaussian noise channel (AWGNC) [70, 68, 77, 78].
One of the earliest algebraic-based methods proposed for constructing LDPC
codes is the SP-construction (also called the hybrid construction). This speciﬁc and
very ﬂexible algebraic-based method for constructing LDPC codes was devised in
2002 [76]. Since then, several other powerful algebraic-based methods have been
proposed. These methods basically evolved from the SP-construction method,
although the connection went unnoticed.
The SP-construction method presented in [76] starts with a small base matrix B
and a set R of sparse matrices of the same size, not necessarily square. Then,
each nonzero entry in B is replaced by a member matrix in R following certain
replacement rules (or constraints) [76, 110, 109, 111, 97] and each zero entry is
replaced by a zero matrix (ZM) of the same size as that of a member matrix in R.
The replacement operation expands the base matrix B into an array H of sparse
matrices in R and/or ZMs. The null space of H gives an LDPC code, called an
SP-LDPC code. We refer to this matrix replacement of a nonzero entry in B as
superposition. The matrices in R are called member (or constituent) matrices and
the set R is called the replacement set. In [110], the structural properties of the
Tanner graph [103] associated with the array H was investigated. It was shown
that the Tanner graph associated with the array H is an expansion of the Tanner
graph associated with the base matrix B.
The PTG-based method for constructing LDPC codes was introduced by Thorpe
in 2003 [105]. This method was devised to construct the Tanner graph of an LDPC
code of large size using a relatively small well-designed bipartite graph, called
a protograph, as the base graph. In the construction, the ﬁrst step is to choose a
protograph with a near-capacity iterative decoding threshold [80, 34] as a building
block (or as a base). The second step is to create copies of the chosen protograph.
The third step is to permute the edges of the copies according to certain rules to
connect them into a Tanner graph of larger size. The null space of the adjacency
matrix of the resultant Tanner graph gives an LDPC code, called a PTG-based
LDPC code (or PTG-LDPC code). The second and third steps of the construction
together form a graph expansion process. Since the introduction of this graphical
02
12:23:43, subject to the Cambridge Core terms of use,

1 Introduction
3
method for constructing LDPC codes, it has been extensively investigated over
the last 12 years [105, 80, 34, 30, 31, 32, 33, 1, 11, 2, 88, 85] (see also their
references). Impressive theoretical results (in terms of code ensemble properties)
have been developed [34, 31, 1, 2, 85] and many PTG-LDPC codes with good error
performance have been constructed. Most recently, a new class of LDPC codes has
emerged, called spatially coupled LDPC codes, that has attracted a great amount
of research enthusiasm and may be regarded as an evolution of PTG-LDPC codes
from the graph-theoretical point of view.
From the above brief descriptions of the PTG-based and the SP-based methods
of LDPC code construction, we can see that both methods have two key
ingredients, a base and an expansion of the base. If we interpret these two
construction methods from the same point of view, either from the graph-theoretic
point of view or from the algebraic point of view, we see that they are closely
related, i.e., there is a strong connection between the SP-construction and the
PTG-based construction.
In this book, we view the SP-based and PTG-based constructions from a broader
perspective and interpret them from both the algebraic (or matrix-theoretic) and
the graph-theoretic points of view. From the algebraic point of view, we show
that the SP-construction of LDPC codes includes, as special cases, many of the
algebraic construction methods developed since 2002. From the graph-theoretic
point of view, we show that the PTG-based construction of LDPC codes is a special
case of the SP-construction. Furthermore, we develop an algebraic method for
constructing PTG-LDPC codes.
We note that, while SP-LDPC codes contain PTG-LDPC codes as special
cases from both the graph-theoretic and the matrix-theoretic points of view,
their design approaches have historically been very different. SP-LDPC codes
(and their relatives) have been designed using algebraic approaches with an eye
toward very low decoding error-ﬂoors and highly structured (lower-complexity)
decoders. By contrast, PTG-LDPC codes have a long history of being designed
by searching “good” ensembles and choosing codes from the ensembles. An
ensemble is considered to be good in the sense of decoding threshold [80, 34] or
minimum distance [31, 32, 1]. Whether or not these ensemble approaches can be
extended to SP-LDPC codes which are not PTG-LDPC codes will require further
research.
Also in this book, we unify all the major algebraic methods for constructing
LDPC codes based on matrix dispersions of base matrices under a single
framework in terms of the SP-construction. We also introduce a new class of LDPC
code with a doubly QC structure as well as algebraic methods for constructing
spatially coupled (SC) and globally coupled (GC) LDPC codes. The constructions
of these codes are also special cases of the SP-construction.
02
12:23:43, subject to the Cambridge Core terms of use,

4
1 Introduction
Although the focus of this book is on binary LDPC codes, all the developments,
interpretations, and constructions presented for binary LDPC codes can be
generalized to their nonbinary (NB) counterparts.
The rest of this book is organized as follows. Chapter 2 gives some deﬁnitions
and basic concepts of matrices and introduces some fundamental structural
properties and performance characteristics of LDPC codes which will be used in
the later chapters. In Chapter 3, we give a brief review of the PTG-based method
for constructing binary LDPC codes from the conventional graph-theoretic point
of view. In Chapter 4, an algebraic method for constructing binary PTG-LDPC
codes is presented. In Chapter 5, we ﬁrst present the SP-construction of LDPC
codes from a broader perspective than that given in [76, 109, 111]. Then, we give
a graph-theoretic interpretation of the SP-construction of LDPC codes and show
that the PTG-based construction is actually a special case of the SP-construction.
Chapter 6 presents various constructions of base matrices and replacement sets
for the SP-construction of LDPC codes. Chapter 7 presents a special type of the
SP-method for constructing QC-LDPC codes. This construction method, called
matrix dispersion, is based on dispersing (or expanding) the nonzero entries of
an algebraically constructed base matrix over a ﬁnite ﬁeld into circulants of the
same size. We also give the necessary and sufﬁcient conditions on a base matrix to
ensure that the dispersion results in a Tanner graph with girth at least 6 or at least 8.
This chapter basically puts all the major algebraic methods for constructing LDPC
codes under the framework of the SP-construction. In Chapter 8, a class of LDPC
codes with a doubly QC-structure is given. Chapter 9 presents algebraic methods
for constructing spatially coupled (SC) QC-LDPC codes, both terminated and not
terminated.
In Chapter 10, a new type of LDPC code, called the GC-LDPC code, is
presented. Two speciﬁc methods for constructing this new type of code are
presented. The ﬁrst method is devised based on cyclic base arrays of matrices
over NB ﬁelds. The second method is based on the direct product of two LDPC
codes. We show that GC-LDPC codes in product form are effective at correcting
erasures clustered in bursts. Also presented in this chapter is a reduced-complexity
local/global two-phase iterative decoding scheme for GC-LDPC codes, which
allows correction of local as well as global random errors and erasures. Chapter 11
generalizes the SP-construction of binary LDPC codes to construct NB LDPC
codes. Several effective methods for constructing NB LDPC codes are presented.
Chapter 12 concludes the book with some remarks on possible future research.
Throughout the book, examples of constructing LDPC codes and their error
performance over the AWGNC and the binary erasure channel (BEC) are
02
12:23:43, subject to the Cambridge Core terms of use,

1 Introduction
5
presented. Also, at the end of each chapter, there is a discussion on some related
or unsolved issues and possible research directions.
Furthermore, three appendices are included at the end of the book. In
Appendix A, two classes of arrays of circulant permutation matrices constructed
based on two types of ﬁnite geometries are given. These arrays can be used to
construct base matrices and replacement sets of matrices for the SP-construction
of LDPC codes. They can also be used to construct well performing LDPC codes
directly. Appendix B gives an algorithm for searching compatible masking and
base matrices for the construction of QC-LDPC codes. Appendix C presents an
iterative algorithm for decoding NB LDPC codes.
02
12:23:43, subject to the Cambridge Core terms of use,

2
Deﬁnitions, Concepts, and Fundamental
Characteristics of LDPC Codes
In this chapter, we ﬁrst present some deﬁnitions and concepts of matri-
ces which are relevant for later developments of various algebraic-based and
graph-theoretic-based constructions of LDPC codes. Then, we give a brief presen-
tation of LDPC codes and characterize their fundamental structural properties that
affect their error performance over the AWGNC and the BEC. Good coverage of
the fundamentals of LDPC codes and the major iterative algorithms for decoding
these codes can be found in [74, 97, 95].
2.1 Matrices and Matrix Dispersions of Finite Field Elements
Let GF(q) be a ﬁnite ﬁeld with q elements, where q is a power of a prime [73].
GF(q) is called a NB ﬁeld if q  2 and a binary ﬁeld if q = 2. A matrix A is
said to be regular if every row has the same weight, called the row weight, every
column has the same weight, called the column weight, and the row weight equals
the column weight. If the row weight (or column weight) of a regular matrix A
is w, we say that A has weight w and call it a weight-w regular matrix. For w  0,
a weight-w regular matrix must be a square matrix. A binary weight-1 regular
matrix is a permutation matrix (PM). It is clear that a weight-w regular matrix
is the sum of w disjoint PMs. More generally, a rectangular matrix with constant
column weight wc and constant row weight wr is said to be (wc,wr)-regular.
A square matrix over GF(q) is called a circulant if every row of the matrix is
the cyclic-shift of the row above it one place to the right, and the top row is the
cyclic-shift of the last row one place to the right. It is clear that a circulant is a
regular matrix whose weight equals the weight of its top row. The top row of a
circulant is called the generator of the circulant. A binary circulant of weight 1 is
a binary circulant permutation matrix (CPM). It is clear that a weight-w circulant
is the sum of w disjoint CPMs.
6
03
12:24:29, subject to the Cambridge Core terms of use,

2.1 Matrices and Matrix Dispersions
7
Two different matrices of the same size are said to be mutually disjoint if there is
no common location where they both have nonzero entries, i.e., the set of locations
with nonzero entries in one matrix and the set of locations with nonzero entries
in the other matrix are disjoint. It is clear that the sum of two mutually disjoint
k × k regular matrices of weights w1 and w2 is a k × k regular matrix of weight
w1 + w2.
A matrix over GF(q) for which no two columns (or two rows) have more
than one location where they both have nonzero entries is said to satisfy the
row-column (RC) constraint. Such a matrix is called an RC-constrained matrix.
For an RC-constrained matrix, every 2 × 2 submatrix contains at least one zero
entry. The Tanner graph [103] of an RC-constrained matrix has a girth of at least 6
[58, 76, 109, 74, 111, 64, 26]. Two RC-constrained matrices A and B of the same
size are said to satisfy the pair-wise (PW) RC-constraint if the matrix formed by
A and B arranged either in a row-block [A B] or in a column-block [AT BT ]T
satisﬁes the RC-constraint. Clearly, all the different binary CPMs of the same
size satisfy the PW-RC-constraint. Let A, B, and C be three PW-RC-constrained
matrices of the same size. Suppose we form a 2 × 2 array with A, B, C, and a ZM
of the same size as the constituent matrices. Then the array, as a matrix, satisﬁes
the RC-constraint.
Let H be an array of matrices of the same size. Suppose all the constituent
matrices of H satisfy the RC-constraint and any two constituent matrices in
a row-block (or a column-block) of H satisfy the PW-RC-constraint. If any
2 × 2 subarray of H satisﬁes the RC-constraint or contains at least one ZM,
then H satisﬁes the RC-constraint. This simply follows from the RC- and the
PW-RC-constrained structures of the constituent matrices of H. An array H is
referred to as a 2 × 2 RC-constrained array if any 2 × 2 subarray of H satisﬁes
the RC-constraint. RC-constrained matrices or arrays play an important role in the
construction of LDPC codes and their error performance. In designing an array H,
the constraint that requires any 2 × 2 subarray of H to satisfy the RC-constraint or
to contain at least one ZM is referred to as the 2 × 2 array RC-constraint.
Hereafter, for a k × t matrix A over GF(q), we label its rows and columns from
0 to k −1 and 0 to t −1, respectively, and express the matrix in the form of A =
[ai, j]0≤i<k,0≤j<t, where ai, j is the entry at location (i, j), the intersection of the
i-th row and the j-th column of the matrix.
In many constructions of binary QC LDPC codes, a nonzero element in GF(q)
is represented by a binary CPM. Let α be a primitive element of GF(q). Then, the
powers of α (α0 = 1,α,α2,...,αq−2) give all the nonzero elements of GF(q).
Commonly, the 0-element of GF(q) is represented by α−∞, i.e., 0 = α−∞.
For 0 ≤j < q −1, we represent the element α j by a binary CPM, denoted
by A(α j), of size (q −1) × (q −1), whose generator has the unit-element
03
12:24:29, subject to the Cambridge Core terms of use,

8
2 Deﬁnitions, Concepts, and Characteristics
“1” of GF(q) as its single nonzero component at position j. It is clear that the
representation of the element α j by the binary CPM A(α j) of size (q −1)×(q −1)
is unique and the mapping between α j and A(α j) is one-to-one. This matrix
representation of α j is referred to as the binary CPM-dispersion of α j. Note that
the size of the binary CPM A(α j) is the order of α. The 0-element of GF(q) is
represented by a (q −1) × (q −1) ZM.
Let β be a nonzero element in GF(q) of order k, where k is a proper factor of
q −1. The k elements β0 = 1,β,β2,...,βk−1 form a cyclic subgroup of GF(q)
[73]. For 0 ≤j < k, we can represent the element β j by a binary CPM A(β j)
of size k × k whose generator has its single nonzero component at location j.
Clearly, the mapping between β j and A(β j) for 0 ≤j < k is one-to-one. In this
case, we disperse an element of a cyclic subgroup of GF(q) into a binary CPM of
smaller size.
Suppose GF(q)\{0} is a cyclic subgroup of a larger ﬁeld GF(q′), i.e., GF(q) is
a subﬁeld of GF(q′). Let ζ be a primitive element GF(q′). Then, an element ω in
GF(q)\{0} can be expressed as a power of ζ, say ω = ζ ℓ, with 0 ≤ℓ< q′ −1.
With respect to the larger ﬁeld GF(q′), we can disperse ω into a binary CPM A(ω)
of size (q′ −1) × (q′ −1) whose generator has its single nonzero component at
location ℓ. Again, the mapping between ω and A(ω) is one-to-one. In this case, an
element of GF(q) is dispersed into a binary CPM of larger size.
The above simply shows that an element of a ﬁeld GF(q) can be one-to-one
dispersed into a CPM of size equal to, smaller than, or larger than q −1. This
one-to-one CPM-dispersion of a ﬁeld element will be used in the QC-LDPC code
constructions presented in later chapters.
2.2 Fundamental Structural Properties and Performance
Characteristics of LDPC Codes
An LDPC code over a ﬁnite ﬁeld GF(q) is a q-ary linear block code given by the
null space of a sparse parity-check matrix H over GF(q). An LDPC code is said
to be regular if its parity-check matrix H has constant column weight, say γ , and
constant row weight, say ρ. Such an LDPC code is said to be (γ,ρ)-regular. If the
columns and/or rows of the parity-check matrix H have multiple weights, then the
null space of the parity-check matrix H gives an irregular LDPC code.
If H is an array of sparse circulants of the same size over GF(q), then the null
space over GF(q) of the parity-check array H gives a q-ary QC-LDPC code. If
H consists of a single sparse circulant or a column of sparse circulants, then its
null space gives a cyclic LDPC code. For q = 2, the null space of H over GF(2)
gives a binary LDPC code.
03
12:24:29, subject to the Cambridge Core terms of use,

2.2 Structures and Performance Characteristics
9
An LDPC code C is commonly represented by a special graph for decoding,
design of decoding algorithms, code performance analysis, and code design.
Suppose the parity-check matrix H of the LDPC code C is an m × n matrix over
GF(q):
H =
⎡
⎢⎢⎢⎣
h0,0
h0,1
···
h0,n−1
h1,0
h1,1
···
h1,n−1
...
...
...
...
hm−1,0
hm−1,1
···
hm−1,n−1
⎤
⎥⎥⎥⎦.
(2.1)
Consider a graph G = (V,C,E) that consists of two sets of nodes, V =
{v0,v1,...,vn−1} and C = {c0,c1,...,cm−1}, and a set of edges E = {( j,i)}. The
n nodes in V represent the columns of the parity-check matrix H, called variable
nodes (VNs). The m nodes in C represent the rows of H, called check nodes (CNs).
VNs can only connect to CNs and vice versa. Therefore, G is a bipartite graph. The
VN v j is connected to the CN ci by an edge ( j,i) if and only if the entry hi, j at
the intersection of the i-th row and the j-th column of H is a nonzero element in
GF(q), say β. Such an edge is labeled with β. For the binary ﬁeld GF(2), the edges
in G are not labeled; an edge connecting VN v j and CN ci simply implies hi, j = 1.
Note that a VN and a CN in G are either not connected or connected by one and
only one edge, i.e., no parallel edges in G.
The bipartite graph G constructed above is a graphical representation of the
parity-check matrix H of the LDPC code C. Conversely, the parity-check matrix
H of the LDPC code is the adjacency matrix of the graph G. Since the LDPC
code C is the null space of H, the n VNs actually represent the n code symbols
of a codeword in C and the m CNs represent the m parity-check constraints
that the code symbols must satisfy. Hence, the bipartite graph G is a graphical
representation of the LDPC code C and is called the Tanner graph [103] of the
code (or the Tanner graph associated with the parity-check matrix H).
The performance of an LDPC code decoded using iterative decoding algorithms
based on belief propagation (BP), such as the sum-product algorithm (SPA) [81,
74, 97], the min-sum algorithm (MSA) [18, 74, 97], or their simpliﬁed variations
[74, 97], very much depends on several important structural properties of its Tanner
graph collectively. In the following, we describe these structural properties.
The number of edges that are incident with a VN v j (or CN ci) in the Tanner
graph G of an LDPC code is called the degree of v j (or ci). Following from the
construction of G, it is clear that the degree of a VN v j equals the weight of the j-th
column of H and the degree of ci equals the weight of the i-th row of H. A path in
G is deﬁned as an alternating sequence of nodes and edges, beginning and ending
with nodes, such that each edge is incident with nodes preceding and following
03
12:24:29, subject to the Cambridge Core terms of use,

10
2 Deﬁnitions, Concepts, and Characteristics
it, and no node appears more than once except possibly for the ﬁrst and the last
nodes. The number of edges on a path is called the length of the path. A closed
path that begins and ends at the same node is called a cycle. A cycle in G contains
an even number of edges, i.e., the length of a cycle in G is even. Since a VN and a
CN in G are connected by at most one edge, G contains no cycle of length 2. The
length of the shortest cycles in G is called the girth of the graph.
The Tanner graph G of an LDPC code C with girth g may contain many cycles of
lengths equal to or larger than g. The numbers of cycles of various lengths (g,g +
2,g + 4,...) in G are referred to as the cycle distribution of G. If the parity-check
matrix H satisﬁes the RC-constraint as deﬁned in Section 2.1, then the Tanner
graph G of the code C contains no cycle of length 4 and its girth is at least 6
[58, 76, 109, 74, 111, 64, 26, 97].
Let γi denote the fraction of VNs in G with degree i and dv denote the maximum
VN degree. Then, the polynomial
γ (X) =
dv

i=1
γi Xi−1
is called the degree distribution of VNs in G [96, 74, 97]. Let ρi denote the fraction
of CNs in G with degree i and dc denote the maximum CN degree. Then, the
polynomial
ρ(X) =
dc

i=1
ρi Xi−1
is called the degree distribution of CNs in G [96, 74, 97]. For a regular LDPC code,
all the VNs in G have the same degree and all the CNs in G have the same degree. It
follows from the correspondence between the degree of a VN (or CN) in G and the
weight of its corresponding column (or row) of H that γ (X) and ρ(X) also give
the column and row weight distributions of the adjacency matrix H of the graph G.
Example 2.1. Consider a binary (10,5) linear LDPC block code which is given
by the null space of the following 5 × 10 parity-check matrix H over GF(2):
H =
⎡
⎢⎣
1
1
1
1
0
0
0
0
0
0
1
0
0
0
1
1
1
0
0
0
0
1
0
0
1
0
0
1
1
0
0
0
1
0
0
1
0
1
0
1
0
0
0
1
0
0
1
0
1
1
⎤
⎥⎦.
(2.2)
H has constant column weight 2 and constant row weight 4. By checking, we
ﬁnd that H satisﬁes the RC-constraint. The Tanner graph G associated with H is
shown in Fig. 2.1. Since H satisﬁes the RC-constraint, G contains no cycle of
length 4 and hence its girth is at least 6. In fact, its girth is exactly 6. A cycle of
03
12:24:29, subject to the Cambridge Core terms of use,

2.2 Structures and Performance Characteristics
11
Figure 2.1. The Tanner graph G of the (10,5) linear LDPC block code given in
Example 2.1.
length 6 is displayed by the bold line in Fig. 2.1. Moreover, this LDPC code has
the following degree distribution polynomials: γ (X) = X, ρ(X) = X3.
In the Tanner graph G of an LDPC code C, a VN may be connected to other
VNs by paths of length 2. Given a VN v j in a Tanner graph G, the number of
VNs that connect to the VN v j by paths of length 2 is deﬁned as the connection
number of the VN v j. The connection numbers of VNs in the Tanner graph G
give a measurement of the connectivity of G. If the parity-check matrix H of the
LDPC code C has constant column weight and row weight, all the VNs in the
Tanner graph G of C have the same connection number; otherwise, they have
multiple connection numbers. By checking the Tanner graph shown in Fig. 2.1,
we ﬁnd that the connection number of each VN is 6 since the parity-check matrix
H given by (2.1) is RC-constrained and has constant column weight 2 and constant
row weight 4. The connection numbers of VNs in a Tanner graph G give the
VN-connection distribution of G. The VN-connection distribution of the Tanner
graph G in Fig. 2.1 is (6,6,6,6,6,6,6,6,6,6).
Another important structural property of the Tanner graph G of an LDPC code
given by the null space of an m × n parity-check matrix H is the trapping set
structure [94]. For 1 ≤κ ≤n and 0 ≤τ ≤m, a (κ,τ) trapping set of G is a subset
T of VNs with |T| = κ such that the subgraph of G induced by the set T, denoted
by G[T], has exactly τ odd degree CNs (and an arbitrary number of even degree
CNs), where κ is referred to as the size of the trapping set. A trapping set is said
to be elementary if all the associated CNs in G[T] have degree 1 or 2. A trapping
set is called small if κ ≤√n and τ/κ ≤4 [62].
Let Vs be a set of VNs in G and Cs be a set of CNs in G that are adjacent to the
VNs in Vs, i.e., each CN in Cs is connected to at least one VN in Vs. The CNs in
Cs are called the neighbors of the VNs in Vs. The set Vs of VNs in G is called a
stopping set [24] of G if each CN in Cs is connected to at least two VNs in Vs.
In many cases, the parity-check matrix H of an LDPC code C contains
redundant rows, i.e., the number of rows of H is greater than its rank. These
redundant rows result in redundant CNs in the Tanner graph G of the code.
03
12:24:29, subject to the Cambridge Core terms of use,

12
2 Deﬁnitions, Concepts, and Characteristics
They are either added by design to enhance the performance of the code or they
come naturally by the construction of the parity-check matrix H. In general, a
parity-check matrix constructed based on a ﬁnite geometry or a ﬁnite ﬁeld has a
large row-redundancy (CN-redundancy) [58, 46, 28], as a consequence of its highly
structured properties.
Numerous studies of LDPC codes since their rediscovery in the late 1990s show
that the error performance of an LDPC code over the AWGNC decoded with
an iterative BP-decoding algorithm very much depends on the girth, the cycle
distribution, the degree distributions of VNs and CNs, the VN-connectivity, the
CN-redundancy, the trapping set structure of the Tanner graph G, and the minimum
distance of the code collectively. No one of these structural characteristics
dominates the performance of all LDPC codes, although one characteristic might
be responsible for the performance of a single code. For example, for an LDPC
code to perform well over the AWGNC decoded with an iterative BP-decoding
algorithm, the girth of its Tanner graph must be at least 6. As an another example,
the performance of an LDPC code over the BEC very much depends on the
stopping set structure and the minimum distance of the code. Studies of these
structural properties of the Tanner graph can be found in [103, 46, 28, 77, 56,
24, 63, 94] (and in their references).
LDPC codes perform amazingly well with an iterative BP-decoding algorithm,
such as the SPA or the MSA. However, with iterative decoding, most LDPC codes
have a common severe weakness, known as error-ﬂoor [94]. The error-ﬂoor of an
LDPC code is characterized by the phenomenon that as the signal-to-noise ratio
(SNR) continues to increase, the error probability suddenly decreases at a much
slower rate than that in the region of low to moderate SNRs. A high error-ﬂoor may
preclude LDPC codes from applications where very low error rates are required.
For low error rate applications such as high-speed optical communication and data
storage, the LDPC code (and decoder) must be designed to achieve the required
error probability without an error-ﬂoor.
The overall performance of an LDPC code decoded with an iterative BP-decoding
algorithm is in general measured by: (1) the decoded error probability (bit, symbol,
or block), (2) the error-ﬂoor, and (3) the rate of decoding convergence. In the code
design, it is desirable to achieve a good balance among these three performance
measurements.
With iterative BP-decoding, the decoded error probability performance of an
LDPC code is in general judged by how close the code performs to the Shannon
limit, the decoding threshold, or the sphere packing bound (SPB). The error
probability performance, especially in the region of low to moderate SNRs, is
mainly determined by the girth, the cycle distribution, and the VN and CN degree
distributions of the Tanner graph of the code. The girth g needs to be reasonably
03
12:24:29, subject to the Cambridge Core terms of use,

2.2 Structures and Performance Characteristics
13
large (at least 6) and the numbers of cycles of lengths g, g + 2, g + 4 (called short
cycles) should be small. The VN and CN degree distributions should be designed to
make the error probability performance of the code close to the decoding threshold
or the Shannon limit, especially for an irregular LDPC code.
The rate of decoding convergence is measured by how fast the decoding of an
LDPC code converges to its performance limit, i.e., how many decoding iterations
are needed. Fast decoding convergence reduces computational complexity, power
consumption, and decoding delay. Fast decoding convergence is required for very
high-speed communication and high-density storage systems. The rate of decoding
convergence of an LDPC code very much depends on the VN-connectivity and
the CN-redundancy of its Tanner graph. For an LDPC code with high-degree
VN-connectivity, each VN is connected to a large number of other VNs with
paths of length 2. Hence, in each decoding iteration, each VN receives extrinsic
information from many other VNs. As a result, in a few iterations, each VN
message processing unit (VN-MPU) collects enough extrinsic information to
update its log-likelihood ratio (LLR) to a level sufﬁcient to make a correct hard
decision with high probability.
The error-ﬂoor of an LDPC code on the AWGNC is a measure of how
low an error probability the code can achieve. It is mostly determined by the
trapping set structure of the Tanner graph and the minimum distance of the
code. A trapping set simply corresponds to an error pattern that prevents the
iterative LDPC code decoder from converging. The most harmful trapping sets
are small trapping sets (corresponding to error patterns with small numbers of
errors) because they are more probable. If a code has a reasonably large minimum
distance and its Tanner graph contains no trapping sets with sizes smaller than
its minimum distance, the code will have a low error-ﬂoor. The CN-redundancy
(or row-redundancy of the parity-check matrix of the code) can also push the
error-ﬂoor down. Designing codes to avoid harmful trapping sets to mitigate
the error-ﬂoor is a challenging combinatorial problem. High error-ﬂoors most
commonly occur for random or pseudo random LDPC codes constructed by
computer search. LDPC codes constructed using algebraic methods in general
have much lower error-ﬂoors. It has been proved that Tanner graphs of several
subclasses of algebraic-based LDPC codes do not contain harmful trapping sets
with sizes smaller than their minimum distances (which are in general reasonably
large) [46, 28, 77]. The error-ﬂoor of an LDPC code can be lowered by taking a
decoder based strategy to remove or reduce the effect of harmful trapping sets.
Several such decoder based strategies have been proposed, such as the prior-
and the post-processing decoding strategies [41, 115, 90, 91, 108, 51]. Among
them, the most effective decoding strategy is the backtracking iterative decoding
algorithm [51].
03
12:24:29, subject to the Cambridge Core terms of use,

14
2 Deﬁnitions, Concepts, and Characteristics
How to design LDPC codes with good waterfall error performance, very low
error-ﬂoor, and fast rate of decoding convergence without excessive decoding
complexity is a hard and challenging problem. The design techniques in this book
represent some very effective solutions to this problem.
2.3 Discussion and Remarks
In this chapter, we merely presented some important structural properties and
characteristics of an LDPC code that affect the performance of the code decoded
with an iterative BP-decoding algorithm. The major objectives of this book are to
bring two major categories of LDPC code constructions, the algebraic-based and
the PTG-based, together under a single framework, namely the superposition, and
to present new designs and constructions of SP-LDPC codes for both the AWGNC
and the BEC. Since the focus is on the design of LDPC codes, we will not discuss
various iterative BP-decoding algorithms and schemes for these codes in this book.
Presentations of major iterative BP-decoding algorithms and schemes can be found
in [74, 97, 95, 81, 18].
In the following, we will give some discussion and remarks about the structural
properties presented in Section 2.2 based on our observation, analysis, and
experimental results over the last 15 years. First, to the best of our knowledge,
VN-connectivity and its impact on the rate of decoding convergence were never
discussed before in the public literature on LDPC codes. It is a dominant structural
property for fast decoding convergence of long and high-rate LDPC codes, as
will be shown in examples given in later chapters. However, high degrees of
VN-connectivity have a disadvantage. In decoder hardware implementation, high
degrees of VN-connectivity require more wires for message passing between the
VN-MPUs and the CN-MPUs and a larger memory for storing messages. In
practical applications, a trade-off between the rate of decoding convergence and
the decoder complexity is needed.
A large girth in general gives good error performance of an LDPC code in the
waterfall region. However, a large girth does not necessarily guarantee a good
error-ﬂoor performance. In fact, a large girth may result in a high error-ﬂoor if
a code lacks other good structural properties. Many experimental results show
that if an LDPC code has high degrees of VN-connectivity, large CN-redundancy,
and no small trapping sets, a girth of 6 is sufﬁcient to give a good overall
performance in terms of error probability, error-ﬂoor performance, and rate of
decoding convergence, as will be shown by examples in later chapters.
To achieve a low error-ﬂoor, the parity-check matrix of an LDPC code in
general requires a column weight (or an average column weight) of at least 3.
03
12:24:29, subject to the Cambridge Core terms of use,

2.3 Discussion and Remarks
15
For an RC-constrained LDPC code, the larger the column weight the lower the
error-ﬂoor. To achieve a bit error rate/probability of 10−15 without a visible
error-ﬂoor, a column weight of 6 is needed. A large column weight also allows
an RC-constrained LDPC code to perform hard-decision one-step majority-logic
decoding [74, 97] to correct residue errors after a few decoding iterations. This
may also bring the iterative decoding process to a quick conclusion. However, a
large column weight has a disadvantage. It in general pushes the error performance
of a code away from the Shannon limit or the decoding threshold, and also
increases the decoder complexity. In the code design, the choice of column weight
(column weight distribution) depends on the required error rate (or the location of
error-ﬂoor).
Finite geometry (FG) codes [58, 74, 97] form an amazing class of structured
LDPC codes. They are cyclic and hence can be encoded easily with simple
feedback registers. They have large minimum distances, no trapping sets with size
smaller than their minimum distances, high degrees of VN-connectivity, and large
helpful CN-redundancy [58, 46, 28]. With all these good structural properties,
FG-LDPC codes give good overall performance in terms of error probability,
error-ﬂoor, and rate of decoding convergence. However, the major disadvantage
of these codes is the high decoder complexity. Recently, two reduced-complexity
iterative schemes for decoding QC-LDPC codes were reported [79, 69, 68, 78].
These two decoding schemes signiﬁcantly reduce the decoder complexity. Since
an FG-LDPC code is cyclic and can be arranged in QC-form [46], these two
decoding schemes can be applied to decode an FG-LDPC code to reduce its
decoder complexity signiﬁcantly.
Two special classes of ﬁnite geometries and their associated LDPC codes will
be discussed in Appendix A.
03
12:24:29, subject to the Cambridge Core terms of use,

3
A Review of PTG-Based Construction
of LDPC Codes
In this chapter, we give a review of the PTG-based construction of binary LDPC
codes from the conventional graph-theoretic point of view. The objective of
this review is to provide a background to develop a method for constructing
PTG-LDPC codes from an algebraic point of view and to relate the PTG-based
construction to the SP-construction of LDPC codes.
3.1 PTG-LDPC Code Construction
The PTG-based construction of LDPC codes was introduced by Thorpe in 2003
[105]. The construction consists of 3 steps. Step 1 of the construction starts
with a properly chosen bipartite graph, denoted by Gptg = (V,C,E), of a
relatively small size that consists of a set V = {v0,v1,...,vn−1} of n VNs, a set
C = {c0,c1,...,cm−1} of m CNs, and a set E = {( j,i)} of edges, where ( j,i)
denotes the edge that connects the j-th VN v j to the i-th CN ci. (The subscript
“ptg” of Gptg stands for “protograph.”) Let λ denote the number of edges in E.
Step 2 of the construction is to create k copies of Gptg. We denote these k copies by
Gptg,0,Gptg,1,...,Gptg,k−1. For 0 ≤j < n, we group the copies of the j-th VN v j
in the k copies of Gptg into a set of k VNs, denoted by  j = {v0, j,v1, j ...,vk−1, j}.
We refer to the k VNs in  j as the type- j VNs. For 0 ≤i < m, we group the
copies of the i-th CN ci in the k copies of Gptg into a set of k CNs, denoted by
i = {c0,i,c1,i,...,ck−1,i}. We refer to the k CNs in i as the type-i CNs. The
kλ edges in the k copies of Gptg are grouped into λ sets, E0,E1,...,Eλ−1, each
consisting of k copies of an edge in the set E of Gptg. For 0 ≤t < λ, if the edges in
Et are copies of the edge ( j,i), then the edges in Et are said to be type-( j,i) edges.
Step 3 of the construction is to connect the k copies Gptg,0,Gptg,1,...,Gptg,k−1
by permuting the edges of the individual copies of Gptg among themselves. The
permutation is carried out under the restriction: for 0 ≤j < n and 0 ≤i < m,
16
04
13:02:52, subject to the Cambridge Core terms of use,

3.1 PTG-LDPC Code Construction
17
type- j VNs in  j can only connect to type-i CNs in i by edges of type-( j,i).
The edge permutations among the copies of Gptg result in a connected bipartite
graph, denoted by Gptg(k,k), with kn VNs, km CNs, and kλ edges, which has the
same degree distributions as the original graph Gptg. The pair (k,k) in Gptg(k,k)
indicates that each VN in Gptg is expanded into k VNs in Gptg(k,k) and each CN
in Gptg is expanded into k CNs in Gptg(k,k). Steps 2 and 3 of the construction are
commonly referred to as the copy-and-permute operation.
The above copy-and-permute operation expands a small bipartite graph Gptg
into a larger bipartite graph Gptg(k,k) by a factor of k. The parameter k is called
the expansion factor (or lifting degree). The graph Gptg is called the protograph
[105] for the code construction. In choosing (or designing) a protograph Gptg for
the LDPC code construction, parallel edges between a VN and a CN are permitted,
but the edge permutations must be performed in such a way that the expanded
graph Gptg(k,k) does not contain parallel edges between a VN and a CN. Since
each VN, each CN, and each edge of the protograph Gptg are expanded by the
same factor k, we refer to the expansion of Gptg to Gptg(k,k) as a uniform graph
expansion.
Let Bptg = [bi, j]0≤i<m,0≤j<n denote the adjacency matrix of the protograph
Gptg. It is an m × n matrix over nonnegative integers with rows corresponding
to the m CNs of Gptg and columns corresponding to the n VNs of Gptg. If
the entry bi, j at location (i, j) of Bptg is a positive integer e, then there are
e parallel edges connecting the VN v j and the CN ci in Gptg. The adjacency
matrix Bptg is called the base matrix of the PTG-based code construction. The
adjacency matrix of the expanded graph Gptg(k,k), denoted by Hptg(k,k), is a
binary mk × nk matrix. If Hptg(k,k) is sparse, the null space of Hptg(k,k) gives
an LDPC code C ptg, called a PTG-based LDPC code. The matrix Hptg(k,k),
obtained by expanding the protograph Gptg as described above, is the parity-check
matrix of the PTG-based LDPC code C ptg. Hereafter, we refer to a PTG-based
LDPC code simply as a PTG-LDPC code. The bipartite graph Gptg(k,k) is the
Tanner graph of C ptg (or the Tanner graph associated with the parity-check matrix
Hptg(k,k)).
Based on the constraint on the copy-and-permute operation performed on the
copies of the protograph Gptg, we see that the connections of the k VNs of type- j
in  j to the k CNs of type-i in i via edges of type-( j,i) can be speciﬁed by
a k × k regular matrix Ai, j, called a connection matrix. Let δ be the number of
nonzero entries in the base matrix Bptg. Then, at most δ distinct regular matrices
of size k × k are needed to connect the k copies of the protograph Gptg to
form the expanded graph Gptg(k,k). Hence, the adjacency matrix Hptg(k,k) =
[Ai, j]0≤i<m,0≤j<n of Gptg(k,k) is an m × n array of regular matrices of size
k × k. If the VN v j and the CN ci in the protograph Gptg are connected by e
04
13:02:52, subject to the Cambridge Core terms of use,

18
3 A Review of PTG-Based Construction of LDPC Codes
parallel edges, then the connection matrix Ai, j that speciﬁes the connections of the
k VNs of type- j in  j to the k CNs of type-i in i is a weight-e regular matrix.
Preferably, the copy-and-permute operation on the copies of a protograph is carried
out in such a way that the connection matrices are binary circulants. In this case, the
parity-check matrix Hptg(k,k) is an m × n array of binary circulants and/or ZMs
of size k × k and the PTG-LDPC code C ptg given by the null space of Hptg(k,k)
is a binary QC-LDPC code, denoted as a QC-PTG-LDPC code. QC-LDPC codes,
in general, have advantages over other types of LDPC codes in terms of encoding
and decoding implementation [72, 20, 68, 78, 79, 69].
The performance of a PTG-LDPC code depends on the choice of the protograph,
its VN and CN degree distributions, and the permutations of the edges among
the copies (to avoid short cycles, such as cycles of length 4, in the Tanner graph
of the resultant code). Protographs are generally designed with good decoding
thresholds based on a computer-aided EXIT chart-based search procedure [80, 34].
In general, a good decoding threshold gives good waterfall performance, but
not necessarily a low error-ﬂoor or a fast rate of decoding convergence. The
PEG algorithm [43, 44] is often used to help design a PTG-LDPC code from a
protograph.
Given a protograph Gptg which is designed for a ﬁxed rate Rc with a good
iterative decoding threshold and an expansion factor (or lifting degree) k, there
are many ways to permute the edges among the k copies of Gptg to connect them
into a bipartite graph Gptg(k,k). Different edge permutations result in different
connected bipartite graphs and different cycle distributions. In general, a bipartite
graph with a reasonably large girth and a small number of short cycles gives an
LDPC code with a better error performance when it is decoded with an iterative
BP-decoding algorithm. Commonly, the PEG algorithm is used to ﬁnd a good
permutation. A girth of at least 6 is normally needed to ensure a reasonably good
error performance.
In the following, we use a small example to illustrate the PTG-based
construction process.
Example 3.1. Consider the protograph Gptg shown in Fig. 3.1(a), that consists of
3 VNs, 2 CNs, and 6 edges. We see that VN v0 is connected to CN c0 by two
parallel edges. The base (or adjacency) matrix of Gptg is given by
Bptg =
	 2
0
1
1
1
1

.
Suppose we take 3 copies of Gptg (i.e., k = 3), permute the edges of these copies
(under the permutation restriction), and connect the three types of VNs and CNs
04
13:02:52, subject to the Cambridge Core terms of use,

3.1 PTG-LDPC Code Construction
19
Figure 3.1. (a) The protograph Gptg given in Example 3.1; (b) the Tanner graph
Gptg(3,3) given in Example 3.1.
using the following 6 connection matrices:
A0,0 =
⎡
⎣
1
1
0
0
1
1
1
0
1
⎤
⎦, A0,1 =
⎡
⎣
0
0
0
0
0
0
0
0
0
⎤
⎦, A0,2 =
⎡
⎣
0
0
1
1
0
0
0
1
0
⎤
⎦,
A1,0 =
⎡
⎣
0
0
1
1
0
0
0
1
0
⎤
⎦, A1,1 =
⎡
⎣
0
1
0
0
0
1
1
0
0
⎤
⎦, A1,2 =
⎡
⎣
0
0
1
1
0
0
0
1
0
⎤
⎦.
The copy-and-permute process based on the above connection matrices results
in a connected bipartite graph Gptg(3,3) shown in Fig. 3.1(b). Since the VN v0 and
the CN c0 are connected by two parallel edges, the connection matrix A0,0, which
connects the three type-0 VNs and the three type-0 CNs, is a weight-2 regular
matrix. The adjacency matrix Hptg(3,3) of Gptg(3,3) is a 2 × 3 array of regular
matrices of size 3 × 3 given below:
Hptg(3,3) =
⎡
⎢⎢⎢⎢⎢⎢⎣
1
1
0
0
0
0
0
0
1
0
1
1
0
0
0
1
0
0
1
0
1
0
0
0
0
1
0
0
0
1
0
1
0
0
0
1
1
0
0
0
0
1
1
0
0
0
1
0
1
0
0
0
1
0
⎤
⎥⎥⎥⎥⎥⎥⎦
.
We can easily check that Hptg(3,3) satisﬁes the RC-constraint. Hence, the
Tanner graph Gptg(3,3) associated with Hptg(3,3) has girth at least 6. From
04
13:02:52, subject to the Cambridge Core terms of use,

20
3 A Review of PTG-Based Construction of LDPC Codes
Fig. 3.1(b), we ﬁnd a cycle of length 6 and hence the girth of Gptg(3,3) is 6.
Furthermore, since Hptg(3,3) is a 2 × 3 array of circulants, the null space of
Hptg(3,3) gives a QC-PTG-LDPC code of length 9 and rate 1/3, whose Tanner
graph has girth 6.
3.2 Conclusion and Remarks
Ensembles of PTG-LDPC codes with asymptotically good decoding thresholds
and good minimum distance properties have been constructed in [34, 31, 32, 2].
For large enough k, a PTG-LDPC code chosen randomly from a good ensemble
in general gives good error performance, especially in the waterfall region (close
to the decoding threshold). Note that, in each ensemble, the parity-check matrix
of a PTG-LDPC code is an array of regular matrices (not necessarily circulants).
Besides random construction, there is no systematic method (or guideline) for
constructing a PTG-LDPC code that not only performs well but also has structure
to facilitate its decoder implementation. Finding such a method may be a good
research problem.
04
13:02:52, subject to the Cambridge Core terms of use,

4
An Algebraic Method for Constructing
QC-PTG-LDPC Codes and Code Ensembles
In this chapter, we consider QC-PTG-LDPC codes from an algebraic point of view
and present a novel algebraic approach to design these codes using a technique that
we call base matrix decomposition.
4.1 Construction of QC-PTG-LDPC Codes
by Decomposing Base Matrices
Suppose we choose a protograph Gptg with n VNs, v0,v1,...,vn−1, and m CNs,
c0,c1,...,cm−1, and expand it by a factor k. Let Bptg = [bi, j]0≤i<m,0≤j<n be
the adjacency matrix of Gptg, an m × n matrix over nonnegative integers. The
ﬁrst step in constructing a QC-PTG-LDPC code is to decompose the base matrix
Bptg into k matrices D0,D1,...,Dk−1, each of size m × n. In decomposing the
base matrix Bptg, we distribute its entries among the k matrices D0,D1,...,Dk−1
in such a way that none of them contains any integer greater than one, i.e., the
entries of each matrix are binary. If the integer-entry bi, j at location (i, j) in Bptg
is greater than one, then it is split into bi, j one-entries which are distributed in bi, j
different matrices among D0,D1,...,Dk−1 at location (i, j)s. The above constraint
on decomposing the base matrix Bptg is called the decomposition constraint and
the parameter k is called the decomposition factor. In the decomposition of Bptg,
ZMs are allowed, i.e., there may be ZMs among the matrices D0,D1,...,Dk−1.
Therefore, for 0 ≤e < k, each matrix De is either an m × n matrix with binary
entries or an m × n ZM. Furthermore, we require that the sum (using integer
addition) of the matrices D0,D1,...,Dk−1 gives the base matrix Bptg of the
protograph Gptg. The matrices D0,D1,...,Dk−1 are referred to as the constituent
matrices of Bptg in the decomposition. The set  = {D0,D1,...,Dk−1} is called
the decomposition set and its elements (member matrices) need not to be distinct.
Note that, if the protograph Gptg contains no parallel edges, its base matrix Bptg is
21
05
12:31:55, subject to the Cambridge Core terms of use,

22
4 Algebraic Construction of QC-PTG-LDPC Codes
a binary matrix. In this case, the constituent matrices D0,D1,...,Dk−1 of Bptg are
mutually disjoint. The matrix Bptg is called the decomposition base matrix.
Next, we arrange the k matrices D0,D1,...,Dk−1 into a row-block, then
cyclically shift this row-block k −1 times, each time by n positions (or one
constituent matrix) to the right. This results in a k × k array Hptg,cyc(m,n) of
m × n matrices with a block-cyclic structure shown below:
Hptg,cyc(m,n) =
⎡
⎢⎢⎢⎣
D0
D1
···
Dk−1
Dk−1
D0
···
Dk−2
...
...
...
...
D1
D2
···
D0
⎤
⎥⎥⎥⎦.
(4.1)
The array Hptg,cyc(m,n) consists of k row-blocks and k column-blocks of
matrices of size m × n. (Note that the pair (m,n) in Hptg,cyc(m,n) denotes the
size of constituent matrices in Hptg,cyc(m,n).) Each row-block is the cyclic-shift
of the row-block above it one constituent matrix to the right, and the top
row-block is the cyclic-shift of the last row-block one constituent matrix to the
right. Each column-block is the cyclic-shift of the column-block on its left one
constituent matrix downward, and the ﬁrst column-block is the cyclic-shift of
the last column-block one constituent matrix downward. The subscript “cyc” in
Hptg,cyc(m,n) stands for “block-cyclic structure.” Since the constituent matrices
of each row-block (or column-block) are the same, i.e., D0,D1,...,Dk−1, the
integer sum of the constituent matrices in each row-block (or each column-block)
of Hptg,cyc(m,n) is a copy of the base matrix Bptg of the protograph Gptg.
Therefore, the block-cyclic array Hptg,cyc(m,n) is composed of k copies of the
decomposition base matrix Bptg of the protograph Gptg. It is a matrix expansion of
Bptg. The top row-block of the cyclic array Hptg,cyc(m,n) is called the generator
row-block.
Let Gptg,cyc(k,k) denote the Tanner graph associated with the k ×k block-cyclic
array Hptg,cyc(m,n). Then, Gptg(k,k) is composed of k copies of the proto-
graph Gptg interconnected by the edges of the copies. Suppose we take each
column-block of Hptg,cyc(m,n) as a copy of the base matrix Bptg of the protograph
Gptg (in the decomposed form). Then, the interconnections of the k copies of the
protograph Gptg are based on the rows of Hptg,cyc(m,n). If we take each row-block
of Hptg,cyc(m,n) as a copy of the base matrix Bptg, then the interconnections of
the k copies of the protograph Gptg are based on the columns of Hptg,cyc(m,n).
Hence, the Tanner graph Gptg,cyc(k,k) associated with the k ×k block-cyclic array
Hptg,cyc(m,n) is an expansion of the protograph Gptg by a factor of k, where the
expansion factor of a protograph is given by the decomposition factor of its base
matrix.
05
12:31:55, subject to the Cambridge Core terms of use,

4.1 Construction by Decomposing Base Matrices
23
Using the k × k block-cyclic array Hptg,cyc(m,n) as a parity-check matrix, its
null space gives a QC-PTG-LDPC code, denoted by C ptg,cyc, of length nk in the
form for which cyclically shifting each codeword n positions to the right also gives
a codeword in Cptg,cyc. This simply follows from the block-cyclic structure of
Hptg,cyc(m,n) and represents the deﬁnition of QC codes ﬁrst introduced in the
1960s [74, 106, 17, 52, 89, 53].
Now we convert the array Hptg,cyc(m,n) to an alternate QC-form, as an array
of circulants of the same size. Label the rows and columns of Hptg,cyc(m,n) from
0 to mk −1 and 0 to nk −1, respectively. Deﬁne the following index sequences
π(0)
row = [0,m,2m,...,(k −1)m],
(4.2)
πrow = [π(0)
row,π(0)
row + 1,...,π(0)
row + m −1],
(4.3)
π(0)
col = [0,n,2n,...,(k −1)n],
(4.4)
πcol = [π(0)
col ,π(0)
col + 1,...,π(0)
col + n −1].
(4.5)
Then, πrow and πcol deﬁne a permutation of the rows and a permutation of
the columns of Hptg,cyc(m,n), respectively. If we ﬁrst permute the rows of
Hptg,cyc(m,n) based on πrow and then permute the columns of Hptg,cyc(m,n)
based on πcol, we obtain an m ×n array Hptg,qc(k,k) of k ×k matrices as follows:
Hptg,qc(k,k) =
⎡
⎢⎢⎢⎣
A0,0
A0,1
···
A0,n−1
A1,0
A1,1
···
A1,n−1
...
...
...
...
Am−1,0
Am−1,1
···
Am−1,n−1
⎤
⎥⎥⎥⎦.
(4.6)
Based on the block-cyclic structure of the array Hptg,cyc(m,n) given by (4.1)
and the row and column permutations πrow and πcol performed on Hptg,cyc(m,n),
we can see that each constituent matrix Ai, j in the array Hptg,qc(k,k) is either a
circulant or a ZM of size k × k. For 0 ≤i < m,0 ≤j < n and 0 ≤e < k, let gi, j,e
be the entry at location (i, j) of the e-th constituent matrix De in the generator
(top) row-block of the block-cyclic array Hptg,cyc(m,n). Then, the k-tuple gi, j =
(gi, j,0,gi, j,1,...,gi, j,k−1) is the generator of the constituent circulant Ai, j of the
array Hptg,qc(k,k). (If gi, j is a zero k-tuple, Ai, j is a ZM of size k × k.) Hence,
we can construct the array Hptg,qc(k,k) directly from these circulant generators
without performing the row and column permutations on Hptg,cyc(m,n). This is
done simply by replacing the nonzero entry bi, j at location (i, j) of the base matrix
Bptg = [bi, j]0≤i<m,0≤j<n of the protograph Gptg with the k × k circulant Ai, j
generated by gi, j = (gi, j,0,gi, j,1,...,gi, j,k−1). If bi, j = 0, Ai, j is a k × k ZM.
Let δ be the number of nonzero entries in the base matrix Bptg. Then, the array
05
12:31:55, subject to the Cambridge Core terms of use,

24
4 Algebraic Construction of QC-PTG-LDPC Codes
Hptg,qc(k,k) consists of δ circulants of size k × k (they may not be all distinct). If
the entries of the base matrix Bptg are binary, then Hptg,qc(k,k) is an m × n array
of CPMs and/or ZMs of size k × k.
Let Gptg,qc(k,k) denote the Tanner graph associated with the m × n array
Hptg,qc(k,k). Then, Gptg,qc(k,k) and the Tanner graph Gptg,cyc(k,k) associated
with the k × k block-cyclic array Hptg,cyc(m,n) are isomorphic (or structurally
identical). One can be obtained from the other by permuting the locations
of VNs and CNs. With Hptg,qc(k,k) as the parity-check matrix, we obtain a
QC-PTG-LDPC code C ptg,qc which is isomorphic (combinatorially equivalent)
to the QC-PTG-LDPC code C ptg,cyc given by the null space of Hptg,cyc(m,n).
A codeword v in Cptg,qc consists of n sections, each containing k bits. If we
cyclically shift all n sections of the codeword v simultaneously one position
to the right within each section, we obtain another codeword in C ptg,qc. This
QC-structure is referred to as a section-wise cyclic structure. Therefore, a
QC-PTG-LDPC code can be put either in a block-cyclic form or in a section-wise
cyclic form.
The QC-PTG-LDPC code C ptg,cyc in block-cyclic form can be decoded with
the reduced-complexity iterative decoding scheme proposed in [79] using the
generator row-block Hptg,cyc,dec = [D0, D1, ...,Dk−1] of its parity-check matrix
Hptg,cyc(n,m) given by (4.1) as the decoding matrix, where the subscript “dec”
stands for “decoding.” This decoding matrix Hptg,cyc,dec is an m × nk submatrix
of Hptg,cyc(n,m). Decoding C ptg,cyc based on Hptg,cyc,dec reduces the complexity
of hardware implementation of an iterative BP-decoder for Cptg,cyc by a factor
of k. The QC-PTG-LDPC code C ptg,qc in section-wise cyclic form can be decoded
using the reduced-complexity iterative decoding scheme proposed in [69] based
on an m × nk submatrix Hptg,qc,dec that consists of the ﬁrst (top) rows of the m
row-blocks of the parity-check matrix Hptg,qc(k,k) of C ptg,qc. Decoding Cptg,qc
based on Hptg,qc,dec also reduces the complexity of hardware implementation of
an iterative BP-decoder for Cptg,qc by a factor of k. The reduction in decoder
complexity is at the expense of a reduction in decoding speed. Various trade-offs
between the decoder complexity and the decoding speed can be achieved by using
decoding matrices of various sizes [79, 69].
If the parity-check matrix Hptg,cyc(n,m) in block-cyclic form (or Hptg,qc(k,k)
in section-wise cyclic form) also has a section-wise cyclic structure (or a
block-cyclic structure), then the QC-PTG-LDPC code C ptg,cyc (or C ptg,qc) has
a doubly QC-structure (i.e., both block-cyclic and section-wise cyclic structures
at the same time without performing row and column permutations). We refer to
such a QC-LDPC code as a doubly QC-LDPC code. More on doubly QC-LDPC
codes will be discussed in Chapter 8. An array of matrices of the same size with
05
12:31:55, subject to the Cambridge Core terms of use,

4.1 Construction by Decomposing Base Matrices
25
a doubly QC-structure can be used to construct spatially coupled (SC) QC-LDPC
codes, which will be discussed in Chapter 9.
With the above construction of a QC-PTG-LDPC code, the graphical process
of edge permutations and connections of the copies of a protograph is replaced by
a matrix decomposition-and-replacement process. It is clear that there are many
possible decompositions of the base matrix Bptg, each resulting in a different
k × k array Hptg,cyc(m,n) (or an m × n array Hptg,qc(k,k)) and hence a different
QC-PTG-LDPC code C ptg,cyc (or C ptg,qc). One extreme decomposition of Bptg is
that each nonzero matrix De in the decomposition set  = {D0,D1,...,Dk−1}
contains a single 1-entry. Hence, in any decomposition of the base matrix
Bptg, the maximum number of nonzero matrices in the set  equals the
integer sum of the nonzero entries in Bptg (the total number of edges in the
protograph Gptg).
In the above algebraic construction of a QC-PTG-LDPC code, there is no upper
limit on the expansion factor k. However, k must be greater than or equal to the
largest integer in the base matrix Bptg of the chosen protograph Gptg. This ensures
that all the nonzero constituent matrices in the decomposition set  are binary,
which is necessary to avoid parallel edges in the Tanner graph associated with
Hptg,cyc(m,n) or Hptg,qc(k,k).
We can label the edge(s) connecting the j-th VN and the i-th CN of the
protograph Gptg with the generator gi, j = (gi, j,0,gi, j,1,...,gi, j,k−1) of the
constituent circulant Ai, j of Hptg,qc(k,k) at location (i, j). In this case, gi, j =
(gi, j,0, gi, j,1,...,gi, j,k−1) is called the vector label of the edge ( j,i). The number
of nonzero components in gi, j equals the number of parallel edges connecting
the j-th VN and the i-th CN of Gptg. From the viewpoint of the graphical
construction of a PTG-LDPC code, the vector labels of the edges in Gptg give
precise information of how to permute the edges of the copies of Gptg and connect
them into the Tanner graph of the QC-PTG-LDPC code C ptg,qc.
The algebraic construction of a QC-PTG-LDPC code presented above is simply
based on the expansion of the base matrix Bptg of the protograph Gptg.
As we showed above, there are two forms of a QC-PTG-LDPC code, the
block-cyclic form and the section-wise cyclic form. Each form consists of
four construction steps. The construction of a QC-PTG-LDPC code C ptg,cyc in
block-cyclic form consists of the following four steps: (1) Design an appropriate
base matrix Bptg for a desired code rate and choose a designed expansion factor k;
(2) Decompose Bptg into k constituent matrices D0,D1,...,Dk−1 which satisfy the
RC- and the PW-RC-constraints; (3) Form a k ×k array Hptg,cyc(m,n) in the form
of (4.1); and (4) Take the null space of Hptg,cyc(m,n) to produce a QC-PTG-LDPC
code Cptg,cyc in block-cyclic form.
05
12:31:55, subject to the Cambridge Core terms of use,

26
4 Algebraic Construction of QC-PTG-LDPC Codes
To construct a QC-PTG-LDPC code in section-wise cyclic form, the ﬁrst two
and the fourth steps are the same as those for constructing a QC-PTG-LDPC code
Cptg,cyc in block-cyclic form. In the third step, an m × n array Hptg,qc(k,k) =
[Ai, j]0≤i<m,0≤j<n is constructed directly from the k constituent matrices D0, D1,
..., Dk−1 formed in the second step (by skipping the row and column permutations
of the array Hptg,cyc(m,n)). This is carried out by ﬁnding the set {gi, j : 0 ≤i <
m,0 ≤j < n} of the generators of the set {Ai, j : 0 ≤i < m,0 ≤j < n} of k × k
circulants from D0,D1,... ,Dk−1. Then, we replace the entries in the base matrix
Bptg = [bi, j]0≤i<m,0≤j<n by their corresponding circulants in {Ai, j : 0 ≤i <
m,0 ≤j < n}. So, the third step for constructing a QC-PTG-LDPC code C ptg,qc in
section-wise cyclic form is simply a replacement process which is exactly the one
used in the SP-construction method for constructing LDPC codes given in [76].
This correspondence will be discussed further in Chapter 5.
With the above algebraic construction of a QC-PTG-LDPC code, the design of a
protograph is equivalent to the design of a base matrix, and the copy-and-permute
process performed on a protograph is equivalent to the decomposition-and-
replacement process performed on its associated base matrix.
4.2 Construction of RC-Constrained PTG Parity-Check Matrices
The girth and cycle distributions of the Tanner graph Gptg,cyc(k,k) (or Gptg,qc
(k, k)) and hence the performance of a QC-PTG-LDPC code C ptg,cyc (or Cptg,qc)
very much depend on the decomposition of the base matrix Bptg, i.e., the
distribution of its nonzero entries and the arrangement (or order) of the nonzero
constituent matrices in the generator row-block of the array Hptg,cyc(m,n). The
distribution of the nonzero entries in Bptg and the order of the nonzero constituent
matrices in the decomposition set  = {D0, D1,... ,Dk−1} should be done in such
a way that the array Hptg,cyc(m,n) satisﬁes the RC-constraint (or the Tanner graph
Gptg,cyc(k,k) associated with the parity-check array Hptg,cyc(m, n) has no cycle
of length 4).
With iterative decoding of an LDPC code using a BP-algorithm, cycles of
length 4 in the Tanner graph of the code cause serious decoding correlation after
a few iterations and result in poor performance, in general. In the code design
(or construction), effort must be made to remove these harmful cycles of length
4. The Tanner graph of an LDPC code whose parity-check matrix satisﬁes the
RC-constraint has girth at least 6 and hence contains no cycle of length 4. In
general, an LDPC code whose Tanner graph has a relatively large girth and a
small number of short cycles performs well if it also has other good structural
properties as described in Section 2.2. A girth of at least 6 is in general required
for a code to achieve good error performance if it has no small trapping sets and has
05
12:31:55, subject to the Cambridge Core terms of use,

4.2 Construction of RC-Constrained PTG Matrices
27
a large enough minimum distance, such as ﬁnite geometry LDPC codes and many
other algebraic LDPC codes constructed based on ﬁnite ﬁelds and combinatorial
designs.
Using the matrix decomposition method to construct a QC-PTG-LDPC code
C ptg,cyc (or C ptg,qc) whose parity-check array Hptg,cyc(m,n) (or Hptg,qc(k,k))
satisﬁes the RC-constraint, the general guidelines to decompose the base matrix
Bptg of the protograph Gptg are: (1) Each nonzero constituent matrix De in the
decomposition set  = {D0,D1,...,Dk−1} satisﬁes the RC-constraint; and (2) Any
two nonzero constituent matrices, De and D j, satisfy the PW-RC-constraint. These
general guidelines are necessary but not sufﬁcient to guarantee that the k × k
array Hptg,cyc(m,n) satisﬁes the RC-constraint. If the number of ZMs in the
decomposition set  is large enough and if we order the constituent matrices
of  in forming the generator row-block of the cyclic array Hptg,cyc(m,n)
in such a way that Hptg,cyc(m,n) satisﬁes the 2 × 2 array RC-constraint,
then Hptg,cyc(m,n) satisﬁes the RC-constraint (as discussed in Section 2.1).
A decomposition set  of a base matrix whose nonzero constituent matrices
satisfy the RC- and the PW-RC-constraints is called an RC-constrained decom-
position set.
In forming an RC-constrained decomposition set  of a base matrix Bptg,
we ﬁrst decompose Bptg into a set of RC- and PW-RC-constrained nonzero
constituent matrices. This can be achieved with computer aid. However, if
each nonzero constituent matrix in the decomposition of Bptg contains a single
1-entry, then all the nonzero constituent matrices in  satisfy the RC- and the
PW-RC-constraints. Another case when computer aid is not needed is when the
base matrix Bptg is binary and satisﬁes the RC-constraint. In this case, any
decomposition of Bptg will give a set of nonzero constituent matrices which satisfy
both the RC- and the PW-RC-constraints. Construction of RC-constrained base
matrices can be done using the PEG algorithm or using the algebraic methods
presented in [58, 76, 110, 109, 35, 107, 3, 19, 74, 111, 102, 101, 112, 64, 65,
116, 97, 50, 99, 113, 114, 25, 46, 26, 70, 68, 77]. New construction methods of
RC-constrained base matrices will be presented in later chapters. Once we obtain a
set of RC- and PW-RC-constrained nonzero constituent matrices of the base matrix
Bptg, we add ZMs to the set to form an RC-constrained decomposition set  of
the base matrix to meet the desired decomposition factor k.
Ordering the constituent matrices in an RC-constrained decomposition set 
of a base matrix Bptg to form the generator row-block of a block-cyclic array
Hptg,cyc(m,n) such that Hptg,cyc(m,n) satisﬁes the 2×2 array RC-constraint can
also be achieved with computer aid. One approach to achieve this is to put ZMs
between two nonzero constituent matrices in forming the generator row-block of
Hptg,cyc(m,n) such that any 2 × 2 subarray of Hptg,cyc(m,n) contains at least
05
12:31:55, subject to the Cambridge Core terms of use,

28
4 Algebraic Construction of QC-PTG-LDPC Codes
one ZM. This ensures that Hptg,cyc(m,n) satisﬁes the RC-constraint as described
in Section 2.1.
Another approach to achieve the RC-constraint on Hptg,cyc(m,n) is an algebraic
approach. Let δ be the number of nonzero constituent matrices in . We
ﬁrst construct a k × k binary circulant M with weight δ which satisﬁes the
RC-constraint. Note that any 2 × 2 submatrix of M contains at least one 0-entry.
Next, we replace the δ 1-components of the generator (or top row) of the
RC-constrained circulant M with the nonzero constituent matrices in  and the
k −δ 0-components with ZMs. (The replacement can be carried out arbitrarily.)
This replacement results in a row-block that consists of all the δ constituent
matrices in . Cyclically shifting this row-block to the right k −1 times, one
constituent matrix per shift, we form a block-cyclic array Hptg,cyc(m,n). Since
any 2 × 2 submatrix of M contains at least one 0-entry, any 2 × 2 subarray
of Hptg,cyc(m,n) contains at least one ZM. Since the constituent matrices of
Hptg,cyc(m,n) are member matrices of the decomposition set  which satisfy
both the RC- and the PW-RC-constraints, every 2 × 2 subarray of Hptg,cyc(m,n)
satisﬁes the RC-constraint. Hence, the block-cyclic array Hptg,cyc(m,n) satisﬁes
the RC-constraint. Construction of RC-constrained circulants can be achieved by
using ﬁnite geometries over ﬁnite ﬁelds [58, 74, 97]. This will be discussed in
Chapter 6 and also in Appendix A.
It is clear that, if the block-cyclic array Hptg,cyc(m,n) is RC-constrained, the
array Hptg,qc(k,k) is also RC-constrained.
4.3 Examples
In this section, we ﬁrst use a simple example to demonstrate the decomposition
process of a small base matrix and the construction of an array of circulants
based on the decomposition of the base matrix. We then give three binary
QC-PTG-LDPC codes constructed based on the proposed algebraic construction
and present their error performances over the AWGNC using BPSK signaling and
the BEC. We show that these codes perform very well over both the AWGNC and
the BEC.
Example 4.1. Consider the protograph Gptg shown in Fig. 4.1(a). The base matrix
Bptg of Gptg is a 2 × 3 matrix given below:
Bptg =
	 2
0
1
1
1
1

.
Note that the base matrix Bptg does not satisfy the RC-constraint.
05
12:31:55, subject to the Cambridge Core terms of use,

4.3 Examples
29
Figure 4.1. (a) The protograph Gptg given in Example 4.1; and (b) the protograph
Gptg in Example 4.1 with vector labels, where g0,0 = (1,1,0), g0,2 = (0,0,1),
g1,0 = (0,0,1), g1,1 = (0,1,0), and g1,2 = (0,0,1).
Choose the decomposition factor k = 3. Suppose we decompose Bptg into the
following three 2 × 3 matrices:
D0 =
	 1
0
0
0
0
0

, D1 =
	 1
0
0
0
1
0

, D2 =
	 0
0
1
1
0
1

.
It is easy to check that the above constituent matrices of the decomposition of
Bptg satisfy the RC- and the PW-RC-constraints. Based on these three constituent
matrices, we form the following 3 × 3 array Hptg,cyc(2,3) of 2 × 3 matrices with
a block-cyclic structure:
Note that Hptg,cyc(2,3) satisﬁes the 2 × 2 array RC-constraint and hence the
RC-constraint. The null space of Hptg,cyc(2,3) gives a QC-PTG-LDPC code
Cptg,cyc of length 9 and rate 1/3, whose Tanner graph has girth 6. The code has a
block-cyclic structure.
Permuting the columns and rows of Hptg,cyc(2,3) based on the row and column
permutations πrow and πcol deﬁned by (4.3) and (4.5), respectively, we obtain the
following 2 × 3 array Hptg,qc(3,3) of circulants of size 3 × 3:
05
12:31:55, subject to the Cambridge Core terms of use,

30
4 Algebraic Construction of QC-PTG-LDPC Codes
Figure 4.2. The Tanner graph Gptg,1 of the base matrix Bptg,1 given in
Example 4.2.
From the structure of the array Hptg,qc(3,3), we see that the array is obtained
by replacing each entry in the base matrix Bptg by a circulant of size 3 × 3
whose generator can be determined directly from the three constituent matrices
D0,D1, and D2 of Bptg (or the generator row-block of the block-cyclic array
Hptg,cyc(2,3)) as explained above. Note that the entry 2 in Bptg is replaced by
a circulant of weight 2 and each 1-entry is replaced by a CPM. The protograph
Gptg with vector labels is shown in Fig. 4.1(b). The null space of Hptg,qc(3,3)
gives a (9,3) QC-PTG-LDPC code C ptg,qc with a section-wise cyclic structure.
Cptg,cyc and C ptg,qc are combinatorially equivalent.
In this example, we show that an RC-constrained array can be constructed by
decomposing the base matrix into constituent matrices which satisfy the RC- and
the PW-RC-constraints and ordering the constituent matrices properly.
Example 4.2. Suppose we choose the following 4 × 8 binary matrix as the base
matrix for constructing a QC-PTG-LDPC code with rate 1/2:
Bptg,1 = [bi, j]0≤i<4,0≤j<8 =
⎡
⎢⎢⎣
1
0
1
0
1
1
1
1
0
1
0
1
1
1
1
1
1
1
1
1
1
0
1
0
1
1
1
1
0
1
0
1
⎤
⎥⎥⎦.
(4.7)
This base matrix is a (3,6)-regular binary matrix with column and row weights
3 and 6, respectively. It has 24 nonzero entries which are all 1s. The protograph
associated with this matrix is shown in Fig. 4.2. It has 8 VNs and 4 CNs but no
parallel edges.
Suppose we choose the decomposition (or expansion) factor k = 330. The base
matrix and the decomposition factor are designed to construct a QC-PTG-LDPC
code of rate 1/2 whose Tanner graph has girth 8 and contains a small number
of short cycles. The base matrix is not designed based on the decoding threshold
criterion.
Decompose the base matrix Bptg,1 into 330 constituent matrices of size 4 × 8,
D0,D1,...,D329. Among these 330 constituent matrices, 23 of them are nonzero
matrices and the other 307 matrices are ZMs. Among the 23 nonzero matrices, one
05
12:31:55, subject to the Cambridge Core terms of use,

4.3 Examples
31
Table 4.1. The nonzeros matric in the decomposition set
 = {D0,D1,...,D329} and the locations of their 1-entries
constructed in Example 4.2
The nonzero
matrices
The locations
of 1-entries
The nonzero
matrices
The locations
of 1-entries
D10
(3,5)
D209
(2,1)
D39
(0,0)
D271
(3,1)
D68
(0,7)
D274
(1,7)
D75
(1,3)
D275
(3,2)
D79
(1,1), (0,2)
D284
(3,7)
D143
(3,3)
D287
(2,2)
D148
(1,6)
D294
(0,6)
D158
(1,4)
D295
(1,5)
D163
(2,4)
D297
(0,6)
D181
(3,0)
D324
(2,3)
D202
(2,6)
D328
(0,5)
D206
(2,0)
consists of two 1s and each of the other 22 consists of a single 1. These 23 nonzero
constituent matrices of Bptg,1 satisfy the RC- and the PW-RC-constraints. The
locations of the 1s in these 23 nonzero matrices are given in Table 4.1, where the
pair (i, j) denotes the location intersecting at the i-th row and the j-th column
of each nonzero constitute matrix. Based on the locations of 1s of these nonzero
constituent matrices of Bptg,1, we construct a set of 24 CPMs of size 330 × 330
which correspond to the 24 1s in Bptg,1. Replacing each 1-entry in Bptg,1 by its
corresponding CPM and each 0-entry by a ZM of size 330 × 330, we obtain the
following 4 × 8 array Hptg,qc,1(330,330) of CPMs and ZMs of size 330 × 330 in
which each CPM is represented by a positive integer less than 330:
Hptg,qc,1(330,330) =
⎡
⎢⎢⎣
39
z
79
z
294
328
297
68
z
79
z
75
158
295
148
274
206
209
287
324
163
z
202
z
181
271
275
143
z
10
z
284
⎤
⎥⎥⎦.
(4.8)
A nonzero entry l in Hptg,qc,1(330,330) represents a CPM whose generator,
a 330-tuple with components labeled from 0 to 329, has its single 1-entry
at location l. The symbol z in Hptg,qc,1(330,330) represents a ZM of size
330 × 330. The array Hptg,qc,1(330,330) is a 1320 × 2640 matrix with column
and row weights 3 and 6, respectively. It can be checked that Hptg,qc,1(330,330)
05
12:31:55, subject to the Cambridge Core terms of use,

32
4 Algebraic Construction of QC-PTG-LDPC Codes
satisﬁes the RC-constraint and hence its associated Tanner graph, denoted by
Gptg,qc,1(330,330), has girth at least 6. Using the cycle counting algorithm
presented in [71], we ﬁnd that the Tanner graph Gptg,qc,1(330,330) of the code
Cptg,qc,1 has girth 8 and contains 990 cycles of length 8 and 8580 cycles of
length 10. The connection number of each VN in Gptg,qc,1(330,330) is 15.
The null space of Hptg,qc,1(330,330) gives a (3,6)-regular (2640,1320)
QC-PTG-LDPC code, denoted by Cptg,qc,1, with rate 1/2. Suppose the code is
used over the AWGNC with BPSK signaling. The bit error rate (BER) and block
error rate (BLER) performances of the code C ptg,qc,1 decoded using the MSA
[97, 18] with a maximum of 50 iterations and the SPA [81, 74, 97] with a maximum
of 100 iterations are shown in Fig. 4.3(a). We see that the code achieves a BER
of 10−10 without a visible error-ﬂoor decoded using the MSA. The decoding
threshold of this code is 1.1 dB. At BERs of 10−5 and 10−10, the code performs 1
and 1.4 dBs away from the decoding threshold, respectively. At a BLER of 10−8,
the code performs within 1.25 dB of the SPB.
For comparison, in Fig. 4.3(a), we also include the BER and BLER perfor-
mances of a (2664,1334) QC-PTG-LDPC code C⋆
ptg,qc with rate 0.5008 which
was recently reported in [85]. This code was constructed based on the conventional
PTG-based construction method using a pre-lifting technique. The protograph of
this code is designed based on the decoding threshold criterion. The decoding
threshold of this code is also 1.1 dB, the same as the decoding threshold of the
(2640,1320) QC-PTG-LDPC code Cptg,qc,1. The QC-PTG-LDPC code C⋆
ptg,qc
is 24 bits longer than the code C ptg,qc,1 constructed using the base matrix given
by (4.7) and the algebraic decomposition method. In [85], the code C⋆
ptg,qc was
decoded using the SPA with 100 iterations. We see that the two codes perform
basically the same above the BER of 10−7 decoded with 100 iteration of the SPA.
Note that the protograph of the code C⋆
ptg,qc was designed based on the decoding
threshold criterion but the base matrix given by (4.7) is not. Surprisingly, it turns
out that the two codes Cptg,qc,1 and C⋆
ptg,qc have the same decoding threshold and
perform almost the same.
It has been shown in the literature (e.g., [101, 64, 65, 97]) that, if an LDPC code
performs well over the AWGNC, it also performs well over the BEC. Fig. 4.3(b)
shows that the (2640,1320) code Cptg,qc,1 indeed performs well over the BEC. At
a unresolved erasure bit rate (UEBR) of 10−10 (an unresolved erasure block rate
(UEBLR) of 10−9), the code performs 0.14 from the Shannon limit (0.5) without
a visible error-ﬂoor.
Example 4.3. In the previous example, a QC-PTG-LDPC code was constructed
based on a binary base matrix, i.e., its associated Tanner graph contains no parallel
edges. In this example, we construct a QC-PTG-LDPC code using a base matrix
05
12:31:55, subject to the Cambridge Core terms of use,

4.3 Examples
33
0.75
1
1.25
1.5
1.75
2
2.25
2.5
2.75
3
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
Cptg,qc,1, MSA, itr50, BLER
Cptg,qc,1, MSA, itr50, BER
Cptg,qc,1, SPA, itr100, BLER
Cptg,qc,1, SPA, itr100, BER
Cptg,qc
*
, SPA, itr100, BLER
Cptg,qc
*
, SPA, itr100, BER
SPB
threshold
0.34
0.35
0.36
0.37
0.38
0.39
0.4
0.41
0.42
0.43
0.44
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
UEBR/UEBLR
ε
Cptg,,qc,1, UEBLR
Cptg,,qc,1, UEBR
(b)
Figure 4.3. (a) The BER and BLER performances of the (2640,1320)
QC-PTG-LDPC code C ptg,qc,1 given in Example 4.2 and the (2664,1334)
QC-PTG-LDPC code C⋆
ptg,qc reported in [85] over the AWGNC; and (b) the
performance of the (2640,1320) QC-PTG-LDPC code C ptg,qc,1 over the BEC.
05
12:31:55, subject to the Cambridge Core terms of use,

34
4 Algebraic Construction of QC-PTG-LDPC Codes
whose Tanner graph contains parallel edges. The chosen base matrix is a 2 × 16
matrix whose entries are all equal to 2 as given below:
Bptg,2 =
	 2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2
2

.
(4.9)
Suppose we choose the decomposition factor k = 511 and decompose the
base matrix Bptg,2 into 511 constituent matrices D0,D1,...,D510 of size 2 ×
16. In decomposing the base matrix Bptg,2, each 2-entry is split into two
1-entries which are put into two different constituent matrices. Furthermore,
each nonzero constituent matrix contains only one 1-entry. Thus, among the
511 constituent matrices of Bptg,2, there are 64 nonzero matrices which satisfy
both the RC- and the PW-RC-constraints. In forming the generator row-block
of the block-cyclic array Hptg,cyc,2(2,16) in the form of (4.1), we order the
constituent matrices of Bptg,2 in such a way that Hptg,cyc,2(2,16) satisﬁes the
2 × 2 array RC-constraint and hence Hptg,cyc,2(2,16) satisﬁes the RC-constraint.
Based on the decomposition of Bptg,2 and the order of the constituent matrices
of the ﬁrst row-block of Hptg,cyc,2(2,16), we can construct a 2 × 16 array
Hptg,qc,2(511,511) = [Ai, j]0≤i<2,0≤j<16 of weight-2 circulants of size 511×511,
which is a 1022 × 8176 matrix with constant column and row weights 4 and 32,
respectively. The generators of the 32 circulants are given in Table 4.2, where the
pair (a,b) denotes the locations of the two 1-components in the generator of each
circulant in Hptg,qc,2(511,511).
The Tanner graph Gptg,qc,2(511,511) associated with Hptg,qc,2(511,511) has
girth 6 and contains 112,420 cycles of length 6. The connection number of
each VN is 124. We see that Gptg,qc,2(511,511) has a high degree of connec-
tivity. The null space of Hptg,qc,2(511,511) gives a (4,32)-regular (8176,7156)
QC-PTG-LDPC code C ptg,qc,2 with rate 0.875.
The BER and BLER performances of the code Cptg,qc,2 decoded with 50, 10,
and 5 iterations of the SPA over the AWGNC are shown in Fig. 4.4(a). We see that
the decoding of the code converges very fast due to the high-degree connectivity
of its Tanner graph. At a BER of 10−8, the performance gap between 5 and 10
iterations is 0.4 dB and the gap between 10 and 50 iterations is about 0.2 dB. With
50 iterations, the code performs about 1.1 dB away from the Shannon limit at a
BER of 10−8 and at a BLER of 10−6, the code performs about 0.65 dB away from
the SPB. The decoding threshold of C ptg,qc,2 is 3.35 dB. At BERs of 10−5 and
10−8, the code performs about 0.43 and 0.65 dBs from the decoding threshold,
respectively, very close to the decoding threshold.
The QC-PTG-LDPC code C ptg,qc,2 constructed above has the same length and
the same rate as the NASA (CCSDS standard) (8176,7156) QC-LDPC code Cnasa
05
12:31:55, subject to the Cambridge Core terms of use,

4.3 Examples
35
[97, 87] for satellite and space communications. This code has been used in
the Land Remote-Sensing Satellite (LANDSAT), the Interface Region Imaging
Spectrograph (IRIS), and other NASA missions. The parity-check matrix of the
NASA code Cnasa is also a 2 × 16 array of 511 × 511 circulants of weight 2.
However, the compositions of the circulants of the parity-check arrays of the
two codes are different as shown in Table 4.2. For comparison, the BER and
BLER performances [97, Example 10.10, pp. 453–454] of the NASA code Cnasa
decoded with 50 iterations of the SPA are also included in Fig. 4.4(a). We see
that, in the simulation range, the two codes basically perform the same. Note
that the NASA code Cnasa can reach down to a BER of 10−14 without a visible
error-ﬂoor [97].
The error performance of the code Cptg,qc,2 over the BEC is shown in
Fig. 4.4(b). At a UEBR of 10−10, it performs about 0.049 away from the Shannon
limit (0.125) without a visible error-ﬂoor.
In the last two examples, we constructed two regular QC-PTG-LDPC codes
using the proposed algebraic construction method. In the next example, we use the
method to construct an irregular QC-PTG-LDPC code.
Example 4.4. Suppose it is desired to construct an irregular QC-PTG-LDPC code
of length around 20 000 bits with rate close to 0.8. Applying density-evolution
[96], we ﬁnd that the following degree distributions [96, 97] of VNs and CNs of
the Tanner graph give a good decoding threshold: γ (X) = 0.1905X +0.6074X2 +
0.1466X6 + 0.0555X7 and ρ(X) = X18. Based on these two degree distributions,
we construct a 12 × 63 base matrix Bptg,3 with only binary entries (i.e., the
associated protograph has no parallel edges) whose row and column weight
distributions are given in Table 4.3.
To achieve the desired code length of around 20000 bits, we choose the
decomposition factor k = 330. Decomposing the base matrix Bptg,3 into 330
constituent matrices, we construct a 12 × 63 array Hptg,qc,3(330,330) of CPMs
and ZMs of size 330×330. The null space of Hptg,qc,3(330,330) gives an irregular
(20790,16830) QC-PTG-LDPC code Cptg,qc,3 with rate 0.8095. The Tanner
graph of the code has girth 6 and contains 32340 cycles of length 6. The BER and
BLER performances of this code over the AWGNC decoded with 50 iterations
of the MSA are shown in Fig. 4.5(a). The ﬁgure shows that the code C ptg,qc,3
achieves a BER of 10−10 without a visible error-ﬂoor and performs about 1 dB
away from the Shannon limit at a BER of 10−10. At a BLER of 10−6, it performs
about 0.6 dB away from the SPB. The decoding threshold of this code is 2.66 dB.
At BERs of 10−5 and 10−10, the code performs 0.24 and 0.35 dBs away from its
05
12:31:55, subject to the Cambridge Core terms of use,

Table 4.2. The locations of 1-entries in the 32 circulants of parity-check matrices of the code C ptg,qc,2 given in Example 4.3 and
those for the NASA code Cnasa [97]
Circulants
1’s positions
of generators
Circulants
1’s positions
of generators
Circulants
(NASA)
1’s positions of
generators (NASA)
Circulants
(NASA)
1’s positions of
generators (NASA)
A0,0
(209,284)
A1,0
(180,305)
A0,0
(0,176)
A1,0
(99,471)
A0,1
(45,469)
A1,1
(315,432)
A0,1
(12,239)
A1,1
(130,473)
A0,2
(111.482)
A1,2
(373,384)
A0,2
(0,352)
A1,2
(198,435)
A0,3
(55,317)
A1,3
(35,232)
A0,3
(24,431)
A1,3
(260,478)
A0,4
(466,467)
A1,4
(106,306)
A0,4
(0,392)
A1,4
(215,420)
A0,5
(149,229)
A1,5
(65,84)
A0,5
(151,409)
A1,5
(282,481)
A0,6
(93,364)
A1,6
(131,221)
A0,6
(0,351)
A1,6
(48,396)
A0,7
(330,337)
A1,7
(137,230)
A0,7
(9,359)
A1,7
(193,445)
A0,8
(162,219)
A1,8
(303,475)
A0,8
(0,307)
A1,8
(273,430)
A0,9
(244,314)
A1,9
(388,448)
A0,9
(53,329)
A1,9
(302,451)
A0,10
(406,441)
A1,10
(62,79)
A0,10
(0,207)
A1,10
(96,379)
A0,11
(273,419)
A1,11
(263,461)
A0,11
(18,281)
A1,11
(191,386)
A0,12
(86,133)
A1,12
(18,242)
A0,12
(0,399)
A1,12
(244,467)
A0,13
(16,359)
A1,13
(343,404)
A0,13
(202,457)
A1,13
(364,470)
A0,14
(190,268)
A1,14
(56,69)
A0,14
(0,247)
A1,14
(51,382)
A0,15
(324,338)
A1,15
(389,455)
A0,15
(36,261)
A1,15
(192,414)
05
12:31:55, subject to the Cambridge Core terms of use,

4.3 Examples
37
3
3.2
3.4
3.6
3.8
4
4.2
4.4
4.6
4.8
5
5.2
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
Cptg,qc,2, itr50, BLER
Cptg,qc,2, itr50, BER
Cptg,qc,2, itr10, BLER
Cptg,qc,2, itr10, BER
Cptg,qc,2, itr5, BLER
Cptg,qc,2, itr5, BER
Cnasa, itr50, BLER
Cnasa, itr50, BER
SPB
Shannon Limit
0.074
0.078
0.082
0.086
0.09
0.094 0.096
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(8176, 7156) Cptg,qc,2, UEBLR
(8176, 7156) Cptg,qc,2, UEBR
Figure 4.4. (a) The BER and BLER performances of the (8176,7156)
QC-PTG-LDPC code C ptg,qc,2 decoded with 50, 10, and 5 iterations of the SPA
given in Example 4.3 and the NASA code Cnasa [97, 87] over the AWGNC; and
(b) the performance of the code C ptg,qc,2 over the BEC.
05
12:31:55, subject to the Cambridge Core terms of use,

38
4 Algebraic Construction of QC-PTG-LDPC Codes
Table 4.3. Row and column weight distributions of the base matrix
Bptg,3 given in Example 4.4
Column weight distribution
Row weight distribution
Column weight
No. of columns
Row weight
No. of rows
2
12
19
12
3
39
7
9
8
3
decoding threshold, respectively. We see that the code performs very close to the
decoding threshold.
For the BEC, the UEBR and UEBLR performances of the code C ptg,qc,3 are
shown in Fig. 4.5(b). We see that at a UEBR of 10−8, the code performs only
about 0.04 away from Shannon limit.
4.4 Construction of the Ensemble of PTG-LDPC Codes
from an Algebraic Point of View
In this section, we create an ensemble of PTG-LDPC codes from an algebraic point
of view.
For a given rate Rc, we choose the parameters m,n, and k such that Rc =
(n −m)/n. Next, we choose, at random, an m × n matrix Bptg over nonnegative
integers. Then, we decompose this base matrix into an arbitrary number k of
constituent matrices randomly, i.e., we split the integer entries in Bptg that exceed
one and distribute them among k constituent matrices randomly. This random
decomposition of a base matrix results in an ensemble ξcyc of block-cyclic arrays
in the form of (4.1), called a block-cyclic ensemble. Next, we permute the rows and
columns of each block-cyclic array in the ensemble ξcyc based on the permutations
πrow and πcol deﬁned by (4.3) and (4.5) to obtain an ensemble ξqc of QC arrays in
the form of (4.6), called a QC ensemble. Each constituent matrix in a QC array in
the ensemble ξqc is either a k × k circulant or a k × k ZM. Note that the ensemble
ξcyc is equivalent to the ensemble ξqc.
Now, we permute the rows and/or columns of each k × k nonzero constituent
circulant of a QC array in the ensemble ξqc randomly to obtain a k × k regular
matrix. These row and/or column permutations of each nonzero constituent
circulant in each of the QC arrays in the ensemble ξqc result in an ensemble ξptg
of arrays of k × k regular matrices. The size of the ensemble ξptg is much larger
than that of the ensemble ξqc (or the ensemble ξcyc).
05
12:31:55, subject to the Cambridge Core terms of use,

4.4 Construction of PTG- LDPC Code Ensembles
39
2
2.2
2.4
2.6
2.8
3
3.2
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
Cptg,qc,3, BLER
Cptg,qc,3, BER
Shannon Limit
SPB
0.145
0.15
0.155
0.16
0.165
0.17
0.175
0.18
0.185
0.19
0.195
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
Cptg,qc,3, UEBLR
Cptg,qc,3, UEBR
Shannon Limit
Figure 4.5. (a) The BER and BLER performances of the (20790,16830)
QC-PTG-LDPC code C ptg,qc,3 given in Example 4.4 over the AWGNC; and
(b) the performance of the code in (a) over the BEC.
05
12:31:55, subject to the Cambridge Core terms of use,

40
4 Algebraic Construction of QC-PTG-LDPC Codes
The null spaces of the arrays in the ensemble ξptg give an ensemble Eptg
of PTG-LDPC codes with rate Rc. This ensemble Eptg of PTG-LDPC codes is
equivalent to the ensemble of PTG-LDPC codes investigated in [34] from the
graphical point of view, where its asymptotic properties were analyzed.
4.5 Discussion and Remarks
In this chapter, we presented an algebraic method for constructing binary
QC-PTG-LDPC codes. The construction is based on the decomposition of a
base matrix over nonnegative integers. The matrix decomposition process seems
more convenient and ﬂexible than the copy-and-permute process of a protograph.
Examples showed that a well-designed base matrix gives a QC-PTG-LDPC code
that performs very close to the decoding threshold. How to design good base
matrices algebraically is an interesting research problem. This problem will be
further discussed in Chapters 5, 7, and 11. Even though we have provided some
general guidelines and constraints for decomposing a base matrix to avoid short
cycles, a more speciﬁc method or algorithm is needed. Finding such a method
may be a good research problem. How to order the constituent matrices in an
RC-constrained decomposition set of a base matrix to form an RC-constrained
parity-check array is also an interesting problem to investigate.
We showed that a QC-PTG-LDPC code constructed by decomposing a base
matrix can be put either in a block-cyclic form or in a section-wise cyclic form.
In a block-cyclic form, the code can be decoded with the iterative BP-decoding
scheme proposed in [79] to reduce the decoder complexity signiﬁcantly by using
a small submatrix of the parity-check matrix of the code as the decoding matrix.
This iterative BP-decoding scheme not only signiﬁcantly reduces the number of
CN-MPUs (and/or VN-MPUs) and the number of wires for message exchanges
between the CN-MPUs and the VN-MPUs but also greatly reduces the size of
memory required for storing messages for exchanges between the CN-MPUs and
the VN-MPUs. In a section-wise cyclic form, we can use the reduced-complexity
iterative BP-decoding scheme proposed in [69, 68, 78] to decode the code using a
decoding matrix much smaller than the parity-check matrix of the code.
In two later chapters, we show that we can generalize base matrices over
nonnegative integers for the algebraic construction of PTG-LDPC codes to base
matrices over ﬁnite ﬁelds and matrices with set-entries over ﬁnite ﬁelds. This is
used for constructing both binary and NB QC-PTG-LDPC codes with a matrix
decomposition method similar to the method presented in this chapter.
05
12:31:55, subject to the Cambridge Core terms of use,

5
Superposition Construction of LDPC Codes
The SP-construction, proposed in 2002 [76], is one of the earliest algebraic-based
methods for constructing LDPC codes, especially QC-LDPC codes. In this
chapter, we interpret this construction in a broader way, algebraically and
graph-theoretically, and show that the PTG-based method of LDPC code
construction is a special case of the SP-construction method.
Even though the PTG-construction of LDPC codes is a special case of the
SP-construction of LDPC codes, it should be pointed out that design techniques
for these two classes of codes have been different over the years since their
discoveries in 2003 [105] and 2002 [76], respectively. Over the years, SP-LDPC
codes and their related codes have employed algebraic approaches in their
design with the goal of very low decoding error-ﬂoors and highly structured
(lower-complexity) decoders. PTG-LDPC codes have instead been designed using
ensemble approaches, with good ensembles found via density evolution or EXIT
charts. The goal in this case is an optimum decoding threshold (waterfall region).
Whether or not these ensemble approaches can be extended to general SP-LDPC
codes will require further research.
5.1 SP-Construction of LDPC Codes and Its Graphical Interpretation
Let Bsp = [bi, j]0≤i<m,0≤j<n be a small m ×n binary matrix. Let R = { A0, A1, ...,
Ar−1} be a set of r k × t sparse matrices over GF(2). From Bsp and the member
matrices of R, we construct an m ×n array Hsp(k,t) of k ×t matrices by replacing
each 1-entry in Bsp by a member matrix of R and each 0-entry by a k ×t ZM. This
replacement of entries in Bsp by the member matrices in R and/or ZMs expands the
matrix Bsp into an mk × nt sparse matrix Hsp(k,t). As an m × n array, Hsp(k,t)
consists of n column-blocks, denoted by H0, H1, ..., Hn−1, and m row-blocks,
denoted by M0, M1, ..., Mm−1. Each column-block H j consists of t consecutive
41
06
12:34:14, subject to the Cambridge Core terms of use,

42
5 Superposition Construction of LDPC Codes
columns of Hsp(k,t) and each row-block Mi consists of k consecutive rows of
Hsp(k,t). The above operation of replacing the entries in Bsp by the member
matrices in R and/or ZMs was called SP-operation in [76, 110, 109, 111, 97].
The SP-operation is simply an expansion operation. The null space of Hsp(k,t)
gives an LDPC code Csp, called a superposition LDPC code (or SP-LDPC code)
of length nt. The rate Rc of the SP-LDPC code Csp is at least (nt −mk)/nt and
depends on the parameters n, m, k, and t. For a given rate Rc, there are many
possible choices of n, m, k, and t. In the SP-construction of an LDPC code, the
matrix Bsp is called the base matrix (or SP-base matrix) and R is referred to as the
replacement set.
Let Gsp be the Tanner graph associated with the SP-base matrix Bsp, that
consists of n VNs and m CNs, labeled by v0, v1, ..., vn−1 and c0, c1, ..., cm−1,
respectively. The Tanner graph associated with the matrix Hsp(k,t), denoted by
Gsp(k,t), consists of nt VNs and mk CNs. Now, we partition the nt VNs of
Gsp(k,t) into n disjoint sets, denoted by 0, 1, ..., n−1. For 0 ≤j < n,  j
consists of t VNs of Gsp(k,t), which correspond to the t columns of the j-th
column-block H j of Hsp(k,t). The t VNs in  j are referred to as the type- j
VNs of Gsp(k,t). The t type- j VNs in  j are simply t copies of the VN v j of
the Tanner graph Gsp associated with the SP-base matrix Bsp. Next, we partition
the mk CNs of Gsp(k,t) into m disjoint sets, denoted by 0, 1, ..., m−1. For
0 ≤i < m, i consists of k CNs of Gsp(k,t), which correspond to the k rows of
the i-th row-block Mi of Hsp(k,t). The k CNs in i are referred to as the type-i
CNs of Gsp(k,t). The k CNs in i are simply k copies of CN ci of the Tanner
graph Gsp.
The SP-operation simply expands each VN in Gsp into t VNs in Gsp(k,t) and
each CN in Gsp into k CNs in Gsp(k,t). In Gsp(k,t), the VNs in 0, 1, ...,
n−1 are connected to the CNs in 0, 1, ..., m−1 based on the 1-entries in
the member matrices of R that are used to replace the nonzero entries in Bsp. The
graph Gsp(k,t) may be viewed as a Tanner graph consisting of n super-VNs, 0,
1, ..., n−1, and m super-CNs, 0, 1, ..., m−1, as shown in Fig. 5.1. The
t type- j VNs in  j can only connect to the k type-i CNs in i if there is an
edge ( j,i) in Gsp. The graph Gsp(k,t) is an expansion of the Tanner graph Gsp of
the SP-base matrix Bsp. In this expansion, if t  k, the VNs and CNs of Gsp are
expanded by two different factors (or degrees), t and k, respectively, (non-uniform
expansion). Therefore, from the graphical point of view, the SP-construction of the
Tanner graph of an SP-LDPC code is carried out using the following three steps:
(1) Design a small bipartite graph Gsp with n VNs and m CNs; (2) Duplicate each
VN v j of Gsp t times to form a set  j of t type- j VNs and duplicate each CN ci
of Gsp k times to form a set i of k type-i CNs; and (3) Connect the type- j VNs
and the type-i CNs by the type-( j,i) edges using edge permutations. Step 3 results
06
12:34:14, subject to the Cambridge Core terms of use,

5.2 Ensembles of SP-LDPC Codes
43
Figure 5.1. The Tanner graph Gsp(k,t) with super-VNs and super-CNs.
in an expanded and connected bipartite graph Gsp(k,t). Then, the null space of
the adjacency matrix Hsp(k,t) of the bipartite graph Gsp(k,t) gives an SP-LDPC
code. The connection of the t type- j VNs to the k type-i CNs can be speciﬁed by
a k ×t matrix, denoted by Ai, j and called a connection matrix. From the algebraic
SP point of view, the connection matrix Ai, j is simply a member matrix of the
replacement set R.
5.2 Ensembles of SP-LDPC Codes
For a given rate Rc, we choose the parameters m, n, k, and t such that Rc =
(nt −mk)/nt. Suppose we choose at random both an m × n SP-base matrix Bsp
and a replacement set R of k × t sparse constituent matrices over GF(2) (i.e., the
constituent matrices in R are chosen at random). Random replacements of the
1-entries of the SP-base matrix Bsp by the constituent matrices in R would result
in an ensemble, denoted by ξsp(k,t), of sparse arrays. This ensemble ξsp(k,t) of
sparse arrays gives an ensemble, denoted by Esp(k,t), of SP-LDPC codes of rate
Rc. The ensemble Esp(k,t) of SP-LDPC codes of rate Rc deﬁned above contains
two major subensembles with different structures, one for the case k = t and the
other for the case k  t.
Consider the case for which k = t and the member matrices in R are k × k
regular matrices. For this case, from the graphical point of view presented above,
the SP-operation duplicates each VN, each CN, and each edge of the associated
Tanner graph Gsp of the SP-base matrix Bsp k times (uniform expansion). This
amounts to duplicating the graph Gsp into k copies. These k copies of Gsp are then
connected by permuting their edges based on the member matrices in R that are
used to replace the 1-entries in Bsp. The connection of the k copies of Gsp results
in the Tanner graph Gsp(k,k) associated with the m × n array Hsp(k,k) which is
obtained by replacing the 1-entries of the SP-base matrix Bsp by the k × k regular
member matrices in the replacement set R. This shows that, for the case with k = t,
06
12:34:14, subject to the Cambridge Core terms of use,

44
5 Superposition Construction of LDPC Codes
an SP-LDPC code is a PTG-LDPC code (or vice versa, a PTG-LDPC code is an
SP-LDPC code). Hence, the ensemble Esp(k,k) of SP-LDPC codes of rate Rc is
an ensemble of PTG-LDPC codes of rate Rc.
From the algebraic construction of the ensemble Eptg of PTG-LDPC codes
given in Section 4.4 and the construction of the ensemble Esp(k,t) of SP-LDPC
codes given above, we readily see that the ensemble Eptg of PTG-LDPC codes
is equivalent to the special ensemble Esp(k,k) of SP-LDPC codes. This, in
turn, implies that the ensemble Esp(k,k) of SP-LDPC codes is equivalent to the
ensemble of PTG-LDPC codes investigated in [34] from the graphical point of
view. Therefore, for a properly designed SP-base matrix, the ensemble Esp(k,k)
is asymptotically good.
Based on the above interpretations of PTG-LDPC and SP-LDPC codes from
both the graph-theoretic and the algebraic (or matrix-theoretic) points of view and
the constructions of their ensembles, we see that the PTG-LDPC code construction
is a special case of the SP-LDPC code construction. The uniﬁcation of the SP
and the PTG-based constructions from both the algebraic and the graph-theoretic
points of view may lead to better designs and constructions of LDPC codes with
good overall performance in terms of the error performance in the waterfall region,
the error-ﬂoor location, and the rate of decoding convergence.
For the case k  t, the member matrices in the replacement set R for the
SP-construction of LDPC codes are not regular. In this case, the VNs and the CNs
in the Tanner graph of an SP-LDPC code are expanded by two different factors,
one by t and the other by k, i.e., the expansion of the Tanner graph is not uniform.
This non-uniform expansion deﬁnes another ensemble, denoted by E′
sp(k,t), of
the ensemble Esp(k,t) of SP-LDPC codes. An analysis of the ensemble E′
sp(k,t)
could be difﬁcult, but it is a good research problem. In the following chapters,
QC-SP-LDPC codes with k  t are constructed and they perform well over both
the AWGNC and the BEC. This may be an indication that the ensemble E′
sp(k,t)
is also a good ensemble.
5.3 Constraints on the Construction of SP-LDPC Codes Free
of Cycles of Length 4
In designing an SP-LDPC code to avoid short cycles in its Tanner graph, especially
cycles of length 4, certain constraints must be imposed on the member matrices
of the replacement set R and the method of replacing the nonzero entries in the
SP-base matrix Bsp by the member matrices of R. First, the member matrices
in R must be designed to satisfy both the RC- and the PW-RC-constraints.
Second, in the replacement process, all the 1-entries in a row and a column of
Bsp must be replaced by distinct member matrices in R (unless they are CPMs).
06
12:34:14, subject to the Cambridge Core terms of use,

5.3 Constraints on the SP-Construction
45
This replacement rule is called the replacement constraint [76, 110, 109, 111, 97].
The RC- and the PW-RC-constraints on the member matrices of the replacement
set R and the constraint on the replacement of the nonzero entries of the SP-base
matrix Bsp by the member matrices of R are necessary but not sufﬁcient to
guarantee that the Tanner graph of the constructed SP-LDPC code is free of
cycles of length 4, i.e., its girth is at least 6. However, if the base matrix Bsp
also satisﬁes the RC-constraint, then the SP-construction under the replacement
constraint will result in an SP-LDPC code whose the Tanner graph has girth at
least 6 [76, 110, 109, 111, 97].
If the base matrix Bsp is a weight-w n × n circulant, the SP replacement
constraint can be met easily. First, we replace the w 1-entries in the top row of
Bsp by w distinct member matrices in R. This replacement results in a row-block
(generator row-block) that consists of n submatrices of size k × t, including
w nonzero matrices and n −w ZMs. Then, we cyclically shift this generator
row-block n −1 times, each time one submatrix to the right. This results in an
n × n array Hsp(k,t) with n row-blocks and n column-blocks. The w nonzero
matrices (member matrices in R) in each row-block (or column-block) are distinct.
Therefore, the replacement constraint is satisﬁed. The above replacement is called
cyclic replacement.
A replacement set R whose member matrices satisfy both the RC- and the
PW-RC-constraints is called an RC-constrained replacement set. Constructions
of RC-constrained SP-base matrices and RC-constrained replacement sets will be
discussed further in Chapter 6.
From the above discussion, we see that the SP-construction is a very general
algebraic construction of LDPC codes. It can be interpreted from either the
matrix-theoretic point of view or the graph-theoretic point of view. From the
perspective of simplicity, the matrix-theoretic approach to the SP-construction of
LDPC codes is preferable in terms of designs of base matrices and replacement
sets, as will be shown in later chapters.
In the following, we give a simple example to illustrate the SP-construction of
an LDPC code and its graphical structure.
Example 5.1. Consider the following base matrix Bsp and the replacement set
R for constructing an SP-LDPC code:
Bsp =
⎡
⎣
1
0
1
1
1
0
0
1
1
⎤
⎦,
R =

A0 =
	 1
0
1
0
1
0

, A1 =
	 1
0
0
0
0
1


.
06
12:34:14, subject to the Cambridge Core terms of use,

46
5 Superposition Construction of LDPC Codes
We see that the base matrix Bsp satisﬁes the RC-constraint and the two
constituent matrices in R satisfy the RC- and the PW-RC-constraints. Note that Bsp
is a circulant. Next, we replace the 1-entries and 0-entries of the base matrix Bsp by
the 2 × 3 constituent matrices in R and 2 × 3 ZMs, respectively. The replacement
results in a 3 × 3 array Hsp(2,3) of 2 × 3 matrices. Under the replacement
constraint, there are several possible replacements. One such a replacement (a
cyclic replacement as described above) gives the following array:
It is easy to check that the array Hsp(2,3), a 6 × 9 matrix over GF(2), satisﬁes
the RC-constraint. The null space of Hsp(2,3) gives a (9,3) QC-SP-LDPC code
Csp in block-cyclic form. The Tanner graph Gsp associated with the base matrix
Bsp and the Tanner graph Gsp(2,3) associated with the array Hsp(2,3) are shown
in Fig. 5.2(a) and Fig. 5.2(b), respectively. We see that Gsp(2,3) is an expansion
of Gsp. In Gsp, each VN is expanded by a factor of 3 and each CN is expanded by
a factor of 2. The Tanner graph Gsp is non-uniformly expanded and their VNs and
CNs are connected based on the two constituent matrices A0 and A1 of R serving
as the connection matrices. Both Gsp and Gsp(2,3) have girth 6.
Now suppose we add (integer sum) the three constituent matrices of the
generator row-block of the 3 × 3 array Hsp(2,3). We obtain the following 2 × 3
matrix over nonnegative integers:
Bptg =
	 b0,0
b0,1
b0,2
b1,0
b1,1
b1,2

=
	 2
0
1
0
1
1

.
The matrix Bptg is simply the base matrix of the protograph Gptg shown in
Fig. 5.2(c). From the generator row-block of Hsp(2,3), we ﬁnd the generators of
the six circulants of size 3 × 3 as described in Section 4.1, which are:
g0,0 = (1,0,1),
g0,1 = (0,0,0),
g0,2 = (1,0,0),
g1,0 = (0,0,0),
g1,1 = (1,0,0),
g1,2 = (0,0,1).
For 0 ≤i < 2 and 0 ≤j < 3, we replace the entry bi, j by the circulant Ai, j
generated by gi, j. This replacement results in the following 2×3 array of circulants
06
12:34:14, subject to the Cambridge Core terms of use,

5.3 Constraints on the SP-Construction
47
(a)
(b)
(c)
Figure 5.2. (a) The Tanner graph Gsp associated with the base matrix Bsp given
in Example 5.1; (b) the Tanner graph Gsp(2,3) associated with the array Hsp(2,3)
in Example 5.1; and (c) the protograph Gptg associated with the base matrix Bptg
given in Example 5.1.
and ZMs of size 3 × 3:
The array Hptg,qc(3,3) is the adjacency matrix of the Tanner graph Gptg(3,3)
obtained by expanding the protograph Gptg by a factor of 3. Note that b0,0 = 2,
and it is replaced by a weight-2 circulant. The null space of Hptg,qc(3,3) gives a
(9,6) QC-PTG-LDPC code C ptg,qc with a section-wise cyclic structure. Here, we
see that the QC-PTG-LDPC code Cptg,qc is constructed algebraically using the
SP-construction and is an SP-LDPC code.
06
12:34:14, subject to the Cambridge Core terms of use,

48
5 Superposition Construction of LDPC Codes
Note that the 2×3 array Hptg,qc(3,3) can also be obtained from the 3×3 array
Hsp(2,3) by permuting the rows and columns using permutations similar to πrow
and πcol deﬁned by (4.3) and (4.5). The Tanner graphs Gsp(2,3) and Gptg(3,3)
are structurally identical, i.e., one can be obtained from the other by permuting the
VNs and the CNs. The above shows again the connection between a PTG-LDPC
code and an SP-LDPC code.
5.4 SP-Construction of QC-LDPC Codes
Suppose the member matrices of the replacement set R are sparse binary circulants
of the same size k ×k, not necessarily of the same weight. Replacing the 1-entries
in the binary m × n SP-base matrix Bsp by the member circulants in R and the
0-entries in Bsp by ZMs of size k × k, we obtain an m × n array Hsp,qc(k,k) =
[Ai, j]0≤i<m,0≤j<n of circulants and/or ZMs of size k × k in the form given by
(4.6). The null space of Hsp,qc(k,k) gives a binary QC-SP-LDPC code Csp,qc
of length nk. Typically, in binary QC-SP-LDPC code construction, the member
matrices in R are binary weight-1 circulants (i.e., CPMs) of size k × k.
Using the inverses of the row and column permutations deﬁned by (4.3) and
(4.5), we can put the array Hsp,qc(k,k) into a k × k array Hsp,cyc(m,n) =
[Di, j]0≤i, j,<k of m × n matrices in the form given in (4.1) with a block-cyclic
structure. The integer sum of the constituent matrices of the generator row-block
(or any row- or column-block) of Hsp,cyc(m,n) gives the base matrix Bptg of the
protograph Gptg for the PTG-construction of the QC-PTG-LDPC code Cptg,qc (or
C ptg,cyc). This shows that the special case of the SP-construction with k = t and
the replacement set R being a set of circulants of size k ×k is exactly the algebraic
construction of a QC-PTG-LDPC code presented in Chapter 4.
Alternatively, if we combine the k constituent matrices of the top row-block
of the array Hsp,cyc(m,n) with corresponding entries added using the logic-OR
operation, we obtain an m × n binary matrix which is simply the SP-base matrix
Bsp for the SP-construction of the QC-SP-LDPC code Csp,qc.
Example 5.2. In this example, we show that, from the the SP-construction
point of view, the (2640,1320) QC-PTG-LDPC code given in Example 4.2 is a
QC-SP-LDPC code. The matrix used for constructing the QC-PTG-LDPC code
given by (4.7) is now taken as the SP-base matrix Bsp. The replacement set R
consists of a set of binary CPMs of size 330 × 330. In this set, there are 23
CPMs whose generators are speciﬁed by the locations of their single 1-entries
which are 10, 39, 68, 75, 79, 143, 148, 158, 163, 181, 202, 206, 209, 271,
274, 275, 284, 287, 294, 295, 297, 324, and 328. Replacing the 24 1-entries in
the base matrix Bsp by these CPMs in the pattern shown in (4.8), we obtain a
06
12:34:14, subject to the Cambridge Core terms of use,

5.5 SP-Base Matrices over Nonnegative Integers
49
4×8 array Hsp,qc(330,330) of CPMs and ZMs of size 330×330. The null space of
Hsp,qc(330,330) gives a (2640,1320) QC-SP-LDPC code Csp,qc which is exactly
the (2640,1320) QC-PTG-LDPC code Cptg,qc,1 given in Example 4.2.
Example 5.3. From the SP-construction point of view, the (8176,7156) QC-PTG-
LDPC code given in Example 4.3 is a QC-SP-LDPC code with the following base
matrix:
Bsp =
	 1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1

.
(5.1)
The 32 weight-2 circulants of size 511 × 511 whose generators are given in
Table 4.2 form the replacement set R. The (8176,7156) NASA-CCSDS standard
QC-LDPC code Cnasa cited in Example 4.3 is also a QC-SP-LDPC code, with
the matrix given by (5.1) as its SP-base matrix Bsp. The replacement set R for
constructing this code consists of 32 weight-2 circulants given in Table 4.2 and
labeled with NASA, which are constructed based on the 3-dimensional Euclidean
geometry EG(3,23) over GF(23) [97].
Note that, in constructing a QC-SP-LDPC code, each member matrix in the
replacement set R can be a b × c array of CPMs of the same size. In this case, the
replacement of the 1-entries in the SP-base matrix by member arrays in R results
in a parity-check array of CPMs and ZMs of the same size. Constructions of
replacement sets whose member matrices are arrays of CPMs and/or ZMs will
be discussed in Chapters 6–11.
5.5 SP-Base Matrices over Nonnegative Integers
The base matrix Bsp for the SP-construction of LDPC codes can be a matrix
over nonnegative integers. Similar to the PTG-based construction, a nonzero entry
represents the number of parallel edges connecting a VN and a CN in its associated
Tanner graph. In this case, the constituent matrices in the replacement set R are
designed (or constructed) as regular matrices with weights in agreement with
integer entries in Bsp. In the construction of a parity-check array, an integer entry
w in the SP-base matrix Bsp is replaced by a member matrix in R with weight
w. As an example, suppose we take the base matrix given by (4.9) as the base
matrix for the SP-construction of a QC-SP-LDPC code. Since all of its entries
are 2s, then the member matrices of the replacement set R are circulants with
weight-2. Therefore, the (4,32)-regular (8176,7156) QC-PTG-LDPC code given
in Example 4.3 (also the NASA CCSDS standard (8176,7156) code Cnasa) may be
regarded as a QC-SP-LDPC code whose SP-base matrix contains only 2-entries.
06
12:34:14, subject to the Cambridge Core terms of use,

50
5 Superposition Construction of LDPC Codes
In Chapter 7, we will present methods for constructing SP-LDPC codes using
base matrices over NB ﬁelds, which are not considered in the conventional
PTG-based construction. So the base matrix for constructing an SP-LDPC code
can be a binary matrix, a matrix over nonnegative integers, or a matrix over a
ﬁnite ﬁeld.
5.6 Discussion and Remarks
As presented in Section 5.2, two major ensembles of SP-LDPC codes for a given
rate can be formed. One ensemble is equivalent to the ensemble of PTG-LDPC
codes. In forming this ensemble, the member matrices in the replacement set
R for the SP-construction of LDPC codes are regular. Since this ensemble is
equivalent to the ensemble of PTG-LDPC codes, SP-LDPC codes in this ensemble
have asymptotically good performance and structural properties. For the other
ensemble, the member matrices in the replacement set R for the SP-construction
of LDPC codes are not regular. Whether this ensemble of SP-LDPC codes has
good asymptotic properties and performance is unknown at this point. However,
some examples given in later chapters show that SP-LDPC codes constructed
using non-regular matrices for replacement do perform very well. This may be
an indication that this ensemble is a good ensemble. An analysis of this ensemble
is a good research problem.
It is known that the EXIT chart approach can be applied to PTG-LDPC codes
[80, 2]. Whether the EXIT chart approach can also be applied to SP-LDPC codes
is another interesting problem to look at.
In the SP-construction of an LDPC code with an m × n base matrix Bsp and
a replacement set R, suppose the member matrices of R are k × t arrays of l × l
regular matrices (e.g., PMs or CPMs). Then, the replacement of 1-entries of the
base matrix Bsp by member arrays in R and 0-entries by kl × tl ZMs results in
a parity-check matrix Hsp(kl,tl) which is an mk × nt array of regular matrices
and/or ZMs of size l ×l. In this case, the null space of Hsp(kl,tl) may be regarded
as an SP-LDPC code constructed from an mk × nt base matrix and a replacement
set whose constituent matrices are regular matrices of size l × l. From the PTG
point of view, the code is also a PTG-LDPC code whose protograph has nt VNs
and mk CNs. Various constructions of RC-constrained replacement sets whose
member matrices are arrays of regular matrices, especially PMs or CPMs, will be
discussed in later chapters and in Appendix A.
06
12:34:14, subject to the Cambridge Core terms of use,

6
Construction of Base Matrices and RC-Constrained
Replacement Sets for SP-Construction
The two key components in the SP-construction of an LDPC code are an SP-base
matrix Bsp and a replacement set R of sparse member matrices. To ensure that the
Tanner graph of an SP-LDPC code has girth at least 6, it is, in general, required
that the SP-base matrix Bsp satisﬁes the RC-constraint and the member matrices
in the replacement set R satisfy both the RC- and the PW-RC-constraints. In this
chapter, we present several algebraic constructions of RC-constrained SP-base
matrices and replacement sets whose member matrices satisfy both the RC- and
the PW-RC-constraints. More constructions of RC-constrained SP-base matrices
and replacement sets will be presented in Chapters 7 to 11 and Appendix A.
6.1 RC-Constrained Base Matrices
The algebraic methods presented in [58, 35, 3, 101, 112, 64, 65, 50, 113, 114, 46,
70, 68] can be used to construct RC-constrained SP-base matrices. All these meth-
ods are based on ﬁnite geometries, ﬁnite ﬁelds, and combinatorial designs (such as
balanced incomplete block designs (BIBDs) or Latin squares). In this section, we
use the construction based on ﬁnite Euclidean geometries. In Chapter 7, we will
present a very ﬂexible and powerful construction based on ﬁnite ﬁelds.
Consider the two-dimensional Euclidean geometry (EG) over the ﬁeld GF(q)
[84, 74, 97] (see Appendix A), denoted by EG(2,q). This geometry consists of
q2 + q lines, each consisting of q points. Among these lines, q + 1 lines pass
through the origin of the geometry. Based on the q2 −1 lines of EG(2,q) not
passing through the origin, it is possible to construct a (q + 1) × (q + 1) array
HEG of CPMs and ZMs of size (q −1) × (q −1) [46, 26] which satisﬁes the
RC-constraint [58, 97, 46] (see Appendix A). This array HEG contains q + 1
ZMs which can be put on the main diagonal of the array. Since HEG satisﬁes
the RC-constraint, any subarray of HEG also satisﬁes the RC-constraint and hence
51
07
12:35:45, subject to the Cambridge Core terms of use,

52
6 Base Matrix and Replacement Set Construction
can be used as an SP-base matrix for constructing an SP-LDPC code. The Tanner
graph of the SP-LDPC code constructed based on this SP-base matrix has girth at
least 6.
If we replace some CPMs by ZMs in a subarray of HEG, it is possible to obtain
an SP-LDPC code whose Tanner graph has girth at least 8, or a smaller number
of short cycles of lengths 6, 8, and 10. The replacement of a CPM by a ZM is
referred to as masking [112, 64, 97, 68]. Masking a subarray of HEG may result in
an SP-LDPC code with good error performance. Masking will be discussed further
in Chapter 7.
There is another method for constructing SP-base matrices based on the
two-dimensional geometry EG(2,q) over GF(q). Using the q2−1 lines of EG(2,q)
not passing through the origin, we can construct a weight-q binary circulant,
denoted by GEG, of size (q2 −1) × (q2 −1), which satisﬁes the RC-constraint
[58, 74, 97, 46, 26]. This circulant can be used as the base matrix for constructing
SP-LDPC codes. If the weight q is too large, we can replace l 1-entries in its
generator by 0-entries with l < q. This gives a new generator with q −l nonzero
components. The circulant generated by this new generator has weight (q −l).
The new circulant is called a descendant of GEG. Clearly, it also satisﬁes the
RC-constraint and can be used as an SP-base matrix for constructing SP-LDPC
codes. This construction gives SP-base matrices with a cyclic structure.
The circulant GEG can be decomposed into a group of descendants of the
same size to form SP-base matrices for the SP-construction of LDPC codes.
Let e be a positive integer less than q. We decompose the generator g of the
circulant GEG into e new generators g0, g1, ..., ge−1 of the same length with
the q nonzero components in g distributed among the e new generators. Each
nonzero component in g is put in one and only one new generator gi at the same
position as its original position in g. Let w0, w1, ..., we−1 be e positive integers
such that w0 + w1 + ... + we−1 = q. For 0 ≤i < e, let wi be the number of
nonzero components in g that are put in gi. Let G0,G1,...,Ge−1 be the circulants
generated by g0,g2,...,ge−1, respectively. These e circulants G0, G1, ..., Ge−1
are descendants of GEG with weights w0,w1,...,we−1, respectively. It follows
from the construction of their generators that these e descendants of GEG are
mutually disjoint and their logic-OR sum G0 +G1 +...+Ge−1 gives GEG. Since
GEG satisﬁes the RC-constraint, its descendants must satisfy both the RC- and the
PW-RC-constraints. Each descendant of GEG can be used as an SP-base matrix.
For 1 ≤r < e, if we take r of these descendants of GEG and arrange them as a row
(or a column) to form a (q2 −1) ×r(q2 −1) (or an r(q2 −1) × (q2 −1)) matrix,
then this matrix also satisﬁes the RC-constraint and can be used as an SP-base
matrix for the SP-construction of LDPC codes. With properly chosen e and
weights w0,w1,...,we−1, we can form regular or irregular base matrices for the
07
12:35:45, subject to the Cambridge Core terms of use,

6.2 Replacement Sets Based on Hamming Codes
53
SP-construction of LDPC codes. An EG circulant GEG can also be decomposed
as an array of circulants of the same size and this array (or its subarray) can be
used as an SP-base matrix [19, 74, 97].
As an example, suppose we use the two-dimensional Euclidean geometry
EG(2,7) over GF(7) for constructing SP-base matrices. Based on the 48 lines not
passing through the origin of EG(2,7), we can construct a 48 × 48 circulant GEG
with weight 7. This 48 × 48 circulant can be used as an SP-base matrix. Suppose
we decompose this circulant into three descendant circulants G0, G1, and G2, the
ﬁrst two with weight 3 and the third one with weight 1. Arranging the ﬁrst two
descendant circulants, G0 and G1, in a row, we obtain a 48 × 96 SP-base matrix
Bsp with column and row weights 3 and 6, respectively. The Tanner graph of the
base matrix Bsp has girth 6.
Besides ﬁnite geometries, large classes of RC-constrained arrays of CPMs and
ZMs can be constructed from ﬁnite ﬁelds. One very ﬂexible construction is based
on two arbitrary subsets of a ﬁnite ﬁeld reported recently in [70, 68]. This general
construction includes several other known constructions of LDPC codes based
on ﬁnite ﬁelds as special cases. This construction method will be presented in
Chapter 7 to construct QC-SP-LDPC codes. The PEG algorithm [43, 44] can also
be used to design base matrices for the SP-construction of LDPC codes, especially
irregular LDPC codes.
Note that the RC-constrained circulant (or its descendant) constructed based
on a two-dimensional Euclidean geometry EG(2,q) can be used as a base matrix
for constructing an RC-constrained parity-check array of a QC-PTG-LDPC code
using the matrix decomposition method presented in Section 4.1.
6.2 Construction of RC-Constrained Replacement Sets Based
on Hamming Codes
Methods for constructing RC-constrained replacement sets for constructing
SP-LDPC codes were ﬁrst discussed in [76, 111]. In this and the next two sections,
we present three new methods for constructing RC-constrained replacement sets
for the SP-construction of LDPC codes, especially QC-SP-LDPC codes. More
discussion on the construction of RC-constrained replacement sets will be given in
Chapter 7 and Appendix A.
Let m be a positive integer with m ≥3. Consider the (2m −1,2m −m −1) cyclic
Hamming code C generated by a primitive polynomial p(X) of degree m over
GF(2) [74, 89]. The minimum weight, denoted by m-w, of this code is 3. Two
different m-w codewords cannot have more than one 1-component in common.
Otherwise, the sum of two m-w codewords would give a nonzero codeword with
07
12:35:45, subject to the Cambridge Core terms of use,

54
6 Base Matrix and Replacement Set Construction
weight less than 3, which contradicts the fact that the m-w of the code C is 3.
Let n = 2m −1. Let v = (v0,v1,...,vn−1) be an m-w codeword of C and v(i) be
its i-th cyclic shift (cyclically shifting v to the right i positions). It is clear that
v(0) = v(n) = v. Let ℓbe the smallest positive integer less than or equal to n such
that v(ℓ) = v. We call ℓthe cycle span of v. It is clear that ℓdivides n. If ℓ= n, then
v is said to be primitive. In this case, v and all its n −1 cyclic shifts are different.
If ℓ< n, then v is said to be nonprimitive. If v is nonprimitive, then its cycle span
ℓdivides n and is equal to 3ℓsince the m-w of the code is 3. If 3 is not a factor of
n or n is a prime, then every m-w codeword of C is primitive.
Since the weight distribution of a Hamming code is completely known
[74, 89, 8], the number of primitive m-w codewords can be determined and these
m-w codewords can be constructed [74]. The primitive m-w codewords in C can
be partitioned into cyclic classes, say k of them, denoted by Q0, Q1, ..., Qk−1.
Each cyclic class contains n m-w codewords of length n which are cyclic shifts
of each other. For each cyclic class Qi, we can construct an n × n circulant Gi
with its n m-w codewords as rows. This is achieved by using any m-w codeword
in Qi as the ﬁrst row and cyclically shifting it n −1 times to form the other
n −1 rows. The weight of the circulant Gi is 3. Note that any column of Gi is
also an m-w codeword in the Hamming code C. Based on the k cyclic classes
Q0, Q1, ..., Qk−1, we can construct k circulants, G0, G1, ..., Gk−1, each of size
n ×n. Since no two m-w codewords have more than one 1-component in common,
these circulants have the following properties: no two rows (or two columns) either
from the same circulant or from two different circulants, Gi and G j, have more
than one 1-component in common. Hence, the circulants G0, G1, ..., Gk−1 satisfy
both the RC- and the PW-RC-constraints and they can be used as the member
matrices of a replacement set RHam for the SP-construction of LDPC codes, where
the subscript “Ham” in RHam stands for “Hamming.”
For 0 ≤i < k, we decompose the circulant Gi into 3 descendant CPMs, Gi,0,
Gi,1, and Gi,2, each of size n × n. The decomposition is done in exactly the same
manner as the decomposition of an EG circulant described in Section 6.1, i.e., we
split the generator gi of Gi into 3 generators, gi,0, gi,1, and gi,2, each with a single
1-component, and then use each of these 3 generators to construct a CPM. Clearly,
these 3 CPMs satisfy the PW-RC-constraint. For 0 ≤i < k, we form the following
two matrices from Gi,0, Gi,1, and Gi,2: A0
i = [Gi,0Gi,1] and A1
i = [Gi,0Gi,1Gi,2],
where A0
i is an n × 2n matrix with constant column and row weights 1 and 2,
respectively, and A1
i is an n × 3n matrix with constant column and row weights 1
and 3, respectively. Next, we form the following two replacement sets: RHam,0 =
{A0
i : 0 ≤i < k} and RHam,1 = {A1
i : 0 ≤i < k}. Both of these two replacement sets
satisfy the RC- and the PW-RC-constraints and can be used for the SP-construction
of QC-SP-LDPC codes.
07
12:35:45, subject to the Cambridge Core terms of use,

6.2 Replacement Sets Based on Hamming Codes
55
Let r be an integer with 1 ≤r ≤k. Suppose we take r circulants from
G0, G1, ..., Gk−1, say the ﬁrst r of them, and form an n × nr matrix
Bsp = [G0 G1 ... Gr−1] which satisﬁes the RC-constraint. The matrix Bsp has
column and row weights, 3 and 3r, respectively, and can be used as an SP-base
matrix for the SP-construction of LDPC codes. Using this SP-base matrix and
the replacement set, either RHam,0 or RHam,1 given above, we can construct
SP-QC-LDPC codes whose Tanner graphs have girth at least 6.
Suppose we use Bsp = [G0 G1 ... Gr−1] as the base matrix for the
SP-construction of QC-SP-LDPC codes. Let all the binary CPMs of size l × l
be the constituent matrices of a replacement set Rcpm. Since these CPMs satisfy
both the RC- and the PW-RC-constraints, Rcpm is an RC-constrained replacement
set. Based on Bsp = [G0 G1 ... Gr−1] and Rcpm, we can construct a QC-LDPC
code of length nrl and rate at least (r −1)/r whose Tanner graph has girth at least
6. For r = 2,3,4,...,k, we can construct a sequence of QC-SP-LDPC codes with
rates at least 1/2,2/3,3/4,...,(k −1)/k.
What we have shown above is that, using the m-w codewords of a Hamming
code, we can form both the SP-base matrices as well as replacement sets for the
SP-construction of QC-SP-LDPC codes.
Example 6.1. Let m = 5. Consider the (31,26) cyclic Hamming code C generated
by the primitive polynomial p(X) = 1+ X2 + X5 over GF(2). Since 31 is a prime,
then every m-w codeword of C is primitive. The code C has 155 m-w codewords
which can be used to form 5 circulants G0, G1, G2, G3, and G4, of size 31 × 31,
each with weight 3. Decompose each of these 5 circulants into 3 descendant CPMs
of size 31 × 31. Based on these 5 groups of descendant CPMs, we can form an
RC-constrained replacement set RHam,1 using the method described above. Each
member matrix in RHam,1 is a 31×93 matrix with three CPMs in a row. Based on
this replacement set RHam,1 and a chosen base matrix, we can construct a family
of QC-SP-LDPC codes.
Suppose we construct a 15 × 15 circulant Bsp using the 15 lines not passing
through the origin of the two-dimensional Euclidean geometry EG(2,22) over
GF(22). The generator of the circulant Bsp has weight 4, i.e., Bsp is a weight-4
circulant. In the SP-construction, we use Bsp as the SP-base matrix and the set
RHam,1 as the replacement set. Replacing the 60 1-entries in Bsp with member
matrices in RHam,1 following the replacement constraint (see Section 5.3), we
obtain a 15×45 array Hsp,qc(31,31) of CPMs and ZMs of size 31×31. The array
Hsp,qc(31,31) is a 465×1359 matrix with constant column and row weights 4 and
12, respectively. The null space of this matrix gives a (4,12)-regular (1395,937)
QC-SP-LDPC code Csp,qc,Ham with rate 0.6717. The Tanner graph of this code
has girth 6 and contains 6200 cycles of length 6 and 164 951 cycles of length 8.
07
12:35:45, subject to the Cambridge Core terms of use,

56
6 Base Matrix and Replacement Set Construction
The BLER and BER performances of this code over the AWGNC decoded with
50 iterations of the MSA are shown in Fig. 6.1(a). We see that this code performs
well, at about 1.25 dB away from the SPB at a BLER of 10−8. The decoding
threshold of this code is 1.95 dB. At BERs 10−5 and 10−9, the code performs 1.0
and 1.55 dBs from the decoding threshold, respectively.
Fig. 6.1(b) shows the performance of the code Csp,qc,Ham over the BEC.
For the BEC, it performs about 0.14 from the Shannon limit at a UEBR
of 10−8.
If we put the array Hsp,qc(31,31) into the form of (4.1), we obtain a 31 ×
31 array Hptg,cyc(15,45) of submatrices of size 15 × 45 with a block-cyclic
structure. The integer sum of the constituent matrices in the top row-block of
Hptg,cyc(15,45) gives the 15×45 base matrix Bptg for constructing the above code
using the algebraic construction presented in Chapter 4. In the code construction
by using this base matrix, we can choose any decomposition factor. This would
result in a family of QC-PTG-LDPC codes.
Example 6.2. In Example 6.1, we used the (31,26) cyclic Hamming code C to
construct a replacement set for the SP-construction of a QC-SP-LDPC code, but
used a base matrix constructed based on a Euclidean geometry. Suppose we use
one of the ﬁve 31 × 31 circulants G0, G1, G2, G3, and G4 constructed from
the m-w codewords in C as the base matrix, denoted by Bsp,Ham and the same
replacement set RHam,1 constructed in Example 6.1 for the SP-construction. The
replacement of the 1-entries of the base matrix Bsp,Ham by the member matrices
in RHam,1 results in the 31 × 93 array Hsp,qc(31,31) of CPMs and ZMs of size
31 × 31 which is a 961 × 2883 matrix with column and row weights 3 and 9,
respectively.
The null space of Hsp,qc(31,31) gives a (3,9)-regular (2883,1927) QC-SP-
LDPC code Csp,qc,Ham with rate 0.6684. The Tanner graph of the code Csp,qc,Ham
has girth 6 and contains 2387 cycles of length 6 and 20 088 cycles of length
8. The BLER and BER performances of this code decoded with 50 iterations
of the MSA over the AWGNC are shown in Fig. 6.2(a). We see that the code
performs about 1.0 dB away from the SPB at a BLER of 10−4 and 1.4 dB away
from the Shannon limit at a BER of 10−5. Its performance over the BEC is
shown in Fig. 6.2(b). At a UEBR of 10−7, it performs within 0.1 of the Shannon
limit.
There is another way to construct SP-base matrices from the circulants
G0, G1, ..., Gk−1 constructed from a Hamming code. First, we use the k circulants
07
12:35:45, subject to the Cambridge Core terms of use,

6.2 Replacement Sets Based on Hamming Codes
57
1
1.5
2
2.5
3
3.5
4
4.5
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(1395, 937) Csp,qc,Ham, BLER
(1395, 937) Csp,qc,Ham, BER
SPB
Shannon Limit
0.18
0.2
0.22
0.24
0.26
0.28
0.3
0.32
0.34
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(1395, 937) Csp,qc,Ham, UEBLR
(1395, 937) Csp,qc,Ham, UEBR
Shannon Limit
Figure 6.1. (a) The BER and BLER performances of the (1395,937)
QC-SP-LDPC code Csp,qc,Ham given in Example 6.1 over the AWGNC; and
(b) performance of the code in (a) over the BEC.
07
12:35:45, subject to the Cambridge Core terms of use,

58
6 Base Matrix and Replacement Set Construction
1
1.2
1.4
1.6
1.8
2
2.2
2.4
2.6
2.8
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BER/BLER
Eb/N0
(2883, 1927), BER
(2883, 1927), BLER
Shannon limit
SPB
0.22
0.24
0.26
0.28
0.3
0.32
0.34
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBR/UEBLR
ε
(2883, 1927), UEBR
(2883, 1927), UEBLR
Shannon limit
Figure 6.2. (a) The BER and BLER performances of the (2883,1927)
QC-SP-LDPC codes Csp,qc,Ham given in Example 6.2 over the AWGNC; and
(b) performance of the code in (a) over the BEC.
07
12:35:45, subject to the Cambridge Core terms of use,

6.3 Replacement Sets Based on EG(m,2)
59
G0, G1, ..., Gk−1 to form a k × 1 column array as follows:
GHam =
⎡
⎢⎢⎣
G0
G1
···
Gk−1
⎤
⎥⎥⎦.
(6.1)
Since G0, G1, ..., Gk−1 satisfy both the RC- and PW-RC-constraints, the array
GHam satisﬁes the RC-constraint. For 0 ≤i < k, we decompose Gi into a row
of three CPMs of size n × n, denoted by Gi,0, Gi,1, and Gi,2. Next, we form the
following k × 3 array of CPMs of size n × n:
HHam(n,n) =
⎡
⎢⎢⎢⎣
G0,0
G0,1
G0,2
G1,0
G1,1
G1,2
...
...
...
Gk−1,0
Gk−1,1
Gk−1,2
⎤
⎥⎥⎥⎦.
(6.2)
It is clear that the array HHam(n,n) satisﬁes the RC-constraint. Any subarray of
HHam(n,n) can be used as an SP-base matrix for the SP-construction of LDPC
codes. Suppose we take the transpose of the array HHam(n,n). We obtain the
following 3 × k RC-constrained array:
H⋆
Ham(n,n) =
⎡
⎣
G0,0
G1,0
···
Gk−1,0
G0,1
G1,1
···
Gk−1,1
G0,2
G1,2
···
Gk−1,2
⎤
⎦.
(6.3)
Any subarray of H⋆
Ham(n,n) can be used as an SP-base matrix for the
SP-construction of LDPC codes. In fact, for 4 ≤ℓ< k, if we take a 3 × ℓ
subarray from H⋆
Ham(n,n), the null space of H⋆
Ham(n,n) gives a (3,ℓ)-regular
QC-SP-LDPC code of length ℓn with rate at least (ℓ−3)/ℓ, whose Tanner graph
has girth at least 6. For ℓ= 4, 5, 6, ..., k, we can construct a sequence of regular
QC-SP-LDPC codes with rates 1/4, 2/5, 1/2, ..., (k −3)/k.
6.3 Construction of RC-Constrained Replacement Sets Based on
m-dimensional Euclidean Geometry EG(m,2) over GF(2)
For any positive integer m ≥2, the m-dimensional Euclidean (or afﬁne) geometry
EG(m,2) over the binary ﬁeld GF(2) can be used to construct an RC-constrained
replacement set. The geometry EG(m,2) consists of (2m−1 −1) × (2m −1) lines
not passing through the origin of the geometry [74, 97]. Each of these lines
consists of 2 points. Based on the incidence vectors of these lines, we can form
07
12:35:45, subject to the Cambridge Core terms of use,

60
6 Base Matrix and Replacement Set Construction
2m−1 −1 circulants of size (2m −1) × (2m −1) with weight 2 [74, 97], denoted
by G0, G1, ..., Gs−1, where s = 2m−1 −1. Since two lines in EG(m,2) are either
parallel or intersect at one and only one point, all these circulants satisfy the RC-
and the PW-RC-constraints. Therefore, these circulants form an RC-constrained
replacement set for the SP-construction of QC-SP-LDPC codes. Furthermore, any
subset of the circulants G0, G1, ..., Gs−1 can be arranged in a row (or a column)
to form an SP-base matrix Bsp.
If we decompose each of the circulants G0,G1,...,Gs−1 into two CPMs of size
(2m −1) × (2m −1) and arrange them in a row to form a (2m −1) × 2(2m −1)
matrix, we obtain 2m−1 −1 matrices of size (2m −1)×2(2m −1). These matrices
also satisfy the RC- and the PW-RC-constraints and they form an RC-constrained
replacement set for the SP-construction of QC-SP-LDPC codes as well as base
matrices.
Example 6.3. Consider the geometry EG(5,2). Based on the 465 lines not passing
through the origin of the geometry, we can form 15 circulants G0, G1, ..., G14 of
size 31 × 31 which satisfy the RC- and the PW-RC-constraints. Using these 15
circulants of weight 2, we can form both SP-base matrices and RC-constrained
replacement sets for the SP-construction of QC-SP-LDPC codes.
Suppose we take two circulants G0 and G1 to form a 31 × 62 SP-base matrix
Bsp with column and row weights 2 and 4, respectively, and use G0, G1, ..., G14
as the replacement matrices to replace the 1-entries in Bsp. Then, we can form an
RC-constrained 31 × 62 array Hsp,qc(31,31) of circulants of size 31 × 31. This
array is a 961 × 1922 matrix with column and row weights 4 and 8, respectively.
The null space of this array gives a (4,8)-regular (1922,997) QC-SP-LDPC code
whose Tanner graph has girth at least 6. By using the cycle counting method in
[71], we ﬁnd that its Tanner graph has girth 6 and contains 7595 cycles of length 6
and 107 260 cycles of length 8. The BER and BLER performances of this code
over the AWGNC decoded with 50 iterations of the MSA and the UEBR and
UEBLR performances over the BEC are shown in Fig. 6.3(a) and Fig. 6.3(b),
respectively. At a BLER of 10−5, the code performs about 2.4 dB away from
the SPB. At a UEBR of 10−7, the code performs within 0.17 of the Shannon
limit (0.52).
For a large m, a large number of circulants of weight 2 that satisfy the
RC- and the PW-RC-constraints can be constructed to form replacement sets
for constructing QC-SP-LDPC codes. Each of these weight-2 circulants can
be decomposed into two circulants of weight 1 (CPMs). By properly grouping
circulants of weights 1 and 2, we can form both RC-constrained replacement sets
with member matrices of various weights, and SP-base matrices.
07
12:35:45, subject to the Cambridge Core terms of use,

6.3 Replacement Sets Based on EG(m,2)
61
0
0.5
1
1.5
2
2.5
3
3.5
4
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BER/BLER
Eb/N0
(1922, 997), BER
(1922, 997), BLER
Shannon limit
SPB
0.3
0.32
0.34
0.36
0.38
0.4
0.42
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(1922, 997), UEBLR
(1922, 997), UEBR
Figure 6.3. (a) The BER and BLER performances of the (1922,997)
QC-SP-LDPC code given in Example 6.3 over the AWGNC; and (b) performance
of the code in (a) over the BEC.
07
12:35:45, subject to the Cambridge Core terms of use,

62
6 Base Matrix and Replacement Set Construction
The class of m-dimensional Euclidean geometries EG(m,2) over GF(2) is well
known for its application in constructing Reed–Muller (RM) codes which have
good trellis structure [74, 89, 75] and can be decoded with the BCJR (or MAP)
decoding algorithm to achieve very good error performance [75, 89, 4]. It was
recently shown that the ensemble of RM codes achieves the capacity of the BEC
[61].
6.4 Construction of RC-Constrained Replacement Sets Based
on RC-Constrained Arrays of CPMs
RC-constrained replacement sets for the SP-construction of LDPC codes can be
constructed by decomposing an RC-constrained array of CPMs.
Let Hqc(l,l) be an m × n RC-constrained array of CPMs of size l × l. This
array consists of m row-blocks, denoted by A0,A1,...,Am−1, each consisting of
n CPMs of size l × l. Since each of these row-blocks of Hqc(l,l) is an l × ln
matrix with column weight 1, it certainly satisﬁes the RC-constraint. If we arrange
any two of these row-blocks in a row, we obtain an l × 2ln matrix which also has
column weight 1 and hence satisﬁes the RC-constraint. Note that this is true even
if the two row-blocks are identical. If we arrange any two of the m row-blocks of
Hqc(l,l) one on the top of the other, we obtain a 2×n subarray of Hqc(l,l). Since
Hqc(l,l) satisﬁes the RC-constraint, this subarray of Hqc(l,l) must also satisfy
the RC-constraint. In fact, for 1 ≤k < m, any k × n subarray that consists of k
row-blocks of Hqc(l,l) satisﬁes the RC-constraint. Based on these facts, the set
R = {A0,A1,...,Am−1} of l × ln matrices forms an RC-constrained replacement
set for the SP-construction of QC-SP-LDPC codes. In the SP-construction, if the
SP-base matrix Bsp satisﬁes the RC-constraint, replacing the 1-entries in each
column of Bsp with distinct member matrices in R will result in a QC-SP-LDPC
code whose Tanner graph has girth at least 6.
Major methods for constructing RC-constrained arrays of CPMs and/or ZMs can
be found in [35, 3, 101, 112, 64, 65, 50, 113, 114, 46, 70, 68]. In Section 6.1, it was
pointed out that an RC-constrained (q +1)×(q +1) array HEG of CPMs and ZMs
of size (q −1)×(q −1) can be constructed based on the lines not passing through
the origin of the two-dimensional Euclidean geometry EG(2,q) over GF(q) [46,
26] (also see Appendix A). This array contains exactly q + 1 ZMs which can be
put on the main diagonal of the array. Hence, for 1 ≤m,n ≤q + 1, any m × n
subarray HEG(q −1,q −1) of HEG, avoiding the ZMs, can be used to construct an
RC-constrained replacement set of m member matrices of size (q −1) × n(q −1)
for the SP-construction of QC-SP-LDPC codes. Constructions of arrays of CPMs
based on two types of ﬁnite geometries are presented in Appendix A.
07
12:35:45, subject to the Cambridge Core terms of use,

6.4 Replacement Sets Based on Arrays of CPMs
63
The array HHam(n,n) given by (6.2) constructed based on the m-w codewords
of a Hamming code can be used to construct RC-constrained replacement sets as
described above.
Another method for constructing RC-constrained array of CPMs and/or ZMs is
based on a Latin square [73, 113]. A Latin square of order q is a q × q matrix for
which each row and each column contains every element of a set of q elements
exactly once [73]. For every ﬁnite ﬁeld GF(q), a Latin square of order q can be
constructed [113]. Let α be a primitive element of GF(q). Then, α−∞= 0,α0 =
1,α,α2,...,αq−2 give all the q elements of GF(q). Let η be a nonzero element of
GF(q). Then, the q × q matrix L = [ηαi −α j] over GF(q), with the row index i
and column index j running through −∞,0,1,...,q −2, is a Latin square of order
q. If we disperse each nonzero entry in L into a CPM of size (q −1)×(q −1) (see
Chapter 2, Section 2.1) and each zero entry into a ZM of size (q −1)×(q −1), we
obtain an RC-constrained q × q array HLat of CPMs and ZMs of size (q −1) ×
(q −1) [113], where the subscript “Lat” in HLat stands for “Latin square.” There
are exactly q ZMs in HLat. If we choose η = 1, then the q ZMs lie on the main
diagonal of HLat. For 1 ≤m,n ≤q, any m × n subarray of HLat, avoiding the
ZMs, can be used to construct an RC-constrained replacement set of m constituent
matrices of size (q −1) × n(q −1) for the SP-construction of QC-LDPC codes.
Example 6.4. Using the Latin square over GF(25), we can construct a 32 × 32
RC-constrained array HLat of CPMs and ZMs of size 31 × 31 with the 32 ZMs
lying on the main diagonal of HLat. Choose a 29×3 subarray from HLat, avoiding
the ZMs. Based on this subarray, we can construct an RC-constrained replacement
set RLat with 29 matrices of size 31 × 93, each with column and row weights 1
and 3, respectively.
Suppose we use the base matrix Bsp given in Example 6.1 as the base matrix for
the SP-construction. This matrix is a 15 × 15 circulant with weight 4 constructed
based on the Euclidean geometry EG(2,22) over GF(22). Replacing the four
1-entries in each column of Bsp by 4 distinct arbitrary member matrices of RLat,
we obtain a 15 × 45 RC-constrained array Hsp,qc,Lat(31,31) of CPMs and ZMs
of size 31 × 31. It is a 465 × 1395 matrix with column and row weights 4
and 12, respectively. The null space of Hsp,qc,Lat(31,31) gives a (4,12)-regular
(1395,937) QC-SP-LDPC code Csp,qc,Lat with rate 0.6717. The Tanner graph
Gsp,qc,Lat(31,31) of this code has girth 6 and contains 6 200 cycles of length 6
and 164 951 cycles of length 8.
The BLER and BER performances of this code over the AWGNC decoded with
50 iterations of the MSA are shown in Fig. 6.4(a). Its performance over the BEC
is shown in Fig. 6.4(b). The code Csp,qc,Lat given above has the same length,
dimension, and rate as the code Csp,qc,Ham constructed in Example 6.1 but with
07
12:35:45, subject to the Cambridge Core terms of use,

64
6 Base Matrix and Replacement Set Construction
1
1.5
2
2.5
3
3.5
4
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(1395, 937) Csp,qc,Lat, BLER
(1395, 937) Csp,qc,Lat, BER
SPB
Shannon Limit
0.18
0.2
0.22
0.24
0.26
0.28
0.3
0.32
0.34
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(1395, 937) Csp,qc,Lat, UEBLR
(1395, 937) Csp,qc,Lat, UEBR
Shannon Limit
Figure 6.4. (a) The BER and BLER performances of the (1395,937)
QC-SP-LDPC code Csp,qc,Lat given in Example 6.4 over the AWGNC; and (b)
performance of the code in (a) over the BEC.
07
12:35:45, subject to the Cambridge Core terms of use,

6.4 Replacement Sets Based on Arrays of CPMs
65
Table 6.1. The code parameters of the QC-SP-LDPC codes constructed in Example 6.5
with different lengths and rates
Code
m × n
(Length,
dimension)
Rate
(wc,wr)
Girth
No. of
cycle-6
No. of
cycle-8
C0
30 × 2
(930, 472)
0.5075
(4, 8)
6
1736
25668
C1
29 × 3
(1395, 976)
0.6715
(4, 12)
6
5888
151552
C2
28 × 4
(1860, 1402)
0.7539
(4, 16)
6
15252
526318
C3
27 × 5
(2325, 1867)
0.8030
(4, 20)
6
30721
1345927
C4
26 × 6
(2790, 2332)
0.8358
(4, 24)
6
53320
2903553
C5
25 × 7
(3255, 2797)
0.8569
(4, 28)
6
86304
5469175
C6
24 × 8
(3720, 3262)
0.8769
(4, 32)
6
128774
9535817
C7
23 × 9
(4185, 3727)
0.8906
(4, 36)
6
185535
15491010
C8
22 × 10
(4650, 4192)
0.9015
(4, 40)
6
256886
23901310
C9
17 × 15
(6975, 6517)
0.9343
(4, 60)
6
881144
125243782
C10
12 × 20
(9300, 8842)
0.9508
(4, 80)
6
2113673
402691271
different structure. From Fig. 6.1 and Fig. 6.4, we see that the two codes perform
almost the same.
Example 6.5. Based on the above example, we can construct a family of
QC-SP-LDPC codes with different lengths and rates by choosing different m and
n. (Here, we only consider the case where the m × n subarray does not contain
any ZMs.) Based on the base matrix Bsp used in the above example and the
32×32 RC-constrained array HLat, we construct a family of QC-SP-LDPC codes
by choosing different m and n. The code parameters including length, dimension,
rate, column and row weights, and cycle distributions are given in Table 6.1. The
BER performances of these codes over the AWGNC decoded with 50 iterations of
the MSA are shown in Fig. 6.5. This ﬁgure shows that all the codes have no visible
error-ﬂoor down to a BER of 10−9 or 10−10.
In the above construction of an RC-constrained replacement set R for the
SP-construction, we put a restriction on the m × n array Hqc(l,l) that it does not
contain ZMs. With this restriction, every member matrix in R has constant column
weight 1 and constant row weight n. This restriction can be removed. In this case,
some of the member matrices in R may contain ZMs. With this replacement set
R, the replacement operation may result in an irregular array, i.e., a matrix with
multiple column and/or row weights. An irregular array with good column and
row weight distributions may result in an LDPC code with good waterfall error
performance.
07
12:35:45, subject to the Cambridge Core terms of use,

66
6 Base Matrix and Replacement Set Construction
2
2.4
2.8
3.2
3.6
4
4.4
4.8
5.2
5.6
6
10
−11
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
BER
Eb/N0(dB)
C0
C1
C2
C3
C4
C5
C6
C7
C8
C9
C10
Figure 6.5. The BER performances of a family of QC-SP-LDPC codes given in
Example 6.5 with different code lengths and rates over the AWGNC.
Example 6.6. In Example 6.4, instead of choosing a 29 × 3 subarray, we can
choose a 32 × 3 subarray and use it to construct an RC-constrained replacement
set RLat with 32 member matrices of size 31 × 93, in which there are 3 matrices
with two column weights (0 and 1) and constant row weight 2, and 29 matrices
with constant column weight 1 and constant row weight 3. Based on such a
replacement set and the same base matrix Bsp, we can construct an irregular
15×45 RC-constrained array H∗
sp,qc,Lat(31,31) of CPMs and ZMs of size 31×31.
This array H∗
sp,qc,Lat(31,31) has 155 weight-3 columns, 1240 weight-4 columns,
and 31 weight-10 rows, 93 weight-11 rows, and 341 weight-12 rows. The null
space of H∗
sp,qc,Lat(31,31) gives an irregular (1395,932) QC-SP-LDPC code
C∗
sp,qc,Lat with rate 0.6681. The rate of the code C∗
sp,qc,Lat is slightly lower than
that of the (1395,937) code Csp,qc,Lat constructed in Example 6.4. The BLER and
BER performances of this code over the AWGNC decoded with 50 iterations of
the MSA are included in Fig. 6.6(a). Its performance over the BEC is shown in
07
12:35:45, subject to the Cambridge Core terms of use,

6.4 Replacement Sets Based on Arrays of CPMs
67
Fig. 6.6(b). From Fig. 6.6, we see that the code C∗
sp,qc,Lat also performs well over
both the AWGNC and the BEC.
In constructing irregular QC-SP-LDPC codes with the SP-construction, it
is simpler to design a base matrix with the desired column and row weight
distributions (which are also the degree distributions of the VNs and the CNs of the
Tanner graph of the base matrix) and then replace its 1-entries with matrices in an
RC-constrained set R whose member matrices all have the same column and row
weights. Then, the replacement operation results in an array which has the same
column and row weight distributions as the base matrix. In the following example,
we use this method to construct an irregular QC-SP-LDPC code.
Example 6.7. Consider the following VN and CN degree distributions (calculated
using density evolution): γ (X) = 0.25X + 0.625X2 + 0.125X8 and ρ(X) =
0.0451X3 + 0.1076X4 + 0.2257X5 + 0.1597X6 + 0.3611X7 + 0.0868X8 +
0.0139X9, which are designed for constructing a rate-1/2 irregular QC-SP-LDPC
code.
Using the lines not passing through the origin of the two-dimensional Euclidean
geometry EG(2,17), we can construct a 288× 288 RC-constrained circulant GEG
of weight 17. Based on the degree distributions given above and the circulant GEG,
we can then construct a 288 × 576 SP-base matrix Bsp with column weights and
row weights in agreement with γ (X) and ρ(X). The construction of Bsp is done
as follows. First, we decompose the circulant GEG into 4 descendant circulants,
G0, G1, G2, and G3, with weight 2, 3, 3, and 9, respectively. The decomposition
is done as described in Section 6.1. The 4 descendant circulants G0, G1, G2, and
G3 of GEG satisfy both the RC- and the PW-RC-constraints. The SP-base matrix
Bsp consists of a 288 × 144 submatrix of G0 (the ﬁrst 144 columns of G0), the
entire circulant G1, a 288 × 72 submatrix of G2 (the ﬁrst 72 columns of G2),
and a 288 × 72 submatrix of G3 (the ﬁrst 72 columns of G3). Then, the base
matrix Bsp is a 288 × 576 binary matrix whose associated Tanner graph has the
degree distributions γ (X) and ρ(X). The row and column weight distributions (in
numbers of rows and columns) of this base matrix Bsp are given in Table 6.2. Since
the circulants G0, G1, G2, and G3 satisfy both the RC- and the PW-RC-constraints,
Bsp also satisﬁes the RC-constraint and its associated Tanner graph has girth at
least 6. Using the cycle counting algorithm proposed in [71], we ﬁnd that the
Tanner graph associated with Bsp has girth 6 and contains 2937 cycles of length 6.
Using the Latin square over GF(24), we can construct a 16 × 16 array HLat of
CPMs and ZMs of size 15×15 which satisﬁes the RC-constraint. Choose a 15×1
subarray (a single column-block of HLat) from HLat avoiding the ZMs. Based on
this subarray, we can construct an RC-constrained replacement set RLat with 15
CPMs of size 15×15 as member matrices. Based on the irregular base matrix Bsp
07
12:35:45, subject to the Cambridge Core terms of use,

68
6 Base Matrix and Replacement Set Construction
1
1.5
2
2.5
3
3.5
4
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(1395, 932) C*
sp,qc,Lat, BLER
(1395, 932) C*
sp,qc,Lat, BER
SPB
Shannon Limit
0.18
0.2
0.22
0.24
0.26
0.28
0.3
0.32
0.34
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(1395, 932) C*
sp,qc,Lat, UEBLR
(1395, 932) C*
sp,qc,Lat, UEBR
Shannon Limit
Figure 6.6. (a) The BER and BLER performances of the irregular (1395,932)
QC-SP-LDPC code C∗
sp,qc,Lat given in Example 6.6 over the AWGNC; and (b)
performance of the code in (a) over the BEC.
07
12:35:45, subject to the Cambridge Core terms of use,

6.5 Discussion and Remarks
69
Table 6.2. Row and column weight distributions of the SP-base
matrix Bsp given in Example 6.7
Column weight distribution
Row weight distribution
Column weight
No. of columns
Row weight
No. of rows
2
144
4
13
3
360
5
31
9
72
6
65
7
46
8
104
9
25
10
4
and the replacement set RLat constructed above and using the SP-construction,
we can construct an irregular 288 × 576 array Hsp,qc,Lat(15,15) of CPMs and
ZMs of size 15 × 15. The array Hsp,qc,Lat(15,15) is a 4320 × 8640 matrix over
GF(2) whose associated Tanner graph Gsp,qc,Lat(15,15) has the same node degree
distributions as the associated Tanner graph Gsp of the base matrix Bsp, i.e., γ (X)
and ρ(X).
The null space of Hsp,qc,Lat(15,15) gives an irregular (8640,4320) QC-SP-
LDPC code Csp,qc,Lat with rate 0.5. The decoding threshold is 0.65 dB. The BER
and BLER performances of this code over the AWGNC decoded with 50 iterations
of the MSA are shown in Fig. 6.7(a). At BERs of 10−5 and 10−8, the code performs
0.81 and 1.11 dBs away from the decoding threshold, respectively. At a BLER of
10−6, the code performs 1.1 dB away from the SPB and it performs 1.6 dB away
from the Shannon limit at a BER of 10−8.
Its UEBR and UEBLR performances over the BEC are shown in Fig. 6.7(b). At
a UEBR of 10−8, the code performs about 0.1 away from the Shannon limit (0.5).
6.5 Discussion and Remarks
The methods presented or mentioned for constructing RC-constrained base
matrices and replacement sets in this chapter are mostly based on ﬁnite ﬁelds
or ﬁnite geometries. However, combinatorial designs, such as Latin squares and
certain BIBDs, can also be used for constructing RC-constrained base matrices
and replacement sets. Construction of a Latin square over a ﬁnite ﬁeld GF(q)
will be further discussed in the next chapter. The CPM-dispersion of such a
Latin square gives an RC-constrained array HLat of CPMs and ZMs of size
07
12:35:45, subject to the Cambridge Core terms of use,

70
6 Base Matrix and Replacement Set Construction
0
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
2.2
2.4
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(8640, 4320), BLER
(8640, 4320), BER
Shannon Limit
SPB
0.39
0.4
0.41
0.42
0.43
0.44
0.45
0.46
0.47
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(8640, 4320), UEBLR
(8640, 4320), UEBR
Figure 6.7. (a) The BER and BLER performances of the (8640,4320)
QC-SP-LDPC code Csp,qc,Lat given in Example 6.7 over the AWGNC; and (b)
performance of the code in (a) over the BEC.
07
12:35:45, subject to the Cambridge Core terms of use,

6.5 Discussion and Remarks
71
(q −1) × (q −1). Using this array, we can construct both RC-constrained base
matrices and replacement sets for the SP-construction of QC-SP-LDPC codes.
Furthermore, the null space of any subarray of HLat gives a QC-LDPC code whose
Tanner graph has girth at least 6. Construction of QC-LDPC codes based on Latin
squares can be found in [113]. These QC-LDPC codes have good trapping set
structure [46].
Let X = {x0,x1,...,xϑ−1} be a set of ϑ objects and let X0,X1,...,Xb−1 be
b distinct subsets of X. These subsets are said to form a BIBD, denoted by B,
provided that they satisfy the following requirements [21, 98]: (1) For 0 ≤j < b,
each X j is a k-subset of X (i.e., consisting of k objects in X); (2) Each object
appears in exactly r of the b subsets X0,X1,...,Xb−1; (3) Every two objects
appear together in exactly λ of the b subsets X0,X1,...,Xb−1; and (4) The
parameters ϑ,k and λ satisfy 0 < λ and k < ϑ −1. The subsets X0,X1,...,Xb−1
are called blocks of B. A BIBD with parameters ϑ,b,k,r and λ is commonly
referred to as a (ϑ,b,r,k,λ)-BIBD (or a conﬁguration). Form a ϑ × b matrix
HBI BD = [hi, j]0≤i<ϑ,0≤j<b with rows corresponding to the ϑ objects and columns
corresponding to the b blocks of B, where hi, j = 1 if the i-th object of X is in the
j-th block of B, otherwise hi, j = 0. This matrix is called the incidence matrix of
B. It has constant column weight k and constant row weight r. For the special case
with λ = 1, any two rows (or two columns) of the matrix HBI BD have exactly
one location where they both have 1-components. Therefore, HBI BD satisﬁes the
RC-constraint. Any submatrix of this RC-constrained matrix HBI BD or HBI BD
itself can be used as a base matrix for the SP-construction of LDPC codes. For
several classes of BIBDs with λ = 1, the incidence matrix HBI BD of such a BIBD
consists of a row of circulants of weight k [21, 98, 97]. These circulants satisfy
both the RC- and the PW-RC-constraints and hence they can be used to form an
RC-constrained replacement set. Of course, a subset of these circulants arranged
in a row or a column can be used to form a base matrix for the SP-construction of
QC-SP-LDPC codes. Constructions of BIBDs with λ = 1 can be found in [9, 21].
A good coverage of constructions of LDPC codes using BIBDs with λ = 1 can be
found in [97, 3, 65].
Experimental results show that LDPC codes constructed based on BIBDs have
low error-ﬂoors. This is an indication that these codes may have good trapping set
structure, i.e., no small trapping sets. Investigation of the trapping set structure of
LDPC codes constructed based on BIBDs may be an interesting research problem.
A ﬁnal remark is that any RC-constrained base matrix constructed in this chapter
can be used as the base matrix for constructing PTG-LDPC codes using the matrix
decomposition method presented in Chapter 4.
07
12:35:45, subject to the Cambridge Core terms of use,

7
SP-Construction of QC-LDPC Codes Using
Matrix Dispersion and Masking
Since the discovery of SP-construction in 2002, many algebraic methods have been
developed for constructing QC-LDPC codes [58, 76, 110, 109, 35, 107, 3, 19, 39,
74, 111, 102, 101, 112, 64, 65, 116, 97, 100, 50, 99, 113, 114, 25, 46, 26, 70, 68,
77, 78]. These methods basically evolved from SP-construction and they all have
the same two ingredients as SP-construction, a base matrix and matrix expansion.
The base matrix is constructed over a NB ﬁeld satisfying certain constraints, in
contrast to the base matrix over nonnegative integers for the PTG-construction of
LDPC codes. These constraints ensure that the Tanner graph of the constructed
QC-LDPC code has girth at least 6 or 8. All these methods are special cases
of the SP-method for constructing QC-LDPC codes. Many codes with excellent
performance, especially very low error-ﬂoors, have been constructed. For example,
QC-LDPC codes with a BER as low as 10−15 without visible error-ﬂoors have
recently been reported in [70, 68, 77, 78].
In this chapter, we unify all these algebraic constructions under the framework
of the SP-construction. Also presented in this chapter is a technique, known as
masking [112, 64, 97], to shape a chosen base matrix such that the produced
QC-LDPC code has a better error performance. The masking technique is also
used to construct QC-LDPC codes for correcting bursts of erasures over the BEC.
Again, we only focus on binary LDPC codes.
7.1 A Deterministic SP-Construction of QC-LDPC Codes
Let α be a primitive element of GF(q). Then, α0= 1,α1,α2,...,αq−2 give all the
nonzero elements of GF(q). Let Bq,sp = [bi, j]0≤i<m,0≤j<n be an m × n matrix
over GF(q), where the subscript “q” stands for “q-ary.” Disperse each nonzero
entry of Bq,sp into a binary CPM of size (q −1) × (q −1) as described in
Section 2.1 and each 0-entry of Bq,sp into a ZM of size (q −1) × (q −1). This
72
08
12:37:45, subject to the Cambridge Core terms of use,

7.2 Conditions on Girth of CPM-QC-SP-LDPC Codes
73
results in an m × n array Hb,sp,qc(q −1,q −1) of binary CPMs and/or ZMs of
size (q −1) × (q −1), where the subscript “b” stands for “binary.” The array
Hb,sp,qc(q −1,q −1) is called the binary CPM-dispersion of the q-ary matrix
Bq,sp. The array Hb,sp,qc(q −1,q −1) is an m(q −1) × n(q −1) matrix over
GF(2). Note that the array is a binary expansion of the NB matrix Bq,sp (a
nonbinary-to-binary (NB-to-B) mapping). The null space of Hb,sp,qc(q −1,q −1)
gives a binary QC-LDPC code Cb,sp,qc of length n(q −1).
The above method for constructing binary QC-LDPC codes can be viewed
as an SP-construction with a deterministic CPM replacement for each nonzero
entry in the base matrix Bq,sp, i.e., each nonzero entry of Bq,sp is replaced by
a speciﬁc binary CPM of size (q −1) × (q −1). We call this SP-construction
the CPM-D-SP-construction, where the symbol “D” stands for “dispersion,” and
the matrix Bq,sp is the base matrix. The code Cb,sp,qc given by the null space of
Hb,sp,qc(q −1,q −1) is called a CPM-QC-SP-LDPC code. Most of the algebraic
methods for constructing QC-LDPC codes presented in [19, 39, 74, 111, 102,
101, 112, 64, 65, 116, 97, 100, 50, 99, 113, 114, 25, 46, 26, 70, 68, 77, 78] are
CPM-D-SP-construction and hence special cases of the SP-construction, where
the SP-base matrix in this case is constructed over an NB ﬁnite ﬁeld.
From the graph-theoretic point of view, the CPM-D-SP-construction is a speciﬁc
PTG-basedconstruction.TheTannergraphGq,sp associatedwiththeNBbasematrix
Bq,sp istheprotographfortheconstructionofthebinarycodeCb,sp,qc.SinceBq,sp is
a matrix over GF(q), the edges of Gq,sp are labeled with nonzero elements in GF(q).
In the PTG-based construction, the protograph Gq,sp is copied q −1 times and the
copies are connected by permuting their edges based on the binary CPM-dispersions
of the edge labels in Gq,sp. This copy-and-permute operation results in a connected
bipartitegraphwhoseadjacencymatrixisthebinaryparity-checkarrayHb,sp,qc(q −
1,q −1) of a binary QC-PTG-LDPC code Cb,ptg,qc which is exactly the binary
CPM-QC-SP-LDPC code Cb,sp,qc described above.
The nonzero entries in the base matrix Bq,sp can also be dispersed into binary
CPMs of size equal to, smaller than, or larger than q −1 as described in Section 2.1.
7.2 Conditions on Girth of CPM-QC-SP-LDPC Codes
The above CPM-D-SP-construction of a binary CPM-QC-SP-LDPC code reduces
to the construction of the base matrix Bq,sp over an NB ﬁeld GF(q). For such
a CPM-QC-SP-LDPC code, the girth of the Tanner graph of the code is related
to the choice of the base matrix Bq,sp. The following two theorems give the
necessary and sufﬁcient conditions on the base matrix Bq,sp for the Tanner graph
of a CPM-QC-SP-LDPC code to have girth at least 6 and 8, respectively. These
08
12:37:45, subject to the Cambridge Core terms of use,

74
7 SP-Construction by Matrix Dispersion and Masking
two theorems were proved in [25, 26]. Here, we rephrase them in terms of the
CPM-D-SP-construction.
Theorem 7.1. Let Bq,sp be the base matrix of a binary CPM-QC-SP-LDPC
code Cb,sp,qc whose parity-check matrix Hb,sp,qc(q −1,q −1) is the binary
CPM-dispersion of Bq,sp. A necessary and sufﬁcient condition for the Tanner
graph of Cb,sp,qc to have girth at least 6 is that every 2 × 2 submatrix in the base
matrix Bq,sp contains at least one zero entry or is non-singular.
Theorem 7.2. A necessary and sufﬁcient condition for the Tanner graph of a
binary CPM-QC-SP-LDPC code Cb,sp,qc with base matrix Bq,sp to have girth
at least 8 is that no 2 × 2 or 3 × 3 submatrix in the base matrix Bq,sp has two
identical nonzero terms in its determinant expansion.
For convenience, the conditions given in Theorems 7.1 and 7.2 are called
the 2 × 2 and the 3 × 3 submatrix (SM) constraints, respectively. In the
CPM-D-SP-construction of a binary CPM-QC-SP-LDPC code, the 2 × 2 and
the 3 × 3 SM-constraints are used to construct a base matrix. Note that the
conditions given in Theorems 7.1 and 7.2 imply that the parity-check matrix
Hb,sp,qc(q −1,q −1) obtained by dispersing the base matrix Bq,sp satisﬁes the
RC-constraint [25, 26]. Hence, the Tanner graph of the CPM-QC-SP-LDPC code
given by the null space of Hb,sp,qc(q −1,q −1) has girth at least 6.
7.3 A Finite Field Construction of 2 × 2 SM-Constrained
SP-Base Matrices and Their Associated
CPM-QC-SP-LDPC Codes
There are many algebraic methods for constructing NB base matrices that satisfy
the 2 × 2 SM-constraint given in Theorem 7.1 [19, 39, 74, 111, 102, 101, 64, 65,
116, 100, 50, 114, 70, 68, 78]. Among these methods, the most ﬂexible one is the
method proposed in [70, 68]. The construction is based on two arbitrary sets of a
chosen NB ﬁeld. In the following, we describe this method and its special cases
for later use of constructing doubly QC-, QC spatially coupled, and QC globally
coupled LDPC codes in Chapters 8 to 10, and NB LDPC codes in Chapter 11.
Let α be a primitive element of the ﬁeld GF(q). For 1 ≤m,n ≤q, let S0 =
{αi0,αi1,...,αim−1} and S1 = {α j0,α j1,...,α jn−1} be two arbitrary subsets of
elements in GF(q) with ik and jl in L ≜{−∞,0,1,2,...,q −2}, i0 < i1 < ... <
im−1 and j0 < j1 < ... < jn−1. Let η be any nonzero element in GF(q). We then
08
12:37:45, subject to the Cambridge Core terms of use,

7.3 A Finite Field SP-Construction
75
form the following m × n matrix over GF(q):
Bq,sp,s =
⎡
⎢⎢⎢⎣
ηαi0 + α j0
ηαi0 + α j1
···
ηαi0 + α jn−1
ηαi1 + α j0
ηαi1 + α j1
···
ηαi1 + α jn−1
...
...
...
...
ηαim−1 + α j0
ηαim−1 + α j1
···
ηαim−1 + α jn−1
⎤
⎥⎥⎥⎦.
(7.1)
Note that the entries of the above matrix Bq,sp,s are the linear sums of elements
from the two subsets S0 and S1. This matrix Bq,sp,s has the following structural
properties [68]: (1) All the entries in a row (or a column) of Bq,sp,s are distinct
elements of GF(q); (2) Each row (or each column) of Bq,sp,s contains at most
one zero element; and (3) No two rows (or two columns) in Bq,sp,s have identical
entries at any position. It was proved in [68] that the matrix Bq,sp,s satisﬁes the
2 × 2 SM-constraint.
If we disperse each entry in Bq,sp,s into a (q −1) × (q −1) binary CPM or
ZM, then the CPM-dispersion of Bq,sp,s results in an RC-constrained m × n array
Hb,sp,qc,s(q −1,q −1) of binary CPMs and/or ZMs of size (q −1) × (q −1).
The null space of Hb,sp,qc,s(q −1,q −1) gives a binary CPM-QC-SP-LDPC code
Cb,sp,qc whose Tanner graph has girth of at least 6. The subscript “s” in Bq,sp,s
and Hb,sp,qc,s(q −1,q −1) represents “sum-form” of Bq,sp,s given by (7.1).
There are two special cases of the base matrix given in (7.1). The ﬁrst case is
that S0 = S1 = GF(q) = {0,1,α,α2,...,αq−2}. In this case, Bq,sp,s is a q × q
matrix over GF(q) in which each row and each column contains every element of
GF(q) exactly once. Thus, Bq,sp,s is simply a Latin square over GF(q) deﬁned in
Section 6.4, where we use Latin squares over GF(q) to construct RC-constrained
replacement sets for the SP-construction of QC-SP-LDPC codes.
The second case is that S0 and S1 are two additive subgroups of the additive
group of GF(q) with orders m and n, respectively, such that m + n ≤q and
S0 ∩S1 = {0}. Let αi0 = α j0 = 0. In this case, the ﬁrst row of Bq,sp,s contains
the elements of the subgroup S1 and all the rows of Bq,sp,s are cosets of S1,
with elements in the set ηS0 = {ηαi0,ηαi1,...,ηαim−1} as coset leaders. The
construction of QC-LDPC codes based on two additive subgroups of the additive
group of GF(q) with orders m and n = q −m, respectively, and η = 1, was ﬁrst
proposed in [100] and later generalized in [50].
The construction of a 2×2 SM-constrained base matrix based on the two subsets
S0 and S1 of GF(q) can also be put in product-form as follows:
Bq,sp,p =
⎡
⎢⎢⎢⎣
αi0α j0 −η
αi0α j1 −η
···
αi0α jn−1 −η
αi1α j0 −η
αi1α j1 −η
···
αi1α jn−1 −η
...
...
...
...
αim−1α j0 −η
αim−1α j1 −η
···
αim−1α jn−1 −η
⎤
⎥⎥⎥⎦.
(7.2)
08
12:37:45, subject to the Cambridge Core terms of use,

76
7 SP-Construction by Matrix Dispersion and Masking
The null space of the binary CPM-dispersion of the base matrix Bq,sp,p, denoted
by Hb,sp,qc,p(q −1,q −1), gives a CPM-QC-SP-LDPC code. The subscript “p”
in Bq,sp,p and Hb,sp,qc,p(q −1,q −1) stands for the “product-form” of the base
matrix Bq,sp,p given by (7.2).
There are four special cases of the base matrix Bq,sp,p in the product-form
given in (7.2), which are summarized as follows. The ﬁrst case is that S0 = S1 =
GF(q)\{0} =

1,α,α2,...,αq−3,αq−2
and η = 1. In this case, the base matrix
Bq,sp,p deﬁned by (7.2) becomes the base matrix given by (4) in [64, p. 2432]
shown as follows:
Bq,sp,p =
⎡
⎢⎢⎢⎣
α0 −1
α −1
α2 −1 ··· αq−3 −1 αq−2 −1
α −1
α2 −1 α3 −1 ··· αq−2 −1
α0 −1
...
...
...
...
...
...
αq−2 −1 α0 −1 α1 −1 ··· αq−4 −1 αq−3 −1
⎤
⎥⎥⎥⎦.
(7.3)
It is a (q −1)×(q −1) matrix over GF(q). Note that each row of the base matrix
Bq,sp,p given by (7.3) is the cyclic-shift of the row above it one position to the left
and the top row is the cyclic-shift of the last row one position to the left. Each
column of Bq,sp,p is the cyclic-shift of the column on its left one place upward
and the ﬁrst column is the cyclic-shift of the last column upward one place. Hence,
it has a cyclic structure. We also note that for 0 ≤i < q −1, the i-th column is the
transpose of the i-th row and vice versa.
The second case is that S0 and S1 are two cyclic subgroups of the multiplicative
group of GF(q) with orders m and n, respectively, such that S0 ∩S1 = {1}, and
m and n are relatively prime factors of q −1. Let αi0 = α j0 = 1 and η = 1.
Then, all the entries in the matrix Bq,sp,p deﬁned by (7.2) are distinct elements
in GF(q). The construction of QC-LDPC codes based on two cyclic subgroups
of the multiplicative group of GF(q) with orders m and n, respectively, such that
mn = q −1 was ﬁrst proposed in [100] and later extended in [114].
The third case is that S0 = {α−j1,α−j2,...,α−jk}, S1 = {α j1,α j2,...,α jk},
and η = 1, where α j1, α j2, ..., α jk are all the primitive elements of GF(q) and
k = (q −1)t
i=1(1−1
pi ) in which p1, p2, ..., pt are all the prime factors of q −1.
Using these two sets of elements of GF(q), the base matrix Bq,sp,p constructed
from (7.2) is exactly the base matrix given by equation (4) of [100, p. 86] or
equation (11.17) of [97, p. 511].
For the fourth case, let GF(q2) be an extension ﬁeld of GF(q). Then, GF(q)
is a subﬁeld of GF(q2). Let α and β be two primitive elements of GF(q) and
GF(q2), respectively. We then have GF(q) = {0,1,α,α2,...,αq−2} and GF(q2) =
{0,1,β,β2,...,βq2−2}. There exists q distinct elements, β j0, β j1, ..., β jq−1 in
GF(q2) with j0, j1,..., jq−1 ∈{0,1,2,...,q2 −2}, in which β jk  αlβ0 and
08
12:37:45, subject to the Cambridge Core terms of use,

7.4 Masking
77
for i  k, β jk  1 + αlβ ji with 0 ≤l < q −1. Let S0 = {β j0,β j1,...,β jq−1},
S1 = GF(q) = {0,1,α,α2,...,αq−2}, and η = −1. In this case, the matrix Bq,sp,p
constructed based on these two subsets S0 and S1 of GF(q2) becomes the base
matrix given by equation (11.20) of [97, Chapter 11, p. 514], constructed based
on the two-dimensional Euclidean geometry EG(2,q) [97].
The above six special cases of the base matrices deﬁned by (7.1) and (7.2) in the
sum- and product-forms constructed based on two subsets of an NB ﬁeld GF(q) are
the major constructions of base matrices given in [35, 101, 64, 65, 100, 50, 113,
114]. In Chapters 8, 9, and 10, we will use the special case of the product-from
given in the form of (7.3) for constructing doubly, spatially coupled, and globally
coupled QC-LDPC codes, respectively.
7.4 Masking
Given an NB base matrix Bq,sp that satisﬁes the 2 × 2 SM-constraint, a shaping
operation can be performed on Bq,sp to obtain a new base matrix which can also
satisfy the 3×3 SM-constraint. The matrix shaping operation is known as masking
[112, 64, 97, 68].
Let Bq,sp = [bi, j]0≤i<m,0≤j<n be an m × n 2 × 2 SM-constrained base matrix
over GF(q). Suppose we replace a nonzero entry in Bq,sp by the zero-element of
GF(q). In the CPM-dispersion Hb,sp,qc(q −1,q −1) of Bq,sp, this replacement
results in replacing a (q −1) × (q −1) CPM in Hb,sp,qc(q −1,q −1) by a
(q −1) × (q −1) ZM which is referred to as masking. Let μ be a nonnegative
integer less than the number of nonzero entries in Bq,sp. The replacement of μ
nonzero entries in Bq,sp by μ zeros amounts to replacing μ CPMs by μ ZMs
at the locations in Hb,sp,qc(q −1,q −1) corresponding to the locations of the
μ nonzero entries in Bq,sp which are replaced by zeros. Masking μ CPMs in
Hb,sp,qc(q −1,q −1) amounts to removing μ(q −1) edges from the Tanner graph
Gb,sp,qc(q −1,q −1) associated with the array Hb,sp,qc(q −1,q −1). Removing
these edges from Gb,sp,qc(q −1,q −1) may break many short cycles. As a result,
the resultant Tanner graph, denoted by Gb,sp,qc,mask(q −1,q −1), may have a
smaller number of short cycles, or a larger girth (larger than 6), or both. The
subscript “mask” in Gb,sp,qc,mask(q −1,q −1) stands for “masking.” In choosing
the nonzero entries in Bq,sp to be masked, we have to avoid disconnecting the
Tanner graph of Hb,sp,qc(q −1,q −1) into disjoint graphs.
Masking the base matrix Bq,sp = [bi, j]0≤i<m,0≤j<n can be modeled math-
ematically as a Hadamard matrix product [42]. Let Z be an m × n matrix
with the zero and unit elements of GF(q) as entries in the form of Z =
[zi, j]0≤i<m,0≤j<n. Deﬁne the following product of Z and Bq,sp: Bq,sp,mask =
08
12:37:45, subject to the Cambridge Core terms of use,

78
7 SP-Construction by Matrix Dispersion and Masking
Z⊙Bq,sp = [zi, jbi, j]0≤i<m,0≤j<n where zi, jbi, j = bi, j if zi, j = 1 and zi, jbi, j = 0
if zi, j = 0. In this matrix product, the nonzero entries in Bq,sp at the locations
corresponding to the zero entries in Z are replaced (or masked) by zeros. The
binary CPM-dispersion of Bq,sp,mask gives an m × n masked array, denoted
by Hb,sp,qc,mask(q −1,q −1), of CPMs and ZMs of size (q −1) × (q −1).
We call Z and Bq,sp,mask the masking matrix and the masked base matrix,
respectively. The null space of Hb,sp,qc,mask(q −1,q −1) also gives a binary
CPM-QC-SP-LDPC code (called masked LDPC code), denoted by Cb,sp,qc,mask.
Since Bq,sp already satisﬁes the 2 × 2 SM-constraint, the masking matrix Z
should be designed to obtain a masked base matrix Bq,sp,mask which satisﬁes the
3 × 3 SM-constraint, called a 3 × 3 SM-constrained base matrix. In this case,
the Tanner graph Gb,sp,qc,mask(q −1,q −1) associated with the masked array
Hb,sp,qc,mask(q −1,q −1) has girth at least 8, as well as a small number of short
cycles. Binary CPM-dispersions of properly chosen base matrices in conjunction
with masking can result in CPM-QC-SP-LDPC codes with good error probability
as well as low error-ﬂoors.
Given an m × n base matrix Bq,sp, the problem of how to design a masking
matrix Z to produce a masked base matrix Bq,sp,mask which results in a
CPM-QC-SP-LDPC code whose Tanner graph not only has a large girth but also
contains a small number of short cycles, is challenging. If the base matrix Bq,sp
satisﬁes the 2 × 2 SM-constraint, a general guideline is to construct a masking
matrix which yields a masked based matrix Bq,sp,mask in which each 3 × 3
submatrix contains at least one zero entry. This may produce a masked base matrix
that satisﬁes the 3 × 3 SM-constraint given in Theorem 7.2. For constructing an
irregular CPM-QC-SP-LDPC code based on designed degree distributions of VNs
and CNs of its Tanner graph, the masking matrix must be constructed with column
and row weight distributions matching the VN and CN degree distributions of
the optimized Tanner graph. This can be achieved by using the PEG algorithm
with computer search. In the PTG-based construction of LDPC codes, the PEG
algorithm is often used to design a protograph.
In the following, we illustrate the CPM-D-SP-construction of LDPC codes
using several examples, and demonstrate the effectiveness of the masking
technique.
Example 7.1. Let α be a primitive element of the prime ﬁeld GF(331). Set m = 4,
n = 8, and η = 1. We choose the following two subsets of GF(331) for constructing
a base matrix using the sum-form given by (7.1): S0 = { α112, α115, α148, α317}
and S1 = {α24,α112,α115,α234,α236,α274,α316,α320}. The elements of these two
sets are chosen at random from the ﬁeld GF(331). Using the construction given by
08
12:37:45, subject to the Cambridge Core terms of use,

7.4 Masking
79
(7.1), we obtain the following 4 × 8 base matrix Bq,sp,s over GF(331):
Bq,sp,s =
⎡
⎢⎢⎣
α39
α123
α79
α190
α294
α328
α297
α68
α139
α79
α126
α75
α158
α295
α148
α274
α206
α209
α287
α324
α163
α129
α202
α325
α181
α271
α275
α143
α208
α10
α173
α284
⎤
⎥⎥⎦.
(7.4)
This base matrix satisﬁes the 2×2 SM-constraint but not the 3×3 SM-constraint
given in Theorem 7.2. All the entries in this matrix are nonzero elements in
GF(331). The binary CPM-dispersion of this base matrix gives a 4 × 8 array
Hb,sp,qc,s(330,330) of binary CPMs of size 330 × 330. The Tanner graph
Gb,sp,qc,s(330,330) associated with the array Hb,sp,qc,s(330,330) has girth 6 and
contains 990 cycles of length six, 24 750 cycles of length 8, and 389 400 cycles of
length 10.
Suppose we mask the base matrix Bq,sp,s with the following masking matrix:
Z =
⎡
⎢⎢⎣
1
0
1
0
1
1
1
1
0
1
0
1
1
1
1
1
1
1
1
1
1
0
1
0
1
1
1
1
0
1
0
1
⎤
⎥⎥⎦.
(7.5)
Note that every 3 × 3 submatrix of Z contains at least one 0-entry. Masking the
base matrix Bq,sp,s given by (7.4) with the masking matrix Z given by (7.5), we
obtain the following masked base matrix:
Bq,sp,s,mask =
⎡
⎢⎢⎣
α39
0
α79
0
α294
α328
α297
α68
0
α79
0
α75
α158
α295
α148
α274
α206
α209
α287
α324
α163
0
α202
0
α181
α271
α275
α143
0
α10
0
α284
⎤
⎥⎥⎦.
(7.6)
By checking, we ﬁnd that the masked base matrix Bq,sp,s,mask satisﬁes the
3 × 3 SM-constraint. The binary CPM-dispersion of Bq,sp,s,mask gives a 4 × 8
array Hb,sp,qc,s,mask(330,330) of binary CPMs and ZMs of size 330 × 330. It
is a 1320 × 2640 matrix with column and row weights 3 and 6, respectively.
Since Bq,sp,s,mask satisﬁes both the 2 × 2 and the 3 × 3 SM-constraints, it follows
from Theorem 7.2 that the Tanner graph Gb,sp,qc,s,mask(330,330) associated with
the array Hb,sp,qc,s,mask(330,330) has girth at least 8. Using the cycle counting
algorithm given in [71], we ﬁnd that Gb,sp,qc,s,mask(330,330) has girth 8 and
contains 990 cycles of length 8 and 8 580 cycles of length 10. We see that masking
the base matrix Bq,sp,s with Z not only increases the girth of the Tanner graph
08
12:37:45, subject to the Cambridge Core terms of use,

80
7 SP-Construction by Matrix Dispersion and Masking
associated with its CPM-dispersion Hb,sp,qc,s(330,330) (from 6 to 8) but also
greatly reduces the number of short cycles (lengths 6, 8, and 10).
The null space of Hb,sp,qc,s,mask(330,330) gives a (3,6)-regular (2640,1320)
CPM-QC-SP-LDPC code Cb,sp,qc,mask with rate 0.5. The BER and BLER
performances of this code decoded with 5, 10, and 50 iterations of the MSA are
shown in Fig. 7.1(a). The decoding of the code converges quickly. At a BER of
10−10, the gap between 5 and 10 iterations is about 1.8 dB and the gap between
10 and 50 iterations is within 0.8 dB. The code Cb,sp,qc,mask is the same code
given in Example 4.2 (the (2640,1320) QC-PTG-LDPC code C ptg,qc,1), where
we constructed the code using the algebraic method with the masking matrix
given by (7.5) as the base matrix for decomposition. Here, we construct the code
using the CPM-D-SP-construction in conjunction with the matrix given by (7.5)
as the masking matrix. This again shows the strong connection of the PTG-based
construction to the algebraic SP-construction.
The UEBR and UEBLR performances of the code Cb,sp,qc,mask over the BEC
are shown in Fig. 7.1(b). At a UEBR of 10−10, the code performs about 0.14 away
from the Shannon limit.
In Examples 4.2 and 7.1, we use the same 4 × 8 matrix given by (4.7) and
(7.5) in two different ways, one as a decomposition base matrix for the algebraic
construction of a PTG-LDPC code and the other as a masking matrix for the
SP-construction of an SP-LDPC code. Both ways result in a code with very good
performance, especially in the error-ﬂoor region. Thus, it would be interesting
to know whether a good binary masking matrix is also a good decomposition
base matrix for algebraic construction of PTG-LDPC codes. Another interesting
question is whether a large girth and a small number of short cycles result in a
good decoding threshold. These two problems deserve further investigation.
Example 7.2. In this example, we use the same ﬁeld GF(331) given in Exam-
ple 7.1 to construct another CPM-QC-SP-LDPC code of length 2640 and rate 0.5
as the (2640,1320) code given in Example 7.1. In Example 7.1, the elements of the
two subsets of GF(331) for constructing the code were chosen at random. However,
in this example, the elements of two subsets of GF(331) are chosen speciﬁcally to
construct a CPM-QC-SP-LDPC code whose Tanner graph has girth 10.
The two sets of GF(331) chosen for constructing the base matrix are:
S∗
0 = {α0,α1,α2,α3} and S∗
1 = {α130,α131,α132,α133,α134,α135,α136,α137}. The
ﬁrst subset consists of 4 consecutive powers of α, a primitive element of GF(331),
and the second subset consists of 8 consecutive powers of α. Based on these two
subsets with m = 4, n = 8, and η = −1, we construct a 4 × 8 base matrix B∗
q,sp,s
over GF(331). The CPM-dispersion of the base matrix B∗
q,sp,s gives a 4 × 8 array
H∗
b,sp,qc,s(330,330) of CPMs of size 330 × 330 (no ZM), a 1320 × 2640 matrix
08
12:37:45, subject to the Cambridge Core terms of use,

0
0.5
1
1.5
2
2.5
3
3.5
4
4.5
5
5.5
6
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(2640, 1320) Cb,sp,qc,mask, itr50, BLER
(2640, 1320) Cb,sp,qc,mask, itr50, BER
(2640, 1320) Cb,sp,qc,mask, itr10, BLER
(2640, 1320) Cb,sp,qc,mask, itr10, BER
(2640, 1320) Cb,sp,qc,mask, itr5, BLER
(2640, 1320) Cb,sp,qc,mask, itr5, BER
SPB
Shannon Limit
0.36
0.38
0.4
0.42
0.44
0.46
0.48
0.5
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(2640, 1320) Cb,sp,qc,mask, UEBLR
(2640, 1320) Cb,sp,qc,mask, UEBR
Shannon Limit
Figure 7.1. (a) The BER and BLER performances of the (2640,1320) code
Cb,sp,qc,mask given in Example 7.1 decoded with 5, 10, and 50 iterations of the
MSA over the AWGNC; and (b) performance of the code in (a) over the BEC.
08
12:37:45, subject to the Cambridge Core terms of use,

82
7 SP-Construction by Matrix Dispersion and Masking
over GF(2) with column and row weights 4 and 8, respectively. The Tanner graph
G∗
b,sp,qc,s(330,330) associated with the array H∗
b,sp,qc,s(330,330) has girth 6 and
contains 7260 cycles of length six, 34 650 cycles of length 8, and 499 620 cycles
of length 10 (a very large number of short cycles).
Suppose we mask the base matrix B∗
q,sp,s with the masking matrix Z given by
(7.5), the same masking matrix used in Example 7.1. Masking results in a masked
matrix B∗
q,sp,s,mask. The CPM-dispersion of B∗
q,sp,s,mask gives a 4 × 8 masked
array H∗
q,sp,qc,s,mask(330,330) of binary CPMs and ZMs of size 330 × 330, a
1320 × 2640 binary matrix with column and row weights 3 and 6, respectively.
The null space of the masked array H∗
q,sp,qc,s,mask(330,330) gives a (3,6)-regular
(2640,1320) CPM-QC-SP-LDPC code C∗
b,sp,qc,mask which has the same length
and rate as that of the code Cb,sp,qc,mask constructed in Example 7.1. The
Tanner graph of the code C∗
b,sp,qc,mask has girth 10 and contains 13 200 cycles
of length 10. We see that masking increases the girth of the Tanner graph
G∗
b,sp,qc,s(330,330) associated with the unmasked array H∗
b,sp,qc,s(330,330) from
6 to 10 for the Tanner graph G∗
b,sp,qc,s,mask(330,330) associated with the masked
array H∗
b,sp,qc,s,mask(330,330). Furthermore, it reduces the number of short cycles
greatly, from a total of 541 530 of cycles of lengths 6, 8, and 10 to 13 200 cycles
of length 10: a large reduction in short cycles.
Comparing the code C∗
b,sp,qc,mask with the code Cb,sp,qc,mask constructed in
Example 7.1, we ﬁnd that the Tanner graph G∗
b,sp,qc,s,mask(330,330) of the code
C∗
b,sp,qc,mask has a larger girth (girth 10) than the Tanner graph Gb,sp,qc,s,mask(330,
330) of the code Cb,sp,qc,mask (girth 8). However, G∗
b,sp,qc,s,mask(330,330) has a
slightly larger number of cycles of length 10 (13 200) than the sum of the numbers
of cycles of lengths 8 and 10 (9 570) in Gb,sp,qc,s,mask(330,330).
In this example, we showed again that proper masking of a base matrix not
only enlarges the girth of the Tanner graph of an LDPC code, but also greatly
reduces the total number of short cycles. We also showed that the masking matrix
Z given by (7.5) (or the decomposition base matrix given by (4.7) for the algebraic
construction of the (2640,1320) QC-PTG-LDPC code given in Example 4.2) is
indeed a good masking matrix.
The BER and BLER performances of the code C∗
b,sp,qc,mask over the AWGNC
decoded with 5, 10, and 50 iterations of the MSA are shown in Fig. 7.2(a). At a
BER of 10−10, the gap between 5 and 10 iterations is about 1.6 dB and the gap
between 10 and 50 iterations is within 0.8 dB. From Fig. 7.1(a) and Fig. 7.2(a),
we see that the code Cb,sp,qc,mask constructed in Example 7.1 and the code
C∗
b,sp,qc,mask constructed in this example perform almost the same, even though
C∗
b,sp,qc,mask has a larger girth than Cb,sp,qc,mask. This is because the total number
of short cycles of the Tanner graph of C∗
b,sp,qc,mask is slightly larger than that of
Cb,sp,qc,mask. This implies that the cycle distribution of the Tanner graph of an
08
12:37:45, subject to the Cambridge Core terms of use,

0
1
2
3
4
5
6
7
10
−12
10
−11
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(2640, 1320) Cb,sp,qc,mask, itr50, BLER
(2640, 1320) Cb,sp,qc,mask, itr50, BER
(2640, 1320) Cb,sp,qc,mask, itr10, BLER
(2640, 1320) Cb,sp,qc,mask, itr10, BER
(2640, 1320) Cb,sp,qc,mask, itr5, BLER
(2640, 1320) Cb,sp,qc,mask, itr5, BER
SPB
Shannon Limit
*
*
*
*
*
*
0.36
0.38
0.4
0.42
0.44
0.46
0.48
0.5
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(2640, 1320) Cb,sp,qc,mask
*
, UEBLR
(2640, 1320) Cb,sp,qc,mask
*
, UEBR
Shannon Limit
Figure 7.2. (a) The BER and BLER performances of the (2640,1320) code
C∗
b,sp,qc,mask given in Example 7.2 decoded with 5, 10, and 50 iterations of the
MSA over the AWGNC; and (b) performance of the code in (a) over the BEC.
08
12:37:45, subject to the Cambridge Core terms of use,

84
7 SP-Construction by Matrix Dispersion and Masking
LDPC code is also a factor affecting the error performance of the code, in addition
to the girth.
The UEBR and UEBLR performances of the code C∗
b,sp,qc,mask over the BEC
are shown in Fig. 7.2(b). At a UEBR of 10−10, the code performs about 0.14 away
from the Shannon limit.
7.5 Design of Masking Matrices
In the previous section, we demonstrated that masking is a very effective technique
to enlarge the girth and reduce the number of short cycles of the Tanner graph of
an algebraically constructed LDPC code. A general guideline to design a good
masking matrix Z is that every 3 × 3 submatrix of Z contains at least one 0-entry.
This one-zero constraint on a 3 × 3 submatrix of Z makes it highly possible
that a masked 2 × 2 SM-constrained base matrix Bq,sp,mask satisﬁes the 3 × 3
SM-constraint (Theorem 7.2), which is the necessary and sufﬁcient condition for
the Tanner graph of the CPM-QC-SP-LDPC code constructed based on Bq,sp,mask
to have girth at least 8 and a smaller number of short cycles. In the following, we
will present several speciﬁc designs of masking matrices.
As shown in Examples 7.1 and 7.2, the 4 × 8 masking matrix Z given by (7.5)
is very effective for masking 4 × 8 base matrices in the form of (7.1) to produce
CPM-QC-SP-LDPC codes of rate 1/2 whose Tanner graphs have girth 8 or 10
and small numbers of short cycles. We could use this masking matrix and/or its
row-permuted versions as building blocks to construct masking matrices of larger
sizes. (In the following, we denote the m × n masking matrix Z by Z(m,n) for
a clear description, where the pair (m,n) in Z(m,n) represents the size of the
matrix Z.)
The masking matrix Z(4,8) given by (7.5) has a symmetrical structural property.
We partition this masking matrix into two 4 × 4 submatrices, denoted by Zl(4,4)
and Zr(4,4). The submatrix Zl(4,4) consists of the left 4 columns of Z(4,8) and
the submatrix Zr(4,4) consists of the right 4 columns of Z(4,8). Zl(4,4) and
Zr(4,4) are called left-half and right-half submatrices of Z(4,8), respectively.
From (7.5), we see that Zr(4,4) can be obtained by cyclically shifting the rows
of Zl(4,4) downward two positions. Both the submatrices Zl(4,4) and Zr(4,4)
have constant column weight 3 and two row weights, 2 and 4. Based on the pair,
Zl(4,4) and Zr(4,4), we can construct masking matrices with alternating Zl(4,4)s
and Zr(4,4)s in the form of:
[Zl(4,4) Zr(4,4) Zl(4,4) Zr(4,4) Zl(4,4) ...].
08
12:37:45, subject to the Cambridge Core terms of use,

7.5 Design of Masking Matrices
85
For an even integer k with k = 2ℓ, we form the following masking matrix:
Z1(4,4k) = [Zl(4,4) Zr(4,4) Zl(4,4) Zr(4,4) ... Zl(4,4) Zr(4,4)],
(7.7)
that consists of ℓpairs of Zl(4,4) and Zr(4,4). In this case, Z1(4,4k) has column
and row weights 3 and 6ℓ, respectively. For an odd integer k = 2ℓ−1 with ℓ> 1,
we form the following masking matrix:
Z1(4,4k) = [Zl(4,4) Zr(4,4) Zl(4,4) Zr(4,4) ... Zl(4,4)],
(7.8)
that consists of ℓ−1 pairs of Zl(4,4) and Zr(4,4) and ends with the left-half
submatrix Zl(4,4) of Z(4,8). In this case, Z1(4,4k) has column weight 3 and
two different row weights, 6(ℓ−1) + 2 and 6(ℓ−1) + 4. Note that for k ≥3
(ℓ≥2), there are 3 × 3 submatrices in Z1(4,4k) which contain all 1-entries. We
call Z1(4,4k) the type-1 masking matrix constructed using the masking matrix
Z(4,8) given by (7.5) as the building block.
With k = 2,3,4,..., we can form a sequence of masking matrices of the forms
(7.7) and (7.8) for constructing CPM-QC-SP-LDPC codes with rates 1/2, 2/3,
3/4, ...
For a clear description that is compatible with that of the masking matrices, in
the following, we denote Bq,sp by Bq,sp(m,n), where the pair (m,n) in Bq,sp(m,n)
represents the size of the base matrix Bq,sp.
Example 7.3. For k = 2,3,...,10, we use the ﬁeld GF(27) to construct nine 4×4k
base matrices Bq,sp,s(4,4k)s in the form of (7.1) and then mask them with the
nine masking matrices Z1(4,4k)s in the form of (7.7) for even k and (7.8) for odd
k. The null spaces of the binary CPM-dispersions of the masked base matrices
Bq,sp,s,mask(4,4k)s give nine CPM-QC-SP-LDPC codes of lengths 508k and rates
(k −1)/k, denoted by Ck−1,mask, for k = 2,3,...,10. The BER performances of
these codes decoded with 50 iterations of the MSA are shown in Fig. 7.3(a). From
this ﬁgure, we see that the codes perform well.
Consider the (5080,4572) CPM-QC-SP-LDPC code C9,mask with rate 9/10
(k = 10). The unmasked base matrix Bq,sp,s(4,40) for this code is constructed
using the two subsets S0 = { α0, α1, α2, α3 } and S1 = { α5, α6, α7, α8, α9,
α10, α11, α12, α14, α15, α16, α17, α18, α19, α20, α21, α23, α24, α25, α26, α27, α28,
α29, α30, α33, α34, α35, α36, α37, α38, α39, α40, α41, α42, α43, α44, α45, α46, α47,
α48} of GF(27) and setting η = 1. The null space of the binary CPM-dispersion of
Bq,sp,s(4,40) is a (5080,4589) CPM-QC-SP-LDPC code C9 whose Tanner graph
has girth 6 and contains 245 110 cycles of length six, 24 630 507 cycles of length
8, and 2 165 484 620 cycles of length 10. The (5080,4572) CPM-QC-SP-LDPC
code C9,mask is given by the null space of the CPM-dispersion of the masked base
matrix Bq,sp,s,mask(4,40) = Z1(4,40) ⊙Bq,sp,s(4,40). The Tanner graph of this
08
12:37:45, subject to the Cambridge Core terms of use,

86
7 SP-Construction by Matrix Dispersion and Masking
masked code has girth 6 and contains 30480 cycles of length six, 1 485 773 cycles
of length 8, and 65 230 502 cycles of length 10. We see that masking drastically
reduces the number of short cycles in the Tanner graph of the unmasked code C9.
The BER and BLER performances of C9,mask decoded with 50 iterations of
the MSA are shown in Fig. 7.3(b). Also included in this ﬁgure are the BER and
BLER performances of a (5080,4572) LDPC ode C peg constructed using the PEG
algorithm whose parity-check matrix has column weight 3. The Tanner graph of
the PEG code C peg has girth 6 and contains 32 723 cycles of length six, 1 567 708
cycles of length 8, and 66 756 528 cycles of length 10. From Fig. 7.3(b), we see
that the two codes perform the same above a BER of 10−7.
Another way of constructing masking matrices based on the masking matrix
Z(4,8) given by (7.5) is to repeat the ﬁrst pair of columns and the third pair of
columns in Z(4,8) k times to obtain a 4 × 4k masking matrix, Z2(4,4k), with
column weight 3 and row weight 3k. For example, setting k = 2 gives the matrix
Z(4,8) given by (7.5), while setting k = 3 gives the masking matrix:
Z2(4,12) =
⎡
⎢⎢⎣
1
0
1
0
1
0
1
1
1
1
1
1
0
1
0
1
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
1
0
1
0
1
1
1
1
1
1
0
1
0
1
0
1
⎤
⎥⎥⎦.
(7.9)
The masking matrix Z2(4,4k) is called the type-2 masking matrix constructed
using the masking matrix Z(4,8) given by (7.5) as the building block. Z2(4,4k) is
simply a uniform expansion of Z(4,8).
Example 7.4. Let us use GF(331) for the code construction ﬁeld and let α be a
primitive element of GF(331). Suppose we use the subsets S0 = {α0,α1,α2,α3}
and S1 = {α14,α15,α16,...,α24,α25} of GF(331) and set η = −1 to construct
a 4 × 12 base matrix Bq,sp,s(4,12) over GF(331) in the form of (7.1) which
has column and row weights 4 and 12, respectively. The code given by
the binary CPM-dispersion of Bq,sp,s(4,12) is a (4,12)-regular (3960,2643)
CPM-QC-SP-LDPC code Cb,sp,qc with rate 0.6674 whose Tanner graph has girth 6
and contains 13 530 cycles of length six, 165 660 cycles of length 8, and 3 835 590
cycles of length 10.
Suppose we mask the base matrix Bq,sp,s(4,12) with Z2(4,12) given by
(7.9). The masked base matrix Bq,sp,s,mask(4,12) = Z2(4,12) ⊙Bq,sp,s(4,12)
has column and row weights 3 and 9, respectively. The null space of the
binary CPM-dispersion of Bq,sp,s,mask(4,12) is a (3,9)-regular (3960,2640)
CPM-QC-SP-LDPC code Cb,sp,qc,mask whose Tanner graph has girth 8 and
contains 3960 cycles of length 8 and 117 480 cycles of length 10. We see that
08
12:37:45, subject to the Cambridge Core terms of use,

1.5
2
2.5
3
3.5
4
4.5
5
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
(a)
−1
BER
Eb/N0(dB)
(1016,508)−1/2
(1524,1016)−2/3
(2032,1524)−3/4
(2540,2032)−4/5
(3048,2540)−5/6
(3556,3048)−6/7
(4064,3556)−7/8
(4572,4064)−8/9
(5080,4572)−9/10
3.5
3.75
4
4.25
4.5
4.75
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
BLER/BER
Eb/N0
(5080,4572), C9,mask, BER
(5080,4572), C9,mask, BLER
(5080,4572), Cpeg, BER
(5080,4572), Cpeg, BLER
Figure 7.3. (a) The BER performances a sequence of CPM-QC-SP-LDPC codes
with rates 1/2, 2/3, 3/4, ..., 8/9, 9/10 constructed in Example 7.3 over
the AWGNC; and (b) the BER and BLER performances of the (5040,4572)
CPM-QC-SP-LDPC code C9,mask and the (5040,4572) PEG code C peg in
Example 7.3 over the AWGNC.
08
12:37:45, subject to the Cambridge Core terms of use,

88
7 SP-Construction by Matrix Dispersion and Masking
masking not only increases the girth from 6 to 8 but also signiﬁcantly reduces the
number of short cycles.
The BER and BLER performances of the two codes Cb,sp,qc and Cb,sp,qc,mask
decoded with 50 iterations of the MSA are shown in Fig. 7.4. We see that the
masked code Cb,sp,qc,mask outperforms the unmasked code Cb,sp,qc. Therefore,
Z2(4,12) is a good masking matrix.
For comparison, also included in Fig. 7.4 are the BER and BLER performances
of a (3960,2640) PEG code Cpeg constructed using the PEG algorithm, whose
parity-check matrix has column weight 3 and average row weight 9. The Tanner
graph of the PEG code C peg has girth 8 and contains 712 cycles of length 8 and
118 636 cycles of length 10. From Fig. 7.4, we see that the two codes perform the
same above a BER of 10−8.
Note that in the construction of a type-2 masking matrix, we can repeat the ﬁrst
pair of columns of Z(4,8) given by (7.5) k1 times and the third pair of columns of
Z(4,8) k2 times. This results in a non-uniform expansion of Z(4,8). The masking
matrix formed in this way is a 4×(2k1+2k2) matrix Z2(4,2k1+2k2) with column
weight 3 and two row weights, k1 + 2k2 and 2k1 + k2. Non-uniform expansion of
Z(4,8) results in a larger class of masking matrices.
Next, we present the third type of masking matrices constructed based on a
small matrix. Let A(4,2k) be a 4 × 2k matrix obtained by repeating the ﬁrst two
columns of Z(4,8) given by (7.5) k times. For ℓ≥0, form a (4 + ℓ) × 2k matrix
A(4 + ℓ,2k) by adding ℓall-zero rows at the bottom of A(4,2k). For f ≥0, let
A( f )(4 + ℓ,2k) be a (4 + ℓ) × 2k matrix obtained by cyclically down-shifting the
rows of A(4+ℓ,2k) f positions. For t ≥2, we construct the following (4+ℓ)×2kt
matrix:
Z3(4 + ℓ,2kt) =
[A(0)(4 + ℓ,2k) A( f )(4 + ℓ,2k) A(2 f )(4 + ℓ,2k) ... A((t−1) f )(4 + ℓ,2k)],
(7.10)
which has column weight 3 and multiple row weights. For various choices of
k, ℓ, f , and t, we obtain a sequence of matrices Z3(4 + ℓ,2kt) of the form
(7.10) that can be used as masking matrices in the construction of a sequence of
CPM-QC-SP-LDPC codes of various lengths and rates. The matrix Z3(4+ℓ,2kt)
is called a type-3 masking matrix. Using performance simulations, we ﬁnd this
type of masking matrix is also quite effective.
Example 7.5. Again, we use the ﬁeld GF(331) for the code construction. Choose
k = 4, ℓ= 2, f = 4, and t = 2. First, we construct a 6×16 base matrix Bq,sp,s(6,16)
over GF(331) in the form of (7.1) using the following two subsets of GF(331):
08
12:37:45, subject to the Cambridge Core terms of use,

1.5
1.75
2
2.25
2.5
2.75
3
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/BER
Eb/N0
(3960,2640), Cb,sp,qc,mask, BER
(3960,2640), Cb,sp,qc,mask, BLER
(3960,2643), Cb,sp,qc, BER
(3960,2643), Cb,sp,qc, BLER
(3960,2640), Cpeg, BER
(3960,2640), Cpeg, BLER
Figure 7.4. The BER and BLER performances of the unmasked (3960,2643) and the masked (3960,2640) CPM-QC-SP-LDPC
codes Cb,sp,qc and Cb,sp,qc,mask given in Example 7.4 and a comparable (3960,2640) PEG code C peg over the AWGNC.
08
12:37:45, subject to the Cambridge Core terms of use,

90
7 SP-Construction by Matrix Dispersion and Masking
S0 = {α0,α1,α2,α3,α4,α5} and S1 = {α15,α16,α17,...,α29,α30}. Set η = 1.
The binary CPM-dispersion of Bq,sp,s(6,16) gives a (6,16)-regular (5280,3305)
CPM-QC-SP-LDPC code Cb,sp,qc whose Tanner graph has girth 6 and contains
133 980 cycles of length 6, 4 307 325 cycles of length 8, and 241 141 560 cycles of
length 10. With k = 4, ℓ= 2, f = 4, and t = 2, we construct the following 6 × 16
masking matrix in the form of (7.10):
Z3(6,16) =
⎡
⎢⎢⎢⎢⎢⎢⎣
1
0
1
0
1
0
1
0
1
1
1
1
1
1
1
1
0
1
0
1
0
1
0
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
1
0
1
0
1
0
0
0
0
0
0
0
0
0
0
1
0
1
0
1
0
1
⎤
⎥⎥⎥⎥⎥⎥⎦
.
(7.11)
Masking Bq,sp,s(6,16) with Z3(6,16), we obtain a 6 × 16 masked base matrix
Bq,sp,s,mask(6,16) with column weight 3 and three row weights 4, 8, and 12.
Bq,sp,s,mask(6,16) satisﬁes the 3 × 3 SM-constraint. The binary CPM-dispersion
of Bq,sp,s,mask(6,16) is a 6×16 array Hb,sp,qc,s,mask(330,330) of CPMs and ZMs
of size 330 × 330, which is a 2980 × 5280 matrix over GF(2) with column weight
3 and three row weights 4, 8, and 12. The null space of Hb,sp,qc,s,mask(330,330)
gives a (5280,3302) CPM-QC-SP-LDPC code Cb,sp,qc,mask with rate slightly
higher than 5/8. The Tanner graph of the code Cb,sp,qc,mask has girth 8 and
contains 4280 cycles of length 8 and 114 840 cycles of length 10. We see that
masking not only increases the girth of the Tanner graph of the unmasked code C
but also reduces the number of short cycles.
The BER and BLER performances of the masked and the unmasked codes
Cb,sp,qc,mask and Cb,sp,qc decoded with 50 iterations of the MSA are shown in
Fig. 7.5. We see that the masked code Cb,sp,qc,mask outperforms the unmasked
code Cb,sp,qc and it reaches down to a BER of 10−9 without a visible error-ﬂoor.
The BER and BLER performances of a comparable (5280,3300) PEG code C peg
constructed using the PEG algorithm are also included in Fig. 7.5 for comparison.
The parity-check matrix of the PEG code C peg has constant column weight 3. The
Tanner graph of the PEG code Cpeg has girth 10 and contains 65 745 cycles of
length 10. From Fig. 7.5, we see that the constructed code Cb,sp,qc,mask performs
almost the same as the PEG code Cpeg.
Once a masking matrix Z is designed for a given code rate and length, we
need to ﬁnd an RC-constrained base matrix Bq,sp such that the masked base
matrix Bq,sp,mask = Z⊙Bq,sp, in conjunction with the CPM-dispersion, produces
a CPM-QC-SP-LDPC code whose Tanner graph has a large girth g, say 8 or larger,
08
12:37:45, subject to the Cambridge Core terms of use,

1.5
1.75
2
2.25
2.5
2.75
3
3.25
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/BER
Eb/N0
(5280, 3302), Cb,sp,qc,mask, BER
(5280, 3302), Cb,sp,qc,mask, BLER
(5280, 3305), Cb,sp,qc, BER
(5280, 3305), Cb,sp,qc, BLER
(5280, 3300), Cpeg, BER
(5280, 3300), Cpeg, BLER
Figure 7.5. The BER and BLER performances of the unmasked (5280,3305) and the masked (5280,3302) CPM-QC-SP-LDPC
codes Cb,sp,qc and Cb,sp,qc,mask given in Example 7.5 and a comparable (5280,3300) PEG code C peg over the AWGNC.
08
12:37:45, subject to the Cambridge Core terms of use,

92
7 SP-Construction by Matrix Dispersion and Masking
and a small total number of cycles of lengths g and g + 2 (called short cycles).
In this case, we say that the masking matrix Z and the base matrix Bq,sp are
compatible (or a good match to each other).
One approach to ﬁnd a base matrix that is a good match to a designed
masking matrix Z is that we ﬁrst construct a large 2 × 2 SM-constrained mother
matrix Bmother over a chosen ﬁeld using a speciﬁc construction method, say the
construction method based on two arbitrary subsets of a ﬁnite ﬁeld presented
in Section 7.3. Then, we develop a searching algorithm to ﬁnd a base matrix
Bq,sp, a submatrix of Bmother, such that Bq,sp,mask = Z ⊙Bq,sp satisﬁes the 3 × 3
SM-constraint or produces a CPM-QC-SP-LDPC code whose Tanner graph has
the largest girth (at least 8) and/or the smallest number of short cycles.
In [68], an algorithm was devised to ﬁnd a 4 × 8 base matrix from a mother
base matrix which is a good match to a designed 4 × 8 masking matrix Z(4,8)
with column and row weights 3 and 6, respectively. This algorithm was developed
to ﬁnd masked base matrices for constructing (3,6)-regular QC-LDPC codes with
rate 1/2. It can be generalized to ﬁnd masked base matrices for constructing regular
QC-LDPC codes with various rates. One such a generalized algorithm is presented
in Appendix B.
So far, the design of masking matrices given above has been focused on
constructing regular (or near regular) CPM-QC-SP LDPC codes using the
CPM-D-SP-construction method. To construct an irregular CPM-QC-SP-LDPC
code with optimized VN and CN degree distributions, we need to construct a
masking matrix with column and row weight distributions in agreement with (or
close to) the optimized VN and CN degree distributions. Such a masking matrix
can be constructed by using the PEG algorithm.
7.6 Construction of CPM-QC-SP-LDPC Codes for Correcting
Bursts of Erasures by Masking
The masking technique presented in the last two sections can be used to construct
CPM-QC-SP-LDPC codes for correcting bursts of erasures, i.e., erasures clustered
in bursts. Let GF(q) be the ﬁeld for the code construction. Let l and t be two
positive integers such that lt ≤q. We construct a t ×lt 2×2 SM-constrained base
matrix Bq,sp,s(t,lt) in the form of (7.1) using two subsets S0 and S1 of GF(q) with
|S0| = t and |S1| = lt. Next, we divide Bq,sp,s(t,lt) into l submatrices of size t ×t
as follows:
Bq,sp,s(t,lt) = [B0(t,t) B1(t,t) ... Bl−1(t,t)].
(7.12)
08
12:37:45, subject to the Cambridge Core terms of use,

7.6 Correcting Bursts of Erasures by Masking
93
For 0 ≤j < l, each submatrix B j(t,t) consists of t consecutive columns of
Bq,sp,s(t,lt).
Let τ be a positive integer with τ ≤t −2. Now, we construct a binary t-tuple
z = (z0,z1,...,zt−1) in which the ﬁrst τ components are zeros and the last t −τ
components are ones, i.e.,
z = (0 0 ... 0

τ
1 1 ... 1

t−τ
).
Now, we form a t × t circulant Z(t,t) with z as the generator. Each row
(or column) of Z(t,t) contains a span of τ 0-entries conﬁned by two 1-entries,
including the end-around case. This span of τ 0-entries is called a zero-span and
the parameter τ is called the length of the zero-span.
Next, we mask each t × t submatrix B j(t,t) of Bq,sp,s(t,lt) with Z(t,t). The
masking operation results in a t ×lt masked base matrix:
Bq,sp,s,mask(t,lt) = [B0,mask(t,t) B1,mask(t,t) ... Bl−1,mask(t,t)].
(7.13)
It follows from the structure of the masking matrix Z(t,t) that the masked base
matrix Bq,sp,s,mask(t,lt) has the following structural properties: (1) Each row con-
tains l zero-spans of length τ, each separated by t −τ nonzero entries, including the
end-around case; and (2) In each column position, there is one row with a nonzero
entry in that position followed by τ 0-entries, including the end-around case.
Dispersing each nonzero entry in Bq,sp,s,mask(t,lt) into a CPM of size (q −
1) × (q −1) and each zero entry into a ZM of size (q −1) × (q −1), we obtain
a binary t × lt array Hb,sp,qc,s,mask(q −1,q −1) of binary CPMs and ZMs of
size (q −1) × (q −1). The array Hb,sp,qc,s,mask(q −1,q −1) is a t(q −1) ×
lt(q −1) matrix with constant column weight t −τ and constant row weight
l(t −τ). Hb,sp,qc,s,mask(q −1,q −1) consists of t row-blocks and lt column-blocks
of CPMs and ZMs of size (q −1)×(q −1). Each row-block consists of l spans of
ZMs, each consisting of τ ZMs of size (q −1) × (q −1) conﬁned by two CPMs,
including the end-around case. Hence, each row of Hb,sp,qc,s,mask(q −1,q −1)
consists of l zero-spans, each of length at least τ(q −1). Based on the structural
properties of Bq,sp,qc,s,mask(t,lt) and Hb,sp,qc,s,mask(q −1,q −1), we readily see
that in any column position of Hb,sp,qc,s,mask(q −1,q −1), there is exactly one
row in Hb,sp,qc,s,mask(q −1,q −1) which has a 1-entry in that column position
followed by at least τ(q −1) zeros entries.
Let Cb,sp,qc,mask be the CPM-QC-SP-LDPC code given by the null space of
Hb,sp,qc,s,mask(q −1,q −1). The above structural property of Hb,sp,qc,s,mask
(q −1,q −1) allows the code Cb,sp,qc,mask to correct any erasure pattern e over the
BEC with erased code symbols conﬁned to κ consecutive positions with 0 ≤κ ≤
08
12:37:45, subject to the Cambridge Core terms of use,

94
7 SP-Construction by Matrix Dispersion and Masking
τ(q −1)+1. This erasure pattern is called an erasure-burst of length κ. When such
an erasure pattern e occurs, we ﬁnd a row in Hb,sp,qc,s,mask(q −1,q −1) which
checks only one erasure in e. Based on the zero-constraint on the parity-check sum
formed by this row, we can uniquely determine the value of the erased symbol
being checked. Recovering this erased code symbol, we obtain an erasure-burst
e1 with one less erasure. Then, we ﬁnd a row in Hb,sp,qc,s,mask(q −1,q −1) that
checks only one erasure in e1. Based on the zero-constraint on the parity-check
sum formed by this row, we recover the code symbol being erased. We continue
the above check-and-recover process until all the erased code symbols in e are
recovered. Any erasure-burst of length τ(q −1) + 1 or less can be corrected
by the code Cb,sp,qc,mask. We say that Cb,sp,qc,mask has erasure-burst correcting
capability τ(q −1) + 1.
We must note that an LDPC code that is efﬁcient for correcting bursts of erasure
does not necessarily perform well over the AWGNC or the BEC for correcting
random erasures and/or errors.
Example 7.6. Let GF(28) be the code construction ﬁeld and α be a primitive
element in GF(28). Set t = 7 and l = 6. Choose two sets S0 = {α0, α1, α2, ..., α6 }
and S1 = {α7,α8,...,α48}. Set η = −1. Based on these two subsets, we construct
a 7×42 base matrix Bq,sp,s(7,42) over GF(28) in the form of (7.1) which satisﬁes
the 2 × 2 SM-constraint. Dividing Bq,sp,s(7,42) into 6 submatrices, each a 7 × 7
matrix, we have Bq,sp,s(7,42) = [B0(7,7) B1(7,7) ... B5(7,7)]. Set τ = 3. Form
the following 7 × 7 masking matrix:
Z(7,7) =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
0
0
0
1
1
1
1
1
0
0
0
1
1
1
1
1
0
0
0
1
1
1
1
1
0
0
0
1
1
1
1
1
0
0
0
0
1
1
1
1
0
0
0
0
1
1
1
1
0
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
(7.14)
For 0 ≤j < 6, masking B j(7,7) of Bq,sp,s(7,42) with Z(7,7) given by (7.14),
we obtain a 7 × 42 masked base matrix Bq,sp,s,mask(7,42) = [ B0,mask(7,7)
B1,mask(7,7) ... B5,mask(7,7) ] with column weight 4 and row weight 24.
Each row of the masked base matrix Bq,sp,s,mask(7,42) has 6 zero-spans, each
of length 3. The CPM-dispersion of Bq,sp,s,mask(7,42) gives a 7 × 42 array
Hb,sp,qc,s,mask(255,255) of CPMs and ZMs of size 255 × 255 over GF(2). It is
a 1785 × 10 710 matrix with column weight 4 and row weight 24. Each row of
Hb,sp,qc,s,mask(255,255) has 6 zero-spans, each of length at least 765, including
the end-around zero-span. In each column position of Hb,sp,qc,s,mask(255,255),
08
12:37:45, subject to the Cambridge Core terms of use,

7.7 Discussion and Remarks
95
there is one row with a 1-entry in that column position followed by at least 765
0-entries.
The null space of the masked array Hb,sp,qc,s,mask(255,255) gives a (4,24)-
regular (10 710, 8926) CPM-QC-SP-LDPC code Cb,sp,qc,mask with rate 0.8334.
This code is capable of correcting any erasure-burst of length 766 or less.
The BER and BLER performances of Cb,sp,qc,mask over the AWGNC are shown
in Fig. 7.6(a). The unresolved erasure performance over the BEC is shown in
Fig. 7.6(b).
7.7 Discussion and Remarks
In the construction of a QC-SP-LDPC code using CPM-dispersion, a key ingredi-
ent is a 2 × 2 SM-constrained base matrix over a chosen NB ﬁeld. In Section 7.3,
we presented a powerful and ﬂexible algebraic method for constructing 2 × 2
SM-constrained base matrices over NB ﬁelds. This construction method includes
as special cases six major algebraic methods for constructing 2×2 SM-constrained
base matrices over NB ﬁelds developed since 2003. Besides this method and
its special cases, there are other powerful methods. One such a method is the
construction of 2 × 2 SM-constrained base matrices based on cyclic subgroups
of prime order of an NB ﬁeld proposed in [64]. This method is not a special case
of the construction presented in Section 7.3 and will be discussed in Chapter 10.
Another method for constructing 2 × 2 SM-constrained base matrices is based on
partial geometries [29]. This geometric construction method gives a large class of
2 × 2 SM-constrained base matrices and will be discussed in Appendix A.
Another key ingredient for constructing QC-SP-LDPC codes to have good error
performance is masking. In Sections 7.4 and 7.5, we demonstrated that masking
is a very effective technique to enlarge the girth and reduce the number of short
cycles of the Tanner graph of an algebraically constructed LDPC code. A general
guideline to design a good masking matrix Z is that every 3 × 3 submatrix of Z
contains at least one 0-entry (or most of the 3×3 submatrices of Z contain at least
one 0-entry). This one-zero constraint on a 3 × 3 submatrix of Z makes it highly
possible that a masked 2 × 2 SM-constrained base matrix Bq,sp,mask satisﬁes the
3×3 SM-constraint (Theorem 7.2), which is the necessary and sufﬁcient condition
for the Tanner graph of the CPM-QC-SP-LDPC code constructed based on the
masked base matrix Bq,sp,mask to have girth at least 8 and a smaller number of
short cycles.
For a given rate, a given code length, and a given ﬁeld, in order to construct a
CPM-QC-SP-LDPC code with good error performance, the two key ingredients,
base matrix and masking matrix, must be compatible, i.e., a good match to each
08
12:37:45, subject to the Cambridge Core terms of use,

96
7 SP-Construction by Matrix Dispersion and Masking
2.4
2.6
2.8
3
3.2
3.4
3.6
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BER/BLER
Eb/N0
(10710, 8926), BER
(10710, 8926), BLER
Shannon limit
SPB
0.1
0.11
0.12
0.13
0.14
0.15
0.16
0.17
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBR/UEBLR
ε
(10710, 8926), UEBR
(10710, 8926), UEBLR
Shannon limit
Figure 7.6. (a) The BER and BLER performances of the (4,24)-regular (10 710,
8926) code Cb,sp,qc,mask given in Example 7.6 over the AWGNC; and (b)
performance of the code in (a) over the BEC.
08
12:37:45, subject to the Cambridge Core terms of use,

7.7 Discussion and Remarks
97
other. To achieve a good match, there are two approaches. One is to construct a
base matrix based on the chosen ﬁeld ﬁrst. Then, we design a masking matrix for
the constructed base matrix that results in a code whose Tanner graph has a large
girth and/or a small number of short cycles. The other approach is to design a
masking matrix ﬁrst and then ﬁnd a compatible base matrix. They together produce
a code whose Tanner graph has a large girth and/or a small number of short
cycles. However, either approach is “suboptimal.” A good question is “whether
the base and masking matrices can be designed jointly to produce a code whose
Tanner graph has good structural properties in terms of girth, cycle distribution,
and trapping sets?” This is deﬁnitely a good research problem, but also a hard one.
The masking matrices presented in Sections 7.4 and 7.5 are limited to small
size or are constructed using small masking matrices as the building blocks.
Furthermore, their column weights are limited to 3. To construct masking matrices
of large size with various column weights, we could use ﬁnite geometries in a
way similar to the construction of base matrices for the SP-construction of LDPC
codes. An RC-constrained SP-base matrix can be used as a masking matrix. In this
case, every 3 × 3 submatrix of the masking matrix contains at least one 0-entry,
i.e., satisﬁes the one-zero constraint. Masking a 2×2 SM-constrained base matrix
with an RC-constrained masking matrix may result in a masked base matrix that
satisﬁes the 3 × 3 SM-constraint and has other good structural properties. This is
also worthy of further investigation.
Another approach to construct a large masking matrix is to start with an m × n
matrix Z0 with all 1-entries. Then, we perform diagonal replacement of 1-entries
by 0-entries. This is done as follows. We start from any position of the top row and
move down to the right on a 45◦diagonal. When reaching the end of a column,
we move to the top of any new column (or the next column). When we reach the
end of a row, we move to the leftmost entry of any new row (or the next row). As
we make this zig-zag move, we replace each 1-entry on the path by a 0-enty. We
continue the zig-zag move and the 1-to-0 replacement until we obtain a matrix Z
for which one or all of the following conditions are met: (1) Any 3 × 3 submatrix
of Z contains at least one 0-entry; (2) Z has the desired row and column weight
distributions; and (3) Z satisﬁes the RC-constraint.
In Section 7.6, we showed that the masking technique is also effective for
constructing CPM-QC-SP-LDPC codes for correcting bursts of erasures over the
BEC. Therefore, in our belief, design of good masking matrices is a good research
problem.
So far, there is no systematic method for constructing good masking matrices,
hence the design of good masking matrices is still an art.
08
12:37:45, subject to the Cambridge Core terms of use,

8
Doubly QC-LDPC Codes
In this chapter, we present an algebraic construction of CPM-QC-SP-LDPC
codes that have both the block- and the section-wise cyclic structures as deﬁned
earlier in Section 4.1. Such a CPM-QC-SP-LDPC code is called a doubly
CPM-QC-SP-LDPC code. The construction of a doubly CPM-QC-SP-LDPC code
is based on an SP-base matrix Bq,sp over a ﬁnite ﬁeld that has cyclic structure,
called a cyclic base matrix. A special case of the base matrix Bq,sp,p given in the
form of (7.2) constructed based on two subsets of a ﬁnite ﬁeld S0 and S1 has a
cyclic structure. One advantage of a doubly QC-LDPC code is that we can apply
either the reduced-complexity iterative decoding scheme proposed in [79] based
on its block-cyclic structure or the reduced-complexity iterative decoding scheme
presented in [69, 68, 78] based on its section-wise cyclic structure using the same
parity-check matrix. Furthermore, well designed doubly QC-LDPC codes perform
well over both the AWGNC and the BEC. The base matrix and its partition used
in this chapter will be used for constructing spatially and globally coupled LDPC
codes in the next two chapters.
8.1 Base Matrices with Cyclic Structure
Let α be a primitive element of GF(q). Set S0 = { α0, α−1, α−2, ..., α−(q−3),
α−(q−2) }, S1 = { α0, α1, α2, ..., αq−3, αq−2 }, and η = 1. Using the product-form
given by (7.2), we obtain the following 2 × 2 SM-constrained (q −1) × (q −1)
base matrix over GF(q):
B∗
q,sp,p =
⎡
⎢⎢⎢⎣
α0 −1
α −1
α2 −1 ··· αq−3 −1 αq−2 −1
αq−2 −1 α0 −1
α −1
··· αq−4 −1 αq−3 −1
...
...
...
...
...
...
α −1
α2 −1 α3 −1 ··· αq−2 −1
α0 −1
⎤
⎥⎥⎥⎦.
(8.1)
98
09
12:40:00, subject to the Cambridge Core terms of use,

8.1 Base Matrices with Cyclic Structure
99
From (8.1), we readily see that the base matrix B∗
q,sp,p has a cyclic structure. It is
a weight-(q −2) circulant over GF(q). This circulant can be obtained by permuting
the rows of the circulant given by (7.3). In fact, every row (or column) of B∗
q,sp,p
is a minimum weight codeword of the (q −1,2) Reed–Solomon (RS) code over
GF(q) with two information symbols and minimum distance q −2 [74, 97]. All
the entries in a row (or a column) of B∗
q,sp,p are distinct elements in GF(q) and any
two rows (or two columns) differ in every location. The q −1 entries lying on the
main diagonal of B∗
q,sp,p are the zero element of GF(q).
For 1 ≤m,n < q, any m ×n submatrix of B∗
q,sp,p can be used as the base matrix
for constructing a CPM-QC-SP-LDPC code. In this chapter, we are interested in
submatrices of B∗
q,sp,p from which we can construct doubly QC-LDPC codes.
To simplify the notation and show the connection to RS codes, we use WRS
for the matrix B∗
q,sp,p, i.e., WRS = B∗
q,sp,p. Label the rows and columns of WRS
from 0 to q −2. Suppose q −1 can be factored as the product of two positive
integers l and r, i.e., lr = q −1. Now, we partition WRS into r submatrices of size
l × (q −1), denoted by W0,W1,...,Wr−1, where for 0 ≤i < r, the submatrix
Wi consists of the il-th to the ((i + 1)l −1)-th rows of WRS (l consecutive rows
of WRS). Next, we partition the submatrix W0 into r submatrices of size l × l,
denoted by W0,0,W0,1,...,W0,r−1, each consisting of l consecutive columns of
W0, so that W0 = [W0,0 W0,1 ... W0,r−1]. Based on the cyclic structure of WRS,
we readily see that, for 0 ≤i < r, the submatrix Wi can be obtained by cyclically
shifting all the rows of W0 = [W0,0 W0,1 ... W0,r−1] il positions to the right,
i.e., Wi = [W0,r−i ... W0,r−1 W0,0 ... W0,r−i−1]. Hence, the matrix WRS can
be arranged as an r × r array of l × l submatrices in the following block-cyclic
structure form:
WRS =
⎡
⎢⎢⎢⎣
W0,0
W0,1
···
W0,r−1
W0,r−1
W0,0
···
W0,r−2
...
...
...
...
W0,1
W0,2
···
W0,0
⎤
⎥⎥⎥⎦.
(8.2)
Each row-block (or each column-block) of WRS is composed of the same
set of constituent matrices W0,0,W0,1,...,W0,r−1 in cyclic order. Since WRS
satisﬁes the 2 × 2 SM-constraint, each of its constituent matrices W0,0, W0,1, ...,
W0,r−1 also satisﬁes the 2 × 2 SM-constraint. Furthermore, all the r constituent
submatrices of WRS satisfy the PW-2 × 2 SM-constraint. This follows directly
from the block-cyclic structure of WRS shown by (8.2).
For 0 ≤j <r and 1 ≤m,n <l, we now take an m×n submatrix R0, j from W0, j.
The submatrices R0,0,R0,1,...,R0,r−1 are taken from the constituent matrices
W0,0,W0,1,...,W0,r−1 under the following location constraint: for j′  j, the
09
12:40:00, subject to the Cambridge Core terms of use,

100
8 Doubly QC-LDPC Codes
locations of the entries of R0, j in W0, j are identical to the locations of the entries
of R0, j′ in W0, j′. We next form the following r × r array Bq,sp,p(m,n) of m × n
submatrices over GF(q) with a block-cyclic structure:
Bq,sp,p(m,n) =
⎡
⎢⎢⎢⎣
R0,0
R0,1
···
R0,r−1
R0,r−1
R0,0
···
R0,r−2
...
...
...
...
R0,1
R0,2
···
R0,0
⎤
⎥⎥⎥⎦.
(8.3)
Bq,sp,p(m,n) is a submatrix of WRS = B∗
q,sp,p and satisﬁes the 2 × 2
SM-constraint. This follows directly from the block-cyclic structure of WRS and
the location constraint on the entries of the submatices R0,0,R0,1,...,R0,r−1 taken
from W0,0,W0,1,...,W0,r−1. Since the submatrices W0,0,W0,1,...,W0,r−1
satisfy the PW-2 × 2 SM-constraint, the submatrices R0,0,R0,1,...,R0,r−1 also
satisfy the PW-2 × 2 SM-constraint. (Here, we note that the pair (m,n) in
Bq,sp,p(m,n) denotes the size of the submatrices of the base array Bq,sp,p(m,n).)
8.2 CPM-D-SP-Construction of Doubly QC-LDPC Codes
Now, we use the array Bq,sp,p(m,n) as the base matrix for the CPM-D-SP-
construction of QC-LDPC codes. Dispersing each nonzero entry of Bq,sp,p(m,n)
into a CPM of size (q −1) × (q −1) and each zero entry into a ZM of size (q −
1)×(q −1), we obtain an r ×r array Hb,sp,d,qc(q −1,q −1) of m ×n subarrays of
binary CPMs and/or ZMs of size (q −1)×(q −1), which is also an mr ×nr array
of CPMs and/or ZMs of size (q −1) × (q −1). The array Hb,sp,d,qc(q −1,q −1)
consists of r row-blocks of subarrays, each consisting of r m × n subarrays of
CPMs and/or ZMs of size (q −1) × (q −1). It follows from the block-cyclic
structure of the base array Bq,sp,p(m,n) that Hb,sp,d,qc(q −1,q −1) also has a
block-cyclic structure. Each row-block of subarrays of Hb,sp,d,qc(q −1,q −1) is
the cyclic-shift of the row-block of subarrays above it one subarray (or n(q −1)
positions) to the right and the top row-block of subarrays is the cyclic-shift of the
last row-block of subarrays one subarray to the right. Since Hb,sp,d,qc(q −1,q −1)
is an mr × nr array of CPMs and/or ZMs of size (q −1) × (q −1), it also has a
section-wise cyclic structure. Hence, the array Hb,sp,d,qc(q −1,q −1) has both
block-cyclic and section-wise cyclic structures.
The null space of Hb,sp,d,qc(q −1,q −1) gives a binary CPM-QC-SP-LDPC
Cb,sp,d,qc of length nr(q −1) with rate at least (n −m)/n. Let v be a codeword
in Cb,sp,d,qc. Now, suppose we divide a codeword v in Cb,sp,d,qc into r sections,
each consisting of n(q −1) bits. If we cyclically shift the codeword v n(q −1)
positions to the right, we obtain another codeword in the code Cb,sp,d,qc. Hence,
09
12:40:00, subject to the Cambridge Core terms of use,

8.2 CPM-D-SP-Construction of Doubly QC- LDPC Codes
101
the code Cb,sp,d,qc has a block-cyclic structure. Suppose we divide a codeword
v into nr sections, each consisting of q −1 bits. If we cyclically shift all the nr
sections simultaneously one position to the right within the sections, we obtain
another codeword in Cb,sp,d,qc. Hence, the code Cb,sp,d,qc has a section-wise
cyclic structure. Therefore, the code Cb,sp,d,qc is a doubly QC-LDPC code which
has both block-cyclic and section-wise cyclic structures. The subscripts “d” and
“qc” in Cb,sp,d,qc and Hb,sp,d,qc(q −1,q −1) stand for “doubly QC-structure.”
For 0 ≤j < r, let CPM(R0, j) be the binary CPM-dispersion of R0, j. Then,
CPM(R0, j) is an m × n array of CPMs and/or ZMs of size (q −1) × (q −1),
a binary m(q −1) × n(q −1) matrix. The parity-check matrix Hb,sp,d,qc(q-1,
q −1) of Cb,sp,d,qc can be expressed in terms of CPM(R0,0), CPM(R0,1), ...,
CPM(R0,r−1) as follows:
Hb,sp,d,qc(q −1,q −1) =
⎡
⎢⎢⎢⎣
CPM(R0,0)
CPM(R0,1)
···
CPM(R0,r−1)
CPM(R0,r−1)
CPM(R0,0)
···
CPM(R0,r−2)
...
...
...
...
CPM(R0,1)
CPM(R0,2)
·
CPM(R0,0)
⎤
⎥⎥⎥⎦.
(8.4)
From (8.4), we see that, in terms of the SP-construction, the code Cb,sp,d,qc
is constructed with an r × r base matrix Bb,sp consisting of all 1-entries and a
replacement set R with CPM(R0,0), CPM(R0,1), ..., CPM(R0,r−1) as member
matrices. Since the matrices R0,0,R0,1,...,R0,r−1 satisfy both the 2 × 2 and the
PW-2 × 2 SM-constraints, their CPM-dispersions CPM(R0,0), CPM(R0,1), ...,
CPM(R0,r−1) satisfy both the RC- and the PW-RC-constraints. The replacement
of the 1-entries in the base matrix Bb,sp by the member matrices in R =
{CPM(R0,0),CPM(R0,1),...,CPM(R0,r−1)} is carried out in a cyclic manner as
shown in (8.4), which satisﬁes the replacement constraint.
Now suppose we view the binary matrix Hb,sp,d,qc(q −1,q −1) as an
mr × nr array of binary CPMs and/or ZMs of size (q −1) × (q −1). Using
the inverses of the row and column permutations, πrow and πcol, deﬁned by (4.3)
and (4.5), respectively, we can put Hb,sp,d,qc(q −1,q −1) into a (q −1)×(q −1)
array Hb,sp,cyc(mr,nr) of binary mr × nr matrices in the form of (4.1) with a
block-cyclic structure as follows:
Hb,sp,cyc(mr,nr) =
⎡
⎢⎢⎢⎣
D0
D1
···
Dq−2
Dq−2
D0
···
Dq−3
...
...
...
...
D1
D2
···
D0
⎤
⎥⎥⎥⎦.
(8.5)
09
12:40:00, subject to the Cambridge Core terms of use,

102
8 Doubly QC-LDPC Codes
The array Hb,sp,cyc(mr,nr) also satisﬁes the RC-constraint. From the PTG
point of view, the integer sum of constituent matrices D0,D1,...,Dq−2 in the
ﬁrst row-block of Hb,sp,cyc(mr,nr) gives the base matrix Bptg of a protograph
Gptg with mr CNs and nr VNs (as shown in Section 4.1). Hence, the doubly
CPM-QC-SP-LDPC code Cb,sp,d,qc can be regarded as a QC-PTG-LDPC code
whose Tanner graph is an expansion of the protograph Gptg by a factor of (q −1).
A binary QC-LDPC code Cb,sp,d,qc with a doubly QC-structure can be decoded
with either the reduced-complexity iterative decoding method proposed in [79]
based on its block-cyclic structure, or the one proposed in [69, 68, 78] based on
its section-wise cyclic structure. Either decoding scheme signiﬁcantly reduces the
decoder complexity and the message storage size.
Example 8.1. Consider the construction ﬁeld GF(17). Construct a 16 × 16 matrix
WRS over GF(17) in the form given by (8.1). Choose r = 2 and l = 8 such that
16 = rl. Then, following (8.2), the matrix WRS can be viewed as a 2 × 2 array
of 8 × 8 submatrices with 2 constituent matrices, W0,0 and W0,1. Take two 2 × 8
submatrices R0,0 and R0,1 from W0,0 and W0,1, respectively. The submatrix R0,0
consists of the ﬁrst two rows of W0,0 and R0,1 consists of the ﬁrst two rows of
W0,1. Based on these two submatrices R0,0 and R0,1, we can form a 2 × 2 array
Bq,sp,p(2,8) of 2 × 8 submatrices in the form given by (8.3). If we cyclically
shift the ﬁrst two rows of Bq,sp,p(2,8) simultaneously 8 positions to the right, we
obtain the other two rows. Dispersing each nonzero entry in Bq,sp,p(2,8) into a
16 × 16 binary CPM and each 0-entry into a 16 × 16 ZM, we obtain a 2 × 2 array
Hb,sp,d,qc(16,16) of 2×8 subarrays of 16×16 CPMs and ZMs. Hb,sp,d,qc(16,16)
is a 64 × 256 binary matrix which can also be viewed as a 4 × 16 array of
16 × 16 CPMs and ZMs. Among the 256 columns in Hb,sp,d,qc(16,16), there are
64 columns with weight 3 and 192 columns with weight 4. The null space of
Hb,sp,d,qc(16,16) gives an irregular (256,192) doubly CPM-QC-SP-LDPC code
Cb,sp,d,qc with rate 0.75. The Tanner graph of the code Cb,sp,d,qc has girth 6 and
contains 10 048 cycles of length 6. The error performances of the code decoded
with 50 iterations of the MSA over the AWGNC and the BEC are shown in
Fig. 8.1(a) and Fig. 8.1(b), respectively. At a BLER of 10−8, from Fig. 8.1(a), we
see that the code performs 1.8 dB away from the SPB. Fig. 8.1(b) shows that the
code performs 0.17 away from the Shannon limit over the BEC at a UEBR of 10−7.
In the following, we present a long high-rate doubly CPM-QC-SP-LDPC code
and demonstrate its error performance.
Example 8.2. Suppose we choose the prime ﬁeld GF(139) for constructing a
doubly CPM-QC-SP-LDPC code. Based on the nonzero elements of this ﬁeld,
we can construct a 138 × 138 matrix WRS = B∗
q,sp,p in the form of (8.1). Based
09
12:40:00, subject to the Cambridge Core terms of use,

8.2 CPM-D-SP-Construction of Doubly QC- LDPC Codes
103
1
1.5
2
2.5
3
3.5
4
4.5
5
5.5
6
6.5
10−3
10−4
10−5
10−6
10−7
10−8
10−9
10−10
10−2
10−1
100
(a)
BLER/BER
Eb/N0
(256, 192), Cb,sp,d,qc, BLER
(256, 192), Cb,sp,d,qc, BER
 SPB
10−3
10−4
10−5
10−6
10−7
10−8
10−9
10−10
10−2
10−1
100
0.05
0.1
0.15
0.2
0.25
(b)
UEBLR/UEBR
ε
(256, 192), Cb,sp,d,qc, UEBLR
(256, 192), Cb,sp,d,qc, UEBR
Shannon Limit
Figure 8.1. (a) The BER and BLER performances of the (256,192) doubly
CPM-QC-SP-LDPC code Cb,sp,d,qc given in Example 8.1 over the AWGNC; and
(b) performance of the code in (a) over the BEC.
09
12:40:00, subject to the Cambridge Core terms of use,

104
8 Doubly QC-LDPC Codes
on WRS, we can then construct a family of doubly CPM-QC-SP-LDPC codes of
various lengths and rates using the construction method given above.
First we factor 138 as the product of two integers 6 and 23, i.e., 138 = 6 × 23,
and let r = 6 and l = 23. The matrix WRS can then be viewed as a 6 × 6 array
of 23 × 23 submatrices over GF(139). Next, we choose m = 1 and n = 20. For
0 ≤j < 6, take a 1×20 submatrix R0, j from W0, j in the manner described above.
(In this example, we avoid choosing the zero entries of WRS.) Based on these 6
submatrices R0,0, R0,1, R0,2, R0,3, R0,4, and R0,5, we then construct a 6×6 array
Bq,sp,p(1,20) of 1 × 20 submatrices over GF(139) in the form given by (8.3).
Bq,sp,p(1,20) is a 6 × 120 matrix over GF(139) with column and row weights 6
and 120, respectively.
The CPM-dispersion of the base matrix Bq,sp,p(1,20) gives a 6 × 120 array
Hb,sp,d,qc(138,138) of CPMs of size 138 × 138. The array Hb,sp,d,qc(138,138)
is an 828 × 16560 matrix with column and row weights 6 and 120, respectively.
Its null space gives a (6,120)-regular (16560,15737) doubly CPM-QC-SP-LDPC
code Cb,sp,d,qc with rate 0.9503. Its Tanner graph has girth 6 and contains
34 158 312 cycles of length 6 – a very large number of short cycles. However, this
large number of short cycles does not degrade the performance of the code because
the Tanner graph of the code also has a very high degree of VN-connectivity. Each
VN is connected to 714 other VNs by paths of length 2. As a result, in a few
iterations, each VN-MPU collects enough extrinsic information to update its LLR
to a level sufﬁcient to make a correct hard decision with high probability.
The BER and BLER performances of the code Cb,sp,d,qc decoded with 5, 10,
and 50 iterations of the MSA are shown in Fig. 8.2(a). At a BLER of 10−7, the
code decoded with 50 iterations performs 0.9 dB away from the SPB. At a BER
of 10−10, the code decoded with 50 iterations performs about 1.3 dB away from
the Shannon limit with no visible error-ﬂoor. From this ﬁgure, we also see that the
decoding of the code Cb,sp,d,qc converges very fast. The performance gap between
5 and 10 iterations is about 0.2 dB and the gap between 10 and 50 iterations is less
than 0.1 dB.
The UEBR and UEBLR performances of the code Cb,sp,d,qc over the BEC are
shown in Fig. 8.2(b). At a UEBR of 10−9, the code performs about 0.026 away
from the Shannon limit (0.05).
8.3 Masking and Variations
In the construction of a doubly CPM-QC-SP-LDPC code using the method pre-
sented in the last section, masking can be performed on the r constituent matrices
R0,0,R0,1,...,R0,r−1 of the base matrix Bq,sp,p(m,n). The masked constituent
09
12:40:00, subject to the Cambridge Core terms of use,

4.5
5
5.5
6
6.5
7
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(16560,15737), itr5, BLER
(16560,15737), itr5, BER
(16560,15737), itr10, BLER
(16560,15737), itr10, BER
(16560,15737), itr50, BLER
(16560,15737), itr50, BER
Shannon Limit
SPB
0.022
0.024
0.026
0.028
0.03
0.032
0.034
0.036
0.038
(b)
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
UEBLR/UEBR
ε
(16560, 15737), UEBLR
(16560, 15737), UEBR
Figure 8.2. (a) The BER and BLER performances of the (16 560, 15 373) doubly
CPM-QC-SP-LDPC code Cb,sp,d,qc decoded with 50, 10, and 5 iterations of the
MSA given in Example 8.2 over the AWGN channel; and (b) performance of the
code in (a) over the BEC.
09
12:40:00, subject to the Cambridge Core terms of use,

106
8 Doubly QC-LDPC Codes
matrices R0,0,mask,R0,1,mask,...,R0,r−1,mask are used to form a cyclic masked
base matrix Bq,sp,p,mask(m,n) using [R0,0,mask,R0,1,mask,...,R0,r−1,mask] as the
generator row-block. Let Hb,sp,d,qc,mask(q −1,q −1) be the CPM-dispersion of
Bq,sp,p,mask(m,n). Then, the null space of Hb,sp,d,qc,mask(q −1,q −1) gives a
new doubly CPM-QC-SP-LDPC code Cb,sp,d,qc,mask whose Tanner graph will
have a smaller number of short cycles or a girth larger (or both) than the unmasked
code Cb,sp,d,qc.
Masking can also be performed on the base array Bq,sp,p(m,n). In this case,
some constituent matrices in Bq,sp,p(m,n) are replaced by m × n ZMs. If we
want to maintain the bock-cyclic structure, the masking matrix Zc should be an
r × r circulant. Masking the r × r base array Bq,sp,p(m,n) with Zc, we obtain a
masked block-cyclic base array Bq,sp,p,mask,c(m,n). Then, the null space of the
CPM-dispersion of Bq,sp,p,mask,c(m,n) gives a doubly CPM-QC-SP-LDPC code
Cb,sp,d,qc,mask,c. The subscript “c” stands for “cyclic masking.”
Of course, masking can be performed on both the constituent matrices R0,0,
R0,1, ..., R0,r−1 of the base array Bq,sp,p(m,n) and the array itself. This double
masking results in a doubly masked base matrix Bq,sp,p,mask,dc(m,n). If the array
masking is cyclic, then the null space of the CPM-dispersion of the masked
base matrix Bq,sp,p,mask,dc(m,n) gives a doubly CPM-QC-SP-LDPC code. The
subscript “dc” stands for “doubly cyclic masking.”
Since the base array Bq,sp,p(m,n) satisﬁes the 2 × 2 SM-constraint, any
subarray of Bq,sp,p(m,n) also satisﬁes the 2 × 2 SM-constraint and hence its
CPM-dispersion gives a CPM-QC-SP-LDPC code whose Tanner graph has girth at
least 6. In this case, the code may not have a doubly QC-structure. For example, if
we take the ﬁrst s row-blocks of Bq,sp,p(m,n), 1 ≤s < r, we obtain an s × r
array Bq,sp,p(s,r,m,n) of m × n matrices over GF(q) which does not have a
block-cyclic structure (the cyclic-shift of the last row-block does not give the top
row-block). The null space of the CPM-dispersion of Bq,sp,p(s,r,m,n) gives a
CPM-QC-SP-LDPC code of length nr(q −1) and rate at least (nr −ms)/nr, but
not a doubly QC-LDPC code.
If s divides r, then r = st with 1 < t < r. Suppose we take the 0-th, t-th, 2t-th,
..., (s −1)t-th row-blocks of Bq,sp,p(m,n) to form the following s × r subarray
Bq,sp,p(s,r,m,n):
Bq,sp,p(s,r,m,n) =
⎡
⎢⎢⎢⎢⎢⎣
R0,0
R0,1
···
R0,r−1
R0,r−t
R0,r−t+1
···
R0,r−t−1
R0,r−2t
R0,r−2t+1
···
R0,r−2t−1
...
...
...
...
R0,t
R0,t+1
···
R0,t−1
⎤
⎥⎥⎥⎥⎥⎦
.
(8.6)
09
12:40:00, subject to the Cambridge Core terms of use,

8.3 Masking and Variations
107
From (8.6), we see that each row-block of Bq,sp,p(s,r,m,n) is the cyclic-shift of
the row-block above it t constituent matrices (or nt positions) to the right and the
top row-block is the cyclic-shift of the last row-block t constituent matrices to the
right. So, Bq,sp,p(s,r,m,n) has a block-cyclic structure. In this case, the null space
of the CPM-dispersion of Bq,sp,p(s,r,m,n) gives a doubly CPM-QC-SP-LDPC
code of length nr(q −1).
Masking can be performed on the array Bq,sp,p(s,r,m,n) (masking its
constituent matrices) to obtain a masked array Bq,sp,p,mask(s,r,m,n). The null
space of the CPM-dispersion of Bq,sp,p,mask(s,r,m,n) gives a new doubly
CPM-QC-SP-LDPC code of length nr(q −1) with rate at least (nr −ms)/nr.
Example 8.3. Consider the 16 × 16 matrix WRS over GF(17) in the form given
by (8.1) constructed in Example 8.1. Suppose, we choose r = l = 4 and view the
matrix WRS as a 4 × 4 array of 4 × 4 submatrices with 4 constituent matrices,
W∗
0,0,W∗
0,1,W∗
0,2, and W∗
0,3. Take 2 × 4 submatrices from these 4 constituent
matrices W∗
0,0,W∗
0,1,W∗
0,2, and W∗
0,3 in the way we described in this section (here
we take the ﬁrst two rows). Then, we obtain a 4 × 4 array B∗
q,sp,p(2,4) of 2 × 4
submatices in the form given by (8.3). It is easy to see that the array B∗
q,sp,p(2,4)
has a block-cyclic structure. Consider the following masking matrix:
Z =
⎡
⎢⎢⎣
0
1
1
0
0
0
1
1
1
0
0
1
1
1
0
0
⎤
⎥⎥⎦.
The matrix Z has a cyclic structure. Replacing each 1-entry in Z by a 2 × 4
matrix with all 1-entries and each 0-entry by a 2 × 4 matrix with all 0-entries, we
obtain a new matrix given as below:
Z∗=
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
1
1
1
1
1
1
1
1
0
0
0
0
0
0
0
0
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
.
(8.7)
We can see that the matrix Z∗also has a block-cyclic structure. If we cyclically
shift the ﬁrst two rows of Z∗4 positions to the right simultaneously, we obtain
the next two rows of Z∗. And the ﬁrst two rows of Z∗is the cyclic shift of
the last two rows 4 positions to the right. It is easy to check that Z∗has the
09
12:40:00, subject to the Cambridge Core terms of use,

108
8 Doubly QC-LDPC Codes
same block-cyclic structure as the matrix B∗
q,sp,p(2,4). Using Z∗as a masking
matrix to mask the base matrix B∗
q,sp,p(2,4), we obtain a masked 4 × 4 array
B∗
q,sp,p,mask(2,4) of 2 × 4 submatrices. Since B∗
q,sp,p(2,4) and Z∗have the same
block-cyclic structure, after masking, the masked array B∗
q,sp,p,mask(2,4) also
has the same block-cyclic structure. The masked array B∗
q,sp,p,mask(2,4) satisﬁes
the 2 × 2 SM-constraint. The binary CPM-dispersion of B∗
q,sp,p,mask(2,4) results
in an 8 × 16 array Hb,sp,d,qc,mask(16,16) of CPMs and ZMs of size 16 × 16.
The null space of Hb,sp,d,qc,mask(16,16) gives a (4,8)-regular (256,133) doubly
CPM-QC-SP-LDPC code Cb,sp,d,qc,mask with rate 0.5195. The Tanner graph of
the code Cb,sp,d,qc,mask has girth 6 and contains 1600 cycles of length 6 and 26 144
cycles of length 8. The performances of the code Cb,sp,d,qc,mask over the AWGNC
and the BEC are shown in Fig. 8.3(a) and Fig. 8.3(b), respectively. We see that the
constructed code performs well over both the AWGNC and the BEC.
8.4 SP-Construction of CPM-QC-SP-LDPC Codes
As shown earlier, in Section 8.2, the matrices CPM(R0,0), CPM(R0,1), ...,
CPM(R0,r−1) (the CPM-dispersions of R0,0,R0,1,...,R0,r−1) satisfy both the
RC- and the PW-RC-constraints. Hence, they can be used as member matrices of
a replacement set R for the SP-construction of QC-SP-LDPC codes. By properly
choosing a base matrix and using these matrices as the replacement matrices, the
SP-construction will result in a CPM-QC-SP-LDPC code whose Tanner graph has
girth at least 6.
If the base matrix has a cyclic structure (such as the circulants constructed based
on Euclidean geometries presented in Section 6.1), the replacement of its 1-entries
with CPM(R0,0), CPM(R0,1), ..., CPM(R0,r−1) can be carried out in a cyclic
manner, which will result in a parity-check array with both the block-cyclic and
the section-wise cyclic structures. Furthermore, each of the matrices CPM(R0,0),
CPM(R0,1), ..., CPM(R0,r−1), or a subset, can be used as an SP-base matrix for
the construction of QC-SP-LDPC codes or a decomposition base matrix for the
algebraic construction of QC-PTG-LDPC codes.
8.5 Discussion and Remarks
As pointed out in Section 8.2, the doubly CPM-QC-SP-LDPC code Cb,sp,d,qc
can be decoded with either the reduced-complexity iterative decoding scheme
proposed in [79] based on its block-cyclic structure or the reduced-complexity
iterative decoding scheme presented in [69, 68, 78] based on its section-wise cyclic
09
12:40:00, subject to the Cambridge Core terms of use,

1
1.5
2
2.5
3
3.5
4
4.5
5
5.5
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(256, 133), Cb,sp,d,qc,mask, BLER
(256, 133), Cb,sp,d,qc,mask, BER
SPB
0.2
0.25
0.3
0.35
0.4
0.45
0.5
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
(256, 133), Cb,sp,d,qc,mask, UEBLR
(256, 133), Cb,sp,d,qc,mask, UEBR
Shannon Limit
Figure 8.3. (a) The BER and BLER performances of the (256,133) doubly
CPM-QC-SP-LDPC code Cb,sp,d,qc,mask given in Example 8.3 over the AWGNC;
and (b) performance of the code in (a) over the BEC.
09
12:40:00, subject to the Cambridge Core terms of use,

110
8 Doubly QC-LDPC Codes
structure. Using the method proposed in [79], we can use the m(q −1)×nr(q −1)
matrix Hdec,0 = [CPM(R0,0) CPM(R0,1) ... CPM(R0,r−1)] (the top row-block of
Hb,sp,d,qc(q −1,q −1) given by (8.4)) as the decoding matrix. Using the method
proposed in [69, 68, 78], we can use the mr × nr(q −1) matrix Hdec,1 formed by
taking the ﬁrst rows of the mr row-blocks of CPMs and ZMs of the mr ×nr array
Hb,sp,d,qc(q −1,q −1) given by (8.4) as the decoding matrix.
Suppose we implement two decoders to decode the code Cb,sp,d,qc jointly in
a turbo decoding manner, one based on the decoding matrix Hdec,0 and the other
based on the decoding matrix Hdec,1. Whether this turbo decoding will enhance the
performance of the code Cb,sp,d,qc, in terms waterfall error probability, error-ﬂoor,
and rate of decoding convergence, is an interesting problem to investigate.
Another interesting problem for investigation is: besides the base matrix given
by (8.1), whether there are other base matrices over NB ﬁelds that satisfy the 2×2
SM-constraint and have a cyclic structure.
09
12:40:00, subject to the Cambridge Core terms of use,

9
SP-Construction of Spatially Coupled
QC-LDPC Codes
In this chapter, we present an algebraic construction of a special type of LDPC
code whose Tanner graph has a very speciﬁc structure. For an LDPC code of this
type, its Tanner graph is locally connected. Every VN is only connected to the
CNs that are conﬁned to a (small) span of ρcol consecutive locations and every CN
is only connected to VNs that are conﬁned to a (small) span of ρrow consecutive
locations. We call such constraints on the connections between VNs and CNs of
a Tanner graph (ρcol,ρrow)-span-constraints. With this span-constraint, the Tanner
graph of such an LDPC code is actually a chain of small Tanner graphs in which
each graph is connected to its adjacent graphs on either side of it, except the
ﬁrst and the last ones. An LDPC code of this type is called a span-constrained
LDPC code. The SC-LDPC code investigated in [59, 60, 22, 86] is a type of
span-constrained LDPC code.
An SC-LDPC code is an LDPC convolutional (LDPC-C) code viewed from a
graphical point of view (or a spatial coupling point of view) [49, 104, 66, 67, 92].
An LDPC-C code [49, 104] is speciﬁed by a bi-inﬁnite parity-check matrix whose
nonzero entries are conﬁned to a diagonal band of a certain width ρrow and a
certain depth ρcol. The nonzero entries in every row are conﬁned to a span of
ρrow consecutive locations and the nonzero entries in every column are conﬁned
to a span of ρcol consecutive locations. With these constraints on the locations of
the nonzero entries of the parity-check matrix of an LDPC-C code, every VN in
its Tanner graph is only connected to the CNs that are conﬁned to a span of ρcol
consecutive locations and every CN is only connected to VNs that are conﬁned
to a span of ρrow consecutive locations. These constraints on the locations of the
nonzero entries of the parity-check matrix of an LDPC-C code lead to the graphical
(ρcol,ρrow)-span-constraint as mentioned above. Hence, an LDPC-C code is a
span-constrained LDPC code, an SC-LDPC code.
Over the past 15 years, a great deal of research effort has been expended
on the study of LDPC-C codes and impressive theoretical results have been
111
10
12:42:19, subject to the Cambridge Core terms of use,

112
9 SP-Construction of QC-SC-LDPC Codes
developed [66, 67, 59]. However, the employment of LDPC-C codes in practical
applications has lagged behind their theoretical development. Recently, LDPC-C
codes have been re-examined from a graphical point of view. As a consequence,
they have been renamed spatially coupled (SC) LDPC codes in a series of
papers [59, 60, 22, 86], which has generated additional research interest for their
asymptotically good ensemble performance and structural properties. Reference
[22] gives a very good tutorial presentation of the structure of LDPC-C and
SC-LDPC codes and also presents some open research problems. Their advantages
and disadvantages compared with typical block LDPC codes will be discussed at
the end of this chapter.
In this chapter, we present SP-based methods (or CPM-dispersion methods) for
constructing algebraic QC-SC-LDPC codes and their terminated codes. Two types
of QC-SC-LDPC codes are presented. In our presentation, we consider only the
construction of binary QC-SC-LDPC codes.
9.1 Base Matrices and Their Structural Properties
A base matrix for a QC-SC-LDPC code can be constructed from the 2 × 2
SM-constrained r ×r array Bq,sp,p(m,n) of m ×n submatrices over GF(q) with a
block-cyclic structure given by (8.3). To give a better picture of the construction,
we permute the row-blocks of Bq,sp,p(m,n) to put it in the following block-cyclic
structure form:
B′
q,sp,p(m,n) =
⎡
⎢⎢⎢⎣
R0,0
R0,1
···
R0,r−2
R0,r−1
R0,1
R0,2
···
R0,r−1
R0,0
...
...
...
...
...
R0,r−1
R0,0
···
R0,r−3
R0,r−2
⎤
⎥⎥⎥⎦.
(9.1)
From (9.1), we see that, for 0 ≤i < r, the i-th column-block of B′
q,sp,p(m,n) is
identical to the i-th row-block. Actually, the permuted array B′
q,sp,p(m,n) can be
obtained by cyclically shifting the top row-block of Bq,sp,p(m,n) given by (8.3)
to the left r −1 times, one submatrix at a time. Since permuting the row-blocks of
Bq,sp,p(m,n) does not affect its 2×2 SM-constrained property, the permuted array
B′
q,sp,p(m,n) still satisﬁes the 2×2 SM-constraint and all the constituent matrices
R0,0,R0,1,...,R0,r−1 of the top row-block of the array B′
q,sp,p(m,n) still satisfy
both the 2 × 2 and the PW-2 × 2 SM-constraints.
Let e and τ be two positive integers such that e ≥2 and τe < r. Using the
constituent matrices R0,0,R0,1,...,R0,r−1 of the left most column-block (or the
10
12:42:19, subject to the Cambridge Core terms of use,

9.1 Base Matrices and Their Structural Properties
113
top row-block) of the array B′
q,sp,p(m,n), we form the following semi-inﬁnite
array over GF(q):
q,sp,sc(τ,m,n) =
R0,0
R0,1
R0,e
...
R0,e+1
...
...
...
...
R0,(τ−1)e
...
...
... R0,(τ−1)e+1
R0,0
R0,e−1
...
...
...
R0,1
R0,e
R0,2e−1
...
...
...
R0,e+1
...
...
...
...
...
...
R0,(τ−1)e
R0,τe−1
...
...
... R0,(τ−1)e+1
...
R0,e−1
...
...
...
...
R0,2e−1
...
...
...
...
...
...
R0,τe−1
...
...
⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝
⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
.
(9.2)
Note that all the nonzero matrices in the semi-inﬁnite array q,sp,sc(τ,m,n)
given above lie on a diagonal band of width en and depth em. This semi-inﬁnite
array q,sp,sc(τ,m,n) has the following structural properties: (1) Every
column-block consists of e distinct nonzero m × n matrices taken from the
PW-2×2 SM-constrained set {R0,0,R0,1,...,R0,r−1}; (2) The e nonzero matrices
in every column-block are conﬁned to a span of em consecutive locations, called
a nonzero column-block-span; (3) For 0 ≤j < τ, the e matrices in the nonzero
column-block-span with the matrix R0, je as the ﬁrst matrix are the top e matrices
of the je-th column-block of the r × r cyclic array B′
q,sp,p(m,n) given by (9.1);
(4) All the τe nonzero matrices in the nonzero column-block-spans of τ consec-
utive column-blocks are distinct; (5) Every nonzero column-block-span repeats
itself every τ consecutive nonzero column-block-spans but is shifted downward
τ positions; (6) Every (e + τ −1) × τ subarray that consists of the nonzero
column-block-spans of any τ consecutive column-blocks of q,sp,sc(τ,m,n),
10
12:42:19, subject to the Cambridge Core terms of use,

114
9 SP-Construction of QC-SC-LDPC Codes
called a τ-span subarray, is a subarray of the r ×r cyclic array B′
q,sp,p(m,n) given
by (9.1) after replacing some submatrices in B′
q,sp,p(m,n) by ZMs; and (7) Every
τ-span subarray consists of the same set of τ nonzero column-block-spans, but
not necessarily in the same order. A τ-span subarray of q,sp,sc(τ,m,n) is an
m(e + τ −1) × nτ matrix over GF(q).
Structural properties 3, 6, and 7 of the semi-inﬁnite array q,sp,sc(τ,m,n)
simply follow from the block-cyclic structure of B′
q,sp,p(m,n). Since every
τ-span subarray of q,sp,sc(τ,m,n) is a subarray of B′
q,sp,p(m,n) and since the
array B′
q,sp,p(m,n) satisﬁes the 2 × 2 SM-constraint, every τ-span subarray of
q,sp,sc(τ,m,n) satisﬁes the 2 × 2 SM-constraint. It follows that the semi-inﬁnite
array q,sp,sc(τ,m,n) satisﬁes the 2 × 2 SM-constraint.
For j ≥0, the jτ-th to the (( j +1)τ −1)-th column-blocks of q,sp,sc(τ,m,n)
form a period of q,sp,sc(τ,m,n). Two periods of q,sp,sc(τ,m,n) do not
overlap and they cover the same set of nonzero column-block-spans in the same
order. Hence, q,sp,sc(τ,m,n) consists of inﬁnite repetitions of the ﬁrst period
formed by the 0-th to the (τ −1)-th column-blocks of q,sp,sc(τ,m,n). The
semi-inﬁnite array q,sp,sc(τ,m,n) is said to have a period τ. The τ nonzero
column-block-spans of a period of q,sp,sc(τ,m,n) forms a τ-span subarray of
q,sp,sc(τ,m,n).
Let Bq,sp,sc(τ,m,n) be the ﬁrst τ-span subarray of the semi-inﬁnite array
q,sp,sc(τ,m,n) (i.e., the ﬁrst τ nonzero column-block-spans of q,sp,sc(τ,m,n))
and let Gq,sp,sc(τ,m,n) be the Tanner graph associated with Bq,sp,sc(τ,m,n).
Then, from the structure of q,sp,sc(τ,m,n) displayed in (9.2), we see that the
Tanner graph associated with q,sp,sc(τ,m,n), denoted by Gq,sp,sc(), consists
of an inﬁnite number of ordered copies of Gq,sp,sc(τ,m,n), each connected to the
two adjacent ones on either side of it by edges, except for the ﬁrst one. The set of
connecting edges between any two consecutive periods (or two adjacent copies of
Gq,sp,sc(τ,m,n)) is the same. Therefore, the Tanner graph Gq,sp,sc() associated
with q,sp,sc(τ,m,n) has an inﬁnite chain-like structure.
The semi-inﬁnite array q,sp,sc(τ,m,n) of m ×n submatrices over GF(q) is the
base array for constructing a QC-SC-LDPC code.
9.2 Type-1 QC-SC-LDPC Codes
Let Hb,sp,sc(τ,m,n) be the binary CPM-dispersion of q,sp,sc(τ,m,n). Then,
Hb,sp,sc(τ,m,n) is a semi-inﬁnite array of binary CPMs and ZMs of size
(q −1) × (q −1) with period τ. It follows from the 2 × 2 SM-constrained
property of the array q,sp,sc(τ,m,n) that the array Hb,sp,sc(τ,m,n) satisﬁes the
10
12:42:19, subject to the Cambridge Core terms of use,

9.2 Type-1 QC-SC-LDPC Codes
115
RC-constraint. The null space of the array Hb,sp,sc(τ,m,n) gives a periodically
time-varying CPM-QC-SC-LDPC code, denoted by Cb,sp,sc(τ), with period τ.
The Tanner graph, denoted by Gb,sp,sc(), of the CPM-QC-SC-LDPC code
Cb,sp,sc(τ), contains no cycle of length 4 and hence has girth at least 6. It is
a periodically time-varying LDPC-C code with constraint length en(q −1) (in
symbols). The CPM-QC-SC-LDPC code Cb,sp,sc(τ) constructed based on the
array q,sp,sc(τ,m,n) is referred to as a type-1 CPM-QC-SC-LDPC code.
For 0 ≤j < r, let CPM(R0, j) be the binary CPM-dispersion of the m × n
matrix R0, j over GF(q). From the SP-construction point of view, the parity-check
matrix Hb,sp,sc(τ,m,n) of the time-varying CPM-QC-SC-LDPC code Cb,sp,sc(τ)
is constructed by using the set
R = {CPM(R0,0),CPM(R0,1),...,CPM(R0,r−1)}
(9.3)
of m(q −1) × n(q −1) matrices (m × n array of CPMs of size (q −1) ×
(q −1)) as the replacement set R and the binary matrix Bsp given by (9.4) as
the SP-base matrix. Hence, the CPM-QC-SC-LDPC code Cb,sp,sc(τ) is also a
CPM-QC-SP-LDPC code.
From the PTG-construction point of view, the Tanner graph Gq,sp,sc(τ,m,n) of
the ﬁrst τ-span subarray Bq,sp,sc(τ,m,n) of the array q,sp,sc(τ,m,n) may be
regarded as the protograph for the PTG-construction of the CPM-QC-SC-LDPC
code Cb,sp,sc(τ). The edges of Gq,sp,sc(τ,m,n) are labeled with nonzero ele-
ments in GF(q). In the PTG-based construction of the parity-check matrix
Hb,sp,sc(τ,m,n) of the code Cb,sp,sc(τ), there are two expansions of the
protograph Gq,sp,sc(τ,m,n), ﬁrst expanding Gq,sp,sc(τ,m,n) into Gq,sp,sc() by
taking an inﬁnite number of copies of Gq,sp,sc(τ,m,n) and connecting them into
a chain and then expanding Gq,sp,sc() by binary CPM-dispersing the q-ary
label of each edge in Gq,sp,sc() to construct the Tanner graph Gb,sp,sc() of
the code Cb,sp,sc(τ) as described above. The adjacency matrix of Gb,sp,sc()
gives the parity-check matrix Hb,sp,sc(τ,m,n) of the code Cb,sp,sc(τ). Therefore,
the CPM-QC-SC-LDPC code Cb,sp,sc(τ) can be viewed as a QC-PTG-LDPC
code.
Since Hb,sp,sc(τ,m,n) is the CPM-dispersion of q,sp,sc(τ,m,n), the Tanner
graph of the time-varying CPM-QC-SC-LDPC code Cb,sp,sc(τ) is a chain of
identical subgraphs, each being an expansion of the graph Gq,sp,sc(τ,m,n)
by a factor of q −1. Each of these subgraphs is the Tanner graph of the
CPM-dispersion of Bq,sp,sc(τ,m,n), the ﬁrst τ-span subarray of the semi-inﬁnite
array q,sp,sc(τ,m,n).
Since a type-1 CPM-QC-SC-LDPC code is an LDPC-C code, the methods
devised for decoding an LDPC-C code [74, 47] can be applied to decode the
10
12:42:19, subject to the Cambridge Core terms of use,

116
9 SP-Construction of QC-SC-LDPC Codes
CPM-QC-SC-LDPC code Cb,sp,sc(τ). The rate of the code Cb,sp,sc(τ) is at least
(n −m)/n.
Bsp =
1
1 1
... 1 ...
...
...
... 1
...
...
... 1 1
1 ...
...
... 1 1
1 ...
...
... 1 ...
...
...
...
...
... 1
1 ...
...
... 1
...
1 ...
...
...
...
1 ...
...
...
...
...
...
1
...
...
⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝
⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
.
(9.4)
Example 9.1. In this example, we use the ﬁeld GF(127) for constructing a
CPM-QC-SC-LDPC code. First, we construct a 126 × 126 cyclic matrix Bq,sp,p
over GF(127) in the form given by (8.2) which satisﬁes the 2 × 2 SM-constraint.
Factor 127−1 = 126 as the product of 63 and 2, and set r = 63 and l = 2. Choose
m = 1 and n = 2. Then, following the construction process in Section 9.1, we form
a 63 × 63 cyclic array B′
q,sp,p(1,2) of 1 × 2 matrices in the form of (9.1). The top
row-block of this array consists of 63 constituent matrices R0,0,R0,1,...,R0,62 of
size 1 × 2.
Choose e = 4 (nonzero column-block-span) and τ = 4 (period). Using the
constituent matrices R0,0,R0,1,...,R0,15, we form the following semi-inﬁnite
base array:
10
12:42:19, subject to the Cambridge Core terms of use,

9.2 Type-1 QC-SC-LDPC Codes
117
q,sp,sc(4,1,2) =
R0,0
R0,1 R0,4
R0,2 R0,5
R0,8
R0,3 R0,6
R0,9
R0,12
R0,7 R0,10 R0,13 R0,0
R0,11 R0,14 R0,1 R0,4
R0,15 R0,2 R0,5
R0,8
R0,3 R0,6
R0,9
R0,12
R0,7 R0,10 R0,13
...
R0,11 R0,14
...
R0,15
...
...
⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝
⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
.
(9.5)
The CPM-dispersion of the above matrix q,sp,sc(4,1,2) gives a semi-inﬁnite
array Hb,sp,sc(4,1,2) of binary CPMs and ZMs of size 126 × 126, which is
a (504,1008)-span-constrained matrix. The null space of Hb,sp,sc(4,1,2) gives
a type-1 periodically time-varying CPM-QC-SC-LDPC code Cb,sp,sc(4) with a
period of 4 whose Tanner graph has girth 6. The code can achieve a rate of 0.5
with an unterminated decoding.
Suppose we decode this code with 1000 iterations of the SPA with a decoding
block of length L = 88 (i.e., over the span of M = 22 periods). In this case, the code
length is 22 176 and the rate is 0.4831. The Tanner graph of the terminated code
Ct
b,sp,sc(4) has girth 6 and contains 13 608 cycles of length 6 and 203 238 cycles
of length 8. (The subscript “t” in Ct
b,sp,sc(4) stands for “termination.”) The bit
error probability performance of the terminated code over the AWGNC is shown in
Fig. 9.1(a). At a BER of 10−6, the code performs about 1.5 dB away from the Shan-
non limit. Also included in this ﬁgure is the BER performance of a QC-SC-LDPC
code Ccjl of length 25 000 bits and rate 0.488 reported in [14]. The subscript “cjl”
stands for the ﬁrst letters of the last names of the authors, Chandrasetty, Johnson,
and Lechner. The code Ccjl, designed with a good decoding threshold, is also
decoded with 1000 iterations of the SPA. From the ﬁgure, we see that the algebraic
CPM-QC-SC-LDPC code Ct
b,sp,sc(4) constructed in this example outperforms the
PTG-based QC-SC-LDPC code Ccjl given in [14] by about 0.1 dB.
10
12:42:19, subject to the Cambridge Core terms of use,

118
9 SP-Construction of QC-SC-LDPC Codes
The UEBR and UEBLR performances of the code Ct
b,sp,sc(4) over the BEC are
shown in Fig. 9.1(b).
The base matrix Bq,sp,sc(4,1,2) for constructing the semi-inﬁnite CPM-QC-SC-
LDPC code Cb,sp,sc(4) (or the terminated code Ct
b,sp,sc(4)) is
Bq,sp,sc(4,1,2) =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
R0,0
R0,1
R0,4
R0,2
R0,5
R0,8
R0,3
R0,6
R0,9
R0,12
R0,7
R0,10
R0,13
R0,11
R0,14
R0,15
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
,
which is a 7×8 matrix over GF(127). The Tanner graph Gq,sp,sc(4,1,2) associated
with the base matrix Bq,sp,sc(4,1,2) consists of 7 CNs, 8 VNs, and 32 edges
labeled with elements from GF(127) as shown in Fig. 9.2. From the graphical point
of view, Gq,sp,sc(4,1,2) is the protograph for constructing the CPM-QC-SC-LDPC
code Ct
b,sp,sc(4).
If we choose various r, l, m, n, e, and τ, we can construct a sequence of
CPM-QC-SC-LDPC codes with various rates based on base matrices in the form
of (9.1) over an NB ﬁeld GF(q).
Example 9.2. In this example, we use the same ﬁeld GF(127) for code
construction as in Example 9.1. This time, we factor out 126 as the product of
21 and 6. Set r = 21 and l = 6 and choose m = 1, n = 4, e = 4, and τ = 4. With
these parameters, we can construct a semi-inﬁnite array Hb,sp,sc(4,1,4) of binary
CPMs and ZMs of size 126×126. The null space of Hb,sp,sc(4,1,4) gives a type-1
periodically time-varying CPM-QC-SC-LDPC code Cb,sp,sc(4) with period 4. The
rate of this code is 0.75 (with unterminated decoding).
If we terminate Cb,sp,sc(4) by setting M = 11 (L = 44), we obtain a terminated
CPM-QC-SC-LDPC code Ct
b,sp,sc(4) with length 22 176 and rate 0.7331. The bit
error probability performance of this terminated code over the AWGNC decoded
with 1000 iterations of the SPA is shown in Fig. 9.3(a) and its erasure error
performance over the BEC is shown in Fig. 9.3(b). At a BER of 10−6, the code
performs within 1 dB of the Shannon limit.
10
12:42:19, subject to the Cambridge Core terms of use,

9.2 Type-1 QC-SC-LDPC Codes
119
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BER
Eb/N0
Cb,sp,sc
t
(4), r=0.483
Ccjl, r=0.488
Cb,sp,sc
t
(4), Shannon limit
0.4
0.42
0.44
0.46
0.48
0.5
0.52
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
Ct
b,sp,sc(4), r=0.483, UEBLR
Ct
b,sp,sc(4), r=0.483, UEBR
Ct
b,sp,sc (4), Shannon limit
Figure 9.1. (a) The bit error probability performances of the CPM-QC-SC-LDPC
code Ct
b,sp,sc(4) given in Example 9.1 and the code Ccjl given in [14] over the
AWGNC; (b) performance of the code Ct
b,sp,sc(4) in (a) over the BEC.
10
12:42:19, subject to the Cambridge Core terms of use,

120
9 SP-Construction of QC-SC-LDPC Codes
Figure 9.2. The Tanner graph Gq,sp,sc(4,1,2) of the base matrix Bq,sp,sc(4,1,2)
given in Example 9.1.
9.3 Type-2 QC-SC-LDPC Codes
Suppose we form a semi-inﬁnite array ⋆
q,sp,sc(τ,m,n) in which the i-th
row-block is identical to the i-th column-block of the array q,sp,sc(τ,m,n) given
by (9.2), with i = 0,1,..., as follows:
⋆
q,sp,sc(τ,m,n) =
R0,0R0,1
···
···
···
R0,e−1
R0,eR0,e+1
···
···
···
R0,2e−1
...
...
...
...
...
...
R0,(τ−1)eR0,(τ−1)e+1
···
···
···
R0,τe−1
R0,0
R0,1
···
···
···
R0,e−1
R0,e
R0,e+1
···
···
···
R0,2e−1
...
...
...
...
...
...
R0,(τ−1)eR0,(τ−1)e+1
···
···
···R0,τe−1
...
...
...
...
...
...
⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝
⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
.
(9.6)
Note that all the nonzero matrices in the semi-inﬁnite array ⋆
q,sp,sc(τ,m,n)
given above lie in a diagonal band of width en and depth em. The structural
properties of ⋆
q,sp,sc(τ,m,n) can be developed from the structural properties of
the array q,sp,sc(τ,m,n) just by changing “column” to “row” and “downward”
to “rightward.” Every nonzero row-block-span repeats itself every τ consecutive
nonzero row-block-spans but shifted to the right by τ positions. Every τ × (e +
τ −1) subarray of ⋆
q,sp,sc(τ,m,n) that consists of the nonzero row-block-spans
of any τ consecutive row-blocks of ⋆
q,sp,sc(τ,m,n), called a τ-span subarray, is
a subarray of the r × r cyclic array B′
q,sp,p(m,n) given by (9.1) after replacing
some entries with ZMs. Furthermore, every such τ-span subarray consists of the
10
12:42:19, subject to the Cambridge Core terms of use,

9.3 Type-2 QC-SC-LDPC Codes
121
1.4
1.6
1.8
2
2.2
2.4
2.6
2.8
10
−6
10
−5
10
−4
10
−3
10
−2
10
(a)
−1
BER
Eb/N0
Ct
b,sp,sc(4), r=0.733
Ct
b,sp,sc(4), Shannon limit
0.19
0.2
0.21
0.22
0.23
0.24
0.25
0.26
0.27
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
Ct
b,sp,sc(4), r=0.733, UEBLR
Ct
b,sp,sc(4), r=0.733, UEBR
Ct
b,sp,sc(4), Shannon limit
Figure 9.3. (a) The bit error probability performance of the CPM-QC-SC-LDPC
code Ct
b,sp,sc(4) given in Example 9.2 over the AWGNC; and (b) performance of
the code in (a) over the BEC.
10
12:42:19, subject to the Cambridge Core terms of use,

122
9 SP-Construction of QC-SC-LDPC Codes
same set of τ nonzero row-block-spans, but not necessarily in the same order. Note
that a τ-span subarray of ⋆
q,sp,sc(τ,m,n) is an mτ × n(e + τ −1) matrix over
GF(q).
The structure of the Tanner graph Gq,sp,sc(⋆) associated with the array
⋆
q,sp,sc(τ,m,n) can be analyzed in a similar way as the Tanner graph Gq,sp,sc()
of the array q,sp,sc(τ,m,n) in the construction of type-1 CPM-QC-SC-LDPC
codes. It is an inﬁnite chain of an inﬁnite number of copies of the Tanner graph
G⋆
q,sp,sc(τ,m,n) of the ﬁrst τ-span subarray of ⋆
q,sp,sc(τ,m,n).
Dispersing each nonzero entry in ⋆
q,sp,sc(τ,m,n) into a CPM of size (q −1)×
(q −1) and each zero entry to a (q −1) × (q −1) ZM, we obtain a semi-inﬁnite
array H⋆
b,sp,sc(τ,m,n) of CPMs and ZMs of size (q −1)×(q −1). The null space
of H⋆
b,sp,sc(τ,m,n) gives a type-2 periodically time-varying CPM-QC-SC-LDPC
code C⋆
b,sp,sc(τ).
From the graph-theoretic point of view, the graph G⋆
q,sp,sc(τ,m,n) is regarded
as the protograph for constructing the CPM-QC-SC-LDPC code C⋆
b,sp,sc(τ).
From the SP point of view, the base matrix for the SP-construction of C⋆
b,sp,sc
(τ) is:
B⋆
sp =
⎡
⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎣
1
1
···
···
···
1
1
1
···
···
···
1
...
...
...
...
...
...
1
1
···
···
···
1
1
1
···
···
···
1
...
...
...
...
...
...
⎤
⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎦
,
(9.7)
and the replacement set is {CPM(R0,0),CPM(R0,1),...,CPM(R0,r−1)}.
Example 9.3. In Example 9.1, we construct a 63 × 63 cyclic array B′
q,sp,p(1,2)
of 1 × 2 matrices in the form of (9.1). The top row of this array consists of 63
constituent 1 × 2 matrices R0,0,R0,1,...,R0,62.
Choose e = 4 (row-block-span) and τ = 4 (period). Using the constituent
matrices R0,0,R0,1,...,R0,15, we form the following semi-inﬁnite array:
10
12:42:19, subject to the Cambridge Core terms of use,

9.4 Terminated and Tailbiting CPM-QC-SC-LDPC Codes
123
⋆
q,sp,sc(4,1,2) =
R0,0 R0,1 R0,2
R0,3
R0,4 R0,5
R0,6
R0,7
R0,8
R0,9
R0,10 R0,11
R0,12 R0,13 R0,14 R0,15
R0,0
R0,1
R0,2
R0,3
R0,4
R0,5
R0,6
R0,7
R0,8
R0,9
R0,10 R0,11
R0,12 R0,13 R0,14 R0,15
...
...
...
...
⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝
⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
.
(9.8)
The CPM-dispersion of the above matrix ⋆
q,sp,sc(4,1,2) gives a semi-inﬁnite
array H⋆
b,sp,sc(4,1,2) of binary CPMs and ZMs of size 126 × 126. The null space
of H⋆
b,sp,sc(4,1,2) gives a type-2 periodically time-varying CPM-QC-SC-LDPC
code C⋆
b,sp,sc(4) with a period of 4 whose Tanner graph has girth 6.
If we terminate H⋆
b,sp,sc(4,1,2) by setting M = 22 (L = 88) and then remove
the ﬁrst two and last two column-blocks, we obtain a terminated and shortened
array H⋆,t
b,sp,sc(4,1,2). The null space of the new array H⋆,t
b,sp,sc(4,1,2) gives a
CPM-QC-SC-LDPC code C⋆,t
b,sp,sc(4) with length 22 050 and rate 0.4972. The
BER performances of this terminated code over the AWGNC decoded with
1000 and 50 iterations of the SPA are shown in Fig. 9.4(a) and its erasure
error performance over the BEC is shown in Fig. 9.4(b). The gap between 1000
iterations and 50 iterations of the SPA is about 0.2 dB.
The base matrix B⋆
q,sp,sc(4,1,2) for constructing the semi-inﬁnite CPM-QC-SC-
LDPC code C⋆,t
b,sp,sc(4) is
B⋆
q,sp,sc(4,1,2) =
⎡
⎢⎢⎣
R0,0
R0,1
R0,2
R0,3
R0,4
R0,5
R0,6
R0,7
R0,8
R0,9
R0,10
R0,11
R0,12
R0,13
R0,14
R0,15
⎤
⎥⎥⎦.
9.4 Terminated and Tailbiting CPM-QC-SC-LDPC Codes
Suppose we terminate the semi-inﬁnite base array q,sp,sc(τ,m,n) by taking its
ﬁrst M periods and removing all the zero row-blocks. This results in a (τ M +
10
12:42:19, subject to the Cambridge Core terms of use,

124
9 SP-Construction of QC-SC-LDPC Codes
0.2
0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
10
−6
10
−5
10
−4
10
−3
10
−2
10
(a)
−1
BER
Eb/N0
Cb,sp,sc
*, t
(4), itr50
Cb,sp,sc
*, t
(4), itr1000
Shannon limit
0.36
0.38
0.4
0.42
0.44
0.46
0.48
0.5
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
Cb,sp,sc
*, t
(4), UEBLR
Cb,sp,sc
*, t
(4), UEBR
Shannon Limit
Figure 9.4. (a) The BER performances of the CPM-QC-SC-LDPC code
C⋆,t
b,sp,sc(4) decoded with 1000 and 50 iterations of the SPA given in Example 9.3
over the AWGNC; and (b) performance of the code in (a) over the BEC.
10
12:42:19, subject to the Cambridge Core terms of use,

9.4 Terminated and Tailbiting CPM-QC-SC-LDPC Codes
125
e −1)×τ M array of m ×n matrices over GF(q), denoted by t
q,sp,sc(M,τ,m,n).
Since t
q,sp,sc(M,τ,m,n) is a subarray of q,sp,sc(τ,m,n) and q,sp,sc(τ,m,n)
satisﬁes the 2 × 2 SM-constraint, t
q,sp,sc(M,τ,m,n) also satisﬁes the 2 × 2
SM-constraint. The Tanner graph of this array consists of M copies of the
Tanner graph Gq,sp,sc(τ,m,n) connected in a ﬁnite-length chain. The last copy
of Gq,sp,sc(τ,m,n) and the ﬁrst copy of Gq,sp,sc(τ,m,n) may not be directly
connected.
The CPM-dispersion of the ﬁnite array t
q,sp,sc(M,τ,m,n) gives an m(Mτ +
e −1) × nMτ array, denoted by Ht
b,sp,sc(M,τ,m,n), of binary CPMs and
ZMs of size (q −1) × (q −1). The null space of Ht
b,sp,sc(M,τ,m,n) gives
a block CPM-QC-SC-LDPC code Ct
b,sp,sc(τ) of length nMτ(q −1) whose
Tanner graph Gb,sp,sc(t) contains no cycle of length 4 and has a ﬁnite-length
chain-like structure. We call this code Ct
b,sp,sc(τ) an L-block-terminated type-1
CPM-QC-SC-LDPC code where L = Mτ. The superscript “t” in t
q,sp,sc(τ,m,n),
Ht
b,sp,sc(τ,m,n), and Ct
b,sp,sc(τ) stands for “terminated.” An L-block-terminated
type-1 CPM-QC-SC-LDPC code can be decoded with any conventional iterative
decoding algorithm of a block LDPC code, such as the SPA, the MSA, or
their simpliﬁed variations. The code Ct
b,sp,sc(τ) has a rate at least (n −m)/n −
(e −1)m/nL. Therefore, there is a rate loss of (e −1)m/nL compared to the
unterminated code. For a large L, the rate loss is very small.
Now suppose we terminate the semi-inﬁnite base matrix q,sp,sc(τ,m,n) by
taking the ﬁrst M τ-span subarrays and wrapping the last e −1 row-blocks to the
top in the way as shown in (9.9). This results in an Mτ × Mτ array, denoted by
tb
q,sp,sc(M,τ,m,n) in the form of (9.9), of m × n matrices over GF(q). Every
row-block of the array tb
q,sp,sc(M,τ,m,n) contains e nonzero m × n matrices
and every column-block contains e nonzero m × n matrices. The Tanner graph
Gtb
q,sp,sc(tb) of tb
q,sp,sc(M,τ,m,n) consists of M copies of Gq,sp,sc(τ,m,n)
connected as a ring in which the last copy is directly connected to the ﬁrst copy of
Gq,sp,sc(τ,m,n). The wrapping around operation is called tailbiting.
The binary CPM-dispersion of the ﬁnite array tb
q,sp,sc(M,τ,m,n) gives an
mMτ × nMτ array Htb
b,sp,sc(M,τ,m,n) of CPMs and ZMs of size (q −1) × (q −
1). The null space of Htb
b,sp,sc(M,τ,m,n) gives a block CPM-QC-SC-LDPC code,
called a type-1 tailbiting (TB) CPM-QC-SC-LDPC code, denoted by Ctb
b,sp,sc(τ).
The superscript “tb” in tb
q,sp,sc(M,τ,m,n), Htb
b,sp,sc(M,τ,m,n), and Ctb
b,sp,sc(τ)
stands for “tailbiting.” The rate of this code is at least (n −m)/n.
For a given ﬁeld GF(q), based on the block-cyclic array B′
q,sp,p(m,n) given by
(9.1), we can construct a large family of CPM-QC-SC-LDPC, L-terminated and
tailbiting CPM-QC-SC-LDPC codes with various rates and periods using different
choices of parameters, m, n, τ, and M.
10
12:42:19, subject to the Cambridge Core terms of use,

126
9 SP-Construction of QC-SC-LDPC Codes
By terminating (or tailbiting) the semi-inﬁnite array ⋆
q,sp,sc(τ,m,n), we can
construct a type-2 terminated (or tailbiting) CPM-QC-SC-LDPC code. Suppose
we take the top M τ-span subarrays from ⋆
q,sp,sc(τ,m,n) to form an Mτ ×(Mτ +
e −1) subarray of ⋆
q,sp,sc(τ,m,n), denoted by ⋆,t
q,sp,sc(M,τ,m,n). The binary
CPM-dispersion of ⋆,t
q,sp,sc(M,τ,m,n) gives an mMτ × n(Mτ + e −1) array of
CPMs and ZMs of size (q −1) × (q −1), denoted by H⋆,t
b,sp,sc(M,τ,m,n). The
null space of H⋆,t
b,sp,sc(M,τ,m,n) gives a terminated type-2 CPM-QC-SC-LDPC
code C⋆,t
b,sc,sp(τ) of length n(Mτ + e −1)(q −1) with rate at least (Mτ(n −
m) + (e −1)n)/n(Mτ + e −1). If we wrap the last e −1 column-blocks of
⋆,t
q,sp,sc(M,τ,m,n) around to the left, we obtain an Mτ × Mτ tailbiting array
⋆,tb
q,sp,sc(M,τ,m,n) of m × n matrices over GF(q). The binary CPM-dispersion
of ⋆,tb
q,sp,sc(M,τ,m,n) gives an mMτ ×nMτ array H⋆,tb
b,sp,sc(M,τ,m,n) of CPMs
and ZMs of size (q −1) × (q −1). The null space of H⋆,tb
b,sp,sc(M,τ,m,n) gives a
type-2 tailbiting CPM-QC-SC-LDPC code C⋆,tb
b,sc,sp(τ) of length nMτ(q −1).
Example 9.4. Consider the cyclic base matrix Bq,sp,p over GF(127) constructed
in Example 9.1. We factor 126 as the product of 9 and 14 and set r = 9 and l = 14.
Then, we partition Bq,sp,p into a 9 × 9 array of 14 × 14 matrices over GF(127) in
the form given by (8.2). Next, we choose m = 2 and n = 8 and construct a 9 × 9
cyclic array B′
q,sp,p(2,8) of 2 × 8 matrices in the form of (9.1). The top row of
B′
q,sp,p(2,8) consists of 9 constituent 2 × 8 matrices R0,0, R0,1, ..., R0,8. In the
code construction, we choose e = 2 and τ = 1 and use R0,0 and R0,1 to construct
the base matrix q,sp,sc(1,2,8).
Set M = 4. Taking the ﬁrst four 1-span subarrays from q,sp,sc(1,2,8) and
wrapping the last row-block around to the top as described above, we obtain a
4×4 array tb
q,sp,sc(4,1,2,8) of 2×8 submatrices over GF(127) given in the form
of (9.9). The binary CPM-dispersion of the base matrix tb
q,sp,sc(4,1,2,8) gives
an 8 × 32 array Hbt
b,sp,sc(4,1,2,8) of CPMs and ZMs of size 126 × 126, which is
a 1008 × 4032 binary matrix with column and row weights 4 and 8, respectively.
The null space of this array gives a (4,16)-regular (4032,3029) type-1 tailbiting
CPM-QC-SC-LDPC code Ctb
b,sp,sc,0(1) with rate 0.7512.
The BER and BLER performances of this code decoded with 50 iterations of the
MSA over the AWGNC are shown in Fig. 9.5(a). From this ﬁgure, we can see that
the code performs about 1.6 dB away from the Shannon limit at a BER of 10−8.
At a BLER of 10−6, the code performs 0.95 dB from the SPB.
If we choose m = 2, n = 10, e = 2, τ = 1, and M = 4, we can construct an
8 × 40 array Htb
b,sp,sc(4,1,2,10) of CPMs and ZMs of size 126 × 126, which is a
1008 × 5040 binary matrix with column and row weights 4 and 10, respectively.
The null space of Htb
b,sp,sc(4,1,2,10) gives a (4,20)-regular (5040,4037) type-1
10
12:42:19, subject to the Cambridge Core terms of use,

q,sp,sc(M,τ,m,n) =
R0,0
...
...
... R0,(τ−1)e+1
R0,1
R0,e
R0,e−1
...
...
...
...
R0,e+1
...
R0,2e−1
...
...
...
...
... R0,(τ−1)e
...
...
...
...
... R0,(τ−1)e+1 R0,0
R0,τe−1
R0,e−1
...
...
...
R0,1
R0,e
R0,2e−1
...
...
...
R0,e+1
...
...
...
...
...
... R0,(τ−1)e
R0,τe−1
...
...
... R0,(τ−1)e+1
...
R0,e−1
...
...
...
...
R0,0
R0,2e−1
...
...
...
R0,1
R0,e
...
...
...
...
R0,e+1
...
R0,τe−1
...
...
...
... R0,(τ−1)e
⎛
⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎜⎝
⎞
⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎟⎠
.
(9.9)
10
12:42:19, subject to the Cambridge Core terms of use,

1.6
1.8
2
2.2
2.4
2.6
2.8
3
3.2
3.4
3.6
3.8
4
(a)
BER/BLER
Eb/N0(dB)
 (4032,3029) Cb,sp,sc,0
tb
(1), BER
 (4032,3029) Cb,sp,sc,0
tb
(1), BLER
 (5040, 4037) Cb,sp,sc,1
tb
(1), BER
 (5040, 4037) Cb,sp,sc,1
tb
(1), BLER
 (4032, 3029),  Shannon Limit
 (5040, 4037),  Shannon Limit
 (4032,3029), SPB
 (5040, 4037), SPB
10−8
10−7
10−6
10−5
10−4
10−3
10−2
10−1
100
0.12
0.14
0.16
0.18
0.2
0.22
0.24
0.26
10−11
10−10
10−9
10−8
10−7
10−6
10−5
10−4
10−3
10−2
10−1
(b)
100
UEBR\UEBLR
ε
(4032,3029), UEBR
(4032,3029), UEBLR
(5040,4037), UEBR
(5040,4037), UEBLR
(4032,3029), Shannon Limit
(5040,4037), Shannon Limit
Figure 9.5. (a) The BER and BLER performances of the (4032,3029) and
the (5040,4037) tailbiting type-1 CPM-QC-SC-LDPC codes Ctb
b,sp,sc,0(1) and
Ctb
b,sp,sc,1(1) given in Example 9.4 over the AWGNC; and (b) performances of
the codes in (a) over the BEC.
10
12:42:19, subject to the Cambridge Core terms of use,

9.5 General Construction of Type-1 SC-LDPC Codes
129
tailbiting CPM-QC-SC-LDPC code Ctb
b,sp,sc,1(1) with rate 0.8010. Its BER and
BLER performances over the AWGNC decoded with 50 iterations of the MSA are
also shown in Fig. 9.5(a). From Fig. 9.5(a), we see that, at a BER of 10−8, this
code performs 1.4 dB away from the Shannon limit. At a BLER of 10−6, the code
performs 0.9 dB from the SPB.
The performances of the two codes Ctb
b,sp,sc,0(1) and Ctb
b,sp,sc,1(1) over the BEC
are shown in Fig. 9.5(b). From this ﬁgure, we see that the code Ctb
b,sp,sc,0(1)
performs about 0.09 away from the Shannon limit at a UEBR of 10−7 and the
code Ctb
b,sp,sc,1(1) performs about 0.07 away from the Shannon limit at a UEBR of
10−6.
Note that the two codes Ctb
b,sp,sc,0(1) and Ctb
b,sp,sc,1(1) constructed in this
example are two doubly CPM-QC-SP-LDPC codes , as we can see by examining
the structure of their base arrays.
9.5 A More General Construction of Type-1 CPM-QC-SC-LDPC Codes
In Sections 9.1 and 9.2, we presented a speciﬁc construction of type-1 CPM-QC-
SC-LDPC codes using the r × r cyclic array B′
q,sp,p(m,n) given by (9.1) as the
base matrix. Based on the base matrix B′
q,sp,p(m,n), we ﬁrst constructed an (e +
τ −1) × τ array Bq,sp,sc(τ,m,n) of m × n matrices over GF(q) with τe < r, and
then we formed a semi-inﬁnite base array q,sp,sc(τ,m,n) that consists of inﬁnite
copies of Bq,sp,sc(τ,m,n) lying on a diagonal band with width en and depth em
shown in (9.2). The null space of the binary CPM-dispersion Hb,sp,sc(τ,m,n)
of q,sp,sc(τ,m,n) gives a type-1 periodically time-varying CPM-QC-SC-LDPC
code Cb,sp,sc(τ) with period τ. In the construction of Bq,sp,sc(τ,m,n), we
restricted all the constituent matrices to be distinct. In this section, we generalize
the construction of Bq,sp,sc(τ,m,n) by removing this restriction. Removing this
restriction gives a larger class of type-1 CPM-QC-SC-LDPC codes.
The ﬁrst step of the generalized construction is to cut the r ×r cyclic base matrix
B′
q,sp,p(m,n) along its main diagonal and form two triangular subarrays of m ×n
matrices over GF(q) as follows:
Tlower(r,r,m,n) =
⎡
⎢⎢⎢⎢⎢⎢⎢⎣
R0,0
O
O
···
O
O
R0,1
R0,2
O
···
O
O
R0,2
R0,3
R0,4
···
O
O
...
...
...
...
...
...
R0,r−2
R0,r−1
R0,0
···
R0,r−4
O
R0,r−1
R0,0
R0,1
···
R0,r−3
R0,r−2
⎤
⎥⎥⎥⎥⎥⎥⎥⎦
,
(9.10)
10
12:42:19, subject to the Cambridge Core terms of use,

130
9 SP-Construction of QC-SC-LDPC Codes
and
Tupper(r,r,m,n) =
⎡
⎢⎢⎢⎢⎢⎣
O
R0,1
R0,2
···
R0,r−2
R0,r−1
O
O
R0,3
···
R0,r−1
R0,0
...
...
...
...
...
...
O
O
O
···
O
R0,r−3
O
O
O
···
O
O
⎤
⎥⎥⎥⎥⎥⎦
,
(9.11)
where O is an m × n ZM.
The subarrays Tlower(r,r,m,n) and Tupper(r,r,m,n) are called the lower
and upper triangular subarrays of B′
q,sp,p(m,n). They are disjoint and form a
partition of B′
q,sp,p(m,n). Note that each nonzero constituent matrix in either
Tlower(r,r,m,n) or Tupper(r,r,m,n) is a member matrix in the set R = {R0,0,
R0,1, ..., R0,r−1 } and each member matrix in R appears r times in the
union of Tlower(r,r,m,n) and Tupper(r,r,m,n). Since B′
q,sp,p(m,n) satisﬁes the
2 × 2 SM-constraint and Tlower(r,r,m,n) and Tupper(r,r,m,n) are two disjoint
subarrays of B′
q,sp,p(m,n), Tlower(r,r,m,n) and Tupper(r,r,m,n) satisfy both the
2 × 2 and the PW-2 × 2 SM-constraints.
Now, using Tlower(r,r,m,n) and Tupper(r,r,m,n) as building blocks, we form
a semi-inﬁnite array as follows:
q,sp,sc(r,r,m,n) =
⎡
⎢⎢⎢⎢⎢⎣
Tlower(r,r,m,n)
Tupper(r,r,m,n)
Tlower(r,r,m,n)
Tupper(r,r,m,n)
Tlower(r,r,m,n)
Tupper(r,r,m,n)
Tlower(r,r,m,n)
...
⎤
⎥⎥⎥⎥⎥⎦
.
(9.12)
Consider the following 2r ×r subarray of q,sp,sc(r,r,m,n):
Bq,sp,sc,v(r,r,m,n) =
	 Tlower(r,r,m,n)
Tupper(r,r,m,n)

,
(9.13)
that consists of r column-blocks, each containing all the r member matrices of
the set {R0,0,R0,1,...,R0,r−1} and r ZMs of size m × n. The nonzero constituent
matrices in each column-block of Bq,sp,sc,v(r,r,m,n) are conﬁned to a span of r
consecutive locations (called a nonzero column-span) and are ordered cyclically
within the span. For 1 ≤j < r, the j-th nonzero column-span is obtained from
the 0-th nonzero column-span by cyclically shifting upward j positions and
wrapping the top j nonzero submatrices around to the bottom of the nonzero
10
12:42:19, subject to the Cambridge Core terms of use,

9.5 General Construction of Type-1 SC-LDPC Codes
131
column-span. Since Tlower(r,r,m,n) and Tupper(r,r,m,n) satisfy the PW-2 ×
2 SM-constraint, the r-span subarray Bq,sp,sc,v(r,r,m,n) of q,sp,sc(r,r,m,n)
satisﬁes the 2 × 2 SM-constraint. Bq,sp,sc,v(r,r,m,n) is called a vertical r-span
subarray of q,sp,sc(r,r,m,n). The subscript “v” stands for “vertical.”
Next, we consider the structure of the following r ×2r subarray of q,sp,sc(r,r,
m,n):
Bq,sp,sc,h(r,r,m,n) =

Tupper(r,r,m,n)
Tlower(r,r,m,n)

,
(9.14)
that consists of r row-blocks, each containing all the member matrices of the
set {R0,0,R0,1,...,R0,r−1} and r ZMs of size m × n. The nonzero constituent
matrices of each row-block of Bq,sp,sc,h(r,r,m,n) are conﬁned to a span of r
consecutive locations and ordered cyclically within the nonzero row-span. For
1 ≤i < r, the i-th nonzero row-span is obtained from the 0-th nonzero row-span
by cyclically shifting i positions to the left and wrapping the ﬁrst i nonzero
submatrices around to the right of the nonzero row-span. Each member matrix of
the set {R0,0,R0,1,...,R0,r−1} appears r times in Bq,sp,sc,h(r,r,m,n). The array
Bq,sp,sc,h(r,r,m,n) is called a horizontal r-span subarray of q,sp,sc(r,r,m,n),
where the subscript “h” in Bq,sp,sc,h(r,r,m,n) stands for “horizontal.” Again,
since Tlower(r,r,m,n) and Tupper(r,r,m,n) satisfy the PW-2 × 2 SM-constraint,
the subarray Bq,sp,sc,h(r,r,m,n) satisﬁes the 2 × 2 SM-constraint.
From the structure of q,sp,sc(r,r,m,n) in the form given by (9.12), we see
that q,sp,sc(r,r,m,n) consists of inﬁnite copies of the vertical r-span subarray
Bq,sp,sc,v(r,r,m,n). Two adjacent copies of Bq,sp,sc,v(r,r,m,n) are connected by
a horizontal r-span subarray Bq,sp,sc,h(r,r,m,n). It follows from the structure of
q,sp,sc(r,r,m,n) and the PW-2×2 SM-constrained structure of Tlower(r,r,m,n)
and Tupper(r,r,m,n) that the semi-inﬁnite array q,sp,sc(r,r,m,n) satisﬁes the
2 × 2 SM-constraint.
Dispersing each nonzero entry of q,sp,sc(r,r,m,n) into a binary CPM of size
(q −1) × (q −1) and each 0-entry into a ZM of size (q −1) × (q −1), we
obtain a semi-inﬁnite array Hb,sp,sc(r,r,m,n) of CPMs and ZMs of size (q −1)×
(q −1). The null space of Hb,sp,sc(r,r,m,n) gives a type-1 periodically
time-varying CPM-QC-SC-LDPC code Cb,sp,sc(r) with period r and rate close
to (n −m)/n (assuming m < n) whose Tanner graph has girth at least 6.
Let c be a positive integer such that 0 ≤c < r. Suppose we remove the top
c row-blocks from both Tlower(r,r,m,n) and Tupper(r,r,m,n). We obtain two
(r −c) × r arrays of m × n matrices over GF(q), denoted by Tlower,row(r −
c,r,m,n) and Tupper,row(r −c,r,m,n), respectively. Next, we form the following
semi-inﬁnite array using Tlower,row(r −c,r,m,n) and Tupper,row(r −c,r,m,n) as
10
12:42:19, subject to the Cambridge Core terms of use,

132
9 SP-Construction of QC-SC-LDPC Codes
building blocks:
q,sp,sc,row(r −c,r,m,n) =
⎡
⎢⎢⎢⎣
Tlower,row(r −c,r,m,n)
Tupper,row(r −c,r,m,n)
Tlower,row(r −c,r,m,n)
Tupper,row(r −c,r,m,n)
Tlower,row(r −c,r,m,n)
...
⎤
⎥⎥⎥⎦.
(9.15)
The subscript “row” in Tlower,row(r −c,r,m,n), Tupper,row(r −c,r,m,n), and
q,sp,sc,row(r −c,r,m,n) stands for “row removal.”
In q,sp,sc,row(r −c,r,m,n), each vertical subarray:
Bq,sp,sc,v,row(r −c,r,m,n) =
	 Tlower,row(r −c,r,m,n)
Tupper,row(r −c,r,m,n)

,
(9.16)
is a 2(r −c)×r array of m ×n matrices over GF(q) and each horizontal subarray:
Bq,sp,sc,h,row(r −c,r,m,n) =

Tupper,row(r −c,r,m,n)
Tlower,row(r −c,r,m,n)

,
(9.17)
is an (r −c) × 2r array of m × n matrices over GF(q). For r −c ≥2, two adjacent
copies of Bq,sp,sc,v,row(r −c,r,m,n) in q,sp,sc,row(r −c,r,m,n) are connected
(or coupled) by the row-blocks of Bq,sp,sc,h,row(r −c,r,m,n). As c increases from
0 to r −2, the degree of coupling between two adjacent copies of Bq,sp,sc,v,row(r −
c,r,m,n) decreases. If c = r −1, then two adjacent copies of Bq,sp,sc,v,row(r −
c,r,m,n) in q,sp,sc,row(r −c,r,m,n) are disconnected.
The null space of the binary CPM-dispersion Hb,sp,sc,row(r −c,r,m,n)
of q,sp,sc,row(r −c,r,m,n) also gives a type-1 periodically time-varying
CPM-QC-SC-LDPC code Cb,sp,sc,row(r) with period r whose Tanner graph has
girth at least 6.
In the above construction of type-1 CPM-QC-SC-LDPC codes, we removed
row-blocks from the triangular arrays Tlower(r,r,m,n) and Tupper(r,r,m,n).
Construction of type-1 CPM-QC-SC-LDPC codes can also be achieved by
removing column-blocks from the two triangular arrays.
Let f be a positive integer such that 0 ≤f < r −1. Suppose we remove the
leftmost f column-blocks from both Tlower(r,r,m,n) and Tupper(r,r,m,n). We
obtain two r × (r −f ) arrays of m × n matrices over GF(q), Tlower,col(r,r −
f,m,n) and Tupper,col(r,r −f,m,n). Next, we form the following semi-inﬁnite
array using Tlower,col(r,r −f,m,n) and Tupper,col(r,r −f,m,n) as building
10
12:42:19, subject to the Cambridge Core terms of use,

9.6 General Construction of Type-1 SC-LDPC Codes
133
blocks:
q,sp,sc,col(r,r −f,m,n) =
⎡
⎢⎢⎢⎣
Tlower,col(r,r −f,m,n)
Tupper,col(r,r −f,m,n)
Tlower,col(r,r −f,m,n)
Tupper,col(r,r −f,m,n)
Tlower,col(r,r −f,m,n)
...
⎤
⎥⎥⎥⎦.
(9.18)
The subscript “col” in Tlower,col(r,r −f,m,n), Tupper,col(r,r −f,m,n), and
q,sp,sc,col(r,r −f,m,n) stands for “column removal.”
In this case, the null space of the binary CPM-dispersion Hb,sp,sc,col(r,r −
f,m,n) of q,sp,sc,col(r,r −f,m,n) gives a type-1 periodically time-varying
CPM-QC-SC-LDPC code Cb,sp,sc,col(r −f ) with period r −f whose Tanner
graph has girth at least 6. Note that the top f rows of q,sp,sc,col(r,r −f,m,n)
are rows of zeros which must be removed in code construction.
For 0 ≤c, f < r −1, suppose we remove the top c row-blocks and the leftmost
f column-blocks from Tlower(r,r,m,n) and Tupper(r,r,m,n) given by (9.10) and
(9.11), respectively. We obtain two (r −c) × (r −f ) arrays, Tlower,row,col (r −
c,r −f,m,n) and Tupper,row,col(r −c,r −f,m,n) of m ×n matrices over GF(q).
Using these two arrays as building blocks, we can construct the following 2 × 2
SM-constrained semi-inﬁnite array:
q,sp,sc,row,col(r −c,r −f,m,n) =
⎡
⎢⎢⎢⎣
Tlower,row,col(r −c,r −f,m,n)
Tupper,row,col(r −c,r −f,m,n)
Tlower,row,col(r −c,r −f,m,n)
Tupper,row,col(r −c,r −f,m,n)
Tlower,row,col(r −c,r −f,m,n)
...
⎤
⎥⎥⎥⎦.
(9.19)
The null space of the CPM-dispersion Hb,sp,sc,row,col(r −c,r −f,m,n) of
q,sp,sc,row,col(r −c,r −f,m,n) gives another type-1 periodically time-varying
CPM-QC-SC-LDPC code Cb,sp,sc,row,col(r −f ) with period r −f whose Tanner
graph has girth at least 6. Note that the top f rows of q,sp,sc,row,col(r −c,r −
f,m,n) are rows of zeros which must be removed in code construction.
For various choices of parameters, r, l, m, n, c, and f , we can construct type-1
CPM-QC-SC-LDPC codes with various rates and periods.
Clearly, tailbiting CPM-QC-SC-LDPC codes can be constructed from any of the
above four generalized type-1 CPM-QC-SC-LDPC codes.
10
12:42:19, subject to the Cambridge Core terms of use,

134
9 SP-Construction of QC-SC-LDPC Codes
9.6 A More General Construction of Type-2 CPM-QC-SC-LDPC Codes
Let e and τ be two positive integers such that eτ = r. Suppose we divide the
top (or the 0-th) row-block R0 = [R0,0 R0,1 ... R0,r−1] of the r × r array
B′
q,sp,p(m,n) given by (9.1) into τ sections, each consisting of e consecutive
constituent matrices of the ﬁrst row-block R0 of B′
q,sp,p(m,n). For 0 ≤i < τ,
let Bi = [R0,ie R0,ie+1 ... R0,(i+1)e−1] denote the i-th section of R0. Then,
R0 = [B0 B1 ... Bτ−1]. Next, we form a τ × τ array by cyclically shifting R0
to the left τ −1 times, one section at a time, as follows:
Bq(τ,τ) =
⎡
⎢⎢⎢⎣
B0
B1
B2
···
Bτ−2
Bτ−1
B1
B2
B3
···
Bτ−1
B0
...
...
...
...
...
...
Bτ−1
B0
B1
···
Bτ−3
Bτ−2
⎤
⎥⎥⎥⎦.
(9.20)
Note that the τ row-blocks of Bq(τ,τ) are simply the 0-th, e-th, ..., (τ −1)e-th
row-blocks of B′
q,sp,p(m,n). Next, we cut Bq(τ,τ) along the main diagonal
into two triangular arrays, denoted by Tq,upper(τ,τ) and Tq,lower(τ,τ), where
Tq,upper(τ,τ) contains all the nonzero sections on or above the main diagonal
of Bq(τ,τ) and Tq,lower(τ,τ) contains only nonzero sections below the main
diagonal. Then, we use Tq,upper(τ,τ) and Tq,lower(τ,τ) to form a τ × 2τ array
as follows:
Bq,sc(τ,τ) =

Tq,upper(τ,τ) Tq,lower(τ,τ)

=
(9.21)
where O is an mτ × ne ZM.
Using an argument similar to that given in the last section, the array Bq,sc(τ,τ)
as an mτ × 2neτ matrix over GF(q), satisﬁes the 2 × 2 SM-constraint. Now, we
take an inﬁnite number of copies of Bq,sc(τ,τ) to form the following semi-inﬁnite
10
12:42:19, subject to the Cambridge Core terms of use,

9.7 Discussion and Remarks
135
array of m × ne matrices over GF(q):
ϒq,sp,sc(τ,τ,m,n) =
⎡
⎢⎣
Tq,upper(τ,τ)
Tq,lower(τ,τ)
Tq,upper(τ,τ)
Tq,lower(τ,τ)
...
...
⎤
⎥⎦.
(9.22)
The array ϒq,sp,sc(τ,τ,m,n), as a semi-inﬁnite matrix, satisﬁes the 2 × 2
SM-constraint. Bq,sc(τ,τ) is called the 2τ-span subarray of ϒq,sp,sc(τ,τ,m,n).
Let Hb,sp,sc(τ,τ,m,n) be the CPM-dispersion of ϒq,sp,sc(τ,τ,m,n). The null
space of Hb,sp,sc(τ,τ,m,n) gives a type-2 periodically time-varying CPM-QC-SC-
LDPC code with period τ.
Similar to the constructions of various generalized type-1 CPM-QC-SC-LDPC
codes, we can construct various generalized type-2 CPM-QC-SC-LDPC codes by
removing corresponding columns and/or rows from Tq,upper(τ,τ) and Tq,lower
(τ,τ). If we terminate ϒq,sp,sc(τ,τ,m,n) by taking M row-blocks and wrap the
tail Tq,lower(τ,τ) of the last τ row-span array around to the left-end, we obtain a
tailbiting CPM-QC-SC-LDPC code.
9.7 Discussion and Remarks
In this chapter, several algebraic methods for constructing CPM-QC-SC-LDPC
codes were presented. All the constructions presented were based on a special
type of 2 × 2 SM-constrained base matrix with a cyclic structure in the form
given by (7.3) (or (8.1)) which is a special case of the construction presented
in Section 7.3, using the cyclic group GF(q)\{0} of a ﬁnite ﬁeld GF(q). Every
row (or column) of B′
q,sp,p(m,n) is a minimum weight codeword of the cyclic
(q −1,2) RS code over GF(q) with minimum distance q −2 [97, 64]. Besides
this type of cyclic base matrix, there are two other types of 2 × 2 SM-constrained
cyclic base matrices which can also be used to construct CPM-QC-SC-LDPC
codes. One type is constructed based on two cyclic subgroups of the cyclic
group of GF(q) [100, 114], which is also a special case of the construction
presented in Section 7.3. The other construction is based on the 2-dimensional
Euclidean geometry EG(2,q) over GF(q) [46, 27] (see Appendix A). Based
on these two types of cyclic base matrices, CPM-QC-SC-LDPC codes can be
constructed.
Note that CPM-QC-SC-LDPC codes can also be constructed based on any 2×2
SM-constrained base matrix even though it does not have a cyclic structure. One
such a base matrix is a Latin square over a ﬁnite ﬁeld as presented in Section 7.3.
10
12:42:19, subject to the Cambridge Core terms of use,

136
9 SP-Construction of QC-SC-LDPC Codes
The construction of CPM-QC-SC-LDPC codes using a non-cyclic base matrix may
be a little more complicated than using a cyclic base matrix. This may deserve
further study. A good coverage of various constructions of 2 × 2 SM-constrained
base matrices can be found in [97, 46].
Another interesting question is how the degree of coupling between two adjacent
τ-span subarrays (or two adjacent periods) in the semi-inﬁnite parity-check array
of an SC-LDPC code affects the error performance of the code. It deﬁnitely affects
the rate of decoding convergence. A higher degree of coupling makes the decoding
converge faster.
Section 9.4 showed that a tailbiting code can be constructed by terminating the
semi-inﬁnite parity-check matrix of an SC-LDPC code and then wrapping the tail
of the last column-span array (or last row-span array) around to the top (or to
the left). Conversely, an SC-LDPC code can be constructed by unwrapping the
parity-check matrix of a tailbiting code and continuing the downward (rightward)
shift of the nonzero column-span (row-span) array (or the ﬁrst period) to form
a semi-inﬁnite spatially coupled chain. Two classes of good and structured
CPM-QC-LDPC codes that can be used for tailbiting were constructed in [65] and
[101] based on ﬁnite Euclidean geometries and BIBDs, respectively. Construction
of QC-SC-LDPC codes from these two classes of tailbiting codes needs further
investigation.
Structured tailbiting codes, such as tailbiting Reed–Muller (RM) codes, have
good trellis structure and can be decoded with the MAP decoding algorithm [75].
A good question, then, is whether the tailbiting SC-LDPC codes presented in this
chapter are suitable for MAP decoding. This may be an interesting problem to
investigate.
SC-LDPC codes have several advantages and some disadvantages compared
to LDPC block codes. For asymptotically large termination lengths and base
matrix expansion factors (resulting in very long codes), their iterative decoding
performance is known to achieve the performance of the optimum MAP decoding.
This is not possible with LDPC block codes. Also, in the asymptotic case, if the
underlying structure is regular, the minimum distance of SC-LDPC codes grows
linearly with block length, which suggests that they are not subject to severe
error-ﬂoors. So, for very large block lengths, SC-LDPC codes normally have
advantages.
In the practical ﬁnite-length case emphasized in this chapter, there are trade-offs.
On an equal latency basis, SC-LDPC codes have been shown to achieve several
tenths of a dB coding gain in the waterfall region of the BER curve compared
to LDPC block codes with the same underlying structure. However, block codes
typically have a sharper BER curve slope, which means that they will outperform
10
12:42:19, subject to the Cambridge Core terms of use,

9.7 Discussion and Remarks
137
SC-LDPC codes in the error-ﬂoor. There are also differences in the implementation
of iterative decoding in the two cases, and a code designer must carefully consider
these differences in light of the particular application being considered. Another
major disadvantage of SC-LDPC codes is that iterative BP-decoding of these codes
takes a large number of iterations to converge.
10
12:42:19, subject to the Cambridge Core terms of use,

10
Globally Coupled QC-LDPC Codes
In this chapter, we present another type of LDPC code with structure related to,
but different from that of the SC-LDPC codes presented in Chapter 9. For an
LDPC code of this type, its Tanner graph is composed of a set of disjoint Tanner
graphs which are connected together by a group of overall CNs, called global
CNs. The other CNs are called local CNs. A code of this type is called a CN-based
GC-LDPC code.
Two types of CN-based GC-LDPC codes and their constructions will be
presented in this chapter. The ﬁrst type of CN-based GC-LDPC codes is
constructed based on the block-cyclic base array Bq,sp,p(m,n) given by (8.3).
Examples show that codes of this type perform very well over both the AWGNC
and the BEC. The second type of codes are direct products of two LDPC codes,
and they not only perform well over both the AWGNC and the BEC, but they
are also very effective in correcting bursts of erasures, i.e., erasures clustered in
bursts as discussed in Section 7.6. A method for constructing CN-based product
GC-LDPC codes with QC-structure is given. Both types of CN-based GC-LDPC
codes are special cases of SP-LDPC codes.
Also presented in this chapter is a reduced-complexity local/global two-phase
iterative decoding scheme for CN-based GC-LDPC codes. This decoding scheme
allows correction of both local and global random errors and/or erasures.
10.1 Construction of CN-Based QC-GC-LDPC Codes: Method-1
In forming the r × r cyclic array Bq,sp,p(m,n) in the form of (8.3) from the
RS-based r × r array WRS of l × l submatrices over GF(q) given by (8.2), there
are l −m rows in each row-block and l −n columns in each column-block of WRS
which are unused. So, a total of r(l −m) rows of WRS are not used in forming the
array Bq,sp,p(m,n). We denote the set of r(l −m) unused rows of WRS by . For
138
11
12:43:20, subject to the Cambridge Core terms of use,

10.1 Construction of CN-Based QC-GC-LDPC Codes
139
each row w in , we remove the components at the locations that correspond to
the columns that are not used in forming the array Bq,sp,p(m,n) from WRS. This
results in a shortened row w∗= (w0,0,w0,1,...,w0,r−1) that consists of r sections,
each consisting of n components. The locations of the n components of the i-th
section w0,i of w∗correspond to the locations of the n columns of the submatrix
R0,i of the submatrix W0,i in the array WRS. Let ∗denote the set of r(l −m)
shortened versions of the rows in . The set ∗of rows and the set of rows in the
ﬁrst row-block of Bq,sp,p(m,n) are disjoint.
Let s and t be two positive integers with 1 ≤s ≤r(l −m) and 1 ≤t ≤r. Take s
rows from ∗and remove the last r −t sections from each of the s chosen rows.
With these s shortened rows, we form an s × nt matrix Xgc,cn(s,t) over GF(q).
Next, we form the following array over GF(q):
Bgc,cn =
⎡
⎢⎢⎢⎢⎢⎢⎢⎣
R0,0
R0,0
R0,0
...
R0,0
Xgc,cn(s,t)
⎤
⎥⎥⎥⎥⎥⎥⎥⎦
.
(10.1)
The upper subarray of Bgc,cn is a t × t diagonal array with t copies of R0,0 on
its main diagonal and the lower part is the s × nt matrix Xgc,cn(s,t). The matrix
Bgc,cn is an (mt + s) × nt matrix over GF(q) which is a submatrix of the matrix
WRS after replacing some entries in WRS by zeros. Since WRS satisﬁes the 2 × 2
SM-constraint, Bgc,cn must also satisfy the 2 × 2 SM-constraint. The subscripts
“gc” and “cn” in Xgc,cn(s,t) and Bgc,cn stand for “global coupling” and “check
node,” respectively.
Let G0,0 and Ggc,cn be the Tanner graphs associated with R0,0 and Bgc,cn,
respectively. It follows from the structure of the matrix Bgc,cn that the Tanner graph
Ggc,cn associated with Bgc,cn is composed of t disjoint copies of the Tanner graph
G0,0 associated with the matrix R0,0 connected by s global CNs that correspond
to the s rows of the matrix Xgc,cn(s,t), as shown in Fig. 10.1. (In this ﬁgure, the
edge labels are ignored.) The s global CNs provide the only connections between
any two disjoint copies of G0,0, i.e., two disjoint copies of G0,0 are only connected
to each other through a set of global CNs.
Let CPM(R0,0) and CPM(Xgc,cn(s,t)) denote the binary CPM-dispersions of
R0,0 and Xgc,cn(s,t), respectively. Then, the CPM-dispersion of Bgc,cn gives the
following (mt + s) × nt array Hgc,cn,sp,qc(q −1,q −1) of binary CPMs and ZMs
11
12:43:20, subject to the Cambridge Core terms of use,

140
10 Globally Coupled QC-LDPC Codes
Figure 10.1. The Tanner graph Ggc,cn of the base matrix Bgc,cn.
of size (q −1) × (q −1):
Hgc,cn,sp,qc(q −1,q −1) =
⎡
⎢⎢⎢⎢⎢⎢⎢⎣
CPM(R0,0)
CPM(R0,0)
CPM(R0,0)
...
CPM(R0,0)
CPM(Xgc,cn(s,t))
⎤
⎥⎥⎥⎥⎥⎥⎥⎦
.
(10.2)
The array Hgc,cn,sp,qc(q −1,q −1) is a binary (mt + s)(q −1) × nt
(q −1) matrix. Since the base matrix Bgc,cn satisﬁes the 2 × 2 SM-constraint,
Hgc,cn,sp,qc(q −1,q −1) must satisfy the RC-constraint. The null space of
Hgc,cn,sp,qc(q −1,q −1) gives a CN-based CPM-QC-GC-LDPC code of length
nt(q −1), denoted by Cgc,cn,sp,qc. The Tanner graph Ggc,cn,sp,qc(q −1,q −1) of
the code Cgc,cn,sp,qc has girth at least 6 and consists of s(q −1) global CNs.
The s(q −1) × nt(q −1) matrix CPM(Xgc,cn(s,t)) is an s × nt array of
CPMs and/or ZMs of size (q −1) × (q −1). Divide this array into t subarrays,
CPM(Xgc,cn,0), CPM(Xgc,cn,1), ..., CPM(Xgc,cn,t−1), each an s × n array of
CPMs and/or ZMs of size (q −1) × (q −1) and consisting of n consecutive
11
12:43:20, subject to the Cambridge Core terms of use,

10.1 Construction of CN-Based QC-GC-LDPC Codes
141
column-blocks of the matrix CPM(Xgc,cn(s,t)). From the SP point of view,
the code Cgc,cn,sp,qc is constructed with R = { CPM(R0,0), CPM(Xgc,cn,0),
CPM(Xgc,cn,1), ..., CPM(Xgc,cn,t−1) } as the replacement set and the following
(t + 1) × t matrix as the SP-base matrix:
Bsp =
⎡
⎢⎢⎢⎢⎢⎢⎢⎣
1
1
1
...
1
1
1
1
···
1
⎤
⎥⎥⎥⎥⎥⎥⎥⎦
.
(10.3)
Hence, the CN-based CPM-QC-GC-LDPC code Cgc,cn,sp,qc is a CPM-QC-SP-
LDPC code. Note that the member matrices of R have two different sizes, but they
all have the same number of columns, n(q −1).
From the PTG point of view, we may regard the Tanner graph G0,0 associated
with the m × n matrix R0,0 as the protograph for constructing the Tanner graph
Ggc,cn,sp,qc(q −1,q −1) of Cgc,cn,sp,qc. In the construction of Ggc,cn,sp,qc(q −
1,q −1), we ﬁrst take q −1 copies of G0,0 and then connect them into a bipartite
graph G0,0(q −1,q −1) using the conventional PTG-methods as presented in
Section 3.1. Next, we take t copies of G0,0(q −1,q −1) and connect them
by s(q −1) global CNs. The connection is based on the connection matrix
CPM(Xgc,cn(s,t)). We see that the construction of Ggc,cn,sp,qc(q −1,q −1) from
the protograph G0,0 takes two steps of expansion. Hence, Cgc,cn,sp,qc can be
viewed as a generalized PTG-LDPC code. However, we may also regard the
Tanner graph Ggc,cn associated with the base matrix Bgc,cn given by (10.1) as
the protograph. In this case, the Tanner graph Ggc,cn,sp,qc(q −1,q −1) of the
CN-based CPM-QC-GC-LDPC code Cgc,cn,sp,qc is obtained by taking q −1
copies of Ggc,cn and connecting them by permuting the edges among the copies.
In forming the array Bgc,cn, we can use t different member matrices in the set
{R0,0,R0,1,...,R0,r−1} as the matrices on the main diagonal of the upper t × t
subarray of Bgc,cn as follows:
B∗
gc,cn =
⎡
⎢⎢⎢⎢⎢⎢⎢⎣
R0,0
R0,1
R0,2
...
R0,t−1
Xgc,cn(s,t)
⎤
⎥⎥⎥⎥⎥⎥⎥⎦
.
(10.4)
11
12:43:20, subject to the Cambridge Core terms of use,

142
10 Globally Coupled QC-LDPC Codes
Then, the null space of the binary CPM-dispersion H∗
gc,cn,sp,qc(q −1,q −1) of
B∗
gc,cn gives a time-varying CN-based CPM-QC-GC-LDPC code.
Since a CN-based CPM-QC-GC-LDPC code is a special type of LDPC block
code, all the conventional BP-algorithms for decoding an LDPC block code can be
applied for decoding a CN-based CPM-QC-GC-LDPC code. For different choices
of the parameters r, l, m, n, s, and t, we can construct a large family of CN-based
CPM-QC-GC-LDPC codes from a given ﬁeld GF(q), with various lengths and
rates.
In the next two examples, we construct three high-rate codes based on the same
ﬁnite ﬁeld, but using three different sets of the parameters m,n,s and t. We label
these three codes with indices 0, 1 and 2, respectively.
Example 10.1. In this and the next examples, we use the prime ﬁeld GF(127) for
the code construction. Based on this ﬁeld, we can construct a 126 × 126 cyclic
matrix WRS over GF(127) in the form given by (8.2) which satisﬁes the 2 × 2
SM-constraint.
For the construction of the ﬁrst code, we factor 126 as the product of 6
and 21 and set r = 6 and l = 21. Then, the matrix WRS can be viewed as
a 6 × 6 array of 21 × 21 submatrices, whose ﬁrst row-block consists of six
submatrices W0,0,W0,1,...,W0,5 of size 21 × 21. Taking six 3 × 21 submatrices,
R0,0,R0,1,...,R0,5, from these submatrices W0,0,W0,1,...,W0,5 (i.e., choose
m = 3,n = 21) under the location constraint as presented in Section 8.1, we obtain
a 6×6 array Bq,sp,p,0(3,21) of 3×21 submatrices over GF(127) in the form given
by (8.3). (Note that the submatrices R0,0,R0,1,...,R0,5 are taken arbitrarily from
W0,0,W0,1,...,W0,5 under the location constraint.) The submatrix R0,0 is a 3×21
matrix over GF(127). The set ∗consists of r(l −m) = 6 × (21 −3) = 108 rows
of length 126 of the matrix WRS. The rows in ∗are disjoint from the rows in
[R0,0 R0,1 ... R0,5] of Bq,sp,p,0(3,21).
Next, we choose t = 6 and s = 1. Then, the base matrix Bgc,cn,0 given in the
form of (10.1) for the code construction consists of 6 copies of R0,0 lying on its
main diagonal and one randomly chosen row (or 1×6 array of 1×21 submatrices)
from the set ∗. Bgc,cn,0 is a 19 × 126 matrix over GF(127) and satisﬁes the
2 × 2 SM-constraint. The binary CPM-dispersion of Bgc,cn,0 gives a 19 × 126
array Hgc,cn,sp,qc,0(126,126) of CPMs and ZMs of size 126 × 126. The array
Hgc,cn,sp,qc,0(126,126) is a 2394 × 15876 binary matrix. With the construction
of R0,0,R0,1,...,R0,5 from W0,0,W0,1,...,W0,5 and the randomly chosen row
from ∗, we ﬁnd that Hgc,cn,sp,qc,0(126,126) has two column weights 3 and
4, two row weights 21 and 125, and average column and row weights 3.99 and
26.47, respectively. The null space of Hgc,sp,qc,0(126,126) gives a (15876,13494)
CN-based CPM-QC-GC-LDPC code Cgc,cn,sp,qc,0 with rate 0.85. The Tanner
11
12:43:20, subject to the Cambridge Core terms of use,

10.1 Construction of CN-Based QC-GC-LDPC Codes
143
graph Ggc,cn,sp,qc,0(126,126) of the code Cgc,cn,sp,qc,0 has girth 6 and contains
204876 cycles of length 6 and 21677544 cycles of length 8. From the above,
we see that the parameters chosen to construct the code Cgc,cn,sp,qc,0 are: r = 6,
l = 21, m = 3, n = 21, s = 1, and t = 6.
The BER and BLER performances of the code Cgc,cn,sp,qc,0 over the AWGNC
decoded with 50 iterations of the MSA are shown in Fig. 10.2(a). From this ﬁgure,
we see that at a BER of 10−8 and a BLER of 10−6, the code performs within 1.5
dB and 1.0 dB of the Shannon limit and the SPB, respectively.
The unresolved erasure probability performance of this code over the BEC is
shown in Fig. 10.2(b). We see that the code also performs well over the BEC.
Example 10.2. In this example, we use the same ﬁeld GF(127) as the one used in
Example 10.1 for constructing two other high-rate CN-based CPM-QC-GC-LDPC
codes. The two sets of parameters used in the code construction are: (1) r = 3,
l = 42, m = 2, n = 42, s = 2, and t = 3; and (2) r = 3, l = 42, m = 1, n = 42, s = 3,
and t = 3. Based on these two sets of parameters and the construction described in
Example 10.1, we construct two CN-based CPM-QC-GC-LDPC codes, denoted
by Cgc,cn,sp,qc,1 and Cgc,cn,sp,qc,2.
The code Cgc,cn,sp,qc,1 is a (15876,14871) code with rate 0.9367. Its
parity-check matrix Hgc,cn,sp,qc,1(126,126) has average column and row weights
3.98 and 62.75, respectively. The Tanner graph of Cqc,cn,sp,qc,1 has girth 6 and
contains 1675296 cycles of length 6 and 384179481 cycles of length 8. The
code Cgc,cn,sp,qc,2 is a (15876,15120) code with rate 0.9524. The average column
and row weights of its parity-check matrix are 3.9762 and 83.5, respectively. The
Tanner graph of Cgc,cn,sp,qc,2 has girth 6 and contains 3783780 cycles of length 6
and 1037792362 cycles of length 8.
The BER and BLER performances of these two codes Cgc,cn,sp,qc,1 and
Cgc,cn,sp,qc,2 over the AWGNC decoded with 5, 10, and 50 iterations of the
MSA are included in Fig. 10.3(a) and Fig. 10.3(b), respectively. From these two
ﬁgures, we see that both codes perform well. For example, with 50 iterations, the
(15876,14871) CPM-QC-GC-LDPC code Cgc,cn,sp,qc,1 with rate 0.9367 has no
visible error-ﬂoor all the way down to a BER of 10−10, where it performs within
1.15 dB of the Shannon limit. Also at a BLER of 10−7, it performs only about 0.75
dB away from the SPB. Even though the Tanner graph of Cgc,cn,sp,qc,1 has a very
large number of cycles of lengths 6 and 8, its MSA decoding converges very fast,
as shown in Fig. 10.3(a). At a BER of 10−10, the performance gap between 5 and
10 iterations is about 0.4 dB and the gap between 10 and 50 iterations is within
0.2 dB. This fast rate of decoding convergence is due to the large connectivity
of each VN. On average, each VN is connected to 246 other VNs with paths of
length 2.
11
12:43:20, subject to the Cambridge Core terms of use,

144
10 Globally Coupled QC-LDPC Codes
2.4
2.6
2.8
3
3.2
3.4
3.6
3.8
4
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
Cgc,cn,sp,qc,0, BLER
Cgc,cn,sp,qc,0, BER
Cgc,cn,sp,qc,0, SPB
Shannon Limit
0.09
0.1
0.11
0.12
0.13
0.14
0.15
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
Cgc,cn,sp,qc,0, UEBLR
Cgc,cn,sp,qc,0, UEBR
Shannon Limit
Figure 10.2. (a) The BER and BLER performances of the (15 876, 13 494)
CN-based CPM-QC-GC-LDPC codes Cgc,cn,sp,qc,0 given in Example 10.1 over
the AWGNC; and (b) performance of the code in (a) over the BEC.
11
12:43:20, subject to the Cambridge Core terms of use,

10.1 Construction of CN-Based QC-GC-LDPC Codes
145
3.8
4
4.2
4.4
4.6
4.8
5
5.2
5.4
5.6
5.8
10
−11
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
Cgc,sp,qc,1, itr50, BLER
Cgc,sp,qc,1, itr50, BER
Cgc,sp,qc,1, itr10, BLER
Cgc,sp,qc,1, itr10, BER
Cgc,sp,qc,1, itr5, BLER
Cgc,sp,qc,1, itr5, BER
 SPB
Shannon Limit
Figure
10.3. (a)
The
performances
of
the
(15 876,
14 871)
CN-based
CPM-QC-GC-LDPC code Cgc,cn,sp,qc,1 decoded with 5, 10, and 50 iterations of
the MSA given in Example 10.2 over the AWGNC; and (b) the performances of
the (15876,15120) CN-based CPM-QC-GC-LDPC code Cgc,cn,sp,qc,2 decoded
with 5, 10, and 50 iterations of the MSA given in Example 10.2 over the
AWGNC.
Code Cgc,cn,sp,qc,2 performs within 1.2 dB of the Shannon limit at a BER of
10−10 and 0.8 dB from the SPB at a BLER of 10−7, as shown in Fig. 10.3(b). The
Tanner graph of this code also contains a large number of cycles of lengths 6 and 8.
Every VN also has a large connectivity, and on average, each VN is connected to
328 other VNs with paths of length 2. This large VN connectivity again results in
a fast rate of decoding convergence as shown in Fig. 10.3(b). This code has almost
the same rate as the (16560,15737) doubly CPM-QC-SP-LDPC code given in
Example 8.2. From Fig. 8.2(a) and Fig. 10.3(b), we see that the two codes perform
almost the same.
11
12:43:20, subject to the Cambridge Core terms of use,

146
10 Globally Coupled QC-LDPC Codes
4.2
4.4
4.6
4.8
5
5.2
5.4
5.6
5.8
6
6.2
6.4
10
−11
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
BLER/BER
Eb/N0
Cgc,sp,qc,2, itr50, BLER
Cgc,sp,qc,2, itr50, BER
Cgc,sp,qc,2, itr10, BLER
Cgc,sp,qc,2, itr10, BER
Cgc,sp,qc,2, itr5, BLER
Cgc,sp,qc,2, itr5, BER
SPB
Shannon Limit
Figure 10.3. Continued
The unresolved erasure probability performances of the above two codes
Cgc,cn,sp,qc,1 and Cgc,cn,sp,qc,2 over the BEC are shown in Fig. 10.4. We see that
they both perform well.
The rates of the above two codes meet the high-rate requirement for high-speed
optical communications and high-density ﬂash memory.
10.2 A Local/Global Two-Phase Decoding of CN-Based
CPM-QC-GC-LDPC Codes
Note that the CPM-dispersion CPM(R0,0) of the m × n R0,0 is an RC-constrained
m × n array of CPMs and/or ZMs of size (q −1) × (q −1). Its null space gives a
QC-LDPC code C0,0 of length n(q −1). From the structure of the parity-check
matrix array Hgc,cn,sp,qc(q −1,q −1) of the CN-based CPM-QC-GC-LDPC
code Cgc,cn,sp,qc displayed in (10.2), we readily see that each codeword
11
12:43:20, subject to the Cambridge Core terms of use,

10.2 A Local/Global Two-Phase Decoding Scheme
147
0.01
0.02
0.03
0.04
0.05
0.06
0.07
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
UEBLR/UEBR
ε
Cgc,cn,sp,qc,1, UEBLR
Cgc,cn,sp,qc,1, UEBR
Cgc,cn,sp,qc,2, UEBLR
Cgc,cn,sp,qc,2, UEBR
Shannon Limit
Shannon Limit
Figure 10.4. The performances of the (15876,14871) and (15876,15120)
CN-based CPM-QC-GC-LDPC codes Cgc,cn,sp,qc,1 and Cgc,cn,sp,qc,2 given in
Example 10.2 over the BEC.
v = (v0,v1,...,vt−1) of Cgc,cn,sp,qc consists of t sections, each containing
n(q −1) code symbols. Each section vi of v is a codeword of the code C0,0
and the cascaded t sections of v in the order v0,v1,...,vt−1 must satisfy the
s(q −1) parity-check constraints speciﬁed by the rows of the lower subarray
CPM(Xgc,cn(s,t)) of Hgc,cn,sp,qc(q −1,q −1). Hence, we may regard the
CN-based CPM-QC-GC-LDPC code Cgc,cn,sp,qc as a global code which is
composed of t local codes connected by s(q −1) global parity-check constraints.
From the local/global point of view, a local/global two-phase iterative decoding
scheme can be devised to correct local and global random errors. Suppose
a codeword v = (v0,v1,...,vt−1) is transmitted. Let r = (r0,r1,...,rt−1) be
the received word. The decoding starts with a local phase of decoding, where
each received section ri is decoded using a local iterative decoder based on
11
12:43:20, subject to the Cambridge Core terms of use,

148
10 Globally Coupled QC-LDPC Codes
the local code C0,0 with a ﬁxed number of iterations. If all the sections are
successfully decoded, the t decoded sections form a locally decoded codeword
v⋆= (v⋆
0,v⋆
1,...,v⋆
t−1). Then, we check whether this locally decoded codeword
satisﬁes the s(q −1) parity-check constraints imposed by the s(q −1) global
CNs. If it does, the locally decoded codeword is a codeword in the CN-based
CPM-QC-GC-LDPC code Cgc,cn,sp,qc and it is delivered to the user. If the locally
decoded codeword v⋆does not satisfy the s(q −1) global CN-constraints, a global
decoder based on the entire code Cgc,cn,sp,qc is activated to decode the received
vector r, with the symbol reliability measures provided by the local decoders and
the channel information as inputs.
The local phase of decoding is a local error correction process that allows
correction of random errors scattered among t sections of a received word, each
containing a small number of random errors (or erasures). If the local decoders fail
to decode the received sequence r into a codeword in Cgc,cn,sp,qc, the error pattern
contained in r is regarded as a global error pattern which the global decoder
attempts to correct.
There are two possible approaches to switch the decoding from the local phase
to the global phase. The ﬁrst approach is to complete the local decoding of all the
received sections, and then pass the decoded information (LLRs) of all the decoded
sections (successfully and unsuccessfully decoded) and the channel information
to the global decoder to process the received word r. The other approach is to
switch to the global phase decoding as soon as a local decoder fails to decode a
received section. In this case, the global decoder processes the received vector r
either with only the channel information as inputs or with the combined channel
information and the reliability information of successfully decoded sections as
inputs (the reliability information of unsuccessfully decoded sections may also
be included).
Basically, the global phase of decoding is needed only when the distribution
of errors does not allow successful error correction of all the sections of the
received sequence r. Intuitively, the average number of computations should be
lower than when using only a global decoder. In the decoder implementation, one
could use a single local decoder based on the local code C0,0 to process all the
received sections sequentially one at a time, or use a group of (t or less) identical
local decoders to process a group of (t or less) consecutive received sections in
parallel. Pipeline processing is possible for high-speed decoding. Clearly, using
only one local decoder results in the lowest decoder complexity, but requires the
longest decoding time. Fully parallel local phase decoding using t local decoders
results in the shortest decoding time, but requires the highest decoder complexity.
Partially parallel local phase decoding using a group of local decoders (less than t)
11
12:43:20, subject to the Cambridge Core terms of use,

10.3 Construction of CN-Based GC-LDPC Codes
149
allows a ﬂexible trade-off between decoding complexity and decoding time. The
design of such a local/global decoder would be an interesting problem for further
investigation.
10.3 Construction of CN-Based GC-LDPC Codes: Method-2
Let H0 and H1 be m0 × n0 and m1 × n1 RC-constrained sparse matrices over
GF(2), respectively. The null spaces of H0 and H1 give two LDPC codes, denoted
by C0 and C1, of lengths n0 and n1, respectively. Let h1,0,h1,1,...,h1,n1−1 be the
n1 columns of H1. Then, H1 can be expressed in terms of its columns as follows:
H1 = [h1,0 h1,1 ... h1,n1−1].
(10.5)
For 0 ≤j < n1, we form an m1n0 × n0 matrix H1, j based on the j-th column
h1, j of H1 as follows:
H1, j =
⎡
⎢⎢⎢⎣
h1, j
0
···
0
0
h1, j
···
0
...
...
...
...
0
0
···
h1, j
⎤
⎥⎥⎥⎦,
(10.6)
where 0 is a column of m1 zeros. It is clear that H1, j satisﬁes the RC-constraint and
the matrices H1,0, H1,1, ..., H1,n1−1 formed by the n1 columns of H1 satisfy the
PW-RC-constraint. If we permute the rows of H1, j using the row permutation πrow
deﬁned by (4.3) with m1 replacing m, we obtain an m0 × 1 array (or a column) of
identity matrices and ZMs of size n0 × n0, denoted by H1, j,π, where the subscript
“π” in H1, j,π stands for “row permutation.”
In the SP-construction of LDPC codes, we can use the matrices H1,0,π, H1,1,π,
..., H1,n1−1,π together with H0 as constituent matrices of a replacement set R. In
this case, the member matrices in R have two different sizes. The size of H0 is
m0 × n0 and the size of H1, j,π for 0 ≤j < n1 is m1n0 × n0. All the matrices in
R have the same number of columns, i.e., n0, and the number of rows of H1, j,π is
n0 times that of H1. If the base matrix Bsp for the SP-construction of an LDPC code
is designed properly and the replacement of the entries by the member matrices of
R is carried out properly, the constructed SP-LDPC code can perform well. Note
that for 0 ≤j < n1, H1, j,π and H0 satisfy a pair-wise row (PW-R) constraint, i.e.,
no two rows, one in H1, j,π and the other in H0 have more than one position where
they both have nonzero components. This simply follows from the structure of
H1, j,π (or H1, j) in which each row contains at most one 1-entry.
In the following, we use H0 and H1,0,π, H1,1,π, ..., H1,n1−1,π to construct a
CN-based GC-LDPC code. First, we construct an (n1 +1)× n1 binary matrix Bsp
11
12:43:20, subject to the Cambridge Core terms of use,

150
10 Globally Coupled QC-LDPC Codes
in the form of (10.3). Next, we replace the n1 1-entries on the main diagonal of the
upper n1 × n1 submatrix of Bsp by the parity-check matrix H0 of the LDPC code
C0 and the 0-entries by ZMs of size m0 × n0. Then, we replace the n1 1-entries of
the bottom row of Bsp by H1,0,π, H1,1,π, ..., H1,n1−1,π. The above replacements
result in the following (n1 + 1) × n1 array of matrices over GF(2) of two different
sizes, m0 × n0 and m1n0 × n0:
Hgc,cn,sp(C0,C1) =
⎡
⎢⎢⎢⎢⎢⎣
H0
H0
...
H0
H1,0,π
H1,1,π
···
H1,n1−1,π
⎤
⎥⎥⎥⎥⎥⎦
.
(10.7)
The array Hgc,cn,sp(C0,C1) is an (m0n1 + m1n0) × n0n1 matrix over GF(2).
Since H0 and H1 satisfy the RC-constraint and H0 and H1, j,π satisfy the
PW-R-constraint, it follows from the structure of Hgc,cn,sp(C0,C1) displayed in
(10.7) that Hgc,cn,sp(C0,C1) satisﬁes the RC-constraint. Hence, the null space of
Hgc,cn,sp(C0,C1) gives a CN-based GC-LDPC code of length n0n1, denoted by
Cgc,cn,sp(C0,C1) = C0 × C1, whose Tanner graph has girth at least 6.
Note that the lower submatrix [H1,0,π H1,1,π ... H1,n1−1,π] consists of
n0 copies of the parity-check matrix H1 of C1. Therefore, the parity-check
matrix Hgc,cn,sp(C0,C1) of Cgc,cn,sp(C0,C1) consists of n1 copies of H0 and
n0 copies of H1 (interleaved). Let v = (v0,v1,...,vn0n1−1) be a codeword in
Cgc,cn,sp(C0,C1). Divide this codeword into n1 sections, each consisting of n0
consecutive components of v. For 0 ≤i < n1, let vi be the i-th section of v.
Then, v = (v0,v1,...,vn1−1). From the structure of Hgc,cn,sp(C0,C1) displayed
by (10.7), we see that each section vi of v is a codeword in C0. We can also divide
the codeword into n0 sections, denoted by v⋆
0,v⋆
1,...,v⋆
n0−1, each consisting of n1
components of v, where for 0 ≤j < n0, v⋆
j = (v j,vn0+ j,v2n0+ j,...,v(n1−1)n0+ j).
It follows from the structure of H1,0,H1,1,...,H1,n1−1 displayed by (10.6) that
each section v⋆
j is a codeword in C1. Let v⋆= (v⋆
0,v⋆
1,...,v⋆
n0−1). Then, v⋆is
simply a permutation of v. From the structure of the codewords described above
in Cgc,cn,sp(C0,C1), the code Cgc,cn,sp(C0,C1) is simply the direct product of
C0 and C1 [74, 110, 111] with Hgc,cn,sp(C0,C1) as its parity-check matrix. The
codes C0 and C1 are referred to as the horizontal and vertical component codes
of the CN-based product GC-LDPC code Cgc,cn,sp(C0,C1), respectively. The two
matrices H0 and H1 are called the horizontal and vertical component parity-check
matrices of CN-based product GC-LDPC code Cgc,cn,sp(C0,C1), respectively.
Let d0 and d1 be the minimum distances of C0 and C1, respectively.
Then the minimum distance of Cgc,cn,sp(C0,C1) is d0d1, the product of d0
11
12:43:20, subject to the Cambridge Core terms of use,

10.3 Construction of CN-Based GC-LDPC Codes
151
and d1. Decoding of Cgc,cn,sp(C0,C1) can be performed either based on the
parity-check matrix Hgc,cn,sp(C0,C1) given by (10.7) or based on the two-phase
decoding presented in Section 10.2. The two-phase decoding can be carried out
iteratively, with the local-phase decoding and global-phase decoding performed
alternatively.
If H0 is an array of circulants (or CPMs) and/or ZMs of size k × k over GF(2),
then Hgc,cn,sp(C0,C1) is an array of circulants and ZMs of sizes k ×k and n0 ×n0.
If n0 = δk, then an n0 × n0 identity matrix can be viewed as a δ × δ array of
identity matrices of size k × k, that consists of δ k × k identity matrices lying on
its main diagonal. In this case, Hgc,cn,sp(C0,C1) is an array of binary circulants
and ZMs of size k × k and Cgc,cn,sp(C0,C1) is a CN-based QC-GC-LDPC
code.
The minimum distance of a CN-based product GC-LDPC code can be relatively
large even if the minimum distances of its two component codes are small.
A large minimum distance may result in a very low error-ﬂoor if the Tanner
graph of the code does not contain trapping sets with size smaller than its
minimum distance. LDPC codes constructed based on ﬁnite geometries have
relatively large minimum distances [58, 74, 97] and their Tanner graphs contain
no small trapping sets with sizes smaller than their minimum distances [28, 29].
Furthermore, the parity-check matrix of a ﬁnite geometry (Euclidean or projective)
LDPC code has large row-redundancy [58, 46, 28]. The above three structural
properties make the error-ﬂoor of a ﬁnite geometry LDPC code very low. In
the product construction of a CN-based GC-LDPC code, we can use a ﬁnite
geometry LDPC code as the horizontal component code C0 and a simple LDPC
code, such as a single parity-check code (SPC), as the vertical component code
C1. In this case, the resultant CN-based product GC-LDPC code has a minimum
distance which is twice the minimum distance of the horizontal component
code C0.
Example 10.3. Suppose we use the two-dimensional Euclidean geometry EG(2,24)
over GF(24) to construct the horizontal component code C0 of a CN-based product
GC-LDPC code Cgc,cn,sp(C0,C1). Using the lines not passing through the origin
of EG(2,24), we can construct an RC-constrained binary circulant H0 of size
255 × 255 with both column and row weights 16. The null space of H0 gives
a (255,175) cyclic LDPC code C0 with minimum distance 17 whose Tanner
graph contains no trapping sets with size smaller than 17 [28]. Next, we choose
the (16,15) SPC code as the vertical component code C1 of Cgc,cn,sp(C0,C1).
The SPC code C1 has minimum distance 2. The parity-check matrix H1 of
C1 is a row of 16 1-entries. Based on H1, we construct a single row-block
11
12:43:20, subject to the Cambridge Core terms of use,

152
10 Globally Coupled QC-LDPC Codes
[H1,0,π H1,1,π ... H1,15,π] of 16 identity matrices of size 255 × 255, which is a
255×4080 matrix over GF(2) with column and row weights 1 and 16, respectively.
Using H0 and H1,0,π,H1,1,π,...,H1,15,π, we construct the parity-check matrix
Hgc,cn,sp(C0,C1) of the CN-based product GC-LDPC code Cgc,cn,sp(C0,C1) in
the form given by (10.7). Since every submatrix in Hgc,cn,sp(C0,C1) is a 255×255
circulant, Hgc,cn,sp(C0,C1) is a 17 × 16 array of circulants and ZMs of size
255 × 255. It is a 4335 × 4080 matrix with column and row weights 17 and 16,
respectively. The null space of Hgc,cn,sp(C0,C1) gives a (4080,2625) CN-based
product QC-GC-LDPC code Cgc,cn,sp(C0,C1) with rate 0.6434 and minimum
distance at least 34, a large minimum distance for an LDPC code. Note that H0
has 80 redundant rows, a large row redundancy. (It is typical that an EG-LDPC
code has large row redundancy [58, 46, 28].) Using the local/global two-phase
decoding scheme, any 8 or fewer random errors are guaranteed to be corrected by
the local decoder.
If we put H0 as a 17 × 17 array of CPMs and ZMs of size 15 × 15 (see
Appendix A or [46]) and regard each 255×255 identity matrix H1, j,π as a 17×17
diagonal array of identity matrices of size 15 × 15. Then, Hgc,cn,sp(C0,C1) is a
34 × 272 array of CPMs and ZMs of size 15 × 15.
The BER and BLER performances of the code Cgc,cn,sp(C0,C1) decoded with
50 iterations of the MSA over the AWGNC are shown in Fig. 10.5(a). At a BLER
of 10−7, the code performs about 2.2 dB away from the SPB and it performs within
2.8 dB of the Shannon limit at a BER of 10−10.
The UEBR and UEBLR performances of Cgc,cn,sp(C0,C1) over the BEC are
shown in Fig. 10.5(b). At a UEBR of 10−10, the code performs about 0.4 away
from the Shannon limit.
The CN-based product GC-LDPC code Cgc,cn,sp(C0,C1) is capable of correct-
ing any burst of erasures of length at least up to n0. For such a burst of erasures,
there is at least one row in the lower submatrix [H1,0,π H1,1,π ... H1,n1−1,π] of
Hgc,cn,sp(C0,C1) which checks (or contains) one and only one erasure in the burst.
Hence, every erased code symbol can be resolved. A small number of scattering
random erasures in each block can be corrected by the horizontal component
code C0. For example, the (4080,2625) CN-based product QC-GC-LDPC code
Cgc,cn,sp(C0,C1) constructed in Example 10.3 is capable of correcting any
erasure-burst of length up to 255. Furthermore, any 16 or fewer random erasures
conﬁned in a block of Cgc,cn,sp(C0,C1) can be corrected by C0 [74]. This is based
on the RC-constraint structure of the parity-check matrix H0 of C0 – that each
erasure is checked by 16 rows, and the other 15 erasures can be distributed in at
most 15 of these rows. Consequently, there is at least one row among these 16 rows
that checks only one erasure and hence its value can be determined.
11
12:43:20, subject to the Cambridge Core terms of use,

0.8
1.2
1.6
2
2.4
2.8
3.2
3.6
4
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
Cgc,cn,sp(C0, C1), BLER
Cgc,cn,sp(C0, C1), BER
SPB
Shannon Limit
0.24
0.26
0.28
0.3
0.32
0.34
0.36
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBLR/UEBR
ε
Cgc,cn,sp(C0, C1), UEBLR
Cgc,cn,sp(C0, C1), UEBR
Shannon Limit
Figure 10.5. (a) The BER and BLER performances of the (4080,2625) CN-based
product GC-LDPC code Cgc,cn,sp(C0,C1) given in Example 10.3 over the
AWGNC; and (b) the performance of the code in (a) over the BEC.
11
12:43:20, subject to the Cambridge Core terms of use,

154
10 Globally Coupled QC-LDPC Codes
10.4 CPM-Dispersion Construction of CN-Based Product
QC-GC-LDPC Codes
A CN-based product QC-GC-LDPC code can be constructed based on 2 × 2
SM-constrained base matrices using the CPM-D-SP-construction. For illustration,
we use the 2 × 2 SM-constrained base matrix Bq,sp,s over GF(q) in the form of
(7.1) presented in Section 7.3 for the code construction.
Let α be a primitive element of the ﬁeld GF(q) and let m0, m1, n0, and n1 be
four positive integers such that 1 ≤m0,m1,n0,n1 ≤q. Next, we form two matrices
B0 and B1 with sizes m0 ×n0 and m1 ×n1, respectively, each in the form of (7.1).
The matrix B0 is constructed based on two subsets S0,0 and S0,1 of GF(q) of sizes
m0 and n0, respectively, and the matrix B1 is constructed based on two subsets S1,0
and S1,1 of GF(q) of sizes m1 and n1, respectively. For simplicity, we set η = 1 in
the construction of B0 and B1.
The null spaces of the CPM-dispersions H0 = CPM(B0) and H1 = CPM(B1) of
B0 and B1 give two CPM-QC-SP-LDPC codes, denoted by C0 and C1, of lengths
n0(q −1) and n1(q −1), respectively, whose Tanner graphs have girth at least 6.
Taking the direct product of C0 and C1 as described in Section 10.3, we obtain
a CN-based product GC-LDPC code whose parity-check matrix is in the form of
(10.7).
In the following, we take the CPM-dispersion approach to construct a CN-based
product QC-GC-LDPC code based on the two base matrices B0 and B1. For 0 ≤
j < n1, let b1, j denote the j-th column of B1. For each column b1, j, we form an
m1n0 ×n0 matrix over GF(q) by shifting b1, j downward to the right n0 −1 times,
each time m1 positions, as follows:
B1, j =
⎡
⎢⎢⎢⎣
b1, j
b1, j
...
b1, j
⎤
⎥⎥⎥⎦.
(10.8)
Next, we form the following (m0n1 + m1n0) × n0n1 matrix over GF(q):
Bgc,cn(B0,B1) =
⎡
⎢⎢⎢⎢⎢⎣
B0
B0
...
B0
B1,0
B1,1
···
B1,n1−1
⎤
⎥⎥⎥⎥⎥⎦
.
(10.9)
It follows from the structures of B1, j and Bgc,cn(B0,B1) displayed by (10.8) and
(10.9) that Bgc,cn(B0,B1) satisﬁes the 2 × 2 SM-constraint. Note that the lower
11
12:43:20, subject to the Cambridge Core terms of use,

10.4 Product QC-GC-LDPC Codes by CPM-Dispersion
155
submatrix [B1,0 B1,1 ... B1,n1−1] of Bgc,cn(B0,B1) is formed by taking n0 copies
of B1 and interleaving the copies.
Dispersing each nonzero entry of Bgc,cn(B0,B1) into a binary (q −1) ×
(q −1) CPM and each 0-entry into a (q −1)×(q −1) ZM, we obtain the following
(m0n1 + m1n0) × n0n1 array of binary CPMs and ZMs of size (q −1) × (q −1):
Hb,gc,cn,sp(C0,C1) =
⎡
⎢⎢⎢⎢⎢⎣
H0
H0
...
H0
H1,0
H1,1
···
H1,n1−1
⎤
⎥⎥⎥⎥⎥⎦
.
(10.10)
Note that the lower subarray [H1,0 H1,1 ... H1,n1−1] of Hb,gc,cn,sp(C0,C1)
consists of n0 copies of H1. For 0 ≤j < n1, each column-block of H1, j is a column
of CPMs and ZMs of size (q −1) × (q −1).
The null space of Hb,gc,cn,sp(C0,C1) gives a CN-based CPM-QC-GC-LDPC
code Cb,gc,cn,sp(C0,C1) which is the direct product of two CPM-QC-SP-LDPC
codes C0 and C1 given by the null spaces of H0 = CPM(B0) and H1 = CPM(B1),
respectively. The base matrix Bgc,cn(B0,B1) is referred to as the product of B0
and B1 and called the product base matrix. The matrices B0 and B1 are called the
horizontal and vertical component base matrices, respectively.
The CN-based product CPM-QC-GC-LDPC code Cb,gc,cn,sp(C0,C1) has a
very interesting graphical structure. Let Gptg,0 and Gptg,1 be the Tanner graphs
associated with B0 and B1, respectively. Let Gb,gc,cn,sp(q −1,q −1) be the Tanner
graph of Cb,gc,cn,sp(C0,C1). Then, from the structure of Hb,gc,cn,sp(C0,C1) and
[H1,0 H1,1 ... H1,n1−1], we see that Gb,gc,cn,sp(q −1,q −1) is formed from
Gptg,0 and Gptg,1 by taking the following steps: (1) Create n1 copies of Gptg,0
and n0 copies of Gptg,1; (2) Expand each copy of Gptg,0 and each copy of Gptg,1
by a factor of q −1 to form two connected Tanner graphs Gptg,0(q −1,q −1)
and Gptg,1(q −1,q −1) through edge permutations; (3) Connect the n1 copies
of Gptg,0(q −1,q −1) by the m1n0(q −1) CNs of the n0 copies of Gptg,1(q −
1,q −1); and (4) Connect the n0 copies of Gptg,1(q −1,q −1) by the m0n1(q −1)
CNs of the n1 copies of Gptg,0(q −1,q −1). Therefore, we may view the code
Cb,gc,cn,sp(C0,C1) as a doubly CN-based QC-GC-LDPC code whose Tanner
graph is constructed from the copies of two protographs connected by two sets
of global CNs.
We may view the Tanner graph Ggc,cn(B0,B1) associated with the base
matrix Bgc,cn(B0,B1) given by (10.9) as the protograph for constructing a
CN-based CPM-QC-GC-LDPC code Cb,gc,cn,sp(C0,C1). In this case, we simply
take q −1 copies of Ggc,cn(B0,B1) and connect them by permuting their
11
12:43:20, subject to the Cambridge Core terms of use,

156
10 Globally Coupled QC-LDPC Codes
edges. This copy-and-permute operation on Ggc,cn(B0,B1) gives a Tanner graph
whose adjacency matrix speciﬁes a QC-PTG-LDPC code. Therefore, a CN-based
QC-GC-LDPC code can be viewed either as an SP-LDPC code or as a PTG-LDPC
code.
In forming the product base matrices Bgc,cn(B0,B1), masking can be performed
on either component base matrix B0, or B1, or both, to reduce the number
of short cycles in the Tanner graph of the resultant masked product CN-based
CPM-QC-GC-LDPC code.
Example 10.4. Let GF(331) be the ﬁeld for the code construction and let
α be a primitive element of GF(331). Suppose we construct a base matrix
B0 in the form of (7.1) using the following two subsets of GF(331): S0,0 =
{α0,α1,α2,α3} and S0,1 = {α130,α131,α132,α133,α134,α135,α136,α137}. Set η =
−1. The construction results in the following 4 × 8 matrix B0 over GF(331):
B0 =
⎡
⎢⎢⎣
α72
α147
α139
α218
α285
α69
α173
α189
α62
α73
α148
α140
α219
α286
α70
α174
α159
α63
α74
α149
α141
α220
α287
α71
α103
α160
α64
α75
α150
α142
α221
α288
⎤
⎥⎥⎦.
(10.11)
Next, we construct another base matrix B1 using the following two subsets of
GF(331): S1,0 = {α4} and S1,1 = {α130,α131,α132,α133,α134,α135}. Again, set
η = −1. The construction results in the following 1 × 6 matrix B1 over GF(331):
B1 =

α67
α104
α161
α65
α76
α151 
.
(10.12)
Masking B0 with the masking matrix Z given by (7.5), we obtain the following
masked base matrix:
B0,mask =
⎡
⎢⎢⎣
α72
0
α139
0
α285
α69
α173
α189
0
α73
0
α140
α219
α286
α70
α174
α159
α63
α74
α149
α141
0
α287
0
α103
α160
α64
α75
0
α142
0
α288
⎤
⎥⎥⎦. (10.13)
Using B0,mask and B1 as the horizontal and vertical component base matrices,
respectively, we construct a 32 × 48 matrix Bgc,cn(B0,mask,B1) over GF(331)
in the form of (10.9). The matrix Bgc,cn(B0,mask,B1) has column weight 4
and row weight 6. By checking, we ﬁnd that Bgc,cn(B0,mask,B1) satisﬁes the
3 × 3 SM-constraint. Using Bgc,cn(B0,mask,B1) as a product base matrix, we can
construct a CN-based product CPM-QC-GC-LDPC code whose Tanner graph has
girth at least 8.
Dispersing each nonzero entry in Bgc,cn(B0,mask,B1) into a 330 × 330 binary
CPM and each 0-entry into a 330 × 330 ZM, we obtain a 32 × 48 binary
11
12:43:20, subject to the Cambridge Core terms of use,

10.4 Product QC-GC-LDPC Codes by CPM-Dispersion
157
array Hb,gc,cn,sp(C0,mask,C1) of CPMs and ZMs of size 330 × 330. The
matrix Hb,gc,cn,sp(C0,mask,C1) is a 10 560 × 15 840 matrix over GF(2) with
column weight 4 and row weight 6. The null space of Hb,gc,cn,sp(C0,mask,C1)
gives a (4,6)-regular (15840,6600) CN-based product CPM-QC-GC-LDPC code
Cb,gc,cn,sp(C0,mask,C1), whose Tanner graph Cb,gc,cn,sp(C0,mask,C1) has girth 8
and contains 297000 cycles of length 8 and 79200 cycles of length 10.
The BER and BLER performances of the code Cb,gc,cn,sp(C0,mask,C1) over the
AWGNC decoded with 50 iterations of the MSA are shown in Fig. 10.6(a). We
see that the code can achieve a BER of 10−7 without a visible error-ﬂoor and it
performs about 1.4 dB away from the SPB at a BLER of 10−5.
For comparison, the BER and BLER performances of a (15840,6601)
LDPC code C peg constructed using the PEG algorithm are also included in
Fig. 10.6(a). The PEG code C peg has a rate close to that of the CN-based product
CPM-QC-GC-LDPC code Cb,gc,cn,sp(C0,mask,C1). The parity-check matrix of
the PEG code Cpeg is a 9240 × 15840 binary matrix and has constant column
weight 4. (Note that the size of the parity-check matrix of the PEG code C peg is
different from that of the parity-check matrix of the code Cb,gc,cn,sp(C0,mask,C1).)
The Tanner graph of Cpeg has girth 10 and contains 128482 cycles of length 10
and 2545908 cycles of length 12. From Fig. 10.6(a), we see that the CN-based
product CPM-QC-GC-LDPC code Cb,gc,cn,sp(C0,mask,C1) outperforms the PEG
code Cpeg by about 0.6 dB.
The UEBR and UEBLR performances of the code Cb,gc,cn,sp(C0,mask,C1) are
shown in Fig. 10.6(b). We see that the code Cb,gc,cn,sp(C0,mask,C1) also performs
well over the BEC.
In forming the product base matrix Bgc,cn(B0,B1) in the form of (10.9), we
can also use n1 different m0 ×n0 matrices B0,0,B0,1,...,B0,n1−1 as the horizontal
component base matrices on the main diagonal of the upper n1 × n1 subarray of
the product base matrix. This results in the following product base matrix:
B′
gc,cn =
⎡
⎢⎢⎢⎢⎢⎣
B0,0
B0,1
...
B0,n1−1
B1,0
B1,1
···
B1,n1−1
⎤
⎥⎥⎥⎥⎥⎦
.
(10.14)
For 0 ≤i < n1, the null space of the CPM-dispersion of B0,i gives a
CPM-QC-SP-LDPC code C0,i. The CN-based product CPM-QC-GC-LDPC code
C′
b,gc,cn,sp given by the null space of the binary CPM-dispersion H′
b,gc,cn,sp of the
product base matrix B′
gc,cn is a product of n1 horizontal component codes C0,0,
C0,1, ..., C0,n1−1 and one vertical component code C1.
11
12:43:20, subject to the Cambridge Core terms of use,

0
0.4
0.8
1.2
1.6
2
2.4
2.8
3
(a)
BLER/BER
Eb/N0
(15840, 6600), Cb,gc,cn,sp, BER
(15840, 6600), Cb,gc,cn,sp, BLER
(15840, 6601), Cpeg, BER
(15840, 6601), Cpeg, BLER
SPB
10−7
10−6
10−5
10−4
10−3
10−2
10−1
100
0.48
0.5
0.52
0.54
0.56
0.58
10−8
10−7
10−6
10−5
10−4
10−3
10−2
10−1
100
(b)
UEBR/UEBLR
ε
(15840, 6600), Cb,gc,cn,sp, UEBR
(15840, 6600), Cb,gc,cn,sp, UEBLR
Shannon limit
Figure 10.6. (a) The BER and BLER performances of the (15840,6600)
CN-based product CPM-QC-GC-LDPC code Cb,gc,cn,sp(C0,mask,C1) and the
(15840,6601) PEG code C peg given in Example 10.4 over the AWGNC; and
(b) the performance of the code Cb,gc,cn,sp(C0,mask,C1) in (a) over the BEC.
11
12:43:20, subject to the Cambridge Core terms of use,

10.4 Product QC-GC-LDPC Codes by CPM-Dispersion
159
Similarly, we can use n0 different m1 × n1 vertical component base matrices to
form the lower subarray of the product base matrix given in the form of (10.9).
The null space of the CPM-dispersion of the resultant product base matrix gives
a product of n0 + 1 CPM-QC-SP-LDPC codes, a single horizontal and n0 vertical
component codes. In forming a product base matrix in the form of (10.9), we can
use n1 different m0 × n0 horizontal component base matrices to form the upper
diagonal subarray of the product base matrix and n0 different m1 × n1 vertical
component base matrices to form the lower subarray of the product base matrix.
Then, the null space of the CPM-dispersion of the resultant product base matrix
gives a product of n1 horizontal and n0 vertical component CPM-QC-SP-LDPC
codes. A product code constructed by using more than two component codes is
referred to as a generalized product code.
The above product construction using the CPM-D construction gives a large
family of CN-based product CPM-QC-GC-LDPC codes. In the construction, any
2 × 2 SM-constrained base matrix can be used. Product codes are effective for
correcting combinations of random and burst errors [74].
Example 10.5. Consider the code construction ﬁeld GF(127). Let α be a primitive
element of GF(127). In this example, we choose the following parameters: m0 = 2,
n0 = 6, m1 = 1, and n1 = 6. The pairs of subsets of GF(127) for constructing the 6
horizontal component base matrices B0,0, B0,1, B0,2, B0,3, B0,4, and B0,5 are:
(1) S0,0 = {α0,α1} and S0,1 = {α11,α12,α13,α14,α15,α16};
(2) S1,0 = {α0,α1} and S1,1 = {α17,α18,α19,α20,α21,α22};
(3) S2,0 = {α0,α1} and S2,1 = {α23,α24,α25,α26,α27,α28};
(4) S3,0 = {α0,α1} and S3,1 = {α29,α30,α31,α32,α33,α34};
(5) S4,0 = {α0,α1} and S4,1 = {α35,α36,α37,α38,α39,α40};
(6) S5,0 = {α0,α1} and S5,1 = {α41,α42,α43,α44,α45,α46}.
The two subsets of GF(127) for constructing the vertical component base matrix
B1 are: S1,0 = {α2} and S1,1 = {α11,α12,α13,α14,α15,α16}.
Set η = −1. Based on the above pairs of subsets of GF(127) and using
the construction given by (7.1), we obtain the following horizontal and vertical
component base matrices:
B0,0 =
	
α8
α5
α43
α24
α79
α57
α102
α9
α6
α44
α25
α80

,
11
12:43:20, subject to the Cambridge Core terms of use,

160
10 Globally Coupled QC-LDPC Codes
B0,1 =
	 α86
α107
α100
α87
α105
α69
α58
α87
α108
α44
α88
α106

,
B0,2 =
	 α54
α14
α98
α108
α59
α116
α70
α55
α15
α99
α109
α60

,
B0,3 =
	
α7
α2
α67
α72
α83
α48
α117
α8
α3
α68
α73
α84

,
B0,4 =
	 α96
α63
α42
α55
α122
α120
α49
α97
α64
α43
α56
α123

,
B0,5 =
	 α97
α37
α13
α62
α64
α71
α121
α98
α38
α14
α63
α65

,
and
B1 =

α77
α103
α10
α7
α45
α26 
.
Based on B0,0, B0,1, B0,2, B0,3, B0,4, B0,5, and B1, we construct an 18 × 36
product base matrix B′
gc,cn over GF(127) in the form of (10.14). B′
gc,cn has column
weight 3 and row weight 6 and it satisﬁes the 2 × 2 SM-constraint. By checking,
we ﬁnd that B′
gc,cn also satisﬁes the 3 × 3 SM-constraint. Therefore, the Tanner
graph associated with the CPM-dispersion of B′
gc,cn has girth at least 8.
The binary CPM-dispersion of B′
gc,cn gives an 18 × 36 array H′
b,gc,cn,sp of
CPMs and ZMs of size 126×126. H′
b,gc,cn,sp is a 2268×4536 matrix over GF(2)
with column and row weights 3 and 6, respectively. The null space of H′
b,gc,cn,sp
gives a (3,6)-regular (4536,2276) CN-based product CPM-QC-GC-LDPC code
C′
b,gc,cn,sp with rate 0.5018. The Tanner graph of the code C′
b,gc,cn,sp has girth
exactly 8 and contains 756 cycles of length eight, 5292 cycles of length 10,
and 110 334 cycles of length 12. The BER and BLER performances of the code
C′
b,gc,cn,sp over the AWGNC decoded with 50 iterations of the MSA are shown
in Fig. 10.7(a). We see that the code can achieve a BER of 10−9 without a visible
error-ﬂoor and it performs about 1.1 dB away from the SPB at a BLER of 4×10−6.
For comparison, the BER and BLER performances of a (4536,2268) LDPC
code C peg constructed using the PEG algorithm are also included in Fig. 10.7(a).
The PEG code C peg has rate 0.5 which is slightly lower than that of the code
C′
b,gc,cn,sp. The parity-check matrix of the PEG code Cpeg is a 2268×4532 binary
matrix and has constant column weight 3. The Tanner graph of Cpeg has girth
10 and contains 3187 cycles of length 10 and 94 074 cycles of length 12. From
Fig. 10.7(a), we see that the two codes perform almost the same over the AWGNC.
11
12:43:20, subject to the Cambridge Core terms of use,

0.4
0.6
0.8
1
1.2
1.4
1.6
1.8
2
2.2
2.4
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(a)
0
BLER/BER
Eb/N0
(4536,2276), C‘
b,gc,cn,sp, BER
(4536,2276), C‘
b,gc,cn,sp, BLER
(4536,2268), Cpeg, BER
(4536,2268), Cpeg, BLER
SPB
0.36
0.38
0.4
0.42
0.44
0.46
0.48
0.5
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
UEBR/UEBLR
ε
(4536,2276), C‘
b,gc,cn,sp, UEBR
(4536,2276), C‘
b,gc,cn,sp, UEBLR
Shannon limit
Figure 10.7. (a) The BER and BLER performances of the (4536,2276) CN-based
product CPM-QC-GC-LDPC code C′
b,gc,cn,sp and the (4536,2268) PEG code
C peg given in Example 10.5 over the AWGNC; and (b) the performance of the
code C′
b,gc,cn,sp in (a) over the BEC.
11
12:43:20, subject to the Cambridge Core terms of use,

162
10 Globally Coupled QC-LDPC Codes
The UEBR and UEBLR performances of the code C′
b,gc,cn,sp are shown in
Fig. 10.7(b). We see that the code C′
b,gc,cn,sp performs also well over the BEC.
It can achieve a UEBR of 10−9 without an error-ﬂoor.
10.5 Discussion and Remarks
The counterpart of a CN-based GC-LDPC code is an LDPC code whose Tanner
graph consists of a set of disjoint Tanner graphs connected by a group of global
VNs. Such an LDPC code is called a VN-based GC-LDPC code. Construction
of a VN-based CPM-QC-GC-LDPC code, denoted by Cgc,vn,qc, is similar to the
construction of a CN-based CPM-QC-GC-LDPC code presented in Section 10.1.
The base matrix Bgc,vn for constructing a VN-based CPM-QC-GC-LDPC code is
of the following form:
(10.15)
where Ygc,vn(t,s) is an mt × s matrix over GF(q) which is formed by taking
and shortening s unused columns in forming the r × r cyclic array Bq,sp,p(m,n)
of (8.3) from the RS-based r × r array WRS of l × l submatrices over GF(q)
given by (8.2) with 1 ≤s ≤r(l −n). The shortening of each unused column is
done by removing the components at the locations that correspond to the rows
which are not used in forming the array Bq,sp,p(m,n). Hence, each column of
Ygc,vn(t,s) consists of t sections, each with m components. Bgc,vn is a submatrix
of Bq,sp,p(m,n) (after replacing some entries in Bq,sp,p(m,n) by zeros) and hence
satisﬁes the 2×2 SM-constraint. The subscript “vn” in Bgc,vn and Cgc,vn,qc stands
for “variable node.”
From the structure of Bgc,vn, we see that the Tanner graph Ggc,vn associated
with Bgc,vn consists of t copies of the Tanner graph associated with the m × n
matrix R0,0 connected by s global VNs. The null space of the CPM-dispersion
Hgc,vn,qc(q −1,q −1) of Bgc,vn gives a VN-based CPM-QC-GC-LDPC code
Cgc,vn,qc of length (nt + s)(q −1) and rate at least ((n −m)t + s)/(nt + s). The
Tanner graph Ggc,vn may be viewed as the protograph for constructing Cgc,vn,qc.
In this case, Cgc,vn,qc is QC-PTG-LDPC code.
Divide the connection matrix Ygc,vn(t,s) into t submatrices of size m ×
s, Ygc,vn,0,Ygc,vn,1,...,Ygc,vn,t−1, each consisting of m consecutive rows of
Ygc,vn(t,s). For 0 ≤i < t, the matrix [R0,0 Ygc,vn,i] is a 2 × 2 SM-constrained
11
12:43:20, subject to the Cambridge Core terms of use,

10.5 Discussion and Remarks
163
m × (n + s) matrix over GF(q). The null space of the CPM-dispersion
CPM([R0,0 Ygc,vn,i]) gives a CPM-QC-SP-LDPC code C0,i of length (n + s)
(q −1). From a global point of view, the code Cgc,vn,qc given by the null space
of Hgc,vn,qc(q −1,q −1) is a global code which is composed of t local codes
C0,0,C0,1,...,C0,t−1. Let v be a codeword in Cgc,vn,qc. Divide v into t + 1
sections, v0,v1,...,vt−1,vt, each of the ﬁrst t sections consisting of n(q −1)
consecutive components of v and the last section vt consisting of the last s(q −1)
components of v. For 0 ≤i < t, the vector (vi,vt) is a codeword in the local code
C0,i. Note that all the t local codes are different.
A local/global two-phase iterative decoding scheme can be devised to decode
the VN-based CPM-QC-GC-LDPC code Cgc,vn,qc. We leave this to the reader.
Decoding of a CN-based product GC-LDPC code Cgc,cn,sp(C0,C1) based
on its parity-check matrix Hgc,cn,sp(C0,C1) can be a serious problem. If the
lengths of its two component codes C0 and C1 are long (even moderately long),
the length of Cgc,cn,sp(C0,C1) can be very long. In this case, the size of the
parity-check matrix Hgc,cn,sp(C0,C1) is very large and the implementation of
a global decoder for Cgc,cn,sp(C0,C1) based on Hgc,cn,sp(C0,C1) will be very
complex and impractical. How to devise a reduced-complexity iterative scheme
to decode a long CN-based product GC-LDPC code seems to be an interesting
problem.
One possible approach to resolve this high decoder complexity problem is to
decode Cgc,cn,sp(C0,C1) using a turbo BP-decoder. A turbo BP-decoder consists
of two local decoders, one for decoding the horizontal component code C0 and
the other for decoding the vertical component code C1. Each local decoder is a
BP-decoder. The two local BP-decoders exchange reliability messages (LLRs) of
code symbols through two interleavers in the form of turbo decoding. The two
local BP-decoders can be connected either in series or in parallel.
Suppose a codeword v = (v0,v1,...,vn0n1−1) in Cgc,cn,sp(C0,C1) is trans-
mitted. Let r = (r0,r1,...,rn0n1−1) be the corresponding received word. We
sectionalize r in two forms, r = (r0,r1,...,rn1−1) and r⋆= (r⋆
0,r⋆
1,...,r⋆
n0−1),
one with n1 equal sections and the other n0 sections, similar to sectionalizing a
codeword in Cgc,cn,sp(C0,C1) as described in Section 10.3. The vector r⋆is a
permutation of r. For 0 ≤i < n1, the i-th section ri of r is an erroneous version of
a codeword in C0. For 0 ≤j < n0, the j-th section r⋆
j of r⋆is an erroneous version
of a codeword in C1.
Now, we design two local BP-decoders, BP-decoder0 and BP-decoder1.
BP-decoder0 processes the n1 sections of r and BP-decoder1 processes the n0
sections of the permuted received vector r⋆simultaneously. At the end of each
decoding iteration (or a ﬁxed number of decoding iterations), two hard-decision
vectors are produced by the two BP-decoders based on the LLRs of the decoded
11
12:43:20, subject to the Cambridge Core terms of use,

164
10 Globally Coupled QC-LDPC Codes
code symbols. Both of the two hard-decision vectors are tested. There are four
possible outcomes of the test:
1. The ﬁrst case is that both the hard-decision vectors give the same codeword
in Cgc,cn,sp(C0,C1). In this case, we stop the decoding process and deliver
the decoded codeword to the user.
2. The second case is that one of the two hard-decision vectors is a codeword in
Cgc,cn,sp(C0,C1) and the other is not. In this case, we also stop the decoding
process and deliver the codeword to the user.
3. The third case is that the hard-decision vectors are two different codewords
in Cgc,cn,sp(C0,C1). In this case, we can either stop the decoding process
and choose one at random and deliver it to the user, or continue the decoding
process.
4. The fourth case is that both the hard-decision vectors are not codewords in
Cgc,cn,sp(C0,C1). In this case, the decoding process continues.
When another decoding iteration is needed, the two local BP-decoders exchange
reliability messages and then start another decoding iteration. This decoding
process continues until a codeword is delivered to the user or the preset maximum
number of decoding iterations is reached. Note that, after message exchanges,
each code symbol has three reliability measures which are provided by the two
BP-decoders and the channel. How to use these reliability measures to start a
new decoding iteration to achieve the best performance is an issue needing to
be investigated. Whether the above proposed turbo BP-decoding scheme (or its
variations) is effective in the trade-off between the error performance and the
decoding complexity is also worthy of further study.
As pointed out in Chapter 2, a common severe weakness of LDPC codes is
the error-ﬂoor. A high error-ﬂoor may preclude LDPC codes from applications
where very low error rates are required. If an LDPC code has a reasonably
large minimum distance and no trapping sets with size smaller than its minimum
distance, then the code in general has a relatively low error-ﬂoor, e.g., a ﬁnite
geometry LDPC code [58, 74, 97]. The minimum distance of a CN-based product
GC-LDPC code Cgc,cn,sp(C0,C1) is the product of the minimum distances of its
two component codes. Even if the minimum distances of the two component codes
are relatively small, their product can be relatively large. An interesting problem
is how the trapping set structure of a CN-based product GC-LDPC code related to
the trapping set structures of its two component codes. Is the smallest trapping set
of a CN-based product GC-LDPC code much larger than the smallest trapping set
of each of its two component codes? We do not have an answer to this question at
this point; however, we can at least show that there is no small local trapping set
in the Tanner graph Ggc,cn,sp(C0,C1) of Cgc,cn,sp(C0,C1).
11
12:43:20, subject to the Cambridge Core terms of use,

10.5 Discussion and Remarks
165
Consider the parity-check matrix Hgc,cn,sp(C0,C1) of Cgc,cn,sp(C0,C1) given
by (10.7). It consists of n1 column-blocks, each consisting of a copy of the
parity-check matrix H0 and an m1n0 × n0 matrix H1, j,π with 0 ≤j < n1. The
matrix H1, j,π is formed by the j-th column of the parity-check matrix H1 of the
vertical component code C1 by shifting it downward to the right n0 −1 times, each
time by m1 positions. So, each row of H1, j,π is either a row of zeros or a row with
a single 1-entry. Suppose H1 has constant column weight w1. Then each column
of H1, j,π has weight w1. Suppose H0 has constant column weight w0. Then, each
column of the j-th column-block of Hgc,cn,sp(C0,C1) has constant column weight
w0 + w1.
For 1 ≤κ ≤n0 and 0 ≤τ ≤m0, suppose the Tanner graph G0 of C0 contains a
(κ,τ) trapping set T whose induced subgraph T contains κ VNs and τ CNs of odd
degrees. The κ VNs correspond to κ columns of H0. Consider the subgraph G0, j
of the Tanner graph Ggc,cn,sp(C0,C1) of Cgc,cn,sp(C0,C1) induced by the n0 VNs
corresponding to the n0 columns of the j-th column-block of Hgc,cn,sp(C0,C1).
Then, the graph T is a subgraph of G0, j (and also a subgraph of Ggc,cn,sp(C0,C1)).
From the structure of the j-th column-block of Hgc,cn,sp(C0,C1), we see that each
VN in T is checked by w1 rows in H1, j,π. Since the two sets of 1-entries in two
different columns of H1, j,π are disjoint, the κ VNs in T are checked by a total
of κw1 rows, each checking one and only one VN in T . As a result, the (κ,τ)
trapping set T in G0 becomes a (κ,τ +κw1) trapping set in Ggc,cn,sp(C0,C1). Such
a trapping set with VNs contained in the subgraph G0, j is called a local trapping
set in Ggc,cn,sp(C0,C1). We see that the product operation increases the number
of CNs of odd degrees by κw1. If T is a small trapping set in G0, it is not a small
trapping set in Ggc,cn,sp(C0,C1) any more if τ + κw1 ≥4κ (see the deﬁnition of a
small trapping set in Section 2.2).
If we switch the roles of H0 and H1 in forming the parity-check matrix
of a CN-based product GC-LDPC code, we can see that a (κ,τ) trapping set
in the Tanner graph G1 of C1 becomes a (κ,τ + κw0) local trapping set in
Ggc,cn,sp(C0,C1).
Now the hard problem is the analysis of the structure of a trapping set whose
VNs are spread among the subgraph G0, j with 0 ≤j < n1 of Ggc,cn,sp(C0,C1). It
is a challenging combinatorial problem and worthy of investigation.
11
12:43:20, subject to the Cambridge Core terms of use,

11
SP-Construction of Nonbinary LDPC Codes
In this chapter, we consider the SP-construction of LDPC codes over NB ﬁelds.
The SP-construction of NB LDPC codes is similar to the SP-construction of their
binary counterparts. Most algebraic and graphical structural properties developed
for binary SP-LDPC codes in earlier chapters can be applied to NB SP-LDPC
codes with some modiﬁcations. In this chapter, we ﬁrst give a brief description
of the general SP-construction of NB LDPC codes using binary base matrices,
and then present six algebraic methods for constructing these codes using both
binary and NB base matrices. Two of these six construction methods are based
on the conventional parity-check matrices of Reed–Solomon (RS) codes over
ﬁnite ﬁelds of characteristic 2. An iterative BP-decoding algorithm, namely the
Fast-Fourier-Transform (FFT) q-ary SPA (FFT-QSPA) [82, 23, 5], is presented
in Appendix C. All the constructed codes in this chapter are simulated on the
binary-input AWGNC.
11.1 General SP-Construction of NB LDPC Codes Using
Binary Base Matrices
Let Bsp = [bi, j]0≤i<m,0≤j<n be an m ×n binary matrix. We use this binary matrix
as the base matrix for the SP-construction of an NB LDPC code. (NB base matrices
for the SP-construction of NB LDPC codes will be considered in later sections.)
Let R = {Q1,Q2,...,Qr} be a set of r sparse k × t matrices over an NB ﬁeld
GF(q) where q is a prime or a power of a prime and q  2. We form an m × n
array Hq,sp(k,t) of k × t matrices over GF(q) by replacing each 1-entry in Bsp by
a member matrix in R and each 0-entry by a k × t ZM. The array Hq,sp(k,t) is an
mk × nt sparse matrix over GF(q), where the subscript “q” stands for “q-ary.”
The null space over GF(q) of Hq,sp(k,t) gives a q-ary SP-LDPC code Cq,sp.
If we impose the RC-constraint on the base matrix Bsp and the RC- and
166
12
12:44:57, subject to the Cambridge Core terms of use,

11.2 SP-Construction of NB QC-LDPC Codes
167
PW-RC-constraints on the member matrices of the replacement set R, then the
Tanner graph Gq,sp(k,t) associated with the parity-check array Hq,sp(k,t) will
have girth at least 6.
The general structural properties of the Tanner graph of an NB SP-LDPC code
are the same as those for the Tanner graph of a binary SP-LDPC code, except that
the edges are labeled with nonzero elements in GF(q).
For a given rate Rc, we choose the parameters m, n, k, and t such that Rc =
(nk −mt)/nk. Suppose we choose at random both an m × n SP-base matrix Bsp
and a replacement set R of k × t sparse constituent matrices over GF(q) (i.e.,
the member matrices in R are chosen at random). Random replacement of the
1-entries of the SP-base matrix Bsp by the constituent matrices in R would result
in an ensemble, denoted by ξq,sp(k,t), of sparse arrays. The null spaces of sparse
arrays in the ensemble ξq,sp(k,t) give a code ensemble, denoted by Eq,sp(k,t), of
q-ary SP-LDPC codes of rate Rc. When k = t, the ensemble Eq,sp(k,t) of q-ary
SP-LDPC codes of rate Rc deﬁned above can be viewed as an ensemble of q-ary
PTG-LDPC codes of rate Rc.
11.2 SP-Construction of NB QC-LDPC Codes
Consider the special case for which k = t. Suppose each member matrix in
the replacement set R is a circulant over GF(q) of size k × k. Then, the array
Hq,sp,qc(k,k) = [Qi, j]0≤i<m,0≤j<n constructed by replacing each 1-entry in Bsp
by a member circulant in R and each 0-entry by a k × k ZM is an m × n array of
circulants over GF(q) and/or ZMs of size k × k, and its null space gives a q-ary
QC-SP-LDPC code Cq,sp,qc. From the PTG point of view, Cq,sp,qc is equivalent
to a q-ary QC-PTG-LDPC code.
If we permute the rows and columns of Hq,sp,qc(k,k) based on the inverses
of the row and column permutations, πrow and πcol, deﬁned by (4.3) and (4.5),
respectively, we obtain the following k × k array Hq,sp,cyc(m,n) of matrices of
size m × n over GF(q) in the form of (4.1) with a block-cyclic structure:
Hq,sp,cyc(m,n) =
⎡
⎢⎢⎢⎣
D0
D1
···
Dk−1
Dk−1
D0
···
Dk−2
...
...
...
...
D1
D2
···
D0
⎤
⎥⎥⎥⎦,
(11.1)
in which each constituent matrix Di is an m ×n matrix over GF(q). The null space
of Hq,sp,cyc(m,n) gives a q-ary QC-LDPC code Cq,sp,cyc with a block-cyclic
structure.
12
12:44:57, subject to the Cambridge Core terms of use,

168
11 SP-Construction of Nonbinary LDPC Codes
The top (generator) row-block of Hq,sp,cyc(m,n), [D0,D1,...,Dk−1], consists
of k constituent matrices of size m × n over GF(q). Suppose we combine the
k matrices, D0,D1,...,Dk−1, into a single m × n matrix, denoted by Bq,ptg, in
which, for 0 ≤i < m and 0 ≤j < n, the entry at location (i, j) is a k-tuple
gi, j = (gi, j,0,gi, j,1,...,gi, j,k−1) over GF(q) where, for 0 ≤e < k, gi, j,e is the entry
at the location (i, j) of the matrix De. Hence, Bq,ptg is a matrix whose entries are
k-tuples over GF(q). The Tanner graph Gq,ptg associated with Bq,ptg consists of
n VNs and m CNs. The edge connecting the j-th VN of Gq,ptg to the i-th CN
of Gq,ptg is labeled by the k-tuple gi, j = (gi, j,0,gi, j,1,...,gi, j,k−1) over GF(q).
The number of nonzero components in gi, j is the number of parallel edges that
connect the j-th VN to the i-th CN of Gq,ptg. If gi, j is an all-zero k-tuple, i.e.,
all the components in gi, j are zeros, then the j-th VN and the i-th CN of Gq,ptg
are not connected. Following on from the replacements of the 1-entries in Bsp
by the member matrices in R and the column and row permutations performed
on Hq,sp,qc(k,k), we see that the vector label gi, j for the edge ( j,i) in Gq,ptg is
simply the generator of the constituent circulant Qi, j in Hq,sp,qc(k,k).
For the PTG-based construction of a q-ary QC-PTG-LDPC code Cq,ptg,qc, the
graph Gq,ptg can be used as the protograph. Suppose we expand Gq,ptg by a factor
of k. In the construction, we take k copies of Gq,ptg and connect the copies of
Gq,ptg by permuting the edges of individual copies of Gq,ptg among the k copies
of Gq,ptg. The k VNs of type- j are connected to the k CNs of type-i based on
the vector label gi, j = (gi, j,0,gi, j,1,...,gi, j,k−1) and their cyclic shifts for the
edge ( j,i) in Gq,ptg. The number of nonzero components in gi, j is equal to the
number of parallel edges connecting the j-th VN and i-th CN of the protograph
Gq,ptg. The expansion of Gq,ptg gives a bipartite graph Gq,ptg(k,k) with nk VNs
and mk CNs in which each edge is labeled with a nonzero element in GF(q). The
null space of the adjacency matrix Hq,ptg,qc(k,k) of Gq,ptg(k,k) gives a q-ary
QC-PTG-LDPC code Cq,ptg,qc which is the same as the q-ary QC-SP-LDPC code
Cq,sp,qc speciﬁed by the q-ary array Hq,sp,qc(k,k) given above. This shows that
for the special case k = t, a q-ary QC-SP-LDPC code Cq,sp,qc constructed by
the SP-construction is a q-ary QC-PTG-LDPC code Cq,ptg,qc constructed by the
PTG-based construction.
In the following, we use a simple example to illustrate the SP-construction of an
NB QC-SP-LDPC code.
Example 11.1. Suppose we choose the following binary matrix as the base matrix
Bsp for the SP-construction of an NB QC-SP-LDPC code:
Bsp =
	 1
1
0
1
0
1

.
12
12:44:57, subject to the Cambridge Core terms of use,

11.2 SP-Construction of NB QC-LDPC Codes
169
Let α be a primitive element of GF(22) constructed based on the primitive
polynomial 1+ X + X2 over GF(2). The ﬁeld GF(22) consists of four elements, 0,
1, α, and α2. Let R be the replacement set for the SP-construction that consists of
the following four circulants of size 3 × 3 over GF(22):
Q1 =
⎡
⎣
1
α
0
0
1
α
α
0
1
⎤
⎦,
Q2 =
⎡
⎣
0
α
0
0
0
α
α
0
0
⎤
⎦,
Q3 =
⎡
⎣
0
0
α2
α2
0
0
0
α2
0
⎤
⎦,
Q4 =
⎡
⎣
α
0
0
0
α
0
0
0
α
⎤
⎦.
By checking, we ﬁnd that the SP-base matrix Bsp and the member matrices in
the replacement set R satisfy the RC- and the PW-RC-constraints, respectively.
Construct a 2 × 3 array Hq,sp,qc(3,3) by replacing the 1-entries of Bsp with the
member circulants in R and the 0-entries by 3 × 3 ZMs as follows:
Hq,sp,qc(3,3) =
	Q1 Q2
0
Q3
0
Q4

=
⎡
⎢⎢⎢⎢⎢⎢⎣
1
α
0
0 α 0 0 0 0
0
1
α
0 0 α 0 0 0
α
0
1
α 0 0 0 0 0
0
0
α2 0 0 0 α 0 0
α2
0
0
0 0 0 0 α 0
0
α2
0
0 0 0 0 0 α
⎤
⎥⎥⎥⎥⎥⎥⎦
.
The array Hq,sp,qc(3,3), a 6×9 matrix over GF(22), satisﬁes the RC-constraint.
The null space of Hq,sp,qc(3,3) gives a 4-ary (9,3) QC-SP-LDPC code Cq,sp,qc
with a section-wise cyclic structure. (Note that there are several other replacements
of the 1-entries in the base matrix Bsp by the member circulants of R which result
in RC-constrained arrays.)
Permuting the rows and the columns of Hq,sp,qc(3,3) using the inverses of the
permutations πrow and πcol deﬁned by (4.3) and (4.5), respectively, we obtain the
following 3 × 3 array Hq,sp,cyc(2,3) of 2 × 3 submatrices over GF(22):
Hq,sp,cyc(2,3) =
⎡
⎢⎢⎢⎢⎢⎢⎣
1
0
0
α
α
0
0
0
0
0
0
α
0
0
0
α2
0
0
0
0
0
1
0
0
α
α
0
α2
0
0
0
0
α
0
0
0
α
α
0
0
0
0
1
0
0
0
0
0
α2
0
0
0
0
α
⎤
⎥⎥⎥⎥⎥⎥⎦
.
12
12:44:57, subject to the Cambridge Core terms of use,

170
11 SP-Construction of Nonbinary LDPC Codes
The null space of the array Hq,sp,cyc(2,3) gives a 4-ary (9,3) QC-SP-LDPC
code Cq,sp,cyc with a block-cyclic structure. Every codeword v in Cq,sp,cyc consists
of three sections, each with three code symbols over GF(22). If we shift the
codeword v one section (three code symbols) to the right, we obtain another
codeword in Cq,sp,cyc. The code Cq,sp,cyc is equivalent to Cq,sp,qc in the sense
that the codewords in the former are just the permutations of the codewords in the
latter. By checking, we ﬁnd that Hq,sp,cyc(2,3) satisﬁes the RC-constraint and the
Tanner graph of Cq,sp,cyc has girth 6.
The ﬁrst row-block of Hq,sp,cyc(2,3) consists of three 2×3 constituent matrices
over GF(22) which are:
D0 =
	 1
0
0
0
0
α

,D1 =
	 α
α
0
0
0
0

,D2 =
	 0
0
0
α2
0
0

.
Combining the above three 2 × 3 matrices by grouping their corresponding
entries into 3-tuples over GF(22), we obtain the following 2 × 3 matrix Bq,ptg
in which each entry is a 3-tuple over GF(22):
Bq,ptg =
	 (1,α,0)
(0,α,0)
(0,0,0)
(0,0,α2)
(0,0,0)
(α,0,0)

.
It is easy to check that a vector entry of Bq,ptg is the generator of a constituent
circulant in the 2 × 3 array Hq,sp,qc(3,3).
The Tanner graphs Gsp and Gq,ptg of Bsp and Bq,ptg are shown in Fig. 11.1(a)
and Fig. 11.1(b), respectively.
If we use Gq,ptg as the protograph, take three copies, and permute the edges
among the copies based on their vector labels, we obtain a connected Tanner
graph Gq,ptg(3,3) with 9 VNs and 6 CNs as shown in Fig. 11.1(c). The null
space of the adjacency matrix of Gq,ptg(3,3) gives a 4-ary QC-PTG-LDPC code
which is exactly the 4-ary QC-SP-LDPC code Cq,sp,qc given by the null space of
Hq,sp,qc(3,3).
In the following, we construct a short NB QC-SP-LDPC code and show that it
performs well.
Example 11.2. Consider the following 2 × 4 base matrix for the SP-construction
of an NB QC-SP-LDPC code:
Bsp =
	 1
1
1
1
1
1
1
1

.
Design a replacement set R that consists of eight weight-1 circulants of size
8 × 8 over GF(28), denoted by Q0,Q1,...,Q7. Let α be a primitive element of
12
12:44:57, subject to the Cambridge Core terms of use,

11.2 SP-Construction of NB QC-LDPC Codes
171
(a)
(c)
(b)
Figure 11.1. (a) The protograph Gsp associated with the base matrix Bsp given in
Example 11.1; (b) the Tanner graph Gq,ptg associated with the base matrix Bq,ptg
given in Example 11.1, where g0,0 = (1,α,0), g0,1 = (0,α,0), g1,0 = (0,0,α2),
and g1,2 = (α,0,0); and (c) the Tanner graph Gq,ptg(3,3) given in Example 11.1.
GF(28). The generators of these circulants over GF(28) in R are:
g0 = (0,0,0,0,0,0,α61,0),
g1 = (0,0,0,0,0,α106,0,0),
g2 = (0,0,0,α240,0,0,0,0),
g3 = (0,0,0,0,0,0,0,α125),
g4 = (0,0,0,α229,0,0,0,0),
g5 = (0,0,0,0,0,0,0,α94),
g6 = (0,0,0,0,0,0,α199,0),
g7 = (0,0,0,0,0,α99,0,0).
(11.2)
These 8 member circulants satisfy both the RC- and the PW-RC-constraints.
Replacing the 1-entries in Bsp by the member matrices in R according to the
replacement constraint given in Section 5.1, we obtain a 2 × 4 array of circulants
of size 8 × 8 over GF(28). There are many possible replacements that result in
codes whose Tanner graphs have girth at least 6. One such replacement gives the
following 2 × 4 array Hq,sp,qc(8,8) of weight-1 circulants:
Hq,sp,qc(8,8) =
	 Q0
Q1
Q2
Q3
Q4
Q5
Q6
Q7

.
The array Hq,sp,qc(8,8) is a 16 × 32 matrix over GF(28) with constant column
and row weights 2 and 4, respectively, and its null space gives a (2,4)-regular
256-ary (32,16) QC-SP-LDPC code Cq,sp,qc. Using the cycle counting algorithm
presented in [71], we ﬁnd that the Tanner graph of the code Cq,sp,qc has girth 8 and
contains 20 cycles of length 8, no cycle of length 10, and 160 cycles of length 12.
12
12:44:57, subject to the Cambridge Core terms of use,

172
11 SP-Construction of Nonbinary LDPC Codes
1.75
2
2.25
2.5
2.75
3
3.25
3.5
3.75
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
(a)
−1
BLER
Eb/N0(dB)
256−ary (32,16) Cq,ptg,qc, itr50
256−ary (32,16) Cq,ptg,qc, itr100
256−ary (32,16) CC−NBPB,itr100
256−ary (32,16) CU−NBPB,itr100
256−ary (32,16) SPB
(b)
Figure 11.2. (a) The BLER performances of the 256-ary (32,16) QC-SP-LDPC
code Cq,sp,qc given in Example 11.2 and the PTG-based codes CC-N B P B and
CU-N B P B reported in [15, 36] over the binary-input AWGNC; and (b) the
protograph associated with the base matrix Bq,ptg in Example 11.2.
The BLER performances of the code Cq,sp,qc decoded with 50 and 100
iterations of the FFT-QSPA [5] (see Appendix C) are shown in Fig. 11.2(a). This
code was simulated on the binary-input AWGNC. Each 256-ary code symbol is
represented by a binary 8-tuple. We see that the decoding converges quickly. The
gap between 50 and 100 iterations is less than 0.05 dB. At a BLER around 10−6,
we see that the code Cq,sp,qc performs 0.75 dB away from the SPB.
For comparison, we also include in Fig. 11.2(b) the BLER performances of
two PTG-based 256-ary LDPC codes reported in [15, 36] of the same length
and rate as the code constructed above, which we denote by CC-N B P B and
12
12:44:57, subject to the Cambridge Core terms of use,

11.3 NB QC-SP-LDPC Codes by q-ary CPM-Dispersion
173
CU-N B P B, respectively. The subscripts “C-NBPB” and “U-NBPB” stand for
“constrained NB PTG-based” and “unconstrained NB PTG-based,” respectively.
The code CC-N B P B was constructed through scale-copy-permute operations
based on a scaled protograph, and the code CU-N B P B was constructed through
copy-scale-permute operations based on an unlabeled protograph. The Tanner
graphs of these two codes have the same cycle distributions and contain the
same number of cycles of length 8, 10, and 12 as the code Cq,sp,qc constructed
above. The code CC-N B P B is a QC code, but the code CU-N B P B is not. Both
CC-N B P B and CU-N B P B were decoded with 100 iterations of FFT-QSPA in
[15, 36]. From Fig. 11.2(a), we see that, among the three 256-ary (32,16) LDPC
codes, the QC-SP-LDPC code Cq,sp,qc slightly outperforms the codes CC-N B P B
and CU-N B P B.
From the PTG point of view, the 256-ary (32,16) QC-SP-LDPC code
constructed above can be viewed as a QC-PTG-LDPC code with the protograph
shown in Fig. 11.2(b) whose associated base matrix is given below:
Bq,ptg =
	 g0
g1
g2
g3
g4
g5
g6
g7

in which the entries are 8-tuples over GF(q) given by (11.2).
11.3 Construction of NB QC-SP-LDPC Codes Using q-ary
CPM-Dispersion
A weight-1 circulant over GF(q) is called a q-ary CPM. A q-ary CPM Q can
be obtained from a binary CPM A by replacing all the 1-entries in A by the
same nonzero element chosen from GF(q). Two q-ary CPMs of the same size are
mutually disjoint if the single nonzero components of their generators are located
at two different positions.
In the following, we present the SP-construction of NB QC-SP-LDPC codes
using the CPM-dispersion construction over an NB ﬁeld. The presentation is in
analogous to that of the binary case given Section 7.1.
Let α be a primitive element of the NB ﬁeld GF(q). Then, the q −1 powers
of α, namely, α0 = 1,α,α2,...,αq−2, give all the nonzero elements of GF(q). For
0 ≤l < q −1, we represent the element αl by a q-ary CPM of size (q −1)×(q −1)
(with both rows and columns labeled from 0 to q −2) whose generator has αl as
its single nonzero component at position l. We denote this q-ary CPM by Q(αl).
All the nonzero entries in Q(αl) are αl. It is clear that the representation of the
element αl by the q-ary CPM Q(αl) of size (q −1) × (q −1) is unique and the
mapping between αl and Q(αl) is one-to-one. This matrix representation of αl
12
12:44:57, subject to the Cambridge Core terms of use,

174
11 SP-Construction of Nonbinary LDPC Codes
is referred to as the q-ary CPM-dispersion of αl. Note that if we replace all the
nonzero entries in Q(αl) by the unit element “1” of GF(q), we obtain a binary
CPM of size (q −1) × (q −1).
Let Bq,sp = [bi, j]0≤i<m,0≤j<n be an m × n matrix over GF(q). Now, we use
this NB matrix as the base matrix for the SP-construction of an NB QC-SP-LDPC
code. We form an m × n array Hq,sp,qc(q −1,q −1) of q-ary CPMs and/or ZMs
of size (q −1) × (q −1) from Bq,sp as follows: (1) If bi, j  0 and bi, j = αl,
we replace bi, j with its q-ary CPM-dispersion Q(αl); and (2) If bi, j = 0, we
replace bi, j by a ZM of size (q −1) × (q −1), i.e., Q(0) is a (q −1) × (q −1)
ZM. The array Hq,sp,qc(q −1,q −1) is called the q-ary CPM-dispersion of
the base matrix Bq,sp. The null space of Hq,sp,qc(q −1,q −1) gives a q-ary
QC-SP-LDPC code Cq,sp,qc of length n(q −1), called a q-ary CPM-QC-SP-LDPC
code. The above method for constructing q-ary CPM-QC-SP-LDPC code is called
the q-ary CPM-dispersion (CPM-D) construction, which is a deterministic NB
SP-construction.
The above CPM-D construction of a q-ary CPM-QC-SP-LDPC code reduces
to the construction of its base matrix Bq,sp over GF(q). For such a q-ary
CPM-QC-SP-LDPC code, the girth of its Tanner graph is related to the choice of
the base matrix Bq,sp. In Section 7.2, two theorems (Theorems 7.1 and 7.2) were
given, which give the necessary and sufﬁcient conditions on the base matrix for
the Tanner graph of a binary CPM-QC-SP-LDPC code to have girth at least 6 and
8. These two theorems also apply to q-ary CPM-QC-SP-LDPC codes constructed
using q-ary CPM-D construction.
In the CPM-D construction of a q-ary CPM-QC-SP-LDPC code, the 2 × 2 and
the 3 × 3 SM-constraints given in Theorems 7.1 and 7.2 are used to construct a
base matrix. All the methods presented in Chapter 7 can be applied to construct
NB SP-base matrices.
Example 11.3. Consider the ﬁeld GF(26). Let α be a primitive element of GF(26).
Using this ﬁeld, we can construct a 63×63 matrix B∗
q,sp,p over GF(26) in the form
given by (8.1) which satisﬁes the 2 × 2 SM-constraint. Take the following 4 × 8
submatrix Bq,sp (avoiding the 0-entry) from B∗
q,sp,p as an SP-base matrix for the
code construction:
Bq,sp=
⎡
⎢⎢⎣
α35
α52
α23
α33
α47
α27
α56
α59
α2
α35
α52
α23
α33
α47
α27
α56
α25
α2
α35
α52
α23
α33
α47
α27
α61
α25
α2
α35
α52
α23
α33
α47
⎤
⎥⎥⎦.
(11.3)
12
12:44:57, subject to the Cambridge Core terms of use,

11.4 NB QC-SP-LDPC Codes by B-to-NB Replacement
175
Next, we mask Bq,sp with the 4 × 8 masking matrix Z given by (7.5) (or (4.7)),
i.e.,
Z =
⎡
⎢⎢⎣
1
0
1
0
1
1
1
1
0
1
0
1
1
1
1
1
1
1
1
1
1
0
1
0
1
1
1
1
0
1
0
1
⎤
⎥⎥⎦.
After masking, we obtain a 4 × 8 masked base matrix:
Bq,sp,mask =
⎡
⎢⎢⎣
α35
0
α23
0
α47
α27
α56
α59
0
α35
0
α23
α33
α47
α27
α56
α25
α2
α35
α52
α23
0
α47
0
α61
α25
α2
α35
0
α23
0
α47
⎤
⎥⎥⎦,
(11.4)
which has row and column weights 3 and 6, respectively. The masked base
matrix Bq,sp,mask satisﬁes the 3 × 3 SM-constraint. The 64-ary CPM-dispersion
of Bq,sp,mask gives a 4 × 8 array Hq,sp,qc,mask(63,63) of 64-ary CPMs and ZMs
of size 63 × 63 which is a 252 × 504 matrix over GF(26) with column weight
3 and row weight 6. The null space of the array Hq,sp,qc,mask(63,63) gives
a 64-ary (3,6)-regular (504,252) CPM-QC-SP-LDPC code Cq,sp,qc,mask. The
Tanner graph of Cq,qc,mask has girth 8 and contains 819 cycles of length 8 and
12348 cycles of length 10.
The BLER performance of the code Cq,sp,qc,mask decoded with 50 iterations
of the FFT-QSPA over the binary-input AWGNC is shown in Fig. 11.3. We see
that at a BLER of 10−6, Cq,sp,qc,mask performs about 1.6 dB away from the SPB.
Also included in this ﬁgure is the BLER performance of a 64-ary LDPC code
Cq,peg constructed based on the PEG algorithm, which is not QC. The code Cq,peg
is an irregular code which has column weight 3 and average row weight 6. Its
Tanner graph also has girth 8 and contains 945 cycles of length 8 and 11655 cycles
of length 10. We decode this PEG code using the FFT-QSPA with 50 iterations.
Fig. 11.3 shows that the code Cq,sp,qc,mask performs just as well as the PEG code
Cq,peg.
11.4 CPM-D Construction of NB CPM-QC-SP-LDPC Codes Using
Binary-to-Nonbinary Replacement
Using the CPM-D construction method to construct NB CPM-QC-SP-LDPC
codes directly as presented above, there is a constraint on the size of CPMs.
If we desire a large CPM size, we have to use a large ﬁeld. This will result in
high decoding complexity. To resolve this problem, we can combine the CPM-D
12
12:44:57, subject to the Cambridge Core terms of use,

176
11 SP-Construction of Nonbinary LDPC Codes
0.5
0.75
1
1.25
1.5
1.75
2
2.25
2.5
2.75
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER
Eb/N0(dB)
64−ary (504,252) Cq,sp,qc,mask
64−ary (504,252) Cq,peg
64−ary (504,252) SPB
Figure
11.3. The
BLER
performances
of
the
64-ary
(504,252)
CPM-SP-QC-LDPC code Cq,sp,qc,mask and the PEG code Cq,peg given in
Example 11.3 over the binary-input AWGNC.
method with a binary-to-NB (B-to-NB) replacement method to construct NB
CPM-QC-SP-LDPC codes whose parity-check arrays consist of large CPMs over
small ﬁelds.
First, a chosen base matrix Bq,sp = [bi, j]0≤i<m,0≤j<n over GF(q) is dispersed
into an m × n array Hb,sp,qc(q −1,q −1) = [Ai, j]0≤i<m,0≤j<n of binary CPMs
and/or ZMs of size (q −1) × (q −1). Then, for 0 ≤i < m,0 ≤j < n, we replace
all the 1-entries in the binary CPM Ai, j by a nonzero element from a chosen code
symbol ﬁeld GF(q⋆). The ﬁeld GF(q⋆) for code symbols can be smaller or larger
than the dispersion ﬁeld GF(q), or the same. This binary to q⋆-ary replacement
operation transforms the binary CPM Ai, j into a q⋆-ary CPM Qi, j. Applying this
binary to q⋆-ary replacement to each binary CPM in the array Hb,sp,qc(q −1,
q −1), we obtain an m × n array Hq⋆,sp,qc(q −1,q −1) = [Qi, j]0≤i<m,0≤j<n of
q⋆-ary CPMs and/or ZMs of size (q −1)×(q −1). The null space of Hq⋆,sp,qc(q −
1,q −1) gives a q⋆-ary CPM-QC-SP-LDPC code Cq⋆,sp,qc.
Using Hb,sp,qc(q −1,q −1) as the binary base array and the B-to-NB replace-
ment for the code construction, we can construct an NB CPM-QC-SP-LDPC
code over any ﬁnite ﬁeld, large or small. For simplicity, we call this combined
construction method the CPM-bD/B-to-NB construction, where the symbol “bD”
denotes “binary dispersion.” Using the CPM-bD/B-to-NB construction method,
12
12:44:57, subject to the Cambridge Core terms of use,

11.4 NB QC-SP-LDPC Codes by B-to-NB Replacement
177
we can construct a base array of binary CPMs of large size and then use a small
code symbol ﬁeld as the B-to-NB replacement ﬁeld to construct a parity-check
array of NB CPMs over a small ﬁeld. The replacement of the 1-entries of
a binary CPM by a nonzero element from another ﬁeld may be considered
as another superposition operation. Hence, the above construction of an NB
CPM-QC-SP-LDPC code may be regarded as a double SP-construction. In fact,
if we disperse each nonzero entry in Hq⋆,sp,qc(q −1,q −1) into either a binary or
a q⋆-ary CPM of size (q⋆−1)×(q⋆−1), we obtain a larger array of CPMs and/or
ZMs of size (q⋆−1) × (q⋆−1). The CPM-bD/B-to-NB construction method is
very ﬂexible for constructing both binary and NB CPM-QC-SP-LDPC codes.
Example 11.4. In this example, we use the CPM-bD/B-to-NB construction
method to construct an 8-ary (2376,1188) CPM-QC-SP-LDPC code. Based on
the prime ﬁeld GF(199), we can construct a 198 × 198 base matrix B∗
q,sp,p over
GF(199) in the form given by (8.1) which satisﬁes the 2 × 2 SM-constraint. We
take a 6 × 12 submatrix Bq,sp from B∗
q,sp,p (avoiding the 0-entries):
Bq,sp =
⎡
⎢⎢⎢⎢⎢⎢⎣
α184
α85
α71
α133
α13
α162 α140
α94
α79
α192
α42
α178
α98
α101
α48
α67
α130
α83
α169 α185
α34
α57
α107
α30
α156
α46
α26
α102
α22
α40
α64
α193
α21
α28
α137 α108
α43
α51
α19
α177 α194
α93
α164 α120
α4
α139
α15
α180
α141 α153 α150
α12
α73
α17
α110
α52
α172
α82
α69
α183
α131
α76
α72
α152 α181
α32
α70
α186
α77
α119
α95
α127
⎤
⎥⎥⎥⎥⎥⎥⎦
.
(11.5)
Since B∗
q,sp,p satisﬁes the 2×2 SM-constraint, Bq,sp, as a submatrix of B∗
q,sp,p,
also satisﬁes the 2 × 2 SM-constraint. Next, we design a masking matrix to
mask Bq,sp to obtain a masked base matrix that additionally satisﬁes the 3 × 3
SM-constraint. To achieve this, we use the PEG algorithm given in [44] to
construct a 6 × 12 binary matrix Z with average column weight 2.5 as follows:
Z =
⎡
⎢⎢⎢⎢⎢⎢⎣
1
0
1
0
1
0
1
1
0
0
0
0
0
1
0
1
0
1
1
1
0
0
0
0
1
0
1
0
0
1
0
0
1
1
0
0
0
1
0
1
1
0
0
0
1
1
0
0
1
0
0
1
1
0
0
0
0
0
1
1
0
1
1
0
0
1
0
0
0
0
1
1
⎤
⎥⎥⎥⎥⎥⎥⎦
.
(11.6)
Note that every 3×3 submatrix of Z contains at least one zero entry. By masking
Bq,sp with the masking matrix Z given by (11.6), we obtain the following 6 × 12
12
12:44:57, subject to the Cambridge Core terms of use,

178
11 SP-Construction of Nonbinary LDPC Codes
masked base matrix Bq,sp,mask in which every 3 × 3 submatrix contains at least
one zero element:
Bq,sp,mask =
⎡
⎢⎢⎢⎢⎢⎢⎣
α184
0
α71
0
α13
0
α140
α94
0
0
0
0
0
α101
0
α67
0
α83
α169
α185
0
0
0
0
α156
0
α26
0
0
α40
0
0
α21
α28
0
0
0
α51
0
α177
α194
0
0
0
α4
α139
0
0
α141
0
0
α12
α73
0
0
0
0
0
α69
α183
0
α76
α72
0
0
α32
0
0
0
0
α95
α127
⎤
⎥⎥⎥⎥⎥⎥⎦
.
(11.7)
By checking, we ﬁnd that Bq,sp,mask satisﬁes both the 2 × 2 and the 3 × 3
SM-constraints. The binary CPM-dispersion of Bq,sp,mask gives a 6 × 12 array
Hb,sp,qc,mask(198,198) of binary CPMs and ZMs of size 198 × 198. This
array Hb,sp,qc,mask(198,198) is a 1188 × 2376 matrix over GF(2) with average
column weight 2.5. Since the base matrix Bq,sp,mask satisﬁes the 2 × 2 and
the 3 × 3 SM-constraints, it follows from Theorem 7.2 that the Tanner graph
Gb,sp,qc,mask(198,198) associated with the binary array Hb,sp,qc,mask(198,198)
has girth at least 8. Using the cycle counting algorithm presented in [71], we ﬁnd
that the Tanner graph Gb,sp,qc,mask(198,198) has girth 8 and contains 396 cycles
of length eight, 594 cycles of length 10, and 3762 cycles of length 12.
Suppose we use the array Hb,sp,qc,mask(198,198) as the binary base array
and choose the ﬁeld GF(23) as the code symbol ﬁeld for constructing an 8-ary
CPM-QC-SP-LDPC code with the CPM-bD/B-to-NB construction. Replacing
all the entries in each CPM in Hb,sp,qc,mask(198,198) with a nonzero ele-
ment which is chosen at random from GF(23), we obtain a 6 × 12 array
Hq⋆,sp,qc,mask(198,198) of 8-ary CPMs and ZMs of size 198 × 198. Each
row-block of Hq⋆,sp,qc,mask(198,198) consists of ﬁve CPMs and seven ZMs. The
generators of the 8-ary CPMs in each row-block of Hq⋆,sp,qc,mask(198,198) are
given in Table 11.1, each speciﬁed by a pair ( j,βs) with 0 ≤j < 198 and 0 ≤s < 7.
The ﬁrst component j of ( j,βs) is a number which speciﬁes the location of the
single nonzero component of the generator of a CPM and the second component
βs gives the value of this single nonzero component which is a nonzero element of
GF(23) where β is a primitive element of GF(23).
The null space over GF(23) of the array Hq⋆,sp,qc,mask(198,198) gives an
8-ary (2376,1188) CPM-QC-SP-LDPC code Cq⋆,sp,qc,mask with rate 0.5. Its
Tanner graph Gq⋆,sp,qc,mask(198,198) has the same girth and cycle distributions
as the Tanner graph Gb,sp,qc,mask(198,198) associated with the binary array
Hb,sp,qc,mask(198,198). The BLER performance of Cq⋆,sp,qc,mask decoded with
12
12:44:57, subject to the Cambridge Core terms of use,

11.4 NB QC-SP-LDPC Codes by B-to-NB Replacement
179
Table 11.1. The generators of the 8-ary CPMs of the parity-check arrays
Hq⋆,sp,qc,mask(198,198) and H⋆
q⋆,sp,qc,mask(198,198) given in Examples 11.4 and
11.5, respectively
Row
Generators of CPMs
Hq⋆,sp,qc,mask
0
(184,β0)
(71,β6)
(13,β4)
(140,β0)
(94,β1)
1
(101, β3)
(67, β6)
(83, β6)
(169, β1)
(185, β6)
2
(156, β6)
(26, β3)
(40, β5)
(21, β0)
(28, β2)
3
(51, β6)
(177, β4)
(194, β6)
(4, β4)
(139, β0)
4
(141, β5)
(12, β6)
(73, β4)
(69, β5)
(183, β5)
5
(76, β2)
(72, β4)
(32, β1)
(95, β4)
(127, β0)
H⋆
q⋆,sp,qc,mask
0
(184, β5)
(71, β1)
(13, β3)
(140, β4)
(94, β6)
1
(48, β6)
(130, β3)
(169, β0)
(185, β1)
(34, β1)
2
(26, β5)
(22, β1)
(193, β5)
(137, β1)
(108, β6)
3
(194, β2)
(164, β1)
(120, β1)
(180, β4)
(74, β3)
4
(73, β2)
(52, β5)
(172, β4)
(176, β3)
(53, β6)
5
(70, β2)
(186, β5)
(95, β5)
(179, β2)
(141, β3)
80 iterations of the FFT-QSPA over the binary-input AWGNC is shown in
Fig. 11.4. At a BLER of 3 × 10−5, the code Cq⋆,sp,qc,mask performs about 0.75
dB away from the SPB.
For comparison, we construct an 8-ary (2376,1188) LDPC code Cq,peg using
the PEG algorithm and also decode it with 80 iterations of the FFT-QSPA. The
parity-check matrix of Cq,peg has the same column and row weight distributions as
the CPM-QC-SP-LDPC code Cq⋆,sp,qc,mask. The Tanner graph of the code Cq,peg
has girth 12 and contains 4462 cycles of length 12 and 31382 cycles of length
14. Its BLER performance is also included in Fig. 11.4. We see that the code
Cq⋆,sp,qc,mask constructed using the CPM-bD/B-to-NB method and the PEG code
Cq,peg perform almost the same, although the PEG code has no structure.
If every symbol in GF(23) is represented by a 3-tuple over GF(2), then
the 8-ary (2376,1188) CPM-QC-SP-LDPC code Cq⋆,sp,qc,mask is equivalent to
a binary (7128,3564) LDPC code. Using the PEG algorithm, we construct a
binary (7128,3564) LDPC code Cb,peg whose parity-check matrix has the same
average column weight (2.5) as the CPM-QC-SP-LDPC code Cq⋆,sp,qc,mask and
its Tanner graph has girth 14 and contains 27144 cycles of length 14. The BLER
performance of this binary PEG code decoded with 80 iterations of the SPA is also
included in Fig. 11.4. We ﬁnd that the 8-ary (2376,1188) CPM-QC-SP-LDPC
code Cq⋆,sp,qc,mask outperforms the binary (7128,3564) PEG code Cb,peg.
In Example 11.4, we chose a 6×12 submatrix Bq,sp of B∗
q,sp,p over GF(199) in
the form given by (8.1) as the base matrix for the CPM-bD/B-to-NB construction
12
12:44:57, subject to the Cambridge Core terms of use,

180
11 SP-Construction of Nonbinary LDPC Codes
0.25
0.5
0.75
1
1.25
1.5
1.75
2
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER
Eb/N0(dB)
8−ary (2376,1188) Cq
*,sp,qc,mask
8−ary (2376,1188) Cq,peg
binary (7128,3564) Cb,peg
8−ary (2376,1188) C*
q
*,sp,qc,mask
8−ary (2496,1248) Cq,qc,hlzz
8−ary (2376, 1188) SPB
8−ary (2496, 1248) SPB
Figure
11.4. The
BLER
performances
of
the
8-ary
(2376,1188)
CPM-QC-SP-LDPC code Cq⋆,sp,qc,mask, the 8-ary (2376,1188) PEG code
Cq,peg, the binary (7128,3564) LDPC code Cb,peg in Example 11.4, the
8-ary (2376,1188) C⋆
q⋆,sp,qc,mask, and the 8-ary (2496,1248) code Cq,qc,hlzz in
Example 11.5 over the binary-input AWGNC.
of an NB CPM-QC-SP-LDPC code. By masking the base matrix Bq,sp, we
constructed an NB CPM-QC-SP-LDPC code whose Tanner graph has girth 8.
There are many possible choices of 6 × 12 submatrices of B∗
q,sp,p; a different
choice with the same masking may result in a code with a larger girth or a smaller
number of short cycles, or both. This will be demonstrated in the next example.
Example 11.5. Consider the 198 × 198 base matrix B∗
q,sp,p over GF(199) given
in Example 11.4. Suppose we choose the following 6 × 12 submatrix of B∗
q,sp,p:
B⋆
q,sp =
⎡
⎢⎢⎢⎢⎢⎢⎣
α184 α85
α71
α133 α13
α162 α140 α94
α79
α192 α42
α178
α101 α48
α67
α130 α83
α169 α185 α34
α57
α107 α30
α167
α26
α102 α22
α40
α64
α193 α21
α28
α137 α108 α5
α18
α177 α194 α93
α164 α120 α4
α139 α15
α180 α74
α168 α132
α73
α17
α110 α52
α172 α82
α69
α183 α86
α170 α176 α53
α32
α70
α186 α77
α119 α95
α127 α25
α158 α92
α179 α141
⎤
⎥⎥⎥⎥⎥⎥⎦
.
(11.8)
12
12:44:57, subject to the Cambridge Core terms of use,

11.4 NB QC-SP-LDPC Codes by B-to-NB Replacement
181
The base matrix B⋆
q,sp is different from the base matrix Bq,sp chosen in
Example 11.4. Masking B⋆
q,sp with the same 6 × 12 masking matrix Z given by
(11.6), we obtain the following masked base matrix B⋆
q,sp,mask which also satisﬁes
both the 2 × 2 and the 3 × 3 SM-constraints:
B⋆
q,sp,mask =
⎡
⎢⎢⎢⎢⎢⎢⎣
α184 0
α71
0
α13
0
α140 α94 0
0
0
0
0
α48
0
α130 0
α169 α185 α34 0
0
0
0
α26
0
α22
0
0
α193 0
0
α137 α108 0
0
0
α194 0
α164 α120 0
0
0
α180 α74
0
0
α73
0
0
α52
α172 0
0
0
0
0
α176 α53
0
α70
α186 0
0
α95
0
0
0
0
α179 α141
⎤
⎥⎥⎥⎥⎥⎥⎦
.
(11.9)
The binary CPM-dispersion of B⋆
q,sp,mask gives a 6 × 12 binary array
H⋆
b,sp,qc,mask(198,198) of CPMs and ZMs of size 198 × 198. The array
H⋆
b,sp,qc,mask(198,198) has the same size and column and row weight distributions
as the binary array Hb,sp,qc,mask(198,198) constructed in Example 11.4, a 1188×
2376 matrix over GF(2).
Using the cycle counting algorithm presented in [71], we ﬁnd that the Tanner
graph G⋆
b,sp,qc,mask(198,198) associated with the array H⋆
b,sp,qc,mask(198,198)
has girth 10 and contains 396 cycles of length 10 and 4653 cycles of length
12. However, the Tanner graph Gb,sp,qc,mask(198,198) associated with the binary
array Hb,sp,qc,mask(198,198) constructed in Example 11.4 has girth 8 and
contains 396 cycles of length 8 and 594 cycles of length 10. We see that
G⋆
b,sp,qc,mask(198,198) has a larger girth and a smaller number of cycles of length
10 than the Tanner graph Gb,sp,qc,mask(198,198) constructed in Example 11.4.
This shows that the choice of a base matrix does affect the girth and cycle
distribution of the Tanner graph of the resultant code.
Replacing the 1-entries of each CPM in H⋆
b,sp,qc,mask(198,198) with nonzero
elements randomly chosen from GF(23) (random replacement), we obtain a 6 ×
12 array H⋆
q⋆,sp,qc,mask(198,198) of 8-ary CPM and ZMs of size 198 × 198. The
generators of the 8-ary CPMs in each row-block of H⋆
q⋆,sp,qc,mask(198,198) are
also given in Table 11.1, each speciﬁed by a pair ( j,βs) with 0 ≤j < 198 and
0 ≤s < 7 as described in Example 11.4, where β is a primitive element of GF(23).
The null space of H⋆
q⋆,sp,qc,mask(198,198) gives another 8-ary (2376,1188)
CPM-QC-SP-LDPC code C⋆
q⋆,sp,qc,mask with rate 0.5. The BLER performance
of the code C⋆
q⋆,sp,qc,mask decoded with 80 iterations of the FFT-QSPA over
the binary-input AWGNC is also included in Fig. 11.4 together with the BLER
12
12:44:57, subject to the Cambridge Core terms of use,

182
11 SP-Construction of Nonbinary LDPC Codes
performance of the code Cq⋆,sp,qc,mask constructed in Example 11.4. From this
ﬁgure, we see that the code C⋆
q⋆,sp,qc,mask outperforms Cq⋆,sp,qc,mask. At a BLER
of 3 × 10−5, the code C⋆
q⋆,sp,qc,mask performs about 0.7 dB away from the SPB.
The BLER performance of the 8-ary (2496,1248) QC-LDPC code Cq,qc,hlzz
given in [45, p.3441, Figure 2] is included in Fig. 11.4 for comparison, where the
subscript “hlzz” stands for the initial letters of the last names of the authors. The
Tanner graph of this code has girth 12 and contains 23504 cycles of length 12.
Note that the number of cycles of length 12 in the Tanner graph of Cq,qc,hlzz is
much larger than the sum of the numbers of cycles of lengths 10 and 12 in the
Tanner graph of the code C⋆
q⋆,sp,qc,mask. The code Cq,qc,hlzz is longer than the
code C⋆
q⋆,sp,qc,mask by 120 symbols. In [45], the code Cq,qc,hlzz was decoded with
80 iterations of the FFT-QSPA. From Fig. 11.4, we see that the code C⋆
q⋆,sp,qc,mask
slightly outperforms the Cq,qc,hlzz below a BLER of 10−2 even though the code
C⋆
q⋆,sp,qc,mask is shorter and the Tanner graph of the code Cq,qc,hlzz has a larger
girth. It shows that the cycle distribution plays an important role in the performance
of an LDPC code.
11.5 Algebraic Construction of NB QC-PTG-LDPC Codes
Construction of NB PTG-LDPC codes can be carried out either using the
conventional copy-and-permute approach presented in Section 3.1 or using the
decomposition-and-replacement process presented in Section 4.1.
Let Gq,ptg be a protograph with n VNs and m CNs in which the edges
are labeled with nonzero elements of an NB ﬁeld GF(q). To construct a q-ary
PTG-LDPC code using the conventional PTG-based construction method as
presented in Section 3.1, we ﬁrst design and choose an expansion factor k. Next,
we create k copies of the protograph Gq,ptg. Then, we permute the edges of copies
and connect the copies into a connected bipartite graph Gq,ptg(k,k) under the
permutation-and-connection constraint deﬁned in Section 3.1. Since the edges
of Gq,ptg are labeled with nonzero elements of GF(q), the adjacency matrix
Hq,ptg(k,k) of Gq,ptg(k,k) is an m × n array of regular matrices over GF(q) of
size k ×k. The null space of Hq,ptg(k,k) gives a q-ary PTG-LDPC code Cq,ptg of
length nk with rate at least (n −m)/n. If the constituent matrices in Hq,ptg(k,k)
are circulants, Cq,ptg is then a q-ary QC-PTG-LDPC code.
Study of NB PTG-LDPC codes is still in its early stage. Several speciﬁc methods
for constructing NB protographs can be found in [36, 15, 16], in which some short
good NB PTG-LDPC codes were given.
In the following, we give a simple example to illustrate the PTG-based
construction of an NB PTG-LDPC code and show its similarity to the construction
of a binary PTG-LDPC code.
12
12:44:57, subject to the Cambridge Core terms of use,

11.5 Algebraic Construction of NB QC-PTG-LDPC Codes
183
(a)
(b)
Figure 11.5. (a) The protograph Gq,ptg given in Example 11.6; and (b) the
bipartite graph Gq,ptg(3,3) in Example 11.6.
Example 11.6. Consider the protograph Gq,ptg with 3 VNs and 2 CNs in which
the edges are labeled with elements from GF(22) shown in Fig. 11.5(a), where α
is a primitive element in GF(22). From Fig. 11.5(a), we see that VN v0 and CN
c0 are connected by two parallel edges labeled by 1 and α, respectively. Suppose
we take 3 copies of Gq,ptg, permute the edges among the copies, and connect them
under the permutation-and-connection constraint as presented in Section 3.1. We
obtain a connected bipartite graph Gq,ptg(3,3) with 9 VNs and 6 CNs shown in
Fig. 11.5(b). Gq,ptg(3,3) contains no parallel edge and has girth 6. The adjacency
matrix Hq,ptg(3,3) of Gq,ptg(3,3) is a 6 × 9 RC-constrained matrix over GF(22)
given below:
Hq,ptg(3,3) =
⎡
⎢⎢⎢⎢⎢⎢⎣
1
α
0
0
α
0
0
0
0
0
1
α
0
0
α
0
0
0
α
0
1
α
0
0
0
0
0
0
0
α2
0
0
0
α
0
0
α2
0
0
0
0
0
0
α
0
0
α2
0
0
0
0
0
0
α
⎤
⎥⎥⎥⎥⎥⎥⎦
.
Since Hq,ptg(3,3) is a 2×3 array of circulants and ZMs of size 3×3, its null space
gives a 4-ary (9,6) QC-PTG-LDPC code which is the same code constructed using
the SP-construction in Example 11.1.
An NB QC-PTG-LDPC code can be constructed algebraically in a similar
way to the algebraic construction of a binary QC-PTG-LDPC code based on the
decomposition of the base matrix associated with a chosen protograph as presented
12
12:44:57, subject to the Cambridge Core terms of use,

184
11 SP-Construction of Nonbinary LDPC Codes
in Section 4.1. The difference is that the decomposition base matrix is not a matrix
over nonnegative integers, but a matrix whose entries are sets of elements from an
NB ﬁeld.
The construction starts with a protograph Gq,ptg with n VNs and m CNs
in which the edges are labeled with nonzero elements from GF(q). Let V =
{v0,v1,...,vn−1} and C = {c0,c1,...,cm−1} denote the sets of n VNs and m CNs,
respectively. For 0 ≤i < m and 0 ≤j < n, let λi, j denote the number of edges
connecting the CN ci and the VN v j. If λi, j = 0, then ci and v j are not connected.
If λi, j  0, the λi, j parallel edges connecting ci and v j are labeled by a set Si, j of
λi, j nonzero elements in GF(q). The elements in Si, j are not necessarily different,
i.e., two different parallel edges connecting ci and v j may be labeled by the same
nonzero element in GF(q).
An adjacency matrix Bq,ptg of the protograph Gq,ptg may be constructed as
follows. It is an m × n matrix in which the entry at location (i, j) is the set Si, j.
Hence, Bq,ptg is an m × n matrix whose entries are sets of elements in GF(q)
shown below:
Bq,ptg =
⎡
⎢⎢⎢⎣
S0,0
S0,1
···
S0,n−1
S1,0
S1,1
···
S1,n−1
...
...
...
...
Sm−1,0
Sm−1,1
···
Sm−1,n−1
⎤
⎥⎥⎥⎦.
(11.10)
In the following, we present an algebraic construction of an NB QC-PTG-LDPC
code based on the adjacency matrix Bq,ptg of the protograph Gq,ptg deﬁned by
(11.10), instead of the protograph itself, We call Bq,ptg the the decomposition base
matrix.
Similar to the algebraic construction of a binary QC-PTG-LDPC code presented
in Section 4.1, we ﬁrst decompose Bq,ptg into k constituent matrices D0, D1, ...,
Dk−1 over GF(q) of size m ×n. In the decomposition of the base matrix Bq,ptg, we
distribute the elements of each non-empty entry-set Si, j among the k constituent
matrices D0, D1, ..., Dk−1 in such as way that for 0 ≤i < m and 0 ≤j < n,
the λi, j elements in the entry-set Si, j are put in different constituent matrices
at location (i, j) and the other k −λi, j (i, j)-th locations get zeros. With this
constraint on the distributions of the elements of each entry-set in Bq,ptg, each
constituent matrix De is an m ×n matrix whose entries are elements in GF(q). The
above constraint on the decomposition of the base matrix Bq,ptg is also called the
decomposition constraint and the parameter k is called the decomposition factor.
In the decomposition of Bq,ptg, ZMs are allowed, i.e., there may be ZMs among
the matrices D0, D1, ..., Dk−1. Therefore, for 0 ≤e < k, each matrix De is either
an m ×n nonzero matrix over GF(q) or an m ×n ZM. To satisfy the decomposition
12
12:44:57, subject to the Cambridge Core terms of use,

11.5 Algebraic Construction of NB QC-PTG-LDPC Codes
185
constraint, the decomposition factor k must be equal to or larger than the size of
the largest entry-set Si, j in the decomposition base matrix Bq,ptg.
The base matrix Bq,ptg can be reconstructed from its constituent matrices
D0, D1, ..., Dk−1 by grouping the nonzero entries at location (i, j)s of these
constituent matrices into the entry-set Si, js in Bq,ptg for 0 ≤i < m and 0 ≤j < n.
(Note that in grouping, zero-entries in D0, D1, ..., Dk−1 are not included in the
reconstruction of each entry-set of Bq,ptg.)
Next, we arrange the k matrices D0, D1, ..., Dk−1 in a row-block [D0 D1 ...
Dk−1], then cyclically shift this row-block k −1 times, each time n positions (or
one constituent matrix) to the right. Placing these k row-blocks on the top of each
other results in a k ×k array Hq,ptg,cyc(m,n) of m ×n matrices over GF(q) with a
block-cyclic structure in the form given by (4.1). The row-block [D0 D1 ... Dk−1]
is the generator row-block of the block-cyclic array Hq,ptg,cyc(m,n).
Now, we perform the row and column permutations πrow and πcol deﬁned by
(4.3) and (4.5) to convert the q-ary array Hq,ptg,cyc(m,n) into an m × n array
Hq,ptg,qc(k,k) of k×k circulants over GF(q) in the form given by (4.6), duplicated
as follows:
Hq,ptg,qc(k,k) =
⎡
⎢⎢⎢⎣
Q0,0
Q0,1
···
Q0,n−1
Q1,0
Q1,1
···
Q1,n−1
...
...
...
...
Qm−1,0
Qm−1,1
···
Qm−1,n−1
⎤
⎥⎥⎥⎦.
(11.11)
The generators of the constituent circulants in the q-ary array Hq,ptg,qc(k,k) can
be determined directly from the constituent matrices of the generator row-block
[D0 D1 ... Dk−1] of the q-ary block-cyclic array Hq,ptg,cyc(m,n), in the
same manner as for the binary array Hptg,qc(k,k) given by (4.6), described in
Section 4.1 (or Section 11.2). Each of these generators is a k-tuple over GF(q).
Let Gq,ptg,qc(k,k) be the Tanner graph associated with Hq,ptg,qc(k,k). Then,
the graph Gq,ptg,qc(k,k) is an expansion of the protograph Gq,ptg by a factor of
k. In the decomposition of the base matrix Bq,ptg, if we impose the RC- and the
PW-RC-constraints on its constituent matrices D0,D1,...,Dk−1 and arrange them
in a proper order (as described in Section 4.2), Gq,ptg,qc(k,k) has girth at least 6.
The null space of Hq,ptg,qc(k,k) gives a q-ary QC-PTG-LDPC code, denoted by
Cq,ptg,qc.
The following simple example illustrates the basic idea of the above algebraic
construction method for q-ary QC-PTG-LDPC codes.
Example 11.7. Let α be a primitive element of GF(22). The set {0,1,α,α2} gives
all the elements of GF(22). Suppose we choose the following 2 × 4 matrix over
12
12:44:57, subject to the Cambridge Core terms of use,

186
11 SP-Construction of Nonbinary LDPC Codes
Figure 11.6. The protograph Gq,ptg of the decomposition base matrix Bq,ptg given
in Example 11.7.
GF(22) as the decomposition base matrix:
Bq,ptg =
	 1
1
α
α2
α2
α
α
1

.
The protograph Gq,ptg associated with Bq,ptg is shown in Fig. 11.6. Choose
the decomposition factor k = 3. Suppose we decompose Bq,ptg into the following
three 2 × 4 matrices over GF(22):
D0 =
	 1
0
0
0
0
α
0
0

,D1 =
	 0
1
α
0
α2
0
0
0

,D2 =
	 0
0
0
α2
0
0
α
1

.
Based on these three constituent matrices, we form the following 3 × 3 array
Hq,ptg,cyc(2,4) of 2 × 4 matrices over GF(22) with a block-cyclic structure:
Permuting the columns and the rows of Hq,ptg,cyc(2,4) based on the row and
column permutations deﬁned by (4.3) and (4.5), we obtain the following 2 × 4
12
12:44:57, subject to the Cambridge Core terms of use,

11.5 Algebraic Construction of NB QC-PTG-LDPC Codes
187
array Hq,ptg,qc(3,3) of circulants of size 3 × 3 over GF(22):
Hq,ptg,qc(3,3)
=
	 Q0,0
Q0,1
Q0,2
Q0,3
Q1,0
Q1,1
Q1,2
Q1,3

The null space of Hq,ptg,qc(3,3) gives a 4-ary (12,6) QC-PTG-LDPC code
whose Tanner graph has girth 8.
Example 11.8. Suppose we want to construct a 256-ary QC-PTG-LDPC code
of symbol length 32 using the following 2 × 4 decomposition base matrix over
GF(28):
Bq,ptg = [bi, j]0≤i<2,0≤j<4 =
	 α61
α106
α240
α125
α229
α94
α199
α99

where α is a primitive element of GF(28). The above base matrix is chosen at
random. The protograph associated with Bq,ptg is shown in Fig. 11.7(a). Choose
the decomposition factor k = 8. Decompose Bq,ptg into the following eight 2 × 4
constituent matrices over GF(28):
D0 = D1 = D2 = D4 =
	 0
0
0
0
0
0
0
0

,
D3 =
	 0
0
α240
0
0
0
α199
0

,D5 =
	 0
α106
0
0
0
α94
0
0

,
D6 =
	 α61
0
0
0
α229
0
0
0

,D7 =
	 0
0
0
α125
0
0
0
α99

.
Next, we construct a 2×4 parity-check array Hq,ptg,qc(8,8)= [Qi, j]0≤i<2,0≤j<4
directly by ﬁnding its eight 256-ary CPMs of size 8 × 8. First, we determine the
generators of these 256-ary CPMs from the constituent matrices, D0 to D7, which
12
12:44:57, subject to the Cambridge Core terms of use,

188
11 SP-Construction of Nonbinary LDPC Codes
are:
g0,0 = (0,0,0,0,0,0,α61,0),
g0,1 = (0,0,0,0,0,α106,0,0),
g0,2 = (0,0,0,α240,0,0,0,0),
g0,3 = (0,0,0,0,0,0,0,α125),
g1,0 = (0,0,0,α229,0,0,0,0),
g1,1 = (0,0,0,0,0,0,0,α94),
g1,2 = (0,0,0,0,0,0,α199,0),
g1,3 = (0,0,0,0,0,α99,0,0).
Based on these generators, we construct eight 256-ary CPMs of size 8×8, Qi, j’s
with 0 ≤i < 2 and 0 ≤j < 4. Then, we replace each entry bi, j in the base matrix
Bq,ptg by its corresponding 256-ary CPM Qi, j. The replacement results in the
following 2 × 4 parity-check array of 256-ary CPMs of size 8 × 8:
Hq,ptg,qc(8,8) =
	 Q0,0
Q0,1
Q0,2
Q0,3
Q1,0
Q1,1
Q1,2
Q1,3

.
The array Hq,ptg,qc(8,8) is an 18 × 36 matrix over GF(28) with column and
row weights 2 and 4, respectively. The null space of Hq,ptg,qc(8,8) gives a
(2,4)-regular (32,16) 256-ary QC-PTG-LDPC code Cq,ptg,qc. The Tanner graph
of the code Cq,ptg,qc has girth 8 and contains 20 cycles of length 8, no cycle
of length 10, and 160 cycles of length 12. The BLER performances of the code
Cq,ptg,qc over the binary-input AWGNC decoded with 50 and 100 iterations of the
FFT-QSPA are shown in Fig. 11.7(b). The decoding converges quickly. The gap
between 50 and 100 iterations is less than 0.05 dB. From this ﬁgure, at a BLER
around 10−6, we see that the code Cq,ptg,qc performs 0.75 dB away from the SPB.
For comparison, we include two other 256-ary codes reported in [16, 36] in
Fig. 11.7(b), denoted by CC-N B P B and CU-N B P B, respectively. The subscripts
“C-NBPB” and “U-NBPB” stand for “constrained NB protograph-based” and
“unconstrained NB protograph-based,” respectively. The code CC-N B P B is
constructed through scale-copy-permute operations based on a scaled protograph
[16, 36], and the code CU-N B P B is constructed through copy-scale-permute
operations based on an unlabeled protograph [16, 36]. The Tanner graphs of these
two codes have the same cycle distributions and contain the same number of cycles
of lengths 8, 10, and 12 as the proposed code Cq,ptg,qc. The code CC-N B P B is in
QC-form, but the code CU-N B P B is not in QC-form. The BLER performances
of the two codes CC-N B P B and CU-N B P B were decoded with 100 iterations
of FFT-QSPA in [16, 36]. From Fig. 11.7(b), we see that the code Cq,ptg,qc
constructed algebraically based on the base matrix Bq,ptg slightly outperforms the
codes CC-N B P B and CU-N B P B in the simulation region.
12
12:44:57, subject to the Cambridge Core terms of use,

11.5 Algebraic Construction of NB QC-PTG-LDPC Codes
189
(a)
1.75
2
2.25
2.5
2.75
3
3.25
3.5
3.75
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
(b)
−1
BLER
Eb/N0(dB)
256−ary (32,16) Cq,sp,qc,itr50
256−ary (32,16) Cq,sp,qc, itr100
256−ary (32,16) CC−NBPB,itr100
256−ary (32,16) CU−NBPB,itr100
256−ary (32,16) SPB
Figure 11.7. (a) The protograph Gq,ptg of the decomposition base matrix Bq,ptg
given in Example 11.8; and (b) the BLER performances of the 256-ary (32,16)
QC-PTG-LDPC code Cq,ptg,qc given in Example 11.8 and the PTG-based codes
CC-N B P B and CU-N B P B reported in [16, 36] over the binary-input AWGNC.
In the above example, we consider a base matrix Bq,ptg whose entries are
sets of elements of GF(q), each set consisting of only one component. In the
next example, we consider a base matrix Bq,ptg consisting of entry-sets, each
containing more than one element in GF(q).
12
12:44:57, subject to the Cambridge Core terms of use,

190
11 SP-Construction of Nonbinary LDPC Codes
Example 11.9. Consider the following 3 × 9 base matrix over GF(23) in the form
of (11.10):
Bq,ptg =
⎡
⎣
0
{α5}
{α6}
0
{α3}
{α5,α6}
{1}
{α2}
{α}
{α3}
0
{α}
{α,α3}
0
{α}
{α5}
{α4}
{α2}
{α4}
{α5}
0
{α6}
{1,α6}
0
{α}
{α}
{α2}
⎤
⎦,
(11.12)
where α is a primitive element of GF(23). The protograph Gq,ptg associated with
the base matrix Bq,ptg is shown in Fig. 11.8(a). There are parallel edges in Gq,ptg
and each edge is labeled by a nonzero element from GF(23).
Choose the decomposition factor k = 60 and decompose the base matrix Bq,ptg
into 60 RC- and PW-RC-constrained constituent matrices D0, D1, ..., D59, each
of size 3× 9. Using the row-block [D0 D1 ... D59] as the generator row-block, we
obtain a 60 × 60 block-cyclic array Hq,ptg,cyc(3,9) over GF(23) of submatrices
of size 3 × 9. Perform row and column permutations πrow and πcol deﬁned by
(4.3) and (4.5) on the array Hq,ptg,cyc(3,9). Then, we obtain a 3 × 9 array
Hq,ptg,qc(60,60) over GF(23) of circulants and ZMs of size 60 × 60 in the form
of (11.11):
Hq,ptg,qc(60,60)=
⎡
⎣
O
Q0,1
Q0,2
O
Q0,4
Q0,5
Q0,6
Q0,7
Q0,8
Q1,0
O
Q1,2
Q1,3
O
Q1,5
Q1,6
Q1,7
Q1,8
Q2,0
Q2,1
O
Q2,3
Q2,4
O
Q2,6
Q2,7
Q2,8
⎤
⎦,
where O is a 60 × 60 ZM. The generators of circulants in Hq,ptg,qc(60,60) are
given in Table 11.2, each speciﬁed by a pair ( j,αs) or two pairs, ( j,αs) and
( j′,αs′), with 0 ≤j, j′ < 60 and 0 ≤s,s′ < 7 as described in Example 11.4.
The array Hq,ptg,qc(60,60) is a 180 × 540 matrix over GF(23) and it has average
column weight 2.667 and constant row weight 8. Its null space gives an 8-ary
(540,360) QC-PTG-LDPC code Cq,ptg,qc with rate 2/3. The Tanner graph of the
code Cq,ptg,qc has girth 8 and contains 3980 cycles of length 8 and 30720 cycles
of length 10. The BLER performance of the code Cq,ptg,qc over the binary-input
AWGNC decoded with 80 iterations of the FFT-QSPA is shown in Fig. 11.8(b). At
a BLER of 10−4, the code performs about 0.8 dB away from the SPB.
For comparison, we construct an 8-ary (540,360) LDPC code Cq,peg using
the PEG algorithm and also decode it with 80 iterations of the FFT-QSPA.
The parity-check matrix of Cq,peg has the same average column weight as the
QC-PTG-LDPC code Cq,ptg,qc. The Tanner graph of the code Cq,peg has girth 8
and contains 3685 cycles of length 8 and 29268 cycles of length 10. Its BLER
12
12:44:57, subject to the Cambridge Core terms of use,

11.5 Algebraic Construction of NB QC-PTG-LDPC Codes
191
Table 11.2. The generators of the circulants of the parity-check arrays Hq,ptg,qc(60,60)
and Hq,ptg,qc(120,120) given in Example 11.9
Generators of circulants in Hq,ptg,qc(60,60)
i
Qi,0
Qi,1
Qi,2
Qi,3
Qi,4
Qi,5
Qi,6
Qi,7
Qi,8
0
—
(0,α5)
(1,α6)
—
(13,α3)
(2,α5)
(15,α0)
(14,α2) (16,α)
(11,α6)
1
(1,α3)
—
(13,α)
(0,α)
—
(15,α)
(9,α5)
(4,α4)
(7,α2)
(2,α3)
2
(4,α4)
(14,α5)
—
(6,α6)
(1,α0)
—
(16,α)
(17,α)
(2,α2)
(15,α6)
Generators of circulants in Hq,ptg,qc(120,120)
i
Qi,0
Qi,1
Qi,2
Qi,3
Qi,4
Qi,5
Qi,6
Qi,7
Qi,8
0
—
(0,α5)
(1,α6)
—
(13,α3)
(2,α5)
(15,α0)
(14,α2) (16,α)
(11,α6)
1
(1,α3)
—
13,α)
(0,α)
—
(15,α)
(9,α5)
(4,α4)
(7,α2)
(2,α3)
2
(4,α4)
(14,α5)
—
(6,α6)
(1,α0)
—
(16,α)
(17,α)
(2,α2)
(15,α6)
performance is also included in Fig. 11.8(b). We see that the QC-PTG-LDPC code
Cq,ptg,qc and the PEG code Cq,peg perform almost the same, although the PEG
code has no structure.
If we choose the decomposition factor k = 120 and use the same decom-
position base matrix Bq,ptg given by (11.12), then we can construct an 8-ary
(1080,720) QC-PTG-LDPC code C⋆
q,ptg,qc with rate 2/3. The parity-check array
Hq,ptg,qc(120,120) of this code is a 3 × 9 array of 8-ary cirulants and ZMs of
size 120 × 120 and has the same column and row weight distributions as the array
Hq,ptg,qc(60,60) constructed above. The Tanner graph of C⋆
q,ptg,qc has girth 8
and contains 7920 cycles of length 8 and 59400 cycles of length 10. Its BLER
performance over the binary-input AWGNC decoded with 80 iterations of the
FFT-QSPA is shown in Fig. 11.8(b). At a BLER of 10−4, the code performs within
0.9 dB away from the SPB. An 8-ary (1080,720) LDPC code C⋆
q,peg constructed
using the PEG algorithm is also included in Fig. 11.8(b) for comparison. From this
ﬁgure, we see that the two codes perform almost the same in the simulation region.
However, the parity-check matrix of the PEG code C⋆
q,peg has no QC-structure.
12
12:44:57, subject to the Cambridge Core terms of use,

192
11 SP-Construction of Nonbinary LDPC Codes
(a)
1.4
1.6
1.8
2
2.2
2.4
2.6
2.8
3
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
(b)
0
BLER
Eb/N0(dB)
8−ary (540,360) Cq,sp,qc
8−ary (540,360) Cq,peg
8−ary (1080, 720) C*
q,sp,qc
8−ary (1080, 720) C*
q,peg
8−ary (540,360), SPB
8−ary (1080, 720), SPB
Figure 11.8. (a) The protograph Gq,ptg of the base matrix Bq,ptg given in Exam-
ple 11.9; and (b) the BLER performances of the 8-ary (540,360) QC-PTG-LDPC
code Cq,ptg,qc, the 8-ary (540,360) PEG code Cq,peg, the 8-ary (1080,720)
QC-PTG-LDPC code C⋆
q,ptg,qc, and the 8-ary (1080,720) PEG code C⋆
q,peg given
in Example 11.9 over the binary-input AWGNC.
Construction of a base matrix Bq,ptg with set entries over an NB ﬁeld GF(q) in
the form of (11.10) can be achieved algebraically by using the construction method
based on two arbitrary subsets S0 and S1 presented in Section 7.3. Suppose we
choose S0 = S1 = GF(q) and a nonzero element η from GF(q). Using the sum-form
given by (7.1), we obtain a q × q base matrix over GF(q), denoted by Bq,ptg(η),
which is a Latin square of order q and satisﬁes the 2×2 SM-constraint. Bq,ptg(η)
is called a Latin square associated with η.
12
12:44:57, subject to the Cambridge Core terms of use,

11.6 Construction of NB LDPC Codes by RS Codes
193
Let α be a primitive element of GF(q). If we use each of the q −1
nonzero elements 1,α,α2,...,αq−2 as ηs, we obtain q −1 different Latin
squares, Bq,ptg(1), Bq,ptg(α), Bq,ptg(α2), ..., Bq,ptg(αq−2). Let Bq,ptg(αk) =
[ai, j]0≤i, j<q and Bq,ptg(αℓ) = [bi, j]0≤i, j<q be two Latin squares associated with
αk and αℓ, respectively. Suppose we combine these two Latin squares into a
q × q matrix Bq,ptg(αk,αℓ) = [(ai, j,bi, j)]0≤i, j<q whose entries are two-tuples
(ai, j,bi, j) over GF(q). All the two-tuple entries in Bq,ptg(αk,αℓ) are different. The
two Latin squares Bq,ptg(αk) and Bq,ptg(αℓ) are said to be orthogonal [73]. The
q −1 different Latin squares, Bq,ptg(1),Bq,ptg(α),Bq,ptg(α2),...,Bq,ptg(αq−2),
are mutually orthogonal.
Let λ be a positive integer less than q. Suppose we take λ mutually orthogonal
Latin squares of order q and form a q × q matrix by grouping their corresponding
entries into sets. This results in a q × q base matrix Bq,ptg with set entries of size
λ. Note that a set entry in Bq,ptg may contain a zero element. For 1 ≤m,n <
q, suppose we take an m × n submatrix Bq,ptg(m,n) from Bq,ptg and a chosen
decomposition factor k. Then, based on Bq,ptg(m,n) and k, we can construct an
m × n array Hq,ptg,qc(k,k) of k × k circulants in the form of (11.11) using the
decomposition method presented above. The null space of Hq,ptg,qc(k,k) gives
a q-ary QC-PTG-LDPC code Cq,ptg,qc. To obtain the desired column and row
weight distributions of the parity-check array Hq,ptg,qc(k,k), we can set some
entries in the entry-sets of the base matrix Bq,ptg(m,n) to zeros, i.e., adjust the
weights of the circulants in Hq,ptg,qc(k,k).
11.6 Construction of NB LDPC Codes from Reed–Solomon Codes
Reed–Solomon (RS) codes [93, 8, 74, 97] are prevalent in many communication
systems and data storage devices. They are powerful cyclic codes that can be
efﬁciently decoded using traditional algebraic hard-decision decoding methods
such as the Berlekamp–Massey algorithm (BMA) [8, 74, 97] and Euclid’s
algorithm [74]. Unfortunately, due to the high density of nonzero elements in their
conventional parity-check matrices and the large number of short cycles, especially
cycles of length 4, in their associated Tanner graphs, direct application of iterative
decoding methods based on the BP is not suitable for RS codes.
In this section, we will show that powerful NB LDPC codes can be constructed
from RS codes based on their conventional parity-check matrices using the
masking technique presented in Section 7.4. To demonstrate this, we use two RS
codes, the (255,239) and the (255,223) RS codes over GF(28). The ﬁrst code
has minimum distance 17 and can correct up to 8 random symbol errors. This
code decoded with the BMA or Euclid’s method has been widely used for many
commercial communication systems and data storage devices over the last 40 years
12
12:44:57, subject to the Cambridge Core terms of use,

194
11 SP-Construction of Nonbinary LDPC Codes
and is still being used. The second code has minimum distance 33 and can correct
up to 16 random symbol errors. It is a CCSDS standard code for satellite and deep
space communications.
Consider the (255,239) RS code over GF(28). It is a cyclic code whose generator
polynomial has α, α2, ..., α16 as roots where α is a primitive element of GF(28)
[97]. Its conventional parity-check matrix Hq,rs is expressed in terms of the roots
of its generator polynomial [97, pp. 124–125]:
Hq,rs =
⎡
⎢⎢⎢⎣
α0
α1
α2
···
α254
α0
(α2)1
(α2)2
···
(α2)254
...
...
...
...
α0
(α16)1
(α16)2
···
(α16)254
⎤
⎥⎥⎥⎦.
(11.13)
Hq,rs is a 16×255 matrix over GF(28). This parity-check matrix is not suitable
for iterative decoding, since its associated Tanner graph has girth 4 and contains
a enormously large number of cycles of length 4. Iterative BP-decoding of the
RS code based on this parity-check matrix gives a very poor error performance,
much worse than the hard-decision BMA. So far, no efﬁcient and practically
implementable iterative decoding scheme (or algorithm) has been devised for this
code. Furthermore, Hq,rs does not satisfy the 2 × 2 SM-constraint. Hence, the
Tanner graph associated with its CPM-dispersion contains a large number of cycles
of length 4 and is not suitable to construct QC-LDPC codes.
In the next example, we show that, by masking the conventional parity-check
matrix Hq,rs given by (11.13) with a properly designed 16 × 255 masking matrix,
we can construct a 256-ary (255,239) LDPC code that performs well with an
iterative BP-decoding algorithm.
Example 11.10. Let Hq,rs (given in the form of (11.13)) be the conventional
parity-check matrix of the (255,239) RS code Crs over GF(28). For masking
Hq,rs, we need a 16 × 255 masking matrix. There are many ways to construct
this masking matrix. Here, we use the 2-dimensional Euclidean geometry EG(2,5)
over the ﬁeld GF(5) for the construction. Based on the the lines in EG(2,5) not
passing through the origin, we can construct a 6 × 6 array M of binary CPMs and
ZMs of size 4×4 [46] (see Appendix A). Each row-block (or each column-block)
consists of 5 CPMs and 1 ZM of size 4×4. Take 11 arbitrary 4×6 subarrays from
M, denoted by M0, M1, ..., M10. Each of these 4 × 6 subarrays of M consists
of 4 column-blocks each having 3 CPMs and one ZM, and 2 column-blocks
each having 4 CPMs. In each column-block with 4 CPMs, we choose one CPM
randomly and replace it by a 4 × 4 ZM. By doing this, each M j of these 11
subarrays becomes a 4 × 6 subarray M⋆
j in which each column-block consists of
3 CPMs and one ZM. Arranging these eleven 4 × 6 subarrays, M⋆
0, M⋆
1, ..., M⋆
10,
12
12:44:57, subject to the Cambridge Core terms of use,

11.6 Construction of NB LDPC Codes by RS Codes
195
3.6
4
4.4
4.8
5.2
5.6
6
6.4
6.8
7.2
7.6
8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER
Eb/N0(dB)
(255,239) Crs,mask
(255,239) Crs, BMA
(255,239) Crs, KVA
(2040,1912)  Cb,peg
Shannon Limit
Figure 11.9. The BLER performances of the 256-ary (255,239) RS-masked
LDPC code Crs,mask, the 256-ary (255,239) RS code Crs decoded with the
BMA and the KVA, and the (2040,1912) binary PEG code Cb,peg given in
Example 11.10 over the binary-input AWGNC.
in a row, we obtain a 4 × 66 array M⋆= [M⋆
0 M⋆
1 ... M⋆
10] of binary CPMs and
ZMs. M⋆is a 16 × 264 matrix over GF(2). Deleting the last 9 columns from M⋆,
we obtain a 16×255 matrix Z with column weight 3, and 5 different row weights:
45, 46, 47, 48, and 49.
Masking Hq,rs with Z, we obtain a masked RS matrix Hq,rs,mask, whose null
space gives a (255,239) LDPC code Crs,mask over GF(28), called an RS-masked
LDPC code. The BLER performance of Crs,mask over the binary-input AWGNC is
shown in Fig. 11.9. Also included in Fig. 11.9 are the BLER performances of the
(255,239) RS code Crs decoded with the BMA and the K¨oetter–Vardy algebraic
soft-decision algorithm (KVA) with interpolation complexity coefﬁcient 4.99 [54].
At a BLER of 10−6, Crs,mask has 1.8 dB and 1.3 dB gains over the RS code Crs
decoded with the BMA and the KVA, respectively. The coding gains are achieved
at the expense of a higher decoding complexity.
The binary image of the 256-ary (255,239) RS-masked LDPC code Crs,mask
is a binary (2040,1912) code. For comparison, a binary (2040,1912) LDPC code
12
12:44:57, subject to the Cambridge Core terms of use,

196
11 SP-Construction of Nonbinary LDPC Codes
Cb,peg is constructed using the the PEG algorithm [43, 44], which has the the
same rate and same degree distributions of Crs,mask. The PEG code has girth 6
and contains 146250 cycles of length 6. The BLER performance of this binary
LDPC code Cb,peg over the AWGNC decoded with 50 iterations of the SPA is also
included in Fig. 11.9. We see that the curves of the two codes Crs,mask and Cb,peg
basically overlap with each other for a BLER down to 4×10−4. At a BLER lower
than 4 × 10−4, Crs,mask starts to outperform the binary PEG code Cb,peg and the
PEG code has an error-ﬂoor starting from a BLER of 5 × 10−6.
Next, we consider the CCSDS standard (255,223) cyclic RS code over GF(28).
Example 11.11. The (255,223) RS code Crs over GF(28) with minimum
distance 32 has been used by international space agencies, such as US-NASA
and ESA (European Space Agency), for space and satellite communications. Its
conventional parity-check matrix Hq,rs = [(αi) j]1≤i<≤32,0≤j≤254 is a 32 × 255
matrix over GF(28) expressed in terms of the 32 roots of its generator polynomial,
α, α2, α3, ..., α32, where α is a primitive element of GF(28). To mask the
parity-check matrix Hq,rs to produce a sparse matrix, we need a 32×255 masking
matrix over GF(2). To do so, we construct eight 32 × 32 circulants M0, M1, ...,
M7 over GF(2), each with weight 3. The generators of these eight circulants are:
g0 = (1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
g1 = (1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
g2 = (1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
g3 = (1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
g4 = (1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0),
g5 = (1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
g6 = (1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
g7 = (1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0).
Arrange these 8 circulants in a row-block to form a 32 × 256 matrix M⋆over
GF(2). Deleting the last column of M⋆, we obtain a 32×255 matrix Z with column
weight 3 but two different row weights, 23 and 24. Masking Hq,rs with Z, we
obtain a masked 32 × 255 matrix Hq,rs,mask. The null space of Hq,rs,mask gives
a 256-ary (255,223) RS-masked LDPC code Crs,mask whose BLER performance
over the binary-input AWGNC decoded with 50 iterations of the FFT-QSPA is
shown in Fig. 11.10. At a BLER of 10−5, this code achieves almost 2 dB and 1.6
dB gains over the (255,223) RS code Crs decoded with BMA, and the KVA with
interpolation complexity coefﬁcient 4.99, respectively.
12
12:44:57, subject to the Cambridge Core terms of use,

11.7 Construction of NB QC-LDPC Codes by RS Codes
197
2.6
3
3.4
3.8
4.2
4.6
5
5.4
5.8
6.2
6.6 6.8
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER
Eb/N0(dB)
(255,223) Crs,mask
(255,223)  Crs, BMA
(255,223) Crs, KVA
Shannon Limit
Figure 11.10. The BLER performances of the 256-ary (255,223) RS-masked
LDPC code Crs,mask and the 256-ary (255,223) RS code Crs decoded with BMA
and the KVA given in Example 11.11 over the binary-input AWGNC.
What we showed above is that masking is a powerful technique to construct
a good LDPC code from a parity-check matrix that is not suitable for iterative
BP-decoding. RS-masked LDPC codes over other ﬁelds of characteristic 2 can be
constructed in a similar manner.
11.7 Construction of NB QC-SP-LDPC Codes based on RS Codes
In general, the conventional parity-check matrix Hq,rs of an RS code over a ﬁeld
GF(2s) of characteristic 2 does not satisfy the 2×2 SM-constraint. However, under
a certain constraint, the parity-check matrix of an RS code over GF(2s) does satisfy
the 2×2 SM-constraint. In this case, the parity-check matrix of an RS code (or its
shortened version) can be used as a base matrix to construct a 2s-ary QC-SP-LDPC
code by 2s-ary CPM-dispersion whose Tanner graph has girth at least 6.
Let n be a factor of 2s −1 such that 2s −1 = cn with n > 1. Let ps be the smallest
prime factor of n. Let α be a primitive element of GF(2s) and let β = αc. The order
of β is n and the set {1,β,...,βn−1} forms a cyclic subgroup of GF(2s). Let d be
12
12:44:57, subject to the Cambridge Core terms of use,

198
11 SP-Construction of Nonbinary LDPC Codes
a positive integer less than or equal to ps , i.e., 1 ≤d ≤ps. Consider the (n,n −d)
RS code Crs over GF(2s) of length n with minimum distance d +1. The generator
polynomial g(X) of this RS code has β, β2, ..., βd as roots. The parity-check
matrix of this RS code in terms of the roots of its generator polynomial is given
below:
Bq,sp,rs(d,n) =
⎡
⎢⎢⎢⎣
1
β
β2
···
βn−1
1
β2
(β2)2
···
(β2)n−1
...
...
...
···
...
1
βd
(βd)2
···
(βd)n−1
⎤
⎥⎥⎥⎦.
(11.14)
Bq,sp,rs(d,n) is a d × n matrix over GF(2s). If n = 2s −1, then the code Crs
generated by Bq,sp,rs(d,n) is a primitive RS code [74, 97]. Otherwise, Crs is a
nonprimitive RS code.
Next, we prove that Bq,sp,rs(d,n) satisﬁes the 2 × 2 SM-constraint. Let i, j, k,
and l be any four nonnegative integers such that 1 ≤i < j ≤d and 0 ≤k < l < n.
Consider the following 2 × 2 submatrix B(2,2) of Bq,sp,rs(d,n):
B(2,2) =
	(αi)k
(αi)l
(α j)k
(α j)l

.
The determinant of B(2,2) is β jl+ik −β jk+il. Next, we show that β jl+ik −
β jk+il  0. Suppose β jl+ik −β jk+il = 0. Then, we must have β( j−i)(l−k) = 1.
Since j −i is a positive integer less than d ≤ps (the smallest prime factor of n)
and l −k is a positive integer less than n, the product ( j −i)(l −k) cannot be
divisible by n. Since the order of β is n and ( j −i)(l −k) is not divisible by n,
β( j−i)(l−k) cannot be equal to 1. Hence, β jl+ik – β jk+il  0 and B(2,2) must be
a nonsingular matrix. Consequently, the matrix Bq,sp,rs(d,n) satisﬁes the 2 × 2
SM-constraint.
Since Bq,sp,rs(d,n) satisﬁes the 2 × 2 SM-constraint, it or a submatrix of it can
be used as the base matrix for the SP-construction of a CPM-QC-SP-LDPC code,
binary or NB, using the CPM-D method. Dispersing each entry of Bq,sp,rs(d,n)
into a 2s-ary CPM of size (2s −1) × (2s −1), we obtain a d × n array
Hq,sp,qc,rs(2s −1,2s −1) of 2s-ary CPMs of size (2s −1)×(2s −1) which satisﬁes
the RC-constraint. It is a d(2s −1) × n(2s −1) matrix over GF(2s) with column
and row weights d and n, respectively. The null space of Hq,sp,qc,rs(2s −1,2s −1)
gives a 2s-ary CPM-QC-SP-LDPC code Cq,sp,qc,rs of length n(2s −1) whose
Tanner graph has girth at least 6. We call this code an RS-QC-SP-LDPC code
and the matrix Bq,sp,rs(d,n) an RS-base matrix.
Note that the entries in Bq,sp,rs(d,n) are elements of the cyclic subgroup
{1,β,β2,...,βn−1} of GF(2s) of order n. Dispersing each entry of Bq,sp,rs(d,n)
12
12:44:57, subject to the Cambridge Core terms of use,

11.7 Construction of NB QC-LDPC Codes by RS Codes
199
into a 2s-ary CPM of size n × n (as described in Section 2.1), we obtain a d × n
array Hq,sp,qc,rs(n,n) of 2s-ary CPMs of size n × n which also satisﬁes the
RC-constraint. It is a dn × n2 matrix over GF(2s) with column and row weights d
and n, respectively. The null space of Hq,sp,qc,rs(n,n) gives a 2s-ary (d,n)-regular
RS-QC-SP-LDPC code Cq,sp,qc,rs of length n2 whose Tanner graph has girth at
least 6.
Example 11.12. Let GF(26) be the ﬁeld for the code construction and let α be
a primitive element of GF(26). Then, 26 −1 = 63. Let n = 63. The smallest
prime factor of 63 is 3. In this case, the parity-check matrix Bq,sp,rs(3,63) of
the (63,60) RS code over GF(26) is a 3 × 63 matrix and satisﬁes the 2 × 2
SM-constraint. The 64-ary CPM-dispersion of Bq,sp,rs(3,63) gives a 3 × 63 array
Hq,sp,qc,rs(63,63) of 64-ary CPMs of size 63 × 63 which is a 189 × 3969 matrix
over GF(26) with column and row weights 3 and 63, respectively. The null space of
Hq,sp,qc,rs(63,63) gives a 64-ary (3,63)-regular (3969,3780) RS-QC-SP-LDPC
code Cq,sp,qc,rs with rate 0.9524 whose Tanner graph has girth at least 6. The
BER, SER (symbol-error rate), and BLER performances of Cq,sp,qc,rs over the
binary-input AWGNC decoded with 50 iterations of the FFT-QSPA are shown in
Fig. 11.11. At a BER of 10−7, the code performs only 0.75 dB from the Shannon
limit and at a BLER of 10−5, it performs 0.5 dB from the SPB.
For comparison, we also include the BER, SER, and BLER performances of a
64-ary (3969,3780) LDPC code Cq,peg constructed using the PEG algorithm in
Fig. 11.11. The PEG code Cq,peg has the same rate and dimension as Cq,sp,qc,rs.
Its parity-check matrix has constant column weight 3, but not in QC-form. From
Fig. 11.11, we see that the two codes perform the same.
Example 11.13. In this example, we use GF(28) as the ﬁeld for the code
construction. Factor 28 −1 = 255 as the product of 3 and 85. Set n = 85. The
smallest prime factor of 85 is 5. Let α be a primitive element of GF(28) and
let β = α5. The order of β is 85. Consider the nonprimitive (85,80) RS code
over GF(28) whose generator polynomial has β, β2, β3, β4, and β5 as roots. The
parity-check matrix Bq,sp,rs(5,85) of this RS code is a 5×85 matrix over GF(28).
Take a 3 × 85 submatrix Bq,sp,rs(3,85) from Bq,sp,rs(5,85) and use it as the
SP-base matrix for the construction of an RS-QC-SP-LDPC code. Dispersing each
entry of Bq,sp,rs(3,85) into a 256-ary CPM of size 85×85, we obtain a 3×85 array
Hq,sp,qc,rs(85,85) of 256-ary CPMs of size 85×85, which is a 255×7225 matrix
over GF(28) with column and row weights 3 and 85, respectively. The null space of
Hq,sp,qc,rs(85,85) gives a 256-ary (3,85)-regular (7225,6970) RS-QC-SP-LDPC
code Cq,sp,qc,rs with rate 0.9647. The BER, SER, and BLER performances of
Cq,sp,qc,rs over the binary-input AWGNC decoded with 50 iterations of the
12
12:44:57, subject to the Cambridge Core terms of use,

200
11 SP-Construction of Nonbinary LDPC Codes
4.2
4.4
4.6
4.8
5
5.2
5.4
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/SER/BER
Eb/N0
Cq,sp,qc,rs, BLER
Cq,sp,qc,rs, SER
Cq,peg, BER
Cq,sp,qc,rs, BLER
Cq,peg, SER
Cq,peg, BER
Shannon limit
SPB
Figure 11.11. The BER, SER, and BLER performances of the 64-ary
(3969,3780) RS-QC-SP-LDPC Cq,sp,qc,rs code and the PEG code Cq,peg given
in Example 11.12 over the binary-input AWGNC.
FFT-QSPA are shown in Fig. 11.12. At a BER of 10−6, the code performs only
0.7 dB from the Shannon limit (4.64 dB) and at a BLER of 10−4, it performs 0.53
dB from the SPB.
For comparison, we also include the BER, SER, and BLER performances of a
256-ary (7225,6970) LDPC code Cq,peg constructed using the PEG algorithm in
Fig. 11.12. The PEG code Cq,peg has the same rate and dimension as Cq,sp,qc,rs.
Its parity-check matrix has constant column weight 3, but not in QC-form. From
Fig. 11.12, we see that the RS-QC-SP-LDPC code Cq,sp,qc,rs slightly outperforms
the PEG code Cq,peg.
Now, we consider a special case. Let p be the largest prime factor of 2s −1. Then
2s −1 = cp. Let β = αc where α is a primitive element of GF(2s). Then, the order of
β is p. Let d be a positive integer such that d < p. Then, the parity-check matrix
Bq,sp,rs(d, p) of the (p, p −d) nonprimitive RS code of length p over GF(2s)
satisﬁes the 2 × 2 SM-constraint. The generator polynomial of this RS code has
12
12:44:57, subject to the Cambridge Core terms of use,

11.7 Construction of NB QC-LDPC Codes by RS Codes
201
4.7
4.8
4.9
5
5.1
5.2
5.3
5.4
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/SER/BER
Eb/N0
Cq,sp,qc,rs, BLER
Cq,sp,qc,rs, SER
Cq,sp,qc,rs, BER
Cq,peg, BLER
Cq,peg, SER
Cq,peg, BER
SPB
Figure 11.12. The BER, SER, and BLER performances of the 256-ary
(7225,6970) RS-QC-SP-LDPC code Cq,sp,qc,rs and the PEG code Cq,peg given
in Example 11.13 over the binary-input AWGNC.
β, β2, ... , βd as roots and its parity-check matrix Bq,sp,rs(d, p) is a d × p matrix
over GF(2s) speciﬁed by the d roots of the generator polynomial of the RS code.
If we disperse each entry in Bq,sp,rs(d, p) into a 2s-ary CPM of size (2s −1) ×
(2s −1), we obtain a d × p array Hq,sp,qc,rs(2s −1,2s −1) of 2s-ary CPMs of
size (2s −1)×(2s −1). The null space of Hq,sp,qc,rs(2s −1,2s −1) gives a 2s-ary
RS-QC-SP-LDPC code Cq,sp,qc,rs of length p(2s −1). If we disperse each entry
of Bq,sp,rs(d, p) into a 2s-ary CPM of size p × p, we then obtain a d × p array
Hq,sp,qc,rs(p, p) of 2s-ary CPMs of size p× p. The null space of Hq,sp,qc,rs(p, p)
gives a 2s-ary RS-QC-SP-LDPC code Cq,sp,qc,rs of length p2. For various choices
of d < p, we can construct a family of 2s-ary RS-QC-SP-LDPC codes of various
lengths and rates.
Example 11.14. Let GF(25) be the ﬁeld for the code construction and α be a
primitive element of GF(25). Since 25 −1 = 31 is a prime, then p = 31 (the largest
prime factor). Set d = 4. The parity-check matrix of a double error-correcting RS
12
12:44:57, subject to the Cambridge Core terms of use,

202
11 SP-Construction of Nonbinary LDPC Codes
code over GF(25) is a 4 × 31 matrix over GF(25) given as follows:
Bq,sp,rs(4,31) =
⎡
⎢⎢⎣
α0
α1
α2
···
α30
α0
(α2)1
(α2)2
···
(α2)30
α0
(α3)1
(α3)2
···
(α3)30
α0
(α4)1
(α4)2
···
(α4)30
⎤
⎥⎥⎦.
The null space of Bq,sp,rs(4,31) gives a (31,27) RS code over GF(25).
The 32-ary CPM-dispersion of the RS-base matrix Bq,sp,rs(4,31) gives a 4×31
array Hq,sp,qc,rs(31,31) of 32-ary CPMs of size 31 × 31 with column and row
weights 4 and 31, respectively. The null space of Hq,sp,qc,rs(31,31) gives a
(4,31)-regular 32-ary (961,840) RS-QC-SP-LDPC code of rate 0.874. Its Tanner
graph has girth 6 and contains 115320 cycles of length 6 and 8735490 cycles
of length 8. The BER, SER, and BLER performances of the code decoded with
50 iterations of the FFT-QSPA over the binary-input AWGNC are shown in
Fig. 11.13. From this ﬁgure, we see that the code can achieve a BER of 10−9
without a visible error-ﬂoor. At a BER of 10−9, the code performs within 1.76 dB
from the Shannon limit and 1.2 dB from the SPB at a BLER of 10−7.
For comparison, we also include the BER, SER, and BLER performances of
a 32-ary (961,837) LDPC code Cq,peg constructed using the PEG algorithm in
Fig. 11.13. The rate of the PEG code Cq,peg is slightly lower than that of the
code Cq,sp,qc,rs. Its parity-check matrix has constant column weight 3, but not in
QC-form. From Fig. 11.13, we see that the two codes perform the same.
Using the CPM-bD/B-to-NB construction presented in Section 11.4, we
can construct short RS-QC-SP-LDPC codes over large symbol ﬁelds or long
RS-QC-SP-LDPC codes with small symbol ﬁelds.
Example 11.15. Consider the (7,4) RS code over GF(23) whose generator
polynomial has α, α2, and α3 as roots where α is a primitive element of
GF(23). Its parity-check matrix Bq,sp,rs(3,7) is a 3 × 7 matrix over GF(23) which
satisﬁes the 2 × 2 SM-constraint. Suppose we take the binary CPM-dispersion
of Bq,sp,rs(3,7) and use the ﬁeld GF(28) for the B-to-NB replacement (random
replacement). We obtain a 3×7 array Hq,sp,qc,rs(7,7) of CPMs of size 7×7 over
GF(28) which is a 21 × 49 matrix over GF(28) with column and row weights 3
and 7, respectively. The null space of Hq,sp,qc,rs(7,7) gives a 256-ary (49,28)
RS-QC-SP-LDPC code Cq,sp,qc,rs,0, a short code over a large ﬁeld. The BER,
SER, and BLER performances of the code over the binary-input AWGNC decoded
with 50 iterations of the FFT-QSPA are shown in Fig. 11.14. At a BLER of 10−6,
the code performs about 2.1 dB away from the SPB.
For comparison, we also include the BER, SER and BLER performances of
a 256-ary (49,28) LDPC code Cq,peg,0 constructed using the PEG algorithm in
12
12:44:57, subject to the Cambridge Core terms of use,

11.7 Construction of NB QC-LDPC Codes by RS Codes
203
2.8
3
3.2
3.4
3.6
3.8
4
4.2
4.4
4.6
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/SER/BER
Eb/N0
Cq,sp,qc,rs, BLER
Cq,sp,qc,rs, SER
Cq,sp,qc,rs, BER
Cq,peg, BLER
Cq,peg, SER
Cq,peg, BER
SPB
Shannon limit
Figure 11.13. The BER, SER, and BLER performances of the 32-ary (961,840)
RS-QC-SP-LDPC code Cq,sp,qc,rs and the 32-ary (961,837) PEG code Cq,peg
given in Example 11.14 over the binary-input AWGNC.
Fig. 11.14. The rate of the PEG code Cq,peg,0 is the same as that of the code
Cq,sp,qc,rs,0. Its parity-check matrix has constant column weight 3, but not in
QC-form. From Fig. 11.14, we see that the two codes perform almost the same.
Suppose we disperse the matrices Bq,sp,rs(3,63) over GF(26) given in Exam-
ple 11.12 and Bq,sp,rs(3,85) over GF(28) given in Example 11.13 into a 3 × 63
binary array of CPMs of size 63 × 63 and a 3 × 85 binary array of CPMs of size
85 × 85, respectively. Using GF(24) as the ﬁeld for the B-to-NB replacement,
we obtain a 3 × 63 array Hq,sp,qc,rs(63,63) of 16-ary CPMs of size 63 × 63
and a 3 × 85 array Hq,sp,qc,rs(85,85) of 16-ary CPMs of size 85 × 85. The null
spaces of Hq,sp,qc,rs(63,63) and Hq,sp,qc,rs(85,85) give a 16-ary (3,63)-regular
(3969,3780) RS-QC-SP-LDPC code Cq,sp,qc,rs,1 and a 16-ary (3,85)-regular
(7225,6970) RS-QC-SP-LDPC code Cq,sp,qc,rs,2, respectively. The BER, SER
and BLER performances of the two codes Cq,sp,qc,rs,1 and Cq,sp,qc,rs,2 over the
binary-input AWGNC decoded with 50 iterations of the FFT-QSPA are shown in
Fig. 11.15 and Fig. 11.16, respectively. The 16-ary (3969,3780) code Cq,sp,qc,rs,1
12
12:44:57, subject to the Cambridge Core terms of use,

204
11 SP-Construction of Nonbinary LDPC Codes
1.5
2
2.5
3
3.5
4
4.5
5
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/SER/BER
Eb/N0
Cq,sp,qc,rs,0, BLER
Cq,sp,qc,rs,0, SER
Cq,sp,qc,rs,0, BER
Cq,peg,0, BLER
Cq,peg,0, SER
Cq,peg,0, BER
SPB
Figure 11.14. The BER, SER, and BLER performances of the 256-ary (49,28)
RS-QC-SP-LDPC code Cq,sp,qc,rs,0 and the PEG code Cq,peg,0 given in Exam-
ple 11.15 over the binary-input AWGNC.
performs about 0.85 dB away from the Shannon limit at a BER of 10−8 and
0.55 dB away from the SPB at a BLER of 10−5. The 16-ary (7225,6970) code
Cq,sp,qc,rs,2 performs about 0.67 dB away from the Shannon limit at a BER of
10−7 and 0.5 dB away from the SPB at a BLER of 10−5.
For comparison, we also include the BER, SER, and BLER performances of a
16-ary (3969,3780) LDPC code Cq,peg,1 constructed using the PEG algorithm in
Fig. 11.15. The rate of the PEG code Cq,peg,1 is the same as that of the code
Cq,sp,qc,rs,1. Its parity-check matrix has constant column weight 3, but not in
QC-form. From Fig. 11.15, we see that the two codes perform almost the same.
Also included in Fig. 11.16 is the performance of a 16-ary (7225,6970) LDPC
code Cq,peg,2 whose rate and dimension are the same as those of the code
Cq,sp,qc,rs,2. The PEG code Cq,peg,2 is constructed using the PEG algorithm and
its parity-check matrix has constant column weight 3. From Fig. 11.16, we see that
performance curves of the codes Cq,sp,qc,rs,2 and Cq,peg,2 overlap with each other.
12
12:44:57, subject to the Cambridge Core terms of use,

11.8 Discussion and Remarks
205
4.2
4.4
4.6
4.8
5
5.2
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/SER/BER
Eb/N0
Cq,sp,qc,rs,1, BLER
Cq,sp,qc,rs,1, SER
Cq,sp,qc,rs,1, BER
Cq,peg,1, BLER
Cq,peg,1, SER
Cq,peg,1, BER
SPB
Shannon limit
Figure 11.15. The BER, SER, and BLER performances of the 16-ary
(3969,3780) RS-QC-SP-LDPC code Cq,sp,qc,rs,1 and the PEG code Cq,peg,1 given
in Example 11.15 over the binary-input AWGNC.
In this and the previous sections, what we have shown is that, even though we
cannot decode RS codes directly based on their conventional parity-check matrices
using a iterative decoding algorithm based on BP, we can construct powerful NB
LDPC codes from these conventional parity-check matrices using the masking
technique, the q-ary CPM-dispersion, and the CPM-bD/B-to-NB constructions.
11.8 Discussion and Remarks
In Chapters 8 to 10, we presented various algebraic methods for constructing
binary doubly QC-LDPC, QC-SC-LDPC, and QC-GC-LDPC codes. These meth-
ods of binary code construction can be generalized in a straightforward manner
to construct NB doubly QC-LDPC, QC-SC-LDPC, and QC-GC-LDPC codes.
This is achieved simply by dispersing a nonzero entry in a 2 × 2 SM-constrained
base matrix into a q-ary CPM. Binary CPM-dispersion combined with B-to-NB
12
12:44:57, subject to the Cambridge Core terms of use,

206
11 SP-Construction of Nonbinary LDPC Codes
4.6
4.7
4.8
4.9
5
5.1
5.2
5.3
5.4
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
BLER/SER/BER
Eb/N0
Cq,sp,qc,rs,2, BLER
Cq,sp,qc,rs,2, SER
Cq,sp,qc,rs,2, BER
Cq,peg,2, BLER
Cq,peg,2, SER
Cq,peg,2, BER
Shannon limit
SPB
Figure 11.16. The BER, SER, and BLER performances of the 16-ary
(7225,6970) RS-QC-SP-LDPC code Cq,sp,qc,rs,2 and its comparable PEG code
Cq,peg,2 given in Example 11.15 over the binary-input AWGNC.
mapping allows us to construct NB QC-LDPC codes with large size CPMs over
small code symbol ﬁelds.
In general, supported by many experimental results, an NB LDPC code over
a larger symbol ﬁeld has a better error-ﬂoor performance than an NB LDPC
codes with a smaller symbol ﬁeld. However, the decoder complexity of an
NB LDPC code increases greatly as the size of the symbol ﬁeld increases. A
reduced-complexity BP-algorithm for decoding NB LDPC codes with an efﬁcient
trade-off between error performance and decoder complexity is desired. The
reduced-complexity iterative schemes proposed in [79, 69, 68, 78] for decoding
binary QC-LDPC codes with a block-cyclic structure or a section-wise cyclic
structure using a small submatrix of the parity-check matrix of the code may be
used for decoding NB QC-LDPC codes.
Another interesting research problem is to ﬁnd an effective BP-algorithm for
iterative decoding of RS codes for practical application, that achieves good error
performance with decoding complexity much lower than the existing algorithms
presented in [54, 37, 7, 48]. Finding an efﬁcient soft-decision decoding method (or
12
12:44:57, subject to the Cambridge Core terms of use,

11.8 Discussion and Remarks
207
algorithm) for RS codes has always been a challenging problem over the last 40
or more years. A breakthrough in soft-decision decoding of RS codes is needed if
we want to keep these powerful error-correcting codes playing an important role
in future generations of communication and data storage systems.
In the last section of this chapter, we used the conventional parity-check matrix
of an RS code as the base matrix for constructing an NB CPM-QC-SP-LDPC
code. Clearly, such a base matrix can be used for constructing a binary
CPM-QC-SP-LDPC code if each entry is dispersed into a binary CPM as described
in Chapters 7 to 10. A high-performance binary CPM-QC-SP-LDPC code was
constructed using an RS parity-check matrix as the base matrix, which we would
like to point out here is the (6,127)-regular (16129,15372) QC-LDPC code
recently reported in [29, 77]. The base matrix Bq,sp,rs(6,127) given in the form
of (11.14) for constructing this code is the conventional parity-check matrix of
the triple-error-correcting (127,121) RS code of length 127 over GF(27) with
minimum distance 7 and rate 0.9528. Bq,sp,rs(6,127) is a 6 × 127 matrix over
GF(27). The binary CPM-dispersion of Bq,sp,rs(6,127) gives a 6 × 127 array
Hb,sp,qc,rs(127,127) of CPMs of size 127×127. It is a 762×16129 binary matrix
4
5
6
7
8
9
10
11
12
13
14
10
−15
10
−14
10
−13
10
−12
10
−11
10
−10
10
−9
10
−8
10
−7
10
−6
10
−5
10
−4
10
−3
10
−2
10
−1
10
0
Eb/N0(dB)
BER/BLER
(16129,15372),BER, itr50
(16129,15372),BLER, itr50
(16129,15372),BER, itr10
(16129,15372),BLER, itr10
(16129,15372),BER, itr5
(16129,15372),BLER, itr5
Shannon Limit
uncoded BPSK
Figure 11.17. The BER and BLER performances of the binary (16 129, 15 372)
QC-LDPC code reported in [29, 77] decoded with 5 , 10, and 50 iterations of the
MSA over the AWGNC.
12
12:44:57, subject to the Cambridge Core terms of use,

208
11 SP-Construction of Nonbinary LDPC Codes
with column weight 6 and row weight 127. The null space of Hb,sp,qc,rs(127,127)
gives a (6,127)-regular (16129,15372) CPM-QC-SP-LDPC code. The BER and
BLER performances of this code decoded with 5, 10, and 50 iterations of the MSA
with a scaling factor 0.75 are shown in Fig. 11.17. From this ﬁgure, we see that
with 50 iterations of the MSA, the code achieves a BER of 10−15 and a BLER
of almost 10−12 without visible error-ﬂoors. We also see that the decoding of the
code converges quickly. At a BER of 10−12, the performance gap between 5 and 50
iterations of the MSA is about 0.5 dB. The performance curves of the code decoded
with 10 and 50 iterations of the MSA almost overlap with each other all the way
down to a BER of 10−12. This code has good waterfall and error-ﬂoor performance
as well as a fast rate of decoding convergence. Hence, it has an excellent overall
performance as deﬁned in Section 2.2. Using the reduced-complexity iterative
decoding scheme proposed in [69, 68, 78], the code can be decoded with a matrix
that consists of the 6 top rows of the 6 row-blocks of the 6×127 parity-check array
Hb,sp,qc,rs(127,127) of the code. So the decoding matrix is a 6 × 16129 binary
matrix, a very small submatrix of Hb,sp,qc,rs(127,127) with size 762 × 16129.
Using this decoding matrix, the decoder complexity of this code is drastically
reduced (by a factor of 127) without performance degradation.
A code with such a high rate and such a low error probability without an
error-ﬂoor may ﬁnd applications in high-speed optical communication and ﬂash
memory systems. No computer constructed code with the same rate and the same
low error rate has been reported in published literature. This high-performance
LDPC code demonstrates the art of algebraic construction of structured LDPC
code.
12
12:44:57, subject to the Cambridge Core terms of use,

12
Conclusion and Remarks
In this book, we uniﬁed several major types of LDPC code constructions using
a single framework, namely, the SP-construction. Under this framework, the
constructions of all these types of LDPC codes can be viewed as basically
algebraic. In general, algebraically constructed LDPC codes have good overall
performance in terms of both waterfall and error-ﬂoor performance, as well as
a fast rate of decoding convergence. The uniﬁcation of all these constructions
may lead to better designs, and construction of high performing and more easily
implementable codes for applications in next generations of communication and
data storage systems.
This book consists of seven parts. In the ﬁrst part (Chapter 4), we gave
an algebraic interpretation of the protograph-based (PTG-based) construction
of LDPC codes and presented a simple and novel algebraic method for
constructing PTG-LDPC codes. The proposed algebraic method is equiva-
lent to the graphical copy-and-permute operation and uses a simple matrix
decomposition-and-replacement process to construct PTG-LDPC codes. The
algebraic method is based on decomposition of a small base matrix and is very
ﬂexible in code construction. The constructed codes perform well as supported
by examples and simulation results. However, how to design decomposition base
matrices so that the resultant PTG-LDPC codes can perform close to their decoding
thresholds is still an unresolved problem which needs further investigation.
In the second part of the book (Chapters 5 and 6), we re-interpreted the
SP-construction of LDPC codes, one of the earliest methods for algebraic
construction of LDPC codes, in a broader context, from both algebraic and
graph-theoretic perspectives. We showed that the PTG-LDPC code construction
is a special case of SP-construction. New constructions of RC-constrained
base matrices and PW-RC-constrained replacement sets of matrices for the
SP-construction of LDPC codes were presented.
209
13
12:46:26, subject to the Cambridge Core terms of use,

210
12 Conclusion and Remarks
In Chapter 5, we showed that two major ensembles of SP-LDPC codes
for a given rate can be formed. One ensemble is equivalent to the ensemble
of PTG-LDPC codes. In forming this ensemble, the member matrices in the
replacement set R for the SP-construction of LDPC codes are regular. Since this
ensemble is equivalent to the ensemble of PTG-LDPC codes, the SP-LDPC codes
in this ensemble have good asymptotic performance and structural properties.
For the other ensemble, the member matrices in the replacement set R for
the SP-construction of LDPC codes are not regular. Whether this ensemble of
SP-LDPC codes has good asymptotic properties and performance is unknown. An
analysis of this ensemble is a good research problem.
The third part of the book (Chapter 7) uniﬁed most known algebraic construc-
tions of QC-LDPC codes based on matrix dispersion under the framework of
the SP-construction. This uniﬁcation leads to a broader class of constructions
of LDPC codes, both QC and random, allowing the possibility of ﬁnding codes
with improved waterfall and error-ﬂoor performance and faster rates of decoding
convergence. Necessary and sufﬁcient conditions, namely the 2 × 2 and the
3 × 3 SM-constraints, were given for constructing base matrices whose matrix
dispersions give QC-LDPC codes with girth at least 6 and 8, respectively. A
powerful method was presented to construct base matrices which satisfy the 2 × 2
SM-constraint. This construction is based on two arbitrary subsets of a ﬁnite
ﬁeld. We showed that at least six algebraic methods developed over the last
11 years to construct 2 × 2 SM-constrained base matrices are special cases of
this method. So far, there is no speciﬁc algebraic method for constructing 3 × 3
SM-constrained base matrices. To construct 3 × 3 SM-constrained base matrices,
we rely on masking. A test algorithm and a cycle counting algorithm are needed
to check whether a masked base matrix satisﬁes the 3 × 3 SM-constraint. Such a
test algorithm was developed (see Appendix B). Therefore, to ﬁnd an algebraic
method to construct 3 × 3 SM-constrained base matrices would be an interesting
problem to look into.
In Chapter 7, we also demonstrated that masking is a very effective technique
to enlarge the girth and reduce the number of short cycles of the Tanner graph
of an algebraically constructed LDPC code. Masking is equivalent to constructing
a masking matrix with size the same as that of the base matrix to be masked.
The masking operation is performed by using the Hadamard product of a masking
matrix and a base matrix. Several types of small, good masking matrices were
given in Chapter 7. However, the design and construction of these masking
matrices is based on experiments and experience. Some criteria need to be
developed for constructing good masking matrices.
In several examples, we showed that masking matrices that enlarge girth and
reduce short cycles are also good base matrices for constructing QC-PTG-LDPC
13
12:46:26, subject to the Cambridge Core terms of use,

12 Conclusion and Remarks
211
codes using the matrix decomposition method presented in Chapter 4. Is it
generally true that a good masking matrix for the CPM-dispersion construction of a
QC-SP-LDPC code is also a good base matrix for the decomposition-construction
of a QC-PTG-LDPC code? If it is, then the design of a good masking matrix is
much easier than the design of a protograph.
The fourth part of the book (Chapter 8) presented an algebraic method for
constructing LDPC codes with a doubly QC structure which not only perform well,
as shown by examples, but also have a simpliﬁed hardware decoding implemen-
tation using the reduced-complexity decoding schemes presented recently in [79]
and [68]. To construct doubly QC-LDPC codes, we need 2 × 2 SM-constrained
cyclic base matrices. Are there other methods to construct this type of base
matrix, besides the 2 × 2 SM-constrained cyclic base matrices constructed based
on RS codes with two information symbols and the two-dimensional Euclidean
geometries? As shown in Chapter 9, 2×2 SM-constrained cyclic base matrices are
good for constructing spatially coupled QC-LDPC codes. Finding other methods
for constructing 2×2 SM-constrained cyclic base matrices seems also to be a good
problem to investigate.
The ﬁfth contribution of the book (Chapter 9) is the presentation of an
algebraic method for constructing two types of time-varying spatially coupled
(SC) QC-LDPC codes: semi-inﬁnite and terminated. These codes can be regarded
as either SP-LDPC codes or PTG-LDPC codes. The Tanner graphs of these
codes were presented, and examples showing code performance were given. The
algebraic approach may lead to better designs, and construction of high performing
and more easily implementable SC-LDPC codes for practical applications. The
construction methods presented in Chapter 9 are simple, systematic, and ﬂexible,
and avoid random or pseudorandom construction of long codes to achieve good
error performance close to decoding thresholds.
The sixth part of the book (Chapter 10) presented algebraic methods for
constructing two types of CN-based GC-LDPC codes. The ﬁrst type of CN-based
QC-GC-LDPC codes is constructed based on cyclic base arrays. Examples showed
that codes of the ﬁrst type perform very well over both the AWGNC and the BEC.
The CN-based product GC-LDPC codes of the second type are direct products of
two LDPC codes, and they perform well over both the AWGNC and the BEC. A
method to construct CN-based product QC-GC-LDPC codes based on component
base matrices and matrix dispersion was also presented. These GC-LDPC codes
were shown to be special cases of SP-LDPC codes. Also presented in this part
was a local/global two-phase iterative decoding scheme for CN-based GC-LDPC
codes. The proposed decoding scheme allows correction of local errors in the local
phase and globally distributed errors in the global phase and it seems worthy of
13
12:46:26, subject to the Cambridge Core terms of use,

212
12 Conclusion and Remarks
further investigation. Another interesting problem is whether the encoding of a
CN-based GC-LDPC code can be carried out in a local/global two-phase manner.
The concept of global coupling seems to be new and interesting.
Decoding of a CN-based product GC-LDPC code based on its entire parity-check
matrix can be a serious problem. If the lengths of its two component codes are
long (even moderately long), the length of their product can be very long. In this
case, the size of the parity-check matrix of the CN-based product GC-LDPC code
is very large and the implementation of a global decoder for this product code
based on its parity-check matrix will be very complex and impractical. How to
devise a reduced-complexity iterative scheme to decode a long CN-based product
GC-LDPC code seems to be an interesting problem.
One possible approach to resolve this high decoding complexity problem is to
decode the product code using a turbo BP-decoder. A turbo BP-decoder consists
of two local decoders which are designed for decoding the two component
codes separately. Each local decoder is a BP-decoder. The two local BP-decoders
exchange reliability messages (LLRs) of code symbols through two interleavers in
the form of turbo decoding after each local decoding iteration (or a ﬁxed number
of local iterations).
Another interesting problem for investigation is the trapping set structure of a
CN-based product GC-LDPC code. In the discussion at the end of Chapter 10, we
showed that the Tanner graph of a CN-based product GC-LDPC code does not
contain small local trapping sets. The question is then whether it contains small
global trapping sets?
The seventh part of the book (Chapter 11) focused on the constructions of
NB LDPC codes. Several effective methods for constructing NB LDPC codes
were presented, including the SP, the algebraic-PTG, the NB CPM-dispersion, the
B-to-NB replacement, and the masking constructions. The algebraic approach to
the construction of NB PTG-LDPC codes is quite different from the construction
methods presented in the current literature. To create ensembles of NB PTG-LDPC
codes using this algebraic approach and to investigate their asymptotic properties
are interesting research problems and worthy of further investigation. Also
presented in this part of the book was the construction of NB LDPC codes based
on the conventional parity-check matrices of RS codes. Two NB LDPC codes were
constructed based on two well-known RS codes, the (255,239) and (255,223) RS
codes over GF(28), which have been widely used for commercial and deep space
communications and information storage systems over the last forty years. The
LDPC codes constructed have the same lengths and rates as the two RS codes.
They perform very well over the binary-input AWGNC in the waterfall region
and have good error-ﬂoor performance. Also presented in Chapter 11 was the
13
12:46:26, subject to the Cambridge Core terms of use,

12 Conclusion and Remarks
213
construction of NB QC-LDPC codes based on the parity-check matrices of RS
codes with a constraint on the smallest prime factor of the code length.
One extremely interesting and challenging problem is to develop a really efﬁ-
cient iterative decoding scheme for RS codes, not only practically implementable
but also achieving good error performance close to maximum-likelihood decoding.
13
12:46:26, subject to the Cambridge Core terms of use,

13
12:46:26, subject to the Cambridge Core terms of use,

Appendices
21:33:53, subject to the Cambridge Core terms of use,

21:33:53, subject to the Cambridge Core terms of use,

A
RC-Constrained Arrays of CPMs Constructed
Based on Partial Geometries
In this appendix, we present a method for constructing RC-constrained arrays
of CPMs based on partial geometries (PaGs) [6, 10, 12]. These PaG-based
RC-constrained arrays are very powerful for creating base matrices and replace-
ment sets of matrices for the SP-construction of QC-SP-LDPC codes.
Consider a system composed of a set N of n points and a set M of m lines,
where each line is a set of points. If a line L contains a point p, we say that p is
on L and that L passes through p. If two points are on a line, then we say that the
two points are adjacent and if two lines pass through the same point, then we say
that the two lines intersect; otherwise they are parallel. The system composed of
the sets N and M is a partial geometry [6, 10, 12] if the following conditions are
satisﬁed for some ﬁxed integers γ ≥2, ρ ≥2, and δ ≥1:
1. Any two points are on at most one line.
2. Each point is on γ lines.
3. Each line passes through ρ points.
4. If a point p is not on a line L, then there are exactly δ lines, each passing
through p and a point on L.
Such a partial geometry will be denoted by PaG(γ,ρ,δ) and γ , ρ, and δ
are called the parameters of the partial geometry. The parameter δ is called the
connection number of the geometry.
A simple counting argument [6] shows that the partial geometry PaG(γ,ρ,δ)
has exactly
n = ρ((ρ −1)(γ −1) + δ)/δ
(A.1)
points and
m = γ ((ρ −1)(γ −1) + δ)/δ
(A.2)
217
14
12:49:30, subject to the Cambridge Core terms of use,

218
A RC-Constrained Arrays from Partial Geometries
lines.
It follows from Properties 1 and 2 that two lines in PaG(γ,ρ,δ) can have at
most one point in common, and for every point in PaG(γ,ρ,δ), there are exactly
γ lines that intersect at point p, i.e., lines that pass through p.
Denote the n points and the m lines in PaG(γ,ρ,δ) by p0,p1,...,pn−1 and
L0, L1,..., Lm−1, respectively. For 0 ≤i < m, for every line Li in PaG(γ,ρ,δ),
we construct an n-tuple vi = (vi,0,vi,1,...,vi,n−1) over GF(2). For 0 ≤j < n and
0 ≤i < m, vi, j = 1 if p j is on Li and otherwise, vi, j = 0. This n-tuple is called the
incidence vector of the line Li. Since two lines in PaG(γ,ρ,δ) have at most one
point in common, the incidence vectors of two different lines can have at most one
position where they both have 1-components. The weight of the incidence vector
is ρ.
Next, we form an m × n matrix HPaG = [hi, j]0≤i<m, 0≤j<n with the incidence
vectors of the m lines in PaG(γ,ρ,δ) as its rows. Hence, the columns and the
rows of HPaG correspond to the points and the lines in PaG(γ,ρ,δ), respectively.
It follows from the fundamental properties of PaG(γ,ρ,δ) that HPaG has the
following structural properties:
1. It satisﬁes the RC-constraint.
2. It has constant column weight γ .
3. It has constant row weight ρ.
Hence, the Tanner graph associated with HPaG has a girth of at least 6. Any
submatrix of HPaG can be used as a parity-check matrix to generate an LDPC
code. The matrix HPaG is called the incidence matrix of PaG(γ,ρ,δ).
Well-known examples of partial geometries are Euclidean and projective
geometries [13, 84] over ﬁnite ﬁelds. In the following, we present two types of
partial geometry whose incidence matrices can be put into RC-constrained arrays
of CPMs. Hence, these arrays can be used to construct QC-LDPC codes directly,
or to construct base matrices and constituent matrices of replacement sets for the
SP-construction of QC-LDPC codes.
A.1 RC-Constrained Arrays of CPMs Constructed Based on
Two-Dimensional Euclidean Geometries over Finite Fields
A.1.1 Two-Dimensional Euclidean Geometries over Finite Fields
A two-dimensional Euclidean geometry over a ﬁnite ﬁeld GF(q), denoted by
EG(2,q) [13, 84, 74, 97], is a partial geometry PaG(q + 1,q,q) that consists of
q2 points and q2 + q lines. Each line consists of q points and each point is on
q + 1 lines. If a point p is not on line L, then there are exactly q lines, each
14
12:49:30, subject to the Cambridge Core terms of use,

A.1 RC-Constrained Arrays Based on EG(2,q)
219
passing through p and a point on L. This implies that any two points of EG(2,q)
are connected by a line. Each point p not on a line L is on a unique line L′ which is
parallel to L, i.e., L and L′ do not any have any point in common. The q2 +q lines
in EG(2,q) can be partitioned into q + 1 classes, each consisting of q lines, such
that all the lines in each class are parallel, any two lines in two different classes
intersect, and each of the n = q2 points is on a unique line in each class. These
classes of lines are called parallel bundles. Each parallel bundle consists of one
line passing though the origin of the geometry and q −1 lines not passing though
the origin. For every point p in EG(2,q), there are exactly q +1 lines that intersect
at p. These lines are said to form an intersecting bundle at p.
A simple construction of EG(2,q) over GF(q) is to regard the geometry as
a two-dimensional vector space V of all the q2 two-tuples (a0,a1) over GF(q),
commonly called vectors. Each two-tuple is regarded as a point p in EG(2,q) and
the zero two-tuple (0,0) is called the origin of the geometry. Let GF(q2) be an
extension ﬁeld of GF(q). Since every element in GF(q2) can be represented by
a two-tuple over GF(q), it presents a point in EG(2,q). The ﬁeld GF(q2) may
be regarded as a two-dimensional vector space over GF(q). Let α be a primitive
element of GF(q2). Then, the powers of α, α−∞= 0,α0 = 1,α,α2,...,αq2−2,
give all the elements of GF(q2) and they represent the q2 points of EG(2,q). The
0-element represents the origin of EG(2,q).
Let α j1 be a non-origin point in EG(2,q). Then, the set {βα j1 : β ∈GF(q)} of q
points constitutes a line in EG(2,q). For β = 0, βα j1 = 0 is the origin of EG(2,q).
Hence, the line {βα j1 : β ∈GF(q)} contains (or passes through) the origin of
EG(2,q). This line, regarded as a set of q vectors in V, is simply a one-dimensional
subspace of the two-dimensional vector space V over GF(q).
Let α j0 and α j1 be two linearly independent non-origin points in EG(2,q), i.e.,
α j1  βα j0 (or α j0  βα j1). Then, the set {α j0 + βα j1 : β ∈GF(q)} of q points
forms a line passing through the point α j0. The line {α j0 + βα j1 : β ∈GF(q)},
regarded as a set of q vectors in V, is simply a coset of the line {βα j1 : β ∈GF(q)}
which is a one-dimensional subspace of V. The line {α j0 + βα j1 : β ∈GF(q)} is
simply obtained by taking a point α j0 in EG(2,q) but not in {βα j1 : β ∈GF(q)} and
adding α j0 to every point in {βα j1 : β ∈GF(q)}. The two lines {βα j1 : β ∈GF(q)}
and {α j0 + βα j1 : β ∈GF(q)} do not have any point in common and hence they
are parallel. Since there are q cosets of {βα j1 : β ∈GF(q)} in V (including {βα j1 :
β ∈GF(q)} itself), these q cosets form a bundle of q parallel lines in EG(2,q),
called a parallel bundle. This parallel bundle of q lines contains all the q2 points
in EG(2,q) and each point appears on a unique line.
There are q + 1 different one-dimensional subspaces in GF(q2) (or V). Based
on each of these one-dimensional subspaces, we can form a parallel bundle of q
14
12:49:30, subject to the Cambridge Core terms of use,

220
A RC-Constrained Arrays from Partial Geometries
lines. Hence, the lines in EG(2,q) can be partitioned into q + 1 parallel bundles,
each consisting of q parallel lines. Therefore, EG(2,q) consists of q2 + q lines.
Let α j0, α j1, and α j2 be three points in EG(2,q) which are pair-wise linearly
independent. Then, the sets {α j0 +βα j1 : β ∈GF(q)} and {α j0 +βα j2 : β ∈GF(q)}
form two different lines in EG(2,q), both containing the point α j0. Therefore, these
two lines intersect at the point α j0. Since they are not parallel, they must be in two
different parallel bundles. Since the point α j0 is on a unique line in each parallel
bundle of EG(2,q) and there are q +1 parallel bundles, there are exactly q +1 lines
that intersect at the point α j0. These q + 1 lines are said to form an intersecting
bundle. For each point in EG(2,q), we can form an intersecting bundle of q + 1
lines.
What we have shown above is that the two-dimensional Euclidean geometry
EG(2,q) over GF(q) can be simply constructed from the two-dimensional vector
space over GF(q) or the extension ﬁeld GF(q2) of the ground ﬁeld GF(q).
Conversely, GF(q2) can be regarded as a two-dimensional Euclidean geometry
EG(2,q) over GF(q).
A.1.2 EG-Based RC-Constrained Arrays of CPMs
In the following, we show that an RC-constrained array of CPMs of size (q −1)×
(q −1) can be constructed from the lines and points of EG(2,q).
Factor q2 −1 as the product of q −1 and q + 1, i.e., q2 −1 = (q −1)(q + 1).
Then, the order of αq+1 is q −1, i.e., α(q+1)(q−1) = 1. The set L−∞= {α−∞=
0,α0,α(q+1),...,α(q+1)(q−2)} of q points in EG(2,q) form a line which passes
through the origin. Note that the elements in L−∞are simply the q elements of
the subﬁeld GF(q) of GF(q2), a one-dimensional subspace of GF(q2). For 0 ≤j ≤
q, the set α j L−∞= {0,α j,α(q+1)+ j,...,α(q+1)(q−2)+ j} of q points forms a line
passing through the origin of EG(2,q) [74, 97]. Hence, L−∞, αL−∞, ..., αq L−∞
give the q + 1 lines intersecting at the origin. Note that α(q+1)L−∞= L−∞.
Let L = {α j1,α j2,...,α jq} be a line in EG(2,q) not passing through the
origin with α j1,α j2,...,α jq as its points where 0 ≤j1, j2,..., jq < q2 −1. For
0 ≤i < q2 −1, let αi L = {α j1+i,α j2+i,...,α jq+i}. Then, for 0 ≤i < q2 −1, the
set αi L of q points also forms a line in EG(2,q) not passing through the origin,
and L,αL,α2L,...,αq2−2L give all the q2 −1 lines in EG(2,q) not passing
through the origin [84, 97]. The structure of lines developed above is called a cyclic
structure. This cyclic structure allows us to construct all the lines of the Euclidean
geometry EG(2,q) from two lines, one passing through the origin of EG(2,q) and
the other not passing through the origin.
Form a q(q + 1) ×q2 matrix HEG over GF(2) with the incidence vectors of the
q(q + 1) lines in EG(2,q) as rows. Let L−∞and L be a line passing through
14
12:49:30, subject to the Cambridge Core terms of use,

A.1 RC-Constrained Arrays Based on EG(2,q)
221
the origin of EG(2,q) and a line not passing through the origin, respectively.
We arrange the rows of HEG in such a way that the incidence vectors of the
lines L−∞,αL−∞,α2L−∞,...,αq L−∞are the top q + 1 rows of HEG and the
incidence vectors of the lines L,αL,α2L,...,αq2−2L are the bottom q2 −1 rows
of HEG. We label the rows of HEG from 0 to q(q + 1) −1 or, equivalently, with
lines L−∞,αL−∞,α2L−∞,...,αq L−∞, L,αL,α2L,...,αq2−2L of EG(2,q) in
this order. We label the columns of HEG from −∞, 0 to q2 −2 or, equivalently,
with points α−∞,α0,α,α2,...,αq2−2 of EG(2,q) in this order. Let HEG,0 and
HEG,1 denote the submatrices of HEG that consist of the top q + 1 rows and
the bottom q2 −1 rows of HEG, respectively. Then, HEG has the following
form:
HEG =
	 HEG,0
HEG,1

.
(A.3)
The top submatrix HEG,0 of HEG is a (q + 1) × q2 matrix over GF(2) with
the following structural properties: (1) The (−∞)-th column consists of q +1 one
entries; (2) Each of the other q2 −1 columns contains a single one entry and q
zero entries; and (3) The 0-th to the (q2 −2)-th columns form a row-block of q −1
identity matrices of size (q + 1) × (q + 1). The bottom matrix HEG,1 of HEG has
the following structural properties: (1) The (−∞)-th column consists of q2 −1
zero entries; and (2) The other q2 −1 columns form a (q2 −1)×(q2 −1) circulant
with both column and row weight equal to q. Hence, the column and row weights
of HEG are q +1 and q, respectively. HEG is the incidence matrix of EG(2,q) and
satisﬁes the RC-constraint. The null space of HEG gives an LDPC code, called an
EG-LDPC code [58, 74, 97].
Suppose we remove the (−∞)-th column from HEG,1. Then, we obtain an
RC-constrained (q2 −1)×(q2 −1) circulant, denoted by HEG,cyc. The null space
of HEG,cyc gives a cyclic LDPC code CEG,cyc of length q2 −1 with minimum
distance exactly q +1 [58, 74, 97]. It has been proved that the Tanner graph of this
cyclic EG-LDPC code contains no trapping set with size smaller than its minimum
distance [46, 28].
Label the rows and columns of HEG,cyc from 0 to q2 −2. Deﬁne the following
index sequences: for 0 ≤i, j ≤q, πrow,i = [i,(q −1) + i,2(q −1) + i,...,(q −
1)(q −1) + i] and πcol, j = [ j,(q −1) + j,2(q −1) + j,...,(q −1)(q −1) + j].
Let
πrow = [πrow,0,πrow,1,...,πrow,q],
(A.4)
πcol = [πcol,0,πcol,1,...,πcol,q].
(A.5)
14
12:49:30, subject to the Cambridge Core terms of use,

222
A RC-Constrained Arrays from Partial Geometries
Then, πrow and πcol deﬁne re-orderings of the row and the column indices,
respectively.
Suppose we permute the rows and the columns of HEG,cyc based on πrow and
πcol, respectively. The row and column permutations result in a (q2 −1)×(q2 −1)
matrix over GF(2):
HEG,qc = [Ai, j]0≤i, j≤q,
(A.6)
which is a (q + 1) × (q + 1) array of matrices of size (q −1) × (q −1). It consists
of q +1 row-blocks and q +1 column-blocks of matrices of size (q −1)×(q −1).
Among the q + 1 constituent matrices in each row-block (or column-block), q of
them are CPMs of size (q −1)×(q −1) and one is a ZM of size (q −1)×(q −1).
Hence, HEG,qc is an RC-constrained (q + 1) × (q + 1) array of CPMs and ZMs
of size (q −1) × (q −1) [46]. There are exactly q + 1 ZMs in HEG,qc. The q −1
rows in each row-block of HEG,qc correspond to q −1 parallel lines in EG(2,q)
not passing through the origin.
The null space of HEG,qc gives a QC-LDPC code CEG,qc which is combina-
torially equivalent to CEG,cyc. The array HEG,qc can also be used to construct
RC-constrained base matrices and replacement sets for the SP-construction of
QC-LDPC code as described in Sections 6.1 and 6.3.
It was shown in [46] that HEG,qc has an interesting block-cyclic structure. Every
row-block of HEG,qc is the cyclic-shift of the row-block above one constituent
matrix (or (q −1) positions) to the right; but when the rightmost constituent
matrix is shifted around to the left end, all its rows are cyclically shifted one
position to the right within the q −1 positions of the constituent matrix. Note
that cyclic shifting all the rows of a CPM results in a different CPM. With the
above block-cyclic structure, the entire array HEG,qc can be formed by using its top
row-block.
Let β be a primitive element of GF(q), a subﬁeld of GF(q2). Then, β−∞=
0,β,β2,...,βq−2 give all the elements of GF(q). Since GF(q) is a subﬁeld of
GF(q2), β = αq+1, where α is a primitive element of GF(q2). For 0 ≤j ≤q and
l j ∈{−∞,0,1,...,q −2}, let l j be the location of the single 1-component in the
top row of the j-th constituent matrix of the top row-block of HEG,qc. If l j = −∞,
the j-th constituent matrix is a ZM in the top row-block of HEG,qc; otherwise, it is
a CPM whose generator has its single 1-component at location l j. For 0 ≤j ≤q,
if the j-th constituent matrix A0, j of the top row-block of HEG,qc is a CPM, then
it is the CPM-dispersion of the nonzero element βl j . If A0, j is the ZM in the top
row-block of HEG,qc, then l j = −∞. Now, we form the following (q +1)×(q +1)
14
12:49:30, subject to the Cambridge Core terms of use,

A.2 RC-Constrained Arrays Based on Prime Fields
223
matrix over GF(q):
BEG =
⎡
⎢⎢⎢⎢⎢⎢⎢⎣
βl0
βl1
βl2
···
βlq−1
βlq
βlq+1
βl0
βl1
···
βlq−2
βlq−1
βlq−1+1
βlq+1
βl0
···
βlq−3
βlq−2
...
...
...
...
...
...
βl2+1
βl3+1
βl4+1
···
βl0
βl1
βl1+1
βl2+1
βl3+1
···
βlq+1
βl0
⎤
⎥⎥⎥⎥⎥⎥⎥⎦
.
(A.7)
From the structure of BEG, we see that each row is a cyclic-shift of the row
above it one position to the right, but when the rightmost component is shifted
around to the leftmost position, it is multiplied by β. Note that the CPM obtained
by cyclically shifting all the rows of the CPM-dispersion of βl j to the right by one
position is the CPM-dispersion of βl j+1. Then, it follows from the cyclic structures
of HEG,qc and BEG that HEG,qc is the CPM-dispersion of BEG. Since HEG,qc
satisﬁes the RC-constraint, BEG satisﬁes the 2 × 2 SM-constraint.
Hence, any submatrix of BEG can be used as a base matrix for the
SP-construction of CPM-QC-SP-LDPC code. For two-dimensional Euclidean
geometries over various ﬁelds, we can construct base matrices of various sizes.
From these base matrices, we can construct a large family of QC-SP-LDPC codes
using the CPM-dispersion construction.
A.2 RC-Constrained Arrays of CPMs Based on Partial Geometries
Constructed from Prime Fields
Next, we present a construction of an RC-constrained array of CPMs based on a
newly discovered partial geometry constructed based on a prime ﬁeld [29].
Let p be a prime and GF(p) be a prime ﬁeld that consists of the following p
elements: 0,1,2,..., p −1. We disperse each element i in GF(p) into a p × p
CPM, denoted by A(i), with both columns and rows labeled from 0 to p −1,
whose generator has its single 1-component at location i. This representation is
one-to-one. For i = 0, A(0) is a p × p identity matrix.
Form the following p × p matrix Bp over GF(p) with both columns and rows
labeled from 0 to p −1:
Bp =
⎡
⎢⎢⎢⎢⎢⎣
0 · 0
0 · 1
···
0 · (p −1)
1 · 0
1 · 1
···
1 · (p −1)
2 · 0
2 · 1
···
2 · (p −1)
...
...
···
...
(p −1) · 0
(p −1) · 1
···
(p −1) · (p −1)
⎤
⎥⎥⎥⎥⎥⎦
,
(A.8)
14
12:49:30, subject to the Cambridge Core terms of use,

224
A RC-Constrained Arrays from Partial Geometries
i.e., Bp = [bi j]0≤i, j<p with bi j = i j, where the multiplication of two elements
in GF(p) is carried out modulo p. The matrix Bp has the following structural
properties:
1. All the entries in the 0-th row and column are zeros.
2. All the entries in any row or column, other than the 0-th row and column,
are different, and they form all the elements of GF(p).
3. Two different rows or columns have the 0-element of GF(p) in common at
the 0-th column or row, and differ in all the other p −1 positions.
4. The i-th column of Bp is identical to the transpose of the i-th row of Bp for
0 ≤i < p.
The last property implies that the transpose BT
p of Bp is identical to Bp, i.e.,
BpT = Bp.
If each entry in Bp is dispersed into its corresponding p × p CPM, we obtain a
p× p array HPaG,p of CPMs of size p× p. It is a p2 × p2 matrix over GF(2). Each
row has weight p and each column has weight p. It was proved in a recent paper
[29] that HPaG,p is the incidence matrix of a partial geometry PaG(p, p, p −1)
that consists of p2 points and p2 lines. Each line in PaG(p, p, p −1) consists
of p points and each point is on p lines. A point p that is not on a line L is
connected to p −1 points on L by lines, i.e., the connection number of a point
in PaG(p, p, p −1) is p −1. HPaG,p consists of p row-blocks of CPMs and p
column-blocks of CPMs. The p rows of a row-block are the incidence vectors of p
parallel lines in PaG(p, p, p −1). Therefore, the q2 lines in PaG(p, p, p −1) can
be partitioned into p parallel bundles. Since each column of HPaG,p has weight p,
each point in PaG(p, p, p −1) is on p lines. As the incidence matrix of a partial
geometry, the array HPaG,p satisﬁes the RC-constraint. Hence, the Tanner graph
associated with any subarray of HPaG,p has a girth of at least 6. The subscript “p”
of Bp and HPaG,p stands for “prime.”
The matrix Bp over GF(p) is called the base matrix for the construction of the
partial geometry PaG(p, p, p −1). The null space of any subarray of HPaG,p gives
a QC-LDPC code.
The array HPaG,p can be used to construct base matrices and replacement sets for
the SP-construction of QC-SP-LDPC codes as described in Sections 6.1 and 6.4.
14
12:49:30, subject to the Cambridge Core terms of use,

B
An Algorithm for Searching Compatible
Masking and Base Matrices for the CPM-Dispersion
Construction of QC-LDPC Codes
In this appendix, we present an algorithm to search for a 2 × 2 SM-constrained
base matrix over a given ﬁeld which is a good match to a designed masking matrix.
That is, when this 2 × 2 SM-constrained base matrix is masked with the designed
masking matrix, we obtain a masked base matrix which also satisﬁes the 3 × 3
SM-constraint, and furthermore will produce a regular CPM-QC-SP-LDPC code
whose Tanner graph has the largest possible girth and a small number of short
cycles.
Let Z(m,n) be an m × n masking matrix designed for a given rate. Let wc and
wr be the column and the row weights of Z(m,n), respectively. Let Bmother be an
M × N matrix over a given ﬁeld GF(q) with M > m and N > n, which satisﬁes
the 2 × 2 SM-constraint. Now, we want to ﬁnd an m × n submatrix B(m,n) of
Bmother such that the masked base matrix Bmask(m,n) = Z(m,n) ⊙B(m,n) will
produce a CPM-QC-SP-LDPC code whose Tanner graph has the largest possible
girth and a small number of short cycles. Such a base matrix B(m,n) is said to
be compatible with the designed masking matrix Z(m,n). The matrix Bmother is
called the mother base matrix.
The search for such an m × n submatrix B(m,n) from the mother base matrix
Bmother can be carried out systematically. To simplify the search process, we only
consider those m × n submatrices which are taken from m consecutive rows and
n consecutive columns in Bmother (no end around rows and columns). The search
begins from the ﬁrst m rows (the 0-th to the (m −1)-th rows) of Bmother and moves
from the leftmost edge of Bmother to the right, one position (or one column) at a
time. Each time, we mask an m × n submatrix B(m,n) with the masking matrix
Z(m,n) and check whether the m × n masked submatrix Bmask(m,n) satisﬁes the
3 × 3 SM-constraint. After checking the last m × n submatrix of the ﬁrst m rows
of Bmother, we start to search across the next m consecutive rows (the 1-st to the
m-th rows) of Bmother from left to right. We move one position at a time until we
reach and test the last m × n submatrix. Then, we move back to the leftmost edge
225
15
12:50:14, subject to the Cambridge Core terms of use,

226
B Algorithm to Search Masking and Base Matrices
Table B.1. Numbers of 4 × 8 masked base matrices over various ﬁelds GF(q) that give
rate-1/2 CPM-QC-SP-LDPC codes with girth 8 or 10 for η = 1
q
#Bmask(4,8)8
#cyc8smallest
#cyc6unmasked
#cyc8unmasked
#Bmask(4,8)10
#cyc10smallest
53
220
806
1,612
26,286
0
0
64
542
819
1,890
25,965
0
0
89
1,433
616
2,640
26,576
0
0
128
6,872
635
3,810
28,575
0
0
181
15,799
360
4,140
27,990
680
11,880
256
45,977
255
6,375
41,820
5
9,435
257
36,927
256
6,400
46,976
1,479
11,776
331
65,373
330
7,920
34,320
8,970
11,220
of Bmother and start across the next m consecutive rows (the 2-nd to the (m +1)-th
rows) of Bmother from left to right. This searching process continues until we ﬁnish
searching the last m consecutive rows of Bmother. While we are checking whether
an m ×n masked submatrix Bmask(m,n) satisﬁes the 3×3 SM-constraint, we also
check the girth g and count the numbers of short cycles of lengths g, g+2, and g+
4 of the Tanner graph associated with the CPM-dispersion of Bmask(m,n) using
the cycle counting algorithm presented in [71]. By the end of the search, we will
ﬁnd a base matrix B(m,n) whose masked version Bmask(m,n) produces a code
whose Tanner graph has the largest girth, or the smallest number of short cycles,
or both. This base matrix is said to be compatible with the designed masking matrix
Z(m,n). If we are not satisﬁed with the results, we could design another masking
matrix and repeat the search algorithm.
The algorithm to perform the above search of a compatible base matrix for
a designed masking matrix is called a compatible base matrix search algorithm
(CBMSA). This search algorithm is a generalization of the algorithm devised in
[68].
Table B.1 gives a list of numbers of 4 × 8 base matrices B(4,8)s which are
submatrices of the mother matrix Bmother, constructed using the method presented
in Section 7.3 in the form of (7.1) by choosing the two subsets S0 = S1 = GF(q)
and η = 1 for various q. This mother matrix is just a Latin square with order
q. The masking matrix used for search is the 4 × 8 masking matrix given by
(7.5). The second and the sixth columns of Table B.1 contain the numbers of
Bmask(4,8)s which give codes with girths 8 and 10, denoted by #Bmask(4,8)8
and #Bmask(4,8)10, respectively. The third and the seventh columns contain the
smallest numbers of cycles of lengths 8 and 10 for each category of 4 × 8 masked
base matrices, denoted by #cyc8smallest and #cyc10smallest, respectively. The
15
12:50:14, subject to the Cambridge Core terms of use,

B Algorithm to Search Masking and Base Matrices
227
fourth and the ﬁfth columns of the table give the smallest numbers of cycles
of lengths 6 and 8, denoted by #cyc6unmasked and #cyc8unmasked, respectively,
among all unmasked 4 × 8 base matrices B(4,8).
For example, consider the 4 × 8 masked matrices constructed based on the ﬁeld
GF(331). Using the CBMSA devised above, we ﬁnd 65373 4 × 8 masked base
matrices which give codes with girth 8 and 8970 masked base matrices which give
codes with girth 10. Among these masked matrices, the smallest numbers of cycles
of lengths 8 and 10 are 330 and 11220, respectively. Consider an unmasked 4 × 8
base matrix B(4,8) that produces a masked base matrix Bmask(4,8) resulting in a
code with girth 8 and the smallest number of cycles of length 8. From Table B.1,
we ﬁnd that the numbers of cycles of lengths 6 and 8 in the Tanner graph associated
with the CPM-dispersion of an unmasked base matrix B(4,8) are at least 7920 and
34320, respectively. However, the number of cycles of length 8 in the Tanner graph
associated with the CPM-dispersion of the masked base matrix Bmask(4,8) is only
330. So, masking not only increases the girth, from 6 to 8, but also reduces the
number of cycles of length 8, from 34320 to 330.
15
12:50:14, subject to the Cambridge Core terms of use,

C
Iterative Decoding Algorithm for NB LDPC Codes
C.1 Introduction
This appendix will present the most popular decoding algorithm for LDPC codes
over GF(q), where q = 2s, s > 1. This algorithm, which relies on the fast
Hadamard transform, was ﬁrst presented in [82, 23, 5].
We will assume that each q-ary symbol is transmitted as a group of s
bits over the binary-input AWGNC, although the results can be extended to
NB-input channels. We will let n and m denote the number of columns and
rows, respectively, of the code’s (low-density) parity-check matrix over GF(q),
H = [hi, j]0≤i<m,0≤j<n with hi, j ∈GF(q).
Recall that, for binary LDPC codes, the decoder iteratively updates estimates
on Pj[0] and Pj[1], the probabilities that code bit v j is 0 and 1, respectively, for
j = 0,1,...,n −1. For mathematical convenience and reduced implementation
complexity, the decoder estimates these probabilities indirectly by instead
iteratively estimating the log-likelihood ratio (LLR) for v j, given by
L j = log
	 Pj[0 | y]
Pj[1 | y]

(C.1)
where the dependency of these probabilities on the channel output vector y is made
explicit in the a posteriori probabilities Pj[0 | y] and Pj[1 | y] for code bit v j. An
additional condition is implied: namely, the code constraints as encapsulated in the
code’s parity-check matrix H.
For q-ary LDPC codes, a pair of probabilities or a single LLR for each code
symbol v j is not appropriate because v j can take on one of q values, so q
probabilities must be estimated. These q probabilities form a probability mass
function (pmf). Thus, the q-ary LDPC code decoder, which consists of VNs and
CNs connected by edges labeled with elements from GF(q), must propagate pmfs
instead of LLRs along the edges of the code’s Tanner graph representation. Once
228
16
12:52:26, subject to the Cambridge Core terms of use,

C.2 Algorithm Derivation
229
the decoder discontinues its iterative computations, its decision for v j is that value
of v ∈GF(q) which maximizes the a posteriori probability Pj[v | y].
C.2 Algorithm Derivation
As with the binary LDPC code decoding algorithm, the algorithm for NB LDPC
codes receives information from the channel and sends that information up to
the CN processors. The CN processors then send their processed outputs to the
VN processors which take these inputs along with the channel information to
produce information that is sent back to the CN processors. The VN/CN processing
iterations continue until a codeword is found or the preset maximum number of
iterations is reached.
For the AWGNC with two-sided power spectral density N0/2, the appropriate
bitwise information computed from the channel output y for candidate binary input
b ∈{±1} is
Pr(b | y) = p(y | b)Pr(b)/p(y) =
1
1 + exp(−4yb/N0).
(C.2)
These bitwise probabilities are converted by a preprocessor to symbol-wise
probabilities by computing appropriate products of the former. For example, for
s = 4, suppose α2 ∈GF(24) has the binary representation [0 0 1 0], where α is a
primitive element of GF(q). Then Pr(α2 | y) = Pr(0 | y3)Pr(0 | y2)Pr(1 | y1)Pr(0 |
y0), where y = [y3 y2 y1 y0] is the group of channel outputs corresponding to
s = 4 consecutive binary inputs. Each VN processor receives q such symbol-wise
probabilities from the decoder preprocessor; that is, each VN processor receives a
(conditional) pmf on the elements of GF(q). The preprocessor pmf for VN j will
be denoted by P j, for j = 0,1,...,n −1. The q elements of P j will be denoted
by Pj(0), Pj(1), Pj(α), Pj(α2),..., Pj(αq−2), where
Pj(β) = Pr(v j = β | y)
(C.3)
for all β ∈GF(q), with Pj(β) given by a product of s probabilities Pr(b | y).
Given the channel outputs and computed pmfs, we now need to develop the VN
and CN update equations involved in the iterative decoding. To aid the discussion,
we deﬁne the CN neighborhood of VN j, for 0 ≤j < n, to be
M j =

i : hi, j  0

.
(C.4)
Similarly, we deﬁne the VN neighborhood of CN i, for 0 ≤i < m, to be
Ni =

j : hi, j  0

.
(C.5)
16
12:52:26, subject to the Cambridge Core terms of use,

230
C Iterative Decoding Algorithm for NB LDPC Codes
C.2.1 VN Update
As is customary, we regard each VN to be a repetition code so that all of the edges
leaving a VN carry the same value in GF(q). (These values are later scaled by the
edge labels on their way up to the CNs.) Moreover, we assume that the messages
from the CNs to the VNs are independent. Because the optimum repetition code
decoder adds LLRs, or multiplies probabilities, it follows that, for each β ∈GF(q),
the (extrinsic) message m j→i(β) to be sent from VN j to CN i is given by
m j→i(β) = Pj(β)

k∈M j\i
mk→j(β)
(C.6)
where mk→j(β) is the message sent from CN k to VN j about the probability
that code symbol v j is equal to β. Note that the independence assumption on the
incoming messages at VN j actually holds only for the ﬁrst g/2 iterations, where
g is the girth of the code’s Tanner graph. Note also that, because of the exclusion
M j\i in the product, the message m j→i(β) does not send CN i information that it
already has.
We should emphasize that, while a single computation of the form (C.6) is
performed in the binary case, q such computations are performed for NB LDPC
codes, one for each value of β ∈GF(q).
The computation of the CN-to-VN messages is much more involved, as is its
development, which we will do in stages.
C.2.2 CN Update: Complex Version
The CN update equation takes more time to develop, but the concepts are well
known to students of coding. First, note that a CN is considered to be an NB
single-parity check (SPC) code. Thus, the i-th CN, representing the i-th row,
[hi,0 hi,1 ... hi,n−1], of the parity-check matrix H, corresponds to the parity-check
equation

j∈Ni
v jhi, j = 0.
(C.7)
In this equation, v j ∈GF(q) is the code symbol corresponding to VN j, hi, j with
j = 0,1,...,n −1 are the nonzero elements of the i-th row of H, and addition and
multiplication are over GF(q).
Letting v′
j = v jhi, j, the above sum can be rewritten as

j∈Ni
v′
j = 0.
(C.8)
16
12:52:26, subject to the Cambridge Core terms of use,

C.2 Algorithm Derivation
231
The previous equation leads to the CN update equation given CN inputs from
neighboring VNs. In particular, consider the i-th CN, its neighborhood of VNs,
Ni, and their pmfs. From these pmfs (messages), we are to compute the pmf to be
sent from CN i to VN j, for all js in Ni. The pmf to be sent to VN j is the pmf of
v′
j =

ℓ∈Ni\ j
v′
ℓ.
(C.9)
When a discrete-valued random variable, v′
j, is the sum of independent discrete-
valued random variables, v′
ℓ, then the pmf of v′
j is given by the cyclic convolution
of the pmfs of the v′
ℓs.
It is important to highlight here an important detail regarding the convolution
of pmfs of elements of GF(q). Consider two random variables, X and Y, taking
values in GF(q). Let their corresponding pmfs be denoted by pX and pY . We are
interested in determining the pmf of their sum, Z = X + Y, noting that the sum
is performed via the modulo-2 addition of the binary s-tuple representations of X
and Y. Thus, it is convenient to represent the elements of GF(q) by their binary
s-tuples or their decimal equivalents. We have then that
pZ(z) =

x,y:x+y=z
pX(x)pY (y) =

x
pX(x)pY (z −x) ,
(C.10)
or, using the cyclic convolution operator shorthand,
pZ = pX ⊛pX .
(C.11)
This generalizes to a sum of more than two random variables. To apply this
result to (C.9), we let mi→j = [mi→j(0) mi→j(1) ... mi→j(αq−2)] be the
conditional pmf of v′
j and mℓ→i = [mℓ→i(0) mℓ→i(1) ... mℓ→i(αq−2)] the
conditional pmf of v′
ℓ. It follows from the development above that the conditional
pmf of v′
j is
mi→j = ⊛
ℓ∈Ni\ j mℓ→i .
(C.12)
C.2.3 CN Update: Fast Hadamard Transform Version
The convolution of multiple pmfs to obtain the pmf of v′
j is obviously quite
complex. The computational complexity may be vastly reduced by using Fast
Hadamard Transform (FHT) techniques to perform the convolutions. To introduce
the FHT-based algorithm, some preliminary information on the Hadamard
transform itself is necessary. We will present the fast Hadamard transform
algorithm later.
16
12:52:26, subject to the Cambridge Core terms of use,

232
C Iterative Decoding Algorithm for NB LDPC Codes
The Hadamard transform of a length-q, real-valued (row) vector p = [ p0 p1 ...
pq−1 ], considered to be a pmf here, is given by
P = H(p) = pHq
(C.13)
where Hq is recursively deﬁned as
Hq =
1
√
2
	 Hq/2
Hq/2
Hq/2
−Hq/2

,
(C.14)
with the initial condition
H2 =
1
√
2
	 1
1
1
−1

.
(C.15)
Letting φx represent the x-th row of Hq, the Hadamard transform of p may be
written as
P =
q−1

x=0
pxφx .
(C.16)
Because Hq is recursively deﬁned, it is not difﬁcult to prove by induction the
following properties of the Hadamard transform.
1. HT
q = Hq (where the superscript T denotes matrix transpose).
2. HqHT
q = HT
q Hq = Iq (Iq is the q × q identity matrix). In particular, the
inverse Hadamard transform is performed by HT
q = H−1
q , that is, H−1(P) =
PHT
q = pHqHT
q = p. A corollary to this property is that the rows of Hq are
orthonormal φxφT
y = δx−y, where δn is the Kronecker delta function.
3. The component-wise multiplication, denoted by ⊙, of the x-th and y-th rows
of Hq is φx ⊙φy =
1
√
2φx⊕y, where x ⊕y is component-wise mod-2 addition
of the binary representations of x and y. For example, 13 ⊕10 = 7.
Observe that the component-wise mod-2 addition mentioned in Property 3 is
identical to addition of two elements in GF(2s), although, following convention,
we have used ⊕for the former and + for the latter. Property 3 is critical to the
proof of the following cyclic convolution theorem for Hadamard transforms that
is central to the low-complexity computation of the cyclic convolution of pmfs
of random variables that take values in GF(q). It will be seen in the proof that
the indices to the rows of Hq are put into a one-to-one correspondence with the
elements (s-tuples) of the additive group in GF(q).
Theorem C.1. Consider two independent random variables, X and Y, deﬁned on
GF(q) with pmfs pX and pY . Then, the pmf pZ of their sum in GF(q), Z = X + Y,
may be computed from
√
2 H−1 
H(pX) ⊙H(pY )

.
16
12:52:26, subject to the Cambridge Core terms of use,

C.2 Algorithm Derivation
233
Proof. For simplicity of notation, instead of pX(x) and pY (y), p(x) and p(y) will
be written for individual components of pX and pY . All summations below are
from 0 to q −1, or their binary s-tuple equivalents.
√
2 H−1 
H(pX) ⊙H(pY )

=
√
2 H−1

x
p(x)φx ⊙

y
p(y)φy

=
√
2 H−1

x

y
p(x)φx ⊙p(y)φy

=
√
2 H−1

x

y
p(x)p(y) 1
√
2
φx⊕y

=

x

y

z
p(x)p(y)φx⊕yφT
z
=

x

y

z
p(x)p(y)δ(x⊕y)−z
=

x,y:x⊕y=z
p(x)p(y)
=

x
p(x)p(z −x)
= pX ⊛pY .
(C.17)
The ﬁrst two lines are obvious; the third follows from Property 3; the fourth
from Properties 1 and 2; the ﬁfth from the corollary to Property 2; and the last
three are obvious.
□
Example C.1. Although the development so far has focused on NB LDPC
codes, the results are applicable to binary LDPC codes as well, that is, the
case q = 2. Substitution of pX = [pX(0)
pX(1)] and pY = [pY (0)
pY (1)]
into
√
2 H−1 
H(pX) ⊙H(pY )

yields pX ⊛pY = [ pX(0)pY (0) + pX(1)pY (1)
pX(0)pY (1) + pX(1)pY (0) ]. Clearly, the ﬁrst component of this vector is equal to
Pr[X +Y = 0] and the second component is equal to Pr[X +Y = 1]. The logarithm
of the ratio of the second component to the ﬁrst appears in the proof of Lemma
5.2 in [97], which shows how to compute the LLR of a sum (over GF(2)) of two
independent binary random variables, given their individual LLRs.
The Fast Hadamard Transform
Efﬁcient computation of a Hadamard transform, called the fast Hadamard
transform algorithm (FHT) (which is also called the fast Fourier transform
16
12:52:26, subject to the Cambridge Core terms of use,

234
C Iterative Decoding Algorithm for NB LDPC Codes
Figure C.1. Diagram of implementation of P = pH16.
(FFT) in [82, 97]), is possible because of the recursive nature of Hadamard
matrices. Further, from Properties 1 and 2, the Hadamard transform and the inverse
Hadamard transform are identical, so we need only discuss one fast algorithm.
Presentation of the FHT is easiest by way of example. Let us consider the 16-ary
case so that q = 16, p = [p0 p1 ... p15], and P = H(p) = pH16. Observe that
H16 =
1
√
2
	 H8
H8
H8
−H8

=
1
√
2
	 H8
0
0
H8

	 I8
I8
I8
−I8

.
(C.18)
Fig. C.1 illustrates the implementation of this equation, where p7
0 is the
subvector [p0 p1 ... p7] of p, and similarly for the other subvectors. In the ﬁgure,
quantities along edges that diverge are identical and quantities along edges that
merge are added.
This implementation does not look advantageous until we observe that H8
decomposes as
H8 =
1
√
2
	 H4
0
0
H4

	 I4
I4
I4
−I4

,
(C.19)
which is implemented as in Fig. C.2 for the input p7
0. The implementation for the
input p15
8 is essentially identical. The setup in Fig. C.2 and the analogous one for
p15
8
replace the two H8 blocks in Fig. C.1. Next, each of the H4 blocks in the
implementation of H8 is replaced by the implementation of
H4 =
1
√
2
	 H2
0
0
H2

	 I2
I2
I2
−I2

,
(C.20)
resulting in eight H2 blocks.
The culmination of all of these steps is Fig. C.3, which is a concatenation of
log2(q) = 4 levels of “butterﬂies,” with eight butterﬂies in the ﬁrst level, four in
the second, two in the third and one in the last. The scale factor of 1/4 at the output
accounts for the four factors of 1/
√
2 that would occur in each of the four stages,
but combined near the output.
16
12:52:26, subject to the Cambridge Core terms of use,

C.3 The NB LDPC Decoding Algorithm
235
Figure C.2. Diagram of implementation of P = p7
0H8.
Figure C.3. Diagram of the Fast Hadamard Transform.
C.3 The NB LDPC Decoding Algorithm
Below we summarize the NB LDPC code decoding algorithm in the foregoing,
called the fast Fourier transform q-ary sum-product algorithm (FFT-QSPA). The
messages m j→i(β) computed in Step 2 correspond to v j, whereas the convolutions
in (C.12) correspond to v′
j, so the translations in Steps 3 and 5 are necessary. Each
of the steps is to be applied to all β ∈GF(q) and all i and j for which hi, j  0,
with 0 ≤i < m and 0 ≤j < n.
16
12:52:26, subject to the Cambridge Core terms of use,

236
C Iterative Decoding Algorithm for NB LDPC Codes
1. Initialize the probabilities Pj(β) according to equations (C.2) and (C.3) and
the discussion in between those equations. Initialize also the CN messages
mi→j(β) = 1.
2. Compute the VN messages m j→i(β) according to equation (C.6).
3. Translate the messages m j→i(β) to the messages m j→i(β′), according to
m j→i(β′) = m j→i(β), where β′ = hi, jβ.
4. Using the Hadamard transform convolution theorem and the FHT algorithm,
compute the CN messages:
mi→j = H−1
⎧
⎨
⎩

ℓ∈Ni\ j
H{mℓ→i}
⎫
⎬
⎭.
(C.21)
5. Translate the messages mi→j(β′) to the messages mi→j(β), according to
mi→j(β) = mi→j(β′), where β′ = hi, jβ.
6. Make symbol decisions using
ˆv j = argmaxβ m j(β) ,
(C.22)
where
m j(β) = Pj(β)

k∈M j
mk→j(β) .
(C.23)
If a codeword found (if ˆvHT = 0) or if the maximum number of iterations
reached, then stop; otherwise, go to Step 2.
16
12:52:26, subject to the Cambridge Core terms of use,

References
[1] Abu-Surra, S., Divsalar, D., and Ryan, W. E. 2010 (Jan.). On the existence of typical
minimum distance for protograph-based LDPC codes. Pages 1–7 of: Proc. IEEE Inf.
Theory Applic. Workshop. San Diego, CA, USA, January 31–February 5 2010.
[2] Abu-Surra, S., Divsalar, D., and Ryan, W. E. 2011. Enumerators for protograph-based
ensembles of LDPC and generalized LDPC codes. IEEE Trans. Inf. Theory, 57(2),
858–886.
[3] Ammar, B., Honary, B., Kou, Y., Xu, J., and Lin, S. 2004.
Construction of
low-density parity-check codes based on balanced incomplete block designs. IEEE
Trans. Inf. Theory, 50(6), 1257–1269.
[4] Bahl, L., Cocke, J., Jelinek, F., and Raviv, J. 1974. Optimal decoding of linear codes
for minimizing symbol error rate. IEEE Trans. Inf. Theory, 20(2), 284–287.
[5] Barnault, L., and Declercq, D. 2003 (Mar.). Fast decoding algorithm for LDPC over
GF(2q). Pages 70–73 of: Proc. IEEE Inf. Theory Workshop. La Sorbonne, Paris,
France, March 31–April 4, 2003.
[6] Batten, L. M. 1997. Combinatorics of Finite Geometries, 2nd ed. Cambridge, UK:
Cambridge University Press.
[7] Bellorado, J., and Kavcic, A. 2010. Low-complexity soft-decoding algorithms for
Reed–Solomon codes part I: An algebraic soft-in hard-out Chase decoder. IEEE
Trans. Inf. Theory, 56(3), 945–959.
[8] Berlekamp, E. R. 1984. Algebraic Coding Theory. Laguna Hills, CA: Aegean Park
Press.
[9] Bose, R. C. 1939. On the construction of balanced incomplete block designs. Ann.
Eugenics, 9(4), 353–399.
[10] Bose, R. C. 1963. Strongly regular graphs, partial geometries and partially balanced
designs. Paciﬁc J. Math., 13(2), 389–419.
[11] Butler, B. K., and Siegel, P. H. 2010 (Jun.). On distance properties of quasi-cyclic
protograph-based LDPC codes.
Pages 809–813 of: Proc. IEEE Int. Symp. Inf.
Theory. Austin, TX, USA, June 13–18, 2010.
[12] Cameron, P. J., and Van Lint, J. H. 1991. Designs, Graphs, Codes, and Their Links.
Cambridge, UK: Cambridge University Press.
[13] Carmichael, R. D. 1956. Introduction to the Theory of Groups of Finite Orders. New
York, NY: Dover.
[14] Chandrasetty, V. A., Johnson, S. J., and Lechner, G. 2013. Memory efﬁcient decoders
using spatially coupled quasi-cyclic LDPC codes. CoRR, arXiv:abs/1305.5625.
237
17
17:13:11, subject to the Cambridge Core terms of use,

238
References
[15] Chang, B. Y., Dolecek, L., and Divsalar, D. 2011 (Nov.).
EXIT chart analysis
and design of non-binary protograph-based LDPC codes. Pages 566–571 of: IEEE
Military Commun. Conf. (Milcom). Baltimore, MD, USA, November 7–10, 2011.
[16] Chang, B. Y., Divsalar, D., and Dolecek, L. 2012 (September 3–7). Non-binary
protograph-based LDPC codes for short block-lengths. Pages 282–286 of: Proc.
IEEE Inf. Theory Workshop. Lausanne, Switzerland, September 3–7, 2012.
[17] Chen, C. L., Peterson, W. W., and Weldon, E. J., Jr. 1969.
Some results on
quasi-cyclic codes. Inf. Control, 15(5), 407–423.
[18] Chen, J., and Fossorier, M. P. C. 2002. Near optimum universal belief propagation
based decoding of low-density parity check codes. IEEE Trans. Commun., 50(3),
406–414.
[19] Chen, L., Xu, J., Djurdjevic, I., and Lin, S. 2004. Near Shannon-limit quasi-cyclic
low-density parity-check codes. IEEE Trans. Commun., 52(7), 1038–1042.
[20] Chen, Y., and Parhi, K. K. 2004.
Overlapped message passing for quasi-cyclic
low-density parity check codes. IEEE Trans. Circuits Syst. I, 51(6), 1106–1113.
[21] Colbourn, C. J., and Dintz, J. H. 1996. The Handbook of Combinatorial Design.
Boca Raton, FL: CRC Press.
[22] Costello, D. J., Jr., Dolecek, L., Fuja, T., Kliewer, J., Mitchell, D. G. M., and
Smarandache, R. 2014.
Spatially coupled sparse codes on graphs: Theory and
practice. IEEE Commun. Mag., 52(7), 168–176.
[23] Davey, M. C., and MacKay, D. J. C. 1998. Low-density parity check codes over
GF(q). IEEE Commun. Lett., 2(6), 165–167.
[24] Di, C., Proietti, D., Telatar, I. E., Richardson, T. J., and Urbanke, R. L. 2002.
Finite-length analysis of low-density parity-check codes on the binary erasure
channel. IEEE Trans. Inf. Theory, 48(6), 1570–1579.
[25] Diao, Q., Huang, Q., Lin, S., and Abdel-Ghaffar, K. 2011 (Feb.).
A transform
approach for analyzing and constructing quasi-cyclic low-density parity-check
codes. Pages 1–8 of: Proc. IEEE Inf. Theory Applic. Workshop. La Jolla, CA, USA,
February 6–11, 2011.
[26] Diao, Q., Huang, Q., Lin, S., and Abdel-Ghaffar, K. 2012a.
A matrix-theoretic
approach for analyzing quasi-cyclic low-density parity-check codes. IEEE Trans.
Inf. Theory, 58(6), 4030–4048.
[27] Diao, Q., Zhou, W., Lin, S., and Abdel-Ghaffar, K. 2012b (Feb.).
A transform
approach for constructing quasi-cyclic Euclidean geometry LDPC codes.
Pages
204–211 of: Proc. IEEE Inf. Theory Applic. Workshop. San Diego, CA, USA,
February 5–10, 2012.
[28] Diao, Q., Tai, Y. Y., Lin, S., and Abdel-Ghaffar, K. 2013. LDPC codes on partial
geometries: Construction, trapping set structure, and puncturing. IEEE Trans. Inf.
Theory, 59(12), 7898–7914.
[29] Diao, Q., Li, J., Lin, S., and Blake, I. F. 2016. New classes of paritial geometries and
their associated LDPC codes. IEEE Trans. Inf. Theory, 62(6) 2947–2965.
[30] Divsalar, D., Dolinar, S., and Jones, C. 2005a (Sep.). Low-rate LDPC codes with
simple protograph structure. Pages 1622–1626 of: Proc. IEEE Int. Symp. Inf. Theory.
Adelaide, SA, USA, September 4–9, 2005.
[31] Divsalar, D., Jones, C., Dolinar, S., and Thorpe, J. 2005b (Nov.). Protograph based
LDPC codes with minimum distance linearly growing with block size.
Page 5
of: Proc. IEEE Glob. Commun. Conf., vol. 3. St. Louis, MO, USA, November
28–December 2, 2005.
17
17:13:11, subject to the Cambridge Core terms of use,

References
239
[32] Divsalar, D., Dolinar, S., and Jones, C. 2006 (Jul.).
Construction of protograph
LDPC codes with linear minimum distance. Pages 664–668 of: Proc. IEEE Int.
Symp. Inf. Theory. Seattle, WA, USA, July 9–14, 2006.
[33] Divsalar, D., Dolinar, S., and Jones, C. 2007 (Oct.). Short protograph-based LDPC
codes. Pages 1–6 of: IEEE Military Commun. Conf. (Milcom). Orlando, FL, USA,
October 29–31, 2007.
[34] Divsalar, D., Dolinar, S., Jones, C. R., and Andrews, K. 2009. Capacity-approaching
protograph codes. IEEE J. Sel. Areas Commun., 27(6), 876–888.
[35] Djurdjevic, I., Xu, J., Abdel-Ghaffar, K., and Lin, S. 2003. A class of low-density
parity-check codes constructed based on Reed-Solomon codes with two information
symbols. IEEE Commun. Lett., 7(7), 317–319.
[36] Dolecek, L., Divsalar, D., Sun, Y., and Amiri, B. 2014. Non-binary protograph-based
LDPC codes: Enumerators, analysis, and designs. IEEE Trans. Inf. Theory, 60(7),
3913–3941.
[37] El-Khamy, M., and McEliece, R. J. 2006.
Iterative algebraic soft-decision list
decoding of Reed–Solomon codes. IEEE J. Sel. Areas Commun., 24(3), 481–490.
[38] Fan, J. L. 2000 (Sep.).
Array codes as low-density parity-check codes.
Pages
543–546 of: Proc. 2nd Int. Sym. on Turbo Codes and Related Topics. Brest, France,
September 4–7, 2000.
[39] Fossorier, M. P. C. 2004. Quasi-cyclic low-density parity-check codes from circulant
permutation matrices. IEEE Trans. Inf. Theory, 50(8), 1788–1793.
[40] Gallager, R. G. 1962. Low-density parity-check codes. IRE Trans. Inform. Theory,
IT-8(Jan.), 21–28.
[41] Han, Y., and Ryan, W. E. 2009. Low-ﬂoor decoders for LDPC codes. IEEE Trans.
Commun., 57(6), 1663–1673.
[42] Horn, R. A., and Johnson, C. R. 1985. Matrix Analysis. Cambridge, UK: Cambridge
University Press.
[43] Hu, X. Y., Eleftheriou, E., and Arnold, D. M. 2001. Progressive edge-growth Tanner
graphs. Pages 995–1001 of: Proc. IEEE Glob. Commun. Conf., vol. 2. San Antonio,
TX, USA, November 25–29, 2001.
[44] Hu, X. Y., Eleftheriou, E., and Arnold, D. M. 2005. Regular and irregular progressive
edge-growth Tanner graphs. IEEE Trans. Inf. Theory, 51(1), 386–398.
[45] Huang, J., Liu, L., Zhou, W., and Zhou, S. 2010. Large-girth nonbinary QC-LDPC
codes of various lengths. IEEE Trans. Commun., 58(12), 3436–3447.
[46] Huang, Q., Diao, Q., Lin, S., and Abdel-Ghaffar, K. 2012. Cyclic and quasi-cyclic
LDPC codes on constrained parity-check matrices and their trapping sets. IEEE
Trans. Inf. Theory, 58(5), 2648–2671.
[47] Iyengar, A. R., Papaleo, M., Siegel, P. H., Wolf, J. K., Vanelli-Coralli, A., and
Corazza, G. E. 2012. Windowed decoding of protograph-based LDPC convolutional
codes over erasure channels. IEEE Trans. Inf. Theory, 58(4), 2303–2320.
[48] Jiang, J., and Narayanan, K. R. 2008.
Algebraic soft-decision decoding of
Reed–Solomon codes using bit-level soft information.
IEEE Trans. Inf. Theory,
54(9), 3907–3928.
[49] Jimenez Felstrom, A., and Zigangirov, K. S. 1999.
Time-varying periodic
convolutional codes with low-density parity-check matrix. IEEE Trans. Inf. Theory,
45(6), 2181–2191.
[50] Kang, J., Huang, Q., Zhang, L., Zhou, B., and Lin, S. 2010. Quasi-cyclic LDPC
codes: An algebraic construction. IEEE Trans. Commun., 58(5), 1383–1396.
17
17:13:11, subject to the Cambridge Core terms of use,

240
References
[51] Kang, J., Huang, Q., Lin, S., and Abdel-Ghaffar, K. 2011. An iterative decoding
algorithm with backtracking to lower the error-ﬂoors of LDPC codes. IEEE Trans.
Commun., 59(1), 64–73.
[52] Karlin, M. 1969. New binary coding results by circulants. IEEE Trans. Inf. Theory,
15(1), 81–92.
[53] Kasami, T. 1974. A Gilbert-Varshamov bound for quasi-cycle codes of rate 1/2.
IEEE Trans. Inf. Theory, 20(5), 679.
[54] K¨oetter, R., and Vardy, A. 2003. Algebraic soft-decision decoding of Reed–Solomon
codes. IEEE Trans. Inf. Theory, 49(11), 2809–2825.
[55] Kou, Y., Lin, S., and Fossorier, M. P. C. 2000a (Sep.). Construction of low density
parity check codes: A geometric approach. Pages 137–140 of: Proc. 2nd Int. Sym.
on Turbo Codes and Related Topics. Brest, France, September 4–7, 2000.
[56] Kou, Y., Lin, S., and Fossorier, M. P. C. 2000b. Low density parity check codes
based on ﬁnite geometries: A rediscovery. Page 200 of: Proc. IEEE Int. Symp. Inf.
Theory. Sorrento, Italy, June 25–30, 2000.
[57] Kou, Y., Lin, S., and Fossorier, M. P. C. 2000c (Nov./Dec.). Low density parity check
codes: Construction based on ﬁnite geometries. Pages 825–829 of: Proc. IEEE Glob.
Commun. Conf., vol. 2. San Francisco, CA, USA, November 27–December 1, 2000.
[58] Kou, Y., Lin, S., and Fossorier, M. P. C. 2001. Low-density parity-check codes based
on ﬁnite geometries: A rediscovery and new results. IEEE Trans. Inf. Theory, 47(7),
2711–2736.
[59] Kudekar, S., Richardson, T. J., and Urbanke, R. L. 2011. Threshold saturation via
spatial coupling: Why convolutional LDPC ensembles perform so well over the
BEC. IEEE Trans. Inf. Theory, 57(2), 803–834.
[60] Kudekar, S., Richardson, T., and Urbanke, R. L. 2013. Spatially coupled ensembles
universally achieve capacity under belief propagation.
IEEE Trans. Inf. Theory,
59(12), 7761–7813.
[61] Kumar, S., and Pﬁster, H. D. 2015. Reed–Muller codes achieve capacity on erasure
channels. CoRR, arXiv:abs/1505.05123.
[62] Laendner, S., and Milenkovic, O. 2005. Algorithmic and combinatorial analysis
of trapping sets in structured LDPC codes. Pages 630–635 of: Wireless Networks,
Communications and Mobile Computing, 2005 International Conference on, vol. 1.
Maui, HI, USA, June 13–16, 2005.
[63] Laendner, S., and Milenkovic, O. 2007. LDPC codes based on Latin squares: Cycle
structure, stopping set, and trapping set analysis.
IEEE Trans. Commun., 55(2),
303–312.
[64] Lan, L., Zeng, L., Tai, Y. Y., Chen, L., Lin, S., and Abdel-Ghaffar, K. 2007.
Construction of quasi-cyclic LDPC codes for AWGN and binary erasure channels:
A ﬁnite ﬁeld approach. IEEE Trans. Inf. Theory, 53(7), 2429–2458.
[65] Lan, L., Tai, Y. Y., Lin, L., Behshad, M., and Honary, B. 2008. New constructions
of quasi-cyclic LDPC codes based on special classes of BIBDs for the AWGN and
binary erasure channels. IEEE Trans. Commun., 56(1), 39–48.
[66] Lentmaier, M., Sridharan, A., Zigangirov, K. S., and Costello, D. J., Jr. 2005 (Sep.).
Terminated LDPC convolutional codes with thresholds close to capacity.
Pages
1372–1376 of: Proc. IEEE Int. Symp. Inf. Theory. Adelaide, SA, USA, September
4–9, 2005.
[67] Lentmaier, M., Sridharan, A., Costello, D. J., Jr., and Zigangirov, K. S. 2010.
Iterative decoding threshold analysis for LDPC convolutional codes. IEEE Trans.
Inf. Theory, 56(10), 5274–5289.
17
17:13:11, subject to the Cambridge Core terms of use,

References
241
[68] Li, J., Liu, K., Lin, S., and Abdel-Ghaffar, K. 2014a. Algebraic quasi-cyclic LDPC
codes: Construction, low error-ﬂoor, large girth and a reduced-complexity decoding
scheme. IEEE Trans. Commun., 62(8), 2626–2637.
[69] Li, J., Liu, K., Lin, S., and Abdel-Ghaffar, K. 2014b (Feb.). Decoding of quasi-cyclic
LDPC codes with section-wise cyclic structure.
Pages 1–10 of: Proc. IEEE Inf.
Theory Applic. Workshop. San Diego, CA, USA, February 9–14, 2014.
[70] Li, J., Liu, K., Lin, S., and Abdel-Ghaffar, K. 2014c (Jun.). Quasi-cyclic LDPC
codes on two arbitrary sets of a ﬁnite ﬁeld. Pages 2454–2458 of: Proc. IEEE Int.
Symp. Inf. Theory. Honolulu, HI, USA, June 29–July 4, 2004.
[71] Li, J., Lin, S., and Abdel-Ghaffar, K. 2015 (Jun.).
Improved message-passing
algorithm for counting short cycles in bipartite graphs. In: Proc. IEEE Int. Symp.
Inf. Theory. Hong Kong, China, June 14–19, 2015.
[72] Li, Z., Chen, L., Zeng, L., Lin, S., and Fong, W. H. 2006. Efﬁcient encoding of
quasi-cyclic low-density parity-check codes. IEEE Trans. Commun., 54(1), 71–81.
[73] Lidl, R., and Niederreiter, H. 1997.
Finite Fields.
Cambridge, UK: Cambridge
University Press.
[74] Lin, S., and Costello, D. J., Jr. 2004. Error Control Coding: Fundamentals and
Applications, 2nd edition. Upper Saddle River, NJ: Prentice Hall.
[75] Lin, S., Kasami, T., Fujiwara, T., and Fossorier, M. P. C. 1998.
Trellis and
Trellis-Based Decoding Algorithm for Linear Block Codes.
New York, NY:
Springer-Verlag New York.
[76] Lin, S., Xu, J., Djurdjevic, I., and Tang, H. 2002 (Oct.). Hybrid construction of
LDPC codes. Pages 1149–1158 of: Proc. 40th Annual Allerton Conf. Commun.,
Control, Computing. Monticello, IL, USA, October 1–3, 2002.
[77] Lin, S., Diao, Q., and Blake, I. F. 2014a (Aug.). Error ﬂoors and ﬁnite geometries.
Pages 42–46 of: Proc. 8th Int. Sym. on Turbo Codes and Iterative Inf. Processing.
Bremen, Germany, August 18–22, 2014.
[78] Lin, S., Liu, K., Li, J., and Abdel-Ghaffar, K. 2014b (Nov.). A reduced-complexity
iterative scheme for decoding quasi-cyclic low-density parity-check codes. Pages
119–125 of: Proc. 48th Annual Allerton Conf. Commun., Control, Computing.
Paciﬁc Grove, CA, USA, November 2–5, 2014.
[79] Liu, K., Lin, S., and Abdel-Ghaffar, K. 2013. A Revolving iterative algorithm for
decoding algebraic cyclic and quasi-cyclic LDPC codes. IEEE Trans. Commun.,
61(12), 4816–4827.
[80] Liva, G., and Chiani, M. 2007 (Nov.). Protograph LDPC codes design based on
EXIT analysis. Pages 3250–3254 of: Proc. IEEE Glob. Commun. Conf. Washington,
DC, USA, November 26–30, 2007.
[81] MacKay, D. J. C. 1999. Good error-correcting codes based on very sparse matrices.
IEEE Trans. Inf. Theory, 45(2), 399–431.
[82] MacKay, D. J. C., and Davey, M. C. 2001. Evaluation of Gallager codes for short
block length and high rate applications. The IMA Volumes in Mathematics and its
Applications, 123(Jun.), 113–130.
[83] MacKay, D. J. C., and Neal, R. M. 1996. Near Shannon limit performance of low
density parity-check codes. Electro. Lett., 32(18), 1645–1646.
[84] Mann, H. 1949. Analysis and Design of Experiments. New York, NY: Dover.
[85] Mitchell, D. G. M., Smarandache, R., and Costello, D. J., Jr. 2014. Quasi-cyclic
LDPC codes based on pre-lifted protographs.
IEEE Trans. Inf. Theory, 60(10),
5856–5874.
17
17:13:11, subject to the Cambridge Core terms of use,

242
References
[86] Mitchell, D. G. M., Lentmaier, M., and Costello, D. J., Jr. 2015. Spatially coupled
LDPC codes constructed from protographs.
IEEE Trans. Inf. Theory, 61(9),
4866–4889.
[87] NASA, Standards. 2008. GSFC-STD-9100. https://standards.nasa.gov/documents/
viewdoc/3315856/3315856. Accessed May 4, 2015.
[88] Nguyen, T. V., Nosratinia, A., and Divsalar, D. 2012. The design of rate-compatible
protograph LDPC codes. IEEE Trans. Commun., 60(10), 2841–2850.
[89] Peterson, W. W., and Weldon, E. J., Jr. 1972. Error-Correcting Codes, 2nd edition.
Cambridge, MS, USA: MIT Press.
[90] Pishro-Nik, H., and Fekri, F. 2004. On decoding of low-density parity-check codes
over the binary erasure channel. IEEE Trans. Inf. Theory, 50(3), 439–454.
[91] Pishro-Nik, H., and Fekri, F. 2007. Results on punctured low-density parity-check
codes and improved iterative decoding techniques. IEEE Trans. Inf. Theory, 53(2),
599–614.
[92] Pusane, A. E., Smarandache, R., Vontobel, P. O., and Costello, D. J., Jr. 2011.
Deriving good LDPC convolutional codes from LDPC block codes. IEEE Trans.
Inf. Theory, 57(2), 835–857.
[93] Reed, I. S., and Solomon, G. 1960. Polynomial codes over certain ﬁnite ﬁelds. J.
Soc. Indust. Appl. Math., 8(2), 300–304.
[94] Richardson, T. 2003 (October 1–3). Error-ﬂoors of LDPC codes. Pages 1426–1435
of: Proc. 41st Annual Allerton Conf. Commun. Control, Computing. Monticello, IL,
USA, October 1–3, 2003.
[95] Richardson, T., and Urbanke, R. L. 2008. Morden Coding Theory. Cambridge, UK:
Cambridge University Press.
[96] Richardson, T. J., Shokrollahi, M. A., and Urbanke, R. L. 2001.
Design of
capacity-approaching irregular low-density parity-check codes.
IEEE Trans. Inf.
Theory, 47(2), 619–637.
[97] Ryan, W. E., and Lin, S. 2009. Channel Codes: Classical and Modern. New York,
NY: Cambridge University Press.
[98] Ryser, H. J. 1996. Combinatorial Mathematics. New York, NY: Wiley.
[99] Sassatelli, L., and Declercq, D. 2010. Nonbinary hybrid LDPC codes. IEEE Trans.
Inf. Theory, 56(10), 5314–5334.
[100] Song, S., Zhou, B., Lin, S., and Abdel-Ghaffar, K. 2009. A uniﬁed approach to the
construction of binary and nonbinary quasi-cyclic LDPC codes based on ﬁnite ﬁelds.
IEEE Trans. Commun., 57(1), 84–93.
[101] Tai, Y. Y., Lan, L., Zeng, L., Lin, S., and Abdel-Ghaffar, K. 2006.
Algebraic
construction of quasi-cyclic LDPC codes for the AWGN and erasure channels. IEEE
Trans. Commun., 54(10), 1765–1774.
[102] Tang, H., Xu, J., Lin, S., and Abdel-Ghaffar, K. 2005. Codes on ﬁnite geometries.
IEEE Trans. Inf. Theory, 51(2), 572–596.
[103] Tanner, R. M. 1981. A recursive approach to low complexity codes. IEEE Trans.
Inf. Theory, 27(5), 533–547.
[104] Tanner, R. M., Sridhara, D., Sridharan, A., Fuja, T. E., and Costello, D. J., Jr. 2004.
LDPC block and convolutional codes based on circulant matrices. IEEE Trans. Inf.
Theory, 50(12), 2966–2984.
[105] Thorpe, J. 2003.
Low density parity check (LDPC) codes constructed from
protographs. JPL INP Progress Report, August 15, 42–154.
[106] Townsend, R., and Weldon, E. 1967.
Self-orthogonal quasi-cyclic codes.
IEEE
Trans. Inf. Theory, 13(2), 183–195.
17
17:13:11, subject to the Cambridge Core terms of use,

References
243
[107] Vasic, B., and Milenkovic, O. 2004. Combinatorial constructions of low-density
parity-check codes for iterative decoding.
IEEE Trans. Inf. Theory, 50(6),
1156–1176.
[108] Vellambi, H., and Fekri, F. 2007. Results on the improved decoding algorithm for
low-density parity-check codes over the binary erasure channel. IEEE Trans. Inf.
Theory, 53(4), 1510–1520.
[109] Xu, J., and Lin, S. 2003 (Jun.).
A combinatoric superposition method for
constructing low density parity check codes. Page 30 of: Proc. IEEE Int. Symp.
Inf. Theory. Paciﬁco Yokohama, Yokohama, Japan, June 29–July 4, 2003.
[110] Xu, J., Lin, S., and Blake, I. F. 2003 (Mar.). On products of graphs for LDPC codes.
Pages 6–9 of: Proc. IEEE Inf. Theory Workshop. La Sorbonne, Paris, France, March
31–April 4, 2003.
[111] Xu, J., Chen, L., Zeng, L., Lan, L., and Lin, S. 2005. Construction of low-density
parity-check codes by superposition. IEEE Trans. Commun., 53(Feb.), 243–251.
[112] Xu, J., Chen, L., Djurdjevic, I., Lin, S., and Abdel-Ghaffar, K. 2007. Construction
of regular and irregular LDPC codes: Geometry decomposition and masking. IEEE
Trans. Inf. Theory, 53(1), 121–134.
[113] Zhang, L., Huang, Q., Lin, S., Abdel-Ghaffar, K., and Blake, I. F. 2010. Quasi-cyclic
LDPC Codes: An algebraic construction, rank analysis, and codes on Latin squares.
IEEE Trans. Commun., 58(11), 3126–3139.
[114] Zhang, L., Lin, S., Abdel-Ghaffar, K., Ding, Z., and Zhou, B. 2011. Quasi-cyclic
LDPC codes on cyclic subgroups of ﬁnite ﬁelds. IEEE Trans. Commun., 59(9),
2330–2336.
[115] Zhang, Z., Dolecek, L., Nikolic, B., Anantharam, V., and Wainwright, M. J. 2008
(November 30–December 4). Lowering LDPC error ﬂoors by postprocessing. Pages
1–6 of: Proc. IEEE Glob. Commun. Conf. New Orleans, LO, USA, November
30–December 4, 2008.
[116] Zhou, B., Kang, J., Tai, Y. Y., Lin, S., and Ding, Z. 2009.
High performance
non-binary quasi-cyclic LDPC codes on Euclidean geometries.
IEEE Trans.
Commun., 57(5), 1298–1311.
17
17:13:11, subject to the Cambridge Core terms of use,

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Index
More Information
www.cambridge.org
© in this web service Cambridge University Press
Index
2 × 2 SM-constraint, 74
2 × 2 array RC-constraint, 7
3 × 3 SM-constraint, 74
a posteriori probabilities, 228, 229
additive white Gaussian noise channel, 2
adjacency matrix of a graph, 2, 9, 17, 43, 47, 184
array
2 × 2 RC-constrained, 7, 112
τ-span sub-, 114, 115, 120, 122, 125, 127, 136
diagonal band, 111, 113, 120, 129
lower triangular, 130
parity-check, 8, 26, 27, 35, 40, 49, 53, 73, 108, 136,
167, 176, 177, 179, 187, 188, 191, 193, 208
RC-constrained, 7, 30, 53, 59, 62, 63, 65, 66, 69,
169
semi-inﬁnite, 113–118, 120, 122, 123, 125, 127,
129–133
triangular, 129, 132, 134
upper triangular, 130
AWGNC, see additive white Gaussian noise channel
B-to-NB, see binary-to-nonbinary replacement
backtracking iterative decoding algorithm, 13
balanced incomplete block designs, 51, 69
base matrices, 2, 4
2 × 2 SM-constrained, 77, 84, 92, 95, 97, 98, 135,
136, 154, 205, 210, 211
3 × 3 SM-constrained, 78, 210
binary, 32, 166
cyclic, 98, 127, 129, 135, 136, 211
decomposition, 22
integer, 21, 38, 40, 46, 49, 50, 184
masked, 78, 79, 90, 92, 93, 95, 97, 106, 210
nonbinary, 73, 74, 166
product, 155
PTG-based code construction, 17
RC-constrained, 51, 69, 71, 90, 209, 222
SP-LDPC code construction, 42
BCJR, 62
BEC, see binary erasure channel, see binary erasure
channel
BER, see bit error rate/probability
BIBDs, see balanced incomplete block designs, 69, 71
binary erasure channel, 4
bursts of erasure, 72, 92, 97, 138
erasure-burst, 94, 95, 152
erasures, 4, 211
binary input channels, 228
binary-input AWGNC, 166, 172
binary-to-nonbinary replacement, 176
bipartite graph, 9
CNs (check nodes), 9
cycle distribution, 10
cycles, 10
degree, 9
degree distribution, 10–12
edges, 9
girth, 10
paths, 9, 11
Tanner graph, 2, 7, 9
VN-connection distribution, 11
VN-connectivity, 12, 13
VNs (variable nodes), 9
bipartite graphs, see graphs, 2, 9
bit error rate/probability, 15
bitwise probabilities, 229
BLER, see block error rate/probability
block error rate/probability, 32
BMA (Berlekamp–Massey algorithm), 193
BP (belief propagation), 9
CBMSA, see compatible base matrix search algorithm
chain, 111
channel, 1
AWGN, 2, 6
BEC, 4, 6
channel capacities, 1
check-and-recover process, 94
circulant, 6
244

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Index
More Information
www.cambridge.org
© in this web service Cambridge University Press
Index
245
circulant permutation matrices, 5, 6
CN neighborhood, 229
CN-MPUs (check node message processing units), 14
CN-redundancy, 12
CNs (check nodes), 9
global, 138, 139
local, 138
code construction methods
algebraic-based, 1
graph-theoretic-based, 1
codes
Hamming, 53
LDPC, 1
LDPC convolutional, 111
RM (Reed–Muller), 62
RS (Reed–Solomon), 193
RS (Reed–Solomon), 99
collectively, 9, 12
column-block, 7
combinatorial designs, 2
compatible base matrix search algorithm, 226
component base matrices
horizontal, 155
vertical, 155
component codes
horizontal, 150
vertical, 150
component matrices
horizontal, 150
vertical, 150
component-wise mod-2 addition, 232
component-wise multiplication, 232
connection matrices, 17, 43, 141
connection number, 11
constituent matrices, 21
copy-and-permute, 17, 19, 26, 182
coset leader, 75
cosets, 75, 219
CPM-bD/B-to-NB, 176
CPM-D-SP-construction, 73
CPM-dispersion
q-ary, 174
binary, 8, 73, 74, 76, 78, 79, 178, 205
CPM-QC-SP-LDPC code, 73
CPMs, see circulant permutation matrices
q-ary, 173
binary, 6
cyclic classes, 54
cyclic convolution, 231
cyclic convolution theorem, 232
cyclic masking, 106
cyclic replacement, 45
cyclic-shift, 6, 22, 76
downward, 22
left, 76
right, 22
upward, 76
decoding convergence, 12–14
decoding matrix, 110
decoding threshold, 12, 15, 30, 32
density evolution, 41, 67
descendant, 52
diagonal replacement, 97
direct product, 150
doubly CPM-QC-SP-LDPC code, 98
doubly cyclic masking, 106
EG (Euclidean geometries), 51, 59, 218
ensemble, 3
block-cyclic, 38
PTG-LDPC code, 20, 38, 40, 50, 210
QC, 38
SP-LDPC code, 50, 210
erasure pattern, 93
error pattern, 13, 148
error-ﬂoors, 2, 3, 12–14, 18, 32, 41, 44, 151, 164, 206,
209
Euclids algorithm, 193
EXIT charts, 18, 41
expansion factor, 17, 18
expansion operation, 42
Fast-Fourier-Transform q-ary SPA, 166
FFT-QSPA, see Fast-Fourier-Transform q-ary SPA,
172
FG (ﬁnite geometries), 12, 15
FHT (fast Hadamard transform), 231, 233
ﬁnite ﬁelds, 1
fully parallel local phase, 148
GC (globally coupled LDPC codes), 138
CN-based, 138, 149, 150
CN-based CPM-QC-, 140, 142, 211
CN-based product, 138, 150, 151, 163,
164
CN-based product QC-, 154
VN-based, 162
VN-based CPM-QC-, 162, 163
generalized product code, 159
generalized PTG-LDPC code, 141
generator row-block, 22–24
geometries
Euclidean, 218
ﬁnite, 1
partial, 217
projective, 218
global decoder, 148
globally coupled, 138
graph expansion, 2, 17
graphs, 9
bipartite graphs, 9, 16
protographs, 17, 21
subgraphs, 11, 115, 165
Tanner graphs, 7, 9

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Index
More Information
www.cambridge.org
© in this web service Cambridge University Press
246
Index
groups
additive sub-, 75
cyclic sub-, 76, 95
multiplicative, 76
sub-, 75
Hadamard matrices, 234
Hadamard matrix product, 77
Hadamard transform, 232
Hamming codes, 53
cycle span, 54
minimum weight, 53
primitive codewords, 54
hybrid construction, 2
incidence matrix, see partial geometries
incidence vector, see partial geometries
index sequences, 23, 221
intersecting bundle, see partial geometries
inverse Hadamard transform, 232
iterative decoding algorithms based on BP, 9
Kronecker delta function, 232
KVA (K¨oetter–Vardy algorithm), 195
Latin squares, 63, 75, 192
orthogonal, 193
LDPC (low-density parity-check) codes, 1
algebraic, 2
binary, 4
cyclic, 8
doubly QC-, 98
EG-, 221
FG-, 15
GC-, 138
irregular, 8
LDPC convolutional codes, 111
masked, 78
NB (nonbinary), 166
PTG-, 16
PTG-based, 2
quasi-cyclic (QC), 8
regular, 8
RS-masked, 195, 196
SC-, 111
SP-, 41, 51
span-constrained, 111
tailbiting (TB), 125
lifting degree, 17, 18
LLR (log-likelihood ratio), 13, 148, 163
local decoder, 148
local/global two-phase decoding scheme, 138, 147,
211
locally connected, 111
MAP, 62
masking, 52, 72, 77, 193
masked base matrices, 78
masking matrices, 78
matrix decomposition, 21, 211
decomposition constraint, 21, 184
decomposition factor, 21, 22, 27, 184
decomposition set, 21, 25
decomposition-and-replacement process, 25, 26,
182, 209
matrix expansion, 22, 72, 136
minimum distance, 12, 13, 150–152
minimum weight, 53, 99
MSA (min-sum algorithm), 9
mutually disjoint, 7
NB-to-B, see nonbinary-to-binary mapping
non-uniform expansion, 42, 44
nonbinary input channels, 228
nonbinary-to-binary mapping, 73
nonzero column-block-span, 113
nonzero row-block-span, 120
one-zero constraint, 84, 95
orthonormal, 232
partial geometries, 217
EG-LDPC codes, 221
incidence matrix, 218, 224
incidence vector, 218, 224
intersecting bundle, 219, 220
lines, 217
parallel bundle, 219
points, 217
partially parallel local phase, 148
PEG algorithm, see progressive edge-growth, 1, 18,
92
period, 114
permutation
column, 23, 222
row, 23, 222
permutation matrices, 6
pmf (probability mass function), 228, 229
post-processing decoding strategies, 13
primitive element, 7
prior-processing decoding strategies, 13
product-form, 75
progressive edge-growth, 1
protograph, 2, 17
PTG-LDPC code, 2
PTG (protograph), 1
PW-R (pair-wise row) constraint, 149
PW-RC constrained matrices, 7
PW-RC constraint, 7
RC (row-column) constraint, 7
RC-constrained matrix, 7
reduced-complexity iterative decoding scheme, 98,
102, 108
redundant CNs, 11
redundant rows, 11
regular matrices, 6

Cambridge University Press
978-1-107-17568-6 — LDPC Code Designs, Constructions, and Unification
Juane Li , Shu Lin , Khaled Abdel-Ghaffar , William E. Ryan , Daniel J. Costello, Jr 
Index
More Information
www.cambridge.org
© in this web service Cambridge University Press
Index
247
replacement constraint, 45, 46, 55, 171
replacement set, 2, 42, 51
row-block, 7
row-redundancy, 12, 13
RS (Reed–Solomon) codes, 193
RS-base matrix, 198
RS-QC-SP-LDPC code, 198
SC-LDPC codes, 111
tailbiting, 125
terminated, 125
time-varying, 115
type-1 CPM-QC-, 115
type-2 CPM-QC-, 122
SER
see symbol-error rate, 199
Shannon limit, 1, 12
short cycles, 13
SNR (signal-to-noise ratio), 12
SP-base matrix, 42
SP-construction, 2, 41
SP-LDPC code, 2
SP-operation, 42
SPA (sum-product algorithm), 9
span-constraint, 111
SPB, see sphere packing bound, 12, 34
SPC (single parity-check code), 151
sphere packing bound, 12
stopping sets, 11, 12
strong connection, 3
structure
block-cyclic, 22–24, 29, 48, 56, 98–102, 106–108,
112, 114, 167, 170, 185, 186
cyclic, 98, 99, 110
doubly QC, 101, 102, 106, 211
section-wise cyclic, 24, 30, 47, 98, 101, 102, 110,
206
sum-form, 75
superposition, 2
symbol-error rate, 199
symbol-wise probabilities, 229
tailbiting SC-LDPC codes, 125
terminated SC-LDPC codes, 125
trapping sets, 11–13, 151, 164, 165, 212
elementary, 11
global, 212
harmful, 13
local, 164, 165, 212
small, 11, 13, 14, 165
turbo BP-decoder, 163
two-sided power spectral density, 229
UEBLR, see unresolved erasure block rate
UEBR, see unresolved erasure bit rate
uniﬁcation, 44
uniform expansion, 43
unresolved erasure bit rate, 32
unresolved erasure block rate, 32
vector label, 25
VN neighborhood, 229
VN-MPUs (variable node message processing units),
13, 14
weight
column, 6
row, 6
weight distributions, 10, 54
zero-constraint, 94
zero-spans, 93, 94

