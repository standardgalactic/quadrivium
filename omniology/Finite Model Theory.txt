springer Monographs in Mathematics 

Heinz-Dieter Ebbinghaus 
Jorg Flum 
Finite Model Theory 
Second Revised and Enlarged 
Edition 1999 
^Spri ringer 

Heinz-Dieter Ebbinghaus 
JorgFlum 
Mathematisches Institut 
Abteilung fur Mathematische Logik 
Universitat Freiburg 
Eckerstrafie i 
79104 Freiburg, Germany 
e-mail: hde@math.uni-freiburg.de 
joerg.flum@math.uni-freiburg.de 
The softcover edition was published in 1999 by Springer-Verlag under the same title in the 
series Perspectives in Mathematical Logic, 
Library of Congress Control Number: 2005932862 
Mathematics Subject Classification (2000): 03C13,03C80,03D15,68P15 
ISSN 1439-7382 
ISBN-10 3-540-28787-6 Springer Berlin Heidelberg New York 
ISBN-13 978-3-540-28787-2 Springer Berlin Heidelberg New York 
ISBN 3-540-65758-4 2nd Edition Springer-Verlag Berlin Heidelberg New York 
This work is subject to copyright. All rights are reserved, whether the whole or part of the material is concerned, specifically 
the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilm or in any 
other way, and storage in data banks. Duplication of this publication or parts thereof is permitted only under the 
provisions of the German Copyright Law of September 9,1965, in its current version, and permission for use must always 
be obtained from Springer. Violations are liable for prosecution under the German Copyright Law. 
Springer is a part of Springer Science+Business Media 
springeronline.com 
© Springer-Verlag BerHn Heidelberg 1995,1999,2006 
Printed in Germany 
The use of general descriptive names, registered names, trademarks, etc. in this publication does not imply, even in 
the absence of a specific statement, that such names are exempt from the relevant protective laws and regulations and 
therefore free for general use. 
lypeset by the authors using a Springer ET^K macro package 
Production: LE-T^ Jelonek, Schmidt & VOckler GbR, Leipzig 
Cover design: Erich Kirchner, Heidelberg 
Printed on acid-free paper 
46/3142YL - 5 4 3 210 

Preface 
Finite model theory, the model theory of finite structures, has roots in clas-
sical model theory; however, its systematic development was strongly influ-
enced by research and questions of complexity theory and of database theory. 
Model theory or the theory of models, as it was first named by Tarski in 
1954, may be considered as the part of the semantics of formalized languages 
that is concerned with the interplay between the syntactic structure of an 
axiom system on the one hand and (algebraic, settheoretic, ...) properties 
of its models on the other hand. As it turned out, first-order language (we 
mostly speak of first-order logic) became the most prominent language in this 
respect, the reason being that it obeys some fundamental principles such as 
the compactness theorem and the completeness theorem. These principles are 
valuable modeltheoretic tools and, at the same time, reflect the expressive 
weakness of first-order logic. This weakness is the breeding ground for the 
freedom which modeltheoretic methods rest upon. 
By compactness, any first-order axiom system either has only finite models 
of limited cardinality or has infinite models. The first case is trivial because 
finitely many finite structures can explicitly be described by a first-order 
sentence. As model theory usually considers all models of an axiom system, 
modeltheorists were thus led to the second case, that is, to infinite structures. 
In fact, classical model theory of first-order logic and its generalizations to 
stronger languages live in the realm of the infinite. Basic methods such as the 
methods of constructing models, and basic aims such as a structure theory 
for first-order axiomatizable classes of structures are essentially concerned 
with infinite structures and transfinite or settheoretic combinatorics. 
Nevertheless, there are natural reasons to consider finite structures. His-
torically, the most important one is the finite model property for certain 
classes of first-order formulas, that is, the equivalence of satisfiability and 
satisfiability in the finite. It was this property that settled the positive cases 
of the decision problem for prefix classes of first-order logic. 
However, it took some twenty years until the middle of the twentieth 
century to really ask questions of a modeltheoretic fiavour within the world of 
finite structures. The first landmarks here are Trahtenbrot's Theorem (1950) 
on the failure of the completeness theorem in the finite and the formulation 

VI 
Preface 
of the spectrum problem by Scholz (1952) that asks for a characterization of 
spectra in the finite of first-order sentences. 
In both cases, computational aspects play their part: Trahtenbrot's proof 
rests on the undecidability of the halting problem for machines, and the spec-
trum problem turned out to be intimately Unked to the question whether de-
terministic and nondeterministic polynomial time complexity coincide. The 
influence of computational aspects can be explained in various ways. First 
of all, finite structures can be coded as words and hence, can be objects of 
computations. Moreover, finite structures can serve to describe finite runs of 
machines. Finally, formulas of a logical language often can be interpreted as 
programs that, given a structure as input, perform the corresponding evalua-
tion. This viewpoint is of importance, for example, in database theory, where 
relational databases are considered as finite structures. 
We now give a short description of the contents of the book, at the same 
time motivating the choice of material and the emphasis it has been given. 
Chapter 1 provides basic material concerning first-order logic. Chapters 
2 and 3 are of a purely modeltheoretic character. When restricting oneself 
to finite structures, the essential theorems of first-order logic fail (this is 
documented at the end of Chapter 3) and important methods get trivial 
or useless. However, the gametheoretic methods of Ehrenfeucht and Fraisse 
survive or even gain a special power. They are developed for first-order logic 
in Chapter 2 and for second-order and infinitary extensions in Chapter 3. Our 
representation is strongly based on isomorphism types (or, Hintikka formulas) 
as a unifying feature. 
When turning to the finite, settheoretic combinatorics get replaced by 
finite combinatorics. As a consequence, there are new questions, for instance, 
questions of the kind: What is the relative frequency of graphs versus struc-
tures or of connected graphs versus graphs? Chapter 4 is dedicated to results 
aiming in this direction, so-called 0-1 laws, for first-order logic and some ex-
tensions. They say that for relational formulas either almost all or almost no 
finite structure is a model. 
Chapter 5 treats the finite model property for some fragments of first-
order logic, namely for the two-variable logic that consists of first-order for-
mulas with only two variables, and for the class of V3-formulas. The choice 
of the first logic is motivated by the methodological role of logics with a re-
stricted number of variables, the choice of the second one by its relationship 
to concepts of the preceding chapter. 
As has already been remarked, many questions in finite model theory are 
related to or even arose from questions in complexity theory. Chapter 6 gives 
an account of these connections on the computational level of finite automata. 
When considering automata or even more powerful machines, it quickly 
becomes clear that first-order logic does not provide an adequate framework 
on the logical side because first-order logic lacks the ability of adequately 
expressing recursive procedures. This weakness of expressive power corre-

Preface 
VII 
spends to a similar phenomenon in classical model theory, and in a similar 
way as there, one can try to overcome this deficiency by introducing more 
powerful languages. In finite model theory, various so-called fixed-point log-
ics have turned out to be promising candidates. They allow to speak about 
fixed-points of definable iteration procedures; the weakest one just allows to 
speak about the transitive closure of a definable binary relation. 
Chapter 7 (together with Chapter 8) forms the core of the book. After 
a short introduction to fixed-point logics it develops what is known as the 
theory of descriptive complexity. Given a resource-bounded machine model, 
say the model of polynomially time-bounded Turing machines, and a suitable 
logic £, say least fixed-point logic, then for every machine M of this kind there 
is a sentence ^ of C whose models are just the structures accepted by M, 
and for every sentence (p oi C there is a machine M of this kind that just 
accepts the models of if. Hence, the classes of structures that are acceptable 
by a polynomially time-bounded machine, correspond to the classes that are 
axiomatizable in £. In this way, one obtains logical descriptions of complexity 
classes and, therefore, logical analogues of major problems in complexity 
theory. For example, the PTIME = PSPACE-problem now amounts to the 
question whether two fixed-point logics have the same expressive power in 
finite structures. The chapter gives an account of the most important results 
of this kind. As it turns out, they mostly presuppose that the structures 
considered are ordered. This assumption seems to be natural, since we induce 
an ordering on the universe of a structure, when encoding it as an input string. 
On the other hand, some major open problems of descriptive complexity 
theory are concerned with the question to what extent the descriptive results 
can be generalized to structures without an ordering. 
The proof indicated above, for the fact that least fixed-point logic corre-
sponds to PTIME, yields that any sentence (p of this logic is equivalent to 
a sentence describing the behaviour of a machine and hence, has a special 
syntactical structure. So, as a byproduct of the logical characterizations of 
complexity classes, one gets certain normal forms for the logics involved. 
Chapter 8 (with parts of Chapter 9) presents the model theory of fixed-
point logics for finite structures. The material presented includes a thorough 
discussion of transitive closure logics, as well as connections to second-order 
logic and infinitary logics. 
Chapter 9 takes up the viewpoint of formulas as programs or queries, 
introducing a bunch of programming languages of the DATALOG family 
in database theory. The main aim here is to show the equivalence of these 
languages with certain fixed-point languages, thus opening another method-
ological gateway to the latter ones. The way pays, as can be seen by new and 
far reaching possibilities of obtaining normal forms. The chapter concludes 
with the investigation of the fine structure of fixed-point languages. 

VIII 
Preface 
Chapter 10 lies outside the mainstream of the book. It is concerned with 
a logically-oriented representation of optimization problems, but is restricted 
to basic material. 
Chapter 11 is concerned with one of the most prominent open problems 
of finite model theory, namely whether there is a logic that captures PTIME 
also on unordered structures. As it turns out, this question is linked to the 
problem of feasibily characterizing finite structures by invariants. By coding 
structures in graphs we reduce the problem to the case of graphs. The chapter 
ends by providing positive answers for some classes of graphs, thus illustrating 
an at the present time active direction of research. 
Finally, Chapter 12 discusses a concept that is well-known from classical 
model theory, the concept of a quantifier. The idea here is the following: In 
order to find a logic £ that corresponds to a complexity class C in the sense 
described above, one can try to start with a simple logic, say first-order logic, 
and add a quantifier that incorporates a C-complete problem. When pursuing 
this idea, one has to find analogues of notions from complexity theory such 
as reductions, hardness, completeness, etc. The chapter concludes with an 
example of the analogy between quantifiers in logic and oracles in complexity 
theory. 
As the preceding description shows, the core of the book is centered 
around modeltheoretic issues related to descriptive complexity. Such a con-
centration seemed to be necessary in order to come along with a book of a 
reasonable size. Among the major gaps the reader will encounter we mention 
two ones lying at opposite ends of the spectrum of possible topics: the theory 
of circuits on the more computational side and the work related to a struc-
ture theory for the finite on the more modeltheoretic side. Concerning topics 
of the first group we refer the reader to Neil Immerman's recent monograph 
"Computational Complexity". 
Some chapters are as independent from each other as their contents allows. 
In particular, a reader interested in descriptive complexity theory should not 
have problems to start with Chapter 7. And a modeltheorist interested in the 
finite model theory of fixed-point logics can start with Chapter 8. 
This second edition is a thoroughly revised and enlarged version of the 
original text, the most relevant addition being the new Chapter 11. Moreover, 
we have tried to take into consideration criticism and suggestions of readers 
of the first edition. Again, with gratitude we mention Martin Grohe: his 
proposals and his results have influenced and enriched considerable parts of 
the text. 
Freiburg, April 1999 
Heinz-Dieter Ebbinghaus 
Jorg Flum 

Table of Contents 
Preface 
V 
1. 
Preliminaries 
1 
2. 
The Ehrenfeucht-Fraisse Method 
13 
2.1 Elementary Classes 
13 
2.2 Ehrenfeucht's Theorem 
15 
2.3 Examples and Fraisse's Theorem 
20 
2.4 Hanf's Theorem 
26 
2.5 Gaifman's Theorem 
30 
3. 
More on Games 
37 
3.1 Second-Order Logic 
•. 
37 
3.2 Infinitary Logic: The Logics Looo; cind L^^^; 
40 
3.3 The Logics FO^ and L^^ 
46 
3.3.1 
Pebble Games 
49 
3.3.2 
The s-Invariant of a Structure 
54 
3.3.3 Scott Formulas 
56 
3.4 Logics with Counting Quantifiers 
58 
3.5 Failure of Classical Theorems in the Finite 
62 
4. 
0-1 Laws 
71 
4.1 0-1 Laws for FO and L^^ 
71 
4.2 Parametric Classes 
74 
4.3 Unlabeled 0-1 Laws 
77 
4.3.1 Appendix 
82 
4.4 Examples and Consequences 
84 
4.5 Probabilities of Monadic Second Order Properties 
88 
5. 
Satisfiability in the Finite 
95 
5.1 Finite Model Property of FO^ 
95 
5.2 Finite Model Property of V23*-Sentences 
99 

X 
Table of Contents 
6. 
Finite Automata and Logic: A Microcosm of Finite Model 
Theory 
105 
6.1 Languages Accepted by Automata 
105 
6.2 Word Models 
108 
6.3 Examples and Applications 
I l l 
6.4 First-Order Definability 
114 
7. 
Descriptive Complexity Theory 
119 
7.1 Some Extensions of First-Order Logic 
120 
7.2 Turing Machines and Complexity Classes 
124 
7.2.1 Digression: Trahtenbrot's Theorem 
127 
7.2.2 
Structures as Inputs 
129 
7.3 Logical Descriptions of Computations 
133 
7.4 The Complexity of the Satisfaction Relation 
147 
7.5 The Main Theorem and Some Consequences 
151 
7.5.1 Appendix 
162 
8. 
Logics with Fixed-Point Operators 
165 
8.1 Inflationary and Least Fixed-Points 
165 
8.2 Simultaneous Induction and Transitivity 
177 
8.3 Partial Fixed-Point Logic 
191 
8.4 Fixed-Point Logics and L^^ 
198 
8.4.1 The Logic F O ( P F P P T I M E ) 
205 
8.4.2 
Fixed-Point Logic with Counting 
207 
8.5 Fixed-Point Logics and Second-Order Logic 
210 
8.5.1 
Digression: Implicit Definability 
217 
8.6 Transitive Closure Logic 
220 
8.6.1 
FO(DTC) < FO(TC) 
221 
8.6.2 
FO(posTC) and Normal Forms 
224 
8.6.3 
FO(TC) < FO(LFP) 
229 
8.7 Bounded Fixed-Point Logic 
235 
9. 
Logic Programs 
239 
9.1 DATALOG 
239 
9.2 I-DATALOG and P-DATALOG 
245 
9.3 A Preservation Theorem 
250 
9.4 Normal Forms for Fixed-Point Logics 
253 
9.5 An Application of Negative Fixed-Point Logic 
263 
9.6 Hierarchies of Fixed-Point Logics 
268 
10. Optimization Problems 
275 
10.1 Polynomially Bounded Optimization Problems 
275 
10.2 Approximable Optimization Problems 
280 

Table of Contents 
XI 
11. Logics for PTIME 
287 
11.1 Logics and Invariants 
288 
11.2 PTIME on Classes of Structures 
295 
12. Quantifiers and Logical Reductions 
307 
12.1 Lindstrom Quantifiers 
308 
12.2 PTIME and Quantifiers 
314 
12.3 Logical Reductions 
320 
12.4 Quantifiers and Oracles 
330 
References 
339 
Index 
349 

1. Preliminaries 
The purpose of this section is to fix notations and terminology for the basic 
notions related to first-order logic. We assume that the reader has already 
some familiarity with these concepts, as it is obtained by an introductory 
course in mathematical logic. For more detailed information we refer to text-
books such as [32, 35]. Parts of our exposition in part B follow [9]. 
A 
Structures 
Vocabularies are finite sets that consist of relation symbols P, Q, R, ... and 
constant symbols (for short: constants) c, d, —^ Every relation symbol is 
equipped with a natural number > 1, its arity. We denote vocabularies by 
T, C7, 
A vocabulary is relational, if it does not contain constants. 
A structure A of vocabulary r (by short: a r-structure) consists of a 
nonempty set A, the universe or domain of A, of an n-ary relation R-^ on A 
for every n-ary relation symbol i^ in r, and of an element c-^ of A for every 
constant c in r. (Mostly we use the notations R^ for R^ and c^ for c^.) An 
n-ary relation R^ on A is a subset of A^, the set of n-tuples of elements of 
A. We mostly write R^ai ... a^ instead of (ai,..., a^) G R^. A structure A 
is finite, if its universe A is a finite set. 
We give some examples of structures that will play a prominent role in 
the book. 
Al Graphs 
Let r = {E} with a binary relation symbol E. A graph (or, undirected graph) 
is a r-structure Q = {G,E^) 
satisfying 
(1) for all aeO: 
not E^aa 
(2) for all a,beG: 
if E^ab then E^ba. 
By GRAPH we denote the class of finite graphs. If only (1) is required, we 
speak of a digraph (or, directed graph). The elements of G are sometimes called 
points or vertices, the elements of E^ edges. The following figures represent 
^ Usually also function symbols are allowed in vocabularies. For the purposes of 
this book our definition does not represent an essential restriction. We explain in 
part D how the results can be extended to vocabularies with function symbols. 

1. Preliminaries 
the graph ({a, 6, c, d}, {(a, 6), (6, a), (6, c), (c, 6), (6, d), (d, 6), (c, d), (rf, c)}) and 
the digraph ({a, 6, c, d}, {(a, 6), (6, a), (6, c), (6, c?), (d, c)}). 
A subset X of the universe of a graph ^ is a clique, if E^ab for all a, 6 G X, 
a^b. 
Let ^ be a digraph. If n > 1 and 
'aia2,... ,E 
an-idn 
then ao,..., fln is a pa^/i from ao to a^ of length n. If ao = an then ao,..., a^ 
is a c?/c/e. ^ is acyclic if it has no cycle. A path ao,..., fln is Hamiltonian if 
G = {ao,.. •, an} and a^ 7^ a^ for z ^ j . If, in addition, E^ando we speak of 
a Hamiltonian circuit. 
Let ^ be a graph. Write a ~ 6 if a = 6 or if there is a path from a to b. 
Clearly, ~ is an equivalence relation. The equivalence class of a is called the 
{connected) component of a. G is connected if a ~ 6 for all a,b ^ G, that is, 
if there is only one connected component. Let CONN be the class of finite 
connected graphs. 
Denote by d{a, b) the length of a shortest path from a to 6; more precisely, 
define the distance function d : G x G ^ NU {00} by ^ 
d{a, b) = 00 iff a / 6; 
d{a, 6) = 0 iff a = b; 
and otherwise, 
d{a, b) = min{n > 1 | there is a path from a to 6 of length n). 
Obviously, 
d{a, c) < d{a, b) + d{b, c), 
where we use the natural conventions for 00. 
For simplicity, we give the following definitions only for finite digraphs. A 
vertex 6 is a successor of a vertex a (and a a predecessor of b) if E^ab. The 
in-degree of a vertex is the number of its predecessors, the out-degree the 
number of its successors. In graphs the in-degree and the out-degree of a 
vertex a coincide and are called the degree of a. 
denotes the set of natural numbers, N = {0,1,2,...}. 

1. Preliminaries 
3 
A root of a digraph is a vertex with in-degree 0 and a leaf a vertex with 
out-degree 0. 
A forest is an acychc digraph where each vertex has in-degree at most 1. 
A tree is a forest with connected underlying graph, i.e., a forest {G, E^) such 
that (G, {(a, 6) | E'^ab or E^ba}) is connected. Note that a finite tree has 
exactly one root. Let TREE be the class of finite trees. 
A2 Orderings 
Let r = {<} with a binary relation symbol <. A r-structure A — (A, <^) is 
called an ordering if for all a, 6, c G A: 
(1) not a <^ a 
(2) a <^ h or h <^ a or a — h 
(3) if a <^ 6 and h <^ c then a <^ c. 
Sometimes we consider finite orderings also as {<, 5, min, max}-structures. 
Here 5 is a binary relation symbol representing the successor relation and 
min and max are constants for the first and the last element of the ordering. 
(When considering the natural ordering on {0,... ,n} we often refer to min 
as the zero-th element.) Thus, a finite {<, S*, min, max}-structure A is an 
ordering if, in addition to (1), (2), (3), for all a, 6 G A : 
(4) S^ah iff (a <^ h and for all c, if a <^ c then h <^ c ov h — c) 
(5) min"^ <^ a or min"^ = a 
(6) a <^ max^ or a = max^. 
For other purposes it might be advantageous to consider finite orderings as 
{<, min, max}-structures. Suppose that TQ is a vocabulary with {<} C TQ C 
{<,5, min,max} and let a be an arbitrary vocabulary with TQ C a. Later in 
this book the class 0[a\ of finite ordered cr-structures will play a prominent 
role. Here a finite cr-structure Vl is said to be ordered^ if the reduct A\TQ 
(i.e., the ro-structure obtained from A by forgetting the interpretations of 
the symbols in cr \ TQ) is an ordering. 
A3 Operations on Structures 
Two r-structures A and B are isomorphic^ written A = B^ li there is an 
isomorphism from A to B, i.e., a bijection TT: A —)• B preserving relations and 
constants, that is, 
— for n-ary R E r and a i , . . . , a^ G A, 
R^ai...an 
iff 
jR^7r(ai).. .7r(an) 
- for c G r, 7r(c^) = c^. 
For r-structures A and B, the product A x B of A and B is the r-structure 
with domain A x B := {(a, b) \ a e A,b e B}, which is given by 

4 
1. Preliminaries 
— for n-ary R in T and (ai, 61),..., (a^, bn) ^ A x B, 
i?^^^(ai, 61)... (an, bn) 
iff 
R^ai ...an and R^bi 
...bn 
- for c in r, c^^^ := (c^,c^). 
For relational r we introduce the union (or, disjoint union) of structures. 
Assume that ^ and ;B are r-structures with AOB = i/). Then AU8, the wmon 
of ^ and i5, is the r-structure with domain AU B and 
for any i? in r. In case A and H are structures with An B / 0, we take 
isomorphic copies A' of A and B' of B with disjoint universes (e.g., with 
universes A x {1} and B x {2}) and set AuB := ^'Ui3'. 
Note that the union of ordered structures is not an ordered structure. 
The situation is different for the so-called ordered sum: Let r with <G r be 
relational and let A and B be ordered r-structures. Assume that AOB = i/). 
Define A<\B, the ordered sum of A and B, as AuB but setting 
^A<iB _ 
<^u<^U 
{{a,b)\aeA,beB}, 
that is, in A<\B all elements of A precede all elements oi B. 
Note that A x B ^ B x A, AuB ^ >BU^ but, in general, A < B ^ B < A. 
The definition of product, union, and ordered sum can easily be extended to 
more than two structures setting, for example, A<B<C:= 
{{A < B) <\C). 
For a finite nonempty set / we denote by A^, OjA, and <iA the product, 
the union, and the ordered sum, respectively, of ||/|| copies of A. Here ||/|| 
denotes the cardinality of /. 
B 
Syntax and Semantics of First-Order Logic 
We now turn to the syntactic notions of first-order logic FO. Fix a vocabulary 
r. Each formula of first-order logic will be a string of symbols taken from the 
alphabet consisting of 
— f 1, f 2 5 ^3, • • • 
(the variables) 
— ->, V 
(the connectives not, or) 
— 3 
(the existential quantifier) 
— = 
(the equality symbol) 
— the symbols in r. 
A term of vocabulary r is a variable or a constant in r. Henceforth, we often 
shall use the letters x, y, z, ... for variables and t, ^i, ... for terms. 
The formulas of first-order logic of vocabulary r are those strings which are 
obtained by finitely many applications of the following rules: 

1. Preliminaries 
5 
(Fl) If to and ti are terms then to == ^i is a formula. 
(F2) If i? in r is n-ary and ti,... 
,tn are terms then Rti .. .tn is a formula. 
(F3) If (^ is a formula then -xy? is a formula. 
(F4) If (^ and ij; are formulas then (</? V '0) is a formula. 
(F5) If (/9 is a formula and x a variable then 3x(p is a formula. 
Denote by FO[r] the set of formulas of first-order logic of vocabulary r. For-
mulas obtained by (Fl) or (F2) are called atomic formulas. For formulas ip 
and ip we use {(p Aip), {(p -^ ip), (cp -^ ip), and \fxcp as abbreviations for the 
formulas -^{-^(fi V -«^), (->(/? V ip), ((-"(^ V ip) A {-^ip V (^)), and -<3x-^ip, respec-
tively. 
We shall often omit parentheses in formulas if they are not essential such 
as the outermost parentheses in disjunctions {(fV ip). In examples, different 
letters x, y, z... will always stand for diflFerent variables. 
The axioms for graphs stated above have the following formalizations in 
FO[{E}]: 
yx^Exx 
\fx\/y{Exy -^ Eyx), 
those for orderings the following formalizations in FO [{<}]: 
\/x-^x < X 
\lx\ly{x <y\/y<x\/x 
— y) 
\/x'iy\lz{{x 
<y/\y<z)^x<z). 
For orderings as {<, 5', min, max}-structures we need in addition 
\/x\/y{Sxy <r^ {x < y A \/z(x <z^[y<z\Jy 
= z)))) 
Va;(min < x V min = x) 
\fx{x < max V X = max). 
All these formulas are sentences, i.e., formulas in which every variable in 
an atomic subformula is in the scope of a corresponding quantifier. Such 
occurrences are called bound occurrences. The last occurrence of x in 
iyx-^Exx A 3yExy) 
is not in the scope of a quantifier binding it. Such occurrences are called free. 
The notion of a free variable of a formula cp is made precise by the following 
definition, a definition by induction on (the length of) (p: The set free((^) of 
free variables of a formula (p is defined by: 
- If (/? is atomic then the set free((/?) of free variables of (p is the set of 
variables occurring in cp 
— hee{-^(p) := fYee{ip) 
— free{(p V ip) :— free((/?) U free(V^) 
- free(3a:(^) := free((/?) \ {x}. 

6 
1. Preliminaries 
It is common practice to use the notation ip(xi,... 
,Xn) to indicate that 
X 2 ^ • • • ^ Jufi 
(XI. t3 distinct and free((/?) C {xi,... 
,Xn} without implying that 
all Xi are actually free in ip (in some chapters of the book we shall give 
another meaning to this notation). Often we abbreviate an n-tuple x i , . . . , Xn 
of variables by x, for example, writing ip{x) for (p{xi,..., 
Xn)- Usually we do 
not make explicit the length of x (here n), its size either being inessential or 
clear from the context. Moreover, we often omit commas writing, for example, 
«/y 
Jy']^ • • • dy Yi • 
So far, terms and formulas of FO are simply finite strings of symbols. We now 
assign the intended meanings to the logical symbols so that, in particular, 
the sentences above really formalize the axioms of graphs and orderings. We 
do this by defining the satisfaction relation A\= ^ between structures on the 
one hand and sentences on the other hand. 
Let ^ be a r-structure. An assignment in ^ is a function a with domain 
the set of variables and with values in A, a : {vn \ n > 1} -^ A. Think of a as 
assigning the meaning a{x) to the variable x. Extend a to a function defined 
for all terms by setting a(c) := c"^ for c in r. Denote by a^ the assignment 
that agrees with a except that ct^{x) = a. 
We define the relation 
A \= ip[a] 
("the assignment a satisfies the formula (p in ^ " or 'V is true in A under 
a") as follows: 
A\=^ti 
=t2[a] 
A\=Rti...tn[a] 
A h -<PN 
A[^{ipWi^)[a] 
A \= 3x(p[a] 
iff 
iff 
iff 
iff 
iff 
a{ti) = a{t2) 
R^a{ti)...a{tn) 
not ^ 1= (yi?[a] 
A \= ip[a\ or A [= ipla] 
there is an a G A such that A \= 9^[CK^]. 
Note that the truth or falsity of ^ |= Lp[a] depends only on the values of 
a for those variables x which are free in cp. That is, if ai{x) = a2{x) for 
all X G free((^), then A \= ^[ai] iff ^ |= (/?[CK2]- Thus, if (p = (p{xi,... 
,Xn) 
and ai = a{xi),... 
,an — a{xn), then we may write A |= V^[ai,...,a^] 
for A \= ^[a]- In particular, if (p is a sentence, then the truth or falsity of 
^ (= (^[a] is completely independent of a. Thus we may write A\= (p (read: 
v4 is a model of cp, or A satisfies cp), if for some (hence every) assignment a, 
A \= (p[oi]. For a set ^ of formulas, A (= ^[a] means that A |= ^[a] for all 
(p € ^. ^ is satisfiable if there is a structure A and an assignment a in ^ such 
that^^^H. 
A formula T/J is a consequence of #, written ^ \=^ ip, ii A \= ip[a\ whenever 
A 1= ^[a]. The formula ip is logically valid, written |= ^, if 0 |= -0, that is, if 
ip is true in all structures under all assignments. And formulas ip and ip are 
logically equivalent if \= ^ -(r^ ip. When only taking into consideration finite 

1. Preliminaries 
7 
structures, we use the notations ^ |=fin ip and |=fin ^ , and speak of equivalent 
formulas; hence, cp and ip are equivalent if [=fin ^ -^ ip^ that is, if cp -H- ^ 
holds in all finite structures under all assignments. 
At some places it will be convenient to assume that first-order logic contains 
two zero-ary relation symbols T, F. In every structure, T and F are interpreted 
as TRUE (i.e., as being true) and FALSE, respectively. Hence, the atomic 
formula T is logically equivalent to 3xx — x and F to -^3xx = x. If ^ = 
{(/?i,..., cpn} we sometimes write /\ ^ for cpiA.. .Aipn and V ^ for (piW.. .V(/?n-^ 
In case <? = 0 we set /\ ^ = T and \/ ^ = F. Then, for arbitrary finite ^, 
A\= l\^ 
iff 
for all (p e #, ^ 1= (yc. 
We introduce some further syntactic notions and notations. The 
quantifier 
rank qr((/?) of a formula (f is the maximum number of nested quantifiers 
occurring in it: 
qr(<^) 
:= 
0, 
if (/? is atomic; 
qr(~'V^) 
'•= qr((^); 
qr((/?V'0) 
:= 
max{qr((p),qr(^)}; 
(\i{3x^) 
:= 
qr((/p) + 1. 
It can be shown that every first-order formula is logically equivalent to a for-
mula in prenex normal form, that is, to a formula of the form QiXi.. 
.QgXgip, 
where Qi,- •. ,Qs € {V, 3} and where ip is quantifier-free. Such a formula is 
called Sn, if the string of quantifiers consists of n consecutive blocks, where 
in each block all quantifiers are of the same type (i.e., all universal or all ex-
istential), adjacent blocks contain quantifiers of different type, and the first 
block is existential. Tin formulas are defined in the same way, but now we 
require that the first block consists of universal quantifiers. A A^-formula is 
a formula logically equivalent to both a E^-formula and a Il^-formula. 
If (fi{xi,.. 
.,Xn) is a formula and ti,... 
,tn are terms then ^^~^ 
or, more 
simply, ip{ti,... 
,tn) denotes the result of simultaneously replacing all free oc-
currences of xi,... 
,Xnhy 
ti,... 
,tn, respectively. This presupposes that none 
of the variables in ti,... 
,tn gets into the scope of a corresponding quanti-
fier; otherwise, the bound variables in if must be renamed in some canonical 
fashion before replacing. 
Given a formula ^{x,^) 
and n 
>1, 
3^''xip{x,z) 
is an abbreviation for the formula 
3xi...3Xn{ 
/ \ 
^(Xi,z) 
A 
f\ 
^Xi=Xj) 
l<i<n 
l<i<j<n 
^ For definiteness, given the vocabulary r, fix an ordering on the alphabet of first-
order logic and interpret a conjunction / \ ^ for a finite set <? as the iterative 
conjunction of the elements of ^ in the induced lexicographic ordering, say. 

1. Preliminaries 
expressing that there are at least n elements x with (p{x, z). 3~'^XLp{x^ z) and 
3-'^xip{x^'z) are defined similarly. Moreover, we set 
i^yn '-— 3-"'a;X = X] 
^-n 
'-— 3~^XX 
— X] 
ip<n •= 3-"'XX = X. 
Clearly, 
A ^ (p>n 
iff 
||A|| > n 
and, similarly, for ^=n and v^<n-
C 
Some Classical Results of First-Order Logic 
First-order logic has been used as a framework to analyze the notion of math-
ematical proof. A result of this analysis is Godel's Completeness Theorem: 
A mathematical proof of ip from ^ shows that ^ \= ip, i.e. that -0 is a conse-
quence of <?. A natural question is whether the converse holds, too, that is, 
whether for any consequence there is a proof. To give an answer, Godel used 
a notion of formal proof that is based on a finite system of formal rules. A 
formal proof of ip from # consists of a sequence of applications of these rules 
leading from the formulas in # to V^.^ In a natural way every formal proof 
corresponds to a mathematical proof. Thus, if ^ is formally provable from ^ 
then ^ is a consequence of ^. Moreover, Godel showed: 
Theorem 1.0.1 (Completeness Theorem) ip is a consequence of ^ iff ij) 
is formally provable from #. 
Two immediate consequences are: 
Theorem 1.0.2 The set of logically valid sentences of first-order logic is 
recursively enumerable. 
Theorem 1.0.3 (Compactness Theorem) (a) Ifip is a consequence of^ 
then ip is already a consequence of a finite subset of #. 
(b) // every finite subset of ^ is satisfiable then # is satisfiable. 
The proof of the Completeness Theorem often leads to a proof of 
Theorem 1.0.4 (Lowenheim-Skolem Theorem) // <? has a model then 
^ has an at most countable model. 
Neither 1.0.2 nor 1.0.3 remain valid if one only considers finite structures. 
A counterexample for the Compactness Theorem is given by the set #oo •= 
W>n I n > 1}: Each finite subset of ^oo has a finite model, but ^oo has no 
finite model. 
The failure of 1.0.2 is documented by 
Theorem 1.0.5 (Trahtenbrot's Theorem) The set of sentences of first-
order logic valid in all finite structures is not recursively enumerable. 
We do not give detailed definitions, since we do not need them later. 

1. Preliminaries 
9 
A proof will be given in section 7.2. 
We derive a consequence of the Compactness Theorem, which will be used 
in section 2.5. 
Lemma 1.0.6 Let Lp G FO[r] and for i G I, let <?* C FO[r]. Assume that 
(*) 
\=^^\l f\^\^ 
Then there is a finite IQ C I and, for every i £ IQ, a finite ^Q C ^* such that 
\=^^ V A*o-
ieio 
Proof For simplicity we assume that (p is a sentence and that every ^* is 
a set of sentences. By hypothesis, for i G / we have #* |= (/?; hence, by 
the Compactness Theorem, ^l^ \= cp for some finite ^Q C ^\ and therefore, 
N Vie/ A ^0 ^ V^ fo^ ea^ch finite subset IQ C /. If there is no such IQ with 
\= if ^ ViG/o A ^0 5 then each finite subset of {(/?} U {-> A ^o M ^ ^} ^^^ ^ 
model. Hence, by the Compactness Theorem, there is a model of (p which for 
alii G / satisfies -• A^o- ^^i^ contradicts (*). 
D 
Structures A and 8 (of the same vocabulary) are said to be elementarily 
equivalent, written A = B, if they satisfy the same first-order sentences. The 
preceding lemma has the following 
Corollary 1.0.7 Let ^ be a set of first-order sentences. Assume that any 
two structures that satisfy the same sentences of # are elementarily equiva-
lent. Then any first-order sentence is equivalent to a boolean combination of 
sentences of ^ {that is, is equivalent to a sentence obtainable by closing ^ 
under -i and V). 
Proof. For any structure A set 
^{A) 
:= {il;\ip e^, 
A\=ip}u 
{-.^ \^l) e^, 
A\= ^V'}-
Let if be any first-order sentence. By the preceding lemma it suflfices to show 
that 
> ^ ^ V /\^{A). 
Clearly, ii B [= (p then B \= V^t^v? ^ ^ ( ^ ) ' since B |= ^{B). For the converse, 
suppose B \= \lj\^^^ f\^{A). 
Then for some model A of v?, B |= ^{A). By 
definition of ^(v4), A and B satisfy the same sentences of ^ and hence, by 
hypothesis, are elementarily equivalent. Therefore, B \= (p. 
D 
^ This means that under any assignment in any structure, (p is true iff for some 
i G / all formulas in #^ are true. 

10 
1. Preliminaries 
D 
Model Classes and Global Relations 
Fix a vocabulary r. For a sentence (f of FO[r] we denote by Mod((/?) the class 
of finite models of (p. If TT is an isomorphism from A to B, ^{xi,..., 
Xn) G 
FO[T], and a i , . . . , a^ G A, then an easy induction on formulas shows 
(1) 
^ 1= (^[ai,...,an] 
iff 
B ^(/?[7r(ai),...,7r(an)]. 
In particular, if </? is a sentence then 
A^ip 
iff 
B^p. 
Hence, Mod((p) is closed under isomorphisms, that is, 
(2) 
A e Mod(99) and ^ ^ H imply B E Mod{ip). 
For (p{xi,... ,Xn) G FO[r] and a structure ^ let 
V?"^(_) 
:= 
{(ai,...,an) I A\= (p[ai,..., an]} 
be the set of n-tuples defined by ^ in A. For n = 0 this should be read as^ 
A ,_ f TRUE 
if A ^ if 
^^^ 
'^^ •" ^ FALSE 
if 
A^ip. 
Using this notation we can rewrite (1) as 
(4) 
ifniA^B 
then 7r((p^(_)) = v?^(_) 
where for X C A^ we set n{X) := {(7r(ai),... ,7r(an)) | (oi, • • • ,On) G X}. 
Later we are going to study various logics that extend first-order logic. In 
all of these logics only structural properties, that is, properties invariant 
under isomorphisms, will be expressible. So the analogues of (2) and (4) will 
be true. In particular, (2) says that only classes of structures closed under 
isomorphisms can be axiomatizable in these extensions. Only such classes will 
be of interest. We therefore agree upon the following convention: 
Throughout the book all classes K of structures considered will tacitly be 
assumed to be closed under isomorphisms, i.e., 
AeK 
and A^B 
imply B e K. 
(4) shows that properties expressible in logics correspond to so-called global 
relations: 
^ TRUE corresponds to the set {0} (consisting of the "empty sequence" 0) and 
FALSE to the empty set 0. 

1. Preliminaries 
11 
Definition 1.0.8 Let K be a class of r-structures. An n-ary global relation 
r on K is a, mapping assigning to each A £ K an n-ary relation r{A) on A 
satisfying 
r{A)ai...an 
iff 
r(B)7r{ai).. 
.7r{an) 
for every isomorphism n : A = B and every a i , . . . , a^ G A. If /r is the class 
of all finite r-structures, then we just speak of an n-ary global relation. 
D 
Examples 1.0.9 (a) Any formula ^{xi,... 
,Xn) of FO[r] defines the global 
relation A^ 
^'^i-)-
(b) The "transitive closure relation" TC is the binary global relation on 
GRAPH with 
TC(^) 
:= 
{(a, 6) I a, 6 G G^, there is a path from a to 6}. 
(c) For m > 0, r ^ is a unary global relation on GRAPH, where 
FmiQ) := {a\\\{b eG \ 
E''ab}\\=m} 
is the set of elements of Q of degree m. 
D 
In the definition of a global relation we also allow the case n = 0. There 
are only two 0-ary relations on a structure, TRUE and FALSE. Often one 
identifies a 0-ary global relation F on K with the class 
{AeK\ 
r(A) = TRUE}. 
By this identification, the global relation associated with a first-order sentence 
(p is the class Mod{(p) of finite models of (p (compare (3)). 
An important issue in model theory is the study of properties of classes 
of structures that are axiomatizable in a given logic £, and, in particular, 
to determine what classes of structures are axiomatizable and what global 
relations are definable in JC. However, since we only consider "function-free" 
vocabularies, how can we examine such problems, say, for the class of groups? 
Nearly all the methods and results presented in this book can directly be 
extended to vocabularies containing function symbols. Moreover, by replacing 
functions by their graphs one can always pass to function-free vocabularies. 
We sketch how to get rid of the function symbols in a vocabulary r. The price 
is the introduction of a new (n + l)-ary relation symbol F for every n-ary 
f ^ r. Let the vocabulary r^ consist of the relation symbols and constants 
from r together with the new relation symbols. Thus r^ is function-free. For 
a r-structure A, let A^ be the r^-structure obtained from A by replacing 
every n-ary function / ^ by its graph F^, 
F^ 
:= {(ai,...,an,/(ai,...,an)) | ai,...,an G A}. 
(So, for example, we look at a group (G,o^,e^) as the {i?, e}-structure 
(G,i^^,e^), where the ternary relation R is interpreted as the graph of o^, 

12 
1. Preliminaries 
i.e., R*^ = {(a, b,ao^ b) \ a,b e G} of o^.) The class of r'^-structures of the 
form A^ is the class of models of the conjunction of the formulas 
Vxi... ^Xn^^^yFxi... 
XnV 
where f £ T. For every r-sentence (^ there is a r'^-sentence (^^ and for every 
r^-sentence ip there is a r-sentence ip~^ such that for every r-structure A we 
have 
A^if 
iff 
^^ h cp" 
A h t/)-" 
iff 
A' h ^. 
(For example, if (f := 3x\/yf{g{y)) 
= a: then 99^ = 3x\/y3u(Gyu A Fux), and 
if ^ := \/x3y(Fxc A ^Gcy) then ^"'^ = Wx3y{f{x) = c A -ip(c) = ^). Note 
that, in general, qr((/?'') > qY((p).) Hence, a class K of r-structures is the class 
of models of a first-order sentence iff K^ := {^'^ | ^ G i^} is the class of 
models of a first-order sentence. 
E 
Relational Databases and Query Languages 
Suppose that a database contains the names of the main cities in the world 
and the pairs (a, b) of such cities such that a given airline offers service from 
a to 6 without stopover. We can view the database as a first-order structure, 
namely as a digraph Q = (G,E^), 
where G is the set of cities and E^ab 
means that there is a flight without stopover from a to 6. Now, first-order 
logic can be considered as a query language. For example, let 
(p{x, y) 
:— Exy V 3z{Exz A Ezy). 
If if is thought of as a query to the database, then the response is the set 
of pairs (a, b) of cities such that b can be reached from a with at most one 
stop. (We obtain a global relation if we assign to any database (digraph) the 
response corresponding to the query ip.) 
First-order logic provides a rich class of database queries. However, some 
plausible queries are not first-order expressible. For example, it is impossible 
to express the query "Can one fly from x to ?/" by a first-order formula such 
that we get the right answer in all possible databases (digraphs). We thus 
are led to ask for stronger logics (or, query languages). 
The last two sections have revealed a close relationship between classes of 
structures, global relations, and queries. Depending on the type of problem 
we are studying and the methods that are involved, we shall use one or the 
other terminology, even though we mostly use the terminology related to 
classes of structures. 

2. The Ehrenfeucht-Fraisse Method 
The Ehrenfeucht-Fraisse method is among the few tools of model theory 
that survive when we restrict our attention to finite structures. We present 
the method in its garnetheoretic, its algebraic, and its logical form (due to 
Ehrenfeucht, Frai'sse, and Hintikka, respectively). Later we shall see that 
generalizations are also available for some extensions of first-order logic. The 
detailed presentation for the case of first-order logic will help to understand 
these extensions, where in each case we only will indicate the changes that 
are necessary. 
We always refer to a fixed vocabulary r. As already mentioned in the 
preliminaries, r contains only relation symbols and constants. 
2.1 Elementary Classes 
The Ehrenfeucht-Fraisse method is a useful tool for showing that a given 
class of structures or a given global relation is (not) definable in first-order 
logic. We start with some easy remarks concerning the expressive power of 
first-order logic in the finite. 
Proposition 2.1.1 Every finite structure can be characterized in first-order 
logic up to isomorphism, i.e., for every finite structure A there is a sentence 
^A of first-order logic such that for all structures B we have 
B\=^A 
iff 
^ = B. 
Proof. Suppose A — {ai,..., arx^- Set a = a i . . . a^. Let 
^n '•— {V' I ^ has the form Rx\ ,. .Xk^ x — y^ or c = a;, 
and variables among ^ i , . . . , fn} 
and 
if A 
:= 3^1 •• . 3^n(A{^ I ^ G On, ^ N ^[^]} A 
A{-'V' I ^ G 6 > n , ^ N -•V'ia]} A VVn+l(^n+l = -^^l V . . . V-^n+l = Vn))-
u 

14 
2. The Ehrenfeucht-Prai'sse Method 
Corollary 2.1.2 Let K he a class of finite structures. 
Then there is a set $ 
of first-order sentences 
such that 
K = Mod(^), 
that is, K is the class of finite models 
of^. 
Proof 
Let K he a. class of finite structures. For each n there is only a 
finite number of pairwise nonisomorphic structures of cardinality n. Let 
{^1,...,^;^} be a maximal subset of K of pairwise nonisomorphic struc-
tures of cardinality n. Set 
^n := (<^^n ^ (^^1 V . . . V c p ^ J ) / 
where y:)=n is a first-order sentence expressing "there are exactly n elements" 
(see l.B)). Then K = Mod({ipn \ n > 1}). 
D 
In many situations we want to know more, namely whether a class K of 
finite structures or, equivalently, a property of finite structures, is axiomati-
zable by a single 
first-order 
sentence, i.e., whether K is elementary in the 
sense of the following definition. 
Definition 2.1.3 Let K be a class of finite structures. K is called 
axioma-
tizable in first-order logic or elementary, 
if there is a sentence (p of 
first-order 
logic such that K = Mod((/?).^ 
D 
For structures A and B and m G N we write A=m B and say that A 
and B are m-equivalent, 
if A and B satisfy the same first-order sentences of 
quantifier rank < m. The following theorem contains necessary and - as we 
shall see in 2.2.12 - sufficient conditions for a class K to be elementary. Since, 
in general, it is used to prove nonaxiomatizability results (see 2.3.5-2.3.9), 
we formulate it in the corresponding way. 
T h e o r e m 2.1.4 Let K be a class of finite structures. 
Suppose that for every 
m there are finite structures A and B such that 
Ae 
K, B ^ K, and A =m B. 
Then K is not axiomatizahle 
in first-order logic. 
Proof. Let ip be any first-order sentence. Set m := qr((p). By our assumption 
there are A and B such that A ^ K, B ^ K, and A =m B; hence, K ^ 
Mod(ip). 
D 
In case k = 0 recall our convention that the empty disjunction is F; one also 
could set ipn •= {^=n "^ -^3x X — x) in this case. 
In the literature, instead of axiomatizahle 
one often uses the term finitely ax-
iomatizahle. In (general) model theory a class of arbitrary structures K is called 
elementary if, for some (/?, K is the class of arbitrary models of cp. And given 
classes Ko and K with KQ D K, it is said that K is elementary relative to KQ if, 
for some <p, K is the class of models of p in KQ. In this terminology our notion of 
elementary 
corresponds to elementary relative to the class of finite structures. 

2.2 Ehrenfeucht's Theorem 
15 
2.2 Ehrenfeucht's Theorem 
In this section we present a purely gametheoretic characterization of the 
relation = ^ . It will be a useful tool, in particular, for applying Theorem 
2.1.4 to concrete classes, at the same time helping us to understand the 
expressive power of first-order logic. One of the central ingredients of the 
characterization are partial isomorphisms. 
Definition 2.2.1 Assume A and B are structures. Let j9 be a map with 
do(p) C A and rg(p) C B, where do{p) and Tg{p) denote the domain and the 
range of p, respectively. Then p is said to be a partial isomorphism from A 
to 5 if 
— p is injective 
— for every c e r : c^ £ do{p) and p{c^) = c^ 
— for every n-ary R e r and all a i , . . . , a^i G do(p), 
R'^ai...an 
iff 
R^p{ai)... 
p{an) • 
We write Part(^, B) for the set of partial isomorphisms from AtoB. 
D 
In the following we identify a map p with its graph {{a,p{a)) \ a G do{p)}. 
Then p Q q means that q is an extension of p. 
Remarks 2.2.2 (a) The empty map, p = 0, is a partial isomorphism from 
AtoB 
just in case the vocabulary contains no constants. 
(b) If p 7^ 0 is a map with do(p) C A and rg{p) C B, then p is a partial 
isomorphism from A to B iS do(p) contains c^ for all constants c e r and 
p :do{p)-^ ^rg(p)^ (where do(p)'^ and rg(p)^ denote the substructures of A 
and B with universes do{p) and rg(p), respectively). 
(c) For a = ai ... tts G A and b = bi .. .bg £ B the following statements are 
equivalent: 
(i) 
The clauses 
p{ai) = bi for i 
-l,...,s 
and 
p{c^) = c^ for c in r 
define a map, which is a partial isomorphism from A to B (henceforth 
denoted by a i-)- 6, a notation that suppresses the constants). 
(ii) For all quantifier-free ip{vi,... ,Vs): 
A\= (p[a] iff 5 |= (p[5]. 
(iii) For all atomic (p{vi,... ,Vs): 
A\= ^[a] iff B \= (p\b]. 
Proof. Note that for an arbitrary structure T> and d in D^ 
di = dj 
iff 
V \= Vi = Vj [d] 
c^=dj 
iff 
V^c 
= Vj[d] 
R^c^didj 
iff 
V^RcViVjid] 

16 
2. The Ehrenfeucht-Praisse Method 
(c, R e T,R ternary). Using such equivalences, it is easy to show that (i) and 
(iii) are equivalent. Clearly, (ii) implies (iii), and (ii) follows from (iii), since 
every quantifier-free formula is a boolean combination of atomic formulas. D 
In general, a partial isomorphism does not preserve the validity of for-
mulas with quantifiers: Let r = {<}, A = ({0,1, 2}, <), B = ({0,1, 2,3}, <), 
where in both cases < denotes the natural ordering. Then po := 02 i-)- 01 is 
a partial isomorphism from A to B such that 
A \= 3^3(^1 < ^3 A ^;3 < V2) [0, 2] 
but 
B ^ 3^3(^1 < ?^3 A ?;3 < V2) [po(0),po(2)]. 
Since 
A^{vi 
<V3A?;3 < ^2) [0,2,1] 
we see that, for any p G Part(^, B) with do(p) = {0, 2}, the vahdity of 
B 1= ^vsivi < -^3 A ^3 < V2) [p(0),p(2)] 
is equivalent to the existence of some q G Part(v4, B) which extends p and 
has 1 in its domain. 
This example indicates that the truth of formulas with quantifiers is pre-
served under partial isomorphisms provided they admit certain extensions. It 
embodies the basic idea behind the algebraic characterization of =rn we have 
in mind: The m-equivalence of structures amounts to the existence of partial 
isomorphisms that can be extended m times. In the gametheoretic terms in-
troduced by the next definition, a y-^b is such a partial isomorphism if the 
duplicator has a winning strategy for the Ehrenfeucht game 
GmiA,a,B,b). 
Let A and B be r-structures, a e A^,b e B^, and m € N. The Ehrenfeucht 
game Gm{A,a, B,b) is played by two players called the spoiler and the dupli-
cator. Each player has to make m moves in the course of a play. The players 
take turns. In his i-th move the spoiler first selects a structure, A or B, and 
an element in this structure. If the spoiler chooses e^ in A then the duplicator 
in his i-th move must choose an element fi'mB. 
If the spoiler chooses fi in 
B then the duplicator must choose an element e^ in A. 
first move 
second move 
m-th move 
A, a 
ei 
62 
^m 
B,b 
/ i 
/ 2 
Jm 
As illustrated by this table, at the end elements ei,..., e^ in ^4 and / i , . . . , /m 
in B have been chosen. The duplicator wins iff ae i-)- 6 / G Part(^, B) (in case 
m = 0 we just require that a 1-^ 6 € Part(v4, B)). Otherwise, the spoiler wins. 

2.2 Ehrenfeucht's Theorem 
17 
Equivalently, the spoiler wins if, after some i < m, aei... e^ i-4- 6/1 ... /^ is not 
a partial isomorphism. We say that a player, the spoiler or the duplicator, has 
a winning strategy in Gm{A,a,8,b), 
or shortly, that he wins 
Gm{A,a,B,b), 
if it is possible for him to win each play whatever choices are made by the 
opponent. We omit a formal definition of the notion of a winning strategy; 
it is implicit in the algebraic characterization given below (cf. the proof of 
Theorem 2.3.3). If s = 0 (and hence a and b are empty), we denote the game 
hyGm{A,B). 
Lemma 2.2.3 (a) If A = B then the duplicator wins 
Gm{A,B). 
(b) // the duplicator wins Gm+i{A,B) and \\A\\ < m then A = B. 
Proof, (a) Suppose n : A = B. A winning strategy for the duplicator consists 
in always choosing the image or preimage under TT of the spoiler's selection; 
that is, if the spoiler chooses a ^ A then the duplicator chooses 7r(a); and if 
the spoiler chooses b e B then the duplicator answers with 7r~^(6). 
(b) Suppose that the duplicator wins Gm+i{A,B), and assume that A = 
{ai,..., ttm}- Consider a play where the spoiler, in his first m moves, chooses 
a i , . . . , ttm. Let 61,..., 6^ be the responses of the duplicator according to his 
winning strategy. Then p : a i-> 6 G Pait{A,B) 
with do{p) = A. It even is 
an isomorphism from A onto B. Otherwise, we have rg(p) 7^ B. Then the 
spoiler, in the last move of the play, chooses some element b e B\ Tg{p). As 
there is no answer for the duplicator leading to a win, we get a contradiction. 
D 
The following lemma collects some facts about the Ehrenfeucht game. 
Their proofs are immediate from the definition. 
Lemma 2.2.4 Let A and B be structures, a G A*, 6 G B^, and m >0. 
(a) The duplicator wins Go(A,a,B,b) 
iff a \-^b is a partial isomorphism. 
(b) For m > 0 the following are equivalent: 
(i) The duplicator wins 
Gm{A,a,B,b). 
(ii) For all a £ A there is b £ B such that the duplicator wins the game 
Gm-i{A,aa,B^bb) 
and for all b £ B there is a e A such that the 
duplicator wins Gm-i {A, aa, B, bb). 
(c) If the duplicator wins Gm{A^a^B^b) and if m' < m, the duplicator wins 
G^>{A,a,B,b). 
D 
Parts (a) and (b) give us a hint how to relate the game to the validity of 
formulas. 
Let A be given. For a = ai ... Og E A and m > 0 we introduce a formula 
y^^{vi,... 
,Vs) that describes the gametheoretic properties of a in any game 
Gm{A,a,...); 
more precisely, we want to define cp^ in such a way that for 
any B and 6 = 61... 6s G -B, 
B^if^ 
[b] 
iff 
the duplicator WmS ^rn {A,a,B,b). 

18 
2. The Ehrenfeucht-Praisse Method 
If the structure A is not clear from the context, we use the notation ^'j^a for 
(pg*. We also allow s — 0, the case of the empty sequence 0 of elements in A, 
and write ip^ for the sentence ip^ ^. 
Definition 2.2.5 Let v he vi^... ^Vg-
^%^) 
'-— f\W{^) 
\ ^ atomic or negated atomic, ^ |r= (^[a]} 
and for m > 0, 
aeA 
aeA 
(p^ describes the isomorphism type of the substructure generated by a in 
A; and for m > 0 the formula ^p^ tells us to which isomorphism types the 
tuple a can be extended in m steps adding one element in each step, (p^ is 
called the m-isomorphism type (or m-Hintikka formula) of a in A. 
Since {^(vi,... 
,fs) | ^ atomic or negated atomic} is finite, a simple in-
duction on m shows: 
Lemma 2.2.6 For s,m > 0, the set {v^^a I ^ ^ structure and a 6 A^} is 
finite. 
D 
In particular, the conjunctions and disjunctions in the above definition 
are finite. 
Lemma 2.2.7 (a) qr{(p^) = m. 
{h)A^^n^' 
(c) For any 8 and h in B, 
B ^ (^^[6] 
iff 
a^be 
Part (^, B). 
Proof The proofs of (a) and (b) are straightforward, (c) holds by part (c) of 
2.2.2. 
D 
Theorem 2.2.8 (Ehrenfeucht's Theorem) Given A and B, a e A^ and 
b G B^, and m >0, the following are equivalent: 
(i) 
The duplicator wins Gm{A, a, B, b). 
(ii) 
B\=vm. 
(iii) a and b satisfy the same formulas of quantifier rank < m, that is, if 
^(xi,...,Xs) 
is of quantifier rank < m, then 
(*) 
^Nv[S] 
iff 
B\=vlb]-
Proof (iii) implies (ii) since qr{(p^) = m and A \= ^^[a]- We prove the 
equivalence of (i) and (ii) by induction on m. For m = 0 
the duplicator wins Go{A,a,B,b) 
iff 
a^be 
Part(^,;B) (cf. 2.2.4(a)) 
iff 
B^cpm 
(by 2.2.7(c)). 

2.2 Ehrenfeucht's Theorem 
19 
For m > 0, 
the dupHcator wins Gm(A, a, B^ b) 
iff 
for all a € A there is b e B such that the duplicator wins 
Gm-i (^,aa, 8,bb), and for all 6 G 5 there is a G A such that 
the duplicator wins Gm-i(v4, aa,B, 66) 
(cf. 2.2.4(b)) 
iff 
for all a G A there is b e B with 8 |= ip^~^ [66], and 
for all 6 G 5 there is a e A with 8 [= ^Z~^[bb] 
(ind. hyp.) 
iff 
8^^,^^3Vs+l^Z~\'^^^s+l) 
A 
V ^ , + i V a e v l ^ ? a ~ ' ( ^ , ^ . + l ) M 
iff 
B^^m-
(i) =^ (iii): The proof proceeds by induction on m. The case m = 0 is handled 
as above. Let m > 0 and suppose that the duplicator wins 
Gm{A,a,8,b). 
Clearly, the set of formulas (p{xi,... ,Xs) satisfying (*) contains the atomic 
formulas and is closed under -• and V. Suppose that (p{x) = 3yip and qr{ip) < 
m. Since y ^ free((^), we can assume that y is distinct from the variables in 
X. Hence, -0 = xp{x,y). Assume, for instance, A |= ^\a]. Then there is a G A 
such that A 1= ipla^a]. As, by (i), the duplicator wins Gm{A,a,8,b), 
there is 
6 G -B such that the duplicator wins Gm-i{A,aa,8,bb). 
Since qr(^) < m—1, 
the induction hypothesis yields H |= ^[6, 6], hence ^B [= (^[6]. 
D 
Corollary 2.2.9 For structures A, 8 andm > 0 the following are equivalent: 
(i) 
The duplicator wins Gm{A^8). 
(ii) 8 \= (p^. 
(iii) A =m 8. 
D 
By 2.2.3(b) we get 
Corollary 2.2.10 Let A be a structure with \\A\\ <m. 
Then for all 8, 
8[=ip'^+^ 
iff 
A^8. 
D 
The next result shows that the formulas ^p^ give a clear picture of the 
expressive power of first-order logic. 
Theorem 2.2.11 Let ip{vi,... ,Vs) be a formula of quantifier rank < m. 
Then 
\= ^ ^ \/WA,a 
I A a structure, a e A, and A \= ^[a]}.^ 
Proof. Suppose first that 8 \= ^\b]. Then the formula cp^-r is a member of the 
disjunction on the right side of the equivalence, which therefore is satisfied 
by 6. Conversely, suppose 8 |= V{v^!4 a I '^ N V^[^]}M- Then, for some A and 
a such that A \= ip[a], we have H |= ^XaH- -^y 2.2.8, a and 6 satisfy the 
same formulas of quantifier rank < m and therefore, 8 \= (p\b]. 
D 
By 2.2.6 the disjunction is taken over a finite set. 

20 
2. The Ehrenfeucht-Praisse Method 
The following result contains the desired characterization of classes ax-
iomatizable in first-order logic. As 2.1.4, we formulate it in a "negative" form, 
since the implication (ii) ^ (i) turns out to be one of the main tools to obtain 
nonaxiomatizability results for first-order logic. 
Theorem 2.2.12 For a class K of finite structures the following are equiv-
alent: 
(i) K is not axiomatizable in first-order logic. 
(ii) For each m there are finite structures A and B such that 
Ae K, B ^ K and A =m B. 
Proof, (ii) =^ (i) was proven in 2.1.4. For the converse, suppose that (ii) does 
not hold, i.e., that for some m and all finite A and H, 
Ae K and A=rnB 
imply B e K. 
Then K = Mod(\J{(p'2 \ A G K}), and thus K is axiomatizable. 
D 
2.3 Examples and Fraisse's Theorem 
To apply Ehrenfeucht's characterization to concrete examples, it is more con-
venient to use an algebraic version due to Fraisse, even though it lacks the 
intuitive appeal of the gametheoretical approach. 
Given structures A^ B and m G N, let Wm{A,B) 
:= 
{a h^ b \ s > 0,a e A^,b e B\ the duplicator wins 
Gm{A,a,B,b)} 
be the set of winning positions for the duplicator. The sequence of the 
Wm(A,B) 
has the back and forth properties as introduced in the following 
definition. 
Definition 2.3.1 Structures A and B are said to be m-isomorphic, written 
A =m B, if there is a sequence {Ij)j<m with the following properties: 
(a) Every Ij is a nonempty set of partial isomorphisms from 
AtoB. 
(b) {Forth property) For every j < m, p e Ij+i, and a £ A there is g G Ij 
such that q D p and a G do{q). 
(c) (Back property) For every j < m, p e Ij+i, and b e B there is q e Ij 
such that q^ p and b G rg(g). 
If {Ij)j<m has the properties (a), (b), and (c), we write {Ij)j<m • A =m B 
and say that A and B are m-isomorphic via {Ij)j^rn' 
D 
Exercise 2.3.2 Suppose {Ij)j<m : A=mB. 
Then {Ij)j<m : A=m B with 
ij := {q e Part(^, B) \ q C p for some p G Ij}. In particular, ^ ^^ ^ e Ij for 
all J < m. Moreover, W^(A^B) = 
Wj{A,B). 

2.3 Examples and Praisse's Theorem 
21 
Using the results of the preceding section we obtain: 
Theorem 2.3.3 For structures A and B, a G A^, 6 G B^, and m > 0 the 
following are equivalent: 
(i) 
The duplicator wins Gm 
(ii) a^beWUAB) 
and {Wj{A,B))j<m 
-A^mB. 
(iii) There is {Ij)j<m with U^ h £ Im such that {Ij)j<m '• A =-rn B. 
(iv)BH¥'?[6]. 
(v) a satisfies in A the same formulas of quantifier rank <m as b in B. 
Proof. By the definition of Wm{A,B) 
and 2.2.4, (i) implies (ii). Obviously, 
(ii) implies (iii). Therefore it suffices to show the implication (iii) =^ (i), 
the remaining equivalences being clear from 2.2.8. For (iii) => (i) suppose 
that {Ij)j<rn ' A =m B and a\-^b 
G Im- We describe a winning strategy 
in Gm{A,a,B,b) 
for the dupHcator: In his i-th move he should choose the 
element e^ (or /i, respectively) such that for pi : aei ... e^ i-)- bfi ... /j it is 
true that Pi C q for some q G Im-f, this is always possible because of the back 
and forth properties of (Ij)j<rn- Looking at z := m we see that the duplicator 
wins. 
D 
For s = 0 in view of Exercise 2.3.2 the preceding theorem yields the 
following extension of 2.2.9. 
Corollary 2.3.4 For structures A, B andm > 0 the following are equivalent: 
(i) 
The duplicator wins Gm{A,B). 
(ii) {Wj{A,B))j<m 
\ 
A=rnB. 
(iii) A^mB. 
(iv) ^ h ^ 3 -
(v) A^mB. 
D 
The equivalence of (iii) and (v) is known as Fraisse^s Theorem. The proof 
of the preceding theorem, and especially that of the equivalence of (i) and 
(iii) shows, that Ehrenfeucht's Theorem and Frai'sse's Theorem are different 
formulations of the same fact. In particular, the proof exhibits the close rela-
tionship between sequences {Ij)j<m and winning strategies for the duplica-
tor in GmiA,a,B,b). 
Therefore, one often speaks of the Ehrenfeucht-Frai'sse 
game or the Ehrenfeucht-Frai'sse method. 
Example 2.3.5 Let r be the empty vocabulary and A and B be r-structures 
(i.e., nonempty sets). Suppose m|| > m and \\B\\ > m. Then v4 =m B. In 
fact, {Ij)j<m :A^mB 
with Ij := {p G Part(^,H) | ||do(p)|| < 
m-j}. 
As a consequence the class EVEN[r] of finite r-structures of even cardi-
nality is not axiomatizable in first-order logic. In fact, for each ?7i > 0, let Am 
be a structure of cardinality m. Then, Am G EVEN[r] iS Am+i i EVEN[T], 
but Am —m Am+1- Now apply 2.2.12. The reader is encouraged to show for 
arbitrary r that EVEN[r] is not axiomatizable. 
D 

22 
2. The Ehrenfeucht-Fraisse Method 
Example 2.3.6 Let r = {<,min,max} be a vocabulary for finite orderings 
as introduced in 1.A2 and m > 1. Suppose that A and B are finite order-
ings, P l l > 2^ and \\B\\ > 2^. Then A=m B. Hence, the class of finite 
orderings of even cardinality is not axiomatizable in first-order logic. Clearly, 
the last statement remains true, if we consider orderings as {<, 5, min, max}-
structures. 
For a proofs given any ordering C, we define its distance function d by 
d{a,a') 
:= 
\\{b e C \ {a < b < a') or {a' < b < a)}\\. 
And, for j > 0, we introduce the "truncated" j-distance function dj onC xC 
by 
. 
/x 
_ 
/ d{a,a') 
ifd{a,a') 
< V 
Now, suppose that A and B are finite orderings with |m|,||5|| > 2^, For 
j < m set 
Ij 
:= 
{pePaiTt{A,B) 
\dj{a,a') 
=dj{p{a),p{a')) 
for a,a'e 
do{p)}. 
Then {Ij)j<m '- A =rn B: By assumption on the cardinalities of A and B we 
have {(min^,min^), (max^,max^)} G Ij for every j < m. To give a proof of 
the forth property of {Ij)j<m (the back property can be proven analogously), 
suppose j < m, p £ Ij+i, and a e A. We distinguish two cases, depending 
on whether or not the following condition 
(*) 
there is an a' G do{p) such that dj{a,a') < V 
is satisfied. If (*) holds then there is exactly one 6 G -B for which pU {(a, 6)} is 
a partial isomorphism preserving o?^-distances. Now assume that (*) does not 
hold and let do(p) = {ai,... ,0^} with a\ < ... < a^- We restrict ourselves 
to the case ai < a < a^+i for some i. Then, dj(ai,a) = 00 and dj{a,ai^i) — 
00; hence, dj^i{ai,ai^i) 
= cxo and therefore, djj^i(p[ai)^p{ai^i)) 
= CXD. 
Thus there is a 6 such that p{ai) < b < p(ai+i), dj{p{ai),b) 
= CXD, 
and dj{b,p{ai+i)) 
= 00. One easily verifies that q := p U {{a,b)} is a 
partial isomorphism in Ij. 
D 
Example 2.3.7 Let r = {<,min, max} be as in the preceding example and 
a = TU{E} with a binary relation symbol E. For n > 3 let An be the ordered 
r-structure with An = {0,... ,n}, min"^" = 0, max^^ = n, where <^^ is 
the natural ordering on An, and 
£ ; ^ » = { ( i , i ) | | i - i | = 2}U{(0,n),(n,0),(l,n-l),(n-l,l)}. 
{An,E^'^) 
is a graph that is connected iff n is odd. Now, let m > 2 and 

2.3 Examples and Praisse's Theorem 
23 
n 
Let Ij be the set of partial isomorphisms from AI\T to Ak\r as introduced in 
the preceding example. For j > 2 any p G Ij preserves E, too, that is, Ij C 
FaiTt{Ai,Ak)- Hence, (/;+2)i<m-2 : Ai =m-2 A , and, by 2.2.12, we obtain: 
- The class of finite connected ordered graphs is not first-order axiomatizable. 
D 
The following example is related to the preceding one, but does not involve 
orderings. 
Example 2.3.8 For / > 1, let ^/ be the graph given by a cycle of length 
/ + 1. To be precise, set 
G, := {0,...,(}, £ « ' := {(i,i + l) I i<l}Ll{(i 
+ l,i) I 
i<l}Ll{{0,l),(l,0)}. 
Thus, for /, A: G N, the disjoint union QiU Qk consists of a cycle of length / + 1 
and of a cycle of length A: + 1 (for Ai as defined in the preceding example we 
have Ai\{E} ^ Qi for / odd, and Ai\{E] ^ GL_^\JQ^ 
for / even). We show: 
If /, /c > 2^ then Gi ^rn Qk and Qi ^m Qi^ Gi-
In fact, for j G N, define the distance function dj on a graph Q by 
dj(a,a') 
:= 
| 
^ ^ ' 6) 
if d{a, b) < 2^+1 
else 
(where d denotes the distance function on Q introduced in l.Al). To show, 
say, that Qi and QiU Qi are m-isomorphic, one verifies {Ij)j<m '• Qi —m Gi^ Gi 
where Ij is the set of p G Part(^/,^/U^/) with 
l|do(p)|| <m — j 
and 
dj{a,b) = dj{p(a),p{b)) for a,b e do{p) 
(the proof is similar to that of Example 2.3.6). We note two consequences. 
— The class CONN of connected finite graphs is not axiomatizable in first-
order logic. 
In fact, by 2.2.12, CONN is not axiomatizable, since for each m we have 
^2- e CONN, ^ 2 - 0 ^ 2 - ^ CONN, ^2- = m ^ 2 - U ^ 2 - . 

24 
2. The Ehrenfeucht-Praisse Method 
— The global relation TC (cf. 1.0.9), the relation of transitive closure on the 
class GRAPH of finite graphs, is not first-order definable. 
In fact, suppose ^^(x, ^) is a first-order formula defining TC on GRAPH. Then 
CONN would be the class of finite models of \/x\/y {-^x = y -^ ip{x,y)) (and 
the graph axioms). 
D 
Exercise 2.3.9 Set r = {E}. For / > 1 let Bi and Vi be the r-structures 
given by 
Br.= {0,...,l}, 
£«' :={(i,i + l) ! » < / } , 
A := {0,..., 0, 
E^' := {(i, J + 1) I J < 0 U {(«, 0)}. 
Given m > 0, show that Bi =m BiUVi for sufficiently large /. Conclude that 
the class of finite acyclic digraphs (cf. l.Al) is not axiomatizable in first-order 
logic. 
D 
Proposition 2.3.10 The product, the disjoint union, and the ordered sum 
{cf. 1.A3) preserve =rn, i-e., 
(a) // Ai =m Bi and A2 =m B2 then Ai x A2 =m Bi x B2. 
(b) IfAi 
=ni Bi and A2 =m ^2 then A1UA2 =m B1UB2. 
(c) If Ai =m Bi and A2 =m B2 then Ai < A2 =m Bi <B2-
Proof. Suppose Ai =m Bi and A2 =m B2- By Ehrenfeucht's Theorem 
there are winning strategies for the duplicator in the games Gm{Ai,Bi) 
and 
Gm(A2,B2)- We refer to these strategies as Si and 5*2. 
(a) The following gives a winning strategy for the duplicator in the game 
Gm{Ai X A2,Bi X B2)'' We simultaneously play games in Gm(Ai,Bi) 
and 
Gm{A2,B2)- Suppose that in his i-th move the spoiler chooses, say, (ai, 02) G 
Ai X A2. Let 61 G Bi and 62 ^ B2 be answers to ai and 02 according to Si 
and ^2, respectively. Then the duplicator chooses (61,62)-
(b),(c) The proofs for parts (b) and (c) proceed in the same way. So let 
* G {U, <}. The following represents a winning strategy for the duplicator in 
Gm{Ai *A2,Bi*B2) 
(when describing it we use moves of plays in Gm(Ai, Bi) 
and Gm{A2,B2))' Suppose that in his i-th move the spoiler selects, say, a G 
Ai * A2. Then the duplicator gets his answer by applying Si if a G Ai, and 
52 if a G A2. 
D 
The last proof yields more: 
Corollary 2.3.11 (a) If {Ai,ai)_=rn {Bi,bi) and{A2,a2) =m (^2,62) then 
{AiUA2,ai,a2) 
=m 
(Bi\JB2MM)-
(b) If {Ai.ai) 
^m_{Bi,bi) 
and (^2,^2) =m {B2M) then {Ai < A2->ai,a2) 
=m{Bi<B2MM).^ 
• 
'^ In this corollary, ai and a2 can be sequences of different length. 

2.3 Examples and Praisse's Theorem 
25 
Exercise 2.3.12 Suppose that r = {i?i,... ,Rk} with unary relation sym-
bols Ri. For a : { 1 , . . . , A:} -> {0,1} and a r-structure A denote by A^ the 
subset XiPi.. .nXfc, where X^ := i?f if a(i) = 1, and Xj := A\Rf 
otherwise. 
Show for any r-structures A^ B and m > 1 that A =m B iff min{||AQ,||, m} = 
min{||BQ;||,m} holds for all a. Conclude that every sentence ip from FO[r] is 
equivalent to a boolean combination of sentences of the form 3'^^xR^x, where 
R'^x := ipi A ... A Lfk with ipi = Rix if a{i) = 1, and Lpi = ^Rix if a{i) = 0. 
Hint: First, consider sentences (f of the form C/P^. Then apply 2.2.11. 
Q 
Exercise 2.3.13 Let < be a binary symbol of the relational vocabulary r. 
For m > 1 and l,k > 2'^ show that <\^A =m <^A holds for ordered A. Here 
<}^A denotes the ordered sum of / copies of A. (Hint: Use the idea of the 
proof of 2.3.6). 
D 
Exercise 2.3.14 Show for a M- 6 G Part(^,B) and m > 0 that 
B^^^[b] 
iff 
( ^ , a ) - ^ ( 5 , 6 ) . 
D 
Exercise 2.3.15 Show that {Ij)j<rn --A^mB 
implies Ij C Wj{A,B) 
for 
j < m. 
D 
Remark 2.3.16 Let Z := (Z, <) and Q := (Q, <) be the integers and the 
rationals with their orderings, respectively. For 
if 
:= 
3x3y{x < y AVZ^{X 
< z A z < y)) 
we have 
(*) 
^ \= ^ and 
Q^ 
^. 
Hence, Z ^s Q and therefore, Z ^3 Q. The spoiler can "transform" the 
information (*) into a winning strategy for the game Gs(Z, Q) as given by 
the table 
z 
5 
6 
? 
Q 
a 
b 
a+b 
2 
We have underlined the selections of the spoiler. Note that no third move of 
the duplicator will lead to a partial isomorphism (since for a < 6 we have 
a < ^ ^ < b and there is no integer between 5 and 6). In this strategy of the 
spoiler his selections in Z correspond to the existential quantifiers in (p and 
his selections in Q to the universal quantifiers. This connection can be made 
precise and is implicit in the proof of 2.2.8. It is the reason why moves in 
Gm{A^ B) in which the spoiler chooses an element of A (of B) are sometimes 
called 3-moves (y-moves). 
D 
As in the present section, the formulas ^^^^ ^^^ m-isomorphism type of a 
in A, will also play a crucial role in subsequent considerations. In our opinion 
their methodological importance stems from the following two facts: 

26 
2. The Ehrenfeucht-Praisse Method 
(1) They have a clear algebraic meaning. 
(2) Every first-order formula is equivalent to a disjunction of such formulas 
(see 2.2.11). 
Classical model theory has been characterized by the equation 
model theory = universal algebra + logic 
(see [20]). By (1) and (2) above, it is clear that the formulas cp-^^- provide a 
bridge between structures and first-order formulas, that is, between our main 
notions from (universal) algebra and from (first-order) logic, respectively. 
Therefore the experience that they are a valuable tool in model theory might 
not come as a surprise. 
There is a more algebraic, sort of logic-free, way to define m-isomorphism 
types, say for a = ai ... as in ^ by 
lT^{A,a) 
:= 
{ip\ A \=^ (p[a], (p{vi,...,Vs) 
atomic} 
and 
IT^+'(^,a) 
:= 
{IT^(^,aa) 
\aeA}. 
One easily verifies that for any 8 and b e B, 
I T - ( ^ , a) = IT-(^, 6) 
iff 
v^Xa = ^srt' 
2.4 Hanf s Theorem 
All vocabularies in this and the next section will be relational unless stated 
otherwise. For a nonempty subset M of a structure A we denote by M the 
substructure of A with universe M. 
Given a structure A, we define the binary relation E^ on A by 
E"^ := {(a, 6) I a 7^ 6, and there are i? in r and c e A such that R^c 
and a and b are components of the tuple c}. 
The structure Q{A) := (A^E"^) is called the Gaifman graph of A. Obviously, 
if A itself is a graph then Q{A) = A. For a in ^ and r G N we denote by 
S{r, a) (or 5'^(r, a)) the r-ball of a, 
S(r,a) 
:= 
{b e A\ d{a,b) <r}.^ 
S{r,a) (or S {r,a)) stands for the substructure of A with universe S{r,a). 
Note that for 6, c G S{r,a) we have d{b,c) < 2r. For a = ai ... flg we set 
5(r, a) := S{r, a j U ... U S{r, as). 
d denotes the distance function of Q{A) as defined in l.Al 

2.4 Hanf's Theorem 
27 
We define the r-ball type of a point a in ^ to be the isomorphism type 
of {S{r,a),a), 
i.e., points a in ^ and 6 in 5 have the same r-ball type iff 
In 2.3.8 we showed for certain graphs that they are m-isomorphic and hence, 
m-equivalent, using a sequence (/j)j<^, where - in the terminology just intro-
duced - for each p G Ij and a G do(p) there was an isomorphism of S{2^ — 1, a) 
onto S{2^ — l,p(a)) compatible with p. We use generalizations of this idea to 
show two further theorems on the expressive power of first-order logic. The 
first one (Hanf's Theorem) is obtained by applying the idea just mentioned 
to graphs of structures. In the second one (Gaifman's Theorem) the require-
ment of isomorphism of corresponding balls is weakened to /-equivalence for 
a suitable L 
Theorem 2.4.1 (Hanf's Theorem) Let A and B he r-structures and let 
m eN. Suppose that for some e G N the S^-balls in A and B have less than 
e elements^ and that for each ?>^-hall type t, (i) or (ii) holds where 
(i) A and B have the same numher of elements of'^'^-hall type L, 
(ii) hoth A and B have more than m • e elements of 3^-hall type i. 
Then A =m B. 
Proof. Since for n < / the /-ball type of an element determines its n-ball 
type, we see that for n < 3"^ and every n-ball type i, A and B have the same 
number of elements of n-ball type i or both, A and H, have more than m • e 
elements of n-ball type L. 
We show that {Ij)j<m '• A =rn B, where Ij is the set 
{a h-> 6 G P a r t ( ^ B) | (5(3^ a), a) ^ (<S(3^ 6), 6) and length (a) 
<m-j}, 
and where, for length(a) = 0, we set (<S(3-^,a),a) = 0 and agree that 0 = 0. 
Therefore, we have 0 i->- 0 G /m- Concerning the back and forth properties 
it is enough, by symmetry, to prove the forth property. Thus suppose that 
0<j<m, 
aeA 
and a i-)- 6 G ij+i, say, 
(*) 
7r:(<S(3^+i,a),a)-(5(3^+1,6),6). 
Case 1: ae 5(2-3^', a). 
Then 5(3^aa) C 5(3^•+^a2. Setting b := 7r(a), we have TT : (<S(3^aa),aa) ^ 
(<S(3'^, bb),bb), hence aa h^ bb e Ij. 
Case 2: a^ 5(2 • 3^a) (and hence, 5(3^ a) 0 5(3^ a) = 0). 
Let i be the 3^-ball type of a. By (*), <S(2 • 3^a) and S{2 • 3-^', 6) contain 
the same number of elements of 3-^-ball type L which, by our assumption 
on the cardinality of balls, is < length (a) • e < m - e . Therefore, by (i) or 
Note that for finite A and B there is always such an e. 

28 
2. The Ehrenfeucht-Prai'sse Method 
(ii), there must be an element 6 ^ 5(2 • 3-^,6) with 3-^-ball type t. Choose 
TT' : (<S(3-^, a), a) = (5(3-^, h),b). Then the corresponding restriction of vr U TT' 
is an isomorphism of (<S(3-^, aa), aa) onto (<S(3-^, 66), 66). 
D 
We give an application. Note that a graph Q is connected if each nonempty 
subset of G closed under the graph relation E^ contains already all elements 
of G, i.e., if ^ is a model of the "second-order sentence" 
\/P{{3xPx A \/x'iy{{Px A Exy) -^ Py)) -> \/zPz). 
We are going to show that the class of connected graphs is not axiomatizable 
by a second-order sentence of the form 3Pi ... 3Prip, where P i , . . . , P^ are 
unary and ^ is first-order (see section 3.1 for a precise definition of second-
order logic). 
For / > 1, let X>/ = (Di, Ei) be a digraph consisting of a cycle of length 
/ + 1, e.g. 
Di - {0,..., /}, El := {(i, i + l)\i<l}U 
{(/, 0)}. 
Lemma 2.4.2 Suppose r = {E, P i , . . . , P^} where P i , . . . , P^ are unary, and 
let m > 0. Then there is anlo > 1 such that for any I > IQ and any r-structure 
of the form (P/, P i , . . . , P^) there are a,b £ Di with disjoint and isomorphic 
3"^-balls. 
Proof For the structures under consideration any 3^-ball contains exactly 
2-3^ -\- 1 elements (note that Pi,... ,Pr are unary and therefore do not 
influence the distances induced by the underlying digraphs). Let i be the 
number of possible isomorphism types of 3^-balls. Then in a structure of 
cardinality > IQ := {i -h l)(2-3"^ H- 1) there must be two points with disjoint 
3"^-balls of the same isomorphism type. 
D 
Lemma 2.4.3 Suppose (X>/,Pi,... ,Pr) is a r-structure (r as in the pre-
ceding lemma) containing elements a and 6 with disjoint and isomorphic 3"^-
balls. Denote by a_ andb- the elements of Di with EiO-a and Eib-b, respec-
tively {see the figure below). Let {Di^E'i^Pi,... 
Pr) be the structure obtained 
by splitting the cycle (I>/,Pi,... ,P^) into two cycles by removing the edges 
(a_,a), (6_,6) and adding edges {b-,a), 
(a-,b) instead; more formally: 
E[ 
:= 
(^A{(«-,«),(&-,^)})U{(6_,a),(a_,6)}. 
Then (Vi^Pu ...,Pr)=m 
{Di,E[,Pu • • -^Pr)-
Proof. Immediate by Hanf's Theorem, since both structures have the same 
number of 3"^-balls of any given isomorphism type. 
D 

2.4 Hanf's Theorem 
29 
Since a partial isomorphism between digraphs is a partial isomorphism of 
the associated graphs, we get from the two preceding lemmas: 
Lemma 2.4.4 For r = {E,Pi,... 
,Pr} and m > 0 choose IQ according to 
2.4-2. Let I > IQ and (Qi, P i , . . . , Pr) be a r-structure, where Qi is the Gaifman 
graph Q{Vi) ofVi, that is, Qi is a cycle of length / + 1. Let Q'l he the Gaifman 
graph Q{{Di^E[)), where {Di^E[) is defined as in the preceding lemma. Then 
{Gl,P^,...,Pr)=m{Q'uPu--..Pr)-
We are now in a position to show: 
D 
Proposition 2.4.5 The class of finite and connected graphs cannot he ax-
iomatized hy a formula of the form 
(*; 
3P,...3Pri^, 
where Pi,... ,P^ are unary relation symhols and ip is a first-order sentence 
over the vocabulary {E, Pi,...,P^}. 
Proof. Suppose that for the sentence (*) and any finite graph Q, we have: 
Q is connected iff for some Pi,... ,Pr C G : (Q,Pi,...,P^) 
|= ip. 
For m := qr(^) choose IQ as in 2.4.2. Since Qi^ is connected, there are 
P i , . . . , P , such that {gi,,Pi,...,Pr) 
h xp. Then, {Gl,Pi,... 
,Pr) h ^ by 
2.4.4, but Q'l^ is not connected, a contradiction. 
D 
On the other side we have 
Proposition 2.4.6 The class of finite and connected graphs can he axioma-
tized hy a formula of the form BRip, where R is binary and 'tp is a first-order 
sentence over the vocabulary 
{E,R}. 

30 
2. The Ehrenfeucht-Praisse Method 
Proof. Let ^ be a sentence expressing that R is an irreflexive and transitive 
relation with a minimal element, and that Exy holds for any immediate R-
successor y oi x\ that is, -0 is the conjunction of 
\/x-^Rxx A \/x\/y\/z{{Rxy A Ryz) -> Rxz), 
3x\/y{x = yV 
Rxy), 
^x\Jy{{Rxy A 'iz-^[Rxz A Rzy)) -^ Exy). 
Let ^ be a graph. Clearly, if ^ is a model of 3i?0, say (Q^R^) |= 0, then 
for any element of Q there is a path connecting it with the minimal element; 
hence, Q is connected. Conversely, suppose Q is connected. Choose an ar-
bitrary a £ G. For n G N set L^ := {6 | d(a, 6) = n] and take as R the 
transitive closure of {(6, c) | E^hc and for some n^ b G Ln and c G Z/j^-^-i}. CH 
Exercise 2.4.7 Show the results corresponding to 2.4.5 and 2.4.6 for the 
class of finite acycHc digraphs (cf. l.Al). (Hint: Denote by Hi the digraph 
({0,...,/},{(z,z + l) I i < I}). For the nonaxiomatizability result use Hanf's 
Theorem similarly as above, cutting off in some {Hi, P i , . . . , Pr) an interval 
with endpoints a and b for suitable a and b and forming a cycle out of it.) 
Moreover show that the class of finite acyclic digraphs can be axiomatized 
by a sentence \fPip, where P is unary and -0 is a first-order sentence over 
{E,P}. 
D 
Exercise 2.4.8 Show that there is a formula ?/'(x, y) of the form 3Pip, where 
P is unary and (^ is a first-order formula over {E,P}, 
expressing in finite 
graphs that x and y are in the same connected component. In fact, as ip{x, y) 
one can take a formula expressing that x — y oi that there is a subset P (a 
"path from x to ?/") containing x and y such that both x and y have an edge 
to exactly one member of P and every other member of P has an edge to 
precisely two members of P. Conclude that \/x\/y3P(p is not equivalent to a 
sentence of the form 3Pi ... 3Pr x with unary P i , . . . , P^ and first-order x-
D 
2.5 Gaifman's Theorem 
Fix a relational r. Let ^ be a r-structure. A subset M of ^ is l-scattered, if 
the distance (in the Gaifman graph G{A)) between any two elements of M 
exceeds /. Given r, n > 1 and a r-formula il^ix), it is easy to write down (see 
below) a first-order sentence asserting that there is a 2r-scattered subset M 
of cardinality at least n such that S{r,a) \= ip[a] for all a G M.^ Gaifman's 
Theorem states that every first-order sentence is logically equivalent to a 
boolean combination of such sentences. It thus is a further formulation of 
^ Note that, due to 2r-scatteredness, the balls S{r,a) for a G M are pairwise 
disjoint. 

2.5 Gaifman's Theorem 
31 
the fact already present in Hanf's Theorem that first-order sentences only 
capture local properties of structures. 
In order to give a more precise formulation we need some notations. First 
note that there is a r-formula On{x,y) such that for any r-structure A and 
a,b e A, 
A [= dn{x,y) [a, 6] 
iff 
d{a,b) < n. 
In fact, set 6o{x,y) \— x — y and (denoting by a{R) the arity of R) 
On+l{x,y) 
: = 
On{x,y) 
V 3z{0n{x,z)A 
\/ 
3ui...3Ua(R) 
Rer 
{Rui...Ua(R)A 
y 
{ui = zAuj 
^y))). 
l<i,j<a(R) 
From now on we write d{x, y) < n for On{x, y). For x = xi... Xm let 
d{x,y)<n 
:= id(xi,y) 
<n V .. .V d(xm,y) < n). 
Let k ^ N. With every r-formula cp = (p{x,y) we associate a formula 
ip^^^'^\x,y) 
such that for any r-structure A,aeA, 
and b G S{k,a), 
A \= (p^(^'^)[a,6] 
iff 
S{k,a) ^ ip[a,b]. 
To define ip^(^^^\ first replace any bound occurrence in (^ of a variable in x 
by a new variable and then inductively relativize the quantifiers to 
S{k,x), 
e.g., 
[3zipf^^^^^ := 3z{d{x,z) <k A (p^(^'^)). 
Call a sentence basic local if it has the form 
3x1...3xn 
A 
{d{xi,xj)>2r 
A ^'^(^'^^^(a:,)), 
l<i<j<n 
where ^1) = \l){x) is a first-order formula. Note that for / < A^, 
in particular, any sentence of the form 
3xi .. .3xn 
f\ 
id{xi,Xj) >2r A V'^^^'^^^x^)) 
l<i<j<n 
with / < r is logically equivalent to a basic local sentence. 
A local sentence is a boolean combination of basic local sentences. 
Theorem 2.5.1 (Gaifman's Theorem) Every first-order sentence is log-
ically equivalent to a local sentence. 

32 
2. The Ehrenfeucht-Praisse Method 
By 1.0.7 it suffices to show 
Lemma 2.5.2 Suppose A and 8 satisfy the same basic local sentences. Then 
A = 5. 
Proof. We show that A =m H for m G N. The argument parallels that for 
Hanf's Theorem. There the sets Ij consisted of partial isomorphisms a \-^ b 
such that length (a) <m — j and 
{S{y,a),a)^{S{3',b),b). 
Here we replace = by =g{j) and take balls of radius 7^; the values ^(0), ^(1),.. • 
of the function g can be defined by induction: g{j) only has to be greater than 
some values which one gets in the course of the proof. 
So let Ij comprise all the partial isomorphisms a \-^b from A to 8 such 
that length (a) <m — j and 
(5(7^a),a)=,y)(5(7^6),6). 
Again, in case length(a) = 0, we set (*S(7^, a), a) = 0 and agree that 0 =A; 0 for 
all k. In particular, ^ ^ ^ e Im- We show (Ij)j<m '• A =m 8. By symmetry, 
we can restrict ourselves to the forth property. Thus suppose 0 < j < m, a e 
A,a\-^b^ 
/j+i; hence 
(1) 
iSiP+\a),a)=,(j+,)(S(P+\b),b). 
We introduce a useful abbreviation: For d in a structure T> let 
^1^-) ••= KS,.,,.(^)1 
that is, '0^(a:) expresses that {S{7^,d),d) =g(j) {S(7^,x),x) 
(recall that (p'' -
denotes the /-isomorphism type of d in X>). 
Case 1. ae 5(2-7^ a). 
Then 
S{V+\a) h 3z{d(a,z) < 2 • 7^' A 4,{az)). 
We assume that the quantifier rank of this formula is < ^(j + 1) (this gives 
us a first condition on the value of ^(j + 1)). Hence by (1), 
S{P+\b) \= Md{b,z) <2-V A V-Llfez)), 
SO that for some b we have 
{S{P,aa),aa) 
=g^j^ (<S(7^66),66). 
Therefore aa \-^bb e Ij. 

2.5 Gaifman's Theorem 
33 
Case 2. a^S{2-7^,a), 
i.e., 5(7^a) fl ^(T^a) = 0. 
For 5 > 1, the following formula Ss{xi,...,Xg) 
expresses that {xi,...,Xg} is 
a 4-7-^-scattered set of elements whose 7-^-ball has the same p(j)-isomorphism 
type as that of a: 
Ss := 
/ \ 
d{xi,Xk)>4-7^ 
A /\ 
i^iixi). 
l<l<k<s 
!</<« 
Compare the cardinalities (e and i below) of maximal 4 • 7-^-scattered sets in 
S(2-7^ ,a) and in A, respectively, consisting of such elements. More precisely, 
let e and i be such that 
(2) 
S(V+\a)^3xi...3xe{A^<k^,d(a,Xk)<2-7^ 
A Se) 
(3) 
S{V+\a)^3x,...3xe+l{^ 
i</fe<e+i c?(a,a;/i;) < 2 • 7-^ A Se+i) 
(4) 
A\=3xi...3xi5i, 
A^3xi...3xi+iSi-^i; 
if no such i exists, set i = oo (note that e is bounded by the length of 
a (and hence by m), since any two elements of the same ball of radius 
2 • 7^ have a distance at most 4 • 7-^). Clearly, e < i. Moreover we claim 
that the corresponding numbers e and i determined in S(7^'^^,b) and B, 
respectively, are the same: Concerning B, this holds since the sentences in 
(4) are basic local up to logical equivalence. Concerning S(7^'^'^, b) note that 
(<S(7-^+-^,a),a) =^(j+i) (<S(7-^+-^,6),6) and that g{j + 1) is greater than the 
quantifier rank of the sentences in (2) and (3) (this gives a second condition 
on the value of ^(j -I- 1); recall that e is bounded by m). 
Case 2.1. e — i. 
Then all elements satisfying i^i^x) have a distance 
< 4 • 7-^' + 2 • 7-^' = 6 • 7-^' < 7^'+^ 
from a (in fact, if one such element a' satisfies <i(a, a') > 6 •7-^ then a' together 
with e many witnesses for (2) show that i > e -I- 1). In particular, this holds 
for a. 
Smcea^S{2-7^+\a), 
S{P+\a) 
\= 3z{2 • 7^ < d{a,z) < 6 • 7^' A i^i{z) A i^W^)). 
Then, by (1), 
S{V+\b) 
^ 3z{2 • 7^ < d{b,z) < 6 • 7^' A ^i{z) 
A ^j(6)) 
(this gives us a third condition on the value of p(j H- 1)). Thus there is b with 
2-7-?' <d{b,b) < 6 - 7 ^ a n d 

34 
2. The Ehrenfeucht-Praisse Method 
(5) 
(5(7^a),a)=,y)(<S(7^6),6). 
Moreover, 
(6) 
(5(7^a),a))=,o)(5(7^6),6). 
Since the universes of the structures on the left sides of (5) and (6) are 
disjoint, and the same applies to the right sides, we obtain from 2.3.10(b) 
that 
{S{7^,aa),aa) 
=^(,) (5(7^66),66), 
thus aa \-^bb e Ij. 
Case 2.2. e <i. 
Then 
8 \= 3a:i.. .3xe+iSe+i. 
Hence there must be an element b in B such that 
S{7^,b) n S{7^,b) = ^ 
and 
B ^ xl^i{x)[b], 
in particular, (<5(7-^, a), a) =c/(j) {'^{^^^ b),b). Now one can argue as at the end 
of the preceding case. 
D 
We close with an application of Gaifman's Theorem which will be used 
in Chapter 9. In the rest of this section all structures are assumed to be 
finite. Recall that r is relational. Given r-structures A and B, a mapping 
h : A ^ B is a, homomorphism if for all R E r and a G A, Ra implies Rh{a). 
The homomorphism is said to be strict if, in addition, for all i? G r and a ^ A 
with R^hia) there is e G A such that R^'e and h{e) = /i(a). 
A sentence ip is preserved under {strict) homomorphisms if for all A, B and 
any (strict) homomorphism h : A ^ 
B, 
A\= (p implies 
B \= (p. 
Exercise 2.5.3 Every existential positive sentence, that is, every sentence 
built up from atomic formulas with the connectives A and V, and the quan-
tifier 3, is preserved under homomorphisms. 
D 
A model ^ of a sentence ip is said to be minimal if no proper substructure 
is a model of (p, that is, if 
B C A and B \^ (p imply 
B = A. 
Exercise 2.5.4 For any (p, every model of ^ contains a minimal model, that 
is, if )5 f= (/? then there is A C B such that ^4 is a minimal model of (p (recall 
that we restrict ourselves to finite structures). 
D 

2.5 Gaifman's Theorem 
35 
Theorem 2.5.5 If ^ is preserved under strict homomorphisms then there 
are I and m such that no minimal model of Lp contains an I-scattered subset 
of cardinality m. 
Proof. By Gaifman's Theorem, (/? is logically equivalent to a boolean combi-
nation of basic local sentences (/?i,..., (/^^. Suppose 
Lpi^3xi...3xni{ 
/\ 
{d{xs,xt) >2ri A 
ipf^'''''''\xs))). 
l<s<t<ni 
Set r :— maxjr^ | 1 < i < k}, I := 2r and m := 2^ + 1. Let ^ be a minimal 
model of (p. We show that A contains no /-scattered subset of cardinality 
m. By contradiction, suppose that M is /-scattered and ||M|| > m. For i = 
1,..., fc let pi{u) express "there is v such that d{u,v) < ri and V'* ''^ (t')". 
By choice of m there are a,a' e M such that a^ o! and for z = 1,..., A:, 
A^Pi\a\ 
iff 
A^Pi\o!\. 
Let B be the substructure of A with universe A \ {a}. Then By^ ip^ since A 
is a minimal model of ^. 
Set n := maxjni | % — 1,...,A:}, Bn := \]j^\ 
yfi (the disjoint union 
of n copies of ;B), and An '•— AuBn- 
The projection of Bn to B is a strict 
homomorphism, therefore, Bn ^ ^' Since the inclusion map of A to An is 
a strict homomorphism, too, and A \= (p, we have An \= ^- We obtain the 
desired contradiction, if we show that for i = 1,..., /;:, 
An \= ^i 
iff 
Bn 1= (Pi-
Fix i. Suppose first that Bn \= ^i- Then, for some b ^ Bn, S^"" (r^, b) |= ^i[6]. 
View b as an element of B. Then the ^^-part of An contains n^ - even 
n - copies of the element 6, which are pairwise at infinite distance. Since 
S^^ (ri, b) = <S^" {ri, b), we obtain 
An\=^i. 
Assume now that An \= ^i- Choose e ^ An such that <S^''(ri,e) |= V'iH-
If a ^ S'^{ri,e) then <S^''(ri,e) = S^{ri,e), 
and we argue as above. Finally, 
assume that a e S^{ri,e). 
Then, A ^ pM, 
and hence, A \= pi[a']. Thus 
there is e' G ^ such that d(e',a') < r and S {ri,e') |= ipile']. Now d{e',a) > 
d{a',a) — d{a',e') > I — r = 2r — r > ri. Therefore, a ^ S {ri,e'), and 
hence S {ri,e') = S^{ri,e'). 
Therefore, Bn contains Ui copies of e', and 
thus, Bn \= ^i' 
• 
Notes 2.5.6 As already mentioned in the introduction to this chapter, the 
algebraic characterization of m-equivalence is due to Fraisse [43], its game-
theoretic version to Ehrenfeucht [33]. The j-isomorphism types were intro-
duced by Hintikka [85] in a different context. Theorem 2.4.1 is due to Hanf 
[79], Theorem 2.5.1 to Gaifman [45], and Theorem 2.5.5 to Ajtai and Gure-
vich [7]. Further references for the results in this chapter are [5, 78, 39]. The 
"local" character as it becomes apparent for first-order logic in the theorems 
of Hanf and Gaifman is studied in [83, 115, 116, 69]. 

3. More on Games 
In this section we show that for some fragments and extensions of first-order 
logic there are corresponding variants of the Ehrenfeucht-Fra'isse method. 
First we deal with second-order logic, mainly with monadic second-order 
logic, then with infinitary languages, and finally with restrictions of these 
infinitary languages and of first-order language to fragments consisting of 
formulas which only contain a fixed finite number of variables. 
3.1 Second-Order Logic 
Second-order logic, SO, is an extension of first-order logic which allows to 
quantify over relations. In addition to the symbols of first-order logic, its al-
phabet contains, for each n > 1, count ably many n-ary relation (or predicate) 
variables V/^, ¥2^,... To denote relation variables we use letters X,Y, 
We 
define the set of second-order formulas of vocabulary r to be the set generated 
by the rules for first-order formulas extended by: 
- If X is fi-ary and t i , . . . , t^^ are terms then Xti ... t^ is a formula. 
— If (/? is a formula and X is a relation variable then 3X(p is a formula. 
The free occurrence of a variable or of a relation variable in a second-order 
formula is defined in the obvious way and the notion of satisfaction is ex-
tended canonically. Then, given (p = (p{xi,... ^Xn^Yi, -- - ^Yk) with free (in-
dividual and relation) variables among xi,... 
,Xn, Yi,..., Ffe, a r-structure 
A, elements a i , . . . , an G A, and relations i^i,..., i^^ over A of arities corre-
sponding to Yi,..., yjfe 5 respectively, 
A \= 
ip[ai,...,an,Ri,...,Rk] 
means that ai,...,a^ together with Ri,... 
,Rk satisfy (f in A. 
For any r the class EVEN[r] of finite r-structures of even cardinality is 
axiomatizable in second-order logic (but not in first-order logic, as we saw in 
2.3.5). In fact, EVEN[r] = Mod((/?), where (^ is a sentence expressing "there 
is a binary relation which is an equivalence relation having only equivalence 
classes with exactly two elements", e.g., 

38 
3. More on Games 
3X{\/xXxx 
A \/x\/y{Xxy 
-^ Xyx) A \/x\/y\/z{{Xxy 
A Xyz) -^ Xxz) 
A\fx3^^y{Xxy 
A y j^ x)). 
We are mainly interested in the fragment MSO of second-order logic known as 
monadic second-order logic. In formulas of MSO only unary relation variables 
("set variables") are allowed. We write A =^^^ B if A and B satisfy the same 
monadic second-order sentences of quantifier rank < m (the quantifier rank 
is the maximal number of nested first-order and second-order quantifiers). 
As in first-order logic, =J)J^^ can be characterized by an Ehrenfeucht-
Fraisse game, MSO-Gm{A,B). 
The rules are the same as in the first-order 
Ehrenfeucht-Fraisse game, but now in every move the spoiler can decide 
whether to make a point move or a set move. The point moves are as 
the moves in the first-order case. In a set move the spoiler chooses a sub-
set P C A oi Q C B, and then the duplicator answers by a subset 
Q C B or P C A, respectively. After m moves, elements ai,...,ar and 
subsets P i , . . . , Ps in A, and corresponding elements 61,..., 6^ and subsets 
Qi,..., 
Qs in P (with m = r + s) have been chosen. The duplicator wins if 
a^be 
Part((^, P i , . . . , P,), (;B, Qi,..., Q,)). 
Theorem 3.1.1 A =^^^ B iff the duplicator wins MSO-G^(^,^). 
The following exercise leads to a proof of this theorem (along the lines of 
the proof of the corresponding result 2.2.8). 
D 
Exercise 3.1.2 Given A,a{=ai... 
a^) in A, and P (= Pi ... Pg) a sequence 
of subsets of A, define the formulas ipi — similar to the j-isomorphism type 
(p^, but now taking into account also the second-order set quantifiers: 
/\{^{vi,..., 
i'r, Vi,..., Vs) I if atomic or negated atomic, A |= (p[a, P]} 
aeA 
aeA 
PCA 
PC.A 
Show the equivalence of 
(i) 
The duplicator wins MSO-G^((^,P,a), (H, Q, 6)); 
(ii) ^ h V ^ ^ p ^ Q ] ; 
(iii) a, P satisfies in A the same formulas of MSO of quantifier rank < m as 
h.Q'mB. 
U 
As in first-order logic (compare 2.2.6) or by a direct proof, one easily gets 
the following result which we need later. 
Proposition 3.1.3 For a fixed vocabulary and m G N, the relation =J5J^^ is 
an equivalence relation with finitely many equivalence classes. 
D 

3.1 Second-Order Logic 
39 
We give an application of the gametheoretic characterization. 
Proposition 3.1.4 The disjoint union and the ordered sum} preserve the 
relation =^^^, 
i.e., for relational r we have: 
(a) IfAi 
=^so Bi and A2 =^^^ ^2 then A1UA2 =^^^ B1UB2. 
(b) // Ai ^^^"^ Bi and A2 =^^^ B2 then Ai <\ A2 =^^^ Bi < B2. 
Proof. The proofs for (a) and (b) proceed in the same way. So let * € {U, <}. 
Assume 
A = ; ^ ^ ° B x 
and 
^ 2 = r ° B 2 . 
By hypothesis and the last theorem there are winning strategies Si and 52 
for the duplicator in the games MSO-Gm(^i,^i) and MSO-Gm(^2,^2), re-
spectively. Then the following represents a winning strategy for the duplicator 
in MSO-Gm(^i * A2,Bi * B2) (when describing it we use moves of plays in 
MSO-Gni(^i,^i) and MSO-G^(^2,>B2)). Suppose first that the i-th move 
of the spoiler is a point move where he selects, say, a E Ai ^ A2. Then the 
duplicator gets his answer by applying 5i if a E ^ 1 , and 52 if a G ^2 • Now 
assume that the spoiler selects, say, P C Ai U A2. Set Pi := P f] Ai and 
P2 := P n ^2- Let Qi and Q2 be the selections of the duplicator according to 
Si and ^2, respectively. Then, in the game MS0-Gm(v4i * A2,Bi * B2), the 
duplicator chooses QiUQ2- 
• 
An easy induction using equivalences such as 
[= -^3Xip ^ \/X^ip, 
h (^ V VFV') ^ Vy((^ V V) 
HY is not free in v?, 
shows that each (M)SO-formula is logically equivalent to an (M)SO-formula 
in prenex normal form, that is, to a formula of the form 
Qiai 
...Qsagi/J, 
where Qi,-.. ,Qs G {V, 3}, and where a i , . . . , a^ are first-order or second-
order variables and ip is quantifier-free. Moreover, since 
\=3xQiai...Qsasip 
^ 
3XQiai.. 
.Qsas{3=^xXx 
A^x{Xx 
-^ ip)), 
^\/xQiai...Qsasil^ 
^ 
^XQiai.. 
.Qsas(3^^xXx 
-^\/x{Xx 
-^ ip)), 
every (M)SO-formula is logically equivalent to one in prenex normal form in 
which each second-order quantifier precedes all first-order quantifiers. Such a 
formula is called (M)Ej^, if the string of second-order quantifiers consists of 
n consecutive blocks, where in each block all quantifiers are of the same type 
(i.e., all universal or all existential), adjacent blocks contain quantifiers of 
different type, and the first block is existential. (M)nJ^-formulas are defined 
in the same way, but now we require that the first block consists of universal 
quantifiers. 
^ Compare 1.A3 for the definition of disjoint union and ordered sum. 

40 
3. More on Games 
In particular, 3X3YWZyx3yip 
with quantifier-free (/? is a S2-formula. 
Clearly, the negation of a Ej^-formula is logically equivalent to a IlJ^-formula, 
and the negation of a nj^-formula to a Sj^-formula. Moreover, denoting by 
A\ the set of formulas that are logically equivalent to both a Ej^-formula and 
a nj^-formula, we have up to logical equivalence 
C, 
^C 
<^ 
Ai 
A^ 
vC 
C, 
^ 
which can easily be verified by adding dummy variables. The same inclusions 
hold for the monadic classes. 
It can be shown that for arbitrary models all the inclusions above are 
proper (this also holds for MSO). The question to what extent the hierarchies 
are proper in the finite is related to important questions of complexity theory 
(cf. Chapter 7). We have seen in section 2.4 that the class of finite, connected 
graphs is MllJ-axiomatizable but not MEj-axiomatizable. Thus, in the finite, 
MS} 7^ MnJ. 
3.2 Infinitary Logic: The Logics Loow and L^^^ 
In recent years even infinitary logics have turned out to be relevant in the 
context of finite model theory. In fact, they contain some of the logics impor-
tant in descriptive complexity theory (see Chapter 7), but - in contrast to 
them - their expressive power allows a manageable characterization in terms 
of games, similar to that of first-order logic. In this and the next section we 
introduce these logics and deal with their gametheoretic aspects. 
The infinitary logics Loou; and L^.^^ allow arbitrary and countable dis-
junctions (and hence conjunctions), respectively. More formally: Let r be a 
vocabulary. The class of Looa;-formulas over r is given by the following clauses: 
— it contains all atomic first-order formulas over r 
— if (^ is a formula then so is ->(/? 
— if (/9 is a formula and x a variable then 3x(p is a formula 
— if ?Z^ is a set of formulas then V ^ is a formula. 
For L^^o; we replace the last clause by 
— if ?F is a countable set of formulas then V ^ is a formula. 
The semantics is a direct extension of the semantics of first-order logic with 
V ^ being interpreted as the disjunction over all formulas in iZ^; hence, ne-
glecting the interpretation of the free variables, 
A\=\/^ 
iff 
for some ip e^, 
A\=ip. 

3.2 Infinitary Logic: The Logics Looo; and L^j-j^uj 
41 
We set /\ ?Z^ := -I Vl""^ | ^ G ?Z^}. Then /\ I?' is interpreted as the conjunction 
over all formulas in W. By identifying (ip V -0) with \/{(p, '0} we see that LQOU; 
and L^^^ are extensions of first-order logic. 
Examples 3.2.1 (a) For any r, the models of the L^^^^-sentence 
Vi^-n I n > 1}, 
where (p=n is a first-order sentence expressing that the universe has cardinal-
ity n, are the finite r-structures. The L^;^^-sentence \/{(p=2n \ n >1} axiom-
atizes the class EVEN[r]. Similarly, if M is any nonempty set of positive nat-
ural numbers, then the class of models of the L^.^^;-sentence \/{(p^k \ k G M} 
corresponds to the query "||A|| G M?". In particular, we see that nonrecur-
sive queries are L^.^^-definable. We get even more: 
(b) Any class of finite structures is axiomatizable in Lu^-^w In fact, let ii^ be a 
class of finite structures. Choose, using 2.1.2, a set ^ of first-order sentences 
such that K = Mod(^). Then K = Mod((/9) for the L^^^-sentence cp := /\^. 
(c) "Connectivity" is a property of graphs expressible in L^^^ by 
\Jxiy{-^x = 2/ ^ \/Wn{x,y) 
I n > 1}), 
where (pnix,y) is a first-order formula saying that there is a path from x to 
y of length n, 
(Pn{x, y) 
: = 
^ZQ... 
3Zn{zo 
= X A Zn = y A EZQZI 
A . . . A EZn-lZn)- 
• 
Loou)-sentences are Looa;-formulas without free variables. While Looa;-formulas 
may have infinitely many free variables (V{~'^i = i'^ | 1 < i < j} is an 
example), it can easily be seen that subformulas of LQOU;-sentences only have 
finitely many free variables. In the following we restrict ourselves to Looo;-
formulas with only finitely many free variables. 
The next two propositions - and in particular the proof of the first one -
show that we need not more than L^^^ in the context of finite model theory, 
although it has become popular - and we follow this tradition - to mainly 
consider Looa;-
Proposition 3.2.2 (a) In the finite, every 1JoQ^jj-formulci ^{x^ is equivalent 
to an L^^^-formula 
ip{x). 
(b) Assume A and B are finite. For every Loouj-formula ^{x) there is an 
FO-formula tpix) such that 
A \= \/x{ip{x) ^ il;{x)) 
and 8 \= \/x{cp{x) ^ ip{x)). 
In both cases, (a) and (h), the formula ip can be chosen such that free(^) C 
fiee{(p) and that every variable occurring in ijj (free or bound) occurs in if. 

42 
3. More on Games 
Proof. The proof of (a) and (b) is by induction over the rules for Loou;-
formulas. The translation procedure preserves the "structure" of formulas 
and only replaces infinitary disjunctions by countable ones (by finite ones in 
(b)). In the main step suppose that 
^(x) = yWiix) 
\iei} 
is an Looa;-formula. For each finite structure C with universe {1,2,...,||C||} 
(for C E {A, 8} in (b)) and each c G C, if there exists an i G / such that 
C 1= ^i\c], choose such an i. Let /Q be the set of z's chosen in this way. Then 
/o is countable (finite in (b)) and \/{(pi{x) \ i e 1} and \/{(fi{x) \ i E IQ} are 
equivalent in the finite (in A and 8). 
D 
Since every finite structure can be characterized in first-order logic, we 
obtain the following improvement of part (a) of the preceding proposition (cf. 
3.2.1(b)): 
Proposition 3.2.3 In the finite, every Loou-formula (p{'x) is equivalent to a 
countable disjunction - and hence to a countable conjunction - of first-order 
formulas. In fact, in the finite, (p(x) is equivalent to 
yWXt'i^} 
I -4 finite, aeA,A^ 
ip[a]}. 
Proof. For simplicity we restrict ourselves to sentences. Let H be a finite 
structure. If 8 \= ^ then cp^j^ " 
is a member of the disjunction which, 
therefore, is satisfied by 8. Conversely, if 8 satisfies the disjunction, then for 
some finite A with A^^pwe 
have 8 \= (p^]^^^^\ Therefore by 2.2.10, A ^8; 
hence, 8 [= (p. 
D 
We say that A and 8 are hoo^-equivalent^ A=^°°'^8, if A and 8 satisfy the 
same Looa;-sentences. In order to characterize =^000,^ Q^e needs Ehrenfeucht 
games with infinitely many moves. 
Definition 3.2.4 Let A and 8 be structures, a € A^, and h G B^. The game 
Goo{A,a,8,b) 
is the same as the game Gm{Aya,8,b) 
up to the fact that 
now each player has to make infinitely many moves. Thus, in the course of a 
play of Goo (A, a, 8, b), elements ei, 62,... in ^ and /i, /2,... in ;B are chosen. 
The duplicator uiins the play if aei .. .ei ^ bfi... fi G Part(^,8) for all i, 
and the spoiler wins if aci... e^ 1-^ 6/1... ft ^ Part(v4,8) for some i. The 
duplicator wins Goo (-4., a, 8,b) if he has a winning strategy. 
D 
Immediately from the definition we get: 
Lemma 3.2.5 Suppose that the duplicator wins Goo{A,a,8,b). 
Then 
(a) a 1-^6 G Part(^,H). 
(b) For a e A there is b ^ B such that the duplicator wins Goo {A, aa, 8, bb). 

3.2 Infinitary Logic: The Logics Loow and L^J-^UJ 
43 
(c) For b e B there is a e A such that the duplicator wins Goo (^5 aa, B, bb). 
D 
Since we want to give the Ehrenfeucht-Fraisse type characterization of 
^Looa> in its different forms we define: 
Definition 3.2.6 (a) A and B are said to be partially isomorphic, 
written 
A =part B, if there is a nonempty set / of partial isomorphisms from A to 
B with the back and forth properties (that is, for every p E I and every 
a E A {b E B) there is g G / with q ^ p and a G do{q) {b G rg(g))). We then 
write / : A =part B. 
ih)Woo{A,B) 
-
{ah^b\ 
s eN,ae 
A^,be 
B^, the duphcator wins Goo{A,a, B,b)} 
is the set of winning positions for the dupUcator. 
D 
LOGO;-equivalence and the notions just introduced are intimately related: 
Theorem 3.2.7 For structures A and B, a e A^, andb G B^ the following 
are equivalent: 
(i) 
The duplicator wins 
Goo{A,a,B,b). 
(ii) ah^be 
Woo {A, B) and Woo {A ^) ' A =part B. 
(iii) There is a set I with a \-^b E I such that I : A —partB. 
(iv) a and b satisfy the same formulas of Looo; in A and B, respectively, that 
is, if (p{xi,..., 
Xs) is a formula of Loou;? then 
A \= ^[a] 
iff 
B\= v[b]-
Proof For (i) => (ii) see the preceding lemma; clearly (ii) implies (iii). For 
(iii) ^ (i) note that a set / with a 1-^ 6 G / and / : A —part B can be 
viewed as a winning strategy for the duplicator for the game Goo(v4,a, ;B, 6). 
Hence, it suffices to show the equivalence of (iii) and (iv). Let / be as in 
(iii). By (transfinite) induction on the quantifier rank of the Loou;-formula 
ip{xi,..., 
Xs) we prove 
(*) 
A\=v>le] 
iff 
B\=^[J] 
for any ei.. .eg i-> / i . . . / s G /. The case of quantifier rank 0 is handled by 
part (c) of 2.2.2. For arbitrary quantifier rank note that the class of formulas 
satisfying (*) contains the atomic formulas and is closed under -> and V-
Suppose that (p{xi,... ,Xs) = 3yip{xi,... 
,Xs,y). Assume, for example, that 
A \= (f[ei,... ,es]. Then there is a e A such that A \= ^[ei,... ,es,a]. By the 
forth property of /, there is 6 G B such that ei ... e^a 1-^ / i . . . fgb G /. Since 
qr(^) < qr((/:'), the induction hypothesis yields B |= V^l/i,...,/«, 6]; hence, 
B^^[h,...,fs]. 

44 
3. More on Games 
Suppose now that (iv) holds, and let / be the set of all partial isomor-
phisms ei .. .Cr I-)- fi • • • fr (with r > 0) such that for all Looa;-formulas 
A^^[e] 
iff 
B^^[f]. 
By (iv), a i-> 6 G /. We show that / has the back and forth properties. So, 
let ei ... e^ 1-^ /i ... /r G / and a G /. For each 6 G 5 , if there is a formula 
ip{xi,... 
,Xr,x) of LooLo such that 
A[=^ (p(x,x)[ea] 
and B \= ^ip{x,x)[fh], 
let ipi){x,x) be such a formula; otherwise, set ipb{x,x) := 
x = x. Since 
A [= 3x /\{(pb I b G B}[e], we have B [= 3x /\{(pb \ b G B}[f]. Hence, there 
is 6' G -B such that B \= /\{(pb \ b G B}[fb']. Using the definition of (pi)', one 
easily sees that ea and fb' satisfy the same formulas of Loou; in A and B, 
respectively, and hence, ea i-> fb' G /. The back property is proven similarly. 
D 
Since Woo{A,B) ^^ 0 iff 0 i-> 0 G Woo{A,B) (cf. 3.2.7), we obtain the 
Corollary 3.2.8 For A and B the following are equivalent. 
(i) 
The duplicator wins Goo(A,B). 
(ii) Woo{A,B) : A =part B. 
(iii) A ^part B. 
(iv) A =Loo. ^, 
• 
To give some applications we first show: 
Lemma 3.2.9 Let A and B be countable. 
(a) // A ^part B then 
A^B. 
(b) If I : A =part B and po £ I then po can be extended to an isomorphism 
from A onto B. 
Proof. Let A = {ai,a2,...} and B = {bi,b2,. • •}- It suffices to show (b). 
Suppose / : A =part B and po ^ -^- By repeated application of the back 
and forth properties, one obtains pi,p2,... 
in / such that po C pi C ... 
and such that ai G do{pi),bi G rg(p2),a2 G do(p3), — Then |Jn>o^^ ^^ ^^ 
isomorphism from A onto B. 
D 
Corollary 3.2.10 If A and B are countable and LQQ^-equivalent then they 
are isomorphic. 
Proof The claim follows immediately from 3.2.8 and 3.2.9(a). 
D 
The following example will be of importance in the next chapter. 
Example 3.2.11 Let r be relational. For r > 0 let A^+i be the set 
A^+i := {v?(^i,.. • ,Vr,Vr+i) I (p has the form i^x, where R ^ r and 
where Vr+i occurs in x}. 

3.2 Infinitary Logic: The Logics Loow and L^^^co 
45 
For a subset ^ of A^+i the sentence x^ := ^ 
l<i<j<r 
l<i<r 
(pG'^ 
cpE'^'^ 
where ^^ := A^+i \ ^ , is called an extension 
axiom, more precisely, an (r+1)-
extension 
axiom. The set Trand of all extension axioms gives the 
random 
structure 
theory.^ Clearly, 
— every model of ^rand is infinite. 
The extension axioms in Trand guarantee for any models A and B of Trand 
that the set 
/ 
:= 
{a^b\ae 
A, be B, ^nd ^\-^ 
= if^^^} 
has the back and forth properties. For a proof let a i-> 6 G / , where a = 
ai .. .Or and a i , . . . , a ^ can be assumed to be distinct, and let, say, a^+i be 
in A \ { a i , . . . , a r . } . Set ^ := {kp{vi,... 
,Vr+i) \ ^ G A^+i, A |= (/?[aar.+i]}. 
As B 1= x$, there is an element 6^-+! ^ B such that ^ ^ i-. 
= V^^laa^. i' 
that 
I-)- 66^+1 G /. Moreover, since r is relational, the empty partial 
isomorphism is in /. Hence, / : A =part B. By 3.2.8 we get: 
— Any two models of Trand are Looa;-equivalent and thus, for each Looo;-
sentence (/?, Trand ^ (^ or Trand 1= -'^' 
Finally we show 
~ Trand has a countable model and hence by 3.2.10, an (up to isomorphism) 
unique countable model 7^, the so-called infinite random 
structure. 
In fact, let (an)n>o be an enumeration of all pairs (m, x), where m is a tuple 
of distinct natural numbers and % is an (r + 1)-extension axiom, where r := 
length(m); moreover suppose that for an = (m, x) all entries of m are not 
greater than n. By induction on n we define structures An with 
An = {0,...,n} 
and AQ C Ai C A2 C ... 
such that A := [Jn>o^ri 
is a model of Trand: Let Ao = (Ao,(0)i?Gr) (each 
relation symbol is interpreted by the empty set). Suppose An has been defined 
and an — ( m i , . . . , m^, x) with x = X^- Define Anw 
with universe ^n+i such 
that An ^ An^i 
and such that for ^ G A^+i 
^^+1 ^ V?[mi,...,m^,n + 1 ] 
iff 
(/? G ^ 
(note that f^+i occurs in every formula of A^+i). This ensures that A := 
Un>o -^ri is a model of x- 
• 
In case r = 0 this sentence reduces to 3i;i(/\ ^^ (^ A l\ ^^c ~^f)-
The name will become clear in Chapter 4. 

46 
3. More on Games 
We close with a further apphcation of 3.2.8. For a sentence (^ let the 
spectrum Spec((/^) of ^p be the set 
Spec((/?) := {m > 1 | there is A\= ^ with ||A|| = m}. 
Proposition 3.2.12 For any first-order sentence (p at least one of Spec{(p) 
or Spec(-i(^) is cofinite {i.e., for some no,{n | no < n} C Spec((/?) or {n \ 
no <n} C Spec(-i(^)). 
Proof. Let ^ be the set of the sentences 
(i) 
ip>m 
for m > 1 
(ii) WRx 
for jR G r 
(iii) c = d 
for c, d G r. 
Clearly, ^ is satisfiable and any two models A and B oi ^ are partially 
isomorphic via I := {p e Part(^, B) | do(p) finite}, and hence by 3.2.8, 
elementarily equivalent. Therefore, given a first-order sentence (^, we have 
^ 1= 99 or ^ 1= -199, say, # |= (/?. By the compactness theorem there is a finite 
#0 ^ ^ such that ^0 1= ^- Let no be larger than any m such that ^>m is in 
^0- Then ^0 and hence, ip has a model of cardinality n for each n > no- 
• 
Exercise 3.2.13 Prove the previous result for "vocabularies" containing 
function symbols. Hint: Compare the passage from such a vocabulary to a 
function-free one given in l.D. For any new relation symbol F corresponding 
to some / G r, in (ii) above take the sentence \fx{3^^xFxx 
A Fxxi) instead 
of ^xxFxx. 
D 
Exercise 3.2.14 For any A and B we have 
Wo{A,B) D ... D Wm{A,B) D ... D Woo{A,B). 
Show that in case A or 5 is finite there is an mo < 1 + min{||A||, \\B\\} such 
that 
Wo{A,B) D ... D Wmo{A,B) = WooiA,B). 
D 
3.3 The Logics FO^ and L 00a? 
In first-order logic FO, every finite structure A can be characterized up to 
isomorphism by a first-order sentence ipj[ which, in general, needs \\A\\ + 1 
variables (compare, for example, the proof of 2.1.1). Hence, an arbitrary class 
K of finite structures can be axiomatized in Looa; by the sentence 
yWA 
\AeK} 
which, in general, contains infinitely many variables. Since every class of fi-
nite structures is axiomatizable in it, Looa; is too powerful in the finite to 

3.3 The Logics FO" and L^^ 
47 
yield new general principles. The observation above motivates the restriction 
to formulas of LQOU; containing only finitely many variables. In the present 
section we shall see that this approach really leads to logics which are inter-
esting from the perspective of finite model theory. 
Fix s > 1. We denote by L^^ and FO* the fragments of Looo; and FO, respec-
tively, containing only formulas, whose free and bound variables are among 
vi,... 
,Vs. Moreover, we set 
TO; 
._ I I T S 
Whereas FO = IJs>i ^0*, the formula \l{ip^n \n>l} 
belongs to Looa; but 
not to L^^. 
Let X = vi,y = V2, and z = vs in examples. 
Examples 3.3.1 (a) Let r = {<}. There are FO^-formulas ipn{x) and Xn 
such that for orderings A, a £ A, and n > 0, 
A 1= ^pn[o] 
iff 
a is the n-th element of <'^, 
and in case n > 1, 
A^Xn 
iff 
P l l = n . 
In fact, define inductively 
ipo{x) := yy^y 
< x, 
i^n+i{x) := 'iy{y < x ^ \J 3x{x = y Aipi{x))), 
i<.n 
and set Xn '= ^xipn-iix) 
A -^3xipn{x)' 
(b) For each n > 1 there is an FO^-formula ^n{x, y) that in digraphs expresses 
that there is a path of length at most n from a: to y. In fact, let 
^i{x,y) 
:= 
Exy, 
(Pn+i{x,y) 
:= 
ipn{x,y) V 3z{EzyA3y{y 
= 
zAipnix,y))). 
Concerning the quantifier rank we can do better than in -0^ and ^n' Let (p be 
an LJo^-formula and TT a permutation of 1,..., s. By simultaneously replacing 
both the free and the bound occurrences of vi,... 
,Vs by ^7^(1),...,v^f^g) 
one 
obtains a formula 
v^m 
... VT,fs\ 
^ \ 
Clearly, 
"^ \ 
vi 
... 
V, 
^ N ^ (''^^;^l ::; 2^'^) m 
iff 
A ^ ^K^),...,«.(,)]. 

48 
3. More on Games 
Now in the preceding examples we can replace ipn and (fn by the formulas 
?/^^ and (f'^ of quantifier rank < n + 1, where 
D 
We write A =^ B y A =^^-'i3, and A = ^ i5 to express that A and B satisfy 
the same sentences in FO^, in LJ^^, and in FO* of quantifier rank < m, 
respectively. 
In view of 3.2.2(b) together with the last remark of 3.2.2 we have 
Proposition 3.3.2 Assume A and B are finite. For every h^^^-formula ip 
there is an FO^-formula ip with free(^) C free((p) such that 
A\=\/xi.. 
.\/xs{(p i-> i^) 
and B [=\/xi.. .\/Xs{ip ^ ip). 
Corollary 3.3.3 If A and B are finite then 
A=^ B 
implies 
A=^'^-'B. 
Proof Given an LJ^^-sentence ip, choose -0 according to the preceding propo-
sition. Then 
A\=(f 
iff 
A^ip 
iff 
5 ^ ^ 
iff 
B\=cp. 
D 
Clearly, if (/? G FO^ (or, cp G LJ^^) then every subformula of (p contains at 
most 5 free variables (namely, at most vi,... 
,Vs). This property characterizes 
the formulas of FO* up to logical equivalence: 
Proposition 3.3.4 Assume s > 1. If every subformula of(p(vi,... 
,Vs) G FO 
has at most s free variables, then (p is logically equivalent to a formula o/FO*. 
The statement remains true, if we replace FO and FO^ by Loou^ and L^^, 
respectively. 
Proof. By induction (on the quantifier rank) we associate with every formula 
(p{vi,... ,Vs) all of whose subformulas have at most 5 free variables, a formula 
(p* with 
1= (/? -H- (/?*, free((/?) = free((/?*), ip* G FO*. 
For atomic ip set (p* := (p, for (p = -^x and cp = (xi V X2) set ip* :— -^x* and 
ip* = (xi V xS)? respectively. Now, let (p = ^yx- Then, 
(*) 
free(x) 
C {vi,...,Vs,y} 
and ||free(x)|| < s. 

3.3 The Logics FO^ and L^^ 
49 
If 2/ ^ free(x) then x = xi'^i^ - • • ^^s) and x* is defined by induction hy-
pothesis. We set ^* := x*- If ?/ ^ free(x) and y G {vi,... 
,Vs} then, again, 
X = x('^i5 • • • 5'^s) and x* is defined, and we set ip* := 3t/x*. Finally sup-
pose ^ G free(x) and ^ ^ {vi,.. .^Vg}- Then, by (*), there is an i such 
1 (as in the preceding example, 
y '^i J 
Xo := X ( 
* 
I is obtained from x by simultaneously replacing all oc-
currences of y and vi by Vi and 2/, respectively). Then, |= (^ ^ 
^t'^xo, 
free(xo) ^ {^i,... ,t's}, and every subformula of xo has at most s free vari-
ables. Thus, Xo is defined and we can set </?* := ^ViXo-
3.3.1 Pebble Games 
Our next aim is an Ehrenfeucht-Frai'sse type characterization of the equiva-
lence of structures in FO* and in LJ^^. To motivate the intended games we 
look at (/p = 3x3y{x < y f\3xy 
< x) and the orderings A := ({a, 6}, <) and 
B :— ({c, c?, e}, <) where a <b and c < d < e. Since A \= -^(p and B \= (f, the 
spoiler has a winning strategy in 03(^4, B). How is the fact that xp only con-
tains two variables reflected in the course of a play? A play won by the spoiler 
is given in the following table, where his selections have been underlined. 
B 
first move 
a 
second move 
b 
third move 
? 
There is no third move of the duplicator leading to a partial isomorphism. 
Apparently, the strategy of the spoiler consists in choosing, for the first two 
quantifiers 3x3y, the elements c for x and d for y in B in order to have-
B \= (x < y /\3xy 
< x)[c,d]. 
The only selections for the duplicator leading to a partial isomorphism are 
a for X and b fox y. Now, for the second quantifier 3x, the spoiler selects in 
B the element e, thereby getting a witness ior B \= 3xy < x[d]. Obviously 
the old value c for x is no longer relevant. Therefore, the play above may be 
represented more informatively by 
first move 
A 
B 
a 
c 
* 
* 
second move 
A 
B 
a 
c 
b 
d 
third move 
A 
B 
? 
e 
b 
d 
x-box 
^-box 
where the a;-boxes and the y-boxes always contain the actual value for x and 
y, respectively, and * stands for an empty box. 

50 
3. More on Games 
This example motivates how to adapt the Ehrenfeucht-Fraisse method 
to our situation: As always, fix a vocabulary r. By convention, * will not 
belong to the universe of any structure. For a £ {AU {*})^,a = a i . . .a^, 
let supp(a) := {i | a^ G A} be the support of a, and if a G A, let a j denote 
ai... ai-iaai+i ... ag. For a G (AU{*})* and b G (5U{*})* we say that a i-)- 6 
is an s-partial isomorphism from A to B, if supp(a) = supp(6) and a' \-^b is 
a partial isomorphism from A to B, where a' and b are the subsequences of 
a and b with indices in the support. 
Let A and 5 be structures, a G (A U {*})^ 6 G (5 U {*})^ with 
supp(a) = supp(6). In the example above we had available a box for each 
relevant variable. It has become customary to replace the boxes by pebbles. 
Thus, in the pebble game G^{A,a,B,b) 
we have s pebbles a i , . . . ,as for A 
and s pebbles /?i,...,^g for B. Initially, ai is placed on a^ if a^ G A, and off 
the board if a^ = *, and similarly, pi is placed on bi £ B or off the board. 
Each play consists of m moves. In his j-th move, the spoiler selects a struc-
ture, A or B, and a pebble for this structure (being off the board or already 
placed on an element). If he selects A and a^, he places ai on some element 
of A, and then the duplicator places Pi on some element of B. If the spoiler 
selects B and pi, he places pi on an element of B and the duplicator places ai 
on some element of A. (Note that there may be several pebbles on the same 
element.) 
The duplicator wins the game if for each j < m we have that e i-> / is 
an s-partial isomorphism, where e — e i . . . e^ are the elements marked by 
a i , . . . , CKs after the j-th move (e^ = * in case ai is off the board) and where 
f — fi • • • fs are the corresponding values given by /3i,..., /3s. For j = 0 this 
means that a H-)- 6 is an s-partial isomorphism. 
The pebble game GJo(A,a, 5,6) with infinitely many moves is defined 
similarly. We use G^(A, B) as abbreviation for G^(A, *...*, ;B, * ... *) and 
G?,(AS) for G^(A*...*,B,*...*). 
The following theorem shows that the logics and the games fit together. 
Here and later, when writing A |= ip\a] for a G (A U {*})* we tacitly assume 
that the free variables of if have indices in supp(a) (that is, z G supp(a) 
whenever Vi G free((^)). 
Theorem 3.3.5 For structures A and B, and for a G (A U {*})^ and b G 
(5 U {*})* with supp(a) = supp(6) the following hold: 
(a) a satisfies in A the same FO^-formulas of quantifier rank <m 
asbinB 
iff the duplicator wins G%^ (A., a, B^ b). 
(b) a satisfies in A the same L J^^ -formulas asbinB 
iff the duplicator wins 
G%,{A,a,B,b). 
In particular, 
(c) A =^ B iff the duplicator wins 
Gf^{A,B). 
(d) A =^^^<^B iff the duplicator wins 
GIQ{A,B). 

3.3 The Logics FO" and L^^ 
51 
Before proving the theorem we give some examples, whose claims are 
easily verified. 
Examples 3.3.6 (a) Let r — $ and let A and B be r-structures (i.e., 
sets). If ||A||, ll^ll > s then the duplicator wins GIQ{A,B) 
(or, equivalently, 
A =^^°ou^8). Moreover, for arbitrary A and B, the duplicator wins G^(^, B) 
iffhewinsG^(A>^)-
(b) For / > 3, let Qi and QiUQi be the graphs consisting of one and two 
cycles, respectively, of length / + 1 (cf. 2.3.8). Then the duplicator wins 
Gloi^hOiOQi) 
and hence by the theorem, Qi = ^ - - QiUQi, Note that 
Qi ^^oou, QiOQi, since - in the notations of Example 3.3.1(b) - the sen-
tence \/xiy{x 
— yy \/n>o^ri{x,y)) 
of L^^ expresses connectivity. In fact, 
the spoiler wins G^(^^azU^z). 
D 
Further examples are contained in the following exercises. 
Exercise 3.3.7 (a) Assume that the relation symbols in r = {<,...} are at 
most binary. Show that for finite ordered structures A and B, 
A = B 
iff 
the duplicator wins G^(^, B). 
(b) For m > s show that the duplicator wins G^ {A, B) iflF he wins the game 
G^(^, B) with the additional condition that in the first s moves distinct 
pebbles have to be chosen (so that after s moves all pebbles are placed on 
elements). 
(c) Suppose that r is relational and all its relation symbols are of arity < s. 
Assume that the duplicator wins G^(^, ;B) and that ||^|| = ||JB|| < S + 1. 
Show that A^B. 
D 
A proof of Theorem 3.3.5 can easily be obtained from the corresponding 
proofs for FO and Looa;: We introduce for FO* and L^^ the further notions 
related to the Ehrenfeucht-Fraisse method (namely, the back and forth prop-
erties, the m-isomorphism types, and the set of winning positions), and give 
the corresponding statements 3.3.9 and 3.3.10 which imply Theorem 3.3.5. 
Definition 3.3.8 Structures A and B are s-m-isomorphic, A = ^ B, iff there 
is a sequence {Ij)j<m of nonempty sets of s-partial isomorphisms with the 
following properties: 
{s-forth property) For j < m, a \-^ b e Ij+i, 
1 < ^ < 5, and a G A 
there is b e B such that a^ 
{s-back property) For j < m, a ^ 
b e 
there is a e A such that a^ ^ b-
We then write (Ij)j<ni 
:A^tn^' 
The notions s-partially isomorphic^ A 
defined similarly. 
D 
^j+l: 
""part 
n 
, 1 
bl 
B, 
£/,.. 
< i < 
elj. 
and / : 
5, 
A 
and b 
part 
€ 
B 
B 
are 

52 
3. More on Games 
For m G N, any structure A, and a € (A U {*})*, the 
s-m-isomorphism 
type -i/;^ (= ^4>^-a) of a in ^ is given by: 
/^s"!^) 
'•— i\{^ 
I ^ atomic or negated atomic, and A |= V'f^]} 
(recall that when writing A |= ^[a] we assume that the free variables of ip 
have indices in supp(a)), 
In particular, -0^ := '^JJ^ .=^ is an FO^-sentence of quantifier rank m. 
Finally we introduce the sets W^{A^B) and W^{A^B) of 5-partial isomor-
phisms corresponding to winning positions in the respective games, 
W^{A,B) 
:= 
{ai->6| the duplicator wins G^(^,a,^,6)}, 
W^ {A,B) 
: = 
{a i-> 6 I the duplicator wins G^ (^, a, i3,6)}. 
Now the following two theorems can be proven completely parallel to those 
for FO and Loou;. 
Theorem 3.3.9 Let a G (A U {*})^ and b e {B U {*})' with supp(a) = 
supp(6). 
(a) The following are equivalent: 
(i) 
The duplicator wins G^ (A, a, B, b). 
(ii) a^beW^(A,B) 
and{W^'{A,B))j<m:A=tnB. 
(iii) There is {Ij)j<m with a\-^belm 
such that {Ij)j<m '• A =^ B. 
(iv) 
B\=i^^[b]. 
(v) a satisfies in A the same formulas of FO* of quantifier rank < m 
as b in B. 
(b) The following are equivalent: 
(i) 
The duplicator wins GJ^(.4,a,B^b). 
(ii) a^be 
W^{AB) 
and W^A.B) 
: A -^.^t ^• 
(iii) There is I with a \-^ b e I such that I : A =part ^' 
(iv) a satisfies in A the same formulas of L^^ asbinB. 
D 
Corollary 3.3.10 (a) The following are equivalent: 
(i) 
The duplicator wins G^(^, B). 
(ii) (W/(^, B))j<m 
lA^'^B. 
(iii) A^t^B. 
(iv) B t = ^ : j . 
(v) 
A=t,B. 
(b) The following are equivalent: 
(i) 
The duplicator wins GJ^(^, H). 
(ii) W^{A, B) : A ^J^^t ^• 
(iii) ^ =part ^- 
(IY) A=^'^-B, 
D 

3.3 The Logics FO" and L^^ 
53 
Example 3.3.11 For s > 1 let Cg be the conjunction of the finitely many 
r-extension axioms with r < s (cf. 3.2.11). Clearly, €« G FO*. We have: 
— Every model of Cg has at least s elements. 
— Every two models A and B of €« are s-partially isomorphic. 
(The last statement is proved as the corresponding one in 3.2.11.) Therefore, 
by the corollary, any two models of e^ are LJ^^-equivalent, and we get: 
— For every LJ^^-sentence cp^ either Cg \= (f ov Cg \= -^(f- 
D 
The next result provides us with an algebraic tool to show that a class of 
finite structures is not axiomatizable in L^^ or in L^^(=: Us>i LJoa;)-
Theorem 3.3.12 Let K be a class of finite structures. 
(a) For s >1 the following are equivalent: 
(i) K is not axiomatizable in LJ^^. 
(ii) There are finite structures A and B such that 
AeK, 
B^K, 
and A ^J^rt ^• 
(b) The following are equivalent: 
(i) K is not axiomatizable in L^^. 
(ii) For every s >1 there are finite structures A and B such that 
AeK, 
B^K, 
and A ^J^rt ^• 
Proof. Clearly, (b) follows from (a). To show (ii) ^ (i) in (a), suppose by 
contradiction, that K = Mod((^) for some ^ E L^^. Choose A and B as given 
by (ii). Then A \= (p (since A e K), B ^ (p (since B ^ K), amd A =^-->B 
(since A =part ^)^ ^ contradiction. 
Conversely, suppose that the condition in (ii) is not satisfied. Then for all 
finite A and B, 
(*) 
Ae K said A=^'^->B 
imply 
BeK. 
We show that K = Mod((/?) for the L^^-sentence v? := \/AEK Am>o'^A • 
Clearly, K C Mod((p), since B \= Am>o^S^ holds for any B. To obtain the 
inclusion Mod{ip) C K, assume that 5 is a finite model of cp. Then, for some 
Ae K and all m > 0, we have B [= ipj; and hence, A = ^ B. Thus, A =^ B. 
By 3.3.3, we get A =^°°'^B, and hence by (*), we obtain B ^ K. 
D 
The corresponding nonaxiomatizability result for FO* is part (a) of Ex-
ercise 3.3.14 below. 
Example 3.3.13 Let r be the empty vocabulary. The class EVEN[T] is not 
L^^-axiomatizable, since for s > 1 and structures A and B with \\A\\ = s 
and \\B\\ = s -h 1, we have A G EVEN[r] iff H ^ EVEN[r]; but A =LLC.B by 
3.3.6(a). Extend the result to arbitrary r. 
D 

54 
3. More on Games 
Exercises 3.3.14 Let K he a, class of finite structures. Show: 
(a) Tlie following statements are equivalent: 
(i) K is not axiomatizable in FO^. 
(ii) For m > 1 there are finite structures A and B such that 
AeK,B^K, 
d^ndA ^tn ^• 
(b) For any global n-ary relation F on K with n < s the following are 
equivalent: 
(i) r is L^^-definable, i.e. there is an LJ^^-formula (/? such that for 
AeK 
3xida^ A"", 
A\^i^[a] 
iff 
aer{A). 
(ii) r is "closed under the game G^", that means, if A,B e K, a e 
r{A), 
b G B^ and the duplicator wins G^{A,a 
* ... *,H,6 * ...*), 
then b G r{B). 
D 
Exercise 3.3.15 Assume that r is relational and contains only unary re-
lation symbols. Fix s > 1 and let A and B he r structures. Show that 
W!{A,B) = W^{A,B). 
D 
Exercise 3.3.16 For an FO*-formula (p{x) of quantifier rank < m show that 
\= (f ^ \/{'^A,a I ^ ^ Structure, a e A, and ^ |r= (^[a]} 
(argue as in the proof of 2.2.11). 
3.3.2 The s-Invariant of a Structure 
In this section we associate with every s > 1 and every structure A a structure 
A/s, whose isomorphism type captures the L^^-type of ^ in a one-to-one 
fashion (see 3.3.17 below for the precise statement). Later we shall see that 
there is a uniform way to define an ordering on A/s. This will enable us to 
translate some problems from arbitrary structures to ordered ones. For sim-
plicity, let r be relational (we encourage the reader to also treat vocabularies 
with constants). 
Let .4 be a r-structure. The binary relation ^ defined on A^ by 
(*) 
a ~ 6 
iff 
a and b satisfy the same L^^-formulas in A 
is an equivalence relation on A^. By 3.3.9(b), we have a ~ 6 iff the duplicator 
wins G^^{A,a,A,b). 
Let [a] denote the equivalence class of a and 
A/s 
:= 
{[a]\aeA'} 
the set of equivalence classes. We endow A/s with a r/s-structure A/s: for 
every [a] £ A/s, the relations on A/s capture the properties of a in any game 
G^(^,a,...). The relation symbols in r/s (together with their meaning in 
A/s) are: 

3.3 The Logics FO^ and L^^ 
55 
— for every k-aij R £ r U {=} and any ii,...,i^ with 1 < i i , . . . , u < s a 
unary relation symbol i^ji...i^ ; 
RtX 
••= {[a] I S e A ^ 
R^ai,...ai,} 
(the Ri/^^^ij^ capture the isomorphism type of a); 
— for i = 1,..., s a binary relation symbol 5^; 
Sf/' := { ([a], [a']) \ a,a' e A', there is a G A such that [a'] = [af ]} 
{S^ '^ encodes the possible moves of the i-th pebble). 
A/ s is called the s-invariant of A. It captures the L^^-theory of A: 
Theorem 3.3.17 For structures A and B, 
A=^^oo^B 
iff 
A/s^B/s. 
Proof. Suppose first that A/s and B/s are isomorphic and TT : A/s = B/s. 
Set 
/ 
:= 
{a^b\aeA',beB', 
7r([a]) = [b]}. 
We show that / : A —part ^ ^^^ hence, A =^°°^B. / is a nonempty set of 
s-partial isomorphisms (use the relations i^i^...^^). To show, say, that / has 
the s-forth property, assume that a ^-^ b ^ 1,1 < i < s, and a e A. Then 
5f/'[a][af ], hence 5'f/'[6]7r([af ]). By the definition of Sf^% there is b e B 
such that [bh] = 7r([af ]), hence af K> 6f G /. 
Conversely suppose that A =^^^^B. Then W^{A, B) : A ^^^rt ^' For a e A' 
and b e B^ set 
7r([a]) := [b] iff 
a h^ 6 G T^4(^,H). 
Hence, by 3.3.9(b), 
7r([a]) = [6] iff 
a in ^ satisfies the same L^^-formulas as 6 in JB. 
By this equivalence and by the definition (*) of the equivalence relation, TT is 
well-defined and injective; moreover, do(7r) = A/s by the s-forth property of 
W^{A,B) 
and rg(7r) = B/s by the 5-back property. Obviously, TT is compat-
ible with the interpretations of the Ri^,,,i^^, and also with the interpretations 
of the Si (use once more the 5-back and s-forth properties of 
W^{A,B)). 
Therefore, n : A/s ^ B/s. 
D 
We close this section by showing that for finite structures we can replace LJ^^ 
by FO^ In fact, in view of 3.3.2 we have 

56 
3. More on Games 
Proposition 3.3.18 Let A and 8 be finite structures, a £ {AU {*})* and 
be{BU 
{*}y with supp(a) = supp(5). // 
for all LP G FO^ {A |= Lp\a] iffB^ 
(/?[&]) 
then 
for all V G LJ,„ (A H v[S] # B N vM)- 
• 
Corollary 3.3.19 (a) Let A he a finite structure and ~ he defined as in (*) 
ahove. Then, for a,b £ A^, 
a ^b 
iff 
a and b satisfy the same FO^ -sentences. 
(b) For finite structures A and B, 
A='B 
iff 
A/s^B/s. 
Proof, (a) is immediate from the preceding proposition and (b) follows from 
3.3.17 by 3.3.3. 
D 
3.3.3 Scott Formulas 
For a finite structure A we saw in 2.2.10 that a single FO-sentence, e.g. 
(/^^^ " 
, characterizes A up to (isomorphisms and therefore up to) LQOU;-
equivalence. We are going to show a similar result for FO^ and LJ^^, in this 
way strengthening 3.3.3. 
Proposition 3.3.20 Let A and B be structures. Then 
(a) WS{A,B)DW{{A,B) 
D... 
(b) If A and B are finite then there is an m < {\\A\\ + 1)^ • {\\B\\ + 1)* such 
thatW^{A,B) 
= 
W^^M,^)' 
(c) Form 
> 0, ifW^{A,B) 
= W^^^{A,B) 
and W^(A,B) 
is nonempty, 
thenW^(A,B):A^pe.rtB. 
Proof, (a) follows immediately from the definition of the Wj{A,B). 
(b) fol-
lows from (a), since there are at most (||A|| + 1)* • {\\B\\ + 1)* s-partial iso-
morphisms from 
AtoB. 
(c) Suppose that W^{A,B) 
= W^^-^{A,B). 
Then W^{A,B) 
has the s-back 
and the s-forth property: To show, say, the s-forth property, let a i-^ 6 G 
W^{A,B), 
1 < i < s, and a e A. By assumption, a \-^b e W^_^i{Aj B), and 
therefore there is 6 G 5 such that aj -^ bj e W^iA^B). 
If, in addition, 
W^{A,B) 
^ 0, we altogether have wi{A, 
B) : A =part B. 
D 
Fix a finite structure A and let a, 6 range over (AU {*}y. By the propo-
sition we know that 
WSiA, A) D W^{A, 
A)D...OW^{AA)2... 

3.3 The Logics FO" and L^oc 
57 
and that there must be a j with Wj{A,A) 
= Wj^i{A,A). 
The minimal j 
having this property is called the s-rank r(A) of A, r{A) = r{s,A). For given 
a, the formula 
6G(^U{*})^ 
(more exactly, a-a = *cr^,a) is called the s-Scott formula of a in ^ . It is an 
FO*-formula of quantifier rank r(^) + 1 + s. In particular, a A := cr^,,,^ is an 
FO^-sentence. It captures the whole LJ^^-theory of A: 
Theorem 3.3.21 Let A be finite. 
(a) For any structure B, 
B\=aA 
iff 
A=^'^^B. 
(b) For a G (v4 U {*})*; any structure B and 6 G (H U {*})^ with supp(a) = 
supp(6), 
B 1= (JQ:[6] iff a satisfies in A the same h^^^-formulas as b in B. 
Proof. We restrict ourselves to (a). Since ^ |= a^, we have that A =^^°°^B 
implies B \= a^- Now suppose that B \= aA, that is. 
Since B ^ il)'^}'^\ we get *...* ^ 
*...* G VF;(^)(^,>B) (by 3.3.9(a)). 
By the validity of the second conjunct in B^ we have W^,j^AA,B) 
C 
^r{A)+M^^) 
^^d hence, T^;(^)(AB) = ^;(^)+i(^,B). Therefore, by 
3.3.20(c), W^^j^^{A,B) : A ^J^^t ^ and thus, A ^^'^-B. 
D 
Corollary 3.3.22 In the finite, each L^^^-formula ip is equivalent to a count-
able disjunction of FO^-formulas. In fact, cp is equivalent to the 
L^^-formula 
yWa: I A finite, a ^ A, A \= (p\a]}. Moreover, if K is any class of finite 
structures, then ip and \l{(Ta \A^K,a^A, 
A\= v^[a]} are equivalent in all 
structures of K. 
D 
Exercise 3.3.23 For finite A and B show that W^{A,A) 
= W^j^^{A,A) 
and A =L--B imply W^{B,B) = W^^^{B,B). 
Conclude: If A =^'^-B then 
r{A)^r{B). 
D 
As an application of the formulas a-a we give a condition for LJ^^ and 
FO* to coincide in expressive power. 
Let K be a class of finite structures. We say that K is s-bounded if the set 
{r{A) I A G K} of s-ranks of structures in K is bounded. The class K is 
bounded if it is s-bounded for every s > 1. 

58 
3. More on Games 
Theorem 3.3.24 Let K he a class of finite structures. 
(a) For 5 > 1 the following are equivalent: 
(i) K is 8-hounded. 
(ii) On K, every L^^^^-formula is equivalent to an FO^ -formula. 
(iii) On K, every L^^^-formula is equivalent to an FO-formula. 
(b) K is hounded iff FO and L^^ have the same expressive power on K. 
Proof. As (b) is a consequence of (a), it suffices to prove (a). First suppose 
that K is s-bounded and set m := sup{r(v4) \ A ^ K} < oo. Thus, for 
A ^ K and a in A^ the quantifier rank of CTQ: is < m + s + 1 . Let (/? be any 
LJo^-formula. Then the disjunction in the preceding corollary is a disjunction 
of formulas of quantifier rank < m + 5 + 1 and hence, it is a finite one. This 
shows that (i) implies (ii). The implication from (ii) to (iii) is trivial. To show 
that (iii) implies (i) assume, by contradiction, that K is not s-bounded. Let 
AQ^AI^... 
be structures in K of pairwise distinct s-rank. For M C N let 
V^M := 
\J{CJA, I i e M}. 
By 3.3.23, if L, M C N and L 7^ M then not K \= (p^ ^ (fM-^ Hence on 
K, LJQ^ contains uncountably many pairwise nonequivalent sentences and is 
therefore more expressive than FO. 
D 
Example 3.3.25 (a) Suppose T — % and let ^ be a r-structure. Then 
WQ{A, A) — Wl{A, A). Hence, r(^) = 0 and the class K of finite r-structures 
is bounded. Therefore, FO and L^^ have the same expressive power on K. 
(b) By Exercise 3.3.15, the class K of all finite r-structures is bounded, if r 
contains only unary relation symbols. Therefore, FO and L^^ have the same 
expressive power on K. 
D 
Exercise 3.3.26 L^^ is stronger than FO on the class of finite orderings 
and on the class of graphs. (Hint: Use 3.3.1.) 
D 
3.4 Logics with Counting Quantifiers 
To express in first-order logic that there are, say, seven elements with the 
property ^(x) we need, in general, at least seven quantifiers: 
'^x\ .. .^x-j^^ixi) 
l\... Nipix-j) N 
A 
-^Xi — Xj) 
l<i<j<7 
(by 3.3.6(a) we see that in case ^{x) := x = x we really need seven quanti-
fiers) . 
^ Recall that K \= (p means that every structure in JC is a model of cp. 

3.4 Logics with Counting Quantifiers 
59 
Let FO(C), so-called first-order logic with counting quantifiers, and Looa;(C) 
(by short, Cooo;), so-called Looa; with counting quantifiers, be the logics ob-
tained from FO and Loou;? respectively, by adding, for every / > 1, a new 
quantifier 3-^ with the intended interpretation "there are at least /". More 
precisely, extend the calculus of formulas for first-order or infinitary logic by 
the following rule: 
- If (/? is a formula and / > 1 then 3-^xip is a formula 
(here, 3-^x is considered as a new quantifier (binding x) and not as an ab-
breviation as in l.B). Fix the interpretation of these quantifiers by adding 
for ip = (p{x,x) and a ^ A the clause 
A\=^3^^xip[a] 
iflF 
\\{beA\A^ip[a,b]}\\>L 
Since the quantifiers 3-^ are first-order definable, the languages FO(C) and 
Coou; have the same expressive power as FO and Looo;, respectively. The 
situation changes if we restrict ourselves to FO(C)* and C^^, which are 
the fragments consisting of the formulas with variables among vi,... 
,Vs. 
For example, 3-'^xx 
= a: is a sentence in FO(C) not equivalent to any 
sentence in FO^. And \/i^^{3-^^xx 
= x A -^3-^^'^^xx = a:) is a C^^-sentence 
axiomatizing the class EVEN[r] of structures of even cardinality that (by 
3.3.13) is not equivalent to any sentence of L^^. We set C^^ := Us>i ^c ooo;' 
For / > 1, set 3~^xip := 3-^xip A -^3-^'^^x(p, and let 3-^xip :— VX-K/?. Then 
3-''Xip is equivalent to -• \/.</ 3^^XLp. Hence, we would obtain logics of the 
same expressive power when adding the quantifiers 3"^^ instead of 3 - ^ 
Examples 3.4.1 (a) Suppose A and B are finite structures. If A =^^(^) 
B, 
that is, if .4 and B satisfy the same sentences of FO(C) , then \\A\\ = \\B\\ 
(note that 3^11^11 a: x = a; is a sentence in FO(C) ). 
(b) Let r = {<}. The finite models of the sentence of FO[r] 
\/x-^x < X A \/x\/y\/z{{x < y A y < z) -^ x < z) A 
\/x\/y\/z{{y <xAz<x)-^{y<zVy 
= 
z\/z<y)) 
(< is irreflexive and transitive, and the predecessors of any element are lin-
early ordered) are called finite <-forests. For a <-forest A and a ^ A the 
height hj({a) is defined by 
M « ) 
- 
| | { 6 G A | 6 < a } | | , 
and the height h{A) by 
h{A) 
:= 
max{/i^(a) | a G A}. 
The element a is a root if /i^(a) = 0. Every finite <-forest can be character-
ized, up to isomorphism, in FO(C) , i.e., for every finite <-forest A there is 
a sentence cp in FO(C) such that for all finite <-forests B, 

60 
3. More on Games 
B^ip 
iff 
8^ 
A. 
To prove this one shows by induction on the height, that for <-forests A 
with exactly one root there is a formula 'ipAix) in FO(C) such that for any 
<-forest B and b e B one has 
B ^ ^^[6] 
iff 
Bb ^ A, 
where B^ is the substructure of B with universe {b' ^ B \ b = b' \/ b < b'}. In 
the induction step, for A with root a, II^A{X) gives the number of elements 
of A and, for any isomorphism type of some At with b e A\ {a}, says how 
many trees Ac with c e A\ {a} are of this type. 
(c) For s > 1 there are <-forests A and B that satisfy the same sentences in 
FO^ but are not isomorphic, e.g., <-forests consisting only of roots, the first 
one having s roots, the second one s + 1 roots. 
D 
We conclude this section by adapting the Ehrenfeucht-Frai'sse method to 
the case of counting quantifiers and by demonstrating with an example its 
value for investigating the expressive power of the logics FO(C)* and C^^. 
In the corresponding pebble games C-Gf^{A,a,B,b) 
with m moves and 
C-GJo(^, a, B,b) with infinitely many moves, each move now consists of two 
steps: 
1. The spoiler chooses one of the two structures, say A, and a corresponding 
pebble, say ai. He then chooses a subset X of A. The duplicator must 
answer with a subset F of 5 of the same cardinality as X. 
2. The spoiler places /3i on some element 6 G F. The duplicator answers by 
placing ai on some a G X (X and Y can now be forgotten). 
The definition for winning is given as in the previous pebble games; it only 
takes into consideration the chosen elements, not the subsets. 
To understand what is going on in the two steps of a move suppose that 
the spoiler attempts to show that 
A h= 3'^^x^{x), 
but not B \= 3^^x(p{x). 
He chooses a subset X consisting of/ elements witnessing that A |= 3-^x(p{x). 
The duphcator claims that the elements of the subset Y witness that B |= 
3-^x(p(x). According to the spoilers conviction there is a 6 G F with not 
B 1= ifi[b]. The duplicator means that some element a in X behaves as b. 
Exercise 3.4.2 Let A and B be finite <-forests and assume that the du-
plicator has a winning strategy in C-GIQ{A,B). 
Show that A and B are 
isomorphic. 
D 
The reader will encounter no difficulties when trying to prove the following 
theorem like corresponding preceding results. 

3.4 Logics with Counting Quantifiers 
61 
Theorem 3.4.3 Let A and B be structures, a G (AU{*})* andbe 
(^U{*})* 
with supp(a) = supp(6). 
(a) The following are equivalent: 
(i) For all vp(x) e C ^ , ; A \= ^[a] 
zff_ B [= ^^. 
(ii) The duplicator wins C-G^(^,a, )B,6). 
( b ) ^ = ^ ^ - ; B 
iff 
the duplicator wins C-Gl^{A,B).^ 
D 
We now use this theorem to show that for coloured graphs the expressive 
power of C^^ corresponds to a natural graph-theoretical property. 
Let Ci,C2,... be unary relation symbols, the "colour relations". A 
coloured graph is, for some r, an {^, (7i,..., (7^}-structure Q, where for 
g = (G, E^, C p , . . . , C^) the following holds: 
- {G,E^) is a graph; 
- Cf U ... U C^ = G, that is, each vertex satisfies exactly one colour relation. 
For a £ G the colour type ct(a) is defined as 
ct(a) := (i,ni,...,n^), 
where 
a^Cf 
and 
nj:=\\{heCf\E^ah}\\. 
Q is stable if for a,b £ G, 
ct(a) = ct(6) 
iff 
a,b e Ci for some i. 
The proof of the following statement is straightforward. 
Proposition 3.4.4 Let Q — (G, E^,Ci^,..., 
C^) be a stable coloured graph 
and a^b e G. Then the following are equivalent: 
(i) Fori = l,...,r: 
aeCj 
iffbeCj. 
(ii) The duplicator has a winning strategy in the game C-G^(^,a*,^, 6*). 
D 
We introduce a process of colour refinement leading from a coloured graph 
Q = (G^,E^,Cf,...,Cp) to a stable coloured graph: Let m := ||{ct(a) | 
a G G}\\ and order the set {ct(a) | a G G} lexicographically. Set Q' :— 
(G, E^, C(,..., C^), where C'j^ is the set of elements a e G such that ct(a) 
is the A:-th element in this ordering. Clearly, 
(*) 
each C^ is the union of some CjJ.. 
Moreover, if C^ is the set of elements of colour type (z,ni,... ,nr), then 
Cl = {aeG\Q^ 
{CiX A 
A 
^^""^viExy A Cjy))[a\}, that is 
j=l,...,r 
Of course, the corresponding results for FO(C)^ hold, too. 

62 
3. More on Games 
.^. 
each colour class of Q' is definable in ^ by a formula of C^^ 
^*^ 
of quantifier rank < 1, 
where we extend the definition of quantifier rank for first-order logic by the 
clause qr(3-^a:(y9) := 1 + qr((/9). 
Obviously, Q is stable if m = r, i.e., if there is no proper colour refinement. 
If Q' is not stable, define Q^^^ := {G')'• By (*), we get that after finitely many 
steps, say after n steps, we must reach a stable coloured graph Q^'^\ the 
stable coloured refinement of ^. A simple induction, using (*), shows that 
each colour class of Q^^^ is definable by a C^^-formula of quantifier rank 
< n. This fact yields (ii) => (i) of the following theorem. 
Theorem 3.4.5 For elements a and h of a coloured graph Q the following 
are equivalent: 
(i) a, b are in the same colour class of the stable coloured refinement of Q. 
(ii) 
Forall^(x)€Cl,^, 
To prove (i) ^ (ii), use the preceding proposition (note that by (*), a win-
ning strategy for the coloured refinement of ^ is a winning strategy for ^). D 
For a graph Q — {G, E^) let the stable coloured refinement be that of the 
coloured graph {G,E^,G). 
Then 
Corollary 3.4.6 For elements a and b of a graph Q the following are equiv-
alent: 
(i) a, b are in the same colour class of the stable coloured refinement of Q. 
(ii) Forallip{x)e 
C^^, 
Q^^[a] 
iff 
Q^m- 
n 
3.5 Failure of Classical Theorems in the Finite 
We have seen that in the finite the compactness theorem for first-order logic 
fails and we shall see in Chapter 7 that there is no sound and complete proof 
calculus. 
These facts raise the question whether and why first-order logic can serve 
as a useful means for the investigation of finite structures. The question 
demands for an answer even more as other central methods of classical model 
theory (such as the use of ultraproducts or saturated structures) become 
useless and, as we shall see in this section, further important results fail 
when restricted to finite structures. The examples we give include Beth's 
definability theorem, Craig's interpolation theorem, and some preservation 

3.5 Failure of Classical Theorems in the Finite 
63 
theorems. Nevertheless, we hope to convince the reader that new methods 
and results intrinsic to the finite compensate for this loss. As a new aspect 
we mention the stronger impact of combinatorics which, in particular, will 
become apparent in connection with probabilities (see Chapter 4). Moreover, 
the restriction to the finite motivates the use of other languages, for example 
languages that are able to grasp notions of recursion or induction, in this way 
building a bridge to computational aspects (see Chapter 7). 
Recall that [= denotes the consequence relation with respect to arbitrary 
structures and |=fin that for finite structures; so if |=fin V' means that every 
finite model of (^ is a model of ij;. 
The Beth Property and the Interpolation Property 
Let C be any logic considered so far, e.g. FO, Loou;,. • • Let R be an n-ary 
relation symbol not contained in the vocabulary r. An £ [ T U {jR}]-sentence 99 
defines R implicitly {in the finite)^ if every (finite) r-structure A has at most 
one expansion (^, R^) to a r U {-R}-structure satisfying (p. We say that R 
is explicitly definable {in the finite) relative to (^, if there is an £[T]-formula 
ipi^) such that 
^ |=(fin) Vx(i?^^ V(^))-
Obviously, if R is explicitly definable relative to </9 then </? defines R implicitly. 
We say that C has the Beth property {in the finite)^ if the converse holds, i.e., 
whenever an ^-sentence (p defines a relation symbol implicitly (in the finite), 
then there is an explicit definition of it (in the finite) relative to ^. 
Beth's theorem states that first-order logic has the Beth property. It ex-
hibits a certain balance between syntax and semantics: every implicitly de-
finable, i.e., "semantically" definable, relation has an exphcit, a "syntactic" 
definition. 
Proposition 3.5.1 First-order logic does not have the Beth property in the 
finite. 
Proof. We consider orderings in the vocabulary r := {<, 5, min,max}. Let 
i? be a unary relation symbol and let (/? be the conjunction of the ordering 
axioms and of the following sentence fixing R as the set of even points, 
-^Rmin^\/x\/y{Sxy 
-^ {Rx ^ 
^Ry))-
Clearly, (/? defines R imphcitly in the finite. Suppose 
^ Nfin ^X{RX ^ 1p{x)) 
for some FO[r]-formula i/?(a:). Then '^(max) together with the ordering axioms 
would define the class of finite orderings of even cardinality, contradicting 
2.3.6. 
D 

64 
3. More on Games 
Closely related to the Beth property is the interpolation property (or, Craig 
property) (more precisely, the Beth property is a consequence of the interpo-
lation property): The logic C has the interpolation property {in the finite) iff 
for all vocabularies a and r and any /^-sentences (p and ip in the vocabularies 
a and r, respectively, such that (p |=(fin) V^? there is an interpolant, that is, 
an jC[a n r]-sentence % such that 
^ N(fin) X and X N(fin) ^• 
Craig's theorem states that first-order logic has the interpolation property. 
We shall see that in the finite the interpolation property fails for first-order 
logic. Our counterexample deals with a special case of the interpolation prop-
erty that will be important later. Given a logic £, some classes K of finite 
r-structures happen to be axiomatizable in £, if we equip the structures in 
K with an arbitrary ordering, that is, there is a sentence cp in the vocabulary 
rU{<} such that for 
K^ 
:= {{A,<) \Ae 
K, < an ordering on A}, 
we have 
K< = Mod(ip). 
The logic C is said to be closed under order-invariant sentences in the finite, 
whenever in this situation there is an £[T]-sentence ip such that Mod(?/') = K. 
If (p = v^(<) axiomatizes i^< and <' is a new binary relation symbol, then 
^(<) N n (" <' is an ordering" -^ ^{<'))-
Clearly, if ^ is any interpolant then Mod{ip) = K. Hence, a logic with the 
interpolation property is closed under order-invariant sentences in the finite. 
In particular, in the following proposition part (b) follows from part (a). 
Proposition 3.5.2 (a) First-order logic is not closed under order-invariant 
sentences in the finite. 
(b) First-order logic does not have the interpolation property in the finite. 
We sketch a proof oi (a). Let K be the class of finite Boolean algebras with an 
even number of atoms. Using the Ehrenfeucht-Fraisse method, one can show 
that K is not axiomatizable in first-order logic. However, K^ is axiomatizable 
in first-order logic. In fact, let ip be the conjunction of the axioms for Boolean 
algebras and the axioms for orderings and of a sentence expressing that there 
is an element containing exactly the atoms at an even position (in the ordering 
induced on the atoms) and containing the last atom. 
D 
Exercise 3.5.3 In the finite, L^^^ has the Beth property, the interpolation 
property, and is closed under order-invariant sentences. Hint: Use the fact that 
every class of finite structures is axiomatizable in L^^o; (cf. 3.2.1(b)). E.g., 

3.5 Failure of Classical Theorems in the Finite 
65 
for the interpolation property argue as follows: If (/? |=fin V^ for the L^j^[cr]-
sentence ^p and the L (j;]^(^[T]-sentence ip then every L^j^^[cr Pi TJ-sentence \ 
axiomatizing the class 
{^|(cr n r) I ^ a finite cr-structure with ^ |= (^} 
is an interpolant. 
D 
Exercise 3.5.4 (a) For r = {<} let (/? be a {<}-sentence expressing that < 
is an ordering and, for n > 1, let Xn be the sentence of FO^ introduced in 
part (a) of 3.3.1, which says that an ordering has exactly n elements. Then 
(for both 1= and |=fin)5 
N(fin) {V{<) A V X2.n(<)) ^ (V(<') ^ V X2.n«'))-
n>l 
n>l 
Show that there is no interpolant in L^^. Hence, L^^ does not have the 
interpolation property (in the finite). 
(b) For s > 2 and unary P, let (p(P) and ^(P) be the FO* sentences 
(^(P) 
:= 
"there is exactly one element satisfying P" 
^(P) 
:= 
"there are at least s elements not satisfying P". 
Then for unary Q, 
h(fi,) (v^(P) A ^(P)) -^ (^(Q) ^ ^(Q)), 
but there is no interpolant in FO^. Hence, FO* does not have the interpolation 
property (in the finite). 
(c) Show that FO^ and L^^ have the interpolation property (in the finite) 
in case r is relational. 
n 
Preservation Theorems 
In the model theory for arbitrary structures certain closure properties of the 
class of models of a sentence (/? are refiected by syntactic properties of (/?. 
Most of these so-called preservation theorems fail when literally translated 
to the finite. We give some examples. 
Call a first-order formula universal {existential) if it is built up from 
atomic and negated atomic formulas using only the connectives A, V and 
the universal (existential) quantifier. If (^ is a universal sentence, a simple 
inductive proof shows 
B <Z A and A\= ^^ imply H |= (/?, 
that is, if is preserved under substructures. Similarly, if ip is existential then 
B C A and B \=^ (p imply A\= (p, 

66 
3. More on Games 
that is, (^ is preserved under extensions. Moreover, in classical model theory 
one proves that every FO-sentence preserved under substructures is logically 
equivalent to a universal FO-sentence. We give an example of an FO-sentence 
that, in the finite, is preserved under substructures but is not equivalent to 
a universal first-order sentence. 
Let the universal sentence (po be the conjunction of the ordering axioms 
in {<, min, max} and of the following sentence expressing that i? is a "partial 
successor relation", 
\/x\fy{Rxy -^ x < y) A \/x\/y\/z{{Rxy A x < z) ^ {y = z V y < z)). 
Let (fi be the sentence Wx{->x = max -> 3yRxy) expressing that R is the 
"total" successor relation. For finite structures A and 8, 
(*) 
A\=(po, 5 [= {(po A ipi), and B CA 
imply A = 6. 
Using a new unary relation symbol Q, we set 
if 
:= 
ipo A ((/?i -^ 3yQy). 
In finite models, (p is preserved under substructures: Suppose {A,Q'^) \= ^ 
and {8,Q^) 
C {A^Q"^). Since (po is universal, B \= (po. If B ^ ipi then 
(B,Q^) 
^ip.lfB^(pi 
then by (*), B = A, therefore {B,Q^) = (AO^) 
and hence, {B,Q^) |= (p. 
Assume by contradiction, that ^ is a universal first-order sentence with 
|=fin V^ -^ V^5 say, ip = Mxi .. .\/XnX with quantifier-free x (every univer-
sal FO-formula is logically equivalent to one of this form!). Look at a {<, 
min, max, i?}-structure A with n -h 3 elements, where (A, <^,min'^,max^) 
is an ordering and where R^ is the successor relation. Set Q-^ — 0. Then 
{A^Q"^) ^ (/?, and hence, {A^Q-^) \= 3xi..3xn-^Xi say, 
Choose a G A \ {ai, ...,an,min^,max^} and set Q' — {a}. Since x is 
quantifier-free, {A^Q') \= -^x[^i5 •••5^n] and therefore, {A,Q') ^ \/xi...\/xnX-
On the other hand, {A, Q') |= ^p. Hence (/? and ^ are not equivalent in the 
finite. 
This example gives part (a) of 
Proposition 3.5.5 (a) There is a first-order sentence which, in the finite, is 
preserved under substructures hut not equivalent to a universal first-order 
sentence. 
(b) There is a first-order sentence which, in the finite, is preserved under 
extensions hut not equivalent to an existential first-order sentence. 
Proof, (b) Let (p be according to (a). Then -K^ is preserved under extensions 
and not equivalent to an existential sentence. 
D 

3.5 Failure of Classical Theorems in the Finite 
67 
We close with some remarks concerning "monotone" formulas. Fix a relation 
symbol i? of r of arity r. A sentence (p is monotone in R {in the finite) if 
{A,Ri) \= (/?, (A finite) and Ri C R2 C A^ imply {A,R2) \= ^. 
A first-order formula cp is positive in R if ^p is built up from atomic formulas 
using ^, A, V, V, 3 and any occurrence of the relation symbol Rin (p is within 
the scope of an even number of negation symbols. An easy inductive argu-
ment shows that a sentence positive in R is monotone. While any first-order 
sentence monotone in R is logically equivalent to a formula positive in R, 
this is no longer true in the finite. We state this result; for a proof we refer 
to the example in Exercise 3.5.8. 
Proposition 3.5.6 There is a first-order sentence which, in the finite, is 
monotone in R, but not equivalent to a first-order sentence positive in R. 
As we have seen, preservation theorems of first-order logic fail when lit-
erally translated to the case of finite structures. However, it is still open 
whether - say, in the case of sentences preserved under substructures - there 
is a syntactically defined or, at least, recursive set of sentences preserved 
under substructures in the finite such that, in the finite, every first-order 
sentence preserved under substructures is equivalent to a sentence in this set. 
Exercise 3.5.7 Define the notions of a universal L^.^^-sentence and of an 
La;ia;-sentence positive in R and show: 
(a) In the finite, every L^;^a;-sentence preserved under substructures is equiv-
alent to a universal L^;^^-sentence. 
(b) In the finite, every Lc^^a;-sentence monotone in R is equivalent to an 
Lcjia;-sentence positive in R. 
Hint for (a): Consider a variant of the Ehrenfeucht game by prescribing that 
in each move the spoiler has to choose an element of the second structure 
and argue with the corresponding isomorphism types defined by 
Xl := ^% and 
x T ' - 
Vt; V xL-
For (b) omit subformulas ^Rti.. 
.tm in ^% defining ip'!^ for m > 0 as usual. 
D 
Exercise 3.5.8 (a) Assume that r = a U {i?}, where i? ^ a is an r-ary 
relation symbol, and let A and B be r-structures. Let Part^(v4, B) be the set 
{p e Fa,vt{A\(7,B\(T) I for all a G do(p), if R-^a then R^p{a)}. 
Write 
A =^ B 
iff 
for all FO[r]-sentences (p with qr((p) < m that 
are positive in R: if A\= ^ then B \= (p, 

68 
3. More on Games 
and 
A = ^ B 
iff 
there is a sequence {Ij)j<m of nonempty subsets 
of Part''"(^, ;B) with the back and forth properties. 
Show that ^ =+ B iff ^ ^+ B. 
(b) Let a = {5} and r = a U {-<} with binary 5, ^. For n, A: G N let ^n,A; be 
the structure with 
Gn,k 
:= 
{0,...,n} X {0,...,/;:}, 
5^-^ 
:= 
{((^,i),(^,i + l ) ) | ^ < n , i < f c } 
U{((^,i),(i + l,j + l)) h < n , i < f c } 
U{((n,j),(0,i + l ) ) | i < A : } , 
^Gn.fc 
._ 
transitive closure of S^'^^''. 
Qn,k can be pictured as a circular net of circumference (n + 1) and height 
k^ where 5-arrows are going from a point (that is not in the upper edge) to 
its upper and to its upper right neighbour. We say that a point (i, j) has 
(geographical) length i and (geographical) latitude j . 
If a ^^-'^ b , let Q^^f be defined as gn,k, setting ^^i%'^=^^-,fc \{(a,&)}. 
Show forn = 4 • (2"^+l) : If a ^^-'" 6, a has latitude 2^ +1, 6 has latitude 
3 • (2^ + 1), and if a and b have length difference A: := 2 • (2^ + 1), then 
yn,k 
—m ^n,n 
' 
Hint: Let c and d in Gn,k have latitude 2"^ + 1 and the lengths of a and 6, 
respectively, and show that {Qn,k,c, d) =+ {Q^^^'^\a, b). For / < m, take as // 
the set of those p G Part+((^n,fc, c,d), {G^^;^\a, b)) that 
- preserve lengths; 
— preserve the upper and the lower edge; 
- preserve differences of latitudes up to 2^ for points whose lengths differ by 
at most 2^ and for points on the edges; 
— do not decrease differences of latitudes. 
(c) Set Lp — \/x\Jy{Sxy -^ {-^x = y A x ^ y)) A ((/?i V (/?2 V (y^s) where 
ipi 
:= 
" ^ is transitive" 
(p2 := 
3x^y(x -< y Ay ^ x) 
(ps := 3x3y{x ^ y Ayz{Szy-^ 
{^x ^ z A 
K(Z)))) 
with 
K,(^z) := 
\/w\/y\/u\/v{{y <w A Swz Av ^u 
ASuy) 
{v ^y Av <w Av -< z Ay < z)). 

3.5 Failure of Classical Theorems in the Finite 
69 
K{Z) guarantees that -< is transitive on the set consisting of z and its iterated 
predecessors; more precisely, if ^ |= K[ao] and S-^ai-^iai for i > 0 then ai -< GJ 
for 0 < j < z. 
Show that Qn,k \= ^ and Q^^t N ~^^^ where n, k^ a, h are as in (b). 
(d) Show that, in the finite, Lp is monotone in ^ but not equivalent to a 
sentence positive in -<. Hint for the monotonicity: Let A^B be given such 
that 5 = A, 5^ = 5-^, and ^^ D ^-^ and such that ^ |= (p. As (f2 is positive 
in ^, assume A |= -^ip2- Consider the cases A\= ^2, and A\^ 
^i f\ ^^3- In 
the first case, if (a, 6) witnesses (p3 in A but not in B, find a chain (a, 6) = 
(ao,&o), (ai,6i),... with ai <^ 6,, (6,+i,60 € TC(5-^), and {aiM) ^ TC(5^) 
that ends with a pair witnessing Lp^mB. 
(e) Show that (/? is not monotone in ~< for arbitrary structures. Hint: Start 
with a model of ip that consists of the negative integers with the natural 
successor relation and ordering together with an additional point. 
D 
Notes 3.5.9 A reference for second-order logic is [133]; for the model theory 
of Loou; and L^^^t; we refer the reader to [8, 100]. The first study of fragments 
with finitely many variables is due to Henkin [84]. The languages L^^ and the 
corresponding pebble games were first introduced by Barwise [10] and then 
reinvented and successfully used by Immerman [90] and Poizat [130]. Further 
references are [96] and [40]. Compare [30] for most results in subsection 3.3.3. 
An exposition of the model theory of L^^ is contained in [86]. Surveys on re-
cent results for finite variable logics are [58, 66]. (Infinite) counting quantifiers 
and the corresponding Ehrenfeucht-Fraisse method have been considered in 
various contexts, e.g. in [145]. A thorough treatment in the context of finite 
model theory is contained in [125]. The results on graphs presented in section 
3.4 are from [97]. The failure of many classical interpolation and preservation 
theorems was first presented explicitly in [70]. The example given in 3.5.8 is 
from [135], the first such example was presented in [6]. 

4. 0-1 Laws 
So far we mainly looked at techniques and results which were developed for 
arbitrary structures, and we analyzed to what extent they remain valid if we 
restrict ourselves to finite ones. In the present chapter we study a concept 
that is genuine to the finite (even though there are extensions to arbitrary 
structures): the probability for a finite structure to be a model of a given 
sentence. A starting point was the observation that for a relational vocabulary 
r and a first-order sentence (p, either nearly all finite structures are models 
of ^ or nearly all finite structures are models of -K^ (for example, nearly 
all {J5}-structures are not digraphs, that is, nearly all {£^}-structures are 
models of -Mx^Exx). 
One describes this property by saying that first-order 
logic satisfies the 0-1 law. 
There are different ways of how to count structures and hence, there are 
different versions of 0-1 laws which we study for FO and for L^^ in the 
first and the third section. The second section treats relativized versions, for 
example, 0-1 laws inside a class of structures, say, inside the class of graphs. 
After some applications in section 4.4, we study the case of monadic second-
order logic and disprove the 0-1 law for it in section 4.5. 
In this chapter n is always a natural number greater than 0. 
4.1 0-1 Laws for FO and h't 
OOU} 
As always we refer to a fixed vocabulary r. For a class K of structures let 
Ln{K) be the number of structures in K with universe {1,2, ...,n}, 
LniK) 
:= \\{A€K\A 
= 
{l,...,nm. 
Sometimes, structures A with A = {1,... ,n} are called labeled structures, 
since every element in such a structure is labeled with a natural number. 
Hence, Ln{K) is the number of labeled structures in K of cardinality n. If K 
is the class of models of a sentence ip or the class of all r-structures, we denote 
Ln{K) also by Ln{(p) and Ln{r), respectively. Let ln{K) be the fraction of 
structures with universe { 1 , . . . , n} which are in K, 

72 
4. 0-1 Laws 
In case it exists, l(K) := lim^_^oo ln{K) is called the labeled asymptotic prob-
ability of K. Similarly as above, ln{^) stands for /^(Mod((/?)) and l{(p) for 
/(Mod((/9)). If I {(f) = 1 we say that (p holds in almost all finite structures or 
that (f almost surely holds. 
A class ^ of sentences of a logic is said to satisfy the labeled 0-1 law if 
l{ip) = 1 
or 
l{(f) = 0 
holds for every ip e ^ {or, equivalently, foripe^ 
either ip or ->(/? holds in 
almost all finite structures). 
Examples 4.1.1 (a) Suppose r = {P,c}, where P is unary. Since for any 
r-structure (A,P^,c^), 
{A,P'^,c'^)^Pc 
iff 
iA,A\P^,c'^)^Pc, 
we see that ln{Pc) — \ and thus, l{Pc) = | . 
(b) For the "vocabulary" r := {/} with a unary function symbol / consider 
the first-order sentence \/xf{x) ^ x expressing that / has no fixed-point. 
Then 
UV./(.)^.)=(^)^=(l-i)^ 
(since on the universe {1,..., n} one can fix the values of / independently 
and since for each argument i the n — 1 possible values 7^ z do not lead to a 
fixed-point). Hence, l(ixf{x) 
^ x) — e~^. 
(c) If K is the class EVEN[T] of all r-structures of even finite cardinality, 
then 
,' 
. _ f 1 
if n is even 
ln\^ 
) -
0 
if n is odd 
and hence, 1{K) does not exist. Therefore, /((/?) does not exist for the second-
order sentence Lp expressing "there is a binary relation which is an equivalence 
relation having only equivalence classes with exactly two elements" or for the 
L^i,^-sentence VA;>I ^=2fe-
(d) Let iiT be a class of structures for a relational r. Construct a "random" 
structure of vocabulary r on {1,..., n} by the following experiment: For every 
m-ary relation symbol R'\WT and for every zi,..., i^ G { 1 , . . . , n}, toss a fair 
coin to decide whether Rii.. Am is true. Then IniK) is the probability for 
the outcome A of the experiment to belong to K. 
D 
Examples (a) and (b) show that we can expect a labeled 0-1 law for first-
order logic only for relational vocabularies. In fact, it then holds. The central 
point of the proof we give is the fact that the extension axioms hold almost 
surely and that for any ip, either (^ or -K^ is a consequence of the extension 
axioms. 
In the following suppose that r is relational. Recall (cf. 3.2.11) that an 
(r-l-1)-extension axiom is a sentence x^ = 

4.1 0-1 Laws for FO and L^^ 
73 
\/Vi...'^Vr{ 
/ \ 
Vi^Vj^3Vr+i{ 
/ \ 
Vi ^ Vr+l A / \ (^ A / \ 
^if)) 
l<i<j<r 
l<i<r 
<p€^ 
cpE^*^ 
where ^ is a subset of 
A^+i = {^{vi,..., 
Vr,Vr+i) I (p has the form Rx, where R ^ T and 
where Vr+i occurs in x}. 
Lemma 4.1.2 Any extension axiom holds in almost all finite structures. 
Proof. Given ^, we have to show that the asymptotic labeled probability 
KX'^) equals 1. For any tuple a i , . . . , a^ of distinct elements in a structure A 
and any further object a let S be the probability that a i , . . . , a^, a satisfies 
^ U {->(/? I if G ^ ^ } , when adding a to ^ as a new element and randomly 
fixing the truth values of Rb for any i? in r and any sequence 6 in ^ U {a} 
containing a. Clearly, if c is the number of subsets of A^+i, then S = ^; in 
particular, S > 0. Thus 
InhX^) 
= 
Ini^Vi 
. . . 3 V r ( A l < i < j < r ^* 7^ '^J^ 
Therefore, /(-^x^) = linin-^oo lnhx<^) = 0- 
D 
Recall that by Trand (= 2^rand('?")) we denote the set of extension axioms. 
Corollary 4.1.3 Let if he a first-order sentence. 
(a) //Trand N ^ ^^^n l{ip) = 1. 
(b) //Trand \= ^^ 
thcU l{(p) = 0. 
Proof, (a) If Trand \= ^ then by compactness, TQ \= ip for some finite subset 
To of Trand- Since To is a set of extension axioms, /(/\ To) = 1 by the preceding 
lemma. Hence, l{ip) = 1. 
(b) If Trand N ""^ then by (a), l{-^(p) = 1 and therefore, l{(p) = 0. 
D 
For 8 > 1, let eg be the conjunction of the finitely many r-extension 
axioms with r < s. Since /(eg) = 1 we obtain 
Corollary 4.1.4 Let cp be an 
L^^-sentence. 
(a) If Cs [= (p then l{ip) = 1. 
(b) If Cg \= ^(p then l{(p) =0. 
D 
Theorem 4.1.5 Letr be relational. Then bothFO[T] andL'^^lr] 
satisfy the 
labeled 0-1 law. 
Proof. The assertions follow from the above corollaries, since we know that 
for ^ in FO[r] (cf. 3.2.11) 
Trand N ^ 
O^ 
^ r a n d N " " ^ 
and that for ^ e LJ^^[r] (cf. 3.3.11), 
eg 1= (y^ 
or 
€s |== ^(p. 
D 

74 
4. 0-1 Laws 
Exercise 4.1.6 Let r be relational and m G N. For n,k> 
1 let /(n, k) be the 
probability that A =m B holds for random structures A and B with universe 
{ 1 , . . . , n} and { 1 , . . . , /c}, respectively. Show that lim^,fc->oo /(^5 ^) = 1- 
D 
Exercise 4.1.7 Let 0 < p < 1. Alter the construction of 4.1.1(d) of a ran-
dom structure with universe { 1 , . . . , n} using a biased coin, so that Rii .. Am 
now holds with probability p. For any extension axiom (p show that with 
probability one this random structure is a model of 99. The situation changes 
drastically ii p is allowed to depend on the number n of elements (see [132]). 
D 
Exercise 4.1.8 Let r be relational. Extending the construction of 4.1.1(d), 
define an infinite random structure over {1,2,...} in the following way: For 
every P in r, say of arity m, and every m-tuple zi,..., z^ of positive integers 
toss a coin to decide whether P i i . . . i^ is true. Show that with probability 1 
(with respect to the canonical product measure) this infinite random struc-
ture is a model of Trand and hence, it is the (up to isomorphism) uniquely 
determined countable model IZ of Trand (cf. 3.2.11). Therefore, IZ is called 
the infinite random structure. 
D 
Exercise 4.1.9 Show that for the infinite "vocabulary" r = {Pi,P2,--.} 
with unary Pi there is an LJ^^^[T]-sentence without labeled asymptotic prob-
ability, 
n 
4.2 Parametric Classes 
Does every first-order sentence or its negation hold in almost all graphs? To 
treat such questions we introduce conditional probabihties. Slight modifica-
tions of the arguments given in the preceding section show that the 0-1 law 
holds for the conditional probabilities with respect to classes of structures 
which are axiomatizable by means of "parametric" axioms. The classes of 
graphs and digraphs are prominent examples. 
We start with the definition of conditional probabilities: Suppose that K and 
H are classes of r-structures. Define the labeled probability ln(K\H) by 
UK\H) := ^"^^SSP-' 
If it exists, 1{K\H) := lim^^oo ln{K\H) is called the labeled asymptotic prob-
ability of K with respect to H. Notations such as ln{^\H) or ln{K\T) should 
be self-explaining. 
Obviously, ln{K\T) ^ ln{K), and /^(CONNIGRAPH) is the number of 
connected graphs on {l,...,n} divided by the total number of graphs on 
{ l , . . . , n } . 
^ This fraction is defined only in case H contains a structure of cardinality n. 

4.2 Parametric Classes 
75 
Let Vdistinctxi .. .Xgip abbreviate Vxi... Wxs{(^xi = X2 /\ -^xi — x^ /\... A 
-^Xs-i = Xs) -> V') (which is Va^i^ in case s = 1). 
Definition 4.2.1 Let r be relational. A first-order sentence ip is called para-
metric^ if it is a conjunction of sentences Vdistincta^i .. .Xgil^, where s > 1 
and V^ is a boolean combination of formulas of the form Ryi .. .yn with R e r 
and {^1,... ,2/n} = {xi,... 
,Xs}. (Note that s cannot exceed the maximum 
of the arities of relation symbols in r.) A class K of structures is said to be 
parametric, if i^ = Mod((/?) where (/? is a parametric sentence. 
D 
Examples 4.2.2 (a) \/x-^Rxx A^distinct xy(Rxy -^ Ryx) and ^/x-^Rxx are 
parametric sentences axiomatizing the classes of graphs and digraphs, respec-
tively. 
(b) The class of tournaments is axiomatized by the parametric sentence 
\/x-^Rxx 
A V distinct xy{Rxy 4-> ^Ryx). 
(c) For relational r the class K of all r-structures is parametric, since K is 
the class of models of the empty conjunction. 
(d) Note that 
\/ distinct xyz({Rxy A Ryz) -^ Rxz) 
is not a parametric sentence (since, e.g., {x^y} ^ {x^y^z}). 
In fact, from 
our analysis of parametric classes it will become clear that, for example, the 
classes of transitive relations, equivalence relations, partial orderings, and 
orderings are not parametric, transitivity being the only obstacle. 
(e) If R is A^-ary, Vdistinctxi ...Xk{Rxi 
.. .Xk A -^Rxi .. .Xk) is a parametric 
sentence that is true in all structures of cardinality < A:, but has no model of 
cardinality > k. 
D 
The following considerations will demonstrate that the sentence in (e) is a 
"sharpest" example of a parametric sentence having only models of bounded 
cardinality. 
Let k be the maximum of the arities of the relation symbols in r. A 
parametric sentence (and its model class) is called nontrivial, if it has a 
model of cardinality > k. We show that nontrivial parametric sentences have 
arbitrarily large models: Suppose that (po is a nontrivial parametric sentence. 
If B is any nonempty set, then the following procedure, where we stepwise 
fix the relations on B, leads to a model of (po with universe B: For any s < k 
and any distinct 6i,..., &§ G B, we choose an arbitrary model A of (fo of 
cardinality > s and distinct ai,...,as G A and define, for all R in r, the 
"{6i,..., 6s}-part of i?^" as a copy of the "{ai,..., as}-part of i?^"; more 
precisely, we define this part of R^ such that for (p(vi,... ,Vs) = Ryi - - -yn 
with {yi,.,.,yn} 
= 
{vi,...,Vs} 
B^ 
^[bi,...,bs] 
iff 
A\=(p[ai,...,as]-

76 
4. 0-1 Laws 
Since in B every s-tuple of distinct elements behaves as some s-tuple in some 
model of cpQ and as (po is parametric, B itself is a model of (fo. Thus we have 
proved: 
(1) ifo has models in all cardinalities. 
Call an (r + l)-extension axiom 
\f distinctVi .. .Vr3vr+i{ 
A ^Vi = Vr-\-i A A (/? A 
A ->(p) 
l<i<r 
(pG'^ 
(pE'P^ 
compatible with cpo if 
{ifo} U {3i;i ... 3vr3vr+i( 
/\ 
-^Vi = Vj A /\ (f A 
/\ 
-^^)} 
l<i<j<r+l 
cpe<^ 
ipe^" 
is satisfiable. Let Trand(v^o) be the set of sentences consisting of (fo and of all 
extension axioms compatible with ipo. The proof in Example 3.2.11 showing 
that any two models of Trand are partially isomorphic, also works for Trand(v^o) 
and yields: 
(2) Any two models of Trand(^o) ctre partially isomorphic and hence, Loo^;-
equivalent. Therefore, 
Trand (V^o) |= V^ 
^^ 
Trand (^o) 
\= "^^ 
holds for any Looa;-sentence ip. 
Also the proof of 3.2.11 leading to a countable model of Trand can be trans-
ferred to Trand(v^o), since by the construction process described above the 
corresponding ^^'s can be chosen as models of (po. Hence, 
(3) Trand(^o) has an (up to isomorphism) unique countable model 7l{ipo). 
For 5 > 1, we denote by cpg the conjunction of (po with the finitely many 
r-extension axioms with r < s that are compatible with (/?o- By a similar 
argumentation, one obtains: 
(4) Any two models of ^PQ are s-partially isomorphic and hence, LJ^^-
equivalent. Therefore, for any LJ^^-sentence -0, 
(Po^ip 
or 
v?g ^ -.^. 
Finally, we have: 
(5) If -0 is an extension axiom compatible with (po then l{ip\(po) = 1. 
To give a proof, one can argue as for 4.1.2, but now restricting oneself to mod-
els of ipo and taking as c the number of subsets <? of A^+i that correspond 
to (r+l)-extension axioms compatible with (po. (Given ^, distinct a i , . . . , a^, 

4.3 Unlabeled 0-1 Laws 
77 
and a new a, we can satisfy ^ by ai ... ara^ applying the construction proce-
dure described above to any a^^ ... ai^a with 1 < ii < i2 < . •. < im ^ f-) 
Let H he a class of structures and ^ a class of sentences. We say that H 
satisfies the labeled 0-1 law for W if 
l{ilj\H) = 1 
or 
1{^\H) = 0 
holds for any -0 G iF. From (2)-(5) we obtain: 
Theorem 4.2.3 Let H be a nontrivial parametric class. Then H satisfies 
the labeled 0-1 law for L^^and 
hence, for FO. 
D 
4.3 Unlabeled 0-1 Laws 
We saw in 4.1.1(d) that from a probabilistic point of view the definition of 
ln{K) is quite natural. But note that for r := {P} with unary P and i = 
1,..., n the structures At := ({1,... ,n}, P^^) with P^^ := {i} are counted 
as n diflPerent structures in the definition of ln{K)^ even though they are 
isomorphic. In this section we study the so-called unlabeled probability Un(K), 
which is the proportion of isomorphism types of structures of cardinality n 
in K. Similarly, we define unlabeled conditional probabilities. It turns out 
that the labeled and unlabeled asymptotic conditional probabilities coincide 
in case almost all structures in the underlying class are rigid. 
Fix a vocabulary r. For a class K let Un{K) be the number of isomorphism 
types of structures of cardinality n'm.K or, equivalently, 
Un{K) 
'.— number of isomorphism types of 
structures in K with universe { 1 , . . . , n}. 
C/n(r) and Un{^) stand for UniK), where K is the class of all r-structures 
and the class of models of </?, respectively. 
For arbitrary K we set 
tj^, 
Un(K) 
and denote (in case it exists) by u{K) :— limn^oo'^n(-^) the unlabeled as-
ymptotic probability. 
If K and H are classes of structures we call 
Un(KnH) 
the unlabeled probability and 

78 
4. 0-1 Laws 
u{K\H) 
:= 
lim Un{K\H) 
n—foo 
the unlabeled asymptotic probability of K with respect to H. 
Thus, i^n(CONN|GRAPH) is the number of isomorphism types of con-
nected n vertex graphs divided by the total number of isomorphism types of 
n vertex graphs. 
When studying the relationship between labeled and unlabeled proba-
bilities, a prominent role is played by the class RIG (= RIG[r]) of rigid 
structures. A structure A is called rigid if the identity on A is the only auto-
morphism of A. 
Lemma 4.3.1 (a) Ln{K) <Un{K) "n\ 
(b) IfKC 
RIG then Ln{K) = Un{K) • n\ 
(c) IfKC 
RIG' 2 then Ln{K) < Un{K) • f. 
Proof. Since Ln{K) = Ln{K 0 RIG) -\- Ln{K 0 RIG"^) and similarly for Un, 
it suffices to show (b) and (c). 
Let ^ be a structure with universe {1,..., n}. There are n\ permutations 
of {1,... ,n}. Every permutation TT gives a structure A-TT on {1,... ,?i} such 
that 7c : A = ATT' Clearly, for permutations TT and p of {1,..., n} we have 
(*) 
A^ = Ap 
iff 
Tf-^ o p : ^ ^ A. 
Hence, if A is rigid, we have 
ATX — Ap 
iff 
TT = p. 
Thus each rigid structure leads to n! distinct structures on {1,... ,n}. This 
shows (b). 
If A is not rigid and p is a nontrivial automorphism of ^4, then by (*), 
for any permutation TT. Hence, any nonrigid structure leads to at most y 
distinct structures on {1,..., n}. This proves (c). 
n 
Lemma 4.3.2 For any class H, Un(RlG\H) < /^(RIG|iJ). In particular, 
u(RlG\H) = 1 implies /(RIG|i:f) = 1. 
Proof. 
Un{RlG n H) - n\ 
Un{RlG\H) = 
UniRlG nH)-n\ 
+ Un{RlG' 
nH)-n 
< 
LnjRIGnH) 
- 
LniRlG n H)-i-Ln{RlG'n 
H) 
^ ^ 
' ' ^ 
= 
ln{RlG\H). 
D 
^ Recall that RIC^ denotes the complement of RIG, the class of r-structures not 
in RIG. 

4.3 Unlabeled 0-1 Laws 
79 
As suggested by (b) and (c) of Lemma 4.3.1, almost all structures in a 
class H are rigid iff Ln{H) ^ Un{H) • n!. In fact: 
Proposition 4.3.3 Let H he a class of structures. Then 
u{RlG\H) = 1 
iff 
lim T y % ^ = 1. 
n-^oo Un\H) 
' n! 
Proof. As 
Ln{H) 
_ 
Ln(RlGnH) 
L^(RIG'niJ) 
Un{H)'n\ 
Un{H)-n\ 
Un{H)-n\ 
= 
^ . ( R I G | f f ) + ^ ; f / g ^ ^ f ^ 
(by 4.3.1(b)), 
we get, using 4.3.1(c), 
^,(RIG|iJ) < ^ ^ ^ ^ \ , < Un{RlG\H)+]^Un{KlG'\H) 
= l-i^,(RIG^|iJ). 
r 
/ TT\ 
T 
/ J:T\ 
So, w(RIG|F) = 1 implies lim^-^oo Ur^lH)'ni ^ ^' ^^^ linin^oo Unlm'ni ^ ^ 
implies w(RIG^|iJ) = 0, that is, w(RIG|iJ) = 1. 
" 
' 
D 
The following theorem will be used to extend for parametric classes the 
0-1 laws from the labeled to the unlabeled case. 
Theorem 4.3.4 Let H be a class of structures. If almost all structures in 
H are rigid, i.e., if u(RlG\H) = 1, then for any class K the labeled and the 
unlabeled asymptotic probabilities with respect to H coincide, that is, 
1{K\H) = u(K\H) 
(= u{K\RlG 0 H)).^ 
Proof By assumption, ^(RIGIi:^) = 1 and therefore, /(RIG|if) = 1 by 4.3.2. 
Immediately from the definitions we get 
l(K\H) = /(K|RIG n H) 
and 
u{K\H) = u{K\RIG D H). 
Therefore, the claim follows from 
t/„(RIGn i7).n! 
- 
^n(K\mGf^H). 
D 
^ Clearly, lim„_>oo ln{K\H) = lim„^oo Un(K\H) means that both sides converge 
to the same number or else that both of them diverge. 

80 
4. 0-1 Laws 
Let HQ be the parametric class consisting of all r-structures A such that 
i?^ = 0 for all Rer. 
Then Ln(^o) = UniHo) = 1 and Un{RlG\Ho) = 0 (for 
n > 2). On the other hand, almost all structures in a "free" parametric class 
are rigid. Intuitively speaking, ^a parametric class H is free if for some r > 2 
there is a real choice when fixing the parts of the relations corresponding 
to r-tuples of distinct elements. More precisely: li H = Mod((/?o) with a 
parametric (/?o, then H is free, if for some m > 2 there is a relation symbol 
R, say of arity r, and a surjection i : {l,...,r} —)• {!,..., m} such that 
(^0 A 3a;i . . . 3Xm{ RXil^i) . . . X^^r) A 
/ \ 
-^Xk = Xi) 
l<k<l<m 
and 
ipoA3xi... 
3Xm{^RXi(i) 
. . . Xii^r) A 
/ \ 
^Xk 
= Xi) 
l<k<l<m 
are satisfiable. 
The class HQ introduced above is not free. The class of graphs is free, and 
for any relational r containing at least one relation symbol of arity > 2, the 
class of all r-structures is a free parametric class. 
Proposition 4.3.5 Let H be a nontrivial free parametric class. Then almost 
all structures in H are rigid, that is, u{KlG\H) = 1. 
For H the class of all structures we prove the proposition in the appendix 
of this section. 
Together with Theorem 4.3.4 we now obtain the following 
Corollary 4.3.6 Let H be a nontrivial free parametric class. Then the la-
beled and the unlabeled asymptotic probabilities with respect to H coincide. 
D 
We extend this result to: 
Proposition 4.3.7 Let H be any nontrivial parametric class. Then the la-
beled and the unlabeled asymptotic probabilities with respect to H coincide. 
Before giving a proof we state a consequence. The class H satisfies the 
unlabeled 0-1 law for the set ^ of sentences if for all (/? G ^, 
u{ip\H) = 1 
or 
u{ip\H) = 0. 
Then we have by 4.2.3: 
Theorem 4.3.8 Let H be a nontrivial parametric class. Then H satisfies 
the unlabeled 0-1 law for U^^and hence, for FO. 
D 
Proof (of 4-3.7). By 4.3.6 we only have to consider the nonfree case. First we 
prove the claim for vocabularies containing only unary relation symbols. So 
suppose T = {Ri,..., 
Rm} with unary i?i,..., i?^, and let (po be a nontrivial 

4.3 Unlabeled 0-1 Laws 
81 
parametric sentence. For a : {1,..., m} -^ {0,1} set R^x := (/?i A ... A (pm, 
where (pi = RiX if a{i) = 1, and (pi = -^Rix if a{i) = 0. Then there are 
distinct a i , . . . , a^ such that 
(^0 and \/x{R'^^xy 
...y 
R'^'x) 
are logically equivalent (note that any boolean combination of formulas Rix 
can be written as a disjunction of formulas R^x). We assume ^ > 2, as the 
case i = 1 is trivial. Since for i = 1,..., ^ and fc > 0 the sentence 3^^x 
R^'x 
is a consequence of the set Trand(v^o) of extension axioms compatible with 
cpo, we have 
(1) lil-^xR'^'xlipo) 
=0. 
The isomorphism type of a model A of cpo is determined by (ni,...,nt), 
where n i : = | | { a G A | ^ | = i?^^a;[a]}||. Using induction on n and - in the 
induction step - on i, it is easy to show that 
(2) the number of i-tuples (ni,..., rit) such that ni + ... + nt = n equals the 
binomial coefficient ("^^^7^), a polynomial in n of degree t — 1. 
Hence, t/n((^o) = ("+V) • 
By 2.3.12 and 3.3.25(b), any sentence of L^^;[T] is equivalent to a finite 
boolean combination of sentences of the form 3^^xR^x 
(where A: > 0 and 
a : {1,... ,m} —>• {0,1}). Thus it suffices to show that 
U[3=^XR''X\(PQ) 
=l{3=^xR''x\ipQ) 
e {0,1}. 
If a ^ ai,...,a 
^ at, then u{3=^xR'^x\(po) 
= lil^^xR'^xlipo) 
= 0 or 
1 depending on whether k > 0 or k .= 0. Let a — ai. Then by (2), 
Un(3^'^xR'^x A ipo) = (^"^^2"^), a polynomial in n of degree t —2, and 
Uni^o) = (^^^7^)' ^ polynomial in n of degree t—1. Hence, 
u{3 "xR'^xlipo) = hm^-^oo 
77-7—r 
= 0, 
and thus by (1), u{3=^x R""x \ ipo) = l{3=^x R^'xlipo) = 0. 
Finally, we turn to arbitrary vocabularies. Let iJ be a nontrivial para-
metric class which is not free. By the definition of freeness, if A ^ H then 
any bijection of the universe that preserves the induced unary relations 
{a I R^a... 
a} for i? G T, is an automorphism of A. Hence, the counting 
arguments in the preceding special case remain valid. 
D 
Exercise 4.3.9 Let a = {P} and r = {-P,-R} where P,R are binary. Show 
for the FO[a]-sentences (p := 3x3y Pxy and ^ := "P is an ordering" V 
-^3x3yPxy 
that r((p|^) = 1, u^{^\i^) = \ and l''{(p\il)) = u''{ip\^l)) = 1. 
D 

82 
4. 0-1 Laws 
4.3.1 Appendix 
In the following we prove (part of) Proposition 4.3.5. Fix a vocabulary r and 
n > 1, and let A,B,... 
range over r-structures with universe {1,..., n} and 
TT, p , . . . over permutations of {1,..., n}. We set 
Aut(^) 
:= 
{7r\7r:A^A} 
Str(7r) 
:= 
{A\7r:A^A}. 
Lemma 4.3.10 Un{r)-nl 
= E l|Str(7r)||. 
TV 
Proof. Un (T) is the number of equivalence classes of the relation ~ where 
A^B 
iff 
A^B. 
Clearly, 
A = B 
implies 
||Aut(^)|| = ||Aut(B)||. 
Given A and TT, once more we let An be the structure A with n : A = An-
We have already remarked that 
A-jr = Ap 
iff 
7r~^ ope 
Aut(^). 
Thus, ||{;B I ^ = B}|| is the index of the subgroup Aut(^) in the group of all 
permutations of { 1 , . . . , n}; hence, 
l|Aut(yl)|| = 
Therefore, for fixed A, 
^ 
||Aut(B)||= Yl l|Aut(^)|| = n!. 
B,B^A 
B,B^A 
Taking into account that there are Unir) many equivalence classes with re-
spect to =, we have 
(1) 
EI|Aut(^)||=:C/,(T).n!. 
B 
On the other hand, 
(2) 
E l|Aut(B)|| = ||{(^,B) I TT e Aut(B)}y = E l|Str(7r)||. 
B 
n 
(1) and (2) yield the desired equation. 
D 

4.3 Unlabeled 0-1 Laws 
83 
Let M be finite and / : M ^ M be a bijection. Denote by c(/) the 
number of /-cycles,^ by spt(/) the support of / , 
spt(/) := {a G M I /(a) ^ a}, 
and set s{f) := ||spt(/)||. Since a £ M \ spt(/) gives rise to the /-cycle {a} 
and since the /-cycle of any a G spt(/) has at least two elements, we have 
(3) 
c(f)<\\M\\-s{f) 
+ 
^<\\M\\-^. 
Proposition 4.3.11 Let r be a relational vocabulary that contains at least 
one relation symbol of arity > 2. Then w(RIG) = 1. 
Proof. Obviously, we can assume ||r|| = 1. For simplicity, we restrict ourselves 
to r = {E} with binary E. By 4.3.3 it suffices to show that limn->oo jj 7r) ni ~ 
1, or equivalently, that 
r 
Unir)-n\ 
^ 
n->oo 
Ln{T) 
Clearly, 
(4) 
L n ( r ) = 2 " ^ 
Fix n and remind our convention that TT, p , . . . denote permutations of 
{ 1 , . . . , n} and A,B,... 
denote r-structures with universe { 1 , . . . , n}. 
Each TT induces a permutation TT of { 1 , . . . , n} x { 1 , . . . , n}, 
7r((i,i)) 
:= 
(7r(z),7r(j)). 
If TT is an automorphism of A and {a, 7r(a), 7f(7r(a)),...} a -zr-cycle, then 
(5) 
E-^a iff E-^Ttia) iff £;'^7r(7r(a))... 
that is, we have E'^b for all elements b of the 7r-cycle of a, or for none. 
Therefore, TT is an automorphism for exactly 2^^^^ many r-structures, 
(6) 
||Str(7r)||=2^(*). 
By the preceding lemma, (4), and (6), we obtain 
Un{r)-n\ 
^ EJIStrWII ^ ^ p ,(^)_,3 
Ln{r) 
2-^ 
^ 
We must show that ^^ 2^(^^~*^ -^ 1. Since for TT the identity on {1,... ,n} 
we have c(7r) = n^, this is equivalent to 
^ For a e M the set {a, /(a), /(/(a)),...} is the /-cycle of a. 

84 
4. 0-1 Laws 
For any TT, 
spt(7r) X { 1 , . . . , n} C spt(7r); 
hence, by (3), c(7r) < n^ - ^ ^ ^ and thus, 
For /c = 2,..., n the number of permutations TT with s(7r) = A: is < (^)'A:! < n^. 
Therefore, for n > 2-logn, we have 
E . , . 2 - ^ < E L . n * - 2 - ^ 
= 
^ . ^ ^ 2 - | ^ - ( n - 2 - l o g n ) 
< 
(n-l)-2-(^-2-iogn) 
(for the last inequahty note that k = 2 gives the largest summand of the 
third sum). Since (n-l)-2-(^-2-i<^g^) -^ 0 we obtain the desired result. 
D 
4.4 Examples and Consequences 
In the present section we give several examples concerning graphs and draw 
some consequences for fragments of second-order logic. We start with some 
general remarks. 
Fix a nontrivial parametric sentence ^Q. By the results of section 4.2, 
^randlv^o) has a uuiquely determined countable model 7l{ipo), the random 
model of cpo. Some results of the preceding sections are summarized in: 
Proposition 4.4.1 For an L^^-sentence 
Lp the following are equivalent: 
(i) 
rrand(</^o) N ^ 
(h) 
^ ( ^ o ) N ^ 
(iii) /((/?|v?o) = 1 
(iv) U{LP\(^O) = 1. 
D 
Using the extension axioms in Trand(^o) we show: 
Proposition 4.4.2 (a) LetB he a finite model ofipo. Then almost all finite 
models of cpo contain a substructure isomorphic to B. 
(b) Let B he a finite model of Lpo and TTQ an isomorphism of a substructure A 
of B into 1Z{^PQ). Then TTQ can he extended to an isomorphism of B into 
n{ipo). 
Proof, (a) Let B consist of s elements and let (^Q be the conjunction of (/?o 
and the finitely many r-extension axioms of Trand(9?o) with r < s. Clearly, 
any model of ip^ contains a substructure isomorphic to B. As 1{LPQ\LPQ) = 1 

4.4 Examples and Consequences 
85 
the claim follows. 
(b) Let A = {a} and B = {a, 6}. Then (note that (^2i,a = ^%,a) 
is a consequence of the extension axioms in Trandl^o) and hence, 7l{ipo) 
is a model of it. Since A \= V^5la[^] ^^^ ^%a ^^ quantifier-free, we have 
1Z(^o) 1= ^ ^ a[^o(^)], and therefore there are d in lZ{(fo) such that 7l{(fo) \= 
(f^^-T[7ro(a), c?]. So ab \-^ 7ro{a)d is the required isomorphism. 
D 
By a back and forth argument we get: 
Proposition 4.4.3 If B andC are isomorphic finite substructures of7l{ipo), 
then there is an automorphism of 7l{ipo) mapping B onto C. 
Proof. Assume that 1Z{ipo) has universe {ao, ai, a2,...} and that n : B =i C. 
Take the finite substructure B'Q of 7l{ipo) with ^ Q ^ ^ U J a o } . By part (b) 
of the preceding proposition, there is an isomorphism TTQ : BQ — CQ for a 
suitable C^ C 7l{ipo) that extends TT. Similarly, we get TTQ : Bo = Co with 
TTQ C TTo, ^0 ^ ^(^o), Co C 7l((po), and Co = C^ U {ao}. Continuing this 
way we obtain a sequence TTQ C TTI C 7r2 C ... with ai G do(7rj) nrg(7ri). Thus, 
TT := Ui>o'^* ^^ ^^^ desired automorphism of 7l{ipo)' 
• 
Graphs 
Let ^G be a parametric sentence axiomatizing the class of graphs. Trand(v^G) 
is equivalent to Trand,G := {^G',V^>2}U 
n 
I 
{V distinct a:i ...XnVi ...yi3z{/\ 
ExiZ A f\{^EyiZ 
A^yi = z)) 
\n-{-l>l}. 
In fact, the sentences in Trand,G are implied by the extension axioms in 
Trandi^o); hence, any model of Tj-andi^c) is a model of Trand.c- On the 
other hand, a back and forth argument using the axioms in rrand,G shows 
that any two of its models and hence, any model of Trand,G and any model 
of ^randlv^G) are partially isomorphic; therefore, any model of Trand,G is a 
m o d e l of r r a n d ( ^ G ) . 
It is well known that a graph cannot be planar if it contains the subgraph 
/Cs, a chque with 5 elements. Thus, by part (a) of 4.4.2, we get: 
Proposition 4.4.4 Almost all finite graphs are not planar. 
D 
Moreover, we have: 
Proposition 4.4.5 71{(PG), the random graph, and almost all finite graphs 
Q are connected, the diameter D{Q) := max{d(a, 6) | a, 6 G G} being 2. 

86 
4. 0-1 Laws 
Proof. Note that, by the extension axioms, 7l{ipG) and almost all finite graphs 
are models of 
(*) 
3x3y-^Exy 
AVx\/y3z(Exz 
A Eyz). 
But any graph Q satisfying this sentence is connected with D{Q) = 2. 
D 
Even though "connectedness" is not expressible in first-order logic, the 
first-order sentence (*) of the preceding proof is a property of almost all 
graphs that implies "connectedness". The situation for "rigidity" is different: 
Proposition 4.4.6 (a) Almost all finite graphs are rigid. 
(b) 71{(PG) is not rigid. 
(c) No Ij^^-definahle property of almost all graphs implies rigidity. 
Proof. For part (a) cf. 4.3.5 and 4.3.2. Part (b) is an immediate consequence 
of 4.4.3 (for B and C take two substructures of cardinality one). Part (c) 
follows from (b) because any L^^-definable property of almost all graphs 
holds in 7^((^G) (cf. 4.4.1). 
D 
Fragments of Second- Order Logic 
Connectedness of graphs can be expressed by a 11J-sentence, for example by 
V^CONN := 
'iXf^xXx\J\Ix-^Xxy3x3y{XxA-^XyAExy)). 
Nonrigidity is expressible by 
3X^x\Jy'iuiv3zi3z23w 
{Xzix A Xxz2 A -^Xww A 
{{Xxy A Xuv) -^ [(x - u ^ y — v) A (Exu ^ 
Eyv)))), 
a so-called Ej(V*3*)-sentence , that is, a sentence of the form 
3Xi...3Xs\/yi...'iym3zi...3zix 
with s,mj 
eN and x quantifier-free. Similarly, EJ;(3*V*)-sentences have the 
form 
3X,...3Xs3yi...3ymyzi...yzix 
where x is quantifier-free. 
Part (a) of the following proposition generalizes the fact mentioned above 
that connectedness is implied by a first-order property of almost all graphs. 
Part (b) shows that nonrigidity cannot be expressed by a Ej(3*V*)-sentence 
(otherwise almost all finite graphs would be nonrigid). 
Proposition 4.4.7 Suppose that LPQ is nontrivial parametric. 
(a) Let if be a Il\-sentence. If7l{ipo) \= Lp then there is a first-order sentence 
ip such that 
u{il)\(po) = 1 
and 
\= ip -^ (p. 

4.4 Examples and Consequences 
87 
(b) Let (p be a ^^{{3*^*)-sentence. If 7l{(po) |= (f then there is a first-order 
sentence ip such that 
u{ip\ipQ) = 1 
and 
|=fin ip ^ (p-
Proof, (a) Assume that 1Z{(po) |= cp holds for the IT J-sentence 
(^ = VXi...VX,x, 
where x contains no second-order quantifiers. Then the set Trand(</^o) U {""X} 
of r U {Xi,... ,Xs}-sentences has no model (otherwise, by the Lowenheim-
Skolem theorem, it would have a countable model whose r-reduct would be 
(isomorphic to) the unique countable model 7l{(po) of Trand(v^o); but then 
^(^o) 1= 3Xi... 3Xs-ix, contrary to TZ{(po) \= VXi... VX^x)- By compact-
ness, there is a finite subset To of Tra^ndi^o) such that To U {-"x} is not sat-
isfiable. Let ip be the conjunction of the sentences in TQ. Then u{ip\ipo) = 1 
and 1= ^ -> X, hence \= ip -^ VXi... VX^x-
(b) Suppose that for the Sj(3*V*)-sentence 
ip^3X,...3Xs3x^yX 
with quantifier-free x we have 7l{^o) \= ^, say, {7l{ipo), X i , . . . , Xg) |= 3'xiyx-
Choose a in 7l{ipo) such that 
(*) 
(7^((^o),Xl,...,x,)^v^x[a] 
and denote by Ao the submodel of 7l{(po) with universe {a}. Since 3x(p^{x) 
holds in 7l{(po), there is a -0 that is the conjunction of cpo and of finitely many 
extension axioms compatible with (/?o such that (= -0 -> 3x(p^{x). Obviously, 
u{ip\ipo) = 1. We show that |=fin ij) -^ ^. 
So let B be a finite model of ij). Choose c? in B such that B |= ^%[d\. Then 
G? 1-^ a is an isomorphism from the substructure of B with universe {d} into 
lZ{(po). By 4.4.2(b), there is an extension n oi d\-^a that is an isomorphism 
of B onto a substructure B' of 7l{(po). It sufl&ces to show that B' is a model 
of if. By (*), as V^x is universal, 
{B',X,nB',...,XsnB')^\fyxla], 
hence (B', Xi n B',..., X, n 5') N ^x^VX, thus B' ^3Xi... 
3Xs3x\/yx^ D 
As a consequence we get: 
Theorem 4.4.8 Let (po be nontrivial parametric and let (p be a Ej(3*V*)-
sentence. 
(a) IfTZ{^o) \= (p then u{ip\ipo) = 1. 
(b) If1l{(po) ^ ^ then u{ip\Lpo) - 0. 

88 
4. 0-1 Laws 
Proof, (a) If 1Z{(po) |= cp then, by part (b) of the proposition, there is a 
first-order sentence ip such that u{ip\ipo) = 1 and |=fin ip -^ ^. In particular, 
u{ip\ipQ) = 1. 
For (b), assume that 1Z{(po) \= -^(p. Since ^^ is (logically equivalent to) a 
n]^-sentence there is, by part (a) of the proposition, a first-order sentence tp 
such that u{ip\ipo) = 1 and \= ip -^ -^ip. Therefore, u{-^ip\ipo) = 1 and hence, 
u{(p\(po) = 0. 
D 
By 4.3.7, the preceding results remain valid for the labeled probability as 
well. Hence, we have: 
Corollary 4.4.9 E]^(3*V*) satisfies the labeled and the unlabeled 0-1 law 
with respect to nontrivial parametric classes. 
D 
The satisfiability problem for 3*V*-sentences is decidable, and we have 
just seen that Sj(3*V*) has the 0-1 law. This is a special case of a general 
phenomenon: It has turned out that the satisfiability problem for a prefix 
class # of first-order logic is decidable just in case the 0-1 law holds for E}# 
(:= {3Rip I cp e #}), cf. [126]. 
Orderings 
In the preceding exposition we dealt with parametric classes; the following 
examples show, among other things, that the class of orderings is not para-
metric. 
Examples 4.4.10 (a) Let r = {<,P} with unary P and let O = 0[r\ be 
the class of r-structures ordered by <. Denote by (p a first-order sentence 
expressing that the first element of the ordering is in P, say, (p = 3x{Px A 
My -^y < x). Then 
(argue as in 4.1.1(a)). By 4.2.3, O is not parametric. 
(b) For T = {<} consider the class ORD of orderings. By 2.3.6, for any first-
order sentence (^ we have w((p|ORD) = l((p\ORD) = liff({0,...,2^},<) 
^(p, 
where k is the quantifier rank of (p. Therefore, ORD satisfies the labeled and 
the unlabeled 0-1 law for FO. On the other hand, ORD does not satisfy the 
(labeled or unlabeled) 0-1 law for L^^. In fact, the probabilities l{ip\OKD) 
and u{(p\OK'D) do not exist for any L^^-sentence (p expressing that the 
ordering has an even number of elements. (As (p one can take Vn>i X2m 
where X2n are the FO^-formulas introduced in Example 3.3.1(a).) 
D 
4.5 Probabilities of Monadic Second Order Properties 
Already in 4.1.1(c) we saw that, in general, the (labeled or unlabeled) as-
ymptotic probabilities do not always exist for second-order sentences. In the 

4.5 Probabilities of Monadic Second Order Properties 
89 
present section we show that this is true even for monadic S J-sentences, that 
is, for sentences of the form 
where X i , . . . , Xm are unary and ^ is first-order. Moreover, we shall show 
the corresponding result for nontrivial free parametric classes. 
Theorem 4.5.1 Let cpo be a nontrivial free parametric sentence in a rela-
tional vocabulary TQ. Then there is a monadic T\-sentence if of vocabulary TQ 
such that the labeled asymptotic probability l{if\LpQ) does not exist. 
Since the class of all finite r-structures is a nontrivial parametric class in case 
T contains an at least binary relation symbol, we obtain 
Corollary 4.5.2 Let r be a vocabulary that contains an at least binary re-
lation symbol. Then there is a monadic T\-sentence of vocabulary r without 
labeled asymptotic probability. 
D 
Proof (of 4-5.1). Let (po be a nontrivial free parametric sentence and H its 
class of finite models. Then the following lemma 4.5.3 tells us that there is a 
first-order formula hi{x, t/, X, Y, Z, U) with unary relation variables X, Y, Z, U 
such that 
3X3y3Z3C/("Av(_, _, X, F, Z, U) is an ordering of the universe") 
almost surely holds on H. Therefore, with a new unary relation variable F, 
the sentence 
3X3y3Z3t/3F("Ac(_,_,X,y,Z,t/) is an ordering of the universe 
whose first element belongs to V and whose last element does not 
belong to V" AVa^Vt/ ("if?/ is the Ac-successor of a: then {Vx ^ "^^2/)") 
almost surely holds for the structures in H of even cardinality and almost 
surely gets wrong for the structures in H of odd cardinality. So it has no 
labeled asymptotic probability (recall that Lpo is nontrivial and thus, has 
models in all cardinalities). 
D 
Lemma 4.5.3 There is a first-order formula K{x,y,X,Y, 
Z,U) with unary 
relation variables X, Y, Z, U such that with 
cp := 
3X3y3Z3t/("/^(-, _, X, F, Z, t/) is an ordering of the universe") 
the labeled asymptotic probability l{ip\ipo) equals 1. 
Proof. As (po is free, there is a relation symbol R in TQ of arity r > 2, an 
m > 2, and a surjection i: { 1 , . . . , r} -^ { 1 , . . . , m} such that both 
ifO A 3a:i . . . 3Xm{RXi^i) 
. . . Xi(^r) A 
/ \ 
Xk ^ 
Xi) 
l<k<l<m 

90 
4. 0-1 Laws 
and 
(^0 A 3a:i ... 3xmhRxii^i) 
... Xa^r) A 
/\ 
Xk ^ xi) 
l<k<l<,m 
are satisfiable. We set 
llj(Xi,...,Xm) 
: = 
RXi(^i)...Xii^r)^ 
/ \ 
Xu i^ Xi 
l<k<l<m 
and 
'ilj^{xi,...,Xm) 
: = 
-^RXi(^i)...Xi(^r) 
^ 
/ \ 
Xk ^ 
Xi. 
l<k<l<m 
Then, among the 0-isomorphism types of m distinct elements satisfiable in 
some model of (po, there are types implying ip{xi,...,Xm) 
and types imply-
ing '0^(xi,... ,Xm)- Hence, the fraction p of types implying ^(xi,... ,Xm) 
satisfies 0 < p < 1. Interchanging ip and ip^, if necessary, we may assume 
that 
0<P<\. 
Intuitively, if we take distinct elements a i , . . . , a^ in a model A of ipo, the 
probability for V^[ai,..., a^] to hold in A is p. 
We first consider the case m = 2 and write ip{x,y) for t/'(a:i,X2). The idea 
behind our argumentation is as follows: We show that with high probability 
models of cpo contain a subset of logarithmic size ordered by ^(x,^/). The 
ordering can suitably be extended to an ordering of the whole universe; this 
will be done in two steps. 
We come to the details. Given n, we set 
c 
:= 
-logpTi, 
[y - c j , the integer part of \ -c. 
L3cJ, 
X := {!,...,r} 
and 
Z :— {n - 5 + 1,... ,n}. 
Note that for sufficiently large n, the sets X and Z are disjoint. 
In the following we equip the set of models of (pQ over {1,... ,n} with the 
uniform probability distribution. 
Claim 1. Almost surely in models of cpo over {1,... ,n} there is a set Y of 
power r disjoint from X U Z such that 
ip^{x,y) 
:= 
Yx AYy A3Z{XZ 
Ail){z,x) 
A-^'ip{z,y)) 

4.5 Probabilities of Monadic Second Order Properties 
91 
defines an ordering on Y. 
Claim 2. Almost surely in models of (po over {1,.. .n}, for any subset Y of 
{ 1 , . . . , n} of cardinality r which is disjoint from X U Z, we have 
(1) "^x^/yiZx AZy Ax :^y ^ 3z{Yz A -^{ipiz,x) ^ 
2p{z,y)))); 
(2) with U :={YU Zf • 
\/x'iy{{Ux Ally Ax ^y) 
^ 3z(Zz A ^{il^iz, x) ^ il){z, y)))). 
Then we are done: If ip^{x, y) defines an ordering on Y and (1), (2) of Claim 
2 are valid, then 
ip^{x, y) 
:= X ^ y A Zx A Zy A "for the V'<-smallest element 
zofY 
with -^{il){z,x) ^ ip{z,y)) we have 'ip{z,xy^ 
defines an ordering on Z and 
^^(x, y) 
:= X ^ y A Ux A Uy A "for the ^^-smallest element z oi Z 
with ->{'ip{z,x) -^ ip{z,y)) we have ip(z,xy^ 
defines an ordering on U. 
Therefore, with 
K{X, y, X, F, Z, U) 
:= 
"X, F, Z are disjoint and U = {Y U Z)"" A 
{i;^{x,y)V^|;^{x,y)V^P^{x,y) 
W{Yx A -^Yy) V {Zx A Uy)), 
claims 1 and 2 yield that 
1{3X3Y3Z3U''K,{., 
_, X, F, Z, U) defines a linear ordering" | ^o) = 1. 
So, we have cp as claimed in the statement of the lemma. 
We give the proofs of Claim 1 and Claim 2. To prove Claim 1, for i G {1,..., i} 
we set 
Y{i) 
:= 
{r • i + 1,... ,/* • i + r}. 
Note that the Y{i) are pairwise disjoint and disjoint from both X and Z (as 
r 't + r < ^ < n — s -\-l). We show that almost surely in models of ipo over 
{ 1 , . . . , n} there is an i G {1,..., ^} such that 
(*) 
for all a, 6 G X, ip{a, r - i -{-b) holds iff a <b. 
Then almost surely there is a Y", namely Y — Y{i) for an i satisfying (*), 
such that for all di, ^2 G F 

92 
4. 0-1 Laws 
there is an a G X such that ip{a,di) holds and -^x/j{a,d2) holds iff 
that is, ip^(x,y) 
defines an ordering on Y. 
For i G {1,... ,n} let g be the probability that i satisfies (*) (where we 
refer to the uniform probability distribution on the set of models of ipo over 
{l,...,n}). Then 
q>P 
>P^ 
= 
-r-
Hence, the probability that no i G {1,... ,^} satisfies (*) is 
v n 
We now come to a proof of Claim 2. Given Y, the probability of the failure 
of (1) is 
< (2) • ( / + a-pfy 
< 5 • c^ • (p^ + (1 -p)2)^/i^-^ ^ . ^ 0 0 0, 
and the probability for the failure of (2) is 
< 
n2-(p2 + (i-p)2)'»g.==+(i-.)2""'-i (note that p2 + (1 - p f > p) 
- 
n-(p2 + ( l - p ) 2 ) 
^ " ^ ~ 0 -
Altogether the case m = 2 is settled. 
We finally sketch a proof for the case m > 2. The model construction method 
for parametric classes given in section 4.2 shows that for distinct elements 
a i , . . . , ttm the probability for '([^{ai,..., am) to hold in a model over { 1 , . . . , n} 
remains the same if we fix as,..., a^n- Therefore, the preceding proof for the 
case m = 2 remains valid with the following changes: 
(i) 
We consider structures over { 1 , . . . , n, n + 1,..., n + m — 2}. 
(ii) We fix X3 by n + 1,..., Xm by n + m — 2. 
(iii) We replace U = (YUZy 
hy the complement of F U Z within {1,..., n}. 
(iv) We put n + l,...,n + m - 2 at the end of the ordering defined on 
{1,..., n} for the case m = 2. 
This leads to the following changes in the definition of (p: 

4.5 Probabilities of Monadic Second Order Properties 
93 
(i) 
We add "3^3 ... 3xm'' to the prefix. 
(ii) We add the conjunct " /\s<k<i<m ^k 7^ xi^ to the kernel. 
(iii) We define /^(a;, y,x^,... 
^Xm,X,Y,Z, 
U) as in case m — 2 with 
as parameters stemming from ip{x,y,xs,..., 
Xm) and then replace it by 
the disjunction of the following formulas 
A3<fe<m X^XkA 
\/3<k<m V = ^k, 
V3<fc<m yk<j<mi^ = XkAy = Vj), 
/\3<k<mi^ ^ XkAy^^Xk) 
A ti{x, y,Xs,...,Xm, 
X', y , Z', U') 
where, e.g., X' is X\{xz,... 
,Xk}. 
U 
Exercise 4.5.4 Let r contain the relation symbol < and at least one further 
relation symbol of arity > 2. Let 0[T\ be the class of ordered r-structures. 
Then there is a first-order ^p such that /(9?|C^[T]) does not exist. (Hint: Argue 
as in the preceding proof, but now let intervals take over the role of the 
subsets X, r, Z and t/.) 
D 
Notes 4.5.5 The 0-1 law for first-order logic was independently proven by 
Glebskij, Logan, Liogonkij, Talanov [47] and Fagin [37], its extension to para-
metric classes is due to Oberschelp [123], and its extension to L^^ to Kolaitis 
and Vardi [109]. The papers [107, 108] contain, among other things, the re-
sults on fragments of second-order logic presented in section 4.4. The last 
section is based on [98] (cf. also [99, 141]) and the Appendix 4.3.1 on [38]. 
Survey articles on 0-1 laws are [21, 72, 111, 146]. 

5. Satisfiability in the Finite 
A classical question having its origin in the decision problem for first-order 
logic, asks for specific classes <? of sentences whether they have the finite 
model property, i.e., whether every satisfiable sentence of # has a finite 
model. We are going to consider two examples where we can demonstrate 
the methodological usefulness of techniques and results we have developed so 
far. 
A first-order sentence (^ expressing that < is a partial ordering without max-
imal elements is satisfiable but has no finite model. As (p we can take (1) or 
(2): 
(1) Wx-^x < X A \/x\fy\fz{{x <yAy<z)^x<z)A 
\fx3y x <y 
(2) \/x'^y\/z3u(-^x < X A {{x < y Ay < z) ^ x < z) Ax < u). 
The sentence in (1) uses only three variables, the sentence in (2) is a V^3-
sentence. These sentences are "best" possible ones: We show in section 5.1 
that every satisfiable sentence with at most two variables has a finite model 
and in section 5.2 that the same holds for every satisfiable V^3*-sentence 
without the equality sign.^ 
5.1 Finite Model Property of FO^ 
We prove that every satisfiable sentence with at most two variables in a re-
lational vocabulary has a finite model. As a consequence, every sentence of 
modal logic has a finite model (cf. 5.1.8). We remark that one can remove 
the restriction on constants (cf. 5.1.7), but the result is not valid for "vocab-
ularies" with function symbols: Consider the sentence with two variables 
\/xyy{f{x) 
= f{y) -^ x = y) A 3yMx^f{x) 
= y 
expressing that / is injective but not surjective. 
Fix a relational vocabulary r and let x := Vi and y := V2' For the purpose 
of this section we say that a first-order formula (possibly containing second-
order variables) is normal, if it has the form 
^ Furthermore, any satisfiable universal sentence has a finite model. 

96 
5. Satisfiability in the Finite 
r 
\/x\/yip A A \/x3yipi 
where i/^^ipi G FO^ are quantifier-free. We shall use the next lemma to re-
strict ourselves to normal sentences when proving the finite satisfiability of 
satisfiable FO^-sentences. 
Lemma 5.1.1 Every sentence 3X((/? A VxV^^), where ip is normal and ip G 
FO^, is equivalent to a sentence of the form 3Yx, where x ^s normal 
Proof. We proceed by induction on the number of quantifiers in xp. If ip 
contains no quantifiers, the result is immediate. In the induction step we 
show how to eliminate a quantifier in ip. So let, say, Va^^o be a subformula of 
-0 with quantifier-free ipo. Then, ip is logically equivalent to 
3X(V2/(X?/ ^ Wxtpo) A \/x\/yip') 
where ip' results from ip by replacing \/xipQ by Xy^ and hence, it is logically 
equivalent to 
3X(VxV|/(Xy -> ipo) A Vy3a;(-n0o V Xy) A Mx'iyip') 
and thus to 
3XNx\/yiXy 
-^ ipo) A yx3y(--ipo (^] 
V Xx) A VxV?/^') 
\xyj 
(V'o (^^) is obtained from ipo by simultaneously replacing all occurrences of x 
and y by y and x, respectively). 
Altogether, 3X{(p A \Jx\lyip) is equivalent to 
3X3X(v9 A yx\/y{Xy -^ iPo) A Wx3y{-^iPo r 
] V Xx) A ^Jx^yiP') 
\xyj 
where the first conjunct is normal and ip' has less quantifiers than ip. By 
induction hypothesis, we obtain our claim. 
D 
Corollary 5.1.2 Every sentence of FO^ is equivalent to a sentence of the 
form 3Yx, where x is normal. 
Proof. Given an FO^-sentence ip, apply the preceding lemma to 3X{ip A 
"ix^yip), where X is the empty sequence and (p := \/x\/yx — x. 
D 
We now formulate the main result of this section. 
Theorem 5.1.3 Every satisfiable first-order sentence with at most two vari-
ables in a relational vocabulary has a finite model. 

5.1 Finite Model Property of FO^ 
97 
Proof. Let (p be such a sentence. We apply the corollary above. Since 3Yx 
and X have models over the same universes, we may assume that cp has the 
form 
r 
ip = \fxiyip A A \/x3y'il)i 
where ip^ipi e FO^ are quantifier-free. Moreover, we may suppose that 
for i = l,...,r, 
ipi\= X ^y 
since over structures with at least two elements \fx3y'ipi{x,y) is equivalent to 
yx3y{x ^y A {^i[x,y) y \lji{x,x))). 
Let ^ be a model of ip. An element a G A is a king (in A) if there is no 
other element h oi A with the same 0-isomorphism type, i.e., (/?3i a — ^^A b- ^^ 
A\= ipi[a,b], we call 6 a child of a (in A), more exactly, an i-child. For a G A 
and i e {1,..., r} we let a* be a fixed i-child of a. Then, a ^ a\ We set 
C:= 
[j 
{a,a\...,a^}. 
aEA, a king 
Clearly, C is finite. We show that there is a B such that 
(i) 
B = CU {{ipX^ \aeAno 
king } x { 1 , . . . , r} x {0,1,2}). 
(ii) Each 0-isomorphism type of a pair of elements of B is realized in A. 
(iii) For i = 1,..., r, all elements of B have an i-child in B. 
Then >B is a model oiMxMyij) by (ii), and of Alzri '^x3yipi by (iii); thus by (i), 
B is a. finite model of (p. 
To define >B, we fix the 0-isomorphism type of all pairs of elements of B in 
a suitable way to ensure (ii) and (iii). The rest - in case r contains relation 
symbols of arity > 3 - can be fixed in an arbitrary way. 
Step 1. For a,b ^ C,a ^ b, we set 
^B,a,b 
'— 
^A,a,b-
Step 2. Let b £ B. We aim at providing children for b in B. So let i G {i,..., r}. 
— If 6 G C and 6 is a king or b has an i-child in A that lies in C, 6 has an 
i-child in B because of Step 1. 
— If 6 = a^ for a king a, but 6 has no i-child in C, we let b' :— ((/?^ (ai)^' ^' ^) 
be an i-child of 6 in i3 by setting 
^B,b,h' 
'•- 
^A,ao,{aoY-
(In case there are several possibilities for a and j , we fix one choice; and 
we also do so in similar situations.) 

98 
5. Satisfiability in the Finite 
— If 6 = {ip\ ^, j , A:) (and, hence, a^Ais 
not a king in A) and a* is a king 
in A^ we let a* be an i-child oihinB 
by setting 
— If 6 = ((/?5i a'i' ^) ^^^ ^^ ^* ^^ ^^* ^ ^i^S i^ -^' ^^ 1^* ^' •— (v^i a^ 5 ^' (^ + 1) 
(mod 3)) be an i-child of 6 in ;B by setting 
In all of these cases, by fixing a type (^^ ^ ^, we of course at the same time 
also fix (p^^^. 
Step 3. If, e.g., for d G C, 6 := {ip\^,j,k), 
and 6' := {^\a'^3'^^') 
the 0-
isomorphism type of (d, h) or of (6,6') has not been fixed in the first two 
steps, we set 
respectively. Note that the definitions we have made do not contradict each 
other, as for c G C we have (/?g^ = v?^^ and for h — (v^3l,a'i'^) ^^ have 
^% b ~ ^2l a' ^y construction, (ii) and (iii) are satisfied. 
D 
Corollary 5.1.4 For any relational vocabulary r, the set ^ of logically valid 
first-order sentences with at most two variables is decidable. 
Proof. By the completeness theorem for first-order logic the set ^ is enumer-
able. For its "complement" 
^^^ 
\— {(/? FO^[T]-sentence | ip is not logically valid} 
we have by the preceding theorem that 
^"^ 
— W FO^[T]-sentence | -«(/? has a finite model}. 
Therefore, #"^ is enumerable too, and hence, ^ is decidable. 
D 
We remarked after Corollary 4.4.9 that the classical prefix classes with a 
decidable satisfaction problem correspond to fragments of Ej with a 0-1 
law. Even though we just have shown that FO^ has a decidable satisfaction 
problem, the 0-1 law does not hold for the class Ej-FO^ := {3X(^ | (/? G FO^}, 
cf. [114]. 
An analysis of the proof of the main theorem leads to the statement of the 
following exercise. 
Exercise 5.1.5 Show that to any first-order sentence if in at most two vari-
ables one can effectively assign a natural number m such that: 

5.2 Finite Model Property of V^3*-Sentences 
99 
— if has a model if and only if y? has a model of power < m. 
— If (/? has a model of power > m then (^ has a model in each cardinality 
> m . 
D 
Exercise 5.1.6 Let r = {<} with < binary. Show that for all n > 1 there 
is a satisfiable FO^[r]-sentence having only models of cardinality > n. (Hint: 
Use the formulas introduced in part (a) of 3.3.1, but note that the class of 
orderings is not axiomatizable in FO^.) 
D 
Exercise 5.1.7 Show that any satisfiable sentence with at most two vari-
ables in a vocabulary possibly containing constants has a finite model. (Hint: 
Let (^ be such a sentence and denote by C the set of constants. For any n-ary 
relation symbol P and any map TT : {1,...,n} -^ C 1} {x^y} introduce a new 
2-ary relation symbol P^. Apply the theorem to the sentence obtained from (/? 
by replacing any subformula P7r(l).. .7r(n) by P'^xy and treating equations 
and quantifiers appropriately.) 
D 
Exercise 5.1.8 Show that any satisfiable sentence of modal logic has a finite 
model. The sentences of modal logic are built up from propositional variables 
Pi,P2,... 
by means of the propositional connectives, say -> and V, and the 
^^necessity operator^^ D. A structure (or frame) A^ is a triple {A,R,J^) where 
A is a nonempty set, the set of ^^states''\ i? is a binary relation on A, and 
^ '• {P15P2, ...}-)• Pow(A), Pow{A) being the power set of A. For s e A, the 
satisfaction relation M\=ga is defined by induction on the complexity of a: 
M^,Pi 
M\=g-^a 
> l K ( ^ V / 3 ) 
M[=pa 
iff 
iff 
iff 
iff 
s e T{pi) 
not M\=ga 
MY-s^ 
or M\=gl5 
M\^^a 
for all t such that Rst. 
If M\=ga for all s G A, then M. is said to be a model of a. To solve the 
exercise, let the propositional variables occurring in a be among pi,... ,Pn-
Associate with a a formula ^oc{x) G FO^[{i?, P i , . . . , Pn}], where P i , . . . , P^ 
are unary, such that for all (A, i?, T) and 5 G A, 
(A,i?,J^)K« 
iff 
{A,R,T{pi),...,T{pn))[-Msl 
• 
5.2 Finite Model Property of V^3*-Sentences 
We fix a relational vocabulary r. In the preceding section we have proved 
that every FO^-sentence has models in the same cardinalities as a sentence 
of the form 
VxV^ ip A A Wx3y ipi 
i=l 
with quantifier-free il^,ipi. This sentence is equivalent to 

100 
5. Satisfiability in the Finite 
(*) 
\/x\/y^yi.. 
.3yr{ij{x,y) 
A 
/\'ipi{x,yi)). 
We then have proved the finite model property for these sentences. 
By a V^ 3*-sentence we mean a first-order sentence of the form 
where A: > 0 and -0' is quantifier-free. In particular, the sentence (*) is a 
V^3*-sentence. In this section we extend the result about the finite model 
property for sentences of the form (*) to arbitrary V^3*-sentences, however 
under the proviso that they have models without kings. (Recall that a ^ A 
is a king in the structure A if for no 6 G A, 6 7^ a, we have (^^ = ^6-) 
Theorem 5.2.1 Suppose that r is a relational vocabulary. If ip is a V^3*-
sentence which has a model without kings, then it has a finite model. 
We first draw a consequence. For a structure ^ in a relational vocabulary 
r and / > 2, denote by ^ x / the structure which for every element of A 
contains / duplicates; more precisely: ^ x / is the r-structure with universe 
A X {0,...,/ — 1} such that for any n-ary R in r, 
R^"^^ 
:= 
{((ai,ii),...,(an,^n)) \R^ai...an, 
0 < i i , . . . , i n < / - ! } • 
Clearly, ^ x / is a structure without kings, and a routine proof by induction 
shows that 
A^ip 
iff 
Axl\=ip 
holds for all sentences ip without (the) equality (sign). As a corollary of the 
above theorem we therefore obtain: 
Corollary 5.2.2 Suppose that r is a relational vocabulary and ip is a V^3*-
sentence without equality. If if) is satisfiable then it has a finite model. 
As in 5.1.4 for FO^ we now get: 
Corollary 5.2.3 The set of logically valid \f'^3*-sentences without equality 
in a relational vocabulary is decidable. 
D 
Proof (of 5.2.1). In models with at least two elements a V^3*-sentence 
is equivalent to the sentence 
'iVi\/V23x^ 
. . .3Xk3z^ 
• • -^Zki-^Vi 
=^V2 ^ 
{\p'{vi,Vi,X3,..-,Xk) 
All)'{vi,V2,Z3,...,Zk))), 
and, for example, a sentence of the form 

5.2 Finite Model Property of V^3*-Sentences 
101 
\/viiv2^x3y\l)'{vi 
,V2,x, y) 
is equivalent to 
\/vi\/v2'^x3y{{ip'{vi,V2,x,x) 
\/ip'{vi,V2,x,y)) 
A^x = y). 
Therefore, we can assume that our V^3*-sentence t/^ has the form 
3<i<j<k 
where tp' is quantifier-free. 
Choose a model .4 of ^ without kings and let 
5 : = { v ° | o e A } 
and 
T := {cp°, \ a,b e A,a 
^b} 
be the 0-isomorphism types of elements and of pairs of elements of A, respec-
tively. If p{vi,... 
,vi) is a 0-isomorphism type of any /-tuple and 1 <m,n 
<1 
with m ^ n, let Pm(^i) and pm,nivi,'iJ2) be the induced 0-isomorphism types 
of Vm and of Vm,Vn, respectively; in particular, for any B and 6i,..., 6^ G 5 , 
B [= p[6i,. ..,hi] 
implies (p^^ = pm and (/??^^^ = pm^n-
As A has no kings, we get: 
(1) 
For all ^,^' 
e S there is a x ^ ^ such that ^ = Xi and (p' = X2-
Moreover, since ^ is a model of V^, we have: 
(2) 
For every x G T there is a 0-isomorphism type p{vi,... 
,Vk) with 
(a) pi ^ S for i = 1,... ,k 
(b) Pm,n G T for l < m < n < f c and pi,2 = X 
(c) [= 
p^i)'{vu...,Vk). 
To get the statement of the theorem it suffices to show: 
Suppose that S and T are nonempty sets of 0-isomorphism types 
(-[-) 
of elements and of pairs of elements, respectively, satisfying (1) 
and (2). Then ip has a finite model. 
Let s := ||5|| and t := ||T|| and fix an ordering on S. To prove (-I-), we 
give a method to construct, for every n > k, structures B with universe 
{1,2,..., n • s} (afterwards we show that with nonvanishing probability these 
structures are models of '?/')• The 0-isomorphism types of elements are fixed 
by a deterministic algorithm while the 0-isomorphism types of tuples of more 
than one element are chosen randomly. The exact construction procedure of 
B reads as follows: 

102 
5. Satisfiability in the Finite 
(i) 
If a G {1, 2,..., 72 • s} and a = i • s + j for some i,j such that 0 < i < n 
and 1 < i < s, ensure that ip^ is equal to the j-th element in S. 
(ii) If a, 6 G {1, 2,... ,n • s}, 1 < a < 6 < n • s, choose at random a x in 
{x ^ ^ I Xi = ^ 5 X 2 = ^^5} (this set is nonempty by (1)) and ensure 
that (^2^ = X' 
(iii) If R is an m-ary relation symbol in r, define the truth value of Rai.. .am 
at random for any a i , . . . , am G { l , 2 , . . . , n ' s } containing at least three 
and at most k distinct members. 
(iv) If R is an m-ary relation symbol in r, define the truth value of Rai.. .am 
to be "false" if ai ... ar^ contains more than k distinct members. 
Let Str(n) be the collection of possible values of B with {1,2, . . . , n • s} 
as universe. Equip Str(72) with the uniform probability distribution /i. Let 
a = ai... ak denote pairwise distinct elements of {1,2,..., n • s} and let d be 
the number of formulas Rvi^ ... Vi^ where R ^ r and {vi^,..., vi^ } contains 
at least three and at most A: distinct variables. 
Claim 1. Suppose that x^T 
and that the 0-isomorphism type p(i'i,... ^Vk) 
satisfies (2) with respect to x- Then the conditional probability 
M(^I = P I ^l^a2 = X,^li = Pi for i = 
3,...,k) 
is > S, where S = (j)^'^~^ • i^^, that is, 
pi{{B I 8 \= pla]} \{B\B[= 
x[ai,a2], B \= p,[a,] for i := 3 , . . . , A:}) > S. 
Proof. The proof is immediate by the definition of d and the fact that, once 
if^. for i = 1,..., A; and (fi^^a2 ^^^ fixed, 0-isomorphism types according to 
(ii) have to be chosen for (2) — 1 pairs of distinct elements. 
Claim 2. Fix ai, 02 • Then 
fi{{B\B^3vs...3vkW{aua2,V3,...,Vk) 
A 
/ \ 
v^ ^ Vj)}) < (l-(5)^ 
l<i<j<k 
where / is the integer part of ^5f • 
Proof. Let x ^ ^ ^md choose (for x) a corresponding p{vi,... ,Vk) according 
to (2). It sufl&ces to prove that the conditional probability 
(3) 
p{{B\B^3vs...3vkp{ai,a2,vs,...,Vk)}\ipla,-^x)<a-Sy. 
By (i), in any B every 0-isomorphism type in 5 is realized by n (> 2-\-f-{k—2)) 
distinct elements. Therefore, for i = 3 , . . . , A: and j = 1,..., / there are 
pairwise distinct elements al G {1,2,..., n-s}\{ai, 02} with (p^j = pi. Under 
the given conditions the events B \= p(ai, 02,^3, • • •, a^) for 1 < j < / are 
independent (compare the construction procedure). Now, 

5.2 Finite Model Property of V^3*-Sentences 
103 
{B\8^ 
3v3 .. .3vkp{ai,a2,V3,... 
,Vk)} 
C{B\ 
for j = 1,...,/, ^ ^ p ( a i , a 2 , a ^ , . . . , 4 ) } . 
Therefore, by Claim 1 we obtain (3). 
Since {8\B^^IJ} 
= 
l<i<j<k 
ai,a2 
— 
— 
ai^a2 
we obtain by Claim 2 that 
/x({H \B^il;})<n'S'{n-s-l)-{l- 
S)^. 
As / is the integer part of jE^, for n big enough we have n - s • (n - s — 1) • 
(1 — 5)^ < 1. Then the probability that B satisfies ip is positive, and therefore 
some member of Str(n) satisfies ip. 
D 
Exercise 5.2.4 Let r be a vocabulary (which perhaps contains constants). 
Show that any satisfiable V^3*-sentence without equality has a finite model 
(argue as in 5.1.7). Conclude that any satisfiable 3*V^3*-sentence without 
equality has a finite model. 
D 
Notes 5.2.5 Theorem 5.1.3 is due to Mortimer [121], Corollary 5.1.4 for 
sentences without equality was already known before (cf. [131]). The proof of 
5.1.3 given here incorporates simplifications from [55]. Together with [44] it 
shows that the satisfiability problem for FO^ is NEXPTIME-complete. The 
papers [59, 60, 127, 144] discuss the decidability of extensions and fragments 
of FO^. Corollary 5.2.2 goes back to Godel [48]; the proof given for 5.2.1 is 
taken from [75]. For formulas with equality the corresponding satisfiability 
problem is undecidable ([49]; see also [50]). For thorough information on the 
decidability and the finite model property of fragments of first-order logic we 
refer the reader to [13]. 

6. Finite Automata and Logic: A Microcosm of 
Finite Model Theory 
One of the major aims of finite model theory consists in characterizing the 
queries in a given complexity class by means of a logic in which they can be 
described. In this way one obtains a new measure of complexity: the complex-
ity of formal descriptions. Moreover, the characterizations allow to translate 
problems on complexity classes into purely modeltheoretic problems, thus 
opening them to modeltheoretic methods. In general, this relationship be-
tween complexity classes and logics turns out to be useful for both, complex-
ity theory and logic. 
Our considerations will show that first-order logic which has played a cen-
tral role so far is not adequate for descriptive complexity. What is missing? 
Which features of computations cannot be expressed in first-order logic and 
which natural extensions of first-order logic capture these features? Once 
these questions are clear they show the way to stronger systems such as log-
ics with fixed-point operators that we shall treat in the next chapters. These 
extensions have natural modeltheoretic properties and thus may turn out to 
be useful in other areas of model theory, too. 
The present chapter deals with the - historically first - logical character-
ization of a complexity class: the characterization of the class of languages 
recognized by automata by means of monadic second-order logic. It turns out 
that this simple case already reflects some of the crucial aspects encountered 
later, at the same time witnessing that the interplay between model theory 
and complexity theory is fruitful for both sides. 
Even though we include all definitions and proofs, a certain familiarity with 
automata will be helpful. 
6.1 Languages Accepted by Automata 
We recall some definitions and notations. Let A be a finite alphabet and A* 
and A+ the set of strings (or words) and the set of nonempty strings over A, 
respectively. Thus, A* = A+ U {A}, where A is the empty word. In automata 

106 
6. Finite Automata and Logic: A Microcosm of Finite Model Theory 
theory subsets of A"*" are called languages} A nondeterministic 
automaton 
M, in short, an NDA (over the alphabet A) is given by a tuple 
M = 
{S,qo,5,F), 
where 5 is a finite set, the set of states, qo £ S is the initial state, F C S 
is the set of {accepting or) final states and SCSxAxSis 
the transition 
relation (intuitively, (q,a,p) € d means: if M is in state q and reads a, then 
M can pass into p). This relation induces a function S : S x A* —>• Pow(5), 
where Pow(S') denotes the power set of 5; 5 is given by 
5iq,\) 
:= {q} 
S{q,wa) 
:= {p \ {r, a,p) £ S for some r £ S{q,w)}. 
In particular, 5{q,a) = {p \ iq,a,p) G 6} for a G A. If S{q,a) is a singleton 
for every a G A, then M is said to be a deterministic automaton or, by short, 
an automaton. Clearly, in this case S{q,w) is a singleton for any w; G A*. If 
S{q,w) = {p}, we simply write S(q,w) = p (and similarly, d{q,a) = p stands 
ioY S(q,a) = M ) . 
The language recognized (or accepted) by the NDA M is defined by 
L(M) 
:= 
{weA+ 
\S{qo,w)nF^9}. 
Hence, in case M is deterministic, 
L{M) 
= 
{weA+ 
\Siqo,w)eF}. 
Let us state the main result of this chapter, even though we still have not 
introduced all concepts appearing in it. With respect to the logical charac-
terizations we have in mind, we are mainly interested in the equivalence of 
(ii) and (vi). The other equivalences are not only useful for the proof, but 
also interesting in their own. 
For a language L C A+ the following are equivalent: 
(i) 
L is the union of equivalence classes of an invariant equivalence 
relation on A"*" of finite index. 
(ii) L is recognized by an automaton. 
(iii) L is recognized by an NDA. 
(iv) L is regular. 
(v) L is definable in monadic second-order logic by a T\-sentence. 
(vi) L is definable in monadic second-order logic. 
^ In the literature languages, in particular languages recognized by automata, may 
contain the empty word. Since to any word we will assign a structure whose 
cardinality coincides with the length of the word, it is more convenient for our 
purposes to exclude the empty string. 

6.1 Languages Accepted by Automata 
107 
Note that (ii) ^ (iii) and (v) ^ (vi) are trivial. We prove the other imphca-
tions by a series of propositions starting with those which mainly deal with 
automata; monadic second-order logic will be treated in the next section. 
An equivalence relation ~ on A+ is called invariant if 
u,v,w G A"^ and u ^ v 
imply 
uw ~ vw. 
Denote by [u] the equivalence class of u and by A+ / ^ the set of equivalence 
classes. The index of ^ is the cardinality of A+/^. 
Proposition 6.1.1 Let ~ be an invariant equivalence relation on A+ of fi-
nite index. Suppose that the language L C A+ is the union of equivalence 
classes, 
L = [ui] U ... U [ur] 
for some ui,... 
,Ur G A"*". Then L is recognized by an automaton. 
Proof. Add [A], "the equivalence class of A", as a new object to A"*"/^ and 
define the automaton M — (5, qo^S, F) by 
5:=A+/.U{[A]}, qo:=l\], 
S([u],a) := [ua], F := {[«i],..., K ] } . 
By invariance of ~, the transition function S is well-defined. For u,v £ A*, a, 
simple induction on the length of v shows that 5([w],f) — [uv], in particular, 
S{[\],v) = [v]. Therefore, 
L{M) = {veA+ 
\S{qo,v)eF} 
= {veA+ 
I [v] eF} = [ui]U...U[ur] 
= L. 
D 
For later applications we state the following result: 
Lemma 6.1.2 (Pumping Lemma) Let ~ be an invariant equivalence re-
lation on A+ of finite index. Then there is an n > 0 such that for any word 
w G A+ with \u\ >n '^ there exist v,w G A+ and x ^ A* with 
u = vwx, \vw\ < n, 
and vw^ ~ vw for all k >0. 
Hence, by invariance, vw^y ~ vwy for all k >0 and ^ G A*. 
Proof. Let / be the index of ~ and set n :=/-(-1. Suppose that w G A+, w = 
ai ... as, where a i , . . . , a^ G A and s > n. Then, for some i and j with 1 < 
i < j < n, we have ai ...a^ ~ ai ...a^. Let v = ai ...ai and w = Oi^i .. .GJ. 
Thus V ^ vw, and by invariance oi ^, vw ^ vw^ ~ vw^ ~ 
D 
We now turn to a description of the languages recognized by automata 
in terms of simple, so-called regular expressions. First some notations: The 
concatenation of languages Li and L2, denoted by L1L2, is the set {uv \ u is 
\u\ denotes the length of u. 

108 
6. Finite Automata and Logic: A Microcosm of Finite Model Theory 
in Li and f is in L2}. Define L^ :— L and L^ := L^~^L forn > 1. The plus (or 
positive) closure L+ of L is the set L+ := |Jn>i ^^' ^^^ regular expressions 
(over A) are strings over the alphabet {0} U { a | a G A} U {U, +,),(}. 
Together with the languages they denote, the regular expressions are defined 
recursively as follows: 
(a) 0 is a regular expression and denotes the empty set. 
(b) a is a regular expression and denotes the set {a}. 
(c) If r and s are regular expressions denoting the languages R and 5, re-
spectively, then (r Us), (rs), and r+ are regular expressions that denote 
the sets RU S, RS, and i?+, respectively. 
A language is regular if it is denoted by some regular expression. For conve-
nience we often omit parentheses in regular expressions (such as in ri U.. .Ur^) 
that have no influence on the language they denote. Moreover, we assume that 
+ has higher precedence than concatenation or U, and that concatenation has 
higher precedence than U. 
Proposition 6.1.3 If L is recognized by an NDA then L is regular. 
Proof. Let L be recognized by the NDA M = {S,qo,S,F) 
with S 
= 
{qo,...,qn}. 
Let L]^ be the set of all nonempty strings that M can read 
starting in qi and ending in qj without going through any state numbered 
> k, 
V^ 
:= {61 ... 6s I s > 1, 61,..., 6s 6 A, there are io,..., is such that 
ii,...,Zs-i < k, io = i, is =j, and {qi^,bm+l,qi^+^) G (5 for m < s}. 
Since L{M) = Uo GF^n+i' i* suffices to show that all Vj^ are regular. We 
proceed by induction on k. As LQ-^ = {a G A | (qi^a^qj) G (5} is a subset of 
A, say VQ — {ai,..., a^}, VQ is denoted by (ai U ... U a^), or by 0 in case 
r = 0. 
For the induction step note that a nonempty string is in I/^-^i' i^ i^ can 
be read without visiting any state numbered > A: -I- 1, thereby starting in 
qi, ending in qj, and passing through q^ zero times or one or more than one 
time. Hence, 
r U 
_ 
jij 
\ I Tik j-kj . , yik/ 
Tkk\+ 
j-kj 
^k+1 
- 
^k 
^^k 
^k 
^ ^k 
\^k 
) 
^k 
• 
By induction hypothesis, for all i',j' there is a regular expression r^-^ denot-
ing L\^ . Therefore, L]^^^ is denoted by 
rl^Urfr,^^Urf(rf)M^-. 
D 
6.2 Word Models 
We turn to languages definable in monadic second-order logic. In order to 
bridge the gap between automata and logic, we introduce a correspondence 

6.2 Word Models 
109 
between words and structures. Once more we fix an alphabet A and let r(A) 
be the vocabulary {<} U {Pa | a G A}, where < is binary and the Pa are 
unary. For a given i/ G A+, say u = ai ... a^, we consider structures of the 
form 
{B, <, (Pa)aeA) 
where the cardinality of B equals the length of w, < is an ordering of B, and 
Pa corresponds to the positions in u carrying an a, 
Pa 
'= 
{b e B \ ioT some j , 6 is the j-th element of < and aj = a}. 
We call them word models for u and denote the class of word models for u 
by Ku- For example, if A = {a, b} and u = abbab, the structure 
({l,...,5},<,Pa,n), 
where < is the natural ordering on { 1 , . . . , 5}, Pa = {I? 4}, and Pt = {2,3, 5} 
is a word model for u. 
Any two word models for u are isomorphic. For simplicity we therefore 
often speak of the word model for u, denoting it by Bw 
Note that for w, t? G A+ we obtain a word model for uv by forming the 
ordered sum (cf. 1.A3) 
Bu<By. 
A language L C A+ is definable in monadic second-order logic, if there is a 
sentence (p in MSO[r(A)] such that Mod{(p) = UweL ^ « ' ^^' ^^ore succinctly 
(but not fully correct), Mod{(p) = {Bu \ u £ L}. The notion of definability in 
FO is introduced similarly. 
Let cpw be the first-order sentence 
(fw 
•= 
" < is a total ordering" A\/x \/ PaX A A \/x-^{PaX AP^x). 
i,beA 
a,oGA 
Then, Mod{^w) is the class of all word models, Mod{(fw) = {Bu | w G A+}, 
and therefore the language A+ is definable in first-order logic. 
As the next step in the proof of the main result stated at the beginning 
of this chapter we shall show that any regular language is definable in 
monadic second-order logic. First we introduce some notations: Let ^min(^) 
and '0max {^) be first-order formulas defining the first and the last element of 
the ordering, respectively: 
^min(a:) := ^y^y 
< x, 
ipm&^x) := \/y^x < y. 
For any formula (/? of MSO and variables x and y let ip^^^y^ be a formula 
expressing that the closed interval [x,y] satisfies ip, and similarly, c/?]^'^] a 
formula expressing that the half-open interval ]x,y] satisfies cp. Such formu-
las can be obtained from ^p by relativizing the first-order quantifiers to the 
interval, the main clause of an inductive definition being (for z ^ x,z ^ y) 

110 
6. Finite Automata and Logic: A Microcosm of Finite Model Theory 
(3^(p)[^'^J 
:= 
3z{x<zAz<yAip^''^y^) 
(3^(/?)]^'^] 
:= 
3z{x<zAz<yAip^''^y^). 
Proposition 6.2.1 Any regular language is definable in monadic second-
order logic by a Y\-sentence. 
Proof. First we prove by induction on the length of the regular expression 
r that there is a sentence ^r of MSO defining the language denoted by r. 
Afterwards we show that we can replace ipr by a E J-sentence. 
(P0 := 
3a; -yx = x^ (/?a := ^w A 3x\/y(y = x A Pax) 
(f(^j,g>^ 
:= ipw A "the universe is partitioned into two intervals sat-
isfying cpr and (fsi respectively" 
= 
<fw/\ 3x3y3z{il)rnm{x) 
Ay <ZA 
'0max(^) A (/?[f^'^] A (/?]/'^]) 
(fr+ •= ^w A "there is a set of right endpoints of intervals, which 
partition the universe, all parts satisfying (/?r" 
= 
Lfw A 3X(3y{Xy 
A ipme.^iy)) A 
3x3y(iPmin{x) AXyA 
"iz^z < ?/ -^ ^Xz) A 4^'^]) A 
\lx\ly 
{{x < y AXx AXy A\/z{x < z <y ^ ^^z)) 
-^ ^1"^^^^)). 
Now, one obtains a Ej-sentence by inductively bringing all existential second-
order quantifiers to the front. In general, a monadic second-order formula 
\fx3Yx 
with first-order x is not equivalent to a monadic S J-formula (cf. 
2.4.8). However, in the case of the formula in the last two lines of ipr+ we can 
argue as follows: Suppose that (pr is equivalent to 3Yi ... 3YmX- ^^ models of 
(pw (and only these are relevant) the formula in the last two lines is equivalent 
to 
3Yi... 3Ym\fx\fy{{x <y AXx AXy A \/z{x <z<y^ 
^Xz)) -^ x^^'^^) 
(for the nontrivial implication of the equivalence piece Yi,... ,Ym together 
from corresponding subsets chosen in the (disjoint) intervals). 
D 
With the next proposition we close the last gap in the proof of the main 
result. 
Proposition 6.2.2 Let L C A+ be definable in monadic second-order logic. 
Then there is an invariant equivalence relation on A+ of finite index such 
that L is a union of equivalence classes. 
Proof. Assume that Mod{cp) — {Bu \ u e L} where (/? is a sentence of MSO. 
Let m be the quantifier rank of ip and define ~ on A+ by 
u^v 
iff 
Bu =!^^'^ B, 

6.3 Examples and Applications 
111 
(recall that A =^^^ B means that A and B satisfy the same sentences of 
MSO of quantifier rank < m). Clearly, ~ is an equivalence relation. Since, 
up to logical equivalence, there are only finitely many sentences of quantifier 
rank < m (cf. 3.1.3), the relation ~ is of finite index. By definition of m, 
Bu \= ^ and u ^ v imply By \= (p. 
Thus, 1/ = UIM \ u e A'^ ,Bu \= ^}' Finally, ~ is invariant: Assume u ^^ v 
and w e A'^. Then Bu =^^^ By. Since = JJ^^ is preserved by ordered sums 
(cf. 3.1.4), we obtain 
K 
C^ K 
^ IQ 
= M S O 
t2 
^ 
1Q 
c^ f2 
that is, uw ^ vw. 
D 
Summing up we have shown the result stated at the beginning of section 
6.1: 
Theorem 6.2.3 For a language L C A+ the following are equivalent: 
(i) 
L is the union of equivalence classes of an invariant equivalence relation 
on A+ of finite index. 
(ii) L is recognized by an automaton. 
(iii) L is recognized by an NDA. 
(iv) L is regular. 
(v) L is definable in monadic second-order logic by a Ej -sentence. 
(vi) L is definable in monadic second-order logic. 
D 
In particular, this theorem shows that a language is accepted by an automa-
ton just in case it is definable in monadic second-order logic. Another de-
scription of languages accepted by automata is given by means of the regular 
expressions. Is that a logical description too? What makes a logic? We shall 
address this problem later. 
6.3 Examples and Applications 
By the following examples and applications we try to exhibit the method-
ological usefulness of Theorem 6.2.3. 
Proposition 6.3.1 (a) The class of languages over A accepted by automata 
is closed under the boolean operations {complementation and union). 
(b) (Pumping Lemma). Let L be accepted by an automaton. Then there is 
n > 0 such that for any u G A"^ with \u\ > n there exist v,w £ A"*" and 
X £ A* with 
u = vwx, \vw\ < n, and for k >0 and y e A* : vw^y ^ L iff vwy G L. 

112 
6. Finite Automata and Logic: A Microcosm of Finite Model Theory 
Proof. Part (a) holds, since monadic second-order logic is closed under the 
boolean connectives -i and V, and part (b) is a reformulation of the Pumping 
Lemma 6.1.2. Both results also have simple direct proofs. 
D 
Example 6.3.2 Let A = {a}. Identify 
a.. .a with the natural number n 
n-times 
and thus, A+ with the set N+ of positive natural numbers. A subset L of N+ 
is accepted by an automaton iff L is ultimately periodic, that is, if there are 
p, r G N+ such that for all m > p, 
m-\- r £ L 
iff 
m E L. 
In fact, assume first that L is accepted by an automaton. By the Pumping 
Lemma there are n,j,r 
G N+ and / > 0 with n = j -\- r -\-1 such that for all 
A; > 0 and 5 G N, 
j -{- kr + s e L 
iff 
j -\-r + s e L. 
In particular, if m > p := j + r, say m = j -\-r -\- s, then (take k = 2) 
m -\- r E L 
iff 
m £ L. 
Now let L be ultimately periodic. Choose corresponding p, r G N+. Set Li := 
{m G L I m < p} and L2 := {m £L\p<m<p-\-r}. 
Then, by periodicity, 
L = Li U L2 U {m -\-kr \m £ L2, k > 1}. So L is the union of the finite (and 
hence regular) sets Li and L2 and of the languages denoted by the regular 
expressions a"*(a'^)+ with m G L2. Thus L is regular. 
D 
As a consequence, the classes of finite ordered structures of vocabulary 
{<} that are axiomatizable in MSO coincide with the ultimately periodic 
ones. 
Example 6.3.3 For A = {a, 6} the set 
L 
:= 
{li G A^ I the number of a's in u equals the number of 6's in u} 
is not accepted by an automaton. Otherwise, choose n and a representation 
vwx of a^b'^ according to the Pumping Lemma. Since \vw\ < n, we have 
w G {a}^- Hence the string vw'^x contains more a's than 6's and therefore, 
vw'^x ^ L (while vwx = a^hi^ G L), a contradiction. 
D 
We use this example to prove nonaxiomatizability results for monadic 
second-order logic: A graph {G,E'^) is bipartite, if there is an X C G such 
that E^ C{X x{G\X)) 
U {{G\X)xX), 
and it is balanced, if the set X can 
be chosen such that, moreover, ||X|| = \\G \ X\\. Denote by BAL the class 
of finite balanced graphs and by BAL< the class of finite balanced graphs 
carrying an arbitrary ordering on their universe, 
BAL< 
:= 
{(Q, <)\G e BAL, < an ordering of G}. 

6.3 Examples and Applications 
113 
Proposition 6.3.4 The class BAL<: - and hence the class BAL - is not 
axiomatizable in monadic second-order logic. 
Proof. Suppose that BAL< = Mod(v9) for a sentence ^ of MSO. Let A = 
{a, 6} and let L be as in the preceding example. For w G A+ recall that 
Bu = {Bu, <,Pa,Pb) denotes a word model associated with u, say, with 
Bu = {l,...,|w|} and < the natural ordering. Let Qu — {Bu,Ru) be the 
bipartite graph given by 
Ru := 
{(iJ)eB^xBu\Paiif^Pbj}^ 
Then, 
and 
(^n,<)eBAL< 
iff 
ueL 
(Pa... 
^Pb-) 
{Q^,<)\=ip 
iff 
Bu^^ 
E... 
(where (f (-P°-^-P& ) ig obtained by replacing any subformula in ^p of the form 
Exy by (PaX ^ Pty)). Therefore, Mod((/? {Pa.^^Pb-)^^ ^ |^^|^ ^ j^y rj.^^^_ 
rem 6.2.3 now implies that L is accepted by an automaton, which contradicts 
the preceding example. 
D 
Corollary 6.3.5 (a) Let HAM be the class of finite graphs with a Hamil-
tonian circuit. Then, HAM and HAM< are not axiomatizable in MSO. 
(b) Let CHS be the set of finite graphs which contain a clique of at least half 
their size. Then, CHS and CHS< are not axiomatizable in MSO. 
Proof (a) A graph of the form (XUF, E) with E = {{a,b) \ {a e X, b e Y) 
or {a e Y, b e X)} has a Hamiltonian circuit iff it is balanced. If HAM< = 
Mod{(p) for an MSO-sentence cp, then the sentence 
3X{Wx\/y{Exy -^ {Xx ^ ^Xy)) A ^ 
^^-^^^-)^^ 
would axiomatize the class BAL<. 
(b) Suppose that CHS< = Mod((/?) for some ^p of MSO. Then an axiomati-
zation of BAL< in MSO would be given by 
3X{\/x\/y{Exy 
-> {Xx 4^ ^Xy)) 
^ ^- 
E:^: 
^ ^- 
EZZ 
-^ 
(note that the conjunction in the last line implies that both X and its com-
plement have size at least half of the universe). 
D 
Exercise 6.3.6 Show that a graph Q is bipartite iff it contains no cy-
cle of odd length (i.e., for no n > 0 there are a i , . . . , a2n-i-i such that 
aiE^a2, a2-E^^a3,..., a2nE^o,2n+i, and a2n+iE^CLi). Conclude that the class 
of bipartite graphs is not first-order axiomatizable (of course, it is axiomati-
zable in MSO). 
D 

114 
6. Finite Automata and Logic: A Microcosm of Finite Model Theory 
6.4 First-Order Definability 
We turn to the problem of characterizing the languages that are accepted 
by automata and are first-order definable. The proof of 6.2.1 shows that 
second-order quantifiers are only needed for the positive closure, that is, in 
the transition from a regular expression r to r+. Therefore, if r does not 
contain the symbol +, the language L denoted by r is first-order definable. 
But a simple induction on the length of such an r shows that then L must 
be finite. 
Example 6.4.1 Let A be an alphabet. For a G A the language A+ \ {a} is 
infinite but first-order definable by 
ipw A {^X^ll)rnin{x) 
V ^X{^min{x) 
A 
^PaX)) 
(for the definition of ipw and ^min compare section 6.2). 
D 
We thus see that the class of languages denoted by regular expressions 
without "^ is not closed under complementation whereas the class of first-order 
definable languages is. Therefore, we add closure under complementation in 
the definition of plus free regular expressions:^ 
— 0 , a (for a ^ A) are plus free regular expressions. 
— If r and s are plus free regular expressions then so are ~r, (r U s), (rs). 
If r denotes the language L, then ~ r denotes A+ \L. A language is said to 
be plus free regular if it is denoted by a plus free regular expression. 
Theorem 6.4.2 A language is plus free regular iff it is definable in first-
order logic. 
Proof. If the language L is definable by the first-order sentence (/?, then A+ \L 
is definable by {(pw A -ly?). This observation together with the corresponding 
parts of the proof of 6.2.1 shows that any plus free regular language is first-
order definable. 
We turn to the other direction. Recall that r(A) = {<}U{Pa | « ^ A}. For 
convenience, we add a constant min to this vocabulary, which henceforth will 
always denote the first element; more precisely, we shall only look at models of 
(/?^ A'?/^rnin(inin). By induction on the quantifier rank of the FO[r(A)U{min}]-
sentence ip we show for a language L that if 
Mod{ipw A 'i/'niin (min) A (^) = {(Btt,min^") \u ^ L] 
then L is plus free regular. (This gives the claim.) 
First assume that ^p is atomic. Then ip is min = min or Pa min for some 
a G A. In the first case, L is A+, which can be denoted by the plus free 
^ In the literature languages and, in particular, languages accepted by automata, 
may contain the empty word. Then the operation "*" is replaced by the operation 
*, where L* :— L"*" U {A} and the role of 'plus free' is taken over by 'star free'. 

6.4 First-Order Definability 
115 
regular expression ^ 0. Let (p be Pa min. Then L = {a} U {a}A''". Therefore, 
L is denoted by a U a(~ 0). 
If the languages defined by the sentences ip and ip are denoted by the plus 
free expressions r and s, then ~ r and r U s correspond to the sentences -^(p 
and ((/? V V'), respectively. 
Let (p = 3xil){x). Then Mod{(pw A '0min(niin) A 3X'IIJ{X)) = 
, , 
Mod{ipw A '0min(min) A ^(min)) 
(*) 
U Mod{ipw A '0niin(niin) A 3x{-iX — min A'0(a:))). 
By induction hypothesis, the first class of structures in (*) corresponds to 
a plus free regular language. Concerning the second class, let c be a new 
constant. Then the finite models of ipw A '0niin(min) A 3x(^x = min A'0(a:)) 
are the r(A) U {min}-reducts of the finite structures (^,min^,c^) such that 
{Ay min"^, c"^) |= (pw A '0min(niin) A -ic = min A '0(c). 
Note that any such structure can be written in the form 
(^,min^,c^) = ( A < A,min^,c^), 
where < denotes the ordered sum and where (^i,min ) |= ((/?vt^ A'0inin(niin)) 
and {A2,c^) |= {^w A ipmm{c)). Let m be the quantifier rank of ip. Choose 
the - up to logical equivalence - finite set {(0i(min),Xi(c)) | i G /} of pairs 
of FO-sentences of quantifier rank < m such that 
(A,min^i) ^ {(pw A '0niin(min) A '0i(min)) 
and 
{A2,c'^^)\= {(pw /\ V'min(c) A Xi(c)) 
imply 
{Ai,mm^^) 
< {A2,c^^) N ^W-
By induction hypothesis there are plus free regular expressions ri and Si 
denoting the languages defined by y^w A •0niin(niin) A '0i(min) and ipw A 
^min(min) A Xj(min), respectively. Then the plus free regular expression 
[Ji^i{riSi) denotes the language defined by {(pw A '0inin(niin) A 3x{^x 
= 
min A^(x))). Note that, if {Ai <A2,mm^\c^'') 
\= 0(c) then (by 2.3.11) the 
pair (^(^^,n,inAi),V^(^2,c^2)) of m-isomorphism types belongs (up to logical 
equivalence) to {('0j(min),Xi(c)) \i E I}. 
D 
Again, for A = {a} identify A"*" with the set N+ of positive natural num-
bers. Examples 6.3.2 and 6.3.3 show that automata do not have the ability to 
count; for instance, they cannot recognize if a given string has prime length; 
more explicitly, the set {p | p a prime} is not accepted by an automaton. 
On the other hand, we saw in Example 6.3.2 that automata are capable to 
count modulo a natural number, e.g. the set {5n | n > 1} is accepted by an 
automaton. But first-order logic even lacks this restricted counting ability; 

116 
6. Finite Automata and Logic: A Microcosm of Finite Model Theory 
in fact, it is an immediate consequence of 2.3.6 that a subset L of N+ is 
first-order definable iff for some n > 1 
{m I m > n} n L = 0 
or 
{m | m > n} C L. 
Before we state the corresponding theorem for word models over arbitrary 
alphabets, we remark that we encounter this noncounting feature of first-
order logic at various points in the book. 
Theorem 6.4.3 For a language L C A'^ accepted by an automaton the fol-
lowing are equivalent: 
(i) L is definable in first-order logic. 
(ii) L is noncounting in the sense that there is an integer k > 1 such that for 
every 2/ G A+ and x,z e A*, 
xy^z e L 
iff 
xy^^^z G L. 
Proof. We only prove the implication from (i) to (ii) and refer the reader 
to the literature for the involved proof of the other half (cf. 6.4.4). Suppose 
{Bu\ueL} 
= Mod((^) for ^ G FO[T(A)]. Let k := 2"^ + 1, where m is the 
quantifier rank of ip. Then by 2.3.13, for any |/ G A+ we have 
Byk ^ 
<\ By ^rn 
<l 
^y — 
Byk+i. 
Using 2.3.10, we obtain 
^xy'^z 
— Bx <\Byk <\Bz 
=m 
Bx <Byh+i 
<\Bz 
= 
B^yk+i^-
In particular, 
^xy'^'z N ^ 
iff 
^xyk+^z 
\= ^ 
and hence, 
xy^z e L 
iff 
xy^'^^z e L. 
D 
As the results of this section show, the plus operation cannot be captured 
in first-order logic. An instance of this operation can be viewed as the fixed-
point of a monotone operation. In fact, let L C A+ be a language. Define 
CL : Pow(A*) -^ Pow(A*) by 
CL{M) 
:= 
LUML. 
Then 
(a) CL is monotone, that is. Mi C M2 implies CL(MI) 
C (7L(M2). 
(b) 
For n > 1, CL(. .. (CL(0)) ...) = L U L^ U . . . U L^. 
n-times 

6.4 First-Order Definability 
117 
M is a fixed-point of CL if CL{M) = M . It can easily be proved that the least 
- with respect to set-theoretical inclusion - fixed-point of CL is given by 
CL(0) U Cz,(Ci(0)) U Ct(Ct(Ct(0))) U ... 
Hence by (b), 
L~^ is the least fixed-point of CL • 
Fixed-points of monotone operations play a prominent role in the general 
theory. We shall study them in Chapters 7 and 8. In particular, we shall see 
that polynomial time queries on structures with an underlying ordering can 
be captured in a logic extending first-order logic by adding the ability to 
express fixed-points of definable monotone operations. 
Notes 6.4.4 The connection between finite automata and monadic second-
order logic as expressed in Theorem 6.2.3 is due to [15, 140]. For a proof 
of Theorem 6.4.3 and references on finite automata compare [136] or [138]. 
Some examples are taken from [17]. 

7. Descriptive Complexity Theory 
In Chapter 1 we gave the example of a database D that contains the names 
of the main cities in the world and the pairs (a, 6) of cities such that a given 
airline offers service from a to 6 without stopover. D may be interpreted 
as a first-order structure, more precisely, as a digraph Q — {G,E'^), where 
G is the set of cities and E^ab means that there is a flight from a to 6 
without stopover. Now, first-order logic may be viewed as a query language. 
For example, let 
(p{x, y) 
:= 
Exy V 3z{Exz A Ezy). 
If (p is thought of as a query to D, the response will consist in the set of 
pairs (a, 6) of cities such that a can be reached from b with at most one stop. 
First-order logic provides a rich class of database queries. However, there are 
plausible queries which are not first-order expressible. The query Q "Is it 
possible to fly from x to y using only the airline in question?" to databases of 
type D is an example. Also from a computational point of view answers to Q 
are more complex than answers to cp. Descriptive complexity theory analyzes 
the complexity of all queries definable in a given logic, the central question 
being the following: Given a complexity class C, is there a logic C such that 
the queries definable in JC are precisely the queries in C? For short: Given 
a complexity class C, is there a logic that captures C? In the positive case, 
there mostly will be an effective procedure translating every formula of such 
a logic into a program for the corresponding query. In this sense the logic can 
be viewed as a higher programming language for C. 
In the first section we briefly introduce some extensions of first-order logic 
which have been considered with this aim in mind. Their model theory will be 
studied in Chapter 8. The second section is devoted to complexity classes of 
structures. In particular, we describe how structures may be viewed as inputs 
to Turing machines. In section 7.3 we show how certain logics can be used 
to describe computations of a given complexity class. In section 7.4 we look 
at the other direction and study the complexity of the satisfaction relation 
of such logics. By bringing together both sides we are lead to the descriptive 
characterizations of complexity classes we aim at, thus constituting a bridge 
between complexity theory and model theory. First consequences are given 
in the last section of this chapter. 
Throughout this chapter all structures will be finite. 

120 
7. Descriptive Complexity Theory 
7.1 Some Extensions of First-Order Logic 
We introduce inflationary fixed-point logic, partial fixed-point logic, deter-
ministic transitive closure logic, and transitive closure logic. These logics are 
obtained from first-order logic by adding operations well-suited to describe 
iterative and recursive procedures, for example, the behaviour of comput-
ing machines. As already remarked in the introduction to this chapter, their 
model theory will be studied in Chapter 8. 
Let M be a finite nonempty set. Denote by Pow(M) the power set of M. A 
function F : Pow(M) —>• Pow(M) induces a sequence 
0, F(9), F(F(0)),... 
of subsets of M. For its members we write FQ, Fi,.... So FQ = 0 and Fn+i = 
F{Fn). Suppose there is an no > 0 such that F„o+i = ^m, that is, F(Fno) = 
FnQ. Then F^ — F^^ for all m > UQ. We denote F^o by Foo and say that 
the fixed-point Foo of F exists. In case the fixed-point FQO does not exist, we 
agree to set FQ© := 0. 
F is said to be inflationary if for all X C M, 
X C F{X). 
Lemma 7.1.1 (a) The sequence {Fn)n>o is periodic, more precisely: There 
are m < 211^1' and I > 1 such that Fk = Fk+i for all k > m. 
(b) //Foo exists then FQO = F2||MII_I. 
(c) If F is inflationary then Foo exists and FQO = ^||M||-
Proof, (a) As Pow(M) has 211^11 elements, there are m < 211^11 and / > 1 
such that Fm = F^+/. Therefore, Fm+i = F(Fm) = F{Fm+i) = Fm+i+u 
Fm+2 — Fm^2^l^ 
(b) Choose m < 211^11 and / > 1 according to (a). If F ^ = F^+i then 
Fm = F^wMw^i = Foo. If Fm ^ Fm+1 then, by (a), for s > m, we get 
{Fm =) Fm+s-i ^ Fm+i+s-i {= -^m+i) and hence, Foo does not exist. 
(c) By assumption, FQ C Fi C ... C M. Since M has ||M|| elements, this 
sequence must get constant not later than with F||jvf||. 
• 
Let ^{xi,... 
,Xk,u,X,Y) 
be a formula in the vocabulary r, where the 
relation variable X has arity k; moreover, let ^ be a r-structure, b an inter-
pretation of u in A, and S an interpretation of Y over A. Then (/?, A, 6, and 
S give rise to an operation F"^ : Pow(A^) -^ Pow(A^) defined by 
F^R) 
:= 
{(au...,ak)\AI^<p[ai,...,a^,b,R,S]}. 
(The notation F'^ does not make explicit all relevant data.) 

7.1 Some Extensions of First-Order Logic 
121 
To give an example, let Q = (G,E^) 
be a graph and 
^o{x, y, X) 
:= 
{Exy V 3z{Xxz A Ezy)) 
with xy corresponding to x above. Then, F^"" = 0, F^"" = F<^o(0) = £;^, 
^2^0 = F^^{E^) 
= £;^U{(a,6) | (£;^ac and £;^c6) for some c G G}. By 
induction on n one shows that 
F^° = {(a, h) I there is a path of length < n from a to 6}, 
and hence, 
F^ — {(a, 6) I there is a path from a to b}. 
Note that for ^^ as above the function F^-^^^"^^ (where 'x = x\ .. .X]^) is infla-
tionary. 
One obtains Inflationary Fixed-Point Logic FO(IFP) and Partial Fixed-Point 
Logic FO(PFP) by closing first-order logic FO under inflationary and arbi-
trary fixed-points of definable operations, respectively. We state the precise 
definitions. 
For a vocabulary r the class FO(IFP)[T] of formulas of FO(IFP) of vocabulary 
T is given by the calculus (we use the succinct notation 
V^l ^ • • • ^ ^ n 
for the clause "If (/?i,..., (/P^ are formulas then (/? is a formula") 
• 
where (p is an atomic second-order formula over r 
cp 
(p,il; 
ip 
^if 
' 
(99 V -0) ' 
^xip 
'P 
— 
-
where the lengths of x and t are the same 
L 
x,x^\ 
^^^ coincide with the arity of X. 
For FO(PFP) we replace the last rule by 
where the lengths of x and t are the same 
[ 
x,xy^\ 
^^^ coincide with the arity of X. 
Sentences are formulas without free first-order and second-order variables, 
where the free occurrence of variables is defined in the standard way, adding, 
for example, for FO(IFP) the clause 
free([IFP^,x^] t) 
:= free(t) U (free((^) \ {x, X}). 
The semantics is defined inductively w.r.t. the calculus above, 
[IFP^,xV^]i meaning that 
t £ F^^""^^ 

122 
7. Descriptive Complexity Theory 
and 
[PFP^,x^] t 
meaning that 
t e F^. 
More precisely: If X is k-aiy and if the variables free in [IFP^,x^] t are among 
u and Y, and b and S are interpretations in ^ of li and F, respectively, then 
A \= [lFF^,x^]i 
[IS] 
iff 
(ti[6],...,t,[6]) G Fi,^^^'^^ 
^ \= [PFF^,x^]i 
[IS] 
iff 
(^i[6],...,^,[6]) G F^. 
Examples 7.1.2 (a) In the language of graphs the formula 
V'o(a^, y) 
'-= [lFFxy,x (Exy V 3z{Xxz A Ezy))] xy 
of FO(IFP) expresses that x^y are connected by a path. Hence, the class 
CONN of connected graphs is axiomatizable in FO(IFP) by Va:V^(-ix = y ^ 
x[^o{x,y)) (and the graph axioms). It is not axiomatizable in FO (cf. 2.3.8). 
(b) For r = {<,S',min,max} the sentence 
-'[IFPa;,x(a^ = min V 3y3z{Xy A Syz A Szx))] max 
of FO(IFP) together with the ordering axioms axiomatizes the class of or-
derings of even cardinality. The same holds for the class of orderings of odd 
cardinality and the FO(PFP)-sentence 3x [PFPa;,x il^{x,X)] x where 
'(p{x^X) = i\/y^Xy/\x 
= min)V(Xmax Aa: = 
max)\/3y{XyA3u{SyuASux)). 
a 
To compare the expressive power of logics we introduce the following 
relations. 
Definition 7.1.3 Let Ci and £2 be logics. 
(a) JCI < £2 (read: £1 is at most as expressive as C2) if for every r and every 
sentence if G CI[T\ there is a sentence ip G C2[T] such that Mod((^) = 
Mod(^).i 
(b) Ci = C2 (read: Ci and C2 have the same expressive power) if £1 < C2 
and £2 < £1 • 
(c) Ci < C2 if £1 < £2 and not £2 < £i- 
• 
In most cases, a proof of £1 < £2 even yields that every formula of £1 is 
equivalent to a formula of £2. In particular, £1 < £2 implies that £1 < £2 
holds for all formulas of £1 containing only free individual variables (one 
simply replaces these variables by new constants). Thus, £1 < £2 will imply 
that every global relation definable in £1 is also definable in £2. 
By Example 7.1.2(a), we have FO < FO(IFP). 
^ £[T] denotes the class of formulas of £ of vocabulary r. 

7.1 Some Extensions of First-Order Logic 
123 
Proposition 7.1.4 FO(IFP) < FO(PFP). 
Proof. Note that [IFP^,x^] t is equivalent to [PFP^,x {Xx V (p)] t. 
D 
Let i? be a binary relation on a set M, R C M^. The transitive closure 
TCiR) of R is defined by 
TC{R) 
:= 
{{a, h) G M^ | there exist n > 0 and eo,... ,6^ € M such 
that a = eo,6 = en, and for all i < n, (ej,ei+i) G i?}. 
And the deterministic transitive closure DTC{R) is defined by 
DTC(i?) 
:= 
{(a,6)G M^ | there exist n > 0 and eo,...,en G M such 
that a = eo,6 = e^, and for all i < n, e^+i is the 
unique e for which (ej,e) G i?}. 
Transitive Closure Logic FO(TC) and Deterministic Transitive Closure Logic 
FO(DTC) are obtained by closing FO under the transitive closure and the 
deterministic transitive closure of definable relations, respectively. More pre-
cisely: For a vocabulary r the class of formulas of FO(TC) of vocabulary r 
is given by the calculus 
where cp is an atomic first-order formula over r 
-"(/? 
((/? V -0) 
3xip 
_=^ 
where the variables in ^ ^ are pairwise distinct and 
L 
x,y^\s 
where the tuples x,y,s, 
and t are all of the same 
length, s and t being tuples of terms. 
For FO(DTC) the last rule is replaced by 
1-^^ with the same 
[DTC^,^ (p\ at 
side conditions. We define 
free([TC^,^ (p] st) 
:= 
free(s) U free® U (free((/?) \ {x, y}), 
and similarly for FO(DTC). 
The meaning of [TCx,y ^{x, y, u)] M is 
{s,t) eTC{{{x,y) 
\ ip{x,y,u)}), 
and the meaning of [DTC^,^ (p{x, y, u)] M is 
{s,t) eDTC{{{x,y) 
\ ip{x,y,u)}) 
(here {{x,y) 
\ ip{x,y,u)} 
is considered as a binary relation on the set of 
length(^)-tuples of the universe). 
Thus a graph is connected if it is a model oi'^x\fy{->x = y -^ [TCx,yExy] xy). 

124 
7. Descriptive Complexity Theory 
Proposition 7.1.5 (a) FO(DTC) < FO(TC). 
(b) FO(TC) <FO(IFP). 
Proof. For (a) note that 
^fin [DTC^,^v?(^,y,u)] St ^ [TC^,y{^{x,y,u) 
A V^((/?(x,z,u) -^z:= y))] st 
and for (b) that 
Nfin [TCx,y^(x, y, u)] St ^ [IFP^^,x {^{x, y, u) V 3v{Xxv A ip{v, y, u)))] st. 
D 
In the following, axiomatizability in a logic (in the sense of the following 
definition) will be a major issue. 
Definition 7.1.6 Let K be a class of r-structures and JC a logic. K is axioma-
tizable in C, if there is a sentence of C of vocabulary r such that K = Mod{(p). 
D 
Sometimes, when relating logics and complexity classes it is convenient to 
restrict oneself to sufficiently large structures. This does not affect problems 
of axiomatizability. In fact, for a class K of structures and m > 1 denote by 
Km the subclass of K of structures of cardinality > m, 
Km 
:= 
{A\AeK,\\A\\>m}. 
For every finite structure A there is a sentence (^^ of FO characterizing A 
up to isomorphism (cf. 2.1.1), that is, 
15\=ipA if^ 
B^A 
holds for all B. Hence, for any logic C with FO < JC, 
K is axiomatizable in C iff Km is axiomatizable in JC. 
In fact, setting ipm '•= \/WA \ A ^ K, \\A\\ < m} we have that K = Mod{ip) 
implies Km = Mod{(pA-^(pm), and Km = Mod(V^) implies K = Mod{ip\/ipm)-
7.2 Turing Machines and Complexity Classes 
The aim of the present section is to recall basic definitions and results from 
computation theory, to fix our computation model for structures as inputs, 
and to introduce the corresponding complexity classes. It is not intended as 
a substitute for a course in computation theory, and some familiarity with 
the basic notions will be helpful. For references compare the notes 7.5.26. 
We adopt a computation model which belongs to the most popular ones 
in theoretical computer science, the Turing machine model. Our choice is 

7.2 Turing Machines and Complexity Classes 
125 
motivated by the fact that Turing machine computations allow for simple 
descriptions and for natural definitions of complexity classes. However, as 
Turing machines deal only with strings, any other data must be coded by 
strings. The tedious work of encoding is one price we have to pay for the 
advantages. Moreover, the model does not well reflect parallel, distributed, 
or real time computations, as only local changes are made in a step. However, 
these shortages are not really important for our aims. 
For the following, we fix a finite alphabet A. A Turing machine M is a finite 
device that performs operations on a tape which is bounded to the left and 
unbounded to the right and divided into squares (or cells). The machine 
operates stepwise, each step leading from one situation to a new one. In any 
situation every square of the tape either contains a single symbol from A or is 
blank. In the latter case we say that it contains the symbol "blank". There is 
one exception: the leftmost or "virtual" cell always contains an endmark, the 
"virtual" letter a (which is not in A). M has a head which, in any situation, 
scans a single square of the tape and, in any step of a computation, erases or 
replaces the scanned symbol by another one and moves one cell to the left or 
to the right or remains at its place (we speak of a read-and-write head). 
In every situation, M is in one of the states of a finite set State(M), the 
set of states of M. State(M) contains a special state SQ, the initial state, and 
special states 5+, the accepting state, and s_, the rejecting state. We assume 
that S05-S+, and s_ are pairwise distinct. The action or behaviour of M in 
a situation depends on the current state of M and on the symbol currently 
being scanned by the head. It is given by Instr(M), the set of instructions of 
M. Each instruction has the form 
(*) 
sa -^ s'hh 
where 
— s^s' £ State(M), s ^ s+, s ^ s-
— a, 6 G A U {a, blank} and (a = a iff 6 = a) 
-he 
{-1,0,1} , and if a = a then h ^ - 1 . 
The instruction (*) means: If you are in state s and your head scans a cell 
with symbol a, replace a by 6, move your head one cell to the left {h — —1), 
or to the right (/i = 1), or don't move (/i = 0); finally, change to state s'. 
A machine M is deterministic^ if for all s G 5 and a G A U {a, blank} 
there is at most one instruction of the form (*) in Instr(M). In order to 
emphasize that a machine is not required to be deterministic we sometimes 
call it 
nondeterministic. 
As usual, denote by A* the set of words over A and by A+ the set of 
nonempty words over A. Let w G A*, w = ai ... a^ with a^ G A. M is started 
with u \i M begins a computation (or run) in state 5o in the situation 

126 
7. Descriptive Complexity Theory 
head 
a 
ai 
a2 
blank 
The computation proceeds stepwise, each step corresponding to the execution 
of one instruction of M. The machine stops when it is in a state s scanning 
a symbol a G A U {a, blank} such that there is no instruction of the form (*) 
in Instr(M). If then s = S4. we speak of an accepting run, and \i s — S- of a 
rejecting run. M accepts u if there is at least one accepting run of M started 
with u, and M rejects u if all runs started with u are finite and rejecting. 
Subsets of A+ are called languages. A language L C A+ is accepted by M 
if for alli/G A+, 
M accepts u 
iff 
u e L. 
L is decided by M if, in addition, 
M rejects u 
iff 
u ^ L. 
Clearly, if M decides L then M accepts L. L is said to be decidahle if it is 
decided by some deterministic Turing machine, and acceptable or enumerable 
if it is accepted by some nondeterministic Turing machine. 
For a function / : N —)• N we say that M is f time-bounded, if for all 
it G A+ accepted by M there is an accepting run of M started with u which 
has length at most f{\u\) (recall that \u\ denotes the length of the word u). 
And M is f space-bounded, if for all w G A+ accepted by M there is an 
accepting run which uses at most f{\u\) cells before stopping. 
Denote by N[a:] the set of polynomials with coefficients from N. A lan-
guage L C A+ is in PTIME ("polynomial time") or in PSPACE ("polynomial 
space"), if it is accepted by a deterministic machine that is p time-bounded 
or p space-bounded, respectively, for some polynomial p G N[x]. The classes 
NPTIME ("nondeterministic polynomial time") and NPSPACE ("nondeter-
ministic polynomial space") are defined similarly, now allowing nondetermin-
istic machines. 
Immediately from the definitions one gets 
PTIME C NPTIME 
and 
PTIME C PSPACE C NPSPACE, 
and one can show that 
NPTIME C PSPACE 
and 
PSPACE =: NPSPACE. 
Hence, 
PTIME C NPTIME C PSPACE (= NPSPACE). 

7.2 Turing Machines and Complexity Classes 
127 
Let A = {a, b} and L := {u £ A^lu contains an even number of a's}. One can 
easily design a machine that accepts L and is time-bounded by the polynomial 
X + 2: the head just runs over the string, the state being "even" or "odd" 
depending on whether the number of a's already scanned is even or odd, 
respectively. Essentially, this machine does not need any "working space" but 
only the space for the input. In order to measure only the working space and 
to introduce complexity classes like LOGSPACE and NLOGSPACE, where 
the working space needed is smaller than the input space, it is convenient to 
separate the input and to introduce machines with an input tape and a work 
tape. For other purposes it might be useful to introduce several input tapes 
and several work tapes, maybe also (if calculating a function, for example) 
one or more output tapes, with a head for each tape, where the heads can 
move independently of each other. It turns out that the definition of the 
usual complexity classes does not depend on the number of tapes or on other 
pecuharities such as the form of the tape, i.e., whether it is unbounded to 
both sides or not. We shall often use this robustness, choosing, for example, 
the number of input and work tapes according to needs and to convenience. 
7.2.1 Digression: Trahtenbrot's Theorem 
We have already remarked that first-order logic, when restricted to the finite, 
does not admit a complete proof calculus. In the following we give a proof of 
Trahtenbrot's Theorem which immediately implies this fact. 
Fix an alphabet A. It is well-known that it is not decidable whether a 
deterministic Turing machine M accepts the empty word, by short, whether 
M halts ("Undecidability of the Halting Problem").^ We use this result to 
show for a certain vocabulary a (A): 
Theorem 7.2.1 (Trahtenbrot's Theorem) Finite Satisfiability is not de-
cidable, that is, the set 
Sat[cr(A)] := {(p \ (p is a sentence o/FO[cr(A)] satisfiable in the finite} 
is not decidable. 
Proof. We assign, in an eff"ective way, to every deterministic machine M over 
A a sentence (fM of FO[o-(A)] such that 
(*) 
(pM is satisfiable in the finite iflF M halts. 
This gives the claim by the result just mentioned. Without loss of generality 
we may restrict ourselves to deterministic Turing machines M whose set 
of states is an initial segment {0,..., SM} of the natural numbers, SQ := 0 
being the initial state and 1 the accepting state, and which stop only in the 
accepting state. We number the cells of the tape as indicated by 
^ More exactly: One encodes Turing machines M in some natural way as words 
WM- Then the language {WM \ M halts} is not decidable. 

128 
7. Descriptive Complexity Theory 
a 
0 
1 
In particular, the number 0 is given to the virtual cell. If the machine M 
makes at least n steps, we let Cn denote the n-th configuration. Cn contains 
the following data: the state, the number of the cell scanned by the head, 
and the tape inscription after n steps. 
Let To = {<,5', min, max} be the vocabulary for orderings. In the follow-
ing we sometimes write 0 instead of min. In addition to the symbols of TQ 
the vocabulary a (A) contains relation symbols State (binary). Head (binary), 
and for every a G A U {a, blank} a binary relation symbol Letter^. 
For every natural number n > SM (recall that { 0 , . . . , S M } is the set 
of states of M) we define a structure An with universe {0, . . . , n } , which 
reflects the initial segment Co,..., Cn of the computation of M started with 
the empty word (however, only Co,..., C^ with k < n ii M stops after k 
steps). For s,t < n, 
State^^ s t 
iflF 
according to Ct the state is s 
Head^^it 
iff 
according to Ct the head is in cell i 
Letter^" z f 
iff 
according to Ct the letter a is in cell i. 
The sentence cpM will have the properties (a) and (b) which immediately give 
the equivalence (*) stated above: 
(a) If M, started with the empty word, stops after k steps (in the accepting 
state) and n > SM, k, then An \= ^M-
(b) If v4 is a finite model of ^M and M, started with the empty word, runs 
at least k steps, then \\A\\ > k. 
As ifM we take the conjunction of the {<,5, min,max}-ordering axioms to-
gether with the conjunction of the sentences in (l)-(4) (where we write 0 for 
min, 1 for the successor of min, etc.): 
(1) "The universe has at least SM + 1 elements." 
(2) State 0 0 A Head 0 0 A Letter^ 0 0 A \fx{-^x = 0 -^ Letterbiank x 0) 
(at time 0 the state is 0, the head scans the virtual cell, the virtual cell 
contains a, and all other cells are empty). 
(3) For each instruction sa -> s'bh a. conjunct ifsa^s'bh^ which describes the 
changes due to this instruction. For example, if /i = 0 then (psa^s'bh is 
the sentence 
V^V^((Statesi A Heady^ A Letteia yt) 
-^ 3t'{Stt' 
A States'*' A Heady *'A Letter^,?/*' 
A\/v{^v = y ^ 
A 
(Letterat;* -> Letter a vt')))). 
a€AU{Q:,blank} 

7.2 Turing Machines and Complexity Classes 
129 
We leave it to the reader to write down the sentence ^sa^s'hh for /i = —1 
and h — 1. 
(4) 3t State 11 
(the accepting state is reached). 
D 
Coding (T(A)-structures by graphs (cf. 11.2.5), one obtains from the un-
decidability of Sat[cr(A)], that for a binary relation symbol E the set 
Graph-Sat 
:= 
{^\^ 
is an FO[{£J}]-sentence satisfiable in a finite graph} 
is not decidable. Hence, for any vocabulary r containing an at least binary 
relation symbol, the set 
Sat[r] 
:= 
{y? | (/? is an FO[r]-sentence satisfiable in the finite} 
is not decidable. 
Clearly, there is a decision procedure that, for any finite structure A whose 
universe is a set of natural numbers and for any first-order sentence (y?, checks 
whether A\= ^. Since ip is satisfiable in the finite iff there is a model A of 
Lp with A — {0,..., n} for some n, we can use this decision procedure to 
enumerate Satfr]. Together with Trahtenbrot's Theorem this shows: 
Theorem 7.2.2 Ifr contains an at least binary relation symbol then the set 
Val[T] 
:= 
{if G FO[r] \ if is a sentence valid in all finite structures} 
of sentences valid in all finite structures is not enumerable. 
Proof. For any sentence ^p we have 
(-h) 
^ i Sat[r] 
iff 
-(^ G Val[r]. 
If Val[r] would be enumerable, then by (-h), FO[r]\ Sat[r] would be enumer-
able, too. This would lead to a decision procedure for Sat[r] (contradicting 
Trahtenbrot's Theorem): Given a sentence 9?, start enumeration procedures 
for Sat[r] and FO[r] \ Satfr] until one of them yields ^. 
D 
Now we have the negative result concerning the proof calculus: If there 
would be a complete proof calculus for first-order logic in the finite, we could 
effectively enumerate all possible formal proofs and hence, also the sentences 
valid in the finite, contradicting Theorem 7.2.2. 
7.2.2 Structures as Inputs 
We fix the conventions which allow to regard finite structures as inputs to 
Turing machines. Note that, in general, structures are abstract objects and 
the same holds for their elements, so that there is no canonical way of repre-
senting structures by strings (or by sequences of strings). If the same structure 

130 
7. Descriptive Complexity Theory 
has different representations, the machine should produce the same answer 
on all the representations. We postpone this problem and first make life easier 
by restricting our attention to ordered structures. Recall the definition (cf. 
1.A2): 
Definition 7.2.3 Let {<} C TQ C {<, 5, min, max} and TQCT. A r-struc-
ture A is ordered if the reduct A\TO is an ordering (that is, <^ is an ordering 
and 5, min, and max, if present, are interpreted by the successor relation, the 
least and the last element of the ordering, respectively). 0[T] is the class of or-
dered T-structures. If ^ is a sentence in the vocabulary r, ordMod(^) denotes 
the class of ordered models ofip, or equivalently, ordMod(^) = Mod{ip Aipo)^ 
where I/JQ is the conjunction of the ordering axioms for the vocabulary TQ. D 
Let A G 0[r] be an ordered structure with \\A\\ = n. By passing to 
an isomorphic copy we can assume - and always will tacitly do so - that 
A = {0,...,n — 1} and that <'^ is the natural ordering on this set; that is, 
we identify or "label" the least element of <^ in ^ with 0, its successor with 
1, etc.^ 
Suppose r = TOUTI, say ri = {Ri,... 
,Rk,ci,... 
,ci} (when writing ri 
in this way we tacitly assume that the symbols in TI are given in the order 
i?i,..., i?jfe, ci,..., Q), and TQ as in the preceding definition. 
A Turing machine for r-structures will have 1 + A: + / input tapes and m 
work tapes for some m > 1. All tapes are bounded to the left and unbounded 
to the right. Their cells are numbered as indicated by^ 
a 
- 1 
The "virtual" cell is numbered by —1 and always contains the virtual letter 
a. All input tapes will contain an input word followed by the virtual letter uj 
indicating the end of the input word. Each tape has its own head. The heads 
can move independently of each other. Those on input tapes are read-only 
heads (i.e., they do not change the scanned letter), while those on the work 
tapes are read-and-write heads. The alphabet only contains the symbol "1". 
Moreover, we identify "0" with "blank"; thus during a computation almost 
all cells contain 0. 
^ By this convention, for isomorphic .4, B G C^[r] a Turing machine M started with 
A will have the same input inscriptions as M started with B. 
'^ For the purposes of the next sections this numbering is more appropriate than 
that of the section on Trahtenbrot's Theorem, where we numbered the virtual 
cell by 0. 

7.2 Turing Machines and Complexity Classes 
131 
With an ordered r-structure A we associate the following input inscrip-
tions on the 1 -I- A; -I- / input tapes (numbered from 0 to A: + 0^ The 0-th tape, 
the "universe tape", contains a sequence of I's of length n := \\A\\, 
a 
1 
1 
1 
(jj 
1 
0 
n - 1 
n 
For I < i < k, the i-th input tape contains the information about R := Ri 
coded as follows: Suppose R is r-ary, that is, R^ C {0,..., n—iy. 
Of course, 
||{0,... , n - l } ^ | | = n^. Then, for j < n^, the j-th cell will contain "1" just in 
case the j-th r-tuple in the lexicographic ordering of {0,..., n — 1}^ is in R. 
More formally: For j < rf ^ let \j\r be the j-th. r-tuple in the lexicographic 
ordering of {0,... ,n — 1}^, i.e., look at the unique n-adic representation of 
h 
j = ii • n'"'^ + J2 ' n"""^ + ... -h jr-i -n + jr with 0 < ji < n, 
and set \j\r := (ji,..., jV)- (If ^ is not clear from the context, we write iJl'^t 
instead of |j|r.) Then the i-th input tape has the inscription 
a 
ao 
ai 
Ci2 
as 
aw-i 
CO 
1 
0 
n ^ - 1 
n' 
where 
(and hence, aj = 0 iff not 
R^\j\r). 
iff 
R^\j\r 
For 1 < i < /, the {k + i)-th input tape contains the binary representation of 
j := cf without leading zeros. 
We say that a Turing machine M is started with A, if the input tapes contain 
the information on A in the way just described, the work tapes are empty, 
and each head scans the cell numbered 0 of its tape. As in the case of one-tape 
machines, M has finite sets State(M) of states and Instr(M) of instructions. 
State(M) contains an initial (or starting) state SQ, an accepting state s+, and 
a rejecting state s_. Instructions now have the form 
(*) 
sbo... 
hk+i ci.. .Cm ^ s'c[ ...C'^HQ... 
hk+i+m 
with the meaning 

132 
7. Descriptive Complexity Theory 
If you are in state s, your heads scan 60,..., bk+i on the input tapes 
and ci,..., Cm on the work tapes, replace ci,..., c^ by c j , . . . , c'^, 
move the i-th head according to hi and, finally, change to state s'. 
Here, s,s' G State(M), 6o,...,6fe+z G {0,1,a,cj}, ci,...,Cm, ci,...,c;^ G 
{0,1, a}, and ho,..., 
hk+i+m ^ {-1,0,1}. Moreover, 
— if bj = a then hj ^ —1 
(if the head scans the leftmost square it cannot move left) 
— if bj = LO then hj ^ 1 
— if Cj = a then hk+i+j 7^ — 1 and Cj = a 
— if c^ G {0,1} then 4 G {0,1} 
— s 7^ s+ and s ^ S-. 
The 6a5e of the instruction in (*) is given by 
sbo...bk+iCi 
...Cm-
M is said to be deterministic, if no two distinct instructions in Instr(M) have 
the same base. Sometimes, to emphasize that we do not require a machine 
to be deterministic, we speak of a nondeterministic machine. 
The notions of accepting run, rejecting run, and of "M accepts ^ " are 
adapted from section 7.2 in the obvious way. For a function / : N —)- N 
we say that M is f time-bounded, if for any A accepted by M there is an 
accepting run of M, started with A, of length at most /(||A||). And M is f 
space-bounded, if for all A accepted by M there is an accepting run which 
uses at most /(|m|) squares on each work tape before stopping. 
Let K he a. class of ordered r-structures. M accepts K ii M accepts 
exactly those ordered r-structures that lie in K. For classes of structures 
the definitions of PTIME ("polynomial time"), NPTIME ("nondeterminis-
tic polynomial time"), PSPACE ("polynomial space") are introduced in the 
obvious way. For example, 
— K is in PTIME iff there is a deterministic machine M and a polynomial 
p G N[a?] such that M accepts K and M is p time-bounded. 
And we define 
— if is in NLOGSPACE, "nondeterministic logarithmic space" (LOGSPACE, 
"deterministic logarithmic space") iflF there is a (deterministic) machine M 
and d>l 
such that M accepts K and is d-log space-bounded (log n stands 
for the least natural number > log2 n). 
Exercise 7.2.4 Denote by 1{A) the sum of the lengths of the input words 
on the input tapes of a machine started with A. Show that in the definitions 
of the complexity classes mentioned above we can replace m|| by 1{A). 
• 

7.3 Logical Descriptions of Computations 
133 
At the end of section 7.1 we have observed that for a class K of ordered 
structures and m > 1 the class 
Km := M e J^ I ||A|| > m} 
is axiomatizable in a logic £ iff i^ is axiomatizable in C. Analogously, for any 
of the complexity classes C introduced so far, we have 
K G C 
iff 
Km^C 
(since we can change a machine, without essentially effecting its time and 
space bounds, in such a way that it runs on a given finite set of inputs in 
a prescribed form; cf. Exercise 7.2.5 below). We give an application of this 
fact. Suppose that K is in PSPACE. Then K2 is in PSPACE, too, say, it 
is accepted by a machine M that is q space-bounded, where q{x) = agX^ + 
as-ix^~^-\-.. 
. + aix-\-ao. For suitable d, q{n) < n^ for all n > 2. Thus M is x^ 
space-bounded. These observations will allow us to restrict ourselves to monic 
polynomials p{x) = x'^ when considering PSPACE (or PTIME, NPTIME). 
Exercise 7.2.5 For fixed r and m > 1 there is c^ G N such that for any 
K C 0[T] and any / : N -> N: 
(a) If i^ is accepted by an / time-bounded machine, then Km is accepted by 
an / -I- 2-(m 4- 1) time-bounded machine, where / + 2-(m -f- 1) denotes 
the function whose value for n is /(n) -|- 2-(m + 1). 
(b) If Km is accepted by an / time-bounded machine, then K is accepted by 
an / -i- c^ time-bounded machine. 
(c) K is accepted by an / space-bounded machine iff Km is accepted by an 
/ space-bounded machine. 
D 
7.3 Logical Descriptions of Computations 
Let K be a class of ordered r-structures, K C 0[T\. We write K G IFP if K 
is axiomatizable in FO(IFP), and use similar notations for the other logics. 
Our main goal is to show 
K G LOGSPACE 
iff 
K e DTC 
K G NLOGSPACE 
iff 
K G TC 
K G PTIME 
iff 
K G IFP 
K G NPTIME 
iff 
K eT.\ 
K G PSPACE 
iff 
K e PFP. 
(Sj denotes the fragment of second-order logic consisting of the sentences of 
the form 3 X i . . . 3X^-0 where V' is first-order, cf. section 3.1). 
These results provide the bridge between logic and complexity theory 
we have aimed at, by relating purely machine-oriented characterizations and 

134 
7. Descriptive Complexity Theory 
characterizations by means of logical definability. Section 7.5 exemplifies the 
methodological possibilities they offer. 
In this section we prove the implications from left to right; the other 
implications will be settled in the next section. 
Let C be one of the complexity classes above and C the logic associated to C 
by the corresponding equivalence. Assume that K G C, and let M be a Turing 
machine witnessing that K e C. We are going to describe the behaviour of 
M by a formula (pM of JC in such a way that for any ordered structure A, 
A 1= (pM 
iff 
M accepts A 
and hence, 
K = ovdMod(ipM)-
The reader familiar with classical recursion theory will observe the analogy 
of the proofs given below with usual proofs showing the )L^-recursiveness of 
Turing computable functions. There, the transition from one configuration 
to the next is coded by "simple" (e.g. primitive recursive) functions, and the 
/x-operator is used to detect the end of a computation. Similarly here, using 
the ordering relation, we can describe the transition from one configuration to 
the next by means of a "simple" logic, mostly first-order logic. The additional 
expressive power, for example the operator IFP, is used to find out whether 
the computation stops and to get its outcome. In recursion theory the proof 
of the equivalence shows that one application of the /x-operator suffices. Sim-
ilarly we shall obtain, say, that every formula of FO(IFP) is equivalent to a 
formula with only one occurrence of IFP. 
For the following we fix a vocabulary r = TQUTI where, for simplicity, we 
assume that TQ = {<,5, min, max} and TI is relational, ri = {Ri,... 
,Rk} 
with Tj-ary Ri. For convenience we set ro = 1. 
A Turing machine M for r-structures has 1 -I- A; input tapes and a certain 
number m of work tapes. In order to describe computations that M performs 
when started with a structure, we introduce configurations which contain the 
relevant data of possible situations of a computation. These data are: 
— the current state 
— the current inscriptions of the work tapes 
— the current position of the heads on both the input and the work tapes. 
An accepting configuration is a configuration with state s+. A configuration 
CONF' is said to be a successor of the configuration CONF, if an instruction 
of M allows M to pass from CONF to CONF' in one step. For convenience, 
we extend this definition by saying that any accepting configuration is a 
successor of itself. If M is deterministic then every configuration has at most 
one successor. 
Let M be a (nondeterministic) Turing machine for r-structures which is 
x^ space-bounded, that is, if M accepts an ordered structure A, then there 

7.3 Logical Descriptions of Computations 
135 
is an accepting run that scans at most n^ squares on each work tape, where 
n := \\A\\. We may assume that ri < d for i — 1,... ,k {ri being the arity of 
Ri). Fix a structure A. By the remarks at the end of the last two sections 
when proving that a class of structures is axiomatizable in a logic or ac-
ceptable by a Turing machine of a certain complexity bound, we can restrict 
ourselves to sufficiently large finite structures. Here we look at structures A 
such that for n := \\A\\ we have n > k+m and n > ||State(M)||. We assume 
that State(M), the set of states of M, is an initial segment of the natural 
numbers and that SQ = 0 is the starting state. 
Let CONF be a configuration, where at most the n^ first cells of each work 
tape are not empty and where the heads scan one of these cells. A first at-
tempt to code the contents of these cells could consist in dividing the relevant 
d 
part of each work tape into j ^ j ^ =: r blocks of length log n and reading each 
block as a natural number < n in binary representation. This would require 
variables xi,... 
,Xr for each tape. Then a formula bearing the information on 
successive configurations would contain at least the variables xi,... 
,Xr and 
would, therefore, depend on the cardinality n of the universe. We overcome 
this difficulty for PTIME, NPTIME, and PSPACE by using relation variables 
instead of individual variables. 
To code the data of CONF we first introduce the "state relation" ST^^^^, 
the "end-of-tape relations" E ^ ^ ^ F ^ ^^le "head relations" H^^^^, and the "in-
scription relations" I^^^^. The last ones are only introduced for the work 
tapes, since the inscriptions of input tapes are given by the input structure 
and kept fixed during the whole computation. We introduce: The unary re-
lation 
grpCONF _ 1^1 ^^^^^ ^ .g ^^^ g^^^g ^f CONF; 
for 0 < j < A: -1- m, the unary 
if the j-th head faces a 
gCONF _ 
J 1^ _^^ 
.£ ^j^g j_^Yi head faces uj 
otherwise; 
for 0 < J < A:, the r^-ary' 
jjCONF ._ ||e|^^. I 0 < e, the j-th head scans the e-th square 
and this does not contain u}; 
for k + 1 < j < k -\- m, the d-ary 
jjCONF ._ {|e|^|0<e, the j-th head scans the e-th square}; 
for A: -h 1 < j < A: -I- m, the d-aij 
^ Recall that \e\rj is the rj-tuple given by the n-adic representation of e and that 
the square containing a is numbered —1. 

136 
7. Descriptive Complexity Theory 
jCONF .^ {|e|d I 0 < e < n^ and the e-th square of the 
j-th work tape contains the symbol 1}. 
Obviously, CONF is uniquely determined by these relations. The starting 
configuration CONFQ, for example, is given by 
g^CONFo ^ |Qj^ gCONFo ^ g^ jjCONFo ^ {(Q^ _ 
Q)}^ ^ ^ J I^ONFO = 0_ 
For technical convenience we encode CONF in a single {d + 2)-ary relation 
^CONF g {0,... ,n —1}^+^ by joining the preceding relations as follows (we 
add two first coordinates to distinguish these relations and fill up with zeroes 
in the middle to get arity (d + 2)):^ 
CONF 
(^CONF 
_ 
{(0,0)}x{0}xST 
U 
U 
{(l,i)}x{0}xE^coNF 
0<j<k+m 
U 
U 
{(2,i)} X {0} X HCONF 
0<j<k+m 
U 
U 
{(3,i)}xlCONF 
k+l<j<k+m 
Clearly, given C C {0,... ,n —1}^+^, we can easily decide whether there is 
a configuration CONF of M, where only the first n^ cells of each work tape 
are relevant, such that C = C^^ONF^ ^^ ^^ ^^ shortly say, whether C is an 
n^-bounded configuration. 
The following lemma now states how the behaviour of M can be described 
by suitable formulas. 
Lemma 7.3.1 Let M be a Turing machine which is x^ space-hounded. There 
is a first-order formula v?start(^) ^^^ there are first-order formulas v^succ(^5 X) 
and ipsucc{X,Y) {more precisely, second-order formulas without second-order 
quantifiers) such that for all sufficiently large A G 0[T] and a G A^+^ we 
have: 
(a) Vstart(^) describes the starting configuration'\' If Co denotes the starting 
configuration of M started with A then 
^N^start[a] 
iff 
aeCo. 
(b) Vsucc(^,-^) describes the successor of X": If M is deterministic and C 
is an n^-bounded configuration of M (where n := \\A\\) then 
A \= (/?SUCC[Q^5 C] iff C has an n^-bounded successor C and a E C. 
^ By 0 we denote constant sequences 0 ... 0 of appropriate length; in general, c will 
denote a sequence of the form c.. .c. 

7.3 Logical Descriptions of Computations 
137 
(c) "ipsucc{X,Y) expresses that Y is a successor of X": If Ci is an un-
bounded configuration of M and C2 a further {d + 2)-ary relation on A 
then 
A 1= '4^s\xcc[Ci^C2\ iff 
C2 is an n^-hounded configuration of M 
which is a successor of Ci. 
We postpone the proof of this lemma and first draw some consequences. 
Theorem 7.3.2 Let K C. 0[T\ he a class of ordered structures. If K is in 
PSPACE then K is axiomatizahle in FO(PFP). 
Proof Let M be a deterministic machine witnessing K G PSPACE. By pre-
vious remarks we can assume that M is x^ space-bounded for suitable d. We 
set 
(f(x,X) 
:= {-i3yXy A ifst^rtix)) V {3yXy 
A(psuccix,X)), 
where (/?start and (/?succ are the formulas assigned to M in the preceding lemma. 
Let A be an ordered structure and n := \\A\\. By this lemma, FQ , F^, F2 ,... 
is the sequence 0, Co, Ci,... where 
— Co is the starting configuration 
— if Ci is an n^-bounded configuration of M with an n^-bounded successor 
configuration C then C^+i = C. In particular, if Ci is accepting then 
Ci = Ci-^i = Cj+2 • • • 
— if Ci is an n^-bounded configuration without a successor configuration or 
with a successor configuration which is not n'^-bounded, then Cj+i = 0, 
Ci+2 = Co, Ci+s = Ci,..., that is, the sequence has no fixed-point. 
Summarizing, we have 
M accepts A 
iff 
F^ is an accepting configuration 
iff 
F^ is a configuration with state s+. 
"F^ is a configuration with state s+" is expressed by the formula (recall the 
SXCONF_p^rt^f^CONF) 
3y{'^y is the s+-th element of <" A [PFP^,x^]niinminminy).^ 
We abbreviate it by [PFP^^x^] niinminmins+. Then, 
Ae K 
if[ 
M accepts A 
iff 
^1= [PFP^^x y^] min min min s+, 
that is, K = ordMod([PFP^,xV^]niinminmins+). 
D 
Compare footnote 6. 

138 
7. Descriptive Complexity Theory 
Corollary 7.3.3 Let K C 0[T] be in PSPACE. Then K is axiomatizable by 
a sentence o/FO(PFP) with only one occurrence o/PFP. 
D 
We now turn to PTIME and will realize that we can do better. Whereas ac-
cepting runs of polynomially space-bounded machines may have exponential 
length, we here only have to consider runs of polynomial length. This enables 
us to code the whole run into a single relation which can be obtained as the 
fixed-point of an inflationary process. On the logical side we therefore can 
replace PFP by IFP. 
Consider a (finite or infinite) run Co, Ci,... of an x^ time-bounded (and 
hence, x^ space-bounded) deterministic machine started with a structure of 
cardinality n. If the run accepts the structure, C^d-i must be an accepting 
configuration. The inflationary process indicated above is given by a formula 
(p{v, X, Z) with 
m < i 
m < n'^ 
Cm defined 
Cm defined 
that is, we use the first d coordinates as time stamps when coding the run in 
one relation (as above, \m\d denotes the m-th tuple of {0,... ,n - 1}^ in the 
lexicographic ordering). 
Theorem 7.3.4 Let K <Z 0[T\ be a class of ordered structures. If K is in 
PTIME then K is axiomatizable in FO(IFP). 
Proof. Let M be a deterministic machine witnessing K G PTIME. We can 
assume that, for suitable c?, M is x^ time-bounded. For v = VQ ... Vd-i we set 
ip{y,x,Z) 
:- 
{v-m\n^^^t^^t{x))y3u{S'^uv^ipsncc{x,Zu-)). 
Here, v — min abbreviates VQ = min A ... A Vd-i = min; S^uv stands for 
"?; is the successor of u in the lexicographic ordering", and v^succ (^, Zu-) 
is obtained from </Psucc(^5^) by replacing subformulas XJ by ZWt. Then we 
have for A € 0[T] with n := P | | : 
AeK 
iff 
M accepts A 
iff the (n'^ —l)-th configuration of M, started 
with A^ is defined and has state 5+ 
iff 
^ 1= [IFPt7^,^(/?]ma3cminminmins+, 
that is, K is the class of ordered models of a sentence of FO(IFP). 
D 
Corollary 7.3.5 Let K C 0[T\ be in PTIME. Then K is axiomatizable in 
FO(IFP) by a sentence with only one occurrence o/IFP. 
D 
It is now easy to extend the previous result to NPTIME. 

7.3 Logical Descriptions of Computations 
139 
Theorem 7.3.6 Let K C 0[T\ he a class of ordered structures. If K is in 
NPTIME then K is axiomatizable in SO by a Til-sentence. 
Proof. Choose M witnessing K G NPTIME and assume that M is x^ time-
bounded. Then, for A G 0[T] with n := \\A\\, 
A e K 
iff 
there is a run of M, started with A, of length < n^ that 
accepts A 
iff 
there is a sequence Co,..., C^d_i of n^-bounded 
configurations of M, started with A, such that Co is the 
starting configuration, C^+i is a successor configuration 
of Ci, and s+ is the state of C^d-i 
iff 
A\=ip, 
where ^p is the sentence (the intended meaning of the second-order variable 
Z being 
U {\m\d} x Cm): 
V? := 3Z(Vx(Zmin^ f^ 9^start(^)) A \/it^v{S^uv 
-^ xpsucc(Zu-, Zv-)) 
A Zmax min min min s+). 
D 
We now come back to a proof of the key lemma 7.3.1. 
Proof (of 7.3.1). Let M be an x^ space-bounded machine for r-structures. 
Recall the specific coding of an n^-bounded configuration CONF in a sin-
gle relation C ^ ^ N F comprising relations ST^^^^, E^ONF HCONF^ ^^d I^^ONF 
that contain the information on the state, the endmarks, the head positions, 
and the inscription of the work tapes. Let 'x be the sequence of variables 
xyxi 
...Xd-
For (a) we can set 
V^start(^) 
:= 
^ = 0 
"the state is SQ" 
\/{x = 2/\0<y<k-\-mf\xi...Xd 
= ^) 
"the heads scan 
the 0-th cell" 
where, for example, () < y < k -\- m means that y is equal to or less than 
the (A:-|-m)-th element in the ordering < and 0 stands for min. Also in the 
following we shall use such self-explanatory abbreviations. 
For parts (b) and (c) we first introduce, for every instruction instr G 
Instr(M), 
instr = s6o ... hk+iCi ...Cm-^ 
s'c[ ...C'^HQ... 
hk+i+m, 
a formula 9:?instr(^, ^ ) which for n'^-bounded configurations X expresses 

140 
7. Descriptive Complexity Theory 
"X has base sbc, and if the successor configuration according to 
instr is not n^-bounded, then {x \ (finstvix^X)} 
= 0, otherwise 
{x I (/^instr(^,-^)} is this successor configuration". 
Moreover, we need a formula 9:?acc(-^) which for n^-bounded configurations 
X expresses 
"X is an accepting configuration". 
Using (^instr(^, X) and (/^accC^), we get the desired formulas (/?succ and V'succ 
of parts (b) and (c) as (recall that we agreed to set Cm+i = Cm for accepting 
configurations Cm) 
iPsucc{x,X) 
: = 
{LPS,CC{X) 
A XX) 
V 
\/ 
(Pmstr{x,X), 
instr G instr(M) 
and 
^succ(X, Y) 
:= 
(ip^cc(X) A \/x(Yx ^ Xx)) V 
y 
(3x (finstrix, 
X) AWiYx 
^ 
V^instr (^,-^ ) ) ) • 
instr e instr(M) 
It remains to give ^instr(^,-^) and (ps,cc{X). We set 
V^acc(X) 
:= 
X0005+. 
The formula v^instr(^, ^ ) has the form 
^ i n s t r ( ^ , X ) 
: = 
^,^1^^{X) 
A </?,.,e',7^(^'^)' 
where, for an n^-bounded configuration X, the formula ^sbci-^) 
expresses 
"X has base s,6,c", 
and ifg, -, j^{x,X) 
expresses 
"if the successor F of X according to s',c',h is not n^-bounded then 
{x I v,,_,,_s(s,X)} = 0, else {x \ ^^,-^,^Ti(x,X)} = K". 
For easier reading of the formulas below we introduce the following abbrevi-
ations: 
ENDMARK yz := XlyOz 
"the y-th head faces the endmark z" 
(which is 0 for a and n —1 for uj) 
HEAD yz := X2ybz 
"the ^-th head is on position \z\" 
ONE y^ := XSy^ 
"the y-th. work tape contains 1 on 
position 1^1". 
Now we take as (/?^ ^- (X) the conjunction of 

7.3 Logical Descriptions of Computations 
141 
XOOOs 
"s is the state" 
A ENDMARKimin A A ENDMARK (A:+j) min 
bj=oc 
Cj—a 
"heads at the left end of a tape" 
A 
ENDMARKjmax 
bj=U! 
"heads at the right end on input tapes" 
A 
^Xi . . . 3Xrj ( H E A D jOxi 
. . . Xrj A RjXi 
. . . Xrj ) 
bj = l 
"heads of input tapes facing a 1" 
A 
3 x i . . . 3Xrj ( H E A D jOXi . . . Xrj A ^RjXi 
. . . Xrj ) 
bj=0 
"heads of input tapes facing a 0" 
A 3xi... 
3xd (HEAD {k-\-j)xi ...Xd A ONE {k+j)xi 
...Xd) 
"heads of work tapes facing a 1" 
A 3xi... 
3xd (HEAD {k+j)xi ...Xd A -lONE {k+j)xi 
...Xd) 
"heads of work tapes facing a 0". 
Finally, we take as ip^, -, ^ (x, X) the conjunction {ipi A (/?2), where (/?i is 
A 
-iHEAD jmax 
k+l<j<k+m 
"heads of work tapes moving to the right do not face the 
(n^ —l)-th square" 
and where (p2 is the disjunction of 
[x = y = 0 A xi ... Xd-i =0 A Xd = s') 
"s' is the new state" 
V 
(^HEAD jxi ...Xd A ONE jxi .. .Xd A x = S A y = j) 
k+l<j<k+m 
"work tape content unchanged on squares not scanned" 
V (HEAD jxi...Xd 
A X = 3 A y = k + j) 
"new content 1 on scanned squares of a work tape" 
V (ENDMARK jO A x = 2 A y = j A Xi .. .Xd = 0) 
"heads scanning a and moving to the right come to position 0" 
V (ENDMARK jO A x = 1 Ay = j A Xi.. .Xd =^0) 
"unchanged position of heads facing a" 

142 
7. Descriptive Complexity Theory 
V 
(ENDMARK jmax Ax ^ 2 A y = j A xi ...Xd-r^ = 0 
A Xd-vj+i . ..Xd = max) 
"heads scanning uj and moving to the left come to position n^^—1" 
V (ENDMARK j max Aa: = l A ^ = j A a : i . . . Xd-i =0 A Xd = max) 
"unchanged position of heads facing a;" 
V 
(HEAD j6 A x = l A y = j A xi...Xd 
= 0) 
"heads scanning a from their new position" 
V (HEAD jQmax.. .max Ax = 1 A y = j A Xi ...Xd-i 
= 0 
hj^l 
rJ-times 
Axd = max) 
"heads of input tapes scanning uj from their new position" 
V 
3^1.. .3ud{^^xi .. .Xd — ui .. .Ud + h/^ A HEAD jui.. 
.Ud Ax — 2 
j<k+m 
A2/ = i) 
"new head position of heads on 'interior' squares." 
D 
We come to the corresponding results for LOGSPACE and NLOGSPACE. 
Recall that K G NLOGSPACE means that there is a (nondeterministic) 
machine M and some d > 1 such that M accepts K and is d-log space-
bounded. Every natural number i < n codes a word over {0,1} of length 
logn, namely its binary representation |i|wj^ of length logn. Thus, using d 
variables, we can represent the relevant contents of a work tape. Moreover, by 
restricting ourselves to sufficiently large structures A, we can assume that d • 
logn < n (where n := \\A\\). Hence, each head position can be represented by 
a single number < n. Altogether, we can describe the data of a configuration 
by a sequence of natural numbers < n of length independent of n, where we 
agree to use the first number to represent the state. The exact definitions will 
be given later when proving the following lemma. 
Lemma 7.3.7 Let M be d - log space-bounded. Then there are formulas 
Xstart(^) of FO and Xsucc(^5^0 o/FO(DTC) such that for all sufficiently 
large A £ 0[T] and a in A, 
(a) A 1= Xstart[tt] iff o. is the {description of the) starting configuration. 
(b) For any {d-log \\A\\)-bounded configuration a and any b, 
^ 1^ Xsucc[^5 
b] iff 
b is a {d-log\\A\\)-bounded successor 
configuration of a. 
Before we give a proof we derive some consequences. 
Theorem 7.3.8 Let K C 0[T] be a class of ordered structures. If K ^ 
LOGSPACE then K is axiomatizable in FO(DTC). 

7.3 Logical Descriptions of Computations 
143 
Proof. Let M be a deterministic machine witnessing K G LOGSPACE, say, 
M is d-log space-bounded. Let Xstart and Xsucc be the formulas corresponding 
to M according to the preceding lemma. Then, by (a) and (b) of this lemma, 
we have for A^ 
^H^ 
M accepts A 
iff 
there is a sequence ao, • • • 5^fc of (c^'log ||A||)-bounded configurations 
such that OQ is the starting configuration, a^+i is the successor 
configuration of ai, and au is an accepting configuration 
iff 
^ ^ 3^(Xstart(^) A 3x'{\Di:C-^;^>Xsncc{x,x')\xx' 
^X[ 
= S+)). 
Hence, K is the class of ordered models of a sentence of FO(DTC). 
D 
Theorem 7.3.9 Let K C 0[T\ he a class of ordered structures. If K e 
NLOGSPACE then K is axiomatizahle in FO(TC). 
Proof. Let M be a machine witnessing K E NLOGSPACE. Since M is non-
deterministic we just have to replace DTC by TC in the last proof. In fact, 
we have for A£ 0[T\ 
M accepts A 
iff 
^ ^ 3^(Xstart(^) A 3 ^ ' ( [ T C ^ , ^ ' X s u c c ( ^ , ^ ' ) ] ^ ^ ' A X'^ = S+)). 
Since FO(DTC) < FO(TC), we have obtained a sentence of FO(TC) axiom-
atizing K. 
D 
Denote by FO(posTC) the class of formulas of FO(TC) which only contain 
positive occurrences of TC, that is, each such occurrence is in the scope of 
an even number of negation symbols. In 8.6.12 we will see that FO(DTC) < 
FO(posTC). Thus the preceding proof yields 
Corollary 7.3.10 If a class of ordered structures is in NLOGSPACE then 
it is axiomatizahle by a sentence o/FO(posTC). 
D 
We turn to a proof of Lemma 7.3.7. As already remarked above, in the 
case of log space-bounded machines we code configurations not by relations 
but by numbers. This change requires to define some arithmetical functions 
and predicates in FO(DTC). The next two lemmas serve this purpose. 
Lemma 7.3.11 There are 
FO(DTC)-formulas 
^+{x,y,z), 
(pXx,y,z), 
(p2(x,y), and 
'/^log(universe) \X) 
such that for any ordered structure A with A = {0,..., ||A|| — 1} and any 
a,b,c e A, 
A\= (f+[a,b,c] 
iff 
a-\-b = c 
A\= ^.[a,b,c] 
iff 
a-b — c 
A^ip2[a,b] 
iff 
2^ = 6 
A \= V^log(umverse)M 
«# 
^ = 
iog\\A\\. 

144 
7. Descriptive Complexity Theory 
Proof. For better readability, instead of describing the natural numbers in 
terms of the ordering, we use constants 1, 2, 
Given numbers x and y, the path 
(0,x) -^ {l,x + 1) -^ {2,x -\- 2) ^ ... -^ {y,x + y) 
from (0, x) to (y, x + y) shows that as (fi+{x, y, z) we can take the formula 
{y = min ^z = x) V \pTCuv,u'v' {Suu' A Svv')] 
minxyz. 
Similarly, the path 
(0,0) -> {l,x) -^ (2,2.:r) ^ (3,3-rr) ^ ... -^ 
{y,yx) 
shows that we can set 
99.{x,y,z) 
:= 
(2/ = min Az = min) 
\/[DTCuv,u'v' {Suu' A^-^{v,x,v'))] 
mmmmyz 
and the path 
(0,l)-f 
( l , 2 ) ^ ( 2 , 4 ) ^ . . . ^ ( j ; , 2 ' ' ) 
shows that we can set 
^2{x,y) 
:= 
{x = mm Ay = 1) 
\/[DTCuv,u'v' {Suu' AipXv,2,v'))] 
min la:?/. 
Finally, let 
V^log(universe) 
{x) := -^3ycp2{x,y) A\/z{z <x-)^3yip2{z,y)). 
• 
Let / := logn — 1. Then 2^ < n. Recall that for m with m < 2^ and 
mo,..., mi-i G {0,1} we have 
|m|f = mo ... mi-i 
iff 
m = mo • 2^~^ + mi • 2^~^ + ... + mi-2 • 2 + m/_i. 
We then say that irik is the A:-th digit of |m|^. If n, and hence /, is clear from 
the context, we denote |m|^ by [m]. We write u for UQ .. .Ud and u < 2^ for 
Wo < 2^ A ... A lid < 2^; similarly with u',x, and ^'. 
Lemma 7.3.12 There are formulas of FO(DTC) which, in ordered struc-
tures A, define the following relations {where n = \\A\\, I = logn — 1) : 
One mk 
iff 
m < 2^, k < I, and the k-th digit of [m] is 1 
Zero mk 
iff 
m < 2^, k < I, and the k-th digit of [m] is 0 
One^ uk 
iff 
u < 2}, k < {d-\-l)-l, and the k-th digit of the 
concatenation [UQ] ... [ud] is 1 
Zerod uk 
iff 
u < 2^, k < {d-\-l)-l, and the k-th digit of the 
concatenation [UQ] ... [ud] is 0 
Equald uku' 
iff 
u,u' < 2^, k < {d-\-l)-l, and the words [UQ] ... [ud] 
and [U'Q] ... [u'^] differ at most at the k-th position. 

7.3 Logical Descriptions of Computations 
145 
We denote the corresponding formulas by ^oneix, z), (/?zero(a^, z), ^d-one{x, z), 
y^d-zevo{x,z), and ^d-equa.\{x,z,x'), respectively. 
Proof. Note that for m < 2^ and fc < / the k-th. digit of [m] is 1 iff 
3yeN3ze 
N(m = y • 2^"^ + z A 2^"^"^ <z< 
2^"^). 
Using this fact one easily shows, for example, the following equivalences, 
which immediately can be formalized with the help of the formulas of the 
preceding lemma. 
OnemA: 
iff 
m < 2^ A k < IA 
3y3z{m = y • 2^"^ + ^ A 2^'^'^ <z< 
2^"^) 
Onei UoUik 
iff 
(UQ < 2^ A ui < 2^ A k < I A Oneuok) V 
{I <k<2-l 
A 
Oneui(k-l)) 
Equalduku' 
iff 
u < 2^ A u' < 2^ A k < (d+1)•/ A 
V^{(^ < {d+l)-l 
Ai ^ k) -^ (One^m i^ Onedu'i))-
D 
Finally, we come to the 
Proof (of 7.3.7). Let M be a logarithmically space-bounded machine for r-
structures, say, M is ci • log space-bounded. For simplicity we assume that 
T = {R} with binary R and that M only has one work tape. We restrict 
ourselves to structures of cardinality n with n > d-logn, {d-{-!)• I > d-logn, 
and n > SM + 1 (recall that / := logn - 1 and that {0,..., SM} is the set of 
states of M). When M is started with a structure A, where ^ = {0,..., n - 1 } , 
we can code the data of a resulting configuration by a tuple 
{Z, Ua,U^,U,Va,V^,Vo,Vi,Wa,W,yo, 
. . . , yd) 
where 
— z is the state 
— Ua,u^,u code the position of the head on the 0-th input tape (the "universe 
tape") by 
the head does not face a 
the head faces a 
r 0 
if 
^- = 1 n - 1 
if 
_ r 0 
if 
'''" " \ n - 1 if 
the head does not face u 
the head faces to 
and u is the number of the cell faced by the head if it is an interior one, 
otherwise u = 0 
similarly, Va,Vu;,vo, f i code the position of the head on the first input tape, 
the tape for the binary relation R; the variables fo,fi represent the head 
position VQ ' n -\- vi 

146 
7. Descriptive Complexity Theory 
— Wa^w code the position of the head on the work tape (note that d-logn < n) 
— the concatenation [^o] • • • [Vd] is the inscription of the first (d + 1) • / cells 
of the work tape. 
Sometimes, for notational simplicity, we denote the sequence zUaU^j • - -Vd 
simply by x. 
Concerning part (a) of the lemma, we can set 
Xstart(^) 
:= 
^ = 6. 
Concerning part (b), we define Xsucc(^5^0 by 
Xsucc(^,^') 
: = 
Xacc{x,x')\/ 
\J 
Xinstr(^,^') 
instr G instr(M) 
where 
Xacc{x,x') 
:= 
{xi = s+ Ax' = x) 
(which in case x is a configuration expresses that x is accepting and x' = x) 
and where for every instruction 
instr = 56061 ci -^ s'c'ihohih2 
Xinstr(^5^') is a formula which, in case x is a (d • log)-bounded configuration, 
expresses that x has base s6o6iCi, the successor configuration of x according 
to instr is {d • log)-bounded and is x'. As an example, we explicitly give 
Xinstr(^,^') for 
instr = slal -^ s'0(-l)ll, 
namely as the conjunction of 
z = s 
"s is the state" 
Ua — min /\Uuj — min 
"the head of the 0-th input tape faces an interior cell" 
VQC — max AVc_j = min AVQ = min A -ui = min 
"the head of the first input tape faces a" 
Wa = min A Oned yo ... ydW 
"the head of the work tape faces a 1" 
z' = s' 
"s' is the new state" 
u'^ = min A{{U > 0 A Su'u A u'^ = min) V {u = 0 Au' = 0 Au'^ = max)) 
"new head position of the 0-th input tape" 

7.4 The Complexity of the Satisfaction Relation 
147 
v'^ = min A fg = min /\v[ = min A i;^ = min 
"new head position of the first input tape is cell 0" 
w'^ — min ASww^ A w' < d- logn, 
i.e. w'^ — min ASWW' 
A 3a;(v?iog(universe)(3^) A w' < d- x) 
"new head position of the work tape is within the bounds" 
ZerOd2/o---2/> 
"new content of cell scanned on the work tape" 
"work tape content unchanged on cells not scanned". 
D 
7.4 The Complexity of the Satisfaction Relation 
Suppose, for example, that the class K of ordered structures is axiomatiz-
able by the FO(IFP)-sentence if, K ^ {A e 0[T] \ A ^ ip]. We aim at 
showing that K G PTIME, that is, for fixed (/? we want to prove that the 
satisfaction relation A \= (p can be decided in time polynomially bounded 
in \\A\\. One also says that (p has a polynomial time model-checker. To sim-
plify the corresponding algorithms we start with some general remarks. Note 
that manipulations in algorithms of the kind we now describe do not destroy 
polynomial time and logarithmic space bounds. 
(1) Using an additional work tape W it is possible at any time of a compu-
tation to move the head of a given work tape W to the rightmost square 
which the head of the tape has scanned so far. (In fact, change the given 
program so that the head on W moves in the same way as the head on 
W, but always prints the symbol 1.) 
(2) By (1) it is possible at any time of a computation to erase the content 
of a work tape (note that the additional work tape used in (1) can be 
cleared in a trivial way); in particular, one can change a program - with-
out changing the accepted class - such that all work tapes are empty 
whenever the program stops. 
(3) The content of a worktape W can be copied to an empty tape Wi (us-
ing (1), bring the corresponding heads H and Hi to the rightmost cell 
scanned by H and copy the content cell by cell). 
(4) In our applications the 0-th input tape has the inscription 1... 1 , where 
n—times 
n is the cardinality of the structure we consider. One can write the binary 
representation of n (of length < log n) on a work tape. We say "a counter 
is set to n". Similarly, a counter can be set to n^ for any fixed d> 1. 
Let £- be one of the logics considered in the preceding section and C the 
corresponding complexity class. We want to show that for any sentence of 

148 
7. Descriptive Complexity Theory 
C the class K of its ordered models is in C. We even show that there is a 
machine M strongly witnessing K £ C, that is, 
— M accepts K; 
— for any A G 0[r] every run of M, started with A, stops at s+ or s_; in 
particular, if M is deterministic then M decides K; 
— for any ^ G C^[T] every run of M satisfies the time or space bounds char-
acteristic for C. 
The proof that the class of ordered models of a sentence (p of CisinC proceeds 
by induction on (p. So we have to deal with formulas, too. We therefore 
introduce the following notation: For a formula (p{xi,..., 
a;/, Fi,..., Yr) we 
let 
ordMod((/p) 
:= 
{ ( ^ a i , . . . ,ai,Pu . •. ,Pr) \ A E (9[T], A ^ 
^[a,P]}, 
that is, we consider the ordered models of ip{ci,..., 
Q. P i , . . . , Pr), a sentence 
in an enlarged vocabulary. 
Theorem 7.4.1 Let K C 0[T] be a class of ordered structures. 
(a) IfKe 
DTC then K G LOGSPACE. 
(b) IfKe 
posTC then K G NLOGSPACE. 
Proof. By induction on the corresponding formulas if we show that the class 
of ordered models of ^ is in LOGSPACE and NLOGSPACE, respectively, 
and that there exists a machine strongly witnessing this fact. We handle both 
cases simultaneously. By passing to an equivalent formula we can assume that 
in formulas of FO(posTC) the TC operation does not occur in the scope of 
any negation symbol (the new formula may also contain A,V). 
Suppose that ^ is atomic, say for simplicity, (/? — Rxy. We show that there 
is a machine M strongly witnessing that 
{{A,iJ) 
I A G 0[TlR'^ij} 
G LOGSPACE. 
Let (A, ij) 
G 0[r U {c, d}] with ^ = {0,1,..., n-1} be given. Note that the 
information, whether R'^ij holds, is to be found in the (i-n + j)-th square of 
the input tape corresponding to i?, and (the binary representations of) i and 
j are available on the input tapes corresponding to c and d. Now it should be 
clear how a machine strongly witnessing that OTdMod{Rxy) G LOGSPACE 
can be designed. 
(p = -^'^p: By the remarks above, ip does not contain TC and hence, is in 
FO(DTC). By induction hypothesis, there is a machine M strongly witnessing 
that ordMod(^) G LOGSPACE. For (p just interchange the roles of s+ and 
5_ in M. 
(p{xi,... ,xi) = ('?/'Vx): By induction hypothesis, there are corresponding 
machines M^ for ip{xi,..., 
a:/) and M^ for x(a^i ^ -- • ,xi). Let M be a machine 
that first carries out the computation of M^ and then that ofM^ accepting 

7.4 The Complexity of the Satisfaction Relation 
149 
the input in case at least one, M^ or M^, accepts, and rejecting otherwise. 
(After the computation of M^ the work tapes are erased as explained in 
remark (2) above.) 
(^ — {ip f\x)'- similarly. 
Lp{xi^... ^xi) — 3xip: By induction hypothesis, there is a corresponding 
machine MQ for ^[^{xi,... ,xi,x). 
A machine M for ip operates as follows: 
Suppose M is started with an ordered structure (^,ai,... ,a/) where A = 
{0,..., n — 1}. Then, for z = 0,..., n— 1, M writes the binary representation 
of z on a work tape and checks, using MQ, whether A \= ^[ai,... ,a/,i]. 
(Note that the binary representation of i on the work tape does not carry an 
endmark uj as required on the corresponding input tape of MQ. TO remind 
the end of the representation of i, proceed as explained in remark (1) above.) 
If the answer is positive at least once, M stops in state s+, otherwise in s_. 
(p — ^xil): similarly. 
ip — \pTCx,yi^]'st^ where ^ is a formula of FO(DTC): For simphcity, we 
assume that the free variables of ip are among ^, y and that x — x,y = y,s — 
s, and i = t. Choose a machine MQ strongly witnessing that ordMod(V^) G 
LOGSPACE. Given A with A = {0,... , n - l } , if there is a ^-path from 
s to t, there is one of length < n. Therefore, the machine M, we aim at, 
can be organized as follows: It writes i := s on a work tape and sets a 
counter to n, which is used to invoke a subroutine at most n times. M rejects 
in case the counter becomes negative. Using MQ, the subroutine checks for 
j = 0,..., n — 1 whether A\= il)[i, j] holds for exactly one j ; if not, M rejects. 
Otherwise, M checks whether j equals t; in the affirmative case M accepts. 
In the negative case, M sets i \— j and reduces the counter by one. 
ip = [TCx,y'ip] 'st : Once more, for simplicity, we assume that the free var-
iables of Ip are among x,y and that x = x,y = y,s = s, and t — t. Choose 
a machine MQ strongly witnessing ordMod('0) E NLOGSPACE. We give the 
basic idea underlying the construction of a machine M for (/?: A counter is 
set to n (again, we assume that A — {0,1,... ,n —1}), which is used to 
carry out a subroutine at most n times. M will stop in the rejecting state 
in case the counter becomes negative. M writes i := s on a work tape. The 
subroutine starts choosing an element j G {0,..., n — 1} nondeterministically 
(by using a counter to randomly write a {0,1} word of length log n on a 
tape). Then it checks, using MQ, whether i^{i,j) holds. If not, M stops in 
state S-. Otherwise, if j = t^ M stops in s+, and if j ^ t, it sets i :— j . 
D 
Theorem 7.4.2 Let K C 0[T\ he a class of ordered structures. 
(a) / / K G IFF thenK 
eFTlME. 
(b) IfKeFFF 
then K 
eFSFACE. 
Proof. Again, we give the proof by induction on the formula ip axiomatizing 
the class K. The cases where ip is atomic, -i^, (^ Vx), or 3xip are handled as 
in the preceding proof. The corresponding machines are polynomially time-
bounded or space-bounded if the machines used in the induction hypotheses 

150 
7. Descriptive Complexity Theory 
are. Now, for part (a), suppose that if = [IFP^,x '4^{x, X)] t where X is r-ary, 
and that MQ is a machine strongly witnessing that 
{{A,a,R) 
I A e 0[T],A\= 
^|^[a,R]} € PTIME 
(for simplicity, we assume that the free variables of ^ are among x^X). The 
machine M, we look for, contains a subroutine that uses work tapes W and 
W. If started with a word of length n^onW- 
the code of an r-ary relation 
R - and empty W, the subroutine writes, invoking the machine MQ, the code 
of 
R' 
:= 
{a\A^{Xxy^)[a.,R]} 
on the tape W without changing the content of W. 
The machine M for (p operates as follows: It sets R := ^ and uses the 
subroutine to calculate R'. If R = R' it checks whether Rt or not Ri and 
accepts or rejects, respectively. Otherwise, it sets R := R', erases the content 
of W, and again starts the subroutine. Note that R = R' will be achieved 
after at most n^ calls to the subroutine (by 7.1.1(c)). 
For part (b) assume that (p — [PFP^,x '4^{x^X)]J with r-ary X and that 
Mo is a machine strongly witnessing {{A^'a^R) \ A G (9[T],^ |= ^\a^R\} G 
PSPACE. Given a structure A^ the operation F^ associated with ijj satisfies 
F^t.,! = F^^r (and this set is the fixed-point F^) or F ^ == 0 (cf. 7.1.1(b)). 
The machine M for ^p starts its computation on A by setting a counter to 
2^—1 (that is, it writes the word 1... 1 of length ti^ on a work tape). Then 
it proceeds as in the IFP-case, but now using the counter to ensure that the 
subroutine which here evaluates 
R' 
:= 
{a\A^^[a,R]}, 
is invoked at most 2^—1 times. When the counter gets negative, it checks 
whether R = R' and whether Rt. If both questions are answered positively 
it accepts, otherwise it rejects. 
D 
Theorem 7.4.3 Let K C 0[T\ he a class of ordered structures. 
(a) IfKeT.\ 
then K G NPTIME. 
(b) If K e SO then K G PSPACE. 
Proof, (a) Let K = Mod{(p) where (p = 3 X i . . . 3X/^, ip is first-order, and 
the arity of Xi is r^. By 7.4.1(a), there is a machine MQ strongly witnessing 
that Mod{ip{Xi,.. 
.,Xi)) is in PTIME (even in LOGSPACE). The machine 
M for v?, started with A G 0[T], nondeterministically writes words over 
{0,1} of length n^^,... ,n^^ on different work tapes, which are intended as 
codes of interpretations F i , . . . , P/ of X i , . . . , X/. Then, using MQ, it checks 
whether A |= ip[Pi,..., Pi] or not, and stops in an accepting or rejecting 
state, respectively. 

7.5 The Main Theorem and Some Consequences 
151 
(b) Let K = Mod((/?) for the formula (p of SO. To gain a machine M 
witnessing K G PSPACE we proceed by induction on ip. For (p atomic or of 
the form -r?/;, (^ V x), or 3xip we argue as in the proof of 7.4.1. For cp = 3X'ip 
with r-ary X the machine M writes the word 1... 1 of length n^ on a work 
tape W] then it systematically decreases this word, checking in each case 
with a polynomially space-bounded machine for ^, whether ip holds, if the 
interpretation of X is given by the tape W. 
D 
7.5 The Main Theorem and Some Consequences 
To summarize the results of the preceding sections we introduce the following 
notion: 
Definition 7.5.1 A logic C captures a complexity class C if for all r with 
< G T and K C 0[T] we have 
K £ C iff 
K is axiomatizable in £. 
D 
Theorem 7.5.2 (Main Theorem) (a) FO(DTC) captures LOGSPACE. 
(b) FO(TC) captures NLOGSPACE. 
(c) FO(IFP) captures PTIME. 
(d) S| captures NPTIME. 
(e) FO(PFP) captures PSPACE. 
Note that we have proved the theorem up to part (b). We only have shown 
that 
FO(posTC) captures NLOGSPACE. 
At the end of this section we will prove that 
FO(posTC) = FO(TC) on ordered structures. 
Then the proof will be finished. 
The main theorem gives descriptive characterizations of some important com-
plexity classes by certain extensions of first-order logic. Is there a well-known 
complexity class that, in this sense, corresponds to first-order logic itself? We 
have mentioned already several times that first-order logic has rather limited 
posssibilities to speak about inductive or recursive procedures. In fact, it 
has been proved that first-order logic captures a very low complexity class, 
namely AC°, a class which is defined in terms of circuits; cf. [95]. 
The study of the complexity of evaluating a formula (^^ of a logic £ in a 
structure A arises in various contexts. For example, A may be a database 
instance and if a corresponding query, or A may represent the state space 
of a program and (p a desired property. When considering such evaluations 
the following kinds of complexities have been treated (the first one being the 
subject of this chapter): 

152 
7. Descriptive Complexity Theory 
— data complexity of C: For a fixed sentence, we measure the complexity as 
a function of the size of the structure; 
— expression complexity of £: For a fixed structure, we measure the complex-
ity as a function of the length of the formula; 
— combined complexity oi C: It is measured as a function of both the size of 
the structure and the length of the formula. 
In this book we mainly concentrate on data complexity. The following exercise 
contains two results on combined complexity. Part (a) illustrates a general 
phenomenon, namely a considerable increase against data complexity (cf. 
[52]); part (b) shows that it may pay to look for axiomatizations with few 
variables. For a proof the reader should carefully analyze the proof of 7.4.1. 
Exercise 7.5.3 (a) The combined complexity of FO is in PSPACE. (In fact, 
it is PSPACE-complete; see [142].) 
(b) For s > 1, the combined complexity of FO^ is in PTIME. (In fact, it is 
PTIME-complete for 5 > 2; see [143].) 
D 
The descriptive characterizations of complexity classes given by the main 
theorem are of importance in various respects: 
— They may help to recognize that a concrete problem is in a given complexity 
class (by expressing it in the corresponding logic). 
— They allow to view the logics involved as higher programming languages for 
problems of the corresponding complexity class. (Note that the proofs of 
the preceding section show how to convert a sentence (p into an algorithm 
accepting the class of models of ^ and satisfying the required resource 
restrictions.) 
— Characteristic features of the logic may be seen as characteristic features of 
the complexity class described by it and may add to a better understand-
ing. (For instance, the result about FO(IFP) and PTIME shows us that 
inflationary inductions are an essential ingredient of PTIME algorithms.) 
— The descriptive characterizations allow to convert problems, methods, and 
results of complexity theory into logic and vice versa, thus widening the 
methodological possibilities for both sides. 
In the remainder of this section we give some illustrating examples for the 
last point. We first stay with ordered structures and subsequently discuss the 
role of order. 
Sentences (p and ^ in a vocabulary r with < G r are said to be equivalent 
on ordered structures if for all ordered r-structures A^ 
A\^ip 
iff 
A^il^. 
Corollary 7.5.4 On ordered structures, every YOiJFV)-sentence is equiva-
lent to an YOiJFV)-sentence 
in which IFP occurs at most once. The same 
applies to FO(PFP) and PFP. 

7.5 The Main Theorem and Some Consequences 
153 
Proof. Suppose (/? G FO(IFP)[r] with <e r. Then ordMod((y9) G PTIME. 
Now the claim follows from 7.3.5. For FO(PFP) cf. 7.3.3. 
D 
The next corollary also has a simple direct proof. 
Corollary 7.5.5 Let C he one of the complexity classes mentioned in the 
Main Theorem. If K is a class of ordered structures in C then there is a 
Turing machine M strongly witnessing K e C, that is, 
— M accepts K 
— every run stops in the accepting or in the rejecting state 
— every run fulfills the time or space hounds characteristic for C. 
Proof. Let JC be the logic capturing C. Then there is a sentence of JC ax-
iomatizing K. By the results of section 7.4 we know that for every class K 
axiomatizable in C there is a machine strongly witnessing K e C. 
D 
An immediate consequence of the Main Theorem is the equivalence of (i) 
and (ii): 
(i) PTIME = PSPACE 
(ii) FO(IFP) = FO(PFP) on ordered structures. 
Note, however, that here PTIME and PSPACE are understood as classes of 
ordered structures and not as languages over alphabets. Does (i) mean the 
same as PTIME = PSPACE in complexity theory? We want to show this by 
making clear that here and in complexity theory we deal only with different 
presentations of a complexity class. 
If C is a complexity class of complexity theory, we denote by C the cor-
responding complexity class of structures. For example, for PTIME we have 
C consists of all languages L, L C A+ for some alphabet A, such that 
there exists a deterministic Turing machine accepting L in polyno-
mial time 
and 
C consists of all classes K, K C 0[T] for some r with < G r, such that 
there is a deterministic Turing machine M accepting K in polynomial 
time. 
In the following let C,Ci,C2 range over the complexity classes LOGSPACE, 
NLOGSPACE, PTIME, NPTIME, and PSPACE of complexity theory. 
Our first consideration will show that (3 C C up to a natural transition 
from words to ordered structures, thereby using word models (already intro-
duced in section 6.2). 
Fix an alphabet A and let r(A) be the vocabulary {<} U {Pa | a G A} 
with unary Pa.lf u e A'^, denote by K^ the class of structures of the form 
( 5 , <, (Pa)aGA), 

154 
7. Descriptive Complexity Theory 
where the cardinahty of B equals the length of w, < is an ordering of B, 
and Pa corresponds to the positions in u carrying an a. For L C A+ set 
K(L) := UueL^u' 
Clearly, K{L) C 0[r{A)] and, since 
K{A+) = ordMod(Vx( \/ {PaX A / \ 
^Pbx))), 
aeA 
beA 
we have 
(1) 
K ( A + ) G L O G S P A C E . 
One can easily show that 
(2) 
forLCA+, 
L G C iff 
K{L)eC', 
thus obtaining "C C C' up to transitions". 
Now we turn to a statement showing C C C up to a transition from 
ordered structures to words. Let r with < G r be given. Set AQ := {0,1, a,uj}. 
For A G 0[T] let UA be the word in AQ" obtained by concatenating the 
inscriptions on all input tapes of a Turing machine started with input A 
(where we include the "virtual letters" a and u). For a class K C 0[T] set 
L{K) 
:= 
{uA\AeK}. 
Clearly, given r, there is a polynomial p G N[x] such that for all A G 0[T] 
we have \\A\\ < \UA\ < p(||^||). In particular, for p{x) := x^ we have that 
log II A|I < log |w^| < c? • log m||. Invoking these relations one shows 
(3) 
L(0[T]) 
G L O G S P A C E 
(4) 
for K C (9[r], K e C iff L{K) G C 
((3) is immediate, and (4) is left as an exercise to the reader). Thus, "C C C 
up to transitions". 
From (2) and (4) we infer 
Proposition 7.5.6 Ci C C2 iff C'^CC^. 
Proof. First, suppose Ci C C2 and let K e C[ where K C 0[T]. Then by (4), 
L{K) G Ci and by hypothesis, L{K) G ^2- Therefore, K eC'2 (again by (4)). 
Now assume C[ C C'^ and let L e Ci. Then, K{L) G CJ by (2), and hence, 
K{L) G C^. Therefore, L e C2 (again by (2)). 
D 
Together with the Main Theorem we have 
Corollary 7.5.7 (a) FO(IFP) = FO(PFP) on ordered structures 
iff PTIME = PSPACE (in complexity theory). 

7.5 The Main Theorem and Some Consequences 
155 
(b) FO(IFP) = El on ordered structures 
iff PTIME = NPTIME {in complexity theory). 
D 
Moreover, the preceding argument shows that in order to get FO(IFP) = 
FO(PFP) on ordered structures (or, equivalently, PTIME = PSPACE) it 
suffices to prove that FO(IFP) = FO(PFP) holds for ordered r-structures 
where, besides <, only unary relation symbols are in r. Since one need only 
consider languages over {0,1}, even a single unary relation symbol suffices. 
Corollary 7.5.8 The following are equivalent: 
(i) PTIME = NPTIME 
(ii) FO(IFP) = SO on ordered structures. 
Proof. If (ii) holds then Ej < FO(IFP) on ordered structures, thus NPTIME 
< PTIME. Conversely, if NPTIME = PTIME then, on ordered structures, 
EJ = FO(IFP). As EJ is closed under existential quantifications and FO(IFP) 
under boolean operations, an easy induction yields SO = FO(IFP). 
D 
Whereas the preceding corollaries contain the translation of problems from 
complexity theory to logics we now turn to the translation of a result. In 
complexity theory one shows 
LOGSPACE CNLOGSPACE C PTIME C NPTIME C PSPACE 
and 
LOGSPACE 7^ PSPACE. 
Hence, by the Main Theorem, 
Corollary 7.5.9 On ordered structures, 
(a) FO(DTC) < FO(TC) < FO(IFP) < Ej < FO(PFP). 
(b) FO(DTC) ^FO(PFP). 
D 
Note that most of the <-relations in (a) are immediate; the remaining ones 
and part (b) will be obtained in chapters 8 and 9 by purely modeltheoretic 
means. 
For any of the complexity classes C introduced so far, in complexity theory 
one defines the class co-C to be the class of complements of languages in C, 
that is, for any alphabet A and L C A+, 
L e co-C iff 
(A^ 
\L)eC. 
Clearly, any deterministic class C is closed under complements, that is, C = 
co-C. Similarly, we define the class co-C as the class of complements of classes 
of structures in C; more precisely, for r with < G r and K C 0[T], we set 
Keco-C 
iff 
{0[T]\K)eC. 

156 
7. Descriptive Complexity Theory 
Exercise 7.5.10 Show that Proposition 7.5.6 remains true if one allows Ci 
and C2 to range over the complexity classes mentioned in the Main Theorem 
and their complements. (Use (l)-(4) before 7.5.6.) 
D 
We now are going to discuss the role of order and to get information 
whether and to what extent orderings can be avoided. Let ^4 be a not neces-
sarily ordered structure. We already mentioned that in order to consider A 
as an input for a Turing machine, we have to represent it as a string (or a 
sequence of strings), for example, by labeling the elements of A in some way. 
Taking, say, the lexicographic ordering of the labels, we get an ordering on 
A and hence, an ordered structure. Now, if ^ is a graph we can state ques-
tions such as "Is there a path from the 5-th to the 28-th element?" whose 
answer depends on this ordering and is senseless for A itself. The following 
framework enables us to concentrate on questions intrinsic to A. 
Definition 7.5.11 Let K be a class of (unordered) r-structures. Set r< := 
rU{<}. The class K< of ordered representations of structures in K is given 
by 
K^ 
:= {{A, <)\ Ae K, < an ordering of A}. 
D 
If £ is a logic capturing the complexity class C we have 
K<: eC 
iff 
there is (^ G £[r<] such that K< = Mod ((/?). 
The sentence (p on the right side of the equivalence is order-invariant in the 
finite, since for every A and any orderings <i and <2 of ^ we have 
{A,<i)eK< 
iff 
( A < 2 ) G E : < 
and thus, 
{A,<i)^ip 
iff 
{A,<2)^^-
Now, if JC would be closed under order-invariant sentences in the finite (by 
3.5.2, FO does not have this property), we would have 
K^eC 
iff 
there is ^ G C[T] such that K = Mod^(V').^ 
In general, this does not hold. To give a counterexample for FO(DTC), let 
K = EVEN[r] with r = 0 be the class of sets of even cardinality. Since 
K< G LOGSPACE, there is a sentence (p of F O ( D T C ) [ T < ] such that 
K< = Mod((/?); 
for example, as </? we can take the sentence ^[DTCx^yV = x -\-2] min max, 
where we use self-explanatory abbreviations. This sentence is order-invariant 
We use Mod^(...) with upper index r to rule out any ambiguity on the vocabu-
lary considered. 

7.5 The Main Theorem and Some Consequences 
157 
in the finite: the evaluation of (^ in a structure {A, <^) makes use of the 
ordering <^, but the outcome of this evaluation does not depend on the 
specific ordering <^ we have chosen. We shall see in 8.4.4 that for no sentence 
^ of FO(DTC)[r], even of F O ( P F P ) [ T ] , 
K = Mod(^). 
These observations lead to a stronger notion of what it means to capture a 
complexity class. 
Definition 7.5.12 Let £ be a logic and C a complexity class. C strongly 
captures C if for all vocabularies r and all classes K of r-structures, 
i^< e C iff K is axiomatizable in £. 
D 
The following proposition holds for all complexity classes C considered so 
far; essentially one needs that C contains LOGSPACE. The proof is left to 
the reader as an exercise. 
Proposition 7.5.13 If C strongly captures C then C, captures C. 
D 
The converse is false: The counterexample given before the definition shows 
that FO(PFP) does not capture PSPACE strongly. For the class EVEN[r] we 
used as a counterexample, we have EVEN[r]< G LOGSPACE, and EVEN[T] 
is not axiomatizable in FO(PFP). Since FO(DTC) < FO(TC) < FO(IFP) 
< FO(PFP) holds for arbitrary structures, we see that none of these logics 
strongly captures the complexity class corresponding to it by the Main The-
orem. The result cannot be extended to Sj and NPTIME, since we know 
Ej < FO(PFP) only on ordered structures. In fact, we have 
Theorem 7.5.14 Ej strongly captures NPTIME. 
Proof. Let r be arbitrary and K be a class of r-structures. Assume K = 
Mod^((/?) for some SJ[r]-sentence (p, say, if = 3Xi .. .3Xm'ip with first-
order -0. Set X := 3Xi.. .3X^(^ A "< is an ordering"). Then, x ^ 5]J[T<], 
Mod(x) = K<, and hence, K^ G NPTIME by the Main Theorem. Con-
versely, if K<^ G NPTIME then, again by the Main Theorem, there is a 
sentence (/? G E}[r<] such that K< = Mod^<((p). Set ip := 3 < ^. Then 
ip G E}[T], and for any r-structure A we have 
A\=il; 
iff 
there is <^ with (A, <^) \= (f 
iff 
there is <^ with {A, <^) G K< 
iff 
AeK, 
that is, K ^Mod''{ip). 
D 
Theorem 7.5.15 IlJ strongly captures co-NPTIME. 

158 
7. Descriptive Complexity Theory 
Proof. Let r be arbitrary and iiT be a class of r-structures. If Str[r] denotes 
the class of all r-structures then 
(+) 
(Str[r]\/f)<=0[r<]\if<. 
Therefore, 
K eli\ 
iff 
there is ^ ( X i , . . . , Xm) G FO[r] such that 
X = Mod(VXi...VX^t/;) 
iff 
there is x(^i? • • • ?-^m) € FO[T] such that 
Str[r]\ii: = Mod(3Xi...3X^x) 
iff 
(Str[r] \ K)< G NPTIME 
(by 7.5.14) 
iff 
(0[r<] \K<)^ 
NPTIME 
(by (+)) 
iff 
K< e co-NPTIME. 
D 
Corollary 7.5.16 NPTIME -: co-NPTIME 
iff 
Sj = n}. 
Proof. As an example we show the implication from left to right. Let K be 
a class of structures. Then 
K G S} 
iff 
K^e 
NPTIME 
iff 
K< G co-NPTIME (by hypothesis) 
iff 
KeUl. 
D 
Corollary 7.5.17 NPTIME = co-NPTIME 
iff SO = S}. 
Proof. By the preceding corollary it suffices to prove 
n J = E j 
iff SO = E}. 
For a logic C we write (/? G £ to express that the sentence (p is equivalent to 
an £-sentence. Clearly, 
(^ G E J implies 
-K/? G 11}, 
(/? G n} implies -^p G Sj. 
Now suppose that SO = Sj; and therefore, IlJ < S j . Let (p G Sj. Then, 
-i(p G nJ and hence, -^cp e S}. Therefore, (/9 G IlJ. Conversely, assume that 
n J = S}. One easily shows that the class E} is closed - up to equivalence - un-
der V and existential first-order and second-order quantifications. For closure 
under -< argue as follows: Suppose cp = ^ip and ^ G Ej. Then -^I/J G IIJ = E J . 

7.5 The Main Theorem and Some Consequences 
159 
Exercise 7.5.18 Show for A: > 1 that S^ = E^^^ impHes E]^ = SO. The 
question, whether Ej^ = Ej^_,_^ for some k, is open. However, it is conjectured 
that 
E } < E ^ < . . . . 
For k >1, the class of ordered structures axiomatizable in S^ forms the A^-th 
stage PHjfe of the polynomial hierarchy PH. Its initial stage FHQ is defined to 
be PTIME. In 12.4.8 we shall give a definition of PH in terms of complexity. 
D 
Exercise 7.5.19 Define the logic SO(PFP). Show that it captures PSPACE 
strongly. In 8.5.1 we shall implicitly show by a purely modeltheoretic proof 
that SO(PFP) = FO(PFP) on ordered structures. 
D 
The question whether LOGSPACE, NLOGSPACE, and PTIME can be 
strongly captured by a logic is a major issue of descriptive complexity theory. 
Of course, one has to give a precise definition of what is meant by a "logic" in 
this context. Moreover, to rule out trivial positive answers, one has to require 
some conditions of effectiveness. Note that in the capturing results obtained 
in the preceding sections, we effectively assigned to every sentence a Turing 
machine accepting its models. And to every Turing machine accepting a class 
of models we effectively assigned a sentence axiomatizing this class. Up to 
now all attempts to find a logic that strongly captures PTIME in such an 
effective way have failed. In Chapter 11 we shall come back to such attempts. 
We close this section by a result which completes the proof of the Main 
Theorem (compare 8.6.15 for a modeltheoretic proof). 
Theorem 7.5.20 On ordered structures, FO(posTC) = FO(TC). 
Proof. We make use of the fact (shown in 8.6.14) that, on ordered structures, 
every formula of FO(posTC) is equivalent to a formula of the form 
with first-order ?/?. 
The proof of the theorem proceeds by induction on FO(TC)-formulas, the 
only nontrivial case being the negation step. By the induction hypothesis and 
the fact just mentioned we may assume that 
with first-order ip. For simplicity, we assume that ip = ip{x,y). By the Main 
Theorem (more precisely, by 7.4.1) there is a Turing machine MQ strongly 
witnessing that ordMod(^) € LOGSPACE. 
Suppose X = xi.. .Xr. Given a structure A and a,b e A^, let dxp{a,b) be 
the length of the shortest V'-path connecting a and 6, 

160 
7. Descriptive Complexity Theory 
d^{a,b) := min{A: > 0 | there exist ao = a,ai,... ,afc = 6 such that 
A ^ ip[ai,ai+i] for i < k}, 
where d^{a,b) := cxo in case the set on the right side is empty. Note that 
- if d^(a,6) < oo then 0 < d^{a,b) < \\A\\'' 
- d^ (a, c) < d^ (a, 6) + d^ (6, c). 
Moreover, -> [TC^^^'0(^,^)] si is equivalent to 
"||{^ I d^{-S,v) < 00}|| = ||{^ I C?(^(^,^) A-.y=t)(^,^) < 00}||". 
We first show that there is a nondeterministic log space-bounded^ machine 
M such that for any ordered structure 
{A^aJ,w,w'), 
if II{e I d^p{a,e) <1}\\ =W then 
M accepts (v4,a,I,w;,tU') iff \\{e \ d^{a,e) <l + 1}\\ =w', 
where the corresponding natural numbers < |mi'' are given by their m||-adic 
representations 1 = IQ .. .lr,w = WQ .. .Wr,w' = WQ ...w'^. 
We present the machine M. When during its computation M checks 
whether A \= ip\c,d\ holds or not, this is done by invoking MQ. Started with 
(.4,a,/, wJ, wJ'), M first sets a counter to w'. Then, for every 5 G A^,it carries 
out either (1) or (2), the choice being done nondeterministically: 
(1) M nondeterministically guesses a path witnessing d^{a,b) < 1+ 1 and 
decreases the counter by one; in case the counter is zero it rejects. 
(2) Using an additional counter with the initial value w, M nondeterminis-
tically guesses w many distinct tuples c e A'^ together with a proof that 
d^{a,c) < 7; for each such c it shows that c ^b and -i^lc, 6] (thus, in case 
II{e I d^{a,e) <1}\\ = W, proving that d^{a,b) > / -h 1). In case / = 0 it 
shows -<'0[a,6]. 
Finally, if all 6 G A^ have been dealt with and the counter is 0, M accepts. 
Since M is log space-bounded there is, by the Main Theorem, a formula 
Xi/;{u,y,W,w') 
G FO(posTC) axiomatizing the class accepted by M. Then, 
noting that 10...0 is (the representation of) ||A||^, we get a formula 
r times 
p^{u,w) 
G FO(posTC) with the meaning 
''\\{v\d^{u,v)<oo}\\=w'' 
or, equivalently, with the meaning 
"\\{v\d^(u,v)<\\A\n\\=w" 
log space-bounded means c- log space-bounded for some c > 0. 

7.5 The Main Theorem and Some Consequences 
161 
by setting 
p^{u,w) 
:= 
[TCy^^y'w'iXi^{u,y,w,w') 
Ay' = y + 1)] minminl^^^^iiJ. 
r times 
Since we saw above that Lp — -^ [TC^^y 7/'(^, ^)] s^ is equivalent to 
"||{iJ I d^{^,v) < OOJII = ||{^ I G?(^(^,^)A^^=t)(s,^) < 00}||", 
we obtain that (p is equivalent to the formula 
3z (p^ (s, z) A Pi^^pA^y^t) (^' ^))' 
a formula of FO (posTC). 
D 
As a consequence of part (b) of the Main Theorem whose proof we just 
have completed we get, since FO(TC) is closed under negation: 
Corollary 7.5.21 NLOGSPACE = co-NLOGSPACE. 
D 
In the preceding considerations, when treating questions of effectiveness, 
we have restricted ourselves to ordered structures A, as they offer a natural 
way of encoding by passing to the unique isomorphic copy whose universe is 
{0,..., \\A\\ — 1} and whose order is the natural order on {0,..., \\A\\ — 1}. 
There is an alternative way, namely the direct restriction to structures whose 
universe forms an initial segment of the natural numbers. Of course, both 
frameworks are equivalent: 
Exercise 7.5.22 Let r be an arbitrary vocabulary. A n?/mencfl/r-structure 
is a T-structure whose universe is an initial segment of the natural numbers, 
that is, the universe is the set {0,..., n} for some n. For a class K of r-
structures let 
^num 
:= 
{AeK\Ais 
numerical} 
be the set of numerical structures in K, and for a sentence ip let 
Modnum(v^) 
•= 
{.4 I ^ 1= v^, ^ numerical} 
be the set of its numerical models. 
Let C and C be any of the complexity classes and logics, respectively, 
considered so far. Show 
(a) For any class K, we have K< G C iff Knum ^ C (that is, there is a Turing 
machine according to C that, started with any numerical A accepts A iff 
vA E -t^numj-
(b) C strongly captures C iff for any r and any class K of r-structures, 
-^num G C iff there is a sentence p of JC[T] such that Knum = Modnum(^)-
(c) JC captures C iff for any r and any class K of r-structures, i^num ^ C 
iff there is an ^-sentence p of i2[r<] with Knum = {^ | {A, <^) |= p, 
A = {0,..., n} for some n, and <^ is the natural ordering on A}. 
D 

162 
7. Descriptive Complexity Theory 
7.5.1 Appendix 10 
In the preceding sections Turing machines have only been used as acceptors^ 
that is, given a machine M and an input structure A^ the question was 
whether M would accept A. However, Turing machines can also be used to 
calculate functions. For later purposes we are interested in machines that 
map structures to structures, so-called transducers. 
Let r and a be vocabularies containing <. We consider (r, a)-Turing ma-
chines ^ that is, deterministic Turing machines M that have input tapes for 
encoding r-structures, work tapes, and in addition so-called output tapes, 
namely as many as we need for our way of encoding cr-structures as inputs. 
The output tapes are write-only tapes: In the beginning of a calculation they 
are empty, and their heads scan the first cell. In a step of M the heads on the 
output tapes either are not active or write a letter on the scanned cell and 
then move to the right neighbour. (So the final positions of the heads on the 
output tapes take over the role of the endmark u since they determine the 
portion of the tape visited by the heads during the computation.) Moreover, 
the behaviour of M does not depend on the actual inscriptions and head 
positions of the output tapes. Altogether it is made precise by the form of 
the instructions that look like (cf. (*) in subsection 7.2.2): 
{+) 
sbo.., bk+ici ...Cm^ 
s'c'i ... c'^/io ... hk+i+mdo ...dp 
(in case M has p -f 1 output tapes OPQ, ..., OPp), where di G {00,10,11}. 
The meaning of (-I-) is fixed as for (*) in subsection 7.2.2 adding that 
di = 00 
means 
"Do nothing on OPi", 
di = 10 
means 
"Write 0 on the scanned cell of OP^ and move 
the head to the cell on the right", 
di = 11 
means 
"Write 1 on the scanned cell of OP^ and move 
the head to the cell on the right". 
A (r, (T)-Turing machine M is a (r, a)-transducer if M, started with an or-
dered r-structure A, finally stops and the output tapes then carry the en-
coding of an ordered cr-structure B (where, up to the missing endmark (j, 
the same encoding as for input structures is used). To be definite, we let 
{0,1,..., 11^11-1} be the universe of B. 
When considering space-bounded transducers, the space used on the out-
put tapes (similar to that used on the input tapes) does not count. Hence, a 
log space-bounded transducer may fill a number of cells on the output tapes 
that is not log space-bounded in the size of the input. 
Without changing the space needed and, up to a constant factor, the time 
needed, we may assume that transducers are normalized in the sense that in 
the instructions (-I-) either (i) or (ii), where 
^° The notions and results of this appendix are only needed in Chapters 11 and 12. 
They may be skipped in a first reading. 

7.5 The Main Theorem and Some Consequences 
163 
(i) all di are = 00 
(ii) exactly one di is ^ 00, ci... Cm = c[ ... c'^, and /IQ = ... = hk+i+m = 0. 
So in a step of a normalized transducer either no output tape is involved 
or only one output tape, but no other tape. In case (ii), we speak of an 
(z, 0)-instruction if di — 10, and of an (i, l)-instruction if di — 11. 
Fix r, a as above and let M be a normalized (r, (7)-transducer. If we forget 
the output tapes and the di, we get a usual deterministic Turing machine M'. 
Thus, if 
(1) 
shQ... bk+i Ci...Cm ^ s'c[ ... c'^ho ... hk+i+mdo ...dp 
is an instruction of M then 
(2) 
soho ... bk+ici ...Cm^ 
s'ci... 
c'^ho ... hk+i+m 
is an instruction of M'; we call it an (i, j)-instruction of M' if (1) is an 
(i, j)-instruction of M. When carrying out an (z, j)-instruction, M' at most 
changes its state. 
Now, start M' with an ordered r-structure A. Then, for every point of 
the run of M started with A, the inscription of the output tapes of M (and 
hence, the output structure of M) can be reconstructed from the run of M' 
as follows: 
OPi has 0 in cell / if the corresponding sequence of configurations of 
M' contains at least / many (i,0)- or (z, l)-configurations, the /-th 
one being an (i,0)-configuration.^^ And similarly, OPj has 1 in cell / 
if the /-th (i,0)- or (z, 1)-configuration is an (i, l)-configuration. 
This observation enables us to describe the behaviour of M and, in particular, 
the output structure via the behaviour of M', using formulas of a suitable 
logic as we have done it for acceptors in section 7.3. As an example that 
we shall need later we consider the case that M is log space-bounded and 
the logic is FO(DTC), recalling that the behaviour of log space-bounded 
acceptors can be described by formulas of FO(DTC) (cf. 7.3.8). 
Theorem 7.5.23 Let M he a log space-hounded {T, a)-transducer. There are 
an e > 1, an FO(DTC)-formula 
^uni(^i5 • • • ^^e)? and for every, say r-
ary, R e a an FO(DTC)-formula 
^R{XI, ... ,Xr) where length(^i) = ... = 
length(^r) = e such that for every ordered r-structure A the machine M, 
started with A, leads to an output structure isomorphic to 
( x 4 i ( - ) . ( ^ ^ ( - . - - - . - ) ) i ? G c T ) . 
We leave the details of a proof to the reader. One uses an FO(DTC)-
description of the run of M. The following exercise contains the key parts 
An (i, j)-configuration is a configuration calling an (i, j)-instruction. 

164 
7. Descriptive Complexity Theory 
needed to obtain the formulas mentioned in the theorem. Note that, when 
started with an ordered structure A, both M and M' stop after the same 
number of steps. As the number of different, say, o?-log mH-bounded configu-
rations of M' is polynomial in |m|, both M and M' are (n^ —1) time-bounded 
for a suitable e. We may assume that e = d. 
For notational simplicity let a — {E^ <} with binary E. 
Exercise 7.5.24 Referring to M' and using the formulas Xstart(^) and 
Xsucc(^5^') from Lemma 7.3.7, show for sufficiently large r-structures A\ 
(a) For i < p there is an FO(DTC)-formula Xi-free(^5^') such that for a, a' in 
A'. 
AV- Xi-freei^-? Q^'] if? ^ cind a' are (c? • log ||A||)-bounded configurations 
of M', and M', with A written on its input tapes, 
runs from a to a' without passing an 
(i,0)-configuration or an (z, l)-configuration. 
(b) For % <p there is an FO(DTC)-formula Xi-count(^5 ^) with length(y) = e 
such that for a, 6 in A\ 
A 1= Xi-count[^, 6] iff 
a is the 6-th (i, 0)-configuration or 
(i, l)-configuration of M' started with A 
(we refer to the lexicographical ordering of A^). 
(c) Let B = {B,E^, <^) be the output structure that M gives on A. There 
are FO(DTC)-formulas Xuni(^),X£;(^^^), and x<(^,^) with length(^) = 
length(:2) = e such that 
Xuni[6], b is the /-th element in the lexicographical 
ordering of A^}; 
E^ 
= 
{{l,m) \ A\= XE\P,C], 
6 is the/-th and C the m-th element in 
the lexicographical ordering of A^ }; 
<^ 
= 
{{l,m) \ A\= X<p5c], b is the /-th, c the m-th element} is the 
natural ordering on B. 
D 
Exercise 7.5.25 Formulate and prove the analogue of Theorem 7.5.23 for 
polynomially time-bounded (r, <j)-transducers and FO(IFP). 
D 
Notes 7.5.26 As a reference for computation and complexity theory we 
mention the books [87, 128, 46]. Theorem 6.2.1 goes back to [139]. The charac-
terizations of complexity classes given by 7.5.2 are due to Immerman [93, 94] 
(LOGSPACE, NLOGSPACE), Immerman [91], Livchak [119], and Vardi [142] 
(PTIME), Fagin [36] (NPTIME), Abiteboul and Vianu [2] (PSPACE). Corol-
lary 7.5.21 was independently proved in [94] and [137]. An important topic 
we have not treated here is circuit complexity. We refer the reader to [95] for 
information and further references. 

8. Logics with Fixed-Point Operators 
In Chapter 7 we have introduced logics with fixed-point operators in the 
context of computational complexity and shown that they capture important 
complexity classes. In the present chapter we study the (finite) model theory 
of fixed-point logics. Though we sometimes refer to Chapter 7, we repeat the 
relevant definitions and results to provide an independent approach. 
In the rest of the hook all structures will he finite, unless stated otherwise 
explicitly. Equivalence of formulas means equivalence with respect to all finite 
structures. 
8.1 Inflationary and Least Fixed-Points 
We prove some basic facts about fixed-points and, besides infiationary fixed-
point logic, present an important sublogic, namely least fixed-point logic. 
We state two major results, the proofs being postponed to the next section: 
Inflationary and least fixed-point logic have the same expressive power, and 
every formula is equivalent to a formula containing at most one fixed-point 
application - a fact that extends Corollary 7.5.4 from ordered structures to 
arbitrary ones. 
We observed in Chapter 2 that many important notions and global relations 
cannot be expressed by first-order formulas. An example is given by the 
reflexive and transitive closure of the edge relation in a graph (cf. 2.3.8). In 
the vocabulary r := {E} for graphs consider the formula 
x{x,y,X) 
:= 
{x = 
y\/^z{XxzhEzy)). 
It gives rise to a sequence of sets defined by 
(*) 
^0 := 0, 
Xn+i := {{x,y) \ 
x{x,y,Xn)}-
In other terms: Let Q = (G, E^) be a graph. Look at the function F^ on the 
power set of G x G, F^ : POW(G2) -^ POW(G2), given by 
F^{U) 
:= 
{{a,h)^G^\G^x[aAU]} 
for U C G X G. Then, (*) corresponds to the sequence of sets 

166 
8. Logics with Fixed-Point Operators 
F^ := 0, 
Fi+, := 
F^F^). 
Note that 
F^ = 
{{a,b)eG'\d(a,b)<n}, 
where d{a,b) denotes the distance between a and 6 in ^ (see l.Al). For 
F^ := Un>o^n we have F{F^) 
= F ^ , that is, F^ is a fixed-point of F^ 
and 
F^ = 
{ia,b)eG^\d{a,b)<^}. 
In particular, for a ^ b, 
a, b are connected by a path in Q 
iff 
(a, b) G F ^ , 
and 
^ is connected 
iff 
F^ = G x G. 
The relations F^ that lead to the fixed-point F^ are first-order definable, but 
in general, F^ is not. In the fixed-point logics we are going to introduce the 
relation F^ will be definable, too; in particular, the connectivity of graphs 
will be expressible. 
Let us first study some aspects of the process above on a more abstract 
level. Fix a finite set M. A function F : Pow(M) —)• Pow(M) gives rise to a 
sequence of sets 
0,F(0), F(F(0)),.... 
Denote its members by FQ, FI ,..., i.e., FQ = 0 and Fn+i = F{Fn). Fn is called 
the n-th stage of F. Suppose that there is an no G N such that F^o+i = F^Q, 
that is, F{Fno) = FUQ- Then, Fm = FUQ for all m > UQ. We denote F^o by 
Foo and say that the fixed-point FQO of F exists. In case the fixed-point Fo© 
does not exist, we agree to set Foo := 0. 
F is inductive if FQ C Fi C — 
Lemma 8.1.1 (a) //FQO exists then F^Q — F2\\M\\_I. 
(b) If F : Pow(M) -^ Pow(M) is inductive then FQO exists and F^ = F||j\^||. 
Proof. Part (a) coincides with (b) of 7.1.1. 
(b) By assumption, FQ C Fi C ... C M. Since M has ||M|| elements, this 
sequence must get constant not later than with F||MI|- 
n 
F is inflationary if for all X C M 
X C F(X), 
and monotone if for all X^Y C M 
XCY 
implies F{X) C F{Y). 

8.1 Inflationary and Least Fixed-Points 
167 
Lemma 8.1.2 (a) If F is inflationary or monotone then F is inductive. 
(b) IfF is monotone then FQO is the least fixed-point of F, i.e., F{Foo) = F^ 
and F{X) = X implies F^Q C X; even F{X) C X implies Foo Q X. 
(c) // F : Pow(M) -^ Pow(M) is arbitrary and F' : Pow(M) -^ Pow(M) 
is given by F'{X) := X U F{X), 
then F' is inflationary. In case F is 
inductive we have F^ = Fn for all n > 0 and hence, F'^ = FQO • 
Proof (a) If F is inflationary then Fn C F{Fn) — Fn+i; thus F is inductive. 
Suppose that F is monotone. We have FQ = 0 C F(0) = Fi and therefore, 
by monotonicity, Fi = F{Fo) C F{Fi) = F2. Going on this way we obtain 
Fn C Fn+i for all n. 
(b) By part (a) and 8.1.1(b) the fixed-point Fo© exists. Suppose F{X) C X. 
We have FQ = 0 C X. Suppose F^ C X. Then, by monotonicity, Fn+i — 
F(Fn) C F(X) C X. Therefore, Foo C X. 
(c) Clearly, F' is inflationary. Let F be inductive. We show by induction 
on n that F^ = Fn- Obviously, F^ = FQ. Suppose F^ = Fn. Then F^^^ = 
F^ U F{F;,) = FnU F{Fn) =FnU Fn+1 = Fn+1. 
D 
Exercise 8.1.3 Let M := {0,1,2} and F : Pow(M) -)• Pow(M). Show: 
(a) If F(X) = 0 for all X C M, then F is monotone but not inflationary. 
(b) If 
' X 
forX = M 
F{X)-^ 
XU{||X||} 
otherwise 
then F is inflationary but not monotone, 
(c) If 
/ X 
forX = 0 
^ l ^ ; - I x \ { | | X | | } 
otherwise 
then F is inductive but neither inflationary nor monotone. 
D 
Exercise 8.1.4 Let F : Pow(M) -)• Pow(M) be monotone. Show that F 
has a greatest fixed-point, i.e., there is F^ C M such that 
-F{Fg)=F, 
— F{Y)^Y 
implies Y C Fg. 
Define G : Pow(M) -^ Pow(M) by G{X) := M \ F(M \ X). Prove that 
— G is monotone 
— Fg = M\ Goo, i-e-5 the greatest fixed-point of F is the complement of the 
least fixed-point of G. 
• 
Exercise 8.1.5 (a) Assume F : Pow(M) —>• Pow(M) is antitone, that is, 
X C y implies F(F) C F(X). Show that 
Fo C F2 C F4 C ... C F5 C F3 C Fi. 

168 
8. Logics with Fixed-Point Operators 
Define H : Pow(M) -^ Pow(M) by H{X) 
:= F{F(X)). 
Show that H is 
monotone, that IJn>o ^2n is the least fixed-point HQO of H and r\n>o ^2-n+i 
is the greatest fixed-point Hg of H. Conclude: 
- Foo exists iff Hoo = Hg-, 
- if Foo exists then FQO = i^oo and FQO is the unique fixed-point of H (and 
hence of F). 
(b) For a concrete example of an antitone operation consider a digraph Q = 
{G,E^). 
The game associated with Q is played between two players I and 
IL The game starts in an arbitrary point of G. It is played in rounds. Each 
round consists of two moves, a move of I followed by a move of IL A player 
can move from point a to point h if E^ah. A player looses if he cannot move. 
A point a G G is won for a player, if he has a winning strategy for games 
started at a. The point a is drawn, if for no player it is a won point. Define 
F : Pow(G) ^ Pow(G) by 
F{X) 
:= 
{aeG\3beG\X 
: E^ab}. 
Show that F is antitone and that for n > 0 
- a e F2.n iff a is won for I in < n rounds; 
- a ^ F2.n+i iff ci is won for II in < n H- 1 rounds. 
Conclude: 
- Un>o ^2n is the set of points won for I; 
~ (rin>o ^2-n+iy is the set of points won for II; 
- Foo exists iff there are no drawn points; 
- If Foo exists then FQ© is the set of points won for I. 
D 
A formula (p{xi,... ,Xk,u,X,Y) 
in the vocabulary r, where the relation vari-
able X has arity k, together with a r-structure A and interpretations b and S 
ofu and Y, respectively, gives rise to an operation F'^ : Pow{A^) —)• Pow(^^) 
defined by 
F'^iR) 
:= 
{{au^..,ak)\A\=^[ai,...,ak,b,R,S]}. 
(The notation F'^ does not make explicit all relevant data.) At the beginning 
of this section we have already given a concrete example using this notation. 
A further example: For the function F introduced in part (b) of the preceding 
exercise for the game associated with a digraph Q we have F = F'^ where 
^(x,X) 
:- 
3y{^XyAExy). 
And for the function (F^^)' associated with F'^ as in part (c) of the preceding 
lemma we have 

8.1 Inflationary and Least Fixed-Points 
169 
We now introduce inflationary fixed-point logic FO(IFP). It contains first-
order logic and is closed under fixed-points of definable inflationary operations 
and hence, by 8.1.2(c), under fixed-points of definable inductive operations. 
Therefore, inflationary flxed-point logic is sometimes called inductive fixed-
point logic. 
The syntax of FO(IFP): For a vocabulary r the class of formulas of FO(IFP) 
of vocabulary r is given by the calculus 
(p an atomic second-order formula over r 
y(p 
(if V ip) 
3xip 
where the lengths of x and t are the same and 
[IFP,,,x^] t 
coincide with the arity of X. 
Sentences are formulas without free first-order and second-order variables, 
where the free occurrence of variables is defined in the standard way, adding 
the clause 
free([IFP^,x^] t) 
:= 
free® U (free((/?) \ {x, X}). 
The semantics is defined inductively w.r.t. the calculus above, the meaning of 
[IFP^,x^] i being t e F^^^'^\ 
More precisely: If X is A:-ary and the variables 
free in [IFP^^xV^] ^ are among u and F, and h and S are interpretations in A 
of u and F, respectively, then 
A h [IFP^,x(^]^ [5,5] 
iff 
(ti[6],..., tfc[6]) G Fi,^^^^). 
We sometimes denote F^ ^^"^^ by [IFP^,x</^]. 
As an example, using the formula x{x, y, X) = (x = y\/3z{XxzAEzy)) 
of the 
beginning of this section, we see that the FO(IFP)-formula in the language 
of graphs 
IIJO{X, y) 
:= 
[IFP^^t/.x {x = yy 3z{Xxz A Ezy))] xy 
expresses "a; — y or x,y are connected by a path". Hence, the class of con-
nected graphs is axiomatized by (the graph axioms and) 
\fx\fyipo{x,y). 
A formula ip of FO(IFP) is said to be first-order, if it does not contain the 
IFP operator, even though it may contain second-order variables. Call an 
FO(IFP)-formula if positive (negative) in the second-order variable X, if each 
free occurrence of X in (p is in the scope of an even (odd) number of nega-
tion symbols. And call ip normal, if for every subformula of ip of the form 
[IFPy^Y'ip]t the formula ip is positive in Y. A simple induction shows (see 
the next exercise) that for any normal formula (p(x, X,...) positive in X the 
operation F'^ is monotone. 

170 
8. Logics with Fixed-Point Operators 
Exercise 8.1.6 (a) Let (p{x, X i , . . . , X^, Fi,..., 1/) be a normal formula of 
FO(IFP) that is positive in X i , . . . , X^; and negative in Fi,..., 1/. Then A \= 
ip[a,R,SlRi 
C R[,...,Rk 
C i?^, and S[ C ^ i , . . . , ^ ; C Si imply A ^ 
(p[a,R ,S]. (Hint: Induction on (p.) 
(b) The formula (p{x,X) := [IFPa;,y {Xx V {3yYy A -^Yc))]x is positive in 
X, but F"^ is not monotone. Note that cp is not normal. 
D 
Of course, it is decidable whether a formula cp is normal and positive in X, 
while - even for first-order (/? - it is not decidable whether F"^ is monotone. 
This can be seen from Trahtenbrot's Theorem 7.2.1 and the equivalence 
jP^xiXx-^ip) jg monotone (in the finite) iff ip is vaHd in the finite 
which holds for every first-order sentence ^. 
We saw in 8.1.2(b) that monotone operations have least fixed-points. This 
motivates the introduction of a corresponding fixed-point logic, namely Least 
Fixed-Point Logic FO(LFP) that we get by closing first-order logic under 
least fixed-points of operations definable by positive formulas. From a se-
mantic point of view it would be more natural to consider the closure under 
arbitrary definable monotone operations. But then, by the preceding remark, 
we would get a logic with an undecidable syntax. Moreover, the restriction to 
normal formulas does not lead to a loss of expressive power, as even FO(IFP) 
is not stronger than FO(LFP) (cf. 8.1.13). 
The class of formulas of FO(LFP) of vocabulary r is the fragment of 
FO(IFP)[r] given by the same calculus as that for FO(IFP), the IFP-rule 
being restricted to positive formulas: 
• 
•• 
r ^ 
where (p is positive in X and the lengths of x and t 
[ 
x,x^\ 
g^j.g ^i^g same and coincide with the arity of X. 
Thus the FO(LFP)-formulas are the normal FO(IFP)-formulas. Since for nor-
mal formulas (p that are positive in X, the operation F'^ is monotone, we 
have, by 8.1.2, that F^^^"^^ = F^ and that F^ is the least fixed-point of 
F'^. Hence, in this case, [IFP^^xV^] t expresses that t is in the least fixed-point 
of F'^. We therefore write [LFP^,x</^] t instead of [IFP^,x^] t. 
Example 8.1.7 Consider trees as {E}-structures (cf. lA.l). The formula of 
FO(LFP) 
(p<:(x,y) 
:= 
[LFF^y^xiExy 
V 3z{Xxz A Ezy))]xy 
defines a partial ordering (an irreflexive and transitive binary relation), the 
induced partial ordering. The FO(LFP)-formula (pD{x,y) := 
[LFP^y^x {yz{-^Ezx A -^Ezy) V 3u3v{Xuv A Eux A Evy))] xy 
expresses that x and y have the same depth and therefore, the FO(LFP)-
sentence 

8.1 Inflationary and Least Fixed-Points 
171 
\/x\/y{\/z{-^Exz A -^Eyz) -^ cpD{x,y)) 
says that all leaves have the same depth. 
D 
Example 8.1.8 Fix a vocabulary r and s > 1. We consider the pebble games 
introduced in subsection 3.3.1. A simple induction on n shows that for any 
r-structure A we have 
K^^ 
-^ 
{(ai,...,a^,6i,...,6s) I the spoiler wins G^(Aa,^,6)}, 
where 
ip(x,y, Z) := 
\J 
{^(x) ^ ^^{y)) V \ / 
{3xiWyiZxy\/3yi\/xiZxy). 
ip atomic 
l<z<.« 
Thus, for every a,b ^ A^ we have that A \= [LFP^^,^ (f]x y[a, b] iff the spoiler 
wins G'^iA,a,B,b). 
' 
D 
Exercise 8.1.9 Given a graph Q and k > 1, consider the following cops-and-
robbers game CR*'(^) with infinitely many moves: There are k cops and one 
robber, each of whom after any move stands on a vertex of ^. In the first move 
every cop chooses a position on the graph and afterwards the robber chooses 
his position. In any subsequent move one of the cops flies in a helicopter to 
a new vertex. Before the helicopter actually lands the robber will run to a 
new vertex along a path of the graph; however, he is not permitted to run 
through a cop. More formally, a position of the game CR^(^) is a (fc -1- 1)-
tuple of vertices of G. In the first move the "cops" choose a i , . . . , a^ G G and 
the "robber" b £ G. Then, (ai,..., a^, 6) is the position after the first move. 
Suppose (ei,... ,6^5 /) is the position after i moves. In the (i + l)th move, 
first the "cops" choose / with 1 < I < k and e' G G, and then the robber 
chooses a point / ' in the connected component of / in the graph induced on 
G \ {ei,...,e/_i,e/+i,...,efc}. Then (ei,... ,e/_i,e',e/+i,... ,6^,/') is the 
new position. The "cops" win if eventually a position (ai,..., ajt, 6) with 
b G {ai,..., afc} is reached. We say that a graph Q has tree-width < k if the 
"cops" have a winning strategy in CR 
(^) (usually, this concept is defined 
in terms of trees). 
Show that the class of graphs of tree-width < A: is axiomatizable in 
FO(LFP). Hint: Consider a formula expressing in any graph Q that the "cops" 
have a winning strategy in CR^^^(^), e.g., 
k+l 
k+1 
3x1...3xk+iyy[LFF^y^z{\/ 
Xi=yV 
\/ 3xi\/z{ipi{x,y,z) 
-> Zxz))]xy 
i=l 
1=1 
where 
ipi{x,y,z) 
:= [LFF^^uiz ^ y W 3u{Uu A Euz A /\z 
^ Xi))]z. 
D 

172 
8. Logics with Fixed-Point Operators 
For convenience we adopt the following convention: 
// not explicitly stated otherwise, the notation Lp{x^Y) only means 
that the variables in (p that are relevant in the given situation are 
among x and Y; there may he other variables free in Lp. 
Exercise 8.1.10 (a) Let ^(^, X) be an FO(LFP)-formula that is positive 
in X. Show that the greatest fixed-point of F^ is defined by the FO(LFP)-
formula -i[LFP^^x ^i^(x, ~'X)] x (here ^(x, -«X) is obtained from xj) by replac-
ing subformulas Xt by ^Xt\ hence, -^ij^ix^^X) is positive in X), a formula 
which sometimes is abbreviated by [GFP^^x i){x^X)]x. 
Hint: Use 8.1.4. 
(b) We know that with Lp{x^X) := 3y{-^Xy A Exy) we have F = F"^ for the 
antitone function F introduced for the game associated with digraphs (cf. 
8.1.5(b)). Hence, for iJ := F o F we have H = F^, where 
^(x,X) 
:= 3y{Exy AWziEyz^ 
Xz)) 
(note that xl){x,X) is equivalent to the formula p{x,^p{-,X)) 
obtained from (f 
by replacing subformulas Xy by (p{y, X)). By Exercise 8.1.5(b) the statement 
"there are no drawn points" is expressed by 
yx([LFF,,xi^]x 
^ 
[GFP,,x^]^) 
and the statement "a; is won by I" by [LFPa^^x i^jx. 
D 
Example 8.1.11 Consider orderings as {<, 5, min,max}-structures.^ Fix 
k > 1. Identify an ordering A with its isomorphic copy ({0,... ,n — 1}, <, 
5, 0,n — 1) where n = \\A\\. Then every A:-tuple (mi,... ^rrik) in A^ can be 
considered as the n-adic representation of a natural number, namely of 
[mi... ruk] := mi • n^~^ H- ... -h rrik • n^. 
Let S^ be the "A:-adic successor relation", 
S^'xi ...Xkyi-.-yk 
iff 
[yi-'-yk] = [xi... Xk] + l. 
S^ is first-order-definable by 
V {xi^i = ... = Xk = max A ^Xi = max 
l<i<A; 
A SxiVi A 
/\ 
yj = min A A 2/i = ^j)-
i<j<k 
l<i<« 
Define the relations ADD^ ("addition") and MULT^ ("multipUcation") by 
ADD^xi ...Xkyi...ykZi...Zk 
iff 
[z] = [x] + [y] 
^ Note that <, being the transitive closure of 5, is definable in F0(LFP)[{5}]. 

8.1 Inflationary and Least Fixed-Points 
173 
and 
MULT^xi ...Xkyi^^.ykZi...Zk 
iff 
[z] = [x] - [y]. 
ADD^ and MULT^ are definable in FO(LFP): For ADD^ we imitate the 
inductive definition 
X -\-0 
= 
X 
x + {y + l) 
= 
(x + y)-\-l 
by an appHcation of the LFP operator and obtain: 
[LFFx yz,x{{y = min A ^ = ^) V 3v3w{Xxvw 
A S^vy A S^wz)) ] xy'z, 
a formula we denote by (/?+ (x, ^, 'z). For MULT^ we use the inductive defini-
tion 
x-0 
= 
0 
x • {y + 1) = 
x ' y + X 
and obtain 
[LFP^y^,x(y = ^ = min V 3v'3w{X^vw/\ 
S^vy A 
ip^{w,x,^)))]xy^, 
a formula with "nested" LFP operators. 
Now one easily sees that the graph of any polynomial is definable in 
FO(LFP) in the following sense: Given p{x) G N[a;], there is a fc and a formula 
(Pp(x,yi,... 
^yk) of FO(LFP) such that for all orderings A containing the 
coefficients of p we have A |= \/x3yy:)p{x,y), and for all a,b e A, 
A^iPp[a,b] 
iff p{a) = [h]. 
D 
The following lemma is immediate. We often use it without mentioning 
it explicitly. Part (b) shows how parameters can be incorporated into fixed-
points. 
Lemma 8.1.12 (a) If X does not occur free in cp then [lFFx,xy^{x)]t and 
ip{t) are equivalent. 
(b) The formulas 
[lFFx,x^{x,y,X)]t 
and 
[IFF^u^Y 
^{x,u,Y-u)]ty 
are equivalent.^ 
D 
By definition, FO(LFP) < FO(IFP). As already remarked in the introduction 
of this chapter we are going to show the converse: 
Theorem 8.1.13 Every FO(IFF)-formula 
is equivalent to an FO(LFP)-
formula. 
Moreover we shall prove 
^ Here, xO^-u) is obtained from x(^) by replacing each subformula Xs by Ysu. 

174 
8. Logics with Fixed-Point Operators 
Theorem 8.1.14 Every FO{LFF)-formula 
is equivalent to an FO(LFP)-
formula with at most one occurrence of LFP. 
The proofs will be given only in the next section. With the following 
considerations we point at an essential step. 
Let Xo,Xi,... be the sequence of sets obtained when evaluating the outermost 
LFP operation in a formula of the form 
[LFPs,x...[LFP5,y<^(l?,X,F)]...].... 
In the transition from Xn to X^+i one needs the value [LFPy,y(p(^, X^, Y)]. 
We show how this kind of nested fixed-points can be expressed by "simulta-
neous fixed-points" and how simultaneous fixed-points can be expressed by a 
single fixed-point. We give the results in a general, more abstract form that 
will also be useful in later sections. 
First, we introduce the notion of simultaneous fixed-point. Let m > 0 and 
suppose that MQ^ ..., Mm are finite sets and that 
F^ : Pow(Mo) X ... X Pow(M^) -^ Pow(Mo) 
F^ : Pow(Mo) X ... X Pow(M^) -^ Pow(Mi) 
(*) 
. 
F"^ : Pow(Mo) X ... X Pow(M^) -^ Pow(M^). 
We define the sequence {F^^^,..., F^^)n>o by 
If we have for some n that (F^^^,..., F^^^^) = {F^^_^^^,..., F(^+i)), we set 
/ TjiO 
rpm 
\ 
. 
/ TTiO 
Tpm 
\ 
V-f^(oo)'---'^(oo)J 
— 
l ^ ( n ) ' ' - - ' ^ ( n ) > ' 
and say that the simultaneous fixed-point {FP^,. 
. . , F ^ . ) of (F°,...,F^) 
exists. Note that for z = 0,..., m, 
^ 
l ^ ( o o ) ' - - - ' ^ ( o o ) y - 
^(oo)-
If the simultaneous fixed-point does not exist, we set -F/QO) '-= 0 for z < m. 
Example 8.1.15 (a) Let F, G : Pow(M) x Pow(M) -^ Pow(M) be given by 
F{X,Y) := M, 
G{X,Y) := 
{M\Y)nX. 
Then (F(n))n>o is the sequence it},M,M,... and ((^(n))n>o is the sequence 
^^^^M^^.M^^^.... Therefore, the simultaneous fixed-point of (F,G) does not 
exist and hence, F(oo) = <J^(OO) = 0? even though F(i) = F{2) and G{Q) — G{i). 
(b) Suppose that the fixed-points Foo and G^oo of F : Pow(M) -> Pow(M) 

8.1 Inflationary and Least Fixed-Points 
175 
and G : Pow(iV) -)• Pow(A/') exist and define the functions F : Pow(M) x 
Pow(iV) -^ Pow(M) and G : Pow(M) x Pow(iV) ^ Pow(iV) by F ( X , r ) = 
F{X) and G{X,Y) 
= G{Y). Then the simultaneous fixed-point (F(00)56(00)) 
exists and (F(oo),6(oo)) = (i^oo,G^oo). 
• 
Definition 8.1.16 Let F ^ , . . . , F ^ be as in (*). 
(a) (F^,..., F^) is inductive if for i < m 
^(0) ^ ^ a ) ^ ^('2) ^ • • • • 
(b) (F^,..., F"^) is inflationary if for arbitrary XQ, ..., X ^ and all i < m, 
Xi C F*(Xo,..., Xm). 
(c) (F^,..., F^) is monotone if 
X o C y o , . . . , X ^ c r ^ imply F^(Xo,...,X^)CF^(ro,-..,i;n) 
for arbitrary XQ, ..., Xj,^, YQ,. .. ,Ym and all i <m. 
D 
The proof of the following lemma is a straightforward generalization of 
the proof of the corresponding parts in 8.1.1 and 8.1.2. 
Lemma 8.1.17 Le^F^...,F"^ he as in (*). 
(a) // (F'^,..., F"^) is inductive then the simultaneous fixed-point exists. 
(b) // (F°,..., F^) is inflationary or monotone then (F^,..., F^) is induc-
tive. 
(c) // (F°,..., F^) is monotone then (FP s,..., FV^^) is the simultaneous 
least fixed-point of{F^,..., 
F"^). Even F*(Xo,..., X^) C X^ for i < m 
implies FO^) C Xo,..., F^^^ C X^. 
(d) If for i <m, G' : Pow(Mo) x ... x Pow(M^) -^ Pow(M^) is ^wen by 
G^(Xo, 
. . . ,Xm) 
'•= 
XiU 
F^{Xo, 
. . . 
,Xm) 
then (G^,...,G"^) is inflationary. In case (F°,...,F"^) is inductive 
we have (C^^), • • •, C?^)) = (^(n), • • •, ^(n)) M a// n > 0 and hence, 
(^(oo)'---'^(^)) = (^(?x))'---'^('S)))' 
^ 
We introduce extensions of FO(IFP) and FO(LFP) which allow to speak 
about simultaneous fixed-points. On the one hand these extensions are quite 
useful when formalizing statements which involve fixed-point operations. On 
the other hand we shall show that they do not increase the expressive power. 
The formulas of Simultaneous Inflationary Fixed-Point Logic FO(S-IFP) are 
obtained by replacing the clause corresponding to IFP in the definition of 
FO(IFP) by 

176 
8. Logics with Fixed-Point Operators 
(+) 
[S-IFP^o,Xo,...,^,„,X^ ^0, . • • , ^m] t 
where m > 0, where for i — 0,..., m the arity of Xi equals the length of 
Xi, and where 1 has the same length as 'XQ. AS usual, the variables in each 
sequence Xi are distinct, but the same variable may occur in distinct ^^'s. 
A variable x is free in [S-IFP^Q,Xo,...,^m,Xn^ ^o, • • •, ^m] t^ if a: is in ^ or if for 
at least one i^ x is free in ^i and not in xi. We define the corresponding 
inflationary system (F^,..., F^) by 
F\Xo,...,Xm) 
~ 
Xi[j{Xi\ipi{Xi,XQ,...,Xra)] 
and let {F?^^^^..., Fr^^) be their simultaneous fixed-point. Then, by defini-
tion, [S-IFP^o,Xo,...,x^,x^ ^0, • •., v^m] ^ means t e F^^y 
Simultaneous Least Fixed-Point Logic FO(S-LFP) is defined analogously, 
clause (+) being restricted to formulas (/^o, • • • ,^m which are positive in all 
the variables XQ, ..., Xm- The system (F°,..., F^) of corresponding func-
tions is now defined by 
F\Xo,...,Xm) 
••= 
{Xi I 
^i{Xi,Xo,...,Xm)}-
By positivity, the system (F^,..., F^) is monotone; hence, by 8.1.17(b),(d), 
[S-lFF^^^Xo,...,Xm,Xm ^0, • • • ,^m]t 
expresses t e F^^y Since, by 8.1.17(c), 
(F^^),..., F^^) 
is the least fixed-point of (F^,..., F"^), we denote the for-
mula in {+) by [S-LFP^o,Xo,...,^m,x^ ^o, • • -,^m]t-^ 
Example 8.1.18 We consider digraphs. Let F and G be the functions cor-
responding to the FO(S-LFP)-formulas ipo and ipi that are positive in X 
(unary) and Y (binary), 
(po{x,X,Y) 
:= 
Yxx 
V?i(x,2/,X,r) 
:= 
Exy W 3z{Yxz 
AEzy). 
Then G(oo) is the transitive closure of the edge relation and F(oo) the set of 
vertices z such that there is a cycle through z. Hence, 
[S-LFFx^X,xy,Y ^0,^l]z 
expresses that there is a cycle through z. Clearly, [LFP^^^^x {Exy\/3z{Yxz 
A 
Ezy))]zz 
is equivalent to this formula. Note that there is no first-order 
formula ^(a:,X) positive in X with free variables among x^X such that 
[LFPa;^x il;\z expresses that there is a cycle through z. Otherwise, the for-
mula 32;[LFPa;,x 4^]^ expresses that there is a cycle. Now, 32;[LFPa;,x '^]z is 
^ Even though the system (F°,..., F"^) corresponding to an S-IFP operator and to 
an S-LFP operator have different definitions, they coincide on the parts relevant 
for our discussion, namely on the stages and on the fixed-points. 

8.2 Simultaneous Induction and Transitivity 
177 
equivalent to F^ ^ 0 and hence, to the first-order formula 3x'ip{x,^)^ 
But 
we know that there is no first-order formula expressing that there is a cycle 
(cf. 2.3.9). 
D 
Notes 8.1.19 Inflationary fixed-point logic goes back to Gurevich [70]. For 
least fixed-point logic cf. the notes to the next section. Theorem 8.1.13 is 
due to Gurevich and Shelah [76] and Theorem 8.1.14 to Immerman [91]. A 
further reference is [18]. 
8.2 Simultaneous Induction and Transitivity 
In the following, A will always denote a finite set with at least two elements. 
For b e A and i > 0 let 
¥ := 
h...h 
i times 
and let h be 6* for some i. The length of h will be irrelevant or clear from the 
context. If Z is an (k + /)-ary relation on A and a ^ A\ then the a-section 
Z_a of Z is given by 
Z_a 
:= 
{beA^\Zba}. 
Let m > 0 and 
F^ : Pow(A^o) X ... X Pow(^^-) -^ Pow(A^o) 
F^ : Pow(A^o) X ... X Pow(A^-) -^ Pow(A^i) 
F"^ : Pow(A^o) X ... X Pow(A^-) -^ Pow(^^-). 
We are going to code these operations as sections of a single operation J of 
higher arity. Setting 
(2) 
k := maxjfco,..., km} 4- (m -h 1) 
we define 
J : Pow(A^) -> Pow(A^) 
in such a way that if Jo, J i , . . . are the stages of J then for any a,b e A with 
a ^ 6, the a6*-section of Jn codes F^'., that is. 
'* The formula ip{x, 0) is obtained from ipix, X) by replacing each occurrence of an 
atomic formula Xt by -it = t. 
^ Hence, a has length k — i — ki. 

178 
8. Logics with Fixed-Point Operators 
Lemma 8.2.1 (Simultaneous Induction) Let F ^ , . . . , F'^ and k be as in 
(1) and (2) above. Define the function J : Fow{A^) -> Pow{A^), the simul-
taneous join of (F^,..., F^), by 
J{Z) := 
U 
((F0(Z_a60,..., Z_a6^) x {ab^}) U ... U 
(F^(Z_a60,..., Z_a6"^) x {a6^})). 
(a) For all 
n>0, 
Jn= 
U 
((^(n) X {«^'}) U ... U (F(-) X {a6-})). 
Therefore, the fixed-point Joo of J exists iff the simultaneous fixed-point 
(^(°oo)' • • •' ^{io)) exists. Moreover, 
Joo= 
U 
((^('oo) X {^b'}) U ... U (F(-) X {a6-})). 
r/zns, for i = 0,..., m anc? /or A// a, 6 G A m^/i a ^ b, 
hence, for c G A'^', 
in particular, for c G A^°, 
(*) 
FO„)C 
iff 
Jooca, 
(b) // (F^,..., F"^) 25 inductive then J is inductive. 
Proof We prove by induction on n that 
Jn= 
U 
(('P'W X {«''°}) U • • • U (F(-) X {56-})) 
a,bEA,a:^b 
(all the other claims in (a) and (b) are then immediate). The case n = 0 is 
clear. In the induction step we have Jn+i 
= 
J(Jn) 
= J{[Ja^,({Ffn) 
>< {«&"}) ^ • • • U (F(-) X {aft™}))) 
= U#6((^"(^(''„).---,i^w)xH°}) 
U...U(f'"(F0„),...,F(-))x{a6'"})) 
= 
liaM(K+l) 
X {«''")) U • • • U (F(™+i) X {56-})). 
D 

8.2 Simultaneous Induction and Transitivity 
179 
We come back to formulas and use the preceding lemma to prove that 
the extensions of FO(IFP) and FO(LFP) to the corresponding simultaneous 
fixed-point logics do not increase the expressive power. 
To simplify the presentation we consider only structures with at least two 
elements; in particular, we say that Lp and ip are equivalent and write 
Nfin V^ ^ V' 
if if and if) are equivalent in all structures with at least two elements. After 
8.2.11 we illustrate how this restriction can be removed. 
First some notations that will be used frequently in the next chapters. We 
write 
J=fin ^ ^ 3(V)a:^(a:), 
if if is equivalent to both 3xil){x) and \/xip{x). Then, for any term t, (p is 
equivalent to ip{t), a fact we often shall use tacitly. 
To speak about distinct sections of a simultaneous fixed-point process, we 
use, for / > 1 and z = 0,..., /, the formulas 5l{xi,... 
,xi,v, w) given by 
Sl(xi,... 
,Xi,v,w) 
:= 
^v = w A xi = ... — Xi = V 
and for z = 1,...,/ by 
Sl{xi,... 
,xi,v,w) 
:= 
->v = w A 
Xi = ... = xi-i = V A xi-i+i =1 ...= xi —w. 
We often omit the superscript / and write 5i{x^ u, v), I then being determined 
by the length of x. Note that for distinct a, 6 in a structure A, we have 
A \= Si[db^ab] iflF 
i = j . 
Furthermore, we use some more or less self-explanatory notations. For in-
stance, given a formula ^{X), 
we write ^{Y-y) 
for the formula obtained 
from ip by replacing each subformula Xt by Yty; of course, this presupposes 
that the arities of X and Y and the length of y match in the right way. 
Theorem 8.2.2 FO(S-LFP) = FO(LFP) and FO(S-IFP) = FO(IFP). 
Clearly, it suflfices to show that FO(S-LFP) < FO(LFP) and FO(S-IFP) 
< FO(IFP). The proof is by induction on formulas, the only nontrivial case 
being handled by the next lemma. 
Lemma 8.2.3 (Simultaneous Induction for LFP and IFP) Let 
Xm)-> • • • 5 ^miXmi 
XQ^ . . . , Xm) 
he formulas of FO(LFP), where Xi is ki-ary and the length of Xi is ki. 
Furthermore, assume that (po^..., (p^n CLf^. all positive in XQ,..., 
Xm - Set 

180 
8. Logics with Fixed-Point Operators 
k := max{A:o,..., A^m} + (m + 1) and, using new variables v and w, define 
the FO{LFF)-formula xji^i, 
^ -. ,Zk, Z) by 
Xj{zi,...,Zk,Z) 
:= 3v3w{-^v = wA 
{{ipo{zi, . . . , Zko: Z-VW^, 
. . . , Z-.VW'^) 
A So{Zko + 
l,'-',Zk,V,w)) 
V{ipi{zi,...,Zk^,Z-VW^,...,Z^vw'^) 
A 
Si{zk^+i,...,Zk,v,w)) 
V {(fmiZl, 
. . . , Zk^, Z-VW^, 
. . . , Z-VW"^) 
A 5m(zkm+l^ 
• • • ^ 
Zk,V,w)))). 
Then, for any new variable u, 
// ipQ^...^ipm are first-order {existential) formulas then XJ ^^ first-order 
{existential), too. Moreover, 
free(xj) C {z} U {hee{ipo) \ {x^}) U ... U (free((/:'^) \ {^^}). 
Without the assumption that (po,- • -, ^m cbre all positive in XQ, ..., Xm the 
claims are true if LFP is replaced by IFP everywhere. 
Proof. First, we turn to the LFP-case. For i = 0,... ,m define 
F\XQ,...,Xm) 
:= {Xi I 
^i{Xi,Xo,...,Xm)}. 
Then, XJ (which is positive in Z) defines the simultaneous join of (F°,..., F^) 
as introduced in Lemma 8.2.1. Since [S-LFP^Q,XO,...,^m,^m V^o, • • • ^^m\i ex-
presses F9^t and [LFP^^^Xj]^^ expresses Jooiu, the claim follows immedi-
ately from (*) in part (a) of 8.2.1. 
In the the IFP-case, for i = 0,..., m we define F* by 
F^(Xo,...,X^) 
:= 
XiiJ{xi\^i{xi,XQ,...,Xm)}. 
Let J be the simultaneous join of {F^,...^F^) 
(cf. 8.2.1(a)). One easily 
verifies that F^^^"^^-^^ defines J' where J'{Z) := Z U J{Z). Recall that 
[IFPj,2^XJ]^W means J'^tu. 
Since ( F ° , . . . , F ^ ) is inflationary and hence, 
inductive, J is inductive (cf. 8.2.1(b)). Therefore, J ^ = Jo© (cf. 8.1.2(c)). 
Thus [IFP^,^XJ]^W expresses Jootu which, by (*) in 8.2.1(a), is equivalent to 
F?^^t^ that is, to 
[S-IFP^o,Xo,...,^nx,X^ ^0, • • • , ^m] t- 
• 
As a first application we present a lemma which will frequently be used 
in the following. 

8.2 Simultaneous Induction and Transitivity 
181 
Lemma 8.2.4 Every FO{LFF)-formula 
[LFPy^y ^]^ with first-order (p is 
equivalent to a formula of the form, 
30^)u[LFF^,z^P]u 
with first-order ip. If (p is existential then -0 can be chosen existential, too. 
The claim and the following proof remain true if LFP is replaced by IFP 
everywhere. 
As the proof will show, we may require in addition - and will often do 
so tacitly - that u does not occur free in ip and that the free variables of 
3{\/)u[LFFz,z ^ ] ^ are among the free variables in [LFP^^y (p\ t. 
Proof. Set ipQ{x^X^Y) :— Yt with dummy variables x and X. We show, for 
a new variable v^ 
(+) 
N n [LFP^,y ip\t^ 
[S-LFP^,x,y,y ^0, ^] V. 
This yields the claim: By the Lemma on Simultaneous Induction for LFP the 
formula on the right side is equivalent to one of the form 3(V)^x[LFPj^^ ip]vu 
with first-order ^ and v ^ free(V^) (moreover, ij; is existential if if is existen-
tial). Hence, 
Hfin [LFP^,y if] t ^ 3(V)l/[LFP^,z ^]VU 
and therefore, as i; ^ free([LFPy,y (/?]^), 
Hfin [LFP^,y if] t ^ 3(V)^[LFP^,z i^]u. 
To prove (-h), consider the functions F and G corresponding to (/?o and (/?, 
respectively, 
F(X,Y) 
= {x\<po{x,X,Y)} 
and 
G(X,Y) 
= 
{y\^{y,Y)]. 
For the simultaneous fixed-point (i^(oo)5 G^(oo)) we immediately get 
"universe" 
if G(^oo)t 
ij) 
otherwise. 
Hence for 
which is a 
<^(oo) 
any ^;, 
— p'^ and 
F(oo) = 
t^F^ 
, reformulation of (-I-). 
iff 
V eFi 
(oo)' 
n 
One of our aims is to prove that any formula of FO(LFP) is equivalent to 
a formula containing only one LFP operation. As an essential step we have to 
express nested fixed-points by single ones. To do so we need a further result, 
the so-called Transitivity Lemma. It shows how the fixed-point of nested 
monotone operations can be expressed by a simultaneous fixed-point. 

182 
8. Logics with Fixed-Point Operators 
Lemma 8.2.5 (Transitivity) Let {F,G) be monotone, where 
F : Pow(A^) X Pow(^0 -> Pow(A^) 
G : Pow(A^) X Pow(^0 "> POW(AO 
and let E : Pow(^^) -> Pow(A^) be given by 
E{X) 
:= 
F(X,G(X,_)oo), 
where G{X,- ) : Pow(A^) —>• Pow(A^) denotes the monotone operation Y i-)-
G{X,Y) 
and G{X,-)oo 
denotes its least fixed-point. Then E is monotone 
and Eoo = i^(oo) • 
Proof. The monotonicity of E is clear. To prove Eoo — -^(oo) we show 
(1) 
^(F(oo)) C F(oo) (hence, Eoo C F^^o) by part (b) of 8.1.2). 
(2) 
For all n, Fi^ri) Q E^o and G(^) C G{Eoo,- )oo (hence, F(oo) C ^Joo). 
For (1) we note 
^(•^(oo)) 
= 
^(^(oo)5<J^(^(oo)5- )oo) C F(F(oo),G(oo)) 
(since G^(F(oo),<^(oo)) = <^(oo) we have G(F(oo),_ )oo C G(oo)) 
- 
F(oo). 
(2) is proved by induction: Clearly, the inclusions hold for n — 0. In the 
induction step we have 
F{n+i) 
= 
^(^(n),<^(n)) Q F{Eoo,G{Eoo,- )oo) (by induction hypothesis) 
= 
E{Eoo) = Eoo 
and 
G(n+1) 
= 
G{F(n)^G(^n)) 
Q G{EooyG{Eoo,-)oo) 
= G{Eoo,-)oo' 
Q 
Using the Lemma on Simultaneous Induction for LFP, the preceding 
lemma gives 
Lemma 8.2.6 (Transitivity for LFP) Let ip{x,X,Y) 
and ip{y,X,Y) 
be 
first-order formulas that are positive in X and Y. Moreover, assume that 
no individual variable free in [LFPy,yi/'(^, X, F)], that is, free in ij) and dis-
tinct from y, gets into the scope of a corresponding quantifier or LFF operator 
in (*). Then 
(*) 
[LFP^,x</:^(^, X, [LFFy^Yi^iy, X, Y)])] i 
is equivalent to a formula of the form 
with first-order x-

8.2 Simultaneous Induction and Transitivity 
183 
Proof. Define F and G by 
F{X,Y) 
'.^ {x\^{x,X,Y)} 
and G{X,Y) 
- 
{y 
\,l^{y,X,Y)}. 
Then the corresponding E in the Transitivity Lemma is given by 
PE{X,X) 
:= 
<p{x,X,[LFPy,YiP{y,X,Y)]). 
Since Eoo — -^(oo) ? we have 
By 8.2.3, the formula on the right side is equivalent to [LFP^,zXo]^^ for 
suitable first-order xo and hence, by 8.2.4, to one of the desired form. 
D 
In a first step towards a proof of 8.1.14 we use the Transitivity Lemma 
to settle the case of FO(LFP)-formulas with only positive occurrences of the 
LFP operator. 
Lemma 8.2.7 Every FO{LFF)-formula 
cp containing only positive occur-
rences of the LFP operator {i.e., each LFP operator in ^ is in the scope 
of an even number of negation symbols) is equivalent to a formula of the 
form 
3{\/)u[LFFj^z4^]u 
where ij) is first-order. 
Proof. By 8.2.4 it suffices to give a representation of ip in the form 
[LFP5,zV]t 
with first-order ^. We use the connectives -i. A, V and the quantifiers V and 
3. Then, by hypothesis, we can assume that all negation symbols in ip are in 
front of atomic formulas. We proceed by induction on if. 
If if is atomic or the negation of an atomic formula then 
Nfin ^ ^ [LFPa;,x ^] X 
for any dummy variables x and X. 
Suppose ip = {ifi Aip2). By induction hypothesis we can assume that 
ipi = [LFP^,x ^1 (x, X)] s 
and 
ip2 = [LFP^,y ^2 {y, Y)] t 
with first-order -01 and ip2- Moreover, we can assume that no variable in x 
occurs in ^2- Then one easily verifies that 
N n (^1 A(p2) ^ [LFF^^x{Mx,X) 
A 
[LFFy,YMy,Y)]i)]s 

184 
8. Logics with Fixed-Point Operators 
which, by the Transitivity Lemma 8.2.6 (for ^{x^ X, Y) :— ijji {x, X) A Yt and 
for ip{y, X, Y) := ip2{y, ^)), is equivalent to a formula of the desired form. 
The proof for y^ = {^i ^ ^2) is completely analogous. 
Suppose that ^ = ^vipi. By induction hypothesis we can assume that cp = 
\/v[LFFy^Y i^i]t with a first-order formula I/JI and, by 8.1.12(b), that the 
variables free in t/^i are among y. By 8.1.12(a), for dummy x and X, 
H n ^ ^ [LFP^,x V^[LFP^,y ^1] i] V. 
By the Transitivity Lemma (for (p{x,X,Y) 
:= \/vYt and ^(^,X,F) :— ipi), 
this formula is equivalent to a formula of the form claimed. 
The proof for ip = 3vil)i is completely analogous. 
Finally suppose that 
if = [LFP^^x ^i]t 
where, by induction hypothesis, we may assume that cpi = [LFPy^y ipi] s with 
first-order ^1 and, by 8.1.12(b), that no variable in x is free in [LFP^^y ^1]. 
Hence, 
(^ = [LFP^,x[LFP^,y^i]s]i. 
Once more, the Transitivity Lemma (for the formulas (p{x,X,Y) 
:= Fs and 
ip{y,X,Y) 
:= -^i) yields the desired form. 
D 
We now want to extend the preceding lemma to arbitrary formulas of 
FO(LFP). This will easily be obtained by the methods we are going to develop 
in order to show that every FO(IFP)-formula is equivalent to an FO(LFP)-
formula. So we turn to this problem next. 
Let ip{x, X) be an FO(LFP)-formula. Recall that [IFP^,x^(^, X)] t expresses 
that t e i7P^-vv.(^,x))_ ^^^^ ^^^^ ^ 
may occur positively and negatively in 
(Xx V (p). Replace all (free) negative occurrences of X by -^Y (where y is a 
new variable), thus getting an FO(LFP)-formula ip(x, X, Y), which is positive 
in X and Y, such that 
(*) 
{Xxy ip{x,X)) 
is (equivalent to) 
ip{x,X,-^X) 
(for example, if (^(a;, 2/,X) = -^3u{-^Xxu\/Xuy),themp{x,y,X,Y) 
— {XxyV 
-^3u{^Xxu V -^Yuy))). Since V^ is positive in X and Y, the function 
L{X,Y) 
:= 
{x\i;{x,X,Y)} 
is monotone (cf. 8.1.6). We set H{X) := L(X,X^).6 Then H = F^(^.^'-^) = 
p(XxV(p(x,x)) ^^^ therefore, H is inflationary. We are going to show how 
the fixed-point of H can be expressed in terms of two relations, the "stage 
For X C M, X"" denotes the complement 
M\X. 

8.2 Simultaneous Induction and Transitivity 
185 
comparison relations". These relations can be obtained as simultaneous fixed-
points of positive formulas and thus, by Simultaneous Induction for FO(LFP), 
as a fixed-point of a positive formula, i.e., by an FO(LFP)-formula. Once more 
we study parts of the problem on a more abstract level. 
First we introduce the rank function \ \H and the stage comparison relations 
<H and -<H associated with an arbitrary inductive H : Pow(M) -^ Pow(M) 
(with finite M). We define | |H : M ^ N U {00} by 
11 
_ j n 
if 
ae 
Hn\Hn-i 
l""'^ •" \ 00 
if 
a^Hoo 
and the binary relations <H and -<H on M hj 
a <H h 
iff 
a^h ^ iJoo and \a\H < \b\H 
a -<H h 
iff 
a e Hoo and \a\H < |&|if, 
where, by definition, n < 00 for n G N. 
Parts (a) - (e) of the next lemma are immediate from the definitions. 
Lemma 8.2.8 (a) 
a E Hoo 
iff 
CL <H a-
(b) For a G i?oo; 
{u I u <H ay := {u\ a -<H u}. 
(c) a<H b iff a,b e Hi W 3e{e ^H b A a,b e H{{u \ u <H e})) 
(in words: a <H b iff both a, 6 are contained in the first stage Hi or 
there is a stage not containing b such that a and b are members of the 
next stage). 
(d) 
a^Hb 
iff 
{aeHiAb^Hi)W3e{e<HeA 
a e H{{u \ u <H e}) A b ^ H({u \ u <H e})). 
(e) //no > 1 and Hoo = Hno # i/no-i then 
a^Hoo 
iff 
36 (b G Hno \ Hno-i /^b^H a). 
(f) //no > 1 and Hoo = Hno 7^ Hno-1 then 
beHno\ 
Hno-1 
iff 
^e(e<HbVe^ 
H({u \ u <H b})). 
Proof, (f) First assume that b satisfies the right side. Then, b G Hoo, as 
otherwise, for all e, e ^ H({u \ u <H b}) = H(fh) = Hi, hence, Hi — ^ — Hoo, 
a contradiction. If 6 G Hn \ Hn-i for some n < no, then no e G Hn+i \ Hn 
would satisfy (e <H 6 V e ^ H{{u \ u <H 6})), a contradiction. Conversely, 
suppose b G Hno \ Hno-i and let e be arbitrary: if e G Hoo then e <H b; if 
e^ Hoo then e ^ H{{u \ u <H b}). 
D 

186 
8. Logics with Fixed-Point Operators 
Now suppose that for the inductive function H there is a monotone func-
tion L : Pow(M) X Pow(M) -)• Pow(M) such that 
for all X C M , 
H{X) = 
L{X,X'). 
Then the operation L : Pow(M) x Pow(M) -> Pow(M) which is given by 
for all X, r C M, 
L(X, Y) := {L{X', F^))" 
is monotone, too: If Xi C X2 and Yi C Y2 we obtain stepwise 
X^ C Xl^ Y,^ C Y{, L{XIY^') 
C L{XIY{), 
L{X,,Y,) 
C 
Ux^^Y^). 
Using part (b) of the preceding lemma we can rewrite parts (c) and (d) as 
(c') 
a<Hh 
iff 
a.heHiy 
^e{e-<Hh^ 
a,b e L{{u I u <H e},{u\ 
e -<H U})) 
(d') 
a^nb 
iff 
{a e Hi A b ^ Hi) W 3e{e <H eA 
a G L{{u I u <H e}, {u \ e -<H U}) A 
b G L{{u I e -<i/ u), {u\u<H 
e})). 
We now define operations F, G : Pow(M^) x Pow(M^) -^ Pow(M^) in such 
a way that 
F{<H,-<H)=<H 
and 
G{<H,<H) 
=^H 
• 
(c') and (d') show that this is achieved by setting (we use notations such as 
a F{U, V) b for (a, b) G F{U, V)) 
(1) aF{U,V)b 
iff 
a,beHiy 
3e{eVb 
Aa,beL{.Ue,eV-)) 
(2) aG(C/,y)6 
iff 
(a G ill A b ^ Hi) W 3e{eUeA 
a G L(_C/e, eV_) A 6 G L{eV-, 
.Ue)). 
By monotonicity of L and L, the functions F and G are monotone, too. Once 
more, we define F(yj) and G(^) by 
F(o) : = 0, G(o) ••= 0, 
F(^n+l) '•= F{F(n)^G(^n))i 
G^(n+1) •= G(F(^n) ^ G(n))• 
Then we have 
(3) 
aF(^) 6 
iff 
a,be HnAa<H 
b 
(4) 
a G^(n) ^ 
iff 
a e Hn Aa -<H b. 
The proof is by simultaneous induction, the induction step for (3) being: 

8.2 Simultaneous Induction and Transitivity 
187 
aF(^+i)6 
iff 
aF(F(^),G(^))6 
iff 
a, 6 G iJi V 3e{eG(^ri) b A a^b e I/(_F(^)e, eG(^n)-)) 
iff 
a,b e Hi V 3e (e e Hn A e ^H b A 
a,be L{{u \u<H e},{u\e 
-^H u})) (by ind. fiyp.) 
iff 
a,b e Hi V 3e {e e Hn A e ^H b A 
a,b e H{{u I u <H e}) 
(by choice of L) 
iff 
a, 6 G Hn+i and a <H b (by definition of i^n+i)-
From (3) and (4) we get 
(5) 
(^(00)5<^(00)) = 
( < / f 5 - < i f ) -
Thus {<H^<H) 
is the simultaneous fixed-point of the monotone system 
{F,G). 
We come back to our original aim of expressing the result of an IFP operation 
by an application of the LFP operator. 
Suppose that ipix^X) is an F0(LFP)-formula. Choose an FO(LFP)-formula 
ip^x^X^Y) positive in X and Y such that 
{Xx\/^{x,X)) 
and 
^p{x,X,-^X) 
are equivalent. As (the inductive) H and (the monotone) L of the preceding 
discussion take the operations given by 
H{X) := {x\Xxy 
ip[x,X)] 
and 
L(X, Y) := {x \ ^(^,X,F)}, 
respectively. Then H{X) = L(X,X^), L{X, Y) = {x \ --^p{x, -X, - F ) } , and 
-'ipix, -"X, -iF) is positive in X and Y. The first stage Hi of iJ is defined 
by (/?(^, 0), where <p(^, 0) is obtained from ip{x,X) by replacing each occur-
rence of an atomic part of the form Xt by ->ti = ti. By (1) and (2), the 
corresponding operations F and G can be defined by the FO(LFP)-formulas 
eix, y,U,V) 
:= 
{ip{x, 0) A ip{y, 0)) V 3^ {zVy A 
ip{x,- Uz,zV-) 
A il^{y,- 
Uz,zV-)) 
S{x, y, U,V) 
:= 
{if{x, 0) A -i(p(y, 0)) V 3^ {zUz A 
ipix,- Uz.zV-) 
A 
^ip{y,-^zV-,^-Uz)), 
respectively. Both are positive in U, V. As {<H, -<H) — (-^(oo)? G^(oo)) by (5), 
the relations <H and -<H are definable by 
ip<jj{x,y) 
:= 
[S-LFF^ 
y^u,xy,ve,S]xy, 
^<H{x,y) 
'•= 
[S-LFF^ 
y^v,xy,uS,e]xy, 

188 
8. Logics with Fixed-Point Operators 
respectively. By 8.2.3 there are FO(LFP)-formulas 4'<^ and ip^^ such that 
Nfin ip<H{x,y) ^ 3(V)ii[LFP^,z'0<H]^, 
N n <^^H{x,y) ^ 
3(V)W[LFP^,Z^^H]^-
Finally, using part (a) of 8.2.8, we get that 
Altogether, we can replace an IFP operation by an equivalent LFP operation. 
This immediately allows us to handle the only nontrivial step of an inductive 
proof of Theorem 8.1.13. 
With the following considerations we turn to the proof of Theorem 8.1.14. 
First, we show that every formula -i[LFP^,x ^{x,X)]t 
with first-order ^ is 
equivalent to an FO(LFP)-formula containing only positive occurrences of 
the LFP operator. So let (p{x,X) be first-order. Then, the formulas e and 
S are first-order and, by 8.2.3, ip<jj and ^^^^ can be chosen first-order. If 
no > 1 and HQQ = Hno ¥" HUQ-I then, by 8.2.8(f) and by the definition of L, 
we have 
beHno\ 
Hno-1 
iff Ve (e <// 6 V e G L{{u \ b -(H U}, {U\U<H 
b})). 
Thus, 'z G Hno \ Hno-i can be expressed by 
V^max(^) 
: = 
Vi;((^<^(^;,^) V ^V'(^, ^ ^ ^ ^ ( ^ 5 - 
) . ^ ^ < H ( - 5 ^ ) ) -
Together with 8.2.8(e) we get the equivalence of ->[LFP^,x i^{x^X)\t 
and 
(*) 
^X-^ip{x, 
0) V {^Xip{x, 
0) A 3^(vPn,ax(^) A ^^^ 
{z,t))). 
Since (/9<^ and cp^^ only contain positive occurrences of the LFP operator, 
the same applies to the formula in (*). 
Thus, every FO(LFP)-formula is equivalent to one with only positive occur-
rences of LFP. In view of Lemma 8.2.7 this finishes the proof of 8.1.14 and, 
in fact, gives the following strengthening of it: 
Theorem 8.2.9 For every FO(LFF)-formula ip there is a first-order formula 
ip such that 
^fin ^^^{^)u[hFF-,^z^]u. 
U 
Corollary 8.2.10 For every FO(LFF)-formula (p with free variables among 
with n > 1 there are first-order formulas ipo^'^i "^i^h free indi-
vidual variables among x and y, respectively, such that 
Nfin ^{x) ^ [S-LFP^,x,y,y^o,^i]^-

8.2 Simultaneous Induction and Transitivity 
189 
Proof. With the preceding theorem choose a first-order formula 
ip{x,'z,Z) 
such that if and 3(V)i/[LFP^,^ ^l^] u are equivalent. We can assume that {z} fi 
{x} = 0 and that the free individual variables of -0 are among Wz. Let Y be 
of arity length(^)+length(2'). Then 
il)o{x,X,Y) 
:= 
Yxxi 
IIJI{X,Z,X,Y) 
:= 
i;{x,z,Yx-) 
satisfy the claim, where y = x'z. 
D 
We saw in 8.1.18 that in the preceding corollary we cannot replace the for-
mula [S-LFP^,x,y,y V^o, V^i] ^ by a formula of the form [LFP^^x '0] 'x'- a coun-
terexample is given by a formula ip{x) expressing in digraphs that there is a 
cycle through x. 
Exercise 8.2.11 Consider a formula x — 3(V)w[IFP^^xV^]^ where if is 
first-order and Hi (cf. page 7). Show that x is equivalent to a formula 
3(V)w[LFP^,zp]^ where p is first-order and A2 (that is, equivalent to a E2-
formula and to a n2-formula). Hint: Assume that (/9 is a Ei-formula and let 
ip^e^5 be as in the exposition following 8.2.8. Then t is equivalent to a Si-
formula and (^ to a S2-formula; hence, the corresponding V'<H is equivalent 
to a S2-formula. To obtain a 112 representation, note that 8.2.8(d) can be 
replaced by 
a -<H b 
iff 
(a <H a A b ^ HI) A 
Ve(a <H eV a-<H eWb^ H{{u \ u <H e})). 
Therefore, as S{x,y, U, V) we can use the Ili-formula 
xUx A -^(p{y, 0) A \/z{xUz V xVz V ^i^{y, 
-^zV-,^-Uz)). 
Then the corresponding XJ is equivalent to a n2-formula (note that XJ has 
the form 3v3w{^v = w A 6), but is equivalent to \/vyw{^v = w ^ 0). An 
inspection of the proof of 8.2.4 shows that we get a A2-formula if we start 
from a A2-formula. 
n 
As promised, we now show how one can remove the (tacitly assumed) 
restriction to structures with at least two elements. As an example we take 
the preceding theorem (Theorem 8.2,9). First of all we note that in structures 
with only one element the formulas 
[LFF^^vx{y.V)]i 
and x(^,0) 
are equivalent. Hence, for every FO(LFP)-formula p there is a first-order 
formula p* equivalent to it in these structures. Now, given (p G FO(LFP), 
we use the preceding theorem to choose a first-order -0 such that (p and 
3{\/)u[LFPj^z '4^]u are equivalent in structures with at least two elements. 

190 
8. Logics with Fixed-Point Operators 
Then, for new x and y, the formulas cp and 3(V)u[LFP^^^ i^xMyx = y Aip*) V 
{3x3y-^x = y A ip)] u are equivalent in any finite structure. 
We close this section by giving a further result demonstrating the value of si-
multaneous fixed-point logic: We show that, on ordered structures, it captures 
the class of polynomial time computable functions in terms of the stages of 
simultaneous fixed-points. First we introduce the corresponding terminology. 
Let 
ipo(xo,Xo, 
. . . ,Xm), 
. • • ,(Pm(Xm,Xo, 
. . . , Xm) 
be first-order formulas that are positive in Xo,...,X^, where arity(X^) = 
length(^i) for i < m. Given a structure A, let F ° , . . . , F^ be the functions 
corresponding to ipo,... ,ipi 
1 ^rrii 
F'{Xo,...,Xm) 
= 
{Xi I 
ipi{Xi,Xo,...,Xm)}-
For i < m, let |(/?i|(^) be the number of different stages of F% more precisely, 
\^i\(A) 
:= 
||{n|F^)#i^„+i)}||. 
Clearly, the function A i-)- |(/?i|(v4) is a function computable in polynomial 
time. A converse is also true: 
Theorem 8.2.12 Let <£ T and let K be a class of ordered r-structures in 
PTIME. Then for every function f : K -^ N computable in polynomial time^ 
there are first-order formulas (po{xo,Xo,..., 
Xm),- • •, (pm{xm,Xo,..., 
Xm) 
that are positive in XQ, .. .,Xm 
such that for all A £ K with at least two 
elements, 
f{A) = MiA). 
Proof. Since / is computable in polynomial time, there is an r such that 
f{A) < mil^ for all ^ G K with at least two elements. For j < \\A\\'' let \j\r 
be the j-th. r-tuple in the lexicographic ordering of A^. By assumption, the 
class 
{{A,ai,...,ar) 
\AeK, 
\f{A)\r = (ai,... ,a,.)} 
is in PTIME. Hence, by 7.3.4 and 8.1.13, there is a formula (p{xi,... ,Xr) of 
FO(LFP) such that for any ordered structure B and b £ B^, 
B ^ (/?[6] 
iff 
BeK 
3iidb= 
\f{B)\r. 
By 8.2.10, we obtain first-order formulas t/?o(^, X, F),'0i(^, X, F) that are 
positive in X, F such that ip{x) and [S-LFP^,x,i7,y V^c'^i]^ are equivalent. 
To get the desired representation of f{A)^ we construct a simultaneous fixed-
point process, where the stages of the first component Z (of arity r) suc-
cessively take up the r-tuples in lexicographic order that are smaller than 
|/(^)|r as soon as |/(v4)|r. gets into X. 
We assume that A = B implies f{A) = f{B). 

8.3 Partial Fixed-Point Logic 
191 
We set 
ip{z,Z,X,Y) 
:= 
3x(Xx 
Az <x A 
{'z = min V 3u{Zu A ^ = u-\- 1))). 
For the system ip('z, Z, X, Y), -00(^5 Z, X, Y), ipi {y, Z, X, Y) one easily verifies 
that f{A) = W{A). 
D 
In the preceding theorem we cannot replace (/?o, • • •, ^m by a single for-
mula. To give a counterexample, we consider the function / defined on the 
class of ordered graphs by 
j , . ^ . 
J 1 if ^ is connected 
j{y) •" I 0 
otherwise. 
Suppose that, for some first-order formula ip{x,X) positive in X, we have 
f{Q) = MiG)- Then, Q is connected iff F^ 7^ 0. But F ^ 7^ 0 is equivalent 
to F^ / 0. Hence, Q is connected iff ^ is a model of 3x(p{x, 0). But we saw 
in 2.3.7 that the class of finite connected ordered graphs is not first-order 
axiomatizable. 
Notes 8.2.13 The book [122] contains the first systematic study of least 
fixed-point operators (in the context of infinite structures); in particular, 
in this book the Lemma on Simultaneous Induction and the Transitivity 
Lemma are proven and the stage comparison relations are introduced. The 
result of Exercise 8.2.11 is due to Dahlhaus [23], Theorem 8.2.12 to Kolaitis 
and Thakur [103]. 
8.3 Partial Fixed-Point Logic 
In Chapter 7 a further fixed-point logic turned out to be relevant, namely 
partial fixed-point logic, its importance being documented by the fact that, 
in ordered structures, exactly the queries computable in polynomial space are 
expressible in partial fixed-point logic. In this section we recall the definition 
of partial fixed-point logic, discuss the scope of totally defined fixed-points, 
and show that every formula of partial fixed-point logic is equivalent to a 
formula containing exactly one occurrence of the PFP operator. 
Partial Fixed-Point Logic FO(PFP) contains first-order logic and "FQO for 
any definable F": For a vocabulary r the class of formulas of FO(PFP) of 
vocabulary r is given by the calculus 
where (p is an atomic second-order formula over r 
LP 
(p,il; 
Lf 
!(/? 
((/? V ip) 
3xip 

192 
8. Logics with Fixed-Point Operators 
where the lengths of x and t are the same and 
L 
x,x^\ 
coincide with the arity of X. 
The semantics is defined inductively w.r.t. this calculus, the meaning of 
\P¥Vx,x^]t 
being t G F^. In particular, [PFP^^x^]^ is false if the fixed-
point of F"^ does not exist. All other definitions and conventions are as for 
FO(LFP). 
Clearly, we have 
Proposition 8.3.1 FO(LFP) < FO(PFP). 
D 
Consider, for example, orderings as {<, 5, min, max}-structures. Then the 
sentence 3a: [PFPa;,x ^(a^, X)] x where 
il){x^X) = (Wy^XyAx 
= min) V (X max A a; = 
m.aix)\/3y{XyA3u{SyuASux)) 
just holds in orderings of odd length. 
As a further example consider the formula 
[PFF^,x 3y{^Xy A Exy)]x. 
By 8.1.5(b), in digraphs it expresses, at the same time, that x is won for 
player I and that there are no drawn points. By 8.1.10(b) we see that this 
formula is equivalent to an FO(LFP)-formula. This result is generalized in 
the following (cf. 8.1.5(a)) 
Exercise 8.3.2 Assume that ip{x,X) is an FO(LFP)-formula negative in X 
and that X does not occur in the scope of any LFP operator. Then 
- ip{x,X) := (p{x,(p{-,X)) 
is an FO(LFP)-formula positive in X. 
- F"^ is antitone and F ^ = F^ o F^. 
- The "FO(LFP,PFP)"-formula [PFP^,x ^{x,X)]tis 
equivalent to the for-
mula of FO (LFP) 
V^([LFP^,x i^]x^ 
[GFP^,x V^] x) A [LFP^,x V'] t. 
D 
We aim at showing 
Theorem 8.3.3 Every FO(PFF)-formula 
is equivalent to an FO(PFP)-
formula with at most one occurrence of FFF. 
We shall point out similarities and differences to the proof of the corre-
sponding result for FO(LFP). As there, we start by introducing Simultaneous 
Partial Fixed-Point Logic FO(S-PFP) and by showing that it has not more 
expressive power than FO(PFP), even though it will turn out to be a valuable 
tool in many considerations. 
The formulas of FO(S-PFP) are obtained by replacing the PFP rule above 
by 

8.3 Partial Fixed-Point Logic 
193 
[S-FFF^o,Xo,...,Xm,Xm 
V^O, • • . , ^m] t 
where m > 0, where for i — 0,... ,m the arity of Xi equals the length of 
'Xi^ and where t has the same length as ^o- As usual, the variables in each 
sequence 'Xi are distinct, but the same variable may occur in distinct 'xis. A 
variable x is free in [S-PFP^o,Xo,..,^m,^m ^o, • • •, V^m] t^ if x occurs in t or if 
for at least one i, x is free in ipi and not in xi. Introducing F ^ , . . . , F^ by 
F'(Xo,...,X^) 
\= 
{Xi\Lpi[Xi,Xo,...,Xm)}, 
the meaning of [S-PFP^o,Xo,...,^m,x^ 9^o, • • •, ^m] t is defined to be ^ G F^^y 
Once more, for simplicity, we restrict ourselves to structures with at least two 
elements. 
Theorem 8.3.4 FO(PFP) = FO(S-PFP). 
The proof of FO(S-PFP) < FO(PFP) is by induction on formulas, the 
main step being taken care of by the following lemma. 
Lemma 8.3.5 (Simultaneous Induction for PFP) Let 
ipo{xo,Xo, 
. . . ,Xm), 
• • • ,^m{XmyXo, 
• • • , ^ m ) 
be formulas of FO(PFP), where Xi is ki-ary and the length of Xi is ki. 
Set k := m.ax{ko,... ,km} + (m + 1) and define the 
FO(PFP)-formula 
Xj{zi,...,Zk,Z) 
by^ 
Xj{zi,...,Zk,Z) 
:= 3v3w{^v = wA 
{(ipo{zi,..,, 
Zko, Z-VW^,..., Z-Vw"^) A 
6o{zko+i,'-',Zk,v,w)) 
\/(ipi{zi,...,Zk^,Z-VW^,...,Z-Vw'^) 
A 
Si{zk^+i,...,Zk,v,w)) 
V ((fm{zi, 
. . . , Zk^, Z-VW^, 
. . . , Z-VW"^) 
A 
Sm{Zk^+i,...,Zk,V,w)))). 
Then, for any new variable u, 
H n 
[S-PFP^,,Xo,...,^^,X^ ^o,--^,^m]t^ 
3(V)t/[PFP^,Z X J ] ^^• 
If (po,..., (prn «^e first-order formulas then XJ ^^ first-order. Moreover, given 
a structure and an assignment to variables, the simultaneous fixed-point of 
the PFP operation of the formula on the right side in the equivalence above 
exists iff the fixed-point of the PFP operation on the left side exists. 
The lemma is a literal translation of the Lemma on Simultaneous Induc-
tion for LFP (cf. 8.2.3), and also the proof can be translated; of course, here 
we do not have the assumption that the formulas are positive in the second-
order variables and hence, the same applies to XJ- The additional claim on 
the existence of the fixed-point immediately follows from 8.2.1(a). 
D 
Also the proof of 8.2.4 can be literally translated and gives 
^ For the definition of Si see page 179. 

194 
8. Logics with Fixed-Point Operators 
Lemma 8.3.6 Every FO{FFP)-formula 
[FFFy^y ^]t with first-order ^ is 
equivalent to a formula of the form 
3{\/)u[FFF^^zip]u 
with first-order ^l). If if is existential thenip can be chosen existential, too. For 
a given structure and assignment, if F^ exists then so does F^. 
Furthermore, 
we may require that u does not occur free in ^ and that the free variables of 
3(\/)u[FFFj^z 'ip]u are among the free variables of [FFFy^y ^]t. 
• 
In the proof of the Transitivity Lemma for LFP we have made essential 
use of the monotonicity of the operations in question, so it does not translate 
to the present case. However, it is easy to derive a version of the Transitivity 
Lemma for PFP (see 8.3.10 below), if we restrict ourselves to formulas whose 
fixed-points always exist. For this purpose call a formula of FO(PFP) totally 
defined, if for all its subformulas of the form [PFP^^x V'] i the fixed-point F^ 
exists in every structure and for all assignments. 
Exercise 8.3.7 Show, using Trahtenbrot's theorem, that it is not decidable 
whether an FO(PFP)-formula is totally defined. 
D 
Nevertheless we can show: 
Proposition 8.3.8 For every FO(PFF)-formula ip there is an equivalent to-
tally defined FO(FFF)-formula ip. If (p has the form [PFP^^x y^']t with first-
order ^' then ip can be chosen of the form [PFP^^x ^'] s with first-order ip'. 
For the proof we need the following 
Lemma 8.3.9 Assume M is finite. Let F : Pow(M) -> Pow(M). Then there 
is an I > 1 such that Fi = F2.1. 
Proof. By finiteness of M, the sequence Fo,Fi,... 
must become periodic (cf. 
7.1.1(a)). So there are no and IQ > 1 such that Fm = Fm+io holds for all m > 
no. Choose s such that I := s - IQ > UQ. Then Fi = Fg-i^ = Fs-io+s-h = ^2Z-
D 
Proof (of 8.3.8). The proof proceeds by induction on FO(PFP)-formulas, the 
main step being the PFP operator. So let [PFP^,x x] t be given and suppose, 
by induction hypothesis, that x is totally defined. Consider the function F^ 
for a given structure A and an assignment of values to the parameters. Set 
Xn := F^ and XQO := F^. Choose the smallest / > 1 such that X2.1 = Xi. 
We consider the sequences {Yn)n>o, {^n)n>o, and {Wn)n>o, whose values are 
shown by the following table: 
Xi 
X/+1 
Xi+2 
Xi 
XQO 
^ 0 0 
X2I 
XQO 
^ 0 0 
... 
A 
A 
A 
X 
Y 
Z 
W 
Xo 
Xo 
Xo 
0 
Xi 
Xi 
X2 
A 
X2 
X2 
Xi 
A 

8.3 Partial Fixed-Point Logic 
195 
In the first / steps (Yn) proceeds as (Xn) and (Zn) as (X2.n), i.e., with twice 
the velocity of (Xn)- When n > 0 (which is signaled by Wn i=- 0) and Yn — Zn 
then Ym — Zm — -^oo for m > n. So, all these new sequences have fixed-
points (this guarantees that the formula obtained below is totally defined). 
The fixed-points are the simultaneous fixed-point of the operations given by 
the formulas ^Y^^Z-> and Lpw-, where 
^Y{y,Y,Z,W) 
:= 
{{W = <I>V Y j^ Z) Ax{y,Y))y 
[Y = x(-,Y) 
AYyf 
>fz{z,Y,Z,W) 
:= 
{(W = 
9vY^Z)Ax{z,xi-,Z))) 
V(Z = 
x{-,Z)AZz) 
^w{'w,Y,Z,W) 
:= 
w = w. 
By the first two lines of the table we know that 
^fin [ P F P ^ , x X ] ^ ^ [^-^^^y,Y,z,Z,w,W 
^Y,^Z,^w]t 
and therefore, by the Lemma on Simultaneous Induction for PFP, we have 
for the corresponding XJ that 
N n [PFP^,x X] t ^ [PFPi;,v Xj] tu 
and that the formula on the right side is totally defined. 
D 
Next we show an FO(PFP)-version of the Transitivity Lemma. It will be 
used in the proof of 8.3.3. 
Lemma 8.3.10 (Transitivity for PFP) Letip{x,X,Y) 
andip{y,X,Y) 
be 
first-order and let [PFP^^y tp{y, X, Y)] y be totally defined. {Moreover, assume 
that no individual variable free in [PFFy^y ip{y, X,Y)] gets into the scope of 
a corresponding quantifier or PFP operator in (*).) Then the formula 
(*) 
[PFPs.x fix, X, [PFPj.y ^{y, X, Y)])] t 
is equivalent to a totally defined formula 
3(V)«[PFP5,zx(^,2)]« 
with first-order x-
Proof. Set p := [PFP^,x ^ ( ^ , ^ , [PFP^,y ^(|/,X,r)])]t We want to write 
the nested fixed-point as a simultaneous fixed-point. For this purpose let 
^'{x,X,Y) 
:= (Yi^i,(_,X,Y)AXx)y(Y 
= 
rP(-,X,Y)A^{x,X,Y)) 
("if Y is not a fixed-point then X does not change, otherwise X goes one 
step further"), 
Y = x(_,y) is an abbreviation for "ixiYx -H- x(x,y)). 

196 
8. Logics with Fixed-Point Operators 
^'{y,X,Y) 
:= 
(Y^^{.,X,Y)Ai>{y,X,Y))V 
{Y = tp{.,X, Y)A(X 
= vi^,X, Y) A Yy)) 
("if Y is not a fixed-point then Y goes one step further; otherwise Y is set 
back to 0 except X happens to be a fixed-point; then Y does not change"). 
Since [FFFy^y ^{y,X,Y)]t 
is totally defined, we immediately have 
For the corresponding x j , which is first-order (cf. 8.3.5), we therefore get 
\={in P ^ 
V?FF^,zXj]iu. 
To get a totally defined formula of the desired form, we first apply 8.3.8 to 
[PFP^;^ XJ] iu and then 8.3.6. 
D 
Exercise 8.3.11 Let ip{x,X,Y) 
:= {x = cWYx) 
and ip{y,X,Y) 
:= -^Yy. 
Show that [FFF^^x^{x,X,[FFFy^Yi^{y,X,Y)])]x 
is equivalent to the for-
mula a; = c, while the simultaneous fixed-point of ip' and -0' defined according 
to the previous proof does not exist. Note that [PFPy,y'0(^,X, F)] ^ is not 
totally defined. 
D 
We now get Theorem 8.3.3 in the following sharper form. 
Theorem 8.3.12 For every FO(FFF)-formula (p there is a first-order for-
mula ip such that 
^fin 
ip^^'i)u[FFF^^zi^]u 
and 3{\f)u[FFFj^z ip]u is totally defined. 
Proof We proceed by induction on ip. The atomic case and the cases for V, 
3, and PFP are handled as in 8.2.7, now using the preceding lemma instead 
of 8.2.6. Concerning the negation step, suppose (p = ->(/?! and, by induction 
hypothesis, assume that 
ipi = 
[FFF^yi;i{v,V)]t 
is totally defined and V'l is first-order. Set p(x,X,Z) 
:= ^Zt for dummy 
variables x and X. Then (p (= ^[FFFy^ ^i{v,V)]t) 
is equivalent to 
[PFP^,x p{x, X, [PFP^,y t/^i (v, V)])] i 
which, by the preceding lemma, is equivalent to a formula of the desired form. 
D 
We close this section by showing that in the normal form given in the 
preceding theorem the formula -0 on the right hand side can be chosen ex-
istential, a result we shall also obtain by different methods in Chapter 9. 
The following exercise gives the idea underlying the procedure to eliminate 
universal quantifiers. 

8.3 Partial Fixed-Point Logic 
197 
Exercise 8.3.13 Show that in models of ^c = d the formulas MxRx and 
[PFP^,x (a: = c V (a^ = d A '^z^Rz)) A {{Xc A Xd) -^-^x = x)] c 
are equivalent. 
D 
Theorem 8.3.14 For every FO(PFF)-formula (/? there is an existential first-
order formula p such that 3(^)u[FFFy^Y p]u is totally defined and 
H n 
ip^30^)u[FFFy,YP]u. 
Proof. By the preceding theorem we can assume that (/? = [PFPy^y tl)]u,^^ 
where [PFP^^y ip] u is totally defined and where ip is first-order and in prenex 
normal form. It suffices to show that if ^ is a S^+i-formula (compare l.B 
for the definition of E^-formulas) with k > 0 then tp can be replaced by a 
E;fe-formula (and hence, by induction, by a Ei-formula; the result then fol-
lows from 8.3.6). So assume that ip{y, Y) — JzMuij)' with ip' — '0'(^,^, w, Y) G 
Eyi;_i, and let Yn := F^. Define the sequences (^/(n))? (^(n))? (^(n)) simulta-
neously, using the formulas Xu.Xv^Xw^ 
respectively, where 
xu{y.u,v,w) 
Xv{yz,U,V,W) 
Xw{x,U,V,W) 
= 
W ^% ^ 
3z-nVyz 
= 
-^\/u^'{y,z,u,U) 
= 
X = 
X. 
Note that VF(o) = 0 and W(^n) — universe for n > 0. Hence, we get U{i) = 0 
and for n > 2 : 
U(n) = {y I ^z^v^n-i)yz} 
= 
{y I 
l-ziuip'{y,z,u,U(^n-2))}-
Since Yn = {y \ 3Ww'0'(^,^, w, Fn-i)}, a simple induction shows that 
t/(2n) = Yn and t/(2n+i) = ^n; in particular, (t/(n)) eventually becomes 
constant. As V(„) — {y^ \ -^fuip^y^l^u^U^n-i))}^ 
the sequence (V(n)) be-
comes constant, too. Thus, the simultaneous fixed-point (t^(oo)? ^(00)5 ^(oo)) 
exists and ?7(oo) = ^00 • Hence (p, that is, [PFPy^y ^] w, is equivalent to 
[S-FFFy^u,yz,v,x,wXu,Xv,Xw]u- 
Since Xu,Xv,Xw 
are equivalent to a Ei, 
Eyfc, El-formula, respectively, a closer look at the corresponding formula XJ in 
8.3.5 shows that it is equivalent to a E/i;-formula and that, for a new variable 
V, we have 
^fin ^ ^ 3(V)v[PFP^,z XJ] UV, 
and hence, |=fin ^ ^ 3{\/)u[FFFj^z Xj]'^'^- 
^ 
Exercise 8.3.15 (A version of the game of life) Let Q = {G,E^,C^) 
where 
{G,E^) is a graph and C^ C G. Interpret C^ as the set of vertices hosting 
a live cell. Set Co — 0,Ci = C^, and for n > 1, define C^, the "n-th 
generation", by the following "reproduction rule": For a ^ G, a ^ Cn iff (i) 
or (ii) holds, where 
^° Recall that a formula 3(V)a;x(^) is equivalent to x(t) for any term t. 

198 
8. Logics with Fixed-Point Operators 
(i) a G Cn-i and, in Cn-i, a has exactly two neighbours hosting a live cell 
(that is, there are exactly two b G Cn-i such that E^ab)\ 
(ii) in Cn-i, a has exactly three neighbours hosting a live cell. 
Show that there is a sentence ^ of FO(PFP) such that ip holds in a structure 
Q as above iff for some n > 1 , Cn = 0 (the species dies out). Give an example 
of a structure Q such that (G'n)n>o has no 
fixed-point. 
D 
Exercise 8.3.16 (a) Assume that M is finite and F : Pow(M) -^ Pow(M). 
Define 
Ftrue '-= {ae M \ 3noVm > HQ : a e F ^ } , 
i^faise 
:= 
{ae M \ 3noVm > no : a ^ F ^ } , 
and Fund •'= M \ (Ftrue U Ffaise), the set of undefined points. Introduce the 
class of formulas of the logic F0(3-PFP) as that of FO(PFP) at the beginning 
of this section replacing, however, the last rule of that calculus by 
^ 
^ 
^ 
[t-FFF^,x^]r 
[f-FFF^^x^]r 
[u-FFF^,x^]r 
the meaning of these formulas being 
HeF,^,J\ 
" ^ e ^ f L e " ^ a n d " ^ G F , V , 
respectively. Show that F0(3-PFP) = FO(PFP). Hint: Argue as in the proof 
of 8.3.8, using, e.g., for the truth set, an additional sequence {Vn)n>o given 
hjVo = Xo,Vi^Xu---,Vi = Xi,Vi+i=VinXi+i,Vi+2 = Vi+inXi+2,^^^-
(b) For the game associated with digraphs and (p{x,X) :— 3y{^Xy A Exy) 
the formulas [t-FFFx,x^]x, 
[f-FFFx,x^]x, 
and [u-FFFx,x^]x 
express "a: is 
won for I", "a: is won for II", and "a; is drawn", respectively. 
Notes 8.3.17 Partial fixed-point logic goes back to [2]. The presentation of 
this section owes much to Grohe [61]. 
8.4 Fixed-Point Logics and L 
07 
In the first part of this section we show that the fixed-point logics intro-
duced so far are contained in L^^. Therefore, when exploring the expressive 
power of fixed-point logics, we can prove nonaxiomatizability results by using 
nonaxiomatizability results for L^^. The second part is concerned with the 
question whether FO(LFP) = FO(PFP). We shall see that, when studying 
this problem, we can restrict ourselves to ordered structures. Thus, by the 
results of Chapter 7, the problem FO(LFP) = FO(PFP) is equivalent to the 
question whether the complexity classes PTIME and PSPACE coincide. 

8.4 Fixed-Point Logics and L^^ 
199 
Throughout this section, for simphcity, we only consider relational vocabular-
ies. The following lemma shows a way how to define the stages of a fixed-point 
construction in first-order logic. 
Proposition 8.4.1 Let ip{x,X) be a first-order formula where all variables 
are among vi,... 
,Vk and X. Suppose X is s-ary and x = xi .. .Xg (with 
xi,... 
,Xs among vi,... 
^Vk)- Then, for every n, there is a formula (p^{x) in 
F0^+^ defining the stage F^. 
Proof Let yi = Vk+i, - -- ,ys = '^k+s- Then ip^{x) can be defined inductively 
by 
3y{y =_ A3^(^ = ^ A ^"^(x))) 
^^+Hx) := ^{x,xy 
X. 
(i.e., we replace in (p{x,X) each occurrence of an atomic subformula of the 
form Xt by 3y{y = tA3x{x = yA(p^{x))); note that some variables of x may 
occur in t). 
D 
As a corollary we get: 
Theorem 8.4.2 FO(PFP) < L^^. 
Proof By 8.3.12, it suflfices to show for first-order (p that [FFFx,x ^]t is 
equivalent to a formula of L^^. 
So suppose that (p, k, s, X,x,y 
are as in the preceding proposition and 
that the variables in t are among vi,... 
,Vk. Then [PFPac,^ ^] t is equivalent 
to the L^*-formula 
\/(Vaf(vp"(x)ov^"+i(S))Av'"(«)) 
n>0 
where, to stay within L ^ , we take 3y{y = t A3x{x = y A(p'^{x))) for ^'^(t). 
D 
Exercise 8.4.3 Show that \/xiy\LFFy^Y{y 
= xV 3x(Yx A Exy))]y is not 
equivalent to a formula of L^^. (Hint: Use part (b) of 3.3.6). 
D 
The preceding theorem allows us to translate some results from L^^ to 
FO(PFP). We give two examples. By 3.3.25(b) we get 
Proposition 8.4.4 For a relational vocabulary containing only unary rela-
tion symbols the expressive power o/FO(PFP) andYO coincide; in particular, 
the class EVEN of sets of even cardinality is not axiomatizable in FO(PFP). 
D 
The last statement of the proposition shows that neither FO(LFP) 
strongly captures PTIME nor FO(PFP) strongly captures PSPACE (cf. page 
157). From the 0-1 laws for L^^ obtained in Chapter 4 we get for example: 

200 
8. Logics with Fixed-Point Operators 
Theorem 8.4.5 FO(PFP) satisfies the labeled and the unlabeled 0-1 law. D 
Now we turn to the question whether FO(LFP) = FO(PFP). We first 
recall some definitions: In subsection 3.3.2, to every r-structure A and to 
every s > 1 we have assigned a r/s-structure A/s which captures the L^^-
theory of ^. Recall that A/s consists of the classes of the equivalence relation 
~ on A^ given by 
a ^b 
iflF 
a and b satisfy the same L^^-formulas in A 
and recall that the vocabulary T/S and the structures A/s are given as follows: 
— for every A:-ary R ^ rU {=} and any ii,... 
,ik with 1 < H,..., i/b < -s the 
vocabulary T/S contains a unary relation symbol Ri^...ih with interpretation 
Rf/li, 
••= {[a]|SeA^i^X...a,J; 
— for z = 1,... ,s the vocabulary r/s contains a binary relation symbol Si 
with 
Sf^' 
:= 
{ ([a], [a']) \ a,a' e A^ there is a e A such that [a'] = [af]}. 
Since FO(PFP) < L^^, for any cp € F O ( P F P ) [ T ] we can choose an s such 
that if — (f{vi^... ,Vs) is equivalent to an L^^-formula, thus 
A \= (p\a] and a ~ 6 imply 
A |= (fi\b]. 
Therefore, any FO(PFP) definable relation on A is the union of some equiv-
alence classes. This will enable us to show that the FO(LFP) (and the 
FO(PFP)) definable relations on A and on the A/s correspond to each other. 
Since A/s has an FO(LFP) definable ordering, we thus shall be able to trans-
late the question whether FO(LFP) = FO(PFP) from arbitrary structures to 
ordered ones. 
Fix 5. We start by showing that ~ is definable in FO(LFP) (cf. 8.1.8). Let a 
and b range over A^. For j > 0 define ~j on A^ by induction: 
a ^ob 
iff 
a and b satisfy the same atomic formulas in A 
a ^j+i b iff 
a ^ob and for alH = 1,..., s and all a G A (6 G A) 
there is b e A {a e A) such that af ~j 6| 
(in the terminology of subsection 3.3.1 we have a ^j b iff the duplicator 
has a winning strategy in the pebble game G| {A, a. A, b) with s pebbles and 
j moves). Clearly, ~o ^ ~i ^ • • •, so that ~/ = ~/+i for some l}^ For such 
an / we have ~/ = ~. For the complements / j of ~j we have / o ^ / i ^ — 
In subsection 3.3.3 the least such I was called the s-rank r{A) . 

8.4 Fixed-Point Logics and L^^ 
201 
They are the stages F^'^ ,F2'^,..., 
where ^^{xi,... 
,Xs,yi, - -- ,ys, Z) is the 
following formula positive in Z: 
y 
{i;{x)<^^i;{y))V 
\ / 
i^XiMyiZxyy^yiMxiZxy). 
ip atomic 
Altogether we get 
Lemma 8.4.6 There is a r-formula ipr^{x,y) in FO(LFP) with variables 
among xi,... 
,Xs,yi,... 
,ys such that for all r-structures A and 
'a,h^A^, 
a ^h 
iff 
vA 1= (/?^ [a, 6]. 
Proof. Take as ipr^{x,y) the formula ^[LFF xy,z ^^{x,y, 
Z)]xy. 
D 
By this lemma there is an FO(LFP) definition of Als in A and hence, 
any FO(LFP) statement on Ajs can be translated to an FO(LFP) statement 
on A. 
Proposition 8.4.7 For any ip{xi,... ,Xk) in FO(LFP)[r/s] whose free vari-
ables are among xi^ • • - ,Xk there is a formula (f>{xii,... ,Xis, ... ,Xki, • •. ,Xks) 
in FO(LFP)[r] such that for all r-structures A and ai,... ,ak in A^, 
A/s ^(p[[ai],...,[ak]] 
iff 
A\=(p[ai,...,ak]. 
The same is true 2/F0(LFP) is replaced by FO(PFP) everywhere. 
Proof. For a variable ^ let ^ be yi ... ^s. The definition of (p is by induction 
on (/?. We give the main steps: 
(f 
(p 
y = z 
Rii-iiV 
Siyz 
Xyi 
...yr 
3y^ 
[LFPyi...^, ,x 
'ip]zi.. 
^r^{y,z) 
Ryii 
"-yii 
3yicp^(y,z) 
X'y^...y^^ 
3yi... 
3ysijj 
..Zr 
[LFP|^^...^^,x''0]^l 
where X' has s-times the arity of X. 
D 
We come to a translation in the opposite direction: 
Proposition 8.4.8 For any ¥0{\J¥V)[T\-formula 
ip without free second-
order variables there is an s > 1 and an ¥0{IJ¥V)[T/s\-formula 
^*{v) with 
at most the free variable v such that the individual variables in ^ are among 
vi,... ,Vs and such that for all r-structures A and a G A*, 
A^^[ai,...,as\ 
iff 
Als^if*[\a]]. 
If if is a sentence then (p* can be chosen to be a sentence. 
The same is true for FO(PFP) instead o/FO(LFP). 

202 
8. Logics with Fixed-Point Operators 
Proof. By Theorem 8.1.14, we may assume that the LFP operator occurs 
only once in (/?, w.l.o.g. in the form [LFPt;^...^;^,^ V']^- Moreover, we may 
assume that the occurrences of X have the form Xvi.. .Vr {li Xzi.. .Zr 
occurs, replace it by 3y(y = z A 3v{v = y A Xv)) where y are new vari-
ables and V = vi...Vr). 
Treating t similarly, we may assume that the 
LFP operator in ip has the form [LFP^,j...t,^,x ^] t'l • • -Vr- Let the variables 
in cp be among vi,...,Vs. 
Finally, we may assume that r = s; otherwise, 
we replace X by an 5-ary variable Y and [LFFy^,_,y^^x 'ip(X)]vi .. .Vr by 
[LFP^;,...^^,y 1p{Y-Vr+l • . . Vs)] Vi... Vg. 
The definition of ip* is by induction on cp, the main steps being (we use a 
unary relation variable V): 
ip 
(^* 
Vi = Vj 
Rvi^ 
...Vi^ 
Xvi 
...Vs 
3viip 
[LFP^,,...„,,xV^K. 
= u ^ 
J^ii ...ifc'^ 
Vv 
3w{SiVW 
AIIJ*{W)) 
..Vs 
[LFFv^Yip*]v. 
For a sentence cp pass to the sentence 3v(p*. 
D 
The next proposition shows that from the point of view of FO(LFP) the 
structures A/s can be regarded as ordered structures. 
Proposition 8.4.9 There is an FO{LFF)[T/S]-formula 
ip^{u,v) such that 
for all r-structures A, 
i>i'' 
••= {([«],[&]) I-4/shV'<[[«], [6]]} 
is an ordering on A/s. 
Proof. Let ^ be a r-structure and let ^j be the equivalence relations intro-
duced before 8.4.6. Assume ~/ = ~. For j > 0 we define partial orderings 
(that means, irreflexive and transitive relations) <j on A/s such that 
(1) 
< 0 C < i C < 2 . . . 
(2) 
m<j[b]ov[b]<j[a]) 
iff 
ayC.b 
(thus, <j induces an ordering on the equivalence classes of ~j). Then <i will 
be the intended ordering. 
Let xi 5 • • • 5 Xm be an enumeration - say in lexicographic order - of the 
atomic r-formulas in the variables vi,... 
,Vs and let %* be the r/s-formula 
associated to Xi in Proposition 8.4.8. As <o we take <o^= V^o 
(-'- ) where 
Mx,y) ••= V (xrWA-x:(j/)A /\ (x;(x)^xUy)))-
l<i<m 
l<i<i 

8.4 Fixed-Point Logics and L^^ 
203 
Clearly, <o is a partial ordering that satisfies (2) for j = 0. 
Now suppose that <j has already been defined. To extend <j to <j+i, 
assume that a ^j b and a /j/+i b. For 1 < i < s set M(a, i) := {[af ]j | a G A} 
and M{b,i) 
:= {[5f]j | b G A}, where [c]j denotes the equivalence class 
of c modulo ~ j . Since a /j+i 6, there is a smallest number i such that 
M{a,i) ^ M{b,i). Set [a] <j+i \b] if the <j-minimal element of (M{a,i) \ 
M(b,i)) U {M{b,i) \ M{a,i)) belongs to M{a,i); otherwise, set [6] <j+i [a]. 
One easily verifies that <j+i is a partial ordering (extending <j) and that 
(2) holds for j + 1. 
Clearly, < := </ is a total ordering on A/s. It is the fixed-point of the 
increasing relations <j and is thus definable in A/s by [IFPiit;,x x] ^^ where, 
with X = y for ->Xxy A ->Xyx, 
x{u,v,X) 
:= 
i)o{u,v)\/ 
y 
{3u'{SiUu' AW{SiVv' 
^ 
l<i<s 
(Xu'v' V {Xv'u' A 3u"{SiUu" A u" = v'))))) 
A / \ 
{W{SkUu' -> 3v\SkVv' 
Au' = v')) 
l<k<i 
AWiSkVv' 
-^ 3u'{SkUu' Au' = v')))). 
D 
We are now able to show the main result of this section. 
Theorem 8.4.10 The following are equivalent: 
(i) FO(PFP) = FO(LFP). 
(ii) FO(PFP) = FO(LFP) on ordered structures. 
Proof. The direction from (i) to (ii) is clear. Assume FO(PFP) = FO(LFP) 
on ordered structures. Let r be a vocabulary and suppose (p is an F O ( P F P ) [ T ] -
sentence. We must show that there is an FO(LFP)[r]-sentence with the same 
finite models. Choose 5 > 1 and ip* G F0(PFP)[r/5] according to 8.4.8. By 
(ii) there is an FO(LFP)[r/sU{<}]-sentence ip such that 
" < is an ordering" \= (f* -^ ip. 
M...,-) 
Let X :— ip^<^'^' \ i.e., x is obtained from tp by replacing any atomic part 
..< 
of the form x < y by ^p<: {x, y), where ^< (u, v) is the formula of the preceding 
proposition. Hence, x ^ FO(LFP)[r/s]. Choose x ^ FO(LFP)[r] according 
to 8.4.7. Then, for any r-structure A we have 
a 
iff 
A/s \= if* 
iff 
(Als,i,i'' 
iff 
Ms \= X 
iff 
A\=x-
')NV' 

204 
8. Logics with Fixed-Point Operators 
With 7.5.7 we now get 
Corollary 8.4.11 FO(LFP) = FO(PFP) 
iff 
PTIME = PSPACE. 
D 
The ordered structure {A/s, <) is isomorphic to exactly one structure of 
the form ({0,...,n},. ..,<), the numerical s-invariant of A. By the results 
above, a query on the class of r-structures is definable in FO(LFP) iff for all 
sufficiently large s, the corresponding query on the numerical s-invariants is 
definable in FO(LFP). Therefore, by 7.5.2, a query on the class of r-structures 
is definable in FO(LFP) iff the corresponding query on the numerical invari-
ants is in PTIME. That is, on arbitrary finite structures exactly those queries 
are definable in FO(LFP) which correspond to PTIME queries on the numer-
ical invariants. The same applies to FO(PFP) and PSPACE. 
Exercise 8.4.12 A r-structure A is s-rigid if a / 6 for all a, b ^ A, a ^ b 
(where ~ is the equivalence relation leading to A/s and a, b are the constant 
sequences of length s). A class K oi structures is s-rigid, if every structure 
in K is s-rigid. Show: 
(a) A is rigid iff A is s-rigid for some s. 
(b) The following are equivalent: 
(i) 
K is s-rigid for some s. 
(ii) There is a formula in FO(LFP) defining an ordering on K (i.e., on 
every structure in K). 
(iii) There is a formula in L^^ defining an ordering on K. 
Hint: (i) =^ (ii): If the r-structure A is s-rigid, then X'^i-^- 
) with x(x,y) — 
V^< (a:,..., a:, ^,..., y) is an ordering, where ^< (u, v) is the formula associated 
with the r/s-formula ip<^{u,v) of 8.4.9 according to 8.4.7. - (iii) => (i): If 
(p{x,y) G L^^ defines an ordering, use formulas as defined in part (a) of 
3.3.1, here built up from ^{x,y) instead of x < y, to show that K is s-rigid 
for some s. 
Conclude: If ET is an s-rigid class of structures, then the PTIME-computable 
queries on K are exactly the FO(LFP) definable ones. 
In contrast to (a) there is a first-order axiomatizable class of rigid struc-
tures that is not s-rigid for any s (see [77]). 
D 
Exercise 8.4.13 Let X be a class of structures. We say that K is fixed-
point bounded, if for any first-order formula ip{x,X) positive in X with free 
variables among x,X, there is an mo such that 
K ^ Vx((p^o+i(^) ^ V9^°(^)), 
where ^^{x) is a first-order formula defining F^ (see 8.4.1). Show the equiv-
alence of (i) - (iii): 
(i) 
K is fixed-point bounded. 
(ii) K is bounded (in the sense of Theorem 3.3.24). 
(iii) On K, every L^^-formula is equivalent to an FO-formula. 

8.4 Fixed-Point Logics and L^^ 
205 
Hint: For (i) =^ (ii) apply the hypothesis to the formula Lpr/.{x,y,X) intro-
duced before 8.4.6. The equivalence of (ii) and (iii) was shown in 3.3.24. For 
the direction from (iii) to (i) suppose that ip{x,X) is as above and witnesses 
that there is no mo as claimed. For M C N set ipu •= Vm6M(^"^"^'^(^) ^ 
-i(p"^(x)). Then, (pM and ipL are not equivalent on AT for L / M. 
In (iii), one cannot replace L^^ by FO(LFP) (see [74]). 
D 
8.4.1 The Logic F O ( P F P P T I M E ) 
While least fixed-point operations reach their fixed-point in polynomially 
many steps, partial fixed-point operations may need exponentially many 
steps. The intermediate logic F O ( P F P P T I M E ) is the fragment of FO(PFP) 
consisting of those formulas for which every occurrence of the PFP operator 
reaches a fixed-point in polynomially many steps in all structures. Clearly, 
FO(LFP) < FO(PFPPTIME). 
Exercise 8.4.16 shows that FO(LFP) = F O ( P F P P T I M E ) for arbitrary struc-
tures is quite unlikely. On the other hand we have 
Theorem 8.4.14 On ordered structures, FO(LFP) = F O ( P F P P T I M E ) . 
Proof. The claim is clear by the results of Chapter 7: By definition, every 
query definable in F O ( P F P P T I M E ) can be evaluated in polynomial time and 
is thus definable in FO(LFP). Nevertheless, for later purposes we sketch a 
direct proof. Let [PFP^,xV^(^, X)] t be given and suppose that, for some poly-
nomial p, the sequence (X/)z>o (with Xi := Fj^) gets constant after at most 
^(cardinality of the universe) many steps. The idea of how to express this 
fixed-point in FO(LFP) is simple: We code the stages (X/)/<p( ) by a rela-
tion variable Y with fixed-point FQO where 
Yoomx 
iff 
fn^pi-") 
A XmX. 
The stages of IQ ? ^i ? ^2, • • • will form the increasing sequence 
{{0,x)\xeXo} 
(=0), 
{ ( 0 , ^ ) | ^ G X O } U { ( 1 , ^ ) | ^ G X I } , 
{(0,x) I ^ G Xo} U {(1,^) I ^ G Xi} U {(2,x) I X G X2},.... 
The arithmetics needed for this encoding is definable in FO(LFP). In fact, 
by 8.1.11 there are A: > 1 and formulas S^uv and v — p{x + 1) in FO(LFP) 
expressing (in the corresponding number representation) that v is the suc-
cessor of u and that v equals p{x + 1), respectively. Therefore, as a formula 
equivalent to [PFP^,x^(^,X)]^ we can take 
3w{w = p{maiX-\-l) A [IFP^^,y((5^minw A (yi?(^, 0)) 
\/3vy {Yvy A v <w A S^vu A (p{x, Yv-))) ] wt). 
D 

206 
8. Logics with Fixed-Point Operators 
Exercise 8.4.15 (FO(LFP) < L^^ fi PTIME ) Let r = {E,U} 
and let 
r' = {<,U} with unary U and binary <,E. Denote by STG the class of 
(binary) "strings", i.e., the class of orc?erec?r'-structures. A finite r-structure 
T = (T, E'^, U^) is a labeled complete binary tree if 
- (T, E'^) is a tree, where every element has out-degree 0 or 2 and all leaves 
have the same depth (cf. 8.1.7). 
- For any a, 6 G T of the same depth we have U^a iff U^b. 
Denote by LCT the class of labeled complete binary trees. Show: 
- LCT is axiomatizable in FO(LFP) (use 8.1.7). 
- If Ti, r 2 G LCT and Ti ^^-^ Ts then Ti = Ts-
- Any class K with K C LCT is axiomatizable in L^^. 
There is a natural correspondence between strings and labeled complete bi-
nary trees obtained by encoding the same t^-information with the z-th bit of 
the string as with the i-ih. level of the tree. More formally, if ipi{x) G FO[r'] 
expresses that x is the i-th. element of < and ipi(x) G FO[r] expresses that x 
has depth i, then for A G STG and T G LCT set ^ ?^ T iff for all i > 0, 
- ^ 1= 3xifi{x) 
iff T |== 3x\l^i{x) 
- A\= \/x[^i{x) -^ Ux) iff r 1= 'ix{il)i{x) -^ Ux). 
Show 
- If if C LCT is axiomatizable in FO(LFP) then STG(iJ) :^ 
{A\A^T 
for some T G iJ} is axiomatizable in FO(LFP). Hint: Show for T G LCT 
and a,beT' 
that 
{T,a) = {T,b) 
iff 
{d{ai A aj))i<i<j<s = {d{bi A 6j))i<i<j<s, 
where d{c) is the depth of c and where aAb denotes the element c of least 
depth with c < a and c < 6 in the induced partial ordering (cf. 8.1.7). 
Thus s-tuples of elements of the tree can be encoded by ^^^^-tuples in 
the corresponding string. The set of the latter tuples being definable in 
FO, this can be used to translate the FO(LFP)-axiomatization of H into 
an FO(LFP)-axiomatization of STG{H). 
-l^K 
C STG is in TIME(2^) (that is, K is accepted by a 2^ time-bounded 
machine), then LCT(ii^)< is in PTIME, where LCT(K) 
:= {T \ A ^ 
T for some A G K}. 
It is a well-known result of complexity theory that there are classes K C STG 
that are in TIME(2^) but not in PTIME. Conclude for such a K that LCT(K) 
is in PTIME and is L^^-axiomatizable, but not FO(LFP)-axiomatizable. D 
Exercise 8.4.16 ( F O ( P F P P T I M E ) = FO(LFP) =^ PSPACE = PTIME) 
Let Ti = {E,U} and T2 — {E,U,V}, 
where U and V are unary and E is 
binary. Fix A^ > 1. Recall the definition of strings (= structures in STG) and 

8.4 Fixed-Point Logics and L^^ 
207 
of labeled complete binary trees of the preceding exercise. For the present 
purpose we encode strings of length n in a suitable complete binary tree of 
depth n^. The class TREEfc consists of r2-structures T = (T, E^, C/^,y^) 
that satisfy 
(T, £J^,t/^) and (T, E^,]/^) are labeled complete binary trees; 
\/xyy{{Exy 
A Vy) -^ Vx) 
\fx{Ux -^ Vx) 
"The depth of T is m^, where m is the number of levels labeled by V'. 
TREEfe is axiomatizable in FO(LFP); in particular, the last condition can 
be expressed in FO(LFP) by developing the arithmetic of Example 8.1.11 for 
complete binary trees instead of orderings, the j-th level taking over the role 
of the j-th element of the ordering. 
Consider the relation x between strings and structures in TREE^ defined 
by using '^ of the preceding exercise as follows: 
A^T 
iff 
^ « ( y ^ , £ : ^ n ( y ^ x y ^ ) , c / ^ ) . 
Show: 
(a) If K C STG is axiomatizable in FO(PFP), then for some k, {T G 
TREE/fe I ^ X r for some A e K} is axiomatizable in F O ( P F P P T I M E ) . 
(b) If H C TREEfe is axiomatizable in FO(LFP), then {A G STG | A x 
T for some T G H} is axiomatizable in FO(LFP). 
Let K C STG be in PSPACE and therefore, axiomatizable in FO(PFP). 
Using (a), choose k such that {T G TREE^ | ^ x T for some A e K} 
is axiomatizable in FO(PFPPTIME) and hence, in FO(LFP), if we assume 
F O ( P F P P T I M E ) = FO(LFP). Then, by (b), K is axiomatizable in FO(LFP) 
and therefore, K is in PTIME. Hence, PSPACE = PTIME by the remark 
following 7.5.7. 
D 
8.4.2 Fixed-Point Logic with Counting 
We have seen that FO(LFP) does not strongly capture PTIME and remarked 
that it is still open whether there exists a logic strongly capturing PTIME (cf. 
the remarks after 7.5.19). While pursuing this problem, various extensions of 
FO(LFP) have been studied as candidates for strongly capturing PTIME. As 
an example we present fixed-point logic with counting. 
Recall that, when proving Theorem 8.4.14, we used the fact that, on 
ordered structures, FO(LFP) can describe the arithmetics needed to code 
polynomially many stages of a fixed-point operation in one relation. But 
arithmetics is not all orderings allows to do: Using orderings we can enu-
merate the elements of a structure and thus successively look at each single 
element. For instance, by enumeration we can calculate in FO(LFP) the sizes 

208 
8. Logics with Fixed-Point Operators 
of definable subsets. In fact, let (p{x) be an FO(LFP)-formula. Then for any 
ordered structure A (with A ^ \/xip{x)), 
a is the ||(p'^(_)||-th element of <^ 
iff 
A\= [LFFxu,xx] "^six u[a], 
where 
x{x,u,X) 
:= {x = mmA^ip{x) Au = m.in)\/{x = m.mAip{x) A Sminu) 
\/3x'u'{Xx'u' 
A Sx'x A {{-^i~p{x) Au = u')V {ip{x) A Su'u))). 
Fixed-point logic with counting, FO(IFP, #), is an extension of fixed-point 
logic that contains arithmetic (in the size of the structure) and allows to 
calculate cardinalities. If we only consider ordered structures, every query 
definable in fixed-point logic with counting is in PTIME; so in this case the 
logic FO(IFP, #) coincides with least fixed-point logic and hence, captures 
PTIME. On the other hand, FO(IFP, #) does not strongly capture PTIME. 
In fact, we shall see that FO(IFP, #) is (equivalent to) a fragment of C^^, 
infinitary logic with counting quantifiers and finitely many variables, and 
that there is a graph property in PTIME which is not even expressible in 
this logic (cf. section 12.2). Nevertheless, FO(IFP, #) has turned out to be 
quite an important logic, since it "captures PTIME on many concrete classes" 
(cf. Chapter 11). Since FO(IFP, #) contains arithmetics (in the size of the 
structure), those results for FO(LFP) and ordered structures where we used 
the ordering only for arithmetical operations or size calculations translate 
to fixed-point logic with counting and arbitrary finite structures (compare 
8.4.19 below and 9.2.3 in the next chapter). 
In Fixed-Point Logic with Counting, FO(IFP, #), any r-structure A is 
thought of to be accompanied by its number part consisting of a disjoint 
virtual universe { 0 , l , . . . , | m | } together with the natural ordering, the suc-
cessor relation, and constants for the first and the last element, respectively. 
We assume that r fl {<, 5, min, max} = 0. ^ is viewed as a two-sorted struc-
ture, the elements of A itself being of the first sort, the point sort, those 
of the virtual universe being of the second sort, the number sort. On the 
syntactic side we have variables x,y,z,... 
for the first sort {point variables) 
and variables /x, i/,... for the second sort (number variables). The formulas of 
FO(IFP, #) are obtained from atomic formulas by closing under the connec-
tives, first-order quantification of both sorts, and inflationary fixed-points of 
mixed sorted relations; moreover, for any formula ^ and variable x there is a 
term H^x^ of the second sort denoting the cardinality of the set of elements 
X satisfying cp. More precisely, terms of both sorts and formulas are given 
simultaneously by the following clauses: 
• All first-order r-terms (with variables x,y,...) 
are terms of the first sort; 
all first-order terms of vocabulary {<, 5, min, max} (with variables //, i/,...) 
are terms of the second sort. 
• All atomic r-formulas and all atomic {<, 5, min, max}-formulas (with 
terms of the corresponding sort) are formulas. 

8.4 Fixed-Point Logics and L^^ 
209 
• If X is a second-order variable of mixed arity ni, n2 then Xfp is a formula, 
where t and p are sequences of terms of the first and second sort of lengths 
ni and n2, respectively. 
• If (y9 and ip are formulas then so are -^ip and {^V ip). 
• If (p is a formula then 3x(p and 3i'(p are formulas. 
• If (/? is a formula then [lFFxji^x^]t'p is a formula (the lengths of x,Jl,t,'p 
are according to the mixed arity of X). 
• If (/? is a formula then #a;<^ is a term of the second sort. 
The variable x does not occur free in #x^' 
The semantics should be clear: 
If (p = Lp{x,y) and a G v4, the value #x^ix,a)^ 
is given by the number 
\\{aeA\A\=^[a,a]}\\. 
Examples 8.4.17 (a) Let r = {P} with unary P. Then #xPx = #x^Px 
is 
a sentence of FO(IFP, #) not equivalent to any L^^-sentence (cf. 3.3.25(b) 
and 2.3.12). 
(b) The class EVEN of structures of even cardinality is axiomatizable in 
FO(IFP, #) by 
^[IFP^,x(/^ = minV3i/(Xz/A > = j/ + 2"))] max. 
(c) For equivalence relations Ei and E2 the following sentence of FO(IFP, #) 
expresses that, for all cardinalities /, Ei and E2 have the same number of 
equivalence classes of cardinality /: 
^IJi{#x{#yEiXy 
= //) = #x{#yE2Xy 
= 1^)). 
(d) For graphs the following formula of FO(IFP, #) says that the distance 
between x and y is X: 
[IFP^^,c/ {z = xAiJ. = 0)V (^3z/ Uziy A 3z'3fi'{Uz'/j,' A Ez'z A Sfi'fi))] yX. 
(e) Note that the negation symbol is superfluous in FO(IFP, #). In fact, if x 
is a variable not occurring in ip then 
Hfin --^ ^ #xy^ = min. 
D 
It should be clear how FO(PFP, #), Partial Fixed-Point Logic with 
Counting, is defined. 
Proposition 8.4.18 FO(PFP, #) < C^^. 
Proof. Given a sentence (p of FO(PFP, #) we show that it is equivalent to a 
sentence of the form 
y (3=''xx = xAipn) 
n>l 
where (pn is a sentence of first-order logic with counting quantifiers that 
captures the meaning of ip in models of cardinality n. The translation from 

210 
8. Logics with Fixed-Point Operators 
ip to Lpn^ though easy in principle, is involved if one wants to give a clean 
definition (the reader is encouraged to translate the formulas in the preceding 
examples to C^^). We give a translation in two steps: First, we pass from 
(/? to a sentence ^'^ eliminating # and PFP, but using atomic formulas and 
first-order quantifications of the second sort (they will be eliminated in the 
second step). Let (/?^ result from (f by replacing any subformula #3,(/? = // by 
\J (3^*x(/? A "// is the i-th element of <") 
i<n 
and by treating PFP operations as in the proof of 8.4.2, taking into account 
that we can replace the infinite disjunctions used there by finite ones, since 
we only consider structures of cardinality n. In the second step we pass to an 
FO(C)-sentence ipn- More generally, for every formula ip{x,/ii,...,/j^k), 
where 
atomic subformulas and quantifications of the second sort are still allowed, 
and for every m — rrii .. .rrik with m i , . . . ,mfc < n we define an FO(C)-
formula ipm{x) such that, in structures of cardinality n, ipmix) says the same 
as 'ip{x,mi,... 
,mfc). We then set ipn := {^n)nr with m — ^ (note that (p'^ is 
a sentence). The main steps in an inductive definition of ipmix) are 
If ip{x,/j,) - iii < fjij then iprn{x) := < 
If ^(x,/l) = 3/j,x(x,%iJ,) then ipmix) := \lm<nXmm{x). 
D 
T 
if mj < rrij 
F 
otherwise 
Since in the proof of 8.4.14 we only used arithmetical properties of the 
ordering, in essentially the same way we get: 
Proposition 8.4.19 FO(IFP, #) = FO(PFPpTiME'#)• 
^ 
Here, F O ( P F P P T I M E , #) denotes the fragment of FO(PFP, #) consisting 
of those formulas for which each PFP operation closes in polynomially many 
steps. 
Notes 8.4.20 Theorem 8.4.5 goes back to [12]. The main result 8.4.10 is 
due to Abiteboul and Vianu [4]. The proof presented here is based on [30]. 
Fixed-point logic with counting originates in ideas of Immerman [92]; in the 
form described here it has been shaped by Gradel and Otto [57, 124]. Otto 
has extended Theorem 8.4.10 to fixed-point logic with counting; cf. [125]. 
8.5 Fixed-Point Logics and Second-Order Logic 
The results of Chapter 7 give us some information about the relationship 
between fixed-point logics and second-order logic SO: Let K — Mod((/9) for 
some sentence ip of FO(LFP). Then, K^ G PTIME C NPTIME and hence, 
K = Mod(^) for some Sj-sentence ij) (by 7.5.14). Therefore, we have 

8.5 Fixed-Point Logics and Second-Order Logic 
211 
(1) 
FO(LFP)<S}. 
As the class EVEN of finite sets of even cardinality is not axiomatizable in 
FO(LFP) (see 8.4.4) but in S} (see the beginning of section 3.1), we have 
S} £ FO(LFP). On ordered structures the statement T\ ^ FO(LFP) is 
equivalent to NPTIME 7^ PTIME (cf. 7.5.7) and hence, is still open. 
Since every class of ordered structures axiomatizable in SO is in PSPACE 
(cf. 7.4.3(b)), the Main Theorem (cf. 7.5.2) yields 
(2) 
SO < FO(PFP) on ordered structures. 
In this section we aim at purely modeltheoretic proofs of (1) and (2). The 
proof of (1) leads to an Ehrenfeucht-Fraisse method for FO(LFP) that can 
also be used to get nonaxiomatizability results for FO(LFP). (However, in 
most cases it is easier to prove nonaxiomatizability even for L^^, as we did 
in the last section for EVEN.) 
Theorem 8.5.1 On ordered structures, SO < FO(PFP) and SO(PFP) = 
F0(PFP).i2 
Proof. Let r be a vocabulary with {<, 5, min, max} C r. We restrict our at-
tention to finite structures whose universe is {0,..., n} for some n and whose 
{<, 5, min, max}-reduct is the natural ordering on {0,..., n}. For every for-
mula (/? of SO (or, of SO(PFP)) we inductively define an equivalent FO(PFP)-
formula, the only nontrivial case being second-order quantification. So let 
(p = \/Zip{Z) and, for simplicity, assume that Z is unary. Below we show 
the existence of a first-order formula x{x,y,X) 
with binary X such that in 
any ordered structure A the fixed-point F^ exists and is nonempty, and the 
sequence of sets {{x \ 3y F^xy})k>o runs through all subsets of A. Then 
\/Z'il){Z) is equivalent to 
3x3y [PFP^^,x (x{x, y, X) A ^{3yX_y))\ 
xy. 
To define x? we code a sequence (ao,...,an) of elements of A by the set 
X := {{ai^i) \ i < n}. It is easy to write down a formula x(a:,y,X) such that 
the stages F^,F},...,F(^+i)n+ 
1 are codes of the sequences 
(0,...,0), (0,...,0,l),...,(n,...,n), 
respectively, and F^ = ^(n+i)"+i • 
^ 
We now show that FO(LFP) < Ej. For the least fixed-point FQO of a 
monotone operation F : Pow(A^) -^ Fow{A^) we have (see part (b) of 8.1.2) 
F^ = 
f]{XCA''\F(X)CX}. 
Cf. 7.5.19 

212 
8. Logics with Fixed-Point Operators 
Thus 
aeFoo 
iff 
for all X C A^, if F{X) C X then 
aeX 
iff 
for all X C ^^, if a ^ X then there is some 
6 with 6^ X and6GF(X). 
Hence, for an arbitrary formula cp of FO(LFP), we have 
(*) 
^fin [LFP^,x ^] i ^ \fX{-^Xt -> 3x{-^Xx A ^)). 
Since, by 8.2.9, every formula of FO(LFP) is equivalent to a formula of the 
form Vi;[LFP^,x ^] v with first-order (/?, (*) shows that FO(LFP) < Hj. Since 
FO(LFP) is closed under negation, we get 
Theorem 8.5.2 FO(LFP) < Aj. 
D 
The equivalence (*) can be used to obtain a characterization in the Ehren-
feucht-Frai'sse style of classes axiomatizable in FO(LFP). Essentially, the cor-
responding Ehrenfeucht-Frai'sse game is obtained by taking into account re-
lation moves that correspond to the right side of (*). Suppose that in a play 
the spoiler aims at showing 
A \= [LFP,,x 'P(x, X)] y [a] and B ^ [LFP,,x V>{x, X)] y [b] 
(a and b being the interpretations of y), that is, by (*), 
. . 
A 
^ 
\/X{-^Xy-^3x{-^XxAip))[a] 
^"^^ 
and 
B 
^ 
\fX(^Xy-^3x{-^XxAip))[b]. 
For this purpose he starts by choosing a subset BQ of B such that b ^ BQ 
and B ^ 3x{^Xx A (p{x,X)) [BQ]. The duplicator then selects a subset AQ of 
A with a ^ AQ claiming that it behaves like BQ. However, by (-I-), 
A^3x{-^XxA(p{x,X))[Ao]. 
Thus the spoiler can choose an element a' ^ AQ such that A \= (fi[a',Ao], 
while for any b' ^ BQ chosen by the duplicator we have B ^ (^[b'^Bo]. Now 
the spoiler has a "simpler" task, namely to show that A |= if[a',Ao] and 
B^^[b',Bo]. 
The order and type of choices of the spoiler and the duplicator in this example 
will be the defining clauses of a so-called LFP move in the game we are 
going to introduce. To simplify the notation and the presentation we consider 
only relational vocabularies and monadic least fixed-point logic FO(M-LFP), 
which is obtained by restricting FO(LFP) to formulas in which only unary 
relation variables (set variables) are allowed. By (*), we have FO(M-LFP) < 
MSO. Furthermore, we remark that FO(M-LFP) like monadic second-order 
logic MSO has turned out to be an interesting logic in the realm of infinite 

8.5 Fixed-Point Logics and Second-Order Logic 
213 
structures (cf. [14, 41]). 
We write A =^ B iS A and B satisfy the same sentences of FO(M-LFP) of 
quantifier rank < m, where the quantifier rank is defined inductively as for 
first-order logic, adding the clause 
qr{[LFF,,x^]y) 
:= 
1 +qr((p). 
In order to determine the winner of a play we need the notion of a general-
ized partial isomorphism. It takes into consideration that in [LFPa;^^ cp] y the 
formula (/? is positive in X. 
Definition 8.5.3 Let A and B be r-structures (where r is relational). Sup-
pose that a = ai .. .Qk G A, b = bi.. .bk G B, that U — U\ .. .XJi and 
V — Vi .. .Vn are sequences of subsets of A, and that S = Si ... Si and 
T = Ti... Tn are sequences of subsets of B. Then {a \-^b,U \-^ S,V ^ T) is 
a generalized partial isomorphism from ^ to i3 iff a i-> 6 is a partial isomor-
phism from ^ to i3 and for i = 1,..., A: and j = 1,..., / we have: 
— ai e Uj implies bi G Sj, 
— bi e Tj implies ai eVj. 
D 
As the Ehrenfeucht-Frai'sse game Gm{A, B) for first-order logic, the game 
MLFP-Gm(v4, i5) is played by two players, the spoiler and the duplicator, 
and consists of m moves. In the i-th move (1 < i < m) an element a^ of A 
and an element bi of B are chosen, and in some moves subsets will be chosen, 
too. More precisely: There are two types of moves, point moves and LFP 
moves. In each move of a play the spoiler first decides what type of move 
he wants. Point moves are as in the first-order case. Now suppose that the 
spoiler decides that the i-th. move should be an LFP move. Then he selects a 
j <i and a structure, A or B. We speak of a positive LFP move if he selects 
A^ and of a negative LFP move if he selects B. 
In the positive case the spoiler chooses a subset S of B with bj ^ S, and 
the duplicator answers by a subset U of A with Oj ^ U. Then the spoiler 
chooses an element Oi G A\U, 
and the move is finished by the selection of 
an element bi e B \ S by the duplicator. 
In the negative case the roles of A and B are interchanged, that is: The 
spoiler chooses a,V C A with Oj ^ V, and the duplicator answers by a T C 5 
with bj ^ T; then the spoiler chooses an element bi G B\T, 
and finally the 
duplicator selects an element ai e 
A\V. 
In the course of a play, besides the elements ai ... a^ and bi.. .bm, subsets 
Ui..MiofA 
and 
Si... Si of B 
have been chosen in positive LFP moves, and subsets 
Vi...VnOfA 
and 
Ti... Tn of B 

214 
8. Logics with Fixed-Point Operators 
in negative ones. By definition, the duphcator wins the play if (a H^ 6, C/ i-> 
5, y -H T) is a generalized partial isomorphism. 
The main theorem now reads as follows: 
Theorem 8.5.4 Let A and B he structures and m ^'H. Then the following 
are equivalent: 
(i) A =JjJ B, i.e., A and B satisfy the same sentences of FO(M-LFP) of 
quantifier rank < m. 
(ii) The duplicator has a winning strategy in the game MLFP-Gm(^, ^)-
Before presenting the proof we give an example. 
Example 8.5.5 Let Qi and QiUQi be graphs consisting of one and two cycles 
of length / + 1, respectively. To be definite, set 
Gi := {0,...,/}, 
E^^ := {(i,i + l) I i < l}U{{i + l,i) \ i < /}U{(0,/), (/,0)} 
and GiUGi := {0,...,/} x {0,1}. - The spoiler has a winning strategy in 
the game MLFP-G4(^/,^zU^/), which is exemplified by the following table 
where we have underlined his selections. He plays according to the fact that 
Qi \= 3xV2/[LFP^,z z = xW 3u{Zu A Euz)] y 
QiOQi ^ 
3x\/y[LFF^^zz = x\/ 3u{Zu A Euz)]y. 
move 
1 
2 
3 
4 
Gi 
0 
a 
U (with 
a^U) 
g!_ := m.in{u \ u ^ U} 
a' -1 
QiOQi 
ib,k) 
{b,l-k) 
{{c,k)\c<l} 
(d, 1 - k) 
? 
j < i 
2 
No fourth move of the duplicator will lead to a generalized partial isomor-
phism, because a' — 1 is connected with a' by an edge and a' — 1 G U, but 
there is no element in QiUQi related to (d, 1 — k) and {{c,k) | c < /} in this 
way. (If a' = 0 then already in the third move there is no answer for the 
duplicator leading to a generalized partial isomorphism.) 
D 
Proof (of 8.5.4)- First suppose that the dupHcator has a winning strategy 
for MLFF-Gm{A,B). 
We have to show that {A [= cp if[ B ^ ip) holds for all 
FO(M-LFP)-sentences of quantifier rank < m. Essentially, the proof runs in 
the standard way: As usual, point moves take care of first-order quantifiers 
and LFP moves of LFP operators as outlined before introducing the game. 
More precisely: Suppose that in a play, where the duplicator has followed his 

8.5 Fixed-Point Logics and Second-Order Logic 
215 
winning strategy, a ^ b, U ^ S and y -H T have been the choices in the 
first i moves; then show that 
A[='il^{x, X, F) [a, U, V] 
impHes 
B ^ ip{x, X, Y) [6,5, T] 
for any FO(M-LFP)-formula ij) of quantifier rank < m—i which is positive in 
X and negative in Y (a corresponding inductive proof runs on m — i). 
For the other direction we introduce an analogue of j-isomorphism types 
(cf. 2.2.5). Fix a structure A. For a — ai...ak 
€ A, "positive" subsets 
U = Ui...Uioi 
A and "negative" subsets F = 14 ... K of A let 
Xl-^y 
:= ^^A / \ ( 
f\ 
XjViA 
/\ 
^YjVil 
l<i<k 
l<j<l;aieUj 
l<j<n;ai^Vj 
where cp^ is the (formula denoting the) 0-isomorphism type of a in A. Then, 
for arbitrary B, 6,5, and T, we have 
^ N xy^ylb, S,T] 
iflf 
(a^b,U^S,V^ 
T) is a 
generalized partial isomorphism. 
For 7 > 0 we define the formula yLr-rTj such that H 1= v:?. —— [6, S,T] when-
ever in a play of the FO(M-LFP) game, in which a i-^ 6, ?7 i-)- 5, and y 4-i T 
have been selected so far, there is a strategy for the duplicator which allows 
him to answer j further moves correctly. Thus we set (writing i^, X, and Y 
for t'fc+i, Xz+i, and Fn+i, respectively): 
Y^' 
— 
A 3t;Y^'~^ 
AVt; \ / Y^~^ 
A 
^a,Uy 
/ \ 
^aa,U,V 
V 
^aa,U,V 
aE:A 
aE.A 
l<i<k 
UCA;ai^U 
a^U 
Iia,U,V 
are empty, we write XA ^^^ *^^ sentence xi_—. We show that, up 
to equivalence, 
(1) 
Y-rTT/ is an FO(M-LFP)-formula of quantifier rank < j . 
This proves the claim: In fact, since A \= XA^ we get B |= x^ from A =^ B 
and hence, the duplicator has a winning strategy in 
MLFF-GmiA,B). 
To obtain (1) we first note that a simple induction on j shows that, given the 
lengths of the sequences which appear as subscripts, there are only finitely 
many formulas of the form xi —_. Thus the disjunctions and conjunctions 
in the definition of vi —— are finite. 

216 
8. Logics with Fixed-Point Operators 
The proof of (1) also proceeds by induction on j . In X-jjy 
the conjunct 
is equivalent to 
which, by (*) before Theorem 8.5.2, is equivalent to 
and hence, by induction hypothesis, to an FO(M-LFP)-formula of quantifier 
rank < j . Finally, we show how to rewrite 
UCA;ai^Ua^U 
as an FO(M-LFP)-formula of quantifier rank < j . This formula has the form 
for suitable finite sets F and A^. Let H be the set of functions h with domain 
r such that h{'y) G A^ for 7 G F. Then, as usual, we can interchange the 
order of V and /\, thus obtaining the equivalent formula 
yX{^Xvi 
^ A V M^Xv 
A ip^hi-r))) 
header 
which in turn is equivalent to 
/\ \/X{^Xv, ^ M^Xv A V 'P,h(,))). 
hen 
7er 
But, using (*) again, this formula can be rewritten as 
/\[LFP,,x V ¥'7M7)]vi-
hen 
7er 
Note that the ^^7/^(7) have quantifier rank < i — 1. 
• 
The following corollaries are now proven as in the case of first-order logic. 
Corollary 8.5.6 For every FO(M-LFP)-lenience (p of quantifier rank m, 
|=fin ^ -^ \/{XA 
\ ^ is a finite model of ip}. 
D 

8.5 Fixed-Point Logics and Second-Order Logic 
217 
Corollary 8.5.7 For a class K of finite structures the following are equiva-
lent: 
(i) K is not axiomatizahle in FO(M-LFP). 
(ii) For each m > 1 there are finite structures A and B such that 
AeK, 
B^K, 
and 
A^^B 
{where A = ^ B means that the duplicator has a winning strategy in 
MLFF-Gm{A,B)). 
D 
8.5.1 Digression: Implicit Definability 
Let £ be a logic. An n-ary query Q on the class of r-structures is implicitly 
JC-definable if - with R a new n-ary relation symbol - there is an JC[TU {-Re-
sentence ipiR) such that 
(1) H n 3^'XV'(X); 
(2) for any r-structure A, 
{A, Q{A)) [= ip{R). 
We then say that ipiR) (or, ip{X)) implicitly i2-defines Q. In section 3.5 we 
used the notion of implicit definability in a slightly different way; essentially, 
(1) was replaced by |=fin 3--^Xil){X). In order to distinguish both notions, 
one sometimes speaks of weak (in the present case) and strong implicit de-
finability. 
Clearly, any £[r U {i?}]-sentence i^(R) such that 
implicitly /^-defines a query. Note that for first-order ip{X) the formula 
3^^X'il){X) is a second-order formula. 
We show that any formula of FO(LFP) is equivalent to a first-order for-
mula that contains relations implicitly definable in FO: 
Theorem 8.5.8 Given an FO(LFF)-formula 
^{x), there are a first-order 
formula i^o{X) and a first-order formula ipi^x^X) {where the free variables 
always are among the displayed ones) such that 
(a) N n 3=iXV;o(X) 
(b) ^=fin VX(V^o(X) ^ {i^{x) ^ 
M^,X))). 
Proof. For notational simplicity let (p be a sentence. By 8.2.9, we can assume 
that (p = 3u[LFF^^z x(^5 ^)] u with first-order %. Let Z be A:-ary Recall the 
definition of the stage comparison relation <^ associated with % (denoted by 
<Fx in section 8.2): 
y <x^ 
iff 
for some n > 1, y e F^ and ^ € F^ \ F^_-^ 
{y and J range over fc-tuples). 

218 
8. Logics with Fixed-Point Operators 
We show that <x is implicitly FO-definable by a formula 'ipo{<)- Then we 
are done, since t G F^ is equivalent to ^ <^ ^ and hence, we have 
Nfin V < (V'o(<) -> (V^ ^ ^UU < U)). 
When defining ^po{<) we use the abbreviations: 
y <^ 
for 
y <'z f\-^'z 
<y 
pred(J) 
for 
{y | ^ < z} 
field(<) 
for 
{z \ 3y{y 
<zVz<y)}. 
As 'ipo{<) we take the conjunction of (l)-(4) where 
(1) " < is a reflexive and transitive relation on field(<)" A 
"^y e field(<)V^ G field(<) (y <z \/ z <y) 
(2) Vz(^<^^x(^,field(<))) 
(3) yziiz <zA -n3yy <z)^ 
x(^, 0)) 
(4) VyVz G field(<)(s^ < z O x{y, pred(^))). 
We prove that ipoi"^) implicitly defines <^: In a model of V'o(<) let ^ be the 
ordering induced by < on the classes of the equivalence relation ~ given by 
^ ~ z 
iff 
y <'z and 'z <y. 
Then, an induction on n > 1 using (3) and (4), shows that for y G field(<) 
the class of y is the n-th element of ^ iff ^ G F^ \ -Fn-i-
Together with (2) this yields that V'o(<) impficitly defines <^. 
D 
Given a logic £, let IMP(£) be the logic that allows to define exactly 
those queries that are expressible in C using implicitly ^-definable queries. 
More precisely: An IMP(£)[T]-formula ip{x) with free variables among x is a 
tuple 
(V^l(/?l), . . .,'ll)m{Rm),'ip{x, 
i?l, . . . , Rm)) 
where m > 0, each ipi{Ri) is an >C[TU{jRi}]-sentence, and xp{x,i?i,..., 
Rm) G 
£[rU{i?i,..., Rm}] has free variables among x and 
hfin 3='XiMXl) 
A . . . A 
3=^Xm^m{Xm)-
The meaning of ip{x) is that of 
yXi 
. . yXrniiMXl) 
A ^ • • Ai^rniXrn)) 
^yx{^{x) 
^ 
^P{x,Xu. 
. . 
,Xrn))), 
i.e., for any r-structure A and a £ A, 
A[=(p[a] 
iff 
A\='ip[a,Ri,...,Rm] 
where Ri is uniquely determined by ^ |= ipi[Ri]. The preceding theorem 
shows 

8.5 Fixed-Point Logics and Second-Order Logic 
219 
Corollary 8.5.9 FO(LFP) < IMP(FO). 
D 
It has been shown (cf. [29]) that IMP(FO) ^ FO(LPF), even IMP(FO) 
Since the formula 
(V'l (i?l), . . . , 'lpm{Rm),^{x, 
/?1, . . . , Rm)) 
in the definition of 1MP{C) is equivalent to 
VXi . .yXmiiMXl) 
A ... A ^Pm{Xm)) -> Hx,Xi, 
. . 
.,Xm)) 
and to 
3Xi... 3X^(^1 (Xi) A ... A i^miXm) A iP(x, X i , . . . , X^)) 
we get 
Proposition 8.5.10 IMP(FO) < A}. 
D 
Exercise 8.5.11 Show: IMP (IMP (FO)) = IMP(FO). 
D 
Exercise 8.5.12 Show that IMP(FO(PFP)) = FO(PFP) on ordered struc-
tures (use Theorem 8.5.1). 
D 
Exercise 8.5.13 Let ^ be a r-structure. For an ordered representation 
(.4, <) let 
'^{A,<) be the {0, l}-word obtained by concatenating the inscrip-
tions of all input tapes of a Turing machine started with {A, <). For fixed A, 
all orderings < lead to words of the same lengths, say /. 
(a) Show: w;(^,<i) = ^/^(A<2) i^ (A <i) = (A, <2). 
An ordering < on ^ is minimal, if for all orderings <' on A the word iy(^,<') 
is not smaller than w^(^,<) in the lexicographic ordering of {0,1}^ Hence, by 
(a), there is a unique minimal ordering iff A is rigid. Let Q be the query 
that assigns the minimal ordering to a rigid structure and the empty binary 
relation to a nonrigid one. 
(b) Show that Q is expressible in IMP(FO(PFP)) (and thus, IMP(FO(PFP)) 
£ L^^ by 8.4.12). Hint: A formula ^(X) implicitly defines Q if it expresses 
in any A that "X is an ordering, and for all orderings Y different from X we 
have: If TT is the map with n : (A,X) ^ (A,F), then not n : {A,X) ^ 
iA,Y), 
and if R is the first relation and a the first X-tuple such that 
R-^a ^ R-^T^ia) does not hold, 
then 
not R^a and /?'^7r(a), 
or there is no such ordering and X = 0". To get '0(X) as an FO(PFP)-formula 
note that in the presence of X and F, the map TT is definable in FO(LFP) 
and that, in the presence of the ordering X, the second-order quantification 
"for all y " can be expressed in FO(PFP) (cf. the proof of 8.5.1). 
D 

220 
8. Logics with Fixed-Point Operators 
Notes 8.5.14 The game-theoretic characterization of FO(LFP)-equivalence 
is due to Bosse [14]. Theorem 8.5.8 is due to Kolaitis [101], Exercise 8.5.13 is 
taken from [81]. 
8.6 Transitive Closure Logic 
One of the most prominent examples of a global relation expressible in least 
fixed-point logic but not in first-order logic is the transitive closure of a 
given relation. Transitive Closure Logic FO(TC) is obtained by adding to 
first-order logic the operation of taking the transitive closure of definable 
relations. We have introduced FO(TC) already in Chapter 7, where we showed 
that FO(TC) captures NLOGSPACE. This section contains a more detailed 
analysis of the expressive power of FO(TC); it can be read independently of 
Chapter 7. 
First we recall some definitions. Let k > 1 and X be a 2A;-ary relation on a 
set A. The transitive closure TC(X) of X is defined by 
TC(X) := {(a, 6) G A^^ | there exist n > 0 and eo,... ,6^ G ^^ such 
that a = eo, 6 = e^, and for all i < n, (e^, ej+i) G X}, 
and the deterministic transitive closure DTC(X) by 
DTC(X) := {{a,b) G A^^ \ there exist n > 0 and eo,... ,6^ G A^ such 
that a = eo,6 = e^, and for all i < n, e^+i is the 
unique e for which (ei,e) G X}. 
For a vocabulary r the class of formulas of FO(TC) of vocabulary r is given 
by the calculus with the following rules: 
(i) 
where cp is an atomic first-order formula over r 
(ii) 
cp 
(f.il; 
if 
^Lp 
(if V '0) 
3a;(y9 
(iii) 
- 
where the variables in ^, y are pairwise distinct and 
L 
a;,y V^J 5 
where the tuples x,y,'s, 
and t are all of the same 
length, s and t being tuples of terms. 
For FO(DTC), rule (iii) is replaced by 
r ^ ^ with the same side 
[DTCx,y ^\ St 
conditions. 
Sentences are formulas without free variables, where the free occurrence 
of a variable is defined in the standard way with the additional clause 
free([TC^,^ cp] st) 
:= 
free(s) U free® U (free((^) \ {x, y}), 
and similarly for DTC. 

8.6 Transitive Closure Logic 
221 
The semantics is defined inductively w.r.t. the calculus above, the meaning of 
[TC^^y ^{x,y)] St being (sj) G TC{{{x,y) 
\ ^{x,y)})] and 
[DTC^^yip(x,y)]st 
expresses that {s,t) G BTC({{x,y) 
\ 
ip(x,y)})P 
Examples and Remarks 8.6.1 (a) FO(DTC) < FO(TC) since 
H n [DTC^^yip{x,y)]si 
^ 
[TC^^y{ip(x,y)AWz{ip{x,z)->z^y))]si. 
(b) FO ^ FO(TC) since 
\fxVy{--x = y^ 
[TC:,,yExy] xy) 
expresses "connectivity" in the class of graphs (cf. 2.3.8). 
(c) FO ^ FO(DTC) since 
\Jx\fy[DTC^,yExy]xy 
is an FO(DTC)-sentence which, for every / > 1, holds in the digraph Vi 
consisting of a cycle of length / + 1, but not in the union ViUVi. Moreover, 
\/u\/v3w3z[DTCa;y,x'y' {Exy A Ex'y' Ax' =y A-^y' = x)] uwvz 
separates the "undirected" cycles Qi from QiUQi for I >2. 
(d) FO(TC) < FO(LFP) since 
Hfin [TC^,y (p{x, y)] St ^ 
[LFP^^,x {(p{x, y) V 3u{Xxu A ip{u, y)))] st. 
D 
Exercise 8.6.2 Show that the class of bipartite graphs is axiomatizable in 
FO(TC). Hint: Use 6.3.6. 
D 
Exercise 8.6.3 For r > 1 let FO(TC^) be the fragment of FO(TC) con-
sisting of those formulas, where for each subformula of the form [TCx,y^] M 
we have length(^) = r. Clearly, FO(TCi) < F0(TC2) < ... Show that 
FO(TC^) = MSO on the class of word models (cf. section 6.2). (Hint: 
FO(TC^) < MSO is true in general; for MSO < FO(TCi) give a proof by 
induction on regular expressions (cf. section 6.1).) 
Define FO(DTC0 similarly and show that F0(DTC2) ^ MSO on the 
class of word models. (Hint: Use the fact that the set {a^b^ | n > 1} is not 
regular.) 
D 
8.6.1 FO(DTC) < FO(TC) 
By the results of Chapter 7 we know that 
^^ Recall that the notation (p{x,y) exhibits only the variables relevant in this situ-
ation. So (p may contain free variables that are not among x, y. 

222 
8. Logics with Fixed-Point Operators 
• 
FO(DTC) ^ FO(TC) on ordered structures iff 
LOGSPACE # NLOGSPACE 
• FO(TC) ^ FO(LFP) on ordered structures iff NLOGSPACE i^ PTIME. 
The inequalities on the right hand side are prominent open problems of com-
plexity theory. The following remarks will lead to a proof of FO(DTC) ^ 
FO(TC) for arbitrary finite structures; the corresponding inequality FO(TC) 
^ FO(LFP) will be shown in subsection 8.6.3. 
Definition 8.6.4 A subset C of a structure A is said to be closed if for all 
a £ A\C there is an automorphism TT of ^ pointwise fixing C with 7r(a) ^ a. 
D 
Every DTC-path starting in a closed set must stay in it: 
Lemma 8.6.5 Let C be a closed subset of a structure A. For every formula 
(p{x,y,'z) with free variables among x,y,^ 
and for every c e C, 
A 1= [T)TCx,y^{x,y,c)]xy[ab] 
and a e C imply b e C. 
Proof Since (a,6) G DTC((/?-^(_,_ ,c)), there IS 9; SGQUGI1C6 60 5 • • • 5 C?n 
such 
that 
(*) 
a^eo,b 
= Cm, and for i < m, A\= \fy{(p{ei,y,c) ^y 
^ e^+i). 
lib^C 
then there is a j < m such that e^- G C and e^+i ^ C, say, 
ej+i = e i . . . efc and ei ^ C Choose an automorphism TT of ^ pointwise fixing 
C with 7r(ei) 7^ e^. Then 
A ^ (/?[e^-,ej+i,c], 
A |= (/?[ej,7r(ej-+i),c], 
and e^+i / 7r(e^+i), 
contradicting (*). 
D 
By the lemma there is a bound for the length of DTC-paths without 
repetitions that start in a closed set of a given cardinality. This is the reason 
why in classes of structures with many closed sets of controllable cardinality, 
so-called indiscernible classes, every DTC operation is first-order definable. 
We thus are led to a proof of FO(DTC) ^ FO(TC) by showing 
- FO(DTC) = FO on every indiscernible class. 
— FO(TC) ^ FO on some indiscernible class. 
Definition 8.6.6 Let / : N -^ N be monotone (that is, m < n implies 
/(m) < /(n)). A structure A is said to be f-indiscernible^ if for every subset 
X of ^ there is a closed set Y such that X C F C A and ||y|| < /(||X||). A 
class K of structures is indiscernible if, for some monotone function /, every 
structure in K is /-indiscernible. 
D 
Proposition 8.6.7 Let K be an indiscernible class. Then, on K, every for-
mula o/FO(DTC) is equivalent to a first-order formula. 

8.6 Transitive Closure Logic 
223 
Proof. Let K be indiscernible via / and (f{x,y,^) 
with x — Xi .. .Xk^y — 
yi .. .yk, and z — zi.. .zihe an FO-formula. Suppose that A ^ K^c £ A, and 
(a,6) e DTC((/?"^(_,_ ,c)). Choose a closed set C C A such that {a,c} C C 
and ||C|| < m := f{k-\-l). By the preceding lemma, every deterministic path 
connecting a and h stays within C; hence, the shortest such path has length 
< m^. Therefore, [DTC^,^ (^(x, j^,;^)] st is equivalent to a first-order formula 
expressing "there exists a deterministic 9?-path of length < m^ from s to P ' . 
D 
For any structure ^ in a relational vocabulary r we denote, as in section 
5.2, by ^ X 2 the structure we get by duplicating each element. To be precise, 
let ^ X 2 be the r-structure with universe ^ x {0,1} such that for any n-ary 
jr^Ax2 _ {((ai,ii),...,(an,in)) I R^ai...an 
and ii,...,in 
G {0,1}}. 
Lemma 8.6.8 Ax2 
is fo-indiscernible, where fo{m) = 2-m. 
Proof. Clearly, for X C ^ x 2 the set 
CiX) 
:= 
XU{{a,i)\{aA-i)eX} 
is closed: for any (6,i) G (^ x 2) \ C(X), the function TCt : A x 2 -^ A x 2 
given by 
(a,j) 
if a 7^ 6 
is the desired automorphism. 
D 
Theorem 8.6.9 FO(DTC) ^ FO(TC). 
Proof. First of all note that 
(*) 
A=mB 
implies ^ x 2 ^ ^ >B x 2. 
Let K := {gi\l> 
2} be the set of cycles and let H := {QiUQi | / > 2}. By 
the preceding lemma the sets K x 2 {:= {A x 2 | ^ G K}) and H x 2 are 
indiscernible. Since Qi =rn Qi^Qi for / > 2^ (cf. 2.3.8), (*) shows that there 
is no first-order sentence separating K x 2 and H x 2, and hence by 8.6.7 
and 8.6.8, no FO(DTC)-sentence. But the structures in X x 2 are connected 
graphs and those in ^ x 2 are not; thus there is a separating FO(TC)-sentence 
(cf. 8.6.1(b)). 
D 
Exercise 8.6.10 Show that the class of bipartite graphs is not axiomatizable 
in FO(DTC). 
D 

224 
8. Logics with Fixed-Point Operators 
8.6.2 FO(posTC) and Normal Forms 
Let FO(posDTC) and FO(posTC) be the logics consisting of the formulas 
of FO(DTC) and FO(TC) in which DTC and TC, respectively, only occur 
positively, i.e., within the scope of an even number of negation signs (we 
assume that the formulas of FO(DTC) are built up from atomic formulas 
using -., A, V,V,3, and DTC; similarly for FO(TC)). 
Proposition 8.6.11 FO(posDTC) = FO(DTC). 
Proof. The proof of the nontrivial part proceeds by induction on the num-
ber of occurrences of logical operations (-i, A, V, V, 3,DTC) in a formula 
of FO(DTC). In the main step of the induction we have to show that an 
FO(DTC)-formula of the form 
(*) 
-^[DTC^,y^{x,y)]st 
is equivalent to an FO(posDTC)-formula where, by induction hypothesis, 
we may assume that cp and -up are equivalent to FO(posDTC)-formulas. 
Obviously, (*) just says that the deterministic (/?-path starting at s reaches, 
without passing through t, a point ^, where it ends or where a (^-cycle starts 
that does not contain t. Noting that the deterministic (/?-path ends at ^ if ^ has 
no or more than one (/^-neighbour, we thus can express 
^[DTCxy^(x,y)]'st 
by 
3z{{s = z\/ 
[DTC^,^ {^(x,y) A^y = t)] sz) A 
{Wx^^{z,x) 
\/3x3y{ip{z,x) 
A(p{z,y) A^x = y) V [DTC^,^((^(x,^) A -^y = 
t)]zz)). 
Applying the induction hypothesis to cp and -xp we see that this formula is 
equivalent to an FO(posDTC)-formula. 
D 
Note that the maximal number of nested occurrences of the DTC operator 
in an FO(DTC)-formula and in the FO(posDTC)-formula assigned to it in 
the preceding proof are the same. We use this fact when showing 
Proposition 8.6.12 FO(DTC) < FO(posTC). 
Proof. By the preceding proposition it suffices to show that FO(posDTC) 
< FO(posTC). The proof is by induction on the number of nested DTC 
operators, the only nontrivial step being the case of an FO(DTC)-formula of 
the form 
[BTC^,yip{x,y)]si. 
By the remark preceding the proposition, -^(p is equivalent to an FO(posDTC)-
formula with the same maximal number of nested occurrences of the DTC 
operator as ip. Thus, by induction hypothesis, both cp and ^(p are equivalent 
to formulas of FO(posTC); therefore the same holds for 
[DTCx,y^{x,y)]'st, 
since this formula is equivalent to [TCx.y {^{x, y) A Vz(--(/?(x,'z)y^ = y))] st. 
D 

8.6 Transitive Closure Logic 
225 
We have already shown in Chapter 7 that FO(posTC) = FO(TC) on 
ordered structures. Below, we give a purely modeltheoretic proof of this fact. 
On arbitrary structures, FO(posTC) has less expressive power than FO(TC). 
The next proposition contains a normal form for a fragment of FO(posTC) 
that will be useful for our purposes. 
Proposition 8.6.13 Suppose that r contains two constants c and d. Let (p 
be an existential FO(posTC)-/ormn/a, that is a formula built up from atomic 
and negated atomic formulas with the help of A, W, TC, and 3. Then, in 
models of -^c = d, (p is equivalent to a formula of the form 
[TCx,x''4^{x,x')]cd 
where ip is quantifier-free. 
Proof The proof proceeds by induction on cp. Of course, any first-order for-
mula (f is equivalent to [TC^,^' if] cd^ where 
variables not occurring in 
Lp. Let (p = ((/?i V (^2) and suppose that cpi is equivalent to [TCx,x'i^i{x,x')]cd 
with quantifier-free ^^ (add dummy variables to obtain sequences x,x' of 
the same length for (pi and (p2). Then (p will be equivalent to a formula 
[TCxx,x'x'i^{xx,x'x')]ccdd, 
where the additional arguments x and x' in ip are 
used as a switch as indicated by the figure 
CO 
. . . — y . . . 
dc 
I 
I 
cd 
... -^ 
... 
dd 
In the formula ip below, the first line corresponds to the upper path in the 
figure leading from cc to dd, and the second line to the lower path: 
ip^xx^^'x') 
:= 
{x = x' = c A 11)1) y {x = x' — d A X = c A x' = d) 
\/{x = x' = cAx = cAx' — d)V{x = x' = dA -02)-
Similarly, for the conjunction (cpi A (^2) we take as ip{xx,x'x') 
a formula 
expressing the existence of a path as indicated by 
cc ... —> ... ac —> ca ... —> ... ad. 
Now suppose that (p — [TCu^vip'JM where, by induction hypothesis, we can 
assume that (p' has the form [TC^,^' il)'{x,x',u,v)] cd with quantifier-free ip'. 
Let s = eo,... ,efc = ^ be a path witnessing that {s,t) G TC((^'(_,_)). 
Then, for i = 0,..., A: — 1 there is a ^'-path witnessing that (c, d) G 
TC(^'(_,_ ,ei,e^+i)). Therefore, ip is equivalent to 
[TCuvx,u'v'x'i^{u, V, X, u',v',x')] cccddd 
where in the formula ip given below the first line sets the correspond-
ing starting values, the second line takes care of witnessing that (c,d) G 

226 
8. Logics with Fixed-Point Operators 
TC(^'(_,_ ,6^,6^+1)), the next line allows to pass from the tuple 6^,6^+1 to 
Cj+i, ei+2 5 and the last line realizes that e^ = t: 
ip{u,v,x,u' ,v',x') 
:= {u = c Av — c Ax = cAu'= 
s Ax'= c) 
y (-nx = d Au'= u Av'= v 
Aip'^x^x',u,v)) 
V (x = d A ^v — t Au' — vA'x' = c) 
\y(x = dAv = tAu' = dAv'^dAx' 
= d). 
For the existential quantifier note that 
^fin ^zip{z) ^ [i:C^^y{{x = cA ip{y)) V {ip{x) Ay = d))] cd. 
So we can apply what we already know to obtain the desired normal form 
also for this case. 
D 
Corollary 8.6.14 Let r D {<, 5, min,max}. On ordered r-structures with 
at least two elements, every FO{posTC)-formula 
is equivalent to a formula 
of the form 
[TC^^^/ ip{x, x')] minmax: 
with quantifier-free ip. 
Proof In ordered models, ^x(p{x) is equivalent to 
[TCx,y{^(x) 
A Sxy A <^{y))] minmax. 
Hence, the universal quantifier can be eliminated in FO(posTC)-formulas. 
Thus the claim follows from the preceding proposition. 
D 
We use this normal form for FO(posTC)-formulas when proving now that 
FO(posTC) = FO(TC) on ordered structures. 
Fix a vocabulary r for ordered structures, for simplicity, r D {<, 5, min, max}. 
We saw in 8.1.11 that for /c > 1 the successor relation S^ of the lexicographic 
ordering of A:-tuples is first-order definable. For any ordered r-structure A 
with A = {0,... ,n — 1} and for any m i , . . . , rrik G A we set 
[mi,...,mfc] 
:= mi • n'^~^-{-...-^ mk-i - n-\-nik-
In the following we use self-explanatory notations such as / = m-I- 1 for S^ml 
or, equivalently, for [/] = [m] + 1. Often we write 0 for min. 
Theorem 8.6.15 On ordered structures, FO(posTC) = FO(TC). 
Proof. The proof- a purely modeltheoretic version of the proof given in 7.5.20 
- proceeds by induction on FO(TC)-formulas. The only nontrivial case is the 
negation step. By induction hypothesis and the corollary above it suffices to 
show for first-order ip that 

8.6 Transitive Closure Logic 
227 
is equivalent to an FO(posTC)-formula.^^ 
Suppose X = xi .. .Xr- Given a structure A and a,6 G A"^, let d^(a,b) be 
the length of the shortest ip-paih connecting a and 6, 
d^{a,b) := min{A: > 0 | there exist ao = a,ai,...,ak 
=b such that 
A 1= ilj[ai,ai+i] for i <k}, 
where d^{a,b) := oo in case the set on the right side is empty. Obviously: 
(1) If d^{a,b) < oo then 0 < d^{a,b) < ||A||^ 
Moreover, -> [TCx^ytpix^y)]^ 
is equivalent to 
\\{v\d^{s,v) 
< oojll = \\{v\d^^^^^y^^^y^i^{s,v) 
< oo}||. 
We show stepwise that the ingredients of this equality are definable in 
FO(posTC). Note that the number ||A||^ has the string 10 of length r + 1 
as its |m|-adic representation. 
(2) For (p(xi,...,Xr,yi,...,yr) 
€ FO(posTC) there is an FO(posTC)-for-
mula x{x, y,zi,..., 
Zr+i) expressing d^p{x^ y) < ^; more precisely: for any 
ordered A and a,b,m £ A, 
A \= x[a, 6, rn] 
iff 
d^p (a, 6) < [m]. 
To obtain such a formula x, we use the TC operator to go through all the 
tuples of a path leading from x to y: 
X{x,y,z) 
:= 
[TC«;j,^'j'((/?(W,wJ') A^ < 
z')]x06yz. 
(3) For first-order ip{x, y) there is an FO(posTC)-formula p^{x^ t) expressing 
\\{y\ d^{x,y) <oo}|| = z. 
For a proof we first note that by (1), 
\\{y I d^(x,y) < (X)}|| = \\{y \ d^{x,y) < 
\\A\n\\. 
To obtain a formula p^{x,J) 
we use-an inductive definition of the function 
9{u) {= g{x,u)) 
:= 
\\{y \ d^{x,y) < u}\\, 
g{lO) (= II{^ I d(p{x,y) < m||'^}||) being the value we are interested in. 
By (1), giOb) = 00. Suppose g{u) = \\{yj d^{x,y) 
< u}\\ = z where 
u = ui .. .Ur+i. Fix y. If u = 00 then d^pix^y) -^ u -\- 1 \s equivalent to 
-^(p{x,y). If w 7^^ 00 then d^{x,y) ^ w + 1 iff there are 1 many w such that 
^^ The restriction to structures with at least two elements is removed as for 
FO(LFP) after 8.2.11. 

228 
8. Logics with Fixed-Point Operators 
w ^y^ d^pix^w) < It, and -^ip{w,y). In the following formula X(p(^,w,z,:^') 
the inner TC operator serves to count these w {q — qi ... qr+i being the 
counting variables) and thus to check whether there are 'z many. If g(u) = ^ 
then x<^{x,u,^,^') 
expresses that g{u + 1) = 'z'. Set with v = vi ... Vr+i 
X^{x,u,z,^') 
:= [TCy^^y'r iiV' =y + '^/\v' =v + l A d^{x,y) 
<u-\-l) 
V {y' — y -\- 1 Av' =v A u = 0 A -^(fix, y)) 
\/(y[ = y + l A iJ' = iJ A -.w = 0 
A [TCyjq^w q' {{w' =w + l Aq' =^q) V {W' = w-\-1 A q' = q + 1 
A-^w = y A d^{x,w) <u A -n(/?(W,^)))]0 00i^))]0 00 1J'. 
By (2), we can view x^ ^is an FO(posTC)-formula. Now 
p^{x,z) 
:= 
[TC^j,^/J. (w' == w + 1 A xA'^.u,z,z'))]00 
00l6z 
expresses that ^(10) = ^ and hence, that ||{^ | d^pi^^y) < (X)}|| = 1. We can 
regard p^ as an FO(posTC)-formula. This finishes the proof of (3). 
As remarked above, ^[TCx,y4'{x,y)]M 
is equivalent to 
\\{y' I d^(s,y') 
< oo}|| = \\{y' \ d^^^^^^^^^^^j^ {s,y') < oo}|| 
and thus, by (3), to the FO(posTC)-formula 
3Z{P^{S, Z) A P(^(^,^)A-,y=t) (5, ^)). 
• 
In view of 8.6.14 we now have 
Corollary 8.6.16 Let r D {<,5,min,max}. On ordered structures with at 
least two elements, every FO{TC)-formula is equivalent to a formula of the 
form 
[TC^^^' '0(x, ^')]minmax 
where ip is quantifier-free. 
D 
Exercise 8.6.17 Let r be arbitrary. Show that for any existential formula 
cp of FO(posTC) there is a quantifier-free V^ such that in structures with at 
least two elements, ip and 3{'^)u[TCx,x''4^{x,x')]u 
s^re equivalent. Conclude 
that, on ordered structures, the same results hold for FO(TC). Hint: Note 
that in structures with at least two elements any Lp of the form 
(*) 
[TCx,w X{x,x')] si 
is equivalent to 3{'^)u[TCxvw,x'v'w' il^{'xvw,x'v''w')]uu, 
where 
ip{xvw,x'v'w') 
:= 
(x = v = wAx'='sA 
^v' = w') 
V 
{-^v = w A x{x,x') 
A -^v' — w') 
V 
{x — i A x' = V = w). 

8.6 Transitive Closure Logic 
229 
To show that any existential FO(posTC)-formula (/? is equivalent to a formula 
of the form (*) with quantifier-free x, get rid of the constants c and d in the 
proof of 8.6.13: the role of c is taken over by any (all) pairs vw with v = w, 
that of d by any (all) vw with v ^ w (similarly as in V^). 
D 
The next example shows that the class of formulas having the normal 
form of Proposition 8.6.13 does not contain all FO(posTC)-formulas. 
Example 8.6.18 Let r = {E,c,d} 
where E is binary. There is no sentence 
of the form 
(*) 
[TC^,r^{x,x')]cd, 
where ip is first-order, that is equivalent to yxyy[TCx,yExy] 
xy. By con-
tradiction, suppose that (*) is such a sentence. Let x = xi ... Xm and set 
k := qr('0). Choose / big enough compared with k and m. Since (^z,0,1) |= 
"ixMylTC^^yExy] xy (for Qi cf. 2.3.8), we have {Qi, 0,1) h= [TC^,r^(^,^')] c^-
Hence, there are 0 = eo,ei,... ,6^ = 1 with 
(^z,0,l) ^^[ei,ei+i] 
for i < n. In view of 2.3.8 and the choice of /, we have 
where 6^,6^+1 denote the corresponding elements in the first copy. But then 
(^z,0,l)ua/ ^ [TC^,^'^(x,x')]cJ, 
even though (^z, 0,1) U ^z ^^ \/xiy[i:C:c,yExy] xy. 
U 
8.6.3 FO(TC) < FO(LFP) 
The preceding example motivates how to handle the TC operation in a ga-
metheoretic characterization of the FO(TC)-equivalence of structures. Given 
m,r > 1 and structures A and H, the game TC-Q'[^{A^B) 
consists of m 
moves and is played, as usual, by two players, the spoiler and the duplicator 
(we shall see below that the number r is related to the arity of the TC op-
erators). In every move there are chosen some elements (possibly more than 
one) both in A and B. Let a i , . . . , a^ G A and 6i,..., 6s G B be the ele-
ments chosen in the first i moves of a play and denote by pi the assignment 
ai ... tts i-> hi.. .hg. The duplicator wins the play if pi is a partial isomor-
phism for alH < m (or, equivalently, iiPm is a partial isomorphism). In the 
i-th move the spoiler first decides whether the move should be a point move 
or a TC move; moreover, he chooses one of the structures, say A. The point 
moves are as in the first-order case. In a TC move the spoiler selects a j with 
1 ^ i ^ ^ and, for some A: > 1, a sequence ao,... ,afe of j-tuples in A with 

230 
8. Logics with Fixed-Point Operators 
ao and ak in the domain of p^_i (i.e., ao and a^ consists of elements already 
chosen or of constants). The duplicator answers by selecting, for some / > 1, 
a sequence 6o, •.. ,6/ of j-tuples in B with bo — Pi-i(ao) and \ — Pi-i{ak). 
Then the spoiler selects some /' < / and the dupHcator answers with ak' < k. 
This finishes the i-th move, the elements chosen in this move being a^/, a^z+i 
and bi',bi'+i. 
TC moves in which the spoiler chooses the structure A are called positive, 
those in which he chooses B, negative. 
Define the quantifier rank as in the case of FO with the additional clause 
qT{[TC^,yip]st) 
:= qr((/p) + l. 
Then one can show: 
Theorem 8.6.19 The following are equivalent: 
(i) The duplicator has a winning strategy for TC-GJ„(^, B). 
(ii) A and B satisfy the same FO{TC)-sentences of quantifier rank < m con-
taining the TC operator only in the form [TC^,^ ^p] M with length(x) < r. 
Proof. The proof proceeds along the usual lines; for the implication (ii) =^ 
(i) we give a direct proof of the only nontrivial step. 
We assume (ii) and explain a winning strategy for the duplicator in TC-
GJ^ {A, B). Suppose that in the first s moves of a play elements a in .4 and 6 
in B have been chosen and that 
(*) 
A\=^[a] 
iff 
B\=ip[b] 
holds for all FO(TC)-formulas ip(x) of quantifier rank < m — s {s = 0 cor-
responds to the assumption (ii)). Let p := a ^-^ b. Assume that the spoiler 
decides that the (s-l-l)-th move should be a TC-move, and let j with 1 < j < r 
and the sequence ao,..., a^ of j-tuples be his selections. For i < k set 
\Pi := 
{'il;{x,y,z) \ qT{ip) < m - s - 1 , A ^^ ip[a,ai,ai+i]} 
and let x(x,^,^) := Vi<fc A^i- (^^ course, /\^i 
is equivalent to a finite 
conjunction.) Clearly, 
A 1= 
[TCy,zX{0',y,z)]yz[ao,ak]. 
By (*), 
(+) 
B\=[TCy,jx{b,y,z)]yz\p{ao),p(ak)]. 
The duplicator selects a x-path p{ao) = 6o,6i,...,6/ = p{ak) witnessing 
(-I-). Suppose the spoiler now chooses 6//,6//+i. Then, for some k' < k, B \= 
^k' [^5 h' 5 h'+i]^ and the duplicator answers by a^','Ok'+i- By definition of ^k' ? 
A 1= ^lj\a,ak',ak'+i] 
iff 
>B ^ ^[6,6i/,6//+i] 
holds for all FO(TC)-formulas of quantifier rank < m - s - 1 . 
D 

8.6 Transitive Closure Logic 
231 
We now aim at a proof of FO(TC) < FO(LFP). The following classes of 
FO(TC)-formulas will be useful. For m > 0 and r > 1 define P^ by induction 
on m as follows: 
— PQ is the set of quantifier-free formulas. 
— P2m+i is the closure under conjunctions and disjunctions of the set P2m ^ 
{[TC^,yip]si I if G P^^, length(x) < r}. 
— P2m+2 is the closure under conjunctions and disjunctions of the set P2m+i ^ 
{-^[TC^,y^^]si 
I if e P2m+i, length(^) < r}. 
Since 3xip{x) and [TCx,y{{x = c A ^{y)) V {yp{x) /\y — c))] cc are equivalent, 
one gets by a simple induction on formulas: 
Lemma 8.6.20 If the vocabulary r contains at least one constant then every 
formula o/FO(TC) is equivalent to a formula in 
(J 
P^. 
D 
m>0,r>l 
We show FO(TC) < FO(LFP) by exhibiting a class of structures ax-
iomatizable in FO(LFP) but not in FO(TC). The underlying idea is already 
present in the following example. 
Example 8.6.21 Let r > 1 and r = {E,F,c} 
with E binary and F ("full") 
unary. Let A and B be the structures 
2r+l 
Points for which F holds are represented by full dots, 4- means that Ea b. We 
b 
show for quantifier-free (p and x with length (x^) < r that 
A \= [TCx,y ^] cc 
implies 
B f= [TC^,^ cp] cc. 
In fact, suppose that c = OQ,. .. ,ai — c witnesses {c,c) G TC((/?*^(_,_)). 
Successively choose 6o = c, 6i,..., 6^ = cm B such that a^ ai^i ^ bi bi^i is a 
partial isomorphism (such elements exist, since B contains 2r full elements). 
As (p is quantifier-free, B \= cp\bi,bi+i] and hence, {c,c) e TC((^^(_,_ )). 
D 
Using suitable refinements of A, B one can handle nested TC operators 
and show: 
Theorem 8.6.22 FO(TC) < FO(LFP) 

232 
Logics with Fixed-Point Operators 
Proof. Fix an r > 1 and let TQ := {£J, F}, where E and F are as in the 
preceding example. For m > 0 define ro-structures Ar,m and Br^m and their 
roots by induction on m as follows: 
Ar^o : 
O 
5r,0 * 
and the respective element is the root. Suppose that Ar,m and B^ 
roots have already been defined. Set 
and their 
r+l 
that is, v4r,m+i is the disjoint union of r + 1 copies of Br^m together with a 
new element, the root of ^r,m+i5 that is connected by the relation E to the 
roots of the distinct copies oi Brm- The structure Brm+i is defined in the 
same way, but one copy of Br^m is replaced by A^, 
can be full. The structure B2 2 looks like 
Note that only leaves 
Let r = To U {c} and let .4^^ and B^^ be the r-structures {Ar,m, "root of 
Ar^m^) and {Br,m, "foot of ;^r.,m")5 respectively. 
We recall or introduce some terminology. Let V be one of the structures 
Ar,m or Br,m' For d, d' e D we say that d' is a successor of d if E^dd', aiud 
that d' is a descendant of d if for some / > 0 there are do = d, di,..., d/ = d' 
such that E^didi+i for i < /. The height h(d) of d is the length of the largest 
^-path starting at d, i.e., 
h{d) := max{/ > 0| there are do = d,di,... 
,di with E^didi^i 
for i < I}. 
The substructure T{d) of T> whose universe T{d) is the set of descendants of 
d is called the tree generated by d. 

8.6 Transitive Closure Logic 
233 
Define the function colour: D —)• {black, white} by 
( \ 
1 
/ j \ ._ / black 
if T{d) = Br,h(d) 
^ ^ 
~ 1 white 
otherwise. 
The inductive definition of Ar,m and Br^m leads to the following definition of 
colour by induction on the height: The point d is of black colour if it is full 
(i.e., if F^d holds) or if it has a white successor. More precisely, colour(d) = 
black iff 
V ^ [WFa^^xiFx V 3y3z(Exy A Exz AXy A ^Xz))] x [d]. 
Using © for a black point and O for a white point, the structure ^2,2 looks 
as follows: 
Let (/?o be a sentence of F O ( L F P ) [ T ] saying that the root is black, that is, 
an FO(LFP)-sentence equivalent to \[FVx,x{Fx V 3y3z{Exy A Exz A Xy A 
^Xz))] c. Then, in view of (*), we have 
(1) For all m > 0,r > 1 : 
A'^^^ |= --(^o and B'^^^ \= (po. 
Therefore, by Lemma 8.6.20, we are done if we show: 
(2) Let A; > 0 and let cp be an FO(TC)-sentence in P^. Then for m > 2-k, 
Ar,m 
N ^ 
iff 
^2r,m N ^• 
We prove (2) by induction on k^ showing a corresponding statement for for-
mulas and assignments to their variables. As in the example preceding this 
theorem one carefully has to choose the elements in the right copies. To make 
precise the notion of "right copy" we have in mind, we introduce the concept 
of an amenable function. A function TT : Ar^m -^ Br,m is amenable if 
- IT : Ar,n.\{E} 
^ 
Br,m\{E} 
— For every / < m there exists exactly one a G Ar^m such that h{a) = I and 
colour (TT (a)) ^ colour (a). The element a is called the TT-critical point of 
height /. 
Note that if n is amenable, a its critical point of height /, a' its critical point 
of height /', and /' < /, then a' G T{a). There is an amenable function from 

234 
8. Logics with Fixed-Point Operators 
Ar,m to 8r,m', this is obtained by induction on m : If TTQ : Ar,m -> 8r,m 
is amenable, then n : Ar,m+i -^ 8r,m+i is amenable, where (compare the 
figures defining Ar,m+i and Br,m+i) '^ maps the root of Ar,m+i to the root 
of Br,m+i, Ti" equals TTQ^ on the leftmost copy of Br,m that is attached to the 
root of Ar,m+i, and is the identity on the remaining copies. 
In the example preceding this theorem, when choosing the elements 6j, we 
avoided the element of B, which is not full and distinct from the root. Here we 
have to avoid elements below critical points of suitable height. More precisely, 
one can show by induction on k: 
(3) Suppose that s,k > 0 and m > 2-k. Let ai,a[,... 
,as,a'g be r-tuples 
in A2r,m' Furthermore, let TT : A2r,m -^ B2r,m be amenable and let a be its 
critical point of height 2k. Finally, assume that 
{ a i , a ; , . . . , a „ a ; } n r ( a ) = = 0 . 
Then, for every ip{xi,x[,... 
,Xs,x'g) G P[ with free variables among the dis-
played ones, 
^2r,m N ^[^i,a[,... 
,as,a'g] iff B'2r,m N ^^(^1),7r(ai),... ,7r(as),7r(a'J]. 
Once this is shown, we get (2) by taking s:=0 and as n any amenable function 
from A2r,m 
t o 
B2r,m-
In the inductive proof of (3) the case A^ == 0 is obvious. To prove (3) for 
A^ > 1 under the assumption that it is already proved for k—1, it suffices to 
show for m > 2-A; (writing a for aia'i .. .aga'^) 
(+) 
^2r,m N [TC^.j V] St [a] iff B^,.„ \= [TC^,y V-] St [77(0)1 
where length(x) = r and -0 G P[_i-
First we assume that the left side of (+) holds, CQ,. .. ,ci being a witnessing 
sequence. Our aim is to construct a witnessing sequence for the right side. 
As ci contains less than 2r+l elements, not all of the 2r+l copies of B2r,2k-i 
attached to a contain one of these elements. Hence, we can find di in B2r m: 
but outside the copy of A2r,2k-i attached to 7r(a), and an amenable n' : 
^2r,m ~^ ^2r,m ^hat coiucides with TT outside of T{a) \ {a} such that 
7r'(ci) = di 
and such that a,co,ci and TT' satisfy (3) for k — 1. Hence, by induction hy-
pothesis, 
62r,mNV'[T'(a),7r'(co),7r'(ci)]. 
Treating now the pair ci,C2 in the same way (ci,C2 contains less than 2r+l 
elements!), where the counterpart di of ci is already defined, and continuing 
in this way up to the pair ci-i,ci, we get a witnessing sequence do,di,... 
,di 
for the right side of (-h). 

8.7 Bounded Fixed-Point Logic 
235 
For the other direction we argue similarly. Concerning elements of the 
witnessing sequence in the copy of A2r,2k-i attached to 7r(a), we proceed 
with this copy as with T{a) above, thus, altogether, decreasing the height of 
the critical point of the induction hypothesis by two. 
D 
Notes 8.6.23 Theorem 8.6.9 is due to Gradel and McColm [56]. Subsection 
8.6.2 is based on [93, 94]. The trees in subsection 8.6.3 go back to [18]. 
8.7 Bounded Fixed-Point Logic 
In the preceding section we already mentioned that an application of the TC 
operator can be replaced by an application of the LFP operator. In fact, 
^fin [TC^,^(^(^, y)] si o [LFP^,y {ip{s, y) V 3x{Yx A ip{x, y)))] i. 
Conversely, every FO(LFP)-formula of the form 
[LFFy,Y{xlj{y) V 3x{Yx A ip{x,y)))] t 
where Y does not occur in if) and </?, is equivalent to 
iP(t) V 3x{i)[x) A [TC^,^ ^{x, y)] xt). 
In this sense, transitive closures correspond to those least fixed-points, where 
each tuple in a new stage is already witnessed by a single tuple of the pre-
ceding stage. We generahze transitive closure logic to Bounded Fixed-Point 
Logic FO(BFP), which allows the LFP operator only if there is a bound r > 1 
such that each tuple in a new stage is already witnessed by a set of at most 
r many tuples of the preceding stage. More precisely: For a vocabulary r the 
class FO(BFP)[r] of formulas of FO(BFP) of vocabulary r is given by 
• the rules of first-order logic starting from first-order atomic formulas (i.e., 
no relation variables are allowed) 
• the "BFP-rule" 
y>o(^), ipi{y,xi,...,Xr) 
[LFPj^,y((^o(y) V 3^1 ... 3xr {Yxi A ... A Yxr Aipi{y,xi,... 
,Xr)))] i 
where Y is an s-ary relation variable for some s > 1, and where r > 0 and 
xi,... 
,Xr are s-tuples of variables, all variables inxi,... 
,Xr being pairwise 
distinct. (Note that Y does not occur free in ^o or ^i.) 
We abbreviate the formula above by 
[LFP^,y {ipo{y) W3xieY...3xre 
Ycpiiy^xi,... 
,Xr))]i. 
Sometimes, bounded fixed-point logic is called stratified fixed-point logic. This 
name will become clear in the next chapter. 

236 
8. Logics with Fixed-Point Operators 
Denote by FO(BFPro) the logic obtained by restricting the BFP-rule to r with 
r < TQ. The introductory remarks show part (c) of the following proposition, 
parts (a) and (b) being trivial. 
Proposition 8.7.1 (a) FO(BFP) < FO(LFP) 
(b) FO(BFPo) = FO 
(c) FO(BFPi) = FO(TC) 
(d) F0(BFP2) = F0(BFP). 
Proof, (d) The proof proceeds by induction on FO(BFP)-formulas. In the 
main step we show that 
(*) 
[LFP^,y {ipo{y) V3xieY...3xre 
Yipi{y,xu... 
,Xr))]t 
is equivalent to a formula of F0(BFP2) under the assumption that cpo and 
(^1 are already in F0(BFP2). For simplicity we assume that Y is unary and 
hence, y = y,xi 
= xi,... 
,Xr — Xr- Denote by Yo,Yi,... 
the stages corre-
sponding to the LFP operation in (*). Let Z be a new r-ary relation symbol. 
The fixed-point operation of the following formula ip stepwise incorporates 
the elements of a new stage Y^ into the different components of the tuples in 
Z. 
i;{yu. ..,yr) 
:= 
[LFPj,z {{Mzi) 
A ... A (^o(^r)) V 3x G Z3y G Z3y 
{ifi{y,x)A 
y 
{zi^y 
A /\zj 
=yj)))]y. 
If Zo, Zi,... are the stages of the LFP operation in ip, then one easily shows 
by induction on n: 
(1) 
for all n, 
Zn C Y^^ 
(2) 
for all n there is an m such that 
Y^ C Zm-
Hence, Y^ — ZQ©, and therefore, 
^fin [LFP^,y (cpo V 3a:i ^Y ...3xr 
eY^i)]t 
^ ip{t,...,t). 
D 
We come back to the trees Ar,m and Br,m introduced in the proof of 
8.6.22. A point of one of these structures got the colour "black", if it was 
(a leaf and) full or if at least (= exactly) one successor was white. Thus the 
colour of a point was determined by the colour of its r H- 1 successors. It is 
therefore not surprising that we can find a sentence in FO(BFPr+i) which 
separates the classes {A'r,m | m > 0} and {B'r,m | m > 0}. In fact, we have 
(recall that c denotes the root of the structures in question) 
F^'^ = {(c,i/) I colour(^) = black} U {{x,y) \ x ^ c, colour(t/) = white} 

8.7 Bounded Fixed-Point Logic 
237 
for the formula ipr{x,y,Y) :— 
{{x = cA Fy) V (^a: = c A \/z-^Eyz A ^Fy)) V Bxo^/o eY ... 3xryr G Y 
( 
A 
ViT^Vj ^ A EyyiA 
0<i<j<.r 
i<r 
{{x = c /\ \l -^Xi = c) V {-^x = c A l\ Xi — c))). 
i<r 
i<r 
Hence for all m > 0, 
A'r,m 
\= -'[^^Pxy,Yi^r] 
CC a n d 
B'r,m 
\= [LFPa;t/,F^r] CC. 
It can be shown that (2) in the proof of 8.6.22 can be strengthened to 
for any FO(TC)-sentence (p there is an mo such that for all m > mo, 
Al^ 
h V iff B'.^m N ^-
Therefore, the FO(BFP)-sentence [LFFxy,Y'fp2\cc is not equivalent to an 
FO(TC)-sentence. This gives the first inequality in the next proposition. To 
obtain the second inequality one shows that the FO(LFP)-sentence (po of 
(1) in the proof of 8.6.22 is not equivalent to an FO(BFP)-sentence; that is, 
there is no FO(BFP)-sentence separating the sets {^^^ | r > l,m > 0} and 
Theorem 8.7.2 FO(TC) < FO(BFP) < FO(LFP). 
D 
We shall see in Theorem 9.1.6 that FO(BFP) = FO(LFP) on ordered 
structures. In the BFP-rule the fixed-point operation is applied to formulas 
((/?o V 3x^1 e Y... 3xr ^ Y (fi) which do not contain free relation variables 
besides Y, and where Y only occurs positively. In fact, this is the only essential 
restriction, as is shown by the following result that we need in the next 
chapter. 
Proposition 8.7.3 Let Y be a second-order variable and let ip be a formula 
built up from FO{BFPr)-formulas 
and atomic formulas of the form Ys with 
-1, A, V, and 3. Furthermore, suppose that Y is not in the scope of any negation 
sign. If Y occurs at most r times in ip, then [LFP^^y^] t is equivalent to a 
formula o/FO(BFP^). 
Proof. To each such if) with exactly s occurrences of Y we associate a formula 
-0* of the form 3^i G F . . . 3xn G F ^ i , where V'l is an FO(BFPr)-formula 
that does not contain Y and is equivalent to ip whenever a nonempty relation 
is assigned to Y. Then, [LFPy,y'0(^, F)] Hs equivalent to 
[LFP^,y (^(^, 0) V 3x1 G F ... 3^n G F^i)] i, 
a formula of FO(BFPr). We define ^* by induction on ip: If il^ = Y's then 
ip* :=3x eYx 
= s. Set -0* := I/J for any formula not containing Y; in partic-
ular, for i/; = -!(/? we have ^* = -K/? since, by hypothesis, cp does not contain 

238 
8. Logics with Fixed-Point Operators 
Y. The definition of ip* for the other cases is straightforward; it uses that 
{ip V 3xi G y ... 3xn ^Yip) 
and 3^i G F ... 3^^ G Y {(pV ip) are equivalent 
in case no variable in ^ i , . . . , ^^ is free in cp and provided a nonempty relation 
is assigned to Y (and a similar equivalence for the conjunction). 
D 
Notes 8.7.4 Stratified logic was introduced and studied first by Chandra 
and Harel [19]. References for the results given are [23, 102, 61]. 

9. Logic Programs 
In the present chapter we introduce a group of languages that originate in 
database theory. Our aim is to exhibit a close relationship to fixed-point 
logics, thus demonstrating that the two groups of logical systems are two 
sides of one and the same coin. We therefore may use methods and results 
from one group when investigating the other. Examples will illustrate the 
methodological means we thus have gained. 
9.1 DATALOG 
Fix a vocabulary r. A general logic program is a finite set 11 of clauses of the 
form 
where / > 0 and where 7,71,..., 7/ are atomic or negated atomic first-order 
formulas. The formula 7 must be an atomic formula of the form Rt. It is 
called the head of the clause. The sequence 7 1 , . . . , 7/ constitutes the body of 
the clause. Every relation symbol occurring in the head of some clause of 11 
is intentional, all the other symbols in r are extensional. Denote by (r, n)int 
and (r, n)ext the set of intentional and extensional symbols, respectively. 
Hence, (r, n)ext —^\{^i 
n)int. We often write Tint and Text if no confusion is 
possible. 
A DATALOG program is a general logic program, in which no intentional 
symbol occurs negated in the body of any clause. Examples of DATALOG 
programs are 
Ho: 
Txy ^ 
Exy 
Txz ^ Txy, Eyz 
H i : 
P min ^ 
112 '• 
Qy ^ Px, Sxy 
Py ^ Qx, Sxy 
Px ^ ^x — c 
Px 4- ^Rx 
The intended meaning of a DATALOG program 11 is obtained by interpreting 
its clauses in a dynamic way as rules, the clause 7 -(- 71,..., 7^ as the rule 
(*) 
whenever 7 1 , . . . , 7/ then 7. 
The values of the extensional symbols are given by a Text-structure. All the 
rules of n will be applied simultaneously to generate consecutive stages of 

240 
9. Logic Programs 
the intentional symbols. For IIo for example, the final value of T in a graph 
Q = {G,E^) 
will be the transitive closure of E^. We come to the exact 
definition. To simplify the presentation of the semantics we suppose that for 
any intentional symbol P of H, say, of arity r, there are distinct variables 
xp = xp^i ... xp^r such that any clause in 11 with head symbol P has the 
form 
Pxp <-7i,...,7/ 
(otherwise, carry out suitable changes having in mind the intended interpre-
tation; for example, replace the clause Pmin 4- in Hi by Px -(^ x = min 
(where xp = x), and a clause Rxyx •<— Py,Sxmin 
by Rxyz ^ Py, 5a:min, 
X — z (where XR — xyz)). With every intentional P we associate the formula 
^pixp) 
:= 
\J{3y{ji 
A ... A 7/) I Pxp f- 71,... ,7/ in 11} 
where y contains the variables in 7 1 , . . . , 7/ that are distinct from the variables 
in Xp. Assume that P^,..., P^ are the intentional symbols of H. By definition 
of a DATALOG program they do not occur negated in the body of any 
clause. Therefore (fpi,..., 
^pk are positive in P^,..., P^ and hence, their 
simultaneous fixed-point (^(^00)'• • •'^(^00)) Siven by P^^^ := U P^^^ exists, 
n>0 
where 
For a Text-structure A we can rewrite the definition of P/^ in such a way 
that the procedural character of the DATALOG program 11 is emphasized: 
P(n+i) 
~ 
{^ I there are P^Xpi -^ 7 1 , . . . , 7/ in LE and h ^ A 
^"^^ 
such that {A, Pl^y..., 
P(^^)) 1= 71 A ... A 7/ [a,5]} 
(where a interprets the variables in Xpi and h the remaining ones). 
Thus, a DATALOG program n and a Text-structure A give rise to the 
r-structure 
A[n] 
:= 
(AP('co),---,-P(*c«))-
And every intentional symbol P of 11 defines a query on the class of Text-
structures given by A 1—v P-^M. 
For the DATALOG program Hi at the beginning of this section and 
any ordering B as {<,5,min, max}-structure, we have B\rLi] = 
(B,P^,Q^), 
where P ^ and Q^ consist of the elements at odd and even positions, respec-
tively. 
A DATALOG formula has the form (H, P)t where P is an intentional symbol 
of n, say of arity r, and t = ti.. .tr are terms. It is a formula of vocabulary 

9.1 DATALOG 
241 
Text, its free variables being those occurring in some ti. For a Text-structure 
A and a G A, 
A h (n, P)t [a] 
iff 
{h[a],..., 
tr[a]) G P^^^^. 
In order to get sentences and thus to be able to compare the expressive power 
of DATALOG programs with other logics, it is desirable to allow zero-ary 
relation symbols. If P G r is 0-ary then, in a structure A, P-^ is the boolean 
value TRUE or FALSE. Denoting the empty sequence by 0, for zero-ary P* 
the inductive step (+) above reads as follows: 
P{n+i) 
'•~ {^ I there are a clause P* ^ 71,..., 7/ in 11 and h e A 
such that {A, Pl^y..., 
P(^^)) h 71 A ... A 7/ [0,6]}. 
So, "P-^ = 0" means "P-^ = FALSE", "P-^ = {0}" means "P-^ = TRUE". 
To give an example, consider the program 
114 : 
Txy 
4- 
Exy 
Txz 
^ 
Txy,Tyz 
P 
^ 
Ted 
with a 0-ary relation symbol P. Then, for any graph Q := 
{G,E^,c^,d^) 
with distinguished points c*^ and d^, P^[n4] jg true just in case c*^ and d^ are 
connected by a path; in other words, Q \= (114, P) iff c^ and d^ are connected 
by a path. 
We now come to a generalization of DATALOG programs. Let 11 be a 
DATALOG program and A a (r, n)ext-structure. Then ^[11] is a r-structure. 
To ^[n] one can apply a further DATALOG program. In such a program 
all symbols in r are extensional and thus may occur negated in the bod-
ies of clauses. An iteration of this process leads to the notion of a strat-
ified DATALOG program. A stratified DATALOG program 
(by short: 
S-DATALOG program) S consists of a sequence IIQ, ... ,11^ of DATALOG 
programs of vocabularies TQ, ... ,Tn, where (r^+i, n^_|_i)ext = ^'m for m < n. 
Given a (To,no)ext-structure A^ we set 
^[E] := (...(^[no])[ni]...)[nj. 
As with DATALOG, (S, P)t is an S-DATALOG formula ff P is an intentional 
symbol of one of the constituents IIj. For example, E := Ho, Hi with 
IIo : 
Px ^ Exy 
IIi : 
Lx ^ 
-^Px. 
is an S-DATALOG program. In any tree, the S-DATALOG formula (E,L)a: 
defines the set of leaves. 
The following result explains why bounded fixed-point logic is sometimes 
called stratified fixed-point logic. 

242 
9. Logic Programs 
Theorem 9.1.1 S-DATALOG = FO(BFP). 
We give the proof in such a way that it yields a stronger result: The 
breadth of a DATALOG program is the number of occurrences of intentional 
symbols in the bodies. Thus the program 
Txy 
<r- Exy 
Txz 
^ 
Txy.Tyz 
P 
^ 
Ted 
has breadth 3. The breadth of an S-DATALOG program E c H i , . . . ,nfc is, 
by definition, given by max^<jfc breadth(n^). Denote by S-DATALOGr the 
class of S-DATALOG formulas (S, Q)t where E is of breadth < r. Then the 
preceding theorem can be strengthened to: 
Lemma 9.1.2 For all r>0, 
S-DATALOG^ = FO(BFP^). 
Proof. We show FO(BFP^) < S-DATALOG^ by assigning to every formula 
(/? of FO(BFP^) with free variables among y an equivalent S-DATALOGr 
formula (S(^,(5(p)y. We do this by induction on (f, tacitly assuming that the 
intentional symbols of the programs H^, H^,... we refer to are distinct. 
- If ip{y) is atomic, set Ti^ := {Qi^y -^ ^}. 
- If (p{y) = ^^, set E^ := E^, {Q^y <r- -^Q^y). 
- If ^{y) == (^ V x), set S^ := S^, E^, {Q^y i- Q^y, Q^y ^ Q^y}. 
- If ip{y) = 3xip(y,x), set S<^ := E^, {Q<py ^ 
Q^yx}. 
- For ip{y) = [LFF^^x{'(p{y,x) V 3xi G X ... 3^^ G Xx{y,x,xi,... 
,Xs))]t 
.,QyXs,Qxyxxi 
...X, 
For the direction S-DATALOG^ < FO(BFPr) we first study the case of a 
(plain) DATALOG formula (H, P)t where U is of breadth < r. Let F ^ ..., P^ 
with P = P^ be its intentional symbols. By previous remarks we may assume 
that the clauses have the form 
QxQ 
^'yi,...,'yi 
where XQ is a sequence of distinct variables. Let 
^Q(XQ) 
:= 
\/{^y{li 
A . . . A 7/) I QXQ 4- 71 . . . , 7Mn B } 
where y contains all the variables in the clause that are not in XQ . By defin-
ition of the semantics of DATALOG, the formula (11, P)t is equivalent to 
with s < r let 
E : 
and set S<^ := E^, 
Qyx 
Qyx 
> ^X5 n ? 
Q^yx 
Qyxi, 
{Q^y ^ Qy 

9.1 DATALOG 
243 
Since ifpi,..., 
cppk are existential and altogether, P^,..., P'^ occur at most 
r times, the corresponding formula XJ(2^, Z) in 8.2.3 is existential, too, and 
contains Z at most r times, and (11, P^)t is equivalent to 
(*) 
3u[LFPJ,zXJ]tu^ 
By 8.7.3 this formula is equivalent to a formula in FO(BFPr). 
Now in any S-DATALOGr program of breadth < r of the form E :== 
n. Ill we can deal with Hi as with 11, where for the intentional symbols 
of n occurring in IIi (as extensional symbols!) we use the defining for-
mulas in FO(BFPy.) just gotten. For an arbitrary S-DATALOG program 
S := Ho,..., n^ of breadth < r the result follows by induction on n. 
D 
Using 8.7.1 we get: 
Corollary 9.1.3 S-DATALOGQ = FO, 
S-DATALOGi = FO(TC), and 
S-DATALOG2 = S-DATALOG. 
D 
What is the logic corresponding to plain DATALOG? We get a hint from 
the observation that in the formula in (*) of the preceding proof the least 
fixed-point operator is applied to an existential formula. In fact, we have: 
Theorem 9.1.4 DATALOG anc? Existential Fixed-Point Logic E(LFP) have 
the same expressive power. 
Here the class of formulas of E(LFP) is given by 
• 
where (p is an atomic second-order formula 
where cp is an atomic first-order formula 
(p,^p 
cp^ip 
(p 
(99 A '0) 
(<P V ip) 
3x(p 
Proof (of 9.1.4). DATALOG < E(LFP): We saw in the proof of the preceding 
theorem that any DATALOG formula (11, P'^)t is equivalent to the formula 
in (*). But this formula is a formula of E(LFP). 
E(LFP) < DATALOG: Theproof parallels that of FO(BFP) < S-DATALOG, 
but now in every step of the induction the S-DATALOG program given there 
has to be joined to a single DATALOG program. Proceed as follows: 
^ This formula is only equivalent to the DATALOG program in models with at 
least two elements. To remove this restriction one can proceed as follows: On 
structures of cardinality 1, the k-th. stage is already the final one. But the k-th. 
stage of P^ can be expressed by an existential first-order formula tp (compare 
9.3.1). Then, for arbitrary structures, we have to replace the formula XJ in (*) 
by (V'Vxj). 

244 
9. Logic Programs 
- For (p{y) atomic set n;^ := {Qipy f- (/?}. 
- For (p{y) = -It/; with atomic ip set U^p := {Qi^y ^ •~'^}. 
- For ip{y) = (V; A x) set U^ := U^UU^U {Q^y ^ Q^y, Q^y}. 
- For ip{y) = (t/' V x) set U^ := U^UU^U {Q^y ^ Q^y, Q^y ^ 
Q^y}. 
- For ip{y) = Bxi/^iy^x) set II^^ := 11^ U {Q^y ^ 
Q^yx}. 
- Suppose (p{y) — [LFP^,xV^] t. Assume w.l.o.g. that the individual variables 
free in ip are among x. Consider X in t/^ as a relation symbol (and not as a 
relation variable) and let 11^ be the DATALOG program corresponding to 
i/j by induction hypothesis and having X as an extensional symbol; X does 
not occur negated in the body of a clause, since ip is positive in X. Then as 
n,^ we can take the following program (that contains X as an intentional 
symbol): U^ := 11^ U {Xx ^ Q^T, Q^py ^ Xt}. 
CH 
Since in graphs the E(LFP) formula 
[LFPa,^,x (Exy V 3z{Xxz A Ezy))] cd 
expresses that there is a path from c to d, we see that E(LFP) £ FO. On the 
other hand, we also have FO ^ E(LFP). An example of an FO-formula not 
equivalent to a formula of E(LFP) is given by \fxPx, since a simple proof by 
induction shows that E(LFP) has the following monotonicity property: 
Proposition 9.1.5 If(p{xi,... 
,Xn) is a formula o/E(LFP) andai,. - - ,an G 
A, then 
A \= ^[ai,..., 
Gn] and ACS 
imply 
B \= ^[ai,..., 
a^]. 
• 
Let r D {<,5,min, max}. In presence of 5, min,max we have for ordered 
structures: 
ACS 
implies 
A = B. 
Thus, on ordered structures, the monotonicity property of the preceding 
proposition holds for all logics. 
Theorem 9.1.6 Let r D {<,5,min, max}. On ordered structures, we have 
E(LFP) = FO(LFP), that is, the expressive power o/DATALOG, S-DATA-
LOG, E(LFP), FO(BFP), and FO(LFP) coincide. 
Proof. To show that FO(LFP) < E(LFP) recall (cf. 8.2.9) that every formula 
of FO(LFP) is equivalent to a formula of the form 
3x [LFFy^Yip] t 
where ip is first-order. Thus it suffices to show that on ordered structures 
universal quantification can be replaced by an LFP operation (according to 
E(LFP)). For this note that yx(p{x) is equivalent to 
[LFPa;,x (v^(niin) Ax = min) V 3y{Xy A Syx A (p{x))] max. 
D 

9.2 I-DATALOG and P-DATALOG 
245 
Exercise 9.1.7 A DATALOG formula (B.,P)t is positive if no negated 
atomic formula at all occurs in the body of any clause. Introduce positive 
existential fixed-point logic and show that it has the same expressive power 
as positive DATALOG. 
D 
Exercise 9.1.8 Let E := Ho,..., H^ and S' := n[),..., HJ be S-DATALOG 
programs with Ho U ... U11^ = 11^ U ... UIIJ. Show that A[£] = A[E'] for any 
structure A. Hint: Consider a finest subdivision of EQ U ... U 11^ leading to 
an S-DATALOG program and show that S and E' are equivalent to it. 
D 
Exercise 9.1.9 Show that on ordered structures the successor relation S is 
not definable in E(LFP) in terms of <,min,max. (Hint: Use 9.1.5.) Show 
that < is definable in E(LFP) using S. 
D 
Exercise 9.1.10 Extend the semantics of E(LFP) and DATALOG to infinite 
structures and show the equivalence of E(LFP) and DATALOG for arbitrary 
structures. Conclude 
— If (p(x) is a formula of E(LFP), A is an arbitrary structure, a ^ A, and 
A \= ^[a], then there is a finite AQ C A such that a e AQ, and for all B 
with ^0 ^ ^5 if ^0 generates the same substructure in 5 as in ^ then 
— If an E(LFP)-formula has a model then it has a finite model. 
D 
9.2 I-DATALOG and P-DATALOG 
Until now we have introduced some natural classes of general logic programs, 
and we have seen that they correspond to certain fixed-point logics. We now 
ask the other way round: What classes of programs correspond to, say, infla-
tionary (= least) fixed-point logic and to partial fixed-point logic? 
First we show that inflationary fixed-point logic FO(IFP) can be captured 
by general logic programs, if we equip them with an "inflationary" semantics. 
We speak of I-DATALOG, the "I" standing for the inflationary aspect of its 
semantics. 
Being a general logic program, an I-DATALOG program H may have 
clauses whose body also contains negated intentional symbols. The semantics 
is fixed in a way that consistently extends the conventions for DATALOG. 
Similarly as with DATALOG, we may suppose that for any intentional symbol 
P of n there are distinct variables xp such that any clause in H with head 
symbol P has the form 
Pxp ^ 7 l , . . . , 7 ^ 
We set 
^P 
'= 
\/{^y 
(71 A ... A 7z) I Pxp ^ 7 1 , . . . , 7/ in H} 

246 
9. Logic Programs 
where y contains the variables of the corresponding clause that are distinct 
from the variables in xp. Assume that P ^ , . . . , P^ are the intentional sym-
bols of n. Then the simultaneous inflationary operations corresponding to 
(fpi,..., 
(fpk give rise to the sequences 
4 ) := 0, 
Pin+l) ••= Pin) U {Xpi I >ppi{xp.,Pl^^, . . . ,P(*„))} 
with the simultaneous fixed-point given by P(^) '•= \J PL)-
n>0 
Let ^ be a Text-structure. Then E leads to the r-structure 
If P is an intentional symbol of H, (H, P)t is an I-DATALOG formula, its 
meaning in a Text-structure A being t G P-^M. 
Exercise 9.2.1 Let U = {Px <- Rx, 
Qx ^ 
-^Px} be an I-DATALOG 
program and E be the S-DATALOG program {Px ^ Rx}, {Qx ^ 
^Px}. 
Show for A = (A, R^) that Q^M = A and Q^^^^ = yl \ P^. In this sense the 
semantics of I-DATALOG and S-DATALOG programs are not compatible. 
D 
Theorem 9.2.2 I-DATALOG = FO(IFP). 
Proof. By the definitions just given, an I-DATALOG formula (II, P)i with 
intentional symbols (P =:)P^, P^,..., P^ is equivalent to 
[S-IFP^^^ ,pi,...,^pfc ,pfc V^pi,..., <^pk]t 
and hence, is definable in FO(IFP). Thus, I-DATALOG < FO(IFP). 
To show FO(IFP) < I-DATALOG, to every formula Lf of FO(IFP) with 
free first-order variables among y we assign an equivalent I-DATALOG-
formula {U.ip,Q^)y. Free relation variables in ip are treated as relation sym-
bols, hence, they are extensional symbols of li^p. 11;^ contains an intentional 
0-ary symbol DONE(^. DONE^ becomes true at the last step of the evalu-
ation of Hep (more precisely, when DONE<^ is true, all intentional symbols 
have reached their final value). We proceed by induction on ip: 
V(p) atomic: S e t n ^ : = { ^^J^!^^ 
^ 
'^ | 
V^(^) •= ~'^' Let H^ consist of the clauses of 11^ and 
Q^y 
^ 
DONE^, ^Q^y 
DONE^ 
^ 
DONE^ 
(p{y) := {ipV x) ' Let 11^ consist of the clauses of 11^ U 11^ and the clauses 

9.2 I-DATALOG and P-DATALOG 
247 
Q^y 
^ 
QxV 
DONE^ 
^ 
DONE^,DONE^ 
ip{y) \— 3x'ip{y,x) : Let U^ consist of the clauses of 11^ and the clauses 
QifiV ^ 
Qxj/yx 
DONE^ 
^ 
DONE^ 
(^(^) :zr [IFP^x'0]^- Assume w.l.o.g. that all first-order variables free in ip 
are among x = xi.. .Xk- By induction hypothesis there is a program 11^ 
corresponding to ij) (with X as an extensional symbol). Thus, for a given 
interpretation of X, the program 11^ returns as Q^ the set {x \ ip{x, X)}. For 
^{y) the program U^ must be repeated several times until the fixed-point of 
the inflationary operation is reached. But note that in order to get the stages 
of the IFF operation, after each iteration step the intentional symbols of 11^ 
have to get empty again before the next iteration step starts. However, such 
a set back is excluded by the "inflationary" semantics of I-DATALOG. To 
overcome this diflficulty we increase the arity of the intentional symbols, using 
the additional components for timestamps, the timestamps for the (n -t- l)-th 
iteration step being given by the new elements of X obtained in the n-th 
iteration step. 
The program U^p given below contains as intentional symbols the inten-
tional symbols of H^ and X, Q^, DONE^, the 0-ary symbols NOTEMPTY, 
DELAY, DONE, the A^-ary symbols OLD, I, and for every intentional symbol 
R of n^ a new symbol R* with arity(i?*) = arity(i?) + k. We use the follow-
ing notation: For new variables 'z = zi.. .Zk, the program U'^l'z] is obtained 
by replacing in every clause of E^ each (possibly negated) atomic formula 
of the form i?s with an intentional R by R^^'z. And if II is any program 
then n II 7i,..., 7m is obtained by appending 7i,...,7m to the bodies of all 
clauses in 11. 
The following remarks should help to read II;^: The clauses in (1) take care 
of the first iteration of ^, (2) - (4) stop the program in case the first iteration 
returns an empty result, and (5) updates the value of X. The subsequent 
iterations of ?/? are simulated by the clauses in (6) timestamped with the 
tuples added at the previous stage. By (7) the value of X is updated and the 
old value is stored in OLD by use of (8). (9) checks whether no new value 
has been added to X. In this case (10) and (12) stop the program. By (11) 
the goal symbol Q^^ gets its right value. 
(1) 
n^lhDONE^ 
(2) 
NOTEMPTY ^ DONE^, Q^x 
(3) 
DELAY ^ DONE^ 
(4) 
DONE<^ ^ DELAY, --NOTEMPTY 
(5) 
Xx ^ DELAY, Q^x 

248 
9. Logic Programs 
(6) 
W^[z]\\Xz,^OLDz 
(7) Xx^BONEp^Q^xz, 
(8) OLD^ ^ DONE^J 
(9) 
Iz i- D O N E ; J , Q*^XZ, 
^XX 
(10) DONE 4- OLD^, ^Iz 
(11) g^^^DONE,X^ 
(12) DONE<^ ^ DONE 
D 
Remark 9.2.3 Recall the definition of FO(IFP, #), fixed-point logic with 
counting, given in subsection 8.4.1. DATALOG(#), Datalog with Counting, 
extends DATALOG by allowing two sorts (the point sort and the number 
sort) and admitting two-sorted intentional relation symbols and certain terms 
of the number sort in its clauses. More precisely: Call a term t of the number 
sort basic if it is either a variable // or min,max or of the form ^xRVP 
for 
an intentional R. Now, a DATALOG(#) program is a finite set of clauses 
7 ^ 7 i , . . . , 7 z 
where 7 is atomic and relational and 7 1 , . . . , 7/ are atomic or negated atomic 
formulas, all of whose terms of the second sort are basic; moreover, intentional 
symbols do not occur in negated atomic formulas. This last condition is not 
a real restriction, since we already remarked in part (e) of 8.4.17 that ^RyJI 
is equivalent to ^xRVP 
— min. So negated intentional relation symbols are 
available via unnegated atomic formulas containing counting terms. We equip 
DATALOG(#) with the inflationary semantics. Now it is not difficult to 
adapt the proof of the preceding theorem in order to show 
DATALOG(#) = FO(IFP, #). 
D 
We turn to partial fixed-point logic and introduce P-DATALOG that will 
correspond to FO(PFP). The syntax of P-DATALOG is the same as that of 
I-DATALOG, that is, every general logic program is a P-DATALOG program. 
The semantics is given by the following conventions: Let 11 be a P-DATALOG 
program. As in the preceding cases we assume that every clause with the 
intentional symbol P in its head has the form 
P^P ^ 7 i , . . . , 7 / . 
Again, set 
ifp{xp) 
:= \/{3y (71 A ... A 7/) I Pxp 4- 71,... ,7/ in H}. 
Assume that P-^,..., P^ are the intentional symbols of E. Set 
P/o) ~ 0 . 
Pln+1) 
••= {^P' I <PP>(Xp>,Pln), 
• • 
-^Pin))} 

9.2 I-DATALOG and P-DATALOG 
249 
and let (P^^), 
• • •, Pf^oo)) ^^ ^^^ simultaneous fixed-point. Thus, in case there 
is an no such that P / 
,^>, = P}^ ^ for i = 1,...,/?, we have PIQQ\ = 
^(no)'-"'^foo) = ^(no)5 Otherwise, P^^^ = 0 for z = 1 , . . . , fc. Let ^ be a 
Text-structure. Then 11 leads to the r-structure 
^[n] := M,P(i^),...,P*^)). 
For any intentional symbol Q of 11 and terms t, (n.,Q)t 
is a P-DATALOG 
formula, its meaning in a Text-structure A being t G Q-^t^^. ^ 
T h e o r e m 9.2.4 P-DATALOG = FO(PFP). 
Proof. By the definitions just given, a P-DATALOG formula (E, Q)t, where 
n has the intentional symbols {Q —)P^,P'^,..., 
P^, is equivalent to 
[S-PFP^^^^pi,...,^^^,pfc (/?pi,..., (^pfc] ^ 
and hence, to a formula of FO(PFP). 
For the direction FO(PFP) < P-DATALOG we proceed as in the case of 
FO(IFP) < I-DATALOG, assigning to every formula ^ of FO(PFP) with free 
first-order 
variables among y an equivalent P-DATALOG formula 
{Jl^^Q^p)y, 
where 11^ contains a 0-ary symbol DONE^^ taking the value TRUE in the last 
stage of the evaluation. Again, free second-order variables of if are treated as 
extensional symbols in IT^^. The atomic case and the cases (^ — ^ip, (p = (^Vx) 
and (p = 3XIIJ are handled as in 9.2.2. For ip(y) := [FFPx.x'ip] t, where w.o.l.g. 
the first-order variables free in ip are among x, the program Il,p given below is 
simpler than the corresponding one for I-DATALOG, since in the semantics 
of P-DATALOG an intentional symbol Z gets 0 in an evaluation step in case 
no positive Z-information is obtained. II,^ contains as intentional symbols the 
intentional symbols of 11^, X, DONEj^, Q^, and the 0-ary symbols UPDATE, 
NOTFIXPOINT. 
The clauses in (1) take care of an application of 11^. Clauses (3) and (4) 
check whether a fixed-point has been reached. In the positive case, clauses 
(7)-(10) stop the program. Clauses (5) and (6) serve to update the values of 
the intentional symbols for the next application of 11^. 
(1) 
(2) 
(3) 
(4) 
(5) 
(6) 
Xlc'l^Xlc 
II -DONE,, .UPDATE 
UPDATE 
^DONE, 
NOTFIXPOINT ^ DONE,, Q^x, ^Xx 
NOTFIXPOINT ^ DONE,, Xx, -^Q^x 
Q^x ^r- D0NE,,(3,a 
Xx ^ UPDATE, NOTFIXPOINT, Q,s 
One easily verifies that the semantics extends the conventions for DATALOG. 

250 
9. Logic Programs 
(7) 
DONE<^ ^ UPDATE, -NOTFIXPOINT 
(8) 
Q^y ^ UPDATE, -NOTFIXPOINT, Q^t 
(9) 
UPDATE ^ UPDATE, ^NOTFIXPOINT 
(10) Q^x ^ UPDATE, -NOTFIXPOINT, Q^x 
U 
9.3 A Preservation Theorem 
A DATALOG program is positive if no negated atomic formula at all occurs 
in the body of any clause. Recall that, given a DATALOG program H, an 
intentional symbol P, and n > 0, we denote by Pt^n) the n-th stage of P in 
the evaluation of H. 
Proposition 9.3.1 Let Jl he a DATALOG program. Then, for any inten-
tional symbol P and n > 0, the relation P(^) is expressible by an existential 
first-order formula (/?p. If H is positive then cp^ can be chosen existential 
positive (cf. 2.5.3). 
Proof. The proof proceeds by induction on n. If n = 0 then (p^p := F. For 
n > 0, let 
(pp{xp) = \/{3y(7i A ... A 7/) I Pxp ^ 71,... ,7/ in H}, 
where y contains the variables in 71,... ,7/ that are not in xp. To obtain 
(p'p{xp), replace in ^p{xp) any subformula Qi with intentional Q by (/?Q~^ (t). 
D 
A DATALOG formula (H, Q)i is bounded if there is an n > 0 such that 
Q{n) — Q{oo) holds in all structures. Thus a bounded (positive) DATALOG 
formula is equivalent to an existential (positive) first-order formula. On the 
other hand, an existential (positive) first-order formula is equivalent to a 
bounded (positive) DATALOG formula. In fact, let ip{x) be existential (pos-
itive), w.l.o.g. of the form 
jl A . . . A ^iki)', 
i=l,...,s 
where the (pij are atomic or negated atomic (atomic) formulas. Then (/?(^) is 
equivalent to the DATALOG formula (11, Q)x, where 11 has the clauses 
Qx 
^ 
ipii,...,ifiki 
for z = 1,..., s and where Q is a symbol not in (p. As (3(i) = Q(oo), (H, Q)x 
is bounded. 
Thus, by the proposition, the bounded positive DATALOG formulas cor-
respond to the existential positive first-order formulas. The following preser-
vation theorem shows that they are the only positive DATALOG formulas 
equivalent to first-order formulas, thus documenting once more that first-
order logic lacks the ability to express recursion. 

9.3 A Preservation Theorem 
251 
Theorem 9.3.2 For a positive DATALOG formula (11, Q)t the following are 
equivalent: 
(i) {I[,Q)t is equivalent to a first-order formula. 
(ii) {ll,Q)t is bounded. 
At the end of this section we sketch a proof of this result. First we draw 
some consequences. 
Corollary 9.3.3 Suppose that the positive DATALOG formulas 
{Ili,Qi)s 
and (n.2,Q2)t are equivalent. If {Tli,Qi)s 
is bounded, then (n.2,Q2)t is 
bounded, too. 
D 
Proposition 9.3.4 For a positive DATALOG formula (II, Q)x the following 
are equivalent: 
(i) 
{I[,Q)x is bounded. 
(ii) (n, Q)x is equivalent to an existential positive first-order formula. 
(iii) (n, Q)x is equivalent to a first-order formula. 
(iv) There is an n >1 such that for all A and a E Q-^^^^ there is a substruc-
ture B of A with \\B\\ <n andae 
Q^M. 
Proof. The equivalence of (i) and (ii) has already been shown, and that of 
(i) and (iii) is given by the theorem. Next we show that (ii) implies (iv): 
Assume (ii) and let (Il,Q)x be equivalent to the existential formula ^{x), 
say ip{x) = 3yip{x,y) with quantifier-free ip. Given A and a G Q*^f^^, that 
is, A \= (^[a], choose b such that A \= ^[a,6]. Then, for the substructure B 
generated by {a, 6}, we have B |= (p[a] and hence, a € Q^^^L Thus, as n 
we can take the sum of length(^), length(y), and of the number of constant 
symbols. 
Finally we show that (iv) implies (i). Clearly, given any n and any 
DATALOG formula (II, Q)^, there is an s such that Q(s) = Q{oo) in all 
structures of cardinality < n. Suppose that the positive DATALOG formula 
(n, Q)x satisfies (iv). Choose n according to (iv) and choose s corresponding 
to (n, Q)x and n. We show that (II, Q)x is bounded by s. If A and a € Q"^^^^ 
are given, (iv) yields a substructure B of ^ with \\B\\ < n such that a G Q^^^^; 
therefore, a G Q/A 
and hence, a G Q/A . 
D 
We give a further application of 9.3.2. A universal Horn sentence is a 
conjunction of sentences of the form 
(1) yxip 
(2) V^((^oA...AV'm)^V') 
(3) Vx(-nV^oV...V-^^), 
where the '0's and the -^i's are atomic. A class K of r-structures is projective 
Horn if there is a relational vocabulary a disjoint from r and a universal 
Horn sentence ip of vocabulary r U cr such that the following holds: 

252 
9. Logic Programs 
— in all subformulas of (/? of type (1) or (2) the formula ij) is relational, its 
relation symbol being from a 
- K is the class of r-reducts of models of ^ (that is, K is the class of models 
of the second-order sentence 3P^ ... 3P^ip where a = {P^,..., P^}). 
Since the first-order formulas involved are universal, a projective Horn class 
is closed under substructures. We have the following "compactness type" 
converse: 
Theorem 9.3.5 Let K be a projective Horn class. If K is axiomatizable in 
first-order logic then there is ann > 1 such that an arbitrary structure belongs 
to K if all substructures of cardinality at most n belong to K. 
Proof. Suppose a^ r, and ^p are as above and K is the class of r-reducts of the 
models of Lp. Choose a new 0-ary relation symbol Q and let IT be the positive 
existential DATALOG program obtained from (p by replacing each conjunct 
of the form (1) by the clause 
(1*) 
i^ ^ 
each conjunct of the form (2) by the clause 
(2*) 
V^^O,...,'0m 
and each conjunct of the form (3) by the clause 
(3*) 
Q ^ V^o,...,V'm 
together with 
Rx ;<— Rx 
for R e a. Hence, a U {Q} is the set of intentional symbols of H. We show 
that the class of models of (H, Q) is the complement K^ of K, that is, for 
every r-structure A, 
(+) 
AeK' 
iff 
A^{U,Q). 
Then, K^ is axiomatizable by the positive DATALOG formula (H, Q) and, 
as K, is first-order axiomatizable. Hence, K^ satisfies (iv) in 9.3.4, that is, 
there is an n > 1 such that all r-structures A G K^ contain a substructure 
of cardinality < n belonging to K^. Rephrasing this for K we get our claim. 
To prove (-h), assume first that A e K^. Then, in particular, 8 := 
{A, (P"^[^])pGcr) ^ ^' By its definition, B satisfies the subformulas of type (1) 
and (2) in (p. Hence, there is a subformula of type (3), say \fx{^ipo\/.. .V-i^rn), 
such that B \= ->V^(-i?/'o V ... V ^ipm)- Choose a e A such that B \= 
(^0 A •.. A i^mM- By (3*), A \= (H, Q). 
Conversely, suppose A e K, say {A, (P^jp^o-) \= (p. A simple induction 
on n shows that P(^) C P ^ for Pea; 
hence, P-^M Q pA ^^^^ if ^^ ^^d 
A \= (n,(3), then for some clause of the form (3*) and some a G A, we 
would have {A, {P^^^^)pea) h ^o A ... A i/jmM and hence, (A, {P^)pea) N 
•00 A ... A '0m[a] contrary to {A, {P^)pea) 
\= ^- 
• 

9.4 Normal Forms for Fixed-Point Logics 
253 
Theorem 9.3.5 can be used to prove nonaxiomatizability results. For ex-
ample, the class K of acyclic digraphs is projective Horn as can be seen via 
the axiom 
3P{\fxWy{Exy -> Pxy) A Wx\/y{{Pxy A Pyz) -^ Pxz) A Mx^Pxx) 
(take as P the transitive closure of E). Since K does not satisfy the conclu-
sion in Theorem 9.3.5, acyclicity is not expressible in first-order logic. 
We close by sketching the main idea of a proof of Theorem 9.3.2 using con-
cepts and results from section 2.5 and refer to [7] for the full proof. Let (H, Q) 
be a positive DATALOG formula where, for simplicity, we assume that Q is 
0-ary. Suppose that (H, Q) is equivalent to the first-order sentence ip. We 
have to show that (H, Q) is bounded. Otherwise, (H, Q) and, hence, if have 
arbitrarily large minimal models. On the other hand, by positivity, (E, Q) 
and, hence, ^p are preserved under strict homomorphisms. By 2.5.5, for some 
/ and m, no minimal model of ^ has an /-scattered subset of cardinality > m. 
Finally, one obtains a contradiction by showing that in large minimal models 
there are such subsets. 
9.4 Normal Forms for Fixed-Point Logics 
The equivalence of I-DATALOG with FO(IFP) and of P-DATALOG with 
FO(PFP) (together with 8.2.3, the Lemma on Simultaneous Induction) pro-
vides an alternative way to derive normal forms for FO(IFP) and FO(PFP). 
We shall exemplify this first and then further improve these results, thus 
obtaining normal forms that, in particular, yield some kind of measure to 
compare FO(IFP) and FO(PFP) with transitive closure logic and bounded 
fixed-point logic. Moreover, they will enable us in Chapter 12 to get repre-
sentations of FO(IFP) and FO(PFP) as logics with generalized quantifiers. 
Once more, for simplicity, we consider only structures with at least two ele-
ments. In particular, we say that if and ij) are equivalent if they are equivalent 
in all finite structures with at least two elements.^ And we say that ^ and 
3(V)a:^ are equivalent if ^ is equivalent (in this sense) to both 3a:^ and Mxil). 
Theorem 9.4.1 Let (^ he an F0{1FF)-formula. 
Then there is an existential 
first-order formula ip such that (p is equivalent to 
Proof. Let ip = ip{v) with free first-order variables among v. Choose an I-
DATALOG formula (H, Q)v equivalent to ip and let P \ ..., P^ with Q = P^ 
be the intentional symbols of 11. 
^ In most cases the restriction to structures with at least two elements can be 
removed as in similar situations before, or the corresponding statements are 
trivially false. 

254 
9. Logic Programs 
We may assume that the clauses of 11 have the form 
Pxp 
^ 7 i , . . . , 7 f 
where xp is a sequence of distinct variables. Let 
ipp{xp) 
:= \/{3y{'yi 
A ... A 7/) | Pxp ^ 7 1 , . . . ,7/ inH} 
where y contains all the variables of the corresponding clause not in xp. Then 
{n.,Q)v 
is equivalent to 
[S-IFP^^^ ,pi,...,^pfc,pk (ppi,..., 
^pk]v. 
Since (ppi,..., 
^pk are existential, the corresponding XJ in 8.2.3 is existential, 
too, and 
Hfin [S-IFP^^^,pi,...,^^^,pfc ippi,.. 
.,ippk]v^ 
3(V)i/[IFP^,z Xj] vu. 
By 8.2.4, the formula on the right side is equivalent to a formula of the form 
3(V)tx[IFP^,z tp] u with existential ijj. 
D 
The corresponding result for FO(PFP) can be obtained along the same 
Unes, using FO(PFP) = P-DATALOG. Moreover, we already proved it in 
8.3.14 by different methods. 
For FO(LFP) the kernel of the fixed-point operator in a normal form 
cannot be chosen existential (cf. the example before 9.1.5); however, we have 
T h e o r e m 9.4.2 Suppose 
that cp is an FO(LFP)-formula. 
Then there is a 
A2-formula 
ip, that is, a first-order formula ip equivalent to both a Ti2-formula 
and a 11.2-formula, such that Lp is equivalent 
to 
3(V)i/[LFP^,z^]ti. 
Proof. By the previous theorem there is an existential formula x such that 
^fin(^ ^ 
3(V)w[IFP^,zx]^-
By 8.2.11, for every existential x there is a A2-formula xjj such that 
^=fi„ 3(V)«[IFPy.^x]fi ^ 
3(V)«[LFP5,yV]«. 
Thus, (/? is equivalent to 3(V)t/[LFPy,y ^] w. 
D 
Our next goal is to further simplify the normal forms we have obtained so 
far with respect to the structure of the kernel, in particular with respect to the 
form in which quantifiers appear in it. We first treat the case of FO(PFP) and 
FO(IFP). To state the result we need the notion of a nontrivial formula. An r-
ary relation i? on a set A is nontrivial \i% ^ R^ 
A^. Furthermore, a formula 
of FO(PFP) is said to be nontrivial 
if for any subformula ip = [PFP^,x x ] ^ 
the stages F^^, F ^ , . . . are nontrivial (for any assignment). The definitions for 
FO(IFP) and FO(LFP) are similar. 

9.4 Normal Forms for Fixed-Point Logics 
255 
Theorem 9.4.3 Let cp be an FO{PFP)-formula. 
Then cp is equivalent to a 
nontrivial, totally defined formula of the form 
3(V)t/[PFP^,z Wo V 3^ € Z3y i Z^^,)] u 
where tpo and ipi are quantifier-free and do not contain Z. The same result 
is true if PFP is replaced by IFP everywhere. 
We have seen in 8.7.1(c) that TC operations correspond to LFP operations 
in which every element of a new stage is already witnessed by a single element 
of the preceding stage. Similarly, the fixed-point operations of bounded fixed-
point logic FO(BFP) correspond to LFP operations where every element of a 
new stage is witnessed by two elements (cf. 8.7.1(d)). The preceding theorem 
tells us that IFP operations and PFP operations can be rewritten in such a 
way that an element of a new stage is witnessed by two elements, but now one 
belonging to the preceding stage, the other one belonging to its complement. 
The proof of 9.4.3 is given in three steps; each step essentially corresponds 
to one of the next lemmas. We state the lemmas and the proofs for FO(PFP). 
They remain literally true for FO(IFP) with a single exception which we point 
out at the corresponding place. 
Lemma 9.4.4 Let cp be an existential (or quantifier-free) first-order formula 
containing a second-order variable X. Then, provided X is interpreted by a 
nontrivial relation, ip is equivalent to a formula of the form 
3xieX...3xke 
X3y^ ^ X .. .3yi ^ X^ 
where ip is existential (or quantifier-free) and does not contain X. If ip is 
positive in X then I can be chosen to be 0. 
Lemma 9.4.5 Suppose that 
ip = 3(V)^[PFP^,x ((po V 3x1 G X ... 3xk G X3y^ ^X...3yii 
X^i)] u 
is a nontrivial, totally defined formula, where ipo is quantifier-free, (pi is ex-
istential, and X does not occur in (po and ^\. 
Then Lp is equivalent to a 
nontrivial, totally defined formula of the form 
3(V)i/[PFP^,y(V^o V 317 G Y3w ^ Y^i)]u 
where ipo is quantifier-free, ipi is existential, and Y does not occur in V^o, ^i • 
Lemma 9.4.6 If (p is as in the conclusion of the preceding lemma then (p is 
equivalent to a formula of the same form with the additional property that %pi 
is quantifier-free. 
Postponing the proof of these lemmas, we give the 

256 
9. Logic Programs 
Proof (of 9.4.3). Let (p be an FO(PFP)-formula. By 8.3.14 we can assume 
that 
that (f is totally defined, and that % is existential. Suppose U is 5-ary. First, 
we pass to a nontrivial formula. For this purpose we introduce an (s + 2)-
ary relation symbol Y where we use the additional components to ensure 
nontriviality by setting 
p(u,Us+l,Us+2) 
'= 
po{u,Us+l,Us+2) 
V 
Pl{u,Us+l,Us+2,Y) 
with 
Po{u,Us+l,Us+2) 
: = 
Us = Us-^l A^Us+1 
= Us+2 
pl{u,Us+l,Us+2,Y) 
: = 
Us+1 ^Us+2 
A 
3vVs+lVs+2YvVs+lVs+2 
Ax{Y-Us+lUs+2)' 
The stages Ff, F^,... are nontrivial, since they contain all tuples of the form 
... uuv with u ^ V and no tuple of the form ... uvu with u ^ v. Moreover, 
F[ — {(wi,..., Ws+2) I Us = Us+i and Ug+i 7^ Ws+2}- An evaluation of the 
stages shows 
F^ = F^^, _uu for n > 0, and F^ - F^ 
.uu. 
By 9.4.4, provided a nontrivial relation is assigned to F, p\ is equivalent to 
a formula -^i of the form 
t/^i 
:= 
3xr^Y 
...3xu^Y3y^iY 
...3y,iY^ 
where ^ is existential and does not contain Y. Using dummy variables if 
necessary, we may assume that A: > 1. Then, if Y is interpreted by the empty 
relation, both pi and V'l are false. Hence, we have F^o^^^ = F^o^^i for all 
n. Thus, Lp is equivalent to the nontrivial, totally defined formula 
3(V)i/[PFP^,y (/90&) V 3^1 G r ... 3xfe G Y3y^ ^Y .. .3y^ f F^] u. 
As claimed, po is quantifier-free, i^) is existential, and Y does not occur in 
po and V'- The theorem now follows by first applying Lemma 9.4.5 and then 
Lemma 9.4.6. 
D 
Proof (of 9.4-4)' Let (/p be an existential (or, quantifier-free) formula contain-
ing the variable X. We may assume that all negation symbols in (p are in front 
of atomic formulas. For such (/? we inductively define if* of the form claimed. 
Ifip = Xt set if* := 3x e X t = X. If (p = ^Xt set (/?* :=3y ^ Xt = y. Let (p* 
be (p for any other atomic or negated atomic formula (p. The definition for the 
remaining cases is straightforward, using the induction hypothesis and equiv-
alences such as that of ((/?i V 3xi G X . . . 3^^ G X3yi ^ X... 
3y^ ^ X^2) 
and 3xi G X ... 3'Xk G X3yi ^ X ... 3yi ^ X[ipi V (P2), provided a nontrivial 
relation is assigned to X and the variables in ^ 1 , . . . , ^^ do not occur in (pi. 
D 

9.4 Normal Forms for Fixed-Point Logics 
257 
Proof (of 9.4-5). Suppose X is r-ary. The lemma claims that the number of 
quantifiers 3x ^ X,3y ^ X in the kernel of the fixed-point operator can be 
reduced to a single positive and a single negative one. We achieve this by 
increasing the arity of the second-order variable to {k -\- l)-r, whose first k 
r-blocks will consist of r-tuples in X and the last / r-blocks of r-tuples in 
the complement X^ of X. The corresponding r-tuples are incorporated in 
(k -\-l) steps into the distinct components, thus making necessary additional 
components for a counter: One iteration step of X will correspond to {k -\-l) 
steps for the new variable. 
To simplify the presentation, assume that k = I = 2 and that X is unary, 
hence 
if = 3(V)it[PFP^,x (V^o V 3x1 G X3x2 G X3yi ^ X3y2 i Xipi)]u 
where (pi{x,xi,X2,yi,y2) 
is existential and (po{x) and ^pi do not contain X. 
Let Xn be the n-th stage of the operation corresponding to the PFP operator 
in (/?. Choose a (4 + 4)-ary new variable Y, where the first 4 components are 
used as a counter for the 4 steps corresponding to one step of X, the next 
two ones for elements of X, and the last two ones for elements of X^. For the 
counters we introduce formulas 6^(2:1,..., 2:4) for i = 1,..., 4 by 
ei{zi,... 
,2:4) 
€ 2 ( 2 ^ 1 , . . . ,2^4) 
€ 3 ( 2 : 1 , . . . ,2^4) 
€ 4 ( 2 ^ 1 , . . . ,2:4) 
= 
2^1 = 2:2 = 2^3 = 2:4 
= 
^zi = Z2 A Zi = Zs = Z4 
= 
-12:1 = 2^3 A 2^1 = 2:2 = 2:4 
= 
-12:1 = 2:4 A 2^1 =2^2 = 2:3, 
If Yn denotes the n-th stage of the operation corresponding to the PFP 
operator in the formula ip below, set 
Yni- 
:— {x \ there are 1 such that ei{'z) and YnZx} 
{x = Xi ... X4 will correspond to XiX2yiy2 in cpi above). For all m > 0 and 
any structure A we will have (1) and (2). 
4m+l 1_ 
= 
Xm+1 X Ax A X A 
/-|\ 
^m+22- 
= 
Xm+1 X Ax X^_^i X A 
^4m+33- 
= 
Xm+1 X X^+i X X^_^i X A 
^4m+44- 
= 
Xm+1 X Xm+1 X X^_^-^ X X^j^^. 
Here the IFP case differs from the PFP case; the values for IFP are: 
^4m+ll- 
= 
Uz<m+1 XiX Ax Ax 
A 
Y4m+22- = 
[Ji^^^^XixAxXfxA 
nm+33- 
= 
Uz<m+1 XiXXiX 
Xf X A 
Y,m+A^- 
= 
U < ^ + l ^ / X X z X X f x X f . 
(1') 

258 
9. Logic Programs 
(2) 
Y4m+i+ji- = Y^m+ii- 
for 1 < 2 < 4 and 1 < j < 3. 
This is achieved if we use the formula ^ := 
4 
3(V)i/[PFP^^,y {ei{w) A ifoi^i)) V 3ux G Y3vy ^ Y \/{ei{w) 
A^i)\u 
where the ipi together with their meaning (formulated in a way suitable for 
an inductive proof of (1) and (2)) are given as follows: 
"^1 G Xm+i is witnessed by x G ^4^4- via ipi{zi^xi^X2,x^^XAy^ 
ip2 '•= ei(w) A €i(t;) Ax2 =y2 ^X3=y3Ax4=y4^Zi 
=xi 
Azs=yi 
"^3 G X^_^i is witnessed by ^ G ^4^4-11- and ^33^23^3^4 ^ ^4m+il-" 
V^3 := e2{u) A €2(^7) Axi =yiAx2=y2Ax4=y4^Zi=Xi 
Az2 = ys 
AZ3 = Xs 
"2:2 G Xm+i is witnessed by X G l^i7j,-|_22_ a n d iCiX22^2^4 ^ ^ m + 2 2 —" 
V^4 : = €3(1*) A €3(U) A 2^2 = ?/2 A 2:3 = 2/3 A X4 = 2/4 A2:i = a:i A 2:2 = ^2 
Azs = X3 Az4 = yi 
"2:4 G X^_^i is witnessed by x G F4m+3 3 - and ^4^:22^32^4 ^ 5^4m+33-". 
Since Xoo exists, Yoo exists, too, and Fool- = XooX^xAxA. As ei(w,ii, w,ii), 
but not ei{u,u,u,u) 
for z = 2,3,4, we thus see that cp and ip are equivalent. 
D 
Proof (of 9.4-6). When proving this lemma, we again use additional compo-
nents to simulate the unbounded existential quantifiers. Let 
(p = 3(V)w[PFP^,x {^0 V 3F G X3w ^ Xfi)] u 
with quantifier-free ipo and existential (/?i, both not containing X. Assume 
that X is r-ary and 
ipi =3?/i 
...3yix{x,v,w,y) 
with quantifier-free x- Let Z be (r-|-/)-ary. Given a structure A, let XQ, X i , . . . 
denote the stages of the PFP operator in (p and ZQ, Zi,... the stages of the 
PFP operator in 
^ = 3{\/)u[FFF^y^z (^0 V 3vyi G Z3wy2 ^ 
Zx{x,v,w,y^))\u. 
Then a simple induction shows that Zn = Xn x AK Thus (/? and ij) are 
equivalent. 
D 
Turning to FO(LFP), the improved normal form reads as follows: 

9.4 Normal Forms for Fixed-Point Logics 
259 
Theorem 9.4.7 Let ip he an FO{LFP)-formula. 
Then ip is equivalent to a 
nontrivial formula of the form 
(1) 
3(V)w[LFP^,z (^0 VVx3y e 
Zi;i)]u 
with quantifier-free I/JQ and ipi not containing Z, and cp is also equivalent to 
a formula of the form 
(2) 
30^)u[LFF^,z^^yiZil^i]u 
with quantifier-free ipi not containing Z {note that My ^ Zipi abbreviates 
My{Zy\/ ipi) and hence, is positive in Z). 
Moreover, in (1) we can choose ipi of the form ipn -^ 1/^12, where no 
variable ofy is free in ipn and no variable of'z is free in ipi2. 
Proof. We sketch a proof along the lines of the proof for the corresponding 
result 9.4.3 for FO(PFP). To obtain (1), we start from the fact (cf. 9.4.2) 
that (p is equivalent to a formula of the form 
3[\J)u[FFFu,u'Mv3wx]u 
where x is quantifier-free (and positive in U). Let s be the arity of U. Using 
an (sH-2)-ary y, we ensure nontriviality as in 9.4.3 by passing to 
p{u, Us+l,Us+2) 
'•= 
Po{u, Us+l,Us+2) V pi{u, 
Us+l,Us+2,Y) 
with 
Po{u,Us+l,Us+2) 
: = 
Us = Us+l A ->Ws+i = Us+2 
Pl{u,Us+l,Us+2,Y) 
: = 
Us+l =Us+2 
A 3 w ' < + i W ' g + 2 ^ ^ ' ^ s + l < + 2 
AMv3wx{Y-Us+iUs+2)-
The formula pi is equivalent to 
yv3w{us+i = Us+2 A 3u'u'^^-^u'^^2Yu'u'^+-^u'^_^2 ^ x{Y-Us+iUs+2))-
As x{Y-Us+iUs+2) is positive in F, by 9.4.4 it is equivalent to 
3y^ eY...3yf^ 
eYxi 
with quantifier-free xi not containing Y, provided Y is interpreted by a non-
trivial relation. Using dummy variables if necessary, we can assume that 
A: > 1. Altogether, ip is equivalent to 
ipi := 3{\/)u[LFFy,Y{po VVv3w3y^ eY...3y,^e 
Yx2)]u 
where po{y) and X2{y,v,w,yi,... 
,yf.) are quantifier-free and do not contain 
Y. Let Z be A:-r-ary where r is the arity of Y. Then for n > 0, if Yn denotes 
the n-th stage of the LFP operation in ipi, 

260 
9. Logic Programs 
ZJ'XI 
: = 
I fi 
X 
. . . 
X 
1-^ 
k times 
are the stages of the LFP operations in 
3(V)w[LFP^,...^„z {{Poizi) A ... A po(^fe))V 
\fiNv3w3y^...yf. 
G ^(VLi ^ = ^^ "^ (po{u) y Xi(u,v,w,y^,... 
,y},))))]u. 
Now, as we have already done in previous proofs, we can ehminate the ex-
istential quantifiers 3w by replacing Z, thereby using a relation variable of 
higher arity. We thus obtain a formula equivalent to ip of the form claimed 
in (1). 
To obtain (2), we may assume (again by 9.4.2) that ip has the form 
ip = 3(V)w[LFP^,y 3iNwtl;] u 
with quantifier-free i^). Suppose that Y is r-ary. A simple induction, using the 
equivalence of Yy and M'z ^ Y^'z — y^ shows that tl) is equivalent to a formula 
V^i ^ Y ...\/^k i 
Yp{y,v,w,zi,...,Zk) 
with quantifier-free p not containing Y, provided Y is interpreted by a relation 
diflferent from the set of all r-tuples. 
So we may assume that p is equivalent to the formula 
p)i := 3(V)it[LFP^,y 3viw\/zi 
^Y ...\/zk 
^ YpiV, v,W,zi,... 
,Zk)]u 
(note that the proviso "Y different from the set of all r-tuples" is irrelevant 
here, as the fixed-point operations in ip and p)i become stationary in case 
they arrive at the set of all r-tuples). Now, let Z be A:-r-ary and let (p2 be 
the formula 
k 
3(V)ti[LFP^^...j^^,z 3y3viwizi 
.. .Zk ^ Z \/[y = y^Apiy.v^w^zi,.. 
.,Zk))] u. 
Then, for the complements Y^ and Z^ of the stages of the LFP operations 
in (pi and (^2, we have 
z;; = y„=x...xy„=. 
k times 
Hence, ipi and (^2 are equivalent. To eliminate the universal quantifiers "iw 
in p2i we use a variable X with arity(X) = length(l(;)-|-arity(Z) and pass to 
the equivalent formula 
3{y)u[h¥Vy.y^.,,y^^x 3y3vi^'z, 
...ZkiX 
yl,{y 
= y, 
Ap{y,v,z',zi,...,Zk))]u, 
a formula of the desired form (note that X^ = universe^®''^*'^^^^ x Z^ for all 
n). 
D 

9.4 Normal Forms for Fixed-Point Logics 
261 
As an application of the preceding theorem we treat a variant of the 
TC operator, the so-called alternating transitive closure operator ATC which 
turns out to be equivalent to the LFP operator. 
We consider structures of the form A = (A, JB^, U^) with binary E and 
unary U. In this context the elements of t/^ are called universal, the elements 
of A \ U"^ existential The alternating transitive closure ATC{E'^,U'^) 
of 
(E^, U^) consists of those pairs (a, 6) G A x A for which there is an E^-path 
from a to 6 with the property that whenever a universal point c is passed 
there must also be an £J^-path with this property from d to 6 for each d ^ b 
with E^cd. More precisely, using the LFP operator, we define: 
(a, h) G ATC(£;^, t/^) iff 
{A, E^, t/^) ^ 
[LFFa^y^xi^Ux A (Exy V 3z(Exz A Xzy))) 
V {Ux A 3zExz A \/z(Exz -^ {z = yV Xzy)))]xy[a, b]. 
The logic FO(ATC) is defined as FO(TC), replacing the TC-clause by 
^ix,y),ip{x) 
[ATC^^yip{x,y),^{x)]st 
where x, y, s, t all have the same length. The meaning of the new formula is 
given by 
(s,«)6ATCM-,-),V(-)). 
We now have: 
Theorem 9.4.8 FO(ATC) = FO(LFP). 
Corollary 9.4.9 FO(ATC) captures PTIME. 
D 
Proof (of 94.8). As FO(ATC) < FO(LFP) is clear from the definition of 
ATC given above, we need only prove the other direction. 
So let (f be an FO(LFP)-sentence. By 9.4.7(1) we may assume that ^ is 
equivalent to the nontrivial sentence 
3u[LFF^^x (Mx) 
VWy3z G X{^Pi{x,y) -^ 
MV.^Mu, 
where X does not appear in the quantifier-free formulas ipo^xpi, '02 and where 
the free variables are among the displayed ones. In view of nontriviality, this 
formula is equivalent to 
3u[LFF^^x {Mx)y^y{Mx.y) 
^ 3^ G X^l)2{y,z)))]u. 
Let FQQ be the fixed-point of the fixed-point process in the last formula. The 
alternating transitive closure capturing it will make use of a binary and a 
unary relation on the set of all tuples xyvi .. .V4. For i == 1,... ,4 we write 
xyi for any such tuple xyv with ei{v), where the €j are as in the proof of 
9.4.5. Then the relations will be defined by FO-formulas (pE and (pu in such 

262 
9. Logic Programs 
a way that x e Foo iff there is an ATC-path from x^^ 1 to a point of the form 
yy4; more precisely: 
. . X e Foo iff 
some (or equivalently, all) pairs of tuples of the form 
^*^ 
{xxl,yy4) 
are in ATC((p£:(_,_ ),(/?f/(_)). 
As universal points we take all tuples xyl, 
that is, we set 
ipu{x,y,v) 
:= 
ei(v). 
The binary relation consists of edges that take care of the disjuncts ^o(^) and 
Vy(^i(x,y) —)• 3z G Xip2{y,^)) of the fixed-point formula above. Concerning 
^0(^)5 it contains the edges indicated by 
xxl 
^ xx2 
*- yy4, 
and concerning the second disjunct, the edges indicated by 
^^i{x,y)^^y'y'4 
xxl 
^ xyS 
ipi{x,y)^^ 
zzl 
'^2{y,z) 
So as ^E we take 
(pE(xyv,x'y'v') 
:= 
(ei(iJ) AIPQ{X) Ax = y = x' = y' A e2{v')) 
V {e2{v) Ax— y 
Ax'=y'Ae4{v)) 
V (ei(v) A ^ipo(x) Ax = y Ax' = x A €3{v')) 
V 
(eg(^7) A -V'l {x, y)Ax'=y'A 
64{v')) 
V (esiv) Ail)i{x,y) Ail;2(y,x') Ax' = y' 
Aei{v')). 
Then (*) is obvious and yields that (p is equivalent to 
3lZ3z'3u^3liJ'(ei(wJ) A e^iw') A 
[ATC^^^j,X' y' v' ^E{xyv,x' 
y' v'), <^u{x, y, v)] 
uuwzzw'). 
D 

9.5 An Application of Negative Fixed-Point Logic 
263 
9.5 An Application of Negative Fixed-Point Logic 
The normal form obtained in Theorem 9.4.3 tells us - as already pointed 
out in the remarks following this theorem - that in FO(PFP) we can restrict 
ourselves to PFP operations where every element of a new stage is witnessed 
by two elements, one belonging to the previous stage (a positive witness), the 
other one belonging to its complement (a negative witness). In this section 
we analyze the expressive power of the fragment of FO(PFP) containing 
PFP operators with only negative witnesses and give an application of this 
fragment to so-called well-founded DATALOG. 
For kj eN let PFF{kJ) 
be the class of FO(PFP)-formulas containing 
only fixed-point operations where every element of a new stage (besides the 
first one) is witnessed by k positive and / negative elements, i.e., ip G FO(PFP) 
is in PFP(A:,/) if all its subformulas starting with a PFP operator have the 
form 
[PFP^,x ((/^o V 3^1 G X ... 3yf, G X3zi i X .. .3zi i Xipi] t 
where (po and (pi do not contain X. 
We have a complete picture of the expressive power of the different 
PFP(A:,/): 
Theorem 9.5.1 (a) Fork,l>l, 
PFP(A:,/) = PFP(1,1) = FO(PFP). 
(b) For k>2, 
PFP(fc,0) = PFP(2,0) = FO(BFP). 
(c) PFP(1,0) = FO(TC). 
(d) For I > 1, PFP(0,/) = PFP(0,1) = FO(LFP). Moreover, every ip G 
FO(LFP) is equivalent to a totally defined formula of the form 
3 ( V ) M [ P F P ^ . X 3 | 7 ^ X V ( S , 1 7 ) ] « 
where ip is quantifier-free and does not contain X. 
Proof. Part (a) holds by Theorem 9.4.3, parts (b) and (c) hold by Proposition 
8.7.1. We turn to (d) and first prove PFP(0,/) < FO(LFP) by induction on 
PFP(0, /)-formulas. So, consider a formula ^p = [PFP^^x ip] t with ip — (cpo V 
3yi ^ X.. .3yi ^ X (pi) where ipo and (/?i do not contain X. By induction 
hypothesis, we may assume that (^o and (/?i are FO(LFP)-formulas. Then ip 
is equivalent to the FO(LFP)-formula 
((^0 V 3|^i ... 3yi(-^Xy^ A ... A -^Xyi A v?i)) 
negative in X. Therefore, by 8.3.2, [PFP^,^ ^] t is equivalent to an FO(LFP)-
formula. 
We sketch a proof of FO(LFP) < PFP(0,1) and of the normal form claimed 
in (d) and refer the reader to [112] for details. Let (/? be a formula of FO(LFP). 
We may assume that 

264 
9. Logic Programs 
cp = 
3iy)u[LFF^,z^o]u 
with first-order (pQ. For simplicity, let </? be a sentence. 
One can simulate the semantics of FO(LFP)-formulas by a game for a de-
finable digraph, thereby obtaining a quantifier-free first-order formula ip{x, y) 
with 'x = xi .. .Xk and y = yi.. .yk for suitable k such that (1),(2), and (3) 
hold for all A: 
(1) (^^,'0'^(_,_ )) is a digraph, i.e., A \= \/x^xp{x,x). 
(2) A 1= [LFP^^^ 99o] u iff w is won in the game associated with (A^, '0^(_,_ )) 
(cf. 8.1.5(bj). 
(3) (A^,'0"^(_,_ )) has no drawn points. 
Therefore (cf. the example previous to 8.3.2), 3(V)'u[PFP^,x 3y ^ Xtl;{x,y)] u 
is a totally defined formula equivalent to cp. 
D 
We apply the normal form just proven to well-founded DATALOG, WF-
DATALOG. (The exercise at the end of this section shows how one can obtain 
some results for FO(LFP) as immediate consequences of this normal form.) 
Consider the program 
Qx 
<— Qx 
Qx 
•(— -iQx 
In the semantics of both I-DATALOG and P-DATALOG, for a structure A 
we have Qoo = A, the elements of A getting into Q using the "wrong" infor-
mation "-iQ = A" in the first step. In WF-DATALOG, intuitively speaking, 
one requires that the values obtained for the intentional symbols are "re-
confirmed by their positive occurrences". More precisely: The semantics of 
WF-DATALOG, the so-called well-founded semantics, treats positive and 
negative occurrences of intentional symbols in the bodies of clauses in an 
asymmetric way: Let 11 be a WF-DATALOG program, i.e., a general logic 
program. For every intentional symbol P replace all occurrences of P in the 
heads of clauses and all positive occurrences of P in the bodies by a new 
relation symbol P'. Now, the original P does not further occur in the head 
of any clause of the resulting program 11'; hence, P is an extensional symbol 
of n' and thus, 11' is a DATALOG program. In order to simplify the presen-
tation, we assume that 11 only contains a single intentional relation symbol 
P. 
In every Text-structure A, the program 11 gives rise to a sequence {Pn)n>o 
of relations on A defined by 
P o ••= 0 , 
Pn+1 is the result for P' of the evaluation of the DATALOG program 
n' in {A,Pn), i-e., taking Pn as interpretation of the extensional 
symbol P of n'. 

9.5 An Application of Negative Fixed-Point Logic 
265 
For example, for the WF-DATALOG program 
Ho : 
Pxy ^ 
Rxyz, ^Pux 
Pxy ^ 
^Sxy,Rxyz,Pxz,-^Pyy 
we have 
HQ : 
P'xy -^ Rxyz, -^Pux 
P'xy 
^ 
-^Sxy,Rxyz,P'xz,-^Pyy 
and the stages Pn of the evaluation of UQ as described above are just the 
stages F^ of F^, where 
(p{xy,P) 
:= [LFFxy,P' {^z^u{Rxyz 
A ^Pux) 
V 3z{^Sxy A Rxyz A P'xz A ^Pyy))] xy. 
We come back to the general case above, i.e., to 11, the Text-structure A, and 
the sequence (Pn)n>o- Let Ftme be the truth set of this sequence, i.e., 
-Ptrue = {a e A\ 3noVn > no : a G Pn} 
(cf. 8.3.16). Then, by definition, in the WF-semantics, 11 leads to the r-
structure A(n.) := {A^Ptrue)- For terms t, the formula {n.,P)t is a WF-
DATALOG formula of vocabulary Text, its meaning being "^ G Ptrue"-
Note that 
^true — -Poo if the fixed-point PQO of the sequence {Pn)n>o 
exists. Call n a totally c?e/znerf WF-DATALOG program and (H, P)t a totally 
defined WF-DATALOG formula, if the fixed-point exists in all structures. 
In case H is a DATALOG program, the WF-DATALOG formula (n, P)t 
is equivalent to the DATALOG formula (H, P)t; in case H is a totally WF-
DATALOG program and the bodies of the clauses in H contain only negative 
occurrences of P, the WF-DATALOG formula (H, P)t is equivalent to the 
P-DATALOG formula (H, P)t. The same applies to the program in part (b) 
of the following theorem; so, in a certain sense, we can do without the well-
founded semantics. 
Theorem 9.5.2 (a) WF-DATALOG = FO(LFP). 
(b) Every WF-DATALOG formula is equivalent to a totally defined WF-
DATALOG formula {U,P)x with U of the form 
Zxy 
^ 
jii, 
...jik^,^Zxz 
Zxy 
^ 
7si, ...Jsks, 
^Zxz 
Px 
i- 
Zxu 
where the jij contain neither Z nor P. 

266 
9. Logic Programs 
Proof, (a) WF-DATALOG < FO(LFP): Let {Tl,P)t be a formula of WF-
DATALOG and again, for simplicity (otherwise, argue with FO(S-LFP)), 
assume that P is the unique intentional symbol, i.e., H has the form 
Px 
i- 
7 i i , - - - , 7 i f e i 
: <- : 
Px 
4- 7si,...,7sfc3-
Then the stages Pn of n evaluated in a Text-structure are just the stages F^ 
of F'^, where 
s 
ifix,P) 
:= [LFP^.p- \/3F»(7:iA...A7-fcJ]a;. 
where y^ are the variables in (7^1 A ... A jiki) distinct from x and where 7^^ is 
obtained from 7^^ by replacing positive occurrences of P by P^ Then, (p{x, P) 
is negative in P. Hence, F"^ is antitone, i.e., 
XCY 
implies 
F'^(y) C F'^(X) 
(see Exercise 8.1.6). Therefore, 
F^ C F:^ CF^ 
C..,F^ 
C F^ C Ff 
(cf. 8.1.5(a)). Clearly, G := F"^ o F^ is monotone, and G ^ F"^ holds for 
the formula ip{x,P) := ip(x,(p{-,P)) 
positive in P (cf. 8.3.2). Since F ^ = 
^2-n^ we have F ^ = Un>o ^2^ — ^true- Hence, (H,F)^ is equivalent to the 
FO(LFP)-formula 
[LFP^,P^(^,F)]i. 
FO(LFP) < WF-DATALOG: Let ip{x) be an FO(LFP)-formula. By Theorem 
9.5.1(d), it is equivalent to a totally defined FO(PFP)-formula of the form 
3u[PFFy,x 3z i 
X^{x,y,z)]u 
where ij) is quantifier-free and does not contain X. Then, ip{x) is equivalent 
to 
3ii[PFP^y,^ 3z{-^Z'x^ A '0(^,y, t))] xu. 
We can assume that tj; is in disjunctive normal form, e.g., V' = Vi=i(7«i ^ 
• • • A 7ife.) with atomic or negated atomic 7^^. Then, ip{x) is equivalent to 
k 
3u\?YF^y^z 
\J 3z{^Zxz 
A 7ii A ... A ^ik^)] xu 
and hence, equivalent to the totally defined WF-DATALOG formula (H, P)x, 
where H consists of the clauses 

9.5 An Application of Negative Fixed-Point Logic 
267 
Zxy 
^ 
711, ...7ife,,-iZ^^ 
: 
<- : 
Zxy 
^ 
^si, 
'-'Isks^^Zxz 
Px 
^ 
Zxu 
This completes the proof of part (a). At the same time, we have proved part 
(b), too. 
D 
The following exercise contains two further applications of part (d) of 
Theorem 9.5.1: In part (a) we give a short proof for the normal form for 
FO(LFP) contained in Theorem 9.4.7 (thereby restricting ourselves to (2)); 
in part (b) we show that every FO(LFP) formula is equivalent to a first-order 
formula containing relations implicitly definable in FO (cf. 8.5.8). 
Exercise 9.5.3 Let p{w) be an FO(LFP)-formula. According to 9.5.1(d) 
choose a totally defined formula equivalent to p{W) of the form 
(*) 
3{\/)u[PFP^,x^ 
i 
Xx]u 
where x is quantifier-free, does not contain X, and free(x) C 
{x,y,w}. 
(a) Set ip{x,X) := 3y ^ Xx{x,y) 
and ipix^X) := ip{x,ip{^,X). 
Then, F^ = 
F'^ o F'^. Since the formula in (*) is totally defined, we have F^ = F^ (cf. 
8.1.5 and 8.3.2). Show that ip{x,X) is equivalent to 
Mxix,y) 
A\/z{x{y,z) 
-> Xz)). 
Conclude that 
\= 3z^Xz 
-^ (ip{x,X) f^ 3y\/z i X{x{x,y) 
A -x(y,^)) 
and hence, that p{w) is equivalent 
3(V)«[LFP3.,x3yW i X{x(x,y) 
A -xd',^))] «• 
(b) Clearly, p{w) is equivalent to to the formula 
3{\/)u[¥YV^^^Y3y{-^Yyw 
A x)] uw, 
that is totally defined, too. Introduce (p{xw, Y) as above. By 8.1.5, F^ is the 
unique fixed-point of F^. Let ^o(^) •= yxw(Yxw 
-H- 3y{-^Yyw A x)) and 
conclude that 
^fin3='YMy) 
and 
^fin Vy(V'o(n ^ (p(^) ^ >^^~i^)), 
i.e., that p{w) is equivalent to a section of a relation implicitly definable in 
FO. 
D 

268 
9. Logic Programs 
9.6 Hierarchies of Fixed-Point Logics 
We first discuss the problem to what extent the expressive power of fixed-
point operators depends on their arities. This problem comes up very natu-
rally with the proofs of the normal form theorems, where the simplifications 
we have obtained with respect to the number of fixed-point operators, quan-
tifiers, and occurrences of second-order variables had to be paid by enlarging 
the arity of the fixed-point operators involved. 
Denote by FO(LFP0, FO(IFP0, and FO(PFP^) the set of formulas of 
the corresponding fixed-point logic that contain second-order variables only 
of arity = r.^ And let FO(DTC'^) be the fragment of FO(DTC) consisting of 
those formulas, where for any subformula of the form [DTC^,^v?] M we have 
length(x) = r. Define FO(TC0 similarly. Clearly, 
(*) FO(DTC0 < FO(TC0 < FO(LFP0 < FO(IFP^) < FO(PFP^). 
Theorem 9.6.1 Let C he one of the logics FO(DTC), FO(TC), FO(LFP), 
FO(IFP), FO(PFP). For r > 1, let C he the corresponding fragment satis-
fying the arity restriction ahove. Then 
£« < z:^ < £2 < .... 
More precisely: If r contains an at least binary relation symhol then 
£ « [ T ] < £ H T ] < . . . . 
Using dummy variables, it is clear that C^ < C^ < C'^ < 
In view of 
(*), the strict inequalities are an immediate consequence of 
Theorem 9.6.2 For any r > 0 we have 
FO(TC^+^) ^ FO(PFP0 
and 
FO(DTC'"+^) ^ FO(TC0 
on the class of graphs. 
For a proof we refer to [64]. We only sketch the main idea. To ob-
tain FO(TC^+^) ^ FO(PFP^), one considers graphs definable on the set 
of (r-I-1)-tuples of the universe of certain structures. These structures are 
sufficiently homogeneous with respect to r-tuples to cause a collapse of the 
expressive power of FO(PFP'^) to FO. As a consequence, the query ex-
pressing that two (r + l)-tuples are connected by a path is not definable 
in FO(PFP^) but, of course, it is expressible in FO(TC^+^). The construc-
tion is quite intricate. It still has to be refined to obtain structures showing 
FO(DTC^+^) ^ FO(TC0. Note that the first claim cannot be strengthened 
to FO(DTC^+i) ^ FO(PFP0, as FO(DTC) < F0(PFP2) by the next propo-
sition. 
D 
^ Thus FO(LFP^) is monadic fixed-point logic FO(M-LFP) as introduced in sec-
tion 8.5. 

9.6 Hierarchies of Fixed-Point Logics 
269 
Throughout this section, given a formula (p{x,y), we abbreviate by (pdetix^y) 
the formula 
(Pdet{x, y) 
:= 
(p{x,y) A ^z{(p{x, z) ^z 
= y) 
(where J are new variables). Then 
f=fin [BTC^^y(p{x,y)]xy 
^ 
[TCx,y^det{x,y)]xy. 
Proposition 9.6.3 FO(DTC) < F0(PFp2). 
Proof. For r-tuples a, e let 
Xe{a) 
:= 
{(ai,ei),...,(a^,e,.)}. 
As the main step of an inductive proof we show how to express a DTC oper-
ator by a PFP^ operator: Given an FO(PFP^)-formula ip{x,y), we shall find 
an FO(PFP^)-formula ip(x,y,X,x,y,'z) 
with binary X and with parameters 
x,y,^ 
such that for distinct elements zi,... 
,Zr, 
(1) if there is a deterministic (/?-path from x to y, say x = Xo,... ,xi =y, then 
F^,F^,... 
is the sequence 0, Xy(^i), Xy(^2), • • •, 
X^{xi),Xj{xi),...; 
(2) if there is no deterministic (/?-path from x to y then F^ = 0. 
Then, in structures with at least r elements (the others can be treated sepa-
rately), [DTC^,y ^]xy and 
3zi...3zr( 
/\ 
^Zi = Zj 
A3u3v[FFFxy,xi^{x,y,X,x,y,z)]uv) 
l<i<j<r 
are equivalent, and we are done. 
As ip{x,y,X,x,y,^) 
we can take the formula (note that the case of a 
(p-path 
X = 
2^0 5 ^ 1 5 • • • 5 Xm,') Xfm 
• • • 
not containing y needs special care) 
(X = 0 A 3w{ipdet{x,w) A {-^W = x\/w 
= y) A Vi<i<r(^ = 'WiAy = Zi))) 
V3v3w(/\^^-^^XviZi 
A (pdet{v,w) A -^v = y A -^v = WA 
Vi<i<r(^ = Wi Ay=^ Zi)) 
V (Al<i<r ^Vi^i ^ Vl<i<r(^ = yi A y ^ Zi)). 
u 
We now turn to the hierarchy problem for ordered structures. We present 
two propositions which will help us to discuss the general problem. 

270 
9. Logic Programs 
3\ 5 
Proposition 9.6.4 On ordered structures, FO(DTC) < FO(LFP"^) 
Proof. Consider a formula ip{x,y), where x = xi .. .Xr and y = t/i ...^r- In a 
structure A of cardinality n, the (shortest) deterministic v?-path between two 
tuples must have length < n^. Assume A = { l , . . . , n } . First suppose that 
there is a deterministic (/?-path 
(1) 
x^xo,xi,...,Xk 
=y 
from xtoy 
with k <n (where xi = xn ... xir). To rewrite (/? as an FO(LFP^)-
formula, we shall code the existence of such a (/?-path by an LFP operator 
with stages 
Xi 
= 
{(a:ii,l,l),(a:i2,l,2),...,(a:i;.,l,r)} 
X2 
= 
XiU{(x2i,2,l),(a:22,2,2),...,(a:2r,2,r)} 
Xk 
= 
Xk-i U {{xki,k, 1), {xk2,k, 2),..., {xkr, k,r)} 
and Xk — Xk+i = 
Using s nested LFP operators appropriately, we can 
express the existence of a deterministic (/?-path of length < n*. For s = r, we 
get the desired formula. 
To give the details of the elimination of a DTC operator by LFP^ oper-
ators (as the main step of an inductive proof), let (p{x,y) be any FO(LFP^) 
formula. 
Consider the formula 
il^ix^y) 
:= 
[DTC^^yip{x,y)]xy. 
Then, in structures with at least max{3, r} elements, the statement 
"there is a deterministic (^-path of length < (cardinality of the uni-
verse) from X to ^" 
can be expressed by the FO(LFP^)-formula (p*{x,y) below, which uses the 
above coding of the path (1) prolongated to the path x = xo,Xi,... 
,Xk = 
y,y,...,y 
onengthn: 
^ 
ip* := 
3x3v[LFFxuv,x 
3y'((Pdet{x,y') A tt = min -hi A Vi<i<r(^ = ?/i A ^ = z)) 
V 3u'3x'3y'{ipdet{x',y') 
A -^x' =y A Ai<i<r Xx'yi 
A u = u' + 1 
A Vi<«<r(^ = y'. A v = i) A {u = max -^y' ^ y)) 
\/3u'{l\^^^^^Xyiu'i 
A u = u' -\-l A Vi<i<r(^ - yt A v - i))]a:maxi;. 
^ The next exercise shows that LFP^ can be replaced by LFP^. 
^ As usual, for 2 > 1 we abbreviate hy z = i that z is the i-th. element in the 
ordering. 

9.6 Hierarchies of Fixed-Point Logics 
271 
We now iterate the transition from ^p to cp*, defining 
ip^=^* 
and 
(^^+1 = ((/p^)*. 
Then cp^(x, y) expresses 
"there is a deterministic (p-path of length < (cardinality of the 
universe)* from x to ^." 
Hence, ^^ is an FO(LFP^)-formula equivalent to [DTCx,y^{x,y)]xy. 
D 
Exercise 9.6.5 Show that FO(DTC) < F0(LFp2) on ordered structures. 
Hint: Using arithmetics definable in FO(LFP^), code the last two components 
of X in the preceding proof by a single one. 
D 
We know that FO(DTC) £ FO(LFP^) on ordered structures, since even 
FO(DTC) ^ MSO on ordered structures (cf. 8.6.3). But we have: 
Proposition 9.6.6 On ordered structures, FO(DTC) < FO(PFPi). 
Proof. Consider the formula 
[DTC^,yip{x,y)]st 
with X = xi.. .Xr and y = yi.. .yr- We show how the DTC operator can be 
expressed by PFP^. For this purpose we consider a deterministic (p-paih 
(*) 
5 = ^ 0 , ^ 1 , ^ 2 , . . . 
starting from s. The idea is to code r-tuples x by subsets Px of the universe 
and to find a formula of FO(PFP^) whose PFP^ operator has the stages 
0, Px^, Px2,..., Pxk, ^J, Pj^ • •' i^ ^^s® ^k = ^ in (*), but does not reach a 
fixed-point in case the deterministic (/?-path started in s does not pass t. 
We present the codification of ^ in a set P^: Let (the interpretations of) x be 
given in an ordered structure. For 1 < z < r, let m^ be the position of xi in 
the ordering induced on the Xi (for example, if r = 4 and xs < Xi — X4 < X2 
then mi = 2,m2 = 3,m3 = 1,7724 = 2). Note that 1 < m^ < r. Order the set 
{(ni,..., Ur) I 1 < n i , . . . , nr> < r}, a set independent of the given structure, 
lexicographically. If (mi,... ,my.) is the /-th element in this ordering set 
Px - {x} U / 
where / is the leftmost interval in the given structure having length r + 1 + 1 
and containing no Xi (such an interval exists in structures of cardinality 
> {r-\-l)-{r-\-2-\-r^)). 
Note that P^ uniquely codes {x} and / and hence, x. 
Since the coding and decoding of x in P^ is first-order definable, it is easy to 
write down an FO(PFP^)-formula equivalent to [DTCx,y^{x,y)]st. 
D 
The hierarchy result for FO(PFP) remains true also on ordered structures. 

272 
9. Logic Programs 
Theorem 9.6.7 For all r > 0, FO(PFP^) < FO(PFP^+i) on ordered struc-
tures. 
Proof. For e G E, e > 1, consider the function n ^-^ n^. We say that a 
class K is in SPACE(n^) if for some c > 0 there is an c-n^ space-bounded 
deterministic Turing machine accepting K. From complexity theory we know 
that for r eN, 
(*) 
SPACE(nO 7^ SPACE(n^+^). 
We show that 
(1) 
each class axiomatizable in FO(PFP'^) is in SPACE(n^) 
and for € G M, 0 < e < 1 that 
(2) 
each class in SPACE(n^+^) is axiomatizable in FO(PFP^+i). 
Then we are finished: If K is a class in SPACE(n^+^)\SPACE(nO then K 
is axiomatizable in FO(PFP^+i) (by (2)), but not in FO(PFP0 (by (1)). 
Claim (1) is already inherent in the proof of 7.4.2. Claim (2) is obtained 
by an analysis of the proof showing that classes of ordered structures in 
PSPACE are axiomatizable in FO(PFP) (cf. 7.3.2). We sketch a proof. To 
code the configurations of an n^ space-bounded machine, in section 7.3 we 
used a (2-|-r)-ary relation, where the first two components served to distinguish 
the distinct ingredients of configurations, their number k being independent 
of the input structure. Clearly, k distinct numbers of a single component are 
sufficient for this purpose. The remaining n — k numbers of this component 
can be used (in sufficiently large structures) to encode the n^ part of an n^+^ 
space-bounded machine (because of the preceding proposition and 7.3.11 the 
arithmetics needed for the encoding is available in FO(PFP^+^)). 
D 
Corollary 9.6.8 On ordered structures, FO(DTC) < FO(PFP). 
Proof. On ordered structures, we have FO(DTC) < FO(PFPi) (cf. 9.6.6) and 
FO(PFPi) < FO(PFP) by the preceding theorem. 
D 
In the following remarks we restrict ourselves to ordered structures. It 
is open whether the arity hierarchy is strict for FO(DTC), FO(TC), or 
FO(LFP), that is, whether the analogues of 9.6.7 are true for these logics. 
The problem for FO(LFP) is related to prominent questions in complexity 
theory: If FO(LFP) = FO(LFP^) for some r > 1, then by 9.6.7, FO(LFP) 
^ FO(PFP) and hence, PTIME ^ PSPACE (cf. 7.5.2). On the other hand, 
in view of FO(DTC) < F0(LFP3) (cf. 9.6.4), if FO(LFP) ^ F0(LFp3) (by 
9.6.5, even if FO(LFP) ^ F0(LFp2)) then FO(DTC) ^ FO(LFP) and hence, 
LOGSPACE ^ PTIME (cf. 7.5.2). 

9.6 Hierarchies of Fixed-Point Logics 
273 
Exercise 9.6.9 Let C G {FO(DTC),FO(TC),FO(LFP)}. Show £} < C? on 
ordered structures (cf. 8.6.3). Show that FO(LFPi) < FO(IFPi). Hint: Use 
6.3.3 (and 6.2.3) to show that FO(IFPi) ^ MSO on word models. 
D 
Exercise 9.6.10 Show FO(DTC) < F0(IFP2). Hint: By 9.6.5, FO(DTC) 
< FO(LFP^) on ordered structures. Use deterministic paths to define suffi-
ciently large orderings that allow to carry out the corresponding argument. 
D 
We know that every FO(LFP)-formula is equivalent to an FO(LFP)-
formula containing just one fixed-point operation. But, given r, does this 
result hold for FO(LFP^) instead of FO(LFP)? In other words: Do we really 
have to increase the arity when replacing nested fixed-point operations by 
single ones? In general, we have. We close by stating a theorem which con-
tains the corresponding result for all fixed-point logics. For a proof we refer 
to [113]. 
For an FO(DTC^)-formula ip let n((/?) be the maximal number of nested 
DTC operations in ip. Define p : FO(PFP) ^ N by 
p(^) 
p(r^) 
p{ip\iil)) 
p{^xip) 
p([PFP^,x(/^]^) 
:= 
0, 
if 99 is atomic; 
:= 
p((/?); 
:= 
max{p((/?), p(V')}; 
:= 
p(ip)\ 
\— 
p{ip) -\- arity of X. 
Theorem 9.6.11 For k >0 there is an FO(DTC )-sentence ip with n{(p) = 
k -\-l, which is not equivalent to any FO(PFP)-lenience ip with p{il)) < k. D 
Corollary 9.6.12 For every k > 1 there is an FO(LFP )-sentence not equiv-
alent to any FO(LFP )-sentence with a single LFP operation. 
D 
Notes 9.6.13 A reference for databases and logic programs is [1]. The main 
reference for sections 9.1 and 9.2 is [3]. Theorem 9.3.2 goes back to [7]. Most 
of the results of section 9.4 are due to Grohe and contained in his thesis [62]; 
cf. also [63]. References for section 9.5 are [112] (for Theorem 9.5.1(d)) and 
[42] (for Theorem 9.5.2). The main result of section 9.6, Theorem 9.6.2, is 
due to Grohe [62, 64]. Further references are [67, 88]. 

10. Optimization Problems 
Many of the oldest and more prominent examples of NPTIME-complete deci-
sion problems arose from the study of combinatorial optimization problems, 
the NPTIME-completeness reflecting their apparent intractability. More pre-
cisely, the NPTIME-completeness of the decision problem rules out the ex-
istence of a polynomial time algorithm for the optimization problem (unless 
PTIME = NPTIME). Of course, the intractability of an optimization problem 
does not exclude the existence of efficient algorithms that provide approxi-
mative solutions. And in fact, such algorithms may be necessary for practical 
purposes. 
It has turned out that intractable optimization problems may behave 
quite differently with respect to the existence of approximative algorithms (a 
phenomenon that led to various notions of approximability). 
In this chapter we first show that the class of polynomially bounded optimiza-
tion problems coincides with the class of optimization problems definable by 
first-order formulas. This characterization leads to a logical or descriptive 
classification of those problems. Section 10.2 presents some first results doc-
umenting a relationship between this classification and approximability. For 
further study we refer the reader to the literature. 
10.1 Polynomially Bounded Optimization Problems 
To prepare our definition of an optimization problem, let us consider two 
examples, a maximization and a minimization problem. 
A cut C in an graph Q = (G, E^) is a subset of G. 
MAXCUT: Given a graph Q, MAXCUT asks for the maximal number of 
edges between the two parts of a cut, that is, for the maximum of 
\\{{a,b)\E°ab,aeC,biC}\\, 
where C ranges over all cuts in Q. 
A vertex cover C in a graph Q — (G, E^) is a subset of G such that 
g ^ \/x\/y{Exy -^ (Cx V Cy)). 

276 
10. Optimization Problems 
MINVERTEX: Given a graph Q, MINVERTEX asks for the minimum of ||C|| 
where C ranges over all vertex covers in Q. 
In this chapter we use some sloppy formulations. For example, we say that a 
class K of (unordered) structures is acceptable in polynomial time, actually 
meaning that the class K^ of its ordered representations (cf. 7.5.11) is in 
PTIME. And if we say that a function f : K ^ Nis computable in polynomial 
time, we mean that the function /< : i^< -> N with 
f<i{A,<)) 
:= 
f(A) 
is computable in polynomial time. 
Definition 10.1.1 An NPTIME optimization problem Q is given by the data 
K,F, cost, fj,, by short: Q = {K^F, cost, //), where 
— K is a, class of structures (of a fixed vocabulary) acceptable in polynomial 
time, the class of input structures or input instances. 
— F is a function defined on K; for every instance A, F{A) is the set of 
feasible solutions for A. There is an 5 > 1 such that for every A E K and 
5 e FiA), 
SCA'. 
Moreover, the class 
{{A,S) 
\AeK,SeF{A)} 
is acceptable in polynomial time. 
— cost is a polynomial time computable function defined on the class {{A, S) \ 
A e K,S e F{A)}. The values of cost are natural numbers. 
— fi e {max, min}. 
If fji = max (IJL = min) we speak of a maximization (minimization) problem. 
D 
For Q we define the function optg on the class K of input instances by 
optQ(^) 
:= fi{cost{A, S)\S 
e F{A)}. 
An NPTIME optimization problem Q induces the following decision problem: 
Given an input instance A and a A: > 0, is there a feasible solution S for A 
such that cost(^, S) > k if jji = max, and cost(^, S) < k if /i = min? The 
name "NPTIME optimization problem" is justified by the observation that 
this decision problem is in NPTIME. 
Let us see how the above examples, MAXCUT and MINVERTEX, fit into 
these definitions. In both examples the class of instances is the class of graphs. 
For MAXCUT the set of feasible solutions F{Q) is the power set Pow(G), 
and the cost function is given by 

10.1 Polynomially Bounded Optimization Problems 
277 
cost(^, C) = ||{(a, h)eE^ 
\aeC 
Sindbi C}\\ 
and fi = max. For MINVERTEX, F{Q) is the set of vertex covers in Q, 
costiG,C) = \\C\\ 
and fj, = min. In both cases the problem asks for optg(^). 
An NPTIME optimization problem Q is said to be polynomially bounded if 
there is a polynomial p G N[x] such that optQ(^) < p(im|) for all input 
structures A. 
For polynomially bounded optimization problems the bridge to logic is 
given by the following concept. 
Definition 10.1.2 An NPTIME optimization problem Q is first-order de-
finable if there is a first-order formula (p{x,Y) with free variables among 
X = xi .. .Xk and Y = Yi .. .Ym such that for any input structure A, 
optgM) = M \\{a eA\A[= 
^[a,R]}\\. 
D 
R 
Clearly, MAXCUT is first-order definable by the formula 
(p(x,y,Y) 
:= Exy /\Yx 
f\-Yy 
and similarly, MINVERTEX by 
Lp{x, Y) 
:= Wx^yiExy -^ {Yx V Yy)) -^ Yx. 
Theorem 10.1.3 ^n NPTIME optimization problem is polynomially bounded 
iff it is first-order definable. 
Proof. Clearly, if an optimization problem Q is first-order definable, say by 
(/9(a;i,... ,Xk,Y), then optQ(^) < \\A\\^ for all instances A; hence, Q is poly-
nomially bounded. 
Now suppose that Q is a polynomially bounded optimization problem, 
say, optQ(^) < \\A\\^ for all instances A. Denote by r the vocabulary of the 
input structures of Q and let P be a new A:-ary relation symbol. Set 
Ki := {{A,P'^)\Ae 
K,P^ C A^, there is a feasible solution 
S G F{A) such that cost(^, S) > ||P^||} 
if /x = max, and 
Ki := {(^,P^) lAeK^P'^C 
A^, there is a feasible solution 
S G F{A) such that costiA,S) 
< ||P^||} 
if /i = min. By the remarks following Definition 10.1.1 we know that the class 
Ki is in NPTIME. Therefore, by 7.5.14, there is a Ej-formula 3X^l)(X, P) of 
vocabulary r U {P} with first-order ip such that for any structure {A, P^), 

278 
10. Optimization Problems 
{A,P'^) e Ki iff {A,P^) 
h 3Xt/;(X,P). 
Thus, 
optQ(.4) = MIII^II I ^5 P relations over A such that A \= ip(R, P)}. 
Therefore, in case opt = max we have 
(1) 
optQ(^) = max ||{aG A I ^ ^ P a A ' 0 ( ^ , P ) } | | , 
'R,P 
and in case opt = min, 
(2) 
optg(^) = min \\{a eA\A\= 
^p(R,P) -^ Pa}\\. 
R,P 
Hence, Q is first-order definable. 
D 
Denote by MAX PB the class of polynomially bounded maximization 
problems and by MAX E^ the class of first-order definable maximization 
problems, where the defining formula (cf. 10.1.2) can be chosen S^. Classes 
such as MAX 11^, MIN PB, ... are defined similarly (for the definition of S^ 
and Un compare l.B). 
Using so-called Skolem relations, one easily shows that every S}-formula 
is logically equivalent to a formula of the form BXV' with i/^ G 112. E.g., for 
^ = \/y3ziv3v^ 
with quantifier-free (^, we show how the formula 3Xil) can 
be transformed into the desired form, thereby exemplifying the main step 
of an inductive proof. For a new relation variable Z, the formula 3X\IJ is 
equivalent to 3X3Zyy{3wZyw 
A \/z{Zyz -^ ^uBvif)) and hence, equivalent 
to 3'X3Z\fyiz\/u3w3v{Zyw 
A {Zyz -^ cp)). 
Thus the formula ip used in the proof of the preceding theorem can be 
assumed to be 112. Hence, the formula in (1) is equivalent to a n2-formula 
and that in (2) to a i;2-formula. Therefore, we have 
Corollary 10.1.4 (a) MAX PB = MAX FO = MAX n2. 
(b) MIN PB = MIN FO = MIN E2. 
D 
For minimization problems we can do better: We shall see in 10.1.6 that MIN 
PB = MIN Hi. In the proof, given a problem in MIN S2, we shall replace 
the leading existential quantifiers by relations similarly as above. The same 
idea underlies the following proof. 
Proposition 10.1.5 MAX E2 = MAX Hi and hence, MAX Ei C MAX 
Hi. 
Proof. Let Q be in MAX E2 and let il){x,y^ Y) be a Hi-formula such that for 
any instance A we have 
optQ(^) = max ||Sat(^)||, 

10.1 Polynomially Bounded Optimization Problems 
279 
where 
Sat(:R) 
:= 
{aeA\A\=- 
3ytP{a,y,R)}. 
We show 
(*) 
max ||Sat(S)|| = max ||Sat(E,P)||, 
'R 
'R,P 
where Sat(i?, P) is 
{abeA\A\= 
tp{a,b,'R) A Pab A "iyizdPayAPaz) 
-^ y = z)}. 
This gives the claim, since then optQ(.4.) = max^^p ||Sat(i?, F)||, and the 
formula in the definition of Sat(i?, P) is equivalent to a Hi-formula. 
To prove (*), note that abi,ab2 G Sat(i?,P) implies 61 = 62 and a G 
Sat(P). Thus 
(1) 
||Sat(P)||>||Sat(P,P)||. 
On the other hand, for a G Sat(P) choose a witness b{a). such that A \= 
i){a,b{a),^) 
and set PQ := {ab{a) \ a G Sat(P)}. Then Sat(S,Po) = PQ and 
hence, 
(2) 
||Sat(B)|| = ||Sat(:R,Po)||. 
From (1) and (2) we conclude (*). 
D 
Proposition 10.1.6 MINHi = MINS2 (= MINPB) an^MINEo = MINSi. 
Proof. For the first assertion, let Q be a problem in MIN E2 and let ^p{x, y, z, Y) 
be a quantifier-free formula such that 
optQ(^) = min ||Sat(P)|| 
'R 
where 
Sat(P) 
:= 
{aeA\A\=3yyzil;{a,y,z,R)}. 
We can assume that x = xi .. .Xk and y = yi.. .ym are of the same length 
(if m < fc we extend y by dummy variables and if A: < m we replace ^ by 
ip Axk = Xk+i = ... = Xm)' We show 
(*) 
min ||Sat(P)||= min ||Sat(P,P)||, 
fi 
^,p 
where 

280 
10. Optimization Problems 
Sat(S, P) 
:= 
{abe A\A\= 
{yzip{a, b, z, 'R) A ^Pa) V {a = 
bAPa)}. 
This finishes the proof, since the formula in the definition of Sat (i?,P) is 
equivalent to a IIi-formula. 
To show (*), we verify for every R that 
(+) 
||Sat(:R)||= min ||Sat(:R,P)||. 
p 
Fix R and let P be arbitrary. For a G Sat(i?) choose b such that A \= 
\/z'ip{a, 6, z, R). If not Pajhen ab G Sat(S, P) and if Pa then a a G_Sat(S, P). 
Thus,JSat(P)|| <JSat(P,P)||. On the other hand, for P = Sat(S), we have 
||Sat(S)|| = ||Sat(P,P)||. Altogether, we see that (+), and thus (*), holds. 
To prove MIN So = MIN Ei, just omit the variables 1 and the quantifiers V^ 
in the preceding proof. 
D 
By 10.1.4-10.1.6 we have 
MAXEo C MAX El C MAX Hi = MAXE2 C MAX Ha = MAXPB 
MIN Eo = MIN El C MIN Hi = MIN E2 {= MIN U2) = MIN PB. 
All the inclusions are proper (compare [105]). The situation changes for struc-
tures with a built-in successor relation (compare [34]). 
10.2 Approximable Optimization Problems 
For many NPTIME optimization problems Q = {K,F, cost, /x) the corre-
sponding decision problem, in case /i = max the set 
{{A, k) I there is a feasible solution S G F{A) such that cost(^, S) > k}, 
is NPTIME-complete. An example is given by MAXCUT. Unless PTIME 
= NPTIME, this rules out the existence of a polynomial time algorithm 11 
giving optimal solutions in the sense that for any instance A, 
Ii{A) G F{A) 
and 
optQ(^) = 
cost{A,U{A)). 
For practical purposes one is interested in approximation algorithms: 
Definition 10.2.1 Let 0 < £ < 1 and Q be an NPTIME optimization prob-
lem. Q is e-approximable if there is a polynomial time algorithm 11, which for 
every instance A returns a feasible solution 11 (.4) such that 
|0ptg(^) - COSt(v4,n(^))| < £ •OptQ(^). 
That is, cost(.4, II(^)) > {I - e) - optQ(^) if fi — max, and cost(^, n(.4)) < 
(1 + e) • optQ(^) if /Li = min. 
Denote by APX the class of NPTIME optimization problems that are 
^-approximable for some e with 0 < £ < 1. 
D 

10.2 Approximable Optimization Problems 
281 
To relate the class MAX Si to APX, we have to incorporate some effec-
tivity requirements; they are fulfilled in all familiar examples. 
Definition 10.2.2 A formula ip{x^ Y) effectively represents the NPTIME op-
timization problem Q if, in addition to the conditions stated in Definition 
10.1.2, there is a polynomial time algorithm that, given any instance A and 
any relations R on A, computes a feasible solution S G F{A) with 
cost(A S) = \\{a eA\A\^ 
^(a,^)}||. 
• 
In the following let MAXe Ei be the class of maximization problems which 
can be effectively represented by a Ei-formula. 
Theorem 10.2.3 MAXg Ei C APX. 
Proof. Consider a problem Q in MAXg Ei. Then, for a suitable quantifier-
free formula ip{x^y^Y)^ the formula 3yip{x,y,Y) 
effectively represents Q; in 
particular, for any instance A we have 
optQ(^) = m_ax||{a G A | A [= 3yil;{a,y,R)}\\. 
R 
Set 
Ao 
:= 
{aeA\A\=^3Y3yiP{a,y,Y)}. 
Then 
(*) 
\\Ao\\>optQ{A). 
Assume y — yi .. .yn- Since AQ = {a G A | A |= 3y3Y'ijj{a^y^F)}, there is a 
function f : AQ -^ A^ such that 
holds for all a G AQ . Consider the probability space Q of all tuples of rela-
tions R on A (of arities corresponding to Y) with the uniform probability 
distribution and let XA be the random variable with 
XA(R) 
••= 
\\{aeAo\A^t{a,f(a),R)}\\. 
Let k be the number of atomic formulas in ip with a relation variable in Y. 
Then for the mean value E(XA) of XA we show: 
(1) EixA) > ^\\Ao\\. 
(2) There is a polynomial time algorithm that, given an instance A, yields 
relations i^ on A such that 
XA(R) 
> 
E(XA)-

282 
10. Optimization Problems 
This proves the claim: Given A, in polynomial time we first pass to relations 
R as in (2) and then, by effective representability, to a feasible solution, say 
n(^), with 
cost(An(^)) 
= 
\\{aeA\A^3yil^{a,y,R)}\\ 
> 
\\{aeAo\A[=4^{aJ{a),R)}\\ 
= 
XA{R) 
> UM\ 
(by (1) and (2)) 
> 
^ o p t 2 ( ^ ) 
(by(*)). 
To show (1), we define the indicator function / by 
l(R,a) := 
1 
ifA^i^{aJ{a),R) 
0 
otherwise. 
Then XAiR) = EaGAo ^(^^«) and hence, 
EiXA) 
= 
T^ReQ ]\h\\'XA{R) = 1^1 E H G ^ T^aeAo ^(^' ^) 
= 
llaeAo Jim ^Reo 
^(-^' ^)' 
Fix a e AQ. Let a i , . . . , a^ be the distinct atomic subformulas of ip with a 
relation variable in Y. Then A determines the truth values of all atomic sub-
formulas of ip different from ai,...,afc. By definition of ^o and /, there 
are relations P such that A \= il){a, f{a),P). 
Thus, for the correspond-
ing assignment of truth values to a i , . . . , a^, the formula ip gets the truth 
value TRUE. Hence, for all relations R leading to the same truth values of 
a i , . . . ,afc, and these are at least ^||i^|| many, we have A (= il){a, f{a),R). 
Thus, Y^^^^ I{R, a) > ^IIi?||. So the equalities above give £J(x^) > ^ m d l -
The last considerations show (and the same applies to similar mean values 
below) that E{XA) can be evaluated in time polynomial in |m|: First, we 
list AQ and a function / of the kind in question by testing for all a G A 
whether for some b we have 'ip{a,b,R) for some R, putting a in ^o, and set-
ting f{a) = 6 if 6 is the first tuple with this property (note that we need 
R only on the sets {a, 6} of limited cardinality). Now, to calculate 
E{XA)J 
for ^-^^^ 
I{R,a) we again need consider the behaviour of the relations R 
only on the set {a,/(a)}, the total number of the relations with the same 
behaviour being easily calculable. 
We come to a proof of part (2). Suppose A = {1,... ,n}. In polynomial 
time we construct relations R with XA{R) > -'^(x^)- For this purpose we 
shall stepwise fix the truth value of Re ior R e R and e £ A. 
Let /?!,..., /3m be an enumeration (in a standard way) without repetitions 
of the elements of the set 
{aj{aj{a)) 
\l<j<k,aeAo} 

10.2 Approximable Optimization Problems 
283 
(if, for example, f{a) = 6, f(b) — a, ai = Rxy, aj = Ryx, and i ^ j , then 
ai{a, f{a)) — aj{b, fib)), and this instance occurs only once in /?i,..., /?^). 
By induction on s we fix the truth value tg € {TRUE, FALSE} of /?« such 
that the following inequality holds for the conditional expectations: 
(*) 
E(xA\l3f 
= tu---,/3f 
= ts)> EixAlPf 
= t i , . . . , 4^-1 = 
ts-i). 
Since E{xA\0f 
= *i, • • • ,/3.^-i = «.-i) = 
lE{xA\/^f 
= 
h,...,0f_,=t,.i,l3f=TRVE) 
^EixAlPf 
= h,...,/?/_! 
= t,.ul3f 
= FALSE), 
in order to fix tg we only have to check whether 
E{XA\l3f = tu...,l3ti= 
ts-i, fit = TRUE) 
> 
E(xA\l3t 
= t i , . . . , /3/_i = «.-i, fif = FALSE), 
and by the remarks above this can be done in polynomial time. For s = m 
we have by (*) 
EiXAlfif =tu...,0i=tm)> 
EixA\fit- = h,...,0i^,= 
«m-l) 
>--->EixA\/3f 
= 
h)>EixA)-
Since for relations R and R' that coincide on all atomic subformulas of 
ipia, f(a),Y) 
with a G ^o^ we have 
XA(R) 
= 
XA(R'), 
we see that for any R with truth values ti,... 
,tm on /3i,..., /3^, respectively, 
we have 
XA(R) 
= E(xA\fit 
= tu...J^=tm) 
(> 
EixA))-
Thus we obtain the relations R as claimed in (2) by fixing the values on 
A5 • • • 5Pm according to h,... 
,tm and arbitrarily (say, as FALSE) on all 
other tuples. 
D 
In the first part of the preceding proof we have shown 
Corollary 10.2.4 Assume Q is in MAXe Tii, say, for every instance A we 
have 
optQ(^) 
= 
ma,x\\{ae A\ 
A\=3y'tp{a,y,R)}\\ 
R 
with quantifier-free ipi^,y,Y). 
Then there is a polynomial time algorithm 
that, given an instance A, yields relations n(^) on A such that 
costM,n(^)) > l||Ao||, 
where k is the number of atomic formulas in ip with a relation variable in Y 
and where AQ := {ae A\ A\= 3Y3yip{a,y,Y)}. 
D 

284 
10. Optimization Problems 
As an application we obtain 
Proposition 10.2.5 MAXCUT is \-approximahle. 
Proof. If Q denotes MAXCUT, we have for any graph A, 
(+) 
optQ(^) = 
m^yi\\{{a,h)\A[^Eah^Ra^-^Rb}\\. 
R 
Thus, the preceding corollary with ?/; = Exy A Yx A -^Yy^ y the empty se-
quence, k = 2, and AQ = {(a, 6) | ^ ^ 3Y{Eab A Fa A -^Yb)} = E^ yields a 
polynomial time algorithm 11 such that 
cost(An(^)) > 
]\\E\ 
4 
Since E^ab implies E^ba, we have by (+); 
opte(^) < 
l\\E\ 
Altogether, 
cost(^,n(^)) > -optQ(^). 
D 
The following two observations show that possible extensions of Theorem 
10.2.3 fail. 
Denote by PTAS the class of NPTIME optimization problems Q with 
a polynomial time approximation scheme, i.e., with the property that there 
is an effective procedure 11 that returns, for every rational e with 0 < e < 
1, a polynomial time algorithm 11^ witnessing that Q is e-approximable. It 
has been shown that, unless PTIME = NPTIME, MAXCUT ^ PTAS; in 
particular, as MAXCUT G MAXeSi, we have MAX^ Si g PTAS. 
We come two the second observation. Let Q be the problem MAX-
CLIQUE: Given a graph Q it asks for the maximal size of a clique in Q. 
Hence, MAXCLIQUE G MAX^ Hi, since 
optQ(^) 
= 
max||{aGG | Q ^ Ra Ayx\/y{{Rx 
A Ry Ax ^ y) -^ Exy)}\\. 
R 
It is known that, unless PTIME = NPTIME, MAXCLIQUE ^ APX, showing 
that Theorem 10.2.3 cannot be extended to MAXe IIi. 
We close this section with two "positive" remarks on Theorem 10.2.3. The 
first one gives a generalization, the second one shows how to enlarge its scope 
of applicability. 
We can change the definition of a first-order definable optimization prob-
lem by considering in 10.1.2 formulas ip{x,u,Y) 
and requiring that 
optg(^) = 
fi_ \\{a eA\A\=- 
ip[a,b,R]}\\ 
b,R 

10.2 Approximable Optimization Problems 
285 
("optimization over elements and relations"). Replacing elements by rela-
tions, we see that this does not change the notion of a first-order definable 
optimization problem; however, the classes MAX Ei and MAXg Si strictly 
increase, if we allow optimization over elements and relations (note that the 
replacement of constants by relation symbols uses universal quantifiers). Nev-
ertheless, Theorem 10.2.3 remains true for the larger class MAXe Si (indeed 
with essentially the same proof). 
The following example shows how one can enlarge the scope of applicability of 
the preceding theorem. Consider the optimization problem known as MAXI-
MUM CONNECTED COMPONENT (MCC). Given a graph, it asks for the 
maximum of the cardinalities of connected components. Since the connected 
components are computable in polynomial time, there is a polynomial time 
algorithm solving the optimization problem. By 10.1.4(a) we know that MCC 
G MAX Hs. On the other hand, MCC ^ MAX Hi (see Exercise 10.2.6 below) 
and hence, MCC ^ MAX Ei by 10.1.5. Therefore, our logical approach does 
not yield MCC G APX, even though there is a polynomial time algorithm 
giving an optimal solution. 
However, since the transitive closure is computable in polynomial time, 
the approximability of MCC is equivalent to the approximability of MCC, 
where MCC is the problem 
Given Q = {G,E^,R^) 
with R^ = TC{E^), 
a "graph with tran-
sitive closure", compute the maximal cardinality of its connected 
components. 
Clearly, MCC is in MAXg Ei (with maximazation over elements) since 
optMCC'(-^) = "lax \\{a I Q |== Rah}\\. 
b 
Now, 10.2.3 (with maximization over elements) yields MCC G APX. 
Of course, the same idea can be applied to any other optimization problem: 
The values of polynomial time global relations can be added to the instances 
by free without changing the behaviour of the optimization problem with 
respect to the notion of approximability we have considered. In [11] this 
extra relations have been "added" on the logical side, allowing formulas of 
FO(LFP) instead of FO. 
Exercise 10.2.6 (a) Give a direct proof that MCC G MAX Hs. (b) Show 
that MCC ^ MAX Hi (even not with maximization over elements). 
D 
Notes 10.2.7 The main references for this chapter are [104, 105, 129]; they 
also contain corresponding historical remarks. 

11. Logics for PTIME 
There are logics (for instance FO(IFP); cf. Chapter 7) that capture PTIME 
on ordered structures. Instantly, this result evokes the question whether it 
can be strengthened to the case of not necessarily ordered structures: 
Is there a logic strongly capturing PTIME ? 
There are examples of such logics (cf. 11.1.2); however, they are quite ar-
tificial, at the same time showing that we should incorporate some obvious 
requirements of effectivity in our notion of strongly capturing. We thus are 
led to an effective notion of a logic strongly capturing PTIME and, therefore, 
may reformulate the question above as follows: 
(*) 
Is there a logic effectively strongly capturing PTIME? 
The question is considered to be the most prominent open problem in finite 
model theory and, at the same time, a difl&cult one. For instance, a proof that 
such a logic does not exist, would yield that PTIME ^ NPTIME (cf. section 
11.1) and hence, solve the most prominent open problem in complexity theory. 
Moreover, in section 11.1 we show that the question (*) is strongly related 
to the isomorphism problem for finite structures. 
The statement "FO(IFP) captures PTIME" can be reformulated as 
"FO(IFP) effectively strongly captures PTIME on the class of ordered struc-
tures". In section 11.2 we are led to investigate specific classes of (not neces-
sarily ordered) structures whether they allow for a similar result, i.e., we are 
led to search for partial solutions of (*). We present some positive results. 
The discussion of specific logics that may be candidates for a positive 
solution of (*) itself, is transferred to the next chapter. There we shall also 
see that if there is any logic at all that effectively strongly captures PTIME, 
then there is such a logic with a familiar syntax. 
In the following not only structures, but also formulas and Turing ma-
chines will be considered as objects of computations. When doing so, we 
shall tacitly assume that vocabularies, formulas, and machines are coded by 
{0, l}-words in some reasonable way. 

288 
11. Logics for PTIME 
11.1 Logics and Invariants 
First, we recall the definition of a logic C capturing a complexity class C and 
of C strongly capturing C. 
For a class K of structures we introduced the class K< of its ordered 
representations, 
K^ 
= 
{(^, <) I ^ G K, < an ordering of A}. 
In particular, if <i and <2 are orderings of A then 
(*) 
( A < i ) e i i : < 
iff 
(A<2)Gi^<. 
The logic L captures the complexity class C iff for every class K of ordered 
structures, 
K ^C 
iff 
K \?> axiomatizable in C 
And C strongly captures C iff for every class K of (not necessarily ordered) 
structures, 
K^ e C iff 
i^ is axiomatizable in £.^ 
Already several times we mentioned the following open question: Is there a 
logic strongly capturing PTIME? Below we present two examples of such 
logics which will turn out to be "unsatisfactory", thus leading to a sharper 
version of the question. 
Recall that a sentence (p of vocabulary T< = rU{<} (i.e., < ^ r) is order-
invariant in the finite if 
{A,<i)[=ip 
iff 
( A < 2 ) h v ^ 
holds for all (finite) r-structures A and orderings <i, <2 of A. 
By (*) above, if /f< = Mod((^) then ip is order-invariant in the finite. 
Exercise 11.1.1 For sufficiently rich r the set 
{^ G FO[T<] I if a sentence order-invariant in the finite} 
is not decidable and hence, not recursively enumerable. Hint: Let cr be a 
vocabulary such that 
{ip e FO[a] I ip a sentence unsatisfiable in the finite} 
^ Note that on the left side of the last two equivalences, K and K<^ are classes of 
ordered structures. This is an accordance with the conventions we agreed upon 
in Chapter 7, that only classes of ordered structures are considered as members 
of complexity classes. 

11.1 Logics and Invariants 
289 
is not decidable (cf. Trahtenbrot's Theorem 7.2.1). Let r := crU {P}, where 
P is a unary relation symbol, P ^ a. For a sentence ip G FO[cr] let ip^ be the 
FO[r<]-sentence 
ip^ 
:= 
(^ -^ 3x{''x is the <-minimal element" 
APx)). 
Then, ^^ is order-invariant in the finite iff V' A 3x3y x ^ y is unsatisfiable in 
the 
finite. 
D 
We present the promised examples. 
Example 11.1.2 Let Ci be the logic whose sentences of vocabulary r are 
the FO(IFF) [T<]-sentences, where the satisfaction relation A \=^'^ ^ for a 
r-structure A and an £i [r]-sentence if is defined by 
A[= '^ (p iff 
if is order-invariant in the finite and there is an 
ordering <^ on A such that {A, <^) \=^^^ cp 
(on the right side, (A, <^) \=^^^ ip means that {A^ <^) is a model of (p in 
the semantics of FO(IFP)). 
Let £2 be the logic whose sentences of vocabulary r are the FO(IFP)[r<]-
sentences order-invariant in the finite where now the satisfaction relation is 
defined by 
A 1=^^ (p iff 
there is an ordering <^ on A such that {A, <^) |=^^^ ip. 
As FO(IFP) captures PTIME, one easily verifies that both Ci and £2 strongly 
capture PTIME. However, both logics have unsatisfactory features: Concern-
ing JCI, in view of 11.1.1 there is no effective procedure assigning to every 
£1-sentence (p an algorithm that, given an ordered version of A, evaluates 
A\= (p in time polynomial in |m|. On the other hand, given an ^2-sentence 
(p, there is such an effective procedure. But now, using 11.1.1 again, we see 
that for sufficiently rich r the set of £2 [T]-sentences is not decidable. 
D 
None of the logics just considered satisfies at the same time that 
— the set of sentences is decidable 
— there is an effective procedure assigning to every ip a polynomially time-
bounded algorithm testing A\= y:). 
We incorporate both requirements in our notion of capturing given by the 
following definition.^ When speaking of complexity classes, we have in mind 
one of the concrete complexity classes considered so far, and we think of a 
logic JC as given - for any vocabulary r - by a set i2[r]o, the set of C-sentences 
of vocabulary r, and by a relation \=^''^ between r-structures and /^-sentences 
of vocabulary r, the C-satisfaction relation for r. 
^ The reader may wonder why, say, in the second requirement we do not ask for a 
polynomial time procedure instead of an effective procedure. In fact, there is no 
real difference: By standard techniques one can pass from a logic satisfying the 
weaker conditions to a logic satisfying the stronger ones. 

290 
11. Logics for PTIME 
Definition 11.1.3 Let £ be a logic and C a complexity class. C effectively 
strongly captures C, C =es C, if 
— C strongly captures C] 
— for every vocabulary r 
(i) C[T]O is a decidable set; 
(ii) there is an effective procedure that to every sentence ^ G JC[T]O assigns 
a pair (M, / ) , where M is a Turing machine that accepts Mod((/?)< and 
/ is (the code of) a function witnessing that M is resource-bounded 
according to C.^ 
D 
In all concrete cases considered in Chapter 7 we have implicitly proved 
that the logics and the corresponding complexity classes satisfy the effectivity 
conditions (i) and (ii). For example, the proof of 7.4.2(a) yields a procedure 
that to every ip G FO(IFP)[T<] assigns a pair {M,d) where M is an x^ time-
bounded deterministic Turing machine accepting the class of ordered models 
of (p. 
In the definition above we do not impose limitations on the syntax of 
a logic (besides (i)). For example, NPTIME is not only effectively strongly 
captured by the logic of E J-sentences, but also by the logic C with 
— JC[T]O := 
{{M,d) \ d>l 
and M is a nondeterministic Turing 
machine for ordered representations of r-structures} 
— for every (p = {M, d) e C[T]O and every r-structure A, 
A\^ 
(f if^ M accepts some ordered representation of v4 in < \\A\\^ steps. 
This logic is very artificial and lacks the logical fiavour we are accustomed 
to. Moreover, it is tied up so closely with the definition of NPTIME that 
the characterization of NPTIME in terms of this logic does not give us any 
additional insight. We shall show in 12.3.17 that in case PTIME is effectively 
strongly captured by any logic at all, it can already be captured by a logic 
with a familiar syntax. 
Altogether, we reformulate our main question as 
(*) 
Is there a logic effectively strongly capturing PTIME? 
In the remainder of this section we study the relationship of (*) with other 
problems, thereby presenting methods and results that may be of help in 
getting an answer. 
Proposition 11.1.4 If the answer to (*) is "no" then PTIME / NPTIME. 
^ To be definite, in case C G {LOGSPACE, NLOGSPACE, PSPACE} we code / 
by a natural number d meaning that M is d- log space-bounded or (for PSPACE) 
x'^ space-bounded; in case C G {PTIME, NPTIME} we also code / by a number 
d meaning that M is x^ time-bounded. 

11.1 Logics and Invariants 
291 
Proof. There seems to be a very short proof: Assume PTIME = NPTIME. 
Since Ej =es NPTIME, we have S} =es PTIME. However, this argument 
has a gap: By Sj =es NPTIME we know that, given r, there is an effective 
procedure assigning to every SJ [r]-sentence 99 a number d > 1 and a non-
deterministic x^ time-bounded Turing machine M accepting Mod((/9)<. But 
how do we get a deterministic machine effectively? 
To close this gap one shows, using an NPTIME-complete problem, that 
PTIME = NPTIME implies an effective version of PTIME = NPTIME. 
More precisely: Let SAT be the set of satisfiable propositional formulas in 
conjunctive normal form. SAT is NPTIME-complete (cf. [87]). Even more: 
There is a polynomial time algorithm ^0 that assigns to every d > 1, every 
nondeterministic x^ time-bounded Turing machine M, and every input string 
ti for M a propositional formula a{u, (M, d)) in conjunctive normal form such 
that 
{+) 
M accepts u 
iff 
a{u, (M, d)) G SAT. 
Assume PTIME = NPTIME and let Ai be a deterministic polynomially 
time-bounded algorithm for SAT. By (-f), using the algorithms AQ and Ai 
and time bounds for them, one can effectively assign to every d > 1 and 
nondeterministic x^ time-bounded M a number d' > 1 and a deterministic 
x^ time-bounded algorithm accepting the same language as M. 
D 
When defining the logics in Example 11.1.2, we essentially restricted our-
selves to sentences order-invariant in the finite to ensure that the model 
classes Mod^^{(p) and Mod^^{ip) belong to PTIME. We could have dis-
pensed with this restriction if there would exist a PTIME-algorithm defining 
a "canonical" ordered version of every structure. Proposition 11.1.6 contains 
the precise statement and the following Definition 11.1.5 gives the precise 
notion. 
Denote by Str and Str[r] the class of all finite structures and of all finite 
r-structures, respectively. 
Definition 11.1.5 A FTIME-canonization 
C consists of functions 
Cr : Str[r] ^ Str[T<] 
for every vocabulary r such that: 
(1) For all A G Str[r], {A = Cr{A)\T and <^-(^) is an ordering).^ 
(2) For all A,B e Str[r], A ^8 
implies Cr{A) ^ Cr{B). 
(3) Cr is PTIME-computable, more precisely: there is a PTIME-algorithm 
that, applied to {A^<^) G Str[r]<, gives (the encoding of) the ordered 
structure Cr{A). ^ 
D 
^ Recall that CT{A)\T denotes the r-reduct of 
CT{A). 
^ In Chapter 7 we agreed upon how to regard ordered structures as inputs to a 
Turing machine M. By those conventions it is clear that for isomorphic (^4, <'^) 

292 
11. Logics for PTIME 
Clearly, in view of (1), condition (2) is equivalent to 
(2') Forall^,^GStr[r], A^8 
iE 
CriA)^Cr{B). 
Proposition 11.1.6 // there exists a FTIME-canonization 
then there is a 
logic effectively strongly capturing PTIME. 
Proof. Let C be a PTIME-canonization. Consider the logic C whose sentences 
of vocabulary r are the FO(IFP)[r<]-sentences. The satisfaction relation is 
defined by 
(*) 
A^^^^^ 
iff 
Cr{A)^^^^ip. 
C effectively strongly captures PTIME: Clearly, the set of £[r]-sentences 
is decidable. From Chapter 7 we know that there is an effective procedure 
assigning to every FO(IFP)[T<]-sentence cp a pair (Mo,(io), where MQ is an 
x^° time-bounded Turing machine accepting the class of ordered models of (p. 
Therefore, using a PTIME algorithm for Cr, the equivalence (*) shows that 
one effectively can assign to every £[r]-sentence ip a pair (M,d), where M 
is an x^ time-bounded Turing machine accepting Mod ((/?)<. In particular, 
Mod^((p)< is in PTIME. 
Conversely, if ii^ is a class of r-structures with i^< G PTIME, then i^< = 
Mod^^^^^^^ip) 
for some FO(IFP)[T<]-sentence (p. But then, K = Mod^{ip). 
D 
For an ordered r<-structure A, let A'^ be its numerical representation, i.e., 
A'^ is the unique T<-structure isomorphic to A with A+ = {0,...,|m| — 1} 
and with <-^ 
the natural ordering on A^. Assume that C is a PTIME-
canonization. By passing to {Cr{A))'^, one sees that (2) (compare (2'), too) 
in the definition of PTIME-canonization can be replaced by 
For all A,Be 
Str[r], 
A^B 
lE Cr{A) = Cr{B). 
The structures {Cr{A))'^ can be coded in a canonical way, say, by words over 
the alphabet {0,1}. Thus, a canonization leads to an "invariantization", i.e., 
to a map associating with every structure A a word only depending on the 
isomorphism type of A. Again, we give a precise definition and statement. 
Definition 11.1.7 A PTIME-invariantization 
I consists of functions 
Ir : Str(r) ^ {0,1}* 
such that for every vocabulary r we have: 
and {13,<^) the result of M applied to (^4, <'^) is the same as that of M applied 
to {8, <^). Therefore, if CT is computable then 
A = B implies 
Cr (A) ^ Cr (B). 
Thus, in the above definition, property (2) is redundant. Nevertheless, here and 
in the following, we stay with such redundancies in order to emphasize both the 
structural and the computational aspects of such functions. 

11.1 Logics and Invariants 
293 
(1) For all A,8e 
Str[r], 
^ ^ ^ iff Ir{A) = Ir{B). 
(2) Ir is PTIME-computable (more precisely: there is a PTIME-algorithm 
that, applied to {A, <^) G Str[r]<, gives the word Ir{A)). 
Proposition 11.1.8 // there is a VTIME-canonization, 
then there is a 
FTlME-invariantization. 
Proof. If C is a PTIME-canonization, then let Ir{A) be the {0, l}-code of 
{Cr{A))~^. By the remarks above, I is a PTIME-invariantization. 
D 
It may be surprising that the converse of the preceding proposition is also 
true, that is, an "arbitrary" invariant already leads to a canonical ordering. 
Theorem 11.1.9 // there is a FTlME-invariantization, 
then there is a 
FTlME-canonization. 
Proof. Assume that I is a PTIME-invariantization. Let r be an arbitrary 
vocabulary and let < be a new binary relation symbol. Set a = r^. First, 
using Icr : Str(cr) -^ {0,1}*, for every r-structure A and every ordering -<^ 
on A, we stepwise define an ordering <^ on A. 
Fix A (with at least two elements) and an ordering -<^ on ^4. If a i , . . . , a/ 
are distinct elements of A, let 
[ai,...,az] 
:= 
{{auaj) \l <i < j <l} 
if / > 2 and [ai] :— {(ai.ai)}. We start the step by step construction of <^: 
Let wi be the first element in the lexicographic ordering of {0,1}* of the set 
{/,((AM))|aGA}. 
Among the a's with wi — I(T[{A, [a])), let ai be the -<^-first one. 
In the second step let W2 be the first element in 
{Ia{{A,[ai,a])) 
I aG 
A.ai^ai}. 
Among the a's with W2 = Ia{{A, [ai,a])) and a ^ ai, let a2 be the -<;^-first 
one. 
After n steps, where n := \\A\\, we have obtained ai,...,an with A = 
{ai,... ,an}. We set 
<^ 
:= 
[ai,...,an] 
and define C by setting 
Cr{A) 
:= the numerical representation of {A, <^). 
To see that C is a PTIME-canonization, we first observe that the transition 
from {A, -<^) to {A, <^) can effectively be performed in polynomial time. 

294 
11. Logics for PTIME 
Trivially, A = (^, <^)|r and hence, A = Cr{A)\T. Finally, suppose that 
B = A and ^ ^ is an ordering of B. Let < ^ = [bi,... ,bn\he the ordering given 
by the stepwise procedure above apphed to (B, -<^). Then, for / = 1,... ,n, 
(+) 
(A[ai,...,a,])-(5,[6i,...,6z]). 
For / = n this yields {A, <^) ^ {B, <^) and hence, Cr{A) = Cr{B). 
The proof of (+) proceeds by induction on /. We show the case / = 1: 
Suppose TT : A = B. Then, for all a e A, 
7r:(AW) = (B,[7r(a)]). 
Thus, by property (1) of the invariantization I, 
{/,((AW))l«e^} = 
{hmm\beB}, 
and hence, Ia{{A,[ai])) = Ia{(B,[bi])). Again by property (1), we therefore 
have(A[ai]) = (5,[6i]). 
D 
Together with 11.1.6 the theorem yields: 
Corollary 11.1.10 // there is a FTlME-invariantization, 
then there is a 
logic effectively strongly capturing PTIME. 
D 
Of course, the notion of canonization can be defined for any deterministic 
complexity class C: A C-canonization C consists of functions Cr '• Str[T] -^ 
Str[r<] satisfying (1), (2) of Definition 11.1.5 and 
(3) Cr is C-computable (more precisely: there is an algorithm according to 
C that, applied to (^, <'^) € Str[T]<, gives (the encoding of) the ordered 
structure Cr{A)). ^ 
Exercise 11.1.11 Generalizing the proof of 11.1.6 show: If there are a C-
canonization and a logic effectively strongly capturing C on ordered structures 
then there is a logic C with C =es C- 
D 
Exercise 11.1.12 Show the existence of a PSPACE-canonization. Hint: 
Given a r-structure A^ let Cr{A) be the numerical representation of (^, <), 
where < is a minimal order on A (compare 8.5.13). 
D 
We conclude with some remarks that shed still further light on the main 
question. 
Suppose there is a logic C effectively strongly capturing the complexity 
class C. Then, given r, we can effectively enumerate the i2[T]-sentences. Using 
the effective transition from sentences (^ to pairs (M, / ) , where M is a Turing 
machine accepting Mod((/?)< and / a resource bound of M according to C, 
we get that C is effectively enumerable in the sense of the following 
^ For C = LOGSPACE this means that Cr is computable by a log space-bounded 
transducer, cf. section 7.5.1. 

11.2 PTIME on Classes of Structures 
295 
Definition 11.1.13 Let C be a complexity class. An effective enumeration 
F of C consists of computable functions Fr, r a, vocabulary, that are defined 
on the set N of natural numbers, with the properties 
(1) For any i G N, Fr{i) is a pair {M,f) 
where M is a Turing machine ac-
cepting a class i^< with K C Str[r], and / witnesses that M is according 
toC. 
(2) For any class K C Str[r] such that K^ is in C, there is an i with Fr{i) = 
(M, /) such that the machine M accepts i^<. 
D 
By the remark preceding the definition we have the direction from (i) to 
(ii) of 
Proposition 11.1.14 For a complexity class C, the following are equivalent: 
(i) There is a logic effectively strongly capturing C. 
(ii) There is an effective enumeration of C. 
Proof. We have to show that (ii) implies (i). Let F be an effective enumeration 
of C. First assume that, for all r, the set {Fr{i) \ i G N} is decidable. Define 
the logic C as follows. The set of £[T]-sentences is {Fr{i) | i G N}. And if 
Fr{i) — {M,f) where M accepts the class iC<, then 
A^'^Frd) 
iff 
AeK. 
Hence, JC =es C. 
Otherwise, we replace F by an enumeration F* such that, for all r, the set 
{F;{i) I i G N} is decidable. We define F;(i) as follows. Let F^(i) = 
(MJ). 
Set F*{i) — {M*,f), 
where M* behaves the same way as M, however, the 
length of (the coding of) M* is greater than i; this is achieved, say, by adding 
to M i-many new instructions that never will be used. To decide whether a 
pair (M', /') belongs to {F*{i) | i G N}, we check whether (M', /') coincides 
with some F*{i) for 1 < z < length of M'. 
D 
By the proposition, the complexity classes above PTIME such as NPTIME 
or PSPACE are effectively enumerable. If we view an effective enumeration 
as providing a tool for a systematic exploration of the complexity class con-
cerned, NPTIME and PSPACE are explorable in this sense, whereas it is 
open whether PTIME or its subclasses LOGSPACE and NLOGSPACE are 
explorable. 
11.2 PTIME on Classes of Structures 
We have already remarked that the question ("main question") whether there 
is a logic effectively strongly capturing PTIME, has a positive answer if we 
restrict ourselves to ordered structures, FO(IFP) being such a logic. We may 

296 
11. Logics for PTIME 
consider this result as a partial answer to the main question and, thus, are 
led to a more systematic study of such restrictions. In the following we show, 
for example, that the main question is equivalent to the question whether 
there is a logic effectively strongly capturing the PTIME properties on the 
class GRAPH of graphs. Moreover, we shall see that for certain subclasses of 
GRAPH such as the class of trees the corresponding question has a positive 
answer. 
If 5 is a class of structures, S C Str, and r a vocabulary, let S[T] :— {A G 
5 I ^ a r-structure}. 
Definition 11.2.1 Let £ be a logic, C a complexity class, and S a class of 
structures, S C Str. C effectively 
strongly captures C on S, C =es C on S, if 
for all T 
(1) JC[T]O is decidable; 
(2) {K n S[T] I K C Str[r], K^eC} 
= {Uod^{ip) 
f] S[T] \ ip G /:[r]o};^ 
(3) there is an effective procedure that to every ip G C'[T\Q assigns a pair 
{M,f), 
where / is a function witnessing that M is resource-bounded 
according to C and where for every {A, <) G «S[r]< the machine M accepts 
{A, <)iSA[=-ifi. 
D 
Clearly, if S and S' are classes of structures with S C S' C Str and if JC =es C 
on S", then JC =es C on S. 
In many concrete situations we have 5'[T]< G C. Then, condition (2) of the 
previous definition can be simplified: 
Proposition 11.2.2 Let C be a logic, C a complexity 
class and S a class of 
structures 
with «S'[r]< G C for all r. 
(a) If C is a logic that for all r satisfies (1),(3) of Definition 
11.2.1 and 
(2*) for all K C 
S[T], 
K<: eC 
iff 
there is ^ e C[r\o such that K = Mod^ ((/?), 
then C =es C on S. 
(b) Let C be a logic such that JC =es C on S. Define the logic C by 
C'[T]Q = C[T]Q 
and 
{A h ^ ' 
^ 
iff 
{A 
^^ 
if and 
A e 
S[T])). 
Then CJ =es ^ on S, too; moreover, CJ satisfies (2*). 
The proof is left as an exercise. 
D 
To get a first example we restate a result of Chapter 7: 
Proposition 11.2.3 (a) FO(DTC) =es LOGSPACE on the class of ordered 
structures. 
^ Readers familiar with set theory will apologize our use of classes of classes. 

11.2 PTIME on Classes of Structures 
297 
(b) FO(IFP) =es PTIME on the class of ordered structures. 
Proof, (a) Let <e T and let 0[T] be the class of ordered r-structures (-< 
being the ordering). Since 0[T]< € LOGSPACE and FO(DTC) satisfies the 
effectivity conditions (1), (3) of Definition 11.2.1, it suffices to show that 
FO(DTC) satisfies (2*) of part (a) of the preceding proposition. Clearly, for 
K C 0[T] we have (arguing as for Proposition 7.5.13), 
K e LOGSPACE 
iff 
K< e LOGSPACE 
and therefore, 
i^< G LOGSPACE 
iff 
there is an FO(DTC)[T]-sentence cp 
such that K = Mod ((/?). 
The proof of (b) is similar. 
D 
We now turn to the class GRAPH of finite graphs and prove that the 
main question is equivalent to its restriction to GRAPH. The reason is that 
any structure can feasibly be coded (interpreted) into a graph. We give the 
exact notion of interpretation. 
Fix vocabularies a and r where a = {Ri,... 
,Rs} with n-ary Ri.^ An 
(s + l)-tuple 
n 
:= 
{7runi{x),nR^ (^i,... , ^ ^ J , . . . , TTR^ {xi,... 
,^rj) 
of £[T]-formulas (with free variables among the displayed ones), where for 
some A; > 1 all tuples x,xi,... 
have length k, is called an JC-interpretation of 
a in T of width k. 
Given a r-structure A^ an ^-interpretation H of cr in r induces a a-
structure A^ over A:-tuples of A^ provided 7r;;[J^-(_) is nonempty; the case 
^uni(-) — ^ plays a marginal role for our considerations and will be neglected. 
The structure Ai^ has universe 7r{^-(_), the interpretation of Ri is given by 
TT^, (_,...,_ )nKl,i(_)r. 
For better reading we often suppress the intersection with the corresponding 
power of the universe and succinctly write 
^" = (^li(-),<(-,...,-),...,<(-,...,-)). 
Exercise 11.2.4 Let £ be one of the logics FO, FO(DTC), FO(TC), FO(IFP)^ 
FO(PFP), L^^, or SO and let H be an ^-interpretation of a in r. Show that 
for every £ [a]-sentence ip there is an >C[r]-sentence -0"^ such that for all 
r-structures A (with 7r{^i(_) ^ 0), 
A \= ^ - n 
iff 
A^ h ^. 
Check whether your proof works for MSO, too. If "yes", it is incorrect. 
D 
^ For simplicity, we restrict ourselves to relational a. It should be clear how the 
notion of interpretation can be extended to vocabularies cr containing constants. 

298 
11. Logics for PTIME 
With the following proposition we show that "up to FO-interpretations, 
structures can be viewed as graphs". 
Proposition 11.2.5 Let r he a vocabulary. There are YO-interpretations 11 
of {E} in T and A of r in {E} with the following properties: 
(i) For all r-structures A with at least two elements, A^ G GRAPH and 
(ii) 
ForallKCStT[T], 
K< e PTIME 
iff 
{K^)< e PTIME, 
where K^ := {B \ B ^ A^ for some 
AeK}. 
Proof. We treat the case r = {T, R} with unary T and binary R. From the 
exposition it will be clear how to handle relation symbols of higher arity. 
To get an idea of how to define II, we first code a given r-structure A as 
a graph Q as follows: 
— Each a e A is a. vertex in Q; 
— each a G A has two new vertices ai, a2 linked to it; 
— each a G T^ is linked to each element of a clique of two new elements; 
— for each (a, b) G i?^, a is linked to one element and b to the remaining two 
elements of a clique of three new elements. 
The following picture shows Q in case A = {a,b}, T^ = {a}, and i?^ = 
{(a,6)}. 
Obviously, Q contains all the data of A. As Q has more elements than A, 
any interpretation II such that A^ = Q has to have a width k > 2. Then 
(a,..., a) G A^ can be the vertex of Q corresponding to a e A. But, what 
elements of A^ may serve as "legs" ai and a2 attached to a? In general, for 
arbitrary A there is no way to uniquely define two such elements for every 
a £ A. Thus, we replace each leg of a as well as every other auxiliary point 
attached to a via T or i? by all elements of the set Aa := {b e A \ b ^ a} 

11.2 PTIME on Classes of Structures 
299 
(as A has at least two elements, Aa is nonempty). Altogether, we are led to 
the following modification H oiQ. We set fc = 9 and let H contain, for every 
a, 6 G ^ , the following points: 
(1) the point a^ (:=(a,... ,a)); 
(2) the points of a^Aatt^ (:= {{a.a^c^a^... 
,a) \ce 
A,c^ 
a}) and of a^Aaa^; 
(3) if T^a^ then the points of a^AaO^ and of a^AaO^] 
(4) if R^ab, then the points of aba'^AaO^, of aba^Aaa, and of aba^Aa. 
Define the edge relation E^ 
as follows: 
— for a G A, connect the points in (2) with a^ 
— for a G A with T'^a and for c ^ Aa, link a'^ca'^ and a^ca^ to a^ and to each 
other 
— for a, 6 G A with R^ab and for c £ Aa, form a clique out of aba^co?, aba^ca, 
and aba^c, and link aba^co? to a^ and aba^ca and aba^c to b^. 
Let n = (7r^ni{x),7rE{x,y)) 
with x,y of length 9 be the interpretation of {E} 
in T that describes this encoding. For instance, set 
7runi(^) 
:= 
a;i = X2 = . . . = 0:9 
V(xi = X2 = X4 =^ . . . = Xg A X3 ^ Xi) 
V(zi = X2 — Xs = X^ = . . . = XQ A X4 ^ Xi) 
\/{Txi 
A Xi = ... = X4 = XQ = ... = XQ A Xs y^ xi) 
\/{Txi 
A xi = ... = x^ = X7 = xs = XQ A XQ ^ 
xi) 
V.... 
Then we have A^ G GRAPH. 
We now define an FO-interpretation A of r in {£^} of width 1 that allows to 
regain the structure A in A^, more precisely: (A^)^ 
= A for all r-structures 
A with at least two elements. 
In view of the definition of 11 this is achieved by setting 
^uni(a:) 
:= 
"a; has (at least) two legs" (2/ is a leg of x, 
if y is only linked to x) 
Srix) 
:= 
"there are two elements which are linked to x and 
to each other and to no other point" 
SR{X, y) 
:— 
"there are three points u, v, w such that u is linked to x 
and v,w are linked to y, to u, and to each other, 
and u,v,w 
are not linked to other points". 
We now come to part (ii). In the argumentation we tacitly assume that the 
r-structures in question have at least two elements. (The remaining finitely 
many cases have to be treated separately.) First, we show that (Str[r]^)< is 
in PTIME. Namely, given an {£^}-structure B, in polynomial time we can 
check whether 

300 
11. Logics for PTIME 
— B is a. graph 
— all points with legs ("domain points") have the same number of legs, this 
number being equal to twice the number of domain points minus two 
— all other points are linked to exactly one domain point and the set of these 
points correctly codes relations T and R. 
Now, let K C Str[r]. Assume that K^ G PTIME. Given an ordered {E}-
structure (B, <), check whether {B, <) G (Str[T]n)<. If not, (B, <) ^ {K^)<-
Otherwise, let B = A^ for some r-structure A. Using A, construct the r-
structure B^ in time polynomial in \\B\\. By part (i) of our proposition, 
^A ^ (^n^A ^ ^ Let < ^ be the ordering induced on B^ by <. Then, 
(5,<)G(i^n)< 
iff (B^,<^)Gi^<. 
In fact, if (H^,<^) G K^ then ^ G iiT and hence, {A^ ^) B e K^ and 
(^,<) G {K^)<. 
Conversely, if (B, <) G {K^)<: then B ^ Af for some 
AieK 
and hence, B^ ^ Ai and (B^, <^) G i^<. 
By assumption, the right hand side can be checked in time polynomial in 
11^^II and hence, in time polynomial in ||B||. Altogether, the left hand side 
can be checked in time polynomial in ||-B||. 
For the other direction assume that {K^)<: G PTIME and let (^, <) 
be an ordered r<-structure. We can construct A^ and, restricting the <-
lexicographic ordering of tuples to A^, an ordering <^ on A^ in time poly-
nomial in |m|. Since, by (i), 
{A,<)eK^ 
iff 
iA^,<'')eiK^)< 
and (i^^)< G PTIME by assumption, we altogether can decide the left hand 
side in time polynomial in ||^||. 
D 
Now we are able to reduce the problem whether there is a logic JC with 
JC =es PTIME to the class of graphs. 
Theorem 11.2.6 If there is a logic that effectively strongly captures PTIME 
on GRAPH then there is a logic effectively strongly capturing PTIME. 
Proof. Choose a logic CQ with CQ =es PTIME on GRAPH. Define the logic 
JC as follows. For every vocabulary r let £[r] = C[T]O be the set of sentences 
of £ G [ { ^ } ] . For a r-structure A and (/? G C[r] define 
(*) 
A^^ip 
iff 
A^ \=^^ ^ 
(here H is the interpretation of {E} in r as given by Proposition 11.2.5). We 
claim that C =es PTIME. 
Firstly, JC strongly captures PTIME: Assume K C Str[T]. We have to 
show that 
K^ G PTIME iff for some ip G C[T],K 
= Mod^((/?) 

11.2 PTIME on Classes of Structures 
301 
or, by Proposition 11.2.5(ii), that 
{K^)< e PTIME 
iff 
for some (p G ^[T], K = Mod^(ip). 
If {K^)< e PTIME, then K^ = Mod^«((/p) for some ip G CG[{E}], 
since 
CG =es PTIME. Therefore, by (*), K = Mod^((/?). Conversely, assume K = 
Mod^{cp) for some (p G JC[T]. Then, K^ = Mod^^ ((p) fl Str[r]n and therefore, 
(ii:")< = Mod^^ ((/?)< n (Str[r]")<. Both classes on the right hand side are in 
PTIME (the first one, as CG =es PTIME, the second one again by 11.2.5(ii)). 
Thus, (K^)< G PTIME. 
Let r be given. Of course, JC[T] is recursive. Moreover, since CG =es 
PTIME, we effectively can assign to (/? G C[T] a pair {M^,d), where M<p 
is a deterministic x^ time-bounded machine accepting M o d ^ ((/?)<. To check 
whether a structure {A, <) G Str(T)< is in Mod^((p)<, by a polynomial time 
algorithm we pass to {A^, <^) (where <^ is the lexicographic ordering on A^ 
induced by <) and then use M^ to decide whether {A^, <") G Mod^^((yc)<, 
and hence, by (*), whether (v4, <) G Mod ((/?)<• Clearly, we can effectively 
calculate a time bound. 
Altogether, we have C =es PTIME. 
D 
Further notions and results of the preceding section can be restricted to 
classes of structures, too. E.g., let r be a vocabulary and S a class of r-
structures and C a deterministic complexity class. A map Cr : Str[r] —> 
Str[r<] is a C-canonization on 5, if 
(1) For all ^ G 5, A^ 
Cr{A)\T and <^-(^) is an ordering. 
(2) For all A,B e Str[r], ifA^B 
then Cr{A) ^ Cr{B). 
(3) CT is C-computable, more precisely: there is a PTIME-algorithm that, 
applied to (v4, <'^) G Str[r]<, gives (the encoding of an ordered version 
of) Cr(A). 
Analogously, one defines the notion of C-invariantization. The proof of 11.1.8 
showing that PTIME-invariantizations yield PTIME-canonizations, in gen-
eral, does not work in the restricted case as it uses PTIME-invariantizations 
for structures with a larger vocabulary. However, in the case of GRAPH one 
can settle this diflficulty by interpreting the expanded structures in graphs: 
Exercise 11.2.7 (a) If there is a PTIME-canonization on GRAPH, then 
there is a PTIME-canonization. 
(b) If there is a PTIME-invariantization on GRAPH, then there is a PTIME-
invariantization. 
D 
Exercise 11.2.8 Let r be a vocabulary and 5* a class of r-structures. Show: 
If there is a PTIME-canonization on S then there is a logic C such that 
C =p. PTIME on S. 
D 

302 
11. Logics for PTIME 
We now come to some positive results and start with a simple observation. 
We saw that the capturing result for PTIME proven in Chapter 7 can be 
reformulated as 
FO(IFP) effectively strongly captures PTIME on the class of ordered 
structures. 
This can easily be generalized to 
Proposition 11.2.9 Let S C Str[T]. Assume that there is an FO(IFP)[r]-
formula ip{x,y,J) 
with free variables among x,y,^ 
such that for all A ^ S 
there are b £ A such that (p"^(_,_ ,6) is an ordering of A. Then, FO(IFP) =es 
PTIME on 5. 
Proof. We first treat the case without parameters. The idea is to use the 
result just quoted, letting (p{x,y) play the role oi x < y. More explicitly: If 
K^ G PTIME then K< = Mod(ip) for some sentence ^ e FO(IFP)[T<]. 
But then, for the FO(IFP)[r]-sentence ^^_^"-'-^ we have that K n S =^ 
Mod(^^^"-;--;^) n S. Conversely, if v? is an FO(IFP)[r]-sentence and K := 
Mod(v?), then we have K< G PTIME and trivially, K 0 S = Mod{(p) n S. 
For the general case one replaces the formula ^'^(—-'•••) by the formula 
ip( 
,...,y) 
<.. 
3y((y?(_,_ ,?/) is an ordering Aip^—':"'^^). 
D 
—< 
The following two exercises contain some applications and generalizations 
of the preceding proposition. 
Exercise 11.2.10 (a) Show that FO(IFP) =es PTIME on the class of cycles. 
Remember that a cycle is a graph that is isomorphic to some Qi (cf. 2.3.8). 
Hint: Note that there is a formula (p{x,y,u,v) 
in FO(IFP)[{^}] such that 
for any cycle Q and all a,b e G with E^ab, the relation (p^(_,_ ,a, 6) is an 
ordering of G. 
(b) A finite grid is a graph isomorphic to 
({0,... ,n}x{0,... ,m}, {((i,i), (fc,/)) \i,k<n,jj< 
m, |i-A:| + | i - / | = 1}) 
for some n,m. Show that FO(IFP) =es PTIME on the class of grids. 
D 
Note that in the situation given by the hypotheses of Proposition 11.2.9 
we have, using the notations of its proof, that Or '• Strfr] -^ Str[r<] with 
Cr{A) 
:= 
(A^^^i-,-)) 
is a PTIME-canonization on 5. Moreover, Cr{A) = A^ for the FO(IFP)-
interpretation 11 of T< in r given by 7runi(a:^) := x = x, 7r<^{x,y) := ip{x,y), 
and 7rR{x) := Rx for i? G r. The proof of 11.2.9 contains the main argument 
needed to show the following exercise: 

11.2 PTIME on Classes of Structures 
303 
Exercise 11.2.11 Let C be one of the logics mentioned in 11.2.4 and C a 
deterministic complexity class with C =es ^ on ordered structures. Assume 
that 5 is a class of r-structures and Cr a C-canonization on S given by an 
/^-interpretation of T< in r (in the form CT '• A^^ J^^. Then L =es C on 5. 
D 
Example 11.2.12 Let KQ be the class of r := {£^}-structures isomorphic to 
some 'Hi with / > 3, where 1-ii is a digraph as pictured by 
There is no formula that defines an ordering on all the structures in i^o, even if 
parameters are allowed. In fact, consider a formula (/?(x, ?/, 2:1,..., 2;^) and the 
digraph 'H/ for / > n + 1 . Then, for any choice of parameters di,..., c^^, there 
are corresponding elements 6, c of in-degree 1 (cf. the figure) not occurring 
among di,..., d^- There is an automorphism of Hi that fixes c?i,..., d^ and 
interchanges 6 and c. Hence, 
.n 
Ui 
(6,c)Gv^^'(_,_,d) 
iff 
(c,6)G(/9^'(_,-,d); 
.Ui 
so ^"-^ (^_,_ ,d) is not an ordering onTii. 
Thus, we cannot apply 11.2.9 to conclude FO(IFP) =es PTIME on J^o- We 
obtain this result from the preceding exercise showing that there is a "defin-
able" LOGSPACE-canonization. In fact, there is an FO(DTC)-interpretation 
n := (7runi,7r£;,7r<) of a := {E, <} in r (= {E}) assigning to the digraph 7ii 
the ordered digraph y,Y consisting of the isomorphic copy of Tii 
{ai,a2) 
(^2,^2) 
(^3,^2^ 
(az,ai) 
{ai,as) 
(^2,^3) 
(03,^3) 
together with the ordering indicated by 
(ai,ai) < (ai,a2) < (01,03) < (02,ai) < (02,02) < ... < (o/,oi). 
To define 11, for z = 1,2,3 let (pi{x) be a formula defining the i-th "cross-
point" of Hi, 

304 
11. Logics for PTIME 
(fi{x) 
= 
\fy^Eyx 
= 
3z{ipi (z) A 3y{Ezy A Eyx)) 
= 
3z{(p2{z) A 3y{Ezy A Eyx)). 
Then, for example, set 
TTnniix.y) := {3='^zExz A {ipi{y) W (p2{y) ^ ^siv)) "^ O^z-^Exz A (fi(y)). 
Using the preceding exercise we conclude that FO(IFP) =es PTIME on KQ 
and that FO(DTC) =es LOGSPACE on i^o- 
• 
We turn to the class of trees. For this purpose we first state and prove a varia-
tion of the preceding exercise for fixed-point logic with counting, FO(IFP, #) 
(cf. subsection 8.4.1). 
Proposition 11.2.13 Let r = {Ri,...,Rm} 
with ri-ary Ri and let S 
he a class of r-structures. 
Assume that there are FO(IFP, if)[T]-formulas 
V^I(A*I), • • •, ^mi'Prn) inhere JI^ is a sequence of number variables of length ri) 
such that for every A^ 
S, 
(*) 
^ = ({o,...,p||-i},v^5'(-),---,^;^(-))' 
Then, 
FO(IFP, #) =es PTIME on S. 
Proof. First, we observe that the map Cr '• Str[r] -^ Str[r<] given by 
Cr{A) 
:= 
{{Q,...,\\A\\-\],^t(-),---,vt{-).<) 
(with < the natural ordering on {0,..., ||A|| — 1}) is a PTIME-canonization 
on 5. 
Let V^ be an FO(IFP)[T<]-sentence. For every point variable x we choose 
a number variable ii^ (with fix 7^ A*y for x ^ y)^ and we let ip* be the 
FO(IFP, #)[r]-sentence that arises from ^ by replacing every subformula 
RiXi .. .Xn by (pidixi, • • • ^l^Xr,)^ by replacing every variable x by ^Xx in all 
other atomic formulas, and by changing every subformula Va;... to "i^ixil^x < 
max -^ ...) and every subformula 3x... 
to 3iix{iJix < max A...). Then we 
have for every r-structure A: 
A[=^P* iff 
Cr{A)\=^. 
It remains to show that 
{KnSlKC 
Str[T], K< e PTIME} 
= 
{Mod{ip) n S \ if e FO(IFP, #)}. 
^ Note that {0,..., ||A||} is the universe of the number part of A., thus, instead of 
iffi-) 
we should write ipf(-) n {0,..., ||A|| - 
ly. 

11.2 PTIME on Classes of Structures 
305 
If ^ is an FO(IFP, #)[r]-sentence and K = Mod{(p), then K< G PTIME 
and clearly, K D S = Mod{(f) fl S. Conversely, assume K C Str[r] and K<^ G 
PTIME. Then K< = Mod(^) for some FO(IFP)[T<]-sentence ^. We claim 
that KnS 
= Mod{ip*) H S. In fact, for Ae 
S, 
^ G K 
iff 
Cr{A)eK^ 
( a s ^ ^ C ^ ( ^ ) l r ) 
iff 
Cr(A)^^p 
iff 
A[= ip* (see above). 
D 
We apply the preceding result to the class TREE of finite trees (cf. Chapter 
l.Al). 
Theorem 11.2.14 FO(IFP, #) =es PTIME on TREE. 
In view of the preceding proposition it suffices to show: 
Lemma 11.2.15 There is a formula ip{/j,]u) in FO(IFP)[{^}] such that for 
all A G TREE, 
A = ({0,...,||A||-l},^-^(_,_)). 
Proof Let A G TREE. By induction going from the leafs to the root, for 
each ueAwe 
define a copy of the subtree Au of A with root u on (an initial 
segment of) the number part of A] the tree relation of the copy of Au will be 
given by Xu 
(X is a ternary mixed relation variable with first component 
for point variables, the last two components for number variables). The case 
of leaves u ^ A being trivial, let w G A have the ^^-successors vi,... 
,vi. By 
induction hypothesis, the trees Avi, • • •, Avi have isomorphic copies on initial 
segments of the number part of A given by Xvi 
,..., Xvi 
Using the 
ordering < of the number part, these copies can be ordered lexicographically 
in an FO-definable way by 
Xvi 
^ Xvj 
(for short : Vi -< Vj) iff ^^Xvi 
^ Xvj 
, 
and the minimal pair (/x, z^), minimal in the lexicographic ordering 
induced by <, where they differ belongs to Xvi 
". 
We abbreviate {^vi -< Vj A -^Vj -< vi) by Vi = Vj. If, for example, / = 4 and 
vi ^ V2 = vs ^ V4, we define the copy of Au on the number part of A by 
assigning 0 to w and let it be followed by a copy of Xvi 
, two copies of 
Xv2 
, and one copy of Xv4 
More precisely, in the general case we 
define 
Xu/iiy 
by the disjunction of the following formulas (pi, ^2 (v^i describes that the 
number 0 assigned to u is linked to the numbers assigned to the Vi; ip2 de-
scribes the copies associated with the subtrees Avi) • 
Using S{u,v) for the number term ij^{w \ 3v'{Euv' Av' ^ v Aw ^ Ay')} 
which counts the number of all elements in trees Av> of £^-successors v' of u 
that are ^ i', we set 

306 
11. Logics for PTIME 
^pi (u, /J,, ly, X) 
:= /J, = min A 3v{Euv A 3C(0 < C < # { ^ I Euw Aw = v} 
A1/ = 1 + S{u, v) + C' #{w \w e Av})); 
^2{u,fi,iy,X) 
:= 3v{Euv A 3C{0 < C < #{w \ Euw Aw =v} A 
3^3r]{Xvir] 
A// = ^ + l + (5('a,'i;) + C-#{^ I ^ e A } 
Ai/ = 77 + l + (5(w,f;) + C - # { ^ I ^^ e Av})))-
Note that, with WQ the root of A, 
XUQ 
defines a copy of A. 
According to Lemma 7.3.11, addition and multipHcation on the num-
ber part of A are FO(IFP)-definable as is "w; G Av^^• Thus, the desired 
FO(IFP, #)[{^}]-formula %(//, i/), defining an isomorphic copy of A on its 
number part, can be given as 
X(AX, i^) := 3uo{uo is the root A [IFP^,^i,,x(^i V (/?2)]^0iWi/). 
D 
Exercise 11.2.16 (a) Show that FO(IFP, #) =es PTIME on the class of 
acyclic connected graphs. Hint: Each point of an acyclic connected graph can 
be viewed as the root of a corresponding tree. 
(b) Show that FO(IFP, #) =es PTIME on the class of acycHc graphs. 
D 
In 11.2.6 we have seen that, in order to obtain a logic JC with JC =es PTIME, 
it is enough to find a logic C such that £' =es PTIME on GRAPH. We then 
have seen that there are subclasses of GRAPH such as the class of acyclic 
graphs or the class of trees that can eff'ectively strongly be captured by a 
logic. Further positive results are contained in [65, 68] where it is shown, for 
example, that FO(IFP, #) =es PTIME on the class of planar graphs. These 
positive results may be interpreted as an approximation to a positive solution 
of the main question, if there should be a positive solution. If not, they might 
serve to discover the borderline where the possibility for an effective strong 
capturing gets lost. 
Notes 11.2.17 The main question whether there is a logic strongly captur-
ing PTIME was first asked in [19]. The notion of a logic effectively strongly 
capturing a complexity class originates with Gurevich [71]; Theorem 11.1.9 
is from [73]. The capturing result 11.2.14 goes back to [97, 117]. For further 
capturing results see [82] and the survey paper [66]. 

12. Quantifiers and Logical Reductions 
In Chapter 7 we have seen that the fixed-point logic FO(IFP) captures 
PTIME. In the last chapter we have remarked that the question 
(*) 
Is there a logic that effectively strongly captures PTIME? 
is still open. We have discussed strategies for a solution and thereby given 
some positive results in case we restrict ourselves to certain classes of struc-
tures. 
The notion of logic underlying the main question is very general. For 
instance, we have admitted that the sentences of a logic are Turing machines 
(and the models of a Turing machine are the structures it accepts). Thus, 
its syntax lacks the characteristic flavour of logics we are accustomed to. 
A corresponding positive answer to (*) could hardly be considered to be a 
logical characterization of PTIME. However, in the present chapter we shall 
show that if there is a logic that eflFectively strongly captures PTIME, then 
there is a logic with a familiar syntax. 
At a first glance the following idea could lead to such a logic: Consider, 
for example, FO(IFP). We know that there is some class K of structures such 
that K< belongs to PTIME, but K is not axiomatizable in FO(IFP). In a 
first step one could add a "logical construct" to FO(IFP) that allows for an 
axiomatization of K, and in this way one could continue trying to enlarge the 
expressive power just up to PTIME. In traditional model theory there is a 
well-established method to enrich logics by new concepts, namely by adjoining 
so-called Lindstrom quantifiers. We have already met such quantifiers, for 
example, the counting quantifiers (cf. section 3.4). 
In the first section we shall introduce the concept of Lindstrom quantifier 
and demonstrate its scope by various examples showing that some important 
logics encountered so far can be obtained as extensions of first-order logic 
by such quantifiers. In section 2 we prove some limiting results saying us, for 
example, that no extension of FO(IFP) by a finite set of Lindstrom quantifiers 
will strongly capture PTIME. Nevertheless, we shall see there that, if any 
reasonable logic strongly captures PTIME, then there is already such a logic 
that can be obtained from first-order logic by adding a simple infinite set of 
quantifiers. When pursuing this line also for other complexity classes such as 
NPTIME, a logical analogue of complexity-theoretical reductions turns out 
to be useful. Section 3 presents results of the corresponding kind. 

308 
12. Quantifiers and Logical Reductions 
If we extend a logic C by the binary Lindstrom quantifier Q where 
Qxy(^{x^y) says that ^(x,y) 
defines a connected graph on the universe, then 
in the extended logic C{Q) we can speak about the connectivity of defin-
able graphs by simply using the quantifier Q. There is a similarity to Turing 
machines with oracles that have the ability to supply, in one step, correct 
answers to the question whether a binary relation (encoded on some tape) is 
a connected graph. We shall see in the last section that this similarity is by 
no means superficial. 
Throughout the chapter all vocabularies are relational and structure means 
finite structure. 
12.1 Lindstrom Quantifiers 
For a binary relation symbol E we know that FO(TC), but not FO, allows 
to express 
(*) 
"(cc, 2/) is in the transitive closure of £J". 
What do we expect from any "natural" logic C allowing to formalize (*)? 
Clearly, for every formula (p{u,v) of C we want to have a formula in JC ex-
pressing 
"(a;,2/) is in the transitive closure of (p{-,- )". 
Similarly, in a natural logic JC which allows to express that a graph has a 
Hamiltonian path, we expect to be able to say that an ^-definable graph has 
a Hamiltonian path. If in the following definitions we take as K the class of 
graphs with a Hamiltonian path, we get a quantifier Q such that FO{Q) will 
be the smallest natural extension of FO having this ability. 
Fix a vocabulary 
c7={Ri,...,Rs} 
where Ri is r^-ary, and a class K of cr-structures. Furthermore, let C be some 
logic such as FO, FO(IFP), or Looo; • For a new "quantifier symbol" QK we 
enlarge, for any vocabulary r, the formation rules for i2[r]-formulas by the 
following clause: 
(-h) If for 1 < i < 8, xpi{xiy is di formula and the length of Xi is r^ then 
QKXI, 
.. .,^^[^'1(^1)5 • •. ,^s(^s)] 
is a formula, too. 
^ We only display the variables relevant in the given context. The variables in each 
Xi are pairwise distinct, but the same variable may occur in distinct Xj's. 

12.1 Lindstrom Quantifiers 
309 
In case s = 1 we write QXIIJ(X) instead of Qx[ip{x)]. A variable y is free in 
QKXI, ... ,Xs[if>iixi),... ,'ips{xs)] ifj for some i, we have y G fYee{ipi) and y 
not in Xi. 
For any r-structure A the meaning of QRXI,... 
,Xs[ipi{xi)^... 
,^ps(^s)] is 
given by (we suppress the assignment to variables) 
A \= QKXU. . .,Xs[Mxi),.. 
-,^s{xs)] 
iff 
(A, ipfi-),..., 
i^f(-)) 
e K 
where i>f{-) stands for (h e A""^ \ A\==^ ^iM}-
QK is the Lindstrom quantifier (by short: quantifier) given by K. Its arity 
is defined to be max{ri | 1 < i < s}. In case s = 1 one speaks of a simple 
quantifier. 
The extension of C by QK is denoted by C{QK)- 
If Q is a class of Lind-
strom quantifiers, the extension £(Q) of £ is defined by adding clause (+) 
for all Q G Q. i3(Q) is called a Lindstrom extension of C. 
Obviously, we have for all <7-structures A: 
A\=QKXI,...,XS[RIXI,...,RSXS\ 
iff 
A^K. 
Hence, K is axiomatizable in C{QK)- 
Indeed, C(QK) 
is the least extension 
of C that allows to axiomatize K. A proof requires some closure conditions 
of the logics involved. They are satisfied in the cases covered by the next 
exercise. As a rule, such closure conditions (cf. 12.1.11) will also be necessary 
in the following when dealing with statements on arbitrary logics and will be 
tacitly assumed. 
Exercise 12.1.1 Let Ci be a Lindstrom extension of FO and C2 one of the 
logics FO(TC), FO(DTC), FO(IFP), FO(PFP), or Looc^. Show: If £1 < A 
and the class K of structures is axiomatizable in £2 then CI{QK) 
< ^^2- 
n 
One can show that any logic C above FO that obeys the closure conditions 
referred to above, can be represented as a Lindstrom extension FO(Q) of FO, 
where the quantifiers in Q correspond to the classes axiomatizable in £, i.e., 
C = FO{{QK 
I K axiomatizable in C}). Of course, one is interested in small 
sets Q such that FO(Q) and C are equivalent. 
We give some examples of Lindstrom quantifiers. 
Examples 12.1.2 (a) Let a := {P} with unary P. For K := {{A,B) 
\ 
^ ^ B C A}, the simple unary quantifier QK corresponds to the existential 
quantifier, as QKXIP{X) is equivalent to 3xip[x). 
(b) Similarly, for K := {{A, A) \ A a nonempty set} we obtain the universal 
quantifier. 
(c) Forn > 1 and Kn := {{A, B) \ B C A amd \\B\\ > n} the quantifier QK„ 
corresponds to the quantifier 3-*^ (cf. section 3.4). 
(d) For the class CONN of connected graphs we get a simple binary quantifier 
QcoNN-So 

310 
12. Quantifiers and Logical Reductions 
is valid in a structure A iff (A,'0-^(_,_ )) is a connected graph. 
(e) Let a := {E,R} 
with binary relation symbols E and R. If iT is the class 
of cr-structures 
A = {{A,E^,R^) 
I R^ C TC(E^)}, 
then Qi^ can replace the unary transitive closure operator, as 
is equivalent to 
and 
is equivalent to 
QKXV, uv[ip{x, y),u = s Av = t], 
QKxy, uv[ipi {x, y), ^2 (w, v)] 
\/u\/v{ip2{u,v) -^ 
[TCx,y'ipi{x,y)]uv). 
Thus, FO(TCi) = FO(Qx). 
(f) Let K he 8i class of a-structures, < a new binary relation symbol, and C 
a logic. Then, 
^{QK<) 
= ^(QK) 
on ordered structures. 
In fact, if (J = {Ri,..., 
i?s} and ipi,... ,ips,ip are formulas in some vocabulary 
r that contains a binary relation symbol ^, then on ordered r-structures (that 
is, structures in which -< is an ordering) the formulas 
QKXI,. 
. .,Xs[(pi{xi),.. 
.,Lps{xs)] 
and 
QK<XI, ... ,Xs,xy[(pi{xi),... 
,(psixs),x ^ y] 
are equivalent, and the formulas 
QK^XI,..., 
Xs^xy^i(aPi),..., 
ips{xs),^p{x, y)] 
and 
"'0(a:,y) defines an ordering" A QRXI,... 
,Xs[(pi{xi),..., 
(ps{xs)] 
are equivalent. Conclude: If ^(Q) captures, say PTIME, then i^< G PTIME 
for all K such that QK ^Q- 
• 
Exercise 12.1.3 Let ii^ be a class such that X< G PTIME. Show that 
Mod(V^)< 6 PTIME for any sentence V^ G FO{IFF){QK)- 
The same is true 
for sets of such quantifiers. Give the corresponding statements for PSPACE 
and FO(PFP) and for LOGSPACE and FO(DTC). Hint: For LOGSPACE cf. 
Appendix 7.5.1. 
D 

12.1 Lindstrom Quantifiers 
311 
Finitely many Lindstrom quantifiers can be replaced by a single one. We 
give a precise statement in the next theorem. The following two technical re-
marks (1) and (2) will be useful for the proof. As above, let a = {i?i,... ^Rg} 
with rj-ary Ri and let if be a class of <j-structures. 
(1) For a new r-ary relation symbol R let Ki be the class of (7U{-R}-structures 
Ki 
:= 
{{A, R^)\AeK 
and i?^ = A"-}. 
Then C{QK) 
= ^{QKI), 
since 
Nfin Q K ^ I , . . - , ^ S [ V ^ I , . - - , ' 0 S ] ^ QK.XI, 
... ,Xs,x[tpi,... 
,il;s,x = x] 
and 
(2) Let r > maxjri | 1 < ^ < s} and let a' arise from cr by replacing 
each Ri by an r-ary relation symbol R[. Finally, let K' be the class of a'-
structures A' that we get from structures ^ in if by replacing each Rf by 
R'/^ := Rf X A'^~'^\ Using dummy variables, one easily shows that C{QK) = 
C{QK')-
Theorem 12.1.4 Let C be a logic. Furthermore, let Q be a finite set of 
Lindstrom quantifiers. Then there is a Lindstrom quantifier QK such that 
£(Q) = C{QK)' 
In particular, if the arities of the quantifiers in Q are < I, 
then QK can be chosen of arity I -\-l. 
Proof. Let Q be {QKJ | 1 < i < ^} where Kj is a class of <jj-structures. 
According to the preceding remarks we may assume that the aj have the 
same cardinality and that the QKJ are of the same arity I as are all relation 
symbols in the vocabularies aj. For simplicity of notation we treat the case 
of two simple binary quantifiers QKI and QK2' Let i? be a ternary relation 
symbol. If no structure of the form (A, 0) belongs to Ki or K2, we define the 
class K of {i?}-structures by 
K 
:= 
{(A,Bx{a})\{A,B)eKuaeA} 
U{{A,B 
X {a,b}) \{A,B) 
eK2,a,beA,a^ 
b}. 
Then the following formulas are equivalent on structures with at least two 
elements (structures of cardinality 1 can be taken into consideration explic-
itly): 
(1) QKiXy(p{x,y) 
and 3vQKxyz(ip{x,y) 
A z = v) 
(2) QK2xyy^{x,y) 
and 3v3w{v ^ w A QKxyz{ip{x, y) A {z = vV z = w))) 
(3) QKxyzij){x,y,z) 
and {3^'^z3x3yil){x,y,z) 
AQK^xy3zij){x,y,z)) 
V (3r'^z3x3yij:{x^ y, z) A yxy{3z'il){x, y, z) —)• 3^^z'0(rc, y, z)) 
AQK2xy3zip{x,y,z)). 

312 
12. Quantifiers and Logical Reductions 
If Ki U K2 contains structures of the form {A, 0), we add to K the structure 
{A, A X A X {a,b,c}) with distinct a,b,c if (A,0) G Ki, and the structure 
(A, Ax Ax {a, b, c, d}) with distinct a, 6, c, c? if (A, 0) G i^2- Arguing similarly 
as above one shows that JC{{QKI,QK2}) 
= ^(QK)- 
D 
Exercise 12.1.5 Generalize the preceding theorem to a countable set Q of 
simple binary quantifiers, thereby weakening the assertion £(Q) = ^(Qx) to 
£(Q) 
< C(QK). 
D 
A 1= \TCx,y^{x^y)]st 
means that (s,t) is in the transitive closure of 
the binary relation on A given by (/?"^(_,_). Similarly, for A: > 2 and 
ip{xi .. .Xk,yi'. 
.yk) we can read A |= [TCx,yil^{x,y)]'st as "(s,i) is in the 
transitive closure of the binary relation on A^ given by ^•^(_,_ )". Guided 
by this example we define the A:-vectorization of a Lindstrom quantifier. 
Let a = {Ri,..., 
Rg} with n-ary Ri and let k > 1. Let a{k) arise from 
a by replacing each relation symbol R in a^ say of arity r, by an r-A:-ary 
relation symbol R(k). An r-ary relation on A^ can also be viewed as an r • k-
ary relation on A just by identifying the r-tuple consisting of the elements 
a i , . . . , ar of A^ with the r • A:-tuple ai ... a^ of elements of A. Using this 
identification on the level of tuples and relations, we define: 
Definition 12.1.6 Let K he a, class of cr-structures. 
(a) K^, the k-vectorization of K, is the class of (7(A;)-structures 
K" 
:= 
{iA,Su...,Ss)\{A'',Si,...,S,)eK}; 
here, in (^, ^ i , . . . , 5s), the relation Si is viewed as an r^ • fc-ary relation 
over A, and in {A^,Si,... 
,Ss) it is viewed as an r^-ary relation over A^; 
in (A, Si,..., 
Ss) it is the interpretation of Ri{k), in (A^, ^ i , . . . , 5^) the 
interpretation of Ri. 
(b) We set Q^^ := {Qj^k \k>l}. 
D 
Thus, for the class K of Example 12.1.2(a) we have 
A \= QK^xyifix, y) 
iff 
(^^^ ^'^(_,_ )) G K 
iff 
A\=^x3yip{x,y), 
and for the class CONN (cf. 12.1.2(d)) 
A 1= QcQ^f^2Xx'yy'(p{xx',yy') 
iff (A^,(/9'^(_,_ )) is a connected graph. 
Exercise 12.1.7 Let K be as in Example 12.1.2(e) and let k > 1. Gener-
alize the equivalence FO(Qx) = FO(TC^) to FO(QxO = FO(TC^). Hence, 
FO(Qg) = FO(TC). 
D 
In view of 9.6.1 we have for the class K of the preceding exercise: 
K but not K^ is axiomatizable in FO(TC^). 
The following exercise shows that our standard logics are closed under vec-
torizations. 

12.1 Lindstrom Quantifiers 
313 
Exercise 12.1.8 Let C be one of the logics FO(TC), FO(DTC), FO(IFP), 
FO(PFP), or Looa;. Show: If K is axiomatizable in C and fc > 1, then K^ is 
axiomatizable in C. Conclude: If £i with Ci < £ is a Lindstrom extension of 
FO and K is axiomatizable in £, then i3i(Qx) ^ ^' 
^ 
Two further logics which we have extensively studied can be obtained 
from FO by adding the vectorizations of a simple quantifier: 
Theorem 12.1.9 There are classes I and P of structures such that 
FO(IFP) = FO(Qf) 
and 
FO(PFP) = F 0 ( Q ; ^ ) . 
Proof. We first consider FO(IFP) and recall (cf. 9.4.3) that any FO(IFP)-
formula is equivalent to a formula of the form 
Vi/[IFP^,x(V' V 3^ € X3-Z i Xx)\ u 
where ^ and % are quantifier-free and X does not occur in ^, %. This normal 
form motivates the following definition of I. 
Let cr = {t/, J?, y} with ternary R and unary t/, V and let I consist of the 
cr-structures A such that there is a sequence AQ, Ai, A2,... of subsets of A 
with the following properties: 
(1) Ao = 0 and Ai = V^. 
(2) For % > 1, Ai+i = Ai\j{ae 
A\ R-^abc for some b e Ai and c 0 Ai}. 
(3) There is an i > 1 such that V^ C Ai. 
To prove FO(Qf) < FO(IFP), by 12.1.8, it suflaces to show that I is axiom-
atizable in FO(IFP). In fact, I is the class of models of (po where 
cpo := \/u{Vu -^ [IFF^^xiUx V 3y e X3z ^ XRxyz)] 
u). 
For the other direction we consider an FO(IFP)-sentence (p in the normal 
form mentioned above, say 
ip=\fu [IFP^,x(^(^) V3ye 
X3z ^ Xx{x,y,z))] 
u, 
where X is A^-ary. Given a structure A^ let Xo,Xi,X2,... be the stages of 
the fixed-point operation in (p. Then Xi = '0'^(_), and ^ is a model of ip iff 
{a I a G A} C Xoo- Hence, ^p is equivalent to 
QihX,xy^,u[^{x),x{^^y^^)^ui 
= ... = Uk\. 
The proof for FO(PFP) is similar; one uses the class P that is defined as I 
with (2), (3) modified to 
(2)' For i > 1, Ai+i = {ae A\ R^ahc for some h £ Ai and c ^ Ai). 
(3)' V>^ = 0 or there is an z > 1 such that V-^ C Ai and Ai = Ai+i. 
D 

314 
12. Quantifiers and Logical Reductions 
We finish by representing FO(ATC) as a Lindstrom extension of FO. 
Setting a := {E, U, R} with binary £J, R and unary f/, we define A to be 
the class of cr-structures {A,E'^,U'^^R'^) 
such that i?^ is contained in the 
alternating transitive closure of {E^, U^). Then one easily gets: 
Theorem 12.1.10 FO(ATC) = FO(QX). 
• 
Notes 12.1.11 At many places of this chapter we tacitly assume that £ is a 
logic extending FO and satisfying certain closure conditions such as closure 
under negations or conjunctions (cf. (3) in the proof of Theorem 12.1.4). For 
instance, closure of C under conjunctions means: 
If if and ip are ^-formulas then (cp AI/J) is an ^-formula (or, at least, 
£ contains a formula equivalent to {^p Aip)). 
Compare [31] for the precise statement and an analysis of such closure con-
ditions. 
12.2 PTIME and Quantifiers 
In this section we shall see that no extension of FO(IFP) by means of finitely 
many Lindstrom quantifiers strongly captures PTIME. The same is true for 
all fragments of the extension of L^^ by all counting quantifiers. 
For a set Q of Lindstrom quantifiers, L^^(Q) consists of those formulas of 
LooculQ) that contain only finitely many variables. As a first result we have 
Theorem 12.2.1 Let Q be a finite set of Lindstrom quantifiers QL with 
L< m PTIME. Then for any relational vocabulary r there is a class K of 
T-structures such that i^< belongs to PTIME, but K is not axiomatizable in 
The proof will be given below. As FO(IFP)(Q) < L^^(Q) (mimic the 
proof of FO(PFP) < L^^, cf. 8.4.2) we have 
Corollary 12.2.2 No extension o/FO(IFP) by means of finitely many Lind-
strom quantifiers strongly captures PTIME. 
n 
To give an application of 12.2.1, let E be binary and Q be the set of all 
simple binary quantifiers corresponding to classes K of {E}-structures with 
K<:^ in PTIME. According to 12.1.5, Q may be replaced by one (ternary) 
quantifier QL such that FO(Q) < F O ( O L ) . Therefore, YO{QL) 
and hence 
IJ'^^{QL)^ 
is able to axiomatize all the classes K of {£J}-structures with ii'< 
in PTIME. By the theorem, L< cannot be in PTIME, that is, FO{QL) 
is 
strictly stronger than FO(Q) (cf. 12.1.3). 
The theorem has a generalization to certain infinite sets of quantifiers. With-
out proof we mention the following generalization to arity-bounded sets of 
quantifiers: 

12.2 PTIME and Quantifiers 
315 
Theorem 12.2.3 Letn > 1 and let Q consist of Lindstrom quantifiers of ar-
ity < n. Then there is a relational vocabulary r and a class K of T-structures 
such that K^ is in PTIME, hut K is not axiomatizahle in L^^(Q). 
Corollary 12,2 A No extension o/FO(IFP) hy means of Lindstrom quanti-
fiers of hounded arity strongly captures PTIME. 
D 
Since the first examples of PTIME classes not axiomatizahle in FO(IFP) 
were related to the class EVEN of structures of even cardinality, the logic 
FO(IFP, #), fixed-point logic with counting, appeared as a natural candidate 
for a logic strongly capturing PTIME. However: Let C be the set of counting 
quantifiers, i.e., C := {QKr, I ^ > I}, where Kn is as in 12.1.2(c). Then we 
have 
Theorem 12.2.5 There is a class K of graphs such that K^ is in PTIME, 
hut K is not axiomatizahle in L^^(C). 
Note that LS^,(C) = C ^ , . By 8.4.18, FO(IFP, #) < C ^ , . Therefore: 
Corollary 12.2.6 FO(IFP, #) does not strongly capture PTIME. 
D 
In the following we prove Theorem 12.2.1 and Theorem 12.2.5. 
Proof (of 12.2.1). First we show that for r = 0 there is a class K of structures 
such that i^< is in PTIME, but K is not axiomatizahle in L^^(Q). 
So let T = 0 and fix s > 1. Thus r-structures are sets and will be de-
noted by their universes. We start by proving that every L^^(Q)-sentence 
(of vocabulary r = 0 and) with variables among vi^... ^Vg is equivalent to an 
FO(Q)-sentence of a certain simple form. 
First we note that there are, up to logical equivalence, only finitely 
many quantifier-free formulas with variables among f i,..., i'g and hence, 
only finitely many formulas ipf,... ,iljf that are strings of the form Qa with 
Q € QU{V, 3}, where a does not contain quantifiers and has variables among 
Given an s-tupel a = ai ... ag of elements of a structure A, the equality 
type of a is, by definition, the formula 
^{vi 
= Vj \ai = aj,l 
<i < j <s} A /\{-^Vi = Vj \ Oi ^ Oj, I < i < j < s}. 
For any s-tuples a,b £ A of the same equality type there is a permutation (i.e., 
an automorphism) of A that maps a onto b. Hence, for n > 0, every L^^(Q)-
formula with variables among vi,... 
,Vs is equivalent in ^4^ := {0,1,..., n} 
to a disjunction of equality types (the disjunction is finite as there are only 
finitely many equality types of s-tuples). In particular, there are disjunctions 
X^^'* of equality types of 5-tuples such that 
(1) 
An h= ^^<i<,, Vi^i. ..\/vM! 
<^ 
x'T'^ 
that is, we have a "local quantifier elimination". Now, a simple induction on 
formulas shows: 

316 
12. Quantifiers and Logical Reductions 
(2) For all ^p G L^^(Q) with variables among vi^... ^Vg there is a quantifier-
free first-order formula x(fi,... ^Vg) (and hence, a boolean combination 
of equality types of s-tuples) such that 
f\ 
VJ;I ... Vv,(Vf ^ xl"'"') 1= Vvi. ..^v,{^ ^ x). 
We set 
^{n^s) ._ 
"there are exactly n elements", 
if n < s 
"there are at least s elements", 
if n > s 
and 
^(n,.) 
_ 
^(n,.)/^ 
yy Vi;i...V^,(V'f ^ X l " ' ' ^ 
l<i<ls 
Clearly, An \=^ (^^^'^^ and {(/?(^'^) | n > 1} is finite. Now we can show: 
(3) li B \= (^(^'*) then for all sentences (p of L^^(Q) with variables among 
B^^ 
iflp 
An 1= (/?. 
In fact, if \\B\\ < s then, by 5 |= 5^'^'^), we have n = \\B\\ and hence, B ^ A^; 
so (3) is trivially true. If ||5|| > s then n > s. For a sentence (p as in (3) choose 
a boolean combination x(fi,. •. jt^s) of equality types of s-tuples according 
to (2). By (1), An N Ai<i<z.Vi;i...V^,(^| ^ xl"''^) and by B ^ (^(-'^), 
also B 1= Ai<i<z, V^i... "^Vsiipl <^ Xi'"'^'')- Choose a G A^ and 6 G B' of the 
same equality type (recall ||An||, ||JB|| > s). Then 
B\=^ 
m 
B^x[b] 
iff 
An \= x H 
iflF An 1= (p. 
Since An |= (y:?^^'^^ and every B is isomorphic to some An, we see, using (3), 
that 
Nn <^ ^ Vi^^"''^ I n > 1, An H ^} 
holds for any sentence cp of L^^(Q) with variables among vi,... ^Vg- As the 
disjunction on the right side is finite, (p is equivalent to an FO(Q)-sentence. 
Altogether, every L^^(Q)-sentence is equivalent to an FO(Q)-sentence 
ip of the form 
(4) 
^ := 
V {Sj A A V^i ... \/Vg{xPi 4^ xO), 
jeJ 
ieij 
where s > 1, the Xi ^^^ quantifier-free, and the 5j and the xpi are of the form 
§(n,s) ^^^ ^s^ respectively. Let ^ be the set of these formulas. 

12.2 PTIME and Quantifiers 
317 
Using a diagonalization procedure, we show that there is a class K of sets 
such that K^ is in PTIME, but K is not axiomatizable by a sentence in ^. 
For a sentence if) as in (4) we set 
\\ip\\ := length of V', 
s^ := s. 
It is not difficult to define a uniform procedure that, given n and ip, checks 
^^ 1= -0 in time polynomial in n, ||^||, and 2*'^. The main point here is that 
in order to check the validity of An \= Vt'i... Vi's^ {ipi -H- Xi), it suflaces to test 
the validity of An \= (V'i <-> Xi)[^] ^^^ exactly one s^-tuple a of each equality 
type in An- This gives a corresponding procedure, because the number of 
equality types is 0(2^^^) and the (finitely many) quantifiers in Q U{V, 3} 
belong to classes K with K^ in PTIME. 
We now consider a function f iN ^ ^ computable in time polynomial in 
n that enumerates ^ in such a way that 
\\f{n)\\=0{n) 
and 
s/(^) = 0(log n) 
(it is not hard to see that such an enumeration exists). We then define K by 
(5) 
B e K 
iff 
for some n, \\B\\ = n and An ^ 
f{n). 
By the preceding remarks, K< is in PTIME; however, by (5), K is not ax-
iomatized by an /(n), that is, K is not axiomatizable by any sentence in ^ 
and hence, not by an L^^(Q)-sentence. 
Now, let r be an arbitrary vocabulary and let Cr be the class of structures 
A such that R-^a for all R e r and a G ^4. As in structures of Cr any atomic 
formula Rt is equivalent to ti = ii, the proof above for r = 0 works for this 
case too, yielding a class K C Cr such that K< is in PTIME, but K is not 
axiomatizable in L^^(Q). 
D 
We now prove Theorem 12.2.5. For this purpose we show that for all 5 > 3 
there are graphs Qs and Qs such that the following holds: 
(1) Qs =LS,^(C) Gs-
(2) There is a class K of graphs such that iC< G PTIME and K contains all 
Qs but no Qs. 
This yields the theorem, because, by (1), no L^^(C)-sentence (p can axiom-
atize a class K as in (2). 
In section 3.4 we have denoted LJQ^(C) by CJ^^ and shown that (1) is 
equivalent to 
(1') 
the duplicator wins C-Gl^{Qs,Qs) 
where C-GJo(_,_ ) is the Ehrenfeucht game corresponding to CJ^^. 
We define the graphs Qs and Qs- Let k := s + 2. Then k >b. Take sets 

318 
12. Quantifiers and Logical Reductions 
A := {ai,...,afc}, 
B := {61,...,6^}, 
C := 
{ci,...,Ck} 
of distinct elements, let 
D 
:= 
{SC{l,...,k} 
I ||5|| is even}, 
and define the graph 7{ := {H,E) by 
H 
:= 
AUBUCUD 
E 
:= 
{{ai, a), {ci, ai), (bi, c^), (c^, h) \ 1 < i < k} 
U{{ai,S),{S,ai)\SeD,ieS} 
U{{h,S),{S,bi)\SeD,i^S} 
U{(ci,Q+i),(ci+i,Ci) I 1 < i < 
k}U{(ck,ci),{ci,Ck)}-
In 'H, the flj and hi have degree 2^~^ + 1, being connected with Ci and exactly 
2^~^ points in D; similarly, the S ^ D have degree k and the Q degree 4. 
(As A; > 5, these degrees are different.) Therefore, any automorphism TT oiH 
maps the sets AU B, C, and D onto themselves, and if n is the identity on 
C then 7r(oi),7r(6i) € {0^,6^}. 
Lemma 12.2.7 Let TT be a permutation of AU B U C which is the identity 
on C. Then ir can be extended to an automorphism ofH iff TT interchanges ai 
and bi for an even number of i 's, leaving the other elements in AU B fixed. 
Proof If TT interchanges a^ and bi for i e SQ, then for any automorphism TT 
of ft that extends TT, and for any 5 G -D we have 
(3) 
7f(5) = ( 5 \ 5 o ) U ( 5 o \ 5 ) 
which is in D just in case SQ is even. If SQ is even, (3) gives an extension of 
TT which is an automorphism ofH. 
D 
Let y be a set of s+3 {= k+1) elements. We define n{V) = {H{V), ^^(^)) 
as follows: We replace each i' G F by a copy 7i{v) of'H, where ai{v), 
bj{v),... 
correspond to a^, 6j, 
Moreover, if i^, w; G V and v ^ w, we add edges 
where 
{a{v,w),a{w,v)), 
{a{w,v),a{v,w)), 
{b{v,w),b{w,v)), 
{b{w,v),b{v,w)) 
for some i, a{v,w) — ai{v) and b{v,w) = bi{v)^ 
for some j , a{w,v) = aj{w) and b{w,v) = bj{w). 
We do this in such a way that for every v and i there are uniquely determined 
w and j such that ai{v) is linked to aj{w) (and hence, bi{v) is linked to bj{w)). 
For VQ.WQ G y, I'D 7^ w^o, we define the "twisted" version 7^(y)^0'^° just 
as ?^(V), but replacing (*) - only for the points VQ^WQ - by 

12.2 PTIME and Quantifiers 
319 
{b{vo,wo),a{wo,vo)), 
{a{wo,vo),b{vo,wo)). 
Fix VQ^WQ G V, VQ ^ WQ. Set 
We show that (1') and (2) are satisfied. First we prove that the dupHcator 
wins the game C-G^^{Qs^Qs)' Obviously, it is enough to show that he can 
play in such a way that, after his moves, the following holds: 
There is a t? G F such that l-i{v) (in Qs) is not pebbled and there 
(+) 
is an isomorphism TT : ^J'^^o = Qs which respects the pebbles and 
maps elements of H{u) to elements of H{u) for all it G V. 
In the beginning we take v := VQ and n the identity on H{V). Now assume 
that, before a move of the spoiler, we have v and TT according to (+). Let 
v' be a further point of V different from WQ such that 1-L{v') (in Qs) is not 
pebbled. Using 12.2.7, choose an automorphism p of li{v) that interchanges 
a{v,v') and b{v,v') and interchanges a{v,wo) and b{v,wo); similarly, choose 
an automorphism p' oil-L{v') interchanging a{v',v) and b{v',v), and a{v', WQ) 
and b{v',wo). Let a be the permutation of H(V) that extends pU p' and is 
the identity outside H{v) U H{v'). Then it is easy to check that 
a : Q'i '^0 ^ Ql 
Wo 
i.e., a shifts the twist from {v',wo} to {v,wo}. 
Now, if the spoiler chooses a subset X, say, of Qs, then the duplicator 
answers by the subset Y of Qs consisting of the 7r-images of the elements in 
X \ H{v) and of the n o a-images of the elements in X H H{v). If then the 
spoiler pebbles an element of Y, the duplicator answers with the correspond-
ing preimage. If 7i{v) remains unpebbled, (+) is again satisfied by v and TT; 
otherwise, it is satisfied by v' and TT o a : Q^ ''^° — Qs-
Before we prove (2), we provide some more information about the graphs 
Qs and Qs- Qs arises from Qs by a twist corresponding to the pair {VQ^WO}. 
Similarly, we can define twisted versions of Qs that have twists corresponding 
to several pairs. We call Q an m-twisted version of Qs, if there are exactly m 
twists of this kind. So Qs is a 0-twisted version of Qs and Qs a 1-twisted one. 
Claim. Let Q and Q' be m-twisted and m'-twisted versions of Qs, respectively. 
Then 
Q = Q' iff m - m' is even. 
Proof (of Claim). Let n : Q = Q'. Then, given v e V, n maps li{v) isomor-
phically onto some copy 7i{w). By (a simple generalization of) 12.2.7, the 
number of z's such that 7r{ai(v)) G {bi{w),... 
,bk{w)} is even. This yields 

320 
12. Quantifiers and Logical Reductions 
that m — m' is even. Now, let m — m' be even. In the proof of (+) we saw how 
one can shift twists by suitable isomorphisms, say, a twist corresponding to a 
pair {v'^w} to a twist corresponding to a pair {v^w}. Hence, we may assume 
that the twists of Q and Q' correspond to pairs that have WQ as one point. 
(Note that it may be necessary to shift a twist upon a twist, thus replacing 
m by m — 2 (or, m' by m' — 2).) Then by 12.2.7, di.s m — m' is even, we can 
find an automorphism of H{wo) that can be extended to an isomorphism of 
g onto Q'. 
We now come to a proof of (2). For this purpose we describe a determin-
istic polynomially time-bounded Turing machine M that accepts all Qs for 
s > 3, but no Qs-
Started with (the ordered version of) a graph Q, M first checks whether 
there is a number s > 3 such that Q contains exactly s-\-S cycles Ci,..., Cs+s 
of length s -f- 2, consisting of points of degree 4 (so-called c-points), and 
whether Q contains no other points of degree 4. If so, M checks 
(i) whether each c-point has exactly two neighbours that are no c-points (so-
called ab-points; different a6-points with the same c-neighbour are called 
related) ; 
(ii) for each pair {a, b} of related a6-points, whether a and b are neighbours 
of exactly one a6-point a' and 6', respectively, a' and b' being related via 
a c-point that belongs to a circle different from that of the c-point that 
relates a to 6; 
(iii) for each circle Ci, whether there are exactly 2^+^ points (so-called d-
points) that have exactly 5-1-2 neighbours, these neighbours being ap-
points that are related to a c-point in d (we let Hi be the set of these 
d-points, the neighbouring a6-points, and the elements of Ci); 
(iv) whether there are no other points or edges. 
Finally, M checks for each Hi whether the subgraph Hi of Q with domain 
Hi is isomorphic to 7i, in the positive case also producing a partition of the 
a6-points into a-points and 6-points. (This can be done in a time polynomial 
in 2* and hence, polynomial in ||G||). If all checks have a positive outcome, M 
counts the number of twists of Q. If this number is even, M accepts, otherwise 
it rejects. By the claim above, M accepts the Qs for s > 3, but rejects the 
12.3 Logical Reductions 
In complexity theory there are well-established notions of reducibility, among 
them the notion of many-one reducibility: Given alphabets A^, languages 
Li C Af (i = 1,2), and a deterministic complexity class C, the language Li is 
C-reducible (or, C-many-one reducible) to L2 if there is a function f : Al -^ A2 
in C such that 

12.3 Logical Reductions 
321 
w eLi 
iff f{w) e L2 
for all w ^ A^. Given a further complexity class C, a language L is C'-hard 
with respect to C-reductions if any language in C is C-reducible to L, and L 
is C-complete with respect to C-reductions if it is C'-hard and belongs to C. 
We aim at a logical analogue. For this purpose we need the notion of an in-
terpretation as introduced in section 11.2. For convenience, we shortly repeat 
the definitions and notations. 
Fix a logic C and vocabularies a and r where a = {Ri,... 
,Rs} with 
Tj-ary Ri. An /^-interpretation of <7 in r of width k is given by an (s-l-l)-tuple 
of £[r]-formulas 
n 
:= 
(7runi(^),7rHi (^1,... ,^^1),.. • ,7r/?^(xi,... ,^rj), 
where all tuples x,xi,... 
are of length k. 
For any r-structure A, 11 induces a cr-structure A^ over /;:-tuples of A 
given by 
A"" 
= 
( 7 r , ^ , i ( _ ) , < ( _ , . . . , _ ) , . . . , < ( _ , . . . , _ ) ) , 
a map 
provided 7r{^j(_) is nonempty.^ So any /^-interpretation IT of cr in r induces 
n : Str[T] -> Stv[a]. 
Exercise 12.3.1 Let Hi be an /^-interpretation of cr in r and 112 be an JC-
interpretation of r in p. Show that there is an /^-interpretation H of <j in p 
such that for all p-structures A, 
A^ 
= {A^^)^K 
D 
Taking the maps ^ as candidates for the maps linked to logical reducibility, 
we are led to the following analogue of the notion of reducibility in complexity 
theory. 
Definition 12.3.2 Let K C Str[r] and L C Str[cr]. i^ is C-reducible to L, 
for short: K <c L, if there is an /^-interpretation 11 of cr in r such that for 
all T-structures A, 
AeK 
iff 
A^ 
eL. 
We write K <^ L to indicate that K <c L can be witnessed by an interpre-
tation of width k. 
D 
Exercise 12.3.3 Show that <£ is transitive. 
D 
^ As in section 11.2, we tacitly ignore the case 7r;;^i(_) = 0 as it will not be 
of importance; moreover, note that TT^. (_,...,_) stands for TT^. (_,...,_) D 

322 
12. Quantifiers and Logical Reductions 
Exercise 12.3.4 Let K C Str[r] be a class of ordered structures and L C 
Str[o-]. Show that K <c L implies K <c L<. 
D 
An important example of first-order reductions is given in the following 
consequence of 11.2.5. In fact, taking as L the class K^ (E as in 11.2.5) we 
have 
Proposition 12.3.5 Let r he an arbitrary vocabulary. Then, for all K C 
Str[T\ there is a class L C GRAPH such that K <FO L . Moreover, L can be 
chosen such that K^ e PTIME iff L< G PTIME. 
D 
We study the relationship between reductions and Lindstrom quantifiers. 
First, there is a difference: Interpretations 11 contain a formula 7runi(^) giving 
the new universe, whereas Lindstrom quantifiers do not allow to "relativize", 
they always refer to the whole universe of the structure in question. To over-
come this difference, we proceed as follows: 
Let a — {Ri,..., 
i^g} with r^-ary Ri and let U he a, new unary relation 
symbol. For L C Str[a] we introduce the class rel-L C Str[cr U {U}] by 
rel-i 
:= 
{iA,U^,Rt 
• • • ,Rf) \ {U^,Rt 
• • • ,Rf) e L}; 
more precisely, rel-L is the class 
{{A,u^,Rt...,Rf) 
I {U^,Rt n {u^y\...,Rf 
n (U^y-) e L}. 
For A: > 1 set a{k) \— {Ri{k),..., 
Rs{k)} with r^A^-ary Ri{k) and let U{k) be 
an fc-ary relation symbol. Identifying r-A:-tuples over A with r-tuples over A^ 
as in section 12.1, we "relativize" the definition of vectorization (cf. 12.1.6) 
as follows: 
Definition 12.3.6 Let L C Str[(j]. 
(a) rel-A;-L, the relativized k-vectorization 
of L, is the following class of 
{U{k)} U (j(A:)-structures: 
rel-A^-L 
:= 
{(A, W,5i,... ,5',) | (^^ PF, 5 i , . . . , 5,) G rel-L} 
(= 
{(A,^,5i,...,5,) I T^ C A^ and (VF,5i,...,5,) G L } ) . 
Note that rel-L is rel-l-L. 
(b) The Lindstrom quantifier Qre\-k-L is called the relativized k-vectorization 
of the quantifier QL- We set lel-uj-QL '•= {Qre\-k-L \ k >1}. 
D 
Example 12.3.7 For the class CONN of connected graphs we have 
A h Qrei-k-coNNX,xylip{x),iP{x,y)] 
iff ((p'^(_), V'^l-,- )) G CONN. 
D 
As a simple observation we have (compare 12.1.6 for the definition of L^): 
Proposition 12.3.8 Let L be a class of structures and C a logic. Then for 
all k >1, 

12.3 Logical Reductions 
323 
Proof. If, for instance, k = 2 and L is a class of {i?}-structures with r-ary i?, 
the formulas 
QL2XIX[ 
. . .XrX'^'llj{xix[,. 
. 
.,XrX'^), 
Qre\-2-LXx' 
Xix[ . . .XrX'^[x 
— X /\ x' — x',IIJ{XIX[, 
. . . ,XrX'j,)] 
are equivalent. 
D 
The direction " > " may be wrong: 
Exercise 12.3.9 Let P be unary and L := {(A,^^) I ll^^^ll < | P I I } -
Show that 
A [= Qre\-LX,y[ip{x),ip{y)] 
iff ^^{-) ^ 0 and 
and that F O ( Q L ) < FO(Qrei-L). 
• 
Exercise 12.3.10 Let I and P be the classes introduced in 12.1.9. Show 
that FO(rel-a;-Qi) = FO(Qf) = FO(IFP) and FO(rel-a;-Qp) = FO(Qg) = 
FO(PFP). 
Exercise 12.3.11 Prove C{Yel-u;-Qi) = £(rel-a;-Q/,^) on ordered struc-
tures (compare 12.1.2(f)). 
D 
Exercise 12.3.12 Let K be a class such that K^ G PTIME. Show that 
Mod(V^)< G PTIME for any sentence ip G FO(IFP)(rel-a;-QK). Moreover 
show: If FO(IFP)(rel-tJ-Qx) or FO(rel-a;-QK) strongly captures PTIME, 
then it effectively strongly captures PTIME. 
D 
For C a logic and Q a set of Lindstrom quantifiers, we denote by C[Q] 
the set of formulas of i2(Q) that are of the form 
Qxi ^...^Xslipiixi),..., 
i^sixs)] 
where Q G Q and ^ i , . . . , -^s are ^-formulas (thus the ipi do not contain the 
new quantifiers). Then a simple, but crucial link between reducibility and 
quantifiers can be stated as follows: 
Proposition 12.3.13 Let C be a logic, K C Str[T] and L C Str[cr]. Then for 
A: > 1 the following are equivalent: 
(i) 
K<),L. 
(ii) There is a sentence ip in C[QYe\-k-L\ of vocabulary r such that K = 
Mod((/?). 
Proof. Assume a = {Ri,..., 
i^g} with n-ary Ri. To prove (i) =^(ii), suppose 
'l L via 
n 
'= 
{7Tuni{x),7rR^ {Xi, . . . ,Xr^), 
. . . ,7rR^(Xi, 
. . . 
,XrJ). 
that K <^ L via 

324 
12. Quantifiers and Logical Reductions 
Then for any r-structure A we have: 
AeK 
iff 
^ n = (7r;f,.(_),<(_,...,_),...,^^^(_,...,_))GL 
iff 
(A,^,^,,(_),^4(_,...,_),...,<(_,...,_))erel-fc-L 
iff 
^ 1= Qj-ei-k-LX, Xi,...,Xr, 
[rCuni ^TTR^, . . . ^TTR^]. 
Concerning the direction from (ii) to (i), assume that K is axiomatized by 
the sentence 
Qre\-k-LX, 
Xi,.. 
.,Xr, 
[TTuni, TTR^ , . . . , TTR^] 
with /^-formulas TTuni, TTRI , • • •, TTR^ . Then a rearrangement of the equivalences 
above shows that K <^ L via II — (TTuni,TT^I, • • •,^Rs)- 
^ 
We now transfer the notions of hardness and completeness from complex-
ity theory to logic.^ 
Definition 12.3.14 Let C be a complexity class, L C Str[<j], and C a logic. 
(a) L is C-hard with respect to C-reductions if K <£ L for all K E C. 
(b) L is C-complete with respect to C-reductions if L is C-hard with respect 
to /^-reductions and L<^ £ C. 
D 
Corollary 12.3.15 Let C,L, and C be as in the preceding definition. 
(a) The following are equivalent: 
(i) L is C-hard with respect to C-reductions. 
(ii) C C {Mod((p) I ^ e £[rel-a;-Qx]}. 
(b) If C is closed under C-reducibility (i.e., for classes Ki,K2 
of ordered 
structures, Ki <c K2 o-nd K2 E C imply Ki £C), then the following are 
equivalent: 
(i) L is C-complete with respect to C-reductions. 
(ii) £[rel-C(;-Qi,] captures C. 
Proof, (a) is immediate from the preceding proposition. For the implication 
(ii) =^ (i) in (b) note that L< (as L) is FO[(3rei-L]-axiomatizable and therefore 
£[rel-L<;-Qi,]-axiomatizable, hence L< G C by (ii). The rest is clear by (a). For 
(i) => (ii) assume that the class K of ordered structures is axiomatizable in 
C[Yel-uj-QL]- Then K <c L by 12.3.13 and hence, K <c L< (cf. 12.3.4). 
Since L^ e C (by (i)) and C is closed under £-reducibility, we get K e C. 
The rest is clear by (a). 
D 
Corollary 12.3.16 Let I and P be the classes introduced in the proof of 
12.1.9. Then I is VTIME-complete 
with respect to YO-reductions and P is 
VSVkCE-complete 
with respect to YO-reductions. 
^ Recall our convention that only classes of ordered structures are considered as 
members of complexity classes. 

12.3 Logical Reductions- 
325 
Proof. By the proof of 12.1.9, FO(IFP) < FO[Qf ]. Therefore, FO(IFP) < 
FO[Qf] < FO[rel-(j-Qi] < FO(rel-u;-Qi) < FO(IFP) (by 12.3.10). Since 
FO(IFP) captures PTIME, so does FO[rel-a;-Qi]. Thus, I is PTIME-complete 
with respect to FO-reductions by part (b) of the preceding corollary. The 
proof for P is similar. 
D 
We are now in a position to show the result announced in section 11.1 that in 
case PTIME is effectively strongly captured by any logic at all, it can already 
be captured by a very familiar one, namely by an extension of first-order logic 
by means of a single vectorized Lindstrom quantifier. 
A class L is strongly PTIME-complete with respect to FO-reductions if L< 
is in PTIME and K <FO L for any class K of structures with K< in PTIME 
(in Definition 12.3.14 we only considered classes K of ordered structures). 
The main result is: 
Theorem 12.3.17 The following are equivalent: 
(i) 
There is a logic that effectively strongly captures PTIME. 
(ii) There is a class L of structures such that FO{re[-cj-QL) effectively 
strongly captures PTIME. 
(iii) There is a class L of structures which is strongly FTlMFj-complete with 
respect to FO-reductions. 
Moreover, a class L satisfies (ii) just in case it satisfies (iii). 
The theorem gets false if "strongly PTIME-complete" is replaced by 
"PTIME-complete": With respect to FO-reductions the class I is PTIME-
complete (cf. 12.3.16) but not strongly PTIME-complete (otherwise, by the 
last statement of the theorem, FO(rel-cc;-Qi) = FO(IFP) (cf. the proof of 
12.3.16) would effectively strongly capture PTIME). 
Proof (of 12.3.17). We show (iii) ^ (ii) and (i) ^ (iii), the implication (ii) 
=^ (i) being trivial. 
(iii) =^ (ii): Let the class L be given by (iii) and let K be any class of struc-
tures such that K< G PTIME. By (iii), K <FO L and hence, by 12.3.13, K is 
axiomatizable in FO[rel-u;-QL] C FO{ie\-uj-Q,L)' Moreover, by induction one 
can effectively assign to every (^ G FO(rel-a;-Qx) a pair (M, c?), where M is a 
deterministic x^ time-bounded machine accepting Mod((^)<. Hence, FO(rel-
CJ-QL) effectively strongly captures PTIME (note that Mod(V')< G PTIME 
for ^ G FO(rel-cj-QL), cf. 12.3.12). 
(i) =^ (iii): It suffices to define a class L of structures such that L< is in 
PTIME and such that for every class K of {£^}-structures (where E is bi-
nary) with K< in PTIME we have K <FO L . Then 12.3.5 together with the 
transitivity of <FO (cf. 12.3.3) yields the strong PTIME-completeness of L. 
Let £ be a logic that effectively strongly captures PTIME. We may assume 
that the set £[{E}]o of sentences of C of vocabulary {E} is N. Furthermore, 

326 
12. Quantifiers and Logical Reductions 
let p be a computable function assigning to i = (p ^ JC[{E}]O a pair {M,d) 
such that M is deterministic and x^ time-bounded and accepts Mod ((/?)<. 
Let Mg be a deterministic machine that calculates p. 
We set 
a := {y,E,P,Q} 
with unary V, Q and binary E, P and define L as the class of cr-structures A 
such that: 
(1) E"^ CV^ X V^. 
(2) P^ is a preordering of A (i.e., it is reflexive and transitive) such that the 
equivalence classes of the equivalence relation given by 
a and 6 are equivalent iff P^ab and P^ha 
are linearly ordered with respect to the ordering -<^ induced by P^. 
(3) Q^ is an equivalence class, say, Q^ is the z'-th class with respect to -<^. 
(4) The length of the run that Mg performs on the input 1... 1 of length i 
to calculate g{i) =: (M,d) is < \\A\\. 
(5) \\A\\ > 
\\V^r. 
(6) M accepts all ordered representations of 
{V^,E^). 
L< is in PTIME. Namely, in order to check in time polynomial in | m | whether 
an ordered cr<-structure (.4, <^) with A = {1,... ,n} belongs to L<, we 
— check (1) 
— check whether P^ satisfies (2) and whether Q^ is an equivalence class and 
determine i 
— calculate g{i) — {M,d), thereby checking (4) 
— check (5) 
— check whether M accepts {V^,E^, 
<^ 0(1/^ x V^)) (which is equivalent 
to a check of (6), as M is x^ time-bounded and accepts Mod(2)<). 
Now, let i^ be a class of {£^}-structures such that K^ is in PTIME. We 
show that K <FO L . For this purpose let i = (p G £[{£^}]o be such that 
Mod((/?) = K. Let g{i) — {M,d). Then the deterministic machine M is x^ 
time-bounded and accepts i^<. Choose / such that there are at least max{i, d} 
many equality types of / elements (cf. section 12.2) and such that l^ > the 
length of the run that Mg performs on the input 1... 1 of length i to calculate 
g{i). We only take care of {£^}-structures of cardinality > /. 
We show K <po L by defining the following FO-interpretation E of cr in 
{E} of width / {x and y are of length /): 

12.3 Logical Reductions 
327 
7runi(^) 
:= xi = xi 
TTvix) 
:= xi=X2 
= ... = xi 
TTpix^y) 
:= "the equality type of x is smaller than that of y " 
(in a fixed, first-order definable ordering of the finitely 
many equality types of / elements) 
^Q{X) 
'•= 
"^ satisfies the z-th equality type" 
7rE{x,y) 
:= xi ^ ... = xi Ayi = ... = yi 
AExiyi. 
Then for all {£J}-structures 8 of cardinality > /, 
8eK 
iff 
B^ eL. 
D 
To conclude this section, we give some further applications of Corollary 
12.3.15 for C = NPTIME. 
Let < G (7 and let L C 0[a] be a class of ordered structures that is NPTIME-
complete with respect to logspace reductions, i.e., L G NPTIME and every 
NPTIME class K of ordered structures, say of vocabulary r, is reducible to 
L in the following sense: There is a log space-bounded^ (r, (j)-transducer M 
(cf. Appendix 7.5.1) such that for all r-structures A, 
AeK 
iff 
M{A) e L 
where M{A) is the output of M started with A. From complexity theory we 
know that an example of such an L is given by IIAM< where 
HAM 
:= {^ I ^ is a directed graph that has a Hamiltonian circuit}. 
Proposition 12.3.18 For classes K and L of ordered structures the follow-
ing are equivalent: 
(i) K is logspace reducible to L. 
(ii) K <FO(DTC) L. 
Proof. For the imphcation (ii) =^ (i) let II be an FO(DTC)-interpretation 
witnessing K <FO(DTC) L. Since satisfiability for FO(DTC)-formulas can be 
checked by log space-bounded machines, there is a (r, cr)-transducer that, 
given A^ writes an encoding of ^4^ on the output tapes. 
For (i) => (ii) suppose that L C 0[o] where a = {i?i,..., i?s} with r^-ary 
Ri. Let K C,0[T\ and let M be a log space-bounded (r, cr)-transducer such 
that for all Ae 0[T\, 
(1) 
^ e i^ 
iff 
M{A) e L. 
By 7.5.23 there are k > 1 and formulas Xuni(^) and XRii^i, • • • ^Xr^) of 
FO(DTC) with x,xi,... 
,Xr, of length k such that for all A G (9[r], 
^ Recall that log space-bounded means clog space-bounded for a suitable c > 0. 

328 
12. Quantifiers and Logical Reductions 
(2) 
M(^)-(x;i,(_),xi(-,...,-),...,xl(-,..-,-)). 
Let n be the FO(DTC)-interpretation (Xuni,Xfii, • • • ,XfiJ- By(l) and (2), 
we have Ae K iS A^ G L; hence, K <FO(DTC) ^' 
'-' 
Since NPTIME is closed under logspace reductions, we get by 12.3.15(b) 
and the preceding proposition: 
Corollary 12.3.19 For a class L of ordered structures the following are 
equivalent: 
(i) 
L is ISiFTlME-complete with respect to logspace reductions. 
(ii) L is NFTIME-complete 
with respect to 
FO(DTC)-reductions. 
(iii) FO(DTC)[rel-cj-QL] captures NFTIME. 
D 
Corollary 12.3.20 HAM< is NFTIME-complete 
with respect to FO(DTC)-
reductions. 
D 
Corollary 12.3.21 FO(DTC)[rel-cj-QHAM<] captures NFTIME. 
D 
In some cases one can do better. For example, NPTIME is captured al-
ready by FO[rel-C(;-QHAM<] (in the presence of min and max even quantifier-
free formulas suflfice); moreover, according to the following exercise we can 
replace HAM< by HAM. 
Exercise 12.3.22 Show that £[rel-a;-Q£,] = £[rel-c<;-QL<] on ordered struc-
tures (compare 12.1.2(f)). 
D 
In a typical first-order prefix, for example a prefix as in 
(1) 
\/x3y\/u3v(p{x,y,u,v), 
the existentially quantified variables depend on all the preceding universally 
quantified variables. So (1) means (using function symbols / (unary) and g 
(binary)) 
(2) 
3f3g\/x\fuip{x, f{x),u, g{x, u)). 
Due to the linear character of our notation of formulas it is not possible to 
arrange the quantifiers in the prefix in (1) in such a way that y only depends 
on X and v only depends on u. Henkin introduced quantifiers which allow 
such dependencies. Here we only consider the simplest one, the one we just 
have described. It is written as ( ^ n 
L a n d ! ^ q 
) (p{x,y,u,v) 
means 
3f3g'^x^uip{x,f{x),u,g{u)).Wet\iTn 
I w q 
1 into a Lindstrom quantifier 
by introducing, for a = {R} with a 4-ary relation symbol R, the class 
HENK 
— 
{{A,R^) 
I (A,i?^) 1= 
3f3g'^x\/uRxf{x)ug{u)}. 

12.3 Logical Reductions 
329 
F0((3HENK) is strictly stronger than FO. For example, with r = 
{U,V}, 
where U, V are unary, and 
= 
"3/3pVxV^((ii = f{x) -^ g{u) = x) A {Ux <^ Vf{x))Y 
= 
Q'iiE^Kxyuv{{u = y ^v 
= x) A (Ux ^ 
Vy)) 
we have Mod(v?) = {{A, U^, V^) \ \\U^\\ < \\V^\\}, a class that is not axiom-
atizable in FO. 
Proposition 12.3.23 For Q — rel-c^-QnENK CL'nd for Q = rel-Lc;-QHENK< 
the logic FO(DTC)[Q] captures NPTIME. 
Proof. By 12.3.22 we may restrict ourselves to HENK<. Let 3C0L be the 
class of 3-colourable graphs. (A graph is Z-colourable^ if its vertices can be 
coloured with three colours such that no two adjacent vertices have the same 
colour.) 3C0L< is NPTIME-complete with respect to logspace reductions 
and hence, with respect to FO(DTC)-reductions (cf. 12.3.19). We show 
(*) 
3C0L< <FO(DTC) HENK<. 
Since HENK< is in NPTIME, (*) yields that HENK< is NPTIME-complete 
with respect to FO(DTC)-reductions. By 12.3.19, FO(DTC) [rel-cc;-QHENK<] 
captures NPTIME. 
We show (*), even 3 C 0 L < F O H E N K : We use a unary function / to rep-
resent three colours: a vertex a has the first colour if 
/(a) = a, 
the second colour if 
/(a) ^ a and 
Eaf{a), 
and the third colour if 
/(a) ^ a and not 
Eaf{a). 
Then an easy argumentation shows that a graph Q = (G, E^) is 3-colourable 
iff it is of cardinality < 3 or there is a function f : G ^ G such that for all 
a, b with E^ab it is not the case that (i), (ii), or (iii) where 
(i) 
/(a) - a and /(6) = 6; 
(ii) /(a) ^ a, Eafia) 
and f{b) # 6, Ebf{b); 
(iii) /(a) ^ a, not Eaf{a) and f{b) / 6, not Ebf{b). 
Therefore, there is a formula ^3COL{X, y,u,v) 
e FO[{E}] such that 
Mod(QiiENKxyuvipsGOL{x,y,u,v)) 
= 3C0L; 

330 
12. Quantifiers and Logical Reductions 
for instance, we can take 
^3COL{x, y,u,v) 
:= (p<3 W {(x = u-^ y = v) A {Exu -^ 
->{{y = X Av = u) V {y ^ X A Exy A v ^ u A Euv) 
M {y ^ X A -^Exy A v ^ u A 
^Euv)))). 
Hence, 3 C 0 L < F O H E N K via the interpretation given by 
^uni\X J 
.— 
X — X 
TTR{x,y,u,v) 
:= 
^zcoh[x,y,u,v). 
D 
12.4 Quantifiers and Oracles 
In the preceding section we have encountered complexity classes captured by 
logics of the form £(rel-a;-QK)- In the following we deal with a question in 
the opposite direction: Let £ be a logic, K a class of structures, and C a 
complexity class. Then: 
(+) 
If £ captures C, what complexity class is captured by £(rel-a;-Qx)? 
Interprete a formula (/?, say, of C{QK) as a program to evaluate the meaning 
of (/?, addressing a device which can evaluate instructions of the form 
in one step, once (/?i,..., (^g have been evaluated. There is a concept of such 
a device in complexity theory that fits into this frame, Turing machines with 
oracles. We let C^ denote the complexity class defined by Turing machines 
with resource-bound according to C that can use an oracle for K to decide 
membership for K. Then the natural answer to (+) would be 
£(rel-tj-Qx) captures C^. 
As it has turned out, this answer is true in various cases. However, one has 
to choose the right oracle machine model in each particular case. We only 
will present one important group of results to give an impression of what is 
going on. First, we introduce an oracle model (essentially Turing machines 
with one oracle tape) that meets our purposes. 
Let a and r be vocabularies with <£ a and < G r. A Turing machine M 
for r-structures with oracle tapes for a-structures^ for short, a {T,a)-oracle 
machine, is a (r, cr)-Turing machine (cf. Appendix 7.5.1), that is, a determin-
istic Turing machine with input tapes for r-structures, with work tapes, and 
with output tapes for <j-structures (now called oracle tapes). In addition to 

12.4 Quantifiers and Oracles 
331 
the instructions of a (r, (j)-Turing machine it has so-called oracle instructions, 
that is, instructions of the form 
(1) 
sbo...bk+iCi 
...Cm-^ 
s's". 
Given an "oracle class" O of <7-structures, (1) has the meaning 
"If you are in a configuration corresponding to sho ... bk+i ci .. .Cm, 
do the following: if the inscription on the oracle tapes encodes a 
structure in O, go into state s'; otherwise, go into state s". Delete 
the inscription on the oracle tapes and move the heads to the initial 
position." 
Configurations which ask for an oracle instruction are called oracle configu-
rations. Note that in an oracle configuration the inscriptions on the oracle 
tapes need not encode a cr-structure. 
We write {M,0) to indicate that M works with O as the class fixing the 
meaning of the oracle instructions. 
An oracle instruction is carried out in one step. By definition, space 
bounds refer only to work tapes; in particular, space used on the oracle tapes 
does not count. If (M, O) is s(n) space-bounded then - in case {M,0) 
stops 
- the number of cells on the oracle tapes that are scanned during the run is 
< d*(^) for a certain constant d > 0. 
Occasionally we shall also use transducers with oracle tapes, so-called or-
acle transducers', they possess both output tapes and oracle tapes, the latter 
ones serving the same purpose and working in the same way as with oracle 
machines. It should not be difficult for the reader to provide an exact defini-
tion. 
Let C be a complexity class and K a class of classes of ordered structures. C^, 
the relativization ofCtoJC, consists of those classes of ordered structures that 
are accepted by some oracle machine {M,0) 
with O e JC that is resource-
bounded according to C. In particular, LOGSPACE^ consists of those classes 
of ordered structures that are accepted by some log space-bounded oracle ma-
chine (M, O) with O G /C. If 1/ is a class of ordered structures, we write C^ 
forC^^}. 
The following proposition which is stated for the case we are interested in 
exhibits the relationship between oracles and quantifiers. 
Proposition 12.4.1 Suppose that O is a class of ordered a-structures and 
(p an F0(DTC)[rel-a;-Qo]-5en^ence. Then there is a log space-bounded oracle 
machine {M,0) 
that decides Mod{ip).^ 
Proof. Let 
^ = Qrel-k-O 
X,Xi,...,Xr, 
[</?uni (x), 
^R^ ( ^ i , . . . , ^ ^ ) , • • • , ^Rs 
( x i , . . . , Xr, )] 
In particular, the logarithmic space bound applies to rejecting runs, too. 

332 
12. Quantifiers and Logical Reductions 
with (/?uni, • • • ,^i?5 ^ FO(DTC). By 7.4.1 there are log space-bounded Tur-
ing machines that evaluate (puni, • • •, ^RS • The intended machine writes the 
"structure" induced by v^uni, • • • ^^R^ o^i the oracle tapes and invokes its or-
acle to decide whether it belongs to O. 
D 
We prove the following well-known result from complexity theory. 
Proposition 12.4.2 Assume that L is a class of ordered structures that is 
ISIFTIME-complete with respect to logspace reductions. Then 
LOGSPACE^ 
= 
LOGSPACE^P^^^^. 
In particular, we have 
L 0 G S P A C E H ^ ^ < 
= 
L0GSPACEHENK< 
^ 
LOGSPACE^PT^^E. 
Proof. Obviously, we have LOGSPACE^ C L O G S P A C E ^ P T I M E r^^ p^^^^ 
the converse inclusion, let K C 0[T] and O C 0[a] with O G NPTIME, and 
let {MK,0) 
be a log space-bounded (r, cr)-oracle machine that accepts K. 
We have to show that K G LOGSPACE^. 
By 12.3.19 there is a sentence (po in FO(DTC)[rel-u;-QL][cr] such that 
O = Mod{ifo) and hence, by 12.4.1, there is a log space-bounded oracle 
machine {Mo,L) that decides O. 
We construct a log space-bounded oracle machine {M,L) that accepts 
K. Roughly, {M,L) runs as follows: Started with an ordered r-structure A, 
it imitates {MK,0). 
Suppose it reaches an oracle configuration of 
{MK,0). 
(M^L) does not have an oracle to decide whether the inscription J on the 
oracle tapes of {MK,0) 
encodes a structure in O. However, using its oracle 
for L, it now can imitate a run of {Mo,L) to answer the question whether 
J encodes a structure in O. For this purpose, (M, L) must use work tapes 
that carry the inscription J to simulate the input tapes of (Mo,L). But 
J, in general, is not log space-bounded in \\A\\. To overcome this difficulty, 
one applies the same trick as for 7.5.23, going always back to obtain the 
information on J needed in a given situation. 
To be more precise, consider a configuration c which is the starting con-
figuration of {MK, O) or the immediate successor of an oracle configuration 
of {MK-,0). 
Assume that there is a next oracle configuration c' and that 
the transition from c to c' leads to the inscription J on the oracle tapes of 
( M K , 0 ) . Assume that c is stored on an additional tape. In order to decide 
whether J encodes a structure in O, the information about J that (M^L) 
really needs, is of the kind 
"What letter stands in a certain cell of a certain oracle tape of 
{MK,o)r 
To provide such an information, {M,L) imitates {MK,0) 
starting from c, 
neglecting the oracle tapes, but using counters to mark the positions of the 
heads on the oracle tapes. Finally, (M, L) replaces the stored c by c'. 
D 

12.4 Quantifiers and Oracles 
333 
We come back to the question (+) of the introduction. For FO(IFP) and 
PTIME and for FO(DTC) and LOGSPACE we give positive answers, thereby 
proceeding in two steps (Proposition 12.4.3 and Proposition 12.4.4). 
Proposition 12.4.3 Let <G a and let O be a class of ordered a-structures. 
Then we have: 
(a) Every class in PTIME^ is 
FO{IFF){re\-cj-Qo)-axiomatizable. 
(b) Every class in LOGSPACE^ is 
FO{DTC){Ye\-u-Qo)-axiomatizable. 
In both (a) and (b) the axiomatizing sentence can be chosen without nested 
quantifiers from rel-cj-Qo-
Proof. We first prove (b). Let <G r and K C 0[T\ be accepted by some log 
space-bounded oracle machine (M, O). We have to show that K is axiomati-
zable in FO(DTC)(rel-cj-Qo). 
To give such an axiomatization, we proceed as in 7.3.7, using log space-
bounded configurations of (M, O) that only refer to the input tapes and to the 
work tapes; but now we describe the transition from one oracle configuration 
to the next one. For this purpose we assume that the oracle answer states 
s', s" in oracle instructions are distinct from each other and do not occur as 
successor states of other instructions. The main point here is to show that the 
predicates Oracle^ (w, U) and Oracle" (TZ,^;) as given below can be expressed 
in FO(DTC)(rel-tJ-Qo). Oracle+/-(i7,i;) says: 
- u is the starting configuration of (M, O) or a configuration with an oracle 
answer state; 
- F is an oracle configuration of (M, O); 
- I^ is reached from u without passing an oracle configuration in between; 
- if (M, O) is started in u with empty oracle tapes then, when reaching v, 
the oracle tapes contain/do not contain the encoding of a structure in O. 
The first three points do not cause difficulties; so we restrict ourselves to the 
last one. We consider the run of (M, O) that leads from u to v (u and v 
obeying the first three points above) as a run of a log space-bounded (r, a)-
transducer. Then we can apply Theorem 7.5.23 (more precisely: the obvious 
generalization involving the parameters u,v) to get, with a fixed e > 1, 
formulas 
(+) 
^uni(^,u, v) and IPR{XI, ... ,Xr,u, v) for R e a, R r-ary, 
in F O ( D T C ) [ T ] where x and the Xi have length e, and, with similar methods, 
a formula ^stT{u,v) in FO(DTC)[r] such that (pstr{u,v) says that 
after the run from utov 
the inscription on the oracle tapes encodes 
a cr-structure, namely {ipnni{-,u,v), 
{IPR{-, . . . , - 
,u,v))R^a)-
Then we see that 
V^(W,U) 
:= 
Qrel-e-OX, . . . {lpuni{x,U,v), 
{lpR{XR,U,v))Rea) 

334 
12. Quantifiers and Logical Reductions 
expresses that (ipunii-^u,!)), {IPR(-, ...,_ ,u,v))ji^a-) ^ O. Therefore, we can 
describe the fourth point of Oracle"*"(w,?;) by 
(pstv{u,v)Aip{u,v) 
and the fourth point of Oracle"(w, I;) by -'(/^'str(^^5 ^^) V -^ip{u,v). 
The proof of (a) is similar, referring to a PTIME analogue of Theorem 7.5.23 
(see Exercise 7.5.25). 
The additional remark of this proposition is obvious. 
D 
The preceding proof cannot be extended to PSPACE and FO(PFP). The rea-
son is that the oracle tapes of a polynomially space-bounded oracle machine 
may get inscriptions of length exponential in the length of the input structure 
and hence, may not be definable by means of an interpretation. One way to 
preserve the validity consists in changing the oracle model, say, by suitably 
restricting the use of the oracle tapes. 
We now turn to model checking: 
Proposition 12.4.4 Let <£ a and let O he a class of ordered a-structures. 
Then we have: 
(a) Every FO{JFF){ie\-{x)-(^o)-0'Xiomatizahle class of ordered structures is in 
PTIME^ {and hence, is decidable by a machine according to PTIME^). 
(b) Every class of ordered structures axiomatizable by an FO(DTC)(rel-L(;-
Qo)-sentence without nested quantifiers o/rel-cj-Qo is in LOGSPACE^ 
{and hence, is decidable by a machine according to LOGSPACE ). 
(c) The assertion in (b) is true for all 
FO(DTC){re\-(j-Qo)-axiomatizable 
classes of ordered structures if O is ISiPTlME-complete with respect to 
logspace reductions. 
Summing up: 
Corollary 12.4.5 (a) For any class O of ordered a-structures, FO (IFF) {lel-
cj-Qo) captures PTIME^. 
(b) // 0 is NFTIME-complete 
with respect to logspace reductions, then 
FO(DTC)(rel-a;-Qo) ca;)^wre5 LOGSPACE^. 
D 
Note that in (b), by 12.4.2, LOGSPACE^ = LOGSPACE^PTIME^ g^ 
FO(DTC)(rel-a;-Qo) captures LOGSPACENPTIME 
^OY example, we have 
FO(DTC)(rel-a;-QHAM<) captures LOGSPACE^^'^^^^. 
The preceding results yield normal form theorems for both the IFP and 
the DTC case: Over ordered structures, any FO(IFP)(rel-a;-Qo)-sentence 
is equivalent to a sentence without nested quantifiers from rel-cj-Qo- The 
same is true for FO(DTC)(rel-^-Qo) provided O is NPTIME-complete with 
respect to logspace reductions. 

12.4 Quantifiers and Oracles 
335 
Proof (of 1244). 
(a) We proceed by induction on FO(IFP)(rel-cj-Qo)-
formulas and confine ourselves to the rel-a;-Qo-step. So let 
^ = Qvel-k-OX,Xi, 
. . .,Xs[(Puni{x),^l{xi), 
. . 
.,(ps{Xs)] 
where a = {Ri,... 
,Rs} and (funi, ^i,- • • ,^s are FO(IFP)(rel-a;-Qo)[r]-
formulas. By induction hypothesis there are polynomially time-bounded or-
acle machines (Muni, O), (Mi, O),..., (Mg, O) that decide 
{{A,a) I A e 0[T],A 
H ^uni[a]},...,{(Aa) I (A G 0[rlA 
\= ^s[a]}, 
respectively. Using these machines, we can build a polynomially time-bounded 
oracle machine (M, O) deciding the class of ordered models of (p: Given an 
ordered r-structure A as input, 
(i) 
(M, O) checks whether Lp:^^^{-) is nonempty and whether (in case i^i = 
<) v^i^(-) is an ordering on ip-^^-^{^); if not, it rejects, otherwise (viewing 
(^uni, (/:'i,..., v^s) as an interpretation 11) 
(ii) using the ordering ipf(-), 
it writes the (encoding of the) structure 
^n = (^;f„.(_),^54(_),...,^^(_)) 
on some work tapes; 
(iii) it copies A^ on the oracle tapes; 
(iv) it envokes its oracle O to decide whether A^ belongs to O. 
Note that in (ii) we cannot write A^ directly on the oracle tapes, because 
these tapes may be used by the machines (Muni, O), (Mi, O),..., (M5, O) 
when constructing A^. 
(b) The proof follows the same pattern as that of (a). But now we write A^ 
directly on the oracle tapes; we can do so as the formulas (^uni, V^i, • • • ,^s 
do not contain quantifiers from rel-u;-Qo- One only has to check that the 
arguments remain valid if the polynomial time bounds are replaced by loga-
rithmic space bounds. 
(c) The proof is more involved. The reason is that, when following the pat-
tern of the proof of (a), we cannot realize (ii) by a log space-bounded oracle 
machine as the encoding of A^ may be of polynomial length, thus violating 
the logspace bound. We therefore proceed as follows: In the rel-a;-Qo-step of 
an inductive proof, let 
^ = Qrel-k-OX, Xi,...,Xs 
[(/?uni (^), (/?i ( x i ) , . . . , cps {Xg )] 
where </?uni, ^1, • • • ,^s are FO(DTC)(rel-Lj-Qo)[T]-formulas. By hypothesis, 
there are log space-bounded oracle machines (Muni, O),... 
deciding {{A, a) | 
^ G (9[r], ^ 1= (/?uni[a]},..., respectively. Using these machines, we now build 
a log space-bounded oracle transducer (M, O) that works as follows: Given an 

336 
12. Quantifiers and Logical Reductions 
ordered r-structure A as input, (M,0) 
checks whether (y^;^-(_) is nonempty 
and whether (pf(-) 
is an ordering on V^;^ni(-)5 ^^ ^^*' i* gives as output a 
fixed ordered cr-structure not in O (note that we may assume the existence 
of such a structure, the other case being trivial), otherwise it produces the 
output structure A^ (cf. (ii) in the proof of (a)). 
By construction of (M, O) we have: 
A\= (p 
iff 
(M, O), started with A, gives an output in O, 
i.e., the class of ordered models of ip is reducible to O via a log space-bounded 
oracle transducer. The next lemma tells us that we are done. 
D 
Lemma 12.4.6 Let O be a class of ordered a-structures that is NPTIME-
complete with respect to logspace reductions and let K be a class of ordered 
T-structures. Then we have: 
If K is reducible to O via a log space-bounded oracle transducer with oracle 
class O, then K belongs to LOGSPACE*^. 
For the proof we need a kind of join of classes: Let a and r be disjoint and 
P a unary relation symbol that does not belong to cr U r. For A G Str[(7] and 
B G Str[r] let AB be the (cr U r U {P})-structure 8 with (we assume that A 
and B are disjoint) 
- E : 
.pS 
-R' 
= A\JB 
:= B 
'- 
\ 
R^ 
liRea 
ifRer. 
We extend the join to the case that one argument is the "empty structure" 
by setting 
A9 
:= 
the expansion of ^ to a (a U r U {P})-structure S 
with P^ = 0 and i?^ = 0 for all R e T] 
W 
'.— the expansion of ;B to a (cr U r U {P})-structure 8 
with P^ ^ B and P^ = 0 for all R e a. 
Note that AB ^ A'B' imphes A ^ A' smd B ^ B'. For L C Str[a] and 
K C Str[r] let LK be the closure under isomorphisms of 
{A(l}\AeL}u{(l}B\BeK}. 
LK is a class of (cr U r U {P})-structures. Up to trivial expansions it consists 
of the structures in L and K. 
The proof of the following fact is routine. 
Lemma 12.4.7 // L and K are in NPTIME then (LK)^ 
is in NPTIME. 
D 

12.4 Quantifiers and Oracles 
337 
Proof (of 12.4-6)• Let O and K be given accordingly, and let K be reducible 
to O via the log space-bounded oracle transducer {M,0). 
By 12.4.2 it suf-
fices to show that K G LOGSPACE^PTIME^ J ^^ ^^la^ ^Yieie is a class O* in 
NPTIME and a log space-bounded oracle machine {M*,0*) that accepts K. 
Let (M, O) be started with an input structure of cardinality n. Thus, if 
n is sufficiently large, the part of the configurations of M comprising 
- the current state 
- the current inscriptions of the work tapes 
- the current position of the heads on both the input and the work tapes 
can be encoded by d numbers between 0 and n — 1 and hence, by d counters 
of length logarithmic in n. Here, d is a suitable positive number independent 
of n. 
Let Cn be the set of these partial configurations. The cardinality of Cn is 
< n^ and hence, polynomial in n. Given an input structure A of cardinality 
n, set 
Or(^) 
:= 
{(c, B) \ceCn 
and (M, O), started with A and with 
empty oracle tapes in configuration c, 
reaches a next oracle configuration, the oracle tapes then 
having an inscription that encodes B, and B ^ O}. 
Now, considering sets {1,... ,r} as structures (of empty vocabulary), we let 
L consist of the structures ^ { 1 , . . . , r} with r EN such that 
- ^ is an ordered r-structure; 
- there is a set {(ci, Hi),..., (c^., JB^)} C Or(^) with distinct ci,..., c^ such 
that (M, {Bi,..., 
Br}), started with A, gives an output in O. 
Then we have: 
(1) For A e 0[T] and r = ||0r(^)||, 
^ { l , . . . , r } e L 
iff 
AeK. 
(2) L< is in NPTIME. 
For (1) we note that (M, {B \ (c, B) G Or(^) for some c G Cn}) started with 
A behaves exactly like (M, O) started with A. 
To prove (2), one can define a (nondeterministic) machine that is polyno-
mially time-bounded and, started with an input structure X>, 
- checks whether V has the form (A{1,..., 
r}, <^) 
- nondeterministically guesses distinct configurations ci,... ,Cr G C'n^n 
- checks whether for alH G {1,..., r} there are Bi such that {ci,Bi) G Or(^) 
(note that O is in NPTIME) 
- runs {M,{Bi,...,Br}) 
on A 

338 
12. Quantifiers and Logical Reductions 
— accepts if the resulting output codes a structure in O (recall that O is in 
NPTIME). 
Now we set 
O* 
:= 
{0L)< 
which, by 12.4.7, belongs to NPTIME. Let a* be its vocabulary. 
We are finished if we succeed in defining a log space-bounded (r, cr*)-
oracle machine {M^^O"") that accepts K. We construct {M*^0*) in such a 
way that, started with an ordered r-structure A^ it 
— counts the number ro of configurations c G C].\A\\ such that {c^B) G Or(^) 
for some B (to test this condition, {M*^O*) imitates (M, O), starting with 
an ordered r- structure A in c; if it reaches a next oracle configuration of 
(M, O), the oracle tapes of {M""^O*)^ that correspond to symbols of a* \ a, 
are empty (and hence, code the empty relations); therefore, the inscription 
on the oracle tapes of (M, O) encodes a structure in O iff the inscription 
on the oracle tapes of {M*,0*) encodes a structure in O*, and 
{M*,0*) 
can check this by use of its oracle); 
— writes 0(v4{l,..., ro}) on its oracle tapes (more exactly, an ordered version, 
using the ordering of A) 
— asks the oracle whether 0(^{1,... ,ro}) G O* (or, equivalently, whether 
{A{l,...,ro})eL) 
— accepts just in case the answer is positive. 
By (1) we see that {M*,0*) accepts K. 
D 
In 7.5.18 we have introduced the polynomial hierarchy PH. The following 
exercise contains an alternative definition. The complexity classes NPTIME^ 
appearing there are defined in a similar way as the classes LOGSPACE . 
Exercise 12.4.8 Set PHQ := PTIME and PH^ := NPTIME^^'^-i for A: > 1. 
Show that PH'fc = PH^ for ah 
k>0. 
Notes 12.4.9 The notion of Lindstrom quantifier goes back to Lindstrom 
[118]; for further information see [31]. Various notions and results that we 
have treated in the book can be extended to logics with Lindstrom quantifiers; 
see, for example, [106, 27]. [89] discusses problems concerning the interplay 
between quantifiers and logical operators. The results of section 11.2 go back 
to [28] (Theorem 11.2.1), [80] (Theorem 11.2.3), and [16] (Theorem 11.2.5). 
For section 11.3, in particular Theorem 11.3.17, we refer to Dawar [24, 25]. 
Early references for reductions by interpretations are [120] and [22]. The 
results in section 11.4 are based on [51]; see also [53, 26]. Corollary 11.4.5(b) 
for HAM< goes back to Stewart [134]. 

References 
1. S. Abiteboul, R. Hull, and V. Vianu. Foundations of Data Bases. 
Addison-
Wesley, 1995. 
2. S. Abiteboul and V. Vianu. Fixpoint extensions of first-order logic and Datalog-
like languages. In Proc. 4th IEEE Symp. on Logic in Computer Science, pages 
71-79, 1989. 
3. S. Abiteboul and V. Vianu. Datalog extensions for database queries and up-
dates. Journal of Computer and System Sciences 43, 62-124, 1991. 
4. S. Abiteboul and V. Vianu. Generic computation and its complexity. In Proc. 
23rd ACM Symp. on Theory of Computing, pages 209-219, 1991. 
5. M. Ajtai and R. Fagin. Reachability is haxder for directed than for undirected 
finite graphs. Journal of Symbolic Logic 55, 113-150, 1990. 
6. M. Ajtai and Y. Gurevich. Monotone versus positive. Journal of the ACM ZA, 
1004-1015, 1987. 
7. M. Ajtai and Y. Gurevich. DATALOG vs. first-order logic. In Proc. 30th IEEE 
Symp. on Foundations of Computer Science, pages 142-146, 1989. 
8. J. Barwise. Admissible Sets and Structures. Springer, 1975. 
9. J. Barwise. An introduction to first-order logic. In J. Barwise (ed.), Handbook 
of Mathematical Logic, pages 5-46. North Holland, 1977. 
10. J. Barwise. On Moschovakis closure ordinals. Journal of Symbolic Logic 42, 
292-296, 1977. 
11. Th. Behrendt, K. Compton, and E. Gradel. Optimization problems: Express-
ibility, approximation properties, and expected asymptotic growth of optimal 
solutions. In E. Borger et al. (eds.), CSL '92, Lecture Notes in Computer Science 
702:43-60. Springer, 1993. 
12. A. Blass, Y. Gurevich, and D. Kozen. A zero-one law for logic with a fixed-point 
operator. Information and Control 67, 70-90, 1985. 
13. E. Borger, E. Gradel, and Y. Gurevich. 
The Classical Decision 
Problem. 
Springer, 1997. 
14. U. Bosse. 
An "Ehrenfeucht-Fraisse Game" for fixpoint logic and stratified 
fixpoint logic. In E. Borger et al. (eds.), CSL '92, Lecture Notes in Computer 
Science 702:100-114. Springer, 1993. 
15. J. R. Biichi. Weak second-order arithmetic and finite automata. Zeitschrift fur 
mathematische Logik und Grundlagen der Mathematik 6, 66-92, 1960. 

340 
References 
16. J. Cai, M. Fiirer, and N. Immerman. An optimal lower bound on the number of 
variables for graph identification. Combinatorica 12, 389-410, 1992. Extended 
abstract in Proc. 30th Symp. on Foundations of Computer Science, pages 612-
617, 1989. 
17. A. Calo and J.A. Makowsky. The Ehrenfeucht-Praisse game for transitive clo-
sure logic. In A. Nerode and M. Taitsin (eds.). Logical Foundation of Computer 
Science - Tver '92, Lecture Notes in Computer Science 620:57-68. Springer, 
1992. 
18. A. Chandra and D. Harel. 
Structure and complexity of relational queries. 
Journal of Computer and System Sciences 25, 99-128, 1982. Extended abstract 
in Proc. 21st Symp. on Foundations of Computer Science, pages 333-347, 1980. 
19. A. Chandra and D. Harel. Horn clause queries and generalizations. Journal of 
Logic Programming 1, 1-15, 1985. 
20. C. C. Chang and H. J. Keisler: Model Theory. North Holland, 3rd edition, 
1990. 
21. K. J. Compton. 0-1 laws in logic and combinatorics. In I. Rival (ed.), NATO 
Advanced Study Institute on Algorithms and Order, pages 353-383. D. Reidel, 
1989. 
22. E. Dahlhaus. Reductions to NP-complete problems by interpretations. 
In 
E. Borger et al. (eds.). Logic and Machines: Decision Problems and Complexity, 
Lecture Notes in Computer Science 171:357-365. Springer, 1983. 
23. E. Dahlhaus. Skolem normal forms concerning the least fixpoint. In E. Borger 
(ed.). Computation 
theory and Logic, Lecture Notes in Computer 
Science 
270:101-106. Springer, 1987. 
24. A. Dawar. Feasible Computation through Model Theory. PhD thesis, University 
of Pennsylvania, 1993. 
25. A. Dawar. Generalized quantifiers and logical reducibilities. Journal of Logic 
and Computation 5, 213-226, 1995. 
26. A. Dawar, G. Gottlob, and L. Hella. Capturing relativized complexity classes 
without order. Mathematical Logic Quarterly 44, 109-122, 1998. 
27. A. Dawar and E. Gradel. Generalized quantifiers and 0-1 laws. In Proc. 10th 
IEEE Symp. on Logic in Computer Science, pages 54-64, 1995. 
28. A. Dawar and L. Hella. The expressive power of finitely many generalized 
quantifiers. In Proc. 9th Symp. on Logic in Computer Science, pages 20-29, 
1994. 
29. A. Dawar, L. Hella, and Ph. G. Kolaitis. Implicit definability and infinitary 
logic in finite model theory. In Proceedings of the 22nd International 
Collo-
quium on Automata, Languages, and Programming (ICALP 95), Lecture Notes 
in Computer Science 944:624-635. Springer, 1995. 
30. A. Dawar, S. Lindell, and S. Weinstein. Infinitary logic and inductive definabil-
ity over finite structures. Information and Computation 119, 160-175, 1995. 
31. H.-D. Ebbinghaus. Extended logics: The general framework. In J. Barwise and 
S. Feferman (eds.), Model-Theoretic Logics, pages 25-76. Springer, 1985. 

References 
341 
32. H.-D. Ebbinghaus, J. Flum, and W. Thomas: Mathematical Logic. Springer, 
2nd edition, 1994. 
33. A. Ehrenfeucht. 
An application of games to the completeness problem for 
formalized theories. Fundamenta Mathematicae 49, 129-141, 1961. 
34. T. Eiter, G. Gottlob, and Y. Gurevich. Normal forms for second-order logic 
over finite structures, and classification of NP optimization problems. Annals 
of Pure and Applied Logic 78, 111-125, 1996. 
35. H. B. Enderton: A Mathematical Introduction to Logic. Academic Press, New 
York, 1972. 
36. R. Fagin. Generalized first-order spectra and polynomial-time recognizable 
sets. In R. M. Karp (ed.). Complexity of Computation, SIAM-AMS 
Proceedings 
7:43-73, 1974. 
37. R. Fagin. Probabilities on finite models. Journal of Symbolic Logic 41, 50-58, 
1976. 
38. R. Fagin. The number of finite relational structures. Discrete Mathematics 19, 
17-21, 1977. 
39. R. Fagin, L. J. Stockmeyer, and M. Y. Vardi. A simple proof that connectiv-
ity separates existential and universal monadic second-order logics over finite 
structures. Research Report RJ 8647, IBM, 1992. 
40. J. Flum. On bounded theories. In E. Borger et al. (eds.), CSL '91, Lecture 
Notes in Computer Science 626:111-118. Springer, 1992. 
41. J. Flum. On the (infinite) model theory of fixed point logics. In X. Caicedo 
et al. (eds.). Models, Algebras, and Proofs, Lecture Notes in Pure and Applied 
Mathematics 203:67-75. Dekker, 1999. 
42. J. Flum, M. Kubierschky, and B. Ludascher. Total and partial well-founded 
datalog coincide. In E. Afrati and Ph. G. Kolaitis (eds), Proc. 6th International 
Conference on Database Theory (ICDT), Lecture Notes in Computer Science 
1186:113-124. Springer, 1997. 
43. R. Fraisse. Sur quelques classifications des systemes de relations (English sum-
mary). Universite d'Alger, Publications Scientifiques, Serie A, 1, 35-182', 1954. 
44. M. Flirer. The computational complexity of the unconstrained limited domino 
problem (with implications for logical decision problems). In Logical Machines: 
Decision Problems and Complexity, Lecture Notes in Computer Science 171:312-
319. Springer, 1981. 
45. H. Gaifman. On local and nonlocal properties. In J. Stern (ed.). Logic Collo-
quium '81, pages 105-135. North Holland, 1982. 
46. M. R. Garey and D. S. Johnson: Computers and Intractability - A Guide to 
the Theory of NP-Completeness. 
W. H. Freeman and Co., 1979. 
47. Y. V. Glebskij, D. I. Kogan, M. I. Liogon'kij, and V. A. Talanov. Range and de-
gree of realizability of formulas in the restricted predicate calculus. Cybernetics 
5, 142-154, 1969. 
48. K. Godel. Ein Spezialfall des Entscheidungsproblems der theoretischen Logik. 
Ergebnisse eines mathematischen 
Kolloquiums 2, 27-28, 1929. 

342 
References 
49. W. Goldfarb. The unsolvability of the Godel class with identity. Journal of 
Symbolic Logic 49, 1237-1252, 1984. 
50. W. D. Goldfarb, Y. Gurevich, and S. Shelah. 
A decidable subclass of the 
minimal Godel class with identity. Journal of Symbolic Logic 49, 1253-1261, 
1984. 
51. G. Gottlob. Relativized logspace and generalized quantifiers over finite struc-
tures. Journal of Symbolic Logic 62, 545-574, 1997. 
52. G. Gottlob, N. Leone and H. Veith. Succinctness as a source of complexity in 
logical formalisms. Annals of Pure and Applied Logic 97, 231-260, 1999. 
53. E. Gradel. On logical descriptions of some concepts in structural complexity 
theory. In E. Borger et al. (eds.), CSL ^89, Lecture Notes in Computer Science 
440:163-175. Springer, 1990. 
54. E. Gradel. On transitive closure logic. In E. Borger et al. (eds.), CSL ^91, 
Lecture Notes in Computer Science 626:149-163. Springer, 1992. 
55. E. Gradel, Ph. G. Kolaitis, and M. Y. Vardi. On the decision problem for 
two-variable first-order logic. Bulletin of Symbolic Logic 3, 53-69, 1997. 
56. E. Gradel and G. McColm. Deterministic versus nondeterministic transitive 
closure logic. In Proc. 7th IEEE Symp. on Logic in Computer Science, pages 
58-63, 1992. 
57. E. Gradel and M. Otto. Inductive definability with counting on finite structures. 
In E. Borger et al. (eds.), CSL '92, Lecture Notes in Computer Science 702:231-
247. Springer, 1993. 
58. E. Gradel and M. Otto. On logic with two variables. Theoretical 
Computer 
Science, to appear. 
59. E. Gradel, M. Otto and E. Rosen. Two-variable logic with counting is decidable. 
In Proc. 12th IEEE Symp. on Logic in Computer Science, pages 306-317, 1997. 
60. E. Gradel, M. Otto and E. Rosen. Undecidability results on two variable logics. 
Archive for Mathematical Logic, to appear. Extended abstract in Proc. 14th 
Symp. on Theoretical Aspects of Computer Science STACS '97. Lecture Notes 
in Computer Science 1200:249-260. Springer, 1997. 
61. M. Grohe. Fixpunktlogiken in der endlichen Modelltheorie. 
Master's thesis, 
University of Freiburg i.Br., 1992. 
62. M. Grohe. The structure of fixed-point logics. PhD thesis. University of Freiburg 
i.Br., 1994. 
63. M. Grohe. Complete problems for fixed-point logics. Journal of Symbolic Logic 
60, 517-527, 1995. 
64. M. Grohe. Arity hierarchies. Annals of Pure and Applied Logic 82, 103-163, 
1996. 
65. M. Grohe. Fixed-point logics on planar graphs. In Proceedings 13th IEEE 
Symp. on Logic in Computer Science, pages 6-15, 1998. 
66. M. Grohe. Finite variable logic in descriptive complexity. Bulletin of Symbolic 
Logic 4, 345-398, 1998. 

References 
343 
67. M. Grohe and L. Hella. A double arity hierarchy theorem for transitive closure 
logic. Archive for Mathematical Logic 35, 157-171, 1996. 
68. M. Grohe and J. Mariiio. Definability and descriptive complexity on databases 
of bounded tree width. In Proc. 7th Intern. Conference on Database Theory, 
Jerusalem 1998. 
69. M. Grohe and T. Schwentick. Locality of order-invariant first-order formulas. In 
Proc. 23rd Intern. Symp. on Math. Foundations in Computer Science, Lecture 
Notes in Computer Science 1450:75-95. Springer, 1998. 
70. Y. Gurevich. Toward logic tailored for computational complexity. In M. M. 
Richter et al. (eds.), Computation and Proof Theory, Lecture Notes in Mathe-
matics 1104:175-216. Springer, 1984. 
71. Y. Gurevich. Logic and the challenge of computer science. In E. Borger (ed.). 
Current Trends in Theoretical Computer Science, pages 1-57. Computer Science 
Press, 1988. 
72. Y. Gurevich. Zero-one laws. Bulletin of the European Association for Theoret-
ical Computer Science 46, 90-106, 1992. 
73. Y. Gurevich. Prom invariants to canonization. Bulletin of the European Asso-
ciation for Theoretical Computer Science 63, 115-119, 1997. 
74. Y. Gurevich, N. Immerman, and S. Shelah. McColm's conjecture. In Proc. 9th 
IEEE Symp. on Logic in Computer Science, pages 10-19, 1994. 
75. Y. Gurevich and S. Shelah. Random models and the Godel case of the decision 
problem. Journal of Symbolic Logic 48, 1120-1124, 1983. 
76. Y. Gurevich and S. Shelah. Pixed-point extensions of first-order logic. Annals 
of Pure and Applied Logic 32, 265-280, 1986. 
77. Y. Gurevich and S. Shelah. On finite rigid structures. Journal of Symbolic 
Logic 61, 549-562, 1996. 
78. P. Hajek. On logics of discovery. In G. Goos and J. Hartmanis (eds.), Proc. 4th 
Conference on Mathematical Foundations of Computer Science, Lecture Notes 
in Computer Science 32:100-114. Springer, 1977. 
79. W. Hanf. Mo del-theoretic methods in the study of elementary logic. In J. Ad-
dison, L. Henkin, and A. Tarski (eds.). The Theory of Models, pages 132-145. 
North Holland, 1965. 
80. L. Hella. Logical hierarchies in PTIME. In Proc. 7th IEEE Symp. on Logic in 
Computer Science, pages 360-368, 1992. 
81. L. Hella, Ph. G. Kolaitis, and K. Luosto. How to define a linear order on finite 
models. In Proc. 9th IEEE Symp. on Logic in Computer Science, pages 40-49, 
1994. 
82. L. Hella, Ph. G. Kolaitis, and K. Luosto. Almost everywhere equivalence of 
logics in finite model theory. Bulletin of Symbolic Logic 2, 422-443, 1996. 
83. L. Hella, L. Libkin, and Y. Nurmonen. Notions of locality and their logical 
characterizations over finite models. Journal of Symbolic Logic, to appear. 
84. L. Henkin. Logical systems containing only a finite number of symbols. Les 
Presses de I'Universite de Montreal. 48 pages, 1967. 

344 
References 
85. J. Hintikka. Distributive normal forms in the calculus of predicates. 
Acta 
Philosophica Fennica 6, 1-71, 1953. 
86. I. Hodkinson. Finite variable logics. Bulletin of the European Association for 
Theoretical Computer Science 51, 111-140, 1993. 
87. J. Hopcroft and J. Ullman: Introduction to Automata Theory, Languages and 
Computation. Addison Wesley, 1979. 
88. H. Imhof. Computational aspects of arity hierarchies. In: D. van Dalen and 
M. Bezem (eds.), CSL '96, Lecture Notes in Computer Science 1258:211-225. 
Springer, 1997. 
89. H. Imhof. Fixed-point logic, generalized quantifiers, and oracles. Journal of 
Logic and Computation 7, 405-425, 1997. 
90. N. Immerman. Upper and lower bounds for first-order expressibility. Journal 
of Computer and System Sciences 25, 76-98, 1982. 
91. N. Immerman. Relational queries computable in polynomial time. 
Information 
and Control 68, 86-104, 1986. Extended abstract in Proc. 14th Annual ACM 
Symp. on Theory of Computing, pages 147-152, 1982. 
92. N. Immerman. Expressibility as a complexity measure: results and directions. 
In Second Structure in Complexity Conference, pages 194-202. IEEE Computer 
Society Press, 1987. 
93. N. Immerman. Languages that capture complexity classes. SIAM Journal on 
Computing 16, 760-778, 1987. Extended abstract in Proc. 15th Annual ACM 
Symp. on Theory of Computing, pages 347-354, 1983. 
94. N. Immerman. Nondeterministic space is closed under complement. 
SIAM 
Journal on Computing 17, 935-938, 1988. 
95. N. Immerman. Descriptive Complexity. Springer, 1998. 
96. N. Immerman and D. Kozen. Definability with a bounded number of bound 
variables. Information and Computation 83, 121-139, 1989. 
97. N. Immerman and E. S. Lander. Describing graphs: a first-order approach to 
graph canonization. In A. Selman (ed.). Complexity Theory Retrospective, pages 
59-81. Springer, 1990. 
98. M. Kaufmann. A counterexample to the 0-1 law for existential monadic second-
order logic. Computational Logic Inc., Internal Note 32, 1987. 
99. M. Kaufman and S. Shelah. On random models of finite power and monadic 
logic. Discrete mathematics 54, 285-293, 1985. 
100. H. J. Keisler: Model Theory for Infinitary Logic. North Holland, 1971. 
101. Ph. G. Kolaitis. Implicit definability on finite structures and unambiguous 
computations. In Proc. 5th IEEE Symp. on Logic in Computer Science, pages 
168-180, 1990. 
102. Ph. G. Kolaitis. The expressive power of stratified logic programs. Information 
and Computation 90, 50-66, 1991. 
103. Ph. G. Kolaitis and M. N. Thakur. Polynomial-time optimization, parallel ap-
proximation, and fixedpoint logic. In Proc. 8th Annual Structure in Complexity 
Conference, pages 31-41, 1993. 

References 
345 
104. Ph. G. Kolaitis and M. N. Thakur. Logical definability of NP-optimization 
problems. Information and Computation 115, 321-353, 1994. 
105. Ph. G. Kolaitis and M. N. Thakur. Approximation properties of NP min-
imization classes. 
Journal of Computing and System Sciences 50, 391-411, 
1995. Extended abstract in Proc. 6th IEEE Symp. on Structure in Complexity 
Theory, pages 353-366, 1991. 
106. Ph. G. Kolaitis and J. Vaananen. Generalized quantifiers and pebble games 
on finite structures. Annals of Pure and Applied Logic 74, 23-75, 1995. 
107. Ph. G. Kolaitis and M. Y. Vardi. The decision problem for the probabilities of 
higher order logics. In Proc. 19th ACM Symp. on Theory of Computing, pages 
425-435, 1987. 
108. Ph. G. Kolaitis and M. Y. Vardi. 0-1 laws and decision problems for frag-
ments of second-order logic. Information and Computation 87, 302-338, 1990. 
Extended abstract in Proc. 3rd IEEE Symp. on Logic in Computer 
Science, 
pages 2-11, 1988. 
109. Ph. G. Kolaitis and M. Y. Vardi. Infinitary logic and 0-1 laws. Information and 
Computation 98, 258-294, 1992. Extended abstract in Proc. 5th IEEE 
Symp. 
on Logic in Computer Science, pages 156-167, 1990. 
110. Ph. G. Kolaitis and M. Y. Vardi. Fixpoint logic vs. infinitary logic in finite 
model theory. In Proc. 7th IEEE Symp. on Logic in Computer Science, pages 
46-57, 1992. 
111. Ph. G. Kolaitis and M. Y. Vardi. 0-1 laws for fragments of second-order logic: 
an overview. In Y. N. Moschovakis (ed.), Logic from Computer Science, pages 
265-286. Springer, 1992. 
112. M. Kubierschky. Remisfreie Spiele, Fixpunktlogiken und Normalformen. 
Mas-
ter's thesis. University of Freiburg i.Br., 1995. 
113. M. Kubierschky. Yet another hierarchy theorem. Journal of Symbolic Logic, 
to appear. 
114. J.-M. Le Bars. Fragments of existential second-order logic without 0-1 laws. 
In Proc. 13th IEEE Symp. on Logic in Computer Science 1998, to appear. 
115. L. Libkin. On the forms of locality over finite models. In Proc. 12th IEEE 
Symp. on Logic in Computer Science, pages 204-215, 1997. 
116. L. Libkin. On counting and local properties. In Proc. 13th IEEE Symp. on 
Logic in Computer Science 1998, to appear. 
117. S. Lindell. An analysis of fixed point queries on binary trees. 
Theoretical 
Computer Science 85, 75-95, 1991. 
118. P. Lindstrom. First order predicate logic with generahzed quantifiers. Theoria 
32, 186-195, 1966. 
119. A. Livchak. The relational model for process controU. (Russian) 
Automated 
Documentation 
and Mathematical Linguistics 4, 27-29, 1983. 
120. L. Lovasz and P. Gacs. Some remarks on generalized spectra. Zeitschrift fur 
Mathematische Logik und Grundlagen der Mathematik 23, 547-554, 1977. 

346 
References 
121. M. Mortimer. On languages with two variables. Zeitschrift fiir Mathematische 
Logik und Grundlagen der Mathematik 21, 135-140, 1975. 
122. Y. N. Moschovakis: Elementary 
Induction 
on Abstract Structures. 
North 
Holland, 1974. 
123. W. Oberschelp. Asymptotic 0-1 laws in combinatorics. In D. Jungnickel (ed.). 
Combinatorial 
theory, Lecture Notes in Mathematics 
969:276-292. Springer, 
1982. 
124. M. Otto. The expressive power of fixed-point logic with counting. Journal of 
Symbolic Logic 61, 147-176, 1996. 
125. M. Otto. Bounded Variable Logics and Counting. A Study in Finite Models. 
Lecture Notes in Logic 9. Springer, 1997. 
126. L. Pacholski and W. Szwast. The 0-1 law fails for the class of existential 
second-order Godel sentences with equality. In Proceedings 30th IEEE 
Symp. 
on Foundations of Computer Science, pages 160-163, 1989. 
127. L. Pacholski, W. Szwast, and L. Tendera. Complexity of two-variable logic 
with counting. In Proc. 12th IEEE Symp. on Logic in Computer Science, pages 
318-327, 1997. 
128. C. H. Papadimitriou. Computational Complexity. Addison-Wesley, 1994. 
129. C. H. Papadimitriou and M. Yannakakis. Optimization, approximation, and 
complexity. In Proc. 20th ACM Symp. on Theory of Computing, pages 229-234, 
1988. 
130. B. Poizat. Deux ou trois choses que je sais de Ln- Journal of Symbolic Logic 
47, 641-658, 1982. 
131. D. Scott. A decision method for validity of sentences in two variables. Journal 
of Symbolic Logic 27, 477, 1962. 
132. S. Shelah and J. Spencer. Zero-one laws for sparse random graphs. Journal 
of the AMS 1, 97-115, 1988. 
133. J. R. Shoenfield: Mathematical Logic. Addison-Wesley, Reading, MA, 1967. 
134. I. A. Stewart. Using the Hamiltonian path operator to capture NP. Journal 
of Computer and System Sciences 45, 127-151, 1992. 
135. A. Stolboushkin. Finitely monotone properties. In Proc. 10th IEEE Symp. on 
Logic in Computer Science, pages 324-330, 1995. 
136. H. Straubing: 
Finite Automata, 
Formal Logic, and Circuit 
Complexity. 
Birkhauser, 1994. 
137. R. Szelepcsenyi. The method of forced enumeration for nondeterministic au-
tomata. Acta Informatica 26, 279-284, 1988. 
138. W. Thomas. Languages, Automata, 
and Logic. Report 9607. Institute for 
Computer Science and Applied Mathematics. University of Kiel, 1996. 
139. B. Trahtenbrot. The impossibility of an algorithm for the decision problem 
for finite domains. (Russian) Doklady Academii Nauk SSSR 70, 569-572, 1950. 
English translation: American Mathematical Society, Translations, Series 2 23, 
1-5, 1963. 

References 
347 
140. B. Trahtenbrot. 
Finite automata and the logic of monadic predicates. 
(Russian). 
Sibirskij Mat. Zhurnal 3, 103-131, 1962. Extended abstract in 
Doklady Academii Nauk SSSR 140, 326-329, 1961. English translation: Soviet 
Physics. Doklady 6, 753-755, 1961. 
141. J. Tyszkiewicz. On asymptotic probabilities of monadic second order prop-
erties. In E. Borger et al. (eds.), CSL '91, Lecture Notes in Computer Science 
626:425-439. Springer, 1992. 
142. M. Y. Vardi. The complexity of relational query languages. In Proc. 14th 
ACM Symp. on Theory of Computing, pages 137-146, 1982. 
143. M. Y. Vardi. On the complexity of bounded-variable queries. In Proc. 14th 
ACM Symp. on Principles of Data Base Systems, pages 266-276, 1995. 
144. M. Y. Vardi. What makes a modal logic so robustly decidable? In Descriptive 
Com,plexity and Finite Models. American Mathematical Society, 1997. 
145. S. Vinner. A generalization of Ehrenfeucht's game and some applications. 
Israel Journal of Mathematics 12, 279-298, 1972. 
146. P. Winkler. Random structures and zero-one laws. In N. W. Sauer et al. (eds.), 
Finite and infinite combinatorics in sets and logic, NATO Advanced Science 
Institutes Series, pages 399-420. Kluver, 1993. 

Index 
T,a, 1 
R-^, c^, R^, c^, 1 
R'^ai.. 
.an, 1 
{<, 5, min, max}, 3 
To, 3 
OH 
3 
A\T,3 
A 
^5,3 
AxB,3 
AOB, 
A<]B,4: 
A\ 
U/^, <iA, 4 
ll^ll, 4 
-, V, 3,4 
A, -^, o , V, 5 
X, (^(x), 6 
A [= (y:?[ai,..., an], A\=^ ^, 
qr(<^), 7 
^ n , J-J-n; ^ n ? 7 
<^ 
(y^(tl,. .. , t n ) , 7 
3^", 7 
3=^, 3^^, 8 
V?>n, V^=ri, 9^<n, 8 
A = B,<d 
^ ^ ( - ) , 10 
^ =m B, 14 
p C g, a 1-^ 6, 15 
Gm{AB), 
17 
^^3,^,^3, ^^(^), 18 
W^^(A^), 20 
^z, 23 
^/, A , 24 
IT"^(^,a), 26 
5(r,a), 26 
^, 20 
.MSO B, 38 
MS0-G.n(v4,^), 38 
^ i p ' 38 
( M ) E L (M)ni, 39 
Ai, 40 
V ^ , 40 
A ^ , 4 1 
^ = ^ - - ^ , 4 2 
Goo(A a, H, 6), 42 
^ =part ^, / : .4 ^part B, 43 
T^ooCAB), 43 
Trand, 45 
T 5 
T O ; 
A^ 
^ =^ .B, ^ =^--H, ^ =tn B, 48 
a f , 5 0 
G ^ ( A « , ^ , ^ ) , G L ( A a , ^ , 6 ) , 50 

350 
Index 
G^(A^), G^(A^), 50 
A ^^art 8,1: A ^Jart H, 51 
^^, ^«,^, « , 52 
T^^(A^), H^ci>(A^), 52 
A/s, 54 
r(^), 57 
FO(C), Looc.(C), Cooa;,59 
3^^ 59 
FO(Cr,C^^^,C^^,59 
C-Gtn{A,a,B,b), 
C-Glo{A,a,B,b), 60 
i^<,64 
L ^ W , L,(^), L„(r), ln{K), 71 
Z(X), ^n(</^), /(^), 72 
-'rand5 
'^ 
ln{K\H), 
1{K\H), 74 
T'randCv^o), 76 
t/n W , l^n W , U{K), 77 
t^n(i^|i?), 77 
«(i^|i:f), 78 
El(V*3*), El(3*V*), 86 
A, A*, A+, 105 
A, 105 
NDA, S, L{M), 106 
It^l, 107 
L+, 108 
Bu, 109 
Fn, Foo, F^, 120 
>Ci < £2, /^i = >C2, Ci < £2, 122 
£[r], 122 
TC, DTC, 123 
So, s+, S-, 125, 133 
lilr, lii:^, 131 
co-C, 155 
r<, K < , 156 
Str[T], 158 
PH, 159 
[WV^,x^l 169 
[GFP^,xV^(^,X)]^, 172 
Floo)^ 174 
3(V)j;t/'(x), 179 
<5-(a:i,... ,xi,v,w), 
179 
(/.(y_y), 179 
#xy:', 208 
^ =J^ B, 213 
MLFP-G,n(v4,^), 213 
^^1^^,217 
T C - G ; ; , ( A 5 ) , 229 
7 ^71,...,7/, 239 
(r,n)int, (r,n)ext, 239 
Tint, Text, 239 
Pin). Ploo). 240 
^[n], (n,p)?, 240 
^[E], (E,P)t, 241 
(n, P)t, 246 
(n,g)f, 249 
£[r]o, N'''^ 289 
£ =es (^, 290 
(M,/), 290 
£ =es C on 5, 296 
^", V;-", 297 
(5x^l,...,^s[V^l(^l),. •• 
Qxip{x), 309 
£(gx), £(Q), 309 
K^, 312 
Q x , 312 
L^c.(Q), 314 
K <cL, K <Jl L, 321 
rel-L, rel-A;-L, 322 
Qrei-fc-L, rel-cj-QL, 322 
£[Q], 323 
(M,0), 331 
C^, C^, 331 
^;B, 336 
ipsC^s)], 308 

Index 
351 
accept, 126, 132 
acceptable, 126 
acceptor, 162 
almost all, 72 
alphabet, 105 
antitone, 167, 172, 192 
approximable, 280 
APX, 281 
arity, 1 
- of a quantifier, 309 
arity hierarchy, 268, 272, 273 
assignment, 6 
ATC, 261 
automaton, 106 
- deterministic, 106 
- nondeterministic, 106 
axiomatizable 
- in a logic, 124 
- in FO, 14, 20, 150, 252 
- in FO(DTC)(rel-a;-Qo), 333, 334 
- in FO(IFP)(rel-cj-Qo), 333, 334 
- in FO(M-LFP), 217 
- i n F O ^ 54 
- in La;iw, 41 
- in L^^, 53 
- in L^^, 53 
- in SO, 150 
back property, 20 
- S-, 51 
ball, 26 
- r-, 26 
base of an instruction, 132 
basic term, 248 
Beth property, 63 
Beth's Theorem, 63 
blank letter, 125, 130 
body of a clause, 239 
bounded, 57, 58 
- S-, 57 
- fixed-point, 204 
breadth 
- of a DATALOG program, 242 
- of an S-DATALOG program, 242 
canonization 
- C-, 294 
- C- on S, 301 
- LOGSPACE-, 294 
- PSPACE-, 294 
- PTIME-, 291-293 
capture, 157 
- a complexity class, 151, 288 
- effectively strongly, 290, 295, 325 
- effectively strongly on S, 296 
- PTIME effectively strongly, 290, 292, 
294, 300 
- PTIME effectively strongly on 
GRAPH, 300 
- strongly, 157, 288 
cardinality, 4 
cell, 125 
- virtual, 125, 130 
circuit 
- Hamiltonian, 2, 113, 327 
class 
- bounded, 57 
- elementary, 14 
- elementary relative to, 14 
- finitely axiomatizable, 14 
- fixed-point bounded, 204 
- free parametric, 80 
- indiscernible, 222 
- nontrivial free parametric, 80 
- nontrivial parametric, 77 
- of finite structures, 14 
- of structures, 10 
- parametric, 75 
- s-bounded, 57 
- s-rigid, 204 
clause, 239 
clique, 2, 113 
closed subset, 222 
closed under isomorphisms, 10 
closure 
- alternating transitive, 261 
- deterministic transitive, 123, 220 
- plus, 108 
- positive, 108 
- transitive, 123, 220 
colour type, 61 
Compactness Theorem, 8 
compatible, 76 
complement of a complexity class, 155 
complete 
- NPTIME- with respect to FO(DTC) 
reductions, 328 
- NPTIME- with respect to logspace 
reductions, 327, 328 
- strongly PTIME- with respect to 
FO-reductions, 325 
- with respect to C-reductions, 321 
- with respect to /^-reductions, 324 
Completeness Theorem, 8 
complexity class 
- as a class of ordered structures, 153 

352 
Index 
- in complexity theory, 153 
component 
- connected, 2, 30 
- of a graph, 2 
computable 
- PTIME-, 204, 291 
concatenation of languages, 107 
configuration, 128, 134 
- accepting, 134 
- oracle, 331 
- starting, 136 
CONN, 2, 23, 122 
connected component, 30 
connective, 4 
co-NPTIME, 157 
consequence, 6 
constant, 1 
constant symbol, 1 
cost, 276 
counting quantifier, 59, 309 
Craig property, 64 
Craig's Theorem, 64 
cut, 275 
cycle, 2, 302 
database, 119 
- relational, 12 
DATALOG, 239 
- I-, 245 
- P-, 248 
- positive, 245, 250 
- S-, 241 
- stratified, 241 
- totally defined WF-, 265 
- well-founded, 264 
- WF-, 264 
- with counting, 248 
DATALOG = E(LFP), 243, 245 
DATALOG program, 239 
DATALOGr 
- S-, 242 
DATALOG(#), 248 
decidability 
- of validity for V^ 3*, 100 
- of validity for F 0 ^ 98 
decidable, 126 
definable 
- explicitly, 63 
- implicitly, 63, 217 
- in first-order logic, 114 
degree of a point in a graph, 2 
depth, 170 
deterministic transitive closure, 123, 
220 
diameter of a graph, 85 
digraph, 1 
- acyclic, 24, 30, 253 
distance function 
- in a graph, 2, 23 
- in an ordering, 22 
distinct, 75 
do(p), 15 
domain, 1 
DTC, 123, 220 
duplicator, 16 
E(LFP), 243 
edge, 1 
Ehrenfeucht's Theorem, 18 
Ehrenfeucht-Fraisse see game 
element 
- existential, 261 
- universal, 261 
enumerable, 126 
enumeration 
- effective of a complexity class, 295 
equality symbol, 4 
equivalence relation 
- invariant, 107, 111 
equivalent, 7 
- elementarily, 9 
- logically, 6 
~ 
•L'OOU)~5 
^ • ^ 
- m-, 14 
- m- in MSO, 38, 39 
- on ordered structures, 152 
EVEN, 199, 209 
EVEN[r], 21, 37, 41, 53, 59, 72, 156 
existence of a fixed-point, 166 
expression 
- plus free regular, 114 
- regular, 108 
expressive power of a logic, 122 
extension axiom, 45, 53, 72 
extensional, 239 
F (truth value), 7 
FALSE, 7, 10, 11, 241 
feasible solution, 276 
finite model property, 95 
- of V^a*, 100 
- of 3*V'3*, 103 
- of FO^ 96, 99 
- of modal logic, 99 
fixed-point, 120, 166 
- greatest, 167, 172 
- least, 167 

Index 
353 
- simultaneous, 174 
- simultaneous least, 175 
fixed-point logic see logic, fixed-point 
FO, 4 
FO = S-DATALOGo, 243 
F 0 ^ 47 
FO(ATC), 261, 314 
FO(BFP), 235 
FO(BFP) < FO(LFP), 237 
FO(BFP) = S-DATALOG, 242 
FO(BFP0, 236 
FO(C), 59 
FO(C)^ 59 
FO(DTC), 123, 327 
FO(DTC) and LOGSPACE, 142, 148, 
151, 296, 304 
FO(DTC) < F0(IFP2), 273 
FO(DTC) < FO(LFP^), 271 
FO(DTC) < FO(LFP^), 270 
FO(DTC) < FO(PFP), 272 
FO(DTC) < FO(PFP'), 271 
FO(DTC) < F0(PFP2), 269 
FO(DTC) ^ FO(TC), 223 
FO(DTC)(rel-cj-QHAM<), 334 
FO(DTC)[rel-a;-QHAM<], 328 
FO(DTC^), 268 
FO(IFP), 121, 169 
FO(IFP) and FO(PFP), 154 
FO(IFP) and PTIME, 138, 149, 151, 
297, 302 
FO(IFP) = FO(S-IFP), 179 
FO(IFP) = I-DATALOG, 246 
FO(IFP) = Sl, 155 
FO(IFP) = SO, 155 
FO(IFP^), 268 
FO(IFP, #), 208 
FO(IFP, # ) and PTIME, 305, 306, 315 
FO(IFP, # ) = DATALOG(#), 248 
FO(IFP, # ) = FO(PFPpTjj^E.#). 210 
FO(LFP), 170 
FO(LFP) < Aj, 212 
FO(LFP) = E(LFP), 244 
FO(LFP) = FO(ATC), 261 
FO(LFP) = FO(IFP), 173 
FO(LFP) = FO(PFP), 203, 204 
FO(LFP) = F O ( P F P P T I M E ) , 205, 206 
FO(LFP) = FO(S-LFP), 179 
FO(LFP) < IMP(FO), 219 
FO(LFP) < L^^ n PTIME , 206 
FO(LFP) = WF-DATALOG, 265 
FO(LFP"), 268 
FO(LFP^) < FO(IFP^), 273 
FO(M-LFP), 212 
FO(PFP), 121, 191 
FO(PFP) and PSPACE, 137, 149, 151 
FO(PFP) = FO(S-PFP), 193 
FO(PFP) = IMP(FO(PFP)), 219 
F O ( P F P ) < L ^ , , 199 
FO(PFP) = P-DATALOG, 249 
FO(PFP^), 268 
F O ( P F P P T I M E ) , 
205 
FO(PFPp^j^E'#)'210 
FO(PFP, # ) , 209 
FO(PFP, # ) < C ^ ^ , 2 0 9 
F0(3-PFP), 198 
FO(posDTC), 224 
FO(posDTC) = FO(DTC), 224 
FO(posTC), 143, 159, 224 
FO(posTC) and NLOGSPACE, 143, 
148 
FO(posTC) = FO(TC), 226 
FO(S-IFP), 175 
FO(S-LFP), 176 
FO(S-PFP), 192 
FO(TC), 123, 159, 220 
FO(TC) and NLOGSPACE, 143, 151 
FO(TC) <FO(BFP), 237 
FO(TC) < FO(LFP), 231 
FO(TC) = S-DATALOGi, 243 
FO(TC0, 221, 268 
FO(TC^) = MSO, 221 
forest, 3 
- <-, 59, 60 
formula 
- atomic, 5 
- bounded DATALOG, 250 
- bounded positive DATALOG, 250 
- DATALOG, 240 
- existential, 65 
- existential FO(posTC), 225 
- first-order, 4, 169 
- I-DATALOG, 246 
- Looc.,40, 42 
- m-Hintikka, 18 
- monotone in a relation, 67 
- negative in X, 169 
- nontrivial, 254 
- normal, 95, 169 
- P-DATALOG, 249 
- positive DATALOG, 245 
- positive in a relation, 67 
- positive in X, 169 
- S-DATALOG, 241 
- 5-Scott, 57 
- totally defined, 194 
- totally defined WF-DATALOG, 265 

354 
Index 
- universal, 65 
- WF-DATALOG, 265 
forth property, 20 
- S-, 51 
FO[r], 5 
frame, 99 
PraVsse's Theorem, 21 
free parametric, 80 
free((^), 5 
function 
- antitone, 167, 172, 192 
- inductive, 166, 175 
- inflationary, 120, 166, 175 
- monotone, 166, 175 
- polynomial time computable, 190 
function symbol, 11 
function system 
- inductive, 175 
- inflationary, 175 
- monotone, 175 
Gaifman graph, 26 
Gaifman's Theorem, 31 
game 
- associated with a digraph, 168, 172, 
198 
- Ehrenfeucht-Praisse for counting 
quantiflers, 60 
- Ehrenfeucht-Frai'sse for FO, 16, 21 
- Ehrenfeucht-Fraisse for FO(M-LFP), 
213 
- Ehrenfeucht-Fraisse for FO^, 50 
- Ehrenfeucht-Fraisse for FO(TC), 229 
- Ehrenfeucht-Fraisse for Loow, 42 
- Ehrenfeucht-Fraisse for L^^, 50 
- Ehrenfeucht-Fraisse for MSO, 38 
- Ehrenfeucht-Fraisse with infinitely 
many moves, 42 
- of life, 197 
- pebble, 50, 60 
global relation, 10, 12 
- L^^^-definable, 54 
graph, 1 
GRAPH, 1, 298, 322 
graph 
- acyclic, 2, 306 
- acyclic connected, 306 
- balanced, 112 
- bipartite, 112, 113, 221, 223 
- coloured, 61 
- connected, 2, 23, 29, 40, 41, 85, 86, 
122, 123, 169, 221, 309 
- connected ordered, 23 
- directed, 1 
- Gaifman, 26 
- of a structure, 26 
- planar, 85 
- random, 85 
- rigid, 86 
- stable coloured, 61 
- undirected, 1 
- with a Hamiltonian circuit, 113 
grid, 302 
Halting Problem, 127 
HAM, 113, 327 
Hamiltonian circuit, 2, 113, 327 
Hamiltonian path, 2 
Hanf's Theorem, 27 
hard 
- with respect to C-reductions, 321 
- with respect to /^-reductions, 324 
head 
- of a clause, 239 
- of a Turing machine, 125 
- read-and-write, 125, 130 
- read-only, 130 
HENK, 328 
hierarchy 
- arity, 268, 273 
- arity for FO(PFP), 272 
- polynomial, 159, 338 
Hintikka formula 
- m-, 18 
hold 
- almost surely, 72 
- in almost all finite structures, 72 
homomorphism, 34 
- strict, 34 
Horn sentence, 251 
IMP(FO) < A}, 219 
IMP(FO(PFP)) ^L^a;,219 
IMP(£), 218 
in-degree, 2 
index of an equivalence relation, 107 
induction 
- on the length of formulas, 5 
- simultaneous, 178 
- simultaneous for LFP and IFP, 179 
- simultaneous for PFP, 193 
inductive, 166, 175 
inflationary, 120, 166, 175 
input inscription, 131 
input instance, 276 
input tape, 127, 130 

Index 
355 
Instr(M), 125, 131 
instruction, 125, 131 
- oracle, 331 
intentional, 239 
interpolant, 64 
interpolation property, 64 
interpretation, 297, 321 
- of o- in r, 297, 321 
invariant 
- s- of a structure, 55, 200 
invariantization 
- C- on 5, 301 
- PTIME-, 292-294, 301 
- PTIME- on GRAPH, 301 
isomorphic, 3 
- m-, 20 
- partially, 43 
- 
S-771-, 51 
- s-partially, 51 
isomorphism, 3 
- generalized partial, 213 
- partial, 15 
- s-partial, 50 
isomorphism type, 18, 77 
- m-, 18, 25, 26 
- s-m-, 52 
join 
- simultaneous, 178 
king, 97 
language, 106, 126 
- acceptable, 126 
- accepted by a Turing machine, 126 
- accepted by an NDA, 106 
- decidable, 126 
- decided by a Turing machine, 126 
- definable by a E J-sentence. 111 
- definable in FO, 114, 116 
- definable in monadic second-order 
logic, 109, 111 
- enumerable, 126 
- noncounting, 116 
- plus free regular, 114 
- recognized by an automaton. 111 
- recognized by an NDA, 106, 111 
- regular, 108, 110, 111 
- ultimately periodic, 112 
law 
- 0-1 for FO, 77 
- 0-1 for L^^, 77 
- labeled 0-1, 72 
- labeled 0-1 for FO, 73 
- labeled 0-1 for FO(PFP), 200 
- labeled 0-1 for L^^, 73 
- labeled 0-1 for parametric classes, 77 
- labeled 0-1 for 0^, 77 
- labeled 0-1 for El(3*V*), 88 
- unlabeled 0-1, 80 
- unlabeled 0-1, failure for Sl-FO^ 98 
- unlabeled 0-1 for FO, 80 
- unlabeled 0-1 for FO(PFP), 200 
- unlabeled 0-1 for L^^, 80 
- unlabeled 0-1 for parametric classes, 
80 
- unlabeled 0-1 for El(3*V*), 88 
leaf, 3 
Lemma 
- Pumping, 107, 111 
- Simultaneous Induction, 178 
- Simultaneous Induction for LFP and 
IFP, 179 
- Simultaneous Induction for PFP, 193 
- Transitivity, 182 
- Transitivity for LFP, 182 
- Transitivity for PFP, 195 
length of a path, 2 
Lindstrom extension, 309 
Lindstrom quantifier, 309 
- vectorization of, 312 
log, 132 
log space-bounded, 160 
logarithmic space 
- deterministic, 132 
- nondeterministic, 132 
logic, 159, 289, 314 
- alternating transitive closure, 261, 
314 
- bounded fixed-point, 235, 263 
- closed under order-invariant 
sentences, 64 
- deterministic transitive closure, 123 
- existential fixed-point, 243 
- first-order, 4, 13 
- first-order with counting quantifiers, 
59 
- fixed-point with counting, 208, 248 
- inductive fixed-point, 169 
- infinitary, 40 
- infiationary fixed-point, 121, 169, 313 
- least fixed-point, 170, 263 
- monadic least fixed-point, 212 
- monadic second-order, 38, 110 
- partial fixed-point, 121, 191, 263, 313 
- partial fixed-point with counting, 209 
- positive existential fixed-point, 245 

356 
Index 
- second-order, 37, 210 
- simultaneous inflationary fixed-point, 
175 
- simultaneous least fixed-point, 176 
- simultaneous partial fixed-point, 192 
- stratified fixed-point, 235 
- transitive closure, 123, 220, 263 
logic program 
- general, 239 
logically equivalent, 6 
logically valid, 6 
LOGSPACE, 132 
LOGSPACE and FO(DTC), 142, 148, 
151, 296, 304 
LOGSPACE'^, 331 
LOGSPACE^P^^^^, 332, 334 
LOGSPACE^P'^^^^ 
= 
LOGSPACE"^^<, 332 
LOGSPACE^P^i^^ 
= 
LOGSPACE^^^^<, 332 
LOGSPACE^, 334 
Lowenheim-Skolem Theorem, 8 
MAXCLIQUE, 284 
MAXCUT, 275, 276, 284 
MAX FO, 278 
maximization, 276 
MAXIMUM CONNECTED COMPO-
NENT, 285 
MAX PB, 278 
MAX Hn, 278 
MAX En, 278 
MAXe El, 281 
MAXe El C APX, 281 
method 
- Ehrenfeucht-Praisse, 21 
MIN FO, 278 
MIN PB, 278 
minimization, 276 
MINVERTEX, 276, 277 
Mod(#), 14 
Mod((^), 10 
modal logic, 99 
model 
- minimal, 34, 35 
- of a formula, 6 
- random, 84 
model checker, 147 
model class, 10 
model theory, 26 
monotone, 166, 175 
move, 16, 168, 213, 229 
- V-, 25 
- 3-, 25 
- inG^(^,a,^,6), 50 
- LFP, 213 
- negative LFP, 213 
- point, 38, 213, 229 
- positive LFP, 213 
- set, 38 
- TC, 229 
MSO, 38, 212 
MSO-Gm(A^), 38 
NDA, 106 
NLOGSPACE, 132 
NLOGSPACE and FO(posTC), 143, 
148 
NLOGSPACE and FO(TC), 143, 151 
NLOGSPACE=co-NLOGSPACE?, 161 
noncounting, 116 
nontrivial parametric, 75 
normal form 
- for FO(IFP), 138, 152, 189, 253, 255 
- for FO(LFP), 174, 188, 254, 259 
- for FO(PFP), 138, 152, 192, 194, 
196, 197, 255 
- for FO(posTC), 226 
- for FO(TC), 228 
- for FO^-sentences, 96 
- prenex, 7, 39 
not, 4 
NPSPACE, 126 
NPTIME, 126, 132, 328, 329 
NPTIME and Ej, 139, 150, 151, 157 
NPTIME optimization problem, 276, 
280 
- first-order definable, 277 
- polynomially bounded, 277 
NPTIME=co-NPTIME?, 158 
number part, 208 
number sort, 208 
number variable, 208 
numerical invariant, 204 
occurrence 
- bound, 5 
- free, 5, 6, 37, 41, 172 
operation 
- boolean. 111 
optg, 276 
optimization problem 
- first-order definable, 277 
- NPTIME, 276, 280 
- polynomially bounded, 277 
or, 4 

Index 
357 
oracle answer state, 333 
oracle configuration, 331 
oracle instruction, 331 
oracle machine 
- (r,^), 330 
oracle tape, 330 
oracle transducer, 331 
ORD, 88 
order-invariant in the finite, 64, 156, 
288 
ordered representation, 156 
ordering, 3, 88 
- as {<, 5, min, max}-structure, 3 
- lexicographic, 131 
- minimal, 219 
- of even cardinality, 22 
ordMod, 130 
out-degree, 2 
output tape, 162 
parametric, 75 
Part(^,S), 15 
partial isomorphism, 15 
partially isomorphic, 43 
path, 2 
pebble, 50, 60 
pebble game, 50, 60 
PFP(/c,0, 263 
plus closure, 108 
plus free regular, 114 
point 
- drawn, 168, 172, 192, 198 
- of a graph, 1 
- won, 168, 172, 192, 198 
point sort, 208 
point variable, 208 
polynomial hierarchy, 159, 338 
polynomial space, 126, 132 
- nondeterministic, 126 
polynomial time, 126, 132 
- nondeterministic, 126, 132 
positive closure, 108 
Pow, 106 
predecessor of a vertex, 2 
prenex normal form, 7, 39 
preservation 
- under extensions, 66 
- under homomorphisms, 34 
- under strict homomorphisms, 34, 35 
- under substructures, 65 
preservation theorem, 65 
probability 
- labeled, 74 
- labeled asymptotic, 72, 74, 79, 80, 89 
- unlabeled, 77 
- unlabeled asymptotic, 77-80 
problem 
- maximization, 276 
- minimization, 276 
product of structures, 3, 24 
program 
- DATALOG, 239 
- general logic, 239 
- I-DATALOG, 245 
- P-DATALOG, 248 
- positive DATALOG, 250 
- S-DATALOG, 241 
- stratified DATALOG, 241 
- totally defined WF-DATALOG, 265 
programming language, 152 
projective Horn, 251-253 
proof 
- formal, 8 
PSPACE, 126, 132, 150 
PSPACE and FO(PFP), 137, 149, 151 
PTAS, 284 
PTIME, 126, 132, 261, 314, 315, 325 
PTIME and FO(IFP), 138, 149, 151, 
297, 302 
PTIME and FO(IFP, #), 305, 306, 315 
PTIME^, 334 
PTIME=NPTIME?, 155, 290 
PTIME=PSPACE?, 153, 154, 204, 206 
Pumping Lemma, 107, 111 
quantifier, 309 
- counting, 59, 309 
- existential, 4, 309 
- Lindstrom, 309 
- simple, 309 
- universal, 309 
quantifier rank, 7 
- for FO(M-LFP), 213 
query 
- PTIME-computable, 204 
query language, 12 
random structure 
- infinite, 45 
random structure theory, 45 
rank 
- s- of a structure, 57 
rank function, 185 
reducibility 
- many-one, 320 
reducible 

358 
Index 
- C-, 320 
- C-many-one, 320 
- £-, 321 
- logspace, 327 
reduct, 3 
refinement 
- stable coloured, 62 
regular expression, 108 
regular language, 108 
reject, 126 
relation, 1 
- defined in a structure, 10 
- global, 10, 12 
- global on a class, 10 
- nontrivial, 254 
- transitive closure, 11, 24 
relation symbol, 1 
- 0-ary, 241 
- extensional, 239 
- intentional, 239 
relativization 
- of a complexity class, 331 
represent effectively, 281 
rg(p), 15 
RIG, 78, 83 
rigid, 78 
root, 3 
round, 168 
run,125 
- accepting, 126 
- rejecting, 126 
satisfaction relation, 6 
satisfiable, 6 
satisfy in a structure, 6 
scattered 
- /-, 30 
S-DATALOG = S-DATALOG2, 243 
second-order logic, 37 
- monadic, 38 
section, 177 
sentence, 5 
- V^3*-, 100 
- basic local, 31 
- 3*V^3*-, 103 
- existential positive, 34 
- first-order, 5 
~ 
i-'COO' 5 4 1 
- La;ia)-, positive in a relation, 67 
- local, 31 
- monadic EJ-, 89 
- monotone in a relation, 67 
- nontrivial free parametric, 89 
- nontrivial parametric, 75, 86, 87 
- order-invariant in the finite, 64, 156. 
288 
- parametric, 75 
- positive in a relation, 67 
- E}-, 110 
- Ei(V*3*)-, 86 
- E}(3*V*)-, 86, 87 
- universal La,ia;-, 67 
- universal Horn, 251 
E} and NPTIME, 139, 150, 151, 157 
simple, 309 
simultaneous join, 178 
SO, 37 
SO(PFP), 159 
SO < FO(PFP), 211 
space bound for oracle machines, 331 
space-bounded, 126 
SPACER), 272 
spectrum of a sentence, 46 
spoiler, 16 
square, 125 
stage, 166, 199 
stage comparison, 185 
start of a Turing machine, 125, 131 
starting configuration, 136 
state, 131 
- accepting, 106, 125, 131 
- final, 106 
- initial, 106, 125, 131 
- of an automaton, 106 
- of a Turing machine, 125 
- oracle answer, 333 
- rejecting, 125, 131 
- starting, 131 
State(M), 125, 131 
Str, 291 
Str[r], 158 
string, 105 
strongly PTIME-complete, 325 
structure, 1 
- finite, 13 
- indiscernible, 222 
- infinite random, 45, 74 
- input, 276 
- labeled, 71 
- numerical, 161 
- of vocabulary r, 1 
- ordered, 3, 130 
- random, 72 
- rigid, 78 
- s-rigid, 204 
- r-, 1 

Index 
359 
structures 
- C^^-equivalent, 61 
- elementarily equivalent, 9 
- equivalent in FO(M-LFP), 214 
- FO^-equivalent, 48, 56 
- FO(TC)-equivalent, 230 
- Looa;-equivalent, 42, 44 
- L^^-equivalent, 48, 52, 55, 57 
- m-equivalent, 14, 19, 21 
- m-equivalent in FO^, 50, 52 
- 771-equivalent in L^^, 50 
- m-equivalent in MSO, 38 
- m-isomorphic, 21 
- s-TTi-isomorphic, 51, 52 
- s-partially isomorphic, 51, 52 
- partially isomorphic, 43, 44 
successor 
- of a configuration, 134 
- of a vertex, 2 
successor relation 
- fe-adic, 172 
sum 
- ordered, of m-equivalent structures, 
24, 25 
- ordered, of structures, 4, 24, 39 
supp(a), 50 
support, 50, 83 
T (truth value), 7 
tape, 125 
- input, 127, 130 
- oracle, 330 
- output, 162 
- work, 127, 130 
r-structure, 1 
TC, 11, 24, 123, 220 
term, 4 
Theorem 
- Beth's, 63 
- compactness, 8 
- completeness, 8 
- Craig's, 64 
- Ehrenfeucht's, 18 
- Praisse's, 21 
- Gaifman's, 31 
- Hanf's, 27 
- Lowenheim-Skolem, 8 
- Trahtenbrot's, 8, 127 
time-bounded, 126 
tournament, 75 
Trahtenbrot's Theorem, 8, 127 
Trand(<^0), 76, 84 
transducer 
- log space-bounded, 163 
- oracle, 331 
- polynomially time-bounded, 164 
- space-bounded, 162 
- (r,a)-, 162 
transitive closure logic see logic, 
transitive closure 
transition relation, 106 
transitive closure, 24, 123, 220 
- alternating, 261 
transitive closure relation, 11 
Transitivity Lemma, 182 
- for LFP, 182 
- for PFP, 195 
tree, 3, 170, 305 
- labeled binary, 206 
TREE, 3, 305 
tree-width, 171 
true, 6 
TRUE, 7, 10, 11, 241 
Turing machine, 125 
- deterministic, 125, 132 
- for r-structures, 130 
- / space-bounded, 126, 132 
- / time-bounded, 126, 132 
- nondeterministic, 125, 132 
- (r,c7)-, 162 
- with oracle tapes, 330 
type 
- m-isomorphism, 18, 25, 26 
- r-ball, 27 
- s-?n-isomorphism, 52 
ultimately periodic, 112 
undecidability 
- of finite satisfiability for FO, 127 
- of order-invariance, 288 
- of satisfiability in finite graphs, 129 
- of the Halting Problem, 127 
union 
- disjoint, of structures, 4, 24, 39 
- of m-equivalent structures, 24 
- of structures, 4 
universal algebra, 26 
universe, 1 
valid 
- logically, 6 
variable, 4 
- free, 5, 6, 37, 41, 172 
- predicate, 37 
- relation, 37 
vectorization 

360 
Index 
- of a class, 312 
- of a Lindstrom quantifier, 312 
- relativized of a class, 322 
- relativized of a Lindstrom quantifier, 
322 
vertex, 1 
vertex cover, 275 
virtual letter, 125 
vocabulary, 1 
- containing function symbols, 11 
- function-free, 11 
- relational, 1 
width of an interpretation, 297, 321 
win 
- a pebble game, 50 
- Gra{A,B), 
19,21 
- Gm{A,B), 
17 
- GmiA,a,B,b), 
18, 21 
- Goo(v4,B), 44 
- Goo(^, a, 5,6), 42, 43 
- G ^ ( ^ , ^ ) , 52 
- 
G^(Aa,^,&),52 
- GL(^,B), 52 
- GUA, a, B,b)^52 
- MSO-Gmi{A, P, a), {B,Q,b)), 38 
winning position, 20, 43, 52 
winning strategy, 17 
witness 
- negative, 263 
- positive, 263 
- strongly, 148, 153 
word, 105 
- empty, 105 
word model, 109, 221 
work tape, 127, 130 

