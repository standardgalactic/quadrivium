start·ng out wi h >>> 
EARLY OBJECTS 
T 
DIT ON 

Digital Resources for Students 
Your new textbook provides 12-month access to digital resources that may include 
VideoNotes (step-by-step video tutorials on programm ing concepts), source code, web 
chapters, quizzes, and more. Refer to the preface in the textbook for a detailed list of 
resources. 
Follow the instructions below to register for the Companion Website for Tony Gaddis, 
Judy Walters, and Godfrey Muganda's Staring Out with C++: Early Objects, Ninth Edition . 
I. Go to www.pearso nhighered.com/cs -resources 
2. Enter the title of your textboo k or browse by author name. 
3. Click Companion Website 
4. Click Register and follow the on-screen instructions to create a login name 
and password . 
Use a coin to scratch off the coating and reveal your access code. 
Do not use a sharp knife or other sharp object as it may damage the code. 
Use the login name and password you created during registration 
to start using the digital resources that accompany your textboo k. 
IMPORTANT: 
This prepaid subscription does not include access to MyProgamminglab, which is 
available at www.myprog ramm inglab.com for purchase. 
This access code can only be used once. This subscription is valid for 12 months upon 
activation and is not transferrable. If the access code has already been revealed it may 
no longer be valid. If this is the case you can purchase a subscription on the login page 
for the Companion Website. 
For technical support go to http://247pea rsoned.cust help.com 

This page intentionally left blank 

LOCATION OF VIDEONOTES IN THE TEXT 
~ 
VideoNote 
-
Chapter 1 
Designing a Program with Pseudocode, p. 20 
Designing the Account Balance Program, p. 25 
Predicting the Output of Problem 30, p. 25 
Solving the Candy Bar Sales Problem, p. 26 
Chapter 2 
Using cout to Display Output, p. 32 
Assignment Statements, p. 59 
Arithmetic Operators, p. 62 
Solving the Restaurant Bill Problem, p. 74 
-
Chapter 3 
Using ci n to Read Input, p. 77 
Evaluating Mathematical Expressions, p. 84 
Combined Assignment Operators, p. 102 
Solving the Stadium Seating Problem, p. 148 
Chapter4 
Using an if Statement, p. 161 
Using an if I else Statement, p. 170 
Using an if I else 
i f Statement, p. 176 
Using Logical Operators, p. 189 
Solving the Time Calculator Problem, p. 238 
Chapter 5 
The while Loop, p. 244 
The for Loop, p. 271 
Nested Loops, p. 279 
Solving the Ocean Levels Problem, p. 317 
Chapter6 
Defining and Calling Functions, p. 324 
Using Function Arguments, p. 333 
Value-Returning Functions, p. 343 
Solving the Markup Problem, p. 399 
Chapter 7 
Creating a Class, p. 412 
Creating and Using Class Objects, p. 414 
Creating and Using Structures, p. 454 
Solving the Car Class Problem, p. 500 
Chapter8 
Accessing Array Elements, p. 509 
Passing an Array to a Function, p. 543 
Two-Dimensional Arrays, p. 553 
Solving the Chips and Salsa Problem, p. 593 
Chapter9 
Performing a Binary Search, p. 606 
Sorting a Set of Data, p. 613 
Solving the Lottery Winners Problem, p. 641 
(continued on next page) 

LOCATION OF VIDEONOTES IN THE TEXT (continued) 
~ 
VideoNote 
-
Chapter 10 
Pointer Variables, p. 647 
Dynamically Allocating an Array, p. 671 
Solving the Days in Current Month Problem, p. 702 
Chapter 11 
Operator Overloading , p. 730 
Aggregation and Composition, p. 776 
Overriding Base Class Functions, p. 797 
Solving the Number of Days Worked Problem, p. 811 
Chapter 12 
Converting Strings to Numbers, p. 829 
Writing a C-String Handling Function, p. 833 
Solving the Case Manipulator Problem, p. 850 
Chapter 13 
The get Family of Member Functions, p. 869 
Rewinding a File, p. 873 
Solving the File Encryption Filter Problem, p. 912 
Chapter 14 
Recursive Binary Search, p. 927 
QuickSort, p. 929 
Solving the Recursive Multiplication Problem, p. 947 
Chapter 15 
Polymorph ism, p. 955 
Composition versus Inheritance, p. 969 
Solving the Sequence Sum Problem, p. 985 
-
Chapter 16 
Throwing and Handling Exceptions, p. 988 
Writing a Function Template, p. 1000 
Iterators, p. 1017 
Solving the Arithmetic Exceptions Problem, p. 1034 
Chapter 17 
Adding an Element to a Linked List, p. 1045 
Removing an Element from a Linked List, p. 1052 
Solving the Member Insertion by Position Problem, p. 1083 
Chapter 18 
Storing Objects in an STL Stack, p. 1097 
Storing Objects in an STL Queue, p. 1111 
Solving the File Reverser Problem, p. 1123 
Chapter 19 
Inserting an Element into a Binary Tree, p. 1132 
Removing an Element from a Binary Tree, p. 1136 
Solving the Tree Size Problem, p. 1152 

Ninth 
Edition 
C++ 
Early Objects 
Tony Gaddis 
Judy Walters 
Godfrey Muganda 
PEARSON 
Boston Columbus 
Indianapolis 
New York San Francisco Hoboken 
Amsterdam 
Cape Town Dubai London 
Madrid 
Milan Munich 
Paris Montreal 
Toronto 
Delhi Mexico City Sao Paulo Sydney Hong Kong Seoul Singapore Taipei Tokyo 

Vice President, Editorial Director , ECS: Marcia Horton 
Acquisitions Editor: Ma tt Goldstein 
Editorial Assistant: Kristy Alaura 
Vice President of Marketing: Christy Lesko 
Director of Field Marketing: Tim Galligan 
Product Mark eting Manager: Bram Van Kempen 
Field Marketing Manager: Demetrius Ha ll 
Marketin g Assistant: Jon Bryant 
Director of Product Management: Erin Gregg 
Team Lead, Program and Project Management: 
Scott Disanno 
Program Manager: Carole Snyder 
Project Manager: RPK Editorial Services, Inc. 
Senior Specialist, Program Planning and Support: Maura 
Zaldivar -Garcia 
Cover Designer: Joyce Wells 
Cover: Sabyna 7 5/Shutterstock 
Mana ger, Right.s and Permissions: Rachel Youdelman 
Project Manager, Rights and Permissions: William Opa luch 
Inventory Mana ger: Meredith Maresca 
Media Project Manager: Renata Butera 
Full-Service Project Management: Deepthi Mohan, 
Aptara® Corporation 
Compos ition: Aptara ® Corporation 
Printer/Binder: Edwards Brothers Malloy, Inc. 
Cover and Insert Printer: Phoenix Color 
Microsoft and/or its respective suppliers make no representations about the suitability of the information containe d in the 
documents and related graphics pub lished as part of the services for any purpose. All such documents and related graphics 
are provided "as is" without warranty of any kind. Microsoft and/or its respective supp liers hereby disclaim all warranties 
and conditions with regard to this information, including all warranties and conditions of merchantability , whether express, 
implied or statutory, fitness for a particular purpose, title and non-infringement. In no event shall Microsoft and/or its 
respective suppliers be liab le for any special, indirect or consequential damages or any damages whatsoever resulting from 
loss of use, data or profits, whether in an action of contract, negligence or otl1er tortious action, arising out of or in connection 
with the use or performance of information available from the services. 
The documents and related graphics contained herein could include technical inaccuracies or typographical errors. Changes 
are periodically added to the information herein. Microsoft and/or its respective suppliers may make improvements and/or 
changes in the product(s) and/or the program(s) described herein at any time. Partial screen shots may be viewed in full 
within the software version specified. 
Microsoft® Windows®, and Microsoft Office® are registered trademarks of the Microsoft corporation in the U.S.A. and 
other countries. This book is not sponsored or endorsed by or affiliated with tl1e Microsoft corporation. 
The programs and app lications presented in this book have been included for their instructional value. They have been tested 
with care, but are not guaranteed for any particular purpose. The pub lisher does not offer any warranties or representations, 
nor does it accept any liabilities with respect to the programs or applications. 
Copyright© 201 7, 2014 Pearson Education, Inc. All rights reserved. Manufactured in the United States of America. This 
pub lication is protected by Copyright, and permission should be obtained from the publisher prior to any prohibited repro-
duction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, 
recording, or likewise. For information regarding permissions, request forms and the appropriate contacts within the Pearson 
Education Globa l Rights & Permissions department, please visit www.pearsonhig hed.com/permissions/. 
Many of the designations by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those 
designations appear in this book, and the pub lisher was aware of a trademark claim, the designations have been printed in 
initial caps or all caps. 
Library of Congress Cataloging-in-Publication Data 
Names: Gaddis, Tony. I Walters, Judy. I Muganda, Godfrey. 
Title: Starting out with C++. Early objects/ Tony Gaddis, Judy Walters, Godfrey Muganda. 
Description: Ninth edition. I Boston : Pearson, 201 7. I Includes index. 
Identifiers: LCCN 20150488 47 I ISBN 01344002 40 
Subjects: LCSH: C++ (Computer program language) 
Classification: LCC QA76.73.C153 G333 2017 1 DOC 005.13/3-dc23 
LC record availab le at 
http://lccn.loc.gov/20150488 47 
10 9 8 7 6 5 4 3 2 1 
PEARSON 
ISBN 10: 
0-13-440024 -0 
ISBN 13: 978-0-13-440024 -2 

" 
Preface 
xv 
Chapter 
1 
Introduction 
to Computers 
and Programming 
1 
Chapter 2 
Introduction 
to C++ 
27 
Chapter 
3 
Expressions 
and Interactivity 
77 
Chapter 4 
Making Decisions 
155 
Chapter 
5 
Looping 
243 
Chapter 
6 
Functions 
323 
Chapter 
7 
Introduction 
to Classes and Objects 
407 
Chapter 8 
Arrays 
507 
Chapter 
9 
Searching, 
Sorting , and Algorithm 
Analysis 
603 
Chapter 
10 
Pointers 
645 
Chapter 
11 
More about Classes and Object -Oriented 
Programming 
703 
Chapter 
12 
More on ( -Strings and the string 
Class 
815 
Chapter 
13 
Advanced 
File and 1/ 0 Operations 
853 
Chapter 
14 
Recursion 
915 
Chapter 
15 
Polymorphism 
and Virtual Functions 
949 
Chapter 
16 
Exceptions, 
Templates, 
and the Standard 
Template 
Library (STL) 
987 
Chapter 
17 
Linked Lists 
103 7 
Chapter 
18 
Stacks and Queues 
1085 
Chapter 
19 
Binary Trees 
1125 
Appendix A: The ASCII Character 
Set 
1155 
Appendix 
B: Operator 
Precedence 
and Associativity 
1159 
Appendix 
C: Answers to Checkpoints 
1161 
Appendix 
D: Answers to Odd -Numbered 
Review Questions 
1201 
Index 
1221 
V 

This page intentionally left blank 

Preface 
xv 
CHAPTER 1 
Introduction 
to Computers and Programming 
1 
1.1 
Why Program? 
1 
1.2 
Computer Systems: Hardware and Software 
3 
1.3 
Programs and Programming Languages 
8 
1.4 
What Is a Program Made of? 
13 
1.5 
Input, Processing, and Output 
17 
1.6 
The Programming Process 
18 
1.7 
Tying It All Together: Hi! It's Me 
23 
CHAPTER 2 
Introduction 
to C++ 
27 
2.1 
The Parts of a C++ Program 
2 7 
2.2 
The cout Object 
31 
2.3 
The# i ncludeDirect ive 
36 
2.4 
Variables and the Assignment Statement 
37 
2.5 
Literals 
39 
2.6 
Identifiers 
41 
2.7 
Integer Data Types 
43 
2.8 
Floating-Point Data Types 
48 
2.9 
The char Data Type 
52 
2.10 
TheC++str
i ngClass 
56 
2.11 
The bool Data Type 
57 
2.12 
Determining the Size of a Data Type 
58 
2.13 
More on Variable Assignments and Initialization 
59 
2.14 
Scope 
61 
2.15 
Arithmetic Operators 
62 
2.16 
Comments 
66 
2.17 
Programming Style 
67 
2.18 
Tying It All Together: Smile! 
69 
vii 

viii 
Contents 
CHAPTER 3 
Expressions and Interactivity 
77 
3.1 
ThecinObject 
77 
3.2 
Mathematical Expressions 
84 
3.3 
Data Type Conversion and Type Casting 
92 
3.4 
Overflow and Underflow 
98 
3.5 
3.6 
3.7 
3.8 
3.9 
3.10 
Named Constants 
99 
Multiple and Combined Assignment 
Formatting Output 
106 
Working with Characters and Strings 
More Mathematical Library Functions 
Random Numbers 
132 
102 
116 
130 
3.11 
Focus on Debugging: Hand Tracing a Program 
136 
3.12 
Green Fields Landscaping Case Study- Part 1 
138 
3.13 
Tying It All Together: Word Game 
141 
CHAPTER 4 
Making Decisions 
155 
4.1 
Relational Operators 
155 
4.2 
The if Statement 
161 
4.3 
Theif/elseStatement 
170 
4.4 
The if /else if Statement 
175 
4.5 
Menu-Driven Programs 
183 
4.6 
Nested i f Statements 
185 
4.7 
Logical Operators 
189 
4.8 
Validating User Input 
198 
4.9 
More about Blocks and Scope 
200 
4.10 
More about Characters and Strings 
203 
4.11 
The Conditional Operator 
209 
4.12 
The switch Statement 
213 
4.13 
Enumerated Data Types 
222 
4.14 
Focus on Testing and Debugging: Validating Output Results 
225 
4.15 
Green Fields Landscaping Case Study- Part 2 
227 
4.16 
Tying It All Together: Fortune Teller 
232 
CHAPTER 5 
Looping 
243 
5 .1 
Introduction to Loops: The whi le Loop 
243 
5 .2 
Using the while Loop for Input Validation 
250 
5.3 
The Increment and Decrement Operators 
253 
5.4 
Counters 
258 
5.5 
Keeping a Running Total 
260 
5.6 
Sentinels 
263 
5.7 
The do-while Loop 
265 

5.8 
The for Loop 
271 
5.9 
Focus on Software Engineering: Deciding Which Loop to Use 
277 
5.10 
Nested Loops 
279 
5 .11 
Breaking Out of a Loop 
281 
5 .12 
Using Files for Data Storage 
285 
5.13 
Focus on Testing and Debugging: Creating Good Test Data 
301 
5.14 
Central Mountain Credit Union Case Study 
304 
5.15 
Tying It All Together: What a Colorful World 
308 
CHAPTER 6 
Function s 
323 
6.1 
Modular Programming 
323 
6.2 
Defining and Calling Functions 
324 
6.3 
Function Prototypes 
332 
6.4 
Sending Data into a Function 
333 
6.5 
Passing Data by Value 
338 
6.6 
The return Statement 
342 
6.7 
Returning a Value from a Function 
343 
6.8 
Returning a Boolean Value 
349 
6.9 
Using Functions in a Menu-Driven Program 
351 
6.10 
Local and Global Variables 
355 
6.11 
Static Local Variables 
362 
6.12 
Default Arguments 
364 
6.13 
Using Reference Variables as Parameters 
368 
6.14 
Overloading Functions 
378 
6.15 
The exit() 
Function 
382 
6.16 
Stubs and Drivers 
385 
6.17 
LittleLottoCaseStudy 
387 
6.18 
Tying It All Together: Glowing Jack-o-lantern 
392 
CHAPTER 7 
Introduction 
to Classes and Objects 
407 
7.1 
Abstract Data Types 
407 
7.2 
Object-Oriented Programming 
409 
7.3 
Introduction to Classes 
411 
7.4 
Creating and Using Objects 
414 
7.5 
Defining Member Functions 
416 
7.6 
Constructors 
423 
7.7 
Destructors 
429 
7.8 
Private Member Functions 
432 
7.9 
Passing Objects to Functions 
435 
7.10 
Object Composition 
442 
Contents 
ix 
7.11 
Focus on Software Engineering: Separating Class Specification, Implementation , 
and Client Code 
446 

x 
Contents 
7.12 
Structures 
453 
7.13 
More about Enumerated Data Types 
465 
7.14 
Home Software Company OOP Case Study 
469 
7.15 
Introduction to Object-Oriented Analysis and 
Design 
476 
7.16 
Screen Contro l 
486 
7.17 
Tying It All Together: Yoyo Animation 
491 
CHAPTER 8 
Arrays 
507 
8.1 
Arrays Hold Multiple Values 
507 
8.2 
Accessing Array Elements 
509 
8.3 
Inputting and Displaying Array Data 
511 
8.4 
Array Initialization 
518 
8.5 
The Range-Based for loop 
525 
8.6 
Processing Array Contents 
528 
8.7 
Using Parallel Arrays 
539 
8.8 
The typede f Statement 
543 
8.9 
Arrays as Function Arguments 
543 
8.10 
Two-Dimensional Arrays 
553 
8.11 
Arrays with Three or More Dimensions 
560 
8.12 
Vectors 
563 
8.13 
Arrays of Objects 
575 
8.14 
National Commerce Bank Case Study 
585 
8.15 
Tying It All Together: Rock, Paper, Scissors 
587 
CHAPTER 9 
Searching, Sorting , and Algorithm Analysis 
603 
9 .1 
Introduction to Search Algorithms 
603 
9.2 
Searching an Array of Objects 
610 
9.3 
Introduction to Sorting Algorithms 
613 
9.4 
Sorting an Array of Objects 
621 
9.5 
Sorting and Searching Vectors 
624 
9.6 
Introduction to Analysis of Algorithms 
627 
9.7 
Case Studies 
635 
9.8 
Tying It All Together: Secret Messages 
635 
CHAPTER 10 
Pointers 
645 
10.1 
Pointers and the Address Operator 
645 
10.2 
Pointer Variables 
647 
10.3 
The Relationship Between Arrays and 
Pointers 
651 

10.4 
Pointer Arithmetic 
655 
10.5 
Initializing Pointers 
656 
10.6 
Comparing Pointers 
659 
10. 7 
Pointers as Function Parameters 
661 
10.8 
Pointers to Constants and Constant Pointers 
665 
10.9 
Focus on Software Engineering: Dynamic Memory 
Allocation 
670 
10.10 Focus on Software Engineering: Returning Pointers from 
Functions 
674 
10.11 Pointers to Class Objects and Structures 
680 
10.12 Focus on Software Engineering: Selecting Members 
of Objects 
684 
10.13 Smart Pointers 
686 
10.14 Tying It All Together: Pardon Me, Do You Have the Time? 
694 
CHAPTER 11 
More about Classes and Object -Oriented Programming 
703 
11.1 
The th is Pointer and Constant Member Functions 
703 
11.2 
Static Members 
708 
11.3 
Friends of Classes 
715 
11.4 
Memberwise Assignment 
720 
11.5 
Copy Constructors 
721 
11.6 
Operator Overloading 
730 
11.7 
Rvalue References and Move Operations 
751 
11.8 
Function Objects and Lambda Expressions 
761 
11.9 
Type Conversion Operators 
770 
11.10 Convert Constructors 
773 
11.11 Aggregation and Composition 
776 
11.12 Inheritance 
782 
11.13 Protected Members and Class Access 
787 
11.14 Constructors, Destructors, and Inheritance 
792 
11.15 Overriding Base Class Functions 
797 
11.16 Tying It All Together: Putting Data on the World Wide Web 
800 
CHAPTER 12 
More on C-Strings and the s t ring Class 
815 
12.1 
C-Strings 
815 
12.2 
Library Functions for Working with C-Strings 
820 
12.3 
Conversions Between Numbers and Strings 
829 
12.4 
Writing Your Own C-String Handling Functions 
833 
12.5 
More about the C++ str i ng Class 
839 
12.6 
Advanced Software Enterprises Case Study 
842 
12.7 
Tying It All Together: Program Execution Environments 
844 
Contents 
xi 

xii 
Contents 
CHAPTER 13 
Advanced File and 1/ 0 Operations 
853 
13.1 
Input and Output Streams 
853 
13.2 
More Detailed Error Testing 
861 
13.3 
Member Functions for Reading and Writing Files 
865 
13.4 
Binary Files 
877 
13.5 
Creating Records with Structures 
881 
13.6 
Random -Access Files 
886 
13. 7 
Opening a File for Both Input and Output 
893 
13.8 
Online Friendship Connections Case Study: Object Serialization 
898 
13.9 
Tying It All Together: File Merging and Color-Coded HTML 
903 
CHAPTER 14 
Recursion 
915 
14.1 
Introduction to Recursion 
915 
14.2 
The Recursive Factorial Function 
922 
14.3 
The Recursive gcd Function 
924 
14.4 
Solving Recursively Defined Problems 
925 
14.5 
A Recursive Binary Search Function 
927 
14.6 
Focus on Problem Solving and Program Design: The QuickSort Algorithm 
929 
14.7 
The Towersof Hanoi 
933 
14.8 
Focus on Problem Solving: Exhaustive and Enumeration Algorithms 
936 
14.9 
Focus on Software Engineering: Recursion versus Iteration 
940 
14.10 Tying It All Together: Infix and Prefix Expressions 
941 
CHAPTER 15 
Polymorphism and Virtual Functions 
949 
15.1 
Type Compatibi lity in Inheritance Hierarchies 
949 
15.2 
Polymorp hism and Virtual Member Functions 
955 
15.3 
Abstract Base Classes and Pure Virtual Functions 
963 
15.4 
Focus on Object-Oriented Programming : Composition versus Inheritance 
969 
15.5 
Secure Encryption Systems, Inc., Case Study 
973 
15.6 
Tying It All Together: Let's Move It 
976 
CHAPTER 16 
Exceptions, Templates, and the Standard Template Library 
(STL) 
987 
16 .1 
Exceptions 
9 8 7 
16.2 
Function Templates 
999 
16.3 
Class Templates 
1007 
16.4 
Class Templates and Inheritance 
1012 
16.5 
Introduction to the Standard Template Library 
1016 
16.6 
Tying It All Together: Word Transformers Game 
1029 

CHAPTER 17 
Linked Lists 
1037 
17.1 
Introduction to the Linked List ADT 
1037 
17.2 
Linked List Operations 
1043 
17.3 
A Linked List Template 
1055 
17.4 
Recursive Linked List Operations 
1059 
17.5 
Variations of the Linked List 
1067 
17.6 
The STL list 
Container 
1068 
17. 7 
Reliable Software Systems, Inc., Case Study 
1071 
17.8 
Tying It All Together: More on Graphics and Animation 
1074 
CHAPTER 18 
Stacks and Queues 
1085 
18.1 
Introduction to the Stack ADT 
1085 
18.2 
Dynamic Stacks 
1093 
18.3 
The STL stack Container 
1097 
18.4 
Introduction to the Queue ADT 
1099 
18.5 
Dynamic Queues 
1106 
18.6 
The STL deque and queue Containers 
1109 
18.7 
18.8 
Focus on Problem Solving and Program Design: Eliminating Recursion 
Tying It All Together: Converting Postfix Expressions to Infix 
1117 
CHAPTER 19 
Binary Trees 
1125 
19.1 
Definition and Applications of Binary Trees 
1125 
19.2 
Binary Search Tree Operations 
1129 
19.3 
Template Considerations for Binary Search Trees 
1145 
19.4 
Tying It All Together: Genealogy Trees 
1145 
Appendix A: The ASCII Character Set 
1155 
Appendix B: Operator Precedence and Associativity 
1159 
Appendix C: Answers to Checkpoints 
1161 
Contents 
xiii 
1112 
Appendix D: Answers to Odd -Numbered Review Questions 
1201 
Index 
1221 

xi v 
Contents 
Additional Appendices 
The following append ices are located on the book's companion web site. 
Appendix E: A Brief Introduction to Object -Oriented Programming 
Appendix F: Using UML in Class Design 
Appendix G: Multi-Source File Programs 
Appendix H: Multiple and Virtual Inheritance 
Appendix I: Header File and Library Function Reference 
Appendix J: Namespaces 
Appendix K: C++ Casts and Run-Time Type Identification 
Appendix L: Passing Command Line Arguments 
Appendix M: Binary Numbers and Bitwise Operations 
Appendix N: Introduction to Flowcharting 

Welcome to Starting Out with C++: Early Objects, 9th Edition. This book is intended 
for use in a two -term or three-term C++ programming sequence, or an accelerated 
one-term course. Students new to programming, as well as those with prior course work 
in other languages, will find this text beneficial. The fundamentals of programming 
are covered for the novice, while the details, pitfalls, and nuances of the C++ language 
are explored in-depth for both the beginner and more experienced student . The book 
is written with clear, easy-to -understand language and it covers all the necessary 
topics for an introductory programming course. This text is rich in example programs 
that are concise, practica l, and real world oriented, ensuring that the student not only 
learns how to implement the features and constructs of C++, but why and when to 
use them. 
What's New in the Ninth Edition 
The New C++ 11 Standard 
C++ 11 is the latest standard version of the C++ language. In previous years, while the 
standard was being developed, it was known as C++Ox. In August 2011, it was 
approved by the International Standards Organization (ISO), and the name of the 
standard was officially changed to C++l l. Most of the popular C++ compilers now 
support this standard. 
The new C++ 11 standard was the primary motivat ion behind this edition, which 
introduces many of the new language features. However, a C++ 11 compi ler is not 
strictly required to use the book . As you progress through the book, you will see 
C++ll icons in the margins, next to the new features that are introduced . Programs 
appearing in sections that are not marked with this icon will still compi le using an 
older compiler. 
The C++ 11 Topics Introduced in This Edition 
• The aut o key word is introduced in Chapter 2 as a way to simplify comp lex 
variable definitions. This key word causes the compiler to infer a variable's data 
type from its initialization value. 
xv 

xvi 
Preface 
• Chapter 2 also introduces the new long long i nt and unsigned long long i nt 
data types and the LL literal suffix. 
• Chapter 5 shows how to pass a str i ng object directly to a file stream object's 
open member function, without the need to call the c_st r () member function. 
A discussion of the c_s t r () function sti ll exists for anyone using a legacy 
compiler. 
• Th e range -based for loop is introduced 
in Chapter 7. Thi s new looping 
mechanism automatically iterates over each element of an array, vector, or 
other collection, without the need for a counter variable or a subscript. 
• Chapter 7 also introduces strongly typed enums. 
• Chapter 8 introduces new ways to initialize variables and shows how a vect or 
can now be initialized with an initialization list. 
• Chapter 10 introduces smart pointers and provides examples of how and why to use 
the new uni que_ptr and shared_ptr 
pointers for safely allocating and working 
with dynamic memory. 
• Chapter 10 also introduces the move assignment operator, and the null pt r key 
word, which is now the standard way of representing a null pointer. 
• Chapter 11 discusses move constructors, provides more in depth coverage of 
move assignment operators, and introduces lambda expressions . 
• Chapter 12 introduces new functions in the C++ 11 string library and discusses 
the new overloaded to _stri ng functions for convert ing numeric values to stri ng 
objects. 
• Chapter 15 introduces and demonstrates the use of the new override key word 
that helps prevent subtle overridin g errors and the new final 
key word that 
prevents a virtua l member function from being overridden . 
• Chapter 16 introduces the new C++ 11 functions begi n ( c) and end ( c) to specify 
positions within a collection c where an operat ion should begin and end. 
What Else is New 
This book's pedagogy and clear writing style remain the same as in the previous edition. 
However, in addition to updating the book to introduce the new C++l 1 standard, 
many improvements have been made to make it even more student -friendly. 
• Upd ated Material 
Material has been updated throughout the book to reflect changes in technology 
and in software development environments, as well as to improve clarity and 
incorporate best practices in teaching introductory programming . As a result, 
new graphics and new or redesigned figures have been added throughout the 
book where appropriate and new or impr oved sample programs have been 
included in a number of chapters . 
• New Material 
New materia l has been added on a number of topics. In addition to introducing 
and using new C++ 11 features, this new edition includes new sections on literals, 
random numbers, and enumerated data types, as well as improved materia l on 
designing classes. 

Preface 
xvii 
• New Programming Challenges 
New Programming Challenge problems have been added to every chapter. 
• Reorganized Chapters 
Several chapters have been redesigned to improve student learning . Chapter 5 
(Looping) has been reorganized to give students more practice using the whi le 
loop before introducing do-while 
and for loops. The Chapter 6 (Functions) 
material on defining and calling functions has been reorganized to introduce 
function prototypes earl ier and allow main to always be the first function in 
a client program . 
Organization of the Text 
This text teaches C++ in a step-by-step fashion. Each chapte r covers a major set of 
topics and builds knowledge as the student progresses through the book . Although 
the chapters can be easily taught in their existing sequence, flexibility is provided . 
The following dependency diagram (Figur e P-1) suggests possible sequences of 
instruct ion. 
Chapter 1 covers fundamental hardware, software, and programm ing concepts. The 
instructor may choose to skip this chapter if the class has already mastered those topics. 
Chapters 2 through 6 cover basic C++ syntax, data types, expressions, selection 
structures, repetition structures, and functions . Each of these chapters builds on the 
previous chapter and should be covered in the order presented. 
Chapter 7 introduces object-oriented programming . It can be covered any time after 
Chapter 6, but before Chapter 11. Instructors who prefer to introduce arrays before 
classes can cover Chapter 8 before Chapter 7. In this case it is only necessary to 
postpone Section 8.13 (Arrays of Objects) until Chapter 7 has been covered. 
As Figure P-1 illustrates, in the second half of the book Chapters 11, 12, 13, and 14 
can be covered in any order. Chapters 11, 15, and 16, however, should be done in 
sequence. Instructors who wish to introduce data structures at an earlier point in the 
course, without having first covered advanced C++ and OO P features, can cover 
Chapter 17 (Linked Lists), followed by Chapters 18 and 19 (Stacks & Queues and 
Binary Tr ees), any time after Chapter 14 (Recursion). In this case it is necessary to 
simply omit the sections in Chapters 17- 19 that deal with templates and the Standard 
Template Library. 

xviii 
Preface 
Figure P-1 
Chapter 1 
Introduction .. 
Chapters 2-6 
Basic 
Language 
Elements 
I 
• 
• 
Chapter 7 
Chapter 8 
OOP Introduction 
Arrays 
I 
+ 
+ 
Chapter 9 
Chapter 10 
Searching, Sorting, 
Pointers 
and Algorithm Analysis 
I 
I 
+ 
• 
+ 
• 
Chapter 12 
Chapter 13 
Chapter 14 
Chapter 11 
Advanced 
Advanced Files 
Recursion 
MoreOOP 
Strings 
and 1/0 
• 
• 
Chapter 15 
Chapter 17 
Adv.OOP 
Linked Lists 
I 
• 
+ 
+ 
Chapter 16 
Chapter 18 
Chapter 19 
Exceptions, 
Stacks and 
Binary Trees 
Templates, 
Queues 
and STL 

Preface 
xix 
Brief Overview of Each Chapter 
Chapter 1: Introduction to Computers and Programming 
This chapter provides an introduction to the field of computer science and covers 
the fundamentals of hardware , software, operating systems, programming, problem 
solving, and software engineering . The components of programs, such as key words, 
variables, operators, and punctuation are covered . The tools of the trade , such as 
hierarchy charts and pseudocode, are also presented . The Tying It All Together 
sect ion shows students how to use the cout statement to create a personalized 
output message. Programm ing Challenges at the end of the chapter help students see 
how the same basic input, processing , and output structure can be used to create 
multiple programs . 
Chapter 2: Introduction to C++ 
This chapter gets the student started in C++ by introducing the basic parts of a 
C++ program , data types, the use of variables and literals, assignment statements, 
simple arithmetic operations, program output, and comments . The C++ st ring 
class is presented and string 
objects are used from this point on in the book as 
the primary method of handling strings. Programm ing style conventions 
are 
introduced , and good programming style is modeled here, as it is throughout the 
text . The Tying It All Toget her section lets the student play with simple text -
based graphics. 
Chapter 3: Expressions and Interactivity 
In this chapter the student learns to write programs that input and handle numer ic, 
character, and string data. The use of arithmet ic operators and the creation of 
mathemat ical expressions are covered, with emphasis on operator precedence . 
Debugging is introduced, with a section on hand tracing a program . Sections are also 
included on using random numbers , on simple output formatting, on data type 
conversion and type casting, and on using library functions that work with numbers. 
The Tying It All Together section shows students how to create a simple interactive 
word game. 
Chapter 4: Making Decisions 
Here the student learns about relational expressions and how to control the flow of a 
program with if, 
if I else
, and if I else 
i f statements . Logical operators, the 
conditional operator, and the swi tch statement are also covered. Applications of these 
constructs, such as menu-driven programs , are illustrated . This chapter also introduces 
the concepts of blocks and scope and continues the theme of debugging with a section 
on validating output results. The Tying It All Together section uses random numbers 
and branching statements to create a fortune telling game. 

xx 
Preface 
Chapter 5: Looping 
This chapter introduces, C++'s repetitive control mechanisms . The while loop, do-while 
loop, and for loop are presented, along with a variety of methods to control them. These 
include using counters, user input, end sentinels, and end-of-file testing. Applications 
utilizing loops, such as keeping a running total and performing data validation, are also 
covered . The chapter includes an extensive section on working with files and a section 
on creating good test data, continuing the book's emphasis on testing and debugging. 
The Tying It All Together section introduces students to Windows commands to create 
colorful output and uses a loop to create a multi-colored display. 
Chapter 6: Functions 
In this chapter the student learns how and why to modularize programs, using both 
void and value-returning functions. Parameter passing is covered, with emphasis on 
when arguments shou ld be passed by value versus when they need to be passed by 
reference. Scope of variables is covered and sections are provided on local versus global 
variables and on static local variables . Overloaded functions are also introduced and 
demonstrated . The Tying It All Together section includes a modular, menu -driven 
program that emphasizes the versatility of functions, illustrating how their behavior 
can be controlled by the arguments sent to them . 
Chapter 7: Introduction to Classes and Objects 
In this chapter the text begins to focus on the object-oriented paradigm. Students have used 
provided C++ classes since the beginning of the text, but now they learn how to define their 
own classes and to create and use objects of these classes. Careful attention is paid to 
illustrating which functions belong in a class versus which functions belong in a client 
program that uses the class. Good object-oriented practices are discussed and modeled, such 
as protecting member data through carefully constructed accessor and mutator functions 
and hiding class implementation details from client programs. Once students are comfortable 
working with classes and objects, the chapter provides a brief introduction to the topic of 
object-oriented analysis and design. The chapter also includes a section on enumerated data 
types and a section on structures, which are used in the Tying It All Together section, where 
students learn to use screen control techniques to create a yoyo animation. 
Chapter 8: Arrays 
In this chapter the student learns to create and work with single and multidimensional 
arrays. Many examples of array processing are provided, including functions to compute 
the sum, average, highest and lowest values in an array. Students also learn to create tables 
using two-dimensional arrays, and to analyze array data by row or by column. Programming 
techniques using parallel arrays are also demonsrrated, and the student is shown how to 
use a data file as an input source to populate an array . The range-based for loop is 
introduced as an easy way to iterate through all the elements of an array, and STL vectors 
are introduced and compared to arrays. A section on arrays of objects and structures is 
located at the end of the chapter, so it can be covered now or saved for later if the instructor 
wishes to cover this chapter before Chapter 7. The Tying It All Together section uses 
arrays to create a game of Rock, Paper, Scissors between a human player and the computer. 

Preface 
xxi 
Chapter 9: Searching, Sorting, and Algorithm Analysis 
Here the student learns the basics of searching for information stored in arrays and of 
sorting arrays, including arrays of objects. The chapter covers the Linear Search, Binary 
Search, Bubble Sort, and Selection Sort algorithm s and has an optional section on 
sortin g and search ing STL vectors. A brief introd uction to algorithm analysis is 
included, and students are shown how to determine which of two algorithms is more 
efficient. This chapter's Tying It All Together section uses both a table lookup and a 
searching algorithm to encode and decode secret messages. 
Chapter 10: Pointers 
Thi s chapter explains how to use pointers . Topics include pointer arithmetic, 
initialization of pointers , comparison of pointers, pointers and arrays, pointers 
and funct ions, dynamic memory allocation , the new null pt r key word, and 
more . A new section introduces smart pointers and shows how they can be used 
to avoid memory leaks. The Tying It All Toget her section demonstrates the use of 
pointers to access library data struct ures and functions that return calendar and 
wall clock time. 
Chapter 11: More About Classes and Object -Oriented Programming 
This chapter contin ues the study of classes and object-oriented programming, covering 
more advanced topics such as inheritance and object aggregation and compos ition. 
Other topics include constant member functions, static members, friends, memberwise 
assignment, copy constructors, object type conversion operators, convert constr uctors, 
operator overloading, move constr uctors, and move assignment operators . A new 
section introduces function objects and the C++ll lambda expressions. The Tying It 
All Together section brings together the concepts of inheritance and convert constr uctors 
to build a program that formats the contents of an array to form an HTML table for 
display on a Web site. 
Chapter 12: More on (-Strings and the string 
Class 
This chapter covers standard library functions for working with characters and 
C-strings, as well as materia l on str i ng class functions, functions in the new C++ 11 
string 
library, and new overloaded to_st ring functions for converting numeric 
values to str i ng objects . The Tying It All Together section shows students how to 
access string-based program environments to obtain information about the computer 
and the network on which the program is running. 
Chapter 13: Advanced File and 1/ 0 Operations 
Thi s chapte r intr oduces more advanced topics for work ing with sequential access 
text files and introduces random access and binary files. Various modes for open -
ing files are discussed, as well as the many methods for reading and writing their 
contents. Th e Tying It All Toget her program app lies many of the techniques 
covered in the chapte r to merge two text files into an HTML doc ument for display 
on the Web, with different colors used to illustrate which file each piece of data 
came from . 

xxii 
Preface 
Chapter 14: Recursion 
In this chapter recursion is defined and demonstrated . A visual trace of recursive calls 
is provided, and recursive applications are discussed. Many recursive algorithms are 
presented, including recursive functions for computing factorials, finding a greatest 
common denominator (GCD), performing a binary search, sorting using QuickSort, 
and solving the famous Towers of Hanoi problem . For students who need more 
challenge, there is a section on exhaustive and enumeration algorithms. The Tying It 
All Together section uses recursion to evaluate prefix expressions . 
Chapter 15: Polymorphism and Virtual Functions 
The study of classes and object-oriented programming continues in this chapter with 
the introduction of more advanced concepts such as polymorphism and virtual 
functions. Information is also presented on abstract base classes, pure virtual functions, 
type compatibi lity within an inheritance hierarchy, and virtual inheritance. The Tying 
It All Together section illustrates the use of inheritance and polymorphism to display 
and animate graphica l images. 
Chapter 16: Exceptions, Templates, and the Standard Template 
Library (STL) 
Here the student learns to develop enhanced error trapping techniques using exceptions. 
Discussion then turns to using function and class templates to create generic code. 
Finally, the student is introduced to the containers, iterators, and algorithms offered by 
the Standard Template Library (STL). The Tying It All Together section uses various 
conta iners in the Standard Template Librar y to create an educational children's game. 
Chapter 17: Linked Lists 
This chapter introduces concepts and techniques needed to work with lists. A linked list 
ADT is developed, and the student learns how to create and destroy a list, as well as to write 
functions to insert, append, and delete nodes, to traverse the list, and to search for a specific 
node. A linked list class template is also demonstrated. The Tying It All Together section 
brings together many of the most important concepts of OOP by using objeets, inheritance, 
and polymorphism in conjunction with the STL list class to animate a collection of images. 
Chapter 18: Stacks and Queues 
In this chapter the student learns to create and use static and dynamic stacks and queues. 
The operations of stacks and queues are defined, and templates for each ADT are 
demonstrated . The stat ic array -based stack uses exception -handling to handle stack 
overflow and underflow, providing a realistic and natural example of defining, throwing, 
and catching exceptions . The Tying It All Together section discusses strateg ies for 
evaluating postfix expressions and uses a stack to convert a postfix expression to infix. 
Chapter 19: Binary Trees 
This chapter covers the binary tree ADT and demonstrates many binary tree operat ions. 
The student learns to traverse a tree, insert, delete, and replace elements, search for a 
particular element, and destroy a tree. The Tying It All Together section introduces a 
tree structure versatile enough to create genealogy trees. 

Preface 
xxiii 
Appendices in the Book 
Appendix A: The ASCII Character Set A list of the ASCII and extended ASCII 
characters and their codes. 
Appendix B: Operator Precedence and Associativity A list of the C++ operators 
with their precedence and associativity. 
Appendix C: Answers to Checkpoints 
A too l students can use to assess their 
under standing by comparing their answers to the Checkpoint exercises found 
throughout the book. The answers to all Checkpoint exercises are included. 
Appendix D: Answers to Odd-Numbered Review Questions Another tool students 
can use to gauge their understanding and progress. 
Additional Appendices on the Book's Companion Website 
Appendix E: A Brief Introduction 
to Object -Oriented Programming 
An 
introduction to the concepts and terminology of object-oriented programming . 
Appendix F: Using UML in Class Design A brief introduction to the Unified Modeling 
Language (UML) class diagrams with examples of their use. 
Appendix C: Multi -Source File Programs 
A tutor ial on how to create, compile, 
and link programs with multiple source files. Includes the use of function header files, 
class specification files, and class implementat ion files. 
Appendix H: Multiple and Virtual Inheritance 
A self-contained discussion of the 
C++ concepts of multiple and virtual inheritance for anyone already familiar with 
single inheritance. 
Appendix I: Header File and Library Function Reference A reference for the C++ 
library functions and header files used in the book. 
Appendix / : Namespaces 
An explanation of namespaces and their purpose , with 
examples provided on how to define a namespace and access its members . 
Appendix K: C++ Casts and Run-Time Type Identification 
An introduction to 
different ways of doing type casting in C++ and to run-time type identificat ion. 
Appendix L: Passing Command Line Arguments 
An introduction to writing C++ 
programs that accept command -line arguments. This appendix will be useful to students 
working in a command -line environment, such as UNIX or Linux. 
Appendix M : Binary Numbers and Bitwise Operations 
A guide to the binary 
number system and the C++ bitwise operators, as well as a tutorial on the internal storage 
of integers. 
Appendix N: Introduction to Flowcharting A tutoria l that introduces flowcharting 
and its symbols . It includes hand ling sequence, selection, case, repetition , and calls 
to other modu les. Sample flowcharts for several of the book's example programs 
are presented. 

xxiv 
Preface 
Features of the Text 
Concept Statements 
Each major section of the text starts with a concept statement. 
This statement summarizes the key idea of the section. 
Example Programs 
The text has over 350 complete example programs, each 
designed to highlight the topic currently being studied . In 
most cases, these are practical, real-world examples . Source 
code for these programs is provided so that students can run 
the programs themselves. 
Program Output 
After each example program there is a sample of its screen 
output. This immediately shows the student how the program 
should function. 
Tying It All Together 
This special section, found at the end of every chapter, shows 
the student how to do something clever and fun with the 
materia l covered in that chapter. 
a VideoNotes 
A series of online videos, developed specifically for this book, 
are available for viewing at ht tp://www
. pearsonhighered. 
com/cs-resources/. 
VideoNote icons appear throughout the 
text, alerting the student to videos about specific topics. 
VideoNot e 
~ 
Checkpoints 
0 Notes 
(D Warnings 
Case Studies 
Review Questions 
and Exercises 
Checkpoints are questions placed throughout each chapter as 
a selftest study aid. Answers for all Checkpoint questions are 
provided in Appendix C at the back of the book so students 
can check how well they have learned a new topic. 
Notes appear at appropriate places throughout the text. They 
are short explanat ions of interesting or often misunderstood 
points relevant to the topic at hand . 
Warnings caution the student abo ut certa in C++ features, 
programming techniques, or practices that can lead to 
malfunctioning programs or lost data . 
Case studies that simulate real-world applications appear in 
many chapters throughout the text, with complete code provided 
for each one. Additional case studies are provided on the book's 
companion website. These case studies are designed to highlight 
the major topics of the chapter in which they appear. 
Each chapter presents a thorough and diverse set of review 
questions, such as fill-in-the-blank and short answer, that 
check the student' s mastery of the basic materia l presented in 
the chapter. These are followed by exercises requiring problem 
solving and analysis, such as the Algorithm Workbench, 
Predict the Output, and Find the Errors sections. Each chapter 
ends with a Soft Skills exercise that focuses on communication 
and group process skills. Answers to the odd numbered review 
questions and review exercises are provided in Appendix D at 
the back of the book . 

Programming 
Challenges 
Group Projects 
C++ Quick 
Reference Guide 
Supplements 
Student Resources 
Preface 
xxv 
Each chapter offers a pool of programming exercises designed 
to solidify the student' s know ledge of the topics currently 
being stud ied. In most cases the assignm ents present 
real-world prob lems to be solved. 
There are several group programming projects throughout 
the text, intended to be constructed by a team of students. 
One student might build the program's user interface, while 
another student writes the mathematica l code, and another 
designs and implements a class the program uses. This process 
is similar to the way many professiona l programs are written 
and encourages teamwork within the classroom . 
For easy access, a quick reference guide to the C++ language 
is printed on the inside back cover. 
Th e following items are avai lab le on the Gaddis Series resource 
page at 
www.pearsonhighered .com/cs-resources: 
• Complete source code for every program included in the book 
• Additional case studies, complete with source code 
• A full set of append ices (including several tutorials) that accompany the book 
• Access to the book's companion VideoNotes 
• Links to down load numerous programming environments and IDEs, including 
Visual Studio Community Edition . 
Instructor Resources 
The following supplements are available to qualified instructors only. 
• Answers to all Review Questions in the text 
• Solutions for all Programming Challenges in the text 
• PowerPoint presentation slides for every chapte r 
• A compute rized test bank 
• A collection of lab materials 
• Source code files 
Visit the Pearson Education Instructor Resource Center (http://www.pearsonhighered.com/irc) 
for information on how to access them. 
Practice and Assessment with MyProgramminglab 
MyProgrammingLab helps student s fully grasp the logic, semantics, and syntax of 
programming . Thr ough practice exercises and immediate, personalized feedback, 
MyProgrammingLab improves the programming competence of beginning students 
who often struggle with the basic concepts and paradigms of popular high-level 
programming languages. A self-study and homework tool, MyProgrammingLab 
consists of hundreds of small practice exercises organized around the structure of this 

xxvi 
Preface 
textbook. For students, the system automat ically detects errors in the logic and syntax 
of their code submissions and offers targeted hints that help them figure out what went 
wrong. For instructors, a comprehens ive gradeboo k tracks correct and incorrect 
answers and stores the code input by students for review. 
MyProgrammingLab is offered to users of this book in partnership with Turing's Craft, 
the makers of the CodeLab inter active programming exercise system . For a full 
demonstration, to see feedback from instructors and students, or to get started using 
MyProgrammingLab in your course, visit www.myprogramminglab .com. 
Which Gaddis C++ book is right for you? 
The Starting Out with C++ Series includes three books, one of which is sure to fit your 
course: 
• Starting Out with C++: Early Objects 
• Starting Out with C++: From Control Structures through Objects 
• Starting Out with C++: Brief Version 

Preface xxvii 
Acknowledgments 
There have been many helping hands in the development and publication of this text. 
We would like to thank the following faculty reviewers for their helpful suggestions 
and expertise. 
Reviewers of the Ninth Edition or Its Previous Versions 
Ahmad Abuhejleh 
University of Wisconsin, River Falls 
David Akins 
El Camino College 
Steve Allan 
Utah State University 
Ijaz A. Awan 
Savannah State University 
John Bierbauer 
North Central College 
Don Biggerstaff 
Fayetteville Technical Community 
College 
Paul Bladek 
Spokane Falls Community College 
Chuck Boehm 
Dean Foods, Inc. 
Bill Brown 
Pikes Peak Community College 
Richard Cacace 
Pensacola Junior College 
Randy Campbell 
Morningside College 
Stephen P. Carl 
Wright State University 
Wayne Caruolo 
Red Rocks Community College 
Thomas Cheatham 
Middle Tennessee State University 
James Chegwidden 
Tarrant County College 
John Cigas 
Rockhurst University 
John Cross 
Indiana University of Pennsylvania 
Fred M. D' Angelo 
Pima Community College 
Joseph DeLibero 
Arizona State University 
Dennis Fairclough 
Utah Valley State College 
Larry Farrer 
Guilford Technical Community College 
James D. Fitzgerald 
Golden West College 
Richard Flint 
North Central College 
Sheila Foster 
California State University Long Beach 
David E. Fox 
American River College 
Cindy Fry 
Baylor University 
Peter Gacs 
Boston University 
Cristi Gale 
Sterling College 
James Gifford 
University of Wisconsin, Stevens Point 
Leon Gleiberman 
Touro College 
Simon Gray 
Ashland University-Ohio 
Margaret E. Guertin 
Tufts University 
Jamshid Haghighi 
Guilford Technical Community College 
Ranette H. Halverson 
Midwestern State University, 
Wichita Falls, TX 

xxviii 
Preface 
Dennis Heckman 
Portland Community College 
Ric Heishman 
Northern Virginia Community College 
Patricia Hines 
Brookdale Community College 
Mike Holland 
Northern Virginia Community College 
Lister Wayne Horn 
Pensacola Junior College 
Richard Hull 
Lenoir-Rhyne College 
Norman Jacobson 
University of California, Irvine 
Eric Jiang 
San Diego State University 
Yinping Jiao 
South Texas College 
Neven Jurkovic 
Palo Alto College 
David Kaeli 
Northeastern University 
Chris Kardaras 
North Central College 
Amitava Karmaker 
University of Wisconsin- Stout 
Eugene Katzen 
Montgomery College- Rockvi lle 
Willard Keeling 
Blue Ridge Community College 
A. J. Krygeris 
Houston Community College 
Ray Larson 
Inver Hills Community College 
Stephen Leach 
Florida State University 
Parkay Louie 
Houston Community College 
Zhu -qu Lu 
University of Maine, Presque Isle 
Tucjer Maney 
George Mason University 
Bill Martin 
Central Piedmont Community College 
Svetlana Marzelli 
Atlantic Cape Community College 
Debbie Mathews 
]. Sargeant Reynolds 
Ron McCarty 
Penn State Erie, The Behrend College 
Robert McDona ld 
East Stroudsburg University 
James McGuffee 
Austin Community College 
M. Dee Medley 
Augusta State University 
Barbara Meguro 
University of Hawaii- Hilo 
Cathi Chambley-Miller 
Aiken Technical College 
Sandeep Mitra 
SUN¥ Brockp ort 
Churairat O'Brien 
Columbia Basin College 
Frank Paiano 
Southwestern Community College 
Jennifer Parham -Mocello 
Oregon State University 
Theresa Park 
Texas State Technical College 
Mark Parker 
Shoreline Community College 
Robert Plantz 
Sonoma State University 
Tino Posillico 
SUN¥ Farmingdale 
Mahmoud K. Quweider 
University of Texas at Brown sville 
M. Padmaja Rao 
Francis Marion University 
Timothy Reeves 
San Juan College 
Nancy Ripplinger 
North Idaho College 

Ronald Robison 
Arkansas Tech University 
Caroline St. Clair 
North Central College 
Dolly Samson 
Weber State University 
Kate Sanders 
Rhode Island College 
Tim Scheemaker 
Onondaga Community College 
Lalchand Shimpi 
Saint Augustine 's College 
Sung Shin 
South Dakota State University 
Barbara A. Smith 
University of Dayton 
Garth Sorenson 
Snow College 
Donald Southwell 
Delta College 
Daniel Spiegel 
Kutztown University 
Ray Springston 
University of Texas at Arlington 
Kirk Stephens 
Southwestern Community College 
Cherie Stevens 
South Florida Community College 
Joe Struss 
Des Moines Area Community College 
Hong Sung 
University of Central Oklahoma 
Preface 
xxix 
Sam Y. Sung 
South Texas College 
Mark Swanson 
Red Wing Technical College 
Martha Tillman 
College of San Mateo 
Maya Tolappa 
Waubonsee Community College 
Delores Tull 
Itawamba Community College 
Rober Tureman 
Paul D. Camp Community College 
Jane Turk 
LaSalle University 
Sylvia Unwin 
Bellevue Community College 
Stewart Venit 
California State University, Los Angeles 
David Walter 
Virginia State University 
Ju Wang 
Virginia State University 
Doug White 
University of Northern Colorado 
Chris Wild 
Old Dominion University 
Catherine Wyman 
DeVry Institute of Technology, Phoenix 
Sherali Zeadally 
University of the District of Columbia 
Chaim Ziegler 
Brooklyn College 
The authors would like to thank their students at Haywood Community College and 
North Central College for inspiring them to write student -friendly books. They would 
also like to thank their families for their tremendous support throughout this project. 
An especially big thanks goes to our terrific editorial, production, and marketing team 
at Pearson . In particular we want to thank our editor Matt Goldstein and our 
production program manager Carole Snyder, who have been instrumental in guiding 
the production of this book . We also want to thank our project manager, Rose Kernan, 
who helped everything run smooth ly, and our meticulous and knowledgable copyeditor, 
Shelly Gerger-Knechtl, who dedicated many hours to making this book the best book 
it could be. You are great people to work with! 

xxx 
Preface 
About the Authors 
Tony Gaddis is the principal author of the Starting Out With series of textbooks. He is 
a highly acclaimed instructor with two decades of experience teaching computer science 
courses, primarily at Hayw ood Commun ity College. Tony was previously selected as 
the North Carolina Community College "Teacher of the Year" and has received the 
Teaching Excellence award from the National Institute for Staff and Organizational 
Development. The Starting Out With series includes introductory textbooks covering 
Programming Logic and Design, C++, Java™, Microsoft® Visual Basic®, Microsoft® 
C#, Python, App Inventor, and Alice, all published by Pearson. 
Judy Walters is an Associate Professor of Computer Science at North Central College 
in Naperville, Illinois, where she teaches courses in both Computer Science and Media 
Studies. She is also very involved with Internationa l Programs at her college and has 
spent three semesters teaching in Costa Rica, where she hopes to retire some day. 
Godfrey Muganda is a Professor of Computer Science at North Central College. He 
teaches a wide variety of courses at both the undergraduate and graduate levels, including 
courses in Algorithms, Computer Organization, Web Applications, and Web Services. 
Credits 
Chapter 1 
Figure 1-1: 
Figure 1-2a: 
Figure 1-2b: 
Figure 1-2c: 
Figure 1-2d: 
Figure 1-2e: 
Figure 1-2f: 
Figure 1-2g: 
Figure 1-2h: 
Figure 1-2i: 
Figure 1-2j: 
Figure 1-2k: 
Figure 1-21: 
Figure 1-7: 
Chapter 2 
PowerPoint 2013, Windows 7, Microsoft Corporation 
Digital webcam in a white background with reflection: Iko/Shutterstock 
Modern flight joystick isolated on white background: Nikita Rogul/ 
Shutterstock 
Scanner close up shot, business concept: Feng Yu/Shutterstock 
Black Wireless Computer Keyboard and Mouse Isolated on White: 
Chiyacat/Shutterstock 
Compact photo camera: Eikostas/Shutterstock 
Computer drawing tablet with pen: Tkemot/Shutterstock 
Illustration of Hard disk drive HDD isolated on white background with 
soft shadow: Vitaly Korovin/Shutterstock 
Small computer speakers isolated on a white background: 
StockPhotosArt/Shutterstock 
Color Printer: Jocic/Shutter stock 
Four monitors. Vector: Art gallery/Shutterstock 
Stick of computer random access memory (RAM): Peter Guess/Shutterstock 
Chip processor radiator: Aquila/Shutterstock 
Screenshot of Microsoft Visual Studio, Microsoft Corporation 
Figure 2-1: 
Screenshots of Microsoft DOS, Microsoft Corporation 
Chapter 5 
Figure 5-11: Windows 10, Microsoft Corporation 
Figure 5-12: Windows 10, Microsoft Corporation 
All other Figures and Tables by the Authors 

PROGRAMMING PRACTICE 
W ith MyProgramminglab, your students will gain first-hand programming 
experience in an interactive online environment. 
IMMEDIATE, PERSONALIZED FEEDBACK 
MyProgramminglab automatically detec ts errors in the logic and syntax of their 
code submission and offers targeted hints that enables students to figure out what 
went wrong and why. 
MyProgramming lab · 
GRADUATED COMPLEXITY 
., 
COOfl All ANAi YSIS • COMl'II fR 11:UIOR(S) 
Rem.-,1(..-: 
MyProgramminglab breaks down programming 
concepts into short , understandab le sequences 
of exercises. With in each sequence the level and 
sophistication of the exercises increase gradually 
but stead ily. 
• 
Vo,.,.,_,.,,"""',....bt.clfflndwlt:)c~,C<lwO!il...Chthtta:b 
~ll
irit!ll 
• 
You,lm°'uena...,,~b,~: 
11 
• um 
+1
1 B i?¼ull 
:::!~7.,t'i ~_, ~ ......-er••• ,.,, ~r 
,ww 
MyProgramming Lati 
DYNAMIC ROSTER 
Students' submissions are stored in a roster that indicates whether 
the submission is correct , how many attempts were made, and the 
actual code submissions from each attempt. 
PEARSON e TEXT 
MyP1ogt.1mmlngl.ab 
. --. 
·-
·,-1=-== 
·--
. ._ .... _ 
. -·-
· -·-····=--
,a---
The Pearson e Text gives students access to their textbook anytime, anywhere 
STEP-BY-STEP VID EONOTE TUTORIALS 
These step-by-step video tutoria ls enhance the programm ing concepts presented 
in select Pearson textbooks. 
For more information and titles available with MyProgramminglab , 
please visit www.myprogramminglab.com
. 
Copyright© 20 17 Pearson Eduatio n. Inc. or its affiliate(s). All rights reserved . HEL088 I 73 • I I/ 15 
:=..--.. --·---------·· 
.. -
c:a 
•. . -·-
• 

This page intentionally left blank 

TOPICS 
1.1 
Why Program? 
1.4 
What Is a Program Made of? 
1.5 
Input, Processing, and Output 
1.6 
The Programming Process 
1.2 
Computer Systems: Hardware and 
Software 
1. 3 
Programs and Programming Languages 
1.7 
Tying It All Togethe r: Hi! It 's Me 
1.1 
Why Program? 
CONCEPT: 
Computers can do man y different jobs because they are programmable. 
Think about some of the different ways that people use computers . In school, students 
use computers for tasks such as writing papers, searching for articles, sending e-mail, 
and partic ipating in online classes. At work, people use computers to analyze data, 
make presentations , conduct business transactions , commun icate with customers and 
coworkers, contro l machines in manufacturing facilities, and do many other things. At 
home, people use computers for tasks such as paying bills, shopping online, social 
networking , and playing games. And don't forget that smart phone s, iPods®, car navi-
gation systems, and many other devices are computers as well. The uses of computers 
are almost limitless in our everyday lives. 
Computers can do such a wide variety of things because they can be programmed . This 
means that computers are not designed to do just one job, but to do any job that their 
programs tell them to do. A program is a set of instructions that a computer follows to 
perform a task . For example, Figure 1-1 shows screens using Microsoft Word and 
PowerPoint, two commonly used programs . 
1 

2 
Chapte r 1 
Introduction to Computers and Programming 
Figure 1-1 A Word Process ing Program and a Presentation Program 
II Q .,. 
U :, , 
,....,.,"-~ 
-
t 11r • 
.. 
• 
11!11 -
,. •. .._ 
-uoc,,,i 
•...:u 
_,. 
-
-
•-A 
• :,: 
_...., 
u 
,: ~· .. 
• 
~"" 
I• 
~ ......o.o.-WbC AdOCc . 
" 
-
,r •I .,._._, 
"'·4·1!:••• 
!I•~
. 
• 
,_, ... ,_,._,, 
~ 
-
C:O!lCUr •A-
• • .... --
......... 
-
.. _,
• ,......• 
__ ,.._ ................... 
~-....... _ 
--
C'_ 
.. ......,._ 
.... 
___ 
Af ......... 
1" .... 
,.,..,.,_, 
........ 
__ 
.............. 
,....... 
........
. -, .. ..._.,._ .... 
..... _.,....,_\.,..,,-, 
...... , ... n._.,.,__, 
...... 
I o..a.,,....., • .,_...,-lfA, 
__ .. ,_ .... 
~ 
: .,,,_,., 
.. ___ ........ 
*'"""·""'"" 
o.,.., __ 
. 
_.....,_Ita-
l ~._..., 
......... -~ 
....... _. 
.. ,... ......... 
_... 
........... 
_. __ ~,.,--.. --._.....-
.. 
··-
. ~.,_,,_ ..... 
_,..,. ___ 
., __ _ 
"~._.... ... _ .. _.,_.,_Hl .... 
n.-. 
_..,. 
.. ..,.,1 ................ 
. 
~ 
.... -- .. 
.-.,_.._,.,. ......... 
, ..... 
_.... 
~ .. 
.,_...,_ 
.. ._,,,,_"-_.,. __ 
.....,.. 
.... ,...., 
..................... 
!, ........... 
~ 
...... 
-
............. __ 
,,,_..._ 
... 
....,_ .. __ 
.. 
,.,.__ ..... 
.. _...., • .,~.,....-
.. ...,..,au_.,..~_ 
... _______ ,. __ '- ___ .,,_tC 
....,_....._.__ 
....
. . ... 411,1. 
........ 
0\.. _• 
--11 
..... 
, ..... 
.,,_, 
__ '-_____ 
... 
l'IU 
·-
II 
'[QJ 
I 
I U $ •!~ 
W 
A • M• 
1; .,-
~ 
.... 
:,., " 
1" Quarter 
,_ 
, .__ 
·-... 
. ........ 
,01 ... 
1 
Cl) 
-
C 
X 
nM[W 
vr:w .... 
>wt 1 011 
Ill 
;. i,otr, 
• co..1~1111, 
I· 
:: 
• 
~ - - 1- --
+ ~\, c.; 
Programs are commonly referred to as software . Software is essential to a computer 
because without software, a computer can do nothing . All of the software that we use 
to make our computers useful is created by individuals known as programmers or 
software developers. A programmer, or software developer, is a person with the 
training and skills necessary to design, create, and test computer programs. Computer 
programming is an exciting and rewarding career. Today you will find programmers 
working in business, medicine, government, law enforcement, agriculture, academics, 
entertainment, and almost every other field. 
Computer programming is both an art and a science. It is an art because every aspect 
of a program should be designed with care and judgment . Listed below are a few of the 
things that must be designed for any real-world computer program: 
• The logical flow of the instruct ions 
• The mathematical procedures 
• The appearance of the screens 
• The way information is presented to the user 
• The program's "user-friendliness" 
• Manuals and other forms of written documentation 
There is also a scientific, or engineering side to programm ing. Because programs rarely 
work right the first time they are written, a lot of experimentation, correction, and 
redesigning is required . This demands patience and persistence of the programmer. 
Writing software demands discipline as well. Programmers must learn special languages 
like C++ because computers do not understand English or other human languages . 
Languages such as C++ have strict rules that must be carefully followed. 
Both the artistic and scientific nature of programming makes writing computer software 
like designing a car. Both cars and programs should be functional, efficient, powerfu l, 
easy to use, and pleasing to look at. 

1.2 
Figure 1-2 
1.2 Computer Systems: Hardware and Software 
3 
Computer Systems: Hardware and Software 
CONCEPT
: All comput er systems consist of similar hardware devices and software 
components. Thi s section provides an overview of standard comput er 
hardware and software organization. 
Hardware 
Hardware refers to the physical components of a computer. A computer, as we gener-
ally think of it, is not an individual device but a system of devices. Like the instruments 
in a symphony orchestra, each device plays its own part . A typical computer system 
consists of the following major components: 
• The centra l processing unit (CPU) 
• Main memory (random -access memory, or RAM) 
• Secondary storage devices 
• Input devices 
• Output devices 
The organization of a computer system is depicted in Figure 1-2. 
.. 
.. 
Input 
Devices 
.. 
Central Processing 
Unit 
Main Memory 
(RAM) 
.. 
Output 
Devices 
.. 
.. 
! 
Secondary 
Storage Devices 

4 
Chapte r 1 
Figure 1-3 
Introduction to Computers and Programming 
The CPU 
When a computer is performing the tasks that a program tells it to do, we say that the 
computer is running or executing the program . The central processing unit, or CPU, is 
the part of a computer that actually runs programs . The CPU is the most important 
component in a computer because without it the computer could not run software . 
In the earliest computers, CPUs were huge devices made of electrical and mechanica l 
components such as vacuum tubes and switches. Today's CPUs, known as micropro -
cessors, are tiny chips small enough to be held in the palm of your hand . In addition to 
being much smaller than the old electromechanica l CPUs in early computers, today 's 
microprocessors are also much more powerful. 
The CPU's job is to fetch instruct ions, follow the instructions, and produce some result. 
Internally, the central processing unit consists of two parts: the control unit and the 
arithmetic and logic unit (ALU) . The control unit coordinates all of the computer's 
operations . It is responsible for determining where to get the next instruction and for 
regulating the other major components of the computer with control signals. The 
arithmet ic and logic unit, as its name suggests, is designed to perform mathematical 
operations . The organizat ion of the CPU is shown in Figure 1-3. 
Instruction 
input 
-
Central processing unit 
(CPU) 
Arithmetic and 
logic unit 
(ALU) 
Control unit 
Result 
output 
A program is a sequence of instructions stored in the computer's memory. When a 
computer is running a program, the CPU is engaged in a process known formally as the 
fetch/decode/execute cycle. The steps in the fetch/decode/execute cycle are as follows: 
Fetch 
Decode 
Execute 
The CPU's control unit fetches, from main memory, the next instruction in 
the sequence of program instructions . 
The instruction is encoded in the form of a number. The control unit 
decodes the instruction and generates an electronic signal. 
The signal is routed to the appropriate component of the computer (such as 
the ALU, a disk drive, or some other device). The signal causes the component 
to perform an operation . 
These steps are repeated as long as there are instructions to perform . 

Figure 1-4 
0 
10 
20 
1.2 Computer Systems: Hardware and Software 
5 
Main Memory 
You can think of main memory as the computer's wor k area. This is where the 
computer stores a program while the program is running, as well as the data that the 
program is working with. For example, suppose you are using a word processing 
program to write an essay for one of your classes. While you do this, both the word 
processing program and the essay are stored in main memory . 
Main memory is commonly known as random-access memory or RAM. It is called this 
because the CPU is able to quickly access data stored at any random location in this 
memory. RAM is usually a volatile type of memory that is used only for temporary 
storage while a program is running . When the computer is turned off, the contents of 
RAM are erased . Inside your computer, RAM is stored in small chips. 
A computer's memory is divided into tiny storage cells known as bytes . One byte is 
enough memory to store just a single letter of the alphabet or a small number. In order 
to do anything meaningfu l, a compute r has to have lots of bytes. Most computers 
today have millions, or even billions, of bytes of memory . 
Each byte is divided into eight smaller storage locations known as bits. The term bit 
stands for binary digit. Computer scientists usually think of bits as tiny switches that 
can be either on or off. Bits aren't actual "switches," however, at least not in the con-
ventional sense. In most computer systems, bits are tiny electrical components that can 
hold either a positive or a negative charge. Computer scientists think of a positive charge 
as a switch in the on position and a negative charge as a switch in the off position. 
Each byte is assigned a unique number known as an address . The addresses are 
ordered from lowest to highest . A byte is identified by its address, in much the same 
way a post office box is identified by an address, so that the data stored there can be 
located . Figure 1-4 shows a group of memory cells with their addresses. The number 
149 is stored in the cell at address 16, and the number 72 is stored at address 23. 
2 
3 
4 
5 
6 
7 
8 
9 
Secondary Storage 
Secondary storage is a type of memory that can hold data for long periods of time-
even when there is no power to the computer. Frequently used programs are stored in 
secondary memory and loaded into main memory as needed. Important information, 
such as word processing documents, payroll data, and inventory figures, is saved to 
secondary storage as well. 
The most common type of secondary storage device is the disk drive. A disk drive 
stores data by magnetically encoding it onto a circular disk. Most comp uter s have a 

6 
Chapte r 1 
Introduction to Computers and Programming 
disk drive mounted inside their case. External disk drives, which connect to one of 
the computer's communication ports, are also available . External disk drives can be 
used to create backup copies of important data or to move data to another computer. 
In addition to external disk drives, many types of devices have been created for copying 
data and for moving it to other computers. The most commonly used devices today are 
USB flash drives. These are small devices that plug into the computer's USB (universal serial 
bus) port and appear to the system as a disk drive. These drives, which use flash memory to 
store data, are inexpensive, reliable, and small enough to be carried in your pocket. 
Optical devices such as the CD (compact disc) and the DVD (digital versatile disc) are 
also popular for data storage . Data is not recorded magnetically on an optical disc, but 
rather is encoded as a series of pits on the disc surface. CD and DVD drives use a laser 
to detect the pits and thus read the encoded data . Optical discs hold large amounts of 
data , and because recordab le CD and DVD drives are now commonplace, they are 
good media for creating backup copies of data. 
Input Devices 
Input is any information the computer collects from the outside world. The device that 
collects the informat ion and sends it to the computer is called an input device. Com-
mon input devices are the keyboard , mouse, touch screen, scanner, digital camera, and 
microphone . Disk drives, CD/DVD drives, and USB flash drives can also be considered 
input devices because programs and information can be retrieved from them and 
loaded into the computer's memory . 
Output Devices 
Output is any information the computer sends to the outside world . It might be a sales 
report , a list of names, or a graph ic image. The information is sent to an output device, 
which formats and presents it. Common output devices are computer screens, printers, 
and speakers. Disk drives, USB flash drives, and CD/DVD recorders can also be con-
sidered output devices because the CPU can send information to them to be saved. 
Software 
If a computer is to function, software is needed. Everything that a computer does, from 
the time you turn the power switch on until you shut the system down , is under the 
control of software . There are two general categories of software: system software and 
application software. Most computer programs clearly fit into one of these two categories. 
Let's take a closer look at each. 
System Software 
The programs that contro l and manage the basic operations of a computer are gener-
ally referred to as system software . System software typically includes the following 
types of programs: 

1.2 Computer Systems: Hardware and Software 
7 
• Operating Systems 
An operating system is the most fundamental set of programs on a computer. The 
operating system controls the internal operat ions of the computer's hardware, 
manages all the devices connected to the computer, allows data to be saved to and 
retrieved from storage devices, and allows other programs to run on the computer. 
• Utility Programs 
A utility program performs a specia lized task that enhances the computer's 
operation or safeguards data . Examples of utility programs are virus scanners, 
file-compression programs, and data -backup programs . 
• Software Development Tools 
The software tools that programmers use to create, modify, and test software are 
referred to as software development tools. Compilers and integrated development 
environments, which we discuss later in this chapter, are examples of programs 
that fall into this category . 
Application Software 
Programs that make a computer useful for everyday tasks are known as application 
software, or application programs. These are the programs that people normally spend 
most of their time running on their computers . Figure 1-1, at the beginning of this 
chapter, shows screens from two commonly used applications Microsoft Word, a word 
processing program, and Microsoft PowerPoint, a presentation program . Some other 
examples of application software are spreadsheet programs, e-mail programs, Web 
browsers, and game programs. 
~ 
Checkpoint 
1.1 
Why is the computer used by so many different people, in so many different 
professions? 
1.2 
List the five major hardware components of a computer system. 
1.3 
Internally, the CPU consists of what two units? 
1.4 
Describe the steps in the fetch/decode/execute cycle. 
1.5 
What is a memory address? What is its purpose? 
1.6 
Explain why computers have both main memory and secondary storage. 
1. 7 
What are the two general categories of software? 
1.8 
What fundamenta l set of programs controls the interna l operations of the 
computer's hardware? 
1.9 
What do you call a program that performs a specialized task, such as a virus 
scanner, a file-compression program, or a data -backup program? 
1.10 
Word processing programs, spreadsheet programs, e-mail programs, Web 
browsers, and game programs belong to what category of software? 

8 
Chapte r 1 
1.3 
Introduction to Computers and Programming 
Programs and Programming 
Languages 
CONCEPT: 
A progra m is a set of instru ctions a computer follow s in order to 
perform a task. A programming language is a special language used to 
write computer program s. 
What Is a Program? 
Computers are designed to follow instructions. A computer program is a set of instruc-
tions that tells the comp uter how to solve a prob lem or perform a task . For example, 
suppose we want the comp uter to calculate someone's gross pay. Here is a list of things 
the comp uter might do: 
1. Display a message on the screen asking "How many hours did you work?" 
2. Wait for the user to enter the number of hours worked . Once the user enters a 
number, store it in memory. 
3. Display a message on the screen asking "How much do you get paid per hour?" 
4. Wait for the user to enter an hourly pay rate. Once the user enters a number, store 
it in memory . 
5. Multip ly the number of hours by the amount paid per hour, and store the result 
m memory. 
6. Display a message on the screen that tells the amo unt of money earned . Th e 
message must include the result of the calculation performed in step 5. 
Collectively, these instructions are called an algorithm . An algorithm is a set of well-
defined steps for performing a task or solving a problem . Not ice these steps are ordered 
sequentially. Step 1 should be performed before step 2, and so forth . It is important 
that these instructions be performed in their proper sequence. 
Although a person might easily understand the instructions in the pay-calculating algorithm, 
it is not ready to be executed on a computer because a computer's CPU can only process 
instructions written in machine language. A machine language program consists of a 
sequence of binary numbers (numbers consisting of only ls and Os), which the CPU interprets 
as commands. Here is an example of what a machine language instruction might look like: 
101101000000010 1 
As you can imagine, encoding an algorit hm in machine language would be tedious and 
difficult . In addit ion, each different type of CPU has its own machine language. So if 
you wrote a machine language program for comp uter A and then wanted to run it on 
a computer B that has a different type of CPU, you would have to rewrite the program 
in comp uter B's machine language. 
Programming languages, which use words instead of numbers, were invented to ease the task 
of programming. A program can be written in a programming language such as C++, which 
is much easier to understand and write than machine language. Programmers can then save 
their programs in text files and use special software to convert them to machine language. 
Program 1-1 shows how the pay-calculating algorithm might be written in C++. 

1.3 Programs and Programm ing Languages 
9 
0 
NOTE: The line numbers shown in Program 1-1 are not part of the program. This 
book shows line numbers in all program listings to help point out specific parts of 
the program . 
Program 1-1 
1 II This program calcu la tes the user's 
pay. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
double hours, 
rate, 
pay; 
8 
9 
II Get the number of hours worked. 
10 
cout << "How many hours did you work?"; 
11 
cin 
>> hours; 
12 
13 
II Get the hourly 
pay rate. 
14 
cout << "How much do you get paid per hour?"
; 
15 
cin 
>> rate; 
16 
17 
II Calculate 
the pay. 
18 
pay= 
hours* 
rate; 
19 
20 
II Di splay the pay . 
21 
cout << "You have earned$
"<< 
pay<< 
endl; 
22 
return 
O; 
23
} 
Program Output with Example Input Shown in Bold 
How many hours did you work? 10 [Enter] 
How much do you get paid per hour? 15 [Enter] 
You have earned $150 
The "Program Output with Example Input Shown in Bold" shows what the program 
will display on the screen when it is running. In the example, the user enters 10 for the 
number of hours worked and 15 for the hourly pay. The program displays the earn-
ings, which are $150. 
Programming 
Languages 
In a broad sense, there are two categories of programming languages: low level and 
high level. A low -level language is close to the level of the computer, which means it 
resembles the numeric machine language of the computer more than the natural lan-
guage of humans. The easiest languages for people to learn are high-level languages. 
They are called "high level" because they are closer to the level of human-readability 
than computer-readability. Figure 1-5 illustrates the concept of language levels. 

10 
Chapte r 1 
Figure 1-5 
Introduction to Computers and Programming 
High level (Easily understood by humans) 
t 
Low level (machine language) 
1010001011101011 
Many high-level languages have been created. Table 1-1 lists a few of the well-known ones. 
Table 1-1 Well-Known High-Level Programming Languages 
Language 
BASIC 
C 
C++ 
C# 
COBOL 
FORTRAN 
Java 
JavaScript 
Pascal 
Python 
Description 
Beginners All-purpose Symbolic Instruction Code. A general programming 
language originally designed to be simple enough for beginners to learn . 
A structured, general -purpose language developed at Bell Laboratories. C offers 
both high-level and low-level features. 
Based on the C language, C++ offers object-oriented features not found in C. Also 
invented at Bell Laboratories. 
Pronounced "C sharp ." A language invented by Microsoft for developing 
applicat ions based on the Microsoft .NET platform . 
Common Business-Oriented Language. A language designed for business applications. 
Formula Translator. A language designed for programming complex mathemat ical 
algorithms . 
An object-oriented language invented at Sun Microsystems. Java may be used to 
develop programs that run over the Internet in a Web browser. 
A language used to write small programs that run in Web pages. Despite its name, 
JavaScript is not related to Java . 
A structured, general-purpose language designed primarily for teaching programming . 
A genera l-purpose language created in the early 1990s. It has become popular for 
both business and academic appl ications . 

Ruby 
Visual Basic 
<) 
1.3 Programs and Programming Languages 
11 
A general-purpose language created in the 1990s . It is becoming increasingly 
popular for programs that run on Web servers. 
A Microsoft programming language and software development environment that 
allows programmers to quickly create Windows -based applications . 
C++ is a widely used language because, in addition to the high-level features necessary 
for writing applications such as payroll systems and inventory programs, it also has 
many low-level features . C++ is based on the C language, which was invented for pur-
poses such as writing operating systems and compilers . Because C++ evolved from C, it 
carries all of C's low-level capabil ities with it. 
C++ is also popular because of its portability . This means that a C++ program can be 
written on one type of computer and then run on many other types of systems. This 
usually requires recompi ling the program on each type of system, but the program 
itself often needs little or no change . 
NOTE: Programs written for specific graphical environments typically do require sig-
nificant changes when moved to a different type of system. Examples of such graphical 
environments are Windows, the X-Window System, and the Mac OS operating system. 
Source Code, Object Code , and Executable Code 
When a C++ program is written, it must be typed into the computer and saved to a file. 
A text editor, which is similar to a word processing program, is used for this task. The 
statements written by the programmer are called source code, and the file they are 
saved in is called the source file. 
After the source code is saved to a file, the process of translating it to machine language 
can begin. During the first phase of this process, a program called the preprocessor reads 
the source code. The preprocessor searches for special lines that begin with the # symbol. 
These lines contain commands, or directives, that cause the preprocessor to amend or 
process the source code in some way. During the next phase the compiler steps through 
the preprocessed source code, translating each source code instruction into the appropr i-
ate machine language instruction. This process will uncover any syntax errors that may be 
in the program . Syntax errors are illegal uses of key words, operators, punctuation, and 
other language elements. If the program is free of syntax errors, the compiler stores the 
translated machine language instructions, which are called object code, in an object file. 
Although an object file contains machine language instruct ions, it is not a complete 
program. Here is why. C++ is conveniently equipped with a library of prewritten code for 
performing common operat ions or sometimes-difficult tasks . For example, the library 
contains hardware -specific code for displaying messages on the screen and reading input 
from the keyboard. It also provides routines for mathemat ical functions, such as calculating 
the square root of a number. This collection of code, called the run-time library, is extensive. 
Programs almost always use some part of it. When the compiler generates an object file, 
however, it does not include machine code for any run-time library routines the programmer 
might have used. During the last phase of the translation process, another program called 
the linker combines the object file with the necessary library routines . Once the linker has 
finished with this step, an executable file is created. The executable file contains machine 
language instructions, or executable code, and is ready to run on the computer. 

12 
Chapte r 1 
Figure 1-6 
I 
I 
I 
Introduction to Computers and Programming 
Figure 1-6 illustrates the process of translating a C++ source file into an executable file. 
The entire process of invoking the preprocessor , compiler, and linker can be initiated 
with a single action. For example, on a Linux system, the following command causes 
the C++ program named he 11 o. cpp to be preprocessed , compiled, and linked. The 
executable code is stored in a file named he 11 o. 
g++ -o hello hello.cpp 
Source code 
hello.cpp 
-
Preprocessor 
' 
-
Modified 
source code 
~ 
Compiler 
' . 
-
Object code 
hello.obj 
~ 
Linker 
' . 
-
Executable code 
hello.exe 
-
--
I 
/ 
I 
/ 
I 
/ 
--
Source code is entered 
with a text editor by 
the programmer. 
// hello. cpp 
#include 
<iostream> 
using namespace std ; 
i nt main( ) 
{ 
} 
cout << "Hello World\n"; 
r eturn O; 
Many development systems, particularly those on persona l computers, have integrated 
development environments (IDEs). These environments consist of a text editor, com-
piler, debugger, and other utilities integrated into a package with a single set of menus. 
Preprocessing, compiling, linking, and even executing a program is done with a single 
click of a button , or by selecting a single item from a menu . Figure 1-7 shows a screen 
from the Microsoft Visual Studio 2013 IDE. 

1.4 What Is a Program Made of? 
13 
Figure 1-7 
DrQ 
Gronl>,y•MICrowltViMHIStWIO 
'f O Qutd.l..uodl(Clll•Q) 
fl.!. 
run 
V1.W PRClIC I 
IIJI.I) 
0[8UG 
1£AM 
l(K>IS 
l(S1 
O • 
lil·~
lid' 
?• 
i(' 
' 
· 
---------------------
· 
SolutionE,.ploe~ 
} 
l§IG,o, .. ., 
(GI""' S<op,J 
i 
l 
I/ 
TI~h p,~ 
-
<.•l\.1,1hlca, 
U1,r VJ_., ·a. P•Y• 
i 
l 
•lndude 
<!01.l r cn> 
3 
vdJi.K n-JP•'-• 
>ld; 
• 
j 
int -1.no 
. 
( 
, 
• • 
lt 
1l 
12 
H 
1' 
l> 
lb 
1/ 
10 
" ,. 
71 
" 
" 
ii 
100"-
• 
II Get tl\t> l'IUllbu of houn ~d 
• 
covt « ·"'* Nn)' houl"S did >'°" wc,rlct * : 
(ln 
-» hour, : 
II ~ 
tl'tt hlk.tr 1 )' ~'I nu·. 
cout « "Hc!W -.,ch cJo you en p,oid per flour? "; 
cin 
)) t' At ~; 
II talcu1ou 
the poy. 
P"'I • hot,I"\ 
• r'",llt f'; 
JI Ohpl.y 
~ 
SW''f· 
covt << evou h111w f'•mf'd 
J" << pwy << l"f'ldl; 
l'#' t 1U'ft n; 
~ 
Checkpoint 
1.11 
What is an algorithm? 
• Q m,m() 
+ ""'"""'"""""'·~«••·:> 
Ci) Solu11on 'Gron P.rf O proj,rd) 
" LS) G,o»P..,. 
• 9 X 
I) 
• 
btt m•ll)cpu,dtneit5 
• 
RMOl#Cf' fdtt 
,. .... Source Flies: 
> .. p,I.OIL,pp 
1.12 
Why were computer programm ing languages invented? 
p 
-
0 
X 
s.9"'.. B 
• 9 " 
P · 
1.13 
What is the difference between a high-level language and a low-level language? 
1.14 
What does portability mean? 
1.4 
1.15 
Explain the operations carried out by the preprocessor , compiler, and linker. 
1.16 
Explain what is stored in a source file, an object file, and an executable file. 
1.17 
What is an integrated development environment? 
What Is a Program Made of? 
CONCEPT: 
There are certain elements that are common to all programming languages. 
Language Elements 
All programming languages have a few things in common . Table 1-2 lists the common 
elements found in almost every language. 

14 
Chapte r 1 
Introduction to Computers and Programming 
Table 1-2 Programming Language Elements 
Language Element 
Key Words 
Programmer -Defined 
Identifiers 
Operators 
Punctuation 
Syntax 
Description 
Words that have a specia l meaning . Key words may only be used for 
their intended purpose . Key words are also known as reserved words . 
Words or names defined by the programmer. They are symbol ic names 
that refer to variables or programming routines . 
Operators perform operations on one or more operands . An operand is 
usually a piece of data, like a number. 
Punctuation characters that mark the beginning or ending of a statement, 
or separate items in a list. 
Rules that must be followed when constructing a program. Syntax 
dictates how key words and operators may be used, and where 
punctuation symbols must appear. 
Let's look at some specific partS of Program 1-1 (the pay-calculating program) to see exam-
ples of each element listed in the table above. For convenience, Program 1-1 is listed again. 
Program 1-1 
1 II Thi s program calcula t es t he user's 
pay. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main () 
6 { 
7 
double hours , rate , pay; 
8 
9 
II Get t he number of hours worked. 
10 
cout << "How many hours did you work?"; 
11 
ci n >> hours; 
12 
13 
II Get t he hourly pay ra t e . 
14 
cout << "How much do you get paid per hour?"; 
15 
ci n >> rate; 
16 
17 
II Calculate 
t he pay . 
18 
pay= 
hours* 
rate; 
19 
20 
II Di splay t he pay. 
21 
cout << "You have earned$"<< 
pay<< endl; 
22 
return 
O; 
23
} 
Key Words (reserved words) 
Three of C++'s key words appear on lines 3 and 5: using , names pace, and int . The word 
double , which appears on line 7, is also a C++ key word . These words, which are always 
written in lowercase, each have a special meaning in C++ and can only be used for their 

1.4 What Is a Program Made of? 
15 
intended purposes. As you will see, the programmer is allowed to make up his or her own 
names for certain things in a program. Key words, however, are reserved and cannot be 
used for anything other than their designated purposes. Part of learning a programming 
language is learning what the key words are, what they mean, and how to use them. 
0 
NOTE: The #i nclude 
<iostream> 
statement in line 2 is a preprocessor directive. 
0 
NOTE: In C++, key words are always written in all lowercase . 
Programmer -Defined Identifiers 
The words hours, rate, and pay that appear in the program on lines 7, 11, 15, 18, and 
21 are programmer -defined identifiers . They are not part of the C++ language but 
rather are name s made up by the programmer. In this particular program , these are the 
names of variables . As you will learn later in this chapter, variables are the names of 
memory locations that may hold data. 
Operators 
On line 18 the following statement appears: 
pay= 
hours* 
rate; 
The = and * symbols are both operators . They perform operations on pieces of data, known 
as operands . The * operator multiplies its two operands, which in this example are the 
variables hours and rate. The = symbol is called the assignment operator. It takes the 
value of the expression on the right and stores it in the variable whose name appears on the 
left. In this example, the = operator stores in the pay variable the result of the hours vari-
able multiplied by the rat e variable. In other words, the statement says, "Make the pay 
variable equal to hours times rat e " or "pay is assigned the value of hours times rate ." 
Punctuation 
Notice that many lines end with a semicolon. A semicolon in C++ is similar to a period in 
English. It marks the end of a complete sentence (or statement, as it is called in program -
ming). Semicolons do not appear at the end of every line in a C++ program , however. 
There are rules that govern where semicolons are required and where they are not. Part 
of learning C++ is learning where to place semicolons and other punctuat ion symbols. 
Lines and Statements 
Often, the contents of a program are thought of in terms of lines and statements. A line is 
just that- a single line as it appears in the body of a program . Program 1-1 is shown with 
each of its lines numbered. Most of the lines contain something meaningful; however, some 
of the lines are empty. The blank lines are only there to make the program more readable. 
A statement is a complete instruction that causes the computer to perform some action. 
Here is the statement that appears in line 10 of Program 1-1: 
cout 
<< "How many hours 
did 
you work?"; 

16 
Chapte r 1 
0 
Figure 1-8 
0 
1 
10 
20 
Introduction to Computers and Programming 
It causes the computer to display the message "How many hours did you work?" on 
the screen. Statements can be a combination of key words, operators, and program -
mer-defined symbols . Statements usually occupy only one line in a program, but some-
times they are spread out over more than one line. 
Variables 
A variable is a named storage location in the computer's memory for holding a piece of 
data. The data stored in variables may change while the program is running (hence the name 
"variable"). Notice that in Program 1-1 the words hours, ra t e, and pay appear in several 
places. All three of these are the names of variables. The hours variable is used to store the 
number of hours the user worked. The rate variable stores the user's hourly pay rate. The 
pay variable holds the result of hours multiplied by rat e, which is the user's gross pay. 
NOTE: Notice the variables in Program 1-1 have names that reflect their purpose. This 
is considered good programming because it makes it easy to guess what each variable is 
being used for just by reading its name. This is discussed further in Chapter 2. 
Variables are symbolic names that represent locations in the computer's random -access 
memory (RAM). When information is stored in a variable, it is actually stored in RAM. 
Assume a program has a variable named 1 ength . Figure 1-8 illustrates the way the 
variable name represents a memory location . 
2 
3 
4 
5 
6 
7 
8 
9 
length 
In Figure 1-8 the variable 1 engt h is holding the value 72. The number 72 is actually stored 
in RAM at address 23, but the name 1 engt h symbolically represents this storage location. 
You can think of a variable as a box that holds information. In Figure 1-8, the number 72 
is stored in the box named 1 engt h. Only one item may be stored in the box at any given 
time. If the program stores another value in this box, it will take the place of the number 72. 
Variable Definitions 
In programming, there are two general types of data: numbers , such as 3, and charac -
ters, such as the letter 'A'. Numbers are used to perform mathematical operations, and 
characters are used to print information on the screen or on paper. 

1.5 
1.5 Input, Processing, and Output 
17 
Numeric data can be categorized even further. For instance, the following are all whole 
numbers, or integers: 
5 
7 
- 129 
32154 
The following are real, or floating-point, numbers: 
3. 14159 
6.7 
1 . 000 2 
When you create a variable in a C++ program, you must know what type of data the 
program will be storing in it. Look at line 7 of Program 1-1: 
double hours, 
rate, 
pay; 
The word doubl e in the statement indicates that the variables hour s, r ate, and pay 
will be used to hold double precision floating-point numbers. This statement is called a 
variable definition . In C++, all variab les must be defined before they can be used 
because the variable definition is what causes the variables to be created in memory. If 
you review the listing of Program 1-1, you will see that the variable definitions come 
before any other statements using those variables. 
Input, Processing, and Output 
CO N C E PT : The three primary activities of a program are input, processing, and output. 
Computer programs typically perform a three-step process of gathering input, performing 
some process on the information gathered, and then producing output . Input is informa-
tion a program collects from the outside world. It can be sent to the program by the user, 
who is entering data at the keyboard or using the mouse. It can also be read from disk 
files or hardware devices connected to the computer. Program 1-1 allows the user to enter 
two items of information: the number of hours worked and the hourly pay rate. Lines 11 
and 15 use the ci n (pronounced "see in" ) object to perform these input operations: 
ci n >> hours; 
ci n >> r ate ; 
Once information is gathered from the outside world, a program usually processes it in 
some manner. In Program 1-1, the hours worked and hourly pay rate are multiplied in 
line 18 to produce the value assigned to the variable pay: 
pay= 
hour s* 
rate; 
Output is information that a program sends to the outside world. It can be words or 
graphics displayed on a screen, a report sent to the printer, data stored in a file, or 
informat ion sent to any output device connected to the computer. 
Lines 10, 14, and 21 in Program 1-1 all use the cout (pronounced "see out") object to 
display messages on the computer's screen. 

18 
Chapte r 1 
Introduction to Computers and Programming 
cout << "How many hours did you work?"; 
cout << "How much do you get paid pe r hour?"; 
cout << "You have earned$
"<< 
pay<< 
endl ; 
You will learn more about ob jects later in the book and abo ut the cout and ci n objects 
in Chapters 2 and 3 . 
~ 
Checkpoint 
1.6 
Figure 1-9 
1.18 
D escribe the difference between a key word and a programmer -defined symbo l. 
1.19 
D escr ibe the difference between operato rs and punctuat ion symbols. 
1.20 
D escr ibe the difference between a program line and a statement . 
1.21 
Why are variables called "variable"? 
1.22 
What happen s to a var iable's current contents when a new val ue is stored there? 
1.23 
What mu st take place in a program before a var iab le is used? 
1.24 
What are the three primary act ivities of a program? 
The Programming 
Process 
CONCEPT: 
Th e programming 
proce ss consists 
of severa l steps, whi ch include 
de sign, crea tion, testin g, and debugging activitie s. 
Designing and Creating a Program 
Now that you have been introduced 
to what a program 
is, it's time to consider the 
process of creating a program. Qu ite often, when inexperienced students are given pro -
gramming 
assignments, 
they have trouble getting started 
because they don't kn ow 
what to do first . If yo u find yo ur self in this di lemma, the steps listed in Figure 1-9 may 
help. Th ese are the steps recommended 
for the process of writin g a program. 
1. Define what the program is to do. 
2. Visualize the program running on the computer. 
3. Use design tools to create a model of the program. 
4. Check the model for logical errors. 
5. Write the program source code. 
6. Compile the source code. 
7. Correct any errors found during compilation. 
8. Link the program to create an executable file. 
9. Run the program using test data for input. 
10. Correct any errors found while running the program. 
Repeat steps 4 through 10 as many times as necessary. 
11. Validate the results of the program. 

1.6 The Programming Process 
19 
The steps listed in Figure 1-9 emphasize the importance of planning. Just as there are 
good ways and bad ways to build a house, there are good ways and bad ways to create 
a program . A good program always begins with planning . 
With the pay-calculating program as our example, let's look at each step in more detail. 
1 . Define what the program is to do. 
This step requires that you clearly identify the purpose of the program , the information 
that is to be input, the processing that is to take place, and the desired output . Here are 
the requirements for the example program: 
Purpose 
To calculate the user's gross pay. 
Input 
Number of hours worked, hourly pay rate. 
Processing 
Multip ly number of hours worked by hourly pay rate. The result is the 
user's gross pay. 
Output 
Display a message indicating the user's gross pay. 
2. Visualize the program running on the computer. 
Before you create a program on the computer, you should first create it in your mind. 
Step 2 is the visualization of the program . Try to imagine what the computer screen 
looks like while the program is running . If it helps, draw pictures of the screen, with 
sample input and output, at various points in the program. For instance, here is the 
screen produced by the pay-calculating program: 
How many hours did you work? 10 
How much do you get paid per hour? 15 
You earned $150 
In this step, you must put yourself in the shoes of the user. What messages should the 
program display? What questions should it ask? By addressing these issues, you will 
have already determined most of the program's output . 
3. Use design tools to create a model of the program. 
While planning a program , the programmer uses one or more design tools to create a 
model of the program . Three common design tools are hierarchy charts, flowcharts , 
and pseudocode . A hierarchy chart is a diagram that graphically depicts the structure 
of a program. It has boxes that represent each step in the program. The boxes are con-
nected in a way that illustrates their relationship to one another. Figure 1-10 shows a 
hierarchy chart for the pay-calculating program . 
A hierarchy chart begins with the overall task and then refines it into smaller subtasks . 
Each of the subtasks is then refined into even smaller sets of subtasks, until each is 
small enough to be easily performed. For instance, in Figure 1-10, the overall task 
"Calculate Gross Pay" is listed in the top-level box. That task is broken into three sub-
tasks . The first subtask, "Get Payroll Data from User," is broken further into two 
subtasks. This process of "divide and conquer" is known as top-down design. 

20 
Chapte r 1 
Figure 1-10 
0 
a 
VideoNot e 
Designing a 
Program with 
Pseudocode 
Introduction to Computers and Programming 
Calculate 
gross pay 
I 
I 
Get payroll data 
Set pay to 
Display 
hours worked 
from user 
times pay rate 
pay 
I 
I 
I 
Read number of 
Read hourly 
hours worked 
pay rate 
A flowchart is a diagram that shows the logical flow of a program. It is a useful tool for 
planning each operation a program must perform and the order in which the operations 
are to occur. 
NOTE: Information on creating flowcharts can be found in Appendix Non this 
book's companion website at pearsonhighered .com/gaddis . 
Pseudocode is a cross between human language and a programm ing language . 
Although the computer can't understand pseudocode, programmers often find it 
helpful to write an algorithm using it. This is because pseudocode is similar to natura l 
language, yet close enough to programming language that it can be easily converted 
later into program source code. By writing the algorithm in pseudocode first, the 
programmer can focus on just the logical steps the program must perform, without 
having to worry yet about syntax or about details such as how output will be displayed. 
Pseudocode can be written at a high level or at a detailed level. Many programmers use 
both forms. High-level pseudocode simply lists the steps a program must perform . 
Here is high-level pseudocode for the pay-calculating program. 
Get payroll 
data 
Calculate 
gross pay 
Display 
gross pay 
High-level pseudocode can be expanded to produce detailed pseudocode . Here is the 
detailed pseudocode for the same program . Not ice that it even names variables and 
tells what mathematical operations to perform. 
Ask the user to input the number of hours worked 
I nput hours 
Ask the user to input the hourly pay rate 
I nput rate 
Set pay equal to hours times rate 
Display 
pay 

1.6 The Programming Process 
21 
4. Check the model for logical errors. 
Logical errors, also called logic errors, are mistakes that cause a program to produce errone-
ous results. Examples of logical errors would be using the wrong variable's value in a com-
putation or performing order-dependent actions in the wrong order. Once a model of the 
program has been created, it should be checked for logical errors. The programmer should 
trace through the charts or pseudocode, checking the logic of each step. If an error is found, 
the model can be corrected before the actual program source code is written. In general, the 
earlier an error is detected in the programming process, the easier it is to correct. 
5. Write the program source code. 
Once a model of the program (hierarchy chart, flowchart, or pseudocode ) has been 
created, checked, and corrected, the programmer is ready to write the source code, 
using an actual computer programming language , such as C++. Most programmers 
write the code directly on the compute r, typing it into a text editor. Some programmers, 
however, prefer to write the program on paper first, then enter it into the computer. 
Once the program has been entered, the source code is saved to a file. 
6. Compile the source code. 
Next the saved source code is ready to be compiled. The compiler will translate the 
source code to machine language. 
7. Correct any errors found during compilation. 
If the compiler reports any errors, they must be corrected and the code recompi led. 
This step is repeated until the program is free of compile-time errors. 
8. Unk the program to create an executable file. 
Once the source code compiles with no errors, it can be linked with the libraries speci-
fied by the program # i nc 1 ude statements to create an executable file. If an error occurs 
during the linking process, it is likely that the program has failed to include a needed 
library file. The needed file must be included and the program relinked. 
9. Run the program using test data for input. 
Once an executable file is generated, the program is ready to be tested for run-time and 
logic errors. A run-time error occurs when the running program asks the computer to do 
something that is impossible, such as divide by zero. Normally a run-time error causes the 
program to abort. If the program runs, but fails to produce correct results, it likely contains 
one or more logic errors. To help identify such errors, it is important that the program be 
executed with carefully selected sample data that allows the correct output to be predicted. 
10. Correct any errors found while running the program. 
When run-time or logic errors occur in a program, they must be corrected. You must 
identify the step where the error occurred and determine the cause. 
Desk-checking is a process that can help locate these types of errors . The term 
desk-checking means the programmer starts reading the program , or a portion of the 
program , and steps through each statement. A sheet of paper is often used in this 

22 
Chapte r 1 
Introduction to Computers and Programming 
process to jot down the current contents of all variables and sketch what the screen 
looks like after each output operation . When a variab le's contents change, or informa -
tion is displayed on the screen, this is noted . By stepping through each statement in this 
manner , many errors can be located and corrected. 
If the error is a result of incorrect logic (such as an improperly stated math formula ), 
you must correct the statement or statements involved in the logic. If the error is due to 
an incomplete understanding of the program requirements, then you must restate the 
program's purpose and modify all affected charts, pseudocode, and source code. The 
program must then be saved, recompiled, relinked, and retested . This means steps 4 
though 10 must be repeated until the program reliably produces satisfactory results. 
11. Validate the results of the program. 
When you believe you have corrected all errors, enter test data to verify that the pro-
gram solves the original problem . 
What Is Software Engineering? 
The field of software engineering encompasses the complete process of crafting com-
puter software. It includes designing, writing, testing, debugging, documenting, modify-
ing, and maintaining complex software development projects . Like traditional engineers, 
software engineers use a number of tools in their craft. Here are a few examples: 
• Program specifications 
• Charts and diagrams of screen output 
• Hierarchy charts 
• Pseudocode 
• Examples of expected input and desired output 
• Special software designed for testing programs 
Most commercial software applications are very large. In many instances one or more 
teams of programmers, not a single individual, develop them. It is important that the 
program requirements be thoroughly analyzed and divided into subtasks that are han-
dled by individual teams or individuals within a team. 
In step 3 of the programming process, you were introduced to the hierarchy chart as a 
tool for top-down design. When the subtasks identified in a top-down design are long 
or complex, they can be developed as modules, or separate components, of a program. 
If the program is very large or complex, a team of software engineers can be assigned 
to work on the individual modules. As the project develops, the modules are coordi -
nated to become a single software application. 
~ 
Checkpoint 
1.25 
What four items should you identify when defining what a program is to do? 
1.26 
What does it mean to "visualize a program running"? What is the value of 
doing this? 
1.27 
What is a hierarchy chart? 
1.28 
What is pseudocode? 
1.29 
What is the difference between high-level pseudocode and detailed pseudocode? 

111111111 
Review Questions and Exercises 
23 
1.30 
Describe what a compiler does with a program's source code. 
1.31 
What is a logic error? 
1.32 
What is a run-time error? 
1.33 
Describe the process of desk-checking. 
1.7 
Tying It All Together: Hi! It's Me 
11111111111 Most programs, as you have learned, have three primary activities: input, processing, 
and output . But it is possible to write a program that has only output. Program 1-2, 
shown below, displays the message: 
Hi! It 's me. 
I'm learning 
t o program! 
Program 1-2 can be found in the Chapter 1 programs folder on the book's companion 
website. Open the program in whatever C++ development environment your class is 
using. Then compile it and run it. Your instructor will show you how to do this. 
Program 1-2 
1 //This 
program prints 
a message wi th your name in i t. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main() 
6 { 
7 
cout <<"H i ! It\'s 
me.\n"; 
8 
cout << "I\'m 
learn i ng to program!\n"; 
9 
return 
O; 
10 } 
Once you have run the program, change the word me on line 7 to your name to personalize 
the message. Then recompile and rerun the program . 
In the next chapter you will learn what the \ ' and \ n do. 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. Computers can do many different jobs because they can be ____ 
_ 
2. The job of the _____ 
is to fetch instructions, carry out the operations com-
manded by the instruct ions, and produce some outcome or resultant information. 
3. Internally, the CPU consists of the _____ 
and the ___ 
_ 
4. A(n) ____ 
is an example of a secondary storage device. 
5. The two general categories of software are _____ 
and ____ 
_ 

24 
Chapte r 1 
Introd uction to Comp uters and Programming 
6. A program is a set of ____ 
_ 
7. Since computers can' t be programmed in natural human language, algorithms 
must be written in a(n) _____ 
language . 
8. ____ 
is the only language computers really process. 
9. 
10. 
____ 
languages are close to the level of humans in terms of readab ility. 
____ 
languages are close to the level of the computer. 
11. A program's ability to run on several different types of computer systems is 
called ___ 
_ 
12. Words that have special meaning in a programming language are called 
_____ 
words. 
13. Words or names defined by the programme r are called ___ 
_ 
14. _____ 
are characters or symbols that perform operations on one or more 
operands . 
15. ____ 
charac ters or symbols mark the beginning or ending of program-
ming statements , or separate items in a list. 
16. The rules that must be followed when constructing a program are called 
17. A(n) _____ 
is a named storage location. 
18. A variable must be _____ 
before it can be used in a program . 
19. The three primary activit ies of a program are ____ 
_ _____ 
, and 
20. _____ 
is information a program gathers from the outside world . 
21. _____ 
is information a program sends to the outside world. 
22. A(n) ____ 
is a diagram that graphically illustrates the Structure of a program. 
23. Both main memory and secondary storage are types of memory. Describe the 
difference between the two. 
24. What is the difference between system software and application software? 
25. What is the difference between a syntax error and a logical error? 
Algorithm Workbench 
26. Available Credit 
Design a hierarchy chart for a program that calculates a customer's available 
credit. The program should carry out the following steps: 
• Display the message "Enter the customer's maximum credit ." 
• Wait for the user to enter the customer's maximum credit. 
• Display the message "Enter the amoun t of credit used by the customer." 
• Wait for the user to enter the customer's credit used. 
• Subtract the used credit from the maximum credit to get the customer's avail-
able credit. 
• Display a message that shows the customer's available credit. 

VideoNote 
Designing the 
Account Balance 
Program 
VideoNote 
Predicting the 
Output of 
Problem 30 
Review Quest ions and Exercises 
25 
27. Acco unt Balance 
Write high-level and detailed pseudocode for a program that calculates the 
current balance in a bank account. The program must ask the user for 
• The starting balance 
• The total dollar amount of deposits made 
• The total dollar amount of withdrawa ls made 
Once the program calculates the current balance, display it on the screen. 
28. Sales Tax 
Write high-level and detailed pseudocode for a program that calculates the tota l 
of a retail sale. The program should ask the user for 
• The retail price of the item being purchased 
• The sales tax rate 
Once these items have been entered, the program should calculate and display the 
sales tax for the purchase and the total of the sale. 
Predict the Output 
Questions 29 - 32 are programs expressed as English statements. What would each 
display on the screen if they were actual programs? 
29. The variable sum starts with the value 0. 
Add 10 to sum. 
Add 15 to sum. 
Add 20 to sum. 
Display the value of sum on the screen. 
30. The variable x starts with the value 0. 
The variable y starts with the value 5. 
Add 1 to x. 
Add 1 toy . 
Add x and y, and store the result in y. 
Display the value in y on the screen. 
31. The variable j starts with the value 10. 
The variable k starts with the value 2. 
The variable m starts with the value 4. 
Store the value of j times k in j . 
Store the value of k times m in m. 
Add j and m, and store the result in k. 
Display the value in k on the screen. 
32. The variable a starts with the value 1. 
The variable b starts with the value 10. 
The variable c starts with the value 100 . 
The variable x starts with the value 0. 
Store the value of c times 3 in x. 
Add the value of b times 6 to the value already in x. 
Add the value of a times 5 to the value already in x. 
Display the value in x on the screen. 

26 
Chapte r 1 
Introduction to Computers and Programming 
Find the Error 
33. The following pseudocode algorithm has an error. It is supposed to use values 
input for a rectangular room's length and width to calculate and display its area. 
Find the error. 
area= 
width x length. 
Display 
"What is the room's 
width?". 
Input 
width. 
Display 
"What is the room's 
length?". 
Input 
length. 
Display 
area. 
Soft Skills 
Before a programmer can design a program he or she must have some basic knowledge 
about the domain, or area, the program will deal with and must understand exactly 
what it is that the client wants the program to do. Otherwise the final program may 
not work correctly or may not meet the client's needs. 
34. Suppose one of your friends, who paints the insides of houses, has asked you to 
develop a program that determines and displays how much paint is needed to 
paint a room if the length and width of the room are input . What information 
are you lacking that you need to write this program? Write at least three ques-
tions that you would need to ask your friend before starting the project . 
Programming 
Challenges 
1 . Candy Bar Sales 
v1c1eoNote 
Using Program 1-1 as an example, write a program that calculates how much a student 
Solving the 
organization earns during its fund-raising candy sale. The program should prompt the 
Ca ndY Bar Sales user to enter the number of candy bars sold and the amount the organization earns for 
Problem 
each bar sold. It should then calculate and display the tota l amount earned. 
2. Baseball Costs 
Using Program 1-1 as an example, write a program that calculates how much a Little 
League baseball team spent last year to purchase new baseballs. The program should 
prompt the user to enter the number of baseballs purchased and the cost of each baseball. 
It should then calculate and display the total amount spent to purchase the baseballs. 
3. Flower Garden 
Write a program that calculates how much a garden center spent to make a flower 
garden display. The program should prompt the user to enter the cost of the soil, the 
flower seeds, and the fence. It should then calculate and display the total amount spent. 

TOPICS 
2.1 
The Parts of a C++ Program 
2.10 
The C++ str i ng Class 
2.2 
The cout Object 
2.11 
The bool Data Type 
2.3 
The #i nclude Directive 
2.12 
Determining the Size of a Data Type 
2.4 
Variables and the Assignment 
2.13 
More on Variable Assignments and 
Statement 
Initialization 
2.5 
Literals 
2.14 
Scope 
2.6 
Identifiers 
2.15 
Arithmetic Operators 
2.7 
Intege r Data Types 
2.16 
Comments 
2.8 
Floating-Point Data Types 
2.17 
Programming Style 
2.9 
The char Data Type 
2.18 
Tying It All Together: Smile! 
The Parts of a C++ Program 
CONCEPT: 
C++ programs have parts and compone nts that serve specific purposes. 
Every C++ program has an anatomy. Unlike human anatomy, the parts of C++ programs 
are not always in the same place . Nevertheless, the parts are there, and your first step in 
learning C++ is to learn what they are . We will begin by looking at Program 2-1. 
Program 2-1 
1 // A s i mple C++ program 
2 #include 
<iostream> 
3 us i ng namespace 
std; 
4 
5 i nt mai n() 
6 { 
7 
cout << "Progra mming is great 
fun!"; 
8 
return 
O; 
9 } 
Program Output 
Programming 
is great 
fun! 
2 7 

28 
Chapter 2 
0 
Introduction to C++ 
Let's examine the program line by line. Here's the first line: 
// 
A simple C++ program 
The I I marks the beginning of a comment . The compi ler ignores everything from 
the double -slash to the end of the line. That means you can type anyth ing you want 
on that line, and the compiler will never complain! Although comments are not 
required, they are very important to programmers . Most programs are much more 
complicated than the example in Program 2-1, and comments help explain what's 
gomg on. 
Line 2 looks like this: 
#include 
<ios t ream> 
When a line begins with a # it indicates it is a preprocessor directive. The preprocessor 
reads your program before it is compiled and only executes those lines beginning with 
a# symbol. Think of the preprocessor as a program that "sets up" your source code for 
the comp iler. 
The #i nclude directive causes the preprocessor to include the contents of another file 
in the program . The word inside the brackets, i ost ream, is the name of the file that is 
to be included . The i ost ream file contains code that allows a C++ program to display 
output on the screen and read input from the keyboard. Because the cout statement 
(on line 7) prints output to the computer screen, we need to include this file. Its 
contents will be placed in the program at the point the #i nclude statement appears. 
The i ost ream file is called a header file, so it should be included at the head, or top, 
of the program . 
Line 3 reads 
usi ng namespace std; 
Programs usually conta in various types of items with unique names . In this chapter 
you will learn to create variables . In Chapter 6 you will learn to create functions . In 
Chapter 7 you will learn to create objects . Var iables, functions, and objects are 
examples of program entities that must have names . C++ uses namespaces to 
organize the names of program entities . The statement 
using namespace 
std; 
declares that the program will be accessing entit ies whose names are part of the 
namespace called std . (Yes, even namespaces have names.) The program needs 
access to the st d namespace because every name created by the ios t ream file is part 
of that namespace . In order for a program to use the entities in i ost ream, it must 
have access to the std namespace . 
NOTE: 
More information on names paces can be found in Appendix J on this 
book's companion website at pearsonhighered .com/gaddis . 

<) 
CD 
<) 
2.1 The Parts of a C++ Program 
29 
Line 5 reads 
i nt mai n() 
This marks the beginning of a function. A function can be thought of as a group of one 
or more programming statements that has a name. The name of this function is main, 
and the set of parentheses that follows the name indicates that it is a function . The 
word i nt stands for "integer." It indicates that the function sends an integer value 
back to the operating system when it is finished executing . 
Although most C++ programs have more than one function , every C++ program must 
have a function called mai n. It is the starting point of the program . If you're ever read-
ing someone else's program and want to find where it starts, just look for the function 
called mai n. 
NOTE: 
C++ is a case-sensitive language. That means it regards uppercase letters 
as being entirely different characters than their lowercase counterparts . In C++, the 
name of the function main must be written in all lowercase letters. C++ doesn't see 
"main" the same as "Main" or "MAIN." 
Line 6 contains a single, solitary character: 
{ 
This is called a left-brace, or an opening brace, and it is associated with the beginning 
of the function main. All the statements that make up a function are enclosed in a set of 
braces. If you look at the third line down from the opening brace, you'll see the closing 
brace. Everything between the two braces is the contents of the function mai n. 
WARNING! Make sure you have a closing brace for every opening brace in your 
program . 
After the opening brace you see the following statement in line 7: 
cout << "Programmi ng i s grea t fun!" ; 
This line displays a message on the screen. You will read more about cout and the<< 
operator later in this chapter. The message "Programming is great fun!" is printed 
without the quotation marks . In programming terms, the group of characters inside the 
quotation marks is called a string literal, a string constant, or simply a string. 
NOTE: This is the only line in the program that causes anything to be printed on 
the screen. The other lines, like #i nc 1 ude <i ost ream> and i nt main (), are necessary 
for the framework of your program , but they do not cause any screen output . 
Remember, a program is a set of instructions for the computer. If something is to be 
displayed on the screen, you must use a programming statement for that purpose. 

30 
Chapter 2 
Table 2 -1 
Character 
II 
# 
< > 
( ) 
{ } 
" " 
Introduction to C++ 
Notice that line 7 ends with a semicolon . Just as a period marks the end of a sentence, 
a semicolon is required to mark the end of a complete statement in C++. But many C++ 
lines, such as comments, preprocessor directives, and the beginning of functions, are 
not complete statements. These do not end with semicolons. Here are some examples 
of when to use, and not use, semicolons. 
II Semicolon examples 
II Thi s is a comment 
# i nclude <iostream> 
II Thi s is a preprocessor 
directive 
i nt mai n() 
II Thi s begins a functi on 
cout << "Hello"; 
II Thi s is a complete st at ement 
As you spend more time working with C++ you will get a feel for where you should 
and should not use semicolons . For now don't worry about it. Just concentrate on 
learning the parts of a program . 
Line 8 reads 
return O; 
This sends the integer value O back to the operating system when the program finishes 
running . The value O usually indicates that a program executed successfully. 
The last line of the program, line 9, contains the closing brace: 
} 
This brace marks the end of the main function. Because mai n is the only function in this 
program, it also marks the end of the program. 
In the sample program you encountered several sets of special characters . Table 2-1 
provides a short summary of how they were used. 
Special Characters 
Nam e 
Double slash 
Pound sign 
Opening and closing 
brackets 
Opening and closing 
parentheses 
Opening and closing 
braces 
Opening and closing 
quotation marks 
Semicolon 
Description 
Marks the beginning of a comment . 
Marks the beginning of a preprocessor directive. 
Encloses a filename when used with the #i nc l ude 
directive. 
Used in naming a function, as in i nt main (). 
Encloses a group of statements, such as the contents 
of a function . 
Encloses a string of characters, such as a message 
that is to be printed on the screen. 
Marks the end of a complete programming 
statement . 

2.2 The cout Object 
31 
~ 
Checkpoint 
2.2 
2.1 The following C++ program will not compile because the lines have been mixed up. 
i nt main() 
} 
// A crazy mixed up program 
#include 
<iostream> 
return 
O; 
cout << "In 1492 Columbus sa i led the ocean blue. "; 
{ 
us i ng namespace std; 
When the lines are properly arranged the program should display the following 
on the screen: 
In 1492 Columbus sa ile d t he ocea n blue. 
Rearrange the lines in the correct order. Test the program by entering it on the 
computer, compiling it, and running it. 
2.2 
On paper, write a program that will display your name on the screen . Use 
Program 2-1 as your guide. Place a comment with today's date at the top of the 
program . Test your program by entering, compiling, and running it. 
The cout Object 
CONCEPT: 
cout is used to display information on the computer's screen. 
In this section you will learn to write programs that produce output on the screen. The 
simplest type of screen output that a program can display is console output, which is 
merely plain text. The word console is an old computer term. It comes from the days 
when a computer operator interacted with the system by typing on a termina l. The 
terminal, which consisted of a simple screen and keyboard, was known as the console. 
On modern compute rs, running graphica l operating systems such as Windows or 
Mac OS, console output is usually displayed in a window such as the one shown in 
Figure 2-1. C++ provides an object named cout that is used to produce console 
outp ut. (You can think of the word cout as meaning console output.) 
Figure 2-1 
A Console Window 

32 
Chapte r 2 
a 
VideoNot e 
Using cout 
to Display 
Output 
Introduction to C++ 
cout is classified as a stream object, which means it works with streams of data . To 
print a message on the screen, you send a stream of characters to cout . Let's look at 
line 7 from Progam 2-1: 
cout << "Programmi ng i s grea t fu n !"; 
The << operator is used to send the string "Programming is great fun!" to cout . When 
the << symbol is used this way, it is called the stream -insertion operator . The item 
immediately to the right of the operator is inserted into the output stream that is sent 
to cout to be displayed on the screen. 
<) NOTE : The stream insertion operator is always written as two less-than signs 
with no space between them. Because you are using it to send a stream of data to the 
cout object, you can think of the stream insertion operator as an arrow that must 
point toward cout, as shown here. 
cout << "Hello"; 
cout 
+-
"Hello"; 
Program 2-2 shows another way to write the same program . 
Program 2-2 
1 // A simple 
C++ program 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main () 
6 { 
7 
cout << "Programmi ng i s"<< 
"great 
fu n !"; 
8 
return 
O; 
9 } 
Program Output 
Prog rammi ng i s grea t fun! 
As you can see, the stream-insertion operator can be used to send more than one item 
to cout . Program 2-3 shows yet another way to accomplish the same thing . 
Program 2-3 
1 II A simple 
C++ program 
2 #include 
<iostream> 
3 using names pace std; 
4 
5 int main () 
6 { 
7 
cout << "Programmi ng i s ... 
' 
8 
cout << "grea t fu n !"; 
9 
return 
O; 
10 } 
The output of this program is identical to Programs 2-1 and 2-2. 

2.2 The cout Object 
33 
An important concept to understand about Program 2-3 is that although the output is 
broken into two programming statements, this program will still display the message 
on a single line. Unless you specify otherwise, the information you send to cout is 
displayed in a continuous stream . Sometimes this can produce less-than -desirable 
results. Program 2-4 illustrates this. 
Program 2-4 
1 // An unruly printing 
program 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
cout << "The following 
items were top sellers"; 
8 
cout << "during 
the month of June:"; 
9 
cout << "Computer games"; 
10 
cout << "Coffee"; 
11 
cout << "Aspirin"; 
12 
return 
O; 
13 } 
Program Output 
The following 
items were top sellersduring 
the month of June:Computer 
gamesCoffeeAspirin 
The layout of the actual output looks nothing like the arrangement of the strings in the 
source code. First, notice there is no space displayed between the words "sellers" and 
"during," or between "June:" and "Compute r." cout displays messages exactly as they 
are sent. If spaces are to be displayed, they must appear in the strings. 
Second, even though the output is broken into five lines in the source code, it comes out 
as one long line of output. Because the output is too long to fit on one line of the screen, 
it wraps around to a second line when displayed. The reason the output comes out as 
one long line is that cout does not start a new line unless told to do so. There are two 
ways to instruct cout to start a new line. The first is to send cout a stream manipulat or 
called endl (pronounced "end-line" or "end-L "). Program 2-5 does this. 
Program 2-5 
1 // A well-adjusted 
print i ng program 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
cout << "The following 
items were top sellers" 
<< endl; 
8 
cout << "during 
the month of June:"<< 
endl; 
9 
cout << "Computer games"<< 
endl ; 
10 
11 
12 
13 } 
cout <<"Coffee"<< 
endl; 
cout <<"Aspirin"<< 
endl; 
return 
O; 
(program continues) 

34 
Chapte r 2 
Introduction to C++ 
Program 2-5 
(continued) 
Program Output 
The following 
items were top sellers 
during the month of June: 
Computer games 
Coffee 
Aspirin 
0 
NOTE: The last character in end l is the lowercase letter L, not the number one. 
Every time cout encounters an endl stream manipulator it advances the output to the 
beginning of the next line for subsequent printing . The manipulator can be inserted 
anywhere in the stream of characte rs sent to cout , as long as it is outside the doub le 
quotes . Notice that an endl is also used at the end of the last line of output . 
Th e second way to cause subsequent output to begin on a new line is to insert a \n 
inside a string that is being output. Program 2-6 does this. 
Program 2-6 
1 // Another well-adjusted 
printing 
program 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
cout << "The following 
items were top sellers\n"; 
8 
cout << "during 
the month of June :\n"; 
9 
cout << "Computer games\nCoffee" ; 
10 
cout << "\nAspirin\n"; 
11 
return 
O; 
12 } 
Program Output 
The following 
items were top sellers 
during the month of June: 
Computer games 
Coffee 
Aspirin 
\ n is an example of an escape sequence. Escape sequences are written as a backslash character 
( \) followed by a control character and are used to control the way output is displayed. There 
are many escape sequences in C++. The newline escape sequence (\n) is just one of them. 
When cout encounters \ n in a string, it doesn't print it on the screen. Instead it 
interprets it as a special command to advance the outp ut cursor to the next line. You 
have probably noticed that insertin g the escape sequence requires less typing than 
inserting endl. That's why some programmers prefer it. 

2.2 The cout Object 
35 
Escape sequences give you the ab ilit y to exercise greater control over the way 
information is output by your program . Table 2-2 lists a few of them. 
Table 2 -2 Common Escape Sequences 
Escape 
Sequence 
\n 
\t 
\a 
\b 
\r 
\ \ 
\ ' 
\" 
Name 
Newline 
Horizontal tab 
Alarm 
Backspace 
Return 
Backslash 
Single quote 
Double quote 
Description 
Causes the cursor to go to the next line for subsequent printing. 
Causes the cursor to skip over to the next tab stop. 
Causes the computer to beep. 
Causes the cursor to back up (i.e., move left) one position . 
Causes the cursor to go to the beginning of the current line, not 
the next line. 
Causes a backslash to be printed . 
Causes a single quotation mark to be printed . 
Causes a double quotation mark to be printed. 
A common mistake made by beginning C++ students is to use a forward slash (/) 
instead of a back slash (\) when trying to write an escape sequence. This will not work. 
For example, look at the following line of code. 
cout << "Four scorelnAnd sevenlnYears 
ago . In"; 
II Error! 
Because the programmer accidentally wrote In instead of \n, cout will simply display 
the In characters on the screen, rather than starting a new line of outp ut. This code will 
create the following output: 
Four score lnAnd sevenlnYears 
ago.I n 
Another common mistake is to forget to put the \ n inside quotation marks . For 
example, the following code will not compile. 
cout <<"Good"<< 
\n; 
cout <<"Morning"<< 
\n; 
II Error! 
II This code will not compile . 
We can correct the code by placing the \n sequences inside the string literals, as shown here: 
cout << "Good\n"; 
cout << "Morning\ n"; 
II This will work. 
It is important not to confuse the backslash (\) with the forward slash (/). An escape 
sequence must start with a backslash, be placed inside quotation marks, and have no 
spaces between the backslash and the control characte r. 
When you type an escape sequence in a string, you type two characters (a backslash 
followed by anothe r character) . However, an escape sequence is stored in memory as a 
single character. For example, consider the following string literal: 
"One\nTwo\nThree\ n" 

36 
Chapte r 2 
Figure 2-2 
2.3 
CD 
Introduction to C++ 
The diagram in Figure 2-2 breaks this string into its individual characters. Notice how 
each \n escape sequence is considered just one character. 
I O I n I e I \n I T I w I O I \n I T I h I r I e I e I \n I 
The #include 
Directive 
CONCEPT : The #in clud e directive causes the contents of another file to be inserted 
into the program. 
Now is a good time to expand our discussion of the #i nclude directive. The following 
line has appeared near the top of every example program . 
#i nclude 
<ios t ream> 
As previously mentioned , the iostream 
header file must be included in any program 
that uses the cout object. This is because cout is not part of the "core" of the C++ 
language. Specifically, it is part of the input- output stream library. The i ostr
eam 
header file contains information describing iostream 
objects. Without it, the compiler 
will not know how to properly compile a program that uses cout . 
Preprocessor directives are not C++ statements . They are commands to the preprocessor, 
which runs prior to the compiler (hence the name "preprocessor") . The preprocessor's 
job is to set programs up in a way that makes life easier for the programmer. 
For example, any program that uses the cou t object must contain the extensive setup 
information found in the i os t ream file. The programmer could type all this information 
into the program, but it would be very time consuming . An alternative would be to use 
an editor to "cut and paste" it into the program, but that would still be inefficient. The 
solution is to let the preprocessor insert the contents of iostr
eam automatically . 
WARNING ! Do not use semicolons at the end of preprocessor directives. Because pre-
processor directives are not C++ statements, they do not require them. In fact, in many 
cases an error will result if a preprocessor directive is terminated with a semicolon. 
An #includ
e directive must contain the name of the file you wish to include in the 
program. The preprocessor inserts the entire contents of this file into the program at 
the point it encounters the #i nclude directive. The compiler doesn't actually see the 
#i nclud e directive. Instead it sees the code that was inserted by the preprocessor, just 
as if the programmer had typed it there. 
The code contained in header files is C++ code. Typically, it describes complex objects 
like cout . Later you will learn to create your own header files. 

2.4 Variables and the Assignment Statement 
37 
~ 
Checkpoint 
2.4 
2.3 Th e following cout statement contains errors . 
cout << "red /n" 
<< "b lue \ n" << "yellow" 
\n << "gree n"; 
Correct it so that it will display a list of colors, with one item per line. 
2.4 
What outp ut will the following lines of code display on the screen? 
cout << "The works of Wolfgang\n i nclude the following"; 
cout << "\nThe Turkish March" << endl; 
cout << "and Symphony No. 40 ". 
' 
cout << "in G mi nor." << endl ; 
2.5 
On paper, write a program that will display your name on the first line, 
your street address on the second line, your city, state, and ZIP code on the third 
line, and your telephone number on the fourth line. Test your program by 
entering, compiling, and running it. 
Variables and the Assignment Statement 
CONCEPT: 
Variab les represent stor age locations in the comput er's memory. Values 
can be stored in them by using an assignment statement. 
The concept of a variable in computer programming is somewhat different from the 
concept of a variable in mathematics. In programming, as you learned in Chapter 1, a 
variable is a named storage location for holding data . Variables allow you to store and 
work with data in the computer's memory . They provide an "interface" to RAM. A 
value can be stored in a variable by using an assignment statement. Program 2-7 has a 
variable and two assignment statements . 
Program 2-7 
1 // Thi s program has a variable. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
int number; 
8 
9 
10 
11 
12 
13 
14 
15 
16 } 
number= 5 ; 
cout << "The value of number is"<< 
number<< 
endl; 
number= 7 ; 
cout << "Now t he value of number is"<< 
number<< endl; 
return 
O; 
(program continues) 

38 
Chapter 2 
Introduction to C++ 
Program 2-7 
(continued) 
Program Output 
The value of number is 5 
Now t he value of number is 7 
0 
0 
Let's look more closely at this program . Start by looking at line 7. 
i nt number ; 
This is called a variable definition . It tells the compiler the variable's name and the type 
of data it will hold. Not ice that the definition gives the data type first, then the name of 
the variab le, and ends with a semicolon. This variable's name is number . The word i nt 
stands for integer, so number may only be used to hold integer numbers. 
NOTE: You must have a definition for every variable you use in a program . In C++, a 
variable definition can appear at any point in the program as long as it occurs before 
the variable is ever used. Later you will learn the best places to define variables. 
Now look at line 9. 
number= 5; 
This is an assignment statement, and the = sign is called the assignment operator. This 
operator copies the value on its right (5) into the variable named on its left (number ). 
This line does not print anything on the computer's screen. It runs silently behind the 
scenes, storing a value in RAM . After this line executes, number will be set to 5. 
NOTE: 
The item on the left-hand side of an assignment statement must be a 
variable. It would be incorrect to say 5 = number; 
Now look at line 10. 
cout << "The value of number is"<< 
number<< 
endl; 
Notice that the first item sent to cout has quotat ion marks around it. This lets C++ 
know that it is a string and should be displayed exactly as written . The second item 
sent to cout is the name of the variable. 
When you send a variable name to cout , it prints the variab le's contents, so the 
following line is displayed . 
The value of number is 5 
Recall from Chapter 1 that variables are called variab les because their values can 
change . The assignment statement on line 12 replaces the previous value stored in 
number with a 7. 
number= 7; 
Therefore, the final cout statement on line 13 
cout << "Now t he value of number is"<< 
number << endl; 
causes the following output to print . 
Now the value of number is 7 

2.5 Literals 
39 
2.5 
Literals 
CONCEPT: 
A literal is a piece of data that is written directly into a program's code. 
A literal is a piece of data written directly into a program's code. One of the most 
common uses of literals is to assign a value to a variab le. In Program 2-7 the following 
statement assigned the literal value 5 to the variable number. 
number= 
5; 
Another common use of literals is to display something on the screen. In Program 2-7 
a string literal was sent to cout to display the words 
The value of number is 
Literals can be characters, strings, or numeric values . Program 2-8 uses a variable and 
several literals . 
Program 2-8 
1 // Thi s program uses integer 
literals
, string 
literals
, and a var i able . 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
int apples; 
8 
9 
apples= 
20 ; 
10 
cout << "On Sunday we sold"<< 
apples<<" 
bushels 
of apples. 
\ n"; 
11 
12 
apples= 
15; 
13 
cout << "On Monday we sold"<< 
apples<<" 
bushels 
of apples. 
\ n"; 
14 
return 
O; 
15 } 
Program Output 
On Sunday we sold 20 bushels 
of apples. 
On Monday we sold 15 bushels 
of apples. 
Of course, the variable is apples. Table 2-3 lists the literals found in the program. 
Table 2 -3 Program 2-8 Literals 
Integer Literals 
20 
15 
0 
String Literals 
"On Sunday we sold" 
"On Monday we sold" 
"bushels 
of apples. 
\n" 

40 
Chapte r 2 
Introduction to C++ 
Sometimes a Number Isn't a Number 
As shown in Programs 2-7 and 2-8, placing quotation marks around one or more 
words makes it a string literal. When string literals are sent to cout , they are printed 
exactly as they appear inside the quotation marks . You've probab ly noticed by now 
that the endl stream manipulator is written with no quotation marks around it. If we 
put the following line in a program , it would print out the word endl , rather than 
cause subsequent output to begin on a new line. 
cout << "endl"; 
/ / Wrong! 
In fact, placing double quotat ion marks around anything that is not intended to be a 
string will create an error of some type. 
For example, on line 9 of Program 2-8 the integer literal 20 was used to assign the value 
20 to the variable apples . It would have been incorrect to write the statement this way: 
apples= 
"20"; 
/ / Wrong! 
With quotation marks around it, 20 is no longer an integer. It is a string. Because 
apples was defined to be an integer variable, you can only store integers in it. The 
integer 20 and the string "20" are not the same thing . 
The fact that numbers can be represented as strings frequently confuses peop le who 
are new to programming . Just remember that strings are intended for humans to 
read . They are to be printed on computer screens or paper. Numbers, however , are 
intended primari ly for mathematical 
operations . You cannot perform math on 
strings, and you cannot display numbers on the screen without first converting them 
to strings . Fortunately , cout handles this conversion automatically when you send a 
number to it. 
~ 
Checkpoint 
2.6 
Which of the following are legal C++ assignment statements? 
a . a = 7· ' 
b. 7 = a· ' 
C . 7 = 7· ' 
2. 7 List all the variables and literals that appear below. 
i nt main() 
{ 
} 
i nt li t tle; 
i nt big; 
l i t tle= 
2; 
bi g= 2000; 
cout << "The l it tle 
number i s"<< 
l i ttle<< 
endl; 
cout << "The bi g number is"<< 
big<< 
endl; 
re t urn O; 
2.8 
When the above main function runs, what will display on the screen? 

2.6 
Table 2 -4 
alignas 
alignof 
and 
and_eq 
asm 
auto 
bitand 
bitor 
bool 
break 
case 
catch 
char 
char16_t 
char32_t 
class 
compl 
2.6 Identifiers 
41 
2.9 When the following main function runs, what will display on the screen? 
i nt main() 
{ 
} 
int number; 
number= 
712 ; 
cout << "The value is"<< 
"number"<< 
endl ; 
return 
O; 
Identifiers 
CONCEPT: 
A variable name should indicate what the variable is used for. 
An identifier is a programmer -defined name that represents some element of a program. 
Variable names are examples of identifiers. You may choose your own variable names 
in C++, as long as you do not use any of the C++ key words. The key words make up 
the "core" of the language and have specific purposes. Table 2-4 shows a complete list 
of the C++ key words. Note that they are all lowercase. 
The C++ Key Words 
const 
for 
private 
throw 
constexpr 
friend 
protected 
true 
const _cast 
goto 
public 
try 
continue 
if 
register 
typedef 
decltype 
inl i ne 
reinterpret_cast 
typeid 
default 
int 
return 
typename 
delete 
long 
short 
union 
do 
mutable 
s i gned 
unsigned 
double 
namespace 
s iz eof 
using 
dynamic_c ast 
new 
static 
virtual 
else 
noexcept 
static
_assert 
void 
enum 
not 
static
_cast 
volatile 
explicit 
not _eq 
struct 
wchar_t 
export 
nullptr 
switch 
while 
extern 
operator 
template 
xor 
false 
or 
this 
xor_eq 
float 
or _eq 
thread_local 
You should always choose names for your variables that indicate what the variables 
are used for. You may be tempted to give variables names such as: 
i nt X; 
However, the rather nondescript name x gives no clue as to the variable's purpose . 
Here is a better example. 
i nt it emsOrdered; 

42 
Chapte r 2 
Introduction 
to C++ 
The name i temsOrdered 
gives anyone reading the program an idea of the variable's 
use. This way of coding helps produce self-documenting programs, which means you 
can get an understanding of what the program is doing just by reading its code. Because 
real-world programs usually have thousands of lines, it is important that they be as 
self-documenting as possible. 
You probably have noticed the mixture of upp ercase and lowercase letters in the 
variable name i temsOrdered
. Although all of C++'s key words must be written in 
lowercase, you may use uppercase letters in variab le names. 
The reason the O in i tem sOrdered is capitalized is to improve readability . Normally 
"items ordered" is two words . However, you cannot have spaces in a variable name, so 
the two words must be combined into one. When "items" and "ordered" are stuck 
together you get a variable definition like this: 
i nt itemso rdered; 
Capitalization of the first letter of the second word and any succeeding words makes 
variable names like i temsOrdered 
easier to read and is the convention we use for 
naming variables in this book . However, this style of coding is not required. You are 
free to use all lowercase letters, all uppercase letters, or any combination of both. In 
fact, some programmers use the underscore character to separate words in a variable 
name, as in the following. 
i nt items_ ordered; 
Legal Identifiers 
Regardless of which style you adopt, be consistent and make your variable names as sensible 
as possible. Here are some specific rules that must be followed with all C++ identifiers. 
• The first character must be one of the letters a through z, A through Z, or an 
underscore characte r (_). 
• After the first character you may use the letters a through z or A through Z, the 
digits O through 9, or underscores . 
• Uppercase and lowercase characte rs are distinct. This means ItemsOrdered 
is not 
the same as i tem sordered
. 
Table 2-5 lists variab le names and indicates whether each is legal or illegal in C++. 
Table 2 -5 Some C++ Variable Names 
Variable Name 
dayOfWeek 
3dGraph 
_emplo yee_n um 
June1997 
Mixture#3 
Legal or illegal 
Legal. 
Illegal. Variable names cannot begin with a digit . 
Legal. 
Legal. 
Illegal. Variable names may only use letters, digits, and underscores. 

2.7 
2.7 Integer Data Types 
43 
Integer Data Types 
CONCEPT: 
There are many different types of data. Variables are classified according 
to their data type, which determines the kind of information that may 
be stored in them. Integer variables can only hold whole numbers. 
Computer programs collect pieces of data from the real world and manipulate them in 
various ways. There are many different types of data. In the realm of numeric infor-
mation, for example, there are whole numbers and fractional numbers. There are 
negative numbers and positive numbers. Then there is textua l informat ion. Names 
and addresses, for instance, are stored as strings, which are made up of characters . 
When you write a program you must determine what types of information it will be 
likely to encounter. 
If you are writing a program to calculate the number of miles to a distant star, you'll 
need variables that can hold very large numbers. If you are designing software to record 
microscopic dimensions, you'll need to store very small and precise numbers. 
Additionally, if you are writing a program that must perform thousands of intensive 
calculat ions, you'll want data stored in variables that can be processed quickly. The 
data type of a variable determines all of these factors . 
Although C++ offers many data types, in the very broadest sense there are only two: 
numeric and character. Numeric data types are broken into two additional categories: 
integer and floating -point, as shown in Figure 2-3. 
Figure 2-3 
Basic C++ Data Types 
c+ + Data Types 
~ 
numeric 
character 
~ 
integer 
floating·point 
Integers are whole numbers like -2 , 19, and 24. Floating-point numbers have a decimal 
point like -2. 35, 19.0, and 0.024. Additionally, the integer and floating-point data 
types are broken into even more classifications. 
Your primary considerations for selecting the best data type for a numeric variable are 
the following: 
• whether the variable needs to hold integers or floating-point values, 
• the largest and smallest numbers that the variable needs to be able to store, 
• whether the variab le needs to hold signed (both positive and negative) or only 
unsigned (just zero and positive) numbers, and 
• the number of decimal places of precision needed for values stored in the variable. 

44 
Chapter 2 
0 
0 
Introduction to C++ 
Let's begin by looking at integer data types. C++ has eight different data types for storing 
integers. They differ by how many bytes of memory they have for storing data and what 
range of values they can hold. The number of bytes a data type can hold is called its size. 
Typically, the larger the size a data type is, the greater the range of values it can hold. 
Table 2-6 Integer Data Types 
Data Type 
Typical Size 
Typical Range 
short i nt 
2 bytes 
- 32,768 to +32,767 
unsigned shor t int 
2 bytes 
0 to +65,535 
int 
4 bytes 
- 2,147,483,648 to +2,147,483,647 
unsigned i nt 
4 bytes 
0 to 4,294,967,295 
long i nt 
4 bytes 
- 2,147,483,648 to +2,147,483,647 
unsigned long int 
4 bytes 
0 to 4,294,967,295 
long long i nt 
8 bytes 
- 9,223,372,036,854,775,808 to 
9,223,372,036,854,775,807 
unsigned long long i nt 
8 bytes 
0 to +8,446,744,073,709,551,615 
NOTE: 
The long long in t and the unsi gned long long in t data types were 
introduced in C++ 11. 
Recall from Chapter 1 that a byte is made up of 8 bits. So a data type that stores data 
in two bytes of memory can hold 16 bits of information . This means it can store 2 16 bit 
patterns, which is 65,536 different combinations of zeros and ones. A data type that 
uses 4 bytes of memory has 32 bits, so it can hold 232 different bit patterns, which is 
4,294,967,296 different combinations . What these different combinations are used for 
depends on the data type. For example, the unsigned shor t data type, which is for 
storing non-negative integers such as ages or weights, uses its 16 bits to represent the 
values O through +65,535 . The shor t data type, in contrast, stores both positive and 
negative numbers, so it uses its 16 bits to represent the values from -32,768 to +32,767. 
Notice that in Table 2-6 the i nt and long data types have the same sizes and ranges, 
and the unsigned i nt data type has the same size and range as the unsi gned lo ng data 
type. This is not always true because the size of integers is dependent on the type of 
system you are using. Here are the only guarantees: 
• Integers are at least as big as short integers. 
• Long integers are at least as big as integers. 
• Unsigned short integers are the same size as short integers. 
• Unsigned integers are the same size as integers. 
• Unsigned long integers are the same size as long integers. 
• The lo ng long int and the unsigned long long i nt data types are guaranteed 
to be at least 8 bytes ( 64 bits) in size. 
Later in this chapter you will learn to use the si zeof operator to determine how large 
all the data types are on your computer. 

2.7 Integer Data Types 
45 
Each of the data types in Tabl e 2-6, except int, can be written in an abbreviated form 
by omittin g the word int. Table 2-7 contrasts integer variable definitions using the full 
data type name with those using the shortened form. Because they simplify definition 
statements, programmers commonly use the abbreviated data type names. 
Table 2 -7 Sample Intege r Variable Definitions 
Definitions Using Full Data Type Names 
short 
int month ; 
unsi gned short 
int amount; 
int days; 
unsi gned int speed; 
long i nt deficit; 
unsi gned long i nt i nsects; 
long long int grandTotal; 
unsi gned long long int population; 
Definitions Using Abbreviated Data Type Names 
short month ; 
unsigned short amount; 
int days; 
/ / Thi s has no short form 
unsi gned speed; 
long deficit ; 
unsi gned long i nsects; 
long long grandTotal; 
unsi gned long long population; 
Program 2-9 uses integer, unsigned integer, and long integer variables. 
Program 2-9 
1 // Thi s program has variables 
of several 
of the i nteger 
types. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
int checking; 
8 
unsigned 
int miles ; 
9 
long days; 
10 
11 
checking= 
-20; 
12 
miles
= 4276; 
13 
days= 
192000; 
14 
15 
cout << "We have made a long journey 
of"<< 
miles<<" 
miles."; 
16 
cout << "\nOur checking account balance 
is"<< 
check i ng; 
17 
cout << "\nAbout "<<days<<" 
days ago Columbus"; 
18 
cout << "stood on this 
spot.\n"; 
19 
return 
O; 
20 } 
Program Output 
We have made a long journey 
of 4276 miles. 
Our checking account balance 
is -20 
About 192000 days ago Columbus stood on this 
spot. 
Notice in Program 2-9 that the variable days is assigned 192000 rather than 192,000 
because C++ does not allow commas inside numeric literals. 

46 
Chapte r 2 
Introduction to C++ 
In most programs you will need many variables . If a program uses more than one 
variable of the same data type, for example the two integers leng th and width , they 
can be defined separately, like this: 
i nt length; 
i nt width ; 
or, alternatively, both variable definitions can be placed in a single statement, like this: 
i nt length , width; 
Many instructors , however , prefer that each variable be placed on its own line when 
more than one is defined in the same statement, like this: 
i nt length , 
width ; 
Whether you place multiple variab les on the same line or each variable on its own line, 
when you define several variables of the same type in a single statement, simply separate 
their names with commas. A semicolon is used at the end of the entire definition, as is 
illustrated in Program 2-10. This program also shows how it is possib le to give an initial 
value to a variable at the time it is defined. 
Program 2-10 
1 // Thi s program defines 
three var i ables 
i n the same st at ement. 
2 II They are gi ven i ni t i al values at the tim e they are defined. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 
7 
8 
9 
10 
11 
int 
{ 
main () 
int floors 
= 
15 , 
rooms 
= 300 , 
suit es = 30; 
12 
cout << "The Grande Hot el has"<< 
floors<<" 
floors\n"; 
13 
cout <<"w it h"<< 
rooms<<" 
rooms and"<< 
sui tes; 
14 
cout <<" 
sui t es.\n"; 
15 
return 
O; 
16 } 
Program Output 
The Grande Hot el has 15 floo r s 
wit h 300 rooms and 30 suit es. 
Integer and Long Integer Literals 
Look at the following statement from Program 2-10: 
i nt floors 
= 15, 
rooms= 
300 , 
suites= 
30; 
This statement contains three integer literals . In C++, integer literals are normally 
stored in memory just as an in t . 

0 
0 
0 
2.7 Integer Data Types 
47 
One of the pleasing characteristics of the C++ language is that it allows you to control 
almost every aspect of your program . If you need to change the way something is stored 
in memory, tools are provided to do that. For example, what if you are in a situation 
where you have an integer literal that you need to store in memory as a long integer? C++ 
allows you to do this by placing the letter L at the end of the number. Here is an example: 
long amount; 
amount= 
32L; 
The first statement defines a long variab le named amount. The second statement assigns 
the literal value 32 to the amount variable. Because the literal is written as 32L, it makes 
it a long integer literal. This means the assigned value is treated as a long . 
Likewise, if you want an integer literal to be treated as a long long i nt, you can 
append LL at the end of the number. Here is an example: 
long long amount; 
amount = 32LL; 
NOTE: Although C++ allows you to use either an uppercase or lowercase L, the 
lowercase I looks too much like the number 1, so when designating a long integer 
literal or a long long integer literal you should always use the uppercase L. 
Hexadecimal and Octal Literals (enrichment) 
Programmers commonly express values in numbering systems other than decimal (or 
base 10). Hexadecimal (base 16) and octal (base 8) are popular because they make 
certain programming tasks more convenient than decimal numbers do. 
By default, C++ assumes that all integer literals are expressed in decimal. If you want to 
indicate that a literal value is a hexadecimal number, you must place Ox in front of it. (This 
is zero-x, not oh-x.) Here is how the hexadecimal number F4 would be expressed in C++: 
OxF4 
Octa l numbers must be preceded by a O (zero, not oh). For examp le, the octal 31 
would be written 
031 
NOTE: 
You will not be writing programs for some time that require using 
hexadecimal or octal numbers, but you should be able to recognize one if you see it 
in a piece of code. 
~ 
Checkpoint 
2.10 
Which of the following are illegal C++ variable names, and why? 
X 
99bottles 
july97 
t heSalesFigureForFiscalYear98 
r&d 
grade _repor t 

48 
Chapter 2 
2.8 
Introduction to C++ 
2.11 
Is the variable name Sales the same as sales? Why or why not? 
2.12 
Refer to the data types listed in Table 2-6 for these questions . 
A) If a variable needs to hold numbers in the range 32 to 6,000, what data 
type would be best? 
B) If a variable needs to hold numbers in the range -40 ,000 to +40,000, what 
data type would be best? 
C) 20 and 20L are both integer literals. Does one use more memory than the 
other, and if so which one, or do they both use the same number of bytes? 
2.13 
Which integer data types can only hold non-negative values? 
2.14 
How would you comb ine the following variable definition and assignment 
statement into a single statement? 
i nt apples; 
apples= 
20 ; 
2.15 How would you combine the following variable definitions into a single statement? 
i nt xCoord = 2 ; 
i nt yCoord = -4 ; 
i nt zCoord = 6 ; 
Floating-Point 
Data Types 
CONCEPT: 
Floating-point data types are used to define variables that can hold real 
numb ers. 
Whole numbers are not adequate for many jobs. If you are writing a program that 
works with dollar amounts or precise measurements, you need a data type that allows 
fractional values. In programming terms, these are called floating -point numbers . 
Internally, floating-point numbers are stored in a manner similar to scientific notation . 
Take the number 47,281.97 . In scientific notation this number is 4.728197 x 104 • 
(104 is equal to 10,000, and 4.728197 x 10,000 is 47,281.97.) The first part of the 
number , 4.728197, is called the mantissa. The mantissa is multiplied by a power of 10. 
Computers typically use E notatio n to represent floating-point values. In E notation, 
the number 47,281.97 would be 4.728197£4 . The part of the number before the Eis 
the mantissa, and the part after the Eis the power of 10. When a floating-point number 
is stored in memory, it is stored as the mantissa and the power of 10. 
Table 2-8 shows other numbers represented in scientific and E notation. 
Table 2 -8 Floating -Point Representations 
Decimal Notation 
Scientific Notation 
E Notation 
247.91 
2.4791 X 102 
2.4791£2 
0.00072 
7.2 X 10-4 
7.2£-4 
2,900,000 
2.9 X 106 
2.9E6 

2.8 Floating-Point Data Types 
49 
In C++ three data types can represent floating-point numbers: 
float 
double 
long double 
The fl oat data type is considered single precision. The double data type is usually 
twice as big as fl oat, so it is considered double precision. As you've probably guessed, 
the long double is intended to be larger than the double. The exact sizes of these data 
types is dependent on the computer you are using. The only guarantees are 
• A double is at least as big as a float. 
• A long double is at least as big as a double. 
Table 2-9 shows the sizes and ranges of floating-point data types usually found on PCs. 
Table 2 -9 Floating -Point Data Types on PCs 
Data Type 
Key Word 
Size 
Range 
Significant 
Digits 
Single precision 
float 
4 bytes 
Numbers between ±3.4E-38 and 
7 
±3.4E38 
Double precision 
double 
8 bytes 
Numbers between ±l.7E-308 and 
16 
±1.7£308 
Long double precision 
long double 
8 bytes" 
Numbers between ±l.7E-308 and 
16 
±1.7£308 
•Some compilers use more than 8 bytes for a long double. This allows a greater range. 
You will notice there are no unsigned floating-point data types. On all machines, 
variables of the fl oat, double, and long double data type can store both positive and 
negative numbers. Program 2-11 uses floating-point data types. 
Program 2-11 
1 // Thi s program uses two floating-point 
data types, 
float 
and double. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main() 
6 { 
7 
8 
9 
float 
distance
= 1 .496E8; 
double mass = 1.989E3D; 
// in kilometers 
// in kilograms 
10 
cout << "The Sun i s"<< 
distance<<" 
ki lomete rs away.\n"; 
11 
cout << "The Sun\'s 
mass is"<< 
mass<<" 
kilogra
ms. \n"; 
12 
retu rn O; 
13 } 
Program Output 
The Sun is 1.496e+OD8 kilometers 
away. 
The Sun's mass is 1.989e+D30 kilograms. 

50 
Chapter 2 
<) 
Introduction to C++ 
Floating-Point 
Literals 
Float ing-point literals, sometimes referred to as floating -point constants, may be 
expressed in a variety of ways. As shown in Program 2-11, E notat ion is one method. 
When you are writing numbers that are extremely large or extreme ly small, this will 
probably be the easiest way . E notat ion numbers may be expressed with an upper -
case E or a lowercase e. Not ice in the source code the literals were written as l.496E8 
and l.989E30, but the program printed them as 1.496e+008 and l.989e+030. The 
two sets of numbers are equivalent . The plus sign in front of the exponent is also 
optiona l. 
You can also express floating -point literals in decimal notat ion. The literal 1.496E8 
could have been written as 
149600000 .0 
Obviously the E notat ion is more convenient for lengthy numbers; but for numbers like 
47.39, decimal notat ion is preferable to 4.739El. 
All of the following floating -point literals are equivalent: 
1. 496E8 
1. 496e8 
1. 496E+8 
1. 496e+8 
149600000 .0 
Floating -point literals are normally stored in memory as doubles . If you need one to be 
stored as a fl oat, you can append the letter F or f to the end of it. For example, the 
following literals would be stored as fl oat numbers: 
1 . 2F 
45.907f 
NOTE: 
Because floating -point literals are normally stored in memory as a double, 
some compilers issue a warning message when you assign a floating -point literal to 
a fl oat variable . For examp le, if num is a fl oat , the following statement might 
cause the comp iler to generate a warning message: 
num = 14.725; 
You can suppress the error message by appending the f suffix to the floating-point 
literal, as shown here: 
num = 14.725f; 
If you want to force a value to be stored as a long double, append an L to it, as shown here: 
1034.56L 
The compiler won't confuse this with a long integer because of the decimal point. A lower-
case letter l can also be used to define a floating-point literal to be a long double, but an 
uppercase L is preferable, as the lowercase letter l is easily confused with the digit 1. 

CD 
2.8 Floating-Point Data Types 
51 
Assigning Floating-Point Values to Integer Variables 
When a floating-point value is assigned to an integer variable, the fractional part of 
the value (the part after the decimal point ) is discarded. This occurs because an integer 
variable cannot hold any value containing decimals . For example, look at the 
following code. 
int number ; 
number= 
7.8; 
// Assigns 
7 to number 
This code attempts to assign the floating-point value 7.8 to the integer variable number. 
Because this is not possible, the value 7 is assigned to number, and the fractional part is 
discarded. When part of a value is discarded in this manner, the value is said to be 
truncated. 
Assigning a floating-point variable to an integer variable has the same effect. For 
example, look at the following code. 
i nt i ntVar; 
double doubleVar = 7 .8; 
i ntVar = doubleVar; 
// Assigns 
7 to i ntVar 
// doubleVar 
remains 7 .8 
WARNING! 
Floating-point variables can hold a much larger range of values 
than integer variables can . If a floating-point 
value is stored in an int eger 
variable, and the whole part of the value (the part before the decimal point) is 
too large for the integer variable, an invalid value will be stored in the integer 
variable . 
~ 
Checkpoint 
2.16 How would the following number in scientific notation be represented in E notation? 
6.31 
X 1017 
2.17 
What will the following code display? 
i nt number ; 
number= 
3.625: 
cout << number ; 
2.18 
Write a program that defines an integer variable named age and a double 
variab le named wei ght. Store your age and weight as literals in the variables. 
The program should display these values on the screen in a manner similar to 
the following: 
Program Output 
My age is 26 and my weight is 168.5 pounds. 
(Feel free to lie to the computer about your age and weight. It will never know!) 

52 
Chapter 2 
Introduction to C++ 
The char Data Type 
CONCEPT
: Th e char data type is used to store individual char acters. 
You learned earlier in this chapter that there are two basic kinds of data types, numeric 
and character. Th e previous two sections examined numeric data types. Now let's take 
a look at character data types. 
The simplest character data type is the char data type. A variable of this type can hold only 
a single character and, on most systems, uses just one byte of memory. Here is an example 
of how you might declare a char variable named l etter. Notice that the character literal 
holding the value being assigned to the variable is enclosed in single quotes. 
char letter
= 'A'; 
Program 2-12 uses a char variable and several character literals. 
Program 2-12 
1 // Thi s program uses a char variable 
and several 
charac ter literals. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
char le t ter; 
8 
9 
letter
='A'; 
10 
cout <<let
ter
<< endl ; 
11 
12 
letter 
= 'B'
; 
13 
cout <<let
ter
<< endl ; 
14 
return 
O; 
15 } 
Program Output 
A 
B 
Interestingly, characters are closely related to integers because internally they are stored as 
integers. Each printable character, as well as many nonprintable characters, is assigned a 
unique number. The most commonly used method for encoding characters is ASCII, which 
stands for the American Standard Code for Information Interchange. When a character is 
stored in memory, it is actually its numeric code that is stored. When the computer is 
instructed to print the value on the screen, it displays the character that corresponds to the 
numeric code. Appendix A, located at the back of this text, shows the entire ASCII character 
set so you can see which integer value is used to represent each character. Notice that the 
number 65 is the code for capital A, 66 is the code for capital B, and so on. 
Program 2-13 illustrates this relationship between characters and how they are stored . 

2.9 The char Data Type 
53 
Program 2-13 
1 II Thi s program demonstrates 
that 
characters 
are actually 
2 II stored 
internally 
by their 
ASCII integer 
value. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
char letter; 
9 
10 
letter= 
65; 
II 65 i s the ASCII code for the character 
A 
11 
cout <<letter<< 
endl; 
12 
13 
letter= 
66; 
II 66 i s the ASCII code for the character 
B 
14 
cout <<letter<< 
endl; 
15 
return 
O; 
16 } 
Program Output 
A 
B 
Figure 2-4 
Figure 2-4 further illustrates that when you think of characters, such as A, B, and C, 
being stored in memory, it is really the numbers 65, 66, and 67 that are stored. 
GGG 
+ 
is stored in~memo,y os 
+ 
0G~ 
The Difference Between Character Literals and 
String Literals 
Character literals and char variables can only hold a single character. If you want to 
store more than one character in a literal or variable, you need to use a more complex 
character data type, a string . String literals and variables can hold a whole series of 
characters. In the next section we will examine string variables in more detail. For now, 
let's look at string literals and compare them to character literals. 
In the following example, 'H' is a character literal and "Hello" is a string literal. Notice 
that while a character literal is enclosed in single quotation marks, a string literal is 
enclosed in double quotation marks. 
cout << ' H' << endl; 
cout <<"Hello"<< 
endl; 
II Thi s di splays 
a character 
literal
. 
II Thi s di splays 
a str i ng literal. 

54 
Chapte r 2 
Figure 2-5 
Introduction to C++ 
Because a string literal can be virtually any length, there must be some way for the 
program to know how long it is. In C++ this is done by appending an extra byte to its 
end and storing the number O in it. This is called the null terminator or null character 
and marks the end of the string. 
Don't confuse the null terminator with the character 'O'. If you look at Appendix A 
you will see that the character 'O' has ASCII code 48, whereas the null terminator has 
ASCII code 0. When you print the character O on the screen, it is the character with 
ASCII code 48 that is displayed. When you use a string literal or assign a value to a string 
variable, it is the character with ASCII code O that is automat ically appended to it. 
Let's look at an example of how a string literal is stored in memory. Figure 2-5 depicts 
the way the string "Sebastia
n" would be stored . 
s 
e 
b 
a 
s 
t 
a 
n 
\0 
[OJ 
[1] 
[2] 
[3] 
[4] 
[5] 
[6] 
[7] 
[8] 
[9] 
First, notice that the characters in the string are stored in consecutive memory locations. 
Second, notice that the quotation marks are not stored with the string . They simply 
mark the beginning and end of the string in your source code. Finally, notice the very 
last byte of the string . It contains the null terminator , which is represented by the \0 
character. The addition of this last byte means that although the string "Sebastian" 
is 
nine characters long, it occupies ten bytes of memory . 
The null terminator is another example of something that sits quietly in the background. 
It doesn't print on the screen when you display a string, but nevertheless, it is there 
silently doing its job. 
0 
NOTE: 
C++ automatically places the null terminator at the end of string literals. 
Figure 2-6 
Figure 2-7 
Now let's compare the way a char and a string are stored . Suppose you have the 
literals 'A' and "A" in a program. Figure 2-6 depicts their internal storage. 
'A' is stored as 
A 
•A• is stored as 
A 
\0 
As you can see, 'A ' is a 1-byte element holding a single character and "A" is a 2-byte 
element holding two characters . Because characters are really stored as ASCII codes, 
Figure 2-7 shows what is actually being stored in memory. 
'A' is stored as 
65 
•A• is stored as 
65 
0 

0 
2.9 The char Data Type 
55 
Because a char variable can only hold a single character, it can be assigned the character 
'A' , but not the string "A" . 
char le t terOne = 'A'; 
char le t ter Two = "A"; 
II Thi s is correct. 
II Thi s wi ll NOT work! 
NOTE: 
It is important not to confuse character literals with string literals. A 
character literal must be enclosed in single quotation marks. A string literal must be 
enclosed in double quotation marks. 
You have learned that some strings look like a single character but really aren't . It is also 
possible to have a character that looks like a string. An example is the newline character, 
\ n. Although it is represented by two characters, a slash and an n, it is internally 
represented as one character. In fact, all escape sequences, internally, are just 1 byte. 
Program 2-14 shows the use of \n as a character literal, enclosed in single quotation 
marks. If you refer to the ASCII chart in Appendix A, you will see that ASCII code 10 
is the linefeed character. This is the code C++ uses for the newline character. 
Program 2-14 
1 II Thi s progra m uses charac t er literals. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main () 
6 { 
7 
char le t ter; 
8 
9 
letter= 
'A'; 
10 
cout << let t er << 
I \n t; 
11 
12 
letter= 
'B'; 
13 
cout << let t er << I \n I; 
14 
return 
O; 
15 } 
Program Output 
A 
B 
Let's review some important points regarding characters and strings: 
• Printable characters are internally represented by numeric codes. Most computers 
use ASCII codes for this purpose. 
• Characters normally occupy a single byte of memory. 
• Strings hold one or more characters that occupy consecutive bytes of memory. 
• String literals have a null terminator at the end . This marks the end of the string . 
• Character literals are enclosed in single quotation marks. 
• String literals are enclosed in double quotation marks. 
• Escape sequences such as ' \ n' are stored internally as a single character. 

56 
Chapte r 2 
2.10 
Introduction to C++ 
The C++ string 
Class 
CO N C E PT: Standard C++ provides a special data type for storing and working with strings. 
Because a char variable can store only one character in its memory location, another 
data type is needed for a variable able to hold an entire string. Although C++ does not 
have a built-in data type able to do this, Standard C++ provides something called the 
str i ng class that allows the programmer to create a string type variab le. 
Using the string 
Class 
The first step in using the stri
ng class is to #i nclude the str i ng header file. This is 
accomplished with the following preprocessor directive: 
#i nclude <st ring> 
The next step is to define a string 
type variable, called a st r i ng object. Defining a 
string 
object is similar to defining a variable of a primit ive type. For example, the 
following statement defines a str i ng object named movi eTi t l e. 
stri
ng movieTitle; 
You can assign a string literal to movi eTi t le with the assignment operator, like this. 
movieTit le = "Wheels of Fury"; 
And you can use cout to display the value of the movi eTi t le object, as shown here. 
cout << "My favor i te movie is"<< 
movieTitle 
<< endl; 
Program 2-15 is a complete program that demonstrates the preceding statements . 
Program 2-15 
1 II Thi s program demonstra t es t he stri
ng class. 
2 #include 
<iostream> 
3 #include 
<str i ng> 
II Required 
for t he str i ng class. 
4 using namespace std; 
5 
6 int main () 
7 { 
8 
string 
movi eTitle; 
9 
10 
movieT it le = "Wheels of Fury"; 
11 
cout << "My favor i te movie is"<< 
movi eTitle 
<< endl; 
12 
return 
O; 
13 } 
Program Output 
My favor i te movie is Wheels of Fury 

2.11 The bool Data Type 
57 
As you can see, working with string objects is similar to working with variables of 
other types. Throughout this text we will continue to discuss string 
class features and 
capabilit ies. 
~ 
Checkpoint 
2.11 
2.19 
What are the ASCII codes for the following characters? (Refer to Appendix A.) 
C 
F 
w 
2.20 
Which of the following is a character literal? 
'B' 
"B" 
2.21 
Assuming the char data type uses 1 byte of memory, how many bytes do each of 
the following literals use? 
·a· 
"Q" 
"Sal es" 
t \ n I 
2.22 
What is wrong with the following program statement? 
char le t ter= 
"Z"; 
2.23 
What header file must you include in order to use string 
objects? 
2.24 
Write a program that stores your name, address, and phone number in three 
separate string 
objects. Then display their contents on the screen. 
The boo 1 Data Type 
CONCEPT: 
Boolean variables are set to either t rue or false. 
Expressions that have a true or false value are called Boolean expressions, named in 
honor of English mathematician George Boole (1815- 1864). 
The bool data type allows you to create variab les that hold t rue or false 
values. 
Program 2-16 demonstrates the definition and use of a bool variab le. Although it 
appears that it is storing the words true and false in this variable, it is actually 
stor ing 1 or 0. This is because true is a specia l integer variable whose value is 1 and 
false 
is a special integer variab le whose value is 0, as you can see from the program 
output . 

58 
Chapter 2 
Introduction to C++ 
Program 2-16 
1 // Thi s progra m uses Boolean variables
. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
bool boolValue; 
8 
9 
boolValue = true; 
10 
cout << boolVal ue << endl; 
11 
12 
boolValue = fa ls e ; 
13 
cout << boolValu e << endl; 
14 
return 
O; 
15 } 
Program Output 
1 
0 
0 
2.12 
NOTE: 
Notice that the words tr ue and false 
do not have quotation mar ks 
around them . This is because they are variables, not strings. 
Determining 
the Size of a Data Type 
CONCEPT: 
Th e sizeof operator may be used to determine the size of a data type 
on any system. 
Chapter 1 discussed the portability of the C++ language. As you have seen in this 
chapter, one of the problems of portabi lity is the lack of common sizes of data types on 
all machines . If you are not sure what the sizes of data types are on your compute r, 
C++ provides a way to find out . 
A special operator called s i zeof will report the number of bytes of memory used by 
any data type or variable. Program 2-17 illustrates its use. 
The name of the data type or variable is placed inside the parentheses that follow the 
operator. Th e operator "returns" the number of bytes used by that item. This operator 
can be used anywhere you can use an unsigned integer, including in mathematical 
operations . 

2.13 More on Variable Assignments and Initialization 
59 
Program 2-17 
1 // This program displays 
the size 
of various 
data types . 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main() 
6 { 
7 
double apple; 
8 
9 
cout << "The size 
of a short 
integer 
is"<< 
sizeof(short) 
10 
<<" 
bytes.
\ n" ; 
11 
12 
cout << "The size 
of a long integer 
is
"<< 
siz eof(long) 
13 
<<" 
bytes.
\ n" ; 
14 
15 
cout << "An apple can be eaten 
in"<< 
sizeof(apple
) 
16 
<<" 
bytes !\ n" ; 
17 
18 
return 
O; 
19 } 
Program Output 
The size 
of a short 
integer 
is 2 bytes. 
The size 
of a long integer 
is 4 bytes. 
An apple can be eaten 
in 8 bytes! 
2.13 
a 
VideoNot e 
Assignment 
Statements 
More on Variable Assignments and Initialization 
CONCEPT: 
A varia ble can be assigned a valu e at the time it is defined. Thi s is called 
variable initialization. 
As you have already seen in many examples, a value is stored in a variable with an 
assignment statement . For example, the following statement copies the value 12 int o 
the variable uni ts Sold. 
uni tsSold 
= 12; 
Th e = symbo l, as you recall, is called the assignment operator . Operators 
perform 
operations 
on data . The data that operators 
work with are called operands . The 
assignment operator has two operands. In the previous statement, the left operand is 
the variable uni ts Sold and the right operand is the inte ger litera l 12. 
It is important to remember that in an assignment statement, C++ requires the name of 
the variable receiving the assignment to appear on the left side of the operator. The 
following statement is incorrect . 
12 = unitsSold; 
// Incorrect! 

60 
Chapter 2 
Introduction to C++ 
In C++ terminology, the operand on the left side of the = symbol must be an !value. An !value 
is something that identifies a place in memory whose contents may be changed, so a new 
value can be stored there. Most of the time the !value will be a variable name. It is called an 
!value because it is a value that may appear on the left-hand side of an assignment operator. 
The operand on the right side of the = symbo l must be an rvalue. An rvalue is any 
express ion that has a value. This could be a single number, like 12, the result of a 
calculation, such as 4 + 8, or the name of a variable . The assignment statement 
evaluates the expression on the right -hand side to get the value of the rvalue and then 
puts it in the memory location identified by the !value. If the integer variable qua nt i ty 
has the value 12, all three of the following statements assign the value 12 to the 
uni t sSold variable . 
uni tsSold = 12; 
uni tsSold = 4 + 8; 
uni tsSold = quant i ty; 
You have also seen that it is possible to assign values to variab les when they are defined. 
This was done in Programs 2-10 and 2-11. When a value is stored in a variable at the 
time it is defined, it is called initialization. If multiple variables are defined in the same 
statement, it is possible to initialize some of them without having to initialize all of 
them. Program 2-18 illustrates this . 
Program 2-18 
1 II Thi s progra m shows variable 
in i t i ali zation. 
2 #include 
<iostream> 
3 #include 
<str i ng> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
9 
10 
11 
12 
13 
string 
month= 
"February"; 
int year, 
days= 
29; 
year= 
1776; 
II month is in i t i alized 
to "February" 
II year is not i nitiali
zed 
II days is initial
iz ed t o 29 
II Now year is ass i gned a value 
14 
cout <<" In " 
<<year<<" 
"<< month 
15 
<<"had"<< 
days<<" 
days.\n"; 
16 
17 
return 
O; 
18 } 
Program Output 
In 1776 February had 29 days. 

0 
2.14 Scope 
61 
Declaring Variables with the auto Key Word 
C++ 11 introduces an alternative way to define variables by using the auto key word 
and an initialization value. Here is an example: 
auto amount= 100; 
Notice that the name of the variable has the key word auto in front of it, instead of a 
data type . This tells the compi ler to determine the variable's data type from the 
initialization value. In this examp le the initialization value, 100, is an int, so amount 
will be an i nt variable. Here are other examples: 
auto stockCode = 'D'; 
auto customerNum = 459L; 
The variable stockCode will be a char because its initialization value, 'D', is a char and 
the variable customerNum will be a 1 ong int because its initialization value, 459L, is a long. 
auto quarter2 
= quarter1; 
Variable quarter2 will be the same data type as previously defined variable quarter1. 
auto numEggs = 12; 
auto interestRate 
= 12.0; 
The variable numEggs will be an int because its initialization value, 12, is an int, but 
the variable i nterestRate 
will be a double because its initialization value, 12.0, is a 
double. This illustrates that when you want the variable you are defining with the 
auto key word to be a double, you must be sure to include a decimal point in the 
initialization value. 
Th ese examp les show how to use the auto key word, but they don't really show its 
usefulness. The auto key word is intended to simplif y the syntax of declarations 
that are more complex than the ones shown here. Later in the book you will see 
examples of how its use can improve the readability 
of comp lex definition 
statements. 
Scope 
CONCEPT: 
A variable's scope is the part of the program that has access to the variable. 
Every variable has a scope. Th e scope of a variab le is the part of the program where 
it may be used. Th e rules that define a variab le's scope are comp lex, and we will just 
introduce the concept here. Later we will cover this topic in more depth . 
The first rule of scope is that a variable cannot be used in any part of the program 
before it is defined. Program 2-19 illustrates this. 

62 
Chapter 2 
Introduction to C++ 
Program 2-19 
1 II This program can 't find its variable. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
8 
cout << value; 
9 
int value= 
100; 
10 
return 
O; 
11 } 
II ERROR! value has not been def i ned yet! 
The program will not work because line 7 attempts to send the contents of the variable 
value to cout before it is defined . To correct the program , the variable definition must 
be put before any statement that uses it. 
2.15 
Arithmetic Operators 
CONCEPT: 
C++ has many operator s for performing arithmetic operation s. 
a 
C++ provides many operators for manip ulating data. Generally , there are three types 
of operators: unary , binary , and ternary. These terms reflect the number of operands 
an operator requires . 
VideoNot e 
Arithmetic 
Operators 
Unary operators only require a single operand . For examp le, consider the expression - 5. 
Of course, we understand this represents the value negative five because the literal 5 is 
preceded by the minus sign. The minus sign, when used this way, is called the negation 
operator. Because it only requires one operand, it is a unary operator. 
Binary operators work with two operands. This is the most common type of operato r. 
Ternary operators, as you may have guessed, require three operands . C++ only has one 
ternary operator, which will be discussed in Chapter 4. 
Arithmet ic operations occur frequently in programming . Table 2-10 shows the common 
arithmetic operators in C++. All are binary operators . 
Table 2 -10 Funda mental Arithmetic Operators 
Operator 
+ 
* 
I 
% 
Meaning 
Addition 
Subtract ion 
Mult iplication 
Division 
Mod ulus 
Example 
total = cost 
cost = total 
tax = cost 
* 
salePrice 
= 
remainder = 
+ tax ; 
- tax ; 
rate; 
orig i nal I 2; 
value% 
3; 

Here is an examp le of how each of these operators works. 
The addition operator returns the sum of its two operands. 
2.15 Arithmetic Operators 
63 
total 
= 4 + 8; 
// total 
is assigned the value 12 
The subtraction operator returns the value of its right operand subtracted from its left 
operand . 
candyBars = 8 - 3; 
// candyBars is assigned 
the value 5 
The multiplication operator returns the product of its two operands . 
poi nts= 
3 * 7 ; 
// points i s assigned the value 21 
The division operator returns the quotient of its left operand divided by its right operand. 
double points= 
5.0 I 2; 
// poi nts is ass i gned the value 2.5 
However, the division operator works differently depending on whether its operands 
are integer or floating-point numbers. When either operand is a floating-point number, 
it performs the "norma l" type of division you are familiar with, as shown above. On 
the other hand, when both operands are integers, the result of the division will also be 
an integer. If the result has a fractional part, it will be thrown away . This type of 
division is known as integer division. 
Here is an examp le of integer division. 
double ful1Boxes = 26 / 8; 
// ful1Boxes i s assigned 
3.0, 
not 3 .25 
The result of the integer divide is 3 because 8 goes into 26 three whole times with a 
remainder of 2. The remainder is discarded. When the 3 is assigned to the floating-
point variable full Boxes, it is changed into the floating -point value 3.0. The fractional 
part of the division is discarded even though the result is being assigned to a floating-
point variable because the division takes place before the assignment. 
If you want the division operato r to perform regular division, you must make sure at 
least one of the operands is a floating -point number. 
The modulus operator comp utes the remainder of doing an integer divide. 
leftover= 
26 % 8; 
// leftover 
is assigned the value 2 
Figure 2-8 illustrates the use of the integer divide and modulus operations . 
Figure 2-8 
Intege r Divide and Modulus Operations 
3 
R 2-,..,__ 
,-- 26-
~26%8 
26/8 
8 
In Chapter 3 you will learn how to use these operators in more complex mathematical 
formulas. For now we will concentrate on their basic usage. Here is a program that does 
that. It uses two arithmetic operators, the addition operator and the multiplication operator. 
Suppose we need to write a program to calculate and display an employee's wages for 
the week. The regular hours for the week are 40, and any hours worked over 40 are 
considered overtime. The employee earns $18.25 per hour for regular hours and $27 .38 
per hour for overtime hours. The employee worked 50 hours this week. 

64 
Chapte r 2 
Introduction to C++ 
The following pseudocode algorithm shows the program's logic. 
Regular wages= base pay rate 
x 
regular 
hours 
Overtime wages= overtime 
pay rate 
x 
overtime 
hours 
Total wages= regular 
wages+ overtime 
wages 
Display 
the total 
wages 
Program 2-20 shows the C++ code for the program. 
Program 2-20 
1 II This program calculates 
hourly wages, incl uding overtime. 
2 II It uses two arithmetic 
operators, 
the addition 
operator 
8 II and the multiplication 
operator. 
4 #include 
<iostream> 
5 using namespace std; 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
int main() 
{ 
double basePayRate 
overtimePayRate 
regularHours 
overtimeHours 
regularWages, 
overtimeWages, 
total Wages; 
= 18.25, 
= 27.38, 
= 40.0, 
= 10, 
17 
II Calculate 
regular 
wages 
II Base pay rate 
II Overtime pay rate 
II Regular hours worked 
II Overtime hours worked 
II Computed regular 
wages 
II Computed overtime 
wages 
II Computed total 
wages 
18 
regularWages 
= basePayRate 
* regularHours; 
19 
20 
II Calculate 
overtime 
wages 
21 
overtimeWages = overtimePayRate 
* overtimeHours; 
22 
23 
II Calculate 
total 
wages 
24 
totalWages 
= regularWages 
+ overtimeWages; 
25 
26 
II Display 
total 
wages 
27 
cout << "Wages for this 
week are$"<< 
totalWages 
<< endl; 
28 
return 
O; 
29
} 
Program Output 
Wages for this 
week are $1003.B 
Notice that the output displays the wages as $1003.8, with just one digit after the decimal 
point. In Chapter 3 you will learn to format output so you can contro l how it displays. 
The following program illustrates two additional arithmetic operators . It uses integer 
division and the modulus operator to convert seconds into minutes and seconds. 

Program 2-21 
1 II Thi s program converts 
seconds to mi nutes and seconds . 
2 II It uses i nteger 
di vi s i on and the modulus operator. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 int main() 
7 { 
2.15 Arithmetic Operato rs 
65 
8 
9 
10 
int tota1Seconds 
= 125 , 
minutes , 
seconds; 
II Number of seconds to be converted 
II Number of minutes 
in tota1Seconds 
II Number of seconds 
remai ni ng 
11 
12 
II Calculate 
the number of minutes 
13 
minutes
= tota1Seconds 
I 60; 
14 
15 
II Calculate 
the remai ni ng seconds 
16 
seconds= 
tota1Seconds 
% 60; 
17 
18 
II Display 
the results 
19 
cout << tota1Seconds 
<<" 
seconds i s equivalent 
to"· 
20 
cout <<minutes<<" 
minutes and"<< 
seconds<<" 
seconds. 
\n"; 
21 
22 
return 
O; 
23 } 
Program Output 
125 seconds is equivalent 
to 2 minutes and 5 seconds. 
~ 
Checkpoint 
2.25 
Is the following assignment statement valid or invalid? If it is invalid, why? 
72 = amount; 
2.26 
What is wrong with the following program? How would you correct it? 
#include 
<iostream> 
us i ng namespace std; 
int mai n() 
{ 
} 
critter= 
62.7; 
double critter; 
cout <<critter<< 
end l; 
return 
O; 
2.27 
What will be assigned toxin each of the following statements? 
A) x = 8 + 3; 
B)x=8-3; 
C)x=8*3; 
D) x = 8 % 3; 
2.28 
Is the following an example of integer division or floating-point division? What 
value will be displayed? 
cout << 16 I 3; 

66 
Chapte r 2 
Introduction to C++ 
Comments 
CONCEPT
: Comm ents are notes of explan ation that document lines or sections of 
a program. 
It may surprise you that one of the most important parts of a program has absolutely 
no impact on the way it runs. We are speaking, of course, of the comments . Comments 
are part of the program , but the compiler ignores them . They are intended for people 
who may be reading the source code. 
Some programmers resist putting more than just a few comments in their source code. 
After all, it may seem like enough work to type the parts of the program that actually 
do something. It is crucia l, however , that you develop the habit of thoroughly 
annotating your code with descriptive comments . It might take extra time now, but it 
will almost certainly save time in the future . 
Imagine writing a program of medium complexity with about 8,000 to 10,000 lines of C++ 
code. Once you have written the code and satisfactorily debugged it, you happily put it 
away and move on to the next project . Ten months later you are asked to make a 
modification to the program (or worse, track down and fix an elusive bug). You pull out 
the massive pile of paper that contains your source code and stare at thousands of statements 
only to discover they now make no sense at all. You find variables with names like z2, and 
you can't remember what they are for. If only you had left some notes to yourself explaining 
all the program's nuances and oddities. But it's too late now. All that's left to do is decide 
what will take less time: figuring out the old program or completely rewriting it! 
This scenar io might sound extreme, but it's one you don't want to happen to you. 
Real-world programs are big and comp lex. Thoroughly documented programs will 
make your life easier, not to mention the work of other programmers who may have to 
read your code in the future . In addit ion to telling what the program does and describing 
the purpose of variables, comments can also be used to explain comp lex procedures in 
your code and to provide information such as who wrote the program and when it was 
written or last modified . 
Single Line Comments 
You have already seen one way to place comments in a C++ program . As illustrated in 
programs throughout this chapter, you simply place two forward slashes (//) where 
you want the comment to begin. The compiler ignores everything from that point to 
the end of the line. This is called a single line comment. 
Multi-Line 
Comments 
The second type of comment in C++ is the multi-line comment . Multi-line comments start 
with/ * (a forward slash followed by an asterisk) and end with */ (an asterisk followed by 
a forward slash). Everything between these markers is ignored. Program 2-22 illustrates 
the use of both a multi-line comment and single line comments. The multi-line comment 
starts on line 1 with the/ * symbol, and ends on line 6 with the */ symbol. 

2.17 Programming Style 
67 
Program 2-22 
1 / * 
2 
PROGRAM: Payroll .cp p 
3 
Wri tten 
by Herbert 
Dorfmann 
4 
This program calculates 
company payroll 
5 
Last modi f ie d: 8/20/2012 
6 */ 
7 #include 
<iostream> 
8 using namespace std; 
9 
10 int main() 
11 { 
12 
13 
14 
int employeeID; 
double payRate; 
double hours; 
// Employee ID number 
// Employees hourly 
pay rate 
// Hours employee worked th i s week 
(The remainder 
of this 
program is left 
out.) 
<) 
2.17 
Notice that unlike a comment started with I I, a multi-line comment can span several lines. 
This makes it more convenient to write large blocks of comments because you do not have 
to mark every line. On the other hand, the multi-line comment is inconvenient for writing 
single line comments because you must type both a beginning and ending comment symbol. 
NOTE: Many programmers use a combination of single line comments and multi-
line comments, as illustrated in the previous sample program . Convenience usually 
dictates which style to use. 
When using multi-line comments: 
• Be careful not to reverse the beginning symbol with the ending symbol. 
• Be sure not to forget the ending symbol. 
Both of these mistakes can be difficult to track down and will prevent the program 
from compiling correctly . 
Programming 
Style 
CONCEPT: 
Program ming style refers to the way a programmer uses identifiers, 
spaces, tabs, blank lines, and punctuation characters to visually arrange 
a program's source code. These are some, but not all, of the elements of 
programming style. 
In Chapter 1 you learned that syntax rules govern the way a language may be used. 
The syntax rules of C++ dictate how and where to place key words, semicolons, 
commas, braces, and other components of the language . The compiler's job is to check 
for syntax errors and, if there are none, to generate object code. 

68 
Chapte r 2 
Introduction to C++ 
When the compiler reads a program it processes it as one long stream of characters. 
Th e compiler is not influ enced by whether each statement is on a sepa rate line or 
whet her spaces separate operators from operands . Hum ans, on the othe r hand , find it 
difficult to read programs that aren 't written in a visually pleasing manner. Consider 
Program 2-23, for examp le. 
Program 2-23 
1 #include 
<iostream> 
2 using namespace std ;i nt mai n(){double 
shares =220.0 ;double 
3 avgPrice =14.67 ;cout 
4 <<"There were "<<shares<< " shares 
sold at $"<<avgPrice<< 
5 • per share.\n";return 
O;} 
Program Output 
There were 220 shares 
sold at $14.67 per share. 
Although the program is syntactica lly correct (it doesn't violate any rules of C++), it is 
difficult to read. The same program is shown in Program 2-24, written in a clearer style. 
Program 2-24 
1 // This program is vi sually 
arranged 
to make it readable. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
double shares
= 220.0 ; 
8 
double avgPrice 
= 14.67 ; 
9 
10 
cout << "There were•<< 
shares<<• 
shares 
sold at$"; 
11 
cout << avgPrice 
<<•per 
share .\n"; 
12 
return 
O; 
13 } 
Program Output 
There were 220 shares 
sold at $14.67 per share. 
Programming style refers to the way source code is visually arranged . Ideally, it is a 
consistent method of putting spaces and indentions in a program so visual cues are 
created . The se cues quickly tell a programmer important information about a program. 
For example, notice in Program 2-24 that the open ing and closing braces of the mai n 
function align and inside the braces each line is indented. It is a common C++ style to 
indent all the lines inside a set of braces. You will also notice the blank line between the 
variable definitions and the cout statements . Thi s is intended to visually separate the 
definitions from the executab le statements. 

<) 
""" 
2.18 
2.18 Tying It All Together: Smile! 
69 
NOTE: 
Although you are free to develop your own style, you should adhere to 
common programming practices. By doing so, you will write programs that visually 
make sense to other programmers and that minimize the likelihood of errors . 
Another aspect of programming style is how to handle statements that are too long to 
fit on one line. Because C++ is a free-flowing language, it is usually possible to spread a 
statement over several lines. For example, here is a cout statement that uses two lines: 
cout << "The Fahrenhe it temperature 
is
" << fahrenheit 
<<" 
and the Celsius 
temperature 
is
"<< celsius 
<< endl ; 
This statement works just as if it were typed on one line. You have already seen variable 
definitions treated similarly: 
i nt fahrenheit
, 
cels i us, 
kelvin ; 
Other issues related to programming style will be presented throughout the book. 
Tying It All Together: Smile! 
With just the little bit of C++ covered so far, you can print pictures using cout 
stateme nts. Here is the code to make a simple smiley face. Try it! 
" 
" 
• 
\_
/ 
Program 2-25 
1 // This program prints 
a simple smiley face. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
cout << "\n\n"; 
8 
cout << " 
" 
" 
\n"; 
9 
cout << " 
* 
\n"; 
10 
cout << " 
\\ 
I 
\n"; 
11 
return 
O; 
12 } 
Now try revising Program 2-25 to make faces like these. 
0 
0 
0 
(_) 
" 
" 
V 
V 
\UUU/ 

70 
Chapter 2 
Introduction to C++ 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. Every complete statement ends with a ___ 
_ 
2. To use cout statements you must include the ____ 
file in your program. 
3. Every C++ program must have a function named ___ 
_ 
4. Preprocessor directives begin with a ___ 
_ 
5. A group of statements, such as the body of a function, must be enclosed in 
6. 72, 'A',and 
"Hel lo World" are all examp les of ___ 
_ 
7. 978.65 x 10 12 would be written in E notation as ___ 
_ 
8. The character literal 'A' requires ____ 
byte(s) of memory , whereas the 
string literal "A" requires _____ 
byte(s). 
9. Indicate if each of the following assignment statements is valid or invalid. 
A) total 
= 9; 
B) 72 = amount ; 
C) yourAge = myAge; 
10. If the variables letter 
and w have been defined as character variables, indicate if 
each of the following assignment statements is valid or invalid. 
A) let t er = w; 
B) let t er = 'w'; 
C) let t er = "w"; 
11. Indicate if each of the following cout statements is valid or invalid. 
A) cout << "Hello" << endl; 
B) cout << "Hello" << \n; 
C) cout << Hello; 
12. Indicate if each of the following cout statements is valid or invalid. 
A) cout << "Hello world"; 
B) cout << Hel lo world; 
C) cout << "Hello" 
<< " world"; 
13. Assume integers x = 4, y = 7, and z = 2. What value will be stored in integer 
variab le resul t by each of the following statements? 
A) resul t = x + y; 
B) result 
= y * 2; 
C) resul t = y I z ; 
14. Assume doubl e variab les x = 2. 5, y = 7. o, and z = 3. What value will be stored 
in integer variable resu l t by each of the following statements? 
A) resul t = x + y; 
B) result 
= y * 2; 
C) resul t = y I z ; 

Review Questions and Exercises 
71 
15. Write a C++ statement that defines the double 
variables t emp, weigh t , and 
he i ght all in the same statement . 
16. Write a C++ statement that defines the i nt variables months, days, and years all 
in the same statement, with months initialized to 2 and years initialized to 3. 
17. Write assignment statements that perform the following operations with int var-
iable i, double variab les d1 and d2, and char variable c. 
A) Add 2 to d1 and store the result in d2. 
B) Multiply d2 times 4 and store the result in d1. 
C) Store the character ' K' in c. 
D) Store the ASCII code for the character 'K' in i . 
E) Subtract 1 from i and store the result back in i. 
18. Write assignment statements that perform the following operations with in t 
variab le i , double variables d1 and d2, and c har variable c. 
A) Subtract 8.5 from d2 and store the result in d1. 
B) Divide d1 by 3.14 and store the result in d2 . 
C) Store the ASCII code for the character ' F' in c. 
D) Add 1 to i and store the new value back in i. 
E) Add d1 to the current value of d2 and store the result back in d2 as its new value. 
19. Modify the following program segment so it prints two blank lines between each 
line of text. 
co ut << "Two mando li ns like 
creatures 
in the"; 
cou t << "dark"; 
cou t << "Creating 
th e agony of ecstasy. 
". 
' 
co ut << .. 
- George Barker"; 
20. Rewrite the follow statement to use the newline escape character, instead of an 
end l , each time subsequent output is to be displayed on a new line. 
cou t 
<< "L" << endl 
<< "E" << endl 
<< "A" << e ndl 
<< "F" << e ndl; 
Algorithm Workbench 
21. Create detailed pseudocode for a program that calculates how many days are left 
until Christmas, when given as an input how many weeks are left until Christ-
mas. Use variables named weeks and days. 
22. Create detailed pseudocode for a program that determines how many full 12-egg 
cartons of eggs a farmer can pack when given as an input the number of eggs he 
has collected on a given day. Use variab les named eggs and cartons. 
23. Create detailed pseudocode for a program that determines distance traveled when 
given inputs of speed and time. Use variables named speed, t i me, and di stance. 
24. Create detailed pseudocode for a program that determines miles per gallon a 
vehicle gets when given inputs of miles traveled and gallons of gas used. Use 
variab les named mil es, gallons, 
and mil esPerGal lon . 

72 
Chapte r 2 
Introduction to C++ 
Predict the Output 
25. What will the following programs print on the screen? 
A) #include 
<iostream> 
using namespace std; 
int main () 
{ 
} 
int freeze= 
32, boil = 212; 
freeze
= O; 
boil = 100 ; 
cout <<freeze<< 
end l << boil << endl ; 
return 
O; 
8 ) #include 
<iostream> 
using namespace std; 
int main () 
{ 
} 
int 
X = 0, 
y = 2; 
X = y * 4 ; 
cout << x << endl << y << endl; 
return 
O; 
C) #include 
<iostream> 
using namespace std; 
int main () 
{ 
} 
cout << "I am the incredible"; 
cout << "computing\nmachine"; 
cout << "\nand 
I will\namaze\n"; 
cout << "you.\n"; 
return 
O; 
26. 
A) #include 
<iostream> 
using namespace std; 
int main () 
{ 
} 
cout << "Be careful !\n"; 
cout << "This might /n be a t rick·· 
cout << "question.\n"; 
return 
O; 
B) #include 
<iostream> 
using namespace std; 
int main () 
{ 
} 
int a, x = 23; 
a= 
X % 2 ; 
cout << x << endl <<a<< 
endl; 
return 
O; 

Review Questions and Exercises 
73 
Find the Error 
27. The following program contains many syntax errors. Locate as many as you can. 
1. */ What's 
wrong with this 
program?/* 
2. #include 
iostream 
3. us i ng namespace std; 
4. 
5. i nt main(); 
6. 
} 
7. 
8. 
9. 
in t a, b, c 
a = 3 
b = 4 
10. 
c=a
+ b 
\\ Define 
3 i ntegers 
11. 
Cout >> "The va l ue of c is•>> 
C; 
12. 
re t urn O; 
13. 
{ 
Soft Skills 
Programmers need good communication skills as well as good analytical and problem-
solving skills. Good communication can minimize misunderstandings that easily arise 
when expectations of different individuals involved in a project are not clearly enough 
articulated before the project begins. A detailed set of project specifications can clarify 
the scope of a project, what interaction will occur between the user and the program, 
and exactly what the program will and will not do. 
28. Pair up with another student in the class. One of you is the client and the other 
is the software developer. Briefly discuss a simple program the client wants the 
programmer to create. Here are some possible ideas. 
• The paint problem described in the Chapter 1 Soft Skills exercise 
• A program that can halve the quantities of ingredients for a recipe 
• A program that determines how long it will take to drive from point A to point B 
Once you have decided on a program, you should independently, with no further com-
munication, each write down detailed specifications. The client writes down exactly 
what he wants the program to do, and the developer writes down her understanding of 
exactly what the program will do. When you are done, compare what you have written. 
Rarely will the two agree. 
Now discuss the discrepancies and see if you can come to a clear understanding of 
exactly what the program must do. Together create a program specification sufficiently 
detailed that both of you believe it leaves no room for misunderstanding . 

74 
Chapter 2 
VideoNote 
Solving the 
Restaurant Bill 
Problem 
Introd uction to C++ 
Programming 
Challenges 
1. Sum of Two Numbers 
Write a program that stores the integers 50 and 100 in variables and stores the sum of 
these two in a variable named t ot al . Display the total on the screen. 
2. Sales Prediction 
The East Coast sales division of a company generates 58 percent of total sales. Based on 
that percentage, write a program that will predict how much the East Coast division will 
generate if the company has $8.6 million in sales this year. Display the result on the screen. 
3. Sales Tax 
Write a program that computes the total sales tax on a $95 purchase. Assume the state 
sales tax is 6.5 percent and the county sales tax is 2 percent. Display the purchase price, 
state tax, county tax, and total tax amounts on the screen. 
4. Restaurant Bill 
Write a program that computes the tax and tip on a restauran t bill for a patron with a 
$44.50 meal charge. The tax should be 6. 75 percent of the meal cost. The tip should be 
15 percent of the total after adding the tax. Display the meal cost, tax amount, tip 
amount, and total bill on the screen. 
5. Miles per Gallon 
A car holds 16 gallons of gasoline and can travel 312 miles before refueling. Write a 
program that calculates the number of miles per gallon the car gets. Display the result 
on the screen. 
6. Distance per Tank of Gas 
A car with a 20 gallon gas tank averages 23.5 miles per gallon when driven in town 
and 28.9 miles per gallon when driven on the highway. Write a program that calculates 
and displays the distance the car can travel on one tank of gas when driven in town and 
when driven on the highway. 
7. Number of Acres 
One acre of land is equivalent to 43,450 square feet. Write a program that calculates 
and displays the number of acres in a tract of land whose size is 869 X 360 feet. 
8. Land Calculation 
In the United States, land is often measured in square feet. In many other countries, it is 
measured in square meters. One acre of land is equivalent to 43,560 square feet. A square 
meter is equivalent to 10. 7639 square feet. Write a program that computes and displays the 
number of square feet and the number of square meters in ½ acre of land. 
Hint : Because a square meter is larger than a square foot, there will be fewer square 
meters in ½ acre than there are square feet. 

Programming Challenges 
75 
9. Circuit Board Price 
An electronics company makes circuit boards that cost $14.95 apiece to produce. Write 
a program to determine how much the company should sell them for if it wants to 
make a 35 percent profit . Display the result on the screen. 
10. Personal Information 
Write a program that displays the following information, each on a separate line: 
Your name 
Your address, with city, state, and zip code 
Your telephone number 
Your college major 
Use only a single cout statement to display all of this information . 
11. Triangle Pattern 
Write a program that displays the following pattern on the screen: 
* 
*** 
***** 
******* 
12. Diamond Pattern 
Write a program that displays the following pattern on the screen: 
* 
*** 
***** 
******* 
***** 
*** 
* 
13. Pay Period Gross Pay 
A particular employee earns $39,000 annually. Write a program that determines 
and displays what the amoun t of his gross pay will be for each pay period if he is 
paid twice a month (24 pay checks per year) and if he is paid bi-weekly (26 checks 
per year). 
14. Basketball Player Height 
The star player of a high school basketball team is 74 inches tall. Write a program to 
compute and display the height in feet/inches form. 
Hint: Try using the modulus and integer divide operat ions. 

76 
Chapte r 2 
Introduction to C++ 
15. Stock Loss 
Kathryn bought 750 shares of stock at a price of $35.00 per share. A year later she sold 
them for just $31.15 per share. Write a program that calculates and displays the 
following: 
• The total amount paid for the stock. 
• The total amount received from selling the stock. 
• The total amount of money she lost. 
16. Energy Drink Consumption 
A soft drink company recently surveyed 16,500 of its customers and found that 
approximately 15 percent of those surveyed purchase one or more energy drinks per 
week. Of those customers who purchase energy drinks, approximately 52 percent of 
them purchase citrus flavored energy drinks. Write a program that displays the following: 
• The approximate number of customers in the survey who purchase one or 
more energy drinks per week. 
• The approximate number of customers in the survey who purchase citrus 
flavored energy drinks . 
1 7. Past Ocean Levels 
The Earth's ocean levels have risen an average of 1.8 millimeters per year over the past 
century . Write a program that computes and displays the number of centimeters and 
number of inches the oceans rose during this time. One millimeter is equivalent to 
0.1 centimeters . One centimeter is equivalent to 0.3937 inches. 
18. Future Ocean Levels 
During the past decade ocean levels have been rising faster than in the past, an average 
of approximate ly 3.1 millimeters per year. Write a program that computes how much 
ocean levels are expected to rise during the next 15 years if they continue rising at this 
rate. Display the answer in both centimeters and inches. 
19. Annual High Temperatures 
The average July high temperature is 85 degrees Fahrenheit in New York City, 
88 degrees in Denver, and 106 degrees in Pheonix. Write a program that calculates and 
reports what the new average high July temperature would be for each of these cities if 
temperatures to rise by 2 percent. 
20. How Much Paint 
A particular brand of paint covers 340 square feet per gallon . Write a program to 
determine and report approximately how many gallons of paint will be needed to paint 
two coats on a wooden fence that is 6 feet high and 100 feet long. 

TOPICS 
3.1 
The c i n Object 
3.9 
More Mathematical Library Functions 
3.10 Random Numbers 
3.2 
Mathematical Expressions 
3.3 
Data Type Conversion and Type Casting 
3.4 
Overflow and Underflow 
3.11 Focus on Debugging: Hand Tracing a 
Program 
3.5 
Named Constants 
3.12 Green Fields Landscaping Case 
Study- Part 1 
3.6 
Mu ltiple and Combined Assignment 
3. 7 
Formatting Output 
3.13 Tying It All Togethe r: Word Game 
3.8 
Working with Characters and Strings 
3.1 
The ci n Object 
a 
VideoNote 
CONCEPT: 
c in can be used to read data typed at the keyboard. 
So far you have written program s with built-in informat ion. You have initialized the 
variables with the necessary starting values without letting the user enter his or her 
own data . These types of programs are limited to performing their task with only a 
single set of starting information. If you decide to change the initial value of any 
variab le, the program must be modified and recompiled. 
In reality, most programs ask for values that will be assigned to variables. This means 
the program does not have to be modified if the user wants to run it several times with 
different sets of information. For example, a program that calculates the area of a circle 
might ask the user to enter the circle's radius. When the circle area has been computed 
and printed, the program could be run again and a different radius could be entered . 
using cin to Just as C++ provides the cou t object to produce console output, it provides an object 
Read Input named ci n that is used to read console input . (You can think of the word ci n as meaning 
console input. ) Program 3-1 shows cin being used to read values input by the user. 
Not ice that in line 2 there is a #include 
statement to include the i os t ream file. This file 
must be included in any program that uses ci n. 
77 

78 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-1 
1 // 
Thi s program calculates 
and displays 
the area of a rectangle. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main() 
6 { 
7 
int length, 
width, 
area; 
8 
9 
cout << "This program calculates 
the area of a rectangle
. \ n"; 
10 
11 
12 
13 
14 
15 
16 
II Have 
cout << 
cin 
>> 
cout << 
cin 
>> 
the user 
"What is 
length; 
"What is 
width; 
i nput the rectangle's 
length 
and wi dth 
the length 
of the rectangle? .. 
' 
the width of the rectangle? .. 
' 
17 
// Compute and display 
the area 
18 
area= 
length* 
wi dth; 
19 
cout << "The area of the rectangle 
is"<< 
area<< 
endl; 
20 
return 
O; 
21 } 
Program Output with Example Input Shown in Bold 
This program calculates 
the area of a rectangle. 
What is the length 
of the rectangle? 
lO[Enter] 
What is the width of the rectangle? 
20[Ent er] 
The area of the rectangle 
is 200. 
Instead of calculating the area of one rectangle, this program can be used to compute 
the area of any rectangle. The values that are stored in the length and width variables 
are entered by the user when the program is running . Look at lines 12 and 13. 
cout << "What is the length 
of the rectangle? 
"; 
cin 
>> length; 
In line 12 cout is used to display the question "What is the length of the rectangle?" 
This is called a prompt . It lets the user know that an input is expected and prompts 
them as to what must be entered. When ci n is used to get input from the user, it should 
always be preceded by a prompt. 
Line 13 uses ci n to read a value from the keyboard. The >> symbol is the stream 
extraction operator, which extracts characters from the input stream so they can be 
used in the program. More specifically, the stream extraction operator gets characters 
from the stream object on its left and stores them in the variable whose name appears 
on its right. In this example line, the characters read in by ci n are taken from the ci n 
object and stored in the length variable. 
Gathering input from the user is normally a two-step process: 
1. Use cout to display a prompt on the screen. 
2. Use ci n to read a value from the keyboard. 

3.1 The ci n Object 
79 
The prompt shou ld ask the user a question, or tell the user to enter a specific value . For 
example, the code we just examined from Program 3-1 displays the following prompt: 
What is the lengt h of the rectangle? 
This tells the user to enter the rectang le's length . After the prompt displays, the program 
uses ci n to read a value from the keyboard and store it in the length variable. 
Notice that the<< and>> operators appear to point in the direction that data is flowing. 
It may help to think of them as arrows. In a statement that uses cout , the << operator 
always points toward cout , as shown here. This indicates that data is flowing from a 
variable or a litera l to the cout object. 
cout << "What is the length 
of t he rectangle? 
"; 
cout -
"What is the lengt h of the rectangle?
"; 
In a statement that uses ci n, the>> operator always points toward the variab le receiving 
the value. This indicates that data is flowing from the ci n object to a variable. 
ci n >> length; 
ci n -+ length; 
The ci n object causes a program to wait until data is typed at the keyboard and the 
[Enter) key is pressed. No other lines will be executed until ci n gets its input. 
When the user enters characters from the keyboard, they are temporarily placed in an area 
of memory called the input buffer, or keyboard buffer. When ci n reads them, it automatically 
converts them to the data type of the variab le where the input data will be stored . For 
example, if the user types 10, it is read as the characters 'l' and 'O' but ci n is smart enough 
to know this will have to be converted to the in t value 10 before it is stored in length. If 
the user enters a floating-point number like 10.7, however, there is a problem. ci n knows 
such a value cannot be stored in an integer variable, so it stops reading when it gets to the 
decimal point, leaving the decimal point and the rest of the digits in the input buffer. This 
can cause a problem when the next value is read in. Program 3-2 illustrates this problem . 
Program 3-2 
1 II Thi s progra m illustrates 
what can happen when a 
2 II floating
-poin t number is entered 
for an integer 
var i able. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main () 
7 { 
8 
int i ntNumber; 
9 
double floatNumber ; 
10 
11 
cout << "In put a number . .. . 
' 
12 
cin 
>> i ntNumber; 
13 
cout << "In put a second number. \n"; 
14 
cin 
>> fl oatNumber ; 
15 
cout << "You entered: 
• << in tNumber 
16 
<< .. and .. << floa tNumber << endl; 
(program continues) 

80 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-2 
17 
18 
return 
O; 
19 } 
(continued) 
Program Output with Example Input Shown in Bold 
Inpu t a number . 12 .3[Enter] 
Inpu t a second number. 
You ent ered: 
12 and 0.3 
Let's look more closely at what occurred in Program 3-2. When prompted for the first 
number , the user entered 12.3 from the keyboard . However, because ci n was reading 
a value into i nt Number, an integer variable, it stopped reading when it got to the 
decimal point , and a 12 was stored in i ntNumber . When the second ci n statement 
needed a value to read into fl oatNumber , it found that it already had a value in the 
input buffer, the .3 left over from the user's first input. Instead of waiting for the user 
to enter a second number, the .3 was read in and stored in fl oatNumber . 
Later you will learn how to prevent something like this from happening , but for now 
this illustrates the need to provide the user with clear prompts . If the user had been 
specifically prompted to enter an integer for the first number, there would have been 
less chance of a problem occurring . 
<) 
NOTE: Remember to include the i ostream file in any program that uses cout or ci n. 
Entering Multiple Values 
You can use ci n to input multiple values at once. Program 3-3 is a modified version of 
Program 3-1 that does this. 
Program 3-3 
1 // Thi s progra m calcula
t es and displays 
t he area of a rec t angle. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main () 
6 { 
7 
int length, 
width, 
area; 
8 
9 
cout << "This progra m calculates 
the area of a rec t angle . \ n"; 
10 
11 
// Have the user input t he rectangle's 
length 
and width 
12 
cout << "Ent er the length 
and widt h of t he rectangle"; 
13 
cout << "separated 
by a space.\n"; 
14 
ci n >>length>> 
wi dth; 
15 
(program continues) 

Program 3-3 
(continued) 
16 
II Compute and display 
the area 
17 
area= 
length* 
wi dth; 
18 
cout << "The area of the rectangle 
is"<< 
area<< 
endl; 
19 
return 
O; 
20 } 
Program Output with Example Input Shown in Bold 
This program calculates 
the area of a rectangle. 
Enter the length 
and width of the rectangle 
separated 
by a space. 
10 20[Ent er] 
The area of the rectangle 
is 200 
3.1 The ci n Object 
81 
Line 14 waits for the user to enter two values. The first is assigned to length and the 
second to width. 
cin >>length>> 
width; 
In the example output, the user entered 10 and 20, so 10 is stored in length and 20 is 
stored in width. 
Notice the user separates the numbers by spaces as they are entered. This is how ci n 
knows where each number begins and ends . It doesn't matter how many spaces are 
entered between the individual numbers. For example, the user could have entered 
10 
20 
0 
NOTE: 
The [Enter] key must be pressed after the last number is entered. 
You can also read multiple values of different data types with a single ci n statement. 
This is shown in Progr am 3-4. 
Program 3-4 
1 II Thi s program demonstrates 
how cin can read mult i ple values 
2 II of di fferent 
data types. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
i nt whole; 
9 
double fractional; 
10 
char letter
; 
11 
12 
cout << "Enter an integer, 
a double, 
and a character: 
"; 
13 
cin 
>>whole>> 
fract i onal >> letter
; 
14 
15 
cout << "whole: " <<whole<< 
endl; 
16 
cout << "fractional: 
"<<fractional<< 
endl; 
17 
cout << "letter: 
"<<letter<< 
endl ; 
(program continues) 

8 2 
Chapte r 3 
Expressions and Interactivity 
Program 3-4 
(continued) 
18 
return 
O; 
19 } 
Program Output with Example Input Shown in Bold 
Enter an integer
, a double, 
and a character: 
4 5 .7 b[Ent er] 
whole: 
4 
fractional: 
5.7 
letter: 
b 
Figure 3-1 
As you can see in the example output and in Figure 3-1, the values are stored in the 
order entered in their respective variab les. 
Keyboard buffer 
ci n begins 
~I .- 4- ,~l--~-
5-~--~-
7-~--~-
b-~I [_E_n_t _e_r ~] I 
reading here. ~ • 
This is stored 
in whole. 
This is stored 
in fractional. 
This is stored 
in letter. 
But what if the user had entered the values in the wrong order, as shown in the following 
samp le run? 
Program 3-4 Output with Different Example Input Shown in Bold 
Enter an integer
, a double, 
and a character: 
5.7 4 b[Ente r] 
whole: 5 
fractional: 
0.7 
letter: 
4 
Figure 3-2 
Because the data was not entered in the specified order, there is a complete mix-up of 
what value is stored for each variable. Figure 3-2 illustrates what happens . 
Keyboard buffer 
. b . 
I 5 I 
7 
4 
b 
l[ Enter]
I 
c, n egins 
~ 
'--,---
, -'-,-=.-=.-=.-=.-:_:-=.-=.-=.-=.
-:,...,_ __ 
...,_ __ 
...,_ __ 
_,_ __ 
_,_ __ 
__, 
reading here . .,.,,..-
' 
This is 
This is 
stored in 
stored in 
whole. 
fractional. 
This is 
stored in 
letter. 
This is left 
in the input 
buffer. 
The ci n statement on line 13 reads 5 for i nt variable whol e, .7 for double variable 
frac t ional , and 4 for char variab le letter. 
The character bis left in the input buffer. 

3.1 The ci n Object 
83 
For a program to function correctly, it is important that the user enter data values in 
the order the program expects to receive them and not enter a floating-point number 
when an integer is expected . 
~ 
Checkpoint 
3.1 
What header file must be included in programs using cin? 
3.2 
What is the>> symbol called? 
3.3 
Where does ci n read its input from? 
3.4 
Tru e or False: ci n requires the user to press the [Enter] key after entering data. 
3.5 
Assume value is an integer variab le. If the user enters 3 .14 in respon se to the 
following programming statement, what will be stored in value? 
cin >> value; 
3.6 
A program has the following variable definitions . 
long miles; 
int feet; 
double inches; 
Write a single ci n statement that reads a value into each of these variables. 
3. 7 
The following program will run, but the user will have difficulty understanding 
what to do. How wou ld you improve the program? 
// This program multiplies 
two numbers and displays 
the result. 
#include 
<iostream> 
usi ng namespace std; 
i nt main () 
{ 
} 
double first
, second, 
product; 
ci n >>first>> 
second; 
product= 
first* 
second; 
cout << product; 
return 
O; 
3.8 
Comp lete the following main function so that it asks for the user's weight (in 
pounds ) and displays the equivalent weight in kilograms . 
int main () 
{ 
double pounds , kil ograms; 
// Write a prompt to tel l the user to ente r his or her weight 
// i n pounds. 
// Write code here that 
reads in the user 's wei ght in pounds . 

84 
Chapter 3 
3.2 
a 
VideoNot e 
Evaluating 
Mathematical 
Expressions 
Expressions and Interactivity 
// The fo l lowing line does the conversion. 
kil ograms= pounds/ 
2 .2 ; 
// Write code here that displays 
t he user's 
weight in kilograms. 
re t ur n O; 
} 
Mathematical 
Expressions 
CONCEPT
: C++ allows you to construct complex mathematical expressions using 
multip le opera tor s and grouping symbols. 
In Chapter 2 you were introduced to the basic mathematica l operators, which are 
used to build mathematical expressions . An expression is something that can be 
eval uated to produce a single value. In programming , an arithmetic expression 
normally consists of an operator and its operands. Look at the following assignment 
statement: 
sum= 21 + 3; 
Since 21 + 3 can be evaluated to produce a value, it is an expression. This value, 24, is 
stored in the variable sum. However, expressions do not have to contain mathematica l 
operators. In the following statement 3 is an expression, which of course evaluates to 
the single value 3. 
number = 3; 
Here are some addit ional assignment statements where the variable result 
is being 
assigned the value of an expression . 
resul t = x · ' 
resul t = 4· ' 
resul t = 15 I 3· ' 
resul t = 22 * number; 
resul t = sizeof (i nt); 
resul t = a + b + c· ' 
In each of these statements, a number, variable name , or mathemat ical express ion 
appears on the right side of the = symbol. A value is obtained from each of these and 
stored in the variable result. These are all examples of a variable being assigned the 
value of an expression . 
Although some instructors prefer that you not perform mathematical operations within 
a cout statement, it is possible to do so. Program 3-5 illustrate s how to do this. 

3.2 Mathematical Expressions 
85 
Program 3-5 
1 // Thi s program displays 
the decimal 
value of a fraction. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
doub l e numerator, 
denominator; 
8 
9 
cout << "Thi s program shows the decimal 
value of a fract i on . \n"; 
10 
11 
12 
13 
14 
15 
16 
II Have 
cout << 
cin 
>> 
cout << 
cin 
>> 
the user enter 
the numerator 
and deno minator 
"Ente r the numerator: 
"; 
numerator; 
"Ente r the denominator: 
"; 
denomi nator; 
17 
// Compute and disp l ay the dec i mal value 
18 
cout << "The deci mal value 
is"<< 
(numera tor
/ denominator)<< 
endl ; 
19 
return 
O; 
20 ) 
Program Output with Example Input Shown in Bold 
This program shows the decimal 
value of a fraction. 
Enter the numerator: 
3[Ent er] 
Enter the denominator: 
16[Ent er] 
The decimal 
value is 0.1875 
0 
0 
T he cout object can display the value of any legal expression in C++. In Program 3-5 
the value of the expression numerator /d enomi nator is displayed . 
NOTE: 
Th e Program 3-5 example input shows the user ente ring 3 and 16. Because 
these values are assigned to double variables, they are stored as 3.0 and 16.0. 
NOTE: 
When sending an exp ression that includes an operator to cout , it is always 
a good idea to put parentheses around the expression . Some operators will yield 
unexpected results othe rwise . 
Operator Precedence 
It is possible to build mathematical expressions with several operators. T he following 
statement assigns the sum of 17, x, 21, and y to the variab le answer. 
answer= 
17 + x + 21 + y; 
Some expressions 
are not that straightforward
, however. Conside r the following 
statement: 
outcome= 
12 + 6 / 3; 

86 
Chapte r 3 
Expressions and Inte ractivity 
What value will be stored in out come? It could be assigned either 6 or 14, depending on 
whether the addition operation or the division operation takes place first. The answer 
is 14 because the division operator has higher precedence than the addition operator. 
This is exactly the same as the operator precedence found in algebra . 
Mathematical expressions are evaluated from left to right . However, when there are 
two operators and one has higher precedence than the other, it is done first. 
Mult iplication and division have higher precedence than addition and subtraction, so 
the example statement works like this: 
• First, 6 is divided by 3, yielding a result of 2. 
• Then, 12 is added to 2, yielding a result of 14. 
• Finally, 14 is stored in the out come variab le. 
These steps could be diagrammed in the following way: 
out come= 12 
+ 
6 / 3 
out come= 12 
+ 
2 
out come= 
14 
Table 3-1 shows the precedence of the arithmet ic operators. The operators at the top of 
the table have higher precedence than the ones below them. 
Table 3-1 Precedence of Arith metic Operators (Highest to Lowest) 
( ) 
* 
I 
+ 
% 
unary 
binary 
binary 
Expressions within parentheses are evaluated first 
Negation of a value, e.g., - 6 
Mult iplication, division, and modulus 
Addition and subtraction 
The multiplication, division, and modu lus operators have the same precedence . This is 
also true of the addition and subtraction operators . Table 3-2 shows some expressions 
with their values. 
Table 3-2 Some Expressions 
Expression 
5 + 2 * 4 
10 / 2 -
3 
8 + 12 * 2 - 4 
4 + 17 % 2 -
1 
6 -
3 * 2 + 7 -
1 
Value 
13 
2 
28 
4 
6 

3.2 Mathematical Expressions 
87 
Associativity 
Associativity is the order in which an operator works with its operands. Associativity 
is either left to right or right to left. The associativity of the division operato r is left to 
right, so it divides the operand on its left by the operand on its right. Table 3-3 shows 
the arithmetic operato rs and their associativity. 
Table 3-3 Associativity of Arithmetic Operators 
Operator 
Associativity 
(unary negat ion ) -
Right to left 
Left to right 
Left to right 
* 
I 
% 
+ 
Grouping with Parentheses 
Parts of a mathematical expression may be grouped with parentheses to force some 
operations to be performed before others . When a pair of parentheses is encountered, 
the expression inside the parentheses is evaluated before any expressions outside of it. 
Thus, in the following statement, a plus bis evaluated first. Then its sum is divided by 4. 
average
= (a+ b) / 4; 
Without the parentheses b would be divided by 4 before adding a to the result because 
the division operato r has a higher precedence than the addition operator. Table 3-4 
shows more expressions and their values. 
Table 3-4 More Arithmetic Expressions 
Expression 
(5 + 2) * 4 
10 / (5 -
3 ) 
8 + 12 * (6 -
2 ) 
(4 + 17 ) % 2 -
1 
(6 -
3) * (2 + 7) / 3 
Value 
28 
5 
56 
0 
9 
Converting Algebraic Expressions to Programming 
Statements 
In algebra it is not always necessary to use an operator for multiplication . C++, however, 
requires an operato r for any mathematica l operat ion. Table 3-5 shows some algebraic 
expressions that perform multiplication and the equivalent C++ expressions. 

88 
Chapter 3 
Expressions and Interactivity 
Table 3-5 Algebraic and C++ Multiplication 
Expressions 
Algebr aic Expression 
Operation 
C++ Equivalent 
6B 
(3)(12) 
4xy 
6 times B 
6 * B 
3 times 12 
3 * 12 
4 times x times y 
4 * X * y 
When converting some algebraic expressions to C++, you may have to insert 
parentheses that do not appear in the algebraic expression . For example, look at the 
following expression: 
a+b 
x =--
c 
To convert this to a C++ statement, a+ b will have to be enclosed in parenthese s so that 
a will be added to b before the sum is divided by c. 
x = (a + b) 
/ c; 
Table 3-6 shows more algebraic expressions and their C++ equivalents. 
Table 3-6 Algebraic and C++ Expressions 
Algebraic Expression 
C++ Expression 
y = 3:: 
2 
z = 3bc + 4 
3x + 2 
a = ---
4a - 1 
y = x I 2 * 3; 
Z = 3 * b * C + 4; 
a = (3 * x + 2 ) / (4 * a -
1 ) 
No Exponents Plea se! 
Unlike many programming languages , C++ does not have an exponent operator. 
Raising a number to a power requires the use of a library function . The C++ library 
isn't a place where you check out books , but a collection of specialized functions. 
Think of a library function as a "routine" that performs a specific operation. One of 
the library functions is called pow, and its purpose is to raise a number to a power. Here 
is an example of how it's used: 
area= 
pow(4.0 , 2); 
This statement contains a call to the pow function. The numbers inside the parentheses are 
arguments. Arguments are information being sent to the function. The pow function always 
raises the first argument to the power of the second argument . In this example, 4.0 is 
raised to the power of 2. The result is returned from the function and used in the statement 
where the function call appears . The pow function expects floating-point arguments . 

Figure 3-3 
Figure 3-4 
3.2 Mathematical Expressions 
89 
On some C++ compilers integer arguments will also work, but since many compilers 
require that at least the first argument be a double, that is the convention we use in this 
book . The value returned from the function is always a double number. In this case, 16.0 
is returned from pow and assigned to the variable area . This is illustrated in Figure 3-3. 
area= 
/f 
+----
pow(4.0, 
2); 
arguments 
16.0 
return value 
The statement area 
= pow(4.0, 
2) is equivalent to the following algebraic statement: 
area 
= 42 
Here is another example of a statement using the pow function . It assigns 3 times 63 to x: 
x = 3 * pow(6 .0, 3); 
And the following statement displays the value of 5 raised to the power of 4: 
cout 
<< pow(5 .0, 4); 
It might be helpful to think of pow as a "black box" that accepts two numbers and then 
sends a third number out. The number that comes out has the value of the first number 
raised to the power of the second number, as illustrated in Figure 3-4. 
Argument 1 
Argument 2 
Yx --L __ 
L xY 
___::nction 
I 
There are some guidelines that should be followed when the pow function is used. First, 
the program must include the cmath header file. Second, at least the first of the two 
arguments you pass to the function , if not both, should be a do uble . Third , because the 
pow function returns a double value, any variab le that value is assigned to should also 
be a double
. For example , in the following statement the variab le area should be 
defined as a dou bl e: 
area= 
pow(4.0, 
2 ); 
Program 3-6 solves a simple algebra ic problem . It asks the user to enter the radius of a 
circle and then calculates the area of the circle. The formula is 
area = 1tr2 

90 
Chapte r 3 
Expressions and Inte ractivity 
This is expressed in the program as 
area= 
3.14159 * pow(radius , 2); 
Program 3-6 
1 II Thi s program calculates 
the area of a circle. 
The formula for the 
2 II area of a circle 
i s PI times the rad i us squared. 
PI is 3 .14159. 
3 #include 
<iostream> 
4 #include 
<cmath> 
II Needed for the pow funct i on 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
double area, 
radius; 
10 
11 
cout << "Thi s program calculates 
the area of a ci rcle . \n"; 
12 
13 
II Get the radius 
14 
cout << "What is the radius 
of the circle?"; 
15 
cin 
>> rad i us; 
16 
17 
II Compute and display 
the area 
18 
area= 
3.14159 * pow(rad i us, 2); 
19 
cout << "The area i s•<< 
area<< 
endl; 
20 
return 
O; 
21 } 
Program Output with Example Input Shown in Bold 
This program calculates 
the area of a circle. 
What is the radius 
of the circle? 
lO[Enter] 
The area is 314.159 
0 
NOTE: 
Program 3-6 is presented as a demonstration of the pow function. In reality, 
there is no reason to use this function in such a simple operation. Line 18 could just 
as easily be written 
area= 
3.14159 *radius* 
radius; 
The pow function is useful , however, in operations that involve larger exponents. 
~ 
Checkpoint 
3.9 
In each of the following cases, tell which operator has higher precedence or 
whether they have the same precedence. 
A) +and* 
B) * and I 
C) I and% 

3.2 Mathematical Expressions 
91 
3.10 
Complete the following tab le by writing the value of each express ion in the 
Value column. 
Expressio n 
A) 6 + 3 ,. 5 
B) 12 / 2 - 4 
C) 9 + 14 ,,. 2 - 6 
D) 5 + 19 % 3 - 1 
E) (6 + 2) ,. 3 
F)14/(11-
4) 
G) 9 + 12 ,,. (8 - 3) 
H) (6 + 17) % 2 - 1 
I) ( 9 - 3) ,,. ( 6 + 9) / 3 
Value 
3 .11 
Write C++ exp ressions for the following algebraic expressions: 
y = 6x 
a = 2b + 4c 
y = x3 
x +2 
g = 
x2 
y = ~--z2 
3.12 
Study the following program code and then complete the table following it. 
double value1, 
value2, 
value3; 
cout 
<< "Ent er a number: "; 
ci n 
>> value1; 
value2 = 2 * pow(value1, 
2); 
value3 = 3 + value2 / 2 - 1; 
cout 
<< value3; 
H th e User Ent ers ... 
2 
5 
4.3 
6 
Th e Program Will Display What Number 
(Stored in val ue3)? 

92 
Chapte r 3 
3.3 
Expressions and Inte ractivity 
3.13 
Complete the following program skeleton so that it displays the volume of a 
cylindrical fuel tank . The formula for the volume of a cylinder is 
volume= 1tr2h 
where 
1t is 3.14159 
r is the radius of the tank 
h is the height of the tank 
#include 
<ios t ream> 
#include 
<cmat h> 
i nt mai n() 
I 
} 
double volume, rad i us, heig ht; 
cout << "This program will tell 
you t he volume of\ n"; 
cout << "a cyl i nder-shaped 
fuel t ank . \n"; 
cout << "How tall 
i s t he tank? "; 
ci n >> heig ht; 
cout << "What i s t he radius of the tank? "; 
ci n >> radius; 
II You must complete t he program . 
re t ur n O; 
Data Type Conversion and Type Casting 
CONCEPT: 
Sometimes it is necessary to convert a value fro m one data type to 
another. C++ provides ways to do this. 
If a floating -point value is assigned to an i nt variab le, what value will the variable 
receive? If an i nt is multiplied by a fl oat, what data type will the result be? What if a 
double is divided by an unsig ned int? Is there any way of predicting what will happen 
in these instances? The answer is yes. When an operator's operands are of different 
data types, C++ automatically converts them to the same data type. When it does this 
it follows a set of rules, and understanding these rules will help you prevent subtle 
errors from creeping into your programs . 
Just like officers in the military, data types are ranked . One numer ic data type outranks 
another if it can hold a larger number. For examp le, a fl oat outranks an in t and a 
double outranks a float . Tab le 3-7 lists the numer ic data types in order of their rank, 
from highest to lowest . 

3.3 Data Type Conversion and Type Casting 
93 
Table 3-7 Data Type Ranking 
long double 
double 
float 
unsigned 
long long i nt 
long long i nt 
unsigned 
long int 
long i nt 
unsigned 
i nt 
in t 
One exception to the ranking in Table 3-7 is when an i nt and a long in t are the same 
size. In that case, an unsigned int outranks a long int because it can hold a higher value. 
When C++ is working with an operator, it strives to convert the operands to the same 
type. This implicit, or automat ic, conversion is known as type coercion. When a value 
is converted to a higher data type, it is said to be promoted . To demote a value means 
to convert it to a lower data type. Let's look at the specific rules that govern the 
evaluation of mathematical expressions . 
Rule 1: char, short, and unsigned s hor t values are automatically promoted to i nt 
values . 
You will notice that char, s hor t , and unsigned 
shor t do not appear in Tab le 3-7. 
That's because anytime values of these data types are used in a mathemat ical expression, 
they are automat ically promoted to an i nt.' 
Rule 2: When an operator works with two values of different data types, the lower-ranking 
value is promoted to the type of the higher-ranking value. 
In the following expression, assume that years is an i nt variable and i nterestRa
t e is 
a double variable: 
years 
* i nterestRate 
Before the multiplicat ion takes place, the value in years will be promoted to a double . 
Rule 3: When the final value of an express ion is assigned to a variable, it will be converted 
to the data type of that variable . 
In the following statement, assume that area is a long i nt variable, while lengt h and 
wi dth are both i nt variables: 
area= 
leng t h * wi dth; 
• The only exception to this rule is when an unsigned 
short holds a value larger than can be 
held by an i nt . This can happen on systems where a shor t is the same size as an in t . In this 
case, the unsigned 
shor t is promoted to unsigned i nt 

94 
Chapte r 3 
Expressions and Inte ractivity 
Because the values stored in length and wi dth are the same data type, neither one will 
be converted to any other data type. The result of the multiplication, however, will be 
promoted to long so it can be stored in area. 
But what if the variable receiving the value is of a lower data type than the value it is 
receiving? In this case the value will be demoted to the type of the variable . If the 
variable's data type does not have enough storage space to hold the value, part of the 
value will be lost, and the variable could receive an inaccurate result . As mentioned in 
Chapter 2, if the variable receiving the value is an integer and the value being assigned 
to it is a floating-point number, the floating-point value will be truncated when it is 
converted to an i nt and stored in the variable. This means everything after the decimal 
point will be discarded . Here is an examp le: 
i nt X; 
double y = 3.75; 
X: 
y; 
II xis 
ass i gned 3 and y remains 3.75 
It is important to understand, however, that when the data type of a variable's value is 
changed, it does not affect the variable itself. For example, look at the following code 
segment . 
i nt quantity1 
= 6; 
double quant i t y2 = 3 . 7; 
double t ot al; 
total 
= quantity1 
+ quant i t y2; 
Before C++ performs the above addition, it moves a copy of quant i ty1 's value into its 
workspace and converts it to a double. So 6.0 and 3.7 are added, and the resulting 
value, 9.7, is stored in to t al. However, the variable quantity1 
remains an i nt , and 
the value stored there in memory is untouched. It is still the integer 6. 
Type Casting 
Sometimes programmers want to change the data type of a value explicitly themselves. 
This can be done by using a type cast expression . A type cast expression lets you 
manually promote or demote a value. Its general format is 
stat i c_cast<DataType>(Value) 
where Value is a variable or literal value that you wish to convert and Data Type is the data 
type you wish to convert it to. Here is an example of code that uses a type cast expression: 
double number= 
3.7; 
i nt val; 
val = st at ic _cast<i nt >(number); 
This code defines two variables: number, a double, and val , an in t . The type cast 
expression in the third statement returns a copy of the value in number, converted to an 
i nt. When a double or float is converted to an i nt , the fractiona l part is truncated, 
so this statement stores 3 in val. The value of number, 3. 7, is not changed. 
Type cast expressions are useful in situat ions where C++ will not perform the desired 
conversion automatically. 

3.3 Data Type Conversion and Type Casting 
95 
Program 3-7 shows an example where a type cast express ion is used to prevent integer 
division from taking place. Th e statement that uses the type cast expression is 
booksPerMonth = static
_cast<double>(books) 
/ months; 
Program 3-7 
1 // Thi s program uses a type cast 
to avo i d an integer 
di vi sion. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
int 
books, 
8 
months; 
9 
double booksPerMonth ; 
10 
11 
// Get user inputs 
12 
cout << "How many books do you plan to read?"; 
13 
cin 
>> books; 
14 
cout << "How many months wi ll it take you to read them?"; 
15 
cin 
>> months; 
16 
17 
// Compute and display 
books read per month 
18 
booksPerMonth = stat i c_cast<double>(books
) / months; 
19 
cout << "That is"<< 
booksPerMonth <<" 
books per month.\n"; 
20 
return 
O; 
21 } 
Program Output with Example Input Shown in Bold 
How many books do you plan to read? 30[Ent er] 
How many months will 
it take you to read them? 7[Enter] 
That is 4.28571 books per month. 
CD 
Th e variable books is an integer, but a copy of its value is converted to a double before 
it is used in the division operat ion . Without the type cast expression in line 18, integer 
division would have been performed, resulting in an incorrect answer. 
It is important 
to note that if we had written line 18 as shown in the following 
statement, integer division would still have occurred . 
booksPerMonth = static
_cast<double>(books 
/ months); 
Because operations inside parentheses are done before other ope rations, the division 
operator would perform integer division on its two integer operands, and the result of 
the expression books 
I months would be 4. The 4 would then be converted to the 
double value 4.0, and this would be the value assigned to booksPerMonth. 
WARNING! 
To prevent the integer division from taking place, one of the 
operands shou ld be converted to a double prior to the division operation. Thi s 
forces C++ to automatically convert the value of the other operand to a double. 

96 
Chapter 3 
Expressions and Interactivity 
Program 3-8 shows another use of a type cast. 
Program 3-8 
1 II Thi s program prints 
a character 
from its 
ASCII code. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
int number= 65 ; 
8 
9 
II Display the value of the number variable 
10 
cout << number << endl ; 
11 
12 
II Use a type cast to display 
the value of number 
13 
II converted 
to the char data type 
14 
cout << static
_cast<char>(number) 
<< endl; 
15 
return 
O; 
16 } 
Program Output 
65 
A 
<) 
Let's take a closer look at this program. In line 7 the i nt variable number is initialized 
with the value 65. In line 10, number is sent to cout , causing 65 to be displayed. In line 
14, a type cast expression is used to convert the value in number to the char data type 
before sending it to cout. Recall from Chapte r 2 that characters are stored in memory 
as integer ASCII codes . Because the number 65 is the ASCII code for the letter 'A', the 
statement on line 14 causes the letter 'A' to be displayed . 
NOTE: C++ provides several different type cast expressions . A stati c_cast is the 
most commonly used type cast expression, so it is the one we will primarily use in 
this book . Additional information on type casts is contained in Appendix K on this 
book's compan ion website at pearsonhighered.com/gaddis. 
C-style and Prestandard C++ Type Cast Expressions 
Even though the stat i c_cast is the preferred type cast expression in use today, C++ 
also supports two older forms that you should know about: the C-style form and the 
prestandard C++ form. Th e C-style cast places the data type to be converted to, enclosed 
in parentheses, in front of the operand whose value is to be converted. Because the type 
cast operato r precedes the operand, this type cast notation is called prefix notation. 
Here is an example . 
booksPerMonth = (double )books I months; 
The prestandard C++ form of the type cast expression also places the data type to be 
converted to before the ope rand whose value is to be converted, but it places the 

3.3 Data Type Conversion and Type Casting 
97 
parentheses aro und the operand rather than around the data type. This typecast 
notation is called functional notatio n. Here is an example . 
booksPerMonth = double (books ) / months; 
~ 
Checkpoint 
3.14 
Assume the following variable definitions: 
i nt a= 
5 , b = 12 ; 
double x = 3 .4, 
z = 9. 1; 
What are the values of the following expressions? 
A) 
b / a 
B) x * a 
C) static
_cast<double>(b 
/ a) 
D) static
_cast<double>(b) 
/ a 
E) b / static
_cast<double>(a) 
F) static
_cast<double>(b) 
/ stat i c_cast<do uble>( a ) 
G) b / static
_cast< i nt>(x) 
H) static
_cast< i nt>(x) 
* static
_cast<int>(z) 
I) 
stat i c_cast< i nt> ( x * z ) 
J) static
_cast<double>(static
_cast<int>(x) 
* stat i c_cast<int>
(z)) 
3.15 
What will the following program code display if a capita l B is entered when the 
ci n statement asks the user to input a letter? 
char letter
; 
cout << "The ASCII values 
of uppercase 
letters 
are 
" 
<< static
_cast< i nt>('A') 
<< " 
" 
<< static
_cast< i nt>('Z') 
<< end l; 
cout << "The ASCII values 
of lowercase 
letters 
<< static
_cast< i nt>('a') 
<< " 
" 
<< static
_cast< i nt>('z') 
<< end l << endl; 
cout << "Ent er a l ette r and I will 
tell 
you 
cin 
>> le tte r; 
cout << "The ASCII code for 
" << letter 
<< 
<< static
_cast< i nt>(letter) 
<< endl ; 
3.16 
What will the following program code display? 
int 
integer1 
= 19 , 
integer2 
= 2; 
double doubleVal; 
doubleVal 
= integer1 
/ i nteger2; 
cout << doubleVa l << endl; 
its 
" is 
are 
" 
ASCII 
" 
doubleVal 
= static
_cast<double>(
i nteger1) 
/ integer2; 
cout << doub l eVal << endl; 
doubleVal 
= static
_cast<double>(
i nteger1 
/ i nteger2); 
cout << doubl eVal << endl; 
code: 
". 
' 

98 
Chapter 3 
3.4 
Expressions and Interactivity 
Overflow and Underflow 
CONCEPT: 
When a value cannot fit in the numb er of bits provid ed by a variable's 
data type, overflow or underflow occurs. 
Just as a bucket will overflow if you try to put more water in it than it can hold, a 
variable will experience a similar problem if you try to store a value in it that requires 
more bits than it has availab le. Let's look at an example . Suppose a short 
i nt that 
uses 2 bytes of memory has the following value stored in it. 
This is the binary representation of 32,767, the largest value that will fit in this data type. 
Without going into the details of how negative numbers are stored, it is helpful to 
understand that for integer data types that store both positive and negative numbers, a 
number with a O in the high-order (i.e., leftmost) bit is interpreted as a positive number, 
and a number with a 1 in the high-order bit is interpreted as a negative number. If 1 is 
added to the value stored above, the variable will now be holding the following bit pattern. 
111010101010101010101010101010101 
But this is not 32,768. Instead, it is interpreted as a negative number, which was not 
what was intended. A binary 1 has "flowed" into the high bit position . This is called 
overflow. 
Likewise, when an integer variable is holding the value at the far end of its data type's 
negative range and 1 is subtracted from it, the 1 in its high-order bit will become a 0, 
and the result ing number will be interpreted as a positive number. This is another 
example of overflow . 
In addition to overflow , floating -point values can also experience und erflow. This 
occurs when a value is too close to zero, so small that more digits of precision are 
needed to express it than can be stored in the variable holding it. Program 3-9 illustrates 
both overflow and underflow. 
Program 3-9 
1 II This program demonstrates 
overflow and underflow. 
2 #i nclude <ios t ream> 
3 usi ng namespace std; 
4 
5 i nt mai n() 
6 { 
7 
II Set i ntVar to t he maximum value a shor t in t can hold 
8 
short i ntVar = 32767; 
9 
10 
11 
II Set floatVar 
t o a number too small to fit 
i n a float 
float 
floatVar 
= 3.0E-47; 
(program continues) 

3.5 Named Constants 
99 
Program 3-9 
12 
(continued) 
13 
II Di splay i ntVar 
14 
15 
cout << "Ori ginal 
value of intVar 
• << intVar 
<< endl ; 
16 
II Add 1 to intVar to make it overflow 
17 
18 
19 
i ntVar = intVar 
+ 1; 
cout << • i ntVar after 
over fl ow 
• << intVar 
<< endl ; 
20 
II Subtract 
1 from intVar 
to make it overflow 
again 
21 
22 
23 
i ntVar = intVar -
1; 
cout << • i ntVar after 
2nd over fl ow 
• << i ntVar << endl ; 
24 
II Di splay floatVar 
25 
cout << "Value of very t i ny fl oat Var 
• << fl oat Var; 
26 
return 
O} 
27 } 
Program Output 
Original 
value of intVar 
intVar after 
overflow 
32767 
- 32768 
intVar after 
2nd overflow 
32767 
Value of very tiny floatVar 
0 
3.5 
Although some systems display an error message when an overflow or underflow 
occurs, most do not. The variable simply holds an incorrect value now and the program 
keeps running. Therefore, it is important to select a data type for each variable that has 
enough bits to hold the values you will store in it. 
Named Constants 
CONCEPT: 
Literals may be given names that symbolically represen t them in a 
program. 
In Chapter 2 you learned that values that will not change when a program runs can be 
stored as literals. However, sometimes this is not ideal. For example, assume the following 
statement appears in a banking program that calculates data pertaining to loans: 
amount= 
balance* 
0 .069; 
In such a program, two potential problems arise. First, it is not clear to anyone other 
than the original programmer what 0.069 is. It appears to be an interest rate, but in 
some situati ons there are fees associated with loan payments. How can the purpose 
of this statement be determined without painstaking ly checking the rest of the 
program? 

100 
Chapte r 3 
Expressions and Inte ractivity 
The second problem occurs if this number is used in other calculations throughout the 
program and must be changed periodically. Assuming the number is an interest rate, 
what if the rate changes from 6.9 percent to 7.2 percent? The programmer will have to 
search through the source code for every occurrence of the number. 
Both of these problems can be addressed by using named constants. A named constant, 
also called a constant variable, is like a variable, but its content is read-only and cannot 
be changed while the program is running . Here is a definition of a named constant: 
const double INTEREST_RATE = 0.069; 
It looks just like a regular variable definition except that the word con st appears before 
the data type name. The key word const is a qualifier that tells the compiler to make 
the variable read-only. This ensures that its value will remain constant throughout the 
program's execution. If any statement in the program attempts to change its value, an 
error results when the program is compiled. A named constant can have any legal C++ 
identifier name, but many programmers use all uppercase letters in the name, as we 
have done here, to distinguish it from a regular variable . 
When a named constant is defined, it must be initialized with a value. It cannot be 
defined and then later assigned a value with an assignment statement . 
const double INTEREST_RATE; 
INTEREST_RATE = 0.069; 
/ / i 11 egal 
/ / i 11 egal 
An added advantage of using named constants is that they make programs more 
self-documenting. Once the named constant INTEREST_RATE has been correctly defined, 
the program statement 
newAmount =balanc e * 0.069; 
can be changed to read 
newAmount =balanc e * INTEREST_RATE; 
A new programmer can read the second statement and better understand what is 
happening . It is evident that balanc e is being multiplied by the interest rate. Another 
advantage to this approach is that widespread changes can easily be made to the 
program. Let's say the interest rate appears in a dozen different statements throughout 
the program. If the rate changes, the initialization value in the definition of the named 
constant is the only value that needs to be modified. If the rate increases to 7.2 percent, 
the definition is simply changed to the following: 
const double INTEREST_RATE = 0.072; 
The program is then ready to be recompiled . Every statement that uses INTEREST_RATE 
will use the new value. 
Named constants can also help prevent typographica l errors in a program's code. For 
example, suppose you use the number 3.14159 as the value of PI in a program that 
performs various geometric calculations. Each time you type the number 3.14159 in 
the program's code, there is a chance that you will make a mistake with one or more of 
the digits. To help prevent a mistake such as this, you can define a named constant for 
PI, initialized with the number of decimal places you want depending on the required 
precision. Then you can use that constant in all of the formulas that require its value. 

3.5 Named Constants 
101 
Program 3-10, which calculates the area of a circle, uses a named constant. It is defined 
on line 9 and used on line 19. 
Program 3-10 
1 II Thi s program calculates 
the area of a circle. 
The formula for the 
2 II area of a ci rcle 
is PI t i mes the radius 
squared. 
PI i s 3.14159. 
3 #i nclude <i ostream> 
4 #i nclude <cmath> 
5 using namespace std; 
6 
7 int main () 
8 { 
9 
const double PI= 
3.14159; 
10 
double area , radius; 
11 
II Needed for the pow function 
II PI is a named constant 
12 
cout << "Thi s program calculates 
the area of a circle.\n"; 
13 
14 
II Get the radius 
15 
cout << "What is the radius 
of the circle?"; 
16 
cin 
>> rad i us; 
17 
18 
II Compute and display 
the area 
19 
area= 
PI* 
pow(rad i us, 2) ; 
20 
cout << "The area is•<< 
area<< 
endl ; 
21 
return 
O; 
22 } 
Program Output with Example Input Shown in Bold 
This program calculates 
the area of a circle. 
What is the radius 
of the circle? 
10 .0[Ent er] 
The area is 314.159 
~ 
Checkpoint 
3.17 
Write statements using the const qualifier to create named constants for the 
following literal values: 
Constant Value 
Description 
2. 71828 
Euler's number (known in mathematics as e) 
5. 256E5 
Number of minutes in a year 
32. 2 
The gravitational acceleration constant (in feet per second2) 
9. 8 
The gravitational acceleration constant (in meters per second2) 
1609 
Number of meters in a mile 

102 
Chapte r 3 
a 
VideoNot e 
Combin ed 
Assignment 
Operators 
Expressions and Inte ractivity 
3.18 
Complete the following program code segment so that it properly converts a 
speed entered in miles per hour to feet per second . One mile per hour is 
1.467 feet per second . 
// Defi ne a named cons t ant call ed CONVERSION
, whose value i s 1.467. 
double mil esPerHour, 
fee t PerSecond; 
cout << "This progra m conver t s mi les per hour to\ n"; 
cout << "feet 
per second . \n"; 
cout << "Ent er a spe ed i n MPH: "; 
ci n 
>> milesPerHour; 
// Insert 
a mathematical 
st at ement here to 
// calculate 
feet 
per second and ass i gn the result 
// to the fee t PerSecond variable. 
cout << "That is"<< 
feetPerSecond 
<<" feet 
per second . \ n"; 
Multiple and Combined Assignment 
CONCEPT: 
Multipl e assignment means to assign the same value to several varia bles 
with one statement. 
C++ allows you to assign a value to mult iple variab les at once . If a program has severa l 
variables, such as a, b, c, and d, and each variable needs to be assigned the same value, 
such as 12, the following statement may be written: 
a= 
b = C = d = 12; 
The value 12 will be assigned to each variable listed in the statement . This works 
because the assignment operations are carried out from right to left. First 12 is assigned 
to d. Then d's value, now a 12, is assigned to c. Then e's value is assigned to b, and 
finally b's value is assigned to a. 
Here is another example. After this statement executes, both st ore 1 and st ore2 will 
hold the same value as begi nv. 
store1 
= store2 
= beginv; 
Combined Assignment 
Operators 
Quite often programs have assignment statements of the following form: 
number= number+ 
1; 
The expression on the right side of the assignment operator gives the value of number 
plus 1. The result is then assigned to number, replacing the value previously stored 
there. Effectively, this statement adds 1 to number. In a similar fashion, the following 
statement subtracts 5 from number. 
number= number - 5; 

3.6 Multiple and Combined Assignment 
103 
If you have never seen this type of statement before, it might cause some initia l confusion 
because the same variable name appears on both sides of the assignment operator. 
Table 3-8 shows other examp les of statements written this way . 
Table 3-8 Assignment State ments that Change a Variable's Value (Assume x = 6) 
Stat ement 
X : 
X + 4; 
X = X -
3; 
X = X * 10; 
X = X I 2 · ' 
X : 
X % 4 
Value of x 
What It Doe s 
After the Statement 
Adds 4 to x 
10 
Subtracts 3 from x 
3 
Multiplies x by 10 
60 
Divides x by 2 
3 
Makes x the remainder of x / 4 
2 
Because these types of operat ions are so common in programming , C++ offers a special set 
of operators designed specifically for these jobs . Table 3-9 shows the combined assignment 
operators, also known as compound operators or arithmetic assignment operators. 
Table 3-9 Comb ined Assignment Operato rs 
Operator 
Example Usage 
Equivalent To 
+= 
= 
*= 
I= 
%= 
X += 5 · ' 
y -= 2 · ' 
z *= 10; 
a I= b· ' 
C %= 3; 
X = X + 5 ; 
y = y -
2 ; 
z = z * 10; 
a= 
a I b; 
C = C % 3; 
As you can see, the combined assignment operators do not require the programmer to 
type the variable name twice. 
Program 3-11 uses both a multiple assignment statement and a combined assignment 
operator. 
Program 3-11 
1 II This program tracks 
the inventory 
of two widget 
stores. 
2 II 
It i l lustrates 
the use of multiple 
and combined assignment. 
3 #include 
<io stream> 
4 using namespace 
std; 
5 
(program continues) 

104 
Chapte r 3 
Expressions and Interactivity 
Program 3-11 
6 
7 
8 
9 
10 
11 
12 
int mai n() 
{ 
i nt beglnv, 
sold, 
store1, 
store2; 
(continued) 
II Beginning 
II Number of 
II Store 1 's 
II Store 2's 
inventory 
for both stores 
wi dgets sold 
i nventory 
inventory 
13 
// Get the beginning 
inventory 
for the two stores 
14 
cout << "One week ago, 2 new wi dget stores 
opened\n"; 
15 
cout << "at the same t i me with the same begi nning\n"; 
16 
cout <<" i nventory . What was the beginn i ng i nventory?"· 
17 
cin 
>> beglnv; 
18 
19 
// Set each store's 
inventory 
20 
store1 
= store2 
= beglnv; 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
II Get the number of wi dgets sold at each store 
cout << "How many widgets 
has store 
1 sold? 
". 
' 
cin 
>> sold; 
store1 
- = sold; 
// Adjust 
store 
1 's inventory 
cout << "How many widgets 
has store 
2 sold? 
". 
' 
cin 
>> sold; 
store2 
- = sold; 
// Adjust 
store 
2's 
inventory 
31 
// Display 
each store's 
current 
inventory 
32 
cout << "\nThe current 
inventory 
of each store:\n"; 
33 
cout << "Store 
1: "<< 
store1 
<< endl; 
34 
cout << "Store 
2: "<< 
store2 
<< endl; 
35 
return 
O; 
36 } 
Program Output with Example Input Shown in Bold 
One week ago, 2 new widget stores 
opened 
at the same time with the same beginning 
inventory. 
What was the beginning 
inventory? 
lOO[Enter] 
How many widgets 
has store 
1 sold? 2S[Enter] 
How many widgets 
has store 
2 sold? 
lS[Enter] 
The current 
inventory 
of each store: 
Store 
1: 75 
Store 2: 85 
More elaborate statements may be expressed with the combined assignment operators. 
Here is an examp le: 
result*= 
a+ 
5; 
In this statement, result 
is multiplied by the sum of a + 5. Notice that the precedence 
of the combined assignment operators is lower than that of the regular arithmetic 
operators, so the above statement is equivalent to 
result= 
result* 
(a+ 
5); 

3.6 Mu ltiple and Combined Assignment 
105 
Table 3-10 shows additional examples using combined assignment operato rs. 
Table 3-10 
Examples Using Combined Assignment Operators and Arithmetic Operators 
Example Usage 
X += b + 5; 
y - =a* 
2; 
z *= 10 - c ; 
a I= b + c; 
C %= d -
3; 
Equivalent to 
X = X + (b + 5); 
y = y -
(a * 2 ); 
z = z * (10 - c); 
a = a I (b + c ); 
C = C % (d -
3); 
~ 
Checkpoint 
3.19 
Write a multiple assignment statement that assigns Oto the variables total, 
subtotal, 
tax, and sh i pping. 
3 .20 Write statements using combined assignment operato rs to perform the following: 
A) Add 6 to x . 
B) Subtract 4 from amount . 
C) Multiply y by 4. 
D) Divide total 
by 27. 
E) Store in x the remainder of x divided by 7. 
F) Add y * 5 to x . 
G) Subtract discount times 4 from total
. 
H) Multiply i ncrease by salesRep times 5. 
I) 
Divide profit 
by shares minus 1000. 
3.21 
What will the following program segment display? 
i nt unus , duo, tres; 
unus =duo= 
t res = 5 ; 
unus += 4; 
duo *= 2 ; 
tres 
- = 4; 
unus /= 3; 
duo+= 
t res; 
cout << unus << endl <<duo<< 
endl << t res << endl; 

106 
Chapte r 3 
Expressions and Inte ractivity 
3.7 
Formatting Output 
CONCEPT: 
cout provides ways to format data as it is being displayed. Thi s affects 
the way da ta appears on the screen. 
The same data can be printed or displayed in several different ways. For example, all of 
the following numbers have the same value, although they look different: 
720 
720.0 
720.00000000 
7.2e+2 
+720.0 
The way a value is printed is called its formatting. The cout object has a standard way 
of formatt ing variables of each data type. Sometimes, however, you need more contro l 
over the way data is displayed . Consider Program 3-12, for example, which displays 
three rows of numbers with spaces between each one . 
Program 3-12 
1 II This program displays 
three 
rows of numbers. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 
6 
7 
8 
9 
10 
int 
{ 
main() 
i nt num1 = 2897, 
num4 = 34, 
num7 = 390, 
num2 = 5, 
num3 
num5 = 7, 
num6 
num8 = 3456, num9 
11 
II Display 
the first 
row of numbers 
= 837, 
= 1623 , 
= 12 ; 
12 
cout << num1 <<" 
"<< num2 <<" 
"<< 
num3 << endl; 
13 
14 
II Display 
the second row of numbers 
15 
cout << num4 <<" 
"<< num5 <<" 
"<< 
num6 << endl; 
16 
17 
II Display 
the th i rd row of numbers 
18 
cout << num7 <<" 
"<< num8 <<" 
"<< 
num9 << endl; 
19 
20 
return 
O; 
21 } 
Program Output 
2897 
5 
837 
34 
7 
1623 
390 
3456 
12 

3.7 Formatting Output 
107 
Unfortunately, the numbers do not line up in columns. Thi s is because some of the 
numbers, such as 5 and 7, occupy one position on the screen, while others occupy two 
or three positions. cout uses just the number of spaces needed to print each number. 
To remedy this, cout offers a way of specifying the minimum number of spaces to use 
for each number. A stream manipulator, setw, can be used to establish print fields of a 
specified width . Here is an examp le of how it is used: 
value= 
23; 
cout << setw(5) << value; 
The number inside the parentheses after the word setw specifies the field width for the 
value immediately following it. The field width is the minimum number of character 
positions, or spaces, on the screen to print the value in. In our example, the number 23 
will be displayed in a field of five spaces . 
To further clarify how this works, look at the following statements: 
value= 
23; 
cout << "(" << setw(5) <<value<<")"; 
This will produce the following output: 
23) 
Notice that the number occupies the last two positions in the field. Since the number 
did not use the entire field, cout filled the extra three positions with blank spaces . 
Because the number appears on the right side of the field with blank spaces "padd ing" 
it in front, it is said to be right-justified. 
Program 3-13 shows how the numbers in Program 3-12 can be printed in columns that 
line up perfectly by using setw. In addition, because the program uses setw(6), and the 
largest number has four digits, the numbers will be separated without having to print a 
string literal containing blanks between the numbers. 
Program 3-13 
1 II Thi s program uses setw to display 
three rows of numbers so they al i gn . 
2 #i nclude <iostream> 
3 #i nclude <iomanip> 
4 usi ng namespace std; 
5 
6 
7 
8 
9 
10 
11 
int main() 
{ 
i nt num1 
num4 
num7 
= 2897, 
= 34, 
= 390, 
II Header fi l e needed to use setw 
num2 = 5, 
num3 = 837, 
num5 = 7, 
num6 = 1623, 
num8 = 3456, num9 = 12; 
II Display the first 
row of numbers 
12 
13 
14 
cout << setw(6) << num1 << setw (6) << num2 << setw (6) << num3 << endl; 
15 
16 
17 
II Display the second row of numbers 
cout << setw(6) << num4 << setw (6) << num5 << setw (6) << num6 << endl; 
(program continues) 

108 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-13 
(continued) 
18 
II Display 
the th i rd row of numbers 
19 
cout << setw(6) 
<< num7 << setw(6) 
<< num8 << setw(6) 
<< num9 << endl; 
20 
21 
return 
O; 
22 } 
Program Output 
2897 
5 
837 
34 
7 
1623 
390 
3456 
12 
0 
NOTE: 
A new header file, iomanip, is named in the #include 
directive on line 3 
of Program 3-13. This file must be included in any program that uses setw. 
Notice that a setw manipulator 
is used with each value. This is because setw only 
estab lishes a field width for the value immediately following it. After that value is 
printed, cout goes back to its default method of printing. 
You might wonder what will happen if the number is too large to fit in the field, as in 
the following statement: 
value= 
18397 ; 
cout << setw(2) 
<< value; 
In cases like this , cout will print the entire number because setw only specifies the 
minimum number of positions in the print field. Any number requiring a larger field 
than the specified minimum will cause cout to overr ide the setw value . 
You may specify the field width for any type of data. Program 3-14 shows setw being 
used with an integer , a floating -point number, and a string 
object. 
Program 3-14 
1 II This program demonstrates 
the setw manipu lator 
2 II being used with variables 
of various 
data types . 
3 #include 
<i ostream> 
II Header file 
needed to use setw 
4 #include 
<i omanip> 
5 #include 
<string> 
II Header file 
needed to use string 
objects 
6 using namespace std; 
7 
8 int mai n() 
9 { 
10 
int 
intValue 
= 3928; 
11 
double doubleValue 
= 91 .5; 
12 
str i ng stringValue 
= "Jill 
Q. Jones"; 
13 
(program continues) 

Program 3-14 
14 
cout << II 
( 
II 
15 
cout << II 
( 
II 
16 
cout << II 
( 
II 
17 
return 
O; 
18 ) 
Program Output 
( 3928) 
( 
91 . 5) 
( 
Jill 
a. Jones) 
(continued) 
<< setw(5) 
<< intValue 
<< ")" 
<< endl ; 
<< setw(8) 
<< doubleValue 
<< 
II 
) 
II << endl ; 
<< setw(16) 
<< stringVal
ue << 
II 
) 
II << endl ; 
Program 3-14 illustrates a numbe r of important points: 
3.7 Formatting Output 
109 
• Th e field width of a floating -point number includes a position for the decimal 
point. 
• Th e field width of a string include s all characters in the string, includ ing spaces . 
• Th e value printed in the field is right -justified by default. Th is means it is aligned 
with the right side of the print field, and any blanks that must be used to pad it 
are inserted in front of the value. 
The setpreci 
si on Manipulator 
Floating -point values may be rounded to a number of significant digits, or precision, 
which is the total number of digits that appear before and after the decimal point. You 
can control the number of sign ificant digits with wh ich floating-point 
values are 
displayed by using the setprecision 
manipulator. Program 3-15 shows the results of 
a division operat ion displayed with different number s of significant digits. 
Program 3-15 
1 // 
This program demonstrates 
how the setprecision 
manipulator 
2 // affects 
the way a float i ng-point 
value 
is displayed. 
3 #i nclude <iostream> 
4 #i nclude <iomanip> 
// Header fi l e needed to use setprec
isio n 
5 usi ng namespace std; 
6 
7 int main () 
8 { 
9 
double , number1 = 132.364 , number2 = 26.91 ; 
10 
double quotient= 
number1 / number2; 
11 
12 
13 
14 
15 
16 
17 
18 
19 ) 
cout << quotient 
<< end l; 
cout << setprec
i sion (5) << quotient 
cout << setprec
i sion (4) << quotient 
cout << setprec
i sion (3) << quotient 
cout << setprec
i sion (2) << quotient 
cout << setprec
i sion (1) << quotient 
return 
O; 
<< end l; 
<< end l; 
<< end l; 
<< end l; 
<< end l; 
(program continues) 

110 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-15 
Program Output 
4.91877 
(continued) 
4.9188 
4.919 
4.92 
4.9 
5 
0 
Table 3-11 
Number 
28 .92786 
21 .40 
109.50 
34.78596 
NOTE: 
With prestandard comp ilers, your output may be different from that 
shown in Program 3-15. 
Th e first value in Program 3-15 is displayed in line 12 without the setprec
i si on 
manipulator. (By default, the system displays floating-point values with six significant 
digits.) Th e subsequent cout statements print the same value, but rounded to five, four, 
three, two, and one significant digits . Notice that , unlike setw, setpreci sion does not 
count the decimal point. When we used setprecis
i on(5) , for example, the output 
conta ined five significant digits, which required six positions to print 4.9188 . 
If the value of a number is expressed in fewer digits of precision than specified by 
setprecision, 
the manipulator will have no effect. In the following statements, the 
value of do 11 ars only has four digits of precision , so the number printed by both cout 
statements is 24 .51. 
double dollars= 
24.51; 
cout <<dollars<< 
endl; 
cout << setprec i si on(5) <<dollars<< 
endl; 
// di splays 24.51 
// di splays 24.51 
Table 3-11 shows how setprec i sion affects the way various values are displayed . Notice 
that when fewer digits are to be displayed than the number holds, setprec i s ion rounds, 
rather than truncates , the number. Notice also that trailing zeros are omitted . Therefore, 
for example, 21.40 displays as 21.4 even though setpreci si on (5) is specified. 
The setpreci 
si on Manipulato r 
Mani pulator 
Value Displayed 
setprecision(3) 
28.9 
setprecision(5) 
21 .4 
setprecision(4) 
109.5 
setprecision(2) 
35 
Unlike field width, the precision setting remains in effect until it is changed to some 
other value. As with all formatting manipulators , you must include the header file 
iomanip to use setprecision. 

3.7 Formatting Output 
111 
Program 3-16 shows how the setw and setprec
i s i on manipulators may be combined 
to contro l the way floating-point numbers are displayed . 
Program 3-16 
1 II Thi s program asks for sales 
figures 
for three 
days . 
2 II The total 
sales 
are calculated 
and displayed 
in a table
. 
3 #include 
<iostream> 
4 #include 
<i omanip> 
5 using namespace std; 
II Header file 
needed to use stream manip ulators 
6 
int main () 
{ 
7 
8 
9 
double day1, day2, day3, total; 
II Get the sales 
for each day 
10 
11 
12 
13 
14 
15 
16 
17 
18 
cout << "Enter the sales 
for day 
cin 
>> day1; 
cout << "Enter the sales 
for day 
cin 
>> day2; 
cout << "Enter the sales 
for day 
cin 
>> day3; 
19 
II Calculate 
total 
sales 
20 
total= 
day1 + day2 + day3; 
21 
22 
II Display 
the sales 
f i gures 
23 
cout << "\nSales 
Figures\n"; 
cout << • -------------
\n''; 
cout << setprec
i sion(5); 
cout << "Day 1 : • << setw(8) 
<< 
cout << "Day 2: • << setw(8) 
<< 
cout << "Day 3: • << setw(8) 
<< 
1 : .. 
' 
2: .. 
' 
3: .. 
' 
day1 << endl; 
day2 << endl; 
day3 << endl; 
24 
25 
26 
27 
28 
29 
30 
31 
cout << "Total : • << setw(8) 
<< total 
<< endl; 
return 
O; 
} 
Program Output with Example Input Shown in Bold 
Enter the sales 
Enter the sales 
Enter the sales 
Sales Figures 
.................................. 
Day 1: 
Day 2: 
Day 3: 
Total: 
321.57 
269.6 
307 
898.17 
for day 1 : 321 .S7[Enter] 
for day 2: 269 .60[Enter] 
for day 3: 307 .00 [Enter] 

112 
Chapte r 3 
Expressions and Inte ractivity 
T he output created by Program 3-16, as we directed, allows a maximum of five 
significant digits to be displayed and is printed right justified in a field width of eight 
characters. However, the result is clearly not what is desired . Let's look at another 
manipulator that fixes the problem . 
The fi xed Manipulator 
If a number is too large to print using the number of digits specified with setpreci si on, 
many systems print it in scientific notation . For examp le, here is the output of Program 
3-16 with larger numbers being input. 
Enter the sales 
for day 1 : 1456 78 .99[Ent er] 
Enter the sales 
for day 2: 205614 .85(Ent er] 
Enter the sales 
for day 3: 198645 .22[Ent er] 
Sales Figures 
Day 1 : 1.4568e+005 
Day 2: 2.0561e+005 
Day 3: 1.9865e+005 
Total: 
5.4994e+005 
To prevent this, you can use another stream manipulator , fixed , which indicates that 
floating -point output should be printed in fixed-point, or decimal, notation. 
cout << fixed; 
What is perhaps most important 
about the f i xed manipulator, 
however , is that 
when it is used in conjunction with the setpreci 
s ion man ipulator se t preci si on 
behaves in a new way . It specifies the number of digits to be displayed after the 
decima l point of a floating -point number, rather than the total number of digits to 
be displayed . This is usually what we want . For example, if we rewrite line 25 of 
Program 3-16 as 
cout <<fixed<< 
setprecision(2); 
and rerun the program using the same sample data, we get the following result s: 
Enter the sales 
for day 1 : 321 .57 [Ent er] 
Enter the sales 
for day 2: 269 .60[Ent er] 
Enter the sales 
for day 3: 307.00[Ent er] 
Sales Figures 
----- --------
Day 1 : 
321 .57 
Day 2: 
269.60 
Day 3: 
307.00 
Total: 
898 .17 
By using fixed and set precision 
together , we get the desired output . Notice in this 
case, however , that we set the precision to 2, the number of decima l places we wish to 
see, not to 5. 

3.7 Formatting Output 
11 3 
The showpoi nt Manipulator 
By default, 
float ing-point numbers are displayed wit hout trailing zeroes, and 
floating -point number s with no fractional part are displayed without a decima l point. 
For example, this code 
double x = 456.0; 
cout << x << endl; 
will just display 456 and nothing more. 
Anot her useful manipulator, showpoi nt , allows these defaults to be overr idden . When 
showpoi nt is used, it indicates that a decima l point and decimal digits should be printed 
for a floating -point number , even if the value being displayed has no decimal digits. 
Here is the same code with the addition of the showpoi nt manip ulator. 
double x = 456.0; 
cout << showpoint << x << endl; 
It displays the following output: 
456.000 
Three zeros are shown because six signi ficant digits are displayed if we do not specify 
how many dec imal dig its we want. We can use the fixed, 
showpoi nt , and 
setpreci 
si on manipulators 
together , as shown below , for even more control over 
how the outp ut looks. 
double x = 456.0; 
cout <<fixed<< 
showpoint << setprecision(2) 
<< x << endl; 
This version of the code produces the following output : 
456.00 
Program 3-17 further illustrates the use of these manipulators. As with setpreci si on, 
the f i xed and showpoi nt manipulators remain in effect until the programmer explicitly 
changes them. 
Program 3-17 
1 // Thi s program illustrates 
the how the showpoint , setprecision, 
and 
2 II fixed manipulators 
operate 
both i ndividually 
and when used together
. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
double x = 6.0; 
10 
cout << X << endl; 
cout << showpoint 
// Header file 
needed to use stream manipulators 
<< X << endl; 
11 
12 
13 
14 
cout << setprec i si on(2) << X << endl; 
cout << fixed << X << endl; 
(program continues) 

114 
Chapter 3 
Expressions and Interactivity 
Program 3-17 
15 
(continued) 
16 
return 
O; 
17 } 
Program Output 
6 
6.00000 
6.0 
6.00 
When xis printed the first time, in line 11, none of the manipulators have been set yet. 
Th erefore, since the value being displayed requires no decimal digits, only the number 
6 is disp layed . When x is printed the second time , in line 12, the showpoi nt 
manipulator 
has been set, so a decima l point followed by zeroes is displayed . 
However , since the setprec
i si on manipulator has not yet been set, we have no 
control over how many zeroes are to be printed , and 6. 00000 is displayed . When x is 
printed the third time , in line 13, the setprec
i s ion manipulator 
has been set. 
However , because the f i xed manipulator has not yet been set, setprecision(2} 
indicates that two significant digits should be shown, and 6.0 is displayed, Finally, 
when xis printed the final time, in line 14, the fi xed and setpreci si on manipulators 
have both been set, specifying that exactly two decimal digits are to be printed, so 
6.00 is displayed . 
Actually, when the fixed and setpreci 
si on manipulators are both used, it is not 
necessary to use the showpoi nt manipulator. For examp le, 
cout <<fixed<< 
setprecision(2); 
will automatically display a decimal point before the two decima l digits . However , 
many programmers prefer to use it anyway as shown here: 
cout <<fixed<< 
showpoi nt << setprecision(2); 
The 1 eft and right Manipulators 
Normally, as you have seen, output is right -justified . This means if the field it prints 
in is larger than the value being displayed, it is printed on the far right of the field, 
with leading blanks. There are times when you may wish to force a value to print 
on the left side of its field, padded by blanks on the right . To do this you can use 
the left manipulator. It remains in effect until you use a right manipulator to set 
it back . Th ese manipulators 
can be used with any type of value, even a string . 

3.7 Formatting Output 
115 
Program 3-18 illustrates the left 
and right 
manipulators. It also illustrates that 
the fixed , showpoi nt , and setpreci 
si on manipulators have no effect on integers, 
only on floating-point numbers. 
Program 3-18 
1 // Thi s program illustrates 
the use of the lef t and right 
mani pulators
. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 #include 
<str i ng> 
// Header file 
needed to use stream mani pulators 
// Header file 
needed to use string 
objects 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
string 
month1 = "January", 
10 
month2 = "February"
, 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
month3 = "March"; 
i nt days1 = 31, 
days2 = 28, 
days3 = 31; 
double high1 = 22.6 , 
high2 = 37 .4, 
high3 = 53 .9; 
cout << f i xed<< 
showpoint 
cout << "Month 
Days 
cout << left 
<< setw(12) 
<< r i ght << setw(4) 
cout << left 
<< setw(12) 
<< right 
<< setw(4) 
cout << left 
<< setw(12) 
<< r i ght << setw(4) 
31 
return 
O; 
32 } 
33 
Program Output 
Month 
Days 
High 
January 
31 
22.6 
February 
28 
37.4 
March 
31 
53.9 
<< 
<< 
<< 
<< 
<< 
<< 
<< 
setprec
i si on (1}; 
High\n"; 
month1 
days1 << setw (9} << high1 << endl; 
month2 
days2 << setw (9} << high2 << endl; 
month3 
days3 << setw (9} << high3 << endl; 
Chapter 13 introduces additional stream manipulators and output formatting methods. 
However, the manipulators we have covered in this chapter are normally sufficient to 
produce the output you desire. Table 3-12 summarizes these six manipulators. 

116 
Chapter 3 
Expressions and Interactivity 
Table 3-12 Output Strea m Manipulators 
Stream Manipul ator 
Description 
set w( n) 
fi xed 
showpoint 
Sets a minimum print field width of size n for the next value output . 
Displays floating-point numbers in fixed point (i.e., decimal) form. 
Causes a decimal point and trailing zeroes to be displayed for 
floating-point numbers , even if there is no fractional part . 
set precision(n) 
left 
Sets the precision of floating -point numbers . 
Causes subsequent output to be left-justified . 
ri ght 
Causes subsequent output to be right-justified. 
~ 
Checkpoint 
3.8 
3.22 
Write cout statements with stream manipulators that perform the following: 
A) Display the number 34 .789 in a field of nine spaces with two decimal places 
of precision . 
B) Display the number 7.0 in a field of five spaces with three decimal places of 
precision . The decimal point and any trailing zeroes should be displayed . 
C) Display the number 5. 789e+12 in fixed-point notation . 
D) Display the number 67 left-justified in a field of seven spaces . 
3.23 
The following program segment converts an angle in degrees to radians . 
const double PI= 
3.14159; 
double degrees , rad i ans; 
cout << "Ent er an angle i n degrees and I will conver t it\n"; 
cout << "t o radians 
for you: "; 
cin 
>> degrees; 
radians= 
degrees* 
PI / 180; 
// Di splay t he value i n rad i ans left -justified
, i n fixed-point 
// notat i on, wit h four decimal places of precis i on, i n a field 
// seven spaces wide. 
Working with Characters and Strings 
CONCEPT : Special functions exist for working with char acters and strings. 
In Chapter 2 you were introduced to characters and to string objects. Let's review a 
few of their characteristics . A char variable can hold only one character, whereas a 
variable defined as a string can hold a whole set of characters. The following variable 
definitions and initializations illustrate this . 

3.8 Working with Characters and Strings 
117 
char l etter1 = 'A' 
I 
letter2 
= ' B'; 
string 
name1 = "Mark Twain ", 
name2 = "Samuel Clemens"; 
As with numeric data types, characters and strings can be assigned values. 
letter2 
= letter1; 
name2 = name1; 
II Now letter2's 
value is 
'A' 
// Now name2's value is "Mark Twai n" 
Like numeric data types, they can be displayed with the cout statement . The following 
line of code output s a character variable, a string literal, and a string 
object . 
cout << letter1 
<< " . " << name1 << endl; 
Th e outp ut produced is 
A. Mark Twain 
However, inputting characters and strings is trickier than reading in numeric values. 
Inputting a String 
Although it is possible to use ci n with the >> ope rator to input strings, it can cause 
problems you need to be aware of. When ci n reads data it passes over and ignores any 
leading whitespace characters (spaces, tabs, or line breaks ). However, once it comes to 
the first nonblank characte r and starts reading, it stops reading when it gets to the next 
whitespace character. If we use the following statement 
cin >> name1; 
we can input "Mark" or "Tw ain" but not "Mark Tw ain" because ci n cannot input 
strings that contain embedded spaces. 
Program 3-19 illustrates this prob lem. 
Program 3-19 
1 II This program illustrates 
a problem that 
can occur i f 
2 II ci n is used to read character 
data i nto a string 
object. 
3 #include 
<io stream> 
4 #include 
<string> 
II 
Header file 
needed to use string 
objects 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
str i ng name; 
10 
string 
city; 
11 
12 
13 
14 
15 
cout 
cin 
cout 
cin 
<< "Please 
>> name; 
<< "Enter 
>> city; 
enter 
your 
the city 
you 
name: ... 
• 
live 
in: ... 
(program continues) 

118 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-19 
16 
(continued) 
17 
cout << "Hello, 
"<<
name<< endl ; 
18 
cout << "You live 
in"<< 
city<< 
endl; 
19 
return 
O; 
20
} 
Program Output with Example Input Shown in Bold 
Pl ease enter 
your name: John Doe [Enter] 
Enter the city 
you live 
in: Hello , John 
You live 
in Doe 
Notice that the user was never given the opportunity to enter the city. In the first input 
statement, when ci n came to the space between John and Doe, it stopped reading, storing 
just John as the value of name. In the second input statement, ci n used the leftover 
characters it found in the keyboard buffer and stored Doe as the value of city. 
To solve this problem, you can use a C++ function called get l i ne. Th is function reads in 
an entire line, including leading and embedded spaces, and stores it in a string 
object. 
Th e get l i ne function looks like the following, where c in is the input stream we are 
reading from and i nputl i ne is the name of the str i ng variable receiving the input string. 
getline(cin, 
inputline); 
Program 3-20 illustrates the getl i ne function. 
Program 3-20 
1 II Thi s program illustrates 
using the getline 
function 
2 II to read character 
data into 
a string 
object. 
3 #i nclude <iostream> 
4 #i nclude <string> 
II Header f i le needed to use string 
objects 
5 usi ng namespace std; 
6 
7 int main () 
8 { 
9 
string 
name; 
10 
string 
city
; 
11 
12 
cout << "Please 
enter 
your name: "; 
13 
getl i ne(cin, 
name); 
14 
cout << "Enter 
the city 
you live 
in: 
"· 
15 
getline(cin, 
city ); 
16 
17 
cout << "Hello, 
"<<
name<< endl ; 
18 
cout << "You live 
in"<< 
city<< 
endl; 
19 
return 
O; 
20
} 
(program continues) 

3.8 Working with Characters and Strings 
119 
Program 3-20 
(continued) 
Program Output with Example Input Shown in Bold 
Pl ease enter 
your name: John Doe[Enter] 
Enter the city 
you live 
in: 
Chlcago[Enter] 
He 11 o , John Doe 
You live 
in Chicago 
Inputting 
a Character 
Sometimes you want to read only a single characte r of input. For example, some 
programs display a menu of items for the user to choose from. Often the selections will 
be denoted by the letters A, B, C, and so forth. The user chooses an item from the menu 
by typing a character. The simplest way to read a single character is with ci n and the 
>> operator, as illustrated in Program 3-21. 
Program 3-21 
1 // Thi s program reads a single 
character 
into a char variable. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
char ch; 
8 
9 
10 
11 
12 
13 } 
cout << 
ci n >> 
cout << 
return 
"Type 
ch; 
"You 
o· ' 
a character 
and press Enter: 
". 
' 
entered 
" << ch<< endl; 
Program Output with Example Input Shown in Bold 
Type a character 
and press Enter: 
A[Ent er] 
You entered 
A 
Using ci n. get 
As with string input, however, there are times when using ci n >> to read a character 
does not do what we want. For example, because it passes over all leading whitespace, 
it is impossible to input just a blank or (Enter ) with ci n >>. The program will not 
continue past the ci n statement until some character other than the spacebar, the tab 
key, or the (Enter ) key has been pressed . (Once such a character is entered, the (Enter ) 
key must still be pressed before the program can contin ue to the next statement.) Thu s, 
programs that ask the user to "Press the enter 
key to cont i nue." cannot use the 
>> operator to read only the pressing of the [Enter) key. 

120 
Chapter 3 
Figure 3-5 
Expressions and Interactivity 
In those situations, the ci n object has a built-in function named get that is helpful. 
Because the get function is built into the ci n object, we say that it is a member function 
of ci n. The get member function reads a single character, including any whitespace 
character. If the program needs to store the character being read, the get member 
function can be called in either of the following ways. In both examples, assume that 
ch is the name of a char variable the character is being read into. 
ci n.get(ch); 
ch = ci n.g et (); 
If the program is using the get function simply to pause the screen until the [Ent er] key is 
pressed, and does not need to store the character, the function can also be called like this: 
ci n. get(); 
Notice that in all three of these programming statements the format of the get function 
call is actually the same. First comes the name of the object. In this case it is ci n. Then 
comes a period , followed by the name of the member function being called. In this case 
it is get . The statement ends with a set of parentheses and a closing semicolon. This is 
the basic format for calling any member function and is illustrated in Figure 3-5. 
/cin.ge
t();
~ 
This is the object whose 
The statement ends 
function is being called. 
with a semicolon. 
A period 
comes next. 
The ( ) tells C++ that 
this is a function call. 
This is the member 
function being called. 
Program 3-22 illustrates all three ways to use the get member function . 
Program 3-22 
1 II Thi s progra m demonstra t es t hree ways t o use ci n.ge t () 
2 II t o pause a program. 
3 #include 
<iostr eam> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
char ch; 
9 
(program continues) 

3.8 Working with Characters and Strings 
121 
Program 3-22 
(continued) 
10 
cout << "This progra m has paused. 
Pr ess Enter to cont i nue."; 
11 
cin .get (ch); 
12 
13 
cout << "It has paused a second time. 
Plea se press 
Enter aga i n."; 
14 
ch = ci n.ge t (); 
15 
16 
cout << "It has paused a third 
t i me. 
Plea se press 
Enter aga i n."; 
17 
ci n . get() ; 
18 
19 
cout << "Thank you! \ n"; 
20 
return 
O; 
21 } 
Program Output with Example Input Shown in Bold 
This program has paused. 
Press Enter to continue.[
Ente r] 
It has paused a second time. 
Please 
press 
Enter again. [Enter] 
It has paused a third 
time. 
Please 
press 
Enter again. [Enter] 
Thank you! 
0 
NOTE: The c i n . get function can be used to keep the output screen visible 
when a programs runs in an IDE that closes the outp ut window when a program 
terminates . 
Mixing ci n >> and ci n. get 
Mixing ci n >> with ci n. get can cause an annoying and hard-to-find problem . For 
example, look at the following code segment . The lines are numbered for reference. 
1 char ch; 
II Defi ne a character 
var iabl e 
2 i nt number; 
II Defi ne an i nte ger variable 
3 cout << "Ente r a number: ". 
' 
4 ci n 
>> number; 
II Read an i nt eger 
3 cout << "Ente r a character: .. 
' 
6 ch = cin.get
(); 
II Read a character 
7 cout << "Thank You! \n"; 
These statements allow the user to enter a number but not a character. It will appear 
that the ci n . get statement on line 6 has been skipped. This happens because ci n >> 
and ci n. get use slightly different techniques for reading data. 
In the example code segment, when line 4 is executed, the user enters a number and 
then presses the [Enter ] key. Let's suppose the number 100 is entered . Pressing the 
[Enter] key causes a newline character (' \ n' ) to be stored in the keyboard buffer right 
after the 100, as shown in Figure 3-6. 

122 
Chapte r 3 
Figure 3-6 
Expressions and Interactivity 
Keyboard buffer 
1 
0 
0 
\n 
~ei:cii~~g~:~e. j 
J 
ci n stops reading here, 
but does not read in the 
\ n character. 
When the ci n >> statement in line 4 reads the data the user entered, it stops when it 
comes to the newline character. The newline character is not read but remains in the 
keyboard buffer. Input statements that read data from the keyboard only wait for the 
user to enter a value if the keyboard buffer is empty, but now it's not empty . When 
the ci n. get function in line 6 executes, it begins reading the keyboard buffer from 
where the previous input operation stopped, and it finds the newline character. So it 
uses it and does not wait for the user to input another value. You can remedy this 
situati on by using the ci n. ignore function, described in the following section . 
Using ci n. ignore 
The ci n. ignore function tells the ci n object to skip one or more characters in the 
keyboard buffer. Here is its general form: 
cin. i gnore(n, 
c); 
The arguments shown in the parentheses are optional. If they are used, n is an integer 
and c is a character. They tell ci n to skip n number of characters, or until the character 
c is encountered. For example, the following statement causes ci n to skip the next 20 
characters or until a newline is encountered, whichever comes first: 
cin. i gnore(20, '\n'); 
If no arguments are used, ci n will only skip the very next character. Here's an 
example: 
cin. i gnore(); 
Th e problem that previously occurred when ci n >> and ci n. get statements were 
intermixed can be avoided by inserting a ci n. i gnore statement after the ci n >> 
statement, as shown below. This causes the newline character left behind by ci n >> to 
be bypassed, forcing ci n. get to wait for the user to enter another character. 
cout << "Enter a number: "; 
cin 
>> number; 
cin. i gnore(); 
cout << "Enter a character: 
"; 
cin.get(ch); 
cout << "Thank You!"<< endl; 
// Ski p the newline character 

3.8 Working with Characters and Strings 
123 
Useful string 
Member Functions and Operators 
C++ string 
objects also have a number of member functions. For examp le, if you 
want to know the length of the string that is stored in a str i ng object, you can call the 
object's length member function. Here is an example of how to use it. 
stri ng state= 
"New Jersey"; 
i nt si ze = state.length(
); 
The first statement creates a string object named sta te , and initializes it with the string 
"New Jersey·. The second statement defines an int variable named size , and initializes it 
with the length of the string in the sta te object. After this code executes, the size variable 
will hold the value 10. The blank space between "New" and "Jersey" is a character and is 
counted just like any other character. On the other hand, the ' \ O' null character you 
learned about in Chapter 2 that marks the end of a String literal is not counted . 
Another useful member function is assign. One of the versions of this function lets 
you assign a set of repeated characters to a string without having to count the characters. 
Suppose, for example, you have declared a string object named spaces and you want 
to assign it 22 blanks. You could do it by using a string literal like this: 
spaces=" 
.. 
' 
However, counting the number of spaces to include in the string literal is tedious, and 
it is easy to miscount . It would be much easier to use the str i ng class assign member 
function, as shown here. 
spaces.assign(22, 
' '); 
The st ri ng class also has special operators for working with strings . One of them is 
the + operator. 
You have already encountered the + operator to add two numeric quantities . Because 
strings cannot be added, when this operator is used with string operands it concatenates 
them, or join s them together. Assume we have the following definitions and 
initializations in a program . 
stri ng gree t i ng1 = "Hello .. 
' 
gree t ing2; 
stri ng word1 
= "World"; 
stri ng word2 
= "People"; 
The following statements illustrate how string concatenation works. 
greeting2 
= greeting1 
+ word1 ; // greeting2 
now holds "Hello World" 
gree t i ng1 = greet in g1 + word2; II greeting1 
now holds "Hello People" 
Notice that the string stored in gree t i ng1 has a blank as its last character. If the blank 
were not there, greet i ng2 would have been assigned the string "He 11 oWorl d ". 
The last statement cou ld also have been written using the += combined assignment 
operator, like this: 
greeting
1 += word2 ; 
Program 3-23 uses the str i ng class member functions and the string concatenation 
operator we have just been looking at. You will learn about many other useful stri ng 
class member functions and operators in later chapters. 

124 
Chapte r 3 
Expressions and Interactivity 
Program 3-23 
1 II Thi s program displays 
the user's 
name surrounded 
by stars
. 
2 II 
It uses the+ 
operator 
and several 
str i ng class 
member funct i ons. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
II Header f i le needed to use string 
objects 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
string 
firstName, 
la stName , fullName; 
10 
string 
stars
; 
11 
int numStars; 
12 
13 
cout << "Please 
enter 
your first 
name: "; 
14 
getl i ne(cin, 
firstName); 
15 
16 
cout << "Please 
enter 
your l ast name : "· 
17 
getline(cin, 
lastNa me ); 
18 
19 
fullName = firstName 
+" 
" + last Name; 
20 
21 
numStars = fullName.length(); 
22 
stars
.a ssign (numStar s , '*'); 
23 
24 
25 
26 
27 
28 
29 ) 
cout << endl; 
cout << stars 
cout << f ull Name 
cout << stars 
ret urn O; 
<< endl ; 
<< endl ; 
<< endl ; 
Program Output with Example Input Shown in Bold 
Pl ease enter 
your first 
name: Mary lou[Ent er] 
Pl ease enter 
your last 
name: St. Germaln e [Enter] 
* * ******
* * * * * * * * * ****
* * * * * * 
Mary Lou St. 
Germaine 
* * ******
* * * * * * * * * ****
* * * * * * 
Using C-Strings 
In C, and in C++ prior to the introd uction of the str i ng class, str ings were stored as a 
set of individ ual characters. A gro up of contig uous 1-byte memory cells was set up to 
hold them, with each cell holding just one character of the string. A group of memory 
cells like this is called an array. You will learn more abo ut arrays in Chapte r 8, but for 
now all you need to know is how to set one up and use it to hold and wo rk with the 
characters that make up a string . 
Because this was the way to create a string var iab le in C, a string defined in this manner 
is called a G-string . Here is a statement that defines word to be an array of characters 
that will hold a C-string and initializes it to "He 11 o •. 
char word[ 10] = "Hello"; 

3.8 Working with Characters and Strings 
125 
Notice that the way we define word is similar to the way we define any other variable. 
The data type is specified first and then the variable name is given. The only difference 
is the [ 1 OJ that follows the name of the variable. This is called a size declarator. It tells 
how many memory cells to set up to hold the characte rs in the C-string. 
As with string literals, the null character is automatically appended to the end of a 
C-string to mark its end. Figure 3-7 shows what the contents of the word variable 
would look like in memory . Notice that the 10 memory cells are numbered 0- 9. 
Figure 3-7 
H I e 
1 
1 I o 
\0 
(OJ 
(1] 
[2] 
[3] 
(4] 
[5] 
[6] 
[7] 
[ 8] 
[9] 
Because one space must be reserved for the null terminator, word can only hold a string 
of up to nine characters . 
Like string objects, C-strings can have their contents input using ci n, and they can 
have their contents displayed using cout . This is illustrated in Program 3-24. Because 
the variable name is defined in line 8 to have 12 memory cells, it can store a name of up 
to 11 characters . Not ice that no special header file is needed to use C-strings . 
Program 3-24 
1 II Thi s progra m uses ci n >> to read a word into a C-st ri ng. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
8 
9 
cons t i nt SIZE = 12; 
char name[SIZE] ; 
II name is a set of 12 memory cells 
10 
cout << "Please enter your first 
name: "; 
11 
ci n >> name; 
12 
cout <<"Hello,"<< 
name<< endl; 
13 
retur n O; 
14 
} 
Program Output with Example Input Shown in Bold 
Pl ease enter your first 
name: Sebastlan[Enter] 
Hello , Sebastian 
Except for inputting and displaying them with ci n >> and cout <<, almost everything 
else about using st ring objects and C-strings is different . This is because the stri ng 
class includes functions and operators that save the programmer having to worry about 
many of the details of working with strings . When using C-strings, however, it is the 
responsib ility of the programmer to handle these things. 

126 
Chapte r 3 
Expressions and Inte ractivity 
Because C-strings are harder to work with than string objects, you might be wondering 
why you are learning about them. There are two reasons. First, you are apt to encounter 
older programs that use them, so you need to understand them. Second, even though 
strings can now be declared as str i ng objects in most cases, there are still times when 
only C-strings will work . You will be introduced to some of these cases later in the book. 
Assigning a Value to a C-String 
The first way in which using a C-string differs from using a string 
object is that, 
except for initializing it at the time of its definition, it cannot be assigned a value using 
the assignment operator. In Program 3-24 we could not, for example, replace the ci n 
statement with the following line of code . 
name= "Sebas tian"
; 
I I Wrong! 
Instead, to assign a value to a C-string, we must use a function called st rcpy (pronounced 
string copy) to copy the contents of one string into another. In the following line of 
code Cstri ng is the name of the variable receiving the value, and value is either a string 
literal or the name of another C-string variable. 
strcpy(Cstring
, value); 
Program 3-25 shows how the strcpy function works. 
Program 3-25 
1 II Thi s program uses the strcpy 
function 
to copy one C-string 
to another . 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main() 
6 { 
7 
const i nt SIZE= 12; 
8 
char name1[SIZE] , 
9 
name2[SIZE]; 
10 
11 
strcpy (name1, "Sebast i an"); 
12 
cout << "name1 now holds the str i ng"<< 
name1 << endl; 
13 
14 
strcpy(name2
, name1); 
15 
cout << "name2 now also holds the string"<< 
name2 << endl ; 
16 
17 
return 
O; 
18 } 
Program Output 
name1 now holds the string 
Sebastian 
name2 now also holds the string 
Sebastian 

3.8 Working with Characters and Strings 
12 7 
Keeping Track of How Much a C-String Can Hold 
Another crucial way in which using a C-string differs from using a string 
object 
involves the memory allocated for it. With a string 
object, you do not have to worry 
about there being too little memory to hold a string you wish to place in it. If the 
storage space allocated to the str i ng object is too small, the string class functions will 
make sure more memory is allocated to it. With C-strings this is not the case. The 
number of memory cells set aside to hold a C-string remains whatever size you originally 
set it to in the definition statement. It is the job of the programmer to ensure that the 
number of characters placed in it does not exceed the storage space. If the programmer 
uses ci n to read a value into a C-string and the user types in more characters than it can 
hold, ci n will store all the characte rs anyway . The ones that don't fit will spill over into 
the following memory cells, overwriting whatever was previously stored there. This 
type of error, known as a buffer overrun, can lead to serious problems. 
One way to prevent this from happening is to use the setw stream manipulator. This 
manipulator, which we used earlier to format output, can also be used to control the 
number of characters that ci n >> inputs on its next read, as illustrated here: 
char word[5] ; 
cin >> setw (5) >> word; 
Another way to do the same thing is by using the ci n width function. 
char word[5] ; 
cin.width(5); 
cin >> word; 
In both cases the field width specified is 5 and ci n will read, at most, one character less 
than this, leaving room for the null character at the end. Program 3-26 illustrates the 
use of the setw manipulator with ci n, while Program 3-27 uses its width function. 
Both programs produce the same output. 
Program 3-26 
1 // Thi s program uses setw with the cin object. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
// Header file 
needed to use stream manipulators 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const 
int SIZE = 5 ; 
9 
char word[SIZE]; 
10 
11 
cout << "Ent er a word: " ; 
12 
cin 
>> setw (SIZE) >> word; 
13 
cout << "You entered 
" << word << endl ; 
14 
15 
return 
O; 
16 ) 

128 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-27 
1 // 
Thi s program uses ci n's width f unction. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
// Header file 
needed to use stream manip ulators 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const int SIZE= 
5; 
9 
char word [SI ZE]; 
10 
11 
cout << "Ent er a word: "; 
12 
cin .width(SIZE); 
13 
cin 
>> word; 
14 
cout << "You entered"<< 
word<< endl ; 
15 
16 
return 
O; 
17 ) 
Program Output for Programs 3-26 and 3-27 with Example Input Shown In Bold 
Enter a word: Eureka[Enter] 
You entered 
Eure 
Figure 3-8 
In Program 3-27, ci n only reads and stores four characters into word. If the field width had 
not been specified, ci n would have written the entire word "Eureka" into memory, 
overflowing the space set up to hold word. Figure 3-8 illustrates the way memory would have 
been affected by this. The shaded area is the 5 bytes of memory allocated to hold the C-string. 
The 5 bytes allocated 
to hold the word array 
_.,.,A...__ 
( 
11 
I E I u 
r I e ' 
k I a 
\0 
Next item in memory, 
overwritten with 'a' 
and null character 
There are three important points to remember about the way ci n handles field widths: 
• The field width only pertains to the very next item entered by the user. 
• To leave space for the '\O' characte r, the maximum number of characters read 
and stored will be one less than the size specified. 
• If ci n comes to a whitespace character before reading the specified number of 
characters, it will stop reading. 

3.8 Working with Characters and Strings 
129 
Reading a Line of Input 
Still another way in which using C-strings differs from using string objects is that you 
must use a different set of functions when working with them. To read a line of input, 
for example, you must use ci n . get line rather than get line. These two names look a 
lot alike, but they are two different functions and are not interchangeable. Like get line, 
ci n. get l ine allows you to read in a string containing spaces. It will continue reading 
until it has read the maximum specified number of characters, or until the [Ente r) key 
is pressed. Here is an example of how it is used: 
cin.getline(sentence, 
20); 
The getl i ne function takes two arguments separated by a comma . The first argument 
is the name of the array the string will be stored in. The second argument is the size of 
the array . When the ci n . get line statement executes, ci n will read up to one character 
less than this number , leaving room for the null terminator. This eliminates the need 
for using the setw manipulator or the wi dth function . The statement above will read 
up to 19 characters. The null terminator will automatica lly be placed in the array after 
the last character. Program 3-28 shows the getl i ne function being used to read a 
sentence of up to 80 characte rs. 
Program 3-28 
1 II Thi s program demonstrates 
cin 's getl i ne function 
2 II to read a line of text 
into a C-string. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const int SIZE= 81; 
9 
char sentence
[SIZE]; 
10 
11 
cout << "Enter a sentence: 
"; 
12 
cin .getline
(sent ence , SIZE); 
13 
cout << "You entered•<< 
sentence<< 
endl ; 
14 
return 
O; 
15 ) 
Program Output with Example Input Shown in Bold 
Enter a sentence: 
To be, or not to be, that ls the question . [Enter] 
You entered 
To be, or not to be , that 
is the question. 
Later chapters cover more on C-strings and how they differ from string 
objects. 
~ 
Checkpoint 
3.24 
Will the following string literal fit in the space allocated for name? Why or 
why not? 
char name[4] = "John"; 

130 
Chapte r 3 
3.9 
Expressions and Inte ractivity 
3.25 
If a program contains the definition str i ng name; indicate whether each of the 
following lettered program statements is legal or illegal. 
A) 
ci n >> name; 
B) ci n.getl ine(name, 20); 
C) 
cout << name; 
D) name = "John"; 
3.26 
If a program contains the definition char name[20]; indicate whether each of 
the following lettered program statements is legal or illegal. 
A) 
ci n >> name; 
B) ci n.getl ine(name, 20); 
C) 
cout << name; 
D) 
name = "John"; 
More Mathematical 
Library Functions 
CONCEPT: 
Th e C++ run-tim e librar y provides functions for performing complex 
mathematical operation s. 
Earlier in this chapter you learned to use the pow function to raise a number to a power. 
The C++ library has numerous other functions that perform specialized mathematical 
operat ions. Th ese functions are useful in scientific and special purp ose programs. 
Table 3-13 shows some of the most common ones. They all require the cmath header file. 
Table 3-13 
Selected Mathematical Library Functions 
Function 
Example 
abs 
y = abs (x); 
cos 
y = cos (x); 
exp 
y = exp (x); 
fmod 
y = fmod(x, z); 
Description 
Returns the absolute value of the argument . The argument 
and the return value are integers. 
Returns the cosine of the argument . The argument should 
be an angle expressed in radians. Th e return type and the 
argument are doubles. 
Computes the exponential function of the argument, which 
is x. The return type and the argument are doubles . 
Returns, as a double, the remainder of the first argument 
divided by the second argument . Works like the modulus 
operato r, but the arguments are doub les. (The modulus 
operato r only works with integers.) Take care not to pass 
zero as the second argument . Doing so would cause 
division by zero. 

log 
log 10 
pow 
round 
si n 
sqrt 
tan 
3.9 More Mathematical Library Functions 
131 
y = log(x); 
Returns the natural logarithm of the argument . The return 
type and the argument are doubles. 
y = log10(x); 
Returns the base-10 logarithm of the argument . The return 
type and the argument are doubles. 
y = pow(x , z); 
Returns the first argument raised to the power of the 
second one. 
y = round (x); 
Returns the argument rounded to the nearest whole 
number. The return value is an integer. 
y = sin(x); 
Returns the sine of the argument. The argument should be 
an angle expressed in radians. The return type and the 
argument are doubles. 
y = sqrt(x); 
Returns the square root of the argument . The return type 
and argument are doubles. The argument must be zero or 
greater. 
y = t an(x); 
Returns the tangent of the argument . The argument should 
be an angle expressed in radians. The return type and the 
argument are doubles. 
With the exception of the abs and round functions , all of the function s listed in 
Table 3-13 take one or more double arguments and return a double value. However, 
most C++ compilers allow them to be called with i nt arguments as well. So, for 
example, both of the following will work to print the square root of 30. 
cout << sqr t (30 .0); 
cout << sqr t (30); 
II Displays 
5.47723 
II Displays 
5.47723 
Program 3-29 shows the sqrt function being used to find the hypotenuse of a right 
triangle. The program uses the following formula, taken from the Pythagorean theorem: 
C ='Va
2 + b2 
In the formula, c is the length of the hypotenuse, and a and b are the lengths of the 
other sides of the triangle. 
Program 3-29 
1 II Thi s progra m inputs 
t he leng t hs of t he t wo sides 
of a right 
2 II t r i angle, 
then calcula
t es and displays 
t he length 
of the hypotenuse . 
3 #include 
<iostream> 
4 #include 
<cmath> 
5 using namespace std; 
6 
7 int main () 
8 { 
9 
double a , b, c; 
10 
II Header f i le needed t o use t he sqrt 
func ti on 
(program continues) 

132 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-29 
(continued) 
11 
12 
13 
14 
15 
16 
II Get 
cout << 
cin 
>> 
cout << 
cin 
>> 
the length 
of the two sides 
'"Enter the l ength of side a: .. 
' 
a· ' 
"Enter the l ength of side b: .. 
' 
b· ' 
17 
// Compute and disp l ay the length 
of the hypotenuse 
18 
c = sqrt(pow(a, 
2.0 ) + pow(b, 2 .0)); 
19 
20 
cout << "The length 
of the hypotenuse 
is·· 
21 
cout << c << endl ; 
22 
return 
O; 
23
) 
Program Output with Example Input Shown in Bold 
Enter the length 
of side a: 5.0[Ent er] 
Enter the length 
of side b: 12 .0[Ent er] 
The length 
of the hypotenuse 
is 13 
3.10 
The following statement, taken from line 18 of Program 3-29, calculates the square 
root of the sum of the squares of the triangle's two sides: 
c = sqrt(pow(a, 
2.0 ) + pow(b, 2.0)); 
Notice that the following mathematica l expression is used as the sqrt 
function's 
argument: 
pow(a, 2.0 ) + pow(b, 2 .0) 
This expression calls the pow function twice: once to calculate the square of a and again 
to calculate the square of b. These two squares are then added together, and the sum is 
sent to the sqrt function. 
Random Numbers 
CONCEPT: 
C++ offers a set of functions to generate and work with random numbers. 
A random number is a value from a set of possible values that appears to be selected by 
chance, with each value in the set having an equal probability of being selected. They 
are used in many different kinds of programs. Here are just a few examples. 
• Computer games often use random numbers to represent things such as the roll 
of a dice or a card drawn from a deck of cards . 
• Simulation programs use random numbers to decide which of a set of actions will 
occur or how a person, animal, or other being will behave. Formulas can be 
created that use a random number to determine when a particular event will take 
place in the program . 

3.10 Random Numbers 
133 
• Dat a analysis programs may use random numbers to randomly select which data 
will be examined . 
• Computer security systems use random numbers to encrypt sensitive data. 
The C++ library has a function called rand () that generates random numbers. It returns 
a non-negative integer each time it is called. To use the rand() function, you must 
include the cstdl i b header file in your program. The number returned by the function 
is a non-negative integer. Here is an example of how it is used. 
randomNum =r and (); 
However, the numbers returned by the function are really pseudorandom. Thi s 
means they have the appearance and properties of random numbers, but in reality 
are not random. The y are act uall y generated with an algorithm. Th e algorithm 
needs a starting value, called a seed, to generate the numbers. If it is not given 
one, it will produce the same stream of numbers each time it is run. Program 3-30 
illustrates this. 
Program 3-30 
1 II Thi s program demonstrates 
what happens in C++ if you 
2 II try to generate 
random numbers wi thout setting 
a "seed". 
3 #include 
<iostream> 
4 #include 
<cstdlib> 
II Header file 
needed to use rand 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
10 
11 
12 
13 
II Generate and print 
three 
random numbers 
cout << rand(} << " 
" 
cout << rand(} << " 
" 
cout << rand(} << endl; 
14 
return 
O; 
15 } 
Program Output from Run 1 
Program Output from Run 2 
41 
18467 
6334 
41 
18467 
6334 
To get a different stream of random numbers each time you run the program, you must 
provide a seed for the random number generator to start with. In C++ this is done by 
calling the srand function. Program 3-31 illustrates this. Notice that the srand function 
is called on line 16 before rand is ever called, and that srand is only called once for the 
whole program. 
Notice also that the variable created in line 9 to hold the seed is declared to be unsigned. 
As you may recall, this data type holds only non -negative integers. This is the data type 
the srand function expects to receive when it is called, so making the variable unsigned 
guarantees that no negative numbers will be sent to srand. 

134 
Chapte r 3 
Expressions and Inte ractivity 
Program 3-31 
1 II Thi s program demonstrates 
using random numbers when a 
2 II "seed" i s provided 
for the random number generator. 
3 #include 
<iostream> 
4 #include 
<cstdl ib> 
II Header file 
needed to use srand and rand 
5 using namespace std; 
6 
7 int main () 
8 { 
9 
10 
unsigned seed ; 
II Random generator 
seed 
11 
II Get a "s eed " value from the use r 
12 
cout << "Enter a seed value: 
"; 
13 
cin 
>> seed; 
14 
15 
II Set the random generator 
seed before 
calling 
rand() 
16 
srand (s eed ); 
17 
18 
19 
20 
21 
22 
II Now generate 
cout << rand(} 
cout << rand(} 
cout << rand(} 
and print 
three 
random numbers 
<< • 
• 
<< • 
• 
<< endl ; 
23 
return 
O; 
24
} 
Program Output with Example Input Shown in Bold 
Run 1 : 
Run 2: 
Enter a seed value: 
19 [Enter] 
Enter a seed value: 
171 [Enter] 
100 
15331 
209 
597 
10689 
28587 
0 
As you can see from the Program 3-31 output, each time the program is run with a 
different seed, a different stream of random numbers is generated . However, if we run 
the program a third time using 19 or 171 as the seed again, we will get exactly the same 
numbers we did the first time. 
NOTE: The stream of random numbers generated on your computer system may 
be different. 
Notice that on line 13 of Program 3-31 ci n is used to get a value from the user for the 
random number generator seed. Another common practice for getting a seed value is to 
call the t i me function, which is part of the C++ standard library. This function returns 
the number of seconds that have elapsed since midnight, January 1, 1970, so it will 
provide a different seed value each time the program is run. Program 3-32 illustrates the 
use of the t i me function, which appears on line 13 of the program . Notice that when 
you call it, you must pass O as an argument . Notice also that Program 3-32 has a new 
header file, ct i me, which is included on line 5. This header file is needed to use ti me. 

Program 3-32 
1 II Thi s program demonstrates 
using the C++ time function 
2 II to provide 
a "se ed" for the random number generator. 
3 #include 
<iostream> 
3.10 Random Numbe rs 
135 
4 #include 
<cstdlib> 
5 #include 
<ctime> 
II Header file 
needed to use srand and rand 
II Header file 
needed to use time 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
unsigned 
seed; 
II Random generator 
seed 
11 
12 
II Use the time funct i on to get a "seed" value for srand 
13 
seed
= time (O); 
14 
srand (s eed ); 
15 
16 
17 
18 
19 
20 
and print 
three 
random numbers 
II Now generate 
cout <<rand()<<" 
cout <<rand()<<" 
cout <<rand()<< 
" 
" 
endl; 
21 
return 
O; 
22 ) 
Program Output 
2961 
21716 
181 
Th e above output was produced by one sample run. It will be different every time you 
run the program. 
Limiting the Range of a Random Number 
Sometimes a program needs a random number in a specific range . To limit the range of 
the random number to an integer between 1 and some maximum value max, you can 
use the following formula. 
number= 
rand ()% max + 1; 
For example, to generate a random number in the range of 1 through 6 to represent the 
roll of a dice, you would use 
dice= 
rand ()% 6 + 1; 
Here is how the statement works. Recall that the modulus operator gives us the remainder 
of an integer divide. When the positive integer returned by the rand function is divided 
by 6, the remainder will be a number between O and 5. Because we want a number 
between 1 and 6, we simply add 1 to it. 
Thi s idea can be extended to produce a random integer in any range. 
Th e general formula to do this is: 
number= 
(r and ()% 
(maxVa1ue - minVa1ue + 1)) + minVa1ue; 

136 
Chapte r 3 
Expressions and Interactivity 
In the form ula, minValue is the lowest number in the range and maxValue is the highest 
number in the range. Here is how you cou ld assign the variable number a random 
integer in the range of 10 through 18. 
const i nt MIN_VALUE = 10; 
const i nt MAX_VALUE = 18 ; 
number = rand () % (MAX
_VALUE - MIN_VALUE + 1) + MIN_VALUE; 
In this code MAX
_VALUE - MIN_VALUE + 1 evaluates to 9, the number of integers in the 
desired range. Th e modulus operation thus returns a value between O and 8. Adding 
MIN_VALUE, which is 10, produces a value between 10 and 18. 
~ 
Checkpoint 
3.11 
3.27 
Use a mathematical library function with a cout statement to display the value 
of the double variable inches rounded to the nearest whole number. 
3.28 
Assume the variables angl e 1 and angl e2 hold angles stored in radians . Write a 
statement that adds the sine of angl e1 to the cosine of angl e2 and stores the 
result in the variab le x. 
3.29 
To find the cube root (the third root) of a number, raise it to the power of½ . To 
find the fourth root of a number , raise it to the power of¾. Write a statement 
that will find the fifth root of the variable x and store the result in the 
variab le y. 
3.30 
Write a statement that produces a random number between 1 and 100 and 
stores it in the variable l uckyNumber. 
Focus on Debugging: Hand Tracing a Program 
Hand tracing is a deb ugging process where you pretend that you are the comp uter 
executing a program. You step through each of the program 's statements one by one. 
As you look at a statement, you record the contents that each variab le will have after 
the statement executes. This process is helpful in finding mathematical mistakes and 
other logic errors. 
To hand trace a program, you constr uct a chart with a column for each variab le. The 
rows in the chart correspond to the lines in the program. For examp le, Program 3-33 is 
shown with a hand trace chart. Th e program uses the following four variables: num1, 
num2, num3, and avg. Notice that the hand trace chart has a column for each variable 
and a row for each line of code in function mai n. 
Program 3-33 
(with hand trace chart empty) 
1 // Thi s program computes and displays 
the average of three 
numbers 
2 II entered 
by the user. 
However, it contains 
a bug. Can you f i nd i t ? 
3 #include 
<iostream> 
(program continues) 

3.11 Focus on Debugging: Hand Tracing a Program 
137 
Program 3-33 
(with hand trace chart empty) (continued) 
4 using names pace std; 
5 
6 int main() 
7 { 
8 
double num1, num2, num3, avg; 
9 
10 
cout << "Enter the first 
number: ". 
' 
11 
cin 
>> num1; 
12 
cout << "Enter the second number: ". 
' 
13 
cin 
>> num2; 
14 
cout << "Enter the th i rd number: ". 
' 
15 
cin 
>> num3; 
16 
avg = num1 + num2 + num3 I 3· ' 
17 
cout << "The average 
i s " << avg << endl; 
18 
return o· ' 
19 } 
Program Output with Example Input Shown in Bold 
Enter the first 
number: lO [Enter] 
Enter the second number: 20[Ent er] 
Enter the third 
number: 30 [Enter] 
The average 
is 40 
num1 
num2 
num3 
avg 
Notice that the program runs, but it displays an incorrect average. The correct average 
of 10, 20, and 30 is 20, not 40. To find the error we will hand trace the program. 
To hand trace a program, you step through each statement, observe the operation 
that is taking place, and then record the contents of the variables after the statement 
executes . After the hand trace is comp lete, the chart will appear as follows. 
We have written question marks in the chart where we do not yet know the contents 
of a variable . 
Program 3-33 
(with hand trac e chart filled in) 
1 II This program computes and displays 
the average of three 
numbers 
2 II entered 
by the user. 
However, it contains 
a bug. Can you find it ? 
3 #include 
<iostream> 
4 using namespace std; 
(program continues) 

138 
Chapte r 3 
Expressions and Interactivity 
Program 3-33 
5 
(with hand trace chart filled in) (continued) 
6 int main() 
7 { 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 } 
3.12 
double num1, num2, num3, avg; 
num1 
num2 
num3 
avg 
cout << "Enter the first 
number: ". 
' 
? 
? 
? 
? 
cin 
>> num1; 
cout << "Enter the second number: ". 
? 
? 
? 
? 
' 
cin 
>> num2; 
10 
? 
? 
? 
10 
? 
? 
? 
cout << "Enter the th i rd number: ". 
' 
10 
20 
? 
? 
cin 
>> num3; 
10 
20 
? 
? 
avg = num1 + num2 + num3 I 3· ' 
10 
20 
30 
? 
cout << "The average i s " << avg << endl; 
10 
20 
30 
40 
10 
20 
30 
40 
return o· ' 
Do you see the error? By examining the statement on line 16 that computes the average, 
we find a mistake. The division operat ion takes place before the addition operat ions, 
so we must rewrite that statement as 
avg= 
(num1 + num2 + num3) / 3; 
Hand tracing is a simple process that focuses your attention on each statement in a 
program. Often this helps you locate errors that are not obvious . 
Green Fields Landscaping Case Study-Part 
1 
Problem Statement 
One of the services provided by Green Fields Landscaping is the sale and delivery of 
mulch, which is measured and priced by the cubic yard. You have been asked to create 
a program that will determine the number of cubic yards of mulch the customer needs 
and the total price. 

Program Design 
Program Steps 
3.12 Green Fields Landscap ing Case Study- Part 1 
139 
The program must carry out the following general steps (this list of steps is sometimes 
called General Pseudocode): 
1. Set the price for a cubic yard of mulch (currently 22.00). 
2. Ask the user to input the number of square feet to be covered 
and the depth of the mulch to be spread over this area. 
3. Calculate the number of cubic feet of mulch needed. 
4. Calculate the number of cubic yards of mulch needed. 
5. Calculate the total price for the mulch. 
3. Display the results. 
Variables whose values will be input 
double squareFeet 
II square feet of land to be covered 
int 
depth 
II how many inches deep the mulch is to be spread 
Variables whose values will be output 
double cub i cYards 
double totalPrice 
Program Constants 
double PRICE_PER_CUBIC_YD 
Additional Variables 
double cub i cFeet 
II number of cubic yards of mulc h needed 
II total 
price 
for all 
the cub i c yards ordered 
II the price 
for 1 delivered 
cubic yard of mulch 
II number of cub i c feet 
of mulc h needed 
Detailed Pseudocode (including actual variable names and needed 
calculations) 
PRICE_PER_CUBIC_ YD = 22.00 
Input squareFeet 
II with prompt 
Input depth 
I I with prompt 
cubicFeet 
= squareFeet 
* {depth I 12.0) 
cubicYards 
= cubicFeet 
I 27 
tota7Price 
= cubicYards 
* PRICE_PER_ CUBIC_ YD 
Display 
cubicYards, 
PRICE_ PER_ CUBIC_ YD, and tota7Price 
The Program 
The next step, after the pseudocode has been checked for logic errors, is to expand the 
pseudocode into the final program. This is shown in Program 3-34. 

140 
Chap ter 3 
Expressions and Interactivity 
Program 3-34 
1 II Thi s program is used by Green Fie l ds Landscap i ng to compute the 
2 II number of cubic yards of mul ch a custo mer needs and its 
pr i ce . 
3 #inc l ude <iostream> 
4 #inc l ude <iomanip> 
5 using namespace std ; 
6 
7 const double PRICE_PER_CUBIC_YD = 22 .00 ; 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
int main () 
{ 
double 
int 
double 
II Get 
cout << 
cin 
>> 
cout << 
cin 
>> 
sq uareFeet
; 
II 
depth ; 
II 
cub i cFeet , 
II 
cub i cYards , 
II 
total Price ; 
II 
inputs 
"Number of square 
squareFeet
; 
"Number of inches 
depth ; 
23 
II Perform calcu l at i ons 
square feet 
of land to be covered 
i nches deep the mulch is to be spread 
number of cubic feet 
of mulch needed 
number of cub i c yards of mul ch needed 
total 
price 
for all 
the cubic yards ordered 
feet 
to be covered with mulch : "· 
deep : " ; 
24 
cubicFeet 
= sq uareFeet 
* (depth 
I 12 .0); 
25 
cubicYards 
= cubicFeet 
I 27 ; 
26 
totalP
r ice = cubicYards 
* PRICE_PER_CUBIC_YD; 
27 
28 
II Di splay outputs 
29 
cout << "\ n Number of cubic yards needed : " << cubicYards 
<< endl ; 
30 
cout <<fixed<< 
showpoint << setprecision
(2); 
31 
cout << "Pr ice per cubic yard : $" << setw (7) 
32 
<< PRICE_PER_CUBIC_YD << end l; 
33 
cout << "Total 
pr i ce: 
$" << setw (7) 
34 
<< tota l Price 
<< end l << end l; 
35 
36 
ret urn O; 
37 } 
Program Output with Example Input Shown in Bold 
Number of square feet 
to be covered with mulch: 270[Enter] 
Number of inches 
deep: 12[Ent er] 
Number of cubic yards 
Price 
per cubic yard: 
Total price: 
needed: 
10 
$ 
22.00 
$ 220.00 
Program Output with Different Example Input Shown in Bold 
Number of square feet 
to be covered with mulch: 800[Enter] 
Number of inches 
deep: 3[Enter] 
Number of cubic yards needed: 7.40741 
Price 
per cubic yard: 
$ 
22.00 
Total price: 
$ 162.96 

3.13 
3.13 Tying It All Together: Word Game 
141 
General Crates, Inc., Case Study 
The following additional case study, which contains applications of material introduced in 
Chapter 3, can be found on the book's companion website at pearsonhighered.com/gaddis. 
This case study develops a program that accepts the dimensions on a crate to be built 
and outputs information on its volume, building cost, selling cost, and profit. The case 
study illustrates the major program development steps: initial problem statement, 
program design using hierarchy charts and pseudocode, development of the algorithm 
needed to create the outputs, source code for the final working program, and output 
created by running the program with several test cases. 
Tying It All Together: Word Game 
With the programming knowledge you have learned so far, you can start constructing 
simp le games . Here is one that creates a program to play a word game. It will ask the 
player to enter the following: 
• their name (name) 
• a food or product you can buy (product) 
• thenameofacity 
(city) 
• an adjective noun ( pet name) 
• a fun activity (activ i ty) 
• a number between 10 and 50 (age) 
• a type of anima l (animal) 
• a number between O and 15 (kids) 
Then it will display a story using those words. 
Program 3-35 
1 II Thi s program uses str i ngs to play a word game. 
2 #include 
<iostream> 
3 #include 
<str i ng> 
4 using namespace std; 
5 
6 int main() 
7 { 
II Stored strings 
string 
s1 
s2 
s3 
s4 
s5 
= "There once was a person named" 
="who 
l i ved in " 1 
= "\nand who loved" 
=" . At the age of", 
= " 
" 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
s6 
s7 
=" graduated 
\nfrom hi gh schoo l and went to work i n a" 
= " factory. \n", 
s8 
s9 
=" got married and had", 
=" children 
and a pet", 
s10=" 
named", 
s11= " . \nEvery weekend the family and" 
s12=" 
had fun", 
s13=" 
together
. "; 
22 
II Values i nput by the user 
23 
string 
name, city, 
activity, 
animal, 
product, 
petName; 
24 
int age, ki ds; 
25 
(program continues) 

142 
Chapte r 3 
Expressions and Interactivity 
Program 3-35 
(continued) 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 } 
cout << "Enter the fol l owing information 
and I\'11 
" 
<< "te l l you a story. \n\n"; 
cout << "Your name: " · 
getl i ne(cin, 
name); 
cout << "The name of a city: 
"· 
getl i ne(cin, 
city); 
cout << "A phys i cal act i vity 
(e.g. 
jogging, 
playing 
baseball): 
"· 
getl i ne(cin, 
activity); 
cout << "An animal: 
"; 
getl i ne(cin, 
ani mal); 
cout << "A food or product 
you can buy: "· 
getl i ne(cin, 
product}; 
cout << "An adjective 
noun (e.g. 
blue car}: 
"· 
getl i ne(cin, 
petName}; 
cout << "A number between 10 and 50: "· 
cin 
>> age; 
cout << "A number between O and 15: "· 
cin 
>> kids; 
cout << endl << s1 <<name<< 
s2 <<c i ty<< 
s3 << activity; 
cout << s4 <<age<< 
s5 <<name<< 
s6 <<product<< 
s7; 
cout <<name<< 
s8 <<kids<< 
s9 <<animal<< 
s10 << petName; 
cout << s11 << petName << s12 <<activity<< 
s13 << endl ; 
return 
O; 
Sample Run with User Input Shown In Bold 
Enter the following 
information 
and I'll 
tell 
you a story. 
Your name: Joe[Enter] 
The name of a city: 
Honolulu[Ent er] 
A physical 
activity 
(e.g. 
jogging, 
playing 
baseball): 
scubadlvlng[Enter] 
An animal: 
bear [Ente r] 
A food or product 
you can buy: potato chlp s[Enter] 
An adjective 
noun (e.g. 
blue car}: 
dlshrag[Enter] 
A number between 10 and 50: 20[Ent e r] 
A number between O and 15: 1 O[Enter] 
There once was a person named Joe who lived 
in Honolulu 
and who loved scuba diving. 
At the age of 20, Joe graduated 
from high school and went to work in a potato 
chips 
factory. 
Joe got married 
and had 10 children 
and a pet bear named dish rag. 
Every weekend the family and dish rag had fun scuba diving 
together. 
Try running this program with a variety of inputs. Then try modifying it to make up new stories. 

Review Questions and Exercises 
143 
Review Question s and Exercises 
Short Answer 
1. Assume a string object has been defined as follows: 
st ri ng descri pt ion ; 
A) Write a ci n statemen t that reads in a one word description . 
B) Write a statement that reads in a description that can contain mult iple words 
separa ted by blanks . 
2. Write a definition statement for a C-string (i.e., an array of characters) large 
enough to hold any of the following strings: 
"Bill y Bob's Pi zza" 
"Downt own Auto Suppl i es" 
"Bet ty Smit h School of Archit ectur e" 
"ABC Cabin et Company" 
3. Assume that the C-string name is defined as follows: 
cha r name[25]; 
A) Using a stream man ipula tor, write a ci n statement that will read a string into 
name but that will read no more characters than name can hold. 
B) Using the get l i ne function, write a ci n statemen t that will read a string into 
name but that will read no more characters than name can hold. 
4. Assume the following variables are defined: 
i nt age ; 
double pay; 
cha r sectio n ; 
Write a single ci n statement that will read inpu t into each of these variables. 
5. What header files must be included in the follow ing program? 
i nt main() 
{ 
} 
double amount= 
89.7; 
cout << f ix ed << showpoi nt << set precision(1); 
cout << setw(8) <<amou nt << endl ; 
ret urn O; 
6. Write a definit ion statemen t for a C-string named ci t y tha t can hold a string 
30 characters in length. 
7. Write a definition statemen t for a C++ string object that can hold a string 
30 characters in length. 

144 
Chapte r 3 
Expressions and Inte ractivity 
8. Complete the following table. 
Expression 
28 / 4 -
2 
6 + 12 * 2 -
8 
4 + 8 * 2 
6 + 17 % 3 -
2 
2 + 22 * (9 -
7) 
(8 + 7) * 2 
(16 + 7 ) % 2 -
1 
12 / (10 -
6 ) 
(19 -
3) * (2 + 2) / 4 
Value of the Expression 
9. Write C++ expressions for the following algebraic expressions: 
A) a= 12x 
B) z = Sx + 14y + 6k 
C) y = x 4 
D) g = 
E) g = 
h +12 
4k 
10. Assume a program has the following variable definitions 
int units
; 
fl oat mass; 
double weight ; 
and the following statement: 
weight= 
mass * units ; 
Which automat ic data type conversions will take place? 
11. Assume a program has the following variable definitions 
int a, b = 2; 
double c = 4.3; 
and the following statement: 
a = b * c; 
What value will be stored in a? 
12. Assume that qty and salesReps are both integers. Use a type cast expression to 
rewrite the following statement so it will no longer perform integer division. 
unitsEach 
= qty
/ salesReps; 

Review Questions and Exercises 
145 
13. Rewrite the following variable definition so the variable is a named constan t with 
the value 12. 
i nt rat e ; 
14. Complete the following table by writing statements with comb ined assignment 
operators in the right-hand column. The statements should be equivalent to the 
statements in the left-hand column. 
Statements with 
Assignment Operator 
X = X + 5; 
t ot al= 
t otal
+ subt ot al; 
dis t = di st/ 
rep; 
ppl = ppl * per iod ; 
i nv = inv - shri nkage ; 
num = num % 2 ; 
Statements with 
Combined Assignment Op erator 
15. Write a multiple assignment statement that can be used instead of the following 
group of assignment statements: 
east
= 1; 
west = 1; 
north = 1; 
south = 1; 
16. Write a pair of multiple assignment statemen ts that can be used instead of the 
following set of assignment statements. 
count= 
O; 
sal es= 
O; 
st art= 
1; 
day= 
1; 
orde rs = O; 
17. Replace the following statements with a single statement that initializes sum to 0 
at the time it is defined. 
i nt sum; 
sum= O; 
18. Is the following code legal? Why or why not? 
const int DAYS_IN_WEEK; 
DAYS_IN_WEEK = 7; 
19. Write a cout statement that uses stream manipulators to display the contents of 
the variable di vSa l es in a field of eight spaces, in fixed-point nota tion, with a 
decimal point and two decimal digits. 
20. Write a cout statement that uses stream manipulators to display the contents of 
the variable prof it in a field of 12 spaces, in fixed-point nota tion, with a decimal 
point and four decimal digits. 

146 
Chapte r 3 
Expressions and Inte ractivity 
21. What header file must be included 
A) to perform mathematical functions like sqr t ? 
B) to use ci n and cout? 
C) to use stream manipluators like setpreci si on? 
D) to use random numbers? 
Algorithm Workbench 
22. Pet World offers a 15 percent discount to senior citizens . Write a pseudocode 
algorithm for a program that inputs the amount of a sale, then calculates and 
displays both the amount the customer saves and the amount they must pay. 
23. A bowling alley is offering a prize to the bowler whose average score from 
bowling three games is the lowest . Write a pseudocode algorithm for a program 
that inputs three bowling scores and calculates and displays their average. 
24. A retai l store grants its customers a maximum amount of credit . Each customer's 
available credit is his or her maximum amount of credit minus the amount of 
credit used. Write a pseudocode algorithm for a program that asks for a customer's 
maximum credit and amount of credit used, then calcu lates and displays the 
customer's available credit . 
25. Little Italy Pizza charges $14.95 for a 12-inch diameter cheese pizza and $17 .95 
for a 14-inch diameter cheese pizza. Write the pseudocode for an algorithm that 
calcu lates and displays how much each of these earns the estab lishment per 
square inch of pizza sold . (Hint: You will need to first calculate how many square 
inches there are in each pizza.) 
Predict the Output 
26. Trace the following program segments and tell what each will display. (Some 
require a calcu lator. ) 
A) (Assum e the user enters 39000. Use a calculator.) 
double salary
, monthly; 
cout << "What i s your annual salary?"; 
cin 
>> salary; 
monthly= 
static
_cast<int>(salary) 
/ 12; 
cout << "Your monthl y wages are"<< 
mont hly<< 
endl ; 
B) unsigned 
i nt x, y, z; 
X = y = Z = 4; 
X += 2; 
y -= 1; 
z *= 3; 
cout << x <<" 
"<< 
y <<" 
'' << z << endl; 

27. A) (Assume the user enters George Washington .) 
string 
userlnput; 
cout << "What is your name?"; 
cin 
>> userlnput; 
cout <<"Hello"<< 
userlnput 
<< endl; 
B) (Assume the user enters George Washington.) 
string 
userlnput; 
cout << "What is your name?"; 
getline
(cin , userlnput); 
cout <<"Hello"<< 
userlnput 
<< endl; 
Find the Errors 
Review Questions and Exercises 
147 
28. Each of th e following program segments has some errors. Locate as many as 
you can . 
A) Cout << "Enter a number: ". 
' 
Cin 
<< number1 ; 
Cout << "Enter another 
number: ". 
Cin 
<< number2 ; 
number1 + number2 = sum; 
Cout "The sum of the two numbers is"<< 
sum 
B) int number1, number2; 
double quotient; 
cout << "Enter two numbers and I will 
divide\n"; 
cout << "the first 
by the second for you.\n"; 
cin 
>> number1 , number2; 
quotient= 
double<static_cast>(number1 
/ number2); 
cout << quotient 
29. A) const 
int number1, number2, product; 
cout << "Enter two numbers and I will 
multiply\n"; 
cout << "them for you.\n"; 
cin 
>> number1 >> number2; 
product= 
number1 * number2; 
cout << product 
B) int number; 
cout << "Enter an integer: 
"· 
cin 
>> number ; 
number=* 
50; 
cout << "Your number times 50 is"<< 
number<< 
endl; 

148 
Chapte r 3 
a 
VideoNote 
Solving the 
Stadium 
Seating 
Problem 
Expressions and Inte ractivity 
Soft Skills 
Often programmers work in teams with other programmers to develop a piece of 
software. It is important that the team members be able to communicate clearly with 
one another. 
30. Suppose you and a fellow student have been assigned to develop together the 
pizza cost program described in Problem 25. You have developed a pseudocode 
algorithm for the program and emailed it to your partner, but he does not 
understand how it works . Write a paragraph that you might email back clearly 
explaining how the algorithm works, what steps must be done, why they must be 
done in a particular order, and why the calculations you have specified in the 
pseudocode are the correct ones to use. Write your answer using full English 
sentences with correct spelling and grammar. 
Programming 
Challenges 
1. Miles per Gallon 
Write a program that calculates a car's gas mileage. The program should ask the user 
to enter the number of gallons of gas the car can hold and the number of miles it can be 
driven on a full tank . It should then calculate and display the number of miles per 
gallon the car gets. 
2. Stadium Seating 
There are three seating categories at a stadium . For a softball game, Class A seats cost 
$15, Class B seats cost $12, and Class C seats cost $9. Write a program that asks how 
many tickets for each class of seats were sold, then displays the amount of income 
generated from ticket sales. Format your dollar amount in a fixed-point notation with 
two decimal points and make sure the decimal point is always displayed. 
3. Housing Costs 
Write a program that asks the user to enter their monthly costs for each of the following 
housing-related expenses: 
• rent or mortgage payment 
• phones 
• utilities 
• cable 
The program should then display the total monthly cost of these expenses and the total 
annual cost of these expenses. 
4. How Much Insurance? 
Many financial experts advise property owners to insure their homes or buildings for 
at least 80 percent of the amount it would cost to replace the structure. Write a program 
that asks the user to enter the replacement cost of a building and then displays the 
minimum amount of insurance that should be purchased for the property . 

Programming Challenges 
149 
5. Batting Average 
Write a program to find a baseball player's batting average. The program should ask 
the user to enter the number of times the player was at bat and the number of hits 
earned. It should then display the batting average to four decimal places. 
6. Test Average 
Write a program that asks for five test scores. The program should calculate the average 
test score and display it. The number displayed should be formatted in fixed-point 
notation, with one decimal point of precision. 
7. Average Rainfall 
Write a program that calculates the average monthly rainfall for three months. The 
program should ask the user to enter the name of each month, such as June or July, and 
the amoun t of rain (in inches) that fell that month. The program should display a 
message similar to the following: 
The average monthly rainfall 
for June, 
July, 
and August was 6.72 inches. 
8. Male and Female Percentage s 
Write a program that asks the user for the number of males and the number of females 
registered in a class. The program should compute and report what percentage of the 
student s are males and what percentage are females. Display the output with two 
decimal points. If you remembered to convert the decimal result of each calculation to 
percent form when you displayed it, the two values should add up to 100.00 percent. 
9. Vacation Days 
Write a program that prompts the users to enter the number of days they plan to spend 
on their next vacation. Then compute and report how long that is in hours, in minutes, 
and in seconds. 
10. Box Office 
A movie theater only keeps 80 percent of the revenue earned from ticket sales. The other 
20 percent goes to the distibutor. Write a program that calculates a theater's gross and 
net box office revenue for a night. The program should ask for the name of the movie, 
and how many adult and child tickets were sold. (The price of an adult ticket is $10 and 
a child's ticket is $6.) It should display a report similar to the following: 
Movie Name: 
Adult Tickets Sold: 
Child Tickets Sold: 
Gross Box Office Revenue: 
Amount Paid to Distributor: 
Net Box Office Revenue: 
"Wheels of Fury" 
382 
127 
$ 4582.00 
- $ 916.40 
$ 3665.60 

150 
Chapte r 3 
Expressions and Inte ractivity 
11. How Many Widgets? 
The Yukon Widget Company manufactures widgets that weigh 12.5 pounds each. 
Write a program that calculates how many widgets are stacked on a pallet, based on 
the total weight of the pallet. The program should ask the user how much the pallet 
weighs by itself and with the widgets stacked on it. It should then calculate and display 
the number of widgets stacked on the pallet. 
12. How many Calories? 
A bag of cookies holds 30 cookies . The calorie information on the bag claims that 
there are 10 "servings" in the bag and that a serving equals 240 calories. Write a 
program that asks the user to input how many cookies they actually ate and then 
reports how many total calories were consumed. 
13. Ingredients Adjuster 
A cookie recipe calls for the following ingredients: 
• 1.5 cups of sugar 
• 1 cup of butter 
• 2. 75 cups of flour 
The recipe produces 48 cookies with these amounts of the ingredients. Write a program 
that asks the user how many cookies he or she wants to make and then displays the 
number of cups of each ingredient needed for the specified number of cookies. 
14. Celsius to Fahrenheit 
Write a program that converts Celsius temperatures to Fahrenheit temperatures . The 
formula is 
9 
F =- C + 32 
5 
where Fis the Fahrenheit temperature and C is the Celsius temperature. The program 
should prompt the user to input a Celsius temperature and shou ld display the 
corresponding Farenheit temperature. 
15. Currency 
Write a program that will convert U.S. dollar amounts to Japanese yen and to euros, 
storing the conversion factors in the constant variab les YEN_PER_DOLLAR and 
EUROS_PER_DOLLAR. To get the most up-to-date exchange rates, search the Internet 
using the term "currency exchange rate" or "currency converter." If you cannot find 
the most recent exchange rates, use the following: 
1 Dollar= 120.005 Yen 
1 Dollar= .881 Euros 

Programming Challenges 
151 
16. Monthly Sales Tax 
A retail company must file a monthly sales tax report listing the sales for the month 
and the amount of sales tax collected. Write a program that asks for the month, the 
year, and the total amount collected at the cash register (that is, sales plus sales tax ). 
Assume the state sales tax is 4 percent and the county sales tax is 2 percent. 
If the total amount collected is known and the total sales tax is 6 percent, the amount 
of product sales may be calculated as 
T 
S =-
1.06 
where S is the product sales and Tis the total income (product sales plus sales tax). 
The program should display a report similar to the following: 
Month: August 2016 
--------------------
Total 
Collected: 
$ 26572 .89 
Sales: 
$ 25068 .76 
County Sales Tax: 
$ 
501 .38 
State 
Sales 
Tax: 
$ 
1002.75 
Total 
Sales 
Tax: 
$ 
1504 .13 
17. Property Tax 
Madison County collects property taxes on the assessed value of property, which is 
60 percent of its actual value. For example, if a house is valued at $158,000, its assessed 
value is $94,800 . This is the amount the homeowner pays tax on. At last year's tax rate 
of $2.64 for each $100 of assessed value, the annua l property tax for this house would 
be $2502.72 . Write a program that asks the user to input the actual value of a piece of 
property and the current tax rate for each $100 of assessed value. The program should 
then calculate and report how much annual property tax the homeowner will be 
charged for this property. 
18. Senior Citizen Property Tax 
Madison County provides a $5000 homeowner exemption for senior citizens. For 
example, if their house is valued at $158,000 its assessed value would be $94,800, as 
explained above. However they would only pay tax on $89,800 . At last year's tax rate 
of $2.64 for each $100 of assessed value, their property tax would be $2370 .72. In 
addition to the tax break, senior citizens are allowed to pay their property tax in four 
equal payments. The quarterly payment due on this property would be $592.68. Write 
a program that asks the user to input the actual value of a piece of property and the 
current tax rate for each $100 of assessed value. The program should then calculate 
and report how much annua l property tax a senior homeowner will be charged for this 
property and what their quarterly tax bill will be. 

152 
Chapter 3 
Expressions and Interactivity 
19. Math Tutor 
Write a program that can be used as a math tutor for a young student . The program 
shou ld display two random numbers between 1 and 9 to be added, such as 
2 
+1 
After the student has entered an answer and pressed the [Enter J key, the program 
shou ld display the correct answer so the student can see if his or her answer is correct . 
20. Interest Earned 
Assuming there are no deposits other than the origina l investment , the balance in a 
savings account after one year may be calculated as 
Amount = Principal ,. ( 1 + R~te) T 
• where Principa l is the balance in the account 
• Rate is the annual interest rate, 
• Tis the number of times the interest is compounded during a year (e.g., Tis 4 if 
the interest is compounded quarterly ). 
Write a program that asks for the principal, the interest rate, and the number of times 
the interest is compounded . It should display a report similar to the following: 
Interes t Rat e: 
4.25% 
Times Compounded: 
12 
Pri ncipal: 
$ 1000 .00 
Interes t : 
$ 
43 .33 
Final balance: 
$ 1043.33 
21. Monthly Payments 
The monthly payment on a loan may be calculated by the following formu la: 
P 
Rate* (l + Rate)N 
ayment = ----'-----
*L 
(1 + Rate)N - 1 
• Rate is the monthly interest rate, which is the annual interest rate divided by 12. 
(A 12 percent annua l interest would be 1 percent monthly interest.) 
• N is the number of payments 
• 
L is the amount of the loan. 
Write a program that asks for these values and displays a report similar to the following: 
Loan Amount: 
$ 10000 . 00 
Monthl y Interest 
Rate: 
1% 
Number of Payment s: 
36 
Monthl y Payment: 
$ 
332 . 14 
Amount Paid Back: 
$ 11957 . 15 
Interes t Pai d: 
$ 
1957 . 15 

Programming Challenges 
153 
22. Pizza Slices 
Joe's Pizza Palace needs a program to calculate the number of slices a pizza of any size 
can be divided into. The program should perform the following steps: 
A) Ask the user for the diameter of the pizza in inches. 
B) Divide the diameter by 2 to get the radius. 
C) Calculate the number of slices that may be taken from a pizza of that size if 
each slice has an area of 14.125 square inches. 
D) Display a message telling the number of slices. 
The number of square inches in the total pizza can be calculated with this formula: 
Area= 1tr2 
where variable r is the radius of the pizza and 1t is the Greek letter Pl. In your program 
make PI a named constant with the value 3.14. Display the number of slices as a whole 
number (i.e., with no decimals). 
23. How Many Pizzas? 
Modify the program you wrote in Programming Challenge 22 so that it reports the 
number of pizzas you need to buy for a party if each person attending is expected to eat 
an average of four slices. The program should ask the user for the number of people 
who will be at the party and for the diameter of the pizzas to be ordered. It should then 
calculate and display the number of pizzas to purchase. Because it is impossible to buy 
a part of a pizza, the number of required pizzas should be displayed as a whole number. 
24. Angle Calculator 
Write a program that asks the user for an angle, entered in radians . The program 
should then display the sine, cosine, and tangent of the angle. (Use the sin, cos, and 
t an library functions to determine these values.) The output should be displayed in 
fixed-point notat ion, rounded to four decimal places of precision. 
25. Stock Transaction Program 
Last month Joe purchased 100 shares of stock for $45 .50 per share and paid his 
stock broker a commission that amoun ted to 2 percent of the total amoun t he paid 
for the stock. 
Two months later Joe sold the stock for $47.92 per share and paid his stock broker another 
commission that amounted to 2 percent of the total amount he received for the stock. 
Write a program that displays the following information: 
• The amount of money Joe paid for the stock. 
• The amoun t of commission Joe paid his broker when he bought the stock. 
• The amount that Joe sold the stock for. 
• The amount of commission Joe paid his broker when he sold the stock. 
• The amount of profit or loss that Joe had after selling his stock and paying both 
broker commissions. 


TOPICS 
4.1 
4.2 
4.3 
4.4 
4.S 
4.6 
4.7 
4.8 
4.9 
4.1 
Relational Ope rators 
4.10 
More about Characters and Strings 
The if Statement 
4.11 
The Conditional Operato r 
The if/ e 1 se Statement 
4.12 
The switc h Statement 
The if/ e 1 se i f Statement 
4.13 
Enumerated Data Types 
Menu-Driven Programs 
4.14 
Focus on Testing and Debugging: 
Nested if Statements 
Validating Output Results 
Logical Operators 
4.lS 
Green Fields Landscaping Case 
Validating User Input 
Study- Part 2 
More about Blocks and Scope 
4.16 
Tying It All Togethe r: Fortune Teller 
Relational Operators 
CONCEPT: 
Relational operators allow you to compare num eric and c ha r values 
and determine whether one is greater than, Jess than, equal to, or not 
equal to another. 
So far, the programs you have written follow this simple scheme: 
• Gather input from the user. 
• Perform one or more calculations . 
• Display the results on the screen. 
Computers are good at performing calculations, but they are also quite adept at comparing 
values to determine if one is greater than , less than , or equal to, the other. These types of 
operations are valuable for tasks such as examining sales figures, determining profit and 
loss, checking a number to ensure it is within an acceptable range, and validating the 
input given by a user. 
155 

156 
Chapte r 4 
Making Decisions 
Numeric data is compared in C++ by using relational operators. Characters can also be 
compared with these operators because characters are considered numer ic values in 
C++. Each relational operator determines whether a specific relationship exists between 
two values. For example, the greater-than operator(>) determines if a value is greater 
than another. The equality operator(==) determines if two values are equal. Table 4-1 
lists all of C++'s relational operators . 
Table 4-1 Relational Operators 
Relation al 
Operators 
> 
< 
>= 
<= 
!= 
0 
Meaning 
Greater than 
Less than 
Greater than or equal to 
Less than or equal to 
Equal to 
Not equal to 
NOTE: 
All the relational operators are binary operators with left-to -right 
associativity . Recall that associativity is the order in which an operator works with 
its operands . 
All of the relationa l operators are binary . This means they use two operands . Here is 
an example of an expression using the greater-than operator: 
X > y 
This expression is called a relational expression . It is used to determine whether x is 
greater than y. The following expression determines whether x is less than y: 
X < y 
The Value of a Relationship 
So, how are relational expressions used in a program? Remember, all expressions have 
a value. Relational expressions are Boolean expressions, which means their value can 
only be true or false. If x is greater than y, the expression x > y will be true and the 
expression x < y will be false. 
The == operator determines whether the operand on its left is equal to the operand on 
its right. If both operands have the same value, the expression is true. Assuming that a 
is 4, the following expression is true: 
a== 
4 
and the following expression is false: 
a== 
2 

CD 
4.1 Relational Operato rs 
157 
WARNING! 
Not ice the equa lity operator is two = symbols together. Don't 
confuse this operator with the assignment operator, which is one = symbol. The == 
operator determines if a variable is equal to another value, but the = operator assigns 
the value on the operator's right to the variable on its left. There will be more about 
this later in the chapter. 
Two of the relational operators actually test for a pair of relationships. The>= operator 
determines whether the operand on its left is greater than OT equal to the operand on 
the right. If a is 4, b is 6, and c is 4, both of the following expressions are true: 
b >= a 
a>= 
C 
and the following expression is false: 
a>= 
5 
The <= operator determines whether the operand on its left is less than OT equal to the 
operand on its right. Once again, if a is 4, b is 6, and c is 4, both of the following 
expressions are true: 
a<= 
C 
b <= 10 
and the following expression is false: 
b <= a 
The last relationa l operator is ! =, which is the not -equa l operator. It determ ines 
whether the operand on its left is different than (i.e., not equal to) the operand on its 
right, which is the oppos ite of the == operator. As before, if a is 4, b is 6, and c is 4, 
both of the following expressions are true: 
a!= 
b 
b != C 
These expressions are true because a is not equal to b and b is not equal to c. However, 
the following expression is false because a is equal to c: 
a!= 
C 
Table 4-2 shows other relational expressions and their true or false values. 
Table 4-2 Example Relational Expressions (Assume x is 10 and y is 7 .) 
Expression 
X < y 
X > y 
X >= y 
X <= y 
y != X 
Value 
False, because x is not less than y. 
True , because x is greater than y. 
True , because x is greater than or equal to y. 
False, because x is not less than or equal toy. 
True , because y is not equal to x. 

158 
Chapte r 4 
Making Decisions 
What Is Truth? 
If a relational express ion can evaluate to either true or false, how are those values 
represented internally in a program? How does a compute r store true in memory? How 
does it store false? 
As you saw in Program 2-16, those two abstract states are converted to numbers. This 
can be confusing, especially for new programmers , because in C++ zero is considered 
false and any nonzero value is considered true. The C++ keyword fa l se is stored as 0, 
and the keyword true is stored as 1. And when a relational expression is false, it 
evaluates to 0. However, when a relational expression is true, it does not always evaluate 
to 1. Though it usually does, it can actually evaluate to any nonzero value. 
To illustrate this more fully, look at Program 4-1. 
Program 4-1 
1 // Thi s program displays 
the values 
C++ uses to represent 
true and false . 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
bool trueValue , fa ls eValue ; 
8 
int 
X = 5, y = 1 0; 
9 
10 
trueValue 
= (x < y); 
11 
falseValue = (y == 
x); 
12 
13 
cout << "True 
is"<< 
trueValue 
<< endl ; 
14 
cout << "False i s"<< 
fa l seVal ue << endl; 
15 
return 
O; 
16 ) 
Program Output 
True 
is 1 
False is O 
Let's examine the statements conta ining the relational expressions a little closer: 
trueValue 
= (x < y); 
falseValue = (y == 
x); 
These statements may seem odd because they are assigning the value of a comparison 
to a variable. In the first statement, the variab le trueVal ue is being assigned the result 
of x < y. Because xis less than y, the expression is true, and the variable trueVal ue is 
assigned a nonzero value. In the second statement, the expression y == x is false, so the 
variable fa l seVal ue is set to 0. 
When writing statements such as these, most programmers enclose the relational 
expression in parentheses, as shown above, to make it clearer. 

4.1 Relational Operators 
159 
Parentheses are not actually required, however, because even without them the relationa l 
operation is carr ied out before the assignment operation is performed . This occurs 
because relational operators have a higher precedence than the assignment operator. 
Likewise, arithmetic operators have a higher precedence than relationa l operators. 
The statement 
resul t = x < y -
8; 
is equivalent to the statement 
resul t = x < (y -
8); 
In both cases, y -
8 is evaluated first. Then this value is compared to x. Notice, 
however, how much clearer the second statement is. It is always a good idea to place 
parentheses around an arithmetic expression when its result will be used in a relational 
expression . 
Table 4-3 shows examples of other statements that include relational expressions. 
Table 4-3 Statements that Include Relational Expressions 
(Assume x is 10, y is 7, and z is an ; nt or bool .) 
Statement 
Out come 
Z = X < y 
cout << (x > y); 
z = (x >= y); 
cout << (x <= y); 
z = (y ! = x); 
z is assigned O because xis not less than y. 
Displays 1 because x is greater than y. 
z is assigned 1 because xis greater than or equal to y. 
Displays O because x is not less than or equal to y. 
z is assigned 1 because y is not equal to x. 
cout << (x == (y + 3)); 
Displays 1 because x is equal to y + 3. 
Relationa l operators also have a precedence order among themselves. The two 
operators that test for equality or lack of equality(== and ! =) have the same precedence 
as each other. The four other relationa l operators, which test relative size, have the 
same precedence as each other. These four relative relational operators have a higher 
precedence than the two equality relational operators. Tab le 4-4 shows the precedence 
of relational operators . 
Table 4-4 Precedence of Relational Ope rators (Highest to Lowest) 
> 
>= 
< 
<= 
!= 

160 
Chapte r 4 
Making Decisions 
Here is an example of how this is applied . If a = 9, b = 24, and c = o, the following 
statement displays a 1. 
cout << (c ==a> 
b); 
Because of the relative precedence of the operators in this expression, a > b is evaluated 
first. Since 9 is not greater than 24, it evaluates to false, or 0. Then c == O is evaluated. 
Because c does equal 0, this evaluates to true, or 1. So a 1 is inserted into the output 
stream and printed . 
In the remaining sections of this chapter, you will see how to get the most from 
relational expressions by using them in statements that take action based on the results 
of the comparison . 
~ 
Checkpoint 
4.1 
Assuming x is 5, y is 6, and z is 8, indicate whether each of the following 
relational expressions is true or false: 
A) X == 5 
B) 7 <= (x + 2) 
C) z > 4 
D) (2 + x) != y 
E) z != 4 
F) X >= 0 
G) X <= (y * 2) 
4.2 
Indicate whether each of the following statements about relational expressions 
is correct or incorrect . 
A) x <= y is the same as y > x . 
B) x ! = y is the same as y >= x. 
C) x >= y is the same as y <= x. 
4.3 
Answer the following questions with a yes or no. 
A) If it is true that x > y and it is also true that x < z, does that mean y < z 
is true? 
B) If it is true that x >= y and it is also true that z == x, does that mean that 
z == y is true? 
C) If it is true that x ! = y and it is also true that x ! = z , does that mean that 
z ! = y is true? 
4.4 
What will the following program segment display? 
i nt a= 
0, b = 2 , x = 4, y = O; 
cout << (a --
b) << 
<< (b <= x) << 
II 
II 
II 
II << (a != y) <<" 
" 
<< (y >a)<< 
endl; 

a 
VideoNot e 
Using an if 
Statement 
Figure 4-1 
4.2 The i f Statement 
161 
The i f Statement 
CONCEPT: 
The if statement can cause other statements to execute only under 
certain condition s. 
You might think of the statements in a procedural program as individual steps taken as 
you are walking down a road . To reach the destinat ion, you must start at the beginning 
and take each step, one after the other, until you reach the destination . The programs 
you have written so far are like a "path" of execution for the program to follow. 
Step 1 • 
Step.2 ' 
'
&;p3 
// A program to calculate 
t he area of a rectangle 
#include <iostream> 
using namespace std; 
i nt main() 
{ 
double lengt h, width , area; 
Step4. ' 
cout << "Enter t he lengt h of t he rectangle: 
"; 
i &:ps 
cin 
>> len gth; 
I ,. 
cout << "Enter t he width of the rec tangle : "; 
Step6 ' 
cin 
>> widt h; 
. --- ~ 
..,_ area= 
lengt h* widt h; 
( 
cout << "The area is : " <<area<< 
endl ; 
I 
return O; 
} 
The type of code in Figure 4-1 is called a sequence structur e because the statements are 
executed in sequence, one after another, without branching off in another direction. 
Programs often need more than one path of execution , however. Many algorithms 
require a program to execute some statements only under certain circumstances. This 
can be accomplished with a decision structur e. 
In a decision structure's simplest form an action, or set of actions, is carried out only 
when a specific condit ion exists . If the condit ion does not exist, the actions are not 
performed . The flowchart in Figure 4-2 shows the logic of a decision structure . The 
diamond symbol represents a yes/no question or a true/false condit ion. If the answer to 
the question is yes (or if the condit ion is true ), the program flow follows one path, 
which leads to the actions being performed. If the answer to the question is no (or the 
condition is false), the program flow follows another path, which skips the actions. 

162 
Chapter 4 
Figure 4-2 
Figure 4-3 
Making Decisions 
No 
outside? 
Yes 
Wear a coat. 
Wear a hat. 
Wear gloves. 
In the flowchart, the actions "Wear a coat", "Wear a hat", and "Wear gloves" are 
performed only when it is cold outside . If it is not cold outs ide, these actions are 
skipped . The actions are conditionally executed because they are performed only when 
a certain condition (cold outside) exists. 
We perform mental tests like these every day. Here are some other examples: 
If the car is low on gas, stop at a service station and get gas. 
If it's raining outside, go inside. 
If you're hungry, get something to eat. 
The most common way to code a decision structure in C++ is with the if statement. 
Figure 4-3 shows the general format of the if statement and a flowchart visually 
depicting how it works . 
if ( condition) 
if 
(condition) { 
{ 
statement 1 ; 
statement 1 ; 
statement 2; 
or 
statement 2; 
true 
statement n; 
statement n; 
statement(s) 
) 
} 

4.2 The if Statement 
163 
Notice that the statements inside the body of the if construct are contained within 
a set of curly braces. This creates what C++ calls a block and lets the comp iler know 
which statements are associated with the if. The opening brace must be located 
after the if condition and before the first statement in the body. However, while 
following this requirement, different programmers choose different places to locate 
it. The two most common placements are shown in Figure 4-3. This book uses 
the form shown on the left. Your instructor will tell you what form he or she wants 
you to use. 
Program 4-2 illustrates the use of an i f statement . The user enters three test scores and 
the program calculates their average. If the average equals 100, the program congratulates 
the user on earning a perfect score. 
Program 4-2 
1 // Thi s program correctly 
averages 
3 test 
scores. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
int score1, 
score2, 
score3; 
9 
double average; 
10 
11 
// Get the three 
test 
scores 
12 
cout << "Enter 3 test 
scores 
and I wi ll average 
them: "; 
13 
cin 
>> score1 >> score2 >> score3; 
14 
15 
// Calculate 
and display 
the average 
score 
16 
average= 
(score1 
+ score2 
+ score3) 
/ 3.0; 
17 
cout <<fixed<< 
showpoint << setprec
i s i on(1); 
18 
cout << "Your average 
is"<< 
average<< 
endl; 
19 
20 
21 
22 
23 
II 
if 
{ 
24 
} 
If the average equals 
100, 
(average== 
100) 
cout << "Congratula
t i ons! 
cout << "That's 
a perfect 
25 
return 
O; 
26 } 
congratulate 
the 
". 
' 
score!\n"; 
user 
Program Output with Example Input Shown in Bold 
Enter 3 test 
scores 
and I wi 11 average 
them: 80 90 70[Enter] 
Your average 
is 80.0 
Program Output with Other Example Input Shown in Bold 
Enter 3 test 
scores 
and I wi 11 average 
them: 100 100 lOO[Enter] 
Your average 
is 100.0 
Congratulations! 
That's 
a perfect 
score! 

164 
Chapte r 4 
Making Decisions 
Let's look more closely at lines 21- 24 of Program 4-2, which cause the congratulatory 
message to be printed. 
i f (average== 
100) 
{ 
cout << "Congratulat
i ons! "; 
cout << "That 's a perfect 
score!\ n"; 
} 
There are four important things to notice . First, the word if , wh ich begins the 
statement, is a C++ key word and must be written in lowercase. Second, the condition 
to be tested (average == 100) must be enclosed inside parentheses . Third, there is no 
semicolon after the test condition, even though there is a semicolon after each action 
associated with the if construct . We will explain why shortly. And finally, the block of 
statements to be cond itionally executed is surrounded by curly braces. This is required 
whenever two or more actions are associated with an if statement . 
If there is only one statement to be cond itionally executed, the braces can be omitted. 
For example, in Program 4-2 if the two cout statements were combined into one 
statement, they could be written as shown here. 
i f ( average == 100) 
cout << "Congratula ti ons! That's 
a perfect 
score!\n"; 
However, some instructors prefer that you always place braces around a conditionally 
executed block, even when it consists of only one statement . 
Table 4-5 shows other examp les of i f statements and their outcomes . 
Table 4-5 Example if Statements 
Statements 
Outcome 
if (hours> 
40) 
Assigns true to Boolean variable over Ti me and doubles 
payRate only when hours is greater than 40 . Because there is 
more than one statement in the conditionally executed block, 
braces {} are required . 
{ 
over Ti me = true; 
payRate *= 2 ; 
} 
if (t emperature> 
32) 
free zing= 
false; 
Assigns false to Boolean variable free zi ng only when 
t emperat ure is greater than 32. Because there is only one 
statement in the conditionally executed block, braces {} are 
optional. 
Programming 
Style and the if Statement 
Even though if statements usually span more than one line, they are technically one 
long statement . For instance , the following i f statements are identica l except in style: 
i f (a >= 100) 
cout << "The number i s out of range.\n"; 
i f (a>= 
100) cout << "The number i s out of range.\ n"; 

4.2 The if Statement 
165 
The first of these two i f statements is considered to be better style because it is easier 
to read. By indenting the conditionally executed statement or block of statements, you 
cause it to stand out visually so you can tell at a glance what part of the program the 
if statement executes . This is a standard way of writing if statements and is the 
method you should use. Here are two important style rules for writing if statements: 
• The conditionally executed statement(s) should begin on the line after the if 
statement . 
• The condit ionally executed statement(s) should be indented one "level" from the 
i f statement . 
0 
NOTE: In most editors, each time you press the tab key, you are indenting one level. 
Three Common Errors to Watch Out For 
When writing if statements, there are three common errors you must watch out for. 
1. Misplaced semicolons 
2. Missing braces 
3. Confusing= with = = 
Be Careful with Semicolons 
Semicolons do not mark the end of a line. They mark the end of a complete C++ statement. 
The if construct isn't complete without the one or more conditionally executed statements 
that come after it. So you must not put a semicolon after the if 
(condition) portion of 
an if statement . 
i f (condition) 
{ 
} 
statement 1; 
statement 2; 
statement n; 
..,.41---
No semicolon goes here 
Semicolons go here 
If you inadvertently put a semicolon after the if part, the compiler will assume you are 
placing a null statement there . The null statement is an empty statement that does 
nothing. This will prematurely terminate the if statement, which disconnects it from 
the block of statements that follows it. These statements will then always execute. For 
example, notice what would have happened in Program 4-2 if the if statement had 
been prematurely terminated with a semicolon, like this: 

166 
Chapte r 4 
0 
Making Decisions 
i f (average== 
100); 
{ 
//Error.
The se micolo n ter mina t es 
// t he i f statement 
pre mat urely . 
cout << "Congratulations! 
"; 
cout << "That's 
a perfec t score!\n"; 
} 
Output of Revised Program 4-2 with Example Input Shown in Bold 
Enter 3 tes t scores 
and I wi 11 average 
t hem: 80 90 70(Enter] 
Your average 
is 80.0 
Congratulations! 
That 's a perfect 
score! 
Because the if statement ends when the premature semicolon is encountered, the cout 
statements inside the braces are no longer part of it. Therefore, they always execute, 
regardless of whether or not average equals 100. This erroneous version of Program 
4-2 can be found in the Chapter 4 programs folder on the book's companion website 
as Program 4-2B. 
NOTE: 
Indentation and spacing are for human readers of a program, not the 
computer. Even though the cout statements inside the braces in the above example 
are indented, the semicolon still terminates the if construct. 
Don't Forget the Braces 
If you intend to conditionally execute a block of statements rather than just one 
statement with an i f statement, don't forget the braces . Without a set of braces, 
the if condition only determines whether or not the very next statement will be 
executed. Any following statements are considered to be outside the if statement 
and will always be executed. For examp le, notice what would have happened in the 
origina l Program 4-2 if the braces enclosing the two cou t statements had been 
omitted . 
i f (average== 
100) 
cout 
<< "Congratula
ti ons! "; 
// There are no braces . 
cout << "That's 
a perfect 
score!\n"; 
// Thi s i s outside 
the if. 
Output of Program 4-2 Revised a Second Time with Example Input Shown in Bold 
Enter 3 tes t scores 
and I wi 11 average 
t hem: 80 90 70(Enter] 
Your average 
is 80.0 
That's 
a perfect 
score! 
With no braces around the set of statement to be conditionally executed, only the first 
of these statements belongs to the if construct . Because the condition in our test case 
( average 
== 100) was false, the Congratulations! 
message was skipped . However 
the cout statement that prints That 's a perfect 
score! was executed, as it would be 
every time, regardless of whether or not average equals 100. This erroneous version of 
Program 4-2 can be found in the Chapter 4 programs folder on the book's companion 
website as Program 4-2C. 

4.2 The if Statement 
167 
Don't Confuse == With = 
Earlier you saw a warning not to confuse the equal ity operator (==) with the assignment 
operator ( =), as in the following state ment: 
if 
(x = 2) 
II Caution here! 
cout << "It i s True!" ; 
This statement does not determine whether x is equal to 2; instead it assigns x the 
value 2! Furth ermore, the cout statement will always be executed because the expression 
x = 2 evaluates to 2, which C++ considers true . 
This occurs because the value of an assignment expression is the value being assigned 
to the variable on the left side of the = operator. Therefore, the value of the expression 
x = 2 is 2. Earlier you learned that C++ stores the value true as 1. However, it actually 
considers all nonzero values, not just 1, to be true . Thus, 2 represents a true condit ion. 
Let's examine this more closely by looking at yet another variation of the original 
Program 4-2. This time notice what would have happened if the equal -to relational 
operator in the if condition had been replaced by the assignment operator, as shown here. 
i f (average
= 100) 
{ 
II Error. 
This assigns 
100 to average . 
cout << "Congratulat
i ons! "; 
cout << "That ' s a perfect 
score!\ n"; 
} 
Output of Program 4-2 Revised a Third Time with Example Input Shown in Bold 
Enter 3 tes t scores and I wi 11 average t hem: 80 90 70(Enter] 
Your average is 80.0 
Congratulations! 
That ' s a perfect 
score! 
Rather than compa ring average to 100, the i f statement assigns it the value 100. This 
causes the if test to evaluate to 100, which is considered true. Therefore, the two cout 
statements will execute every time, regardless of what test scores are entered by the 
user. This erroneous version of Program 4-2 can be found in the Chapter 4 programs 
folder on the book's compan ion website as Program 4-2D. 
More about Truth 
Now that you've gotten your feet wet with relationa l expressions and if statements, 
let's look further at the subject of truth. You have seen that a relational expression has 
the value 1 when it is true and O when false. You have also seen that while O is 
considered false, all values other than O are considered true. This means that any value, 
even a negative number, represents true as long as it is not 0. 
Just as in real life, truth is a complicated thing. Here are the rules you have seen so far: 
• When a relational expression is true, it has a nonzero value, which in most cases 
is represented by the value 1. 
• When a relational expression is false, it has the value 0. 
• An expression that has the value O is considered false by the i f statement . This 
includes the bool value false , which is equivalent to 0. 
• An expression that has any value other than O is considered true. This includes 
the bool value t rue, which is equivalent to 1. 

168 
Chapte r 4 
Making Decisions 
The fact that the i f statement considers any nonzero value as true opens many 
possibilities. Relational expressions are not the only conditions that may be tested. For 
example, if the variable value is an integer, the following is a legal if statement in C++: 
i f (value) 
cout << "It is True!"; 
If value contains any number other than 0, the if condition will evaluate to true , and 
the message "It 
i s True!" will be displayed. If value is set to 0, however , the i f 
condition will evaluate to false , and the cout statement will be skipped . Here is 
another example: 
i f (x + y) 
cout << "It is True!"; 
In this statement the sum of x and y is tested. If the sum is 0, the expression is considered 
false; otherwise it is considered true. You may also use the return value of a function 
call as a conditional expression . Here is an examp le that uses the pow function: 
i f (pow(a, b)) 
cout << "It is True!"; 
This if statement uses the pow function to raise a to the power of b. If the result is anything 
other than 0, the cout statement will be executed. 
Flags 
A flag is a variable that signals whether or not some cond ition currently exists in a 
program. Because bool variables hold the values true and false , they are the perfect 
type of variables to use for flags. When the flag variable is set to true , it means the 
cond ition does exist. When the flag variable is set to false , it means that the condition 
does not exist, at least not yet. 
For example, suppose a program that calculates sales commissions has a Boolean variable, 
defined and initialized as shown here: 
bool salesQuo t aMet = false; 
In the program , the sa l esQuotaMet variable is used as a flag to indicate whether a 
salesperson has met the sales quota . When we define the variab le, we initialize it with 
false because we do not yet know if the salesperson has met the quota. Assuming a 
variable named sales holds the amount of sales, code similar to the following might 
appear in the program . 
i f (sales>= 
QUOTA
_AMOUN
T) 
sales QuotaMet = t rue; 
If the test condition is true (i.e., sales is greater than or equal to the QUOTA_AMOUNT
), 
the flag sal esQuotaMet is set to true . Otherwise , it remains false . 

Later in the program we might test the flag in the following way: 
if (salesQuotaMet ) 
cout << "You have met your sales quota! \n" ; 
4.2 The if Statement 
169 
This code displays "You have met your sales quota!" if the boo! variable sal esQuotaMet 
is true. Otherwise, it does not display anything. Notice that we did not have to use 
the == operator to explicitly compare the sa l esQuotaMet variable with the value true. 
The above code is equiva lent to the following: 
if (salesQuotaMet == true) 
cout << "You have met your sales quota! \n" ; 
Integer Flags 
Integer variables may also be used as flags. Thi s is because in C++ the value O is 
considered false and any nonzero value is considered true. In the sales commission 
program previously described, we could define the sa l esQuotaMet variable with the 
following statement: 
int salesQuotaMet = O; 
II O means false 
As before, we initialize the variable with 0, meaning false, because we do not yet know 
if the sales quota has been met. After the sales have been calculated, we can use code 
similar to the following: 
if (sales>= 
QUOTA_AMOUNT
) 
salesQuotaMet = 1; 
II 1 means true 
Later in the program we could test the flag like this: 
if (salesQuotaMet ) 
II Any value other than O evaluates 
to true 
cout << "You have met your sales quota! \n" ; 
This is equivalent to the following: 
if (salesQuotaMet 
!= 0) 
cout << "You have met your sales quota!\n"
; 
~ 
Checkpoint 
4.5 
Write an if statement that performs the following logic: If the value of variable 
price is greater than 500, then assign 0.2 to the variable di scountRate . 
4.6 
Write an if statement that multiplies payRate by 1.5 if hours is greater than 40. 
4. 7 
Write an i f statement that performs the following logic: If the variable sales is 
greater than 50,000, then assign 0.25 to the commi ssi onRate variable and assign 
250 to the bonus variable . 
4.8 
TRUE or FALSE: Both of the following if statements perform the same 
operat ion. 
if (calls 
== 20 ) 
rate*= 
0 .5; 
i f (cal ls
= 20 ) 
rate*= 
0.5; 

170 
Chapte r 4 
4.3 
a 
VideoNot e 
Using an 
if /else 
Statement 
Figure 4 -4 
Making Decisions 
4.9 
Write an i f statement that performs the following logic: If the variable named 
ti cketsSo l d is equal to 200, then set the Boolean flag variab le sol dOut to true; 
4 .10 
Write an if statement that print s "The performance is sold out! " if the Boolean 
flag variab le sol dOut is set to true. 
4 .11 
Although the following code segments are syntactically correct, each contains 
an error. Locate the error and indicate what is wrong . 
A) 
hours = 12 ; 
if (hours> 
40); 
cout <<hours<<" 
hours qualifies 
for over-time .\n"; 
B) i nterestRate 
= . 05; 
if (interestRate 
= . 07) 
cout << "This acco unt is earning the maximum rate.
\n"; 
C) i nterestRate 
= . 05; 
if (interestRate 
> . 07) 
cout << "This acco unt earns a $10 bonus. \n"; 
balance+= 
10 .0; 
The i f / e 1 se Statement 
CONCEPT: 
Th e if I else statement will execute one set of statements when the if 
condition is true and another set when the condition is false. 
Th e if /els e statement is an expans ion of the if statement . Figure 4-4 shows the 
general format of this statement and a flowchart visually depicting how it works . 
if ( condition) 
{ 
true 
false 
statement set 1 ; 
} 
else 
statement 
statement 
{ 
set 1 
set 2 
statement set 2; 
} 
As with the if statement , a condition is tested. If the condition is true, a block containing 
one or more statements is executed. If the condition is false, however, a different group 
of statements is executed. Program 4-3 uses the if/else 
statement along with the 
modulus operator to determine if a number is odd or even. 

4.3 The i f / else Statement 
171 
Program 4-3 
1 // 
Thi s program uses the modulus operator 
to determine 
2 II 
if a number is odd or even . If the number is evenly di visible 
3 II by 2 , i t is an even number . A remai nder indicates 
it i s odd . 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
int number; 
10 
11 
cout << "Enter an integer 
and I will 
tel l you if it \n"; 
12 
cout << "is odd or even. 
"; 
13 
cin 
>> number ; 
14 
15 
16 
17 
18 
19 
20 } 
if (number % 
cout << 
els e 
cout << 
return o· ' 
2 -- 0) 
number << " is even . \n"; 
number << " is odd. \ n"; 
Program Output with Example Input Shown in Bold 
Enter an integer 
and I will 
tell 
you if it 
is odd or even. 
17[Ent er] 
17 is odd. 
The else part at the end of the if statement specifies one or more statements that are to 
be executed when the condition is false. When number % 2 does not equal 0, a message 
is printed indicating the number is odd . Note that the program will only take one of the 
two paths in the if I els e statement . If you think of the statements in a computer program 
as steps taken down a road, consider the if I el se statement as a fork in the road. It 
causes program execution to follow one of two mutually exclusive paths. 
Notice the programming style used to construct the if I else statement. The word else 
is at the same level of indention as if. The statements whose execution are controlled 
by the i f and by the el se are both indented one level. This makes the two possible 
paths of execution visually clear to anyone reading the code. 
When to Use if and When to Use if / else 
Sometimes new programming student s are unsure whethe r to use two separate if 
statements or a single i f I else statement when two possible conditions exist. Here is 
the basic rule. If both conditions could be true or both could be false, use two separate 
i f statements . Here is an example: 
if (score>= 
60 ) 
// Use 2 i f statements 
here 
cout << "You passed. 
\n"; 
if (score>= 
80) 
cout << "Good job. 
\n"; 

172 
Chapte r 4 
Making Decisions 
In this case two separate if statements are needed because with a score below 60 
neither message should be displayed, and with a score of 80 or higher both messages 
sho uld be displayed . 
If the two conditions are mutually exclusive, however , such that one must be true and 
the other false, an i f / el se statement should be used. Here is an example: 
i f (s core>
= 60) 
II Do NOT use 2 if statements 
here 
cout << "You passed . \n"; 
i f (s core< 
60) 
cout << "You fa i led . \n"; 
Here the two test condit ions are mutually exclusive . Either it is true that the score is 60 
or higher , in which case the first message shou ld be displayed, or it is false and the 
score is below 60, in which case the second message should be displayed. Therefore, 
these two statements should be combined into a single if I else constr uct, like this: 
i f (s core>
= 60) 
// Use a single 
if/else 
statement 
instead 
cout << "You passed . \ n ·; 
els e 
cout << "You fa i led . \n"; 
Program 4-3 used a single i f I else statement to test the integer variable number to see 
if it was even or odd because these are mutu ally exclusive condit ions. If a number is 
evenly divisible by 2, it is even. If not , it must be odd. Program 4-4 includes another 
case where if I el se is the right construct to use. It shows how to make sure a program 
does not attempt to perform division by zero . 
Division by zero is mat hematically impossible to perform and it normally causes a 
program to crash . This means the program will prematurely stop running , sometimes 
with an error message . Program 4-4 shows a way to test the value of a divisor before 
the division takes place. 
Program4-4 
1 // Thi s program makes sure that 
the di vi sor is not 
2 II equal to O before 
it performs a divide 
operat i on. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
double num1, num2, quotient
; 
9 
10 
// Get the two numbers 
11 
cout << "Enter two numbers: •; 
12 
cin 
>> num1 >> num2; 
13 
14 
// If num2 is not zero , perform the division
. 
15 
if (num2 != 0) 
16 
{ 
17 
quotient= 
num1 / num2; 
18 
cout << "The quotient 
of•<< 
num1 <<•divided 
by • 
19 
<< num2 <<·
i s · << quotient<< 
".\n"; 
20 
} 
(program continues) 

Program4-4 
21 
el se 
22 
{ 
23 
cout 
24 
cout 
25 
26 
} 
27 
return 
28 } 
<< 
<< 
<< 
o· ' 
(continued) 
"Div i si on by zero is not possib l e .\n"; 
"Please 
run the program again and enter" 
"a number other 
than zero. \ n"; 
Program Output with Example Input Shown in Bold 
Enter two numbers: 
10 O[Ent er] 
Division 
by zero is not possible. 
4.3 The i f / else Statement 
17 3 
Please 
run the program again and enter 
a number other 
than zero. 
Notice how line 15 of Program 4-4 tests the value of num2. If the user ente rs anything 
other than zero, the lines controlled by the i f are executed, allowing the division to be 
performed and the result to be displayed. But if the user enters a zero for num2, the lines 
controlled by the else are executed instead, causing an error message to be displayed. 
Notice also the braces on lines 22 and 26. As with the i f part of an if constr uct, if you 
wish to execute more than one statement in the else part, these statements must be 
placed inside a set of braces. Otherwise the else only controls a single statement. 
Comparing Floating-Point 
Numbers 
Testing floating -point numbers for equality can sometimes give erroneo us results. Because 
of a lack of precision or round -off errors, a number that shou ld be mathematically equal 
to another might not be. In Program 4-5, the number 6 is multiplied by 0.666667, a 
decimal version of 2/3. Of course, 6 times 2/3 is 4. The program, however, disagrees. 
Program 4-5 
1 // Thi s program demonstrates 
how a lack of prec1s1on 
in 
2 II floating-
poi nt numbers can make equal i ty comparisons 
unreliable. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
doub l e result
= .666667 * 6 .0; 
9 
10 
// 2/ 3 of 6 should be 4 and, if you print 
result
, 4 i s di splayed
. 
11 
cout <<"result
="
<< result<< 
end l; 
12 
13 
14 
15 
16 
17 
II However , 
i f (r esu lt 
cout << 
else 
cout << 
internally 
== 4.0) 
"r esu lt DOES 
"r esu lt DOES 
result 
i s NOT prec i sely 
equal 
4! II << end l; 
NOT equal 
4! II << end l; 
equa l to 4 . 
(program continues) 

174 
Chapte r 4 
Making Decisions 
Program 4-5 
18 
(continued) 
19 
return 
O; 
20
} 
Program Output 
result= 
4 
result 
DOES NOT equal 4! 
Typi cally, the value in result 
will be a number just short of 4, like 3.999996 . To prevent 
err ors like this , it is wise to stick with greater -than and less-than comparisons 
when 
using floating-point numbers. For example, instead of testing if the result equals 4.0, you 
could test to see if it is very close to 4.0. Program 4-6 demonstrates this technique. 
Program4-6 
1 I I Thi s program demon st rates 
how to safely 
test 
a float i ng-point 
number 
2 II to see if i t is, 
for all 
practical 
purposes, 
equal to some value. 
3 #include 
<iostream> 
4 #include 
<cmath> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
double 
result
= .6 66667 * 6.0; 
10 
11 
II 213 of 6 should 
be 4 and , if you print 
result
, 4 is displayed. 
12 
cout <<"result="<< 
result<< 
endl ; 
13 
14 
II 
However, internally 
result 
i s NOT precisely 
equal to 4. 
15 
II So test 
to see if i t is "clos e " to 4 . 
16 
if 
(abs(r esu l t - 4.0 < .0001}) 
17 
cout << "r esu lt DOES equal 4!" << end l; 
18 
els e 
19 
cout << "r esu lt DOES NOT equal 4!" << end l; 
20 
21 
return 
O; 
22
} 
Program Output 
result= 
4 
result 
DOES equal 4! 
Line 16 of the program uses the abs function introduced in Chapter 3. Recall that it 
returns the absolute value of the argument. By using it, we ensure that the test cond ition 
will be true if the difference between result 
and 4.0 is less than .0001, regardless of 
whet her result 
is just a tiny bit smaller or a tiny bit larger than .0001. 

4.4 The if/else 
if Statement 
175 
~ 
Checkpoint 
4.12 
Write an if/else 
statement that assigns 0.10 to commission 
unless sales 
is 
greater than or equal to 50,000.00, in which case it assigns 0.20 to commission. 
4 .13 
Write an i f I else statement that assigns 1 to x if y is equal to 100. Otherwise it 
should assign O to x . 
4.14 
Write an if /else statement that assigns .10 to the variable discount if the Boolean 
flag variable prepaid is true and assigns 0.0 to discount if prepaid is false. 
4.15 
True or false: The following if / else statements cause the same output to display. 
A) 
if 
(x > y) 
cout 
<< "x is greater 
than 
y . \n"; 
else 
cout 
<< "x is not greater 
than 
y . \ n" ; 
B) 
if 
(x <= y) 
cout 
<< "x is not greater 
than 
y . \n"; 
else 
cout 
<< "x is greater 
than 
y\n"; 
4.16 
Will the if I else statement shown on the right below function exactly the same 
as the two separate i f statements shown on the left? 
if 
(x < y) 
if 
(x < y) 
cout 
<< 1; 
if 
(x > y) 
cout 
<< 2; 
cout 
<< 1 ; 
else 
cout 
<< 2; 
The i f / e 1 se i f Statement 
CONCEPT: 
The if I else 
if statemen t is a chain of if statements. Th ey perform 
their tests, one after the other, until one of them is found to be true. 
We make certain mental decisions by using sets of different but related rules. For example, 
we might decide the type of coat or jacket to wear by consulting the following rules: 
if it is very cold, wear a heavy coat, 
else, if it is chilly, wear a light jacket, 
else, if it is windy, wear a windbreaker, 
else, if it is hot, wear no jacket. 
The purpose of these rules is to determine which type of outer garment to wear. If it is 
cold, the first rule dictates that a heavy coat must be worn. All the other rules are then 
ignored. If the first rule doesn't apply, however (if it isn't cold), then the second rule is 
consulted. If that rule doesn't apply, the third rule is consulted, and so forth. 

176 
Chapter 4 
a 
VideoNot e 
Using an i f I 
else if 
Statement 
Figure 4-5 
Making Decisions 
The way these rules are connected is very important . If they were consulted individually, we 
might go out of the house wearing the wrong jacket or, possibly, more than one jacket. For 
instance, if it is windy, the third rule says to wear a windbreaker. What if it is both windy 
and very cold? Will we wear a windbreaker? A heavy coat? Both? Because of the order that 
the rules are consulted in, the first rule will determine that a heavy coat is needed. The third 
rule will not be consulted, and we will go outside wearing the most approp riate garment . 
This type of decision making is also very common in programming. In C++ it can be 
accomplished through the if I el se if statement . Figure 4-5 shows its format and a 
flowchart visually depicting how it works. 
if ( condition 1) 
true 
statement 
{ 
set 1 
statement set 1 ; 
} 
false 
else if ( condition 2) 
{ 
statement set 2; 
} 
condition true 
statement 
2 
set 2 
. false 
else if ( condition n) 
{ 
statement set n; 
condition true 
statement 
} 
n 
set n 
false 
This constr uction is like a chain of if I else statements. The else part of one statement 
is linked to the if part of anothe r. When put together this way, the chain of if / el ses 
becomes one long statement . Program 4-7 shows an example . The user is asked to 
enter a numeric test score, and the program displays the letter grade earned. 
Program 4-7 
1 // This program uses an i f/else 
if statement 
to assign 
a 
2 II 
letter 
grade of A, B, C, D, or F to a numeric test 
score. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
// Create named constants 
to hold minimum 
9 
II 
scores 
required 
for each letter 
grade. 
(program continues) 

4.4 The if/else 
if Statement 
177 
Program 4-7 
(continued) 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 } 
const i nt MIN_A_SCORE = 90 , 
MIN_B_SCORE = 80, 
MIN_C_SCORE = 70 , 
MIN_D_SCORE = 60; 
int testScore; 
char grade ; 
// Holds a numeric test 
score 
// Holds a lett er grade 
// Get the numeric score 
cout << "Enter your numeric test 
score and I will\n"; 
cout << "tell 
you the letter 
grade you earned : "; 
cin 
>> testScore; 
// Determine the letter 
grade 
if (t estScore 
>= MIN_A_SCORE} 
grade= 
'A'; 
els e if (testScore 
>= MIN_B_SCORE) 
grade= 
'B'; 
els e if (testScore 
>= MIN_C_SCORE) 
grade = 'C'; 
els e if (testScore 
>= MIN_D_SCORE) 
grade= 
'D'; 
els e if (testScore 
>= 0) 
grade= 
'F'; 
// Di splay the letter 
grade 
cout << "Your grade is"<< 
grade<< 
".\n"; 
return 
O; 
Program Output with Example Input Shown in Bold 
Enter your numeric test 
score and I will 
tell 
you the letter 
grade you earned: 
88[Ent er] 
Your grade is 8. 
As with other forms of the if statement, braces are required in an i f / el se if whenever 
there is more than one statement in a conditionally executed block. Otherwise they are 
optional. Because each of the conditionally executed blocks of code in Program 4-7 
conta ins only one statement, braces were not used. 
The if I else i f statement has a number of notab le characteristics. Let's analyze how it 
works in Program 4-7. First, the relational expression testScore 
>= MIN_A_SCORE is 
tested on line 24. 
if 
(t estScore 
>= MIN_A_SCORE} 
grade= 
'A'; 

178 
Chapte r 4 
Figure 4-6 
Making Decisions 
If testScore 
is greater than or equal to MIN_A_ SCORE, which is 90, the letter 'A' is 
assigned to grade and the rest of the linked if statements are skipped. If testScore 
is 
not greater than or equal to MIN_A_ SCORE, the else part takes over and causes the next 
if condition to be tested on line 26. 
else 
if 
(testScore 
>= MIN_ B_ SCORE) 
grade 
= ' B'; 
The first if statement filtered out all of the grades of 90 or higher, so when this next if 
statement executes, testScore 
will have a value of 89 or less. If testScore 
is greater 
than or equal to MIN_B_SCORE, which is 80, the letter 'B' is assigned to grade and the 
rest of the if statements are skipped. This chain of events continues until one of the 
condit ional expressions is found true or the end of the entire i f/else 
if construct 
is encountered . In either case, the program resumes at the statement immediately 
following the if/else 
i f statement. This is the cout statement on line 36 that prints 
the grade. Figure 4-6 shows the paths that may be taken by the if / e l se if statement . 
No 
No 
No 
testScore 
Yes 
>= 60? 
No 
No 
testScore 
Yes 
>= 80? 
grade = 'B' 
Yes 
grade= 'C' 
grade= 'D' 
Yes 
grade= 'F' 
Yes 
grade= 
'A' 

4.4 The if/else 
if Statement 
179 
Each i f condition in the structure depends on all the i f condit ions before it being 
false. Th e statements following a particular else if are executed when the condit iona l 
expression associated with that el se if is true and all previous conditional expressions 
are false. To demonstrate how this interconnection works, let's look at Program 4-8, 
which uses independent if statements instead of an if I else i f statement . 
Program4
-8 
1 // Thi s program illustrates 
a bug that 
occurs when independent 
if / else 
2 II statements 
are used to assign 
a letter 
grade to a numeric test 
score . 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
// Create named constants 
to hold m1n1mum 
9 
II 
scores 
required 
fo r each letter 
grade. 
10 
const i nt MIN_A_SCORE = 90 , 
11 
MIN_B_SCORE = 80 , 
12 
MIN_C_SCORE = 70 , 
13 
MIN_D_SCORE = 60; 
14 
15 
16 
17 
int testScore; 
char grade ; 
// Holds a numeric test 
score 
// Holds a lett er grade 
18 
// Get the numeric score 
19 
cout << "Enter your numeric test 
score and I will\n"; 
20 
cout << "tell 
you the letter 
grade you earned : "; 
21 
cin 
>> testScore; 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
II Determine the letter 
grade 
if (t estScore 
>= MIN_A_SCORE) 
grade= 
'A'; 
if (t estScore 
>= MIN_B_SCORE) 
grade= 
' B'; 
if (t estScore 
>= MIN_C_SCORE) 
grade= 
'C'; 
if (t estScore 
>= MIN_D_SCORE) 
grade= 
'D'; 
if (t estScore 
>= 0) 
grade= 
'F'; 
II Display the letter 
grade 
cout << "Your grade is • << grade<< 
" . \n"; 
(program continues) 

180 
Chapte r 4 
Making Decisions 
Program4
-8 
(continued) 
42 
return 
O; 
43
} 
Program Output with Example Input Shown in Bold 
Enter your numeric test 
score and I will tell 
you 
the letter 
grade you earned: 
88[Enter] 
Your grade is F. 
In Program 4-8, all the if statements execute because they are individual statements. In 
the example output , testScore 
is assigned the value 88, yet the student receives an F. 
Here is what happens. First the program comes to the if statement on line 24. Because 
the student's score is not at least 90, the assignment statement on line 25 is skipped. 
Next the program comes to the i f statement on line 27. Because the student' s score is 
at least 80, the statement on line 28 executes and grade is assigned a 'B' . However, 
because none of the if statements are connected to the ones above them, the if 
statements on lines 30, 33, and 36 all execute as well. Because testScore 
is also at 
least 70, it causes 'C' to be assigned to grade, replacing the 'B' that was previously 
stored there . This contin ues until all the i f statements have executed. The last one will 
cause 'F' to be assigned to grade . (Students will be very unhappy with this method since 
'F' is the only grade it gives out!) 
Using a Trailing else 
A final el se that is placed at the end of an if / else if statement is called a trailing 
else. A trailing else provides a default action, or set of actions, when none of the if 
expressions are true and is often used to catch errors. This feature would be helpful, for 
example, in Program 4-7. What happens in the current version of that program if the 
user accidentally enters a test score that is less than zero? The i f /else if statement 
handles all scores down through zero, but none lower. If the user enters -8 8, for 
example, the program does not assign any value to the variable grade because there is 
no code to handle a negative score. We can fix this problem by adding a trailing else 
to the if /else if statement. This is done in Program 4-9. 
Program4-9 
1 // Thi s program uses an i f/else 
if statement 
to assign a letter 
2 II grade of A, 8 , C, D, or F to a numeri c test 
score. 
A trail
i ng 
3 II els e is used to set a flag if a negative 
value i s entered . 
4 #include 
<iostream> 
5 using namespace std ; 
6 
(program continues) 

Program4-9 
7 int main () 
8 { 
(continued) 
9 
II Create 
named constants 
to hol d m1n1mum 
10 
II scores 
required 
fo r each letter 
grade . 
11 
const i nt MIN_A_SCORE = 90 , 
12 
MIN_B_SCORE = 80 , 
13 
MIN_C_SCORE = 70 , 
14 
MIN_D_SCORE = 60 , 
15 
MIN_POSSIBLE_SCORE = O; 
16 
4.4 The if I el se if Statemen t 
181 
17 
18 
19 
20 
int testScore
; 
char grade ; 
II Holds a numeric test 
score 
II Holds a letter 
grade 
bool goodScore = true ; 
21 
II Get the numeric score 
22 
cout << "Enter your numeric test 
score and I wil l\ n" ; 
23 
cout << "tel l you the letter 
grade you earned : " ; 
24 
cin 
>> testScore
; 
25 
26 
II Deter mine the letter 
grade 
27 
if (testScore 
>= MIN_A_SCORE) 
28 
grade
= ' A'; 
29 
el se if (testScore 
>= MIN_B_SCORE) 
30 
grade
= ' B'; 
31 
el se if (testScore 
>= MIN_C_SCORE) 
32 
grade
= ' C'; 
33 
el se if (testScore 
>= MIN_D_SCORE) 
34 
grade
= ' D'; 
35 
el se if (testScore 
>= MIN_POSSIBLE_SCORE) 
36 
37 
38 
39 
grade
= ' F'; 
el se 
goodScore = fa l se ; 
40 
II Display 
the letter 
grade 
41 
if (goodScore ) 
II The score was below 0 
42 
cout << "Your grade is
" << grade<< 
".\ n" ; 
43 
el se 
44 
cout << "The score cannot be below zero . \ n" ; 
45 
46 
ret urn O; 
47
) 
Program Output with Example Input Shown in Bold 
Enter your numeric test 
score and I will 
tell 
you 
the letter 
grade you earned: 
88[Enter] 
Your grade is 8. 
Program Output with Different Example Input Shown in Bold 
Enter your numeric test 
score and I will 
tell 
you the letter 
grade you earned: 
-88[Enter] 
The score cannot be below zero. 

182 
Chapte r 4 
Making Decisions 
~ 
Checkpoint 
4.1 7 What will the following program segment display? 
i nt funny = 1, serious; 
if 
(funny!
= 1) 
{ 
funny = serious= 
1; 
} 
else 
if (funny== 
2) 
{ 
funny = ser i ous= 
3; 
} 
else 
{ 
funny = ser i ous= 
5 ; 
} 
cout <<funny<<" 
" <<serious<< 
endl; 
4.18 
The following program is used in a bookstore to determine how many discount 
coupons a customer gets. Complete the table that appears after the program. 
#include 
<iostream> 
us i ng namespace std; 
i nt mai n(} 
{ 
} 
int numBooks, numCoupons; 
cout << "How many books are being purchased?"· 
ci n 
>> numBooks; 
if (numBooks < 1) 
numCoupons = O; 
else 
if (numBooks < 3} 
numCoupons = 1; 
else 
i f (numBooks < 5} 
numCoupons = 2 ; 
else 
numCoupons = 3 ; 
cout << "The number of coupons to give is"<< 
numCoupons << endl ; 
return 
O; 
If the customer purchases 
this many book s ... 
. .. This many coupons are given. 
1 
2 
3 
4 
5 
10 

4.5 
4.5 Menu-Driven Programs 
183 
4.19 
Write an i f I else i f statement that carries out the following logic. If the value 
of variable quant i t yOnHand is equal to 0, display the message "Out of stock" . If 
the value is greater than 0, but less than 10, display the message "Reorder". If 
the value is 10 or more, do not display anything . 
4.20 
Write an i f/els e if statement that performs the same actions as in the above 
question when the value of quant ityOnHand is equal to O or is greater than 0, 
but less than 10. However, when the value is 10 or more, it should display the 
message "Quantity OK" . 
Menu-Driven 
Programs 
CONCEPT: 
A menu is a set of choices presented to the user. A menu-driven program 
allows the user to determine the course of action by selecting it from 
the menu. 
A menu is a screen displaying a set of choices the user selects from. For example, a 
program that keeps a mailing list might give you the following menu: 
1. Add a name to the list. 
2. Remove a name from the list. 
3. Change a name in the list. 
4. Print the list. 
3. Quit the program . 
The user selects one of the operations by entering its number. Entering 4, for example, 
causes the mailing list to be printed, and entering 5 causes the program to end. The if I 
else if structure can be used to set up such a menu. After the user enters a number, it 
compares the number to the available selections and executes the statements that 
perform the requested operation . 
Program 4-10 calculates the charges for membership in a health club. The club has 
three membership packages to choose from: standard adult membership, child 
membership, and senior citizen membership . The program presents a menu that allows 
the user to choose the desired package and then calculates the cost of the membership. 
Program 4 -10 
1 // Thi s menu-driv en program uses an if/else 
statement 
to carry 
2 II out the corr ect set of actions 
based on th e user's 
menu choic e . 
3 #include 
<iostr eam> 
4 #include 
<iomanip> 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
II Const ants for membership rat es 
10 
const double AOULT_RATE = 120.0; 
11 
const double CHILO_RATE = 60.0; 
12 
const double SENIOR_RATE = 100.0; 
(program continues) 

184 
Chapte r 4 
Making Decisions 
Program 4-10 
(continued) 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 } 
int choice; 
int months; 
double charges ; 
// Menu choice 
// Number of months 
// Monthly charges 
// Display 
the menu and get the user's 
choice 
cout <<" 
Health Club Membershi p Menu\n\n"; 
cout << "1. Standard 
Adult Membership \ n"; 
cout << "2. Child Membership \n"; 
cout << "3. Senior Citizen 
Membership \ n"; 
cout << "4. Quit the Program \n\n"; 
cout << "Enter your cho i ce: "· 
cin 
>> choice; 
// Set the numeric output 
formatting 
cout <<fixed<< 
showpoint << setprec
i s i on (2}; 
// Use the menu selection 
to execute 
the correct 
set of actions 
if (choic e == 1) 
{ 
cout << "For how many months? "; 
ci n 
>> months ; 
charges
= months* 
ADULT_RATE; 
cout << "\ nThe total 
charges 
are$"<< 
charges<< 
endl ; 
} 
els e if (choice== 
2} 
{ 
cout << "For how many months? "; 
cin 
>> months ; 
charges
= months* 
CHILD_RATE; 
cout << "\ nThe total 
charges 
are$"<< 
charges<< 
endl ; 
} 
els e if (choice== 
3} 
{ 
cout << "For how many months? "; 
ci n 
>> months ; 
charges
= months* 
SENIOR_RATE; 
cout << "\ nThe total 
charges 
are$"<< 
charges<< 
endl ; 
} 
els e if (choice 
!= 4} 
{ 
cout << "\ nThe val i d choices 
are 1 through 
4.\n" 
<< "Run the program again and select 
one of those .\n"; 
} 
return 
O; 
Program Output with Example Input Shown in Bold 
Health Club Membership Menu 
1. Standard 
Adult Membership 
2. Child Membership 
3. Senior Citizen 
Membership 
4. Quit the Program 
Enter your choice: 
3[Ent er] 
For how many months? 4[Ent er] 
The total 
charges 
are $400.00 

4.6 
Figure 4-7 
4.6 Nested if Statements 
185 
Notice that three double constants ADULT_ RATE, CHILD_ RATE, and SENIOR_RATE are 
defined in lines 10 through 12. These constants hold the month ly membership rates for 
adult, child, and senior citizen memberships . Also notice that the program lets the user 
know when an invalid menu choice is made. If a number other than 1, 2, 3, or 4 is 
entered, an error message is printed. This is known as input validation. 
Nested if Statements 
CONCEPT: 
To test more than one condition, an if statement can be nested inside 
another if statement. 
It is possible for one if statement or if/else 
statement to be placed inside another 
one. This construct, called a nested if, allows you to test more than one condition to 
determine which block of code should be executed. For example, consider a banking 
program that determines whether a bank customer qualifies for a special low interest 
rate on a loan . To qualify, two conditions must exist: 
1. The customer must be currently employed. 
2. The customer must have recently graduated from college (in the past two years). 
Figure 4-7 shows a flowchart for an algorithm that could be used in such a program . 
False 
Display "You must be 
employed to qualify." 
employed = 'Y' 
False 
Display "You must have 
graduated from college 
in the past two years to 
qualify." 
True 
recentGrad = 'Y' 
True 
Display "You qualify for 
the special interest 
rate." 

186 
Chapte r 4 
Making Decisions 
If we follow the flow of execution 
in this diagram, 
we see that first the express ion 
empl oyed == ' Y' is tested. If this exp ress ion is false, there is no need to perform any 
othe r tests. We kn ow that the custome r does not qualify for the special int erest rate. 
If the exp ress ion is true , however, we need to test the second cond ition . Thi s is done 
with a nested decision str uctu re that tests the expression 
recentGrad 
== 'Y '. If this 
express ion is also true , then the customer qualifies for the spec ial interest rate. If 
this second express ion is false, the customer does not qualify. Program 4-11 shows 
the code that corresponds 
to the logic of the flowchart. 
It nests one if I e ls e 
statement 
inside another one . 
Program 4-11 
1 // 
This program determines 
whether 
a loan app licant 
qualifies 
for 
2 II 
a spec ial 
loan interest 
rate. 
It uses nested 
if / else 
statements
. 
3 #include 
<iostream> 
4 using 
namespace std ; 
5 
6 int 
main() 
7 { 
8 
9 
10 
char 
employed, 
recentGrad
; 
// Current ly employed? 
(Y or N) 
// Recent college 
graduate? 
(Y or N) 
11 
// 
Is the applicant 
employed and a recent 
college 
graduate? 
12 
cout << "Answer the following 
questions\n"; 
13 
cout << "wit h eithe
r Y for Yes or N fo r No.\n"; 
cout << "Are you employed? 
". 
' 
cin 
>> employed; 
cout << "Have you graduated 
from college 
in the past 
cin 
>> recentGrad; 
// Determine 
the appl ic ant's 
loa n qualifications 
if 
(employed
== ' Y') 
{ 
two years? 
if 
(recentGrad 
== ' Y') 
{ 
// Employed and a recent 
grad 
cout << "You qualify 
fo r the special 
interest 
rate.\n"; 
} 
". 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
else 
// Employed but not a recent 
grad 
28 
{ 
29 
cout << "You must have graduated 
from college 
in the past \n"; 
30 
cout << "two years 
to qualify 
for the special 
interest 
rate.\n"; 
31 
} 
32 
} 
(program continues) 

4.6 Nested if Statements 
187 
Program 4-11 
(continued) 
33 
el se 
// Not empl oyed 
34 
{ 
35 
co ut << "You must be empl oyed to qual i fy for the
" 
36 
<< "spec i al i nterest 
rate. 
\ n"; 
37 
} 
38 
ret urn O; 
39 
} 
Program Output with Example Input Shown in Bold 
Answer the following 
questions 
wi th either 
Y for Yes or N for No. 
Are you employed? N[Enter] 
Have you graduated 
from college 
in the past two years? 
Y[Enter] 
You must be employed to qualify 
for the spec i al interest 
rate. 
Program Output with Other Example Input Shown in Bold 
Answer the following 
questions 
wi th either 
Y for Yes or N for No. 
Are you employed? Y[Enter] 
Have you graduated 
from college 
in the past two years? 
N[Enter] 
You must have graduated 
from college 
in the past 
two years 
to qualify 
for the special 
interest 
rate. 
Program Output with Other Example Input Shown in Bold 
Answer the following 
questions 
with either 
Y for Yes or N for No. 
Are you employed? Y[Enter] 
Have you graduated 
from college 
in the past two years? 
Y[Enter] 
You qualify 
for the special 
interest 
rate. 
Let' s take a close r look at th is prog ram . Th e i f statement th at begi ns on line 
2 1 tests th e exp ression employed == ' Y' . If th e exp ressio n is tru e, th e inn er if 
statement th at begi ns on line 23 is exec ut ed. H owever , if th e out er ex pr ession is 
false, th e progra m ju mps to line 33 and execut es th e stateme nt s in the outer else 
bloc k instead . 
Wh en yo u are deb ugging a pr ogram with nested if / else stat ement s, it's im port ant 
to know which if statement eac h else goes wi th. Th e ru le for matchin g eac h else 
with th e pro per if is thi s: An e l se goes with th e closes t previous i f stateme nt 
th at does n't alrea dy have its ow n else. 
This is eas ier to see when th e stateme nt s 
are properly inde nt ed . Figur e 4-8 shows lin es simi lar to lines 21 thr ough 37 of 
Progra m 4 -11. It illustrat es how eac h else should line up with th e if it belongs 
to . Th ese visual cues are im port ant beca use nested i f statement s ca n be very long 
an d co mpl ex . 

188 
Chapte r 4 
Making Decisions 
Figure 4-8 
Thi s if and els e -
go together. 
if ( employed == 
'Y') 
{ 
.-4~ 
i f (recentGrad == ' Y') II Nested if 
{ 
cout << "You qualif y for the special 
cout << "interest 
rate . In"; 
". ' 
This i f and else 
go together. -
} 
el se // 
{ 
Not a recent grad, but employed 
} 
} 
cout 
cout 
cout 
<< 
<< 
<< 
"You must have graduated from 
"college i n the past two In"; 
"years to quali fy.In"; 
else II Not employed 
{ 
". ' 
cout << "You must be employed to qualify.In" 
} 
~ 
Checkpoint 
4.21 
If you execute the following code, what will it display if the user enters 5? 15? 
30? - 1? 
cout 
<< "Enter a number : "· 
cin 
>> number ; 
if 
(number > 0) 
{ 
cout 
<< "Zero 
i f (number> 
10) 
{ 
cout 
<< "Ten 
... 
". 
if 
(number> 
20) 
} 
} 
{ 
cout 
<< "Twenty 
} 
". 
4.22 
If you execute the following code, what will it display if the user enters 15 18? 
15 10? 9 7? 
cout <<" 
Enter the number of team wi ns and number of team losses : "· 
cin 
>> team Wins>> teamlosses
; 
i f (t eamWins > teamlosses) 
{ 
} 
if (teamWins > 10) 
cout 
<< "You are the champi ons. 
In"; 
else 
cout 
<< "You have won more than 50% of your games. In"; 
else 
cout 
<< "Good l uck in the rest 
of your games. "· 

4.7 
a 
Video Note 
Using Logical 
Operators 
4. 7 Logical Operators 
189 
Logical Operators 
CONCEPT: 
Logical operators connect two or more relational expressions into one 
or reverse the logic of an expression. 
In the previous section you saw how a program tests two cond itions with two if 
statements . In this section you will see how to use logical operators to combine two or 
more relational expressions into one. Table 4-6 lists C++'s logical operators . 
Table 4-6 Logical Operato rs 
Operator 
&& 
11 
Meaning 
AND 
OR 
NO T 
Effect 
Connects two expressions into one. Both expressions must be 
true for the overall expression to be true . 
Connects two expressions into one. One or both expressions 
must be true for the overall expression to be true . It is only 
necessary for one to be true, and it does not matter which. 
Reverses the "tr uth " of an expression . It makes a true expression 
false and a false expression true. 
The && Operator 
Th e && operato r is known as the logical AND operator. It takes two expressions as 
operands and creates an expression that is true only when both subexpressions are 
true. Here is an example of an i f statement that uses the && operator : 
if (( temperature< 
20) && (minutes> 
12 )) 
cout << "The temperature 
is in the danger zone ."; 
Notice that both of the expressions being ANDed together are comp lete expressions 
that evaluate to true or false. First temperature 
< 20 is evaluated to produce a true or 
false result. Then minutes > 12 is evaluated to produce a true or false result. Then, 
finally, these two results are ANDed together to arr ive at a final result for the entire 
expression. Th e cout statement will only be executed if temperature 
is less than 
20 AND mi nut es is greater than 12. If either relationa l test is false, the entire expression 
is false and the cout statement is not executed. 
Table 4-7 shows a truth table for the && operator. The truth table lists all the possible 
comb inations of values that two expressions may have and the resulting value returned 
by the && operator connecting the two expressions . As the table shows, both 
subexpressions must be true for the && operator to return a true value. 

190 
Chapte r 4 
Making Decisions 
Table 4-7 Logical AND 
Expression 
Value of th e Expression 
false 
&& fa ls e 
false 
(0) 
false 
&& true 
false 
(0) 
true 
&& fa ls e 
false 
(0) 
true 
&& true 
true 
( 1 ) 
0 
NOTE: If the subexpression on the left side of an && 
operator is false, the express ion 
on the right side will not be checked . Because the entire express ion is false if even 
just one of the subexpressions 
is false, it would waste CPU time to check the 
remaining express ion . Thi s is called short -circuit evaluation . 
Th e && operator can be used to simplify programs that othe rwi se wou ld use nested i f 
statements . Program 4-12 is similar to Program 4-11, wh ich determines if a bank 
customer qua lifies for a specia l interest rate . H owever, Program 4-12 uses the logica l 
&& 
operator instead of nested i f statements. 
Program 4 -12 
1 II Thi s program determ i nes whether 
a loan app licant 
qualifies 
for 
2 II a spec ia l loan i nteres t rate. 
It uses the && logical 
operator. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main () 
7 { 
8 
9 
10 
char 
employed, 
rece nt Grad; 
II Currently 
employed? 
(Y or N) 
II Recent college 
graduate? 
(Y or N) 
11 
II Is the applicant 
employed and a recent 
college 
gradua te ? 
12 
cout << "Answer the following 
questions\n"; 
13 
cout << "wit h eithe r Y for Yes or N fo r No.\n"; 
14 
15 
16 
17 
18 
19 
cout 
cin 
cout 
cin 
<< 
>> 
<< 
>> 
"Are you employed? 
employed; 
"Have you graduated 
recen t Grad; 
". 
' 
from college 
in t he past two years? 
". 
(program continues) 

4.7 Logical Operato rs 
191 
Program 4-12 
(continued) 
20 
II Determine the appl i cant's 
loa n qual i fications 
21 
if (employed == 'Y' 
&& recentGrad 
== 'Y') 
I I Uses logical 
AND 
22 
cout << "\nYou qual i fy for the special 
interest 
rate . \ n"; 
23 
els e 
24 
25 
26 
{ 
27 
} 
cout << "\nYou must be employed and have graduated 
from college\n" 
<< "in the past two years to qualify• 
<< "for the special 
interest 
rate. 
\ n"; 
28 
return 
O; 
29
} 
Program Output with Example Input Shown in Bold 
Answer the following 
questions 
with either 
Y for Yes or N for No. 
Are you employed? Y[Ent er] 
Have you graduated 
from college 
in the past two years? 
N[Enter] 
You must be employed and have graduated 
from college 
in the past two years to qualify 
for the special 
interest 
rate. 
0 
0 
Note that although this program is similar to Program 4-11, it is not the exact logical 
equivalent. In Program 4-12 the following message displays any time the app licant 
does not qualify for the special rate: "You must be employed and have graduated from 
college in the past two years to qualify for the specia l interest rate ." Program 4-11 
displays different messages when the loan applicant does not qualify, depending on 
why they failed to qualify. 
The I I Operator 
Th e 11 operator is known as the logical OR operator. It takes two expressions as 
operands and creates an expression that is true when either of the subexpressions is 
true. Here is an example of an i f statement that uses the I I operator: 
if 
(( temperature< 
20) I I (temperature> 
100)) 
cout << "The temperature 
is in the danger zone. "; 
The cout statement will be executed if temperature 
is less than 20 OR temperature 
is 
greater than 100. If either relationa l test is true , the entire expression is true and the 
cout statement is executed. 
NOTE: 
The two things being ORed shou ld both be logical expressions that 
evaluate to true or false. It would not be correct to write the if condition like this: 
if (temperature< 
20 I I > 100) 
NOTE: 
There is no 1 1 key on the computer keyboard. Use two I symbols . Th is 
symbo l is on the backslash key. Press Shift and backslash to type it. 

192 
Chapter 4 
Making Decisions 
Table 4-8 shows a truth table for the 11 operato r. 
Table 4-8 Logical OR 
Expression 
Value of the Expression 
false 
11 false 
false 
(0) 
false 
11 true 
true 
( 1 ) 
true 
11 false 
true 
( 1 ) 
true 
11 true 
true 
( 1 ) 
All it takes for an OR expression to be true is for one of the subexpressions to be true. 
It doesn't matter if the other subexpression is false or true. 
Program 4-13 performs different tests to qualify a person for a loan. This one determines 
if the customer earns at least $35,000 per year or has been employed for more than 
five years. 
Program 4-13 
1 II This program determ i nes whether or not an applicant 
qualif ie s 
2 I I for a loan. 
It uses the logical 
11 operator. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const double MIN_INCOME 
= 35000.0; 
9 
const int MIN_YEARS 
= 5; 
10 
11 
12 
13 
double i ncome; 
int years; 
I I Annual income 
II Years at the current 
job 
14 
II Get annual income and years on the job 
15 
cout << "What i s your annual i ncome? " ; 
16 
17 
18 
19 
ci n 
cout 
ci n 
>> income; 
<< "How many years have you worked at your current 
job?"; 
>> years; 
20 
II Determine if the applicant 
qualifies 
for a loan 
21 
if (i ncome> = MIN_INCOME I I years> 
MIN_YEARS
) 
II Uses lo gical 
OR 
22 
cout << "You qualify 
for a loan. \ n"; 
23 
else 
24 
25 
26 
{ 
cout << "\ nYou must earn at le ast$"<< 
MIN_INCOME 
<<"or 
have been employed \ n" 
<< "for more than"<< 
MIN_YEARS 
<<"years" 
27 
<< "to qual i fy for a loa n. \ n"; 
28 
} 
(program continues) 

Program 4-13 
(continued) 
29 
return 
O; 
30 } 
Program Output with Example Input Shown in Bold 
What is your annual income? 40000[Enter] 
How many years have you worked at your current 
job? 2[Enter] 
You qualify 
for a loan. 
Program Output with Other Example Input Shown in Bold 
What is your annual income? 20000[Ent er] 
How many years have you worked at your current 
job? 7[Enter] 
You qualify 
for a loan. 
Program Output with Other Example Input Shown in Bold 
What is your annual income? 30000[Ent er] 
How many years have you worked at your current 
job? 3[Enter] 
You must earn at least 
$35000 or have been employed 
for more than 5 years to qualify 
for a loan. 
4.7 Logical Operators 
193 
Th e message "You qualify for a loan." is displayed when either or both expressions 
income >= MIN_INCOME 
or years > MIN_YEARS are true . If both of these are false, the 
disqualifying message is printed . 
<) NOTE: 
The 11 operator also performs short -circuit evaluation . If the subexp ression 
on the left side of an 11 operator is true, the subexpression on the right side will not 
be checked because it is only necessary for one of the subexp ressions to be true for 
the whole expression to evaluat e to true. 
The ! Operator 
The ! operato r performs a logical NOT operat ion . It takes an operand and reverses its 
truth or falsehood. In other words, if the express ion is true, the ! operator returns false, 
and if the expression is false, it returns true . Here is an if statement using the ! operato r: 
if 
(!(t emperature> 
100)} 
cout << "You are below the maximum temperature. 
\n"; 
First, the expression (temperature 
> 100} is tested to be true or false. Then the ! operato r 
is applied to that value. If the expression ( temperature > 100) is true, the ! operato r returns 
false. If it is false, the ! operator returns true. In the example, it is equivalent to asking "is the 
temperature not greater than 100?" or "is it false that the temperature is greater than 100?" 

194 
Chapter 4 
Making Decisions 
Table 4-9 shows a truth table for the ! operator. 
Table 4-9 Logical NOT 
Expression 
!false 
!true 
Value of the Expression 
true 
(1) 
false 
(0) 
Program 4-14 performs the same task as Program 4-13. The if statement, however, 
uses the ! operator to determine if it is false that the applicant makes at least $35,000 
or has been on the job more than five years. 
Program 4-14 
1 II Thi s program determines 
whether or not an applicant 
2 II qual i f i es for a loa n . It uses the ! logica l operator 
3 II to reverse 
the logic 
of the if statement. 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
const double MIN_ INCOME = 35000 .0; 
10 
const i nt MIN_YEARS = 5 ; 
11 
12 
13 
14 
double income; 
int years; 
I I Annual i ncome 
II Years at the current 
job 
15 
II Get annua l income and years on the job 
16 
cout << "What is your ann ual income?"; 
17 
cin 
>> i ncome; 
18 
cout << "How many years have you worked at your current 
job?"; 
19 
cin 
>> years; 
20 
21 
II Determine 
if the applicant 
qual i f i es for a loa n 
22 
if ( ! (i ncome> = MIN_ INCOME I I years> 
MIN_YEARS) ) 
II Uses logica l NOT 
23 
{ 
cout << "\nYou must earn at least
$" << MIN_INCOME 
24 
<<" 
or have been employed \n" 
25 
<< "for more than
"<< MIN_YEARS <<"years" 
26 
<< "to qualify 
for a loan. 
\n"; 
27 
} 
28 
els e 
29 
cout << "You qual i fy for a loa n . \n"; 
30 
ret urn O; 
31 } 
Program Output 4-14 Is the same as that of Program 4-13. 

4.7 Logical Operators 
195 
Boolean Variables and the ! Operator 
An interesting feature of a Boolean var iab le is that its value can be tested just by naming 
it. Suppose moreData is a Boolean variable. Then the test 
if 
(moreData == true) 
can be written simply as 
if 
(moreData ) 
and the test 
if 
(moreData --
false) 
can be written simply as 
if 
( ! moreData ) 
In fact, this second way of testing the value of a Boolean variable is preferable. Thi s is 
because although the C++ constant 
true 
always has the value 1, a condition 
that 
evaluates to true may have any nonzero value. For example, C++ has a function called 
i sa l pha (), which tests whether or not a character is an alphabetic character. As you 
would expect, the test i sal pha ( '?') 
evaluates to false and the test i sal pha ( 'x') 
evaluates to true. H owever, for some alphabetic characters, 
this function returns a 
value other than 1 to represent true. Program 4-15 illustrates this. 
Program 4-15 
1 II Thi s program illustrates 
what can happen when a 
2 II Boolean value is compared to the C++ constant 
true . 
3 #include 
<iostream> 
4 #include 
<cctype> 
II Needed to use the isalpha 
function 
5 using namespace std; 
6 
7 
8 
9 
10 
11 
12 
int 
{ 
main() 
cout << "Is '?' 
an 
cout << "Is 
' X ' an 
cout << "Is 
'x' 
an 
alphabetic 
character? 
alphabetic 
character? 
alphabetic 
character? 
13 
cout << "Ask if(isalpha('x') 
== true) 
\n"; 
14 
if 
(isalpha
(' x ') == true ) 
• << i salpha( '?') 
• << i salpha( 
' X ') 
• << i salpha( 
'x') 
15 
cout << "The letter 
x IS an alphabetic 
character. 
\n\n"; 
16 
else 
<< 
<< 
<< 
17 
cout << "The letter 
xis 
NOT an alphabetic 
character. 
\ n\ n" ; 
18 
19 
cout << "Ask if(isalpha('x')) 
\n"; 
20 
if 
(isalpha
('x')) 
21 
cout << "The letter 
x IS an alphabetic 
character. 
\n"; 
22 
else 
23 
cout << "The letter 
xis 
NOT an alphabetic 
character. 
\ n"; 
24 
25 
return 
O; 
26
) 
II \n"; 
II \n"; 
"\n\n"; 
(program continues) 

19 6 
Chapte r 4 
Making Decisions 
Program 4-15 
(continued) 
Program Output 
Is '?' 
an alphabetic 
character? 
0 
Is 
'X' an alphabetic 
character? 
1 
Is 'x' 
an alphabetic 
character? 
2 
Ask if ( i sa l pha ( ' x' ) --
true 
The letter 
xis 
NOT an alphabetic 
character 
Ask if(isalpha('x')) 
The letter 
x IS an alphabetic 
character 
In line 14 when the condition i sal pha ( 'x') 
== true was tested, the program did not 
produce the desired result. The value 2 returned by the i sal pha function was compared 
to the value 1, so the condition evaluated to false even though, in fact, both values 
being tested represent true . The code in line 20 worked correctly because the value 2, 
returned by the i sal pha function, was correctly interpreted as true . 
Precedence 
and Associativity of Logical Operators 
Table 4-10 shows the precedence of C++'s logical operators, from highest to lowest. 
Table 4-10 Precedence of Logical Ope rato rs 
&& 
11 
The ! operato r has a higher precedence than many of the C++ operators. Therefore, to 
avoid an error, it is a good idea always to enclose its operand in parentheses, unless 
you intend to apply it to a variable or a simple expression with no other operators . For 
example, consider the following expressions: 
!(x 
> 2) 
!x > 2 
The first expression applies the ! operator to the expression x > 2. It is asking "is x not 
greater than 2?" The second expression, however, applies the ! operator to x only. It is 
asking "is the logical negation of x greater than 2?" Suppose x is set to 5. Since 5 is 
nonzero, it would be considered true, so the ! operator would reverse it to false, which 
is 0. The > operator would then determine if O is greater than 2. To avoid such an 
error, it is wise to always use parentheses. 
The && 
and I I operators rank lower in precedence than relational operators, which means 
that relational expressions are evaluated before their results are logically ANDed or ORed. 
a> 
b && X < y 
a>bl
l x<y 
i s the same as 
i s the same as 
(a> 
b) && (x < y) 
(a>b) 
I I (x<y) 

0 
4.7 Logical Operators 
197 
Thus you don't normally need parentheses when mixing relational operato rs with && 
and I 1. However it is a good idea to use them anyway to make your intent clearer for 
someone reading the program. 
Parentheses are even more strongly recommended anytime && and 11 operators are 
both used in the same expression. This is because && has a higher precedence than I 1. 
Without parentheses to indicate which you want done first, && will always be done 
before 11, which might not be what you intended. Assume recent Grad, employ ed, and 
goodCredi t are three Boolean variables . Then the expression 
rece nt Grad I I employed && goodCredit 
is the same as 
rece nt Grad I I (employed && goodCredit ) 
and not the same as 
(recentGrad 
I I employed)&& goodCredit 
Checking Numeric Ranges with Logical Operators 
Logical operators are effective for determining if a number is in or out of a range . To 
check if a number is inside a numeric range, it's best to use the && operator. For example, 
the following i f statement checks the value in x to determine if it is in the range of 20 
through 40. 
if 
(( x >= 20 ) && (x <= 40)) 
cout << x << •i s i n t he acceptable 
range .\n"; 
The expression in the if statement will be true only when x is both greater than or 
equa l to 20 AND less than or equal to 40. The value of x must be within the range of 
20 through 40 for this expression to be true. 
To check if a number is outside a range, it is best to use the 11 operator. The following 
statement determines if the value of x is outside the range of 20 to 40: 
if 
(( x < 20) I I (x > 40)) 
cout << x << •i s outside 
the acceptable 
range.\ n"; 
It's important not to get the logic of these logical operators confused . For examp le, the 
following i f statement would never test true: 
if 
(( x < 20) && (x > 40)) 
cout << x << •i s outside 
the acceptable 
range.\ n"; 
Obvious ly, x can never be both less than 20 and greater than 40 at the same time. 
NOTE: 
C++ does not allow you to check numeric ranges with expressions such as 
5 < x < 20. Instead you must use a logical operator to connect two relational 
expressions, as previously discussed. 

198 
Chapte r 4 
Making Decisions 
~ 
Checkpoint 
4.2 3 The following truth table shows various combinations of the values t rue and 
false connected by a logical operator. Complete the table by indicating if the 
result of such a combination is true or false. 
Logical Expression 
true && fa l se 
true && true 
false && false 
true I I fa l se 
true 11 true 
false 
11 false 
!t rue 
!fa lse 
Result (true or false) 
4.24 
If a = 2, b = 4, and c = 6, indicate whether each of the following condit ions is 
true or false: 
A) 
(a -- 4) I I (b > 2) 
B) 
(6 <= c) && (a > 3 ) 
C) 
(1 != b) && (c != 3) 
D) (a >= - 1) 11 (a<= b) 
E) ! (a > 2) 
4.25 
Ifa = 2, b = 4, and c = 6, is the following expression true or false? 
(b > a ) I I (b > c) && (c == 
5 ) 
4.2 6 
Rewrite the following using the ! operator so that the logic remains the same. 
i f (activeEmployee == false) 
Validating User Input 
CONCEPT : As long as the user of a program enters bad input , the program will 
produ ce bad output. Programs should be writt en to filter out bad input. 
A famous saying of the computer world is "garbage in, garbage out ." The integrity of 
a program's output is only as good as its input, so you should try to make sure garbage 
does not go into your programs . Input validation is the process of inspecting information 
given to a program by the user and determining if it is valid. A good program should 
give clear instructions about the kind of input that is acceptable, but still not assume 
the user has followed those instructions. Here are just a few examples of input 
validations performed by programs: 
• Numbers are checked to ensure they are within a range of possible values. For 
example, there are 168 hours in a week. It is not possible for a person to be at 
work longer than 168 hours in one week. 

4.8 Validating User Input 
199 
• Values are checked for their "reasonab leness." Although it might be possible for 
a person to be at work for 168 hours per week, it is not probab le. 
• Items selected from a menu or some other set of choices are checked to ensure 
they are available options . 
• Variables are checked for values that might cause problems, such as division by zero. 
Program 4-16 is a test scoring program that rejects any score less than O or greater than 100. 
Program 4-16 
1 II Thi s test 
scoring 
program does not accept 
test 
2 II scores 
th at are less 
than O or grea t er t han 100. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 int main () 
7 { 
8 
II Const ants for grade thresholds 
9 
const i nt A_SCORE = 90, 
10 
B_SCORE = BO, 
11 
12 
C_SCORE = 70, 
D_SCORE = 60, 
13 
MIN_SCORE = 0, 
II Mi ni mum valid 
score 
14 
MAX
_SCORE = 100; 
II Maxi mum valid 
score 
15 
16 
int tes t Score; 
II Holds t he user entered 
numeric tes t score 
17 
18 
II Get t he numeric tes t score 
19 
cout << "Ent er your numeric t est score and I will\n" 
20 
<< "t ell you the le t ter grade you earned: 
"; 
21 
ci n >> tes t Score; 
22 
23 
II Check if the inpu t is valid 
24 
if (tes t Score >= MIN_SCORE && testScore 
<= MAX
_SCORE) 
25 
{ 
26 
II The score is valid, 
so determine 
t he letter 
grade 
27 
if (t estScore 
>= A_SCORE) 
28 
cout << "Your grade is A. \n"; 
29 
else 
i f (testScore 
>= B_SCORE) 
30 
cout << "Your grade is 8. \n"; 
31 
else 
i f (testScore 
>= C_SCORE) 
32 
cout << "Your grade is C. \n"; 
33 
else 
i f (testScore 
>= D_SCORE) 
34 
cout << "Your grade is D. \n"; 
35 
else 
36 
cout << "Your grade is F. \n"; 
37 
} 
(program continues) 

200 
Chapte r 4 
Making Decisions 
Program 4-16 
(continued) 
38 
else 
39 
{ 
40 
// An invalid 
score was entered 
41 
cout << "That i s an i nvalid 
score. 
Run the progra m\n" 
42 
<< "aga i n and ent er a value i n t he range of\n" 
43 
<< MIN_SCORE <<"
t hroug h "<< MAX
_SCORE << ".\n"; 
44 
} 
45 
return 
O; 
46
} 
Program Output with Example Input Shown in Bold 
Ent er your numeri c t est score and I will 
t ell you the le t ter grade you ea r ned: -l[Enter] 
That is an inval i d score. 
Run t he program 
again and enter 
a value in the range of 
0 t hrough 100. 
Program Output with Different Example Input Shown in Bold 
Ent er your numeri c t est score and I will 
t ell you the le t ter grade you ea r ned: 81[Enter] 
Your grade is B. 
4.9 
In Chapter 5 you will learn an even better way to validate input data . 
More about Blocks and Scope 
CONCEPT: 
Th e scope of a varia ble is limited to the block in which it is defined. 
C++ allows you to create variab les almost anywhere in a program . It is a common 
pract ice to define all of a function's variables at the top of the function, right after the 
opening brace that marks the beginning of its body. However, especially in longer 
programs, variables are sometimes defined near the part of the program where they are 
used. This is permitted provided they are defined before they are used . 
You learned earlier in this chapter that surrounding one or more programming statements 
with curly braces defines a block of code. The body of function main, which must be 
surrounded by braces, is a block of code. So is the set of statements associated with an i f or 
an else in an i f /else statement. Whenever a variable is defined inside a block, and you may 
define a variable inside any block, its scope is the part of the program between its definition 
and the block's closing brace. Thus the scope of a variable defined at the top of a function is, 
essentially, the entire function, while a variable defined in an inner block, is just that block. 
Program 4-17 defines its variables later. 

4.9 More about Blocks and Scope 
201 
Program 4-17 
1 II Thi s program determ i nes whether or not an applicant 
qualif i es 
2 II for a loan. It demonstrates 
late var i able declaration, 
and 
3 II even has a variable 
defined 
in an inner block. 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
II Constants 
for minimum income and years 
10 
const double MIN_INCOME = 35000.0; 
11 
const i nt MIN_YEARS = 5; 
12 
13 
II Get the annual income 
14 
cout << "What is your annual income?"; 
15 
16 
double income; 
II Variable 
def i ni tion 
17 
cin >> income; 
18 
19 
if (i ncome>= MIN_INCOME) 
20 
{ 
21 
II Income is hi gh enough, so get years at current 
job 
22 
cout << "How many years have you worked at your current 
job?"; 
23 
24 
25 
26 
int years; 
ci n >> years; 
II Variable 
def i ned inside the if block 
27 
if (years> 
MIN_YEARS) 
28 
cout << "\nYou qualify
. \n"; 
29 
else 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 } 
} 
cout << "\nYou must have been employed for more than" 
<< MIN_YEARS <<" years to qualify.\n"
; 
else 
II Income is too low 
{ 
cout 
} 
<< 
<< 
"\nYou must earn at least$"<< 
MIN_INCOME 
" to qualify.\n"; 
return o· ' 
In Program 4-17 the income variable is defined on line 16, inside the braces marking the 
block of code that makes up the body of the main function. So its scope , the part of the 
program where it can be used, includes lines 16 through 38. Those are the lines from the 
point it is defined until the brace that closes the mai n function. The years variable is defined 
on line 24, inside the braces marking the block of code to be conditionally executed by the if 
statement. So its scope includes only lines 24 through 31. Those are the lines from the point 
it is defined until the brace that closes the if block. Variables like these that are defined 
inside a set of braces are said to have local sc.ope or block sc.ope. They are not visible and able 
to be used before their definition or after the closing brace of the block they are defined in. 

202 
Chapte r 4 
Making Decisions 
0 
NOTE: 
When a program is running and it enters the section of code that constit utes 
a variab le's scope, it is said that the variable comes into scope. This simply means the 
variable is now visible and the program may reference it. Likewise, when a variable 
leaves scope, it may no longer be used. 
Variables with the Same Name 
When a block is nested inside another block, a variable defined in the inner block may 
have the same name as a variab le defined in the outer block. Thi s is generally not 
cons idered a good idea, as it can lead to confusion . However, it is permitted . When the 
variable in the inner block comes into scope, the variable in the outer block becomes 
"hidd en" and cannot be used. This is illustrated by Program 4-18. 
Program 4-18 
1 // Thi s program uses two variables 
with the same name. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
8 
int number ; 
// Define a var i able named number 
9 
cout << "Enter a number greater 
than 0 : "; 
10 
cin 
>> number ; 
11 
12 
13 
14 
15 
if (number > 0) 
{ 
int number; 
// Define another 
variable 
named number 
cout << "Now enter 
another 
number : .. 
' 
16 
cin 
>> number ; 
17 
cout << "The second number you entered 
was ". 
' 
18 
cout << number << endl ; 
19 
} 
20 
cout << "Your first 
number was"<< 
number<< endl; 
21 
return 
O; 
22 
} 
Program Output with Example Input Shown in Bold 
Enter a number greater 
than O: 2[Enter] 
Now enter 
another 
number: 7[Enter] 
The second number you entered 
was 7 
Your first 
number was 2 
Program 4-1 8 has two separate variables named number. One is defined on line 7 in the 
outer block. The other is defined on line 13 in the inner block. The ci n and cout statements 
in the inner block (belonging to the if statement) can only work with the number variab le 
defined in that block. As soon as the program leaves that block, the inner number goes out 
of scope, revealing the outer number variable again. 

CD 
4.10 
4.10 More about Characters and Strings 
203 
WARNING! 
Although it's perfectly acceptable to define variables inside nested 
blocks, you should avoid giving them the same names as variables in the outer 
blocks. It's too easy to confuse one variable with anothe r. 
Checkpoint 
4.27 
Write an if statement that prints the message "The number is valid." if the 
variable speed is within the range O through 200 . 
4.28 
Write an if statement that prints the message "The number is not valid." if the 
variable speed is outside the range O through 200. 
4.29 
Find and fix the errors in the following code segment. 
cout << "This progra m calcu l ates the area of a" 
<< "rectangle. 
Enter the length : "; 
ci n 
>> length ; 
ci n 
>> widt h; 
i nt length, 
width, 
area; 
area= 
length 
* wid th; 
cout << "The area is"<< 
area<< 
endl ; 
More about Characters and Strings 
CONCEPT: 
Relation al operators can also be used to compar e characters and string 
objects. 
Earlier in this chapter you learned to use relationa l operators to compare numeric 
values. They can also be used to compare characters and string 
objects. 
Comparing Characters 
As you learned in Chapter 3, characters are actually stored in memory as integers. On 
most systems, this integer is the ASCII value of the character. For example, the letter 
'A' is represented by the number 65, the letter 'B' is represented by the number 66, and 
so on. Table 4-11 shows the ASCII numbers that correspond to some of the commonly 
used characte rs. 
Table 4-11 ASCII Values of Co mmonly Used Characte rs 
Character 
'0'- '9' 
'A' - 'Z ' 
'a' - 'z' 
blank 
period 
ASCII Value 
48-57 
65- 90 
97- 122 
32 
46 

204 
Chapte r 4 
Making Decisions 
Every character, even the blank, has an ASCII code associated with it. Notice that the 
uppercase letters 'A'- 'Z' have different codes than the lowercase letters 'a'- 'z' . Notice 
also that the ASCII code of a character representing a digit, such as ' 1 ' or '2' , is not 
the same as the value of the digit itself. A complete table showing the ASCII values for 
all characters can be found in Appendix A. 
When two characters are compared, it is actually their ASCII values that are being 
compared . 'A' 
< 'B' because the ASCII value of 'A' ( 65) is less than the ASCII value 
of 'B' (66). Likewise, '1' 
< '2' because the ASCII value of '1' (49) is less than the 
ASCII value of '2' (50). However, as Table 4-11 shows, lowercase letters have higher 
numbers than uppercase letters, so 'a' 
> 'Z' . Program 4-19 shows how characters 
can be compared with relational operators. 
Program 4 -19 
1 II Thi s program demonstra t es how characters 
can 
2 II be compared wit h the relational 
opera t ors . 
3 #include 
<iostream> 
4 using namespace std; 
8 
6 int main () 
7 { 
8 
char ch ; 
9 
10 
II Get a character 
from t he user 
11 
cout << "Ent er a digit 
or a letter: 
"; 
12 
ch= 
ci n.ge t (); 
13 
14 
II Determine what the user entered 
15 
if (ch>= 
'O' && ch<= 
'9') 
16 
cout << "You entered 
a digit.\n"; 
17 
else 
if (c h >= 'A' && ch <= 'Z') 
18 
cout << "You entered 
an uppercase 
le t ter . \ n"; 
19 
else 
if (c h >= 'a' && ch <= ' z ') 
20 
cout << "You entered 
a lowercase 
let t er. \n"; 
21 
else 
22 
cout << "That i s not a digit 
or a le t ter . \ n"; 
23 
24 
return 
O; 
25
) 
Program Output with Exampl e Input Shown in Bold 
Ent e r a digit 
or a letter: 
t [Enter ] 
You ent ered a lowerca se le t t er. 
Program Output with Different Example Input Shown in Bold 
Ent e r a digit 
or a letter: 
V[En ter] 
You ent ered an uppe rcase l et t er . 
(program continues) 

4.10 More about Characters and Strings 
205 
Program 4-19 
(continued) 
Program Output with Different Example Input Shown in Bold 
Enter a digit 
or a letter: 
5[Enter] 
You entered 
a digit. 
Program Output with Different Example Input Shown in Bold 
Enter a digit 
or a letter: 
&[Ent er] 
That is not a digit 
or a letter. 
Comparing string 
Objects 
str i ng objects can also be compared with relational operators . As with individual 
characters, when two string objects are compared, it is actually the ASCII value of the 
characters making up the strings that are being compared . For example, assume the 
following definitions exist in a program: 
string 
str1 
= "ABC"; 
string 
str2 
= "XYZ •; 
The string 
object str1 is considered Jess than the string 
object str2 because the 
characters "ABC" alphabetically precede (have lower ASCII values than) the characters 
"XYZ" . So the following i f statement will cause the message "strl is less than str2 ." 
to be displayed on the screen. 
if 
(s t r1 < str2) 
cout 
<< "s tr 1 is less 
than str2."; 
One by one, each character in the first operand is compared with the character in the 
corresponding position in the second operand. If all the characters in both str i ng objects 
match, the two strings are equal. Other relationships can be determined if two characters in 
corresponding positions do not match. The first operand is less than the second operand if 
the first mismatched character in the first operand is less than its counterpart in the second 
operand. Likewise, the first operand is greater than the second operand if the first mismatched 
character in the first operand is greater than its counterpart in the second operand. 
For example, assume a program has the following definitions: 
string 
name1 = "Mary"; 
string 
name2 = "Mark"; 
The value in name1, "Mary", is greater than the value in name2, "Mark" . This is 
because the first three characters in name1 have the same ASCII values as the first three 
characters in name2, but the 'y' in the fourth position of "Mary" has a greater ASCII 
value than the 'k' in the corresponding position of "Mark" . 
Any of the relational operators can be used to compare two str i ng objects. Here are 
some of the valid comparisons of name1 and name2. 
name1 > name2 
name1 <= name2 
name1 != name2 
// true 
II false 
// true 

206 
Chapte r 4 
Making Decisions 
str i ng objects can also, of course, be compared to string literals: 
name1 < "Mary Jane" II true 
Program 4-20 further demonstrates how relational operators can be used with string 
objects . 
Program 4-20 
1 II This program uses relational 
operators 
to compare a str i ng 
2 II entered 
by the user with valid 
stereo 
part 
numbers. 
3 #include 
<iostream> 
4 #include 
<iomani p> 
5 #include 
<string> 
6 us i ng namespace std; 
7 
8 i nt main() 
9 { 
10 
const double PRICE_A = 249.0, 
11 
PRICE_B = 299 .0; 
12 
13 
str i ng partNum; 
II Holds a stereo 
part number 
14 
15 
II Display ava i lable 
parts 
and get the user's 
selection 
16 
17 
18 
19 
20 
21 
22 
cout 
cout 
cout 
cout 
cout 
cin 
<< 
<< 
<< 
<< 
<< 
>> 
"The stereo 
part numbers are:\n"; 
"Boom Box 
part number S-29A \ n"; 
"Shelf 
Model: part number S-29B \ n"; 
"Enter the part 
number of the stereo 
"wi sh to purchase: .. 
partNum; 
23 
II Set the numeri c output 
formatt i ng 
you\n"; 
24 
cout <<fixed<< 
showpoint << setprecision(2); 
25 
26 
II Determine and di splay the correct 
price 
27 
if (partNum == "S-29A") 
cout << "The price 
is $" << 
28 
29 
30 
31 
32 
else 
if (partNum -- "S-29B") 
cout << "The price 
is $" << 
else 
cout << partNum << " is not 
33 
return 
O; 
34 ) 
PRICE_A << endl; 
PRICE B 
-
<< endl; 
a valid 
part 
number . \n"; 
Program Output with Example Input Shown in Bold 
The stereo 
part numbers are: 
Boom Box 
: part 
number S-29A 
Shelf Model: part 
number S-29B 
Enter the part number of the stereo 
you 
wish to purchase: 
S-29A[Enter] 
The price 
is $249.00 

0 
4.10 More about Characters and Strings 
207 
NOTE: 
C-strings, unlike st ring objects, cannot be compared with relational 
operators . To compare C-strings, which you recall are strings defined as arrays of 
characters, you must use the st rcmp function, which is discussed in Chapter 12. 
Testing Characters 
Program 4-19 compared a user-entered character to certain character literals to test 
whether the entered character was a digit, an uppercase letter, or a lowercase letter. We 
can also test for these things, and more, by using character testing functions provided by 
the C++ library. These Boolean functions test the ASCII code of a character and return 
either t rue or false . For example, the following program segment uses the i supper 
function to determine if the character passed to it as an argument is an uppercase letter. 
If it is, the function returns true . Otherwise , it returns false * 
char le t ter= 
'a'; 
i f (i sup per(letter)) 
cout << "Letter 
i s uppercase.\n"; 
else 
cout << "Letter 
i s not uppercase . \n"; 
Because the variable 1 et ter , in this examp le, contains a lowercase character, i supper 
returns false . The if statement will cause the message "Letter is not uppercase" to be 
displayed. 
Table 4-12 lists some of the common character -testing functions C++ provides . To use 
these functions you need to include the ccty pe header file in your program. 
Table 4-12 Character Testing Functions 
Ch aracter Function 
Description 
i sa 1 pha 
Returns true if the argument is a letter of the alphabet. Otherwise, it returns false. 
i sa 1 num 
Returns true if the argument is a letter of the alphabet or a digit. 
Otherwise , it returns fa 1 se . 
i sd i g i t 
Returns true if the argument is a digit from O to 9. Otherwise, it returns fa 1 se. 
i sl ower 
Returns true if the argument is a lowercase letter. Otherwise, it returns false. 
i spr i nt 
Returns true if the argument is a printab le character (including a space) . 
Otherwise , it returns fa 1 se . 
i spunct 
Returns true if the argument is a printab le character other than a digit, 
letter, or space. Otherwise , it returns false . 
i supper 
Returns true if the argument is an uppercase letter. Otherwise, it returns false. 
i sspace 
Returns true if the argument is a whitespace character. Otherwise it 
returns fa 1 se . Whitespace characters are any of the following: 
space ' 
newline '\n' 
vertical 
tab '\v' 
t ab '\ t ' 
• These functions actually return an int value. A nonzero value indicates true and a zero indicates 
false. 

208 
Chap ter 4 
Making Decisions 
Program 4-2 1 uses several of th e fun ctions shown in Tab le 4-12. It asks th e user to 
input a char acter and th en displays various messages, depending on the return value of 
eac h fun ction. 
Program 4-21 
1 II Thi s program demonstrates 
some of the avai l able 
2 II C++ character 
testing 
functions
. 
3 #inc l ude <iostream> 
4 #inc l ude <cctype> 
5 using namespace std ; 
6 
7 int main () 
8 { 
9 
char input ; 
10 
II Needed to use characte
r testing 
funct i ons 
11 
cout << "Enter any character: 
" ; 
12 
cin .get (input ); 
13 
14 
cout << "The characte
r you entered 
is: 
" <<input<< 
endl ; 
15 
cout << "Its 
ASCII code is: 
" << static
_cast< i nt> (input ) << endl ; 
16 
17 
if (isalpha
(input )) 
18 
co ut << "That ' s an alphabetic 
character
.\ n" ; 
19 
20 
if (i sdigit
(input )) 
21 
co ut << "That ' s a numeric di gi t. \ n"; 
22 
23 
if (islowe r( input )) 
24 
co ut << "The l ette r you entered 
is lowercase.
\ n"; 
25 
26 
if (i suppe r( input )) 
27 
co ut << "The l ette r you entered 
is uppercase.
\ n"; 
28 
29 
if (i sspace (input )) 
30 
co ut << "That ' s a whi tespace 
character
. \ n"; 
31 
32 
return 
O; 
33 ) 
Program Output with Example Input Shown in Bold 
Enter any character: 
A[Ent er] 
The character 
you entered 
is: A 
Its ASCII code is: 
65 
That's 
an alphabetic 
character. 
The letter 
you entered 
is uppercase. 
Program Output with Other Example Input Shown in Bold 
Enter any character: 
7[Ent er] 
The character 
you entered 
is: 
7 
Its ASCII code is: 
55 
That's 
a numeric digit. 

4.11 The Conditional Operator 
209 
~ 
Checkpoint 
4.30 
Indicate whether each of the following relational expressions is true or false. 
Refer to the ASCII table in Appendix A if necessary. 
A ) 'a' < 'z' 
D) 'a' < 'A' 
B) 'a' == 'A' 
E) 'l' == 1 
C) '5' < '7' 
F) 'l' == 49 
4.31 
Indicate whether each of the following relational expressions is true or false. 
Refer to the ASCII table in Appendix A if necessary. 
A) "Bill" == "BILL" 
E) "189" > "Bill" 
B) 
"Bill" < "BILL" 
F) "Mary" == " Mary" 
C) "Bill"< "Bob" 
G) "Mary"< "MaryEllen" 
D) "189" > "23" 
H) "Mary Ellen" < "Mary Ellen" 
4.32 
Assume str1 and str2 are string objects that have been initialized with values. 
Write an i f I else i f statement that compares the two objects. If their values are 
the same, it should print a message saying so and display their value. Otherwise, 
it should display the values in alphabetical order. 
4.33 
Indicate whether each of these character testing functions will return true or false. 
A) isalpha( 'B') 
E) isprint('B') 
B) isalnum ('B') 
F) ispunct('B') 
C) isdigit('B ') 
G) isupper( 'B') 
D) islower('B') 
H) isspace('B') 
The Conditional Operator 
CONCEPT: 
You can use the conditional operator to create short expressions that 
work like if I else statements. 
The conditional operator is powerful and unique . It provides a shorth and method of 
expressing a simple if /else statement . The operator consists of the question mark (?) and 
the colon (:). Its format is 
expression? 
expression 
expression
; 
Here is an examp le of a statement using the condit ional operator: 
X < 0? 
y = 10: 
Z = 20; 
This statement is called a conditional expression and consists of three subexpre ssions 
separated by the ? and : symbols . The expressions are x < o, y = 1 o, and z = 20. 
X < 0 
? 
y = 10 
z = 20; 

210 
Chapter 4 
Figure 4-9 
Making Decisions 
The conditional expression above performs the same operation as this if I else statement: 
if 
(x < 0) 
y = 10; 
else 
z = 20; 
Th e part of the conditional expression that comes before the question mar k is the 
cond ition to be tested. It's like the expression in the parentheses of an if statement . If 
the cond ition is true, the part of the statement between the ? and the : is executed. 
Otherwise , the part after the : is executed . Figure 4-9 illustrates the roles played by the 
three subexp ressions. 
1st expression: 
condition to 
be tested 
+ 
X < 0 
? 
y = 10 
t 
2nd expression: 
executes if the 
condition is true 
3rd expression: 
executes if the 
condition is false 
+ 
z = 20; 
If it helps, you can put parentheses around the subexpress ions, as shown here: 
( X < 0) ? ( y = 1 0) : ( Z = 20) ; 
0 
NO TE: Because it takes three operands, the conditional operator is a ternary operator. 
Using the Value of a Conditional Expression 
Remember, in C++ all expressions have a value, and this includes the conditional expression. 
If the first subexpression is true, the value of the conditional expression is the value of the 
second subexpression. Otherwise it is the value of the third subexpression. Here is an 
example of an assignment statement that uses the value of a conditional expression: 
a= 
(x > 100) ? 0 : 1; 
The value assigned to variable a will be either O or 1, depending on whether xi s greater 
than 100. This statement has the same logic as the following i f I els e statement: 
if 
(x > 100) 
a= 
O; 
els e 
a= 
1 ; 

4.11 The Conditional Operator 
211 
Program 4-22 can be used to help a consultant calculate her charges. Her rate is $50 
per hour, but her minimum charge is for five hours. The conditional operator is used in 
a statement that ensures the number of hours does not go below five. 
Program 4-22 
1 II This program calculates 
a consultant's 
charges 
at $50 
2 II per hour, 
for a mi nimum of 5 hours. 
The?: 
operator 
3 II adjusts 
hours to 5 i f fewer than 5 hours were worked. 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 using namespace std; 
7 
8 int main() 
9 { 
10 
11 
12 
13 
14 
const double PAY_RATE = 50.0; 
const i nt MIN_HOURS = 5; 
double hours , 
charges; 
15 
II Get the hours worked 
II Hourly pay rate 
II Minimum billable 
hours 
II Hours worked 
II Total charges 
16 
cout << "How many hours were worked?"; 
17 
cin 
>> hours ; 
18 
19 
II Determine how many hours to charge for 
20 
hours= 
hours< 
MIN_HOURS? MIN_HOURS: hours; 
21 
22 
II Calculate 
and display 
the charges 
23 
charges= 
PAY_RATE * hours; 
24 
cout <<fixed<< 
showpoint << setprecision(2) 
25 
<< "The charges 
are$"<< 
charges<< 
endl; 
26 
return 
O; 
27 } 
Program Output with Example Input Shown in Bold 
How many hours were worked? lO[Enter] 
The charges 
are $500.00 
Program Output with Other Example Input Shown in Bold 
How many hours were worked? 2[Enter] 
The charges 
are $250.00 
Let's look more closely at the statement in line 20 that uses a conditional expression: 
hours= 
hours< 
MIN_HOURS? MIN_HOURS : hours; 
If the value of the hours variable is less than MIN_HOURS, it stores MIN_HOURS in 
hours. Otherwise it assigns hours the value it already has. This ensures that hours 
will not have a value less than MIN_HOURS when it is used in line 23 to calculate the 
consultant's charges. 

212 
Chapte r 4 
0 
Making Decisions 
As you can see, the conditional operator gives you the ability to pack decision -making 
power into a concise line of code . With a little imagination it can be applied to many 
other programming problems. For instance , consider the following statement: 
cout << "Your grade is: 
"<<(score< 
60? 
"Fail . " : "Pass."); 
If you were to use an if I else statement, this statement would be written as follows: 
i f ( score < 60) 
cout << "Your grade is : Fail . "; 
else 
cout << "Your grade is : Pass."; 
NOTE: 
Th e parenthese s are placed around the condit iona l expression because the 
<< operator has higher precedence than the ? : operator. Without the parentheses , 
just the value of the express ion score < 60 wou ld be sent to cout. 
Checkpoint 
4 .34 
Rewrite the following if I el se statements as cond itional expressions . 
A) 
if 
(x > y) 
z = 1; 
else 
z = 20 ; 
B) 
if 
(temp > 45) 
populatio
n = base* 
10; 
else 
populatio
n = base* 
2 ; 
C) 
if 
(hours > 40) 
wages*= 
1 .5; 
else 
wages *= 1 . 
' 
D) if 
(result 
>= 0) 
cout << "The result 
is 
else 
cout << "The result 
is 
pos iti ve\n"; 
negat i ve . \n"; 
4.35 
Rewrite the following conditional expressions as if I else statements . 
A) 
j = k > 90 ? 57 : 12 ; 
B) factor= 
x >= 10? 
y * 22 : y * 35; 
C) total 
+=cou nt == 1 ? sales 
: count * sales; 
D) cout << ((num % 2) == 
0) ? "Even\n" 
: "Odd\n"); 
4.36 
What will the following program segment display? 
const 
i nt UPPER= 8, LOWER= 2; 
i nt num1, num2, num3 = 12 , num4 = 3; 
num1 = num3 < num4? UPPER 
num2 = num4 >UPPER? 
num3 
LOWER
; 
LOWER
; 
cout << num1 <<" 
"<< 
num2 << endl; 

4.12 
4.12 The switc h Statement 
213 
The switch Statement 
CONCEPT : Th e swi t ch statement uses the value of a variable or express ion to 
determine where the program will br anch to. 
A branch occurs when one part of a program causes another part to execute . The 
if I e 1 se i f statement introduced earlier allows your program to branch into one of 
several possible paths. It performs a series of tests (usually relational) and branches 
when one of these tests is true . The swi tc h statement is a similar mechanism. It, 
however, tests the value of an integer expression and then uses that value to determine 
which set of statements to branch to . Here is the format of the switc h statement: 
swi tch (IntegerExpression) 
{ 
} 
case 
ConstantExpression: 
II Place one or more 
II statements 
here 
case 
ConstantExpression: 
II Place one or more 
II statements 
here 
II case statements 
may be repeated 
II as many t i mes as necessary 
defaul t : 
II Place one or more 
II statements 
here 
The first line of the statement starts with the word switch, followed by an integer 
expression inside parentheses. This can be either of the following: 
• A variable of any of the integer data types (including char ). 
• An expression whose value is of any of the integer data types. 
On the next line is the beginning of a block contain ing several case statements. Each 
case statement is formatted in the following manner: 
case 
ConstantE xpression: 
II Place one or more 
II statements 
here 
After the word case is a constant expression (which must be of an integer type such as 
an in t or char), followed by a colon. The constant expression can be either an integer 
literal or an integer named constant . The expression cannot be a variable and it cannot 
be a Boolean expression such as x < 22 or n == 25. The case statement marks the 
beginning of a section of statements that are branched to if the value of the swi t ch 
expression matches that of the case expression. Not ice that, unlike most blocks of 
statements, no braces are required around this set of statements. 
(I) 
WARNING! 
The expressions of each case statement in the block must be unique. 

214 
Chapte r 4 
Making Decisions 
An optional default 
section comes after all the case statements. 
Thi s section is 
branched to if none of the case expressions match the switch expression . Thus , it 
functions like a trailing else in an if I else if statement. 
Program 4-23 shows how a simple switch statement works . 
Program 4-23 
1 II Thi s program demonstrates 
the use of a switch 
statement. 
2 II The program simply tells 
the user what character 
they entered. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
char cho i ce; 
9 
10 
cout << "Enter A, B, or C: "; 
11 
cin 
>> choice; 
12 
13 
swi tch (choice) 
14 
{ 
15 
16 
17 
18 
19 
case 
case 
case 
'A' :cout << 
break; 
'B' :cout << 
break; 
'C' :cout << 
20 
break; 
"You entered 
"You entered 
"You entered 
A. \n"; 
B. \n"; 
C. \n"; 
21 
default: 
cout << "You did not enter 
A, B, or C!\n"; 
22 } 
23 return 
O; 
24 
Program Output with Example Input Shown in Bold 
Enter A, B, or C: B[Ent er] 
You entered 
8. 
Program Output with Different Example Input Shown in Bold 
Enter A, B, or C: F[Enter] 
You did not enter 
A, B, or C! 
The first case statement is case 'A' : , the second is case 'B' : , and the third is case 'C' :. 
These statements mark where the program is to branch to if the variable choice contains the 
values 'A', 'B', or 'C'. (Remember , character variables and literals are considered integers.) 
The default section is branched to if the user enters anything other than A, B, or C. 
Notice the break statements at the end of the case 'A' , case 'B' , and case 'C' sections. 

0 
swi tch 
(choice) 
{ 
case 
'A': 
cout 
<< "You ent ered 
A.\n"; 
break; 
case 
'B': 
cout 
<< "You ent ered 
B.\n"; 
break; 
case 
'C': 
cout 
<< "You ent ered 
C. \n"; 
break; 
4.12 The switc
h Statement 
215 
default: 
cout 
<< "You di d not enter 
A, B, or C! \n"; 
} 
The break statement causes the program to exit the switch 
statement . The next 
statement executed after encountering a break statement will be whatever statement 
follows the closing brace that terminates the entire switc
h statement . A break statement 
is needed whenever you want to "break out of" a swit ch statement because it is not 
automatically exited after carrying out a set of statements the way an if/else 
if 
statement is. 
The case statements show the program where to start executing in the block, and the 
break statements show the program where to stop . Without the break statements, the 
program would execute all of the lines from the matching case statement to the end of 
the block. 
NOTE: The defaul
t section (or the last case section if there is no default
) does 
not need a break statement . Some programmers prefer to put one there anyway for 
consistency. 
Program 4-24 is a modification of Program 4-23 that demonstrates what happens if the 
break statements are omitted . 
Program 4-24 
1 // 
Thi s program 
demonstra t es how a swit ch statement 
2 II 
works 
i f t here 
are no break 
statements. 
3 #include 
<iostream> 
4 using 
namespace std; 
5 
6 int 
mai n () 
7 { 
8 
char 
cho i ce; 
9 
10 
cout 
<< "E nt er A , B, or C: "; 
11 
ci n 
>> choice; 
12 
(program continues) 

21 6 
Chapte r 4 
Making Decisions 
Program 4-24 
(continued) 
13 
II The following 
switch statement 
is miss i ng i ts break statements! 
14 
swi tch (cho i ce) 
15 
{ 
16 
case 'A' :cout << "You entered 
A. \n"; 
17 
case 'B':cout 
<< "You entered 
8. \n"; 
18 
case 'C':cout 
<< "You entered 
C. \n"; 
19 
default 
:cout << "You did not enter 
A, B, orC!\n"; 
20 
) 
21 
return 
O; 
22 ) 
Program Output with Example Input Shown in Bold 
Enter A, B, or C: A[Enter] 
You entered 
A. 
You entered 
B. 
You entered 
C. 
You did not enter A, B, or C! 
Program Output with Different Example Input Shown in Bold 
Enter A, B, or C: C[Enter] 
You entered 
C. 
You did not enter 
A, B, or C! 
Without the break statement, Program 4-24 "falls through" all of the statements below 
the one with the matching case expression. Sometimes this is what you want. Program 
4-25 lists the features of three TV models a customer may choose from. Model 100 
includes a 42-inch LCD flat screen. Model 200 includes a 1080p high-definition picture 
as well as a 42-inch LCD flat screen. Model 300 includes all of this as well as a built-in 
digital video recorder (DVR). The program uses a switch statement with carefully 
omitted breaks to print the features of the selected model. 
Program 4-25 
1 II Thi s program is carefully 
constructed 
to use the 
2 II 
"fall 
through" 
feature 
of the swi tch statement. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
int modelNum; 
9 
10 
II Di splay available 
models and get the user's 
choice 
11 
cout << "Our TVs come in three 
models: The 100, 200, and 300. \n"; 
12 
cout << "Which do you want? " ; 
13 
cin 
>> modelNum; 
14 
15 
II Di splay the features 
of the selected 
model 
16 
cout << "\nThat 
model has the follow i ng features:\n"; 
(program continues) 

4.12 The switch Statement 
217 
Program 4-25 
17 
(continued) 
18 
swi tch (model Num) 
19 
{ 
20 
21 
22 
23 
24 
25 
} 
case 300: cout <<" 
case 200: cout <<" 
case 100: cout <<" 
break ; 
Bui l t- i n DVR \ n"; 
1080p high definition 
picture 
\ n" ; 
42\ " LCD flat 
screen 
\ n" ; 
default 
cout << "You can only choose the 100 , 200 , or 300. \ n "; 
26 
return 
O; 
27
} 
Program Output with Example Input Shown in Bold 
Our TVs come in three 
models: The 100 , 200, and 300. 
Which do you want? lOO[Enter] 
That model has the following 
features: 
42" LCD flat screen 
Program Output with Different Example Input Shown in Bold 
Our TVs come in three 
models: The 100 , 200, and 300. 
Which do you want? 200[Enter] 
That model has the following 
features: 
1080p high definition 
picture 
42" LCD flat screen 
Program Output with Different Example Input Shown in Bold 
Our TVs come in three 
models: The 100 , 200, and 300. 
Which do you want? 300[Enter] 
That model has the following 
features: 
Built-in 
DVR 
1080p high definition 
picture 
42" LCD flat screen 
Program Output with Different Example Input Shown in Bold 
Our TVs come in three 
models: The 100 , 200, and 300. 
Which do you want? SOO[Enter] 
That model has the following 
features: 
You can only choose the 100, 200 , or 300. 
Another example of how useful this "fall through" capability can be is when you want 
the program to branch to the same set of statements for multiple case expressions. For 
instance, Program 4-26 asks the user to select a grade of dog food. The available choices 
are A, B, and C. The switch statement will recognize either uppercase or lowercase letters. 

218 
Chapte r 4 
Making Decisions 
Program 4-26 
1 I/ The swi tch statement 
i n this 
program uses the "fall 
through" 
feature 
2 II to accept 
both uppercase 
and lowerc ase letters 
entered 
by the user. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
char feedGrade ; 
9 
II Get the desired 
grade of feed 
10 
11 
12 
13 
14 
cout << "Our dog food is available 
in three 
grades:
\n"; 
cout << "A, 8, and C. Which do you want pricing 
for? 
cin 
>> feedGrade ; 
15 
II 
Find and display 
the price 
16 
swi tch(feedGrade) 
17 
{ 
18 
case ' a ': 
19 
case 'A': 
cout << "30 cents 
per pound.\n"; 
20 
break; 
21 
case 'b': 
22 
case 
'8': 
cout << "20 cents 
per pound.\n"; 
23 
break; 
24 
case ' c ': 
25 
case 'C': 
cout << "15 cents 
per pound.\n"; 
26 
break; 
27 
default 
cout << "That is an inval i d choice.
\ n"; 
28 
} 
29 
return 
O; 
30 } 
Program Output with Example Input Shown in Bold 
Our dog food is available 
in three 
grades: 
A, 8 , and C. Which do you want pricing 
for? 
b[Enter] 
20 cents 
per pound. 
... 
• 
Program Output with Different Example Input Shown in Bold 
Our dog food is available 
in three 
grades: 
A, 8 , and C. Which do you want pricing 
for? 
B[Ent er] 
20 cents 
per pound. 
When the user enters 'a ' , the corresponding case has no statements associated with 
it, so the program falls through to the next case , which corresponds with 'A' . 
case 'a': 
case 'A' :cout << "30 cents 
per pound.\n"; 
break; 
Th e same technique is used for 'b' and 'c' . 

4.12 The switch Statement 
219 
Using switch in Menu-Driven Systems 
The switch statement is a natural mechanism for building menu-driven systems like 
the one we built in Program 4-10. However in that program, once the user selects 
which package to purchase, the program uses an if I e 1 se if statement to calculate the 
charges . Program 4-27 modifies that program to use a switch statement instead. 
Notice how the switch statement is nested inside an if statement that validates the 
user's menu choice before prompting for the number of months. This means that the 
prompt and input for the number of months only have to appear once, and the user is 
never prompted to enter the number of months if the menu choice is invalid. 
Program 4-27 
1 II This menu-driven 
program uses a swit ch statement 
to carry out 
2 II the appropriate 
set of actions 
based on the user's 
menu choice. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
II Constants 
for membership rates 
10 
const double AOULT
_RATE = 120.0; 
11 
const double CHILO_RATE = 60.0; 
12 
const double SENIOR_RATE = 100.0; 
13 
14 
15 
16 
17 
int choice; 
II Menu choice 
int months; 
double charges; 
II Number of months 
II Monthly charges 
18 
II Display the menu and get the user's 
choice 
19 
cout <<" 
Health Club Membershi p Menu\n\n"; 
20 
cout << "1. Standard 
Adult Membership\n"; 
21 
cout << "2. Child Membership\n"; 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
cout << "3. Senior Citizen 
Membership\n"; 
cout << "4. Quit the Program\n\n"; 
cout << "Enter your choi ce: 
". 
' 
cin 
>> choice; 
II Vali date and process 
the menu choi ce 
if (choice >= 1 && choice <= 3) 
{ 
cout << "For how many months? .. 
' 
ci n >> months ; 
32 
II Set charges 
based on user i nput 
33 
switch 
(choice) 
34 
{ 
35 
case 1: 
36 
37 
38 
case 2: 
39 
case 3: 
40 
} 
charges 
break; 
charges 
break; 
charges 
= months * ADULT_RATE; 
= months * CHILO_RATE; 
= months * SENIDR_RATE; 
(program continues) 

220 
Chap ter 4 
Making Decisions 
Program 4-27 
(continued) 
41 
42 
43 
44 
} 
// Di splay the monthly 
charges 
cout <<fixed<< 
showpoint 
<< setprecision
(2); 
cout << "The total 
charges 
are$"<< 
charges<< 
end l; 
45 
el se if (choice 
!= 4) 
46 
{ 
cout << "The val i d choices 
are 1 thro ugh 4. \ n"; 
47 
cout << "Run the program again and se l ect one of these .\ n" ; 
48 
} 
49 
return 
O; 
50 } 
Program Output with Example Input Shown in Bold 
Health Club Membership Menu 
1. Standard 
Adult Membership 
2. Child Membership 
3. Senior Citizen 
Membership 
4. Quit the Program 
Enter your choice: 
2[Ent er] 
For how many months? 6[Ent er] 
The total 
charges 
are $360.00 
Program Output with Different Example Input Shown in Bold 
Health Club Membership Menu 
1. Standard 
Adult Membership 
2. Child Membership 
3. Senior Citizen 
Membership 
4. Quit the Program 
Enter your choice: 
5[Ent er] 
The valid 
choices 
are 1 through 
4. 
Run the program again and select 
one of these. 
~ 
Checkpoint 
4.37 
Explain why you cannot convert the following if / else if statement into a swi tch 
statement. 
i f (te mp == 100) 
x = 0 ; 
el se if (population> 
1000) 
X = 1; 
el se if (rate< 
.1) 
X = - 1; 

4.12 The switch Statement 
221 
4.38 
What is wrong with the following switch statement? 
swi tch (t emp) 
{ 
case temp < 0 
cout << "Temp is negative.\n"; 
break; 
case temp == 0: 
cout << "Temp is zero.
\n"; 
break; 
case temp > 0 
cout << "Temp is positive. 
\ n"; 
break; 
} 
4.39 
What will the following program segment display? 
i nt funny = 7 , serious= 
15; 
f unny= 
serious 
* 2 · ' 
swi tch (funny } 
{ 
case 0 
cout << "That is f unny . \n"; 
break; 
case 30: 
cout << "That is serious
. \n"; 
break; 
case 32: 
cout << "That is seriously 
funny. \ n"; 
break; 
default: 
cout << funny << endl; 
} 
4.40 
Comp lete the following program segment by writing a switch statement that 
displays "one" if the user enters 1, "two" if the user enters 2, and "three" 
if 
the user enters 3. If a number other than 1, 2, or 3 is entered, the program 
should display an erro r message . 
cout 
<< "Enter one of the numbers 1, 2 , or 3: "· 
ci n 
>> userNum; 
// Write the switch statement 
here . 
4 .41 
Rewrite the following program segment using a switch statement instead of the 
if / e 1 se i f statement . 
i nt selection; 
cout << "Which formula do you want 
cout << "1 . Area of 
cout << "2. Area of 
cout << "3. Area of 
cout << "4. None of 
cin 
>> selection; 
if (s el ection
== 1} 
a circle
\n"; 
a rectangle
\ n"; 
a cylinder
\n" 
them !\ n" ; 
to see?\n\n"; 
cout 
<< "Pi times radius 
squared \ n" ; 
else 
if (selection
== 2) 
cout 
<< "Length times width\n"; 
else 
if (selection
== 3) 
cout 
<< "Pi times radius 
squared 
times height\n"; 
else 
if (selection
== 4) 
cout 
<< "Well okay then, 
good-bye! \ n"; 
else 
cout 
<< "Not good with numbers, eh? \n"; 

222 
Chapte r 4 
4.13 
Making Decisions 
Enumerated Data Types 
CONCEPT: 
An enum erated data type in C++ is a progra mmer-defined data type 
whose legal values are a set of nam ed integer constants. 
So far we have used data types that are built into the C++ language, such as int and 
double , and object types, like string, 
which are provided by C++ classes. However, 
C++ also allows programmers to create their own data types. An enumerated data type 
is a programmer -defined data type whose only legal values are those associated with a 
set of named integer constants . It is called an enumerated type because the named 
constants are enumerated, or listed, as part of the definition of the data type. Here is an 
example of an enumerated-type declaration . 
enum Roster { Tom, Sharon, Bil l , Teresa, 
John}; 
This creates a data type named Roster. Because the word enum is a C++ key word , it 
must be in lowercase. However, notice that the data type name itself begins with a 
capital letter. Although this is not required, most programmers do capitalize this name. 
Th e named int eger constants associated with the Roster 
data type are called 
enumerat ors. A variab le of the Roster data type may only have one of the values 
associated with these enumerators . But what are their values? By default, the compiler 
sets the first enumerator to 0, the next one to 1, and so on. In our example then, the 
value of Tom would be 0, the value of Sharon would be 1, and so forth . Th e final 
enumerator, Jo hn, would have the value 4. Later in this section you will learn how to 
associate different values with these named constants if you wish. 
It is important to realize that the example enum statement does not actually create any 
variables. It just defines the data type. It says that when we later create variables of this 
data type, this is what they will look like- integers whose values are limited to the 
integers associated with the symbolic names in the enume rated set. Th e following 
statement shows how a variable of the Roster data type would be defined . 
Roster student ; 
The form of this statement is like any other variable definition: first the data type name, 
then the variable name . Notice that the data type name is Roster , not enum Roster. 
Now that the student variable has been created, it can be assigned a value, like this: 
student= 
Sharon; 
The value of the variable could then be tested like this: 
if (student
== Sharon) 
Notice in these two examples that there are no quotation marks around Sharon because 
it is a named constant, not a string literal. 
Even though the values in an enumerated data type are actually stored as integers, you 
cannot always substitute the integer value for the symbolic name . For example, we 
could not have assigned Sharon as the value of student like this: 
student= 
1; 
// Error! 

4.13 Enumerated Data Types 
223 
You can, however, test an enumerated variable by using an integer value instead of a 
symbolic name . For example, the following two if statements are equivalent . 
i f (st udent --
Bill) 
i f (st udent== 
2) 
You can also use relational operators to compare two enumerated variables. For 
example, the following i f statement determines if the value stored in studen t 1 is less 
than the value stored in student2: 
i f (st udent1 < student2) 
If studen t 1 equals Bi 11 and student2 
equals Joh n, this statement would be true . 
However, if student1 equals Bi 11 and student2 equals Sharon, the statement would 
be false. 
As mentioned earlier, the symbols in the enumeration list are assigned the integer 
values 0, 1, 2, and so forth by default . If this is not appropriate, you can specify the 
values to be assigned, as in the following example. 
enum Department {factory= 
1, sales= 
2, warehouse= 
4 }; 
Remember that if you do assign values to the enumerated symbols, they must be 
integers . The following value assignments would produce an error. 
enum Department {factory= 
1.0, sales= 
2.0, warehouse= 
4.0 }; 
// Error! 
Although there is no requirement that assigned integer values be placed in ascending 
order, it is generally considered a good idea to do so. 
If you leave out the value assignment for one or more of the symbo ls, they will be 
assigned default values, as illustrated by the following two examples . 
enum Colors { red, orange, yellow= 
9, gree n, blue}; 
In this example, the named constant red will be assigned the value 0, orange will be 1, 
yellow will be 9, green will be 10, and blue will be 11. 
enum Rooms { livingroom = 1, den, bedroom, kitche n }; 
In this examp le, 1 i vi ngroom will be assigned the value 1, den will be 2, bedroom will be 
3, and kitc hen will be 4. 
One purpose of an enumerated data type is that the symbolic names help to make a 
program self-documenting. However, because these names are not strings, they are for 
use inside the program only. Using the Rost er data type in our example, we see that 
the following two statements would output a 2, not the name Sharo n. 
Roster t opSt udent = Sharon; 
cout << topStudent; 
Because the symbolic names of an enumerated data type are associated with integer 
values, they may be used in a switch statement, as shown in Program 4-28 . This 
program also demonstrates that it is possible to use an enumerated data type without 
actually creating any variables of that type. 

224 
Chap ter 4 
Making Decisions 
Program 4-28 
1 II Thi s program demonstrates 
an enumerated 
data type. 
2 #inc l ude <iostream> 
3 using namespace std ; 
4 
5 II Decl are the enumerated 
type 
6 enum Roster 
{Tom = 1 , Sharon , Bil l, Teresa , John
}; 
7 
II Sharon - John will 
be ass i gned defa ult va l ues 2-5 . 
8 int main () 
9 { 
10 
i nt who; 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
cout << "Thi s program wil l gi ve you a st udent ' s birthday. 
\ n"; 
cout << "Whose bi r thday do you want to know?\ n"; 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 } 
cout << .. 1 = Tom\n"; 
cout << "2 = Sharon \ n"; 
cout << "3 = Bill \ n"; 
cout << " 4 = Teresa \ n"; 
cout << "5 = J ohn\ n"; 
cin 
>> who; 
swi tch (who) 
{ 
case Tom 
cout << 
break ; 
case Sharon : 
cout << 
break ; 
case Bi 11 
cout << 
break ; 
case Teresa : 
cout << 
break ; 
case J ohn 
cout << 
break ; 
default 
cout << 
} 
ret urn O; 
"\ nTom' s bi r t hday is Janua r y 3 .\ n"; 
"\ nSharon ' s bi rthday 
is Apr il 22 .\ n" ; 
"\ nBil l' s bi rthday 
is December 19 . \ n"; 
"\ nTeresa ' s bi rthday 
is Februa r y 2 .\ n" ; 
"\ nJohn's 
bi rthday 
is J une 17 . \ n"; 
"\ nlnvalid 
selec ti on\ n"; 
Program Output with Example Input Shown in Bold 
This program wi ll give you a student's 
bi rthday. 
Whose birthday 
do you want to know? 
1 = Tom 
2 = Sharon 
3 = Bi 11 
4 = Teresa 
5 = John 
2[Enter] 
Sharon's 
bi rthday 
is April 
22. 

4.14 Focus on Testing and Debugging: Validating Output Results 
225 
You will learn more about working with enumerated data types in later chapters . 
~ 
Checkpoint 
4.42 
Find all the things that are wrong with the following declaration . 
Enum Pet = { "dog", 
"cat", 
"bird", 
"fish" 
} 
4.43 
Follow the instructions to complete the following program segment . 
enum Paint 
{ red , blue, 
yellow, 
green, 
orange, 
purple}
; 
Paint 
color= 
green; 
// Write an if/else 
statement 
that wi ll print 
out "pri mary color" 
// if color 
is red , blue, 
or yellow, 
and will 
print 
out 
// "mixed color" 
otherw i se . The i f test 
should use a relat
i onal 
// expression
. 
4.14 
Focus on Testing and Debugging: 
Validating Output Results 
CONCEPT: 
When testing a newly created or modified program , the output it 
produces must be carefully examined to ensure it is correct. 
Once a program being developed has been designed, written in a programming 
language , and found to compile and link without errors, it is easy to jump to the 
conclusion that it works correctly. This is especially true if it runs without aborting 
and produces "reasonable" 
output . However , just because a program runs and 
produces output does not mean that it is correct. It may still contain logic errors that 
cause the output to be incorrect. To determine if a program actually works correctly, 
it must be tested with data whose output can be predicted and the output examined 
to ensure it is accurate . 
Program 4-29 runs and produces output that may initially appear reasonable. However, 
it contains a bug that causes it to produce incorrect output. 
Program 4-29 
1 // This program determines 
a client's 
total 
buffet luncheon cost 
2 II when the number of guests 
and the per person cost are known. 
3 II 
It conta i ns a log i c error. 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 using namespace std; 
7 
8 const 
int ADULT_MEAL
_COST = 6.25; 
II Chi ld meal cost= 
75% of this 
9 
(program continues) 

226 
Chapte r 4 
Making Decisions 
Program 4-29 
(continued) 
10 int main() 
11 { 
12 
int 
13 
numAdults, 
numChil dren; 
adultMealTotal, 
childMealTotal, 
total Meal Cost; 
II Number of guests 
ages 12 and old er 
II Number of guests 
ages 2-11 
14 
double 
II Cost fo r all 
adult 
meals 
15 
II Cost fo r all 
child 
meals 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
II Get 
cout << 
<< 
cout << 
cin 
>> 
cout << 
cin 
>> 
number of adults 
and children 
attending 
"This program calculates 
total 
cost 
" 
"for a buffet 
l uncheon .\n"; 
"Ent er the number of adu lt guests 
(ag e 
numAdults; 
"Ent er the number of chi l d guests 
(ag e 
numChildren; 
26 
I I Calculate 
meal costs 
27 
adultMealTotal 
= numAdults * ADULT_MEAL
_COST; 
12 and 
2- 11): 
28 
childMealTotal 
= numChi l dren 
* ADULT_MEAL
_COST * .75 ; 
29 
totalMealCost 
= adultMealTotal 
+ childMealTotal; 
30 
31 
II Display 
total 
meal cost 
32 
cout <<fixed<< 
showpoint << setprec
i sion(2); 
over) : 
". 
' 
33 
cout << "\n Total 
buffet 
cost is $" << totalMealCost 
<< endl ; 
34 
return 
O; 
35 } 
Program Output with Example Input Shown in Bold 
This program calculates 
total 
cost for a buffet 
luncheon. 
Enter the number of adult 
guests 
(age 12 and over}: 
92[Enter] 
Enter the number of child 
guests 
(age 2-11): 
4[Enter] 
Total buffet 
cost is $570.00 
". 
' 
At first glance the program may appear to run correctly. The per person charge for adults 
is $6.25, so if there were 100 adult guests the price would be $625. But there are only 96 
guests and four of them are children, so it should cost less. $570 sounds "abo ut right." 
However, "about right" is not a sufficient test of accuracy. If the program had been 
run with data whose output could have been more easily checked, the programmer 
would have quickly seen that there is an error. Here is the output from two more runs 
of the same program using more carefully selected sample data. 
Program Output with Different Example Input Shown in Bold 
This program calculates 
total 
cost for a buffet 
lun cheon . 
Enter the number of adult 
guests 
(age 12 and over }: l[Enter] 
Enter the number of child 
guests 
(age 2-11): 
O[Enter] 
Total buffet 
cost is $6 .00 

4.15 Green Fields Landscap ing Case Study- Part 2 
22 7 
Program Output with Still Different Example Input Shown in Bold 
This program calculates 
total 
cost for a buffet 
lun cheon . 
Enter the number of adult 
guests 
(age 12 and over ): O[Enter] 
Enter the number of child 
guests 
(age 2-11): 
l[Enter] 
Total buffet 
cost i s $4 .50 
From this outp ut we can see that the cost of a child meal is correctly being calculated 
as 75 percent of the cost of an adult meal, but the adult meal cost is wrong. For one 
adult, it is coming out as $6.00, when it shou ld have been $6.25. 
To find the problem, the programmer should determine which lines of code are most a pt to 
have caused the problem . Most likely, something is wrong either in the initialization or 
storage of ADULT
_MEAL
_COST on line 8, in the calculation or storage of adul tMeal Tota l or 
total Meal Cost on lines 14, 16, 27, and 29, or in the printing of totalMealCost on line 33. 
Because the cost for one adult meal is erroneo usly coming out as a whole dollar amount, 
even though it is formatted to appear as a floating-point number, one of the things to check 
is whether all the variables that need to hold floating-point values have been defined as 
type float or double. Sure enough, although adultMealTotal and total Meal Cost have 
each been defined as a doub 1 e, the named constant ADULT 
_MEAL
_COST has been defined to 
be an i nt. So the 6.25 with which it is initialized is truncated to 6 when it is stored. When 
the definition of this named constant is rewritten as 
const doubl e ADULT
_MEAL
_COST = 6.25 ; 
and the program is rerun, we get the following results. 
Output of Revised Program with Example Input Shown in Bold 
This program calculates 
total 
cost for a buffet 
lun cheon . 
Enter the number of adult 
guests 
(age 12 and over ): l[Enter] 
Enter the number of child 
guests 
(age 2-11): 
O[Enter] 
Total buffet 
cost i s $6 .25 
Now that this error has been found and fixed, the program is correct . However, additional 
testing with carefully developed test cases should be used to confirm this conclusion. The 
topic of how to develop good test cases will be dealt with further in the next chapter. 
Green Fields Landscaping Case Study-Part 
2 
Problem Statement 
Another of the services provided by Green Fields Landscaping is the sale of evergreen trees, 
which are priced by height. Customers have the choice of purchasing a tree on a "cash and 
carry" basis, of purchasing a tree and having it delivered, or of purchasing a tree and 
having it both delivered and planted . Table 4-13 shows the price for each of these choices. 
You have been asked to develop a program that uses the number of trees purchased , their 
height, and the delivery and planting information to create a customer invoice. To simplify 
the program you may assume that all trees purchased by a customer are the same height. 

228 
Chapte r 4 
Making Decisions 
Table 4-13 
Evergreen Tree Pricing Infor mation 
Under 3 feet tall 
3 to 5 feet tall 
6 to 8 feet tall 
over 8 feet tall 
delivery only (per tree) 
delivery + planting 
Program Design 
Program Steps 
39.00 (t ax included) 
69 .00 (t ax included) 
99.00 (t ax included) 
199 .00 (t ax included) 
20.00 (100 .00 max. per 
50% of the cost of the 
The program must carry out the following general steps: 
order) 
tree 
1. Have the user input the number of trees purchased and their height. 
2. Have the user indicate if the trees will be planted by Green Fields. 
3. If planting service is not desired, have the user indicate if delivery is wanted . 
4. Calculate the total tree cost. 
5. Calculate the planting and delivery charges. 
6. Calculate the total of all charges. 
7. Print a bill that displays the purchase information and all charges. 
Named constants 
double PRICE_ 1 = 39 .00 
double PRICE_2 = 69.00 
double PRICE_3 = 99 .00 
double PRICE_4 = 199 .00 
double PER_TREE_DELIVERY = 20.00 
double MAX
_DELIVERY = 100.00 
Variables whose values will be input 
int 
numTrees 
int 
height 
char planted 
char delivered 
// Number of evergreen 
trees 
purchased 
// Tree height 
to the nearest 
foot 
// Are trees 
to be planted?
( 'Y'/' N') 
// Are trees 
to be delivered?
('Y' /' N') 
Variables whose values will be output 
double treeCost 
II Cost of each tree 
double totalTreeCost 
II Total price 
for all 
the trees 
double deliveryCost 
II Delivery 
cost for all 
the trees 
double plantingCost 
II Planti
ng cost for all 
the trees 
double total Charges 
II Total i nvoice amount 

4.15 Green Fields Landscap ing Case Study- Part 2 
229 
Detailed Pseudocode (including actual variable names and needed calculations) 
Initialize 
deliveryCost 
and plantingCost 
to 0 
Display 
screen heading 
Input numTrees, height, 
planted 
If planted= 
'N' 
Input delivery 
End If 
If height 
< 3 
treeCost 
= PRICE_1 
Else If height<= 
5 
treeCost 
= PRICE_2 
Else If height<= 
8 
treeCost 
= PRICE_ 3 
Else 
treeCost 
= PRICE_ 4 
End If 
tota7TreeCost 
= numTrees • treeCost 
If planted 
= 'Y' 
plantingCost 
= tota7TreeCost 
I 2 
II deliveryCost 
stays 
0 
Else If delivered= 
'Y ' 
If numTrees <= 5 
deliveryCost 
= PER_TREE_DELIVERY * numTrees 
Else 
deliveryCost 
= MAX_DELIVERY 
End If 
End If 
tota7Charges 
= tota7TreeCost 
+ deliveryCost 
+ plantingCost 
Display 
invoice 
heading 
Display 
numTrees, 
treeCost, 
tota7TreeCost, 
deliveryCost, 
plantingCost, 
tota7Charges 
The Program 
The next step, after the pseudocode has been checked for logic errors, is to expand the 
pseudocode into the final program. This is shown in Program 4-30. 
Program 4-30 
1 II This program is used by Green Fields 
Landscaping 
to 
2 II create 
customer i nvoi ces for evergreen 
tree 
sales
. 
3 #include 
<i ostream> 
4 #include 
<i omanip> 
5 using namespace std; 
6 
7 int mai n() 
8 { 
const double PRICE_1 = 
PRICE_2 = 
PRICE_3 = 
39.00, 
69.00, 
99.00, 
9 
10 
11 
12 
13 
PRICE_4 = 199.00; 
II Set prices 
for different 
II size trees 
14 
const double PER TREE DELIVERY= 20.00, 
II Set delivery 
fees 
15 
MAX
_DELIVERY = 100. 00; 
(program continues) 

230 
Chapte r 4 
Making Decisions 
Program 4-30 
16 
(continued) 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
int 
numTrees, 
II Number of evergreen 
trees 
purchased 
height; 
II Tree height 
to the nearest 
foot 
cha r 
planted, 
II Are trees 
to be planted ?('Y'/'
N') 
del i vered; 
II Are trees 
to be delivered?('Y'/'N') 
double treeCost, 
II Cost of a par ticular 
tree 
totalTreeCost, 
II Total pr i ce fo r a 11 t he trees 
del i veryCost 
= 0.0, 
II Delivery 
cost for all 
the trees 
plant i ngCost = 0.0, 
II Planting 
cost for all 
the trees 
totalCharges; 
II Total 
invo ic e amount 
27 
II 
Display 
purchase 
screen 
and get purchase 
i nformation 
28 
cout <<" 
Green Fields 
Landscaping \ n" 
29 
<<" 
Evergreen 
Tree Purchase \n\n"; 
30 
cout << "Number of trees 
purchased: 
"; 
31 
32 
33 
34 
35 
36 
ci n 
cout 
ci n 
cout 
ci n 
>> numTrees; 
<< "Tree height 
to the nearest 
foot: 
"; 
>> heigh t; 
<< "Wi ll Green Fields 
do the planting?(Y/N): 
"; 
>> planted; 
37 
if (!(pl anted
== 'Y' II planted== 
'y')) 
38 
{ 
cout << "Do you want the trees 
delivered? 
(Y/ N): 
"; 
39 
cin 
>> delivered
; 
40 
) 
41 
42 
II Calculate 
costs 
43 
i f (height 
< 3) 
44 
treeCost 
= PRICE_ 1; 
45 
else 
if(height 
<= 5) 
46 
treeCost 
= PRICE_2 ; 
47 
else 
if(height 
<= 8) 
48 
treeCost 
= PRICE_3; 
49 
else 
50 
treeCost 
= PRICE_4; 
51 
52 
totalTreeCost 
= numTrees * treeCost; 
53 
54 
if ((p lanted
== 'Y') II (plant ed == 'y')) 
55 
plant i ngCost = totalTreeCost 
/ 2; 
56 
else 
if((del
i vered == 'Y') 
I I (de liv ered
== 'y')) 
57 
if ( numTrees <= 5) 
58 
del i veryCost 
= PER_TREE_DELIVERY * numTrees ; 
59 
el se 
60 
del i veryCost 
= MAX_DE
LIVERY; 
61 
// el se plant i ng and del i very costs 
bot h remai n 0.0 
62 
63 
totalCharges 
= totalTreeCost 
+ de liv eryCost 
+ plant i ngCost; 
64 
(program continues) 

4.15 Green Fields Landscap ing Case Study- Part 2 
231 
Program 4-30 
(continued) 
65 
II 
Display 
information 
on the invoice 
66 
cout 
<<fixed<< 
showpoi nt << setprecision(2); 
67 
cout 
<< "\n\n 
Green Fields 
Landscaping\n" 
68 
<<" 
Evergreen 
Tree Purchase\n\n"; 
69 
cout 
<< setw(2) 
<< numTrees << " trees 
@ $" << setw(6) 
<< treeCost 
70 
<<"each= 
$" << setw(8) 
<< totalTreeCost 
<< endl; 
71 
cout 
<< "Delivery 
charge 
$" 
72 
<< setw(8) 
<< del i veryCost 
<< endl; 
73 
cout 
<< "Pl anting 
charge 
$" 
74 
<< setw(8) 
<< plantingCost 
<< endl; 
75 
cout 
<< " 
____ 
" << endl ; 
76 
cout 
<< "Total Amount Due 
$" 
77 
<< setw(8) 
<< totalCharges 
<< endl << endl; 
78 
return 
O; 
79 } 
Program Output with Example Input Shown in Bold 
Green Fields 
Landscaping 
Evergreen Tree Purchase 
Number of trees 
purchased: 
4[Enter] 
Tree height 
to the nearest 
foot: 
7[Enter] 
Will Green Fields 
do the planting?(YIN): 
y[Enter] 
Green Fields 
Landscaping 
Evergreen 
Tree Purchase 
4 trees@$ 
99.00 each= 
Delivery 
charge 
Planting 
charge 
Total Amount Due 
$ 
396.00 
$ 
0.00 
$ 
198.00 
$ 
594.00 
Crazy Al's Computer Emporium Case Study 
The following add itiona l case study, which contains app licat ions of material 
introduced in Chapter 4, can be found on the book's companion website at 
pearsonhighered.com/gaddis. 
Crazy Al's is a retail seller of home computers whose sales staff all work on commission. 
The commission rate varies depending on the amount of sales. This case study develops 
a program that computes month ly sales commission and then subtracts any pay already 
advanced to the salesperson to calculate how much remaining pay is due at the end of 
the month. The case study, which employs branching logic to determine the correct 
commission rate, includes problem definition, general and detailed pseudocode design, 
and a final running program with sample output . 

232 
Chapte r 4 
Making Decisions 
Tying It All Together: Fortune Teller 
4.16 
~ With the rand () function you learned about in Chapter 3 and the i f/else 
if statement 
you learned about in this chapter, you can now create a simp le fortune telling game. 
Your program will start by asking users to enter three careers they would like to have 
some day. The program will then use random numbers to predict their future . 
Program 4-31 
1 // Thi s program pred i cts the player's 
future 
using 
2 II 
random numbers and an if/e l se i f statement. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 #include 
<cstd l ib> 
6 using namespace std; 
7 
8 
9 
int main() 
{ 
II Needed to use str i ngs 
II Needed for random numbers 
// Str i ngs to hold user entered 
careers 
string 
career1, 
career2, 
career3; 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
int randomNum; 
// Will hol d the randoml y generated 
integer 
II 
"Seed" the random generator 
unsigned 
seed= 
t i me(O); 
srand (seed) ; 
// Expla i n the game and get the player's 
career 
cho i ces 
cout << "I am a fortune 
te l ler. 
Look into my crystal 
screen 
\n" 
<< "and enter 
3 careers 
you would l ike to have. Example: \n\n" 
<<" 
chef \n 
astronaut 
\n 
CIA agent \n\n" 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
<< "Then I wi ll predict 
what you wil l be. \n\n"; 
cout << "Career cho i ce 
getl i ne(cin, 
career1); 
cout << "Career cho i ce 
getl i ne(cin, 
career2); 
cout << "Career cho i ce 
getl i ne(cin, 
career3); 
1 
2: 
3: 
" 
" 
" 
// Randoml y generate 
an integer 
between 
1 and 4. 
randomNum = 1 +rand()% 
4; 
II Use branching 
l ogi C to output 
the prediction 
if (randomNum == 1 ) 
cout << "\nYou wi ll be a " << career1 
<< " 
\n"; 
else 
if (randomNum == 2) 
cout << "\nYou wi ll be a " << career2 
<< " 
\n"; 
else 
if (randomNum == 3) 
cout << "\nYou wi ll be a " << career3 
<< " 
\n"; 
42 
else 
43 
cout << "\nSorry. 
You wil l not be any of these. 
\n"; 
44 
return 
O; 
45
} 
(program continues) 

Program 4-31 
(continued) 
Sample Run with User Input Shown In Bold 
I am a fortun e t ell er. Look in t o my crystal 
scr een 
and ent er 3 car eer s you would like to have . For example, 
chef 
astronaut 
CIA agent 
Then I wi ll pr edi ct what you will 
be. 
Career choi ce 1 : radio announcer[Enter] 
Career choi ce 2: sky diving lnstrudor[Enter] 
Career choi ce 3: drcusdown[Enter] 
You will 
be a radio announce r . 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
Review Questions and Exercises 
233 
1. An expression using the greater-than, less-than, greater-than -or-equal-to, less-than-
or-equal-to, equal, or not-equal operator is called a(n) _____ 
expression. 
2. The value of a relationa l expression is O if the expression is _____ 
or 1 if 
the expression is ____ 
_ 
3. The i f statement regards an expression with the value O as _____ 
and an 
expression with a nonzero value as ____ 
_ 
4. For an if statement to condit ionally execute a group of statements, the 
statements must be enclosed in a set of -----
5. In an if / el se statement, the i f part executes its statement(s) if the expression is 
____ 
, and the el se part executes its statement(s) if the expression is _____ 
. 
6. The trailing e l se in an if I e l se i f statement has a similar purpose as the 
section of a swit ch statement . 
-----
7. If the subexpression on the left of the && logical operator is _____ 
, the 
right subexpression is not checked. 
8. If the subexpression on the left of the I I logical operator is _____ 
, the 
right subexpression is not checked. 
9. The ____ 
logical operator has higher precedence than the other logical 
operators . 
10. Logical operators have _____ 
precedence than relational operators. 
11. The _____ 
logical operator works best when testing a number to determine 
if it is within a range. 
12. The _____ 
logical operator works best when testing a number to determine 
if it is outside a range. 
13. A variable with _____ 
scope is only visible when the program is executing 
in the block containing the variable's definition. 

234 
Chapte r 4 
Making Decisions 
14. The expression that is tested by a swi tc h statement must have a(n) _____ 
value. 
15. A program will "fall through" to the following case section if it is missing the 
_____ 
statement . 
16. What value will be stored in the variable t after each of the following statements 
executes? 
A) t = ( 12 > 1 ) ; 
B) 
t = (2 < O); 
C) t = (5 == (3 * 2)) ; 
D) t = ( 5 == 5); 
17. Write an if statement that assigns 100 to x when y is equal to 0. 
18. Write an if /e l se statement that assigns Oto x when y is equal to 10. Otherwise 
it should assign 1 to x. 
19. Write an if/ el se statement that prints "Excellent" when score is 90 or higher, 
"Good" when score is between 80 and 89, and "Try Harder" when score is 
less than 80. 
20. Write an if statement that sets the variable hours to 10 when the flag variable 
minimum is set to true . 
21. Convert the following conditional expression into an if/ else statement . 
q = (x < y) ? (a + b) 
: (x * 2); 
22. Convert the following if/else 
if statement into a switch statement: 
i f (choice== 
1) 
cout <<fixed<< 
showpoin t << se t precision(2); 
else 
if ((choice== 
2) I I (cho i ce== 
3)) 
cout << fixed 
<< s howpoint << se t precision(4); 
else 
if (choice== 
4) 
cout << fixed 
<< showpoin t << se t precision(6); 
else 
cout << fixed 
<< showpoin t << se t precision(8); 
23. Assume the variables x = 5, y = 6, and z = 8. Indicate if each of the following 
conditions is true or false: 
A) 
( x --
5) I I ( y > 3) 
B) 
( 7 <= x) && ( z > 4) 
C) 
( 2 ! = y) && ( z ! = 4) 
24. Assume the variables x = 5, y = 6, and z = 8. Indicate if each of the following 
conditions is true or false: 
A) ( x >= 0) I I ( x <= y) 
B) 
(z -
y) > y 
C) 
! ( ( z - y) > X ) 
Algorithm Workbench 
25. Write a C++ statement that prints the message "The number is valid." if the 
variab le grade is within the range O through 100. 
26. Write a C++ statement that prints the message "The number is valid." if the 
variab le t emperat ure is within the range -50 through 150. 

Review Questions and Exercises 
235 
27. Write a C++ statement that prints the message "The number is not valid." if the 
variab le hours is outside the range O thr ough 80. 
28. Write a C++ stat ement that displays the titles stored in the st ring objects book1 
and book2 in alphabetical order. 
29. Using the following chart, write a C++ statement that assigns .10, .15, or .20 to 
commi ssion, depending on the value in sa l es . 
Sales 
Up to $10,000 
$10,000 to $15,000 
Over $15,000 
Commission Rate 
10% 
15% 
20% 
30. Write one or more C++ statements that assign the correct value to di scoun t , 
using the logic described here: 
Assign .20 to di scount if dept equals 5 and price is $100 or more. 
Assign .15 to di scount if dept is anything else and price is $100 or more . 
Assign .10 to di scount if dept equals 5 and price is less than $100. 
Assign .05 to di scount if dept is anything else and price is less than $100. 
31. The following statement should determine if x is not greater than 20. What is 
wrong with it? 
if 
( ! X > 20) 
32. The following statement shou ld determine if count is within the range of 0 
thr ough 100. What is wrong with it ? 
if 
(count>= 
0 I I count <= 100) 
33. The following statement should determine if count is outside the range of 0 
thr ough 100. What is wrong with it? 
if 
(count< 
O && count> 
100) 
34. The following statement should determine if x has a value other than 1 or 2. 
What is wrong with it? 
if 
(x ! = 1 11 x ! = 2) 
Find the Errors 
35. Each of the following program segments has errors . Find as many as you can. 
A) 
cout << "Enter your 3 tes t scores 
and I wi 11 " ; 
<< "average the m:"; 
i nt score1, 
score2, 
score3, 
ci n 
>> score1 >> score2 >> score3; 
doubl e average= 
(s core1 + score2 
+ score3) 
/ 3 .0; 
if (average= 
100); 
perfectScore 
= true; 
// Set the flag variable 
cout << "Your average is"<< 
average<< 
endl; 
bool perfectScore; 
if (perfec t Score); 
cout << "Congratulat
i ons!\n"; 
cout << "That 's a perfect 
score . \n"; 
cout << "You deserve 
a pat on the back!\n"; 

236 
Chapte r 4 
Making Decisions 
B) 
doub l e num1, num2, quotient; 
cout << "Enter a number: ". 
' 
ci n 
>> num1; 
cout << "Enter another 
number: ". 
ci n 
>> num2; 
if (num2 == 0) 
co ut << "Division 
by zero i s not possible.\
n"; 
cou t << "Please 
run t he program again"; 
cou t << "and enter 
a number besides 
zero.\n"; 
else 
quot ien t = num1 / num2; 
cou t << "The quoti ent of"<< 
num1 << 
co ut <<" 
di vi ded by"<< 
num2 <<"is"· 
co ut <<q uotient<< 
endl; 
C) i nt t estScore; 
cout << "Enter your tes t score and I wil l tel l you\n"; 
cout << "the letter 
grade you ear ned: "· 
ci n 
>> t estScore; 
if (t estScore 
< 60) 
cou t << "Your grade i s F. \ n"; 
else 
i f (testScore 
< 70) 
cou t << "Your grade i s D. \ n"; 
else 
i f (testScore 
< 80) 
cou t << "Your grade i s C. \ n"; 
else 
i f (testScore 
< 90) 
cou t << "Your grade i s 8. \ n"; 
else 
cou t << "That is not a va li d score.\n"; 
else 
i f (testScore 
<= 100) 
cou t << "Your grade i s A.\ n"; 
D) doub l e tes t Score; 
cout << "Enter your tes t score and I wil l tel l you\n"; 
cout << "the letter 
grade you ear ned: "· 
ci n 
>> t estScore; 
switc h (t estScore) 
{ case (t estScore 
< 60. 0): 
cout << "Your grade is F . \n"; 
case (t estScore 
< 70.0): 
co ut << "Your grade is D. \n"; 
case (t estScore 
< 80. 0) : 
cout << "Your grade is C. \n"; 
case (t estScore 
< 90.0): 
co ut << "Your grade is B. \n"; 
case (t estScore 
<= 100.0): 
cout << "Your grade is A . \n"; 
defaul t : 
cout << "That score i s n 't val i d\n"; 
} 
} 

Programming Challenges 
237 
Soft Skills 
Programmers need to be able to look at alternative approaches to solving a problem 
and at different ways of implementing a solution, weighing the pros and cons of each. 
Further, they need to be able to clearly articulate to others why they recommend, or 
have chosen, a particular solution. Come to class prepared to discuss the following: 
36. Sometimes either a swi t ch statement or an i f I else 
if statement can be used to 
implement logic that requires branching to different blocks of program code. But 
the two are not interchangeable. 
A) Under what circumstances wou ld an if I e l se if statement be a more 
appropriate choice than a switch statement? 
B) Under what circumstances would a switc
h statement be a more appropriate 
choice than an i f I else 
if statement? 
C) Under what circumstances would a set of nested i f I else statements be more 
appropriate than either of the other two structures? 
Try to come up with at least one example case for each of the three, where it is the best 
way to implement the desired branching logic. 
Programming 
Challenges 
1. Minimum / Maximum 
Write a program that asks the user to enter two numbers. The program should use the 
conditional operator to determine which number is the smaller and which is the larger. 
2. Roman Numeral Converter 
Write a program that asks the user to enter a number within the range of 1 through 10. 
Use a switch statement to display the Roman numeral version of that number. 
Input Validation: Decide how the program should handle an input that is less 
than 1 or greater than 10. 
3. Magic Dates 
The date June 10, 1960, is special because when we write it in the following format, 
the month times the day equals the year. 
6/10/60 
Write a program that asks the user to enter a month (in numeric form), a day, and a 
two-digit year. The program should then determine whether the month times the day is 
equal to the year. If so, it should display a message saying the date is magic. Otherwise, 
it should display a message saying the date is not magic. 
Input Validation: Think about what legal values the program should accept for 
month and day. 
4. Areas of Rectangles 
The area of a rectangle is the rectangle's length times its width. Write a program that 
asks for the length and width of two rectangles. The program should then tell the user 
which rectangle has the greater area or if the areas are the same. 

238 
Chapte r 4 
a 
VideoNote 
Solving the 
Time 
Calculator 
Problem 
Making Decisions 
5. Book Club Points 
An online book club awards points to its customers based on the number of books 
purchased each month . Points are awarded as follows: 
Books Purchased 
0 
1 
2 
3 
4 or more 
Points Earned 
0 
5 
15 
30 
so 
Write a program that asks the user to enter the number of books purchased this month 
and then displays the number of points awarded . 
6. Change for a Dollar Game 
Create a change-counting game that asks the user to enter what coins to use to make 
exactly one dollar. The program should ask the user to enter the number of pennies, 
nickels, dimes, and quarters. If the total value of the coins entered is equa l to one 
dollar, the program should congratulate the user for winning the game. Otherwise, the 
program shou ld display a message indicating whether the amount entered was more or 
less than one dollar. Use constant variables to hold the coin values. 
7. Time Calculator 
Write a program that asks the user to enter a number of seconds . 
• There are 86400 seconds in a day. If the number of seconds entered by the user 
is greater than or equal to 86400, the program should display the number of 
days in that many seconds. 
• There are 3600 seconds in an hour. If the number of seconds entered by the 
user is less than 86400 but is greater than or equal to 3600, the program 
should display the number of hours in that many seconds . 
• There are 60 seconds in a minute. If the number of seconds entered by the user 
is less than 3600 but is greater than or equal to 60, the program should display 
the number of minutes in that many seconds . 
8. Math Tutor Version 2 
This is a modification of the math tutor Programming Challenge problem in Chapter 3. 
Write a program that can be used as a math tutor for a young student . The program 
shou ld display two random numbers between 10 and 50 that are to be added, such as: 
24 
+ 12 
The program should then wait for the student to enter the answer. If the answer is 
correct, a message of congratulat ions should be printed. If the answer is incorrect, a 
message should be printed showing the correct answer. 

Programming Challenges 
239 
9. Software Sales 
A software company sells a package that retails for $199 . Quantity discounts are given 
according to the following table. 
Quantity 
Discount 
10- 19 
20% 
20-49 
30% 
50- 99 
40% 
100 or more 
50% 
Write a program that asks for the number of units purchased and computes the tota l 
cost of the purchase. 
Input Validation: Decide how the program should handle an input of less than 0. 
10. Bank Charges 
A bank charges $15 per month plus the following check fees for a commercial checking 
account: 
$0.10 each for fewer than 20 checks 
$0.08 each for 20- 39 checks 
$0.06 each for 40- 59 checks 
$0.04 each for 60 or more checks 
Write a program that asks for the number of checks written during the past month, 
then computes and displays the bank's fees for the month . 
Input Validation: Decide how the program should handle an input of less than 0. 
11. Geometry Calculator 
Write a program that displays the following menu: 
Geometry Calculator 
1 . Cal culate 
the Area of a Ci rc l e 
2 . Cal culate 
the Area of a Rectangle 
3 . Cal culate 
the Area of a Triang l e 
4 . Quit 
Ent er your choi ce (1-4): 
• If the user enters 1, the program should ask for the radius of the circle and 
then display its area. Use 3.14159 for 1t. 
• If the user enters 2, the program should ask for the length and width of the 
rectangle, and then display the rectangle's area. 
• If the user enters 3, the program should ask for the length of the triangle's base and 
its height, and then display its area. 
• If the user enters 4, the program should end. 
Input Validation: Decide how the program should handle an illegal input for the 
menu choice or a negative value for any of the other inputs. 

240 
Chapte r 4 
Making Decisions 
12. Color Mixer 
The colors red, blue, and yellow are known as the primary colors because they cannot 
be made by mixing other colors. When you mix two primary colors, you get a secondary 
color, as shown here: 
When you mix red and blue, you get purple. 
When you mix red and yellow, you get orange. 
When you mix blue and yellow, you get green. 
Write a program that prompts the user to enter the names of two primary colors to 
mix. If the user enters anything other than "red," "blue," or "yellow," the program 
should display an error message. Otherwise, the program should display the name of 
the secondary color that results. 
13. Running the Race 
Write a program that asks for the names of three runners and the time it took each of 
them to finish a race. The program should display who came in first, second, and third 
place. Think about how many test cases are needed to verify that your problem works 
correctly. (That is, how many different finish orders are possible?) 
Input Validation: Only allow the program to accept positive numbers for the times. 
14. Personal Best 
Write a program that asks for the name of a pole vaulter and the dates and vault 
heights (in meters) of the athlete's three best vaults. It should then report in height 
order (best first), the date on which each vault was made, and its height. 
15. February Days 
The month of February normally has 28 days. But if it is a leap year, February has 
29 days. Write a program that asks the user to enter a year. The program should then 
display the number of days in February that year. Use the following criteria to identify 
leap years: 
1. Determine whether the year is divisible by 100. If it is, then it is a leap year if and 
if only it is also divisible by 400. For example, 2000 is a leap year but 2100 is not. 
2. If the year is not divisible by 100, then it is a leap year if and if only it is divisible 
by 4. For example, 2008 is a leap year but 2009 is not. 
Here is a sample run of the program: 
Enter a year: 
2020[Enter] 
In 2020 February 
has 29 days. 
16. Body Mass Index 
Write a program that calculates and displays a person's body mass index (BMI). The BMI 
is often used to determine whether a person with a sedentary lifestyle is overweight or 
underweight for his or her height. A person's BMI is calculated with the following formula: 
BMI = weight x 703/height2 
where weight is measured in pounds and height is measured in inches. 

Programming Challenges 
241 
The program should display a message indicating whether the person has optimal weight, is 
underweight, or is overweight. A sedentary person's weight is considered to be optimal if his 
or her BMI is between 18.5 and 25. If the BMI is less than 18.5, the person is considered to 
be underweight. If the BMI value is greater than 25, the person is considered to be overweight. 
17. Fat Gram Calculator 
Write a program that asks for the number of calories and fat grams in a food. The 
program should display the percentage of calories that come from fat. If the calories 
from fat are less than 30 percent of the tota l calories of the food, it should also display 
a message indicating the food is low in fat. 
One gram of fat has 9 calories, so 
Calor i es from fa t = fat grams* 
9 
The percentage of calories from fat can be calculated as 
Calor i es from fa t + total 
calor i es 
Input Validation: The program should make sure that the number of calories is 
greater than 0, the number off at grams is O or more, and the number of calories 
from fat is not greater than the total number of calories. 
18. The Speed of Sound 
The speed of sound varies depending on the medium through which it travels. In general, 
sound travels fastest in rigid media, such as steel, slower in liquid media, such as water, 
and slowest of all in gases, such as air. The following table shows the approximate speed 
of sound, measured in feet per second, in air, water, and steel. 
Medium 
Air 
Water 
Steel 
Speed (feet per sec) 
1,100 
4,900 
16,400 
Write a program that displays a menu allowing the user to select air, water, or steel. 
After the user has made a selection, the number of feet a sound wave will travel in the 
selected medium should be entered . The program will then display the amount of time 
it will take . (Round the answer to four decimal places.) 
Input Validation: Decide how the program should handle an illegal input for the 
menu choice or a negative value for the distance. 
19. The Speed of Sound in Gases 
When traveling through a gas, the speed of sound depends primarily on the density of 
the medium. The less dense the medium , the faster the speed will be. The following 
table shows the approximate speed of sound at O degrees Celsius, measured in meters 
per second, when traveling through carbon dioxide, air, helium, and hydrogen. 
Medium 
Carbon dioxide 
Air 
Helium 
Hydrogen 
Speed (meters per sec) 
258 .0 
331.5 
972.0 
1270 .0 

242 
Chapte r 4 
Making Decisions 
Write a program that displays a menu allowing the user to select one of these four 
gases. After a valid selection has been made, the program should ask the user to enter 
the number of seconds (0 to 30) it took for the sound to travel in this medium from its 
source to the location at which it was detected. The program should then report how 
far away (in meters) the source of the sound was from the detection location . 
Input Validation: If the use enters an invalid menu choice the program should 
display an error message instead of prompting for the number of seconds. 
20. Spectral Analysis 
If a scientist knows the wavelength of an electromagnetic wave, she can determine what 
type of radiation it is. Write a program that asks for the wavelength in meters of an 
electromagnetic wave and then displays what that wave is according to the following 
chart . (For example, a wave with a wavelength of lE -10 meters would be an X-ray.) 
1 X 10-11 
1 X 10-8 
4 X 10-7 
] X 10-7 
1 X 10-3 
1 X t0-2 
• 
I 
I 
I 
I I I 
I 
Gamma Rays / 
X-rays 
I I I 
I 
I 
I I I 
I 
I 
I I I 
I 
I 
I I I 
I 
I 
I I I 
I 
I 
I • 
/ Ultraviolet / visible Light / 
Infrared / Microwaves 
/ Radio Waves 
21. Freezing and Boiling Points 
The following table lists the freezing and boiling points of several substances . Write a 
program that asks the user to enter a temperature , and then shows all the substances 
that will freeze at that temperature and all that will boil at that temperature. For 
example, if the user enters - 20, the program should report that water will freeze and 
oxygen will boil at that temperature . 
Substance 
Freezing Point (°F) 
Boiling Point (°F) 
Ethyl alcohol 
- 173 
172 
Mercury 
- 38 
676 
Oxygen 
- 362 
- 306 
Water 
32 
212 
22. Mobile Service Provider 
A mobile phone service has three different subscription packages for its customers: 
Package A: 
Package B: 
Package C: 
For $39.99 per month, 450 minutes are provided. Additiona l 
usage costs $0.45 per minute. 
For $59.99 per month, 900 minutes are provided. Additiona l 
usage costs $0.40 per minute. 
For $69.99 per month, unlimited minutes are provided. 
Write a program that calculates a customer's monthly bill. It should input customer 
name, which package the customer has purchased , and how many minutes were used. 
It should then create a bill that includes the input information and the total amount 
due. It should also display much money Package A customers wou ld save if they 
purchased package B or C, and how much money package B customers would save if 
they purchased package C. If there would be no savings, no message should be printed. 
Wherever possible, use named constants instead of numbers . 

TOPICS 
5.1 
Introduction to Loops: The whi le Loop 
5.2 
Using the while Loop for Input Validation 
5. 3 The Increment and Decrement Operato rs 
5.4 
Counte rs 
5.5 
Keeping a Running Total 
5.6 
Sentinels 
5.7 
The do-whi le Loop 
5.8 
The for Loop 
5.9 
Focus on Software Engineering: 
Deciding Which Loop to Use 
5.10 Nested Loops 
5.11 Breaking Out of a Loop 
5.12 Using Files for Data Storage 
5.13 Focus on Testing and Debugging: 
Creating Good Test Data 
5.14 Central Mountain Credit Union Case 
Study 
5.15 Tying It All Together: What a Colorful 
World 
5.1 
Introduction 
to Loops: The whi 1 e Loop 
CONCEPT: 
A loop is part of a progra m that repeats. 
Chapter 4 included several programs that report a student's letter grade based on his or 
her numer ic test score . But what if we want to find out the letter grade for every 
student in a class of 20 students? We wou ld have to run the program 20 times . Wou ldn't 
it be easier if we could simply indicate that the code shou ld be repeated 20 times in a 
single run? Fortunately, there is a mechanism to do this. It is called a loop . 
A loop is a control structure that causes a statement or group of statements to repeat . 
C++ has three looping contro l structures: the while loop , the do-while loop, and the 
for loop . The difference between each of these is how they contro l the repetition . 
243 

244 
Chapter 5 
a 
VideoNot e 
The while 
Loop 
Figure 5-1 
Looping 
The whi 1 e Loop 
The whi le loop has two important parts: (1) an expression that is tested for a true or 
false value and (2) a statement or block that is repeated as long as the expression is 
true. Figure 5-1 shows the general format of the while loop and a flowchart visually 
depicting how it works . 
while 
(condition) 
{ 
} 
statement ; 
statement ; 
II Place as many statements 
II here as necessary 
d.1. 
false 
con 110n >- --1~ , 
true 
statement(s) 
Let's look at each part of the while loop. The first line, sometimes called the loop 
header, consists of the key word while followed by a condition to be tested enclosed in 
parentheses . The condition is expressed by any expression that can be evaluated as true 
or false. Next comes the body of the loop. This contains one or more C++ statements . 
Here's how the loop works . The condit ion expression is tested, and if it is true, each 
statement in the body of the loop is executed. Then, the condition is tested again. If it is 
still true, each statement is executed again. This cycle repeats until the condition is false. 
Notice that, as with an if statement, each statement in the body to be conditionally 
executed ends with a semicolon, but there is no semicolon after the condition expression 
in parentheses. This is because the whi le loop is not complete without the statements 
that follow it. Also, as with an if statement, when the body of the loop contains two 
or more statements, these statements must be surrounded by braces. When the body of 
the loop contains only one statement, the braces may be omitted . Essentially, the while 
loop works like an i f statement that can execute over and over. As long as the 
expression in the parentheses is true, the conditionally executed statements will repeat. 
Program 5-1 uses a while loop to print "Hello" five times. 
Program 5-1 
1 // This program demonst rates a simple while loop . 
2 #include <iostream> 
3 usi ng namespace std; 
4 
(program continues) 

5.1 Introduction to Loops: The while Loop 
24 5 
Program 5-1 
(continued) 
5 int main() 
6 { 
7 
i nt count = 1 ; 
8 
9 
10 
11 
12 
13 
14 
15 
16 } 
whi le (count< = 5) 
{ 
cout << "Hello 
... 
' 
count = count+ 
1 ; 
} 
cout << "\n That 's all !\n"; 
return 
O; 
Program count 
Hello 
Hello 
Hello 
Hello 
Hello 
That's 
all! 
Figure 5-2 
Let's take a closer look at this program. In line 7 an integer variable count is defined 
and initialized with the value 1. In line 9 the whil e loop begins with this statement: 
whi le (count<= 
5) 
This statement tests the variable count to determine whether its value is less than or equal 
to 5. Because it is, the statements in the body of the loop (lines 11 and 12) are executed: 
cout << "Hello 
"; 
count= 
count+ 
1; 
The statement in line 11 prints the word "Hello" . The statement in line 12 adds one to 
count, giving it the value 2. This is the last statement in the body of the loop, so after 
it executes the loop starts over. It tests the expression count <= 5 again, and because it 
is still true, the statements in the body of the loop are executed again . This cycle repeats 
until the value of count equa ls 6, making the expression count <= 5 false. Then the 
loop is exited. This is illustrated in Figure 5-2. 
Test this condition. 
l 
while 
(count<= 
5) 
{ 
} 
cout << "Hello 
" ; 
count= 
count+ 
1; 
If the condition is false, exit the loop. 
If the condition is true, perform 
these statements. 
I 
._ ___ 
After executing the body of the loop, start over. 

246 
Chapter 5 
Looping 
Each execution of a loop is known as an iteration. This loop will perform five iterations 
before the expression count <= 5 is tested and found to be false, causing the loop to 
term inate. The program then resumes execution at the statement immed iate ly 
following the loop . A variable that controls the number of times a loop iterates is 
referred to as a loop control variable. In the example we have just seen, count is the 
loop control variab le. 
whi 1 e Is a Pretest Loop 
The while loop is a pretest loop . This means it tests its condit ion before each iteration. 
If the test expression is false to start with, the loop will never iterate. So if you want to 
be sure awhi le loop executes at least once, you must initialize the relevant data in such 
a way that the test expression starts out as true . For examp le, not ice the variable 
definition of count in line 7 of Program 5-1: 
i nt count= 
1; 
The count variable is initialized with the value 1. If count had been initialized with a 
value greater than 5, as shown in the following program segment, the loop would 
never execute: 
i nt count= 
6; 
whi le (count <= 5) 
{ 
cout << "Hello 
... 
' 
count = count+ 
1 ; 
} 
Infinite Loops 
In all but rare cases, a loop must include a way to terminate. This means that something 
inside the loop must eventually make the test expression false. The loop in Program 5-1 
stops when the expression count <= 5 becomes false. 
If a loop does not have a way of stopping, it is called an infinite loop. Infinite loops 
keep repeating until the program is interrupted. Here is an example: 
i nt count= 
1; 
whi le (count <= 5) 
{ 
cout << "Hello 
} 
... 
' 
This is an infinite loop because it does not contain a statement that changes the value 
of the count variable. Each time the expression count <= 5 is tested, count will still 
have the value 1. 

5.1 Introduction to Loops: The while Loop 
247 
Be Careful with Semicolons 
It's also possible to create an infinite loop by accidentally placing a semicolon after the 
first line of the whi 1 e loop. Here is an example: 
i nt count= 
1; 
whi le (count <= 5); 
{ 
// This semi colon is an ERROR! 
} 
cout << "Hello 
... 
' 
count = count+ 
1 ; 
Because the compi ler sees a semicolon at the end of the first line, before finding a 
statement or a brace that begins a block of statements, it ends the loop there. Specifically, 
it interpret s the missing statement before the semicolon as a null statement, one that 
has nothing in it, and disconnects the while statement from anything that comes after 
it. To the compiler, this entire loop looks like this: 
whi le (count <= 5); 
This while loop will continue executing the null statement, which does nothing , 
forever. The program will appear to have "gone into space" because there is nothing to 
display screen output or show any activity. 
Don't Forget the Braces 
If you write a loop that cond itionally executes a block of statements, don't forget to 
enclose all of the statements in a set of braces. If the braces are accidentally left out, the 
whi le statement conditionally executes only the very next statement . For example, 
look at the following code. 
i nt count= 
1; 
// This loop is mi ssing 
whi le (count <= 5) 
cout << "Hello 
... 
' 
count = count+ 
1 ; 
its braces! 
In this code, only one statement, the cout statement, is in the body of the while loop. 
The statement that increases the value of count is not in the loop, so the value of count 
remains 1, and the loop test condition remains true forever. The loop will print "Hello" 
over and over again, until the user stops the program . 
Don't Confuse = with == 
Another common pitfall with loops is accidentally using the = operator when you 
intend to use the == operator. The following is an infinite loop because the test 
expression assigns 1 to remai nder each time it is evaluated rather than testing if 
remainder is equal to 1: 
whi le (re mainder= 
1} 
{ 
// Error: 
Notice t he assignmen t . 
cout << "Enter a number: "; 
ci n 
>> num; 
remainder= 
num % 2; 
} 
Remember , any nonzero value is evaluated as true. 

248 
Chapte r 5 
Looping 
Programming 
Style and the whi 1 e Loop 
It's possible to create loops that look like this: 
whi le (coun t <= 5) { cout << "Hello 
•· count= 
count+ 
1· } 
' 
' 
Avoid this style of programming, however. The programming layout style you should 
use with the while loop is similar to that of the i f statement: 
• If there is only one statement repeated by the loop, it should appear on the line 
after the whi le statement and be indented one level. 
• If the loop repeats a block of statements, the block should begin on the line after 
the whi le statement, and each line inside the braces should be indented . 
You will see a similar layout style used with the other types of loops presented in this chapter. 
Now that you understand the while loop, let's see how useful it can be. Program 5-2 revises 
Program 4-9 from the previous chapter to compute letter grades for multiple students. 
Program 5-2 
1 II This program uses a loop to compute letter 
grades 
for multiple 
st udents . 
2 #include 
<iostream> 
3 us i ng namespace std; 
4 
5 i nt mai n(} 
6 { 
7 
II Crea t e named cons t ants to hold mini mum scores 
for eac h let t er grade 
8 
const int MIN_A_SCORE = 90, 
9 
MIN_B_SCORE = 80, 
10 
MIN_C_SCORE = 70, 
11 
MIN_D_SCORE = 60, 
12 
MIN_POSSIBLE_SCORE = O; 
13 
i nt numStudents, 
II The total 
number of students 
14 
15 
16 
17 
18 
st udent, 
tes t Score; 
char grade; 
II The curre nt stude nt being processed 
II Current 
stude nt 's numeric tes t score 
II Current 
stude nt 's le t ter grade 
bool goodScore = true; 
19 
20 
II Get t he number of st udent s 
21 
cout << "How many students 
do you have grades 
for? 
•; 
22 
ci n >> numStudents; 
23 
24 
II Initialize 
t he loop control 
variable 
25 
st udent= 
1; 
26 
27 
28 
29 
30 
31 
32 
II Loop once for each student 
whi le (student<= 
numSt udent s} 
{ 
II Get t his st udent's 
numer i c score 
cout << "\nE nt er t he numeric tes t score for st udent#" 
<<student<< 
II• 
It 
33 
cin 
>> tes t Score; 
(program continues) 

5.1 Introduction to Loops: The while Loop 
24 9 
Program 5-2 
(continued) 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 } 
// Determine 
the letter 
grade 
if 
(t estScore 
>= MIN_A_SCORE) 
grade = 'A'; 
else 
if 
(testScore 
>= MIN_B_SCORE} 
grade = 'B'; 
else 
if 
(testScore 
>= MIN_C_SCORE) 
grade = ·c·; 
else 
if 
(testScore 
>= MIN_D_SCORE) 
grade = 'D'; 
else 
if 
(testScore 
>= MIN_POSSIBLE_SCORE) 
grade = 'F'; 
else 
goodScore = false
; 
/ / The score was below 0 
II Di splay 
the letter 
grade 
if 
(goodScore ) 
cout << "The letter 
grade is 
" <<grade<< 
.. 
else 
. \ n"; 
cout << "The score 
cannot 
be below zero . \ n"; 
} 
// Set student 
to the next student 
student= 
student
+ 1; 
return 
O; 
Program Output with Example Input Shown in Bold 
How many students 
do you have grades 
for? 
3 [Ent er ] 
Enter the numeric test 
score 
for student 
#1: 
88[En te r] 
The letter 
grade is B. 
Enter the numeric test 
score 
for student 
#2: 
70[En te r ] 
The letter 
grade is C. 
Enter the numeric test 
score 
for student 
#3: 
93 [Ente r] 
The letter 
grade is A. 
Let's take a look at some of the key features of Program 5-2. Th e loop header for the 
while loop is on line 28 . Th e body of the loop, which contains the statements to be 
executed each time the loop iterates, is contained between the braces on lines 29 and 
57 . Th e loop control variable is student, 
and it is initialized to 1 on line 25, before the 
loop. Notice that this variable is changed on line 56, inside the loop. Thi s is very 
important. Because it is increased by one each time through the loop, it will eventually 
become greater than numStudents , and the loop will be exited. Altho ugh the primary 
purpose of a loop control variable is to control the number of loop iterations, it can 
also be used for other purposes. Not ice how Program 5-2 displays its current value as 
part of the prompt to the user on lines 31 and 32. 

250 
Chapte r 5 
Looping 
~ 
Checkpoint 
5.1 
How many lines will each of the following while loops display? 
A) int count = 1 ; 
while (count< 
5 ) 
{ 
cout << "My favorite 
day is Sunday \n"; 
count = count + 1; 
} 
B) int count = 1 O; 
while (count< 
5 ) 
{ 
cout << "My favorite 
day is Sunday \n"; 
count = count + 1; 
} 
C) int count = 1 ; 
while (count< 
5 ); 
{ 
cout << "My favorite 
day is Sunday \n"; 
count = count + 1; 
} 
D) int count = 1 ; 
while (count< 
5) 
cout << "My favorite 
day is Sunday \n"; 
count = count + 1; 
5.2 
What will display when the following lines of code are executed? 
int count= 
1 ; 
while (count< 
10} 
{ 
cout <<count<<" 
count= 
count+ 
2; 
} 
". 
Using the whi 1 e Loop for Input Validation 
CONCEPT: 
The while loop can be used to create input routines that repeat until 
acceptable data is entered. 
Chapter 4 introduced the idea of data validation and showed how to use an if 
statement to validate data that is entered by the user. However, the i f construct can 
only catch one bad value. If the user enters a second bad value after being prompted to 
reenter the original one, it will not be checked. 
The while loop solves this problem and is especially useful for validating input. If an 
invalid value is entered, a loop can require that the user reenter it as many times as 
necessary until an acceptable value is received . For example, the following loop asks 
for a number in the range of 1 through 100: 

Figure 5-3 
5.2 Using the while 
Loop for Input Validation 
25 1 
cout << "Enter a number in the range 1 - 100: "; 
cin 
>> number ; 
whi le ((number< 
1) I I (number> 
100)) 
{ 
} 
cout << "ERROR: Enter a value in the range 1 - 100: "; 
ci n 
>> number; 
This code first allows the user to enter a number. This takes place just before the loop. 
If the input is valid, the while cond ition will be false, so the loop will not execute. If the 
input is invalid, however, the while cond ition will be true, so the statements in the body 
of the loop will be executed . They will display an error message and require the user to 
enter another number. The loop will continue to execute until the user enters a valid 
number. The general logic of performing input validat ion is shown in Figure 5-3. 
l 
Read the first 
value 
No 
Is the 
value 
invalid? 
Yes 
Display an 
1----i 
Read another 
error message 
value 
The read operation that takes place just before the loop is called a priming read. It provides 
the first value for the loop to test. Subsequent values, if required, are obtained by the loop. 
Program 5-3 calculates the number of soccer teams a youth league may create, based 
on the given number of available players and a minimum and maximum number of 
players per team. The program uses while loops (in lines 26 through 32 and lines 37 
through 41) to validate the user's input. 
Program 5-3 
1 II This program calculates 
the number of soccer teams a 
2 II youth league can create 
from the number of available 
3 II players. 
It performs 
input validation 
usi ng while loops. 
4 #include 
<iostream> 
5 usi ng namespace std; 
6 
(program continues) 

252 
Chapte r 5 
Looping 
Program 5-3 
(continued) 
7 i nt mai n() 
8 { 
9 
II Constants 
for m1n1mum and maximum players 
per team 
10 
const 
int MIN_PLAYERS = 9, 
11 
MAX
_PLAYERS = 15; 
12 
13 
14 
15 
16 
17 
18 
I I Variables 
i nt players, 
teamS i ze, 
numTeams, 
leftover; 
II Number of available 
players 
II Number of desired 
players 
per team 
II Number of teams 
II Number of players 
left 
over 
19 
II Get the number of players 
per team 
20 
cout << "How many players 
do you wish per team?\n"; 
21 
cout << "(Enter 
a value in the range" 
22 
<< MIN_PLAYERS << " - " << MAX
_PLAYERS << ") : "· 
23 
cin 
>> teamS i ze; 
24 
25 
II Validate 
the input 
26 
while 
(teamSize 
< MIN_PLAYERS I I teamSize 
> MAX
_PLAYERS) 
27 
{ 
28 
cout << "\nTeam size 
should 
be" 
29 
<< MIN_PLAYERS <<"to"<< 
MAX
_PLAYERS <<" 
players.\n"; 
30 
cout << "How many players 
do you wi sh per team? "· 
31 
cin 
>> teamSize; 
32 
} 
33 
II Get and validate 
the number of players 
ava i lable 
34 
cout << "\nHow many players 
are available? 
"· 
35 
cin 
>> players; 
36 
37 
while 
(players<= 
0) 
38 
{ 
39 
cout << "Please 
enter 
a pos i tive 
number: "· 
40 
cin 
>> players; 
41 
} 
42 
II Calculate 
the number of teams and number of leftover 
players 
43 
numTeams = players 
I teamS i ze; 
44 
leftover= 
players% 
teamS i ze; 
45 
46 
II Display 
the results 
47 
cout << "\ nThere wi 11 be " << numTeams << " teams with "· 
48 
cout <<leftover<<" 
players 
left 
over.\n"; 
49 
return 
O; 
50
} 
Program Output with Example Input Shown In Bold 
How many players 
do you wish per team? 
(Enter 
a value in the range 9 - 15): 8[Enter] 
Team size 
should 
be 9 to 15 players. 
How many players 
do you wish per team? 12[Enter] 
How many players 
are available? 
138[Enter] 
There will 
be 11 teams with 6 players 
left 
over. 

0 
5.3 The Increment and Decrement Operato rs 
253 
The Increment 
and Decrement 
Operators 
CONCEPT: 
C++ pro vides a pair of operators for incrementing and decrementing 
variables. 
To increment a value means to increase it, and to decrement a value means to 
decrease it. In the example below, qt yOrdered is incremented by 10 and numSo l d is 
decremented by 3. 
qtyOrdered = qtyOrdered + 10; 
numSold = numSold - 3 ; 
Although the values stored in variables can be increased or decreased by any amount, it 
is part icularly common to increment them or decrement them by 1. We did this in 
Programs 5-1 and 5-2 when we incremented the loop control variable by 1 each time the 
while loop iterated . In fact, increasing or decreasing a variable's value by 1 is so common 
that if we say a value is being incremented or decremented witho ut specifying by how 
much, it is understood that it is being incremented or decremented by 1. C++ provides a 
pair of operato rs to do this. They are both unary operators . That means they operate on 
just one operand. The ++ operator increases its operand's value by 1. Th e -- operator 
decreases its operand's value by 1. For example, in the expression num++, the single 
operand is the variable num. The expression increases its value by 1. 
NOTE: 
The express ion num++ is pronounced "num plus plus," and num-- 1s 
pronounced "num minus minus. " 
Here are three different ways to increment the value of the variable num by 1. 
num = num + 1; 
num += 1; 
num++ ; 
// Thi s statemen t uses the increment opera t or. 
And here are three different ways to decrement it by 1: 
num = num -
1; 
num -= 1; 
num--; 
// Thi s statemen t uses the decrement opera t or. 
Notice that there is no space between the two plus signs in ++ or between them and the 
name of the variable being incremented. Likewise, there is no space between the two minus 
signs -- or between them and the name of the variable being decremented. Note also that 
the ++ and -- operators cannot operate on literals. They can only operate on an !value, 
such as a variable. Here are some examples of legal and illegal expressions using++ and --. 
count ++; 
count--
5++ 
5--
/ / legal 
/ / legal 
/ / i 11 egal 
/ / i 11 egal 

254 
Chapte r 5 
Looping 
Program 5-4 illustrates the correct use of the ++ and -- operators . It uses each of them 
to change the value of a loop control variable. 
Program 5-4 
1 II Thi s program has two loops . The first 
disp l ays the numbers 
2 II from 1 up to 5 . The second displays 
the numbers from 5 down to 1. 
3 II The program uses the+
+ and --
operators 
to change the value 
4 II of the loop control 
var i able . 
5 #include 
<iostream> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
int count= 
1; 
II Initialize 
the loop control 
variable 
to 1 
11 
whi le (count< 
6) 
12 
{ 
13 
14 
15 
} 
cout <<count<<" 
". 
count+ +; 
II The ++ operator 
i ncrements 
count 
16 
cout << endl; 
17 
18 
count
= 5; 
II Re-initia
l i ze the l oop control 
variable 
to 5 
19 
whi le (count> 
0) 
20 
21 
22 
23 
24 
25 
26
} 
{ 
cout <<count<<" 
". 
' 
count--; 
} 
cout << endl; 
return 
O; 
II The --
operator 
decrements 
count 
Program Output 
1 
2 
3 
4 
5 
5 
4 
3 
2 
1 
Postfix and Prefix Modes 
Our examples so far show the increment and decrement operators used in postfix 
mode, which means the operator is placed after the variable. The operators also work 
in prefix mode, where the operator is placed before the variable name. The statements 
on lines 14 and 22 of Program 5-4 could have been written like this: 
++countUp; 
-- countDown; 
In both prefix and postfix mode, these operators add 1 to, or subtract 1 from, their 
operand . What then is the difference between them? 

5.3 The Increment and Decrement Operators 
255 
In simple statements like those used in Program 5-4, there is no difference. The difference 
is important , however , when these operators are used in statements that do more than 
just increment or decrement a variable . For example, look at the following lines: 
num = 4; 
cout << num++; 
This cout statement is doing two things: displaying the value of num and incrementing 
num. But which happens first? cout will display a different value if num is incremented first 
than if it is incremented last. The answer depends on the mode of the increment operator. 
Postfix mode causes the increment to happen after the value of the variable is used in 
the expression . In the example, cout will display 4, then num will be incremented to 5. 
Prefix mode , however, causes the increment to be done first. In the following statements, 
num will first be incremented to 5, and then cout will display 5: 
num = 4; 
cout << ++num; 
Program 5-5 illustrates these dynamics further by placing increment and decrement 
operators in cout statements . This make s it easy to see the difference between using 
them in prefix and postfix mode. However, this should not normally be done. That is, 
in actual programming app lications it is not recommended 
to place increment or 
decrement operators in cout statements. 
Program 5-5 
1 II This program demonstrates 
the postfix 
and pref i x 
2 II modes of the increment 
and decrement operators. 
3 #include 
<iostream> 
4 usi ng namespace std; 
5 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
i nt 
{ 
mai n() 
int num = 4; 
II 
Illustrate 
cout << num 
cout << num++ 
cout << num 
cout << ++num 
II 
Illustrate 
cout << num 
cout << num--
cout << num 
cout << --num 
22 
return 
O; 
23
} 
Program Output 
4 
4 
5 
6 
6 
6 
5 
4 
postfix 
and 
<< .. ... 
<< .. ... 
<< .. ... 
' 
<< II \n"; 
postfix 
and 
<< .. ... 
' 
<< .. ... 
' 
<< .. ... 
' 
<< II \n"; 
prefix+
+ operator 
II Di splays 
4 
II Di splays 
4, then adds 1 to num 
II Di splays 
5 
II Adds 1 to num, then displays 
6 
prefix 
--
operator 
II Di splays 
6 
II Di splays 
6, then subtracts 
1 from num 
II Di splays 
5 
II Subtracts 
1 from num, then displays 
4 

256 
Chapter 5 
Looping 
Let's analyze the statements in this program. In line 8, num is initialized with the value 
4, so the cout statement in line 11 displays 4. Then, line 12 sends the expression num++ 
to cout. Because the ++ operator is used in postfix mode , the value 4 is first sent to 
cout , and then 1 is added to num, making its value 5. 
When line 13 executes, num will hold the value 5, so 5 is displayed. Th en, line 14 sends 
the expression ++num to cout. Because the ++ operator is used in prefix mode, 1 is first 
added to num (making it 6), and then the value 6 is sent to cout. This same sequence of 
events happens in lines 17 through 20, except the -- operator is used. 
For anot her example, look at the following code: 
i nt 
X = 1 . 
' 
int y 
y = x++· ' 
II Postfix 
increment 
II Assign x' s ol d value toy 
and then increment x 
The first statement defines the variable x (initialized with the value 1) and the second 
statement defines the variable y. Th e third statement does two things: 
• It assigns the value of x, which is 1, to the variable y. 
• Then the variable x is incremented. 
After the statement executes, y will conta in 1, and x will conta in 2. Now let's look at 
the same code but with the ++ operato r used in prefix mode: 
i nt X = 1 ; 
i nt y; 
y = ++x; 
II Prefix 
increment 
This time the third statement uses the ++ operato r in prefix mode , so variable x is 
incremented before the assignment takes place. After the code has executed, x and y 
will both contain 2. 
Using++ and -- in Mathematical Expressions 
The increment and decrement operators can also be used on variables in mathematical 
expressions . Consider the following program segment: 
a= 
2; 
b = 5 ; 
C =a* 
b++; 
cout <<a<<
" '' << b <<
" "<< 
c; 
In the statement c = a * b++, c is assigned the value of a times b, which is 10. Then 
variable b is incremented, so the cout statement will display 
2 6 10 
If we changed the statement to read 
C =a* 
++b; 
variable b would be incremented before it was multiplied by a, so the cout statement 
would display 
2 6 12 

<) 
5.3 The Increment and Decrement Operato rs 
257 
You can pack a lot of action into a single statement using the increment and decrement 
operators, but don't get too tricky with them . You might be tempted to try something 
like the following, thinking that c will be assigned 11: 
a= 
2; 
b = 5 ; 
C = ++ (a * b) ; 
// Error! 
But this assignment statement simply will not work because, as previously mentioned, 
the operand of the increment and decrement operators must be an !value. 
Using ++ and -- in Relational Expressions 
The ++ and -- operators may also be used in relational expressions . Just as in arithmetic 
express ions, the difference between postfix and prefix mode is critical. Consider the 
following program segment: 
X = 10 ; 
if 
(x ++ > 10) 
cout <<"xis 
greater 
than 10 .\n"; 
Two operations are taking place in this if statement: the value in x is tested to 
determine if it is greater than 10, and x is incremented. Because the increment 
operator is used in postfix mode , the comparison happens first. Since 10 is not greater 
than 10, the value of x before it is incremented, the cout statement won't execute. If 
the increment operator is used in prefix mode, however , x will be incremented before 
the if condition is tested, so the if statement will compare 11 to 10 and the cout 
statement will execute: 
X = 10 ; 
if 
(+ +x > 10) 
cout <<"xis 
greater 
than 10 .\n"; 
NOTE: 
Some instructors prefer that you only use the ++ and -- operators in 
statements whose sole purpose is to increment or decrement a variable. They may 
ask you not to use them in assignment statements, mathematical express ions, or 
relational expressions . 
Checkpoint 
5.3 
What will each of the following program segments display? 
A) x = 2 ; 
y = x++; 
cout 
<< x <<" 
"<< 
y; 
B) x = 2 ; 
y = ++x; 
cout 
<< x <<" 
"<< 
y; 

258 
Chapte r 5 
Looping 
C) X = 2 · ' 
y = 4· ' 
cout << x++ << " " << -- y; 
D) X = 2 · ' 
y = 2 * x++· ' 
cout << X << " " << y; 
E) X = 99 ; 
if (x++ < 100) 
cout "It is true! \n"; 
else 
cout << "It is false! \n"; 
F) X = o· ' 
if (++x) 
cout << "It is tr ue !\ n"; 
else 
cout << "It is false! \n"; 
Counters 
CONCEPT: 
A count er is a variable that is regularl y incremented or decremented 
each time a loop iterate s. 
Sometimes it's important for a program to keep track of the number of iterations a 
loop performs. For example, Program 5-6 displays a table consisting of the numbers 1 
through 5 and their squares, so its loop must iterate five times. 
Program 5-6 
1 // This program uses a while loop to display 
2 // the numbers 1-5 and their 
sq uar es . 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std ; 
6 
7 int main() 
8 { 
int num = 1 ; 
9 
10 
cout << "Number Square\n"; 
11 
cout << "--------------\n"; 
12 
whi le (num <= 5) 
13 
{ 
14 
cout << setw (4) << num << setw(7) 
<< (num * num) << end l; 
15 
num++; 
// Increment 
counter 
16 
}return 
O; 
17 } 
(program continues) 

Program 5-6 
Program Output 
Number 
1 
2 
3 
4 
5 
Square 
1 
4 
9 
16 
25 
5.4 Counters 
259 
(continued) 
In Program 5-6 the loop control variable num starts at 1 and is incremented each time 
through the loop . When num reaches 6, the condition num <= 5 becomes false, and the loop 
is exited . Variable num also acts as a counter, keeping count of how many times the 
loop has iterated so far. Notice how num is incremented in line 15 of the program. Because 
counters most often count by 1 's, the increment operator is frequently used with them. 
0 
NOTE: 
It 's important 
that num be properly initialized. Remember, variables 
defined inside a function have no guaranteed starting value. 
Letting the User Control the Loop 
Sometimes we want to let the user dec ide how many times a loop should iterate. 
Program 5-2 did this. Program 5-7, which is a revision of Program 5-6, also doe s this. 
It prompts the user to enter the maximum integer value to be displayed and squared. 
Th en it has num, the loop counter, count up to that value. 
Program 5-7 
1 II Thi s program displays 
integer 
numbers and the i r squares , begi nning 
2 II with one and ending wi th whatever 
number the user requests. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
10 
11 
int num, 
lastNum; 
II Counter telling 
what number to square 
II The final 
integer 
value to be squared 
12 
II Get and validate 
the last 
number i n the tab le 
13 
cout << "This program will 
display 
a tab le of integer\n" 
14 
<< "numbers and their 
squares, 
starting 
with 1.\ n" 
15 
<< "What should the las t number be?\n" 
16 
17 
<< "Enter an integer 
between 2 and 10: "; 
cin 
>> lastNum; 
(program continues) 

260 
Chapte r 5 
Looping 
Program 5-7 
18 
(continued) 
19 
whi le ((lastNum 
< 2) I I (l astNum > 10)) 
20 
{ cout 
<< "Pl ease enter 
an integer 
between 2 and 10: "; 
21 
cin 
>> lastNum ; 
22 
} 
23 
II Di splay the table 
24 
cout << "\nNumber 
Square\n"; 
25 
cout << "--------------\n"; 
26 
27 
num = 1; 
II Set the counter 
to the start
i ng value 
28 
whi le (num <= lastNum) 
29 
{ 
30 
cout 
<< setw(4 ) << num << setw(7) 
<< (num * num) << endl ; 
31 
32 
} 
num++ ; 
II 
Increment 
the counter 
33 
return 
O; 
34 } 
Program Output with Example Input Shown in Bold 
This program will 
display 
a table 
of integer 
numbers and their 
squares, 
starting 
with 1. 
What should the last 
number be? 
Enter an integer 
between 2 and 10: 3[Enter] 
Number Square 
1 
2 
3 
5.5 
1 
4 
9 
Keeping a Running Total 
CO N C E PT: A running total is a sum of numbers that accumulates with each iteration of 
a loop. The variable used to keep the running total is called an accumulator. 
Many programming tasks require you to add up a series of numbers . For example, if 
you want to find the average of a set of numbers, you must first add them up. Programs 
that add a series of numbers typically use two elements: 
• A loop that reads each number in the series. 
• A variable that accumulates the total of the numbers as they are read. 
The variable that is used to accumulate the total of the numbers is called an accumulator. 
It is often said that the loop keeps a running total because it accumulates the total as it 
reads each number in the series. Figure 5-4 shows the general logic of a loop that 
calculates a running total. 

5.5 Keeping a Running Total 
261 
Figure 5-4 
Set 
accumulator 
to 0 
another 
No 
Yes 
Read the next 
Add the 
1----,~
1 number to the 
number 
accumulator 
When the loop finishes, the accumulator will contain the tota l of the numbers read by 
the loop. Notice that the first step in the flowchart is to set the accumulator variable to 
0. This is a critical step. Each time the loop reads a number, it adds it to the accumulator. 
If the accumulator starts with any value other than 0, it will not contain the correct 
total when the loop finishes. 
Let's look at a program that keeps a running total. Program 5-8 calcu lates a 
company's total sales for a week by reading daily sales figures and adding them to an 
accumulator. 
Program 5-8 
1 II This program takes 
daily 
sales 
figures 
for 
2 II a 5-day sales 
week and calcula
t es t heir total
. 
3 #include 
<iostream> 
4 #include 
<iomani p> 
5 us i ng namespace std; 
6 
7 i nt mai n() 
8 { 
cons t in t NUM
_DAYS = 5; 
i nt day; 
II The day bei ng processed 
9 
10 
11 
12 
13 
double dailySales, 
tota1Sales 
= 0 .0; 
II The sales 
amount for a si ngle day 
II Accumulator, 
i nit iali zed with 0 
(program continues) 

262 
Chapte r 5 
Looping 
Program 5-8 
(continued) 
14 
// Get the sales 
for each day and accumulate 
a total 
15 
// The loop control 
var i able, 
day, is a counter 
16 
day = 1 ; 
17 
whi le (day<= 
NUM
_DAYS) 
18 
{ 
19 
20 
21 
22 
23 
24 
25 
26 
27 
} 
cout << "Enter the sales 
for day"<< 
day<<": 
"; 
cin 
>> dailySales; 
totalSales 
= totalSales 
+ dailySales; 
// Accumulate the total 
day++; 
// Increment the counter 
// Di splay the total 
sales 
cout <<fixed<< 
showpoint << setprecision(2); 
cout << "\nTotal 
sales: 
$" << totalSales 
<< endl; 
28 
return 
O; 
29
} 
Program Output with Example Input Shown in Bold 
Enter 
Enter 
Enter 
Enter 
Enter 
Total 
the sales 
for day 1 : 505 .50[Enter] 
the sales 
for day 2: 615 .20[Enter] 
the sales 
for day 3: 488 .25 [Enter] 
the sales 
for day 4: 553 . lO[Enter] 
the sales 
for day 5: 614 .05 [Enter] 
sales: 
$2776.10 
Let's take a closer look at a few of the key lines in this program. Line 9 creates a named 
constant called NUM
_DAYS, which is set to 5. This will be used to control how many 
times the loop beginning on line 17 iterates . On line 12, the total Sal es variable is 
defined. This is the accumulator. Notice that it is initia lized with 0. The variable day, 
which is defined on line 10, is assigned the value 1 on line 16, just before the loop. This 
variable is the counter that controls the loop and keeps track of which day's sales 
amount is currently being read in and processed. The loop test condition specifies that 
it will repeat as long as day is less than or equal to NUM
_DAYS. Line 22 increments day 
by one at the end of each loop iteration . 
During each loop iteration, in line 20, the user enters the amount of sales for one 
specific day. This amount is stored in the dailySales 
variable . Then, in line 21, this 
amount is added to the existing value stored in the total Sal es variab le. Note that line 
21 does not assign dailySales 
to total Sales, but rather increases the value stored in 
total Sales by the amount in dailySales. 
After the loop has finished all its iterations, 
total Sal es will contain the total of all the daily sales figures entered, which it displays 
on line 26. 

5.6 
5.6 Sentinels 
263 
Sentinels 
CONCEPT: 
A sentinel is a special value that marks the end of a list of values. 
Program 5-8, in the previous section, uses a named constant to indicate the number of 
days there are sales figures for. But what if this number could vary? In that case, we 
could ask the user to input the number of days. This works when the user knows the 
number of items to be input and processed. However, sometimes the user has a list that 
is very long and doesn't know how many items there are. 
A technique that can be used in a situation like this is to ask the user to enter a sentinel 
at the end of the list. A sentinel is a special value that cannot be mistaken for a member 
of the list and that signals that there are no more values to be entered . When the user 
enters the sentinel, the loop terminates. 
Program 5-9 provides an example of using an end sentinel. This program calculates the 
total points earned by a soccer team over a series of games. It allows the user to enter 
the series of game points, and then enter - 1 to signal the end of the list. 
Program 5-9 
1 II Thi s program illustrates 
the use of an end sent i nel. 
It calculates 
2 II the total 
number of points 
a soccer 
team has earned over a ser i es 
3 II of games. The user enters 
the poi nt values, 
then - 1 when f i nished . 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
10 
11 
12 
int game= 1, 
poi nts, 
total 
= O; 
II Game counter 
II Holds number of points 
for a spec i f i c game 
II Accumulates 
total 
points 
for all games 
13 
II Read in the points 
for game 1 
14 
cout << "Enter the number of points 
your team has earned\n"; 
15 
cout << "so far this 
season . Then enter 
- 1 when finished.\n\n"; 
16 
cout << "Enter the points 
for game"<< 
game<<"· 
"; 
17 
cin 
>> points; 
18 
19 
II Loop as long as the end sentinel 
has not yet been entered 
20 
while 
(poi nts != - 1) 
21 
{ 
II Add point just 
read in to the accumulator 
22 
total 
+= points; 
23 
24 
II Enter the points 
for the next game 
25 
game++; 
26 
cout << "Ent er the points 
for game" 
<<game<<"· 
"; 
27 
28 
} 
ci n >> points; 
(program continues) 

264 
Chapter 5 
Looping 
Program 5-9 
(continued) 
29 
II Display the total 
points 
30 
cout << "\n The total 
points 
are•<< 
total 
<< endl; 
31 
return 
O; 
32
} 
Program Output with Example Input Shown in Bold 
Enter the number of points 
your team has earned 
so far this 
season. 
Then enter - 1 when finished. 
Enter the points 
for game 1 : 2[Enter] 
Enter the points 
for game 2: 1 [Enter] 
Enter the points 
for game 3: 
3[Enter] 
Enter the points 
for game 4: 2[Enter] 
Enter the points 
for game 5: 
1 [Enter] 
Enter the points 
for game 6: 
- 1 [Enter ] 
The total 
points 
are 9 
Program Output with Different Example Input Shown in Bold 
Enter the number of points 
your team has earned 
so far this 
season. 
Then enter -1 when finished. 
Enter the points 
for game 1: - 1 
The total 
points 
are O 
The value - 1 was chosen for the sentinel in this program because it is not possible for a 
team to score negative points. Notice that this program performs a priming read in line 
17 to get the first value. Th is is done so that the while loop will not try to test the value 
of points until a first value has been read in. It also makes it possible for the loop to 
immediately terminate if the user enters - 1 for the first value, as shown in the second 
samp le run . Also note that the sentinel value is not included in the runnin g total. 
~ 
Checkpoint 
5.4 
In the following program segment, which variable is the counter and which is 
the accum ulato r? 
i nt number, maxNums, x = 0, t = O; 
cout << "How many numbers do you wi sh to enter?
"; 
cin 
>> maxNums; 
whi le (x < maxNums) 
{ 
} 
cout << "Enter the next number: "; 
cin 
>> number; 
t += number; 
x++ ; 
cout << "The sum of those numbers i s •<< t << endl; 

Figure 5-5 
0 
5.7 The do-whil e Loop 
265 
5.5 
Find four errors in the following code that is attempting to add up five numbers. 
i nt val, count , sum; 
cout << "I wil l add up 5 numbers. \n" 
whi le (count< 
5 ) 
{ 
} 
cout << "Enter a number: "; 
ci n 
>> val; 
sum= val; 
cout << "The sum of these numbers is
" << sum<< endl; 
5.6 
Write a sentinel-controlled while loop that accumulates a set of test scores input 
by the user until negative 99 is entered. The code should count the scores as well 
as add them up. It should then report how many scores were entered and give the 
average of these scores. Do not count the end sentinel negative 99 as a score. 
The do-whi 1 e Loop 
CONCEPT: 
Th e do-while loop is a post-test loop, which means its expression is 
tested after each iteration. 
In addition to the while loop, C++ also offers the do-whi l e loop. Th e do-while loop 
looks similar to a whil e loop turned upside down. Figure 5-5 shows its format and a 
flowchart visually depicting how it works. 
do 
{ 
statement ; 
statement ; 
II Place as many statements 
II here as necessary. 
} while (condition); 
statement(s) 
true 
d'. 
con 1110n 
false 
As with the whi l e loop, if there is only one condit ionally executed statement in the 
loop body, the braces may be omitted. 
NOTE: The do-while loop must be terminated with a semicolon after the closing 
parenthesis of the test expression . 

266 
Chapte r 5 
Looping 
Besides the way it looks, the difference between the do-while loop and the while loop 
is that do-while 
is a post-test loop. This means it tests its expression at the end of the 
loop, after each iteration is comp lete. Therefore a do-while always performs at least 
one iteration , even if the test expression 
is false at the start . For example, in the 
following whi le loop the cout statement will not execute at all . 
i nt X = 1 ; 
while 
(x < 0) 
cout << x << endl; 
But the cout statement in the following do-while loop will execute once because the 
do-while loop does not evaluate the expression x < O until the end of the iteration . 
i nt X = 1 ; 
do 
cout << x << endl; 
whi le(x<O); 
You shou ld use the do -while loop when you want to make sure the loop executes at 
least once. For examp le, Program 5-10 computes and displays the average of a set of 
test scores before ask ing if the user wants to repeat the process with another set of 
scores . As with the whi le loop, ado -while loop can be written to iterate a set number 
of times or to allow the user to contro l how many times to loop . Program 5-10 
illustrates another method for letting the user control the loop . It will repeat as long as 
the user enters a 'Y' or 'y' for yes. 
Program 5-10 
1 II This program averages 
3 test 
scores. 
It uses a do-while 
loop 
2 II th at allows 
the code t o repeat 
as many t i mes as the user wishes. 
3 #include 
<iostream> 
4 us i ng namespace std; 
5 
6 i nt mai n() 
7 { 
8 
9 
10 
11 
i nt score 1 , score2, 
score3; 
double 
average; 
char agai n ; 
12 
do 
13 
{ 
I I Get t hree t est scores 
II Three t est 
scores 
II Average test 
score 
II Loop aga i n? Y or N 
14 
cout << "\ nEnter 
3 scores 
and I will 
average 
t hem: "; 
15 
ci n 
>> score1 
>> score2 
>> score3; 
16 
17 
II Calculate 
and di splay 
the average 
18 
average= 
(score 1 + score2 
+ score3) 
I 3.0; 
19 
cout << "The average 
is"<< 
average<< 
"\ n\ n"; 
20 
21 
II 
Does t he user want to average 
ano t her se t ? 
22 
cout << "Do you want t o average 
another 
set? 
(YIN) "; 
23 
ci n 
>> agai n ; 
24 
} while 
(agai n == 'Y' 
11 aga i n == 'y'); 
25 
return 
O; 
26 
} 
(program continues) 

Program 5-10 
(continued) 
Program Output with Example Input Shown In Bold 
Enter 3 scores 
and I wi 11 average 
them: 80 90 70[Enter] 
The average 
is 80 
Do you want to average 
another 
set? 
(Y/N) y[Enter] 
Enter 3 scores 
and I wi 11 average 
them: 60 75 88[Enter] 
The average 
is 74.3333 
Do you want to average 
another 
set? 
(Y/N) n[Enter] 
The toupper Function 
5.7 The do-wh il e Loop 
267 
Let's take a closer look at the line containing the do-whi le loop test expression in 
Program 5-10. 
whi le (again== 
'Y' I I again== 
'y'); 
Notice how the logical OR operator is used to allow the user to enter either an 
uppercase or a lowercase 'Y' to do anothe r iteration of the loop . 
While this method works well to test both of these characters, it can be done more 
easily by using a C++ function named toupper (pronounced "to upper"). This function 
is passed a character and returns the integer ASCII code of a character. If the character 
it receives is a lowercase letter, it returns the ASCII code of its uppercase equivalent. If 
the character it receives is not a lowercase letter, it returns the ASCII code for the same 
character it was passed. 
If the value returned by toupper were printed, it is the ASCII code that would print. 
However, if it is assigned to a char variable, which is then printed, the character itself 
will print . The following examples illustrate this. 
char l etter
1 , l etter2
, letter3; 
l etter1 
= toupper ( '? ' ) ; 
cout << l etter1
; 
// This disp l ays ? 
letter2 
= toupper ( 'A ' ) ; 
cout << letter2; 
// This disp l ays A 
letter3 
= toupper('b'); 
cout << letter3; 
II This disp l ays B 
cout << toupper ( 'c' ) ; 
II This disp l ays 67, the ASCII code for C 
In the first example, the character passed to the toupper function is not a letter at all, 
so the ASCII code of the same character is returned and assigned to l etter
1 for 
printing. In the second example, the character passed to toupper is already an uppercase 
letter so, again, the ASCII code of the same character it received is returned . In the 
third example, toupper receives a lowercase letter, so the ASCII code of its uppercase 
equivalent is returned. In the final example, toupper again receives a lowercase letter 
and returns the ASCII code of its uppercase equivalent . However, this time the returned 
value is printed instead of being assigned to a char variable, so it is the integer value of 
the ASCII code itself that displays. 

268 
Chapte r 5 
0 
Looping 
The value passed to toupper does not have to be a characte r literal. It can also be a 
character variable, as shown here: 
char letter
1 = 'b'; 
char letter2 
= toupper(letter1); 
II Now lett er2 ' s value i s ' B' 
The toupper function is especially useful when used in the test express ion of a do-while 
loop. It can test the variable holding a user's input to see if the user has entered a 'Y' or 
a 'y' when asked whether or not the loop should iterate again. The following two 
do-while tests are logically equivalent : 
whi l e (again== 
' Y ' I I again== 
'y'); 
whi l e (toupper(again) 
== ' Y '); 
It is important to understand that this last test expression does not change the value 
stored in the again variab le. Rath er, it compares the value returned by to upper to a 
character literal. To actua lly change the value stored in again , the value returned by 
the function would have to be assigned to it, as shown here: 
again= 
toupper(again); 
C++ provides a similar function to conve rt an uppercase letter to its lowercase 
equivalent . This function is named tolower (prono unced "to lower" ). Here are two 
examples of its use: 
whi l e (tolower(again) 
== 'y'); 
again= 
tolower(aga
i n); 
NOTE: 
To use to upper and tolower you must include the cctype file in your 
program . You can include it with the following statement : 
#i nclude <cctype> 
Using do-while 
with Menus 
The do-while 
loop is a good choice for repeating a menu. Recall Program 4-27, which 
displays a menu of health club packages . Program 5-11 is a modification of that 
program that uses a do-while loop to repeat the program until the user selects item 4 
from the menu . 
Program 5-11 
1 II This menu-dr i ven Heal th Club membership program carries 
out the 
2 II appropriate 
actions 
based on the menu choice entered
. A do-whi le l oop 
3 II allows the program to repeat 
unti l the user selects 
menu choice 
4. 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 usi ng namespace std; 
7 
(program continues) 

Program 5-11 
8 int mai n() 
9 { 
(continued) 
10 
II Constants 
fo r membership rates 
11 
const double ADULT_RATE = 120.0; 
12 
const double CHILD_RATE = 60.0; 
13 
const double SENIOR_RATE = 100.0; 
14 
15 
i nt choice; 
II Menu choice 
16 
17 
i nt months ; 
double charges ; 
II Number of months 
II Monthly charges 
18 
19 
do 
20 
{ 
I I Display the menu and get the us er's 
cho i ce 
21 
cout << "\n 
Health Club Membership Menu\ n\ n"; 
22 
cout << "1 . Standard 
Adult Membership\n"; 
23 
cout << "2 . Chi l d Membership\n"; 
24 
25 
26 
27 
28 
cout 
cout 
cout 
cin 
<< 
<< 
<< 
>> 
"3 . Senior Ci t i zen Membersh i p\n"; 
"4 . Qui t the Program \ n\ n"; 
"Ent er your choice: 
". 
choice ; 
29 
II Validate 
the men u selection 
30 
wh i l e ( ( c ho i ce < 1 ) I I ( cho i c e > 4) ) 
31 
{ 
} 
cout << "Please 
enter 
1, 2, 3, or 4: "· 
cin 
>> choice; 
II Process 
the user's 
choice 
if (c hoi ce != 4) 
{ 
cout << "For how many months? " · 
ci n 
>> months ; 
II Compute charges 
based on us er input 
switch 
(choic e ) 
{ 
case 1 : charges = months * ADULT_RATE; 
break; 
case 2 : charges = months * CHILD_RATE; 
break; 
case 3: charges = months * SENIOR_RATE; 
} 
II 
Display the monthly charges 
cout <<fixed<< 
showpoint 
<< setprecision
(2); 
5.7 The do-wh il e Loop 
269 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
cout << "The total 
charges 
are$"<< 
charges<< 
endl ; 
} 
53 
} whi l e (c hoi ce != 4); 
I I Loop again i f the us er di d not 
54 
II select 
choice 4 to quit 
55 
return 
O; 
56 } 
(program continues) 

270 
Chap ter 5 
Looping 
Program 5-11 
(continued) 
Program Output with Example Input Shown in Bold 
Health Club Membership Menu 
1. Standard 
Adult Membership 
2. Child Membership 
3. Senior 
Citizen 
Membership 
4. Quit the Program 
Enter your choice: 
1 [Enter] 
For how many months? 4[Enter] 
The total 
charges 
are $480.00 
Health Club Membership Menu 
1. Standard 
Adult Membership 
2. Child Membership 
3. Senior 
Citizen 
Membership 
4. Quit the Program 
Enter your choice: 
4[Enter ] 
~ 
Checkpoint 
5. 7 
Wh at will th e follow ing progra m segments display? 
A) int count = 
do 
cout << 
count--
; 
while 
(co unt 
B) int val = 5 ; 
do 
3 ; 
"Hel lo 
< 1 ) ; 
cout <<va l << 
while 
(va l >= 5 ); 
Worl d\ n" ; 
II 
II
, 
C) int count
= 0 , number= 
0 , limit
= 4 ; 
do 
{ 
number += 2 ; 
count ++ ; 
} while 
(co unt< 
l i mi t ); 
cout <<number<<" 
" <<count<< 
endl ; 
5.8 
Write a program segment with a do-while loop that displays whether a user-entered 
integer is even or odd. The code should then ask the user if he or she wants to test 
another num ber. The loop should repeat as long as the user enters 'Y' or 'y' . Use a 
logical OR operator in the do-while loop test expression. 
5.9 
Revise your answer to Qu estion 5 .8 to use the touppe r function in the do-while 
loop test exp ression. 

5.8 
a 
Vide-oNot~ 
The for 
Loop 
5.8 The for Loop 
271 
The for Loop 
CONCEPT: 
The for loop is a pretest loop that combines the initialization, testing, 
and updating of a loop control variable in a single loop header. 
In general, there are two categories of loops: conditional loops and count -controlled 
loops. A conditional loop executes as long as a particular condition exists. For example, 
an input validation loop executes as long as the input value is invalid. When you write 
a conditiona l loop, you have no way of knowing the number of times it will iterate. 
Sometimes you know the exact number of iterations that a loop must perform. A loop 
that repeats a specific number of times is known as a count-controlled loop. For example, 
if a loop asks the user to enter the sales amounts for each month in the year, it will iterate 
twelve times. In essence, the loop counts to twelve and asks the user to enter a sales 
amount each time it makes a count. A count-controlled loop must possess three elements: 
1. It must initialize a counter variable to a starting value. 
2. It must test the counter variable by comparing it to a final value. When the 
counter variable reaches its final value, the loop terminates. 
3. It must update the counter variable during each iteration. This is usually done by 
incrementing the variable. 
You have already seen how to create a count-controlled loop by using a while loop. 
However, count-controlled loops are so common that C++ provides another type of loop 
that works especially well for them. It is known as the for loop. The for loop is specifically 
designed to initialize, test, and update a counter variable. Here is the format of the for loop. 
for (initial
ization
; 
test ; 
update) 
{ 
} 
statement
; 
statement
; 
II 
Place as many statements 
II 
here as necessary. 
As with the other loops you have used, if there is only one statement in the loop body, 
the braces may be omitted. 
The first line of the for loop is the loop header. After the key word for , there are three 
expressions inside the parenthe ses, separated by semicolons . (Notice that there is no 
semicolon after the third expression .) The first expression is the initialization expression. 
It is typically used to initialize a counter to its starting value. This is the first action 
performed by the loop, and it is only done once. 
The second expression is the test expression. It tests a condition in the same way the test 
expression in the while and do-while loops do, and contro ls the execution of the loop. 
As long as this condition is true, the body of the for loop will repeat. Like the while loop, 
the for loop is a pretest loop, so it evaluates the test expression before each iteration. 

272 
Chapter 5 
Figure 5-6 
Figure 5-7 
Looping 
The third express ion is the update expression. It executes at the end of each iteration, 
before the test expression is tested again . Typically, this is a statement that increments 
the loop's counter variab le. 
Here is an examp le of a simple for loop that prints "Hello" five times: 
for (cou nt = 1; count <= 5; count++) 
cout <<"Hello"<< 
endl; 
In this loop, the initialization expression is count = 1, the test expression is count <= 5, 
and the update expression is count ++. The body of the loop has one statement, which 
is the cout statement . Figure 5-6 illustrates the sequence of events that take place 
during the loop's execution . Notice that steps 2 through 4 are repeated as long as the 
test expression is true. 
for 
Step 1: Perform the initialization expression. 
j 
Step 2: Evaluate the test expression. 
! 
If it is true, go to step 3. 
Otherwise, terminate the loop. 
(count= 
1; count<= 
5; count++) 
{ 
} 
cout <1 "Hello"<< 
endl; l 
Step 3: Execute the body 
of the loop. 
Step 4: Perform the update expression. 
Then go back to step 2. 
Figure 5-7 shows the loop's logic in the form of a flowchart . 
l 
Assign 1 to 
count 
False 
True 
cout 
statement 
Increment 
count 

5.8 The for Loop 
273 
Notice how the counter variable count is used to control the number of times the loop 
iterates . It begins with the value 1 and is incremented after each loop iteration. As long 
as the expression count <= 5 remains true, the loop will iterate again. However , after 
the fifth iteration, count will become 6. This causes the test expression to become false, 
so the loop will terminate. Also notice that in this example the count variable is used 
only in the loop header, to control the number of loop iterations . It is not used for any 
other purpose. However, it is also possible to use the counter variable within the body 
of a loop. For example, look at the following code: 
fo r (number = 1; number< = 5 ; number++) 
cout <<number<<'' 
'' ; 
The counter variable in this loop is number. In addition to contro lling the number of 
iterations, it is also used in the body of the loop. This loop will produce the following 
output: 
1 2 3 4 5 
As you can see, the loop displays the contents of the number variable during each 
iteration. 
Program 5-12 is a new version of Program 5-6 that displays the numbers 1- 5 and their 
squares by using a for loop instead of a whi le loop. 
Program 5-12 
1 // Thi s program uses a for loop to display 
the numbers 1-5 
2 II and their 
squares. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std ; 
6 
7 int main() 
8 { 
int num; 
9 
10 
cout << "Number Square\n"; 
11 
cout << ·--------------\n"; 
12 
13 
for (num = 1; num <= 5 ; num++) 
14 
cout << setw(4) 
<< num << setw(7) 
<< (num * num) << endl ; 
15 
return 
O; 
16 } 
Program Output 
Number Square 
1 
1 
2 
4 
3 
9 
4 
16 
5 
25 

274 
Chapter 5 
Looping 
The for Loop Is a Pretest Loop 
Because the for loop tests its test expression before it performs an iteration, it is 
possible to write a for loop in such a way that it will never iterate . Here is an example: 
for (cou nt = 11; count<= 
10; count ++) 
cout <<"Hello"<< 
endl; 
Because the variab le count is initialized to a value that makes the test expression false 
from the beginning, the body of the loop is never executed . This loop terminates as 
soon as it begins. 
Avoid Modifying the Counter Variable in the Body 
of the for Loop 
Although it is okay to use the count er variable inside the body of the loop, as we did in 
Program 5-12, be careful not to place a statement there that modifies it. Modifications 
of the counter var iable sho uld only take place in the upd ate expression, which is 
automatically executed at the end of each iteration . If a statement in the body of the 
loop also modifies the counter variable, the loop will probab ly not terminate when you 
expect it to . The following loop, for example, increments x twice for each iteration: 
for (x = 1; x <= 10; x++) 
{ 
cout << x << endl ; 
x++; 
II Wrong! 
) 
Other Forms of the Update Expression 
You are not limited to incrementing the loop control variable by just 1 in the updat e 
expression . Here is a loop that displays all the even numbers from 2 through 100 by 
adding 2 to its count er: 
for (num = 2 ; num <= 100; num += 2) 
cout << num << endl ; 
And here is a loop that count s backward from 10 down to 0: 
for (num = 10; num >= O; num--) 
cout << num << endl ; 
Defining a Variable in the for Loop's Initialization 
Expression 
Not only may the counter variable be initialized in the initializat ion expression, it may 
be defined there as well. Th e following code shows an examp le. Thi s is a modified 
version of the loop in Program 5-12. 
for (i nt num = 1 ; num <= 5 ; num++) 
cout << setw(4 ) << num << setw(7) 
<< (num * num) << endl; 
In this loop, the num variable is both defined and initialized in the initialization expression. 

5.8 The for Loop 
275 
If the counter variable is used only in the loop, it is considered good programming 
practice to define it in the loop header. This makes the variable's purpose clearer. 
However, when a variab le is defined in the initialization expression of a for loop, the 
scope of the variable is limited to the loop. This means you cannot access the variable 
in statements outside the loop. For example, the following program segment will not 
comp ile because the last cout statement cannot access the variab le count. 
for (int count
= 1 ; count< = 10; count+ +) 
cout <<count<< 
endl ; 
cout << "count i s now"<< 
count<< 
endl; 
// 
ERROR! 
Creating a User-Controlled for Loop 
In Program 5-7 we allowed the user to contro l how many times a while loop should 
iterate . This can also be done with a for loop by having the user enter the final value 
for the count er variab le, as illustrated in the following program segment . 
II Get the final 
counter value 
cout << "How many t imes should the loop execute?"
; 
cin 
>> fina lValu e ; 
for (int num = 1 ; num <= finalValue; 
num++) 
{ 
II Statements 
in the loop body go here. 
} 
Using Multiple Statements 
in the Initialization 
and Update Expressions 
It is possible to execute more than one statement in the initialization expression and the 
update express ion . When using multiple statements in either of these expressions, 
simply separate the statements with commas . For examp le, look at the loop in the 
following code, which has two statements in the initialization expression . 
for (int x = 1, y = 1; x <= 5 ; x++) 
{ 
cout << x <<"plus"<< 
y <<"equals"<< 
(x + y) << endl; 
} 
The loop's initialization expression is 
int 
X = 1 , y = 1 
This defines and initializes two int variables, x and y. The out put produced by this 
loop is: 
1 plus 1 equa ls 2 
2 plus 1 equa ls 3 
3 plus 1 equa ls 4 
4 plus 1 equa ls 5 
5 plus 1 equa ls 6 

276 
Chapter 5 
Looping 
We can further modify the loop to execute two statements in the upd ate expression. 
Here is an examp le: 
fo r (i nt x = 1, y = 1; x <= 5 ; x++, y++) 
{ 
cout << x <<•plus•<< 
y <<•equals•<< 
(x + y) << endl; 
) 
Th e loop's update expression increments both the x and y var iables. The output 
produced by this loop is: 
1 plus 1 equals 2 
2 plus 2 equals 4 
3 plus 3 equals 
6 
4 plus 4 equa ls 8 
5 plus 5 equa ls 10 
Connecting multiple statements with commas is allowed in the initialization and update 
expressions but not in the test expression. If you wish to combine multiple express ions 
in the test express ion, you must use the && or 11 operators. 
Here is an examp le of a for loop header that does this: 
fo r (i nt count
= 1 ; count< = 10 && moreData ; count ++) 
This loop will execute only as long as count <= 1 O and Boolean variab le moreData is 
true. As soon as either of these condit ions becomes false, the loop will be exited. 
Omitting the for Loop's Expressions or Loop Body 
Although it is generally considered bad programming style to do so, one or more of the 
for loop's expressions, or even its loop body, can be omitted. 
The initialization expression may be omitted from inside the for loop's parentheses if 
it has already been performed or if no initialization is needed . Here is an example of a 
loop with the initialization being performed prior to the loop: 
int num = 1; 
fo r ( ; num <= maxValue; num++) 
cout << num << • 
• << (num * num) << endl; 
The update express ion may be omitted if it is being performed elsewhere in the loop 
or if none is needed . Altho ugh this type of code is not recommended, the following 
for loop works just like a while loop: 
i nt num = 1; 
fo r ( ; num <= maxValue; 
{ cout << num << • 
• << (num * num) << endl; 
num++ ; 
) 
It is also possible, though not recommended, to write a for loop that has no formal 
body. In this case, all the work of the loop is done by statements in the loop header. Here 
is an examp le that displays the numbers from 1 to 10. The combined increment operation 
and cout statement in the update expression perform the work of each iteration. 
fo r (number = 1; number< = 10; cout << number++); 

5.9 Focus on Software Engineering: Deciding Which Loop to Use 
277 
~ 
Checkpoint 
5.10 
What three expressions appear inside the parentheses of the for loop's header? 
5.11 
You want to write a for loop that displays "I love to program" 50 times . 
Assume that you will use a counter variable named count. 
A) What initialization expression will you use? 
B) What test expression will you use? 
C) What update expression will you use? 
D) Write the loop. 
5.12 
What will each of the following program segments display? 
A) for (i nt count = O; count< 
6 ; count ++) 
cout <<(cou nt+ 
count )<<" 
"; 
B) for (i nt valu e = - 5 ; value< 
5 ; value+ +) 
cout <<value<<" 
"; 
C) i nt x 
for ( x = 3; x <= 10; x += 3) 
cout << x <<" 
... 
' 
5.13 
Write a for loop that displays your name 10 times. 
5.14 
Write a for loop that displays all of the odd numbers, 1 through 49 . 
5.15 
Write a for loop that displays every fifth number, 0 through 100. 
5.16 
Write a for loop that sums up the squares of the integers from 1 through 10. 
5.17 
Write a for loop that sums up the squares of the odd integers from 1 through 9. 
5.18 
Write a for loop that repeats seven times, asking the user to enter a number 
each time and summing the numbers entered . 
5.19 
Write a for loop that calculates the total of the following series of numbers: 
1 
2 
3 
4 
30 
30 + 29 + 28 + 27 + ... 1 
5.20 
Write a for loop that calculates the total of the following series of numbers: 
Focus on Software Engineering: 
Deciding Which Loop to Use 
CONCEPT : Although most repetitive algorithm s can be writt en with any of the 
three types of loops, each work s best in different situation s. 

278 
Chapte r 5 
Looping 
Each of C++'s three loops is ideal to use in specific situations . Here's a short summary 
of when each loop should be used. 
The whi 1 e Loop 
The whil e loop is a pretest loop . It is ideal in situations where you do not want the 
loop to iterate if the test condit ion is false from the beginning . For examp le, validating 
input that has been read and reading lists of data terminated by a sentine l value are 
good app lications of the while loop . 
cout << "This program finds 
the square of any integer.\n"; 
cout << "\nEnter 
an integer
, or - 99 to quit: 
"; 
cin 
>> num; 
whi le (num != - 99) 
{ 
cout << num << " squared 
is " << pow(num, 2. 0) << endl ; 
cout << "\nE nter an i nteger, 
or - 99 to quit 
"; 
ci n 
>> num; 
} 
The do-whi 1 e Loop 
The do-while loop is a post-test loop . It is ideal in situations where you always want 
the loop to iterate at least once . Th e do-while loop is a good choice for repeating a 
menu or for asking users if they want to repeat a set of actions. 
cout << "This program finds 
the square of any integer.\n"; 
do 
{ 
cout << "\nE nter an i nteger: 
"; 
ci n 
>> num; 
cout << num <<" squared 
is"<< 
pow(num, 2.0} << endl ; 
cout << "Do you want to square another 
number? (Y/ N} "; 
ci n 
>> doAgain; 
} while 
(doAgain == 'Y' II doAgai n == 'y'}; 
The for Loop 
Th e for loop is a pretest loop with built-in express ions for initializing , testing , and 
updating a counter variable . The for loop is ideal in situations where the exact number 
of iterations is known. 
cout 
<< "This program finds the squares 
of the integers" 
<< "f rom 1 to 8.\n\n"; 
fo r (num = 1; num <= 8 ; num++) 
{ 
cout << num <<" squared 
is"<< 
pow(num, 2.0} << endl ; 
} 
A program containing the above code for all three types of loops can be found in the 
loop-examp l es. cpp file in the Chapte r 5 programs folder on the book's companion 
website, along with all the other programs in this chapter. 

5.10 Nested Loops 
279 
Nested Loops 
CONCEPT: 
A loop that is inside anoth er loop is called a nested loop. 
a 
VideoNot e 
Nested Loops 
In Chapter 4 you saw how one if statement could be nested inside another one. It is also 
possible to nest one loop inside another loop. The first loop is called the outer loop . The 
one nested inside it is called the inner loop. This is illustrated by the following two whi 1 e 
loops . Notice how the inner loop must be completely contained within the outer one. 
whi l e (condition1) 
// Beginning of the outer 
loop 
{ 
} 
while (condition2
) 
// Beginning of the inner loop 
{ 
} 
// End of the i nner loop 
// End of the outer loop 
Ne sted loops are used when, for each iteration of the oute r loop , something must be 
repeated a number of times . Here are some examp les from everyday life: 
• For each batch of cookies to be baked, we must put each cookie on the cookie sheet. 
• For each salesperson, we must add up each sale to determine total comm ission . 
• For each teacher , we must produce a class list for each of their classes . 
• For each student, we must add up each test score to find the student's test average. 
Whatever the task, the inner loop will go through all its iterations each time the outer 
loop is executed. This is illustrated by Program 5-13, which handles this last task , 
finding student test score averages . Any kind of loop can be nested within any other 
kind of loop. This program uses two for loops. 
Program 5-13 
1 // This program averages 
test 
scores. 
It asks the user for the 
2 // number of students 
and the number of test 
scores 
per student
. 
3 #include 
<iostream> 
4 usi ng namespace std; 
5 
6 i nt mai n(} 
7 { 
8 
9 
10 
11 
i nt numStudents, 
numTests; 
doubl e average ; 
// Number of students 
// Number of tests 
per student 
// Average test 
score for a student 
12 
// Get the number of students 
13 
cout << "This program averages 
test 
scores.\n"; 
14 
cout << "How many students 
are there? 
•; 
15 
cin 
>> numStudents; 
16 
17 
18 
19 
20 
// Get the number of test 
scores 
per student 
cout << "How many test 
scores does each student 
have?"; 
cin 
>> numTests; 
cout << endl ; 
(program continues) 

280 
Chapte r 5 
Looping 
Program 5-13 
(continued) 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 } 
II Read each student's 
scores 
and compute the i r average 
for 
(in t snum = 1; snum <= numStudents; 
snum++} 
II Outer loop 
{ double total 
= 0 .0; 
II Initialize 
accumulator 
for 
(i nt test= 
1; test<= 
numTests; 
test+ +) 
{ int 
score; 
II Inner loop 
} 
} 
II Read a score 
and add it to the accumulator 
cout << "Enter 
score•<< 
test<<• 
for"; 
cout <<"student·<< 
snum << 
cin 
>> score; 
total+= 
score; 
It• 
II• 
' 
II Compute and display 
the student's 
average 
average= 
total 
I numTests; 
cout << "The average 
score for student•<< 
snum; 
cout <<"is''<< 
average<< 
"\n\ n"; 
return 
O; 
II End inner 
loop 
II End outer 
loop 
Program Output with Example Input Shown In Bold 
This program averages 
test 
scores. 
How many students 
are there? 
2[Ent er] 
How many test 
scores 
does each student 
have? 3[Enter] 
Enter score 
1 for student 
1 : 84[Ent er] 
Enter score 
2 for student 
1 : 79[Ent er] 
Enter score 
3 for student 
1 : 97[Ent er] 
The average 
for student 
1 is 86.6667 
Enter score 
1 for student 
2: 92[Ent er] 
Enter score 
2 for student 
2: 88[Ent er ] 
Enter score 
3 for student 
2: 94[Ent er] 
The average 
for student 
2 is 91.3333 
Let's trace what happened in Program 5-13, using the sample data shown . In this case, 
for each of two students, we input and summed each of their three scores. First, in line 
23 the outer loop was entered and snum was set to 1. Th en, once the tota l accumulator 
was initialized to zero for that student, the inner loop, which begins on line 26, was 
entered. While the outer loop was still on its first iteration and snum was still 1, the inner 
loop went through all of its iterations, handling tests 1, 2, and 3 for that student. It then 
exited the inner loop and in lines 36 through 38 calculated and output the average for 
student 1. Only then did the program reach the bottom of the outer loop and go back 
up to do its second iteration. The second iteration of the outer loop processed student 2. 
For each iteration of the outer loop, the inner loop did all its iterations. 
It might help to think of each loop as a rotating wheel. Th e outer loop is a big wheel 
that is mov ing slowly. The inner loop is a smaller whee l that is spinning quick ly. 

5.11 
5.11 Breaking Out of a Loop 
281 
For every rotation the big wheel makes, the little wheel makes many rotations. Since, in 
our example, the outer loop was done twice, and the inner loop was done three times for 
each iteration of the outer loop, the inner loop was done a total of six times in all. This 
corresponds to the six scores input by the user, as summarized by the following points. 
• An inner loop goes through all of its iterations for each iteration of an outer loop. 
• Inner loops complete their iterations faster than outer loops. 
• To get the total number of iterations of an inner loop, multiply the number of 
iterations of the outer loop by the number of iterations done by the inner loop 
each time the outer loop is done. 
Breaking Out of a Loop 
CONCEPT: 
C++ provides ways to break out of a loop or out of a loop iteration early. 
Sometimes it's necessary to stop a loop before it goes through all its iterations. The 
break statement, which was used with swi tch in Chapter 4, can also be placed inside a 
loop. When it is encountered, the loop immediately stops, and the program jumps to 
the statement following the loop. 
Here is an example of a loop with a break statement . Th e whi 1 e loop in the following 
program segment appears to execute 10 times, but the break statement causes it to stop 
after the fifth iteration . 
i nt count= 
1; 
whi l e (count<= 
10) 
{ 
} 
cout <<count<< 
endl ; 
count+ +; 
if (count== 
6 ) 
break ; 
This example is presented just to illustrate what a break statement inside a loop will 
do. However , you would not normally want to use one in this way because it violates 
the rules of str uctured programming and make s code more difficult to understand, 
debug, and maintain . The exit from a loop should be contro lled by its cond ition test at 
the top of the loop, as in a whi 1 e loop or for loop, or at the bottom, as in a do-whi 1 e 
loop. Norma lly the only time a break statement is used inside a loop is to exit the loop 
early if an error cond ition occurs. Program 5-14 provide s an example . 
Program 5-14 
1 II This program is supposed to f i nd the square root of 5 numbers 
2 II entered 
by the user . However, if a negat i ve number is entered 
3 II an error message displays 
and a break statement 
is used to 
4 II stop the lo op early. 
(program continues) 

282 
Chapte r 5 
Looping 
Program 5-14 
(continued) 
5 #include 
<iostream> 
6 #include 
<cmath> 
7 using namespace std ; 
8 
9 int main () 
10 { 
11 
double number; 
12 
13 
cout << "Enter 5 positive 
numbers separated 
by spaces and \n" 
14 
<< "I will 
f i nd their 
square roots: 
"; 
15 
16 
for (int 
count
= 1 ; count<
= 5 ; count ++) 
17 
{ 
18 
ci n >> number ; 
19 
if (number> = 0.0 ) 
20 
{ cout << "\ nThe square 
root of"<< 
number<<" 
i s " 
21 
<< sqrt (number); 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 } 
) 
else 
{ 
cout << 
<< 
<< 
break; 
) 
} 
return o· ' 
"\ n\ n" <<number<<" 
i s negative. 
" 
"I cannot find the square root \ n" 
"of a negative 
number . The program is terminating
. \ n"; 
Program Output with Example Input Shown in Bold 
Enter 5 positive 
numbers separated 
by spaces and 
I will 
find their 
square roots: 
12 15 - 17 19 31[Enter] 
The square 
root of 12 is 3.4641 
The square 
root of 15 is 3.87298 
-17 is negative. 
I cannot find the square root 
of a negative 
number. The program is terminating. 
Using break in a Nested Loop 
In a nested loo p, the break statement only interrupt s th e loo p it is placed in. Th e 
following progr am segment displays five rows of asterisks on the screen. The outer 
loo p contr ols th e numb er of row s, and the inner loo p contr ols the number of asterisks 
in each row. Th e inn er loo p is designed to display tw enty asterisks, but the break 
statem ent stop s it during the eleventh iterati on. 

CD 
CD 
for (row= 
O; row< 3; row++) 
{ 
for (s tar= 
O; star< 
20 ; star++) 
{ 
cout << '*'; 
) 
) 
if (s tar == 10) 
break; 
cout << endl ; 
The output of this program segment is 
*********** 
*********** 
*********** 
5.11 Breaking Out of a Loop 
283 
WARNING! 
Because the break statement bypasses the loop condition to terminate 
a loop, it violates the rules of structured programming and makes code more difficult 
to understand, debug, and maintain. Therefore, we do not recommend using it to 
exit a loop. Because it is part of the C++ language, however, we have introduced it. 
The continue Statement 
Sometimes you want to stay in a loop but cause the current loop iteration to end 
immediately. This can be done with the continue 
statement. When continue 
is 
encountered, all the statements in the body of the loop that appear after it are ignored, 
and the loop prepares for the next iteration. In a whi 1 e loop, this means the program 
jumps to the test expression at the top of the loop. If the expression is still true, the next 
iteration begins. Otherwise, the loop is exited. In a do-while loop, the program jumps 
to the test expression at the bottom of the loop, which determines if the next iteration 
will begin. In a for loop, continue causes the update expression to be executed, and 
then the test expression to be evaluated. The following program segment demonstrates 
the use of cont i nue in a whi 1 e loop: 
i nt testVal 
= O; 
whi le (testVal 
< 10 ) 
{ 
) 
testVal+ +; 
if (testVal) 
--
4 
continue; 
cout << testVal 
<< 
// Terminate this 
iteration 
of the loop 
II 
II• 
This loop looks like it displays the integers 1- 10. However, here is the output: 
1 2 3 5 6 7 8 9 10 
Notice that the number 4 does not print. This is because when testVal is equal to 4, the 
continue statement causes the loop to skip the cout statement and begin the next iteration. 
WARNING! 
As with the break statement, the continue statement violates the 
rules of struct ured programming and makes code more difficult to understand, 
debug, and maintain . For this reason, you should use cont i nue with great caution . 

284 
Chapte r 5 
Looping 
Th e continue statement has some practical uses, however, and Program 5-15 illustrates 
one of these uses. Th e program calculates the charges for DVD rentals where cur rent 
releases cost $3.50 and all others cost $2.50. If a customer rents several DVD s, every 
third one is free. Th e continue 
statement is used to skip the part of the loop that 
calc ulates the charges for every third DVD. 
Program 5-15 
1 // This program calculates 
DVD renta l charges 
where every th i rd DVD 
2 // is free . It i l lustrates 
the use of the continue 
statement. 
3 #include 
<iostream> 
4 #include 
<iomani p> 
5 us i ng namespace std; 
6 
7 i nt mai n() 
8 { 
9 
10 
11 
12 
i nt numDVDs; 
doubl e total 
= 0 .0; 
char current
; 
// Number of DVDs bei ng rented 
// Accumulates 
total 
charges 
for all 
DVDs 
// Current 
release? 
(Y / N) 
13 
// Get number of DVDs rented 
14 
cout << "How many DVDs are being rented ? " ; 
15 
cin 
>> numDVDs; 
16 
17 
// Determi ne the charges 
18 
fo r (in t dvdCount = 1; dvdCount <= numDVDs; dvdCount++) 
19 
{ 
if (dvdCount % 3 == 0) 
// If it's 
a 3rd DVD it's 
free 
20 
{ 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
} 
} 
cout <<"DVD#"<< 
dvdCount <<" 
is free!\n"; 
continue
; 
cout << "Is DVD#" << dvdCount << " a current 
release 
(Y/N)? "; 
cin 
>> current; 
i f (( current
== 'Y') 
I I (c urrent
== 'y'}) 
total 
+= 3 .50 ; 
else 
total 
+= 2 .50; 
31 
// Display 
the total 
charges 
32 
cout <<fixed<< 
showpoint << setprec
i sion(2}; 
33 
cout << "The total 
is$"<< 
total 
<< endl; 
34 
return 
O; 
35} 
Program Output with Example Input Shown In Bold 
How many DVDs are being rented? 
6[Enter] 
Is DVD #1 a current 
release 
(Y/N)? y[Enter] 
Is DVD #2 a current 
release 
(Y/N)? n[Ent er] 
DVD #3 is free! 
Is DVD #4 a current 
release 
(Y/N)? n[Ent er] 
Is DVD #5 a current 
release 
(Y/N)? y[Enter] 
DVD #6 is free! 
The total 
is $12.00 

5.12 Using Files for Data Storage 
285 
~ 
Checkpoint 
5.21 
Which loop (while, do-while, or for ) is best to use in the following situat ions? 
A) The user must enter a set of exactly 14 numbers . 
B) A menu must be displayed for the user to make a selection. 
C) A calculat ion must be made an unknown number of times (maybe even 
no times). 
D) A series of numbers must be entered by the user, terminated by a sentinel value. 
E) A series of values must be entered. The user specifies exactly how many. 
5.22 
How many total stars will be displayed by each of the following program segments? 
A) for (r ow = O; row< 
20; row++) 
{ for (star
= O; st ar< 
30 ; star+ +) 
{ 
cou t << '*'; 
} 
cout << endl ; 
} 
B) for (r ow = O; row< 
20; row++) 
{ for (star
= O; st ar< 
30 ; star+ +) 
{ 
i f (s t ar> 
10) 
break; 
cout << '*'; 
} 
cout << endl; 
} 
5.23 
What will the following program segment display? 
i nt addOn = 0, subTot al = O; 
whi le (addOn < 5) 
{ 
} 
addOn++; 
if (addOn == 3) 
cont inue; 
subTotal += addOn; 
cout << subTotal 
<<" 
". 
Using Files for Data Storage 
CONCEPT : When a pro gram needs to save dat a for later use, it writ es the data in a 
file. Th e data can be read from the file at a later time. 
The programs you have written so far require the user to reenter data each time the program 
runs because data kept in variables is stored in RAM and disappears once the program stops 
running. If a program is to retain data between the times it runs, it must have a way of saving 
it. Data written into a file, which is usually stored on a computer's disk, will remain there 
after the program stops running . That data can then be retrieved and used at a later time. 
Most of the commercial software programs that you use on a day-to-day basis store 
data in files. The following are a few examples. 

286 
Chapter 5 
Looping 
• Word processors: Word processing programs are used to write letters, memos, 
reports, and other documents . The documents are then saved in files so they can 
be viewed, edited, and printed at a later time. 
• Spreads heets: Spreadsheet programs are used to work with numerical data . 
Numbers and mathematical formulas can be inserted into the rows and columns 
of the spreadsheet . The spreadsheet can then be saved in a file for later use. 
• Image editors: Image editing programs are used to draw graphics and edit images, 
such as the ones that you take with a digital camera . The images that you create 
or edit with an image editor are saved in files. 
• Business operations softwa re: Programs used in daily business operations rely 
extensive ly on files. Payroll programs keep employee data in files, inventory 
programs keep data about a company's products in files, accounting systems 
keep data about a company's financial operations in files, and so on. 
• Web browsers: Sometimes when you visit a Web page, the browser stores a small 
file known as a cookie on your computer. Cookies typically contain information 
about the browsing session, such as the contents of a shopping cart . 
• Games: Many computer games keep data stored in files. For example, some games 
keep a list of player names with their scores stored in a file. These games typically 
display the players' names in the order of their scores, from highest to lowest. Some 
games also allow you to save your current game status in a file so you can quit the 
game and then resume playing it later without having to start from the beginning. 
Programmers usually refer to the process of saving data in a file as writing data to the 
file. When a piece of data is written to a file, it is copied from a variable in RAM to the 
file. This is illustrated in Figure 5-8. The term output file is used to describe a file that 
data is written to. It is called an output file because the program stores output in it. 
Figure 5-8 
Writing data to a file 
Variable 
payRate 
Variable 
e11ployeel0 
Oata is copied from 
variables to the file. 
18.65 f---------------~ 
74512 1------------~ 
Variable 
I . 
1 I 
e11ployeeName 
Cindy Chand er f-----~l 
~yChandler 
/ 7451Z /1s.q; 
t 
A file on the disk c=:> 
The process of retrieving data from a file is known as reading data from the file. When 
a piece of data is read from a file, it is copied from the file into a variable in RAM. See 
Figure 5-9 for an illustration . The term input file is used to describe a file that data is 
read from. It is called an input file because the program gets input from the file. 

5.12 Using Files for Data Storage 
287 
Figure 5-9 
Reading data from a file 
Oata is copied from 
lhe file to variables. 
Var iable 
payRate 
118.65 1-
----------~ 
Variable 
e11ployeel0 
174512 1----------~ 
Var iable 
I . 
1 I 
e11ployeeName 
CindyChander 
----~ 
~yChandler 
/ 7451Z /1a.q; 
t 
A file on the disk c=:> 
Types of Files 
In general, there are two types of files: text and binary. A text file conta ins data that 
has been encoded as text , using a scheme such ASCII or Unicode . Even if the file 
conta ins numbers, those numbers are stored in the file as a series of characters. As a 
result, the file may be opened and viewed in a text editor such as Notepad. A binary file 
conta ins data that has not been converted to text. As a consequence, you cannot view 
the contents of a binary file with a text editor. Here we will work only with text files. 
In Chapter 13 you will learn to work with binary files. 
File Access Methods 
There are two general ways to access data stored in a file: sequentia l access and direct 
access. When you work with a sequent ial access file, you access data from the beginning 
of the file to the end of the file. If you want to first read a piece of data that is stored at 
the very end of the file, you have to first read all of the data that comes before it. You 
cannot jump directly to the desired data. This is similar to the way cassette tape players 
work. If you want to listen to the last song on a cassette tape, you have to either fast-
forward over all of the songs that come before it or listen to them. There is no way to 
jump directly to a specific song. 
When you work with a random access file (which is also known as a direct access file), 
you can directly access any piece of data in the file without reading the data that comes 
before it. This is similar to the way a CD player or an MP3 player works. You can 
jump directly to any song that you want to listen to. 
Here the focus is on sequential access text files. These files are easy to work with, and 
you can use them to gain an understand ing of basic file operat ions. In Chapte r 13 you 
will learn to work with random access and binary files. 

288 
Chapter 5 
Looping 
Filenames and File Stream Objects 
Files on a disk are identified by a filename . For example, when you create a document 
with a word processor and then save the document in a file, you have to specify a 
filename. When you use a utility such as Windows Explorer to examine the contents of 
your disk, you see a list of filenames. Figure 5-10 shows how three files named cat . 
j pg, not es. t xt , and resume . doc might be represented in Windows Explorer. 
Figure 5-10 
Thr ee file s 
cat.jpg 
~ 
Ii:] 
notes.txt 
resume.doc 
Each operating system has its own rules for naming files. Many systems, including 
Windows, support the use of filename extensions, which are short sequences of characters 
that appear at the end of a filename preceded by a period. The files depicted in Figure 
5-10 have the extensions .j pg , .t xt , and .doc. The period is called a "dot ." So, for 
example, the filename resume . doc would be read "resume dot doc." The extension 
usually indicates the type of data stored in the file. For example, the . j pg extension 
usually indicates that the file contains a graphic image compressed according to the 
JPEG image standard . The . txt extension usually indicates that the file contains text. 
The . doc extension usually indicates that the file contains a Microsoft Word document. 
In order for a program to work with a file on the computer 's disk, the program must 
create a file stream object in memory. A file stream object is an object that is associated 
with a specific file and provides a way for the program to work with that file. It is 
called a "stream" object because a file can be thought of as a stream of data. 
File stream objects work very much like the ci n and cout objects. A stream of data 
may be sent to cout, which causes values to be displayed on the screen. A stream of 
data may be read from the keyboard by ci n and stored in variables. Likewise, streams 
of data may be sent to a file stream object, which writes the data to the file it is 
associated with. When data is read from a file, the data flows from the file stream 
object associated with the file into variables. 
Setting Up a Program for File Input / Output 
Five steps must be taken when a file is used by a program: 
1. Include the header file needed to perform file input/output . 
2. Define a file stream object. 
3. Open the file. 
4. Use the file. 
5. Close the file. 
Let's examine each of these, beginning with step 1. 

Table 5 -1 
File Stream 
Data Type 
ofstream 
ifstream 
fs t ream 
0 
5.12 Using Files for Data Storage 
289 
Just as you need to include the i ost ream file in your program to use ci n and cout, you 
need another header file to use files. The fst ream file contains all the declarations 
necessary for file operations . You can include it with the following statement: 
#include 
<fstream> 
The fstream header file defines the data types of stream, i fstream , and fstream. Before 
a C++ program can work with a file, it must define an object of one of these data types. 
The object will be "linked" with an actual file on the computer's disk, and the operations 
that may be performed on the file depend on which of these three data types you pick 
for the file stream object. Table 5-1 lists and describes the file stream data types. 
Description 
This stands for output file stream and is pronounced 'o' 'f' stream. An object of 
this data type can be used to create a file and write data to it. 
This stands for input file stream and is pronounced 'i' 'f' stream. An object of this 
data type can be used to open an existing file and read data from it. 
This stands for file stream and is pronounced 'f' stream . An object of this data 
type can be used to open files for reading, writing, or both. 
NOTE: 
In this chapter we only discuss the ofstream and ifs t ream data types. 
The fstream type is covered in Chapter 13. 
Creating a File Stream Object and Opening a File 
Before data can be written to or read from a file, two things must happen: 
• A file stream object must be created. 
• The file must be opened and linked to the file stream object. 
The following code shows an example of opening a file for input (reading). 
if stream inpu t Fi le; 
i nputFil e .open("Customers.
t xt "); 
The first statement defines an i fs t ream object named i nputFi le. The second statement 
calls the object 's open member function, passing the string "Customers. txt • as an 
argument. In this statement, the open member function opens the Cust omers. txt file 
and links it with the i nputFi le object. After this code executes, you will be able to use 
i nput Fi le to read data from the Customers . txt file. 
The following code shows an example of opening a file for output (writing). 
ofstream outputFile
; 
outpu t File.open("Employees
.txt"); 
The first statement defines an of st ream object named out put File . The second statement 
then calls the object's open member function, passing it the string ·Employees. txt" 
as an argument. This opens a file named Employees. txt and links it with output File. 

290 
Chapter 5 
0 
Looping 
If the specified file did not previously exist, it will be created . If the specified file already 
exists, it will be erased and a new file with the same name will be created. After this code 
executes, you will be able to use out put File to write data to the Employees . tx t file. 
Sometimes, when opening a file, you will need to specify its full path as well as its 
name. For example, on a Windows system the following statement opens the file C: \ 
dat a\ inventory . txt and links it with i nputFi le: 
i nputFi le .open("C:\\da
t a\\inv entory .txt"); 
NOTE: Notice the use of two backslashes in the file's path. As mentioned before, 
two backslashes are needed to represent one backslash in a string literal. 
It is possible to define a file stream object and open a file all in one statement . Here is 
an example that defines an i fs t ream object named i nputFi le, opens the Customers . 
t xt file, and associates i nputFi le with it: 
i fstrea m inpu t Fi le("Customers.txt"); 
And here is an examp le that defines an of stream object named outp ut File , opens the 
Employees. txt file, and associates out putFi le with it: 
ofstrea
m out putFile("E mployees.txt"); 
Closing a File 
The opposite of opening a file is closing it. Although a program's files are automat ically 
closed when the program shuts down, it is a good programming practice to write 
statements that explicitly close them . Here are two reasons a program should close files 
when it is finished using them: 
• Most operating systems temporarily store data in a file buffer before it is written to a 
file. A file buffer is a small "holding section" of memory that file-bound data is first 
written to. The data is not actually written to the file until the buffer is full. This is 
done to improve the system's performance because doing file 1/0 is much slower than 
processing data in memory. Closing a file causes any unsaved data still in a buffer to 
be written out to its file. This ensures that all the data the program intended to write 
to the file is actually in it if you need to read it back in later in the same program. 
• Some operating systems limit the number of files that may be open at one time. 
When a program closes files that are no longer being used, it will not deplete 
more of the operating system's resources than necessary. 
Calling the file stream object's close member function closes the file associated with it. 
Here is an examp le: 
i nputFi le .close(); 
Writing Data to a File 
You already know how to use the stream insertion operator(<<) with the cout object to 
write data to the screen. It can also be used with ofst ream objects to write data to a file. 

5.12 Using Files for Data Storage 
29 1 
Assuming output Fi 1 e is an of stream object, the following statement demonstrates 
using the << operator to write a string literal to a file: 
outputFile 
<< "I love C++ programming\n"; 
This statement writes the string literal "I love C++ programming\n" to the file associated 
with outputFi le. As you can see, the statement looks like a cout statement, except the 
name of the of stream object name replaces cout. Here is a statement that writes both 
a string literal and the contents of a variable to a file: 
outputFile 
<< "Pr i ce: • <<price 
<< endl; 
This statement writes the stream of data to output File exactly as cout would write it 
to the screen: It writes the string "Pr i ce: ", followed by the value of the price variable, 
followed by a newline character. 
Program 5-16 demonstrates opening a file, writing data to the file, and closing the file. 
After this code has executed, we can open the demofi le. txt file using a text editor, 
look at its contents, and, if we wish, print it. 
Program 5-16 
1 // Thi s program wri tes data to a file. 
2 #include 
<iostream> 
3 #include 
<fstream> 
// Needed to use files 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
ofstream 
outputFile
; 
9 
10 
// Open the output 
file 
11 
outputFile.open("demofile.txt"
); 
12 
13 
cout << "Now writ i ng data to the file
. \n"; 
14 
15 
// Write four names to the file 
16 
outputFile 
<< "Bach\n"; 
17 
outputFile 
<< "Beethoven\n"; 
18 
outputFile 
<< "Mozart\n"; 
19 
outputFile 
<< "Schubert\n"; 
20 
21 
// Close the file 
22 
outputFile.close
(); 
23 
24 
cout << "Done. \n"; 
25 
return 
O; 
26
} 
Program Screen Output 
Now writing 
data to the file. 
Done. 

292 
Chapter 5 
Looping 
Figure 5-11 shows how the file's content s appear in Notepad . 
Figure 5-11 
] 
demofile.txt - Notepad 
= @I 
File 
Edit Format 
Vie!W Help 
Bac h 
Beethoven 
Mozart 
Schuber t 
... 
Notice that in lines 16 through 19 of Program 5-16, each string that was written to the 
file ends with a newline escape sequence (\n) . The newline specifies the end of a line of 
text . Because a newline is written at the end of each string , the strings appear on 
separate lines when viewed in a text editor, as shown in Figure 5-11. 
If we wrote the same four names without the \n escape sequence or an endl after each 
one, they would all appear on the same line of the file with no spaces between them, as 
shown in Figure 5-12. 
Figure 5-12 
JI demofile.txt - Notepad 
O 
@I 
File Edit 
Format 
View 
Help 
Bachs eethov enMozar tschu bert 
• 
.. 
Program 5-17 also writes data to a file, but it gets its data from keyboard input when 
the program runs . This program asks the user to enter the first names of three friends, 
and then it writes those names to a file named Fri ends. t xt . 
Program 5-17 
1 
2 
3 
4 
5 
6 
// This program wri t es user i nput t o a fi le . 
#i nclude <i ost ream> 
#i nclude <fstream> 
// Needed to use f i les 
#i nclude <stri ng> 
using namespace st d; 
(program continues) 

Program 5-17 
7 int main() 
8 { 
(continued) 
9 
ofstream 
outputFile; 
10 
string 
name; 
11 
12 
II Open the output 
file 
13 
outputFile.open("Fr
i ends .txt"); 
14 
15 
II Use a loop to get the names of three 
friends 
16 
II and write 
each name i n the output 
f i le 
17 
cout << "Enter the names of three 
fr i ends . \n"; 
18 
19 
for (int 
count
= 1 ; count<
= 3; count ++) 
20 
{ 
21 
22 
23 
24 
} 
25 
cout <<"Friend#"<< 
count<< 
ci n 
>> name; 
outputF i le <<name<< 
endl ; 
26 
II Close the file 
27 
outputFile.close(); 
28 
II• 
II• 
' 
29 
cout << "The names were saved to a f i le . \n"; 
30 
return 
O; 
31 } 
5.12 Using Files for Data Storage 
293 
Program Screen Output with Example Input Shown In Bold 
Enter the names of three 
fr i ends. 
Fri end #1 : Joe[Enter] 
Fri end #2: Chrls[Enter] 
Fri end #3: Gerl[Enter] 
The names were saved to a f i le. 
Figure 5-13 shows an example of what the Fr i ends. txt file will look like after this 
program runs. 
Figure 5-13 
JI Friends.bet - Notepad 
File Edit Format View Help 
Joe 
Chri s 
Geri 
... 

294 
Chapte r 5 
Looping 
Reading Data from a File 
In addition to viewing a text file with a text editor, you can also use the data in a text file 
as input for a program . This is easy to do because the >> operator can read data from a file 
as well as from the ci n object . Assuming i nputFi le is an fst ream or i fstream object, the 
following statement will read a string from the file and store it in the string variable name: 
inputFile 
>> name; 
Program 5-18 uses this statement . It opens the Fri ends. txt file holding the three 
names that we created by Program 5-17. It reads in the names and displays them on the 
screen . Then it closes the file. 
Program 5-18 
1 
II This program reads data from a file. 
2 
#i nclude <iostream> 
3 
#i nclude <fstream> 
II Needed to use files 
4 
#i nclude <string> 
5 
using namespace std; 
6 
7 
int main () 
8 { 
9 
ifstream 
i nputFile; 
10 
string 
name; 
11 
12 
II Open the input file 
13 
inputFile.open
("Friends.txt"); 
14 
15 
cout << "Here are the names stored 
in the Friends.txt 
file.\n"; 
16 
17 
18 
19 
20 
21 
22 
23 
for (in t count= 
1 ; count<= 
3; count++) 
{ 
} 
inputF i le >> name; 
cout <<name<< 
endl; 
inputFile.close
(}; 
II Read the next name from the file 
II and display 
it 
II Close the file 
24 
return 
O; 
25
} 
Program Output 
Here are the names stored 
in the Friends.txt 
file. 
Joe 
Chris 
Geri 
Notice that Programs 5-17 and 5-18 both contain a loop . Most programs that work with 
files perform the same operat ions for each record in the file. Therefore they will normally 
contain a loop that is executed once for each record . The loop in Program 5-17 iterates 
once for each piece of data to be input by the user and written to the file. The loop in 
Program 5-18 iterates once for each piece of data to be read from the file and displayed. 

Figure 5-14 
Figure 5-15 
Figure 5-16 
5.12 Using Files for Data Storage 
295 
The Read Position 
When a file has been opened for input, the file stream object internally maintains a special 
value known as a read position. A file's read position marks the location of the next byte 
that will be read from the file. When an input file is opened, its read position is initially set 
to the first byte in the file. So the first read operation extracts data starting at the first byte. 
As data is read from the file, the read position moves forward, toward the end of the file. 
Let's see how this works with the example shown in Program 5-18. When the Fri ends . 
tx t file is opened by the statement in line 13, the read posit ion for the file will be 
positioned as shown in Figure 5-14. 
I J 
o 
e I \n I C 
h 
r 
i 
s I \n I G 
e 
r 
i I \n I 
t 
Read position 
Keep in mind that when the >> operator extracts data from a file, it expects to read 
pieces of data that are separated by whitespace characters (spaces, tabs, or newlines). 
When the statement in line 19 executes the first time, the >> operato r reads data from 
the file's current read position, up to the \n character. The data that is read from the 
file is assigned to the name variable. The \ n characte r is also read from the file, but it is 
not included as part of the data . So name will hold the value "Joe" after this statement 
executes. The file's read position will then be at the location shown in Figure 5-15. 
J 
o 
e I \n I C 
h 
r 
i 
s I \n I G 
e 
r 
i I \n I 
t 
Read position 
When the statement in line 19 executes the second time, it reads the next item from the 
file, which is "Chris", and assigns that value to the name variable. After this statement 
executes, the file's read position will be at the location shown in Figure 5-16. 
J 
o 
e I \n I C 
h 
r 
i 
s I \n I G 
e 
r 
i I \n I 
t 
Read position 
When the statement in line 19 executes the third time, it reads the next item from the 
file, which is "Geri", and assigns that value to the name variable. After this statement 
executes, the file's read position will be at the end of the file, as shown in Figure 5-17. 

296 
Chapte r 5 
Looping 
Figure 5-17 
J 
o 
e I \n I C 
h 
r 
; 
s I \n I G 
e 
r 
i I \n I 
t 
Read position 
Letting the User Specify a Filename 
0 
In each of the previous examp les, the name of the file that is opened is hard-coded as a 
string literal into the program. In many cases, however, you will want to let the user specify 
the name of the file to use. In C++ 11 you can pass a string object as an argument to a file 
stream object's open member function. Program 5-19 shows an example. Line 19 prompts 
the user to enter the name of a file to read from. Line 20 stores the name the user enters in 
a string object named fi l eName, and line 27 passes it as an argument to the open function. 
Program 5-19 also has the user enter the number of values to be read from the file. 
Program 5-19 
1 II This program sums the numeric values stored 
in a file. 
2 II It l ets the user spec i fy the name of the file, 
as well as 
3 II the number of values 
to read from it. 
4 #include 
<str i ng> 
5 #include 
<iostream> 
6 #include 
<fstream> 
II Needed to use files 
7 using namespace std ; 
8 
9 int main() 
ifstream 
i nputFi l e ; 
II File stream object 
10 { 
11 
12 
13 
14 
15 
16 
string 
f il eName; 
II Holds the user entered 
fi l e 
int numValues ; 
II Number of values 
to read 
double value , 
II A single 
value read 
total 
= 0.0; 
II Accumulator 
17 
II Prompt the user to enter 
the data file 
name 
name 
18 
cout << "This program reads and sums the values 
in a data file.
\ n"; 
19 
cout << "Enter the name of the fi le to read from: "; 
20 
cin 
>> fileName ; 
21 
22 
II Get the number values to read 
23 
cout << "How many values are stored 
i n your file?"· 
24 
cin 
>> numValues; 
25 
26 
II Open the input f ile 
27 
inputF il e .open(fileName); 
28 
29 
II Loop once for each pie ce of data to read 
30 
for (i nt count
= 1 ; count<
= numValues; count++) 
31 
{ 
32 
II Read a value from the file 
and add it to the sum 
33 
34 
35 
} 
inputFile 
>> value; 
total 
+= value; 
(program continues) 

5.12 Using Files for Data Storage 
297 
Program 5-19 
(continued) 
36 
cout << "\nThe total 
of the
"<< numValues <<" values is" 
37 
<<total<< 
endl; 
38 
39 
// Close the file 
40 
inputF i le .close(); 
41 
return 
O; 
42
} 
Program Output with Example Input Shown in Bold 
This program reads and sums the values in a data file. 
Enter the name of the file 
to read from: Sales.txt[Enter] 
How many values are stored 
in your file? 
5[Enter] 
The total 
of the 5 values is 6550 
The Sal es. txt file, whose name is input by the user in this example run, can be found 
in the Chapter 5 programs folder on the book's companion website . 
Using the c_st r Member Function in Older Versions 
ofC++ 
In older versions of the C++ language (prior to C++ 11 ), a file stream object's open 
member function will not accept a string 
object as an argument . The open member 
function requires that you pass the name of the file as a null-terminated string, which is 
also known as a C-string. String literals are stored in memory as null-terminated C-strings 
(which explains why you can pass them to the open function), but string objects are not. 
Fortunately, string 
objects have a member function named c_str that returns the 
contents of the object formatted as a null-terminated C-string. Here is the general 
format of how you call the function: 
stringObject.c
_ str() 
In the general format, stringObject 
is the name of a string object. The c_str function 
returns a copy of the string stored in stringObject 
as a null-terminated C-string . 
For examp le, line 27 in Program 5-19 could be rewritten like this to make the program 
compatib le with older versions of C++: 
inputF i le .open(fileName.c
_str ()); 
Detecting the End of the File 
Program 5-19 asked the user how many values were in the file, and that is how many 
data items it read in. However, when reading data from a file, it is not necessary for the 
user to specify how many data values there are or where the data ends . This is because 
files have an end of file (EOF) mark at their end. You cannot see it, but it is there, and 
a program can test to see whether or not it has been reached. This test is important 
because an error will occur if the program attempts to read beyond the end of the file. 

298 
Chapte r 5 
Looping 
The easiest way to test if the end of the file has been reached is with the >> operato r. 
This operator not only can read data from a file, but it also returns a true or false value 
indicating whether or not the data was successfully read. If the operator returns true, 
then a value was successfully read . If the operator returns false, it means that no value 
was read from the file. The EOF has been reached. 
Program 5-20 revises Program 5-19 to read in and sum the values in a file without knowing 
how many numbers are in the file. It also counts the numbers as it reads them in. 
Program 5-20 
1 II Thi s program reads and sums the numeric values 
stored 
in a file
. 
2 II It reads until 
the end of the file 
(EOF) is reached. 
3 #include 
<str i ng> 
4 #include 
<iostream> 
5 #include 
<fstream> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
ifstream 
inputFile; 
11 
string 
fileName; 
12 
int numValues = O; 
13 
double value , 
14 
total 
= 0.0; 
15 
II Needed to use files 
II File stream object 
II Holds the user entered 
fi l e 
II Counts the number of values 
II A single 
value read 
II Accumulator 
16 
II Prompt the user to enter 
the data file 
name 
name 
read 
17 
cout << "This program reads and sums the values 
in a data file.
\ n"; 
18 
cout << "Enter the name of the f i le to read from: "; 
19 
cin 
>> fileName ; 
20 
21 
II Open the input 
f i le 
22 
inputF i le .open(fileName); 
23 
24 
II Loop unti l the EOF is reached 
25 
whi le (i nputFi le >> value) 
II If a value was read, 
execute 
the 
26 
{ 
numValues++; 
II loop aga i n to count the value and 
27 
total 
+= value; 
II add i t to the total 
28 
} 
29 
cout << "\nThe total 
of the
"<< 
numValues <<" 
values 
is" 
30 
<<total<< 
endl; 
31 
32 
II Close the file 
33 
inputF i le .close(); 
34 
return 
O; 
35
} 
Program Output with Example Input Shown in Bold 
This program reads and sums the values 
in a data file. 
Enter the name of the file 
to read from: Sales.txt[Enter] 
The total 
of the 5 values 
is 6550 

5.12 Using Files for Data Storage 
299 
Now let's take a closer look at line 25, which controls the loop. 
whi le (i nputFi le >> value) 
Notice that the statement that extracts data from the file is used as a Boolean test 
expression in the while loop . It works like this: 
• The expression i nputFi le >> value executes. 
• If an item is successfully read from the file, the item is stored in the value variable, 
and the expression returns true to indicate that it succeeded. In that case, the 
statements in lines 26 and 27 execute and the loop repeats . 
• When there are no more items to read from the file, the expression i nputFi l e >> value 
returns false, indicating that it did not read a value. In that case, the loop terminates. 
Testing for File Open Errors 
Unde r certain circumstances, the open member function will not work. For example, 
the following code will fail if the file i nfo . txt does not exist or cannot be found in the 
expected directory: 
fstream 
i nputFile; 
i nputF il e .open("info
.txt"); 
Fortunately , there is a way to determine whether the open member function successfully 
opened the file. After you call the open member function, you can test the file stream 
object as if it were a Boolean expression . Program 5-21 shows how to do this . 
Program 5-21 
1 // Thi s program te sts fo r fi l e open errors. 
2 #include 
<iostream> 
3 #include 
<fs t ream> 
// Needed to use files 
4 using namespace std ; 
5 
6 int main () 
7 { 
8 
ifstream 
i nput Fi le; 
9 
int number ; 
10 
11 
// Attemp t t o open the i nput f i le 
12 
inputF il e .open(" ListOfNumbers.txt"); 
13 
14 
// 
If the fi l e successfully 
opened , process 
it 
15 
if (i nputF ile ) 
16 
{ 
17 
// Read t he numbers from t he file 
and display 
them 
18 
while 
(i nputFile 
>> number) 
19 
cout <<number<< 
endl; 
20 
21 
// Close the fi le 
22 
inpu t File.close(); 
23 
} 
(program continues) 

300 
Chapte r 5 
Looping 
Program 5-21 
(continued) 
24 
els e II The fi le could not be found and opened 
25 
{ 
26 
II Display an error 
message 
27 
cout 
<< "Error opening the file
.\ n"; 
28 
} 
29 
ret urn O; 
30
} 
Program Output (when LlstOfNumbers.txt does not exist) 
Error opening the file. 
Let's take a closer look at certain parts of the code. Line 12 calls the open member 
function to open the file Li stOfNumbers. txt and associate it with the i fstrea
m object 
named i nputFi le . Then the if statement in line 15 tests the value of i nputF i le as if it 
were a Boolean expression. When tested this way, i nputF i le will give a true value if 
the file was successfully opened . Otherwise it will give a false value. As the example 
output shows, the program displays an error message if it could not open the file. 
Another way to detect a failed attempt to open a file is with an i fstream class member 
function named fail , as shown in the following code: 
i fstream 
inputF i le; 
inputF i le .open("customers.txt"); 
if 
(inputFile
.fail()) 
cout 
<< "Error opening file.\n"; 
else 
{ 
II Process 
the file 
} 
The fa i l member function returns true when an attempted file operation fails (i.e., is 
unsuccessful) and returns false otherwise . When using file 1/0 , it is a good idea to 
always test the file stream object to make sure the file was opened successfully before 
attempting to use it. If the file could not be opened, the user should be informed and 
the program should handle the situation in an appropriate manner. 
~ 
Checkpoint 
5.24 
A) What is an output file? B) What is an input file? 
5.25 
What header file must be included in a program to use files? 
5.26 
What five steps must be taken when a file is used by a program? 
5.27 
What is the difference between a text file and a binary file? 
5.28 
What is the difference between sequential access and random access? 
5.29 
What type of file stream object do you create if you want to write data to a file? 
5.30 
What type of file stream object do you create if you want to read data from a file? 

5.13 
5.13 Focus on Testing and Debugging: Creating Good Test Data 
301 
5.31 
If dataFi l e is an ofstream object associated with a disk file named payRates .dat, 
which of the following statements would write the value of the hourl yPay 
variab le to the file? 
5.32 
5.33 
A) ifStream << hourlyPay; 
C) dataF i le << hourlyPay; 
B) ifStream >> hourlyPay ; 
D) dataFi l e >> hourlyPay; 
If dataFi l e is an i fstream object associated with a disk file named payRates .dat, 
which of the following statements would read a value from the file and place it in 
the hourl yPay variable? 
A) ifStream << hourlyPay; 
C) dataF i le << hourlyPay ; 
B) ifStream >> hourlyPay; 
D) dataF i le >> hourlyPay ; 
Assume you have an outp ut file named numbers. txt that is open and associated 
with an of stream object named outf i 1 e. Write a program segment that uses a 
fo r loop to write the numbers 1 through 10 to the file. 
Focus on Testing and Debugging: Creating Good 
Test Data 
CONCEPT: 
Thorough testing of a program requires good test data. 
Once a program has been designed, written in a programming language, and found to 
compile and link witho ut errors, it must be thoroughly tested to find any logic errors and 
to ensure that it works correctly according to the original problem specification . When it 
comes to creating test data, quality is more important than quantity. That is, a small set 
of good test cases can provide more information about how a program works than twice 
as many cases that are not carefully thought out. Each test case should be designed to test 
a different aspect of the program, and you should always know what each test set you use 
is checking for. As an illustrat ion, look at Program 5-22. It uses a sentinel-controlled loop 
to average two test scores for each student in the class, where all test scores are between 
0 and 100. The program compiles, links, and runs. But it contains several logic errors . 
Program 5-22 
1 II This program attempts 
to average 2 test 
scores 
for each 
2 II student 
in a class. 
However, i t contains 
log i c errors. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 #include 
<iomanip> 
6 usi ng namespace std; 
7 
8 i nt mai n() 
9 { 
string 
name; 
II Student 
f i rst name 
II Student 
counter 
II An individual 
score read in 
10 
11 
12 
13 
14 
15 
i nt count= 
1, 
score, 
totalScore 
= O; 
doubl e average ; 
II Total of a student's 
2 scores 
II Average of a student's 
2 scores 
(program continues) 

302 
Chapte r 5 
Looping 
Program 5-22 
(continued) 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 } 
cout <<fixed<< 
showpoint << setprec
i sion(1}; 
cout << "Ent er the first 
name of st udent•<< 
count 
<<. 
(or a to quit): 
"; 
cin 
>> name; 
while 
(name != ·a· && name!
= "q"} 
{ 
} 
// Get and validate 
the first 
score 
cout << "Enter score 1 : "; 
cin 
>> score; 
if (score<
= 0 I I score>= 
100} 
{ cout << "Score must be between O and 100. Pl ease reenter: 
"; 
cin 
>> score ; 
} 
totalScore 
+= score; 
// Add the first 
score onto the total 
// Get and validate 
the second score 
cout << "Enter score 2: "; 
cin 
>> score; 
if (score<
= 0 I I score>= 
100} 
{ cout << "Score must be between O and 100. Pl ease reenter: 
"; 
cin 
>> score ; 
} 
totalScore 
+= score; 
// Add the second score onto the total 
// Calculate 
and pr i nt average 
average
= totalScore 
/ 2; 
cout <<name<< 
setw(6) 
<<average<< 
endl; 
II Get the next student 
name 
cout << "Enter the first 
name of student•<< 
count++ 
<< • (or Q to quit): . . 
' 
cin 
>> name ; 
return 
O; 
Table 5 -2 Preliminary Test Plans for Program 5-22 
Test 1: 
Test 2: 
Test 3: 
Test 4: 
Name 
Mary 
Q 
Bill 
Q 
Tom 
q 
Sam 
q 
Score 1 
80 
70 
80 
- 1 then 1 
Score 2 
Expected Outcome 
80 
80.0 
program quits 
80 
75 .0 
program quits 
90 
85.0 
program quits 
999 then 99 
50 .0 
program quits 

5.13 Focus on Testing and Debugging: Creating Good Test Data 
303 
Try running the program using the four test cases shown in Table 5-2. The program 
contains five logic errors . However, if it is run with just these four test cases, none 
of the errors will be revealed. The test data is not designed carefully enough to 
catch them . Tests 1, 2, and 3 are really just three versions of the same test . They 
all simply check that the program can compute a correct average for a single 
student where the resu lt has no decimal digits. The fina l test checks that the 
program can catch a single invalid value that is too small or too big, but does not 
check what will happen if a second invalid value is entered for the same input . 
Table 5-3 contains a better set of tests and illustrates some of the kinds of things 
you should check for when you test a program . These tests will reveal all five of 
the program's errors. 
Table 5 -3 Modified Test Plans for Program 5-22 
Test 
1 
2 
3 
Expected 
Name 
Score 1 
Score 2 
Purpose 
Outcome 
Mary 
Bill 
Tom 
Q 
Sam 
Ted 
q 
Bob 
q 
80 
80 
Program correctly handles 
80.0 
70 
80 
both even results and 
75 .0 
80 
91 
ones with decimal values. 
85.5 
Program can loop to 
program ends 
handle multiple students. 
Program ends when Q is 
entered for the name. 
- 1 then 1 
101 then 99 Program correctly handles 50 .0 
- 1 then - 2 then 1 
200 then 
invalid scores, even when 
50 .0 
500 
more than one bad score 
program ends 
is entered in a row. 
then 99 
Program catches bad 
inputs immediately 
outside the valid range 
(e.g., - 1 & 101). 
Program ends when q is 
entered for the name. 
0 
100 
Program allows values at 
50 .0 
extreme ends of the valid 
program ends 
range. 
Rerun Program 5-22 using the test cases from Table 5-3 and examine the incorrect 
output to identify the errors . Then see if you can fix them. Do not rewrite the program. 
Just make the smallest changes necessary to correct the errors. Now test the program 
again using the test cases in Table 5-3. Continue making corrections and retesting until 
the program successfully passes all three of these test cases. A correct solution can be 
found on the book's companion website in the pr5-22B.cpp 
file of the Chapter 5 
programs folder. 

304 
Chapter 5 
5.14 
Looping 
Central Mountain 
Credit Union Case Study 
The manager of the Centra l Mounta in Credit Union has asked you to write a loan 
amortization program that his loan officers can run on their laptops . Here is what it 
should do. 
Problem Statement 
When given the loan amount , annua l interest rate, and number of years of a loan, the 
program must determine and display the monthly payment amount. It must then create 
and display an amortization table that lists the following information for each month 
of the loan: 
• payment number 
• amount of that month 's payment that was applied to interest 
• amount of that month 's payment that was applied to principal 
• balance after that payment . 
The following report may be used as a model. It shows all the required informat ion on 
a $2,000 loan at 7.5 percent annual interest for 0.5 years (i.e., 6 months) . 
Mont hly payment: $340.66 
Month 
I nterest 
Princi
pal 
Balanc e 
1 
12 .50 
328 .16 
1671. 84 
2 
10 .45 
330 .2 1 
1341.62 
3 
8 .39 
332 .28 
1009.34 
4 
6 .31 
334. 35 
674 .99 
5 
4 .22 
336 .4 4 
338.55 
6 
2 .12 
338 .55 
0.00 
Calculations 
The credit union uses the following formula to calculate the month ly payment of a loan: 
Payment= 
where: 
Loan,,. Rate/12 " Term 
Term - 1 
Loan = Amount of the loan 
Rate = Annua l interest rate 
Term= (1 + Rate/12)Years'l2 
Variables 
Table 5-4 lists the variables needed in the program. 

5.14 Central Mountain Credit Union Case Study 
305 
Table 5 -4 Variables Used in the Cent ral Mounta in Credit Union Case Study 
Variable 
lo an 
rate 
Description 
A double. Holds the loan amount . 
mo! nterestRate 
years 
A doub 1 e. Holds the annua l intere st rate. 
A double. Holds the month ly interest rate . 
A double. Holds the number of years of the loan. 
balance 
term 
payment 
numPayments 
month 
molnterest 
princ i pal 
Figure 5-18 
I 
Read loan 
amount 
A doub 1 e. Holds the remaining balance to be paid . 
A double. Used in the monthly payment calculation . 
A double. Holds the month ly payment amount . 
An int . Holds the total number of payments. 
An int . Loop control variable that holds the current payment number. 
A double. Holds the month ly interest amount . 
A double. Holds the amount of the monthly payment that pays down the loan. 
Program Design 
Figure 5-18 shows a hierarchy chart for the program. 
Main 
I 
I 
I 
I 
Input loan 
Pertorm 
Display 
starting 
parameters 
calculations 
report 
I 
I 
I 
I 
I 
I 
I 
I 
I 
Read annual 
Read years 
caJculate 
Calculate 
Calculate 
Print 
For each month calculate 
interest rate 
ol loan 
number ol 
monthly 
monthly 
header 
interest, principal, new 
payments 
interest rate 
payment 
balance. Display report 
detail line 
Detailed Pseudocode 
<including actual variable names and needed calculations> 
Input 
loan , rate , years 
numPayments =y ears• 
12.0 
mointerestRate 
= rate I 12.0 
term = {1 + mointerestRate)numPayments 
payment= 
(loan
• mointerestRate 
• term ) I (t erm -
1.0) 
Display payment 
Display 
a report 
header with column headings 
balance= 
loan 
II Remaining balance starts 
out as full 
loan amount 

306 
Chapte r 5 
Looping 
For each month of the Joan 
mointerest 
= mointerestRate 
* balance 
If it's 
not the fina1 month 
principal= 
payment - mointerest 
E1se 
principal= 
balance 
payment= 
balance+ 
mointerest 
End If 
II Ca1cu1ate interest 
first 
II Rest of pmt goes to principal 
II It's 
the Jast month so 
II pay off exact 
fina1 balance 
balance = balance - principal 
II On1y principal 
reduces the balance 
Display month, mointerest, 
principal, 
balance 
End of 1oop 
The Program 
The next step, after the pseudocode has been checked for logic errors, is to expand the 
pseudo-code into the final program. This is shown in Program 5-23. 
Program 5-23 
1 II This program produces a loan amortization 
table 
2 II for the Central 
Mountain Cred it Union. 
3 #include 
<iostream> 
4 #include 
<iomani p> 
5 #include 
<cmath> 
II Needed for the pow function 
6 us i ng namespace std; 
7 
8 i nt mai n() 
9 { 
10 
double loan , 
11 
rate, 
12 
molnterestRate, 
13 
years, 
14 
balance, 
15 
16 
17 
18 
int 
term, 
payment; 
numPayments ; 
19 
I I Get loan informat i on 
II 
II 
II 
II 
II 
II 
II 
II 
20 
cout << "Loan amount: $"; 
21 
cin 
>> loan; 
Loan amount 
Annual interest 
rate 
Monthly interest 
rate 
Years of loan 
Monthly balance 
Used to calculate 
payment 
Monthly payment 
Number of payments 
22 
cout << "Annual interest 
rate 
(entered 
as a decimal): 
"· 
23 
cin 
>> rate; 
24 
cout << "Years of loan : " · 
25 
ci n >> years; 
26 
27 
II Calculate 
monthly payment 
28 
numPayments = static
_cast< i nt>(12 
* years); 
29 
molnterestRate 
= rate 
I 12.0 ; 
30 
term= 
pow((1 + molnterestRate
), numPayments); 
31 
payment= 
(loan* 
molnterestRate 
* term) 
I (term - 1.0); 
32 
33 
34 
35 
36 
II Display monthly payment 
cout <<fixed<< 
showpoint << setprec
i sion(2); 
cout << "Monthly payment:$"<< 
payment<< 
endl ; 
(program continues) 

5.14 Central Mountain Credit Union Case Study 
307 
Program 5-23 
(continued) 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 } 
II Display 
report 
header 
cout << endl ; 
cout << setw (5} << "Month" 
<< setw (10} << "Interest"
; 
cout << setw (10) << "Princ i pal"<< 
setw (9) 
<< "Balance " << endl ; 
cout << "----------------------------------
\ n'' ; 
balance
= l oan ; 
II Remaining balance 
starts 
out as ful l l oan amount 
II Prod uce a listing 
for each month 
fo r (int month
= 1; month< = numPayments ; month++) 
{ 
} 
double mointerest
, 
principal
; 
II Amount of pmt that 
pays i nterest 
II Amount of pmt that 
l owers the balance 
II Calc ul ate amount paid for this 
month's 
interest 
and principal 
mointerest 
= mointerestRate 
* balance ; II Cal culate 
interest 
f i rst 
if 
(month != numPayments } 
II If not the f i nal month 
principa
l= 
payment - mointerest
; 
II rest 
of pmt goes 
el se 
{ 
principa
l = balance ; 
payment = balance
+ mointerest
; 
} 
II Calc ul ate new loan balance 
balance
- = pr i ncipal
; 
II Di splay 
th i s month ' s payment fig ures 
II to pr i ncipa l 
II It ' s the l ast month so 
II pay exact 
final 
balance 
II Onl y principa
l reduces 
the 
II bal ance , not the whole pmt 
cout << setw (4) 
<< month 
<< setw (10) << mointerest
; 
cout << setw (10) << principal 
<< setw (10) <<balance<< 
endl ; 
ret urn O; 
Program Output with Example Input Shown In Bold 
Loan amount: $1200[Enter] 
Annual interest 
rate 
( entered 
as a decimal}: 
.08[Enter] 
Years of 1 oan: 
1 [Enter] 
Monthly payment: $104.39 
Month 
Interest 
Principal 
Balance 
1 
8.00 
96.39 
1103.61 
2 
7.36 
97.03 
1006.59 
3 
6.71 
97.68 
908. 91 
4 
6.06 
98.33 
810.58 
5 
5.40 
98.98 
711.60 
6 
4.74 
99.64 
611.96 
7 
4.08 
100. 31 
511.65 
8 
3.41 
100.98 
410.68 
9 
2.74 
101 . 65 
309.03 
10 
2.06 
102.33 
206.70 
11 
1. 38 
103. 01 
103.69 
12 
0.69 
103.69 
0.00 

308 
Chapter 5 
Looping 
NOTE: 
You might have not iced in the output that for some months, such as 
months 5 and 6, the interest amount plus the principal amount does not add up to 
the monthly payment amount . Also, for some months, the previous balance minus 
the principa l paid does not exactly equal the new balance . The se prob lems are 
due to round -off error, which is caused by a disparity between the precision of a 
value the computer stores internally and the precision of the value it displays . 
Do not worry about this problem for now . You will learn later how to deal with it. 
Testing the Program 
Testing the program has been left as an exercise for you to do. Use what you learned 
in Section 5 .13 about developing good test cases to develop a set of cases you can use 
to test Program 5-23. The program runs correctly except for one special case, where it 
fails . The program design failed to realize the need to handle this special case 
differently than it handles other data. Try to come up with input data for a test case 
that reveals the error. Then, once you have identified the prob lem, see if you can 
revise the program to fix it. A corrected version of Program 5-23 can be found in the 
pr5 - 23B . cp p file of the Chapter 5 programs folder on the book's companion website. 
Lightening Lanes Case Study 
The following additional case study, which contains applications of material introduced in 
Chapter 5, can be found on this book's companion website at pearsonhighered.com/gaddis. 
On Tuesday afternoons, Lightening Lanes Bowling Alley runs a special class to teach 
children to bowl. Each lane has an instructor who works with a team of four student 
bowlers and instructs them as they bowl three lines (i.e., games). The management of 
Lightening Lanes has asked you to develop a program that will report each student's 
three-game average score and compare it to the average score they bowled the previous 
week. In this way, the students can see how much they are improving. The program 
will use looping structures and data validation techniques learned in Chapter 5. 
5.15 
Tying It All Together: What a Colorful World 
In this chapter's Tying It All Together section we'll take a look at how to use looping 
constructs along with colorful output characters to create interesting screen displays. 
All the C++ programs you have seen so far produce output that is white on a black 
background . This is because they use the standard C++ i ost re am libraries, which can 
only display output in these two colors . However, C++ compilers provide other libraries 
you can use to call operating system functions that can display output in many colors. 
Because these libraries are tailored to specific operating systems, programs that use 
them will only run on the system they were written for. 
Here is how to use Microsoft Windows functions to create programs with colorfu l 
output that can run on Windows 2000 and newer operating systems. 

Table 5 -5 
Number 
0 
1 
2 
3 
4 
5 
6 
7 
5.15 Tying It All Together: What a Colorful World 
309 
The first thing you need to do is include the following file in your program so you will 
be able to use the functions you need: 
#include 
<windows.h> 
Next, because programs can actually access more than one screen device at a time, you 
will need to indicate which screen you want the colors you set to appear on. The cout 
object writes to the standard output screen. You can set colors on this screen by 
providing a handle to it. A handle is an object of type HANDLE, which is defined by 
Microsoft Windows. Here is how to obtain a handle to the standard output screen: 
HANDLE screen= 
GetStdHand l e(STD_OUTPUT_HANDLE); 
GetStdHandl e is a Windows -specific library function and STD_OUTPUT _ HANDLE is a 
Windows -specific constant . 
The easiest way to set a color is to call the SetConso l eTextAttri 
bute function and 
pass it the name of the handle to the output screen and a number that tells what color 
you want the output text to appear in. Table 5-5 shows the number that corresponds 
to each color. 
Windows Text Colors 
Text Color 
Number 
Text Color 
Black 
8 
"Bright" Black 
Blue 
9 
Bright Blue 
Green 
10 
Bright Green 
Cyan 
11 
Bright Cyan 
Red 
12 
Bright Red 
Purple 
13 
Bright Purple 
Yellow 
14 
Bright Yellow 
White 
15 
Bright White 
Once you set a color it will remain in effect for all output text until you set a new one. 
The following code segment shows how you can write the string "red" in red, "white" 
in white, "blue" in blue, and "bright yellow" in bright yellow. 
SetConsoleTextAttribute(screen, 
4); 
cout <<"Red"<< 
endl ; 
SetConsoleTextAttribute(screen, 
7); 
cout <<"White"<< 
endl ; 
SetConsoleTextAttribute(screen, 
1); 
cout <<"Blue"<< 
endl; 
SetConsoleTextAttribute(screen, 
14); 
cout << "Bright 
Yellow"<< 
endl; 
Here are two programs that use color. Neither one requires any input. Try running them 
to see their output displayed in color. Program 5-24 uses a loop to display "Hel lo World" 
on a black background in each of the 16 colors shown in Table 5-5. 

310 
Chapte r 5 
Looping 
Program 5-24 
1 II This program demonstrates 
Wi ndows functions 
to print 
colored 
2 II text . It di splays" 
Hell o World!" in 16 different 
colors. 
3 #include 
<iostream> 
4 #include 
<windows.h> 
5 us i ng namespace std; 
II Needed to display 
col ors and call 
Sl eep 
6 
7 i nt mai n() 
8 { 
9 
II Create 
a handle to the computer screen. 
10 
HANDLE screen= 
GetStdHandle(S TD_OUTPUT
_HANDLE); 
11 
12 
II Write 16 lines 
i n 16 di fferent 
col ors. 
13 
for (int 
color= 
O; color< 
16; col or++) 
14 
{ 
15 
SetConsoleTextAttribute 
(screen, 
color); 
16 
cout <<" 
Hel lo World!"<< 
endl; 
17 
Sl eep(400); 
II Pause between l ines to watch them appear 
18 
} 
19 
II Restore 
the normal text 
color) 
20 
SetConsoleTextAttribute(screen, 
7); 
21 
return 
O; 
22} 
Notice in Program 5-24 that each cout statement ended with an endl. This is needed 
to "flush" the buffer to ensure that all the output has been written to the screen before 
you change to another color. A ' \ n' will not work because it causes output to go to the 
next line but does not flush the output buffer. 
Program 5-25 provides another example of creating colorful output. It uses a loop to 
print the ABCs in color, alternating between bright green, red, and yellow. 
Program 5-25 
1 II This program writes 
the ABCs i n green, 
red, 
and yel l ow. 
2 #include 
<iostream> 
3 #include 
<windows.h> 
II Needed to display 
col ors and call 
sl eep 
4 us i ng namespace std; 
5 
6 i nt mai n() 
7 { 
8 
II Bright Green= 
10 
Bri ght Red= 12 
Bright 
Yel l ow= 14 
9 
10 
II Get the handl e to standard 
output 
dev i ce (the console) 
11 
HANDLE screen= 
GetStdHandle(S TD_OUTPUT
_HANDLE); 
12 
13 
II Write the ABCs using 3 col ors 
14 
int col or= 
10; 
II Star i ng color= 
green 
(program continues) 

Review Questions and Exercises 
3 11 
Program 5-25 
(continued) 
15 
for (char letter 
= 'A'; 
letter 
<= 'Z'; 
letter
++) 
16 
{ 
17 
SetConsoleTextAttribute 
(screen, 
color); 
II Set the color 
18 
cout <<letter<<" 
"<< endl ; 
II Print 
the letter 
19 
20 
21 
22 
23 
color +=2; 
i f (color 
> 14) 
col or= 
10; 
II Choose next color 
24 
S1eep(280); 
II Pause between characters 
to watch them appear 
25 
} 
26 
II Restore 
normal text 
attr i bute (i.e. 
white) 
27 
SetConso l eTextAttr
i bute(screen, 
7); 
28 
return 
O; 
29 } 
There are three important things to remember when working with colors: 
• Include the <windows. h> header file. 
• Follow each cout statement with an endl . 
• Always set the text color back to norma l (i.e., white) before quitting . 
Review Questions and Exercises 
Fill-in-the-Blank 
1. To _____ 
a value means to increase it by one. 
2. To _____ 
a value means to decrease it by one. 
3. When the increment or decrement operator is placed before the operand (or to 
the operand's left), the operator is being used in ____ 
mode. 
4. When the increment or decrement operator is placed after the operand (or to the 
operand's right), the operator is being used in ____ 
mode. 
5. The statement or block that is repeated is known as the _____ 
of the loop. 
6. Each repetition of a loop is known as a(n) ___ 
_ 
7. A loop that evaluates its test expression before each repetition is a(n) ____ 
loop. 
8. A loop that evaluates its test expression after each repetition is a(n) ____ 
loop. 
9. A loop that does not have a way of stopping is a(n) ____ 
loop. 
10. A(n) _____ 
is a variab le that "counts" the number of times a loop repeats. 
11. A(n) 
is a sum of numbers that accumulates with each iteration of a loop. 

312 
Chapter 5 
Looping 
12. A(n) ____ 
is a variab le that is initialized to some starting value, usually 
zero, and then has numbers added to it in each iteration of a loop. 
13. A(n) ____ 
is a special value that marks the end of a series of values. 
14. The 
loop is ideal for situations that require a counter. 
15. The 
loop always iterates at least once. 
16. The _____ 
and _____ 
loops will not iterate at all if their test expressions 
are false to start with. 
17. Inside the for loop's parentheses, the first expression is the ____ 
, the second 
expression is the ____ 
, and the third expression is the ___ 
_ 
18. A loop that is inside another is called a(n) ____ 
loop. 
19. The ____ 
statement causes a loop to terminate immediately. 
20. The 
statement causes a loop to skip the remaining statements in the 
current iteration . 
21. What header file do you need to include in a program that performs file operations? 
22. What data type do you use when you want to create a file stream object that can 
write data to a file? 
23. What happens if you open an output file and the file already exists? 
24. What data type do you use when you want to create a file stream object that can 
read data from a file? 
25. What is a file's read position? Where is the read position when a file is first opened 
for reading? 
26. What should a program do when it is finished using a file? 
Algorithm Workbench 
27. Write code that lets the user enter a number. The number should be multiplied by 
2 and printed until the number exceeds 50. Use a while loop . 
28. Write a do-while 
loop that asks the user to enter two numbers. The numbers 
should be added and the sum displayed . The user should be asked if he or she 
wishes to perform the operation again. If so, the loop should repeat; otherwise it 
should terminate. 
29. Write a for loop that displays the following set of numbers: 
0, 10, 20, 
30, 
40, 
50 . . . 1000 
30. Write a loop that asks the user to enter a number. The loop should iterate 
10 times and keep a running total of the numbers entered . 
31. Write a nested loop that displays the following ouput: 
***** 
***** 
***** 

Review Questions and Exercises 
3 13 
32. Write a nested loop that displays 10 rows of'#' characters . There should be 15 '#' 
characters in each row. 
33. Rewrite the following code, converting the while loop to ado-whi le loop: 
char doAgain = 'y'; 
i nt sum= O; 
cout << "Thi s code 
whil e ((doAgai n == 
{ 
sum++; 
wil l increment sum 1 or more t imes.\n"; 
'y') 
11 (doAgain == 'Y')) 
cout << "Sum has been i ncremented. 
Increment it again(y/n)? 
"; 
cin 
>> doAgain; 
} 
cout << "Sum was i ncremented"<< 
sum<<" 
times . \n"; 
34. Rewrite the following code, replacing the do-whi l e loop with a while loop. 
When you do this you will no longer need an if statement. 
i nt number; 
cout << "Enter an 
do 
{ 
cin >> number; 
even number: "; 
if (number% 2 != 0) 
cout << "Number must be even. Reenter number: "; 
} while 
(number% 2 != O); 
35. Convert the following while loop to a for loop: 
i nt count= 
O; 
whil e (count< 
50) 
{ 
} 
cout << "count is"<< 
count << endl; 
count++; 
36. Convert the following for loop to a while loop: 
for (in t x = 50; x > O; x--) 
{ 
cout << x <<" seconds t o go.\n"; 
} 
37. Comp lete the program segment below to write the numbers 1 through 50 to the 
numbers . txt file. 
ofs t ream outputFile; 
outp ut File.open("numbers
.txt"); 
// YOU WRITE THIS CODE. 
outpu t File.close(); 

314 
Chapte r 5 
Looping 
38. Comp lete the following program segment that reads in and disp lays the data 
written 
to the numbers. txt 
file in the previous question. 
Your code should 
continue reading values until the end of file is reached . 
i fs t ream inputF il e; 
i nputFi l e .ope n ("n umbers. t xt"); 
II YOU WRITE THIS CODE. 
i nputFi l e .close(); 
Predict the Output 
What will each of the following program segments display? 
39. i nt 
X = 1 ; 
whil e (x < 10); 
x++; 
cout << x; 
40. i nt 
X = 1 ; 
whil e (x < 10) 
x++; 
cout << x; 
41. for 
(in t coun t
= 1; cou nt
<= 10; cou nt ++) 
{ cout << ++count << • 
•; 
I I This 
is a bad thing 
to do! 
} 
42. for 
(i nt row= 
1; row<= 
3; row++) 
{ cout << • \ n$ • ; 
} 
for 
(i nt di git
= 1; di git
<= 4; digit++) 
cout << '9'; 
Find the Errors 
43. Each of the program segments in this section has errors . Find as many as you can. 
A) 
int 
num1 = 0, num2 = 10, resul t ; 
num1++; 
resul t
= ++(num1 + num2); 
cout 
<< num1 <<" 
"<< 
num2 <<""<<result; 
B) II Thi s code should 
add two user-entered 
numbers. 
i nt num1, num2; 
char aga i n; 
while 
( (again 
== 'y') 
11 (again 
== 'Y')) 
cou t << "Enter 
two numbers: .. 
' 
cin 
>> num1 >> num2; 
cou t << "Their 
sum is << (num1 + num2) << endl; 
cou t << "Do you want to do th is aga i n? .. 
' 
cin 
>> aga i n; 

Review Questions and Exercises 
315 
44. A) // This code should use a loop to raise 
a number to a power . 
int num, bigNum, power, count ; 
cout << "Enter an integer: 
"· 
cin 
>> num; 
cout << "What power do you want it raised 
to?"
· 
cin 
>> power; 
bigNum = num; 
while 
(count++< 
power); 
bigNum *= num; 
cout << "The result 
is<< 
bigNum << endl ; 
B) / / This code should average 
a set of numbers. 
int numCount, total
; 
double average ; 
cout << "How many numbers do you want to average?
"· 
cin 
>> numCount; 
for (int 
count= 
O; count< 
numCount; count++ ) 
{ 
} 
int num; 
cout << "Enter a number: "· 
cin 
>> num; 
total+= 
num; 
count++ ; 
average= 
total 
I numCount; 
cout << "The average 
is<< 
average<< 
endl ; 
45. A) / / This code should display 
the sum of two numbers. 
int choice , num1, num2; 
do 
{ 
cout << "Enter a number: ". 
' 
cin 
>> num1; 
cout << "Enter another 
number: " . 
cin 
>> num2; 
cout << "Their sum is • << (num1 + num2) << endl ; 
cout << "Do you want to do this 
again? \ n"; 
cout << • 1 = yes, 0 = no\ n"; 
cin 
>> choice; 
} while 
(choice 
= 1 ) 
B) // This code should display 
the sum of the numbers 1 -
100. 
int count= 
1, total; 
while 
(count<= 
100) 
total+= 
count; 
cout << "The sum of the numbers 1 -
100 is"· 
cout << total 
<< endl ; 

316 
Chapte r 5 
Looping 
Soft Skills 
Programmers need to be able to analyze what is wrong with a faulty algorithm and be 
able to explain the problem to others . 
46. Write a clear problem description for a simple program and create a pseudocode 
solution for it. The pseudocode should incorporate the logic, including all the 
calculations, needed in the program, but should purposely contain a subtle logic 
error. Then pair up with another student in the class who has done the same thing 
and swap your work. Each of you should trace the logic to find the error in the 
pseudocode you are given, then clearly explain to your partner what the problem 
is, why the "code" will not work as written, and what should be done to correct it. 
As an alternative, your instructor may wish to provide you with a problem description 
and an incorrect pseudocode solution . Again, the goal is not only for you to find the 
error, but also to clearly explain what the problem is, why the "code" will not work as 
written, and what should be done to correct it. 
Programming 
Challenges 
1. Characters for the ASCII Codes 
Write a program that uses a loop to display the characters for each ASCII code 32 
through 127. Display 16 characters on each line with one space between characters. 
2. Sum of Numbers 
Write a program that asks the user for a positive integer value and that uses a loop to 
validate the input. The program should then use a second loop to compute the sum of 
all the integers from 1 up to the number entered . For example, if the user enters 50, the 
loop will find the sum of 1, 2, 3, 4, ... 50. 
3. Distance Traveled 
The distance a vehicle travels can be calculated as follows: 
distance= 
speed* 
time 
For example, if a train travels 40 miles per hour for 3 hours, the distance traveled is 
120 miles. 
Write a program that asks the user for the speed of a vehicle (in miles per hour) and 
how many hours it has traveled. It should then use a loop to display the total distance 
traveled at the end of each hour of that time period . Here is an example of the output: 
What is the speed of the vehicle 
i n mph? 40 
How many hours has it t raveled? 
3 
Hour 
Miles Traveled 
1 
2 
3 
40 
80 
120 

a 
VideoNote 
Solving the 
Ocean Levels 
Problem 
Programming Challenges 
3 17 
4. Celsius to Fahrenheit Table 
In one of the Chapte r 3 Programming Challenges you were asked to write a program 
that converts a Celsius temperature to Fahrenheit. Modify that program so it uses a 
loop to display a table of the Celsius temperatures from O to 30 and their Fahrenheit 
equivalents. 
F = 9!5C + 32 
5. Speed Conversion Chart 
Write a program that displays a table of speeds in kilometers per hour with their 
values conver ted to miles per hour. The table should display th e speeds from 
40 kilometers per hour through 120 kilometers per hour, in increments of 10 
kilometers per hour. (In other words, it should display 40 kph, 50 kph, 60 kph and 
so forth, up thr ough 120 kph .) 
MPH= KPH "0.6214 
6. Ocean Levels 
Assuming the level of the Earth's oceans contin ues rising at about 3.1 millimeters per 
year, write a program that displays a table showing the total number of millimeters the 
oceans will have risen each year for the next 25 years. 
7. Circle Areas 
The formula to compute the area of a circle is 
area = PI '' radius 2 
so if a circle's radius doubles (i.e., is multiplied by 2), the circle's area will be four times 
as large as before. Write a program that creates a table showing the radius and area for 
a circle whose radius begins with 1 and continues doubling until it is 8. Use 3.14 for Pl. 
8. Pennies for Pay 
Write a program that calculates how much a person earns in a month if the salary is 
one penny the first day, two pennies the second day, four pennies the third day, and so 
on with the daily pay doubling each day the employee works . The program should ask 
the user for the number of days the employee worked during the month, validate that 
it is between 1 and 31, and then display a table showing how much the salary was for 
each day worked, as well as the total pay earned for the month . The output should be 
displayed in dollars with two decimal points, not in pennies. 
9. Weight Loss 
If moderate ly active persons cut their calorie intake by 500 calories a day, they can 
typically lose about 4 pounds a month. Write a program that has the users enter their 
starting weight and then creates and displays a tabl e showing what their expected 
weight will be at the end of each month for the next 6 months if they stay on this diet. 

318 
Chapte r 5 
Looping 
10. Calories Burned 
Running on a particu lar treadmill, you burn 3.9 calories per minute. Write a program 
that uses a loop to display the number of calories burned after 5, 10, 15, 20, 25, and 
30 minutes. 
11. Membership 
Fees Increase 
A country club, which curren tly charges $3,000 per year for membership, has 
announced it will increase its membership fee by 3 percent each year for the next five 
years. Write a program that uses a loop to display the projected rates for the next 
five years. 
12. Random Number Guessing Game 
Write a program that generates a random number between 1 and 100 and asks the 
user to guess what the number is. If the user's guess is higher than the random 
number, the program shou ld display "Too high. Try again ." If the user's guess is 
lower than the random number, the program should display "Too low. Try again ." 
The program should use a loop that repeats until the user correctly guesses the 
random number. Then the program should display "Congratulations. 
You figured 
out my number." 
13. Random Number Guessing Game Enhancement 
Enhance the program that you wrote for Programming Challenge 12 so it keeps a 
count of the number of guesses the user makes. When the user correctly guesses the 
random number, the program should display the number of guesses along with the 
message of congratulations . 
14. The Greatest and Least of These 
Write a program with a loop that lets the user enter a series of integers, followed 
by -99 to signal the end of the series. After all the numbers have been entered, the 
program should display the largest and smallest numbers entered . 
15. Student Line -Up 
A teacher has asked all her students to line up single file according to their first name. 
For example, in one class Amy will be at the front of the line and Yolanda will be at the 
end. Write a program that prompts the user to enter a number between 1 and 20 for 
the number of students in the class and then loops to read in that many names. Once 
all the names have been read in, it reports which student would be at the front of the 
line and which one would be at the end of the line. You may assume that no two 
students have the same name. 

Programming Challenges 
319 
16. Rate of Inflation 
The annua l rate of inflation is the rate at which money loses its value. For example, 
if the annual rate of inflation is 3.0 percent, then in one year it will cost $1,030 to buy 
the goods that could have been purchased for $1,000 today . Put another way, a year 
from now $1,000 will only buy 1/1.03 " $1,000, or $970 .87, worth of goods. Two 
years from now, $1,000 will only buy only 1/1.03 of $970.87, or $942.59 worth of 
goods . Write a program that allows the user to enter an annual rate of inflation between 
1 percent and 10 percent, and which then displays a table showing how much $1,000 
today will be worth each year for the next 10 years. 
17. Population 
Write a program that will predict the size of a population of organisms . The program 
should ask the user for the starting number of organisms, their average daily population 
increase (as a percentage of current population), and the number of days they will 
multiply. A loop should display the size of the population for each day. 
Input Validation: The program should not accept a number less than 2 for the 
starting size of the population, a negative number for average daily population 
increase, or a number less than 1 for the number of days they will multiply . 
18. Math Tutor Version 3 
This program started in Chapter 3 and was modified in Chapter 4. Starting with the 
version described in Chapter 4, modify the program again so that it displays a menu 
allowing the user to select an addition, subtraction, or multiplication problem. The 
final selection on the menu should let the user quit the program. After the user has 
finished the math problem, the program should display the menu again. This process 
must repeat until the user chooses to quit the program. If the user selects an item not on 
the menu, the program should print an error message and then display the menu again. 
19. Hotel Suites Occupancy 
Write a program that calculates the occupancy rate of the 120 suites (20 per floor) 
located on the top six floors of a 15-story luxury hotel. The se are floors 10- 12 and 
14- 16 because, like many hotels , there is no 13th floor. Solve the prob lem by using 
a single loop that iterates once for each floor between 10 and 16 and, on each 
iteration, asks the user to input the number of suites occupied on that floor. Use a 
nested loop to validate that the value entered is between O and 20. After all the 
iterations, the program should display how many suites the hotel has, how many of 
them are occupied, and what percentage of them are occupied . 

32 0 
Chapte r 5 
Loop ing 
20. Rectangle Display 
Write a program that asks the user for two positive integers between 2 and 10 to use 
for the length and width of a rectangle. If the numbers are different, the larger of the 
two numbers should be used for the length and the smaller for the width . The program 
should then display a rectangle of this size on the screen using the character 'X'. For 
examp le, if the user enters either 2 5 or 5 2, the program should display the following: 
xxxxx 
xxxxx 
21. Diamond Display 
Write a program that uses nested loops to display the diamond pattern shown below. 
+ 
+++ 
+++++ 
+++++++ 
+++++ 
+++ 
+ 
22. Triangle Display 
Write a program that uses nested loops to display the triangle patte rn shown below. 
+ 
+++ 
+++++ 
+++++++ 
+++++ 
+++ 
+ 
23. Arrowhead Display 
Write a program that uses nested loops to display the arrowhead pattern shown below. 
+ 
+++ 
+++++ 
+++++++++++++ 
+++++ 
+++ 
+ 
24. Sales Bar Chart 
Write a program that asks the user to enter today's sales rounded to the nearest $100 
for each of three stores. The program should then produce a bar graph displaying each 
store's sales. Create each bar in the graph by displaying a row of asterisks. Each asterisk 
should represent $100 of sales. 

Programming Challenges 
32 1 
Here is an example of the program's output . User input is shown in bold. 
Ent er t oday's 
sales 
for 
store 
1: lOOO[Enter] 
Ent er t oday's 
sales 
for 
store 
2: 
1200[Enter] 
Ent er t oday's 
sales 
for 
store 
3: 900[Enter] 
DAILY SALES 
(each*= 
$100) 
Store 
1: ********** 
Store 
2: 
************ 
Store 
3: 
********* 
25. Savings Account Balance 
Write a program that calculates the balance of a savings account at the end of a three-month 
period. It should ask the user for the starting balance and the annual interest rate. A loop 
should then iterate once for every month in the period, performing the following steps: 
A) Ask the user for the total amount deposited into the account during that 
month and add it to the balance. Do not accept negative numbers . 
B) 
Ask the user for the tota l amount withdrawn from the account during that 
month and subtract it from the balance. Do not accept negative numbers 
or numbers greater than the balance after the deposits for the month have 
been added in. 
C) 
Calculate the interest for that month. The monthly interest rate is the 
annua l interest rate divided by 12. Multiply the month ly interest rate by 
the average of that month's starting and ending balance to get the interest 
amount for the month. This amount should be added to the balance. 
After the last iteration , the program should display a nicely formatted report that 
includes the following information: 
• Starting balance at the beginning of the three-month period 
• Total deposits made during the three months 
• Total withdrawals made during the three months 
• Total interest posted to the account during the three months 
• Final balance 
26. Using Files-Total 
and Average Rainfall 
Write a program that reads in from a file a starting month name, an ending month 
name, and then the monthly rainfall for each month during that period. As it does this, 
it should sum the rainfall amounts and then report the tota l rainfa ll and average rainfall 
for the period. For example, the output might look like this: 
During the months of March-June, the tota l rainfall was 7.32 inches and the average 
monthly rainfall was 1.83 inches. 
Data for the program can be found in the Rainfall. 
tx t file located in the Chapter 5 
programs folder on the book's companion website. 
Hint: After reading in the month names, you will need to read in rain amounts until the 
EOF is reached and count how many pieces of rain data you read in. 

32 2 
Chapte r 5 
Looping 
27. Using Files- Population Bar Chart 
Write a program that produces a bar chart showing the population growth of 
Prairieville, a small town in the Midwest, at 20-year intervals during the past 
100 years. The program should read in the population figures (rounded to the nearest 
1,000 people) for 1910, 1930, 1950, 1970, 1990, and 2010 from a file. For each year 
it should display the date and a bar consisting of one asterisk for each 1,000 people. 
The data can be found in the People. t xt file located in the Chapter 5 programs folder 
on the book's companion website. 
Here is an example of how the chart might begin: 
PRAIRIEVILLE POPULA
TION GROWTH 
(each* 
represents 
1000 people) 
1910 
1930 
1950 
** 
**** 
***** 
28. Using Files-Student 
Line Up 
Modify the Student Line-Up program described in Programming Challenge 15 so that 
it gets the names from a data file. Names should be read in until there is no more data 
to read. Data to test your program can be found in the Li neUp. txt file located in the 
Chapter 5 programs folder on the book's companion website. 
29. Using Files-Savings 
Account Balance Modification 
Modify the Savings Account Balance program described in Programming Challenge 25 
so that it writes the report to a file. After the program runs, print the file to hand in to 
your instructor. 

TOPICS 
6.1 
6.2 
6.3 
6.4 
6.S 
6.6 
6.7 
6.8 
6.9 
6.10 
6.1 
Modular Programming 
6.11 Static Local Variables 
Defining and Calling Functions 
6.12 Default Arguments 
Function Prototypes 
6.13 Using Reference Variables as 
Sending Data into a Function 
Paramete rs 
Passing Data by Value 
6.14 Overloading Functions 
The retur
n Statement 
6.15 The exit () Function 
Returning a Value from a Function 
6.16 Stubs and Drivers 
Returning a Boolean Value 
6.17 Little Lotto Case Study 
Using Functions in a Menu-Driven Program 
6.18 Tying It All Togethe r: Glowing 
Local and Global Variables 
Jack-o-lantern 
Modular Programming 
CONCEPT: 
A program may be broken up into a set of manageable functions, or 
modul es. Thi s is called modular programming. 
A function is a collection of statements that performs a specific task. So far you have used 
functions in two ways: (1) you have created a function called mai n in every program you've 
written, and (2) you have called library functions such as pow and sqr t. In this chapter you 
will learn how to create your own functions that can be used like library functions. 
Functions are commonly used to break a problem down into small, manageab le pieces, 
or modu les. Instead of writing one long funct ion that contains all the statements 
necessary to solve a problem , several smaller functions can be written, with each one 
solving a specific part of the problem. These small functions can then be executed in the 
desired order to solve the problem. This approach is sometimes called divid e and conquer 
because a large prob lem is divided into several smaller problems that are more easily 
solved. Figure 6-1 illustrates this idea by comparing two programs, one that uses a single 
module containing all of the statements necessary to solve a problem, and another that 
divides a problem into a set of smaller problems, each handled by a separate function . 
323 

324 
Chapte r 6 
Functions 
Figure 6-1 
This program has one long, complex 
function containing all of the statements 
necessary to solve a problem. 
In this program the problem has been 
divided into smaller problems , each 
handled by a separate function. 
int 
{ 
} 
6.2 
a 
VideoNot e 
Defining and 
Calling 
Functions 
! 
! 
main() 
int main() 
{ 
statement
; 
statement
; 
statement
; 
statement
; 
main function 
statement
; 
statement
; 
statement
; 
} 
statement
; 
statement
; 
void function2
() 
statement
; 
{ 
statement
; 
statement
; 
statement
; 
statement
; 
function 2 
statement
; 
statement
; 
statement
; 
} 
statement
; 
statement
; 
void function3() 
statement
; 
{ 
statement
; 
statement
; 
statement
; 
statement
; 
function 3 
statement
; 
statement
; 
statement
; 
} 
Another reason to write functions is that they simplify programs. If a specific task is 
performed in several places in a program, a function can be written once to perform 
that task and then be executed anytime it is needed. This benefit of using functions is 
known as code reuse because you are writing the code to perform a task once and then 
reusing it each time you need to perform the task . 
Defining and Calling Functions 
CONCEPT
: A function call is a statement that causes a function to execute. A 
function definition contains the statements that make up the function. 
When creating a function, you must write its definition . All function definitions have 
the following parts: 
Name 
Parameter list 
Body 
Every function must have a name. In general, the same rules that 
apply to variable names also apply to function names . 
The program module that calls a function can send data to it. The 
parameter list is the list of variables that hold the values being passed 
to the function . It is enclosed in parentheses . If no values are being 
passed to the function, its parameter list is empty . 
The body of a function is the set of statements that carries out the task 
the function is performing . These statements are enclosed in braces. 

Figure 6-2 
6.2 Defining and Calling Functions 
325 
Return type 
A function can send a value back to the program module that called 
it. The return type is the data type of the value being sent back. 
Figure 6-2 shows the definition of a simple function with the various parts labeled. 
Return type 
~ 
i nt 
{ 
} 
Parameter list (This one is empty) 
N;e 
//Bod
y 
main () 
cout << "Hello World\n"; 
return O; 
The first line in the definition is called the function header. Let's take a closer look at 
its three parts. First comes the function's return type. Then comes its name. The header 
ends with a set of parentheses . If the function has any parameter s, they will be listed 
inside these parentheses. However, the parentheses must be included even if the 
parameter list is empty, as shown in Figure 6-2. 
Void Functions 
You already know that a function can return a value. The mai n function in all of the 
programs you have seen in this book is declared to return an i nt value to the operating 
system . The return 
O; statement causes the value O to be returned when the main 
function finishes executing . 
It isn't necessary for all functions to return a value, however. Some functions simply 
perform one or more statements and then return. In C++ these are called void functions. 
The di sp 1 ayMessage function shown here is an example: 
voi d di splayMessage() 
{ 
cout << "Hello from the functio n displayMessage.\n"; 
) 
The function's name is di splayMessage . This name is descriptive, as function names 
should be. It gives an indication of what the function does. It displays a message. Because 
the function does not need to receive any information to carry out its job, it has no 
parameters listed inside the parentheses. The function's return type is void. This means 
the function does not send back a value when it has finished executing and returns to 
the part of the program that called it. Because no value is being sent back, no re t urn 
statement is required . When the statements in the function have finished executing and 
the right brace that ends the function is encountered, the program automatically returns. 
Calling a Function 
A function is executed when it is called. Function main is called automatically when a 
program starts, but all other functions must be executed by function call statements. When 
a function is called, the program branches to that function and executes the statements in 
its body. Let's look at Program 6-1, which contains two functions: main and di sp 1 ayMessage. 

326 
Chapte r 6 
Functions 
Program 6-1 
1 II Thi s program has two functions
, main and displayMessage. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototype 
6 void displayMessage()
; 
7 
8 /*************************************** 
9 
* 
main 
* 
10 
***************************************/ 
11 int main() 
12 { 
13 
cout << "Hello from main . \n"; 
14 
displayMessage(); 
II Call displayMessage 
15 
cout << "Now we are back in the main function 
again.\n"; 
16 
return 
O; 
17 } 
18 
19 /*************************************** 
20 
21 
22 
* 
displayMessage 
* 
* 
This function 
displays 
a greeting. 
* 
***************************************/ 
23 void displayMessage
() 
24 { 
25 
cout << "Hello from the displayMessage 
function.\n"; 
26
} 
Program Output 
Hello from main. 
Hello from the displayMessage 
function. 
Now we are back in the main function 
again. 
As all C++ programs do, the program starts exec uting in main. Other functions are 
executed on ly when they are called . In Program 6-1, the displayMessage 
function is 
called by the following statement in line 14 of main. 
displayMessage
(); 
Notice the form of the function call. It is simply the name of the function followed by 
a set of parentheses and a semicolon. Let's compare this with the function header: 
Function Header 
Function Call 
voi d displayMessage(} 
displayMessage
(); 
Th e function header is part of the function definition. It declares the function's return 
type, name, and parameter list. It must not be terminated with a semicolon because the 
definition of the function's body follows it. 
Th e function call is a statement that executes the function, so it is terminated with a 
semicolon like all othe r C++ statements . Notice that the function call does not include 
the return type. 

6.2 Defining and Calling Functions 
32 7 
You may be wondering what the statement on line 6 of Program 6-1 does. It is called a 
function prototype, and its job is simply to let the compiler know about a function that 
will appear later in the program. Notice that it looks just like the function header 
except that it is a statement, so it ends with a semicolon. In the next section you will 
learn more about function prototype s. 
Now let's examine how Program 6-1 flows. It starts, of course, in function main. When 
the call to di sp l ayMessage is encount ered, the program branche s to that function and 
perform s its statements. Once di sp l ayMessage has finished executing , the program 
branches back to function main and resume s with the line that follows the function 
call. This is illustrated in Figure 6-3. 
Figure 6-3 
int main() 
{ 
cout « "Hello from main. In"; 
disp layttessage() ; 
-
cout « "Now we are back in t he funct ion again . In"; 
retur n O; 
1 
2 
} 
void displayHessage() 
{ 
cout « "Hello from t he functio n disp layHessage.ln"; 
} 
Function call statements may be used in control structures such as loops, i f statements , and 
switch statements. Program 6-2 places the di spl ayMessage function call inside a loop. 
Program 6-2 
1 II Thi s program calls 
the displayMessage 
function 
from within 
a loop . 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototype 
6 void displayMessage
(); 
7 
8 /*************************************** 
9 
* 
main 
* 
10 
***************************************/ 
11 int main() 
12 { 
13 
cout << "Hello from main . \n\n"; 
14 
15 
16 
17 
for(int 
count= 
O; count 
{ displayMessage(); 
} 
< 3; count ++) 
II Call di splayMessage 
18 
cout << "\nNow we are back in the mai n function 
aga i n.In"; 
19 
return 
O; 
20
} 
21 
(program continues) 

328 
Chapte r 6 
Functions 
Program 6-2 
(continued) 
22 /*************************************** 
* 
displayMessage 
* 
23 
24 
25 
26 
27 
28 
29
} 
* 
This function 
displays 
a greeting. 
* 
***************************************/ 
void displayMessage
() 
{ 
cout << "Hello from the displayMessage 
function.\n"; 
Program Output 
Hello from main. 
Hello from the displayMessage 
Hello from the displayMessage 
Hello from the displayMessage 
function. 
function. 
function. 
Now we are back in the main function 
again. 
It is possible to have many functions and function calls in a program. Program 6-3 has 
three functions: main, first, 
and second . 
Program 6-3 
1 II Thi s program has three 
functions: 
mai n, first, 
and second. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototypes 
6 void first
(); 
7 void second(}; 
8 
9 /*************************************** 
10 
* 
main 
* 
11 
***************************************/ 
12 int main() 
13 { 
14 
cout << "I am start
i ng i n function 
main . \n"; 
15 
first(); 
II Call function 
first 
16 
second( ); 
II Call function 
second 
17 
cout << "Now I am back in function 
main again. \n"; 
18 
return 
O; 
19 } 
20 
21 
22 
/*************************************** 
* 
first 
* 
23 
* Thi s funct i on di splays 
a message. 
* 
24 
***************************************/ 
25 void first
() 
26 { 
27 
cout << "I am now ins i de the funct i on first
. \n"; 
28
} 
(program continues) 

6.2 Defining and Calling Functions 
329 
Program 6-3 
29 
(continued) 
30 / ****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * 
31 
* 
second 
• 
32 
* Thi s func ti on di splays 
a message. 
• 
33 
****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * */ 
34 void second( ) 
35 { 
36 
cout 
<< "I am now ins i de the funct i on second. \ n" ; 
37
) 
Program Output 
I am st art i ng i n function 
main. 
I am now ins i de the funct i on first. 
I am now ins i de the funct i on second. 
Now I am bac k i n function 
main again. 
In lines 15 and 16 of Program 6-3, function mai n contain s a call to f i rs t and a ca ll to 
second: 
Figure 6-4 
first
() ; 
second( ); 
Each call stat ement causes the program to bran ch to a function and then back to mai n 
when the function is finished. Figure 6-4 illustrates th e path s taken by the program. 
int main() 
{ 
cout << "I am starting in funct ion main.In"; 
first () ; 
. 
second(); 
cout << "Now I am Back in funct ion main again.In"; --
return 0; 
1 
2 
} 
void first () 
3 
{ 
4 
cout << "I am now inside the function first . In"; 
} 
void second() 
--
{ 
cout << "I am now inside the funct ion second.In"; 
} 

330 
Chap ter 6 
Functions 
Functions may also be called in a hierar chical, or layered, fashion. Thi s is demonstrated 
by Program 6-4, which has thr ee functions: mai n, deep , and deeper. 
Program6-4 
1 II This program has three 
functions: 
main , deep , and deeper . 
2 #include 
<iostream> 
3 us i ng namespace std ; 
4 
5 II Function 
prototypes 
6 voi d deep () ; 
7 voi d deeper (); 
8 
9 / * * * * * * ******
* * * * * * * * * ******
* * * * * * * ***** 
10 
* 
mai n 
* 
11 
* * * * * * ******
* * * * * * * * * ******
* * * * * * * *****
/ 
12 i nt mai n () 
13 { 
cout << 
deep (); 
"I am starting 
I I Call 
14 
15 
16 
17 
18 } 
19 
cout << "Now I am back 
return 
O; 
in function 
main .\ n" ; 
f unction 
deep 
in function 
main again . \ n" ; 
20 / * * * * * * ******
* * * * * * * * * ******
* * * * * * * ***** 
21 
* 
deep 
* 
22 
* This funct i on displays 
a message . 
* 
23 
* * * * * * ******
* * * * * * * * * ******
* * * * * * * *****
/ 
24 voi d deep () 
25 { 
26 
cout << "I am now i nside the function 
deep. \ n"; 
27 
deeper (); 
II Cal l f unction 
deeper 
28 
cout << "Now I am back in deep . \ n" ; 
29
} 
30 
31 
32 
/ * * * * * * ******
* * * * * * * * * ******
* * * * * * * ***** 
* 
deeper 
* 
33 
* This funct i on displays 
a message . 
* 
34 
* * * * * * ******
* * * * * * * * * ******
* * * * * * * *****
/ 
35 voi d deeper () 
36 { 
37 
cout << "I am now i nside the function 
deeper.
\ n"; 
38
} 
Program Output 
I am starting 
in function 
main. 
I am now inside 
the function 
deep. 
I am now inside 
the function 
deeper. 
Now I am back in deep. 
Now I am back in function 
main again. 

Figure 6-5 
6.2 Defining and Calling Functions 
331 
In Program 6-4, funct ion mai n only calls the function deep. In turn , deep calls de eper . 
T he paths taken by this program are shown in Figure 6-5 . 
int main() 
{ 
cout << "I am starting 
in function main. In"; 
deep(); 
cout << "Now I am back in function main again.In "; . -
return O; 
1 
} 
-
void deep() 
4 
~ 
{ 
cout << "I am now inside the function deep. In"; 
deeper() ; 
cout << "Now I am back in deep. In"; 
. 
-
2 
} 
- void deeper() 
3 
-
{ 
cout << "I am now inside the function deeper. In"; 
} 
~ 
Checkpoint 
Use the following information to answer que stions 6.1- 6.6. Line number s within each 
funct ion have been included for reference . 
A program includes the following function. 
1 void pr i nt Head ing() 
2 { 
3 
cout << "The Hi story of Computers 
In"; 
4 ) 
T he program 's mai n function includes the following code segment . 
12 fo r 
13 { 
14 
15} 
(i nt count = O; cou nt < 3; cou nt+ +) 
pr i nt Head ing ( ); 
cout << "I ca l led pri nt Headi ng In"; 
6.1 
Does line 1 contain a funct ion header or a funct ion call? 
6.2 
Does line 13 contain a function header or a function call? 
6.3 
How many times is the pr i nt Headi ng function called? 
6.4 
Which line number has code that causes the program to leave the pri ntHea di ng 
function and return to mai n? 
6.5 
When the program returns to main , which line' s code is executed next? 
6.6 
What will be displayed when lines 12- 15 of mai n are executed? 

33 2 
Chapter 6 
Functions 
Function Prototypes 
CONCEPT: 
A function prototype eliminates the need to place a function definitio n 
before all calls to the function. 
Before the compiler encounters a call to a particular function, it must already know certain 
things about the function. In particular, it must know the number of parameters the function 
uses, the data type of each parameter, and the return type of the function. This is normally 
done by including a function prototype for each function in the program except for main. 
A prototype is never needed for mai n because it is the starting point of the program. 
The functions you have seen in this chapter so far did not receive any information from 
the function that called them, so they had no parameters. And except for mai n, they did 
not return any information, so their return type was void. Let's take a closer look at 
the prototype for the di spl ayMessage function in Program 6-1: 
void displayMessage
(); 
This prototype looks similar to the function header, except there is a semicolon at the 
end . Th e statement tells the compiler that the function di sp l ayMessage uses no 
parameters and has a void return type, meaning it doesn't return a value. 
Notice that the prototype for the di sp l ayMessage function in Program 6-1 was placed 
above the main function. Without its prototype there to provide the needed information 
for the compi ler, the entire di spl ayMessage function definition would have to come 
before the main function in order to be called . Program 6-5 revises Program 6-1 to 
show how it would need to be reorganized if it didn't have a function prototype. 
Program 6-5 
1 II Thi s program has two functions
, main and displayMessage. 
2 II There i s no prototype 
for displayMessage, 
so i t must be 
3 II placed before the main function 
i n order to be called. 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 /*************************************** 
* 
displayMessage 
* 
8 
9 
* 
This function 
displays 
a greeting. 
* 
10 
***************************************/ 
11 void displayMessage
() 
12 { 
13 
cout << "Hello from the displayMessage 
function.\n"; 
14 } 
15 
16 /*************************************** 
17 
* 
main 
* 
18 
***************************************/ 
(program continues) 

6.4 Sending Data into a Function 
333 
Program 6-5 
(continued) 
19 int main() 
20 { 
21 
cout << "Hello from mai n. \n"; 
22 
displayMessage(); 
// Call displayMessage 
23 
cout << "Now we are back in t he mai n func t ion agai n.\ n"; 
24 
return O; 
25
} 
Program Output Is the same as the output of Program 6-1. 
CD 
6.4 
a 
VideoNot e 
Using Function 
Arguments 
Some programmers prefer to use this organizat ion and place the main function last. 
However, most programmers find it easier to use a prototype for each function except 
main and to place mai n first. This is particularly helpful when a program has many 
functions that call other functions. Consider how Program 6-4, with the three functions 
main, deep, and deeper, would have to be organized if it had no function prototypes . 
• Function deeper would have to be placed first so that deep could call it. 
• Function deep would have to be placed second so that mai n could call it. 
• The main function would have to be placed last. 
When function prototypes are used, the actua l function definitions can be placed in any 
order you wish. Just place the prototypes at the top of the program, right after the usi ng 
namespace st d statement, as we did in Programs 6-1 through 6-4. This will ensure that 
they come before mai n or any other functions . 
WARNING! 
You must either place the function definition or the function 
prototype ahead of all calls to the function . Otherwise the program will not compile . 
Sending Data into a Function 
CONCEPT: 
When a function is called, the program may send values into the 
function. 
Values that are sent into a function are called arguments . You're already familiar with 
how to use arguments in a function call. In the following statement the function pow is 
being called with two arguments, 2.0 and 3.0, passed to it: 
resul t = pow(2.0, 3.0); 
The pow function uses the information passed to it to comp ute the value of the first 
argument raised to the power of the second argument . In this case, it will compute the 
value of 2.0 to the third power and return the value 8.0 to be stored in result. 
A parameter is a special variable that holds a value being passed as an argument into 
a function . By using parameters, you can design your own functions that accept data 
this way. 

334 
Chapte r 6 
Functions 
Here is the definition of a function that has a parameter. The parameter is num. 
void displayValue(
i nt num) 
{ 
cout << "The value i s•<< 
num << endl; 
) 
Notice that the parameter variable is defined inside the parentheses (in t num). Because 
it is declared to be an integer, the function di spl ayVal ue can accept an integer value as 
an argument. Program 6-6 is a complete program that uses this function . 
Program6-6 
1 II This program demonstrates 
a function 
wit h a parameter. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 II Function 
prototype 
6 void displayValue(
i nt num); 
7 
8 int main() 
9 { 
10 
cout << "I am passing 
5 to displayValue
. \n"; 
11 
displayValue(5); 
II Call displayValue 
with argument 5 
12 
cout << "Now I am back in main. \ n" ; 
13 
return 
O; 
14 ) 
15 
16 /******************************************** 
* 
displayValue 
* 
17 
18 
19 
* 
* 
This function 
uses an i nteger 
parameter* 
whose value is di splayed. 
* 
20 
********************************************/ 
21 void displayValue(int 
num) 
22 { 
23 
cout << "The value i s"<< 
num << endl; 
24
) 
Program Output 
I am passing 
5 to displayValue. 
The value is 5 
Now I am back in main. 
Notice the function prototype for displayValue 
in line 6: 
voi d di splayValue(int 
num); 
II Function 
prototype 
It lists both the data type and the name of the function's parameter variable . However, 
it is not actually necessary to list the name of the parameter variable inside the 
parentheses . Only the data type of the variable is required. The function prototype 
could have been written like this: 
voi d di splayValue(int); 
II Function 
prototype 

6.4 Sending Data into a Function 
335 
Because some instructors prefer that you list only the data type for each parameter in a 
function prototype, while others prefer that you list both the data type and name, we use 
both versions throughout this book. Your instructor will tell you which version to use. 
0 
NOTE: 
Your instructor will also tell you what to call the function parameters. In this 
text, the values that are passed into a function are called arguments, and the variables 
that receive those values are called parameters. However, there are several variations of 
these terms in use. Some call the arguments actual parameters and the parameters 
formal parameters . Others use the terms actual arguments and formal arguments . 
Regardless of which set of terms you use, it is important to be consistent. 
In Program 6-6 the di spl ayVa l ue function is called in line 11 of main with the argument 
5 inside the parentheses. The number 5 is passed into num, which is di sp l ayVa l ue' s 
parameter. This is illustrated in Figure 6-6. 
Figure 6-6 
displayValue(S); 
void displayValue(int 
num) 
{ 
II Function call 
II Function header 
cout << "The value is • << num << endl; 
} 
Any argument listed inside the parentheses of a function call is copied into the function's 
parameter variable. In essence, parameter variables are initialized to the value of the 
corresponding arguments passed to them when the function is called. Program 6-7 shows 
the function di splayValue being called several times with a different argument passed 
each time. 
Program 6-7 
1 II Thi s program demonstrates 
a function 
with a parameter. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototype 
6 void displayValue
(i nt num); 
7 
8 int main() 
9 { 
10 
11 
12 
13 
14 
15 
cout << "I am passing 
several 
values to displayValue
. \n"; 
displayValue(5); 
II Call di splayValue 
wi th argument 
displayValue(10); 
II Call di splayValue 
wi th argument 
displayValue(2); 
II Call di splayValue 
with argument 
displayValue(16); 
II Call di splayValue 
with argument 
cout << "Now I am back in main. \n"; 
16 
return 
O; 
17 ) 
5 
10 
2 
16 
(program continues) 

336 
Chapter 6 
Functions 
Program 6-7 
18 
(continued) 
19 /******************************************** 
20 
21 
22 
* 
* 
* 
displayValue 
* 
This function 
uses an i nteger 
parameter* 
whose value is di splayed. 
* 
23 
********************************************/ 
24 void displayVal ue (int num) 
25 { 
26 
cout << "The value i s "<< num << endl; 
27 } 
Program Output 
I am passing several 
values to displayValue. 
The value is 5 
The value is 10 
The value is 2 
The value is 16 
Now I am back in main. 
In lines 11- 14 of Program 6-7 the di spl ayVal ue function is called four times, and each 
time num takes on a different value. Any express ion whose value could normally be 
assigned to num may be used as an argument . For example, the following function call 
would pass the value 8 into num: 
displayVal ue (3 + 5); 
When a function is called, it is best if each argument passed to it has the same data type 
as the parameter receiving it. However, it is possible to send an argument with a 
different data type. In this case, the argument will be promoted or demoted to match 
the data type of the parameter receiving it. Be very careful if you do this, as you may 
introduce a hard to find bug. For example, the di sp l ayVa l ue function in Program 6-7 
has an integer parameter, which means it expects to receive an integer value . If the 
function is called as shown here, 
displayVal ue (4.7); 
the argument will be truncated and the integer 4 will be stored in the paramete r num. 
Often it is useful to pass severa l arg um ents into a function . Program 6-8 includes 
a function that has three parameters . Notice how these parameters are defined in 
the function header in line 27, as well as in the function prototype in line 6. Notice 
also that the call to the function in line 18 must now send three arg uments to the 
function. 
showSum(value1, value2, 
value3); 

6.4 Sending Data into a Function 
337 
Program6
-8 
1 II Thi s program demonstrates 
a function 
with three 
parameters. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 II Function prototype 
6 void showSum(i nt num1, int num2, int num3); 
7 
8 int main() 
9 { 
10 
int value1, 
value2, 
value3; 
11 
12 
II Get 3 integers 
13 
cout << "Enter three i ntegers 
and I will display"· 
14 
cout << "their 
sum: "; 
15 
cin 
>> value1 >> value2 >> value3; 
16 
17 
II Call showSum, pass i ng 3 arguments 
18 
showSum(value1, value2, 
value3); 
19 
return 
O; 
20 } 
21 
22 /******************************************** 
23 
24 
25 
* 
* 
* 
showSum 
This function 
displays 
the sum of the 
3 integers 
passed into its parameters. 
* 
* 
* 
26 
********************************************/ 
27 void showSum(i nt num1, int num2, i nt num3) 
28 { 
29 
cout << "The sum i s"<< 
(num1 + num2 + num3) << endl; 
30 } 
Program Output with Example Input Shown in Bold 
Enter three integers 
and I will display 
their 
sum: 4 8 7[Enter] 
The sum is 19 
One important point to mention about Program 6-8 is how the showSum parameter 
variables are defined in its function header. 
voi d showSum(int num1, i nt num2, int num3} 
As you might expect, they are each preceded by their data type and they are separated 
by commas. However, unlike regular variable definitions, they cannot be combined 
into a single definition even if they all have the same data type. That is, even though all 
three parameter variables are integers, they cannot be defined like this: 
voi d showSum(int num1, num2, num3) 
II Error! 
Another point to notice is that whereas the function prototype and function header must 
list the data type of each parameter, the call to the function must not list any data types. 

338 
Chapter 6 
Figure 6-7 
Functions 
Each argument in the function call must be a value or something that can be evaluated to 
produce a value. If value1 , value2 , and value3 hold the values 4, 8, and 7 respectively, 
as they did in the sample run for Program 6-8, the following three function calls would 
all be legal and would cause the showSum function to display the same thing. 
showSum(value1 , value2, 
value3); 
showSum(4, 8 , 7); 
showSum(3+1, 16/2, 7); 
// Legal The sum is 19 
// Legal The sum is 19 
// Legal The sum is 19 
But the following function call would cause an error. 
showSum(i nt value1 , int value2, 
i nt value3); 
// Error! 
Figure 6-7 shows the difference in the syntax between the function call and the function 
header when variables are used as arguments. It also illustrates that when a function with 
multiple parameters is called, the arguments are passed to the parameters in order. 
FunctioncaU-.s
howSum(value1, value2, value3 ) 
void showSum(int num1, int num2, int num3) 
{ 
cout << num1 + num2 + num3 << endl; 
) 
The following function call will cause 4 to be passed into the num1 parameter , 8 to be 
passed into num2, and 7 to be passed into num3: 
showSum(4, 8 , 7); 
Note that although the names of the arguments passed to a function do not need to 
match the names of the function parameters receiving them, the arguments must match 
the parameters in number, in order, and in data type. 
Passing Data by Value 
CONCEPT: 
When an argument is passed into a parameter by value, only a copy of 
the argument's value is passed. Changes to the parameter do not affect 
the original argument. 
As you have seen in this chapte r, parameters are special -purp ose variables that are 
defined inside the parentheses of a function definition. Th eir purpose is to hold the 
information passed to them by the arguments, which are listed inside the parenthe ses 
of a function call. Normally when information is passed to a function it is passed by 
value. This means the parameter receives a copy of the value that is passed to it. If a 
parameter's value is changed inside a function, it has no effect on the original argument. 
Program 6-9 demonstrates this concept . 

6.5 Passing Data by Value 
339 
Program 6-9 also illustrates that when a function prototype lists variab le names along 
with data types, the names it uses are just dummy names . They are not actually used by 
the compiler and do not have to agree with the names used in the function header. Th e 
changeMe function prototype in line 7 and the changeMe function header in line 29 both 
specify that the function has one int parameter, but they use different names for it. 
Program6-9 
1 II Thi s program demonstrates 
that 
changes to a function 
2 II parameter 
have no effect 
on the or i gi nal argument. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
Prototype 
7 void changeMe(int 
aValue); 
8 
9 int main() 
10 { 
11 
int number= 
12; 
12 
13 
II Di splay the value i n number 
14 
cout << "In main number is"<< 
number<< endl ; 
15 
16 
II Call changeMe, passing 
the value i n number as an argument 
17 
changeMe(number ); 
18 
19 
II Display 
the value i n number again 
20 
cout << "Back in main again , number i s still 
"<<number<< 
endl; 
21 
return 
O; 
22 } 
23 
24 /************************************* 
25 
26 
27 
* 
* 
* 
changeMe 
This function 
changes the value 
stored 
i n its 
parameter 
myValue 
* 
* 
* 
28 
*************************************/ 
29 void changeMe(int 
myValue) 
30 { 
31 
II Change the value of myValue to 0 
32 
myValue = O; 
33 
34 
II Display 
the value i n myValue 
35 
cout << "In changeMe, the value has been changed to" 
36 
<< myValue << endl; 
37
} 
Program Output 
In main number is 12 
In changeMe, the value has been changed to 0 
Back in main again , number is still 
12 

340 
Chapter 6 
Figure 6-8 
Functions 
Even though the parameter variable my Value is changed in the changeMe function , the 
argument number is not modified . This occurs because the myVa l ue variable contains 
only a copy of the number variable. Just this copy is changed, not the origina l. The 
changeMe function does not have access to the original argument. 
Figure 6-8 illustrates that a parameter variable's storage location in memory is separate 
from that of the original argument. 
Origina l argument 
(in its 
memory location) 
12 
Function 
parameter 
(in its 
own memory location) 
12 
Late r in this chapter you will learn ways to give a function access to its origina l 
arguments . 
~ 
Checkpoint 
6. 7 
Indicate which of the following is the function prototype , the function header, 
and the function call: 
void showNum(double num) 
void showNum(double num); 
showNum(45.67 ); 
6.8 
A) Write the function header for a function named times Ten that has an integer 
parameter named number. The body of the function has been provided below. 
II You write 
the function 
header 
{ 
cout << "Ten t imes"<< 
number<<
" is
"<< (10 *number<< 
".\ n" ; 
} 
B) Write the function prototype for the t i mes Ten function. 
C) Write a statement that calls t imesTen, passing it the integer literal 5. 
D) Write a statement that calls ti mes Ten, passing it an integer variable named boxes. 

6.9 
What is the output of the following program? 
#include 
<iostream> 
us i ng namespace std; 
voi d func1(double, 
int ); // Function 
prototype 
i nt mai n() 
{ 
) 
int x = 0; 
double 
y = 1 . 5 ; 
cout << X << " 
func1 (y, x ); 
cout << X << " 
return o· ' 
" << y << endl ; 
" << y << endl ; 
voi d func1(double 
a, i nt b) 
{ 
) 
cout <<a<<" 
"<< b << endl ; 
a= 
0 .0; 
b = 10 ; 
cout <<a<<" 
"<< b << endl ; 
6.5 Passing Data by Value 
34 1 
6.10 
The following program skeleton asks for the number of hours you've worked 
and your hourly pay rate. It then calculates and displays your wages. The 
function showDo 11 ars, which you are to write, formats the output of the wages. 
#include 
<iostream> 
#include 
<iomanip> 
us i ng namespace std; 
voi d showDollars
(double pay); 
// Function 
prototype 
int mai n() 
{ 
) 
double payRate, 
hoursWorked, wages; 
cout << "How many hours have you 
cin 
>> hoursWorked; 
cout << "What is your hourly 
pay 
cin 
>> payRate; 
wages= 
hoursWorked * payRate; 
showDollars(wages); 
return 
O; 
worked? 
rate? 
". 
" 
// Write the definition 
of the showDollars 
function 
here . 
// It should have one double parameter 
and display 
the message 
II "Your wages are$" 
followed 
by the value of the parameter. 

342 
Chapte r 6 
Functions 
The return Statement 
CONCEPT
: The return statement causes a function to end immedia tely. 
When the last statement in a function has finished executing, the function terminates. 
Th e program returns to the module that called it and continues executing from the 
point immediately following the function call. It is possible, however, to force a function 
to return to where it was called from before its last statement has been executed. This 
can be done with the ret urn statement, as illustrated in Program 6-10. In this program, 
the function di vi de shows the quotient of arg1 divided by arg2. If arg2 is set to zero, 
however, the function returns to main without performing the division 
Program 6-10 
1 // Thi s program uses a function 
to perform division
. 
2 // It illustrates 
the return 
statement
. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 void divide(double 
arg1, 
double arg2); 
8 
9 int main() 
10 { 
11 
double num1, num2; 
12 
13 
cout << "Enter two numbers and I wi ll divide 
the first
\n"; 
14 
cout << "number by the second number : "· 
15 
cin 
>> num1 >> num2; 
16 
divide(num1 , num2); 
17 
return 
O; 
18 } 
19 
20 /******************************************************** 
21 
22 
23 
24 
25 
* 
* 
* 
* 
* 
divide 
This function 
uses two parameters, 
arg1 and arg2. 
If arg2 does not= 
zero , the f unction 
displays 
the 
result 
of arg 1/ar g2 . Otherwise 
i t returns 
without 
perform i ng the di vi s i on . 
* 
* 
* 
* 
* 
26 
********************************************************/ 
27 void divide(double 
arg1, 
double arg2) 
28 { 
29 
if (arg 2 == 0 .0) 
30 
{ 
31 
cout << "Sorry , I cannot divide 
by zero .\n"; 
32 
return; 
33 
} 
34 
cout << "The quot i ent is"<< 
(ar g1 I arg2) << endl; 
35 } 
(program continues) 

6.7 Returning a Value from a Function 
343 
Program 6-10 
(continued) 
Program Output with Example Input Shown in Bold 
Enter two numbers and I wi ll divid e the fir st 
number by the second number : 12 O[Ent er] 
Sorry, I cannot divide by zero. 
6.7 
a 
VideoNote 
Value-Returning 
Functions 
Figure 6-9 
In the example running of the program, the user entered 12 and O as input . These were 
stored as doub le values as variables num1 and num2. In line 16 the divi de function was 
called, passing 12.0 into the arg 1 parameter and 0.0 into the arg2 parameter. Inside the 
di vi de function, the i f statement in line 29 executes. Because arg2 is equal to 0.0, 
the code in lines 31 and 32 executes. When the retur n statement in line 32 executes, 
the di vi de function immediately ends. This means the cout statement in line 34 does 
not execute. The program resumes at line 17 in the mai n function. 
Returning 
a Value from a Function 
CONCEPT: 
A function may send a value back to the part of the program that called 
the function. 
You've seen that data may be passed into a function by way of parameter variables. 
Data may also be returned from a function back to the statement that called it. 
Functions that return a value are known as value-returning functions . 
The pow function, which you have already used, is an examp le of a value-returning 
function. Here is an example: 
double x; 
x = pow(4.0, 2.0); 
This code calls the pow function, passing 4.0 and 2.0 as arguments . The function 
calculates the value of 4.0 raised to the power of 2.0 and returns that value. The value, 
which is 16.0, is assigned to the x variab le by the= operator. 
Although several arguments can be passed into a function, only one value can be 
returned from it. Think of a function as having multiple communication channels for 
receiving data (parameters), but only one channel for sending data (the return value). 
This is illustrated in Figure 6-9. 
Argument 1 
Argument 2 
Argument 3 
Argument4 
... 
... 
... 
... 
Function 
Return value 

344 
Chapte r 6 
0 
Figure 6-10 
Functions 
NOTE: In order to return multiple values from a function, they must be "packaged" 
in such a way that they are treated as a single value. You will learn to do this in 
Chapter 7. 
Defining a Value-Returning 
Function 
When you are writing a value-returning function, you must decide what type of value the 
function will return. This is because you must specify the data type of the return value in 
the function header and function prototype. Up until now all the functions we have written 
have been vo i d functions. This means they do not return a value. These functions use the 
key word void as the return type in their function header and function prototype. A value-
returning function, in contrast, uses i nt , doubl e, boo l, or any other valid data type in its 
header. Here is an example of a function that returns an i nt value: 
i nt sum( i nt num1 , i nt num2) 
{ 
) 
i nt resul
t ; 
resul
t
= num1 + num2; 
return 
result; 
The name of this function is sum. Not ice in the function header that the return type is 
i nt , as illustrated in Figure 6-10. 
Return type 
! 
int 
sum(int 
num1, int 
num2) 
This code defines a function named sum that accepts two in t arguments. The arguments 
are passed into the parameter variables num1 and num2. Inside the function, the variable 
result 
is defined. Variables that are defined inside a function are called local variables . 
After the variable definition, the values of the parameter variables num1 and num2 are added, 
and their sum is assigned to the result 
variable. The last statement in the function is: 
return 
result; 
This statement causes the function to end, and it sends the value of the result 
variable 
back to the statement that called the function. A value-returning function must have a 
re t urn statement written in the following general format: 
return 
expression; 
In the general format, expression 
is the value to be returned. It can be any expression 
that has a value, such as a variable, literal, or mathemat ical expression . The value of 
the expression is converted to the data type that the function returns and is sent back 
to the statement that called the function. In this case, the sum function returns the value 
in the resul
t variable. 

6.7 Returning a Value from a Function 
34 5 
However, we could have eliminated the result 
variab le entire ly and returned the 
expression num1 + num2, as shown in the following code: 
int sum(int 
num1, int num2) 
{ 
return 
num1 + num2; 
) 
The prototype for a value-returning function follows the same conventions that we 
covered earlier. Here is the prototype for the sum function: 
int sum(int 
num1, int num2); 
Calling a Value-Returning 
Function 
Program 6-11 shows an example of how to call the sum function. 
Program 6-11 
1 II This program uses a function 
that 
returns 
a value. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototype 
6 int sum(int 
num1, int num2); 
7 
8 
9 
10 
11 
12 
13 
int 
{ 
main() 
int value1 
value2 
total; 
= 20 , 
II The first 
value 
= 40, 
II The second value 
II Holds the returned 
total 
14 
II Call the sum function, 
pass i ng the contents 
of 
15 
II value1 and value2 as arguments. 
Assign the return 
16 
II value to the total 
variable. 
17 
total 
= sum(value1, 
value2); 
18 
19 
II Display 
the sum of the values 
20 
cout << "The sum of"<< 
value1 <<"and" 
21 
<< value2 <<"is"<< 
total 
<< endl; 
22 
return 
O; 
23 } 
24 
25 /********************************************************* 
* 
sum 
* 
26 
27 
* 
This function 
returns 
the sum of it s two parameters
. * 
28 
*********************************************************/ 
29 int sum(int 
num1, int num2) 
30 { 
31 
return 
num1 + num2; 
32 } 
Program Output 
The sum of 20 and 40 is 60 

346 
Chapter 6 
Figure 6-11 
Functions 
Here is the statement in line 17, which calls the sum funct ion, passing val ue1 and 
val ue2 as arguments. 
total 
= sum(value 1, value 2); 
This statement assigns the value returned by the sum function to the t ot al variab le. In 
this case, the function will return 60. Figure 6-11 shows how the arguments are passed 
into the function and how a value is passed back from the function. 
total 
= sum(value1, 
val ue2); 
I '---1 ~1-,l 
'------1
~
1--
i 
int 
sum (int 
num1, int 
num2) 
60 
{ 
'--------
return 
num + num; 
} 
When you call a value-returning function, you usually want to do something meaningfu l 
with the value it returns . Program 6-11 shows a function's return value being assigned 
to a variable. This is commonly how return values are used, but you can do many other 
things with them as well. For example, the following code shows a math expression 
that uses a call to the sum function: 
i nt X = 10, y = 15; 
double average; 
average= 
sum(x, y) 
/ 2.0; 
In the last statement, the sum function is called with x and y as its arguments. The function's 
return value, which is 25, is divided by 2.0. The result, 12.5, is assigned to averag e. Here 
is another example: 
i nt X = 10, y = 15; 
cout << "The sum i s"<< 
sum(x, y) << endl; 
This code sends the sum function's return value to cout so it can be displayed on the 
screen. The message "The sum is 25" will be displayed. 
Remember, a value-returning function returns a value of a specific data type. You can use 
the function's return value anywhere that you can use a regular value of the same data 
type. This means that anywhere an i nt value can be used, a call to an i nt value-returning 
function can be used. Likewise, anywhere a double value can be used, a call to a double 
value-returning function can be used. The same is true for all other data types. 
Let's look at another example . Program 6-12, which calculates the area of a circle, has 
two functions in addition to main . One of the functions is named squar e, and it returns 
the square of any number passed to it as an argument . The square function is called in 
a mathemat ical statement. The program also has a function named get Radi us, which 
prompts the user to enter the circle's radius. The value entered by the user is returned 
from the function. 

6.7 Returning a Value from a Function 
347 
Program 6-12 
1 // Thi s program demonstrates 
two value-returning 
funct i ons. 
2 II The square function 
is called 
i n a mathematica l statement. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std; 
6 
7 //Funct ion prototypes 
8 double getRad i us(); 
9 double square(double 
number); 
10 
11 int main() 
12 { 
13 
14 
15 
16 
const double PI = 3.14159; 
double rad i us; 
double area ; 
// Constant 
for pi 
// Holds the circle's 
radius 
// Holds the circle's 
area 
17 
// Set the numeric output 
formatting 
18 
cout <<fixed<< 
showpoint << setprecision(2); 
19 
20 
II Get the radius 
of the circle 
21 
cout << "This program calcu l ates the area of a circle.\n"; 
22 
radius
= getRadius(); 
23 
24 
II Caclulate 
the area of the ci rcle 
25 
area
= PI * square(radius); 
26 
27 
II Display 
the area 
28 
cout << "The area is"<< 
area<< 
endl; 
29 
return 
O; 
30 ) 
31 
32 /******************************************** 
33 
* 
getRadius 
34 
* Thi s funct i on returns 
the circle 
rad i us 
35 
* input by the user. 
* 
* 
* 
36 
********************************************/ 
37 double getRad i us() 
38 { 
39 
double rad ; 
40 
41 
cout << "Enter the radius 
of the circle: 
"· 
42 
cin 
>> rad; 
43 
return 
rad ; 
44 ) 
45 
46 
47 
48 
49 
50 
/********************************************* 
* 
square 
* Thi s funct i on returns 
the square of the 
* double argument sent to it 
* 
* 
* 
*********************************************/ 
(program continues) 

348 
Chapter 6 
Functions 
Program 6-12 
(continued) 
51 double square(double 
number) 
52 { 
53 
ret urn number* number; 
54 ) 
Program Output with Example Input Shown in Bold 
This program calculates 
the area of a circle. 
Enter the radius of the circle: 
lO[Enter] 
The area is 314.16 
Figure 6-12 
First, look at the getRadi us function, which is defined in lines 37 through 44. Notice that 
there is nothing inside the parentheses of the function header on line 37. This means the 
function has no parameters, so no arguments are sent to it when it is called. The purpose 
of this function is to get the circle radius from the user. In line 39 the function defines a 
local variable, rad. Line 41 displays a prompt , and line 42 accepts the user's input for the 
circle's radius, which is stored in the rad variable. In line 43 the value of the rad variable is 
returned . The getRadi us function is called in line 22 of the main function. When the value 
is returned from the getRadi us function, it is assigned to the rad i us variable. 
Next look at the square function, which is defined in lines 51 through 54. When the 
function is called, a double argument is passed to it. The function stores the argument in 
its number parameter. The return statement in line 53 returns the value of the expression 
number ,,. number, which is the square of the value in the number parameter. The square 
function is called in line 25 of the mai n function, with the value of rad i us passed as an 
argument . The square function will return the square of the rad i us variable, and that 
value will be used in the mathematica l expression that computes the circle's area. 
Assuming the user has entered 10.0 as the radius and this value is passed as an argument 
to the square function, the function will return the value 100.0. Figure 6-12 illustrates 
how this value is passed back to be used in the mathematical expression . 
area= 
PI* 
square(radius); 
1100. 01 
'------11
10.0-I -1 
double square(doub
l e number) 
{ 
._ ____ 
return 
number* 
number; 
} 
Functions can return values of any type. Both the getRadi us and square functions in 
Program 6-12 return a double . The sum function you saw in Program 6-11 returned an 
i nt. When a statement calls a value-returning function , it should properly hand le the 
return value. For example, if you assign the return value of the square function to a 
variable, the variab le should be a double. If the return value of the function has a 
fractional portion and you assign it to an i nt variable, the value will be truncated . 

6.8 
6.8 Returning a Boolean Value 
349 
Returning 
a Boolean Value 
CONCEPT: 
Fun ctio ns may return true or false values. 
Frequently there is a need for a function that tests an argument and returns a true or false 
value indicating whether or not a condit ion is satisfied . Such a function wou ld return a 
boo l value. For examp le, the i sVa l id function shown below accepts an int argument and 
returns true if the argument is within the range of 1 through 100, or false otherwise . 
bool isValid(int 
number) 
{ 
bool status; 
i f (number> = 1 && number< = 100) 
status= 
true; 
} 
else 
status= 
false
; 
return 
status; 
Th e following code shows an if I else statement that makes a call to the function: 
i nt value= 
20 ; 
if 
(i sValid(value)) 
cout << "The value i s with i n range.\n"; 
else 
cout << "The value i s out of range.\n"; 
Because value equa ls 20, this code will display the message "Th e value is within 
range." when it executes. 
Program 6-13 shows another example of a function whose return type is bool. Thi s 
program has a function named i sEven, which returns true if its argument is an even 
number. Otherwise, the function returns false. 
Program 6-13 
1 // 
This program uses a function 
that 
returns 
true 
or false. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 II Function 
prototype 
6 bool i sEven(int); 
7 
8 int main() 
9 { 
10 
int val; 
11 
12 
II Get a 
13 
cout << 
14 
cout << 
15 
cin 
>> 
number 
"Enter 
II if it 
val; 
// the value to be tested 
from the user 
an integer 
and I will 
tell 
you"; 
i s even or odd: "; 
(program continues) 

350 
Chapte r 6 
Functions 
Program 6-13 
16 
(continued) 
17 
18 
19 
20 
21 
22 
23 
24 
} 
II Indicate 
whether it 
if (isEven(val
)) 
cout << val << " is 
else 
cout << val << " is 
return o· ' 
is even or odd 
even. \n"; 
odd . \n"; 
25 /******************************************************* 
26 
* 
isEven 
* 
27 
* This Boolean function 
tests 
if the integer 
argument* 
28 
* it receives 
is even or odd . It returns 
true 
if the 
* 
29 
* argument is even and false 
if i t is odd . 
* 
30 
*******************************************************/ 
31 bool i sEven(int 
number) 
32 { 
33 
if (number % 2 == 0) 
34 
return 
true; 
// The number is even if there's 
no remainder 
35 
else 
36 
return 
false ; // Otherwise, 
the number is odd 
37
} 
Program Output with Example Input Shown in Bold 
Enter an integer 
and I will 
tell 
you if it is even or odd: S[Enter] 
5 is odd. 
Notice how the i sEven function is called in line 18 with the following statement: 
if 
(isEven (va l )) 
Recall from Chapter 4 that this is asking if the function call i sEven (val) returned the 
value true. When the if statement executes, i sEven is called with val as its argument. 
If val is even, i sEven returns true ; otherwise it returns false. 
Notice also how the i sEven function that begins on line 31 uses an if statement to 
return either the value true or the value false. 
Ther e are several other ways this 
function could have been written. Let's compare three different ways to write it. 
// 
Program 6-13 code 
bool isEven( i nt number) 
{ 
// Version 2 
bool isEven( i nt number) 
{ bool answer ; 
// Vers io n 3 
bool is Even(int 
number) 
{ bool answer = false; 
} 
if (number% 2 == 0) 
return 
true; 
else 
return 
false; 
} 
i f (number % 2 --
answer = true; 
else 
answer = false; 
return 
answer; 
0) 
} 
i f (number% 2 == 0) 
answer = true; 
return 
answer ; 

6.9 Using Functions in a Menu-Driven Program 
35 1 
Although the code used in Program 6-13 is short and clear, it has two different return 
statements . Many instructors prefer that a value-returning function have only a single 
return statement, placed at the end of the function. Versions 2 and 3 do this. Your 
instructor will let you know which method you should use. 
~ 
Checkpoint 
6.9 
6.11 
How many return values may a function have? 
6.12 
Write a header for a function named distance. The function shou ld return a 
double and have two double parameters: rate and time. 
6.13 
Write a header for a function named days. The function should return an i nt 
and have three i nt parameters: years, months, and weeks. 
6.14 
Write a header for a function named getKey. The function should return a 
char and use no parameters. 
6.15 
Write a header for a function named l ightYears. The function shou ld return a 
long and have one long parameter: mil es. 
Using Functions in a Menu-Driven 
Program 
CONCEPT : Functions are ideal for use in menu-driven programs. When the user selects 
an item from a menu, the program can call the appropriate function. 
All of the functions you have seen in this chapter so far have been very simple . This was 
done in order to focus on how functions are created and called, without making them 
too long. However, in most programming app lications, functions do more. They allow 
a program to be modularized, with a function written to carry out each major task the 
program needs to do. The job of mai n then is to organize the flow of the program by 
making calls to the functions. 
In Chapters 4 and 5 you saw a menu-driven program that calculates the charges for a 
health club membership. Program 6-14 is an improved modular version of that program 
that has three functions in addition to main. 
Program 6-14 
1 II This is a modular, menu-driven program that 
computes 
2 II health 
club membership fees. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 #include 
<str i ng> 
6 usi ng namespace std; 
7 
8 II Function prototypes 
9 voi d di splayMenu (); 
10 int getChoice(); 
11 voi d showFees(str i ng category, 
double rate, 
int months); 
12 
(program continues) 

352 
Chapte r 6 
Functions 
Program 6-14 
(continued) 
13 int main() 
14 { 
15 
16 
II Constants 
for monthly 
const double ADULT_RATE 
17 
CHILO_RATE 
18 
SENIOR_RATE 
membership rates 
= 120.0, 
= 
60.0, 
= 100.0; 
19 
int choice, 
20 
months; 
II Holds the user's 
menu choice 
II Number of months being paid 
21 
22 
II Set numeric output 
formatting 
23 
cout <<fixed<< 
showpoi nt << setprecision(2); 
24 
25 
do 
26 
{ displayMenu()
; 
27 
choice= 
getCho i ce (); II Ass i gn choice the value returned 
28 
II by the getChoice 
funct i on 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
if (choic e != 4) 
{ 
II If user does not want to quit, 
proceed 
cout << "For how many months?"· 
ci n 
>> months; 
switch 
(choice) 
{ 
case 1: 
showFees("Adult", 
ADULT_RATE, months); 
break; 
case 2: 
showFees("Child", 
CHILO_RATE, months); 
break; 
case 3: 
showFees("Sen i or", 
SENIOR_RATE, months); 
} 
} 
43 
} while 
(choice 
!= 4); 
44 
return 
O; 
45 } 
46 
47 /********************************************** 
48 
* 
di splayMenu 
49 
* Thi s funct i on clears 
the screen 
and then 
50 
* displays 
the menu cho i ces. 
* 
* 
* 
51 
**********************************************/ 
52 void displayMenu () 
53 { 
54 
system( "c ls "); 
II Clear the screen . 
55 
cout << "\n 
Health Club Membership Menu\n\n"; 
cout << 
II 1 • 
56 
Standard 
Adult Membershi p\n"; 
cout << "2. 
57 
Child Membership\n"; 
cout << "3. 
58 
Senior Ci tizen 
Membershi p\n"; 
cout << "4. 
59 
Quit the Program\n\n"
; 
60 
61 
} 
(program continues) 

6.9 Using Functions in a Menu-Driven Program 
353 
Program 6 -14 
(continued) 
62 / ****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * 
63 
64 
65 
* 
* 
* 
getChoice 
This function 
inputs
, validates
, and returns 
the user's 
menu choice. 
* 
* 
* 
66 
****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * */ 
67 int getChoice(
) 
68 { 
69 
int choice ; 
70 
71 
cin >> cho i ce; 
72 
whi le (cho i ce < 1 11 choice 
> 4) 
73 
{ cout << "The only valid 
choices 
are 1-4. 
Please 
re-enter. 
"· 
74 
cin 
>> choice ; 
75 
} 
76 
return 
cho i ce; 
77 } 
78 
79 / ****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * 
80 
81 
82 
83 
84 
85 
86 
* 
showFees 
* 
* Thi s funct i on uses the membership type , monthly rate, 
and 
* 
* number of months passed to it as arguments 
to compute and 
* 
* display 
a member's total 
charges. 
It then holds the screen* 
* until 
the user presses 
the ENTER key. This is necessary 
* 
* because after 
returning 
from this 
function 
the displayMenu 
* 
* function 
wi ll be called
, and it will 
clear 
the screen. 
* 
87 
****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * / 
88 void showFees(string 
memberType, double rate, 
int months ) 
89 { 
90 
91 
92 
93 
94 
cout << 
<< 
<< 
<< 
endl 
"Membershi p Type 
• 
"Number of months: 
• 
"Total 
charges 
$ " 
<< memberType << • 
" 
<< months<< 
endl 
<< (rate 
* months ) << endl; 
95 
II 
Hold the screen 
until 
the user presses 
the ENTER key. 
96 
cout << "\ nPress the Enter key to return 
to the menu. "; 
97 
cin.get
() ; 
II Clear the prev i ous \ n out of the i nput buffer 
98 
cin.get
() ; 
II Wait for the user to press 
ENTER 
99 } 
Program Output with Example Input Shown in Bold 
Health Club Membership Menu 
1. 
Standard 
Adult Membership 
2. 
Child Membership 
3. 
Senior Citizen 
Membership 
4. 
Quit the Program 
1 [Enter] 
For how many months? 3[Ent er] 
Membership Type 
Total charges 
Adult 
Number of months: 3 
$360.00 
Press the Enter key to return 
to the menu. 

354 
Chapter 6 
Functions 
Notice how each function, or module, of Program 6-14 is designed to perform a specific task. 
• di sp l ayMenu, as its name suggests, displays the menu of choices. 
• get Choice gets the user's menu choice and validates it before returning it to the 
main function . The main function can then use the value, knowing it is good. 
• showFees computes and displays membership informat ion and fees. 
Notice , in particular , the versatility of the showFees function, which is called in three 
different places within the swi tch statement . It is passed three arguments: a string 
holding the membership type, a double holding the monthly fee for that membership 
type, and an int holding the number of months being billed. Without these arguments, 
we would need a whole set of functions: one to compute adult membership fees, another 
to compute child membership fees, and a third to compute senior membersh ip fees. 
Because we can vary the information passed as arguments to the function, however, we 
are able to create a single general-purpose function that works for all three cases. 
Notice also how the function arguments relate to the function parameters . Here they 
are shown again with the parameters and arguments aligned for easy comparison . 
void showFees(string 
cat egory, 
double ra t e, int mont hs) ; 
II prot ot ype 
void showFees(string 
member Type, double ra t e, int mont hs) 
II header 
showFees( 
"Adult", 
ADULT_RATE, 
mont hs) ; 
II function 
call 
showFees( 
"Chi ld" , 
CHILD_RATE, 
mont hs) ; 
II function 
call 
showFees( 
"Senior" 
1 
SENIDR_RATE, 
mont hs) ; 
II function 
call 
Each call to the function can send different arguments, and the names of any variables 
used as arguments do not have to match the parameter names . However, the showFees 
function has three parameters: first a string, 
then a double , and finally an int. 
Therefore, each call to the function must have three arguments whose order and data 
types match the parameters in which they will be stored . 
Clearing the Screen 
Sometimes in a program you want to clear the screen and place the cursor back up at 
the top. This is particular ly useful when you are writing a menu-driven program . After 
the user has made a menu selection and the function to carry out that choice has been 
executed, it would be nice to be able to clear the screen before redisplaying the menu. 
This can be accomp lished by inserting a command in your program that asks the 
operating system to clear the screen for you. Here is the command for Unix-based 
operating systems, such as Linux and Mac OS: 
syste m("clear"); 
And here is the command for Windows operating systems. You may have noticed that 
it appears in line 54 of Program 6-14, just before the menu is displayed. 
syste m("cls"); 
This removes the previous report from the screen before the user selects a new one to be 
displayed . However , it is important not to clear the screen too quickly after a report 
displays, or it will disappear before the user has a chance to look at it. Take a look at lines 
95 through 98 of Program 6-14. These lines hold the report screen until the user presses 
the [Enter] key to signal readiness to return to the menu and begin something new. 

6.10 Local and Global Variables 
35 5 
6.10 
Local and Global Variables 
CONCEPT
: A local variable is defined inside a function and is not accessible outside 
the function. A global variable is defined outside all functions and is 
accessible to all functions in its scope. 
Local Variables 
Variables defined inside a function are local to that function. They are hidden from the 
statements in other functions, which normally cannot access them. Program 6-15 
shows that because the variables defined in a function are hidden, other functions may 
have separate, distinct variables with the same name. 
Program 6-15 
1 II Thi s program shows that 
variables 
defined 
in a function 
2 II are hidden from other 
functions. 
3 #include 
<iostream> 
4 using namespace std;} 
5 
6 void anotherFunction(); 
7 
8 int main() 
9 { 
10 
int num = 1 ; 
11 
II Funct i on prototype 
II Local variable 
12 
cout << "In main, num is"<< 
num << end l; 
13 
anotherFunction(); 
14 
cout << "Back in mai n, num is st i ll "<< num << endl ; 
15 
return 
O; 
16 } 
17 
18 /*************************************************************** 
19 
* 
anotherFunct
i on 
* 
20 
* Thi s funct i on displays 
the value of i ts l oca l variable 
num. * 
21 
***************************************************************/ 
22 void anotherFunction() 
23 { 
24 
25 
int num = 20; 
II Local variable 
26 
cout << "In anotherFunction, 
num is"<< 
num << endl; 
27
} 
Program Output 
In main, num is 1 
In anotherFunction, 
num is 20 
Back in main, num is still 
1 

356 
Chapte r 6 
Figure 6-13 
0 
Functions 
Even though there are two variables named num, the program can only "see" one of them at 
a time because they are in different functions. When the program is executing in main, the num 
variable defined in mai n is visible. When anotherFunction 
is called, however, only variables 
defined inside it are visible, so the num variable in mai n is hidden. Figure 6-13 illustrates the 
closed nature of the two functions. The boxes represent the scope of the variables. 
Function main 
i nt num = 1 ; .... 
-1-----+--
This num variable is visible 
only in main 
Function anotherFunct io n 
int num = 20; .... 
_1-----+--
This num variable is visible 
only in another Funct ion 
NOTE: 
The parameters of a function are also local variab les. Their scope is limited 
to the body of the function. 
Local Variable Lifetime 
A local variable exists only while the function it is defined in is executin g. Thi s is 
known as the lifetime of a loca l variable. When the function begins , its parameter 
variab les and any local variab les it defines are created in memory , and when the 
function ends, they are destroyed. This means that any values stored in a function's 
parameters or local variab les are lost between calls to the function . 
Initializing Local Variables with Parameter Values 
It is possible to use parameter variabl es to initialize local variables . Sometimes this 
simpli fies the code in a function. Here is a modified version of the sum function we 
looked at earlier. In this version, the function's parameters are used to initialize the 
local variable result. 
i nt sum(i nt num1, int num2) 
{ 
) 
int result= 
num1 + num2; 
return 
result
; 
Global Variables 
A global variable is any variable defined outside all the functions in a program , including 
main. The scope of a globa l variable is the portion of the program from the variab le 
definition to the end of the entire program. This means that a global variable can be accessed 
by all functions that are defined after the global variable is defined. Program 6-16 shows 
two functions, mai n and anotherFunct ion, which access the same global variable, num. 

6.10 Local and Global Variables 
35 7 
Program 6-16 
1 II Thi s program shows that 
a global 
var i able is visible 
to all 
f unctions 
2 II that 
appear in a program after 
the variable's 
defin i tion . 
3 #include 
<iostream> 
4 usin g namespace std; 
5 
6 void anotherFunction(); 
7 int num = 2 ; 
8 
9 int main() 
10 
11 { 
II Function 
prototype 
II Global variable 
12 
cout << "In main, num is"<< 
num << endl; 
13 
anotherFunction(); 
14 
cout << "Back in mai n, num is"<< 
num << endl ; 
15 
return 
O; 
16 } 
17 /*************************************************************** 
18 
* 
anotherFunction 
* 
19 
* Thi s funct i on changes the value of the global 
variable 
num. * 
20 
***************************************************************/ 
21 void anotherFunction() 
22 { 
23 
cout << "In anotherFunction, 
num is"<< 
num << endl ; 
24 
num = 50; 
25 
cout << "But, it i s now changed to"<< 
num << endl; 
26
} 
Program Output 
In main, num is 2 
In anotherFunction, 
num is 2 
But , it is now changed to 50 
Back in main, num is 50 
In Program 6-16, num is defined outside of all the functions. Because its definition appears 
before the definitions of main and anotherFunct i on, both functions have access to it. 
In C++, unless you explicitly initialize numeric global variables, they are automat ically 
initialized to zero. Global character variab les are initialized to NULL.· In Program 6-17 
the variable global Num is never set to any value by a statement, but because it is globa l 
it is automatically set to zero . 
Program 6-17 
1 II Thi s program has an uninitialized 
global 
variable. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int globalNum ; 
II Global variable 
automatically 
set to zero 
6 
(program continues) 
• The NULL character is stored as ASCII 0 

358 
Chapte r 6 
Functions 
Program 6-17 
(continued) 
7 int main () 
8 { 
9 
cout << "globalNum i s"<< 
globalNu m << endl; 
10 
return 
O; 
11 } 
Program Output 
globalNum i s O 
0 
NOTE: 
Remember that local variables are not automat ically initialized as global 
variab les are. The programmer must handle this. 
Although global variables can be useful, you should restrict your use of them. When 
beginning students first learn to write programs with multiple functions, they are some-
times tempted to make all their variables global so they can be accessed by any function in 
the program without being passed as arguments. Although this approach might make a 
program easier to create, it usually causes problems later. Here is why. 
• Global variables make debugging difficult . Any statement in a program can 
change the value of a global variable. If you find that the wrong value is being 
stored in a global variable, you have to track down every statement that accesses 
it to determine where the bad value is coming from. In a program with thousands 
of lines of code, this can be difficult. 
• Functions that use global variables are usually dependent on those variables. If 
you want to use such a function in a different program , most likely you will have 
to redesign it so it does not rely on the global variable. 
• Global variables make a program hard to understand. A global variable can be 
modified by any statement in the program . So to understand any part of the 
program that uses a global variable, you have to be aware of all the other parts of 
the program that access it. 
Therefore, it is best not use global variables for storing, manipulating , and retrieving 
data . Instead, declare variables locally and pass them as arguments to the functions 
that need to access them . 
Global Constants 
Although you should try to avoid the use of global variab les, it is generally permissible 
to use global constants in a program. A global constant is a named constant that is 
available to every function in a program. Because a global constant's value cannot be 
changed during the program's execution, you do not have to worry about the potentia l 
hazards associated with the use of global variables. 
Global constants are typically used to represent unchanging values that are needed 
throughout a program . For example, suppose a banking program uses a named constant 
to represent an interest rate. If the interest rate is used in several functions, it is easier to 
create a global constant, rather than a local named constant in each function. This also 
simplifies maintenance. If the interest rate changes, only the declaration of the global 
constant has to be changed, instead of several local declarations. 

6.10 Local and Global Variables 
359 
Program 6-18 shows an examp le of how global constants might be used. The program 
calculates gross pay, including overtime, for a company's management trainees. All 
trainees earn the same amount per hour. In addition to main, this program has two 
functions: getBasePay 
and getOvert i mePay. Th e getBasePay 
function accepts the 
number of hours worked and returns the amount of pay for the non -overtime hours. 
The get Overt i mePay function accepts the number of hours worked and returns the 
amount of pay for the overtime hours, if any. 
Program 6-18 
1 II Thi s program calculates 
gross pay . It uses global 
constants. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 using namespace std ; 
5 
6 II Global constants 
II Hourly pay rate 
7 const double PAY_RATE = 22.55; 
8 const double BASE_HOURS = 40.0; 
9 const double OT_MULTIPLIER = 1 .5; 
II Max non-overtime 
hours 
II Overtime multipl
i er 
10 
11 II Function 
prototypes 
12 double getBasePay(double); 
13 double getOvertimePay(double); 
14 
15 int main() 
16 { 
17 
18 
19 
20 
double hours, 
21 
basePay, 
overtimePay 
= 0 .0, 
total Pay; 
II Hours worked 
II Base pay 
II Overt i me pay 
II Total pay 
22 
II Get the number of hours worked 
23 
cout << "How many hours did you work?"; 
24 
cin 
>> hours; 
25 
26 
II Get the amount of base pay 
27 
basePay = getBasePay(hours); 
28 
29 
II Get overtime 
pay, i f any 
30 
if (hours> 
BASE_HOURS) 
31 
overtimePay 
= getOvertimePay(hours
); 
32 
33 
II Calculate 
the total 
pay 
34 
totalPay 
= basePay + overtimePay; 
35 
II Display 
the pay 
showpoint; 
<< basePay 
36 
37 
38 
39 
40 
cout << setprecis
i on(2) <<fixed<< 
cout << "Base pay 
$" << setw(7 ) 
cout << "Overtime pay$"<< 
setw(7 ) 
cout << "Total 
pay 
$" << setw(7) 
<< overtimePay 
<< 
<< totalPay 
<< endl ; 
endl ; 
<< endl ; 
41 
return 
O; 
42 } 
(program continues) 

360 
Chapte r 6 
Functions 
Program 6-18 
43 
(continued) 
44 /*************************************************************** 
45 
* 
getBasePay 
* 
46 
* Thi s funct i on uses the hours worked value passed in to 
* 
47 
* compute and return 
an employee 's pay for non-overtime 
hours.* 
48 
***************************************************************/ 
49 double getBasePay(double 
hoursWorked) 
50 { 
51 
double basePay; 
52 
53 
if (hoursWorked > BASE_HOURS) 
54 
basePay = BASE_ HOURS * PAY_RATE; 
55 
else 
56 
basePay = hoursWorked * PAY_RATE; 
57 
58 
return 
basePay; 
59 ) 
60 
61 /******************************************************** 
62 
* 
getOvert i mePay 
* Thi s funct i on uses the hours worked value passed i n 
* to compute and return 
an employee's 
overtime 
pay. 
* 
* 
* 
63 
64 
65 
********************************************************/ 
66 double getOvertimePay(double 
hoursWorked) 
67 { 
68 
double overtimePay
; 
69 
70 
if (hoursWorked > BASE_HOURS) 
71 
{ 
72 
overt i mePay = 
73 
(hoursWorked - BASE_HOURS) * PAY_RATE * OT_MULTIPLIER; 
74 
} 
75 
else 
76 
overt i mePay = 0.0; 
77 
78 
return 
overtimePay
; 
79 } 
Program Output with Example Input Shown in Bold 
How many hours did you work? 48[Enter] 
Base pay 
$ 902.00 
Overtime pay$ 
270.60 
Total pay 
$1172.60 
Let's take a closer look at the program. Three global constants are defined in lines 7, 8, 
and 9. The PAY_RATE constant is set to the employee's hourly pay rate, which is 22.55. 
The BASE_ HOURS constant is set to 40.0, which is the number of hours an employee can 
work in a week without getting paid overtime. The OT_MULTIPLIER constant is set to 
1.5, which is the pay rate multiplier for overtime hours. This means that the employee's 
hourly pay rate is multiplied by 1.5 for all overtime hours. 

6.10 Local and Global Variables 
361 
Because these constants are globa l and are defined before all of the functions in the 
program, all the functions may access them. For example, the getBasePay function 
accesses the BASE_HOURS 
constant in lines 53 and 54 and accesses the PAY_RATE constant 
in lines 54 and 56. The getOvertimePay 
function accesses the BASE_HOURS 
constant in 
line 70 and all three constants in line 73 . 
Local and Global Variables with the Same Name 
You cannot have two local variables with the same name in the same function. This applies 
to parameter variables as well. A parameter variable is, in essence, a local variable. So, you 
cannot give a parameter variable and a local variable in the same function the same name. 
However, you can have a parameter or local variable with the same name as a globa l 
variable or constant . When you do this, the name of the parameter or local variable 
shadows the name of the globa l variable or constant . Thi s means that the globa l 
variable or constant's name is hidden by the name of the parameter or local variable. 
So, the global variable or constant can't be seen or used in this part of the program. 
Program 6-19 illustrates this. It has a global constant named BIRDS set to 500 and a 
local constant in the ca 1 i forni a function named BI RDS set to 10000. 
Program 6-19 
1 II Thi s program demonstrates 
how a local 
variable 
or constant 
2 II can shadow the name of a global 
variable 
or constant
. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 void californ
i a (); 
7 
8 const int BIRDS= 500; 
9 
10 int main() 
II 
Funct i on prototype 
II Global constant 
11 { 
12 
cout << "In main 
cal ifornia(); 
return 
O; 
there 
are"<< 
BIRDS<< " birds.\n"; 
13 
14 
15 ) 
16 
17 /******************************* 
18 
* 
californ
i a 
* 
19 
*******************************/ 
20 void californ
i a () 
21 { 
22 
const i nt BIRDS= 10000; 
23 
24 
cout << "In cal i fornia 
there are"<< 
BIRDS<<" 
birds . \n"; 
25
) 
Program Output 
In main there 
are 500 birds. 
In california 
there are 10000 birds. 

362 
Chapte r 6 
Functions 
When the program is executing in the mai n function, the global constant BIRDS, which 
is set to 500, is visible. The cout statement in line 12 displays "In main there are 500 
birds." (My apologies to folks living in Maine for the difference in spelling.) When the 
program is executing in the cal i forn i a function, however, the local constant BIRDS 
shadows the global constant BIRDS, so it is the local constant BI RDS that gets used. That 
is why the cout statement in line 24 displays "In california there are 10000 birds." 
Static Local Variables 
If a function is called more than once in a program, the values stored in the function's 
local variables do not persist between function calls. This is because local variables are 
destroyed when a function terminates and are then re-created when the function starts 
again. This is shown in Program 6-20. 
Program 6-20 
1 II Thi s progra m shows tha t local 
variables 
do not reta i n 
2 II t heir values 
betwee n function 
calls
. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 void showlocal(); 
7 
8 int main () 
9 { 
10 
showlocal(); 
11 
showlocal(); 
12 
retur n O; 
13 ) 
14 
II Funct ion prototy pe 
15 /****************************************************** 
16 
* 
s howlocal 
* 
17 
* Thi s func ti on sets, 
di splays, 
and then changes the* 
18 
* value of local 
variable 
localNum before 
retur ning. 
* 
19 
******************************************************/ 
20 void showlocal() 
21 { 
22 
int localNum = 5; 
II 
Local var i able 
23 
24 
cout << "localNum is"<< 
localNum << endl; 
25 
localNu m = 99; 
26
) 
Program Output 
local Num is 5 
local Num is 5 
Even though in line 25 the last statement in the showlocal 
function stores 99 in 
local Num, the variable is destroyed when the function terminates . The next time the 
function is called, local Num is re-created and initialized to 5 all over again. 

6.11 Static Local Variables 
363 
Sometimes, however, it's desirable for a program to "remember" what value is stored 
in a local variable between function calls . Thi s can be accomplished by making the 
variable static. 
Static local variables are not destroyed when a function returns. The y 
exist for the entire lifetime of the program, even though their scope is only the function 
in which they are defined. Program 6-21 uses a static local variab le to count how many 
times a function is called. 
Program 6-21 
1 II Thi s program uses a static 
local 
var i able . 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 void showStat i c (); 
6 
7 int main() 
8 { 
II Function 
prototype 
9 
II Call the showStatic 
function 
five t i mes 
10 
for (int 
count
= O; count< 
5 ; count+ +) 
11 
showStatic(); 
12 
return 
O; 
13 ) 
14 
15 /************************************************** 
16 
* 
showStatic 
• 
17 
* Thi s funct i on keeps track 
of how many times it* 
18 
* has been called 
by i ncrementing 
a stat i c local 
* 
19 
* variable, 
numCalls , each time i t is called. 
* 
20 
**************************************************/ 
21 void showStat i c () 
22 { 
23 
stat i c int numCalls = O; 
II Stat i c local 
variable 
24 
25 
cout << "This funct i on has been called" 
26 
<< ++numCalls <<" times. 
"<< endl; 
27
) 
Program Output 
This 
This 
This 
This 
This 
function 
has been called 
1 times. 
function 
has been called 
2 times. 
function 
has been called 
3 times. 
function 
has been called 
4 times. 
function 
has been called 
5 times. 
In Progr am 6-21 numCal ls is defined and initialized to O in line 23. It is incremented in 
line 26 once each time the showStat i c function is called, and because it is a static 
variable, it retains its value between calls. You might think that every time the function 
is called, numCalls would be reinitialized to 0. But this does not happen because a 
variable is only initialized when it is first created, and stat ic variables are only created 
once during the running of the program. If we had not initialized numCa 11 s, it would 
automatically have been initializ ed to O because numeric static local variables, like 
global variab les, are initialized to O if the programmer does not initialize them. 

364 
Chapte r 6 
Functions 
~ 
Checkpoint 
6.16 
What is the difference between a static local variable and a global variab le? 
6.17 
What is the output of the following program? 
#include 
<iostream> 
us i ng namespace std; 
voi d myFunc(); 
// Function 
prototype 
i nt mai n() 
{ 
i nt var= 
100; 
} 
cout <<var<< 
endl; 
myFunc(); 
cout <<var<< 
endl; 
return 
O; 
// Defi nition 
of function 
myFunc 
voi d myFunc () 
{ 
i nt var= 
50 ; 
cout <<var<< 
endl; 
} 
6.18 
What is the output of the following program? 
#include 
<iostream> 
us i ng namespace std; 
voi d showVar (}; // Function 
prototype 
int mai n() 
{ 
for (int 
count= 
O; count< 
10; count++ ) 
showVar (); 
return 
O; 
} 
// Defi nition 
of function 
showVar 
voi d showVar () 
{ 
stat i c int var= 
10 ; 
cout <<var<< 
endl; 
var ++; 
} 
Default Arguments 
CONCEPT: 
Default argument s are pas sed to pa rame ters automa tically if no 
argument is provided in the function call. 
It's possible to assign default arguments to function parameters. A default argument is 
passed to the parameter when the actual argument is left out of the function call. The 
default arguments are usually listed in the function prototype. Here is an example: 
voi d showArea (dou ble length
= 20.0, 
doubl e width= 
10 .0); 
Because parameter names are not required in function prototypes, the example prototype 
could also be declared like this: 
voi d showArea (dou ble = 20.0, 
double= 
10.0); 

0 
6.12 Default Arguments 
365 
In either case, the default arguments, which must be literal values or constants, have an = 
operator in front of them. 
Notice that in both example prototypes, function showArea has two doub 1 e parameters. 
The first is assigned the default argument 20.0, and the second is assigned the default 
argument 10.0. Here is the definition of the function: 
voi d showArea(double length, 
double width) 
{ 
double area= 
leng th* 
width; 
cout << "The area is•<< 
area<< 
endl ; 
) 
The default argument for leng th is 20.0, and the default argument for width is 10.0. 
Because both parameters have default arguments, they may optionally be omitted in 
the function call, as shown here: 
showArea(); 
In this function call, both default arguments will be passed to the parameters. Parameter 
length will receive the value 20.0, and width will receive the value 10.0. The output of 
the function will be 
The area is 200 
Th e default arguments are only used when the actual arguments are omitted from 
the function call. In the following call, the first argument is specified, but the second 
is omitted: 
showArea(12 .0); 
The value 12.0 will be passed to length , while the default value 10.0 will be passed to 
wi dth. The output of the function will be 
The area is 120 
Of course, all the default arguments may be overridden. In the following function call, 
arguments are supplied for both parameters: 
showArea(12 .0, 5.5); 
The output of this function call will be 
The area is 66 
NOTE: 
A function's default arguments should be assigned in the earliest occurrence 
of the function name. This will usually be the function prototype. However, if a 
function does not have a prototype, default arguments may be specified in the function 
header. The showArea function could be defined as follows: 
void showArea(double leng th = 20 .0, double width= 
10.0) 
{ 
double area= 
lengt h * width; 
cout << "The area is•<< 
area<< 
endl; 
} 

366 
Chapte r 6 
Functions 
Program 6-22 illustrates the use of default function arguments . It has a function that 
displays asterisks on the screen. This function receives arguments specifying how many 
rows of asteris ks to display and how many asterisks to print on each row. Default 
arguments are provided to display one row of 10 asterisks. 
Program 6-22 
1 II Thi s program demonstrates 
the use of defau l t f unction 
arguments . 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototype 
with default 
arguments 
6 void displayStars
(int starsPerRow 
= 10, int numRows = 1); 
7 
8 int main() 
9 { 
10 
displayStars(); 
II starsPerRow & numRows use defaults 
(10 & 1) 
11 
cout << endl; 
12 
displayStars(5); 
II starsPerRow 
5. numRows uses defa ult value 
1 
13 
cout << endl; 
14 
displayStars(7, 
3); II starsPerRow 
7. numRows 3. No defaults 
used . 
15 
return 
O; 
16 } 
17 
18 /*********************************************************** 
* 
* 
19 
20 
21 
22 
* 
* 
disp l ayStars 
This function 
displays 
a rectang le 
If arguments are not passed to i t, 
arguments 
10 for starsPerRow 
and 1 
made of asterisks. 
* 
i t uses the default* 
* 
fo r numRows. 
* 
23 
***********************************************************/ 
24 void displayStars
(int starsPerRow, 
i nt numRows) 
25 { 
26 
27 
28 
29 
30 
31 
32 
33 
34 } 
II Nested loop . The outer 
loop controls 
the rows and 
II the inner 
loop controls 
the number of stars 
per row . 
for (i nt row = 1 ; row<= numRows; row++) 
{ 
} 
for (int star= 
1 ; star<
= starsPerRow; 
star++ ) 
cout << 
I* 
I• 
' 
cout << end l; 
Program Output 
* * ******
* * 
* * *** 
* * ***** 
* * ***** 
* * ***** 

6.12 Default Arguments 
367 
Although C++'s default arguments are very conven ient, they are not totally flexible in 
their use. When an argument is left out of a function call, all arguments that come after 
it must be left out as well. In the di splayStars 
function in Program 6-22, it is not 
possible to omit the argument for starsPerRow without also omitting the argument for 
numRows. For examp le, the following function call would be illegal: 
displayStars
(, 3); 
// Illegal 
function 
call! 
It is possible, however, for a function to have some parameters with default arguments 
and some without. For examp le, in the following function, only the last parameter has 
a default argument: 
// Function 
prototype 
voi d calcPay (int 
empNum, double payRate, 
double hours= 
40.0); 
// Defi nition 
of function 
calcPay 
voi d calcPay (int 
empNum, double payRate, 
double hours) 
{ 
double wages; 
wages= 
payRate * hours; 
cout << "Gross pay for employee number" ; 
cout << empNum <<•is•<< 
wages<< endl; 
} 
When calling this function, arg uments must always be specified for the first two 
parameters (empNum and payRate) because they have no default arguments . Here are 
examples of valid calls: 
cal cPay ( 769 , 15. 75) ; 
calcPay(142, 
12.00, 20}; 
// Uses default 
argument for hours 
// Specifies 
number of hours 
When a function uses a mixture of parameters with and without default arguments, the 
parameters with default arguments must be declared last. In the cal cPay function, 
hours could not have been declared before either of the other parameters. The following 
prototypes are illegal: 
// Illegal 
prototype 
voi d calcPay (int 
empNum, double hours
= 40 .0, double payRate); 
// Illegal 
prototype 
voi d calcPay (double hours= 
40.0, 
int empNum, double payRate); 
Here is a summary of the important points about default arguments: 
• The value of a default argument must be a literal value or a named constant . 
• When an argument is left out of a function call (because it has a default value), all 
the arguments that come after it must also be left out. 
• When a function has a mixture of parameters both with and without default 
arguments, the parameters with default arguments must be defined last. 

368 
Chapter 6 
Functions 
Using Reference Variables as Parameters 
CONCEPT: 
A reference variable is a variable that references the memory locatio n of 
anoth er variable. Any change made to the reference variable is actually 
made to the one it references. Reference variables are sometimes used as 
function par ameters. 
Earlier you saw that arguments are normally passed to a function by value. This means 
that parameters receive only a copy of the value sent to them, which they store in the 
function's local memory. Any changes made to the parameter's value do not affect the 
value of the original argument. 
Sometimes, however, we want a function to be able to change a value in the calling 
function (i.e., the function that called it). This can be done by making the parameter a 
reference variable. 
You learned in Chapter 1 that variables are the names of memory locations that may 
hold data . When we use a variable we are accessing data stored in the memory location 
assigned to it. A reference variable is an alias for another variable . Instead of having its 
own memory location for storing data, it accesses the memory locat ion of anot her 
variable . Any change made to the reference variable's data is actually made to the data 
stored in the memory location of the other variable. When we use a reference variable 
as a parameter, it becomes an alias for the corresponding variable in the argument list. 
Any change made to the parameter is actually made to the variable in the calling 
function. When data is passed to a parameter in this manner, the argument is said to be 
passed by reference . 
Reference variab les are defined like regular variables, except there is an ampersand (&) 
between the data type and the name . For example, the following function definition 
makes the parameter refVar a reference variable: 
void doubleNum(i nt &refVar ) 
{ 
refVar *= 2 ; 
) 
You may place the space either before or after the ampersand . The doubl eNum function 
heading could also have been written like this: 
void doubleNum(i nt& refVar ) 
0 
NOTE: The variable refVar is called "a reference to an int ." 
This function doubles refVar by mult iplying it by 2. Because refVar is a reference 
variab le, this action is actua lly performed on the variable that was passed to the 
function as an argument . 
The prototype for a function with a reference parameter must have an ampersand as 
well. As in the function header, it goes between the data type and the variable name. 

6.13 Using Reference Variables as Parameters 
369 
If the variable name is omitted from the prototype, the ampersand simply follows the 
data type. All of the following prototypes for the doub 1 eNum function are correct. 
voi d doubleNum(int 
&refVar ); 
voi d doubleNum(int& refVar ); 
voi d doubleNum(i nt &); 
voi d doubleNum(i nt&); 
Your instructor will let you know which form to use. 
0 
NOTE: The ampersand must appear in both the prototype and the header of any function 
that uses a reference variable as a parameter. It does not appear in the function call. 
Program 6-23 demonstrates the use of a parameter that is a reference variable. 
Program 6-23 
1 II Thi s program uses a reference 
variable 
as a funct i on parameter. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototype. 
The parameter 
i s a reference 
variable. 
6 void doubleNum(int 
&refVar ); 
7 
8 int main() 
9 { 
10 
int value= 
4; 
11 
12 
cout << "In main, value is"<< 
value<< 
endl ; 
13 
cout << "Now call i ng doubleNum ... " << endl ; 
14 
doubleNum(value); 
15 
cout << "Now back in mai n, value is"<< 
value<< 
endl; 
16 
return 
O; 
17 } 
18 
19 /************************************************************** 
20 
* 
doubleNum 
* 
21 
* Thi s funct i on's parameter 
is a reference 
variable. 
The & 
* 
22 
* tells 
us that . Thi s means it receives 
a reference 
to the 
* 
23 
* or i ginal 
variable 
passed to it, 
rather 
than a copy of that* 
24 
* variable's 
data. 
The statement 
refVar *= 2 is doubl i ng the* 
25 
* data stored 
in the value variable 
defined 
in mai n. 
* 
26 
**************************************************************/ 
27 void doubleNum (int &refVar ) 
28 { 
29 
refVar *= 2; 
30
} 
Program Output 
In main, value is 4 
Now calling 
doubleNum. 
Now back in main, value is 8 

3 70 
Chapte r 6 
Functions 
Th e parameter refVar in Program 6-23 "points" to the value variab le in function 
main. When a program works with a reference variable, it is actually working with the 
variable it references, or points to. This is illustrated in Figure 6-14. 
Figure 6-14 
Original argument 
4 
Reference variable 
Using reference variables as function parameters is especially useful when the purpose 
of the function is to accept input values to be stored in variables of the calling function. 
Another use of reference parameters is when multiple values must be sent back from 
the function. If the function is computin g and sending back a single value, it is generally 
considered more appropriate to use a value-returning function and send the value back 
with a return statement . 
Program 6-24 is a modification of Program 6-23. It adds a function getNum, which 
accepts an input from the user and stores it in userNum. However, the parameter userNum 
is a reference to mai n' s variable value, so that is where the input data is actually stored. 
Program 6-24 also rewrites the function doub l eNum as a value-returnin g function . 
Notice in line 19 how main must now store the value when doubl eNum returns it. 
Program 6-24 
1 II Thi s program uses 2 functions: 
a void function 
with a reference 
2 II variable 
as a parameter, 
and a value-returning 
function
. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototypes 
7 void getNum(int 
&); 
8 int doub l eNum(int ); 
9 
10 int main() 
11 { 
12 
int value; 
13 
14 
II Cal l getNum to get a number and store 
it in value 
15 
getNum(value); 
16 
17 
II Cal l doub l eNum, passing 
it the number stored 
in value 
18 
II Ass i gn value the number returned 
by the function 
19 
value= 
doub l eNum(value ); 
20 
21 
22 
23 
24
} 
25 
II Display 
the result
i ng number 
cout << "That value doubled is"<< 
value<< 
endl; 
return 
O; 
(program continues) 

6.13 Using Reference Variables as Parameters 
3 71 
Program 6-24 
(continued) 
26 /********************************************************** 
27 
* 
getNum 
* 
28 
* Thi s funct i on stores 
user input data 
in main's 
value 
* 
29 
* variable 
by using a reference 
variable 
as a parameter. 
* 
30 
**********************************************************/ 
31 void getNum(int 
&userNum) 
32 { 
33 
cout << "Enter 
a number: "· 
34 
cin 
>> userNum; 
35
} 
36 
37 /*********************************************************** 
38 
* 
doubleNum 
* 
39 
* Thi s funct i on doubles 
the number it receives 
as an 
* 
40 
* argument and returns 
i t to main thru a return 
statement.* 
41 
***********************************************************/ 
42 int doubleNum (int 
number} 
43 { 
44 
return 
number* 
2 ; 
45
} 
Program Output with Example Input Shown in Bold 
Enter a number: 
12[Enter] 
That value doubled 
is 24 
<) 
CD 
NOTE: 
Only var iables may be passed by referenc e. If you attempt to pass a 
nonvariable argument, such as a literal, a constant, or an express ion, into a reference 
parameter, an error will result. 
If a function has more than one parameter that is a reference var iable, you must use an 
ampersand for each of them in both the prototype and the function header. Here is the 
prototype for a function that uses four reference variable parameters: 
voi d addThree (i nt& num1, int& num2, i nt& num3, i nt& sum); 
and here is the function definition: 
voi d addThree (i nt& num1, int& num2, i nt& num3, i nt& sum) 
{ 
} 
cout << "Enter 
three 
integer 
values: 
"· 
cin 
>> num1 >> num2 >> num3; 
sum= num1 + num2 + num3; 
Notice, 
however, 
that the addThree 
function 
really needed only one reference 
parameter, 
sum. Th e other three parameters could have received their arguments by 
value because the function was not changing them. 
WARNING! 
Only use reference var iables where they are absolutely needed. Any 
time you allow a function to alte r a variable that's outside the function, you are 
creating potential debugging problems. 

3 72 
Chapte r 6 
Functions 
When to Pass Arguments by Reference and When 
to Pass Arguments by Value 
New programmers often have a problem determining when an argument should be 
passed to a function by reference and when it should be passed by value. The problem 
is further compounded by the fact that if a value must be "sent back" to the calling 
function there are two ways to do it: by using a reference parameter or by using a 
return statement. Here are some general guidelines. 
• When an argument is a constant, it must be passed by value. Only variables can 
be passed by reference. 
• When a variable passed as an argument should not have its value changed, it 
should be passed by value. This protects it from being altered. 
• When exactly one value needs to be "sent back" from a function to the calling 
routine, it should generally be returned with a return 
statement rather than 
through a reference parameter. 
• When two or more variables passed as arguments to a function need to have their 
values changed by that function, they should be passed by reference. 
• When a copy of an argument cannot reasonably or correctly be made, such as 
when the argument is a file stream object, it must be passed by reference. 
Here are three common instances when reference parameters are used. 
• When data values being input in a function need to be known by the calling function 
• When a function must change existing values in the calling function 
• When a file stream object is passed to a function 
Program 6-25 illustrates the first two of these uses. The getNums function uses reference 
variables as parameters so that it can store the values it inputs into the main function's 
sma 11 and bi g variables . The orderNums function uses reference variables as parameters 
so that when it swaps the two items passed to it, the values will actually be swapped in 
the main function. 
Program 6-25 
1 II Thi s program illustrates 
two appropr i ate uses 
2 II of passing 
arguments 
by reference. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 II Function 
prototypes 
7 void getNums (int&, 
i nt&); 
8 
9 
10 
11 void orderNums(int&, 
int&); 
12 
13 
II Uses reference 
parameters 
to input 
II values 
in the funct i on, but to actually 
II store 
them in variables 
defined 
in main 
II Uses reference 
parameters 
to change the 
II values 
of exist i ng values 
stored 
in main 
(program continues) 

6.13 Using Reference Variables as Parameters 
3 73 
Program 6 -25 
14 int main() 
15 { 
(continued) 
16 
int small, 
big; 
17 
18 
II Call getNums to input the two numbers 
19 
getNums(small, 
big ); 
20 
21 
II Call orderNums to put the numbers in order 
22 
orderNums (s mall , big ); 
23 
24 
25 
26 
II Di splay 
cout 
<< 
the new values 
"The two input 
small <<" 
and 
numbers ordered 
smallest 
to biggest 
are" 
<< 
" <<b i g<< endl; 
27 
return 
O; 
28 ) 
29 
30 /********************************************************** 
31 
* 
getNums 
* 
32 
* The arguments 
passed i nto input1 and input2 are passed* 
33 
* by reference 
so that 
the values 
entered 
into them wi ll * 
34 
* actually 
be stored 
in the memory space of main's 
small * 
35 
* and big variables. 
* 
36 
**********************************************************/ 
37 void getNums( i nt &input1 , int &input2 ) 
38 { 
39 
40 
41 
42 
43 ) 
44 
cout 
cin 
cout 
cin 
<< "Enter 
>> i nput 1 ; 
<< "Enter 
>> i nput2; 
an integer: 
". 
a second integer: 
". 
45 /********************************************************** 
* 
orderNums 
* The arguments 
passed i nto num1 and num2 are passed by 
* reference 
so that 
if they are out of order mai n's 
* variables 
small and bi g can be swapped. Just 
swapping 
* num1 and num2 in orderNum's 
local 
memory would not 
* accomplish 
the desired 
result. 
* 
* 
* 
* 
* 
* 
46 
47 
48 
49 
50 
51 
52 
53 
**********************************************************/ 
void orderNums (int &num1, int &num2) 
54 { 
55 
int temp; 
56 
if (num1 > num2) 
57 
II 
If the numbers are out of order, 
swap them 
58 
59 
60 
61 
62 } 
{ 
} 
temp = num1; 
num1 = num2; 
num2 = temp ; 
Program Output With Example Input Shown In Bold 
Enter an integer: 
lO[Ent er] 
Enter a second integer: 
S[Enter] 
The two input 
numbers ordered 
smallest 
to biggest 
are 5 and 10 

3 74 
Chapte r 6 
Functions 
Passing Files to Functions 
As mentioned previously, reference parameters should always be used when a file 
stream ob ject is passed to a function. Program 6-26 illustrates how to pass a file to a 
function. The weather. dat file used by the program contains the following seven 
values: 72 83 71 69 75 77 70. It can be found in the Chapter 6 programs folder on 
the book's companion website. 
Program 6-26 
1 II Thi s program reads a set of daily 
high temperatures 
from a file 
2 II and displays 
them. It demonstrates 
how to pass a file 
to a 
3 II function. 
The funct i on argument, 
which is a f i l e stream object
, 
4 II must be passed by reference. 
5 #include 
<iostream> 
6 #include 
<fstream> 
7 using namespace std ; 
8 
9 void readFile(ifstream&); 
10 
11 int main() 
12 { 
13 
ifstream 
inputF i l e ; 
14 
15 
inputF i le .open("weather.dat"); 
16 
if (inputF i le .fail ()) 
II Funct i on prototype 
17 
cout << "Error opening data f i le . \n"; 
18 
els e 
19 
{ 
readFile(inputFile); 
20 
inputFile.close(); 
21 
} 
22 
return 
O; 
23
} 
24 
25 /******************************************************** 
26 
* 
readFile 
* 
27 
* Thi s funct i on reads and displays 
the contents 
of the* 
28 
* input file 
whose file 
stream object 
i s passed to i t. 
* 
29 
********************************************************/ 
30 void readFile(ifstream 
&someFil e ) 
31 { 
32 
int temperature; 
33 
34 
whi le (someFile 
>> temperature) 
35 
cout <<temperature<<" 
"· 
36 
cout << endl; 
37
} 
Program Output 
72 
83 
71 
69 
75 
77 
70 

6.13 Using Reference Variables as Parameters 
3 75 
It is also possible to pass an opened file to a function and have it read just part of the file 
each time it is called. Program 6-27 provides an example . Each time the readData 
function is called, it reads the next line of the file. It stores the input data in reference 
parameters so that the main function will be able to see and use this data . The rainfall 
. 
dat file that Program 6-27 reads from can be found, along with the source code for all 
the chapter programs, in the Chapter 6 programs file on the book's companion website. 
Program 6-27 
1 II Thi s program displays 
a tab l e of July rainfall 
totals 
for several 
2 II Ameri can ci ties. 
It calls 
a function 
to read the data from a f i le 
3 II one line 
at a time. 
The data values 
are stored 
i n reference 
4 II parameters 
so they can be seen and used by the main function. 
5 #include 
<iostream> 
6 #include 
<str i ng> 
7 #include 
<fstream> 
8 #include 
<iomanip> 
9 using namespace std ; 
10 
11 II Function 
prototype 
12 bool readData(ifstream 
&someFi l e , string 
&city , double &rain ); 
13 
14 int main() 
15 { 
16 
ifstream 
inputF i le; 
17 
string 
city ; 
18 
double inchesOfRa i n; 
19 
20 
II Di splay tab le head i ngs 
21 
cout << "July Rainfall 
Tota l s fo r Selected 
Cities 
\ n\ n"; 
22 
cout <<" 
City 
Inches \n"; 
23 
cout <<" --------
\n"; 
24 
25 
II Open the data file 
26 
inputF i le .open("rainfall 
.dat"); 
27 
if (inputF i le .fail()) 
28 
cout << "Error opening data f i le . \n"; 
29 
els e 
30 
{ 
II Call the readData 
function 
31 
II Execute the lo op as long as it found and read data 
32 
while 
(r eadData (inp utFi le , city, 
i nchesOfRain) == true) 
33 
{ 
34 
35 
36 
37 
} 
cout << setw(11) 
<<left<< 
city; 
cout <<f i xed<< 
showpoint << setprecis
i on(2) 
<< inchesOfRain 
<< endl; 
38 
inputFile.close(); 
39 
} 
40 
return 
O; 
41 } 
42 
(program continues) 

3 76 
Chapte r 6 
Functions 
Program 6-27 
(continued) 
43 /******************************************************** 
44 
* 
readData 
* 
45 
* Each t i me i t is called 
this 
function 
reads the next 
46 
* one line 
of data from the input file 
passed to i t. 
* 
* 
47 
48 
49 
50 
* It stores 
the input data in reference 
variables. 
* 
* Then , i f it read data , it returns 
true. 
If there 
was * 
* no more data in the f i le to read , i t returns 
false
. 
* 
********************************************************/ 
51 bool readData(ifstream 
&someFile , string 
&city, 
double &rain ) 
52 { 
53 
bool foundData = someFile >>city>> 
rain; 
54 
return 
foundData; 
55 } 
Program Output 
July Rainfall 
Totals 
for Selected 
Cities 
City 
Chicago 
Tampa 
Houston 
Inches 
3.70 
6.49 
3.80 
Checkpoint 
6.19 
What kind s of values may be specified as default arguments? 
6.20 
Write the prototype and header for a function called compute that has three parameters: 
an int, a double, and a long (not necessarily in that order). The i nt parameter should 
have a default argument of 5, and the long parameter should have a default argument 
of 65536. The double parameter should not have a default argument. 
6.21 
Write the prototype and header for a function called calculate 
that has three 
parameters: an int, a reference to a double, and a long (not necessarily in that 
order.) The i nt parameter should have the default argument 47. 
6.22 
What is the output of the following program? 
#include 
<iostream> 
us i ng namespace std; 
voi d test
(int 
= 2 , i nt= 
4, int= 
6}; 
i nt mai n(} 
{ 
} 
test(}; 
test(6); 
test(3, 
9}; 
test(1, 
5, 7); 
return 
O; 

6.13 Using Reference Variables as Parameters 
377 
voi d test 
(in t first, 
int second, 
int third) 
{ 
first 
+= 3; 
second
+= 6 ; 
th ird
+= 9; 
cout <<first<<" 
"<<second<<" 
"<<th
ird
<< endl ; 
} 
6.23 
The following program asks the user to enter two numbers. What is the output 
of the program if the user enters 12 and 14? 
#include 
<iostream> 
us i ng namespace std; 
voi d func1(int 
&, int&); 
voi d func2(int 
&, int&, 
int&); 
voi d func3(int, 
int, 
i nt}; 
i nt mai n(} 
{ 
int 
X = 0, y = 0, z = o· ' 
cout << X << • • << y << z << 
func1 (x, y); 
cout << X << • • << y << z << 
func2 (x, y, 
z ); 
endl; 
endl; 
cout << x <<" 
"<< 
y << z << endl; 
func3 (x, y, z ); 
} 
cout << x <<" 
"<< 
y << z << endl; 
return 
O; 
voi d func1(int 
&a, i nt &b) 
{ 
cout << "Enter two numbers: 
"· 
cin 
>>a>> 
b; 
} 
voi d func2(int 
&a, i nt &b, int &c) 
{ 
b++· ' 
c- - . ' 
a= 
b + c ; 
} 
voi d func3(int 
a, int b, int c) 
{ 
a= 
b - c ; 
} 

3 78 
Chapte r 6 
Functions 
Overloading Functions 
CONCEPT: 
Two or more functions may have the same name , as long as their 
parame ter lists are different. 
Sometimes you will create two or more functions that perform the same operation but use a 
different set of parameters, or parameters of different data types. For instance, in Program 
6-12 there is a square function that uses a double parameter. But supp ose you also wanted 
a square function that works exclusively with integers and accepts an int as its argument. 
Both functions wou ld do the same thing: return the square of their argument . Th e only 
difference is the data type involved in the operation . If you were to use both of these functions 
in the same program , you could assign a unique name to each function. For example, one 
might be named square Int and the other one named squareDoubl e. C++, however , allows 
you to overload function names. That means you may assign the same name to multiple 
functions as long as their parameter lists are different. Program 6-28 illustrates this. 
Program 6-28 
1 // Thi s program uses overloaded 
functions. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 using namespace std ; 
5 
6 II Function 
prototypes 
7 int 
square( i nt); 
8 double square(double); 
9 
10 int main() 
11 { 
12 
13 
14 
int userlnt; 
double userReal; 
15 
// Get an i nt and a double 
16 
cout << "Enter 
an integer 
and a f lo ating-point 
value: 
"· 
17 
cin 
>> userlnt 
>> userReal; 
18 
19 
// Display 
thei r squares 
20 
cout << "Here are the i r squares
: "· 
21 
cout <<fixed<< 
showpoi nt << setprecision(2); 
22 
cout << square(userlnt) 
<<"and"<< 
square(userReal) 
<< endl; 
23 
return 
O; 
24
) 
25 
26 /*************************************************** 
27 
* 
overloaded 
function 
square 
28 
* Thi s funct i on returns 
the square 
of the value 
29 
* passed 
into 
its 
int parameter. 
* 
* 
* 
30 
***************************************************/ 
31 int 
square( i nt number) 
32 { 
33 
34
) 
return 
number* 
number; 
(program continues) 

6.14 Overloading Functions 
3 79 
Program 6-28 
35 
(continued) 
36 /*************************************************** 
37 
* 
overloaded 
function 
square 
* 
38 
* Thi s funct i on returns 
the square of the value 
39 
* passed into its 
double parameter. 
* 
* 
40 
***************************************************/ 
41 double square(double 
number) 
42 { 
43 
return 
number* 
number; 
44 ) 
Program Output with Example Input Shown in Bold 
Enter an integer 
and a floating-point 
value: 
12 4.2[Enter] 
Here are their 
squares: 
144 and 17.64 
Here are the headers for the square functions used in Program 6-28: 
int square(int 
number) 
double square (double number) 
In C++, each function has a signatu re. Th e function signature is the name of the 
function and the data types of the function's parameters in the proper order. Th e 
square functions in Program 6-28 would have the following signature s: 
square(int) 
square(double) 
When an overloaded function is called, C++ uses the function signature to distinguish 
it from other functions with the same name . In Program 6-28, when an int argument 
is passed to square, the version of the function that has an i nt parameter is called. 
Likewise, when a double argument is passed to square , the version with a double 
parameter is called . 
Note that the function's return value is not part of the signature. The following functions 
could not be used in the same program because their parameter lists aren't different . 
i nt square(int 
number) 
{ 
return 
number* 
number 
) 
double square (i nt number) 
II Wrong! Parameter 
lists 
must differ 
{ 
return 
number* 
number 
) 
Overloading is also conven ient when there are similar functions that use a different 
number of parameters. For example, consider a program with functions that return the 
sum of integers. One returns the sum of two integers, another returns the sum of three 
integers, and yet another returns the sum of four integers. Here are their function headers: 
i nt sum(i nt num1, int num2) 
i nt sum (i nt num1 , int num2, int num3) 
i nt sum (i nt num1 , int num2, int num3, int num4) 

380 
Chapte r 6 
Functions 
Because the number of parameters is different in each, they may all be used in the same 
program. Program 6-29 uses two functions, each named calcWeeklyPay , to determine 
an employee's gross weekly pay. One version of the function uses an int and a double 
parameter , while the other version only uses a double parameter. 
Program 6-29 
1 II Thi s program demonstrates 
overloaded 
functions 
to calculate 
2 II the gross weekly pay of hourly-wage 
or salaried 
employees. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std; 
6 
7 II Function 
prototypes 
8 char getCho i ce(); 
9 double calcWeeklyPay(int, 
double); 
10 double calcWeeklyPay(double); 
11 
12 int main() 
13 { 
14 
15 
16 
17 
18 
char selection; 
int worked; 
double rate, 
yearly; 
II Menu selection 
II Weekly hours worked 
II Hourly pay rate 
II Annual salary 
19 
II Set numeric output 
formatting 
20 
cout <<fixed<< 
showpoint << setprecision(2); 
21 
22 
II Di splay the menu and get a select
i on 
23 
cout << "Do you want to calculate 
the weekly pay of\n"; 
24 
cout << "(H) an hourly-wage 
employee, or \n"; 
25 
cout << "(S) a salaried 
employee?"· 
26 
select
i on= getChoice(); 
27 
28 
II Process 
the menu selection 
29 
swi tch (selection) 
30 
{ 
31 
II Hourly employee 
32 
case 'H' 
33 
34 
35 
36 
37 
38 
39 
40 
case 'h' 
: 
cout << 
cin 
>> 
cout << 
cin 
>> 
cout << 
cout << 
break; 
"How many hours were worked?"; 
worked; 
"What is the hourly pay rate?"· 
rate; 
"The gross weekly pay is$"; 
calcWeeklyPay(worked, 
rate)<< 
endl; 
(program continues) 

6.14 Overloading Functions 
381 
Program 6-29 
(continued) 
41 
42 
43 
44 
45 
46 
47 
II Salaried 
employee 
case ·s· 
case 's' 
: 
} 
48 
return 
O; 
49
} 
50 
cout << "What is the annual salary? 
"; 
cin 
>> yearly; 
cout << "The gross weekly pay is $ •; 
cout << calcWeeklyPay(yearly) 
<< endl ; 
51 
52 
53 
54 
55 
56 
57 
/***************************************************** 
* 
getChoice 
* 
* Accepts and returns 
user's 
validated 
menu choice. 
* 
*****************************************************/ 
58 
char getCho i ce() 
{ 
char letter; 
II Holds user's 
letter 
choice 
59 
II Get the user's 
cho i ce 
60 
cin >> letter; 
61 
62 
II Val i date the cho i ce 
63 
whi le (letter 
!= 'H' && letter 
!= 'h' 
64 
&& letter 
!= 'S' && letter 
!= ' s ') 
65 
{ 
66 
cout 
<< "Enter 
Hor S: "· 
67 
ci n 
>> letter
; 
68 
} 
69 
II Return the cho i ce 
70 
return 
letter; 
71 } 
72 
73 /************************************************************* 
74 
* 
overloaded 
function 
calcWeeklyPay 
* 
75 
* Thi s funct i on calculates 
and returns 
the gross weekly pay* 
76 
* of an hourly-wage 
employee . Parameters 
hours and payRate 
* 
77 
* hold the number of hours worked and the hourly pay rate. 
* 
78 
*************************************************************/ 
79 double calcWeeklyPay(int 
hours, 
double payRate ) 
80 { 
81 
return 
hours* 
payRate; 
82
} 
83 
84 
85 
86 
/************************************************************* 
* 
overloaded 
function 
calcWeeklyPay 
* Thi s funct i on calculates 
and returns 
the gross weekly 
* of a salar i ed employee . The parameter 
annSalary 
holds 
* employee ' s annual salary
. 
* 
pay* 
the
* 
* 
87 
88 
89 
90 
91 
92 
93
} 
*************************************************************/ 
double calcWeeklyPay(double 
annSalary) 
{ 
return 
annSalary 
I 52.0; 
(program continues) 

382 
Chap ter 6 
Functions 
Program 6-29 
(continued) 
Program Output with Example Input Shown in Bold 
Do you want to ca l culate 
the weekly pay of 
(H) an hourly-wag e employe e , or 
(S) a salaried 
employee? 
H[Ent er] 
How many hours were worked? 40[Enter] 
What is the hourly 
pay rate? 
18 .SO[Enter] 
The gross weekly pay i s $740.00 
Program Output with Other Example Data Shown in Bold 
Do you want to calculate 
the weekly pay of 
(H) an hourly-wage 
employee , or 
(S) a salaried 
employee? 
S[Enter] 
What is the annual 
salary? 
48000 .00[Enter] 
The gross weekly pay is $923.08 
6.15 
The exit () Function 
CONCEPT: 
Th e exit() 
fun ction cau ses a progra m to termina te, regar dless of 
which fun ction or contr ol mechanism is executing. 
A C++ progra m stops exec utin g when a re t ur n statement in fun ction mai n is 
encount ered . When oth er fun ctions end, however , th e program does not stop. Contr ol 
of th e pr ogram goes bac k to th e place imm ediately followin g th e fun ction call. 
Sometim es, howeve r, rare circumstances make it necessa ry to termin ate a program in a 
function oth er th an main . To acco mpli sh this, the exit function is used . 
Wh en the exit function is ca lled, it causes th e progra m to stop, regardl ess of which 
function contains th e call. Program 6-30 demonstra tes this effect. 
Program 6-30 
1 II Thi s program shows how the exit 
function 
causes 
a program 
2 II t o stop exec ut ing. 
3 #inc l ude <iostream> 
4 #inc l ude <cs t dlib> 
II Needed to use the exi t f unction 
5 using namespace std ; 
6 
7 II Function 
prototype 
8 void someFunction
(); 
9 
10 int main () 
11 { 
12 
someFunction
(); 
13 
return 
O; 
14 ) 
15 
(program continues) 

6.15 The exit () Function 
383 
Program 6-30 
(continued) 
16 /**************************************************************** 
17 
* 
someFunct i on 
* 
18 
* Thi s funct i on demonstrates 
that 
exi t( ) can be used to end 
* 
19 
* a program from a function 
other than main . This is not 
* 
20 
* considered 
good programming practice 
and should normally 
* 
21 
* be done only to si gnal that 
an error 
condition 
has occurred. 
* 
22 
****************************************************************/ 
23 void someFunction() 
24 { 
25 
cout << "This program terminates 
with the exit 
function.
\n"; 
26 
cout << "Bye!\n"; 
27 
exi t(O); 
28 
cout << "This message will 
never be displayed
\n"; 
29 
cout << "because the program has already 
terminated.
\ n"; 
30
) 
Program Output 
This program terminates 
with the exit 
function. 
Bye! 
CD 
To use the exi t function, you must include the cstdl i b header file. Not ice the function 
takes an integer argument. This argument is the exit code you wish the program to pass 
back to the computer's operating system. This code is sometimes used outside of the pro-
gram to indicate whether the program ended successfully or as the result of a failure. In 
Program 6-30, the exit code zero is passed. This code, which is also normally used in the 
return statement at the end of a program's main function, indicates a successful program 
termination. Another way to signal this is to use the C++ named constant EXIT_SUCCESS. 
This constant, which is defined in cstdl i b, is used with the exi t function like this: 
exi t(EXIT _SUCCESS); 
However, because it is considered good programming practice to always terminate a 
program at the end of the main function where possible, many programmers 
use 
exit () only to handle error condit ions. In this case, the error code should indicate that 
a problem has occurred. Thi s can be done by using another C++ named constant, 
EXIT_FAILURE. This named constant, also defined in cstdl i b, is defined as the termi -
nation code that commonly represents an unsuccessful exit under the current operating 
system . Here is an examp le of its use: 
exi t(EXIT _FAILURE); 
WARNING! 
The exit() 
function unconditionally 
shuts down your program. 
Because it bypasses a program's normal logical flow, you shou ld use it with caution. 

384 
Chapter 6 
Functions 
~ 
Checkpoint 
6.24 
Is it required that overloaded functions have different return types, different 
parameter lists, or both? 
6.25 
What is the output of the following program code? 
voi d showVals (double, double); 
int mai n() 
{ 
double x = 1 .2, y = 4.5; 
showVals(x, 
y); 
return 
O; 
) 
voi d showVals (double p1, double p2) 
{ 
) 
cout << p1 << endl ; 
exi t (O); 
cout << p2 << endl ; 
6.26 
What is the output of the following program code? 
int manip (int); 
i nt manip (int, 
i nt); 
i nt manip (int, 
double ); 
int mai n() 
{ 
) 
i nt x = 2 , y= 4, z ; 
double a = 3.1; 
z = manip (x) + manip (x, y) + mani p(y, a); 
cout << z << endl; 
return 
O; 
int manip (int val) 
{ 
return 
val+ 
val * 2; 
) 
i nt manip (int val1, 
int val2) 
{ 
return 
(val 1 + val2) 
* 2 ; 
) 
i nt manip (int val1, 
double val2) 
{ 
return 
val1 * static
_cast< i nt>(val2); 
) 

6.16 
6.16 Stubs and Drivers 
385 
Stubs and Drivers 
Stubs and drivers are very helpful tools for testing and debugging programs that use 
functions. Th ey allow you to test the individual functions in a program, in isolation 
from the parts of the program that call the functions. 
A stub is a dummy function that is called instead of the actual function it represents. It 
usually displays a test message acknowledging that it was called, and nothing more. 
For example, if a stub were used for the showFees function in Program 6-14 (the 
modular health club membership program ), it might look like this: 
// Stub for the showFees function 
voi d showFees (str i ng memberType, double rate, 
int months ) 
{ 
cout << "The funct i on showFees was called 
with arguments: \n" 
<< "Member type: 
" 
<< memberType << endl 
<< "r ate: 
"<<rate<< 
endl 
<< "months: "<<mon ths<< 
endl; 
) 
Here is example outp ut of the program if it were run with this stub instead of with the 
actual showFees function. Input is shown in bold. 
Health Club Membership Menu 
1. Standard 
Adult Membership 
2. Chi ld Membership 
3. Senior Citizen 
Membership 
4. Quit the Program 
1 [Ent er] 
For how many months? 3[Ent er] 
The function 
showFees was called 
with arguments: 
Member type: Adult 
rate: 
120 .00 
months: 3 
Health Club Membership Menu 
1. Standard 
Adult Membership 
2. Chi ld Membership 
3. Senior Citizen 
Membership 
4. Quit the Program 
4(Ent er] 
As you can see, by replacing an actual function with a stub, you can concentrate your 
testing efforts on the parts of the program that call the function. Primarily, the stub 
allows you to determine whether your program is calling a function when you expect it 
to and confirm that valid values are being passed to the function. If the stub represents 
a function that returns a value, then the stub shou ld return a test value. This helps you 
confirm that the return value is being handled properly. When the parts of the program 
that call a function are debugged to your satisfaction, you can move on to testing and 
debugging the actual functions themselves. This is where drivers become useful. 
A driver is a program that tests a function by simply calling it. If the function accepts any 
arguments, the driver passes test data. If the function returns a value, the driver displays 

386 
Chapte r 6 
Functions 
the return value on the screen . Thi s allows you to see how the function performs in 
isolation from the rest of the program it will eventually be part of. Program 6-31 is a 
driver for testing the showFees function in the health club membership program. 
Program 6-31 
1 II Thi s program is a driver 
for testing 
the showFees function. 
2 #include 
<iostream> 
3 #include 
<str i ng> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 void showFees(string, 
double , int); 
8 
9 int main() 
10 { 
11 
cout << "Calling 
the showFees f unction 
with arguments 
" 
12 
<< "Adult, 
120.0, 
3 . \n"; 
13 
showFees ("Adult" , 120.0, 
3); 
14 
15 
cout << "Calling 
the showFees f unction 
with arguments 
" 
16 
<< "Child, 
60 .0, 2. \n"; 
17 
showFees ("Chi ld" , 60 .0, 2); 
18 
19 
cout << "Calling 
the showFees f unction 
with arguments 
" 
20 
<< "Senior, 
100 .0, 4.\n"; 
21 
showFees ("Senio r", 
100 .0, 4); 
22 
23 
ret urn O; 
24 } 
25 
26 /******************************************************* 
27 
* 
showFees 
* 
28 
* Thi s funct i on uses the membership 
type, 
monthly 
* 
29 
* rate and number of months passed to i t as arguments* 
30 
* to compute and pr i nt a member 's total 
charges. 
* 
31 
*******************************************************/ 
32 void showFees(string 
memberType, double rate , int months ) 
33 { 
34 
35 
36 
37 
38 
39 
40 } 
cout << 
<< 
<< 
<< 
<< 
<< 
endl 
"Membershi p Type 
"Monthly rate$" 
"Number of months : 
"Total 
charges 
endl << endl ; 
Program Output 
" << memberType << " 
" 
<< rate 
<< endl 
" << months << endl 
$"<< (ra te * months) 
Calling 
the showFees function 
with arguments Adult, 
120.0, 
3. 
Membership Type : 
Number of months: 
Total charges 
Adult 
3 
$360 
Monthly rate $120 
(program output continues) 

6.17 Little Lotto Case Study 
387 
Program 6-31 
(continued) 
Calling 
the showFees function 
with arguments 
Child, 
60.0, 
2. 
Membership Type : Child 
Number of months: 2 
Total charges 
: $120 
Monthly rate $60 
Calling 
the showFees function 
with arguments 
Senior, 
100.0, 
4. 
Membership Type : Senior 
4 
Monthly rate 
$100 
Number of months: 
Total charges 
$400 
6.17 
As shown in Program 6-31, a driver can be used to thoroughly test a function. It can 
repeated ly call the function with different test values as arguments . When the function 
performs as desired, it can be placed into the actual program it will be part of. 
Little Lotto Case Study 
Problem Statement 
The mathematics department of Jefferson Junior High Schoo l wants a program 
developed that will illustrate basic probability for their students in an entertaining way. 
In particular , they want a program called "Little Lotto" that simulates a lottery. In this 
program students can specify the number of numbers in the selection set (1- 12) and the 
number of numbers patrons must pick and match to the winning numbers (between 1 
and the size of the selection set). The order of the selected numbers is not significant. 
Example Output 
This example output clarifies exactly what the department wants the program to do. 
This program wi ll tell 
you your probability 
of wi nning "Litt le Lotto" . 
How many numbers (1-12) are there 
to pick from? 12 
How many numbers must you pick to play? 5 
Your chance of winning the lottery 
is 1 chance i n 792 . 
Thi s is a probability 
of 0 .0013 
Program Design 
Program Steps 
The program must carry out the following general steps: 
1. Get and validate how many numbers there are to choose from (n). 
2. Get and validate how many of these numbers must be selected (k). 
3. Compute the number of ways a set of k items can be selected from a set of n items. 
4. Report to the player his chance of winning and his probability of winning. 

388 
Chapter 6 
Functions 
Program Modules 
Th e program will be designed as a set of modules , each having a specific function. 
Table 6-1 describes the modules that will be used: 
Table 6 -1 Little Lotto Program Modules 
Function 
main 
Description 
This function explains the "game," organizes calls to other functions , 
and reports results. 
getlotterylnfo 
This function gets and validates the number of numbers to select from 
(n) and the number that must be chosen (k). 
computeWays 
This function computes the number of different sets of size k that can 
be chosen from n numbers. 
factorial 
Figure 6-15 
This function computes factorials. It is used by computeWays. 
Program Organization 
In previous chapters hierarchy charts were used to illustrate the relationship of actions 
that a program must carry out. However, they are more common ly used to illustrate 
the relationship of program modules in a program that is organized into a set of 
functions. The hierarchy chart in Figure 6-15 illustrates the organization of the Little 
Lotto program. Notice that it clarifies which functions call which other functions . 
main 
' 
I 
I 
getlotteryinfo 
computeWays 
I 
factorial 
Variables whose values will be input 
int 
pi ckFrom 
int 
numPicks 
// Number of numbers available 
to select 
from 
// Number of numbers that must be chosen 
Variables and values whose values will be output 
long int ways 
1 . 0 / ways 
// Number of di fferent 
poss i ble select i ons 
// Only 1 of these can "win" 
// Probabil i ty of winni ng 
Detailed Pseudocode for Each Module 
In a modular program, a separate pseudocode routine should be created to capture the logic 
of each function. Here is the pseudocode for each function in the Little Lotto program. 

6.17 Little Lotto Case Study 
389 
main 
Display 
information 
on what the program does 
Call getLotteryinfo 
II Puts value in pickFrom and numPicks variables 
Call computeWays 
II Returns number of ways numbers can be selected 
Store 
the returned 
result 
in the ways variable 
Display 
ways and 1 I ways 
End main 
getLotteryinfo 
II Places 
inputs 
in reference 
variables 
Input pickFrom 
While pickFrom < 1 or pickFrom > 12 
Display 
an error message 
Input pickFrom 
End while 
Input numPicks 
While numPicks < 1 or numPicks > pickFrom 
Display 
an error message 
Input pickFrom 
End while 
End getLotteryinfo 
computeWays 
II Receives 
pickFrom as n and numPicks ask 
Call factorial 
3 times to get information 
for its calculations 
Return 
factorial{n) 
factorial(k) 
• 
factorial 
(n -k ) 
End computeWays 
factorial 
II Receives 
number whose factorial 
is to be calculated 
factTota7 
= 1 
Loop for count= 
number down to 1 
fact Tota 7 = fact Tota 7 • count 
End Loop 
Return factTotal 
End factori a 7 
The Program 
The next step, after the pseudocode has been checked for logic errors, is to expand the 
pseudocode into the final program . This is shown in Program 6-32. 
Program 6-32 
1 II Thi s program finds 
the probability 
of winning 
a "mini" lottery 
when 
2 II the user's 
set of numbers must exactly 
match the set drawn by the 
3 II 
lottery 
organizers. 
In addition 
to main , it uses three 
funct i ons. 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 using namespace std; 
7 
8 II Function 
prototypes 
9 void getLotteryinfo(
i nt&, int& ); 
10 long i nt computeWays(int, 
int ); 
11 long i nt factoria
l(i nt ); 
12 
(program continues) 

390 
Chapte r 6 
Functions 
Program 6-32 
(continued) 
13 int main() 
14 { 
15 
16 
17 
18 
19 
int pickFrom , 
numPicks ; 
long int ways; 
II The number of numbers to pic k from 
II The number of numbers to select 
II The number of different 
possible 
II ways to pick the set of numbers 
20 
cout << "This program will 
tell 
you your probab i l it y of" 
21 
<< "wi nning \"Little 
Lotto\". 
\ n"; 
22 
getLotterylnfo(pickFrom, 
numPicks); 
23 
ways = computeWays(pickFrom , numPicks); 
24 
25 
26 
27 
28 
cout << fixed << showpoi nt << setprecision(4); 
cout << "\nYour chance of winning the lottery 
<< • 1 chance in • << ways << • . \n"; 
cout << "This is a probability 
of • << ( 1 . 0 I 
29 
return 
O; 
30 } 
31 
is • 
ways) 
<< 
II \n It; 
32 /******************************************************************* 
33 
* 
get Lottery Info 
* 
34 
* Gets and validates 
lottery 
info. 
from the user and places 
i t in* 
35 
* reference 
parameters 
referencing 
var iables 
in the main funct i on . * 
36 
*******************************************************************/ 
37 void getLotterylnfo(
i nt &pickFrom , i nt &numPicks) 
38 { 
39 
cout << "\nHow many numbers (1 -12) 
are there 
to pick from?"
· 
40 
cin 
>> pickFrom ; 
41 
while 
(pick From < 1 11 pickFrom > 12) 
42 
{ 
43 
44 
45 
46 
} 
cout << 
<< 
ci n 
>> 
"There must be between 1 and 
"How many numbers (1-12) are 
pickFrom; 
12 numbers . \n" 
there 
to pick from? 
47 
cout << "How many numbers must you pick to play?"· 
48 
cin 
>> numPicks ; 
49 
while 
( numPi cks < 1 11 numPi cks > pi ck From) 
50 
{ 
.. 
51 
52 
53 
54 
55 
if (numPicks < 1) 
II too few picks 
cout << "You must pick at least 
one number. \ n"; 
else 
II too many pi cks 
cout << "You must pick"<< 
pick From <<" 
or fewer numbers . \n"; 
56 
cout << "How many numbers must you pick to play?"· 
57 
ci n 
>> numPi cks; 
58 
} 
59 } 
60 
(program continues) 

6.17 Little Lotto Case Study 
39 1 
Program 6-32 
(continued) 
61 /******************************************************************* 
62 
63 
64 
65 
66 
67 
* 
computeWays 
* Computes and returns 
the number of di fferent 
poss i ble sets 
* of k numbers that 
can be chosen from a set of n numbers. 
* The formula for this 
i s 
n! 
* 
* 
k! (n -k ) ! 
* 
* 
* 
* 
* 
* 
68 
*******************************************************************/ 
69 II Note that 
the computation 
is done i n a way that 
does not require 
70 II multiplying 
two factorials 
together
. This is done to prevent 
any 
71 II intermediate 
result 
becoming so large 
that 
it causes overflow. 
72 l ong i nt computeWays(int 
n, int k) 
73 { 
74 
return 
( factor
i al(n) 
I factor
i al(k) 
I factor
i al (n-k) 
); 
75 ) 
76 
77 /******************************************************************* 
* 
* Computes and returns 
the 
* passed to i t . n! means n 
* O! is a special 
case and 
factor
i al 
factorial 
of the non-negat i ve integer 
* ( n-1 ) * ( n-2 ) . . . * 1 
is defined 
to be 1 . 
* 
* 
* 
* 
78 
79 
80 
81 
82 
*******************************************************************/ 
83 II Notice that 
if number equals 
0, the loop cond i t i on will 
84 II 
in i tially 
be false 
and the l oop will 
never be executed
. 
85 II Thi s wi ll, 
correct
ly, 
leave factTotal 
= 1 . 
86 
87 long i nt factoria
l(i nt number) 
88 { 
89 
long int factTotal 
= 1 ; 
90 
91 
for (int 
count
= number; count>= 
1 ; count--
) 
92 
{ 
93 
factTotal 
*= count; 
94 
} 
95 
return 
factTotal; 
96 } 
Program Output with Example Input Shown in Bold 
This program will 
tell 
you your probability 
of winning "Little 
Lotto". 
How many numbers (1 -12) are there 
to pick from? lO[Enter] 
How many numbers must you pick to play? 
3[Enter] 
Your chance of winning the lottery 
is 1 chance in 120. 
This is a probability 
of 0.0083 
High Adventure Travel Agency Case Study 
The following additional case study, which contains applications of material introduced in 
Chapter 6, can be found on this book's companion website at pearsonhighered.com/gaddis. 
It demonstrates all the steps needed to develop a modular program that calculates and 
itemizes charges for the vacation packages offered by the High Adventure Travel Agency. 

392 
Chapte r 6 
6.18 ..-
Functions 
Tying It All Together: Glowing Jaclc-o-lantern 
Functions are not just practical. They are fun. True, they let you simplify programs by 
breaking them into smaller modu les. And they minimize repetitive code . If you need to 
do the same thing in severa l different places in your program, you can just write a 
function to do it, then call that function from different places in the program instead of 
writing the same block of code more than once . But they also let you do new and fun 
things. This is because even though the function code is the same, it will behave 
differently every time it is called with different arguments . 
For examp le, we could write the following pri ntSpaces function, and each time it will 
print a different number of spaces depending on the value passed in to its parameter n. 
voi d printSpaces(
i nt n) 
{ 
) 
for (i nt space= 
1; space<= 
n; space+ +) 
cout <<" 
"; 
Now that may not sound like fun, but let's see how we can use it and other functions 
to enhance the smiley face we created in Chapter 2 and the colored alphabet program 
we created in Chapter 5. We will start with the alphabet program and use the simple 
pri ntSpaces function shown above to make the letters appear to "climb down a set of 
stairs" by moving them across the screen as they are displayed. So that they will all fit 
on one screen, we will print them in pairs. 
Recall from Chapter 5, however, that the function we are using to display output in 
color uses a Windows operating system function, so this program will only run on 
Windows systems. 
Program 6-33 
1 II Thi s program wri tes the ABCs in green, 
red, and yel low, 
2 II displaying 
them di agonal l y across 
the screen so they 
3 II appear to be cl i mbing down a sta i rcase. 
4 #include 
<iostream> 
5 #include 
<wi ndows.h> 
6 using namespace std; 
II Needed to di spl ay colors 
and cal l Sleep 
7 
8 II Prototype 
9 void pr i ntSpaces(int 
n); 
10 
11 int main() 
12 { 
13 
14 
II Bright Green= 
10 
Bright Red= 12 
Bright Yel low= 14 
15 
II Get the handle to standard 
output 
device 
(the conso l e) 
16 
HANDLE screen= 
GetStdHand l e(STD_OUTPUT_HAND
LE); 
17 
18 
II Write the ABCs using 3 col ors 
19 
II Di spl ay 2 per line, 
stair 
stepp i ng across 
the screen 
20 
int color= 
10; 
II Starting 
color= 
green 
(program continues) 

6.18 Tying It All Together: Glowing Jack-o-lantern 
393 
Program 6-33 
(continued) 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 } 
37 
for (char letter= 
'A'; 
let ter<= 
' Z'; let ter+=2) 
{ 
SetConso leTe xtAttr i bute (screen, 
color}; 
printSpaces(letter-'A'); 
cout << let ter 
<< static_cast<char>
(lett
er+1} << endl ; 
II Set the color 
I I Indent 
II Print 
2 letters 
color 
+=2; 
II Choose next color 
if (co l or > 14) 
color= 
10; 
Sleep(280); 
II Pause between characters 
to watch them appear 
} 
II Restore 
normal text 
attribute 
(i. e . white) 
SetConsoleTextAttribute(screen
, 7); 
return 
O; 
38 /******************************************** 
* 
printSpaces 
* Prints 
n spaces where n is passed as an 
* argument to the funct io n . 
* 
* 
* 
39 
40 
41 
42 
********************************************/ 
43 void printSpaces
(int 
n) 
44 { 
45 
for (int 
space= 
1 ; space<= 
n; space ++} 
46 
cout <<" 
"· 
47
} 
Run the program and view the results. 
The output display should look like 
the one below, but in color of course. 
AB 
CD 
EF 
GH 
IJ 
KL 
MN 
OP 
QR 
ST 
UV 
wx 
YZ 
Now, can you modify the program to make 
the letters appear to climb UP the stairs? The 
program will still print starting with the top 
line and move down the screen, but the final 
display should look like this: 
IJ 
GH 
EF 
CD 
AB 
MN 
KL 
YZ 
wx 
UV 
ST 
QR 
OP 
If you have trouble figuring this out, the 
solution can be found in the pr6-33B. cpp 
file found in the Chapter 6 programs folder 
on the book's companion website. 

394 
Chapte r 6 
Functions 
Now let's use a function to turn the Smiley Face we created in Chapter 2's Tying It All 
Together into a spooky Jack-o-lantern glowing in the dark . We'll let the user pick what 
color to display it in. 
Program 6-34 
1 II This program displays 
a Jack-o-lantern 
gl owing in the dark. 
2 II It lets 
the user select 
what color 
i t shou l d be. 
3 #inc l ude <i ostream> 
4 #inc l ude <windows .h> 
5 using namespace std; 
6 
7 II Funct i on prototypes 
8 void di splayMenu(); 
9 int getCho i ce(); 
10 void makeJackOLantern(); 
11 
12 II Global constants 
II Needed to display 
colors 
13 const 
int QUIT= 6, MAX
_CHOICE = 6; 
14 
15 int main() 
16 { 
17 
int colorChoice; 
18 
II Get the handle to standard 
output 
device 
(the conso l e) 
19 
HANDLE screen= 
GetStdHand l e(STD_OUTPUT_HANDLE); 
20 
21 
do 
22 
{ SetConso l eTextAttr
i bute(screen, 
7); 
II Set to white on black 
23 
di spl ayMenu(); 
II for menu di sp l ay 
24 
colorChoice 
= getCho i ce(); 
25 
26 
if (co l orChoi ce != QUIT) 
27 
{ 
SetConsoleTextAttribute(screen, 
colorChoice 
+ 9); 
28 
makeJackOLantern(); 
29 
) 
30 
} whi le (co l orChoi ce != QUIT); 
31 
return 
O; 
32
} 
33 
34 /**************************************************** 
35 
* 
displayMenu 
* 
36 
* Thi s funct i on di splays 
the menu of col or choices.* 
37 
****************************************************/ 
38 void displayMenu() 
39 { 
system("c l s"); 
II Clear the screen 
40 
cout << "I wil l draw 
41 
<< "Enter 
1 for 
a Jack-o-lantern
. What 
Green 
2 for Blue 
color 
shou l d it be?\n\n" 
3 for Red \n" 
42 
43
} 
44 
<<" 
4 for Purple 
5 for Yel low 
6 to qui t: 
"· 
(program continues) 

Program 6-34 
(continued) 
45 /************************************************** 
46 
47 
48 
* 
* 
* 
getChoice 
This function 
i nputs, 
validates, 
and returns 
the user's 
menu choice. 
* 
* 
* 
49 
**************************************************/ 
50 int getChoice(
) 
51 { 
52 
int choice; 
53 
54 
cin >> choi ce; 
55 
whi le (cho i ce< 
1 I I choice> 
MAX
_CHOICE) 
Review Questions and Exercises 
395 
56 
{ cout << "\nT he onl y valid choi ces are 1-" << MAX
_CHOICE 
57 
<< " . Please 
re-enter. 
"· 
58 
ci n >> choice ; 
59 
} 
60 
return 
choice; 
61 } 
62 
63 /*********************************************** 
64 
65 
66 
* 
* 
* 
makeJackOLantern 
This function 
draws a Jack-o-lantern 
in whatever color the user selected. 
* 
* 
* 
67 
***********************************************/ 
void makeJackOLantern() 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77
} 
{ 
cout << "\n\n"; 
cout << " 
A 
A 
\n"; 
cout << " 
* 
\n"; 
cout << " 
\ \ 
I 
" << 
cout << "\n\n 
ci n. get(); 
endl ; 
Press ENTER to return 
to the menu." 
II Clear the prev i ous \n out of the i nput buffer 
II Wait for the user to press ENTER 
ci n. get(); 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. The ____ 
is the part of a function definition that shows the function name, 
return type, and parameter list. 
2. If a function doesn't return a value, the word ____ 
will appear as its return type. 
3. If function showVal ue has the following header: voi d showVal ue( i nt quant it y) 
you would use the statement ____ 
to call it with the argument 5. 
4. Either a function's ____ 
or its ____ 
must precede all calls to the function. 
5. Values that are sent into a function are called ___ 
_ 
6. Special variables that hold copies of function arguments are called ___ 
_ 

396 
Chapter 6 
Functions 
7. When only a copy of an argument is passed to a function , it is said to be passed by 
8. A(n) ____ 
eliminates the need to place a function definition before all calls 
to the function. 
9. A(n) ____ 
variable is defined inside a function and is not accessible outside 
the function. 
10. ____ 
variables are defined outside all functions and are accessible to any 
function within their scope. 
11. ____ 
variables provide an easy way to share large amounts of data among 
all the functions in a program . 
12. Unless you explicitly initialize numeric global variables, they are automat ically 
initialized to ----
13. If a function has a local variable with the same name as a global variable, only the 
____ 
variable can be seen by the function. 
14. ____ 
local variables retain their value between function calls. 
15. The ____ 
statement causes a function to end immediately. 
16. ____ 
arguments are passed to parame ters automatically if no argument is 
provided in the function call. 
17. When a function uses a mixtu re of paramete rs with and without defau lt 
arguments, the parameters with default arguments must be defined ___ 
_ 
18. The value of a default argument must be a(n) ___ 
_ 
19. When used as parameters , ____ 
variables allow a funct ion to access the 
parameter's original argument . 
20. Reference variables are defined like regular variables, excep t there ,s a(n) 
in front of the name. 
----
21. Reference variables allow arguments to be passed by ____ 
_ 
22. The ____ 
function causes a program to terminate immediately . 
23. Two or more functions may have the same name, as long as their ____ 
are 
different . 
24. Wha t is the advantage of break ing your application's code into several small 
functions? 
25. What is the difference between an argument and a parame ter variable? 
26. When a function accepts multiple arguments, does it matter what order the 
arguments are passed in? 
27. What does it mean to overload a function? 
28. If you are writing a function that accepts an argument and you want to make sure 
the function cannot change the value of the argument, what should you do? 
29. Give an examp le of where an argument should be passed by reference. 
30. How do you return a value from a function? 

Review Questions and Exercises 
397 
31. Can a function have a local variable with the same name as a global variable? 
32. When shou ld a static 
local variab le be used? 
Algorithm Workb ench 
33. The following statemen t calls a function named half , which returns a value that 
is half that of the argumen t passed to it. Assume that result 
and number have 
both been defined to be doubl e variables . Write the half function . 
result= 
half (number); 
34. A program contains the following function. 
int cube(int 
num) 
{ 
return 
num * num * num; 
} 
Write a statement that passes the value 4 to this function and assigns its return 
value to the variable r esult. 
35. Write a function, named timesTen , that accepts an integer argument . When the 
function is called, it should display the product of its argumen t multiplied times 10. 
36. A program contains the following function. 
void display(int 
arg1, double arg2, char arg3) 
{ 
cout << "Here are the values: 
• 
<< arg1 << • • << arg2 << • • << arg3 << endl ; 
} 
Write a statement that calls the function and passes the following variables to it: 
int age; 
double income; 
char initial; 
37. Write a function named getNumber, which uses a reference parameter to accept 
an integer argument . Th e function should prompt the user to enter a number in 
the range of 1 through 100. Th e inp ut should be validated and stored in the 
parameter variable. 
38. Write a function named biggest that receives thr ee integer arguments and returns 
the largest of the three values. 
Find the Errors 
39. Each of the following functions has erro rs. Locate as many errors as you can. 
A) void total(int 
value1, 
value2, 
value3) 
{ 
return 
value1 
+ value2 
+ value3; 
} 
B) double average(int 
value1, 
int value2, 
int value3) 
{ 
double average; 
average= 
value1 
+ value2 
+ value3 / 3; 
} 

398 
Chapte r 6 
Functions 
C) void area(int 
length= 
30, int width) 
{ 
return 
leng th
* width; 
} 
D) void getValue (int value&) 
{ 
} 
cout << "Enter a value: 
"; 
cin >> value&; 
E) II Over loa ded functions 
int get Value() 
{ 
} 
{ 
} 
Soft Skills 
int inputValue
; 
cout << "Enter an integer: 
"; 
cin >> inputValue; 
return 
inputValue; 
double getValue () 
double inputValue; 
cout << "Enter a floating-point 
number: "; 
cin >> inputValue; 
return 
inputValue; 
Programmers need to develop th e abili ty to break a large problem into a set of 
manageable components, or modules, each of which can focus on handling one specific 
task. If these tasks are large, they may be divided even further into a set of subtasks. 
Each component can then be programmed as a separate function. Often there is more 
than one acceptable way to divide a program into modules and to organize the modules. 
However, in general, if module A calls module B, then module B should carry out some 
subtask that helps module A perform its function. 
40. Read the following program statement and then come to class prepared to discuss 
how you would design the program . How many modules would you use? What task 
would each one handle? How would you organize them? That is, which modules 
would call which other modules? Be prepared to state the advantages of your design. 
Artistic Solutions Paint Job Estimator 
Artistic Solutions, a painting company, has determined that for every 160 square feet of 
wall space, one gallon of paint and three hours of labor are required. The company charges 
$28 per hour for labor. Design a modular program that allows the user to enter the number 
of rooms that are to be painted, the approxima te square feet of wall space in each room (it 
may differ from room to room), and the price of the paint per gallon. It should then create 
a report that includes a fancy company header and displays the following information: 
• The number of gallons of paint required (rounded up to the next full gallon) 
• The hours of labor required 
• The cost of the paint 
• The labor charges 
• The total cost of the paint job 

a 
VideoNote 
Solving the 
Markup 
Problem 
Programming 
Challenges 
1. Markup 
Programming Challenges 
39 9 
Write a program that asks the user to enter an item's wholesale cost and its markup 
percentage. It should then display the item's retail price. For example: 
• If an item's wholesale cost is $5.00 and its markup percentage is 100 percent, then 
the item's retail price is $10.00 . 
• If an item's wholesale cost is $5.00 and its markup percentage is 50 percent, then 
the item's retail price is $7.50. 
The program should have a function named cal cul at eRet ai l that receives the wholesale 
cost and the markup percentage as arguments and returns the retail price of the item. 
2. Celsius Temperature Table 
The formula for converting a temperature from Fahrenheit to Celsius is 
C = ~ (F - 32) 
where F is the Fahrenheit temperature and C is the Celsius temperature. Write a function 
named ce l s i us that accepts a Fahrenheit temperature as an argument and returns the 
temperature converted to Celsius. Demonstrate the function by calling it in a loop that 
displays a table of the Fahrenheit temperatures O through 20 and their Celsius equivalents. 
3. Falling Distance 
The following formula can be used to determine the distance an object falls due to 
gravity in a specific time period: 
d =112 gt2 
The variables in the formula are as follows: 
• d is the distance in meters, 
• g is 9.8, 
• and tis the time in seconds that the object has been falling. 
Write a function named fall i ngDi stance that accepts an object's falling time (in seconds) 
as an argument. The function should return the distance, in meters, that the object has 
fallen during that time interval. Write a program that demonstrates the function by calling 
it in a loop that passes the values 1 through 10 as arguments and displays the return value. 
4. Kinetic Energy 
In physics, an object that is in motion is said to have kinetic energy. The following 
formula can be used to determine a moving object's kinetic energy: 
KE =112 mv 2 
The variables in the formula are as follows: 
• KE is the kinetic energy in joules, 
• m is the object's mass in kilograms, 
• and v is the object's velocity in meters per second. 

400 
Chapter 6 
Functions 
Write a function named ki net i cEnergy that accepts an object's mass (in kilograms ) and 
velocity (in meters per second) as arguments . The function should return the amount of 
kinetic energy that the object has. Demonstrate the function by calling it in a program 
that asks the user to enter values for mass and velocity. 
5. Winning Division 
Write a program that determines which of a company's four divisions (Northeast , 
Southeast , Northwest, and Southwest) had the greatest sales for a quarter. It should 
include the following two functions, which are called by main. 
• double get Sal es () is passed the name of a division. It asks the user for a division's 
quarte rly sales figure, validates that the input is not less than 0, then returns it. It 
should be called once for each division. 
• void fi ndHi ghest () is passed the four sales totals. It determines which is the largest 
and prints the name of the high grossing division, along with its sales figure. 
6. Shipping Charges 
The Fast Freight Shipping Company charges the following rates: 
Weight of Package (in kilograms) 
2 kg or less 
Over 2 kg but not more than 6 kg 
Over 6 kg but not more than 10 kg 
over 10 kg 
Rate per 500 Miles Shipped 
$3.10 
$4.20 
$5.30 
$6.40 
Write a program that asks for the weight of a package and the distance it is to be shipped. 
This information should be passed to a calculateCharge 
function that computes and 
returns the shipping charge to be displayed. The main function should loop to hand le 
multiple packages until a weight of O is entered . 
7. String Compare 
You know that the == operator can be used to test if two string objects are equal. 
However, you will recall that they are not considered equa l, even when they hold the 
exact same letters, if the cases of any letters are different. So, for example, if name1 = 
"Jack" and name2 = "JACK", they are not considered the same. Write a program that 
asks the user to enter two names and stores them in st ring objects . It should then 
report whether or not, ignoring case, they are the same. 
To help the program accomp lish its task, it should use two functions in addition to 
main, uppercase It () and sameSt ri ng (). Here are their function headers. 
string 
upperCaselt(s
t ring s) 
Boolean sameSt ri ng (str i ng s1, string 
s2) 
The sameStri ng function , which receives the two strings to be compared, will need to 
call uppercase It for each of them before testing if they are the same. The uppercase It 
function should use a loop so that it can call the to upper function for every character 
in the string it receives before returning it to the sameStri ng function . 

Programming Challenges 
401 
8. Lowest Score Drop 
• Write a program that calculates the average of a group of test scores, where the 
lowest score in the group is dropped . It should use the following functions: 
• void getScore () should ask the user for a test score, store it in a reference parameter 
variable, and validate that it is not lower than O or higher than 100. This function 
should be called by main once for each of the five scores to be entered. 
• voi d cal cAverage () should calculate and display the average of the four highest 
scores. This function shou ld be called just once by mai n and should be passed the 
five scores. 
• i nt f i ndlowest () should find and return the lowest of the five scores passed 
to it. It should be called by calcAverage, which uses the function to determine 
which one of the five scores to drop. 
9. Star Search 
A particular talent competition has five judges, each of whom awards a score between 
0 and 10 to each performer. Fractional scores, such as 8.3, are allowed . A performer's 
final score is determined by dropping the highest and lowest score received, then 
averaging the three remaining scores. Write a program that uses these rules to calculate 
and display a contestant's score. It should include the following functions: 
• voi d getJudgeDa t a() should ask the user for a judge's score, store it in a reference 
parameter variable, and validate it. This function should be called by mai n once 
for each of the five judges. 
• double calcScore() 
should calculate and return the average of the three scores 
that remain after dropping the highest and lowest scores the performer received. 
This function shou ld be called just once by main and should be passed the five 
scores. 
Two additional functions, described below, should be called by calcScore, which uses 
the returned information to determine which of the scores to drop. 
• i nt fi ndlowest () should find and return the lowest of the five scores passed to it. 
• i nt fi ndHi ghest () should find and return the highest of the five scores passed to it. 
10. isPr i me Function 
A prime number is an integer greater than 1 that is evenly divisible by only 1 and itself. 
For examp le, the number 5 is prime because it can only be evenly divided by 1 and 5. 
The number 6, however, is not prime because it can be divided by 1, 2, 3, and 6. 
Write a Boolean function named i sPri me, which takes an integer as an argument and 
returns true if the argument is a prime number, and false otherwise. Demonstrate the 
function in a complete program . 
Tl P: Recall that the % operator divides one number by another and returns the 
remainder of the division. In an expression such as num1 % num2, the% operator will 
return O if num1 is evenly divisible by num2. 

402 
Chapter 6 
Functions 
11. Present Value 
Suppose you want to deposit a certain amoun t of money into a savings account and 
then leave it alone to draw interest for the next 10 years. At the end of 10 years you 
would like to have $10,000 in the accoun t. How much do you need to deposit today to 
make that happen? To find out you can use the following formula, which is known as 
the present valu e formula: 
P = 
F 
(1 + r)" 
The terms in the formula are as follows: 
• P is the present value, or the amoun t that you need to deposit today. 
• F is the futur e value that you want in the account (in this case, $10,000 ). 
• r is the annual interest rate (expressed in decimal form, such as .042 ). 
• n is the numb er of years that you plan to let the money sit in the accoun t. 
Write a program with a function named prese ntVal ue that performs this calculation. 
The function should accept the future value, annua l interest rate, and number of years 
as arguments. It should return the present value, which is the amoun t that you need 
to deposit today . Demonstrate the function in a program that lets the user experiment 
with different values for the formula's terms. 
12. Future Value 
Suppose you have a certain amoun t of money in a savings account that earns compound 
month ly interest, and you want to calculate the amoun t that you will have after a specific 
number of months . The formula, which is known as the future value formula , is: 
F= PX (1 + i)t 
The variables in the formula are as follows: 
• F is the future value of the account after the specified time period. 
• P is the present value of the accoun t. 
• i is the monthl y interest rate. 
• t is the numb er of months. 
Write a program that prompts the user to enter the account's present value, monthly 
interest rate, and number of months that the money will be left in the accoun t. The 
program should pass these values to a function named f utur eVal ue that computes 
and returns the future value of the account after the specified number of months . The 
program should display the account's future value. 

Programming Challenges 
403 
13. Stock Profit 
The profit from the sale of a stock can be calculated as follows: 
Profit = ((NS x SP) - SC) - ((NS x PP) + PC) 
• where NS is the number of shares, 
• SP is the sale price per share, 
• SC is the sale commission paid, 
• PP is the purchase price per share, 
• and PC is the purchase commission paid. 
If the calculation yields a positive value, then the sale of the stock resulted in a profit. If 
the calculation yields a negative number, then the sale resulted in a loss. 
Write a function that accepts as arguments the number of shares, the purchase price per 
share, the purchase commission paid, the sale price per share, and the sale commission 
paid. The function should return the profit (or loss) from the sale of stock. 
Demonstrate the function in a program that asks the user to enter the necessary data 
and displays the amount of the profit or loss. 
14. Multiple Stock Sales 
Use the function that you wrote for Programming Challenge 13 (Stock Profit) in a pro-
gram that calculates the total profit or loss from the sale of multiple stocks. The program 
should ask the user for the number of stock sales, and the necessary data for each stock 
sale. It should accumulate the profit or loss for each stock sale and then display the total. 
15. Order Status 
The Middletown Wholesale Copper Wire Company sells spools of copper wiring for 
$100 each and ships them for $10 apiece. Write a program that displays the status of 
an order. It should use two functions. The first function asks for the following data and 
stores the input values in reference parameters. 
• The number of spools ordered . 
• The number of spools in stock. 
• Any special shipping and handling charges (above the regular $10 rate). 
The second function receives as arguments any values needed to compute and display 
the following information: 
• The number of ordered spools ready to ship from current stock. 
• The number of ordered spools on backorder (if the number ordered is greater 
than what is in stock). 
• Total selling price of the portion ready to ship (the number of spools ready to ship 
times $100 ). 
• Total shipping and handling charges on the portion ready to ship. 
• Total of the order ready to ship. 
The shipping and handling parameter in the second function should have the default 
argument 10.00. 

404 
Chapter 6 
Functions 
16. Overloaded Hospital 
Write a program that computes and displays the charges for a patient's hospita l stay. 
First, the program should ask if the patient was admitted as an inpatient or an 
outpatient . If the patient was an inpatient, the following data should be entered: 
• The number of days spent in the hospital 
• The daily rate 
• Charges for hospital services (lab tests, etc.) 
• Hospital medication charges 
If the patient was an outpatient , the following data should be entered: 
• Charges for hospital services (lab tests, etc.) 
• Hospital medication charges 
Use a single, separate function to validate that no input is less than zero. If it is, it 
should be reentered before being returned. 
Once the required data has been input and validated, the program should use two 
overloaded functions to calculate the total charges. One of the functions should accept 
arguments for the inpatient data, while the other function accepts arguments for 
outpatient data . Both functions should return the total charges. 
17. Population 
In a population, the birth rate is the percentage increase of the population due to births, 
and the death rate is the percentage decrease of the population due to deaths. Write a 
program that asks for the following: 
• The starting size of a population (minimum 2) 
• The annua l birth rate 
• The annua l death rate 
• The number of years to display (minimum 1) 
The program should then display the starting population and the projected population 
at the end of each year. It should use a function that calculates and returns the projected 
new size of the population after a year. The formula is 
N = P(1 + 8)(1 - D) 
where 
• N is the new population size, 
• Pis the previous population size, 
• Bis the birth rate, 
• and Dis the death rate. 
Annual birth rate and death rate are the typical number of births and deaths in a year 
per 1,000 people, expressed as a decimal. So, for example, if there are norma lly about 
32 births and 26 deaths per 1,000 people in a given population, the birth rate would be 
.032 and the death rate would be .026. 

Programming Challenges 
405 
18. Transient Population 
Modify Programming Challenge 17 to also consider the effect on population caused by 
people moving into or out of a geographic area. Given as input a starting population 
size, the annual birth rate, the annua l death rate, the number of individual s that 
typically move into the area each year, and the number of individuals that typically 
leave the area each year, the program should project what the popu lation will be 
numYears from now. You can either prompt the user to input a value for numYears , or 
you can set it within the program. 
19. Using Files-Hospital 
Report 
Modify Programming Challenge 16, Overloaded Hospital , to write the report it creates 
to a file. Print the contents of the file to hand in to your instructor. 
Group Project 
20. Using Files-Travel 
Expenses 
This program should be designed and written by a team of students . Here are some 
suggestions: 
• One student should design function main , which will call the other functions in 
the program . The rest of the functions should be designed by other team members. 
• Analyze the program requirement s so each student is given about the same 
workload . 
• Decide on the function names, parameters , and return types in advance. 
• Use stubs and drivers to test and debug the program. 
• The program can be implemented either as a multifile program , or all the functions 
can be cut and pasted into the main file. 
Here is the assignment. Write a program that calculates and displays the tota l travel 
expenses of a businessperson on a trip . The program should have functions that ask for 
and return the following: 
• The total number of days spent on the trip 
• The time of departure on the first day of the trip and the time of arriva l back 
home on the last day of the trip 
• The amount of any round -trip airfare 
• The amount of any car rentals 
• Miles driven, if a private vehicle was used. Vehicle allowance is $0.58 per mile. 
• Parking fees. (The company allows up to $12 per day. Anything in excess of this 
must be paid by the employee.) 
• Taxi fees. (The company allows up to $40 per day for each day a taxi was used. 
Anything in excess of this must be paid by the employee.) 
• Conference or seminar registration fees 
• Hotel expenses. (The company allows up to $90 per night for lodging. Anything 
in excess of this amount must be paid by the employee.) 

406 
Chapter 6 
Functions 
• The cost of each meal eaten. On the first day of the trip, breakfast is allowed as 
an expense if the time of departure is before 7 a.m. Lunch is allowed if the time 
of departure is before noon . Dinner is allowed if the time of departure is before 
6 p.m. On the last day of the trip, breakfast is allowed if the time of arrival is after 
8 a.m. Lunch is allowed if the time of arrival is after 1 p.m. Dinner is allowed if 
the time of arrival is after 7 p.m. The program should only ask for the costs of 
allowable meals. (The company allows up to $18 for breakfast, $12 for lunch, 
and $20 for dinner. Anything in excess of this must be paid by the employee.) 
The program should perform the necessary calculations to determine the total amount 
spent by the business traveler in each category (mileage charges, parking, hotel, meals, 
etc.) as well as the maximum amount allowed in each category. It should then create a 
nicely formatted expense report that includes the amount spent and the amount 
allowed in each category, as well as the total amount spent and total amount allowed 
for the entire trip. This report should be written to a file. 
Input Validation: The program should not accept negative numbers for any dollar 
amount or for miles driven in a private vehicle. It should also ensure that the 
number of days is at least 1 and that the time of departure and the time of arrival 
are valid. 

TOPICS 
7.1 
Abstract Data Types 
7.2 
Object-Oriented Programming 
7.3 
Introduction to Classes 
7.4 
Creating and Using Objects 
7.5 
Defining Member Functions 
7.6 
Constructo rs 
7.7 
Destructors 
7.8 
Private Member Functions 
7.9 
Passing Objects to Functions 
7.10 Object Composition 
7.11 Focus on Software Engineering: 
Separating Class Specification, 
Implementation, and Client Code 
7 .12 Structures 
7.13 More about Enumerated Data Types 
7.14 Home Software Company OOP Case Study 
7.15 Introduction to Object -Oriented Analysis 
and Design 
7 .16 Screen Control 
7.17 Tying It All Togethe r: Yoyo Animation 
0 
NOTE : This chapter can be covered after Chapter 8 if the instructor wants to 
introduce arrays before classes and objects. 
Abstract Data Types 
CONCEPT: 
An abstract data type (ADT) is a data type that specifies the values the 
data type can hold and the operations that can be done on them without 
the details of how the data type is implemented. 
Abstraction 
An abstraction is a general model of something . It is a definition that includes only the 
genera l characterist ics of an object without the details that characterize specific 
instances of the object. 
An automobile provides an illustration of abstract ion. Most people understand what 
an automob ile is, and many people know how to drive one. Yet, few people understand 
407 

408 
Chapte r 7 
Introduction to Classes and Objects 
exactly how an automobi le works or what all its parts are . This is a feature of 
abstraction. Details of the internal components, organization, and operations of an 
object are kept separate from the description of what it can do and how to operate it. 
We are surrounded in our everyday lives with such examples of abstract ion, from our 
microwaves and washing machines to our DVD players and computers . We know 
what these objects can do, and we understand how to operate them, but most of us do 
not know, or care, how they work inside. We do not need to be concerned with this 
information . 
The Use of Abstraction in Software Development 
Abstraction occurs in programming as well. In order to focus on the bigger picture of 
creating a working application, a programmer needs to be able to use certain objects 
and routines without having to be concerned with the details of their implementation. 
You have been doing this since the beginning of this text when you used objects such 
as c i n and cou t and functions such as sqrt and pow. All you need to know to use the 
objects or functions is what they do and the interface for using them. For example, to 
use the sqrt function you only have to know its name and that it must be called with 
one numeric argument, the value whose square root is to be returned. To use the pow 
function you only have to know its name and that it must be called with two numeric 
arguments . The first is the value to be raised to a power, and the second is the exponent. 
In neither case do you need to know what algorithm is used by the function to compute 
the result it returns . 
Abstraction applies to data too. To use any data type you need to know just two things 
about it: what values it can hold and what operations apply to it. For example, to use 
a double you need to know that it can only hold numeric values, such as 5. O or - 5. 1, 
and not strings, such as "5. 1 ". To use a dou bl e you also need to know what operations 
can be performed on it. It can be used with the addition, subtraction, multiplication, 
and division operators, but not with the modu lus operator (which only works with 
integer operands, as in the expression 8 % 3). You do not have to know anything else 
about a doubl e to use it. You do not have to know how it is stored in memory or how 
the arithmetic operat ions that can be performed on it are carried out by the computer. 
This separation of a data type's logical propert ies from its implementation details is 
known as data abstraction . 
Abstract Data Types 
The term abstract data type (ADT) describes any data type whose implementat ion 
details are kept separate from the logical properties needed to use it. Normally though, 
the term is used to refer to data types created by the programmer. Often these data 
types can hold more than one value, as with classes, which you will learn about in this 
chapter. The programmer defines a set of values the data type can hold, defines a set of 
operations that can be performed on the data, and creates a set of functions to carry 
out these operations . In C++ and other object-oriented languages, programmer created 
ADTs are normally implemented as classes. 

7.2 
0 
Figure 7-1 
7.2 Object -Oriented Programming 
409 
Object-Oriented 
Programming 
CONCEPT : Object-oriented programming is centered around objects that encapsulate 
both data and the functions that operate on them. 
There are two common programm ing methods in practice today: procedura l 
programming and object-oriented programming (OOP). Up to this chapter, you have 
learned to write procedural programs. 
Procedural programming is a method of writing software centered on the procedures, 
or functions, that carry out the actions of the program. The program 's data, typically 
stored in variables, is separate from these procedures . So you must pass the variables to 
the functions that need to work with them . Object-oriented programming , on the other 
hand, is centered on objects. 
Procedura l programming has worked well for software developers for many years. 
However, as programs become larger and more complex, the separat ion of a program 's 
data from the code that operates on it can lead to problems . For example, quite often a 
program 's specifications change, resulting in the need to change the format of the data 
or the design of a data structure . When the structure of the data changes, the code that 
operates on the data must also be changed to accept the new format . Finding all the 
code that needs changing results in add itional work for programmers and an 
opportunity for bugs to be introduced into the code. 
This problem has helped influence the shift from procedural programming to object-
oriented programming . OOP is centered on creating and using objects. An object is a 
software entity that combines both data and the procedures that work with it in a single 
unit. An object's data items, also referred to as its attributes, are stored in member 
variables. The procedures that an object performs are called its member functions. This 
bundling of an object's data and procedures together is called encapsulation. 
NOTE: In some object-oriented programming languages, the procedures that an 
object performs are called meth ods. 
Figure 7-1 shows a representation of what a Ci rel e object might look like. It has just 
one member variable to hold data and two member functions. The Ci rel e object's 
member variab le is radius
. Its se t Radi us member function sets the radius, and its 
cal cArea member function calculates and returns the area . 
Circle 
Member variables (Attributes) 
double radius; 
Member functions 
void setRadius(double r) 
double calcArea() 

41 0 
Chapter 7 
Figure 7-2 
Introduction to Classes and Objects 
The member variable and the member functions are all members of the Ci rel e object, bound 
together in a single unit. When an operation needs to be performed, such as calculating the 
area of the circle, a message is passed to the object telling it to execute the cal cArea function. 
Because cal cArea is a member of the Ci rel e object, it automatically has access to the object's 
member variables. Therefore, there is no need to pass radius to the cal cArea function. 
In addition to bundling associated data and functions together, objects also permit data 
hiding. Data hiding refers to an object's ability to hide its data from code outside the object. 
Only the object's member functions can directly access and make changes to its data. An 
object typically hides its data, but allows outside code to access it through some of its 
member functions. As Figure 7-2 illustrates , the object's member functions provide 
programming statements outside the object with a way to indirectly access the object's data. 
Circle 
I 
radius 
Code ---1~
~ setRadius _J 
Outside 
~e 
calcArea 
Object..- ---
computed area using radius 
I 
Why is hiding information a good thing? When an object's internal data is hidden from 
outside code, and that data can only be accessed by going through the object's member 
functions, the data is protected from accidental or intentional corruption . In addition, the 
programming code outside the object does not need to know about the format or internal 
structure of the object's data . The code only needs to interact with the object's functions. 
When a programmer changes the structure of an object's internal data, the object's 
member functions are also modified so they will still properly operate on it. These changes, 
however, are hidden from code outside the object. That code does not have to be changed. 
It can call and use the member functions exactly the same way as it did before. 
Earlier we used the automobi le as an example of an abstract object that can be used 
without having to understand the detai ls of how it works. It has a rather simple 
interface that consists of an ignition switch, steering wheel, gas pedal, brake pedal, and 
a gear selector. (Vehicles with manua l transmissions also provide a clutch pedal). If you 
want to drive an automobile , you only have to learn to operate these elements of its 
interface . To start the motor, you simply turn the key in the ignition switch . What 
happens internally is irrelevant to the driver. If you want to steer the auto to the left, 
you rotate the steering wheel left. The movements of all the linkages connecting the 
steering wheel to the front tires occur without your awareness . If the manufacturer 
redesigns the vehicle to perform one of the behind -the-scenes operat ions differently , 
the driver does not need to learn a new interface. 
Because automob iles have simple user interfaces, they can be driven by people who 
have no mechan ical knowledge. This is good for the makers of automobiles because it 
means more people are likely to become customers . It's good for the users of automobiles 
because they can learn just a few simple procedures and operate almost any vehicle. 

7.3 Introduction to Classes 
411 
These are also valid concerns in software development . A program is rarely written by 
only one person. Even the small programs you have created so far weren't written entirely 
by you. If you incorporated C++ library functions, or objects like ci n and cout , you used 
code written by someone else. In the world of professiona l software development, 
programmers commonly work in teams, buy and sell their code, and collaborate on 
projects. With OOP, programmers can create objects with powerful engines tucked away 
"under the hood," but simple interfaces that safeguard the object's algorithms and data . 
Introduction 
to Classes 
CONCEPT
: In C++, the class is the construct primarily used to create objects. 
Before we can create and use an object, there must be a description of what member 
variables and member functions it will have. This is done by defining a class. A class is 
a programmer -defined data type that describes what objects of the class will look like 
when they are created . Shortly, you will see how to define your own classes, but first 
let's look at a class you are already familiar with . 
Using a Class You Already Know 
You have been using the str i ng class to create and use st ring objects since almost the 
beginning of this book . Recall that you must have the following #i nclud e directive in 
any program that uses the st ring class: 
#i nclude <st ring> 
This is necessary because the st ring header file is where the string class is defined. 
With this header file included in your program , you can now define as many stri ng 
objects as you wish. To do this you simply name the class, followed by the names you 
wish to give the objects. Here is an example: 
stri ng cit y, 
state; 
This statement creates two string objects. One is named cit y and the other is named 
state. 
Both objects are instances of the stri ng class, and although they can be assigned 
different data values, both objects essentially look the same. That is, both will have a 
member variable that can hold a string, and both will have the same set of functions 
that can operate on strings. 
Once a string object has been created, you can store data in it. Because the stri ng 
class is designed to work with the assignment operator, you can assign a string literal 
to a str i ng object. Here is an example: 
city 
= "Chicago"; 
state= 
"Illino i s"; 
These statements store "Chicago· in the ci t y object's member variable and "I 11 i noi s" 
in the st at e object's member variable. 
The string class includes numerous member functions that perform operations on the 
data that a string object holds. In earlier chapters you were introduced to several of these. 

412 
Chapter 7 
a 
VideoNot e 
Creating a 
Class 
0 
Introduction to Classes and Objects 
One is a member function named length , which returns the length of the string stored in a 
str i ng object. The following code demonstrates this: 
cout << city.length() 
cout << st at e .lengt h() 
<< endl; 
<< endl; 
// This pr i nts 7 
// This pr i nts 8 
These statements both call their same member function, but in each case it works with 
the object's own data . The data stored in city is a string of length 7. The data stored 
in state is a string of length 8. 
It is important to note that in order to create and use st ring objects, we do not need 
to know anything about how the string class is implemented . We just have to know 
what kind of data it can hold and what functions we can call to operate on the data . 
Creating Your Own Class 
To create your own class, you must write a class declaration . Here is the general format 
of a class declarat ion. 
class ClassNa me 
// Class declara t ion begi ns with 
// t he key word class 
and a name. 
{ 
) ; 
Declarations 
for class 
member variables 
and member functions 
go here. 
// Not ice the required 
semi colon. 
We will learn how to implement a class by building one step by step. Our example will 
be the simple Ci rel e class depicted in Figure 7-1. The first step is to determine what 
member variables and member functions the class shou ld have. In this case we have 
determined , as already described, that the class needs a member variable to hold the 
circle's radius and two member functions: setRadi us and cal cArea. 
NOTE: 
This information , along with other design information , is sometimes 
expressed using visual modeling tools that are part of an object-oriented modeling 
"language" known as the Unified Modeling Language, or UML. Figure 7-1 
illustrated a commonly used type of UML diagram called a class diagram . You will 
see more examples of these later in this chapter. 
Once the class has been designed, the next step is to write the class declaration . This 
tells the compiler what the class includes . Here is the declaration for our Ci rel e class. 
Notice that the class name begins with a capita l letter. Although this is not strictly 
required, it is convent ional to always begin class names with an uppercase letter. 
class Circle 
{ private: 
} ; 
double rad i us; 
public: 
voi d se t Radi us(double 
r) 
{ 
radius 
= r; } 
double calcArea() 
{ 
retur n 3. 14 * pow(radius, 
2); 
} 

0 
7.3 Introduction to Classes 
413 
Access Specifiers 
The class declaration looks very much like Figure 7-1 with the addition of the actua l 
code for each member function and two key words, pr i vate and publ i c. These are 
called access sp ecifiers because they designate who can access various members of 
the class . Notice that each access specifier is followed by a colon . A public member 
variab le can be accessed by functions outs ide the class, and a public member function 
can be called by functions outside the class . A private member variab le, on the other 
hand, can only be accessed by a function that is a member of the same class, and a 
private member funct ion can only be called by other functions that are members of 
the class . If we had omitted the words publ i c and priva t e altogether, everything 
would have defaulted to being private. This would not have been very useful because 
then, except in special circumstances, no functions outside the class could ever use 
the class . 
In our Ci rel e class, the member variable rad i us is declared to be private, and the 
member functions are declared to be public. This is common . Member data is usually 
made private to safeguard it. Public functions are then created to allow carefully 
controlled access to this data from outside the class. For now, all our class member 
variables will be declared as private and all our member functions will be declared as 
public. Later you will see cases where private member functions are used. 
NOTE: If a program statement outside a class attempts to access a private member , 
a compiler error will result. Later you will learn how outside functions may be given 
special permission to access private class members . 
Placement of private 
and public Members 
It does not matter whether we list the private or public members first. In fact, it is not 
even required that all members of the same access specification be declared together. 
Both examples below are legal declarations of the Ci rel e class. 
class Circle 
{ public: 
} ; 
void setRadius(doubl
e r) 
{ radius = r; } 
doubl e calcArea 
() 
{ ret urn 3.14 
* pow(rad i us, 2); } 
private: 
doubl e rad i us; 
class Circle 
{ public: 
void setRadius(dou ble r) 
{ radius = r; } 
private: 
double rad i us; 
publ i c: 
} ; 
doubl e calcAr ea () 
{ re t urn 3.14 
* pow 
(radius, 
2); 
} 
Most programmers consider it more orderly to separate private and public members, 
and most instructors prefer that you do this. In this text we follow the standard practice 
of listing private members together first, followed by the public members, as shown in 
the initial Ci rel e declaration. 

414 
Chapte r 7 
7.4 
a 
VideoNot e 
Creating and 
Using Class 
Objects 
Figure 7-3 
Introduction to Classes and Objects 
Creating and Using Objects 
CO N C E PT: Objects are instances of a class. They are created with a definition statement 
after the class has been declared. 
A class declaration is similar to the blueprint for a house. The blueprint itself is not a 
house, but is a detailed description of a house. When we use the blueprint to build an 
actual house, we could say we are constructing an instance of the house described by the 
blueprint . If we wish, we can constr uct several identical houses from the same blueprint. 
Each house is a separate instance of the house described by the blueprint. This idea is 
illustrated in Figure 7-3. 
Blueprint that describes a house . 
....... 
Instances of the house described by the blueprin t. 
EB 
EB 
EB 
tE 
tE 
tE 
A class declaration serves a similar purpose. It describes what the objects created from 
the class will look like when they are constructed . Each object created from it is called 
an instance of the class, and defining a class object is called instantiating the class. 
Class objects for classes you define are created with simple definition statements, just 
like objects of classes defined in header files and just like variables. For example, the 
following statement defines ci rel e1 and ci rel e2 to be two objects of the Ci rel e class: 
Circle 
c i rcle 1, 
c i rcle2
; 
They are two distinct instances of the Ci rel e class, with different memory assigned to 
hold the values stored in their member variables. 

7.4 Creating and Using Objects 
415 
Accessing an Object's Members 
Public members of a class object are accessed with the dot operator. You saw this in 
the previous section when we called the length function for the st ring object city 
with the following statement: 
cout <<city.length()<< 
endl; 
The following statements call the setRadi us function of ci rel e1 and ci rel e2. 
circle1
. setRadius(1.0); 
circle2
.setRadius(2.5); 
// Thi s se t s circle1's 
rad i us to 1.0 
// Thi s se t s circle2's 
rad i us to 2.5 
Notice that member functions, just like regular functions, can be passed arguments when 
they are called if they have been defined to accept arguments. We defined setRadi us to 
accept one double argument . 
As mentioned earlier, an object's member variables are usually declared to be private. 
However, if one were declared to be public, it also could be accessed from outside the 
class by using the dot operator. If the ci rel e class radius variable was public, we 
could just set it like this: 
circle1 
.radius= 
1 .O; 
circle2
.radius 
= 2.5; 
Now that the radii have been set, we can call the cal cArea member function to return 
the area of the Ci rel e objects: 
cout << "The area of circle1 
is"<< 
circle1 
.calcArea 
() << endl; 
cout << "The area of circle2 
is"<< 
circle2.calcArea 
() << endl; 
Program 7-1 is a complete program that demonstrates the Ci rel e class. Notice that the 
statements to create and use Ci rel e objects are in main, not in the class declaration . 
Program 7-1 
1 // Thi s program demonstra t es a simple class. 
2 #include 
<iostream> 
3 #include 
<cmath> 
4 using namespace std; 
5 
6 // Circle 
class 
declara ti on 
7 class 
Ci rcle 
8 { 
pr i vate: 
9 
double radius; 
10 
11 
publ i c: 
12 
void setRadius(double 
r) 
13 
{ 
radius= 
r; 
) 
14 
15 
double calcArea() 
16 
{ 
return 
3.14 
* pow(radius, 
2); 
) 
17 ) ; 
18 
(program continues) 

41 6 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-1 
(continued) 
19 int main() 
20 { 
21 
II Defi ne 2 Circle 
objects 
22 
Circle 
ci rcle 1, 
23 
circle2
; 
24 
25 
26 
27 
28 
function 
for each circle 
II Thi s sets 
circle1's 
II This sets 
circle2's 
II Cal l the setRadius 
circle1
. setRadius(1); 
circle2
.setRadius(2.5); 
rad i us to 1 .0 
rad i us to 2.5 
29 
II Call the calcArea 
function 
fo r each circle 
and 
30 
II di splay the returned 
res ult 
31 
cout << "The area of circle1 
is"<< 
ci rcle 1.ca lcArea () << endl; 
32 
cout << "The area of circle2 
is"<< 
circle2
.ca lcArea () << endl; 
33 
34 
ret urn O; 
35 } 
Program Output 
The area of circle1 
is 3.14 
The area of circle2 
is 19.625 
7.5 
Accessors and Mutators 
Notice in lines 13 and 16 of Program 7-1 how the class member functions setRadius 
and cal cArea use the member variable rad i us . They do not need to use the dot operator 
to reference it because member functions of a class can access member variables of the 
same class like regular variables, without any extra notation. Notice also that the class 
member function cal cArea only uses, but does not modify , the member variable radius. 
A funct ion like this, that uses the value of a class variable but does not change it, is 
known as an accessor. The function setRadi us, on the other hand , modifies the contents 
of rad i us. A member function like this, which stores a value in a member variable or 
changes its value, is known as a mutator . Some programme rs refer to mutators as set 
functions or setter functions because they set the value of a class variable and refer to 
accessors as get functions or getter functions because they just retrieve or use the value. 
Defining Member Functions 
CONCEPT: 
Class member function s can be defined either inside or out side the class 
declaration. 
Class member funct ions are defined similarly to regular functions. Except for a few 
special cases we will look at later, they have a function header that includes a return 
type (which may be void) , a function name, and a parameter list (which may possibly 
be empty) . Th e statements that carry out the actions of the function are contained 
within a pair of braces that follow the function header. 

CD 
7.5 Defining Member Functions 
4 17 
When we defined the Ci rel e class in the previous section, we defined its two member 
functions within the class declarat ion itself. When a class function is defined there , it is 
called an inline function. Inline functions provide a convenient way to contain function 
information within a class declaration , but they can only be used when a function body 
is very short, usually a single line. When a function body is longer, we place a prototype 
for the function in the class declarat ion, instead of the function definition itself. We 
then put the function definition outside the class declaration, either following it or in a 
separate file. 
Even though the two functions in our Ci rel e class are short enough to be written as 
inline functions , we will rewrite them as regular functions , defined outside the class 
declaration , to illustrate how this is done. Inside the class declaration the functions will 
be replaced by the following prototypes: 
voi d setRadius (double ); 
double calcArea( ); 
Following the class declaration we will place a function implementation section 
conta ining the following function definitions: 
voi d Ci rcle: :setRad i us(double 
r) 
{ 
radius= 
r ; 
} 
double Ci rcle: :calcArea( } 
{ 
return 
3 .1 4 * pow(radius, 
2); 
} 
Notice that these look like ordinary functions except that the class name and a double 
colon (: : ) are placed after the function return type, just before the function name. The 
: : symbol is called the scope resolution operator. It is needed to indicate that these are 
class member functions and to tell the compiler which class they belong to. 
WARN I NG ! The class name and scope resolution operator are an extension of 
the function name. When a function is defined outside the class declaration, these 
must be present and must be located immediately before the function name in the 
function header. 
Here are some additional examples to illustrate how the scope resolution is used when 
a class function is defined outside the class declaration. 
double calcArea( ) 
II Wrong! The class 
name and scope 
II resolution 
operator 
are mi ssing. 
Circle: :doubl e calcArea(} 
II Wrong! The class 
name and scope 
II resolution 
operator 
are mi splaced. 
double Ci rcle: :calcArea( } 
II Correct! 
Program 7-2 revises Program 7-1 to define the class member functions outside the class. 

418 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-2 
1 II Thi s program demonstrates 
a simple class 
with member funct i ons 
2 II defined 
outside 
the class 
declarat
i on . 
3 #include 
<iostream> 
4 #include 
<cmath> 
5 using namespace std ; 
6 
7 II Circle 
class 
declarat
i on 
8 class 
Ci rcle 
9 { 
pr i vate: 
10 
double radius; 
11 
12 
13 
14 
15 } ; 
16 
publ i c: 
void 
setRad i us(double); 
double calcArea(); 
II This is a member var i able . 
II These are just 
prototypes 
II for the member funct i ons. 
17 II The member function 
implementation 
section 
follows
. It conta i ns the 
18 II actual 
function 
defin i tions 
for the Circle 
class 
member functions
. 
19 
20 /******************************************************************* 
* 
Ci rcle: :setRad i us 
* 
21 
22 
23 
* 
* 
This function 
copies 
the argument passed into the parameter 
to* 
the private 
member variable 
rad i us . 
* 
24 
*******************************************************************/ 
25 void Circle: 
:setRadius(double 
r} 
26 { 
radius= 
r ; 
27 } 
28 
29 /****************************************************************** 
30 
* 
Circle: 
:calcArea 
* 
31 
* Thi s funct i on calculates 
and returns 
the Circle 
object's 
area. 
* 
32 
* It does not need any parameters 
because it already 
has access 
* 
33 
* to the member var i able radius. 
* 
34 
******************************************************************/ 
35 double Circle: 
:calcArea() 
36 { 
return 
3.14 * pow(rad i us, 2); 
37 } 
38 
39 /**************************************************************** 
40 
* 
main 
* 
41 
****************************************************************/ 
42 int main() 
43 { 
44 
45 
46 
47 
48 
49 
Circle 
ci rcle1 , 
ci rcle2 ; 
ci rcle1.setRadius(1}; 
ci rcle2.setRadius(2
.5); 
II Define 2 Circle 
objects 
II This sets 
circle1's 
radius 
to 1 .0 
II This sets 
circle2's 
radius 
to 2 .5 
(program continues) 

7.5 Defining Member Functions 
419 
Program 7-2 
(continued) 
50 
51 
cout << "The 
52 
cout << "The 
53 
54 
return 
O; 
55 } 
area of 
area of 
II Get and di splay each circle's 
area 
ci rcle 1 i s"<< 
circle1.calcArea() 
<< endl; 
ci rcle2 i s "<< circle2.calcArea() 
<< endl; 
Program Output Is the same as for Program 7-1. 
Naming Conventions for Class Member Functions 
Program 7-3 provides another example using classes and objects . It declares and 
implements a Rectangle class that has two private member variables and five public 
member functions. Not ice that the names of four of the member functions in Program 7-3 
begin with the word set or the word get. Functions set Length and setWi dth are mutator, 
or set, functions. It is common to name a mutator with the word set followed by the name 
of four of the member variable whose value it is setting . As you would expect, the 
set Length function sets the value of the l ength member variable and the setWi dth 
function sets the value of the width member variable. 
Member functions get Length and getWidth are accessor, or get, functions. It is common 
to name an accessor with the word get followed by the name of the member variable 
whose value it is getting if all it does is return the value stored in the variable. Function 
getlength 
returns the value stored in the length membe r variable, while getWidth 
returns the value stored in the width member variable. Th e final member function, 
cal cArea , is an accessor function because it just uses, and does not change, any value 
stored in the class variables. However, its name does not begin with get because it is 
calculating the value it returns rather than just retrieving a value stored in a class variable. 
Program 7-3 
1 II Thi s program implements a Rectang le class . 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Rectangle 
class 
declaration 
6 class 
Rectangle 
7 { 
8 
pr i vate: 
9 
double length ; 
10 
double width; 
11 
public : 
12 
void setlength(double); 
13 
void setWidth(double); 
14 
double getlength(); 
15 
double getWi dth(); 
16 
double calcArea(); 
17 } ; 
18 
(program continues) 

420 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-3 
(continued) 
19 II Member function 
implementation 
section 
20 
21 /******************************************************************** 
22 
* 
Rectangle::setlength 
* 
23 
* This function 
sets 
the value of the member variable 
length. 
* 
24 
* If the argument passed to the function 
is zero or greater, 
it is
* 
25 
* copied into lengt h . If it is negat i ve, 1 .0 is ass i gned to length.* 
26 
********************************************************************/ 
27 void Rectangle: 
:setlengt
h(double len) 
28 { 
29 
if (len >= 0.0) 
30 
lengt h = len; 
31 
else 
32 
{ 
length= 
1.0; 
33 
cout << "Invalid 
length. 
Using a default 
value of 1.0\n"; 
34 
} 
35 } 
36 
37 /******************************************************************** 
38 
* 
Rectangle: 
:setWi dth 
* 
39 
* This function 
sets 
the value of the member variable 
width. 
* 
40 
* If t he argument passed to the function 
is zero or greater, 
it is
* 
41 
* copied into width. 
If it is negative, 
1.0 is assigned 
to wi dth. 
* 
42 
********************************************************************/ 
43 void Rectangle: 
:setWi dth(double 
w) 
44 { 
45 
if 
(w >= 0.0) 
46 
wi dth= 
w; 
47 
else 
48 
{ 
widt h = 1 .0; 
49 
50 
51 } 
52 
cout << "Invalid 
width . Usi ng a default 
value of 1.0 \n"; 
} 
53 /************************************************************** 
54 
* 
Rectangle: 
:getlength 
* 
55 
* This function 
returns 
the value i n member var i able length. 
* 
56 
**************************************************************/ 
57 double Rectangle: 
:getlengt
h() 
58 { 
59 
return 
length; 
60 } 
61 
62 /************************************************************** 
* 
Rectangle: 
:getWidt h 
* 
* This function 
returns 
the value i n member var i able width . 
* 
63 
64 
65 
66 
67 
68 
69 } 
**************************************************************/ 
70 
double Rectangle: 
:getWi dth() 
{ 
return 
width ; 
(program continues) 

7.5 Defining Member Functions 
42 1 
Program 7-3 
(continued) 
71 / *** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * * * * * * * 
72 
73 
* 
Rectangle::calcArea 
* 
* This function 
calcula
t es and returns 
the area of t he rectangle
. * 
74 
*** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * * * * * * * / 
75 double Rectangle: 
:calcArea
( ) 
76 { 
77 
retur n length
* width ; 
78 } 
79 
80 / *** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * 
81 
* 
mai n 
* 
82 
*** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * / 
83 in t mai n() 
84 { 
85 
Rectangle 
box ; 
II Declare 
a Rectangle 
obj ec t 
double boxLength , boxWi dth ; 
II Get box lengt h and widt h 
86 
87 
88 
89 
90 
91 
92 
93 
94 
cout 
<< "This program will 
calcula
t e the area of a rectangle.
\ n"; 
cout 
<< "What i s the leng t h? ". 
' 
ci n 
>> boxLengt h ; 
cout 
<< "What i s the wi dth? 
" . 
ci n 
>> boxWidth ; 
95 
II Call member func ti ons t o set box dimensions 
96 
box.se t Length (boxLength ); 
97 
box.se t Widt h(boxWidth ); 
98 
II Call member func ti ons t o get box i nformat i on 
99 
100 
101 
102 
103 
cout 
<< "\ nHere i s t he rectangle's 
data: \ n"; 
cout 
<< "Lengt h : " << box .getLength(
) << endl ; 
cout 
<< "Widt h 
" << box .getWidt h() 
<< endl ; 
cout 
<< "Area 
" << box .calcArea () 
<< endl ; 
104 
retur n O; 
105 } 
Program Output with Example Input Shown in Bold 
This program wi ll calculate 
t he area of a rec t angle. 
What is the length? 
3[Enter] 
What is the widt h? - 1 [Enter ] 
Invalid 
width. 
Using a default 
value of 1 .0 
Here is the rec t angle's 
dat a: 
Lengt h: 3 
Wi dth : 1 
Area 
3 
to di splay 
Program Output with Different Example Input Shown in Bold 
This program wi ll calculate 
t he area of a rec t angle. 
What is the length? 
10.l [Enter ] 
What is the widt h? 5[Enter ] 
Here is 
Lengt h: 
Wi dth 
Area 
the rec t angle's 
10. 1 
5 
50.5 
dat a: 

422 
Chapte r 7 
Introduction to Classes and Objects 
We mentioned earlier that when designing a class it is common practice to make all 
member variables private and to provide public set and get functions for accessing 
those variables. This safeguards the data . Functions outside the class can only access 
the member data through calls to the public member functions, and these functions can 
be written to prevent the data from being corrupted or modified in a way that might 
adversely affect the behavior of an object of the class. Notice in Program 7-3 how the 
two set functions are written to filter out invalid data . Rather than allowing an invalid 
value to be stored in a member variab le, they use a default value if the data passed to 
them is not acceptable. 
Avoiding Stale Data 
In the Rectangle 
class, the get Lengt h and getWi dt h member functions return the 
values stored in the l en gt h and widt h member variab les, but the cal cArea member 
function returns the result of a calculation . You might wonder why the area of the 
rectangle is not also stored in a member variable. The area is not stored because it could 
potentially become stale. When the value of an item is dependent on other data and that 
item is not updated when the other data is changed, we say that the item has become 
stale. If the area of the rectangle were stored in a member variable, its value would 
become incorrect as soon as either the leng t h or width member variable changed. 
When designing a class, you should normally not use a member variable to store a 
calculated value that could potentially become stale . Instead, provide a member 
function that calculates the value, using the most current data, and then returns the 
result of the calculation . 
More on lnline Functions 
When designing a class, you will need to decide which member functions to write as 
inline functions within the class declaration and which ones to define outside the class. 
Inline functions are handled completely differently by the compiler than regular functions 
are. An understanding of this difference may help you decide which to use when. 
A lot goes on behind the scenes each time a regular function is called. A number of special 
items, such as the address to return to when the function has finished executing and the 
values of the function arguments, must be stored in a section of memory called the stack. In 
addition, local variables are created and a location is reserved to hold the function's return 
value. All this overhead, which sets the stage for a function call, takes CPU time. Although 
the time needed is small, it can add up if a function is called many times, as in a loop. 
An inline function, on the other hand, is not called in the conventional sense at all. 
Instead, in a process known as inline expansion, the compiler replaces every call to the 
function with the actual code of the function itself. This means that if the function is 
called from multiple places in the program, the entire body of its code will be inserted 
multiple times, increasing the size of the program . This is why only a function with 
very few lines of code should be written as an inline function. In fact, if the function is 
too large to make the inline expansion practical, the compiler will ignore the request to 
handle the function this way. However, when a member function is small, it can 
improve performance to write it as an inline function because there is less overhead 
when you don't make actual function calls. 

7.6 Constructors 
423 
~ 
Checkpoint 
0 
7.1 
Which of the following shows the correct use of the scope resolution operator in 
a member function definition? 
A) Invl t em: :void setOnHand(int 
units) 
B) void Invltem: :setOnHand(int 
units) 
7.2 
An object's private member variables can be accessed from outside the object by 
A) public member functions 
B) any function 
C) the dot operator 
D ) the scope resolut ion operator 
7.3 
Assuming that soap is an instance of the Inventory class, which of the following 
is a valid call to the setOnHand member function? 
A) set OnHand(20); 
B) soap: :se t OnHand(20); 
C) soap. setOnHand(20); 
D) Inventory.setO
nHand(20); 
7.4 
Complete the following code skeleton to declare a class called Oate. The class 
should contain member variables and functions to store and retrieve the month, 
day, and year components of a date. 
class 
Dat e 
{ pr i vat e: 
publ i c: 
} 
Constructors 
CONCEPT : A constructor is a member function that is automatically called when a 
class object is created. 
A constructor is a special public member function that is automatically called to 
construct a class object when it is created . If the programmer does not write a 
constructor, C++ automatically provides one. You never see it, but it runs silently in the 
background each time your program defines an object. Often, however, programmers 
write their own constructor when they create a class. If they do this, in addition to 
constructing each newly created object of the class, it will execute whatever code the 
programmer has included in it. Most often programmers use a constructor to initialize 
an object's member variables. However, it can do anything a norma l function can do. 
NOTE: 
Information on how to denote a constructor in UML can be found in 
Appendix Fon this book's compan ion website at pearsonhighered .com/gaddis . 
A constructor looks like a regular function except that its name must be the same as the 
name of the class it is a part of. This is how the compiler knows that a particular member 
function is a constructor. Also, a constructor is not allowed to have a return type. 

4 24 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-4 includes a class called Demo with a constructor that does nothing except 
print a message. It was written this way to demonstrate when the constructor executes. 
Because the Demo object is created between two cout statements, the constructor will 
print its message between the output lines produced by those two statements . 
Program 7-4 
1 II Thi s program demonstra t es when a cons t ruc t or execu t es. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 class 
Demo 
6 { 
7 publ i c: 
8 
Demo () 
II Const ruc t or 
9 
{ 
10 
cout << "Now t he cons t ruc t or i s run ning. \n"; 
11 
} 
12 } ; 
13 
14 int main () 
15 { 
16 
cout << "This is displayed 
before the objec t i s crea t ed.\n"; 
17 
18 
19 
Demo demoObj; 
II Defi ne a Demo obj ect 
20 
cout << "This is displayed 
after 
the object 
is created
. \n"; 
21 
return 
O; 
22 } 
Program Output 
This is displayed 
before the objec t i s crea t ed. 
Now t he const r uctor is runn i ng. 
This is displayed 
after 
the object 
is created. 
In Program 7-4 we defined the constructor 
as an inline function inside the class 
declaration . However, like any other class member function, we could have just put its 
prototype in the class declarat ion and then defined it outs ide the class . In that case, we 
wou ld need to add the name of the class the function belongs to and the scope resolution 
operator in front of the function name . But the name of the constructor function is the 
same as the class name, so the name wou ld appear twice. Here is how the funct ion 
header for the Demo constructor wou ld look if we defined it outside the class. 
Demo : : Demo ( ) 
{ 
II Constructor 
cout << "Now the constructor 
is running. \ n"; 
) 
Program 7-5 modifies Program 7-2 to include a constructor that initializes an object's 
member data. The constructor is defined outside of the class. 

7.6 Constructors 
42 5 
Program 7-5 
1 II Thi s program uses a constructor 
to initialize 
a member var i able . 
2 #include 
<iostream> 
3 #include 
<cmath> 
4 using namespace std ; 
5 
6 II Circle 
class 
declarat
i on 
7 class 
Ci rcle 
8 { 
pr i vate: 
9 
double radius; 
10 
11 
12 
13 
14 
15 } ; 
16 
publ i c: 
II Member function 
prototypes 
Circle(); 
void setRadius(double}; 
double calcArea(); 
17 II Circle 
member function 
implementation 
section 
18 
19 /******************************************** 
20 
* 
Circle: 
:Ci rcle 
21 
* Thi s is the constructor. 
It in i t i alizes 
22 
* the radius 
class 
member variable. 
* 
* 
* 
23 
********************************************/ 
24 Circle: 
:Ci rcle () 
25 { 
radius= 
1.0; 
26
} 
27 
28 /******************************************** 
29 
* 
Circle::setRadius 
* 
30 
* Thi s funct i on val i dates 
the value passed* 
31 
* to it before 
assigning 
it to the rad i us 
* 
32 
* member var i able. 
* 
33 
********************************************/ 
34 void Circle: 
:setRadius(double 
r} 
35 { 
if 
(r >= 0.0) 
36 
rad i us= 
r; 
37 
II else 
leave it set to its 
prev i ous value 
38 } 
39 
40 /********************************************** 
41 
* 
Circle: 
:calcArea 
* 
42 
* Thi s funct i on calculates 
and returns 
the 
* 
43 
* Circle 
object's 
area . It does not need any* 
44 
* parameters 
because i t can directly 
access 
* 
45 
* the member variable 
radius
. 
* 
46 
**********************************************/ 
47 double Circle: 
:calcArea() 
48 { 
return 
3.14 * pow(rad i us, 2); 
49
} 
(program continues) 

4 26 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-5 
50 
(continued) 
51 /*************************************** 
52 
53 
54 
55 
* 
main 
* The mai n function 
creates 
and uses 
* 2 Circle 
objects
. 
* 
* 
* 
***************************************/ 
56 int main() 
57 { 
58 
II Defi ne a Circ le object. 
Beca use the setRadi us function 
59 
II is never called 
for it , it will 
keep the value set 
60 
II by the constructor. 
61 
Circle 
ci rcle 1; 
62 
63 
II Defi ne a second Circle 
object 
and set 
its 
radius 
to 2 .5 
64 
Circle 
circle2
; 
65 
circle2
.setRadius(2.5); 
66 
67 
II Get and display 
each circle
's area 
68 
cout << "The area of circle1 
is"<< 
circle
1.ca lcArea () << endl ; 
69 
cout << "The area of circle2 
is"<< 
circle2
.ca lcArea () << endl ; 
70 
71 
ret urn O; 
72 } 
Program Output 
The area of circle1 
is 3.14 
The area of circle2 
is 19.625 
Overloading Constructors 
Recall from Chapter 6 that when two or more functions share the same name, the 
function name is said to be overloaded . Multiple functions with the same name may 
exist in a C++ program, as long as their parameter lists are different . 
Any class member function 
may be overloaded, 
including the constr ucto r. One 
constructor 
might take an integer arg um ent, for example, while another constr uctor 
takes a double . Th ere could even be a third constructor 
taking two int egers . As 
long as each constr uctor has a different list of parameters, 
the compi ler can tell 
them apart . 
Program 7-6 declares and uses a class named Sale , wh ich has two constructors . Th e 
first has a parameter that accepts a sales tax rate . Th e second, which is for tax-exempt 
sales, has no parameters. It sets the tax rate to 0. A constructor like this, whic h has no 
parameters, is called a default constructor. 

Program 7-6 
1 II Thi s program demonstrates 
the use of overloaded 
constructors. 
2 #inc l ude <iostream> 
3 #inc l ude <iomanip> 
4 using namespace std ; 
5 
6 II Sale class 
dec l arat i on 
7 class 
Sal e 
8 { 
9 private
: 
10 
double taxRate ; 
11 
12 publ i c : 
13 
Sal e (double rate ) 
14 
{ taxRate 
= rate ; 
15 
} 
16 
17 
18 
19 
20 
Sal e () 
{ taxRate 
= 0.0 
} 
II Constructor 
with 1 parameter 
II hand l es taxab l e sales 
II Defa ult constructo
r 
II hand l es tax-exempt 
sales 
21 
doubl e calcSa l eTotal (double cost ) 
22 
{ double total 
= cost
+ cost *taxRate ; 
23 
return 
total
; 
24 
} 
25 }; 
26 
27 int main () 
28 { 
7.6 Constructors 
427 
29 
30 
Sale cas hier 1(. 06); 
Sale cashier2
; 
II Defi ne a Sal e obj ect wi t h 6% sales 
tax 
II Defi ne a tax-exempt 
Sale object 
31 
32 
II Format the output 
33 
cout <<fixed<< 
showpoi nt << setprecision
(2); 
34 
35 
II Get and display 
the tota l sa l e pr i ce for two $24.95 sa l es 
36 
cout << "Wi th a 0.06 sales 
tax rate , the total
\ n"; 
37 
cout << "of the $24.95 sa l e is$"
; 
38 
cout << cashier1 .calcSaleTota
l( 24 .95) << end l; 
39 
40 
cout << "\ nOn a tax-exempt 
purchase , the total
\ n"; 
41 
cout << "of the $24.95 sa l e is , of course , $"; 
42 
cout << cashier2
.calcSaleTota
l( 24 .95) << end l; 
43 
return 
O; 
44 } 
Program Output 
With a 0.06 sales 
tax rate, 
the total 
of the $24.95 sale 
is $26.45 
On a tax-exempt 
purchase , the total 
of the $24.95 sale 
is , of course, 
$24.95 

428 
Chapter 7 
Introduction to Classes and Objects 
Notice on lines 29 and 30 of Program 7-6 how the two Sale objects are defined. 
Sale cashier 1(.0 6); 
Sale cashier2
; 
There is a pair of parentheses after the name cashi er1 to hold the value being sent to 
the one-parameter constr uctor. However , there are no parentheses after the name 
cashi er2, which sends no arguments. In C++ when an object is defined using the 
default constr uctor, instead of passing arguments, there must not be any parentheses. 
Sale cashier2 (); 
Sale cashier2
; 
/ / Wrong! 
// Correct 
Default Constructors 
The Sale class needed a default constructor to handle tax-free sales. Other classes may 
appear not to need one- for examp le, if objects created from them are always expected 
to pass arguments to the constr uctors . Yet, any time you design a class that will have 
constructors, 
it is cons idered good programming 
practice to include a defau lt 
constructor. If you do not have one, and the program tries to create an object without 
passing any arguments, it will not compile. This is because there must be a constr uctor 
to create an object. In order to create an object that passes no arguments, there must be 
a constructo r that expects no arguments - a default constr uctor. If the programmer 
doesn't write any constructors for a class, the comp iler automatica lly creates a default 
constructor for it. However , when the programmer writes one or more constructors, 
even ones that all have parameters , the compiler does not create a default constr uctor. 
So it is the responsibility of the programmer to do this. 
A class may have many constr uctors but can only have one default constructor. This is 
because if multiple functions have the same name, the compiler must be able to 
determine from their parameter lists which one is being called at any given time. It uses 
the number and type of arguments passed to the function to determine which of the 
overloaded functions to invoke. Because there can be only one function with the class 
name that is able to accept no arguments, there can be only one default constr uctor. 
Normally, as in the Sale class, default constr uctors have no parameters. However, it is 
possible to have a defau lt constr uctor with parameters if all of them have default 
values, so that it can be called with no arguments. It would be an error to create one 
constr uctor that accepts no arguments and another that has arguments but allows 
default values for all of them. This would essentially create two "defa ult" constructors. 
The following class declaration does this illegally. 
class Sale 
// Illegal 
declarat i on! 
{ private: 
} ; 
double taxRate ; 
publ i c : 
Sale() 
// Default constructor 
with no arguments 
{ taxRate = 0.05; } 
Sale(double 
r = 0.05} // Default constructor with a default argument 
{ taxRate = r; } 
double calcSaleTotal
(doubl e cost) 
{ double total= 
cost+ 
cost
* taxRate; 
return total; 

7.7 
<) 
7.7 Destructors 
429 
As you can see, the first constructor has no parameters. The second constructor has 
one parameter, but it has a default argument . If an object is defined with no argument 
list, the comp iler will not be able to tell which constructor to execute . 
Destructors 
CONCEPT : A destr uctor is a member function that is autom atically called when an 
object is destroyed. 
Destructors are public member functions with the same name as the class, preceded by 
a tilde character(-). 
For example, the destructor for the Recta ngle class wou ld be 
named-Recta
ngle . 
Destructors are automatically called when an object is destroyed. In the same way that 
constructors can be used to set things up when an object is created, destructors are 
used to perform shutdown procedures when an object ceases to exist. This happens, for 
example, when a program with an object stops executing or when you return from a 
function that created an object . 
NOTE: 
Information on how to denote a destructor in UML can be found in 
Appendix Fon this book's compan ion website at pearsonhighered .com/gaddis . 
Program 7-7 shows a simple class with a constructor and a destructor. It illustrates 
when each is called during the program's execution . 
Program 7-7 
1 II Thi s progra m demonstra t es a destruc t or. 
2 #include 
<iostr eam> 
3 using namespace std; 
4 
5 class 
Demo 
6 { 
7 
8 
9 
10 } ; 
11 
publ i c: 
Demo(); 
-Demo(); 
II Const ruc t or prot ot ype 
II Destructor 
prototy pe 
12 Demo::Demo() 
II Const ruc t or function 
defi nition 
13 { 
cout << "An object 
has j ust been def i ned, so the constructor" 
14 
<<" 
i s runn i ng. \n"; 
15 } 
16 
17 Demo::-Demo() 
II Destructor 
func ti on defin i t i on 
18 { 
cout << "Now t he dest ruc t or is run ning.\n"; 
19 } 
20 
(program continues) 

43 0 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-7 
21 int main () 
22 { 
(continued) 
23 
Demo demoObj; 
// Declare 
a Demo object; 
24 
25 
cout << "The obj ect now exis t s, but i s about to be des t royed.\ n"; 
26 
return 
O; 
27
} 
Program Output 
An obj ect has j ust been def i ned, so the const r uctor is runn i ng. 
The object 
now exis t s, but i s about to be des t royed. 
Now t he destruc t or is running. 
In addition to the fact that destructors are automatically called when an object is 
destroyed, the following points should be mentioned: 
• Like constructors, destructors have no return type . 
• Destructors cannot accept arguments , so they never have a parameter list. 
• Because destructors cannot accept arguments, there can only be one destructor. 
Destructors are most useful when working with objects that are dynamically allocated. 
You will learn about this in Chapter 10. 
~ 
Checkpoint 
7.5 
Briefly describe the purpose of a constructor. 
7.6 
Constructor functions have the same name as the 
A) class 
B) class instance 
C) program 
D) none of the above 
7. 7 
A constructor that requires no arguments is called 
A) a default constructor 
B) an inline constructor 
C) a null constructor 
D) none of the above 
7.8 
Assume the following is a constructor: 
ClassAc t : :ClassAct( i nt x} 
{ 
item= 
x; 
} 
Define a Cl assAct object called sa 11 y that passes the value 25 to the constructor. 
7.9 
True or false: Like any C++ function , a constructor 
may be overloaded, 
provid ing each constructor has a unique parameter list. 

7.7 Destructors 
431 
7.10 
True or false: A class may have a constructor with no parameter list and an 
overloaded constructor whose parameters all take default arguments. 
7.11 
A destructor function name always starts with 
A) a number 
B) the tilde character (-) 
C) a data type name 
D ) the name of the class 
7.12 
True or false: Just as a class can have multiple constructors, it can also have 
multiple destructors . 
7.13 
What will the following program code display on the screen? 
class 
Tank 
{ 
pr i vat e: 
i nt gallons; 
publ i c: 
Tank() 
{gallons= 
50; } 
Tank( i nt gal) 
{gallons= 
gal; 
} 
i nt get Gal lons() 
{ return 
gallons; 
} 
} ; 
i nt mai n() 
{ Tank st orage 1 , storage2, 
storage3(20); 
} 
cout << storage1.ge
t Gallons() 
<< endl; 
cout << storage 2 .ge t Gallons() 
<< endl; 
cout << storage3.ge
t Gallons() 
<< endl; 
re t ur n O; 
7.14 
What will the following program code display on the screen? 
class 
Package 
{ 
pr i vat e: 
i nt value; 
publ i c: 
Package() 
{value= 
7; cout <<value<< 
endl; 
} 
Package(in t v) 
{value= 
v; cout <<value<< 
endl; 
} 
-Package() 
{ cout <<"good bye"<< 
endl; 
} 
} ; 
i nt mai n() 
{ Package obj1(4); 
Package obj2; 
re t ur n O; 
} 

432 
Chapte r 7 
7.8 
Introduction to Classes and Objects 
Private Member Functions 
CONCEPT: 
Private member functions may only be called from a function that is a 
member of the same class. 
Unti l now all of the class member funct ions you have seen have been publ ic funct ions. 
This means they can be called by code in programs outs ide the class. Often, however, a 
class needs functions for internal processing that should not be called by code outside 
the class . These functions should be made private . 
Program 7-8 shows an examp le of a class with a private function . The Si mp l eSt at class is 
designed to find and report informat ion, such as the average and the largest number, from 
a set of non -negative integers sent to it. However, once a number has been received and 
added to a running total, it is not kept. So the class cannot later determine which number 
was the biggest. It must do this by examining each number it reads in to see if it is bigger 
than any number it previously read . The private i sNewlarges t function does this. 
0 
NOTE: Informat ion on how to denote private and public members in UML can be 
found in Appendix Fon this book's companion website at pearsonh ighered.com/gaddis . 
Program 7-8 
1 
// This program uses a class wit h a Boolean funct i on tha t determ i nes 
2 
II 
if a new value sent to it is the largest 
value received 
so far . 
3 #include 
<i ost ream> 
4 
using namespace std; 
5 
6 class 
SimpleS t at 
7 
{ 
8 
9 
10 
11 
12 
pr i vate: 
i nt larges t ; 
i nt sum; 
i nt count ; 
// The largest 
number rece i ved so far 
// The sum of t he numbers received 
// How many numbers have bee n received 
13 
bool i sNewlargest(
i nt); 
// Thi s is a priva t e class 
func t ion 
14 
15 
publ i c: 
16 
17 
18 
19 
20 
Si mp l eStat () ; 
bool addNumber(i nt); 
double calcAverage(); 
21 
i nt get largest() 
22 
{ return 
largest; 
} 
23 
24 
i nt get Count() 
25 
{ return 
count; 
} 
26 
}; 
// Default 
constructor 
(program continues) 

Program 7-8 
(continued) 
27 
28 
II Si mpleStat 
Class Implementation 
Code 
29 
30 
31 
32 
33 
34 
35 
36 
37 
/************************************* 
* 
SimpleStat 
Default 
Constructor 
* 
*************************************/ 
SimpleStat: 
:SimpleStat() 
{ 
largest= 
sum = count= 
O; 
} 
38 
/************************************* 
39 
* 
SimpleStat: 
:addNumber 
* 
40 
*************************************/ 
41 
bool SimpleStat: 
:addNumber(int 
num) 
42 
{ 
bool goodNum = true; 
43 
if (num >= 0) 
II 
If num is valid 
44 
{ 
45 
sum+= num; 
II Add it to the sum 
46 
count ++; 
II Count it 
47 
if (isNewLargest(num)) 
II 
Fi nd out i f it is 
48 
largest
= num; 
II the new largest 
49 
} 
50 
else 
II 
num is i nvalid 
51 
goodNum = false; 
52 
53 
return 
goodNum; 
54 
} 
55 
56 
/************************************* 
57 
* 
Simpl eStat: :i sNewLargest 
* 
58 
*************************************/ 
59 
bool SimpleStat: 
:isNewLargest(int 
num) 
60 
{ 
61 
if (num > largest) 
62 
return 
true ; 
63 
else 
64 
65 
} 
66 
return 
false; 
67 
/************************************* 
68 
* 
SimpleStat: 
:calcAverage 
* 
69 
*************************************/ 
70 
double Simpl eStat: :calcAverage() 
71 
{ 
72 
if (count> 
0) 
73 
return 
static_cast<double>(sum
) I count; 
74 
else 
75 
return 
O; 
76 
} 
77 
7.8 Private Member Functions 
433 
(program continues) 

434 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-8 
(continued) 
78 
79 
// Client 
Program 
80 
81 
82 
83 
84 
85 
86 
87 
/************************************* 
* 
main 
* 
*************************************/ 
int main() 
{ 
int 
num; 
Si mpleStat 
statHelper; 
88 
cout << "Please 
enter 
the set of non-negative 
i nteger 
\n"; 
89 
cout << "values 
you want to average. 
Separate 
them wi th \n"; 
90 
cout << "spa ces and enter 
- 1 after 
the last 
value . \ n\n"; 
91 
92 
ci n >> num; 
93 
while 
(num >= 0) 
94 
{ 
95 
statHelper.addNumber(num); 
96 
cin 
>> num; 
97 
) 
98 
cout << "\nY ou entered
"<< 
statHelper
.getCount(
) <<" 
values. 
\n"; 
99 
cout << "The largest 
value was " << statHelper.getlargest() 
<< endl; 
100 
cout << "The average 
value was " << statHelper.calcAverage() 
<< endl; 
101 
102 
return 
O; 
103 } 
Program Output with Example Input Shown in Bold 
Please 
enter 
the set of non-negative 
integer 
values 
you want to average. 
Separate 
them with 
spaces 
and enter 
- 1 after 
the last 
value. 
7 6 8 8 9 7 7 8 9 7 -1 [Enter] 
You entered 
10 values. 
The largest 
value was 9 
The average 
value was 7.6 
In Program 7-8 the private function 
i sNewlargest 
was written to create a more 
modular class with code that is easy to follow. Th e program could have been written 
without 
this function. 
H oweve r, in that case, the addNumber function itself would 
have to handle the additional 
work of comparing 
the new value with largest. 
In 
later chapters you will encounter many examples where the use of private functions 
is essentia l. 

7.9 
7.9 Passing Objects to Functions 
435 
Passing Objects to Functions 
CONCEPT
: Class objects may be passed as arguments to functions. 
In Chapter 6 you learned how to use variables as function arguments . Class objects can 
also be passed as arguments to functions. For examp le, the following function has a 
parameter that receives a Rectangle object . 
voi d di splayRectangle(Rectangle 
r) 
{ 
cout << "Lengt h = " << r. get Length () << endl; 
cout << "Width 
= " << r.getW i dth() 
<< endl; 
cout << "Area 
= " << r.calcArea() 
<< endl; 
) 
The following lines of code create a Rectangle object with length 15 and width 10, 
and then pass it to the di sp l ayRectang le function. 
Rectangle 
box(15, 10); 
displayRectangle(box); 
Assuming the Rectangle class includes the member functions used in this examp le, the 
di sp l ayRectangl e function will output the following information: 
Length= 
15 
Width = 10 
Area 
= 150 
As with regular variables, objects can be passed to functions by value or by reference. 
In the Rectangle example, box is passed to the di splayRectangle 
function by value. 
This means that di sp l ayRectangl e receives a copy of box. If di sp l ayRecta ngl e called 
any Rectangle class mutator functions, they would only change the copy of box, not 
the original. If a function needs to store or change data in an object's member variables, 
the object must be passed to it by reference . 
Program 7-9 illustrates this . It has two functions that receive an Inventoryl
t em 
object. The object is passed to storeVal ues by reference because this function needs 
to call a class mutator function that stores new values into the object . The object is 
passed to showVal ues by value because this function on ly needs to use accessor 
functions that retrieve and use values stored in the object's data members . Notice in 
Program 7-9 that the Inve ntory It em class declaration appears before the prototype 
for the storeVal ues and showVal ues functions. This is important. Because both 
functions have an Inve ntoryl t em object as a parameter, the compi ler must know 
what an Inven t ory Item is before it encounters anything that refers to it. Otherwise 
an error will occur. 

436 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-9 
1 II Thi s program passes 
an object 
to a function
. It passes 
it 
2 II to one function 
by reference 
and to another 
by value . 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 #include 
<str i ng> 
6 using namespace std ; 
7 
8 class 
Inventoryitem 
9 { 
10 private: 
11 
int par tNum; 
12 
string 
descript
i on; 
13 
int onHand; 
14 
double price; 
15 
16 publ i c: 
17 
II Part number 
II Item descr i ption 
II Units on hand 
II Unit price 
18 
voi d storeinfo(
i nt p , string 
d, i nt oH, double cost); 
II Prototype 
19 
20 
int getPartNum() 
21 
{ 
return 
partNum ; } 
22 
23 
string 
getDescription(} 
24 
{ 
return 
descr i ption; 
} 
25 
26 
int getOnHand() 
27 
{ 
return 
onHand; } 
28 
29 
double getPrice() 
30 
{ 
return 
price ; } 
31 } ; 
32 
33 II Implementation 
code for Inventoryite
m class 
funct i on storeinfo 
34 void Inventoryitem: 
:sto reinfo
(int 
p, string 
d, int oH, double cost} 
35 { partNum = p ; 
36 
descript
i on = d; 
37 
onHand = oH; 
38 
pr i ce= 
cost; 
39
} 
40 
41 II Function 
prototypes 
for cli ent 
42 void storeValues(Inventoryitem&}; 
43 void showValues (I nvento ryi tem ); 
44 
program 
II Receives 
an object 
by reference 
II Receives 
an object 
by value 
(program continues) 

7.9 Passing Objects to Functions 
437 
Program 7-9 
(continued) 
45 //****************mai
n
****************** 
46 int main() 
47 { 
48 
Inventoryltem 
part; 
49 
50 
storeValues
(part ); 
51 
showValues(part
); 
52 
return 
O; 
53 } 
54 
II part 
is an Inventoryltem 
object 
55 /********************************************************** 
56 
* 
storeValues 
* 
57 
* This function 
stores 
user input data in the members of* 
58 
* an Inventoryltem 
object 
passed to it by reference. 
* 
59 
* ********************************************************/ 
60 void storeValues(Inventoryltem 
&item) 
61 { 
62 
int partNum ; 
II Local variables 
to hold user i nput 
63 
string 
description
; 
64 
int qty ; 
65 
double price; 
66 
67 
II Get the data from the user 
68 
cout << "Enter data for the new part number \ n" ; 
69 
70 
71 
72 
73 
cout << "Part 
number: "· 
cin 
>> partNum ; 
cout << "Descript
i on: "· 
ci n . get(); 
74 
getline(cin, 
descript
ion ); 
II Move past the '\ n ' left 
in the 
II input buffer 
by the last 
input 
75 
cout << "Quantity 
on hand : "· 
76 
cin 
>> qty ; 
77 
cout << "Unit price: 
"· 
78 
cin 
>> price ; 
79 
80 
81 
82 } 
83 
II Store the data in the Inventoryltem 
object 
item.storelnfo(partNum, 
descript
i on, qty, 
price); 
84 
85 
86 
87 
88 
/******************************************************** 
* 
showValues 
* 
* This function 
displays 
the member data stored 
in the* 
* Inventoryltem 
object 
passed to it by value. 
* 
********************************************************/ 
89 void showValues(Inventoryltem 
90 { 
91 
cout << fixed 
<< showpoint 
92 
cout << "Part Number 
" 
93 
cout << "Descript
i on 
" 
94 
cout << "Units On Hand: " 
95 
cout << "Price 
$" 
96 } 
item) 
<< 
<< 
<< 
<< 
<< 
setprecision(2) 
<< endl;; 
item.getPartNum(
) << endl; 
i tem.getDescription() 
<< endl ; 
i tem.getOnHand() 
<< endl ; 
i tem.getPrice() 
<< endl; 
(program continues) 

438 
Chapter 7 
Introduction to Classes and Objects 
Program 7-9 
(continued) 
Program Output with Example Input Shown in Bold 
Enter data for the new part number 
Part number: 175 [Enter] 
Description: 
Hammer[Enter] 
Quantity on hand: 12[Enter] 
Unit price: 
7.49[Enter] 
Part Number 
175 
Description 
Hammer 
Units On Hand: 12 
Price 
$7.49 
Constant Reference Parameters 
In Program 7-9 part, the Inventory Item object, was passed by value to the showVal ues 
function . However, passing an object by value requires making a copy of all of the 
object's members. Thi s can slow down a program's execution time, particularly if it 
has many members . Passing an object by reference is faster because no copy has to be 
made since the function has access to the original object. For this reason it is generally 
preferable to pass objects by reference. 
Passing an object by reference does have a disadvantage, 
however. Because the 
function has access to the original object, it can call its mutator functions and alter its 
member data . Thi s is why we normally do not pass variables by reference when we 
want to safeguard their contents . Luckily, there is a solution . To protect an object 
when it is passed as an argument, without having to make a copy, it can be passed as 
a constant reference. This means that a reference to the original object is passed to the 
function, but it cannot call any mutator functions or change any of the object's 
member data. It can only call accessor functions that have themselves been designated 
as constant functions . 
To declare a parameter to be a constant reference parameter, we must put the key 
word const in the parameter list of both the function prototype and function header. 
Here is what the function prototype and header of the showVal ues function from 
Program 7-9 wo uld look like if we changed them to use a constant referen ce 
parameter. 
voi d showValues (const Inventoryltem& ) 
voi d showValues (const Inventoryltem 
&item) 
II Function prototype 
II Function header 
Now the showVal ues function can only call Inventory Item functions that also have 
the key word const listed in their function prototype and header, like this: 
double getPrice() 
const 

7.9 Passing Objects to Functions 
439 
If showVal ues tried to call any other Inventory Item functions, a compiler error would 
occur. Not ice that when showVal ues is modified to have a constant reference parameter, 
only the function prototypes and headers are changed to include the word const. The 
body of the showVa l ues function and the call to showVa l ues do not change. 
Returning an Object from a Function 
Just as functions can be written to return an i nt, double , or other data type, they can 
also be designed to return an object. In fact, you have done this before when you 
returned a string from a function, since a string is an object. When a function returns 
an object it normally creates a local instance of the class, sets its data members, and 
then returns it. Here is an example of how the Inventory Item object used in Program 
7-9 could be created in the storeVa l ues function and then returned to the calling 
function. Notice that this new version of the storeVa l ues function does not accept any 
arguments, and its return type is now Inventoryltem 
rather than void. 
Inventoryltem 
storeValues() 
{ 
Inventoryltem 
templtem; 
int partNum ; 
II Local Inventoryltem 
object 
II Local variables 
to hold user i nput 
str i ng descr i ption; 
int qty ; 
double price; 
II Code to get the data from the user goes here . 
II Store the data i n the Inventoryltem 
object 
and return 
i t. 
templtem .storelnfo(partNum, 
descr i ption, 
qty, 
pr i ce ); 
return 
templtem; 
) 
The main function could then create part like this: 
Inventoryltem 
part= 
storeValues(); 
Program 7-10 revises Program 7-9 to incorporate the techniques we have just discussed. 
The function previously named storeVal ues is renamed create Item, as it now creates 
an Inventory Item object and returns it to main. The showVal ues function now receives 
part as a constant reference instead of having it passed by value, as before. 
Program 7-10 
1 II This program uses a constant 
reference 
parameter. 
2 II It also shows how to return 
an object 
from a function. 
3 #include 
<iostream> 
4 #include 
<iomani p> 
5 #include 
<str i ng> 
6 us i ng namespace std; 
7 
(program continues) 

440 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-10 
(continued) 
8 class 
Inventoryitem 
9 { 
10 
private: 
11 
int partNum; 
12 
str i ng description; 
13 
int onHand; 
14 
double price; 
15 
16 
public: 
17 
II Part number 
II Item descr i ption 
II Units on hand 
II Unit price 
18 
void storeinfo(int 
p, str i ng d , int oH, double cost ); 
I I Prototype 
19 
20 
21 
22 
int getPartNum() 
const 
{ 
return 
part Num; } 
II The get f unctions 
have all 
been made 
II const functions
. This ensures 
they 
II cannot alter 
any cl ass member data . 
23 
str i ng getDesc ri pt i on () const 
24 
{ 
return 
desc ri pt i on ; } 
25 
26 
int getOnHand() const 
27 
{ 
return 
onHand; } 
28 
29 
doub l e getPrice() 
const 
30 
{ 
return 
pr i ce; } 
31 } ; 
32 
33 II 
Implementation 
code for Invento ryi tem class 
function 
storeinfo 
34 voi d Inventoryite
m: :storeinfo
(i nt p , string 
d, i nt oH, double cost) 
35 { partNum = p ; 
36 
description= 
d ; 
37 
onHand = oH; 
38 
price= 
cost ; 
39
} 
40 
41 II Function 
prototypes 
for client 
program 
42 Inventoryitem 
createitem(); 
II Returns 
an Inventoryitem 
object 
43 voi d showValues (const Invento ryi tem&); 
II Receives 
a reference 
to an 
44 
II 
Inventoryitem 
object 
45 
46 //*************** 
main 
47 i nt mai n() 
48 { 
***************** 
49 
Inventoryite
m par t = createitem
(); 
50 
showValues (part); 
51 
return 
O; 
52
} 
53 
(program continues) 

7.9 Passing Objects to Functions 
441 
Program 7-10 
(continued) 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
/************************************************************ 
* 
create Item 
* 
* This funct i on stores 
user input data in the members of a* 
* locally 
defined 
Inventoryltem 
object, 
then returns 
it. 
* 
************************************************************/ 
Inventoryltem 
createltem() 
{ 
Inventoryltem 
templtem; 
int partNum; 
str i ng description; 
int qty; 
double price; 
II Local Inventoryltem 
object 
II Local variables 
to hold user input 
67 
II Get the data from the user 
68 
cout << "Enter data for the new part 
number \n"; 
69 
70 
71 
72 
73 
cout << "Part 
number: "· 
ci n 
>> partNum; 
cout << "Descr i ption: 
"· 
cin.get()
; 
74 
getline(cin, 
descr i ption); 
II Move past the '\n' 
left 
in the 
II i nput buffer 
by the last 
input 
75 
cout << "Quant i ty on hand: "· 
76 
ci n 
>> qty; 
77 
cout << "Unit price: 
"; 
78 
cin 
>> pr i ce; 
79 
80 
II Store the data i n the Inventoryltem 
object 
and return 
i t 
81 
templtem .storelnfo(partNum, 
description, 
qty, 
price)
; 
82 
return 
templtem; 
83 } 
84 
85 /*************************************************************** 
86 
* 
showValues 
* 
87 
* This funct i on displays 
the member data in the Inventoryltem 
* 
88 
89 
90 
* object 
passed to it . Because i t was passed as a constant 
* reference
, showValues accesses 
the original 
object, 
not a 
* copy, but i t can only call 
member functions 
declared 
to be 
* 
* 
* 
91 
* const. 
This prevents 
it from calling 
any mutator 
functions
. * 
92 
***************************************************************/ 
93 voi d showValues(const 
Inventoryltem 
&item) 
94 { 
95 
96 
97 
98 
99 
100 } 
cout << 
cout << 
cout << 
cout << 
cout << 
fixed 
<< showpoint 
"Part 
Number 
• 
"Descr i ption 
• 
"Units On Hand: • 
"Pric e 
$" 
<< setprecision(2) 
<< endl ;; 
<< item .getPartNum () << endl ; 
<< item .getDescription
() << endl; 
<< item .getOnHand(} << endl ; 
<< i tern . getPr i ce () << endl ; 
Program Output is the Same as for Program 7-9. 

442 
Chapte r 7 
Introduction to Classes and Objects 
~ 
Checkpoint 
7.10 
7.15 
A private class member function can be called by 
A) any other function 
B) only public functions in the same class 
C) only private functions in the same class 
D) any function in the same class 
7.16 
When an object is passed to a function, a copy of it is made if the object is 
A) passed by value 
B) passed by reference 
C) passed by constant reference 
D) any of the above 
7.17 
If a function receives an object as an argument and needs to change the object's 
member data, the object should be 
A) passed by value 
B) passed by reference 
C) passed by constant reference 
D) none of the above 
7.18 
True or false: Objects can be passed to functions, but they cannot be returned 
by functions. 
7.19 
True or false: When an object is passed to a function, but the function is not 
supposed to change it, it is best to pass it by value. 
Object Composition 
CONCEPT: 
It is possible for a class to have a member variable that is an instance of 
another class. 
Sometimes it's helpful to nest an object of one class inside another class. For example, 
consider the following declarations: 
class 
Rectangle 
{ 
) ; 
private: 
doub l e length ; 
doub l e width ; 
public: 
void setLength
(doub l e ); 
void setWidth(double
); 
doub l e get Length (); 
doub l e getWid th(); 
doub l e calcArea(
); 
(program continues) 

class 
Carpet 
{ 
} ; 
private: 
doub l e pricePerSqYd; 
Rectangle 
siz e; 
public: 
voi d setPricePe
rYd(double 
void setDimensions
(double 
doub l e getTotalPrice(); 
7.10 Object Composition 
443 
II size 
is an instance 
of 
II the Rectang le class 
p ); 
1 , double w); 
Notice that the Carpet class has a member var iab le named size, which is an instance 
of the Rectangle class . Th e Carpet class can use this object to store the room dimensions 
and to compute the area for a carpet purchase . Figure 7-4 illustrates how the two 
classes are related . When one class is nested inside another like this, it is called object 
composition . 
Figure 7-4 
Carpet 
pricePerSq Yd 
size 
Rectangle 
length 
width 
Rectangle 
member functions 
Carpet member functions 
Program 7-11 uses these two classes to create an application that comp utes carpet prices. 
Program 7-11 
1 II This program nests 
one class 
ins i de another
. It has a cl ass 
2 II with a member var i able that 
is an i nstance 
of another 
cl ass . 
3 #include 
<iostream> 
4 using names pace std ; 
5 
6 class 
Rectangle 
7 { 
8 
pr i vate: 
9 
double 
length
; 
10 
double width; 
(program continues) 

444 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-11 
(continued) 
11 
public: 
12 
void setLength(double 
l en ) 
13 
{ length 
= len; 
} 
14 
15 
void setWidth(double 
wid ) 
16 
{ width= 
wid; } 
17 
18 
double getLength() 
19 
{ return 
length ; } 
20 
21 
double getWidth() 
22 
{ return 
width ; } 
23 
24 
double calcArea() 
25 
{ return 
length* 
width ; } 
26 }; 
27 
28 class 
Carpet 
29 { 
30 
31 
32 
33 
pr i vate: 
double pricePerSqYd ; 
Rectangle 
size ; 
34 
public: 
35 
void setPricePerYd(double 
p) 
36 
{ pricePerSqYd 
= p; } 
37 
II size 
is an i nstance 
of 
II the Rectangle 
class 
38 
39 
40 
void setDimens i ons(double 
{ size.setLength(lenl3); 
size.setWidth 
(widl3); 
len, 
double wid ) 
II Convert feet 
to yards 
41 
} 
42 
43 
double getTotalPrice() 
44 
{ return 
(size.calcArea
() * pricePerSqYd); 
} 
45 }; 
46 
47 II 
************** 
Cl ient 
Program ***************** 
48 int main() 
49 { 
50 
Carpet 
double 
purchase; 
pricePerYd; 
length ; 
width ; 
II This var ia ble is a Carpet object 
51 
52 
double 
53 
double 
54 
55 
56 
57 
58 
59 
60 
cout 
cin 
cout 
cin 
cout 
cin 
<< 
>> 
<< 
>> 
<< 
>> 
"Room lengt h i n feet: 
length; 
"Room width in feet 
width; 
"Carpet 
price 
per sq. 
pricePe rYd ; 
". 
' 
". 
' 
yard: 
". 
' 
(program continues) 

7.10 Object Composition 
445 
Program 7-11 
(continued) 
61 
62 
purchase.setDimensions
(length , wi dth); 
63 
purchase.setPricePerYd
(pricePe rYd ); 
64 
65 
cout << "\nThe total 
price 
of my new"<< 
l ength<<
" x " << wi dth 
66 
<<" 
carpet 
i s$"<< 
purchase.getTotalPrice() 
<< end l; 
67 
68 
ret urn O; 
69} 
Program Output with Example Input Shown in Bold 
Room 1 ength in feet: 
16 .S[Enter] 
Room width in feet 
: 12[Ent er] 
Carpet price 
per sq. yard: 
22 .49[Enter] 
The total 
price 
of my new 16.5 x 12 carpet 
is $494.78 
Let's take a closer look at Program 7-11. Notice that the client program, which defines 
purchase , a Carpet object, only uses it to call Carpet class functions, not Rectangle 
class functions. It does not even know that the Carpet class has a Rectangle object 
inside it. Not ice also, in lines 39, 40, and 44, how Carpet class functions call Rectangle 
functions. Just as the user program calls Carpet functions through the name of its 
Carpet object, the Carpet class functions must call Rectangle functions through the 
name of its Rectangle object. The Rectangle object, defined in line 32, is named size. 
That is why the Carpet functions make calls like this: 
size.calcArea() 
~ 
Checkpoint 
7.20 
Assume a Map class has a member variable named position 
that is an instance 
of the Location class. The Location class has a private member variable named 
latit
ude and a public member function called getlatitude. 
Which of the 
following lines of code would correctly get and return the value stored in 
latitude
? 
A) return 
Locat i on.latitude; 
B) return 
Locat i on.getlatitude(); 
C) return 
posit i on.latitude; 
D) return 
posit i on.getlatitude(); 
7.21 
Write a class declaration for a class named Ci rel e, which has the data member 
radius , a double , and member functions setRad i us and calcArea. Write the 
code for these as inline functions. 

446 
Chapte r 7 
7.11 
Introduction to Classes and Objects 
7.22 
Write a class declaration for a class named Pizz a that has the data members 
pri ce, a doubl e, and si ze, a Circle object (declared in question 7.21). It also 
has member functions: setPri ce, setS i ze, and cos t PerSql n. Write the code 
for these as inline functions. 
7.23 
Write four lines of code that might appear in a client program using the Pizz a 
class to do the following: 
Define an instance of the Pi zza class named myPi zza. 
Call a Piz za function to set the price. 
Call a Pi zza function to set the size (i.e., the radius). 
Call a Piz za function to return the price per square inch and then print it. 
Focus on Software Engineering: Separating Class 
Specification, Implementation, and Client Code 
CONCEPT
: Usually class declarations are stored in their own header files and member 
function definitions are stored in their own . cpp files. 
In the programs we've looked at so far, the class declaration, the member function 
definitions, and the applicat ion program that uses the class are all stored in one file. A 
more conventional way of designing C++ programs is to store these in three separate 
files. Typically, program components are stored in the following fashion: 
• Class declarations are stored in their own header files. A header file that contains a 
class declaration is called a class specification file. The name of the class specification 
file is usually the same as the name of the class, with a . h extension. For example, 
the Rect angle class would be declared in the file Rect angle . h. 
• Any program that uses the class should #i nclude this header file. 
• The member function definitions for a class are stored in a separate . cpp file, 
which is called the class implementation file. The file usually has the same name 
as the class, with the . cpp extension . For example the Rectangle class member 
functions would be defined in the file Rectangle . cpp. 
• The class . cpp file should be compiled and linked with the application program 
that uses the class. This program , also known as the client program, or client 
code, is the one that includes the mai n function . This process can be automated 
with a project 
or make utility. Integrated development environments such as 
Visual Studio also provide the means to create multi-file projects. 
Let's see how we could rewrite Program 7-3, the rectangle program , using this design 
approach. First, the Rect angle class declaration wou ld be stored in the following 
Rectangle. h file. 

7.11 Focus on Software Engineering: Separating Class Specification, Implementation, and Client Code 
447 
Contents of Rectangle. 
h 
1 II Rectang l e.his 
t he Rectangle class 
specificatio
n file. 
2 #ifndef 
RECTANGLE
_H 
3 #define RECTANGLE
_H 
4 
5 II Rectang l e class declaration 
6 class Rectangle 
7 { 
8 
private: 
9 
doubl e length ; 
10 
doubl e widt h; 
11 
publ ic : 
12 
bool setleng t h(double); 
13 
bool setWid th(double); 
14 
double getleng t h(); 
15 
double getWidth(); 
16 
double calcArea(); 
17 ) ; 
18 #endif 
This is the specification file for the Rectangle class. It contains only the declaration of 
the Rectang le class. It does not contain any member function definitions. When we 
write other programs that use the Rectangle class, we can have an #include directive 
that includes this file. That way, we won't have to write the class declaration in every 
program that uses the Rectangle class. 
This file also introduces two new preprocessor directives: #i fndef and #end if . Th e 
#i fndef directive that appears in line 2 is called an include guard. It prevents the 
header file from accidentally being included more than once. When your main program 
file has an #i nclude directive for a header file, there is always the possibility that the 
header file will have an #in clude direct ive for a second header file. If your main 
program file also has an #include directive for the second header file, the preprocessor 
will include the second header file twice. Unless an include guard has been written into 
the second header file, an error will occur because the comp iler will process the 
declarations in the second header file twice. Let's see how an include guard works. 
Th e word i fndef stands for "if not defined." It is used to determine whether or not a 
specific constant has already been defined with another #define directive. When the 
Rectang l e . h file is being comp iled, the #i fndef directive checks for the existence of a 
constant named RECTANGLE
_H. If this constant has not been defined yet, it is immediately 
defined in line 3, and the rest of the file is included . However, if the constant has 
already been defined, it means that this file has already been included . In that case, it is 
not included a second time. Instead, everything between the #i fndef and #endi f 
directives is skipped. Note that the constant used in the #i nfdef and #def i ne directives 
should be written in all capital letters and is customari ly named FI LENAME_H, where 
FI LENAME 
is the name of the header file. 
Next we need an implementation 
file that contains the class member function 
definitions . The implementation file for the Rectangle class is Rectangle. cpp. 

448 
Chapte r 7 
Introduction to Classes and Objects 
Contents of Rectangle. 
cpp 
1 II Rectangle.cpp 
is the Rectangle 
class 
function 
implementation 
file. 
2 #include 
"Rectangle.h" 
3 
4 /******************************************************************* 
5 
* 
Rectangle: 
:setLength 
* 
6 
7 
8 
9 
* If the argument passed to the setLength 
function 
is zero or 
* 
* greater, 
it is copied into the member variable 
length, 
and true* 
* is returned. 
If the argument is negative
, the value of length 
* 
* remains unchanged and false 
is returned. 
* 
10 
*******************************************************************/ 
11 bool Rectangle: 
:setLength(double 
len) 
12 { 
13 
bool validData 
= true ; 
14 
15 
16 
17 
18 
19 
if (len >= 0) 
length= 
len; 
else 
validData 
= false; 
20 
return 
validData; 
21 } 
22 
II If the len is valid 
II copy it to length 
II else 
leave length 
unchanged 
23 /****************************************************************** 
24 
* 
Rectangle: 
:setWidth 
* 
25 
* If the argument passed to the setWidth 
function 
is zero or 
* 
26 
* greater, 
it is copied into the member variable 
width, 
and true* 
27 
* is returned. 
If the argument is negative
, the value of width 
* 
28 
* remains unchanged and false 
is returned. 
* 
29 
******************************************************************/ 
30 bool Rectangle: 
:setWidth(double 
w} 
31 { 
32 
bool validData 
= true ; 
33 
34 
35 
36 
37 
38 
if 
(w >= 0) 
width= 
w; 
else 
validData 
= false; 
39 
return 
validData; 
40
} 
41 
II If w is valid 
II copy it to width 
II else 
leave width unchanged 
42 /************************************************************** 
43 
* 
Rectangle: 
:getLength 
* 
44 
* This function 
returns 
the value in member variable 
length. 
* 
45 
**************************************************************/ 
46 double Rectangle: 
:getLength() 
47 { 
48 
return 
length; 
49
} 
50 

7.11 Focus on Software Engineering: Separating Class Specification, Implementation, and Client Code 
449 
51 /************************************************************** 
52 
* 
Rectang l e : :getWidth 
* 
53 
* This function 
returns 
the value i n member variable 
width . 
* 
54 
**************************************************************/ 
55 doubl e Rectangle: :getWidth( ) 
56 { 
57 
return wid th; 
58
) 
59 
60 /******************************************************************* 
61 
* 
Rectangle : :calcArea 
* 
62 
* This function 
calculates 
and returns 
the area of the rectangle. 
* 
63 
*******************************************************************/ 
64 doubl e Rectangle: :calcArea( ) 
65 { 
66 
return 
l ength* 
width; 
67
) 
Look at the code for the five functions. Not ice that the three accessor functions, 
getlength, 
getWidth , and calcArea , are the same as those that appeared in Program 
7-3. However, a change has been made to the two mutator functions , setlength 
and 
setWi dth , to illustrate another way that public class functions can safegua rd private 
member data . In Program 7-3, the set Length and setWi dth functions use a default 
value for length and width if invalid data is passed to them . In the Rectang l e . cpp 
code, these two functions return a Boolean value indicating whether or not the value 
received was stored in the member variable. If a valid argument is received, it is stored 
in the member variable and true is returned. If an invalid argument is received, the 
member variable is left unchanged and false is returned. The client program that uses 
this class must test the returned Boolean value to determine how to proceed. 
Now look at line 2, which has the following #i nclude directive: 
#include 
"Rectangle.h" 
Thi s directive includes the Rectangle. 
h file, which contains the Rectangle 
class 
declaration. Notice that the name of the header file is enclosed in double-quote characte rs 
(" ") instead of angled brackets (<>). When you include a C++ system header file, such as 
i ostream , you enclose the name of the file in angled brackets. This indicates that the file 
is located in the compiler's include file directory. That is the directory or folder where all 
of the standard C++ header files are located . When you include a header file that you have 
written, such as a class specification file, you enclose the name of the file in double quote 
marks. This indicates that the file is located in the current project directory. 
Any file that uses the Rectangl eclass must have an #i nclude directive for the Rectang l e. h 
file. We need to include Rectang l e. h in the class specification file because the functions 
in this file belong to the Rectangle class. Before the compiler can process a function with 
Rectangle:: in its name, it must have already processed the Rectangle class declaration . 
Program 7-12 is a modified version of Program 7-3. Notice that it is much shorte r than 
Program 7-3 because it does not conta in the Rectangle class declaration or member 
function definit ions. Instead, it is designed to be compiled and linked with the class 
specification and implementation files. Program 7-12 only needs to conta in the client 
code that creates and uses a Rectangle object. 

450 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-12 
1 // This program uses the Rectang le class
. 
2 II The Rectangle 
class 
declaration 
i s in fi l e Rectangle.h. 
3 II The Rectangle 
member function 
definitions 
are in Rectangle.cpp 
4 II These files 
should all 
be combined into a project. 
5 #include 
<iostream> 
6 #include 
"Rectangle.h" 
// Conta i ns Rectangle 
class 
declarat
ion 
7 using namespace std ; 
8 
9 int main() 
10 { 
11 
Rectangle 
box ; 
II Declare 
a Rectang le object 
12 
double boxlength, 
boxWidth; 
13 
14 
//G et box length 
and width 
15 
cout << "This program wil l calculate 
the area of a rectangle.\n"; 
16 
cout << "What is the length?
"; 
17 
cin 
>> boxlength ; 
18 
cout << "What is the width?"; 
19 
cin 
>> boxWidth ; 
20 
21 
// Call member f unctions 
to set box di mensions
. 
22 
II If the f unction 
call 
ret urns false
, it means the 
23 
II argument sent to it was inval i d and not stored
. 
24 
if (!bo x .setlength
(boxlength )) 
// Store the length 
25 
cout << "Inva l i d box length 
entered
.\n"; 
26 
els e if (! box.setWidth
(boxWidth )) 
// Store the width 
27 
cout << "Inva l i d box width entered
. \n"; 
els e 
28 
// Both values were valid 
29 
30 
31 
32 
33 
34 
35 
36 
37 } 
{ 
II Call 
cout << 
cout << 
cout << 
cout << 
} 
member functions 
to get box informat i on to display 
"\nHere is the rectang le 's data :\n"; 
"Length : " << box .getlength() 
<< endl ; 
"Width 
" << box .getWidth() 
<< endl ; 
"Area 
" << box .calcArea() 
<< endl ; 
return 
O; 
Notice that line 6 of Program 7-12 has an #i nclude directive for the Rectangle . h file. 
T his is needed so the Rectangle class declaration will be included in the file. 
Now that we have created the three files for this program, the following steps must be 
taken to create an executable program. 
• First, the implementation 
file, Rectangle. cpp, shou ld be compi led to create an 
ob ject file. Th is file would typically be named Rectangle. obj. 
• Next, the main program file, located in file pr7-12. cpp, must be compiled to 
create an object file. Thi s file would typically be named pr7-12 . obj. 
• Finally, the object files pr7-12 . obj and Rectangle. obj are linked together to 
create an exec utable file, which wou ld be named something like pr7-12 . exe. 

7.11 Focus on Software Engineering: Separating Class Specification, Implementation, and Client Code 
451 
Table 7-1 summarizes how the different files of Program 7-12 are organized and 
compiled on a typical Windows computer. All of the . h and . cpp files listed can be 
found in the Chapter 7 programs folder on the book 's companion website . 
Table 7-1 Files Used in Prog ram 7-12 
Recta ngl e . h 
Contains the Rectang l e class declarat ion . This file is included by 
Rect angle .c pp and pr7-12 .c pp. 
Recta ngl e . cpp 
Contains the definit ions of the Rectangle class member functions . 
This file is compiled to create an object file, such as Rectangl e . obj. 
pr7- 12. cpp 
Contains the application program that uses the class. In this case, 
the app lication program consists of just the function main. This file 
is comp iled to create an object file, such as pr 7- 12. obj . 
Li nki ng t he . obj f il es 
The two object code files created by compiling Rectangle
. cpp and 
pr 7-1 2. cpp are linked to make the executable file pr 7-1 2. exe . 
Figure 7-5 
Headers 
Figure 7-5 further illustrates this process . 
Source 
files 
Object 
files 
Executable 
file 
Rectangle.h 
Rectangle.cpp 
Rectangle.obj 
-
Specification 
. 
Implementation 
Compile 
file 
0 
file 
I-+ 
pr7-12.exe 
Include 
pr7-12.cpp 
pr7-12 .obj 
Link 
. 
Compile 
. 
Main program 
-
file 
The exact details on how these steps take place are different for each C++ development 
system . Fortunately, most systems perform all of these steps automat ically for you . For 
example, in Microsoft Visual C++ you create a project, and then you simply add all of 
the files to the project. When you compile the project, the steps are done for you and 
an executab le file is generated . Once the executable file has been created, you can run 
the program . When valid values are entered for box Lengt h and boxWi dt h, the output 
shou ld be identical to that shown for Program 7-3. 
NOTE: 
Additional information on creat ing multifile projects can be found in 
Appendix G on this book's compan ion website at pearsonhighered .com/gaddis . 
Advantages of Using Multiple Files 
Separating a client program from the details of a class it uses is considered good 
programming pract ice. A class is an example of an abstract data type and, as you learned 
earlier in this chapter, the only thing a programmer writing an application that uses the 

452 
Chapte r 7 
<) 
Introduction to Classes and Objects 
class needs to know is what the class does, what kind of data it can hold, what functions 
it provides, and how to call them. Programmers, and any programs using the class, do 
not need to know anything about the implementat ion of the class. In addition, often 
many different programs use a particular class. If the implementat ion code that defines 
the class member functions is in its own separate file, this code does not have to be in all 
of these programs . They can each simply #i nclude the file containing the defintions. 
Separating a class into a specification file and an implementation file is also considered 
good programming practice. If you wish to give your class to other programmers, you 
don't have to share all of your source code. You can just provide a copy of the specification 
file and the compiled object file for the class's implementation. The other programmers 
simply insert the necessary #include 
directive into their programs, compile them, and 
link them with your class object file. This prevents other programmers, who might not 
understand all the details of your code, from making changes that introduce bugs. 
Separating a class into specification and implementation files also makes things easier 
when class member functions must be modified . It is only necessary to modify the 
implementation file and recompile it to create a new object file. Programs that use the 
class don't have to be recompiled . They just have to be linked with the new object file. 
Performing Input / Output in a Class Object 
You may have noticed in Program 7-12 that we avoided doing any 1/0 inside the 
Rectangle class. In general it is considered good design to have class member functions 
avoid using ci n and cout . This is so anyone writing a program that uses the class will 
not be locked into the part icular way the class performs input or output . Unless a class 
is specifically designed to perform 1/0, it is best to leave operations such as user input 
and output to the person designing the application. As a general rule, classes should 
provide member functions for retrieving data values without displaying them on the 
screen . Likewise, they should provide member functions that store data into private 
member variables without using ci n. Program 7-12 follows both of these practices. 
NOTE: In some instances, it is appropr iate for a class to perform 1/0 . For example, 
a class might be designed to display a menu on the screen and get the user's selection . 
Another example is a class designed to handle a program's file 1/0. Classes that 
hold and manipulate data, however, should not be tied to any particular 1/0 
routines . This allows them to be more versatile. 
Checkpoint 
7.24 
Assume the following class components exist in a program: 
BasePay class declaration 
BasePay member function definitions 
Over tim e class declaration 
Over tim e member function definitions 
What files would you store each of the above components in? 
7.25 
What header files should be included in the client program that uses the BasePay 
and Overtim e classes? 

7.12 Structures 
453 
Structures 
CONCEPT: 
C++ allows a set of variables to be combined together into a single unit 
called a structure. 
A structure is a programmer -defined data type that can hold many different data 
values. In the past, before the use of object-oriented programming became common, 
programmers typically used these to group logically connected data together into a 
single unit. Once a structure type is declared and its data members are identified, 
multiple variables of this type can be created, just as multiple objects can be created 
for the same class. 
Although structures are less commonly used today, it is important that you know what 
they are and how to use them. Not only may you encounter them in older programs, 
but there are actually some instances in which classes will not work and structures 
must be used. You will see an example of this later in this chapter. 
The way a structure is declared is similar to the way a class is declared, with the 
following differences: 
• The key word struct is used instead of the key word class. 
• Although structures can include member functions, they rarely do. So normally a 
structure declaration only declares member variables. 
• Structure declarations normally do not include the access specifiers pub 1 i c or 
priva t e. 
• Unlike class members, which are private by default, members of a structure 
default to being public. Programmers normally want them to remain public and 
simply use the default . 
Here is an example of a declarat ion for a structure that bundles together five variables 
holding payroll data for an employee. The name of this particular structure is Pay Ro 11. 
Notice that it begins with a capita l letter. The convention is to begin structure names, 
just like class names, with an uppercase letter. Notice also that, like a class declaration, 
there must be a semicolon after the closing brace of the declaration. 
struc t PayRoll 
{ 
} ; 
i nt 
str i ng 
double 
empNumber; 
name; 
hours, 
payRate, 
grossPay; 
Just as a class declaration is not instantiated until objects of the class are created, a 
structure declaration does not create any instances of the structure . The structure 
declaration in our example simply tells the compiler what a Payrol 1 structure looks 
like. It in essence creates a new data type named Payrol 1. 

454 
Chapte r 7 
Introduction to Classes and Objects 
You define variables that are Payro 11 structures the way you define any variable, by 
first listing the data type and then the variable name. The following definition creates 
three variables that are Payro 11 structures . 
Payroll 
deptHead , foreman , associate
; 
Each is an instance of a Payroll structure, with its own memory allocated to hold its 
member data. Notice that although the three structure variab les have distinct names, 
each contains members with the same name . Figure 7-6 illustrates this. 
Figure 7-6 
deptHead 
foreman 
associ ate 
empNumber I 
empNumber I 
empNumber I 
name 
I 
I 
name 
I 
I 
name 
I 
I 
hours 
I 
hours 
I 
hours 
I 
payRate I 
payRate I 
payRate I 
grossPay I 
grossPay I 
grossPay I 
Accessing Structure Members 
a 
Members of a structure are accessed just like public members of a class, with the dot 
operator. Howeve r, the data members of a class are normally private and must be 
accessed through functions . Because struct ure data members are public, they are 
accessed directly and can be used like regular variables . The following statements 
assign values to the empNumber member of each of the Payro ll variables we created . 
VideoNot e 
Creating and 
Using 
Structures 
deptHead.empNumber = 475; 
foreman.empNumber = 897 ; 
associate.empNumber 
= 729 ; 
And the following statements display the contents of all the dept Head's members. 
-
cout << deptHead .empNumber << endl; 
cout << deptHead .name << endl ; 
cout << deptHead .hours << endl; 
cout << deptHead .payRate << endl; 
cout << deptHead .gro ssPay << endl ; 
Program 7-13 is a complete program that uses the PayRol l structure . Not ice how the 
individual structure members are used just like regular variables in ci n statements, in 
cout statements, and in mathematical operations . 
Program 7-13 
1 // This program demonstrates 
the use of a structure
. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 #include 
<str i ng> 
5 using namespace std ; 
6 
(program continues) 

Program 7-13 
(continued) 
7 
8 
9 
struct 
PayRoll 
{ 
int 
empNumber; 
string 
name; 
double hours, 
payRate; 
} ; 
int main() 
{ 
PayRol l employee; 
II Employee number 
II Employee name 
II Hours worked 
II Hourly pay rate 
II Employee is a PayRoll structure 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
double grossPay; 
II Gross amount the employee earned 
20 
//Get 
the employee's 
data 
21 
cout << "Enter the employee's 
number: "· 
22 
cin 
>> employee.empNumber; 
23 
24 
cout << "Enter the employee's 
name: "· 
7.12 Structures 
455 
this 
week 
25 
cin. i gnore(); 
// Skip the '\n' 
character 
left 
i n the i nput buffer 
26 
getl i ne(cin, 
employee.name); 
27 
28 
29 
30 
31 
32 
33 
cout 
cin 
cout 
cin 
<< 
>> 
<< 
>> 
"Hours worked this 
employee.hours; 
"Employee·s 
hourly 
employee.payRate; 
week: 
, .. 
pay rate: 
34 
II Calculate 
the employee's 
gross pay 
... 
35 
grossPay 
=employee.hours* 
employee.payRate; 
36 
37 
II Di splay the results 
38 
cout << "\nHere is the employee's 
payroll 
data:\n"; 
39 
40 
41 
42 
43 
44 
45 
46 } 
cout << "Name: 
.. << employee .name<< endl; 
cout << "Employee number: .. << employee .empNumber << endl; 
cout << "Hours worked: 
.. << employee .hours << endl; 
cout << "Hourly pay rate: .. << employee .payRate << endl; 
cout << fixed << showpoi nt 
<< setprec
i sion(2); 
cout << "Gross pay: 
$"' << grossPay 
<< endl; 
return o· ' 
Program Output with Example Input Shown in Bold 
Enter the emp 1 oyee' s number: 2214[Enter] 
Enter the emp 1 oyee' s name: Jack Smlth[Enter] 
Hours worked this 
week: 40[Enter] 
Employee's 
hourly pay rate: 
12 .SO[Enter] 
Here is the employee's 
payroll 
data: 
Name: 
Jack Smith 
Employee number: 2214 
Hours worked: 
40 
Hourly pay rate: 
12.5 
Gross pay: 
$500.00 

456 
Chapte r 7 
Introduction to Classes and Objects 
In Program 7-13 the variab le employee is defined in line 17 to be an instance of a 
Payro l l struct ure. Its five data members can then be accessed with the dot operator 
through the name of the variable. For example, in line 22 the following statement reads 
a value into the variable's empNumber member. 
cin 
>> employee.empNumber; 
// Correct 
It would be wrong to try to access this member through the name of the structure type. 
cin 
>> Payroll.empNumber; 
// Wrong! 
Displaying and Comparing Structure Variables 
In Program 7-13 each member of the employee structure variable was displayed 
separately . This is necessary because the entire contents of a structure variable cannot 
be displayed by simply passing the whole variable to cout. For example, the following 
statement will not work. 
cout <<employee<< 
endl ; 
// Error! 
Likewise, although it is possible to compare the contents of two individual structure 
members, you cannot perform compa rison operations on entire structures. For 
examp le, if employee 1 and employee2 are both Payroll 
structure variab les, this 
comparison will cause an error. 
if 
(employee1 == 
employee2 ) 
// Error! 
The following comparison, however, is perfectly legal. 
if 
(employee1 .hours== 
employee2.hours) 
// Legal 
Initializing a Structure 
There are two ways a structure variable can be initialized when it is defined: with an 
initialization list or with a constr uctor. 
The simplest way to initia lize the members of a structure variable is to use an 
initialization list. An initializatio n list is a list of values used to initialize a set of memory 
locations . The items in the list are separated by commas and surrounded by braces . 
Suppose, for example, the following Date struct ure has been declared: 
struct 
Date 
{ 
int day , 
month , 
year; 
) ; 
A Date variable can now be defined and initialized by following the variable name with 
the assignment operator and an initialization list, as shown here: 
Date bir thday= 
{23, 8 , 1983} ; 
This statement defines birthday 
to be a variable which is a Date structure. The values 
inside the curly braces are assigned to its members in order. So the data members of 
bir thday have been initialized as shown in Figure 7-7. 

Figure 7-7 
7.12 Structures 
457 
birthday. day 
23 
birthday. month 
8 
birthday. year 
1983 
It is also possible to initialize just some of the members of a structure variable. For 
example, if we know the birthday to be stored is August 23 but do not know the year, 
the variable could be defined and initialized like this: 
Date bi rthday= 
{23, 8}; 
Only the day and month members are initial ized here. The year member is not 
initialized. If you leave a structure member uninitialized, however, you must leave all 
the members that follow it uninitialized as well. C++ does not provide a way to skip 
members when using an initializat ion list. The following statement attempts to skip the 
initialization of the mont h member. It is not legal. 
Date bi rthday= 
{23, , 1983}; 
II Illegal! 
It is important to note that you cannot initialize a structure member in the declaration 
of the structure because the structure declarat ion just creates a new data type. No 
variables of this type exist yet. For examp le, the following declarat ion is illegal: 
// Illegal 
structure 
declara t ion 
struc t Date 
{ i nt day 
= 23, 
month= 
8, 
year 
= 1983; 
} ; 
Because a structure declaration only declares what a structure "looks like," the member 
variables are not created in memory until the structure is instantiated by defining a 
variable of that structure type. Until then, there is no place to store an initial value. 
Although an initialization list is easy to use, it has two drawbacks: 
1. It does not allow you to leave some members unin itialized and still initialize 
others that follow. 
2. It will not work on many compilers if the structure includes any objects, such as 
strings. 
In these cases you can initialize structure member variables the same way you initialize 
class member variables - by using a constructor. 
As with a class constructor, 
a 
constructor for a structure must be a public member function with the same name as 
the structure and no return type. Because all structure members are public by default, 
however, the key word pub 1 i c does not need to be used. Here is a structure declaration 
for a structure named Emp 1 oyee. It includes a two-argument constructor that provides 
default values in case an Employee variable is created without passing any arguments 
to the constructor. 

458 
Chapte r 7 
Figure 7-8 
Introduction to Classes and Objects 
struct 
Empl oyee 
{ 
str i ng name; 
II Employee name 
int vacationDays, 
daysUsed; 
II Vacation 
days allowed 
per year 
II Vacation 
days used so far 
Employee(string 
n = "" 
{ 
} 
} ; 
name = n; 
vacationDays 
= 
daysUsed = d ; 
Nested Structures 
10 ; 
int d = 0) 
II Constructor 
Just as objects of one class can be nested within anothe r class, instances of one 
str ucture can be nested within another str ucture . For example, consider the following 
declarations: 
struct 
Costs 
{ 
} ; 
double wholesale; 
double 
retail; 
struct 
Item 
{ 
} ; 
str i ng partNum; 
str i ng descr i ption; 
Costs pricing; 
Th e Costs stru cture has two double 
members, wholesa l e and retail. 
Th e Item 
str ucture has three members . Th e first two, partNum and descr i pt i on, are str i ng 
objects . Th e third, pricing
, is a nested Costs str ucture. If wi dget is defined to be an 
Item structure, Figure 7-8 illustrates its membe rs. 
widget 
partNum 
description 
pricing 
whol esa l e 
retai
l 
Th ey wo uld be accessed as follows: 
widget.partnum 
= "123A"; 
widget.descript
i on= 
"iron widget"; 
widget.pricing.wholesale= 
100.0; 
widget.pricing.retail 
= 150.0; 

7.12 Structures 
459 
Notice that wholesale 
and retai 1 are not members of wi dget; pricing 
is. To access 
whol esale 
and retail, 
widget's 
pr i cing member must first be accessed and then, 
because it is a Costs structure, its wholesale 
and retail 
members can be accessed. 
Notice also, as with all str uctures, it is the member name, not the structure name, that 
must be used in accessing a member. Th e following statements wo uld not be legal. 
cout << widget.reta
il ; 
cout << widget.Costs
.wholesale; 
II Wrong! 
II Wrong! 
When you are dec iding whether or not to use nested structures, 
think about how 
vario us members are related . A str ucture bundl es together items that logically belong 
together. Normally the members of a str ucture are attr ibut es describing some object. In 
our example, the object was a widget, and its part number, description, and who lesale 
and retail prices were its attributes. When some of the attrib utes are related and form a 
logical subgroup of the object's attr ibutes, it makes sense to bundle them together and 
use a nested structure . Notice the relatedness of the attributes in the inner str ucture of 
Program 7-14, which uses a nested str ucture . 
Program 7-14 
1 II This program demonstrates 
the use of a nested 
structure. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 #include 
<str i ng> 
5 using namespace std ; 
6 
7 
8 
9 
10 
11 
12 
13 
14 
struct 
Costlnfo 
{ 
double food, 
medical , 
license
, 
misc ; 
} ; 
15 struct 
Petlnfo 
16 { 
17 
18 
19 
20 
21 
22 
23 
string 
name; 
string 
type ; 
int 
age ; 
Costlnfo 
cost ; 
II Food costs 
II Medical costs 
II 
Lic ense fee 
II Misce l laneo us 
II Pet name 
II Pet type 
II Pet age 
costs 
II A Petlnfo 
structure 
has a Costlnfo 
structure 
II nested 
ins i de as one of its 
members 
24 
Petlnfo
() 
II Default 
constructo
r 
25 
{ 
name = "unknown"; 
26 
type = "unknown"; 
27 
age= 
O; 
28 
cost .fo od= 
cost.med ic al =cost.
license
= cost.m is c= 
0.00; 
29 
} 
30 }; 
(program continues) 

460 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-14 
(continued) 
31 
32 int main() 
33 { 
34 
II Defi ne a Petlnfo 
structure 
variable 
called 
pet 
35 
Petlnfo 
pet; 
36 
37 
II Ass i gn values 
to the pet member var i ables. 
38 
II Noti ce that 
cost.m i sc is not assigned 
a value, 
39 
II so i t remains 0, as set by the constructor. 
40 
pet.name= 
"Sassy"; 
41 
pet.type= 
"cat"; 
42 
pet.age= 
5; 
43 
pet.cost.food= 
300.00; 
44 
pet.cost.medical 
= 200 .00; 
45 
pet.cost.l
i cense= 
7 .00; 
46 
47 
II Di splay the total 
annual costs 
for the pet 
48 
cout <<fixed<< 
showpoi nt << setprecision(2); 
49 
cout << "Annual costs 
for my"<< 
pet .age<< 
"-year-old" 
50 
<<pet
.type<<" 
"<< 
pet.name 
<<"are$" 
51 
<<(pet.cost.food+ 
pet .cost.medical+ 
52 
pet.cost.l
i cense
+ pet.cost.m
i sc)<< 
endl; 
53 
return 
O; 
54 ) 
Sample Output 
Annual costs 
for my 5-year-old 
cat Sassy are $507.00 
~ 
Checkpoint 
7.26 
Write a structure declaration for a structure named Student 
that holds the 
following data about a student: 
ID (int) 
entry year (int) 
GPA (double) 
Then write definition statements that create the following two Student variables 
and initialize them using initialization lists. 
Variable s1 should have ID number 1234, entry year 2008, and GPA 3.41. 
Variable s2 should have ID number 5678 and entry year 2010. The GPA 
member should be left uninitialized . 
7.27 
Write a structure declaration for a structure named Account that holds the 
following data about a savings account. Include a constructor that allows data 
values to be passed in for all four members. 
Account number (string) 
Account balance (double) 
Interest rate (double) 
Average monthly balance (double) 

7.12 Structures 
461 
Now wr ite a definition statement for an Account var iab le that initializes the 
members with the following data : 
Account number: ACZ42137 
Account balance: $4512.59 
Inter est rate: 4% 
Average monthly balance: $4217 .07 
7.28 
Th e following pr ogram skeleton, when complete, asks the user to enter the 
7.29 
7.30 
7.31 
following information abo ut his or her favo rite movie: 
Name of the movie 
Name of the movie's director 
The year the movie was released 
Comp lete the program by declaring the structure that holds this information, 
defining a str ucture var iab le, and writing the required individual statements . 
#include 
<iostream> 
#include 
<string> 
us i ng namespace std; 
II Write the structure 
declaration 
to hold the movie information. 
int mai n() 
{ 
} 
II Define the structure 
variable 
here . 
cout << "Ent er the fo 11 owing i nformation 
about your " 
<<" 
favorite 
movie .\n' ' << "Name: "; 
II Wri te a statement 
here that 
lets 
the user enter 
a movie name. 
II Store 
it in the appropriate 
structure 
member. 
cout << "Dir ector: 
"· 
II Wri te a statement 
here that 
lets 
the user enter 
the director
' s 
II name. Store 
it i n the appropriate 
structure 
member. 
cout << "Year of Release : "· 
II Wri te a statement 
here that 
lets 
the user enter 
the movie 
II release 
year. 
Store 
it in the appropr i ate structure 
member. 
cout << "\nH ere is information 
on your favor i te movie:\n"; 
II Wri te statements 
here that 
di splay 
the i nformation 
II just 
entered 
into 
the str uctu re variable. 
return 
O; 
Write a declaration for a str ucture named Locat i on, with the following three 
double member variab les: lat i tude , longitu
de, and height . 
Write a declaration 
for a st ru cture named City , which has the members 
ci tyName, a string, 
and posit ion , a Location str ucture (declared above) . Th en 
define a var iable named destination 
that is an instance of the City str ucture . 
Write assignment statements that sto re the following information in destination. 
city name 
Tup elo 
latit ude 
34.28 
long itud e 
-88 . 77 
height 
361.0 
II 34.28 degrees north 
II 88. 77 degrees west 
II feet above sea level 

462 
Chapte r 7 
Introduction to Classes and Objects 
Passing Structures to Functions 
Structure variables, just like class objects, can be passed to functions by value, by 
reference, and by constant reference. By default, they are passed by value. This means 
that a copy of the entire original structure is made and passed to the function. Because it 
is not desirable to take the time to copy an entire structure, unless it is quite small, 
structures are normally passed to functions by reference. This, however, gives the function 
access to the member variables of the original structure, allowing it to change them. If 
you do not want a function to change any member variable values, the structure variable 
should be passed to it as a constant reference. 
Program 7-15 is a modification of Program 7-9 that defines a structure variable and 
passes it to two functions. 
Program 7-15 
1 II Thi s program passes 
a structure 
variable 
to one function 
2 II by reference 
and to another 
as a constant 
reference. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 #include 
<str i ng> 
6 using namespace std ; 
7 
8 
9 
10 
11 
12 
13 
14 
15 
struct 
Invltem 
{ 
int partNum ; 
string 
descript
i on; 
int onHand; 
double price; 
} ; 
16 II Function 
prototypes 
II 
Holds data for an i nventory 
II Part number 
II 
Item description 
II Units on hand 
II Unit pr i ce 
item 
17 void getltemData(Invltem 
&); II Funct i on getltemData 
wi ll receive 
an 
18 
II Invltem structure 
passed to it by 
19 
II reference 
so new values 
can be stored 
20 
II in i ts member variables
. 
21 
22 void showltem(const 
Invltem 
&); 
23 
II Function 
showltem will 
receive 
an 
24 
II Invltem structure 
passed to it as a 
25 
II constant 
reference 
because showltem 
26 
II just 
needs disp lay member var i able 
27 
II values, 
not change them . 
28 int main() 
29 { 
30 
Invltem part ; 
II Defi ne an Invltem structure 
var i able . 
31 
32 
getltemData(part); 
33 
showltem(part
); 
34 
return 
O; 
35
} 
36 
(program continues) 

7.12 Structures 
463 
Program 7-15 
(continued) 
37 /******************************************************************** 
38 
* 
getitemData 
* 
39 
* Thi s funct i on stores 
data input by the user in the members of an* 
40 
* Invltem structure 
var i able passed to the function 
by reference. 
* 
41 
* ******************************************************************/ 
42 void getitemData(Invitem 
&i tem) 
43 { 
44 
45 
46 
47 
48 
49 
50 
51 
52 
number: "· 
descript
i on: "· 
cout << "Enter the part 
cin 
>> i tem.partNum; 
cout << "Enter the part 
ci n. get(); 
II Move past the '\n' 
left 
i n the 
II 
input buffer 
by the last 
input. 
getl i ne(cin, 
item.descr
i ption); 
cout << "Enter the quantity 
on hand: "· 
cin 
>> i tem.onHand ; 
cout << "Enter the uni t price: 
"· 
53 
cin 
>> i tem.pr i ce; 
54
} 
55 
56 /******************************************************************** 
57 
* 
showltem 
* 
58 
* Thi s funct i on di splays 
the data stored 
in the members of an 
* 
59 
* Invltem structure 
var i able passed to it as a constant 
reference
. * 
60 
* ******************************************************************/ 
61 void showltem(const 
Invltem &item) 
62 { 
63 
64 
65 
66 
67 
68 } 
cout << 
cout << 
cout << 
cout << 
cout << 
fixed 
<< showpoi nt 
"Part Number 
" 
"Descript
i on 
" 
"Units On Hand: " 
"Price 
$" 
<< setprecision(2) 
<< endl;; 
<< i tem.partNum 
<< endl; 
<< i tem.description 
<< endl; 
<< i tem.onHand << endl; 
<< i tem.price 
<< endl ; 
Program Output with Example Input Shown in Bold 
Enter the part number: 800[Enter] 
Enter the part description: 
Screwdrlver[Enter] 
Enter the quantity 
on hand: 135[Ent er] 
Enter the unit price: 
1.25 [Ent er] 
Part Number 
Description 
Units On Hand: 
800 
Screwdriver 
135 
Price 
$1 .25 
Returning a Structure from a Function 
A structure variable can also be returned from a function. In this case the return type of the 
function is the name of the structure. Program 7-15 could have been written to allow the 
getitemData function to create a local instance of an Inv Item structur e, place data values 
into its member variab les, and then pass it back to mai n, instead of receiving it from main 
as a reference variable . Thi s is what the revised getitemData function would look like. 

464 
Chapte r 7 
0 
Introduction to Classes and Objects 
/*************************************************************** 
* 
getltemData 
* This function 
stores 
data i nput by the user in the members 
* of a local 
Invltem 
structure 
variable 
and then returns 
it . 
* 
* 
* 
* *************************************************************/ 
Invltem 
getltemData() 
{ 
} 
Invltem 
item; 
II Create 
a local 
Invltem var i able 
II to hold data until 
it can be returned. 
cout << "Ent er the part 
number : "; 
cin 
>> item .pa rtNum; 
cout << "Enter 
the part description
: "; 
cin .ge t(); 
II Move past the 
'\n' 
l eft 
i n the 
II i nput buffer 
by the last 
input. 
getline(cin, 
item .description
); 
cout << "Enter 
the quantity 
on hand: "; 
cin 
>> item .onHand; 
cout << "Ent er the unit 
price: 
•· 
cin 
>> item .price
; 
return 
i tem; 
And here is how it would be called from main. 
part= 
getltemData(); 
Th is version of Program 7-15 can be found in the Chapter 7 programs folder on the 
book's companion website as pr? -158. cpp . 
NOTE: 
In Chapter 6 yo u learned that C++ only allows you to return a sing le 
value from a function . However, classes and str uctures provide a way around this 
limitation. Even though they may have several members, each instance of a class or 
str ucture is technically a single object . By packaging multiple values inside a class or 
str ucture, you can return as many values as you need from a function. 
Checkpoint 
Use the following str ucture declaration to answer the questions in this section . 
struct 
Rectang le 
{ 
} ; 
int 
length
; 
int width ; 
7.32 
Write a function that accepts the Rectangle 
str ucture defined above as its 
argument and displays the str ucture's contents on the screen. 
7.33 
Write a function that uses a Rectangle 
stru ctu re reference variable as its 
parameter and stores the user's input in the str ucture's members. 
7.34 
Write a funct ion that returns a Rectangle str ucture . Th e function shou ld create a 
local Rectang l e variable, store the user's input in its members, and then return it. 

7.13 
7.13 More about Enumerated Data Types 
465 
More about Enumerated 
Data Types 
CONCEPT
: Enum erated data types can make pr ogram s more reada ble. 
In Chapter 4 you were introduced to enumerated 
data types. These , as you recall , are 
programmer -defined data types that consist of a set of values known as enumerators, 
which represent integer constants. In this sect ion we will further exp lore their use and 
examine things you can and cannot do with them . 
Declaring an enum Data Type and Defining Variables 
All in One Statement 
The follow ing code uses two lines to declare an enumerated 
data type and define a 
variable of the type . 
enum Car { PORSCHE, FERRARI , JAGUAR}; 
Car sportsCar; 
However , C++ allows you to declare an enumerated 
data type and define one or 
more variab les of the type in the same statement
. So the previous code could be 
written like this: 
enum Car { PORSCHE, FERRARI , JAGUAR} sportsCar; 
The following statement declares the Car data type and defines two variables, myCar 
and yourCar. 
enum Car { PORSCHE, FERRARI , JAGUAR} myCar, yourCar; 
Assigning an Integer to an enum Variable 
Even though the enumerators 
of an enumerated 
data type are stored in memory as 
integers , you cannot directly assign an integer value to an enum var iable. For example, 
assume we have a program that contains the following declarat ions: 
enum Day { MONDAY, TUESDAY, WEDNESDAY, 
THURSDAY, FRIDAY}; 
Day today; 
We could now write the following assignment statement: 
today= 
THURSDAY; 
However, 
as you learned in Chapter 4, the following statement 
is illegal and will 
produce an error message if you try to compile it. 
today = 3; 
I I Error! 
When assigning a value to an enum variab le, you should use a valid enumerator. 
However, if circumstances 
require that you store an integer value in an enum variable, 
you can do so by cast ing the integer to the enum data type . Here is an examp le: 
today= 
st at ic _cast<Day>(3); 

466 
Chapte r 7 
Introduction to Classes and Objects 
This statement will produce the same resu lts as: 
today= 
THURSDAY; 
Assigning an Enumerator to an int Variable 
Although you cannot directly assign an integer value to an enum variable, you can 
directly assign an enumerator to an integer variable. For example, the following code 
will work just fine. 
enum Day { MONDAY, 
TUESDAY, WEDNESDAY, 
THURSDAY, FRIDAY}; 
i nt today= 
THURSDAY; 
Day workday= 
FRIDAY; 
i nt tomorrow= 
workday; 
cout <<today<<" 
"<<tomorrow<< 
endl; 
When this code runs it will display 3 4. 
Using Math Operators to Change the Value of an 
enum Variable 
Even though enumerators 
are really integers and enum variables really hold integer 
values, you can run into prob lems when trying to perform math operations with them. 
For example, look at the following code . 
Day day1, day2; 
day1 = TUESDAY; 
day2 = day1 + 1; 
// Define two Day variables 
// Assign TUESDAY t o day 1 
// ERROR! This will 
not work 
The third statement causes a problem because the expression day1 + 1 results in the 
integer value 2. The assignment operator then attempts to assign the integer value 2 to 
the enum variable day2 . Because C++ cannot implicitly convert an i nt to a Day, as 
prev ious ly discussed, an error occurs . You can fix this by using a cast as we did above 
to explicitly convert the result to the Day data type, as shown here: 
day 2 = static
_cast<Day>(day1 
+ 1); // This works 
Using Enumerators to Output Values 
As you have already seen, sending an enumerator 
to cout causes the enumerator's 
integer value to be displayed . For example, assuming we are using the Day type 
prev ious ly described, the following statement displays 0. 
cout <<MONDAY<< endl; 
If you wish to use the enumerator to display a string such as "Monday," you'll have to 
write code that produces the desired string . For examp le, if workDay is a Day variable 
that has been init ialized to some value, the following swi t ch statement displays the 
name of a day, based on the value of the variable . 

0 
7.13 More about Enumerated Data Types 
467 
swi tch(workDay) 
{ 
case MONDAY 
cout << "Monday"; 
break; 
case TUESDAY cout << "Tuesday" ; 
break; 
case WEDNESDAY: 
cout << "Wednesday" ; 
break; 
case THURSDAY cout << "Thurs day "; 
break; 
case FRIDAY 
cout << "Friday "; 
} 
Using Enumerators to Control a Loop 
Because enumerators are stored in memory as integers, you can use them to control 
how many iterations a loop should perform. However, as discussed above, you cannot 
assign the result of a math operation to an enumerator without first casting the result 
to its enum data type. Therefore, you cannot use the ++ or -- operators directly on an 
enum variable. The following code will not work. 
Double sales , total 
= 0.0; 
fo r (Day workday = MONDAY; 
workday<= 
FRIDAY; workday+ +) 
// Wrong! 
{ 
} 
cout << "Enter the sales 
for day"<< 
(workday+1) << "· "; 
ci n 
>> sales ; 
total 
+= sales; 
We can solve the problem by changing the for statement to the following: 
fo r (Day workday = MONDAY; 
workday<= 
FRIDAY; 
workday = stati c_cast<Day> (workday+ 1}) 
However, it is simpler to make the loop contro l variable an i nt. Then you can write 
the loop like this: 
fo r (i nt workday = MONDAY; 
workday<= 
FRIDAY; workday+ +) 
{ 
} 
cout << "Enter the sales 
for day"<< 
(workday+1) << "· "; 
ci n 
>> sales ; 
total 
+= sales; 
Using Strongly Typed enums in C++ 11 
C++ does not allow multiple enumerators with the same name within the same scope. 
That is, the same enumerator name cannot be a member of two different enumerated 
data types defined or used in the same scope. However, C++ 11 includes a new type of 
enum, known as a strongly typed enum (also known as an enum class), to get around 
this limitation . Here are two examples of a strong ly typed enum declarat ion: 
enum class 
Presidents 
{ MCKINLEY
, ROOSEVE
LT, TAFT} ; 
enum class 
VicePres i dents 
{ ROOSEVE
LT, FAIRBANKS, SHERMAN}; 

468 
Chapte r 7 
Introduction to Classes and Objects 
Th ese statements declare two strongly typed en urns, Presidents 
and Vi cePres i dents. 
Notice that they look like regular enum declarat ions, except that the word cl ass 
appears after enum. Alth ough both enums conta in the same enumerator, 
ROOSEVELT, 
these declarat ions will compile without an error. 
When you use a strong ly typed enumerated data type, howeve r, you must prefix every 
enumerator 
you reference with the name of the enum it belongs to, followed by the : : 
operator. Here are three examples: 
Presidents 
prez = Presidents: 
:ROOSEVELT; 
VicePres ide nts vp1 = VicePresidents: 
:ROOSEVELT; 
VicePresidents 
vp2 = VicePresidents: 
:SHERMAN
; 
Th e first statement defines a Presidents 
var iable named prez and initializes it with the 
Presidents
: : ROOSEVELT 
enumerator. Th e second statement defines a Vi cePresi dents 
variable named vp1 and initi alizes it with the Vi cePresi dents: : ROOSEVELT 
enumerato r. 
Th e third statement defines a Vi cePresi dents variable named vp2 and initializes it 
wit h the Vi cePres i dents: 
: SHERMAN enumerato
r. Notice 
that even though 
the 
enumerator 
SHERMAN 
is only a membe r of one of the enumerated data types, it still must 
be preceded by the name of the enum it belongs to. 
Here is an examp le of an if statement 
that compares 
the prez variable with an 
enumerator: 
if 
(prez --
Presidents: 
:ROOSEVELT
) 
cout << "Roosevelt 
is president!\n"; 
Strongly typed enumerators 
are stored as integers, like regular enume rators . However, 
if you want to retr ieve a strongly typed enumerator's 
underlying integer val ue, you 
must use a cast ope rator. Here is an example that assigns the underlying integer val ue 
of the Presidents
: : ROOSEVELT 
enumerator 
to the variable x. 
i nt x = static
_cast<int>(Presidents: 
:ROOSEVELT
); 
Here is another examp le. It displays the integer values of the Presidents
: : TAFT and 
the Presidents
: : MCKINLEY enumerators 
cout << static
_cast<int>(Presidents: 
:ROOSEVELT
) <<" 
<< static
_cast<int>(Presidents: 
:TAFT)<< 
endl ; 
" 
When you declare a strong ly typed enum, you can opt iona lly spec ify any integer data 
type as the underlying type . You simp ly write a colon ( : ) after the enum name , followed 
by the desired data type . For examp le, the following statement declares an enum that 
uses the char data type for its enumerators: 
enum class 
Day : char { MONDAY
, TUESDAY
, WEDNESDAY
, THURSDAY
, FRIDAY}; 
Th e following statement 
shows anot her example . Thi s statement 
declares an en um 
named Water that uses uns ig ned as the data type of its enumerators. 
Additionally , 
val ues are ass igned to the enumerators. 
enum class 
Water : unsigned 
{FREEZING= 
32, BOILING = 212 }; 
Program 7-16 illustrates the use of strong ly typed enumerated data types . 

7.14 Home Software Company OOP Case Study 
469 
Program 7-16 
1 // This program uses two strongly 
typed enumerated 
data types. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 enum class 
Pr esidents 
{ MCKINLEY, ROOSEVELT, TAFT}; 
6 enum class 
VicePresidents 
{ ROOSEVELT
, FAIRBANKS, SHERMAN}; 
7 
8 int main() 
9 { 
10 
Presidents 
prez = Presidents: 
:ROOSEVELT
; 
11 
VicePres i dents 
vp1 = VicePresidents: 
:ROOSEVELT
; 
12 
VicePres i dents 
vp2 = VicePresidents: 
:SHERMAN
; 
13 
14 
cout << static
_cast<int>(prez) 
<<" 
" << static
_cast<int>(vp1) 
15 
<<" 
" << static
_cast<int>(vp2) 
<< end l; 
16 
ret urn O; 
17 } 
Program Output 
1 
0 
2 
Home Software Company OOP Case Study 
You are a programmer for the Home Software Company assigned to develop a class that 
models the basic workings of a bank account. Th e class should perform the following tasks: 
• Save the account balance . 
• Save the numbe r of transactions performed on the account . 
• Allow deposits to be made to the account . 
• Allow withrawals to be taken from the acco unt . 
• Calculate interest for the period. 
• Report the current acco unt balance at any time. 
• Report the current number of transactions at any time . 
Private Member Variables 
Table 7-2 lists the private member var iables needed by the class. 
Table 7-2 Private Member Variables of the Account Class 
Variable 
balance 
intRate 
interest 
transactions 
Description 
A double that holds the current account balance 
A double that holds the interest rate for the period 
A double that holds the interest earned for the current period 
An integer that holds the current number of transactions 

470 
Chapte r 7 
Introduction to Classes and Objects 
Public Member Functions 
Table 7-3 lists the public member functions in the class. 
Table 7-3 Public Membe r Functions of the Account Class 
Function 
constructor 
makeDeposi t 
wit hdraw 
Description 
Takes arguments to be initially stored in the balance and in t Rate 
members . The default value for the balance is zero and the default value 
for the interest rate is 0.045. 
Takes a double argument that is the amount of the deposit . This 
argument is added to bala nce. 
Takes a double argument that is the amount of the withdrawal. This 
value is subtracted from the balance, unless the withdrawal amount is 
greater than the balance. If this happens, the function reports an error. 
calc lnt erest 
Takes no arguments . This funct ion calculates the amount of interest for 
the current period , stores this value in the in t erest member, and then 
adds it to the balance member. 
get Balance 
get Interes
t 
get Transac t ions 
Returns the current balance (stored in the bala nce member ). 
Returns the interest earned for the current period (stored in the i nt erest 
member) . 
Returns the number of transact ions for the current period (stored in the 
transac t ions member ). 
The Class Declaration 
The following listing shows the class declaration . 
Contents of Account . h 
1 //Account.
hi s t he Account class 
specification 
file. 
2 class Account 
3 { 
4 
private: 
5 
double balance; 
6 
double i nt Rate; 
7 
double i nt erest; 
8 
in t transac ti ons; 
9 
10 
public: 
11 
12 
// Construc t or 
13 
Account(double 
ra t e= 
0.045 , double bal = 0 .0) 
14 
{ 
balance= 
bal; 
i ntRat e = rate; 
15 
i nterest= 
0 .0; transac t ions= 
O; 
16 
} 
17 
18 
void makeDeposi t (double amount) 
19 
{ balance
+= amount; 
20 
transactions
++; 
21 
} 

7.14 Home Software Company OOP Case Study 
471 
22 
23 
24 
25 
bool wi thdraw(double 
amount); 
// Defined 
in account.cpp 
void calclnterest() 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 } ; 
{ 
interest= 
balance* 
intRate; 
balance
+= interest; 
} 
double getBalance
() 
{ 
return 
balance
; 
} 
double getlnterest
() 
{ 
return 
interest
; 
} 
int getTransactions() 
{ 
return 
transactions; 
} 
The withdraw Member Function 
Th e on ly member function not defined inline in the class declaration is wi thdraw. Th e 
purpose of that function is to subtract the amount of a withd rawal from the balance 
member. If the amount to be withdr awn is greater than the current balance, however, 
no withdrawal is made . Th e function returns true if the withd rawa l is made or false if 
there is not eno ugh in the account. 
Content s of Account . cpp 
1 // Account.cpp 
is the Account class 
function 
implementat
ion file. 
2 #include 
"Account.h" 
3 
4 bool Account: :withdraw (dou ble amount) 
5 { 
6 
if 
(balance< 
amount) 
7 
return 
false
; 
// Not eno ugh in the account 
8 
el se 
9 
{ 
10 
balance
- = amount; 
11 
transactions
++; 
12 
return 
true; 
13 
} 
14 } 
The Class Interface 
Th e balance , i ntRate, i nterest
, and transactions 
member variables are private, so 
they are hidden from the world outside the class . Th is is beca use a programmer with 
direct access to these variables might unknowingly comm it any of the follow ing errors: 
• A deposit or withdrawal might be made with out the transactions 
member being 
incremented . 

472 
Chapte r 7 
Introduction to Classes and Objects 
• A withdrawal might be made for more than is in the account . Thi s will cause the 
balance 
member to have a negative value. 
• Th e interest rate might be calculat ed and the balance member adjusted, but the 
amount of interest might not get recorded in the i ntRate member. 
• Th e wrong interest rate might be used. 
Because of the potential for these errors, the class contains public member functions 
that ensure the proper steps are taken when the account is manipulated. 
Implementing 
the Class 
Program 7-17 shows an implementation 
of the Account class . It presents a menu for 
displaying a savings account's balance , number of transactions , and interest earned . It also 
allows the user to deposit an amount into the acco unt , make a withdrawal from the 
account, and calculate the interest earned for the current period. All the files needed for this 
program are located in the Chapter 7 programs folder on the book's companion website. 
Program 7-17 
1 
II This cl i ent program uses the Account class 
to perform 
simple 
2 
II banking operat i ons. Thi s file 
should 
be combi ned into a 
3 
II project 
along with the Account.hand 
Account.cpp 
f i les . 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 #include 
"Acco unt.h" 
7 
using namespace std; 
8 
9 
II Funct i on prototypes 
10 
void displayMenu
(); 
11 
char getChoice
(char ); 
12 
void makeDeposit(Account 
&); 
13 
void wi thdraw(Account 
&); 
14 
15 
int main() 
16 
{ 
17 
const 
char MAX
_CHOICE = ' 7 '; 
18 
Account savings
; 
II Account object 
to model sav i ngs account 
19 
char choice; 
20 
21 
cout <<f i xed<< 
showpoint 
<< setprec
i sion (2); 
22 
do 
23 
{ 
24 
displayMenu(
); 
25 
choice= 
getChoice(MAX _CHOICE); 
II This returns 
only 
'1' 
-
' 7 ' 
26 
swi tch(choice
) 
27 
{ 
28 
29 
30 
31 
32 
33 
34 
case 
'1': 
cout << "The current 
bal ance is$"; 
cout << savings.getBalance() 
<< endl; 
break ; 
case 
' 2 ': cout << "There have been"; 
cout << savings.getTransactions() 
<<" 
transactions
. \n"; 
break ; 
(program continues) 

7.14 Home Software Company OOP Case Study 
473 
Program 7-17 
(continued) 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
case '3': 
cout << "Interest 
earned for this 
period: 
$"; 
cout << savings.getinterest() 
<< endl ; 
} 
break; 
case '4': 
makeDeposit(savings); 
break; 
case '5': 
withdraw(savings); 
break; 
case '6': 
sav i ngs.calcinterest(); 
cout << "Interest 
added.\n"; 
45 
} while(choice 
!= '7'); 
46 
return 
O; 
47 
} 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
/**************************************************************** 
* 
displayMenu 
* 
* This function 
displays 
the user's 
menu on the screen. 
* 
****************************************************************/ 
void displayMenu() 
{ 
} 
cout << "\n\n 
MENU\n\n"; 
cout << "1) Display 
the account 
balance\n"; 
cout << "2) Display 
the number of transactions\n"; 
cout << "3) Display 
i nterest 
earned for this 
period\n"; 
cout << "4) Make a deposit\n"; 
cout << "5) Make a wi thdrawal \n"; 
cout << "6) Add i nterest 
for th i s per i od\n"; 
cout << "7) Exit the program\n\n"; 
cout << "Enter your choice: 
"· 
66 
67 
68 
69 
70 
71 
72 
73 
74 
/***************************************************************** 
* 
getChoice 
* 
* This function 
gets, 
validates, 
and returns 
the user's 
cho i ce. 
* 
*****************************************************************/ 
char getChoice (char max) 
{ 
char choice= 
ci n. ignore(); 
ci n. get(); 
// Bypass the 
75 
while 
(choic e < '1' 
11 choice 
> max) 
76 
{ 
I \n I in the i nput buffer 
77 
cout << "Choice must be between 1 and"<< 
max<<" 
" 
78 
<< "Please 
re-enter 
cho i ce: "; 
79 
choice= 
cin.get
(); 
80 
cin .i gnore(); 
// Bypass the '\n' 
in the input buffer 
81 
} 
82 
return 
choice; 
83 
} 
84 
(program continues) 

474 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-17 
(continued) 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 
95 
96 
97 
98 
99 
/**
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * * * * * 
* 
makeDeposi t 
* This function 
accepts 
a reference 
to an Account object
. 
* The user is prompted for the dollar 
amount of the deposit
, 
* and the makeDeposi t member of the Account object 
i s 
* then called
. 
* 
* 
* 
* 
* 
** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * * * * * / 
void makeDeposit(Account 
&account ) 
{ 
} 
double dollars
; 
cout << "Enter the amount of the deposit: 
"· 
cin 
>> dollars
; 
cin. i gnore (); 
account .makeDeposit(dollars)
; 
100 
101 
102 
103 
104 
105 
106 
107 
108 
109 
110 
111 
/ ** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * * * * * 
* 
withdraw 
* 
* This function 
accepts 
a reference 
to an Account object
. 
* 
* The user is prompted for the dollar 
amount of the wi thdrawal
, * 
* and the withdraw member of the Account object 
is then called.* 
** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ****
* * * * * * / 
void withdraw (Account &account) 
{ 
double dollars
; 
112 
cout << "Enter the amount of the wi thdrawal: 
" ; 
113 
cin 
>> dollars
; 
114 
cin. i gnore()
; 
115 
i f (!account.withdraw(dollars)) 
116 
cout 
<< "ERROR: Withdrawal 
amount too large.\n\n"; 
117 
} 
Program Output with Example Input Shown in Bold 
Menu 
1) Display 
the account 
balance 
2) Display 
the number of transactions 
3) Display 
interest 
earned for this 
period 
4) Make a deposit 
5) Make a withdrawal 
6) Add interest 
for this 
period 
7) Exit the program 
Enter your choice: 
4[Enter] 
Enter the amount of the deposit: 
500[Ent er] 
Menu 
1) Display 
the account 
balance 
2) Display 
the number of transactions 
3) Display 
interest 
earned for this 
period 
4) Make a deposit 
5) Make a withdrawal 
6) Add interest 
for this 
period 
7) Exit the program 
Enter your choice: 
1 [Enter] 
The current 
balance 
is $500.00 
(program output continues) 

7.14 Home Software Company OOP Case Study 
475 
Program 7-17 
(continued) 
Menu 
1) Display 
the account 
balance 
2) Display 
the number of transactions 
3) Display 
interest 
earned for this 
period 
4) Make a deposit 
5) Make a withdrawal 
6) Add interest 
for this 
period 
7) Exit the program 
Enter your choice: 
S[Enter] 
Enter the amount of the withdrawal: 
700[Enter] 
ERROR: Withdrawal 
amount too large. 
Menu 
1) Display 
the account 
balance 
2) Display 
the number of transactions 
3) Display 
interest 
earned for this 
period 
4) Make a deposit 
5) Make a withdrawal 
6) Add interest 
for this 
period 
7) Exit the program 
Enter your choice: 
S[Enter] 
Enter the amount of the withdrawal: 
200[Enter] 
Menu 
1) Display 
the account 
balance 
2) Display 
the number of transactions 
3) Display 
interest 
earned for this 
period 
4) Make a deposit 
5) Make a withdrawal 
6) Add interest 
for this 
period 
7) Exit the program 
Enter your choice: 
6[Ent er] 
Interest 
added. 
Menu 
1) Display 
the account 
balance 
2) Display 
the number of transactions 
3) Display 
interest 
earned for this 
period 
4) Make a deposit 
5) Make a withdrawal 
6) Add interest 
for this 
period 
7) Exit the program 
Enter your choice: 
1 [Enter] 
The current 
balance 
is: 
$313.50 
Menu 
1) Display 
the account 
balance 
2) Display 
the number of transactions 
3) Display 
interest 
earned for this 
period 
4) Make a deposit 
5) Make a withdrawal 
6) Add interest 
for this 
period 
7) Exit the program 
Enter your choice: 
7[Enter] 

476 
Chapte r 7 
Introduction to Classes and Objects 
Introduction to Object-Oriented 
Analysis 
and Design 
CONCEPT: Obj ect-ori ented analysis determines the requirements for a system to 
clarify what it must be able to do, what classes are needed, and how 
those classes are related. Object-oriented design then designs the classes 
and specifies how they will carry out their responsibilities. 
So far you have learned the basics of writing a class, creating an object from the class, 
and using the object to perform operations . This knowledge is necessary to create an 
object-oriented application, but it is not the first step in designing the application . First, 
a programmer or an analyst must caref ully ana lyze the problem to be solved to 
determine exactly what the program must be able to do. In OOP term inology, this 
phase of program development is known as the object-oriented analysis phase. Durin g 
this time it is determined what classes are needed . 
The process of object-oriented analysis typically includes the following steps: 
1. Identify the classes and objects to be used in the program. 
2. Define the attr ibutes for each class. 
3. Define the behaviors for each class. 
3. Define the relationships between classes. 
Let's look at each step more closely. 
1. Identify the Classes and Objects. 
Remember, a class is a package that consists of data and procedures that perform operations 
on the data. In order to determine the classes that will appear in a program, the programmer 
should think of the major data elements and decide what procedures or actions are required 
for each class. For example, consider a restaurant that uses an object-oriented program to 
enter customer orders. A customer order is a list of menu items with their respective prices. 
The restaurant uses this list to charge the customer, so a class could be created to model it. 
Also, the restaurant's menu has several main entrees, appetizers, side dishes, and beverages 
to choose from. A class could be designed to represent menu items as well. 
Classes can be easily designed to model real-world objects, such as customer orders 
and a restaurant's menu items. Here are some other types of items that may be 
cand idates for classes in a program: 
• User-interface components, such as windows, menus, and dialog boxes 
• Input/output devices, such as the keyboard, mouse, display, and print er 
• Physical objects, such as vehicles, machines, or manufactured products 
• Recordkeeping items, such as customer histories, and payroll records 
• A role played by a human (employee, client, teacher, student, and so forth) 
2. Define Each Class's Attributes. 
A class's attributes are the data elements used to describe an object instant iated from 
the class. They are the values needed for the object to function properly in the program. 

7.15 Introduction to Object -Oriented Analysis and Design 
477 
Using the restaurant example, here is the beginning of a possible specification for a 
menu Item class. 
Class name: Menu Item 
Attributes: 
i temName 
price 
category 
II 
1 = appetizer, 
2 = salad, 
3 = entree 
II 
4 = si de dish , 5 = dessert, 
6 = beverage 
And here is the beginning of a possible specification for a CustomerOrder class. 
Class name: CustomerOrder 
Attributes: 
orderNumber 
tableNumber 
serverNumber 
date 
it ems 
II a list 
of Menultem objects 
total Price 
tip 
3. Define Each Class's Behaviors. 
Once the class's attr ibut es have been defined, the programmer must identify the 
activities, or behaviors, each class must be capable of performing. For example, some 
of the activities the Menu Item class should be able to perform include 
• Changing a price 
• Displaying a price 
Some of the activities the CustomerOrder class should be able to perform include 
• Accepting the information for a new order 
• Adding an item to an existing order 
• Return ing any information on a previously stored order 
• Calculating the total price of all items on an order 
• Printing a list of ordered items for the kitchen 
• Printin g a bill for the patron 
In C++, a class's behaviors are its member functions . 
4. Define the Relationships Between the Classes. 
Th e last step in our object-oriented analysis phase is to define the relationships that 
exist between and among the classes in a program. Th e possible relationships may be 
formally stated as 
• Access 
• Ownership (Composition) 
• Inheritance 
Informally, these three relationships can be described as 
• Uses-a 
• Has-a 
• Is-a 

478 
Chapte r 7 
Figure 7-9 
Introduction to Classes and Objects 
The first relationship, access, allows an object to modify the attributes of another 
object . Normally, an object has attributes not accessible to parts of the program 
outside the object . These are known as private attributes . An access relationship 
between two objects means that one object will have access to the other object's 
private attr ibutes. When this relationsh ip exists, it can be said that one object uses 
the other. 
The second relationship, ownership, means that one object has another object as one of 
its members. For example, in our restaurant example, the CustomerOrder 
class has a 
list of Menultem objects as one of its attr ibutes . In OOP termino logy, this type of 
relationship is also called composition. 
The third relationship is inheritance. Sometimes a class is based on another class. This 
means that one class is a specialized case of the other. For example, consider a program 
that uses classes representing cars, trucks, and jet planes. Although those three types of 
classes in the real world are very different, they have many common characteristics: 
They are all modes of transportation, and they all carry some number of passengers. So 
each of the three classes could be based on a Vehicle class that has attributes and 
behaviors common to them all. This is illustrated in Figure 7-9. 
Car 
Jet Plane 
In OOP terminology, the Vehicle class is the base class and the Car, Truck and Jet 
Plane classes are derived classes. All of the attributes and behaviors of the Vehicle class 
are inherited by the Car, Truck, and Jet Plane classes. The relationship implies that a 
car is a vehicle, a truck is a vehicle, and a jet plane is a vehicle. 
In addition to inheriting the attributes and behaviors of the base class, derived classes 
add their own. For example, the Car class might have attributes and behaviors that set 
and indicate whether it is a sedan or a coupe and the type of engine it has. The Truck 
class might have attributes and behaviors that set and indicate the maximum amount 
of weight it can carry, and how many miles it can travel between refuelings. The Jet 
Plane class might have attributes and behaviors that set and indicate its altitude and 
heading. These added components of the derived classes make them more specialized 
than the base class. 
These three types of relationships between classes, access, ownership, and inheritance, 
are discussed further in Chapter 11. 
Once an enterprise and its operations have been analyzed, each class can be designed, 
and a set of programs can be developed to automate some of these operations . 

7.15 Introduction to Object -Oriented Analysis and Design 
479 
Finding the Classes 
Let's look further at step 1 in the analysis process: identifying the classes. Over the 
years, software professionals have developed numerous techniques for doing this, but 
they all involve identifying the different types of real-world objects present in the 
problem, so that classes can be created for them. One simple and popular technique 
involves the following steps: 
1. Get a written description of the problem domain. 
2. Identify all the nouns (including pronouns and noun phrases) in the description. 
Each of these is a potential class. 
3. Refine the list to include only the classes that are relevant to the problem. 
Let's take a closer look at each of these steps. 
Write a Description of the Problem Domain 
The problem domain is the set of real-world objects, parties, and major events related 
to the problem. If you understand the nature of the problem you are trying to solve, 
you can write a description of the problem domain yourself. If you do not thorough ly 
understand it, you should have an expert write the description for you. 
For example, suppose we are programming an application that the manager of Joe's 
Automot ive Shop will use to print service quotes for customers. Here is a description 
that an expert, perhaps Joe himself, might have written: 
Joe's Automotive Shop services foreign cars and specializes in servicing cars made by 
Mercedes, Porsche, and BMW. When a customer brings a car to the shop, the manager 
gets the customer's name, address, and telephone number. The manager then determines 
the make, model, and year of the car, and gives the customer a service quote. The 
service quote shows the estimated parts charges, estimated labor charges, sales tax, and 
total estimated charges. 
The problem domain description should include any of the following: 
• Physical objects such as vehicles, machines, or products 
• Any role played by a person, such as manager, employee, customer, teacher, or student 
• The results of a business event, such as a customer order, or in this case a service quote 
• Recordkeeping items, such as customer histories and payroll records 
Identify All of the Nouns 
The next step is to identify all of the nouns and noun phrases. (If the description 
contains pronouns , include them too.) Here's anot her look at the previous problem 
domain description . This time the nouns and noun phrases appear in bold. 
Joe's Automotive Shop services foreign cars and specializes in servicing cars 
made by Mercedes, Porsche, and BMW. When a customer brings a car to the 
shop, the manager gets the customer's name, address, and telephone numb er. 
The manager then determines the make, model, and year of the car and gives the 
customer a service quote. The service quote shows the estimated parts charges, 
estimated labor charges, sales tax, and total estimated charges. 

480 
Chapte r 7 
Introduction to Classes and Objects 
Notice that some of the nouns are repeated . The following lists all of the nouns without 
duplicating any of them . 
address 
foreign cars 
Porsche 
BMW 
Joe's Automot ive Shop 
sales tax 
car 
make 
service quote 
cars 
manager 
shop 
customer 
Mercedes 
telephone number 
estimated labor charges 
model 
total estimated charges 
estimated parts charges 
name 
year 
Refine the List of Nouns 
The nouns that appear in the problem description are merely candidates to become 
classes. It might not be necessary to make classes for them all. The next step is to refine 
the list to include only the classes that are necessary to solve the particular problem at 
hand . Here are the common reasons that a noun can be eliminated from the list of 
potential classes. 
Some of the noun s really mean the same thing. 
In this example, the following sets of nouns refer to the same thing: 
• cars and foreign cars both refer to the general concept of a car. 
• Joe's Automotive Shop and shop both refer to the same shop. 
We can settle on a single class for each of these. In this example we will arbitrar ily 
eliminate foreign cars from the list and use the word cars. Likewise, we will eliminate 
Joe's Autom otive Shop from the list and use the word shop. The updated list of 
potential classes is: 
address 
£01 eiga eat:, 
Porsche 
BMW 
f ' 
4 
! 
, · 
51 
oe s 1 ,a 0 1110 1; e
1op 
sales tax 
car 
make 
service quote 
cars 
manager 
shop 
customer 
Mercedes 
telephone number 
estimated labor charges 
model 
tota l estimated charges 
estimated parts charges 
name 
year 
Some noun s might represent items that we do not need to be 
concerned with in order to solv e the problem. 
A quick review of the problem description reminds us of what the application should do: 
print a service quote. To do this, two of the potential classes we have listed are not needed. 
• We can cross shop off the list because our application only needs to be concerned 
with individual service quotes. It doesn't need to work with or determine any 
companyw ide information . If the problem description asked us to keep a total of 
all the service quotes, then it would make sense to have a class for the shop. 
• We will also not need a class for the manager because the problem statement does 
not ask us to process any information about the manager. If there were multiple 
shop managers, and the problem description asked us to record which manager 
wrote each service quote, it would make sense to have a class for the manager. 

7.15 Introduction to Object -Oriented Analysis and Design 
481 
The updated list of potential classes at this point is: 
address 
foreign ears 
Porsche 
BMW 
f ' 
4 
! 
, · 
51 
oe s 1 ,a 01110 1; e
1op 
sales tax 
car 
make 
service quote 
cars 
thAllAget 
~ 
Customer 
Mercedes 
telephone number 
estimated labor charges 
model 
tota l estimated charges 
estimated parts charges 
name 
year 
Some of the nouns might represent objects, not classes. 
We can eliminate Mercedes, Porsche, and BMW as classes because, in this example, 
they all represent specific cars and can be considered instances of a single cars class. We 
can also eliminate the word car from the list because, in the description, it refers to a 
specific car brought to the shop by a customer. Therefore, it would also represent an 
instance of a cars class. At this point the updat ed list of potential classes is: 
address 
£01 eiga eat:, 
Po1sehe 
B!\itW 
j 
' ' 
. 
51 
oc s 1xato111ottvc10p 
sales tax 
CM 
make 
service quote 
cars 
thAllAget 
~ 
customer 
hfereedes 
telephone number 
estimated labor charges 
model 
tota l estimated charges 
estimated parts charges 
name 
year 
Some of the nouns might represent simple values that can be stored 
in a variable and do not require a class. 
Remember, a class contains attributes and member functions . Attributes are related 
items stored within a class object that define its state . Member functions are actions 
or behaviors the class object can perform . If a noun represents a type of item that 
would not have any identifiable attrib ut es or member functions, then it can 
probably be eliminated from the list. To help determine whether a noun represents 
an item that would have att ribute s and member functions, ask the following 
questions about it: 
• Would you use a group of related values to represent the item's state? 
• Are there any obvious actions to be performed by the item? 
If the answers to both of these questions are no, then the noun probab ly represents a 
value that can be stored in a simple variable. If we apply this test to each of the nouns 
that remain in our list, we can conclude that the following are probably not classes: 
address, estimated labor charges, estimated parts charges, make, model, name, sales 
tax, telephone numb er, total estimated charges and year. These are all simple string or 
numeric values that can be stored in variables. 

482 
Chapte r 7 
Introduction to Classes and Objects 
Here is the updated list of potential classes: 
add.res:, 
fureiga ears 
Porsche 
B~IW 
j 
' 
4 
. 
51 
oe :, 1 ruto111ott" e
1op 
sales tax 
CM 
tnAke 
service quote 
cars 
ttlAil Ali,Ct 
fflO!' 
customer 
Afercedes 
telepltotte nmnber 
es~i,nated labo r ehMges 
1nodel 
tOhtl e:ni1nated charges 
estinrated part~ charges 
nanre 
year 
As you can see from the list, we have eliminated everything except cars, customer, and 
service quote. This means that in our application, we will need classes to represent cars, 
customers, and service quotes . Ultimately, we will write a Car class, a Customer class, 
and a Serv i ceQuote class. 
Identifying Class Responsibilities 
Once the classes have been identified, the next task 1s to identify each class's 
responsibilities. Class responsibilities are 
• The things that the class is responsible for knowing 
• The actions that the class is responsible for doing 
When you have identified the things that a class is responsible for knowing, then you 
have identified the class's attributes . Likewise, when you have identified the actions 
that a class is responsible for doing, you have identified its member functions. 
It is often helpful to ask the questions "In the context of this problem , what must the 
class know? What must the class do?" The first place to look for the answers is in the 
description of the problem domain. Many of the things that a class must know and do 
will be mentioned. Some class responsibilit ies, however, might not be directly mentioned 
in the problem domain, so additional ana lysis is often required. Let's apply this 
methodo logy to the classes we previously identified from our problem domain . 
The Custo mer Class 
In the context of our problem domain, what must any object of the Customer class 
know? The description mentions the following items, which are all attributes of a 
customer: 
• The customer's name 
• The customer's address 
• The customer's telephone number 
These are all values that can be represented as strings and stored in the class's member 
variables . The Customer class can potentially know many other things also . One 
mistake that can be made at this point is to identify too many things that an object is 
responsible for knowing . In some applications, for example, a Customer class might 
know the customer's email address . However, this part icular problem domain does not 
mention that the customer's email address is used for any purpose , so it is not the 
responsibility of this class to know it, and we should not include it as an attribute . 

Figure 7-10 
<) 
7.15 Introduction to Object -Oriented Analysis and Design 
483 
Now let's identify the class's member functions. In the context of our problem domain, 
what must the Cust omer class do? The only obvious actions are: 
• Create an object of the Customer class. 
• Set and get the customer's name. 
• Set and get the customer's address . 
• Set and get the customer's telephone number. 
From this list we can see that the Cust omer class will need a constructor, as well as 
accessor and mutator functions for each of its attr ibutes. 
Figure 7-10 shows a UM L class diagram for the Customer class. Notice that the 
diagram looks like a simple rectangle with three parts. The top section holds the name 
of the class. The middle section lists the class attr ibutes, that is, its member variables. 
The bottom section lists its member functions. The minus sign to the left of each 
attribute indicates that it is private. The plus sign to the left of each function indicates 
that it is public. Each attr ibute name is followed by a colon and its data type. Each 
function name is followed by a set of parentheses. If the function accepts any arguments, 
its parameters will be listed inside these parentheses , along with the data type of each 
one. After the parentheses is a colon, followed by the function 's return type. 
Customer 
- name: string 
- address:string 
- phone: string 
+ Customer () : 
+setName(n:string) :void 
+ setAddress (a: string) : void 
+setPhone(p:string):void 
+getName():string 
+ getAddress () : string 
+ getPhone () : int 
NOTE: More information on UML class diagrams can be found in Appendix Fon 
this book's companion website at pearsonhighered .com/gaddis . 
The Car Class 
In the context of our problem domain , what must an object of the Car class know? The 
following items are all attributes of a car and are mentioned in the problem domain: 
• The car's make 
• The car's model 
• The car's year 

484 
Chapte r 7 
Figure 7-11 
Introduction to Classes and Objects 
Now let's identify the class member functions. In the context of our problem domain, 
what must the Car class do? Once again, the only obvious actions are the standard 
member functions we find in most classes: constructors, accessors, and mutators. 
Specifically, the actions are: 
• Create an object of the Car class. 
• Set and get the car's make. 
• Set and get the car's model. 
• Set and get the car's year. 
Figure 7-11 shows a UML class diagram for the Car class at this point . 
Car 
- make: string 
- model: string 
-year:
int 
+Car(): 
+setMake(m:string) 
:void 
+setModel(m:string):void 
+ setYear(y:int) 
:voi d 
+ getMake () : string 
+getModel():string 
+ get Year() : int 
The Servi ceQuote Class 
In the context of our problem domain , what must an object of the Serv i ceQuote class 
know? The problem domain mentions the following items: 
• The estimated parts charges 
• The estimated labor charges 
• The sales tax 
• The total estimated charges 
Careful thought will reveal that two of these items are the results of calculations: sales 
tax and total estimated charges . These items are dependent on the values of the 
estimated parts and labor charges. In order to avoid the risk of holding stale data, we 
will not store these values in member variables . Rather, we will provide member 
functions that calculate these values and return them. The other member functions that 
we will need for this class are a constructor and the accessors and mutators for the 
estimated parts charges and estimated labor charges attributes . 

Figure 7-12 
7.15 Introduction to Object -Oriented Analysis and Design 
48 5 
Figure 7 -12 shows a UML class diagram for the Serv i ceQuote class. 
ServiceQuote 
- partsCharges: doub 1 e 
- laborC harges :double 
+Service Quote() : 
+setPartsCharges{c
:double) :void 
+setlaborCharges{c
:double) :void 
+getPartsCharges{) 
:double 
+getlaborCharges{) :double 
+getSa lesTax {) :double 
+getTota lCharges{) :double 
This Is Only the Beginning 
You should look at the process that we have discussed in this section as merely a starting 
point. It's important to realize that designing an object-oriented application is an iterative 
process. It may take you several attempts to identify all of the classes that you will need and 
to determine all of their responsibilities. As the design process unfolds, you will gain a deeper 
understanding of the problem, and consequently you will see ways to improve the design. 
Object Reusability 
We have mentioned several advantages offered by object-oriented programming . Still 
another is object reusability. A class is not a stand -alone program. It is a mechanism 
for creating objects used by programs that need its service. Ideally, a class created for 
use in one program can be made general enough to be used by other programs as well. 
For examp le, the Customer class can be designed to create objects used by many 
different appl ications that have customers. The Car class can be designed to create 
objects used by many different programs that involve vehicles. 
Object-Oriented versus Object-Based Programming 
Although classes and objects form the basis of object-oriented programming, by themselves 
they are not sufficient to constitute true object-oriented programming. Using them might 
more correctly be referred to as object-based programming. When we add the ability to 
define relationships among different classes of objeets, to create classes of objects from other 
classes (inheritance), and to determine the behavior of a member function depending on 
which object calls it (polymorphism), it becomes true object-oriented programming. You will 
learn about these more advanced object-oriented programming features later in the book. 
~ 
Checkpoint 
7.35 
What is a prob lem domain? 
7.36 
When designing an object -oriented app lication, who should write a description 
of the problem domain? 
7.37 
How do you identify the potential classes in a prob lem domain descript ion? 

486 
Chapter 7 
<) 
Introduction to Classes and Objects 
7.38 
What two questions should you ask to determine a class's responsib ilities? 
7.39 
Look at the following description of a prob lem domain: 
A doctor sees patients in her practice . When a pat ient comes to the practice, the 
doctor performs one or more procedures on the patient. Each procedure 
performed has a description and a standard fee. As patients leave, they receive a 
statement that shows their name and address, as well as the procedures that 
were performed and the total charge for the procedures. 
Assume that you are creating an application to generate a statement that can be 
printed and given to the patient. 
A) Identify all of the potential classes in this prob lem domain. 
B) Refine the list to include only the necessary class or classes for this problem. 
C) Identify the responsibilities of the class or classes that you identified in step B. 
Screen Control 
CONCEPT : Op erating system function s allow you to contr ol how outpu t appears 
on the console screen. 
Positioning 
the Cursor on the Screen 
In Chapter S's Tying It All Together section you learned that C++ compilers provide 
special libraries for calling on operating system functions. So far, in Chapters 5 and 6, 
we have used the Windows Set Consol eTextAtt ri bute function to display screen 
output in color. Now we will look at a Windows operating system function for 
positioning the cursor on the screen. This function is Set Consol eCursorPosi ti on. 
NOTE: 
Recall from Chapter 5 that operating Operating system functions are 
tailored to specific operating systems. So programs that use them will only run on the 
system for which they were written . The functions described here work with Windows 
2000 and newer operating systems. If you are using Linux or Mac OS, your instructor 
may be able to provide you with similar functions that work on those systems. 
Until now, all the programs you have created display output beginning on the top line 
of the screen. They then move down the screen, one line at a time, when the user 
presses the [Enter] key or when the program outputs an endl or "\ n". But what if you 
are writing on the fifth row of the screen and want to go back to the second row? Or 
what if you want to display something in the very middle of the screen? You can do 
these things on a Windows system by using the SetConsol eCursor Position 
function 
to move the cursor to the desired location before writing the output . 
To use this function, you will need to do the same two things you did in Chapters 5 
and 6 to use color. You must 
• #include 
<wi ndows. h> in your program . 
• Create a handle to the standard output screen by includ ing the following 
definition in your program. 
HANDLE scre en = GetStdHandle(STD _OUTPUT_HANDLE); 

0 
7.16 Screen Control 
487 
A typical text screen has 25 rows, or lines, with 80 print positions per row. Each of these 
positions is called a cell. A cell is a little block that can display a single character, and it is 
identified by its row number and its position on that row. The rows range from O to 24, 
with O being the top row of the screen. The print positions on each row, usually referred 
to as columns, range from O to 79, with O being at the far left-hand side. The row and 
column of a cell, which identifies its location on the screen, are called its coordinates. 
To place the cursor in a specific screen cell, you must specify its cell coordinates by 
setting two variables in a COORD 
structure that is already defined in Windows . This 
structure has two member variables named X and Y, with X holding the column and Y 
holding the row. Here is what the structure looks like. 
struc t COORD 
{ 
shor t in t X; 
II Column posi t i on 
shor t in t Y; 
II Row posi t ion 
} ; 
Here is how you use it. The following code segment writes the word He 11 o centered on 
the standard output screen. 
HANDLE 
scr een= GetSt dHandle (STD_OUTPUT_HANDLE); 
COORD position; 
II posi t ion is a COORD structure 
position.
X = 
position.Y 
= 
38; 
11 ; 
II Set column near scre en cent er 
II Set row near scr een center 
II Place cursor t here, the n pr i nt 
SetConsoleCursorPos
iti on(scree n, posit ion}; 
cout <<"Hello"<< 
endl; 
NOTE: 
When you set a screen posit ion, you must follow all output that your 
program writes there with an endl . This is necessary to ensure that the output is 
actually displayed at this location. If you do not use an endl, the output may be 
buffered and written to the screen much later, after the cursor position has changed . 
Following your output with the new line character '\ n' does not work because it 
does not flush the screen buffer like endl does. 
Program 7-18 positions the cursor to display a set of nested boxes near the center of 
the screen. Notice that it uses the Sleep function, previously seen in Chapter 5 and 
Chapter 6's Tying It All Together programs . This function pauses the program 
execution for part of a second so things do not happen too fast for the user to see them. 
The argument passed to the function tells it how many milliseconds it should pause . A 
millisecond is a thousandth of a second . So, for examp le, to pause execution of a 
program for a half second, the following function call would work. 
Slee p(SOO}; 
Program 7-18 uses the command Sleep(750) to pause the program execution for¾ of 
a second after each box displays . 

488 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-18 
1 II Thi s program demonstrates 
the use of Windows f unctions 
2 II for positioning 
the cursor
. It di splays 
a ser i es of nested 
3 II boxes near the center 
of the screen . 
4 #include 
<iostream> 
5 #include 
<windows.h> 
6 using namespace std ; 
II Needed to set cursor 
positions 
& call 
Sleep 
7 
8 void placeCu rsor (HANDLE, int, 
int); 
9 void printStars
(int); 
10 
11 int main() 
12 { 
13 
const i nt midRow = 12 , 
14 
midCol = 40, 
15 
numBoxes = 3; 
16 
int width, 
startRow , endRow; 
17 
II Function 
prototypes 
18 
II Get the handle to standard 
output 
device 
(the console} 
19 
HANDLE screen= 
GetStdHandle(STD _OUTPUT
_HANDLE
); 
20 
21 
II Each loop pr i nts one box 
22 
for (i nt box= 
1 , height= 
1; box< = numBoxes; box++, height+=2} 
23 
{ 
startRow = mi dRow - box ; 
24 
endRow = midRow + box ; 
25 
width= 
box*5 + (box+1)%2 ; 
II Adds 1 if box*5 is an even number 
26 
27 
II Draw box top 
28 
placeCursor(screen, 
startRow, 
midCol-widthl2); 
29 
printStars(width); 
30 
31 
II Pr i nt box si des 
32 
for (i nt sideRow = 1; sideRow <= hei ght; 
si deRow++) 
33 
{ placeC ursor (sc reen , startRow 
+ sideRow , mi dCol-widthl2); 
cout << '*' 
<< endl; 
34 
35 
36 
placeC ursor (sc reen , startRow 
+ s i deRow, mi dCol +widthl2); 
cout << '*' 
<< endl; 
37 
} 
38 
II Draw box bottom 
39 
placeCursor(screen, 
endRow, mi dCol-widthl2); 
40 
printStars(w
i dth); 
41 
42 
S1eep(750); 
II Pause 314 second between boxes disp l ayed 
43 
} 
44 
45 
46 
47 } 
48 
placeCursor(screen, 
20 , O); 
ret urn O; 
II Move cursor 
out of the way 
(program continues) 

Program 7-18 
(continued) 
/****************************************************** 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58
} 
59 
60 
61 
62 
63 
64 
65 
* 
pl aceCursor 
* 
******************************************************/ 
void placeCursor(HAND LE screen, 
i nt row, i nt col) 
{ 
II COORD is a defined 
C++ structure 
t hat 
COORD position; 
II holds a pair of X and Y coordi nates 
position.Y 
= row; 
position.
X =col; 
SetConsoleCursorPosition
(s creen , pos itio n); 
/****************************************************** 
* 
pri nt St ars 
* 
******************************************************/ 
void printStars
(int 
numStars) 
{ 
for (i nt star
= 1; st ar<= 
numStars; 
star++ } 
66 
cout << '*'
; 
67 
cout << endl; 
68
} 
Program Output 
*************** 
* *********** 
* 
* * 
***** 
* * 
* * 
* 
* 
* * 
* * 
***** 
* * 
* *********** 
* 
*************** 
Creating a Screen Input Form 
7.16 Screen Control 
489 
Program 7-18 is fun to run, but Program 7-19 demonstrates a more practical application 
of positioning the cursor on the screen. Instead of prompting the user to input a series 
of entries one prompt at a time, we can design a screen input form. This more 
professional -looking way of getting input from the user involves creating and displaying 
a screen that shows all the prompts at once. The cursor is then placed beside a part icular 
prompt the user is expected to respond to . When the user enters the data for this 
prompt and presses [Enter), the cursor moves to the next prompt . 
Program 7-19 
1 II Thi s program crea tes a screen 
form for user i nput . 
2 II from the user. 
3 #include 
<iostream> 
4 #include 
<windows.h> 
5 #include 
<string> 
6 us i ng namespace std; 
7 
II Needed to set cursor 
posi t ions 
(program continues) 

490 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-19 
8 struct 
Userlnfo 
9 { 
10 
11 
12 } ; 
13 
str i ng name; 
int age ; 
char gender ; 
(continued) 
14 voi d placeCursor(HANDLE, int, 
i nt}; 
II Function 
prototypes 
15 voi d di splayPrompts(HANDLE} ; 
16 voi d getUserinput(HANDLE, 
userlnfo&}; 
17 voi d di splayData 
(HANDLE, userlnfo); 
18 
19 int mai n(} 
20 { 
21 
22 
23 
userlnfo 
input; 
II i nput is a Userlnfo 
structure 
II that 
has 3 member variables 
24 
II Get the handle to standard 
output 
dev i ce (the console) 
25 
HANDLE screen= 
GetStdHandle(STD _OUTPUT
_HANDLE); 
26 
27 
di splayPrompts(screen}
; 
28 
getUserinput(screen, 
input); 
29 
di splayData 
(screen, 
input); 
30 
31 
return 
O; 
32
} 
33 
34 
35 
36 
/****************************************************** 
* 
placeCursor 
* 
******************************************************/ 
37 voi d placeCursor(HANDLE screen , i nt row, int col} 
38 { 
II COORD i s a defined 
C++ structure 
that 
39 
COORD position; 
II holds a pair of X and Y coordinates 
40 
pos i tion .Y = row; 
41 
pos i tion .X = col; 
42 
SetConsoleCursorPosition
(scr een , posit i on); 
43
} 
44 
45 /****************************************************** 
46 
* 
displayPrompts 
* 
47 
******************************************************/ 
48 voi d di splayPrompts(HANDLE screen} 
49 { 
50 
placeCursor(screen, 
3, 25); 
51 
52 
53 
54 
55 
56
} 
57 
cout <<"*******Data 
Entry Form*******''<< 
endl; 
placeCursor(screen, 
5, 25); 
cout << "Name: " << endl ; 
placeCursor(screen, 
7, 25); 
cout << "Age: 
Gender (MIF}: " << endl; 
58 /****************************************************** 
59 
* 
getUserinput 
* 
60 
******************************************************/ 
(program continues) 

7.17 Tying It All Together: Yoyo Animation 
491 
Program 7-19 
(continued) 
61 voi d getUserlnput(HANDLE 
screen, 
userlnfo 
&i nput) 
62 { 
63 
64 
65 
66 
67 
68 
69
) 
70 
placeCursor(screen, 
5, 31); 
getline(cin, 
input.name); 
placeCursor(screen, 
7, 30); 
ci n >> input.age; 
placeCursor(screen, 
7, 55); 
cin >> input.gender; 
71 /****************************************************** 
* 
displayData 
* 
72 
73 
******************************************************/ 
74 voi d di splayData
(HANDLE screen , userlnfo 
i nput) 
75 { 
76 
placeCursor(screen, 
10, 0); 
77 
cout << "Here i s the data you entered.
\n"; 
78 
cout << "Name 
"<< 
input.name 
<< endl; 
79 
cout << "Age 
" << input.age 
<< endl; 
80 
cout << "Gender: 
" <<input.gender<< 
endl; 
81 ) 
Initial Screen Display 
******* 
Data Entry Form******* 
Name: 
Age: 
Gender (M/F): 
Program Output with Example Input Shown In Bold 
******* 
Data Entry Form******* 
Name: Mary Beth Jones[Enter] 
Age: 19[Ent er] 
Gender (M/ F) : F[Enter] 
Here is the data you entered. 
Name 
Mary Beth Jones 
Age 
19 
Gender: 
F 
7.17 
~ 
Tying It All Together: Yoyo Animation 
With what you have learned in this chapter you can now create simp le text-based 
graphics. To do that, simp ly arrange characters in different patterns to form images on 
the screen. Then animate those images, giving the illusion of motion, by erasing them 
from their old position and redisplaying them somewhe re else on the screen. To erase a 
character from the screen simply write a blank " " on top of it. 
Program 7-20 uses Windows operating system functions to simulate a yoyo unwinding 
and then winding back up . The Sleep function is used to pause execution between 
moves, so that the user can watch the motion taking place. 

492 
Chapte r 7 
Introduction to Classes and Objects 
Program 7-20 
1 II This program creates 
a simple animation 
using Windows 
2 II functions 
to si mulate a yoyo moving down and up . 
3 #include 
<iostream> 
4 #include 
<windows.h> 
5 us i ng namespace std; 
6 
7 i nt mai n() 
8 { 
II Needed to set cursor 
positions 
9 
HANDLE screen= 
GetStdHandle(STD _OUTPUT
_HANDLE); 
10 
COORD pos = {40 , 3}; 
II Start 
position 
11 
SetConsoleCursorPosition
(scr een , pos); 
12 
cout << "O" << endl ; 
13 
S1eep (500 ); 
14 
15 
II Watch the yoyo go down & back up 3 times 
16 
for (int 
tosslt 
= 1 ; tosslt 
<= 3; tosslt++
) 
17 
{ 
18 
II Yoyo unwi nds 
19 
while 
(pos .Y <= 20) 
II pos .Y is the row 
20 
{ 
21 
22 
23 
24 
25 
26 
27 
28 
29 
II Move the yoyo down 1 position 
and then pause 
SetConsoleCursorPos
i t i on (s creen , pos); 
cout <<"I"<< 
end l; 
pos.Y++; 
SetConsoleCursorPos
i tion(screen, 
pos); 
cout << "O" << end l; 
S1eep (100); 
} 
30 
II Yoyo winds back up 
31 
whi l e (pos.Y > 3) 
32 
{ 
33 
II Erase character 
at current 
pos i tion 
34 
II Move yoyo up one position
, then pause 
35 
SetConsoleCursorPosition(screen, 
pos ); 
36 
cout <<" 
"<< endl ; 
37 
pos.Y -- ; 
38 
SetConsoleCursorPosition(screen, 
pos ); 
39 
cout << "O" << endl ; 
40 
S1eep(100); 
41 
} 
42 
} 
43 
return 
O; 
44 } 
You will need to run the program to see the animation as the yoyo unwinds and then 
winds back up on its string . 
0 

Review Questions and Exercises 
493 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. What does ADT stand for? 
2. Which of the following must a programmer know about an ADT to use it? 
A) What values it can hold 
B) What operations it can perform 
C) How the operations are implemented 
3. The two common programming methods in practice today are ____ 
and 
4. ______ 
programming 
is centered around functions , or procedures, 
whereas ______ 
programming is centered around objects. 
5. An object is a software entity that combines both ____ 
and ____ 
_ 
in a single unit. 
6. An object is a(n) ______ 
of a class. 
7. Creating a class object is often called ______ 
the class. 
8. Once a class is declared, how many objects can be created from it? 
A) 1 
B) 2 
C) Many 
9. An object's data items are stored in its ______________ 
_ 
10. 
11. 
12. 
13. 
The procedures, or functions, an object performs are called its _______ 
_ 
Bundling together an object's data and procedures is called _______ 
_ 
An object's members can be declared publ i c or private . 
A public member can be accessed by _______________ 
_ 
A private member can be accessed by _______________ 
_ 
Normally a class's ______________ 
are declared to be private, 
and its 
are declared to be public. 
14. A class member function that uses, but does not change, the value of a member 
variab le is called a(n) ____ 
_ 
15. A class member function that changes the value of a member variab le is called 
a(n) ____ 
_ 
16. When a member function's body is written inside a class declaration, the function 
is a(n) ____ 
function. 
17. A class constructor is a member function with the same name as the ___ 
_ 
18. A constructor is automatically called when an object is ___ 
_ 
19. Constructors cannot have a(n) ____ 
type. 
20. A(n) ____ 
constructor is one that requires no arguments . 

494 
Chapte r 7 
Introduction to Classes and Objects 
21. A destructor is a member function that is automatically called when an object is 
22. A destructor has the same name as the class but is preceded by a(n) ___ 
_ 
character. 
23. A constructor whose parameters all have default values is a(n) ___ 
constructor. 
24. A class may have more than one constructor, as long as each has a different 
25. A class may only have one default ____ 
and one ___ 
_ 
26. In general, it is considered good practice to have member functions avoid doing 
27. When a member function forms part of the interface through which a client 
program can use the class, the function must be _____ 
_ 
28. When a member function performs a task internal to the class and should not be 
called by a client program, the function should be made ____ 
_ 
29. True or false: A class object can be passed to a function but cannot be returned 
by a function . 
30. True or false: C++ class objects are always passed to functions by reference. 
31. It is considered good programming practice to store the declaration for a class, 
its function definitions, and the client program that uses the class in _____ 
_ 
files. 
32. If you were writing a class declaration for a class named Canine and wanted to 
place it in its own file, what should you name the file? ________ 
_ 
33. If you were writing the definitions for the Canine class member functions and 
wanted to place these in their own file, what should you name the file? 
34. A structure is like a class but normally only contains member variables and no 
35. Bydefault , arethemembersofastructurepublicorprivate? 
________ 
_ 
36. Before a structure variable can be created, the structure must be ______ 
_ 
37. When a structure variab le is created its members can be initialized with either 
a(n) __________ 
or a(n) __________ 
_ 
38. The _____ 
operator is used to access structure members . 
39. An Inventory structure is declared as follows: 
struct 
Inventory 
{ 
} ; 
i nt itemCode; 
i nt qtyOnHand; 
Write a definition statement that creates an Inventory variable named tr i vet 
and initializes it with an initialization list so that its code is 555 and its quantity 
is 110. 

40. A Car structure is declared as follows: 
struc t Car 
{ 
str i ng make, 
model; 
in t 
year; 
doub l e cos t ; 
Review Questions and Exercises 
495 
Car(string 
mk, str i ng md, i nt y, double c) 
{ make= mk; model= 
md; year= 
y; cost= 
c; } 
} ; 
Write a definition statement that defines a Car structure variab le initialized with 
the following information: 
Make: Ford 
Year: 2010 
Mode l: Mustang 
Cost: 
$22,495 
41. Declare a structure named TempSca le, with the following members: 
fahren heit : a double 
cels i us: a double 
Next , declare a structure named Readi ng, with the following members: 
windSpeed: 
an in t 
humidity: 
a doub l e 
tempera tu re: a TempScal e structure variable 
Next , define a Reading structure variable named t oday. 
Now write statements that will store the following data in the Reading variable. 
Wind speed: 37 mph 
Humidity: 32 % 
Fahrenheit temperature: 32 degrees 
Celsius temperature: 0 degrees 
42. Write a function called showReadi ng. It should have a parameter that accepts a 
Readi ng structure variable (see question 41) and should display the values of the 
structure's member variables on the screen . 
43. Write a function called i nput Readi ng that has a parameter to accept a Reading 
structure reference variable (see question 41 ). The function should ask the user 
to enter values for each member of the structure. 
44. Write a function called getRead i ng, which returns a Read i ng structure (see 
question 41 ). The function should ask the user to enter values for each member 
of a Readi ng structure, and then return the structure . 
45. Indicate whether each of the following enumerated data type definitions is valid 
or invalid. If it is invalid, tell what is wrong with it. 
A) enum Holiday { Easter, 
Hal lowee n , Thanksgiving, 
Chris t mas}; 
B) Enum Holiday { Easter, 
Hal lowee n , Thanksgiving, 
Chris t mas }; 
C) enum Holi day { "EASTER", "HALLOWEEN", "THANKSGIVING", "CHRISTMAS" } ; 
D ) enum Holiday { EASTER, HALLOWEEN, THANKSGIVING, CHRISTMAS} 
nextHo l iday; 

496 
Chapte r 7 
Introduction to Classes and Objects 
46. An enumerated data type and several variables have been defined like this: 
enum Department 
{Purc has ing, Manufacturing, 
Warehouse, Sales}; 
Department floor1, 
floor2; 
i nt dNum = 2; 
Indicate whether each of the following statements is valid or invalid. If it is 
invalid, tell what is wrong with it. 
A) fl oor1 = Sales; 
B) dNum = Sales; 
C) dNum = fl oor1 ; 
D) floor2 
= dNum; 
Algorithm Workbench 
47 . Assume a class named Inventory 
keeps track of products in stock for a 
company . It has member variables prod ID, prodDescri pti on, and qtyinStock. 
Write a constructor that initializes a new In ventory object with the values 
passed as arguments, but that also includes a reasonab le defau lt value for 
each parameter. 
48. Write a remove member function that accepts an argument for a number of units 
and removes that number of units of an item from inventory. If the operation is 
completed successfully it should return the number of units remaining in stock for 
that item. However, if the number of units passed to the function is less than the 
number of units in stock, it should not make the removal and should return - 1 as 
an error signal. 
Find the Errors 
Each of the following declarations and program segments has errors . Locate as many 
as you can. 
49. A) struct 
{ i nt x; 
double y; 
} ; 
B) struct 
Values 
{ st ring name; 
i nt age; 
} 
50. A ) struct 
TwoVals 
{ 
i nt a, b; 
} ; 
i nt main() 
{ 
} 
TwoVals.a = 10; 
TwoVals.b = 20; 
return 
O; 

Review Questions and Exercises 
497 
BJ struct 
ThreeVals 
{ 
int a, b , c ; 
void ThreeVals () 
{a= 
1 ; b = 2 ; C = 3;} 
} ; 
int main () 
{ 
} 
ThreeVals 
vals; 
cout << vals << endl; 
return 
O; 
51. AJ struct 
Names 
BJ 
{ string 
first
; 
string 
last ; 
} ; 
int main () 
{ 
} 
Names customer 
("Smith ", "Orley ") ; 
cout <<Names.first<< 
endl ; 
cout <<Names.last<< 
endl ; 
return 
O; 
struct 
TwoVals 
{ 
int a = 5 · ' 
int b = 10 ; 
} ; 
int main () 
{ 
} 
TwoVals v ; 
cout 
<< v.a 
<< '' '' << v.b ; 
return 
O; 
52. AJ class 
Circle: 
{ 
} 
private 
double centerX; 
double centerY; 
double radius ; 
public 
setCenter(double, 
double) ; 
setRadius(double
}; 
BJ Cl ass Moon; 
{ 
} 
Private; 
double earthWeight; 
double moonWeight; 
Public ; 
moonWeight (double ew);// 
Constructor 
{ earthWeight = ew; moonWeight = earthWeight 
/ 6; } 
double getMoonWeight ( ); 
{ return 
moonWeight ; } 

498 
Chapte r 7 
Introduction to Classes and Objects 
i nt main() 
{ 
) 
double eart h ; 
co ut >> "What is your wei ght?"· 
ci n << earth; 
Moon l unar(ear
th ); 
co ut << "On t he moon you would weigh" 
<<l unar.getMoonWeig ht() 
<< end l ; 
return 
O; 
53. A) class 
DumbBell; 
{ 
i nt weight; 
publi c: 
voi d se t Weight( i nt); 
) ; 
void setWeig ht(i nt w) 
{ wei ght = w; 
} 
i nt main() 
{ 
DumBe 11 bar ; 
DumbBell .setWeight(200); 
co ut << "The wei ght is"<< 
bar .weigh t << endl; 
return 
O; 
} 
B) cl ass Change 
{ 
pr i vat e: 
i nt pennies; 
i nt nickels; 
i nt dimes; 
i nt quarters; 
Change() 
{penn i es= 
nicke l s= 
di mes= quar t ers= 
O; } 
Change(int 
p = 100, in t n = 50, d = 50 , q = 25); 
} ; 
void Change: :Change( i nt p, i nt n , d, q) 
{ 
} 
pennies= 
p; 
nicke l s= 
n; 
dimes= 
d; 
quarters= 
q; 
54. If the items on the following list appeared in a problem domain description, 
which would be potential classes? 
Animal 
Medication 
Nurse 
Inoculate 
Operate 
Advertise 
Doctor 
Invoice 
Measure 
Patient 
Client 
Customer 

Programming Challenges 
49 9 
55. Look at the following description of a problem domain: 
The bank offers the following types of accounts to its customers: savings 
accounts, checking accounts, and money market accounts. Customers are 
allowed to deposit money into an account (thereby increasing its balance), 
withdraw money from an account (thereby decreasing its balance), and earn 
interest on the account . Each account has an interest rate. 
Assume that you are writing an application that will calculate the amount of 
interest earned for a bank account. 
A) Identify the potentia l classes in this problem domain. 
B) Refine the list to include only the necessary class or classes for this problem. 
C) Identify the responsibilities of the class or classes. 
Soft Skills 
Working in a team can often help individua ls better understand new ideas related to 
programming. Others can explain things that you do not understand . Also, you will 
find that by explaining something to someone else, you actually understand it 
better. 
56. Write down one question you have about the object -oriented programming 
material from Chapter 7. For example, you could mention something you 
want explained about how classes are designed and created, about how 
objects are related to classes, or about how overloaded constructors work . 
Then form a group with three to four other students. Each person in the group 
should participate in answering the questions posed by the other members of 
the group. 
Programming 
Challenges 
1. Date 
Design a class called Date that has integer data members to store month , day, and year. 
The class should have a three-parameter default constructor that allows the date to be 
set at the time a new Date object is created. If the user creates a Date object without 
passing any arguments, or if any of the values passed are invalid, the default values of 
1, 1, 2001 (i.e., January 1, 2001) should be used. The class shou ld have member 
functions to print the date in the following formats: 
3/15/16 
March 15, 2016 
15 March 2016 
Demonstrate the class by writing a program that uses it. Be sure your program only 
accepts reasonable values for month and day. The month should be between 1 and 12. 
The day should be between 1 and the number of days in the selected month. 

500 
Chapte r 7 
a 
VideoNote 
Solving the 
Car Class 
Problem 
Introduction to Classes and Objects 
2. Report Heading 
Design a class called Heading that has data members to hold the company name and the 
report name. A two-parameter default constructor should allow these to be specified at 
the time a new Heading object is created. If the user creates a Heading object without 
passing any arguments, "ABC Industries" 
should be used as a default value for the 
company name and "Repo rt " should be used as a default for the report name. The class 
should have member functions to print a heading in either one-line format, as shown here: 
Pet Pals 
Payroll 
Report 
or in four-line "boxed" format, as shown here: 
******************************************************** 
Pet Pals 
Payro ll 
Report 
******************************************************** 
Try to figure out a way to center the headings on the screen, based on their lengths. 
Demonstrate the class by writing a simple program that uses it. 
3. Widget Factory 
Design a class for a widget manufacturing plant . Assuming that 10 widgets may be 
produced each hour, the class object will calculate how many days it will take to 
produce any number of widgets. (The plant operates two 8-hour shifts per day.) Write 
a program that asks the user for the number of widgets that have been ordered and 
then displays the number of days it will take to produce them. Think about what 
values your program should accept for the number of widgets ordered . 
4. Car Class 
Write a class named Car that has the following member variables: 
• year. An i nt that holds the car's model year. 
• make. A string 
object that holds the make of the car. 
• speed. An int that holds the car's current speed. 
In addition, the class should have the following member functions. 
• Constructor. 
The constructor should accept the car's year and make as arguments 
and assign these values to the object's year and make member variables. The 
constructor should initialize the speed member variable to 0. 
• Accessors. 
Appropriate accessor functions should be created to allow values to 
be retrieved from an object's year, make, and speed member variables. 
• accelerate. 
The accelerate 
function should add 5 to the speed member 
variable each time it is called. 
• brake. The brake function should subtract 5 from the speed member variable 
each time it is called. 
Demonstrate the class in a program that creates a Car object and then calls the 
accelerate 
function five times. After each call to the accelerate 
function, get the 
current speed of the car and display it. Then, call the brake function five times. After 
each call to the brake function, get the current speed of the car and display it. 

Programming Challenges 
501 
5. Population 
In a population, the birth rate and death rate are calculated as follows: 
Birth Rate = Number of Births + Population 
Death Rate = Number of Deaths + Populat ion 
For example, in a population of 100,000 that has 8,000 births and 6,000 deaths per year, 
Birth Rate= 8,000 + 100,000 = 0.08 
Death Rate= 6,000 + 100,000 = 0.06 
Design a Popu l at ion class that stores a current population, annua l number of births, 
and annual number of deaths for some geographic area. The class should allow these 
three values to be set in either of two ways: by passing arguments to a three-paramete r 
constructor when a new Populat i on object is created or by calling the set Popul at ion, 
s etB i rths, 
and set Deat hs class member functions. In either case, if a popula tion 
figure less than 2 is passed to the class, use a default value of 2. If a birth or death figure 
less than O is passed in, use a default value of 0. The class should also have ge t Bi rth Rat e 
and getDeat hRat e functions that compute and return the birth and death rates. Write 
a short program that uses the Population 
class and illustrates its capabilities. 
6. Gratuity Calculator 
Design a Ti ps class that calculates the gratuity on a restauran t meal. Its only class 
member variable, t axRat e, should be set by a one-paramete r constr uctor to whatever 
rate is passed to it when a Tips object is created. If no argument is passed, a default tax 
rate of .065 should be used. The class should have just one public function, comput eTi p. 
This function needs to accept two arguments, the total bill amount and the tip rate. It 
should use this information to compute what the cost of the meal was before the tax 
was added . It should then apply the tip rate to just the meal cost portion of the bill to 
compute and return the tip amount. Demonstrate the class by creating a program that 
creates a single Ti ps object, then loops multiple times to allow the program user to 
retrieve the correct tip amoun t using various bill totals and desired tip rates. 
7. Inventory Class 
Design an Inv entory class that can hold information for an item in a retail store's 
inventory. The class should have the following private member variables. 
Variable Name 
it emNumber 
quant i t y 
cost 
Description 
An int that holds the item's number. 
An int that holds the quant ity of the item on hand. 
A do ubl e that holds the wholesale per-unit cost of the item 
The class should have the following public member functions. 
Member Function 
default constructor 
constructor #2 
Description 
Sets all the member variables to 0. 
Accepts an item's number, quanti ty, and cost as arguments. Calls 
other class functions to copy these values into the approp riate 
member variables. Then calls the se t Tot al Cost function. 

502 
Chapte r 7 
Introduction to Classes and Objects 
Member Function 
se t l t emNumber 
se t Quantity 
se t Cost 
get l t emNumber 
get Quantity 
get Cost 
get TotalCost 
Description 
Accepts an int 
argument and copies it into the i temNumber 
member variab le. 
Accepts an int argument and copies it into the qua nt ity member 
variable. 
Accepts a double argument and copies it into the cos t member 
variab le. 
Returns the value in i temNumber. 
Returns the value in quantity
. 
Returns the value in cost . 
Computes and returns the to t al Cost . 
Demonstrate the class by writing a simple program that uses it. This program should 
validate the user inputs to ensure that negative values are not accepted for item number, 
quantity, or cost. 
8. Movie Data 
Write a program that uses a structure named Movi eData to store the following 
information about a movie: 
Title 
Director 
Year Released 
Running time (in minutes) 
Include a constructor that allows all four of these member data values to be specified at the 
time a Movi eData variable is created. The program should create two Movi eData variables 
and pass each one in turn to a function that displays the information about the movie in a 
clearly formatted manner. Pass the Movi eData variables to the display function by value. 
9. Movie Profit 
Modify the Movie Data program written for Programming Challenge 8 to include two 
more members that hold the movie's production costs and first-year revenues. The 
constructor should be modified so that all six member values can be specified when a 
Movi eData variable is created . Modify the function that displays the movie data to 
display the title, director, release year, running time, and first year's profit or loss. Also, 
improve the program by having the Movi eData variables passed to the display function 
as constant references. 
10. Corporate Sales Data 
Write a program that uses a structure named CorpData 
to store the following 
information on a company division: 
Division name (such as East, West, North, or South) 
First quarter sales 
Second quarter sales 
Third quarter sales 
Fourth quarter sales 

Programming Challenges 
50 3 
Include a constructor that allows the division name and four quarterly sales amounts 
to be specified at the time a CorpData variab le is created. 
The program should create four CorpData 
variables, each repr esenting one of the 
following corpor ate divisions: East, West, North, and South. These variables should 
be passed one at a time, as constant references, to a function that compu tes the 
division's annua l sales total and quarterly average, and displays these along with the 
division name. 
11. Monthly Budget Screen Form 
A student has established the following monthly budget: 
Housing 
500.00 
Utilities 
150.00 
Household expenses 
65.00 
Transporta tion 
50.00 
Food 
250.00 
Medical 
30.00 
Insurance 
100.00 
Entertainment 
150.00 
Clothing 
75.00 
Miscellaneous 
50.00 
Write a modular program that declares a Monthl yBudget 
structure with member 
variables to hold each of these expense categor ies. The program should create two 
Monthl yBudget structure variab les. The first will hold the budget figures given above. 
The second will hold the user-enter amoun ts actually spent during the past month. 
Using Program 7-19 as a model, the program should create a screen form that displays 
each category name and its budgeted amoun t, then positions the cursor next to it for 
the user to enter the amount actually spent in that category. Once the user data has all 
been entered, the program should compute and display the amoun t over or under 
budget the student's expenditures were in each category, as well as the amount over or 
under budget for the entire month. 
12. Ups and Downs 
Write a program that displays the word UP on the bottom line of the screen a couple of 
inches to the left of center and displays the word DOWN on the top line of the screen 
a couple of inches to the right of center. Moving about once a second, move the word 
UP up a line and the word DOWN down a line until UP disappears at the top of the 
screen and DOWN disappears at the bottom of the screen. 
13. Wrapping Ups and Downs 
Modify the program you wrote for Programming Challenge 12, so that after 
disappearing off of the screen, the word UP reappears at the bottom of the screen and 
the word DOWN reappears at the top of the screen. Have these words each traverse 
the screen three times before the program terminates . 

504 
Chapte r 7 
Introduction to Classes and Objects 
14. Left and Right 
Mod ify the program you wrote for Programming Challenge 12 to display the words 
LEFT (starting at the right -hand side of the screen a row or two down from the middle) 
and RIGHT (starting at the left-hand side of the screen a row or two up from the 
middle). Moving about six moves per second, move LEFT to the left and RIGHT to the 
right until both words disappear off the screen. 
15. Moving Inchworm 
Write a program that displays an inchworm on the left-hand side of the screen, facing right. 
Then slowly move him across the screen, until he disappears off the right-hand side. You 
may wish to do this in a loop so that after disappearing to the right, the worm appears again 
on the left. The diagram below shows how he may look at various points on the screen. 
\ I 
00 
-000000000 
\I 
0 
00 
-0000 
0000 
16. Coin Toss Simulator 
\ I 
000 00 
-000 
000 
\ I 
0 
00 
-0000 
0000 
\ I 
00 
-000000000 
Write a class named Coin. The Coin class should have the following member variable: 
• A string named sideUp. The sideUp member variable will hold either "heads" 
or "tails" indicating the side of the coin that is facing up. 
The Coin class should have the following member functions: 
• A default constructor that random ly determines the side of the coin that is facing 
up ("heads" or "tai ls") and initializes the si deUp member variable accordingly. 
• A void member function named toss that simulates the tossing of the coin. When 
the toss member function is called, it randomly determines the side of the coin that 
is facing up ("heads" or "tails") and sets the sideUp member variable accordingly. 
• A member function named getSideUp that returns the value of the sideUp 
member variab le. 
Write a program that demonstrates the Coin class. The program shou ld create an 
instance of the class and display the side that is initially facing up. Then, use a loop to 
toss the coin 20 times. Each time the coin is tossed, display the side that is facing up. 
The program should keep count of the number of times heads is facing up and the 
number of times tails is facing up, and display those values after the loop finishes. 
17. Tossing Coins for a Dollar 
Create a game program using the Coin class from Programming Challenge 16. The 
program should have three instances of the Coin class: one representing a quarter, one 
representing a dime, and one representing a nickel. 
When the game begins, your starting balance is $0. During each round of the game, the 
program will toss each of the simulated coins. When a tossed coin lands heads-up, the 
value of the coin is added to your balance. For example, if the quarter lands heads-up, 
25 cents is added to your balance. Nothing is added to your balance for coins that land 
tails-up. The game is over when your balance reaches one dollar or more. If your balance 
is exactly one dollar, you win the game. If your balance exceeds one dollar, you lose. 

Programming Challenges 
505 
18. Fishing Game Simulation 
Write a program that simulates a fishing game. In this game, a six-sided die is rolled to 
determine what the user has caught. Each possible item is worth a certain number of fishing 
points. The points will remain hidden until the user is finished fishing, and then a message 
is displayed congratulating the user depending on the number of fishing points gained. 
Here are some suggestions for the game's design: 
• Each round of the game is performed as an iteration of a loop that repeats as long 
as the player wants to fish for more items. 
• At the end of each round, the program will ask the user whether or not he or she 
wants to continue fishing. 
• The program simulates the rolling of a six-sided die 
• Each item that can be caught is represented by a number generated from the 
die- for example, 1 for "a huge fish", 2 for "an old shoe", 3 for "a little fish", 
and so on. 
• Each item the user catches is worth a different number of points. 
• You, the program designer, get to decide what fish or object each number will 
represent and how many points is associated with each "catch" . 
• The loop keeps a running total of the user's fishing points. 
• When the loop is exited, the total number of fishing points is displayed, along 
with a message that varies depending on the number of points earned. 
Group Project 
19. Patient Fees 
This program should be designed and written by a team of students. Here are some 
suggestions: 
• One or more students may work on a single class. 
• The requirements of the program should be analyzed so each student is given 
about the same workload. 
• The names, parameters, and return types of each function and class member 
function should be decided in advance. 
• The program will be best implemented as a multifile program. 
Write a program that comp utes a patient's bill for a hospital stay. The different 
components of the program are 
• The Pat i entAccount 
class will keep a total of the patient's charges. It will also 
keep track of the number of days spent in the hospital. The group must decide on 
the hospital's daily rate. 
• The Surgery class will have stored within it the charges for at least five types of 
surgery. It can update the charges variable of the Pat i entAccount class. 
• The Pharmacy class will have stored within it the price of at least five types of 
medication. It can updat e the charges variable of the Pat i entAccount class. 
• The mai n program. 
The student who designs the main program will design a menu that allows the user to 
enter a type of surgery, enter one or more types of medication, and check the patient 
out of the hospital. When the patient checks out, the total charges should be displayed. 


TOPICS 
8.1 
Arrays Hold Multip le Values 
8.2 
Accessing Array Elements 
8.3 
Inputting and Displaying Array Data 
8.4 
Array Initialization 
8.5 
The Range-Based for loop 
8.6 
Processing Array Contents 
8. 7 
Using Parallel Arrays 
8.8 
The typedef Statement 
8.9 
Arrays as Function Arguments 
8.10 Two -Dimensional Arrays 
8.11 Arrays with Three or More Dimensions 
8.12 Vectors 
8.1 3 Arrays of Objects 
8.14 National Commerce Bank Case Study 
8.15 Tying It All Togethe r: Rock, Paper, 
Scissors 
8.1 
Arrays Hold Multiple Values 
CONCEPT: 
An array allows you to store and work with multiple values of the same 
data type. 
The variables you have worked with so far are designed to hold only one value at a 
time. Each of the variable definitions in Figure 8-1 causes only enough memory to be 
reserved to hold one value of the specified data type. 
Figure 8-1 
int count; 
! 12314 
double price; ! 56.981 
char letter; m 
Enough memory for 1 i n t 
Enough memory for 1 double 
Enough memory for 1 char 
507 

508 
Chapte r 8 
Figure 8-2 
Figure 8-3 
Arrays 
An array works like a variab le that can store a group of values, all of the same type. 
The values are stored together in consecutive memory locations . Here is a definit ion of 
an array of integers: 
i nt hour s[6]; 
The name of this array is hours . The number inside the brackets is the array's size 
declarator. It indicates the number of elements, or values, the array can hold. The 
hours array can store six elements, each one an integer. This is depicted in Figure 8-2. 
hours array: enough memory to hold six i nt values 
t 
t 
t 
t 
t 
t 
Element O Element 1 Element 2 Element 3 Element 4 Element 5 
An array's size declarator must be a constant integer expression with a value greater 
than zero . It can be either a litera l, as in the previous examp le, or a named constant, as 
shown here: 
const i nt SIZE= 6; 
i nt hour s [SIZE]; 
Arrays of any data type can be defined. The following are all valid array definitions: 
f loat t emper at ure[100 ] ; 
char l et t er[ 26]; 
doubl e s ize [1200]; 
stri ng name[10]; 
// Array of 100 floats 
// Array of 26 cha racters 
// Array of 1200 doubles 
// Array of 10 st ring obje ct s 
Memory Requirements 
of Arrays 
The amount of memory used by an array depends on the array's data type and the 
number of elements . The age array, defined here, is an array that holds six shor t 
int values . 
short 
age[6]; 
On a typical PC, a shor t in t uses 2 bytes of memory, so the age array would occupy 
12 bytes. This is shown in Figure 8-3. 
age array: each element uses 2 bytes 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
I 
'-v--1 
'-v--1 
'-v--1 
'-v--1 
'-v--1 
'-v--1 
t 
t 
t 
t 
t 
t 
Element O Element 1 Element 2 Element 3 Element 4 Element 5 

8.2 Accessing Array Elements 
509 
The size of an array can be calculated by multiplying the number of bytes needed to store 
an individual element by the number of elements in the array. Table 8-1 shows the sizes 
of various arrays on a typical system. 
Table 8 -1 Example Ar ray Size Declarato rs 
Array Declaratio n 
Number of Elements 
Size of Each Element 
Size of the Array 
char letter[26]
; 
26 
1 byte 
26 bytes 
short ring[100]
; 
100 
2 bytes 
200 bytes 
i nt mile[84] ; 
84 
4 bytes 
336 bytes 
fl oat temp [ 12]; 
12 
4 bytes 
48 bytes 
double dis t ance[1000 ] ; 
1000 
8 bytes 
8,000 bytes 
a 
VideoNot e 
Accessing 
Array Elements 
Figure 8-4 
<) 
<) 
Accessing Array Elements 
CONCEPT: 
Th e individual elements of an array are assigned uniqu e sub script s. 
Th ese subscripts are used to access the elements. 
Even though an entire array has only one name, the elements may be accessed and used 
as individual variables . This is possible because each element is assigned a number 
known as a subscript. A subscript is used as an index to pinpoint a specific element 
within an array. Th e first element is assigned the subscript 0, the second element is 
assigned 1, and so forth . The six elements in the hours array we defined in the previous 
section would have the subscript s O through 5. This is shown in Figure 8-4. 
Subscripts 
0 
i 
1 
2 
i 
i 
3 
4 
5 
i 
i 
i 
NOTE: 
Subscript numbering in C++ always starts at zero . The subscript of the 
last element in an array is one less than the tota l number of elements in the array. 
This means that in the array shown in Figure 8-4, the element hours[6] does not 
exist. The last element in the array is hours [ 5]. 
Each element in the hours array, when accessed by its subscript, can be used as an int variable. 
Here is an example of a statement that stores the number 20 in the first element of the array: 
hours[O] = 20; 
NOTE: The expression hours[O] is pronounced "hours sub zero." You would read 
this assignment statement as "hours sub zero is assigned twenty." 

510 
Chapte r 8 
Figure 8-5 
0 
Figure 8-6 
0 
Arrays 
Figure 8-5 shows the contents of the hours array after the statement assigns 20 to hours[O]. 
hours[O) 
hours [1) 
hours [2) 
hours[3) 
hours [4) 
hours[S ) 
i 
i 
i 
i 
i 
i 
20 
? 
? 
? 
? 
? 
NOTE: 
Because values have not been assigned to the other elements of the array, 
question marks are used to indicate that the contents of those elements are unknown. 
If an array holding numeric values is defined globally, all of its elements are initialized 
to zero by default. Local arrays, however, have no default initialization value. 
The following statement stores the integer 30 in hours [ 3]. Note that this is the fourth 
array element. 
hours[3 ] = 30 ; 
Figure 8-6 shows the contents of the array after this statement executes. 
hours[O) 
hours [1) 
hours [2) 
hours[3) 
hours [4) 
hours[S ) 
! 
i 
i 
i 
i 
i 
20 
? 
? 
30 
? 
? 
NOTE: 
It is important to und erstand the difference between the array size 
declarator and a subscript. The number inside the brackets in an array definition is 
the size declarator. It specifies how many elements the array holds. The number 
inside the brackets in an assignment statement or any statement that works with the 
contents of an array is a subscript. It specifies which element is being accessed. 
Array elements may receive values with assignment statements just like other variables. 
However, entire arrays may not receive values for all their elements at once. Assume 
the following two arrays have been defined. 
i nt doctorA[5 ]; 
i nt doctorB[5 ]; 
II Hol ds the number of patients 
seen by Dr. A 
II on each of 5 days. 
II Holds the number of pat i ents seen by Dr. B 
II on each of 5 days . 
The following are all legal assignment statements . 
doctorA[O ] 
doctorA[1 ] 
doctorA[2 ] 
doctorB[O ] 
= 
= 
= 
= 
31; 
40; 
doctorA[O ]; 
doctorA[1 ]; 
II doctorA[O ] now holds 31. 
II doctorA[1 ] now holds 40. 
II doctorA[2 ] now also holds 31. 
II doctorB[O ] now holds 40. 

8.3 Inputting and Displaying Array Data 
511 
However, the following statements are not legal. 
doctorA = 152; 
doctors
= doctorA; 
II Illegal! 
An array 
as a whole may not 
II be ass i gned a value. 
Thi s must be done 
II one element at a time, 
us i ng a subscript. 
Inputting and Displaying Array Data 
Array elements may also have information read into them using the ci n object and have 
their values displayed with the cout object, just like regular variables, as long as it is done 
one element at a time. Program 8-1 shows the hours array, discussed in the last section, 
being used to store and display values entered by the user. 
Program 8-1 
1 II Thi s program stores 
employee work hours in an int array. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
const i nt NUM
_EMPLOYEES 
= 6; 
8 
int hours[NUM_EMPLOYEES
] ; 
II Holds hours worked for 6 employees 
9 
10 
II Input the hours worked by each employee 
11 
cout << "Enter the hours worked by " << NUM_EMPLOYEES 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 } 
<< 
" employees: 
". 
' 
cin 
>> hours [OJ ; 
cin 
>> hours[1 ] ; 
cin 
>> hours [2 ] ; 
cin 
>> hours[3 ] ; 
cin 
>> hours[4 ] ; 
cin 
>> hours[5 ] ; 
II Di splay the contents 
of the array 
cout << "The hours you entered 
are:"; 
cout << " " << hours[O] ; 
cout << " " << hours[1]
; 
cout << " " << hours[2]
; 
cout << " " << hours[3]
; 
cout << " " << hours[4]
; 
cout << " " << hours[5] 
<< endl ; 
return 
O; 
Program Output with Example Input Shown in Bold 
Enter the hours worked by 6 employees: 
201240303015[Enter] 
The hours you entered 
are: 
20 12 40 30 30 15 

512 
Chapte r 8 
Arrays 
Figure 8-7 shows the contents of the hours array with the example values entered by 
the user for Program 8-1. 
Figure 8-7 
hours[O) 
hours[ 1) 
hours [2) 
hours[3) 
hours [4) 
hours [S) 
i 
i 
i 
i 
i 
i 
20 
12 
40 
30 
30 
15 
Even though most C++ compilers require the size declarator of an array definition to be a 
constant or a literal, subscript numbers can be stored in variables. This makes it possible 
to use a loop to "cycle through" an entire array, performing the same operation on each 
element. For example, Program 8-1 could be simplified by using two loops: one to input 
the values into the array and another to display the contents of the array. This is shown in 
Program 8-2. 
Program 8-2 
1 II This program stores 
employee work hours in an int array. 
It uses 
2 II one loop to input the hours and another 
loop to display 
them. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
9 
10 
11 
const i nt NUM
_EMPLOYEES 
= 6; 
int hours[NUM_EMPLOYEES
] ; 
int count; 
II Holds hours worked for 6 employees 
II Loop counter 
12 
II Input the hours worked by each employee 
13 
cout << "Enter the hours worked by"<< 
NUM_EMPLOYEES 
14 
<<" 
employees: 
"; 
15 
16 
for (count= 
O; count< 
NUM
_EMPLOYEES; count++) 
17 
cin >> hours[count
] ; 
18 
19 
II Di splay the contents 
of the array 
20 
cout << "The hours you entered 
are:"; 
21 
22 
for (count= 
O; count< 
NUM
_EMPLOYEES; count++) 
23 
cout <<" 
"<< 
hours[count]; 
24 
25 
cout << endl; 
26 
return 
O; 
27 } 
Program Output with Example Input Shown in Bold 
Enter the hours worked by 6 employees: 
201240303015[Enter] 
The hours you entered 
are: 
20 12 40 30 30 15 

8.3 Inputting and Displaying Array Data 
51 3 
Let's look at Program 8-2 more carefully . In line 9, the hours array is defined using the 
named constant NUM
_EMPLOYEES 
as the size declarator. This creates the hours array 
with six elements, hours [ OJ through hours [ 5]. In lines 16 and 17 a for loop is used to 
input a value into each array location. Not ice that count, the loop control variable, is 
also used as the subscript for the hours array . Each time the loop iterates, count will 
have a different value, so a different array element will be accessed. 
Because the for loop initializes count to 0, the first time the loop iterates, the user input 
value is read into hours[O]. The next time the loop iterates, count equals 1, so this time 
the user input value is read into hours [ 1] . This continues until, on the last iteration, count 
equals 5, and the final user input value is read into hours [ 5]. The for loop test condition 
is written so that when count reaches NUM
_EMPLOYEES, 
which equals 6, the loop will stop. 
Th e program's second for loop appears in lines 22 and 23. It works in a similar 
fashion, except that this loop is using cout to display each array element's value, rather 
than cin to read a value into each array element . In line 22 the count variable is 
re-initialized to 0, so the first time the loop iterates, the value stored in hours [ O] is 
displayed. The next time the loop iterates, count equals 1, so this time the value stored 
in hours [ 1] is displayed. This contin ues until, on the final iteration, count equals 5 
and the value stored in hours [5] is displayed. 
Reading Data from a File into an Array 
Sometimes you will need to read data from a file and store it in an array . The process 
is straightforward . Simply open the file. Then use a loop to read each item from the file 
and store it in an array element . Program 8-3 modifies Program 8-2 to do this. Notice 
how the while loop condition on line 23 of Program 8-3 causes the loop to iterate only 
as long as the array is not yet filled and the end of the file has not yet been reached. The 
work . dat file used by Program 8-3, like all data input files used by programs in this 
chapter, is located in the Chapter 8 programs folder on the book's companion website. 
Program 8-3 
1 II Thi s program reads employee work hours from a fi le 
2 II and stores 
them in an int array. 
It uses one loop 
3 II to input the hours and another to display 
them. 
4 #include 
<iostream> 
5 #include 
<fstream> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
11 
12 
13 
14 
15 
const i nt NUM
_EMPLOYEES 
= 6; 
int hours[NUM_EMPLOYEES
] ; 
int count= 
O; 
ifstream 
inputF i le; 
16 
II Open the data file
. 
17 
inputF i le .open("work .dat "); 
II Sets number of employees 
II Holds each employee's 
hours 
II Loop control 
var i able that 
counts 
II how many data i tems have been read in 
II Input file 
stream object 
(program continues) 

514 
Chapte r 8 
Arrays 
Program 8-3 
(continued) 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 } 
if ( ! inputFile) 
cout << "Error opening data f i le\ n"; 
els e 
{ II Read the numbers from the file 
into the array. 
When we exit 
II the loop , count wil l hold the number of items read in. 
while 
(c ount< 
NUM_EMPLOYEES 
&& inputFile 
>> hours[count] 
count ++ ; 
II Close the f i le . 
inputFile.close(); 
II Display the contents 
of the array . 
cout << "The hours worked by each employee are\n"; 
for (i nt employee
= O; employe e< 
count ; employee ++} 
{ 
cout <<"Employee"<< 
employee+1 << "· "; 
} 
} 
cout << hours[employee
] << endl; 
return 
O; 
Program Output 
The hours worked by each employee are 
Employee 1: 20 
Employee 2: 12 
Employee 3: 40 
Employee 4: 30 
Employee 5: 30 
Employee 6: 15 
Notice in Program 8-3 that the contents of the hours array were input and displayed 
one element at a time. The following statements would have been incorrect. 
ci n 
>> hours ; 
I I Incorrect
! 
cout << hours ; 
II Incorrect
! 
inputF i le >> hours; 
II 
Incorrect
! 
Notice also that when we displayed a worker's data in line 33 we used the loop contro l 
variable, employee , as the subscript to access that worker's data in the hours array . 
cout << hours[e mployee ] << endl ; 
However, when we displayed that same worker's number in line 32 we added 1 to the 
value of the loop control variable, like this: 
cout << "Employee " << employee+1 << ": "; 
This is because the data for employee 1 is stored in hours[O J, the data for employee 2 is 
stored in hours [ 1 J, and so forth. 
Writing the Contents of an Array to a File 
Writing the contents of an array to a file is also a straightfo rward matter. First open an 
output file pointed to by an ofstream object, as you learned to do in Chapter 5. Then 
simply use a loop to step through each element of the array and direct the output to the 
file instead of to the computer screen. 

8.3 Inputting and Displaying Array Data 
515 
No Bounds Checking in C++ 
Historically, one of the reasons for C++'s popularity has been the freedom it gives 
programmers to work with the computer 's memory. However, this means that many of 
the safeguards provided by other languages to prevent programs from unsafely 
accessing memory are absent in C++. For example, C++ does not perform array bounds 
checking. This means you could write a program that accidentally allows an array's 
subscript to go beyond its boundaries. This is why line 23 of Program 8-3 tested the 
value of the loop contro l variable to make sure it was less than NUM
_EMPLOYEES, 
which 
was the size of the array, before it allowed the loop to contin ue iterating and reading in 
values. If the program tried to read in all the items in a file that contained more items 
than the array could hold, it could cause serious problems. What exactly occurs 
depends on how your system manages memory. On many systems it causes other 
nearby variables to have their contents overwritten, losing their correct value. On some 
systems it can even cause the computer to crash. 
Program 8-4 demonstrates what occurs on the authors' comp uter when an array 
subscript goes out of bounds. It shows that data stored into one array overwrites the 
data in another array. It also shows, in line 10, how to initialize an array with data 
when it is defined. This technique is discussed further in the following section. 
Program 8-4 
1 II Thi s program unsafely 
stores 
values 
beyond an array ' s boundary. 
2 II What happens depends on how your computer manages memory. 
3 II It MAY overwrite 
other 
memory variables. 
It MAY crash your computer. 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
const i nt SIZE= 3 ; 
10 
int A[SIZE] = {1, 1, 1} ; II Define A as a 3-element 
int array 
11 
// hold i ng the values 
1 , 1, 1 
12 
int B[SIZE] ; 
II Define Bas 
another 
3-element 
i nt array 
13 
14 
15 
16 
17 
18 
II Here is what is stored 
in array A 
cout << "Here are the original 
numbers in 3-element 
array A: 
for (int 
count
= O; count< 
3; count+ +) 
cout << A[count] 
<<" 
"; 
19 
II Attempt to store 
seven numbers i n the 3-element 
array 
20 
cout << "\n\nNow I'm storing 
7 numbers in 3-element 
array 
B." ; 
21 
for (int 
count
= O; count< 
7 ; count+ +) 
22 
B[count ] = 5 ; 
23 
24 
II If the program is st i ll running, 
display 
the numbers 
.. 
25 
cout << "\nif 
you see this 
message, 
the computer did not crash."; 
26 
cout << "\n\nHere 
are the 7 numbers i n array 
B 
"· 
27 
for (int 
count
= O; count< 
7 ; count+ +) 
28 
cout << B[count] 
<<" 
"; 
29 
(program continues) 

51 6 
Chapte r 8 
Arrays 
Program 8-4 
(continued) 
30 
31 
32 
33 
cout << "\nHere are 
for (i nt count
= O; 
the numbers now i n array A: "; 
count< 
3; count+ +) 
cout << A[count] 
<<" ... 
34 
cout << "\n\nArray 
A's values were overwritten 
by \ n" 
35 
<< "the values that 
did not f i t in Array 8.\n"; 
36 
return 
O; 
37
} 
Program Output 
Here are the original 
numbers in 3-element 
array 
A: 
1 
Now I'm storing 
7 numbers in 3-element 
array 8. 
If you see this 
message, the computer did not crash. 
Here are the 7 numbers in array 8 
5 
5 5 5 
5 5 
5 
Here are the numbers now in array 
A: 5 
5 5 
Array A's values were overwritten 
by 
the values that 
did not fit 
in Array 8. 
1 
1 
Let's look more closely at what occurred . Notice that array A started out with the 
values 1, 1, 1, but ended up with the values 5, 5, 5. This occurred because the loop in lines 21 
and 22 of the program stored the value 5 in seven array 8 elements, even though array 8 only 
had enough memory assigned to it to store three values. The rest of the values were stored in 
adjacent memory locations that did not belong to array 8. In this case, some of them belonged 
to array A, so its contents were overwritten and destroyed. Figure 8-8 illustrates this. 
Figure 8-8 
The way the A and B arrays are set up in memory on the authors' computer 
The outlined areas are the arrays 
Memory outside 
the array 
~ 
I 
I f 
8(0) 
t 
8 [ 1 J 
(each block= 4 bytes) 
t i 
8(2) 
Memory outside 
the array 
A[O) 
A[ 1 J 
How the numbers assigned to array B elements overflow the array's boundaries 
Anything previously 
stored here is overwritten 
5 
5 
5 
• 
5 
5 
5 
f 
f 
f 
t 
t 
t 
8(0) 
8 (1 J 
8(2) 
8(3) 
8(4) 
8(5) 
A[2) 
5 
t 
8(6) 

8.3 Inputting and Displaying Array Data 
517 
You can see why it's important to make sure that any time you assign values to array 
elements, the values are written within the array's boundaries. 
Watch for Off-By-One Errors 
When working with arrays, a common type of mistake is the off-by-one error. Thi s is 
an easy mistake to make because array subscripts start at O rather than 1. For example, 
look at the following code: 
// This code has an off-by-one 
error 
const i nt SIZE= 100; 
i nt numbers[SIZEJ ; 
for (int count
= 1; count< = SIZE; count++) 
numbers[count] 
= O; 
The intent of this code is to create an array of integers with 100 elements and store the 
value O in each element . However, this code has an off-by-one error. The loop uses its 
counter variable, count, as a subscript with the numbers array . During the loop's 
execution, the variable count takes on the values 1 through 100, when it should take 
on the values O through 99. As a result, the first element, which is at subscript 0, is 
skipped. In addition, the loop attempts to use 100 as a subscript during the last 
iteration. Because 100 is an invalid subscript , the program will write data beyond the 
array's boundaries . 
~ 
Checkpoint 
8.1 
Define the following arrays: 
A) empNum, a 100 -element array of i nts 
B) pay Rate, a 25-element array of double s 
C) mil es, a 14-element array of longs 
D) stateCapi tal, a SO-element array of string objects . 
E) l i ghtYears, a 1,000-e lement array of doubles 
8.2 
What's wrong with the following array definitions? 
int readings[-1]
; 
double measurements[4 .5 ]; 
int size; 
string 
name[size ] ; 
8.3 
What would the valid subscript values be in a four-element array of doubles? 
8.4 
Assume a program includes the following two statements . They both use square 
brackets, but they mean different things. 
int score[15]
; 
score[6] 
= 45 ; 
A) Which number is the size declarator? 
B) Which number is a subscript? 
8.5 
What is "array bounds checking"? Does C++ perform it? 

518 
Chapter 8 
Arrays 
8.6 
What is the output of the following code? 
i nt values[5], 
count; 
for (count= 
O; count< 
5; count+ +) 
values[count
] =count+ 
1; 
for (count= 
O; count< 
5; count+ +) 
cout << values[count] 
<< endl; 
8. 7 
Comp lete the following program skeleton so it will have a 10-element array of 
int values called fish. When completed, the program should ask how many 
fish were caught by fishermen 1 through 10, and store this information in the 
array . Then it should display the data. 
#include 
<iostream> 
us i ng namespace std; 
int mai n () 
{ 
const 
int NUM
_MEN = 10 ; 
II Define an array 
named fish 
that 
can hold 10 int values. 
II You must finish 
this 
program so it works as 
II described 
above. 
return 
O; 
} 
8.4 
Array Initialization 
CONCEPT: 
Arrays may be initialized when they are defined. 
Sometimes it is more appropriate to set variable values within a program than to input them. 
However, writing separate assignment statements for the individual elements of an array can 
mean a lot of typing, especially for large arrays. For example, consider Program 8-5. 
Program 8-5 
1 II This program displays 
the number of days in each month . 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
const i nt NUM
_MONTHS = 12 ; 
9 
int days(NUM_MONTHS
] ; 
10 
11 
days(O J 
= 31; 
II Ja nuary 
12 
days(1 ] 
= 28; 
II February 
13 
days(2 ] 
= 31; 
II March 
14 
days(3 ] 
= 30; 
II April 
15 
days(4 ] 
= 31; 
II May 
16 
days(5 ] 
= 30; 
II June 
(program continues) 

8.4 Array Initia lization 
519 
Program 8-5 
(continued) 
17 
days[6 J 
= 31; 
II Ju ly 
18 
days [ 7J 
= 31; 
II August 
19 
days[8 J 
= 30; 
II September 
20 
days[9 J 
= 31; 
II October 
21 
days [ 1 OJ = 30; 
II November 
22 
days[11J 
= 31; 
II December 
23 
24 
for (i nt month = O; month< NUM
_MONTHS; month++) 
25 
{ 
26 
cout << "Month " << setw(2) 
<< (month+1) << 
II has ". 
' 
27 
cout << days[month J << " days. \ n" ; 
28 
} 
29 
retu rn O; 
30 } 
Program Output 
Month 1 
Month 2 
Month 3 
Month 4 
Month 5 
Month 6 
Month 7 
Month 8 
Month 9 
Month 10 
Month 11 
Month 12 
Figure 8-9 
has 31 days. 
has 28 days. 
has 31 days. 
has 30 days. 
has 31 days. 
has 30 days. 
has 31 days. 
has 31 days. 
has 30 days. 
has 31 days. 
has 30 days. 
has 31 days. 
Fortunately , there is an alternative . As you saw briefly in Program 8-4, C++ allows you 
to initialize arrays when you define them. By using an initializat ion list, all the elements 
of the array can be easily initialized when the array is created. T he following statement 
defines the days array and initializes it with the same values established by the set of 
assignment statements in Program 8-5: 
int days[NUM_MONTHS
J = {31, 28, 31, 30 , 31, 30, 31, 31 , 30 , 31, 30, 31}; 
T hese values are stored in the array elements in the order they appear in the list. (Th e 
first value, 31, is stored in days [OJ, the second value, 28, is stored in days [ 1 J, and so 
forth.) Figure 8-9 shows the contents of the array after the init ialization . 
Subscripts 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
I 31 I 28 
31 
30 
31 
30 
31 
31 
30 
31 
30 
31 
Program 8-6 is a modification of Program 8-5. It initializes the days array at the time 
it is created rather than by using separate assignment statements . Noti ce that the 
init ialization list is spread across multiple lines. Th e program also adds an array of 
str i ng objects to hold the month names . 

520 
Chapte r 8 
Arrays 
Program 8-6 
1 II Thi s program displays 
the number of days in each month . It uses an 
2 II array of string 
objects 
to hold the month names and an int array 
3 II to hold the number of days in each month . Both are i nitial
i zed with 
4 II in i tialization 
lists 
at the ti me they are created. 
5 #include 
<iostream> 
6 #include 
<iomanip> 
7 #include 
<str i ng> 
8 using namespace std; 
9 
10 int main() 
11 { 
12 
13 
14 
15 
16 
Const i nt NUM
_MONTHS = 12 ; 
string 
name[NUM_MONTHS] = 
{ "January"
1 
"May", 
"Sept ember", 
"February", 
"June", 
"October"! 
"March", 
"July" 
I 
"November", 
"April", 
"August ", 
"December" }; 
17 
18 
int days[NUM_MONTHS
] = {31, 28 , 31, 30, 
19 
31 , 30, 31 , 31 , 
20 
30, 31, 30, 31}; 
21 
22 
for (i nt month = O; month< 
NUM
_MONTHS; month++) 
23 
{ 
24 
cout << setw(9) 
<<left<< 
name [month] <<"has"; 
25 
cout << days[month ] <<" 
days.\n"; 
26 
} 
27 
return 
O; 
28 } 
Program Output 
January 
has 31 days. 
February 
has 28 days. 
March 
has 31 days. 
April 
has 30 days. 
May 
has 31 days. 
June 
has 30 days. 
July 
has 31 days. 
August 
has 31 days. 
September has 30 days. 
October 
has 31 days. 
November has 30 days. 
December 
has 31 days. 
So far we have demonstrated how to fill an array with values and then display all the values. 
Sometimes, however, we want to retrieve one specific value from the array. Program 8-7 is 
a variation of Program 8-6 that displays how many days are in the month the user selects. 
Program 8-7 
1 II Thi s program allows the us er to select 
a month and then 
2 II displays 
how many days are in that 
month . It does this 
3 II by "looking 
up" information 
it has stored 
in arrays. 
4 #include 
<iostream> 
(program continues) 

Program 8-7 
(continued) 
5 #include 
<iomanip> 
6 #include 
<str i ng> 
7 using namespace std ; 
8 
9 int main () 
10 { 
const i nt NUM
_MONTHS = 12 ; 
int choice ; 
string 
name[NUM_MONTHS] = 
8.4 Array Initialization 
521 
11 
12 
13 
14 
15 
16 
17 
{ ''January" , 
''February'' , 
"May", 
"June" 
1 
"September ", "October ", 
"March ", 
II July " I 
"November", 
"Apri l" 1 
"August"! 
"December" } ; 
18 
int days[NUM_MONTHS
] = {31, 28 , 31 , 30 , 
19 
31 , 30 , 31 , 31 , 
20 
30 , 31 , 30, 31} ; 
21 
22 
cout << "This program will 
tell 
you how many days are
• 
23 
<< "in any month. \ n\ n"; 
24 
25 
II Di splay the months 
26 
for (int 
month = 1 ; month< = NUM
_MONTHS; month++) 
27 
cout << setw(2 ) <<month<<• 
• << name[month-1 ] << endl ; 
28 
29 
cout << "\ nEnter the number of the month you want: "; 
30 
cin 
>> choice ; 
31 
32 
II Use the choice the user entered 
to get the name of 
33 
II the month and i ts number of days from the arrays. 
34 
cout << "The month of
• << name[choice-1] 
<<•has 
• 
35 
<< days[choice-1
] 
<< • days. \ n"; 
36 
return 
O; 
37 } 
Program Output with Example Input Shown in Bold 
This program will 
tell 
you how many days are in any month. 
1 January 
2 February 
3 March 
4 April 
5 May 
6 June 
7 July 
8 August 
9 September 
10 October 
11 November 
12 December 
Enter the number of the month you want: 
4[Enter] 
The month of April 
has 30 days. 

522 
Chapte r 8 
Arrays 
Starting with Array Element 1 
Some instructors prefer that you not use array element O and, instead, begin storing the 
actual data in element 1 when you are modeling something in the real world that logically 
begins with 1. The months of the year are a good example . In this case you would declare 
the name and days arrays to each have 13 elements and would initialize them like this: 
string 
name[NUM
_MONTHS+
1] = 
{ "" 
''January ", 
"February"
, "March ", 
"April 
11
1 
"May" 1 
"June" , 
"July"1 
''August ", 
"September" , "October", 
"November" , 
"December" 
} ; 
int days[NUM_MONTHS+
1] = {O, 31, 28 , 31 , 30, 
31, 30 , 31 , 31, 
30, 31 , 30 , 31}; 
Notice that array element O is not used. It just holds a dummy value. This allows the 
name of the first month, Jan uary, to be stored in name [ 1], the name of the second 
month , February, to be stored in name[2], and so on. Likewise, the number of days in 
January is found in days [ 1] , the number of days in February in days [2], and so on . 
Here is what the loop found in lines 22 through 26 of Program 8-6 would look like if 
the arrays were defined and initia lized as we have done here. It displays the contents of 
array elements 1 through 12, instead of elements O through 11 as before . 
for (int month = 1; month< = NUM_MONTHS
; month++) 
{ 
} 
cout << setw(9) <<left<< 
name[month] <<"has"; 
cout << days [month] <<" days .\n"; 
If the actual data is stored beginning with element 1, it is also not necessary to offset 
array subscripts by 1 to locate a particular piece of data . Here is what the loop in lines 
26 and 27 of Program 8-7 that lists each month number with its name would look like: 
for (int month = 1; month< = NUM_MONTHS
; month++) 
cout << setw(2) <<mont h <<" 
"<< name[month] << endl; 
And lines 34 and 35 of Program 8-7 that display the number of days in a month 
selected by the user would look like this: 
cout << "The month of"<< 
name[cho i ce] <<"has" 
<< days(choice
] 
<<" days. \n"; 
Versions of Programs 8-5, 8-6 , and 8-7 that store data values beginning with element 1 
can be found in the Chapter 8 programs folder on the book 's companion website in files 
pr8-058 .cpp, pr8-068.cpp , and pr8-078 .cpp, respectively. 
Partial Array Initialization 
When an array is being initialized , C++ does not require a value for every element . It's 
possible to only initia lize part of an array, like this: 
i nt numbers(? ]= 
{1, 2, 4 , 8}; 
Thi s definition only initi alizes the first four elements of a seven -element array, as 
illustrated in Figure 8-10. 

8.4 Array Initia lization 
523 
Figure 8-10 
int numbers[?] = {1, 2, 4, 8}; 
1 
numbers 
[OJ 
numbers 
[ 1 ] 
numbers 
numbers 
[2 ] 
[3 ] 
Uninitialized elements 
0 
numbers 
[ 4] 
0 
numbers 
[ 5] 
0 
numbers 
[ 6] 
Notice in Figure 8-10 that the uninitialized elements have all been set to zero. Th is is 
what happens when a numeric array is partially initialized. When an array of string 
objects is partially initialized , the uninitialized elements will all contain empty strings, 
that is, strings of length 0. This is true even if the partially initialized array is defined 
locally. If a local array is completely uninitialized , however, its elements will contain 
"garbage," just like othe r loca l variables. Program 8-8 shows the contents of the 
numbers array after it is partially initialized . 
Program 8-8 
1 II Thi s program has a part i al ly initial
i zed array . 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main () 
6 { 
7 
const int SIZE= 7 ; 
8 
int numbers[SIZE] = {1, 
2 , 4, 8} ; // Ini tialize 
the first 
4 elements 
9 
10 
11 
12 
13 
14 
15 } 
cout << "Here are the contents 
of the array:\n"; 
for (in t i ndex= O; index< 
SIZE; index++) 
cout << numbers[index] 
cout << endl ; 
return 
O; 
<< " ". ' 
Program Output 
Here are the contents 
of the array: 
1 
2 
4 
8 
0 
0 
0 
Although an array initialization list can have fewer values than the array has elements, it is 
not allowed to have more values than the array can hold. The following statement would 
be illegal because the numbers array can only hold seven values, but the initialization list 
contains eight values. 
i nt numbers[? ] = {1, 2, 4 , 8, 3 , 5 , 7, 9} ; II NOT legal ! 
Also, if you leave an element uninitialized , you must leave all the element s that follow 
it uninitialized as well. C++ does not provide a way to skip elements in the initialization 
list. Here is another example that is illegal. 
i nt numbers [ 7] = { 1 , , 4, 
, 3 , 5 , 7} ; 
II NOT legal ! 

524 
Chapte r 8 
0 
0 
Arrays 
Implicit Array Sizing 
You can define an array without specifying its size by providing an initialization list that 
includes a value for every element. C++ counts the number of items in the initialization list 
and gives the array that many elements. For example, the following definition creates an 
array with five elements: 
double ra t ings( ] = {1 .0, 1 .5, 2.0, 2.5, 3 .0}; 
NOTE: You must specify an initialization list if you leave out the size declarator. 
Otherwise, C++ doesn't know how large to make the array . 
New Ways to Initialize Variables 
So far you have learned to define and initialize regular variables using the assignment 
operator, as shown here: 
i nt value= 
5; 
However, now that you have worked with functions (Chapter 6), arrays (Chapter 8), 
and possibly classes (Chapter 7), it is time to introduce two addit ional ways to initialize 
variables when you define them . 
The first new way to initialize a variable uses a functional notation. It looks similar to 
the way you pass an argument to a function . If you have already covered Chapter 7, 
you will notice that it also mirrors how you pass a value to a constructor when you 
create a class object. Here is how you would define the value variable and initialize it 
to 5 using the functional notation: 
i nt value(5); 
The second new way to initialize a variable, just introduced in C++ 11, uses a brace 
notat ion. It looks similar to the way you have just seen to initialize an array . However, 
there are two differences. Because a regular variable can only hold one value at a time, 
there will only be one value inside the curly braces. And, unlike an array initialization 
list, there is no= operator before the braces. Here is how you would define the value 
variable and initialize it to 5 using the brace notat ion notat ion: 
i nt value{5}; 
// This only works with C++ 11 or higher. 
Most programmers continue to use the assignment operator to initialize regular variables, 
as we do throughout this book . However, the brace notat ion offers an advantage . It 
checks to make sure the value you are initializing the variable with matches the data type 
of the variable. For example, assume that doubl eVal is a double variable with 6.2 stored 
in it. Using the assignment operator, we can write either of the following statements: 
i nt value1 = 4.9; 
i nt value2 = doubl eVal; 
// Thi s will store 
4 in valu e1 
// Thi s will store 
6 in valu e2 
In both cases, the fractional part of the value will be truncated before it is assigned to 
the variable being defined. This could cause problems, yet C++ compi lers allow it. 
They do issue a warn ing, but they still build an executable file you can run. If the brace 
notation is used, however, the comp iler indicates that these statements produce an 
error, and no executab le is created . You will have to fix the errors and rebu ild the 
project before you can run the program . 

0 
8.5 The Range-Based for Loop 
525 
The Range -Based for Loop 
CONCEPT: 
Th e range-based for loop is a loop that iterates once for each element in 
an array. Each time the loop iterates, it copies an element from the array 
to a variable. Th e range-based for loop was introdu ced in C++ 11. 
C++ 11 provides a specialized version of the for loop that, in many circumstances, 
simplifies array processing . It is known as the range-based for loop . When you use the 
range -based for loop with an array, the loop automatically iterate s once for each 
element in the array . For examp le, if you use the range-based for loop with an eight-
element array, the loop will iterate eight times . Because the range-based for loop 
automatically knows the number of elements in an array, you do not have to use a 
counter variable to control its iterations or have to worry about stepping outside the 
bounds of the array . 
The range -based for loop works with a built-in variable known as the range variable. 
Each time the range -based for loop iterates, it copies the next array element to the 
range variab le. For examp le, the first time the loop iterates, the range variable will 
conta in the value of element 0, the second time the loop iterates, the range variable will 
conta in the value of element 1, and so forth . 
Here is the general format of the range-based for loop: 
for
{d ataType 
rangeVariable 
: array) 
statement
; 
Let's look at the parts of the format more closely. 
• 
data Type is the data type of the range variable . It must be the same as the data 
type of the array elements, or a type that the elements can automatically be 
converted to. 
• 
range Vari ab 7 e is the name of the range variable . This variable will receive the 
value of a different array element during each loop iteration . Durin g the first loop 
iteration, it receives the value of the first element; during the second iteration, it 
receives the value of the second element, and so on . 
• array 
is the name of the array on which you wish the loop to operate. The loop 
will iterate once for every element in the array . 
• 
statement 
is a statement that executes during each loop iteration . To execute 
more than one statement in the loop, enclose the statements in a set of curly 
braces. 
For example, assume that you have the following array definition: 
i nt numbers[]
= {3, 6, 9}; 
You can use a range-based for loop to display the contents of the numbers array like this: 
for (i nt val : numbers) 
{ 
} 
cout << "The next value is"· 
cout <<va l<< 
endl; 

526 
Chapte r 8 
Arrays 
Because the numbers array has three elements, this loop will iterate three times. The 
first time it iterates, the val variable will receive the value in numbers [OJ. Durin g the 
second iteration , val will receive the value in numbers [ 1 J. Durin g the third iteration, 
val will receive the value in numbers [2 ] . Thi s code will produce the following output: 
The next value i s 3 
The next value i s 6 
The next value i s 9 
If you wish, you can use the auto key word to specify the range variable's data type 
instead of specifying it yourself. Here is an examp le: 
for (aut o val 
: numbers ) 
{ 
) 
cout << "The next value 
is
"· 
cout <<va l<< 
endl; 
Program 8-9 uses a range -based for loop to display the elements of a string 
array . 
Program 8-9 
1 // Thi s program demonstrates 
the range-based 
for lo op . 
2 #include 
<iostream> 
3 #include 
<str i ng> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
string 
planets
[] = { "Mercury", 
"Venus", 
"Eart h", "Mars" , 
9 
10 
11 
''Jupiter
", ''Saturn ", "Uranus'' 1 
"Neptune", 
"Pluto 
(a dwarf planet)• 
) ; 
12 
// Di splay the values 
in the array 
13 
cout << "Here are the planets:\n"; 
14 
15 
for 
(str i ng val 
: planets) 
16 
co ut <<val<< 
endl ; 
17 
18 
return 
O; 
19 ) 
Program Output 
Here are the planets: 
Mercury 
Venus 
Earth 
Mars 
Jupiter 
Saturn 
Uranus 
Neptune 
Pluto 
(a dwarf planet
) 

8.5 The Range-Based for Loop 
52 7 
Modifying an Array with a Range-Based for Loop 
As the range -based for loop executes, its range variable conta ins only a copy of an 
array element . As a consequence, you cannot use a range -based for loop to modify the 
contents of an array unless you declare the range variable as a reference. Recall from 
Chapter 6 that a reference variab le is an alias for another value. Any changes made to 
the reference variable are actually made to the value for which it is an alias. 
To declare the range variab le as a reference variable, place an ampersand( &) in front of 
its name in the loop header. Program 8-10 shows an example . It uses a range -based for 
loop to store user input data in an array . 
Program 8-10 
1 II Thi s program uses a range-based 
for 
2 II t o modi fy the conte nt s of an array. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main () 
7 { 
8 
9 
10 
const i nt SIZE= 5 ; 
int numbers[SIZEJ; 
11 
II Get values 
for the array . 
12 
for (i nt &val : numbers) 
13 
{ 
loop 
14 
cout << "Enter an i nteger 
value: 
"; 
15 
ci n >> val; 
16 
} 
17 
II Di splay t he values 
i n the array. 
18 
cout << "\nHere are the values you entered:
\n"; 
19 
20 
for (i nt val : numbers) 
21 
22 
cout <<val<<" 
.. 
' 
23 
cout << endl; 
24 
return 
O; 
25
} 
Program Output with Example Input Shown in Bold 
Enter an integer 
value: 
lO [Ente r] 
Enter an integer 
value: 
20 [Ente r] 
Enter an integer 
value: 
30 [Ente r] 
Enter an integer 
value: 
40 [Ente r] 
Enter an integer 
value: 
SO[Ente r] 
Here are the values you entered: 
10 
20 
30 
40 
50 
Notice that in line 12 the range variab le, val, has an ampersand (&) written in front of 
its name. Thi s declares val as a reference variable. As the loop executes, the val 
variable will not merely contain a copy of an array element, but it will be an alias for 
the element itself. Th erefore, any changes made to the val variable will actually be 
made to the array element it currently references. 

528 
Chapte r 8 
0 
0 
Arrays 
Notice , by cont rast, that in line 20 there is no ampersand written in front of the range 
variable's name . This is because here there is no need to declare val to be a reference 
variable here. This loop is simply displaying the array elements, not changing them. 
The Range-Based for Loop versus the Regular for Loop 
The range-based for loop can be used in any situation where you need to step through 
all the elements of an array, and you do not need to use the element subscripts. It will 
not work, however, in situations where you need the element subscript for some purpose. 
It will also not work if the loop control variable is being used to access elements of two 
or more different arrays. In these situations, you need to use the regular for loop. 
NOTE: You can use the auto key word with a reference range variable. For example, 
the code in lines 12 through 16 in Program 8-10 could have been written like this: 
for (aut o &val : numbers) 
{ 
cout << "Enter an integer 
value: 
"; 
cin 
>> val; 
} 
Processing Array Contents 
CONCEPT: 
Individual array elements are processed like any other type of variab le. 
Processing array elements is no different than processing other variables. For example, 
the following statement multiplies hours[3 ] by the variable rate: 
pay = hours[3 ] • rate; 
And the following are examples of pre-increment and post-increment operations on 
array elements: 
int score[5] 
++score[2]; 
score[4]+ +; 
= { 7 , 8, 9 , 10, 11} ; 
// Pre-increment 
operat io n on the value in score[2 ] 
// Post-increment 
operation on the value in score[4] 
NOTE: When using increment and decrement operators, be careful not to confuse 
the subscript with the array element. The following example illustrates the difference. 
amount[count]--; 
amount[count--]; 
// This decrements the value stored in amount[count ] 
// This decrements the variable 
count , but does 
// nothing to the value stored 
in amount[c ount ] 
Program 8-11 demonstrates the use of array elements in a simple mathematical statement. 
A loop steps through each element of the array, using the elements to calculate the gross pay 
of five employees. 

8.6 Processing Array Contents 
529 
Program 8-11 
1 II Thi s program uses an array to store 
the hours worked by 
2 II a set of empl oyees who al l make the same hourly wage . 
3 #inc l ude <iostream> 
4 #inc l ude <iomanip> 
5 using namespace std ; 
6 
7 int main () 
8 { 
9 
10 
11 
12 
13 
const i nt NUM
_WORKERS 
= 5 ; 
int hours[NUM_WORKERS
] ; 
double payRate ; 
double grossPay ; 
II Set the number of employees 
II Array to hol d each employee ' s hours 
II Hourly pay rate 
for all employees 
II An employee's 
gross 
pay 
14 
II Input hours worked by each empl oyee 
15 
cout << "Enter the hours worked by \ n"; 
16 
for (int worker
= O; worker< 
NUM
_WORKERS; worker+ +) 
17 
{ 
18 
cout << "Employee# " << (worker+1 ) << " · "; 
19 
ci n >> hours[worker
] ; 
20 
} 
21 
22 
II Input the hourly pay rate 
for all 
employees 
23 
cout << "\ nAll these 
employees have the same pay rate.
" 
24 
<< "\ nEnter this 
hourly 
pay rate: 
$"; 
25 
cin 
>> payRate ; 
26 
27 
II Di splay each employee's 
gross 
pay 
28 
cout << "\ nHere is the gross 
pay for each employee: \ n"; 
29 
cout <<fixed<< 
showpoint << setprecision
(2); 
30 
31 
for (int worker
= O; worker< 
NUM
_WORKERS; worker+ +) 
32 
{ 
33 
grossPay 
= hours[worker] 
* payRate; 
34 
cout << "Employee# " << (worker
+ 1) << " · $" 
35 
<< setw(7 ) << grossPay 
<< endl ; 
36 
} 
37 
return 
O; 
38 } 
Program Output with Example Input Shown in Bold 
Enter the hours worked by 
Emp l oy ee #1 : 5 [Enter] 
Employee #2: lO[Enter] 
Employee #3: 15[Enter] 
Emp l oy ee #4 : 20 [Enter] 
Emp l oy ee #5 : 40 [Enter] 
All these 
employees have the same pay rate. 
Enter this 
hourly pay rate: 
$12 .75[Enter] 
Here is the gross 
pay for each employee: 
Employee #1: $ 
63.75 
Employee #2: $ 127.50 
Employee #3: $ 191 .25 
Employee #4: $ 255.00 
Employee #5: $ 510.00 

530 
Chapte r 8 
Arrays 
Array elements can be used in all the same ways regular variables can . You have seen 
how to read in a value and store it in an array element, how to assign a value to an array 
element, and how to display an element's value. 
Array elements can also be used in relational expressions . For example, the following 
if statement tests cost [20] to determine whether it is less than cost [OJ: 
i f (cost[20 ] < cost[O ] ) 
And this line begins a whi le loop that iterates as long as val ue[place] does not equal 0: 
whi l e (value[place] 
!= 0) 
Copying One Array to Another 
We have alread y discussed that you cannot simp ly assign one array to another array. 
To copy the contents of one array to another, you must assign each element of the first 
array, one at a time, to the corresponding element of the second array . The following 
code segment uses a for loop to do this. 
const i nt SIZE= 6; 
int arrayA[SIZE ] = {10, 
int arrayB[SIZE ] = { 2, 
20 , 30, 40, 50, 60) ; 
4 , 
6, 
8, 10, 12); 
for (int 
index = O; index< 
SIZE; i ndex++) 
arrayA[index
] = arrayB[index]; 
On the first iteration of the loop, index = o, so arrayA[O] is assigned the value stored 
in arrayB[O ] . On the second iteration, index = 1, so arrayA[1 ] is assigned the value 
stored in arrayB [ 1] . This contin ues until, one by one, all the elements of arrayB are 
cop ied to arrayA. When the loop is finished executing, both arrays will contain the 
values 2, 4, 6, 8, 10, 12. 
This code can be found in the file ArrayCopy . cpp in the Chapter 8 programs folder on 
the book's companion website . 
Comparing 
Two Arrays 
Just as you cannot copy one array to another with a single statement, you also cannot 
compare the contents of two arrays with a single statement . That is, you cannot use the 
== 
operator with the names of two arrays to determine whether the arrays are equal. The 
following code appears to compare the contents of two arrays but in reality does not . 
int arrayA[] 
= { 5, 10, 15 , 20, 25 } ; 
int arrayB[] 
= { 5, 10, 15 , 20, 25 } ; 
i f (arrayA == arrayB) 
II This i s a mistake 
cout << "The arrays 
are the 
same . \n"; 
el se 
cout << "The arrays 
are not the same . \n"; 
When you use the == 
operator with array names, the operator compares the beginning 
memory addresses of the arrays, not the contents of the arrays. The two arrays in this code 
will obviously have different memory addresses. Therefore, the result of the expression 
arrayA == arrayB is false, and the code reports that the arrays are not the same. 

8.6 Processing Array Contents 
531 
To compare the contents of two arrays, you must compare their individual elements. 
For example, look at the following code . 
const i nt SIZE= 5 ; 
i nt arrayA[SIZE ] = { 5, 10, 15, 20, 25 }; 
i nt arrayB[SIZE ] = { 5, 10, 15, 20, 25 }; 
bool arraysEqual 
= true; 
II Flag variable 
i nt count= 
O; 
II Loop counter 
var i able 
II Det ermine whether the elements 
cont ain t he same data 
whi le (arraysEqual 
&& count< 
SIZE) 
{ 
} 
i f (a rrayA[count] 
!= arrayB[count]) 
arraysEqual 
= false; 
count ++; 
II Displ ay t he appropria te message 
if 
(arraysEqual
) 
cout << "The arrays 
are equal.\n
"; 
else 
cout << "The arrays 
are not equal. \ n"; 
Thi s code determines whether arrayA and arrayB contain the same values. A bool 
variable arraysEqual
, which is initialized 
to true, 
signals whether or not the 
arrays are equal. Another variable cou nt, which is initia lized to 0, is used as a loop 
counter. 
Then a while loop begins . The loop executes as long as arraysEqual 
is t rue and the 
counter variable count is less than SIZE. During each iteration, it compares a different 
pair of corresponding elements in the arrays . If it finds two corresponding elements 
that have different values, the arraysEqual 
variable is set to false, which allows the 
loop to be exited without examining any more values . After the loop finishes, an i f 
statement 
tests the arraysEqual 
variable . If the variab le is still true, 
then no 
differences were found . The arrays are equa l, and a message indicating this is displayed. 
Otherwise, they are not equal, so a different message is displayed . Thi s code can be 
found in the file ArrayCompare. cpp in the Chapter 8 programs folder on the book's 
companion website. 
Summing the Values in a Numeric Array 
To sum the values in an array, you must use a loop with an accumulator variable. The 
loop adds the value in each array element to the accumulator. For example, assume 
that the following statements appear in a program. 
const i nt NUM_UNITS 
= 6; 
i nt units[NUM_UNITS] = {16, 
20 , 14 , 8, 6, 10}; 
i nt total= 
O; 
II Initialize 
accumulator 
The following lines use a regular for loop to add the values of each element in the 
array to the total variab le. When the code is finished, total 
will contain the sum of 
the uni ts array's elements. 
for (i nt count
= O; count< 
NUM_UNITS; count++) 
to t al += units[cou
nt] ; 

532 
Chapte r 8 
0 
0 
Arrays 
In C++ 11 you can also use the range-based for loop to accumulate the total, as shown here. 
for (i nt val : uni ts) 
total 
+=val; 
NOTE: 
Notice that total 
is initialized to 0. Recall from Chapter 5 that an 
accumulator var iable must be set to O before it is used to keep a runn ing tota l; 
otherwise the sum will not be correct . 
Finding the Average of the Values in a Numeric Array 
The first step in calculating the average of all the values in an array is to sum the values. 
The second step is to divide the sum by the number of elements in the array. Assume 
that the following statements appear in a program. 
const i nt NUM
_SCORES = 5; 
double scores[NUM_SCORES] = {90, 88, 91, 82, 95}; 
The following code calculates the average of the values in the scores array and stores 
the result in the average variable. 
double t ot al = O; 
double average; 
// I nitiali
ze accu mula t or 
// Wi ll hold the average 
for (i nt count = O; count < NUM
_SCORES; count++) 
total 
+= scores[cou
nt ]; 
average= 
total 
/ NUM
_SCORES; 
As in the previous example, in C++ 11 a range-based for loop could be used to accumulate 
the total, rather than the regular for loop shown . Regardless of which loop you choose, the 
statement that divides t otal by NUM
_SCORES to find the average should not be inside the 
loop. This statement should only execute once, after the loop has finished all its iterations. 
Finding the Highest and Lowest Values in a Numeric Array 
The algorithms for finding the highest and lowest values in an array are very similar. First, 
let's look at code for finding the highest value in an array . Assume that the following lines 
appear m a program. 
const i nt SIZE= 10; 
i nt numbers[SIZE] = {15, 6, 3, 11 , 22, 4, 0, 1 , 9, 12}; 
The code to find the highest value in the array is as follows. 
i nt count, highest; 
highest= 
numbers[O] ; 
for (cou nt = 1; count < SIZE; count ++) 
{ 
} 
if (numbers[count] 
> highest) 
hi ghes t = numbers[count]; 
First, we copy the value in the first array element to the variable named highes t. Then the 
loop compares all of the remaining array elements, beginning at subscript 1, to the value 
stored in highest. Each time it finds a value in the array that is greater than highest, it copies 
it to highest . When the loop has finished, highes t will contain the highest value in the array. 

8.6 Processing Array Contents 
533 
The following code finds the lowest value in the array. As you can see, it is nearly identical 
to the code for finding the highest value. 
int count; 
i nt lowest; 
lowest= 
numbers[OJ; 
for (count= 
1; count< 
SIZE; count++) 
{ 
) 
if (numbers[count] 
< lowest ) 
lowest= 
numbers[count]; 
When the loop has finished, lowest will contain the lowest value in the array . 
Program 8-12, which creates a monthly sales report, demonstrates the algor ithms for 
finding the sum, average, highest, and lowest values in an array. It comb ines the 
algorithms to find the highest and the lowest value into a single loop . The sales data used 
to fill the array is read in from the sales. dat file, which contains the following values 
62458 
89920 
Program 8-12 
81598 
78960 
98745 53460 
124569 43550 
35678 
45679 
86322 
98750 
1 II Thi s program uses an array to store 
monthly sales 
f i gures 
2 II for a company's regional 
offices. 
It then finds and displays 
3 II the total, 
average , hi ghest, 
and lowest sales 
amounts. 
4 II The data to fill 
the array is read in from a file. 
5 #include 
<iostream> 
6 #include 
<fstream> 
II Needed to use files 
7 #include 
<iomanip> 
8 using namespace std ; 
9 
10 int main() 
11 { 
12 
const i nt NUM
_OFFICES = 
ifstream 
datain; 
int office; 
12; 
II Loop counter 
II Array to hold the sales 
data 
13 
14 
15 
16 
17 
18 
19 
20 
double sales[NUM_OFFICESJ, 
tota1Sales 
= 0.0, 
II Accumulator 
init i alized 
to zero 
averageSales
, 
hi ghestSales, 
lowestSales
; 
21 
II Open the data file 
22 
datain.open("sales.dat"); 
23 
if (!da tain ) 
24 
cout << "Error opening data f i le . \n"; 
25 
else 
26 
{ 
II Fill 
the array with data from the file 
27 
for (of fice
= O; off i ce< 
NUM
_OFFICES; off i ce++) 
28 
datain 
>> sales[office]; 
29 
datain
.close(); 
30 
(program continues) 

534 
Chapte r 8 
Arrays 
Program 8-12 
(continued) 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 } 
} 
II Sum all 
the array 
elements 
for 
(office= 
O; off i ce< 
NUM_OFFICES; off i ce++} 
totalSales 
+= sales[office]; 
II Calculate 
average 
sales 
averageSales 
= totalSales 
I NUM_OFFICES; 
II 
Find highest 
and lowest 
sales 
amounts 
highestSales 
= lowestSales 
= sales[O]; 
for 
(office= 
1 ; off i ce< 
NUM_OFFICES; off i ce++} 
{ 
i f (sales[off
ice ] > highestSales) 
highestSales 
= sales[office]; 
else 
if 
(sales[office] 
< lowestSales) 
lowestSales 
= sales[office
] ; 
} 
II Display 
results 
cout << fixed << showpoi nt << setprec
i sion(2}; 
cout << "Total 
sales 
$" << setw(9} 
<< total Sales 
cout << "Average sales 
$" << setw(9} 
<< averageSales 
cout << "Highest 
sales 
$" << setw(9} 
<< highestSales 
cout << "Lowest sales 
$" << setw(9} 
<< lowestSales 
return 
O; 
<< endl; 
<< endl; 
<< endl; 
<< endl; 
Program Output 
Total 
sales 
$899689.00 
Average sales$ 
74974.08 
Highest 
sales 
$124569.00 
Lowest sales 
$ 35678.00 
Partially Filled Arrays 
Sometimes you need to store a series of items in an array, but you do not know the 
exact number of items. As a result, you do not know the number of elements needed 
for the array . One solution is to make the array large enough to hold the largest possible 
number of items . However, if the actual number of items stored in the array is less than 
the number of elements, the array will be only partially filled. When you process a 
partially filled array, you must on ly process the elements that contain valid data. 
A partially filled array is normally used with an accompanying 
integer variable that 
tells how many items are currently stored in the array. For example, suppose a program 
uses the code shown below to create a 100 -element array and an i nt variable named 
numVal ues which will hold the number of items stored in the array . Notice that 
numVal ues is initialized to zero because no values have been stored in the array yet . 
const 
i nt SIZE= 
100 ; 
int 
array[SIZE]; 
int 
numValues = O; 

8.6 Processing Array Contents 
535 
Each time we add an item to the array, we must increment numValues. The following 
code demonstrates . 
i nt number; 
cout << "Enter a number or -1 to quit: 
"; 
ci n 
>> number; 
whi le (number != - 1 && numValues < SIZE) 
{ 
) 
array[numValues] 
= number; 
numValues+ +; 
cout << "Enter a number or -1 to quit: 
"; 
ci n 
>> number; 
Each iteration of this sentinel -controlled loop allows the user to enter a number to be 
stored in the array, or -1 to quit . After each value is stored in the array, numVal ues is 
incremented to hold the subscript of the next available element in the array . When the 
user enters -1, or when numVal ues exceeds 99, the loop stops . Th e following code 
displays all of the valid items in the array . 
for (i nt index= 
O; index< 
numValues; index++) 
{ 
cout << array[index] 
<< endl ; 
) 
Why Use an Array? 
Program 8-12 stored a set of numbers in an array in order to sum the numbers and find 
the average, largest, and smallest values. However, this could have been done without 
using an array at all. The sales figures could have just been placed one at a time into a 
simp le variable, added to a sum, and compared to the largest and smallest values as 
they were read in. This is illustrated by the following code segment. 
datain 
>> salesAmt; 
// Input the dat a from the first 
off i ce 
tota1Sales 
= highestSales 
= lowestSales = salesAmt; 
for (off ice
= 2 ; office<= 
numOffices; 
office++ ) 
{ 
dat ai n >> salesAmt ; 
to t a1Sales += salesAmt ; 
) 
if (salesA mt > hi ghes t Sales) 
highestSales 
= salesAmt ; 
else 
i f (s alesAmt < lowestSales
) 
lowestSales 
= salesAmt; 
averageSales 
= tota1Sales 
/ numOffic es; 
Then why use an array at all? There are many reasons. One of the most important is that 
once the data is in the array, it can be used more than once without having to be input 
again . For example, suppo se that instead of finding the highest and lowest sales figures we 
want to create a report that tells which offices have below -average sales figures . 
Program 8-13 modifies Program 8-12 to do this. Note that it requires looking at each 
piece of data twice. First, each value is input and summed to find and display the average. 
Then each data value is examined again, so it can be compared to the average, and any 
below-average value can be displayed. 

536 
Chapte r 8 
Arrays 
Program 8-13 also illustrates the use of a partially filled array . It allows the sales array to 
hold up to 20 values and then uses the loop control variable of awhile loop to count the 
actual number of values stored in it as they are read in from the file. The data is read in 
from the same sales . dat file used by Program 8-12. 
Program 8-13 
1 II Thi s program uses a partial
ly -fil
l ed array 
to store 
monthly sales 
2 II figures 
for a set of offices
. It then finds 
and displays 
the total 
3 II sales 
amount , the average 
sales 
amount, and a l i sting 
of the offices 
4 II with sales 
below the average . The data to fi l l the array 
is read 
5 II in from a fi l e and the number of data values 
are counted . 
6 #include 
<iostream> 
7 #include 
<fstream> 
II Needed to use files 
8 #include 
<iomanip> 
9 using namespace std ; 
10 
11 int main() 
12 { 
const i nt SIZE= 20; 
ifstream 
datain
; 
int numOffi ces , 
count; 
II Object to read f i le i nput 
II Number of data values 
read i n 
I I Loop counter 
II Array to hold the sales 
data 
13 
14 
15 
16 
17 
18 
19 
20 
double sales[SIZE
] , 
totalSa
les = 0.0, 
averageSa l es ; 
II Accumulator 
in i t i alized 
to zero 
II Average sales 
for all offices 
21 
II Open the data file 
22 
datain.open
(" sales
.dat "); 
23 
if (!da tain ) 
24 
cout << "Error opening the data f i le . \n"; 
25 
els e 
26 
{ 
II Read values 
from the fi le and store 
them i n the array , 
27 
II counting 
them and summing them as they are read in 
28 
count= 
O; 
29 
while 
(c ount< 
SIZE && datain 
>> sales[count
] ) 
30 
{ totalSales 
+= sales[count
]; 
31 
count ++ ; 
32 
} 
33 
numOffices = count; 
34 
datain
.close(); 
35 
36 
II Calculate 
average 
sales 
37 
averageSales 
= totalSales 
I numOffices; 
38 
39 
II Display total 
and average 
40 
cout <<fixed<< 
showpoint 
<< setprecision(2); 
41 
cout << "The total 
sales 
are 
$" 
42 
<< setw(9 ) << totalSa
les << endl; 
43 
cout << "The average 
sales 
are$" 
44 
<< setw(9 ) << averageSa les << endl; 
45 
46 
II Display 
figures 
for offices 
performing 
below the average 
47 
cout << "\nT he following 
offices 
have below-average 
• 
48 
<< "sa les figures.\n"; 
(program continues) 

8.6 Processing Array Contents 
537 
Program 8-13 
(continued) 
49 
for (i nt off i ce= 
O; office< 
numOffices; office+ +) 
50 
{ i f (sal es[office] 
< averageSales) 
51 
cout <<"Office• 
<< setw(2) << (off ic e+ 1) 
52 
<< • $" << sales[office
] << endl; 
53 
} 
54 
} 
55 
return 
O; 
56 } 
Program Output 
The tota l sales 
are 
$899689.00 
The average sales are$ 
74974.08 
The following 
offices 
have below-average 
sales 
figures. 
Office 
1 $62458.00 
Office 
4 $53460.00 
Office 
5 $35678.00 
Office 10 $43550.00 
Office 11 $45679.00 
Let's look at a couple of key points in Program 8-13. First, look at line 29 . Thi s line 
controls the while loop and reads in the data . 
whi le (count < SIZE && datain 
>> sales[count]) 
The loop repeats as long as count is less than the size of the array and a data value is 
successfully read in from the file (i.e., the end of the file has not been encountered). The 
first part of the while loop's test expression, count < SIZE, prevents the loop from 
writing outside the array boundaries . The second part of the test expression stops the 
loop if there is no more data in the file to read. Recall from Chapter 4 that the && operator 
performs short-circuit evaluation, so the second part of the while loop's test expression, 
datai n >> sales[count], 
will be executed only if count is less than SIZE. The sales 
array defined in line 17 has room to store up to 20 values, but because the data file 
contains only 12 values, the while loop terminates after reading in these 12 items. 
Notice how count, the loop contro l variable, serves two purposes in addition to controlling 
execution of the loop. Because it is initialized to zero and is incremented on line 31 once 
each time the loop iterates, it keeps count of which array position the next item read should 
be stored in, correctly allowing the 12 values from the sales.dat 
file to be stored in array 
positions O through 11. It also keeps count of how many values are read in. When the loop 
terminated in our sample run, count was 12, which equaled the number of items read in. 
We said that using an array is particularly helpful when data values need to be looked at more 
than once. That is exactly what happens in Program 8-13. The statement in line 30 adds each 
piece of stored data to a total it is accumulating of all the values. This total is later used in line 
37 to compute an average. Then, inside the for loop on lines 49 through 53, each stored data 
item is again examined to compare it to the average and to display it if it is below the average 
As you continue to program you will encounter many additional algorithms that 
require examin ing data values more than once and you will discover many cases where 
arrays are a particularly useful way to organize and store data. 

538 
Chapte r 8 
Figure 8-11 
0 
Arrays 
Processing Strings 
Strings are internally stored as arrays of characte rs. They are different from other 
arrays in that the elements can either be treated as a set of individua l characters or can 
be used as a single entity . The following sample code defines a string object and treats 
it as a single entity, inputting it and displaying it as a single unit . 
string 
name; 
cout << "Enter your name: "; 
cin 
>> name; 
cout << "Hello, 
"<<name<< 
endl ; 
This is, in fact, how strings are normally treated and processed- as single entities. However, 
C++ provides the ability to index them with a subscript, like an array, so they can be 
processed character by character. If "Warren" were entered for the name in the previous 
code segment, it would be stored in the name string object as shown in Figure 8-11. 
·w· 
'a' 
, r' 
name 
name 
name 
[ 0 ] 
[ 1 ] 
[ 2 ] 
, r, 
name 
[3] 
'e' 
name 
[4] 
'n, 
name 
[5] 
NOTE: 
Both string 
objects and C-strings are stored as characters in contig uous 
bytes of memory, as shown in Figure 8-11. String literals and C-strings are terminated 
by placing a ' \ O ', which represents the null terminator, in the byte of memory following 
the last character of the string. There is no guarantee, however, of how str i ng objects 
will be implemented . Man y versions of C++ do terminate string objects with the null 
terminator, but it is never safe to assume they will be terminated this way. 
If we wanted to process the string characte r by character, like a regular array, we could 
do so. For examp le, the statement 
cout << name[OJ; 
cout << name[1]; 
would print 
the letter 
W, 
would print 
the letter 
a , and so fort h 
Program 8-14 illustrates character -by-character string processing . It reads in a string 
and then counts the number of vowels in the string. The str i ng class member function 
length is used to determine how many characters are in the string. 
Program 8-14 
1 II This program i llustr
ates 
how a str i ng can be processed 
as an array 
2 II of ind i vid ual characters. 
It reads in a string, 
then counts the 
3 II number of vowels i n the string. 
It uses the toupper 
function 
to 
4 II uppercase 
each letter 
in the str i ng and the str i ng class 
function 
5 II length( ) to determine 
how many characters 
are in the string
. 
6 #include 
<iostream> 
7 #include 
<str i ng> 
8 #include 
<cctype> 
9 using namespace std ; 
II Needed to use string 
objects 
II Needed for the toupper 
function 
(program continues) 

Program 8-14 
10 
11 int main () 
12 { 
13 
char ch ; 
(continued) 
14 
int vowelCount = O; 
15 
string 
sentence
; 
16 
17 
cout << "Enter any se nt ence you wish and I wil l \ n" 
18 
<< "t ell you how many vowels are i n it . \ n"; 
19 
getl i ne(ci n , sentence
); 
20 
21 
for (i nt pos = O; pos < sentence.
leng th (); pos++) 
22 
{ 
8.7 Using Parallel Arrays 
539 
23 
II Uppercase a copy of t he next character 
and assign 
it to ch 
24 
ch = toupper(sentence[pos]); 
25 
26 
II 
If the character 
i s a vowel, incremen t vowelCount 
27 
switc h(ch) 
28 
{ case 'A' : 
29 
30 
31 
32 
case 'E': 
case 'I': 
case 'O': 
case 'U': 
vowelCount ++; 
33 
} 
34 
} 
35 
cout << "There are"<< 
vowelCount <<" 
vowels i n the sentence.
\ n"; 
36 
return 
O; 
37
} 
Program Output with Example Input Shown in Bold 
Enter any sentence 
you wish and I will 
te ll you how many vowels are in it. 
The quick brown fox Jumped over the lazy dog . [Enter] 
There are 12 vowels in the sentence. 
Additional examp les of string processing are introduced in Chapter 12. 
Using Parallel Arrays 
CONCEPT: 
By using the same subscript, you can build relationships between data 
stored in nvo or more arr ays. 
Sometimes it is useful to store related data in two or more arrays . It's especially useful 
when the related data is of different data types. We did this in Programs 8-6 and 8-7, 
where the name array stored the names of the 12 months and the days array stored the 
number of days in a given month. A month name and its number of days were related by 
having the same subscript . For examp le, days [ 3] stored the number of days in the month 
whose name was stored in mont h [ 3] . 

540 
Chap ter 8 
Arrays 
Wh en data items stored in two or more arra ys are related in this fashion, the array s are 
called parallel arrays. Program 8-15, which is a variati on of the payroll progra m, uses 
para llel arra ys. An int arr ay stores the hours worked by each empl oyee, and a double 
arra y stores each empl oyee's hourly pay rat e. 
Program 8-15 
1 II Thi s program stores 
employee hours worked 
2 II and hourly pay rates 
i n two paral l el arrays
. 
3 #inc l ude <iostream> 
4 #inc l ude <iomanip> 
5 using namespace std ; 
6 
7 int main () 
8 { 
9 
10 
11 
12 
13 
const i nt NUM
_EMPS = 5 ; 
int hours[NUM_EMPSJ; 
double payRate [NUM
_EMPS] ; 
double grossPay ; 
14 
II Get employee work data 
II Define 2 paral l el arrays 
15 
cout << "Enter the hours worked and hour l y pay rates 
of
" 
16 
<< NUM
_EMPS << " empl oyees . \ n"; 
17 
18 
for (int 
index
= O; index< 
NUM
_EMPS; i ndex ++) 
19 
{ 
20 
21 
22 
23 
cout 
ci n 
cout 
ci n 
<< "\ nHours worked by empl oyee #" << (index + 1 ) << " · " ; 
>> hours[ i ndex ]; 
24 
} 
<< "Hourl y pay rate 
for th i s empl oyee : $"; 
>> payRate[ i ndex ]; 
25 
II Display 
each employee's 
gross 
pay 
26 
cout << "\ nHere is the gross 
pay for each employee: \ n" ; 
27 
cout <<fixed<< 
showpoi nt << setprecision
(2); 
28 
29 
for (int 
index
= O; index< 
NUM
_EMPS; index ++) 
30 
{ 
31 
grossPay 
= hours[index] 
* payRate[index]
; 
32 
cout << "Employee# " << (index+ 
1); 
33 
cout << ": $" << setw (7) << grossPay 
<< end l; 
34 
} 
35 
return 
O; 
36 } 
Program Output with Example Input Shown in Bold 
Enter the hours worked and hourly pay rates 
of 5 employees. 
Hours worked by employee #1: lO[Enter] 
Hourly pay rate 
for this 
employee: $9 .7S[Enter] 
Hours worked by employee #2: lS[Enter] 
Hourly pay rate 
for this 
employee: $8.6S[Ent er] 
(program output continues) 

Program 8-15 
(continued) 
Hours worked by employee #3: 20[Ent er] 
Hourly pay ra t e for t his employee : $10 .SO[Ent er] 
Hours worked by employee #4: 40[Ent er] 
Hourly pay ra t e for t his employee : $18 .SO[Ent er] 
Hours worked by employee #5: 40[Ent er] 
Hourly pay ra t e for t his employee : $15 .00[Ent er] 
Here i s the gros s pay for each employee: 
Employee #1 : $ 
97.50 
Employee #2: $ 129.75 
Employee #3: $ 210.00 
Employee #4: $ 740.00 
Employee #5: $ 600.00 
8.7 Using Parallel Arrays 
541 
Notice in the loops that the same subscript is used to access both arrays. That's because 
the data for a particular employee is stored in the same relative position in each array. 
For examp le, the hours worked by employee #1 are stored in hours[OJ , and the same 
empl oyee's pay rate is stored in payRat e [OJ. The subscript relates the data in both 
arra ys. This concept is illustrat ed in Figure 8-12. 
Figure 8-12 
10 
15 
20 
40 
40 
hours[O] 
hours[1J 
hours[2J 
hours[3] 
hours[4J 
t 
t 
t 
t 
t 
Employee Employee Employee Employee Employee 
#1 
#2 
#3 
#4 
#5 
! 
! 
! 
! 
! 
9.75 
8.62 
10.50 
18. 75 
15.65 
payRate [O] payRate (1 J payRate[2J payRate [3] payRate (4J 
~ 
Checkpoint 
8.8 
Define the following arrays: 
A) ages, a 10-element arra y of i nt s initialized with the values 5, 7, 9, 14, 15, 
17, 18, 19, 21, and 23 
B) te mps, a 7-element array of doubl es initialized with the values 14.7, 16.3, 
18.4 3, 21.09, 17.9, 18.76, and 26.7 
C) al pha, an 8-element array of cha rs initialized with the values 'J', 'B', 'L', 
'A' "" '$' 'H' and 'M' 
' ' ' 
' 
8.9 
Indicate if each of the following array definition s is valid or invalid. (If a definition 
is invalid, explain why.) 
A) i nt numbers[ 10] = {O, 0, 1, 0 , 0, 1, 0, 0 , 1, 1}; 
B) i nt mat rix[5 ] = {1, 2, 3 , 4 , 5 , 6 , 7} ; 

542 
Chapte r 8 
Arrays 
C) double radii [10] = {3 .2 , 4.7}; 
D ) int table[?] 
= {2, , , 27, , 45, 39}; 
E) 
F) 
G) 
char codes[]= 
int blanks[]; 
{ 'A' 
'X' 
'1' 
' 2 ' 
's'}
· 
1 
I 
I 
1 
I 
string 
suit[4] 
= {"Clubs", 
"Diamonds", 
8.10 
Given the following array definitions: 
double array1[4] 
= {1 .2, 3 .2 , 4.2, 
5.2}; 
double array2[4]
; 
will the following statement work? If not, why? 
array2 
= array1 ; 
8.11 
Given the following array definition: 
int values [ J = { 2 , 6, 10, 14} ; 
what do each of the following display? 
A) cout << values[2
] ; 
B) cout << ++values [OJ ; 
C) cout << values[1
]++; 
D ) x = 2 ; 
cout << values[++x ] ; 
8.12 
Given the following array definition: 
int nums [ 5 J = { 1 , 2 , 3} ; 
what will the following statement display? 
cout << nums[3] ; 
8.13 
What is the output of the following code? 
"Hearts", 
"Spades"} ; 
double balance[5] 
= {100 .0, 250.0 , 325.0 , 500.0, 
1100.0}; 
const double INT_RATE = 0.1; 
cout <<fixed<< 
showpoint << setprecision(2); 
for (int 
count
= O; count< 
5 ; count+ +) 
cout << (balance[count] 
* INT_RATE) << endl ; 
8.14 
What is the output of the following code? 
const i nt SIZE 5 ; 
i nt count; 
int time[SIZEJ 
= 
speed[SIZEJ 
= 
dist[SIZEJ
; 
{1, 
2 , 3, 4, 5} , 
{18, 4, 27, 52, 100} , 
for (count= 
O; count< 
SIZE; count ++) 
dis t[count] 
= time[count] 
* speed[count]; 
for (count= 
O; count< 
SIZE; count ++) 
{ 
) 
cout << time[count] 
<<" 
"; 
cout << speed[count] 
<<" 
"; 
cout << dist[count
] << endl ; 

8.9 
a 
VideoNot e 
Passing an 
Array to a 
Function 
8.9 Arrays as Function Arguments 
543 
The typedef 
Statement 
CONCEPT
: The typedef statement allows an alias to be associated with a simple or 
structured data type. 
The typedef statement allows the programmer to create an alias, or synonym, for an 
existing data type. Th is can be a simple data type, such as an int , or a more complicated 
data type, such as an array . The simplest form of the statement is 
typedef 
<exist i ng data type> <alias>; 
For example, the following statements declare examScore to be anot her name for an 
int and then define two variables of type examScore. 
typedef 
int examScore ; 
examScore score1 , score2; 
// score 1 and score2 are of type examScore 
The declaration emphasizes that variables of type exa mScore are integers that will hold 
exam scores. 
One of the most common uses of the typedef statement is to provide a descriptive alias 
for an array of a specific purpose . When used with arrays, the [ J holding the array size 
is written next to the alias name , not next to the data type name. Th e following 
statement creates an alias named score for a double array of size 100. 
typedef 
doubl e score[100]; 
Th is means that anything defined to be a score is an array of 100 double elements 
intended to hold scores. The following two statements now do the same thing. 
double fina1Exam[100]; 
score fina l Exam; 
Sometimes it is desirable to create an alias for an array of a specific data type witho ut 
specifying its size. Th e following statement creates an alias, named arrayType for an 
int array of unspecified size. 
typedef 
i nt arrayType[J; 
In the next section, when you learn how to pass arrays as function arguments, it will 
become apparent why it is convenient to set up a typedef for an array type. 
Arrays as Function Arguments 
CONCEPT: 
Individual elements of arrays and entire arrays can both be passed as 
arguments to functions. 
Quite often you' ll want to write functions that process the data in arrays . For example, 
functions can be written to put values in an array, display an array's contents on the 
screen, total all of an array's elements, or calculate their average . Usually , such 
functions accept an array as an argument . 

544 
Chapte r 8 
Arrays 
When a single element of an array is passed to a function, it is handled like any other 
variable . For example, Program 8-16 shows a loop that passes one element of the 
co 11 ect ion array to the showVa l ue function each time the loop is executed. Because 
the elements of the co 11 ect ion array are i nts, a single int value is passed to the 
showVal ue function each time it is called. Not ice how this is specified in the showVal ue 
function prototype and function header. All showVa l ue knows is that it is receiving an 
int . It does not matter that it happens to be coming from an array . 
Program 8-16 
1 II This program demonstrates 
that 
an array element 
2 II can be passed to a function 
like any other variable. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 void showValue(int); 
II Function 
prototype 
7 
8 int main() 
9 { 
10 
const i nt ARRAY
_SIZE = 8; 
11 
int collection[ARRAY _SIZEJ = {5, 10, 15, 20, 25, 30, 35, 40}; 
12 
13 
for (int 
index= 
O; index< 
ARRAY
_SIZE; index++) 
14 
showValue(collection[index]); 
15 
cout << endl; 
16 
return 
O; 
17 
} 
18 
19 /************************************** 
20 
* 
showValue 
* 
21 
* This funct i on di splays 
the integer* 
22 
* value passed to its 
num parameter. 
* 
23 
**************************************/ 
24 void showValue(int 
num) 
25 { 
26 
cout << num <<" 
"· 
27
} 
Program Output 
5 10 15 20 25 30 35 40 
Because the showVal ue function simply displays the contents of num and doesn't need 
to work directly with the array elements themselves, the array elements are passed to it 
by value . If the function needed to access the original array elements, they would be 
passed by reference . 
If the function were written to accept the entire array as an argument, the parameter 
wou ld be set up differently . In the following function definition, the parameter nums is 
followed by an empty set of brackets. This indicates that the argument will be an entire 
array, not a single value. 

8.9 Arrays as Function Arguments 
545 
voi d showValues 
(i nt nums[] , int 
size) 
{ 
) 
for (i nt index= 
O; i ndex< 
si ze; index++) 
cout << nums[index] 
<< • •· 
cout << endl ; 
Notice that along with the array contain ing the values, the size of the array is also 
passed to showVal ues. Thi s is so it will know how many values there are to process. 
Notice also that there is no size declarator inside the brackets of nums. This is because 
nums is not actually an array - it's a special variable that accepts the address of an array. 
When an entire array is passed to a function, it is not passed by value. Imagine the CPU 
time and memory that would be necessary if a copy of a 10,000 -element array were 
created each time it was passed to a function! Instead, only the starting memory address of 
the array is passed. Thi s is similar to passing a variable to a function by reference, except 
that in this case no & is used. Program 8-17 illustrates how function showValues receives 
the address of an entire array so it can access and display the contents of all its elements . 
Program 8-17 
1 II Thi s program shows how to pass an entire 
array 
to a function. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 void showValues(int 
i ntArray(], 
int 
si ze ); 
II Function 
prototype 
6 
7 int main() 
8 { 
9 
const 
int ARRAY
_SIZE = 8; 
10 
i nt collection[ARRAY _SIZE] = {5, 10, 15, 20 , 25, 30, 35, 40} ; 
11 
12 
cout << "The array 
contains 
the values\n"; 
13 
showValues(collection
, ARRAY
_SIZE); 
14 
return 
O; 
15 } 
16 
17 /************************************************************* 
18 
* 
showValues 
* 
19 
* Thi s funct i on di splays 
the contents 
of an integer 
array 
* 
20 
* when passed the array's 
address 
and i ts size 
as arguments.* 
21 
*************************************************************/ 
22 void showValues (i nt nums[ ] , int size) 
23 { 
24 
25 
26 
< size ; index ++) 
for 
(int 
index= 
O; index 
cout << nums[index ] << • 
cout << endl ; 
27
} 
Program Output 
The array 
contains 
the values 
5 
10 
15 
20 
25 
30 
35 
40 
.. 

546 
Chapte r 8 
Figure 8-13 
Arrays 
Look closely at the s howVa l ues prototype in line 5 and function header in line 22. In 
both cases a pair of braces follows the first parameter name. This lets the program 
know that this parameter accepts the address of an array . If the function prototype had 
not used parameter names, it would have looked like this: 
vo i d showValues(i
nt 
[ ] , in t ); 
This would still have indicated that the first showVal ues parameter receives the address 
of an integer array and the second parameter receives a single integer value. 
Look also at how the showVal ues function is called in line 13 of the program with the 
following statement: 
showValues(collection, 
ARRAY_SIZE); 
The first argument is the name of the array being passed to the function . Remember, in 
C++ the name of an array without brackets and a subscript is actually the beginning 
address of the array . In this function call, the address of the co 11 ec t i on array is being 
passed to the function . The second argument is the size of the array. 
In the s howVa l ues function, the beginning address of the co 11 ect io n array is copied 
into the nums parameter variable. The nums variab le is then used to reference the 
co 11 ec t i on array. Figure 8-13 illustrates the relationship between the co 11 ect ion 
array and the nums parameter variable. When nums(O) is displayed, it is actually the 
contents of co 11 ect ion [ O] that appears on the screen. 
co 11 ect ion array of eight integers 
5 
20 
25 
30 
35 
40 
l 
nums[O] 
nums[1] 
nums[2] 
... and so forth 
references 
references 
references 
collection[O] 
collection[1] 
collection[2] 
0 
NOTE: 
Although nums is not a reference variable, it works like one. 
The nums parameter variable in the showVal ues function can accept the address of any 
integer array and can use it to reference that array . So, we can use the showVal ues 
function to display the contents of any integer array by passing the name of the array 
and its size as arguments . Program 8-18 uses this function to display the contents of 
two different arrays . Not ice that they do not have to be the same size. Notice also the 
use of the typedef 
statement in this program . It makes the name array
Type an alias for 
an array of integers. This name is then used in the showVal ues prototype and function 
header, instead of using in t [ ] , to indicate that the first parameter receives the starting 
address of an i nt array. 

8.9 Arrays as Function Arguments 
54 7 
Program 8 -18 
1 II This program demonstrates 
passing different 
arrays 
to a function
. 
2 #include 
<iostream> 
3 usi ng namespace std; 
4 
5 II Declare arrayType to be an al i as for an array of ints 
6 typedef int arrayType[]; 
7 
8 voi d showValues(arrayType
, int); 
II Function prototype 
9 
10 int mai n() 
11 { 
12 
const int SIZE1 = 8; 
13 
const int SIZE2 = 5; 
14 
int set1[] 
= {5, 10, 15, 20, 25, 30, 35, 40} ; 
15 
int set2[] 
= {2, 4, 6, 8, 10}; 
16 
17 
cout << "Here are the values stored 
in array set1: 
"; 
18 
showValues(set1, 
SIZE1); 
II Pass set 1 to showValues 
19 
20 
21 
22 
23 } 
24 
cout << "Here are the values 
showValues(set2, 
SIZE2); 
return 
O; 
stored 
in array set2: 
"; 
II Pass set 2 to showValues 
25 /************************************************************* 
26 
* 
showValues 
* 
27 
* This funct i on displays 
the contents 
of an integer 
array 
* 
28 
* when passed the array's 
address and its size as arguments.* 
29 
*************************************************************/ 
30 voi d showValues (arrayType nums, int size ) 
31 { 
32 
33 
34 
35 } 
for (int 
index= 
O; index 
cout << nums[index] << 
cout << endl ; 
< si ze; index++) 
It 
II• 
Program Output 
Here are the values stored 
in array set1: 
5 10 15 20 25 30 35 40 
Here are the values stored 
in array set2: 
2 4 6 8 10 
Notice that when set1 and set2 are declared in lines 14 and 15, no size declarator is 
used. We could have used one, but recall that a size declarator is not required when an 
initialization list is used. 
Recall also, from Chapter 6, that when a reference variable is used as a parameter, it 
gives the function access to the original argument. Any changes made to the reference 
variable are actually performed on the argument referenced by the variable. Array 
parameters work very much like reference variables. They give the function direct access 
to the original array. Any changes made to the array parameter are actually made to the 
original array used as the argument. The function doubleArray in Program 8-19 uses 
this capability to double the contents of each element in the array. 

548 
Chapte r 8 
Arrays 
Program 8-19 
1 II Thi s program uses a function 
to double the value of 
2 II each element of an array . 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Declare 
arrayType 
to be an alias 
for an array 
of i nts 
7 typedef 
int arrayType[
] ; 
8 
9 II Function 
prototypes 
10 void doubleArray
(array Type , int); 
11 void showValues (array Type , int); 
12 
13 int main() 
14 { 
15 
const i nt ARRAY
_SIZE = 7; 
16 
arrayType 
set= 
{1, 2 , 3, 4, 5 , 6, 7}; 
17 
18 
II Display 
the or i ginal 
values 
19 
cout << "The arrays 
values 
are:\n"; 
20 
showValues(set
, ARRAY
_SIZE) ; 
21 
22 
II Double the values 
i n the array 
23 
doubleArray(set, 
ARRAY
_SIZE); 
24 
25 
II Display 
the new values 
26 
cout << "\nAfter 
call i ng doubleArray, 
the values 
are: \n"; 
27 
showValues(set
, ARRAY
_SIZE) ; 
28 
cout << endl; 
29 
return 
O; 
30
} 
31 
32 /*************************************************** 
33 
34 
35 
36 
* 
doubleArray 
* 
* Thi s funct i on doubles 
the value of each element* 
* in the array whose address 
is passed to it. 
* 
***************************************************/ 
37 void doubleArray
(array Type nums, i nt size) 
38 { 
39 
for (int 
index= 
O; index< 
size ; i ndex ++) 
40 
nums[i ndex] *= 2 ; 
41 } 
42 
43 /********************************************************* 
44 
* 
showValues 
* 
45 
* Thi s funct i on di splays 
the contents 
of an int array 
* 
46 
* when passed the array's 
address 
and size as arguments.* 
47 
*********************************************************/ 
void showValues (array Type nums, int 
48 
49 
50 
51 
52 
53
} 
{ 
for (int 
index= 
O; index 
cout << nums[index ] << 
cout << endl; 
< size ; 
II 
II• 
' 
size) 
index ++) 
(program continues) 

8.9 Arrays as Function Arguments 
549 
Program 8-19 
(continued) 
Program Output 
The array values are: 
1 2 3 4 5 6 7 
After calling 
doubleArray, 
the values are: 
2 4 6 8 10 12 14 
0 
Notice that in line 16 of Program 8-19 the set array is defined to be type arrayType 
rather than int set [] or i nt set [ARRAY
_SIZE], although it could also be defined in 
either of these ways. As in Program 8-18, it is not necessary to indicate the size of the 
array because it is initialized with an initialization list at the time it is created . 
Notice also that in the typedef statement in line 7, the showVal ues prototype in line 11, 
and the showVa l ues function header in line 48, there is no &. Remember, when you pass 
an array to a function you do not use an &. 
NOTE: In C++ when a regular variable is passed to a function and an & precedes 
its name, it means that the function is receiving a reference to the memory address 
where a variable is stored . An array name, however, is already a memory address . 
That is, instead of holding a value, it holds the starting address of where the array is 
located in memory . Ther efore, an & should not be used with it. 
Using const Array Parameters 
Sometimes you want a function to be able to modify the contents of an array that is 
passed to it as an argument, but other times you don't . In Program 8-19, for example, 
we needed the doubleArray function to be able to change the values in the array, but 
we did not want the showVa l ues function to change them. You can prevent a function 
that should not change an array passed to it from accidentally making changes to it by 
using the const key word. Here is what the showVal ues prototype and function header 
would look like with a const array parameter: 
void showValues(const 
arrayType, 
i nt) 
void showValues(const 
arrayType nums, i nt size) 
// Function prototype 
// Function header 
Nothing in the call to the function or in the function code changes when you use a 
const array parameter. On ly the function prototype and header are affected. When an 
array parameter is declared as cons t , the function is not allowed to make changes to 
the array's contents . If a statement in the function attempts to modify the array, an 
error will occur at comp ile time. As a precaution, it is a good idea to always use a 
con st array parameter in any function that is not intended to modify its array argument. 
Some Useful Array Functions 
Section 8.6 introduced you to algorithms such as summing an array and finding the highest 
and lowest values in an array. Now we can write general-purpose functions that perform 
these operat ions. Program 8-20, which is a modification of Program 8-12, uses the 
functions sumArray, getHighes t , and getlowest . Because none of these functions should 
make changes to the array, they all have const array parameters . 

550 
Chapte r 8 
Arrays 
Program 8-20 
1 II Thi s program passes 
an array 
filled 
with sales 
data 
2 II to functions 
which find and return 
its 
total
, hi ghest , 
3 II and lowest values. 
The functions 
should not change the 
4 II array , so they each use a const array 
parameter. 
5 #include 
<iostream> 
6 #include 
<iomanip> 
7 using namespace std ; 
8 
9 II Function 
prototypes 
10 double sumArray 
(const double[]
, int); 
11 double getH i ghest(const 
double[]
, int); 
12 double getlowest 
(co nst double[]
, int); 
13 
14 int main() 
15 { 
16 
17 
18 
const i nt NUM
_DAYS = 5; 
double sales[NUM_DAYS] , 
total
, 
19 
average , 
20 
highest, 
21 
lowest; 
22 
23 
II Get the sales 
data 
II Number of 
II 
Holds the 
II 
Holds the 
II 
Holds the 
II 
Holds the 
II 
Holds the 
days 
daily 
sales 
amounts 
week's total 
sales 
average da i ly sales 
highest 
daily 
sales 
lowest daily 
sales 
24 
cout << "Enter the sales 
for this 
week.\n"; 
25 
for (int 
day= 
O; day< 
NUM
_DAYS; day ++) 
26 
{ cout <<"Day"<< 
(day+1) <<: "· 
27 
ci n >> sales[day]
; 
28 
} 
29 
30 
II Get total 
sales 
and compute average 
sales 
31 
total 
= sumArray(sales, 
NUM
_DAYS); 
32 
average
= total 
I NUM_DAYS; 
33 
34 
II Get hi ghest and lowest sales 
amounts 
35 
highest= 
getHighest(sales, 
NUM
_DAYS); 
36 
lowest= 
getlowest(sales, 
NUM
_DAYS); 
37 
38 
II Di splay results 
39 
cout <<fixed<< 
showpoi nt << setprecision(2) 
<< endl; 
40 
cout << "The total 
sales 
are 
$" 
41 
<< setw(9) 
<< total 
<< endl; 
42 
cout << "The average 
sales 
amount i s$" 
43 
<< setw(9) 
<<average<< 
endl; 
44 
cout << "The highest 
sales 
amount is$" 
45 
<< setw(9) 
<<highest<< 
endl; 
46 
cout << "The lowest sales 
amount is 
$" 
47 
<< setw(9) 
<< lowest 
<< endl; 
48 
return 
O; 
49 } 
50 
51 /****************************************************** 
52 
53 
54 
55 
* 
sumArray 
* 
* Thi s funct i on computes and returns 
the sum of the 
* 
* values 
in the array whose address 
is passed to i t. 
* 
******************************************************/ 
(program continues) 

Program 8-20 
(continued) 
56 double sumArray (const double array(
] , int size ) 
57 { 
58 
double total 
= 0.0 ; 
II Accumulator 
59 
60 
for (int 
count
= O; count< 
size ; count++ ) 
61 
total 
+= array(count
] ; 
62 
return 
total
; 
63 ) 
64 
8.9 Arrays as Function Arguments 
551 
65 / ****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * 
66 
* 
getHighest 
67 
* Thi s funct i on finds 
and returns 
the largest 
value 
68 
* in the array whose address 
is passed to it. 
• 
• 
• 
69 
****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * */ 
70 double getHighest
(const double array(
] , int size ) 
71 { 
72 
double highest
= array(O]
; 
73 
74 
for (int 
count
= 1 ; count< 
size ; count ++) 
75 
{ 
if (array(count] 
> hi ghest ) 
76 
highest
= array(count]; 
77 
} 
78 
return 
hi ghest ; 
79 } 
80 
81 / ****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * 
82 
83 
84 
85 
* 
get Lowest 
* 
* Thi s funct i on finds 
and returns 
the smallest 
value
* 
* in the array whose address 
is passed to it. 
• 
****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * */ 
86 double getlowest
(const double array(]
, i nt size ) 
87 { 
88 
double lowest
= array(O ] ; 
89 
90 
for (int 
count
= 1 ; count< 
size ; count ++) 
91 
{ 
if (array(count] 
< lowest ) 
92 
lowest= 
array(count]
; 
93 
} 
94 
return 
lowest; 
95 } 
Program Output with Example Input Shown in Bold 
Enter the sales 
for this 
Day 1 : 2698 .72[Ent er] 
Day 2: 
3757 .29[Ent er] 
Day 3: 
1109 .67[Ent er] 
Day 4: 2498 .65[Ent er] 
Day 5: 
1489 .87[Ent er] 
The total 
sales 
are 
The average 
sales 
amount 
The highest 
sales 
amount 
The lowest sales 
amount 
week. 
$ 11554.20 
is$ 
2310.84 
is$ 
3757.29 
is $ 
1109.67 

552 
Chapte r 8 
Arrays 
~ 
Checkpoint 
8.15 
Write a typedef statement that makes the name Tenints an alias for an array 
that holds 10 integers. 
8.16 
When an array name is passed to a function, what is actually being passed? 
8.17 
What is the output of the following program segments? (You may need to consult 
the ASCII table in Appendix A.) 
// Function 
prototypes 
voi d f i llArray(char 
[ ] , int) 
voi d showArray(const 
char[], 
i nt) 
int mai n () 
{ 
char prodCode[8] 
= { 'O', 
'O' 
I 
'O'' 
'O' 
'O' 
'O' 
'O' 
'O'}· 
1 
I 
I 
1 
I 
} 
f i llArray(prodCode,8); 
showArray(prodCode,8); 
return 
O; 
// Defi nit ion of function 
fillArray 
// 
(Hint : 65 is the ASCII code for 'A'.} 
voi d f i llArray(char 
arr[], 
int siz e} 
{ char code= 
65; 
for (i nt k = O; k < size; 
code++, 
k++ ) 
arr[k] 
= code; 
} 
// Defi nit ion of function 
showArray 
voi d showArray(const 
char codes[ ] , int size) 
{ 
for (int k = O; k < size; 
k++) 
cout << codes[k ] ; 
} 
8.18 
The following program segments, when completed, will ask the user to enter 10 
integers, which are stored in an array . The function avgArray, which you must 
write, should calculate and return the average of the numbers entered . 
// Write the avgArray function 
prototype 
here. 
// It should have a const array 
parameter
. 
int mai n() 
{ 
} 
const 
int SIZE= 10; 
int userNums[SIZE]; 
cout << "Enter 
10 i ntegers: 
"; 
for (i nt count= 
O; count< 
SIZE; count++) 
{ 
} 
cout << "#" << (count
+ 1) 
cin 
>> userNums[count]; 
<< 
II 
It• 
' 
cout << "The average 
of those 
numbers is"; 
cout << avgArray(userNums, 
SIZE)<< 
endl; 
return 
O; 
// Write the avgArray function 
here . 

a 
VideoNot e 
Two-
Dimensional 
Arrays 
8.10 Two-Dimensiona l Arrays 
553 
Two-Dimensional 
Arrays 
CONCEPT
: A two-dimensional arr ay is like several identical arrays put togeth er. It is 
useful for storin g multipl e sets of data. 
An array is useful for storing and working with a set of data. Sometimes, though, it's 
necessary to wor k with multiple sets of data . For example, in a grade -averaging program 
a teacher might record all of one student's test scores in an array of doub 1 es. If the teacher 
has 30 students, that means 30 arrays of double s will be needed to record the scores for 
the entire class. Instead of defining 30 individual arrays, however, it wou ld be better to 
define a two -dimens ional array. 
The arrays that you have studied so far are called one-dimensional arrays because they can 
only hold one set of data. Two-dimensional arrays, which are also called 2D arrays, can 
hold multiple sets of data . It's best to think of a two-dimens ional array as a table having rows 
and columns of elements, as shown in Figure 8-14. This figure shows an array of test scores 
that has three rows and four columns . Notice that the three rows are numbered O thro ugh 2 
and the four columns are numbered O through 3. There are a total of 12 elements in the array. 
Figure 8-14 
RowO 
Row 1 
Row2 
Column 0 
score [OJ [OJ 
score [ 1 J [OJ 
score [2J [OJ 
Column 1 
score[O J [1J 
score[1 J [1J 
score[2 J [1J 
Column 2 
Column 3 
score[O J [2J 
score[OJ [3J 
score[1 J [2J 
score[1J[3J 
score[2 J [2J 
score[2J [3J 
To define a two -dimensional array, two size declarato rs are required . The first one is for 
the number of rows, and the second one is for the number of columns . Here is an examp le 
definition of a two -dimens ional array with three rows and four columns: 
double score[3 J [4J ; 
I 
I 
I 
I 
Rows Columns 
Notice that each number is enclosed in its own set of brackets . 
For process ing the information 
in a two -dimensional 
array, each element has two 
subscripts, one for its row and another for its column . In the sc or e array, the elements 
in row O are referenced as 
score[O] [OJ 
score[0][1] 
score[O] [2] 
score[O] [3] 
T he elements in row 1 are 
score[ 1][0] 
score[ 1][1] 
score[ 1][ 2] 
score[ 1] [3] 

554 
Chapte r 8 
Arrays 
And the elements in row 2 are 
score[2] [OJ 
score[2][1] 
score[2] [2] 
score[2] [3] 
The subscripted references are used in a program just like the references to elements in 
a one -dimensiona l array . For example, the following statement assigns the value 92.25 
to the element at row 2, column 1 of the score array: 
score[2][1] 
= 92.25; 
And the following statement displays the element at row 0, column 2: 
cout << score[0 ] [2]; 
Programs that cycle through each element of a two-dimensional array usually do so with 
nested loops . Program 8-21 shows an example . 
Program 8-21 
1 // This program uses a two-dimensional 
array . The 
2 // data stored 
in the array 
is read in from a file. 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 #include 
<iomanip> 
6 using namespace std; 
7 
8 int main() 
9 { 
10 
11 
12 
13 
14 
15 
16 
const i nt NUM
_DIVS = 3: 
const i nt NUM
_QTRS = 4: 
double sales[NUM_DIVS] [NUM_QTRS]; 
double tota1Sa les = O; 
int div, 
qtr; 
ifstream 
inputFile; 
17 
inputF i le .open("sales2
.dat"); 
18 
if (!i nputFi le) 
// Number of divisions 
// Number of quarters 
// 20 array with 3 rows & 4 columns 
// Accumulates 
total 
sales 
// Loop counters 
// Used to read data from a file 
19 
cout << "Error 
opening data f i le . \n"; 
20 
else 
21 
{ 
22 
cout <<fixed<< 
showpoint 
<< setprecision(2); 
23 
cout << "Quarterly 
Sales by Di vis i on\n\n"; 
24 
25 
// Nested loops are used to f i ll the array wi th quarterly 
26 
// sales 
figures 
for each di vi si on and to display 
the data 
27 
for (div= 
O; div< 
NUM
_DIVS; div+ +) 
28 
{ for (qtr = O; qtr < NUM
_QTRS; qtr ++) 
29 
{ 
30 
31 
32 
33 
34 
35 
36 
37 
} 
cout <<"D i vi s i on" 
<<(div+ 
1) 
<< ''
1 Quarter''<< 
(qtr + 1) << "· 
$"; 
inputFile 
>> sales[div][qtr
] ; 
cout << sales[div][qtr] 
<< endl; 
cout << endl; 
// Print 
blank l ine 
} 
inputFile.close(); 
(program continues) 

Program 8-21 
38 
(continued) 
39 
II Nested loops are used to add all 
the elements 
40 
for (div= 
O; div< 
NUM
_DIVS; di v++) 
41 
{ for 
(qtr 
= O; qtr < NUM
_QTRS; qtr++) 
42 
tota1Sales 
+= sales[divJ[qtr
J ; 
43 
} 
44 
II Display 
the total 
45 
cout << "The total 
sales 
for the company are:$"; 
46 
cout << tota1Sa les << endl; 
47 
} 
48 
return 
O; 
49 } 
Program Output 
Quarterly 
Sales 
by Division 
Division 
1 ' Quarter 
1 : $31569.45 
Division 
1 ' Quarter 
2: $29654.23 
Division 
1 ' Quarter 
3: $32982.5 4 
Division 
1 ' Quarter 
4 : $39651 .21 
Division 
2, Quarter 
1 : $56321 .02 
Division 
2, Quarter 
2: $54128.63 
Division 
2, Quarter 
3: $41235.85 
Division 
2, Quarter 
4 : $54652.33 
Division 
3, Quarter 
1 : $29654.35 
Division 
3, Quarter 
2: $28963.32 
Division 
3, Quarter 
3: $25353.55 
Division 
3, Quarter 
4 : $326 15.88 
The tota l sales 
for the company are: 
$456782.34 
8.10 Two-Dimensiona l Arrays 
555 
As with one-dimensional arrays, two-dimensional arrays can be initialized when they 
are created . When initializing a two-dimensional array, it helps to enclose each row's 
initialization list in a set of braces. Here is an example: 
in t hours[3][2J 
= {{8, 5} , {7, 9}, {6, 3}}; 
The same statement could also be written as 
in t hours[3J[2J 
= {{8, 5} , 
{7, 
9} , 
{6, 
3}}; 
In either case, the values are assigned to hours in the following manner: 
hours[OJ (OJ is set to 8 
hours[OJ[1J 
is set to 5 
hours[1J[OJ 
is set to 7 
hours[1J[1J 
is set to 9 
hours[2J (OJ is set to 6 
hours[2J[1J 
is set to 3 

556 
Chapte r 8 
Figure 8-15 
Arrays 
Figure 8-15 illustrates the initialization . 
RowO 
Row 1 
Row2 
Column 0 
8 
7 
6 
Column 1 
5 
9 
3 
The extra braces that enclose each row's initiali zation list are optiona l. Both of the 
following statements perform the same initialization: 
i nt hours[3][2J 
= {{8, 5}, {7, 9}, {6, 3}}; 
i nt hours[3 J[2J = {8, 5, 7 , 9, 6, 3}; 
Because the extra braces visually separate each row, however, it's a good idea to use 
them. In add ition, the braces give you the ability to leave out initializers within a row 
without omittin g the initializers for the rows that follow it. For instance, look at the 
following array definition: 
i nt table[3][2J 
= {{1}, 
{3, 4}, 
{5}}; 
tab le [OJ [OJ is initialized to 1, table [ 1 J [OJ is initialized to 3, table [1 J [ 1 J is initialized 
to 4, and table[2J 
[OJ is initia lized to 5. Th e uninitialized elements (in this case 
tab le[OJ [1 J and table[2
J [1 J) are automatically set to zero. 
Passing Two-Dimensional 
Arrays to Functions 
Program 8-22 illustrates how to pass a two -dimensional array to a function. When a 
two -dimensional array is passed to a function, the parameter type must contain a size 
declarator for the number of columns . C++ needs this information to correct ly translate 
a subscr ipted array reference, such as table[2
J [1 J, to the address in memory where that 
element is stored . Here is the header for the function showArray, from Program 8-22: 
voi d showArray(const 
i nt array[J[NUM _COLSJ, int numRows) 
The showArray function can accept any two-dimensional integer array, as long as it has four 
columns . In Program 8-22, the contents of two separate arrays are displayed by this function. 
Program 8-22 
1 // This program demonstrates 
how to pass 
2 // a two-dimensional 
array to a funct i on . 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std; 
6 
7 const int NUM_COLS = 4; 
8 const int TBL1_ROWS 
= 3; 
9 const int TBL2_ROWS 
= 4; 
// Number of columns i n each array 
// Number of rows in table1 
// Number of rows in table2 
10 
11 void showArray(const 
int 
[ J [NUM_COLSJ, i nt}; 
// Function 
prototype 
12 
(program continues) 

Program 8-22 
13 int main() 
14 { 
(continued) 
15 
int table1[TBL1 _ROWS][NUM
_COLS] = { {1, 
16 
{5, 
17 
{9, 
2 , 
3, 
6, 
7, 
10, 11 , 
18 
19 
20 
21 
22 
23 
int table2[TBL2 _ROWS] [NUM_COLS] = { { 10 , 
{ 50, 
{ 90, 
{130, 
24 
cout << "The contents 
of table1 
are:\n"; 
25 
showArray(table1, 
TBL1_ROWS); 
26 
cout << "\nThe contents 
of table2 
are:\n"; 
27 
showArray (t able2 , TBL2_ROWS); 
28 
return 
O; 
29 } 
30 
20 , 
60, 
100, 
140, 
8.10 Two-Dimensiona l Arrays 
557 
4}, 
8}, 
12} } ; 
30, 
70, 
110, 
150, 
40}, 
80}, 
120}, 
160} }; 
31 /**************************************************************** 
32 
33 
34 
35 
36 
37 
* 
showArray 
* 
* This function 
displays 
the contents 
of a 2-D integer 
array. 
* 
* Its first 
parameter 
receives 
the address 
of the array, 
which* 
* has NUM_COLS 
columns. The second parameter 
receives 
the 
* 
* number of rows in the array. 
* 
****************************************************************/ 
38 void showArray(int 
const array[][NUM_COLS], int numRows} 
39 { 
40 
for (int 
row= O; row< numRows; row++) 
41 
{ 
for (i nt col= 
O; col< 
NUM_COLS; col++ ) 
42 
{ 
43 
cout << setw(5} << array[row][col] 
<< " "· 
44 
} 
45 
cout << endl ; 
46 
} 
47 } 
Program Output 
The contents 
of table1 
are: 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
The contents 
of table2 
are: 
10 
20 
30 
40 
50 
60 
70 
80 
90 
100 
110 
120 
130 
140 
150 
160 
C++ requires the columns to be specified in the function prototype and header because 
of the way two-dimensional arrays are stored in memory. One row actually follows 
another, as shown in Figure 8-16. 

558 
Chapte r 8 
Figure 8-16 
Arrays 
i 
i 
i 
i 
row 1 
row 2 
row3 
When the compi ler generates code for accessing the elements of a two-dimens ional 
array, it needs to know how many bytes separate the rows in memory. The number of 
columns is a critical factor in this calculation . 
This required column information can also be provided with a typedef statement. 
Here is how a typedef declaration for a two-dimensional array might look: 
typedef i nt intTable[
] [4]; 
This statement makes i ntTable an alias for a two-dimensional array with any number 
of rows and four columns. If this typedef statement had been included in Program 8-22, 
the prototype for the showArray function could then have been written as 
voi d showArray (i ntTable, 
int); 
and its function header could have been written as 
voi d showArray (i ntTable array , int numRows) 
Summing All the Elements of a Two-Dimensional 
Array 
In Program 8-21 we summed all the data in a two-dimensional array by using a nested 
loop and adding the contents of each array element to an accumulator. You will recall 
that the code to sum the array elements looked like this: 
for (di v= 
O; div< 
NUM
_DIVS; div++ ) 
{ for (qtr = O; qtr < NUM
_QTRS; qtr+ +) 
tota1Sales 
+= sales[div][qtr
] ; 
) 
NUM
_DIVS was the number of rows in the array . NUM
_QTRS was the number of columns. 
The outer loop iterates once for each row in the array, and the inner loop iterates once 
for each column in the row . 
Summing the Rows of a Two-Dimensional 
Array 
Sometimes, however, you need to calculate separately the sum of each row in a two-
dimensional array. For examp le, suppose a two-dimensiona l array is used to hold a 
set of test scores for a group of students. Each row in the array is a set of scores for 
one student . To sum the scores for each student, you again use a pair of nested loops. 
The inner loop is used to add all the scores in a row, that is, all the scores for one 
student . The outer loop is executed once for each student. But now the accumulator 
must be set back to O for each row, before you begin accumulatin g its values. Also, the 
sum of the row needs to be stored somew here or displayed before beginning a new 
row. Here is an example. 

8.10 Two-Dimensiona l Arrays 
559 
const i nt NUM_STUDENTS = 3; 
const i nt NUM_SCORES = 5; 
double total
; 
II Number of students 
II Number of test 
scores 
II Accumulator 
double average; 
II Holds a given student's 
average 
double scores[NUM_STUDENTS][NUM
_SCORES] = {{88, 97, 79, 86, 94}, 
{86, 91, 78 , 79 , 84}, 
{82, 73, 77 , 82 , 89}}; 
II Sum each student's 
test 
scores 
so his or her 
II average 
can be calculated 
and displayed 
for (i nt row= O; row< NUM
_STUDENTS; row++) 
{ 
} 
II Reset accumulator 
to O for this 
student 
total 
= O; 
II Sum a row 
for (i nt col= 
O; col< 
NUM
_SCORES; col++) 
total 
+= scores[row][col
] ; 
II Compute and di splay the average 
for this 
student 
average= 
total 
I NUM
_SCORES; 
cout << "Score average 
for student" 
<<(row+ 
1) <<"is"<< 
average<< 
endl; 
Summing the Columns of a Two-Dimensional 
Array 
Sometimes you may need to calculate the sum of each column in a two-dimensional array. 
Using the array of test scores from the previous example, suppose you wish to calculate 
the class average for each of the tests, rather than for each student. To do this, you must 
calculate the average of each column in the array . As in the previous example, this is 
accomplished with a set of nested loops . However, now the order of the two loops is 
reversed. The inner loop is used to add all the scores in a column, that is, all the scores for 
one test. The outer loop is executed once for each test. The following code illustrates this. 
const i nt NUM_STUDENTS = 3; 
II Number of students 
const i nt NUM_SCORES = 5; 
II Number of test 
scores 
double total
; 
II Accumulator 
double average; 
II Holds average score on a given test 
double scores[NUM_STUDENTS][NUM
_SCORES] = {{88, 97, 79, 86, 94}, 
{86 , 91, 78, 79, 84}, 
{82, 73, 77, 82, 89}}; 
II Calculate 
and display 
the class 
II average 
for each test 
for (i nt col = O; col < NUM
_SCORES; col ++) 
{ 
} 
II Reset accumulator 
to O for this 
test 
total 
= O; 
II Sum a column 
for (int row= O; row< NUM
_STUDENTS; row++) 
total 
+= scores[row][col]; 
II Compute and display 
the class 
average 
for this 
test 
average= 
total 
I NUM
_STUDENTS; 
cout << "Class average 
for test"<< 
(col + 1) 
<<"is"<< 
average<< 
endl; 

560 
Chapte r 8 
8.11 
Arrays 
Arrays with Three or More Dimensions 
CONCEPT: 
C++ permits arr ays to have multipl e dimensions. 
C++ allows you to create arrays with virtually any number of dimensions . Here is an 
example of a three-dimensional (3D) array definition: 
double seat[3][5][8
] ; 
This array can be thought of as three sets of five rows, with each row having eight 
elements. The array might be used, for examp le, to store the price of seats in an 
auditorium that has three sections of seats, with five rows of eight seats in each section. 
Figure 8-17 illustrates the concept of a three -dimensional array as "pages" of two -
dimensional arrays . 
Figure 8-17 
0 
1 
2 
3 
4 
0 
2 
1 
1 
2 
3 
4 
5 
6 
7 
0 
Arrays with more than three dimensions are difficult to visualize but can be useful in 
some programming problems. 
When writing functions that accept multidimensional arrays as arguments, you must 
explicitly state all but the first dimension in the parameter list. If the seat array, defined 
here, were passed to ad i sp l aySeats function, its prototype and function header might 
look like the following: 
// Functi on prototy pe 
voi d di splaySeats(dou
ble [] [5] [8] , i nt ); 
// Functi on header 
voi d di splaySeats(dou
ble array[][5
] [8], int numGroups); 
As with one-dimensional and two -dimensional arrays, the parameter lists can be 
simplified if a typedef statement is used to create an alias for the array type. This is 
demonstrated in Program 8-23, which uses the seat array to store theater seat prices. 
The information to populate the array is read in from a file. The information on 
number of sections, number of rows in a section, and number of seats in a row is stored 
in global constants, rather than being passed to the functions . 

8.11 Arrays with Three or More Dimensions 
561 
Program 8-23 
1 II Thi s program stores 
and displays 
theater 
seat 
prices
. 
2 II It demonstrates 
how to pass a 3-dimens i onal array 
to 
3 II a function. 
The data i s read in from a file
. 
4 #include 
<iostream> 
5 #include 
<fstream> 
6 #include 
<iomanip> 
7 using namespace std; 
8 
9 const 
int NUM_SECTIONS = 3, 
10 
ROWS
_IN_SECTION = 5, 
11 
SEATS_ IN_ROW = 8; 
12 
13 typedef 
double seatTable[] 
[ROWS_IN_SECTION][SEATS_ IN_ROW] ; 
14 
15 II Function 
prototypes 
16 void fil lArray (s eatTable
); 
17 void showArray(const 
seatTable); 
18 
19 int main() 
20 { 
21 
II Defi ne 3-0 array 
to hold seat 
prices 
22 
double seats[NUM_SECTIONS][ROWS
_ IN_SECTION][SEATS_IN_ROW]; 
23 
24 
fillArray(seats); 
25 
showArray(seats); 
26 
return 
O; 
27 } 
28 
29 /***************************************************** 
30 
* 
fi llArray 
* 
31 
* Thi s funct i on receives 
the address 
of a 3-0 array* 
32 
* and fills 
i t with data read in from a fi l e . 
* 
33 
*****************************************************/ 
34 void fil lArray (s eatTable 
array) 
35 { 
36 
ifstream 
dataln; 
37 
dataln.open("seats.dat"); 
38 
39 
if (!da taln } 
40 
cout << "Error 
opening file.\n"; 
41 
els e 
42 
{ 
for (int section= 
O; section< 
NUM_SECTIONS; section
++) 
43 
for (int 
row= O; row< ROWS
_IN_SECTION; row++} 
44 
for (i nt seat= 
O; seat< 
SEATS_ IN_ROW; seat+ +) 
45 
dataln 
>> array[sect
i on][row][seat]; 
46 
47 
dataln
.close(); 
48 
} 
49 } 
50 
(program continues) 

562 
Chap ter 8 
Arrays 
Program 8-23 
(continued) 
51 / ****
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * 
52 
* 
showArray 
* Thi s func ti on di sp l ays the conte nts of t he 3-D 
* array 
of doubles 
whose address 
is passed t o it . 
* 
* 
* 
53 
54 
55 
* * * ******
* * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ******
* / 
56 void showArray (const 
seat Tabl e array ) 
57 { 
58 
cout <<fixed<< 
showpoi nt << setprecision
(2); 
59 
60 
fo r (i nt sectio
n = O; section< 
NUM
_SECTIONS; section+
+) 
61 
{ 
62 
co ut << "\ n\ nSection" 
<< (section+
1); 
63 
for (i nt row = O; row< ROWS
_ IN_SECTION; row++) 
64 
{ 
65 
cout << "\ nRow " << ( row+1) << " : " ; 
66 
fo r (in t seat
= O; sea t < SEATS_ IN_ROW; seat ++) 
67 
cout << setw (7) << array(sec
ti on] [row ]( seat ]; 
68 
) 
69 
} 
70 
cout << endl ; 
71 } 
Program Outpu t 
Section1 
Row 1 : 
18.00 
18.00 
18.00 
18.00 
18.00 
18.00 
18.00 
Row 2: 
15.00 
15.00 
15.00 
15.00 
15.00 
15.00 
15.00 
Row 3: 
15.00 
15.00 
15.00 
15.00 
15.00 
15.00 
15.00 
Row 4: 
15.00 
15.00 
15.00 
15.00 
15.00 
15.00 
15.00 
Row 5: 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
Section2 
Row 1 : 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
Row 2: 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
Row 3: 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
12.00 
Row 4: 
10.00 
10.00 
10.00 
10.00 
10.00 
10.00 
10.00 
Row 5: 
10.00 
10.00 
10.00 
10.00 
10.00 
10.00 
10.00 
Section3 
Row 1 : 
8.00 
8.00 
10.00 
10.00 
10.00 
10.00 
8.00 
Row 2: 
8.00 
8.00 
10.00 
10.00 
10.00 
10.00 
8.00 
Row 3: 
5.00 
5.00 
8.00 
8.00 
8.00 
8.00 
5.00 
Row 4: 
5.00 
5.00 
8.00 
8.00 
8.00 
8.00 
5.00 
Row 5: 
5.00 
5.00 
8.00 
8.00 
8.00 
8.00 
5.00 
~ 
Checkpoint 
18.00 
15.00 
15.00 
15.00 
12.00 
12.00 
12.00 
12.00 
10.00 
10.00 
8.00 
8.00 
5.00 
5.00 
5.00 
8.19 
Define a two -dimensional array of i nt s named grades . It should have 30 rows 
and 10 columns. 
8.20 
H ow many elements are in th e followi ng ar ray? 
double 
sal es[6 ][ 4] ; 

8.12 
0 
8.12 Vectors 
563 
8.21 
Write a statement that assigns the value 56893.12 to the first column of the first 
row of the sales array defined in question 8.20. 
8.22 
Write a statement that displays the contents of the last column of the last row of 
the sales array defined in question 8.20. 
8.23 
Define a two-dimensional array named set t ings large enough to hold the table 
of information below. Initialize the array with the values in the table. 
12 
24 
32 
21 
42 
14 
67 
87 
65 
90 
19 
1 
24 
12 
8 
8.24 
Fill in the empty table below so it shows the contents of the following array: 
int table [ 3 ][ 4] = { { 2, 3} , { 7, 9 , 2}, { 1 } } ; 
8.25 
Write a function called di spl ayArray7 . The function should accept a two -
dimensional array as an argument and display its contents on the screen. The 
function should work with any of the following arrays: 
i nt hours[5][7]; 
i nt st amps[8][7 ] ; 
i nt autos[12][7
] ; 
8.26 
A DVD rental store keeps DVDs on 50 racks with 10 shelves each. Each shelf 
holds 25 DVDs. Define a 3D array to represent this storage system. 
Vectors 
CONCEPT : The Standard Template Library includes a data type called a vector. It 
is similar to a one-dimensional array but has some advantages compar ed 
to a standard array. 
The Standard Template Library (STL) is a collection of programmer-defined data types and 
algorithms that are available for you to use in your C++ programs. These data types and 
algorithms are not part of the C++ language but were created in addition to the built-in data 
types. If you plan to continue your studies in the field of computer science, you should 
become familiar with the STL. This section introduces one of the STL data types, the vect or. 
NOTE : To use vectors, your program header must indicate that you are using 
namespace std, since vectors are contained within that namespace. Many older 
compilers do not allow namespaces or support the STL. 

564 
Chapte r 8 
0 
Arrays 
The data types that are defined in the STL are common ly called containers. They are 
called containers because they store and organize data. There are two types of 
containers in the STL: sequence containers and associat ive containers . A sequence 
container organizes data in a sequential fashion, similar to an array . Associative 
containers organize data with keys, which allow rapid, random access to elements 
stored in the container. 
The vect or data type is a sequence container that is like a one-dimensional array in the 
following ways: 
• A vector holds a sequence of values, or elements. 
• A vector stores its elements in contiguous memory locations . 
• You can use the array subscript operator [] to access individual elements in the 
vector. 
However, a vector offers several advantages over arrays . Here are just a few: 
• You do not have to declare the number of elements that the vector will have. 
• If you add a value to a vector that is already full, the vector will automatically 
increase its size to accommodate the new value. 
• Vectors can report the number of elements they contain . 
Defining and Initializing a Vector 
To use vectors in your program, you must include the vect or header file with the 
following statement: 
#include 
<vect or> 
To create a vector object you use a statement whose syntax is somewhat different from 
the syntax used in defining a regular variable or array. Here is an example: 
vector<i nt > numbers; 
This statement defines numbers as a vector of i nt s. Not ice that the data type is enclosed 
in angled brackets, immediately after the word vector . Because a vector expands in 
size as you add values to it, there is no need to declare a size. However, you can declare 
a starting size, if you prefer. Here is an examp le: 
vector<i nt > numbers(10); 
This statement defines numbers as a vector of 10 i nt s, but this is only a starting size. Its 
size will expand if you add more than 10 values to it. 
NOTE: Notice that if you specify a starting size for a vector, the size declarator is 
enclosed in parentheses, not square brackets. 
When you specify a starting size for a vector, you may also specify an initializat ion 
value. The initialization value is copied to each element . Here is an example: 
vector<i nt > numbers(10, 
2 ); 
In this statement, numbers is defined as a vector of 10 i nts. Each element in numbers is 
initialized to the value 2. 

0 
8.12 Vectors 
565 
You may also initialize a vector with the values in another vector. For examp le, if set 1 
is a vector of i nts that already has values in it, the following statement will create a 
new vector, named set2 , which is an exact copy of set1. 
vector<int> 
set2(set1); 
After this statement executes, the vector set2 will have the same number of elements 
and hold the same set of values as set 1. 
If you are using C++ 11, you can also initialize a vector with a list of values, as shown 
in this examp le: 
vector<int> 
numbers { 10, 20, 30, 40 }; 
Thi s statement defines a vector of i nt s named numbers. Th e vector will have four 
elements, initialized with the values 10, 20, 30, and 40. Notice that the initialization 
list is enclosed in a set of braces, but you do not use an = operator before the list. 
Table 8-2 summarizes the vector definition procedures we have discussed . 
Table 8 -2 Example Vector Definitions 
Definition Format 
vector<string> 
names; 
vector<int> 
scores(15); 
vector<char> 
letters(25, 
'A'); 
vector<double> 
values2(values1); 
vector<int> 
length{12, 
10, 6}; 
Description 
This defines names as an empty vector of string objects . 
This defines scores as a vector of 15 i nt s. 
This defines letters 
as a vector of 25 characters . 
Each element is initialized with 'A'. 
This defines val ues2 as a vector of double s. All the 
elements of val ues1, which is also a vector of doubles, 
are copied to val ues2 . 
In C++ 11 this defines lengt h as a vector of 3 i nt s, 
holding the values 12, 10, and 6. 
Storing and Retrieving Values in a Vector 
To store a value in a vector element that already exists or to access the data stored in a 
vector element, you may use the array subscript operator [ J. Program 8-24, which is a 
modification of Program 8-15, illustrates this. 
Program 8-24 
1 II Thi s program stores 
employee hours worked 
2 II and hourly pay rates 
i n two parallel 
vectors. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 #include 
<vector> 
II Needed to use vectors 
6 using namespace std ; 
7 
8 int main() 
9 { const i nt NUM
_EMPS = 5; 
10 
vector 
<i nt> hours(NUM_EMPS); 
11 
vector 
<double> payRate(NUM_EMPS); 
12 
double grossPay; 
II Number of employees 
II Define a vector 
of i ntegers 
II Define a vector 
of doubles 
II An employee's 
gross pay 
(program continues) 

56 6 
Chapte r 8 
Arrays 
Program 8 -24 
(continued) 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 } 
// Get employee work data 
cout << "Ent er the hours worked and hourly 
pay rates 
of" 
<< NUM
_EMPS << " employees. 
\ n" ; 
for (i nt i ndex= 
O; i ndex< 
NUM
_ EMPS; index++) 
{ 
} 
cout << "\nHours worked by employee#
" << (index+ 
1) << "· "; 
cin 
>> hours[index
] ; 
cout << "Hourly pay rate 
for this 
employee: 
$"; 
cin 
>> payRate[index]; 
// Display each employee's 
gross pay 
cout << "\nHere is the gross pay fo r each employe e :\ n"; 
cout <<fixed<< 
showpoint << setprec
i sion (2); 
for (int index
= O; index< 
NUM
_ EMPS; index++) 
{ 
} 
grossPay 
= hours[index
] * payRate[ i ndex]; 
cout << "Employe e #" << (i ndex + 1); 
cout << ": $" << setw(7) 
<< grossPay 
<< endl ; 
return 
O; 
When run with the same example input, the output is the same as for Program 8-15. 
Let's take a look at some of the lines in Program 8-24. 
First notice line 5. It contains the preprocessor directive needed to use vectors . 
#include 
<vector> 
Lines 10 and 11 define the two vectors. 
vector 
<int> hours (NUM
_ EMPS); 
vector 
<double> payRate(NUM_EMPS); 
// Define a vector 
of integers 
// Define a vector 
of doubles 
Because a size declarator follows each vector name, it will be created with a starting size. 
In this case, the named constant NUM
_EMPS equals 5, so both vectors will begin with five 
elements. And because they already have elements, values can be read into them or assigned 
to them exactly the same way you store values in array elements, using the [] operator. 
On line 18 a for loop begins, whose purpose is to input the user data . Lines 21 and 23 
of the loop have the statements that read the inputs and place them in the vector 
elements specified by the current value of the loop contro l variable index. 
ci n >> hours[ i ndex]; 
cin 
>> payRate[index]; 
On line 29 a second for loop begins. Its purpose is to compute and display each 
employee's gross pay. Line 31 of the loop has the statement that performs this 
computation, using data it gets from the specified element of each vector. 
grossPay 
= hours[index
] * payRate[index]; 
If you compare Program 8-24 to Program 8-15, you will see that lines 9 through 36 are 
identical. Once the vectors have been defined and have been given starting elements, 
you can access them to store and retrieve data just like you do with arrays . 

8.12 Vectors 
567 
0 
Using the Range-Based for Loop with a vector in C++ 11 
With C++ 11, you can also use a range -based for loop to step through the elements of 
a vector, just as you did earlier in this chapter with elements of an array . Program 8-25 
demonstrates 
this. 
Program 8-25 
1 II Thi s program uses 
2 #include 
<iostream> 
3 #include 
<vector> 
4 using 
namespace std; 
5 
6 int 
main() 
two range-based 
for loops wi th a vector. 
7 { 
8 
9 
10 
II Def i ne a vector 
with a starting 
s i ze of 5 elements 
vector<int> 
numbers(5); 
11 
II Get values 
for the vector 
elements 
12 
II Make the range var i able a reference 
variable 
so i t can be 
13 
II used to change the contents 
of the element 
it references. 
14 
for 
(int 
&val : numbers) 
15 
{ 
16 
cout << "Enter 
an i nteger 
value: 
"; 
17 
ci n 
>> val; 
18 
} 
19 
20 
II Display 
the vector 
elements 
21 
cout << "\nHere 
are the values 
you entered: 
\n"; 
22 
23 
for 
(int 
val 
: numbers) 
24 
25 
26 
27 
28
} 
cout <<val<<" 
cout << endl; 
return 
O; 
". 
' 
Program Output with Example Input Shown in Bold 
Enter 
an integer 
value: 
lO[Enter] 
Enter 
an integer 
value: 
20[Enter] 
Enter 
an integer 
value: 
30[Enter] 
Enter 
an integer 
value: 
40[Enter] 
Enter 
an integer 
value: 
SO[Enter] 
Here are the values 
you entered: 
10 
20 
30 
40 
50 
Using the push_back Member Function 
You cannot, however, use the [] operator to access a vector element that does not yet 
exist. To store a value in a vector that does not have a starting size, or that is already 
full, you should use the push _back member function. This function accepts a value as 
an argument and stores it in a new element placed at the end of the vector. (It "pushes" 
the value at the "back" of the vector.) 

568 
Chapte r 8 
Arrays 
Here is an examp le that adds an element to a vecto r of i nts named numbers. 
numbers .push_back(25); 
Thi s statement creates a new element holding 25 and places it at the end of numbers. 
If numbers previously had no elements, the new element becomes its single element. 
Program 8-26 is a modification of Program 8-24. Thi s version, however, allows the 
user to speci fy the number of employees . Th e two vectors, hours and payRate, are 
defined witho ut start ing sizes. Because these vectors have no start ing elements, the 
push _back member function is used to store values in them. 
Program 8-26 
1 II Thi s program stores 
employee hours worked and hourly pay rates 
2 II in two vectors. 
It demonstrates 
the use of the push _back member 
3 II function 
to add new elements 
to the vectors
. 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 #include 
<vector> 
II Needed to use vectors 
7 using namespace std ; 
8 
9 int main() 
10 { 
11 
12 
13 
14 
15 
16 
vector<int> 
hours; 
vector<double> 
payRate ; 
double grossPay; 
int numEmployees ; 
int i ndex; 
17 
II Get the number of employees 
II hours is an empty i nteger 
vector 
II payRate is an empty doub le vector 
II Number of employe es 
I I Loop counter 
18 
cout << "How many employees do you have?"· 
19 
cin 
>> numEmploy ees ; 
20 
21 
II 
Input the payroll 
data 
22 
cout << "Enter the hours worked and hour ly pay rates 
of the" 
23 
<< numEmp l oyees << " employ ees . \ n" ; 
24 
25 
for (i ndex = O; index< 
numEmployees; index ++) 
26 
{ 
27 
28 
29 
int tempHours ; 
double tempRate; 
II Number of hours entered 
II Pay rate 
entered 
30 
cout << "Hours worked by employe e#"<< 
(i ndex + 1) << "· "· 
31 
cin 
>> tempHours ; 
32 
hours.push _back(tempHours); 
II Add an ele ment to hours 
33 
cout << "Hourly pay rate 
for employee#"<< 
(i ndex + 1) << ": "· 
34 
ci n >> tempRate ; 
35 
payRate.push _back(tempRate); 
II Add an element to payRate 
36 
} 
(program continues) 

Program 8-26 
(continued) 
37 
// Di splay each employee's 
gross 
pay 
38 
cout << "\ nHere is t he gross 
pay for each employee: \ n" ; 
39 
cout <<fixed<< 
showpoint 
<< setp r ecision
(2); 
40 
fo r (index
= O; index< 
numEmployees ; index ++) 
41 
{ 
42 
gr ossPay = hour s [index ] * payRate [index ]; 
43 
co ut << "Employee#
" << (index+ 
1); 
44 
co ut << ": $" << setw (7) << gr ossPay << end l; 
45 
} 
46 
ret ur n O; 
47 } 
Program Output with Example Input Shown in Bold 
How many employees 
do you have? 3 [Ent er] 
Enter the hours worked by 3 employees 
and their 
hourly 
rates. 
Hours worked by employee #1 : 40[Enter] 
Hourly pay rate 
for employee #1: 
12 .63[Ent er] 
Hours worked by employee #2: 2S[Enter] 
Hourly pay rate 
for employee #2: 
10 .3S[Ent er] 
Hours worked by employee #3: 4S[Enter] 
Hourly pay rate 
for employee #3: 22 .6S[Ent er] 
Here is the gross 
pay for each employee: 
Employee #1: $ 505.20 
Employee #2: $ 258.75 
Employee #3: $1019.25 
8.12 Vectors 
569 
N otice th at th e Progra m 8-26 loop in lines 40 thro ugh 45, which calculates and displays 
eac h employee's gross pay, uses the [ J opera tor to access the eleme nts of the hours and 
payRate vectors. Thi s is possib le because the first loop in lines 25 throug h 36 alrea dy 
used the push_bac k member function to create the elements in the two vectors . 
Determining 
the Size of a Vector 
Unlike arrays, vectors can report th e nu mbe r of ele men ts they con tain. Th is is 
acco mplishe d with th e size member funct ion. Here is an exam ple of a statement tha t 
uses the si ze member functio n: 
numValues = set . si ze (); 
In this statemen t, ass um e th at numVal ues is an int and set is a vector. Afte r the 
statement executes, numVal ues will contain the numbe r of eleme nts in set. 
Th e size member function is especia lly useful for writing functio ns tha t accep t vectors 
as arg uments. For examp le, look at the follow ing code for the showVal ues funct ion : 
voi d showVal ues (vector<int> 
vect ) 
{ 
) 
for (i nt co unt
= O; count< 
vect .size (); co unt+ +) 
cout << vect[count
] << endl ; 
Because the vector can report its size, this function does no t need a second argument 
indi cating the num ber of elements in the vector. Program 8-27 demonstra tes this function. 

570 
Chapte r 8 
Arrays 
Program 8-27 
1 II Thi s program demonstrates 
the vector 
size member function. 
2 #include 
<iostream> 
3 #include 
<vector> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 void showValues(vector<int>); 
8 
9 int main() 
10 { 
11 
vector<int> 
values; 
12 
13 
II Store a series 
of numbers in the vector 
14 
for (int 
count
= O; count< 
7 ; count+ +) 
15 
values .push_back(count 
* 2) ; 
16 
17 
II Di splay the numbers 
18 
showValues(values
); 
19 
20 
return 
O; 
21 ) 
22 
23 /***************************************************************** 
24 
25 
26 
27 
* 
showValues 
* 
* Thi s funct i on accepts 
an int vector 
as its 
sole argument, 
and* 
* displays 
the value stored 
in each of the vector's 
elements. 
* 
*****************************************************************/ 
28 void showValues(vector<int> 
vect) 
29 { 
30 
for (int 
count
= O; count< 
vect.s
i ze (); count++) 
31 
cout << vect[count
] <<" 
"· 
32 
cout << endl; 
33 ) 
Program Output 
0 2 
4 6 
8 
10 
12 
Notice that when the vector in Program 8-27 was defined on line 11, it was given no 
elements. Ther efore, the statement on line 15 that stores values in the vector uses the 
push _back function introduced in Program 8-26. Th e push _back function creates a 
new vector element to hold a value each time it is called . 
Removing Elements from a Vector 
To remove the last element from a vector you can use the pop_back member function. 
Th e following statement removes the last element from a vector named co 11 ect i on. 
collection.pop
_back( ); 
Program 8-28 demonstrates the pop_back function. 

Program 8-28 
1 II Thi s program demonstrates 
the vector 
s i ze, 
2 II push _back, and pop_back member functions
. 
3 #include 
<iostream> 
4 #include 
<vector> 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
vector<int> 
values; 
10 
11 
II Store values 
in the vector 
12 
values.push
_back(1); 
13 
values.push
_back(2); 
14 
values.push
_back(3); 
15 
cout << "The size of values 
is"<< 
values.size()<< 
endl; 
16 
17 
II Remove a value from the vector 
18 
cout << "Popping a value from the vector . . . \n"; 
19 
values.pop
_back(); 
20 
cout << "The size of values 
is now " << values.size() 
<< endl; 
21 
22 
II Now remove another 
value from the vector 
23 
cout << "Popping a value from the vector . . . \n"; 
24 
values.pop
_back(); 
25 
cout << "The size of values 
is now " << values.size() 
<< endl; 
26 
27 
II Remove the last 
value from the vector 
28 
cout << "Popping a value from the vector . . . \n"; 
29 
values.pop
_back(); 
30 
cout << "The size of values 
is now " << values.size() 
<< endl; 
31 
return 
O; 
32 } 
Program Output 
The size of values 
is 3 
Popping a value from the vector ... 
The size of values 
is now 2 
Popping a value from the vector ... 
The size of values 
is now 1 
Popping a value from the vector ... 
The size of values 
is now O 
8.12 Vectors 
571 
0 
NOTE: 
The pop_back function is a voi d function that does not return the value 
being removed from the vector. The following line of code will not work: 
cout << "The value bei ng removed from the vector 
is" 
<< values.pop
_back(} << endl; 
II Error! 

572 
Chapte r 8 
Arrays 
Clearing a Vector 
To completely clear the contents of a vector, use the cl ear member function, as shown 
in the following example: 
numbers .clear(); 
After this statement executes, numbers will be cleared of all its elements. Program 8-29 
demonstrates the function. 
Program 8-29 
1 II Thi s program demonstrates 
the vector 
clear 
member function. 
2 #include 
<iostream> 
3 #include 
<vector> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
vector<int> 
values(100); 
9 
10 
cout << "The values vector 
has" 
11 
<<values.size()<<" 
elements . \n"; 
12 
cout << "I wil l call 
the clear 
member function ... \n"; 
13 
values.clear(); 
14 
cout << "Now the values vector 
has" 
15 
<<values.size()<<" 
elements . \n"; 
16 
return 
O; 
17 ) 
Program Output 
The values vector 
has 100 elements. 
I will 
call 
the clear 
member function ... 
Now the values vector 
has O elements. 
Detecting an Empty Vector 
To determin e if a vector is empty, use the empty member function. The function returns 
true if the vector is empty, and false if the vector has elements stored in it. Assuming 
numberVector is a vector, here is an example of its use: 
i f (numberVector .empty ()) 
cout << "No values 
in numberVector . \n"; 
Program 8-30 shows how to pass a vector to a function. Th e function, named 
avgVector, demonstrates the empty member function. 
Program 8-30 
1 II Thi s program demonstrates 
the vector 
empty member function. 
2 #include 
<iostream> 
3 #include 
<vector> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 double avgVector(vector<
i nt>); 
8 
(program continues) 

Program 8-30 
(continued) 
9 int main() 
10 { 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 } 
32 
vector<int> 
values; 
int numValues; 
double average ; 
II Define a vector 
to hold i nt values 
II Number of values 
to be averaged 
II Average of the stored 
values 
II Get the number of values 
to average 
cout << "How many values 
do you wish to average?"· 
cin 
>> numValues ; 
II Get the values 
and store 
them in a vector 
for (int 
count
= O; count< 
numValues; count++ ) 
{ 
int tempValue ; 
} 
cout << "Enter an i nteger 
value: 
"· 
ci n >> tempValue; 
values .push_back(tempValue ); 
II Get the average of the values 
and di splay i t 
average
= avgVector(values); 
cout << "Average: 
" << average << endl ; 
return 
O; 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
/************************************************************* 
* 
avgVector 
* Thi s funct i on accepts 
an int vector 
as its 
argument. 
If 
* the vector 
contains 
values, 
the function 
returns 
the 
* average of those values. 
Otherwise, 
an error 
message i s 
* displayed 
and the funct i on returns 
0.0. 
* 
* 
* 
* 
* 
*************************************************************/ 
double avgVector(vector<
i nt> vect) 
{ 
int total 
= O; 
double avg= 
0.0; 
II Accumulator 
if (vect.empty
()) 
II Determine 
if the vector 
i s empty 
cout << "No values 
to average.
\n"; 
else 
{ 
for (i nt count= 
O; count< 
vect .size(); 
count+ +) 
total+= 
vect[count]; 
avg= 
static
_cast<double>(total)lvect.size(); 
51 
} 
52 
return 
avg ; 
53
} 
Program Output with Example Input Shown in Bold 
How many values 
do you wish to average? 
4[Enter] 
Enter an integer 
value: 
12[Enter] 
Enter an integer 
value: 
3[Enter] 
Enter an integer 
value: 
7[Enter] 
Enter an integer 
value: 
9[Enter] 
Average: 
7.75 
Program Output with Different Example Input Shown in Bold 
How many values 
do you wish to average? 
O[Enter] 
No values 
to average. 
Average: 
0 
8.12 Vectors 
57 3 

574 
Chapte r 8 
Arrays 
Summary of Vector Member Functions 
Table 8-3 provides a summary of the vector member functions we have discussed, as 
well as some additional ones. 
Table 8 -3 Vector Member Functions 
Member Function 
Description 
at (position
) 
Returns the value of the element located at position in the vector. 
Example: 
x = vect . at ( 5 ) ; II Assigns the value of vect [ 5] to x. 
capacity () 
Returns the maximum number of elements that may be stored in the vector 
without additiona l memory being allocated. (This is not the same value as 
returned by the size member function .) 
Example: 
x = vect. capac it y(); II Assigns the capacity of vect to x. 
c 1 ear () 
Clears a vector of all its elements. 
Example: 
vect . cl ear () ; II Removes all the elements from vect. 
empty () 
Returns true if the vector is empty. Otherwise, it returns fa l se. 
Example: 
if ( vect . empty () ; 
II If the vector is empty 
cout << "The vector is empty. "; II the message is displayed . 
pop_back() 
Removes the last element from the vector. 
Example: 
vect . pop_back(); 
II Removes the last element of vect, thus 
II reducing its size by 1. 
push_bac k ( va 7 ue) 
Stores a value in the last element of the vector. If the vector is full or empty, a 
new element is created. 
Example: 
vect . push_back (7); 
II Stores 7 in the last element of vect . 
reverse () 
Reverses the order of the elements in the vector (the last element becomes the 
first element, and the first element becomes the last element). 
Example: 
vect . reverse (); II Reverses the order of the element in vect . 
resize ( n) 
Resizes a vector to have n elements, where n is greater than the vector's 
current size. If the optional value argument is included, each of the new 
resize ( n, value) 
elements will be initialized with that value. 
size() 
swap(vector2) 
Example where vect currently has four elements: 
vect . resize (6 , 99 ); II Adds two elements to the end of the vector, 
II each initialized to 99. 
Returns the number of elements in the vector. 
Example: 
numElements = vect.size(); 
Swaps the contents of the vector with the contents of vector2 . 
Example: 
vect 1 . swap ( vect2) ; II Swaps the contents of vect 1 and vect2 . 

8.13 Arrays of Objects 
575 
~ 
Checkpoint 
8.13 
8.2 7 What header file must you #inc 1 ude in order to define vector objects? 
8.28 
Write definition statements for the following three vector objects: frogs (an 
empty vector of i nt s), 1 i zards (a vector of 20 double s), and toads (a vector of 
100 char s, with each element initialized to 'Z' ). 
8.29 
Define gators to be an empty vector of i nt s and snakes to be a 10-element 
vector of double s. Then write a statement that stores the value 27 in gators and 
a statement that stores the value 12.897 in element 4 of snakes. 
Arrays of Objects * 
CONCEPT: 
Elements of arrays can be class objects. 
You have learned that all the elements in an array must be of the same data type, and 
you have seen arrays of many different simple data types, like i nt arrays and string 
arrays . However, arrays can also hold more complex data types, such as programmer-
defined structures or objects . All that is required is that each element hold a structure 
of the same type or an object of the same class. 
Let's look at arrays of objects . You define an array of objects the same way you define 
any array. If, for example, a class named Circle has been defined, here is how you 
would create an array that can hold four Ci re 1 e objects: 
Circle 
circle[4]
; 
The four objects are ci rel e [OJ, ci rel e [ 1], ci rel e [2], and ci rel e [3]. 
Notice that the name of the class is Ci rel e, with a capital C. Th e name of the 
array is ci rel e, with a lowercase c. You will recall from Chapter 7, that the 
convention is to begin the name of a class with a capital letter and the name of a 
variable or object with a lowercase letter. Calling a class function for one of these 
ob jects is just like calling a class function for any ot her object, except that a 
subscript must be included to identify which of the objects in the ar ray is being 
referenced. For example, the following statement would call the f i ndArea function 
of circle[2]. 
circle[2
]. findArea(); 
Program 8-31 illustrates these ideas by creating and using an array of Ci re 1 e class 
objects. Here is the definition of the Ci re 1 e class it uses. It is a variation of the Ci re 1 e 
class introduced in Chapter 7. 
• This section should be skipped until later if Chapter 7 has not yet been covered. 

576 
Chapte r 8 
Arrays 
Circle.h 
1 // This header fi l e contains 
the Circle 
class 
declarat
ion. 
2 #ifndef 
CIRCLE_H 
3 #define 
CIRCLE_H 
4 #include 
<cmath> 
5 
6 class 
Ci rcle 
7 { pr i vate: 
8 
double radius; 
9 
int centerX , centerY; 
publ i c: 
Circle() 
{ radius= 
1 .O; 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
centerX = centerY = O; 
} 
Circle(double 
r) 
{ radius= 
r; 
centerX = centerY = O; 
20 
} 
21 
22 
23 
24 
Circle(double 
r, int x , int 
y) 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
{ 
} 
radius= 
r; 
centerX = x; 
centerY = y; 
void setRadius(double 
{ 
radius= 
r; 
} 
int getXcoord () 
{ 
return 
centerX ; 
} 
int getYcoord () 
{ 
return 
centerY ; 
} 
40 
double findArea () 
r) 
41 
{ return 
3. 14 * pow (radi us, 2) ; 
42 
} 
43 }; // End Cir cle class 
declaration 
44 #endif 
// Ci rel e radius 
// Center coord i nates 
// Default 
constructor 
// accepts 
no arguments 
// Constructor 
2 
// accepts 
1 argument 
// Constructor 
3 
// accepts 
3 arguments 
As you look at Program 8-31, which follows, pay particular attent ion to its key parts. 
Line 5 includes the Ci rel e . h header file that contains the Ci rel e class definition. Then, 
on line 12, the program creates an array of four Ci rel e objects. In lines 15 through 20 
it uses a loop to call the setRad i us method for each object. A second loop is used in 
lines 26 through 29 to call the fi ndArea method for each object and display the result. 

Program 8-31 
1 II Thi s program uses an array of objects
. 
2 II The objects 
are instances 
of the Ci rcle class. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
8.13 Arrays of Objects 
577 
5 #include 
"Ci rcle .h" 
II Circle 
cl ass dec la rat i on f i le 
6 using namespace std ; 
7 
8 const 
int NUM_CIRCLES = 4; 
9 
10 int main() 
11 { 
12 
Circle 
circle[NUM _CIRCLESJ; II Define an array 
of Circle 
objects 
13 
14 
II Use a loop to i nit i alize 
the radius 
of each object 
15 
for (i nt index= 
O; index< 
NUM
_CIRCLES; index++) 
1 6 
{ 
dou b 1 e r ; 
17 
cout << "Ent er the radius 
fo r circle"<< 
(i ndex+1) << "· "· 
18 
cin 
>> r; 
19 
circle[index].setRadius(r); 
20 
} 
21 
22 
II Use a loop to get and print 
out the area of each object 
23 
cout 
<<fixed<< 
showpoint << setprecision(2); 
24 
cout 
<< "\nHere are the areas of the
"<< NUM
_CIRCLES 
25 
<<" 
circles.\n"; 
26 
for (i nt index= 
O; index< 
NUM
_CIRCLES; index++) 
27 
{ cout 
<<"circle"<< 
(ind ex+1 ) << setw(8) 
28 
<< circle[index].findArea() 
<< endl ; 
29 
} 
30 
ret urn O; 
31 } 
Program Output with Example Input Shown in Bold 
Enter the radius 
for circle 
1 : O[Enter] 
Enter the radius 
for circle 
2: 2[Enter] 
Enter the radius 
for circle 
3: 2.S[Enter] 
Enter the radius 
for circle 
4: lO[Enter] 
Here are the areas 
of the 4 circles. 
c i re 1 e 1 
0 . 00 
circle 
2 
circle 
3 
circle 
4 
<) 
12.56 
19.63 
314.00 
NOTE: Whenever an array of objects is created with no constructor arguments, 
the default constructor, if one exists, runs for every object in the array . This occurred 
in Program 8-31. 

578 
Chapte r 8 
Arrays 
When the array of Ci rel e objects was first created, the default const ructor executed 
for each object in the array and assigned its radius the value 1.0. We never saw this 
because the call made to the setRadi us member function of each object replaced its 1.0 
with the new value passed to setRadi us. If we commented out lines 15 through 20 of 
Program 8-31, no calls wou ld be made to setRadi us. So every object in the array 
would still have a radius of 1.0 when the loop on lines 26 through 29 gets and prints 
the area. The out put would look like this: 
Here are the areas of the 4 cir cles. 
circle 
1 
3 .14 
circle 
2 
3 .14 
circle 
3 
3 .14 
circle 
4 
3 .14 
This version of Program 8-31 can be found in the Chapter 8 programs folder on the 
book's companion website with the name pr8-31 B. cpp. 
It is also possible to create an array of objects and have another constr uctor called for 
each object . To do this you must use an initia lization list. The following array definition 
and initialization list creates four Ci rel e objects and initializes them to the same four 
values that were input in the original Program 8-31 sample run. 
Circle 
circle[NUM _CIRCLESJ = {0 .0 , 2.0 , 2.5 , 10.0 }; 
Thi s invokes the constr uctor that accepts one double argument and sets the radi i 
shown here. 
Object 
radius 
circle[O
J 
0.0 
circle[1
] 
2.0 
circle[2
] 
2.5 
circle[3
] 
10.0 
If the initialization list had been shorter than the number of objects, any remaining 
objects would have been initialized by the default constr uctor. For exam ple, the following 
statement invokes the constr uctor that accepts one doubl e argument for the first three 
objects and causes the default constr uctor to run for the fourth object. The fourth object 
is assigned a default radius of 1.0. 
Circle 
circle[NUM _CIRCLESJ = {0 .0 , 2.0 , 2.5 }; 
This is illustrated in Program 8-32. 
Program 8-32 
1 II This program demonstrates 
how an overloaded 
constructor 
2 II that 
accepts 
an argument can be i nvoked for multiple 
objects 
3 II when an array of obje cts is created. 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 #include 
"Cir cle .h" 
II Circle 
class 
dec lara tion 
file 
7 using namespace std ; 
8 
(program continues) 

Program 8-32 
(continued) 
9 const 
int NUM_CIRCLES = 4; 
10 
11 int main() 
12 { 
8.13 Arrays of Objects 
579 
13 
// Defi ne an array of 4 Circle 
objects. 
Use an i nit i alizat
i on list 
14 
// to call 
the 1-argu ment constructo
r for the f i rst 3 objects
. 
15 
// The default 
constructor 
will 
be called 
for the f i nal object
. 
16 
Circle 
circle[NUM _CIRCLESJ = {0.0, 
2 .0, 2 .5} ; 
17 
18 
// Di splay the area of each object 
19 
cout 
<<f i xed<< 
showpoint << setprec
i sion (2); 
20 
cout 
<< "\nHere are the areas 
of the"<< 
NUM
_CIRCLES 
21 
<<"circles.\n"; 
22 
23 
index= 
O; index< 
NUM
_CIRCLES; index++) 
for (i nt 
24 
<< "circle
" << (ind ex+1 ) << setw(8) 
{ 
cout 
25 
<< circle[index].findArea() 
<< endl ; 
} 
26 
27 
28 
ret urn o· ' 
} 
Program Output 
Here are 
circle 
1 
circle 
2 
circle 
3 
circle 
4 
the areas 
of the 4 circles. 
0.00 
12.56 
19.63 
3.14 
To use a constructor that requires more than one argument, the initializer must take 
the form of a function call. For example, look at the following definition statement . It 
invokes the three-argument constructo r for each of three Ci re 1 e objects. 
Circle 
circle[3
] = { Circle(4.0
, 2 , 
Circle(2.0
, 1, 
Circle(2.5
, 5, 
1 ) ' 
3)' 
- 1 ) } ; 
ci rcle[O J will have its radius variable set to 4.0, its centerX variable set to 2, and its 
centerY variable set to 1. ci re 1 e [ 1] will have its rad i us variable set to 2.0, its centerX 
variable set to 1, and its centerY variable set to 3. ci re 1 e [ 2 J will have its radius 
variable set to 2.5, its centerX variable set to 5, and its centerY variable set to -1. 
It isn't necessary to call the same constructor for each object in an array . For example, 
look at the following statement: 
Circle 
circle[3
] = { 4 .0, 
Ci re 1 e ( 2 . O, 1 , 
3) , 
2 .5 }; 
This statement invokes the one-argument constr uctor for circle
[OJ and circle[2] 
and the three-argument constructor for c ire 1 e [ 1 J . 

580 
Chapte r 8 
Arrays 
In summary, there are seven key points to remember about arrays of objects. 
1. The elements of arrays can be objects. 
2. If you do not use an initialization list when an array of objects is created, the 
default constructor will be invoked for each object in the array . 
3. It is not necessary that all objects in the array use the same constructor . 
4. If you do use an initialization list when an array of objects is created, the correct 
constructor will be called for each object, depending on the number and type of 
arguments used. 
5. If a constructor requires more than one argument, the initializer must take the 
form of a constructor function call. 
6. If there are fewer initializer calls in the list than there are objects in the array, the 
default constructor will be called for all the remaining objects. 
7. It is best to always provide a default constructor; but if there is none you must be 
sure to furnish an initializer for every object in the array. 
These seven statements also apply to arrays of structures, which we will look at more 
closely in the next few pages. 
~ 
Checkpoint 
8.30 
True or false: The default constructor is the only constructor that may be called 
for objects in an array of objects. 
8.31 
True or false: All elements in an array of objects must use the same constructor. 
8.32 
What will the following program display on the screen? 
#i nclude <ios t ream> 
us i ng namespac e std; 
class 
Tank 
{ 
pr i vat e: 
i nt gallons; 
publ i c: 
Tank() 
{gallons= 
50; } 
Tank(i nt gal) 
{gallons= 
gal; 
} 
i nt get Gal lo ns() 
{ re t urn gallons; 
} 
} ; 
i nt mai n () 
{ 
} 
Tank st orag e [3 ] = { 10, 20 }; 
for (i nt index= 
O; i ndex< 
3; i ndex ++) 
cout << storage[i
ndex ] .getGallons() 
<< endl; 
re t ur n O; 

8.13 Arrays of Objects 
581 
8.33 
Complete the following program so that it defines an array of 10 Yard objects. 
The program shou ld use a loop to ask the user for the length and width of each 
yard . Then it should use a second loop to display the length and width of each 
yard . To do this, you will need to add two member functions to the Yard class. 
#include 
<iostream> 
usi ng namespace std; 
class Yard 
{ 
private: 
int length, 
width; 
public: 
} ; 
Yard () 
{ length
= O; width= 
O; } 
void 
setLength(int 
1} 
{ 1 ength = 1 ; } 
void 
setWidth(int 
w) 
{ width = w; } 
i nt mai n () 
{ 
// Finish this 
program. 
} 
Arrays of Structures 
As mentioned earlier in this section, array elements can also be structures. This is useful 
when you want to store a collection of records that hold multiple data fields, but you 
aren't using objects . Program 8-15, which we saw earlier, showed how related 
information of different data types can be stored in parallel arrays . These are two or 
more arrays with a relationship established between them through their subscripts. 
Because structures can hold multiple items of varying data types, a single array of 
structures can be used in place of several arrays of regular variables. 
An array of structures is defined like any other array . Assume the following structure 
declaration exists in a program: 
struct 
Booklnfo 
{ 
} ; 
str i ng title; 
str i ng author; 
str i ng publisher; 
double price; 
Th e following statement defines an array, bookL i st, which has 20 elements. Each 
element is a Booklnfo structure . 
Booklnfo bookList[20]; 
Each element of the array may be accessed through a subscr ipt. For example, 
bookL i st [O] is the first structure in the array, bookL i st [ 1] is the second, and so forth. 
Because members of structures are public by default, you do not need to use a function, 

582 
Chapte r 8 
Arrays 
as you do with class objects, to access them. You can access a member of any element 
by simply placing the dot operator and member name after the subscript . For example, 
the following expression refers to the title 
member of bookL i st [ 5]: 
bookList[5] 
.title 
The following loop steps through the array, displaying the data stored in each element: 
for 
(int 
index= 
O; index< 
20; i ndex++) 
{ 
) 
cout << bookList[
i ndex].title 
<< endl; 
cout << bookList[
i ndex].author 
<< endl; 
cout << bookList[
i ndex].publ
i sher << endl; 
cout << bookList[
i ndex].price 
<< endl << endl; 
Because the members tit
le, author , and publisher 
are string 
objects the individua l 
characters 
making up the string can be accessed as well. The following statement 
displays the first character of the t it le member of bookL i st [ 1 O] : 
cout << bookList[10
] .title[O]; 
And the following statement 
stores the character 
't' in the fourth position of the 
publisher 
member of bookL i st [2]: 
bookList[2] 
.publisher[3
] = ' t '; 
Program 8-33 is a modification of Program 8-15 which calculates and displays payroll 
information for a set of emp loyees . The original program used two parallel arrays to 
hold the hours and pay rates of the emp loyees . This modified vers ion uses a single 
array of structures . 
Program 8-33 
1 II This program uses an array 
of structures 
to hold payrol l data. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 using namespace std; 
5 
6 struct 
Paylnfo 
II Define a structure 
that 
holds 2 variables 
7 { 
8 
9 
10 ) ; 
11 
int hours; 
double payRate 
12 int main() 
II Hours worked 
II Hourly pay rate 
II Number of employees 
13 { 
14 
15 
const 
i nt NUM
_EMPS = 3; 
Paylnfo 
workers[NUM_EMPS]; 
II Defi ne an array 
of Paylnfo 
structures 
16 
double grossPay; 
17 
18 
II Get payroll 
data 
19 
cout << "Enter 
the hours worked and hourly 
pay rates 
of" 
20 
<< NUM
_EMPS <<" 
employees. 
\ n"; 
21 
(program continues) 

Program 8-33 
(continued) 
22 
23 
24 
25 
26 
fo r (int index
= O; index< 
NUM
_EMPS; i ndex ++) 
{ co ut << "\ nHours worked by empl oyee#
" << (index 
cin 
>> workers [index ]. hours ; 
co ut << "Hourl y pay rate 
fo r this 
empl oyee : $"; 
ci n 
>> workers[ i ndex ]. payRate ; 
27 
} 
28 
// Display 
each employee's 
gross 
pay 
8.13 Arrays of Objects 
58 3 
+ 1) << II • II; 
29 
cout << "\ nHere is the gross 
pay for each employee: \ n" ; 
30 
cout <<fixed<< 
showpoint << setprecision
(2); 
31 
32 
fo r (int index
= O; index< 
NUM
_EMPS; i ndex ++) 
33 
{ 
34 
grossPay 
= workers (index ] .hours* 
workers [index ]. payRate ; 
35 
co ut << "Employee #" << (index+ 
1); 
36 
co ut << ": $" << setw (7) << grossPay 
<< end l; 
37 
} 
38 
return 
O; 
39 } 
Program Output with Example Input Shown in Bold 
Enter the hours worked and hourly pay rates 
of 3 employees. 
Hours worked by emp 1 oyee #1 : lO[Enter] 
Hourly pay rate 
for this 
employee: $9 .75[Enter] 
Hours worked by employee #2: 15[Ent er] 
Hourly pay rate 
for this 
employee: $8.65[Enter] 
Hours worked by emp 1 oyee #3: 20[Ent er] 
Hourly pay rate 
for this 
employee: $ 10 .SO[Enter] 
Here is the gross 
pay for each employee: 
Employee #1: $ 
97.50 
Employee #2: $ 129.75 
Employee #3: $ 210.00 
You can initialize an array of stru ctures the same way you initialize an array of class 
objects, with a constr uctor. Here is the stru cture decla ration fro m Program 8-33 
modified to include a constructor. It accepts two arguments, but also has default values 
in case a structur e variable is created without passing any values to the constructor. 
st r uct Paylnfo 
{ 
} ; 
int hours ; 
double payRate ; 
Paylnfo (int h = 0 , double p = 0 .0) 
{ hours
= h; 
payRate = p; 
} 
// Hours worked 
// Hour l y pay rate 
// Constructor 

584 
Chapte r 8 
Arrays 
Using this structure, the array in Program 8-33 could now be initialized as follows: 
Paylnfo workers[NUM_EMPS] = { Paylnfo (10, 
Pay Info ( 15, 
Paylnfo(20, 
9. 75), 
8. 65), 
10. 50) } ; 
Notice that the syntax for initializing members in an array of structures is the same as 
for initializing members in an array of objects . It is different from the syntax presented 
in Chapter 7 for initializing a single structure . 
~ 
Checkpoint 
For questions 8.34-8.38, assume the Product structure is declared as follows: 
struct 
Product 
{ 
} ; 
string 
descr i ption; 
int partNum; 
double cost; 
// Product description 
// Part number 
// Product cost 
8.34 
Add two constructors to the Product structure declaration . The first should be 
a default constructor that sets the descript
i on member to the null string and 
the partNum and cost members to zero . The second constructor should have 
three parameters: a str i ng, an int , and a double. It shou ld copy the values of 
the arguments into the descr i ption , partNum, and cost members . 
8.35 
Write a definition for an array named i terns that can hold 100 Product structures. 
8.36 
Write statements that store the following information in the first element of 
the i tems array you defined in question 8.35. 
Description: Claw Hammer 
Part Number: 547 
Part Cost: $8.29 
8.37 
Write a loop that displays the contents of the entire i terns array you created in 
question 8.35. 
8.38 
Write the definit ion for an array of five Product structures, initializing the first 
three elements with the following information: 
Description 
Part Number 
Cost 
Screwdriver 
Socket set 
Claw hammer 
621 
892 
547 
$ 1.72 
18.97 
8.29 
8.39 
Write a structure declaration called Measurement that holds an in t named 
miles and a double named hours. 
8.40 
Write a structure declaration called Destination
, with the following members: 
city, 
a string 
object 
travel Time, a Measurement structure (declared in Checkpoint 8.39) 
8.41 
Define an array of 20 Destination 
structures (see Checkpoint 8.40) . Write 
statements that store the following information in the fifth array element: 
City: Tupelo 
Miles: 375 
Hours: 7.5 

8.14 National Commerce Bank Case Study 
585 
National Commerce Bank Case Study 
The Nationa l Commerce Bank has hired you as a contract programmer. Your first 
assignment is to write a function that will be used by the bank's automated teller 
machines (ATMs) to validate a customer's persona l identification number (PIN). 
Your function will be incorporated into a larger program that asks the customer to input 
his or her PIN on the ATM's numeric keypad. (PINs are four -digit numbers . The 
program stores each digit in an element of an int array .) The program also retrieves a 
copy of the customer's actual PIN from a database . (The PINs are also stored in the 
database as four element arrays.) If these two numbers match, then the customer's 
ident ity is validated . Your function should compare the two arrays and determine 
whether they contain the same numbers . 
Here are the specifications your function must meet. 
Parameters 
Return value 
Th e function should accept three arguments. Th e first is an array 
holding the digits entered by the customer. The second is an array 
holding the digits of the customer's correct PIN, retrieved from the 
bank's database . The final argument indicates the number of digits 
in a PIN. This is set in the program to 4. However, by passing this 
argument to the function it makes the program easier to update in 
the future if the bank decides to change the PIN size. 
The function should return a Boolean true value if the two arrays 
are identical. Otherwise, it should return fa 1 se . 
Here is the pseudocode for the function: 
For each e1ement in the first 
array 
Compare the e1ement with the corresponding 
one in the 2nd array 
If the two e1ements contain 
different 
va1ues 
Return fa 1 se 
End If 
End For 
II If we made it this 
far the va1ues are the same 
Return true 
You have only been asked to write a function that performs the comparison between 
the customer's input and the PIN that was retrieved from the database . However, code 
must also be written to test it. Program 8-34 is a complete program that includes both 
the function and a test driver. 
Program 8-34 
1 II Thi s program te sts a function 
that compares t he conte nt s of two arrays. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function prototype 
6 bool testP IN(const i nt set1[], 
const i nt set2[], 
i nt siz e); 
(program continues) 

586 
Chap ter 8 
Arrays 
Program 8-34 
7 
(continued) 
8 
9 
10 
11 
12 
13 
14 
15 
16 
int main () 
{ 
const i nt NUM
_DIGITS = 
int pin 1 [NUM
_DIGITS] = 
int pin2 [NUM
_DIGITS] = 
int pin3 [NUM
_DIGITS] = 
4 · ' 
{2 , 4 , 1 ' 8}; 
{2 , 4 , 6 , 8}; 
{ 1 ' 2 , 3 , 4}; 
17 
if (testPIN (pin1 , pi n2 , NUM
_DIGITS)) 
II Base set of valu es 
II One el ement i s 
II different 
from PIN1. 
II All el ements are 
II different 
from PIN1. 
18 
co ut << "ERROR: pin 1 and pin2 are reported 
to be the sa me. \ n"; 
19 
el se 
20 
co ut << "SUCCESS: pin 1 and pin2 are correct
l y i dentified" 
21 
<< "as different
. \ n"; 
22 
23 
if (testPIN (pin1 , pin3 , NUM
_DIGITS)} 
24 
co ut << "ERROR: pin 1 and pin3 are reported 
to be the sa me .\ n"; 
25 
el se 
26 
co ut << "SUCCESS: pin 1 and pin3 are correct
l y identified" 
27 
<< "as different
. \ n"; 
28 
29 
if (testPIN (pin1 , pin1 , NUM
_DIGITS)} 
30 
co ut << "SUCCESS: pin 1 and pin 1 are correct
l y repo r ted" 
31 
<< "to be the same . \ n"; 
32 
el se 
33 
co ut << "ERROR: pin 1 and pin 1 are erroneous l y identified" 
34 
<< "as different
. \ n"; 
35 
return 
O; 
36 } 
37 
38 / * * * ******
* * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * ******
* * * * * 
39 
* 
testPIN 
* 
40 
* Thi s Boolean f unction 
accepts 
and compares the val ues stored 
in 
* 
41 
* two i nt arrays
. If they both have exactly 
the same set of val ues , 
* 
42 
* true 
is ret urned . If there 
are any di fferences
, false 
is returned
. * 
43 
* * * ******
* * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * ******
* * * * * / 
44 bool testPIN (const int custPIN[ ], const 
int databasePIN[
] , int size ) 
45 { 
46 
fo r (int index
= O; index< 
size ; i ndex ++} 
47 
{ 
48 
if (custPIN[ i ndex ] != databasePIN
[index ]} 
49 
ret urn false
; 
II We' ve fo und two di fferent 
val ues 
50 
} 
51 
52 
53 } 
ret urn tr ue ; 
Program Output 
SUCCESS: pi n1 and 
SUCCESS: pi n1 and 
SUCCESS: pi n1 and 
pin2 are 
pin3 are 
pi n1 are 
II 
If we make it this 
fa r, 
II al l val ues are the sa me 
correctly 
identified 
as different. 
correctly 
identified 
as different. 
correctly 
reported 
to be the same. 

8.15 Tying It All Together: Rock, Paper, Scissors 
587 
Additional Case Studies 
The following additional case studies, which contain applications of material 
introduced in Chapter 8, can be found in the Chapter 8 programs folder on this 
book' s companion website at pearsonhighered. com/ga ddis. 
Set Intersection 
Case Study 
In algebra, the intersection of two sets is defined as a new set that contains those values 
common to the two original sets. This case study, which utilizes three one-dimensional 
arrays, finds and displays the intersection of two sets. 
Creating an Abstract Array Data Type-Part 
1 
The lack of bounds checking in C++ can lead to problems . This object-oriented case 
study develops a simple integer list class with array-like characteristics that provides 
bounds checking. 
8.15 
Tying It All Together: Rock, Paper, Scissors 
Now that you have learned to use arrays, you can create more advanced computer 
games, like Rock, Paper, Scissors. You have probably played this game before. Here is 
how it works. Simultaneously, two players form their hand to represent one of three 
objects. A fist represents a rock. A flat palm represents a sheet of paper. Two extended 
fingers represent a pair of scissors. If the two players choose the same object, the round 
is a tie. Otherwise, someone wins the round . Rock beats scissors because it can break a 
pair of scissors. Scissors beats paper because it can cut a sheet of paper. Paper beats 
rock because it can wrap itself around the rock. 
In this section we will create a program that lets a user play a game of Rock, Paper, 
Scissors with the computer. Notice how in line 9 of the Rock, Paper, Scissors program 
shown here, the strings holding the names of the choices are stored in an array. In line 
28 the program randomly generates a 1, 2, or 3 for the computer's choice. Then, in 
lines 31 and 32, the human player's choice is entered: 
cout 
<< "Pick 
1 (rock), 
2 (paper), 
or 3 (sc i ssors): 
"; 
cin 
>> pl ayerCho i ce; 
Notice how, for both the computer and the player, the choice number matches the 
array element holding the name of the object they chose. Therefore, the choice number 
can be used as a subscript to get the string to be displayed . With this ability, the 
program can easily display information for each round of the game about who chose 
what, what beats what, and who wins that round. 
Try running the program to see if you can beat the computer. 

588 
Chapte r 8 
Arrays 
Program 8-35 
1 II Thi s program l ets the user pl ay a game of rock, 
paper, 
scissors 
2 II with the computer. 
The computer's 
choices 
are randoml y generated. 
3 #include 
<iostream> 
4 #include 
<ctime> 
5 #include 
<cstd l ib> 
6 #include 
<str i ng> 
7 using namespace std; 
8 
9 const 
str i ng name[4] = {" " 
"rock", 
"paper", 
"scissors"}; 
10 
11 int main() 
12 { 
13 
14 
15 
16 
17 
18 
19 
int computerCho i ce, 
playerChoice, 
computerPoints 
= 0, 
playerPoints 
= O; 
srand(time(NUL L)); 
20 
playerPo i nts = O; 
21 
computerPo i nts = O; 
22 
II Point accumul ators 
II Gi ve the random generator 
II a seed to start 
with 
23 
cout << "Let's 
play Rock-Paper-Scissors!\n"; 
24 
cout << "The first 
pl ayer to score 5 points 
wi ns.\n\n"; 
25 
26 
do 
27 
{ II Generate 
a random number 1 to 3 to simulate 
computer cho i ce 
28 
computerChoice 
= 1 + rand()% 
3; 
29 
30 
II Get pl ayer's 
choice 
31 
cout << "Pick 1 (rock}, 
2 (paper}, 
or 3 (scissors}: 
"· 
32 
ci n >> playerChoice; 
33 
34 
35 
36 
if (computerChoice 
== pl ayerCho i ce} 
{ 
cout << "I chose"<< 
name[computerCho i ce] 
<<" 
too, 
so we tied.\n\n"; 
} 
else 
i f ((playerChoice 
-- 1 && computerCho i ce 
(playerChoice 
-- 2 && computerCho i ce 
(playerChoice 
-- 3 && computerCho i ce 
{ 
cout << "I chose 
" << name[computerCho i ce] 
<< name[computerChoice
] << " beats 
" 
<< name[playerChoice
] << " . \n\n"; 
computerPo i nts+ +; 
} 
else 
-- 2) 11 
-- 3) I I 
-- 1 ) ) 
<< " ' so 
II Tie 
II Computer 
II wins 
I wi n! " 
II Pl ayer 
II wins 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
{ 
cout << "I chose"<< 
name[computerCho i ce] <<" 
so you wi n! " 
<< name[playerChoice
] <<" 
beats" 
<< name[computerChoice
] << ".\n\n"; 
50 
playerPo i nts+ +; 
51 
} 
52 
} whi le (playerPo i nts < 5 && computerPoints 
< 5); 
(program continues) 

Review Questions and Exercises 
589 
Program 8-35 
53 
(continued) 
54 
cout << "Let's 
see how you did :\n" 
55 
<< "You won"<< 
playerPo i nts <<" points 
and I won" 
56 
<< computerPoints 
<<" poi nts.\
n"; 
57 
58 
if (player Points == 5) 
59 
cout << "Congratu l at i ons! You' re the champ !\ n"; 
60 
else 
61 
cout << "Hurray for me! I'm the champ!\n"; 
62 
63 
return 
O; 
64 } 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. The ____ 
indicates the number of elements, or values, an array can hold. 
2. The size declarator must be a(n) ____ 
with a value greater than ___ 
_ 
3. Each element of an array is accessed and indexed by a number known as a(n) 
4. Subscript numbering in C++ always starts at ___ 
_ 
5. The number inside the brackets of an array definition is the ____ 
, but the 
number inside an array's brackets in an assignment statement, or any other 
statement that works with the contents of the array, is the ___ 
_ 
6. C++ has no array ____ 
checking, which means you can inadvertently store 
data past the end of an array . 
7. Starting values for the elements of an array may be specified with a(n) ___ 
_ 
list. 
8. If a numeric array is partially initialized, the uninitialized elements will be set to 
9. If the size declarator of an array definition is omitted, C++ counts the number of 
items in the ____ 
to determine how large the array should be. 
10. Look at the following array definition. 
double amount[5] ; 
A) How many elements does this array hold? 
B) What can you store in amount [ 5]? 
11. By using the same ____ 
for multiple arrays, you can build relationships 
between the data stored in the arrays . These arrays are referred to as parallel arrays. 
12. You cannot use the ____ 
operator to copy data from one array to another in 
a single statement. 

590 
Chapte r 8 
Arrays 
13. Arrays are never passed to functions by ____ 
because there would be too 
much overhead in copying all the elements. 
14. To pass an array to a function, pass the ____ 
of the array. 
15. A(n) ____ 
array is like several arrays of the same type put together. 
16. It's best to think of a two-dimensiona l array as having ____ 
and ___ 
_ 
17. To define a two-dimensional array, ____ 
size declarators are required. 
18. When initia lizing a two-dimensional 
array, it helps to enclose each row's 
initialization list in ----
19. When a two-dimensiona l array is passed to a function, the number of ___ 
_ 
must be specified. 
20. When you pass the name of an array as an argument to a function, you are actually 
passmg ___ 
_ 
21. Look at the following array definition. 
i nt values [1 OJ; 
A) How many elements does the array have? 
B) What is the subscript of the first element in the array? 
C) What is the subscript of the last element in the array? 
D) If an int uses four bytes of memory, how much memory does the array use? 
22. Given the following array definition: 
i nt values [5] = { 4, 7, 6, 8, 2 }; 
What does the following statement display? 
cout << values [4] << • 
• << (values [2] + values[3]) 
<< • 
• 
<< ++values[1] 
<< endl ; 
23. Look at the following array definition. 
i nt numbers [5] = { 1, 2, 3 }; 
A) What value is stored in numbers [ 2]? 
B) What value is stored in numbers [ 4]? 
24. Assume that array1 and array2 are both 25-element integer arrays . Indicate 
whether each of the following statements is legal or illegal. 
A) array1 = array2; 
B) cout << array1; 
C) cin >> array2; 
25. Assume that vec1 is an existing integer vector. Each of the following statements 
attempts to create a new integer vector, vec2. Indicate whether each of these 
statements is legal or illegal. 
A) vector<int> 
vec2; 
B) vector<int> 
vec2 ( 10); 
C) vector<int> 
vec2(10, 
100); 
D) vector<int> 
vec2(vec1); 
E) vector<int> 
vec2 ( vec1 . size()) 
; 
26. How do you establish a paralle l relationship between two or more arrays? 

27. Look at the following array definition. 
double sa l es [8] [10]; 
A) How many rows does the array have? 
B) How many columns does the array have? 
C) How many elements does the array have? 
Review Questions and Exercises 
591 
D) Write a statement that stores 3.52 in the last column of the last row in the array. 
Questions 28- 30 are for students who have covered Chapter 7 on classes and 
structures . These questions use the following Car structure declaration. 
struc t Car 
{ 
str i ng make, 
model; 
in t 
year; 
doub l e cos t ; 
/ / Constructors 
Car() 
{make= 
model=""; 
year= 
cost= 
O; } 
Car(string 
mk, str i ng md, in t yr, double c) 
{ make= mk; model = md; 
year= 
yr; 
cos t = c; } 
} ; 
28. Define an array named co 11 ect i on that holds 25 Car structures . 
29. Define an array named forSal e that holds 35 Car structures . Initialize the first 
three elements with the following data: 
Make 
Ford 
Honda 
Jeep 
Model 
Taurus 
Accord 
Wrangler 
Year 
2006 
2004 
2007 
Cost 
$21,000 
$11,000 
$24,000 
30. Write a loop that will step through the array you defined in question 29, displaying 
the contents of each element. 
Algorithm Workbench 
31. The arrays array1 and array2 each hold 25 integer elements. Write code that 
copies the values in array1 to array2. 
32. The following code totals the values in each of two arrays described in question 
31. Will the code print the correct total for both arrays? Why or why not? 
i nt total= 
O; 
i nt count; 
// Accumul at or 
/ / Loop counter 
// Cal culate 
and display 
the to t al of the f i rs t array. 
for (coun t = O; coun t < 25; count ++) 
t ot a l += array1[count]; 
cou t << "The total 
for array1 
i s" 
<< total 
<< end l ; 
// Cal culate 
and display 
the to t al of t he second array. 
for (coun t = O; cou nt < 25; count ++) 
t ot a l += array2[count]; 
co ut << "The total 
for array2 
i s"<< 
total<< 
end l ; 

592 
Chapte r 8 
Arrays 
33. In a program you need to store the names and popu lations of 12 countries. Create 
an appropriate array to store this information and then write the code needed to 
read the information into the array from a file named pop . dat . 
34. A weather ana lysis program uses the following array to store the temperature for 
each hour of the day on each day of a week. 
i nt temp [7] [24]; 
Each row represents a day (0 = Sunday, 1 = Monday, etc.) and each column 
represents a time (0 = midnight, 1 = 1 a.m ., .. . , 12 = noon, 13 = 1 p.m ., etc.). 
A) Write code to find Tuesday's average temperature . 
B) Write code to find the average weekly noon temperature . 
35. In a program you need to store the identification numbers of 10 employees (as i nt s) 
and their weekly gross pay (as doubl es). 
A) Define two arrays that may be used in paralle l to store the 10 emp loyee 
identification numbers and 10 weekly gross pay amounts . 
B) Write a loop that uses these arrays to print each employee's identification 
number and weekly gross pay. 
36. If you have covered Chapter 7, revise your answer to quest ion 35 as follows: 
A) Define and use an array of Payroll structures instead of two para llel arrays . A 
Payro 11 structure should hold an employee ID and a weekly gross pay amount. 
B) Define and use an array of Payrol l class objects instead of two parallel arrays 
or an array of Payrol l structures. 
Find the Errors 
37. Each of the following definitions has errors. Locate as many as you can. 
A) i nt si ze; 
doubl e val ues[si ze]; 
B) i nt collection
[-20]; 
C) i nt hours [3] = 8, 12 , 16; 
38. Each of the following definitions has errors. Locate as many as you can . 
A) i nt numbers [8] = {1, 2 ,, 
4,, 
5}; 
B) doubl e rat i ngs []; 
C) val ues[3 ] = {6, 8 .2, 
'A'}; 
39. Each of the following funct ions contains errors. Locate as many as you can. 
A) void showValues( i nt nums) 
{ 
} 
for (i nt count= 
O; count< 
8; count ++) 
cout << nums[count]; 
B) void showValues( i nt nums[4] []) 
{ 
} 
for (rows= O; rows< 
4; rows++) 
for (co l s= 
O; cols< 
5; cols ++) 
cout << nums[r ows] [cols ] ; 

VideoNote 
Solving the 
Chips and 
Salsa Problem 
Programming Challenges 
59 3 
Soft Skills 
Diagrams are an important means of clarifying many programming concepts. You have 
seen them used throughout this book to illustrate such things as how the flow of control 
works for various programming construc ts, how a program is broken into modules and 
those modules related, how data is stored in memory, and how data is organized. Once 
you have covered Chapter 7, your teacher may wish to assign Quest ion 40, which uses 
nested structures to organize a program's data. 
40. Here is a set of declarations that define how the data for a set of poker hands is 
organized. Create a neat diagram that illustrates this organiza tion. Figure 7-8 in 
Chapter 7 might give you an idea of how to begin. 
st ruc t CardStruc t 
{ in t 
fa ce ; 
char sui t ; 
II 
' s ' , 'h'
1 
'd', 
or ' c ' 
} ; 
st ruc t Pl ayerStruc t 
{ in t pl ayerNum; 
CardStruc t card[5]; 
} 
Pl ayerSt ruct playe r[ 4]; 
Programming 
Challenges 
Programm ing Challenges 1- 10 allow you to pract ice wor king with arrays witho ut 
using classes or stru ctures. Most of the problems beginning with Programming 
Challenge 11 use arrays with classes or structures . 
1 . Perfect Scores 
Write a modular program that accepts up to 20 integer test scores in the range of Oto 100 
from the user and stores them in an array. Then main should report how many perfect scores 
were entered (i.e., scores of 100), using a value-returning count Per fect function to help it. 
2. Larger Than n 
Create a program with a function that accepts three arguments: an integer array, an integer 
si ze that indicates how many elements are in the array, and an integer n. The function 
should display all of the numbers in the array that are greater than the number n. 
3. Roman Numeral Converter 
Write a program that displays the Roman numeral equivalent of any decimal number 
between 1 and 20 that the user enters. The Roman numerals should be stored in an array 
of strings, and the decimal number that the user enters should be used to locate the array 
element holding the Roman numera l equivalent. The program should have a loop that 
allows the user to continue entering numbers until an end sentinel of O is entered. 
4. Chips and Salsa 
Write a program that lets a maker of chips and salsa keep track of their sales for five 
different types of salsa they prod uce: mild, medium, sweet, hot, and zesty. It should use 
two parallel five-element arrays: an array of strings that holds the five salsa names and 

594 
Chapte r 8 
Arrays 
an array of integers that holds the number of jars sold during the past month for each 
salsa type. The salsa names should be stored using an initialization list at the time the 
name array is created. The program should prompt the user to enter the number of jars 
sold for each type. Once this sales data has been entered, the program should produce 
a report that displays sales for each salsa type, tota l sales, and the names of the highest 
selling and lowest selling products. 
5. Monkey Business 
A local zoo wants to keep track of how many pounds of food each of its three monkeys 
eats each day during a typical week. Write a program that stores this information in a 
two-dimensional 3 x 7 array, where each row represents a different monkey and each 
column represents a different day of the week. The program should first have the user 
input the data for each monkey. Then it should create a report that includes the 
following information: 
• Average amount of food eaten per day by the whole family of monkeys 
• The least amount of food eaten during the week by any one monkey 
• The greatest amount of food eaten during the week by any one monkey 
6. Rain or Shine 
An amateur meteorologist wants to keep track of weather conditions during the past 
year's three-month summer season and has designated each day as either rainy ('R'), 
cloudy ('C'), or sunny ('S'). Write a modu lar program that stores this information in 
a 3 x 30 array of characters, where the row indicates the month (0 = June, 1 = July, 
2 = August) and the column indicates the day of the month. Note that data is not 
being collected for the 31st of any month . The program should begin by calling a 
function to read the weather data in from a file. Then it should create a report that 
displays for each month and for the whole three-month period, how many days were 
rainy, how many were cloudy, and how many were sunny. To help it do this, it 
should use a value-returning function that is passed the array, the number of the 
month to examine, and the character to look for ('R', 'C', or 'S') . This function 
shou ld return the number of days the indicated month had the requested weather. 
Data for the program can be found in the Rai nOrShi ne. da t file located in the 
Chapter 8 programs folder on this book's companion website. 
7. Lottery 
Write a program that simulates a lottery. The program should have an array of five 
integers named wi nni ngDi gi ts, with a random ly generated number in the range of 0 
through 9 for each element in the array. The program should ask the user to enter five 
digits and should store them in a second integer array named pl ayer . The program must 
compare the corresponding elements in the two arrays and count how many digits match. 
For example, the following shows the wi nni ngDi gi ts array and the Pl ayer array with 
sample numbers stored in each. There are two matching digits, elements 2 and 4. 
Wi nningD i gi ts 
player 
7 
4 
4 
9 
2 
9 
1 
3 
7 
3 
Once the user has entered a set of numbers, the program should display the winning 
digits and the player's digits and tell how many digits matched. 

Programming Challenges 
595 
8. Rainfall Statistics 
Write a modular program that analyzes a year's worth of rainfall data. In addition to 
main, the program shou ld have a getData function that accepts the total rainfall for 
each of 12 month s from the user and stores it in a double array . It should also have 
four value-returning functions that compute and return to mai n the total Rainfall, 
averageRa i nfall , dr i estMont h, and wettestMonth. These last two functions return 
the number of the month with the lowest and highest rainfall amoun ts, not the amoun t 
of rain that fell those months. Not ice that this month numbe r can be used to obtain the 
amoun t of rain that fell those months. This informa tion should be used either by mai n 
or by a di spl ayReport funct ion called by main to print a summa ry rainfall report 
similar to the following: 
2015 Rain Report fo r Neversnows County 
Total ra i nfall: 
23 . 19 inches 
Average monthly rainfall: 
1.93 inches 
The least 
rain fel l in January wi th 0 .24 inches. 
The most rain fell 
i n April with 4 . 29 inches. 
9. Lo Shu Magic Square 
The Lo Shu Magic Square is a grid with thr ee rows and three columns that has the 
following propertie s: 
Figure 8-18 
• The grid contains the numbers 1 thr ough 9 exactly. 
• The sum of each row, each column, and each diagonal all add up to the same 
number. This is shown in Figure 8-18. 
)5 
4 
9 
2 -
15 
3 
5 
7 -15 
8 
1 6 , -
15 
I 
I 
I , 
15 
15 
15 
15 
Write a program that simulates a magic square using a two -dimensional 3 x 3 array. It 
should have a Boolean function i sMagi cSquare that accepts the array as an argument 
and returns tr ue if it determines it is a Lo Shu Magic Square and false if it is not. Test 
the program with one array, such as the one shown in Figure 8-18, that is a magic 
square and one that is not. 
10. Baseball Champions 
This challenge uses two files located in the Chap ter 8 programs folder on the book's 
companion website. 
• Teams. txt - Th is file contains an alphabetical list of a number of Major League 
baseball teams that have won the World Series at least once. 
• Wor l dSeri esWi nners. txt - This file contains a chronologica l list of World Series' 
winning teams from 1950 through 2014 . The first line in the file is the name of 
the team that won in 1950, and the last line is the name of the team that won in 
2014 . (Note that the World Series was not played in 1994. ) 

596 
Chapte r 8 
Arrays 
Write a program that reads the contents of each of these files into an array or vector. 
It should then display the contents of the Teams. txt file on the screen and prompt 
the user to enter the name of one of the teams. When the user enters a team name, 
the program should display the number of times that team has won the World Series 
in the time period from 1950 through 2014. 
11. Chips and Salsa Version 2 
Revise Programming Challenge 4 to use an array of Product 
objects instead of two 
parallel arrays. The Product class will need member variables to hold a product name 
and a quantity . 
12. Stats Class and Rainfall Statistics 
Create a Stats class whose member data includes an array capable of storing 30 double 
data values, and whose member functions include total, 
average, lowest, and highes t 
functions for returning information about the data to the client program. These are general 
versions of the same functions you created for Programming Challenge 8, but now they 
belong to the Stats class, not the application program. In addition to these functions, the 
Stats class should have a Boolean storeVal ue function that accepts a double value from 
the client program and stores it in the array. It is the job of this function to keep track of 
how many values are currently in the array, so it will know where to put the next value it 
receives and will know how many values there are to process when it is carrying out its 
other functions. It is also the job of this function to make sure that no more than 30 values 
are accepted. If the storeVa l ue function is able to successfully store the value sent to it, it 
should return t rue to the client program. However, if the client program tries to store a 
thirty-first value, the function should not store the value and should return false to the 
client program. 
The client program should create and use a Stats object to carry out the same rainfall 
analysis requested by Programming Challenge 8. Notice that the Stats object does no 1/0. 
All input and output is done by the client program. 
13. Stats Class and Track Statistics 
Write a client program that uses the Stats 
class you created for Programming 
Challenge 12 to store and analyze "best" 100-yard dash times for each of the 15 
runners on a track team. All 1/0 should be done by the client program. In addition to 
main, it should have two other functions: a getData function to accept input from the 
user and send it to the St ats object and a createReport 
function that creates and 
displays a report similar to the one shown here, 
Tulsa Tigers 
Track Team 
Average 
100 yard-dash 
time: 
11 . 16 seconds 
Slowest 
runner: 
Jack 
13.09 seconds 
Fastest 
runner: 
Wi 11 
10.82 seconds 

Programming Challenges 
597 
14. Character Converter Class 
Create a CharConverter class that performs various opera tions on strings . It shou ld 
have the following two public member functions to start with. Your instructor may ask 
you to add more functions to the class. 
• The uppercase member function accepts a string and returns a copy of it with all 
lowercase letters converted to uppercase. If a characte r is already uppercase or is 
not a letter, it should be left alone . 
• The properWords member function accepts a string of words separated by spaces 
and returns a copy of it with the first letter of each word converted to uppercase. 
Write a simple program that uses the class. It should prompt the user to input a string. Then 
it should call the properWords function and display the resulting string. Finally, it should 
call the uppercase function and display this resulting string. The program should loop to 
allow additional strings to be converted and displayed until the user chooses to quit. 
15. Driver 's License Exam 
The State Department of Motor Vehicles (DMV) has asked you to write a program 
that grades the written portion of the driver's license exam, which has 20 multiple-
choice questions . Here are the correct answers: 
1. B 
2 . D 
3.A 
4.A 
5.C 
6.A 
7 . 8 
B.A 
9.C 
10. D 
11 . B 
12.C 
13 .D 
14 .A 
15 .D 
16 .C 
17 . C 
18 .B 
19 .D 
20.A 
To do this, you should create a TestGrader class. Th e class will have an answers array 
of 20 characters, which holds the correct test answers. It will have two public member 
functions that enable user programs to interact with the class: setKey and grade. The 
setKey function receives a 20-characte r string holding the correct answers and copies 
this informat ion into its answers array. The grade function receives a 20-characte r 
array holding the test taker's answers and compares each of their answers to the correct 
one. An applicant must correctly answer 15 or more of the 20 questions to pass the 
exam. After "grading" the exam, the grade function should create and return to the 
user a string that includes the following informa tion: 
• A message indicating whether the applicant passed or failed the exam 
• The number of right answers and the number of wrong answers 
• A list of the question numbers for all incorrectly answered questions 
The client program that creates and uses a TestGrader object should first make a single call 
to setKey, passing it a string containing the 20 correct answers. Once this is done, it should 
allow a test taker's 20 answers to be entered, making sure only answers of A-D are accepted, 
and store them in a 20-character array. Then it should call the grade function to grade the 
exam and should display the string the function returns. The program should loop to allow 
additional tests to be entered and graded until the user indicates a desire to quit. 

598 
Chapte r 8 
Arrays 
16. Array of Payro 11 Objects 
Design a PayRol l class that has data members for an employee's hourly pay rate and 
number of hours worked . Write a program with an array of seven PayRol l objects. 
The program should read the number of hours each employee worked and their hourly 
pay rate from a file and call class functions to store this information in the appropriate 
objects. It shou ld then call a class function, once for each object, to return the 
employee's gross pay, so this informat ion can be displayed. Sample data to test this 
program can be found in the pay ro 11 . dat file located in the Chapter 8 programs folder 
on this book's companion website. 
17. Drink Machine Simulator 
Create a class that simulates and manages a soft drink machine . Information on each 
drink type should be stored in a structure that has data members to hold the drink 
name, the drink price, and the number of drinks of that type currently in the machine . 
The class should have an array of five of these structures, initialized with the following data. 
Drink N ame 
Cost 
Numb er in Machine 
Cola 
1.00 
20 
Root beer 
1.00 
20 
Orange soda 
1.00 
20 
Grape soda 
1.00 
20 
Bottled water 
1.50 
20 
The class should have two public member functions, di sp l ayChoi ces (which displays 
a menu of drink names and prices) and buy Drink (which handles a sale). The class 
should also have at least two private member functions, i nputMoney, which is called by 
buyDri nk to accept, validate, and return (to buyDri nk) the amount of money input, 
and dai l yReport, which is called by the destructor to report how many of each drink 
type remain in the machine at the end of the day and how much money was collected. 
You may want to use additional functions to make the program more modular. 
The client program that uses the class should have a main processing loop that calls the 
di s p l ayCho i ces class member function and allows the patron to either pick a drink or 
quit the program . If the patron selects a drink, the buyDri nk class member function is 
called to handle the actual sale. This function should be passed the patron's drink 
choice. Here is what the buyDr i nk function should do: 
• Call the i nputMoney function, passing it the patron's drink choice. 
• If the patron no longer wishes to make the purchase, return all input money. 
• If the machine is out of the requested soda, display an appropriate "sold out" 
message and return all input money. 
• If the machine has the soda and enough money was entered, complete the sale by 
updating the quant ity on hand and money collected information, calculating any 
change due to be returned to the patron, and delivering the soda. This last action 
can be simulated by printing an appropriate "here is your beverage" message. 

Programming Challenges 
599 
18. Bin Manager Class 
Design and write an object -oriented program for managing inventory bins in a warehouse. 
To do this you will use two classes: I nvBin and BinManager. The InvBi n class holds 
information abou t a single bin. The Bi nManager class will own and manage an array of 
I nvBi n objects . Here is a skeleton of what the InvBi n and Bi nManager class declarations 
should look like: 
class 
InvBin 
{ 
} ; 
private: 
str i ng descr i ption; 
in t qty; 
publ ic : 
II Item name 
II Quantity 
of it ems 
II in t his bin 
InvBin (string 
d = "empty", in t q = 0) II 2-parame ter constructor 
{ 
description= 
d; 
qty= 
q; ) 
// with default 
va lue s 
II It will 
also have the following 
public member functions. 
They 
// wil l be used by the BinManager class
, not the client 
program. 
void setDescript
ion (s t ring d ) 
str i ng getDescription
() 
void setQty( i nt q) 
in t get Qty ( ) 
class 
BinManager 
{ 
} ; 
private: 
InvBin bin[30]; 
in t numBins; 
public: 
Bi nManager() 
{ 
numBins = O; } 
II Array of InvBi n objects 
II Number of bins 
II curren t ly i n use 
II Default 
constructor 
BinManager(int size, 
str ing d(J , int q[J) II 3-parameter constructor 
{ 
II Receives number of bins in use and parallel 
arrays of item names 
II and quantities. 
Uses th is i nfo . to store values in the elements 
II of the bin array. Remember, these elements are InvBin objects. 
} 
II The class will also have the following 
string getDescription(int 
i ndex) 
int getQuantity(int 
index) 
bool addParts(int 
binlndex, 
i nt q) 
bool removeParts(int 
binlndex, 
int q) 
public member functions: 
II Returns name of one item 
II Returns qty of one item 
II These return true if t he 
II action was done and false 
// if it could not be done-
// see validation 
information 

600 
Chapte r 8 
Arrays 
Client Program 
Once you have created these two classes, write a menu-driven client program that uses 
a Bi nManager object to manage its warehouse bins. It should initialize it to use nine of 
the bins, holding the following item descriptions and quantities. The bin index where 
the item will be stored is also shown here. 
1. regular pliers 25 
4. p. head screw driver 6 
7. drill 51 
2. n. nose pliers 5 
5. wrench-large 7 
8. cordless drill 16 
3. screwdriver 25 
6. wrench-small 18 
9. hand saw 12 
The modular client program should have functions to display a menu, get and validate 
the user's choice, and carry out the necessary activities to handle that choice. This 
includes adding items to a bin, removing items from a bin, and displaying a report of 
all bins. Th ink about what calls the di spl ayRepor t client function will need to make 
to the Bi nManager object to create this report. When the user chooses the "Quit" 
option from the menu, the program should call its di sp l ayRepor t function one last 
time to display the final bin information. All 1/0 should be done in the client class. The 
Bi nManager class only accepts informa tion, keeps the array of I nvBi n objects up to 
date, and returns information to the client program . 
Input Validation: The Bi nManage r class functions should not accept numbers less 
than 1 for the number of parts being added or removed from a bin. They should 
also not allow the user to remove more items from a bin than it currently holds. 
Group Projects 
19. Tic-Tac-Toe Game 
Write a modular program that allows two players to play a game of tic-tac-toe. Use a 
two-dimensiona l char array with three rows and three columns as the game board. 
Each element of the array should be initialized with an asterisk ("). The program should 
display the initial board configurat ion and then start a loop that does the following: 
• Have player 1 select a board location for an X by entering a row and column 
number. Then redisplay the board with an X replacing the '' in the chosen location. 
• If there is no winner yet and the board is not yet full, have player 2 select a board 
location for an O by entering a row and column number. Then redisplay the 
board with an O replacing the '' in the chosen location. 
The loop should continue until a player has won or a tie has occurred, then display a 
message indicating who won, or reporting that a tie occurred . 
• Player 1 wins when there are three Xs in a row, a column, or a diagonal on the 
game board . 
• Player 2 wins when there are three Os in a row, a column, or a diagonal on the 
game board . 
• A tie occurs when all of the locations on the board are full, but there is no winner. 
Input Validation: Only allow legal moves to be entered. The row and column must 
be 1, 2, or 3. The selected board location must currently be empty (i.e., still have an 
asterisk in it). 

Programming Challenges 
601 
20. Theater Ticket Sales 
Create a Ti cketManager class and a program that uses it to sell tickets for a single 
performance theater production. This project is intended to be designed and written by 
a team of two to four students. Here are some suggestions: 
• One student might design and write the client program that uses the class, while 
other team members design and write the Ti cketManager class and all of its 
functions. 
• Each student should be given about the same workload. 
• The class design and the names, parameters, and return types of each function 
should be decided in advance. 
• The project can be implemented as a multifile program, or all the functions can 
be cut and pasted into a single file. 
Here are the specifications: 
• The theater's auditor ium has 15 rows, with 30 seats in each row. To represent the 
seats, the Ti cketManager 
class shou ld have a two-dimensional 
array of 
SeatStructures. 
Each of these structures should have data members to keep 
track of the seat's price and whether or not it is available or already sold. 
• The data for th e program is to be read in from two files located in th e 
Chapter 8 programs folder on this book's companion website. The first one, 
SeatPri ces. dat, contains 15 values representing the price for each row. All 
seats in a given row are the same price, but different rows have different prices. 
The second file, SeatAvai l abil i ty. dat, holds the seat availability information. 
It contain s 450 characte rs (15 rows with 30 characters each), indicating which 
seats have been sold (' • ') and which are available ( '#' ). Initially all seats are 
available . However, once the program run s and the file is updated, some of the 
seats will have been sold . The obvious function to read in the data from these 
files and set up the array is the constructor that runs when the Ti cketManager 
object is first created. 
• The client program shou ld be a menu-driven program that provides the user 
with a menu of box office options, accepts and validates user inputs, and calls 
appropria te class functions to carry out desired tasks. The menu should have 
options to display the seating chart, request tickets, print a sales report, and exit 
the program. 
• When the user selects the display seats menu option, a Ti cketManager function 
shou ld be called that creates and returns a string holding a char t, similar to 
the one shown here. It should indicate which seats are already sold ( *) and 
which are still ava ilable for purchase (#) . The client program shou ld th en 
display the string. 

602 
Chapte r 8 
Arrays 
Seats 
1234567890 12345678901234567890 
Row 1 
***###***###******############ 
Row 2 
####*************####*******## 
Row 3 
**###**********########****### 
Row 4 
**######**************##****** 
Row 5 
********#####*********######## 
Row 6 
##############************#### 
Row 7 
#######************########### 
Row 8 
************##****############ 
Row 9 
#########*****############**** 
Row 10 
#####*************############ 
Row 11 
#**********#################** 
Row 12 
#############********########* 
Row 13 
###***********########**###### 
Row 14 
############################## 
Row 15 
############################## 
• When the user selects the request tickets menu option , the program should 
prompt for the number of seats the patron wants, the desired row number, 
and the desired starting seat number. A Ti cke tMa nager ticket request function 
should then be called and passed this information so that it can handle the 
ticket request. If any of the requested seats do not exist, or are not available, 
an appropriate message should be returned to be displayed by the client 
program. If the seats exist and are available, a string should be created and 
returned that lists the number of requested seats, the price per seat in the 
requested row, and the total price for the seats. Then the user program should 
ask if the patron wishes to purchase these seats. 
• If the patron indicates they do want to buy the requested seats , a 
Ti cketManager 
purchase tickets module should be called to handle the actual 
sale. This module must be able to accept money, ensure that it is sufficient to 
continue with the sale, and if it is, mark the seat(s) as sold, and create and 
return a string that includes a ticket for each seat sold (with the correct row, 
seat number, and price on it). 
• When the user selects the sales report menu option, a Ti cketManager 
report 
module should be called. This module must create and return a string holding 
a report that tells how many seats have been sold, how many are still 
available, and how much money has been collected so far for the sold seats. 
Think about how your team will either calculate or collect and store this 
information so that it will be available when it is needed for the report. 
• When the day of ticket sales is over and the quit menu choice is selected, the 
program needs to be able to write the updated seat availability data back out 
to the file. The obvious place to do this is in the TicketMa
nage r destructor. 

TOPICS 
9.1 
Introduction to Search Algo rithms 
9.5 
Sorting and Searching Vectors 
9.2 
Searching an Array of Objects 
9.6 
Introduction to Analysis of Algorithms 
9.7 
Case Studies 
9.3 
Introduction to Sorting Algorithms 
9.4 
Sorting an Array of Objec ts 
9.8 
Tying It All Together: Secret Messages 
9.1 
Introduction to Search Algorithms 
CONCEPT: 
A search algorithm is a method of locating a specific item in a collection 
of data. 
It's very common for programs not only to store and process data stored in arrays, but to 
search arrays for specific items. This section will show you two methods of searching an 
array: the linear search and the binary search. Each has its advantages and disadvantages. 
The Linear Search 
The linear search is a very simple algorithm. Sometimes called a sequential search, it uses 
a loop to sequentially step through an array, starting with the first element. It compares 
each element with the value being searched for, and it stops when either the value is 
found or the end of the array is encountered. If the value being searched for is not in the 
array, the algorithm will search to the end of the array . 
60 3 

604 
Chapter9 
0 
Searching, Sorting, and Algorithm Analysis 
Here is the pseudocode for a function that performs the linear search : 
Set found to false 
Set position 
to - 1 
Set index to 0 
While index< 
number of elements 
and found is false 
If list[index] 
is equal to search value 
found = true 
position= 
index 
End If 
Add 1 to index 
End While 
Return position 
Th e function searchl i st, which follows, is an examp le of C++ code used to perform a 
linear search on an int eger array . Th e array l i st, which has a maximum of size 
elements, is searched for an occurrence of the number stored in value. If the number is 
found , its array subscript is returned. Otherwise, - 1 is returned, indicating the value did 
not appear in the array. 
int 
searchlist(const 
i nt lis t [] , int size , i nt value) 
{ 
) 
i nt i ndex= 
O; 
II Used as a subscript 
to search 
array 
int 
position
= - 1; 
bool found= 
false; 
II Used to record 
position 
of search 
value 
II Flag to indicate 
if the value was found 
whi le (i ndex< 
size && !foun d) 
{ 
) 
i f (lis t[index
] == value) 
{ 
) 
found
= true; 
position
= index; 
i ndex ++ ; 
return 
position; 
II If the value is found 
I I Set the fl ag 
II Record the value's 
subscript 
II Go to the next ele ment 
II Return the pos i t i on, or - 1 
NOTE: 
Th e reason -1 is chosen to indicate that the search value was not found in 
the array is that - 1 is not a valid subscript. Any other nonvalid subscript value 
could also have been used to signal this. 
Program 9-1 is a comp lete program that uses the searchl i st function . It searches the 
five-element tests 
array to find a score of 100. 
Program 9-1 
1 II Thi s program demonstrates 
the searchlist 
function, 
2 II whi ch perfo rms a linear 
search 
on an integer 
array . 
3 #include 
<iostream> 
4 using namespace std ; 
5 
(program continues) 

9.1 Introduction to Search Algorithms 
605 
Program 9-1 
(continued) 
6 II Function 
prototype 
7 int searchL i st (c onst int 
[ ] , int, 
int); 
8 
9 const 
int SIZE = 5 ; 
10 
11 int main() 
12 { 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 } 
30 
int tests[SIZE
] = 
int results; 
{87, 75, 98, 100, 82}; 
II Holds the search 
results 
II Search the array 
for the value 100 
results
= searchList(tests, 
SIZE, 100) ; 
II If searchList 
returned 
- 1, 100 was not found 
if (results
== - 1) 
cout << "You did not earn 100 points 
on any test
. \n"; 
else 
{ 
II Otherw i se results 
contains 
the subscript 
of 
II the first 
100 found in the array 
} 
cout << "You earned 100 poi nts on test"· 
cout <<(results+ 
1} << ".\n"; 
return 
O; 
31 /****************************************************************** 
32 
33 
34 
35 
36 
* 
* 
* 
* 
* 
searchList 
* 
This function 
performs 
a linear 
search 
on an integer 
array. 
* 
The l i st array, 
whi ch has si ze elements, 
is searched 
for 
* 
the number stored 
i n value. 
If the number i s found, 
its 
array 
* 
subscript 
is returned
. Otherwi se, - 1 is returned. 
* 
37 
******************************************************************/ 
38 int searchL i st (c onst int l i st[], 
i nt size, 
int value) 
39 { 
40 
41 
42 
43 
int index= 
O; 
II Used as a subscript 
to search 
array 
int position= 
- 1; 
bool found= 
false; 
II Used to record 
position 
of search 
value 
II Flag to i ndicate 
if the value was found 
44 
while 
(index< 
size && !found) 
45 
{ 
} 
i f (list[
i ndex] == value) 
{ 
} 
found= 
true; 
position= 
index; 
i ndex ++; 
46 
47 
48 
49 
50 
51 
52 
53 
54
} 
return 
pos i t i on; 
Program Output 
You earned 100 points 
on test 
4. 
II If the value is found 
I I Set the flag 
II Record the value's 
subscr i pt 
II Go to the next element 
II Return the position
, or - 1 

606 
Chapter9 
a 
VideoNot e 
Performing a 
Binary Search 
Searching, Sorting, and Algorithm Analysis 
Inefficiency of the Linear Search 
The advantage of the linear search is its simplicity. It is very easy to understand and 
implement . Furthermore, it doesn't require the data in the array to be stored in any 
part icular order. Its disadvantage, however, is its inefficiency . If the array being 
searched contained 20,000 elements, the algorithm would have to look at all 20,000 
elements in order to find a value stored in the last element or to determ ine that a 
desired element was not in the array . 
In a typical case, an item is just as likely to be found near the beginning of the array as 
near the end. On average, for an array of N items, the linear search will locate an item 
in N/2 attempts . If an array has 20,000 elements, the linear search will make a 
comparison with 10,000 of them on average . This is assuming, of course, that the 
search item is consistently found in the array. (N/2 is the average number of 
comparisons. The maximum number of comparisons is always N .) 
When the linear search fails to locate an item, it must make a comparison with every 
element in the array . As the number of failed search attempts increases, so does the 
average number of comparisons . When it can be avoided, the linear search should not 
be used on large arrays if speed is important . 
The Binary Search 
The binary search is a clever algorithm that is much more efficient than the linear 
search. Its only requirement is that the values in the array be in order. Instead of 
testing the array's first element, this algorithm starts with the element in the middle. 
If that element happens to contain the desired value, then the search is over. Otherwise, 
the value in the middle element is either greater than or less than the value being 
searched for. If it is greater than the desired value, then the value (if it is in the list) 
will be found somewhere in the first half of the array. If it is less than the desired 
value, then the value (again, if it is in the list) will be found somewhere in the last half 
of the array. In either case, half of the array's elements have been eliminated from 
further searching . 
If the desired value wasn't found in the middle element, the procedure is repeated for 
the half of the array that potentially conta ins the value. For instance, if the last half of 
the array is to be searched, the algorithm immediately tests its middle element. If the 
desired value isn't found there, the search is narrowed to the quarter of the array that 
resides before or after that element. This process continues until the value being 
searched for is either found or there are no more elements to test. 
Here is the pseudocode for a function that performs a binary search on an array whose 
elements are stored in ascending order. 
Set first 
to O 
Set last 
to the last 
subscript 
in the array 
Set found to false 
Set position 
to - 1 

9.1 Introduction to Search Algorithms 
607 
Whi1e found is not true and first 
is Jess than or equa1 to 1ast 
Set midd1e to the subscript 
halfway between first 
and 1ast 
If array[midd1e] 
equa1s the desired 
va1ue 
Set found to true 
Set position 
to midd1e 
E1se If array[midd1e] 
is greater 
than the desired 
va1ue 
Set Jast to midd1e - 1 
E1se 
Set first 
to midd1e + 1 
End If 
End Whi1e 
Return position 
Thi s algorithm uses three index variables: first
, 1 ast, and mi ddle. The first 
and 
1 ast variables mark the boundaries of the portion of the array currently being searched. 
Th ey are initialized with the subscripts of the array's first and last elements . Th e 
subscript of the element approximately halfway between first 
and 1 ast is calculated 
and stored in the mi ddle variable. If there is no precisely central element, the integer 
division used to calculate middle will select the element immediately preceding the 
midpoint. If the element in the middle of the array does not contain the search value, 
the first 
or 1 ast variables are adjusted so that only the top or bottom half of the 
array is searched during the next iteration. Thi s cuts the portion of the array being 
searched in half each time the loop fails to locate the search value. 
The function bi narySearch in the following example C++ code is used to perform a binary 
search on an integer array. The first parameter, array, which has size elements, is searched 
for an occurrence of the number stored in value . If the number is found, its array subscript 
is returned. Otherwise, -1 is returned, indicating the value did not appear in the array . 
i nt binarySearch
(const i nt array[], 
i nt size, 
int value) 
{ 
} 
int 
first 
= 0, 
last 
= size -
1 ' 
middle, 
position
= - 1; 
bool found = false ; 
while (!foun d && f ir st<= 
last) 
{ 
middle
= (first+ 
last) 
I 2 ; 
if (array[middle
] == value) 
{ 
} 
found = true; 
position
= middle; 
II First 
array element 
II Last array element 
II Midpoint of search 
II Position 
of search value 
II Flag 
II Calculate 
mi dpoi nt 
II If value is found at mid 
else 
if (array[ middle] 
> value) 
II If value is in lower half 
last= 
middle -
1; 
else 
first
= mi ddle+ 
1; 
II If value is in upper half 
} 
return 
position; 

608 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Progr am 9-2 is a complete progr am using the bi narySearch 
function. It searches an 
array of emp loyee ID numbers for a specific value. 
Program 9-2 
1 II Thi s program performs 
a binary 
search on an integer 
2 II array whose elements 
are in ascending 
order . 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 int bi narySearch(const 
int 
[], 
int, 
int); 
8 
9 const 
int SIZE= 20 ; 
10 
11 int main() 
12 { 
13 
II Create 
an array of ID numbers sorted 
in ascending 
order 
14 
int IDnums[SIZEJ = { 101, 
142, 147, 189, 
199, 207 , 222, 
15 
234 , 289 , 296, 310, 319, 
388, 394, 
16 
417, 429 , 447, 521 , 536 , 600 }; 
17 
18 
19 
20 
int empID, 
results; 
II Holds the ID to search 
for 
II Holds the search 
results 
21 
II Get an employee ID to search 
for 
22 
cout << "Enter the employee ID you wi sh to search 
for: 
"· 
23 
cin 
>> empID; 
24 
25 
II Search for the ID 
26 
results= 
binarySearch
(IDnums , SIZE, empID); 
27 
28 
II If binarySearch 
returned 
- 1, the ID was not found 
29 
if (results== 
- 1) 
30 
cout << "That number does not exist 
in the array.\n"; 
31 
else 
32 
{ 
II Otherwise 
results 
contains 
the subscript 
of 
33 
II the specified 
employee ID i n the array 
34 
cout <<"ID"<< 
empID <<"was 
found in element
" 
35 
<<results<<" 
of the array.\n"; 
36 
} 
37 
return 
O; 
38 } 
39 
40 /**************************************************************** 
41 * 
binarySearch 
42 * This function 
performs 
a binary 
search on an integer 
array 
43 * with size elements 
whose values 
are stored 
in ascend i ng 
44 *order.The 
array 
is searched 
for the number stored 
in the 
45 * value parameter. 
If the number is found, 
its 
array 
subscript 
46 * is returned. 
Otherwise , - 1 is returned
. 
* 
* 
* 
* 
* 
* 
47 *****************************************************************/ 
(program continues) 

9.1 Introduction to Search Algorithms 
609 
Program 9-2 
(continued) 
48 int bi narySearch(const 
int array (] , int size , int value) 
49 { 
50 
int 
first 
= 0, 
II First 
array 
element 
II Last array 
element 
II Midpoint of search 
51 
52 
53 
54 
55 
last
= size -
1, 
middle , 
position
= - 1; 
bool found = false; 
II Position 
of search 
value 
II Flag 
56 
while 
(!found && first<= 
l ast ) 
57 
{ 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
) 
mi ddle= 
(first+ 
last ) I 2 ; 
if (ar ray[ middle ] == value) 
{ 
} 
found = true; 
position
= middle ; 
else 
i f (array[
mi ddle] 
> value) 
last= 
middle -
1; 
else 
first
= mi ddle+ 
1; 
II Calculate 
mi dpoint 
II 
If value i s found at mi d 
II If value i s in l ower half 
II 
If value is in upper half 
69 
return 
position; 
70
} 
Program Output with Example Input Shown in Bold 
Enter the employee ID you wish to search 
for: 
199 [Enter] 
ID 199 was found in element 4 of the array. 
The Efficiency of the Binary Search 
Obviously, the binary search is much more efficient than the linear search. Every time it 
makes a comparison and fails to find the desired item, it eliminates half of the remaining 
portion of the array that must be searched . For example, consider an array with 20,000 
elements. If the binary search fails to find an item on the first attempt, the number of 
elements that remains to be searched is 10,000. If the item is not found on the second 
attempt, the number of elements that remains to be searched is 5,000 . This process 
continues until the binary search locates the desired value or determines that it is not in 
the array . With 20,000 elements in the array, this takes a maximum of 15 comparisons. 
(Compare this to the linear search, which would make an average of 10,000 comparisons!) 
Powers of 2 are used to calculate the maximum number of compar isons the binary 
search will make on an array of any size. (A power of 2 is 2 raised to some integer 
exponent.) Simply find the smallest power of 2 that is greater than the number of 
elements in the array . That will tell you the maximum number of comparisons needed 
to find an element or to determine that it is not present . For examp le, a maximum 
of 16 comparisons will be made to find an item in an array of 50,000 elements 
(216 = 65,536), and a maximum of 20 comparisons will be made to find an item in an 
array of 1,000,000 elements (220 = 1,048,576). 

610 
Chapter9 
9.2 
Searching, Sorting, and Algorithm Analysis 
Searching an Array of Objects 
CONCEPT: 
Linear and binary searches can also be used to search for a specific entry 
in an array of objects or structur es. 
In Programs 9-1 and 9-2 we searched for a particular value in an array of integers . We 
can just as easily search through an array holding values of some other data type, such 
as double or st ring. We can even search an array of objects or structures. In this case, 
however, the search value is not the entire object or structure we are looking for, but 
rather a value in a particular member variable of that object or structure. The member 
variable being exam ined by the search is sometimes called the key field, and the 
particular value being looked for is called the search key. 
Assume we have a class named Inven t ory that includes the following member variables 
stri ng itemCode; 
stri ng descript
i on ; 
double price; 
as well as methods to set and get the value of each of these. Assume also that we have 
set up an array of I nventory objects. We might want to search for a particular object in 
the array, say the object whose i t emCode is K33, so that we can then call the getPri ce 
method for that object. Program 9-3 illustrates how to do this. It searches the array of 
Invent ory objects using a search function similar to the searchL i st function we used earlier 
in this chapter. However, it has been modified to work with an array of Inventory objects. 
Program 9-3 
1 II This program searches 
an array of Inventory 
obj ect s to get 
2 II t he price of a particular 
object. 
It demonstrates 
how to 
3 II perfor m a linear 
searc h using an array of obj ects . 
4 #include 
<i ost ream> 
5 #include 
<st ring> 
6 using namespace std; 
7 
8 II I nventory 
class 
declara t ion 
9 class 
Inve nt ory 
10 { 
private: 
11 
str i ng it emCode; 
12 
str i ng descr i ption; 
13 
double price; 
public: 
14 
15 
16 
17 
Inventory() 
{ it emCode = "XXX"; 
II Defaul t constructor 
descr i ption=" 
"; 
pr i ce= 
0 .0; 
} 
18 
19 
Inventory(string 
c, st ring d , double p} II 3 argument construc t or 
20 
{ it emCode = c; 
21 
descrip t ion= 
d; 
22 
pr i ce= 
p; 
23 
} 
24 
25 
II Add methods set Code, setOescri
pti on, and setPrice 
here. 
(program continues) 

9.2 Searching an Array of Objects 
611 
Program 9-3 
26 
(continued) 
27 
II Get funct i ons to retrieve 
member variable 
values 
28 
str i ng getCode() 
const 
29 
{ string 
code = itemCode; 
30 
return 
code ; 
31 
} 
32 
33 
str i ng getDescript
i on () const 
34 
{ string 
d = description
; 
35 
return 
d; 
36 
} 
37 
38 
double getPr i ce() 
const 
39 
{ return 
pr i ce; 
40 
} 
41 
42 } ; I I End Inventory 
cl ass declarat
i on 
43 
44 II Program that 
uses the Inventory 
class 
45 
46 II Funct i on prototype 
47 int search(const 
Inventory[], 
int, 
str i ng}; 
48 
49 /******************************************************* 
50 
* 
main 
* 
51 
*******************************************************/ 
52 int main() 
53 { 
54 
55 
const 
int SIZE = 6 ; 
II Create 
and in i tialize 
the array of Inventory 
objects 
Inventory 
silverware[SIZEJ 
= 
{ Inventory("S15", 
"sou p spoon", 
Inventory("S12", 
"teaspo on", 
Inventory
("F 15", "dinner 
fork", 
Inventory
("F0 9", "salad 
fork" 
, 
Inventory("K33", 
"knife", 
Inventory("K41", 
"st eak knife", 
II The itemCode to search 
for 
2 .35), 
2 .19), 
3 .19), 
2 .25), 
2 .35), 
4.15) 
}; 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
string 
desiredCode
; 
int pos; 
char doAgain; 
II Pos i t i on of desired 
object 
i n the array 
II Look up another 
pr i ce (YIN)? 
69 
do 
70 
{ II Get the i temCode to search 
for 
71 
cout << "\nEnter 
an item code: •· 
72 
cin 
>> desiredCode; 
73 
74 
II Search for the object 
75 
pos = search(silverware, 
SIZE, des i redCode ); 
76 
77 
II If pos = - 1 , the code was not found 
78 
i f (pos --
- 1) 
79 
cout << "That code does not exist 
in the array\n"; 
80 
else 
(program continues) 

612 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Program 9-3 
(continued) 
81 
{ II The object 
was found, 
so use pos to get the 
price 
82 
83 
84 
85 
86 
II descr i ption and 
cout << "This • 
<< si lverware[pos].getDescr
i ption() 
<< • costs 
$" << silverware[pos].getPrice() 
<< endl; 
) 
87 
II Does the user want to look up another 
pr i ce? 
88 
cout << "\nlook 
up another 
price 
(YIN)?" · 
89 
cin 
>> doAgai n; 
90 
91 
) while 
(doAgai n --
'Y' 
11 doAgain --
'y' 
) ; 
92 
return 
O; 
93 }II End mai n 
94 
95 /************************************************************** 
96 
* 
search 
97 
* This function 
performs 
a linear 
search on an array 
of 
98 
* Inventory 
objects
, using itemCode as the key f i eld. 
99 
* If the desired 
code i s found, 
its 
array 
subscr i pt i s 
100 
* returned
. Otherwi se, - 1 is returned. 
* 
* 
* 
* 
* 
101 
**************************************************************/ 
102 
int search(const 
Inventory 
object[]
, i nt size, 
str i ng value) 
103 
{ 
104 
105 
106 
107 
i nt i ndex = 0; 
i nt position
= - 1; 
bool found= 
false; 
II Used as a subscript 
to search 
array 
II Used to record 
position 
of search 
value 
II Flag to i ndicate 
i f the value was found 
108 
while 
(index< 
size && !found) 
109 
{ 
110 
if (object[index
] .getCode() 
== value) 
II If the value is found 
111 
{ 
} 
found = true; 
position
= index; 
112 
113 
114 
115 
index+ +; 
116 
} 
117 
return 
position; 
118 
}II 
End search 
I I Set the flag 
II Record the value's 
subscript 
II Go to the next element 
II Return the posit i on, or - 1 
Program Output with Example Input Shown in Bold 
Enter an item code: 
FlS[Enter] 
This dinner 
fork costs 
$3.19 
Look up another 
price 
(YIN)? n[Ent er] 
Recall from Chapter 7 that when an object is passed to a function as a constant reference, 
any of the object's member functions that the receiving function will call must also be 
defined with the key word const . Thi s is also the case when an array of objects is passed 
to a function. In Program 9-3 the search function uses a const array parameter to receive 
the array of Inventory objects in order to safeguard it from any changes being made to 
it. Th erefore, the Inventory class member functions it calls are also declared to be const. 

9.3 Introduction to Sorting Algorithms 
613 
~ 
Checkpoint 
a 
VideoNot e 
Sorting a Set 
of Data 
9.1 
Describe the difference between the linear search and the binary search . 
9.2 
On average, with an array of 1,000 elements, how many comparisons will the 
linear search perform? (Assume the items being search for are consistently found 
in the array .) 
9.3 
With an array of 1,000 elements, what is the maximum number of compar isons 
the binary search will perform? 
9.4 
If a linear search is performed on an array, and it is known that some items are 
searched for more frequently than others, how can the contents of the array be 
reordered to improve the average performance of the search? 
Introduction to Sorting Algorithms 
CONCEPT : Sorting algorithms are used to arrang e data into some order. 
Often the data in an array must be sorted in some order. Customer lists, for instance, are 
commonly sorted in alphabetical order. Student grades might be sorted from highest to 
lowest. Mailing label records could be sorted by ZIP code. To sort the data in an array, the 
programmer must use an appropriate sorting algorithm. A sorting algorithm is a technique 
for scanning through an array and rearranging its contents in some specific order. This 
section will introduce two simple sorting algorithms: the bubble sort and the selection sort. 
The Bubble Sort 
The bubble sort is an easy way to arrange data in ascending or descending order . 
Sortin g data in ascending order means placing the values in order from lowest to 
highest . Sorting in descend ing orde r means placing them in order from highest to 
lowest. Bubble sort works by comparing each element in the array with its neighbor 
and swapping them if they are not in the desired order. Let's see how it arranges the 
following array's elements in ascending order: 
7 
2 
3 
8 
9 
1 
Element O 
El ement 1 
Element 2 
Element 3 
Element 4 
Ele ment 5 
The bubble sort starts by comparing the first two elements in the array. If element O is 
greater than element 1, they are exchanged. After the exchange, the array appears as 
2 
7 
3 
8 
9 
1 
Element O 
El ement 1 
Element 2 
Element 3 
Element 4 
Ele ment 5 
This process is repeated with elements 1 and 2. If element 1 is greater than element 2, 
they are exchanged . The array now appears as 
2 
3 
7 
8 
9 
1 
Element O 
El ement 1 
Element 2 
Element 3 
Element 4 
Ele ment 5 
Next, elements 2 and 3 are compared . However, in this array, these two elements are 
already in the proper order (element 2 is less than element 3), so no exchange takes place. 

614 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
As the cycle contin ues, elements 3 and 4 are compared . Once again, because they are 
already in the proper order, no exchange is necessary. When elements 4 and 5 are 
compared, however, an exchange must take place because element 4 is greater than 
element 5. The array now appears as 
2 
3 
7 
8 
1 
9 
Element O 
Element 1 
Element 2 
Element 3 
Element 4 
Element 5 
At this point, the entire array has been scanned. This is called the first pass of the sort. Notice 
that the largest value is now correctly placed in the last array element. However, the rest of 
the array is not yet sorted. So the sort startS over again with elements O and 1. Because they 
are in the proper order, no exchange takes place. Elements 1 and 2 are compared next, but 
once again, no exchange takes place. This continues until elements 3 and 4 are compared. 
Because element 3 is greater than element 4, they are exchanged. The array now appears as 
2 
3 
7 
1 
8 
9 
Element O 
Element 1 
Element 2 
Element 3 
Element 4 
Element 5 
Notice that this second pass over the array elements has placed the second largest 
number in the next to the last array element. This process will contin ue, with the sort 
repeated ly passing through the array and placing at least one number in order on each 
pass, until the array is fully sorted. Ultimately, the array will appear as 
1 
2 
3 
7 
8 
9 
Element O 
Element 1 
Element 2 
Element 3 
Element 4 
Element 5 
Here is the bubble sort in pseudocode. Notice that it uses a pair of nested loops . The 
outer loop, a do-while 
loop, iterates once for each pass of the sort . The inner loop, a 
for loop, holds the code that does all the comparisons and needed swaps during a pass. 
Do 
Set madeAswap f1ag to fa1se 
For count= 
0 to the next-to-Jast 
array subscript 
If array[count] 
is greater 
than array[count 
+ 1] 
Swap the contents 
of array[count] 
and array[count 
+ 1] 
Set madeAswap f1ag to true 
End If 
End For 
Whi1e the madeAswap f1ag is true 
Notice that the first statement in the do-while 
loop sets a flag variable named madeAswap to 
false. This is because no swaps have been made yet on the pass that is just beginning. When 
anything is found to be out of order on this pass, the inner loop swaps two values and sets 
madeAswap to true. The test condition at the bottom of the do-wh i le loop checks to see if 
madeAswap has become true. If it has, this loop iterates again. However, if it checks and finds 
that madeAswap is still false, it knows that nothing was swapped on the pass just ending. This 
means that the array is now in order, and no more passes are needed. So the loop is exited. 
Th e following C++ code implements the bub ble sort as a function. Th e parameter 
array references an integer array to be sorted . The parameter size contains the number 
of elements in array. 

9.3 Introduction to Sorting Algorithms 
615 
voi d sortArray
(i nt array[], 
int size) 
{ 
} 
int temp; 
bool madeAswap; 
do 
{ madeAswap = false; 
for (i nt count= 
O; count< 
(si ze -
1); count ++) 
{ 
} 
if (array[ count] 
> array[count 
+ 1] ) 
{ 
} 
temp= array[count
] ; 
array[count] 
= array[count 
+ 1] ; 
array[count 
+ 1] = temp; 
madeAswap = true; 
} while (madeAswap); 
// Loop again if a swap occurred. 
Let's look more closely at the for loop that handles the comparisons and exchanges 
during a pass. Here is its start ing line: 
for (int 
count
= O; count< 
(s iz e -
1} ; count++) 
The variable count holds the array subscript s. It starts at zero and is incremented as 
long as it is less than size - 1. The value of size is the number of elements in the array, 
and count stops just short of reaching this value because the following line compares 
each element with the one after it: 
if 
(array[count] 
> array[count 
+ 1] } 
When array [ count J is the next -to-last element, it will be compared to the last element. 
If the for loop were allowed to increment count past size - 1, the last element in the 
array would be compared to a value outside the array. 
Here is the if statement in its entirety: 
if 
(array[count] 
> array[count 
+ 1] } 
{ 
} 
temp = array[count]
; 
array[count] 
= array[count 
+ 1]; 
array[count 
+ 1] = temp; 
madeAswap = true; 
If array [ count] is greater than array [count+ 1 J, the two elements must be exchanged. 
First, the contents of array [ count J is copied into the variable temp. Then the contents 
of array [ count + 1 J is copied into array [ count J. Th e exchange is made comp lete 
when temp (which holds the previous contents of array [ count J) is cop ied to 
array [ count + 1 J. Last, the madeAswap flag variable is set to true. This indicates that 
an exchange has been made. 
Program 9-4 demonstrates the bubble sort function in a complete program. 

616 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Program 9-4 
1 II Thi s program uses the bubble sort 
algorithm 
2 II to sort 
an array of integers 
in ascend i ng order. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototypes 
7 void sortArray(int 
[] , int); 
8 void showArray(const 
int 
[ ] , int); 
9 
10 int main() 
11 { 
12 
const i nt SIZE= 
6; 
13 
14 
II Array of unsorted 
values 
15 
int values[SIZE ] = {7, 2, 3 , 8, 9, 1}; 
16 
17 
II Di splay the values 
18 
cout << "The unsorted 
values 
are:\n"; 
19 
showArray (values , SIZE); 
20 
21 
II Sort the values 
22 
sortArray
(values , SIZE); 
23 
24 
II Display 
them again 
25 
cout << "The sorted 
values 
are:\n"; 
26 
showArray (values , SIZE); 
27 
return 
O; 
28
} 
29 
30 /************************************************************ 
31 
* 
sortArray 
* 
32 
* Thi s funct i on performs 
an ascend i ng-order 
bubble sort 
on* 
33 
*array.The 
parameter 
size holds the number of elements 
* 
34 
* in the array. 
* 
35 
************************************************************/ 
36 void sortArray(int 
array(], 
int si ze) 
37 { 
38 
int 
temp; 
39 
bool madeAswap; 
40 
41 
do 
42 
{ 
madeAswap = false; 
43 
for (int count= 
O; count< 
(si ze -
1); 
count++) 
44 
{ 
45 
46 
47 
48 
49 
50 
i f (a rray(count
] > array(count 
+ 1]) 
{ 
temp= 
array(count]; 
array(count] 
= array(count 
+ 1] ; 
array(count 
+ 1] = temp ; 
madeAswap = true; 
51 
} 
52 
} 
53 
54
} 
55 
} whi le (madeAswap); 
II Loop aga i n if a swap occurred 
on this 
pass. 
(program continues) 

9.3 Introduction to Sorting Algorithms 
617 
Program 9-4 
(continued) 
56 /************************************************************* 
57 
* 
showArray 
• 
58 
* Thi s funct i on di splays 
the contents 
of array. 
The 
• 
59 
* parameter 
size holds the number of elements 
in the array . * 
60 
*************************************************************/ 
61 void showArray(const 
int array(]
, int s i ze ) 
62 { 
63 
for (int 
count
= O; count< 
size ; count ++) 
64 
cout << array(count] 
<< • "; 
65 
cout << endl; 
66 ) 
Program Output 
The unsorted 
values 
are: 
7 2 3 8 9 1 
The sorted 
values 
are: 
1 2 3 7 8 9 
The Selection Sort 
The bubble sort is inefficient for large arrays because repeated data swaps are often 
required to place a single item in its correct position. The selection sort, like the bubble 
sort, places just one item in its correct position on each pass. However, it usually 
performs fewer exchanges because it moves items immediately to their correct position 
in the array . Like any sort, it can be modified to sort in either ascending or descending 
order. An ascending sort works like this: The smallest value in the array is located and 
moved to element 0. Then the next smallest value is located and moved to element 1. 
This process continues until all of the elements have been placed in their proper order. 
Let's see how the selection sort works when arranging the elements of the following array: 
5 
7 
2 
8 
9 
1 
Element O 
Element 1 
Element 2 
Element 3 
Element 4 
Element 5 
The selection sort scans the array, starting at element 0, and locates the element with 
the smallest value. The contents of this element are then swapped with the contents of 
element 0. In this example, the 1 stored in element 5 is the smallest value, so it is 
swapped with the 5 stored in element 0. This completes the first pass, and the array 
now appears as 
1 
7 
2 
8 
9 
5 
Element O 
Element 1 
Element 2 
Element 3 
Element 4 
Element 5 
The algorithm then repeats the process, but because element O already contains the 
smallest value in the array, it can be left out of the procedure. For the second pass, the 
algorithm begins the scan at element 1. It locates the smallest value in the unsorted part 
of the array, which is the 2 in element 2. Theref ore, element 2 is exchanged with 
element 1. The array now appears as 
1 
2 
7 
8 
9 
5 
Element O 
Element 1 
Element 2 
Element 3 
Element 4 
Element 5 

618 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Once again the process is repeated, but this time the scan begins at element 2. The algorithm 
will find that element 5 contains the next smallest value and will exchange this element's 
contents with that of element 2, causing the array to appear as 
1 
2 
5 
8 
9 
7 
Element O 
El ement 1 
Element 2 
Element 3 
Element 4 
Element 5 
Next, the scann ing begins at element 3. Its contents are exchanged with those of 
element 5, causing the array to appear as 
1 
2 
5 
7 
9 
8 
Element O 
El ement 1 
Element 2 
Element 3 
Element 4 
Element 5 
At this point there are only two elements left to sort. The algorit hm finds that the value 
in element 5 is smaller than that of element 4, so the two are swapped. This puts the 
array in its final arrangement: 
1 
2 
5 
7 
8 
Element O 
Element 1 
Element 2 
Element 3 
Element 4 
Here is the selection sort algorithm in pseudocode: 
For startScan 
= 0 to the next-to-1ast 
array subscript 
Set index to startScan 
Set minindex 
to startScan 
Set minVa1ue to array[startScan] 
9 
Element 5 
For index= 
(star tScan 
+ 1) to the 1ast subscript 
in the array 
If array[index] 
is Jess than minVa1ue 
Set minVa1ue to array[index] 
Set minindex 
to index 
End If 
Increment 
index 
End For 
Set array[minindex] 
to array[startScan] 
Set array[startScan] 
to minVa1ue 
End For 
As with bubble sort, selection sort uses a pair of nested loops, in this case two for loops. The 
outer loop iterates once for each pass of the sort. Its loop control variable, startScan , holds 
the subscript of the array element that will receive its correct value on this pass. On the first 
pass startScan equals 0, and the smallest value is found and placed in position 0, swapping 
places with the value previously stored in position 0. On the second pass startScan equals 
1, and the smallest of the remaining values is found and placed in position 1, swapping 
places with the value previously stored in position 1. This process contin ues until the 
correctly ordered values are in positions O through the next-to-last subscript position. Once 
this has been done, the value remaining in the final array position will be the largest, so there 
is no need for the outer loop to iterate again. For N pieces of data there will be N-1 passes. 
On each pass, it is the job of the inner loop to find the smallest remaining value to be 
swapped with the value in position startScan. 
Before it begins iterat ing, minlndex is 
set to st artScan , and mi nVal ue is set to the value currently in position startScan. 
The inner loop then moves through the rest of the array starting at index startScan 
+ 1. 
If it finds a smaller value than the one currently stored in mi nVa l ue, it replaces it with 

9.3 Introduction to Sorting Algorithms 
619 
this new smaller one and replaces the subscript sto red in mi nlndex with this new 
index. Once the inner loop comp letes its iterations, minlndex will hold the index of 
the smallest element . Th e outer loop then exchanges the contents of this element with 
array [ startScan
] and increments startScan
. Notice that if no smaller element than 
the one at position startScan 
was found , mi nlndex will still equal startScan
, so the 
value in startScan 
will, essentially, be swapped with itself, leaving it unchanged . 
The following function uses the selection sort to arrange the values in an integer array in 
ascending order. It accepts two arguments . The first parameter , array, receives the array 
to be sorted and the second, size , indicates how many values are stored in the array . 
voi d selectionSort
(i nt array[], 
i nt size) 
{ 
) 
int startScan
, mi nlndex, 
minValu e ; 
for (s tartScan 
= O; startScan 
< (si ze - 1); startScan
++) 
{ 
} 
minlndex = startScan
; 
mi nValue = array[startScan]; 
for (i nt i ndex= 
startScan 
+ 1 ; index< 
size ; i ndex++) 
{ 
if (array [index ] < minVal ue) 
{ 
} 
} 
minValu e = array[index]; 
minlndex = index; 
array[minlndex
] = array[startScan
] ; 
array[startScan] 
= minValu e ; 
As mentioned earlier, the selection sort requires fewer swaps than the bubb le sort . In fact, 
as seen above, it requires only one data exchange per pass. Not only does each iteration 
of the outer loop place a value in its correct position , but that value and that array 
position do not have to be examined again on subsequent passes. Notice, however, that 
the selection sort does not use a flag variable, such as the madeAswap variab le in bubble 
sort. This is because even if a particular array position already holds the next smallest 
value, so that its value does not change on a particular pass, it does not mean the array is 
fully sorted . Other values might not yet have been moved to their correct position . 
Program 9-5 demonstrates the selection sort function in a complete program . 
Program 9-5 
1 II This program uses the selection 
sort 
algorithm 
2 II to sort 
an array i n ascending 
order . 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototypes 
7 void selectionSort(int 
[ ] , int); 
8 void showArray(const 
int 
[ ] , int); 
9 
(program continues) 

620 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Program 9-5 
10 int main() 
11 { 
(continued) 
12 
const i nt SIZE= 6; 
13 
14 
II Array of unsorted 
values 
15 
int values[SIZE ] = {5, 7, 2 , 8, 9, 1}; 
16 
17 
II Display 
the values 
18 
cout << "The unsorted 
values 
are\n"; 
19 
showArray (values , SIZE}; 
20 
21 
II Sort the array 
22 
select
i onSort (valu es, SIZE} ; 
23 
24 
II Di splay the values 
again 
25 
cout << "The sorted 
values 
are\n"; 
26 
showArray (values , SIZE}; 
27 
return 
O; 
28
} 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
/************************************************************** 
* 
* Thi s funct i on 
* on array. 
The 
* in the array. 
selectionSort 
performs 
an ascend i ng-order 
selection 
sort 
parameter 
size 
holds the number of elements 
* 
* 
* 
* 
**************************************************************/ 
void selectionSort(int 
array[]
, int size} 
{ 
int startScan, 
minindex, 
minValue; 
40 
for (startScan 
= O; startScan 
< (size 
-
1}; 
startScan+
+) 
41 
{ 
42 
mi nindex = startScan; 
43 
mi nValue = array[startScan]; 
44 
for(int 
index= 
startScan 
+ 1; index< 
size; 
index+ +) 
45 
{ 
46 
47 
48 
49 
50 
51 
} 
i f (a rray[index
] < minValue) 
{ 
} 
mi nValue = array[index]
; 
mi nindex = index; 
52 
array[m i nindex ] = array[startScan
] ; 
53 
array[startScan] 
= mi nValue; 
54 
} 
55 } 
56 
57 /************************************************************* 
58 
59 
60 
* 
showArray 
* Thi s funct i on displays 
the contents 
of array. 
The 
* parameter 
size holds the number of elements 
in the 
* 
* 
array . * 
61 
*************************************************************/ 
(program continues) 

9.4 Sorting an Array of Objects 
621 
Program 9-5 
(continued) 
62 void showArray(const 
int array(]
, int s i ze ) 
63 { 
64 
for (int 
count
= O; count< 
size ; count ++) 
65 
cout << array(count] 
<< • "; 
66 
cout << endl; 
67
) 
Program Output 
The unsorted 
values 
are 
5 7 2 8 9 1 
The sorted 
values 
are 
1 2 5 7 8 9 
~ 
Checkpoint 
9.4 
9.5 
Tru e or false: Any sort can be modified to sort in either ascending or descending 
order. 
9.6 
What one line of code would need to be modified in the bubble sort to make it sort in 
descending, rather than ascending, order? How would the revised line be written? 
9. 7 
After one pass of bubble sort, which value is in order? 
9.8 
After one pass of selection sort, which value is in order? 
9.9 
Which sort usually requires fewer data values to be swapped, bubble sort or 
selection sort? 
Sorting an Array of Objects 
CONCEPT: 
Sorting algorithms can also be used to order elements in an array of objects 
or structures. 
Programs 9-4 and 9-5 illustrated how to sort an array of integer s using bubble sort 
and selection sort. Th ese sorts could just as easily be used to sort array elements of 
any other data type. Program 9-6 uses a bubble sort to sort Inventory 
objects, using 
the Inventory 
class introduced earlier in this chapter. When sorting objects or 
str uctur es, one must decide which data item to sort on. For example, we could 
arrange Inventory 
objects in order by itemCode, by description, 
or by price. To 
determine if two elements are out of order and should be swapped, we compare only 
the values in the data member we are sorting on . How ever, if the two array elements 
are found to be out of orde r, we swap the entire two elements. Thi s is illustrated in 
Program 9-6. 

62 2 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Program 9-6 
1 II This program uses bubble sort 
to sort 
an array 
of objects. 
2 II It places 
Inventory 
objects 
in ascending 
order 
by their 
itemCode . 
3 #include 
<i ostream> 
4 #include 
<i omanip> 
5 #include 
<string> 
6 using namespace std; 
7 
8 II Inventory 
class 
declaration 
9 class 
Inventory 
10 { 
pr i vate: 
11 
string 
itemCode; 
12 
string 
descript
i on; 
13 
double price; 
14 
15 
16 
17 
18 
publ i c: 
Inventory
() 
{ i temCode = "XXX"; 
II Default 
constructor 
descr i ption=" 
"; 
pr i ce= 
0 .0; ) 
19 
Inventory
(string 
c , string 
d , double p) II 3 argument constructor 
20 
{ i temCode = c; 
21 
description
= d; 
22 
pr i ce = p; 
23 
} 
24 
25 
II Add methods setCode, 
setOescript
i on, and setPrice 
here. 
26 
27 
II Get funct i ons to retrieve 
member variable 
values 
28 
str i ng getCode() 
const 
29 
{ string 
code = itemCode; 
30 
return 
code ; 
31 
} 
32 
33 
str i ng getOescript
i on () const 
34 
{ string 
d = description; 
35 
return 
d; 
36 
} 
37 
38 
double getPrice() 
const 
39 
{ return 
price; 
40 
} 
41 
42 } ; I I End Inventory 
cl ass declarat
i on 
43 
44 II Program that 
uses the Inventory 
class 
45 
46 II 
Funct i on prototype 
47 void di splayinventory(const 
Inventory[
] , int); 
48 void bubbleSort(Inventory[], 
int); 
49 
(program continues) 

9.4 Sorting an Array of Objects 
623 
Program 9-6 
(continued) 
50 /******************************************************* 
51 
* 
main 
* 
52 
*******************************************************/ 
53 int mai n() 
54 { 
55 
const 
int SIZE = 6 ; 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
II Create 
and in i tialize 
the array of Inventory 
objects 
Inventory 
silverware[SIZE] 
= 
{ Inventory
("S15" , "s oup spoon" , 
Inventory("S12", 
"t easpoon" , 
Inventory("F15", 
"di nner fork", 
Inventory("F09", 
"s alad fork" 
, 
Inventory("K33", 
"kni fe", 
Inventory("K41", 
"s teak knife", 
66 
II Display the inventory 
67 
cout 
<< "Here is the original 
data\n"; 
68 
di splayinventory(silverware, 
SIZE); 
69 
70 
II Sort the objects 
by their 
i temCode 
71 
bubbleSort(silverware, 
SIZE); 
72 
73 
II Display the inventory 
again 
74 
cout 
<< "\nHere i s the sorted 
data\n"; 
75 
di splayinventory(silverware, 
SIZE); 
76 
77 
78 } 
79 
return 
O; 
//En d mai n 
80 /******************************************************* 
81 
* 
displayinventory 
* 
82 
* This function 
displays 
the entire 
array. 
* 
83 
*******************************************************/ 
84 void displayinventory(const 
Inventory 
object[], 
int s i ze ) 
85 { 
si ze ; index+ +) 
<< object[index
] .getCode() 
2.35 ), 
2 .19), 
3 .19), 
2.25 ), 
2.35 ), 
4.15) 
}; 
86 
87 
88 
89 
for (i nt i ndex= 
O; 
{ cout << setw(5) 
<< setw(13) 
i ndex < 
<< left 
<< left 
<< right 
<< object[index
] .getDescript
i on() 
<< "$" 
<< object[index
] .getPrice() 
<< endl; 
90 
} 
91 }// End displayinventory 
92 
93 
94 
95 
96 
97 
98 
99 
100 
101 
102 
/******************************************************** 
* 
bubbleSort 
* 
* This function 
performs 
a bubble sort on Inventory 
* 
* objects, 
arranging 
them in ascend i ng i temCode order . * 
********************************************************/ 
void bubbleSort(Inventory 
array[
] , int s i ze ) 
{ 
Inventory 
temp ; 
bool swap; 
II Holds an Inventory 
object 
(program continues) 

624 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Program 9-6 
(continued) 
103 
do 
104 
{ swap= false; 
105 
for (i nt count= 
O; coun t < (s iz e - 1); cou nt+ +) 
106 
{ 
107 
108 
109 
110 
111 
112 
113 
i f (array[cou
nt] .getCode() 
> array[count 
+ 1].ge t Code()) 
{ 
} 
t emp= array[coun
t ]; 
array[count] 
= array[count 
+ 1]; 
array[count 
+ 1] = t emp; 
swap= 
true; 
114 
} 
115 
} while 
(swap); 
116 }// End bubbleSort 
Program Output 
Here 
S15 
S12 
F15 
F09 
K33 
K41 
Here 
F09 
F15 
K33 
K41 
S12 
S15 
is the ori gi nal data 
soup spoon 
$2.35 
teaspoon 
$2. 19 
dinner 
fork 
$3. 19 
salad 
fo rk 
$2.25 
knife 
$2.35 
st eak knif e 
$4. 15 
is the sor t ed data 
salad 
fo rk 
$2.25 
dinner 
fork 
$3. 19 
knife 
$2.35 
st eak knif e 
$4. 15 
t easpoon 
$2. 19 
soup spoon 
$2.35 
Let's take a closer look at the bubbl eSor t function . Line 107 contains the code that 
compares the objects stored in two array elements. Not ice that only the i te mCode values 
of the objects are compared and that these values are retrieved by using each object's 
get Code method . Next look at lines 109 through 111. Notice that when two objects are 
out of order the entire objects are swapped and that an entire object can be moved in a 
single statement . It isn't necessary to move each of the member variables one by one. 
Finally, notice in line 100 that t emp is defined as an Inve ntory object. Because it will be used 
to temporarily hold an array element during each swap, and because the array elements in 
this case are I nventory objects, temp must also be defined as an Invent ory object. 
Sorting and Searching Vectors 
CONCEPT
: Th e sorting and searching algorithm s you have studied in this chapter 
can be applied to STL vectors as well as to arrays. 
In the previous chapter you learned about the vector class that is part of the Standard 
Template Library (STL). Once you have properly defined an STL vector and populated 
it with values, you may sort and search the vector with the algorithms presented in this 
chapter. Simply substitute the vector syntax for the array syntax when necessary. 

9.5 Sorting and Searching Vectors 
62 5 
Program 9-7 modifies Program 9-4 to use a STL vector instead of an array. 
Program 9-7 
1 II Thi s program uses the bubble sort 
algorithm 
to sort 
2 II a vector 
of integers 
i n ascend i ng order. 
3 #include 
<iostream> 
4 #include 
<vector> 
II Needed to use vectors 
5 using namespace std ; 
6 
7 II Function 
prototypes 
8 void displayVector(vector<int>
); 
9 void sortVector(vector<int> 
&); 
10 
11 int main() 
12 { 
13 
const i nt SIZE= 6; 
14 
15 
II Create 
a vector 
to hold a set of unsorted 
i ntegers 
16 
vector<int> 
values(SIZE); 
17 
18 
II Prompt the user to enter 
the values 
to be stored. 
19 
cout << "Please 
enter
"<< SIZE<<" 
integers 
separated 
by spaces . \n"; 
20 
21 
for (int 
i = O; i < SIZE; i+ +) 
22 
cin >> values[i
] ; 
23 
24 
II Display 
the values 
25 
cout << "\nThe unsorted 
values 
entered 
are: \n"; 
26 
displayVector(values); 
27 
28 
II Sort the values 
29 
sortVector(values
); 
30 
31 
II Display 
them again 
32 
cout << "The sorted 
values 
are:\n"; 
33 
displayVector(values); 
34 
return 
O; 
35
} 
36 
37 /************************************************************ 
38 
* 
sortVector 
* 
39 
* Thi s funct i on performs 
an ascend i ng-order 
bubble sort 
on* 
40 
* numbers, a vector 
of i ntegers. 
* 
41 
************************************************************/ 
42 void sortVector(vector<int> 
&numbers) 
43 { 
int 
temp; 
44 
bool swap; 
45 
(program continues) 

626 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Program 9-7 
(continued) 
46 
do 
47 
{ 
swap= false ; 
48 
for (unsigned count= 
O; count< 
numbers .si ze( )-1; count++) 
49 
{ 
50 
i f (numbers[count ] > numbers[count 
+ 1]) 
51 
{ 
52 
temp= 
numbers[count]; 
53 
numbers[count] 
= numbers[count 
+ 1]; 
54 
numbers[count 
+ 1] = temp; 
55 
swap = true; 
56 
} 
57 
} 
58 
} whi le (swap); 
59
} 
60 
61 /************************************************************* 
62 
63 
64 
65 
* 
di splayVector 
* 
* Thi s funct i on di splays 
the contents 
of numbers, a 
* 
* vector 
of i ntegers. 
* 
*************************************************************/ 
66 void displayVector(vector<
i nt> numbers) 
67 { 
68 
for (uns i gned count= 
O; count< 
numbers.size(); 
count ++) 
69 
cout << numbers[count] 
<< • •· 
70 
cout << endl; 
71 } 
Program Output With Example Input Shown In Bold 
Please enter 
6 integers 
separated 
by spaces. 
9 4 8 6 3 1 [Enter] 
The unsorted 
values entered 
are: 
94863
1 
The sorted 
values are: 
1 3 4 6 8 9 
Notice the similarities and differences between Progr am 9-7 and Program 9-4. The code 
in Program 9-7 that sorts vectors is almost identical to the code in Program 9-4 that 
sorts arrays. The differences lie in some details of initialization and argument passing . 
First, notice that in Program 9-4 the array data is provided in an initialization list when 
the array is created, but in Program 9-7 the data to be stored in the vector is input by the 
user. This is done because vectors do not accept initialization lists. Second, notice that in 
Program 9-7 the vector is passed by reference to the sort Vector function. This is necessary 
because, unlike arrays, vectors are passed by value unless the programmer uses a reference 
variable as a parameter. Finally, notice that in Program 9-7 we don't have to pass the size 
of the vector to the functions that work with it because the vector's size member function 
can tell us how many elements it holds. You may have noticed that the loop control 
variables in lines 48 and 68 of Program 9-7 are declared to be unsigned. This is because 
they are compared to the value returned by the size function, and it returns an unsigned 
value. Some compilers complain if an int variab le is compared to an unsigned value. 

9.6 
9.6 Introduction to Analysis of Algorithms 
627 
Introduction to Analysis of Algorithms 
CONCEPT
: We can estimate the efficiency of an algorithm by counting the number 
of steps it requires to solve a problem. 
An algorithm is a mechanical step-by-step procedure for solving a problem and is the 
basic strategy used in designing a program . There is often more than one algorithm 
that can be used to solve a given problem. For example, we saw earlier in this chapter 
that the problem of searching a sorted array can be solved by two different methods: 
sequential search and binary search. 
How can we decide which of two algor ithms for solving a problem is better? To 
answer this question, we need to establish criteria for judging the "goodness" or 
efficiency of an algorithm . The two criteria most often used are space and time. 
The space criterion refers to the amount of memory the algorithm requires to solve the 
problem , while the time criterion refers to the length of execution time. In this chapter, 
we will use the time criterion to evaluate the efficiency of algorithms . 
One possibility for comparing two algorithms is to code them and then time the 
execution of the resulting C++ programs . This experimental approach can yield useful 
information , but it has the following shortcomings: 
• It measures the efficiency of programs rather than algorithms. 
• The results depend on the programming language used to code the algorithms 
and on the quality of the compiler used to generate machine code. The programs 
may run faster or slower if they are coded in a different language or compiled by 
a different compiler. 
• The results depend on how the operating system executes programs and on the 
nature of the hardware on which the programs are executing. The execution 
times may be different if we run the programs on a different computer and a 
different operating system. 
• The results apply only to those inputs that were part of the execution runs and may not 
be representative of the performance of the algorithms using a different set of inputs. 
A better approach is to count the number of basic steps an algorithm requires to process an 
input of a given size. To make sense of this approach, we need more precise definitions of 
what we mean by computational problem, problem input, input size, and basic step. 
Computational 
Problems and Basic Steps 
A computational problem is a problem to be solved using an algorithm . Such a problem 
is a collection of instances, with each instance specified by input data given in some 
prescribed format . For example , if the problem P is to sort an array of integers, then an 
instance of Pis a specific integer array to be sorted . The size of an instance refers to the 
amount of memory needed to hold the input data. The input size is usually given as a 
number that allows us to infer the total number of bits occupied by the input data . If 
the number of bits occupied by each entry of the array is fixed, say at 64 bits, then the 
length of the array is a good measure of input size. In contrast, the length of the array 

628 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
is not a good measure of input size if the size of array elements can vary and there is no 
fixed upper bound on the size of these elements. 
A step executed by an algorithm is a basic step (also called a basic operation) if the 
algorithm can execute the step in time bounded by a constant regardless of the size of 
the input. In sorting an array of integers, the step 
Swap the elements in positions k and k+1 
is basic because the time required to swap two array elements remains constant even if 
the length of the array increases. In contrast, a step such as 
Find the largest element of the array 
is not basic because the time required to complete the step depends on the length of the 
array. Intuitively, a basic step is one that could conceivably be built into the hardware 
of some physical computer. 
The definition of a basic step does not specify the size of the constant that bounds the 
time required to execute the step. Ignoring the exact value of these constants reflects 
the reality that the same operat ion may be executed with different speeds on different 
hardware and that an operation that can be executed with one hardware instruction on 
one computer may require several hardware instructions on another computer. 
A consequence of this definition is that we can count any constant number of basic 
steps as one basic step. For example, an algorithm that executes Sn basic steps can 
accurately be described as executing n basic steps. 
It is important to realize that ordinary arithmetic and logic operations such as addition 
and comparison are not basic unless a constant bound is put on the size of the numbers 
being added or compared . The size of the bound does not matter as long as the bound 
is constant . It may be 32, 64, 128, 1024 bits, or even larger, and these operations will 
still be basic. In the following discussion, we assume that all the numbers used in our 
algorithms as inputs, outputs, or computed intermediate results are bounded in size. 
This allows us to consider operat ions on them as basic. 
It only makes sense to describe an algorithm after we have described the problem it is 
supposed to solve. A computationa l problem is described by stating what the input will 
look like, how big it is, and what output the algorithm solving the problem is supposed 
to produce. These must be described clearly, so there is no ambiguity, and generally, so 
the algorithm can work with any data set that fits the description . 
Let's look at an example . Suppose the problem P is to sum all the integer values in a 
one-
0 dimensional array . We could describe the problem by saying that the input data is 
an array of n integer values and that the output to be produced is the integer sum of 
these values. Formally, this is written as follows: 
INPUT: An integer array a [] of size n 
SIZE OF INPUT: The number n of array entries 
OUTPUT: An integer sum representing the sum total of the values stored in the array 
Notice that the word INPUT used this way does not mean a set of data entered by the 
user. It means the form of the data used by the algorithm solving the problem . Likewise, 
the word OUTPUT used this way does not mean something displayed on the computer 
screen by a program. It means the result created by the algorithm that solves the problem. 

9.6 Introduction to Analysis of Algorithms 
629 
Because we have assumed all the array entries are of some fixed size, such as 32 or 64 
bits, the number n of elements in the array is a good measure of input size. 
Once a computationa l problem has been described, there can be many different 
algorithms designed to solve it. Some, of course, are better than others, as we will soon 
see. Here is one possible algorithm for solving the computational 
problem just 
described. Notice that it is expressed in pseudocode rather than in C++ or any other 
particular programming language. 
Algorithm 1: 
1 : sum = 0 
2: k = 0 //array 
inde x 
3: While k < n do 
4: 
sum= sum+ a[k] 
5: 
k = k + 1 
6: End While 
Complexity of Algorithms 
We can measure the complexity of an algorithm that solves a computational problem 
by determining the number of basic steps it requires for an input of size n. Let's count 
the number of steps required by Algorithm 1. The algorithm consists of two statements 
on lines 1 and 2 that are each executed once and two statements inside a loop on lines 
4 and 5 that will execute once each time the loop iterates . Recall that because the 
statements on lines 1 and 2 perform basic operations they can be grouped together and 
counted as one basic operation . Let's call this operation A. 
Also, because both statements in the loop execute in constant time, independently of 
the size of n, they are also basic operat ions. Since the loop body contains only basic 
operations, the amount of time the algorithm takes to execute a single iteration of the 
loop is also constant, and not dependent on the size of n. This allows us to count each 
loop iteration as a single basic operation . Let's call this operation B. 
Operation A executes only one time, regardless of how big n is. Operation B executes 
once each time the loop iterates. Because the loop iterates n times, operat ion B is 
executed n times . Thus, the tota l number of operations performed is 1 + n. When 
n = 10, for example, 11 operations are performed. When n = 1000, 1001 operations 
are performed. When n = 10,000 the number of operations performed is 10,001. 
Not ice that as n becomes large, the 1 becomes insignificant and the number of 
operations performed is approximately n. We thus say that the algorithm requires 
execution time proportional to n to process an input set of size n. 
There is another way we could look at Algorithm 1 and determine how many operations 
it requires. The crucial operation in summing the values in an array is the addition of 
each value to the variable accumulating the sum. This occurs in line 4, and there are as 
many additions of array values as there are loop iterations. 
Thus, we could get the same result by just counting additions of array elements. It 
turns out that for most algorithms, it is sufficient to identify and count only one or two 
basic operations that are in some way crucial to the problem being solved. For example, 
in many array searching and sorting algorithms, it is sufficient to just count the number 
of comparisons between array elements. 

630 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
The array-summing algorithm just considered is particularly simple to analyze because 
it performs the same amount of work for all input sets of a given size. 
This is not the case with all algorithms. Consider the linear search algorithm introduced 
earlier in this chapter. It searches through an array of values, looking for one that 
matches a search key. Let's call the key X. The input to the algorithm is the array of n 
values and the key value X. The output of the algorithm is the subscript of the array 
location where the value was located or, if it is not found, the determination that the 
loop control variable has become larger than the subscript of the last array element. 
Formally, the problem can be stated like this: 
INPUT: An integer array a[ ] of size n, and an integer X 
SIZE OF INPUT: The number n of array entries 
OUTPUT: An integer kin the range O ~ k ~ n - 1 such that a[k] = X, or k = n 
Algorithm 2, shown here, uses the linear search algorithm to solve the problem. 
Algorithm 2 : 
1 : k = 0 
2: While k < n and a[k] 
~ X do 
3: 
k = k + 1 
4: End While 
This algorithm starts at one end and searches sequentially through the array . The 
algorithm stops as soon as it encounters X but will search the entire array if X is not in 
the array . The algorithm may stop after making only one comparison (Xis found in the 
first entry examined), or it may not stop until it has made n comparisons (X is found in 
the last place examined or is not in the array). In fact, the algorithm may perform m 
comparisons where m is any value from 1 to n. In cases where an algorithm may perform 
different amounts of work for different inputs of the same size, it is common to measure 
the efficiency of the algorithm by the work done on an input of size n that requires the 
most work. This is called measuring the algorithm by its worst-case complexity function. 
Worst-Case Complexity of Algorithms 
The worst -case complexity function f(n) of an algorithm is the number of steps it 
performs on an input of size n that requires the most work. It gives an indication of the 
longest time the algorithm will ever take to solve an instance of size n and is a good 
measure of efficiency to use when we are looking for a performance guarantee . 
Let's determine the worst -case complexity of binary search, which was introduced 
earlier in this chapter. This algorithm is used to locate an item X in an array sorted 
in ascending order. The worst case occurs when X is not found in the array . In this 
case, as we will see, the algorithm performs L + 1 steps, where L is the number of 
loop iterations. 
Here is the binary search algorithm to search an array of n elements. 
Algorithm 3: 
1: first= 
O 
2: last = n - 1 
3: found = false 
4 : position= 
- 1 
II n - 1 is the subscript 
of the last element. 

9.6 Introduction to Analysis of Algorithms 
631 
5: While found is not true and first<= 
last 
6: 
middle = (first 
+ last) 
I 2 
7: 
If a[middle] 
= X 
8: 
found = true 
9: 
position= 
middle 
10: 
Else if a[middle] 
> X 
11: 
last= 
middle -
1 
12: 
Else 
13: 
14: 
first= 
middle
+ 1 
End If 
While 
15: End 
16: 
I I 
17: 
I I 
18: 
I I 
When the loop terminates, 
position 
holds 
where the value matching 
X was found, 
or 
the value was not found. 
the subscript 
holds - 1 if 
The algorithm consists of some initialization of variab les followed by a loop . The 
initialization requires constant time and can therefore be considered to be one basic 
operation. Likewise, each iteration of the loop is a basic step because increasing the 
number of entr ies in the array does not increase the amount of time required by a 
single iteration of the loop. This shows that the number of steps required by binary 
search is L + 1. Now L is approximately equal to the integer part of log2n, the 
logarithm of n to the base 2. To see this, notice that the size of the array to be 
searched is initially n, and each iteration reduces the size of the remaining port ion of 
the array by approximately one half. Because each loop iteration performs at most 
two comparisons, binary search performs a total of 2 log2n comparisons. We can 
summarize our findings as follows: 
In the worst case, binary search requires time proportional to log2n. 
Let's look at one more algor ithm to determ ine its worst -case complexity . The 
computationa l problem to be solved is to arrange a set of n integers into ascending order. 
INPUT: An array a[ ) of n integers 
SIZE OF INPUT: The number n of array entries 
OUTPUT: The array a[) rearranged so that a(O) ~ a(l) ~ .. . ~ a(n-1) 
The algorithm we will use is a modification of the selection sort algorithm introduced 
earlier in this chapter. This version scans for the largest element (instead of the smallest) 
and moves it to the end in each pass. 
Algorithm 4: 
1 : For (k = n- 1; k 
~ 1; k -- ) 
2: 
II a[O .. k] is what remains to be sorted 
3: 
Determine position 
p of largest 
entry 
in a[O .. k] 
4: 
Swap a[p] with a[k] 
5: 
End For 
To analyze the complexity of this algorithm, let's begin by determining the number of 
array entry comparisons it makes when sorting an array of n entries. These comparisons 
occur in step 3. Step 3 is clearly not a basic step, as it requires time proport ional to k, 
and k varies with each iteration of the loop . To better see what is going on, let's restate 
step 3 using operations that are basic. 

632 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
INPUT: array a(O .. k] of k + 1 entr ies 
SIZE OF INPUT: number k + 1 of array entries 
3 .0: p = 0 //Position 
of largest 
value in unsorted 
part of the array 
3. 1 : For (m = 1; m ~ k; m++ ) 
3.2: 
I f a[m] > a[p] Then 
3.3: 
p=m 
3.4: 
End if 
3.5: 
End For 
We can see that the loop in lines 3.1 through 3.5 iterates k times and on line 3.2 makes 
one comparison each time it iterates . Therefore this algorithm requires k comparisons 
between array entries. 
Now returning to the main sorting algorithm, we observe that there will be n-1 iterations 
of the loop that starts at line 1 and ends at line 5, one iteration for each value of k in the range 
n- 1 to 1. On the first iteration, k equals n- 1, so step 3, as we learned from the analysis of 
lines 3.0 through 3.5, performs n-1 comparisons between array elements. On the second 
iteration, k equals n- 2, so step 3 performs n-2 comparisons. This continues until, on the final 
iteration, k equals 1, and step 3 performs 1 comparison. Here is what it looks like: 
k = n- 1: step 3 performs n- 1 comparisons 
k = n- 2: step 3 performs n- 2 comparisons 
k = 1: step 3 performs 1 comparison 
Genera lizing, we can thus say that for every value of k from n- 1 to 1, on the kth 
iterat ion, the step on line 3 will perform k comparisons . 
Thus the tota l number of comparisons performed by this simple sorting algorithm is 
given by the expression 
1 + 2 + 3 + · · · + (n- 1) = (n- l)n/2 
For large n, this expression is very close to n2 I 2. So we say that: 
In the worst case, selection sort requires time proportional to n2. 
Average-Case Complexity 
The worst-case complexity does not, however, give a good indication of how an algorithm 
will perform in practical situations where inputs that yield worst-case performance are rare. 
Often we are more interested in determining the complexity of the typical, or average case. 
The average-case complexity function can be used when we know the relative frequencies 
with which different inputs are likely to occur in practice. The average-case complexity 
function uses these frequencies to form a weighted average of the number of steps performed 
on each input. Unfortunately, although it yields a good measure of the expected performance 
of an algorithm, accurate estimates of input frequencies may be difficult to obtain. 
Asymptotic Complexity and the Big O Notation 
We can compare two algorithms F and G for solving a problem by comparing their 
comp lexity functions. More specifically, if f(n) and g(n) are the comp lexity functions 
for the two algorithms, we can compare the algorithms against each other by looking 

9.6 Introduction to Analysis of Algorithms 
633 
at what happens to the ratio f(n)lg(n) when n gets large. This is easiest to understand if 
this ratio tends to some limit. Let us consider some specific examples. Throughout , we 
assume that f(n) ~ 1 and g(n) ~ 1 for all (n) ~ 1. 
• f(n) = 3n2+ Sn and g(n) = n2. In this case 
That is, the value of f(n)lg(n) gets closer and closer to 3 as n gets large. What this means 
is that for very large input sizes F performs three times as many basic operations as G. 
However, because the two algorithms differ in performance only by a constant factor, 
we consider them to be equivalent in efficiency. 
• f(n) = 3n2+ Sn and g(n) = 100n. In this case 
f(n) = 3n2 + Sn = _3_n_ + _s _ _ 
00 as n -
oo 
g(n) 
100n 
100 
100 
Here, the ratio f(n)lg(n) gets larger and larger as n gets large. This means F does a lot more 
work than G on large input sizes. This makes G the better algorithm for large inputs. 
• f(n) = 3n2+ Sn and g(n) = n3. In this case 
f(n) = 3n2 + Sn = _3 + _S _ _ O as n _ 
00 
g(n) 
n3 
n 
n2 
This means that for large inputs the algorithm G is doing a lot more work than F, 
making F the more efficient algorithm. 
In general, we can compare two complexity functions f(n) and g(n) by looking at what 
happens to f(n)lg(n) as n gets large. Although thinking in terms of a limit of this ratio 
is helpful in comparing the two algorithms, we cannot assume that such a limit will 
always exist . It turns out that a limit does not have to exist for us to gain useful 
information from this ratio . We can usefully compare the two comp lexity functions if 
we can find a positive constant K such that 
f(n) :s: K for all n.::: 1 
g(n) 
If this can be done, it means that the algorithm F is no worse than K times G for large 
problems. In this case, we say that f(n) is in O(g(n) ), pronounced "f is in Big O of g." 
The condition that defines f(n) is in O(g(n)) is often written like this 
f(n) :S: Kg(n) whenever n .::: 1. 
Showing that f(n) is in O(g(n)) is usually straightforward. You look at the ratio f(n)lg(n) 
and try to find a positive constant K that makes f(n)lg(n) ~ K for all n ~ 1. For example, 
to show that 3n2 + Sn is in O(n 2), look at the following rat io and notice that Sin will 
be at most S for all n ~ 1. So 3 + Sin~ 8. Therefore for K = 8, f(n) I g(n) ~ K. 
3n 2 + Sn 
S 
----=
3 + -
n2 
n 

634 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
To show that f(n) is not in O(g(n)), you have to show that there is no way to find 
a positive K that will satisfy f(n) I g(n) ~ K for all n ~ 1. For example, the function 
3n2 + Sn is not in O(n) because there is no constant K that satisfies 
3n 2 + Sn 
-~
2~-= 
3n + 5 :s; K for all n 2: 1. 
n 
Although defined for functions, the "Big O" notat ion and terminology is also used to 
characterize algorithms and computationa l problems . Thus, we say that an algorithm F 
is in O (g(n)) for some function g(n) if the worst -case complexity function f(n) of Fis in 
Big O of g(n). Accordingly , sequentia l search of an array is in O(n), whereas binary 
search is in O(log2n). 
Similarly, a computat ional problem is said to be in O(g(n)) if there exists an algorithm for 
the problem whose worst-case complexity function is in O(g(n)). Thus, the problem of 
sorting an array is in O(n2), whereas the problem of searching a sorted array is in O(log2n). 
If g(n) is a function, O(g(n)) can be regarded as a family of functions that grow no faster 
than g(n). These families are called complexity classes, and a few of them are important 
enough to merit specific names . We list them here in order of their rate of growth . 
1. 0 (1): A function f(n) is in this class if there is a constant K > 0 such that f(n) ~ K 
for all n ~ 1. An algorithm whose worst -case complexity function is in this class 
is said to run in constant time . 
2. O(log2n): Algorithms in this class run in logarithmic time. Because log n grows 
much slower than n, a huge increase in the size of the problem results in only a 
small increase in the running time of the algorithm. 
This comp lexity is 
characterist ic of search problems that eliminate half of the search space with each 
basic operation. The binary search algorithm is in this class. 
3. O(n): Algorithms in this class run in linear time . Any increase in the size of the 
problem results in a proportionate increase in the running time of the algorithm. 
This comp lexity is characteristic of algorithms like sequential search that make a 
single pass, or a constant number of passes, over their input. 
4. O (n log2n): This class is called "n log n" time . An increase in the size of the 
problem results in a slight increase in the running time of the algorithm . The 
average case complexity of Quicksort , a sorting algorithm you will learn about in 
Chapter 14, is in this class. 
5. O(n2): This class is called quadratic time. This performance is characterist ic of 
algorithms that make multiple passes over the input data using two nested loops. 
An increase in the size of the prob lem causes a much greater increase in the 
running time of the algorithm . The worst -case complexity functions of bubble 
sort, selection sort, and Quicksort all lie in this class. 
~ 
Checkpoint 
9.10 
What is a basic operation? 
9.11 
What is the worst -case complexity function of an algorithm? 

9.8 
~ 
9.8 Tying It All Together: Secret Messages 
635 
9.12 
One algorithm needs 10n basic operations to process an input of size n, and 
another algorithm needs 25n basic operations to process the same input . Which 
of the two algorithms is more efficient? Or are they equally efficient? 
9.13 
What does it mean to say that f(n) is in O (g(n)) ? 
9.14 
Show that 100n 3 + 50n 2 + 75 is in 0 (20n 3) by finding a positive K that satisfies 
the equation (100n 3 + 50n2 + 75) / 20n 3 $ K. 
9.15 
Assuming g(n) ~ 1 for all n ~ 1, show that every function in O(g(n) + 100) is also 
in O (g(n)) . 
Case Studies 
The following case stud ies, which contain appl ications of material introduced in 
Chapter 9, can be found in the Chapter 9 folder of this book 's companion website at 
pearsonhighered .com/gaddis . 
Demetris Leadership Center-Parts 
1 & 2 
Chapter 9 included programs illustrating how to search and sort arrays, including arrays of 
objects. These two case studies illustrate how to search and sort arrays of structures. Both 
studies develop programs for DLC, Inc., a fictional company that publishes books, DVDs, and 
audio CDs. DLC's inventory data, used by both programs, is stored in an array of structures. 
Creating an Abstract Array Data Type-Part 
2 
The Int l i st class, begun as a case study in Chapter 8, is extended to include array 
searching and sorting capabilitie s. 
Tying It All Together: Secret Messages 
Now that you know how to search through an array to locate a desired item, we can 
write a program to encode and decode secret messages. We will use a simple substitution 
cipher. This means that for each character in a message, a different character will be 
substituted. For examp le, if we substitute f for c, t for a, and x for t , then the word cat 
would be written ft x. Can you guess what this message says? 
*>P;HMAyJHyJH91 [ 3Lf 
You' II know if you run the message through the program decoder. 
For this program we'll create a CodeMaker class that has encode and decode functions. 
When a CodeMaker object is created, the constructor will open the code . dat file that 
contains the character substitutions to be used. This file is located, along with the program 
source code file, in the Chapter 9 programs folder on the book's compan ion website. Be 
sure to place it in the project directory so the program can open and use it. There is one 
substitution character for each of the printable ASCII characters, which are represented by 
the decimal numbers 32 through 126. The program will read in these characters and store 
them in a one-dimensional array of characters, using the ASCII code of the original character, 
minus 32, as the index for the stored substitution character. So, for example, the substitution 
for ASCII character 32, a blank, will be stored in array element 0. The substitution for ASCII 
character 33, an exclamation point, will be in array element 1, and so forth. 

636 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
The code will be hard to break because even the blank space will be represented by 
another character. So someone trying to read the code will not know where one word 
ends and the next one begins. 
When the encode method is called, it is passed a string holding the message to be 
encoded. The method simply uses the ASCII code of each character in the string to 
compute the array index where its rep lacement character is located. Once each 
character in the string has been replaced, the string is returned. 
When the decode method is called, it is passed a string holding an encoded message to 
be turned back into its original, or plain text, form. However, this method cannot 
compute an index to reverse the code. Instead, for each character in the string, it must 
do a search of the array to locate it. When the character is found, its array subscript 
can be used to compute the ASCII value of the origina l character. Once each character 
in the encoded string has been translated back to its original form, the string is 
returned . 
In addition to creating the CodeMaker class, we will also write a client program that 
does the following: 
• Creates a CodeMaker object . 
• Has the user input a message and store it as a string. 
• Calls the encode function, passing it the string . 
• Displays the returned encoded string . 
• Calls the decode function, passing it the encoded string . 
• Displays the returned decoded string . This shou ld equal the original message. 
Program 9-8 does all of this. 
Program 9-8 
1 // This program encodes and decodes secret 
messages. 
2 #include 
<i ostream> 
3 #include 
<fstream> 
4 #include 
<string> 
5 using namespace std; 
6 
7 class CodeMaker 
8 { 
private: 
i nt size; 
9 
10 
11 
12 
char codeChar [94]; 
// Array to hol d the subst i tutions 
// for the 94 printable 
ASCII chars 
13 
i nt findit(char
[J, i nt, char); 
14 
15 
public: 
16 
CodeMaker(); 
17 
string 
encode(str
i ng); 
18 
string 
decode(str
i ng); 
19 }; 
20 
21 // Member function 
i mpl ementation 
sect i on 
22 
(program continues) 

9.8 Tying It All Together: Secret Messages 
637 
Program 9-8 
(continued) 
/***************************************************** 
* 
CodeMaker: :CodeMaker - the Constructor 
* 
* This method reads the substitut
i on 
* from a file 
and stores 
them it the 
* It also sets 
member variable 
size. 
characters 
i n 
* 
codeChar array . * 
* 
*****************************************************/ 
CodeMaker: :CodeMaker() 
{ 
siz e= 
94; 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 } 
ifstream 
i nputFile; 
inputFile.open("code.dat"); 
for (i nt ascii 
= 32; ascii 
< 127 ; asc i i+ +) 
i nputF ile 
>> codeChar [asci i - 32] ; 
inputFile.close(); 
II Open the file 
II Read in data 
II Cl ose the f il e 
39 
40 /******************************************************* 
41 
* 
CodeMaker: :encode 
* 
42 
* This method encodes and returns 
a clear 
text 
str i ng . * 
43 
*******************************************************/ 
44 string 
CodeMaker::encode(string 
s) 
45 { 
int asc i i; 
char newChar; 
46 
47 
48 
49 
str i ng newString 
= II" • 
II Wi ll hold the encoded string 
50 
for (unsigned 
pos = O; pos < s.length(); 
pos++) 
51 
{ 
52 
53 
54 
55 
56 
57 
II Get the or i gi nal character's 
ASCII code 
a sci i = s [ pos ] ; 
II Get the new rep l acement character 
newChar = codeChar[ascii 
- 32]; 
58 
II Concatenate 
it onto the end of the new str i ng 
59 
newStr i ng += newChar; 
60 
} 
61 
return 
newString; 
62 } 
63 
64 
65 
/*************************************************** 
* 
CodeMaker: :decode 
* 
66 
* This method converts 
an encoded str i ng back to 
* 
* clear 
text 
and returns 
it . 
* 
67 
68 
***************************************************/ 
69 string 
CodeMaker::decode(string 
s) 
70 { 
71 
int index; 
72 
73 
74 
char nextChar; 
char or i gi nal Char; 
str i ng decodedText 
= II" • 
(program continues) 

638 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Program 9-8 
(continued) 
75 
76 
for (unsigned 
pos = O; pos < s.length()
; pos++) 
77 
{ 
78 
II Get the next character 
from the string 
79 
nextChar = s [pos] ; 
80 
81 
II Cal l findit 
to f i nd it i n the array 
and return 
its 
i ndex 
82 
i ndex= 
findit(codeChar
, si ze , nextChar)
; 
83 
84 
II Get the or i gi nal character 
by computing i ts ASCII code 
85 
or i gi nal Char = i ndex+ 
32 ; 
86 
87 
II Concatenate 
th i s character 
onto the end of the 
88 
II decoded text 
str i ng being constructed 
89 
decoded Text += or i gi nal Char ; 
90 
) 
91 
return 
decodedText ; 
92 } 
93 
94 /***
* * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * **** 
95 
96 
97 
98 
99 
100 
101 
102 
103 
104 
105 
106 
107 
108 
* 
CodeMaker: :findit 
* This method performs 
a l inear 
search on 
* a character 
array 
look i ng for value. 
* 
* 
* 
*** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ****
/ 
int CodeMaker: :f i ndit 
(char A[] , i nt size , char value) 
{ 
i nt i ndex= 
O; 
i nt position= 
- 1; 
bool found= 
false; 
whi le (index< 
size && !found) 
{ 
II If the value is found 
I I Set the flag 
109 
if (A[index] == value) 
{ found= 
true; 
position= 
i ndex; 
II Record the value's 
subscr i pt 
110 
} 
111 
index+ +; 
112 
} 
113 
114 
} 
115 
return 
position
; 
II Go to the next element 
II Return the pos i t i on, or -1 
116 / *** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * 
117 
* 
main 
* 
118 
* The client 
"program " that 
uses the CodeMaker class.* 
119 
*** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * */ 
120 
int main () 
121 
{ 
122 
str i ng or i ginalText, 
secretCode
, final Text; 
123 
CodeMaker myCoder; 
124 
125 
126 
127 
II Get text 
from the user 
cout << "Enter the message to be encoded . \n" ; 
getline(c
i n , original
Text) ; 
(program continues) 

Program 9-8 
128 
(continued) 
Review Questions and Exercises 
639 
129 
II Send the text 
to be encoded and display 
the resu l t 
130 
secretCode 
= myCoder.encode(original
Text); 
131 
cout 
<< "\nHere i s the encoded message\n" 
<< secretCode 
<< endl ; 
132 
133 
II Send the encoded text 
back to be decoded 
134 
II and display 
the resu l t 
135 
f i nalText 
= myCoder.decode(secretCode); 
136 
cout 
<< "\nHere i s the decoded message\n" 
<< f i nal Text << endl; 
137 
138 
return 
O; 
139 
) 
Program Output with Example Input Shown in Bold 
Enter the message to be encoded. 
I can write a secret message . [Enter] 
Here is the encoded message. 
xH43DHP1yL(H3HJ[4I (LH=[JJ39[f 
Here is the decoded message. 
I can write 
a secret 
message. 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. The ____ 
search algorithm steps sequentially through an array, comparing 
each item with the search value. 
2. The ____ 
search algorithm repeatedly divides the portion of an array being 
searched in half. 
3. The ____ 
search algorithm is adequate for small arrays but not large arrays. 
4. The ____ 
search algorithm requires that the array's contents be sorted. 
5. The average number of comparisons performed by linear search to find an item in 
an array of N elements is ___ 
_ 
6. The maximum 
number of comparisons performed by linear search to find an 
item in an array of N elements is ___ 
_ 
7. A linear search will find the value it is looking for with just one comparison if 
that value is stored in the ____ 
array element. 
8. A binary search will find the value it is looking for with just one comparison if 
that value is stored in the ____ 
array element. 
9. In a binary search, after three comparisons have been made, only ____ 
of the 
array will be left to search. 
10. The maximum number of comparisons that a binary search function will make 
when searching for a value in a 2,000 -element array is ___ 
_ 

640 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
11. If an array is sorted in ____ 
order, the values are stored from lowest to highest. 
12. If an array is sorted in 
order, the values are stored from highest to lowest. 
13. Bubble sort places 
number(s) in place on each pass through the data. 
14. Selection sort places 
number(s) in place on each pass through the data. 
15. To sort N numbers, bubble sort continues making passes through the array until 
16. To sort N numbers, selection sort makes ____ 
passes through the data . 
17. Why is selection sort more efficient than bubble sort on large arrays? 
18. Which sort, bubble sort or selection sort, would require fewer passes to sort a set 
of data that is already in the desired order? 
19. Complete the following table by calculating the average and maximum number 
of compar isons the linear search will perform and the maximum number of 
compar isons the binary search will perform . 
Array Size-
100 
Elements 
1000 
Elements 
10,000 
Elements 
100,000 
Elements 
1,000,000 
Elements 
Linear Search (Average 
Comparisons) 
Linear Search (Maximum 
Comparisons) 
Binary Search (Maximum 
Comparisons) 
Algorithm Workbench 
20. Assume that empName and empID are two parallel arrays of size numEmp that hold 
employee data . Write a pseudocode algorithm that sorts the empI D array in 
ascending ID number order (using any sort you wish), such that the two arrays 
remain parallel. That is, after sorting, for all indexes in the arrays, empName [index
] 
must still be the name of the employee whose ID is in empID[ i nde x ]. 
21. Assume an array of structures is in order by the customerlD field of the record, 
where customer IDs go from 101 to 500. 
A) Write the most efficient pseudocode algorithm you can to find the record with 
a specific customerlD if every single customer ID from 101 to 500 is used and 
the array has 400 elements. 
B) Write the most efficient pseudocode algorithm you can to find a record with a 
customer ID near the end of the IDs, say 494, if not every single customer ID 
in the range of 101 to 500 is used and the array size is only 300. 
Soft Skills 
Deciding how to organize and access data is an important part of designing a program. You 
are already familiar with many structures and methods that allow you to organize data. These 
include one-dimensional arrays, vectors, multidimensional arrays, parallel arrays, structures, 
classes, arrays of structures, and arrays of class objects. You are also now familiar with some 
techniques for arranging (i.e., sorting) data and for locating (i.e., searching for) data items. 

a 
VideoNote 
Solving the 
Lottery Winners 
Problem 
Programm ing Challenges 
641 
22. Team up with two to three other students and jointly decide how you wou ld 
organize, order, and locate the data used in the following application . Be prepared 
to present your group's design to the rest of the class. 
The program to be developed is a menu-driven program that will keep track of 
parking tickets issued by the village that is hiring you. When a ticket is issued, the 
program must be able to accept and store the following information: ticket 
number, officer number, vehicle license plate state and number, location, violation 
code (this indicates which parking law was violated), and date and time written. 
The program must store information on the amount of the fine associated with 
each violation code. When a ticket is paid, the program must be able to accept 
and store the information that it has been paid, the amount of the payment, and 
the date the payment was received. The program must be able to accept inquiries 
such as displaying the entire ticket record when a ticket number is entered. The 
program must also be able to produce the following reports: 
• A list of all tickets issued on a specific date, ordered by ticket number 
• A list of all tickets for which payment was received on a specific date and the 
total amount of money collected that day 
• A report of all tickets issued in a one-month period, ordered by officer number, 
with a count of how many tickets each officer wrote 
• A report of all tickets that have not yet been paid, or for which payment 
received was less than payment due, ordered by vehicle license number 
Programming 
Challenges 
Many of these programming challenges can be written either with or without the use of 
classes. Your instructor will tell you which approach you should use. 
1. Charge Account Validation 
Write a program that lets the user enter a charge account number. The program should 
determine if the number is valid by checking for it in the following list: 
5658845 
8080152 
1005231 
4520125 
4562555 
6545231 
7895122 
5552012 
3852085 
8777541 
5050552 
7576651 
8451277 
7825877 
7881200 
1302850 
1250255 
4581002 
Initialize a one-dimensional array with these values. Then use a simple linear search to 
locate the number entered by the user. If the user enters a number that is in the array, 
the program should display a message saying the number is valid. If the user enters a 
number not in the array, the program should display a message indicating it is invalid. 
2. Lottery Winners 
A lottery ticket buyer purchases 10 tickets a week, always playing the same 10 five-digit 
"lucky" combinations . Write a program that initializes an array with these numbers and 
then lets the player enter this week's winning five-digit number. The program should 
perform a linear search through the list of the player's numbers and report whether or 
not one of the tickets is a winner this week. Here are the numbers: 
13579 
26791 
26792 
33445 
55555 
62483 
77777 
79422 
85647 
93121 

642 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
3. Lottery Winners Modification 
Modify the program you wrote for Programming Challenge 2 (Lottery Winners) so it 
performs a binary search instead of a linear search. 
4. Batting Averages 
Write a program that creates and displays a report of 12 Little League baseball players 
and their batting averages, listed in order of batting average from highest to lowest. 
The program shou ld use an array of structures or class objects to store the data, where 
each structure or object holds the name of a player and their batting average. Make the 
program modular by having main call on different functions to input the data, sort the 
data, and display the report. 
5. Hit the Slopes 
Write a program that can be used by a ski resort to keep track of local snow conditions 
for one week. It should have a seven-element array of structures or class objects, where 
each structure or object holds a date and the number of inches of snow in the base on 
that date. The program should have the user input the name of the month, the starting 
and ending date of the seven-day period being measured, and then the seven base snow 
depths . The program should then sort the data in ascending order by base depth and 
display the results. Here is the beginning of a sample report . 
Snow Report December 12 -
18 
Dat e 
Base 
13 
42 .3 
12 
42 .5 
14 
42 .8 
6. String Selection Sort 
Modify the select i onSort function presented in this chapter so it sorts an array of 
strings instead of an array of i nt s. Test the function with a driver program. Use 
Program 9-9 as a skeleton to complete . 
Program9-9 
// Inc l ude needed header files 
here. 
in t main() 
{ 
const int SIZE= 20; 
st ring name[SIZE] = 
{"Collins, 
Bil l ", 
"Smith , Bart", 
"Sanchez, Manny", "Rubin, Sarah", 
"Al l i son, Jeff", 
"Moreno, Juan", 
"Moretti, 
Bel l a", 
"Wu, Hong" 1 
"Smith, Cathy", 
"Conroy, Pat", 
"Mi chalski, 
Joe", 
"Taylor, 
Tyrone", 
"Wol fe, Bil l ", 
"Pat el , Renee", 
"Kelly, 
Sean", 
// Insert your code to complet e t his program . 
} 
"Gri ffin, 
Jim", 
"Johnson, Jill", 
"Whit man, Jean", 
"Harrison, 
Rose", 
"Holland, Beth"}; 

Programm ing Challenges 
64 3 
7. Binary String Search 
Modify the bi narySearch function presented in this chapter so it searches an array of strings 
instead of an array of i nts. Test the function with a driver program. Use Program 9-9 as 
a skeleton to complete. (The array must be sorted before the binary search will work.) 
8. Search Benchmarks 
Write a program that has at least 20 integers stored in an array in ascending order. It 
should call a function that uses the linear search algorithm to locate one of the values. 
The function should keep a count of the number of comparisons it makes until it finds 
the value. The program then should call a function that uses the binary search algo-
rithm to locate the same value. It should also keep count of the number of compar isons 
it makes. Display these two counts on the screen. 
9. Sorting Benchmarks 
Write a program that uses two identical arrays of at least 20 integers stored in a random 
order. It should call a function that uses the bubble sort algorithm to sort one of the arrays in 
ascending order. The function should count the number of exchanges it makes. The program 
should then call a function that uses the selection sort algorithm to sort the other array. It 
should also count the number of exchanges it makes. Display these two counts on the screen. 
10. Sorting Orders 
Write a program that uses two identical arrays of eight randomly ordered integers. It 
should display the contents of the first array, then call a function to sort it using an 
ascending order bubble sort, modified to print out the array contents after each pass of 
the sort . Next the program should display the contents of the second array, then call a 
function to sort it using an ascending order selection sort, modified to print out the 
array contents after each pass of the sort. 
11. Ascending Circles 
Program 8-31 from Chapter 8 creates an array of four Ci rel e objects, then displays 
the area of each object. Using a copy of that program as a starting point, modify it to 
create an array of seven Ci rcle objects initialized with the following radii: 2.5, 4.0, 
1.0, 3.0, 6.0, 5.5, 2.0. Then use a bubble sort to arrange the objects in ascending order 
of radius size before displaying the area of each object. 
12. Modified Bin Manager Class 
Modify the Bi nManager class you wrote for Programming Challenge 18 in Chapter 8 to 
overload its get Quantity, add Parts, and removeParts functions as shown here: 
bool addParts (str i ng i temDescri ption, 
int 
q ); 
bool removeParts (stri ng itemDescript i on, int q ) 
i nt getQuantity(str
i ng i temDescri ption); 
These new functions allow parts to be added, parts to be removed, and the quantity in 
stock for a particular item to be retrieved by using an item description, rather than a 
bin number, as an argument. In addition to writing the three overloaded functions, you 
will need to create a private 
Bi nManager class function that uses the item description 
as a search key to locate the index of the desired bin. 

644 
Chapter9 
Searching, Sorting, and Algorithm Analysis 
Test the new class functions with the same client program you wrote for Programming 
Challenge 15 in Chapter 8, modifying it to call the new functions. Be sure to use some 
descriptions that match bins in the array and some that do not. 
As you did in the previous Bin Manager program, if an add or remove operation is suc-
cessfully carried out, make the function return true. If it cannot be done-for example, 
because the string passed to it does not match any item description in the array- make 
the function return false. 
If the getQuan t it y function cannot locate any item whose 
description matches the one passed to it, make it return -1. 
13. Using Files-Birthday 
List 
Write a program that produces a list of stored names and birthdays in date order. It 
should use a 10-element array of structures or class objects that each holds two string 
variables, name and bir t hday . The program should fill the array elements by reading in 
the data from the bir thdays. dat file located in the Chapter 9 programs folder on the 
book's companion website. The file contains 20 lines with a person's name on one line, 
followed by his birthday on the next line in the form mm/dd. Once the data has been 
read in and stored, the program should sort the array elements in ascending order of date 
and display the birthday list. Make the program modular with main calling different 
functions to read in the file data, perform the sort, and display the list. 
14. Using Files-Birthday 
Look Up 
Modify the program you wrote for Programming Challenge 13 so that after reading in the 
data from the birt
hdays. dat file it sorts the array elements alphabetically by the name 
field and then prints the names, prompting the user to enter the name of the person whose 
birthday they want to find. It should then locate and display that person's birthday. 
15. Using Files-String 
Selection Sort Modification 
Modify the program you wrote for Programming Challenge 6 so it reads in the 20 
strings from a file. The data can be found in the names . dat file located in the Chapter 9 
programs folder on the book's companion website. 
16. Using Vectors - String Selection Sort Modification 
Modify the program you wrote for Programming Challenge 15 so it stores the names 
in a vector of strings, rather than in an array of strings. Create the vector without 
specifying a size and then use the push _ back member function to add an element 
holding each string to the vector as it is read in from a file. Instead of assuming there 
are always 20 strings, read in the strings and add them to the vector until there is no 
data left in the file. The data can be found in the names. dat file. 

TOPICS 
10.1 
Pointers and the Address Operator 
10.2 
Pointer Variables 
10.3 
The Relationship Between Arrays and 
Pointers 
10.4 
Pointer Arithmetic 
10.5 
Initializing Pointers 
10.6 
Compa ring Pointers 
10.7 
Pointers as Function Parameters 
10.8 
Pointers to Constants and Constant 
Pointers 
10.9 
Focus on Software Engineering: 
Dynamic Memory Allocation 
10.10 Focus on Software Engineering: 
Returning Pointers from Functions 
10.11 Pointers to Class Objects and Structures 
10.12 Focus on Software Engineering: Selecting 
Members of Objects 
10.13 Smart Pointers 
10.14 Tying It All Together: Pardon Me, Do You 
Have the Time? 
10.1 
Pointers and the Address Operator 
CO N C E PT: Every variable is assigned a memory location whose address can be retrieved 
using the address operator &. The address of a memory location is called a 
pointer. 
Every variable in an executing program is allocated a section of memory large enough to 
hold a value of that variable's type. Current C++ compilers that run on PCs usually 
allocate a single byte to variables of type char, two bytes to variab les of type short, four 
bytes to variables of type fl oat and 1 ong, and 8 bytes to variables of type doub 1 e. 
645 

646 
Chapter 10 
Pointers 
Figure 10-1 
Each byte of memory has a unique address . A variable's address is the address of the 
first byte allocated to that variable. Suppose that the following variables are defined in 
a program: 
char le t ter; 
short number; 
float 
amount ; 
Figure 10-1 illustrates how they might be arranged in memory and shows their addresses. 
1 etter 
number 
amount 
__ _.1 ___ ... 
111 
__________ 
1 .. 
1 _________________ 
..._1 
__ 
1200 
1201 
1203 
In Figure 10-1, the variable let t er is shown at address 1200, number is at addre ss 
1201, and amount is at address 1203. 
The addresses of the variables shown in Figure 10-1 are somewhat arbitrary and are 
used for illustrative purpose s only. In fact, most compilers allocate space in such a way 
that individual variab les are always assigned even addresses . This is because current 
computer hardware can access data that resides at even addresses faster than data that 
resides at odd addresses . 
C++ has an address operator & that can be used to retrieve the address of any variable. 
To use it, place it before the variable whose address you want . Here is an expression 
that returns the address of the variable amount : 
&amount 
And here is a statement that displays the variable's address to the screen: 
cout << long( &amount); 
By default, C++ prints addresses in hexadecimal. Here we have used a function-style 
cast to 1 ong to make the address print in the usua l decimal format . Program 10-1 
demonstrates the use of the address operator to display addresses of variab les. 
Program 10-1 
1 II Thi s progra m uses the & operator 
to deter min e a 
2 II variable's 
address. 
3 #include 
<iostr eam> 
4 using namespace std; 
5 
6 char l etter; 
7 short number; 
8 fl oat amount 
(program continues) 

10.2 Pointer Variables 
647 
Program 10-1 
(continued) 
9 double profit
; 
10 char ch; 
11 
12 int main() 
13 { 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
// Print 
address 
of each variable 
// The cast to long makes addresses 
// rather 
than in hexadecimal 
cout << "Address of letter 
is: 
" 
<< long (&lett er) << endl ; 
cout << "Address of number is: 
" 
<< long(&number) 
<< endl ; 
cout << "Address of amount is: 
" 
<< long (&amount) << endl ; 
cout << "Address of profit 
is: 
" 
<< long(&profit) 
<< endl ; 
cout << "Address of ch is : 
" 
<< long(&ch) 
<< endl; 
print 
in deci mal 
27 
return 
O; 
28 ) 
Program Output 
Address 
Address 
Address 
Address 
Address 
a 
VideoNot e 
Pointer 
Variables 
of letter 
is: 
4468752 
of number is: 
4468754 
of amount is: 
4468756 
of profit 
is: 
4468760 
of ch is: 
4468768 
T he value &amount specifies the locat ion of the var iable amount in the computer 's 
memory: in a sense, it points to amount. A value that represents the address of a memory 
locat ion, or holds the address of some variable, is called a pointer . 
Pointer Variables 
CONCEPT: 
A pointer variable is a variable that hold s addre sses of memory location s. 
Like other data values, memory addresses, or pointer values, can be stored in variables 
of the appropriate type. A variable that stores an address is called a pointer variable, 
but is often simply referred to as just a pointer . The definit ion of a pointer variab le, say 
ptr , must specify the type of data that ptr will point to. Here is an example: 
int 
*pt r ; 
The asterisk before the variable name indicates that pt r is a pointer variable, and the int 
data type indicates that pt r can only be used to point to, or hold addresses of, integer 
variables. This definition is read as "ptr is a pointer to int." It is also useful to think of "'ptr 
as the "variable that pt r points to. " With this view, the definition of ptr just given can be 
read as "the variable that ptr points to has type int." Because the asterisk (''·) allows you to 
pass from a pointer to the variable being pointed to, it is called the indirection operator. 

648 
Chapte r 10 
Pointers 
Some programmers prefer to declare pointers with the asterisk next to the type name, 
rather than the variable name. For example, the declaration shown above could be 
written as: 
i nt* ptr; 
This style of declaration might visually reinforce the fact that pt r 's data type is not int 
but pointer-to- i nt. Both declaration styles are correct . 
Program 10-2 demonstrate s a very simple usage of a pointer: storing and printing the 
address of another variab le. 
Program 10-2 
1 II This program stores 
the address 
of a variable 
in a pointer. 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 int main() 
6 { 
7 
int x = 25; 
I I int variable 
8 
int *ptr; 
II Pointer 
variable, 
can point to an int 
9 
10 
ptr = &x; 
II Store the address 
of x in ptr 
11 
cout << "The value in xis"<< 
x << endl; 
12 
cout << "The address 
of xis"<< 
ptr << endl; 
13 
return 
O; 
14 } 
Program Output 
The value in xis 
25 
The address 
of xis 
Ox7e00 
Figure 10-2 
In Program 10-2, two variables are defined: x and ptr. The variable xis an int , while 
pt r is a pointer to an int. The variab le x is initialized with 25, while pt r is assigned the 
address of x with the following statement: 
pt r = &x; 
Figure 10-2 illustrates the relationship between pt r and x. 
X 
25 
ptr 
I Ox7e00 
Address of x: Ox7e00 
As shown in Figure 10-2, the variable x is located at memory address Ox7e00 and 
conta ins the number 25, while the pointer ptr contains the address Ox7e00. In essence, 
ptr "points" to the variable x. 

10.2 Pointer Variables 
649 
You can use a pointer to indir ectly access and modify the variable being pointed to. 
In Program 10-2, for instance , ptr co uld be used to change the contents of the variabl e 
x. When the indirection ope rat or is placed in front of a pointer variable name, it 
dereferences the pointer. When you are wo rkin g with a dereferenced pointer , you are 
actually wo rkin g with the value the pointer is pointing to . Thi s is demonstrated 
in 
Program 10-3. 
Program 10-3 
1 II This program demonstrates 
the use of the indirection 
2 II operator. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
9 
10 
11 
12 
int 
X = 25; 
int 
*pt r ; 
ptr = &x; 
I I int variable 
II Pointer 
variable, 
can point 
to an int 
II Store 
the address 
of x in ptr 
13 
II Use both x and ptr to disp lay the value 
in x 
14 
cout << "Here is the value in x , printed 
twice :\n"; 
15 
cout << x <<" 
"<< 
*pt r << endl ; 
16 
17 
II Ass i gn 100 to the location 
pointed 
to by ptr 
18 
II This will 
act ual ly assign 
100 to x . 
19 
*ptr = 100; 
20 
21 
II Use both x and ptr to display 
the value 
in x 
22 
cout << "Once aga i n, here is the value 
in x:\n"; 
23 
24 
25 } 
cout << x <<" 
return 
O; 
"<< 
*pt r << endl ; 
Program Output 
Here is the value in x, printed 
twice: 
25 
25 
Once again , here is the value 
in x: 
100 
100 
Every time the expression *ptr appears in Program 10-3, the program indirectly uses 
the variable x. Th e following cout statement displays the value in x twice: 
cout << x <<" 
"<< 
*pt r << endl ; 
And the following statement stores 100 in x: 
*ptr = 100; 
With the indirection operator, 
pt r can be used to indirectly access the variab le it is 
pointing to. Program 10-4 demonstrates that pointers can point to different var iables . 

650 
Chapte r 10 
Pointers 
Program 10-4 
1 II Thi s program demonstrates 
the abi l ity of a pointer 
to 
2 II poi nt to di fferent 
variables
. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
9 
10 
int 
X = 25, y = 50, 
Z = 75 ; 
int *pt r ; 
II Three int var i ables 
II Poi nter variable 
11 
II Display 
the contents 
of x, y, and z 
12 
cout << "Here are the values 
of x, y, and z: \ n"; 
13 
cout << x <<" 
"<< 
y <<" 
"<< 
z << end l; 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
II Use the pointer 
to manipulate 
x, y, and z 
ptr = &x; 
II Store 
the address 
of X in ptr 
*ptr 
*= 2; 
II Mult i ply value i n X by 2 
ptr = &y; 
II Store 
the address 
of y in ptr 
*ptr 
*= 2; 
II Mult i ply value i n y by 2 
ptr = &z; 
II Store 
the address 
of z in ptr 
*ptr 
*= 2; 
II Mult i ply value i n z by 2 
26 
II Di splay the contents 
of x, y, and z 
27 
cout << "Once aga i n, here are the values" 
28 
<< ''of x 1 y, and z :\n"; 
29 
cout << x <<" 
"<< 
y <<" 
"<< 
z << end l; 
30 
return 
O; 
31 } 
Program Output 
Here are the values 
of x, y, and z: 
25 
50 
75 
Once again , here are the values 
of x , y, and z: 
50 
100 
150 
<) NOTE: So far you've seen three different uses of the asterisk in C++: 
• As the multiplication operator, in statements such as 
distance
= speed* 
time; 
• In the definition of a pointer variable, such as 
int 
*pt r ; 
• As the indirection operator, in statements such as 
*pt r = 100; 

10.3 
10.3 The Relationship Between Arrays and Pointers 
651 
The Relationship Between Arrays and Pointers 
CO N C E PT: Array nam es can be used as pointer constants, and point ers can be used as 
array names. 
You learned earlier that an array name, without brackets and a subscript, actually 
represents the starting address of the array. This means that an array name is really a 
pointer. Progr am 10-5 illustrates this by showing an array name being used with the 
indirection operator. 
Program 10-5 
1 II This program shows an array name being dereferenced 
with the* 
2 II operator. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
short 
numbers[]
= {10, 20, 30, 40 , 50}; 
9 
10 
cout << "The first 
element of the array is"· 
11 
cout <<*numbers<< 
endl; 
12 
return 
O; 
13 } 
Program Output 
The first 
element of the array is 10 
Because numbers works like a pointer to the starting address of the array in Program 10-5, 
the first element is retrieved when numbers is dereferenced . So, how could the entire con-
tents of an array be retrieved using the indirection operato r? Remember, array elements 
are stored together in memory, as illustrated in Figure 10-3. 
Figure 10-3 
numbers[OJ 
numbers[1] 
numbers[2] 
numbers[3] 
numbers[4] 
t 
numbers 
It makes sense that if numbers is the address of numbers[OJ, values could be added to 
numbers to get the addresses of the othe r elements in the array . It's important to know, 
however, that pointers do not work like regular variables when used in mathematica l 
statements . In C++, when you add a value to a pointer, you are actually adding that 
value times the size of the data type being referenced by the pointer . In other words, 

652 
Chapte r 10 
Pointers 
if you add one to numbers, you are actua lly adding 1 * s i zeof (short ) to numbers. If 
you add two to numbers , the result is numbers+ 2 * sizeof(short)
, and so forth. On 
a PC, this means the following are true because short integers typically use 2 bytes: 
* (numbers + 1) is the value at address numbers + 1 * 2 
* (numbers + 2) is the value at address numbers + 2 * 2 
* (numbers + 3) is the value at address numbers + 3 * 2 
and so forth. 
Thi s aut omatic convers ion means that an element in an array can be retrieved by using 
its subscript or by adding its sub script to a pointer to the ar ra y. If the express ion 
*numbers , which is the same as* (numbers+ O), retrieves the first element in the array, 
then * ( numbers + 1 ) retrieves the second element. Likewise, * ( numbers + 2) retrieves 
the third element, and so forth . Figure 10-4 shows the equivalence of subscript notation 
and pointer notation. 
Figure 10-4 
numbers[O] 
numbers[ 1] 
numbers[2] 
numbers[3] 
numbers[4 ] 
I 
I 
I 
I 
I 
t 
t 
t 
t 
t 
*numbers 
* (numbers +1) *(numbers+2) *(numbers+3) 
*(numbers+4) 
0 
NOTE: 
Th e parentheses are critical when adding values to pointers. Th e* operator 
has precedence over the + operato r, so the expression *numbers+ 1 is not equivalent 
to * (numbers + 1). Th e expression *numbers + 1 adds one to the contents of the first 
element of the array, while* (numbers+ 1) adds one to the address in numbers, then 
dereferences it. 
Program 10-6 shows the entire contents of the array being accessed, using pointer notation. 
Program 10-6 
1 II This program processes 
an array 
using pointer 
notat ion. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
8 
9 
const i nt SIZE= 5 ; 
int numbers[SIZE ]; 
II Size of the array 
II Array of integers 
10 
II Get values 
to store 
in the array 
11 
II Use pointer 
notation 
instead 
of subscripts 
12 
cout <<"Enter"<< 
SIZE<<
" numbers: "; 
13 
for (int 
count
= O; count< 
SIZE; count ++) 
14 
cin >> *(numbers+ 
count ); 
15 
(program continues) 

10.3 The Relationship Between Arrays and Pointers 
653 
Program 10-6 
(continued) 
16 
II Display the values 
in the array 
17 
II Use pointer 
notation 
instead 
of subscripts 
18 
cout << "Here are the numbers you entered:\n"; 
19 
for (int 
count
= O; count< 
SIZE; count ++) 
20 
cout <<*(numbers+ 
count)<<""; 
21 
cout << endl ; 
22 
return 
O; 
23 ) 
Program Output with Example Input Shown in Bold 
Enter 5 numbers: 5 10 15 20 25 [Enter] 
Here are the numbers you entered: 
5 10 15 20 25 
When working with arrays, remember the following rule: 
array [i ndex] is equivalent to * ( array + i ndex) 
CD 
WARNING! 
Remember that C++ performs no bounds checking with arrays . 
When stepping through an array with a pointer, it's possible to give the pointer an 
address outside of the array. 
To demonstrate just how close the relationsh ip is between array names and pointers, 
look at Program 10-7. It defines an array of doubles and a doubl e pointer , which is 
assigned the starting address of the array . Not only is pointer notation then used with 
the array name , but subscript notation is used with the pointer! 
Program 10-7 
1 II Thi s program uses subscript 
notation 
wi th a pointer 
2 II variable 
and pointer 
notation 
with an array name. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
const i nt NUM
_COINS = 5 ; 
10 
double coins[NUM_COINS] = {0 .05 , 0.1, 
0 .25 , 0.5, 
1 .0}; 
11 
double *doublePtr; 
II Pointer 
to a double 
12 
13 
II Assi gn the address 
of the coins array to doublePtr 
14 
doublePtr 
= coins; 
15 
16 
II Display the contents 
of the coins array 
17 
II Use subscripts 
with the pointer! 
18 
cout << setprecis
i on(2); 
19 
cout << "Here are the values 
in the coi ns array:\n"; 
20 
for (int 
count
= O; count< 
NUM
_COINS; count++ ) 
21 
cout << doublePtr[count] 
<<" 
"; 
22 
(program continues) 

654 
Chapte r 10 
Pointers 
Program 10-7 
(continued) 
23 
II Di splay the contents 
of the coins array 
again , but 
24 
II this 
time use poi nter 
notat i on with the array 
name ! 
25 
cout << "\nAnd here they are aga i n:\n"; 
26 
for (i nt count
= O; count< 
NUM
_COINS; count++ ) 
27 
cout <<*(co i ns+ 
count)<<" 
"; 
28 
cout << endl; 
29 
ret urn O; 
30 } 
Program Output 
Here are the values 
in the coins array: 
0.05 0.1 0.25 0.5 1 
And here they are again: 
0.05 0.1 0.25 0.5 1 
Notice that the address operator is not needed when an array's address is assigned to a 
pointer. Since the name of an array is already an address, use of the & operator would 
be incorrect. You can, however, use the address operator to get the add ress of an 
ind ivid ual element in an array . For instance, &numbe r s [ 1] gets the address of 
numbers [ 1] . Th is technique is used in Program 10-8. 
Program 10-8 
1 II Thi s program uses the address 
of each element in the array. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const i nt NUM
_COINS = 5 ; 
9 
double coins[NUM_COINS] = {0 .05, 0.1, 
0 .25 , 0.5, 
1 .O}; 
10 
double *doublePtr; 
II Pointer 
to a double 
11 
12 
II Use the pointer 
to di splay the values 
in the array 
13 
cout << setprec
i si on(2}; 
14 
cout << "Here are the values 
in the coins array:\n"; 
15 
for (i nt count = O; count< 
NUM
_COINS; count++ ) 
16 
{ 
17 
doublePtr 
= &coins [count ]; 
18 
cout << *doublePtr 
19 
} 
20 
cout << endl; 
21 
ret urn O; 
22 } 
Program Output 
<< " ". ' 
Here are the values 
in the coins array: 
0.05 0.1 0.25 0.5 1 

10.4 Pointer Arithmetic 
655 
The only difference between array names and pointer variables is that you cannot change 
the address an array name points to. For example, given the following definitions: 
double readings
[20 ], totals[20
] ; 
double *dptr; 
These statements are legal: 
dptr = readings
; II Make dptr poi nt to read i ngs 
dptr = totals
; 
II Make dptr poi nt to totals 
But these are illegal: 
read i ngs= 
totals
; 
totals= 
dptr; 
II ILLEGAL! Cannot change readings 
II ILLEGAL! Cannot change totals 
Array names are pointer constants . You can't make them point to anything but the 
array they represent. 
Pointer Arithmetic 
CONCEPT: 
Some mathema tical operations may be performed on pointers. 
The contents of pointer variables may be changed with mathematical statements that 
perform addition or subtract ion . This is demonstrated in Program 10-9. The first loop 
increments the pointer variable, stepping it through each element of the array. Th e 
second loop decrements the pointer, stepping it through the array backwards . 
Program 10-9 
1 II Thi s program uses a pointer 
to di splay 
2 II the contents 
of an array . 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const i nt SIZE= 8; 
9 
int set [ J = { 5 , 10 , 15 , 20 , 25 , 30, 35 , 40} ; 
10 
int *numPtr; 
II Pointer 
11 
12 
II Make numPtr poi nt to the set array 
13 
numPtr = set ; 
14 
15 
II Use the pointer 
to di splay the array elements 
16 
cout << "The numbers i n set are :\n"; 
17 
for (i nt index= 
O; index< 
SIZE; i ndex ++) 
18 
{ 
19 
cout << *numPtr <<" 
"; 
20 
numPtr++; 
21 
22 
} 
(program continues) 

656 
Chapte r 10 
Pointers 
Program 10-9 
(continued) 
23 
// Display the array elements 
in reverse 
order 
24 
cout << "\nThe numbers i n set backwards are: \n"; 
25 
for (int 
index= 
O; index< 
SIZE; i ndex++) 
26 
{ 
27 
numPtr--; 
28 
cout << *numPtr <<" 
"; 
29 
} 
30 
return 
O; 
31 } 
Program Output 
The numbers in set are: 
5 10 15 20 25 30 35 40 
The numbers in set backwards are: 
40 35 30 25 20 15 10 5 
0 
NOTE: 
Because numPtr is a pointer, the increment operator adds the size of one 
integer to numPtr, so it points to the next element in the array. Likewise, the 
decrement operator subtracts the size of one integer from the pointer. 
Not all arithmetic operations may be performed on pointers. For examp le, you cannot 
use multipication or division with pointers. The following operations are allowable: 
• The ++ and -- operators may be used to increment or decrement a pointer variable. 
• An integer may be added to or subtr acted from a pointer variable. This may be 
performed with the + and - operators, or the += and - = operators . 
• A pointer may be subtr acted from another pointer. 
Initializing Pointers 
CONCEPT: 
Pointers may be initialized with the address of an existing object. 
Remember that a pointer is designed to point to an object of a specific data type. When a 
pointer is initialized with an address, it must be the address of an object the pointer can point 
to. For instance, the following definition of pi nt is legal because myVa 1 ue is an integer: 
i nt myValue; 
i nt *pi nt= 
&myValue; 
The following is also legal because ages is an array of integers: 
i nt ages [20]; 
int 
*pi nt= 
ages; 
But the following definition of pint is illegal because myFloat is not an i nt: 
fl oat my Fl oat; 
int 
*pi nt= 
&myFloat; 
/ / I 11 ega 1 ! 

10.5 Initia lizing Pointers 
657 
Pointers may be defined in the same statement as other variables of the same type. The 
following declaration defines an integer variable, myVal ue, and then defines a pointer, 
pint, which is initialized with the address of myVal ue: 
i nt myValue, *pi nt= 
&myValue; 
And the following definition defines an array, readings, and a pointer, marker , which 
is initialized with the address of the first element in the array : 
double readings[50]
, *marker
= readings; 
Of course, a pointer can only be initialized with the address of an object that has 
already been defined. The following is illegal because pi nt is being initialized with the 
address of an object that does not exist yet: 
i nt *pi nt= 
&myValue; 
i nt myValue; 
I I I 11 ega l ! 
A local pointer variable that has not been initialized does not hold a valid address, and 
an attempt to use such a pointer will result in execution -time errors . The convention in 
older versions of C++ is to assign the address O to a pointer that does not currentl y 
point to a valid memory location: 
i nt *pt rToint 
= O; 
double *ptrToDouble 
= O; 
In many comp uters, the address O is occupied by operating system data and is not 
accessible to user programs. This makes O a safe choice for a value that indicates an 
invalid memory location. 
Many header files, including i ostream, fstream, and cstdl i b, define a constant named 
NULL to represent the pointer value 0. Assuming one of these header files has been 
included, we can rewrite the above code as 
i nt *pt rToint 
= NULL; 
double *ptrToDouble 
= NULL; 
Many people prefer this latter form because NULL is clearly recognized as denoting the 
address O rather than the integer 0. Regardless, a pointer whose value is O is called a 
null pointer. C++ 11 defines the key word null ptr to indicate an invalid memory 
address: 
int 
*pt rToint 
= nullptr; 
double *ptrToDouble 
= nullptr; 
You can test a pointer p against 0, NULL, or null ptr to determine if it points to a valid 
address using equality-testing operato rs ! = and ==. For example, 
i f (p != nullptr) 
{ 
II use the poi nter 
p ... 
} 
i f (p != NULL) { II use the poi nter p 
} 
i f (p != 0) { II use the pointer 
p . .. } 
The pointer will only be used if it does not evaluate to 0, so each of the above tests is 
equivalent to 
if 
(p) { II 
use the pointer 
p . .. } 
In C++ 11, putting an empty pair of braces { } at the end of a variab le definition 
initializes the variable to its default value. The default value for numeric types such as 

658 
Chapter 10 
Pointers 
int, 1 ong, and doub 1 e is zero, while the defau lt value for pointer types is null pt r. 
Thus, the following definitions 
int mylnt = O; 
double myDouble = 0.0; 
i nt *pt rTolnt = nullptr; 
are equivalent to 
i nt mylnt{ }; 
double myDouble{ }; 
int *pt rTolnt{ 
}; 
It is important to be able to check at a glance whether a pointer has been assigned a 
correct value. For this reason, pointers should always be initialized or assigned a value 
close to where they are defined. Also, a pointer that is no longer pointing to a valid 
location should be assigned a value of null ptr unless the pointer is going out of scope 
or the program is about to terminate. 
~ 
Checkpoint 
10.1 
Write a statement that displays the address of the variab le count. 
10.2 
Write a statement defining a variable dPtr. Th e variable should be a pointer to 
a double. 
10.3 
List three uses of the * symbol in C++. 
10.4 
What is the output of the following program? 
#include 
<iostream> 
usi ng namespace std; 
int mai n() 
{ 
} 
int 
X = 50 , y = 60, 
Z = 70 ; 
int *ptr = nullptr; 
cout 
<< x <<" 
'' << y <<" 
'' << z << endl ; 
ptr = &x; 
*pt r *= 10; 
ptr = &y; 
*pt r *= 5 ; 
ptr = &z; 
*pt r *= 2 ; 
cout 
<< x <<" 
'' << y <<" 
'' << z << endl ; 
return 
O; 
10.5 
Rewrite the following loop so it uses pointer notation (with the indirection 
operator) instead of subscript notation. 
for (i nt x = O; x < 100 ; x++) 
cout << array[x ] << endl; 
10.6 
Assume ptr is a pointer to an int and holds the address 12000. On a system 
with 4-b yte integers, what address will be in pt r after the following statement? 
ptr += 10; 

Figure 10-5 
10.6 Compa ring Pointers 
659 
10. 7 
Assume pint is a pointer variable. For each of the following statements, determine 
whether the statement is valid or invalid. For those that are invalid, explain why. 
A) pi nt ++; 
B) --pint
; 
C) pi nt /= 2 ; 
D) pi nt *= 4; 
E) pi nt += x ; / / Assume x is an int. 
10.8 For each of the following variable definitions, determine whether the statement 
is valid or invalid. For those that are invalid , explain why. 
A) int ivar; 
int *i ptr = &ivar ; 
B) int ivar, 
*iptr 
= &ivar ; 
C) fl oat fvar; 
D) int *i ptr = &fvar ; 
int nums[50], 
*i ptr = nums; 
E) int *i ptr = &ivar ; 
int ivar; 
Comparing Pointers 
CONCEPT: 
C++'s relation al operators may be used to compare pointer values. 
Pointers may be compared by using any of C++'s relational operators: 
> < == != >= <= 
If one address comes before another address in memory, the first address is considered 
"less than" the second . In an array, all the elements are stored in consec utive memory 
locations, so the address of element 1 is greater than the address of element 0. This is 
illustrated in Figure 10-5. 
An array of five integers 
array[OJ 
array[1] 
array[2] 
array[3] 
array[4] 
t 
t 
t 
t 
t 
Ox5AO
O 
Ox5A04 
Ox5A08 
Ox5AOC 
Ox5A10 
(Addresses) 
Because the addresses grow larger for each subseq uent element in the array, the 
following Boolean expressions are all true: 
&array [1] > &array[O J 
array< 
&array [4] 
array== 
&array [OJ 
&array [2] != &array [3] 

660 
Chapte r 10 
Pointers 
0 
NOTE: 
Comparing two pointers is not the same as comparing the values the two 
pointers point to. For example, the following i f statement compares the addresses 
sto red in the pointer variab les pt r 1 and pt r2: 
if 
(ptr1 
< ptr2) 
Th e following statement, however, compares the values that ptr1 and ptr2 point to: 
if 
(*ptr1 
< *ptr2) 
Th e capability of comparing addresses gives you another way to be sure a pointer does not 
go beyond the boundaries of an array . Program 10-10 initializes the pointer numPtr with 
the starting address of the array set. The pointer numPtr is then stepped through the array 
set until the address it contains is equal to the address of the last element of the array . 
Th en the pointer is stepped backwards through the array until it points to the first element. 
Program 10-10 
1 II Thi s program uses a pointer 
to di splay the contents 
2 II of an i nteger 
array. 
It illustrates 
the comparison 
of 
3 II poi nters. 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
const 
i nt SIZE= 
8 ; 
1 0 
int set [ ] = { 5 , 1 0, 15 , 20 , 25 , 30, 35, 40} ; 
11 
int 
*numPtr = set; 
II Make numPtr point 
to set 
12 
13 
cout << "The numbers i n set are :\n"; 
14 
cout << *numPtr <<" 
"; 
II Di splay f i rst 
element 
15 
whi le (numPtr < &set[SIZE- 1]) 
16 
{ 
17 
II Advance numPtr to the next element 
18 
numPtr+ +; 
19 
II Di splay 
the value pointed 
to by numPtr 
20 
cout << *numPtr <<" 
"; 
21 
} 
22 
23 
II Di splay the numbers i n reverse 
order 
24 
cout << "\nThe numbers i n set backwards are: \ n"; 
25 
cout << *numPtr <<" 
"; II Display 
last 
element 
26 
whi le (numPtr > set) 
27 
{ 
28 
II Move backward to the prev i ous element 
29 
numPtr-- ; 
30 
II Display 
the value pointed 
to by numPtr 
31 
32 
} 
cout << *numPtr <<" 
"; 
33 
ret urn O; 
34 } 
(program continues) 

Program 10-10 
(continued) 
Program Output 
The numbers in set are: 
5 10 15 20 25 30 35 40 
The numbers in set backwards are: 
40 35 30 25 20 15 10 5 
10.7 Pointers as Function Parameters 
661 
Most comparisons involving pointers compare a pointer to o, NULL, or nul 1 ptr to 
determine whether the pointer points to a legitimate address . For examp le, assuming 
that ptrTolnt has been defined as a pointer to int, the code 
if (ptrTolnt 
!= nullptr) 
cout << *ptrTolnt; 
else 
cout << "nul l pointer "; 
prints the integer pointed to only after verifying that ptrTolnt is not a null pointer. 
Pointers as Function Parameters 
CONCEPT: 
A pointer can be used as a function paramete r. It gives the function 
access to the original argument, much like a reference parameter does. 
In Chapte r 6 you were introd uced to the concept of reference variables being used as 
function parameters. A reference variable acts as an alias to the original variab le used 
as an argument . This gives the function access to the original argument variable, 
allowing it to change the variable's contents . When a variab le is passed into a reference 
parameter , the argument is said to be passed by reference. 
An alternative to passing an argument by reference is to use a pointer variable as the 
parameter. Admittedly , reference variables are much easier to work with than pointers. 
Reference variab les hide all the "mechan ics" of dereferencing and indirection. You 
should still learn to use pointers as function arguments , however, because some tasks, 
especially when dealing with C-strings, are best done with pointers. ,. Also, the C++ 
library has many functions that use pointers as parameters. 
Here is the definition of a function that uses a pointer parameter: 
voi d doubleValue (i nt *val ) 
{ 
*val *= 2 ; 
} 
• It is also important to learn the technique in case you ever have to wr ite a C program. In C, the 
only way to get the effect of pass by reference is to use a pointer 

662 
Chapte r 10 
Pointers 
The purpose of this function is to double the variable pointed to by val with the 
following statement: 
*val *= 2; 
When val is dereferenced , the ''·= operator works on the variab le pointed to by val. 
This statement multip lies the original variable, whose address is stored in va 1, by two. 
Of course, when the function is called, the address of the variable that is to be doubled 
must be used as the argument, not the variable itself. 
Here is an examp le of a call to the doubl eVal ue function: 
doubleValue(&number); 
This statement uses the address operator(&) to pass the address of number into the val 
parameter. After the function executes, the contents of number will have been multiplied 
by two . 
The use of this function is illustrated in Program 10-11. 
Program 10-11 
1 II Thi s program uses two func t ions tha t accept 
2 II addresses 
of variables 
as arguments . 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 II Function 
prototypes 
7 void getNu mber(int 
*); 
8 void doubleValue(i
nt *); 
9 
10 int main () 
11 { 
12 
int number; 
13 
14 
II Call getNu mber and pass the address 
of number 
15 
getNumber(&nu mber); 
16 
17 
II Call doubleValue 
and pass t he address 
of number 
18 
doubleValue(&number); 
19 
20 
II Di splay t he value i n number 
21 
cout << "That value doubled 
is"<< 
number<< 
endl; 
22 
return 
O; 
23
} 
24 
25 //****************************************************** 
26 II Defi nition 
of getNumber. 
The parame t er, 
input, 
i s a* 
27 II poi nter . This funct i on asks t he user for a number. 
* 
28 II The value entered 
is st ored in the var i able 
* 
29 II poi nted to by input. 
* 
30 //****************************************************** 
31 
(program continues) 

10.7 Pointers as Function Parameters 
66 3 
Program 10-11 
(continued) 
32 void getNumber(int 
*i nput) 
33 { 
34 
cout << "Enter an integer 
number: "· 
35 
cin >> *input; 
36
) 
37 
38 //****************************************************** 
39 II Definition 
of doubleValue. 
The parameter, 
val, 
40 II poi nter . This function 
multiplies 
the variable 
41 II poi nted to by val by two . 
i s a * 
* 
* 
42 //****************************************************** 
43 
44 void doubleValue (i nt *val) 
45 { 
46 
*val *= 2; 
47
) 
Program Output with Example Input Shown in Bold 
Enter an integer 
number: 1 O[Enter] 
That value doubled is 20 
CD 
Program 10-11 has two functions that use pointers as parameters. Notice the function 
prototypes: 
voi d getNumber(int 
*); 
voi d doubleValue( i nt *); 
Each one uses the notation int * to indicate the parameter is a pointer to an int. As 
with all other types of parameters, it isn't necessary to specify the name of the variable 
in the prototype. The * is required, though. 
The getNumber function asks the user to enter an integer value. The following ci n 
statement stores the value entered by the user in memory: 
cin >> *input; 
The indirection operato r causes the value entered by the user to be stored, not in input, 
but in the variable pointed to by input. 
WARNING! 
It 's crit ical that the indirection operator be used in the previous 
statement. Without it, ci n would store the value entered by the user in i nput, as if 
the value were an address . If this happens, i nput will no longer point to the number 
variable in function main. Subsequent use of the pointer will result in erroneous, if 
not disastrous, results. 
When the getNumber function is called, the address of the number variable in function 
main is passed as the argument . After the function executes, the value entered by the 
user is stored in number. Next, the doub 1 eVa 1 ue function is called, with the address of 
number passed as the argument . This causes number to be multiplied by two. 

664 
Chapte r 10 
Pointers 
Pointer variables can also be used to accept array addresses as arguments . Either 
subscript or pointer notation may then be used to work with the contents of the array. 
This is demonstrated in Program 10-12. 
Program 10-12 
1 II Thi s program demonstrates 
t hat a poi nt er may be used as a 
2 II parameter 
to accept 
the address 
of an array . Either 
subscript 
3 II or poi nt er not ation 
may be used. 
4 #include 
<iostream> 
5 #include 
<io manip> 
6 using namespace std ; 
7 
8 II Function 
prototypes 
9 void getSales(double 
*sales, 
in t si ze ); 
10 double totalSales(double 
*sales, 
i nt si ze ); 
11 
12 int main () 
13 { 
14 
const 
i nt QUARTERS= 4; 
15 
double sales[QUARTERS]; 
16 
17 
getSales
(s ales, 
QUARTERS); 
18 
cout << setprecision(2
); 
19 
cout <<f ix ed<< 
showpoi nt ; 
20 
cout << "The total 
sales 
for t he year are$"; 
21 
cout << t ot alSales(sales, 
QUARTERS)<< endl; 
22 
retur n O; 
23 } 
24 
25 //***************************************************************** 
26 II Defi nition 
of getSales. 
This funct ion uses a pointer 
to accept* 
27 II t he address 
of an array 
of doubles. 
The number of elements 
i n 
* 
28 II in t he array 
is passed as a separate 
i nte ger parameter. 
The 
* 
29 II The function 
asks the user to enter 
the sales 
figures 
for 
* 
30 II four quar t ers, 
then stores 
those 
f i gures in t he array 
using 
* 
31 II subscript 
notation. 
* 
32 //***************************************************************** 
33 void getSales(double 
*array, 
in t si ze ) 
34 { 
35 
36 
for (i nt count = O; count< 
size; 
cou nt ++) 
{ 
37 
cout << "Ent er t he sales 
figure 
for quar ter
"· 
38 
cout <<(count+ 
1) << "· "· 
39 
ci n >> array[cou
nt ] ; 
40 
} 
41 } 
42 
43 //*************************************************************** 
44 II Defi nition 
of totalSales
. This function 
uses a pointer 
to 
* 
45 II accept 
the address 
of an array 
of doubles whose siz e is 
* 
46 II is passed as a separate 
para meter. 
The func t ion uses pointer* 
47 II notation 
t o sum t he elements 
of the array . 
* 
48 //*************************************************************** 
(program continues) 

10.8 Pointers to Constants and Constant Pointers 
665 
Program 10-12 
(continued) 
49 double tota1Sales(double 
*array, 
int size) 
50 { 
51 
double sum= 0 .0; 
52 
53 
for (int count= 
O; count< 
size; 
count+ +) 
54 
{ 
55 
sum+= *array ; 
56 
array+ +; 
57 
} 
58 
return 
sum; 
59
} 
Program Output with Example Input Shown in Bold 
Enter the 
Enter the 
Enter the 
Enter the 
The total 
sales 
figure 
for quarter 
1 : 10263 .98[Enter] 
sales 
figure 
for quarter 
2: 12369 .69[Enter] 
sales 
figure 
for quarter 
3: 11542 . 13 [Enter] 
sales 
figure 
for quarter 
4: 14792 .06[Enter] 
sales 
for the year are $48967.86 
Notice that in the getSales 
function in Program 10-12, even though the parameter 
array is defined as a pointer , subscript notation is used in the ci n statement: 
cin >> array(count
]; 
In the total Sales function, array is used with the indirection operato r in the following 
statement: 
sum+= *array; 
And in the next statement, the address in array is incremented to point to the next element: 
array ++; 
0 
NOTE: The two previous statements could be combined into the following statement: 
sum += *array++; 
10.8 
The ,. operato r will first dereference array, then the ++ operator will increment the 
address in array . 
Pointers to Constants and Constant Pointers 
CONCEPT: 
A pointer to a constant may not be used to change the value it point s 
to; a constant poin ter may not be changed after it has been initialized. 
Pointers to Constants 
You have seen how an item's address can be passed into a pointer parameter, and the 
pointer can be used to modify the item that was passed as an argument . Sometimes it is 
necessary to pass the address of a const item into a pointer. When this is the case, the 

666 
Chapte r 10 
Pointers 
Figure 10-6 
pointer must be defined as a pointer to a const item. For example, consider the 
following array definition: 
const i nt SIZE= 6; 
const double payRates[SIZE] 
= { 18.55, 
17.45 , 
12. 85, 14. 97, 
10. 35, 18. 89 } ; 
In this code, payRates is an array of const doubles. This means that each element in the 
array is a con st doub 1 e, and the compiler will not allow us to write code that changes 
the array's contents . If we want to pass the payRates array into a pointer parameter, the 
parameter must be declared as a pointer to con st doub 1 e. The following function shows 
such an examp le: 
voi d displ ayPayRates(const 
double *rates , int siz e} 
{ 
} 
// Set numeric output 
formatting 
cout << setprecision(2
) <<fixed<< 
showpoint ; 
// Display all 
the pay rates 
for (i nt count= 
O; count< 
size; 
count+ +) 
{ 
} 
cout << "Pay rate 
for employee•<< 
(count+ 
1} 
<<•is$"<< 
*(rates+ 
count}<< 
endl ; 
In the function header, notice that the rates parameter is defined as a pointer to const 
double. It shou ld be noted that the word const is applied to the thing that rates points 
to, not rates itself. This is illustrated in Figure 10-6. 
The asterisk indicates that 
rates 
is a pointer. 
l 
double 1*rates 
I 
This is what rates 
points to. 
Because rates is a pointer to a const, the compiler will not allow us to write code that 
changes the thing that rates points to. 
When passing the address of a constant into a pointer variab le, the variab le must be 
defined as a pointer to a constant. If the word const has been left out of the definition 
of the rates parameter, a compiler error would have resulted. 

10.8 Pointers to Constants and Constant Pointers 
667 
Passing a Non-Constant Argument into a Pointer 
to a Constant 
Altho ugh a constant's address can be passed only to a pointer to const , a pointer to 
const can also receive the address of a non-constant 
item. For examp le, loo k at 
Program 10-13. 
Program 10-13 
1 II Thi s program demonstrates 
a pointer 
to const para mete r 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 void displayVal
ues (cons t int *numbers, i nt size); 
6 
7 int main() 
8 { 
9 
II Array s i zes 
10 
const i nt SIZE= 6; 
11 
12 
II Defi ne an array of const 
ints 
13 
const i nt array1[SIZE ] = { 1, 2, 3, 4, 5 , 6 }; 
14 
15 
II Defi ne an array of non-const 
i nts 
16 
int array2[SIZE ] = { 2, 4, 6 , 8, 10, 12 } ; 
17 
18 
II Di splay the contents 
of the const array 
19 
displayValues(array1, 
SIZE}; 
20 
21 
II Display 
the contents 
of the non-const 
array 
22 
displayValues(array2, 
SIZE}; 
23 
ret urn O; 
24 } 
25 
26 //*************************************************** 
27 II The displayVal
ues funct i on uses a poi nter to 
28 II parameter 
to display 
the contents 
of an array. 
* 
* 
29 //*************************************************** 
30 
31 void displayVal
ues (cons t int *numbers, i nt size) 
32 { 
33 
II Di splay al l the values 
34 
for (i nt count = O; count< 
size ; count ++) 
35 
{ 
36 
cout <<*(numbers
+ count )<<" 
"· 
37 
} 
38 
cout << endl; 
39 } 
Program Output 
1 2 3 4 5 6 
24681012 

668 
Chapter 10 
Pointers 
0 
Figure 10-7 
NOTE: When writing a function that uses a pointer parameter, and the function 
is not intended to change the data the parameter points to, it is always a good idea 
to make the parameter a pointer to const. Not only will this protect you from 
writing code in the function that accidentally changes the argument, but the function 
will be able to accept the addresses of both constant and non-constant arguments. 
Constant Pointers 
In the previous section we discussed pointers to const, that is, pointers that point to 
cons t data . You can also use the const key word to define a constant pointer. Here is 
the difference between a pointer to const and a const pointer: 
• A pointer to const points to a constant item. The data that the pointer points to 
cannot change, but the pointer itself can change. 
• With a const pointer, it is the pointer itself that is constant . Once the pointer is 
initialized with an address, it cannot point to anything else. 
The following code shows an example of a const pointer. 
i nt value= 
22; 
i nt* 
const pt r = &value; 
Not ice in the definition of pt r that the word const appears after the asterisk. This 
means that ptr is a cons t pointer. This is illustrated in Figure 10-7. In the code, pt r is 
initialized with the address of the value variable . Because pt r is a constant pointer, a 
comp iler error will result if we write code that makes pt r point to anything else. An 
error will not result, however, if we use pt r to change the contents of value. This is 
because value is not constant, and pt r is not a pointer to const . 
* const indicates that 
pt r is a constant pointer. 
1int
1
1
• clnst
1 ptr 
I 
This is what pt r points to. 
Constant pointers must be initialized with a starting value, as shown in the previous 
example code. If a constant pointer is used as a function parameter, the parameter will 
be initialized with the address that is passed as an argument into it and cannot be 
changed to point to anything else while the function is executing . Here is an example 
that attempts to violate this rule: 
voi d se t ToZero( i nt * const pt r) 
{ 
ptr = O; 
II ERROR!! Cannot change the conte nt s of ptr. 
} 

Figure 10-8 
10.8 Pointers to Constants and Constant Pointers 
669 
This function's parameter, ptr, is a const pointer. It will not compile because we 
cannot have code in the function that changes the contents of ptr . However, ptr does 
not point to a const, so we can have code that changes the data that ptr points to. 
Here is an example of the function that will compile: 
voi d setToZero
(int 
* const 
ptr) 
{ 
*ptr = O; 
} 
Although the parameter is const pointer, we can call the function multiple times with 
different arguments . The following code will successfully pass the addresses of x, y, 
and z to the setToZero function: 
int 
X, y, 
Z ; 
II 
Set x , y, and z to 0. 
setToZero(&x); 
setToZero(&y); 
setToZero(&z); 
Constant Pointers to Constants 
So far, when using const with pointers we've seen pointers to constants and we've seen 
constant pointers . You can also have constant pointers to constants. For example, look 
at the following code: 
i nt value= 
22 ; 
const 
i nt* 
const 
ptr = &valu e ; 
In this code ptr is a const pointer to a const 
int. Notice the word const appears 
before int, indicating that ptr points to a const int, and it appears after the asterisk, 
indicating that ptr is a constant pointer. This is illustrated in Figure 10-8. 
* const indicates that 
pt r is a constant pointer. 
~lc_o_n_s_t~i_n_t~I 
1• cLs 
t
1 
pt r 
I 
This is what pt r points to. 
In the code, pt r is initialized with the address of value. Because ptr is a const pointer, 
we cannot write code that makes ptr point to anything else. Because pt r is a pointer to 
const, we cannot use it to change the contents of value. The following code shows one 

6 70 
Chapte r 10 
Pointers 
more example of a con st pointer to a con st. This is another version of the di spl ayVal ues 
function in Program 10-13. 
voi d di splayValues (const int * const numbers, int si ze) 
{ 
// Display all the values . 
for (i nt count= 
O; count< 
si ze; count++) 
{ 
cout <<*(numbers
+ count)<<" 
"; 
) 
cout << endl ; 
) 
In this code, the parameter numbers is a const pointer to a const int. Although we can 
call the function with different arguments, the function itself cannot change what 
numbers points to, and it cannot use numbers to change the contents of an argument . 
Focus on Software Engineering: 
Dynamic Memory Allocation 
CONCEPT: 
Variab les may be created and destroyed while a progra m is running. 
As long as you know how many variables you will need during the execution of a 
program, you can define those variables up front. For example, a program to calculate 
the area of a rectangle will need three variables: one for the rectangle's length, one 
for the rectang le's width, and one to hold the area. If you are writing a program to 
compute the payroll for 30 employees, you'll probably create an array of 30 elements 
to hold the amount of pay for each person. 
But what about those times when you don't know how many variables you need? For 
instance, suppose you want to write a test-averaging program that will average any 
number of tests. Obviously, the program would be very versatile, but how do you store 
the individual test scores in memory if you don't know how many variables to define? 
Quite simply, you allow the program to create its own variables "on the fly." This is 
called dynamic memory allocation and is only possible through the use of pointers. 
To dynamically allocate memory means that a program, while running, asks the 
computer to set aside a chunk of unused memory large enough to hold a variab le of a 
specific data type. Let's say a program needs to create an integer variable. It will make 
a request to the computer that it allocate enough bytes to sto re an int. When the 
computer fills this request, it finds and sets aside a chunk of unused memory large 
enough for the variable. It then gives the program the starting address of the chunk of 
memory. The program can only access the newly allocated memory through its address, 
so a pointer is required to use those bytes. 
The way a C++ program requests dynamically allocated memory is through the new 
operator. Assume a program has a pointer to an int defined as 
i nt *i ptr = nullptr; 

Figure 10-9 
a 
VideoNot e 
Dynamically 
Allocating an 
Array 
10.9 Focus on Software Engineering: Dynamic Memory Allocation 
671 
You can use the new operator to dynamically allocate an integer variable and assign the 
address of the newly allocated variable to i ptr like this: 
i ptr = new in t ; 
The operand of the new operator is the data type of the variable being created . This is 
illustrated in Figure 10-9. Once the statement executes, i pt r will contain the address 
of the newly allocated memory . A value may be stored in this new variable by 
dereferencing the pointer: 
*iptr 
= 25; 
i pt r variable 
I 
OxA654 
I 
I 
Pool of unused memory 
This chunk of memory starts 
at address OxA654 
Any other operation may be performed on the new variable by simply using the 
dereferenced pointer. Here are some example statements: 
cout << *ip t r; 
ci n >> *i ptr; 
total 
+= *iptr; 
// Di splay the cont ents of t he new variable. 
// Let t he user i nput a value. 
// Use t he new variable 
in a computatio n. 
Although these statements illustrate the use of the new operator, there's little purpose in 
dynamically allocating a single variable. A more pract ical use of the new operator is to 
dynamically create an array. Here is an example of how a 100-element array of integers 
may be allocated: 
i ptr = new in t [100]; 
Once the array is created, the pointer may be used with subscript notation to access it. 
For instance , the following loop could be used to store the value 1 in each element: 
for (i nt count = O; count < 100; count ++) 
ip t r[count] 
= 1; 
Every call to new allocates storage from a special area of the program 's memory called 
the heap. If a program makes a lot of requests for dynam ic memory , the heap will 
eventually become depleted , and additiona l calls to new will fail. When this happens, 
the C++ runtime system will throw a bad_al loc exception to notify the calling program 
that the requested memory cannot be allocated . An exceptio n is a mechanism for 
notifying a program that something has gone drastically wrong with the operation that 

672 
Chapte r 10 
Pointers 
CD 
was being executed and that the results of the operation cannot be trusted. The default 
action of an exception is to force the executing program to terminate . 
A program that has finished using a dynamically allocated block of memory should free 
the memory and return it to the heap to make it available for future use. This is accomplished 
by calling the de l ete operator and passing it the address of the memory to be deallocated. 
After de l ete has completed, the value of the pointer should be set to null pt r to indicate 
that it is no longer valid. The only exception to this rule is in situations (such as at the end 
of the program) where it is clear that the deleted pointer will never be used again. Here is 
an example of how delete is used to free up a single variable pointed to by i ptr: 
delete 
ip t r; 
i ptr = nullptr; 
If i pt r points to a dynam ically allocated array, a pair of square brackets must be 
placed between delete 
and ip t r: 
delete 
[ ] iptr; 
i ptr = nullptr; 
Unless a pointer is going out of scope, it is good practice to set its value to null ptr 
immediately after de 1 ete has been called on it. This will make it clear to the rest of the 
program that the pointer no longer refers to a valid memory location . It also avoids 
problems that can arise from calling de 1 ete more than once on the same pointer. This 
is because de 1 ete is designed to do nothing when called on a null pointer. 
Dangling Pointers and Memory Leaks 
A pointer is said to be dangling if it is pointing to a memory location that has been 
freed by a call to delete. 
When you access a dangling pointer, you are trying to use 
memory that has already been freed and returned to the heap. In fact, such memory 
may already be reallocated by another call to new. You can avoid the use of dangling 
pointers by always 
1. setting pointers to null as soon as their memory is freed, and 
2. verifying that a pointer is not null before you attempt to access its memory . 
A memory leak is said to occur in your program if, after you have finished using a 
block of memory allocated by new, you forget to free it via de 1 ete . The leaked block of 
memory remains unavailab le for use until the program terminates. Memory leaks are 
especially serious when they occur in loops. They are even more serious in programs 
such as Web servers and other network programs that are expected to run for months 
or even years without being shut down. Over time, a Web server with a memory leak 
will exhaust all memory in the computer on which it is running, requiring both it and 
the computer to be shut down and restarted . 
WARNING! 
Only use pointers with de 1 ete that were previously used with new. 
If you use a pointer with delete 
that does not reference dynamically allocated 
memory, unexpected problems could result! 
Program 10-14 demonstrates the use of new and de 1 ete. It asks for sales figures for any 
number of days. The figures are stored in a dynamically allocated array and then 
totaled and averaged. 

10.9 Focus on Software Engineering: Dynamic Memory Allocation 
67 3 
Program 10-14 
1 II Thi s program totals 
and averages 
the sales 
figures 
for 
2 II any number of days. 
The figures 
are stored 
in a 
3 II dynamically 
allocated 
array. 
4 #include 
<iostream> 
5 #include 
<iomanip> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
11 
12 
13 
double *sales= 
nullptr, 
total= 
0.0, 
average; 
II To dynamically 
allocate 
an array 
II Accumulator 
II To hold average 
sales 
int numDays; 
II To hold number of days of sales 
14 
15 
II Get number of days of sales 
16 
cout << "How many days of sales 
figures 
do you wish"· 
17 
cout << "to process?"· 
18 
cin >> numDays; 
19 
20 
II Dynami cally 
allocate 
an array 
large 
enough 
21 
II to hold that 
many days of sales 
amounts 
22 
sales
= new double(numDays]; 
II Allocate 
memory 
23 
24 
II Get the sales 
figures 
for each day 
25 
cout << "Enter the sales 
figures 
below.\n"; 
26 
for (int 
count
= O; count< 
numDays; count+ +) 
27 
{ 
28 
cout <<"Day"<< 
(count
+ 1) << "· "· 
29 
cin >> sales[count
] ; 
30 
} 
31 
32 
II Calculate 
the total 
sales 
33 
for (int 
count
= O; count< 
numDays; count+ +) 
34 
35 
{ 
36 
} 
37 
total 
+= sales[count]
; 
38 
II Calculate 
the average 
sales 
per day 
39 
average
= total 
I numDays; 
40 
41 
II Display 
the results 
42 
cout << setprec
i si on(2) <<fixed<< 
showpoint; 
43 
cout << "\n\nTotal 
Sales: 
$"<<total 
<< endl ; 
44 
cout << "Average Sales: 
$"<<average 
<< endl ; 
45 
46 
II 
Free dynamically 
allocated 
memory 
47 
delete(
] sales; 
48 
sales
= nullptr
; 
49 
return 
O; 
50 } 
(program continues) 

674 
Chapte r 10 
Pointers 
Program 10-14 
(continued) 
Program Output with Example Input Shown in Bold 
How many days of sales 
figures 
do you wish to process? 
5[Enter] 
Enter the sales 
figures 
below. 
Day 1 : 898 .63[Ent er] 
Day 2: 652 .32[Ent er] 
Day 3: 741 .85[Ent er] 
Day 4: 852 .96[Ent er] 
Day 5: 921 .37[Ent er] 
Total Sales: 
$4067.13 
Average Sales: 
$813.43 
The statement in line 23 dynamically allocates memo ry for an array of doubles , using 
the value in numDays as the number of elements . Th e new operato r returns the starting 
address of the memory allocated, and this address is assigned to the sa 1 es pointer 
variable . The sales variable is then used throughout the program to store the sales 
amounts in the array and perform the necessary calculations . In line 48 the de 1 ete 
operator is used to free the allocated memory. 
Focus on Software Engineering: 
Returning Pointers from Functions 
CONCEPT: 
Functions can return pointers, but you must be sure the item the pointer 
references still exists. 
It is often useful for a function to dynam ically allocate storage for an object, fill the 
object with data, and return its address. Consider a function that returns for a given 
positive integer n the sequence of the first n integer squares . For example, if the function 
is passed the value 4, it returns an array whose elements are 1, 4, 9, and 16. 
When called, the function allocates an array of the given size, sets the elements of the 
array to the required values, and returns the address of the base of the array . 
int *squares (int n) 
{ 
) 
// Allocate 
an array of size n 
i nt *sqarray 
= new i nt[n]; 
// Fil l the array with squares 
for (int k = O; k < n; k++) 
sqarray[k
] = (k+1) * (k+1); 
// Return base address of allocated 
array 
return 
sqarray ; 
Program 10-15 shows another example. This program contains a function that returns a 
pointer to an array of random numbers. The function accepts an integer size, dynamically 
allocates an array of the given size, and then populates the array with random values. The 
function uses the system clock to seed the random number generator. Notice that the array 
containing the random numbers is only deleted after the function main is done with it. 

10.10 Focus on Software Engineering: Returning Pointers from Functions 
675 
Program 10-15 
1 II Thi s program demonstrates 
a function 
that 
returns 
2 II a pointer
. 
3 #include 
<iostream> 
4 #include 
<cstdlib> 
5 #include 
<ctime> 
II For rand and srand 
II For the t i me function 
6 using namespace std ; 
7 
8 II Function 
prototype 
9 int 
*getRandomNumbers(int); 
10 
11 int main() 
12 { 
13 
int *numbers= 
nullptr; 
II To point to the numbers 
14 
15 
II Get an array of five 
random numbers 
16 
numbers= 
getRandomNumbers(5); 
17 
18 
II Di splay the numbers 
19 
for (int 
count
= O; count< 
5 ; count+ +) 
20 
cout << numbers[count] 
<< endl; 
21 
22 
23 
II Free the memory 
24 
delete[
] numbers ; 
25 
numbers= 
nullptr
; 
26 } 
return 
O; 
27 
28 //************************************************** 
29 II The getRandomNumbers function 
returns 
a pointer* 
30 II to an array of random integers. 
The parameter 
* 
31 II indicates 
the number of numbers requested
. 
* 
32 //************************************************** 
33 
34 int 
*getRandomNumbers(int 
size) 
35 { 
36 
37 
int *ar ray= 
nullptr; 
II Array to hold the numbers 
38 
II Return nullptr 
if size 
is zero or negative 
39 
if (si ze< = 0) 
40 
return 
nullptr; 
41 
42 
II Dynamically 
allocate 
the array 
43 
array
= new int[s
i ze] ; 
44 
45 
II Seed the random number generator 
by passing 
46 
II the return 
value of time(O) to srand 
47 
srand ( time (O) ); 
48 
49 
II Populate 
the array with random numbers 
50 
for (int 
count
= O; count< 
size ; count ++) 
51 
array[count] 
= rand(); 
(program continues) 

6 76 
Chapte r 10 
Pointers 
Program 10-15 
52 
(continued) 
53 
II Return a pointer 
to the array 
54 
return 
array ; 
55 } 
Program Output with Example Input Shown in Bold 
2712 
9656 
24493 
12483 
7633 
0 
A function can safely return a pointer to dynamically allocated storage that has not yet 
been deleted. In contrast, functions should not return pointers to local variables because 
the storage for such variables is automatically deallocated upon return. Consider the 
following function, which returns the address of a local array: 
i nt *errSquares(int 
n) 
{ 
} 
II Assume n is less 
than 100, use local 
array 
int array(100]
; 
II Fill 
the array with squares 
for (i nt k = O; k < n; k++) 
array(k] 
= (k+1) * (k+1) ; 
II Return base address 
of local 
array 
return 
array; 
A call such as 
i nt* 
arr= 
errSquares
(5}; 
will return the address of an array that has already been deallocated. Trying to access 
an element of such an array, as in 
cout 
<< arr[O] ; 
will result in a reference to nonexistent storage and cause an error. 
NOTE: 
Storage for a static local variab le is not deallocated upon return, so a 
function returning a pointer to such a variable will not trigger the kind of error we 
are talking about here. Such a function, however, may cause other types of errors 
whose discussion is beyond the scope of this book. 
Stopping Memory Leaks 
It is important for programs that use dynamically allocated memory to ensure that 
each call to new is eventually followed by a call to delete 
that frees the allocated 
memory and returns it to the heap. A program that fails to do this will suffer from 
memory leaks, a condition in which the program loses track of dynamically allocated 

10.10 Focus on Software Engineering: Returning Pointers from Functions 
677 
storage and therefore never calls delete to free the memory. There are two rules of 
thumb that are helpful when trying to avoid memory leaks: 
• Whenever possib le, the function that invokes new to allocate storage shou ld also 
be the function that invokes delete to deallocate the storage. 
• A class that needs to dynamically allocate storage should invoke new in its 
constructors and invoke the corresponding dele t e in its destructor. Because the 
destructor is automatically called by the system whenever an object is deleted or 
goes out of scope, a delete statement placed in a destructor will always be called . 
By following these rules whenever possible, you will always be able to find the delete 
operation that corresponds to a given call to new, thereby verifying that a particular call to 
new does not result in a memory leak. Program 10-16 is an example of a program that 
follows these rules. Note that the Squares class allocates dynamic memory in its constructor 
and has a dele t e statement in its destructor. Also, the allocation of memory for the 
Squares object (line 57) and its subsequent deletion (Line 61) are in the same function, 
namely, mai n. The program is garnished with output statements in strategic places to show 
when the new and delete operators in constructors and destructors are called. 
Program 10-16 
1 II Thi s program illustrates 
the use of constructors 
2 II and des t ruc t ors i n the allocat
i on and deallocat
i on of memory. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 using namespace std; 
6 
7 class 
Squares 
8 { 
9 private: 
10 
int leng th ; 
11 
int 
*sq; 
12 publ i C: 
II How long is the sequence 
II Dynamically 
allocated 
array 
13 
14 
15 
16 
II Constructor 
alloca t es storage 
for sequence 
II of squares 
and creates 
the sequence 
Squares(i
nt le n) 
17 
18 
19 
20 
{ 
leng th = len; 
sq= 
new i nt[leng th ]; 
for (i nt k = O; k < lengt h ; k++) 
{ 
21 
sq[k] 
= (k+1)*(k+1); 
22 
} 
23 
II Trace 
24 
cout << "Construc t an object 
of s iz e"<< 
le ngth<< 
endl; 
25 
} 
26 
II Pr i nt the sequence 
27 
void pr i nt () 
28 
{ 
29 
for (i nt k = O; k < lengt h ; k++) 
30 
cout << sq[k ] <<" 
"; 
31 
cout << endl; 
32 
} 
33 
II Dest ruc t or deallocates 
st orage 
(program continues) 

6 78 
Chapte r 10 
Pointers 
Program 10-16 
(continued) 
34 
-Squares(
) 
35 
{ 
36 
delete 
[ J sq ; 
37 
II Trace 
38 
cout << "Destroy object 
of size
" << lengt h<< 
endl ; 
39 
} 
40 } ; 
41 
42 //*
** *****
* * * * ****
*****
* * * * ******
*****
* * * * ******
* 
43 II Outputs the sequence of squares 
i n a 
44 II Squares object 
* 
* 
45 //*
** *****
* * * * ****
*****
* * * * ******
*****
* * * * ******
* 
46 void outputSquares(Squares 
*sqPtr ) 
47 { 
48 
cout << "The l i st of squares 
i s: "· 
49 
sqPtr->pr
i nt (); 
50 } 
51 
52 
53 int main () 
54 { 
55 
II Mai n allocates 
a Squares object 
56 
Squares 
*sqPtr = new Squares (3); 
57 
outputSquares
(sqPtr ); 
58 
59 
II Mai n deallocates 
the Squares object 
60 
delete 
sqPtr; 
61 
62 
return 
O; 
63 } 
Program Output 
Construct 
an object 
of size 3 
The list 
of squares 
is: 
1 4 9 
Destroy object 
of size 3 
~ 
Checkpoint 
10.9 
Assuming array is an array of i nt s, which of th e following progr am segments 
will display "True " and which will display "False" ? 
A) if (array 
< &array(1]) 
cout << "True "; 
else 
cout << "False"; 
B) if (&array(4 ] < &array(1] ) 
cout << "True "; 
else 
cout << "False"; 
C) if (array 
!= &array(2]) 
cout << "True "; 
else 
cout << "False"; 

10.10 Focus on Software Engineering: Returning Pointers from Functions 
679 
D ) if 
(ar ray != &array[O ]) 
cout << "True"; 
else 
cout << "False"; 
10.10 Give an example of the proper way to call the following function in order to 
negate the variable i nt num = 7 ; 
voi d makeNegative (i nt *val) 
{ 
if 
(*val > 0) 
*val = - (*val); 
} 
10.11 Complete the following program skeleton. When finished, the program shou ld 
ask the user for a length (in inches), convert that value to centimeters, and display 
the result . You are to wr ite the function convert. 
(Note: 1 inch = 2.54 cm. 
Do not modify funct ion main. ) 
#include 
<iostream> 
#include 
<iomani p> 
us i ng namespace std ; 
// Write your funct io n prototype 
here . 
i nt main (} 
{ 
} 
II 
double measurement; 
cout << "Enter 
a length 
in i nches , and I will 
convert\n"; 
cout << "it 
to centimeters
: "; 
cin >> measurement; 
convert
(&measurement ); 
cout << setprecision(4); 
cout <<fixed<< 
showpoint ; 
cout << "Value in centimeters: 
"<<measurement<< 
endl; 
return 
O; 
// Write the f unction 
convert 
here . 
II 
10.12 Look at the following array definit ion: 
const 
int 
numbers[SIZE] 
= { 18 , 17 , 12 , 14 } ; 
Supp ose we want to pass the array to the function processArray 
in the following 
manner: 
processArray
(numbers , SIZE); 
Which of the following function headers is the cor rect one for the processArray 
function? 
A) void processArray
(const 
int 
*arr ay , int size ) 
B) void processArray
(i nt * const 
array, 
int 
siz e} 
10.13 Assume i p is a pointer to an in t . Write a statement 
that will dynamically 
allocate an integer variable and store its address in i p, then wr ite a statement 
that will free the memory allocated in the statement you just wrote . 

680 
Chapte r 10 
Pointers 
10.14 Assume i p is a pointer to an i nt. Write a statement that will dynamically 
allocate an array of 500 integers and store its add ress in i p, then write a 
statement that will free the memory allocated in the statement you just wrote. 
10.15 What is a null pointer? 
10.16 Give an examp le of a function that correctly returns a pointer. 
10.17 Give an examp le of a function that incorrectly returns a pointer. 
Pointers to Class Objects and Structures 
CONCEPT: 
Point ers and dynamic memory allocation can be used with class objects 
and structures. 
Declaring a pointer to a class is the same as declar ing any othe r pointer type. For 
example, if Rectang 1 e is defined as 
class 
Rectangle 
{ 
i nt wi dth , height; 
} ; 
you can declare a pointer to Rectang le and create a Rectangle object by writing 
Rectangle 
*pRect = nullp t r; // Poi nt er t o Rectangle 
Rectangle rec t ; 
// Rectangle object 
and you can assign the address of rec t to pRect as follows: 
pRect = &rect ; 
Now suppose that you want to access the members of the Rectang le object through 
the pointer pRect . Because *pRect is just another way of accessing rect, you might 
think that the expression 
*pRect.w i dth 
will access rect. widt h, but this is not so. Th e reason is that the dot selector has higher 
priority than the * operator, so *pRect. wi dth is equivalent to * ( pRrect. wi dth ). This 
last expression is a type error. To get it right, you must use parentheses to force the 
indirection operator * to be applied first, as shown here: 
( *pRect} .width 
The following statements will correctly set the dimensions of the rectangle to 10 and 20. 
(*pRect}.width 
= 10; 
(*pRect}.height 
= 20 ; 
Th e combined use of parentheses , the indirection operator, and the dot selector to 
access members of class objects via pointers can result in expressions that are hard to 
read . To solve this prob lem, C++ provides the structur e pointer operator -> to use 
when you want to access a member of a class object through a pointer. It consists of a 
hyphen - and a greater -than symbol > written next to each other to look like an arrow. 
Using this operator, you can set the dimensions of the rectangle with these statements: 
pRect->width = 10; 
pRect->height 
= 20 ; 

10.11 Pointers to Class Objects and Structures 
681 
Member functions of class objects can be called through a pointer. In particular , if ptr 
is a pointer to an object that has a member function fun () , then the function can be 
called with eith er one of these two (equiva lent) expressions: 
( *ptr). fun(); 
ptr->fun (); 
Dynamic Allocation of Class Objects 
Dynamically 
allocated class objects are used in programs 
that build and manage 
advanced data structures such as lists (studied in Chapter 17) and binary trees (studied 
in Chapter 19). Th e new operator is used to allocate such objects in the same way that 
it is used to allocate variab les of other types. For examp le, the following statements 
allocate a single Rectangle object and set its dimensions 
pRect = new Rectangle; 
pRect->w i dth = 10 ; 
pRect->height 
= 3; 
If Rectangle 
has a constructor 
that takes two integer parameters, 
then you can 
simu ltaneous ly allocate the object and invoke the constructor like this: 
pRect = new Rectangle(10, 
30); 
Program 10-17 illustrates these concepts . 
Program 10-17 
1 II This program uses pointers 
to dynamically 
allocate 
2 II structures 
and class 
objects
. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 using namespace std; 
6 
7 II Person class 
8 class 
Person 
9 { 
10 private: 
11 
str i ng name; 
12 
int age; 
13 publ i C: 
14 
Person(string 
name1, int age1) 
15 
{ 
16 
name = name1; 
17 
age= 
age1; 
18 
) 
19 
int getAge() 
{ return 
age; } 
20 
str i ng getName() 
{ return 
name; } 
21 } ; 
22 
23 II Rectangle 
structure 
24 struct 
Rectangle 
25 { 
26 
int width, 
height; 
27 }; 
28 
(program continues) 

682 
Chap ter 10 
Pointers 
Program 10-17 
29 int main () 
30 { 
(continued) 
31 
32 
33 
Rectangle 
*pRect = nullptr
; 
Person *pPerson = nullptr
; 
II Pointer 
to Rectangle 
II Pointer 
to Person 
34 
II Local object 
accessed 
through 
a pointer 
35 
Rectangle 
rect ; 
36 
pRect = &rect ; 
37 
(*pRect ) .height 
= 12 ; 
38 
pRect->width 
= 10 ; 
39 
cout << "Area of the first 
rectangle 
is
" 
40 
<< pRect->width 
* pRect->height
; 
41 
42 
II Dynamical l y al located 
object 
accessed 
through 
pointer 
43 
pRect = new Rectangle
; 
44 
pRect->height 
= 6 ; 
45 
pRect->width 
= 5 ; 
46 
cout << "\ nArea of the second rectangle 
is
" 
47 
<< pRect->width 
* pRect->height
; 
48 
delete 
pRect ; 
49 
pRect = nullptr
; 
50 
51 
II Dynamical l y al located 
object 
accessed 
through 
pointer 
52 
pPerson = new Person ( "Miquel E. Gonzalez ", 23); 
53 
cout << "\ n\ nThe person ' s name is"<< 
pPerson->getName (); 
54 
cout << "\ nThe person ' s age is " << pPerson->getAge () << endl ; 
55 
delete 
pPerson ; 
56 
pPerson = nul lptr ; 
57 
58 
ret urn O; 
59
} 
Program Output 
Area of the first 
rectangle 
is 120 
Area of the second rectangle 
is 30 
The person's 
name is Miguel E. Gonzalez 
The person's 
age is 23 
Pointers to Class Objects as Function Parameters 
Pointers to structures and class variables can be passed to functions as parameters. The 
function receiving the pointer can then use it to access or modify members of the structure. 
This is shown in Program 10-18. 
Program 10-18 
1 II This program i l l ustrates 
pointers 
to class 
objects 
2 II and structures 
as parameters 
of functions. 
3 #inc l ude <iostream> 
4 #inc l ude <string> 
(program continues) 

10.11 Pointers to Class Objects and Structures 
68 3 
Program 10-18 
(continued) 
5 using namespace std ; 
6 
7 II Person class 
8 class 
Person 
9 { 
10 private: 
11 
string 
name; 
12 
int 
age; 
13 publ i C: 
14 
Person (str i ng name1, i nt age1) 
15 
{ 
16 
name= name1; 
17 
age= 
age 1; 
18 
} 
19 
int getAge() 
{ return 
age ; } 
20 
string 
getName() { return 
name; } 
21 } ; 
22 
23 II Rectangle 
structure 
24 struct 
Rectangle 
25 { 
26 
int width, 
height; 
27 }; 
28 
29 II Prototypes 
30 void magni fy(Rectangle 
*pRect, 
int mfacto r); 
31 int lengt hOfName(Perso n *p); 
32 void output(Rectangle 
*pRect ); 
33 
34 int main() 
35 { 
36 
II Create, 
then magnify a rectang le by a factor 
of 3 
37 
Rectangle 
rect; 
38 
rect.w i dth = 4; 
39 
rect.height 
= 2 ; 
40 
cout << "Initial 
size of rectangle 
is"· 
41 
output( &rect ); 
42 
magni fy (&rect , 3); 
43 
cout << "Si ze of Rectangle 
after 
magnification 
i s"· 
44 
output( &rect ); 
45 
46 
II Create 
Person object 
and find leng th of person's 
name 
47 
Person *pPerson = new Person ("Susa n Wu", 32); 
48 
cout << "The name"<< 
pPerson->getName () 
49 
<<" 
has lengt h"<< 
lengthOfNa me (pPerson ) << endl; 
50 
51 
delete 
pPerson; 
52 
pPerson = nul lptr ; 
53 
54 
55 } 
56 
return 
O; 
(program continues) 

684 
Chapte r 10 
Pointers 
Program 10-18 
(continued) 
57 //********************************************* 
58 II Output the dimens i ons of a rectangle 
* 
59 //********************************************* 
60 void output(Rectangle 
*pRect ) 
61 { 
62 
63 
64
} 
65 
cout << "wi dth: 
" << pRect->wi dth << " height: 
" 
<< pRect->he i ght << endl ; 
66 //****************************************************** 
67 II Returns the number of characters 
in a person's 
name* 
68 //****************************************************** 
69 int lengthOfName(Person 
*p) 
70 { 
71 
string 
name= p->getName(); 
72 
return 
name.length(); 
73
} 
74 
75 //****************************************************** 
76 II Stretch 
the width and height 
of a rectangle 
by 
* 
77 II a spec i fied 
factor 
* 
78 //****************************************************** 
79 void magni fy(Rectangle 
*pRect, int factor
) 
80 { 
81 
pRect->width 
= pRect->width 
* factor; 
82 
pRect->he i ght = pRect->height 
* factor; 
83
} 
Program Output 
Initial 
size of rectangle 
is width: 
4 height: 
2 
Size of Rectangle 
after 
magnification 
is width: 
12 height: 
6 
The name Susan Wu has length 
8 
10.12 
Focus on Software Engineering: 
Selecting Members of Objects 
Sometimes str uctu res and classes contain pointers as members. For example, the 
following structure declaration has an i nt pointer member: 
struct 
Gradelnfo 
{ 
} ; 
str i ng name; 
int *testScores; 
double average; 
II Student 
name 
II Dynamically allocated 
array 
II Test average 
It's important to remember that the structure pointer operato r (- >) is used to dereference a 
pointer to a structure or class object, not a pointer that is a member of a structure or class. If 
a program dereferences the testScores 
pointer in the structure in the example, the indirection 
operator must be used. For example, assuming the following variable has been defined: 
Gradelnfo 
student1; 
The following statement will display the value pointed to by the testScores 
member: 
cout << *student1.testScores; 

10.12 Focus on Software Engineering: Selecting Members of Objects 
685 
It's still possible to define a pointer to a structure that contains a pointer member. For 
instance , the following statement defines stPtr as a pointer to a Grade Info structure: 
Gradeln fo *stPtr; 
Assuming st Pt r points to a valid Grade Info variable, the following statement will 
display the value pointed to by its tes t Scores member: 
cout << *stPtr->testScores; 
In this statement, the * operator dereferences stPtr - >tes t Scores , while the - > 
operator dereferences st Pt r. It might help to remember that the expression 
stPtr-> t estScores 
is equivalent to 
(*stP t r). t estScores 
So, the expression 
*stPtr - >tes t Scores 
is the same as 
*(*stPtr)
.tes t Scores 
The awkwardness of this expression shows the necessity of the -> operator. Table 10-1 
lists some expressions using the*, - >, and . operators, and describes what each references. 
The table is easier to understand if you remember that the operators -> and . for selecting 
members of structures have higher precedence than the dereferencing operator *. 
Table 10-1 
Dereferencing Pointers to Structures 
Expression 
Description 
s->m 
s is a pointer to a structure variable or class object, and m is a member. This 
expression accesses the m member of the structure or class object pointed to by s. 
*a. p 
a is a structure variable or class object and p, a pointer , is a member of a. This 
expression accesses the value pointed to by a. p. 
( * s) . m 
s is a pointer to a structure variable or class object, and m is a member. The " 
operator dereferences s, causing the expression to access the m member of the 
object ''s . This expression is the same as s-> m. 
*s->p 
sis a pointer to a structure variable or class object and p, a pointer , is a member of 
the object pointed to by s. This expression accesses the value pointed to by s->p . 
* ( * s) . p 
s is a pointer to a structure variable or class object and p, a pointer , is a member of 
the object pointed to by s. This expression accesses the value pointed to by (''s) .p. 
This expression is the same as "s- >p. 
~ 
Checkpoint 
Assume the following structure declaration exists for questions 10.18 through 10.20: 
struc t Rectangle 
{ 
) ; 
i nt length; 
i nt width ; 
10.18 Write the definition of a pointer to a Rectangle structure. 

686 
Chapte r 10 
Pointers 
10.19 Assume the pointer you defined in question 10.18 points to a valid Rectangle 
structure. Write the statement that displays the structure's members through the 
pointer. 
10.20 Assume rpt r is a pointer to a Rectangle structure. Which of the expressions, A, 
B, or C, is equivalent to the expression: 
rpt r->width 
A) *rptr .width 
B) (*rptr ) .width 
C) rpt r . (*widt h) 
10.11 Smart Pointers 
CONCEPT: 
C++ 11 introdu ces smart pointers, objects that work like pointers but 
have the ability to automatically delete dynamically allocated memory 
that is no longer being used. 
In a large program, a pointer to dynamically allocated memory may be used by different 
parts of the program . In such cases, it can be difficult to determine when such memory is 
no longer needed, or which part of the program should be responsible for deleting the 
pointer. The program may suffer from dangling pointers, where pointers are deleted while 
their memory is still in use; and from memory leaks, where pointers are not deleted even 
after their memory is no longer needed. Another problem, double deletion, occurs when 
one part of the program deletes a pointer that has already been deleted. Double deletion 
can wreak havoc on a program if the memory being deleted has already been reallocated. 
C++ 11 introduces the concept of smart pointers to help with these problems . Smart 
pointers are objects that work like pointers but have the ability to automatically delete 
dynamically allocated memory that is no longer being used. C++ 11 provides three types 
of smart pointers defined by classes called uni que_pt r, shared _pt r, and weak_pt r. 
We will refer to these as unique pointers, shared pointers, and weak pointers. 
The central concept behind smart pointers is ownership of dynamically allocated 
memory . A smart pointer is said to own or manage the object that it points to. Unique 
pointers are used when a dynam ically allocated object is to be owned by a single 
pointer. Ownership of an object can be transferred from one such pointer to anothe r, 
in such a way that the object always has at most one pointer as its owner. The unique 
pointer automatically deallocates the object it is managing if the pointer is going out of 
scope, or if it is assuming ownership of a different object . 
Shared pointers jointly maintain a count of the pointers that currently share ownership 
of an object. This reference count increases as additiona l pointers are set to point to the 
object and decreases as pointers detach from the object. When the reference count 
drops to zero, the object is deleted. We will not discuss weak pointers in this book . 
The classes unique _ptr , shared _ptr , and weak_ptr are defined in the memory header 
file, so you need the statement 
#i nclude <memory> 
in programs that use them. 

10.13 Smart Pointers 
687 
The unique_ptr 
class 
A smart pointer is really an object that wraps an ordinary pointer to an owned object. 
We will refer to the wrapped regular pointer as the raw pointer . Smart pointer classes 
are parameterized by the type of object pointed to. For example, unique _ptr<i nt> is a 
pointer to i nt; while uni que_ptr<doub l e> is a pointer to doubl e. The following code 
shows how to create uniqu e pointers. 
uni que_ptr<int> 
uptr 1(ne w int); 
uni que_ptr<double> 
uptr2 (new double); 
Alternatively, you can define an uninitialized unique pointer and later assign it a value: 
uni que_ptr<int> 
upt r 3 ; 
uptr3 = uniq ue_ptr< i nt>(new int); 
To avoid memory leaks, objects that are managed by smart pointers should have no 
other references to them. In other words, the pointer to dynamically allocated storage 
sho uld immediately be passed to a smart pointer constr uctor without first assigning it 
to a pointer variable . For example, you should avoid writing code like this 
int 
*p = new int; 
uni que_ptr<int> 
uptr (p); 
Smart pointers do not support pointer arithmetic, so statements such as 
uptr1 ++; 
uptr1 = uptr 1 + 2 ; 
result in compile-time errors. However, smart pointers support the usual pointer operations 
* and - > through operator overloading, a topic we will study later in Chapter 11. The 
following code dereferences a unique pointer to assign a value to a dynam ically allocated 
memory location, increments the value at that location, and then prints the result: 
uni que_ptr<int> 
uptr (new int); 
*uptr = 12; 
*uptr = *uptr + 1; 
cout << *uptr << endl; 
You cannot initi alize a uni que_ ptr with the value of anot her unique _ptr object. 
Similarly, you cannot assign one uni que_ptr object to another. This is because such 
operations wou ld result in two unique pointers sharing owners hip of the same object. 
Thu s, the following statements result in compi le-time errors: 
uni que_ptr<int> 
uptr 1(ne w int); 
uni que_ptr<int> 
uptr2 = uptr1; 
uni que_ptr<int> 
uptr3 ; 
uptr3 = uptr 1; 
// Illegal 
i ni t i alization 
// 
Ok 
// Illegal 
assignment 
C++ provides a move( )library function that can be used to transfer ownership from 
one unique pointer to another: 
uni que_ptr<int> 
uptr 1(ne w int); 
*uptr 1 = 15 ; 
uni que_ptr<int> 
uptr3 ; 
uptr3 = move(uptr1); 
cout << *uptr3 << endl ; 
When a move statement such as 
U = move(V); 
// 
Ok 
// Transfer 
ownership from upt r 1 to uptr3 
// Prints 
15 

688 
Chapte r 10 
Pointers 
is exec uted, two things happen. First, any object curren tly owned by U is dea llocated. 
Second, the moved-from pointer V relinquishes ownership of its ob ject and becomes 
empty, and U assum es contro l of the object previously owned by V. 
You cannot directly pass a unique pointer to a function by value because pass by value 
involves copying of the actual parameter. If you have a function that accepts a unique pointer 
by value, you must use the move ( ) function on the actual parameter when calling the function: 
// Function 
uses pass by value 
voi d fun(unique
_ptr<int> 
uptrParam) 
{ 
cout << *uptrParam 
<< end l; 
} 
i nt mai n(} 
{ 
uni que_ptr< i nt> uptr(new 
int) ; 
*uptr = 10; 
fun (move (uptr)); 
II Use move in call 
} 
Th e above code will print 10 from inside the function fun (). Alternatively, you can 
dispense with the move () on the actual parameter if you use pass by reference: 
// Function 
uses pass by reference 
voi d fun(unique
_ptr<int>& 
uptrParam} 
{ 
cout << *uptrParam 
<< end l; 
} 
i nt mai n(} 
{ 
} 
uni que_ptr<int> 
uptr1(new 
int ); 
*uptr 1 = 15 ; 
fun (uptr1 }; 
// No need for move in call 
Th e above program will print the number 15 when executed . 
Int erest ingly, you can return a uni que pointer from a fun ction . Thi s is because the 
comp iler automat ically appli es a move () ope rat ion to return values of functions that 
return uni que_pt r ob jects. 
// Returns 
a uni que pointer 
to a dynamically 
// allocated 
resource 
uni que_ptr<int> 
makeResource() 
{ 
uni que_ptr< i nt> uptrResult(new 
int ); 
*uptrRes ult = 55 ; 
return 
uptrResult; 
} 
i nt mai n(} 
{ 
} 
uni que_ptr<int> 
uptr; 
uptr = makeResource( }; 
cout << *uptr << endl ; 
// automatic 
move 

10.13 Smart Pointers 
689 
This program prints 55. 
You shou ld never dynamically allocate a smart pointer. Instead, smart pointers should 
be declared as local variab les of a function. A uni que_pt r will delete its managed object 
as it is going out of scope. If you need the smart pointer to delete its managed object 
while it is still in scope, set its value to null ptr , or call its reset () member function: 
uptr = nullptr; 
upt r. reset () ; 
Beginning with C++ 14, there is a library function make_uni que<T> () that can be used 
to create uni que_pt r objects . This function allocates an object of type T and returns a 
unique pointer that owns that object. For example, instead of writing 
uni que_ptr<int> 
uptr(new int); 
you can write 
uni que_ptr<int> 
uptr = make_uni que<int>(); 
Unique Pointers to Arrays 
A unique pointer created as shown above will call de 1 ete on the wrapped pointer to 
deallocate the managed object. This will not be correct if the wrapped pointer is pointing to 
an array of objects. To ensure that arrays of objeets are deallocated with a call to de 1 ete [ J, 
you should include a pair of empty brackets [ J after the object type. For example, to use 
a unique pointer to point to a dynamically allocated array of five integers, write: 
uni que_ptr<int
[J> uptr(new int[5 ] ); 
Recall that the smart pointer upt r can be used just as if it was a regular pointer to int. 
Recalling again that we can use array notation on pointers, we can write a program to 
store the squares of integers in such an array like this 
i nt mai n() 
{ 
) 
// Unique pointer 
to an array 
uni que_ptr<int
[J> up(new int[5 ] ); 
// Set array ele ments to squares 
of integers 
for (int 
k = O; k < 5 ; k++) 
{ 
up[k] = (k+1)*(k+1); 
) 
II Print 
the array elements 
for (int 
k = O; k < 5 ; k++) 
{ 
cout << up[k] << " ". 
' 
) 
cout << endl ; 
The result printed will be 1 4 9 16 25. 
When used to create a unique pointer to an array of objects of type T, the 
make_uni que<T [ J > ( ) takes an integer parameter for the size of the array: 
uni que_ptr<int[
J> up= make_uni que<int[J>(5); 

690 
Chapte r 10 
Pointers 
Selected Member Functions of the uni que_pt r class 
The uni que_ptr class has a number of instance member functions that are often useful. 
They are shown in Table 10-2. 
Table 10 -2 uni q ue_pt r Member Functions 
Member Function 
Description 
reset () 
Destroys the object managed by this smart pointer, if any. The smart 
pointer becomes empty . 
reset (T* ptr) 
Destroys the object currently managed by this smart pointer , if any. The 
smart point assumes control of the object pointed to by the raw pointer ptr. 
get () 
Returns the raw pointer to the object managed by this smart pointer. This is 
useful if such a pointer needs to be passed to a function that does not know 
how to handle smart pointers . 
Program 10-19 illustrates the use of unique pointers. A class Thing is associated with a 
global variable that is used to assign a sort of serial number to each Thing object as it 
is created, and each object of the class is assigned a uniqu e number at the time of 
creation. The Thing class has a constructor and a destructor that are used to trace the 
creation and destruct ion of class instances. 
The Thing class includes a to _stri ng () function that returns a string that contains the 
instance's "serial number." This method calls a library function, also called to _stri ng (), 
which is defined in the standard namespace std , to convert the integer i nstanceNumber 
to its string form. The scope resolution operator std : : is used to resolve the ambiguity. 
Notice that there are no calls to de 1 ete in this program . By examining the code and its 
output, you can see how smart pointers work to delete memory that is no longer needed. 
Program 10-19 
1 // This program i llustr
ates the use of unique _ptr to manage memory 
2 #include 
<iostream> 
3 #include 
<memory> 
4 #include 
<str i ng> 
5 using namespace std ; 
6 
7 int ser ial No = 1; 
8 class 
Thing 
9 { 
10 
int instanceNumber; 
11 public: 
12 
Thing() 
13 
{ 
14 
i nst anceNumber = serialNo++; 
15 
cout <<" Thi ng•<< 
instanceNumber 
<< • created.\
n"; 
16 
) 
17 
-Th i ng() 
18 
{ 
19 
cout <<" Thi ng•<< 
instanceNumber 
<< • destroyed.\n"; 
(program continues) 

10.13 Smart Pointers 
691 
Program 10-19 
(continued) 
20 
} 
21 
str i ng to _string() 
22 
{ 
23 
return 
"Thi ng"+ 
std::to
_str i ng( i nstanceNumber} 
+ "\ n"; 
24 
} 
25 }; 
26 
27 int main() 
28 { 
uni que_ptr<Thing> 
u1 = make_unique<Thing>(); 
uni que_ptr<Thing> 
u2 = make_uni que<Thing>(); 
II 
1 
II 
2 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
uni que_ptr<Thing[
]> uArr2 = make_unique<Thing[]>(2}; 
uni que_ptr<Thing> 
u5 = make_unique<Thing> (); 
uni que_ptr<Thing> 
u6 = make_uni que<Thing>(); 
I I 3, 
4 
II 
5 
II 
6 
u5 = move(u6); 
u1.rese t (}; 
u1.rese t (new Thi ng); 
41 
II output 
array managed by uArr2 
42 
cout << uArr2[0 ] .to _str i ng(); 
43 
cout << uArr2[1 ] .to _str i ng(); 
44 
45 
II Now all 
smart pointers 
will 
go out scope 
46 
47 
return 
O; 
48
} 
Program Output 
Thing 1 created. 
Thing 2 created. 
Thing 3 created. 
Thing 4 created. 
Thing 5 created. 
Thing 6 created. 
Thing 5 destroyed. 
Thing 1 destroyed. 
Thing 7 created. 
Thing 3 
Thing 4 
Thing 6 destroyed. 
Thing 4 destroyed. 
Thing 3 destroyed. 
Thing 2 destroyed. 
Thing 7 destroyed. 
The shared_ptr 
class 
II destroy 
5, u5 manages 6 
II destroy 
1 
II u1 manages 7 
Shared pointers are used to manage a dynamically allocated object that can have more 
than one owner. In particular, the type shared _ptr<T> is used to manage ownership of 
objects of type T. The class constructor shared _pt r<T> (T * pt r} can be used to create 
a shared pointer that manages an object whose address is given by the raw pointer ptr. 

692 
Chapte r 10 
Pointers 
Th e shared _pt r class overloads the pointer ope rato rs * and - >. Here is a simple 
example that creates a dynamically allocated integer managed by a shared pointer and 
then accesses it through that pointer: 
i nt mai n() 
{ 
shared _ptr<int> 
p(new int); 
*p = 45; 
cout << *p + 1; 
return 
O; 
) 
This code will print the value 46. 
Here is another examp le. Suppose that we want to manage shared ownership of objects 
of the following class: 
class 
Person 
{ 
str i ng name; 
int age ; 
publ i c : 
str i ng to _string(
) 
{ 
return 
name+ 
II 
II 
) 
/ / Constructor 
+ to _string(age
) + "\n"; 
Person() 
{name =""; 
age = O;} 
Person(const 
string& name, int age) 
{ 
} 
} 
this->name 
= name; 
this->age 
= age; 
We can create two shared pointers, each managing a different object, like this: 
shared _ptr<Person> 
p1(ne w Person ()); 
shared _ptr<Person> 
p2(new Person ("Maria Wu", 23)); 
Alternatively, we can write 
shared_ptr<Person> 
p1 = shared_ptr<Person> (new Person()); 
shared_ptr<Person> 
p2 = shared_ptr<Person> (new Person("Mar i a Wu", 23)); 
Groups of Shared Pointers 
Supp ose that you set a shared pointer to manage an object pointed to by a raw 
pointer rPtr: 
T * rPtr 
= new T(); 
shared _ptr<T> sPtr1(rPtr); 
At that point, sPtr1 becomes the only member of a group of shared pointers that owns 
rPt r . The group maintains a reference count, which is just the number of shared pointers 
that belong to the group. This "gro up," called a control block, is actually itself a dynam ically 
allocated object that keeps track of both the reference count and the raw pointer that 
points to the managed object . The control block is responsible for deleting the managed 

10.13 Smart Pointers 
693 
object when the reference count drops to zero. You can think of the shared pointer as 
pointing to the control block and the control block as pointing to the managed object. 
Now, if sPt r1 is used to initialize another shared pointer, 
shared _ptr< T> sPtr2 
= sPtr1; 
then sPt r2 becomes a member of the same group as sPtr1, sharing ownership of the 
rPtr object, and the group's reference count increases by one. If after this, sPtr2 is 
assigned the value of another shared pointer: 
sPtr2 
= sPtr3; 
then sPtr2 will relinquish ownership of rPtr, leave the sPtr 1 's group, and join sPtr3's 
group . The reference count of the first group decreases by one, while that of the second 
group increases. 
The Danger of Double Dipping 
When using shared pointers, you should avoid situations that can lead to two groups 
of pointers managing the same object . For example, in the code 
T * rPtr = new T(); 
shared _ptr< T> sPtr 1(rPtr); 
shared _ptr< T> sPtr2(rPtr); 
the two shared pointers point to two different contro l blocks that manage the same 
object . The first group whose reference count drops to zero will delete the object, 
leaving the other group with a dangling pointer. To avoid this prob lem, a given raw 
pointer shou ld be used to initialize at most one shared pointer. 
The make_shared<T> () function 
Consider again the creation of a shared pointer: 
shared _ptr<Person> 
p1(new Perso n()); 
The execution of this statement involves two separate memory allocations: one to 
allocate a control block, and the second to allocate memory for the Perso n object to be 
managed. Each memory allocat ion incurs significant overhead, so it is more efficient to 
allocate a single memory block large enough to hold both the control block and the 
object to be managed. There is a library function, 
make_shared<T>() 
that does this. Using this function, we can rewrite the above statement in the following 
form: 
shared _ptr<Person> 
p1 = make_shared<Person>(); 
This version of make_shared initializes the managed object using the default constructor. 
There is a version of make_shared that takes parameters to pass to a nondefault 
constructor. Thus, instead of writing 
shared _ptr<Person> 
p2(new Person("Maria 
Wu", 23)); 
You can write 
shared _ptr<Person> 
p2 = make_shared<Person>("Maria 
Wu", 23)); 

694 
Chapte r 10 
Pointers 
The make_shared function is the recommended way to create shared pointers . In 
addition to being more efficient, it removes the need to directly deal with raw pointer s, 
thereby eliminating the possibility of doub le dipping . 
Selected s hared_ptr 
Member Functions 
Table 10-3 lists the most useful member function s for working with shared pointers. 
Table 10 -3 shared_ptr 
Member Functions 
Member Function 
Description 
T* get () 
Returns a raw pointer to the managed object or a null pointer if no object 
is being managed . 
void reset () 
Releases the ownership of the managed object, if any. The calling shared 
pointer becomes empty. 
void rese t (T • ptr) 
Releases ownership of the object currently being managed and acquires 
ownership of the object pointed to by ptr. 
1 ong use_count () 
Returns the number of shared pointers that refer to the same managed object. 
11111111 
In addition, you can check whether a shared pointer is managing an object by testing 
the value of the shared pointer like this: 
shared _ptr< T> p = .... 
; 
i f ( p ) 
{ 
II an object 
is bei ng managed 
) 
else 
{ 
II shared poi nter i s empty 
) 
Shared Pointers to Arrays 
By default, shared _ptr uses dele t e to destroy the managed object. Unlike unique _ptr, 
you cannot write 
shared _ptr< T[ ]> sPtr; 
II Error! 
to specify that the type of the managed object is an array . A simple way around this 
restriction is to use a shared pointer to a vector of type T: 
shared _ptr<vector<T>> sVecPtr; 
When the vector is destroyed, its destructor will run and destroy all of the vector elements. 
10.14 Tying It All Together: Pardon Me, Do You Have the Time? 
11111111111 Professor Susan Gonzalez wants to have her students take some of their tests online and 
has asked you to write a program to administer the tests. For each student, the program 
must record the student's starting time, the student's answer for each question, and the 
student's ending time. Before you write the program, you want to make sure that you 
can write code to accurately capture a student's start and end time. You decide to write 
a short program that experiments with the C++ library functions for telling time. 

10.14 Tying It All Together: Pardon Me, Do You Have the Time? 
695 
C++ libraries provide a number of data types and functions that can be used to deter-
mine the current calendar time. By convention, many computers mark calendar time by 
the number of seconds that have elapsed since a point in time that has come to be 
known among computer scientists as the epoch. In case you want to know, the epoch 
is midnight January 1, 1970. 
The C++ data type ti me_t is used to represent the number of seconds since the epoch. 
The library function 
time _t t i me (time _t * epSecs); 
takes as parameter a pointer to a t i me_ t object that will hold the value representing 
the current time. Program 10-20 illustrates the use of this function. 
Program 10-20 
1 II Thi s program illustrates 
the use of the time function. 
2 #include 
<iostream> 
3 #include 
<ctime> 
II Needed to use the time functions 
and types 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
time _t epSeconds; 
9 
time(&epSeconds); 
10 
cout << "The number of seconds since 
the epoch is" 
11 
<< epSeconds << endl; 
12 
return 
O; 
13 ) 
Program Output 
The number of seconds since the epoch is 
1247930628 
Somewhat redundantly, the value stored in the parameter epSecs is also returned by 
the t i me function. This allows the programmer to pass NULL for the parameter to 
ti me () and use the returned value instead. The following program is equivalent to 
Program 10-20. 
Program 10-21 
1 II Thi s program illustrates 
the use of the time function. 
2 #include 
<iostream> 
3 #include 
<ctime> 
II Needed to use the time functions 
and types 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
time _t epSeconds; 
9 
epSeconds = time(NULL); 
10 
cout << "Number of seconds since the epoch is• 
11 
<< epSeconds << endl; 
12 
return 
O; 
13 ) 
Program Output 
Number of seconds since the epoch is 1247930807 

696 
Chapte r 10 
Pointers 
As usefu l as t i me () is, it does not solve all time-re lated prob lems. First, Professor 
Gonzalez would much prefer that chrono logical times be stated in a form such as 
Fr i day June 10, 2016, 4:29PM 
instead of as so many seconds after the epoch. Second, she wants the program to take 
differences in time zones into account and always give the correct local time. The C++ function 
tm * l oca l time(const 
time _t *eps) 
is exactly what is needed: It takes a ti me_t value, converts it into a structure of type tm, 
and returns the address of that structure. The members of tm are integers and have the 
meanings shown here: 
i nt tm_mi n; 
II 
Mi nutes 
after 
the hour (0 . . 59) 
i nt tm_hour; 
II 
Hours after 
midni ght (0 . . 23) 
i nt tm_mday; II 
Day of the month (1 . . 31) 
i nt tm_mon; 
II 
Month s i nce January 
(0 . . 11) 
i nt tm_year; 
II 
Years s i nce 1900 
i nt tm_wday; II Weekday (Sunday=O, Monday=1, .. Saturday=6) 
The following is an example of how to use ti me () in conjunction with loca l ti me() to 
print the number of the current month: 
time _t epSecs; 
// Seconds since 
epoch 
tm *pCal endar Time= nul l ptr; 
// Pointer 
to ca l endar t i me 
// Get seconds 
since 
epoch 
epSecs = time(NU LL); 
// Convert 
to l oca l time 
pCalendar Time = loca l time(&epSecs); 
// Print 
number of current 
month 
cout << pCal endarTime->tm _mon; 
The following program determines and prints the day of the week, month, and year of 
the time of its execution: 
Program 10-22 
1 // Thi s program pr i nts "today's" 
date 
2 #include 
<iostream> 
3 #include 
<ctime> 
4 #include 
<str i ng> 
5 using 
namespace std; 
6 
7 int 
main() 
8 { 
9 
time _t epSeconds; 
// Seconds since 
epoch 
10 
tm *pCal endar Time = nul lptr; 
// Pointer 
to calendar 
time 
11 
// Array of weekday names 
12 
string 
wDay[J = {"Sunday", 
"Monday", "Tuesday", 
"Wednesday", 
13 
"Thursday", 
"Fr i day", 
"Saturday" 
14 
) ; 
15 
// Array of month names 
16 
string 
month []= 
{"January", 
"February", 
"March", 
"April", 
17 
"May", 
"June", 
"July"
1 
"August", 
"September", 
18 
"October", 
"November", 
"December" 
19 
20 
} ; 
(program continues) 

10.14 Tying It All Together: Pardon Me, Do You Have the Time? 
697 
Program 10 -22 
(continued) 
21 
epSeconds = time(NULL); 
// Seconds s i nce epoc h 
22 
pCalendar Ti me = loca l time(&epSeconds); 
// Convert t o local 
t i me 
23 
24 
II Pri nt day of month and day of week 
25 
cout << "Today i s"<< 
wDay[pCalendar Ti me->t m_wday] 
26 
<<" 
"<< mont h[pCal endarTime->tm _mon] 
27 
<<" 
"<< pCalendar Time->tm_mday 
28 
<<" 
"<< 
1900 + pCal endarTime->tm _year << endl ; 
29 
30 
return 
O; 
31 } 
Program Output 
Today is Friday September 23, 2016 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. Each byte in memory is assigned a unique ____ 
_ 
2. 
3. 
The _____ 
operator can be used to determine a variable's address. 
____ 
variab les are designed to hold addresses. 
4. The _____ 
operator can be used to work with the variable a pointer points to. 
5. Array names can be used as _____ 
and vice versa. 
6. Creating variab les while a program is running is called ____ 
_ 
7. The ____ 
operator is used to dynamically allocate memory. 
8. If the new operator cannot allocate the amount of memory requested, it throws 
9. A pointer that contains the address O is called a(n) ____ 
pointer . 
10. When a program is finished with a chunk of dynamically allocated memory, it 
should free it with the ____ 
operator. 
11. You shou ld only use the del et e operator to deallocate memory that was dynam -
ically acquired with the ____ 
operator . 
12. What does the indirection operator do? 
13. Look at the following code. 
i nt X = 7; 
i nt *ptr = &x; 
What will be displayed if you send the expression *ip t r to cout? What happens 
if you send the expression pt r to cout? 
14. Name two different uses for the C++ operator ". 
15. Which arithmetic operations can be app lied to pointers? 
16. Assuming that ptr is a pointer to an in t , what happens when you add 4 to it? 

698 
Chapter 10 
Pointers 
17. Look at the following array definition. 
i nt numbers [] = {2, 4, 6, 8, 10}; 
What will the following statement display? 
cout <<*(numbers
+ 3) << endl; 
18. What is the purpose of the new operator? 
19. What happens when a program uses the new operator to allocate a block of 
memory, but the amount of requested memory isn't availab le? How do programs 
written with older compilers handle this? 
20. Under what circumstances can you successfully return a pointer from a function? 
21. What is the purpose of the dele t e operator? 
22. What is the difference between a pointer to a constant and a constant pointer? 
23. Show C++ code for defining a variable ptr that is a pointer to a constant i nt . 
24. Show C++ code for defining a variable ptr that is a constant pointer to i nt. 
25. How do smart pointers differ from regular pointers? 
26. Name the header file that needs to be included in a program that uses smart 
pointers . 
2 7. What happens when a uni que_pt r that is managing an object is assigned the 
nul l pt r value? 
28. What does the get () method of the uni que_pt r classs do? 
29. What is the name of the class of smart pointer that allows more than one pointer 
to own the same object? 
30. List three different operations that are permitted on raw pointers but not on 
uni que_pt r objects. 
31. Why shou ld programmers prefer the use of the make_shared function when 
creating shared pointers? 
32. What problems are likely to occur if you have the following declaration in your 
program? 
shared _ptr<double 
[ ] > sDPtr; 
C++ Language Elements 
33. Consider the function 
voi d change(int 
*p) 
{ 
*p = 20; 
} 
Show how to call the change function so that it sets the integer variable 
i nt i ; 
to 20. 

34. Consider the function 
voi d modify(int 
& x) 
{ 
X = 10; 
} 
Review Questions and Exercises 
699 
Show how to call the modify function so that it sets the integer 
i nt i ; 
to 10. 
Algorithm Workbench 
35. Write a function whose prototype is 
voi d exchange(i nt *p, in t *q); 
that takes two pointers to integer variables and exchanges the values in those 
variab les. 
36. Write a function 
voi d switchEnds(in
t *array, 
i nt size); 
that is passed the address of the beginning of an array and the size of the array. The 
function swaps the values in the first and last entries of the array. 
Predict the Output 
3 7. Given the variable initializations 
i nt a[5] = {O, 10, 20, 30, 40}; 
i nt k = 3; 
i nt *p =a+ 
1; 
determine the output from each of the following statements: 
A) cout 
<< a[k]; 
B) cout 
<< *(a+k); 
C) cout 
<< *a; 
D) cout 
<< a[*a]; 
E) 
cout 
<< a[ *a + 2]; 
F) cout 
<< *p; 
G) cout 
<< p[O] ; 
H) cout 
<< p [ 1 l ; 
Find the Error 
38. Each of the following declarations and program segments has errors. Locate as 
many as you can . 
A) i nt pt r*; 
B) i nt x, *pt r; 
&x = ptr; 
C) i nt x, * pt r ; 
*ptr = &x; 

700 
Chapte r 10 
Pointers 
D) i nt x, *pt r; 
pt r = &x; 
pt r = 100 ; II Store 
100 in x 
cout << x << end l; 
E) i nt numbers[ ] = {10 , 20, 30, 40 , 50}; 
cout << "The t hi rd el ement i n the array 
is"· 
cout <<*numbers+ 
3 << end l; 
F) i nt values [20], 
*i ptr; 
i ptr = va l ues; 
i ptr *= 2; 
G) double l eve l ; 
i nt dPtr = &l eve l; 
H) 
i nt *i pt r = &iva l ue ; 
i nt i va lue ; 
I) 
voi d doub l eVal (i nt val) 
{ 
*val *- 2 · ' 
} 
J) i nt *pi nt; 
new pint ; 
K) 
i nt *pi nt; 
pint= 
new in t ; 
pint= 
100; 
L) 
i nt *pi nt; 
pint= 
new in t[1 00]; 
II Al l ocate memory 
Process 
the array 
delete 
pi nt; 
II 
Free memory 
M) i nt *getNum() 
{ 
} 
i nt whol eNum; 
cout << "Ente r a number : "; 
cin >> whol eNum; 
r eturn 
&wholeNum; 
N) 
unique_ptr 
u = new unique_pt r( new i nt); 
0) 
uni que_ptr<i nt > u = make_unique<i nt> (); 
unique_ptr<int> 
v; 
V = u ; 
P) unique_ptr<int>u
(new i nt); 
unique_ptr<int>v
; 
v.reset(u); 
Soft Skills 
39. Suppose that you are a manager of a programming team. To facilitate project 
development and maintenance, you have decided to establish some programming 
and coding guidelines. Make a list of pointer-related programming guidelines you 
think will improve program readabi lity and decrease pointer-related bugs. 

Programming Challenges 
701 
Programming 
Challenges 
1. Test Scores #1 
Write a program that dynamically allocates an array large enough to hold a user-defined 
number of test scores. Once all the scores are entered, the array should be passed to a 
function that sorts them in ascending order. Another function should be called that calculates 
the average score. The program should display the sorted list of scores and averages with 
appropriate headings. Use pointer notation rather than array notation whenever possible. 
Input Validation: Do not accept negative numbers for test scores. 
2. Test Scores #2 
Modify the program of Programming Challenge 1 to allow the user to enter name-score 
pairs. For each student taking a test, the user types a string representing the name of the 
student, followed by an integer representing the student's score. Modify both the sorting 
and average-calculating functions so they take arrays of structures, with each structure 
containing the name and score of a single student. In traversing the arrays, use pointers 
rather than array indices. 
3. Indirect Sorting Through Pointers #1 
Consider a company that needs to sort an array Perso n dat a [ 1 OJ of structures of type 
Person by name. 
st ruc t Person 
{ 
} 
string 
name; 
i nt age; 
In real life the Person structures may have many members and occupy a large area of 
memory, making it computa tionally expensive to move Person objects around while 
sorting . You can define an auxiliary array Person 
* pData [ 1 OJ, setting each entry of 
pData [ k] to point to the corresponding entry of data[k]. 
Write a program that sorts 
the array of pointers so that when you go through pData in increasing order of index k, 
the entries pData[k] 
point to Person objects in ascending alphabe tic order of names. 
4. Indirect Sorting Through Pointers #2 
Write a program that solves the problem of Programming Challenge 3, except that the 
array of pointer points to the data array in descending order of age. 
5. Pie a la Mode 
In statistics the mode of a set of values is the value that occurs most often. Write a 
program that determines how many pieces of pie most people eat in a year. Set up an 
integer array that can hold responses from 30 people. For each person, enter the 
number of pieces they say they eat in a year. Then write a function that finds the mode 
of these 30 values. This will be the number of pie slices eaten by the most people. The 
function that finds and returns the mode should accept two arguments, an array of 
integers, and a value indicating how many elements are in the array. 

702 
Chapte r 10 
Pointers 
VideoNote 
Solving the 
Days in Current 
Month Problem 
6. Median Function 
In statistics the median of a set of values is the value that lies in the middle when the values 
are arranged in sorted order. If the set has an even number of values, then the median is 
taken to be the average of the two middle values. Write a function that determines the 
median of a sorted array. The function should take an array of numbers and an integer 
indicating the size of the array and return the median of the values in the array. You may 
assume the array is already sorted. Use pointer notation whenever possible. 
7. Movie Statistics 
Write a program that can be used to gather statistica l data about the number of movies 
college students see in a month. The program should ask the user how many students 
were surveyed and dynamically allocate an array of that size. The program should then 
allow the user to enter the number of movies each student has seen. The program 
should then calculate the average, median, and mode of the values entered. 
8. Days in Current Month 
Write a program that can determine the number of days in a month for a specified month 
and year. The program should allow a user to enter two integers representing a month and 
a year, and it should determine how many days are in the specified month . The integers 1 
through 12 will be used to identify the months of January through December. The user 
indicates the end of input by entering O O for the month and year. At that point, the 
program prints the number of days in the current month and terminates. 
Use the following criteria to identify leap years: 
1. A year Y is divisible by 100. Then Y is a leap year if and only if it is divisible by 
400. For example, 2000 is a leap year but 2100 is not. 
2. A year Y is not divisible by 100. Then Y is a leap year if and only if it is divisible 
by 4. For example, 2008 is a leap year but 2009 is not. 
Here is sample run of the program: 
Enter mont h and year: 
2 2008[Enter] 
29 days 
Enter mont h and year: 
0 O[Enter] 
The current 
month, September 2009, has 30 days. 
9.Age 
Write a program that asks for the user's name and year of birth, greets the user by name, 
and declares the user's age in years. Users are assumed to be born between the years 
1800 and 2099, and should enter the year of birth in one of the three formats 18XX, 
19XX, or 20XX . A typical output should be "Hello Caroline, you are 23 years old." 
10. Modify the program Prl0 -16 so that it uses smart pointers rather than raw pointers. 

TOPICS 
11.1 
11.2 
11.3 
11.4 
11.5 
11.6 
11.7 
11.8 
The this Pointer and Constant Member 
11.9 
Type Conversion Operators 
Functions 
11.10 Convert Constructo rs 
Static Members 
11.11 Aggregation and Composition 
Friends of Classes 
11.12 Inheritance 
Memberwise Assignment 
11.13 Protected Members and Class Access 
Copy Constructors 
11.14 Constructors, Destructors, and Inheritance 
Operator Overloading 
11.15 Overriding Base Class Functions 
Rvalue References and Move Operations 
11.16 Tying It All Togethe r: Putting Data on the 
Function Objects and Lambda Expressions 
World Wide Web 
The this Pointer and Constant Member 
Functions 
CONCEPT: 
By default, the comp iler provides each member function of a class wit h 
an implicit parameter 
that points to the object through 
which the 
member fun ction is called. Th e implicit parameter 
is calle d this. 
A 
cons tant member function 
is one th at does not modif y th e object 
through which it is called. 
The this 
Pointer 
Consider the class 
class 
Example 
{ 
} ; 
int x ; 
public: 
Example (i nt a){ x = a ;} 
voi d setValue(int
); 
i nt get Value(); 
703 

704 
Chapter 11 
More about Classes and Object-Oriented Programming 
with the member function 
i nt Example: :getVa lu e( ) 
{ 
return x; 
) 
that simply returns the value in an object of the class. As an example, the getVal ue 
function might be invoked in a program such as 
i nt mai n() 
{ 
) 
Example ob1(10), ob2(20 ); 
cout << ob1 .getValue () << " " << ob2 .getVal ue(); 
return 
O; 
in which case the program would print out the values 1 O 
20. 
You learned in an earlier chapter that the different objects of a structure or class type 
are called instances of that class and that each instance of a class has its own copy of 
the data members listed in the class. These data members , called instance members 
because they belong to instances of the class, can have different values in different 
objects. Thus, in the preceding examp le, the instance member x in the ob1 object has a 
value of 1 O while x in ob2 has a value of 20. 
Now consider again the code for the member function 
int Example: :getVa lu e( ) 
{ 
return x; 
) 
This function is supposed to return the x member of some object of the Ex amp 1 e class, 
but how does it know which object to use? What happens is that by default, the compiler 
provides each member function of every class with an implicit parameter that is a 
pointer to an object of the class. Thus, for example, the getVal ue function is equipped 
with a single parameter of type pointer to Example. Similarly, the member function 
voi d Exampl e : :setValue (int a) 
{ 
X = a ; 
) 
although written by the programmer to take a single parameter of type int , in reality 
has two parameters: an pointer to an object of the class Ex amp 1 e, and the 
i nt a 
parameter specified by the programmer. In all cases, the actual parameter for the 
implicit object parameter is the address of the object through which the member 
function is being called. Thus, in the call 
ob1 .getValue () 
the implicit parameter passed to get Value is the address of ob1, whereas in the call 
ob2.setValue(78) 
the implicit parameter passed to setVa l ue is &ob2. 

11.1 The this Pointer and Constant Member Functions 
705 
The implicit pointer passed by the compiler to a member function can be accessed by 
code inside that function by using the reserved keyword th i s. So for examp le, a 
member function of the Example class could access the object through which it is called 
by using the expression 
*t his 
and it could also access any of the members of that object through the same pointer. 
Program 11-1 illustrates these concepts . It modifies the Ex amp 1 e class to include a 
member function that uses the this pointer to print the address of the object through 
which it is called as well as the value of the instance member x in the same object . 
Program 11-1 
Contents of Thi sExamp 1 e . h 
1 class 
Example 
2 { 
3 
int x; 
4 
publ i c: 
5 
Example( i nt a){ x = a;} 
6 
voi d setValue(int); 
7 
voi d printAddressAndValue(); 
8 } ; 
Contents of Thi sExamp 1 e . cpp 
1 #include 
"ThisExample.h" 
2 #include 
<iostream> 
3 using namespace std; 
4 
5 //***************************************** 
6 II Set value of object. 
* 
7 //***************************************** 
8 void Example: :se tVa lue(i
nt a) 
9 { 
10 
X = a; 
11 } 
12 //***************************************** 
13 II Pr i nt address 
and value. 
* 
14 //***************************************** 
15 void Example: :printAddressAndValue() 
16 { 
17 
cout << "The object 
at address"<< 
this<<" 
has" 
18 
<<"value"<< 
(*this ).x << endl; 
19 } 
Contents of main program , pr11-1 . cpp 
1 II This program illustrates 
the this 
poi nter . 
2 #include 
<iostream> 
3 #include 
"ThisExample.h" 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
Example ob1(10), 
ob2(20); 
9 
(program continues) 

706 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11 -1 
(continued) 
10 
// Print 
the addresses 
of the two objects 
11 
cout << "Addresses of objects 
are " << &ob1 
12 
<<"and"<< 
&ob2 << endl; 
13 
14 
// Print 
the addresses 
and values 
from within 
15 
// the member function 
16 
ob1 .pr i ntAddressAndValue(); 
17 
ob2.pr i ntAddressAndValue(); 
18 
19 
return 
O; 
20 } 
Program Output 
Addresses 
of objects 
are Ox241ff5c and Ox241ff58 
The object 
at address 
Ox241ff5c has value 10 
The object 
at address 
Ox241ff58 has value 20 
As an examp le of a common use of the this pointer, consider the member function 
voi d Example: :setValue(int 
a} 
{ 
X = a; 
} 
It is natural to name the parameter to be used to set the value of the member x using an 
identifier that makes its connection to x explicit, perhaps xVa 1 ue or even x itself. However, 
a formal parameter of a member function with the same identifier as a member of the class 
will hide the class member, making it inaccessible inside the function. The this pointer can 
be used to qualify the name of the class member and make it visible again . Here is the 
set Value member function rewritten in this manner: 
voi d Example: :setValue(
i nt x} 
{ 
this - >x = x; 
} 
Recall from Chapter 10 that the notation this - >x is equivalent to (*this) .x. 
Constant Member Functions 
A parameter that is passed to a function by reference or through a pointer may be 
modified by that function. The const key word is used with a parameter to prevent the 
called function from modifying it. For example, a function declared as 
voi d fun(const 
string 
&str}; 
takes a reference to a string object as a parameter but will not be able to modify the 
object . A similar mechanism can be used to protect the implicit parameter *this from 
being modified by a member function. When placed right after the parameter list in the 
definition of a member function, the const key word serves as an indication to the 
comp iler that the member function shou ld not be allowed to modify its object . If the 
member function is defined outs ide the class, both the in-class declaration and the 
definition must have the const. Here is an example: 

11.1 The this Pointer and Constant Member Functions 
707 
class 
ConstExample 
{ 
int x ; 
publ ic : 
ConstExample(int 
a ){ x = a ;} 
void setValue(
i nt}; 
int getValue() 
const; 
} ; 
T he defin ition of the get Va 1 ue function wou ld be 
i nt ConstExample::getValue() 
const 
{ 
return 
x; 
} 
A function with a constant parameter x cannot tum around and pass x as a non-constant 
parameter to anothe r function. In othe r words, a funct ion that promises not to modify 
x may not pass x to another function unless that second function also promises not to 
modify x. Thi s can sometimes occur in ways that are not obvio us. Th e following 
program uses a funct ion with a constant parameter to print the first element of an array. 
It does not compile because it is not consistent in its use of const. 
#i nclude <i ostream> 
using namespace std; 
class 
K 
{ 
public: 
void output() 
{ 
// Missing const! 
cout << "Output of a K object"<< 
endl; 
} 
} ; 
void outputFirst(const 
Karr[
] } 
{ 
arr[O] .outpu t (}; 
} 
int main (i nt argc, 
char* * argv} 
{ 
} 
Karr[
] = { K() }; 
outputFirst
(a r r}; 
return 
O; 
Th e program does not compile because the compiler cannot guarantee that an element 
of the const array will not be modified when passed as the implicit this parameter to 
the output member function: 
arr[O] .output(); 

708 
Chapte r 11 
Figure11-1 
More about Classes and Object-Orien ted Programming 
You can get the program to compile by making output () a con st member function to 
signify that it has a constant this parameter: 
class 
K 
{ 
public: 
} ; 
void output() 
const 
{ 
} 
cout << "Output of a K object"<< 
endl; 
Static Members 
CONCEPT: 
If a member variab le is declared static
, all objects of that class have 
access to that variab le. If a member function is declared stat i c, it may 
be called before any instances of the class are defined. 
By default, each class object (an instance of a class) has its own copy of the class's 
member variab les. An object's member variab les are separate and distinct from the 
member var iables of other objects of the same class. For examp le, consider the 
following declaration: 
class 
Widget 
{ 
} ; 
private: 
doubl e price; 
i nt quant i ty; 
public: 
Widget (double p, int q) 
{p rice
= p; quantity
= q ; } 
doubl e getPrice() 
const 
{ return 
pr i ce ; } 
i nt getQuantity
() const 
{ return 
quantity
; } 
Assume that in a program , two separate instances of the Widget class are created by the 
following declaration: 
Widget w1(14. 50 , 100), w2(12 .75 , 500 ); 
Thi s statement creates w1 and w2, two distinct objects . Each has its own pr i ce and 
quantity 
member variables. This is illustrated by Figure 11-1. 
w1 Object 
I 14.50 11 100 
price quantity 
w2 Object 
12.15 11 500 
price quantity 

Figurel 1-2 
11.2 Static Membe rs 
709 
When the getQuant i ty member function of either instance is called, it returns the 
value stored in the calling object's quantity 
variable. Based on the values initially 
stored in the objects, the statement 
cout << w1 .getQuantity
() <<" 
" << w2.getQuantity(); 
will cause 100 500 to be displayed . 
Static Member Variables 
It's possible to create a member variable that is shared by all the objects of the same 
class. To create such a member, simply place the key word static 
in front of the 
variable declaration, as shown in the following class: 
class 
StatDemo 
{ 
private: 
static 
int x; 
int y; 
public : 
void setx( i nt a) const 
void sety( i nt b) const 
int getx() 
{ return 
x; 
int gety() 
{ return 
y; 
{ 
X 
: a· ' } 
{ y = b · } 
' 
} 
} 
} ; 
Next, place a separate definition of the variab le outside the class, such as: 
int Stat Demo: : x; 
In this example, the member variable x will be shared by all objects of the StatDemo class. 
When one class object puts a value in x, it will appear in all other StatDemo objects. 
For example, assume the following statements appear in a program: 
StatDemo obj1, obj2; 
obj 1 . setx ( 5) ; 
obj 1 . set y ( 1 0) ; 
obj 2. set y ( 20) ; 
cout << "x: 
"<< 
obj1.getx() 
<< 
cout << "y: 
"<< 
obj1.gety() 
<< 
The cout statements shown will display 
x: 5 5 
y: 10 20 
II 
II 
II 
II 
<< obj2.getx() 
<< endl; 
<< obj2.gety() 
<< endl; 
The value 5 is stored in the static member variable x by the object obj 1. Since obj 1 and obj 2 
share the variable x, the value 5 shows up in both objects. This is illustrated by Figure 11-2. 
Static Member x 
III 
obj1 
obj2 
Member y 
\ 
Membery 
OD 
~ 
Both obj 1 and obj 2 share the static member x 

710 
Chapte r 11 
More about Classes and Object-Oriented Programming 
A more practical use of a static member variable is demonstrated in Program 11-2. The 
Budget class is used to gather the budget requests for all the divisions of a company. 
The class uses a static member, corpBudget, to hold the amount of the overall corporate 
budget. When the member function addBudget is called, its argument is added to the 
current contents of corpBudget. By the time the program is finished, corpBudget will 
conta in the total of all the values placed there by all the Budget class objects. 
Program 11-2 
Contents of budget . h 
1 #ifndef 
BUDGET
_H 
2 #define 
BUDGET
_H 
3 
4 class 
Budget 
5 { 
6 private: 
7 
8 
stat i c double corpBudget; 
double divBudget; 
9 public: 
10 
11 
12 
13 
14 
15 } ; 
Budget() 
{ divBudget 
= O; } 
voi d addBudget(double 
b) 
{ di vBudget += b; corpBudget 
+= di vBudget; 
} 
double getDivBudget() 
const 
{ return 
divBudget; 
} 
double getCorpBudget() 
const 
{ return 
corpBudget; 
} 
16 #endif 
Contents of main program , pr11 -2. cpp 
1 II This program demonstrates 
a stat i c class 
member var i able. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 #include 
"budget.h" 
II For Budget class 
declaration 
5 using namespace std; 
6 
7 II Definition 
of the static 
member of the Budget class 
8 double Budget::corpBudget 
= O; 
9 
10 int main() 
11 { 
12 
13 
14 
const i nt N_DIVISIONS = 4; 
Budget div i sions[N _DIVISIONS]; 
15 
II Get the budget request 
for each di vi sion 
16 
for (i nt count= 
O; count< 
N_DIVISIONS; count++) 
17 
{ 
18 
double bud ; 
19 
20 
cout << "Enter the budget request 
for division"; 
21 
cout <<(count+ 
1) << ": "; 
22 
cin >> bud ; 
23 
div i sions[count].addBudget(bud); 
24 
25 
} 
(program continues) 

11.2 Static Membe rs 
711 
Program 11 -2 
(continued) 
26 
II Display 
the budget request 
for each division 
27 
cout << setprecis
i on(2); 
28 
cout << showpoint 
<< fixed; 
29 
cout << "\nHere are the division 
budget requests:\n"; 
30 
for 
(int 
count= 
O; count< 
N_DIVISIONS; count++) 
31 
{ 
32 
cout <<"Division"<< 
(count+ 
1) << "\t$ 
"; 
33 
cout << divisions[count] 
.getDivBudget() 
<< endl; 
34 
} 
35 
36 
II Display 
the total 
budget request 
37 
cout << "Total 
Budget Requests:\t$ 
"; 
38 
cout << divisions[O
J .getCorpBudget() 
<< endl; 
39 
40 
return 
O; 
41 } 
Program Output with Example Input Shown in Bold 
Enter the budget request 
for division 
1 : 102000[Ent
er] 
Enter the budget request 
for division 
2: 201 OOO[Enter] 
Enter the budget request 
for division 
3: 570000[Ent
er] 
Enter the budget request 
for division 
4: 1001 OO[Enter] 
Here are the division 
budget requests: 
Division 
1 
$ 102000.00 
Division 
2 
$ 201000.00 
Division 
3 
$ 570000.00 
Division 
4 
$ 100100.00 
Total 
Budget Requests: 
$ 973100.00 
0 
N OT E: Static member variables furnish a good example of the distinction between C++ 
declarations and C++ definitions. A declaration provides information about the existence 
and type of a variable or function. A definition provides all the information contained in a 
declaration and, in addition, causes memory to be allocated for the variable or function being 
defined. Static member variables must be declared inside the class and defined outside of it. 
In genera l, we can divide the member variab les and functions of a class into two groups: 
instance members and static members . An instance member is one whose use must be 
assoc iated with a particular instance of the class. In particular, an instance var iable of 
a class must be accessed through a specific instance of its class, and an instance member 
function must be called through a specific instance of its class . 
In contrast, the use of a stat ic member variable, or the call of a static member function, 
does not need to be associated with any instance. Only the class of the stat ic member 
needs to be specified . 
Static Member Functions 
A member function of a class can be declared static by prefixing its declarat ion with 
the key word static. 
Here is the general form: 
stat i c <return 
type><function 
name>(<parameter list>) 

712 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Static member functions are normally used to work with stat ic member variab les of the 
class. In fact, member functions that do not access any nonstat ic members of their 
class, such as getCorpBudge t () in Program 11-2, should be made static. 
Program 11-3, a modificat ion of Program 11-2, demonstrates this. It asks the user to 
enter the main office's budget request before any division requests are entered . The 
Budget class has been modified to include a static member function named mai nOffi ce. 
This function adds its argument to the static corpBudge t variable and is called before 
any instance of the Budget class is defined . The get CorpBudget () function has also 
been made static . 
Program 11-3 
Contents of budget 2 . h 
1 #ifndef 
BUDGET
_H 
2 #define 
BUDGET
_H 
3 
4 class 
Budget 
5 { 
6 private: 
7 
stat i c double corpBudget; 
8 
double di vBudget; 
9 public: 
10 
Budget() 
{ divBudget = O; } 
11 
voi d addBudget (double b) 
12 
{ di vBudget += b; corpBudget 
+= di vBudget ; } 
13 
double get DivBudget() 
cons t { return 
di vBudget; 
} 
14 
stat i c double getCorpBudge t () { return 
corpBudget; 
} 
15 
stat i c void mainOff i ce(double); 
16 } ; 
17 #endif 
Contents of budget 2 . cpp 
1 #include 
"budget2. h" 
2 
3 II Defi nition 
of t he static 
member of Budget class. 
4 double Budget ::corpBudget 
= O; 
5 
6 //********************************************************** 
7 II Defi nition 
of static 
member fu nction 
mainOffice 
8 II Thi s func ti on adds the main office's 
budget reques t t o 
9 II t he corpBudge t variable. 
* 
* 
* 
10 //********************************************************** 
11 void Budget ::mainOff i ce(double 
budReq) 
12 { 
13 
corpBudge t += budReq; 
14 } 
Contents of main program , pr1 1 -3 . cpp 
1 II Thi s program demonstra t es a stat i c class 
member func ti on . 
2 #include 
<iostream> 
3 #include 
<io manip> 
4 #include 
"budget2. h" 
II For Budget class 
declara ti on 
5 using namespace std; 
6 
(program continues) 

Program 11 -3 
7 int main() 
8 { 
(continued) 
9 
const i nt N_DIVISIONS = 4; 
10 
11 
II Get the budget requests 
for each division 
12 
cout << "Enter the mai n office's 
budget request: 
"; 
13 
double amount; 
14 
cin >> amount; 
15 
II Call the static 
member function 
of the Budget class 
16 
Budget::ma i nOff i ce(amount); 
17 
II Create 
i nstances 
of the Budget class 
18 
Budget di vi sions[N _DIVISIONS]; 
19 
for (i nt count= 
O; count< 
N_DIVISIONS; count++) 
20 
{ 
21 
double bud; 
22 
23 
cout << "Enter the budget request 
for division"; 
24 
cout << ( count + 1 ) << " : "; 
25 
cin >> bud; 
26 
di vi s i ons[count].addBudget(bud); 
27 
} 
28 
29 
II Display 
the budget for each di vis i on 
30 
cout << setprecis
i on(2); 
31 
cout<< showpoint 
<< f i xed; 
32 
cout << "\nHere are the division 
budget requests:\n"; 
33 
for (i nt count= 
O; count< 
N_DIVISIONS; count++) 
34 
{ 
35 
cout << "\ tDi vi si on "<<(count
+ 1) << "\t$ 
"; 
36 
cout << divisions[count].getD
i vBudget() 
<< endl; 
37 
} 
38 
39 
II Print 
total 
budget requests 
40 
cout << "Total 
Requests 
(including 
main office):$"· 
41 
cout << Budget::getCorpBudget() 
<< endl; 
42 
return 
O; 
43 } 
Program Output with Example Input Shown in Bold 
Enter the main office's 
budget request: 
400000 [Enter] 
Enter the budget request 
for division 
1 : 102000[Ent
er] 
Enter the budget request 
for division 
2: 21 OOOO[Enter] 
Enter the budget request 
for division 
3: 240000[Ent
er] 
Enter the budget request 
for division 
4: 105000[Ent
er] 
Here are the division 
budget requests: 
Division 
1 
$ 102000.00 
Division 
2 
$ 210000.00 
Division 
3 
$ 240000.00 
Division 
4 
$ 105000.00 
Total Requests 
(including 
main office): 
$ 1057000.00 
11.2 Static Membe rs 
713 

714 
Chapter 11 
More about Classes and Object-Oriented Programming 
Notice the statement that calls the static function mai nOffi ce: 
Budget : :mainOff i ce(a mount ); 
Calls to static member functions are normally made by connecting the function name to 
the class name with the scope resolution operator. If objects of the class have been defined, 
static member functions can also be called by connecting their names to the object with 
the dot operator. Thus, the last output statement of Program 11-3 could be written as 
cout << divisio
ns[O] .getCorpBudget() 
<< endl; 
The th i s pointer cannot be used in a static member function because static member 
functions are not called through any instance of their class. Moreover, a static member 
function cannot access an instance member of its class unless it specifies what instance 
the member belongs to. For example, in the class 
class St at Access 
{ 
} ; 
private: 
i nt x; 
public: 
static 
void outpu t () 
{ 
cout << x; 
// Incorrect 
access of non-static 
member 
} 
StatAccess(i
nt x) { this - >x = x; } 
The attempt to access x in the statement cout << x is incorrect because it is tantamount 
to an implicit use of the t his pointer, which the static function output does not have. In 
contrast, in the following modified example of the same class, the static member function 
pr i nt correctly accesses the nonstatic member x because it qualifies it with the name of 
a class object passed to it as a parameter. 
class St at Access 
{ 
} ; 
private: 
i nt x; 
public: 
st at ic voi d pri nt (StatAccess 
a) 
{ 
cout << a.x; 
} 
StatAccess(i
nt x) { this - >x = x; } 
An advantage of static member functions is that they can be called before any instances 
of the class have been created . This allows them to be used to perform complex 
initializat ion tasks that have to be done before objects of the class have been created . 
C++ uses the key word static 
to describe both static class members and static local 
variables. To understand why, it is helpful to look at the distinction between instance and 
static class members. Each object of the class has its own copy of the instance members, but 
all objects share the same static members. Similarly, each call to a function has its own copy 
of the non-static local variables, but all function calls share the same static local variables. 
In this analogy, the function definition corresponds to the class, function calls correspond 
to objects of the class, and non-static local variables correspond to instance members. 

11.3 Friends of Classes 
715 
Friends of Classes 
CONCEPT: 
A friend is a function that is not a member of a class but has access to 
the private members of the class. 
Private members are hidden from all parts of the program outside the class, and 
accessing them requires a call to a public member function. Sometimes you will want to 
create an except ion to that rule. A friend function is a function that is not a member of 
a class but that has access to the class's private members . In other words, a friend 
function is treated as if it were a member of the class. A friend function can be a regular 
stand -alone function, or it can be a member of another class. (In fact, an entire class 
can be declared a friend of anothe r class.) 
In order for a function or class to become a friend of another class, it must be declared 
as such by the class granting it access. Classes keep a "list" of their friends, and only 
the external functions or classes whose names appear in the list are granted access. A 
function is declared a friend by placing the key word friend in front of a prototype of 
the function . Here is the general format: 
friend 
<return 
type><function 
name>(<parameter type list> ); 
In the following declaration of the Budget class, the addBudget function of another 
class, Aux, has been declared a friend: 
class 
Budget 
{ 
private: 
static 
double corpBudget ; 
double divBudget; 
publ ic : 
) ; 
Budget () { di vBudget = O; } 
void addBudget(double 
b) 
{ divBudget += b; corpBudget += divBudget; 
) 
double getDivBudget () const { re t urn divBudge t ; ) 
static 
double getCorpBudget() 
{ ret urn corpBudget; 
} 
static 
void mai nOffice(double); 
friend 
void Aux::addBudge t (double ); 
II A friend 
Let's assume anothe r class Aux represents a division's auxiliary office, perhaps in 
another country. The auxiliary office makes a separate budget request, which must be 
added to the overall corporate budget . Th e friend declaration of the Aux: : addBudget 
function tells the compi ler that the function is to be granted access to Budget's private 
members. The function takes an argument of type double representing an amount to 
be added to the corporate budget: 
class Aux 
{ 
private: 
double auxBudget; 

716 
Chapte r 11 
More about Classes and Object-Oriented Programming 
public: 
Aux() { auxBudget = O; } 
void addBudget(double); 
double getDivBudget() 
{ return 
auxBudget; 
} 
} ; 
And here is the definition of the Aux addBudget member function: 
voi d Aux: :addBudget(double 
b) 
{ 
auxBudget += b; 
Budget: :corpBudge t += auxBudget; 
} 
The parameter b is added to the corporate budget, which is accessed by using the expression 
Budget: : corpBudget. Program 11-4 demonstrates the classes in a complete program. 
Program 11-4 
Contents of aux i 1 . h 
1 #ifndef 
AUXIL_H 
2 #define 
AUXIL_H 
3 
4 II Aux class 
declaration. 
5 class 
Aux 
6 { 
7 private: 
8 
double auxBudget; 
9 public: 
10 
Aux() { auxBudget = O; } 
11 
voi d addBudget(double); 
12 
double getDivBudget() 
const 
{ return 
auxBudget; 
} 
13 } ; 
14 #endif 
Contents of budget3 . h 
1 #ifndef 
BUDGET3
_H 
2 #define 
BUDGET3
_H 
3 #include 
"aux i l .h" 
4 
II For Aux class 
declaration 
5 II Budget class 
declarat
i on . 
6 class 
Budget 
7 { 
8 private: 
9 
static 
double corpBudget; 
10 
double di vBudget; 
11 public: 
12 
Budget() 
{ divBudget 
= O; } 
13 
voi d addBudget(double 
b) 
14 
{ di vBudget += b; corpBudget 
+= di vBudget; 
} 
15 
double getDivBudget() 
const 
{ return 
di vBudget; 
} 
16 
stat i c double getCorpBudget() 
{ return 
corpBudget; 
} 
17 
stat i c void mainOff i ce(double); 
18 
fr i end void Aux: :addBudget(double); 
19 } ; 
20 #endif 
(program continues) 

Program 11-4 
(continued) 
Contents of budget3 . cpp 
1 #include 
"budget3.h" 
2 
3 II Definition 
of static 
member. 
4 double Budget::corpBudget 
= O; 
5 
6 //********************************************************** 
7 II Definition 
of static 
member function 
mainOffice 
8 II Thi s funct i on adds the main office
' s budget request 
to 
9 II the corpBudget 
variable. 
* 
* 
* 
10 //********************************************************** 
11 void Budget: :mainOff i ce(double 
budReq) 
12 { 
13 
corpBudget 
+= budReq; 
14 } 
Contents of aux i l . cpp 
1 #include 
"aux i l.h" 
2 #include 
"budget3.h" 
3 
4 //*********************************************************** 
5 II Definition 
of member function 
addBudget 
* 
6 II Thi s funct i on is declared 
a fr i end by the Budget class 
* 
7 II It adds the value of argument b to the static 
corpBudget 
* 
8 II member var i able of the Budget class
. 
* 
9 //*********************************************************** 
10 
11 void Aux::addBudget(double 
b) 
12 { 
13 
14 
15 } 
auxBudget += b; 
Budget: :corpBudget 
+= auxBudget ; 
Contents of main program pr11 -4 . cpp 
1 II Thi s program demonstrates 
a stat i c class 
member var i able . 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 #include 
"budget3.h" 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
const i nt N_DIVISIONS = 4; 
10 
11 
II Get the budget requests 
for the di visions 
and 
12 
II off i ces 
13 
cout << "Enter the mai n office's 
budget request: 
"· 
14 
double amount; 
15 
cin >> amount; 
16 
Budget::ma i nOffice(amount); 
17 
11.3 Friends of Classes 
717 
(program continues) 

718 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11-4 
(continued) 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
// Create 
the di vi si on and aux i l i ary offices 
Budget div i sions[N _DIVISIONS]; 
Aux auxOff i ces[N _DIVISIONS]; 
cout << "\nEnter 
the budget requests 
for the divisions 
and 
<< "\ntheir 
auxiliary 
off i ces as prompted:\n"; 
for (i nt count= 
O; count< 
N_DIVISIONS; count++) 
{ 
double bud; 
cout << 
"Di vi si on''<< 
(cou nt + 1) << "· 
"; 
cin >> bud; 
divisions[count
] .addBudget(bud); 
" 
30 
31 
cout <<"Division"<< 
(count+ 
1) << "'s auxil i ary office: 
"; 
cin >> bud; 
32 
33 
34 
35 
36 
37 
38 
39 
40 
auxOff i ces[count].addBudget(bud); 
} 
// Pr i nt the budgets 
cout << setprecision(2); 
cout << showpoi nt << f i xed; 
cout << "Here are the division 
budget requests:\n"; 
for (i nt count= 
O; count< 
N_DIVISIONS; count++) 
{ 
41 
42 
cout << "\tDivision: 
"<<(cou
nt + 1) << "\t\t\t$ 
"; 
cout << setw(7); 
43 
cout << divis i ons[count] 
.getDivBudget() 
<< endl; 
44 
45 
cout << "\tAuxiliary 
Office 
of Di vision"<< 
(cou nt+ 1); 
cout << "\t$ 
"; 
46 
47 
cout << auxOffices[count].getD
i vBudget() 
<< endl; 
} 
48 
// Pr i nt total 
requests 
49 
50 
cout << "\ tTota l Requests 
(includ ing main office): 
$ "; 
cout << Budget: :getCorpBudget() 
<< endl; 
51 
return 
O; 
52 } 
Program Output with Example Input Shown in Bold 
Enter the main office's 
budget request: 
100000[Enter] 
Enter the budget requests 
for the divisions 
and 
their 
auxiliary 
offices 
as prompted: 
Division 
1: 100000[Enter] 
Division 
1 's auxiliary 
office: 
500000[Enter] 
Division 
2: 200000 [Enter] 
Division 
2's auxiliary 
office: 
40000[Enter] 
Division 
3: 300000 [Enter] 
Division 
3's auxiliary 
office: 
700000[Enter] 
Division 
4: 400000 [Enter] 
Division 
4's auxiliary 
office: 
650000[Enter] 
(program output continues) 

11.3 Friends of Classes 
719 
Program 11-4 
(continued) 
Here are the division 
budget requests: 
Division: 
1 
$ 100000.00 
Auxiliary 
Office of Division 
1 
$ 
50000.00 
Division: 
2 
$ 200000.00 
Auxiliary 
Office of Division 
2 
$ 
40000.00 
Division: 
3 
$ 300000.00 
Auxiliary 
Office of Division 
3 
$ 
70000.00 
Division: 
4 
$ 400000.00 
Auxiliary 
Office of Division 
4 
$ 
65000.00 
Tota l Requests (including 
main office): 
$ 1325000.00 
<) NOTE: 
As mentioned before, it is possible to make an entire class a friend of 
another class. The Budget class could make the Aux class its friend with the following 
declaration: 
friend 
class Aux; 
This may not be a good idea, however. Every member function of Aux (including 
ones that may be added later) would have access to the private members of Budget. 
The best pract ice is to declare as friends only those functions that must have access 
to the private members of the class. 
~ 
Checkpoint 
11.1 What is the difference between an instance member variable and a static member 
variab le? 
11.2 
Static member variables are declared inside the class declarat ion . Where are 
static member variables defined? 
11.3 
Does a static member variable come into existence in memory before, at the 
same time as, or after any instances of its class? 
11.4 
What limitation does a static member function have? 
11.5 
What action is possible with a static member function that isn't possible with an 
instance member function? 
11.6 If class X declares function f as a friend, does function f become a member of 
class X? 
11. 7 Suppose that class Y is a friend of class X, meaning that the member functions of 
class Y have access to all the members of class X. Should the friend key word 
appear in class Y's declaration or in class X's declaration? 

720 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
11.4 
Memberwise Assignment 
CONCEPT: 
Th e = operator may be used to assign one object to another , or to 
initialize one ob ject with another object's data. By default , each member 
of one object is cop ied to its count erp art in the other ob ject. 
Like ot her var iables (except arrays), objects may be assigned to each othe r using the = 
operator. As an example, consider Program 11-5, which uses a Rectang le class similar 
to the one discussed in Chapter 7 : 
Program 11 -5 
1 II This program demonstrates 
object 
assignment
. 
2 #include 
<iostream> 
3 us i ng namespace std; 
4 
5 class 
Rectangle 
6 { 
7 private: 
8 
doub l e width , length ; 
9 public : 
10 
Rectangle(do
uble width, 
double length ) 
11 
{ 
12 
this - >wi dth = width ; 
13 
this - >length 
= l ength ; 
14 
} 
15 
doub l e getWidth(} 
const 
{ return 
width ; } 
16 
doub l e getLength() 
const 
{ return 
l ength ; } 
17 
voi d output () const 
18 
{ 
19 
cout << "Width is•<< 
width<<·
, • 
20 
<< "Length is•<< 
length<< 
endl ; 
21 
} 
22 } ; 
23 
24 int mai n(} 
25 { 
26 
II Set up two rectangle 
objects 
27 
Rectang l e box1(10, 20}, box2(5, 
10}; 
28 
29 
II Display the rectang l e objects 
30 
cout << "Before the assignment:\n"; 
31 
cout << "Box 1 data:\t"; 
box1 .output(); 
32 
cout << "Box 2 data:\t"; 
box2 .output(); 
33 
34 
II Assignment 
35 
box2 = box1; 
36 
37 
II Display the rectang l e objects 
38 
cout << "\ nAfter the assign ment :\n"; 
(program continues) 

11.5 Copy Constructo rs 
721 
Program 11 -5 
(continued) 
39 
cout << "Box 1 data:\t"; 
box1 . output(); 
40 
cout << "Box 2 data:\t"; 
box2. outpu t (); 
41 
return 
O; 
42 } 
Program Output 
Before the ass i gnment: 
Box 1 data: 
Width is 10, Length i s 20 
Box 2 data: 
Width is 5, Length is 10 
After 
the assignment: 
Box 1 data: 
Width is 10, Length i s 20 
Box 2 data: 
Width is 10, Length i s 20 
As you can see, the statement 
box2 = box1 
copied the wi dt h and leng t h variables of box1 directly into the width and lengt h variables 
of box2. 
Memberwise assignment also occurs when one object is initialized with another object's 
values. Remember the difference between assignment and initialization: Assignment 
occurs between two objects that already exist, and initialization happens to an object 
being created. Consider the following program segment: 
Rectangle 
box1(10, 
50); 
Rectangle 
box2 = box1; 
The second statement defines a Recta ngle object box2 and initializes it to the values 
stored in box1 . Because memberwise assignment takes place, the box2 object will 
contain the same values as the box1 object . 
Copy Constructors 
CONCEPT: 
A copy constructor is a special constructor that is called whenever a 
new object is created and initialized with the data of another object of 
the same class. 
Many times it makes sense to create an object and have it start out with its data being 
the same as that of another, previously created object. For example, if Mary and Joan 
live in the same house and an address object for Mary has already been created, it 
makes sense to initialize Joan's address object to a copy of Mary's . In particular, suppose 
we have the following class to represent addresses: 
class 
Address 
{ 
pr i vat e: 
str i ng st reet; 

722 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
publ ic : 
} ; 
Address() 
{street=""; 
} 
Address(string 
st) 
{ setStreet
(s t ); } 
void setStreet(str
i ng st) 
{stre
et
= st; 
} 
str i ng getStreet
() const 
{ return 
street
; } 
We could then create Mary's address and initialize Joan's address to a copy of Mary's 
using the following code: 
Address mary("123 Main St"); 
Address joan = mary; 
Recall that a constructor must execute whenever an object is being created . When an 
object is created and initialized with another object of the same class, the compiler 
automat ically calls a special constr uctor, called a copy constructor, to perform the 
initialization using the existing object's data . This copy constr uctor can be specified by 
the programmer, as we will show shortly . 
The Default Copy Constructor 
If the programmer does not specify a copy constr uctor for the class, then the compiler 
automatically calls a default copy constructor . This default copy constructor simply 
copies the data of the existing object to the new object using memberwise assignment. 
Most of the time, the default copy constr uctor provides the kind of behavior that we 
want. For example, if after initializing Joan's address with Mary's, Joan later moves 
out and gets her own place, we can change Joan's address witho ut affecting Mary's. 
This is illustrated in Program 11-6. 
Program 11 -6 
1 // Thi s program demonstrates 
the operat i on of the 
2 // defau lt copy constructor
. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 using namespace std ; 
6 
7 class 
Address 
8 { 
9 private: 
10 
str i ng street; 
11 public: 
12 
Address() 
{street=""; 
} 
13 
Address(str
i ng st) 
{ setStreet
(st); 
} 
14 
void setStreet(str
i ng st) 
{s treet
= st; 
} 
15 
str i ng getStreet() 
const 
{ ret urn street; 
} 
16 } ; 
17 
18 int main() 
19 { 
20 
// Mary and Joan l i ve at same address 
(program continues) 

11.5 Copy Constructo rs 
723 
Program 11 -6 
(continued) 
21 
Address mary("1 23 Mai n St "); 
22 
Address joan = mary; 
23 
cout << "Mary lives 
at•<< 
mary.getStreet() 
<< endl; 
24 
cout << "J oan lives 
at•<< 
joan.getStreet() 
<< endl; 
25 
26 
II Now Joan moves out 
27 
joan.setStreet("1600 
Pennsylvania 
Ave"); 
28 
cout << "Now Mary lives 
at • << mary .getStreet() 
<< endl; 
29 
cout << "Now Joan lives 
at•<< 
joan .getStreet() 
<< endl; 
30 
31 
return 
O; 
32 ) 
Program Output 
Mary lives 
at 123 Main St 
Joan lives 
at 123 Main St 
Now Mary l ives at 123 Main St 
Now Joan lives 
at 1600 Pennsylvania 
Ave 
Deficiencies of Default Copy Constructors 
Ther e are times, however, when the behavior of the default copy constructo r is not 
what we expect . Consider a class 
class 
NumberArray 
{ 
private: 
double *aPtr; 
int arraySize
; 
public: 
} ; 
NumberArray(int 
size, 
double value); 
II -NumberArray(){ 
if (arrayS iz e > 0) delete 
[ ] aPtr;} 
void print () const; 
void setValue(double 
value); 
that encapsulates an array of numbers of type double (in practice, there may be other 
members of the class as well). T o allow flexibility for different size arrays, the class 
contains a pointer to the array instead of directly containing the array itself. The 
constructor of the class, whose code is shown below, allocates an array of a specified size, 
then sets all the entries of the array to a given value. The class has member functions for 
printing the array and for setting the entries of the array to a given (possibly different ) 
value. The class's destructor uses the delete [] statement to deallocate the array (see 
Chapter 10) but is currently commented out to avoid problems caused by the default 
copy constr uctor. We shall shortly point out the specific nature of these prob lems. 
Program 11-7 creates an object of the class, creates and initializes a second object with 
the data of the first, and then changes the array in the second object. As shown by the 
output of the program, changing the second object's data changes the data in the first 
object . In many cases, this is undesirable and leads to bugs. 

724 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11 -7 
Contents of NumberArray . h 
1 #include 
<iostream> 
2 using namespace std ; 
3 
4 class 
NumberArray 
5 { 
6 private: 
7 
double *aPtr; 
8 
int arrayS i ze; 
9 public: 
10 
NumberArray (int 
si ze, double value); 
11 
// -NumberArray(){ 
i f (a rraySize 
> 0) delete 
[ ] aPtr;} 
12 
// Commented out to avo i d problems wi th the 
13 
// default 
copy constructor 
14 
voi d print() 
const ; 
15 
voi d setValue(double 
value); 
16 } ; 
Contents of Number Array . cpp 
1 #include 
<iostream> 
2 #include 
"NumberArray.h" 
3 using namespace std ; 
4 
5 //********************************************* 
6 //Constructor 
allocates 
an array of the 
7 //given 
si ze and sets 
all 
i ts entries 
to the 
8 //given 
value. 
* 
* 
* 
9 //********************************************* 
NumberArray::NumberArray(int 
10 
11 
12 
13 
14 
15 } 
size , double value) 
{ 
16 
arrayS i ze = size; 
aPtr = new double[arraySize]; 
setValue(value)
; 
17 //******************************************************* 
18 //S ets all 
the entries 
of the array 
to the same value . 
* 
19 //******************************************************* 
20 void NumberArray: :setValue(double 
value) 
21 { 
22 
for( i nt i ndex= 
O; i ndex< 
arraySize; 
i ndex ++) 
23 
aPtr[index] 
= value; 
24
} 
25 
26 //*************************************** 
27 //P rints 
all 
the entries 
of the array. 
* 
28 //*************************************** 
29 void NumberArray: :pr i nt() 
30 { 
31 
for( i nt i ndex= 
O; i ndex< 
arraySize; 
i ndex ++) 
32 
cout << aPtr[index
] <<" 
"· 
33
} 
(program continues) 

Program 11 -7 
(continued) 
Contents of Pr1 1-7. cpp 
1 II Thi s program demonstrates 
the deficiencies 
of 
2 II the default 
copy constructor
. 
3 #inc l ude <iostream> 
4 #inc l ude <iomanip> 
5 #inc l ude "NumberArray .h" 
6 using namespace std ; 
7 
8 int main () 
9 { 
10 
II Create 
an obj ect 
11 
NumberArray 
first
(3 , 10 .5); 
12 
13 
II Make a copy of the object 
14 
NumberArray 
second
= first
; 
15 
16 
II Di splay the values 
of the two objects 
17 
cout << setprec
i si on (2) <<fixed<< 
showpoint ; 
18 
cout << "Val ue stored 
in first 
object 
i s "; 
19 
first
.pr i nt (); 
20 
cout << endl << "Val ue stored 
i n second object 
i s "· 
21 
second .print
(); 
22 
cout << endl << "Only the value i n second object" 
23 
<< "wi l l be changed . " 
<< endl ; 
24 
25 
II Now change t he 
val ue st ored i n t he second object 
26 
second .se t Valu e (20 .5); 
27 
28 
II Di splay t he val ues stored 
i n the two objects 
29 
cout << "Val ue stored 
i n first 
object 
i s "; 
30 
first
.pr i nt (); 
31 
cout << endl << "Val ue st ored i n second object 
i s "· 
32 
second .pri nt (); 
33 
34 
ret urn O; 
35 } 
Program Output 
Value stored 
in first 
object 
i s 10.50 
10.50 
10.50 
Value stored 
in second obj ect is 10.50 
10.50 
10.50 
Only the value 
in second obj ect will 
be changed. 
Value stored 
in first 
object 
i s 20.50 
20.50 
20.50 
Value stored 
in second obj ect is 20.50 
20.50 
20.50 
11.5 Copy Constructors 
725 
The reason changing the data in one object changes the other object is that the memberwise 
assignment performed by the default copy constructor copies the value of the pointer in 
the first object to the pointer in the second object, leaving both pointers pointing to the 
same data. Thus, when one of the objects changes its data through its pointer, it affects 
the other object as well. Th is is illustrated in Figure 11-3. 

726 
Chapte r 11 
Figure 11-3 
More about Classes and Object-Orien ted Programming 
first 
1----, .... 
1 
10.5 
'-------' 
aPtr 
10.5 
10.5 
second 
aPtr 
The fact that the two pointers point to the same memory location will also cause problems 
when the destructors for the two objects try to deallocate the same memory (that is why 
the destructor code in the above class is commented out). In general, classes with pointer 
members will not behave correctly under the default copy constructor provided by the 
compi ler. They must be provided with a copy constr uctor written by the programmer. 
Programmer-Defined 
Copy Constructors 
A programmer can define a copy constructor for a class. A programmer-defined copy 
constructor must have a single parameter that is a reference to the same class. Thu s, in 
the case of the previous example, the prototype for the copy constr uctor would be 
NumberArray: :NumberArray (const NumberArray &obj) 
The copy constructor avoids the problems of the default copy constr uctor by allocating 
separate memory for the pointer of the new object before doing the copy : 
NumberArray: :NumberArray (const NumberArray &obj) 
{ 
} 
arraySize 
= obj .a rraySize
; 
aPtr = new doubl e[arraySize
] ; 
for(int 
index
= O; index< 
arrayS i ze ; index++ ) 
aPtr[index] 
= obj.aPtr[index
] ; 
The copy constructor should not change the object being copied, so it declares its argument 
as const . Program 11-8 demonstrates the use of the NumberArray class modified to have a 
copy constructor. 
Th e class declaration is in the NumberArray2 . h file, with the 
implementations of its member functions being given in NumberArray2. cpp. 
Program 11 -8 
Contents of NumberArray2 . h 
1 #include 
<iostream> 
2 using namespace std ; 
3 
4 class 
NumberArray 
5 { 
6 private: 
7 
doubl e *aPtr ; 
8 
int arraySize
; 
9 public: 
10 
NumberArray(const 
NumberArray &); 
11 
NumberArray(int 
size, 
doubl e value); 
(program continues) 

Program 11 -8 
(continued) 
12 
13 
14 
15 } ; 
-NumberArray() 
{ if (arraySize 
void pr i nt() 
const; 
> 0) delete[] 
aPtr; 
} 
void setValue(double 
value); 
Contents of NumberArray2. cpp 
1 #include 
<iostream> 
2 #include 
"NumberArray2.h" 
3 using namespace std ; 
4 
5 //***************************************** 
6 //C opy constructor 
allocates 
a new 
7 //a rray and copies 
into i t the entr i es 
8 //of 
the array 
in the other 
object. 
* 
* 
* 
9 //***************************************** 
10 NumberArray::NumberArray(const 
NumberArray &obj) 
11 { 
12 
arrayS i ze = obj.arraySize; 
13 
aPtr = new double(arraySize]; 
14 
for(int 
index
= O; index< 
arraySize; 
index ++) 
15 
aPtr[index] 
= obj.aPtr[index
] ; 
16 } 
17 
//********************************************* 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28
} 
//C onstructor 
allocates 
an array of the 
// given si ze and sets 
all 
i ts entries 
to the 
// given value. 
* 
* 
* 
//********************************************* 
NumberArray: :NumberArray(int 
size , double value) 
{ 
29 
arrayS i ze = size; 
aPtr = new double(arraySize]; 
setValue(value
); 
30 //****************************************************** 
31 //S ets all 
the entries 
of the array 
to the same value . * 
32 //****************************************************** 
33 void NumberArray: :setValue(double 
value) 
34 { 
35 
for( i nt i ndex= 
O; i ndex< 
arraySize; 
i ndex ++) 
36 
aPtr[index] 
= value; 
37
} 
38 
39 //************************************** 
40 //P rints 
all 
the entries 
of the array. 
* 
41 //************************************** 
42 void NumberArray: :pr i nt() 
const 
43 { 
44 
45 
46 } 
for( i nt i ndex= 
O; i ndex 
cout << aPtr[index] 
<<" 
< arraySize; 
i ndex ++) 
... 
11.5 Copy Constructo rs 
72 7 
(program continues) 

728 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11-8 
(continued) 
Contents of Pr1 1 -8. cpp 
1 // This program demonstrates 
the use of copy constructors
. 
2 #include 
<iostream> 
3 #include 
<iomanip> 
4 #include 
"NumberArray2.h" 
5 
6 using namespace std; 
7 
8 int main() 
9 { 
10 
NumberArray first(3, 
10.5 ); 
11 
12 
//Make second a copy of first 
object 
13 
NumberArray second= 
first; 
14 
15 
// Di splay the values 
of the two objects 
16 
cout << setprec
i si on(2) <<fixed<< 
showpoint; 
17 
cout << "Value stored 
in first 
object 
i s"· 
18 
first.print(); 
19 
cout << "\nValue 
stored 
in second object 
is"· 
20 
second.print(); 
21 
cout << "\nOnly the value in second object 
wi ll " 
22 
<< "be changed . \n"; 
23 
24 
//Now change value stored 
in second object 
25 
second.setValue(20.5); 
26 
27 
II Display 
the values 
stored 
in the two objects 
28 
cout << "Value stored 
in first 
object 
is
"; 
29 
first.print(); 
30 
cout << endl << "Value stored 
i n second object 
i s"· 
31 
second.print(); 
32 
return 
O; 
33 ) 
Program Output 
Value stored 
in first 
object 
is 10.50 
10.50 
10.50 
Value stored 
in second object 
is 10.50 
10.50 
10.50 
Only the value in second object 
will 
be changed. 
Value stored 
in first 
object 
is 10.50 
10.50 
10.50 
Value stored 
in second object 
is 20.50 
20.50 
20.50 
<) NOTE: 
A copy constructor must have a single parameter that is a reference to the 
same class . Forgetting the & that identifies reference parameters 
will result in 
compiler errors. In addition, the parameter should be a const reference because the 
copy constuctor should not modify the object being cop ied . 

0 
11.5 Copy Constructo rs 
729 
The copy constructor is also automatically called by the compiler to create a copy of an 
object whenever an object is being passed by value in a function call. It is for this 
reason that the parameter to the copy constr uctor must be passed by reference; if it was 
passed by value when the constr uctor was called, then the constructor 
wo uld 
immediately have to be called again to create the copy to be passed by value, leading to 
an endless chain of calls to the constr uctor. 
Invocation of Copy Constructors 
Copy constructors are automatically called by the system whenever an object is being 
created by initializing it with anothe r object of the same class. For example, the copy 
constr uctor for the Rectang l e class is called for each of the following initialization 
statements : 
Rectangle box(5, 10); 
Rectangle b = box; 
II Initia
l iz at io n statement 
Rectangle b1(box); 
II Initia
l iz at io n statement 
Copy constr uctors are also automatically called when a function call receives a value 
parameter of the class type. For example, for a function of the form 
void fun(Rectangle 
rect) 
{ 
} 
a call such as 
fun (box}; 
will cause the Rectangle copy constructor to be called. Finally, copy constructors are 
automatically called whenever a function returns an object of the class by value. Thu s, 
in the function 
Rectangle makeRectangle(} 
{ 
} 
Rectangle rect(12, 
3}; 
return 
rect ; 
the copy constr ucto r will be called when the return statement is executed . This is 
because the return statement must create a temporary, nonlocal copy of the object that 
will be availab le to the caller after the function returns. To summarize, a class copy 
constructor is called when 
• A variable is being initialized from an object of the same class 
• A function is called with a value parameter of the class 
• A function is returning a value that is an object of the class 
NOTE: 
Copy const ructors are not called when a parameter of the class is passed 
by reference or through a pointer, nor are they called when a function returns a 
reference or pointer to an object of the class. 

730 
Chapte r 11 
More about Classes and Object -Oriented Programming 
~ 
Checkpoint 
11.6 
a 
Video Note 
Operator 
Overloading 
11.8 
Briefly describe what is meant by memberwise assignment. 
11.9 
Describe two scenarios in which memberwise assignment occurs. 
11.10 Describe a situation in which memberwise assignment should not be used. 
11.11 When is a copy constructor called? 
11.12 How does the compiler know that a member function is a copy constructor? 
11.13 What action is performed by a class's default copy constructor? 
Operator Overloading 
CONCEPT: 
C++ allows you to redefine how standard operators work when used 
with class objects. 
Overloading the = Operator 
As we have seen, copy constructors are designed to solve problems that arise when an 
object containing a pointer is initialized with the data of another object of the same 
class using memberwise assignment. Similar problems arise in object assignment . For 
example, with the NumberArray class of the previous section, we may have a program 
that has defined two objects of that class: 
NumberArray first(3, 
10.5); 
NumberArray second(5, 
20 .5); 
Now, because C++ allows the assignment operator to be used with class objects, we 
may execute the statement 
first= 
second; 
if we want to set the first object to exactly the same value as the second. At this point, 
C++ will once again perform a memberwise copy from the second to the first object, 
leaving pointers in both objects pointing to the same memory . 
Because the default object assignment encounters the same problem as the default copy 
constructor, we might think that a programmer -defined copy constructor can be used 
to solve the prob lem caused by the default assignment, but this is not so. Copy 
constructors only come into play when an object is being initialized at creation time. In 
particular, copy constructors are not called in an assignment. To see the difference 
between initialization and assignment, suppose that the object firs t has already been 
created . Then the statement 
NumberArray second= 
first; 
II copy constructor 
called 

Figure 11-4 
11.6 Operator Overloading 
731 
which creates second and initial izes it with the value of first
, is an initialization 
and causes the copy constr ucto r to be called to perform the initialization. However, 
the statement 
second= 
first; 
// copy constructo
r not called 
which assumes that both objects have previously been created, is an assignment, and 
therefore no constructor is invoked . 
To address the problems that result from memberwi se assignment of objects, we need 
to modify the behavior of the assignment operator so that it does something other than 
memberwise assignment when it is applied to objects of classes that have pointer 
members. In effect we are supplying a different version of the assignment operator to 
be used for objects of that class. In so doing , we say that we are overloading the 
assignment operator. 
One way to overload the assignment operator for a given class is to define an operator 
function called operator= 
as a member function of the class . To do this for the 
Number Array class, we would write the class declaration as follows: 
class 
NumberArray 
{ 
private: 
double *aPtr; 
int arraySize
; 
publ ic : 
} ; 
void operator =(const NumberArray &right ); 
// Overloaded operator 
NumberArray(const NumberArray &); 
NumberArray(i nt size, 
double value); 
-NumberArray() 
{ if (arrayS ize > 0) delete 
[ ] aPtr ; } 
void print () const; 
void setValue(double 
value); 
Let's take a look at the function header , or prototype, before we look at how the 
operator function itself is implemented. We break the header down into its main parts, 
as shown in Figure 11-4. 
Return 
Function 
Parameter for object 
type 
name 
on the right side of operator 
! 
! 
! 
NumberArray& 
operator=(const 
NumberArray 
&right) 
Th e name of the function is operator=. 
Since the operator function is an instance 
member of a class, it can only be called through an object of the class. Th e object of the 
class through which it is called is cons idered the left operand of the assignment 

732 
Chapter 11 
<) 
More about Classes and Object-Oriented Programming 
operator, while the parameter passed to the function is considered the right operand of 
the assignment operator. To illustrate , let us suppose that two objects, 1 eft and r i ght , 
have been defined in a program: 
NumberArray left(3,
10.5); 
NumberArray rig ht(5, 
20.5); 
To assign the value of right to left , we call the member function operator= through 
the 1 eft object, and pass it the right object as parameter: 
left.o
perator=(right); 
While you can call operator functions this way, the compiler will also let you use the 
more conventiona l notation 
left= 
ri ght ; 
NOTE: 
Parameters to operator functions do not have to be passed by reference , 
nor do they have to be declared const . In this example, we have used a reference 
parameter for efficiency reasons: Reference parameters avo id the overhead of 
copying the object being passed as parameter. The cons t is used to protect the 
parameter from change. 
The Class Assignment 
Operator's Return Value 
Figure 11-4 shows that overloaded = operator returns a reference to NumberArray. This 
is done to be consistent with C++'s built-in assignment operator, which allows cascaded 
assignment statements like 
a= b = c; 
Cascaded assignments work because the built-in assignment operator is implemented so 
that it returns a reference to its left operand after the assignment has been performed. 
Thus, in this statement, the expression b = c causes c to be assigned to b and then 
returns a reference to b. The value from this returned reference is then assigned to a. 
Implementation 
of the Class Assignment Operator 
Let us now consider the implementation of assignment operator. First notice that there 
is no need to do any copying if a statement such as 
X = x; 
is resulting in an object being assigned to itself. (Such assignments can happen in large 
programs in a roundabout way .) We can test for this possibility by checking that the 
address th is of the object on the left side of the assignment is different from the address 
of the object on the right side like this: 
i f(t his != &right) 
{ /* copy the obj ect _*/ } 
The assignment operator function starts by deleting the memory allocated to pointers 
in the object being assigned to. After that , it makes a copy of the other object in much 
the same way as the copy constructor for the class. The last act of the function is to 

11.6 Operator Overloading 
733 
return (by reference) the object *this on the left side of the assignment . Here is the 
code for the function: 
NumberArray& NumberArray: :operator =(const NumberArray &right ) 
{ 
i f (thi s != &right ) 
{ 
i f (a rraySize 
> 0) 
{ 
delete[] 
aPt r; 
} 
arraySize 
= ri ght.arrayS
i ze ; 
aPtr = new double [arraySize
]; 
fo r (in t index = O; index< 
arraySize; 
index ++} 
} 
} 
{ 
aPtr[index] 
= ri ght.aPtr[index]; 
} 
return 
*this; 
Th e assignment operato r discussed in this section is also called copy assignment to 
distinguish it from the move assignment operato r, which we will study later. In general, 
classes that allocate dynam ic memory (or any kind of resource) in a constr uctor should 
always define a destructor, a copy constructor, a move constructor, a copy assignment 
operator, and a move assignment operator. You will learn about both move assignment 
and move constr uctors later in this chapte r. 
The class NumberArray, with modifications to include both a copy constr uctor and an 
overloaded assignment operator, is demonstrated in Program 11-9. 
Program 11 -9 
Contents of overload. h 
1 #include 
<iostream> 
2 using namespace std ; 
3 
4 class 
NumberAr ray 
5 { 
6 private: 
7 
double *aPt r; 
8 
int arraySize; 
9 public: 
10 
// Overloaded operator 
function 
11 
NumberArray& operator=(const 
NumberArray &right ); 
12 
13 
// Constructors 
and other member functions 
14 
NumberArray (const NumberArray &); 
15 
NumberArray (in t size, 
doubl e value); 
16 
-NumberArray() { if (ar raySize > 0) delete 
[ J aPtr; 
} 
17 
void pr i nt() const; 
18 
void setValue(double 
value); 
19 } ; 
(program continues) 

734 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11 -9 
(continued) 
Contents of overload. cpp 
1 #include 
<iostream> 
2 #include 
"overload.h" 
3 using namespace std ; 
4 
5 //*************************************************** 
6 //Th e overloaded 
operator 
function 
for assignment. 
* 
7 //*************************************************** 
8 NumberArray& NumberArray: :operator=(const 
NumberArray &ri ght) 
9 { 
10 
if (this 
!= &ri ght ) 
11 
{ 
12 
if (arraySize 
> O} 
13 
{ 
14 
delete[
] aPtr; 
} 
arraySize 
= right
.arraySize; 
aPtr = new double[arraySize
] ; 
15 
16 
17 
18 
19 
20 
for (i nt index= 
O; i ndex< 
arraySize; 
index++) 
{ 
aPtr[ i ndex ] = right
.aPtr[ i ndex]; 
21 
} 
22 
} 
23 
return 
*this; 
24 } 
25 
26 //********************************************** 
27 //C opy constructor. 
* 
28 //********************************************** 
29 NumberArray: :NumberArray(const 
NumberArray &obj) 
30 { 
31 
arraySize 
= obj .arrayS i ze; 
32 
aPtr = new double[arrayS
i ze] ; 
33 
for(int 
index= 
O; index< 
arrayS i ze; index+ +) 
34 
{ 
35 
aPtr[ i ndex] = obj .aPtr[index]; 
36 
} 
37 } 
38 
39 //********************************************** 
40 //C onstructor. 
* 
41 //********************************************** 
42 NumberArray: :NumberArray(int 
size1 , double value) 
43 { 
44 
arraySize 
= size1 ; 
45 
aPtr = new double[arrayS
i ze] ; 
46 
setValue(value}; 
47 } 
48 
49 //**************************************************** 
50 //S ets the value stored 
i n all 
entr i es of the array. 
* 
51 //**************************************************** 
(program continues) 

Program 11 -9 
(continued) 
52 void NumberArray: :setValue(double 
value) 
53 { 
54 
for(int 
index= 
O; index< 
arrayS i ze; index+ +) 
55 
{ 
56 
aPtr[ i ndex] = value; 
57 
} 
58 } 
59 
60 //*************************************** 
61 //P rint 
out all 
entr i es i n the array. 
* 
62 //*************************************** 
63 void NumberArray: :pr i nt() 
const 
64 { 
65 
for(int 
index= 
O; index< 
arrayS i ze; index+ +) 
66 
67 
{ 
68 
} 
69 } 
cout << aPtr[index
] <<" 
Contents of Pr11 -9. cpp 
". 
1 // Thi s program demonstrates 
overloading 
of 
2 II the assignment 
operator. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 #include 
"overload.h" 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
NumberArray first(3
, 10.5); 
11 
NumberArray second(5, 
20 .5); 
12 
13 
// Di splay the values 
of the two objects 
14 
cout << setprecis
i on(2) <<fixed<< 
showpoint; 
15 
cout << "Fi rst object's 
data is"; 
16 
first.pr
i nt(); 
17 
cout << endl << "Second object
's data i s "· 
18 
second.print
(}; 
19 
20 
II Call the overloaded 
operator 
21 
cout << "\ nNow we wi 11 assign 
the second object 
" 
22 
<< "to the f i rst."<< 
endl ; 
23 
first= 
second; 
24 
25 
II Display 
the new values 
of the two objects 
26 
cout << "Fi rst object's 
data is"; 
27 
first.pr
i nt(); 
28 
cout << endl << "The second object
' s data is"· 
29 
second.print
(}; 
30 
31 
return 
O; 
32 
} 
11.6 Operato r Overloading 
735 
(program continues) 

736 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11 -9 
(continued) 
Program Output 
First 
object's 
data is 10.50 
10.50 
10.50 
Second object's 
data is 20.50 
20.50 
20.50 
20.50 
20.50 
Now we will 
assign the second object 
to the first. 
First 
object's 
data is 20.50 
20.50 
20.50 
20.50 
20.50 
The second object's 
data is 20.50 
20.50 
20.50 
20.50 
20.50 
0 
Overloading 
Other Operators 
C++ allows the programmer to overload other operators besides assignment. There are 
many times when it is natural to overload some of C++'s built-in operators to make 
them work with classes that the programmer has defined. For example, assume that a 
class named Date exists and that objects of the Date class hold the day, month , and 
year in member variables. Suppose the Date class has a member function named add. 
The add member function adds a number of days to the date and adjusts the member 
variables if the date goes to another month or year. For examp le, the following 
statement adds five days to the date stored in the today object: 
today .add(5); 
Although it might be obvious that the statement is adding five days to the date stored 
in today, the use of an operator might be more intuitive. For example, look at the 
following statement: 
today+= 
5; 
This statement uses the standard += operator to add 5 to today. This behavior does not 
happen automatically, however. The+= operator must be overloaded for this action to 
occur. In this section, you will learn to overload many of C++'s operators to perform 
specialized operat ions on class objects. 
NOTE: 
You have already exper ienced the behavior of an overloaded operator. 
The / operator performs two types of division: floating-point and integer. If one of 
the operator's operands is a floating -point type, the result will be a floating-point 
value. If both of the / operator's operands are integers, however, a different behavior 
occurs: The result is an integer, and the fractional part is thrown away . 
Some General Issues of Operator 
Overloading 
Now that you have had an introduction to operator overloading, let's look at some of 
the general issues involved in this programming technique. 
First, you can change an operator's entire meaning , if that's what you wish to do. 
Th ere is nothing to prevent you from chang ing the = symbol from an assignment 
operator to a "display" operator. For instance, the following class does just that: 
class Wei rd 
{ 
pr i vate: 
int value; 

() 
publ ic : 
} ; 
Weird(int 
v) 
{val ue = v; } 
void operator=(const 
Weird &right ) 
{ cout <<right.value<< 
endl ; } 
11.6 Operator Overloading 
737 
Although the operator
= function overloads the assignment operator, the function 
doesn't perform an assignment . All the overloaded operator does is display the contents 
of right . value. Consider the following program segment: 
Weird a(5} , b(10); 
a= 
b ; 
Although the statement a = b looks like an assignment statement, it actually causes the 
contents of b's va 1 ue member to be displayed on the screen: 
10 
Another operator overloading issue is that you cannot change the number of operands 
taken by an operator. Th e = symbol must always be a binary operator. Likewise, ++ 
and -- must always be unary operators . 
The last issue is that although you may overload most of the C++ operators, you cannot 
overload all of them. Table 11-1 shows all of the C++ operators that may be overloaded. 
NOTE: Some of the operators in Table 11-1 are beyond the scope of this book 
and are not covered. 
Table 11-1 Operators That Can Be Overloaded 
+ 
* 
I 
% 
" 
& 
= 
< 
> 
+= 
= 
*= 
I= 
%= 
"= 
&= 
1= 
<< 
>> 
>>= 
<<= 
--
!= 
<= 
>= 
&& 
11 
++ 
-> * 
- > 
[ l 
() 
new 
delete 
The only operato rs that cannot be overloaded are 
?: 
* 
: : sizeof 
Approaches to Operator Overloading 
There are two approaches you can take to overload an operato r: 
1. Make the overloaded operator a member function of the class. This allows the 
operato r function access to private members of the class. It also allows the function 
to use the implicit this pointer parameter to access the calling object. 
2. Make the overloaded member function a separate, stand-alone function . When 
overloaded in this manner, the operator function must be declared a friend of the 
class to have access to the private members of the class. 

738 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
Some operators, such as the stream input and outp ut operators >> and <<, must be 
overloaded as stand -alone functions. Other ope rato rs may be overloaded either as 
member functions or stand -alone functions. Consider a class 
class 
Length 
{ 
pr i vate: 
int len _inches; 
publ i c : 
} ; 
Length(int 
feet , i nt inches) 
{ 
setLength(feet, 
inches); 
} 
Length(int 
i nches) { l en_inches 
= inches; 
} 
i nt getFeet() 
const { return 
len _inches 
/ 12; } 
int getlnches() 
const { ret urn len _ inches 
% 12; } 
voi d setLength
(int feet , int inches} 
{ 
len _inches 
= 12 *feet+ 
i nches; 
} 
designed to represent length measurements. The class internally represents the length of an 
item in inches but allows its clients to specify measurements in feet and inches via a 
set Length (} function. The class also provides member functions get Feet () and get Inches (} 
to allow the feet and inch components of a measurement to be separately retrieved. 
Overloading the Arithmetic and Relational Operators 
Clients of the class must be able to add and subtra ct measurements . In add ition, they 
should be able to compare two measurements to see if they are equa l or if one of them 
is less or greater than the other. We will provide all these capabi lities by overloading 
the operators+,
- ,<, and== as stand -alone functions. We start by adding the following 
declarations to the Length class: 
fr i end Length operator +(Length a, Length b); 
fr i end Length operator - (Length a, Length b); 
fr i end bool operator<(Length 
a, Length b); 
fr i end bool operator==(Length 
a , Length b}; 
T o see how we arrive at these declarations , cons ider the addition and less-than 
operators . Addition needs to take two Length objects a and b as parameters and produce 
a third Length object that is the sum of a and b. Similarly, the less-than operator needs 
to take two Length objects as parameters and return a Boolean value. 
To see how to write the code that implements these functions , consider again the addition 
operator. Given two input parameters a and b, it needs to return a Length object whose 
1 en_ inches member is the sum of the 1 en_ inches members of a and b. This can be done 
by writing 
Length operator+
(Length a , Length b} 
{ 
} 
Length result(a.len
_inches + b.len _ inches); 
return 
result
; 

or more succinctly: 
Length operator+
(Length a , Length b) 
{ 
11.6 Opera to r Overloading 
739 
return 
Length(a.len
_inches + b.len _ inches); 
) 
We can reason in a similar manner to work out the definitions of the operator functions 
- , <, and ==. Here is a complete program showing the class and its overloaded operators 
and illustrating their use. 
Content s of Length. h 
1 #ifndef 
_LENGTH
_H 
2 #define 
_LENGTH
_H 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 class 
Length 
7 { 
8 private
: 
9 
int len _inches; 
10 pub 1 i C : 
11 
Length (i nt feet , int inches) 
12 
{ 
13 
setLength(feet, 
i nches); 
14 
) 
15 
Length (i nt i nches){ 
len _i nches = i nches; 
) 
16 
int getFeet
() const 
{ return 
len _i nches I 12 ; ) 
17 
int getlnches
() const 
{ return 
len _inches 
% 12 ; } 
18 
void setLength(int 
feet, 
int inches) 
19 
{ 
20 
len _inches = 12 *f eet+ 
inches; 
21 
} 
22 
friend 
Length operator+
(Length a, Length b); 
23 
friend 
Length operator
- (Length a, Length b); 
24 
friend 
bool operator< 
(Length a, Length b); 
25 
friend 
bool operator
== (Length a, Length b); 
26 } ; 
27 #endif 
Content s of Length . cpp 
1 #include 
"Length .h" 
2 
3 //************************************* 
4 II Overloaded 
operator+ 
* 
5 //************************************* 
6 Length operator+(Length 
a, Length b) 
7 { 
8 
return 
Length(a.len
_inches 
+ b.len _inches ); 
9 } 
10 
11 //************************************* 
12 II Overloaded 
operator 
-
* 
13 //************************************* 
14 Length operator
- (Length a, Length b) 
15 { 

740 
Chapte r 11 
More about Classes and Object-Oriented Programming 
16 
return 
Length(a.len
_inches 
- b.len _inches); 
17 } 
18 
19 //************************************ 
20 II Overloaded 
operator
== 
• 
21 //************************************ 
22 bool operator
==(Length a, Length b) 
23 { 
24 
return 
a .len _inches 
== b.len _ inches; 
25 } 
26 
27 //************************************ 
28 II Overloaded 
operator< 
• 
29 //************************************ 
30 bool operator<
(Length a, Length b} 
31 { 
32 
return 
a .len _inches 
< b .len _inches; 
33 } 
Program 11 -10 
1 II Thi s program demonstrates 
the Length class's 
overloaded 
2 II +, - , ==, and< 
operators. 
3 #include 
<iostream> 
4 #include 
"Length .h" 
5 using namespace std ; 
6 
7 
8 
9 
10 
int 
{ 
main() 
Length first
(O), 
int f ' i . 
' 
second(O}, 
third(O); 
11 
cout << "Ent er a di stance 
in feet 
and inches: 
"· 
12 
ci n >> f >> i; 
13 
f i rst.setLength(f, 
i); 
14 
cout << "Enter another 
distance 
in feet 
and inches: 
"· 
15 
ci n >> f >> i; 
16 
second .setLength(f, 
i }; 
17 
18 
II Test the
+ and - operators 
19 
third= 
f i rst+ 
second; 
20 
cout <<"first+ 
second="; 
21 
cout << third.getFeet
() <<" 
feet , "; 
22 
cout << third.getlnches
() <<" 
i nches.\n"; 
23 
third= 
f i rst - second; 
24 
cout << "first 
- second="· 
25 
cout << third.getFeet
() <<" 
feet , "; 
26 
cout << third.getlnches
() <<" 
i nches.\n"; 
27 
28 
II Test the relational 
operators 
29 
cout <<"first== 
second="; 
30 
if (f i rst=
= second} cout << "true"; 
else cout << "false"; 
31 
cout << "\n"; 
(program continues) 

11.6 Operato r Overloading 
741 
Program 11 -10 
(continued) 
32 
cout <<"first< 
second="; 
33 
if 
(f i rst< 
second) 
cout << "true"; 
else 
cout << "false"; 
34 
cout << "\n"; 
35 
36 
return 
O; 
37
} 
Program Output with Example Input Shown in Bold 
Enter a distance 
in feet 
and inches: 
65[Enter] 
Enter another 
di stance 
in feet 
and inches: 
3 1 O[Enter] 
first+ 
second= 
10 feet, 
3 inches. 
first 
- second= 
2 feet, 
7 inches. 
first== 
second= 
false 
first< 
second= 
false 
Choosing Between Stand-Alone 
and 
Member-Function 
Operators 
Given the stand -alone overloads we have written, the code 
Length a(4 , 2} , b(1, 8}, c (O}; 
C =a+ 
b; 
is interpreted by the comp iler as being 
Length a(4 , 2} , b(1, 8}, c (O}; 
c = operator+
(a, b); 
The compiler allows the programmer 
to use the friendly infix notation. 
Internally , 
however, it sees the operator as just an ordinary function whose name is operator
+. 
Thi s has an impl ication that is not immed iately obvious . The statement 
C = 2 + a; 
is equivalent to 
c = operator+
(2 , b); 
Both of these statements compi le and execute correctly because the convert constructor 
of the Length class is ab le to create a Length object out of the integer parameter 2. You 
will learn about convert constructors in Section 11-10. 
We could just as easily have overloaded the arithmetic and relat ional operators as 
member functions . Here is how to do so for the addition operator. First , modify the 
in-class declaration to make the operator a member function: 
class 
Length 
{ 
pr i vate: 
i nt len _inches; 
publ i c: 
} ; 
// Modified declaration 
of operator
+ 
Length operator+
(Length b); 
// Rest of class 
not shown 

742 
Chapte r 11 
More about Classes and Object -Oriented Programming 
Notice that the operator is now declared as taking a single operator of type Length. 
This is because as a member function , the operator is automatically passed a Length 
object through the implicit parameter t his. When we write 
Length a(4 , 2) , b(1, 8), c(O); 
C =a+ 
b; 
The compiler sees this as 
Length a(4 , 2) , b(1, 8), 
c(O); 
c = a .opera t or+(b); 
When you write a + b, the left operand of the overloaded + operator becomes the 
object through which the member function is called, and the right operand becomes the 
explicit parameter. With these changes, the body of the operator is written as follows: 
Length Lengt h: :opera t or+(Lengt h b) 
{ 
return 
Length(t his - >len_inches + b.len _i nches); 
) 
To sum up, the addition operator (as well as other arithmetic and relational operators) 
can be overloaded equally well as member functions or as stand -alone functions . It is 
generally better to overload binary operators that take parameters of the same type as 
stand -alone funct ions . This is because, unlike stand -alone operator overloading, 
member -function overload ing introduces an artificial distinction between the two 
parameters by making the left parameter implicit. This allows convert constructors to 
apply to the right parameter but not to the left, creating situations where changing the 
order of parameters causes a compiler error in an otherwise correct program: 
Length a(4 , 
C =a+ 
2; 
C = 2 + a; 
2) , c(O); 
II Compi les, 
equivalent 
to c = a.opera t or+( 2) 
II Does not compile: equi valent 
to c = 2.operator+(a); 
Overloading the Prefix ++ Operator 
We want to overload the prefix operator for the Lengt h class so that the expression ++b 
increments the object b by adding 1 inch to its length and returns the resulting object. 
We overload this operator as a member function. This makes its single parameter 
implicit, so the overloaded operator needs no parameters . Here is the port ion of the 
Lengt h class that shows the operator declarat ion: 
class 
Length 
{ 
pri vat e: 
i nt len _inc hes; 
publ i c: 
II Declarat i on of prefix++ 
Length operator+ +(); 
II Rest of class 
not shown 
) ; 
Here is the implementat ion of the operator - it increases the number of inches by 1 and 
returns the modified object: 

Length Lengt h: :opera t or++() 
{ 
) 
len _inches ++; 
re t ur n *t his; 
11.6 Operator Overloading 
743 
Given th is overload, 
the user -friendly notation 
++b is equ ivalent to the call 
b. operator++ () . Either notation may be used in your program . 
Overloading the Postfix++ Operator 
The postfix increment operator b++ also increments the length of b but differs from the 
prefix version in that it return s the value that the object had prior to being incremented. 
Overloading the postfix operator is only slightly different from overload ing the prefix 
version . Here is the function that overloads the postfix operator for the Length class: 
Length Lengt h: :opera t or++(in t ) 
{ 
) 
Length t emp= *thi s; 
len _i nches ++; 
return 
t emp; 
The first difference you will notice is that the function has a dummy parameter of type 
i nt that is never used in the body of the function . This is a convention that tells the 
comp iler that the increment operator is being overloaded in postfix mode . The second 
difference is the use of a temporary local variab le t emp to capture the value of the 
object before it is incremented . This value is saved and is later returned by the function. 
Overloading the Stream Insertion and 
Extraction Operators 
Overloading the stream insertion operator << is convenient because it allows values of 
objects to be converted into text and output to cout , to a file object, or to any object of 
a class that derives from os t ream. In the presence of appropriate overloads, the 
statements 
Length b(4 , 8) , c(2, 
5); 
cout << b; 
cout << b + c; 
appear to the compiler as 
Length b(4 , 8) , c( 2, 5); 
opera t or<<(cout, 
b); 
opera t or(cout, 
b + c); 
This equivalence has the following implications: 
1. The overloaded operator<< takes two parameters, the first of which is an ostrea m 
object and the second of which is an object of the class for which the operator 
is being overloaded . For the Length 
class, the prototype 
would be 
opera t or<<(ostream &strm, Length a) . 

744 
Chapte r 11 
More about Classes and Object -Oriented Programming 
2. To allow expressions (such as b + c) in the second parameter, the second parameter 
should be passed by value. The first parameter shou ld be passed by reference 
because ost ream parameters shou ld never be passed by value . 
In addit ion, the stream insertion operator should return its stream parameter so that 
several output expressions can be chained together, as in 
Length b(4, 
8), c(2, 
5); 
cout << b <<" 
"<< 
b + c; 
Putting all of this together, we see that the stream insertion operator should be written as 
ostream &operator<<(os t ream& out, 
Length a) 
{ 
) 
out<< 
a.getFeet() 
<<"feet,"<< 
a.getl
nches() 
<<" 
i nches"; 
return 
out ; 
Overloading the stream output operator is useful because it allows for the various 
fields of a complex class to be labeled during output . 
Overloading the stream input operator is similar, except that the class parameter 
signifying the object to be read into must be passed by reference . Thus, the header for 
the stream input operator looks like this: 
i stream &operator>>(is
t ream &in , Lengt h &a); 
The full implementation 
of this function can be found in lines 3- 18 of the following 
listing of Length 1 . cpp . At first glance, the function appears to be useful in that it 
relieves the programmer of the necessity of issuing prompts for the different parts 
of the object when the user is enter ing data at the screen and keyboard. Not ice, 
however, that the prompts become an irritating distraction if the operator is being 
used to read Length objects from a non -keyboard source such as a file or network 
connection . 
Contents of Lengt h1 . h 
1 #ifndef 
_LENGTH
1_H 
2 #define 
_LENGTH
1_H 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 class 
Lengt h 
7 { 
8 priva t e: 
9 
int len _inches; 
10 pub 1 i C: 
11 
Lengt h (i nt fee t , i nt inches) 
12 
{ 
13 
setLe ngth(feet, 
i nches); 
14 
) 
15 
Lengt h (i nt i nches){ len _i nches = i nches; 
) 
16 
int getFee t () const { return 
len _i nches / 12; ) 
17 
int getlnches() 
const { return 
le n_i nches % 12; ) 
18 
void setLeng t h(int 
feet, 
in t inches) 

11.6 Operator Overloading 
745 
19 
{ 
20 
len _inches = 12 *feet+ 
inches; 
21 
} 
22 
II Overloaded 
arithmetic 
and relational 
operators 
23 
friend 
Length operator+
(Length a, Length b); 
24 
friend 
Length operator-
(Length a, Length b); 
25 
friend 
bool operator<(Length 
a , Length b) ; 
26 
friend 
bool operator==(Length 
a, Length b); 
27 
Length operator+
+(); 
28 
Length operator+
+(i nt); 
29 
30 
II Overloaded 
stream input and output 
operators 
31 
friend 
ostream &operator<<(ostream 
&out , Length a); 
32 
friend 
is tream &operator>>(istream 
&in, Length &a) ; 
33 } ; 
34 #endif 
Contents of Length1 . cpp 
1 #include 
"Length1.h" 
2 
3 //********************************************** 
4 II Overloaded 
stream extraction 
operator>> 
* 
5 //********************************************** 
6 is tream &operator>>(istream 
&in, Length &a) 
7 { 
8 
II Prompt for and read the object 
data 
9 
int feet, 
inches; 
10 
cout << "Ent er feet: 
"; 
11 
in>> 
feet; 
12 
cout << "Enter 
inches: 
"· 
13 
in>> 
inches; 
14 
15 
II Modify the object 
a with the data and return 
16 
a .setLength(feet, 
i nches); 
17 
return 
i n; 
18 } 
19 
20 //********************************************* 
21 II Overloaded 
stream insertion 
operator<< 
* 
22 //********************************************* 
23 ostream &operator<<(ostream& 
out , Length a) 
24 { 
25 
out<< 
a .getFeet() 
<<" 
feet , "<< a .getlnches() 
<<" 
i nches"; 
26 
return 
out; 
27 } 
28 
29 //*********************************** 
30 II Overloaded 
prefix++ 
operator 
* 
31 //*********************************** 
32 Length Length::operator++() 
33 { 
34 
len _inches 
++; 
35 
return 
*this; 
36 } 

746 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
37 
38 //*********************************** 
39 II Overloaded 
postfix++ 
operator 
* 
40 //*********************************** 
41 Length Length: :operator++
(i nt) 
42 { 
43 
Length temp= 
*this; 
44 
l en_inches 
++; 
45 
return 
temp; 
46 } 
47 
48 //************************************* 
49 II Overloaded 
operator 
-
* 
50 //************************************* 
51 Length operator+(Length 
a, Length b) 
52 { 
53 
return 
Length(a.len
_i nches + b.len _i nches); 
54 } 
55 
56 //************************************* 
57 II Overloaded 
operator 
-
* 
58 //************************************* 
59 Length operator
- (Length a, Length b) 
60 { 
61 
62
} 
63 
return 
Length(a.len
_i nches - b.len _i nches); 
64 //************************************ 
65 II Overloaded 
operator
== 
* 
66 //************************************ 
67 bool operator
==(Length a, Length b) 
68 { 
69 
return 
a .len _inches 
== b.len _ inches; 
70
} 
71 
72 //************************************ 
73 II Overloaded 
operator< 
* 
74 //************************************ 
75 bool operator<
(Length a, Length b) 
76 { 
77 
return 
a .len _inches 
< b .len _inches; 
78
} 
Program 11 -11 
1 II Thi s program demonstrates 
the Length class
' s overloaded 
2 II prefix
++, postfix+
+, and stream operators
. 
3 #include 
<iostream> 
4 #include 
"Length1.h" 
5 using namespace std ; 
6 
7 int main() 
(program continues) 

Program 11 -11 
(continued) 
8 { 
9 
Length f i rst (O), second(1 , 9) , c(O ) ; 
10 
11.6 Operato r Overloading 
747 
11 
cout << "Demonstrat i ng prefix++ 
operator 
and output 
operator.\n"; 
12 
for (int 
count
= O; count< 
4 ; count+ +) 
13 
{ 
14 
15 
16 
} 
first
= ++second; 
cout << "First: 
" <<first<< 
" 
Second: 
"<<second<< 
". \ n"; 
17 
cout << "\ nDemonstrat i ng postf i x++ operator 
and output 
operator.
\ n"; 
18 
for (int 
count
= O; count< 
4 ; count+ +) 
19 
{ 
20 
first
= second++; 
21 
22 
23 
} 
cout << "First: 
" <<first<< 
" 
Second: 
"<<second<< 
". \ n"; 
24 
cout << "\ nDemonstrat i ng input and output 
operators.
\ n"; 
25 
cin >> c ; 
26 
27 
28 } 
cout << "You entered"<< 
c << 
return 
O; 
" " << endl ; 
Program Output with Example Input Shown in Bold 
Demonstrating 
prefix++ 
operator 
and output 
operator. 
First: 
1 feet, 
10 inches. 
Second: 
1 feet , 10 inches. 
First: 
1 feet, 
11 inches. 
Second: 
1 feet , 11 inches. 
First: 
2 feet, 
0 inches. 
Second: 2 feet , 0 inches. 
First: 
2 feet, 
1 inches. 
Second: 2 feet , 1 inches. 
Demonstrating 
postfix 
++ operator 
and output 
operator. 
First: 
2 feet, 
1 inches. 
Second: 2 feet , 
First: 
2 feet, 
2 inches. 
Second: 2 feet , 
First: 
2 feet, 
3 inches. 
Second: 2 feet , 
First: 
2 feet, 
4 inches. 
Second: 2 feet , 
Demonstrating 
input and output 
operators. 
Enter feet: 
3[Enter] 
Enter inches: 
4[Enter] 
You entered 
3 feet , 4 inches. 
2 inches. 
3 inches. 
4 inches. 
5 inches. 
Overloading the [] Operator 
Any C++ class can overload the array indexing operator [ ) to make its objects have 
arra y-like behavior. In fact, the vector and string library classes override [ ), enabling 
their objects to be indexed like arrays. For example, the following code 
string 
str 
= "mad"; 
cout << str[O] 
<<" 
"· 
str[O] 
= 'b' ; 
cout << str[O] 
<<" 
"· 
cout << str; 

748 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
prints the output 
m b bad 
An overloaded [ ] operator must take a single argument of any type and can return a 
value of any type: 
ReturnType & operator
[ ] (input Type T) 
To be consistent with how the built-in operator [ ] works, the overloaded operator 
should return its result by reference so that the result can be assigned to. 
To give a simple examp le, supp ose we want to write a Name class to represent the full 
name of a person. For such a name object, we want name [ 1] to be the first name and 
name[2] to be the last name. Furthermore , we want an attempt to index such an object 
with any integer other than 1 and 2 to terminate the program with an error message. 
The Name class is shown below. 
Contents of Name. h 
1 #include 
<str i ng> 
2 #include 
<iostream> 
3 #include 
<cstdl i b> 
4 
5 using namespace std ; 
6 class 
Name 
7 { 
8 
str i ng first_name
; 
9 
str i ng last_name ; 
10 
void subError() 
11 
{ 
12 
cout << "Index must be 1 or 2\n" 
13 
exit (1); 
14 
} 
15 pub 1 i C : 
16 
str i ng &operator[ 
] (i nt i ndex} 
17 
{ 
18 
switch( i ndex} 
19 
{ 
20 
case 1: return 
f ir st _name; break ; 
21 
case 2: ret urn last_name ; break; 
22 
default: 
subError(); 
23 
} 
24 
} 
25 } ; 
Notice that the operator [ ] function takes an int parameter and returns a reference 
to a string variable . If name is an object of this class and k is an intege r, the call 
name. operator [ ] (k) will be equ ivalent to name [kl . Basically, name [ 1] will return a 
reference to the member variable fi rst_name , and name [2] will return a reference to 
1 ast _name. Use of this class is demonstrated in Program 11-12. 

11.6 Operator Overloading 
749 
Program 11 -12 
1 II Thi s program demonstrates 
the use of the [ ] operator. 
2 #include 
"name.h" 
3 int main() 
4 { 
5 
Name name; 
6 
7 
II Set first 
name and last 
name 
8 
name[1] = "J oseph "; 
9 
name[2] = "Puf f "; 
10 
11 
II Access first 
name and last 
name 
12 
cout << name[1 ] <<" 
"<< name[2] <<" aka Joe Blow\n"; 
13 
14 
return 
O; 
15 } 
Program Output 
Joseph Puff aka Joe Blow 
The type of the input parameter to the [ ] operato r is not limited to int . To illustrate, let 
us create an object that can translate English words that describe numbers in the range 
0 .. 10 to corresponding integers . If we had such an object, say trans , then trans [·one·] 
would have the integer value 1, trans ["seven" ] would have the value 7, and so on. 
The main idea is to have a vector 
vector<string> 
numerals 
{ 
} ; 
"zero", 
"one ", 
"two" 1 
"thr ee" , "four " 1 
"f i ve", 
"s i x" 1 
"s even" , "eight", 
"ni ne" , "t en" 
that stores each numer ical word at the corresponding integer position in the vector. For 
example, "zero" is stored at O and "seven" is stored at 7. We then write the overloaded 
operator 
int operator[ 
](str
ing num_str) 
so that when passed a string parameter, it returns the position of its parameter in the 
vector. We will adopt the convent ion that the function returns - 1 for a string that is 
not found in the vector. Here we have departed from the convention that the operator 
[ ] return a reference to a memory location that can be assigned to. Th e class Trans 
that implements this operator is demonstrated in Program 11-13. 
Content s of Trans . h 
1 #include 
<str i ng> 
2 #include 
<vector> 
3 using namespace std ; 
4 class 
Trans 
5 { 
6 
vector<string> 
numerals 

750 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
7 
{ 
8 
"zero ", 
"one" 1 
"t wo", 
"thr ee ", 
"four", 
"five
" 1 
9 
"six", 
"seven ", 
"eight
", 
"ni ne", 
"t en " 
10 
} ; 
11 public: 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
int operator
[ ] (s tring 
num_str) 
{ 
for (i nt k = 0; k < numerals .size(); 
{ 
if (numera l s[k ] == num_str) 
{ 
return 
k; 
} 
} 
return 
-1 ; 
} 
23 } ; 
Program 11 -13 
1 II Thi s program demonstrates 
the array subscript 
[] 
2 II operator 
for the Trans class . 
3 #include 
<cstdlib> 
4 #include 
<iostream> 
5 #include 
"trans.h" 
6 using namespace std ; 
7 
8 int main( i nt argc, char** argv) 
9 { 
10 
Trans trans ; 
11 
cout << "s even ·" << trans[
"seven"] << endl ; 
12 
cout << "thr ee ·" << trans[
"t hree" ] << endl ; 
13 
14 
return 
O; 
15 } 
Program Output 
seven :7 
three 
:3 
~ 
Checkpoint 
k++) 
11.14 Assume there is a class named Pet. Write the prototype for a member function 
of Pet that overloads the = operator. 
11.15 Assume that dog and cat are instances of the Pet class, which has overloaded 
the = operator. Rewrite the following statement so it appears in function call 
notation instead of operato r notation: 
dog = cat; 
11.16 What is the disadvantage of an overloaded= operator returning voi d? 

11.7 Rvalue References and Move Operations 
751 
11.17 Describe the purpose of the th i s pointer. 
11.18 The this pointer is automat ically passed to what type of functions? 
11.19 Assume there is a class named Animal, which overloads the = and + operators. 
In the following statement, assume cat, tiger, and wi l dcat are all instances of 
the Animal class: 
wildc at= 
cat+ 
tiger; 
Of the three objects, wildcat, cat, and tiger, which is calling the operator + 
function? Which object is passed as an argument into the function? 
11.20 What does the use of a dummy parameter in a unary operator function indicate 
to the compiler? 
11.21 Describe the values that should be returned from functions that overload 
relational operators . 
11.22 What is the advantage of overloading the << and >> operators? 
11.23 What type of object should an overloaded << operator function return? 
11.24 What type of object should an overloaded >> operator function return? 
11.25 If an overloaded << or >> operator accesses a private member of a class, what 
must be done in that class's declaration? 
11.26 Assume the class NumL i st has overloaded the [] operator. In the express ion 
below, list 1 is an instance of the NumL 
i st class: 
list1 (25] 
Rewrite this expression to explicitly call the function that overloads the [) operato r. 
11.27 When overloading a binary operato r such as + or - as an instance member function 
of a class, what object is passed into the operato r function's parameter? 
11.28 Explain why overloaded prefix and postfix ++ and -- operator functions should 
return a value. 
11.29 How does C++ tell the difference between an overloaded prefix and postfix ++ 
or -- operato r function? 
11.30 Overload the function call operator 
() (i nt i , int j ) for the Trans class of 
Program 11-13 to return the string concatenation of all vector entries in positions 
i through j . 
Rvalue References and Move Operations 
CONCEPT: 
An Rvalue reference denotes a temporary object that would otherwise 
have no name. A move operation transfers resources from a source 
object to a target object. A move operation is approp riate when the 
source object is temporary and is about to be destroyed. 

752 
Chapte r 11 
More about Classes and Object -Oriented Programming 
Lvalues and RValues 
Earlier in this book, you learned that a reference is a variable that refers to the memory 
location of another variable. For example, in the code fragment 
i nt X = 34; 
i nt &lRef = x; 
the identifier 1 Ref is a reference . In a declaration, a reference is indicated by the 
presence of an ampersand (&) between the type and the variable's identifier. This type 
of reference, which you learned about in Chapter 6, is called an /value reference. You 
can think of an /value as a memory location associated with a name that can be used to 
access it from other parts of the program. Here we interpret "name" to mean any 
expression that can be used to access a memory location. Thus, if arr is an array, then 
arr [ 1] and * (arr + 1) are both considered "names" of the same memory location . In 
contrast, an rvalue is a temporary value that cannot be accessed from other parts of the 
program. To illustrate, consider the following program fragment: 
i nt square(in
t a) 
{ 
re t ur n a * a· ' 
} 
i nt mai n(} 
{ 
i nt X : o· ' 
II 
1 
X : 
12; 
II 
2 
cout 
<< x << endl; 
II 
3 
x = square(5); 
II 
4 
cout 
<< X << endl; 
II 5 
re t ur n O; 
} 
In this program, x is an !value. This is because x represents a memory location that is 
accessed in several parts of the program, namely, lines 2, 3, 4, and 5. On the other 
hand, the expression square(5) 
is an rvalue because it represents a temporary memory 
location created by the comp iler to hold the value returned by the function . That 
memory location is accessed only once, on the right-hand side of the assignment in 
line 4. Immediately afterward, it is deallocated and can no longer be accessed. The 
essence of a memory location containing an rvalue is that it lacks a name that can be 
used to access it from another part of the program. 
C++ 11 introduces the concept of an rvalue reference to refer to a temporary object 
that would otherwise have no name. An rvalue reference is declared similarly to an 
!value reference, except with a double ampersand (&&). The code below uses an rvalue 
reference to print the square of 5 two times. 
i nt && r Ref = square(5}; 
cout << rRef << endl; 
cout << rRef << endl; 
Interestingly, declaring an rvalue reference assigns a name to a temporary memory 
location, making it possible to access the location from other parts of the program and 
transforming the temporary location into an !value. 

11.7 Rvalue References and Move Operations 
753 
An rvalue reference cannot be bound to an !value, so the following code will not compile. 
i nt x = 0; 
i nt && rRefX = x; 
After the initialization statement 
i nt && rRef1 = square(5); 
the memory locat ion containing square (5) has a name, namely, rRef1, so rRef1 itself 
becomes an !value. This means that a subsequent initialization statement 
int && rRef2 = rRef1; 
will not compile because the right-hand side rRef1 is no longer an rvalue. The upshot 
of all this is that a temporary object can have at most one !value reference pointing to 
it. If a function has an !value reference to a temporary object, you can be sure no other 
part of the program has access to the same object. Thi s fact is important in understanding 
how move operat ions work. We discuss move operations next. 
Move Constructors and Move Assignment Operators 
Consider again the NumberArray class of Program 11-9, which we have modified by 
adding a default constructor: 
class 
NumberArray 
{ 
pr i vate: 
double *aPtr; 
i nt arraySize; 
public: 
} ; 
II Copy assignment 
and copy constructor 
NumberArray& operator=(const 
NumberArray &ri ght ); 
NumberArray (const NumberArray &); 
II Default 
constructor 
and regular 
constructor 
NumberArray (); 
NumberArray (i nt si ze, double value); 
II Destructor 
-NumberArray() 
{ if (a rraySize 
> 0) delete 
[ ] aPtr; 
} 
voi d print(} 
const; 
voi d setValue(double 
value}; 
Each object of this class owns a resource, namely, a pointer to dynamically allocated 
memory. Such classes need both a programmer-defined 
copy const ructor and an 
overloaded copy assignment operator. Th ese are necessary to avoid errors that result 
from the inadvertent sharing of the resource that results from a memberwise copy 
operation. 
Beginning with C++ 11, a class can define a move constructor and a move assignment 
operator. To better understand these concepts, we need to take a closer look at the 
operation of the destructor, copy constructor, and copy assignment operator. To help us 
monitor when these functions are being called, we modify the NumberArray destructor 

754 
Chapte r 11 
More about Classes and Object-Oriented Programming 
and all constr uctors to include a print statement that traces the execution of those 
functions. For examp le, we modify the copy constr uctor as follows: 
NumberArray: :NumberArray (const NumberArray &obj) 
{ 
} 
cout << "Copy constructor 
running\n"; 
arraySize 
= obj .a rraySize
; 
aPtr = new double[arraySize]; 
for(int 
index= 
O; index< 
arraySize; 
index++) 
{ 
aPtr[index] 
= obj.aPtr[index]
; 
} 
Similarly, we add the following statements to the destructor and to the other constr uctors 
and to the copy assignment operator: 
cout << "Destructor 
running \n"; 
cout << "Default 
constructor 
running\n"; 
cout << "Regular constructor 
running\n"; 
cout << "Assignment operator 
running\n"; 
Th e modified versions of the files that make up Program 11-9 can be found in files 
overl oad2. h and overl oad2. cpp. Program 11-14 demonstrates the working of the 
copy constr uctor and copy assignment operato rs. 
Program 11 -14 
1 // This program demonstrates 
the copy constructo
r and the 
2 // copy assignment 
operator 
for the NumberArray class. 
3 #include 
<iostream> 
4 #include 
"overload2.h" 
5 using namespace std ; 
6 
7 //Funct ion Prototype 
8 NumberArray makeArray (); 
9 
10 int main() 
11 { 
12 
13 
NumberArray first
; 
first= 
makeArray(); 
14 
NumberArray second= 
makeArray(); 
15 
16 
cout << endl << "The object's 
data is"· 
17 
first.print(); 
18 
cout << endl; 
19 
20 
return 
O; 
21 } 
22 
23 //***************************************************** 
24 II Creates 
a loca l object 
and returns 
it by value. 
* 
25 //***************************************************** 
26 NumberArray makeArray () 
27 { 
(program continues) 

11.7 Rvalue References and Move Operations 
755 
Program 11-14 
(continued) 
28 
NumberArray nArr(5, 
10.5); 
29 
retur n nArr; 
30 } 
Program Output (With line numbers added) 
(1}Default constructor 
running 
(2}Regular constructor 
running 
(3)Copy constructor 
running 
(4)Destructor 
running 
(5)Copy Assignment operator 
running 
(6)Destructor 
running 
(?)Regular 
constructor 
running 
(8)Copy constructor 
running 
(9)Destructor 
running 
(10)The object's 
data is 10.5 
10.5 
10.5 
10.5 
10.5 
(11)Destructor 
running 
(12)Destructor 
running 
<) 
The line numbers in the output are not generated by the program: We have added them to 
facilitate the discussion. Line (1) in the output is generated by the default constructor in 
line 12 of the program . Line (2) is generated by Line 28 when the makeArray () function 
creates a local object . Line (3) of the outp ut is generated when the copy constructor is 
invoked to copy the local object and create the temporary object returned from the 
function . At that point, the local object is destroyed, producing line (4) of the output. 
Next, line 13 of the program executes, invoking the copy assignment and producing line 
(5) of the output. With completion of the assignment, the temporary object is destroyed, 
producing line (6) of the output . Line (7) is generated by creation of the local object in the 
second call to makeArray () . The returned object is copied directly into the object second 
by the copy constructor, producing line (8) of the output, after which the local object in 
the function is destroyed, producing line (9). Lines (10) and (11) are produced when the 
objects first and second are destroyed at the end of the main function. 
NOTE: 
Some comp ilers may perform optimizations that eliminate some of the 
constr uctor calls. 
We are especially interested in line 13 of the program, 
first
= makeArray() 
which invokes the copy assignment to copy the temporary object makeArray (), as 
shown by line (5) of the output . The copy assignment deletes the aPtr array in firs t , 
allocates another array the same size as in the temporary, and copies the values from the 
temporary array into the aPt r array in first. 
The copy assignment goes to great lengths 
to avoid pointer sharing between first 
and the temporary object, but right after that, 
the temporary object is destroyed and its aPt r array is deleted. The idea behind the 
move assignment operator is to avoid all this work by having the object being assigned 
to swap resources with the temporary object. Th at way, when the temporary is 
destroyed, it deletes the memory that was previously owned by first, 
and first 
avoids 
having to copy the elements that were in the temporary's aPtr array . 

756 
Chapte r 11 
More about Classes and Object -Oriented Programming 
The move assignment for the NumberArray class is written below. To simplify the code, 
we have used the library function swap to swap the contents of two memory locations. 
The swap function is declared in the <algorithm> header file. 
NumberArray& NumberArray: :operator=(NumberArray&& ri ght ) 
{ 
} 
i f (this 
!= &right) 
{ 
} 
swap(arraySi ze, right .arraySi ze); 
swap(aPtr , ri ght .aPt r); 
return 
*this; 
Not ice that the function prototype is similar to that of the copy assignment, except 
move assignment takes an rvalue reference as parameter. This is because a move 
assignment shou ld only be performed when the source of the assignment is a temporary 
object . Not ice also that the parameter to the move assignment cannot be cons t . This is 
because "moving" a resource from an object modifies it. 
The move assignment, introduced in C++ 11, is obviously much more efficient than 
copy assignment, and it should be used whenever the object being assigned from is 
temporary . There is also a move constructor, which shou ld be used when creating a 
new object by initialization from a temporary object . 
Like move assignment, a move constructor avoids unnecessary copying of a resource 
by "stealing" the resource from the temporary object . Here is the move constructor for 
the NumberArray class. Again, note that the parameter to the constructor is an rvalue 
reference, denoting that the parameter is a temporary object . 
NumberArray: :NumberArray(NumberArray && temp) 
{ 
} 
II "Steal" 
t he resource 
from the temp obj ect 
t his - >arrayS iz e = temp.arrayS iz e; 
t his - >aPt r = temp .aPtr; 
II Put the temp obj ect in a safe st at e 
II for i t s destructor 
to run 
te mp.arraySi ze = O; 
te mp.aPtr = nullp t r; 
Note that the parameter to the move constructor cannot be const . In addition, the 
temporary object that is the source for the move constructor must be left in a state that 
will allow its destructor to run without causing errors. 
The implementation of the move operations for the NumberArray class can be found in 
the files overl oad3 . h and overl oad3. cpp. The operations themselves are demonstrated 
in Program 11-15. 
Conte nts of overload3. h 
1 #include 
<iostream> 
2 using namespace std; 
3 
4 class NumberArray 
5 { 
6 priva t e: 
7 
double *aPt r; 

11.7 Rvalue References and Move Operations 
757 
8 
int arraySize; 
9 public: 
10 
// Copy ass i gnment and copy constructor 
11 
NumberArray& operator=(const 
NumberArray &right ); 
12 
NumberArray(const 
NumberArray &); 
13 
14 
// Default 
constructor 
and regular 
constructor 
15 
NumberArray( ); 
16 
NumberArray(int 
size , double value); 
17 
18 
// Move Ass i gnment and Move Constructor 
19 
NumberArray& operator=(NumberArray 
&&); 
20 
NumberArray(NumberArray &&); 
21 
22 
II Destructor 
23 
-NumberArray(); 
24 
25 
void pr i nt() 
const; 
26 
void setValue(double 
value); 
27 ) ; 
Content s of overload3. cpp 
1 #include 
<i ostream> 
2 #include 
"overload3
.h" 
3 using namespace std; 
4 
5 //*************************************************** 
6 // The overloaded 
operator 
function 
for assignment. 
* 
7 //*************************************************** 
8 NumberArray& NumberArray::operator
=(co nst NumberArray &right ) 
9 { 
10 
cout << "Copy Ass i gnment operator 
running\n"; 
11 
if (th i s != &right ) 
12 
{ 
13 
i f (a rraySize 
> 0) 
14 
{ 
15 
delete[] 
aPtr; 
16 
) 
17 
arrayS i ze = r i ght.arraySize
; 
18 
aPtr = new double[arraySize]; 
19 
for (int 
index= 
O; index< 
arraySize; 
index++) 
20 
{ 
21 
aPtr[index] 
= r i ght.aPtr[index
] ; 
22 
) 
23 
} 
24 
return 
*th i s ; 
25 } 
26 
27 //********************************************** 
28 //Copy constructor. 
* 
29 //********************************************** 
30 NumberArray: :NumberArray(const 
NumberArray &obj) 
31 { 
32 
cout << "Copy constructor 
runn i ng\n"; 
33 
arrayS i ze = obj .arraySize; 
34 
aPtr = new double[arraySize]; 

758 
Chapte r 11 
More about Classes and Object-Oriented Programming 
35 
for (int 
index= 
O; index< 
arraySize; 
index++) 
36 
{ 
37 
38 
39 } 
40 
} 
aPtr[index] 
= obj.aPtr[index
] ; 
41 //********************************************** 
42 //Constr
uctor. 
* 
43 //********************************************** 
44 NumberArray: :NumberArray( i nt size1, 
double value) 
45 { 
46 
47 
48 
49 
50 } 
51 
cout << "Regular 
constructor 
running\n"; 
arraySize 
= size1; 
aPtr = new double[arraySize]; 
setValue(value); 
52 //********************************************** 
53 //D efault 
Constructor. 
* 
54 //********************************************** 
55 NumberArray: :NumberArray() 
56 { 
57 
cout << "Default 
constructor 
running\n"; 
58 
arraySize 
= 2; 
59 
aPtr = new double[arraySize]; 
60 
setValue(O.O); 
61 } 
62 
63 //**************************************************** 
64 // Sets the value stored 
in all entries 
of the array. 
* 
65 //**************************************************** 
66 void NumberArray: :setValue(double 
value) 
67 { 
68 
for (int 
index= 
O; index< 
arraySize; 
index++) 
69 
{ 
70 
aPtr[index] 
= value; 
71 
} 
72 } 
73 
74 //*************************************** 
75 // Print 
out all entries 
in the array. 
* 
76 //*************************************** 
77 void NumberArray: :print() 
const 
78 { 
79 
for (int 
index= 
O; index< 
arraySize; 
index++) 
80 
{ 
81 
cout << aPtr[ i ndex] <<" .. 
82 
} 
83 } 
84 
85 //************************************* 
86 // Destructor
. 
* 
87 //************************************* 
88 NumberArray: :-NumberArray() 
89 { 
90 
cout << "Destructor 
running\n"; 

11.7 Rvalue References and Move Operations 
759 
91 
92 
93 
94 
95 } 
96 
if (array Si ze > 0) 
{ 
delete[] 
aPtr ; 
} 
97 //*********************************************************** 
98 // Move assignment 
operator. 
* 
99 //*********************************************************** 
100 NumberArray & NumberArray::operator
=( NumberArray&& right) 
101 { 
102 
cout << "Move ass i gnment is runn i ng\n"; 
// Trace 
103 
104 
if (th i s != &right ) 
105 
{ 
106 
107 
108 
} 
swap(arraySize, 
r i ght.arrayS
i ze ); 
swap(aPtr, 
right.aPtr
); 
109 
return 
*th i s ; 
110 } 
111 
112 //*********************************************************** 
113 // Move constructor
. 
* 
114 //*********************************************************** 
115 NumberArray: :NumberArray(NumberArray 
&& temp) 
116 { 
117 
118 
119 
120 
121 
122 
123 
124 
125 } 
Program 11 -15 
// "Steal" 
the resource 
from the temp object 
th i s- >arraySize 
= temp .arraySize; 
th i s- >aPtr = temp.aPtr; 
// Put the temp object 
i n a safe state 
// for its 
destructor 
to run 
temp.arraySize 
= O; 
temp.aPtr 
= nullptr; 
1 // Thi s program demonstrates 
move constructor 
2 II the move assignment 
operator
. 
3 #include 
<iostream> 
4 #include 
"overload3.h" 
5 using namespace std ; 
6 
7 NumberArray makeArray (); 
8 
9 int main() 
10 { 
11 
NumberArray first; 
12 
f i rst= 
makeArray (); 
//P rototype 
13 
NumberArray second= 
makeArray (); 
14 
15 
cout << endl << "The object's 
data i s "; 
16 
f i rst.print(); 
(program continues) 

760 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11 -15 
(continued) 
17 
cout << endl; 
18 
19 
ret ur n O; 
20 } 
21 
22 //***************************************************** 
23 II Creates 
a local 
object 
and retur ns it by value. 
* 
24 //***************************************************** 
25 NumberArray makeArray() 
26 { 
27 
NumberArray nArr(5, 
10.5); 
28 
retur n nArr; 
29 } 
Program Output 
(1}Default 
cons t ruc t or runn i ng 
(2}Regular 
cons t ruc t or runn i ng 
(3)Des t ructor 
running 
(4)Move assignmen t is running 
(4)Des t ructor 
running 
(5}Regular 
cons t ruc t or runn i ng 
(6}Dest ructor 
running 
(7)The object's 
data i s 10.5 
10.5 
10.5 
10.5 
10.5 
(8}Dest ructor 
running 
(9}Dest ructor 
running 
By examining line (4) of the program output, you can see that the move assignment is 
called when the source of the assignment is a temporary object, at line 12 of the 
program listing. Line 13 of the program uses a temporary 
object to initialize a 
NumberArray object and so should have resulted in a call to the move constructor. 
However, there is no sign of this in the program output . This is because compilers 
sometimes use optimization techn iques to avoid calls to copy or move constructors . 
When Does the Compiler Use Move Operations? 
Like the copy constructor and assignment operator, move operations are called by the 
comp iler when appropriate . Specifically, the compi ler uses a move operation when 
1. a funct ion returns a result by value, or 
2. an object is being assigned to and the right -hand side is a temporary object, or 
3. an object is being initialized from a temporary object. 
Although most move operations are used to transfer a resource from a temporary 
object, this is not always the case . An example of this is the uni que _pt r class 
discussed in Chapter 10: One unique _ptr may need to transfer its managed object to 
another uni que _ptr object . If the source is not a temporary object, the comp iler 
cannot tell on its own that is should use a move. In such cases, the s t d: :move(} 
library function can be used . The effect of this function is to make its argument look 
like an rvalue and allow it to be moved from. You can see an example of the use of 
move () in Chapter 10. 

<) 
11.8 Function Objects and Lambda Expressions 
761 
Default Operations 
The class copy operations, move operations, and destructor are related in the sense that 
they are all concerned with the proper management and disposal of resources. Writing all 
of these operations for each class can be tedious, so the compiler tries to help out by 
generating default implementations for them. For a class MyCl ass , the compiler can generate 
• a default constructor MyCl ass () 
• a copy constructor MyCl ass ( cons t MyCl ass &) 
• a copy assignment operator MyClass & operator=(co
nst Myclass 
&) 
• a move constructor MyClass(MyClass 
&&) 
• a destructor -MyCl ass () 
Two rules govern the default generation of these operations: 
1. If you declare any constructor, the compiler will assume that objects of your class 
require special initialization and will not provide a default constructor . 
2. If you provide a nondefault implementation of any of these operations, the compiler 
will not generate implementations for any of them. This means, for example, that if 
you define a copy constructor for your class, then you should also define copy 
assignment, both move operations, and a destructor. Similarly, if you define a 
destructor for your class, then you should also define all copy and move operations. 
NOTE: 
Rule 2 is not completely enforced by current compilers, which generate 
default copy constructors and copy assignments even if a destructor has been 
defined. A future standard of C++ will completely enforce this rule. 
Function Objects and Lambda Expressions 
CONCEPT : A function object is an object of a class that overloads the function call 
operator. Function objects behave just like functions and can be passed 
as parameters to other functions. A lambda expression is a convenient 
way of creating a function object. 
An instance of a class that overloads the function call operator () is called a function 
object, or sometimes, a functor. A function object can be called just as if it were a 
function. As a simple example, let us create a function object which, when called with 
two integer parameters , returns the sum of those integers. What we want is a function 
object that behaves just like the function 
i nt sum ( i nt a , i nt b) 
{ 
re t ur n a+ 
b; 
} 
We begin by writing a class that overloads the function call operator(). 
class 
SumFunct or 
{ 
publ i c: 
i nt opera t or()(
i nt a, in t b) 
{ 
} 
} 
re t urn a+ 
b; 

762 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
Notice that overloading the function call operato r is very similar to overloading the 
array subscript operator [ ], the main difference being that the function call operator 
can take any number of arguments. Th e following code illustrates how to create 
SumFunctor function objects and call them to print sums of pairs of numbers. 
SumFunctor summer1; 
SumFunctor summer2; 
SumFunctor summer3 = SumFunctor(); 
cout << summer1(1,2) 
<<" 
"
<< summer2(3, 4 ) <<" 
" 
<< summer3(10, 5 ) << endl; 
This code will print the numbers 3, 7, and 15. 
In the above examp le, we assigned the identifiers summer1, summer2, and summer3 to the 
created function objects, and then we used these names to call the function objects. But 
function objects can be called at the point of their creation, without ever being given a 
name. For examp le, the following code creates a SumFunctor function object, calls it with 
arguments 12 and 5, and prints the result witho ut ever giving the function object a name. 
cout << SumFunctor()(12, 
5 ) << endl ; 
Objects that are created and used without being given a name are said to be anonymous. 
Predicates 
A predicate is a function that returns a Boolean value, and a unary predicate is one that 
takes a single argument . You use a unary predicate to determine whether a given object has 
a certain characteristic. For example, you can use the following class to create function 
objects that are unary predicates capable of determining whether an integer is even. 
class 
IsEven 
{ 
publ i c : 
bool operator(
)(i nt x ) 
{ 
} 
} 
return 
x % 2 == O; 
The following code shows how to use a predicate function object created from this class. 
i nt number; 
cout << "Enter an integer: 
"; 
cin << number; 
if (IsEven ()(number )) 
{ 
cout 
<< "Even "; 
} 
els e 
{ 
cout "Odd"; 
} 
A binary predicate is a predicate that takes two parameters. You use a binary predicate 
to determine whether two objects are related in some way. For example, you can use 
the follow ing class to create a predicate that determines whether one integer is less 
than anot her. 

class 
LessThan 
{ 
publ i c: 
11.8 Function Objects and Lambda Expressions 
763 
bool operator()(i
nt a, int b) 
{ 
} 
} 
return 
a< b; 
The expression Less Than () is the function object, whereas Less Than () ( x, y) represents 
the result of calling the function object with the arguments x and y . 
Function Objects as Parameters to Functions 
Like any other object, a function object can be passed as a parameter to another 
function . Indeed, the C++ library defines classes that can be used to define function 
objects and library functions that take objects of such classes as parameters . These 
library functions, most of which are declared in the <algorithm> header file, can sort 
and search arrays and vectors and perform many other useful tasks. 
Sorting Arrays and Vectors 
As an example, consider the library function 
voi d sort(begin, 
end, compare) 
This function is designed to sort a range of elements in an array or vector. The first two 
parameters , begi n and end, specify the positions within the array (or vector) where the 
range of elements to be sorted begins and ends. The begi n parameter points to the first 
element of the range, while the end parameter points to just beyond the last element of 
the range . The third parameter, compare, is a predicate that compares two values x 
and y and returns true if and only if the sorting operation should place x before y. The 
following code fragment shows how to use this function to sort an array of five integers. 
i nt arr [ ] { 12, 89, 34, 15 , 11 } ; 
sort(arr, 
arr+ 
5, LessThan()}; 
Notice that arr is the address of the first element in the array, while arr + 5 is the 
address of the memory location just past the end of the array . 
You can use the same funct ion to sort a vector. A vector uses objects called iterators 
to denote positions of vector elements. Given a vector vec, the member function 
vec . begi n () returns an iterator to first element, while vec. end ( )returns an iterator 
to just beyond the last element . Here is how to sort a vector of integers: 
vector<i nt > vec { 12, 89, 34, 15, 11 } ; 
sort(vec.begin()
, vec.e nd() , LessT han()); 
The standard namespace of the C++ library defines two functions, begi n () and 
end (), that can be used to give the beginning and ending of both arrays and vectors. 
For an array arr , the expression begi n(arr) has the same value as arr , and end(arr) 
has the same value as arr + si ze where si ze is the size of the array . For a vector vec, 
the expressions begi n (vec) and end (vec) have the same values as vec . begin() and 
vec . end (), respectively. So our array and vector examples can be written this way: 
i nt arr [ ] { 12 , 89 , 34, 
15, 11} ; 
sort(beg i n(arr), 
end(arr)
, LessThan()}; 
vector<i nt > vec { 12 , 89, 34 , 15 , 11}; 
sort(beg i n(vec), 
end(vec) , LessTha n()); 

764 
Chapter 11 
More about Classes and Object-Oriented Programming 
Removing Elements From a Vector 
Another useful library function is the remove_ i f function 
remove_if(begin, 
end, unary _pred i cate) 
This function facilitates the removal of elements that satisfy a unary predicate from a 
range of elements within a vector. Just as in the sort function , the beg i n and end 
parameters specify the beginning and ending of the range of elements. Despite its name, 
the function does not actua lly remove any elements. Instead, it just reworks the vector 
so that the subsequence of all elements that do not satisfy the predicate overwr ite the 
elements at the beginning of the vector. 
As an example, suppose that we want to use this function to remove all even elements 
from the vector vec. Using the predicate IsEven (), the code 
vector<int> 
vec {12 , 25, 36 , 8, 11, 15 , 89 , 32 , 71} ; 
auto rem_start 
= remove_if(beg i n(vec), 
end (vec ), IsEven ()); 
will pick out the subseq uence 25 , 11, 15, 89 , 71 of elements that are not even and use it 
to overwrite the first five elements of the vector, leaving the vector as 
{ 25 , 11 , 15 , 89, 
71 , 15 , 89 , 32 , 71} 
Th e function retu rns an iterator pointing to just past the end of the range to be 
preserved. Our example above stores this iterator into the variab le rem_start. 
Thi s 
means that rem_start 
will be pointing just after the fifth element . To comp lete the 
removal operat ion, you must call the vector's erase () function and tell it to erase the 
elements from rem_start to the end of the vector: 
vec.erase(rem
_start, 
end(vec)); 
In this code example, we declared the type of rem_start as auto . This tells the compiler 
that the type of rem_start is the same as the return type of the remove_ if function . 
Program 11-16 demonstrates the use of function objects as parameters to the sort and 
remove_ if functions . 
Content s of predicates
. h 
1 class 
IsEven 
2 { 
3 public : 
4 
bool operator()(int 
x) 
5 
{ 
6 
return 
x % 2 == O; 
7 
} 
8 } ; 
9 
10 class 
LessThan 
11 { 
12 public : 
13 
bool operator()(int 
X, 
14 
{ 
15 
return 
x < y; 
16 
} 
17 } 
i nt y) 

11.8 Function Objects and Lambda Expressions 
765 
Program 11 -16 
1 II Thi s program demonstrates 
the use of function 
objects 
2 II with the sort 
and remove_if functions
. 
3 #include 
"predicates.h" 
4 #include 
<vector> 
5 #include 
<algorithm> 
6 #include 
<iostream> 
7 using namespace std; 
8 
9 int main() 
10 { 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 } 
int arr [] { 12, 25 , 36, 8 , 11 , 
15, 89, 32 , 71 } ; 
vector< i nt> vec{ 12, 25, 36, 8 , 11 , 
15 , 89 , 32 , 71 } ; 
II Display array 
and vector 
in their 
original 
form 
cout << "Original 
form of both array 
and vector:\n" 
for (i nt e: 
arr) 
{ cout << e <<" 
"; } 
II Sort the array 
sort(begin(arr)
, end(arr), 
LessThan(}); 
II Pr i nt the sorted 
array 
cout << "\nHere i s the sorted 
array:\n 
"; 
for (i nt e: 
arr) 
{ cout << e <<" 
"; } 
II Call remove_if for even values 
auto start
_removed = remove_if(begin(vec}
, end(vec), 
IsEven()); 
cout << "\nHere i s the vector 
after 
call 
to remove_if:\n"; 
for (i nt e: 
vec) { cout << e <<" 
"; } 
II Erase the remove_i f'd 
elements 
vec.erase(start
_removed, end(vec)); 
cout << "\nHere i s the vector 
after 
call 
to erase:\n"; 
for (i nt e: 
vec) { cout << e <<" 
"; } 
cout << endl; 
return 
O; 
Program Output 
Original 
form of both array 
and vector: 
12 25 36 8 11 15 89 32 71 
Here is the sorted 
array: 
8 11 12 15 25 32 36 71 89 
Here is the vector 
after 
call 
to remove_if: 
25 11 15 89 71 15 89 32 71 
Here is the vector 
after 
call 
to erase: 
25 11 15 89 71 
Functional Objects with Stored Values 
One thing that makes function objects more useful than plain functions is that the 
overloaded function call operator can refer to member variables of the class. Suppose 
that, in a generalization of our previous example, we want to be able to remove from a 
vector all integers divisible by a given integer d, where dis supplied by the user at program 

766 
Chapte r 11 
More about Classes and Object-Oriented Programming 
execution time. A simple solution might be to write classes IsEven, i sDi vi si bl eBy3, 
IsDivisib
le By4, IsDivisibleBy5, 
and so on. This approach is clearly not practical. A 
more realistic approach is to write a single class whose constr uctor takes an integer 
parameter to be used as the divisor when testing an integer for divisibility. 
class 
IsDivisibleBy 
{ 
) 
int divisor; 
public: 
// Constructor 
stores 
parameter 
for use as di vi sor 
IsDi visibleBy(
i nt d){ divisor= 
d; } 
// Check if x i s di vi sib l e by the divisor 
bool operator( 
) (i nt x) 
{ 
return 
x % diviso r --
O; 
} 
Given such a class, you can create a function object IsDi visibleBy(7) 
to test integers 
for divisibility by 7, the funct ion object IsDivisibleBy
(12) to test divisibility by 12, 
and so on. Notice that if d and x are integers, the express ion IsDiv i si bleBy(d) is a 
function object, while the express ion Is Di vi si b 1 e ( d) ( x) is the Boolean result of calling 
the function object wit h argument x. In this last expression, d is the constr uctor 
parameter, while x is the parameter to the function object. 
Th e following code asks the user to enter an integer and then removes from vec all 
elements divisible by that integer: 
int d ; 
cout << "Enter a diviso r: "; 
cin >> d; 
auto rem_start 
= remove_if(beg i n(vec), 
end (vec ), IsDivisibleBy(d)); 
vec.erase(rem
_start, 
end(vec)); 
Void Returning Function Objects 
Function objects can have a return type of void. A function that takes a single parameter 
and has a return type of void is called a unary function . The following is a class that 
can be used to create a function object that is a unary function. The function object just 
prints the square of its argument . 
class 
Pri ntSquare 
{ 
publ i c : 
void operator()(
i nt a) { cout <<a* 
a<<" 
"; } 
) 
There are times when we want to call a unary function on each element of an array or 
vector. The for_each library function 
fo r_each(begin, 
end , unary _funct i on) 
declared in the calgorithm> header file does exactly that. It takes as parameters the 
beginning and end of a range of elements and a unary function, and applies the function 
to each element in the range. Program 11-17 demonstrates the use of this function to 
print the squares of numbers stored in a vector. 

11.8 Function Objects and Lambda Expressions 
767 
Program 11 -17 
1 II Thi s program demonstrates 
the use of 
2 II the for _each algorithm 
function
. 
3 #include 
<iostream> 
4 #include 
<algorithm> 
5 #include 
<vector> 
6 using namespace std ; 
7 
8 class 
PrintSquare 
9 { 
10 publ i C: 
11 
voi d operator()(int 
a ) { cout <<a* 
a<<
• "; } 
12 } ; 
13 
14 int main() 
15 { 
16 
vector<int> 
vec{ 1 , 2 , 3, 4, 5, 6 }; 
17 
18 
II 
print 
square 
of each el ement i n the array 
19 
for _each(begin(vec), 
end(vec}, 
PrintSquare(}); 
20 
21 
cout << endl ; 
22 
ret urn O; 
23
} 
Program Output 
1 4 9 16 25 36 
Functional Classes in the C++ Library 
Function objects are so useful that the C++ library defines a number of classes that can 
be instantiated to create function objects you can use in your program. Th e use of these 
classes requires the inclusion of the <funct i ona 1 > header file. Table 11-2 lists those 
that can be used to compare objects, but you can find information on many more in 
various resources online . 
Table 11-2 Library Function Objects 
Function Object 
less<T> 
less _equal<T> 
greater<T> 
greater
_equal<T> 
Description 
less<T>() (T a, T b} is true if and only if a < b 
1 ess _equal () (T a, T b) is true if an only if a <= b 
greater<T> () (T a, T b) is true if and only if a > b 
greater _eq ua 1 <T> () (T a, T b} is true if and only if a >= b 
Program 11-18 shows how to use a greater< T> object to sort arrays of do ubles and 
arrays of strings in descending order. 

768 
Chap ter 11 
More about Classes and Object-Oriented Programming 
Program 11 -18 
1 II Thi s program demonstrates 
the use of the library 
function 
2 II obj ect greater<T> 
to so r t arrays 
in descending 
orde r . 
3 #inc l ude <algorith
m> 
4 #inc l ude <functiona
l > 
5 #inc l ude <iostream> 
6 #inc l ude <str i ng> 
7 
8 using namespace std ; 
9 
10 int main () 
11 { 
12 
double d_val ues [J{ 12.5 , 78 .2 , 8.34 , 48 .0 , - 7.5 }; 
13 
string 
words[ ] { "the ", 
"quick ", "brown" 1 
"fox" , "j umps", 
14 
15 
} ; 
"over '' 1 "the ", "lazy '' 1 "dog " 
16 
II Di splay array of numbers 
17 
cout << "Or igina l array 
of numbers :\ n"; 
18 
fo r (auto x : d_va l ues } { cout << x << " "· 
} 
19 
cout << endl ; 
20 
21 
II Sort array of numbers and di sp l ay 
22 
so r t (begi n (d_val ues ), end (d_val ues ), greater<double>
()}; 
23 
cout << "Number array 
in descend i ng order:
\ n"; 
24 
fo r (auto x : d_va l ues ) { cout << x << " "; } 
25 
26 
cout << endl ; 
27 
28 
II Display 
array of words 
29 
cout << "Or igina l array 
of words :\ n"; 
30 
fo r (auto x : words ) { cout << x <<" 
" · } 
31 
cout << endl ; 
32 
33 
II Sort array of words and disp l ay 
34 
so r t (begin (words ), end (words }, greater<string>
()); 
35 
cout << "Number array 
in descend i ng order:
\ n"; 
36 
fo r (auto x : words ) { cout << x <<" 
" ; } 
37 
38 
cout << endl ; 
39 
return 
O; 
40 } 
Program Output 
Original 
array 
of numbers: 
12.5 78.2 8.34 48 - 7.5 
Number array 
in descending 
order: 
78.2 48 12.5 8.34 - 7.5 
Original 
array 
of words: 
the quick brown fox jumps over the lazy dog 
Number array 
in descending 
order: 
the the quick over lazy jumps fox dog brown 

11.8 Function Objects and Lambda Expressions 
769 
Lambda Expressions 
A lambda expression is a compact way of creating a function object from a class whose 
only member is the function call operator. The lambda expression does away with the 
class declaration and uses a streamlined notation for expressing the logic of the function 
call operator. For examp le, the lambda expression for a function object that computes 
the sum of two integers is 
[ ] (i nt a, int b) { return x + y; } 
and the lam bda expression for a function object that determines whether an integer 
. 
. 
1s even 1s 
[ ] (i nt a} { return a% 2 == O;} 
As another example, the lambda expression that takes an integer as input and prints 
the square of that integer is written like this: 
[ ] (i nt a} { cout <<a* 
a<<" 
"; } 
The lambda expressions shown above are basically function definitions in which the 
name and return type of the function has been replaced with the empty pair of brackets 
[ ). More generally, a lambda expression has the form 
[capture 
clause ] (parameter list) 
{ function 
body} 
The capture clause is a list of variables in the scope of the lambda expression that can be 
accessed from the lambda's function body. This is akin to a regular function definition 
listing all the global variables that it accesses. The lambdas we use in this book will not 
use capture clauses, so we do not discuss the concept any further. 
A lambda expression is called by placing a list of actual parameters right after it. For 
example, the following code fragment prints 7, the sum of the variables x and y. 
i nt X = 2; 
i nt y = 5; 
cout << [](int 
a, int b) {return a + b;}(x, 
y); 
Th e following code fragment sorts an array in descending order in the manner of 
Program 11-18. However, it uses a lambda expression in place of the greater<doubl e> 
function object as the third argument to the sort function. 
double d_values[]{ 
12.7 , 45 .9, 6.9 }; 
// Sort the array in descending order 
sort( 
begin (d_values}, 
end(d _values}, 
[](auto 
a, auto b) {return a> b;} 
) ; 
// Print 
the array 
for (auto x : d_values} 
{ 
cout 
<< x <<" 
"; 
} 
Because lambda expressions are function objects, you can assign a lambda to a variable 
of a suitable type and call it through the variable's name. For example, you can assign 
a name to a lambda expression like this: 
auto compare= 
[](auto 
a, auto b) {re turn a> 
b;}; 

770 
Chapte r 11 
More about Classes and Object -Oriented Programming 
Doing this breaks up your code into smaller chunks and makes it more readable. Here is the 
above code fragment rewritten to refer to a variable whose value is a lambda expression: 
double d_values[]{ 
12.7, 
45.9 , 6.9 }; 
II 
Lambda express i on 
auto compare= 
[](au t o a, aut o b) {re t urn a> 
b;}; 
II Sort the array 
i n descending 
order 
sort(beg
i n(d _values), 
end(d _values), 
compare); 
II Pri nt t he array 
for (au t o x : d_values) 
{ 
cout 
<< x <<" 
"; 
} 
~ 
Checkpoint 
11.9 
11.31 What is an rvalue reference? 
11.32 How is the type declaration of an rvalue reference distinguished from that of 
an !value reference? 
11.33 What is the difference between a move assignment and a copy assignment? 
11.34 What is a function object? 
11.35 Which operator must be overloaded in a class before the class can be used to 
create function objects? 
11.36 What is a lambda expression? 
Type Conversion Operators 
CONCEPT: 
Special operator functions may be written to convert a class object to 
any other type. 
As you've already seen, operator functions allow classes to work more like built-in 
data types. Another capab ility that operator functions can give classes is automat ic 
type conversion . 
Data type conversion happens "behind the scenes" with the built-in data types. For 
instance, suppose a program uses the following variab les: 
i nt i ; 
doubled; 
The following statement automat ically converts the value in i to a doub le and stores 
it in d: 
d = i ; 
Likewise, the following statement converts the value in d to an integer (truncating the 
fractional part) and stores it in i : 
i = d; 

0 
11.9 Type Conversion Operato rs 
771 
Th e same functionality 
can also be given to class ob jects. For examp le, assuming 
di stance is a Length object and di s a doubl e, the following statement would convenien tly 
store distance into a floating -point number stored in d, if Length is properly written: 
d = distance
; 
To be able to use a statement such as this, an operator function must be written to perform 
the conversion. Here is an operator function for converting a Length object to a doubl e: 
Length: :operator 
double( ) const 
{ 
return 
l en_inches 
/12 + (len _i nches %12) / 12 .0; 
) 
Thi s function comp utes the real decimal equivalent of a length measurement in feet. For 
example, a measurement of 4 feet 6 inches wou ld be converted to the real number 4.5. 
N OT E: No return type is specified in the function header because the return type 
is inferred from the name of the operato r function. Also, because the function is a 
member function, it operates on the calling object and req uires no other parameters . 
Program 11-19 demonstrates a modified version of the Length class with both a double 
and an int conversion ope rato r. Th e int operator simp ly returns the number of inches 
of the Length ob ject . 
Content s of Length2. h 
1 #ifndef 
_LENGTH1
_H 
2 #define 
_LENGTH1
_H 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 class 
Length 
7 { 
8 private
: 
9 
int 
len _inches; 
10 pub l i C : 
11 
Length (i nt feet , int 
inches) 
12 
{ 
13 
setLength(feet, 
i nches); 
14 
) 
15 
Length (int 
inches ){ len _i nches = inches ; ) 
16 
int getFeet(
) const 
{ return 
len _i nches / 12 ; } 
17 
int getlnches(
) const 
{ return 
len _i nches % 12 ; } 
18 
void setLength(int 
feet , int 
inches) 
19 
{ 
20 
len _inches 
= 12 *f eet+ 
inches; 
21 
} 
22 
// Type conversion 
operators 
23 
operator 
double () const ; 
24 
operator 
i nt() 
const 
{ return 
l en_inches; 
} 
25 
26 
// Overloaded 
stream output 
operator 
27 
friend 
ostream 
&operator<<(ostream 
&out , Length a); 
28 } ; 
29 #endif 

772 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Contents of Length2. cpp 
1 #include 
"Length2.h" 
2 
3 //*********************************************** 
4 II Operator 
double converts 
Length to a double 
* 
5 //*********************************************** 
6 Length: :operator 
double() 
const 
7 { 
8 
return 
len _inches 
112 + (len _inches %12) I 12 .0; 
9 } 
10 
11 //******************************************* 
12 II Overloaded 
stream insertion 
operator<< 
* 
13 //******************************************* 
14 ostream &operator<< (ostream& out , Length a) 
15 { 
16 
out<< 
a.getFeet() 
<<" 
feet, 
"<< a.getlnches() 
<<" 
inches"; 
17 
return 
out; 
18 } 
Program 11 -19 
1 II Thi s program demonstrates 
the type conversion 
operators 
for 
2 II the Length class. 
3 #include 
"Length2.h" 
4 
5 #include 
<iostream> 
6 #include 
<str i ng> 
7 using namespace std ; 
8 
9 int main() 
10 { 
11 
Length di stance(O ); 
12 
double feet; 
13 
14 
15 
16 
int inches ; 
distance.setLength(4, 
6); 
cout << "The Length object 
is"<< 
di stance<< 
17 
II Convert and pr i nt 
18 
feet= 
distance; 
19 
inches= 
di stance ; 
It 
II << endl ; 
20 
cout << "The Length object 
measures"<< 
feet<<" 
feet.
"<< endl; 
21 
cout << "The Length object 
measures 
" << inches << " inches." 
22 
<< endl; 
23 
return 
O; 
24 } 
Program Output 
The Length object 
is 4 feet, 
6 inches. 
The Length object 
measures 4.5 feet. 
The Length object 
measures 54 inches. 

11.10 Convert Constructors 
773 
Convert Constructors 
CONCEPT: 
In addition to providin g a means for the creatio n of objects, convert 
constr uctors provide a way for the compiler to convert a value of a 
given type to an object of the class. 
A constructo r that takes a single parameter of a type other than its class type can be 
regarded as converting its parameter into an object of its class. Such a constr uctor is 
called a convert constructor . 
In addition to the function of creating objects of its class, a convert constr uctor provides 
the comp iler with a way of performing implicit type conversions . Such type conversions 
will be performed by the compile r wheneve r a value of the constr uctor's parameter 
type is given where a value of the class type is expected. 
As a simple example, consider the class 
class 
IntClass 
{ 
private: 
int value; 
publ ic : 
) ; 
// Convert constructor 
from int 
IntClass
(int 
intValue) 
{ 
value= 
intValue; 
) 
int getValue() 
const { return 
value; 
) 
Since the constr uctor IntC l ass (i nt ) takes a single paramete r of a type other than 
I ntCl ass , it is a convert constr uctor. 
Convert constr uctors are automatically invoked by the compiler whenever the context 
demands a class object but a value of constructor's parameter type is provided . Th is 
occurs in four different contexts: 
1. An object of the class is initialized with a value of the convert constr uctor's 
parameter type: for example 
IntClass 
intOb je ct = 23 ; 
2. An object of the class is assigned a value of the convert constructor's parameter 
type: for example 
intOb je ct = 24; 
3. A function expecting a value parameter of the class type is instead passed a value 
of the constructor's parameter type. For example, we may define a function 
void printValue
(IntC lass x) 
{ 
cout << x.getValue(); 
) 

774 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
and then pass it an int when we call it: 
pri ntVa l ue (25 ); 
The compiler will use the convert constructor to convert the integer 25 into an 
object of the IntCl ass class and will then pass the object to the function. The 
compiler will not invoke the convert constructor if the formal parameter is a pointer 
or a reference to an IntCl ass object: Convert constructors are only invoked when 
the formal parameter uses pass by value. 
4. A function that declares a return value of the class type actually returns a value of 
the convert constr uctor's parameter type. For example, the compiler will accept 
the following function: 
IntClass 
f(int 
intValue) 
{ 
ret urn intValue; 
) 
Note that the function returns a value of type integer, even though IntCl ass is 
declared as its return type. Again, the compiler will implicitly call the convert 
constr uctor to convert the integer i ntVal ue to an IntCl ass object. It is this object 
that is returned from the function . 
The following program illustrates the action of convert constr uctors. 
Content s of Convert. h 
1 #include 
<iostream> 
2 using namespace std ; 
3 
4 class 
IntC la ss 
5 { 
6 private
: 
7 
int value; 
8 public : 
9 
II Convert constructor 
from int 
10 
IntC lass( i nt i ntValue) 
11 
{ 
12 
value= 
intValue; 
13 
) 
14 
int getValue () const 
{ return 
value; 
) 
15 } ; 
Content s of Convert . cpp 
1 #include 
"Convert.h" 
2 //******************************************* 
3 II This funct i on returns 
an i nt even though* 
4 II an IntC la ss object 
i s declared 
as the 
* 
5 II 
ret urn type . 
* 
6 //******************************************* 
7 IntClass 
f (i nt i ntValue) 
8 { 
9 
ret urn intValue; 
10 } 
11 

12 //******************************************* 
13 II Prints 
the int value i nside an IntClass 
* 
14 II object. 
* 
15 //******************************************* 
16 void pr i ntValue(IntClass 
x) 
17 { 
18 
cout << x .getValue(); 
19 } 
Program 11 -20 
1 II Thi s program demonstrates 
the action 
of 
2 II convert 
constructors
. 
3 #include 
"Convert.h" 
4 
5 II Function 
prototypes. 
6 void pr i ntValue(IntClass); 
7 IntClass 
f (i nt}; 
8 
9 int main() 
10 { 
11 
II Initial
i ze wi th an int 
12 
IntClass 
intObject 
= 23; 
11.10 Convert Constructo rs 
775 
13 
cout << "The value is
" << intObject.getValue() 
<< endl; 
14 
15 
II Ass i gn an int 
16 
intObject 
= 24 ; 
17 
cout 
<< "The value is " << intObject
.getValue() 
<< endl; 
18 
19 
II Pass an int to a function 
expecting 
IntClass 
20 
cout << "The value is
"· 
21 
pr i ntValue(25}; 
22 
cout << endl; 
23 
24 
II Demonstrate 
conversion 
on a return 
25 
intObject 
= f (26) ; 
26 
cout << "The value i s "; 
27 
pr i ntValue(intObject}; 
28 
29 
return 
O; 
30 } 
Program Output 
The value 
The value 
The value 
The value 
is 23 
is 24 
is 25 
is 26 
You should consider the use of a convert constructo r whenever it makes sense to have 
automatic conversions from some type to the class type. A practical example of the use 

776 
Chapter 11 
More about Classes and Object-Oriented Programming 
of convert constructors can be found in the C++ string class. Th at class provides a 
convert constructor from C-strings : 
class 
string 
{ 
} ; 
II Only t he convert constructor 
is shown 
public: 
st ring(char 
*); 
The presence of this convert constr uctor allows programmers to pass C-str ings to 
functions that expect string object parameters, assign C-strings to stri ng objects, and 
use C-strings as initial values of string objects: 
stri ng str 
= "Hel lo" ; 
str 
= "Hello There!"; 
In a way, convert constructors work in a way that is the opposite of the type conversion 
operators covered in a previous section: Whereas type conversion operators convert an 
object to a value of another type, convert constr uctors convert a value of a given type 
to an object of the class. 
~ 
Checkpoint 
11.11 
a 
VideoNot e 
Aggregation 
and 
Composition 
11.37 What are the benefits of having operator functions that perform object conversion? 
11.38 Why is it not necessary to specify a return type for an operator function that 
performs data type conversion? 
11.39 Assume that there is a class named Bl ackBox. Write a prototype for a member 
function that converts Bl ackBox to int. 
11.40 Assume there are two classes, Bi g and Smal 1.Write a prototype for the convert 
constr uctor that converts objects of type Sma 11 to objects of type Big. 
Aggregation 
and Composition 
CONCEPT: 
Class aggregatio n occurs when an object of one class owns an object of 
anot her class. Class composition is a form of aggregation where the 
owner class controls the lifetime of objects of the owned class. 
In Chapter 7, you learned that a class can contain members that are themselves objects 
of other classes. When a class C contains a member that is an object of another class D, 
every object of C will have inside it an object of the class D. This creates a has-a 
relationship between C and D. In this type of relationship, every instance of Chas, or 
owns, an instance of the class D. In C++, such ownersh ip usually occurs as a result of 
C having a member of type D, but it can also occur as a result of C having a pointer to 
an object of D. The term aggregation is often broad ly used to describe situations in 
which objects of one class own objects of other classes. 
Member Initialization 
Lists 
Consider the following Person and Date classes. 

class 
Date 
{ 
str i ng month; 
int day , year; 
publ ic : 
Date(string 
m, int d, int y) 
{ 
month = m; 
day = d; 
year= 
y; 
} 
} ; 
class 
Person 
{ 
Str i ng name; 
Date dateOfBirth
; 
publ ic : 
11.11 Aggregation and Composition 
777 
Person(string 
name , string 
month , int day , int year} 
{ 
} 
} ; 
// Pass month, day and year to the 
// dateOfBirth 
constructor 
th is-> name = name ; 
The Person constructor receives parameters month, day, and year that it needs to pass 
to the Date constr uctor of its dateOfB i rth member. C++ provides a special notation, 
called a member initialization list, that allows constr uctors of classes to pass arguments 
to constr uctors of member objects. A member initialization list is a list of comma -separated 
calls to member object constructors. It is prefixed with a colon and is placed just after 
the header , but before the body, of the constr uctor of the containing class: 
class 
Person 
{ 
Str i ng name; 
Date dateOfBirth
; 
publ ic : 
} ; 
Person(string 
name , string 
month , int day , int year}: 
dateOfBirth(month, 
day , year) 
// Member i ni t ia lization 
list 
{ 
this -> name = name ; 
} 
Notice the colon at the end of the constructor header, and notice that in invoking the 
constructor of the contained Date object, it is the name of the object (dateOfBi rth ) 
rathe r than the class of the object (Date ) that is used. Th is allows const ructors of 
different objects of the same class to be invoked in the same initialization list. 
Altho ugh the member initialization 
list is usually used to invoke constr uctors on 
member objects, it can be used to initialize membe r variables of any type. Thu s, the 
Person and Date class can be written as follows: 
class 
Date 
{ 
str i ng month; 
int day , year; 

778 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
publ ic : 
} ; 
Date(string 
m, int d, int 
month(m), day(d), 
year(y) 
{ 
} 
class 
Person 
{ 
Str i ng name; 
Date dateOfBirth
; 
publ ic : 
y) : 
// Member Initial
iz at io n list 
Person(string 
name , string 
month , int day, int year}: 
name (name) , 
} ; 
dateOfBirth(month, 
day, year) 
{ 
} 
Notice that the bodies of the Date and Person constructors are now empty . Th is is 
because the assignment of values to member variables normally performed there is now 
accomplished by the initialization lists. Many programmers prefer the use of member 
initialization lists to assignment inside of the body of the constr uctor because it allows the 
compiler to generate more efficient code in certain situations . When using member 
initialization lists, it is good programming practice to list the members in the initialization 
list in the same order that they are declared in the class. 
Finally, notice the occurrence of name (name) in the initialization list of the Person 
constructor. The compi ler is able to determine that the first occurrence of name refers 
to the member variab le and that its second occurrence refers to the parameter. 
Aggregation 
Through Pointers 
Now let's suppose that, in addition to having a date of birth, each person has a country 
of residence. A country has a name and possibly many other attrib utes: 
class Country 
{ 
str i ng name; 
// Additional 
fields 
} ; 
Because many people will "have" the same country, the has-a relationship between 
Person and Country sho uld not be implemented by embedding an instance of the 
Country class inside every Person object. Because many people share the same country 
of residence, implementing the has-a relation by containment will result in unnecessary 
duplication of data and waste memory . In addit ion, it would require many Person 
objects to be updated whenever a country has a change in any of its data . Using a 
pointer to implement the has-a relation avoids these problems . Here is a version of the 
Person class, modified to include a pointer to the country of residence: 
class 
Person 
{ 
str i ng name; 
Date dateOfBirth
; 

11.11 Aggregation and Composition 
779 
shared _ptr<Country> pCountry; 
II Pointer 
to Country of Residence 
publ i c : 
Person (string 
name, string 
month, int day, 
{ 
) 
) ; 
int 
year, 
shared _ptr<Country>& pC) 
Aggregation, 
Composition, and Object Lifetimes 
Composition is a term used to describe special cases of aggregation in which the lifetime 
of the owned object coincides with the lifetime of its owner. A good example of 
composition is when a class C contains a member that is an object of another class D. The 
contained D object is created at the same time that the C object is created and is destroyed 
when the containing C object is destroyed or goes out of scope. Another example of 
composition is when a class C contains a pointer to a D object and the D object is created 
by the C constructor and destroyed by the C destructor. 
Th e following program features modified versions of the above classes designed to 
illustrate aggregation, composition, and object lifetimes . Each class has a constr uctor 
to announce the creation of its objects and a destructor to announce their demise. The 
Person class has a static member 
i nt Person : :uniquePersonID; 
that is used to generate numbers assigned to Person objects as they are created . Th ese 
numbers serve as a sort of universal personal identificat ion number, much as socia l 
security numbers are used to identify people in the United States . The numbers are 
sto red in a personID field of the Person and Date classes and are used to identify 
objects being created or destroyed. Each dateOfBi rth object carries the same person ID 
number as the Person object that contains it. 
Program 11 -21 
1 // Thi s program illustrates 
aggregation, 
composition 
2 II and object 
lifetimes
. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 using namespace std ; 
6 
7 class 
Date 
8 { 
9 
string 
month ; 
10 
int day , year; 
11 
int personID ; // ID of person whose bi rthday this 
i s. 
12 publ i C: 
13 
Date(string 
m, int d , int y, int id) 
: 
14 
month(m), day(d), 
year(y), 
personID (id) 
15 
{ 
16 
cout << "Date-Of-B i rth object 
for person" 
17 
<< personID <<" 
has been created
. \n"; 
18 
} 
19 
-Date () 
(program continues) 

780 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11 -21 
(continued) 
20 
{ 
21 
cout << "Date-Of-B i rth object 
for person" 
22 
<< personID <<" 
has been destroyed
. \n"; 
23 
} 
24 }; 
25 
26 class 
Country 
27 { 
28 
string 
name; 
29 public: 
30 
Country(string 
name) : name(name ) 
31 
{ 
32 
cout << "A Country object 
has been created. 
\ n" ; 
33 
} 
34 
-Country() 
35 
{ 
36 
cout << "A Country object 
has been destroyed.\n
"; 
37 
} 
38 }; 
39 
40 class 
Person 
41 { 
42 
string 
name; 
43 
Date dateOfBirth; 
44 
int personID ; II Person identification 
number (PID) 
45 
shared _ptr<Country> 
pCountry; 
46 public: 
47 
Person(str
i ng name, str i ng month, i nt day, 
48 
int year, 
shared _ptr<Country>& pC) : 
49 
name(name), 
50 
dateOfB i rth(month, 
day, year, 
Person: :uniquePersonID), 
51 
personID(Person::uniquePersonID), 
52 
pCountry(pC) 
53 
{ 
54 
cout << "Person object" 
55 
<< personID <<" 
has been created
. \n"; 
56 
Person: :uniquePersonID+
+; 
57 
} 
58 
-Person () 
59 
{ 
60 
cout << "Person object" 
61 
<< personID <<" 
has been destroyed
. \n"; 
62 
} 
63 
static 
int uniquePersonID; 
II Used to generate 
PIDs 
64 }; 
65 
66 II Define the static 
class 
variable 
67 int Person: :uniquePersonID 
= 1; 
68 
69 int main() 
70 { 
71 
II Create 
a Country object 
(program continues) 

11.11 Agg regation and Composition 
781 
Program 11 -21 
(continued) 
72 
shared _ptr<Country> 
p_usa = make_shared<Country>("USA"); 
73 
II Create 
a Person object 
74 
shared _ptr<Person> 
p = 
75 
make_shared<Person> ("Peter 
Lee" , "January" , 1 , 1985 , p_usa) ; 
76 
II Create 
another 
Person object 
77 
shared _ptr<Person> 
p1 = 
78 
make_shared<Person>("Eva 
Gustafson", 
"May ", 15, 1992, p_usa); 
79 
cout << "Now there 
are two people.\n"; 
80 
81 
II Both persons wi ll go out of scope when main returns 
82 
return 
O; 
83 ) 
Program Output 
A Country object 
has been created. 
Date-Of-Birth 
object 
for person 1 has been created. 
Person object 
1 has been created. 
Date-Of-Birth 
object 
for person 2 has been created. 
Person object 
2 has been created. 
Now there 
are two people. 
Person object 
1 has been destroyed. 
Date-Of-Birth 
object 
for person 1 has been destroyed. 
Now there 
is only one. 
Person object 
2 has been destroyed. 
Date-Of-Birth 
object 
for person 2 has been destroyed. 
A Country object 
has been destroyed. 
Th e relationship between the dateOfBi rth objects and the Person objects that contain 
them is an example of compos ition. As you can see from the program output, those 
Date objects are created at the same time, and die at the same time, as the Person 
objects that own them. Aggregation in its more general form is exemplified by the 
has-a relationship between Person and Country. 
By looking at the print 
member function, 
you can see an example of how the 
member functions of the enclosing class can access the member functions of the 
contained class. 
The Has-A Relation 
When one class contains an instance of a second class, the first class is said to sustain 
a has-a relation to the second. For example, the Acquaintance 
class has -a Date class 
in the form of its dob member, while the Date class has-a string 
object in the form of 
its month member. Th e has-a relation is important in modeling relationships among 
classes and objects during the design of an object -or iented system. Another important 
relation between classes in a program is the is-a relation, which we will discuss in 
a lat er section afte r we have discussed the concept of inheritance. 
Thu s object 
composition realizes the has-a relation, while, as we will see later, inheritance is a way 
of realizing the is-a relation. 

782 
Chapter 11 
Figure 11-5 
More about Classes and Object-Oriented Programming 
Inheritance 
Generalization 
and Specialization 
In the real world, you can find many objects that are specialized versions of other 
objects. For example, the term "insect" describes a very general type of creature with 
numerous characteristics. Because grasshoppers and bumblebees are insects, they have 
all the general characterist ics of an insect. In addition, they have special characteristics 
of their own. For example, the grasshopper has its jumping ability, and the bumblebee 
has its stinger. Grasshoppers and bumblebees are specialized versions of an insect. This 
is illustrated in Figure 11-5. 
In addition to the common 
insect characteristics, the 
bumblebee has its own 
character istics such as the 
ability to sting. 
Insect 
All insects have 
certain characteristics. 
In addition to the common 
insect characteristics , the 
grasshopper has its own 
characteristics such as the 
ability to jump. 
Inheritance and the ls-a Relationship 
When one object is a specialized version of another object, there is an is-a relationship 
between them. For example, a grasshopper is an insect. Here are a few other examples 
of the is-a relationship . 
• A poodle is a dog. 
• A car is a vehicle. 
• A rectangle is a shape. 
When an is-a relationship exists between objects, it means that the specialized object 
has all of the characteristics of the general object, as well as additional characteristics 
that make it special. In object-oriented programming, inheritance is used to create an 
is-a relationship between classes. 
Inheritance involves a base class and a derived class. The base class is the general class, 
and the derived class is the specialized class. The derived class is based on, or derived 
from, the base class. You can think of the base class as the parent and the derived class 
as the child. This is illustrated in Figure 11-6. 

Figure 11-6 
Insect class 
members 
t 
Base class 
(parent) 
I 
Grasshopper class 
members 
Derived class 
(child) 
11.12 Inheritance 
783 
The derived class inherits the member variables and member functions of the base class 
without any of them being rewritten. Furth ermore, new member variables and functions 
may be added to the derived class to make it more specialized than the base class. To 
take a specific example, consider a college or university environment where there are 
both students and faculty personnel. Suppose that we have a class Person with a name 
data member and member functions for working with the name member: 
class 
Person 
{ 
pr i vate: 
string 
name; 
publ ic : 
} ; 
Person () { set Name ( '"') ; } 
Person (const string& 
pName) { setName(pName); } 
voi d setName (const string& 
pName) {n ame = pName; } 
string 
getName() const 
{ return 
name; } 
Suppose further that we have the enumerated types 
enum class 
Discipline 
{ARCHEOLOGY, 
BIOLOGY, COMPUTER
_SCIENCE}; 
enum class 
Classification 
{FRESHMAN, SOPHOMORE
, JUNIOR, SENIOR}; 
to define the range of disciplines in which studies are offered and the classification of 
students . We can use these types to define Student and Facu l ty classes that inherit 
from Person. This makes sense because a Student is a Person and a Faculty member 
is also a Person. 
To define a class by inheritance, we need to specify the base class plus the additiona l 
members the derived class adds to the base class. Let's say that in addition to having all 
the characteristics of a Person , a Student must declare a major in some discipline and 
have an academic advisor who is a Person. The Student class can be defined as follows: 
class 
Student 
: public 
Person 
{ 
pr i vate: 
Disc i pline 
major; 
shared _ptr<Person> 
advisor; 
publ ic : 
} ; 
voi d setMajor (Discipline 
d) {m ajor
= d; } 
Disc i pline 
getMajor() 
const 
{ return 
major; } 
voi d setAdv i sor(shared
_ptr<Person> 
p) {a dvi sor
= p; } 
shared _ptr<Person> 
getAdvisor() 
const 
{ return 
advisor; 
} 

784 
Chapte r 11 
Figure 11-7 
More about Classes and Object-Oriented Programming 
We assume that many different students may have the same advisor. The St uden t 
object stores a shared smart pointer to the advisor to avoid memory management 
problems . 
The first part of the first line of the class declaration specifies St udent as the name of 
the class being defined and specifies the existing class Person as its base class: 
The key word pub 1 i c that precede s the name of the base class is the base class access 
specificati on. It affects how the members of the base class will be accessed by the 
class Student 
public Person 
t 
t 
Derived class 
Base class 
member functions of the derived class and by code outside of the two classes. We will 
discuss the base class access specificat ion in greater detail in a later section . 
A class can be used as the base class for more than one derived class . In particular , a 
Faculty class can also be derived from the Person class as follows: 
class 
Facul t y : public 
Person 
{ 
pr i vat e: 
Disc i pline 
departme nt ; 
publ i c: 
voi d se t Department(Discipline 
d) {departme
nt= 
d; } 
Disc i pline 
getDepart ment( 
} const { retur n depar t ment ; 
} 
} ; 
Thus a Faculty object is a Perso n object that has a home department in some discipline. 
It is also important to note that each object of the derived class will contain all members 
of the base class. This is illustrated by Figure 11-7 in the case of the Stude nt and 
Person classes . 
Class Person 
Members: 
string name 
Person() 
Person(string) 
void setname(string) 
string getName() 
Class Student 
Members inherited from Person: 
string name 
Person() 
Person(string) 
void setname(string) 
string get Name() 
New Members added by Student: 
Discipline 
major 
shared_ptr<Person> advisor 

11.12 Inheritance 
785 
Inheritance and Pointers 
Whenever inheritance is involved, all objects should be dynamically allocated and 
accessed through pointers . To see why, cons ider a program that works wit h both 
Student and Person types. Because a Student is a Person, we sho uld be able to pass 
Student objects to functions that expect a parameter of type Person, or assign a Student 
object to a variable of type Person: 
Person p; 
Students; 
P = s; 
However, a Student object, with its additiona l members, will not fit in a memory location 
allocated for a Person object . To car ry out such an assignment, the compiler will slice off 
the Student 
parts that do not belong to Person , leaving only the inherited parts and 
resulting in loss of information. 
Thi s does not occur if we are dea ling with pointers 
because all pointers have the same size. 
Program 11-22 demonstrates the creation and use of an object of a derived class by creating 
a Faculty object. The program uses arrays of strings that map values of enumerated types 
to strings to enab le printing of values of enumerated types in the form of strings . Th e 
included "inh eritance
. h" file contains declarations of the Person, Student, and Faculty 
classes, as well as the enumerated types Di sc i p 1 i ne and Cl assi fi cat i on. 
Content s of lnheritance.h 
1 #include 
<string> 
2 #include 
<memory> 
3 using namespace std ; 
4 
5 enum class 
Disc i pline 
{ARCHEOLOGY
, BIOLOGY, COMPUTER
_SCIENCE}; 
6 enum class 
Classificat
i on {FRESHMAN
, SOPHOMORE, JUNIOR, SENIOR}; 
7 
8 class 
Person 
9 { 
10 private
: 
11 
str i ng name; 
12 pub 1 i C : 
13 
Person () { set Name ( "") ; } 
14 
Person(const 
string& 
pName) { setName(pName); 
} 
15 
void setName(const 
str i ng& pName) {na me = pName; } 
16 
str i ng getName() const 
{ ret urn name; } 
17 } ; 
18 
19 class 
Student 
20 { 
21 private
: 
public 
Person 
22 
Discipl
i ne major; 
23 
shared _ptr<Person> 
adv i sor ; 
24 public
: 
25 
void setMajor(Disc
i pline 
d) {major= 
d ; } 
26 
Discipl
i ne getMajor() 
const 
{ return 
major; 
} 
27 
void setAdv i sor (shared _ptr<Person> 
p} {advisor= 
p ; } 
28 
shared _ptr<Person> 
getAdvisor
() const 
{ ret urn advisor; 
} 
29 } ; 
30 
(program continues) 

786 
Chapte r 11 
More about Classes and Object-Oriented Programming 
31 class 
Faculty 
: public 
Person 
32 { 
33 private
: 
34 
Discipl
i ne department
; 
35 public : 
36 
void setDepartment(D
i scipline 
d) { depa r tment
= d ; } 
37 
Discipl
i ne getDepartment() 
const 
{ return 
department; 
} 
38 } ; 
Program 11 -22 
1 II Thi s program demonstrates 
the creation 
and use 
2 II of objects 
of der i ved classes
. 
3 #include 
<iostream> 
4 #include 
"inheritance.h" 
5 
6 using namespace std ; 
7 
8 II These arrays 
of str i ng are used to print 
the 
9 II enumerated 
types . 
10 const 
str i ng dName[] = { 
11 
"Arche ology ", "Bi ology", 
"Comput er Sci ence " 
12 } ; 
13 
14 const 
str i ng cName[] = { 
15 
"Fres hman" 1 
"Sophomore" 
1 
"Jun io r", 
"Senior" 
16 } ; 
17 
18 int main() 
19 { 
20 
II Create 
a Faculty 
object 
21 
shared _ptr<Facu lty> prof
= make_shared<Faculty>(); 
22 
23 
II Use Person member function 
to set name 
24 
prof - >setName("Indiana 
Jones"); 
25 
26 
II Use Faculty 
member function 
to set Department 
27 
prof - >setDepartment(Discipline::ARCHEOLOGY); 
28 
cout <<"Professor"<< 
prof - >getName() 
29 
<<" 
teaches 
in the
" << "Depa r t ment of
"· 
30 
31 
II Get Department as an en umerated type 
32 
Di scipline 
dept= 
prof - >getDepa rtm ent (); 
33 
34 
II Pr i nt out the department 
in string 
form 
35 
cout << dName[stat i c_cast<int>
(dept )] << endl ; 
36 
37 
return 
O; 
38
} 
Program Output 
Professor 
Indiana 
Jones teaches 
in the Department of Archeology 

11.13 
11.13 Protected Membe rs and Class Access 
787 
Superclasses and Subclasses 
We can think of a class as describing the set of all objects that have certain characteristics. 
An object of a derived class inherits all the characteristics of the base class, so it can be 
regarded as belonging to the base class. Thus, objects of the derived class are just 
specialized objects of the base class. For this reason, the derived class is often called a 
subclass of the base class, and the base class is called a superclass of the derived class. 
Multiple Inheritance 
C++ supports multiple inheritance in which a derived class simultaneously derives from 
two or more base classes. Though interesting, multiple inheritance can lead to programs 
that are very difficult to understand and is rarely useful in practice. You can find a 
discussion of it in Appendix H on the book's companion website. 
Appendix F on the book 's compan ion website shows how to represent inheritance 
using UML. 
Protected Members and Class Access 
CONCEPT: 
Protected members of a base class are like private members, except they 
may be accessed by derived classes. The base class access specification 
determines how private, protected , and public base class members are 
accessed when they are inherited by the derived class. 
Until now you have used two access specifications within a class: private and pub 1 i c. 
C++ provides a third access specification, protected. 
Protected members of a base 
class are like private members, except they may be accessed by member functions of a 
derived class. Protected members are inaccessible to all other code in the program .· 
Let us supp ose we want to add to the Facu lty class a constr uctor that takes as 
parameter the name and department of a professor. The best way to accomplish this is 
to have the constructor call the set Name () member function inherited from the Person 
class. To illustrate the use of protected members, however, we will change the access 
specification of the name field of the Person class to protected 
and have the Faculty 
constructor access it directly. We make similar changes to the Student class, adding a 
constructor that takes parameters and sets the protected member name. The resulting 
code is stored in the i nheri tance1. h file: 
Contents of I nher i tance1 . h 
1 #include 
<str i ng> 
2 #include 
<memory> 
3 using namespace std ; 
4 
5 enum class 
Disc i pline 
{ARCHEOLOGY
, BIOLOGY, COMPUTER
_SCIENCE); 
6 enum class Classificat
i on {FRESHMAN
, SOPHOMORE, 
JUNIOR, SENIOR); 
7 
'Friend functions and friend classes have access to both private and protected members 

788 
Chapte r 11 
More about Classes and Object-Oriented Programming 
8 class 
Person 
9 { 
10 protected: 
11 
str i ng name; 
12 pub 1 i C: 
13 
Person () { set Name ( "") ; } 
14 
Person(const 
string& 
pName) { setName(pName); 
} 
15 
void setName(const 
str i ng& pName) {name= 
pName; } 
16 
str i ng getName() const 
{ return 
name; } 
17 } ; 
18 
19 class 
Student 
20 { 
21 private: 
public 
Person 
22 
Discipl
i ne major; 
23 
shared _ptr<Person>advisor; 
24 public: 
25 
II Constructor 
26 
Student(const 
string& 
sname, Disc i plined, 
27 
const shared _ptr<Person>& adv); 
28 
29 
void setMajor(Disc
i pline 
d) {major= 
d; } 
30 
Discipl
i ne getMajor() 
const 
{ return 
major; 
} 
31 
void setAdv i sor (const shared _ptr<Person>& 
p} {advisor= 
p; } 
32 
shared _ptr<Person> 
getAdvisor
() const 
{ return 
advisor; 
} 
33 } ; 
34 
35 class 
Faculty:public 
Person 
36 { 
37 private: 
38 
Discipl
i ne department
; 
39 public: 
40 
II Constructor 
41 
Faculty(const 
string& 
fname, Disc i plined) 
42 
{ 
43 
44 
45 
46 
47 
48 
49 
50 } ; 
II Access the protected 
base class 
member 
name= fname; 
department= 
d; 
} 
II Other member functions 
void setDepartment(D
i scipline 
d) {department= 
d ; } 
Discipl
i ne getDepartment(} 
const 
{ return 
department; 
} 
Content s of i nheri tance1 . cpp 
1 #include 
"inher i tance1.h" 
2 //********************************************* 
3 II Constructor 
for the Student 
class. 
* 
4 //********************************************* 
5 Student: :Student(const 
str i ng& sname , Disciplined, 
6 
const 
shared _ptr<Person>& 
adv} 
7 { 
8 
II Access the 
protected 
member name 
9 
name= sname; 

11.13 Protected Membe rs and Class Access 
789 
10 
11 
// Access the other members 
12 
major= 
d; 
13 
adv i sor= 
adv; 
14 } 
Program 11-23 demonstrate s the use of these classes. 
Program 11 -23 
1 //This 
program demonstrates 
the use of 
2 //objects 
of derived 
classes. 
3 #include 
"inheritance1.h" 
4 #include 
<iostream> 
5 #include 
<memory> 
6 using namespace std; 
7 
8 // These arrays 
of str i ng are used to print 
9 II values 
of enumerated 
types 
10 const 
str i ng dName[J = 
11 { "Archeology", 
"Bi ology", 
"Computer Sci ence" }; 
12 
13 const 
str i ng cName[J = 
14 { "Freshman", 
"Sophomore", 
15 
16 int main() 
17 { 
"Junior" 
''Seni or" }· 
' 
' 
18 
// Create 
Faculty 
and Student 
objects 
19 
shared _ptr<Faculty> 
20 
prof= 
make_shared<Faculty>("Ind
i ana Jones", 
21 
Discipline: 
:ARCHEOLOGY); 
22 
shared _ptr<Student> 
23 
st= 
make_shared<Student>("Sean 
Bolster"
, 
24 
Disc i pline::ARCHEOLOGY, prof); 
25 
26 
cout <<"Professor"<< 
prof - >getName() <<"teaches" 
27 
<< dName[static
_cast<int>(prof
- >getDepartment())J 
28 
29 
<< " . " << endl ; 
30 
//Get student's 
advisor 
31 
shared _ptr<Person> 
pAdvisor = st - >getAdvisor(); 
32 
cout << st - >getName() << "\'s 
advisor 
is" 
33 
<< pAdvisor - >getName() << "."; 
34 
cout << endl; 
35 
36 
return 
O; 
37 } 
Program Output 
Professor 
Indiana 
Jones teaches 
Archeology. 
Sean Bolster's 
advisor 
is Indiana 
Jones. 

790 
Chapte r 11 
More about Classes and Object -Oriented Programming 
Although our example does not show it, member functions of a base class can be 
declared protected as well. Protected member functions can be called by member 
functions of derived classes, as well as by friend functions and friend classes. 
Base Access Specifications 
In addition to public, C++ permits the use of protected and private as base access 
specifications, as illustrated in the following (incompletely specified) examp les 
class 
Cat : prot ected Felin e 
{ 
} ; 
class 
Dog 
privat e Cani ne 
{ 
} ; 
Be careful not to confuse base access specification with member access specification. 
Member access specification determines the type of access for members defined in the 
class, whereas base access specification determines the type of access for inherited 
members . Table 11-3 and Figure 11-8 show the interplay between member access 
specification in the base class and base class specification that determines access to the 
inherited member. 
Table 11-3 Base Class Access Specifications 
Base Class Access 
Specification 
private 
protect
ed 
publ i c 
How Members of the Base Class Appear in the Derived Class 
• Private members of the base class are inaccessible to the derived class. 
• Protected members of the base class become private members of the 
derived class. 
• Public members of the base class become private members of the 
derived class. 
• Private members of the base class are inaccessible to the derived class. 
• Protected members of the base class become protected members of 
the derived class. 
• Public members of the base class become protected members of the 
derived class. 
• Private members of the base class are inaccessible to the derived class. 
• Protected members of the base class become protected members of 
the derived class. 
• Public members of the base class become public members of the 
derived class. 

11.13 Protected Membe rs and Class Access 
791 
Figure 11-8 
How base class 
members appear 
Base class members 
in the derived class 
private: 
private 
x is inaccessible. 
X 
base class 
protected : y 
private: 
y 
public: z 
private: z 
protected 
private: 
x is inaccessible. 
X 
base class 
protected : y 
protected : y 
public: z 
protected : z 
private: 
X 
public 
base class 
x is inaccessible. 
protected : y 
protected : y 
public: z 
public: z 
~ 
Checkpoint 
11.41 What type of relationship between classes is realized by inheritance? 
11.42 Why does it make sense to think of a base class as a superclass of its derived class? 
11.43 What is a base class access specification? 
11.44 Think of an example of two classes where one class is a special case of the other, 
and write declarations for both classes, with the special case being written as a 
derived class. 
11.45 What is the difference between private members and protected members? 
11.46 What is the difference between member access specification and base class 
access specification? 
11.4 7 Suppose a program has the following class declarat ion: 
class CheckPoint 
{ 
private: 
i nt a; 
protected: 
i nt b; 
i nt c; 
void setA(int 
x ) {a= 
x;} 
public: 
void setB(int 
y) 
{ b = y;} 
void setC(int 
z) { c = z ;} 
} ; 
Answer the following questions. 
A) Suppose another class, Quiz, is derived from the CheckPoi nt class. Here is 
the first line of its declaration: 
class Quiz : private 
CheckPoi nt 

792 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
Indicate whether each member of the CheckPoi nt class is private , protec te d, 
pub 1 i c, or inaccessible: 
a 
b 
C 
setA 
setB 
setC 
B) Suppose the Quiz class, derived from the CheckPoi nt class, is declared as 
class 
Quiz : protec te d Checkpoi nt 
Indicate whether each member of the CheckPoi nt class is privat e, protec te d, 
pub 1 i c, or inaccessible: 
a 
b 
C 
setA 
setB 
setC 
C) Suppose the Quiz class, derived from the CheckPoi nt class, is declared as 
class 
Quiz : public Checkpoint 
Indicate whether each member of the CheckPoi nt class is private, protected , 
pub 1 i c, or inaccessible: 
a 
b 
C 
setA 
setB 
setC 
D) Suppose the Quiz class, derived from the CheckPoi nt class, is declared as 
cl ass Quiz : Checkpoi nt 
Is the CheckPoi nt class a private, public , or protected base class? 
11.14 Constructors, 
Destructors, and Inheritance 
CONCEPT: 
When an object of a derived class is being instanti ated, the base class 
constructor is called before the derived class constru ctor. When the 
object is destroyed, the derived class destruct or is called before the base 
class destructor. 
Recall that constructors are automatically called by the compiler whenever an object of a 
class is being created. Because every object of a derived class can be regarded as having 
an object of the base class embedded within it, the creation of a derived class object 
involves the creation of the embedded base class object. The compiler will always call the 
base class constructor before it calls the derived class constructor. This order is reversed 

11.14 Constructors, Destructors, and Inheritance 
793 
upon destruction of a derived class object; the destructor in the derived class is called 
before the destructor in the base class. This order permits the derived class constructors 
and destructors to use data or member functions of the base class in doing their work. 
Program 11-24 illustrates this behavior in a simple program. 
Program 11 -24 
1 // Thi s program demonstrates 
the order 
i n which base and 
2 II derived 
class 
constructors 
and destructors 
are called. 
3 #include 
<iostream> 
4 #include 
<memory> 
5 using namespace std ; 
6 
7 II Base class 
8 class 
BaseDemo 
9 { 
10 publ i C: 
11 
BaseDemo() 
II Constructor 
12 
{ 
13 
cout << "This is the BaseDemo constructo
r.\n"; 
14 
} 
15 
vi rtual 
-BaseDemo() II Destructor 
16 
{ 
17 
cout << "This i s the BaseDemo destructor.\n"; 
18 
} 
19 } ; 
20 
21 II Derived class 
22 class 
Deri Demo 
public 
BaseDemo 
23 { 
24 public: 
25 
Deri Demo() 
/ /Constructor 
26 
{ 
27 
cout << "This is the DeriDemo constructo
r.\n"; 
28 
} 
29 
vi rtual 
-DeriDemo(} 
II Destructor 
30 
{ 
31 
cout << "This is the DeriDemo destructor.\n"; 
32 
} 
33 }; 
34 
35 int main() 
36 { 
37 
cout << "We wi 11 now create 
a Deri Demo object. 
\ n" ; 
38 
shared _ptr<Der i Demo> d 
= make_shared<DeriDemo>(); 
39 
cout << "The program is now going to end . \n"; 
40 
return 
O; 
41 } 
Program Output 
We will 
now create 
a DeriDemo object. 
This is the BaseDemo constructor. 
This is the DeriDemo constructor. 
The program is now going to end. 
This is the DeriDemo destructor. 
This is the BaseDemo destructor. 

794 
Chapter 11 
0 
More about Classes and Object-Oriented Programming 
NOTE: It is good programming practice to tag the destructors of base and derived 
classes with the key word vir t ual. We will study the concept of virtua l member 
functions in Chapter 15. 
Passing Arguments to Base Class Construdors 
As already mentioned, the compiler will automat ically call a base class constructor 
before executing the derived class constructor. The compiler's default action is to call 
the default constructor in the base class. Some classes, however, may not have a default 
constructor. Also, the programmer may want to specify which of several base class 
constructors should be called during the creat ion of a derived class object . 
In these cases, the programmer must explicitly specify which base class constructor 
shou ld be called by the compiler. This is done by specifying the arguments to the 
selected base class constructor in the definition of the derived class constructor. 
The syntax for passing arguments to base class constructors is simple: The header for 
the derived class constructor is followed by a colon, an indication of which base class 
constructor to call, and the arguments to be passed. To illustrate, we will modify the 
constructor for the Faculty class so that it invokes a constructor in the Person class. 
The constructor in its previous form was 
Facul t y(const 
str i ng& f name, Di sci pl i ne d) 
{ 
) 
name= fna me; 
depart ment= 
d; 
It now becomes 
Facul t y(const 
str i ng& f name, Di sci pl i ne d) 
{ 
depart ment= 
d; 
) 
Person(fname) 
Notice that one of the arguments passed to the derived class constructor is passed to 
the base class constructor. In general, the argument passed to the base class constructor 
may be any expression and may involve any variables that are in scope at the point of 
the call to the derived class constructor. For example, a string literal, or even a global 
string variable, could have been passed as the argument to the Person constructor. If, 
for example, it was desired that the name of a faculty member default to that of the 
ubiquitous "Dr. Staff," the following constructor would be just what we want: 
Facul t y(Discipl i ne d) : Person("Staff") 
{ 
depart ment= 
d; 
) 
In general, the base class constructor may take any number of parameters . 
Contents of i nher i t ance2. h 
1 #include 
<str i ng> 
2 #include 
<memory> 
3 using namespace std; 

11.14 Constructors, Destructors, and Inheritance 
795 
4 
5 enum class 
Disc i pline 
{ARCHEOLOGY, 
BIOLOGY, COMPUTER
_SCIENCE}; 
6 enum class 
Classificat
i on {FRESHMAN, 
SOPHOMORE, 
JUNIOR, SENIOR}; 
7 
8 class 
Person 
9 { 
10 protected: 
11 
str i ng name; 
12 pub 1 i C: 
13 
Person () { set Name ( "") ; } 
14 
Person(const 
string& 
pName) { setName(pName); 
} 
15 
void setName(const 
str i ng& pName) {name= 
pName; } 
16 
str i ng getName() const 
{ return 
name; } 
17 } ; 
18 
19 class 
Student:public 
Person 
20 { 
21 private: 
22 
Discipl
i ne major; 
23 
shared _pt r<Person> adv i sor; 
24 public: 
25 
II Constructor
. 
26 
Student(const 
string& 
sname, Disc i plined, 
27 
const shared _ptr<Person>& adv); 
28 
29 
void setMajor(Disc
i pline 
d) {major= 
d; } 
30 
Discipl
i ne getMajor() 
const 
{ return 
major; 
} 
31 
void setAdv i sor(const 
shared _ptr<Person>& p) {adv i sor= 
p; } 
32 
shared _pt r<Person> getAdvisor() 
const 
{ return 
advisor; 
} 
33 } ; 
34 
35 class 
Faculty 
:public 
Person 
36 { 
37 private: 
38 
Discipl
i ne department
; 
39 public: 
40 
II Constructor 
41 
Faculty(const 
string& 
fname, Disc i plined) 
{ 
department= 
d; 
} 
Person(fname) 
42 
43 
44 
45 
46 
47 
48 } ; 
void setDepartment(D
i scipline 
d) {department= 
d ; } 
Discipl
i ne getDepartment(} 
const 
{ return 
department; 
} 
Contents of i nheri tance2 . cpp 
1 #include 
"inher it ance2.h" 
2 
3 
//********************************************* 
II Constructor 
for the Student 
class. 
* 
4 //********************************************* 
5 Student: :Student(const 
str i ng& sname, Di sciplined, 
6 
const 
shared _ptr<Person>& 
adv} 
7 
Person(sname} 
II Base constructor 
initialization 
8 { 
9 
major= 
d; 
10 
adv i sor= 
adv ; 
11 } 

796 
Chapte r 11 
More about Classes and Object-Orien ted Programming 
The new constructors are demonstrated in Program 11-25App on the book's companion 
website, which is virtually the same as Program 11-23. The only difference is that 
Program 11-25App includes i nheritance2.h 
rather than inheritance1 
.h, and must 
be compiled and linked with i nheri tance2. cpp. It can be found in the file Pr11 -25App 
on the book 's companion website. 
It is important to remember that the arguments to the base class constr uctor must 
be specified in the definition of the derived class constructor, and not in its declaration. In 
the case of the Student class, the declaration of the constructor occurs at line 26 of the 
i nheri tance2. cpp file. The corresponding definition starts at line 5 of the i nheri tance2. cpp 
file and specifies the argument to pass to the Person superclass in line 7. 
~ 
Checkpoint 
11.48 What is the reason that base class constr uctors are called before derived class 
constr uctors? 
11.49 Why do you think the arguments to a base class constructor are specified in the 
definition of the derived class constructor rathe r than in the declarat ion? 
11.50 Passing arguments to base classes constr uctors solves the problem of selecting a 
base class constructo r in inheritance. Can the same problem arise with 
composit ion? That is, might there be a case where a constructor of a class might 
have to pass arguments to the constructor of a contained class? If so, guess the 
syntax that would be used to pass the parameters , and constr uct a simple examp le 
to verify your guess. 
11.51 What will the following program display? 
#include 
<iostream> 
#include 
<memory> 
us i ng namespace std; 
class 
Base 
{ 
publ ic : 
Base () { cout << "Entering 
the base .\n"; 
} 
vi rtual 
-Base () { cout << "Leav i ng the base.\n"; 
} 
} ; 
class 
Camp : publ i c Base 
{ 
publ ic : 
Camp() { cout << "Ent ering 
the camp.\n"; 
} 
vi rtual 
-Camp() { cout << "Leav i ng the camp.\n"; 
} 
} ; 
int mai n(} 
{ 
} 
shared _ptr<Camp> outpost
= make_shared<Camp> (); 
return 
O; 
11.52 What will the following program display? 
#include 
<iostream> 
#include 
<string> 
#include 
<memory> 

us i ng namespace 
std; 
class 
Base 
{ 
publ ic : 
11.15 Overrid ing Base Class Functions 
797 
Base() 
{ cout << "Ent ering 
the base .\n"; 
} 
Base(string 
str) 
{ 
cout << "This base is"<< 
str 
<< " . \ n"; 
} 
virtual 
-Base () { cout << "Leaving the base.\n"; 
} 
} ; 
class 
Camp : publ i c Base 
{ 
publ ic : 
Camp() { cout << "Ent ering 
the camp.\n"; 
} 
Camp(string 
str1, 
string 
st r 2) : Base (st r1) 
{ 
cout << "The camp is"<< 
str2 
<< " . \ n"; 
} 
} ; 
int main (} 
{ 
} 
shared _ptr<Camp> 
outpost= 
make_shared<Camp> ("s ec ur e ", "seclu ded "); 
return 
O; 
11.15 Overriding Base Class Functions 
a 
VideoNot e 
Overriding 
Base Class 
Functions 
CONCEPT: 
A derived class can override a member function of its base class by defining 
a derived class member function with the same nam e and param eter list. 
It is often useful for a derived class to define its own version of a member funct ion 
inhe rited from its base class. Th is may be done to specialize the member function to the 
needs of the derived class. When this happen s, the base class member function is said to 
be overridden, or redefined, by the derived class . 
As a simple example, suppose that we want to have a class Tfac ul ty that will allow us to 
associate with each member of the faculty a title such as "Dr. ," "Professor," or "Dean." 
To accomplish this, we derive the new class from the Faculty class by adding a title 
data member , an approp riate constructo r, a member function to set the title, and then 
overr iding the inherited getName (} member function to return a "titled" name. 
class 
TFaculty
: public 
Faculty 
{ 
private: 
string 
tit l e ; 
publ ic : 
// This Constructor 
allows 
the specificat
i on of a tit l e 
TFaculty
(const 
string& 
fname, Disc i plined
, str i ng title) 
Faculty(fname, 
d} 
{ 
} 
setTitle(title); 

798 
Chapte r 11 
More about Classes and Object-Oriented Programming 
voi d se t Title(cons
t string& 
title) 
{ t his - >title 
= title; 
) 
// Override 
t he get Name function 
string 
get Name( ) cons t { return 
tit le
+ " "+ 
name; ) 
) ; 
Program 11-25 illustrates the use of this class and its overr idden member function. It uses 
the files i nher i tance3. h and i nheri t ance3 . cpp. The i nheri tance3. h file is just 
i nher i tance2. h with the class declaration of TFacul ty added, and i nher i t ance3. cpp is 
the same as i nher i t ance2. cpp. Code listings of i nher i t ance2. hand i nheri tance2. cpp 
can be found at the end of Section 11-14. Copies of all these files are included on the 
book's companion website. 
Program 11-25 
1 #include 
<str i ng> 
2 #include 
<memory> 
3 using namespace std; 
4 
5 enum class 
Discipl i ne {ARCHEOLOGY, 
BIOLOGY, COMPUTER
_SCIENCE); 
6 enum class 
Classif
i cat i on {FRESHMAN, SOPHOMORE, 
JUNIOR, SENIOR); 
7 
8 class 
Perso n 
9 { 
10 pro t ected: 
11 
str i ng name; 
12 publ i C: 
13 
Perso n() { setName(""); 
) 
14 
Perso n(const 
str i ng& pName) { setName(pName); 
} 
15 
void setName(const 
str i ng& pName) {na me= 
pName; } 
16 
str i ng getNa me() cons t { re t urn name; } 
17 } ; 
18 
19 class 
Stude nt :public 
Person 
20 { 
21 private: 
22 
Di scipl i ne major; 
23 
shared _pt r<Person> adv i sor; 
24 public: 
25 
Stude nt (cons t stri
ng& sname, Disc i plined, 
26 
cons t shared _ptr<Person>& adv); 
27 
void setMajor(Disc
i pline 
d) {major= 
d; } 
28 
Di scipl i ne getMaj or() 
const 
{ retur n major; 
} 
29 
void setAdvisor(const 
shared _ptr<Person> 
p) {advisor= 
p; } 
30 
shared _pt r<Person> get Advisor() 
cons t { re t urn adv i sor; 
} 
31 } ; 
32 
33 class 
Faculty 
:public 
Person 
private: 
34 { 
35 
36 
Di scipl i ne department; 
37 public: 
38 
Faculty(cons
t stri
ng& 
39 
{ 
40 
depart ment= 
d; 
fname, Disc i plined) 
Perso n(fname) 
(program continues) 

11.15 Overriding Base Class Functions 
799 
Program 11 -25 
(continued) 
41 
} 
42 
void setDepartment(D
i scipline 
d) { department
= d ; } 
43 
Di scipline 
getDepa r t ment () const 
{ return 
department; 
} 
44 }; 
45 
46 class 
TFaculty 
public 
Faculty 
47 { 
48 private: 
49 
string 
title; 
50 public: 
51 
II Thi s Constructor 
allows the spec i f i cation 
of a title 
52 
TFaculty(const 
string& 
fname, Di sciplined, 
string 
tit l e ) 
53 
: Faculty(fname, 
d) 
54 
55 
{ 
56 
} 
setTitle(t
i tle); 
57 
void setT i t l e (co nst string& 
title) 
{ this - >title 
= tit l e ; } 
58 
59 
II Override 
the getName funct i on 
60 
str i ng getName() const 
{ ret urn t i tle
+ " "+ 
name ; } 
61 } ; 
Program Output 
Dr. Indiana 
Jones teaches 
Archeology. 
Sean Bolster's 
advisor 
is Indiana 
Jones. 
Choosing Between Base and Derived Class Versions 
of an Overriden Function 
An object of a derived class that has overridden a base class member function contains 
more than one version of the member function. The compiler will determine which of the 
several versions to call by using type information in the expression used to make the call to 
the member function. For example, in Program 11-25, there are two calls to get Name(}: 
1. The call prof. get Name () returns Dr . Indiana 
Jones because the function is 
called through prof, which has type TFaculty. The compiler calls the TFaculty 
version get Name () . 
2. The call pAdvi sor - >getName () returns Indiana Jones without the "Dr." because 
the function is called through the pointer pAdvi sor, which is a pointer to Person. 
The compiler calls the Person version of get Name () . 
The Difference Between Overloading and Overriding 
Both overloading and overriding involve the definition of different functions with the 
same name. There are differences between the two concepts, however. Overriding can 
only be done in the context of inheritance and refers to the defining of a member function 
by a derived class when the base class already has a member function of the same name 
and parameter list. Overloading refers to the definition of different functions within the 

800 
Chapte r 11 
11111111 
11.16 
~ 
More about Classes and Object-Oriented Programming 
same class with the same name and different parameter lists. Overloading can also refer to 
the definition of different functions with different parameter lists at the global level. 
Gaining Access to an Overridden Member Function 
If a derived class overrides a base class member function, member functions of the 
derived class that would have otherwise called the overridden base class member 
function will now call the version in the derived class. It is occasionally useful to be able 
to call the overridden version . In fact, the new member function of the derived class may 
want to call the base class member function that it is overriding . This is done by using 
the scope resolution operator to specify the class of the overridden member function 
being accessed. For example, a member function of TFacul ty that is to call the getName 
function of Person can do so in this fashion: 
Person ::get Name(); 
Thus, a better version of the TFacul ty class is the following. Note that the overriding 
function does not need to access any protected members of Person , but instead calls 
the public member function getName. 
class TFaculty 
: public Faculty 
{ 
private: 
str i ng title; 
public: 
TFaculty(const 
str i ng& fname , Di sciplined, 
string 
tit le) 
Faculty(fname
, d) 
{ 
} 
setTitle(title}; 
void setTitle(const 
string& t i tle) 
{ this - >t it le = tit le; 
} 
// Override getName() by call i ng Person: :getName 
str i ng getName( ) const 
{ 
} 
} ; 
return 
tit le+" 
"+ Person::getName(); 
Code for the program demonstrat ing this can be found in files Pr11 -26App. cpp, 
i nheri tance4. h, and i nheri tance4. cpp on the book's companion website. 
Tying It All Together: Putting Data on the 
World Wide Web 
The ability to generate output formatted in HTML (Hypertext Markup Language ) is 
important to programs that interact with users via the World Wide Web. Th ese 
applications include Web servers and Web-based E-commerce appl ications such as 
Amazon and eBay. Often the information displayed by these programs must be formatted 
using HTML tables. 

11.16 Tying It All Together: Putting Data on the World Wide Web 
801 
HTML tables are quite simple. They consist of rows of cells where each cell holds a 
unit of information referred to as table data. The information comprising the table is 
marked with HTML tags as shown in Table 11-4. 
Table 11 -4 HTML Tags fo r Formatting Tables 
<table> 
</table> 
<tr> 
</tr> 
<td> 
<ltd> 
<th> 
</th> 
Marks the beginning of the table 
Marks the end of the table 
Marks the beginning of a row in the table 
Marks the end of a row in the table 
Marks the beginning of data in a single cell of the table 
Marks the end of data in a single cell of the table 
Marks the beginning of the header for a single column of the table 
Marks the end of the header for a single column of the table 
The <table> 
tag normally causes a browser to display tables with no borders. To 
display tables with borders, the border attribute can be used. For example, the data 
table shown in Table 11-5 can be displayed using the following HTML markup, 
identified here as the contents of a file named table. html . The file can be found on the 
book's companion website. 
Table 11 -5 Sample Input Data for the HTML Table Program 
Name 
Address 
Mike Sane 
Natasha Upenski 
1215 Mills St 
513 Briarcliff Ln 
Contents of table. html 
<tab l e border= 
"1"> 
<tr> 
<th> 
<th> 
<th> 
</tr> 
<tr> 
<td> 
<td> 
<td> 
</tr> 
<tr> 
Name 
</th> 
Address </th> 
Phone 
</th> 
Mike Sane 
</td> 
1215 Mil ls St </td> 
630-728-1293 
<ltd> 
<td> Natasha Upenski 
</td> 
<td> 513 Briarc l iff 
Ln <ltd> 
<td> 412-672-1004 
<ltd> 
</tr> 
</table> 
Phone 
630-555-1293 
412-555 -1004 

802 
Chapte r 11 
More about Classes and Object -Oriented Programming 
If you use Microsoft Windows, you can display this table in your browser by 
double-clicking on the file tab l e . html in Windows Explorer, or by using Open in the 
File menu of your browser. 
Let's write a program that converts a two -dimensional array of strings into an HTML 
table capab le of being displayed in a Web browser. The centerpiece of our program is 
an HTMLTabl e class with two member variables 
vector<string> 
headers; 
vector<vector<str
i ng>> rows; 
that represent the headers and the rows of the table. The headers constitute a single 
vector of strings, while the rows of the table are represented by a vector of vectors. The 
HTMLTable class has a member function setHeaders() 
for setting the headers and a 
member function addRow () for adding rows to the table. The class also has an overloaded 
stream output operator 
ostream & operator 
<<(ostream 
&out, HTMLTable hTabl e); 
that is used to convert the table data stored in the headers and rows vectors into 
HTML markup and write that markup onto an output stream. If the stream receiving 
the markup is a file, you can open the file in a browser for viewing. Alternatively, if 
your system has established a default browser for opening files with an . html extension, 
you can use the C++ library function 
system("fi7e
_ 7ocation.htm7"); 
to make the operating system open the HTML file using the default browser. This, of 
course, assumes that the HTML markup is stored in a file named "fi 1 e_ 1 ocat ion. htm 1 . " 
We learned in this chapter that a derived class object can be used wherever a base class 
object is expected. We use this fact to allow for more flexibility in the data that is 
passed as parameters to functions. We build this flexibility into an overloaded stream 
output operator. The overloaded stream output operator is able to write the standard 
output object cout because cout is an ostream object . It is also able to write to an 
ofstream object because of stream inherits from ostream. 
Program 11 -26 
1 II Thi s program demonstrates 
the use of classes 
to 
2 II to put tabu l ar data on the World Wi de Web. 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 #include 
<str i ng> 
6 #include 
<vector> 
7 using namespace std; 
8 
9 II Thi s class 
al l ows a 2-d i mensional 
tab l e expressed 
as 
10 II a vectors 
of vector 
of strings 
to be transformed 
i nto 
11 II HTML form . 
12 cl ass HTMLTable 
13 { 
14 private: 
15 
vector<str
i ng> headers; 
16 
vector<vector<str
i ng>> rows; 
17 
II Helper method for wri ting an HTML row in a table 
18 
voi d writeRow(ostream 
&out, string 
tag, 
vector<string> 
row); 
(program continues) 

11.16 Tying It All Together: Putting Data on the World Wide Web 
80 3 
Program 11 -26 
(continued) 
19 
20 
21 
publ ic: 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 }; 
34 
II Set headers 
for the tab l e columns 
voi d setHeaders(const 
vector<str
i ng> 
{ 
this - >headers 
= headers; 
} 
II Add rows to the tab l e 
&headers) 
voi d addRow(const vector<string> 
&row) 
{ 
rows .push_back(row); 
} 
II Write the table 
i nto HTML form onto an output 
stream 
fr i end 
ostream& operator<<(ostream 
& out, 
HTMLTable htmlTab l e}; 
35 
36 
37 
38 
39 
//************************************************************ 
II Wri tes a row of the table, 
using the gi ven tag for the 
II table 
data. 
The tag may be td for tab l e data or th for 
II table 
header. 
* 
* 
* 
//************************************************************ 
40 void HTMLTabl e: :wri teRow(ostream 
&out, string 
tag, 
41 
vector<string> 
row} 
42 { 
43 
44 
45 
46 
47 
48 
49 
50
} 
51 
out 
for 
{ 
} 
<< "<tr>\n"; 
(uns i gned int k = O; k <headers.s
i ze(); 
k++) 
out<<"<"<< 
tag<<">" 
<< row[k] <<"<I"<< 
tag << "> "· 
out<< 
"\n<ltr>\n"; 
//****************************************************** 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68
} 
69 
II Overloaded 
stream output 
operator<< 
* 
//****************************************************** 
ostream & operator<<(ostream 
&out, HTMLTabl e htmlTable) 
{ 
out<< 
"<table 
border= 
\"1\">\n"; 
II Write the headers 
htmlTab l e .writeRow(out, 
"th", 
htmlTab l e .headers); 
II Write the rows of the tab l e 
for (uns i gned int r = O; r < htmlTable.rows
.si ze(); 
r++) 
{ 
html Table.wr i teRow(out, 
"td", 
html Table.rows[r
] }; 
} 
II Write end tag for 
out<< 
"<ltab l e>\n"; 
return 
out; 
tab l e 
70 int main() 
71 { 
72 
II Hard-coded data for tab l e column headers 
73 
vector<str
i ng> headers 
{ "Name", "Address", 
"Phone"}; 
74 
75 
II Hard-coded data for the two rows of the table 
76 
II 
(program continues) 

804 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Program 11 -26 
(continued) 
77 
vector<str
i ng> person1 
78 
{ "Mike Sane", 
"1215 Mil ls St", 
"630-728-1293" 
}; 
79 
vector<str
i ng> person2 
80 
{ "Natasha Upenski", 
"513 Briarc l iff 
Ln", "412-672-1004" 
}; 
81 
82 
II Create 
the HTML table 
obj ect and set i ts members 
83 
HTMLTable hTable; 
84 
hTabl e .setHeaders(headers); 
85 
hTabl e .addRow(person1}; 
86 
hTabl e .addRow(person2}; 
87 
88 
II Open a file 
and write 
the HTML code to the file 
89 
ofstream 
outFile("c:\\temp\\table.html"); 
90 
outFile 
<< hTabl e; 
91 
outFile.close(); 
92 
93 
II Write the same HTML code to the screen 
for ease of vi ewing 
94 
cout << hTable; 
95 
II 
Use the default 
browser to vi ew generated 
HTML table 
96 
system("c:\\temp\\tab
l e .html"); 
97 
98 
return 
O; 
99 } 
Program Output as Displayed In Browser 
I 
Name 
I Address I Phone 
jMike Sane 
I 1215 I\1Iills 
St 
1630-555-1293 
!Natasha Upenskil513 BriarcliffLnj412-555-1004 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. If a member variable is declared ____ 
, all objects of that class share that 
variab le. 
2. Static member variables are defined 
the class. 
----
3. A(n) ____ 
member function cannot access any nonstatic member variables 
in its own class. 
4. A static member function may be called ____ 
any instances of its class are 
defined. 

Review Questions and Exercises 
805 
5. A(n) _____ 
function is not a member of a class, but has access to the private 
members of the class. 
6. A(n) _____ 
tells the compiler that a specific class will be declared later in 
the program . 
7. ____ 
is the default behavior when an object is assigned the value of another 
object of the same class. 
8. A(n) _____ 
is a special constructor, called whenever a new object is initialized 
with another object's data . 
9. _____ 
is a special built-in pointer that is automatically passed as a hidden 
argument to all nonstatic member functions. 
10. An operator may be _____ 
to work with a specific class. 
11. When the _____ 
operator is overloaded, its function must have a dummy 
parameter . 
12. Making an instance of one class a member of another class is called ____ 
_ 
13. Object composition is useful for creating a(n) _____ 
relationship between 
two classes. 
14. A constructor that takes a single parameter of a type different from the class type 
,s a _____ 
constructor. 
15. The class Stuff has both a copy constructor and an overloaded = operator. 
Assume that bl ob and cl ump are both instances of the St uff class. For each of the 
statements, indicate whether the copy constructor or the overloaded = operator 
will be called. 
Stu ff blob= cl ump; 
cl ump= blob; 
blob.operator=(c
l ump); 
showValues(blob); 
II Blob is passed by val ue. 
16. Explain the programming steps necessary to make a class's member variable static. 
17. Explain the programming steps necessary to make a class's member function 
static . 
18. Consider the following class declaration: 
cl ass Thing 
{ 
} ; 
private: 
int 
x; 
int y; 
stat i c i nt z; 
publ i c: 
Thi ng() 
{ 
X = y = z; 
} 
stat i c void putThi ng(i nt a) 
{ z = a; } 
i nt Thing:: 
z = 0: 

806 
Chapte r 11 
More about Classes and Object -Oriented Programming 
Assume a program containing the class declaration defines three Thing objects 
with the following statement: 
Thi ng one, two, th ree; 
A) How many separate instances of the x member exist? 
B) How many separate instances of the y member exist? 
C) How many separate instances of the z member exist? 
D) What value will be stored in the x and y members of each object? 
E) Write a statement that will call the put Thing member function before the 
Thing objects are defined. 
19. Describe the difference between making a class a member of another class (object 
composition) and making a class a friend of another class. 
20. What is the purpose of a forward declaration of a class? 
21. Explain why memberwise assignment can cause problems with a class that 
contains a pointer member. 
22. Explain why a class's copy constructor is called when an object of that class is 
passed by value into a function. 
23. Explain why the parameter of a copy constructor must be a reference. 
24. Assume a class named Bi rd exists. Write the header for a member function that 
overloads the = operator for that class. 
25. Assume a class named Dollars exists. Write the headers for member functions 
that overload the prefix and postfix ++ operators for that class. 
26. Assume a class named Yen exists. Write the header for a member function that 
overloads the < operator for that class. 
27. Assume a class named Length exists. Write the header for a member function that 
overloads the stream insertion << operator for that class. 
28. Assume a class named Co 11 ect ion exists. Write the header for a member function 
that overloads the [] operator for that class. 
29. Explain why a programmer would want to overload operators rather than use 
regular member functions to perform similar operations. 
Find the Error 
30. Each of the following class declarations has errors. Locate as many as you can. 
A) class 
Box 
{ 
priva t e: 
double wi dth; 
double leng th ; 
double height; 
publ ic: 
Box(double w, l, h) 
{w i dth= 
w; lengt h = l; heig ht= 
h; } 
Box(Box b) // Copy constructor 
{w i dth= 
b.widt h; 
leng t h= b.length; 
height= 
b.height; 
} 

... Other member functions follow ... 
} ; 
B) class 
Circle 
{ 
priva t e: 
double diame t er; 
int centerX; 
int centerY; 
publ ic: 
Circle(double 
d, int x, i nt y) 
Review Questions and Exercises 
807 
{d i ameter= 
d; cen t erX = x; cen t erY = y; 
} 
//Overloaded= 
operator 
void Circle=(Circle 
&ri ght ) 
{diame t er= 
right.diame
t er; 
cen t erX = rig ht.centerX; 
ce nt erY = rig ht.centerY; 
} 
... Other member functions follow ... 
} ; 
C) class 
Poi nt 
{ 
private: 
int xCoord; 
i nt yCoord; 
publ ic: 
Point 
(i nt x, int y) 
{ xCoord = x; yCoord = y; } 
//Overloaded
+ opera t or 
void opera t or+(const 
&Poi nt Ri ght) 
{ xCoord += r i ght.xCoord; 
yCoord += r i ght.yCoord; 
} 
... Other member functions follow ... 
} ; 
D) class 
Box 
{ 
private: 
double wi dth; 
double l engt h; 
double height; 
publ ic: 
Box(double w, l, h) 
{wid th = w; length= 
l ; height= 
h ; } 
// Over l oaded prefix+
+ operator 
voi d operator
++() 
{ 
++wi dth; ++leng th ; } 
// Over l oaded postf i x ++ operator 
voi d operator
++() 
{width+ +; l ength++;} 
... Other member functions follow ... 
} ; 

808 
Chapte r 11 
More about Classes and Object-Oriented Programming 
E) cl ass Yar d 
{ 
pr ivat e : 
double l engt h; 
publ ic: 
Yard (double l ) 
{ len gth = l ; } 
II double conver s ion f unct i on 
voi d ope r at or doubl e (} 
{ r eturn le ngt h; } 
.. . Other member functions follow ... 
} ; 
Fill-in-the -Blank 
31. A derived class inherits the 
of its base class. 
----
32. The base class named in the following line of code is ___ 
_ 
c l as s Pet : publ ic Dog 
33. The derived class named in the following line of code is ____ 
_ 
c l as s Pet : publ ic Dog 
34. In the following line of code, the class access specification for the base class is 
c l as s Pet : publ ic Dog 
35. In the following line of code, the class access specification for the base class is 
c l as s Pet : Fi sh 
36. Protected members of a base class are like ____ 
members, except they may 
be accessed by derived classes. 
3 7. Complete the following table by filling in private, protected, public, or inaccessible 
in the right-hand column: 
In a private base class, this base class 
MEMBER access specification ... 
private 
protected 
public 
... becomes this access specification 
in the derived class. 
38. Complete the following table by filling in private, protected, public, or inaccessible 
in the right-hand column: 
In a protected base class, this base class 
MEMBER access specification ... 
private 
protected 
public 
... becomes this access specification 
in the derived class. 

Review Questions and Exercises 
809 
39. Complete the following table by filling in private, protected, public, or inaccessib le 
in the right -hand column: 
In a public base class, this base class 
MEMB ER access specification ... 
private 
protected 
public 
... becomes this access specification 
in the derived class. 
40. When both a base class and a derived class have constructors, the base class's 
constructor is called ____ 
(first/last). 
41. When both a base class and a derived class have destructors , the base class 's 
destructor is called ____ 
(first/last ). 
42. An overridden base class function may be called by a function in a derived class 
by using the ____ 
operator . 
Find the Errors 
43. Each of the following class declarations and/or member function definitions has 
errors. Find as many as you can. 
A) class 
Car , public 
Vehicle 
{ 
} 
public: 
Car(); 
-Car() ; 
protec t ed: 
in t passengers; 
B) class 
Truck , public 
: Vehi cle, 
publ ic 
{ 
private: 
double cargoWeight; 
public: 
Truck(); 
- Truck(); 
} ; 
Soft Skills 
44 . Your company's software is a market leader but is proving difficult to maintain 
because it was written in C without using object -oriented concepts. Customers 
have identified prob lems with the software that must be fixed immediately and 
have pointed out features in competitors' 
products that they want you to 
support. The best solution will require a complete OOP redesign and subsequent 
implementation 
but will take three years . Write a memo to company 
management 
outlining your recommendation 
for the course of action the 
company shou ld pursue. 

810 
Chapte r 11 
More about Classes and Object-Oriented Programming 
Programming 
Challenges 
1 . Check Writing 
Design a class Numbers that can be used to translate whole dollar amounts in the range 
0 through 9999 into an English description of the number. For example, the number 
713 would be translated into the string seven hundred thirteen, and 8203 would be 
trans lated into eight thousand two hundred three. 
The class should have a single integer member variable 
i nt number; 
and a collection of static string members that specify how to translate key dollar 
amounts into the desired format . For example, you might use static strings such as 
string 
lessTha n20[ ] = 
{" zero ", 
"one", 
... 1 
"e igh tee n", 
"nineteen"}; 
string 
hundred= 
"hundred"; 
string 
tho usand= 
"t housand"; 
The class shou ld have a constructor that accepts a non-negative integer and uses it to 
initialize the Numbers object. It should have a member function pri nt () that prints the 
English description of the Numbers object. Demonstrate the class by writing a main 
program that asks the user to enter a number in the proper range and then prints out 
its English description . 
2. Day of the Year 
Assuming that a year has 365 days, write a class named DayOfYear that takes an integer 
representing a day of the year and translates it to a string consisting of the month followed 
by day of the month . For example, 
Day 2 would be January 2. 
Day 32 would be February 1. 
Day 365 would be December 31. 
The constructor for the class should take as parameter an integer representing the day 
of the year, and the class should have a member function pri nt () that prints the day in 
the month -day format. The class shou ld have an integer member variab le to represent 
the day and shou ld have static member variables of type string 
to assist in the 
trans lation from the integer format to the month-day format . 
Test your class by inputting various integers representing days and printing out their 
representation in the month-day format . 
3. Day of the Year Modification 
Modify the DayOfYear class, written in an earlier Programming Challenge, to add a 
constructor that takes two parameters: a string representing a month and an integer in 
the range O through 31 representing the day of the month . The constructor should then 
initialize the integer member of the class to represent the day specified by the month 

a 
VideoNote 
Solving the 
Number of 
Days Worked 
Problem 
Programming Challenges 
8 11 
and day of month parameters. The constructor should terminate the program with an 
appropriate error message if the number entered for a day is outside the range of days 
for the month given. 
Add the following overloaded operators: 
++ prefix and postfix increment operators. These operators should modify the 
DayOfYear object so that it represents the next day. If the day is already the end of 
the year, the new value of the object will represent the first day of the year. 
-- prefix and postfix decrement operators. These operators should modify the 
DayOfYear object so that it represents the previous day. If the day is already the 
first day of the year, the new value of the object will represent the last day of 
the year. 
4. Number of Days Worked 
Design a class called NumDays. The class's purpose is to store a value that represents a 
number of work hours and convert it to a number of days. For example, 8 hours would 
be converted to 1 day, 12 hours would be converted to 1.5 days, and 18 hours would 
be converted to 2.25 days. The class should have a constructor that accepts a number 
of hours, as well as member functions for storing and retrieving the hours and days. 
The class should also have the following overloaded operators: 
• The addition operator +. The number of hours in the sum of two objects is the 
sum of the number of hours in the individual objects. 
• The subtraction operator-. The number of hours in the difference of two objects X 
and Y is the number of hours in X minus the number of hours in Y. 
• Prefix and postfix increment operators ++. The number of hours in an object is 
incremented by 1. 
• Prefix and postfix decrement operators --. The number of hours in an object is 
decremented by 1. 
5. Palindrome Testing 
A palindrome is a string that reads the same backward as forward . For example, the 
words mom, dad, madam and radar are all palindromes . Write a class Ps t ring that is 
derived from the STL st r i ng class. The Pstr i ng class adds a member function 
bool 
isPal
i ndrome( 
) 
that determines whether the string is a palindrome. Include a constructor that takes an 
STL st ring object as parameter and passes it to the string 
base class constructor. Test 
your class by having a main program that asks the user to enter a string. The program 
uses the string to initialize a Pstri ng object and then calls i sPal i ndrome() to determine 
whether the string entered is a palindrome. 
You may find it useful to use the subscript operator [ J of the string class: If st r is a 
string object and k is an integer, then st r [ k] returns the character at position k in 
the string. 

812 
Chapte r 11 
More abo ut Classes and Object-Oriented Programming 
6. String Encryption 
Write a class Encr ypt abl eStri ng that is derived from the STL string 
class. The 
Encrypt abl e string class adds a member function 
voi d encr ypt ( ) 
that encrypts the string contained in the object by replacing each letter with its successor in 
the ASCII ordering. For example, the string baa would be encrypted to ebb. Assume that all 
characters that are part of an Encrypta bl eStr i ng object are letters a, .. , z and A, .. , Z, and 
that the successor of z is a and the successor of Z is A. Test your class with a program that 
asks the user to enter strings that are then encrypted and printed. 
7. Corporate Sales 
A corpora tion has six divisions, each respons ible for sales to differen t geograph ic 
locations. Design a Di vSal es class that keeps sales data for a division, with the 
following members: 
• An array with four elements for holding four quarters of sales figures for the 
division. 
• A private static variable for holding the total corporate sales for all divisions for 
the entire year. 
• A member function that takes four arguments, each assumed to be the sales for 
a quarter. The value of the arguments should be copied into the array that holds 
the sales data . The total of the four argumen ts should be added to the static 
variable that holds the total yearly corpora te sales. 
• A function that takes an integer argument within the range of Oto 3. The argument 
is to be used as a subscript into the division quarterly sales array. The function 
should return the value of the array element with that subscript. 
Write a program that creates an array of six Di vSal es objects. The program should ask 
the user to enter the sales for four quarters for each division. After the data is entered, 
the program should display a table showing the division sales for each quarter. The 
program should then display the total corporate sales for the year. 
8. Rational Arithmetic I 
A rational number is a quotient of two integers. For example, 12/5, 12/-4, -3/4, and 
4/6 are all rational numbers . A rational number is said to be in reduced form if its 
denomina tor is positive and its numerator and denominato r have no common divisor 
other than 1. For example, the reduced forms of the rational numbers given above are 
12/5, - 311, -314, and 2/3. 
Write a class called Rat i onal with a constr uctor Rationa l (in t , in t ) that takes two 
integers, a numerator and a denomina tor, and stores those two values in reduced form 
in corresponding private members. The class should have a private member function 
voi d reduce () that is used to accomplish the transforma tion to reduced form. The 
class should have an overloaded insertion operator << that will be used for output of 
objects of the class. 

Programming Challenges 
813 
9. Rational Arithmetic II 
Modify the class Rationa l of Programming Challenge 8 to add overloaded operators 
+, - , *,and/ to be used for addition, subtraction, multiplication , and division. Test the 
class by reading and processing from the keyboard (or from a file) a series of rationa l 
expressions such as 
2 / 3 + 2 / 8 
2 / 3 * - 2 / 8 
2 / 3 -
2/ 8 
2 / 3 / 2 / 8 
To facilitate parsing of the input, you may assume that number s and arithmetic 
operators are separated by whitespace. 
10. HTML Table of Names and Scores 
Write a class whose constructor takes a vector of Stu dent objects, where each Studen t 
has a name of type str i ng and a score of type in t. The class internally stores the data 
passed to it in its constructor. The class should have an overloaded output operator 
that outputs its data in the form of an HTML table. Make up suitable input and use it 
to test your class. 
11. Prime Number Generation 
A positive integer greater than 1 is said to be prime if it has no divisors other than 1 
and itself. A positive integer greater than 1 is a composite if it is not prime. Write a 
program that asks the user to enter an integer greater than 1 and prints the list of all 
prime numbers less than or equal to the number entered. Your program should use a 
predicate (function object or a lambda) that determines whether a given integer is 
composite . The program should generate the list of prime numbers less or equal to X 
by adding all positive integers greater than 1 to a vector and then using the remove_ i f 
function and the predicate to remove all composites from the vector. 


TOPICS 
12.1 C-Strings 
12.5 More about the C++ string 
Class 
12.6 Advanced Software Enterprises 
Case Study 
12.2 Library Functions for Working with 
C-Strings 
12.3 Conversions Between Numbers and Strings 
12.4 Writing Your Own C-String Handling 
Functions 
12.7 Tying It All Together. Program Execution 
Environments 
12.1 
C-Strings 
CONCEPT: 
AC -strin g is a sequence of char acters stor ed in consecutive memor y 
locatio ns and termin ated by a null character. 
Many programs make extensive use of strings . C++ provides two different data types 
for working with strings: C-strings and the stri
ng class. The string 
class library has 
many functions for working with strings . These functions perform many useful string -
related functions and have programming safeguards that C-string handling functions 
lack . For all these reasons, you should prefer use of the stri
ng class over C-strings. 
Neverthe less, every C++ programmer should have a good understanding of C-strings. 
The string 
class is built on top of C-strings, so understanding C-strings helps you to 
understand the string 
class. There are also many programs that were written before 
the st r i ng class library was incorporated into the C++ standard. Such programs need 
programmers who understand C-strings to maintain them. Finally, programmers who 
write and maintain low-level code, such as the st r i ng class libraries and parts of the 
operating system, must use C-strings to represent string data . 
A C-string is a sequence of characters sto red in consec utive memory locations and 
terminated by a null character. Recall that the null character is the character whose 
ASCII code is 0. In a program, the null character is usually written '\O'. It is also common 
815 

816 
Chapte r 12 
More on C-Strings and the string 
Class 
Figure 12-1 
to use the integer O or the constant NULL to denote the null character in a program. 
Thus, all of the following statements store the null character into a character variable: 
char ch1, ch2, ch3; 
ch1 = '\O'; 
ch2 = O; 
ch3 = NULL; 
Because an array is a sequence of consecutive memory locations that store values of the 
same type, a C-string is really a null-terminated array of characters . C-strings can 
appear in a program in one of three forms: 
• "Hard -coded" string literals 
• Programmer -defined arrays of character 
• Pointers to character 
Regardless of which one of the three forms a C-string appears in a program, a C-string 
is always a null-terminated array of characters and is represented in the program by a 
pointer to the first character in the array . In other words, the type of a C-string is 
char* 
That is, the type of a C-string is pointer to char. 
String Literals 
String literals, also called string constants, are written directly into the program as a 
sequence of characters enclosed in double quotes: For example, 
"What i s your name?" 
"Bailey" 
are both string literals. 
When the compiler encounters a string literal such as "Bai 1 ey", it allocates an array of 
seven characters, stores the six characters of "Bailey" 
in the first six entr ies of the 
array, and then stores the null character in the last entry, as shown in Figure 12-1. The 
compiler treats the address of the first character of the array (which has type char *) as 
the value of the string literal. 
B 
a 
e 
y 
\0 
Program 12-1 illustrates the fact that a string literal is regarded by the compiler as a 
value of type cons t char *. The key word con st indicates that the compiler does not 
expect the programmer to alter the contents of the string literal. 
Program 12 -1 
1 //This 
program demonstrates 
tha t stri
ng l ite rals 
2 //ar e poi nt ers to char. 
3 #include 
<iostr eam> 
4 using namespace std; 
5 
6 int main () 
7 { 
(program continues) 

Program 12-1 
(continued) 
8 
II Defi ne variables 
th at are pointers 
to char 
9 
const char *p = nullptr, 
*q = nullp t r; 
10 
11 
II Ass i gn st ring literals 
t o t he poi nt ers to char 
12 
p ="Hello"; 
13 
q = "Bailey"; 
14 
15 
II Pri nt t he poi nters 
as G-s t r i ngs! 
16 
cout << p << q << endl; 
17 
18 
II Pri nt t he poi nters 
as G-s t r i ngs and as addresses 
19 
cout << p <<" 
is st ored at"<< 
i nt(p) 
<< endl; 
20 
cout << q 
<<" 
is st ored at"<< 
i nt(q) 
<< endl; 
21 
22 
II A str i ng literal 
can be treated 
as a pointer! 
23 
cout << "String 
l i teral 
stored 
at"<< 
in t ("l i teral"); 
24 
return 
O; 
25
) 
Program Output 
Hello Bailey 
Hello is stored 
at 4206692 
Bailey 
is sto r ed at 4206699 
St r ing l i teral 
stored 
at 4206721 
12.1 C-Strings 
817 
The first two assignments of Program 12-1 show that string literals are pointers to 
char by assigning them to variables of type char *. The pointers p and q then hold the 
addresses of the two string literals. By casting the pointers to int, we can see where in 
memory the string literals are stored. Notice that in this case, the compiler has stored 
all string literals in the program in consecutive memory locations . 
Programmer-Defined 
Arrays of Character 
String literals can only hold C-strings that are hard -coded into the program. To have a 
C-string whose characters are read from the keyboard or a file, you must explicitly 
define an array to hold the characters of the C-string. In doing this, you should make 
sure that you allocate an additiona l entry in the array for the terminating null character. 
For examp le, if your C-string will be at most 19 characters long, you will need to 
allocate an array of 20 characters, as in 
const i nt SIZE= 20; 
char company[SIZE ] ; 
As in the case of literals, the compiler will represent the C-string by the address of the 
first character of the string, in this case, the array identifier. Recall from Chapter 8 that 
an array identifier without the brackets is interpreted by the compiler to be the address 
of the first entry of the array . 

818 
Chapte r 12 
More on C-Strings and the string 
Class 
A C-string defined as an array can be given its value by initializing it with a string 
litera l, by reading characters into it from the keyboard or a file, or by copying characters 
into the array one character at a time. Here are some examples of initialization: 
const 
i nt SIZE= 
20; 
char company[SIZE ] = "Robotic 
Systems, 
inc."; 
char corporation[
] = "C. K . Graphics"; 
When initializing an array with a string literal in this manner , the size of the array in 
the array definit ion is optiona l. If not specified, the compiler will set the size to one 
more than the number of characters in the initializing literal string (thus allowing room 
for the null terminator) . 
As descr ibed in Chapter 3, C-strings defined as arrays can be read and written using 
the various objects, operators, and member functions of the input and output stream 
classes . A C-string stored as a programmer -defined array can be processed using 
standard 
subscr ipt notation. 
Program 12-2 is an example. It outputs a string one 
character at a time , and stops when it finds the null terminator. 
It uses the getl i ne 
member function, covered in Chapter 3, to read the str ing to be output. 
Program 12 -2 
1 II Thi s program cycles 
through 
a character 
array, 
displaying 
2 II each element 
until 
a null 
terminator 
is encountered. 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 int main() 
7 { 
8 
9 
10 
const 
i nt LENGTH= 80; 
char l i ne[LENGTH]; 
II Maximum length 
for string 
II Array of char 
11 
II Read a string 
i nto the character 
array 
12 
cout 
<< "Enter 
a sentence 
of no more than" 
13 
<< LENGTH-1 <<" 
characters:\n"; 
14 
cin.getl
i ne(line
, LENGTH); 
15 
cout 
<< "The sentence 
you entered 
is:\n"; 
16 
17 
II Loop through 
the array 
printing 
each character 
18 
for( i nt i ndex= 
O; line[index] 
!= '\O'; 
index++) 
19 
{ 
20 
cout << line[index
] ; 
21 
} 
22 
return 
O; 
23 } 
Program Output with Example Input Shown in Bold 
Enter a sentence 
of no more than 79 characters: 
C++ is challenging but fun! [Enter] 
The sentence 
you entered 
is: 
C++ is challenging 
but fun! 

12.1 C-Strings 
8 19 
Pointers to char 
As we have seen, C-strings can be represented as string literals or as arrays of characters. 
Both of these methods allocate an array and then use the address of the array as a 
pointer to cha r to actually represent the string . The difference between the two is that 
in the first case, the array used to store the string is allocated implicitly by the compiler, 
whereas in the second, the array is explicitly allocated by the programmer. 
The third method of representing a C-string uses a pointer to char to point to a C-string 
whose storage has already been allocated by one of the other two methods. Here are 
some examples of using C-strings in this way: 
char name[] = "Jo hn Q. Public "; 
char *p; 
p = name; 
cout << p << end l; 
p = "Jane Doe"; 
cout << p << end l; 
II Point to an exi sting 
C-string 
II Print 
II Point to another 
C-string 
II Print 
A major advantage in using a pointer variab le to represent a C-string is the ability to 
make the pointer point to different C-strings. 
Another way to use a pointer to a char as a C-string is to define the pointer and then 
set it to point to dynamically allocated storage returned by the new operator. This is 
illustrated in Program 12-3. 
Program 12 -3 
1 II Thi s program illustrates 
dynamic 
2 II of storage 
for C-strings
. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const i nt NAME
_LENGTH = 50 ; 
9 
char *pname = nullptr; 
10 
11 
II Allocate 
the array 
12 
pname = new char[NAME_LENGTHJ; 
13 
14 
II Read a string 
15 
cout << "Enter your name: "; 
16 
cin .getline
(pname , NAME
_LENGTH); 
17 
18 
II Di splay the string 
19 
cout <<"Hello·<< 
pname; 
20 
21 
I I Re 1 ease the memory 
22 
delete[ 
J pname; 
23 
ret urn O; 
24
} 
allocation 
II Maximum length 
II Address of array 
Program Output with Example Input Shown in Bold 
Enter your name: Georg e[Enter] 
He 11 o George 

820 
Chapter 12 
More on C-Strings and the string 
Class 
12.2 
A common mistake when using pointers to char as C-strings is using the pointer when 
it does not point to a properly allocated C-string . For example, the code 
char *pname; 
cout << "Enter your name: "; 
ci n 
>> pname; 
is erroneous because the program tries to read a str ing into the memory location 
pointed to by pname, when pname has not been properly initialized . 
Library Functions for Working with C-Strings 
CONCEPT: 
Th e C++ librar y provides many functions for working with C-strings. 
Th e C++ library provides many functions that can be used to work with C-strings . 
Th ere are functions for determin ing the length of a string, for concatenating two 
strings, for comparing two strings, and for searching for the occurrence of one string 
within another. You must include the cstri ng header file to use these functions . 
The strl en Function 
The st rlen function is passed a C-string as its argument and returns the length of the 
string . This is the number of characters up to, but not including, the null terminator. 
For example, in the code segment 
char str [] = "Hel lo" ; 
i nt length
= str len( str ); 
the variable 1 ength will have the number 5 stored in it. 
Th e length of a string should not be confused with the size of the array holding it. 
Remember, the only information passed to st rlen is the beginning of the C-string . It 
doesn't know where the array ends, so it looks for the null terminator to indicate the 
end of the string. 
Passing C-String Arguments 
Because C-strings are pointers to char, C-string handl ing functions take parameters 
that are arrays of char , or equivalently, pointers to char. The C-string can be passed to 
the function in any one of the three forms that a C-string can take: 
• A string literal 
• The name of an array that stores the C-string 
• A pointer variable holding the address of the C-string 
The st rcat Function 
Another example of a C-string handling function is strcat. 
The st rca t function takes 
two strings as parameters and concatenates them, returning a single string that consists 
of all the characters of the first string followed by the characte rs of the second string. 
Here is an examp le of its use: 

12.2 Library Functions for Working with C-Strings 
821 
const i nt SIZE= 13; 
char string
1[SIZE] =" Hell o "; 
char string2(
] = "World!"; 
cout << string1 
<< endl; 
cout << string2 
<< endl; 
strcat(string1, 
str i ng2); 
cout << string1 
<< endl; 
These statements will produce the following outp ut: 
Hello 
Worl d! 
Hello World! 
Th e strcat 
function copies the contents of stri ng2 to the end of stri ng1. In this 
example, str i ng1 contains the string "Hello" before the call to strcat. 
After the call, 
it contains the string "Hello World!". Figure 12-2 shows the contents of both arrays 
before and after the function call. 
Figure 12-2 
CD 
Before the call to st rca t ( st ri ng1 , str i ng2) : 
str ing1 
\0 
str ing2 
d 
\0 
After the call to st rca t (string1
, str ing2) : 
str ing1 
str ing2 
d 
\0 
d 
\0 
Notice that the last character in string1 
(before the null terminator ) is a space . The 
strcat 
function doesn't insert a space, so it's the programmer's responsibility to make 
sure one is already there, if needed. It's also the programmer's responsibility to make 
sure the array holding string1 
is large eno ugh to hold str i ng1 plus string2 
plus a 
null terminator. Here is a program segment that uses the s i zeof operator to test an 
array's size before st rcat is called: 
if 
(si zeof (string1
) >= (strlen(string1) 
+ strlen(string2) 
+ 1)) 
strcat(string1, 
string2); 
else 
cout 
<< "String1 
is not l arge enough for both strings
. \n"; 
WARNING! 
If the array holding the first string isn't large enoug h to hold both 
strings, strcat 
will overflow the bound aries of the array . 

822 
Chapte r 12 
More on C-Strings and the string 
Class 
CD 
The strcpy Function 
The strcpy function can be used to copy one C-string to anot her. Here is an example 
of its use: 
const i nt SIZE= 20; 
char name[SIZEJ; 
strcpy(name, 
"Albert Einstein"); 
The second C-string is copied to the address specified by the first C-string argument . If 
anything is already stored in the location referenced by the first argum ent, it is 
overwritten, as shown in the following program segment: 
char string
1[] ="He llo
"; 
cout << string1 
<< endl; 
strcpy(string1
, "World!"); 
cout << string1; 
Here is the outp ut: 
Hello 
Worl d! 
WARNING! 
Being true to C++'s nature, strcpy performs no bounds checking . 
The array specified by the first argument will be overflowed if it isn't large enough 
to hold the string specified by the second argument . 
Comparing C-Strings 
The assignment and relational operato rs work with the C++ str i ng class because they 
have been overloaded to work with that class. Howeve r, just as the assignment operator 
cannot be used to assign to C-strings, the relationa l operato rs <=, <, >, >=, ! =, and == 
cannot be used to compare C-strings. This is because when used with C-strings, these 
operators compare the addresses at which the C-strings are stored instead of comparing 
the actua l sequence of characte rs that comprise the C-strings. Program 12-4 shows the 
incorrect result of trying to compare C-strings using the equality operator. 
Program 12-4 
1 II This program illustrates 
that 
you cannot compare 
2 II C-strings 
with relational 
operators. 
Although it 
3 II appears 
to test 
the strings 
for equality
, that 
i s 
4 II not what happens. 
5 #include 
<iostream> 
6 using namespace std ; 
7 
(program continues) 

Program 12-4 
8 int main () 
9 { 
(continued) 
10 
II Two arrays 
for holdi ng t wo stri
ngs 
11 
const i nt LENGTH= 40; 
12.2 Library Functions for Working with C-Strings 
823 
12 
char f i rs t St ring[LENGTH] , secondString[LENG TH] ; 
13 
14 
II Read two st r i ngs 
15 
cout << "Ent er a string: 
"; 
16 
ci n .getl i ne(firstString, 
LENGTH); 
17 
cout << "Ent er another 
st ring: 
"; 
18 
ci n .getl i ne(secondStr
i ng, LENGTH); 
19 
20 
II Attemp t t o compare t he t wo stri
ngs using --
21 
if 
(f i rs t St r i ng == secondString) 
22 
cout << "You entered 
the same st ring t wi ce.\n"; 
23 
else 
24 
25 
cout << "The st ri ngs are not t he same . \ n"; 
26 
return 
O; 
27 } 
Program Output with Example Input Shown in Bold 
Ent e r a string: 
Alfonso[Enter] 
Ent e r another 
st ring: 
Alfonso[Enter] 
The st r ings ar e not the same. 
Although two identical strings may be entered, Program 12-4 will always report that 
they are not equal. This is because the expression 
firstStr
i ng == secondS t ring 
used in the i f statement compares the memory addresses of the two arrays instead of 
comparing the strings of characters stored at those addresses. Because these addresses 
are different, the comparison yields a result of false. In fact, in C++, even the comparison 
"abc" 
== "abc" 
will usually yield a result of false. This is because most compilers do not check to see if 
a string literal has been encountered before and will store the two strings at different 
memory addresses. The compiler will then compare the two different addresses, giving 
a value of false for the result . 
The strcmp Function 
To properly compare C-strings, you should use the library function s t rcmp. This 
function takes two C-strings as parameters and returns an integer that indicates how 
the two strings compare to each other. Its prototype, 
i nt st rcmp(char 
*string
1 , char *string2}; 

824 
Chapte r 12 
More on C-Strings and the string 
Class 
indicates that the function takes two C-strings as parameters (recall that char 
* is the 
type of C-str ing) and returns an integer result. Th e value of the result is set according 
to the following convention: 
• Th e result is zero if the two strings are equal on a character -by-character basis. 
• Th e result is negative if str i ng1 comes before str i ng2 in alph abet ical order. 
• Th e result is positive if st ri ng1 comes after st ri ng2 in alp habetica l order. 
Here is an examp le of the use of strcmp to determine if two str ings are equal: 
if 
(s trcmp (string1
, string2
) == 0) 
cout << "The strings 
are eq ual"; 
else 
cout << "The strings 
are not equal"
; 
Program 12-4, which incorrectly tested two C-strings with a relat iona l operator, can be 
correctly rewritten with the strcmp function, as shown in Program 12-5. 
Program 12 -5 
1 II Thi s program correctly 
tests 
two G-str i ngs for 
2 II equality 
wi th the strcmp funct i on. 
3 #include 
<iostream> 
4 #include 
<cstring> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
II Two arrays 
for two strings 
10 
const 
i nt LENGTH= 40; 
11 
char f i rstString[LENGTH ] , secondString
[LENGTH] ; 
12 
13 
II Read two strings 
14 
cout << "Enter 
a string: 
"; 
15 
cin .g etl i ne(firstString, 
LENGTH); 
16 
cout << "Enter 
another 
string: 
"; 
17 
cin .g etl i ne(secondStr
i ng, LENGTH); 
18 
19 
II Compare the strings 
for equa l i ty with strcmp 
20 
if 
(st rcmp(firstString
, secondStr
i ng) == 0) 
21 
cout << "You entered 
the same string 
twice .\n"; 
22 
els e 
23 
cout << "The strings 
are not the same . \n"; 
24 
25 
ret urn O; 
26 ) 
Program Output with Example Input Shown in Bold 
Enter a string: 
Alfonso[ Enter] 
Enter another 
string: 
Alfo nso[ Enter] 
You entered 
the same string 
twice. 
Th e function strcmp is case sensitive when it compares strings . If the user enters "Dog" 
and "dog" in Program 12-5, it will report they are not the same. Some compilers 

12.2 Library Funct ions for Working with C-Strings 
825 
provide nonstandard 
versions of strcmp that perf orm case-insens itive comparisons. 
Such functions work identically to strcmp except the case of the characters is ignored. 
Program 12-6 is a more practical examp le of how strcmp can be used. It asks users to 
enter the number of the com put er part they wish to pur chase . Th e part number contains 
digits, letters, and a hyphen, so it must be stored as a string . Once the user enters the 
part number, the program displays its price. 
Program 12 -6 
1 II Thi s program uses strcmp to compare the string 
2 II by the user with the valid 
part numbers . 
3 #include 
<iostream> 
4 #include 
<cstring> 
5 #include 
<iomanip> 
6 using namespace std ; 
7 
8 
9 
int 
main () 
{ 
II Price 
of items 
const double A_PRICE = 49.0, 
B_PRICE = 
II Character 
array 
for part 
const i nt PART_LENGTH = 8 ; 
char partNum[PART_LENGTH
]; 
number 
69 .95; 
II Instruct 
the user to enter 
a part number 
cout << ''The computer part 
numbers are:\
n"; 
entered 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
cout << ''\tBlu-ray 
Disk Drive, 
part number S147-29Aln''; 
cout << "\tWireless 
Router , part 
number S147-298\ n" ; 
cout << ''Enter 
the part number of the item youln"; 
cout << "wi sh to purchase: 
"; 
24 
II Read a part number of at most 8 characters 
25 
cin >> setw (9); 
26 
cin >> partNum; 
27 
28 
II Determine what user entered 
using strcmp 
29 
II and print 
its 
pr i ce 
30 
cout << showpoint <<fixed<< 
setprecision(2); 
31 
if (str cmp(partNum , "S147-29A") == 0) 
32 
cout << "The price 
is$"<< 
A_PRICE << endl ; 
33 
els e if (strcmp(partNum, 
"S147-298" ) == 
0) 
34 
cout << "The price 
is$"<< 
B_PRICE << endl ; 
35 
els e 
36 
cout << partNum <<" 
is not a val i d part 
number . In"; 
37 
38 
return 
O; 
39 ) 
Program Output with Example Input Shown in Bold 
The computer part 
numbers are: 
Blu-ray 
Disk Drive, 
part 
number S147-29A 
Wireless 
Router, 
part number S147-298 
Enter the part number of the item you 
wish to purchase: 
S147 -29A[Ent er] 
The price 
is $49.00 

826 
Chapter 12 
More on C-Strings and the string 
Class 
Using! with strcmp 
Some programmers prefer to use the logical NO T operator with strcmp when testing 
strings for equality. Since O is considered logically fa l se, the ! operator converts that 
value to true. The expression ! strcmp (stri ng1, str i ng2) will return true when both 
strings are the same and false when they are different. The two following statements 
have exactly the same effect when executed. 
i f(strcmp (s tr 1, str2) == 0) cout << "equal"; 
if( !strcmp (str 1, str2)) 
cout << "equal"; 
Sorting Strings 
Because strcmp returns informat ion on the relative alphabetic order of the two strings 
being compared, it can be used to sort lists of C-strings . Program 12-7 is a simple 
illustration of this: It asks the user to enter two names, which are then printed in 
ascending alphabetic order. 
Program 12 -7 
1 II Thi s program uses the return 
value of strcmp to 
2 II al phabet i cal ly order two strings 
entered 
by the user . 
3 #include 
<iostream> 
4 #include 
<cstring> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
II Two arrays 
to hold two strings 
10 
const i nt NAME
_LENGTH = 30 ; 
11 
char name1[NAME
_LENGTH
], name2[NAME
_LENGTH]; 
12 
13 
II Read two str i ngs 
14 
cout << "Enter a name (last 
name first): 
"; 
15 
cin .getline
(name1, NAME
_LENGTH); 
16 
cout << "Enter another name: "; 
17 
cin .getl i ne(name2, NAME
_LENGTH); 
18 
19 
II Print 
the two strings 
in al phabet i cal order 
20 
cout << "Here are the names sort ed alphabetica
l ly :\ n"; 
21 
if 
(st rcmp(name1, name2) < 0) 
22 
cout << name1 << endl << name2 << endl; 
23 
els e if (strcmp (name1, name2) > 0) 
24 
cout << name2 << endl << name1 << endl; 
25 
els e 
26 
cout << "You entered the same name twice !\n"; 
27 
28 
return 
O; 
29 ) 
(program continues) 

12.2 Library Funct ions for Working with C-Strings 
827 
Program 12 -7 
(continued) 
Program Output with Example Input Shown in Bold 
Enter 
a name ( 1 ast 
name f irst
) : Smith, Rlchard[Enter] 
Enter 
another 
name: Jones, John[Enter] 
Here are the names sorted 
alphabetically: 
Jones , John 
Smith , Richard 
Table 12-1 summar izes the string-handling functions discussed here, as well as others. 
(All the functions listed require the est ring header file.) 
Table 12 -1 (See your C++ reference manual for more information on these functions.) 
Function 
Description 
strl en 
Accepts a C-string as an argument. Returns the length of the C-string (not 
including the null terminator). Example Usage: 1 en = strl en (name); 
strcat 
Accepts two C-strings as arguments . The function appends the contents of the 
second string to the first C-string. (The first string is altered, but the second string 
is left unchanged.) 
Example Usage: strcat(string1, 
string2
); 
st rcpy 
Accepts two C-strings as arguments . The function copies the second C-string to 
the first C-string. The second C-string is left unchanged . 
Example Usage: strcpy(s
t ring1, 
string2
); 
st rcmp 
Accepts two C-string arguments . If st ri ng1 and st ri ng2 are the same, this 
function returns 0. If st r i ng2 is alphabet ically greater than stri ng1, it returns a 
negative number. If st ri ng2 is alphabetically less than stri ng1, it returns a 
positive number. 
ExampleUsage :if 
(strcmp(s
t r i ng1, st ring2)) 
~ 
Checkpoint 
12.1 Write a short description of each of the following functions: 
A) strle
n 
B) strcat 
C) strcpy 
D ) strcmp 
12.2 What will the following program segment display? 
char dog[ ] = "Fi do" ; 
cout 
<< st rlen(dog) 
<< endl ; 

828 
Chapte r 12 
More on C-Strings and the string 
Class 
12.3 
Assume the constant 
SIZE has val ue 16. What will the following 
program 
segment display? 
char str i ng1 [SIZE] = "Have a "; 
char str i ng2[] 
= "ni ce day "; 
strcat
(st ring 1, str i ng2); 
cout << string1 
<< endl; 
cout << string2 
<< endl; 
12.4 
Write a statement that will copy the string "Beethoven" to the array composer. 
12.5 
Write code that uses the ci n. getl i ne funct ion read a line of input into an array 
of characte rs, and then prints the number of 'e' characters in the inp ut. 
12.6 
Indicate whethe r the following strcmp function calls will return 0, a negative 
number, 
or a positive number. 
Refer to the ASC II table in Appendix 
A if 
necessary . 
A) strcmp("ABC", 
"abc"); 
B) strcmp("Jill", 
"Jim"); 
C) strcmp("123", 
"ABC"); 
D ) strcmp("Sammy", 
"Sally"); 
12. 7 
Comp lete the if statements in the following program skeleton. 
#include 
<iostream> 
usi ng namespace 
std; 
int 
main() 
{ 
} 
const 
i nt LENGTH= 20; 
char iceCream[LENGTH]; 
cout << "What flavor 
of ice cream do you 1 i ke best? 
"· 
cout << "Choco late, 
Vanilla, 
or Pralines 
and Pecan?
"; 
cin .getline(iceCream, 
LENGTH); 
cout << "Here is the number of fat 
grams fo r a half
"; 
cout << "cup serv i ng:\n"; 
II 
II 
Fi nis h the following 
if-else 
statement 
II 
so the program wil l select 
the ice cream entered 
II 
by the user 
II 
if (I* insert 
your code here 
*I) 
cout << "Chocolate
: 9 fat 
gra ms. \n"; 
else 
if (I* insert 
your code here *I) 
cout << "Vani l la : 10 fat 
grams . \n"; 
else 
if (I* insert 
your code here *I) 
cout << "Prali
nes and Pecan: 
14 fat 
grams.\n"; 
else 
cout << "That 's not one of our flavors
!\ n" ; 
return 
O; 

a 
VideoNot e 
Converting 
Strings to 
Numbers 
12.3 Conversions Between Numbers and Strings 
829 
Conversions Between Numbers and Strings 
CONCEPT: 
The C++ libraries provide functions and classes that can be used to convert 
a string representation of a number to numeric form and vice versa. 
There is a difference between a number that is stored as a string and one stored as a 
numeric value. The string "2679" isn't a number: it is a sequence of ASCII codes of the 
characters that form the individ ual digits of the number 2679 . Because the string 
"2679" is not a number, the compiler will not allow arithmet ic operat ions such as 
addit ion, multiplication , and division to be applied to it. Strings that represent numbers 
must first be converted to numeric form before they can be used with arith metic 
operators. Similarly, program values that are in the numeric form of types such as in t , 
1 ong, and doubl e sometimes need to be converted to string form . The resulting string 
may be immediately output to a file or some other input/output device, or it may be 
stored in an in-memory string object for later use. 
When a user enters a number at a keyboard , the number is entered in its string form as 
a sequence of characters (digits) typed by the user. In C++, such a number is usually 
read via the stream extract ion operator >>. This operator automat ically performs 
conversions as needed before storing into a variable of numeric type. During output, 
the reverse conversion from numeric to string is performed by the stream outp ut 
operator <<. 
Using String Stream Objects for Numeric Conversions 
C++ has two classes, ostri ngstream and i stri ngstream , that can be used to perform 
string/numeric conversions for in-memory values. Th e class ostri ngstream is a 
subclass of ostream (the class that cout belongs to) and uses the stream insertion 
operator<< to convert numeric values to string . Objects of type ostr i ngstream work 
the same way that cout and file objects do, except that instead of writing to the screen 
or to a file, ostri ngstream writes its data to a string object contained inside it. Each 
time you use<< on the ostrings
tream object, it performs any numeric -to-string 
convers ions necessary and appends the result to the end of its string . In addition to 
supporting all the member functions and operators of the ost ream class, ost ri ngstream 
objects support the str member functions shown in Table 12-2. 
The i str i ngst ream class derives from i st ream. It contains a string object inside it that 
functions as an input stream that can be "read" from. The input stream can be set by the 
i st ri ngstream constr uctor when the object is created, or by calling the str ( str i ng s) 
function after the object has been created . The stream extract ion operator>> reads from 
the enclosed string and converts from string to numeric where necessary. Member 
functions of i st ri ngst ream are also listed in Table 12-2. You must include the sst ream 
header file in your programs to use these classes. 

830 
Chapte r 12 
More on C-Strings and the string 
Class 
Table 12 -2 Member Functions of ostri 
ngstream and i stri ngstream Classes 
Member Function 
Description 
istringstream(string 
s ) 
Constr uctor for i stri ngstream : sets the initia l value of the input 
stream for the object. 
Example: istr i ngstream istr("50 
64 28"); 
ostringstream(string 
s ) 
Constr uctor for ostri ngstream : sets the initia l value of the output 
stream for the object. 
Example:ostr
i ngstream ostr("50 
64 28"); 
str i ng str() 
Returns the string conta ined in the ostri ngstream or 
i stri ngstream ob ject. 
Example: string 
is = istr
.st r(); 
str i ng os = ostr.str
(); 
void str(str
i ng &s) 
Sets the string that serves as the input or output stream for the object. 
Example: ostr.str
(" 50 64 28" ); 
istr.str("50 
64 28"); 
Program 12-8 demonstrates the use of these classes. 
Program 12 -8 
1 II This program illustrates 
the use of sstream 
objects. 
2 #include 
<sstream> 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
string 
str 
const char 
= "Joh n 
*cstr 
= 
20 50"; 
"Amy 30 
istr i ngstream istr1 (str ); 
istringstream 
istr2; 
II String 
to read from 
42 "; 
II Cstring 
to read from 
II 
i str 1 wi 11 read from 
II 
i str2 wi 11 read from 
str 
cstr 
10 
11 
12 
13 
14 
ostringstream 
ostr; 
II The ostringstream 
object 
15 
string 
name; 
16 
int score1, 
score2, 
average_score
; 
17 
18 
II Read name and scores 
and compute average then writ e to ostr 
19 
istr1 
>>name>> 
score1 >> score2; 
20 
average_score 
= (sco re 1 + score2 )12; 
21 
ostr 
<< name<<" 
has average 
score"<< 
average _s core << "\n"; 
22 
23 
II Set istr2 
to read from the C string 
and repeat 
the above 
24 
istr2.str(cstr); 
25 
istr2 
>>name>> 
score1 >> score2; 
26 
average_score 
= (sco re 1 + score2 )12; 
27 
ostr 
<< name<<" 
has average 
score"<< 
average _s core << "\n"; 
28 
29 
II Switch to hexadecimal 
output 
on ost r 
30 
ostr 
<< hex ; 
(program continues) 

12.3 Conversions Between Numbers and Strings 
831 
Program 12-8 
(continued) 
31 
32 
// Write Amy's scores 
in hexadec i mal 
33 
ostr 
<<name<< 
"'s scores 
in hexadeci mal are: 
• << score1 
34 
<<''and"<< 
score2 
<< "\n''; 
35 
36 
// Extract 
the string 
from ostr 
and pr i nt it to the screen 
37 
cout << ostr.str(); 
38 
39 
return 
O; 
40
} 
Program Output 
John has average 
score 
35 
Amy has average 
score 36 
Amy's scores 
in hexadecimal 
are: 
1e and 2a 
Notice that these classes have the full power of ostream and i stream objects, including 
the abi lity to convert numbers to string using different bases such as octal and 
hexadecimal. They do have a disadvantage, however , in that they force you to create 
sstream objects just so you can use their insertion and extraction operators to perform 
conversions . 
Numeric Conversion Functions 
C++ 11 provides severa l to_st r i ng (T value} functions to convert a numeric value of 
type T to string form. Here is a list of a few of the to _stri ng (} functions: 
string 
to_string
(i nt value) 
string 
to_string
(lo ng value) 
string 
to_string
(double value) 
The following code fragment 
int 
a= 
5; 
string 
str 
= to_string
(a*a}; 
cout << "The square 
of 5 is•<< 
str 
<< endl; 
illustrates how to use this family of functions . It prints the string 
The square 
of 5 is 25 
The to _stri ng (} functions cannot handle conversion of integers to base s other than 
10. If you need that facility, you should use an ostri 
ngstream 
object to do the 
conversion . 
The string -to-numeric conversions are performed by the family of stoX() functions. 
The members of this family that perform string conversions to i nt, 1 ong, fl oat , and 
double are 
int 
stoi(const 
string& 
str, 
size _t* pos = 0, int 
base= 
10) 
long stol(const 
str i ng& str , si ze_t* pos = 0 , int base= 
10) 
float 
stof(const 
string& 
str, 
size _t * pos = 0) 
double stod(const 
str i ng& str , si ze_t* pos = 0) 

832 
Chapte r 12 
More on C-Strings and the string 
Class 
Th e first parameter , str , is a string (such as "- 342" or "3 .48") to be converted to an 
appropriate 
numeric form. Th ese functions will conve rt to numeric the longest prefix 
of str possible and return in pos the address of an integer in which to store the index 
of the first characte r of str that cou ld not be converted. Th e type si ze_t is defined in 
the standard library and is commonly used to repre sent an unsigned integer that is the 
size of, or an index into , an array, vector, or string . For example, an attempt to convert 
the str ing "- 34 is even" will succeed and return the integer - 34 and set the position of 
the first character that could not be converted to 3. 
Th e base parameter applies for integral conversions only and indicates the base to be used 
for the conversion . Th e pos and base parameters are optiona l, so they can be omitted. If 
pos is omitted, the index of the stopping character is not stored; and if base is omitted, it 
is assumed to be 10. If the string str has an invalid value, such as "is 
- 34 even? ", 
then no conversion can be performed and the funct ion throws an i nval i d_argument 
exception . We will study except ions further in Chap ter 16. 
Program 12-9 demonstrates the use of the string conversion functions . 
Program 12 -9 
1 II Thi s program demonstrates 
the use of the stoXXX( ) 
2 II numeric conversion 
functions
. 
3 #include 
<str i ng> 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
II String 
to convert 
9 
10 
string 
str ; 
size _t pos; 
II Hold position 
of stopping 
character 
11 
12 
II Convert 
string 
to doub l e 
13 
str 
= "- 342 .57is a number" ; 
14 
cout << "The string 
is"<< 
str 
<< endl ; 
15 
doubled
= stod(str
, &pos); 
16 
cout << "The converted 
doub l e is"<< 
d << end l; 
17 
cout << "The stopping 
character 
i s"<< 
str[pos
] 
18 
<<" 
at position"<< 
pos << endl; 
19 
20 
II Convert 
string 
to i nt (defau lt to decimal ) 
21 
st r = "- 342 .57is a number" ; 
cout << "\nThe string 
is .. << str 
<< end l; 
int i = stoi(str
, &pos); 
cout << "The converted 
i nteger 
is .. << i << endl ; 
22 
23 
24 
25 
26 
27 
cout << "The stopping 
characte
r i s .. << str[pos
] 
<< .. at position 
.. << pos << endl; 
28 
II Conver t string 
to i nt (ba se is bina ry) 
29 
st r = "01110binary 
number "; 
30 
cout << "\nThe string 
is"<< 
str 
<< end l; 
31 
i = stoi(str
, &pos, 2); 
(program continues) 

12.4 Writing Your Own C-String Handling Functions 
833 
Program 12 -9 
(continued) 
32 
33 
34 
35 
36 
37 } 
cout << "The 
cout << "The 
<< " at 
return 
O; 
converted 
binary 
i nteger 
is
"<< 
i << endl; 
stopping 
character 
i s" 
<< st r[pos ] 
position"<< 
pos << endl; 
Program Output 
The string 
is -342 .57 is a number 
The converted 
double is -342.57 
The stopping 
character 
is i at position 
7 
The string 
is -342 .57 is a number 
The converted 
integer 
is -342 
The stopping 
character 
is . at position 
4 
The string 
is 01110binary 
number 
The converted 
binary 
integer 
is 14 
The stopping 
character 
is bat 
position 
5 
~ 
Checkpoint 
Vld~Not~ 
Writing a 
C-String 
Handling 
Function 
12.8 
Write a short description of each of the following functions . Your description 
should discuss the type of each parameter of the function and its default value, 
if any, and should identify the return type of the function . 
A) sto i 
B) stod 
C) to _st ring 
12.9 
Write a statement that will convert the C-string "1 O" to an integer and store the 
result in the variab le num. 
12.10 Write a statement that will convert the C-string "100000" to a long and store 
the result in the variable num. 
12.11 Write a statement that will convert the string "7. 2389" to a double and store 
the result in the variable num. 
12.12 Write a statement that will convert the Base 3 string 21201 to a numeric integer 
and store the result in the variable num. 
Writing 
Your Own C-String Handling Functions 
CONCEPT : You can design your own specialized function s for manipul ating strin gs. 
By being able to pass arr ays as arg um ents, you can write your own functions for 
processing C-strings . For examp le, Program 12-10 uses a function to copy a C-string 
from one array to anothe r. 

834 
Chapte r 12 
More on C-Strings and the string 
Class 
Program 12 -10 
1 II Thi s program uses a function 
to copy 
2 II a string 
into an array . 
3 #include 
<iostream> 
4 using namespace std; 
5 
6 II Function 
prototype 
7 void stringCopy(char 
[] , const char [] ); 
8 
9 int main() 
10 { 
11 
II Defi ne two arrays 
of char 
12 
const i nt S_LENGTH = 30; 
13 
char dest[S _LENGTH], source[S _LENGTH
] ; 
14 
15 
II Read a string 
i nto a source array 
16 
cout 
<< "Enter a str i ng with no more than" 
17 
<< S_LENGTH - 1 <<" 
characters:\n"; 
18 
cin.getline(source, 
S_LENGTH); 
19 
20 
II Copy i t into a destination 
array 
and print 
21 
stringCopy(dest, 
source); 
22 
cout << "The string 
you entered 
i s:\n" 
<< dest << endl; 
23 
return 
O; 
24 ) 
25 
26 //************************************************** 
27 II Definition 
of the str i ngCopy function
. 
* 
28 II Thi s funct i on accepts 
two character 
arrays 
as 
* 
29 II arguments . The function 
assumes the two arrays 
* 
30 II contain 
C-strings. 
The contents 
of the second 
* 
31 II array 
are copied to the first 
array . 
* 
32 //************************************************** 
33 void stringCopy(char 
destStr[], 
const char sourceStr[]) 
34 { 
35 
int i ndex= 
O; 
36 
37 
II Copy one character 
at a time till 
we come to 
38 
II the null terminator 
39 
whi le (sourceStr[
i ndex] != '\O') 
40 
{ 
41 
destStr[index] 
= sourceStr[index]; 
42 
index+ +; 
43 
} 
44 
destStr[
i ndex] = '\O'; 
45
} 
Program Output with Example Input Shown in Bold 
Enter a string 
with no more than 29 characters: 
Thank goodne ss It's Friday! [Enter] 
The string 
you entered 
is: 
Thank goodness it's 
Friday! 

12.4 Writing Your Own C-String Handling Functions 
835 
Notice that the function str i ngCopy in Program 12-10 does not accept an argument 
indicating the size of the arrays. It simply copies the characte rs from the source string 
to the destination until it encounters a null terminator in the source string . When the 
null terminator is found, the loop has reached the end of the C-string . Th e last statement 
in the function assigns a null terminator (the '\0' 
character) to the end of stri ng2, so 
it is properly terminated. 
CD 
WARNING! 
Since the stringCopy 
function 
doesn't 
know the size of the 
destination array, it's the programmer's 
responsibility to make sure the destination 
array is large enough to hold the source string array. 
Program 12-11 uses another C-string handling function: nameS1 i ce. Th e program asks 
the user to enter his or her first and last names, separated by a space . Th e function 
searches the string for the space and replaces it with a null terminator. 
In effect, this 
cuts off the last name of the string. 
Program 12 -11 
1 II Thi s program uses the function 
nameSlice 
2 II to "cut" 
off the last 
name of a string 
that 
3 II contains 
the user's 
f i rst 
and last 
names. 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 void nameSl i ce (char 
[]); 
8 
9 int main() 
10 { 
11 
II Funct i on prototype 
12 II Define array 
of char to hold name 
13 
const 
i nt NAME
_LENGTH = 41; 
14 
char name[NAME_LENGTHJ ; 
15 
16 
II Get user's 
f i rst 
and last 
names 
17 
cout << "Enter 
your f i rst 
and last 
names, separated"· 
18 
cout << "by a space:\n"; 
19 
cin.getline
(name, NAME
_LENGTH); 
20 
21 
II Slice 
off the last 
name and print 
what is left 
22 
nameSl i ce (name) ; 
23 
cout << "Your first 
name is: 
• << name << endl ; 
24 
return 
O; 
25
} 
26 
27 //***************************************************** 
28 II Definition 
of function 
nameSlice. 
Thi s function 
• 
29 II accepts 
a character 
array 
as its 
argument . It 
* 
30 II scans the array 
looking 
for a space . When it finds
* 
31 II one , it replaces 
i t wi th a null 
term i nator. 
* 
32 //***************************************************** 
33 void nameSlice (char userName[J) 
(program continues) 

836 
Chapte r 12 
More on C-Strings and the string 
Class 
Program 12 -11 
(continued) 
34 { 
35 
36 
37 
38 
39 
40 
II 
Look for the end of the first 
name, indicated 
II 
by a space or a null terminator 
int k = O; 
whi le (userNa me[k] != 
' && user Name[k] != '\O') 
k++· ' 
41 
II 
Insert 
nul l terminator 
42 
if (use rName[k ] --
' ') 
43 
userName[k ] = '\O'; 
44 } 
Program Output with Example Input Shown in Bold 
Enter your first 
and last 
names, separated 
by a space: 
Jimmy Jones[Ent er] 
Your first 
name is: 
Jimmy 
0 
Figure 12-3 
The following loop in nameS1 ice starts at the first character in the array and scans the 
string, search ing for either a space or a null terminator: 
whi le (us erName[k] != ' ' && userName[k ] != '\O'} 
k++; 
If the character in userName[k ] isn't a space or the null terminator, k is incremented, 
and the next character is examined . With the example input "Ji mmy Jones ," the loop 
finds the space separating "Jim my" and "Jon es " at userName[5 ] . When the loop stops, 
k is set to 5. Th is is illustrated in Figure 12-3. 
NOTE: 
The loop stops if it encounters a null terminator so it will not go beyond 
the boundary of the array if the user didn't enter a space. 
Once the loop has finished , user Name [ k] will contain either a space or a null terminator. 
If it contains a space, the following if statement, whose action is illustrated in Figure 
12-4, replaces it with a null terminator: 
if 
(use rName[k] == ' ') 
userName[k] = '\O'; 
The new null terminator now becomes the end of the string. 
The loop stops when k reaches 5 because user Name [ 5] contains a space 
' 
J 
m 
m 
y 
J 
0 
n 
e 
s 
\0 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Subscripts 

12.4 Writing Your Own C-String Handling Functions 
837 
Figure 12-4 
The space is replaced with a null terminator. This now becomes the end of the string . 
• 
J 
m 
m 
y 
\0 
J 
0 
n 
e 
s 
\0 
0 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
11 
12 
Subscripts 
Using Pointers to Pass C-String Arguments 
Pointers are extremely useful for writing functions that process C-strings. If the 
start ing add ress of a string is passed into a pointer parameter variable, it can be 
assumed that all the characters, from that address up to the byte that holds the null 
terminator are part of the string. (It isn't necessary to know the length of the array 
that holds the string .) 
Program 12-12 demonstrates a function, countChars, that uses a pointer to count the 
number of times a specific character appears in a C-string . 
Program 12 -12 
1 II This program demonstrates 
a function, 
countChars , 
2 II that 
counts the number of times a spec i fic 
3 II character 
appears 
in a string. 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 II Function 
prototype 
8 int countChars(const 
char* 
char ); 
9 
10 int main() 
11 { 
12 
II Defi ne array to hold the string 
13 
const i nt S_LENGTH = 51; 
14 
char userString
[S_LENGTH
]; 
15 
16 
17 
char le tte r; 
II User i nput 
18 
II Read the string 
and the l ette r to count 
19 
cout << "Enter a string 
(up to" 
20 
<< S_LENGTH-1 <<" 
characters
): "; 
21 
cin .getline
(userString
, S_LENGTH); 
22 
cout << "Enter a character 
and I will 
tell 
you how many\n; 
23 
cout << "t imes it appears 
in the str i ng: "; 
24 
cin >> letter
; 
25 
(program continues) 

838 
Chapte r 12 
More on C-Strings and the string 
Class 
Program 12 -12 
(continued) 
26 
II Output the results 
of the letter 
count 
27 
cout <<letter<<• 
appears
"; 
28 
cout << countChars(userString
, letter)<<• 
times.\n"; 
29 
return 
O; 
30 } 
31 
32 //******************************************************* 
33 II Definition 
of countChars . The parameter 
strPtr 
i s 
34 II a pointer 
that 
poi nts to a string. 
The parameter 
35 II ch is a character 
that 
the funct i on searches 
for 
36 II in the str i ng . The function 
returns 
the number of 
37 II times the character 
appears 
in the string
. 
* 
* 
* 
* 
* 
38 //******************************************************* 
39 int countChars(const 
char *strPtr
, char ch) 
40 { 
41 
int count= 
O; 
42 
whi le (*strPtr 
!= '\O') 
43 
{ 
44 
if (*strPtr 
--
ch) 
45 
count ++; 
46 
strPtr
++; 
47 
} 
48 
return 
count ; 
49
} 
Program Output with Example Input Shown in Bold 
Enter a string 
( up to 50 characters): 
Starting Out With C++ [Ent er] 
Enter a character 
and I will 
tell 
you how many 
ti mes it appears 
in the string: 
t[Enter] 
t appears 
4 times. 
In the function countChars , strPtr 
points to the C-string that is to be searched and ch 
contains the character to look for. The whi 1 e loop repeats as long the character strPtr 
points to is not the null terminator: 
whi le (*strPtr 
!= '\O') 
Inside the loop, the following if statement compares the character that strPtr 
points 
to with the character in ch: 
i f (*strPtr 
== ch) 
If the two are equal, the variable count is incremented. (count keeps a running total of 
the number of times the character appears.) The last statement in the loop is 
strPtr+
+; 

12.5 More about the C++ string 
Class 
839 
Th is statement increments the add ress in strPtr
. T his causes strPtr 
to point to 
the next character in the string . Th en the loop starts over. When strPtr 
finally 
reaches the null terminator , the loop terminates and the function ret urn s the value 
in count. 
~ 
Checkpoint 
12.13 What is the output of the following program? 
#i nclude <iostream> 
usi ng namespace std; 
II Function 
prototype 
void mess (char [] ); 
int main () 
{ 
} 
char stuff
[] = "Tom Talbert 
Tried Trains"; 
cout <<stuff<< 
endl; 
mess (stuff
) ; 
cout <<stuff<< 
endl; 
return 
O; 
II Definition 
of function 
mess 
void mess (char str[]) 
{ 
i nt step= 
O; 
while 
(st r[step
] != . \ 0. ) 
{ 
if (st r[step
] -- 'T' ) 
str[step] 
= 'D'; 
step++ ; 
) 
} 
More about the C++ string 
Class 
From an ease -of-programming 
point of view, the standard 
library string 
class 
offers several advantages over C-str ings. As you have seen throughout 
this text, 
the string 
class has several member functions and overloaded operators. 
Th ese 
simp lify tasks , such as locating a character 
or string with in a string, that are 
difficult and tedious to perfo rm with C-string s. In this section we review some 
basic operations 
with strings, 
then disc uss more of the string 
class's member 
function s. 

840 
Chapter 12 
More on C-Strings and the string 
Class 
Any program using the string 
class must #include 
the string 
header file. String 
objects may then be created using any of the constructors shown in Table 12-3. 
Table 12-3 
String Constructo rs 
Definition 
str i ng() 
Description 
Default constructor: creates an empty string . 
Example: str i ng st r(); 
str i ng(const char *s) 
Convert constructor: creates a string object from a C-string s. 
Example: str i ng name ( "Wi 11 i am Smith") ; 
str i ng(const 
str i ng &s) 
Copy constructor: creates a new string from an existing string s. 
Example: st ri ng name1 (s); 
The string class overloads the operators shown in Tab le 12-4. 
Table 12-4 
String Class Operators 
Overloaded Operator 
Description 
>> 
Extracts characters from a stream and inserts them into the string. 
Characters are copied until a whitespace or the end of the input is 
encountered. 
<< 
Inserts the string into a stream . 
= 
Assigns the string on the right to the string object on the left. 
+= 
Appends a copy of the string on the right to the string object on the left. 
+ 
Returns a string that is the concatenation of the two string operands . 
[ J 
Implements array -subscript notation, as in name(x]. A reference to the 
character in the x position is returned . 
Relationa l Operators 
Each of the relational operators is implemented: 
< > <= >= == != 
The string class also has several member functions . For example, the si ze function 
returns the length of the string . Table 12-5 lists many of the st ring class member 
functions and their overloaded variations. In some cases, the arguments passed to a 
member function may be such that the operation being requested is impossible. In 
those cases, the member function will signal the occurrence of an error by throwing an 
exception. Exceptions are discussed in Chapter 16. 

12.5 More abo ut the C++ string 
Class 
84 1 
Table 12-5 
string 
Class Member Functions 
Member Function Example 
theString.append(str); 
theStri 
ng. append (str
, p, n); 
theString.append(str, 
n); 
theString.append(n, 
ch); 
theString.assign(str); 
theStri 
ng. assign (str
, p, n); 
theString.at(p); 
theString.begin(); 
theString.capacity(); 
theString.clear(); 
theString.compare(str); 
theSt ring. copy ( st r , p, n) ; 
theString.c
_str(): 
theString.data(); 
theString.empty(); 
Description 
Appends str to theStri 
ng. The argument str can be a 
string object or a C-string . 
n number of characters from str, starting at position p, are 
appended to theStr
i ng. An exception is thrown if the 
substring of str that begins at p has fewer than n 
characters. 
The first n characters of the C-string st r are appended to 
theStr
i ng. 
Appends n copies of character ch to theStri 
ng. 
Assigns str to theStr
i ng. Th e parameter str can be a 
string object or a C-string . 
n number of characters from str, starting at position p, are 
assigned to theSt ring. An exception is thrown if the 
substring of str that begins at p has fewer than n 
characters. 
Returns the character at position p in the string, the same 
value as returned by theSt ring [ p]. 
Returns an iterator pointing to the first character in 
the string . (For more information on iterato rs, see 
Chapter 16.) 
Returns the size of the storage allocated for the string . 
Clears the string by deleting all the characte rs stored in it. 
Compare theString 
to str in the manner of the 
strc mp. The str argument may be a str i ng object 
or a C-string . 
Copies the substring of length n that begins at position p of 
theStr
i ng into the character array str. An exception is 
thrown if theSt ring has fewer than n characters after the 
given position p. 
Returns the C-string value of the string 
object. 
Returns a character array containing a null terminated 
string, as stored in theStri 
ng. 
Returns true if theStri 
ng is empty, false otherwise . 
(table continues) 

842 
Chapter 12 
More on C-Strings and the string 
Class 
Table 12-5 
string 
Class Member Functions (continued) 
Member Function Example 
theS t ring.end(); 
theS t ring.erase(p, 
n); 
theS t ring.find(str, 
p); 
theS t ring.find(c
h, p); 
theS t ring.insert(p, 
str); 
theS t ring.length(); 
theS t ring. rep lace( p, n, str); 
theS t ring.si
ze (); 
theS t ring.substr(p, 
n); 
theS t ring.swap(str); 
Description 
Returns an iterator pointing to the position beyond the last 
character of the string in t heSt ri ng. (For more 
information on iterators, see Chapter 16.) 
Erases n characters from theSt ring, beginning at 
position p. 
Returns the first position at or beyond position p where the 
string str is found in theString
. Th e paramete r str may 
be a string object or a C-string. If str is not found , the 
static member str i ng:: npos of thestri ng class is 
returned . 
Returns the first position at or beyond position p where the 
character ch is found in the St ri ng. Returns st ring:: npos 
if the character is not found . 
Inserts a copy of str into theS t ri ng, beginning at position p. 
The argument str may be a string object or a C-string. 
Returns the length of the string in the St ri ng. 
Replaces then characters in theStr i ng beginning at 
position p with the characters in string object str. 
Returns the length of the string in the St ri ng. 
Returns a copy of a substring . Th e substring is n characters 
long and begins at position p of t heSt ri ng. 
Swaps the contents of theS t ri ng with str. 
12.6 
Advanced Software Enterprises Case Study 
You are a summer int ern at Advanced Softwa re Enterprises, and your boss has 
asked you to develop a function that can format string representations 
of dollar 
amounts . Specifically, he wants you to add commas and a dollar sign ($) at 
appropr iate places in the string . For example, when the function is given the string 
ob ject or C-string with a value of "1084567 .89", it sho uld return the string 
"$1,084,567.89". 
After reviewing the Stri ng class members listed in Table 12-5 and giving the problem 
some thought, you decide to use the fi nd method. This will let you find the index of 
the decimal point in the input string. Beginning at that point , you can back up in the 

12.6 Advanced Software Enterprises Case Study 
843 
string, inserting a comma at every third location. You then finish it off by inserting a 
$ sign at the beginning. In no time at all, you have the solution and the demonstration 
program shown in the listing for Program 12-13. 
Program 12 -13 
1 II This program demonstrates 
the use of the string 
f i nd 
2 II and insert 
member functions. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 using namespace std; 
6 
7 string 
dollarFormat(string 
); 
II Prototype 
8 
9 int main(void) 
10 { 
11 
string 
input; 
II User i nput 
12 
13 
14 
15 
16 
II Get the dollar 
amount from the user 
cout << "Enter a dollar 
amount in the form nnnnn.nn 
cin 
>> i nput; 
17 
II Display 
the formatted 
dollar 
amount 
... 
18 
cout << "Formatted 
amount: 
" << dollarFormat(input) 
<< endl; 
19 
return 
O; 
20
) 
21 
22 //**************************************************** 
23 II Returns 
a $-formatted 
version 
of the input string* 
24 //**************************************************** 
25 string 
dollarFormat(string 
original) 
26 { 
27 
28 
29 
30 
31 
32 
33 
string 
formatted= 
or i ginal; 
int dp 
= formatted. f i nd(' . '); 
int pos = dp; 
whi le (pos > 3) 
{ 
pos = pos - 3; 
formatted.insert(pos, 
" ") . 
' 
' 
34 
} 
35 
formatted
.i nsert (0, "$"); 
36 
return 
formatted; 
37
} 
II Pos it ion of decimal 
point 
II Search for comma position 
Program Output with Example Input Shown in Bold 
Enter a dollar 
amount in the form nnnnn. nn : 1084567
.89[Enter] 
Here is the amount formatted: 
$1,084,567.89 

844 
Chapte r 12 
More on C-Strings and the string 
Class 
~ 
12.7 
a.ii 
Tying It All Together: Program Execution Environments 
Most operating 
systems provide 
every executing 
program 
with an ex ecutio n 
environment consisting of a set of strings of the form 
name=value 
The name part of this equation is called an environment variable, and the value part is 
used to specify a string value for that particular environment variable . As an example, 
look at this partia l listing of the execution environment of a C++ program running on 
one of the authors' machines: 
1 COMPUTERNAME=GCM-RED 
2 ComSpec=C:\Wi ndows\system32\cmd.exe 
3 HOMEDRIVE=C: 
4 HOMEPA
TH=\Users\gcm 
5 LOGONSERVER=\\GCM-RED 
6 NUMBER
_OF_PROCESS0RS=4 
7 OS=Windows_NT 
8 SESSIONNAME=Conso
l e 
9 SystemDrive=C: 
10 SystemRoot=C:\Windows 
11 USERDOMAIN=gcm-Red 
12 USERNAME=gcm 
13 wi ndir=C:\Windows 
In line 1, COMPUTERNAME 
is the environment variable and GCM-RED 
is the associated value. 
A program that examines its execution environment can obtain information about the 
user currently logged in and about the machine on which it is running. Depending on the 
operating system, the program can also gather information about the network to which 
the machine is connected . For example, by examining the above listing, we can tell that 
the user's login name is gem (line 12), that the user's home folder is \Users \gem (line 4), 
and that the machine's operating system is a version of Microsoft Windows (line 7). 
Furthermore, we can tell that the computer has four central processing units (line 6) and 
that the network name of the machine is GCM-RED 
(line 1). 
The operating system stores the program's environment 
as an array of pointers to 
C-strings. To mark the end of the array, the system sets the last entry in the array to 0. 
It then passes the base address of this array to the program. When the program starts 
executing, the C++ run -time system sets a variable 
char **environ; 
to point to the beginning of the environment array. 
Basically, the environ variable is a global variab le defined in library code that is linked 
with the executable code of your program. In C++, a function can access a globa l 
variable defined in a separate file by declaring the variable and prefixing the declaration 
with the key word extern . This means that you can gain access to the environment by 
including this declaration in your program: 
extern 
char** 
environ; 
In Chapter 10 you learned that if environ is a pointer to the beginning of an array of 
items, you can use the notation 
environ[k] 

Review Questions and Exercises 
845 
to access the various components of that array. By start ing a variab le k at O and 
repeated ly incrementing 
k, you can step through the array and examine each 
environment string, as shown in Program 12-14. 
Program 12-14 
1 // This program prints 
its 
environment 
variables
. 
2 #include 
<iostream> 
3 us i ng namespace std; 
4 
5 i nt mai n(int 
argc, 
char** argv) 
6 { 
7 
8 
9 
10 
11 
extern 
char **envir on; 
int k = 0; 
while(environ
[k] != 0) 
{ 
// Needed to access 
the environment 
// Is 
it last 
C-string 
in environment? 
12 
// Print 
the string 
13 
cout << environ[k] 
<< "\n"; 
14 
15 
16 
17 } 
k++ · ' 
} 
return 
O; 
The output from this program will vary depending on the user running the program 
and the machine on which the program is running. It will be similar to what is shown 
at the beginning of this section . 
Review Questions and Exercises 
Fill-in-the-Blank 
1. A(n) ____ 
is represented in memory as an array of characte rs with a null 
terminator. 
2. The ____ 
statement is required before the C-string library functions can be 
used in a program . 
3. A(n) ____ 
is written in your program as a sequence of characters surrounded 
4. 
5. 
6. 
7. 
8. 
9. 
10. 
11. 
by doub le quotes. 
The type ____ 
is used by the compiler as the type of a string literal. 
____ 
is used to mark the end of a C-string . 
The 
The 
The 
The 
____ 
class can be used to read input from an in-memory string object. 
____ 
class can be used to write output to an in-memory string object. 
____ 
function returns the length of a string . 
To ____ 
two strings means to append one string to the other. 
____ 
function concatenates two strings . 
The 
The ____ 
function copies one string to another. 

846 
Chapte r 12 
More on C-Strings and the string 
Class 
12. 
13. 
14. 
15. 
16. 
17. 
18. 
The 
The 
The 
____ 
function searches for a string inside of another one. 
____ 
function compares two strings. 
____ 
function copies, at most , n number of characters from one string 
to another . 
The 
The 
The 
The 
____ 
function returns the value of a string converted to an integer . 
____ 
function returns the value of a string converted to a 1 ong integer. 
____ 
function returns the value of a string converted to a doub 1 e. 
____ 
function converts an integer to a string. 
Algorithm Workbench 
19. Write a function whose prototype is 
char lastC har(const 
char *str) 
that takes a nonempty C-string as parameter and returns the last character in the 
string . For example, the call 1 astC har ( "abc") will return the character c. 
Predict the Output 
20 . #i nclu de <iostream> 
using namespace std; 
int main() 
{ 
} 
cout << ("hello")[1]; 
re t urn O; 
21. #i ncl ude <iostream> 
using namespace std; 
i nt main() 
{ 
} 
cout << *("hello"}; 
re t urn O; 
22 . #i ncl ude <iostream> 
using namespace std; 
i nt main() 
{ 
} 
cout << *("C++ is fun"+ 
5); 
re t urn O; 
23. #i nclu de <iostream> 
#i nclu de <string> 
using namespace std; 
int main() 
{ 
} 
cout << string("fan
t ast i c").s
i ze(); 
re tu rn O; 

24. #include 
<iostream> 
#include 
<cstring> 
using namespace std ; 
int main () 
{ 
} 
cout << strcmp( "a", 
"b" ); 
return 
O; 
25. #include 
<iostream> 
using namespace std; 
int main () 
{ 
} 
i f ( "a " == "a" ) 
cout 
<< ''equal"; 
else 
cout << "not equal" ; 
return 
O; 
26. #include 
<iostream> 
#include 
<string> 
using namespace std; 
int main () 
{ 
} 
string 
s (5 , ' a '); 
s.append (3 , ' b'); 
s.insert
(6 , "xyz" ); 
cout << s ; 
return 
O; 
27. #include 
<iostream> 
#include 
<cstring> 
using namespace std; 
int main () 
{ 
} 
char name[20] = "abracadabra
"; 
strcpy
(name+4, "sion" ); 
cout << name; 
return 
O; 
28. #include 
<iostream> 
#include 
<cstring> 
using namespace std; 
int main () 
{ 
} 
char name[20] ="John"
; 
*name= 
'\O'
; 
strcat
(name, "Smith ") ; 
cout << name; 
return 
O; 
Review Questions and Exercises 
847 

848 
Chapter 12 
More on C-Strings and the string 
Class 
Find the Errors 
29. Each of the following programs or program segments has errors . Find as many as 
you can. 
A) char st ring [] = "Stop"; 
if (isupper(string) 
== "STOP") 
exit(O); 
B) char numeric [5] ; 
int 
X = 123; 
numeri c= atoi(x); 
C) 
char st ring1 [] = "Bil ly"; 
char st ring2 [] =•Bob 
Jones"; 
strcat(s
t ring1, 
st ring2); 
D) 
char x = 'a', 
y = 'a'; 
if (strcmp(x, 
y) == 0) 
exit ( O) ; 
Soft Skills 
30. You are a member of a standardization committee for a new C++ standard, and there is 
a proposal on the table to drop C-strings from the language and support only the C++ 
string class. State whether you would oppose or support the proposal and explain why. 
Programming 
Challenges 
1. Word Counter 
Write a function that accepts a C-string as an argument and returns the number of 
words contained in the string . For instance, if the string argument is "Four score and 
seven years ago" the function should return the number 6. Demonstrate the function in 
a program that asks the user to input a string and then passes it to the function. The 
number of words in the string should be displayed on the screen. 
2. Average Number of Letters 
Modify the program you wrote for Problem 1 (Word Counter), so that it also displays 
the average number of letters in each word. 
3. Sentence Capitalizer 
Write a function that accepts a C-string as an argument and capitalizes the first character 
of each sentence in the string. For instance, if the string argument is "he 11 o. my name is 
Joe. what is your name?" the function should manipulate the string so it contains "He 11 o. 
My name is Joe. What is your name?" Demonstrate the function in a program that asks 
the user to input a String and then passes it to the function. The modified string should be 
displayed on the screen. 
4. Vowels and Consonants 
Write a function that accepts a C-string as its argument . The function should count the 
number of vowels appearing in the string and return that number. 

Programming Challenges 
849 
Write another function that accepts a C-string as its argument . This function should 
count the number of consonan ts appearing in the string and return that number. 
Demonstrate the two functions in a program that performs the following steps: 
1. The user is asked to enter a string. 
2. The program displays the following menu: 
A) Count the number of vowels in the string 
B) Count the number of consonants in the string 
C) Count both the vowels and consonants in the string 
D) Enter anothe r string 
E) Exit the program 
3. The program performs the operation selected by the user and repeats until the 
user selects E, to exit the program . 
5. Nam e Arrang er 
Write a program that asks for the user's first, middle, and last names . The names 
shou ld be stored in three different character arrays . The program should then store 
in a fourth array the name arranged in the following manner: the last name followed 
by a comma and a space, followed by the first name and a space, followed by the 
middle name . For example, if the user entered "Caro l Lynn Smith", it should store 
"Smith, Carol Lynn" in the fourth array. Display the contents of the fourth array 
on the screen. 
6. Sum of Digits in a String 
Write a program that asks the user to enter a series of single-digit numbers with nothing 
separating them. Read the input as a C-string or a stri ng object . The program should 
display the sum of all the single-digit numbers in the string. For example, if the user 
enters 2514, the program should display 12, which is the sum of 2, 5, 1, and 4. The 
program should also display the highest and lowest digits in the string. 
7. Most Frequent Character 
Write a function that accepts either a pointer to a C-string or a stri ng object as its 
argument. The function should return the character that appears most frequently in the 
string . Demonstrate the function in a complete program . 
8. rep l aceSubstri 
ng Function 
Write a function named re placeS ubst ring. The function should accept three C-string 
or st ri ng object arguments . Let's call them string1, 
string 2, and s t ri ng3. It should 
search stri ng1 for all occurrences of string2
. When it finds an occurrence of string2, 
it should replace it with st ri ng3. For example, suppose the three arguments have the 
following values: 
stri ng1: 
stri ng2: 
stri ng3: 
"the dog j umped over t he fence" 
"the " 
"th at" 

850 
Chapter 12 
More on C-Strings and the string 
Class 
a 
VideoNote 
Solving 
the Case 
Manipulator 
Problem 
With these three arguments, the function would retur n a st ri ng object with the value 
"that dog jumped over that fence". Demonstrate the function in a complete program . 
9. Case Manipulator 
Write a program with three functions: upper, 1 ower , and fli p. The upper function 
should accept a C-string as an argument. It should step through all the charac ters in the 
string , converting each to uppercase. The 1 ower function, too, should accept a pointer 
to a C-string as an argument. It should step throug h all the characters in the string, 
converting each to lowercase. Like upper and lower, fl i p should also accept a C-string. 
As it steps through the string, it should test each character to determine whether it is 
upper- or lowercase. If a characte r is uppercase, it should be converted to lowercase. If 
a character is lowercase, it should be converted to uppercase. 
Test the functions by asking for a string in function mai n, then passing it to them in the 
following order: fl i p, l ower, and upper . 
10. Password Verifier 
Imagine you are developing a softwa re package that requires users to enter their 
own passwords . Your software requ ires that user's passwords meet the following 
criteria: 
• The password should be at least six characters long. 
• The password should conta in at least one uppercase and at least one lowercase 
letter. 
• The password should have at least one digit. 
Write a program that asks for a passwo rd and then verifies that it meets the stated 
criteria. If it doesn' t, the program should display a message telling the user why. 
11. Phone Number List 
Write a program that has an array of at least 10 string objects that hold people's names 
and phone numbers . You may make up your own strings or use the following: 
"Hoshi kawa Tanaka , 678-1223 " 
"Joe Looney, 586- 00 97 " 
"Geri Pal mer, 223- 8787" 
"Lynn Lopez, 887-1212 " 
"Hol l y Gaddi s , 223-88 78" 
"Sam Wi ggin s , 486- 0998 " 
"Bob Kain, 586-8712 " 
"Ti m Haynes, 586- 7676" 
"Warren Gaddi s , 223-9 037" 
"Jean Ja mes , 678- 4939 " 
"Ron Palmer, 486- 2783 " 
The program should ask the user to enter a name or partial name to search for in the 
array. Any entries in the array that match the string entered should be displayed. For 
exam ple, if the user enters "Pal mer", the program should display the following names 
from the list: 
Geri Palmer, 223-8787 
Ron Palmer , 486-2 783 

Programming Challenges 
851 
12. Check Writer 
Write a program that displays a simulated paycheck. The program should ask the user 
to enter the date, the payee's name, and the amount of the check. It should then display 
a simulated check with the dollar amount spelled out, as shown here: 
Dat e: 12/24/2016 
Pay to th e Order of: John Phillips 
$1920 .85 
One thousand 
nine hundred t wenty and 85 cents 
You may assume the amount is no greater than $10000. Be sure to format the numeric 
value of the check in fixed-point notation with two decimal places of precision. Be sure 
the decimal place always displays, even when the number is zero or has no fractiona l 
part. Use either C-strings or string class objects in this program. 
13. Digit Sums of Squares and Cubes 
If you add up all the digits in 468, you get 4 + 6 + 8 = 18. The square and cube of 468 
are 219024 and 102503232, respectively. Interestingly, if you add up the digits of the 
square or cube, you get 18 again. Are there other integers that share this property? 
Write a program that lists all positive integers k less than 1000 such that the three 
numbers k, k2, and k3 have digits that add up to the same number. 
14. Dollar Amount Formatter 
Modify Program 12-13 by adding a function 
string 
dol larFormat(doub
l e amount) 
that takes a dollar amount in numeric form and returns a string formatted in currency 
notation, with a $ sign and commas inserted at the appropriate locations . Test your 
function using suitab le inputs. 
15. Word Separator 
Write a program that accepts as input a sentence in which all of the words are run 
together, but the first character of each word is uppercase . Convert the sentence to a 
string in which the words are separated by spaces and only the first word starts with an 
uppercase letter. For example the string "StopAndSmellTheRoses ." would be converted 
to "Stop and smell the roses." 
16. Pig Latin 
Write a program that reads a sentence as input and converts each word to "Pig Latin." In 
one version, to convert a word to Pig Latin you remove the first letter and place that letter 
at the end of the word. Then you append the string "ay" to the word. Here is an example: 
English: I SLEPT MOST OF THE NIGHT 
Pig Latin: IA Y LEPTSA Y OSTMA Y FOA Y HETA Y IGHTNA Y 
1 7. I before e except after c 
A friend of yours who is an educator is conducting research into the effectiveness of 
teaching the spelling rule "I before e except after c" to students. She wishes to analyze 

852 
Chapter 12 
More on C-Strings and the string 
Class 
writing samp les from two groups of students, only one of which was taught the rule. 
Write a program that will take a file containing a writing sample and print a list of all 
words in the file that contain at least one of the strings "ie" or "ei". 
18. User Name 
Write a program that queries its environment , determines the user's login name , and 
then greets the user by name. For examp le, if the login name of the user is gem, then the 
program prints 
Hello, gem 
when it is executed . 
19. String Splitter 
Write a function veetor<stri 
ng> split (st ring str) that takes a string as parameter 
and returns a vector of the distinct words in the string. A distinct word is any run of 
characters delimited by the beginning of the string, the end of the string, or whitespace. 
A consecutive run of whitespace characters is to be treated the same as a single 
whitespace character. Test your program by having the user enter lines of input , reading 
and splitting the line into words, and printing the words in the returned vector with 
each word on its own line. For examp le, the input 
Every 
results in the output 
Every 
good 
boy 
does 
fine. 
good boy 
20. Palindromic Numbers 
does fi ne . 
A palindromic number is a positive integer that reads the same forward as backward. 
For example, the numbers 1, 11, and 121 are palindromic. Moreover, 1 and 11 are 
very special palindromic numbers: their squares are also palindromic. How many 
positive integers less than 10,000 have this property? Write a program to list all such 
numbers together with their squares. 
The beginning part of your output should look like this: 
1 has square 
1 
2 has square 4 
3 has square 9 
11 has square 
121 
22 has square 484 
Hint: If str is a string object, the reverse() 
function (declared in <algorit
hm> header ) 
will reverse the string. The code to do that is: 
reverse(str
.begi n(), 
str .end()); 

TOPICS 
13.1 Input and Output Streams 
13.2 More Detailed Error Testing 
13.3 Member Functions for Reading and 
Writing Files 
13.4 Binary Files 
13.5 Creating Records with Structu res 
13.6 Random-Access Files 
13.7 Open ing a File for Both Input and 
Output 
13.8 Online Friendship Connections Case 
Study: Object Serialization 
13.9 Tying It All Together: File Merging and 
Color-Coded HTML 
Input and Output Streams 
CONCEPT: 
i fstream objects are used for file input, ofstr eam objects are used for 
file output , and fstream objects are used for both input and outpu t. 
An input stream is a sequence from which data can be read; an output stream is a 
sequence to which data can be written; and an input - output stream is a sequence of 
data that allows both reading and writing . Th e keyboard is the standard example of an 
input stream, and the monitor screen is the standard example of an output stream . 
C++ provides various classes for working with streams. These include i stream and 
ostream for standard input and output; i fs t ream, of stream, and fstream for file IO; 
and i stri ngstream and ost ri ngstream for reading and writing strings . To read from 
the keyboard, you use ci n, which is a predefined object of the i st ream class. To write 
to the screen, you use cout , a predefined object of the ostream class. In Chapter 5 you 
learned how to use an i fstream object to read a file and how to use an of stream object 
to write to a disk file. In Chapter 12, you learned how to read and write in-memory 
string objects through the use of istringstream 
and ostringstream 
objects. In this 
chapter we will discuss the fstream class, which allows a file to be used for both input 
and outp ut. We will also cover additional materia l related to outp ut formatting, error 
testing, binary files, random -access files, and data serialization. 
853 

854 
Chapte r 1 3 
Advanced File and 1/0 Operations 
The File Stream Classes 
Th e i fstream , ofst ream, and fstream 
classes are very similar. Each has a defa ult 
constructor that allows instances of the class to be created: 
i fstream () 
of stream() 
fstream () 
In addit ion, each has initialization constr uctors that take two parameters: the name 
of a file to be opened and an open mode . The name of the file is given by a C-string. 
Th e open mode is a setting that determines how the file will be used . The initialization 
constructo rs have the follow ing prototypes: 
if stream(const 
char* filename , ios: :openmode mode= ios: :in ) 
ofstream(const 
char* filename , ios: :openmode mode= ios: :out ) 
fstream (const char* f il ename, 
ios: :openmode mode = ios : :i n I ios: :out); 
Beginning with C++l 1, you can use a str i ng object for the filename: 
ifstream
(const string& 
fi l ename, ios::openmode 
mode= ios::in) 
ofstream(const 
string& 
fi l ename, ios: :openmode mode= ios: :out ) 
fstream (const str i ng& f ile name, 
ios: :openmode mode = i os: :i n I ios: :out); 
The open mode parameter is optional. When not specified, the open mode defaults to 
the values shown in the initialization constr uctors. Th e meaning of these open mode 
values and others like them is explained in Table 13-1. 
All three file stream classes have member functions with parameters similar to those of 
the initialization constr uctors that can be used to open files. For example, the open 
functions for fstream 
have the following prototypes: 
voi d open (const char* f ile name, 
ios::openmode 
mode= i os: :in 
voi d open (const string& filename, 
ios::openmode 
mode= i os: :in 
ios: :out); 
ios: :out); 
Each of these classes also has a c 1 ose membe r function that is used to sever the connection 
when the program is done using the file: 
voi d c 1 ose () ; 
Open files use resources in the operating system, so it is important to close files as soon 
as you are done using them. Also, data that your program writes to the file stream 
object is often buffered within the operating system and is not immediately written to 
disk . When you close the file, the operat ing system writes this data to the disk in a 
process known as flushing the buffer. Closing the file will ensure that buffered data is 
not lost in the event of a power failure or some other circumstances that causes your 
program to terminate abnormally. 
The fstream class combines in itself the capabilit ies of both i fstream and of stream. 
Therefore, fstream has every member function and operato r possessed by those two 
classes . In particular , you can use the extraction operator>> and the insertion operator 
<< to read and write data on fstream objects. 

13.1 Input and Output Streams 
855 
By default, i fstream objects open files for input , of stream objects open files for 
output , and fstream objects open files for both input and output. Program 13-1 gives 
a simple (albeit not very useful) example of using an fstream object to open a file for 
both reading and writing. It opens the file, reads and prints its contents, and then 
writes the word "Hello" at the end of the file. If you start with an empty file named 
"inout .txt," repeated execut ion of this program will result in the word "Hello" being 
added to the file each time the program is run. 
Program 1 3-1 
1 //This 
program demonstrates 
reading and writing 
2 Ila 
fi le through an fstream object. 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 #include 
<str i ng> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
fstream i nOutFile; 
11 
12 
string 
word; 
13 
// Open the file 
// Used to read a word from the file 
14 
inOutFi le .open("inout.txt"); 
15 
if (i nOutFi le .fail()) 
16 
{ 
17 
cout << "The file 
was not found . "<< endl ; 
18 
return 
1; 
19 
} 
20 
21 
// Read and print 
every word already 
in the file 
22 
whi le (inOutFile 
>> word) 
23 
{ 
24 
25 
26 
} 
cout <<word<< 
endl; 
27 
II Clear end of fi le flag to allow additional 
fi le operations 
28 
inOutFi le .clear(); 
29 
30 
// Write a word to the file 
and close the file 
31 
inOutFi le <<"Hello"<< 
endl; 
32 
inOutFi le .close(); 
33 
34 
return 
O; 
35
} 
Program Output (Sample) 
Hello 
Hello 
Hello 

856 
Chapter 1 3 
Advanced File and 1/0 Operations 
In Program 13-1, the loop of lines 22- 25 terminate s only when the extraction operator 
fails to read the next word at the end of the file. File stream objects set a number of 
error flags whenever an input or output operation fails. Once an error flag is set, the 
stream will not allow further operations to be performed on it until the error flags have 
been cleared . The call to the cl ear function in line 28 clears these flags, allowing the 
statements in lines 31 and 32 to succeed . 
File Open Modes 
A file open mode is a setting that determines how the file can be used. The type openmode 
is defined in a stream -related class called i os. Values of this type are static constant 
members of the ios class. Each such value represents a flag or an option that can be set 
when the file is opened . Table 13-1 lists the mode flags together with their meanings. 
Table 13-1 
File Mode Flags 
File Mode Flag 
Meaning 
i os:: app 
i os:: ate 
i os: : bi nary 
i OS: 
: in 
i os: :out 
i os::trunc 
<) 
Append: Output will always take place at the end of the file. 
At end: Output will initially take place at the end of the file. 
Binary: Data read or written to the file is in binary form. 
Input: The file will allow input operations . If the file does 
not exist, the open will fail. 
Output: The file will allow output operat ions. If the file 
does not exist, an empty file of the given name is created . 
Truncate: If the file being opened exists, its contents are 
discarded and its size is truncated to zero. 
The binary or operator I can be used to combine the effect of two or more flags. For 
example, the open mode 
i os: : in I i os: : out I i os: : ate 
causes the file to be opened for both input and output, with output initially taking 
place at the end of the file. Here is an example of opening three files for input, output, 
and input -output using fstream: 
fstream i nFile , outFile, 
inOutFile; 
inFile.open
("in.txt", 
ios: :in); 
outFile
.open("out.txt", 
ios: :out); 
out Fi 1 e . open ( "i nout. txt" , i os: : in I i os: : out); 
NOTE: When used by itself, the ios: :out flag causes the contents of an existing 
file to be deleted, the assumption being that the programmer wants to overwrite the 
file. If i os: : out is combined with i os: : app, the contents of the existing file are 
preserved, and all new data is appended to the end of the file. 

13.1 Input and Output Streams 
85 7 
Using Constructors to Open Files 
Using one of the initialization constr uctors, you can create a stream object and open a 
file in a single statement: 
fstream 
outFile("
i nout .txt", 
ios: :in I ios: :out); 
Output Formatting and 1/ 0 Manipulators 
The 1/0 manipulators you learned about in Chapter 3 can be used on stream objects. In 
particular, the manipulators 
setw (n) 
showpoint 
1 eft 
fixed 
setprecision(n) 
right 
can be used on fstream , of stream , and ostri ngstream objects . To illustrate, consider 
the need for a function that takes an argum ent of type doub 1 e representing the price 
of an item in dollars and returns a string that starts with the dollar sign $ and 
represents the value of the price to two decimal places. For example, an amo unt of 
12. 5 passed as parameter would result in the function returning the string $12. 50. 
We can easily write this function using our knowledge of ost ri ngst ream gained 
from Chapter 12: 
string 
dollarFormat(double 
amount) 
{ 
} 
// Create ostringstream 
object 
ostr i ngstream outStr; 
//
Setup 
format information 
and write 
to outStr
. 
outStr 
<< showpoint <<fixed<< 
setprecis
i on(2); 
outStr 
<< '$' 
<< amount; 
// Extract 
and return 
the string 
inside 
outStr
. 
return 
outStr.str(
); 
Program 13-2 uses the dollarFormat 
function to write a neatly formatted table of 
prices. Th e prices are given in a two-dimensional array. The program formats each 
price and prints a tab le of all prices, with each price being right-justified in a column of 
width 10. 
Program 1 3-2 
1 // Thi s program demonstrates 
the use of an ostringstream 
2 // object 
to do soph i sticated 
formatt i ng . 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 #include 
<sstream> 
6 using namespace std ; 
7 
8 string 
dollarFormat
(double ); // Function 
Prototype 
9 
(program continues) 

858 
Chapte r 13 
Advanced File and 1/0 Operations 
Program 1 3-2 
(continued) 
10 int main() 
11 { 
12 
13 
14 
15 
const 
int ROWS= 3, COLS= 2 ; 
double amount[ROWS] [COLS] = {184.45, 
64.32 , 
7 , 59 .13, 
7 . 29, 
1289} ; 
16 
II Format table 
of dollar 
amounts r i ght justif
i ed 
17 
II i n columns of wi dth 10 
18 
cout << right
; 
19 
for (i nt row= O; row< ROWS; row++) 
20 
{ 
21 
22 
23 
24 
25 
for (int 
column= 
O; column< 
COLS; column++) 
{ 
cout << setw(10) 
<< dollarFormat(amount[row](column
] ); 
} 
26 
cout << endl ; 
27 
} 
28 
return 
O; 
29 } 
30 
31 //************************************************** 
32 II formats 
a dollar 
amount 
* 
33 //************************************************** 
34 string 
dollarFormat
(double amount ) 
35 { 
36 
II Create 
ostringstream 
object 
37 
ostringstream 
outStr
; 
38 
39 
II Set up format information 
and wri te to outStr. 
40 
outStr 
<< showpoint 
<<fixed<< 
setprecision(2); 
41 
outStr 
<< '$' 
<< amount; 
42 
43 
II Extract 
and return 
the string 
i nside outStr. 
44 
return 
outStr.str(); 
45 } 
Program Output 
$184.45 
$7.00 
$59. 13 
$64. 32 
$7.29 
$1289.00 
Table 13-2 shows a list of 1/0 manipulators that can be used with C++ stream objects 
and gives a brief description of their meanings. 
Table 13 -2 1/0 Manipulators 
Manip ulator 
dee 
endl 
Description 
Displays subsequent numbers in decimal format. 
Writes new line and flushes output stream. 
(table continues) 

13.1 Input and Output Streams 
859 
Table 13-2 
1/0 Man ipulators (continued) 
Manipulator 
fixed 
flush 
hex 
left 
oct 
r i ght 
scientific 
setfi 11 (ch) 
setprecision(n) 
setw( n) 
showbase 
noshowbase 
showpoint 
noshowpoint 
showpos 
noshowpos 
Description 
Uses fixed notation for floating -point numbers. 
Flushes output stream. 
Input s or outputs in hexadecimal. 
Left justifies output . 
Input s or outputs in octal. 
Right justifies output . 
Uses scientific notation for floating -point numbers. 
Makes ch the fill character. 
Sets floating-point precision to n. 
Set width of output field to n. 
Shows the base when printing numbers. 
Does not show the base when printing numbers. 
Forces decimal point and trailing zeros to be displayed. 
Prints no trailing zeros and drops decimal point if possible. 
Prints a + with nonnegative numbers. 
Prints no + with nonnegative numbers. 
You have already encountered some of these manipulators in Chapter 3. The oct, dee, 
and hex manipulators can be used with both input and outp ut streams; they allow 
numbers to be read or written using the octal, decimal, or hexadecimal number systems. 
Program 13-3 demonstrates 
how to use ci n and cout to read and write decimal, 
hexadecimal, and octa l values. 
Program 13 -3 
1 //This 
program demonstrates 
input and output of numbers 
2 //u sing the octal , dec imal, and hexadec imal number systems. 
3 #include 
<iostream> 
4 #include 
<iomanip> 
5 using namespace std ; 
6 
7 
8 
9 
int 
{ 
main() 
int a, 
II Read 
cout << 
ci n >> 
b; 
two decimals 
and print 
hex and octal 
equivalents 
"Ent er two dec imal numbers: "; 
a >> b; 
10 
11 
12 
13 
cout << "The numbers in decimal: 
"<<a<< 
'\t' 
<< b << endl ; 
(program continues) 

860 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Program 13 -3 
(continued) 
14 
"The numbers in hexadec i mal: "<< 
hex 
cout << 
<< 
15 
showbase <<a<< 
'\t' 
<< b << end l; 
16 
"The numbers in octal: 
"<< 
oct 
cout << 
<< 
17 
a<< 
'\t' 
<< b << end l; 
18 
19 
20 
21 
22 
23 
24 
II Read 
cout << 
ci n 
>> 
cout << 
some hexadec i mals and print 
their 
decimal 
equivalents 
"Ent er two hexadecimal 
numbers: 
"; 
hex>> 
a>> 
b ; 
"You entered 
decimal 
"<< 
dee 
<<a<< 
'\t' 
<< b << endl ; 
25 
II Read some octals 
and print 
the i r decimal 
equivalents 
26 
cout << "Ent er two octal 
numbers: 
"; 
27 
28 
29 
30 
ci n 
cout 
>> oct >> a>> 
b; 
<< "You entered 
decimal 
" << dee 
<<a<< 
'\t' 
<< b << endl ; 
31 
return 
O; 
32 } 
Program Output With Sample Input Shown In Bold 
Enter 
two decimal 
numbers: 
234S[Enter] 
The numbers in decimal: 
23 
45 
The numbers in hexadecimal: 
Ox17 
Ox2d 
The numbers in octal: 
027 
055 
Enter 
two hexadecimal 
numbers: 
17 2d[Enter] 
You entered 
decimal 
23 
45 
Enter 
two octal 
numbers: 
27 55 
You entered 
decimal 
23 
45 
Recall that when a program writes data to an open file, the data does not go directly to 
the file. Instead, the data is stored in an outp ut buffer associated with the file and is later 
transferred to the file in a process known as flushing the buffer. Usually the buffer is 
flushed only if it is full or when the file is closed. Th e endl and fl us h manipulators allow 
the programmer to flush the buffer at any time, hence forcing transfer of buffered data to 
the file. For example, the following statement flushe s the buffer of an output stream: 
outF i le << flush; 
Th e scientific 
man ipulator causes floating-point numbers to be written out in scientif ic 
notation, that is, in the form d .dddEdd . Th e fill character is the character that is written 
when a printed number does not fill the entire field it is printed in. By defa ult, the fill 
character is a blank. Th e programmer can specify a different fill character by using the 
setfi 11 man ipulator. For example, 
outFile 
<< setfi
11 ('%'); 
will make the percent characte r (%) the fill character. 

13.2 More Detailed Error Testing 
861 
~ 
Checkpoint 
13.1 Name three different C++ classes that can be used to create input streams. 
13.2 Name three different C++ classes that can be used to create output streams . 
13.3 
What is the purpose of the second parameter to the file stream member function 
open? 
13.4 
Why is it important for a program to close an open file as soon as it is done 
using the file? Give two reasons . 
13.5 Which file open flag causes all output to take place at the end of the file? 
13.6 Which file open flag causes the contents of an existing file to be discarded and 
the file size reduced to zero? 
13. 7 What happens if i os: : out is used by itself to open a file that does not exist? 
13.8 What happens if i os: : out is used by itself to open an existing file? 
13.9 Write a sequence of C++ statements that reads in two numbers entered in octal 
format and separated by whitespace and prints their sum in octal. 
13.10 Write a sequence of C++ statements that reads in two hexadecimal numbers and 
prints the sum of the numbers twice, once in decimal and the second time in 
hexadecimal. 
13.11 Show how to use the constructor of the fst ream class to open a file for input 
without having to call the open function . 
13.12 Consider two parallel arrays of the same size, one containing strings and the 
second containing integers. Write C++ statements to output the information in 
the two arrays as a table of names and numbers . The first column of the table 
will contain the names left-justified in a field of 20, and the second column will 
conta in the integers right-justified in a field of 10. Here is an example of the 
data when the size of the array is 2. 
const i nt SIZE= 2; 
st ring names[SIZEJ = {"Cat herine", 
"Bi ll"}; 
i nt numbers[SIZEJ = {12, 2005}; 
More Detailed Error Testing 
CONCEPT : All stream objects have error state bits that indicate the condition of the 
stream. 
All stream objects contain a set of bits that act as flags. These flags indicate the current 
state of the stream . Table 13-3 lists these bits. 

862 
Chapter 1 3 
Advanced File and 1/0 Operations 
Table 13 -3 Files Condition Bit Flags 
Bit 
Description 
i os: : eofb i t 
io s: :fai l bit 
i os: : hardfai 1 
i OS: 
: bad bit 
io s: :goodbit 
Set when the end of an input stream is encountered. 
Set when an attempted operat ion has failed. 
Set when an unrecoverable error has occurred . 
Set when an invalid operation has been attempted . 
Set when all the flags above are not set. Indicates the stream is in good 
cond ition. 
Th ese bits can be tested by the member functions listed in Table 13-4. One of the 
functions listed in the table, cl ear (), can be used to set a status bit. 
Table 13 -4 Member Functions That Report on the Bit Flags 
Function 
eof () 
fai 1 () 
bad () 
good () 
clear() 
Description 
Returns true (nonzero ) if the eofbi t flag is set; otherwise returns false. 
Returns true (nonzero ) if the fai 1 bit or hardfai 1 flags are set; otherwise returns 
false. 
Returns true (nonzero ) if the badbi t flag is set; otherwise returns false. 
Returns true (nonzero ) if the good bit flag is set; otherwise return s false. 
When called with no arguments, clears all the flags listed above. Can also be 
called with a specific flag as an argument . 
The function showState , shown here, accepts a file stream reference as its argument . It 
shows the state of the file by displaying the return values of the eof (), f ai 1 (), bad(), 
and good ( ) member functions: 
voi d showState (fstrea m &file ) 
{ 
) 
cout << "File Status:\n"; 
cout <<" 
eof bit: 
"<< file.eof() 
<< endl ; 
cout <<" 
fail 
bit: 
" <<fi
le. fail () << endl ; 
cout <<" 
bad bit: 
"<<file.bad()<< 
endl ; 
cout <<" 
good bit: 
"<<f
i le.g ood ()<< 
endl ; 
fil e .clear(); 
// Clear any bad bits 
Program 13-4 uses the showState function to display testF i 1 e's status after vario us 
operations . First, the file is created, and the integer value 10 is stored in it. The file is 
then closed and reopened for input . Th e integer is read from the file, and then a second 
read operat ion is performed. Since there is only one item in the file, the second read 
operation will result in an error. 

13.2 More Detailed Error Testing 
863 
Program 1 3-4 
1 II Thi s program demonstrates 
the return 
value of 
2 II the stream object 
error 
testing 
member functions. 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 using namespace std ; 
6 
7 II Function 
prototype 
8 void showState(fstream 
&); 
9 
10 int main() 
11 { 
12 
13 
14 
15 
II Open a file
, write 
a number, and show 
fstream 
testFile("stuff.dat", 
i os: :out); 
if (testFile.fa
i l()) 
{ 
16 
cout << "cannot open the file.\n"; 
17 
return 
O; 
18 
} 
19 
int num = 10 ; 
20 
cout << "Writing 
to the file
. \n"; 
21 
testFile 
<< num; 
22 
showState (t estF i le); 
23 
testFile.close(
); 
24 
file 
status 
25 
II Open the same file
, read the number, show status 
26 
testFile.open
("stuf f .dat ", ios: :i n); 
27 
if (testFile.fa
i l()) 
28 
{ 
29 
cout << "cannot open the file.\n"; 
30 
return 
O; 
31 
} 
32 
cout << "Reading from the file.\n"; 
33 
testFile 
>> num; 
34 
showState (t estFile)
; 
35 
36 
II Attempt an inval i d read, 
and show status 
37 
cout << "Forcing 
a bad read operation
. \n"; 
38 
testFile 
>> num; 
39 
showState (t estFile)
; 
40 
41 
II Close f i le and quit 
42 
testFile.close(
); 
43 
return 
O; 
44 } 
45 
46 //********************************************************* 
47 II Definition 
of function 
showState. 
Thi s function 
uses 
* 
48 II an fstream 
reference 
as its 
parameter
. The return 
* 
49 II values 
of the eof()
, fa i l() , bad(), 
and good() member 
* 
50 II functions 
i s displayed
. The clear() 
function 
i s called 
* 
51 II before 
the function 
returns. 
* 
52 //********************************************************* 
(program continues) 

864 
Chap ter 1 3 
Advanced File and 1/0 Operations 
Program 1 3-4 
(continued) 
53 void showState
(fstream 
&file ) 
54 { 
55 
cout << "Fi le Status:
\ n" ; 
56 
57 
58 
59 
60 
61 } 
cout <<" 
eof bit : " << fi l e . eof () << end l; 
cout <<" 
fai l bi t : "<<file.fail
()
<< end l; 
cout <<" 
bad bit : " <<fi
l e . bad ()
<< end l; 
cout <<" 
good bi t : "<<file.good
()
<< end l; 
file.clear
(); 
// Clear 
any bad bits. 
Program Screen Output 
Writing 
to the file. 
File 
Status: 
eof bit: 
0 
fail 
bit: 
O 
bad bit: 
0 
good bit: 
1 
Reading from the file. 
File 
Status: 
eof bit: 
1 
fail 
bit: 
O 
bad bit: 
0 
good bit: 
O 
Forcing 
a bad read operation. 
File 
Status: 
eof bit: 
1 
fail 
bit: 
1 
bad bit: 
0 
good bit: 
O 
For th e purp ose of error testing, a stream ob ject behaves as a Boolean expr ession th at 
is true when no err or flags are set and is false oth erwise . To check whether th e last 
opera tion perfor med on a stream dataF i 1 e succeeded, you can write 
if 
(datafi
l e ) 
{ 
cout << "Success !"; 
} 
To check whether th e operation failed due to so me error, yo u ca n call the fail
(} 
mem ber funct ion, or alternatively, you can wr ite 
if 
(! datafile
} 
{ 
cout << "Fail ure !"; 
} 

13.3 Membe r Functions for Reading and Writing Files 
865 
13.3 
Member Functions for Reading 
and Writing Files 
CONCEPT: 
File str eam objects have memb er fun ction s for mor e specialized file 
readin g and writin g. 
If whitespace characters are part of the information in a file, a problem arises when the 
file is read by the >> operator. Since the operator considers whitespace characters as 
delimiters, it does not read them. For examp le, consider the file mur phy. txt that 
conta ins the following information: 
Figure 13-1 
Jayne Murphy 
47 Jones Circle 
Almond, NC 28702 
Figure 13-1 shows the way the information is recorded in the file. 
J 
a I y 
n I e I 
M 
u I r I p 
h 
y 
J 
0 
n 
e 
s 
C 
r 
C 
m 
0 I n I d 
N 
C 
2 
2 
\n EEOF>
I 
\n 
4 
7 
e 
\n 
A 
8 
7 
0 
The problem that arises from use of the>> operator is evident in the output of Program 13-5. 
Program 1 3-5 
1 II Thi s pr ogr am shows the behavior of the
>> operator 
2 II on f i les t hat conta i n s pac es as par t of th e i nf ormation. 
3 II The program r eads t he cont ent s of the f il e and transfe
r s 
4 II t hose cont ents to standa rd out put. 
5 #in clude <iost rea m> 
6 #in clude <st ri ng> 
7 #in clude <fs t r eam> 
8 usin g namespace st d ; 
9 
10 int main () 
11 { 
12 
II var i abl es needed t o r ead fi le 
13 
fstream 
f i le ; 
14 
stri
ng i nput ; 
(program continues) 

866 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Program 1 3-5 
(continued) 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 } 
// Open the fi le 
file.open
( "murphy.txt", 
ios: :in); 
if (! file } 
{ 
} 
cout << "File 
open error
!"<< 
endl ; 
return 
O; 
// Read the fi le and echo to screen 
file>> 
input ; 
whi 1 e ( ! fi 1 e . fa i 1 ()) 
{ 
} 
cout << input; 
file>> 
input; 
// Close the file 
file.close(); 
return 
O; 
Program Screen Output 
JayneMurphy47JonesCircleAlmond,NC28702 
The getl i ne function 
One way to get around the problem in Program 13-5 is to use a function that reads an 
entire line of text. There is a global function that is part of the string library that you 
can use for this purpose: 
istrea
m& getline 
(is tream& is , string& 
str , char delim = '\n'); 
This function reads a line of text from a stream is and stores it into a string variable 
st r. The function has an optional parameter de 1 i m that marks the end of the line to be 
read. The delimiting character is removed from the stream and discarded . If getl i ne is 
called witho ut the third parameter , the delimiter is assumed to be the end of line 
character ' \ n ' . 
The first parameter, is , must be an object of the class i stream. It can also be any 
object of the classes i stri ngstream , i fstream , or fstream (if an fstream object is 
passed, it must have been opened for input ). The value returned is a reference to the 
input stream that was just read . This allows the return value to be tested to ascertain 
the success or failure of the call as in this code fragment: 
string 
str ; 
if 
(getline
(inputstr
eam, str}) 
{ 

13.3 Member Functions for Reading and Writing Files 
867 
} 
else 
{ 
II A line was read and stored 
instr 
cout << str << endl; 
II An error 
occurred 
or we reached end of file 
} 
Alternatively, you can ignore the return value and test the stream in a statement after 
the call: 
string 
str ; 
getl i ne (i nputstream, 
str}; 
i f (i nputstream) 
{ 
} 
else 
{ 
II A line was read and stored 
instr 
cout << str << endl; 
II An error 
occurred 
or we reached end of f i le 
} 
Program 13-6 is a modification of Program 13-5 that uses the getl i ne function to read 
the file line by line, thereby preserving the wh itespace between words . 
Program 1 3-6 
1 II Thi s program uses the getline 
f unction 
to read 
2 II a line 
of i nformation 
from the f i le . 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 #include 
<fstream> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
II Variables 
needed fo r file 
input 
11 
fstream 
nameFile; 
12 
str i ng i nput; 
13 
14 
II Open the file 
15 
nameFile .open("murphy .txt" , ios::in); 
16 
if (! nameFi l e ) 
17 
{ 
18 
cout << "Fi le open error
!"<< 
endl ; 
19 
return 
O; 
20 
} 
21 
22 
23 
24 
II Read f i rst line 
of the fi le 
getline
(na meFile , inp ut}; 
while 
(nameFi le) 
(program continues) 

868 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Program 1 3-6 
(continued) 
25 
{ 
26 
27 
28 
29 
} 
30 
II If s uccessful
, print 
l i ne and read anothe r line 
cout <<input<< 
end l; 
getline
(nameFile , i nput}; 
31 
II Close the f i l e 
32 
nameFi le .close(); 
33 
return 
O; 
34 } 
Program Screen Output 
Jayne Murphy 
47 Jones Circle 
Almond, NC 28702 
Because the third argument of the getl i ne function was left out in Program 13-6, its 
default value is \ n. Sometimes you might want to specify another delimiter. For 
example, consider a file that contains multiple names and addresses internally formatted 
in the following manner: 
Content s of addresses. 
txt 
Jayne Murphy$47 Jones Circle$Almond, 
NC 28702 \n$ Bobbie Smith$ 
217 Halifax 
Drive$Canton, 
NC 28716 \n$ Bil l Hammet$PO Box 121$ 
Springfield, 
NC 28357\n$ 
Th ink of this file as consisting of three records. A record is a complete set of information 
abo ut a single item . Also, the records in the file are made of three fields. Th e first field 
is the person's name. Th e second field is the person's street address or PO box numbe r. 
Th e third field contains the person's city, state, and ZIP code . Notice that each field 
ends with a $ character, 
and each record ends with a \ n character. 
Program 13-7 
demonstrates how a get 1 i ne function can be used to detect the $ characters . 
Program 13 -7 
1 II Thi s f i le demonstrates 
the getline 
function 
wi th a 
2 II user-specified 
deli mit er . 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 #include 
<fstream> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
II Variable 
needed to read file 
11 
str i ng i nput; 
12 
13 
II Open the file 
(program continues) 

13.3 Membe r Functions for Reading and Writing Files 
869 
Program 13 -7 
(continued) 
14 
fstream 
datafile("addresses.txt", 
ios::in); 
15 
if 
( !datafile) 
16 
{ 
17 
cout << "Error 
opening file."; 
18 
return 
O; 
19 
} 
20 
21 
II Read l i nes terminated 
by '$' 
sign and output 
22 
get 1 i ne ( datafi 
1 e , input, 
'$' ) ; 
23 
while 
(!da tafile.fail
()} 
24 
{ 
25 
cout <<input<< 
endl; 
26 
get 1 i ne ( datafi 
1 e , input, 
'$' ) ; 
27 
} 
28 
29 
II Close the f i le. 
30 
dataf i le .close(); 
31 
return 
O; 
32 } 
Program Output 
Jayne Murphy 
47 Jones Circle 
Almond, NC 28702 
Bobbie Smith 
217 Halifax 
Drive 
Canton, 
NC 28716 
Bill 
Hammet 
PO Box 121 
Springfield
, NC 28357 
<) 
a 
VideoNot e 
The get 
Family of 
Member 
Functions 
Notice that the \n characters, which mark the end of each record, are also part of the 
output. They cause an extra blank line to be printed on the screen, separating the records. 
NOTE: 
When using a printable characte r such as$ to delimit information in a file, 
be sure to select a character that will not actually appear in the information itself. 
Since it's doubtful that anyone's name or address conta ins a $ character, it's an 
acceptable delimiter. If the file contained dollar amounts, however, another delimiter 
would have been chosen. 
The get Family of Member Functions 
Each of the input classes i fstream, 
fstream, 
and i str i ngstream has a family of get 
member functions that can be used to read single characters: 
i nt get(); 
istream& get(char& 
c}; 

870 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Th e first version reads a single character. 
If successfu l, it returns an int eger code 
represent ing the character that was read. If unsuccessful, it sets the error codes on the 
stream and returns the special value EOF. Program 13-8 uses the get function to copy a 
file to the screen . Th e loop of lines 27- 32 terminates when get () returns EOF. 
Program 1 3-8 
1 II Thi s program demonstrates 
the use of the get member 
2 II functions 
of the i stream class 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 #include 
<fstream> 
6 using namespace std ; 
7 
8 int 
mai n () 
9 { 
10 
II Variables 
needed to read file 
one character 
at a time 
11 
string 
fileName ; 
12 
fstream 
f i le ; 
13 
char ch; 
II character 
read from the file 
14 
15 
II Get file 
name and open fi le 
16 
cout << "Enter a fi 1 e name: "; 
17 
ci n >> fileName ; 
18 
19 
f i le.open(fi
leNa me.c _str (), 
ios: :in ); 
20 
if 
( !file
) 
21 
{ 
22 
cout << fileName 
<<" 
could not be opened.\n"; 
23 
return 
1; 
24 
} 
25 
26 
II Read f i le one character 
at a t i me and echo to screen 
27 
ch= 
file.get
(); 
28 
while 
(ch != EOF) 
29 
{ 
30 
31 
32 
33 
} 
cout << ch ; 
ch = fi 1 e . get() ; 
34 
II Close fi l e 
35 
f i le.c lose (); 
36 
return 
O; 
37
} 
Program 13-8 will display the contents of any file. Because the get function does not 
skip whitespaces, all the characters will be shown exactly as they appear in the file. 
Th e second version of get takes a reference to a character variable to read into and 
returns the stream that was read from . If you use this version of the function, you must 

13.3 Member Functions for Reading and Writing Files 
8 71 
test the stream to determine whether the operation was successful. The behavior of 
Program 13-8 will not change if you replace lines 27- 32 with following code: 
27 
file.get(ch); 
28 
while 
(!f ile .fail
()) 
29 
{ 
30 
31 
32 
} 
cout << ch; 
file
.get(ch); 
The peek Member Function 
The peek member function is similar to get, but there is an important difference. When 
the get function is called, it returns the next characte r available from the input stream 
and removes that characte r from the stream. In contrast, the peek function returns a 
copy of the next character available without remo ving it from the stream. Thu s, 
get () reads a characte r from the file, but peek () just "looks" at the next character 
without act ually reading it. To see the difference, suppose that a newly opened file 
contains the string "abc". Then the sequence of statements 
char ch = inF i le .get (); 
II Read a character 
cout << ch; 
II Output the character 
ch= 
inFile.get(); 
II Read another 
character 
cout << ch; 
II Output the character 
will print the two characters "ab" on the screen. However, the statements 
char ch= 
inFile.peek(); 
II Return the next character 
without reading it 
cout << ch; 
II Output the character 
ch= 
inFile.get(); 
II Now read the next character 
cout << ch; 
II Output the character 
will print the two characters "aa" on the screen. 
The peek function is useful when you need to know what kind of data you are about to 
read before you actually read it, so you can decide on the best input method to use. If 
the data is numeric, it is best read with the stream extract ion operator >>, but if the 
data is a non-numeric sequence of characters, then it should be read with get or 
getline. 
Progr am 13-9 uses the peek function in making a modified copy of a file by 
incrementing the value of each integer number appearing in the file by one. 
Program 1 3-9 
1 II Thi s program demonstrates 
the peek member funct i on . 
2 #include 
<iostream> 
3 #include 
<str i ng> 
4 #include 
<fstream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
II Variables 
needed to read characters 
and numbers 
10 
char ch; 
11 
int number; 
(program continues) 

872 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Program 1 3-9 
(continued) 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 } 
II Variables 
for f il e hand ling 
string 
fileName ; 
fstream 
inFile, 
outF il e; 
II Open the file 
to be modified 
cout << "Enter a fi 1 e name: "; 
ci n >> fileName ; 
inFile
.open(fileName.c
_s tr(}, 
ios: :i n); 
if ( !i nFile) 
{ 
} 
cout << "Cannot open file"<< 
fileName ; 
return 
1; 
II Open the file 
to receive 
the modi f ie d copy 
outFile.open("modified.txt", 
i os::out); 
if ( !outF ile } 
{ 
} 
cout << "Cannot open the output 
f ile.
"; 
return 
2 ; 
II Copy the input file 
one characte
r at a ti me 
II except numbers in the input file 
must have 1 
II added to them 
II Peek at the first 
characte
r 
ch= 
i nFile.peek(); 
while 
(ch != EOF) 
{ 
} 
II Examine current 
characte
r 
if (isdigit(ch)} 
{ 
} 
else 
{ 
} 
II Numbers should be read with>> 
inFile 
>> number ; 
outFi le <<number+ 
1; 
II Just 
a simple characte
r, read it and copy it 
ch = inF i le .get(); 
outFi le << ch ; 
II Peek at the next character 
from input 
fi le 
ch= 
i nFile.peek(}; 
II Close the files 
inF i le .close(); 
outFile.close(); 
return 
O; 
(program continues) 

13.3 Member Functions for Reading and Writing Files 
8 73 
Program 1 3-9 
(continued) 
Sample Input FIie 
Amy is 23 years old. 
Robert is 50 years old. 
The 
difference 
between their 
ages is 27 years. 
Amy was born 
in 1986. 
Program Ouput for the Given Sample Input FIie 
Amy is 24 years old. 
Robert is 51 years old. 
The 
difference 
between their 
ages is 28 years. 
Amy was born 
in 1987. 
a 
VideoNot e 
Rewinding 
a File 
The program cannot tell beforehand whether the next character to be read is a digit 
that starts a number (in which case the entire number should be read using the stream 
extraction operator >>) or just an ordinary nondigit character (in which case the 
character should be read using a call to the get () member function). The program 
therefore uses peek () to examine characters without actually reading them (lines 38 
and 55). If a character is a digit, the extraction operator is called to read the number 
that starts with that character (lines 44-46). Otherwise, the character is read using a 
call to get () (lines 50- 52) and copied to the target file. 
The put Member Function 
Each of the outp ut stream classes ofstream
, fstream, 
and ostringstream 
has a 
member function 
ostream& put(int 
c); 
that takes the integer code of a character and writes the corresponding character to the 
stream . You can think of put as the output stream counterpart to the input stream get 
functions. As an example, the following simple program prints AB on the screen. 
1 #i nclude <i ostream> 
2 using namespace std; 
3 int 
main() 
4 { 
5 
char ch = 'A' ; 
6 
cout.put(ch); 
7 
cout.put(ch 
+ 1); 
8 } 
Rewinding a File 
Many times it is useful to open a file, process all the data in it, rewind the file back to 
the beginning, and process it again, perhaps in a slightly different fashion. For example, 
a user may ask the program to search a database for all records of a certain kind, and 
when those are found, the user may want to search the database for all records of some 
other kind. 

874 
Chapte r 13 
Advanced File and 1/0 Operations 
0 
File stream classes offer a number of different member functions that can be used to 
move around in a file. One such method is the 
seekg(offse t , place); 
member function of the input stream classes (the file "seeks" to a certain place in the 
file; the 'g' is for "get" and denotes that the function works on an input stream, because 
we "get" data from an input stream) . The new location in the file to seek to is given by 
the two parameters: the new location is at an offset of offse t bytes from the starting 
point given by p 1 ace . The offset parameter is a 1 ong integer, while p 1 ace can be one of 
three values defined in the i os class. The starting place may be the beginning of the file, 
the current place in the file, or the end of the file. These places are indicated by the 
constants i os: beg, i os: : cur , and i os: : end, respectively. 
More information on moving around in files will be given in a later section. Here we 
are interested in moving to the beginning of the file. To move to the beginning of a file, 
use the call 
see kg ( OL, i os : : beg) ; 
to move O bytes relative to the beginning of the file. 
NOTE: If you are already at the end of the file, you must clear the end of file flag 
before calling this function . Thus , to move to the beginning of a file stream dat aln 
that you have just read to the end, you need the two statements 
dat a In .clear(); 
dat aln .seekg(OL, ios: :beg); 
Program 13-10 illustrates how to rewind a file. It creates a file, writes some text to it, 
and closes the file. The file is then opened for input , read once to the end, rewound, 
and then read again . 
Program 1 3-10 
1 II Program shows how to rewind a file. 
It writes 
a 
2 II t ext fi le and opens it for reading, 
then rewinds 
3 II it to the begin ning and reads i t agai n. 
4 #include 
<iostream> 
5 #include 
<fs t rea m> 
6 using namespace std; 
7 
8 int main() 
9 { 
10 
II Variables 
needed to read or writ e file 
one 
11 
II character 
at a time 
12 
char ch; 
13 
fstream ioFile("rewind.
t xt ", i os: :out ); 
(program continues) 

13.3 Member Functions for Reading and Writing Files 
8 75 
Program 1 3-10 
(continued) 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 } 
II Open f i le 
if ( !i oFile) 
{ 
} 
cout << "Error 
in trying 
to create 
file"; 
return 
O; 
II Wri te to file 
and close 
ioFile 
<<"Allgood 
dogs
• << endl 
<< "growl , bark , and eat.• 
<< endl ; 
i oFi 1 e . c 1 ose () ; 
II Open the file 
i oFi 1 e . open (•rew i nd . txt • , i os: : i n) ; 
if ( !i oFile) 
{ 
} 
cout << "Error 
in trying 
to open file"; 
return 
O; 
II Read the file 
and echo to screen 
ioFile
.get(ch); 
while 
(!ioFi
le.fail
()) 
{ 
cout.put(ch); 
i oFile.get(ch); 
} 
II Rewind the file 
ioF i le .clear(); 
ioFile
.seekg(O, 
i os: :beg); 
II Read f i le aga i n and echo to screen 
ioF i le .get(ch); 
while 
(!ioFi
le.fail
()) 
{ 
cout.put(ch); 
i oFile.get(ch); 
} 
return 
O; 
Program Output 
A 11 good dogs 
growl , bark , and eat. 
A 11 good dogs 
growl , bark , and eat. 

876 
Chapte r 1 3 
Advanced File and 1/0 Operations 
~ 
Checkpoint 
13.13 Make the required changes to the following program so it writes its outp ut to 
the file output. txt instead of to the screen . 
#i nclude <iostream> 
using namespace std; 
int main() 
{ 
} 
cout << "Today i s the first 
day \ n"; 
cout << "of the rest 
of your l i fe . \n"; 
return 
O; 
13.14 Describe the purpose of the eof member function. 
13.15 Assume the file i nput . txt contains the following characters: 
R 
s 
p 
s 
p 
What will the following program display on the screen? 
#include 
<iostream> 
#include 
<string> 
#include 
<fstream> 
us i ng namespace std; 
i nt mai n(} 
{ 
} 
} 
fstream 
inFile( 
"input . txt"
, ios:: i n); 
str i ng item; 
inF il e >> item; 
while 
( ! inFile. 
fail()} 
{ 
cout <<item<< 
endl; 
inF ile 
>> i tem; 
return 
O; 
s 
13.16 Describe the difference between reading a file with the>> operator and with the 
get 1 i ne function. 
13.17 Describe the difference between the getline 
function and the get member 
functions . 
13.18 Describe the purpose of the put member function. 
13.19 What will be stored in the file out. dat afte r the follow ing program runs? 
#i nclude <iostream> 
#include 
<fstream> 
#include 
<iomanip> 
usi ng namespace std; 

int mai n() 
{ 
const 
int SIZE = 5 ; 
ofstream 
outFile("out
.dat"); 
13.4 Binary Files 
877 
double nums[ ] = {100 .279, 1 .719, 8.602 , 7. 777 , 5.099} ; 
outFile 
<< setprec
isio n(2); 
} 
for (i nt count= 
O; count< 
SIZE; count++ ) 
{ 
outFile 
<< setw(8) 
<< nums[count]; 
} 
outFile.close(); 
return 
O; 
13.20 The following program skeleton, when complete, will allow the user to store 
names and telephone numbers in a file. Complete the program. 
#include 
<iostream> 
#include 
<fstream> 
#include 
<cctype> 
II Needed for toupper 
us i ng namespace std; 
int main () 
{ 
} 
II Define a file 
stream object 
here and use 
II the file 
stream to open the file 
phones.dat 
str i ng name, phone; 
cout << "This progra m a 11 ows you to add names and phone\ n" ; 
cout << "numbers to phones .dat .\n"; 
do 
{ 
char add ; 
cout << "Do you wish to add an entry?
"; 
cin >> add ; 
i f (t oupper(a dd) == 
'Y') 
{ 
} 
II Write code here that 
asks the user fo r a name 
II and phone number, then stores 
it in the file 
} while 
(t oupper (add ) == 
'Y'); 
II Don't forget 
to close 
the file
. 
return 
O; 
Binary Files 
CONCEPT: 
Values of numeric data types such as int and double must be formatt ed 
for output before being written to text files. No such formatting takes 
place when number s are writte n to binary files. 
A short integer number such as 1297 has both a string representation "1297" (shown 
in Figure 13-2) and a binary numer ic representation (shown in Figure 13-3). Both 
representations can be viewed as sequences of bytes. The string representation depends 

878 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Figure 13-2 
Figure 13-3 
on the type of encoding used to represent individual characters and is 4 bytes long 
when the ASCII encoding is used. The number of bytes in the binary numer ic 
representation depends on the type of the number and is 2 bytes long when the number 
is a short 
int. The conversion of string representation to numeric is called parsing, 
while the reverse conversion from numeric to string is called formatting. 
Although people find it natural to work with numbers in their string representation, 
computer hardware is better adapted to processing numbers in their binary form. This 
is why numbers must be parsed when input from the keyboard or from a file that has 
been edited by a person. It is also the reason numbers must be formatted when being 
output in a form that will be viewed by humans. There are times, however, when a 
program is outputting data to a file that will only be read by other programs and will 
never be viewed by humans . In those cases, formatting of numeric data during output 
and the parsing of numbers during input can be omitted. When data is written in 
unformatted form, it is said to be written in binary, and files written in this way are 
called binary files. In contrast, files that hold formatted data are called text files. 
As a convenience to programmers, the stream insertion operator << provides automat ic 
formatting of numbers during output. Likewise, the stream extraction operator >> 
provides parsing of numeric input. For example, consider the following program fragment: 
ofstrea m fil e ("num.dat"); 
short 
x = 1297; 
file<< 
x; 
The last statement writes the contents of x to the file. When the number is written, however, 
it is stored as the characters ' 1 ',' 2', '9', and '7' . This is illustrated in Figure 13-2. 
' 1' 
'2' 
'9' 
'7' FEOF>
I 
1297 expressed in ASCII 
I 49 I 50 I 57 I 55 F EOF>
I 
The number 1297 isn't stored in memory (in the variab le x) in the fashion depicted in 
Figure 13-2, however. It is formatted as a binary number, occupying 2 bytes on a 
typical PC. Figure 13-3 shows how the number is represented in memory, using binary 
or hexadecimal. 
1297 as a short integer, in binary 
I 00000101 I 00010001 I 
1297 as a short integer, in hexadecimal 
05 
11 

13.4 Binary Files 
879 
The unformatted representation of the number shown in Figure 13-3 is the way the 
"raw" data is stored in memory. Information can be stored in a file in its pure, binary 
format. The first step is to open the file in binary mode. This is accomplished by using 
the i os: : bi nary flag. Here is an example: 
file.open("stuff 
.dat", 
ios: :out 
I ios: :binary); 
Notice the i os: : out and i os: : bi nary flags are joined in the statement with the 
operator. This causes the file to be opened in both output and binary modes. 
0 
NOTE: 
By default, files are opened in text mode. 
The write member function of the ostream and ofstream classes can be used to write 
binary data to a file or other output stream. To call this function, you specify the 
address of a buffer containing an array of bytes to be written and an integer indicating 
how many bytes are to be written: 
wri te(addressOfBuffer, 
numberOfBytes ); 
The write member function does not distinguish between integers, floats, or some 
other type in the buffer; it just treats the buffer as an array of bytes. Because C++ does 
not support a pointer to a byte, the prototype of write specifies that the address of a 
buffer be a pointer to a char: 
wri te(char 
*addressOfBuffer
, int numberOfBytes); 
This means that when we call writ e, we need to tell the compiler to interpret the address 
of the buffer as a pointer to char. We do this by using a special form of type casting called 
a rei nterpret
_cast. Briefly, rei nterpret_cast 
is used to force the compiler to interpret 
the bits of one type as if they defined a value of a different type. Here is an example of 
using re i nterpet _cast to convert a pointer to a double into a pointer to a char. 
doubled= 
45 .9; 
double *pd= &d; 
char *pChar; 
II convert 
pointer 
to double to pointer 
to char 
pChar = reinterpret
_cast<char 
*>(pd); 
In general, to convert a value to some target type, use the expression 
re i nterpret
_cast<TargetType>(value); 
Here are examples of using wri te to write a doub 1 e and an array of doub 1 e to a file. 
double dl = 45.9; 
double dArray[3 ] = { 12.3 , 45.8 , 19 .0 }; 
ofstream 
outFile("stuff.dat", 
ios : :b i nary); 
outFile
.write(reinterpret
_cast<char 
*>(&dl), 
sizeof(d1}); 
outFile
.write(reinterpret
_cast<char 
*>(dArray), 
sizeOf(dArray)}; 
Notice that in writing a single variable such as dl , we treat the variable itself as the 
buffer and pass its address (in this case the address is &dl ). However, in using an array 
as the buffer, we just pass the array because the array is already an address. 

880 
Chapte r 1 3 
Advanced File and 1/0 Operations 
If the data we are writing happens to be character data, there is no need to use the cast. 
Here are some examp les of writing character data. 
char ch = ' X' ; 
char charArray
(5] = "Hello "; 
outF i le .write(&ch, 
sizeof(ch)); 
outF i le .write(charArray, 
sizeof(charArray)); 
Th ere is a read member function in the i stream and i fstream classes that can be used 
to read binary data written by write . It takes as parameters the address of a buffer in 
whic h the bytes read are to be stored and the number of bytes to read: 
read(addressOfBuffer, 
numberOfBytes) 
Th e address of the buffer must be interpreted as a pointer to char using rei nterpret
_cast. 
You can find out if the specified number of bytes was successfully read by calling the fa i 1 () 
member function on the input stream . 
Program 13-11 demonstrates the use of write and read . The program initializes an array of 
integers and then stores the number of array entries in the array using the statements 
i nt buffer[ 
] = {1 , 2 , 3 , 4 , 5 , 6 , 7 , 8, 9 , 10); 
int 
size= 
sizeof(buffer
)/ sizeof(buffer[O
]); 
Recall that the si zeof ope rator can be used on variables to determ ine the number of 
bytes occupied by the variable . Here s i zeof(b
uffer ) returns the number of bytes 
allocated to the array by the initialization statement, and s i zeof ( buffer [ OJ ) returns 
the number of bytes occup ied by a single array entry . By dividing the former by the 
latter, we obtain the number of array entr ies, which we then store in size . 
Program 1 3-11 
1 //This 
program uses the wri te and read functions. 
2 #include 
<iostream> 
3 #include 
<fstream> 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
// File object 
used to access 
file 
9 
fst ream fi 1 e ( "nums. dat " , i os: : out 
I i os: : bi nary) ; 
10 
if 
(! f i le ) 
11 
{ 
12 
cout << "Error 
opening file."; 
13 
return 
O; 
14 
} 
15 
16 
// Integer 
data to wri te to binary 
f i le 
17 
int buffer [ ] = {1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10}; 
18 
int size= 
sizeof(buffer
)/ sizeof(buffer[O
]); 
19 
20 
II Write the data and close 
the file 
21 
cout << "Now writ i ng the data to the file
. \n"; 
(program continues) 

13.5 Creating Records with Structures 
881 
Program 1 3-11 
(continued) 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 } 
file.write(reinterpret
_cast<char 
*>(buffer), 
sizeof(buffer)}; 
file.close(}; 
II Open the fi le and use a binary 
read to read 
II contents 
of the file 
into an array 
file.open("nums.dat", 
ios: :in); 
if (! f i le } 
{ 
} 
cout << "Error opening file."; 
return 
O; 
cout << "Now read i ng the data back into memory. \n"; 
file.read(reinterpret
_cast<cha r *>(buf fer ), 
s i zeof (buf fe r)); 
II Write out the array 
entries 
for (i nt count
= O; count< 
size 
cout << buffer[count
] <<" 
"; 
II Close the file 
file.close(}; 
return 
O; 
count+ +) 
Program Screen Output 
Now writing 
the data to the file. 
Now reading 
the data back into memory. 
1 2 3 4 5 6 7 8 9 10 
13.5 
Creating Records with Structures 
CONCEPT: 
Structures may be used to store fixed-length records to a file. 
Earlier in this chapter the concept of fields and records was introd uced. A field is an 
individual piece of information pertaining to a single item. A record is made up of 
fields and is a complete set of information about a single item. For example, a set 
of fields might be a person's name, age, address, and phone number. Together, all 
those fields that pertain to one person make up a record. 
In C++, structures provide a convenient way to organize information into fields and 
records . For example, the following structure declarat ion could be used to create a 
record containing information about a person. 

882 
Chapte r 1 3 
Advanced File and 1/0 Operations 
<) 
const i nt NAME
_SIZE = 51 , ADDR
_SIZE = 51, PHONE
_SIZE = 14; 
struct 
Info 
{ 
} ; 
char name[NAME
_SIZE] ; 
i nt age; 
char address 1[ADDR_SIZE]; 
char address2 [ADDR_SIZE]; 
char phone[PHONE_SIZE] ; 
Besides providing an organizat ional structure for information, structures also package 
information into a single unit. For example, assume the structure variable person is 
declared as 
Info person; 
Once the members (or fields) of person are filled with information, the entire variable 
may be written to a file using the write function: 
file.w rit e (reinte rpr et _cast<char*>(&person), 
sizeof(person)); 
The first argument is the address of the person variab le. Th e rei nterpret
_cast<char*> 
cast operator is necessary because write expects the first argument to be a pointer to a 
cha r . When you pass the address of anything other than a char to the wri te function, 
you must make it look like a pointer to a char with the cast operator. The second 
argument is the si zeof operator. It tells write how many bytes to write to the file. 
Program 13-12 demonstrates this technique. 
NOTE: 
Since structures can contain a mixture of data types, you shou ld always 
use the i os: : bi nary mode when opening a file to store them. 
Program 13-12 allows you to build a file by filling the members of the person variable, 
then writing the variab le to the file. To read a C-string into an array, the program first 
reads a string object using the get 1 i ne funct ion and then uses st rcpy to move the 
C-string into a characte r array . Program 13-13 opens the file and reads each record 
into the person variable, then displays the information on the screen . 
Program 1 3-12 
1 //This 
progra m demonstrates 
the use of a structure 
var i able 
2 //t o store 
a record of information 
to a f i le . 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 #include 
<cstring> 
6 #include 
<cctype> 
// fo r toupper 
7 using namespace std ; 
8 
9 const int NAME
_SIZE = 51, ADDR
_SIZE = 51 , PHONE
_SIZE = 14; 
10 struct 
Info 
11 { 
12 
char name [NAME
_SIZE]; 
(program continues) 

13.5 Creating Records with Structures 
88 3 
Program 1 3-12 
(continued) 
13 
int age ; 
14 
char address1[ADOR_SIZE]; 
15 
char address2[ADOR_SIZE]; 
16 
char phone[PHONE_SIZE]; 
17 } ; 
18 
19 int 
mai n () { 
20 
Info person ; 
II Store 
information 
about a person 
21 
char response; 
II User response 
22 
23 
str i ng input; 
II Used to read strings 
24 
25 
II Create 
file 
object 
and open file 
26 
fstream 
people("people.dat", 
i os::out 
I ios::b
i nary}; 
27 
if (! people ) 
28 
{ 
29 
cout << "Error 
opening file. 
Program abort i ng . \n"; 
30 
return 
O; 
31 
} 
32 
33 
II Keep getting 
i nformation 
from user and writ i ng i t 
34 
II to the file 
in bina ry mode 
35 
do 
36 
{ 
37 
cout << "Enter person information:\n"; 
38 
cout << "Name: "; 
39 
getline
(cin , input); 
40 
strcpy(person.name, 
input.c
_str()); 
41 
cout << "Age : •; 
42 
ci n >> person.age; 
43 
ci n.ignore(); 
II Skip over remai ning newline 
44 
cout << "Address 
line 
1 : •; 
45 
getline
(cin , input); 
46 
strcpy(person.address1, 
input.c
_str (}); 
47 
cout << "Address 
l i ne 2: "; 
48 
getline
(cin , input); 
49 
strcpy(person.address2, 
input.c
_str ()); 
50 
cout << "Phone : "; 
51 
getline
(cin , input); 
52 
strcpy(person.phone, 
input.c _str()}; 
53 
people .write(reinterpret
_cast<char 
*>(&person }, 
54 
sizeof(person)); 
55 
cout << "Do you want to enter 
another 
record ?"· 
56 
ci n >> response; 
57 
ci n.ignore(); 
58 
} whi le (to upper(r esponse ) --
'Y'}; 
59 
60 
II Close file 
61 
people .close (); 
62 
return 
O; 
63 } 
(program continues) 

884 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Program 1 3-12 
(continued) 
Program Screen Output with Example Input Shown In Bold 
Enter person information: 
Name: Charlie Baxter[Enter] 
Age: 42[Enter] 
Address 
1 i ne 1 : 67 Kennedy Bvd.[Ent er] 
Address 
1 i ne 2: Perth , SC 38754[Enter] 
Phone: (803 )SSS-1234[Ent er] 
Do you want to enter 
another 
record? 
Y[Ent er] 
Enter person information: 
Name: Merideth Murn ey [Ent er] 
Age: 22[Enter] 
Address 
1 i ne 1 : 487 Undsa y Lane[Ent er] 
Address 
1 i ne 2: Hazelwood , NC 28737[Ent
er] 
Phone: ( 704 )453 -9999[Ent er] 
Do you want to enter 
another 
record? 
N[Ent er] 
Program 1 3-13 
1 II Thi s program demonstrates 
the use of a structure 
2 II variable 
to read a record 
of information 
from a f i le . 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 using namespace std; 
6 
7 const 
int NAME
_SIZE = 51, ADDR_SIZE = 51, PHONE_SIZE = 14; 
8 struct 
Info 
9 { 
10 
11 
12 
13 
14 
15 } ; 
16 
char name [NAME
_SIZE]; 
int age; 
char address1[ADDR_SIZE]; 
char address2[ADDR_SIZE]; 
char phone[PHONE_SIZE]; 
17 int main () 
18 { 
19 
Info person ; II Store 
person information 
20 
char response; 
II User response 
21 
22 
II Create 
file 
object 
and open file 
for binary 
reading 
23 
fstream 
people("people.dat", 
i os: :i n I ios: :bina ry); 
24 
if (! people ) 
25 
{ 
26 
cout << "Error 
opening file. 
Program abort i ng . \ n" ; 
27 
return 
O; 
28 
} 
29 
30 
II Label the output 
31 
cout << "Here are the peop le i n the f i le:\n\
n"; 
(program continues) 

13.5 Creating Records with Structures 
885 
Program 1 3-13 
(continued) 
32 
33 
34 
35 
II Read one str ucture 
at a time and echo to screen 
peop l e .read (re i nterpret
_cast<char 
*>(&person ), 
sizeof 
(person )); 
36 
while 
(! people.eof(
}) 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 } 
{ 
cout << "Name: ". 
' 
cout << person.name 
<< end l; 
cout << "Age: " . 
' 
cout << person.age 
<< endl ; 
cout << "Address line 
1 : " . 
' 
cout << person.address
1 << endl ; 
cout << "Address l i ne 2: " . 
' 
cout << person.address2 
<< endl ; 
cout 
<< "Phone : '' ; 
cout <<person.phone<< 
endl ; 
cout << "\ nStr i ke any key to see the next record. \ n"; 
ci n.get (response ); 
people .read (reinterpret
_cast<char 
*>(&person ), 
sizeof
(person )}; 
} 
cout << "That ' s al l the information 
in the f i l e !\ n" ; 
peop l e . close (); 
return 
O; 
Program Screen Output (Using the same file created by Program 13-12 as input) 
Here are the people in the file: 
Name: Charlie 
Baxter 
Age: 42 
Address line 
1: 67 Kennedy 
Address line 
2: Perth, 
SC 
Phone: (803)555-1234 
Bvd. 
38754 
Strike 
any key to see the next record. 
Name: Merideth Murney 
Age: 22 
Address line 
1: 487 Lindsay Lane 
Address line 
2: Hazelwood, NC 28737 
Phone: (704)453-9999 
Strike 
any key to see the next record. 
That's 
all 
the information 
in the file! 
0 
NOTE: Structures containing pointers cannot be correctly stored to disk using the 
techniques of this section. This is because if the structure is read into memory on a 
subsequent run of the program, it cannot be guaranteed that all program variables 
will be at the same memory locations. Because string class objects contain implicit 
pointers, they cannot be a part of a structure that has to be stored . 

886 
Chapte r 1 3 
Advanced File and 1/0 Operations 
~ 
Checkpoint 
13.6 
13.21 Write a short program that opens two files da t a1 . t xt and data2. txt and then 
creates a third file data3. t xt that consists of all the characters in data1 . t xt 
followed by all the characters in data2 . txt . 
13.22 How would the number 479 be stored in a text file? (Show the character and 
ASCII code representation. ) 
13.23 Describe the differences between the wri t e member function and the << operator. 
13.24 What are the purposes of the two arguments needed for the write 
member 
function? 
13.25 What are the purposes of the two arguments needed for the read member 
function? 
13.26 Describe the relationship between fields and records. 
13.27 Assume the following structure declaration, variable, and file stream object 
definition exist in a program: 
const 
i nt NAME
_SIZE = 51; 
struct 
Data 
{ 
char customer[NAME_SIZEJ; 
i nt num; 
double 
balance; 
} ; 
Data cus t ; 
fstrea
m f i le("stuff", 
i os: :ou t 
I i os: :b i nary); 
Write a statement that uses the writ e member function to store the contents of 
cust in the file. 
Random-Access Files 
CONCEPT : Random access means nonsequentially accessing information in a file. 
All of the programs created so far in this chapter have performed sequential file access. 
When a file is opened, the position where reading and/or writing will occur is at the 
file's beginning (unless the i os: : app mode is used, which causes data to be written to 
the end of the file). If the file is opened for output, bytes are written to it one after the 
other. If the file is opened for input , data is read beginning at the first byte. As the 
reading or writing continues, the file stream object's read/write position advances 
sequentially through the file's contents. 
The problem with sequential file access is that in order to read a specific byte from the 
file, all the bytes that precede it must be read first. For instance, if a program needs 
information stored at the 100th byte of a file, it will have to read the first 99 bytes to 

Figure 13-4 
13.6 Random-Access Files 
887 
reach it. If you've ever searched for a song on a cassette tape, you understand sequentia l 
access. To find a song, you have to listen to all the songs that come before it or 
fast-forward over them. There is no way to immediately jump to that particular song. 
Although sequential file access is useful in many circumstances, it can slow a program 
down tremendously. If the file is very large, locating information buried deep inside 
it can take a long time. Alternatively, C++ allows a program to perform random file 
access. In random file access, a program may immediately jump to any byte in the file 
without first read ing the preceding bytes. The difference between sequential and 
random file access is like the difference between a cassette tape and a compact disc. 
When listening to a CD, there is no need to listen to or fast-forward over unwanted 
songs. You simply jump to the track that you want to listen to . This is illustrated in 
Figure 13-4. 
Sequential Access 
Random Access 
The seekp and seekg Member Functions 
File stream objects have two member functions that are used to move the read/write 
position to any byte in the file. They are seekp and seekg. The seekp function is used 
with files opened for output, and seekg is used with files opened for input. (It makes 
sense if you remember that "p" stands for "put" and "g" stands for "get." seekp is 
used with files that you put informat ion into, and seekg is used with files you get 
information out of.) 
Here is an example of seekp's usage: 
file.seekp(20L, 
ios: :beg); 
The first argument is a long integer representing an offset into the file. This is the 
number of the byte you wish to move to . In this example, 20L is used. (Remember, the 
L suffix forces the compiler to treat the number as a long integer.) This statement 
moves the file's write position to byte number 20. (All numbering starts at 0, so byte 
number 20 is actually the 21st byte.) 
The second argument is called the mode flag, and it designates where to calculate the 
offset from . The flag i os: : beg means the offset is calculated from the beginning of the 
file. Alternatively, the offset can be calculated from the end of the file or the current 
position in the file. Table 13-5 lists the flags for all three of the random -access modes. 

888 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Table 13 -5 File Positioning Flags 
Mode Flag 
ios:: beg 
ios:: end 
ios::cur 
Description 
The offset is calculated from the beginning of the file. 
The offset is calculated from the end of the file. 
The offset is calculated from the current position. 
Table 13-6 shows examp les of seekp and seekg using the various mode flags. 
Table 13 -6 File Seek Operations 
Statement 
fi le .seekp(32L, 
i os: :beg ); 
fi le .seekp( - 10L, ios: :end); 
fi le .seekp(120L , ios: :cur); 
file .seekg(2L , ios: :beg); 
file .seekg( - 100L, i os: :end ); 
file .seekg(40L, 
ios: :cur ); 
file .seekg(OL , ios: :end); 
How It Affects the Read/Write Position 
Sets the write position to the 33rd byte (byte 32) from the 
beginning of the file. 
Sets the write position to the 11th byte (byte 10) from the 
end of the file. 
Sets the write position to the 121st byte (byte 120) from 
the current position. 
Sets the read position to the 3rd byte (byte 2) from the 
beginning of the file. 
Sets the read position to the 101st byte (byte 100) from 
the end of the file. 
Sets the read position to the 41st byte (byte 40 ) from the 
current position. 
Sets the read position to the end of the file. 
Notice that some of the examp les in Table 13-6 use a negative offset. Negative offsets 
result in the read or write position being moved backward in the file, while positive 
offsets result in a forward movement . 
Assume the file 1 etters
. txt contains the following data: 
abcdefgh i jklmnopqrstuvwxyz 
Program 13-14 uses the seekg function to jump around to different locations in the 
file, retrieving a character after each stop . 
Program 1 3-14 
1 // Thi s program demonstrates 
the seekg function
. 
2 #include 
<iostream> 
3 #include 
<fstream> 
4 using namespace std ; 
5 
(program continues) 

Program 1 3-14 
6 int main() 
7 { 
(continued) 
8 
II Vari able to access 
file 
9 
char ch; 
10 
11 
II Open the fi le fo r reading 
12 
fstream 
file
("lett
ers .txt ", ios::in); 
13 
if (! file ) 
14 
{ 
15 
cout << "Error open i ng file."; 
16 
return 
O; 
17 
} 
18 
19 
II Get fifth 
byte from beginning 
of alphabet 
file 
20 
file. 
see kg (SL, i os: : beg) ; 
21 
file.get(ch); 
22 
cout << "Byte 5 fro m beginning : "<<ch<< 
end l; 
23 
24 
II Get tenth 
byte from end of alphabet 
file 
25 
file.seekg(
- 10L, i os: :end ); 
26 
file.get(ch); 
27 
cout << "Byte 10 from end : "<<ch
<< endl; 
28 
29 
II Go forward three 
bytes from current 
position 
30 
file.seekg(3L, 
i os::cur); 
31 
file.get(ch); 
32 
cout << "Byte 3 fro m current: 
"<<ch<< 
end l; 
33 
34 
II Close f i le 
35 
file.close(); 
36 
return 
O; 
37 } 
Program Screen Output 
Byte 5 from beginning: 
f 
Byte 10 from end: q 
Byte 3 from current: 
u 
13.6 Random-Access Files 
889 
Program 13-15 shows another example of the see kg function. It opens the people. dat 
file created by Program 13-12. The file contains two records. Program 13-15 displays 
record 1 (the second record) first, then displays record 0. 
Program 1 3-15 
1 II Thi s program demonstrates 
the use of a str ucture 
2 II variable 
to read a record 
of information 
from a f i le . 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 using namespace std ; 
(program continues) 

890 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Program 1 3-15 
6 
(continued) 
7 const 
int NAME
_SIZE = 51, ADDR_SIZE = 51 , PHONE_SIZE = 14; 
8 
9 II Declare 
a structure 
for the record 
10 struct 
Info 
11 { 
12 
char name[NAME
_SIZE] ; 
13 
int age; 
14 
char address1[A0DR _SIZE] ; 
15 
char address2[A0DR _SIZE] ; 
16 
char phone[PHONE_SIZE] ; 
17 } ; 
18 
19 II Function 
Prototypes 
20 l ong byteNum(i nt}; 
21 void showRec(Info); 
22 
23 int main() 
24 { 
25 
II Person i nformation 
26 
Info person; 
27 
28 
II Create 
fi l e object 
and open the f i le 
29 
fstream 
peop l e ("peo ple .dat ", ios: :i n I ios: :bi nary}; 
30 
if (!pe ople ) 
31 
{ 
32 
cout << "Error opening file. 
Progra m abort i ng.\n"; 
33 
return 
O; 
34 
} 
35 
36 
II Skip forward and read record 
1 in the file 
37 
cout << "Here is record 
1:\n"; 
38 
people.seekg(byteNum(1), 
ios: :beg ); 
39 
people.read(reinterpret
_cast<cha r *>(&person ), 
40 
sizeof(person)); 
41 
showRec(person ); 
42 
43 
II Skip backwards and read record 
O i n the file 
44 
cout << "\nHere is record 
O:\n"; 
45 
people.seekg(byteNum(O), 
ios: :beg ); 
46 
people.read(reinterpret
_cast<cha r *>(&person ), 
47 
sizeof(person)); 
48 
showRec(person ); 
49 
50 
II Close the file 
51 
people.close(); 
52 
ret urn O; 
53 } 
54 
(program continues) 

Program 1 3-15 
55 
13.6 Random-Access Files 
891 
(continued) 
56 //************************************************************ 
57 II Definition 
of funct i on byteNum. Accepts an integer 
as 
58 II its 
argument. 
Returns 
the byte number i n the file 
of the 
59 II record whose number is passed as the argument. 
* 
* 
* 
60 //************************************************************ 
61 long byteNum(i nt recNum) 
62 { 
63 
return 
s i zeof (I nfo) * recNum; 
64 ) 
65 
66 //************************************************************ 
67 II Definition 
of funct i on showRec. Accepts an Info structure* 
68 II as its 
argument , and displays 
the structure's 
contents
. 
* 
69 //************************************************************ 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
void showRec(Info 
record) 
{ 
cout << "Name: ... 
cout << record.name 
<< endl; 
cout << "Age: ". 
' 
cout << record.age<< 
endl; 
cout << "Address line 
1 : ". • 
cout << record.address1 
<< endl ; 
cout << "Address line 
2: ". • 
cout << record.address2 
<< endl ; 
cout << "Phone: 
". 
' 
cout << record.phone<< 
endl; 
) 
Program Screen Output (Using the same file created by Program 13-12 as input) 
Here is record 
1: 
Name: Merideth Murney 
Age: 22 
Address line 
1: 487 Lindsay Lane 
Address line 
2: Hazelwood, NC 28737 
Phone: (704)453-9999 
Here is record 
0: 
Name: Charlie 
Baxter 
Age: 42 
Address line 
1: 67 Kennedy 
Address line 
2: Perth, 
SC 
Phone: (803)555-1234 
Bvd. 
38754 
Th e program has two important functions other than main. Th e first, byteNum, takes a 
record number as its argument and returns that record's starting byte. It calculates the 
record's starting byte by multiplying the record number by the size of the Info structure. 
Thi s returns the offset of that record from the beginning of the file. The second function, 
showRec, accepts an Info str uctur e as its argument and displays its contents on the screen. 

892 
Chapter 1 3 
Advanced File and 1/0 Operations 
The te 11 p and te 11 g Member Functions 
File stream objects have two more member functions that may be used for random file 
access: te 11 p and te 11 g. Th eir purpose is to return , as a 1 ong integer , the curr ent byte 
number of a file's read and write position . As you can guess, tel 1 pis used to return the 
write position, and te 11 g is used to return the read position . Assuming pos is a 1 ong 
integer , here is an examp le of the functions' usage: 
pos = outFile
.tellp(); 
pos = i nFile.tellg(); 
Program 13-16 demonstrate s the tel 1 g function. It opens the 1 etters
. txt file, which 
was also used in Program 13-14. Th e file contains the following characters: 
abcdefgh i jklmnopqrstuvwxyz 
Program 1 3-16 
1 // 
Thi s program demonstrates 
the tellg 
function
. 
2 #include 
<iostream> 
3 #include 
<fstream> 
4 #include 
<cctype> 
5 using namespace std ; 
6 
7 int main() 
8 { 
II For touppe r 
9 
II Variables 
used to read the f i le 
10 
long offset; 
11 
char ch; 
12 
char response; 
// User response 
13 
14 
II Create 
the file 
object 
and open the file 
15 
fstream 
file("letters
.txt" , ios: :in ); 
16 
if ( !file
) 
17 
{ 
18 
cout << "Error 
opening file."; 
19 
return 
O; 
20 
) 
21 
II Work wi th the f i le 
22 
do 
23 
{ 
24 
II Where in the file 
am I? 
25 
cout << "Curr ently 
at posit i on" 
26 
<< file.tel 
lg ()<< 
endl ; 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
II Get a file 
offset 
from the user . 
cout << "Enter an offset 
from the
" 
<< "beginn i ng of the file
: "; 
ci n 
>> offset
; 
II Read the character 
at the given offset 
f i le .seekg(offset, 
ios: :beg); 
file
.get(ch); 
cout << "Character 
read: 
"<<ch<< 
end l; 
(program continues) 

13.7 Opening a File for Both Input and Output 
893 
Program 1 3-16 
(continued) 
37 
cout 
<< "Do i t aga i n? ". 
' 
38 
ci n >> respo nse; 
39 
} while 
(t oupper(response
) --
'YI); 
40 
fi 1 e. c 1 ose () ; 
41 
retur
n O; 
42 } 
Program Output with Example Input Shown in Bold 
Currently 
at pos it ion 0 
Enter 
an offset 
from the beginning 
of the file: 
S[Enter] 
Character 
read: 
f 
Do it 
again? 
y[Enter] 
Currently 
at position 
6 
Enter 
an offset 
from the beginning 
of the file: 
O[Enter] 
Character 
read: 
a 
Do it 
again? 
y[Enter] 
Currently 
at position 
1 
Enter 
an offset 
from the beginning 
of the fi 1 e: 20[Enter] 
Character 
read: 
u 
Do it 
again? 
n[Enter] 
13.7 
Opening a File for Both Input and Output 
CONCEPT: 
You may perform input and output on an fstream file without closing 
it and reopening it. 
There are times when you need to update data stored in a file. To do this, you need to 
open the file, copy some of the data into memory, modify it, write the data back to the 
file, and then close the file. A file can be opened for both input and output by combining 
the i os: : in and i os: : out flags with the I operator: 
fstream 
fi l e ("data.
dat ", ios: :i n I ios: :out) 
The same operation may be accomplished with the open member function: 
file.open
("da ta.dat"
, ios: :in 
I i os: :ou t ); 
You can also specify the i os: : bi nary flag if binary data is to be written to the file. 
Here is an examp le: 
file.open
("da ta.dat"
, ios: :in I i os: :ou t I i os: :b i nary); 
When an fstream file is opened with both the ios: : in and ios: : out flags, the file's current 
contents are preserved, and the read/write position is initially placed at the beginning of the 
file. If the file does not exist, it is created (unless the i os: : nocreate is also used). 
Programs 13-17, 13-18, and 13-19 demonstrate many of the techniques we have discussed. 
Program 13-17 sets up a file with five blank inventory records. Each record is a structure 
with members for holding a part description, quantity on hand, and price. Program 13-18 

894 
Chapte r 1 3 
Advanced File and 1/0 Operations 
displays the contents of the file on the screen. Program 13-19 opens the file in both input and 
output modes and allows the user to change the contents of a specific record . 
Program 1 3-17 
1 II Thi s program sets 
up a fi l e of blank inventory 
records
. 
2 #include 
<iostream> 
3 #include 
<fstream> 
4 using namespace std ; 
5 
6 const 
int DESC_SIZE = 31, NUM
_RECORDS = 5 ; 
7 II Declarat
i on of Invtry 
str ucture . 
8 struct 
Invtry 
9 { 
10 
char desc [DESC_SIZE]; 
11 
int qty; 
12 
double pr i ce ; 
13 } ; 
14 
15 int main() 
16 { 
17 
II Variables 
needed to write 
the file 
18 
Invtry 
record= 
{ "", 0, 0.0 }; 
19 
20 
II Create 
file 
object 
and open file 
21 
fstream 
inventory("invtry
.dat", 
ios::out 
I ios::binary); 
22 
if (! i nventory) 
23 
{ 
24 
cout << "Error opening fi le."; 
25 
return 
O; 
26 
} 
27 
28 
II Now wri te the blank records 
29 
for (i nt count= 
O; count< 
NUM
_RECORDS
; count++) 
30 
{ 
31 
cout << "Now wri t i ng record 
" << count << endl ; 
32 
inventory
.write(reinterpret
_cast<char 
*>(&record ), 
33 
s i zeof (r ecord )); 
34 
} 
35 
36 
II Close the f i le 
37 
inventory.close(); 
38 
return 
O; 
39
} 
Program Screen Output 
Now writing 
record 
O 
Now writing 
record 
1 
Now writing 
record 
2 
Now writing 
record 
3 
Now writing 
record 
4 

13.7 Opening a File for Both Input and Output 
89 5 
Program 13-18 simply displays the contents of the inventory file on the screen. It can 
be used to verify that Program 13-17 successfully created the blank records and that 
Program 13-19 correctly modified the designated record. 
Program 1 3-18 
1 II Thi s program displays 
the contents 
of the inventory 
f i le. 
2 #include 
<iostream> 
3 #include 
<fstream> 
4 using namespace std ; 
5 
6 const 
int DESC_SIZE = 31; 
7 
8 II Declaration 
of Invtry 
structure 
9 struct 
Invtry 
10 { 
11 
char desc[DESC_SIZE] ; 
12 
int qty; 
13 
double price; 
14 } ; 
15 
16 int main() 
17 { 
18 
II Buffer 
used for reading 
19 
Invtry 
record; 
20 
21 
II Create 
and open the file 
for read i ng 
22 
fst ream inventory ( "i nvt ry. dat", 
i os: : in I i os: : bi nary ) ; 
23 
if (!i nventory ) 
24 
{ 
25 
cout << "Error 
in opening the f i le . "; 
26 
return 
O; 
27 
} 
28 
29 
II Now read and di splay the records 
30 
inventory
.read(re
i nterpret
_cast<char 
*>(&record), 
31 
sizeof(record}); 
32 
whi le (!inventory.eof()) 
33 
{ 
34 
cout << "Descr i ption: 
"; 
35 
cout << record.desc 
<< endl ; 
36 
cout << "Quant i ty: 
"; 
37 
cout <<record.qty<< 
endl ; 
38 
cout << "Price: 
"; 
39 
cout <<record.price<< 
endl << endl; 
40 
inventory.read(reinterpret
_cast<char 
*>(&record}, 
41 
sizeof(record)); 
42 
} 
43 
inventory
.close(); 
44 
return 
O; 
45
} 

896 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Here is the screen output of Program 13-18 if it is run immediately after Program 13-17 
sets up the file of blank records. 
Program Screen Output 
Description: 
Quantity: 
O 
Pr i ce: 0.0 
Description: 
Quantity: 
O 
Pr i ce: 0.0 
Description: 
Quantity: 
O 
Price: 
0.0 
Description: 
Quantity: 
O 
Price: 
0.0 
Description: 
Quantity: 
O 
Price: 
0.0 
Program 13-19 allows the user to change the contents of an individual record in the 
inventory file. 
Program 1 3-19 
1 II This program allows the user to edit 
a specific 
2 II record 
in the inventory 
file
. 
3 #include 
<iostream> 
4 #include 
<fstream> 
5 using namespace std; 
6 
7 const 
int DESC_SIZE = 31; 
8 II Declarat
i on of Invtry 
structure 
9 struct 
Invtry 
10 { 
11 
char desc[DESC_SIZE] ; 
12 
int qty; 
13 
double price; 
14 } ; 
15 
16 int main() 
17 { 
18 
II Vari ables 
needed to read the file 
19 
Invtry 
record; 
20 
long recNum; 
21 
22 
II Open the file 
(program continues) 

13.7 Opening a File for Both Input and Output 
89 7 
Program 1 3-19 
(continued) 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 } 
fstream 
i nventory("
i nvtry.dat", 
i os: :in I ios: :out I 
ios: :binary); 
if (!inventory) 
{ 
cout << "Error open i ng file."; 
return 
O; 
} 
II Move to the desired 
record 
and read it into record 
cout << "Which record 
do you want to edit?"; 
cin >> recNum; 
inventory
.seekg(recNum * sizeof(record), 
ios: :beg); 
inventory
.read(re
i nterpret
_cast<char 
*>(&record), 
sizeof(record}); 
II Get new data from user and edi t in-memory record 
cout << "Descript
i on: .. 
' 
cout << record.desc 
<< endl; 
cout << "Quantity: .. 
cout << record.qty 
<< endl; 
cout << "Price: .. 
' 
cout << record.pr
i ce << endl; 
cout << "Enter the new data: \n"; 
cout << "Descript
i on: "; 
cin. i gnore(}; 
cin.getl
i ne(record.desc, 
DESC_SIZE); 
cout << "Quant ity: 
"; 
ci n >> record.qty; 
cout 
<< ''Price: 
"; 
ci n >> record.pr
i ce; 
II Move to t he right 
place in file 
and write 
the record 
inve ntory .seekp(recNum * sizeof(record), 
ios: :beg); 
inve ntory .wri t e(rei
nt erpre t _cast<c har *>(&record), 
si zeof(record)); 
II Close t he file 
inve ntory .close(); 
return 
O; 
Program Screen Output with Example Input Shown In Bold 
Which record do you want to edit? 
2[En te r] 
Descript
i on: 
Quantity: 
0 
Price: 
0.0 
Enter the new data: 
Descript
i on: Wr ench [Ente r] 
Quantity: 
1 O[Ent er] 
Price: 
4.67 [Ente r] 

898 
Chapter 1 3 
Advanced File and 1/0 Operations 
~ 
Checkpoint 
13.28 Describe the difference between the seekg and the seekp functions . 
13.29 Describe the difference between the tellg and the tellp functions . 
13.30 Describe the meaning of the following file access flags. 
ios:: beg 
ios: :end 
ios: :cur 
13.31 What is the number of the first byte in a file? 
13.32 Briefly describe what each of the following statements does. 
fi le.s eekp (100L, ios: :beg ); 
fi l e .s eekp (- 10L, ios: :end ); 
fi l e .s eekg (-25 L, ios: :cur ); 
fi le.s eekg (30L, i os: :cur ); 
13.33 Describe the mode that each of the following statements causes a file to be 
opened in. 
fi l e .open("in fo .dat ", io s: :in 
file.open("info.dat", 
io s: :in 
file.open("info.dat", 
io s: :in 
file.open("info.dat", 
io s: :in 
ios: :out); 
ios::app); 
ios: :out I ios: :ate ); 
ios::out 
I ios::binary); 
Online Friendship Connections Case Study: 
Object Serialization 
Online Friendship Connections is an online service that helps people meet and make new 
friends. People who want to join the club and use its services fill out a registration form, 
stating their names, age, contact information , gender, hobbies, personal interests, and 
other pertinent information about themselves. They also specify the qualities they are 
looking for in a new friend. The service will then try to get two people together if the 
personal information submitted indicates that there is a high probability of a good match. 
Object Serialization 
Online Friendship Connections will store information about its members in files. 
Member information will be manipulated by a C++ program and will be stored in 
objects of appropr iately designed classes. Th ese objects may involve pointers to other 
objects, forming a network of objects whose structure must somehow be preserved 
when the data are stored to a file. This structure is then reconstructed when the data is 
read back from the file at a later time. The process of transforming complex networks 
of objects interconnected through pointers into a form that can be stored in a disk file 
(or on some other medium outside of central memory) is called object serialization. 
In this section, we will illustrate some of the techniques used in serializing objects by looking 
at a simple case in which an object containing a C++ str in g object is serialized. Recall that 
C++ strings are normally implemented using pointers to dynamically allocated array of char. 

13.8 Online Friendship Connections Case Study: Object Serialization 
899 
Designing the Classes Needed by the Program 
A simple class that stores a portion of the information submitted by members of Online 
Friendship Connections might include a first name , middle initial, last name, and the 
age of a member. In addition to the usual getter and setter functions, we need member 
functions for serializing the object: that is, a member function that converts the object 
into data stored in a file: 
voi d store (ofstream &outFile ); 
We also need a member function for deserializing an object: that is, one that reads 
from a file data previously placed there by store , recovers its structure, and sets the 
data members of the object correctly: 
voi d load (ifs tream &inFi le ); 
After adding a constr uctor and a display 
member function , we come up with the 
following class: 
Contents of serialization. 
h 
1 #include 
<iostream> 
2 #include 
<fstream> 
3 #include 
<str i ng> 
4 using namespace std ; 
5 
6 class Person 
7 { 
8 
string 
fname, lname; 
9 
char mi; 
10 
int age; 
11 public : 
12 
string 
getFname() const {return 
fname;} 
13 
string 
getLname() const {return 
l name;} 
14 
char getMi () const {ret urn mi;} 
15 
int getAge () const {ret urn age ;} 
16 
17 
void setFname(string 
name){fname = name;} 
18 
void setLname(string 
name){lname = name;} 
19 
void setMi (cha r ch){mi = ch ;} 
20 
21 
// Read data from file 
22 
void load(ifstream 
&i nFile); 
23 
// store data to file 
24 
void store(ofstream 
&outFile ); 
25 
26 
II Constructor 
27 
Person(string 
fname = "" 
char mi = 0, 
28 
string 
lname = "" 
int age= 
O); 
29 
30 
void display () 
31 
{ 
32 
cout << fname <<" 
"<< mi <<" 
"<< lname << endl 
33 
34 
} 
35 } ; 
<< "Age : " << age << endl; 

900 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Figure 13-5 
Determining 
a Serialization Scheme 
We cannot just write the contents of a Person object to a disk file because the string 
members contain pointers to arrays of characters that need to be stored so that the string 
objects can be reconstructed at a later time when the object is deserialized. Because strings 
have varying lengths, Person objects will occupy varying amounts of space on the disk 
when they are deserialized. A simple but effective serialization scheme is to first write all 
the members of the object that take up constant space and then write each member 
whose space requirement may vary on the disk, preceded by the number of bytes that the 
member occupies. For the Person class, we can use the scheme shown in Figure 13-5. 
mi 
age 
fna me. 1 ength () 
fna me.data() 
1 name. 1 ength () 
lname.data() 
The code for the store function is then very straightforward and can be seen in the 
listing of the file seriali
zation. cpp. To design the 1 oad function, we note that we 
need to reconstruct the f name and 1 name strings by first reading their data portions into 
an in-memory buffer that is an array of character. To do this for fname, we first read 
the number of bytes occupied by its data portion from the file: 
i nt firstNamelength; 
i nFile.read(addr(&f
i rs t Namel engt h), si zeof( i nt)); 
We must then read that many bytes into a buffer and null terminate the buffer to tum 
it into a C-string: 
i nFile.read(buffer
, f i rs t Namelengt h); 
buffer[f
i rs t Namel ength ] = '\O'; 
Finally, we convert the C-string to a string object by assigning it to the f name member. 
The C++ str ing has a convert constructor that automat ically converts C-strings to 
string objects to make such assignments possible. 
frame= 
buffer; 
The buffer array is used as a temporary holding place. Making it an instance member 
of the class would allocate space for it in every object and would waste a lot of memory. 
A better idea to make it a static member of the class, so that the scratch space can be 
shared by all members of the object. However, we note that it is only used by the 1 oad 
member function. For this reason , we make it local static. That way, space for the 
buffer is allocated once instead of being allocated a new for each call to 1 oad. Static 
local variables were described in Chapter 6. 
The rest of the member functions needed to implement the Perso n class are shown in 
the listing of the ser i a 1 i zat io n. cpp file. 

13.8 Online Friendship Connections Case Study: Object Serialization 
901 
Contents of seri a 1 i zat ion. cpp 
1 #include 
"ser i alization.h" 
2 
3 Person::Person
(s tring 
fname, 
4 
string 
lname, 
5 { 
6 
this->fname 
= fname ; 
7 
this->lname 
= lname; 
8 
this->mi 
= mi ; 
9 
this->age 
= age; 
10 } 
11 
char mi, 
int age) 
12 //********************************************* 
13 // Stores 
mi , age , then length 
of fname, 
* 
14 // then data for fname , then length 
of lname, * 
15 // then data for lname 
* 
16 //********************************************* 
17 void Person::store
(ofstream 
&outFile) 
18 { 
19 
outF i le.wr i te (&mi, sizeof(mi}); 
20 
outF i le.wr i te (r einterpret
_cast<char 
*>(&age}, 
21 
sizeof(age}); 
22 
23 
// Write length 
and data for fname and lname 
24 
int firstNameLength 
= fname.length()
; 
25 
outF i le.wr i te (r einterpret
_cast<char 
*>(&firstNameLength
), 
26 
sizeof(int}); 
27 
outF i le.write(fname.data(), 
firstNameLength}; 
28 
int lastNameLength 
= lname .length(); 
29 
outF i le.wr i te (r einterpret
_cast<char 
*>(&lastNameLength }, 
30 
sizeof(
i nt}); 
31 
outF i le.write(lname.data(), 
lastNameLength); 
32 
} 
33 
34 
35 
//********************************************** 
// Reads the data in the format wri tten 
by 
* 
36 
// Person::store 
* 
37 
//********************************************** 
38 
void Person: :load(ifstream 
&inFile ) 
39 
{ 
40 
const 
int BUFFER_SIZE = 256; 
41 
static 
char buffer[256
] ; //us ed to read names 
42 
43 
inF i le.read(&mi, 
si zeof (mi)}; 
44 
inF i le.read(reinterpret
_cast<char 
*>(&age), sizeof(age
)}; 
45 
46 
II First 
get length 
and data for fname 
47 
int f i rstNameLength; 
48 
inF i le.read(reinterpret
_cast<char 
*>(&fi rstNameLength }, 
49 
sizeof(int
)}; 
50 
51 
// Read the data for fname into a local 
buffer 
52 
inF i le.read(buffer, 
firstNameLength
); 
53 

902 
Chapte r 1 3 
Advanced File and 1/0 Operations 
54 
II Null terminate 
the buffer 
55 
buffer[firstNamelength
] = '\O ' ; 
56 
fname = buffer; 
//tak e advantage 
of convert 
constructor 
57 
58 
// Do the same thing 
for length 
and data for l name 
59 
int last Namelength ; 
60 
inF i le.r ead (reinte
rpr et _cast<char 
*>(&lastNamelength
), 
61 
sizeof
(i nt )); 
62 
inF i le.r ead (buff er , lastNamelength
); 
63 
buffer[lastNamelength] 
= ' \O'; 
64 
1 name = buffer; 
65 } 
We need two separate programs to demonstrate the serialization capabi lities of the 
Person class . Program 13-20, wh ich generates no screen output , creates an array of 
two objects, seria lizes them , and writes them to a file. 
Program 1 3-20 
1 // Thi s program demonstrates 
object 
ser i alization
. 
2 #include 
"ser i ali zat i on .h" 
3 int main() 
4 { 
5 
// Array of objects 
to 
Person people[ 
] = 
store 
in file 
6 
7 
{ Person ("Josep h", 
' X ' 1 "Puff ", 32), 
8 
Person (" Loui se", 
' Y ' 1 
"Me" , 28) 
9 
10 
11 
12 
13 
} ; 
// Open a fi l e and store 
the array 
of peop l e 
ofstream 
outFi le(" MorePeople .dat" , ios: :binary); 
if( !outF ile } 
{ 
14 
cout << "The output 
f i le cannot be opened "; 
15 
exi t(1); 
16 
} 
17 
18 
// Store the people data in the file 
19 
people[O ]. store(outFile); 
20 
people[1 ] .store(outFile); 
21 
cout << "Data has been written 
to the fi l e " 
22 
<<" 
' Morepeople .da t '"; 
23 
24 
II Close file 
25 
outFile.close(}; 
26 
return 
O; 
27
} 
Program 13-21 opens the file created by Program 13-20, deserializes the two ob jects in 
the file, and displays them on the screen . 
Program 13 -21 
1 //This 
progra m demonstrates 
object 
dese ria lization
. 
2 #include 
"ser i ali zat i on .h" 
3 int main() 
4 { 
(program continues) 

Program 13 -21 
(continued) 
5 
6 
const 
int NUM
_PEOPLE = 2 ; 
Person people[NUM_PEOPLE] ; 
13.9 Tying It All Together: File Merging and Color-Coded HTML 
903 
7 
8 
9 
II Open a f ile and lo ad the array 
of peop l e 
ifstream 
i nFile("MorePeople
.dat", 
ios::binary); 
if(! inFile} 
10 
{ 
11 
12 
cout 
<< "The input f il e cannot be opened "; 
exit (1}; 
13 
} 
14 
15 
II Read the data fro m the file 
16 
17 
for (i nt k = O; k < NUM_PEOPLE; k++) 
people [k ] .l oad (i nFile); 
18 
19 
II Display 
the data 
20 
for (int k = O; k < NUM_PEOPLE
; k++) 
21 
22 
23 
24 
25 
26 } 
people [k ] .display(}; 
II Close the fi le 
inFile.close(); 
return 
O; 
Program Output 
Joseph X Puff 
Age : 32 
Louise Y Me 
Age : 28 
""" 
13.9 
~ 
Tying It All Together: File Merging and 
Co/or-Coded HTML 
Suppose that you have two files, with each file containi ng a sorted list of names and 
each name occurr ing on a line by itself, as illustrated in Table 13-7. 
Table 13-7 
Black File 
Abrams, Elaine 
Bostrom, Andy 
Potus, Nicholas 
Radon, Joseph 
Williams, Nancy 
Blue File 
Avon, Martha 
Gomez, Diane 
Pistachio, Mary 
Rhodes, Peter 
Wilson, Zelda 
Zazinski, Pete 

904 
Chapte r 1 3 
Advanced File and 1/0 Operations 
You want to merge the contents of the two files into one file in such a way that the 
merged file is sorted in alphabetic order. You also want people to be able to tell at a 
glance which of the two original files a given line in the merged file came from. One 
way to do this is to color -code the original files and then display each line of the 
merged file in the color of the originating file: 
Abrams, Elaine 
Avon, Martha 
Bostrom, Andy 
Gomez, Diane 
Pistachio, Mary 
Potus, Nicho las 
Radon, Joseph 
Rhodes, Peter 
Williams, Nancy 
Wilson, Zelda 
Zazinski, Pete 
To accomp lish this, we code the output file in HTML and arrange for the browser to 
display each line with the appropriate color. This can be done via what are called CSS 
styles. We will use the HTML span elements to enclose a line and then color the content 
of the span element using the CSS style attribute . For the two files shown above, our 
program will produce the following output: 
<span sty l e = "color:b l ack"> Abrams, Elaine <br/></span> 
<span sty l e = "color: bl ue"> Avon, Martha <br/></span> 
<span sty l e = "color:b l ack"> Bostrom, Andy <br/></span> 
<span sty l e = "color:b l ue"> Gomez, Di ane <br/></span> 
<span sty l e = "color:b l ue"> Pistachio, 
Mary <br/></span> 
<span sty l e = "color:b l ack"> Potus, 
Nichol as <br/></span> 
<span sty l e = "color:b l ack"> Radon, Joseph <br/></span> 
<span sty l e = "color:b l ue"> Rhodes, Peter <br/></span> 
<span sty l e = "color:b l ack"> Wi lliams, 
Nancy <br/></span> 
<span sty l e = "color:b l ue"> Wilson, Zelda <br/></span> 
<span sty l e = "color:b l ue"> Zazinski, 
Pete <br/></span> 
The <br / > HTML element signifies a line break . 
Our solution to this problem will use a subclass of fstream that has a member function 
for writing a string inside of an HTML span element . The span element will specify the 
color the browser should use to display the string: 
class 
ColorCodedStream: 
publ ic fstream 
{ 
publ i c: 
voi d writelnColor(string 
str, 
string 
aColor) 
{ 
} 
} ; 
*this<< 
"<span style= 
\"color:"+ 
aColor + "\"> "; 
*this<< 
str 
<< • <br/> "; 
*this<< 
"</span>\n"; 

13.9 Tying It All Together: File Merging and Color-Coded HTML 
905 
Our program will need to open two files for reading and a third file for writing. To 
avoid repetition of code, we write a function 
voi d openFi l e(fstream 
&file, 
str i ng descr); 
that takes a file object and a description ("black", 
"blue", or "output"), prompts the 
user for the name of a file, and then opens the file. A file described as "bl ack" or 
"bl ue" is opened for input, while a file described as "output" is opened for output . 
Our program also uses the library function 
getl i ne( i stream &i n, string 
&str); 
to read strings from the input file one line at a time. The program has two variables 
string 
blacklnput, 
bl uelnput 
that are used to hold the line that was last read from the corresponding file. Because a 
read may be unsuccessful, the program tests each file object for errors before using the 
input last read from it. For example, the code 
i f (bl ackFi l e && !blueF il e) 
{ 
} 
II Only blacklnput 
is good 
outputFi
l e.writelnColor(blacklnput, 
"black"); 
getline(blackF
il e, blacklnput); 
determines that the last read from the black file was good while the read from the blue 
file failed, so it processes the input from the black file. After the input from the black 
file has been written out, the black file is read again to prepare for the next iteration of 
the loop . When the program cannot read any more data from either file (this is checked 
at the top of the loop that begins at line 39) the program terminates . 
Program 1 3-22 
1 II Thi s program demonstrates 
fi l e merging and the use 
2 II of CSS to determine 
text 
colors 
i n HTML documents. 
3 #include 
<stdlib
.h> 
4 #include 
<iostream> 
5 #include 
<fstream> 
6 #include 
<str i ng> 
7 using namespace std; 
8 
9 II Thi s subc l ass of fstream 
adds the abili ty to 
10 II wri te a string 
that 
is automat i cally 
embedded 
11 II in an HTML span element with a color 
specificat
i on 
12 I I style 
13 cl ass ColorCodedStream: 
public 
fstream 
14 { 
15 publ i C: 
16 
voi d writelnColor(str
i ng str, 
string 
aCol or) 
17 
{ 
(program continues) 

906 
Chapte r 1 3 
Advanced File and 1/0 Operations 
Program 1 3-22 
(continued) 
18 
*this<< 
"<span style= 
\"color:"+ 
aColor + "\"> "; 
19 
*this<< 
str 
<< • <brl> "; 
20 
*this<< 
"<lspan>\n"; 
21 
} 
22 }; 
23 
24 void openFile(fstream 
&fil e, string 
descr); 
II Prototype 
25 
26 int main() 
27 { 
28 
ColorCodedStream 
outputFile; 
29 
fstream 
bl ackFile, 
bl ueFile; 
30 
openFile(blackF
i le, 
"bl ack"); 
31 
openFile(blueFile, 
"blue"); 
32 
openFile(outputFile, 
"output"); 
33 
string 
blacklnput, 
bl uelnput; 
f i 1 e 
34 
35 
36 
37 
38 
II read the f i rst li ne from each 
getl i ne(b l ackFile, 
bl acklnput); 
getl i ne(b l ueFi le, 
bluelnput); 
I I 
II Read black f il e into buffer 
Read bl ue file 
into buffer 
39 
whi le (blackF i le I I blueFi l e) 
40 
{ 
41 
42 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
i f (bl ackFile 
&& blueFile) 
{ 
} 
II Both buffers 
have fresh 
data 
i f (blacklnput 
<= bluelnput} 
{ 
} 
el se 
{ 
} 
outputF il e .writelnColor(b
l acklnput, 
"bl ack"); 
getline(blackFile, 
blacklnput}; 
outputF il e .writelnColor(b
l uelnput, 
"blue"); 
getline(blueFi
l e, bluelnput}; 
i f (bl ackFile 
&& !blueFile) 
{ 
} 
II Only blacklnput 
is good 
outputF i le .wri telnColor(b
l acklnput, 
"black"); 
get l ine(blackFile, 
blacklnput}; 
i f (bl ueFi le && !bl ackFile) 
{ 
II Only bluelnput 
is good 
outputF i le .wri telnColor(b
l uelnput, 
"blue"); 
get l ine(blueF
il e, bluelnput}; 
66 
} 
67 
} 
68 
return 
O; 
(program continues) 

Program 1 3-22 
69 } 
(continued) 
Review Questions and Exercises 
907 
70 //******************************************************************** 
71 II Opens a specified 
f il e for reading 
or writing. 
The descr argument* 
72 II is used i n prompt i ng for the name of the fi l e. 
* 
73 //******************************************************************** 
74 void openFile(fstream 
&fil e, string 
descr) 
75 { 
76 
string 
f il eName; 
77 
cout << "Enter the 
name of the"<< 
descr <<•f
il e: "· 
78 
cin >> f il eName; 
79 
80 
II Determine whether the file 
should be opened for reading 
81 
II or wri ting 
based on the descr i ption 
(descr ) 
82 
i f (descr == "output") 
83 
file.open(f
i leName.data(), 
ios::out}; 
84 
else 
85 
file.open(f
i leName.data(), 
ios::
i n); 
86 
87 
II Check if f i le open was successfu
l 
88 
i f (!f il e} 
89 
{ 
90 
cout << "Cannot open the f i le"<< 
fi l eName; 
91 
exi t(1); 
92 
} 
93 } 
Sample Program Interaction with User Input Shown In Bold 
Enter the 
Enter the 
Enter the 
name of the black file: 
blackfile.txt[Enter
] 
name of the blue file: 
bluefile.txt[Enter
] 
name of the output 
file: 
mergedfile.html[Enter] 
The contents of the output file can be viewed in a browser. 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. All files are assigned a(n) ____ 
that is used for identification purposes by 
the operating system and the user. 
2. Before a file can be used, it must first be ____ 
_ 
3. When a program is finished using a file, it should ____ 
it. 
4. The ____ 
header file is required for file 1/0 operations . 
5. The three file stream data types are __________ 
,and ____ 
_ 

908 
Chapte r 1 3 
Advanced File and 1/0 Operations 
6. The ____ 
file stream data type is for output files. 
7. The 
file stream data type is for input files. 
8. The ____ 
file stream data type is for output files, input files, or files that 
perform both input and output. 
9. Write a statement that defines a file stream object named people. The object 
will be used for file output. 
10. Write a statement that defines a file stream object named pets. The object will 
be used for file input. 
11. Write a statement that defines a file stream object named places. 
The object 
will be used for both output and input. 
12. Write two statements that use the people file stream object to open a file named 
people. 
dat. (Show how to open the file with a member function and at 
definition.) The file should be opened for output . 
13. Write two statements that use the pets file stream object to open a file named 
pets. dat. (Show how to open the file with a member function and at definition .) 
The file should be opened for input. 
14. Write two statements that use the places file stream object to open a file named 
places.dat. 
(Show how to open the file with a member function and at 
definition.) The file should be opened for both input and output. 
15. If a file fails to open, the file stream object will be set to ___ 
_ 
16. Write a program segment that defines a file stream object named employees. 
The file should be opened for both input and output (in binary mode). If the file 
fails to open, the program segment should display an error message. 
17. The same formatting techniques used with ____ 
may also be used when 
writing information to a file. 
18. The _____ 
member function reports when the end of the file has been 
encountered . 
19. The ____ 
function reads a line of text from a file. 
20. The 
member function reads a single character from a file. 
21. The 
member function writes a single character to a file. 
22. 
files contain data that is unformatted and not necessarily stored as 
ASCII text. 
23. ----
files contain information formatted as ASCII text. 
24. A record is a complete set of information about a single item and is made up of 
25. In C++, _____ 
provide a convenient way to organize information into 
fields and records. 
26. The ____ 
member function writes "raw" binary data to a file. 
27. The ____ 
member function reads "raw" binary data from a file. 
28. The ____ 
operator is necessary if you pass anything other than a pointer 
to char as the first argument of the two functions mentioned in questions 26 
and 27. 

Review Questions and Exercises 
909 
29. In _____ 
file access, the contents of the file are read in the order they 
appear in the file, from the file's start to its end. 
30. In _____ 
file access, the contents of a file may be read in any order. 
31. The _____ 
member function moves a file's read position to a specified byte 
in the file. 
32. The ____ 
member function moves a file's write position to a specified 
byte in the file. 
33. The ____ 
member function returns a file's current read position. 
34. The ____ 
member function returns a file's current write position. 
35. The ____ 
mode flag causes an offset to be calculated from the beginning 
of a file. 
36. The ____ 
mode flag causes an offset to be calculated from the end of a file. 
37. The ____ 
mode flag causes an offset to be calculated from the current 
position in the file. 
38. A negative offset causes the file's read or write position to be moved ___ 
_ 
in the file from the position specified by the mode. 
Algorithm Workbench 
39. Give a pseudocode algorithm for determining the length of a file: that is, the 
number of bytes that are stored in the file. 
40. Give a pseudocode algorithm for comparing two files to see if their contents are 
identical. 
41. Design a pseudocode algorithm for reversing the contents of a text file into another 
file. Assume that the amount of memory is limited, so that you cannot read the entire 
source file into memory before you start writing it to a second file in reverse order. 
42. Suppose that you have two text files that contain sequences of integers separated 
by whitespace (blank space, tabs, and line breaks). The integers in both files 
appear in sorted order, with smaller values near the beginning of the file and 
large values closer to the end. Write a pseudocode algorithm that merges the 
two sequences into a single sorted sequence that is written to a third file. 
Find the Error 
43. Each of the following programs or program segments has errors . Find as many 
as you can. 
A) fs t ream fi l e(ios: 
:i n I ios: :out); 
f il e .open("info.dat"); 
if (!file) 
{ 
co ut << "Could not open file.\
n"; 
} 
B) ofstream 
file; 
f il e .open("i nfo.dat", 
ios: :i n); 
if (f il e) 
{ 
cou t << "Could not open file.\
n"; 
} 

910 
Chapte r 1 3 
Advanced File and 1/0 Operat ions 
C) fs t rea m fi l e(" i nfo.da t "); 
if (!file) 
{ 
co ut << "Could not open file.\
n"; 
) 
D ) fs t ream dat aFile("
i nfo.da t ", i os: i n I ios:bi
nary); 
i nt X = 5; 
dat aFil e << x; 
E) fs t ream dat aFile("
i nfo.da t ", i os: i n); 
i nt x; 
while 
(dataF i le.eof()) 
{ 
) 
dat aFi l e >> x; 
cout << x << endl; 
F) fs t ream dat aFile("
i nfo.da t ", i os: i n); 
char line [81] ; 
dat aFil e .get(l
i ne); 
G) fs t ream dat aFile("
i nfo.da t ", i os: i n); 
char st uff[81]; 
dat aFil e .get(stuff); 
H) fs t ream dat aFile("
i nfo.da t ", i os: i n); 
char st uff [ 81 ] = "abcdefghi j kl mnopqrstuvwxyz" ; 
dat aFil e .put(stuff); 
I) 
fs t ream dat aFile("
i nfo.da t ", i os:out); 
str uct Date 
{ 
i nt mont h; 
i nt day; 
i nt year; 
) ; 
Dat e dt = { 4, 2, 98 }; 
dat aFil e .write(&d t , sizeof(
i nt)); 
J) 
fs t ream inFile("
i nfo.da t ", i os: i n); 
in t x; 
inF il e .seekp(5); 
inF il e >> x; 
Soft Skills 
44. Learning to look beyond the symptoms of a problem to identify the root cause is an 
important skill. Bugs in a program are sometimes the result of careless mistakes, but 
at other times, they reflect a fundamental misunderstanding of some concept. 
Suppose that a friend has been trying to determine why his file processing 
program is not working correctly . You notice that he is passing file objects to 
functions by value. In addition to simply telling your friend that file parameters 
need to be passed by reference, what can you tell him that will help him 
understand why files need to be passed by reference? 
Suppose now that you need to demonstrate this bug to other people. Bugs usually 
occur in the context of a larger program, which can make it difficult for a person 
unfamiliar with the program to understand what is happening . Write a program 
that is as short as possible but still has the file-passing bug. 

Programming Challenges 
911 
Programming 
Challenges 
1 . File Previewer 
Write a program that asks the user for the name of a text file. The program should display 
the first 10 lines of the file on the screen. If the file has fewer than 10 lines, the entire file 
should be displayed along with a message indicating the entire file has been displayed. 
2. File Display Program 
Write a program that asks the user for the name of a file. The program should display 
the contents of the file on the screen. If the file's contents won't fit on a single screen, the 
program should display 24 lines of output at a time and then pause. Each time the program 
pauses, it should wait for the user to type a key before the next 24 lines are displayed. 
3. Punch Line 
Write a program that reads and prints a joke and its punch line from two different files. 
The first file contains a joke but not its punch line. The second file has the punch line as 
its last line, preceded by "garbage." The main function of your program should open the 
two files and then call two functions, passing each one the file it needs. The first function 
should read and display each line in the file it is passed (the joke file). The second function 
should display only the last line of the file it is passed (the punch line file). It should find 
this line by seeking to the end of the file and then backing up to the beginning of the last 
line. Data to test your program can be found in the jo ke . dat and punc hl ine . da t files. 
4. Tail of a File 
Write a program that asks the user for the name of a text file. The program should 
display the last 10 lines of the file on the screen (the "tail" of the file). If the file has 
less than 10 lines, the entire file is displayed, with a message that the entire file has 
been displayed. The program should do this by seeking to the end of the file and then 
backing up to the tenth line from the end. 
5. String Search 
Write a program that asks the user for the name of a file and a string to search for. 
The program will search the file for all occurrences of the specified string and display 
all lines that contain the string. After all occurrences have been located, the program 
should report the number of times the string appeared in the file. 
6. Sentence Filter 
A program that processes an input file and produces an outpu t file is called a filter. 
Write a program that asks the user for two filenames. The first file will be opened for 
input, and the second file will be opened for output . (It will be assumed that the first file 
conta ins sentences that end with a period.) The program will read the contents of the 
first file and change all the letters other than the first letter of sentences to lowercase. 
The first letter of sentences should be made uppercase . The revised contents should be 
stored in the second file. 

912 
Chapter 1 3 
Advanced File and 1/0 Operations 
VideoNote 
Solving the 
File Encryption 
Filter Problem 
7. File Encryption Filter 
File encryption is the science of writing the contents of a file in a secret code. Your 
encryption program should work like a filter, reading the contents of one file, modifying 
the information into a code, and then writing the coded contents out to a second file. 
The second file will be a version of the first file but written in a secret code. 
Although there are complex encryption techniques, you should come up with a simple 
one of your own. For example, you could read the first file one character at a time and 
add 10 to the ASCII code of each character before it is written to the second file. 
8. File Decryption Filter 
Write a program that decrypts the file produced by the program in Programming 
Challenge 7. The decryption program should read the contents of the coded file, restore 
the information to its original state, and write it to another file. 
9. Letter Frequencies 
The letter e is the most frequently used letter in English prose, and the letter z is the least 
frequently used. A friend of yours doing a sociology experiment believes that this may 
not necessarily be true of the writings of first-year college students . To test his theory, 
he asks you to write a program that will take a text file and print, for each letter of the 
English alphabet, the number of times the letter appears in the file. 
Hint: Use an integer array of size 128, and use the ASCII values of letters to index into 
the array to store and retrieve counts for the letters. 
10. Put It Back 
C++ input stream classes have two member functions, unget () and putba ck(), that 
can be used to "undo" an operation performed by the get () function. Research these 
functions on the Internet, and then use one of them to rewrite Program 13-9 without 
using the peek () function. 
11. Insertion Sort on a File I 
Write a program that uses an initially empty file to store a sorted list of integers entered 
by the user. The integers are stored in binary form. Each time the program is run, it 
opens the file and outputs the list of stored integers onto the screen. The program then 
asks the user to enter a new integer X. The program then looks at the integer at the 
end of the file. If that integer is less than or equal to X, the program stores X at the end 
of the file and closes the file. Otherwise, the program starts at the end of the file and 
works toward the beginning, moving each value in the file that is greater than X up by 
one until it reaches the position in the file where X should be stored. The program then 
writes X at that position and closes the file. 
12. Insertion Sort on a File II 
Modify the program written for Programming Challenge 11 so that the file contains 
records of people. Each record should contain an array of 10 characters to hold the 

Programming Challenges 
91 3 
name of a person and an integer to hold the person's age. The file should be sorted by 
alphabetic order of the names. 
13. Corporate Sales Data Output 
Write a program that uses a structure to store the following information on a company 
division: 
Division name (such as East, West, North, or South) 
Quarter (1, 2, 3, or 4) 
Quarterly sales 
The user should be asked for the four quarters' sales figures for the East, West, North, 
and South divisions. The information for each quarter for each division should be 
written to a file. 
14. Corporate Sales Data Input 
Write a program that reads the information in the file created by the program in 
Programming Challenge 13. The program should calculate and display the following 
figures: 
• Total corporate sales for each quarter 
• Total yearly sales for each division 
• Total yearly corporate sales 
• Average quarterly sales for the divisions 
• The highest and lowest quarters for the corporation 
15. Inventory Program 
Write a program that uses a structure to store the following inventory information in a file: 
Item description 
Quantity on hand 
Wholesale cost 
Retail cost 
Date added to inventory 
The program should have a menu that allows the user to perform the following tasks: 
• Add new records to the file. 
• Display any record in the file. 
• Change any record in the file. 
16. Inventory Screen Report 
Write a program that reads the information in the file created by the program in 
Programming Challenge 14. The program should calculate and display the following 
information: 
• The total wholesale value of the inventory 
• The total retail value of the inventory 
• The total quantity of all items in the inventory 

914 
Chapte r 13 
Advanced File and 1/0 Opera tions 
Group Project 
17. Customer Accounts 
This program should be designed and written by a team of students. Here are some 
suggestions: 
• One student should design function mai n, which will call other program functions 
or class member functions. The remainder of the functions will be designed by 
other members of the team. 
• The requiremen ts of the program should be analyzed so each student is given 
about the same workload. 
Write a program that uses a structure to store the following information about a 
customer account: 
• Name 
• Address 
• City, state, and ZIP 
• Telephone number 
• Account balance 
• Date of last payment 
The structure should be used to store customer account records in a file. The program 
should have a menu that lets the user perform the following operat ions: 
• Enter new records into the file 
• Search for a partic ular customer's record and display it 
• Search for a partic ular customer's record and delete it 
• Search for a partic ular customer's record and change it 
• Display the contents of the entire file 
Input Validation: When the information for a new account is entered, be sure the 
user enters data for all the fields. No negative account balances should be entered. 
18. Ordered by Name, Ordered by Age 
Write a program that processes a text file that contains names of people paired with 
ages. Each name- age pair is on a line by itself, with the name coming first and separated 
from the age by whitespace. The program prints out the data line by line, in alphabetical 
order of names, and then prints out the same data in ascending order of age. Here is a 
sample input file. 
Mary 
45 
Anna 
78 
Sophi a 
5 
Pet ros 
12 
The file may have any number of lines of such data. The output should be printed to 
the screen as well as to an output file. 

TOPICS 
14.1 
Introduction to Recursion 
14.2 
The Recursive Factorial Function 
14.3 
The Recursive gcd Function 
14.4 
Solving Recursively Defined Problems 
14.5 
A Recursive Binary Search Function 
14.6 
Focus on Problem Solving and Program 
Design: The QuickSort Algorithm 
14.7 
The Towers of Hanoi 
14.8 
Focus on Problem Solving: Exhaustive 
and Enumeration Algorithms 
14.9 
Focus on Software Engineering: 
Recursion versus Iteration 
14.10 Tying It All Togethe r: Infix and Prefix 
Expressions 
14.1 
Introduction 
to Recursion 
CONCEPT: 
A recursive functio n is one tha t calls itself. 
You have seen instances of functions calling other functions. Functi on A can call function 
B, which can then call Function C. It's also possible for a function to call itself. A function 
that calls itself is a recursive function. Look at this message function: 
void message () 
{ 
} 
cout 
<< "Thi s is a recursive 
function.\n"; 
message (); 
915 

916 
Chapter 14 
Recursion 
Figure 14-1 
This function displays the string "Thi s is a recursive 
funct i on. \ n" and then calls 
itself. Each time it calls itself, the cycle is repeated . Can you see a problem with the 
function? There 's no way to stop the recursive calls. This function is like an infinite 
loop because there is no code to stop it from repeating. 
To be useful, a recursive function must have a way of controlling the number of 
recursive calls. The following is a modification of the message function . It passes an 
integer argument that holds the number of times the function is to call itself. 
voi d message(int 
times) 
{ 
) 
if (times> 
0) 
{ 
) 
cout << "Thi s is a recursive 
func t ion.\ n"; 
message(t i mes -
1); 
This function contains an if statement that controls the recursion . As long as the t i mes 
argument is greater than zero, it will display the message and call itself again . Each 
time it calls itself, it passes t i mes - 1 as the argument . For example, let's say a program 
calls the function with the following statement: 
message(3); 
The argument, 3, will cause the funct ion to be called four times . The first time the 
function is called, the i f statement will display the message and call itself with 2 as the 
argument. Figure 14-1 illustrates this. 
message (3) 
times = 3 
2 
• 
message (2) 
times= 
2 
The diagram in Figure 14-1 illustrates two separate calls of the message function. Each 
time the function is called, a new instance of the t i mes parameter is created in memory. 
The first time the function is called, the ti mes parameter is set to 3. When the function 
calls itself, a new instance of ti mes is created, and the value 2 is passed into it. This 
cycle repeats until zero is passed to the function . This is illustrated in Figure 14-2. 
As you can see from Figure 14-2, the function will be called four times, so the depth of 
recursion is four. When the function reaches the fourth call, the t i mes parameter will 
be set to 0. At that point, the if statement will stop the recursive chain of calls, and the 

Figure 14-2 
14.1 Introduction to Recursion 
917 
message (3) 
t i mes = 3 
2 
• 
message (2) 
t i mes = 2 
1 
message (1) 
t i mes = 1 
0 . 
message (0) 
t i mes= 0 
fourth instance of the function will return. Control of the program will return from the 
fourth instance of the function to the point in the third instance directly after the 
recursive function call: 
if 
(tim es> 
0) 
{ 
cout << "This i s a recursive 
function
.\n"; 
message(times 
- 1); 
) 
~ 
Control returns here. 
Because there are no more statements to be executed after the function call, the third 
instance of the function returns contro l of the program to the second instance . This 
repeats until all instances of the function return . Program 14-1 demonstrates the 
recursive message function, modified to show the value of the parameter to each call. 
Program 14-1 
1 // This program demonstrates 
a simple recursive 
f unction. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
(program continues) 

918 
Chapte r 14 
Recursion 
Program 14-1 
(continued) 
5 II Function 
prototype 
6 void message( i nt); 
7 
8 int main() 
9 { 
10 
message (3); 
11 
return 
O; 
12 ) 
13 
14 //*********************************************************** 
15 II Definition 
of function 
message. 
If the value in times 
* 
16 II is greater 
than 0, the message is displayed 
and the 
* 
17 II function 
is recursively 
called 
wi th the argument 
* 
18 II times - 1 . 
* 
19 //*********************************************************** 
20 void message( i nt t i mes) 
21 { 
22 
23 
if 
(tim es> 
0) 
{ 
24 
cout <<"Message"<< 
times<< 
"\n"; 
25 
message(times 
- 1); 
26 
} 
27
} 
Program Output 
Message 3 
Message 2 
Message 1 
To further illustrate the inner workings of this recursive function, let's look at another 
version of the program. In Program 14-2, a message is displayed each time the function 
is entered, and another message is displayed just before the function returns. 
Recurs ive functions work by breaking a complex problem down into subproblems of 
the same type. Thi s breaking-down 
process stops when it reaches a base case, that is, 
a subpr oblem that is simple eno ugh to be solved directly. For example, in the recursive 
message function of the preceding examples, the base case is when the parameter 
times is 0. 
Program 14-2 
1 II Thi s program demonstrates 
a simple 
recursive 
function. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 II Function 
prototype 
6 void message( i nt); 
(program continues) 

14.1 Introduction to Recursion 
919 
Program 14-2 
7 
(continued) 
8 int main() 
9 { 
10 
message (3); 
11 
return 
O; 
12 ) 
13 
14 //*********************************************************** 
15 II Definition 
of function 
message. 
If the value in times 
* 
16 II 
is greater 
than 0, the message is displayed 
and the 
* 
17 II function 
is recursively 
called 
wi th the argument 
* 
18 II times - 1 . 
* 
19 //*********************************************************** 
20 void message( i nt times) 
21 { 
22 
23 
24 
25 
cout << "Message 
if (tim es> 
0) 
II<< 
t i mes << ". \n"; 
{ 
message(t i mes - 1); 
26 
} 
27 
cout <<"Message"<< 
t i mes<<" 
is returning.\n"; 
28
} 
Program Output 
Message 
Message 
Message 
Message 
Message 
Message 
Message 
Message 
3. 
2. 
1 . 
0. 
0 
1 
2 
3 
is returning. 
is returning. 
is returning. 
is returning. 
You should consider the use of recursion when there is a way to express the solution of a 
problem in terms of solutions of simpler, or smaller, problems of the same type. As an 
example, one can envision sorting a long list of names by splitting the list into two sublists 
and assigning the two sublists to two different people to sort. Once the sublists are sorted, 
they can be merged into a sorted version of the original list by a suitable collating process. 
In this case, the problems of sorting the sublists are the simpler problems of the same 
type, and the base cases occur when the sublists consist of a single name. 
Let's look at a simp le example of recursion that performs a useful task. Th e function 
frequency 
counts the number of times a specific character appears in a string . 
int frequency (c har ch, string 
inputString, 
i nt position) 
{ 
if (position== 
i nputString.length()) 
return 
O; 
if (inputStr
i ng[position] 
== ch) 
// base case 

920 
Chapte r 14 
Recursion 
return 
1 + frequency
(ch, 
inputString, 
pos i t i on+1); 
else 
return 
frequency(ch, 
inputString, 
posit i on+1); 
) 
Th e funct ion's parameters are 
• ch: the character to be searched for and counted 
• i nputSt ring: the string to be searched 
• position: 
the starting subscript for the search 
Th e first i f statement determines whether the base case, that is, the end of the string, 
has been reached: 
if 
(position
== inputString.length()) 
return 
O; 
If the end of the string has been reached, the function returns 0, indicating there are no 
more characters to count. Otherwise , the following i f statement is executed: 
if 
(inputString
[pos it i on] == ch) 
return 
1 + frequency(ch, 
inputStr
i ng, position+1); 
else 
return 
frequency(ch, 
inputStr
i ng, position+1); 
If inputString[position] 
is the search character, the function performs a recurs ive 
call . Th e return statement returns 1 + the number of times the searc h character appears 
in the string, starting at position 
+ 1. If i nputSt ring [position] 
is not the search 
character, a recursive call is made to search the remainde r of the string. Program 14-3 
demonstrates the program. 
Program 14-3 
1 II Thi s program demonstrates 
a rec urs ive function 
fo r 
2 II counting 
the number of times a character 
appears 
3 II 
in a str i ng . 
4 #include 
<iostream> 
5 #include 
<str i ng> 
6 using namespace std ; 
7 
8 II Function 
prototype 
9 int 
freq uency( char ch , str i ng inputString, 
int 
pos); 
10 
11 int main() 
12 { 
13 
string 
inputStr
i ng = "abcddddef"; 
14 
15 
cout << "The letter 
d appears" 
16 
<< freq uency (' d' , inputString
, 0) <<" 
times.\n"; 
17 
ret urn O; 
18 } 
(program continues) 

Program 14-3 
19 
(continued) 
20 //************************************************ 
21 // Function 
frequency. 
This recursive 
function 
22 II counts the number of times the character 
* 
* 
23 // ch appears 
in inputString. 
The search 
begins 
* 
24 II at index position 
in the string. 
* 
25 //************************************************ 
14.1 Introduction to Recursion 
921 
26 int frequency(char 
ch, str i ng inputString, 
int pos i t i on) 
27 { 
28 
if (position=
= inputString.length()) 
//b ase case 
29 
return 
O; 
30 
if (i nputString[pos
i t i on] == ch) 
31 
return 
1 + frequency(ch, 
inputStr
i ng, position+1); 
32 
else 
33 
return 
frequency(ch, 
inputStr
i ng, position+1); 
34
) 
Program Output 
The letter 
d appears 
4 times. 
Direct and Indirect Recursion 
The examples we have discussed so far show recursive functions that directly call 
themselves. This is known as direct recursion. There is also the possibility of creating 
indirect recursion in a program. This occurs when function A calls function B, which in 
turn calls function A. There can even be several functions involved in the recursion. For 
example, function A could call function B, which could call function C, which calls 
function A. 
~ 
Checkpoint 
14.1 What is a recursive function's base case? 
14.2 What happens if a recursive function does not handle base cases correctly? 
14.3 What will the following program display? 
#include 
<iostream> 
us i ng namespace std ; 
// Function 
prototype 
voi d showMe(int arg); 
i nt main() 
{ 
) 
int num = O; 
showMe(num); 
return 
O; 

922 
Chapte r 14 
Recursion 
14.2 
voi d showMe(i nt arg ) 
{ 
} 
if (arg < 10) 
showMe(++arg ); 
else 
cout << arg << endl ; 
14.4 
What is the difference between direct and indirect recursion? 
The Recursive Factorial Function 
CONCEPT: 
The recursive factorial function accepts an argument and calculates its 
factorial. Its base case is when the argument is 0. 
Let's use an example from mathematics to examine an appl ication of recursion . In 
mathemati cs, the notation n! represents the factorial of the number n. The factorial of 
an integer n is defined as 
n ! 
= 1 x 2 x 3 x . . . x n; if n > 0 
= 1; 
if n = 0 
The rule states that when n is greater than 0, its factorial is the product of all the positive 
integers from 1 up to n. For instance, 6! can be calculated as 1 x 2 x 3 x 4 x 5 x 6. The 
rule also specifies the base case: the factorial of O is 1. 
We can define the factorial of a number using recursion as follows: 
factorial(n) = n x factorial(n - 1) if n > 0 
= 1; 
if n = 0 
The C++ implementat ion of this recursive definition is 
i nt factoria
l(i nt num) 
{ 
} 
if (num == 0) // base case 
return 
1; 
else 
return 
num * factor
i al (num - 1}; 
Consider a program that displays the value of 3! with the following statement: 
cout << factoria
1(3) 
<< end l; 
The first time the function is called, num is set to 3. The if statement will execute the 
following line: 
return 
num * factor
ial (num -
1); 
Although this is a retur n statement , it does not immediately return . Before the return 
value can be determined, the value of fac t ori a 1 ( num - 1 ) must be determined . The 
function is called recursively until the fourth call, in which the num parameter will be set 
to zero. The diagram in Figure 14-3 illustrates the value of num and the return value 
during each call of the function . 

14.2 The Recursive Factorial Func tion 
923 
Figure 14-3 
3l 
return n um x2 =3 x2 = 6 
factorial (3) 
num = 3 
2 
return n um x 1 = 2 x 1 = 2 
factorial (2) 
num = 2 
1 
return n um x 1 = 1 x 1 = 1 
factorial (1) 
num = 1 
0 
return 1 
factorial (0) 
num = 0 
Program 14-4 demonstrates the factorial 
function. 
Program 14-4 
1 II Thi s program demonstrates 
a rec urs i ve function 
2 II to calculate 
the factoria
l of a number. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 int facto ria l (in t ); 
8 
9 int main() 
10 { 
11 
int number; 
12 
13 
cout << "Enter an integer 
value and I will 
display\n"; 
14 
cout << "its 
factor
i al: 
"; 
15 
cin 
>> number ; 
16 
cout << "The factorial 
of"<< 
number<<" 
is"· 
17 
cout << factoria
l(n umber) 
<< endl ; 
18 
ret urn O; 
19 ) 
20 
(program continues) 

924 
Chapte r 14 
Recursion 
Program 14-4 
(continued) 
21 //**************************************************** 
22 II Definition 
of factorial. 
A recursive 
function 
to 
* 
23 // calculate 
the factorial 
of the parameter, 
num. 
* 
24 //**************************************************** 
25 int factorial(int 
num) 
26 { 
27 
if (num == 0) 
// base case 
28 
return 
1; 
29 
else 
30 
return 
num * factorial
(num - 1); 
31 } 
Program Output with Example Input 
Enter an integer 
value and I will 
display 
its 
factorial: 
4 
The factorial 
of 4 is 24 
14.3 
The Recursive gcd Function 
CONCEPT: 
Th ere is a recursive method for finding the greatest common divisor 
(gcd) of two numbers. 
Our next example of recursion is the calculation of the greatest common divisor, or gcd, of 
two numbers. Using Euclid's algorithm, the gcd of two positive integers, x and y, is 
gcd(x, y) = y 
= gcd(y, remainder of x/y); 
if y divides x with no remainder 
otherwise 
This definition states that the gcd of x and y is y if xly has no remainder. Otherwise, 
the answer is the gcd of y and the remainder of xly. Program 14-5 shows the recursive 
C++ implementation: 
Program 14-5 
1 // This program demonstrates 
a recursive 
function 
to 
2 II calculate 
the greatest 
common divisor 
(gcd) of two 
3 // numbers . 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 II Function 
prototype 
8 int gcd (int, 
i nt} ; 
9 
10 int main() 
11 { 
12 
int num1, num2; 
13 
(program continues) 

14.4 Solving Recursively Defined Problems 
925 
Program 14-5 
(continued) 
14 
cout << "Enter two integers: 
"; 
15 
cin >> num1 >> num2; 
16 
cout << "The greatest 
common di vi sor of"<< 
num1; 
17 
cout <<''and"<< 
num2 <<"is''; 
18 
cout << gcd(num1, num2) << endl ; 
19 
return 
O; 
20
} 
21 
22 //********************************************************* 
23 II Definition 
of gcd. This function 
uses recursion 
to 
* 
24 II calculate 
the greatest 
common divisor 
of two integers
, * 
25 II passed into the parameters 
x and y. 
* 
26 //********************************************************* 
27 int gcd(int 
x , int y) 
28 { 
29 
30 
31 
32 
33 } 
if 
(x % y 
return 
else 
return 
-- 0) 
// base case 
y; 
gcd(y, 
X % y); 
Program Output with Example Input Shown in Bold 
Enter two integers: 
49 28 
The greatest 
common divisor 
of 49 and 28 is 7 
14.4 
Solving Recursively Defined Problems 
CONCEPT: 
Some prob lems naturally lend themselves to recursive solutions. 
One well-known example of problems that naturally lend themselves to recursive solutions 
is the calculation of Fibonacci numbers. The Fibonacci numbers, named after the Italian 
mathematician Leonardo Fibonacci (c. 1170--c. 1250), form the following sequence: 
o, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89,144,233, 
.. . 
Notice that after the second number, each number in the sequence is the sum of the 
two previous numbers . The Fibonacci sequence can be defined as: 
F0 = 0, 
F1 = 1, 
FN = FN - 1 + FN - 2 
for all N ~ 2. 
It is clear that the problem of computing a Fibonacci number other than the first two 
can be reduced to the problems of computing the two preceding Fibonacci numbers. 
Thus, this problem makes a good candidate for a recursive solution. The problems of 
computing the first two Fibonacci numbers are the base cases. Here is the recursive 
C++ function for computing the nth number in the Fibonacci sequence: 

926 
Chapte r 14 
Recursion 
int fib (int n) 
{ 
if (n <= 0) 
II base case 
return 
O; 
else 
if (n == 
1 ) 
II base case 
return 
1 . 
' 
else 
return 
fib(n 
-
1) + fib(n 
-
2); 
) 
The function is demonstrated in Program 14-6, which displays the first 10 numbers in 
the Fibonacci sequence. 
Program 14-6 
1 // Thi s program demonstrates 
a rec urs i ve function 
2 // that 
calculates 
Fi bonacci numbers. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 int f i b(int); 
8 
9 int main() 
10 { 
11 
cout << "The first 
10 Fi bonacc i numbers are:\n"; 
12 
for (i nt x = O; x < 10; x++) 
13 
cout << fib (x) <<" 
"; 
14 
cout << endl; 
15 
return 
O; 
16 ) 
17 
18 //***************************************** 
19 // Function 
f i b. Accepts an int argument 
20 //inn. 
This function 
returns 
the nth 
* 
* 
21 // Fibonacc i number. 
* 
22 //***************************************** 
23 
24 int f i b(int 
n) 
25 { 
26 
27 
28 
if 
(n <= 0) 
return 
O; 
els e if (n == 
1) 
29 
return 
1 ; 
30 
els e 
// base case 
// base case 
31 
return 
fib (n -
1) + fib (n - 2); 
32 ) 
Program Output 
The first 
10 Fibonacci 
numbers are: 
0 1 1 2 3 5 8 13 21 34 
Another such example is Ackermann's function. A Programming Challenge at the end of 
this chapter asks you to write a recursive function that calculates Ackermann's function. 

a 
VideoNot e 
Recursive 
Binary Search 
14.5 A Recursive Binary Search Function 
92 7 
A Recursive Binary Search Function 
CONCEPT: 
Th e bin ary search algorithm can be defined as a recursive functio n. 
In Chapter 9 you learned abo ut the binary search algorithm and how it can be used to 
search a sorted array for a given value. Let us look to see how the binary search algorithm 
can be form ulated using recursion. Suppose that we want to write the function so that it 
has prototype 
i nt bina rySearch (const i nt array[], 
i nt first, 
i nt last , int value) 
where the parameter array is the array to be searched; the parameter f i rst holds the 
subscript of the first element in the search range (the portion of the array to be searched); 
the parameter 1 ast holds the subscript of the last element in the search range; and the 
parameter value holds the value to be searched for. The function will return the 
subscript of value if it is found within the array, and will return - 1 otherwise . 
In order to use recursion, we need to find a way to break down the problem of searching 
a range of a sorted array for a given value into smaller problems of the same type. We 
start by comparing value to the middle element of the search range . If value is equal to 
the middle element , we are done and we return the subscript of the middle element . 
Otherwise , if va 1 ue is smaller than the middle element, then we must search for it in the 
lower half of the original range (a recursive call on a smaller problem of the same type ); 
but if value is larger than the middle element, we must search for it in the upper half of 
the origina l range . Notice that every time we make a recursive call, the search range will 
be smaller. The base case is when the search range is empty . Here is the function: 
i nt binarySearch
(const i nt array[], 
i nt first, 
i nt last , int value) 
{ 
} 
int middle ; 
II mid poi nt of search 
if (first> 
last ) 
II base case 
return 
- 1; 
mi ddle
= (first+ 
last ) I 2 ; 
if (array[middle
] == value) 
return 
middle ; 
if (array[middle
] < value) 
return 
binarySearch(array
, middle +1 ,last.v
alue ); 
else 
return 
binarySearch(array
, f i rst ,middle- 1,va lue ); 
This function is demonstrated in Program 14-7 . 
Program 14-7 
1 II Thi s program demonstrates 
a rec urs i ve function 
that 
2 II performs a binary 
search on an integer 
array . 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Function 
prototype 
(program continues) 

928 
Chapte r 14 
Recursion 
Program 14-7 
(continued) 
7 int bi narySearch (const 
int 
[], 
int , int , int)
; 
8 
9 const 
int SIZE = 20 ; 
10 
11 
12 
13 
14 
15 
int main () 
{ 
int tests[SIZEJ 
= { 101 , 142, 147 , 
234 , 289, 296 , 
417 , 429, 447 , 
16 
int result
; II Result 
of the search 
17 
int 
empID; II What to search 
for 
18 
189 , 199, 
310 , 319, 
521 , 536, 
207 , 222 , 
388 , 394 , 
600} ; 
19 
cout << "Enter the Employee ID you wi sh to search 
for: 
"· 
20 
cin >> empID; 
21 
result= 
bi narySearch(tests
, 0 , SIZE - 1, empID); 
22 
if (result=
= - 1) 
23 
24 
25 
26 
27 
28 
29 
30 
31 
cout 
else 
{ 
cout 
cout 
} 
return o· ' 
} 
<< "That number does not exist 
in the array.
\ n"; 
<< "That ID is found at element"<< 
result
; 
<< " in the array\n"; 
32 / / *** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * *** 
33 II The binarySearch 
function 
performs 
a recursive 
binary 
34 II search 
on a range of elements 
of an i nteger 
array. 
The 
35 II parameter 
first 
holds the subscr i pt of the range's 
36 II starting 
element , and last 
holds the subscript 
of the 
37 II ranges ' s last 
element. 
The parameter 
value holds the 
38 II the search 
value. 
If the search 
value i s found , its 
39 II array 
subscript 
is returned. 
Otherwise , -1 is returned 
40 II indicating 
the value was not in the array . 
* 
* 
* 
* 
* 
* 
* 
* 
41 //
*** * * * * * * * * * ****
* * * * * * * * * ******
* * * * * * * * * ******
* * * * * * * * * *** 
42 int bi narySearch (const 
int array[
] , int f i rst , int last, 
int value ) 
43 { 
44 
45 
int middle ; 
II Mid point of search 
46 
if (first> 
last) 
II Base case 
47 
return 
- 1; 
48 
middle= 
(first+ 
last )l 2 ; 
49 
if (array[middle]
==value ) 
50 
return 
middle ; 
51 
if (array[middle]<value
) 
52 
return 
binarySearch
(array, 
middle+1 , last,value
) ; 
53 
else 
54 
return 
binarySearch
(array, 
first,middle-1
,value ); 
55 } 
Program Output with Example Input Shown in Bold 
Enter the Emp 1 oyee ID you wish to search 
for: 
521 [Enter] 
That ID is found at element 
17 in the array 

a 
VideoNote 
QuickSort 
Figure 14-4 
14.6 Focus on Problem Solving and Program Design: The QuickSort Algorithm 
929 
Focus on Problem Solving and Program 
Design: The QuiclcSort Algorithm 
CONCEPT: 
Th e Qui ckSort algorithm uses recursion to sort lists efficiently. 
QuickSort is a recursive sorting algorithm that was invented in 1960 by C. A. R. Hoare . It 
is very efficient and is often used to sort lists of items stored in arrays . QuickSort is usually 
written as a recursive function with three parameters that define a portion of an array to be 
sorted. The three parameters are an array arr containing a list of items and two subscripts, 
start and end, denoting the beginning and end of the segment of arr that is to be sorted. 
Let us write arr(star
t . . end) for these three parameters . To sort the entire array, you call 
QuickSort with star t set to O and end set to the size of the array minus 1. 
QuickSort works as follows. If star t is greater than or equal to end, then the segment 
of arr to be sorted has at most one element and is therefore already sorted . In this case, 
QuickSort returns immediately . Otherwise , QuickSort partitions arr(star
t . . end) by 
selecting one of the elements in arr[ start 
. . end) to be a pivot element and then 
rearranging arr( star t . . end) so that all entr ies that are less than the pivot are to the 
left of the pivot, and all entries greater than or equal to the pivot are to the right of the 
pivot. In effect, the partition step rearranges arr( star t .. end) so that it consists of a 
sublist 1, the pivot element, and a sublist 2, as shown in Figure 14-4. 
start 
t 
t 
sublist 1 
entries < pivot 
end 
t 
sublist 2 
entries ~ pivot 
t 
Depending on the value selected to be the pivot element, one or the other of the two 
sublists may be empty. For example, if the pivot element happens to be the minimum array 
element, there will be no array entries less than the pivot, and sublist 1 will be empty . 
Notice that once the partit ion stage is comp leted and we have the situation shown in 
Figure 14-4, the pivot element will be in the right place. By recursively applying the 
QuickSort procedure to the two sublists, each of the sublists will be partitioned, putting 
whatever element was selected to be the pivot for that sublist in its right place. The 
process continues unti l the length of the sub lists is at most one . At that point, the 
original array will be sorted . 
Let us assume that we have a function 
i nt par tit ion(i nt arr[], 
int start, 
i nt end) 
which when called will 
1. select a pivot element from arr(start 
. . end) 

930 
Chapter 14 
Recursion 
2. rearrange arr [ start 
.. end ] into sublist 1, the pivot element, and sublist 2 (see 
Figure 14-4) so that the pivot element is at position p and sublist 1 and sublist 2 
are, respectively, arr[start 
.. p-1 J and arr[p +1 .. end], 
3. return the position p of the pivot. 
We can then implement QuickSort in C++ as follows: 
voi d quickSort(
i nt arr( ] , int start, 
int end ) 
{ 
} 
if (start< 
end) 
{ 
} 
// Partition 
the array and get the pivot point 
i nt p = partition(arr
, start, 
end); 
// Sort the portion 
before the pivot point 
quickSort (arr, 
start, 
p - 1); 
// Sort the portion 
afte r the pivot point 
quickSort (arr, 
p + 1, end ); 
Now let us consider the process of partitioning the array segment arr[start 
.. end). 
The partitioning algorithm selects arr[start
) to be the pivot element and then builds 
the two sublists on the left and right of the pivot element in stages . Initially, the portion 
of the array that has been partitioned consists of just the pivot element by itself. In 
effect, the initial situation will be as shown in Figure 14-4, with sublist 1 and sublist 2 
being empty and all the array entries that have not yet been added to the partitioned 
part lying to the right of sublist 2. 
The main idea is to extend the partitioned portion of the array one element at a time by 
considering the element X that is just to the right of sublist 2. If such an Xis greater than 
or equal to the pivot, it is added to the end of sublist 2 by leaving it where it is and moving 
on to consider the next element. If X is less than the pivot element, it is added to the end 
of sublist 1 by placing it just to the left of the pivot element. One way to do this is to store 
X in a temporary location, move every element in sublist 2 up one position, move the 
pivot element up one position, and then drop X into the array position just vacated by the 
pivot element. This simplistic strategy moves too many array elements and does not result 
in an efficient algorithm . Instead, we can put X to the left of the pivot more efficiently by 
first exchanging X with the array item Y that is just to the right of the pivot element and 
then exchanging X with the pivot element. The first exchange puts Y, which is greater or 
equal to the pivot element, at the end of sublist 2 while putting X in a position that is 
adjacent to the pivot. The second exchange then puts X to the left of the pivot. This is 
repeated until the entire list has been partitioned. The code for the partition function is 
int partition
(i nt arr(], 
int start, 
i nt end ) 
{ 
// The pivot element is taken to be the element at 
// the start 
of the subrange to be partitioned 
int pi votValue = arr [start
]; 
int pivotPosit
i on = start; 
// Rearrange the rest of the array elements to 
// partition 
the subrange from start 
to end 
for (int pos =st art+ 
1; pos <= end; pos++) 

14.6 Focus on Problem Solving and Program Design: The QuickSort Algorithm 
931 
{ 
i f (arr[pos
] < pivotValue
) 
{ 
// arr[scan] 
is the "current" 
item 
// Swap the current 
item with the i tem to the 
// right 
of the pivot element 
swap (arr[p i votPosition 
+ 1], arr[pos
] ); 
// Swap the current 
item with the pivot 
element 
swap (arr[p ivotPosition
], arr[pivotPosition 
+ 1]); 
II Adjust 
the pivot 
pos i tion 
so it stays wi th the 
// pivot ele ment 
} 
} 
} 
pivotPos i t i on ++; 
return 
pivotPosition; 
The swap function used in par t i tion is part of the standard template library. You need 
to include the algorithm header file to use it. 
Program 14-8 demonstrates the QuickSort algorithm in action. 
Program 14-8 
1 // Thi s program demonstrates 
the Qui ckSort algorithm. 
2 #include 
<iostream> 
3 #include 
<algorithm> 
//ne eded for swap function 
4 using namespace std ; 
5 
6 II Function 
prototypes 
7 void qui ckSort(int 
[] , int, 
int); 
8 int partition(int 
[], 
i nt, 
int); 
9 
10 int main() 
11 { 
12 
// Array to be sorted 
13 
const i nt SIZE= 10 ; 
14 
int array[SIZE] 
= {17 , 53, 9, 2, 30, 1, 82, 64 , 26 , 5}; 
15 
16 
// Echo the array 
to be sorted 
17 
for (i nt k = O; k < SIZE; k++) 
18 
cout << array[k
] << • "; 
19 
cout << endl; 
20 
21 
// Sort the array 
usi ng Quicksort 
22 
qui ckSort(array, 
0, SIZE- 1); 
23 
24 
25 
26 
27 
28 
// Print 
the so rted 
for (i nt k = O; k < 
cout << array[k
] 
cout << endl; 
29 
return 
O; 
30 } 
31 
ar ray 
SIZE; k++ ) 
<< 
II 
It• 
' 
(program continues) 

932 
Chapte r 14 
Recursion 
Program 14-8 
(continued) 
32 //************************************************ 
33 II qui ckSort 
uses the Qui ckSort algor i thm to 
* 
34 II sort 
arr from arr[start
] through 
arr[end]
. 
* 
35 //************************************************ 
36 void quickSort(int 
arr[], 
int start, 
int end) 
37 { 
38 
if (sta rt< 
end ) 
39 
{ 
40 
II Partition 
the array and get the pivot 
point 
41 
i nt p = partition(arr
, start, 
end); 
42 
43 
II Sort the portion 
before 
the pivot point 
44 
quickSort(arr, 
start, 
p -
1); 
45 
46 
II Sort the portion 
after 
the pivot 
point 
47 
quickSort(arr, 
p + 1, end ); 
48 
} 
49
} 
50 
51 //*********************************************************** 
52 II 
53 II 
54 II 
55 II 
partit
i on rearranges 
the entries 
in the 
start 
to end so all 
values 
greater 
than 
pivot 
are on the right 
of the pivot 
and 
than are on the left 
of the pivot. 
array 
arr from 
or equal to the 
all 
values 
less 
* 
* 
* 
* 
56 //*********************************************************** 
57 int partition(int 
arr[ ] , int start
, int end) 
58 { 
59 
60 
61 
62 
63 
II The pivot 
element i s taken to be the element at 
II the start 
of the subrange 
to be partitioned 
int pivotValue 
= arr[start]; 
int pivotPosition 
= start
; 
64 
II Rearrange 
the rest 
of the array 
elements 
to 
65 
II partition 
the subrange 
from start 
to end 
66 
for (int 
pos =start+ 
1; pos <= end ; pos ++) 
67 
{ 
68 
if (arr[pos] 
< pivotValue) 
69 
{ 
70 
II arr[scan
] i s the "curr ent" i tem. 
71 
II Swap the current 
item wi th the item to the 
72 
II r i ght of the pivot 
element 
73 
swap(arr[pivotPos
i tion + 1] , arr[pos]
); 
74 
II Swap the current 
item wi th the pivot element 
75 
swap(arr[pivotPosition], 
arr[p i votPosition 
+ 1] ); 
76 
II Adjust the pi vot position 
so it stays 
with the 
77 
II pi vot element 
78 
pivotPosition 
++; 
79 
} 
80 
} 
81 
return 
pi votPos i t i on; 
82 } 
Program Output 
17 53 9 2 30 1 82 64 26 5 
1 2 5 9 17 26 30 53 64 82 

14.7 The Towers of Hanoi 
933 
The Towers of Hanoi 
CONCEPT
: There are probl ems that have simple recursive solutions but that are 
otherwise very difficult to solve. 
The Towers of Hanoi is a game that is often used in computer science textbooks to 
illustrate the power of recursion. The game uses three pegs and a set of disks of different 
sizes with holes through their centers. The game begins with all of the disks stacked on 
the first of the three pegs, as shown in Figure 14-5. 
Figure 14-5 
The pegs and disks in the Towers of Hanoi game 
The object of the game is to move all the disks from the first peg to the third, while 
abiding by the following rules: 
• All disks must rest on a peg except while being moved. 
• Only one disk may be moved at a time. 
• No disk may be placed on top of a smaller disk. 
Let us look at some examples of how the game is played. The simplest case is when 
there is only one disk: in this case, you solve the game in one move, by moving the disk 
from peg 1 to peg 3. 
If you have two disks, you can solve the game with three moves: 
1. Move a disk from peg 1 to peg 2 (it must be the top one). 
2. Move a disk from peg 1 to peg 3. 
3. Move a disk from peg 2 to peg 3. 
Notice that although the object of the game is to move the disks from peg 1 to peg 3, 
it is necessary to use peg 2 as a temporary resting place for some of the disks. The 
complexity of the solution increases rapidly as the number of disks to be moved increases. 
Moving three disks requires seven moves, as shown in Figure 14-6. 

934 
Chapte r 14 
Recursion 
Figure 14-6 
------
' ' ' 
Original setup. 
First move: Move disk 1 to peg 3. 
Secon d move: Move disk 2 to peg 2. 
' 
, 
, 
Fourth move: Move disk 3 to peg 3. 
Sixth move: Move disk 2 to peg 3. 
, 
I 
Third move: Move disk 1 to peg 2. 
Fifth move: Move disk 1 to peg 1. 
Seventh move: Move disk t to peg 3. 
There is a charm ing legend associated with this game. According to this legend, there is 
a group of monks in a temple in Hanoi who have a set of pegs with 64 disks. The 
monks are busy moving the 64 disks, initially stacked on the first peg, to the third peg. 
When the monks complete their task, the world will come to an end. 
Let us now return to the prob lem and consider its solution in the general case when we 
can have any number of disks. The problem can be stated as: 
Move n disks from peg 1 to peg 3 using peg 2 as a temporary peg. 
It is very difficult to see how this problem can be solved using loops. Happily, it is not 
difficult to envision a recursive solution: If we can (recursively) move n - 1 disks from 
peg 1 to peg 2 while using peg 3 as the temporary peg, then the largest disk will be left 
sitting alone on peg 1. We can then move the large disk from peg 1 to peg 3 in one move. 
We can next (recursively) move then - 1 disks from peg 2 to peg 3, this time using peg 1 
as the temporary peg. This plan can be formulated in pseudocode as follows: 
To move n disks from peg 1 to peg 3, using peg 2 as a temporary peg: 
If n > 0 Then 
Move n - 1 disks from peg 1 to peg 2, using peg 3 as a temporary peg. 

14.7 The Towers of Hanoi 
935 
Move a disk from peg 1 to peg 3. 
Move n - 1 disks from peg 2 to peg 3, using peg 1 as a temporary peg. 
End If 
We will now write a function that implements this solution by printing a sequence of 
moves that solves the game. We will also use names rather than numbers to describe 
the pegs. The object of the function is then to move a stack of disks from a source peg 
(peg 1) to a destination peg (peg 2) using a temporary peg (peg 3). Here is the code for 
the function: 
voi d moveDisks (int n , string 
source, 
string 
dest, 
string 
temp) 
{ 
) 
if(n>O) 
{ 
) 
II Move n -
1 di sks from source to temp 
II using dest as the temporary 
peg 
moveDisks(n -
1, source, 
temp, dest); 
II Move a di sk from source to dest 
cout << "Move a di sk from"<< 
source 
<<"to"<< 
dest << endl; 
II Move n -
1 di sks from temp to dest 
II using source as the temporary 
peg 
moveDisks(n -
1, temp, dest, 
source); 
The base case occurs when n = 0 and there are no disks to be moved . In this case, 
the function call returns without doing anything. The function is demonstrated in 
Program 14-9 . 
Program 14-9 
1 II This program displays 
a solution 
to the Towers of 
2 II Hanoi game. 
3 
4 #include 
<iostream> 
5 using namespace std; 
6 
7 II Function 
prototype 
8 void moveDisks(int, 
string, 
string, 
str i ng); 
9 
10 int main() 
11 { 
12 
13 
14 
15 
II Play the game with 3 disks 
moveDisks (3, "peg 1", "peg 3", "peg 2"); 
cout << "All the disks 
have been moved!" 
16 
return 
O; 
17 ) 
18 
(program continues) 

936 
Chapte r 14 
Recursion 
Program 14-9 
(continued) 
19 //*************************************************** 
20 
21 
22 
23 
24 
25 
26 
II 
II 
II 
II 
II 
II 
II 
The moveDisks funct i on displays 
disk moves used 
* 
to solve the Towers of Hanoi game. 
* 
The parameters 
are: 
* 
n 
The number of disks 
to move. 
* 
source 
The peg to move from. 
* 
dest 
The peg to move to. 
* 
temp 
The temporary 
peg. 
* 
27 //*************************************************** 
28 void 
29 moveDi sks(int 
n, str i ng source, 
str i ng dest , string 
temp) 
30 
{ 
31 
i f(n>O) 
32 
{ 
33 
34 
35 
36 
37 
38 
39 
40 
II Move n -
1 di sks from source to temp 
II using dest as the temporary 
peg 
moveDisks(n -
1, source, 
temp, dest); 
II Move a di sk from source to dest 
cout << "Move a disk from"<< 
source 
<<"to"<< 
dest << endl; 
41 
II Move n -
1 di sks from temp to dest 
42 
II using source as the temporary 
peg 
43 
moveDisks(n -
1, temp, dest, 
source ); 
44 
} 
45
} 
Program Output 
Move a disk from peg 1 to peg 3 
Move a disk from peg 1 to peg 2 
Move a disk from peg 3 to peg 2 
Move a disk from peg 1 to peg 3 
Move a disk from peg 2 to peg 1 
Move a disk from peg 2 to peg 3 
Move a disk from peg 1 to peg 3 
All 
the disks 
have been moved! 
<) NOTE: You can find many animat ions on the World Wide Web and on You Tube. 
Type "Towers of Hanoi Animation" into your favorite search engine. 
Focus on Problem Solving: 
Exhaustive and Enumeration Algorithms 
CONCEPT: 
An enumeration algorithm is one that generates all possible combinations 
of items of a certain type; an exhaustive algorithm is one that searches 
through such a set of combinations to find the best one. 

14.8 Focus on Problem Solving: Exhaustive and Enumeration Algorithms 
937 
Many problems can only be solved by examining all possible combinations of items of 
a certain type and then choosing the best one. For example, consider the problem of 
making change for $1 using the U.S. system of coins. A few of the solutions to this 
problem are: 
one dollar coin 
two fifty-cent coins 
four quarters 
one fifty-cent coin and two quarters 
three quarters , two dimes, and one nickel 
In fact, there are 293 ways to make change for $1, so we need to have a systematic 
method for generating them. Suppose we want to make change for a given amount using 
the fewest coins. A strategy for this problem that almost immediately suggests itself is to 
give as many of. the largest coin as possible, then as many of the second largest coin as 
possible, and so on, until you have made change for the complete amount . It turns out 
that for the U.S. system of coins, this procedure, which is called the greedy strategy, always 
finds the best solution. However, the procedure does not work for other systems of coins. 
For example, if there are only three coin sizes, 
1, 20, 25 
and one has to make change for 44 cents, the greedy strategy will give one quarter 
and 19 pennies, for a total of 20 coins . The best solution uses six coins: two 
twenty -cent pieces and four pennies . In general, one would have to try all possible 
ways of making change to determine the best one. An algorithm that searches 
through all possible comb inations to solve a problem is called an exhaustive 
algorithm ; an algor ithm that generates all possible combinations is an enumeration 
algorithm . 
Recursive techniques are often useful in exhaustive and enumeration algorithms . In 
this section, we look at a recursive algorithm that counts the number of different ways 
to make change for a given amount . With some modification, the algorithm can be 
adapted to keep track of the different combinations and either enumerate the list of all 
such combinations or report which combination is best. Although the algorithm works 
for any system that includes a one-cent piece among its coins, we will assume the 
American system with the six coin values: 1, 5, 10, 25, 50, and 100. 
The main idea is this. Suppose we want to calculate the number of ways to make 
change for 24 cents using coins in the set 1, 5, 10, 25, 50, 100. Since there is no way to 
make change for 24 cents that uses coins in the set 25, 50, 100, the largest usable coin 
is a dime, and we can just calculate the number of ways to make change for 24 cents 
using coins in the set 1, 5, 10. Moreover, we cannot use more than two 10-cent pieces 
in making change for 24 cents, so we only need to count the number of ways to make 
change that use zero, one, or two 10-cent pieces and add them all together to get our 
answer. Table 14-1 lists these possib ilities, shows how each possib ility can be 
decomposed into a smaller problem of the same type, and shows the call to the recursive 
mkChange function that would be invoked to solve the subproblem . The parameters for 
the mkChange function will be explained shortly . 

938 
Chapter 14 
Recursion 
Table 14-1 
number of ways to make 
change for 24 cents using 
no dimes 
number of ways to make 
= 
change for 24 cents using 
coins in the set 1, 5 
= 
mkChange(24,1); 
number of ways to make 
change for 24 cents using 
one dime 
number of ways to make 
= 
change for 14 cents using 
coins in the set 1, 5 
= 
mkChange(14, 1); 
number of ways to make 
change for 24 cents using 
two dimes 
number of ways to make 
= 
change for 4 cents using 
coins in the set 1, 5 
= 
mkChange ( 4, 1 ) ; 
We are now ready to present the implementat ion of the algorithm. The set of possible 
coin values is given by an array 
const i nt coinVa lu es[ ] = {1, 5, 10, 25, 50 , 100}; 
and the algorithm itself is embodied in the recursive function 
i nt mkChange(amount, largestlndex
) 
where the first parameter is the amount to make change for, the second is the index of 
the largest coin in the coi nVa 1 ues array to be used in making that amount, and the 
integer returned is the number of combinations possible to make the specified amount 
of change using the specified maximum coin value. Thu s, the call to make change for 
24 cents using coin values 1, 5 is 
mkChange(24,1); 
In this case, the second parameter 1 is the index of the largest coin to be used, that is, 
the index of the nickel in the coi nVal ues array. Likewise, the call to make change for 
14 cents using the same coin values is 
mkChange ( 14 , 1 ) ; 
Program 14-10 implements this algorithm for the U.S. system of coins. It would work 
for any other coin system by simply changing the coin set size and the values in the 
coi nVal ues array . The algorit hm assumes that the coi nVal ues array lists its values in 
increasing order. 
Notice how the function handles the base case in lines 23-24 . It returns 1 when the amount 
equals 0, so that when the calling function deducts coins that equal the desired amount 
exactly in line 34, nWays will be incremented by 1 in line 38. The function also returns 1 
when largestlndex 
equals Oto indicate that any amount can be composed in just one 
way using pennies (this wouldn't necessarily be true if the smallest coin were not 1). 
Program 14-10 
1 II Thi s program demonstrates 
a recursive 
function 
tha t f i nds 
2 II and counts al l possi ble combinat i ons of coin values t o 
3 II make a specified 
amount of change. 
4 
5 #include 
<iostream> 
6 using namespace std ; 
7 
(program continues) 

14.8 Focus on Problem Solving: Exhaustive and Enumeration Algorithms 
939 
Program 14-10 
(continued) 
8 const 
int COIN_SET_SIZE = 6; 
9 const 
int coinValues[ 
] = {1, 5, 10 , 25, 50, 100}; 
10 
11 //*********************************************************** 
12 II Thi s funct i on returns 
the number of ways to make change 
* 
13 II for an amount if we can only use coinValues 
in the array* 
14 II positions 
O through 
largestlndex 
* 
15 //*********************************************************** 
16 
17 int mkChange(i nt amount, int largestlndex
) 
18 { 
19 
II Don't use coi n values 
bigger 
than amount 
20 
whi le(co i nValues[largestindex] 
> amount} 
21 
largest Index--; 
22 
23 
if (amount= = 0 I I largestlndex 
--
0) 
24 
return 
1; 
25 
26 
II Number of ways to make change for amount 
27 
int nWays = O; 
28 
II Number of coins of largest 
index to use 
29 
int nCoins = 0 ; 
30 
31 
whi le (nCoi ns <= amountlcoinValues[largestindex
] ) 
32 
{ 
33 
int amountleft
; 
34 
amountleft 
= amount - nCoins * coi nValues[largestlndex]; 
35 
36 
II Add the number of ways to make change with nCoins 
37 
II of the largest 
i ndex 
38 
nWays = nWays + mkChange(amountleft, 
largestlndex-1}; 
39 
40 
nCoi ns ++; 
41 
} 
42 
return 
nWays; 
43 } 
44 
45 int main ( } 
46 { 
47 
II Di splay poss i ble coin values 
48 
cout << "Here are the valid 
coi n values, 
in cents: 
"; 
49 
for (int 
index= 
O; index< 
COIN_SET_SIZE; index+ +) 
50 
cout << coinValues[index] 
<<" 
"· 
51 
cout << endl ; 
52 
53 
II Get input from user 
54 
int amount; 
55 
cout << "Enter the amount of cents 
to make change for: 
"· 
56 
cin 
>> amount; 
57 
(program continues) 

940 
Chapte r 14 
Recursion 
Program 14-10 
(continued) 
58 
// Compute and display 
number of ways to make change 
59 
cout << "Number of poss i ble combi nat i ons is" 
60 
<< mkChange(amount, COIN_SET_SIZE-1) 
61 
<< endl; 
62 
return 
O; 
63
} 
Program Output with Example Input Shown in Bold 
Here are the valid 
coin values, 
in cents: 
1 5 10 25 50 100 
Enter 
(as an integer) 
the amount of cents 
to make change for: 
ll[Enter] 
Number of possible 
combinations: 
4 
Focus on Software Engineering: 
Recursion versus Iteration 
CONCEPT: 
Recursion and iteration are equivalent in expressive power. 
Recursion and iteration are equivalent in expressive power in the sense that whatever 
can be done with one can also be done with the other. In any program , any recursive 
function can be replaced with an equivalent function that uses loops and no recursion, 
and converse ly, any function that uses loops can be replaced with an equiva lent 
recursive function that uses no loops. 
In genera l, programs that use recursion incur more overhead than equ ivalent 
programs that use iteration. 
This is because recurs ion typi cally involves the 
making of several function calls . For each such call, the machine must pass 
parameters to the call, keep track of the return address, create the function's local 
variables, and finally, destroy the local variab les when the fuction returns. Current 
computers are fast enough that for many problems people would not notice this 
difference in efficiency between an algorithm that uses recursion and one that 
does not. In such cases, it does not make much difference whether one uses 
recursion or iteration . 
There are, however , some recursive algorithms (like the one used to compute the 
Fibonacci sequence) that in the course of solving a problem recompute solutions to the 
same subprob lems over and over again. Such algorithms tend to be extremely inefficient 
and should always be avoided in favor of iteration. 
In general, recursion should be used whenever the problem has a natural recursive 
solution that does not unnecessarily recompute solutions to subprob lems and the 
equivalent solution based on iteration either is not obvious or is difficult. 

14.10 Tying It All Together: Infix and Prefix Expressions 
941 
14.10 Tying It All Together: Infix and Prefix Expressions 
Table 14-2 
A binary operator is said to be infix if it is written between its operands, as in the expres-
sion x + y. It is said to prefix if it is written before its operands, as in the expression+ x y. 
Finally, it is said to be postfix if it is written after its operands as in x y +. An arithmetic 
expression consisting of numbers, variables, and operators is called infix if it uses only 
infix operators, prefix if it uses only prefix operators, and postfix if all of its operators are 
postfix. Table 14-2 shows the infix, prefix, and postfix forms of five different expressions. 
Infix Expression 
Prefix Expression 
Postfix Expression 
2 
X 
x+2 
X + 23 * y 
(x + 23) ,. y 
2 
2 
X 
X 
+x2 
x2+ 
+ X * 23 y 
X 23 y ,. + 
* + X 23 y 
X 23 + y '' 
An infix expression with more than one operator can be evaluated in different ways yielding 
different results. Consider the expression 2 + 5 ,. 3. If we add before multiplying, the result 
is 21, but if we multiply and then add, we get 17. Infix expressions depend on elaborate 
rules of operator precedence to determine how the expression is evaluated . In addition, 
parentheses must sometimes be used with infix expressions to override the precedence rules. 
Prefix and postfix expressions do not suffer from these drawbacks and need neither 
parentheses nor rules of precedence. Instead, their operators are simply applied in the 
order in which they are encountered . The omission of parentheses allows prefix and 
postfix expressions to be stored in very compact forms, leading to savings in the amount 
of memory used. Because algorithms that work with prefix and postfix expressions do 
not need to process the parentheses or deal with precedence, they are often simpler. 
Most programming languages, however, use infix express ions because that is what 
people are accustomed to. Many compilers and interpreters internally translate infix 
expressions to prefix or postfix so they can take advantage of the resulting efficiencies 
in storage and processing. 
It is useful, when working with prefix expressions, to know they can be defined recursively: 
1. A simple variable such as x, or a number such as 23, is a prefix expression . 
2. Any operator followed by two prefix expressions is a prefix expression . 
Based on this recursive definition, we will develop a strategy for converting a fully 
parenthesized infix expression to its prefix equivalent . First, note that an infix 
expression that involves no operators (it is an ident ifier or a number) is already in 
prefix form, in which case there is nothing to do . Otherwise, place the outermost 
operator of the fully parenthesized infix expression before its operands and then 

942 
Chapte r 14 
Recursion 
recursively apply this strategy to the subexpress ions (the operands of the outermost 
operator). Continue this until all subexpressions have been converted to prefix. Here is 
an example of this process: 
1. Original infix expression is (x + 23)" y. 
2. Place the outermost operator before its operands to give the result ,. (x + 23) y. 
3. Recursively apply the same strategy to the inner subexpression x + 23 by placing+ 
before x and 23 to give the result'' + x 23 y. 
4. Recursively apply the strategy to x, 23, and y. However, these are all base cases so 
they remain unchanged. The procedure terminates with the result ,. + x 23 y. 
Having gained some practice working with prefix expressions, let's write a program 
that reads in prefix expressions, evaluates them, and prints the results. We assume that 
the prefix expressions contain no variables. 
We use a recursive strategy . The base case is when the prefix expression is a single 
number. In that case, we just read the number and return its value. A prefix expression 
that is not a single number must consist of an operator followed by two prefix expressions. 
To evaluate such an expression, we read and store the operator, recursively evaluate the 
two prefix expressions to get two results, and then apply the operator to the two results. 
The recursive function pref i xExpr () shown in Program 14-11 implements this strategy. 
The pref i xExpr () function uses the peek() member function of the i st ream class to 
skip whitespace and locate the beginning of the prefix expression . The peek() function 
returns the next available character from the stream without actually reading it and 
removing it from the stream . We use peek() to ensure that we do not skip a character 
that is part of the expression while we are skipping leading whitespace. We also use the 
peek() function to check if the first nonspace character is a digit: If it is, we know the 
prefix expression is a number, and we read it using the extract ion operator in line 50: 
exprSt ream >> number; 
A nonspace character that begins a prefix expression but is not a digit must be an 
operator. In that case, we read the character using the get () member function in line 42: 
ch= 
exprStream.get(); 
The main function of this program just reads one line at a time, transforms the string 
retrieved into an i st ri ngs t ream object, and calls the prefi xExpr () function . The user 
can enter multiple infix expressions with each expression being entered on its own line. 
The program terminates when the user enters a blank line. 
Program 14-11 
1 // Thi s program evaluates 
prefix 
expressions
. 
2 #include 
<stdlib
.h> 
3 #include 
<str i ng> 
4 #include 
<ss t ream> 
5 #include 
<iostream> 
6 using namespace std; 
7 
8 int prefixExpr(istream 
&exprSt ream); 
//Pro t ot ype 
9 
10 int main() 
(program continues) 

14.10 Tying It All Together: Infix and Prefix Expressions 
94 3 
Program 14-11 
(continued) 
11 { 
12 
string 
input; 
13 
cout << "Enter pref i x expressions 
to evaluate.\n" 
14 
<< "Press 
enter 
after 
each expression,\n" 
15 
<< "and press 
enter 
on a blank line 
to quit.\n\n" 
16 
cout << "Enter a pref i x expression 
to eva l uate: 
"· 
17 
getl i ne(cin, 
input); 
18 
while 
(input.size() 
!= 0) 
19 
{ 
20 
II Convert string 
to istringstream 
21 
i str i ngstream exprStream(input); 
22 
II Evaluate 
the prefix 
express i on 
23 
cout << prefixExpr(exprStream) 
<< endl ; 
24 
II Get next l i ne of input 
25 
cout << "Enter a prefix 
expression 
to evaluate: 
"· 
26 
get li ne(cin, 
i nput); 
27 
} 
28 
return 
O; 
29
} 
30 
31 //*************************************************************** 
32 II Takes an istream 
that 
contains 
a si ngl e prefix 
expression 
p 
33 II and returns 
the integer 
val ue of p 
* 
* 
34 //*************************************************************** 
35 int prefixExpr(istream 
&exprStream) 
36 { 
37 
38 
II Peek at first 
non-space 
character 
in prefix 
expression 
39 
char ch= 
exprStream .peek(); 
40 
whi le (isspace(ch)) 
41 
{ 
42 
43 
44 
} 
45 
ch= 
exprStream.get(); 
II Read the space character 
ch = exprStream.peek(); 
// Peek again 
46 
if (i sdigit(ch)) 
47 
{ 
48 
II The pref i x expression 
is a 
s i ngl e number 
49 
i nt number; 
50 
exprStream 
>> number; 
51 
return 
number; 
52 
} 
53 
else 
54 
{ 
55 
II The pref i x expression 
is an operator 
followed 
56 
II by two prefix 
expressions: 
Compute values 
of 
57 
II the pref i x expressions 
58 
59 
60 
61 
II Read the operator 
ch= 
exprStream.get(); 
(program continues) 

944 
Chapte r 14 
Recursion 
Program 14-11 
(continued) 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
} 
77 } 
// Recursively 
eva l uate the two subexpressions 
i nt value1 = pref i xExpr(exprStream); 
i nt value2 = pref i xExpr(exprStream); 
// Apply the operator 
swi tch(ch) 
{ 
case 
'+': 
return 
val ue1 + value2; 
case 
' _ ,. 
return 
val ue1 - value2; 
case 
' *' . return 
val ue1 * value2; 
case 
' I' : return 
val ue1 I value2; 
defau l t: 
cout 
<< "Bad input expression"; 
exit(1); 
} 
Program Output with Example Input Shown in Bold 
Enter prefix 
expressions 
to evaluate. 
Press enter 
after 
each expression, 
and press 
enter 
on a blank line 
to quit. 
Enter a prefix 
expression 
to evaluate: 
34[Enter] 
34 
Enter a prefix 
expression 
to evaluate: 
+ 23 5[Ent er] 
28 
Enter a prefix 
expression 
to evaluate: 
* +23 5 2[Ent er] 
56 
Enter a prefix 
expression 
to eva 1 uate: [Ent er] 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. What type of recursive function do you think would be more difficult to debug; 
one that uses direct recursion or one that uses indirect recursion? Why? 
2. Which repetition approach is less efficient; a loop or a recursive function? Why? 
3. When should you choose a recursive algorithm over an iterative algorithm? 
4. The _____ 
of recursion is the number of times a function calls itself. 
5. 
recursion is when a function explicitly calls itself. 
6. 
recursion is when function A calls function B, which in turn calls 
function A. 

Predict the Output 
7. What is the output of the following programs? 
A) 
#include 
<iostream> 
using namespace std; 
int func tion (int); 
int main() 
{ 
) 
i nt 
X = 10 ; 
cout << 
function
(x) << end l ; 
return 
O; 
int func tion (int 
num) 
{ 
) 
i f (num <= 0) 
re turn O; 
else 
re turn funct i on( num -
1) + num; 
B) 
#include 
<io st ream> 
using namespace std; 
void function
(in t ); 
int main() 
{ 
) 
i nt 
X = 10 ; 
function(x
); 
return 
O; 
void function
(in t num) 
{ 
} 
if 
(num > 0) 
{ 
} 
for (i nt x = O; x < num; x++) 
cout << '*' 
; 
cout << end l; 
function
(num -
1); 
C) 
#include 
<cstdl i b> 
#i nc l ude <string> 
#i nc l ude <i os t ream> 
using namespace std; 
void function
(st ring str, 
int pos); 
int main(i nt argc, 
char** argv) 
Review Questions and Exercises 
945 

946 
Chapte r 14 
Recursion 
{ 
} 
Soft Skills 
string 
names = "Adam and Eve"; 
function
(names, 0); 
return 
O; 
void function 
(st r i ng str, 
i nt pos ) 
{ 
i f (pos < str.length()) 
{ 
} 
} 
funct i on(str, 
pos+1); 
cout << str [pos]; 
8. Programming is communicat ion; the programmer "explains" to a computer how 
to carry out a task, with the explana tion being the program. Can you thin k of 
any cases where communica ti on directed to people uses direct or indi rect 
recursion? Are there cases where such a use of recurs ion is indispensable? 
Programming 
Challenges 
1. Iterative Factorial 
Write an iterative version (using a loop instead of recursion ) of the facto rial function 
shown in this chap ter. Demons tr ate the use of the function in a program that prints the 
facto rial of a number entered by the user. 
2. Recursive Conversion 
Convert the following function to one that uses recursion. 
voi d s i gn(int 
n) 
{ 
while (n > 0) 
{ 
} 
} 
cout << "No Parking\n"; 
n-- ; 
Demonstrate the function with a driver program. 
3. QuickSort Template 
Create a template version of the quickSort algorithm that will work with any data type 
that overloads the comparison operato rs. Demonstrate the template with a driver 
function. 

a 
VideoNote 
Solving the 
Recursive 
Multip lication 
Problem 
Programming Challenges 
947 
4. Recursive Array Sum 
Write a function that accepts two arguments,, an array of integers, and a number 
indicating the number of elements in the array. Th e function should recursive ly 
calculate the sum of all the numbers in the array. Demonstrate the use of the function 
in a program that asks the user to enter an array of numbers and prints its sum. 
5. Recursive Multiplication 
Write a recursive function that accepts two arguments into the parameters x and y. The 
function shou ld return the value of x times y. Remember, multiplication can be 
performed as repeated addition: 
7*4=4+4+4+4+4+4+4 
6. Recursive Member Test 
Write a recursive Boolean function named i sMember. The function should accept three 
parameters: an array of integers, an integer indicating the number of elements in the array, 
and an integer value to be searched for. The function should return true if the value is 
found in the array or fa l se if the value is not found. Demonstrate the use of the function 
in a program that asks the user to enter an array of numbers and a value to be searched for. 
7. String Reverser 
Write a recursive function that accepts a string as its argumen t and prints the string in 
reverse order. Demonstrate the function in a driver program . 
8. Palindrome Testing 
A palindrome is a string such as "madam", "radar", "dad", and "I", that reads the 
same forwards and backwards. The empty string is regarded as a palindrome. Write a 
recursive function 
bool isPa l indrome(str
i ng st r, i nt lower, 
int upper) 
that returns tru e if and only if the part of the string str in positions l ower through 
upper (inclusive at both ends) is a palindrome . Test your function by writing a main 
function that repeatedly asks the user to enter strings terminated by the ENTER key. 
These strings are then tested for palindromicity . The program terminates when the user 
presses the ENTER key without typing any characters before it. 
9. Ackermann 's Function 
Ackermann's function is a recursive mathematical algorithm that can be used to test 
how well a computer performs recursion . Write a function A (m, n) that solves 
Ackermann's function. Use the following logic in your function: 
If m = 0 t hen 
return 
n + 1 
If n = O t hen 
return 
A(m- 1, 1) 
Otherw i se, 
return 
A(m-1, A(m, n-1 )) 

948 
Chapte r 14 
Recursion 
Test your function in a driver program that displays the following values: 
A(O, 0) A(O, 1) A(l, 1) A(l, 2) A(l, 3) A(2, 2) A(3, 2) 
10. Prefix to Postfix 
Write a prog ram tha t reads prefix express ions and converts them to postfix. Each 
prefix expression shou ld be entered on a separate line. The program should keep 
reading prefix expressions and converting them to postfix until a blank line is entered . 
11. Prefix to Infix 
Write a program that reads prefix expressions and converts them to infix. The infix 
expressions should be fully parenthesized to show the orde r of app lication of the 
operators. Each prefix expression should be entered on a separate line. The program 
should keep reading prefix expressions and converting them to infix until a blank line 
is entered. 
12. Ancestral Trees 
Assume the following arrays are globally defined. 
const st ring people []= 
{"Al" , "Beth", 
"Bob" , "Carol " , "Chuck", 
"Candy", 
"Cain" , "Debbi e " 1 
"Doug", 
"Di ane", 
"Dwayne " , "Delo r es " , "Dwi ght" 
} ; 
const st ring moth er [] = {"Bet h'' 
"Carol" 
"Charit y" 
' 
' 
' "Debbi e " , 
"Di ane", 
"", 
"De l or es" 
} ; 
const st ring fath er [] = {"Bob" 
''Charl ey" 
''Cai n" 
' 
' 
' "Dougl as", 
"Dwayne" , "" 
1 
"Dwight" 
} ; 
const i nt mom[]= 
{ 1 , 3 , 5 , 7 , 9, - 1, 11 , - 1 , - 1 , - 1 , - 1, - 1, - 1}; 
const i nt pop[] = {2, 4, 6 , B, 10 , - 1 , 12 , - 1, - 1, - 1 , - 1 , - 1 , - 1}; 
The peop 1 e array establishes a correspondence between a name and its position in the 
array: Al is assigned the index 0, Beth is assigned the index 1, and so on. The mother 
and f at her arrays specify parental informa tion . Al, who has index 0, has Beth 
(mother[O]} for his mother and Bob (fa the r [Ol) for his father. Similarly, the mother 
and father of Beth are Caro l and Charley, respectively. The mother and father of Candy 
(index 5) are not known, so they are indicated by empty strings. 
The mom and pop arrays give the same informa tion in integer rather than string format. 
Values of - 1 denote unknown information . For examp le, the mother of the person at 
index 4 has index mom [ 4] = 9, and the father has index pop [ 4 ] = 10. 
The ancestral lineage of a person is a list that begins with that person and includes all 
of his or her ancestors. For examp le, the ancestral lineage of Al (index 0) is given by the 
people array, while the ancestral lineage of Cain (index 6) is Cain, Delores, Owi ght. 
Write a function void ancest ors (in t in dex) that prints a list of names that make up 
the ancestral lineage of the person with the given index. 

TOPICS 
15.1 Type Compatibility in Inheritance 
Hierarchies 
15.2 Polymorphism and Virtual Member 
Functions 
15.3 Abstract Base Classes and Pure Virtual 
Functions 
15.4 Focus on Object-Oriented Programming: 
Composition versus Inheritance 
15.5 Secure Encryption Systems, Inc., 
Case Study 
15.6 Tying It All Together: Let's Move It 
Type Compatibility in Inheritance Hierarchies 
CONCEPT: 
Objects of a derived class can be used wherever objects of a base class 
object are expected. 
Hierarchies of Inheritance 
As you learned in Chapter 11, it often makes sense to create a new class based on an 
existing class if the new class is a special version of the existing one. The derived class 
can then itself serve as the base class for other classes, resulting in an inheritance 
hierarchy. For example,in Chapter 11, we used the process of inheritance to create a 
hierarchy of several classes: Perso n, Student , Facul t y, and TFacul t y. The relationship 
of inheritance is normally depicted using rectangles to represent the classes and arrows 
pointing from the derived class to the base class, as shown in Figure 15-1. 
Thi s hierarchy may of course be extended . For example, the Student class might itself 
be used as a base class for two other derived classes, CStudent and RStudent. These 
last two classes might be used to represent a type of student that commutes and another 
type of student that is resident on camp us. 
949 

950 
Chapte r 15 
Figure 15-1 
Polymorphism and Virtua l Functions 
I Person I 
~----'+ 
+.__ 
__ 
~ 
I 
Student 
Faculty 
TFaculty 
Type Compatibility in Inheritance 
Certain type compat ibility relationships hold among different classes in an inheritance 
hierarchy. Because objects in an inheritance hierarchy are commonly accessed through 
pointers, we state these rules in terms of pointers: 
• A derived class pointer can always be assigned to a base class pointer. This means 
that base class pointers can point to derived class objects. 
• A type cast is required to perform the opposite assignment of a base class pointer 
to a derived class pointer. An error may result at run time if the base class pointer 
does not actually point to a derived class object. 
We will use a simple example to show how these rules work with both raw and smart 
pointers. 
class 
Base 
{ 
public: 
int i ; 
Base(int 
k) 
{ i = k; 
} 
} ; 
class 
Derived 
{ 
public: 
doubled
; 
public 
Base 
Derived(int 
k, double g) 
} ; 
Base(k) 
{ d = g; } 
Given these classes, we can have raw and smart pointers to both base and derived class 
objects: 
// Raw pointers 
Base 
*raw_pb = new Base(5); 
Derived *raw_pd = new Derived(6, 
10 .5); 
// Smart pointers 
shared _ptr<Base> 
pb = make_shared<Base>(5); 
shared _ptr<Derived> 
pd= make_shared<Derived>(6, 
10.5 ); 

15.1 Type Compatib ility in Inheritance Hierarchies 
951 
The first rule says we can assign derived class pointers to base class pointers . Thu s we 
can write: 
// Raw pointers 
Base *raw_bp1 = raw_pd; 
Base *raw_bp2 = new Deri ved(?, 
11 .5); 
// Smart pointers 
shared _ptr<Base> pb1 = pd; 
shared _ptr<Base> pb2 = make_shared<Derived>
(7, 11 .5); 
The second rule says we can assign a base class pointer to a derived class pointer if we 
use a type cast. With raw pointers, the app ropriate cast is stat i c_cast. For shared _ptr, 
you must use stati c_poi nter _cast: 
Derived *raw_pd1 = static
_cast<Derived 
*>(raw_pb1); 
shared _ptr<Derived> 
pd1 = stat i c_pointer _cast<Der i ved>(pb1); 
Assuming that the base pointers were previously pointing to derived class objects, these 
assignments will leave pd1 and raw_pd1 pointing to derived class objects . Subsequently, 
you will be able to use those pointers to access derived class members : 
cout << raw_pd1- >d << endl; 
cout << pd1- >d << endl ; 
Consider now a scenario in which a base class pointer that is pointing to a base class 
object is assigned to a derived class pointer using a type cast: 
raw_pd = static
_cast<Derived 
*>(raw_pb); 
pd = static
_pointer _cast<Derived>
(pb); 
Th e statement comp iles correctly, but will cause an error when it is executed. After 
such an assignment, an attempt such as 
cout << raw_pd- >d; 
cout << pd- >d; 
to access Derived class members will fail, because the Base class object pointed to by 
raw_pd (or pd) does not have the membe r d. 
These compatibi lity rules hold even for deep inheritance hierarchies. For example, in 
Figure 15-1 Person is a base class for Faculty which is in turn a base class for TFacul ty. 
You can assign a TFacul ty pointer to a Person pointer: 
TFaculty 
*tF = new TFacul ty (name , di sc ); 
Person *p ; 
p = tF; 
The assignment in the reverse direction, however, requires a type cast: 
tF = static
_cast<TFaculty 
*>(p); 
For the sake of brevity, we omit the smart -pointer version of the above example . Th ese 
concepts are further illustrated in the following program using modified versions of 
classes from Chapter 11. 
Content s of Inheri tance4. h 
1 #include 
<string> 
2 #include 
<memory> 
3 using namespace std ; 

952 
Chapte r 15 
Polymo rphism and Virtua l Functions 
4 
5 enum class 
Disc i pline 
{ ARCHEOLOGY, 
BIOLOGY, COMPUTER
_SCIENCE }; 
6 enum class 
Classif
i cat i on { FRESHMAN, 
SOPHOMORE, 
JUNIOR, SENIOR}; 
7 class 
Person 
8 { 
9 protected: 
10 
str i ng name; 
11 public: 
12 
Person () { set Name ( "") ; } 
13 
Person(const 
string& 
pName) { setName(pName); 
} 
14 
void setName(const 
str i ng& pName) {name= 
pName; } 
15 
str i ng getName() const 
{ return 
name; } 
16 } ; 
17 
18 class 
Student 
19 { 
20 private: 
public 
Person 
21 
Discipl
i ne major; 
22 
shared _ptr<Person> 
adv i sor ; 
23 public: 
24 
Student(const 
string& 
sname, Disc i plined, 
25 
const shared _ptr<Person>& adv) : Person(sname} 
26 
{ 
27 
major= 
d; 
28 
adv i sor= 
adv ; 
29 
} 
30 
void setMajor(Disc
i pline 
d) {major= 
d; } 
31 
Discipl
i ne getMajor() 
const 
{ return 
major; 
} 
32 
void setAdv i sor (shared _ptr<Person> 
p} {advisor= 
p; } 
33 
shared _ptr<Person> 
getAdvisor
() const 
{ return 
adv i sor ; } 
34 } ; 
35 
36 class 
Faculty 
:public 
Person 
37 { 
38 private: 
39 
Discipl
i ne department
; 
40 public: 
41 
Faculty(const 
string& 
fname, Disc i plined) 
42 
{ 
43 
department= 
d; 
44 
} 
Person(fname) 
45 
void setDepartment(Discipline 
d) {department= 
d ; } 
46 
Discipl
i ne getDepartment(} 
const 
{ return 
department; 
} 
47 } ; 
48 
49 class 
TFaculty 
50 { 
51 private: 
52 
str i ng title; 
53 public: 
public 
Faculty 
54 
TFaculty(const 
str i ng& fname, Discipl
i ned, 
string 
t i tle) 
55 
: Faculty(fname, 
d) 
56 
{ 
57 
setTitle(title); 
58 
} 
59 
void setTitle(const 
string& 
title) 
{ this - >title 
= t i tle ; } 

15.1 Type Compatib ility in Inheritance Hierarchies 
953 
60 
61 
// Override 
getName() 
62 
str i ng getName() const 
63 
{ 
64 
65 
66 } ; 
return 
title+• 
• +Per son: :getName(); 
} 
Here are other examp les of assigning derived class pointers to base classes: 
shared _ptr<Person> 
ptp ; 
shared _ptr<TFaculty> 
ptf ; 
// Pointer 
to Deri ved class 
assigned 
to Base class 
pointer 
ptp = make_shared<TFaculty>
(" Indiana 
Jones", 
Disc i pline: :ARCHEOLOGY, 
"Or ."); 
// Assi gning a base class 
pointer 
to a derived 
class 
// pointer 
req ui res a typecast 
ptf = static
_pointer _cast<TFaculty>(ptp}; 
In this section of code, a newly created pointer to an object of the derived class TFacul ty 
is assigned to the base class pointer ptp . That base class pointer is then assigned to ptf 
using a type cast . 
These type compatibi lity rules apply in two othe r cases . A function parameter that is 
declared as a pointer to a base class will accept a pointer to a derived class object . Also, 
a function that declares a return type of a pointer to a partic ular class C may return a 
pointer to on object of a class derived from C. 
Type Casting of Base Class Pointers 
We have seen that a pointer to a particular class may actually be pointing to an object 
of a derived class. In this case, the class type of the pointer will be different from the 
class type of the object . As an example, consider the statement 
shared _ptr<Person> 
pPerson = 
make_shared<Facu lty>("Oona ld Knuth",Oiscipl
i ne: :COMPUTER_SCIENCE
); 
Even though this assignment is legal, the pPerson pointer is not aware of Faculty class 
members other than those inherited from Person. Conseq uently, an attempt to access 
non -inherited members of the Faculty class through pPerson is rejected by the compile r: 
pPerson - >setOepartment(Oiscipl
i ne: :BIOLOGY
); // Error! 
If we do know that pPerson actually points to a Faculty object, we can use a type cast 
to coax the comp iler to accept the statement: 
static
_pointer _cast<Faculty> 
(pPerson } 
- > setOepartment(Oisc
i pline: :BIOLOGY); 
Th e type cast informs the compiler that pPerson is actually pointing to a Faculty 
object . Alternatively, we can first cast pPerson to a pointer to Faculty 
stored in 
pFacul ty and then use that to access Faculty-specific members: 
shared _ptr <Faculty> pFaculty = static_pointe
r_ca st<Faculty>(pPerson); 
pFaculty->setOepa
rtment (Oiscipline
:: BIOLOGY); 
In general, a pointer to a base class that actually points to a derived class object must 
be appropriately cast before the add itional features of the derived class can be used. 

954 
Chapte r 15 
Polymo rphism and Virtual Functions 
Recall from Chapter 11 that a derived class may override member functions that are 
defined in its base class. When a pointer to a base class is being used to access a member 
function that has been overridden by the derived class, the default C++ behavior is to 
use the version of the function that is defined in the class of the pointer rather than in 
the class of the object. For examp le, the code 
shared _ptr<Person> 
pP = 
make_shared<TFacul ty>(" Indiana 
Jones", 
Di sci pl i ne: :ARCHEOLOGY, 
"Dr."); 
sets pP, which is a pointer to the base class Person , to point to a TFacul ty object. Note 
that TFacul ty overr ides the getName function defined in Person. In executing the statement 
cout << pP->getName( ); 
the comp iler is not aware that the actual class type of the object is TFacul ty. The 
comp iler sees the class type of the pointer and assume s that the class type of the object 
is the same as that of the pointer. Th erefore, it calls the version of getName defined in 
the Person class. Program 15-1 illustrates these concepts . 
Program 15-1 
1 II This program demonstrates 
type compatibility 
with i n 
2 II an inher it ance hierarchy. 
3 #include 
"inheritance4.h" 
4 #include 
<iostream> 
5 using 
namespace std; 
6 
7 int 
main() 
8 { 
9 
shared _ptr<Person> 
pp ; 
10 
shared _ptr<Faculty> 
pf; 
11 
shared _ptr<TFaculty> 
ptf ; 
12 
ptf 
= make_shared<TFaculty>("Ind
i ana Jones", 
13 
Disc i pline: 
:ARCHEOLOGY, "Dr."); 
14 
15 
II Calling 
getName through 
a pointer 
to TFaculty 
uses 
16 
II the version 
of getName in TFaculty 
17 
cout << "Get name through 
a pointer 
to TFacu lty: 
"; 
18 
cout << ptf - >getName() 
<< endl; 
19 
20 
II Ass i gnment of derived 
to base needs no cast 
21 
pf = ptf; 
22 
23 
II Calling 
getName through 
a pointer 
to Faculty 
uses the 
24 
II version 
of getName in Faculty 
25 
cout << "Get name through 
a poi nter 
to Faculty: 
"; 
26 
cout << pf->getName(
) << endl; 
27 
28 
II Ass i gnment of derived 
to base needs no cast 
29 
pp= 
ptf; 
30 
31 
II Der i ved class 
members can be accessed 
using 
a cast 
32 
cout << "Get name through 
a cast 
to pointer 
to TFaculty: 
"; 
33 
cout << static
_poi nter _cast<TFaculty> 
(pp) - >getName() 
<< endl; 
(program continues) 

15.2 Polymorphism and Virtual Member Functions 
95 5 
Program 15 -1 
(continued) 
34 
35 
// Ass i gment from base to derived 
needs a cast 
36 
shared _ptr< TFaculty> 
pt f1; 
37 
ptf1 = static
_poi nter _cast<TFaculty>(pp); 
38 
39 
// Access getName through 
a poi nter 
to TFaculty 
40 
cout << "Get name through 
a poi nter 
to TFaculty: 
"; 
41 
cout << pt f1 - >getName(); 
42 
43 
cout << endl; 
44 
return 
O; 
45 ) 
Program Output 
Get name through 
a poi nter 
to TFaculty: 
Dr . Indiana 
Jones 
Get name through 
a poi nter 
to Faculty: 
Ind i ana Jones 
Get name through 
a cast 
to poi nter 
to TFaculty: 
Dr . Ind i ana Jones 
Get name through 
a poi nter 
to TFaculty: 
Dr . Indiana 
Jones 
Polymorphism and Virtual Member Functions 
a 
VideoNot e 
Polymorphism 
CONCEPT
: Virtual functio ns allow the most specific version of a memb er fun ctio n 
in an inh erit ance hierarc hy to be selected for exec uti on . Virtu al 
functions make polymorphi sm possible. 
A piece of code is said to be polymorphic if executing the code with different types of 
data produces different behavior. For example, a function would be called polymorph ic 
if it executes differently when it is passed different types of parameters . 
To illustrate 
polymorphism, 
consider the follow ing program, 
Program 15-2. The 
program creates a vector of (pointers to ) Perso n objects of type Stude nt, Facul t y, 
and TFacul ty . It then prints the names in all the objects using the same code . Because 
a vector can only hold elements of one type, we must use a vector of pointers to the 
base class. 
Program 15 -2 
1 // Thi s exh i bit s t he defaul t non-p olymorp hic behav i or of C++. 
2 #include 
"i nheri t ance4.h" 
3 #include 
<vector> 
4 #include 
<iostream> 
5 using namespace std; 
6 
7 int main () 
8 { 
(program continues) 

956 
Chapte r 15 
Polymorphism and Virtua l Functions 
Program 15 -2 
(continued) 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 } 
// Create a vector 
of pointers 
to Person objects 
vector<shared
_ptr<Person>> 
people 
{ 
make_shared<TFaculty> 
("In diana Jones" , Discipline::ARCHEOLOGY, "Dr."), 
make_shared<St udent> 
("Thomas Cruise", 
Di scipline
: :COMPUTER_SCIENCE, nullptr), 
make_shared<Faculty> 
("J ames Stock", 
Di scipline
: :BIOLOGY
}, 
make_shared<TFaculty> 
("Sha ron Rock" , Di scipline
: :BIOLOGY, "Professor"
), 
make_shared<TFaculty> 
(" Nicole Eweman", Di scipline
::ARCHEOLOGY
, "Dr.") 
} ; 
// Print 
the names of the Person objects 
for (i nt k = O; k <people.size(); 
k++) 
{ 
cout << people[k] - >getName() << endl; 
} 
ret urn O; 
Program Output 
Indiana Jones 
Thomas Cruise 
James Stock 
Sharon Rock 
Nicole Eweman 
Notice that the program calls the Person version of the getNa me function for all objects 
in the array, even though the TFacul ty objects have their own, more specialized 
version. Th is code is obvious ly not polymorphic, for it exec utes the same member 
function for each object, regardless of its type. In other words, it does not behave 
differently for different types of objects . 
To better understand what is happening, we need to take a closer look at each of the 
five calls 
people [k]- >getName() 
used to retrieve the name to be printed. In each of these calls, a pointer peop 1 e [ k] to 
the base class Person is used to invoke the getName funct ion in objects of different 
derived classes. Some of these classes, like TFacul ty, override getName to provide a 
more specialized version of that function. When peopl e[k ] is pointing to a TFaculty 
object, the compiler must choose between the getNa me defined in Person, the class of 
the pointer, and the getNa me defined in TFacul ty, the class that the object actually 
belongs to. The default C++ behavior is to use the class type of the pointer rather than 
that of the object to determine which version of an overridden function to call. 
The scenario of invoking a member function of a derived class object through a base 
class pointer is a common occur rence in object -oriented programming. Let us say that 

15.2 Polymorphism and Virtual Member Functions 
957 
we have a base class B with a member function mfun () and a base class pointer ptr that 
is pointing to an object of a derived class D. 
class 
B 
{ 
public: 
void mfun() 
{ 
cout << "Base class 
vers i on"; 
} 
} ; 
class 
D 
{ 
public: 
public 
B 
void mfun() 
} ; 
{ 
} 
cout << "Derived class 
version"; 
shared _ptr<Base> ptr = make_shared<D> (); 
We want to tell the compi ler that whenever we write 
ptr->mfun () 
the compiler should select the more specialized version of mfun () in the derived class. 
We can do this in C++ by declaring mfun () to be a virtual function in the base class. 
Virtual functions are used in C++ to support polymorphic behavior. Thus, to achieve 
polymorphic behavior for mfun () in the class B and all of its derived classes, we must 
modify the definition of B as follows: 
class 
B 
{ 
public: 
} ; 
vir tual void mfun() 
{ 
cout << "Base class 
vers i on"; 
} 
The virtua l characte ristic is inherited: That is, if a member function of a derived class 
overr ides a virtual function in the base class, then that member function is automat ically 
virtual itself. Thu s, the declaration of mfun as virtua l in B makes mfun virtual in D and 
in all classes derived from D. 
Although it is not necessary, many programmers tag all virtual functions with the key 
word virtual 
to make it easer to identify them. This is good practice, and accordingly, 
the definition of D should be written as follows: 
class 
D: public 
B 
{ 
public: 
vir tual void mfun() 
{ 
} 
} ; 
cout << "Derived class 
version"; 

958 
Chapte r 15 
Polymorphism and Virtual Functions 
In this example, the virtual function has been defined inside the class declaration. If a 
virtual member function is defined outside of the class decla rati on, the virt ual key 
word goes on its declaration inside the class but not on the definition. 
The following program, Program 15-3, is a modification of Program 15-2. In it, the 
getName function 
of the Person 
class has been declared 
virt ual. It includ es 
the i nher i tance5. h file, which is the just the i nheri tance4. h file modified to make 
the getName function in the Person class virtual. 
Program 15 -3 
Contents of I nheri tance5. h 
1 #include 
<str i ng> 
2 #include 
<memory> 
3 using namespace std ; 
4 
5 enum Disc i pline 
{ ARCHEOLOGY
, BIOLOGY, COMPUTER
_SCIENCE }; 
6 enum Classification 
{ FRESHMAN
, SOPHOMORE, 
JUNIOR, SENIOR}; 
7 
8 II The Person cl ass i s modi fied to make getName 
9 II a virtual 
funct i on 
10 class 
Person { 
11 protected: 
12 
str i ng name; 
13 publ i C: 
14 
Person() 
{ setName(""}; 
} 
15 
Person(const 
str i ng& pName) { setName(pName); } 
16 
void setName(const 
string& 
pName) {name= 
pName; } 
17 
18 
II Virtual 
funct i on 
19 
vi rtual 
string 
getName( } const { return 
name; } 
20 }; 
21 
22 class 
Student 
publ i c Person 
23 { 
24 private: 
25 
Di scipline 
major; 
26 
shared _ptr<Person> 
advi sor ; 
27 public: 
28 
Student(const 
string& 
sname, Disciplined
, 
29 
const shared _ptr<Person>& adv} : Person(sname ) 
30 
{ 
31 
major= 
d ; 
32 
advi sor
= adv; 
33 
} 
34 
void setMajor(Discipline 
d) {majo r = d ; } 
35 
Di scipl i ne getMajor () const { return 
major; 
} 
36 
void setAdvisor(const 
shared _ptr<Person>& p) {a dvi sor
= p ; } 
37 
shared _ptr<Person> 
getAdvisor() 
const { return 
advi sor ; } 
38 }; 
39 
40 class 
Faculty 
41 { 
publ i c Person 
(program continues) 

15.2 Polymorphism and Virtual Member Functions 
959 
Program 15 -3 
(continued) 
42 private: 
43 
Di scipl i ne department; 
44 public: 
45 
Faculty(const 
string& 
fname , Disciplined) 
Person(fname) 
46 
{ 
47 
department= 
d; 
48 
} 
49 
void setDepartment(D
i scipline 
d) { department
= d ; } 
50 
Di scipline 
getDepa r t ment () const 
{ return 
department; 
} 
51 } ; 
52 
53 class 
TFaculty 
54 { 
55 private: 
56 
str i ng title; 
57 public: 
public 
Faculty 
58 
TFaculty(const 
string& 
fname, Di sciplined, 
const string& 
title) 
59 
: Faculty(fname, 
d) 
60 
{ 
61 
62 
63 
} 
setTitle(title); 
64 
void setT i t l e (co nst string& 
t i tle) 
{ this - >t i tle 
= t i t l e ; } 
65 
66 
II Virtual 
f unct i on 
67 
vi rtual 
string 
getNa me (} const override 
68 
{ 
69 
return 
title+" 
" + Person : :getName(); 
70 
} 
71 } ; 
Contents of Main Program , pr15-03. cpp 
1 II Thi s program demonsrates 
the polymorph i c behavior 
of C++ . 
2 #include 
"inheritance5.h" 
3 #include 
<vector> 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
II Create 
a vector 
of pointers 
to Person objects 
10 
vector<shared
_ptr<Person>> 
people 
11 
{ 
12 
make_shared<TFaculty> 
13 
("I ndi ana Jo nes ", Discipl i ne: :ARCHEOLOGY, "Dr . "}, 
14 
make_shared<Student> 
15 
("Thomas Crui se", 
Discipline: 
:COMPUTER
_SCIENCE, nullptr), 
16 
make_shared<Faculty> 
17 
("Ja mes Stock ", Di sci pl i ne: : BIOLOGY) , 
18 
make_shared<TFaculty> 
19 
("Sharon Rock", Discipline::BIOLOGY, 
"Professo r"), 
20 
make_shared<TFaculty> 
21 
("Ni cole Eweman", Discipl i ne: :ARCHEOLOGY, "Dr . "} 
22 
} ; 
(program continues) 

960 
Chapter 15 
Polymorphism and Virtual Functions 
Program 15 -3 
23 
(continued) 
24 
II Print 
the names of the Person obje cts 
25 
for (i nt k = O; k < peopl e .size( ); k++) 
26 
{ 
27 
cout << people[k ]- >getName() << endl; 
28 
} 
29 
return 
O; 
30
} 
Program Output 
Dr. Indiana Jones 
Thomas Cruise 
James Stock 
Professor 
Sharon Rock 
Dr. Nicole Eweman 
Dynamic and Static Binding 
The compiler is said to bind the name of a function when it selects the code that should 
be executed when the function name is invoked. In other words, the compiler binds the 
name to a function definition when the function is called. 
Static binding happens at compile time and binds the name to a fixed function 
definition, which is then executed each time the name is invoked . For example, in 
Program 15-2 of the previous section, the comp iler used static binding to bind 
getName in the statement 
for (int 
k = O; k < people .size() 
k++} 
{ 
cout << people[k ]- >getName() << endl; 
} 
to the definition of getName in the Person class. 
In static binding, the compiler uses type information available at compile time. If the 
code is operating on objects of different classes within an inheritance hierarchy, the 
only type information available to the compiler will be the base class pointer type used 
to access all the objects. Consequently, static binding will always use the base class 
version of a member function. 
In contrast, dynamic binding occurs at run time. Dynamic binding works only if the 
comp iler can determine at run time the exact class that a subclass object belongs to. 
The compiler then uses this run-time type information to call the version of the function 
defined in that class. To make dynamic binding possible, the compiler stores run-time 
type information in every object of a class with a virtual function . Dynamic binding 
always uses the version of the member function in the actual class of the object, 
regardless of the class of the pointer used to access the object . 
More information on dynam ic binding and run-time type information can be found in 
Appendix K on the book's companion website. 

15.2 Polymorphism and Virtual Member Functions 
961 
C++ 11 's override 
and final 
Key Words 
C++ 11 introduces the override 
key word to help prevent subtl e erro rs when overr idin g 
virtual functions. For example, can you find the mistake in Program 15-4? 
Program 15-4 
1 II Thi s program has a subtle 
error 
related 
to virtual 
functions. 
2 #include 
<iostream> 
3 #include 
<memory> 
4 
using namespace std; 
5 
6 class 
Base 
7 
8 
publ i c: 
9 
virtual 
void functionA
(int 
arg) 
const 
10 
{ cout << "This is Base:: funct i onA" << endl ; } 
11 
} ; 
12 
13 class 
Deri ved 
14 { 
publ i c Base 
15 
public: 
16 
virtual 
void functionA
(l ong arg) const 
17 
{ cout << "Thi s is Derived: :functionA" 
<< endl ; } 
18 }; 
19 
20 int main() 
21 { 
22 
II Base poi nter 
b points 
to a Derived class 
object
. 
23 
shared _ptr<Base> 
b = make_shared<Der i ved>(); 
24 
II Call virtual 
funct i onA through 
Base pointer. 
25 
b- >funct i onA(99); 
26 
27 
return 
O; 
28 
} 
Program Output 
This is Base::functionA 
In this program, a Base class pointer b is pointing to a Derived class ob ject. Because 
the f unct i onA is virt ual, we expect that the call to f unct i onA through b will call the 
Deri ved class version. Thi s is not the case, however, as you can see from the program's 
output. Th e reason is that the the two functions have different parameter types, so 
fun ct i onA in the Deri ved class does not overr ide funct i onA in the Base class. Th e 
function in the base class takes an i nt argument, but the one in the derived class takes 
a long argument. So, functionA 
in the Derived class merely overloads funct i onA in 
the Base class. 
To make sure that a member function in a derived class overr ides a virtual member 
function in a base class, you can place the overr i de key word just afte r the derived 
class's function prototype (or the function header, if the function is written inline ). Th e 
override 
key word tells the compi ler that the function is supposed to override a 

962 
Chapte r 15 
Polymorphism and Virtual Functions 
function in the base class . It will cause a compi ler error if the function does not actually 
overr ide any functions. Program 15-5 demonstrates how Program 15-4 can be fixed so 
that the Derived class function does in fact override the Base class function . Notice in 
line 16 that we have changed the parameter in the Deri ved class function to int , and 
we have added the override 
key word to the function header. 
Program 15-5 
1 II This program demonstrates 
the override 
keyword. 
2 #include 
<iostream> 
3 #include 
<memory> 
4 using namespace std; 
5 
6 class 
Base 
7 { 
8 
public: 
9 
vi rtual 
void funct i onA(int 
arg) const 
10 
{ cout << "This i s Base: :functionA" 
<< endl; 
} 
11 } ; 
12 
13 class 
Deri ved 
14 { 
publ i c Base 
15 
publ i C: 
16 
vi rtual 
void functionA(int 
arg) const 
override 
17 
{ cout << "This i s Derived: :functionA" 
<< endl; 
} 
18 }; 
19 
20 int main() 
21 { 
22 
II Base pointer 
b points 
to a Derived class 
object
. 
23 
shared _ptr<Base>b 
= make_shared<Derived>
(}; 
24 
II Call virtual 
funct i onA through 
Base pointer. 
25 
b- >funct i onA(99); 
26 
27 
return 
O; 
28
} 
Program Output 
This is Derived: :functionA 
Preventing 
a Member Function 
from Being Overridden 
In some der ived classes , you might want to make sure that a virtual member function 
cannot be overr idden any further down the class hierarchy . When a member function 
is declared with the final 
key word, it cannot be overr idden in a derived class . Th e 
following member function prototype is an examp le that uses the f i nal key word: 
virtual 
void message () const 
f i nal; 
If a derived class attempts to override a final member function , the compi ler generates 
an error. 

15.3 
15.3 Abst ract Base Classes and Pure Virtua l Func tions 
963 
Abstract Base Classes and Pure Virtual Functions 
CONCEPT: 
Abstract classes and pure virtu al functions can be used to define an 
interface that must be implemented by derived classes. 
It is often convenient to have a base class for an inheritance hierarchy that defines a 
member function that must be implemented in every derived class but cannot be 
implemented by the base class itself because the details needed for a reasonable 
implementation can only be found in the derived classes. If this is the case, the C++ 
language permits the programmer to declare the function a pure virtual function, that is, 
a member function for which the class provides no implementation. The C++ way of 
declaring a pure virtual function is to put the expression = O in the class declaration where 
the body of the function would otherwise have gone. For example, if a member function 
void draw() is being declared pure virtual, then its declaration in its class looks like 
void draw() = 0; 
A pure virtual function is sometimes called an abstract function , and a class with at 
least one pure virtual function is called an abstract class. The C++ compiler will not 
allow you to instantiate an abstract class. Abstract classes can only be subclassed: That 
is, you can only use them as base classes from which to derive other classes. 
A class derived from an abstract class inherits all functions in the base class and will 
itself be an abstract class unless it overrides all the abstract functions it inherits . The 
usefulness of abstract classes lies in the fact that they define an interface that will then 
have to be supported by objects of all classes derived from it. 
You can think of an abstract class as a class that has no instances other than those that 
belong to some subclass. There are many examples of abstract classes in real life. For 
example, in the animal kingdom, the class "Animal" of all animals is an abstract class. 
There are no instances of animals that do not actually belong to some subclass. There are 
animals that are dogs, or chickens, or foxes, but there no animals that are just animals. 
Consider a graphics system that consists of a collection of shapes that must be drawn 
at certain locations on the screen. Each shape object would have some member variables 
to keep track of its position and a member function for drawing the shape at the right 
position . The different shap es suppo rted by the system might include rectang les, 
hexagons, and others . Because a rectangle is a shape and a hexagon is a shape, it makes 
sense to have a Shape class and have both Rectangle and Hexagon be classes derived 
from Shape. The Shape class will have a member function setPosi ti on for setting the 
position of the shape, as well as a member function draw for drawing the shape. 
However, because Shape is an abstract class (there is no shape that is just a "shape"; it 
must be a rectangle, a hexagon, a triangle, or other) the logic for drawing a particular 
shape must be delegated to an appropr iate subclass. Thus, the draw() function cannot 
have an implementation in the Shape class and must be made a pure virtual function. 
Program 15-6 shows a Shape class with two derived classes: Rectangle and Hexagon. 
The class declares a pure virtual function draw() that is implemented by its two subclasses. 
The main function maintains a collection of Shape objects using a vector of pointers. 

964 
Chapte r 15 
Polymorphism and Virtual Functions 
Program 15 -6 
1 II Thi s program demonstrates 
abstract 
base 
2 II class es and pure virtual 
funct i ons. 
3 #include 
<iostream> 
4 #include 
<memory> 
5 #include 
<vector> 
6 using namespace std ; 
7 
8 class 
Shape 
9 { 
10 protected: 
11 
int posX, posY; 
12 publ i C: 
13 
vi rtual 
void draw() const = O; 
14 
void setPosition(int 
pX, int pY) 
15 
{ 
16 
17 
18 
} 
19 } ; 
20 
posX = pX; 
posY = pY; 
21 class 
Rectangle 
22 { 
publ i c Shape 
23 public: 
24 
vi rtual 
void draw() const 
25 
{ 
26 
27 
28 
} 
29 }; 
30 
cout << "Drawi ng rectang le at"<< 
posX <<" 
<< posY << endl ; 
31 class 
Hexagon 
32 { 
publ i c Shape 
33 public: 
34 
vi rtual 
void draw() const 
35 
{ 
36 
37 
38 
} 
39 }; 
40 
cout << "Drawi ng hexagon at"<< 
posX <<" 
<< posY << endl ; 
41 int main() 
42 { 
" 
" 
43 
II Create 
vector 
of poi nters 
to Shapes of various 
types 
44 
vector<shared
_ptr<Shape>> shapes 
45 
{ 
46 
47 
48 
49 
} ; 
make_shared<Hexagon>(}
, 
make_shared<Rectangle>()
, 
make_shared<Hexagon>(} 
50 
II Set positions 
of all the shapes 
51 
int posX = 5 , posY = 15; 
52 
for (i nt k = O; k < shapes.size(); 
k++} 
(program continues) 

15.3 Abstract Base Classes and Pure Virtual Functions 
965 
Program 15-6 
(continued) 
53 
{ 
54 
55 
56 
shapes[k] - >setPosition(posX, 
posY); 
posX += 10; 
posY += 10; 
57 
} ; 
58 
59 
II Draw all 
t he shapes at the i r pos iti ons 
60 
for (i nt j = O; j < shapes.size(); 
j+ +} 
61 
{ 
62 
shapes[j]
- >draw(); 
63 
} 
64 
retur n O; 
65
} 
Program Output 
Drawing 
Drawing 
Drawing 
hexagon at 5 
rectangle 
at 
hexagon at 25 
15 
15 
25 
35 
Program 15-6 affords another demonstration of dynamic binding and polymorphism. 
Consider in particular the statement 
shapes[j
]- >draw(); 
which is executed a number of different times in the loop 
for (i nt j = O; j <s hapes .size(); 
j+ +) 
{ 
shapes[j]
- >draw(); 
} 
The first time the statement is executed, it invokes the draw function on a hexagon 
object, while the second time, it invokes the draw function on a rectangle object . 
Because the two draw functions are in different classes, they produce different behavior. 
Remember the following points about abstract base classes and pure virtual functions: 
• When a class contains a pure virtual function, it is an abstract base class. 
• Abstract base classes cannot be instantiated. 
• Pure virtual functions are declared with the = O notation and have no body 
or definition . 
• Pure virtual functions must be overridden in derived classes that need to be 
instantiated . 
~ 
Checkpoint 
15.1 Explain the difference between static binding and dynamic binding . 
15.2 Are virtua l functions statically bound or dynamically bound? 

966 
Chapte r 15 
Polymorphism and Virtual Functions 
15.3 
What will the following program display? 
#include 
<iostream> 
#include 
<memory> 
using namespace std; 
class 
First 
{ 
protected: 
int a ; 
publ ic : 
First (int 
x = 1 ) { a = x ; } 
int getVal() 
const 
{ ret urn a; } 
} ; 
class 
Second : publ ic First 
{ 
private: 
int b; 
publ ic : 
Second(int 
y = 5) { b = y; } 
int getVal() 
const 
{ ret urn b; } 
} ; 
int mai n(} 
{ 
} 
shared _ptr<F i rst> object1 
= make_shared<First>(}; 
shared _ptr<Second> 
object2 
= make_s hared<Second>(}; 
cout << object1->getVa
l() 
<< endl; 
cout << object2->getVa
l() 
<< endl; 
return 
O; 
15.4 
What will the following program display? 
#include 
<iostrea
m> 
#include 
<memory> 
us i ng namespace std; 
class 
First 
{ 
protected: 
int a ; 
publ ic : 
First (in t x = 1 ) { a = x ; } 
void twist() 
{a*= 
2; } 
int get Val() 
{ twist(}; 
return 
a; } 
} ; 
class 
Second : publ ic First 
{ 
private: 
int b; 
publ ic : 
} ; 
Second(int 
y = 5) { b = y; } 
void twist() 
{ b *= 10 ; } 
int main (} 
{ 
) 
shared _ptr<F i rst> object1 
= make_shared<First>(}; 
shared _ptr<Second> 
object2 
= make_shared<Second>
(); 
cout << object1->getVa
l() 
<< endl; 
cout << object2->getVa
l() 
<< endl; 
return 
O; 

15.3 Abstract Base Classes and Pure Virtual Functions 
967 
15.5 
What will the following program display? 
#include 
<iostream> 
#include 
<memory> 
us i ng namespace std; 
class 
First 
{ 
protected: 
int a ; 
publ ic : 
Fir st (in t x = 1 ) { a = x ; } 
vir tual 
void twist(} 
{a*= 
2 ; } 
int get Val() 
{ twist(); 
return 
a; } 
} ; 
class 
Second : publ ic Fir st 
{ 
private: 
int b; 
publ ic : 
Second(int 
y = 5) { b = y; } 
virtual 
void twist() 
{ b *= 10; } 
) ; 
int main () 
{ 
shared _ptr<F i rst> object1 
= make_shared<First>(); 
shared _ptr<Second> 
object2 
=make_shared<Second>(); 
cout << object1->getVa
l() 
<< endl; 
cout << object2->getVa
l() 
<< endl; 
return 
O; 
) 
15.6 
What will the following program display? 
#include 
<iostream> 
#include 
<memory> 
us i ng namespace std; 
class 
Base 
{ 
protected: 
int baseVar; 
publ ic : 
Base (int val = 2) { baseVar =va l ; } 
int getVar() 
const 
{ ret urn baseVar; 
} 
) ; 
class 
Derived 
{ 
private: 
int deriVar; 
publ ic : 
public 
Base 
Deri ved(int 
val = 100) { deriVar 
= val; 
) 
int getVar() 
const 
{ ret urn deriVar; 
} 
) ; 
i nt main () 
{ 
) 
shared _ptr<Base> 
opt r = make_shared<Derived>(); 
cout << optr->getVar
() << endl ; 
return 
O; 

968 
Chapte r 15 
Member 
Variable 
a 
b 
C 
d 
e 
f 
g 
h 
i 
Polymorphism and Virtual Functions 
15. 7 
How can you tell from looking at a class declaration that a virtual member 
function is pure? 
15.8 What makes an abstract class different from other classes? 
15.9 Examine the following classes. The table lists the variab les that are members of 
the Third class (some are inherited). Complete the table by filling in the access 
specification each member will have in the Thi rd class. Write "inaccessible" if a 
member is inaccessible to the Thi rd class. 
class 
First 
{ 
} ; 
private: 
i nt a ; 
protected: 
doubl e b; 
public: 
long c ; 
class 
Second 
{ 
} ; 
private: 
i nt d ; 
protected: 
doubl e e ; 
public: 
long f; 
protected 
First 
class 
Third 
public Second 
{ 
} 
private: 
i nt g ; 
protected: 
doubl e h; 
public: 
long i ; 
Access Specification 
in Third class 

a 
VideoNot e 
Composition 
versus 
Inheritance 
15.4 Focus on Object -Oriented Programming : Composition versus Inheritance 
969 
Focus on Object-Oriented 
Programming: 
Composition versus Inheritance 
CONCEPT: 
Inheritance should model an "is -a" relation, rather than a "has -a" 
relation, between the derived and base classes. 
Class inheritance in an object-oriented language should be used to model the fact that 
the type of the derived class is a special case of the type of the base class. Actually, a 
class can be considered to be the set of all objects that can be created from it. Because 
the derived class is a special case of the base class, the set of objects that correspond 
to the derived class will be a subset of the set of objects that correspond to the base 
class. Thus, every object of the derived class is also an object of the base class. In other 
words, each derived class object is a base class object. 
Class composition occurs whenever a class contains an object of another class as one of 
its member variables. Composition was discussed in Chapter 11, where it was pointed 
out that composition models a has-a relation between classes. 
Because a derived class inherits all the members of its base class, a derived class 
effectively contains an object of its base class. As a result, it is possible to use inheritance 
where a correct design would call for composition . As an example, consider a program 
that needs to represent data for a person, say the person's name and street address . The 
street address might consist of two lines: 
123 Main Street 
Hometown, 12345 
Now suppose we had a class for representing a street address: 
class 
St re et Address 
{ 
) ; 
private: 
st ring li ne1 , l i ne2; 
public: 
voi d set Li ne1(str
i ng); 
voi d set Li ne2 (str i ng); 
st ring get Li ne1(); 
st ring get Li ne2(); 
Because a person's data has a name and a street address, the proper formulation of a 
class to represent a person's data would use composition in the following way: 
class 
PersonData 
{ 
) ; 
private: 
st ring name ; 
St re et Address address; 
public: 

970 
Chapter 15 
Polymorphism and Virtual Functions 
We have left off the rest of the class declaration for PersonDat a because we don't need 
it for our purposes . 
It is possible to define this class using inheritance instead of composition . For example, 
we could define a class PersonData1 as follows: 
class 
PersonData1:p ublic St reetAddress 
{ 
} ; 
private: 
st ring name; 
public: 
While this new definition would compile correctly, it is conceptually the wrong thing 
to do because it regards a person's data as a special kind of St reetAddress, which it is 
not . This type of conceptual error in design can result in a program that is confusing to 
understand and difficult to maintain . It is a good design practice to prefer composition 
to inheritance 
whenever possible. One reason is that inher itance breaks the 
encapsulation of the base class by exposing the base class's protected members to the 
methods of the derived class. 
Let us next consider an examp le where it makes sense to use inheritance rather than 
composition . Suppose that we have a class Dog that represents the set of all dogs . 
Assuming that each Dog object has a member variab le wei ght of type double and a 
member function void bark(), we might have the following class: 
class 
Dog 
{ 
protec t ed: 
double wei ght; 
public: 
Dog(double w) 
{ weight = w; } 
vir t ual void bark(} const 
{ 
cout << "I am dog weighi ng" 
<<we i ght <<" pounds . "<< endl; 
} 
} ; 
The class also has a constructor to allow Dog objects to be initialized . Note that we 
have declared the bark() member function as virtual to allow it to be overridden in a 
derived class. 
Suppose that we need to have a class that represents the set of all sheep dogs. Since 
every sheep dog is also a dog, it makes sense to derive the new SheepDog class from the 
Dog class. That way, a SheepDog object will inherit every member of the Dog class. In 
addition to having every characteristic that every dog has, a sheep dog can be expected 
to have other characteristics peculiar to sheep dogs, for example, an integer member 
numberSheep that indicates the maximum number of sheep the dog is trained to herd. 
In addition, a sheep dog might have a way of barking different from that of a generic 
dog, perhaps one adapted to the tending of sheep. This is accounted for by overriding 
the bark() member function of the Dog class. 

15.4 Focus on Object -Oriented Programming: Composition versus Inheritance 
971 
class 
SheepDog: 
publ i c Dog 
{ 
pr i vate: 
int numberSheep; 
publ ic : 
SheepDog(double 
w, int nSheep) 
{ 
numberSheep = nSheep; 
} 
Dog(w) 
virtual 
void bark() 
const override 
{ 
} 
} ; 
cout << "I am a sheepdog weigh i ng" 
<<weight<<
" pounds \ n and guarding" 
<< numberSheep <<"sheep.
" << endl ; 
To demonstrate this class, we will set up a vector of dogs with some of the dogs in the 
vecto r being sheep dogs . To get around the fact that a vector cannot hold two different 
types, we will use a vector of pointers to Dog. Recall from Section 15.1 that a pointer to 
a base class (in this case, Dog) can point to any der ived class object (in this case, 
SheepDog). We can therefore create a vector of pointers to Dog and have some of those 
pointers point to Dog objects while others point to SheepDog objects: 
vector<shared
_ptr<Dog>> kennel 
{ 
} ; 
make_shared<Dog>(40 .5}, 
make_shared<SheepDog>(45.3
, 50 ), 
make_shared<Dog>(24 .7} 
Finally , we can use a loop to call the bark (}member function of each Dog ob ject in the 
array. 
fo r (i nt k = O; k < kennel.size(); 
k++) 
{ 
} 
cout << k+1 << " : " ; 
kennel[k
]- >bark(); 
Because of polymorphism , and because the bark() 
function was declared virtua l, the 
same line of code inside the loop will call the original bark () function for a regular dog 
but will call the special ized bark (} function for a sheep dog . Th e complete program is 
given in Program 15-7. 
Program 15 -7 
1 // Thi s program demonstrates 
the Is-A 
2 // relation 
in inher i tance. 
3 #include 
<iostream> 
4 #include 
<memory> 
5 #include 
<vector> 
6 using namespace std ; 
7 
8 // Base class 
9 class 
Dog 
(program continues) 

972 
Chapte r 15 
Polymorphism and Virtual Functions 
Program 15 -7 
10 { 
(continued) 
11 protected: 
12 
double wei ght; 
13 
14 
15 
16 
17 
18 
public: 
Dog(double w) 
{ 
weight= 
w; 
) 
vi rtual 
void bark() 
const 
{ 
19 
20 
21 
cout << "I am a dog weigh i ng" 
<<weight<<" 
pounds."<< 
endl; 
22 
23 ); 
24 
) 
25 II 
A SheepDog is a special 
26 class 
SheepDog :pu bl i c Dog 
type of Dog 
int numberSheep; 
public: 
SheepDog(double 
w, 
{ 
int nSheep) 
numberSheep = nSheep ; 
) 
void bark () 
{ 
const override 
Dog(w) 
27 { 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 
cout << "I am a sheepdog wei ghing
" 
<<weight<<" 
pounds \ n and guarding" 
<< numberSheep <<"sheep.
" << endl ; 
40 ) ; 
41 
) 
42 
43 
44 
45 
46 
47 
48 
49 
50 
int main() 
{ 
51 
II Create 
a vector 
of 
dogs 
vector<shared
_ptr<Dog>> kennel 
{ 
) ; 
make_shared<Dog>(40 .5), 
make_shared<SheepDog>(45.3, 
make_shared<Dog>(24 .7) 
50), 
52 
II Walk by each kennel and make the dog bark 
53 
for (i nt k = O; k < kennel .size (); k++) 
54 
{ 
55 
cout << k + 1 << ": "; 
56 
kennel[k]
- >bark(); 
57 
) 
58 
return 
O; 
59
) 
Program Output 
1: I am a dog weighing 40.5 pounds. 
2: I am a sheepdog weighing 45.3 pounds 
and guarding 
50 sheep. 
3: I am a dog weighing 24.7 pounds. 

15.5 Secure Encryption Systems, Inc., Case Study 
9 73 
Inheritance is a better choice than composition in this example, since to use composition 
would be tantamount to saying that a sheep dog has a dog, instead of saying that a 
sheep dog is a dog. 
There is a third relat ionship between classes that some authors talk about: the uses 
implementation of relation. Basically, one class uses the implementation of a second 
class if it calls a member function of an object of the second class. 
How can you know when to use inheritance and when to use composition? Suppose 
that you have an existing class C1 and you need to write a definition for another class 
C2 that will need the services of an associated C1 object . Should you derive C2 from C1, 
or should you give C2 a member variable of type C1? In general, you should prefer 
composit ion to inheritance . To help determine if inheritance may be appropriate , you 
might ask the following questions: 
• Is it natural to think of a C2 object as a special type of C1 object? If so, then you 
should use inheritance . 
• Will objects of class C2 need to be used in places where objects of class C1 are used? 
For example, will they need to be passed to functions that take reference parameters 
of type C1, or pointers to C1? If so, then you should make C2 a derived class of C1. 
Secure Encryption Systems, Inc., Case Study 
Secure Encryption Systems is a recently founded consulting company that advises 
business and corporations on how to protect their data from unauthorized access. The 
company is interested in developing a framework that enables the rapid evaluation and 
testing of different encryption and decryption algorithms to determine their effectiveness 
and the level of security they offer. 
In this section, we will consider the use of virtual functions and abstract classes to build 
application frameworks. An application framework can be regarded as an application 
in skeletal form: it only needs the user to specify the definition of a few functions to 
transform the framework into a useful application. 
Understanding 
the Problem 
In Chapter 9's Tying It All Together section you were introduced to the idea of 
encoding a message so that it could only be read by someone possessing the right 
information to decode it. More formally , encryptio n is the process of transforming 
a message, called plain text, into cipher text, a form that disguises its true mean ing. 
Decryption is the process of reversing the encryption transformation that has been 
performed on a message . Decryption is appl ied to cipher text to yield the original 
plain text . There are many other methods of encrypting text . For example , a simple 
encryption algorithm might encrypt the message by shifting each character forward 
in the alphabet by a fixed number. The message can later be decrypted by shifting 
each character back by the same fixed number. For examp le, the plain -text message 
attack 
at dawn 
might be transformed into the cipher text 
buubdl !bu! ebxo 

974 
Chapter 15 
Polymorphism and Virtual Functions 
A Simple Encryption / Decryption Framework 
To provide a framework for testing encryption and decrypt ion algorithms, we will 
implement a class that provides all the functiona lity needed to test such an algorithm 
but leaves the function that is used to transform the letters unspecified. The framework 
will be realized as a class, and the transformation 
function will be a pure virtu al 
member function of the class. Specific encryption algorithms can then be easily tested 
by forming a derived class of the framework class and overrid ing the virtual 
transformation function . 
We use a really simple character transformation algorithm : It just shifts up the character 
by one in the ASCII code; it does not even wrap around to the beginning of the alphabet 
when it shifts the letters 'z' or 'Z'. The major part of the program is the Encryption class: 
class 
Encryptio n 
{ 
protected: 
ifstream 
inF i l e ; 
ofstream outFile
; 
publ ic : 
) ; 
Encrypt ion(const 
string& inFileName , const str i ng& outFi l eName); 
vir tual 
-Encryption(
); 
II Pure virtual 
function 
vir tual char transform(char 
ch) const = O; 
II Do t he actua l work. 
vir tual void encrypt( ) final; 
This class contains the file objects that will be used to access the input and output files. 
The constr uctor is passed the names of the two files and does the work of opening the 
files. The destructor closes the files. The encrypt function will read characters from the 
input file, call the virtual function t ransform to transform the single character, and 
write the character to the output file. 
Because the transform function is pure virtual, the Encrypt ion class is abstract and 
cannot be instantiated . All a subclass of Encryptio n needs to do is implement a suitable 
t ransform function and pass the filenames as parameters to its base class constr uctor. 
The complete program follows. 
Application frameworks are used in many areas of software development to simplify 
the creation of software. Most application frameworks rely heavily on virtual functions 
and abstract classes. 
Program 15-8 
1 II Thi s program demonstrates 
an application 
2 II of pure vir t ual functions
. 
3 #include 
<iostream> 
4 #include 
<fs t ream> 
5 #include 
<str i ng> 
6 #include 
<cstdl ib> 
7 using namespace std ; 
8 
9 class 
Encryp tio n 
(program continues) 

15.5 Secure Encryption Systems, Inc., Case Study 
975 
Program 15 -8 
(continued) 
10 { 
11 protected: 
12 
ifstream 
inFile; 
13 
ofstream 
outFile
; 
14 publ i C: 
15 
Encryption(const 
string& 
inFileName, 
16 
const string& 
outFileName); 
17 
virtual 
-Encrypt i on(); 
18 
// Pure virtual 
funct i on 
19 
virtual 
char transform
(cha r ch) const 
= O; 
20 
II Do the actual 
work. 
21 
virtual 
voi d encrypt () final; 
22 }; 
23 
24 //***************************************************** 
25 II Constructor 
opens the input and output 
file
. 
* 
26 //***************************************************** 
27 Encryption: 
:Encryption(const 
28 
29 { 
const 
30 
inFile.open(inFileName); 
31 
outFile
.open(outF i leName}; 
32 
if (!i nFile ) 
33 
{ 
string& 
inFileName , 
string& 
outF i leName) 
34 
cout << "The f i le"<< 
inFileName 
35 
<<" 
cannot be opened."; 
36 
exit (1}; 
37 
} 
38 
if (!outFile) 
39 
{ 
40 
cout << "The f i le"<< 
outFileName 
41 
<<" 
cannot be opened."; 
42 
exit (1}; 
43 
} 
44 } 
45 
46 //***************************************************** 
47 //D estructor 
closes 
files
. 
* 
48 //***************************************************** 
49 Encryption: 
:-Encrypt
i on() 
50 { 
51 
inFile.close(}; 
52 
outF i le .close(); 
53 } 
54 
55 //***************************************************** 
56 //Encry pt function 
uses the virtual 
transform 
* 
57 //m ember function 
to transform 
individual 
characters. 
* 
58 //***************************************************** 
59 void Encryption: 
:encrypt() 
60 { 
(program continues) 

97 6 
Chapte r 15 
Polymorphism and Virtual Functions 
Program 15 -8 
(continued) 
61 
char ch; 
62 
char transCh; 
63 
inFile.get(ch); 
64 
whi le (!inFile.fa
i l()) 
65 
{ 
66 
transCh 
= transform(ch); 
67 
outFile.put(transCh); 
68 
inF i le .get(ch); 
69 
} 
70
} 
71 
72 II The subclass 
simply overides 
the virtual 
73 II transformation 
function 
74 class 
Si mpleEncryption 
: public 
Encrypt i on 
75 { 
76 public: 
77 
char transform(char 
ch) const override 
78 
{ 
79 
return 
ch + 1; 
80 
} 
81 
SimpleEncryption(const 
string& 
inFileName, 
82 
const string& 
outFileName) 
83 
: Encryption(inFileName, 
outF i leName) 
84 
{ 
85 
} 
86 }; 
87 
88 int main() 
89 { 
90 
string 
inF i leName, outF i leName; 
91 
cout << "Enter name of file 
to encrypt: 
"; 
92 
cin >> inF i leName; 
93 
cout << "Enter name of file 
to receive" 
94 
<< "the encrypted 
text: 
"; 
95 
cin >> outFileName; 
96 
SimpleEncryption 
obfuscate(inFileName, 
outFileName); 
97 
obfuscate
.encrypt(); 
98 
return 
O; 
99 } 
15.6 
..i 
Tying It All Together: Let's Move It 
Video game programmers often have to maintain a collection of figures that are 
simultaneous ly moving in various directions on the screen. Let's devise a solution to a 
simplifed version of this problem. We will maintain a collection of geometric shapes 
and simultaneous ly animate those shapes. The functions used to directly access the 
screen and manage the timer are peculiar to Microsoft Windows, but the principles 
used are very general and are applicab le to all operating systems. 
We begin with a class that represents a shape that is able to move in any of eight 
different directions, with each direction being specified by a pair of integer (X, Y) 

Figure 15-2 
15.6 Tying It All Together: Let's Move It 
977 
coordinates. Upward or downward motion is indicated by a Y component of ±1, and 
likewise, motion in a left or rightward direction is indicated by an X component of ±1. 
A value of O for an X or Y coordinate indicates lack of motion in that direction . Thus, 
a value of (0, 1) for (X, Y) indicates motion straight up, a value of (-1, 0) indicates 
motion to the left, and (1, 1) is motion that is simultaneous ly downward and to the 
right. The Shape class can be seen in lines 12- 26 of the ShapeAn i mator. h file. 
The Shape class has a move () function that is pure virtual. This is because a shape is 
moved by erasing it at its current position and redrawing it at a new position, and it is 
not possible to know how to draw a shape without knowing what type of shape it is. 
Our solution for representing the different shapes will use the five classes Shape, 
Compl exShape, Simpl eShape, Box, and Tent. These classes form the inheritance hierarchy 
shown in Figure 15-2. 
Shape 
ComplexShape 
SimpleShape 
Box 
Tent 
The Simp l eShape class represents objects that can be drawn at a given position in a 
specified color. Accordingly, it has member variab les for representing position and 
color and member functions for setting and accessing those values. The Si mp 1 eShape 
class appears in lines 29-4 7 of the ShapeAni mat or. h file. Notice that the Si mp 1 eShape 
class is still abstract because it provides no implementation for the draw() 
method. 
The class does implement the move () method, though. This is because the move () 
method works the same way for all subclasses of SimpleShape: Erase the shape at its 
current position, compute its new position, and draw the shape at the new position. The 
draw () method, however, works differently for each concrete subclass that implements 
it. Because draw() is virtual, the move () method will always call the appropriate version 
of draw(), even when the call to draw() is through a pointer to the abstract class Shape. 
The Box and Tent classes are the concrete classes at the tip of the inheritance hierarchy. 
They define a specific concrete shape and implement the member function draw() that 
draws the shape at its current position using the shape's specified color. The Box class 
defines a rectangular shape by specifying the position of its top left-hand corner together 
with its width and height. The Tent class defines a triangle with a horizontal base whose 
two other sides are equal in length and whose height is half the length of the base. A Tent 
object is specified by giving the position of the left end point of its base together with the 
length of the base. For example, a tent whose base has length 5 would look like this: 
The Box and Tent classes can be seen in Lines 50-69 of ShapeAnimator. 
h. 

978 
Chapte r 15 
Polymorphism and Virtual Functions 
The Comp 1 exShape class provides a mechanism for assembling a collection of simple 
shapes to form a single shape that can be moved using a single command . The class 
maintains a vector of pointers to Shape objects and implements its move () method by 
calling the move () methods of all the Shape objects in its collection . Likewise, Comp 1 exShape 
has a set Direct i on () method that can be used to cause all of its constituent shapes to 
move in the same direction . The class itself is found in lines 73- 80 of the ShapeAni mat or . h 
file, and its move () method is implemented in lines 128- 132 of ShapeAni mator. cpp. 
Contents of SortAn i mator. h 
1 #include 
<iostream> 
2 #include 
<str i ng> 
3 #include 
<vector> 
4 #include 
<memory> 
5 #include 
<wi ndows.h> 
6 using namespace std; 
7 
8 const HAND
LE outHand l e = GetStdHandle(STD _OUTPUT_HAND
LE); 
9 
10 // A shape has a di rection 
and is able to move in that direct i on. 
11 // The move is a virtual 
member funct i on . 
12 cl ass Shape 
13 { 
14 publ i C: 
15 
void setD i rection(
i nt drow, int dcol) 
16 
{ 
17 
dRow = drow; dCol = dcol ; 
18 
} 
19 
void getD i rection(
i nt &drow, int &dcol} const 
20 
{ 
21 
drow = dRow; dcol = dCol ; 
22 
} 
23 
virtual 
void move()= 
O; 
24 private: 
25 
int dCol, dRow; // Di rection 
of moti on 
26 } ; 
27 
28 // A SimpleShape i s drawn at a given position 
in a specified 
col or 
29 cl ass Si mpleShape : publ i c Shape 
30 { 
31 publ ic: 
32 
virtual 
void draw() const = O; 
33 
void getPos i tion(int 
&row, int &col) const 
34 
{ 
35 
row= rowPos; col = colPos; 
36 
} 
37 
void setPos i tion(int 
row, int col) 
38 
{ 
39 
rowPos = row; colPos =co l ; 
40 
} 
41 
void setCo l or(int 
c) {co l or= 
c; } 
42 
int getColor() 
const 
{ return 
color; 
} 
43 
virtual 
void move() override; 
44 private: 
45 
int color; 
46 
int rowPos, col Pos; 

15.6 Tying It All Together: Let's Move It 
979 
47 } ; 
48 
49 II A Box i s 
50 cl ass Box 
51 { 
52 publ ic: 
a rectangular 
type of shape 
public 
SimpleShape 
53 
virtual 
void draw() const overr i de; 
54 
Box (int 
rowPos, int col Pos, int wi dth, 
i nt height); 
55 private: 
56 
int wi dth, 
height; 
57 } ; 
58 
59 II A Tent is an isosceles 
tr i angle whose horizontal 
base has a 
60 II given length 
and whose hei ght is half the length 
of the base . 
61 II The position 
of the triang
l e is the left 
endpoint 
of the base 
62 cl ass Tent : publ ic SimpleShape 
63 { 
64 publ ic: 
65 
virtual 
void draw() const overr i de; 
66 
Tent( i nt baseRowPos, int baseColPos, 
i nt length); 
67 private: 
68 
int length; 
69 } ; 
70 
71 II A ComplexShape is made up of simpler 
shapes . It is represented 
72 II as a vector 
of pointers 
to the si mpler shapes that 
make it up 
73 cl ass ComplexShape : public 
Shape 
74 { 
75 publ ic: 
76 
ComplexShape(const 
vector<shared
_ptr<Shape>>& 
virtual 
void move() override; 
shapeCo l lection); 
77 
78 private: 
79 
vector<shared
_ptr<Shape>>shapes; 
80 } ; 
Contents of ShapeAni mat or . cpp 
1 #include 
"ShapeAnimator .h" 
2 
3 //************************************************************* 
4 II Moves a simple shape one step by erasing 
the shape 
5 II at its 
current 
position, 
chang i ng i ts posit i on, and then 
6 II redraw i ng the shape at its 
new pos i t i on . 
* 
* 
* 
7 //************************************************************* 
8 void SimpleShape: :move() 
9 { 
10 
int dRow, dCol; II Di rection 
of moti on 
11 
int savedColor 
= col or; 
12 
color= 
O; 
II Drawing i n col or O erases 
the shape 
13 
draw(); 
14 
II Compute the new postion 
for the shape by adding a step in 
15 
II the proper direct
i on to the current 
pos i t i on 
16 
getDirection(dRow, 
dCol); 
17 
rowPos += dRow; 
18 
colPos += dCol; 
19 
II Draw the shape at its 
new position 
in its 
specified 
color 
20 
color= 
savedColor; 

980 
Chapte r 15 
Polymorphism and Virtual Functions 
21 
draw(); 
22 } 
23 
24 //*********************************** 
25 II Draws a tent 
at its 
position 
* 
26 //*********************************** 
27 void Tent: :draw() 
const 
28 { 
29 
30 
int 
rowPos, colPos; 
COORD pos; 
31 
int current
l ength = length; 
32 
II Set the color 
attribute 
33 
SetConso l eTextAttr
i bute(outHandle, 
getCo l or()); 
34 
getPosition(rowPos, 
colPos); 
35 
pos.Y = rowPos; pos .X = colPos; 
36 
37 
II Draw the l ines 
that 
form the tent 
beginning 
wi th 
38 
II the base and moving up toward the point 
39 
for (i nt r = O; r <( l ength+ 
1) I 2; r++) 
40 
{ 
41 
SetConso l eCursorPosition(outHand
l e, pos); 
42 
for 
(int 
k = O; k < currentlength; 
k++) 
43 
{ 
44 
45 
} 
cout 
<< "*"· ' 
46 
cout << endl; 
47 
pos.Y -- ; 
48 
pos.X+ +; 
49 
current
l ength -= 2; 
50 
} 
51 
II Restore 
normal attribute 
52 
SetConso l eTextAttr
i bute(outHandle, 
7}; 
53 } 
54 
55 //********************************** 
56 II Draws a box shape 
* 
57 //********************************** 
58 void Box: :draw() 
const 
59 { 
60 
61 
62 
int 
rowPos, colPos; 
COORD pos; 
63 
II Set the color 
attribute 
for the box 
64 
SetConso l eTextAttr
i bute(outHandle, 
getCo l or()); 
65 
getPosition(rowPos, 
colPos); 
66 
pos.X = col Pos; pos .Y = rowPos; 
67 
68 
II Draw the l ines 
that 
make up the box 
69 
for (i nt r = O; r < height; 
r++) 
70 
{ 
71 
72 
73 
74 
75 
76 
77 
SetConso l eCursorPosition(outHand
l e, pos); 
for 
(int 
c = O; c < width; 
c++) 
{ 
} 
cout 
<< "*"· ' 
cout << endl; 
pos.Y+ +; 

15.6 Tying It All Together: Let's Move It 
981 
78 
} 
79 
// Restore 
normal text 
attribute 
80 
SetConsoleTextAttribute(outHand
l e, 7); 
81 } 
82 
83 //*********************************************** 
84 // Constructor 
sets 
the color , pos itio n, and 
85 // di mensions for a box shape , and draws 
86 // the box at its 
initia
l position 
* 
* 
* 
87 //*********************************************** 
88 Box::Box(int 
rowPos , i nt colPos, 
int width , int height} 
89 { 
90 
91 
92 
93 
94 
95 } 
setCo l or(4); 
setPos it ion(rowPos, 
colPos)
; 
th is-> width = wi dth; 
th is->he ight 
= height ; 
draw(}; 
96 //*********************************************** 
97 // Constructor 
sets 
the color 
for a Tent shape , * 
98 // sets 
the posit i on of the tent 
as wel l as the* 
99 // length 
of its 
base and draws i t at it s 
* 
100 // initia
l position 
* 
101 //*********************************************** 
102 Tent: :Tent(int 
baseRowPos, int baseCol Pos, int length) 
103 { 
104 
105 
106 
107 
108 } 
109 
setCo l or(2); 
setPos it ion(baseRowPos, 
baseColPos); 
th is- >length 
= length; 
draw(}; 
110 //******************************************************* 
111 // Constructor 
bui lds complex shape by assembling 
a 
112 // vector 
of constituent 
shapes 
* 
* 
113 //******************************************************* 
114 ComplexShape:: 
115 ComplexShape(const 
vector<shared
_ ptr<Shape>>& 
shapeCo l lection) 
116 { 
117 
for (int 
k = O; k < shapeCollection.size()
; k++) 
118 
{ 
119 
auto p = shapeCo l lection
[k] ; 
120 
shapes.push
_back(p}; 
121 
} 
122 } 
123 
124 //************************************** 
125 // Moves a complex shape by moving the* 
126 // const it uent shapes 
* 
127 //************************************** 
128 voi d Compl exShape: :move(} 
129 { 
130 
for (int 
k = O; k < shapes.size
(); k++) 
131 
shapes [k] - >move(}; 
132 } 

982 
Chapte r 15 
Polymo rphism and Virtua l Functions 
Program 15-9, which follows, illustrates the use of these classes. The program starts out by 
creating two simple shapes, a tent and a box, in lines 5-6 . The box is created near the left 
edge of the screen while the tent is near the bottom edge. In lines 16-22, the program moves 
the box to the right at the same time that it is moving the tent upwards, stopping the motion 
of the two shapes after 14 steps. Lines 25- 30 continue to move the box to the right for 49 
more steps. At that point, lines 31- 38 create a complex shape composed of the tent and the 
box, setting the box to move left and the tent to move down . The complex shape is then 
moved for 13 steps. After that, the box continues to move left for 37 steps (lines 47- 53). 
Program 15 -9 
1 #include 
"ShapeAnimator .h" 
2 int main() 
3 { 
4 
II Create 
a tent 
and a box 
5 
shared _ptr<Tent> 
tent= 
make_shared< Tent>(20, 
10, 13); 
6 
shared _ptr<Box> box= make_shared<Box>(5, 
10, 4, 7); 
7 
8 
II Draw the tent 
and the box 
9 
tent - >draw(); 
10 
box- >draw(); 
11 
12 
13 
14 
15 
II Set direction 
of motion 
tent - >setDirection(
- 1, 0); 
box- >setD i rect i on(O, 1); 
for the two shapes 
II Tent moves stra i ght up 
II Box moves to the right 
16 
II Simultaneously 
move the tent 
and the box 
17 
for (i nt k = O; k < 12; k++) 
18 
{ 
19 
Sleep(75); 
20 
tent - >move(); 
21 
box- >move(); 
22 
} 
23 
box- >move(); tent - >move(); 
24 
25 
II Move the box farther 
to the right 
26 
for (i nt k = O; k < 48; k++} 
27 
{ 
28 
Sleep(75}; 
29 
box- >move(); 
30 
} 
31 
II Create 
a complex shape composed of the tent 
and the box 
32 
vector<shared
_ptr<Shape>> myShapes {tent, 
box}; 
33 
shared _ptr<ComplexShape> 
34 
cS = make_shared<Compl exShape>(myShapes); 
35 
36 
II Set directions 
for the two shapes 
37 
tent - >setDirection(1, 
O}; 
38 
box- >setD i rect i on(O, - 1}; 
39 
II Move the complex shape: 
th i s moves both the 
40 
II tent 
and the box 
41 
for (i nt k = O; k < 12; k++} 
42 
{ 
(program continues) 

Review Questions and Exercises 
983 
Program 5-9 
(continued) 
43 
44 
45 
46 
47 
48 
49 
50 
51 
52 
53 ) 
S1eep(75); 
cS- >move () ; 
) 
II Conti nue moving the box by itse lf 
for (i nt k = O; k < 36; k++) 
{ 
S1eep(75); 
box->move () ; 
) 
return 
O; 
Review Questions and Exercises 
Fill-in-the-Blank 
1. A class that cannot be instantiated is a(n) ___ 
_ 
2. A member function of a class that is not implemented is called a(n) ___ 
_ 
function . 
3. A class with at least one pure virtua l member function is called a(n) ___ 
_ 
class. 
4. In order to use dynamic binding, a member function of a class needs to be declared 
as a(n) ____ 
function. 
5. Static binding takes place at ____ 
time. 
6. Dynamic binding takes place at 
time. 
7. The ability of code to execute differently depending on the type of data is called 
8. A base class pointer needs a(n) ____ 
to be assigned to a derived class pointer. 
9. The is-a relat ion between classes is best implemented using the mechanism of 
class ___ 
_ 
10. The has-a relation between classes is best implemented using the mechanism of 
class ___ 
_ 
11. If every C1 class object can be used as a C2 class object, the relationship between 
the two classes should be implemented using ___ 
_ 
12. A collection of abstract classes defining an app lication in skeletal form is called 
a(n) ___ 
_ 
13. The keyword ____ 
prevents a virtual member function from being overridden. 
14. To have the compi ler check that a virtua l member function in a subclass overrides 
a virtua l member function in the superclass, you sho uld use the keyword 
after the function declaration . 
----

984 
Chapte r 15 
Polymo rphism and Virtua l Functions 
C++ Language Elements 
Suppose that the classes Dog and Cat derive from Animal, which in tum derives from 
Cr eat ur e. Suppose further that pDog, pCat, pAnimal , and pCreatur e are pointers to 
the respective classes . Suppose that Ani mal and Creatur e are both abstract classes. 
15. Will the statemen t 
Animal a; 
compile? 
16. Will the statemen t 
pAni mal = new Cat; 
compile? 
17. Will the statemen t 
pCr eatur e = new Dog; 
compile? 
18. Will the statemen t 
pCat = new Animal ; 
compile? 
19. Rewrite the following two statements to get them to compile correctly. 
pAnimal = new Dog; 
pDog = pAni mal ; 
Algorithm Workbench 
20. Write a C++ class that has an array of integers as a member variable, a pure 
virtual member function 
bool compare (int 
x, i nt y) = O; 
that compares its two parameters and returns a boolean value, and a member function 
voi d sor t () 
that uses the comparison defined by the compare virt ual function to sort the 
array . T he sort function will swap a pair of array elemen ts a [k] and a[ j J if 
compar e (a[k], 
a[ j ] ) 
returns true. Explain how you can use this class to produce classes that sort arrays 
in ascending order and descending orde r. 
Find the Errors 
21. Find all errors in the following fragmen t of code. 
c l ass MyClas s 
{ 
publ i c : 
vi rtu al myFun() = O; 
{ cout << "Hell o";} 
} ; 

a 
VideoNote 
Solving the 
Sequence Sum 
Problem 
Programming Challenges 
985 
Soft Skills 
22. Suppose that you need to have a class that can sort an array in ascending order or 
descending order upon request. If an array is already sorted in ascending or 
descending order, you can easily sort it the other way by reversing it. Now 
suppose you have two different classes that encapsu late arrays. One provides a 
member function to reverse its array, while the other provides a member function 
to sort its array. Can you use multip le inheritance to obtain a quick solution to 
your problem? Should you? Write a coup le of paragraphs explaining whether 
using multiple inheritance will or will not work to solve this problem, and, if it 
can, whether this is a good way to solve the problem. 
Programming 
Challenges 
1. Analy sis of Sorting Algorithms 
Design a class Abst ract Sort that can be used to analyze the number of compar isons 
performed by a sorting algorithm. The class should have a member function compare that 
is capable of comparing two array elements, and a means of keeping track of the number 
of compar isons performed . The class should be an abstract class with a pure virtual 
member function 
voi d so rt(int 
arr [ ] , i nt si ze ) 
which, when overridden, will sort the array by calling the compare function to determine 
the relative order of pairs of numbers. Create a subclass of AbstractSo rt that uses a simple 
sorting algorithm to implement the sort function. The class should have a member function 
that can be called after the sorting is done to retrieve the number of comparisons performed. 
2. Analy sis of Quick sort 
Create a subclass of the Abst rac t Sort class of Programming Challenge 1 that uses the 
Qui cks ort algorithm to implement the sort function. 
3. Sequence Sum 
A sequence of integers such as 1, 3, 5, 7, ... can be represented by a function tha t takes 
a non-negative integer as parameter and returns the corresponding term of the sequence. 
For example, the sequence of odd numbers just cited can be represented by the function 
i nt odd(i nt k) {ret urn 2 * k + 1;} 
Write an abstract class Abstr act Seq that has a pure virtua l member function 
virt ual i nt fun(i nt k) = O; 
as a stand -in for an actual sequence, and two member functions 
voi d pri nt Seq(i nt k, i nt m}; 
i nt sumSeq(in t k, i nt m) 
that are passed two integer parame ters k and m, where k < m. The function pri nt Seq 
will print all the terms f un(k} through fun( m) of the sequence, and likewise, the 
function sumSeq will return the sum of those terms. Demonstrate your Abst ract Seq 
class by creating subclasses tha t you use to sum the terms of at least two different 
sequences. Determine what kind of outpu t best shows off the operat ion of these classes, 
and write a program that produces that kind of output. 

986 
Chapter 15 
Polymorphism and Virtual Functions 
4. Flexible Encryption 
Write a modification of the encryption program of Section 15.5 whose transform 
function uses an integer key to transform the character passed to it. The function 
transforms the character by adding the key to it. The key should be represented as a 
member of the Encryption class, and the class should be modified so that it has a member 
function that sets the encryption key. When the program runs, the main function should 
ask the user for the input file, the output file, and an encryption key. 
Show that with these modifications , the same program can be used for both encryption 
and decryption . 
5. File Filter 
A file filter reads an input file, transforms it in some way, and writes the results to an 
output file. Write an abstract file filter class that defines a pure virtua l function for 
transforming a character. Create one subclass of your file filter class that performs 
encryption , another that transforms a file to all uppercase, and another that creates an 
unchanged copy of the original file. 
The class should have a member function 
void doFil ter(ifstream 
&in, ofstream &out) 
that is called to perform the actual filtering. The member function for transforming a 
single character should have the prototype 
char t ransform(char 
ch) 
The encryption class should have a constructor that takes an integer as an argument 
and uses it as the encryption key. 
6. Removal of Line Breaks 
Create a subclass of the abstract filter class of Programming Challenge 5 that replaces 
every line break in a file with a single space. 
7. Bumper Shapes 
Write a program that creates two rectangular shapes and then animates them. The two 
shapes should start on opposite ends of the screen and then move toward each other. 
When they meet in the middle of the screen, each shape reverses course and moves 
toward the edge of the screen. The two shapes keep oscillating and bouncing off of 
each other in the middle of the screen. The program terminates when the shapes meet 
each other in the middle for the tenth time. 
8. Bow Tie 
In Tying It All Together , we defined a tent to be a certain type of triangu lar shape . 
Define a wedge to be a tent that has been rotated 90 degrees clockwise, and a reverse 
wedge to be a tent rotated 90 degrees counterclockwise . Write a program that creates 
a wedge and a reverse wedge at the left and right edges of the screen, respectively, and 
then moves them toward each other until they meet in the middle. The two shapes 
should form a bow tie when they meet. 

TOPICS 
16.1 Exceptions 
16.5 Introduction to the Standard Template 
Library 
16.2 Function Temp lates 
16.3 Class Templates 
16.4 Class Templates and Inheritance 
Exceptions 
16.6 Tying It All Togethe r: Word 
Transformers Game 
CONCEPT: 
Exceptions are used to signal errors or unexpected events that occur 
while a program is running. 
Error testing is usually a straightforward process involving i f statements or other control 
mechanisms. For example, the following code segment will trap a division-by-zero error 
before it occurs: 
if (denomi nator== 
0) 
cout << "ERROR: Cannot divide 
by zero . \n"; 
else 
quot i ent= 
numerator/ 
denomi nator; 
But what if similar code is part of a function that returns the quotient as in the following 
examp le: 
// An unreliable 
di vis i on function 
double divide
(double numerator, 
double denominator ) 
987 

988 
Chapter 16 
Exceptions, Templates, and the Standard Template Library (STL) 
a 
VideoNot e 
Throwing and 
Handling 
Exceptions 
{ 
} 
if (denominator== 
0) 
{ 
} 
else 
cout << "ERROR: Cannot di vi de by zero. \ n" ; 
re t urn O; 
return 
numerator/ 
denomi nator; 
Functions commonly signal error conditions by returning a predetermined value. In 
this example, the function returns O when division by zero has been attempted. This is 
unreliable , however, because O is a valid result of a division operation. Even though the 
function displays an error message, the part of the program that calls the function will 
not know when an error has occurred . Problems like these require more sophisticated 
error -handling techniques. 
Throwing an Exception 
One way of handl ing complex error conditions is with exceptions. An exception is a 
value or an object that signals an error. When the error occurs, an exception is said to 
be "thrown" 
because control will pass to a part of the program that catches and 
hand les that type of error. For examp le, the following code shows the di vi de function, 
modified to throw an exception when division by zero has been attempted . 
double div i de(double 
numerator, 
double denominator} 
{ 
} 
if (denominator== 
0) 
throw str i ng("ERROR: Cannot divide 
by zero . \n"}; 
else 
return 
numerator/ 
denomi nator; 
The following statement causes the except ion to be thrown. 
throw st ring("ERROR: Cannot divide by zero. \n"); 
The throw key word is followed by an argument , which can be any value. As you will 
see, the type of the argument is used to determine the nature of the error. The function 
above simply throws a string object containing a descriptive error message. 
The line containing a throw statement is known as the throw point . When a throw 
statement is executed, control is passed to another part of the program known as an 
exception handler. 
Handling an Exception 
To hand le an except ion, a program must have a try/catch construct. The genera l format 
of the try/catch construct is 
try 
{ 
} 
// code here calls 
func t ions or object 
member 
// functions 
that might throw an excep t ion. 

16.1 Exceptions 
989 
catch(exception 
parameter) 
{ 
II code here handles the except i on 
} 
II Repeat as many catch blocks as needed . 
T he first part of the constr uct is the try block. Th is starts with the key word try and 
is followed by a block of code executing any statements that might direc tly or indirectly 
cause an except ion to be thrown. T he try block is immediately followed by one or 
more catch blocks, which are the exception handlers. A catch block starts with the key 
word catch, 
followed by a set of parentheses containing 
the declaration 
of an 
exception parameter. For example, here is a try/catch construct that can be used with 
the divide funct ion: 
try 
{ 
} 
quotient= 
div i de(num1, num2); 
cout << "The quotient 
is"<< 
quotient<< 
endl; 
catch 
(string 
exceptionString
) 
{ 
cout << except i onString; 
} 
Because the di vi de function throws an exception whose type is a string, there must be 
an except ion handler that catches a string . The catch block shown catches the error 
message in the exceptionString 
parameter, then displays it with cout . 
Now let's look at an entire program to see how throw, try, and catch work together. 
In the first samp le run of Program 16-1, valid data is given. Thi s shows how the 
program should run with no errors. In the second sample run, a denominator of O is 
given. This shows the result of the exception being thrown. 
Program 16-1 
1 II Thi s program illustrates 
exception 
handling . 
2 #include 
<iostream> 
3 #include 
<str i ng> 
4 using namespace std ; 
5 
6 II Function 
prototype 
7 double divide (double , double ); 
8 
9 int main() 
10 { 
11 
int num1, num2; 
12 
double quotient; 
13 
14 
cout << "Enter two numbers: 
"; 
15 
cin >> num1 >> num2; 
16 
try 
(program continues) 

990 
Chapte r 16 
Exceptions, Templates, and the Standa rd Template Library (STL) 
Program 16-1 
(continued) 
17 
{ 
18 
quotient= 
di vi de(num1, num2); 
19 
cout << "The quotient 
is"<< 
quotient<< 
endl; 
20 
} 
21 
catc h (str i ng exceptionString) 
22 
{ 
23 
cout << except i onStr i ng; 
24 
} 
25 
cout << "End of the program.\ n"; 
26 
return 
O; 
27
} 
28 
29 double divide(double 
numerator, 
double denominator) 
30 { 
31 
if (denominator== 
0) 
32 
throw string("ERROR: 
Cannot di vi de by zero.\
n"); 
33 
else 
34 
return 
numerator/ 
denominator; 
35 } 
Program Output with Example Input Shown in Bold 
Enter two numbers: 
12 2[Enter] 
The quotient 
is 6 
End of the program. 
Program Output with Example Input Shown in Bold 
Enter two numbers: 
12 O[Enter] 
ERROR: Cannot divide 
by zero. 
End of the program. 
As you can see from the second output screen, the exception caused the program to 
jump out of the di vi de function and into the catch block. After the catch block has 
finished, the program resumes with the first statement after the try/catch construct. 
What If an Exception Is Not Caught? 
There are two possible ways for a thrown exception to go uncaught. The first possibility 
is for the program to contain no catch blocks with an exception parameter of the right 
data type. The second possibility is for the exception to be thrown from outside a try 
block. In either case, the exception will cause the entire program to abort execution. 
Object-Oriented 
Exception Handling with Classes 
Now that you have an idea of how the exception mechanism in C++ works, we will 
examine an object-oriented approach to exception handling. Let's begin by looking at 
the I ntRange class: 

Content s of IntRange . h 
1 #ifndef 
INTRANGE_H 
2 #define 
INTRANGE_H 
3 
4 #include 
<iostream> 
5 using namespace std ; 
6 
7 class 
IntRange 
8 { 
9 private
: 
10 
int i nput; 
11 
12 
int lowe r; 
int upper; 
13 pub 1 i C : 
// For user input 
// Lower li mit of 
// Upper li mit of 
14 
15 
// Exception 
cl ass 
cl ass OutOfRange 
range 
range 
16 
{ }; 
// Empty class 
declaration 
17 
18 
19 
// Member f unctions 
IntRange (i nt low , int 
hi gh} 
{ 
20 
lower= 
low ; 
21 
upper
= hi gh; 
22 
} 
23 
int getlnput(} 
24 
{ 
25 
ci n >> inp ut; 
// Constructor 
26 
if 
(i nput< 
lower I I input> 
upper} 
27 
throw OutOfRange(); 
28 
return 
i nput; 
29 
} 
30 } ; 
31 #endif 
16.1 Exceptions 
991 
IntRange is a simp le class whose member function, getlnput
, lets the user enter an 
integer value . Th e value is compared against the member variab les 1 ower and uppe r 
(whic h are initialized by the class constructor) . If the value entered is less than 1 ower or 
greate r than upper, an exception 
is thrown 
indicating 
the value is out of range . 
Otherwise , the value is returned from the function . 
Instead of throwing a string or some value of a primitive type , this function throws an 
exception class. Notice the empty class declaration that appears in the public section: 
class 
OutOfRange 
{ }; 
// Empty class 
declarat
i on 
Notice that the class has no members. Th e on ly important part of this class is its name, 
which will be used by the exception -handling code . Look at the if statement in the 
get i nput function: 
if 
(i nput< 
l ower I I i nput> 
upper ) 
throw OutOfRange(}; 

992 
Chapte r 16 
Exceptions, Templates, and the Standa rd Template Library (STL) 
Th e throw statement's argument, OutOfRange (), causes an instance of the Out Of Range 
class to be created and thrown as an exception . All that remains is for a catch block to 
handle the except ion. Here is an example: 
catch 
(IntRange: :OutOfRange) 
{ 
cout << "That value is out of range.\n"; 
) 
All that must appear inside the catch block's parentheses is the name of the exception 
class. Th e exception class is empty, so there is no need to declare an actua l parameter. 
All the catch block needs to know is the type of the except ion . 
Since the OutOfRange class is declared in the IntRange class, its name must be fully 
qualified with the scope resolution operator. Program 16-2 shows the class at work in 
a driver program. 
Program 16-2 
1 II Thi s program demonstrates 
the use of object-oriented 
2 II except i on hand l i ng. 
3 #include 
<iostream> 
4 #include 
"IntRange.h" 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
IntRange 
range(5, 
10); 
10 
int userValue; 
11 
12 
cout << "Enter 
a value i n the range 5 - 10: "· 
13 
try 
14 
{ 
15 
userValue 
= range .getlnput(); 
16 
cout << "You entered"<< 
userValue 
<< endl; 
17 
} 
18 
catch 
(IntRange: :OutOfRange) 
19 
{ 
20 
cout << "That value i s out of range.\n"; 
21 
} 
22 
cout << "End of the program.\n"; 
23 
return 
O; 
24
} 
Program Output with Example Input Shown in Bold 
Enter a value in the range 5 - 10: 12[Ent er] 
That value 
is out of range. 
End of the program. 
Multiple Exceptions 
The programs we have studied so far test only for a single type of error and throw only 
a single type of exception. In many cases, a program will need to test for several different 

16.1 Exceptions 
993 
types of errors and signal which one has occurred . C++ allows you to throw and catch 
multiple exceptions . The on ly requirement 
is that each different exception be of a 
different type . You then code a separate catch block for each type of exception that 
may be thrown in the try block . 
For example, suppose we wish to expand the IntRange class so that it throws one type 
of exception if the user enters a value that is too low , and another type if the user enters 
a value that is too high . First , we declare two different exception classes , such as 
// Exception 
classes 
class 
Toolow 
{ } ; 
class 
TooHigh 
{ } ; 
An instance of the Toolow class will be thrown when the user enters a low value, and 
an instance of the TooHi gh class will be thrown when a high value is entered . 
Next we modify the getlnpu
t member function to perform the two error tests and 
throw the appropriate exception: 
i f (i nput< 
lower) 
throw Tool ow(); 
else 
if 
(inpu t > upper) 
throw TooHi gh () ; 
The entire modified class , wh ich is named IntRange2 , is shown here: 
Contents of IntRange 2 . h 
1 #ifndef 
INTRANGE2
_H 
2 #define 
INTRANGE2
_H 
3 
4 #include 
<iostream> 
5 using namespace std; 
6 
7 class 
I ntRange2 
8 { 
9 priva t e: 
10 
in t i nput; 
11 
in t lower; 
12 
in t upper; 
13 pub 1 i C: 
14 
// Exception 
15 
class 
Toolow 
16 
{ } ; 
// For user i nput 
// Lower limit 
of 
// Upper limit 
of 
classes 
17 
class 
TooHi gh 
18 
{ } ; 
19 
// Member functions 
range 
range 
20 
I nt Range2( i nt low, i nt high) 
// Const ruc t or 
21 
{ 
22 
lower = low; 
23 
upper= 
high; 
24 
} 
25 
in t getl nput () 

994 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
26 
{ 
27 
ci n >> i nput; 
28 
if (input 
< lower ) 
29 
throw Toolow() ; 
30 
else 
i f (input 
> upper ) 
31 
throw TooHigh (); 
32 
return 
i nput; 
33 
} 
34 } ; 
35 #endif 
Program 16-3 is a simple driver that demonstrates this class . 
Program 16-3 
1 // This program demonstrates 
the IntRange2 class. 
2 #include 
<iostream> 
3 #include 
"IntRange2.h" 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
IntRange2 range(5, 
10); 
9 
int userValue; 
10 
11 
cout << "Enter a value i n the range 5 - 10: "· 
12 
try 
13 
{ 
14 
userValue = range .getlnput(); 
15 
cout << "You entered
"<< 
userValue << endl ; 
16 
} 
17 
catch 
(IntRange2 ::To olow ) 
18 
{ 
19 
cout << "That value is too low. \n"; 
20 
} 
21 
catch 
(IntRange2 ::To oHigh ) 
22 
{ 
23 
cout << "That value is too high. \ n"; 
24 
} 
25 
26 
cout << "End of the program.\n"; 
27 
return 
O; 
28 } 
Program Output with Example Input Shown in Bold 
Enter a value in the range 5 - 10: 3[Enter] 
That value is too low. 
End of the program. 
Extracting Information from the Exception Class 
Sometimes we might want an except ion to pass information 
back to the exception 
handler. For examp le, suppose we would like the IntRange class not only to signal when 

16.1 Exceptions 
995 
an invalid value has been entered, but to pass the value back . This can be accomplished 
by giving the exception class members in which information can be stored . 
IntRange3, our next modification of the IntRange class, again uses a single exception 
class: OutOfRange. This version of OutOfRange, however, has a member variable and a 
constructor that initializes it: 
// Exception 
class 
class 
OutOfRange 
{ public: 
) ; 
i nt value; 
OutOfRange( i nt i ) 
{ value = i ; } 
When we throw this exception, we want to pass the value entered by the user to the 
OutOfRange's constructor. This is done with the following statement: 
throw OutOfRange( i nput); 
This throw statement creates an instance of the OutOfRange class and passes a copy of 
the input variable to the constructor. 
The constructor then stores this number in 
OutOfRange's member variab le value. The class instance carries this member variable 
to the catch block that intercepts the exception. 
Back in the catch block, the value is extracted: 
catch 
(IntRange3::0utOfRange 
ex) 
{ 
) 
cout << "That value"<< 
ex.value 
<<" 
is out of range . \ n" ; 
Notice that the catch block declares a parameter object named ex. This is necessary 
because the exception has a member variab le that we want to examine. The entire 
IntRange3 class is as follows , and Program 16-4 is a driver that demonstrates it. 
Content s of IntRange3. h 
1 #ifndef 
INTRANGE3
_H 
2 #define 
INTRANGE3
_H 
3 
4 #include 
<iostream> 
5 using names pace std; 
6 
7 class 
IntRange3 
8 { 
9 private: 
10 
int i nput; 
II For user input 
11 
int lower; 
II 
Lower limit 
of 
12 
int upper; 
II Upper limit 
of 
13 public : 
14 
II 
Exception 
class 
15 
class 
OutOfRange 
16 
{ 
17 
public: 
range 
range 

996 
Chapte r 16 
Exceptions, Templates, and the Standard Template Library (STL) 
18 
int value; 
19 
OutOfRange (int 
i) 
20 
{ value= 
i; } 
21 
} ; 
22 
II Member functions 
23 
IntRange3 (i nt l ow, i nt high ) 
// Constructor 
24 
{ 
25 
lower= 
low ; 
26 
upper
= hi gh; 
27 
} 
28 
int getlnput() 
29 
{ 
30 
ci n >> i nput; 
31 
if (i nput < lower 11 input > upper) 
32 
throw OutOfRange( i nput); 
33 
return 
i nput; 
34 
} 
35 } ; 
36 #endif 
Program 16-4 
1 II Thi s program demonstrates 
the IntRange3 class. 
2 #include 
<iostream> 
3 #include 
"IntRange3.h" 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
IntRange3 range(5, 
10); 
9 
int userValue; 
10 
11 
cout << "Enter a value i n the range 5 - 10: "· 
12 
try 
13 
{ 
14 
userValue 
= range .getlnput(); 
15 
cout << "You entered
" << userValue 
<< endl ; 
16 
} 
17 
catch 
(IntRange3 ::0 utOfRange ex ) 
18 
{ 
19 
cout << "That value"<< 
ex.va lu e 
20 
<<" 
is out of range . \ n" ; 
21 
} 
22 
cout << "End of the program.\n"; 
23 
return 
O; 
24 } 
Program Output with Example Input Shown in Bold 
Enter a value in the range 5 - 10: 12[Ent er] 
That value 12 is out of range. 
End of the program. 

16.1 Exceptions 
997 
Handling the bad_a 11 oc Exception Thrown by new 
The new operator throws a system-defined exception of type bad_al 1 oc if it is unable to 
allocate the requested storage . For examp le, the following program, Program 16-5 
attempts to allocate an array of two integers using the new operator inside a try block. If 
the allocat ion fails, the resulting bad_al loc exception is caught in the attached catch 
block and the program is terminated with an appropriate error message. If the allocation 
succeeds, the program proceeds to print the two numbers 10 and 20. The bad_all oc 
type is defined in the header file new, which must be included in programs that refer to it. 
Program 16-5 
1 II This program demonstrates 
the use of the bad_alloc 
2 II except i on . 
3 #include 
<iostream> 
4 #include 
<cstdlib> 
5 #include 
<new> 
6 using namespace std; 
7 
8 int main() 
9 { 
1 O 
int 
* p; 
11 
try 
12 
{ 
13 
p = new int[2]; 
14 
p[O] = 10; 
15 
p[1 ] = 20; 
16 
} 
17 
catch(bad _alloc) 
18 
{ 
II Needed to use bad_alloc 
19 
cout << "Memory cannot be allocated."; 
20 
exit(1); 
21 
} 
22 
cout << p[O] <<" 
"<< p[1]; 
23 
return 
O; 
24 } 
Program Output 
10 20 
Unwinding the Stack 
If an except ion is thrown in a try block that has a catch block capable of handling the 
exception, control transfers from the throw point to the catch block . Assuming that the 
catch block executes to completion without throwing further exceptions, returning 
from the function , or terminating the program, execut ion will continue at the first 
statement after the sequence of catch blocks attached to the try block. 
If the function does not contain a catch block capable of handling the exception, contro l 
passes out of the function , and the exception is automatically rethrown at the point of 
the call in the calling function . By this process, an exception can propagate backwards 
along the chain of function calls until the except ion is thrown out of a try block that has 
a catch block that can handle it. If no such try block is ever found, the exception will 

998 
Chapte r 16 
Exceptions, Templates, and the Standa rd Template Library (STL) 
eventually be thrown out of the main function, causing the program to be terminated. 
This process of propagating uncaught exceptions from a function to its caller is called 
unwinding the stack of function calls. 
Rethrowing an Exception 
It is possible for try blocks to be nested. For example, look at this code segment: 
voi d mai n() 
{ 
} 
try 
{ 
doSomethi ng(); 
} 
cat ch(except i on1) 
{ 
Code to hand1e exception 
1 
} 
cat ch(except i on2) 
{ 
Code to hand1e exception 
2 
} 
In this try block, the function doSomet hi ng is called. There are two catch blocks, one 
that handles excep t i on1 and another that handles excep ti on 2. If the doSomethi ng 
function contains a try block, then it is nested inside the one shown . 
With nested try blocks, it is sometimes necessary for an inner exception handler to pass an 
exception to an outer exception handler. Sometimes, both an inner and an outer catch block 
must perform operations when a particular exception is thrown . These situations require 
that the inner catch block rethrow the exception so the outer catch block can catch it. 
A catch block can rethrow an exception with the throw; statement with no parameter. 
For example, suppose the doSomethi ng function (called in the try block above) executes 
code that potentially can throw exce pti on1 or exce pti on3. Suppose we do not want 
to handle the except i on1 error in doSometh ing, but instead want to rethrow it to the 
outer block . The following code segment illustrates how this is done . 
voi d doSomet hing() 
{ 
try 
{ 
Code that can throw exceptions 
1 and 3 
} 
cat ch(except i on1) 
{ 
throw; // Rethrow t he except i on 
} 
cat ch(except i on3) 
{ 
} 
} 
Code to hand1e exception 
3 

16.2 Function Templates 
999 
When the first catch block catches exception1, 
the throw; statement simply throws 
the exception again. The catch block in the outer try/catch construct, in this case the 
one in the mai n function, will then handle the exception. 
~ 
Checkpoint 
16.2 
16.1 What is the difference between a try block and a catch block? 
16.2 What happens if an except ion is thrown but not caught? 
16.3 If multiple exceptions can be thrown, how does the catch block know which 
except ion to catch? 
16.4 
After the catch block has handled the exception, where does program execution 
resume? 
16.5 How can an exception pass information to the exception handler? 
Function Templates 
CONCEPT: 
A function temp late is a "generic" function that can work with different 
data types. Th e programmer writes the specification s of the function but 
substitut es parameters for data types. When the compiler encounters a 
call to the function, it generates code to handl e the specific data type (s) 
used in the call. 
Overloaded functions make programming convenient because only one function name 
must be remembered for a set of functions that perform similar operat ions. Each of the 
functions, however, must still be written individually . For example, consider the following 
overloaded square functions. 
i nt square(int 
number) 
{ 
return 
number* number; 
} 
double square (double number) 
{ 
return 
number* number; 
} 
The only differences between these two functions are the data types of their return 
values and their parameters. In situations like this, it is more convenient to write a 
function template than an overloaded function. Function templates allow you to write 
a single function definition that works with many different data types, instead of 
having to write a separate function for each data type used. 
A function template is not an actual function, but a "mold" the compiler uses to generate one 
or more functions. When writing a function template, you do not have to specify actual types 
for the parameters, return value, or local variables. Instead, you use a type parameter to specify 
a generic data type. When the compiler encounters a call to the function, it examines the data 
types of its arguments and generates the function code that will work with those data types. 

1000 
Chapte r 16 
Exceptions, Templates, and the Standa rd Template Library (STL) 
a 
VideoNot e 
Writing a 
Function 
Template 
Here is a function template for the square function: 
t emplate <class 
T> 
T square( T number) 
{ 
re t ur n number* 
number; 
} 
The beginning of a function template is marked by a template prefix, which begins 
with the key word te mp 1 at e . Next is a set of angled brackets that contain one or more 
generic data types used in the template. A generic data type starts with the key word 
class , followed by a parameter name that stands for the data type. The example just 
given only uses one, which is named T. (If there were more, they would be separated 
by commas.) After this, the function definition is written as usual, except the type 
parameters are substituted for the actual data type names. In the example, the function 
header reads 
T square( T number) 
T is the type parameter , or generic data type. The header defines square as a function 
that returns a value of type T and uses a parameter , number, which is also of type T. 
As mentioned before, the comp iler examines each call to square 
and fills in the 
appropriate data type for T. For example, the following call uses an int argument: 
i nt y, 
X = 4; 
y = square(x); 
This code will cause the compiler to generate the function: 
i nt square(in
t number) 
{ 
re t ur n number* 
number; 
} 
while the statements 
double 
y, d = 6.2 
y = square(d); 
will result in the generation of the function 
double square(double 
number) 
{ 
re t ur n number* 
number; 
} 
Program 16-6 demonstrates how this function template is used. 
Program 16-6 
1 // Thi s program uses a func t ion templa t e . 
2 #include 
<iostream> 
3 #include 
<io manip> 
4 using namespace std; 
(program continues) 

Program 16-6 
5 
(continued) 
6 II Template 
definition 
for sq ua re funct i on 
7 template 
<class 
T> 
8 T square(T 
number ) 
9 { 
10 
ret urn number* 
number; 
11 } 
12 
13 int main() 
14 { 
15 
cout << setprec
i si on(5}; 
16 
17 
II Get an i nteger 
and comput e its 
square 
18 
cout << "Enter an integer: 
"; 
19 
int i Value; 
20 
cin >> iValue; 
21 
22 
II The compil er creates 
int square (i nt ) at the first 
23 
II occurrence 
of a call 
to square with an int argument 
24 
cout << "The square 
is"<< 
square( i Value); 
25 
26 
II Get a double and comput e its 
square 
27 
cout << "\nEnter 
a double : "; 
28 
double dValue; 
29 
cin >> dValue; 
30 
16.2 Function Templates 
1001 
31 
II The compil er creates 
double square(double)at 
the first 
32 
II occurrence 
of a call 
to square with a double argument 
33 
cout << "The square 
is"<< 
square (dVal ue } << endl ; 
34 
35 
return 
O; 
36 
} 
Program Output with Example Input Shown in Bold 
Enter an integer: 
3[Enter] 
The square 
is 9 
Enter a double: 
8.3[Enter] 
The square 
is 68.89 
0 
NOTE: 
All type parameters defined in a funct ion template must appear at least 
once in the function parameter list. 
Since the comp iler encounte red two calls to square in Program 16-6, each with different 
parameter types, it generated the code for two instances of the function: one with an 
int parameter and int return type, the othe r with a doub 1 e parameter and doub 1 e 
return type. Thi s is illustrated in Figure 16-1. 

1002 
Chapte r 16 
Exceptions, Templates, and the Standa rd Template Library (STL) 
Figure 16-1 
<) 
Function calls 
int X = 4, y; 
y = square(x); 
double x = 12.5 , y; 
y = square(x); 
Function template 
template <class T> 
T square(T number) 
( 
ret urn number• number; 
} 
Template-generated function code 
int square(int number) 
( 
ret urn number • number; 
} 
double square(double number) 
{ 
return number• number ; 
} 
Notice in Program 16-6 that the template appears before all calls to square. As with 
regular functions, the comp iler must already know the template's contents when it 
encounters a call to the template function. Templates, therefore, should be placed near 
the top of the program or in a header file. 
NOTE: A function template is merely the specification of a function and by itself 
does not cause memory to be used. An actual instance of the function is created in 
memory when the comp iler encounters a call to the template function. 
The swap Function Template 
In many applications, there is a need for swapping the contents of two variables of the 
same type. For examp le, while sorting an array of integers, there would be a need for 
the function 
voi d swap(int &a, i nt &b) 
{ 
) 
i nt t emp= a; 
a= 
b; 
b = t emp; 
whereas while sorting an array string objects, there would be a need for the function 
voi d swap(s t ring &a, st ring &b) 
{ 
) 
str i ng temp= a; 
a= 
b; 
b = t emp; 
Because the only difference in the coding of these two functions is the type of the variables 
being swapped, the logic of both functions and all others like them can be captured with 
one template function: 
t emplate<class 
T> 
voi d swap(T &a, T &b) 

{ 
} 
T temp = a; 
a= 
b; 
b = temp; 
16.2 Function Templates 
100 3 
Such a template function is available in the libraries that come with standard C++ compilers. 
The function is declared in the algorithm header file. Program 16-7 demonstrates the use 
of this library template function to swap the contents of pairs of variables. 
Program 16-7 
1 II Thi s program demonstrates 
the use of the swap 
2 II function 
template. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 #include 
<algorithm> 
II Needed for swap 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
II Get and swap two chars 
11 
char f i rstChar
, secondChar; 
12 
cout << "Enter two characters: 
"· 
13 
cin >> f i rstChar 
>> secondChar ; 
14 
swap(f i rstChar
, secondChar}; 
15 
cout << firstChar 
<<" 
"<< secondChar << endl ; 
16 
17 
II Get and swap two ints 
18 
int firstlnt
, secondlnt; 
19 
cout << "Enter two i ntegers: 
"· 
20 
cin >> firstlnt 
>> secondlnt; 
21 
swap(f i rstlnt, 
secondlnt}; 
22 
cout << firstlnt 
<<" 
" << secondlnt 
<< endl ; 
23 
24 
II Get and swap two str i ngs 
25 
cout << "Enter two strings: 
"; 
26 
string 
firstString, 
secondString
; 
27 
cin >> f i rstStr
i ng >> secondString
; 
28 
swap(f i rstString
, secondString); 
29 
cout << firstString 
<<" 
"<< secondString 
<< endl; 
30 
return 
O; 
31 } 
Program Output With Example Input Shown In Bold 
Enter two characters: 
a b[Enter] 
b a 
Enter two integers: 
12 45[Enter] 
45 12 
Enter two strings: 
Ronald Reagan[Enter] 
Reagan Ronald 

100 4 
Chapte r 16 
Exceptions, Templates, and the Standard Template Library (STL) 
Using Operators in Function Templates 
Th e square function template shown earlier in this section applies the operator * to its 
parameter. Th e sq uare template will work correc tly as long as the type of the parameter 
passed to it supp orts the * operato r. For example, it works for numeric types such as i nt, 
1 ong, and doub 1 e because all these types have a multiplication operator *. In addition, the 
square template will wor k with any user-defined class type that overloads the operator *. 
Errors will result if square is used with types that do not supp ort the operato r *. 
Always remember that templates will only work with types that support the operations used by 
the template. For example, a class can only be used with a template that applies the relational 
operators such as <, <=, and != to its type parameter if the class overloads those operators . 
For exam ple, because the string class overloads all the relational operators, it can be used 
with template functions that comp ute the minimum of an array of items. Program 16-8 
illustrates this. 
Program 16-8 
1 II Thi s program i llustr
ates 
the use of function 
templates
. 
2 #include 
<str i ng> 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 II Template for minimum of an array 
7 template 
<class 
T> 
8 T mini mum(T arr( 
], i nt size) 
9 { 
10 
T smallest= 
arr[O J; 
11 
for 
(int 
k = 1; k < s i ze ; k++) 
12 
{ 
13 
if 
(arr[k] 
< smallest) 
14 
smallest
= arr[k]; 
15 
} 
16 
return 
smallest
; 
17 } 
18 
19 int main() 
20 { 
21 
II The compi l er creates 
int minimum(i nt [], 
int) 
22 
II when you pass an array 
of int 
23 
int arr1[] 
= {40, 20 , 35} ; 
24 
cout << "The minimum number is
"<< minimum(arr1, 
3) 
25 
<< endl; 
26 
27 
II The compi l er creates 
string 
mi nimum(string 
[] , int) 
28 
II when you pass an array 
of str i ng 
29 
string 
arr2[ ] = {"Zoe" , "Snoopy ", "Bob", "Wal dorf"}
; 
30 
cout << "The minimum string 
is"<< 
minimum(arr2, 
4) 
31 
<< endl; 
32 
33 
return 
O; 
34 } 
(program continues) 

Program 16-8 
(continued) 
Program Output 
The minimum number is 20 
The minimum string 
is Bob 
Function Templates with Multiple Types 
16.2 Function Templates 
1005 
More than one generic type may be used in a function template. Program 16-9 is an 
example of a function that takes as parameters a list of three values of any printable 
type, prints out the list in order, and then print s out the list in reverse . The type parameters 
for the template function are represented using the identifiers T1, T2, and T3. 
Program 16-9 
1 II Thi s program illustrates 
the use of function 
templates 
2 II with multiple 
types. 
3 #include 
<iostream> 
4 #include 
<str i ng> 
5 using namespace std; 
6 
7 II Template function 
8 template 
<class 
T1, class 
T2, class 
T3> 
9 void echoAndReverse(T1 
a1, T2 a2 , T3 a3) 
10 { 
11 
12 
cout << "Original 
order 
is: 
" 
<< a1 <<" 
'' << a2 <<" 
13 
cout << "Reversed 
order 
is: 
" 
14 
15 } 
16 
<< a3 <<" 
17 int main() 
18 { 
II<< 
a2 << II 
• 
<< a3 << endl; 
• 
<< a1 << endl; 
19 
echoAndReverse("Computer"
, 'A', 
18); 
20 
echoAndReverse("One", 
4, "All"); 
21 
return 
O; 
22 } 
Program Output 
Original 
Reversed 
Original 
Reversed 
<) 
order 
is: 
Computer 
A 18 
order 
is: 
18 A Computer 
order 
is: 
One 
4 
All 
order 
is: 
All 
4 
One 
NO TE: Each type parameter declared in the template prefix must be used somewhere 
in the template definition. 
Overloading with Function Templates 
Function templates may be overloaded. As with regular functions, function templates are 
overloaded by having different parameter lists. For example, there are two overloaded 

1006 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
versions of the sum function in Program 16-10. Th e first version accepts two arguments, 
and the second version accepts three. 
Program 16-10 
1 // Thi s program demonstrates 
an overloaded 
funct i on template. 
2 #include 
<iostream> 
3 using namespace std ; 
4 
5 template 
<class 
T> 
6 T sum(T va11, T va12) 
7 { 
8 
return 
va11 + va12; 
9 } 
10 
11 template 
<class 
T> 
12 T sum(T va11, T va12, T va13) 
13 { 
14 
ret urn val 1 + va12 + va13; 
15 } 
16 
17 int main() 
18 { 
19 
double num1, num2, num3; 
20 
21 
cout << "Enter 
two values: 
". 
' 
22 
cin >> num1 >> num2; 
23 
cout << "Their 
sum i s " << sum(num1, num2} << endl ; 
24 
cout << "Enter 
three 
values: 
". 
' 
25 
cin >> num1 >> num2 >> num3; 
26 
cout << "Their 
sum is 
" << sum(num1, num2, num3) << end l; 
27 
return 
O; 
28 } 
Program Output with Example Input Shown in Bold 
Enter two values: 
12 .5 6 .9[Enter] 
Their sum is 19.4 
Enter three 
va 1 ues: 
45 .76 98 .32 10 .51 [Enter] 
Their sum is 154.59 
Th ere are other ways to perform overloading with function templates as well. For 
examp le, a program might contain a regular (nontemplate) 
version of a function as 
well as a template version . As long as each has a diffe rent parameter list, they can 
coexist as overloaded functions . 
Defining Template Functions 
In defining template funct ions, it may be helpful to start by wr itin g a nontemplate 
version of the function and then converting it to a template after it has been tested. Th e 
convers ion is then achieved by prefixing the function definit ion with an app rop riate 
template header, say 
template 
<class 
T> 
and then systemat ically replacing the relevant type with the generic type T. We followed 
a similar procedure in defining the template for the swap function . 

<) 
16.3 Class Templates 
1007 
NOTE: 
Beginning with C++ 11, you may use the key word t ypename in place of 
class in the template prefix . So the template prefix can be written as templa t e 
<t ypename T>. 
~ 
Checkpoint 
16.6 When does the compiler actually generate code for a function template? 
16.7 The function 
i nt minPosition
(i nt arr ( ], i nt size) 
takes an array of integers of the given size and returns the index of the smallest 
element of the array. Define a template that works like this function but permits as 
parameter arrays of any type that can be compared using the less-than operator <. 
16.8 What must you be sure of when passing a class object to a function template 
that uses an operator, such as * or>? 
16.9 What is a good method for writing a function template? 
Class Templates 
CONCEPT: 
Templates may also be used to create generic classes and abstract data types. 
Function template s are used whenever we need several different functions that have the 
same problem -solving logic, but differ only in the types of the parameter s they work 
with. Class template s can be used whenever we need several classes that only differ in 
the types of some of their data member s or in the types of the parameters of their 
member functions. 
Declaring a class template is similar to declaring a function template: You write the class 
using identifiers such as T, T1, T2 (or whatever other identifier you choose) as generic 
types, and then you prefix the class declaration with an appropriately written template 
header. For examp le, suppose that we wish to define a class similar to the NumberArray 
class studied in Chapter 11, that represents an array of a generic type and adds an 
overloaded operato r [] that performs bounds checking. Calling our class Si mp 1 eVector 
and putting in the appropriate data members and constructors, we arrive at the template: 
templa t e <class T> 
class 
SimpleVector 
{ 
unique _pt r<T (]> aptr ; 
i nt arraySize
; 
public: 
SimpleVect or( i nt); 
SimpleVect or(cons t SimpleVect or &); 
II Const ructor 
II Copy cons t ructor 
i nt size () const { re t urn arraySize
; } 
T &operator []( i nt); 
II Overlo aded [] operator 
voi d print () const; 
II Outputs the array ele ments 
} ; 

1008 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
This class template will store elements of type Tin a dynamica lly generated array. This 
explains why the pointer aptr , which will point to the base of this array, is declared to 
be of type T [] . We have used a unique_ptr for the type of apt r because a Si mp 1 eVector 
object will not share the dynamically allocated array with any other part of the program. 
Likewise, the overloaded array subscription operator returns a value of type T. Notice, 
however, that the value return ed by the size member function and the member 
arrayS i ze are both of type int. This makes sense because the number of elements in an 
array is always an integer, regardless of the type of element the array stores. 
You can think of the Si mp 1 eVector template as a generic pattern that can be specialized 
to create classes of Si mpl eVector that hold doub 1 e, 1 ong, string, or any other type that 
you can define. The rule is that you form the name of such an actual class by appending 
a list of the actual types, enclosed in angled brackets, to the name of the class template: 
• Si mp 1 eVector<doub 1 e> is the name of a class that stores arrays of doub 1 e. 
• Si mpl eVector<stri 
ng> is the name of a class that stores arrays of str i ng. 
• Si mpl eVector<char> is the name of a class that stores arrays of char. 
Here is an example of defining a Si mp 1 eVector object by using the convert constr uctor 
to create an array of 10 elements of type doub 1 e: 
SimpleVector<double> 
dTabl e (10); 
This statement uses the convert constructor to create an array of 10 elements of type doub 1 e. 
Defining a member function of a template class inside the class is straightforward: an 
example is furnished by the definition of size() in the Simpl eVector class. To define a 
member function outside the class, you must prefix the definition of the member function 
with a template header that specifies the list of type parameters, and then within the 
definition, use the name of the class template followed by a list of the type parameters in 
angled brackets whenever you need the name of the class. 
Let us use the operator [ ] function to illustrate the definition of a member function 
outside the class. 
template 
<class T> 
T &SimpleVector<T> : :operator[](int 
sub ) 
{ 
} 
if (sub< 
0 I I sub>= arraySize
) 
throw IndexOutOfRangeException(sub
) 
return 
aptr[sub]
; 
In this definition, the name of the class is needed just before the scope resolution 
operator, so we have Si mpl eVector<T> at that place. As another example, consider the 
definition of the convert constructor: 
template 
<class T> 
SimpleVector<T>: :SimpleVector (i nt s} 
{ 
} 
arraySize 
= s ; 
aptr = make_uni que<T[]>(s}; 
for (int count= 
O; count< 
arraySize
; count+ +) 
aptr[count
] = T(); 

16.3 Class Templates 
1009 
Here, we need to have Simpl eVector<T> before the sco pe resolut ion operator but only 
SimpleVector , without the <T>, after. Th is is because what is needed after the scope 
resolution operator is not the name of the class but the name of a member funct ion, 
which in this case happens to be a constr uctor. 
There is an exception to the rule of attaching the list of type parameters to the name of the 
template class. The list, and the angled brackets that enclose it, can be omitted whenever the 
name of the class is within the scope of the template class. Thus the list can be omitted when 
the name of a class is being used anywhere within the class itself, or within the local scope of a 
member function that is being defined outside of the class. For examp le, the copy constructor 
template 
<class 
T> 
SimpleVector<T>: 
:SimpleVector
(co nst SimpleVector 
&obj ) 
{ 
arraySize 
= obj.arraySize; 
aptr 
= make_unique<T[ J>(arraySize
); 
fo r (in t count
= O; count< 
arraySize; 
count ++) 
aptr[count] 
= obj [count ]; 
) 
does not need to append the <T> to the Si mp l eVector that denotes the type of its argument. 
Th e convert constr uctor for Si mpl eVecto r assumes that the type parameter T has a defau lt 
constr uctor T () when it executes the assignmentaptr [ count ] = T () ; . If T is a primit ive 
type, the C++ compi ler will use the default value of O in place of T (). For example, if T 
were int , the assignment is equivalent to aptr [ count J = i nt() ; and a value of O will be 
stored in apt r[ count ]. 
Th e code for the Si mpl eVector template is listed in the Simpl eVector . h file. 
Content s of Si mpl eVecto r. h 
1 #include 
<iostream> 
2 #include 
<cstdl i b> 
3 #include 
<memory> 
4 using namespace std ; 
5 
6 II Exception 
fo r index out of range 
7 struct 
IndexOutOfRangeExcept
i on 
8 { 
9 
10 
11 } ; 
12 
const 
int 
index; 
IndexO utOfRangeException
(in t ix) 
13 template 
<class 
T> 
14 class 
Si mpleVector 
15 { 
16 
unique _ptr<T []> aptr; 
17 
int arraySize; 
18 public
: 
19 
SimpleVector
(int); 
20 
SimpleVector
(const 
SimpleVector 
&); 
21 
index (ix) 
{} 
22 
23 
int 
si ze () const 
{ return 
arraySize; 
} 
T &operator
[J(in t ); 
II Overloaded[
] operator 
24 
void pr i nt () const; 
II Outputs 
the array 
ele ments 
25 } ; 

1010 
Chapte r 16 
Exceptions, Templates, and the Standard Template Library (STL) 
26 
27 //******************************************************* 
28 II Constructor 
for SimpleVector 
class. 
Sets the size 
29 II of the array 
and al locates 
memory for i t. 
* 
* 
30 //******************************************************* 
31 template 
<class 
T> 
32 SimpleVector<T>::SimpleVector(int 
s) 
33 { 
34 
arraySize 
= s ; 
35 
aptr 
= make_unique<T[]>(s); 
36 
for (i nt count= 
O; count< 
arraySize; 
count ++) 
37 
aptr[count] 
= T(); 
38
} 
39 //****************************************************** 
40 II Copy Constructor 
for SimpleVector 
class
. 
* 
41 //****************************************************** 
42 template 
<class 
T> 
43 SimpleVector<T>::SimpleVector(const 
Si mpleVector &obj) 
44 { 
45 
arraySize 
= obj .arrayS i ze ; 
46 
aptr 
= make_unique<T[]>(arraySize); 
47 
for (i nt count= 
O; count< 
arraySize; 
count ++) 
48 
aptr[count] 
= obj[count]; 
49
} 
50 
51 
52 //******************************************************* 
53 II Overloaded[
] operator. 
The argument is a subscript. 
* 
54 II This function 
returns 
a reference 
to the el ement 
* 
55 II in the array 
indexed by the s ubscr i pt . 
* 
56 //******************************************************* 
57 template 
<class 
T> 
58 T &SimpleVector<T>: :operator
[](in t sub) 
59 { 
60 
if (sub< 
0 I I sub>= 
arraySize) 
61 
throw IndexOutOfRangeExcept i on(sub); 
62 
return 
aptr[sub]; 
63 } 
64 //******************************************************** 
65 II prints 
all 
the entr i es i s the array . 
* 
66 //******************************************************** 
67 template 
<class 
T> 
68 void SimpleVector<T>: :print
() const 
69 { 
70 
for (i nt k = O; k < arraySize; 
k++) 
71 
cout << aptr[k
] <<" 
"· 
72 
cout << endl ; 
73 } 
Program 16-11 demonstrates the SimpleVector template. 

Program 16-11 
1 II Thi s program demonstrates 
the SimpleVector 
template. 
2 #include 
<iostream> 
3 #include 
"SimpleVector.h" 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const i nt SIZE= 10 ; 
9 
10 
SimpleVector<int> 
intTable(SIZE); 
11 
SimpleVector<double> 
doubleTable(SIZE
); 
12 
13 
II Store values 
in the arrays 
14 
for (int 
x = O; x < SIZE; x++) 
15 
{ 
16 
intTable[x] 
= (x * 2); 
17 
doubleTable[x] 
= (x * 2 .14); 
18 
} 
19 
20 
21 
22 
23 
24 
II Display 
the values 
cout << "These values 
intTable.print(); 
cout << "These values 
25 
doubleTable
.print(); 
26 
in the arrays 
are in intTable: 
\n"; 
are in doubleTable:\n"; 
27 
II Use the built -i n + operator 
on array elements 
28 
for (int 
x = O; x < SIZE; x++ ) 
29 
{ 
30 
intTable[x] 
= i ntTable[x] 
+ 5; 
31 
doubleTable[x] 
= doubleTable[x] 
+ 1.5; 
32 
} 
33 
II Di splay the values 
in the array 
34 
cout << "These values 
are in intTable:\n"; 
35 
intTable.print(); 
36 
cout << "These values 
are in doubleTable:\n"; 
37 
doubleTable
.print(); 
38 
39 
II Use the built -i n ++ operator 
on array 
elements 
40 
for (int 
x = O; x < SIZE; x++ ) 
41 
{ 
42 
intTable[x]++; 
43 
doubleTable[x]++; 
44 
} 
45 
II Di splay the values 
in the array 
46 
cout << "These values 
are in intTable:\n"; 
47 
intTable.print(); 
48 
cout << "These values 
are in the doubleTable:\n"; 
49 
doubleTable
.print(); 
50 
cout << endl; 
51 
return 
O; 
52 
} 
16.3 Class Templates 
1011 
(program continues) 

101 2 
Chap ter 16 
Exceptions, Templates, and the Standard Template Library (STL) 
Program 16- 11 
(continued) 
Program Output 
These values 
are in intTable: 
0 2 
4 6 
8 
10 
12 14 
16 
18 
These values 
are in doubleTable: 
0 2.14 
4.28 
6.42 
8.56 
10.7 
12.84 
14.98 
17.12 
19.26 
These 
5 
7 
These 
1. 5 
These 
values 
are 
9 
11 
13 
values 
are 
3.64 
5.78 
values 
are 
in intTable: 
15 17 19 
21 23 
in doubleTable: 
7.92 
10.06 
12.2 
14.34 
16.48 
18.62 
20.76 
in intTable: 
16 
18 20 
22 
24 
These values 
are in the doubleTable: 
6 8 
10 12 
14 
2.5 
4 .64 
6.78 
8.92 
11.06 
13.2 
15.34 
17. 48 
19.62 
21.76 
0 
NOTE: 
The file th at cont ains the templ ate code has been includ ed in th e file that 
contain s the dr iver code to avo id th e compl exities of linking separa tely compi led 
files th at use templ ates. 
Class Templates and Inheritance 
Inh eritance can be appli ed to class templates. For exampl e, in th e follow ing templ ate, 
SearchableVector 
is der ived from th e Simpl eVector class . 
Conte nts of SearchVect . h 
1 #inc l ude "SimpleVector.h" 
2 
3 templ ate <class 
T> 
4 class 
SearchableVector 
5 { 
public 
Simpl eVector<T> 
6 public : 
7 
II Construc t or . 
8 
9 
SearchableVec t or (int s ) 
{ } 
Si mpleVector< T>(s ) 
10 
// Copy constr uctor. 
11 
SearchableVec t or (const Searchab l eVector &); 
12 
// Addi t i onal constructor. 
13 
SearchableVec t or (const Simpl eVector<T> &obj) 
14 
SimpleVec t or< T>(obj ) { } 
15 
in t findl t em(T); 
16 ) ; 
17 
18 //*
* * * ******
* * * * * * * * * ******
* * * * * * * ******
* * * * 
19 // Defi nition 
of the copy constr uctor. 
* 
20 //*
* * * ******
* * * * * * * * * ******
* * * * * * * ******
* * * * 
21 templ ate <class 
T> 
22 Searchab l eVector<T> : : 

16.4 Class Templates and Inheritance 
101 3 
23 SearchableVector(const 
SearchableVector 
&obj) : 
24 
SimpleVector<T>(obj) 
25 { 
26
} 
27 
28 //****************************************** 
29 II findltem 
takes 
a parameter 
of type T 
30 II and searches 
for it wi thin the array. 
* 
* 
31 //****************************************** 
32 template 
<class 
T> 
33 i nt SearchableVector<T>: 
:f i ndltem(T item) 
34 { 
35 
for (int count= 
O; count< 
this - >size(); 
count++) 
36 
{ 
37 
if (this - >operator[](count) 
== item ) 
38 
return 
count; 
39 
} 
40 
return 
- 1; 
41 } 
Let us use this example to take a closer look at the derivation of a class from a template 
base class. First, we have to indicate to the compiler that we are defining a new class 
template based on an another, already existing class template: 
template 
<class 
T> 
class 
SearchableVector 
: public 
SimpleVector<T> 
{ 
II Members of the class 
will 
go here 
} ; 
Here the new class template being defined is Searchabl eVector , while the existing 
base class template is Si mp 1 eVector<T>. The class has three constructors. The first 
constructor, shown here, 
SearchableVector(
i nt size) 
: SimpleVector<T>(size){ 
} 
is designed to dynamically allocate an array of size elements of type T, which it does 
by invoking the base class constructor and passing it the parameter size. 
Thi s 
constructor will create an array of the specified size with all elements initialized to 
default values of type T. The class has another constr uctor, 
SearchableVector(const 
SimpleVector<T> &obj): SimpleVector<T> (obj ){ } 
which takes as parameter a base class object, a copy of which is to be searched. The 
constructor simply passes its parameter to the base class copy constructor. The remaining 
constructor is the copy constructor for the Searchab 1 eVector class, 
SearchableVector(const 
SearchableVector<T> &obj): SimpleVector<T>(obj){ } 
Because the initialization of a Searchab 1 eVector is the same as that of a Si mp 1 eVector, 
the Searchabl 
eVector 
copy constructor simply passes its argument to the copy 
constructor of its base class. The member function f i ndltem takes an item of type T as its 
argument and returns the position of the item within the array. If the item is not found in 
the array, a value of - 1 is returned. 
Program 16-12 demonstrates the class by storing values in two Searchabl eVector 
objects and then searching for a specific value in each. 

1014 
Chapte r 16 
Exceptions, Templates, and the Standard Template Library (STL) 
Program 16-12 
1 // Thi s program demonstrates 
the SearchableVector 
template. 
2 #include 
<iostream> 
3 #include 
"searchvect.h" 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
const i nt SIZE= 10 ; 
9 
SearchableVector<
i nt> intTable(SIZE); 
10 
SearchableVector<double> 
doubleTable(SIZE); 
11 
12 
// Store values 
in the vectors 
13 
for (i nt x = O; x < SIZE; x++) 
14 
{ 
15 
intTable[x] 
= (x * 2); 
16 
doubleTable[x] 
= (x * 2 .14); 
17 
} 
18 
// Display 
the values 
in the vectors 
19 
cout << "These values 
are in intTable:\n"; 
20 
for (i nt x = O; x < SIZE; x++) 
21 
cout << intTable[x
] <<" 
"· 
22 
cout << endl; 
23 
cout << "These values 
are in doubleTable:\n"; 
24 
for (i nt x = O; x < SIZE; x++) 
25 
cout << doubleTable[x] 
<<" 
"· 
26 
cout << endl; 
27 
28 
// Now search 
for values 
in the vectors 
29 
int result; 
30 
cout << "Search i ng fo r 6 in intTable.\n"; 
31 
res ult= 
intTable.f
i nditem(6); 
32 
if (r es ult --
- 1) 
33 
cout << "6 was not found in intTable
. \n"; 
34 
els e 
35 
cout << "6 was found at subscript" 
36 
<<result<< 
endl; 
37 
38 
cout << "Searching 
fo r 12 .84 in doubleTable
. \ n"; 
39 
res ult= 
doubleTable
.finditem
(12 .84); 
40 
if (r es ul t == - 1) 
41 
cout << "12 .84 was not found i n doubleTable.\n"; 
42 
els e 
43 
cout << "12 .84 was found at subscript" 
44 
<<result<< 
endl; 
45 
ret urn O; 
46 } 
(program continues) 

Program 16-12 
(continued) 
Program Output 
These values 
are in intTable: 
0 2 4 6 8 10 12 14 16 18 
These values 
are in doubleTable: 
0 2.14 4.28 6.42 8.56 10.7 12.84 14.98 17. 12 19.26 
Searching 
for 6 in intTable. 
6 was found at subscript 
3 
Searching 
for 12.84 in doubleTable. 
12.84 was found at subscript 
6 
16.4 Class Templates and Inheritance 
1015 
Th e Search ab 1 eVector class demonstrates that a class templ ate ma y be derived from 
an oth er class templ ate. In add ition, class templ ates may be derived fro m ordin ary 
classes, and ordinary classes may be derived from class templ ates. 
~ 
Checkpoint 
16.10 Supp ose your program uses a class templ ate named Li st, whi ch is defined as 
template<c
l ass T> 
cl ass List 
{ 
I I Members are dee 7 a red here ... 
} ; 
Give an exam ple of how you wo uld use int as th e data type in th e declara tion 
of a Li st object . (Assume the class has a default constru ctor. ) 
16.11 In the follow ing Rectangle 
class declaration, the wi dt h, lengt h, and area 
mem bers are of type doub 1 e. Rewrite th e class as a templ ate that will acce pt any 
num eric type for these members. 
cl ass Rectangle 
{ 
pr i vate: 
double widt h ; 
double 
length ; 
double 
area ; 
publ i c : 
voi d setData
(double w, doubl e 1} 
{ widt h = w; length 
= 1; } 
voi d calcArea(
) 
{ area
= wi dth* 
length
; } 
double 
getWi dth( } 
{ return 
wi dth ; } 
double 
getLengt h() 
{ return 
length
; } 
doub 1 e getArea () 
{ return 
area ; } 
} ; 

1016 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
Introduction to the Standard Template Library 
CONCEPT
: Th e Standard T emplat e Library contains many temp lates for useful 
algorithm s and data structur es. 
In addition to its run-time library , which you have used throughout this book , C++ 
also provides a library of templates . The Standard Template Library (or STL) contains 
numerous templates for implementing data types and algorithms. 
The most important data structures in the STL are the containers and iterators. A container 
is a class that stores data and organizes it in some fashion. An iterator is an object that 
works like a pointer and allows access to items stored in containers . 
Sequential Containers 
There are two types of container classes in the STL: sequential containers and associative 
containe rs. Sequential containers store items in the form of sequences, meaning that 
there is a natura l way to order the items by their position within the containe r. An 
array is an example of a sequential container. The STL provides the three sequential 
containers shown in Table 16-1. 
Table 16 -1 STL Sequentia l Containers 
Container Name 
Description 
vector 
A sequence of items implemented as an array that can automat ically grow as 
needed during program execution. Items can be efficiently added and 
removed from the vector at its end. Insertions and remova ls from the middle 
or beginning of the vector are not as efficient. 
deque 
A sequence of items that has a front and back: Items can be efficiently added 
or removed from the front and back . Insertions and removals in the middle 
of a deque are not as efficient. 
l is t 
A sequence of items that allows quick additions and removals from any position. 
Because a sequential container organizes the items it stores as a sequence, it can be said to 
have a front and a back. A container is said to provide random access to its contents if it 
is possible to specify a position of an item within the container and then jump directly to 
that item without first having to go through all the items that precede it in the container. 
Positions used in random access are usually specified by giving an integer specifying the 
position of the desired item within the container. The integer may specify a position relative 
to the beginning of the container, the end of the container, or relative to some other position. 
Arrays and vectors are examples of sequential containers that provide random access. 
Associative Containers 
Sequential containers use the position of an item within the sequence to access their data. 
In contrast, associative containers associate a key with each item stored and then use the 
key to retrieve the stored item. A telephone book is an example of an associative containe r; 

16.5 Introduction to the Standard Template Library 
1017 
the values stored are telephone numbers, and each telephone number is associated with a 
name. The name can later be used as a key to look up, or retrieve, the telephone number. 
The STL provides four associative containers, as shown in Table 16-2. 
Table 16-2 STL Associative Containers 
Container Name 
Description 
se t 
mult i set 
map 
mult i map 
a 
VideoNot e 
Iterators 
Stores a set of keys. No duplicate values are allowed. 
Stores a set of keys. Duplicates are allowed . 
Maps a set of keys to data elements. Each key is associated with a unique 
data element, and duplicate keys are not permitted . 
Maps a set of keys to data elements. The same key may be associated 
with multiple values. 
A map is a conta iner that requires each value stored to be associated with a key. Each 
key may be associated with only one value; once a key is used, no other value with the 
same key may be added to the map . A multimap is like a map, except a key may be 
associated with multiple values. 
A set is like a map in which only keys are stored, with no associated values. No item 
may be stored twice in a set: That is, duplicates are not permitted . A multiset is like a 
set in which duplicates are permitted . 
Iterators 
Iterators are objects that behave like pointers. They are used to access items stored in 
containers . A typical iterator is an object of a class declared inside a container class. The 
iterator overloads pointer operators such as the increment operator ++ , the decrement 
operator -- , and the dereferencing operator * in order to provide pointer-like behavior. 
Each STL container object provides member functions begi n () and end () that return 
the beginning and ending iterators for the object. The begi n () iterator points to the item 
at the beginning of the container if the container is nonempty, while the end() iterator 
points to just past the end of the container. More details on the use of these iterators will 
be given later. 
Table 16-3 shows the different types of iterators available for use with various STL 
conta iners. 
Table 16-3 Iterator Types 
Iterator Type 
Forward 
Bidirectional 
Random -access 
Input 
Output 
Description 
Can only move forward in a conta iner (uses the++ operator) . 
Can move forward or backward in a container (uses the++ and -- operators) . 
Can move forward and backward, and can jump to a specific data element in 
a container. 
Can be used with c i n to read information from an input device or a file. 
Can be used with cout to write information to an output device or a file. 

1018 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
The Use of Iterators 
Each STL container class defines an inner class called iterator 
that can be used to 
create iterator objects. For examp le, 
vector<int>: 
:iterato
r 
list<string>
: :iterator 
are the inner classes that represent iterators to containers of type vector<i nt> and 
1 i st<stri 
ng>, respectively. Here is an example of how to define iterators for a vector of 
int and a list of str i ng and initialize both iterators to the beginning of the container: 
vector<int> 
vect; 
list<str
i ng> mylist ; 
vector<int>: 
:iterato
r vlter 
= vect.begin(); 
list<string>
: :iterator 
listlter 
= mylist.begin(); 
In C++ 11, you can declare the type of an iterator as auto and the compiler will infer 
its correct type from the type of the container: 
auto vlter 
= vect.beg
i n(); 
auto listlter 
= mylis t .beg in(); 
Moreover , C++ provides the begin(c) 
and end(c ) functions, which when applied to 
an STL container c, return the c. begi n () and c . end () iterator, respectively. So we can 
use the alternative forms 
auto vlter 
= begin(vect); 
auto listlter 
= mylist
.beg in(myl i st); 
Th e advantage of the beg i n ( c ) and end ( c) functions is that you can use them with 
arrays . Under some circumstances, that allows you to write code that works for both 
STL containe rs and arrays . 
An iterator works like a pointer that indicate s a position within a container. If i ter is 
an iterator , then * i ter represents the element stored in the container at the position of 
the iterator. Moreover, writing i ter++ causes the iterator to advance to the next 
position in the containe r. The end () iterator always indicate s a position past the last 
element in the container, so it should never be dereferenced. The end () iterator is only 
used as a sentinel to prevent "falling off the end" of a conta iner. For example, the 
following code will print all values in a vector: 
vector<int> 
vect { 10 , 20 , 30 , 40 , 50} ; 
auto iter 
= vect.begin(); 
whi le (iter 
!= vect.end()) 
{ 
} 
// Print 
element at iter 
and advance 
cout << *iter 
<< 
iter 
++ ; 
II 
II• 
Program 16-13 illustrates how these concepts can be used to work with arrays and 
vectors. Th e main idea is to write a template function 
template<typename 
T> void print(T 
begin_iter
, T end_iter
) 
that takes parameters of type T. Actual types passed for T need to support both the 
dereferencing operator * and the post-increment operator ++. Such types might be 

16.5 Introduction to the Standard Template Library 
1019 
iterators into some STL container or pointers into an array . Either way, we will refer to 
T as an iterator type for ease of presentation. Not ice that begin _ i ter and end_ i ter 
specify begin and end positions within some container, and that the increment operator 
++ knows how to move from one position to the next within that container. Therefore, 
there is no need for a third parameter to specify the container itself. You can see code 
for the print function in the code listing for Program 16-13 . 
The main function of the same program demonstrates two uses of the pr i nt function, 
one with an array of str i ng, and another with a vector of i nt. 
Program 16-13 
1 II Thi s program demonstrates 
how iterators 
and related 
concepts can 
2 II be used to write code that works wi th arrays 
and STL conta i ners . 
3 #include 
<algorithm> 
4 #include 
<iostream> 
5 #include 
<str i ng> 
6 #include 
<vector> 
7 using namespace std ; 
8 
9 //***************************************** 
10 II Thi s funct i on will 
pr i nt a range of 
* 
11 II values from an array or containe r. 
* 
12 //***************************************** 
13 template<typename 
T> 
14 void print (T begin _iter, 
T end_iter) 
15 { 
16 
auto iter 
= begi n_iter; 
17 
whi le (it er != end_i ter ) 
18 
{ 
19 
cout << *iter 
<<" "· 
20 
iter ++; 
21 
} 
22 
cout << endl; 
23 } 
24 
25 
26 int main() 
27 { 
28 
II Print 
an array of strings 
29 
string 
names[]{ "Anna", "Bob", "Chuck" }; 
30 
pr i nt(begin(names), 
end (names)); 
31 
32 
II Print 
a vector of i ntegers 
33 
vector<int> 
vec{ 10, 20, 30 }; 
34 
pr i nt(begin(vec), 
end (vec)); 
35 
36 
ret urn O; 
37
} 
Program Output 
Anna Bob Chuck 
10 20 30 

1020 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
The vector Container 
Table 16-4 lists a selection of member functions of the vector class template. Some of 
these accept iterators as parameters , and some of them return iterators as results. 
Table 16-4 Selected Member Funct ions of the Vector Class 
Member Function 
Description 
at (pos i tion) 
Returns the value of the element located at position in the vector. 
back() 
begin() 
capacity
() 
cl ear () 
empty () 
end () 
erase (i ter) 
erase (i ter1, 
iter2) 
Example: 
x = vect.at(5); 
This statement assigns the value of the element in position 5 of vect to x. 
Returns a reference to the last element in the vector. 
Example: 
cout << vect.back() 
<< endl ; 
Returns an iterator pointing to the vector's first element. 
Example: 
i ter = vect .begi n(); 
Returns the maximum number of elements that may be stored in the vector 
without additiona l memory being allocated. (This is not the same value as 
returned by the size member function .) 
Example: 
x = vect.capacity(); 
This statement assigns the capacity of vect to x. 
Clears a vector of all its elements . 
Example: 
vect.clear(); 
This statement removes all the elements from vect . 
Returns true if the vector is empty . Otherwise , it returns false. 
Example: 
i f (vect.empty ()) 
cout << "The vector 
is empty. "; 
Returns an iterator pointing to just after the last element of the vector. 
Example: 
i ter = vect .e nd(); 
Causes the vector element pointed to by the iterator i ter to be removed . 
Example: 
vect.erase(iter); 
Removes all vector elements in the range specified by the iterators i ter1 and 
i ter2. 
Example: 
vect.erase(iter1
, iter2); 
(table continues) 

16.5 Introduction to the Standard Template Library 
1021 
Table 16-4 Selected Member Funct ions of the Vector Class (continued) 
Member Function 
front() 
insert(iter, 
value) 
insert(iter, 
n, 
value) 
pop_back() 
Description 
Returns a reference to the vector's first element . 
Example: 
cout <<vector.front
()<< 
endl ; 
Inserts an element into the vector. 
Example: 
vect.insert(iter, 
x); 
This statement inserts the value x just before the element pointed to by the 
iterator i ter. 
Inserts n copies of value into the vector, starting just before the position 
pointed to by the iterator i ter. 
Example: 
vect.insert(iter, 
7, x); 
This statement inserts seven copies of the value x just before the element 
pointed to by the iterator i ter. 
Removes the last element from the vector. 
Example: 
vect.pop _back(); 
This statement removes the last element of vect, thus reducing its size by one. 
push_back ( va 1 ue) 
Stores va 1 ue as the new last element of the vector. If the vector is already 
filled to capacity, it is automatically resized. 
reverse () 
Example: 
vect.push _back(7); 
This statement stores 7 as the new last element of vect. 
Reverses the order of the elements in the vector (the last element becomes 
the first element, and the first element becomes the last element.) 
Example: 
vect.reverse();. 
resize(n) 
Resizes a vector to haven elements, where n is greater than the vector's 
resize (n, value) 
current size. If the optiona l value argument is included, each of the new 
elements will be initialized with that value. 
size() 
swap(vector2 ) 
Example where vect currently has four elements: 
vect.res
ize (6,99) ; 
adds two elements to the end of the vector, each initialized to 99. 
Returns the number of elements in the vector. 
Example: 
cout <<vector.size()<< 
endl ; 
Swaps the contents of the vector with the contents of vector2. 
Example: 
vect1 .swap(vect2); 
The statement above swaps the contents of vect1 and vect2. 

102 2 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Tem plate Library (STL) 
Algorithms 
The algorithms provided by the STL are implemented as function templates and 
perform various operat ions on elements of containers. There are many algorithms in 
the STL; Table 16-5 lists a few of them. (The table gives only general descriptions.) 
Table 16 -5 STL Algorithms 
Algorithm 
binary _search 
count 
for _each 
find 
Description 
Performs a binary search for an object and returns true if the object is found, 
false if not. 
Example: 
binary _search(ite
r1, i ter2 , value); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range.) The statement performs a binary 
search on the range of elements, searching for va 1 ue. The bi nary _search 
function returns true if the element was found and false if the element was 
not found. 
Returns the number of times a value appears in a range. 
Example: 
number = count (i ter1, 
iter2
, value); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range.) The statement returns the number 
of times value appears in the range of elements. 
Executes a function for each element in a container. 
Example: 
for _each(iter1
, iter2, 
func ); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range.) The third argument, func , is the 
name of a function. The statement calls the function func for each element 
in the range, passing the element as an argument . 
Finds the first object in a conta iner that matches a value and returns an 
iterator to it. 
Example: 
iter3 
= find (i ter1, 
iter2
, value); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range.) The statement searches the range 
of elements for va 1 ue. If va 1 ue is found, the function returns an iterator to 
the element contain ing it; otherwise, it returns the iterator i ter2. 
(table continues) 

16.5 Introduction to the Standard Template Library 
10 23 
Table 16 -5 STL Algorithms (continued) 
Algorithm 
max_element 
min_element 
random_shuffl e 
sort 
Description 
Returns an iterator to the largest object in a range. 
Example: 
iter3 
= max_element(iter1
, iter2); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range .) The statement returns an iterator 
to the element containing the largest value in the range. 
Returns an iterator to the smallest object in a range. 
Example: 
i ter3 
= min_element(iter1
, iter2); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range .) The statement returns an iterator 
to the element containing the smallest value in the range. 
Randomly shuffles the elements of a container. 
Example: 
random_shuffle
(iter1, 
iter2); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range .) The statement randomly reorders 
the elements in the range . 
Sorts a range of elements . 
Example: 
sort(iter1, 
iter2); 
In this statement, i ter1 and i ter2 define a range of elements within the 
container. ( i ter1 points to the first element in the range, and i ter2 points 
to just after the last element in the range .) The statement sorts the elements 
in the range in ascending order. 
0 
NOTE: 
The STL algorithms require the inclusion of the algorithm header file. 
Program 16-14 demonstrates the use of the random_shuffl e, sort, and bi nary _search 
algorithm templates . 
Program 16-14 
1 II Thi s program prov i des a simple demonstration 
of the 
2 II STL algorithms. 
3 
4 #include 
<iostream> 
5 #include 
<vector> 
6 #include 
<algorithm> 
7 using namespace std ; 
II 
Include the vector 
header 
II Required for STL algorithms 
(program continues) 

1024 
Chapte r 16 
Exceptions, Templates, and the Standard Template Library (STL) 
Program 16-14 
8 
(continued) 
9 int main() 
10 { 
11 
12 
vector< i nt> vect; 
II Define a vector 
object 
13 
II Use push_back to push values 
into the vector 
14 
for (i nt x = O; x < 10 ; x++) 
15 
vect.push
_back(x*x); 
16 
17 
II Display the vector's 
elements 
18 
cout << "The collect
i on has"<< 
vect.size() 
19 
<<" 
el ements. 
Here they are:\n"; 
20 
for (i nt x = O; x < vect.size(); 
x++) 
21 
cout << vect[x] 
<<" 
"· 
22 
cout << end l; 
23 
24 
II Randomly shuff le the vector's 
contents 
25 
random_shuffle(vect
.begin (), 
vect.end()); 
26 
27 
II Display the vector's 
elements 
28 
cout << "The elements 
have been shuffled:\n"; 
29 
for (i nt x = O; x < vect.size(); 
x++) 
30 
cout << vect[x] 
<<" 
"· 
31 
cout << end l; 
32 
33 
II Now sort 
them 
34 
sort(vect.begin()
, vect .end ()); 
35 
36 
II Display the vector's 
elements 
again 
37 
cout << "The elements 
have been sorted:\n"; 
38 
for (i nt x = O; x < vect.size(); 
x++) 
39 
cout << vect[x] 
<<" 
"· 
40 
cout << end l; 
41 
42 
II Now search 
for an element 
43 
int val = 49; 
44 
if (bi nary _search(vect.begin()
, vect .end(), 
val)) 
45 
cout << "The value"<< 
val 
46 
<<"was 
found i n the vector.\n"; 
47 
else 
48 
cout << "The value"<< 
val 
49 
<<"was 
not found i n the vector
. \ n"; 
50 
return 
O; 
51 ) 
Program Output 
The collection 
has 10 elements. 
Here they are: 
0 1 4 9 16 25 36 49 64 81 
The elements 
have been shuffled: 
64 1 81 4 0 25 49 9 16 36 
The elements 
have been sorted: 
0 1 4 9 16 25 36 49 64 81 
The value 49 was found in the vector. 

16.5 Introduction to the Standard Template Library 
10 25 
<) NOTE: 
Your run of this program will generate a different random shuffle. 
Th e random_shuffl e function rearranges the elements of a container. In Program 16-14, 
it is called in the following manner: 
random_shuff l e (vect.beg
i n() , vect.end
()); 
Th e function takes two arguments, which together represent a range of elements within 
a containe r. Th e first argument is an iterator to the first element in the range. In this case, 
vect. begin () is used. Th e second argument is an iterator to just after the last element in 
the range. Here we have used vect. end (). Th ese arguments tell random_sh uf fl e to 
rearrange all the elements from the beginning to the end of the vect container. 
Th e sort algo rithm also takes iterators to a range of elements. Here is the function call 
that appears in Program 16-14: 
sort(vect
.begin(), 
vect.end()); 
All the elements within the range are sorted in ascending order. 
Th e bi nary _search algorithm searches a range of elements for a value. If the value is 
found , the function returns true. Otherwise , it returns false. For example, the following 
function call searches all the elements in vect for the value 7. 
binary _search (vect.
begin (), 
vect.end()
, 7) 
Program 16-15 demonstrate s the count algorithm . 
Program 16-15 
1 II Thi s program demonstrates 
the STL count algor i thm. 
2 #include 
<iostream> 
3 #include 
<vector> 
II Needed to dec lare 
the vector 
4 #include 
<algorithm> 
II Needed for the for _each algorithm 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
vector<int> 
values; 
10 
vector<int>: 
:iterato
r iter; 
11 
12 
II Store 
some values 
i n the vector 
13 
values.push
_back(1); 
14 
values.push
_back(2); 
15 
values.push
_back(2); 
16 
values.push
_back(3); 
17 
values.push
_back(3); 
18 
values.push
_back(3); 
19 
20 
II Di splay the values 
in the vector 
21 
cout << "The values 
in the vector 
are:\n"; 
22 
for 
(it er =v al ues .begin (); 
iter 
!=v alues .end (); 
iter ++) 
23 
cout << *iter 
<<" 
"; 
24 
cout << endl << endl ; 
25 
(program continues) 

1026 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
Program 16-15 
(continued) 
26 
// Di splay the count of each number 
27 
cout << "The number of 1s in the vector 
is ... 
28 
cout << count(values
.be gin(), 
values.end(), 
1 ) << endl ; 
29 
cout << "The number of 2s in the vector 
is"; 
30 
cout << count(values
.be gin(), 
values.end(), 
2) << endl ; 
31 
cout << "The number of 3s in the vector 
is"; 
32 
cout << count(values
.be gin(), 
values.end(), 
3) << endl ; 
33 
return 
O; 
34 } 
Program Output 
The values 
in the vector 
are: 
1 2 2 3 3 3 
The number of 1s in the vector 
is 1 
The number of 2s in the vector 
is 2 
The number of 3s in the vector 
is 3 
Program 16-16 demonstrates the max_e 1 ement and mi n_e 1 ement algorithms. 
Program 16-16 
1 II This program demonstrates 
the STL max_element 
2 II and min_element algor ithm s . 
3 #include 
<iostream> 
4 #include 
<vector> 
5 #include 
<algorithm> 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
vector<int> 
numbers; 
II Needed to declare 
the vector 
II Needed fo r the algor i thms 
11 
vector<int>: 
:iterato
r iter; 
12 
13 
II Store some numbers in the vector 
14 
for (i nt x = O; x < 10; x++) 
15 
numbers .push_back(x); 
16 
17 
II Shuffle 
things 
up just 
for f un 
18 
random_shuff l e (numbers.begin
(), 
numbers .e nd()); 
19 
20 
II Display 
the numbers in the vector 
21 
cout << "The numbers i n the vector 
are :\ n"; 
22 
for (it er = numbers.beg i n(}; 
iter 
!= numbers.end(); 
iter ++) 
23 
cout << *iter 
<<" 
"· 
24 
cout << endl; 
25 
26 
II Fi nd the l argest 
value in the vector 
27 
iter 
= max_el ement (numbers.begin
(), 
numbers.end
()); 
28 
cout << "The largest 
value in the vector 
is" 
29 
<< *it er << endl; 
(program continues) 

-
16.5 Introduction to the Standard Template Library 
1027 
Program 16-16 
(continued) 
30 
31 
II Find the smallest 
value in the vector 
32 
iter 
= min_element( numbers .begin(), 
numbers .end()); 
33 
cout << "The smallest 
value in the vector 
is" 
34 
<< *iter 
<< endl; 
35 
36 
return 
O; 
37
} 
Program Output 
The values 
in the vector 
are: 
8 1 9 2 0 5 7 3 4 6 
The largest 
value in the vector 
is 9 
The smallest 
value in the vector 
is 0 
Program 16-17 demonstrates the f i nd algorithm . 
Program 16-17 
1 II This program demonstrates 
the STL find algorithm. 
2 #include 
<iostream> 
3 #include 
<vector> 
II Needed to declare 
the vector 
4 #include 
<algorithm> 
II Needed for the find algorithm 
5 using namespace std; 
6 
7 int main() 
8 { 
9 
vector<int> 
numbers; 
10 
vector<int>: 
:iterator 
iter; 
11 
12 
II Store some numbers in the vector 
13 
for (i nt x = O; x < 10; x++) 
14 
numbers.push _back(x}; 
15 
16 
II Di splay the numbers i n the vector 
17 
cout << "The numbers i n the vector 
are:\n"; 
18 
for (iter 
= numbers.begin(); 
iter 
!= numbers.end(); 
iter ++) 
19 
cout << *iter 
<<" 
"· 
20 
cout << endl << endl; 
21 
22 
II Find 7 i n the vector 
23 
iter 
= find(numbers.begin(), 
numbers.end(), 
7); 
24 
cout << "The value searched 
for i s"<< 
*iter 
<< endl; 
25 
return 
O; 
26
} 
Program Output 
The numbers in the vector 
are: 
0 1 2 3 4 5 6 7 8 9 
The value searched 
for is 7 

1028 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
Program 16-18 demonstrates the for _each algorithm. 
Program 16-18 
1 II Thi s program demonstrates 
the for _each alg orithm . 
2 
3 #include 
<iostream> 
4 #include 
<vector> 
II Needed to declare 
the vector 
5 #include 
<algorithm> 
6 using namespace std ; 
7 
II Needed for the for _each algorithm 
8 II Function 
prototype 
9 void doubleValue (i nt &); 
10 
11 int main() 
12 { 
13 
vector<int> 
numbers; 
14 
vector<int>: 
:iterato
r iter; 
15 
16 
II Store some numbers in the vector 
17 
for (i nt x = O; x < 10; x++) 
18 
numbers.push _back(x); 
19 
20 
II Display 
the numbers in the vector 
21 
cout << "The numbers i n the vector 
are :\n"; 
22 
for (it er = numbers.beg i n(); 
iter 
!= numbers.end(); 
iter ++) 
23 
cout << *iter 
<<" 
"· 
24 
cout << endl; 
25 
26 
II Double the values 
i n the vector 
27 
for _each(numbers.begin(), 
numbers.end(), 
doubleValue); 
28 
29 
II Display 
the numbers in the vector 
again 
30 
cout << "Now the numbers in the vector 
are :\n"; 
31 
for (it er = numbers.beg i n(); 
iter 
!= numbers.end(); 
iter ++) 
32 
cout << *iter 
<<" 
"· 
33 
cout << endl; 
34 
return 
O; 
35
} 
36 
37 //******************************************************** 
38 II Function 
doubleValue . This funct i on accepts 
an i nt 
39 II reference 
as its 
argument. 
The value of the argument 
40 II is doubled. 
* 
* 
* 
41 //******************************************************** 
42 void doubleValue (i nt &val ) 
43 { 
44 
val *= 2 ; 
45
} 
Program Output 
The numbers in the vector 
are: 
0 1 2 3 4 5 6 7 8 9 
Now the numbers in the vector 
are: 
0 2 4 6 8 10 12 14 16 18 

16.6 
-ii 
16.6 Tying It All Together: Word Transformers Game 
1029 
In Program 16-18, the following statement calls for _each: 
for _each(numbers.begi
n(), 
numbers.end(), 
doubleValue); 
The first and second arguments specify a range of elements. In this case, the range is the 
entire vector. The third argument is the name of a function . The for _eac h algorithm 
calls the function once for each element in the range, passing the element as an argument 
to the function . 
The programs in this section give you a brief introduction to using the STL by 
demonstrating simple operations on a vec t or . In the remaining chapters you will be given 
specific examples of how to use other STL containers, iterators, and algorithms. 
Tying It All Together: Word Transformers Game 
A software entrepreneur is designing an educational word game for children. A child 
playing the game is given two words and must determine if it is possible to rearrange 
the letters in the first word to form the second . What the program does next depends 
on the relation between the two words and on the correctness of the player's answer. 
When given two words, the child may claim that transformation of the first word into 
the second is possible . In this case, the program asks the child to demonstrate the 
correctness of the answer by typing a sequence of words starting with the first and 
ending with the second. Such a sequence is an acceptable proof sequence if each word is 
obtained from its predecessor by swapping a single pair of adjacent letters. For example, 
the sequence 
tops, tosp, tsop, stop, sotp, sopt, spot 
proves that the word tops can be transformed into spot . If the proof sequence is 
accepted, the child earns a point and play proceeds to the next round with a fresh pair 
of words. 
A proof sequence is rejected if a word cannot be obtained from its predecessor by swapping 
an adjacent pair of letters, or if the first word in the sequence is not the first word of the pair 
of words being tested, or if the last word is not the second word in the given pair. When a 
sequence is rejected, play proceeds to the next round, but the child earns no points. 
The child may observe that transformation is not possible. If the child's answer is correct, 
he or she receives a point and play proceeds to the next round. If the child's answer is 
incorrect and the transformat ion is indeed possible, the child receives no points. In this 
case, however, the program displays a correct proof sequence before moving on to the 
next round of the game. 
A program at the heart of this game must perform several tasks. 
1. The program must be able to determine if one of a given pair of words can be 
transformed into another. 
2. The program must be able to determine if one word results from another by 
swapping an adjacent pair of letters. 
3. The program must be able to produce a proof sequence when transformat ion of 
one word into another is possible. 

1030 
Chapte r 16 
Exceptions, Templates, and the Standa rd Template Library (STL) 
How can we write a program for producing proof sequences for a pair of words? One 
idea is to start with the first word as the current word. Then, swap an adjacent pair of 
letters to obtain a new current word. Repeating this strategy will generate a sequence 
of words. If the current word ever turns out to be the target word, we know we have a 
proof sequence. 
Although the approach we have just outlined is easy to think of, it is difficult to implement. 
An alternative approach involves sorting. If a transformation between the two words is 
possible, sorting them will yield the same word. If, in addition, we use a sorting method 
that works by swapping adjacent letters, the sorting process will yield a proof sequence 
from each of the original words to the same word. For example, sorting tops and spot 
yields the same word opst with the corresponding sequences 
tops, otps, opts, opst 
and 
spot, psot, post, opst. 
Notice that the second sequence is a sequence from opstto spot in reverse. By concatenating 
this last sequence to the first and eliminating the duplicate entry in the middle, we obtain 
the proof sequence from tops to spot: 
tops, otps, opts, opst, spot, psot, post, spot 
Let us consider some details related to the implementation of this plan . Rather than 
keep a list of intermediate words generated during the sort, we can keep a list of swaps 
or transpositions performed by the sort . We do this by storing the index i for each pair 
(i, i+1) of positions of characters swapped by the transposition. Our program uses the 
well-known Bubblesort sorting algorithm. A function 
sort(char 
str[J, 
i nt size, 
vector< i nt> &tranpose) 
is used to sort an array of characters of a given size, while saving the list of transpositions 
performed on the array during the sort. Once both words have been sorted, the resulting 
two lists of transpositions will be applied to a copy of the first word as previously 
described and the words resulting from the application of each transposition will be 
printed. This strategy is implemented in Program 16-19. 
Program 16-19 
1 // Thi s program solves 
the word transformation 
puzzle . 
2 #include 
<iostream> 
3 #include 
<str i ng> 
4 #include 
<vector> 
5 #include 
<algorithm> 
6 using namespace std; 
7 
8 // Prototype 
9 void sort(char 
str[J, 
i nt size, 
vector< i nt>& transpositions); 
10 
11 int main() 
(program continues) 

16.6 Tying It All Together: Word Transformers Game 
10 31 
Program 16-19 
12 { 
(continued) 
13 
II The two words and a copy of the f i rst word 
14 
char str1[] 
= "spot"; 
15 
char str1Copy[J 
= "spot"; 
16 
char str2[] 
= "stop"; 
17 
18 
II These vectors 
hold the list 
of transpositions 
19 
vector<int> 
transpose; 
20 
vector<int> 
reverse _transpose
; 
21 
22 
II Sort the two words 
23 
cout << "The first 
word is•<< 
str1 
<< endl 
24 
<< "The second word is"<< 
str2 
<< endl ; 
25 
sort(str1, 
4, transpose); 
26 
sort(str2, 
4, reverse _transpose)
; 
27 
28 
II Apply the first 
list 
of transpositions 
29 
cout << "The transformation 
steps 
are: 
• << endl; 
30 
cout << str1Copy << " "· 
31 
for (int 
k = O; k < transpose.size()
; k++) 
32 
{ 
33 
i nt i ndex= 
transpose
[k]; 
34 
swap(str1Copy[index], 
str1Copy[index 
+ 1]) ; 
35 
cout << str1Copy << • "; 
36 
} 
37 
II Apply the second li st of transpos
i tions 
i n reverse 
order 
38 
for (int 
k = reverse _transpose.s
i ze () - 1; k >=O; k-- } 
39 
{ 
40 
41 
42 
43 
} 
i nt i ndex= 
reverse _transpose[k]
; 
swap(str1Copy[index], 
str1Copy[index 
+ 1]) ; 
cout << str1Copy << • "· 
44 
cout << endl ; 
45 
return 
O; 
46 } 
47 
48 //************************************************************* 
49 II Thi s is a version 
of Bubblesort 
that 
saves a list 
of al l 
50 II transpos
i t i ons that 
are needed to sort 
the l ist 
* 
* 
51 //************************************************************* 
52 void sort(char 
str[J, 
i nt size, 
vector< i nt>& transpositions} 
53 { 
54 
II Last i ndex of port i on yet to be sorted 
55 
i nt upperBound = size - 1; 
56 
57 
whi le (upperBound 
> O} 
58 
{ 
59 
60 
61 
for (int 
k = O; k < upperBound; 
k++) 
{ 
i f (str [k ] > str[k +1 J ) 
(program continues) 

1032 
Chapte r 16 
Exceptions, Templates, and the Standa rd Template Library (STL) 
Program 16-19 
(continued) 
62 
{ 
63 
II Save the swap index 
64 
transpositions
.push_back(k); 
65 
swap(str[k], 
str[k+1 ] ); 
66 
) 
67 
) 
68 
upperBound -- ; 
69 
} 
70
} 
Program Output 
The first 
word is spot 
The second word is stop 
The transformation 
steps 
are: 
spot psot post opst ospt sopt sotp stop 
Review Questions and Exercises 
Fill-in-the-Blank 
1. 
The line containing a throw statement is known as the ____ 
_ 
2. 
The ____ 
block should enclose code that directly or indirectly might cause 
3. 
4. 
an exception to be thrown. 
The ____ 
block hand les an exception. 
When writing function or class templates , you use a(n) ____ 
to specify a 
generic data type. 
5. 
The beginning of a template is marked by a(n) ___ 
_ 
6. 
7. 
8. 
9. 
When declaring objects of class templates, the ____ 
you wish to pass into 
the type parameter must be specified. 
A(n) ____ 
container organizes data in a sequential fashion similar to an array. 
A(n) 
container uses keys to rapidly access elements. 
____ 
are pointer-like objects used to access information stored in a container. 
C++ Language Elements 
10. 
Modify the Si mpl eVector template presented in this chapter to include an overloaded 
assignment operator. 
Algorithm Workbench 
11. 
Write a function template that takes a generic array of a given size as a parameter 
and reverses the order of the elements in the array. The first parameter of the function 
should be the array, and the second parameter should be the size of the array . 
12. 
Write a function template that is capable of adding any two numeric values and 
returning the result. 

Review Quest ions and Exercises 
103 3 
13. 
Describe what will happen if you call the function of question 11 and pass it an 
array of char . 
14. 
Describe what will happen if you call the function of question 11 and pass it an 
array of string
. 
Find the Error 
15. 
Each of the following declarations or code segments has errors. Locate as many 
as possible. 
A) catc h 
{ 
quot ien t = divide(num1, 
num2); 
co ut << "The quoti ent is•<< 
quot ient<< 
endl; 
} 
try 
(str i ng exceptionS
t ring) 
{ 
} 
B) 
try 
{ 
cou t << exceptionS
t ring; 
quot ien t = divide(num1, 
num2); 
} 
cout << "The quot i ent is•<< 
quoti ent << endl; 
catc h (string 
exceptionS
t ring) 
{ 
cou t << exceptionS
t ring; 
} 
C) 
template 
<cl ass T> 
T square( T number) 
{ 
return 
T * T; 
} 
D) 
template 
<cl ass T> 
i nt square(in
t number) 
{ 
return 
number* 
number; 
} 
E) 
template 
<cl ass T1, class 
T2> 
T1 sum(T1 X, T1 y) 
{ 
return 
x + y; 
} 
F) 
Assume the following declaration 
appears 
in a program 
that uses the 
Simpl eVect or class template presented in this chapter. 
int <SimpleVec t or> array(25); 
G) Assume the following statement 
appears in a program that has defined 
valueSe t as an object of the Si mpl eVector class presented in this chapter. 
Assume that val ueSet is a vector of i nt s and has 20 elements . 
cout << valueSe t <int> [2] << endl; 

10 34 
Chapte r 16 
Exceptions, Templat es, and the Standa rd Template Library (STL) 
Video Note 
Solving the 
Arithmetic 
Exceptions 
Problem 
0 
Soft Skills 
16. 
Suppose that you are part of a project team and it becomes clear to you that one 
of the team members is not "pulling his weight." What should you do if you are 
the project leader? What should you do if you are not the project leader? 
Programming 
Challenges 
1. String Bound Exceptions 
Write a class BCheckSt ring that is derived from the STL str i ng class. This new class 
will have two member functions: 
A) A BCheckString (string 
s ) constru ctor that receives a string object passed 
by value and passes it on to the base class constructor. 
B) An char 
operator [ J (int 
k) function that thr ows a BoundsExcept ion 
object if k is negative or is greater than or equal to the length of the string . If 
k is within the bounds of the string, this function will return the character at 
position k in the string. 
You will need to write the definition of the BoundsExcept ion class. Test your class 
with a main function that attemp ts to access characters that are within and outside the 
bounds of a suitabl y initialized BCheckSt ring object. 
2. Arithmetic Exceptions 
Write a function that accepts an integer parameter and returns its integer squa re root. 
The function should throw an exception if it is passed an integer that is not a perfect 
square . Demonstra te the function with a suitabl e driver program . 
3. Min/ Max Templates 
Write templates for the two functions min and max. mi n should accept two arguments 
and return the value of the argument that is the lesser of the two.max should accept two 
arguments and return the value of the argument that is the greater of the two. Design a 
simple driver program that demonstrates the templates with various data types. 
4. Sequence Accumulation 
Write a function 
T accum(vec tor 
<T> 
v) 
that forms and returns the "sum" of all items in the vector v passed to it. For example, if 
T is a numeric type such as int or doub le, the numeric sum will be returned, and if 
T represents the STL string type, then the result of concatenation is returned . 
NOTE: For any type T, the expression T () yields the value or object created by the 
default constructor. For example , T () yields the empty string object if T is the string 
class. If T represents a numer ic type such as int , then T () yields 0. Use this fact to 
initialize your "accumulator." 

Programming Challenges 
1035 
Test your function with a driver program that asks the user to enter three integers, uses 
accum to compute the sum, and prints out the sum. The program than asks the user to 
enter three strings, uses accum to concatenate the strings, and prints the result. 
5. Rotate Left 
The two sets of output below show the results of successive circular rotat ions of a vector. 
One set of data is for a vector of integers, and the second is for a vector of strings. 
1 3 
5 7 
3 5 
7 
1 
5 
7 
1 3 
7 
1 3 5 
a b 
C d e 
b 
C d e a 
C d e a b 
d e a b 
C 
e a b 
C d 
Write two template functions that can be used to rotate and output a vector of a generic type: 
voi d rotateleft
(vect or <T>& v) 
voi d outp ut(v ecto r <T> v) 
The first function performs a single circular left rotation on a vector, and the second 
prints out the vector passed to it as paramete r. Write a suitable driver program that will 
allow you to test the two functions by generating output similar to the above. Verify that 
the program works with vectors whose element types are char , int , double, and string. 
6. Template Reversal 
Write a template function that takes as parameter a vector of a generic type and reverses 
the order of elements in the vector, and then add the function to the program you wrote 
for Programming Challenge 5. Modify the driver program to test the new function by 
reversing and outputt ing vectors whose element types are char, i nt, double, and str i ng. 
7. Si mp l eVe ct or Modification 
Modify the Simpl eVector class template, presented in this chapter, to include the member 
functions push_back and pop_back. These functions should emulate the STL vector class 
member functions of the same name. (See Table 16-4.) The push_back function should 
throw an exception if the array is full. The push_back function should accept an argument 
and insert its value at the end of the array. The pop_back function should accept no 
argument and remove the last element from the array. Test the class with a driver program. 
8. Searc habl eVector Modification 
Modify the Searchabl eVector class template, presented in this chap ter, so it performs 
a binary search instead of a linear search. Test the template in a driver program. 
9. Sort abl eVect or Class Template 
Write a class template named SortableVector. 
The class should be derived from the 
Si mple-Vecto r class presented in this chapter. It should have a member function that 
sorts the array elements in ascending order. (Use the sorting algorithm of your choice.) 
Test the template in a driver program . 

1036 
Chapte r 16 
Except ions, Templat es, and the Standa rd Template Library (STL) 
10. Two-Dimensional 
Data 
Suppose that data representing a list of people and places they would like to visit is 
stored in a file as follows: 
3 
0 Paul 
1 Peter 
2 David 
0 3 Chicago Boston Memph is 
1 1 Boston 
2 0 
The first number n in the file indicates how many people there are in the list. Here n is 3, 
so there are three people. Each person in the list is assigned a number in the range 0 .. n - 1 
that is used to identify that person. For each person, the file lists the numerical identifier 
of the person, followed by the number of places the person wants to visit, followed by the 
names of those places. For example, Boston is the only place that Peter cares to visit, while 
David wants to visit no places. 
Write a program that reads in this type of data from a file and stores it in appropriate 
STL data structure. For example , you might use vectors, as well as vectors of vectors, 
to represent this informa tion. The program allows users to type in the name of a person 
whose list of favorite destinations is to be printed out. Th e program prints an error 
message if the person is not in the database . 
11. Word Transformers Modification 
Mod ify Program 16-19 so that it keeps lists of intermed iate words during the two sorts 
instead of keeping lists of swap indices. 
12. Pascal 's Triangle 
The first seven rows of Pascal's triangle are 
1 
1 1 
1 2 1 
1 3 3 1 
1 4 6 4 1 
1510 10 5 1 
1615 20 15 6 1 
The first row shown has index 0, and the last row has index 6. Row O of the triangle consists 
of the single number 1. For any positive integer k, the row with index k has k + 1 numbers 
and starts and ends with a 1. For each position p other than the first and the last, the element 
at pin row k is the sum of the two elements of row (k - 1) at positions p and p - 1. 
Write a function 
vecto r <in t > pasc al Tr i ang l eNext Row(vect or <i nt> row) 
that takes a row of Pascal's triangle in the form of a vector and returns the next row in the 
triangle. Test your function by writing a main function that asks the user to enter an integer 
N and prints the first N rows of Pascal's triangle by repeatedly calling the above function. 

TOPICS 
17.1 Introduction to the Linked List ADT 
17.2 Linked List Operations 
1 7.6 The STL 1 i st Containe r 
17.7 Reliable Software Systems, Inc., 
Case Study 
17.3 A Linked List Template 
17.4 Recursive Linked List Operations 
17.5 Variations of the Linked List 
17.8 Tying It All Togethe r: More on Graphics 
and Animation 
17.1 
Introduction 
to the Linked List ADT 
CONCEPT: 
Dynamically allocated data structur es may be linked together in memory 
to form a chain. 
A linked list is a series of connected nodes, where each node is a data structure . The 
nodes of a linked list are usually dynamically allocated, used, and then deleted, allowing 
the linked list to grow or shrink in size as the program runs. If new information needs 
to be added to a linked list, the program simply allocates another node and inserts it 
into the series. If a particular piece of information needs to be removed from the linked 
list, the program deletes the node containing that information . 
Advantages of Linked Lists over Arrays and Vectors 
Although linked lists are more complex to code and manage than arrays, they have 
some distinct advantages . First, a linked list can easily grow or shrink in size. In fact, 
the programmer doesn't need to know how many nodes will be in the list. They are 
simply created in memory as they are needed. 
One might argue that linked lists are not superior to vectors (found in the Standard 
Template Library), because they too can expand or shrink. The advantage that linked lists 
have over vectors, however, is the speed at which a node may be inserted into or deleted 
1037 

1038 
Chapte r 17 
Linked Lists 
Figure 17-1 
Figure 17-2 
from the list. To insert a value into the middle of a vector requires that all the elements after 
the insertion point be moved one position toward the vector's end, thus making room for 
the new value. Likewise, removing a value from a vector requires all the elements after the 
removal point to be moved one position toward the vector's beginning. When a node is 
inserted into or deleted from a linked list, none of the other nodes have to be moved. 
The Structure of Linked Lists 
Each node in a linked list contains one or more members that hold data. (For example, 
the data stored in the node may be an inventory record; or it may be a customer 
informat ion record consisting of the customer's name, address, and telephone number. ) 
In addition to the data, each node contains a successor pointer that points to the next 
node in the list. The makeup of a single node is illustrated in Figure 17-1. 
Pointer 
Data Members 
-
-
The first node of a nonempty linked list is called the head of the list. To access the 
nodes in a linked list, you need to have a pointer to the head of the list. Beginning with 
the head, you can access the rest of the nodes in the list by following the successor 
pointers stored in each node. The successor pointer in the last node is set to nul 1 ptr to 
indicate the end of the list. 
Because the pointer to the head of the list is used to locate the head of the list, we can 
think of it as representing the list head. The same pointer can also be used to locate the 
entire list by starting at the head and following the successor pointers, so it is also 
natural to think of it as representing the entire list. Figure 17-2 illustrates a linked list 
of three nodes, showing the pointer to the head, the three nodes of the list, and the 
null ptr value that signifies the end of the list. 
G-1 
I • I , ~I ___ 
_.__•_.I, ~I ___ 
_.__•_.I, nullptr 
List Head 
0 
NOTE: Figure 17-2 depicts the nodes in the linked list as being very close to each 
other, neatly arranged in a row . In reality, the nodes may be scattered around 
various parts of memory. 
C++ Representation 
of Linked Lists 
To represent linked lists in C++, we need to have a data type that represents a single 
node in the list. Looking at Figure 17-1, we see that it is natural to make this data type a 
structure that contains the data to be stored, together with a pointer to another node of 

17.1 Introduction to the Linked List ADT 
1039 
the same type. Assuming that each node will store a single data item of type doubl e, we 
can declare the following type to hold the node: 
struc t Lis tNode 
{ 
} ; 
double value; 
ListNode *next; 
Here Li stNode is the type of a node to be stored in the list, the structure member value 
is the data portion of the node , and the structure member next , declared as a pointer to 
Li stNode , is the successor pointer that points to the next node . 
Th e Li stNode structure has an interesting property: It contains a pointer to a data 
structure of the same type and thus can be said to be a type that contains a reference to 
itself. Such types are called self-referential data types, or self-referential data structur es. 
Having declared a data type to represent a node, we can define an initially empty linked 
list by defining a pointer to be used as the list head and initializing its value to nul 1 ptr: 
ListNode *head= 
nullptr
; 
We can now create a linked list that consists of a single node storing 12.5 as follows: 
head= new ListNode; 
head->value = 12.5; 
head->ne xt = nullptr; 
II alloca t e new node 
II store 
the value 
II sign ify end of l i st 
Now let's see how we can create a new node, store 13.5 in it, and make it the second 
node in the list. We can use a second pointer to point to a newly allocated node into 
which the 13.5 will be stored: 
ListNode *secondPtr 
= new ListNode; 
secondP t r - >value = 13.5; 
secondP t r - >next = nullptr; 
head->ne xt = secondPtr
; 
II second node is end of list 
II first 
node points 
t o second 
Note that we have now made the second node the end of the list by setting its successor 
pointer , secondP t r - >next , to null ptr, and we have changed the successor pointer of 
the list head to point to the second node . Program 17-1 illustrates the creation of a 
simple linked list. 
Program 17-1 
1 II Thi s program illustrates 
the creat ion 
2 II of l i nked lists. 
3 #include 
<iostream> 
4 using namespace std ; 
5 
6 st ruct Lis tNode 
7 { 
8 
double value; 
9 
ListNode *next ; 
10 } ; 
11 
(program continues) 

1040 
Chapte r 17 
Lin ked Lists 
Program 17-1 
(continued) 
12 int main() 
13 { 
14 
ListNode 
*head= 
nullpt
r; 
15 
16 
II Create 
first 
node with 12 .5 
17 
18 
19 
20 
head= 
new ListNode ; 
head - >value = 12. 5 ; 
head - >next = nullptr; 
II Allocate 
new node 
II Store 
the value 
II Signify 
end of list 
21 
II Create 
second node wi th 13.5 
22 
List Node *secondPtr 
= new ListNode ; 
23 
secondPtr
- >value = 13 .5 ; 
24 
secondPtr
- >next = nullptr; 
II Second node is end of list 
25 
head - >next = secondPt r; 
II First 
node points 
to second 
26 
27 
II Print 
the list 
28 
cout << "Fi rst 
item is "<< 
head - >value << end l; 
29 
cout << "Second item i s " << head - >next - >value << endl ; 
30 
ret urn O; 
31 } 
Program Output 
First 
item is 12.5 
Second item is 13.5 
Using Constructors to Initialize Nodes 
Recall that C++ str uctures can have constr uctors . It is often convenient to provide the 
structures that define the type for a list node with one or mo re constructo rs, to allow 
nodes to be init ialized as soon as they are created . Recall also that just like regular 
functions, constructo rs can be defined with default parameters. It is very common to 
provide a default parameter of nul 1 ptr for the successor pointer of a node. Here is an 
alternative definition of the Li stNode structure: 
struct 
ListNode 
{ 
double value; 
Li stNode *next ; 
I I Constructor 
ListNode (double value1, 
ListNode 
*next 1 = nullptr) 
{ 
value= 
value1; 
next
= next1; 
} 
) ; 
With this declarat ion, a node can be created in two different ways: 
1. by specifying just its value part and letting the successor pointer default to nul 1 pt r, or 
2. by specifying both the value part and a pointer to the node that is to follow this 
one in the list 

17.1 Introduction to the Linked List ADT 
1041 
The first method is useful when we are creating a node to put at the end of a linked list, 
while the second method is useful when the newly created node is to be inserted at a 
place in the list where it will have a successor. 
Using this new declaration of a node, we can create the previous list of 12 . 5 followed 
by 13 . 5 with much shorter code: 
ListNode *secondPtr 
= new ListNode(13 .5); 
ListNode *head= 
new Lis t Node(12.5, 
secondPtr); 
We can actually dispense with the second pointer and write the above code as: 
ListNode *head= 
new Lis t Node(13.5); 
head= 
new ListNode(12 .5, head); 
This code is equivalent to what precedes it because the assignment statement 
head= 
new ListNode(12 .5, head); 
is evaluated from right to left: First the old value of head is used in the consrructor, and then 
the address returned from the new operator is assigned to head, becoming its new value. 
Building a List 
Using the constructor version of Li stNode , it is very easy to create a list by reading 
values from a file and adding each newly read value to the beginning of the list of 
values already accumu lated . For examp le, using numberl i st for the list head , and 
numberFi 1 e for the input file object, the following code will read in numbers stored in 
a text file and arrange them in a list: 
ListNode *numberl i st = nullp t r; 
double number; 
whi le (numberFile 
>> number) 
{ 
) 
// Create 
a node t o hold t hi s number 
numberlist 
= new Li stNode(number, 
numberlist); 
Traversing a List 
The process of beginning at the head of a list and going through the entire list while 
doing some processing at each node is called traversing the list. For example, we would 
have to traverse a list if we needed to print the contents of every node in the list. To 
traverse a list, say one whose list head pointer is numberl i st , we take another pointer 
pt r and point it to the beginning of the list: 
ListNode *pt r = numberl i st; 
We can then process the node pointed to by ptr by working with the expression *ptr, 
or by using the structure pointer operator - >. For example, if we needed to print the 
value at the node, we could write the code 
cout << pt r - >value; 

104 2 
Chapte r 17 
Lin ked Lists 
Once the processing at the node is done, we move the pointer to the next node, if there 
is one, by writing 
ptr = ptr - >next; 
thereby replacing the pointer to a node by the pointer to the successor of the node. 
Thus to print an entire list, we can use code such as 
ListNode *ptr = numberLi st ; 
whi l e (ptr 
!= nullptr) 
{ 
" ". 
II Process 
node 
cout << ptr - >value << 
ptr = ptr - >next ; 
II Move to next node 
} 
Program 17-2 illustrates these techniques by reading a file of numbers, arranging the 
numbers in a linked list, and then traversing the list to print the numbers on the screen. 
Program 17-2 
1 II Thi s program illustrates 
the building 
2 II and traversal 
of a linked 
list. 
3 
4 #include 
<iostream> 
5 #include 
<fstream> 
6 using namespace std ; 
7 
8 struct 
ListNode 
9 
{ 
10 
double value; 
11 
ListNode *next; 
12 
II Constructor 
13 
ListNode(double 
value1, 
ListNode *next1 = nullptr) 
14 
{ 
15 
value= 
value1; 
16 
next
= next1; 
17 
} 
18 
}; 
19 
20 int main() 
21 { 
22 
23 
24 
double number; 
List Node *numberLi st = 
25 
II Open the fi le 
nul lptr ; 
II Used to read the file 
II Li st of numbers 
26 
ifstream 
numberFile("numberFile.dat"); 
27 
if (!n umberFile ) 
28 
{ 
29 
cout << "Error 
in opening the file 
of numbers."; 
30 
exit (1}; 
31 
} 
32 
II Read the fi le i nto a linked 
l i st 
33 
cout << "The contents 
of the file 
are: 
" << endl ; 
34 
whi le (numberFile 
>> number) 
(program continues) 

17.2 Linked List Operations 
1043 
Program 17-2 
(continued) 
35 
{ 
36 
cout <<nu mber<<" 
"; 
37 
II Create a node t o hold t hi s number 
38 
numberl i st = new Li stNode(number, 
numberlist); 
39 
} 
40 
II Traverse the l i st whi le pri nt i ng 
41 
cout << endl << "The cont ents of the l i st are: 
"<< endl; 
42 
ListNode *pt r = numberl i st; 
43 
whi le (ptr 
!= nullptr) 
44 
{ 
45 
46 
47 
} 
cout << ptr - >value <<" 
ptr = ptr - >next; 
"; II Process node 
II Move t o next node 
48 
return 
O; 
49
} 
Program Output 
The 
10 
The 
40 
contents 
of the file 
are: 
20 30 40 
contents 
of the 1 i st are: 
30 20 10 
~ 
Checkpoint 
17.1 Describe the two parts of a node . 
17.2 What is a list head? 
17.3 
What signifies the end of a linked list? 
17.4 
What is a self-referential data structure? 
17.2 
Linked List Operations 
CONCEPT: 
Th e basic linked list opera tions are adding an element to a list, removing 
an element from the list, travers ing the list, and destroying the list. 
In this section we develop some simple list classes. The first of these, which we call 
Numberli st , will store values of type double . It is based on the ListNode structure 
defined in the preceding section and is shown here. 
Contents of Numberl i st. h 
1 #include 
<iostream> 
2 using namespace std; 
3 class Numberli st 
4 { 
5 pro t ected: 
6 
II Declare a class 
for the list 
node 
7 
struct 
Li stNode 

1044 
Chapte r 1 7 
Linked Lists 
8 
{ 
9 
double value; 
ListNode *next; 
10 
11 
12 
13 
14 
15 
ListNode (double value1, 
ListNode *next1 = nullptr) 
{ 
} 
16 
} ; 
value= 
value1; 
next= 
next1; 
17 
ListNode *head; 
18 public: 
19 
Numberlist() 
{head= 
nullptr; 
} 
20 
-Numberlist
(); 
21 
voi d add(double 
number); 
22 
voi d remove(double 
number); 
23 
voi d displ aylist() 
const; 
24 } ; 
II List head pointer 
II Constructor 
II Destructor 
Because Li st Node does not need to be accessed by any code outside of NumberL i st, we 
have declared it inside the Numberl i st class. We have also declared Li stNode in a 
protected section to make it accessible to classes that may later be derived from NumberL i st. 
Notice that the constructor initializes the head pointer to nullptr, 
thereby indicating 
that the list starts out empty . The class has an add function that takes a value and adds 
it to the end of the list, as well as a di sp 1 ayL i st function that prints to the screen all 
values stored in the list. A destructor function destroys the list by deleting all its nodes. 
With the exception of remove (), all of these functions are defined in Numberl i st. cpp. 
The remove ( ) function will be added later. 
Content s of NumberL i st. cpp 
1 #include 
"NumberList .h" 
2 using namespace std ; 
3 
4 //***************************************************** 
5 II add adds a new element to the end of the list. 
* 
6 //***************************************************** 
7 void NumberList::add
(double number) 
8 { 
9 
if (head== 
nullptr) 
10 
head= 
new ListNode(number); 
11 
else 
12 
{ 
13 
II The list 
is not empty 
14 
II Use nodePtr to traverse 
the list 
15 
ListNode *nodePtr = head ; 
16 
while (nodePtr->next 
!= nullptr) 
17 
nodePtr = nodePtr ->next; 
18 
19 
II nodePtr - >next is nullptr 
so nodePtr points 
to last 
node 
20 
II Create a new node and put i t after 
the last 
node 
21 
nodePtr ->next = new ListNode(number); 
22 
} 
23 } 
24 

a 
VideoNot e 
Adding an 
Element to a 
linked list 
17.2 Linked List Operations 
1045 
25 //*************************************************** 
26 II displayl
i st outputs 
a sequence 
of all 
values 
27 II current
ly stored 
in the l i st . 
* 
* 
28 //*************************************************** 
29 void Numberlist
: :disp laylis
t( ) const 
30 { 
31 
32 
33 
34 
35 
36 
37 
38 
39
} 
40 
ListNode 
*nodePtr 
= head ; 
while 
(nodePtr ) 
II Start 
at head of list 
{ 
II Print 
the value i n the current 
node 
} 
cout 
<< nodePtr - >value 
<<" 
II Move on to the next node 
nodePtr 
= nodePtr - >next; 
". 
41 //****************************************************** 
42 II Destructor 
deallocates 
the memory used by the l ist
. * 
43 //****************************************************** 
44 Numberl i st: :-Numberlist
() 
45 { 
46 
ListNode *nodePtr 
= head; 
II Start 
at head of list 
47 
whi le (nodePtr 
!= nullptr) 
48 
{ 
49 
50 
51 
52 
53 
54 
55 
56
} 
II garbage 
keeps track 
of node to be deleted 
ListNode 
*garbage= 
nodePtr; 
} 
II Move on to the next node, if any 
nodePtr 
= nodePtr - >next; 
II Delete 
the "garbage" 
node 
delete 
garbage; 
Because the Numberl i st class contains pointers to dynamically allocated memory, it needs 
to be equipp ed with both a copy constr uctor and an overloaded assignment operator 
before it can safely be used in situations that require copies of lists to be made. 
Adding an Element to the List 
Th e add member function accepts as an argument a number of type doub 1 e, creates a 
node containing the number, and adds it to the end of the list. Th e bas ic idea is as 
follows. If, on one hand, the list is empty, the newly created node becomes the only node 
in the list: 
head = new ListNode(number); 
If, on the other hand, the list is not empty, we take a poi nter 
nodePtr, set it to the 
beginning of the list, and walk it down the list until it points to the last node . We will 
know it is pointing to the last node when nodePtr - >next equa ls nul 1 ptr . Th e code for 
starting the pointer at the beginning of the list and walking it down to the end is 
ListNode 
*nodePtr 
= head; 
whi le (nodePtr - >next != nullptr) 
nodePtr 
= nodePtr - >next; 

1046 
Chapte r 17 
Lin ked Lists 
Once nodePtr 
is pointing to the last node, we can add the new node after it by using 
the code 
nodePtr
- >next = new Li stNode (number ); 
Putting all of this together, we get the add function shown in lines 7-23 of Numberl i st . cpp. 
Displaying a List 
The code for the di spl ayl i st member function, in lines 29- 39, is based on the 
algorithm for traversing a list presented in the last section. 
Destroying the List 
It is important for the class's destructor to release all the memory used by the list. It 
does this by stepping through the list, deleting one node at a time. The code for doing 
so is found in lines 44- 56 of the Numberl i st. cpp file. A pointer nodePtr starts at the 
beginning (head) of the list and steps through the list one node at a time. A second 
pointer , garbage
, follows in nodePtr
' s wake and is used to delete each node as soon as 
nodePt r has passed on to the node's successor. 
Program 17-3 demonstrates the operation of the member functions of the Numberl i st 
class. 
Program 17-3 
1 II 
Thi s program 
demonstrates 
the 
add and 
2 II 
display 
linked 
list 
operations. 
3 
4 #include 
"Numberlist.h" 
5 using 
names pace std ; 
6 
7 int 
main() 
8 { 
9 
Numberlist 
1 i st; 
10 
1 ist.add(2.5); 
11 
1 i st. add ( 7 . 9 ) ; 
12 
list.add(
12 .6 ); 
13 
list.d
i splayl
i st(); 
14 
cout 
<< endl; 
15 
return 
O; 
16 ) 
Program Output 
2.5 
7.9 
12.6 
Let's step through Program 17-3, observing how the add function builds a linked list to 
store the three argument values used. 
The head pointer , a member variable of the NumberL i st class, is automat ically 
initialized to nul 1 ptr by the constructor when the list is created . This indicates that the 
list is initially empty. 

Figure 17-3 
Figure 17-4 
Figure 17-5 
17.2 Linked List Operations 
1047 
The first call to add passes 2. 5 as the argument . Because the list is empty at that time, 
the code 
head = new ListNode(num); 
is executed, resulting in the situation depicted in Figure 17-3: 
•-+I--· 
~1 
__ 
2_.s_~l._··:~-,~nullptr 
head 
There are no more statements to execute, so control returns to function main. In the 
second call to add, 7. 9 is passed as the argument . The e 1 se clause of the if statement 
will be executed, setting nodePtr to point to the first node of the list, as illustrated in 
Figure 17-4. 
7.9 
num 
••--t-1--· 
~I __ z_.s_~_·_.I 
, nu 11 pt r 
head 
dJ 
nodePtr 
At this point, the pointer nodePtr ->next has value nul 1 ptr, and thewhi 1 e loop terminates. 
The statement 
nodePtr - >next = new Lis tNode(num); 
which follows the loop, is then executed, giving the situation depicted in Figure 17-5. 
The function then returns. 
• I 
I I 2.5 
• I · I 
7.9 
• I 
, nullptr 
head 
dJ 
nodePtr 
The value 12. 6 is passed on the third call to add. Again, control will flow to the else 
clause of the if statement because the list is nonempty. The pointer nodePtr will be set 
to the beginning of the list as shown in Figure 17-6. 

1048 
Chapter 17 
Linked Lists 
Figure 17-6 
Figure 17-7 
Figure 17-8 
I • I 
head 
• I · I 
2.5 
• I 
-1--~• ._l 
__ 1_.9 
_ _.__•_.I, 
nullptr 
head dJ 
num=12.6 
nodePtr 
Because nodePtr - >next is not nul 1 ptr , the whi 1 e loop executes, resulting in the situation 
illustrated in Figure 17-7. 
• I · I 
2.5 I • · I 
7.9 
---~l_••_
-_:-~•~nullptr 
head 
dJ 
num=12.6 
nodePtr 
At this point, the whi 1 e loop terminates , and the statement 
nodePtr - >next = new Lis tNode(num); 
that comes after the whi 1 e loop is executed. This gives the situation depicted in Figure 17-8. 
, 
.__I _2_.5_ ...... 
I __ ... :--· 
._I __ 1._9_.._I 
_ .... 
_ -1_. ---· 
I 
12.6 
dJ 
• I , nullptr 
nodePtr 
Linked Lists in Sorted Order 
It is sometimes useful to keep elements added to a linked list in sorted order. For example, 
the list may maintain its elements in ascending order, meaning that each element in the list 
is less than or equal to its successor. In these cases, we cannot add elements to the list by 
putting them at the end of the list as in the add function of the Numberl i st class because 
doing so would violate the order of the elements in the list. A different approach is needed. 
Consider a class SortedNumberl i st that maintains its elements in ascending order. It is 
similar to the NumberL i st class, except the add function is modified so that it keeps the 
list in sorted order when placing new elements . Because a sorted list is still a list, it 
makes sense to use inheritance and derive it from NumberL i st. 

Content s of SortedNumberl i st. h 
1 #include 
"Numberlist
.h" 
2 class 
SortedNumberlist 
: public Numberlist 
3 { 
4 public : 
5 
void add(double 
number); 
6 } ; 
Inserting a Node into a Sorted List 
17.2 Linked List Operations 
1049 
Supp ose that we have a linked list of numbers that is sorted in ascend ing order. We 
want to write the add function so that it inserts its argument number in the list at a 
position that leaves the list sorted. 
There are two cases to cons ider. The first case is when the new number to be inserted 
sho uld go before every node already in the list. Thi s happens when the list is either 
empty, or the first number in the list is greater or equa l to num: 
if 
(head == nullptr 
I I head->va lu e >= number) 
head = new ListNode(number, 
head ); 
Note that the order of these two tests should not be reversed: you should make sure 
that head is not null ptr before you try to access head- >val ue: Trying to evaluate the 
expression head - >va 1 ue will result in a run -time error if head is nul 1 pt r . 
The second case that should be considered is when the new number needs to go after one 
of the nodes already in the list. In this case, the new number will need to be placed just 
before the first node that has a value greater than or equal to the number. To locate such a 
node, we use a pointer called nodePtr. We will start nodePtr at the second node and then 
keep moving it forward in the list until it falls off the end of the list (this will happen when 
nodePtr becomes nul 1 ptr) or it points to a node whose value is greater than or equal to 
number (this will happen when the expression nodePtr - >val ue >= number becomes true). 
In order to insert the new node just before nodePtr, we will need a pointer to the node that 
precedes the one that nodePtr points to. To this end, we use a pointer previousNodePtr 
that always points to the node previous to the one that nodePtr points to. The whole 
process of finding the insertion point is accomplished by the following code: 
previousNodePtr 
= head; 
nodePtr = head- >next; 
II 
Find the insertion 
point 
whi le (nodePtr 
!= nullptr 
&& nodePtr ->value 
< number} 
{ 
} 
previousNodePtr 
= nodePtr ; 
nodePtr = nodePtr - >next; 
The entire function , including the code for creating a new node and inserting it at the 
point just after previ ousNodePtr but before nodePtr , is given here: 
Content s of SortedNumberl i st. h 
1 #include 
"SortedNumberlist.h" 
2 
3 //********************************************* 
4 II Adds a number to the sorted 
list. 
* 
5 II This funct ion overr i des add in Numberl is t . * 
6 //********************************************* 

1050 
Chapte r 17 
Lin ked Lists 
7 void SortedNumberList
::a dd (doub le number) 
8 { 
9 
ListNode *nodePtr, 
*pr eviousNodePt r; 
10 
11 
if (head --
nul lptr 
I I head - >valu e >= number ) 
12 
{ 
13 
II A new node goes at the begi nning of the l i st 
14 
head= 
new ListNode (number , head); 
15 
} 
16 
el se 
17 
{ 
18 
previousNodePtr 
= head ; 
19 
nodePtr = head - >next; 
20 
21 
II Find the insertion 
point 
22 
while 
(nodePtr 
!= nullptr 
&& nodePtr - >value 
< number) 
23 
{ 
24 
25 
26 
} 
previousNodePtr 
= nodePtr; 
nodePt r = nodePtr - >next ; 
27 
II Insert 
the new node just 
before 
nodePtr 
28 
previousNodePtr
- >next = new Li stNode(number, 
nodePtr); 
29 
} 
30 } 
Program 17-4 is a program that uses the add function. A discussion of how the function 
works follows the program . 
Program 17-4 
1 II Thi s program illustrates 
the NumberLi st append, 
2 II insert, 
and displayList 
member funct i ons . 
3 #include 
"SortedNumberList.h" 
4 
5 int main() 
6 { 
7 
Sorted NumberList 
list
; 
8 
9 
II Add ele ments in order 
10 
list
.a dd (2 .5); 
11 
list
.a dd (7 .9); 
12 
list
.a dd (12 .6); 
13 
II Add a value that 
should go i n the mi ddle of the list 
14 
list
.a dd (10 .5); 
15 
II Display 
the list 
16 
list
.d i splayList
(); 
17 
cout << endl; 
18 
ret urn O; 
19 } 
Program Output 
2.5 
7.9 
10.5 
12.6 

Figure 17-9 
• I 
head 
17.2 Linked List Operations 
1051 
Like Program 17-3, Program 17-4 starts out by building a list with the values 2.5, 
7.9, and 12.6. Because of the order of add ition to the list, each of these values is 
handled by the i f clause in lines 11- 15 of SortedNumberl i st . cpp. Th e add funct ion 
is then called with argument 10.5. This time, the el se part in lines 16- 26 is executed. 
Th e statements 
previousNodePtr 
= head; 
nodePtr = head- >next; 
are executed, giving the situation depicted in Figure 17-9. 
previousNodePtr 
cp 
. I 
2.5 
I I . I 
nodePtr 
cp 
7.9 
• I . I 
10.5 
number 
12.6 
• I , nullptr 
Th e whi 1 e loop then executes once, leaving the state of the linked list as shown in 
Figure 17-10. 
Figure 17-10 
I I 
head 
prev i ousNodePt r 
nodePtr 
cp 
. I 2.5 
• I . I 7.9 
• I cp 
. I 12.6 
• I , nullptr 
10.5 
number 
At this point, node Pt r->va 1 ue is greater than or equal to number, so the loop terminates. 
The statement after the loop is executed : 
previousNodePtr->next 
= new List Node(number, nodePtr ); 

1052 
Chapte r 17 
Linked Lists 
This final state of the list is illustrated in Figure 17-11. 
Figure 17-11 
• I 
head 
previousNodePtr 
nodePtr 
cp 
cp 
· I 
2.5 
• I 
7.9 
T 
12.6 
• I , nullptr 
I 
l 
+ 
10.5 
• I 
This leaves the list in its final state . If you follow the links from the head pointer to the 
null ptr, you will see that the nodes are stored in the order of their value members. 
~ 
Checkpoint 
a 
VideoNot e 
Removing an 
Element from 
a Linked List 
17.5 What is the difference between appending a node to a list and inserting a node 
into a list? 
17.6 Which is easier to code, appending or inserting? 
17. 7 
Why does the i nsertNode function shown in this section use a previ ousNodePt r 
pointer? 
Removing an Element 
Removing an element from a linked list requires a number of steps: 
1. Locating the node containing the element to be removed 
2. Unhooking the node from the list 
3. Deleting the memory allocated to the node 
The remove member function uses a pointer nodePtr to search for a node containing the 
value number that is to be removed. During this process, a second pointer previ ousNodePtr 
trails behind nodePt r, always pointing to the node preceding the one pointed to by nodePt r. 
When nodePt r points to the node to be deleted, previ ousNodePt r- >next is set to 
nodePtr ->next. This causes the successor pointers in the list to bypass the node containing 
number, allowing its memory to be freed using delete. The entire function is shown here: 
25 //********************************************** 
26 II Removes a number from a list. 
The function 
27 II does not assume that 
the list 
is sorted . 
* 
* 
28 //********************************************** 
29 void Numberlist ::r emove(double number) 
30 { 
31 
ListNode *nodePtr , *prev i ousNodePtr; 
32 
33 
II If the list 
is empty , do nothing 
34 
if (!hea d) return ; 
35 
36 
II Determine if the fi rst node is the one to delete 
37 
if (head->value 
== number) 

17.2 Linked List Operations 
1053 
38 
39 
40 
41 
42 
43 
44 
45 
46 
47 
48 
{ 
} 
nodePtr 
= head ; 
head= 
head - >next; 
delete 
nodePtr; 
el se 
{ 
II Initial
ize nodePtr to the head of the list 
nodePtr 
= head ; 
II Skip nodes whose value member is not number 
49 
whi le (nodePtr 
!= nullptr 
&& nodePtr -> value 
!= number) 
50 
51 
52 
53 
54 
55 
56 
57 
58 
59 
60 
61 
} 
62 } 
{ 
} 
previousNodePtr 
= nodePtr ; 
nodePtr = nodePtr - >next; 
II Link the previous 
node to the node after 
II nodePtr, 
then delete 
nodePtr 
if (nodePtr } 
{ 
} 
previousNodePtr
- >next = nodePtr ->ne xt; 
delete 
nodePtr ; 
Notice 
that the remove (} function 
is a member of NumberL i st rather 
than 
SortedNumberL i st. Unlike add (}, the remove () function works with both sorted and 
unsorted lists and so does not have to be overridden . Th e file RNumberL i st. cpp, found on 
the book's companion website, is a simple modification of the NumberL i st . cpp: It simply 
adds the implementation of remove() . Program 17-5 demonstrates this new function by 
first building a list of three values and then removing the values one by one . 
Program 17-5 
1 II This program demonstrates 
the remove member funct ion. 
2 #include 
"NumberList.h" 
3 using namespace std ; 
4 
5 int main() 
6 { 
7 
NumberList list
; 
8 
9 
II Build the list 
10 
list.add(2.5
); 
11 
list.add(7.9
); 
12 
list.add(
12 .6 }; 
13 
14 
II Display 
the list 
15 
cout << "Here are the initial 
values:\n"; 
16 
list.displayList
(); 
17 
cout << "\n\n"; 
(program continues) 

1054 
Chapte r 17 
Lin ked Lists 
Program 17-5 
(continued) 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 
29 
30 
31 
32 
33 
34 
35 
36 
37 
38 
39 } 
// Demonstrate the remove funct i on 
cout 
<< "Now removi ng the value in the middle.\n"; 
l i st.remove(7.9); 
cout 
<< "Here are the values left.
\ n"; 
l i st.displaylist(); 
cout 
<< "\n\n"; 
cout 
<< "Now removing the l ast value . \n"; 
l i st.remove(12.6); 
cout 
<< "Here are the values left.
\ n"; 
l i st.displaylist(); 
cout 
<< "\n\n"; 
cout 
<< "Now removing the only remai ning value.\n"; 
l i st.remove(2.5); 
cout 
<< "Here are the values left.\n"; 
l i st.displaylist(); 
cout 
<< endl; 
return 
O; 
Program Output 
Here are the initial 
values: 
2.5 
7.9 
12.6 
Now removing the value in the middle. 
Here are the values 
left. 
2.5 
12.6 
Now removing the last 
value. 
Here are the values 
left. 
2.5 
Now removing the only rema1n1ng value. 
Here are the values 
left. 
To illustrate how remove works, we will step through the first call, the one that 
removes 7.9 from the list. Thi s value is in the middle of the list. 
Look at thee 1 se part of the second if statement, lines 44- 61. Th is is where the function 
will perform its action because the list is not empty and the first node does not contain 
the value 7.9. Just like the sorted list version of add (), this function uses nodePtr and 
previ ousNodePtr to traverse the list. The whi 1 e loop terminates when the value 7.9 is 
located . At this point, the list head and the other pointers will be in the state depicted 
in Figure 17-12. 

17.3 A Linked List Temp late 
1055 
Figure 17-12 
previousNodePtr 
nodePtr 
•-+I--· ~1 
__ 2_.s _ _._:•:;I- -· ~1 
__ 1_.9 _ _.__••_-_:I--· ~1_1_2_._6_...._'_.I , nullptr 
head 
Next, the following statement executes. 
prev i ousNodePt r->next = nodePtr - >next; 
This statement causes the links in the list to bypass the node that nodePtr points to. 
Although the node still exists in memory, this removes it from the list, as illustrated in 
Figure 17-13. 
Figure 17-13 
previousNodePtr 
nodePtr 
cp 
cp 
I I 
I I 2.5 I j I 
7.9 
I I · I 12.6 
I I , nullptr 
head 
t 
The last statement uses the de 1 ete operator to free the memory used by the deleted node. 
~ 
Checkpoint 
17.3 
17.8 What are the two steps involved in deleting a node from a linked list? 
17.9 When deleting a node, why can't you just use the dele t e operator to remove it from 
memory? Why must you take the steps you listed in response to question 17.8? 
17.10 In a program that uses several linked lists, what might eventually happen if the 
class destructor does not destroy its linked list? 
A Linked List Template* 
A major limitation of the NumberL i st class is that it can only hold values of type doub 1 e. 
A list class is most useful when it can be used to hold values of different types. The 
Li nkedL i st class, which we will cover next, uses templates to achieve type flexibility. 
It uses the same logic as the NumberL i st class. 
*This section should be skipped if Chapter 16 has not yet been covered. 

1056 
Chapte r 1 7 
Linked Lists 
Content s of Li nkedl i st. h 
1 #include 
<i ostream> 
2 using namespace std; 
3 template 
<class 
T> 
4 class 
Linkedlist 
5 { 
6 protected: 
7 
II Declare 
a class 
for the list 
node 
8 
struct 
ListNode 
9 
{ 
T value; 
Li stNode *next; 
10 
11 
12 
13 
ListNode (T value1, 
ListNode *next1 = nullptr) 
{ 
14 
value= 
value1; 
15 
next= 
next1; 
16 
} 
17 
}; 
18 
ListNode *head; 
19 public: 
20 
LinkedList(} 
{head= 
nullptr; 
21 
22 
23 
24 
25 } ; 
26 
-Li nkedLi st (); 
voi d add(T value); 
voi d remove(T value); 
voi d di splayList
() const; 
} 
II List head pointer 
II Constructor 
II Destructor 
27 //***************************************************** 
28 II Adds a new element to the end of the list. 
* 
29 //***************************************************** 
30 template 
<class 
T> 
31 void Li nkedList<T>: :add(T value) 
32 { 
33 
if (head== 
nullptr) 
34 
head= 
new ListNode(value); 
35 
else 
36 
{ 
37 
II The list 
is not empty 
38 
II Use nodePtr to traverse 
the list 
39 
Li stNode *nodePtr = head ; 
40 
while 
(nodePtr - >next != nullptr) 
41 
nodePtr = nodePtr - >next ; 
42 
43 
44 
45 
46 
} 
47 } 
48 
II nodePtr - >next is nullptr 
so nodePtr 
points 
to last 
node 
II Create 
a new node and put i t after 
the last 
node 
nodePtr - >next = new ListNode(value); 
49 //********************************************** 
50 II Removes a number from a list. 
The function 
* 
51 II does not assume that 
the list 
is sorted. 
* 
52 //********************************************** 
53 template 
<class 
T> 
54 void Li nkedLi st<T>: :remove(T value) 

17.3 A Linked List Temp late 
105 7 
55 { 
56 
ListNode *nodePtr , *prev i ousNodePtr ; 
57 
58 
II If the l i st is empty, do nothing 
59 
if (!head) 
return
; 
60 
61 
II Determi ne if the first 
node i s the one to delete 
62 
if (head - >value --
value) 
63 
{ 
64 
nodePtr = head; 
65 
head= 
head - >next ; 
66 
delete 
nodePtr; 
67 
} 
68 
else 
69 
{ 
70 
II In i t i alize 
nodePtr 
to the head of the list 
71 
nodePtr = head; 
72 
73 
II Ski p nodes whose value member is not num 
74 
while 
(nodePtr 
!= nullptr 
&& nodePtr - >value != value) 
75 
{ 
76 
prev i ousNodePtr = nodePtr; 
77 
nodePtr = nodePtr - >next ; 
78 
} 
79 
II Link the prev i ous node to the node after 
80 
II nodePtr, 
then delete 
nodePtr 
81 
if (nodePtr) 
82 
{ 
83 
previousNodePtr
- >next = nodePtr - >next; 
84 
delete 
nodePtr; 
85 
} 
86 
} 
87
} 
88 
89 //*************************************************** 
90 II displayList 
outputs 
a sequence of all 
values 
91 II currently 
stored 
in the list. 
* 
* 
92 //*************************************************** 
93 template 
<class 
T> 
94 void Li nkedLi st<T>: :di splayList(} 
const 
95 { 
96 
97 
98 
ListNode *nodePtr = head ; 
while 
(nodePtr} 
II Start 
at head of list 
{ 
99 
II Print 
the value i n the current 
node 
100 
101 
cout << nodePtr - >value <<" 
II Move on to the next node 
102 
nodePtr 
= nodePtr - >next; 
103 
} 
104 } 
105 
". 
106 //****************************************************** 
107 II Destructor 
deallocates 
the memory used by the list. 
* 
108 //****************************************************** 

1058 
Chapte r 17 
Lin ked Lists 
109 template 
<class 
T> 
110 Link edlist<T>: 
:-Linkedl i st() 
111 { 
112 
ListNode *nodePtr = head; 
II Start 
at head of l i st 
113 
whi le (node Ptr 
!= nullptr) 
114 
{ 
115 
II garbage keeps track 
of node to be deleted 
116 
ListNode *garbage= 
nodePtr; 
117 
II Move on to the next node, if any 
118 
nodePtr 
= nodePtr - >next; 
119 
// Delete the "garbage" 
node 
120 
delete 
garbage; 
121 
} 
122 } 
Notice that the implementation of the class member functions, previously in a separate . cpp 
file, have now been folded into the header file. This has been done to avoid the tremendous 
complexities of compiling and linking a multifile program that uses templates. 
Th e template class will wor k for any data type that supp orts comparison operators 
such as == and <=. In particular, it will wor k for all nume ric types and for str i ng. 
Program 17-6 shows the template being used as a list of strings. 
Program 17-6 
1 II Thi s program demonstrates 
the linked 
list 
template 
2 II bei ng used to create 
a linked 
list 
of strings. 
3 #include 
<str i ng> 
4 #include 
"Li nkedlist.h" 
5 using namespace std ; 
6 
7 int main() 
8 { 
9 
Li nkedl i st<str
i ng> l i st ; 
10 
11 
II Build the l i st 
12 
1 i st . add ("A 1 ice" ) ; 
13 
l i st .add("Chuck"); 
14 
l i st .add("Elaine"); 
15 
l ist .add("Fran"); 
16 
17 
cout << "Here are the initial 
names:\n"; 
18 
l i st .disp l aylist
(); 
19 
cout << "\n\ n"; 
20 
21 
cout << "Now removi ng Elaine.\n\n"; 
22 
l i st .remove("Ela i ne"); 
23 
cout << "Here are the remaining 
ele ments . \ n"; 
24 
l ist .disp l aylist
(); 
25 
cout << end l; 
26 
27 
return 
O; 
28 } 
(program continues) 

Program 17-6 
(continued) 
Program Output 
Here are the initial 
names: 
Alice 
Chuck Elaine 
Fran 
Now removing Ela i ne. 
Here are the remaining elements. 
Alice 
Chuck Fran 
17.4 Recursive Linked List Operations 
1059 
Recursive Linked List Operations 
CONCEPT: 
Recursion is a useful technique for working with linked lists. 
Recursion is a useful approach to solving prob lems that can be broken down into 
smaller problems of the same type. Some data structures, such as arrays and linked 
lists, mirror this property of recursion in that a large array can be split into smaller 
arrays; and likewise, a nonempty linked list can be reduced to a smaller linked list by 
removing its first node . Because of this, both array and linked list operations are often 
well suited to a recursive solution . In this section, we will take a look at the recursive 
implementation of linked list operations . 
Let's take a look at some examples of recursive linked list operations. We will first look 
at the implementation of recursive stand -alone functions, and then later on in the section, 
we will look at how member functions of a class can be made recursive. We will use for 
our examples linked lists of numbers based on the node type 
struc t Li stNode 
{ 
) ; 
double value; 
Li stNode *next; 
Li stNode(double 
value1, 
ListNode *next1 = nullp t r) 
{ 
} 
value= 
value 1; 
next = next 1; 
We have used a structure here to represent the node for ease of presentation only. 
Normally, the node would be a class type to restrict access to its private members . 
Recall that the head of a nonempty list is the first item on the list. The tail of a nonempty 
list is the list that remains after you remove the head. For example, any list with only 
one item has the empty list for its tail. A list of numbers 2. 5, 7. 9, 12. 6 has the list 7. 9, 
12. 6 as its tail. With a declaration such as Li stNode, if a nonempty list is represented by 
a pointer pt r, the tail will be represented by ptr - >next . 
Finally, remember that a good recursive solution must be careful to identify and deal with 
base cases of the problem, that is, the subproblems resulting from the breaking down 
process that can be directly solved. In the case of linked lists, the process will often involve 

1060 
Chapte r 17 
Linked Lists 
breaking a list down by separating it into its head and tail, and then recursively solving the 
problem on the tail. The base case will usually be when the list on which the operation is to 
be performed is empty, or in some cases, has only one item. 
Recursive List Functions 
Let's write some recursive linked list functions. The function 
i nt size(ListNode 
*ptr) 
takes as parameter a pointer to the head node of a linked list and returns the number 
of elements stored in the list. If the list is empty, its size is zero: 
if (ptr == nullptr) 
return 
O; 
But if a list is nonempty, its size will be one more than the size of its tail: 
if (ptr 
!= nullptr) 
return 
1 + siz e(ptr ->next); 
Putting these two observat ions together, we arrive at the following code for the size() 
function: 
i nt size(ListNode 
*ptr) 
{ 
if (ptr == nullptr) 
return 
O; 
else 
return 
1 + size(ptr
- >next); 
) 
Consider now a recursive strategy for a function 
voi d di splaylist(ListNode 
*ptr) 
that takes a pointer to the head node of a list and prints the list elements. There is 
nothing to print if the list is empty. To display a nonempty list, we first display the 
element stored in the head node 
cout << ptr ->value <<" 
". 
' 
and then recursively display the tail of the list. Because the tail of the list is given by 
ptr ->next, we arr ive at the following code: 
voi d di splaylist(ListNode 
*ptr) 
{ 
i f (ptr 
!= null ptr ) 
{ 
cout << ptr - > value << 
II 
". 
' 
di splaylist(ptr
- >next); 
) 
) 
Program 17-7 gathers these two functions together and illustrates their use. The 
program reads data from a file Numberfi 1 e . dat that can be found on the book's 
companion website. 

17.4 Recursive Linked List Operations 
1061 
Program 17-7 
1 II Thi s program illustrates 
recursion 
on linked 
lists
. 
2 #include 
<iostream> 
3 #include 
<fstream> 
4 using namespace std ; 
5 
6 struct 
ListNode 
7 
{ 
8 
double value; 
9 
ListNode *next; 
10 
II Constructor 
11 
ListNode(double 
value1, 
ListNode *next1 = nullptr) 
12 
{ 
13 
value= 
value1; 
14 
next
= next1; 
15 
} 
16 
} ; 
17 
18 II Function 
prototypes 
19 int si ze (Lis tNode *); 
20 void displayL i st (ListNode *); 
21 
22 int main() 
23 { 
24 
25 
26 
ListNode *numberLi st = nul lptr ; 
double number; 
27 
II Open the fi le 
II List of numbers 
II Used to read the file 
28 
ifstream 
numberFile("numberFile.dat"); 
29 
if (!nu mberFile ) 
30 
{ 
31 
cout << "Error 
in opening the f i le of numbers . "; 
32 
exit (1); 
33 
} 
34 
II Read the fi le i nto a linked 
l i st 
35 
whi le (numberFile 
>> number ) 
36 
{ 
37 
II Create 
a node to hold th i s number 
38 
numberLi st = new Li stNode (number, numberList); 
39 
} 
40 
II Print 
the list 
41 
cout << endl << "The contents 
of the l i st are: 
"<< end l; 
42 
displayList(numberList); 
43 
44 
II Print 
the size of the lis t 
45 
cout << endl << "The number of items in the l i st i s : " 
46 
<< size(numberList); 
47 
return 
O; 
48 } 
49 
50 //***************************************** 
51 II length 
comput es the number of nodes i n* 
52 II a linked 
l i st 
* 
53 //***************************************** 
(program continues) 

1062 
Chapte r 1 7 
Linked Lists 
Program 17-7 
(continued) 
54 int siz e(ListNode 
*ptr) 
55 { 
56 
if (ptr == nullptr
) 
57 
return 
O; 
58 
else 
59 
return 
1 + size(ptr->next); 
60 } 
61 
62 //******************************************* 
63 II displayl
is t prints 
all 
the values 
stored* 
64 II in t he list 
* 
65 //******************************************* 
66 void displaylist
(ListNode *pt r) 
67 { 
68 
if (ptr 
!= nullptr
) 
69 
{ 
70 
71 
72 
} 
73 } 
cout << ptr - > value<<" 
di splaylist(ptr
- >next}; 
Program Output 
The contents 
of the l ist 
are: 
40 
30 
20 
10 
". 
The number of items in the list 
is: 
4 
Recursive Member Functions 
Let's write a new version of the Numberl i st class in which the member functions for 
adding an element, removing an element, and displaying the list have recursive 
implementations. The class will also have a size () function. Here is the class declaration: 
Contents of NumberL i st2. h 
1 #include 
<iostream> 
2 using namespace std ; 
3 class 
NumberList2 
4 { 
5 protected: 
6 
II Declare 
a class 
for the list 
node 
7 
struct 
ListNode 
8 
{ 
double value; 
ListNode *next; 
9 
10 
11 
12 
13 
14 
15 
ListNode(double 
value1, 
ListNode *next1 = nullptr) 
{ 
} 
16 
} ; 
value= 
value1; 
next= 
next1; 
17 
ListNode *head; 
18 public: 
19 
NumberList2( ) {head= 
nullptr; 
} 
20 
-NumberList2(); 
II List head pointer 
II Constructor 
II Destructor 

17.4 Recursive Linked List Operations 
1063 
21 
void add(double 
value) 
{head= 
add(head , value);} 
22 
void remove(double 
value) 
{head = remove(head, 
value);} 
23 
void displaylist
() cons t {displaylis
t (head};} 
24 
int siz e() const {ret urn size (hea d);} 
25 private
: 
26 
II Recursive implementa tio ns 
27 
ListNode *add (Li stNode *alist, 
double value); 
28 
ListNode *remove (ListNode *alist
, double value); 
29 
void displaylist
(li stNode *alist
) cons t ; 
30 
int siz e(lis
tNode *alis t ) const; 
31 } ; 
If you look at the class, you will notice that each pub lic member function in lines 
20- 24 has a correspond ing private member function in lines 27- 30. The private 
member funct ions provide recursive implementations 
for their public counterparts . 
Notice that each of the private member functions has a parameter of type list Node*. 
This parameter is needed for the recursion to work. 
You might wonder why we do not make the recursive functions public. The reason is 
that the parameters of type l i stNode* are implementation details and therefore shou ld 
not be exposed to the users of the class. The user of the public interface of the class does 
not need to know that the list is internally implemented using a pointer to l i stNode 
named head. 
The Recursive add Member Function 
Notice that the recurs ive add member function 
listNode 
*add(l i stNode *alist
, double value); 
takes as parameters an input list and a value and returns the list that results from 
adding the value to the input list. Technica lly, the function takes as its first parameter 
a pointer to the head of a linked list and returns a pointer to the head of the resulting 
list. Line 21 of the code listing of Numberl i st2. h shows how the recursive function is 
called to add a value to the list. 
Let's see how the add function works. If the input list is empty (base case), the function 
creates a new node containing the value and returns a pointer to that node: 
return 
new li stNode (va lue ); 
If the list is not empty, the function proceeds as follows . First, it splits the input list into 
its constit uent head node and tail. 
l i stNode *tai 1 = al i st - >next; 
I I Fix the tai 1 
ali st - >next = nullptr; 
II al is t now poi nt s to t he head 
The tail is shorte r than the original input list and is therefore closer to the base case. Using 
recursion, the function adds the value to the tail of the list, resulting in a "bigger" tail: 
listNode 
*biggerTail 
= add(tail
, value); 
Finally , the original head , which is being pointed to by al i st , is reattached to the 
bigger tail, and a pointer to the original head is returned: 
ali st - >next = big gerTail; 
II Reattach 
the head 
return 
alist
; 
II Ret urn pointer 
to augmented list 

1064 
Chapte r 17 
Lin ked Lists 
Puttin g all of this together, we get the following code for the add function : 
42 Numberlist2 : :ListNode *Numberlist2: 
:add (Li stNode *alist, 
doubl e value) 
43 { 
44 
if (alist 
== nullptr) 
45 
return 
new ListNode (valu e); 
46 
else 
47 
{ 
48 
II Split 
into constituent 
head and tail 
49 
ListNode *tai l= 
aList -> next; 
II tail 
50 
alist
->next = nul l pt r; 
II Detached head 
51 
II Recursively 
add value to tail 
52 
ListNode *biggerTail 
= add (ta i l, value); 
53 
II Reattach the head 
54 
alist
->next = biggerTail
; 
55 
II Return pointer 
to head of bigger list 
56 
return 
aList; 
57 
) 
58 } 
The code in this function can be shortened . First, notice that line 50 is not needed. The 
head does not have to be detached before making the recursive call on the tail in line 52, 
as long as it is "reattached" in line 54. Then, we can eliminate the tail variable and just 
use al i st->next in line 52. The code in the else clause then gets shortened to 
ListNode *biggerTail 
= add(aList ->next , value); 
aLi st - >next = biggerTail; 
return 
alist
; 
which can in tum be shortened to 
aLi st - >next = add(alist
->next , value); 
return 
alist; 
The add function can therefore be written as follows: 
28 NumberList2 : :ListNode *NumberList2: :add (Li stNode *alist, 
doubl e value) 
29 { 
30 
if (aLis t == nullptr) 
31 
return 
new ListNode (valu e); 
32 
else 
33 
{ 
34 
II Add the value to the end of the tail 
35 
aList ->next = add(aL is t ->next, value); 
36 
return 
aList; 
37 
} 
38 } 
The Recursive remove Member Function 
The remove function 
ListNode *remove(ListNode *alist, 
doubl e value) 
takes as paramete r an input list and a value, removes the value from the input list, and 
returns the resulting list. If the value to be removed is not on the list, the function 
returns the input list unchanged . 

17.4 Recursive Linked List Operations 
The function works as follows . If the list is empty, the function returns nul 1 ptr . 
i f(alis
t == nullptr) 
return 
nullptr; 
Otherwise, the function compares the value to what is stored in the first (head) node of 
the list. If the value is found there, the head node (pointed to by al i st) is deleted and 
the function returns the tail: 
i f (al i st - >value == value) 
{ 
} 
Li stNode *t ai l = aLis t- >next; 
dele t e aList; 
re t ur n tail; 
The last case considered is when the list is not empty and the head of the list does not 
contain the value to be removed. In this case, the function recursively removes the 
value from the tail of the list, reattaches the original head to the modified tai l, and 
returns a pointer to the head of the (possibly) modified list. Using the same reasoning 
as in the add ( ) function, we can write this case as 
aLi st - >next = remove(aL i st - >next, 
value}; 
return 
alis t ; 
Again putting it all together, we get the complete function as found lines 10- 60 of the 
implementation 
file Numberl i st 2 . cpp . 
Contents of NumberL i st2. cpp 
1 #include 
"NumberList2.
h" 
2 
3 //******************************************* 
4 II Ret urns the number of elemen t s i n a lis t
* 
5 II 
****************************************** 
6 i nt NumberLi st2: :size(ListNode 
*aList) 
const 
7 { 
8 
if 
(alis
t == nullptr) 
9 
retur n O; 
10 
else 
11 
retur n 1 + size(aL i st - >next); 
12 } 
13 
14 //******************************************* 
15 II Prints 
all 
elemen t s stored 
in a list 
* 
16 //******************************************* 
17 void NumberLis t 2: :display
List(Lis
t Node *aLis t ) const 
18 { 
19 
if 
(alis
t 
!= nullptr) 
20 
{ 
21 
22 
23 
} 
24
} 
cout 
<< aLis t- >value 
<<" 
di splayLis
t (a Li st - >next}; .. 
25 //*********************************************** 
26 II Adds a value at the end of a list 
* 
27 //*********************************************** 
28 NumberList2: :Lis t Node *NumberList2: :add(ListNode 
*alist, 
double 
value} 
29 { 
30 
if 
(aLis t == nullptr) 
1065 

1066 
Chapte r 17 
Lin ked Lists 
31 
return 
new ListNode (valu e ); 
32 
else 
33 
{ 
34 
II Add the value to the end of the tail 
35 
alist
- >next = add(aList
- >next, 
value); 
36 
return 
aList; 
37 
) 
38 ) 
39 
40 NumberList2 : :ListNode *NumberList2 : :r emove(ListNode *aList, 
double value) 
41 { 
42 
if (aLis t == nullptr) 
return 
nullptr; 
43 
II The list 
is not empty 
44 
45 
II See i f value is first 
on the l i st 
46 
II If so, delete 
the value and return 
the tai l 
47 
if (aLis t - >valu e == value) 
48 
{ 
49 
ListNode *tail= 
aLi st - >next; 
50 
delete 
aList ; 
51 
return 
tai 1 ; 
52 
) 
53 
else 
{ 
54 
55 
56 
II value is not the first 
on the list 
II Return the list 
wi th the value removed 
57 
II from the ta i l of the list 
58 
alist
- >next = remove(aList
- >next, 
value); 
59 
return 
aList; 
60 
) 
61 ) 
62 
63 NumberLi st2: :-NumberList2() 
64 { 
65 
66 
67 
ListNode *ptr 
whi le (pt r != 
{ 
= head; 
null ptr) 
68 
II Point to the node to be deleted 
69 
ListNode *garbage= 
ptr; 
70 
II Go on to the next node 
71 
pt r = ptr - >next; 
72 
II Delete the current 
node 
73 
delete 
garbage; 
74 
} 
75 } 
76 
77 
Program 17-8 demonstrates the use of these member functions. 
Program 17-8 
1 II Thi s program demonstrates 
the recurs i ve member 
2 II functions 
of the Numberlist2 
class. 
3 #include 
"NumberList2.h" 
4 
5 int main() 
(program continues) 

Program 17-8 
(continued) 
6 { 
7 
Numberl is t2 list
; 
8 
doub l e number ; 
9 
l i st . add ( 23) ; 
10 
l i st . add ( 17) ; 
11 
l i st . add ( 59) ; 
12 
cout 
<< "The members of the l ist 
are: ... 
' 
13 
l i st.displaylist(); 
14 
cout 
<< 
II \n"; 
15 
cout 
<< "Ent er a number to add : ... 
' 
16 
ci n >> number ; 
17 
l i st.add(number); 
18 
cout 
<< "The members of the l i st are: ... 
' 
19 
l i st.displaylist(); 
20 
cout 
<< 
II \n"; 
21 
cout 
<< "Enter a number to re move : ". 
' 
22 
ci n >> number ; 
23 
l i st.remove(number); 
24 
cout 
<< "The members of the l i st are: ... 
' 
25 
l i st.displaylist(); 
26 
cout 
<< 
II \n"; 
27 
return 
O; 
28 } 
Program Output with Example Input Shown in Bold 
The members of the list 
are: 
23 
17 59 
Enter a number to add: 89 
The members of the list 
are: 
23 
17 59 
89 
Enter a number to remove: 17 
The members of the list 
are: 
23 59 
89 
17.5 
Variations of the Linked List 
17.5 Variations of the Linked List 
1067 
CONCEPT: 
Th ere are many ways to link dynamically allocated data structures 
together. Two variatio ns of the linked list are the doubly linked list and 
the circular linked list. 
The linked list examples that we have discussed are singly linked lists: Each node is 
linked to a single other node. A variation of this is the doubly linked list. In this type of 
list, each node points not only to the next node, but also to the previous one. This is 
illustrated in Figure 17-14. 
Figure 17-14 
J 
I • I · 
List Head I I I • I 
' 
t 
-
I 
I I • I 
' 
-
f 
t 
f 
null ptr 
nullptr 

1068 
Chapte r 17 
Lin ked Lists 
In Figure 17-14, the last node and the first node in the list have pointers to the nul 1 ptr 
address. When the program traverses the list, it knows when it has reached either end . 
Another variat ion is the circular linked list. Th e last node in this type of list points to 
the first, as shown in Figure 17-15. 
Figure 17-15 
17.6 
I 
G-
I • I I I • I 
• 
List Head 
I 
I • I 
I --.-..-. 
I 
The STL 1 i st Container* 
CONCEPT: 
Th e Standard Template Library provides a linked list contain er. 
The 1 i st container, found in the Standard Template Library, is a template version of a 
doubly linked list. STL 1 i sts can insert elements or add elements within the list more 
quickly than vectors can because lists do not have to shift the other elements. Lists are 
also efficient at adding elements at their back because they have a built-in pointer to 
the last element in the list (no traversal required). 
Table 17-1 describes some of the 1 i st member functions . 
*This section should be skipped if Chapter 16 has not yet been covered. 
Table 17-1 Selected List Member Funct ions 
Member 
Function 
back 
erase 
empty 
end 
front 
Examples and Description 
cout << list.back
() << endl; 
Th e back member function returns a reference to the last element in the list. 
l i st .er ase(iter); 
l i st .er ase(firstlter, 
lastlter
) 
Th e first form causes the list element pointed to by the iterator i ter to be removed . 
Th e second form causes all of the lis t elements from firstlter 
to lastlter 
to 
be removed . 
if (l is t .empty()) 
Th e empty member function returns true if the 1 i st is empty. It returns false if 
the 1 i st has elements. 
iter 
= list
.end (); 
end returns an iterator to the end of the list. 
cout <<list
.front()<< 
endl ; 
front returns a reference to the first element of the 1 i st. 
(table continues) 

17.6 The STL 1 i st Containe r 
1069 
Table 17-1 Selected List Member Funct ions (continued) 
Member 
Function 
Examples and Descri ptio n 
insert 
l i st .i nsert(iter, 
x) 
Th e insert 
member function inserts an element into the l i st. Th e example inserts 
an element with the value x, just before the element pointed to by i ter. 
merge 
l i st1.merge(list2); 
Th e merge member fun ction expects both l i st 1 and l i st2 to be already sorted . 
Every element of l i st2 will be inserted into list 1 in such a way that the expanded 
l i st 1 remains sorted. 
pop_back 
l i st . pop_back(); 
pop_back removes the last element of the list. 
pop_front 
l i st . pop_front(); 
pop_front removes the first element of the list . 
push _back 
l i st . push _back(x); 
push _back inserts an element with value x at the end of the list. 
push _front 
l i st . push _front(x); 
push _front inserts an element with value x at the beginning of the list. 
reverse 
l i st . reverse(); 
reverse 
reverses the order in which the elements appear in the list . 
si ze () 
Returns the number of elements in the list. 
swap 
l i st1.swap(list2) 
Th e swap member function swaps the elements stored in two lists. For example, 
assuming l i st1 and l i st2 are lists, the statement shown will exchange the val ues 
in the two lists. 
unique 
l i st . uni que(); 
unique eliminates dupli cate val ues by removing any element that has the same 
value as the element before it. 
Program 17-9 demonstrates 
some simple operations with the STL lists. 
Program 17-9 
1 // Thi s program demonstrates 
the STL list 
container
. 
2 #include 
<iostream> 
3 #include 
<list> 
// Include 
the list 
header 
4 using 
namespace std ; 
5 
6 int 
main() 
7 { 
8 
list<int> 
mylist; 
9 
list<int>: 
:it erator 
iter; 
10 
11 
// Add values 
to the list 
12 
for 
(int 
x = O; x < 100; x += 10) 
13 
mylist.push
_back(x); 
14 
15 
// Di splay 
the values 
(program continues) 

10 70 
Chapte r 17 
Linked Lists 
Program 17-9 
(contin ued) 
16 
for (it er = myList. begi n(); 
iter 
!= mylis t .end(); it er ++) 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 
27 
28 } 
cout << *i te r 
cout << endl ; 
<< 
II 
II• 
' 
II Now r eve r se the orde r of t he ele ment s 
myList.
r eve r se (); 
II Di spl ay t he val ues again 
for (it er = myList. begi n(); 
iter 
!= mylis t .end(); it er ++) 
cout << *i te r 
cout << endl ; 
re turn O; 
<< 
II 
II• 
' 
Program Output 
0 10 20 30 40 50 60 70 80 90 
90 80 70 60 50 40 30 20 10 0 
Choosing Between Raw and Smart Pointers 
Smart pointers are designed to solve three problems that arise in programs that use dynamically 
allocated memory. The prob lems are memory leaks due to failure to delete memory; 
premature deletion of memory that is still in use; and double deletion, where a program 
deletes the same memory more than once. The root of all these problem is lack of clarity as to 
who has ownership and responsibility for deleting a dynamically allocated object. C++ 11 
provides three types of smart pointers to solve these problems. An important question is 
whether we should always use smart pointers in preference to raw pointers in programs . 
We have opted to use raw pointers in our work with the linked list class. There are several 
reasons for this decision. First, the linked list class is the sole owner of the head node pointer 
and all nodes reachable through it, so there is never any doubt as to who has responsibility 
for deleting nodes. This reason alone would make the use of smart pointers unnecessary. 
But there are other reasons not to use smart pointers. Almost all operations on linked lists 
require the use of auxiliary pointers to traverse lists of nodes. The node pointers and the 
auxiliary pointers cannot be uniqu e_ptr objects because the uni que_pt r class does not 
allow assignment. You should never mix raw pointers and smart pointers, so if you decide to 
go with smart pointers, you have to go with shar ed_ptr all the way. Shared pointers carry 
the overhead of maintaining shared groups, so this will somewhat slow down your program. 
Even worse, you can have memory leaks if you use shar ed_ptr with circularly linked lists 
and doubly linked lists. Under these circumstances, you can have a pointer to a head node 
that is in a circle of nodes that point to each other with shared pointers. In such a circle, the 
shared pointer groups associated with each node will have a reference count of 1, except for 
the head node, which will have a reference count of 2. When the pointer to the head node 
detaches, all nodes in the circle will have a reference count of 1, so none of them will ever be 
deleted. You can try to use weak pointers to mitigate this problem, but it will still be messy. 

17.7 
17.7 Reliable Software Systems, Inc., Case Study 
1071 
Reliable Software Systems, Inc., Case Study 
Problem Statement 
Reliable Software Systems, Inc., writes and markets C++ class libraries for use by programmers 
worldwide. One of the company's producrs is a library package that includes the NumberL i st 
class introduced in Section 2 of this chapter. Its customers need to use the class in programs 
in which copies and assignment of NumberL i st objecrs will occur. You have been asked to 
modify the class to support a copy constructor and an assignment operator. 
Planning for the Changes and Class Design 
At least two functions need to be added to the NumberL i st class. Rather than modifying 
the original class, you opt to use inheritance to create a new class with the requested 
enhancements. 
Both copy constructor and assignment need to make a copy of the 
linked list of nodes inside of the NumberL i st object being copied . To avoid duplication 
of code, we will add a member function 
ListNode *copyList(ListNode 
*aList); 
that creates and returns a distinct copy of a list of nodes. In addition, the assignment 
operator, when applied as in the statement 
X: 
y; 
will need to deallocate storage allocated to the linked list in the NumberL i st object x. 
Accordingly, we add a member function 
voi d destroyList(ListNode 
*aList); 
to the class. The result of this design work is the Rel i abl eNumberL i st class shown in 
the listing of the Re 1 i ab 1 eNumberL i st. h file. 
Contents of Rel i abl eNumberL i st . h 
1 #include 
"numberlist
.h" 
2 
3 class 
Rel i ableNumberList 
public 
NumberList 
4 { 
5 public : 
6 
II Copy constructor 
7 
Rel i ableNumberList(const 
ReliableNumberList& 
original); 
8 
// Now we need a default 
constructor 
9 
Rel i ableNumberList(){} 
10 
// Assignment operator 
11 
Rel i ableNumberList& operator=(Rel
i ableNumberList 
12 private
: 
13 
14 
15 } ; 
static 
ListNode* copyLi st(ListNode 
*aLis t ); 
static 
void destroyList(ListNode 
*aLis t ); 
r i ght); 
We have added a default constructor (line 9) to allow lists that are initially empty to be 
created . Notice that the auxiliary functions copyL i st and dest royL i st are declared 
static . This is because they are generic utility functions that do not require access to 
specific NumberL i st objects to do their job. 

1072 
Chapte r 17 
Linked Lists 
Implementation 
of Class Member Functions 
We adop t a recursive strategy for implementing copyl i st and destroyl i st. If a list is empty, 
copyli st returns nul 1 ptr. If a list is not empty, then the function creates a copy of the head 
node, attaches it to a recursively created copy of the tail, and returns the resulting list. 
Consider now the working of destroyl i st. Th ere is nothing to destroy if the argument 
list is empty . If the argument list is nonempty, the function recursively destroys the tail 
and then deallocates the storage for the head node. Th e coding details for both copyl i st 
and destroyl i st can be seen in the listing of Rel i abl eNumberL i st. cpp that follows. 
Having the copy l i st function makes writing the copy constructor almost trivial: Th e 
constructor simply cop ies the linked list in the existing object and assigns the result to 
the head pointer of the ob ject being created : 
head = copylist(original 
.head); 
Coding the assignment operator is not much harder. Th e operator first deallocates the 
storage for the linked list in the calling object and then assigns a copy of the list in its 
right ope rand to the head member of the calling object. 
destroylist
(head ); 
head = copylist(right.head
); 
You can find the full implementation 
deta ils and an illustrat ion of the use of this new 
class in the following listing. 
Contents of Rel i ab l eNumberL i st. h 
1 #include 
"rel iable numberlist.h" 
2 
3 //*************************************************** 
4 II Copy constructor 
* 
5 //*************************************************** 
6 Rel iab l eNumberl is t:: 
7 Rel iab l eNumberl is t(const 
Rel ia bleNumberlist& 
original) 
8 { 
9 
head= 
copylist(or
igi nal.head); 
10 ) 
11 
12 //**************************************************** 
13 II Overloaded 
Assignment 
operator 
• 
14 //**************************************************** 
15 Rel iab l eNumberl is t& 
16 Rel iab l eNumberl is t: :operator
=(Rel iab l eNumberli st r igh t) 
17 { 
18 
II First 
destroy 
the l i nked list 
i n this 
object 
19 
destroylist(head
); 
20 
II Assign a copy of the linked 
list 
in other 
object 
21 
head= 
copylist(right.head); 
22
} 
23 
24 //**************************************************** 
25 II Make a separate 
copy of the linked 
l is t i nside 
* 
26 II a ReliableNumberlist 
obje ct 
* 
27 //**************************************************** 
28 Numberlist
::L is tNode * 
29 Rel iab l eNumberl is t: :copylist(
ListNode *al is t) 

17.7 Reliable Software Systems, Inc., Case Study 
107 3 
30 { 
31 
if (alist 
== nullptr) 
32 
return 
nullp tr ; 
33 
else 
34 
35 
36 
37 
38 
{ 
39 
} 
40 } 
41 
II First 
copy the ta i l 
Li stNode *tailCopy 
= copylist(alist
- >next); 
II Return copy of head attached 
to copy of tail 
return 
new ListNode(alist
- >value, 
tai lCopy); 
42 //****************************************************** 
43 II Destroy a list 
by deallocating 
all 
of i ts nodes 
* 
44 //****************************************************** 
45 void ReliableNumberlist: 
:destroylist(Lis
tNode *alist) 
46 { 
47 
if (al ist 
!= nullptr) 
48 
{ 
49 
Li stNode *tai l= 
alist
- >next; 
50 
II Deallocate 
the head and then destroy 
the ta i l 
51 
delete 
al i st; 
52 
destroylist(tail); 
53 
} 
54 } 
Program 17-10 demonstrates the copy constructor and assignment operator that the 
preceding code adds to the Numberl i st class . 
Program 17-10 
1 II Thi s program demonstrates 
the copy constructor 
2 II and assignment 
operator 
added to Numberlist
. 
3 #include 
"rel i ablenumberlist.h" 
4 int main() 
5 { 
6 
7 
8 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25 
26 } 
Rel i ableNumberlist 
squarelist, 
cubelist; 
II Store 
values 
i n the two lists 
for (i nt k = 1; k <= 5; k++} 
{ 
squarelist.add(k*k); 
cubel i st .add(k*k*k); 
} 
II Use copy constructor 
to create 
a third 
list 
Rel i ableNumberlist 
otherlist(squarelist); 
cout << "Result 
of the copy constructor 
is: 
"· 
otherlist.displaylist(); 
cout << endl; 
II Use the ass i gnment operator 
otherlist 
= cubelist; 
cout << "Result 
of assignment 
is: 
otherlist.displaylist(); 
cout << endl; 
return 
O; 
.. 
(program continues) 

1074 
Chapte r 17 
Linked Lists 
Program 17-10 
(continued) 
Program Output 
Result 
of the copy constructor 
is: 
Result 
of assignment 
i s: 
1 
4 
9 
16 
25 
1 
8 
27 
64 
125 
17.8 
Tying It All Together: More on Graphics 
and Animation 
In prev ious chapters you learned how to use text -based graph ics to draw and animate 
simple geometr ic shapes like straight lines, rectang les, and triang les. The techniques 
you learned can be extended to more complex shapes and figures . 
Before you can draw a shape, you must determine the screen coordinates 
of the 
characters that will form both its outline and interior. For examp le, consider the slanted 
line segment shown in Figure 17-16. 
Figure 17-16 
• 
• 
• 
T he line starts at (0, 0) and ends at (3, 3) and is drawn by placing aster isks at the screen 
coordinates (0, 0), (1, 1), (2, 2), and (3, 3). 
Representing 
Shapes with Image Maps 
More generally, a figure or shape may consist of several parts. Each of the individua l parts 
making up the figure may be a line segment, a geometric shape such as a rectang le or 
triangle, or some other type of shape. It is convenient to use an array of coordinates to 
specify a part of a mult i part figure and then combine the arrays into a single list that defines 
the whole figure. We use the term image map to refer to the list of coordinates that specifies 
a shape to be drawn . 
Let us design the class that will be used to represent image maps . An image map is a list 
of coordinates, 
so we make the class a subclass of the STL type 1 i st<COORD>. In 
addit ion, we define a member function 
voi d add(COORD coordArray []); 
to allow us to add an array of coordinates to the list. We mark the end of the coordinate 
array by storing a COORD 
value of (- 1, - 1) as the last element of the array . 
Here is a pre liminary declarat ion of an ImageMap class: 
class 
ImageMap: l i st<COORD> 
{ 
publ i c: 
// Add an array 
of coordinates 
t o the image map 
voi d add(COORD coordArray [] ) 

{ 
} 
} 
17.8 Tying It All Together: More on Graphics and Animation 
1075 
for( i nt k = O; coordArray [k] .X != - 1; k++) 
{ 
push_back(coordArray
[k]); 
} 
As an examp le, the line from (0, 0) to (3, 3) would be represented by the code 
ImageMap l ine; 
COORD lineCoords
[J = {{0,0}, 
{1 ,1}, {2,2}, 
{3,3}, 
{- 1, - 1}}; 
line.add(
l ineCoords); 
Initia lizing an array of coordinates in this manner and then adding it to the image map 
is very handy and is a vast improvement over the alternative of using push_back to add 
the coordinates to the image map one at a time: 
ImageMap l ine; 
COORD pos; 
pos.X = O; 
pos.Y = O; 
line.push
_back(pos); 
pos.X = 1 ; 
pos.Y = 1 ; 
line.push
_back(pos); 
// Rest of the code is omitted 
The braces { } that go around a single COORD object in the initialization of the 
1 i neCoords array are tedious to insert, particularly when the array has a lot of elements. 
We will therefore consider an alternative notation for initializing the image map. The 
alternative will allow us to use an array of short integers to initialize an array of coordinates. 
An array of two short integers and a COORD 
object both consist of two short integers, and 
C++ compilers store both in memory the same way. Once stored in memory, an array of 
5 COORD 
objects is indistinguishable from an array of 10 short integers. If we write 
short 
i nt lineShorts[
J = {O, 0, 1 , 1, 2, 2, 3, 3, -1 , - 1}; 
then the array 1 i neShorts is indistinguishable from 1 i neCoords in the way the two 
arrays are stored in memory . We can use this fact to find an alternative way of initializing 
image maps that does not require as many braces . We add a second add member 
function to ImageMap, one that takes an array of short int as a parameter. The new add 
function uses a cast to convert its parameter to an array of COOR D and then calls the 
first add function . 
voi d add(short 
*coordAsShorts) 
{ 
} 
COORD *pCoord = reinterpret
_cast<COORD *>(coordAsShorts); 
add(pCoord); 
It will help you to understand why this code works if you remember that an array of 
COORD, which is what the member function add (COORD arr [ ]) expects, has the same 
type as a pointer to COORD. 

1076 
Chapte r 17 
Linked Lists 
Basics of Animation 
Now consider a video game in which a person has to run across the screen. The effect 
of running will be achieved by creating image maps of a person in successive running 
position as in Figure 17-17. 
Figure 17-17 
• • • 
• 
• 
• • • 
. . . 
• 
• 
• 
• • 
• 
• 
• 
• 
• 
• • 
• • 
•• • •• 
• • 
• 
•••• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• 
• •• . 
• • • 
•• 
• 
• • • 
• 
• 
• 
• 
The first image is displayed briefly at a certain position and then erased . Next, the 
second image is briefly displayed a little to the right of the first position and then erased. 
By successively displaying and erasing a progression of images at a series of positions in 
left to right order, we obtain the appearance of a person running . 
Implementation 
Details 
Once an ImageMap object is created, a programmer can use its add methods to incrementally 
build the list of coordinates that comprises the shape. Starting with an empty image map, the 
programmer can initialize arrays of short integers to represent different parts of the human 
body. In this way, arms, legs, torsos, and other parts of the body can be represented and 
added to the image map to form the shape of a complete person. Two additional methods, 
void displayAt(char 
ch, int col, 
int row); 
void displayAt(int 
col, 
int row); 
can be used to display the image map's shape at a given position . The first of the two 
methods specifies a fill character to be used for the outline and interior of the shape. 
The second is a convenience method - it calls the first display method and passes it the 
asterisk as fill character. Finally, the method 
void eraseAt(int 
col, 
int row); 
is used to erase the image map's shape at a specified position. The full implementation 
of the ImageMap class, and an illustration of its use to achieve graphics animation, are 
shown in the listings that follow . 
Contents of Imagemap. h 
1 #include 
<iostream> 
2 #include 
<l is t> 
3 #include 
<wi ndows.h> 
4 using namespace std; 
5 
6 const HAND
LE conso le = GetStdHandle (STD_DUTPUT_HAND
LE); 

17.8 Tying It All Together: More on Graphics and Animation 
7 
8 cl ass ImageMap:list<COORD>{ 
9 
10 publ i C: 
11 
II Add an array 
of coord i nates 
to the image map 
12 
void add(COORD coordArray[J); 
13 
II Conveni ence method for adding an array 
of coord i nates 
14 
void add(short 
*coordAsShorts); 
15 
II Display 
a given character 
at a specified 
position 
16 
void displayAt(char 
ch, i nt col, 
i nt row); 
17 
II Display 
an asterisk 
at a given pos i t i on 
18 
void displayAt(int 
col, 
i nt row) 
19 
{ 
20 
di spl ayAt('*', 
col, 
row); 
21 
) 
22 
II Erase whatever 
character 
is at a gi ven position 
23 
void eraseAt(int 
col, 
i nt row) 
24 
{ 
25 
di spl ayAt(' 
', col, 
row); 
26 
) 
27 } ; 
Contents of Imagemap. cpp 
1 #include 
"ImageMap.h" 
2 
3 //************************************************** 
4 II Adds an array of coordinates 
to the i mage map 
* 
5 //************************************************** 
6 void ImageMap::add(COORD coordArray [ J) 
7 { 
8 
for(int 
k = O; coordArray[k].X 
!= -1 ; k++ ) 
9 
{ 
10 
push_back(coordArray[k]); 
11 
} 
12 } 
13 
14 //*************************************************** 
15 II All ows an array of shorts 
to be converted 
to 
16 II an array 
of COORD. That s i mpl ifies 
the 
17 II init i ali zation 
process 
for an image 
* 
* 
* 
18 //*************************************************** 
19 void ImageMap::add(short 
*coordAsShorts) 
20 { 
21 
COORD *pCoord = reinterpret
_cast<COORD *>(coordAsShorts); 
22 
add(pCoord); 
23 } 
24 
25 //****************************************************** 
26 II Shows an image at a gi ven position. 
The i mage is 
27 II is drawn using the character 
ch 
* 
* 
28 //****************************************************** 
29 void ImageMap: :displayAt(char 
ch, int col , i nt row) 
30 { 
31 
l ist<COORD>: :iterator 
iter 
= this - >begi n(); 
32 
for(; 
iter 
!= this - >end(); 
iter++) 
1077 

1078 
Chapte r 17 
Linked Lists 
33 
{ 
34 
COORD currentPos
; 
35 
currentPos.Y 
= row + iter->
Y; 
36 
currentPos.X 
= col + iter->
X; 
37 
SetConsoleCursorPos
itio n(console , currentPos) 
; 
38 
cout <<ch<< 
endl ; 
39 
} 
40 } 
Program 17-11 demonstrate s the use of the ImageMap class. 
Program 17-11 
1 II This program illustrates 
animat i on us i ng the 
2 II ImageMap cl ass. 
3 #include 
"ImageMap.h" 
4 
5 int mai n() 
6 { 
7 
II Figure 
1 - a snapshot 
of a person running 
8 
ImageMap figure1
; 
9 
10 
11 
12 
13 
14 
15 
16 
17 
18 
II Set up the coordinates 
for the various 
body parts 
II of the person 
in the first 
running 
position 
short 
int 1 ower l eg1 [ ] = { 1 ' 10 , 2, 10, 3 , 10 , - 1' - 1} ; 
short 
int thigh1 [] = { 4 , 9 , 5 , 8 , 6, 7 , 7, 6 , - 1' - 1} ; 
short 
int thigh2[] 
= { 6 , 7, 7 , 8 , 8, 9 , -1 ' -1 }; 
short 
int 1 ower Leg2 [ ] = {8, 10 , 8 , 11 , - 1 , -1 }; 
short 
int torso [] = { 8, 5 , 9 , 4, 10, 3 , 11 , 2 , - 1 ' - 1}; 
short 
int upper Arms [ ] = { 7, 2 , 8 , 3, 9 , 
4 , 10 , 5, 11 , 6 , -1 ' - 1 
19 
}; 
20 
short 
int foreArm1[] 
= { 12, 5 , 13, 4 , - 1, -1 }; 
21 
short 
int foreArm2[] 
= {6, 3 , 5 , 4, - 1, - 1} ; 
22 
short 
int 
* f ig ure1A11Parts 
[ ] = 
23 
{ 
24 
25 
26 
lowerleg1
, lowerleg2
, thigh1 , thigh2, 
torso , 
upperArms , foreArm1, foreArm2 , 0 
} ; 
27 
II Add the coord i nates 
that 
make up the various 
body 
28 
II parts 
to the i mage map for the f ir st running 
position 
29 
int k = O; 
30 
for (i nt k = O; figure1A11Parts[k] 
!= O; k++) 
31 
f i gure1.add(figure1A1
1Parts[k
] ) ; 
32 
33 
II Figure 
2- a snapshot 
of the person 
in a 
34 
II 
di fferent 
runn i ng posit i on 
35 
ImageMap figure2
; 
36 
short 
int p2Lowerleg1[] 
= {1, 11 , 2 , 10 , 3 , 9 , - 1' - 1} ; 
37 
short 
int p2th igh 1[] = {3, 9 , 3 , 8, 3 , 7, - 1, - 1}; 
38 
short 
int p2th igh2[ ] = {4, 7 , 5 , 7, 6 , 7, - 1, - 1}; 
39 
short 
int p2Lowerleg2[] 
= {6, 8 , 6, 9 , - 1, -1 }; 
(program continues) 

17.8 Tying It All Together: More on Graphics and Animation 
1079 
Program 17-11 
40 
41 
42 
43 
44 
45 
46 
47 
short 
short 
short 
short 
short 
int 
int 
int 
int 
int 
(continued) 
p2torso[
] = {3, 6 , 
3 , 2 , 
} ; 
p2UpperArms[] = { 1 ' 
p2foreArm1 [] = { 1 ' 
p2foreArm2 [] = { 5 , 
*f ig ure2A11Parts [] 
{ 
3 , 5 , 3, 4 , 3 , 3 , 
3 , 1 ' - 1' - 1 
3 , 2, 3 , 4, 3 , 5 , 3, - 1' - 1} ; 
4 , 1 ' 5 , - 1, -1 }; 
2 , 5, 1 ' - 1, -1 }; 
= 
48 
p2Lowerleg1, 
p2th igh 1, p2thigh2 , p2Lowerl eg2 , 
49 
p2torso, 
p2UpperArms, p2foreArm1 , p2foreArm2 , 0 
50 
}; 
51 
for (i nt k = O; figure2A11Parts[k] 
!= O; k++) 
52 
f i gure2.add(figure2A1
1Parts [k] }; 
53 
54 
55 
56 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
II Figure 
3- a snapshot 
of a person 
in 
II yet another 
running 
position 
ImageMap figure3
; 
short 
int p3torso[
] = {4, 7, 4 , 6 , 4, 5 , 4 , 4 , 
4 , 3 , 4 , 2 , 4, 1 ' -1 ' -1 
} ; 
short 
int p3Thigh 1 [] = {5, 8 , 6 , 9, - 1' - 1} ; 
short 
int p3Thigh2[ ] = {3, 8 , 2 , 9, 
- 1, -1 }; 
short 
int p3Lowerleg1[] 
= {6, 10, 6 , 11 , -1 ' -1 }; 
short 
int p3Lowerleg2 [] = { 1 ' 8 , 0, 7 , - 1, -1 }; 
short 
int p3UpperArm1[] = {3, 4 , 2, 5 , - 1, -1 }; 
short 
int p3UpperArm2[] = {5, 4 , 6, 5 , - 1, -1 }; 
short 
int p3ForeArm1 [] = {3, 6 , 4 , 7, - 1' - 1} ; 
short 
int p3ForeArm2 [] = {7' 4 , 8 , 3, - 1' - 1} ; 
short 
int 
* figure3A11Parts[] 
= 
{ 
70 
p3torso, 
p3Thigh 1, p3Thigh2 , p3Lowerleg1 , 
71 
p3Lowerleg2,p3UpperArm1
, p3UpperArm2, 
72 
p3ForeArm1 , p3ForeArm2, 0 
73 
}; 
74 
75 
for (i nt k = O; figure3A11Parts[k] 
!= O; k++) 
76 
f i gure3.add(figure3A1
1Parts [k] }; 
77 
78 
// Ask Microsoft 
Wi ndows to clear 
the screen 
79 
system ( "cls")
; 
80 
//Forman 
array 
of al l three 
f i gures 
81 
ImageMap *sequence [3] = {&fig ure1 , &figure2 , &figure3} ; 
82 
83 
// Ani mate to create 
the appearance 
of 
84 
// runn i ng across 
the screen 
85 
k = O; 
86 
int pos = O; 
87 
while 
(pos <= 60} 
88 
{ 
89 
90 
91 
// Show the current 
image at the current 
pos itio n 
sequence[k]->displayAt(pos
, 3); 
S1eep(400) ; 
(program continues) 

1080 
Chapte r 17 
Linked Lists 
Program 17-11 
(continued) 
92 
93 
94 
95 
// Erase t he curren t image 
seq uence [k]- >eraseA t (pos, 3); 
// Move to next i mage i n the rotation 
and next position 
k= 
(k +1) %3; 
96 
pos = pos + 8; 
97 
} 
98 
seq uence[k] - >di spl ayAt (pos, 3); 
99 
ret urn O; 
100
} 
Review Questions and Exercises 
Fill-in-the-Blank 
1. The ____ 
points to the first node in a linked list. 
2. A data structure that points to an object of the same type as itself is known as 
a(n) ____ 
data structure . 
3. To indicate that a linked list is empty, you should set the pointer to its head to the 
value 
4. 
5. 
6. 
7. 
8. 
----
----
a node means adding it to the end of a list. 
____ 
a node means adding it to a list but not necessarily to the end . 
____ 
a list means traveling through the list. 
In a(n) _____ 
list, the last node has a pointer to the first node . 
In a(n) ____ 
list, each node has a pointer to the one before it and the one after it. 
Algorithm Workbench 
9. Using the Li stNode structure introduced in this chapter, write a function 
void pri ntFirst(Lis
t Node *ptr) 
that prints the value stored in the first node of a list passed to it as parameter. The 
function should print an error message and terminate the program if the list 
passed to it is empty . 
10. Write a function 
void pri ntSeco nd(ListNode 
*pt r} 
that prints the value stored in the second node of a list passed to it as parameter. 
The function should print an error message and terminate the program if the list 
passed to it has less than two nodes. 
11. Write a function 
doub l e lastVa lu e(ListNode 
*pt r) 

Review Quest ions and Exercises 
1081 
that returns the value stored in the last node of a nonempty list passed to it as 
parameter. The function should print an error message and terminate the program 
if the list passed to it is empty. 
12. Write a function 
Li stNode *removeFirst(
Li stNode *ptr) 
that is passed a linked list as parameter and returns the tai l of the list: That is, it 
removes the first node and returns what is left. The function should deallocate the 
storage of the removed node. The function returns null ptr if the list passed to it 
is empty. 
13. Write a function 
Li stNode *Lis t Concat (ListNode 
*lis t 1, Lis t Node *list2) 
that concatenates the items in l i st2 to the end of list 1 and returns the resulting list. 
Predict the Output 
For each of the following program fragments, predict what the output will be. 
14. ListNode 
*p = new ListNode(56.4); 
p = new ListNode(34.2, 
p); 
cou t << (*p) .value<< 
endl << p- >value; 
15. ListNode 
*p = new ListNode(56.4); 
p = new ListNode(34.2, 
p); 
Lis t Node *q = p- >next ; 
cou t << q- >value; 
16. ListNode 
*p = new ListNode(56.4, 
new Li stNode(31 .5)); 
Lis t Node *q = p; 
whil e (q- >next - >next != nullptr) 
q = q- >next; 
cou t << q- >value; 
Find the Errors 
17. Each of the following member functions for performing an operation on a linked list 
of type Numberl i st has at least one error. Explain what is wrong and how to fix it. 
A) 
Numberl i st : : pri ntl i st ( 
{ 
while(head) 
{ 
} 
} 
cout << head - >value; 
head= 
head - >next; 
B) Numberlis t : :printlis
t ( 
{ 
ListNode *p = head; 
while 
(p- >next ) 
{ 
} 
} 
cout << p- >value; 
p = p- >next ; 

108 2 
Chapte r 1 7 
Linked Lists 
C) Numberl i st : : pri ntl i st ( 
{ 
ListNode *p = head; 
while(p) 
{ 
cout << p->value; 
p++; 
} 
} 
D) 
Numberlis t : :-Numberlis t () 
{ 
ListNode *nodePt r, *nextNode; 
nodePtr = head; 
while (nodePtr 
!= nullptr) 
{ 
nextNode = nodePtr ->next ; 
nodePtr ->next = nullp t r; 
nodePtr = nextNode; 
} 
} 
Soft Skills 
18. You are the leader of a programming team. You want the programmers on your 
team to attend a two -day workshop on linked lists, stacks, and queues. One of 
the managers points out that the STL already supplies each one of those data 
structures, making it unnecessary for your programmers to write their own . Write 
the manager a short memo that justifies the need for the workshop. 
Programming 
Challenges 
1. Simple Linked List Class 
Using an appropriate definition of Li stNode, design a simple linked list class with only 
two member functions and a default constructor: 
voi d add(doub le x); 
boolean i sMember(double x); 
Linkedlis t ( ) ; 
The add function adds a new node containing x to the front (head ) of the list, while the 
i sMember function tests to see if the list contains a node with the value x. Test your 
linked list class by adding various numbers to the list and then testing for membership. 
2. List Copy Constructor 
Modify your list class of Programming Challenge 1 to add a copy constructor. Test 
your class by making a copy of a list and then testing membership on the copy. 
3. List Print 
Modify the list class you created in the previous programming challenges to add a 
pr i nt member function . Test the class by starting with an empty list, adding some 
elements, and then printing the resulting list out . 

a 
VideoNote 
Solving the 
Member 
Insertion by 
Position 
Problem 
Programming Challenges 
108 3 
4. Recursive Member Check 
Modify the list class you created in the previous programming challenges to use a 
recursive method to check for list membership. Test your class. 
5. List Member Deletion 
Modify the list class you created in the previous programming challenges by adding a 
function to remove an item from the list and by adding a destructor: 
voi d remove(double x); 
- Li nkedl i st() ; 
Test the class by adding a sequence of instructions that mixes operations for adding 
items, removing items, and printing the list. 
6. List Reverse 
Modify the list class you created in the previous programming challenges by adding a 
member function for reversing the list: 
voi d reverse(); 
The member function rearranges the nodes in the list so that their order is reversed. 
You should do this without creating or destroying nodes. 
7. List Search 
Modify the list class of Programming Challenge 1 (or later) to include a member function 
i nt search(double 
x) 
that returns the position of a number x on the list. The first node in the list is at position 0, 
the second node is at position 1, and so on. If x is not found on the list, the search should 
return -1. Test the new member function using an appropriate driver program. 
8. Member Insertion By Position 
Modify the list class you created in the previous programming challenges by adding a 
member function for inserting a new item at a specified position: 
voi d insert(double 
x, in t pos); 
A position of O means that x will become the first item on the list, a position of 1 means 
that x will become the second item on the list, and so on. A position equal to, or greater 
than, the length of the list means that the x is placed at the end of the list. 
9. Member Removal by Position 
Modify the list class you created in the previous programming challenges by adding a 
member function for deleting a node at a specified position: 
voi d remove(int pos); 
A value of O for the position means that the first node on the list (the current head) is 
deleted. The function does nothing if the value passed for pos is greater than or equal 
to the length of the list. 

1084 
Chapte r 17 
Linked Lists 
10. List Sort 
Mod ify the list class you created in the previous programming challenges by adding a 
member function that will sort the list into ascending order by the numeric value of the 
item stored in the node . 
voi d sor t ( 
) ; 
You should sort the list by moving pointers rather than by copying or swapp ing the 
conten ts of the nodes. 
11. Generation of Subsets 
Adopt the following strategy to construct the list of all subsets of the set of the integers 
1, 2, . . . n. Use an STL vector to represent a single subset of integers, and use an STL list 
of vectors to represent a list of subsets. Start with a list Lo of one empty vector; then Lo 
represents the list of all subsets of the empty set. Now suppose that you have created the 
list Lk-l of all subsets of 1, 2, . .. , k-1. To form the list Lk of all subsets of 1, 2, . . . k, 
create an empty list L, and then for each vector v in Lk- t, add both v and v + [k] to L. 
Finally, set Lk to L. (Here by v + [k] we mean the result of adding the integer k to the 
vector v.) Test your program for all values of n ~ 4. 
12. Recursive Generation of Subsets 
Solve the problem of Programming Challenge 11 by using recursion. Do this by writing 
a recursive function that takes an integer parameter n and returns a list of all subsets of 
the set 1, 2 . . . , n. 
13. Running Back 
Program 17-11 makes a person run from across the screen, starting near the left edge 
of the screen and ending near the right edge. Modify the program so that the person 
turns around and runs back to the starting point. 
14. Read , Sort , Merge 
Using the Li stNode structure of Program 17-2, write the following functions: 
List Node *r ea d() 
List Node *sor t (List Node* lis t 1) 
Li st Node *merg e (Li st Node* l i st 1 , Lis t Node * l ist 2) 
The first function reads a sequence of whitespace-separated positive numbers and forms the 
numbers read into a linked list of nodes. The input for a sequence of numbers is terminated 
by - 1. The second function sorts a linked list of nodes and returns a pointer to the head of 
the sorted lists. The function should sort by rearranging existing nodes, not by making 
copies of existing nodes. The third function merges two linked lists that are already sorted 
into a linked list that is also sorted. The merge function should not make copies of nodes: 
Rather, it must remove nodes from the two lists and form those nodes into a new list. 
Test your functions by having the user enter two sequences of numbers, sorting each 
sequence, and then merging and printing the resulting list. 

TOPICS 
18.1 Introduction to the Stack ADT 
18.2 Dynamic Stacks 
18.6 The STL deque and queue Containers 
18.7 Focus on Problem Solving and Program 
Design: Eliminating Recursion 
18.3 The STL stack Containe r 
18.4 Introduction to the Queue ADT 
18.5 Dynamic Queues 
18.8 Tying It All Together: Converting Postfix 
Expressions to Infix 
18.1 
Introduction 
to the Stack ADT 
CONCEPT: 
A stack is a data structure that stores and retrieves items in a last-in-first-out 
manner. 
Definition 
Like an array or a linked list, a stack is a data structu re that holds a sequence of 
elements. Unlike arrays and lists, however, stacks are last-in-first-out (LIFO) structures. 
This means that when a program retrieves elements from a stack, the last element 
inserted into the stack is the first one retrieved (and likewise, the first element inserted 
is the last one retrieved). 
When visualizing the way a stack works, think of a stack of plates at the beginning of 
a cafeteria line. When a cafeteria worker replenishes the supply of plates, the first one 
he or she puts on the stack is the last one taken off. This is illustrated in Figure 18-1. 
1085 

1086 
Chapte r 18 
Stacks and Queues 
Figure 18-1 
Figure 18-2 
Last plate in, 
. 
-
first plate out 
The LIFO characteristic 
of a stack of plates in a cafeter ia is also the primary 
characteristic of a stack data structure. The last data element placed on the stack is the 
first data retrieved from the stack. 
Applications 
of Stacks 
Stacks are useful data structures for algorithms that work first with the last saved element 
of a series. For example, computer systems use stacks while executing programs . When a 
function is called, the computer system stores the program's return address, the parameters 
to the function, and the function's local variables on a stack. When the function returns, 
the local variables, parameters, and return address are removed from the stack. 
Static and Dynamic Stacks 
There are two types of stack data structure: static and dynamic. Static stacks have a fixed size 
and are implemented as arrays. Dynamic stacks grow in size as needed and are implemented 
as linked lists. In this section you will see examples of both static and dynamic stacks. 
Stack Operations 
A stack has two primary operations: push and pop. The push operation causes a value 
to be stored, or pushed onto the stack. For example, suppose we have an empty integer 
stack that is capable of holding a maximum of three values. With that stack we execute 
the following push operat ions. 
push(5); 
push(10); 
push(15); 
Figure 18-2 illustrates the state of the stack after each of these push operations. 
15 
push(S); 
push(lO); 10 
push(IS); 10 
5 
5 
5 
The pop operation retrieves (and hence, removes) a value from the stack . Suppose we 
execute three consecutive pop operations on the stack shown in Figure 18-2. Figure 18-3 
depicts the results. 

Figure 18 -3 
15 
pop; 10 
5 
10 
pop; 
18.1 Introduction to the Stack ADT 
1087 
5 
pop; 
5 
As you can see from Figure 18-3, the last pop operation leaves the stack empty. 
For both static and dynamic stacks we will need a Boolean isEmpty operation. The 
isEmpty operation returns true when the stack is empty and false otherwise . By calling 
this operat ion, a programmer can ensure that there is something on the stack before 
attempting a pop operation . 
A Static Stack Class 
Now we examine a class IntStack 
that stores a static stack of integers and performs 
the stack operat ions we have discussed. The class has the member variables described 
in Table 18-1. 
Table 18 -1 Members Variables of the Stack Class 
Member Variable 
stackArray 
capac it y 
top 
Description 
A uni que_ptr to an array of integers. When the constr uctor is executed, it 
uses stackArray 
to dynamically allocate an array for storage . 
An integer that holds the size of the stack. This is the maximum number of 
elements the stack can hold, not the number of elements currently in the stack. 
An integer that is used to mark the top of the stack. It specifies the position 
of the next item that will be added to the stack. 
The class's member functions are listed in Table 18-2. 
Table 18 -2 Members Functions of the Stack Class 
Member Functions 
Constr uctor 
pus h 
pop 
isEmpty 
Description 
The class constr uctor accepts an integer argument, which specifies the size 
of the stack . An integer array of this size is dynamically allocated and 
assigned to stackArray. 
Also, the variable top is initialized to Oto indicate 
that the stack is currently empty. 
The pus h function accepts an integer argument, which is pushed onto the 
top of the stack . 
The pop function uses an integer reference parameter. The value at the top 
of the stack is removed and copied into the reference parameter. 
Returns t rue if the stack is empty and false otherwise . The stack is empty 
when top is set to 0. 

1088 
Chapte r 18 
Stacks and Queues 
0 
NOTE: 
Even though the constr uctor dynamically allocates the stack array, it is still 
considered a stat ic stack since the size of the stack does not change once it is allocated . 
The code for the class is shown here: 
Content s of I ntStack . h 
1 #include 
<memory> 
2 using namespace std ; 
3 class 
IntStack 
4 { 
5 
6 
7 
unique _ptr<int 
[J>stackArray; 
int capacity; 
int top; 
8 public : 
9 
10 
11 
// Constructor 
IntStack (i nt capacity ); 
12 
// Member functions 
13 
void push(int 
value); 
14 
void pop(int 
&valu e); 
15 
bool isEmpty() const ; 
16 
17 
// Stack Exceptions 
18 
cl ass Overflow{}; 
19 
cl ass Underflow{}; 
20 } ; 
In add ition to the members of the stack described in Table 18-2, the IntStack class 
defines two inner classes named Overflow and Underflow to be used as stack exceptions. 
Exceptions are covered in Chapter 16, but we will briefly expla in them here for the 
benefit of those who may have skipped that chapter. A section of code is said to cause 
an exception when, in the course of execution, it encounters conditions that make it 
impossible to perform the task the code was designed to do. In the case of a static stack, 
an overflow exception occurs during a call to push if there is no more room on the 
stack . Likewise, an underflow exception occurs in a call to pop if there is nothing on the 
stack for pop to return . 
Code that detects the occurrence of an except ion can notify the rest of the program by 
creating a value that describes the exception and passing that value to the rest of the 
program using a throw statement. For examp le, the push function anno unces the 
occurrence of an overflow except ion by executing the statement 
throw InstStack
: :Overflow (}; 
and the pop function executes the statement 
throw IntStack :: Underflow (}; 
to notify the program that the underflow exception has occurred . By default, a program 
terminates with an error message when any part of it throws an exception. This default 
behavior can be changed through a process known as catching the except ion . You can 
learn more about exceptions in Chapter 16. 

18.1 Introduction to the Stack ADT 
1089 
The I ntStack constructor allocates an array of a specified capacity and sets the member 
variable top to 0. All stack functions use top in such a way that it always points to 
the next available slot in the stack's array . When top equals capac i ty, there are no 
more slots available to store values, and the call to push throws an exception . Likewise, 
when top is zero, the stack is empty and a call to pop throws an exception . Because 
there are no provisions in the program to catch either exception, the occurrence of 
either one will terminate the program with an error message. Notice that push 
increments top after adding a value to the stack, and pop decrements top before 
returning the value stored at stackArray [top ] . 
Content s of IntStack. cpp 
1 #include 
"intstack
.h" 
2 //************************************ 
3 // Constructor 
• 
4 //************************************ 
5 IntStack: 
:IntStack(int 
capac i ty ) 
6 { 
7 
stackArray 
= make_unique<int[]>(capacity); 
8 
this - >capacity 
= capacity
; 
9 
top
= O; 
10 ) 
11 
12 //*********************************** 
13 // Adds a value to the stack 
• 
14 //*********************************** 
15 void IntStack::push
(int 
value) 
16 { 
17 
if (to p == capacity
) throw IntStack::Overflow
(); 
18 
stackArray[top] 
= value; 
19 
top++ ; 
20
) 
21 
22 //**************************************** 
23 // Determi nes whether the stack 
is empty* 
24 //**************************************** 
25 bool IntStack: 
:i sEmpty( ) const 
26 { 
27 
return 
top== 
O; 
28
) 
29 
30 //************************************************ 
31 // Removes a value from the stack and returns 
it* 
32 //************************************************ 
33 void IntStack: 
:pop(int 
&value ) 
34 { 
35 
if (i sEmpty()) 
throw IntStack: 
:Underflow(); 
36 
top--
; 
37 
value= 
stackArray[top]; 
38
) 
Program 18-1 illustrates the stack class and its member functions. Notice that the 
values pushed onto the stack come off in reverse order when they are popped. 

1090 
Chapte r 18 
Stacks and Queues 
Program 18-1 
1 // This program illustrates 
the IntStack 
class
. 
2 #include 
"intstack
.h " 
3 #include 
<iostream> 
4 us i ng namespace 
std; 
5 int 
mai n() 
6 { 
7 
IntStack 
stack(5); 
8 
i nt values[
] = {5, 10, 15, 20, 25}; 
9 
int 
value; 
10 
11 
cout <<"Push
i ng . . . \n"; 
12 
for 
(in t k = O; k < 5; k++) 
13 
{ 
14 
15 
16 
cout << values[k] 
<<" 
stack.push(values[k]); 
} 
17 
cout << "\nPo pping . . . \n"; 
18 
whi le (!stack.isEmpty()) 
19 
{ 
20 
stack.pop(value); 
21 
22 
} 
cout <<value<<" 
23 
cout << endl; 
24 
return 
O; 
25 } 
Program Output 
Pushing ... 
5 
10 
15 
20 
25 
Popping ... 
25 
20 
15 
10 
5 
". 
' 
". 
' 
In Program 18-1, the constructor 
is called with the argument 5. This sets up the member 
variables, as shown in Figure 18-4. Since top is set to 0, the stack is empty . 
Figure 18-4 
(4] 
top 0 
capacity0 
[3 ] 
(21 
[ 1 I 
stackArray_ 
[OJ 
Figure 18-5 shows the state of the member variab les after the push function is called 
the first time (with 5 as its argument) . The value of top is now 1. 

Figure 18-5 
Figure 18-6 
Figure 18-7 
18.1 Introduction to the Stack ADT 
1091 
(4] 
top[2J 
capac i ty0 
[3] 
(21 
[ 1 I 
stackArray_ 
5 (OJ 
Figure 18-6 shows the state of the member variables after all five calls to the pus h function. 
Now top has value 5, and the stack is full. 
25 (4] 
top 0 
capaci ty 0 
20 [3] 
15 [2] 
10 [ 1 ] 
stackArray-
5 (OJ 
Notice that the pop function uses a reference parameter, va l ue. The value that is popped 
off the stack is copied into val ue so it can be used later in the program . Figure 18-7 
depicts the state of the class members and the valu e parameter, just after the first value 
is popped off the stack. 
value~ 
-
25 (4] 
t op0 
capacit y 0 
20 [3] 
15 [2] 
10 [ 1 ] 
stackArray _ 
5 (OJ 
The program contin ues to call the pop function until all the values have been removed 
from the stack. 
Handling Stack Exceptions 
As you learned in Chapter 16, the C++ t ry/catch statement can be used to catch and 
recover from exceptions, thereby allowing the program to avoid being terminated . 
Program 18-2 shows how a program using the Int Stac k class can catch the exceptions 
that it throws . The program tries to store in the stack more values than the stack can 
handle, causing push to throw the Overfl ow exception . The main function catches the 
exception and prints an explanatory error message. 

109 2 
Chapte r 18 
Stacks and Queues 
Program 18-2 
1 // This program illustrates 
IntStack 
except i on hand ling. 
2 #include 
"intstac
k .h" 
3 #include 
<iostream> 
4 us i ng namespace std; 
5 int mai n() 
6 { 
7 
IntStack 
stack(5); 
8 
i nt values[
] = {5 , 10, 15, 20 , 25} ; 
9 
int value; 
10 
try 
11 
{ 
12 
cout <<"Push i ng . . . \ n"; 
13 
for (i nt k = O; k < 5 ; k++) 
14 
15 
16 
17 
18 
19 
20 
21 
22 
} 
{ 
} 
cout << values[k
] <<" 
stack.push(values[k]); 
". 
' 
cout << "\n Pushing value after 
stack 
i s full . . "; 
stack.push(30); 
cout << "\nYou should not see this!!"; 
cout << endl ; 
23 
catch(IntStack: 
:Overf l ow) 
24 
{ 
25 
cout << "\ nAn Over fl ow exception 
occurred.\ 
n" ; 
26 
} 
27 
return 
O; 
28
} 
Program Output 
Pushing ... 
5 
10 
15 20 
25 
Pushing value after 
stack 
is full .. 
An Overflow exception 
occurred. 
There is a significant difference between a stack filling up and a stack becoming empty, and 
between the stack overflow and stack underflow exceptions. In stack overflow, a program 
has a value to push on a stack but cannot continue execution because the stack is full. There 
is a sense in which overflow is unexpected because a program does not normally expect to 
use up every slot in the stack. On the other hand, programs are usually written to remove 
and process all items stored on a stack, so they do expect that the stack will eventually 
become empty. Indeed, most algorithms that use a stack have a loop that continues to 
iterate as long as the stack is not empty. This is why a stack always needs an i sEmpty 
function but does not need an i sFul 1 function. A well-written stack-based algorithm will 
normally call i sEmpty to make sure the stack is not empty before calling pop. 
The difference between overflow and underflow can be summarized as follows. Stack 
overflow in push notifies the caller that the stack has run out of resources, while 
stack underflow notifies the caller of an error in the program's logic. Unlike overflow, 
stack underflow can be avoided by careful programming. Therefore, programs should 

18.2 
18.2 Dynamic Stacks 
1093 
not use try I cat ch to hand le und erflow. Instead, they should ensure that underflow 
cannot occur by calling i sEmpty before calling pop. 
Stack Templates 
The stack classes shown in this chapter work only with integers . A stack template can 
be easily designed to work with any data type. This is left as a Programm ing Challenge 
for you to complete . 
Dynamic Stacks 
CONCEPT
: A stack may be implemented as a linked list and expand or shrink with 
each push or pop operation. 
A dynamic stack is built on a linked list instead of on an array . A stack based on a 
linked list offers two advantages over a stack based on an array . First, there is no need 
to specify the starting size of the stack. A dynamic stack simply starts as an empty 
linked list, then expands by one node each time a value is pushed . Second, a dynamic 
stack will never be full, as long as the system has enough free memory . 
In this section we will look at a dynamic stack class, DynintStack. This class is a dynam ic 
version of the IntStack class previously discussed. The class declarat ion is shown here: 
Conte nts of DynlntStack. h 
1 class DynlntStack 
2 { 
3 
struct 
StackNode 
4 
{ 
5 
i nt value; 
6 
StackNode *next; 
7 
II Constructor 
8 
StackNode(in t value1, 
Stac kNode *next 1 = nullptr) 
9 
{ 
10 
11 
12 
13 
} ; 
} 
value= 
value 1; 
next = next 1; 
14 
StackNode *t op; 
15 pub l i C : 
16 
DynlntStack() 
{t op = nullptr; 
} 
17 
-oynintStack(
); 
18 
void push(i nt); 
19 
void pop(i nt &); 
20 
bool isEmpty() const ; 
21 
22 
II Stack Exception 
23 
cl ass Underflow{}; 
24 } ; 
The StackNode class is the data type of each node in the linked list. Because it is easy to 
add and remove items at the beginning of the list, we make the beginning of the linked 

1094 
Chapte r 18 
Stacks and Queues 
list the top of the stack and use a pointer top to point to the first node in the list. Thi s 
pointer is initialized to nu 11 pt r by the stack constr uctor, to signify that the stack is 
created empty . Dynamic stac ks have no stat ically allocated array to fill up, so there 
is no overflow exception . However, the class defines an Underflow exception, to be 
thrown when there is an attempt to pop an empty stack. 
The member functions of this stack class are shown here: 
Content s of DynlntStack. cpp 
1 #include 
<iostream> 
2 #include 
"DynlntStack.h" 
3 #include 
<cstdl i b> 
4 using namespace std ; 
5 
6 //************************************************** 
7 II Member funct i on push pushes the argument onto 
8 II the stack . 
* 
* 
9 //************************************************** 
10 void DynlntStack: :push(int 
num) 
11 { 
12 
top = new StackNode(num, top); 
13 } 
14 
15 //***************************************************** 
16 II Member funct i on pop removes the value at the top 
17 II of the stack and copies 
it into the variable 
18 II passed as an argument. 
* 
* 
* 
19 //***************************************************** 
20 void DynlntStack: :pop (i nt &num) 
21 { 
22 
StackNode *temp ; 
23 
24 
if (i sEmpty()) 
{ throw DynlntStack: :Underf l ow(); 
} 
25 
el se 
26 
{ 
27 
II Pop value off top of stack 
28 
num = top - >valu e ; 
29 
temp= 
top; 
30 
top= 
top - >next ; 
31 
delete 
temp; 
32 
} 
33 } 
34 
35 //***************************************************** 
36 II Member funct i on isEmpty returns 
true 
if the stack 
37 II is empty , or false 
otherwise
. 
* 
* 
38 //***************************************************** 
39 bool DynlntStack: : isEmpty () const 
40 { 
41 
ret urn top== 
nullptr; 
42 } 
43 
44 //***************************************************** 
45 II Destructor. 
* 
46 //***************************************************** 

47 DynlntStack : :-DynlntStack
() 
48 { 
49 
StackNode *g arbage
= top; 
50 
while (garbage 
!= nullptr) 
51 
{ 
52 
top= 
top - >next ; 
53 
garbage - >next = nullptr; 
54 
delete 
garbage; 
55 
garbage
= top ; 
56 
} 
57 
58
} 
18.2 Dynamic Stacks 
1095 
The push function is particularly simple. It simply creates a new node whose value is the 
number to be pushed on the stack and whose successor pointer is the node that is currently 
the top of the stack, and then makes the newly created node the new top of the stack: 
top= 
new StackNode(num, top); 
Note that this works correctly even if the stack was empty previous to the push 
operation because in that case the successor to the new node at the top of the stack will 
be correctly set to nullptr
. 
Now let's look at the pop function. Just as the push function must insert nodes at the head 
of the list, pop must delete nodes at the head of the list. First, the function calls i sEmpt y 
to determine whether there are any nodes in the stack. If not, an except ion is thrown . 
if 
(isEmpty ()) { throw DynlntStack: :Underflow(); 
} 
If i sEmpty returns fa 1 se, then the following statements are executed . 
else 
II Pop value off top of stack 
{ 
} 
num = top - >valu e ; 
temp= top; 
top= 
top - >next ; 
delete 
temp; 
First, a copy of the va 1 ue member of the node at the top of the stack is saved in the num 
reference paramete r. A temporary pointer temp is then set to point to the node that is 
to be deleted , that is, the node currently at the top of the stack. Th e top pointer is then 
set to point to the node after the one that is currently at the top . The same code will set 
top to nullptr if there are no nodes after the one that is curren tly at the top of the stack. 
It is then safe to delete the top node through the temporary pointer. 
Program 18-3 is a driver that demonstrates the DynlntStack class . 
Program 18-3 
1 II This program demonstrates 
the dynamic stack 
2 II class 
DynlntStack
. 
3 #include 
<iostream> 
4 #include 
"DynlntSt ack.h" 
5 usi ng namespace std; 
(program continues) 

1096 
Chapte r 18 
Stacks and Queues 
Program 18-3 
6 
7 i nt mai n() 
8 { 
(continued) 
9 
DynlntStack 
stack; 
10 
int popped_value; 
11 
II 
Push values 
5 , 10 , and 15 on the stack 
12 
for (int 
value= 
5 ; value<= 
15 ; value= 
value
+ 5) 
13 
{ 
14 
cout << "Push: •<<value 
<< "\n"; 
15 
stack .push(value); 
16 
} 
17 
cout << "\ n"; 
18 
19 
II 
Pop three 
values 
20 
for (int 
k = 1; k <= 3 ; k++) 
21 
{ 
22 
cout << "Pop: "; 
23 
stack .pop(popped _value); 
24 
cout << popped_value << endl; 
25 
} 
26 
27 
II Stack is now empty, a pop will 
cause an exception 
28 
t ry 
29 
{ 
30 
cout << • \ nAttempt i ng to pop again . . . • · 
31 
stack .pop(popped _value); 
32 
} 
33 
catch 
(DynlntSt ack :: Underf lo w) 
34 
{ 
35 
cout << "Underflow exception 
occ ured . \n"; 
36 
} 
37 
return 
O; 
38
) 
Program Output 
Push: 5 
Push: 10 
Push: 15 
Pop: 15 
Pop: 10 
Pop: 5 
Attempting 
to pop again ... 
Underflow exception 
occured. 
This program creates a stack and pushes three items onto the stack. All three items are 
then popped and printed . The fourth and final pop is on an empty stack, so an 
underflow exception is thrown. Lines 27- 36 show a try-catch block that catches the 
exception and prints a message. 

a 
18.3 The STL stack Container 
1097 
The STL stack Container* 
CONCEPT: 
Th e Standard T emplate Library offers a stack templat e that may be 
implemented as a vector , a list , or a deque. 
So far, the STL containe rs you have learned about are vectors and l i st s. The STL stack 
containe r may be implemented as a vect or or a list. 
(It may also be implemented as a 
deque, which you will learn abo ut later in this chapter.) One class is said to adapt another 
class if it provides a new interface for it. The purpose of the new interface is to make it 
more convenient to use the class for specialized tasks. Because the stack container is used 
to adapt the list, vector, and deque containers, it is often referred to as a container adapter. 
Here are examp les of how to declare a stack of i nt s, implemented as a vect or , a lis t , 
and a deque. 
VldeoNot e 
stack< int, 
vect or<i nt >> i Stack; 
/ / Vector stack 
Storing Objects stack< int, 
l i st <i nt >> i Stack 
/ / Li st stack 
in an STL Stack stack< int > i St ack; 
// Deque st ack ( t he default
) 
0 
NOTE: 
Prior to C++ll, the closing pair of angled brackets>> in the declarat ion 
of i Stack had to be written as > >, with at least one space between them, so the 
compiler would not mistake them for the stream extraction operator>>. 
Table 18-3 lists and describes some of the stack template 's member functions . 
Table 18-3 STL Stack Member Fiunctions 
Member Function 
Examples and Description 
empty 
pop 
push 
siz e 
top 
0 
if (myStack.empty ()) 
Th e empty member function returns t rue if the stack is empty . It returns 
false if the stack has elements . 
myStack. pop() ; 
Th e pop function removes the element at the top of the stack. 
myStack.pus h(x); 
Th e push function pushes an element with the value x onto the stack . 
cout << myStack .size () << endl ; 
Th e size function returns the number of elements currently in the stack. 
x = myStack. t op(); 
Th e top function returns a reference to the element at the top of the stack. 
NOTE: 
The pop function in the stack template does not retrieve the value from 
the top of the stack; it only removes it. To retrieve the value, you must call the top 
function first. 
• This section should be skipped if Chapter 16 has not yet been covered. 

1098 
Chapte r 18 
Stacks and Queues 
Program 18-4 is a driver that demonstrates an STL stack implemented as a vector. 
Program 18-4 
1 II This program demonstrates 
the STL stack 
2 II container 
adapter
. 
3 #include 
<iostream> 
4 #include 
<vector> 
5 #include 
<stack> 
6 us i ng namespace std; 
7 
8 i nt mai n() 
9 { 
10 
stack< 
int, 
vector<int> 
> iStack; 
11 
12 
for (int 
x = 2 ; x < 8; x += 2) 
13 
{ 
14 
cout <<"Push i ng•<< 
x << end l; 
15 
i Stack .push(x ); 
16 
} 
17 
18 
cout << "The si ze of the stack 
i s ·· 
19 
cout << iStack.size() 
<< endl; 
20 
21 
II 
Print 
items and pop until 
the stack 
is empty 
22 
while 
(!iStack.
empty ()) 
23 
{ 
24 
cout << •Popping • << i Stack. top () << endl ; 
25 
i Stack .pop (); 
26 
} 
27 
return 
O; 
28
} 
Program Output 
Pushing 2 
Pushing 4 
Pushing 6 
The size of the stack 
is 3 
Popping 6 
Popping 4 
Popping 2 
~ 
Checkpoint 
18.1 
Describe what LIFO means. 
18.2 
What is the difference between static and dynamic stacks? What advantages do 
dynamic stacks have over static stacks? 
18.3 
What are the two primary stack operat ions? Describe them both. 
18.4 
What STL types does the STL stack container adapt? 

Figure 18-8 
18.4 Introduction to the Queue ADT 
1099 
Introduction 
to the Queue ADT 
CONCEPT: 
A queue is a data structure that stores and retrieves items in a first-in-first-out 
mann er. 
Definition 
Like a stack, a queue (pronounced "cue") is a data structure that holds a sequence of 
elements. A queue, however, provides access to its elements in first-in-first -out (FIFO) 
order. The elements in a queue are processed like customers standing in a grocery 
checkout line: The first customer in line is the first one served . 
Application of Queues 
Queue data structures are commonly used in computer operating systems. They are 
especially important in multiuser/multitasking environments where several users or tasks 
may be requesting the same resource simultaneously. Printing, for example, is controlled by 
a queue because only one document may be printed at a time. A queue is used to hold print 
jobs submitted by users of the system, while the printer services those jobs one at a time. 
Communicat ions software also uses queues to hold information received over networks 
and dial-up connect ions. Sometimes information is transmitted to a system faster than 
it can be processed, so it is placed in a queue when it is received. 
Static and Dynamic Queues 
Queues, like stacks, can be implemented as arrays or linked lists. Dynam ic queues offer 
the same advantages over stat ic queues that dynam ic stacks offer over static stacks. In 
fact, the primary difference between queues and stacks is the way data elements are 
accessed in each structure. 
Queue Operations 
A queue has a front and a rear like a checkout line in a grocery store. This is illustrated in 
Figure 18-8. When an element is added to a queue, it is added to the rear. When an element 
is removed from a queue, it is removed from the front. The two primary queue operations 
are enqueuing and dequeuing. To enqueue means to insert an element at the rear of a queue, 
and to dequeue means to remove an element from the front of a queue. There are several 
algorithms for implementing these operations. We will begin by looking at the simplest. 
Suppose we have an empty static integer queue that is capable of holding a maximum 
of three values. With that queue we execute the following enqueue operations: 
enqueue(3); 
enqueue(6); 
enqueue(9); 

1100 
Chapte r 18 
Stacks and Queues 
Figure 18-9 
Figure 18-9 illustrates the state of the queue after each of these enqueue operat ions. 
enqueue(3); 
front" 
/rear 
I 3 I I 
enqueue(6); 
front'. 
/r ear 
I 3 Is I I 
enqueue(9); 
front'. 
/rear 
1 3
1 6
1 9 
I 
Notice that the front index (which is a variable holding a subscript or perhaps a pointer ) 
always references the same physical element. The rear index moves in the array as items 
are enqueued. Now let's see how dequeue operat ions are performed . Figure 18-10 
illustrates the state of the queue after each of three consecutive dequeue operations . 
Figure 18-10 
dequeue(); 
front '. 
/rear 
I s I 9 I I 
dequeue(); 
front '. /rear 
I 9 I I 
dequeue(); 
front= -1 
rear= -1 
In the dequeuing operation, the element at the front of the queue is removed. This is done 
by moving all the elements after it forward by one position. After the first dequeue operation, 
the value 3 is removed from the queue and the value 6 is at the front . After the second 
dequeue operation, the value 6 is removed and the value 9 is at the front. Notice that when 
only one value is stored in the queue, that value is at both the front and the rear. 
When the last dequeue operation is performed in Figure 18-10, the queue is empty. An 
empty queue can be signified by setting both front and rear indices to - 1. 
The problem with this algorithm is its inefficiency. Each time an item is dequeued, the 
remaining items in the queue are copied forward to their neighboring element. The more 
items there are in the queue, the longer each successive dequeue operation will take. 
Here is one way to overcome the problem: Make both the front and rear indices move in 
the array . As before, when an item is enqueued, the rear index is moved to make room 
for it. But in this design, when an item is dequeued, the front index moves by one element 

18.4 Introduction to the Queue ADT 
1101 
toward the rear of the queue. This logically removes the front item from the queue and 
eleminates the need to copy the remaining items to their neighboring elements. 
With this approach, as items are added and removed, the queue gradually "crawls" 
toward the end of the array . This is illustrated in Figure 18-11. The shaded squares 
represent the queue elements (between the front and rear). 
Figure 18-11 
5 items have been enqueued. 
1 item is dequeued. 
3 more items are enqueued. 
3 more items are dequeued. 
The problem with this approach is that the rear index cannot move beyond the last 
element in the array . The solution is to think of the array as circular instead of linear. 
When an item moves past the end of a circular array, it simply wraps around to the 
beginning. For example, consider the queue depicted in Figure 18-12. 
Figure 18-12 
front 
rear 
I 
I 
(OJ (1) [2] (3) (4] (5) (6] (7] (8) 
The value 3 is at the rear of the queue, and the value 7 is at the front of the queue. Now, 
suppose an enqueue operation is performed, inserting the value 4 into the queue . 
Figure 18-13 shows how the rear of the queue wraps around to the beginning of the array. 
Figure 18-13 
rear 
I 
front 
I 
(OJ (1] [2] (3] (4] (5] (6] (7) (8] 
So, what is the code for wrapping the rear marker around to the opposite end of the 
array? One straightforward approach is to use an if statement such as 
i f (rear== 
queueSi ze - 1) 
rear= 
O; 
els e 
rear ++; 

110 2 
Chapter 18 
Stacks and Queues 
Another approac h is with modular arithmetic: 
rear= 
(r ear + 1 ) % queueSize ; 
This statement uses the % operator to adjust the value in rear to the proper position. 
Although this approac h appears more elegant, the choice of which code to use is yours. 
Detecting Full and Empty Queues with Circular Arrays 
In our implementation of a queue using a circular array, we have adopted the convention 
that the front and rear indices both reference items that are still in the queue, and that 
the front and rear indices will both be set to -1 to indicate an empty queue. To preserve 
this convention, the operation for dequeueing an element must set both front and rear 
to -1 after removing an element from a queue with only one item. The dequeuing 
operat ion can test for a queue with only one item by testing whether front is equal to 
rear. To avoid overflowing the queue, the operation for enqueuing must first check 
that the queue is not already full before adding another element . We can check to see if 
the queue is full by testing the expression 
(rear+ 
1) % queueSi ze == front 
to see if it is true. 
There is anothe r way for detecting full and empty queues: A counter variable can be 
used to keep a count of the number of items currently stored in the queue. With this 
convention, the counter is incremented with each enqueue operation and decremented 
with each dequeue operation . The queue is empty when the counter is zero and is full 
when the counter equals the size allocated for the queue. 
Because it might be helpful to keep a count of items in the queue anyway, we will use 
the second method in our implementation. Accordingly, we introduce the variables 
uni que_ptr<int 
[]> queueArray ; 
i nt queueSize ; 
i nt front ; 
i nt rear; 
i nt numltems ; 
with numltems being the counter variable and queueArray the unique smart pointer to a 
dynamically allocated array of size queueSi ze. We adopt the following two conventions: 
• rear points to the place in the queue holding the item that was last added to the 
queue. 
• front points to the place in the queue that used to hold the item that was last 
removed from the queue. 
Because of the convention on where the rear index is pointing to, the enqueue operat ion 
must first (circularly) move rear one place to the right before adding a new item num: 
rear= 
(rear+ 
1) % queueSize ; 
queueArray[rear
] = num; 
numltems ++; 
Simila rly, because whatever is at front 
has already been removed, the dequeue 
operation must first move front before retrieving a queue item. 

A Static Queue Class 
The declaration of the IntQueue class is as follows: 
Contents of IntQueue. h 
1 #include 
<memory> 
2 using namespace std; 
3 class 
IntQueue 
4 { 
5 private: 
6 
unique _ptr<int 
[]> queueArray; 
7 
int queueSize; 
8 
int front; 
9 
int rear; 
10 
int numltems; 
11 public : 
12 
IntQueue(int); 
13 
14 
void enqueue(int); 
15 
void dequeue(int 
&); 
16 
bool isEmpty() 
const; 
17 
bool isFull() 
const; 
18 
void clear(); 
19 } ; 
18.4 Introduction to the Queue ADT 
1103 
Notice that in addition to the operations discussed in this section, the class also declares 
a member function named c 1 ear. This function clears the queue by resetting the front 
and rear indices and setting the numltems member to 0. The member function 
definitions are listed here: 
Contents of IntQueue. cpp 
1 #include 
<iostream> 
2 #include 
"IntQueue .h" 
3 #include 
<cstdl i b> 
4 using namespace std; 
5 
6 //************************* 
7 II Constructor
. 
* 
8 //************************* 
9 IntQueue::IntQueue(int 
s) 
10 { 
11 
queueArray = make_uniq ue<i nt [J>(s); 
12 
queueS iz e = s; 
13 
front= 
- 1; 
14 
rear= 
-1 ; 
15 
numltems = O; 
16 } 
17 
18 //******************************************** 
19 II Function 
enqueue inserts 
the value in num * 
20 II at the rear of the queue . 
* 
21 //******************************************** 
22 void IntQueue::enqueue(int 
num) 
23 { 

1104 
Chapte r 18 
Stacks and Queues 
24 
if (i sFull()) 
25 
{ 
26 
cout 
<< "The queue is full.
\n"; 
27 
exit (1) ; 
28 
} 
29 
else 
30 
{ 
31 
II Calculate 
the new rear pos i t i on 
32 
rear= 
(rear+ 
1) % queueSize ; 
33 
II Insert 
new item 
34 
queueArray[rear] 
= num; 
35 
II Update item count 
36 
numltems ++; 
37 
} 
38 } 
39 
40 //********************************************** 
41 II Function 
dequeue removes the value at the 
* 
42 II front 
of the queue, and copies 
it i nto num. * 
43 //********************************************** 
44 void IntQueue::dequeue(int 
&num) 
45 { 
46 
if (i sEmpty()) 
47 
{ 
48 
cout 
<< "The queue is empty . \n"; 
49 
exit (1) ; 
50 
} 
51 
else 
52 
{ 
53 
II Move front 
54 
front= 
(front+ 
1) % queueSize ; 
55 
II Retrieve 
the front 
item 
56 
num = queueArray[front
] ; 
57 
II Update item count 
58 
numltems--; 
59 
} 
60
} 
61 
62 //********************************************* 
63 II Function 
isEmpty returns 
true 
if the queue* 
64 II is empty , and false 
otherwise. 
* 
65 //********************************************* 
66 bool IntQueue: :is Empty() const 
67 { 
68 
return 
numltems == 
O; 
69 } 
70 
71 //******************************************** 
72 II Function 
isFull 
returns 
true 
if the queue* 
73 II is full
, and false 
otherw ise. 
* 
74 //******************************************** 
75 bool IntQueue::isFull
() const 
76 { 
77 
return 
numltems == 
queueS ize ; 
78 } 
79 

18.4 Introduction to the Queue ADT 
1105 
80 //******************************************* 
81 II Function clear 
resets 
the front 
and rear* 
82 II indices
, and sets 
numltems to 0. 
* 
83 //******************************************* 
84 void IntQueue : :clear () 
85 { 
86 
front= 
- 1; 
87 
rear
= - 1; 
88 
numltems = O; 
89
} 
Program 18-5 is a driver that demonstrates the IntQueue class. 
Program 18-5 
1 II This program demonstrates 
the IntQueue class. 
2 #include 
<iostream> 
3 #include 
"IntQue ue .h" 
4 usi ng namespace std; 
5 
6 int mai n() 
7 { 
8 
IntQueue iQueue(5); 
9 
10 
cout << "Enqueuing 5 items .. . \n"; 
11 
12 
II Enqueue 5 items 
13 
for (int k = 1; k <= 5; k++) 
14 
i Queue .en queue( k*k); 
15 
16 
17 
18 
II Deqeue and retr i eve al l 
cout << "The values in the 
while (!i Queue.isEmpty ()) 
{ 
19 
20 
21 
i nt value; 
i Queue .dequeue (valu e); 
22 
cout <<value<<" 
23 
} 
24 
cout << endl; 
25 
return 
O; 
26 } 
Program Output 
Enqueuing 5 items ... 
". 
items in the queue 
queue were: "· 
The values in the queue were: 1 4 
9 
16 25 
Overflow and Underflow Exceptions in a Static Queue 
The enqueue and dequeue functions in our queue class terminate the calling program 
when they cannot perform the task they are called to do. But terminating the caller is 
not always the right thing to do. A better course of action is to throw an exception and 
allow the caller who is prepared to handle such an exception to take appropr iate 
action . Upon catching such an except ion, some callers may indeed decide to terminate 

1106 
Chapter 18 
Stacks and Queues 
18.5 
the program. Other callers, however, may be able to recover and contin ue execution. 
For example, a program that catches a queue overflow exception might be able to 
create a bigger queue and switch to the new queue. 
A better design for a static queue is to have enqueue and dequeue throw overflow and 
under fl ow exceptions . Having enqueue throw over fl ow eliminates the need for a 
public i sFul 1 function because the caller can use a try/ catch block to handle queue 
overflows if and when they occur. By puttin g all calls to enqueue within the try block, 
the caller is able to put the code to handle an exception thrown by any of those calls in 
a single place: the catch block. Without exception handling, every call to enqueue 
would have to be preceded by a call to i sFul 1 and have code attached to it to recover 
in the event that i sFul 1 returns true . One of the programming challenges at the end of 
this chapter asks you to modify the queue class to use exceptions. 
Dynamic Queues 
CONCEPT: 
A queue may be implemented as a linked list and expand or shrink with 
each enqueue or dequeue operation. 
Dynamic queues, which are built around linked lists, are much more intuitive to 
understand than static queues. A dynamic queue starts as an empty linked list. With the 
first enqueue operation, a node is added, which is pointed to by the front and rear 
pointers. As each new item is added to the queue, a new node is added to the rear of the 
list, and the rear pointer is updated to point to the new node. As each item is dequeued, 
front is made to point to the next mode in the list, and then the node that was previously 
at the front of the list is deleted. Figure 18-14 shows the structure of a dynamic queue. 
Figure 18-14 
I 
item 11 • · I 
item 2 I • • I 
item 31 
cb 
cb 
front 
rear 
A dynamic integer queue class is listed here: 
Contents of DynlntQueue. h 
1 class DynlntQueue 
2 { 
3 
struct 
QueueNode 
4 
{ 
5 
int value; 
6 
QueueNode *next; 
• ~ 
NULL 
7 
QueueNode(int value1, QueueNode *next1 = nullptr) 
8 
{ 
9 
value= 
value1; 

10 
next= 
next1; 
11 
} 
12 
} ; 
13 
II These track 
the front 
and rear of the queue 
14 
QueueNode *fr ont ; 
15 
QueueNode *rear; 
16 pub 1 i C: 
17 
II Constructor 
and Destructor 
18 
DynlntQueue(); 
19 
-DynlntQueue(); 
20 
21 
II Member functions 
22 
void enqueue(int
); 
23 
void dequeue(int 
&); 
24 
bool isEmpty() 
const ; 
25 
void clear(}; 
26 } ; 
Content s of DynlntQueue. cpp 
1 #include 
<iostream> 
2 #include 
"DynlntQueue.h" 
3 #include 
<cstdl i b> 
4 using namespace std ; 
5 
6 //************************ 
7 II Constructor
. 
* 
8 //************************ 
9 DynlntQueue::DynlntQueue() 
10 { 
11 
front= 
nullptr; 
12 
rear
= nullptr; 
13 } 
14 
15 //************************ 
16 II Destructor. 
* 
17 //************************ 
18 DynlntQueue::-DynlntQueue() 
19 { 
20 
QueueNode *g arbage
= front ; 
21 
while 
(garbage 
!= nullptr) 
22 
{ 
23 
front= 
front - >next; 
24 
garbage - >next = nullptr; 
25 
delete 
garbage; 
26 
garbage= 
front; 
27 
} 
28 } 
29 
30 //******************************************** 
31 II Function 
enqueue inserts 
the value in num * 
32 II at the rear of the queue . 
* 
33 //******************************************** 
34 void DynlntQueue: :enqueue( i nt num} 
35 { 
36 
if (i sEmpty()) 
18.5 Dynamic Queues 
1107 

1108 
Chapte r 18 
Stacks and Queues 
37 
{ 
38 
front= 
new QueueNode(num); 
39 
rear= 
front; 
40 
} 
41 
else 
42 
{ 
43 
rear - >next = new QueueNode(num) ; 
44 
rear= 
rear - >next ; 
45 
} 
46 } 
47 
48 //********************************************** 
49 II Function 
dequeue removes the value at the 
* 
50 II front 
of the queue, and copies 
it i nto num. * 
51 //********************************************** 
52 void DynlntQueue: :dequeue( i nt &num) 
53 { 
54 
QueueNode *temp = nullptr; 
55 
if (i sEmpty()) 
56 
{ 
57 
cout 
<< "The queue is empty . \n"; 
58 
exit (1) ; 
59 
} 
60 
else 
61 
{ 
62 
num = front - >value ; 
63 
temp= 
front; 
64 
front= 
front - >next ; 
65 
delete 
temp; 
66 
} 
67 } 
68 
69 //********************************************* 
70 II Function 
isEmpty returns 
true 
if the queue* 
71 II is empty , and false 
otherwise. 
* 
72 //********************************************* 
73 bool DynlntQueue: :isEmpty() 
const 
74 { 
75 
if (front
== nullptr) 
76 
return 
true; 
77 
else 
78 
return 
false; 
79 } 
80 
81 
82 
83 
84 
85 
86 
87 
88 
//******************************************** 
II Function 
clear 
dequeues all 
the elements 
II in the queue. 
* 
* 
//******************************************** 
void DynlntQueue: :clear() 
{ 
int value; 
II Dummy variable 
for dequeue 
89 
while 
(! i sEmpty ()) 
90 
dequeue(value); 
91 } 

18.6 The STL deque and queue Containers 
110 9 
Program 18-6 is a driver that demonstrates 
the DynintQueue class. 
Program 18-6 
1 II 
This program demonstrates 
the DynlntQeue class. 
2 #include 
<iostream> 
3 #include 
"Dynlnt Queue.h" 
4 us i ng namespace 
std; 
5 
6 i nt mai n() 
7 { 
8 
DynlntQueue 
i Queue ; 
9 
10 
cout << "Enqueuing 
5 items ... \n"; 
11 
12 
II 
Enqueue 5 items 
13 
for 
(int 
k = 1; k < = 5; k++) 
14 
i Queue.enqueue
(k*k ); 
15 
16 
17 
18 
19 
20 
21 
22 
23 
24 
25} 
II 
Dequeue and retrieve 
all 
items 
in the queue 
cout << "The values 
in the queue were:\n"; 
while 
(!i Queue.isEmpty
()) 
{ 
} 
i nt value; 
i Queue.dequeue
(value ); 
cout <<value<<" 
". 
' 
return 
O; 
Program Ouput 
Enqueuing 
5 items ... 
The values 
in the queue were: 
1 
4 
9 
16 
25 
The STL deque and queue Containers* 
CONCEPT
: T he Standard Template 
Library provides two co ntainers, deque and 
queue, for impleme nting queue -like data structures. 
In this sect ion we will examine two ADTs offered by the Standard Template Library: 
deque and queue. A deque (pronounced 
"dec k " or "<leek ") is a double -ended queue. It 
is similar to a vector but allows efficient access to values at both the front and the rear. 
Th e queue ADT is like the stack ADT: It is actually a container adapter. 
• Note: This section should be skipped if Chapter 16 has not yet been covered. 

1110 
Chapte r 18 
Stacks and Queues 
The deque Container 
Think of the deque container as a vecto r that provides quick access to the element at its 
front as well as at its back . (Like vector , deque also pr ovides access to its elements wit h 
the [ ] operator.) 
Programs that use the deque ADT must include the deque header. Since we are concentrating 
on its queue-like characterist ics, we will focus our attention on the push_back, pop_front, 
and front member functions. Table 18-4 describes them. 
Table 18-4 deque Member Functions 
Member Functio n 
Examples and Description 
push _back 
iDeque.push _back(7); 
Accepts as an argument a value to be inserted into the deque. The argument 
is inserted after the last element (pushed onto the back of the deque ). 
pop_front 
iDeque.pop _front (); 
Rem oves the first element of the deque and discards it. 
front 
cout << iDeque .front(
) << endl; 
front returns a reference to the first element of the deque. 
Program 18-7 demonstrates the deque container. 
Program 18-7 
1 II This program demonstrates 
the STL deque 
2 II container
. 
3 #include 
<iostream> 
4 #include 
<deque> 
5 us i ng namespace std; 
6 
7 int mai n() 
8 { 
9 
deque<int> 
iDeque; 
10 
11 
cout << "I will 
now enqueue items . . . \n"; 
12 
for (int 
x = 2 ; x < 8; x += 2) 
13 
{ 
14 
cout <<"Pushing"<< 
x << end l; 
15 
iDeque.push _back(x); 
16 
} 
17 
18 
cout << "I will 
now dequeue items . . . \n"; 
19 
while 
(!iD eque.empty ()) 
(program continues) 

18.6 The STL deque and queue Containe rs 
1111 
Program 18-7 
(continued) 
20 
{ 
21 
cout <<"Popping"<< 
iDeque .front() 
<< endl; 
22 
iDeque.pop _fron t (); 
23 
} 
24 
return 
O; 
25
} 
Program Output 
I will 
now enqueue items ... 
Pushing 
2 
Pushing 
4 
Pushing 
6 
I will 
now dequeue items ... 
Popping 2 
Popping 4 
Popping 6 
The queue Container Adapter 
The queue container adapter can be built upon vectors, lists, or deques. By default, it 
uses a deque as its base. 
a 
VideoNot e 
Storing 
Objects in an 
STL Queue 
The insert ion and remova l operations supported by queue are similar to those 
supported by the stack ADT: pus h, pop, and front. 
There are differences in their 
behavior, however. The queue version of push always inserts an element at the rear of 
the queue. The queue version of pop always removes an element from the structure's 
front . The front function returns the value of the element at the front of the queue. 
Program 18-8 demonstrates a queue. Since the declaration of the queue does not specify 
which type of container is being adapted, the queue will be built on a deque. 
Program 18-8 
1 II This program demonst rates 
the STL queue 
2 II conta i ner adapter. 
3 #i nclude <io st ream> 
4 #include 
<queue> 
5 us i ng namespace std; 
6 
7 int mai n() 
8 { 
9 
queue<i nt > iQueue; 
10 
11 
cout << "I will 
now enqueue items . . . \n"; 
12 
for (i nt x = 2 ; x < 8; x += 2) 
(program continues) 

111 2 
Chapte r 18 
Stacks and Queues 
Program 18-8 
(continued) 
13 
{ 
14 
cout <<"Push i ng•<< 
x << endl ; 
15 
i Queue.pu sh (x); 
16 
} 
17 
cout << "I will 
now dequeue items . . . \n"; 
18 
while(!iQueue.empty()) 
19 
{ 
20 
cout <<"Popp i ng•<< 
iQueue.front(} 
<< endl ; 
21 
i Queue.pop(); 
22 
} 
23 
return 
O; 
24 } 
Program Output 
I will 
now enqueue items ... 
Pushing 2 
Pushing 4 
Pushing 6 
I will 
now dequeue items ... 
Popping 2 
Popping 4 
Popping 6 
18.7 
Focus on Problem Solving and Program 
Design: Eliminating Recursion 
Altho ugh recursion is a very useful programming technique , it carries the overhead 
of the necessity to make numerous 
function calls dur ing the process of solv ing 
the problem. The efficiency of a recursive solution can often be greatly improved 
by reformulating 
a recursive algor ithm to eliminate the recursion. In this sect ion, 
we look at how a stac k can be used to eliminate recursion 
from the Quicksort 
algorithm. 
The main problem in Quicksort is that of sort ing a range, or a segment of an array arr, 
between two indices start 
and end. Naturally, this has to be done only if start 
is less 
than end . As learned in Chapte r 14, this is accomplished 
by calling a procedure 
partition, 
which determin es an integer pivot such that 
1. All array items in the segment to the left of the pivot are less than the element at 
the pivot: that is, 
arr[k ] < arr[pivot
] for all k in the range start 
. . pivot-1 
2. All array items in the segment to the right of the pivot are greater than or equa l 
to the element at the pivot: that is, 
arr[k ] >= arr[pivot
] for all k in the range pivot+1 .. end 

18.7 Focus on Problem Solving and Program Design: Eliminating Recursion 111 3 
Once this is done, the array item at the pivot is in its sorted position. Thu s, an 
important effect of the partition 
procedure is that it gets the pivot element in its final 
sorted position. By keeping track of the left and right subranges when we call 
partit
i on, and then later calling partition 
on those subranges, we can sort the 
entire array without using recursion. We need to keep track of these subran ges and 
eventually partition them in the order in which the recursive calls to Quicksort would 
have done them. Because the recursive calls to Quicksort are invoked and return in 
LIFO (last-in-first-out ) order, we use a stack to keep track of the ranges that are 
waiting to be partitioned. 
The main idea of our solution is to define a class 
class 
Range 
{ 
int start
; 
int end ; 
public: 
Range(int 
s , int e) 
{ 
} 
} ; 
start= 
s; 
end= e; 
to keep track of the ranges of the array that remain to be partitioned. Accordingly, we 
use the STL stack class to define a stack of these ranges: 
stack<Range> qStack; 
We then use a function qSort (i nt arr[ 
] , i nt size) that sorts the array arr by 
initially pushing the range from O to si ze-1 onto the stack, and then repeatedly 
removing ranges from the stack, partitioning the range, and putting the left and right 
subran ge back onto the stack. Empty subranges removed from the stack are discarded. 
The algorithm is 
push Range{O, size-1) 
onto stack 
Whi1e stack not empty 
pop a ranger 
from the stack 
If r is not empty 
partition 
the ranger 
into two sma11er ranges about the pivot 
push the two sma11er ranges onto the stack 
End if 
End Whi1e 
The complete solution, which reuses the partition function from Chapter 14, is given in 
Program 18-9. Notice that we declare the qSort function to be a friend of Range, to 
allow access to the private members of Range. 
NOTE: The statement qStack. push (Range (0, si ze-1 }}; creates a Range object by 
invoking the constructor. The Range object is then pushed onto the stack. 

1114 
Chapte r 18 
Stacks and Queues 
Program 18-9 
1 II Thi s program i llustrates 
the use of a stack to 
2 II i mplement a nonrecursive 
quicksort. 
3 #i nclude <stack> 
4 #i nclude <iostream> 
5 #i nclude <fstream> 
6 #i nclude <algorithm> 
II Needed for swap 
7 usi ng namespace std; 
8 
9 II Function 
prototypes 
10 void qSort (i nt a[ ] , int size ); 
11 void outputArray(const 
int a[ ] , i nt size); 
12 int partition(
i nt a[ ] , int, 
i nt); 
13 
14 II Range is used to i ndicate 
a segment 
15 II of an array 
that 
i s sti l l to be sorted 
16 cl ass Range 
17 { 
18 
II Make qSort a friend 
19 
20 
fr i end voi d qSort(int 
a[ ] , int); 
i nt start; 
21 
i nt end ; 
22 public: 
23 
Range(int 
s, 
{ 
24 
25 
26 
27 
} 
28 } ; 
29 
start= 
s; 
end= 
e ; 
i nt e) 
30 const 
int MAX 
31 int main () 
= 100 ; 
32 { 
33 
ifstream 
inputFile; 
34 
35 
str i ng filename= 
"sort .dat" 
int array[MAX]; 
36 
int size ; 
37 
inputFile.open(filename
.data()}; 
38 
if (!inputFi
le ) 
39 
{ 
40 
cout << "The f i le 
"<<f
i lename<<" 
cannot be" 
41 
42 
43 
} 
44 
<< "opened 
exit ( 1) ; 
". 
. ' 
45 
II Read the f i le and count the number of i tems in the 
46 
II file
. Take care not to overrun 
the array 
47 
size= 
O; 
48 
whi le (in putF i le >> array [si ze ] } 
49 
{ 
50 
size++
; 
51 
if (size --
MAX} 
52 
break; 
53 
} 
(program continues) 

18.7 Focus on Problem Solving and Program Design: Eliminating Recursion 
Program 18-9 
(continued) 
54 
II Echo the inputted 
array 
55 
cout << "The or i gi nal array 
i s ·• << endl; 
56 
outputArray(array, 
size); 
57 
58 
II Perform the sort 
and output 
the result 
59 
qSort (a rray , size); 
60 
cout << "The sorted 
array 
is : • << endl; 
61 
outputArray(array, 
size); 
62 
return 
O; 
63 } 
64 
65 //******************************************** 
66 II qSort performs 
a nonrecursive 
quicksort 
* 
67 II on the array 
a[ ] of the gi ven size 
* 
68 //******************************************** 
69 void qSort (i nt arr[ 
] , int size) 
70 { 
71 
II qStack holds segments of the array 
that 
have not 
72 
II yet been sorted 
73 
stack<Range> qStack; 
74 
int pivot, 
start, 
end; 
75 
76 
qStack .push(Range(O, 
size-1)}; 
77 
II As long as there 
is a range waiting 
to be sorted, 
78 
II take it off the stack, 
partition 
it, 
and then 
79 
II put the result
i ng two smaller 
ranges onto the stack 
80 
while 
(!qStack.
empty (}) 
81 
{ 
82 
Range currentRange 
= qStack .top(); 
83 
qStack .pop (); 
84 
85 
II Get the endpoints 
of the current 
Range 
86 
II and part i t i on it 
87 
start= 
currentRange
.start; 
88 
end= 
currentRange
.end ; 
89 
i f (s tart< 
end ) 
90 
{ 
91 
pivot= 
part i tion (arr, 
start, 
end ); 
92 
II Store the result
i ng smaller 
ranges for later 
93 
II process i ng 
94 
qStack.push(Range(start, 
pivot-1
)); 
95 
qStack.push(Range(p
i vot + 1, end )); 
96 
} 
97 
} 
98 } 
99 
100 //***************************************************** 
101 II partition 
rearranges 
the entries 
in the array 
arr 
102 II from start 
to end so all 
values 
greater 
than or 
103 II equal to the pivot are on the right 
of the pivot 
104 II and all 
values 
less 
than are on the left 
of the 
105 II pivot . 
* 
* 
* 
* 
* 
106 //***************************************************** 
(program continues) 
1115 

1116 
Chapte r 18 
Stacks and Queues 
Program 18-9 
(continued) 
107 int partition(int 
arr[], 
int start, 
int end) 
108 { 
109 
// The pivot 
element is taken to be the element at 
110 
// the start 
of the subrange 
to be part i tioned 
111 
int pivotValue 
= arr[start
] ; 
112 
int pivotPosition 
= start
; 
113 
114 
// Rearrange 
the rest 
of the array 
element s to 
115 
// partit
i on the subrange 
from start 
to end 
116 
fo r (in t pos =s tart+ 
1; pos <= end ; pos++) 
117 
{ 
118 
if (ar r[ pos ] < pivotValue) 
119 
{ 
120 
// arr[scan
] is the "current" 
item. 
121 
// Swap the current 
item with the item to the 
122 
// right 
of the pivot 
element 
123 
swap(arr[pivotPosition 
+ 1], 
ar r[ pos ]); 
124 
// Swap the current 
item with the pivot el ement 
125 
swap(arr[pivotPosition
] , arr[pivotPosition 
+ 1] ); 
126 
// Adjust the pivot 
position 
so it stays with the 
127 
// pivot 
element 
128 
pivotPosition 
++; 
129 
} 
130 
} 
131 
return 
pivotPos itio n; 
132 } 
133 
134 //************************************* 
135 // Output an array's 
el ements. 
* 
136 //************************************* 
137 void outputArray(const 
int arr[ 
] , int siz e) 
138 { 
139 
fo r (in t k = O; k < size ; k++) 
140 
cout << arr[k ] <<" 
"· 
141 
cout << endl ; 
142 } 
Program Output 
The 
34 
The 
- 45 
original 
array 
is 
- 45 
78 32 
90 
45 
sorted 
array 
is: 
32 
0 
34 
45 
78 
90 
NOTE: The friend concept should be used with caution, since it circumvents the 
protection afforded the members of the class by declaring them private. Notice that 
in our case, the start and end members of the Range class are never modified by the 
friend function qSort. 

18.8 
~ 
18.8 Tying It All Together: Converting Postfix Expressions to Infix 
1117 
Tying It All Together: Converting Postfix 
Expressions to Infix 
Stacks can be used to evaluate postfix expressions. Let's see how this can be done. We 
confine ourselves to postfix expressions that contain only numbers and the binary 
operators +, -, ", and/ . 
Recall from Chapter 14 that a postfix expression is either a single number or two 
postfix expressions followed by an operator. Evaluation of a single-number postfix 
expression is easy: we just return the number. For the nonsimple case, we must evaluate 
the two postfix expressions in order and save their values. Then, when we come to the 
operator, we retrieve the two previously saved values and apply the operator. 
To see how the method works consider the example 
2 5 -
Because 2 and 5 are single-number postfix expressions, we simply save their values for 
later use. Then, when we encounter the minus operator, we retrieve the two saved values 
and apply the operator, yielding - 3 as the value of the entire expression . In general, any 
postfix expression can be evaluated by reading it in left to right order. Whenever a value 
is encountered, it is pushed onto the stack to await application by an operator at a later 
stage. Whenever an operator is encountered, its two operands are popped off the stack, 
and the operator is applied to them to yield a value. This value is in tum pushed onto the 
stack. The procedure ends when all of the input expression has been read. At that time, 
there should be only one value on the stack. The value on the stack is the value of the 
postfix expression . 
This same idea can be used to convert postfix expressions to infix. Again, we read the 
input postfix expression from left to right. This time, though, we use a stack of strings 
instead of a stack of integers. Any number that is read must be an operand: It is 
converted to a string and pushed onto the stack. If an operator is encountered, the two 
strings at the top of the stack are popped and the operator is placed between them. 
Parentheses are then placed around the resulting string, and the parenthesized string is 
pushed back onto the stack. Thus, for example, the above input postfix expression 
would result in the following sequence of pushes of strings onto the stack: 
"2" 
"2" 
"5" 
"(2 
-
5)" 
These ideas are used in Program 18- 10. 
Program 18-10 
1 // This program converts 
postf i x expressions 
to infix. 
2 #include 
<std i o.h> 
3 #include 
<cstdl i b> 
4 #include 
<str i ng> 
5 #include 
<iostream> 
(program continues) 

1118 
Chapte r 18 
Stacks and Queues 
Program 18-10 
(continued) 
6 #include 
<sstream> 
7 #include 
<stack> 
8 
9 us i ng namespace std; 
10 
11 string 
postfixExpr(
i stream& i nputStream); 
12 
13 i nt mai n() 
14 { 
15 
str i ng input; 
16 
cout << "Enter a postfix 
expression 
to convert 
to inf i x," 
17 
<<" 
\nor a blank l ine to quit 
the program:"; 
18 
getline(cin, 
input); 
19 
while 
(input.s
i ze() 
!= 0) 
20 
{ 
21 
II Convert str i ng to a string 
stream 
22 
istringstream 
i nputExpr(input); 
23 
cout << "The infix 
equivalent 
is" 
24 
<< postfixExpr(inputExpr) 
<< endl; 
25 
cout << "Enter another 
postfix 
express i on: "· 
26 
getline(cin, 
input); 
27 
} 
28 
return 
O; 
29
} 
30 
31 //*************************************************************** 
32 II Takes an istream 
that 
conta i ns a single 
postfix 
express i on p * 
33 II and returns 
a string 
representing 
the i nfix equivalent 
of p 
* 
34 //*************************************************************** 
35 string 
postfixExpr(
i stream & in) 
36 { 
37 
II Holds intermediate 
values 
i n computat i on 
38 
stack<string> 
i nfixStack; 
39 
II Used to read characters 
i n the expression 
40 
char ch; 
41 
II Used to read numbers in the express i on 
42 
int number; 
43 
II Used to remove i nfix express i ons from the stack 
44 
str i ng lExpr, 
rExpr; 
45 
46 
ch= 
in.peek(); 
47 
while 
(ch!= 
EOF) 
48 
{ 
49 
II If we have a whitespace 
character 
skip i t and 
50 
II continue 
with the next iteration 
of this 
loop 
51 
if 
(isspace(ch)) 
52 
{ 
53 
54 
55 
56 
} 
ch = in . get() ; 
ch = in . peek() ; 
cont i nue; 
II Go back to top of loop 
(program continues) 

18.8 Tying It All Together: Converting Postfix Expressions to Infix 
1119 
Program 18-10 
(continued) 
57 
58 
59 
60 
61 
62 
63 
64 
65 
66 
67 
68 
69 
70 
71 
72 
73 
74 
75 
76 
77 
78 
79 
80 
81 
82 
83 
84 
85 
86 
87 
88 
89 
90 
91 
92 
93 
94 } 
} 
II Nonspace character 
is next in input stream 
II If the next character 
i s a number, read it, 
convert 
II to string, 
and push the string 
onto the infix 
stack 
if (isdigit(ch)} 
{ 
} 
in>> 
number; 
II Use to convert 
number to str i ng 
ostringstream 
numberStr; 
II Convert number to str i ng using stream 
numberStr << number; 
II Push the expression 
string 
onto the stack 
inf i xStack .push(numberStr
.str()); 
ch= 
i n.peek(); 
continue; 
II If the next character 
i s an operator, 
II pop the two top infix 
expressions 
stored 
on the 
II stack, 
put the operator 
between the two infix 
II express i ons, and then push the result 
on the stack 
rExpr = i nfixStack.top(); 
infixStack.pop(}; 
l Expr = i nfixStack.top(); 
infixStack.pop(}; 
if ( ch == ' + ' I I ch == ' - ' I I + ch == ' * ' I I ch --
' I ' } 
{ 
infixStack.push("(" 
+ l Expr + " "+ 
ch + " " + rExpr + ")"); 
} 
else 
{ 
} 
cout << "Error 
in the input expression"<< 
endl; 
exi t(1); 
ch = in. get (); 
I I Actua l 1 y read the operator 
character 
ch= 
in.peek(}; 
II Prepare 
for next i terat
i on of loop 
return 
inf i xStack .top(); 
Program Output with Example Input Shown in Bold 
Enter a postfix 
expression 
to convert 
to infix, 
or a blank line 
to quit 
the program: 
56 [Enter] 
The infix 
equivalent 
is 56 
Enter another 
postfix 
expression: 
56 2 + [Enter] 
The infix 
equivalent 
is (56 + 2} 
Enter another 
postfix 
expression: 
56 2 + 12 9 - * [Ent er] 
The infix 
equivalent 
is ( (56 + 2) * (12 - 9)} 
Enter another 
postfix 
expression: 
[Ent er] 

1120 
Chapte r 18 
Stacks and Queues 
Review Questions and Exercises 
Short Answer 
1. What does LIFO mean? 
2. What element is retrieved from a stack by the pop operat ion? 
3. What is the difference between a static stack and a dynamic stack? 
4. Describe two operations that all stacks perform. 
5. The STL stack is considered a container adapter. What does that mean? 
6. What types may the STL stack be based on? By default, what type is an STL 
stack based on? 
7. What does FIFO mean? 
8. When an element is added to a queue, where is it added? 
9. When an element is removed from a queue, where is it removed from? 
10. Describe two operations that all queues perform . 
11. What two queue-like containers does the STL offer? 
12. Suppose the following operations were performed on an empty stack: 
push (O); 
push (9); 
push(12); 
push(1); 
Insert numbers in the following diagram to show what will be stored in the static 
stack after the operations have executed. 
top of stack 
bottom of stack 
13. Suppose the following operations were performed on an empty stack: 
push(8); 
push(?); 
pop(); 
push (19); 
push(21); 
pop(); 
Insert numbers in the following diagram to show what will be stored in the static 
stack after the operations have executed. 

Review Questions and Exercises 
11 21 
top of stack 
bottom of stack 
14. Suppose the following operations are performed on an empty queue: 
enqueue(5); 
enqueue(?); 
enqueue(9); 
enqueue ( 12); 
Insert numbers in the following diagram to show what will be stored in the static 
queue after the operations have executed. 
front 
rear 
15. Suppose the following operations are performed on an empty queue: 
enqueue(5); 
enqueue(?); 
dequeue(); 
enqueue(9); 
enqueue ( 12); 
dequeue(); 
enqueue(10); 
Insert numbers in the following diagram to show what will be stored in the static 
queue after the operations have executed. 
front 
rear 
16. What problem is overcome by using a circular array for a static queue? 
Algorithm Workbench 
17. Give pseudocode that implements a queue using two stacks. The queue operations 
enqueue, dequeue, and empty must be implemented in terms of the push, pop, 
and empty stack operations . 
Soft Skills 
18. A common real-life example used to explain stacks is the stack of plates in a 
cafeteria. Find at least two other real-life examples in which items are added and 
removed from a container in last-in-first-out order, and use these examples to 
explain the concept of a stack. 

112 2 
Chapte r 18 
Stacks and Queues 
0 
Programming 
Challenges 
1. Static Stack Template 
In this chapter you studied Int Stac k, a class that implements a static stack of integers. 
Write a template that will create a static stack of any data type. Demonstra te the class 
with a driver program . 
2. Dynamic Stack Template 
In this chapter you studied Dyn in tSta ck , a class that implements a dynamic stack of 
integers. Write a template that will create a dynamic stack of any data type. Demonstrate 
the class with a driver program . 
3. Static Queue Template 
In this chapte r you studied I nt Queue, a class that implements a static queue of integers. 
Write a template that will create a static queue of any data type. Demonstrate the class 
with a driver program . 
4. Dynamic Queue Template 
In this chapter you studied Dy nin t Queue, a class that implements a dynamic queue of 
integers. Write a template that will create a dynamic queue of any data type. Demonstrate 
the class with a driver program. 
5. Error Testing 
The Dyn intS t ack and Dyn in t Queue classes shown in this chapter are abstrac t data 
types using a dynamic stack and dynamic queue, respectively. The classes do not 
currently test for memory allocaton errors. Modify the classes so they determine if new 
nodes cannot be created, and handle the error condit ion in an approp riate way. (You 
will need to catch the predefined exception bad_ a 11 oc .) 
NOTE: If you have already done Programming Challenges 2 and 4, modify the 
templates you created . 
6. Dynamic String Queue 
Design a class that stores strings on a dynamic queue. The strings should not be fixed 
in length. Demonstrate the class with a driver program. 
7. Queue Exceptions 
Modify the static queue class used in Program 18-5 as follows. 
1. Make the i sF ul 1 member private. 
2. Define a queue overflow exception and modify enque ue so that it throws this 
exception when the queue runs out of space. 
3. 
Define a queue underflow exception and modify dequeue so that it throws this 
exception when the queue is empty. 

VideoNote 
Solving the 
File Reverser 
Problem 
Programming Challenges 
11 23 
4. 
Rewrite the main program so that it catches overflow exceptions when they occur. 
The exception hand ler for queue overflow should print an appropriate error 
message and then terminate the program . 
8. Stack Copy Operations 
Modify the IntStack 
class of Section 18.2 by adding a copy constructor and a copy 
assignment operator. Test your code in a program that creates a stack, pushes some 
values onto it, and then copies the stack two different ways, one using a copy 
constructor and one using copy assignment. Your program should include code that 
demonstrates the correctness of the new operations. 
9. File Reverser 
Write a program that opens a text file and reads its contents into a stack of characters. 
The program should then pop the characters from the stack and save them in a second 
text file. The order of the characters saved in the second file should be the reverse of 
their order in the first file. 
10. Balanced Parentheses 
A string of characters has balanced parentheses if each right parenthesis occurring in 
the string is matched with a preceding left parenthesis in the same way each right 
brace in a C++ program is matched with a preceding left brace. Write a program that 
uses a stack to determine whether a string entered at the keyboard has balanced 
parentheses. 
11. Balanced Multiple Delimiters 
A string may use more than one type of delimiter to bracket information into "blocks." 
For example, A string may use braces {},parentheses ( ), and brackets [] as delimiters. 
A string is properly delimited if each right delimiter is matched with a preceding left 
delimiter of the same type in such a way that either the resulting blocks of information 
are disjoint or one of them is completely nested within the other. Write a program that 
uses a single stack to check whether a string containing braces, parentheses, and 
brackets is properly delimited. 
12. Stack-based Binary Search 
Imitate the technique of Section 18.7 and use a stack to remove recursion from the 
binary search algorithm. 
13. Stack-based Fibonacci Function 
Use a stack to remove recursion from the implementation of the Fibonacci function 
discussed in Section 14.4. 
14. Stack-based Evaluation of Postfix Expressions 
Write a program that reads postfix expressions and prints their values. Each input 
expression should be entered on its own line, and the program should terminate when 
the user enters a blank line. Assume that there are only binary operators and that the 

1124 
Chapte r 18 
Stacks and Queues 
expressions contain no variables. Your program should use a stack. Here are sample 
input- output pairs: 
78 
78 
6 
+ 
78 
6 
+ 
9 
2 
I 
78 
84 
12 
15. Stack-based Evaluation of Prefix Expressions 
Write a program that reads prefix expressions and prints their values. Each input 
expression should be entered on its own line, and the program should terminate when 
the user enters a blank line. Assume that there are only binary operators and that the 
expressions contain no variables. Your program should use a stack. Here are sample 
input- output pairs: 
78 
+ 
78 
6 
I 
+ 
78 
6 
9 
2 
78 
84 
12 
Hint: Go through the prefix expression from left to right, pushing operators and values 
onto a stack . Whenever you have two values on the stack with an operator just 
underneath them, pop the two values, pop the operator, apply the operator to the 
value, and push the result (which is a value) onto the stack. The tricky part is how to 
store both operators of type char and values of type i nt on the same stack. Think 
about a type such as the following: 
struc t StackE l ement 
{ 
bool i s_va l ue; 
in t va l ue; 
char op; 
StackE l ement(int 
number) 
{ 
) 
i s_va l ue = true; 
value= 
number; 
StackE l ement(char 
ch) 
{ 
i s_va l ue = false; 
op= 
ch; 
) 
} ; 
You might consider using a vector as a stack to make it easier to get at the three 
elements at the top of the stack. 

TOPICS 
19.1 Definition and App lications of 
Binary Trees 
19.3 Template Considerations for Binary 
Search Trees 
19.2 Binary Search Tree Operations 
19.4 Tying It All Togethe r: Genealogy Trees 
19.1 
Definition and Applications of Binary Trees 
CONCEPT: 
Binary trees differ from linked lists in that where a nod e in a linked list 
may have at most one successor, a nod e in a binary tree can have up to 
two successors. 
A binary tree is a collection of nodes in which each node is associated with up to two 
successor nodes, respectively called the left and right child. Not every node in the 
binary tree will have two children: One or both nodes may be omitted . A node in a 
binary tree that has no children is called a leaf node . 
A node that has children is said to be the parent of its children. For a nonempty 
collection of nodes to qualify as a binary tree, every node must have at most one parent, 
and there must be exactly one node with no parent. The one node that has no parent is 
called the root of the binary tree. An empty collection of nodes is regarded as constituting 
an empty binary tree. 
There is some similarity between a linked list and a binary tree. The root of a binary 
tree corresponds to the head of a list, a child of a binary tree node corresponds to a 
successor node in a list, and the parent of a binary tree node corresponds to the 
predecessor of a node in the list. And of course, the analog of the empty list is the 
empty binary tree. 
1125 

1126 
Chapter 19 
Binary Trees 
Figure 19-1 
Implementation 
of Binary Trees 
Binary trees are used to store values in their nodes. A node in a binary tree will therefore 
be a structure or class object that contains a member for storing the value, as well as 
two members that point to nodes that are the left and right children of that node: 
struc t TreeNode 
{ 
} ; 
i nt value; 
TreeNode *left; 
TreeNode *right; 
A binary tree is itself represented by a pointer to the node that is the root of the tree. 
An examp le binary tree, with the values stored in the node s not shown, is illustrated in 
Figure 19-1. The 1 eft or right pointer in a node is set to nul 1 pt r if that node does not 
possess the corresponding child. 
left 
right 
left 
right 
nullptr 
nullptr 
root 
pointer 
left 
right 
nullptr 
nullptr 
left 
right 
left 
right 
nullptr 
nullptr 
Binary trees are called trees because they resemble an upside-down tree. Any nonempty 
tree can be partitioned into its root node , its left subtr ee, and its right subtr ee. 
Intuit ively, a subtree is an entire branch of the tree, from one part icular node down. 
Figure 19-2 shows the left subtree of the binary tree depicted in Figure 19-1. 
Applications of Binary Trees 
Searching any linear data structure, such as an array or a standard linked list, is slow when 
the structure holds a large amount of information. This is because of the sequential nature 
of linear data structures. Binary trees and their generalizations are excellent data structures 
for searching large amounts of information . They are commonly used in database 
applications to organize key values that index database records. When used to facilitate 

Figure 19-2 
Figure 19-3 
-
,.,. 
Left Subtree/ 
/ 
left 
/ 
/ 
/ 
I 
I 
left 
right 
I 
I 
\ 
nullptr 
nullptr 
' ' 
,.,. 
.... 
-
- - - - -
-
right 
/ 
/ 
/ 
19.1 Definition and App lications of Binary Trees 
11 2 7 
root 
Pointer 
left 
right 
' ' \ 
\ 
I 
nullptr / 
I 
I 
/ 
nullptr 
left 
right 
left 
right 
nullptr 
nullptr 
searches, a binary tree is called a binary search tree. Binary search trees are the primary 
focus of this chapter. 
Information is stored in binary search trees in a way that makes searching for information 
in the tree simple. For example, look at Figure 19-3. 
M 
left 
right 
F 
left 
right 
B 
nullptr 
nullptr 
root 
Pointer 
left 
right 
nullptr 
p 
nullptr 
left 
right 
R 
left 
right 
nullptr 
nullptr 

1128 
Chapter 19 
Binary Trees 
Figure 19-4 
The figure depicts a binary search tree where each node stores a letter of the alphabet. 
Notice that the root node holds the letter M. The left child of the root node holds the 
letter F, and the right child holds R. Values are stored in a binary search tree so that a 
node's left child holds data whose value is less than the node's data, and the node's 
right child holds data whose value is greater than the node's data . This is true for all 
nodes in the tree that have children. 
In fact, in a binary search tree, all the nodes to the left of a node hold values less than 
the node's value. Likewise, all the nodes to the right of a node hold values that are 
greater than the node's data . When an application is searching a binary search tree, it 
starts at the root node. If the root node does not hold the search value, the application 
branches either to the left or right child, depending on whether the search value is less 
than or greater than the value at the root node. This process continues until the value 
is found or it is determined that the search value is not in the tree. Figure 19-4 illustrates 
the search pattern for finding the letter P in the binary tree shown . 
left 
F 
left 
right 
B 
nullptr 
nullptr 
M 
right 
root 
pointer 
left 
nullptr 
' 
right 
\ 
\ 
1 __ 
..,.:
, ........:i. 
__ 
_ 
/ 
left 
right 
I 
R 
31 
left 
right 
p 
nullptr 
nullptr 
nullptr 
This manner of searching a binary tree is reminiscent of the binary search technique 
that is used on sorted arrays. Assuming that the binary tree is balanced (meaning that 
at each node, the left and right subtrees have approximately the same number of nodes), 
the search will reduce the size of the tree remaining to be searched by one-half at each 
step. This makes it possible to search trees with very large amounts of informat ion in a 
relatively small number of steps. 
~ 
Checkpoint 
19.1 Describe the difference between a binary tree and a linked list. 
19.2 What is a root node? 
19.3 What is a child node? 

19.2 
19.4 
What is a leaf node? 
19.5 
What is a subtree? 
19.2 Binary Search Tree Operations 
1129 
19.6 
Why are binary trees suitable for algorithm s that must search large amounts of 
information? 
Binary Search Tree Operations 
CONCEPT: 
Many operations may be performed on a binar y search tree, includin g 
creati ng a binar y search tree, inserting, findin g, and deleting nodes. 
In this section you will learn some basic operations that may be performed on a binary 
search tree . We will study a simp le class that implements a binary tree for sto ring 
integer values. 
Creating a Binary Search Tree 
We will demonstrate the fundamenta l binary tree operations using the IntBi naryTree 
class. The basis of our binary tree node is the following struc t ure declaration: 
st ruct TreeNode 
{ 
i nt value; 
TreeNode *lef t ; 
TreeNode *right; 
TreeNode(int 
value1, 
TreeNode *lef t1 = nullptr, 
TreeNode *right1 
= nullp t r) 
{ 
) 
) ; 
value= 
value1; 
left 
= l eft1 ; 
r i ght = right1 ; 
Notice that each node of the tree has a value member, as well as two pointers to keep 
track of the left and right children of the node . The class will only be used by methods 
of the following IntBi naryTree class. 
Contents of I ntBi naryTree. h 
1 class 
IntBinaryTree 
2 { 
3 private
: 
4 
// The TreeNode 
5 
struct 
TreeNode 
6 
{ 
7 
i nt value; 
st ruct 
8 
TreeNode *left
; 
is used to build the tree. 

1130 
Chapter 19 
Binary Trees 
9 
TreeNode *right
; 
10 
TreeNode( i nt value1, 
11 
TreeNode *left1 
= nullptr, 
12 
TreeNode *r i ght1 = nullptr) 
13 
{ 
14 
value= 
value1; 
15 
left= 
left 1; 
16 
right= 
right1; 
17 
} 
18 
}; 
19 
20 
TreeNode *root; 
II Pointer 
to the root of the tree 
21 
22 
II Various helper 
member functions. 
23 
void insert(TreeNode 
*&, int ); 
24 
void destroySubtree(TreeNode 
*}; 
25 
void remove(TreeNode 
*&, i nt}; 
26 
void makeDeletion(TreeNode 
*&); 
27 
void displaylnOrder(TreeNode 
*} const; 
28 
void di splayPreOrder(TreeNode 
*) const; 
29 
void di splayPostOrder(TreeNode 
*) const; 
30 
31 public : 
32 
II These member functions 
are the public 
interface. 
33 
IntBinaryTree
() 
34 
35 
{ 
36 
} 
root = null ptr; 
37 
38 
-IntBina
ry Tree (} 
{ 
39 
destroySubtree(root); 
40 
} 
41 
void insert(
i nt num) 
42 
{ 
43 
insert(root, 
num); 
44 
} 
45 
bool search( i nt} const ; 
46 
void remove( i nt num) 
47 
{ 
48 
remove(root, 
num); 
49 
} 
50 
void showlnOrder(vo i d) const 
51 
{ 
52 
di splaylnOrder(root); 
53 
} 
54 
void showPreOrder() 
const 
55 
{ 
56 
di splayPreOrder(root); 
57 
} 
58 
void showPostOrder() 
const 
59 
{ 
60 
di splayPostOrder(root); 
61 
} 
62 } ; 
II Constructor 
II Destructor 

19.2 Binary Search Tree Operations 
1131 
Besides the TreeNode class declaration, the class has a root member. This is a pointer 
to the root node of the binary tree and plays a role similar to that of the head pointer in 
the linked list class of Chapter 17. In many instances, it is useful to think of the pointer 
to the node that is the root of a binary tree as the binary tree itself. Thus, we may write 
TreeNode *tree; 
or 
TreeNode *root; 
and think of both as representing a binary tree because the root provides access to the 
entire tree. On the other hand, it is also useful to think of an object of the I ntBi naryTree 
class as a binary tree, and write 
IntB i naryTree Tree; 
To avoid confus ion, we will use identifier s with an initial capita l letter for a binary tree 
that is represented by an object of the IntBi naryTree class and use identi fiers with 
initial lowercase letters for a binary tree represented by a pointer to its root node . 
The public member functions of I ntBi nary Tree include a constr uctor, a destructor, 
and member functions for inserting a new number into the tree, for searching a tree to 
determine whether a given number is in the tree, for removing a number from the tree, 
and for displaying the numbers stored in the tree according to different orders. All of 
these member functions are discussed in the sections that follow . 
Program 19-1 demonstrates the creation of an IntBi naryTree object and the use of the 
public insert member function to build a binary search tree. The implementation code 
for the member functions are in the IntB i naryTree . cpp file; the contents of that file 
will be discussed later. The tree that results from the execution of Program 19-1 is 
shown in Figure 19-5. 
Program 19-1 
1 // Thi s program bui lds a bi nary tree with 5 nodes. 
2 #include 
<iostream> 
3 #include 
"IntBinaryTree
.h" 
4 using namespace std ; 
5 
6 int main() 
7 { 
8 
IntBinaryTree 
tree; 
9 
10 
cout << "Insert i ng numbers . "; 
11 
tree.insert
(5); 
12 
tree.insert
(8); 
13 
tree.insert
(3); 
14 
tree.insert
(12); 
15 
tree.insert
(9); 
16 
cout << "Done. \n" ; 
17 
return 
O; 
18 ) 

1132 
Chapter 19 
Binary Trees 
Figure 19-5 
a 
VideoNot e 
Inserting an 
Element into a 
Binary Tree 
5 
left 
right 
3 
nullptr 
root 
pointer 
left 
right 
nullptr 
8 
nullptr 
left 
right 
left 
right 
12 
left 
right 
9 
nullptr 
nullptr 
Implementation 
of the Binary Search 
Tree Operations 
nullptr 
Many binary tree operations have very natura l recursive implementations . This is 
because a binary tree is an inherently recursive data structure: Every nonempty binary 
tree consists of a root node together with the left and right subtrees, which are, of 
course, binary trees. Many binary tree operations can be implemented by performing 
some processing at the root node and then recursively perform ing the operation on the 
left and right subtrees. For example, if the root node is represented by a pointer 
Tre eNode *t ree ; 
then the value in the root node will be t r ee- >val ue, and the left and right subtrees will 
be given by t r ee- >le ft and t r ee - >ri ght . A recursive operation might first process 
t r ee- >va l ue, and then recursively operate on tr ee- >l eft and tr ee- >ri ght . 
Inserting an Element 
The work of inserting a number into a binary search tree is performed by the private 
member function 
i nser t (Tr eeNode *&tr ee, in t num) 
which is passed a pointer t r ee to the root node of a binary search tree and a number 
num to be inserted into the tree. It uses a recursive strategy: If the binary tree is empty 
(this is the base case for the recursion ), it creates a new Tre eNode object whose value 
member is the given number and makes it the root of the tree: 

0 
if 
(! tree ) 
{ 
) 
tree= 
new TreeNode(num); 
return; 
19.2 Binary Search Tree Operations 
11 33 
If, however, the binary search tree is not empty, the insert 
function compares num to 
the t ree - >va 1 ue, the value in the root node. Depending on the outcome of this 
comparison, the new value is recursively inserted into the left or right subtree: 
if 
(num < tree - >value) 
insert(tree
- >left, 
num); 
else 
insert(tree
- >ri ght , num); 
The entire function is given here: 
voi d IntBinaryTree
::in sert (TreeNode * &tree , int num) 
{ 
) 
II If the tree 
is empty, make a new node and make it 
II the root of the tree 
if ( ! tree) 
{ 
) 
tree= 
new TreeNode (num); 
return; 
II If num is already 
in tree: 
return 
if (tree - >value == num) 
return
; 
II The tree 
is not empty : insert 
the new node into the 
II left 
or r i ght subtree 
if (num < tree - >value) 
i nsert(tree
- >left, 
num); 
else 
i nsert(tree
- >right, 
num); 
Note that the function is passed a reference to a pointer because the pointer passed 
may need to be modi fied by the function . This is also the reason the remove and 
makeDe let ion functions are passed their parameters by reference. 
NOTE: 
The shape of the tree shown in Figure 19-5 is determined by the order in 
which the values are inserted. Th e root node holds the value 5 because that was the 
first value inserted. By stepping through the function , you can see how the othe r 
nodes came to appear in their depicted positions. 
Traversing the Tree 
There are three common methods for traversing a nonempty binary tree and processing 
the value of each node: inorder, preorder, and postorder. Each of these methods is best 
implemented as a recursive function . The algorithm s are described as follows. 

11 34 
Chapter 19 
Binary Trees 
• lnorder traversal 
1. The node's left subtree is traversed. 
2. The node's data is processed. 
3. The node's right subtree is traversed . 
• Preorder traversal 
1. The node's data is processed. 
2. The node's left subtree is traversed. 
3. The node's right subtree is traversed. 
• Postorder traversal 
1. The node's left subtree is traversed. 
2. The node's right subtree is traversed. 
3. The node's data is processed. 
The I ntBi naryTree class can display all the values in the tree using all three of these 
algorithms. The algorithms are initiated by the following inline public member functions: 
voi d showlnOrder (voi d) 
{ di splaylnOrder(root
); } 
voi d showPreOrder( ) 
{ di splayPreOrder
(r oot ); } 
voi d showPostOrder () 
{ di splayPostOrder(root
); } 
Each of the public member functions calls a recursive private member function and 
passes the root pointer as an argument. The recursive functions are very simple and 
straightforward: 
voi d IntBinaryTree
: :di splaylnOrder(TreeNode 
*tree) 
const 
{ 
if (tree} 
{ 
disp l aylnOrder (t ree - >l eft ); 
cout << tree - >value 
<< • 
"; 
displaylnOrder(tree
- >right ); 
} 
} 
voi d IntBinaryTree
:: di splayPreOrder
(TreeNode *tr ee } const 
{ 
if (tree) 
{ 
cout << tree - >value 
<< • 
"; 
displayPreOrder(tree
- >left); 
disp l ayPreOrder(tree
- >right); 
} 
} 
voi d IntBinaryTree
:: di splayPostOrder(TreeNode 
*tree) 
const 
{ 
} 
if (tree} 
{ 
disp l ayPostOrder
(t ree - >le ft ); 
disp l ayPostOrder
(t ree - >right ); 
cout << tree - >value 
<< • 
} 
". 
' 

19.2 Binary Search Tree Operations 
1135 
Program 19-2, which is a modification of Program 19-1, demonstrates 
each of these 
traversal methods. 
Program 19-2 
1 II Thi s program builds 
a binary 
tree 
with 5 nodes. 
2 II The nodes are displayed 
with inorder, 
preorde r, 
3 II and postorder 
algor i thms . 
4 #include 
<iostream> 
5 #include 
"IntBinaryTree
.h" 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
IntB i naryTree 
tree; 
11 
cout << "Inserting 
the numbers 5 8 3 12 9 . \n\ n"; 
12 
tree .in sert
(5); 
13 
tree .in sert
(8); 
14 
tree .in sert
(3); 
15 
tree .in sert
(12); 
16 
tree .in sert
(9); 
17 
18 
19 
20 
cout << "Inorder 
traversal: 
tree .s howinOrde r(); 
.. 
' 
21 
22 
23 
24 
25 
26 
cout << "\n\nPreorder 
traversal
: 
tree .s howPreOrder (); 
27
) 
cout << "\n\nPostorder 
traversal: 
tree .s howPostOrde r(); 
return 
O; 
Program Output 
Inserting 
the numbers 5 8 3 12 9. 
Inorder 
traversal: 
3 
5 
B 9 
12 
Preorder 
traversal: 
5 
3 
8 
12 
9 
Postorder 
traversal: 
3 
9 
12 
B 5 
.. 
' 
". 
' 
Searching the Binary Search Tree 
T he IntB i narySearchTree 
class has a publ ic member function search , wh ich returns 
tr ue if a given value is found in the tree and returns false 
otherwise . Th e function 
simp ly starts out searching the entire tree. Th e function compares num, the value being 
searched for, to the value in the root of the tree it is currently searching . If the value 
matches, the function returns true. If the value does not match, the function replaces 
the tree with either its left subtree or its right subtree and continues the search. T he 
search will terminate when the function finds the value or when the tree being searched 
becomes empty . 

11 36 
Chapter 19 
Binary Trees 
bool IntBinaryTree: 
:s earch (in t num) const 
{ 
} 
TreeNode *tree= 
root; 
whi le (tree ) 
{ 
} 
if (tree - >value == num) 
return 
true ; 
else 
i f (num < tree - >value) 
tree= 
tree - >left; 
else 
tree= 
tree - >right; 
return 
false; 
Program 19-3 demonstrates this function. 
Program 19-3 
1 // Thi s program bui l ds a bi nary tree 
with 5 nodes. 
2 II The search 
function 
determines 
if the 
3 // value 3 is in the tree . 
4 #include 
<iostream> 
5 #include 
"IntBinarytree
.h" 
6 using namespace std ; 
7 
8 int main() 
9 { 
10 
IntB i naryTree tree; 
11 
cout << "Insert
i ng the numbers 5 8 3 12 9 . \n\ n"; 
12 
tree .in sert (5); 
13 
tree .in sert (8); 
14 
tree .in sert (3); 
15 
tree .in sert (12); 
16 
tree .in sert (9); 
17 
18 
if (tre e .search (3)) 
19 
cout << "3 is found in the tree.\n"; 
20 
els e 
21 
cout << "3 was not found in the tree . \n"; 
22 
return 
O; 
23 } 
Program Output 
Inserting 
the numbers 5 8 3 12 9. 
3 is found in the tree. 
a 
VideoNot e 
Removing an 
Element from 
a Binary Tree 
Removing an Element 
To remove an element, we first locate the node containing the element and then delete 
the node. The procedure for deleting a node X depends on the number of its children. 
If X has no children, we first find its parent, set the parent's child pointer that links to 

Figure 19-6 
19.2 Binary Search Tree Operations 
1137 
X to nu l l pt r, and then free the memory allocated to X. If Xis the root of the tree, the 
procedure we have just described will not work. In that case, we simply delete X and 
set the pointer to the root of the tree to nu ll pt r . 
A procedure for deleting a nonleaf node must ensure that the subtrees that the node 
links to remain as parts of the tree. The procedure varies according to whether the 
node being deleted has one or two children. Figure 19-6 shows a tree in which we are 
about to delete a node with one subtree. 
root 
pointer 
This node wiU 
be deleted 
left 
right 
left 
right 
left 
right 
left 
right 
nullptr 
nullptr 
left 
right 
nuUptr 
nullptr 
nullptr 
Figure 19-7 shows how we will link the node's subtree with its parent . 
Figure 19-7 
I -
1 
left I 
righ0 
root 
pointer 
left 
right 
I 
I 
l~I 
I 
I 
- - -
____ 
_, 
.--
............ """T--, 
left 
right 
nullptr 
nuUptr 
nullptr 
left 
right 
nullptr 
left 
right 
nullptr 
nullptr 
nullptr 

1138 
Chapter 19 
Binary Trees 
The problem is not as easily solved, however, when the node we are about to delete has 
two subtrees. For example, look at Figure 19-8. 
Figure 19-8 
This node will 
be delet ed 
I -
• 
left I 
right l 
root 
pointer 
left 
right 
~-:-~ 
left 
right 
left 
right 
nullptr 
nullptr 
nullptr nullptr 
nullptr 
left 
right 
left 
right 
nullptr 
nullptr 
Obviously, we cannot attach both of the node's subtrees to its parent, so there must be 
an alternative solution. One way of addressing this problem is to attach the node's 
right subtree to the parent, then find a position in the right subtree to attach the left 
subtree. The result is shown in Figure 19-9. Note that in attaching the left subtree to 
the right subtree, we must take care to preserve the binary tree's search property . 
Figure 19-9 
This node will 
be delet ed 
I -
1 
left I 
right 1 
I 
I • 
I • 
I 
I 
I 
I 
I 
- _, __ , _ 
root 
pointer 
left 
right 
_______ 
_, 
'----
left 
right 
left 
right 
nullptr 
nullptr 
nullptr 
nullptr 
left 
right 
left 
right 
nullptr 
nullptr 

19.2 Binary Search Tree Operations 
1139 
The deletion of a value from an IntB i naryTree object is accomplished by calling the 
public member function remove, which in tum calls the private member function of the 
same name . This latter function is passed (the root of) a binary search tree tree and a 
value num to be removed from the tree: 
remove(TreeNode *&tree , int num) 
Th e function uses a recursive strategy. If the tree is empty, it returns immediate ly. 
Otherwise , if num is less than the value stored in the root node, the function recursively 
removes num from the left subtree; but if num is greater, the function recursively removes 
num from the right subtree. The case where num is found in the root node is handed off 
to a function 
makeDeletion(TreeNode 
*&tree) 
Here is the code for remove: 
voi d IntBinaryTree
:: remove(TreeNode *&tree , int num) 
{ 
) 
if (tree
== nul l pt r) ret urn ; 
if (num < tree->value
) 
remove(tree ->left, 
num); 
else i f (num > tree - >value) 
remove(tree ->right,num); 
else 
// We have found the node to delete . 
makeDel etion (t ree ); 
The makeDe let ion function is designed to remove the root node of the binary search 
tree passed to it as an argument, leaving a binary search tree consisting of the remaining 
nodes. Let us take a look at the logic behind makeDel etion. There are a number of 
cases to consider: 
1. The root of the tree passed to makeDe l et ion has no children. In this case, we 
delete the root node and replace the tree with nullptr. 
2. The root of the tree has only one child. In this case, we delete the root node and 
replace the tree with the child of the deleted root: 
TreeNode *nodeToDelete = tree; 
i f (t ree->right 
== nul lptr ) 
tree
= tree - >left; 
else if (tree->left 
== nullptr) 
tree
= tree - >ri ght; 
Note that this code works for the first case as well. 
3. The tree passed to makeDe l ete has two children. The deletion of the root node 
would leave two subtrees, and we need to do something with both of them. The 
strategy we adopt is to combine the two subtrees into one binary search tree and 
then replace the original tree with the tree built from the combined subtrees. As 
shown in Figure 19-9, we can do this by attaching the left subtree of the origina l 
tree as the left subtree of the least node in the right subtree of the original tree. 
Here is the code for the entire function. 

1140 
Chapte r 19 
Binary Trees 
void IntBinaryTree: 
:makeDeletion (TreeNode *&tree ) 
{ 
} 
// Used to hold node that wi ll be deleted 
TreeNode *nodeToDel ete = tree; 
// Used to lo cate the 
poi nt where the 
// l eft subtree 
i s attached 
TreeNode *att achPoint
; 
if (tree - >right == 
nullptr) 
{ 
} 
// Replace tree with its 
left 
subtree 
tree= 
tree - >left
; 
else 
if (tr ee - >left == 
nullptr) 
{ 
} 
// Replace tree with its 
right 
subtree 
tree= 
tree - >ri ght ; 
else 
//Th e node has two children 
{ 
} 
II Move to right 
subtree 
attachPo i nt = tree - >r i ght; 
// Locate the smallest 
node in the r i ght s ubtr ee 
// by moving as far to the l eft as possible 
whi le (attachPoint
- >left 
!= nullptr) 
attachPo i nt = attachPoint
- >l eft ; 
// Attach 
the l eft subtree 
of the or i ginal 
tree 
// as the left 
s ubtree 
of the smallest 
node 
// in the ri ght subtree 
attachPoint
- >left 
= tree - >left; 
// Replace the or i gi nal tree wi th i ts right 
subtree 
tree
= tree - >right; 
// Delete 
root of or i gi nal tree 
delete 
nodeToDel ete ; 
Program 19-4 demonstrates these functions . 
Program 19-4 
1 // Thi s program builds 
a binary 
tree 
with 5 nodes. 
2 II The deleteNode 
f unction 
is used to remove 2 of them. 
3 #include 
<iostream> 
4 #include 
"IntBinaryTree
.h" 
5 using namespace std ; 
6 
7 int main() 
(program continues) 

19.2 Binary Search Tree Operations 
Program 19-4 
( continued) 
8 { 
9 
IntB i naryTree tree ; 
10 
11 
cout << "Insert
i ng the numbers 5 8 3 12 9 . ". 
' 
12 
tree.insert
(5) ; 
13 
tree.insert
(8) ; 
14 
tree.insert
(3) ; 
15 
tree. insert ( 12) ; 
16 
tree.insert
(9) ; 
17 
18 
cout << "\ nHere are the values 
in the tree:
\ n" ; 
19 
tree.showinOrder()
; 
20 
21 
cout << "\ nDeleting 
8 . . . \ n" ; 
22 
tree.remove
(8) ; 
23 
24 
cout << "Deleting 
12 . . . \n"; 
25 
tree.remove
(12) ; 
26 
27 
cout << "Now, here are the nodes:\n"
; 
28 
tree.showinOrder()
; 
29 
return 
O; 
30 ) 
Program Output 
Inserting 
the numbers 5 8 3 12 9. 
Here are the values 
in the tree: 
3 5 
8 9 
12 
Deleting 
8 .. . 
Deleting 
12 .. . 
Now, here are the nodes: 
3 
5 
9 
For your referenc e, the entire content s of IntBi naryTree file are shown here: 
Contents of I ntBi naryTree. cpp 
1 #include 
<i ostream> 
2 #include 
"IntB i naryTree.h" 
3 using namespace std; 
4 
5 //****
* * * * * * * * * ******
* * * * * * * ******
* * * * * * * * * ******
* * * 
6 II This vers i on of insert 
inserts 
a number into 
* 
7 II a gi ven subtree 
of the main binary 
search 
tree. 
* 
8 //****
* * * * * * * * * ******
* * * * * * * ******
* * * * * * * * * ******
* * * 
9 void IntBinaryTree: 
:insert
(TreeNode * &tree, 
int num) 
10 { 
11 
II 
If the tree 
is empty, make a new node and make i t 
12 
II the root of the tree 
13 
if ( ! tree ) 
14 
{ 
15 
tree= 
new TreeNode(num); 
1141 

1142 
Chapte r 19 
Binary Trees 
16 
17 
18 
return; 
} 
19 
II If num is already 
in tree: 
return 
20 
if (tree - >value == num) 
21 
22 
return; 
23 
II The tree 
is not empty: insert 
the new node i nto the 
24 
II left 
or right 
subtree 
25 
if (num < tree - >value) 
26 
i nsert(tree
- >left, 
num}; 
27 
else 
28 
i nsert(tree
- >right, 
num); 
29 } 
30 
31 //*************************************************** 
32 II destroySubTree 
is called 
by the destructor
. It 
33 II deletes 
all 
nodes i n the tree. 
* 
* 
34 //*************************************************** 
35 void IntBinaryTree: 
:destroySubtree(TreeNode 
*tree) 
36 { 
37 
i f (! tree } return
; 
38 
destroySubtree
(tre e->left); 
39 
destroySubtree
(tre e->right
}; 
40 
II Delete the node at the root 
41 
delete 
tree; 
42 } 
43 
44 //*************************************************** 
45 II searchNode determines 
i f a value i s present 
in 
46 II the tree . If so, the function 
returns 
true. 
47 II Otherwise, 
it returns 
false. 
* 
* 
* 
48 //*************************************************** 
49 bool IntBinaryTree: 
:search(int 
num) const 
50 { 
51 
TreeNode *tree= 
root; 
52 
53 
while 
(t ree ) 
54 
{ 
55 
i f (t ree->value 
== num} 
56 
return 
true; 
57 
else 
if (num < tree -> value} 
58 
tree= 
tree - >left; 
59 
else 
60 
tree= 
tree - >r ight ; 
61 
} 
62 
return 
false; 
63
} 
64 
65 //******************************************** 
66 II remove deletes 
the node in the given tree* 
67 II that 
has a value member the same as num. 
* 
68 //******************************************** 

19.2 Binary Search Tree Operations 
69 void IntBina ry Tree : :remove(TreeNode 
*&tree , int num) 
70 { 
71 
if (tr ee == nullptr) 
return; 
72 
if (num < tree - >value) 
73 
remove(tree
- >left, 
num); 
74 
else 
if (num > tree - >value) 
75 
remove(tree
- >right,num); 
76 
else 
77 
II We have found the node to delete 
78 
makeDeletion
(tree ); 
79 } 
80 
81 //*********************************************************** 
82 // makeDeletion 
takes 
a reference 
to a tree whose root 
83 // is to be deleted. 
If the tree 
has a single 
child, 
84 // the tree 
is rep l aced by the single 
child after 
the 
85 // removal of it s root node . If the tree 
has two chi l dren 
86 // the le ft subtree 
of the de l eted node is attached 
at 
87 // an appropriate 
point 
in the right 
subtree, 
and then 
88 // the r ight subtree 
replaces 
the or igi nal tree. 
• 
• 
• 
• 
• 
• 
• 
89 //*********************************************************** 
90 void IntBina ry Tree : :makeDeletion(TreeNode 
*&tree ) 
91 { 
92 
// Used to hold node that will 
be deleted 
93 
TreeNode *nodeToDelete 
= tree ; 
94 
95 
// Used to locate 
the 
point where the 
96 
// left 
subtree 
is attached 
97 
TreeNode *attachPoint
; 
98 
99 
if (tr ee - >ri ght == nullptr) 
100 
{ 
101 
// Replace tree with its 
l eft subtree 
102 
tree= 
tree - >left; 
103 
} 
104 
else 
if (t ree-> l eft == nullptr) 
105 
{ 
106 
// Replace tree with its 
right 
subtree 
107 
tree= 
tree - >right; 
108 
} 
109 
else 
110 
// The node has two children 
111 
{ 
112 
113 
114 
115 
116 
117 
118 
119 
120 
121 
// Move to right 
subtree 
attachPoint 
= tree - >right; 
II 
Locate the smallest 
node i n the right 
subtree 
// by moving as far to the left 
as possible 
whil e (attachPoint
- >left 
!= nullptr) 
attachPoint 
= attachPoint
- >left; 
// Attach the le ft subtree 
of the original 
tree 
II as the l eft subtree 
of the smallest 
node 
1143 

1144 
Chapte r 19 
Binary Trees 
122 
123 
124 
// in the right 
subtree 
attachPoint
- >left 
= tree - >left; 
125 
126 
127 
128 
// Replace the or i ginal 
tree with its 
right 
subtree 
tree= 
tree - >right; 
} 
129 
// Delete 
root of or igi nal tree 
130 
delete 
nodeToDelete ; 
131 } 
132 
133 //********************************************************* 
134 // This function 
displays 
the values 
stored 
in a tree 
135 / / in i norder . 
* 
* 
136 //********************************************************* 
137 void IntBinaryTree: 
:di splaylnOrder(TreeNode 
*tree) 
const 
138 { 
139 
if (tree} 
140 
{ 
141 
displaylnOrder
(tre e->left); 
142 
cout << tree ->value 
<< • 
"· 
143 
displaylnOrder
(tre e->right}
; 
144 
} 
145 } 
146 
147 //********************************************************* 
148 // This function 
displays 
the values 
stored 
in a tree 
* 
149 / / in i norder . 
* 
150 //********************************************************* 
151 void IntBinaryTree: 
:di splayPreOrder(TreeNode 
*tree) 
const 
152 { 
153 
if (tree} 
154 
{ 
155 
cout << tree ->value 
<< • 
"; 
156 
displayPreOrder(tree
- >left}; 
157 
displayPreOrder(tree
- >right); 
158 
} 
159 } 
160 
161 //********************************************************* 
162 // This function 
displays 
the values 
stored 
in a tree 
163 // in postorder. 
* 
* 
164 //********************************************************* 
165 void IntBinaryTree: 
:di splayPostOrder(TreeNode 
*tree) 
const 
166 { 
167 
if (tree} 
168 
{ 
169 
displayPostOrder
(tre e->left)
; 
170 
displayPostOrder
(tre e->right
); 
171 
cout << tree ->value 
<< • .. 
172 
} 
173 } 

19.4 Tying It All Together: Genealogy Trees 1145 
~ 
Checkpoint 
19.3 
~ 
19.4 
19.7 Describe the sequence of events in an inorder traversal. 
19.8 Describe the sequence of events in a preorder traversal. 
19.9 Describe the sequence of events in a postorder traversal. 
19.10 Describe the steps taken in deleting a leaf node. 
19 .11 Describe the steps taken in deleting a node with one child. 
19.12 Describe the steps taken in deleting a node with two children . 
Template Considerations 
for Binary Search Trees 
CONCEPT: 
Binary searc h trees may be implemented as templates, bu t any data 
types used with them must support the<, >, and == operators. 
The actual implementation of a binary tree template has been left as a Programming 
Challenge for students who have covered Chapters 16 and 19. When designing your 
template, remember that any data types stored in the binary tree must support the<,>, and 
== operators. If you use the tree to store class objects, these operators must be overridden. 
Tying It All Together: Genealogy Trees 
Say we want to write a program that will trace peoples' ancestr ies and build genealogy 
trees. To keep track of each person's biological parents, we might use a class such as 
the following: 
cl ass Person 
{ 
} ; 
string 
name; 
Person *father; 
Person *mother; 
This simple class is very similar to the "node" classes we have been using to build 
binary trees. In maintaining genealogies, however, we are interested in recording not 
only a person's ancestors, but their descendants as well. We also want to keep track of 
gender information to enab le people using the program to distinguish between materna l 
and paternal relatives . The Person class, as shown above, is not adequate for these 
needs. We therefore modify it as shown here: 
enum Gender {male, femal e}; 
cl ass Person 
{ 
} ; 
string 
name; 
Gender gender; 
vector<Person 
*> paren t s; 
vector<Person 
*> chil dren; 

1146 
Chapte r 19 
Binary Trees 
We now have a "node" that can have any number of children and any number of 
parents. Because each person can have at most two parents, the size of the parents 
vector will never exceed two. 
We can make the Person class more usefu l by adding a constructor and several member 
functions. The method 
Person *addChild(string 
name, Gender g); 
creates a Person object with the specified name and gender, adds a pointer p to the 
created object to the chi 1 dren of "this" Person object, and returns p to the caller. 
Another method, 
Person *addChild(Person 
*p); 
adds a pointer to an already created Person object to the chi 1 dren vector of "this" 
Person object. The following code shows the use of these member functions to record 
the fact that a father f and a mother m have a child named "Char l ie": 
Person f("Frank", 
mal e); 
Person m("Mary", female); 
Person *pChild = m.addChild("Charl
i e", mal e); 
f.addChild(pChild); 
There is also a method 
voi d addParent(Person 
*p); 
that is used to record the fact that one person is the parent of another. The class also 
has an overloaded stream operator that outputs the data in a Person object using an 
XML- like format. Finally, the class has severa l methods that can be used to access 
information 
about various members of the class objects. These additiona l functions 
can be seen in lines 29- 34 of Program 19-5. 
Program 19-5 
1 II Thi s program uses a genera l ization 
of binary 
trees 
to build 
2 II genealogy 
trees. 
3 #include 
<vector> 
4 #include 
<str i ng> 
5 #include 
<iostream> 
6 using namespace std; 
7 enum Gender{ma l e, female); 
8 
9 II Person class 
represents 
a person 
participating 
i n a genealogy 
10 cl ass Person 
11 { 
12 
string 
name; 
13 
Gender gender; 
14 
vector<Person 
*> parents; 
15 
vector<Person 
*> chil dren; 
16 
voi d addParent(Person 
*p){ parents.push
_back(p); 
) 
17 publ i C: 
18 
Person 
(string 
name, Gender g) 
(program continues) 

19.4 Tying It All Together: Genealogy Trees 
Program 19-5 
( continued) 
19 
{ 
20 
21 
22 
} 
this - >name = name; 
gender= 
g; 
23 
Person *addChild(string 
name, Gender g); 
24 
Person *addChild(Person 
*p); 
25 
26 
fr i end ostream &operator<< 
(ostream 
&out, Person p); 
27 
28 
II Member funct i ons for getting 
various 
Person i nfo 
29 
string 
getName() const 
{ return 
name; }; 
30 
Gender getGender() 
const 
{ return 
gender; 
}; 
31 
int getNumChil dren() 
const 
{ return 
chil dren.size(}; 
} 
32 
int getNumParents() 
const 
{ return 
parents.size(); 
} 
33 
Person *getChild(
i nt k) const; 
34 
Person *getParent(int 
k) const; 
35 }; 
36 
37 //************************************************************ 
38 II Create a child 
with specified 
name and gender, 
and 
* 
39 II set one of the parents 
to be this 
person. 
* 
40 II Add the new child 
to the list 
of children 
for this 
person* 
41 //************************************************************ 
42 Person *Person: :addChild(string 
name, Gender g} 
43 { 
44 
Person *child= 
new Person(name, 
g}; 
45 
child - >addParent(this}; 
II I am a parent 
of th i s child 
46 
children
.push_back(child); 
II Thi s is one of my children 
47 
return 
chil d; 
48
} 
49 
50 //************************************************************ 
51 II Add a chil d to the list 
of children 
for this 
person 
* 
52 //************************************************************ 
53 Person *Person: :addChild(Person* 
chi ld} 
54 { 
55 
56 
57 
58
} 
59 
chi ld - >addParent(th
i s); 
chi ldren.push
_back(ch il d}; 
return 
child; 
II I am a parent 
of th i s child 
II Thi s is one of my children 
60 //********************************************************* 
61 II Return a pointer 
to the specif i ed parent 
* 
62 //********************************************************* 
63 Person *Person: :getParent(
i nt k} const 
64 { 
65 
if (k < 0 I I k >= parents.size()) 
66 
{ 
67 
cout << "Error 
index i ng parents 
vector
. "<< endl ; 
68 
exit(1}; 
69 
} 
70 
return 
parents
[k]; 
71 } 
(program continues) 
1147 

1148 
Chapte r 19 
Binary Trees 
Program 19-5 
72 
( continued) 
73 //********************************************************** 
74 II Return a pointer 
to a specified 
child 
* 
75 //********************************************************** 
76 Person 
*Person: :getCh il d( i nt k) const 
77 { 
78 
if 
(k < 0 I I k >= chil dren.si
ze()) 
79 
{ 
80 
cout << "Error 
i ndexing chi ldren's 
vector."<< 
endl ; 
81 
exi t(1); 
82 
) 
83 
return 
children
[k] ; 
84 } 
85 
86 //**************************************************** 
87 // Overloaded 
stream output 
operator 
* 
88 //**************************************************** 
89 ostream & operator<<(ostream 
& out, 
Person p) 
90 { 
91 
out<< 
"<person name="<< 
p.name << ">" 
<< '\n'; 
92 
i f (p .parents.s
i ze() 
> 0) 
out<<" 
for 
(int 
k = 
{ 
<parents>" 
<< ' 
'· 
O; k < p.parents.size(); 
k++) 
93 
94 
95 
96 
out<<• 
"<< p.parents
[k] - >name << ' 
97 
} 
98 
i f (p .parents.s
i ze() 
> 0) 
99 
out<<• 
</parents>"<< 
"\n"; 
100 
i f (p .chil dren.size() 
> 0) 
101 
out<<" 
<chil dren>"<< 
' .. 
.. 
102 
for 
(int 
k = O; k < p.children.s
iz e(); 
k++) 
103 
{ 
104 
105 
} 
out<<• 
"<< p.children
[k]- >name << ' '· 
106 
i f (p .chil dren.size() 
> 0) 
107 
out<<• 
</children>"<< 
"\n"; 
108 
out<< 
"</person>"<< 
"\n"; 
109 
return 
out; 
110 } 
111 
112 
113 int mai n(int 
argc, 
char** argv) 
114 { 
115 
116 
117 
118 
119 
// Here are the peopl e 
Person adam("Adam", mal e); 
Person eve("Eve", 
femal e); 
Person joan("Joan", 
femal e); 
120 
// Adam and Eve are parents 
of Abel 
(program continues) 

19.4 Tying It All Together: Genealogy Trees 
1149 
Program 19-5 
( continued) 
121 
122 
Person *pAbel = eve.addChi l d(new Person ( "Abel" , mal e)); 
adam.addChi l d(pAbel ); 
123 
124 
// Abel and Joan are parents 
of Missy 
125 
126 
Person *pMissy = j oan.addChild("Missy
", female) ; 
pAbel- >addChild(pMissy)
; 
127 
128 
II Output al l the peop l e 
129 
cout << "Here are all 
the people: \ n\ n"; 
130 
cout << adam << eve" ; 
131 
cout << *pAbel << joan; 
132 
cout << *pMissy << " \ n"; 
133 
134 
// Print 
parents 
of Mi ssy 
135 
cout << "Missy's 
parents 
are: 
"<< endl; 
136 
137 
138 
139 
140 
141 
142 
143 
144 
145 
146 
147 } 
for (uns i gned int k = O; k < pMissy- >getNumParents ( ); k++) 
{ 
} 
Person* 
p = pMissy - >getParent
(k) ; 
switch (p- >getGender ( )) 
{ 
} 
case female 
: cout << "\tMother: 
"; break ; 
case male: cout << "\tFather: 
"· break ; 
cout << p- >getName() << endl; 
return 
O; 
Program Output 
Here are all 
the people: 
<person name= Adam> 
<children> 
Abel 
</children> 
</person> 
<person name= Eve> 
<children> 
Abel 
</children> 
</person> 
<person name= Abel> 
<parents> 
Eve Adam </parents> 
<children> 
Missy 
</children> 
</person> 
<person name= Joan> 
<children> 
Missy 
</children> 
</person> 
<person name= Missy> 
<parents> 
Joan 
Abel 
</parents> 
</person> 
Missy's 
parents 
are: 
Mother: Joan 
Father: 
Abel 

1150 
Chapte r 19 
Binary Trees 
Review Questions and Exercises 
Fill-in-the-Blank and Short Answer 
1. The first node in a binary tree is called the ____ 
_ 
2. A binary tree node's left and right pointers point to the node's ____ 
_ 
3. A node with no children is called a(n) ___ 
_ 
4. A(n) _____ 
is an entire branch of the tree, from one part icular node down. 
5. The three common types of tr aversal with a binary tree are _____ 
, 
_____ 
, and ____ 
_ 
6. In what ways is a binary tree similar to a linked list? 
7. A ternary tree is like a binary tree, except each node in a ternary tree may have 
three children: a left child, a middle child, and a right child. Write an analog of 
the Tr eeNode declaration that can be used to represent the nodes of a ternary tree. 
8. Imagine a tree in which each node can have up to a hundred children. Write an 
analog of the Tre eNode declaration that can be used to represent the nodes of 
such a tree. A declarat ion such as 
Tre eNode 
{ 
} ; 
i nt va l ue ; 
Tr eeNode *chi l d1; 
TreeNode *chi l d2 ; 
TreeNode *chi l d3; 
that simply lists all the pointers to the hundred children is not acceptable. 
Algorithm Workbench 
9. Propose a definition of a preorder traversal for ternary trees and give pseudocode 
for accomplishing such a traversal. 
10. Propose a defini tion of a postord er traversal for ternary trees and give 
pseudocode for accomplishing such a traversal. 
11. What problems do you encoun ter when you try to define the concept of an 
inorder traversal for ternary trees? 
12. Assume that data is stored in a binary tree but that unlike in the case of binary 
search tree, no attemp t is made to maintain any sort of order in the data stored. 
Give an algorithm for a function sear ch that searches a binary tree for a 
particular value num and returns t r ue or fa l se according to whether the value 
num is found in the tree. 
13. Give an algorithm for a function 
i nt l arge st (Tre eNode *t ree ) 
that takes a pointer to a root of a binary search tree as paramete r and returns 
the largest value stored in the tree. 

14. Give an algorithm for a function 
int smallest(TreeNode 
*tree) 
Programming Challenges 
11 51 
that takes a pointer to a root of a binary search tree as parameter and returns 
the smallest value stored in the tree. 
15. Give an algorithm for a function 
void i ncrement 
(TreeNode *tree) 
that increments the value in every node of a binary tree by one. 
16. Suppose the following values are inserted into a binary search tree, in the order given: 
12, 7, 9 , 10, 22, 
24, 30, 
18, 3, 14, 20 
Draw a diagram of the resulting binary tree. 
17. How would the values in the tree you sketched for queston 16 be displayed in 
an inorder traversa l? 
18. How would the values in the tree you sketched for queston 16 be displayed in a 
preorder traversal? 
19. How would the values in the tree you sketched for queston 16 be displayed in a 
postorder traversa l? 
Soft Skills 
20. All three binary tree traversal methods studiedin this chapter traverse the left 
subtree before the right subtree. This is an artifact of Western culture, where people 
are accustomed to reading material printed on a page from left to right. In a world 
of increasing globalization, products and services that will be offered in foreign 
markets must be designed so that they can be easily altered to target different 
markets . Discuss with your classmates some of the ways these internationalization 
considerations are affecting the design of computer software and hardware today. 
Discuss this with a friend who has had a course in International Business, or take 
such a course yourself, to become better aware of some of the problems businesses 
face when they enter international markets. 
Programming 
Challenges 
1. Simple Binary Search Tree Class 
Write a class for implementing a simple binary search tree capable of storing numbers. 
The class should have member functions 
voi d insert(double 
x) 
bool search(double 
x) 
voi d inorder(vector 
<double> & v) 
The insert function should not use recursion directly or indirectly by calling a recursive 
function. The search function should work by calling a private recursive member function 
bool search(double 
x, BtreeNode *t) 

115 2 
Chapte r 19 
Binary Trees 
a 
VideoNote 
Solving the 
Tree Size 
Problem 
The inorder function is passed an initially empty vector v: it fills v with the inorder list 
of numbers stored in the binary search tree. Demonstrate the operation of the class 
using a suitable driver program . 
2. Tree Size 
Modify the binary search tree created in the previous programming challenge to add a 
member function 
i nt size
() 
that returns the number of items (nodes) stored in the tree. Demonstrate the correctness 
of the new member function with a suitable driver program . 
3. Leaf Counter 
Modify the binary search tree you created in the preceding programming challenges to 
add a member function 
i nt 1 e afC ount () 
that counts and returns the number of leaf nodes in the tree. Demonstrate that the 
function works correctly in a suitable driver program . 
4. Tree Height 
Modify the binary search tree created in the preceding programming challenges by 
adding a member function that computes and returns the height of the tree. 
i nt he i ght () 
The height of the tree is the number of levels it contains. For example, the tree shown in 
Figure 19-10 has three levels. Demonstrate the function with a suitable driver program. 
Figure 19-10 
left 
right 
left 
right 
left 
right 
left 
right 
nullptr 
left 
right 
nullptr 
nullptr 
nullptr 
nullptr 
nullptr 
5. Tree Width 
Modify the binary search tree created in the preceding programming challenges by 
adding a member function that computes the width of the tree. 
i nt width
() 

Programming Challenges 
11 53 
The width of a tree is the largest number of nodes at the same level. Demonstrate 
correctness in a suitable driver program . 
6. Tree Copy Constructor 
Design and implement a copy construc tor for the binary search tree created in the 
preceding programming challenges. Use a driver program to demonstrate correctness. 
7. Tree Assignment Operator 
Design and implement an overloaded assignment operato r for the binary search tree 
created in the preceding programming challenges. 
8. Employee Tree 
Design an Emp l oyeel nf o class that holds the following employee informat ion: 
Employee ID Number: an integer 
Employee Name: a string 
Implement a binary tree whose nodes hold an instance of the Employee Info class. The 
nodes should be sorted on the Employee ID number. 
Test the binary tree by inserting nodes with the following information. 
Employee 
ID Number 
Name 
102 1 
John Williams 
1057 
Bill Witherspoon 
2487 
Jennifer Twain 
3769 
Sophia Lancaster 
1017 
Debbie Reece 
1275 
George McMullen 
1899 
Ashley Smith 
4218 
Josh Plemmons 
Your program should allow the user to enter an ID number, then search the tree for the 
number. If the number is found, it should display the employee's name. If the node is 
not found, it should display a message indicating so. 
9. Cousins 
Building on Program 19 -5, write a function that takes a pointer to a Person object and 
produces a list of that person's cousins. 
10. Prefix Representation 
of Binary Trees 
Prefix representation is a simple of way of preserving the structure of a binary tree 
when you write it to an output stream in string form. It is defined as follows: 
1. The prefix representation of an empty binary tree is a single underscore _. 

1154 
Chapte r 19 
Binary Trees 
2. The prefix representa tion of a non -empty binary tree is (v L, R), where v 
represents the value stored in the root and L and R are the prefix represen tations 
of the left and right subtrees . 
Examples of prefix representa tions are the strings (5_ ,_ ) and (5 (3_ ,_ ) , (8_ ,_ )) . 
Modify the binary tree class of Program 19-1 to add the following member functions: 
1. void t re ePri nt (): This public member function will print the prefix representation 
of the binary tree object to standard output . 
2. voi d t ree Pri nt (TreeNode *root, ost re am& out ) con st: This private member 
function will print the prefix representa tion of the binary tree with a given root to 
a given output stream . 
Test your functions by modifying the main function of Program 19-4 to print the prefix 
representa tion of the tree after each insertion and deletion . 

No nprintab le ASCII Characters 
Printab le ASCII Characters 
Dec 
Hex 
Oct 
Name of Character 
Dec 
Hex 
Oct 
Character 
0 
0 
0 
NULL 
32 
20 
40 
(Space) 
1 
1 
1 
SOTT 
33 
21 
41 
2 
2 
2 
STX 
34 
22 
42 
" 
3 
3 
3 
ETY 
35 
23 
43 
# 
4 
4 
4 
EOT 
36 
24 
44 
$ 
5 
5 
5 
ENQ 
37 
25 
45 
% 
6 
6 
6 
ACK 
38 
26 
46 
& 
7 
7 
7 
BELL 
39 
27 
47 
' 
8 
8 
10 
BKSPC 
40 
28 
50 
( 
9 
9 
11 
HZTAB 
41 
29 
51 
) 
10 
a 
12 
NEWLN 
42 
2a 
52 
* 
11 
b 
13 
VTAB 
43 
2b 
53 
+ 
12 
C 
14 
FF 
44 
2c 
54 
13 
d 
15 
CR 
45 
2d 
55 
14 
e 
16 
so 
46 
2e 
56 
15 
f 
17 
SI 
47 
2f 
57 
I 
16 
10 
20 
DLE 
48 
30 
60 
0 
17 
11 
21 
DC1 
49 
31 
61 
1 
18 
12 
22 
DC2 
50 
32 
62 
2 
19 
13 
23 
DC3 
51 
33 
63 
3 
20 
14 
24 
DC4 
52 
34 
64 
4 
21 
15 
25 
NAK 
53 
35 
65 
5 
22 
16 
26 
SYN 
54 
36 
66 
6 
23 
17 
27 
ETB 
55 
37 
67 
7 
24 
18 
30 
CAN 
56 
38 
70 
8 
25 
19 
31 
EM 
57 
39 
71 
9 
26 
1a 
32 
SUB 
58 
3a 
72 
27 
1b 
33 
ESC 
59 
3b 
73 
28 
1c 
34 
FS 
60 
3c 
74 
< 
29 
1d 
35 
GS 
61 
3d 
75 
= 
30 
1e 
36 
RS 
62 
3e 
76 
> 
31 
1f 
37 
us 
63 
3f 
77 
? 
127 
7f 
177 
DEL 
64 
40 
100 
@ 
1155 

1156 
Appendix A 
The ASCII Characte r Set 
Printab le ASCII Characters 
Printab le ASCII Characters 
Dec 
Hex 
Oct 
Character 
Dec 
Hex 
Oct 
Character 
65 
41 
101 
A 
121 
79 
171 
y 
66 
42 
102 
B 
122 
7a 
172 
z 
67 
43 
103 
C 
123 
7b 
173 
{ 
68 
44 
104 
D 
124 
7c 
174 
I 
69 
45 
105 
E 
125 
7d 
175 
} 
70 
46 
106 
F 
126 
7e 
176 
71 
47 
107 
G 
72 
48 
110 
H 
73 
49 
111 
I 
74 
4a 
112 
J 
Extended ASCII Characters 
75 
4b 
113 
K 
76 
4c 
114 
L 
Dec 
Hex 
Oct 
Character 
77 
4d 
115 
M 
128 
80 
200 
<;: 
78 
4e 
116 
N 
129 
81 
201 
ii 
79 
4f 
117 
0 
130 
82 
202 
e 
80 
50 
120 
p 
131 
83 
203 
ii 
81 
51 
121 
Q 
132 
84 
204 
a 
82 
52 
122 
R 
133 
85 
205 
a 
83 
53 
123 
s 
134 
86 
206 
a 
84 
54 
124 
T 
135 
87 
207 
y 
85 
55 
125 
u 
136 
88 
210 
e 
86 
56 
126 
V 
137 
89 
211 
e 
87 
57 
127 
w 
138 
Ba 
212 
e 
88 
58 
130 
X 
139 
8b 
213 
i 
89 
59 
131 
y 
140 
Be 
214 
l 
90 
5a 
132 
z 
141 
8d 
215 
i 
91 
5b 
133 
[ 
142 
Be 
216 
A 
92 
5c 
134 
\ 
143 
8f 
217 
A 
93 
5d 
135 
l 
144 
90 
220 
E 
94 
5e 
136 
" 
145 
91 
221 
a! 
95 
5f 
137 
-
146 
92 
222 
If. 
96 
60 
140 
. 
147 
93 
223 
6 
97 
61 
141 
a 
148 
94 
224 
6 
98 
62 
142 
b 
149 
95 
225 
6 
99 
63 
143 
C 
150 
96 
226 
0 
100 
64 
144 
d 
151 
97 
227 
u 
101 
65 
145 
e 
152 
98 
230 
y 
102 
66 
146 
f 
153 
99 
231 
b 
103 
67 
147 
g 
154 
9a 
232 
0 
104 
68 
150 
h 
155 
9b 
233 
¢ 
105 
69 
151 
i 
156 
9c 
234 
£ 
106 
6a 
152 
j 
157 
9d 
235 
u 
107 
6b 
153 
k 
158 
9e 
236 
0 
108 
6c 
154 
l 
159 
9f 
237 
f 
109 
6d 
155 
m 
160 
aO 
240 
a 
110 
6e 
156 
n 
161 
a1 
241 
i 
111 
6f 
157 
0 
162 
a2 
242 
6 
112 
70 
160 
p 
163 
a3 
243 
u 
113 
71 
161 
q 
164 
a4 
244 
ii 
114 
72 
162 
r 
165 
a5 
245 
N 
115 
73 
163 
s 
166 
a6 
246 
a 
116 
74 
164 
t 
167 
a7 
247 
0 
117 
75 
165 
u 
168 
a8 
250 
l 
118 
76 
166 
V 
169 
a9 
251 
© 
119 
77 
167 
w 
170 
aa 
252 
N 
120 
78 
170 
X 
171 
ab 
253 

The ASCII Character Set 
11 57 
Extended ASCII Characters 
Extended ASCII Characters 
Dec 
Hex 
Oct 
Character 
Dec 
Hex 
Oct 
Character 
172 
ac 
254 
214 
d6 
326 
173 
ad 
255 
215 
d7 
327 
<> 
174 
ae 
256 
216 
dB 
330 
y 
175 
af 
257 
)) 
217 
d9 
331 
'( 
176 
bO 
260 
co 
218 
da 
332 
I 
177 
b1 
261 
± 
219 
db 
333 
178 
b2 
262 
~ 
220 
de 
334 
( 
179 
b3 
263 
~ 
221 
dd 
335 
180 
b4 
264 
¥ 
222 
de 
336 
fi 
181 
b5 
265 
µ 
223 
df 
337 
fl 
182 
b6 
266 
a 
224 
eO 
340 
+ 
183 
b7 
267 
L 
225 
e1 
341 
184 
b8 
270 
n 
226 
e2 
342 
' 
185 
b9 
271 
n 
227 
e3 
343 
" 
186 
ba 
272 
f 
228 
e4 
344 
%, 
187 
bb 
273 
a 
229 
e5 
345 
'A 
188 
be 
274 
0 
230 
e6 
346 
E 
189 
bd 
275 
0 
231 
e7 
347 
A 
190 
be 
276 
a! 
232 
e8 
350 
E 
191 
bf 
277 
0 
233 
e9 
351 
E 
192 
co 
300 
(., 
234 
ea 
352 
i 
193 
c1 
301 
235 
eb 
353 
i 
194 
c2 
302 
., 
236 
ec 
354 
I 
195 
c3 
303 
..J 
237 
ed 
355 
i 
196 
c4 
304 
f 
238 
ee 
356 
(J 
197 
c5 
305 
:::: 
239 
ef 
357 
() 
198 
c6 
306 
fl 
240 
fO 
360 • 
199 
c7 
307 
241 
f1 
361 
(J 
200 
c8 
310 
)) 
242 
f2 
362 
(J 
201 
c9 
311 
243 
f3 
363 
0 
202 
ca 
312 
244 
f4 
364 
0 
203 
cb 
313 
A 
245 
f5 
365 
l 
204 
cc 
314 
A 
246 
f6 
366 
205 
cd 
315 
0 
247 
f7 
367 
206 
ce 
316 
CE 
248 
f8 
370 
207 
cf 
317 
re 
249 
f9 
371 
208 
dO 
320 
250 
fa 
372 
209 
d1 
321 
251 
fb 
373 
210 
d2 
322 
" 
252 
fc 
374 
. 
211 
d3 
323 
" 
253 
fd 
375 
-
212 
d4 
324 
254 
fe 
376 
213 
d5 
325 
255 
ff 
377 

This page intentionally left blank 

The operators are shown in order of precedence, from highest to lowest. 
Operator 
() 
[ ] - > 
++ -
+ -
-
(typ e ) * & sizeof 
* I % 
+ -
<< >> 
< <= > >= 
--
!= 
& 
&& 
11 
?: 
= += -=*=I=%=&=-= I=
<<=>>
= 
' 
Associativ ity 
unary: left to right 
binary: right to left 
left to right 
right to left 
left to right 
left to right 
left to right 
left to right 
left to right 
left to right 
left to right 
left to right 
left to right 
left to right 
right to left 
right to left 
left to right 
1159 

This page intentionally left blank 

Chapter 1 
1.1 
Because the computer can be programmed to do so many different tasks 
1.2 
The central processing unit (CPU), main memory (RAM), secondary storage 
devices, input devices, and output devices 
1.3 
Arithmetic and logic unit (ALU) and control unit 
1.4 
Fetch: The CPU's control unit fetches the program 's next instruction from 
main memory. 
Decode: The contro l unit decodes the instruction , which is encoded in the 
form of a number. An electrical signal is generated . 
Execute: The signal is routed to the appropriate component of the computer, 
which causes a device to perform an operation . 
1.5 
A memory address is a unique number assigned to each storage location in 
memory. Its purpose is to allow data stored in RAM to be located. 
1.6 
Program instructions and data are stored in main memory while the program 
is runnin g. Main memory is volati le and loses its contents when power is 
removed from the computer. Secondary storage holds data for long periods of 
time---even when there is no power to the computer. 
1.7 
Operating systems and application software 
1.8 
The operating system 
1.9 
A utility program 
1.10 
Application software or application programs 
1.11 
A set of well-defined steps for performing a task or solving a problem 
1.12 
To ease the task of programming . Programs may be written in a programming 
language, then converted to machine language. 
1.13 
A low-level language is close to the level of the computer and resembles the 
system's numeric machine language . A high-level language is closer to the 
level of human readability and resembles natural languages . 
1.14 
That a program may be written on one type of computer and run on another type 
1161 

1162 
Appendix C 
Answe rs to Checkpoints 
1.15 
The preprocessor reads the source file, searching for commands that begin with 
the # symbol. These are commands that cause the preprocessor to modify the 
source file in some way. The compiler translates each source code instruction into 
the appropriate machine language instruction and creates an object file. The linker 
combines the object file with necessary library routines to create an executable file. 
1.16 
Source file: Contains program statements written by the programmer . 
Object file: Contains machine language instructions generated by the compiler. 
Executable file: Contains code ready to run on the computer. Includes the machine 
language from an object file and the necessary code from library routines. 
1.17 
A programming environment that includes a text editor, compiler, debugger, 
and other utilities, integrated into one package 
1.18 
A key word has a special purpose and is defined as part of a programming 
language. A programmer -defined symbol is a word or name defined by the 
programmer. 
1.19 
Operators perform operations on one or more operands . Punctuation sym-
bols mark the beginning or ending of a statement, or separate items in a list. 
1.20 
A line is a single line as it appears in the body of a program. A statement is a 
complete instruction that causes the computer to perform an action . It may be 
written on 1 or more lines. 
1.21 
Because their contents may be changed while the program is running . 
1.22 
It is overwritten by the new value. The old value is "lost". 
1.23 
The variable must be defined in a declaration. 
1.24 
Input, processing, and output 
1.25 
The program's purpose , the information to be input, the processing to take 
place, and the desired output . 
1.26 
To imagine what the computer screen looks like while the program is running. 
This helps define input and output . 
1.27 
A chart that depicts the logical steps of the program in a hierarch ical fashion 
1.28 
A "language" that is a cross between human language and programming lan-
guages that is used to express algorithms. 
1.29 
High-level psuedocode just lists the steps a program must carry out . Detailed 
psuedocode shows the variab les, logic, and computations needed to create the 
program . 
1.30 
It translates each source code statement into the appropriate machine lan-
guage statements . 
1.31 
A mistake that causes a program to produce erroneous results. A logic error 
occurs when what the programmer means for the program to do does not 
match what the code actually instructs the program to do. 
1.32 
An error that occurs while the program is running when the system is asked to 
perform an action it cannot carry out . 
1.33 
The programmer steps through each statement in the program from beginning 
to end . The contents of variables are recorded, and screen output is sketched. 

Chapter 2 
2.1 
I I A crazy mixed up program 
#include 
<iostream> 
using namespace std ; 
i nt main() 
{ 
Answers to Checkpoints 
116 3 
cout << "In 1492 Columbus sailed 
the ocean blue."; 
return 
O; 
} 
2.2 
II 
Insert 
current 
date here 
#include 
<iostream> 
using namespace std ; 
i nt main() 
{ 
} 
cout << "Teresa Jones"; 
return 
O; 
2.3 
cout << "red \n" << "blue \n" << "yel low \n" << "green"; 
2.4 
The works of Wolfgang 
i nclude the following: 
The Turkish 
March 
and Symphony No. 40 in G mi nor. 
2.5 
#include 
<iostream> 
using namespace std ; 
i nt main() 
{ 
} 
cout << "Teresa Jones\n"; 
cout << "127 West 423rd Street
\n"; 
cout << "San Antonio, 
TX 78204\n" ; 
cout << "555-475-1212\n"; 
return 
O; 
2.6 
Only statement a is legal. Th e left-hand side of an assignment statement must 
be a var iab le, not a liter al. 
2.7 
Variables: little 
and big 
2.8 
Liera~: 2,2000, "The little 
The little 
number is 2 
The big number i s 2000 
2.9 
The value is number 
number is" 
"The big number is" 
0 
' 
' 
2.10 
99bottles: 
Variable names cannot begin with a number. 
r&d: Variable names may only use alphabetic letters, digits, and underscores. 
2.11 
No. Variable names are case sensit ive. 

11 64 
Appendix C 
Answers to Checkpoints 
2.12 
A) short or uns i gned short 
B) int 
C) They both use the same amount of memory. 
2.13 
unsigned short, unsigned i nt, and unsi gned long 
2.14 
i nt apples 
= 20; 
2.15 
i nt xCoord = 2, yCoord = - 4, zCoord = 6 ; 
2.16 
6.31E17 
2.17 
3 
2.18 
#include 
<iostream> 
using namespace std ; 
i nt main() 
{ 
} 
int age; 
double weight; 
age = 26; 
weight
= 168.5; 
cout << "My age is"<< 
age<<" 
and my weight i s"· 
cout <<we i ght<<" 
pounds . \n"; 
return 
O; 
2.19 
67, 70, 87 
2.20 
'B' 
2.21 
1 byte, 2 bytes, 6 bytes, 1 byte 
2.22 
The string literal "Z" is being stored in the character variable letter. 
2.23 
string 
2.24 
II Substitute 
your name, address , and phone 
II number for those shown i n this 
program. 
#include 
<iostream> 
#include 
<string> 
using namespace std ; 
i nt main() 
{ 
} 
string 
name, address , phone; 
name = "George Davis"; 
address
= "179 Ravenwood Lane"; 
phone= 
"555-6767"; 
cout <<name<< 
endl ; 
cout <<address<< 
endl; 
cout <<phone<< 
endl; 
return 
O; 
2.25 
Invalid. The value on the left of the = operator must be an l value, such as a 
variable name . 

Answers to Checkpoints 
1165 
2.26 
Th e variable critter 
is assigned a value before it is declared . You can correct 
the program by moving the statement cr i tter 
= 62 . 7; to the line after the 
var iable declaration. 
2.27 
11, 5, 24, 2 
2.28 
Integer division. Th e value 5 will be displayed . 
Chapter 3 
3.1 
i ostream 
3.2 
Th e stream extraction operator 
3.3 
Th e console (or keyboard) 
3.4 
Tru e 
3.5 
3 
3.6 
cin >>miles>> 
feet>> 
i nches; 
3.7 
Include one or more co ut statements explaining what values the user should 
enter . 
3.8 
#include 
<iostream> 
using namespace std ; 
i nt main() 
{ 
} 
double pounds, 
kilograms; 
cout << "Enter 
your weight 
in pounds: 
"; 
cin 
>> pounds ; 
// The following 
line 
does the convers i on . 
kilograms= 
pounds/ 
2 .2; 
cout << "Your weight 
i n ki lograms i s"· 
cout <<kilograms<< 
endl; 
ret urn O; 
3.9 
A) "' 
B) same 
C) same 
3.10 A) 21 
D) 
B) 2 
E) 
C) 31 
F) 
3.11 
y = 6 * x· ' 
a = 2 * b + 4 * c ; 
y = X * X * x · ' 
g = (x + 2) I (z * 
y = (x * x) I (z * 
3.12 
If the user enters . .. 
2 
5 
4.3 
6 
5 
24 
2 
G) 69 
H) 0 
I) 
30 
or y = pow(x, 3); 
z ); 
or g = (x + 2) / pow(z, 2); 
z ); 
or y = pow(x, 2) / pow (z, 2); 
The program displays . .. 
6 
27 
20 .49 
38 

11 66 
Appendix C 
Answe rs to Checkpoints 
3.13 
#include 
<iostream> 
#include 
<cmath> 
using namespace std ; 
i nt main() 
{ 
double volume, radius , height ; 
cout << "This program wi ll tell 
you the volume of\n"; 
cout << "a cylinder-shaped 
fuel tank.\n"; 
3.14 
3.15 
3.16 
3.17 
cout << "How tall 
is the tank?"; 
cin 
>> hei ght; 
cout << "What is the radius 
of the tank?"; 
cin 
>> radius; 
volume= 
3.14159 
* pow(r adius , 2.0 ) * hei ght; 
cout << "The volume of the tank i s"<< 
volume<< 
endl; 
return 
O; 
} 
A) 2 
B) 17.0 
C) 2.0 
D) 2.4 
F) 2.4 
G) 4 
H) 27 
I) 30 
The ASCII values 
of uppercase 
letters 
are 65 - 90 
The ASCII values 
of lowercase 
letters 
are 97 - 122 
Enter a letter 
and I wi ll tell 
you i ts ASCII code: 
The ASCII code for Bis 
66 
9 
9 .5 
9 
const 
const 
const 
const 
const 
double E = 2 .71828 ; 
double MIN_PER_YEAR = 5 .256E5; 
double GRAV_ACC_FT_PER_SEC = 32.2; 
double GRAV_ACC_M_PER_SEC = 9.8; 
int METERS
_PER_MILE = 1609 ; 
E) 2.4 
]) 27.0 
B 
3.18 
#include 
<iostream> 
using namespace std ; 
i nt main() 
{ 
} 
const double CONVERSION= 1 .467; 
double mi lesPerHour , feetPerSecond
; 
cout << "This program converts 
miles-per-hour 
to\n"; 
cout << "feet-per-second
. \n"; 
cout << "Enter a speed i n MPH: "; 
cin 
>> milesPerHour; 
feetPerSecond 
= mi lesPerHour 
* CONVERSION; 
cout << "That is"<< 
feetPerSecond 
<<" 
feet-per-second.
\n"; 
return 
O; 

Answers to Checkpoints 
1167 
3.19 
total= 
subtotal= 
tax= 
shipping
= O; 
3.20 
3.21 
A) x += 6 ; 
B) 
C) 
D) 
E) 
F) 
G) 
H) 
I) 
3 
11 
1 
amount- = 4; 
y *= 4 ; 
total 
/= 27 ; 
X %= 7 ; 
X += (y * 5); 
total 
- =(dis
count
* 4); 
increase*= 
(salesRep 
* 5); 
profit 
/= (shares 
- 1000); 
3.22 
A) cout << fixed<< 
setprecision
(2); 
B) 
C) 
D) 
cout 
cout 
cout 
cout 
cout 
<< 
<< 
<< 
<< 
<< 
<< 
setw(9) 
<< 34.789; 
fixed<< 
showpoint 
setprecision(3); 
setw(5) 
<< 7.0; 
fixed<< 
5 .789 e12 ; 
left 
<< setw(7) 
<< 
3.23 
#include 
<iostream> 
#include 
<iomani p> 
using namespace std ; 
i nt main() 
{ 
const double PI = 3.14159; 
double degrees , rad i ans; 
67; 
cout << "Enter an angle in degrees 
and I wil l convert 
it\n"; 
cout << "to radians 
for you: "; 
} 
cin 
>> degrees ; 
radians
= degrees
* PI / 180 ; 
cout <<degrees<<" 
degrees 
is equal to"; 
cout <<fixed<< 
showpoi nt << setprecision
(4); 
cout <<left<< 
setw(7) 
<<radians<<" 
radians.\n 
"; 
ret urn O; 
3.24 
No. A space is needed for a fifth character, to hold the null terminator. 
3.25 
A) Legal (Though no embedded blanks can be input) 
B) Illegal (This works for C-strings only) 
C) Legal 
D) Legal 
3.26 
A) Legal (Though no embedded blanks can be input) 
B) Legal 
C) Legal 
D) Illegal (Arrays cannot be assigned to variab les like this. Use strcpy () .) 

1168 
Appendix C 
Answers to Checkpoints 
3.27 
cout 
<< round(inches); 
3.28 
x = sin (angle1) 
+ cos(angle2); 
3.29 
y= pow(x, 0.2); 
II 0.2 is equal to 1/5 
3.30 
luckyNu mber = rand () % 100 + 1; 
Chapter4 
4. 1 
All seven are true . 
4.2 
4.3 
4.4 
A) Incor rect 
A) Yes 
0 0 1 0 
B) Inco rrect 
B) No 
C) Correct 
C) No 
4.5 
i f (p rice 
> 500 ) 
discountRate 
= 0.2; 
4.6 
i f (hours > 40) 
payRate = payRate 
* 1. 5 ; 
4.7 
i f (s ales > 50000 ) 
{ commissionRate 
= 0.25; 
bonus= 
250; 
} 
4.8 
false 
4. 9 
i f (tic ketsSold 
--
200 ) 
soldOut 
= true; 
4. 10 
i f (s ol dOut ) // 
Same as if 
(soldOut 
== tr ue ) 
cout << "The performance 
is sold out! 
\n"; 
4. 11 
A) Error: 
Th ere is a semicolon afte r the i f test condit ion . 
Result: 
Th e co ut statement 
will execute even though hours is not 
greater than 40. 
Output: 
12 hours qua lifies 
for ove r-tim e . 
B) Error: 
Th e if test condition uses an assignment operato r ( =) rather 
than an equality test(==) . 
Result: 
i nterestRate 
will be assigned the value .07, and the cout 
statement will exec ute even though it sho uldn't. 
Output: 
This account 
is earning 
the maxi mum rate . 
C) Error: 
Th e 2 statements that are supposed to be included in the body 
of the if statement are not surrounded by curly braces . 
Result: 
Only the cout statement is in the if body. Th e $10 addit ion to 
balance will always be done, even when i nterestRate 
is not 
greater than .07. 
Output: 
None 
4. 12 
i f (s ales>= 
50000 .00) 
commission
= 0.20; 
else 
commission
= 0.10; 

Answers to Checkpoints 
1169 
4. 13 
i f (y == 100) 
X = 1 ; 
else 
x = 0; 
4. 14 
i f (p repa i d) 
discount= 
0.10; 
else 
discount= 
0.0; 
4. 15 
true 
II Same as if 
(pr epa i d --
true) 
4. 16 
No. When x equals y the two separate if statements don 't display anyt hing, 
but the if I els e statement causes a 2 to display. 
4. 17 
5 5 
4. 18 
If the customer 
purchases 
this 
many books . . . 
This many coupons are given 
1 
2 
3 
4 
5 
10 
4. 19 
i f (qua nt i tyOnHand == 0) 
cout 
<< "Out of stock 
\ n"; 
else 
if 
(quantity
OnHand < 10) 
cout 
<< "Reorder 
\n"; 
4.20 
i f (qua nt i tyOnHand == 0) 
cout 
<< "Out of stock 
\ n"; 
else 
if 
(quantity
OnHand < 10) 
cout 
<< "Reorder 
\n"; 
else 
cout 
<< "Quantity 
OK \n"; 
1 
1 
2 
2 
3 
3 
4.21 
A) Zero 
B) Zero Ten 
C) Zero Ten Twenty 
4.22 
A) Good luck in the rest of your games . 
B) You are the champions . 
C) You have won more than 50% of your games. 
4.23 
Logical Expression 
Result (true or false) 
true && false 
false 
true && true 
true 
false && false 
false 
true II false 
true 
true II true 
true 
false II false 
false 
!tru e 
false 
!false 
true 
D) Nothing 

1170 
Appendix C 
Answers to Checkpoints 
4.24 
A) true 
D) true 
B) false 
E) true 
C) true 
4.25 
true (&& is done before I I) 
4.26 
i f ( ! act i veEmp l oyee) 
4.27 
i f (sp eed> = O && speed<= 
200) 
cout << "The number is valid
. \n"; 
4.28 
i f (sp eed < 0 11 speed > 200 ) 
cout << "The number is not valid."; 
4.29 
Th e variab les length, width, and area should be defined before they are used. 
Th ere is no prompt for the width . 
Th ere is no space in the final output string to separate the words "The area is" 
from the result being displayed 
4.30 A) true 
D) false 
4.31 
4.32 
4.33 
4.34 
4.35 
B) false 
E) false 
C) true 
F) true 
A) false 
E) false 
B) false 
F) false 
C) true 
G) true 
D) false 
H ) false 
i f ( str1 == 
str2 ) 
cout << "Both str i ngs have the value" 
<< str1 
<< endl; 
else 
if 
cout 
else 
cout 
A) true 
B) true 
false 
false 
C) 
D) 
(str1 
< str2 ) 
<< str1 
<< endl << 
<< str2 
<< endl << 
E) true 
F) false 
G) true 
H ) false 
A) Z = ( X > y) ? 1 : 20 ; 
str2 
<< endl; 
str1 
<< endl; 
B) population= 
(t emp> 45)? 
(ba se* 
10) : (base
* 2); 
C) 
D) 
A) 
B) 
wages
*= (hours> 
40)? 
1.5 : 1; 
cout <<((result>= 
0)? 
("The result 
is 
(" The result 
is negative.
\n")); 
if 
(k > 90) 
j = 57; 
else 
j = 12; 
if 
(x >= 10) 
factor 
= y * 22 ; 
else 
factor 
= y * 35; 
positive\n") 

Answers to Checkpoints 
1171 
4 .36 
C) if (count== 
1) 
total
+= sales; 
el se 
total 
+= count 
* 
D) if (num % 2) 
cout << "Even \n"; 
el se 
cout << "Odd\n"; 
2 2 
sales; 
4 .37 
Because the if / else statement tests several different conditions, consisting of 
different variables and because it tests values with relational operators other 
than equal -to. 
4.38 
The case statements must be followed by an integer constant, not a relational 
expression. 
4.39 
That is ser io us. 
4.4 0 
switch 
(us erNum) 
{ 
case 1 
cout << 
break; 
case 2 
cout << 
break; 
case 3 
cout << 
break; 
default: 
cout << 
} 
"One"; 
"Two"; 
"Three"; 
"You must enter 
1 ' 2, or 3. \n"; 
4.4 1 Here is the converted if I else if statement found in the program segment. 
switch 
(sele ction ) 
{ 
case 1 
cout << "Pi times radius 
squared\n"; 
break ; 
case 2 
cout << "length 
times width\n"; 
break ; 
case 3 
cout << "Pi times radius 
squared times height \n"; 
break ; 
case 4 
cout << "Well okay then, 
good bye! \n"; 
break ; 
default 
cout << "Not good with numbers, eh? \n"; 
} 
4.4 2 
enum must be lowercase. There should be no = sign. The symbolic names in 
the enumeration list should not be in quotes. The statement should end with a 
semicolon . 
4.4 3 
i f (c olor<= 
yellow) 
cout "primary color 
\ n"; 
else 
cout "mixed color 
\ n" ; 

1172 
Appendix C 
Answers to Checkpoints 
Chapter 5 
5.1 
A) 4 
B) 0. The test condit ion is initially false, so the body of the loop is never 
executed . 
C) 0. Not ice the semicolon after the whi le test expression . This causes an 
infinite loop that prints nothing . 
D) Notice the missing braces . This means the line that increments count is 
not in the loop, so count always remains less than 5, causing an infinite 
loop . The cou t statement executes over and over again until the user 
stops the program. 
5.2 
1 
3 
5 
7 
9 
5.3 
A) 3 2 
D) 3 4 
B) 3 3 
E) It is true! 
C) 2 3 
F) It is true! 
5.4 
The counter is x and the accumulator is t. Of course you should use more 
descriptive names in your code. These names were purposely unclear to see if 
you could spot which variable was which by the way it funct ioned in the 
code . 
5.5 
The counter variable, count , is not intia lized to 0. 
The accumulator, sum, is not intia lized to 0. 
The count variable is never incremented , causing an infinite loop . 
The value stored in the val variab le is assigned to sum, rather than added to it. 
5.6 
i nt score, 
numScores = O; 
double total 
= 0 .0; 
cout << "Enter th e f i rst t est scor e (or - 99 t o quit): 
"; 
cin 
>> score; 
whil e (score 
!= - 99) 
{ numScores ++; 
t ot al += score; 
cout << "Ent er t he next t est score 
(or - 99 t o quit): 
"; 
cin 
>> score; 
} 
i f (numScores == O} 
cout << "No scor es were ente red. " << endl; 
else 
cout << "The average of t he " << numScores 
<< " scor es i s • << total 
I numScores << endl; 
5.7 
A) He llo World 
B) 5 5 5 5 5 5 5 5 . .. (Infinite loop) 
C) 8 4 

Answers to Checkpoints 
1173 
5.8 
do 
{ 
cout << "Enter an integer: 
". 
cin 
>> num; 
if (num % 2 -- 0) 
cout << "That intege r is even. \ n" ; 
el se 
cout << "That i nteger 
is odd . \n"; 
cout << "Do you want to test 
another 
number (y/ n)? "· 
cin 
>> reply; 
} while 
(r eply
== 'y ' I I reply
== 'Y'); 
5.9 
Change the last line of answer 5.5 to the following: 
while(toupper(reply) 
== ' Y') 
5.10 
initialization expression, test expression, and update expression 
5.11 
A) count = 1 
B) count <= 50 
C) count++ 
D) for (cou nt = 1; count<= 
50 ; count++) 
cout << "I love to program. \n"; 
5.12 
A) 0 2 4 6 8 10 
B) - 5- 4- 3 - 2 - 101234 
C) 3 6 9 12 
5.13 
for (int 
count= 
1; count<= 
10; count++ ) 
cout << "Put your name here .\n"; 
5.14 
for (int 
num = 1 ; num < 50 ; num += 2) 
cout << num << end l; 
5.15 
for (int 
num = O; num <= 100; num += 5) 
cout << num << end l; 
5.16 
i nt sum = O; 
for (int 
num = 1 ; num <= 10; num++) 
s um+ = num * num; 
cout << "The sum of the squares 
of the i ntegers 
\n" 
<< "from 1 through 
10 is"<< 
sum<< end l; 
5.17 
i nt sum = O; 
for (int 
num = 1 ; num <= 9 ; num += 2) 
s um+ = num * num; 
cout << "The sum of the squares 
of the odd integers 
\n" 
<< "from 1 through 
9 is
" << sum; 
5.18 
i nt count, 
number , total 
= O; 
for (count
= O; count< 
7; count++ ) 
{ 
} 
cout << "Enter a number: "· 
cin 
>> number ; 
total 
+= number; 
cout << "The total 
is"<< 
total 
<< endl ; 

1174 
Appendix C 
Answe rs to Checkpoints 
5.19 
doubl e x, y, quotient
, total 
= 0.0; 
for 
(x = 1 , y = 30 ; x <= 30; x++ , y--) 
{ 
} 
quot ien t= 
x I y; 
total 
+= quotient; 
cout << "The total 
is•<< 
total 
<< endl ; 
5.20 
doubl e total 
= 0 .0; 
5.21 
for (int denom = 2 ; denom <= 1024 ; denom *= 2) 
total 
+= 1.0 / denom; 
cout << "The total 
of the series 
is•<< 
total<< 
endl; 
A) for 
B) do-while 
C) while 
D) while 
E) for 
5.22 
A) 600 (20 rows with 30 stars in each row) 
B) 220 (20 rows with just 11 stars in each row due to the break statement) 
5.23 
1 3 7 12 
5.24 
A) An output file is one that a program can write outp ut to. 
B) In input file is one that a program can read input from. 
5.25 
fstream 
5.26 
1. Include the fstrea
m header file needed to perform file input/output. 
2. Define a file stream object. 
3. Open the file. 
4. Use the file. 
5 . Close the file. 
5.27 
A text file contains data that has been encoded as text, so it can be read with 
a text edito r. A binary file contains binary data that has not been converted to 
text, so it cannot be viewed with a text editor. 
5.28 
A sequentia l access file contains data that can only be accessed in sequentia l 
order from beginnning to end . A random access file allows direct access to 
any piece of data without having to read the data that comes before it. 
5.29 
ofstream 
5.30 
i fstream 
5.31 
C. dataFile 
<< hourlyPay ; 
5.32 
D. dataFil e >> hourl yPay; 
5.33 
for (int 
num = 1 ; num <= 10; num++) 
outfi le << num << endl ; 

Chapter6 
6.1 
function header 
6.2 
function call 
6.3 
3 
6.4 
4 
6.5 
14 
6.6 
The Hi story 
of Computers 
I called 
printHeading 
The History 
of Computers 
I called 
printHeading 
The History 
of Computers 
I called 
printHeading 
6.7 
The first line is the function header. 
The second line is the function prototype. 
The third line is the function call. 
6.8 
A) void t i mesTen(int 
number) 
Answers to Checkpoints 
1175 
B) void t i mesTen(int 
number); OR voi d t imesTen(int); 
C) timesTen (5); 
D) timesTen (boxes ); 
6.9 
0 1 . 5 
1. 5 0 
0 10 
0 1 .5 
6.10 
void showDollars (double pay ) 
{ 
} 
cout <<fixed<< 
showpoi nt << setprecision
(2); 
cout << "Your wages are$"<< 
pay<< 
endl ; 
6.11 
One 
6.12 
doubl e distance
(doubl e rate, 
double t i me) 
6.13 
i nt days(int 
years, 
int months , int weeks) 
6.14 
char getKey() 
6.15 
long lightYears
(long mi le s ) 
6.16 
A static local variab le's scope is limited to the function in which it is defined. 
A globa l variable 's scope is the portion of the program from its definition to 
the end of the program . 
6.17 
100 
50 
100 
6.18 
It displays the numbers 10 through 19, printed one per line. 
6.19 
Literals and Constants 

1176 
Appendix C 
Answers to Checkpoints 
6.20 
Prototype: 
void compute (double , int= 
5 , long= 
65536); 
Header: 
void compute (double 
x, int 
y, long z) 
6.21 
Prototype: 
void calculate
(long , &double , int= 
47) ; 
Header: 
void calculate
(long x, double 
&y, int 
z) 
6.22 
5 10 15 
9 10 15 
6 15 15 
4 11 16 
6.23 
O 00 
Enter two numbers: 
12 14 
12 140 
14 15-1 
14 15-1 
6.24 
Diff erent parameter lists 
6.25 
1 .2 
6.26 
30 
Chapter 7 
7.1 
B 
7.2 
A 
7.3 
C 
7.4 
class 
Date 
{ 
private: 
int month; 
int day ; 
int 
year; 
public: 
void setDate(int 
m, int 
d, int 
y) 
{month= 
m; day = d; year= 
y; ) 
int getMonth() 
{ return 
month ; } 
int get Day () 
{ return 
day; 
} 
int getYear() 
{ return 
year; 
} 
} 
Alternately these could be separate setMonth, setDay, and setYear 
member 
functions to validate and set each component of the date separately . 
7.5 
A constructor 
is automaticall y called when the class ob ject is created. It is 
useful for initializing member variables or performing setup operations. 

7.6 
7.7 
7.8 
7.9 
7.10 
7.11 
7.12 
7.13 
7.14 
7.15 
7.16 
7.17 
A 
A 
ClassAct 
True 
False 
B 
False 
50 
50 
20 
4 
7 
goodbye 
goodbye 
D 
A 
B 
Answers to Checkpoints 
1177 
sally(25); 
7.18 
False. They can be both passed to functions and returned by functions . 
7.19 
False. Passing it by value will ensure it is not changed, but it is best to pass it 
as a constant reference. 
7.20 
D 
7.21 
class 
Ci rcle 
{ private: 
double radius; 
publ i c: 
void setRadius(double 
r) 
{ radius 
= r; ) 
/ / In i nches 
double calcArea() 
{ return 
(3 .14.159 
* 
/ / In sq. i n. 
radius 
* radius); 
} 
} 
7.22 
cl ass Pi zza 
{ private: 
double pr i ce; 
Ci rcle 
size; 
publ i c: 
void setPrice(double 
p) 
{ 
price 
= p; } 
void setS i ze(double 
r) 
{ 
si ze . setRadius(r); 
} 
double costPerSqln() 
{ 
return 
(pr i ce/ 
size.getArea()); 
} 
} 

1178 
Appendix C 
Answers to Checkpoints 
7.23 
Other prices and sizes could be used. 
Pizza myPizza; 
myPizza.setPrice(12.99); 
myPizza.setSize(14); 
cout << "Price 
per square i nch$"<< 
myPizza.costPerSqin
(); 
7.24 
Th e BasePay class declarat ion wo uld reside in Basepay . h 
Th e BasePay member function defin itions would reside in Basepay . cpp 
Th e Overtime class declaration would reside in Overtime. h 
Th e Overtime member function declarations would reside in Overtime. cpp 
7.25 
Basepay . h and Overtime. h 
7.26 
struct 
Student 
{ 
int 
id , 
entryYear; 
double gpa ; 
} ; 
Student 
s1 (1234 , 2008 , 3.41}; 
Student 
s2(5678, 
2010); 
7.27 
struct 
Account 
{ string 
acctNum; 
double acctBal, 
intRate, 
avgBal; 
Account(string 
num, double bal, 
double rate , double avg ) 
{ 
acctNum = num; acctBal 
= bal; 
i ntRate = rate; 
avgBal = avg; 
} 
} ; 
Account sav i ngs ( "ACZ42137", 4512. 59, . 04, 4217 . 07); 
7.28 
#include 
<iostream> 
#include 
<str i ng> 
using namespace std ; 
struct 
Movielnfo 
{ 
} ; 
string 
name, 
dir ector; 
int 
year; 
i nt main() 
{ 
Movielnfo movie ; 
cout << "Enter the following 
information 
abo ut your • 
<<•favorite 
movie . \n" << "Name: "· 
getl i ne(cin, 
movie .name ); 
cout << "Dir ector: 
"; 
getl i ne(cin, 
movie .director
); 
cout << "Year of Release: 
•; 
cin 
>> movie.yea
r; 

Answers to Checkpoints 
1179 
cout << "\nHere is i nformation 
on your favorite 
movie :\ n"; 
cout << "Name: "<<mov
ie .name<< endl; 
cout << "Director: 
"<<movie.director<< 
endl ; 
cout << "Year of Release: 
" <<movie.yea
r<< 
end l; 
ret urn O; 
} 
7.29 
struct 
Location 
{ 
} ; 
double la titude
, 
longitud
e , 
height; 
7.30 
struct 
City 
{ 
7.31 
} ; 
String 
cit yName; 
Location 
pos it ion; 
City dest i nat ion ; 
destination.cityName 
= "Tupelo"; 
destination.position.
lat itude 
= 
destination.position.
longitu de = 
destination.position.height 
= 
7.32 
void showRect (Rectang le r} 
{ 
7.33 
} 
cout << r .length 
<< endl ; 
cout << r .width << endl; 
void getRect(Rectangle 
&r} 
{ 
cout << "Wi dth: .. 
' 
cin 
>> r .width; 
cout << "Length: .. 
' 
cin 
>> r .len gth; 
} 
34.28; 
- 88.77; 
361 .O; 
II degrees 
nor th 
II degrees 
west 
II 
ft. 
above sea level 
7.34 
Rectangle getRect () 
II Function return type is a Rectangle structure 
{ 
} 
Rectang le r; 
cout << "Wi dth: 
"· 
cin 
>> r .width; 
cout << "Length: 
"; 
cin 
>> r .len gth; 
ret urn r; 
7.35 
The problem domain is the set of real-world objects, parties, and major events 
related to a problem. 

1180 
Appendix C 
Answe rs to Checkpoints 
7.36 
Someone who has an adeq uate und erstanding of the problem. If you 
adequately understand the nature of the problem you are trying to solve, you 
can write a description of the problem doma in yourself. If you do not 
thoroughly understand the nature of the problem, you should have an expert 
write the description for you. 
7.37 
Start by identifying all the nouns (including pronouns and noun phrases ) in 
the problem doma in description . Each of these is a potential class. Then, 
refine the list to include only the classes that are relevant to the problem . 
7.38 
It is often helpful to ask the questions "In the context of this problem, what 
must the class know? What must the class do?" 
7.39 
A) Begin by identifying the nouns: doctor , patients , pract ice, patient , 
procedure, description, fee, statement, office manager, name, address, and 
total charge. After eliminating duplicates, objects, and simple data items 
that can be stored in variables, the remaining list of potentia l classes is: 
Doctor, Practice, Patient, Procedure, Statement, and Office manager. 
B) The necessary classes for this problem are: Patient, Procedure, and Statement. 
C) The Patient class knows the patient's name and address . The Procedure 
class knows the procedure description and fee. The Statement class knows 
each procedure that was performed . The Statement class can calculate 
total charges. 
Chapter8 
8.1 
A) int empNum[100]; 
8.2 
B) double payRate[25]; 
C) long mi l es[ 14]; 
D) string 
stateCapital[50]; 
E) double l i ghtYear s[1000]; 
i nt readings[
- 1] ; 
float 
measurement s[4.5 ] ; 
i nt si ze ; 
string 
name[size ]; 
8.3 
0 through 3 
8.4 
A) 15 
B) 6 
II Size declarator 
cannot be nega t ive 
II Size declarator 
must be an i nteger 
II Size declarator 
must be 
II a literal 
or named constant 
8.5 
Array bounds checking is a safeguard provided by some languages. It prevents 
a program from using a subscript that is beyond the boundaries of an array. 
C++ does not perform array bounds checking. 
8.6 
1 
2 
3 
4 
5 

Answers to Checkpoints 
1181 
8.7 
#include 
<iostream> 
using namespace std ; 
i nt main() 
{ 
} 
const 
i nt NUM_MEN 
= 10; 
int fish [NUM_MEN
J, count; 
cout << "Enter 
the number of fish 
caught\n"; 
cout << "by each fisher
man. \n"; 
for 
(i nt count
= O; count< 
NUM_M
EN; count++ ) 
{ 
} 
cout <<"fisherman"<< 
(count +1) << "· "; 
ci n 
>> f is h[count ] ; 
cout << "\n\nFish 
Report\n\n"; 
for 
(i nt count
= O; count< 
NUM_MEN
; count++ ) 
{ 
} 
cout <<"Fisherman#"<< 
count +1 <<"caught" 
<< f is h[count ] <<" 
fish.\n"; 
ret urn O; 
8.8 
A) int ages[10] 
= {5, 7 , 9 , 14 , 15 , 17, 18, 19, 21, 23}; 
B) double temps[?] 
= {14 .7 , 16.3 , 18.43, 21.09 , 17.9 , 18 .76 , 26.7 }; 
C) char 
alpha(B
] = { 'J ', 
'B' , 'L' 
1 
'A', 
' * ' , '$', 
'H', 
'M' }; 
8.9 
A) int numbers[10] 
= {O, 0, 1 , 0 , 0, 1 , 0, 0, 1, 1}; 
Th e definition is valid. 
B) int matr ix [5] = {1, 2 , 3, 4 , 5, 6 , 7}; 
Th e defin ition is invalid because there are too many values in the initiali-
zation list. 
C) double 
rad i i[10] 
= {3. 2 , 4 .7 }; 
Th e definition is valid. Elements 2 through 9 will be initialized to 0.0. 
D) int table[?] 
= {2, , , 27, , 45 , 39}; 
Th e defin ition is invalid. Values cannot be skipped in the initialization list. 
E) char codes [ J = { 'A' , ' X ' , '1 ' , '2' , ' s '} ; 
Th e definit ion is valid. Th e codes array will be allocated space for five 
characters. 
F) int blan ks []; 
Th e definit ion is inval id. An initia lization list must be provided when an 
array is implic itly sized . 
G) string 
suit[4] 
= {"Clubs", 
"Diamonds" , "Hearts
", "Spades"}; 
Th e definition is valid. 
8.10 
No. An entire array cannot be copied in a single statement with the= operator. 
The array must be copied element by element. 
8.11 
A) 10 
B) 3 
C) 6 
D) 14 

1182 
Appendix C 
Answers to Checkpoints 
8.12 
O 
8.13 
10.00 
25.00 
32.50 
50.00 
110. 00 
8.14 
1 18 18 
2 4 8 
3 27 81 
4 52 208 
5 100 500 
8.15 
typedef 
int Tenints[10]
; 
8.16 
The starting address of the array 
8.17 
ABCDEFGH 
8.18 
(The entire program is shown here.) 
#include 
<iostream> 
using namespace std ; 
// Function 
prototype 
double avgArray(const 
i nt [], 
int); 
i nt main() 
{ 
const i nt SIZE= 10 ; 
int userNums[SIZE ] ; 
cout << "Enter 
10 numbers: "; 
for (int 
count= 
O; count< 
SIZE; count ++) 
{ 
} 
cout << "#" << (co unt+ 
1) 
ci n >> userNums[count ] ; 
<< " ". ' 
cout << "The average of those numbers is
"; 
cout << avgArray(userNums, 
SIZE)<< 
endl; 
return 
O; 
} 
// Function 
avgArray 
double avgArray(const 
i nt array(], 
size) 
{ 
} 
double total 
= 0.0, 
average; 
for (int 
count= 
O; count< 
size ; count ++) 
total 
+= array(count
] ; 
average
= total 
/ siz e; 
return 
average; 
8.19 
i nt grades[30] 
(10]; 
8.20 
24 
8.21 
sales[O ] [OJ = 56893.12 ; 
8.22 
cout << sales[5
] [3]; 

8.23 
i nt settings[3] 
[5] = {{12, 24 , 32, 21, 42}, 
{14 , 67, 87, 65 , 90} , 
{ 19 , 1 , 24 , 12 , 8}} ; 
8.24 
2 
3 
0 
0 
7 
9 
2 
0 
1 
0 
0 
0 
Answers to Checkpoints 
1183 
8.25 
void displayArray7(int 
array[][?], 
int numRows} 
{ 
} 
for (i nt row = O; row< numRows; row ++} 
{ 
} 
for (i nt col = O; col < 7 ; col ++) 
{ cout << array[row
][ col ] <<" 
"; 
} 
cout << end l; 
8.26 
i nt vidNum[50 ] [10][25]; 
8.27 
vector 
8.28 
vector 
<int> frogs ; 
vector 
<float> 
lizards
(20}; 
vector 
<char> toads (100 , 'Z'); 
8.29 
vector 
<int> gators; 
vector 
<double> snakes (10}; 
gators.push
_back(27); 
snakes[4] 
= 12 .897; 
8.30 
false 
8.31 
false 
8.32 
10 
20 
50 
8.33 
#include 
<iostream> 
using namespace std ; 
class 
Yard 
{ 
private
: 
int length , width; 
public : 
} ; 
Yard () 
{leng
th
= O; width= 
O; } 
void setlength(int 
len } 
{ leng th = l en ; } 
void setWidth(int 
wi de} 
{w i dth= 
wide ; } 
int getlength() 
{ret urn length ;} 
int getWi dth(} 
{return 
width;} 

1184 
Appendix C 
Answers to Checkpoints 
i nt main() 
{ 
} 
const i nt SIZE= 10 ; 
Yard lawns[SIZE]; 
cout << "Enter the length 
and width of" 
<< "each yard.\n"; 
for (int 
count= 
O; count< 
SIZE; count ++) 
{ 
int input; 
cout <<"Yard"<< 
(c ount+ 
1) << ":\ n"; 
cout << "length: 
"; 
ci n 
>> input; 
lawns[count] 
.setlength(input); 
cout << "width: 
"; 
ci n 
>> input; 
lawns[count] 
.setWidth( i nput); 
} 
cout << "\nHere are the yard dimensions
. \n"; 
for (int 
yard= 
O; yard< 
SIZE; yard+ +) 
{ 
cout <<"Yard"<< 
(yard+1) <<" 
" 
<< lawns[yard] 
.getlength() 
<< " X " 
<< lawns[yard] 
.getWidth() 
<< endl; 
} 
return 
O; 
8.34 
Product () 
II Default 
constructor 
{ descript
ion
=""; 
partNum =c ost= 
O; 
} 
Product(string 
d, int p , double c) 
{ descript
ion
= d; 
} 
partNum = p; 
cost
= c; 
8.35 
Product 
items[100]; 
8.36 
item s[O ] .description 
= "Claw Hammer"; 
item s[O ] .partNum = 547; 
item s[O ] .cost= 
8.29; 
8.37 
for (int 
x = O; x < 100 ; x++ ) 
{ 
II Constructor 
cout << it ems[x].description 
<< endl; 
cout << it ems[x].partNum 
<< endl ; 
cout << it ems[x].cost 
<< endl << endl; 
} 
8.38 
Product 
items[5 ] = { Product("Screw 
driver", 
621, 1.72 ), 
Product ("Socket set", 
892, 19.97 ), 
Product ("Cl aw hammer", 547, 8.29) 
}; 

8.39 
struct 
Measurement 
{ 
int miles; 
double hours; 
} ; 
8.40 
struct 
Dest i nat io n 
{ 
string 
cit y; 
Measurement travelT i me; 
} ; 
8.41 
Destination 
places 
(20 ] ; 
places[4
].c it y = "Tupelo" ; 
places[4
].tr ave1Time.mi le s = 375; 
places[4
].tr ave1Time.ho ur s = 7 .5 ; 
Chapter9 
Answers to Checkpoints 
1185 
9.1 
The linear search algorithm simply uses a loop to step through each element 
of an array, comparing each element's value with the value being searched for. 
The binary search algorithm, which requires the values in the array to be 
sorted in order, starts searching at the element in the middle of the array . If 
the middle element's value is greater than the value being searched for, the 
algorithm next tests the element in the middle of the first half of the array. If 
the middle element's value is less than the value being searched for, the algo-
rithm next tests the element in the middle of the last half of the array . Each 
time the array tests an array element and does not find the value being 
searched for, it eliminates half of the remaining portion of the array. This 
method continues until the value is found, or there are no more elements to 
test. The binary search is more efficient than the linear search. 
9.2 
500 
9.3 
10 
9.4 
The items frequently searched for can be stored near the beginning of the array. 
9.5 
True 
9.6 
Change the> sign in the i f statement to a< sign. The line would now read 
If (array(count
] < array(count 
+ 1]) 
9.7 
The last value is now in order. 
9.8 
The first value, in position 0, is now in order. 
9.9 
selection sort 
9.10 
A basic operat ion is one that requires constant time, regardless of the size of 
the problem that is being solved. 
9.11 
The worst case complexity function f{n) of an algorithm is a measure of the 
time required by the algorithm to solve a problem instance of size n that 
requires the most time. 
9.12 
Because 10n and 25n differ by a constant factor and constant factors are not 
significant, the two algorithms are considered to be equivalent in efficiency. 

1186 
Appendix C 
Answers to Checkpoints 
9.13 
To say that f{n) is in O(g(n)) means that there exists a positive constant K such 
that f(n) ~ Kg(n) for all n ~ 1. This means that for large prob lem sizes, an 
algorithm with complexity function f(n) is no worse than one with complexity 
function g(n) . 
9.14 
To show that 100n3 + 50n2 + 75 is in 0 (20n3), we must show that some con-
stant K exists for which 100n 3 + 50n2 + 75 ~ K(20n3) for all n ~ 1. 
Observe that for all n ~ 1 
100n 3 + 50n2 + 75 = 5 + 2 + _.]J_ ~ 5 + 5 + 75 ~ 85 
20n3 
2n 
20n3 
Therefore, we have found a constant K that satisfies the inequality, namely K = 85. 
9.15 
Assuming that g(n) ~ 1 for all n ~ 1, we have 100 ~ 100 g(n) for all n ~ 1. This 
implies that g(n) + 100 ~ g(n) + lOOg(n) = lOlg (n) for all n ~ 1. Now, if f{n) is 
in O(g(n)+lOO), there exists a positive K such that f{n) ~ K(g(n)+lOO) ~ 101Kg(n) 
for all n ~ 1. Taking K1 = 101K, we see that f{n) ~ K1g(n) for all n ~ 1. 
Chapter 10 
10.1 
cout << &count; 
10.2 
double *dPtr; 
10.3 
Multiplicat ion operator, pointer declaration, indirect ion operator 
10.4 
50 
60 
70 
500 
300 
140 
10.5 
for (int x = O; x < 100; 
x++) 
cout <<*(array+ 
x) << endl; 
10.6 
12040 
10.7 
A) Valid 
B) Valid 
C) Invalid . Only addition and subtraction are valid arithmetic operations 
with pointers . 
D) Invalid . Only addition and subtraction are valid arithmetic operations 
with pointers . 
E) Valid 
10.8 A) Valid 
B) Valid 
C) Invalid. fvar is a float, and i ptr is a pointer to an i nt . 
D) Valid 
E) Invalid. i var must be defined before it is used. 
10.9 A) True 
B) False 
C) True 
D) False 

10.10 
makeNegative 
(&num); 
10.11 
voi d convert
(double *val) 
{ 
*val *= 2.54; 
) 
10.12 
A 
10.13 
i p = new int; 
delete 
ip; 
10.14 
ip = new int[500]; 
delete 
(] ip; 
10.15 
A pointer whose value is the address 0 
10.16 
char *getname(char 
*name) 
{ 
) 
cout << "Enter your name: "; 
ci n.getl
i ne(name, 81); 
return 
name; 
10.17 
char *getname() 
{ 
) 
char name[81 ] ; 
cout << "Enter your name: "; 
ci n.getl
i ne(name, 81); 
ret urn name; 
10.18 
Rectangle 
*rptr; 
Answers to Checkpoints 
1187 
10.19 
cout << rptr->length 
<< endl << rptr->w i dth << endl; 
10.20 
B 
Chapter 11 
11.1 
Each class object (an instance of a class) has its own copy of the class's 
instance member variables. If a class's member variable is static, however, 
only one copy of the variab le exists in memory. All objects of that class have 
access to that one variable. 
11.2 
Outside the class declaration 
11.3 
Before 
11.4 
Static member functions cannot access instance members unless they explic-
itly specify an object of the class. 
11.5 
You can call a static member function before any instances of the class have 
been created. 
11.6 
No, but it has access to all of class X's members, just as if it were a member. 
11.7 
Class X 

1188 
Appendix C 
Answe rs to Checkpoints 
11.8 
Each member of one object is copied to its counterpart in another object of 
the same class. 
11. 9 
When one object is copied to another with the = operator, and when one 
object is initialized with another object's data 
11.10 
When an object contains a pointer to dynamically allocated memory 
11.11 
When an object is initialized with another object's data, when an object is 
passed by value as the argument to a function, and when an object is returned 
by value. 
11.12 
The member function has the same name as the class, has no return type, 
and has a single reference parameter to the same type as the class. 
11.13 
It performs memberwise assignment. 
11.14 
Pet Pet : : opera t or=(const 
Pet ); 
11.15 
dog .opera t or=(ca t ); 
11.16 
It cannot be used in multip le assignment statements or other expressions . 
11.17 
It's a built-in pointer, available to a class's instance member functions, that 
always points to the instance of the class making the function call. 
11.18 
Instance member functions 
11.19 
cat is calling the operator+ function . t i ger is passed as an argument . 
11.20 
The operator is used in postfix mode . 
11.21 
They shou ld always return Boolean values. 
11.22 
The object may be directly used with input stream such as ci n and output 
streams such as cout . 
11.23 
An ostr eam object should be returned by reference. 
11.24 
An i st ream object should be returned by reference. 
11.25 
The operator function must be declared as a friend. 
11.26 
lis t1 .operator[ ] (25); 
11.2 7 
The object whose name appears on the right of the operator in the expression 
11.28 
So statements using the overloaded operators may be used in other expressions 
11.29 
The postfix version has a dummy parameter. 
11.30 
#include 
<str i ng> 
#include 
<vector> 
usi ng namespace std; 
class Trans 
{ 
vect or<stri
ng> numerals 
{ 
} ; 
"ze ro", 
"one", 
"t wo", 
"t hre e " 1 
"four", 
"f i ve ", 
"six", 
"seven" 
1 
"ei ght" 
1 
"nine" 
1 
"ten" 

11.31 
11.32 
11.33 
11.34 
11.35 
11.36 
11.37 
public : 
i nt operator[ 
]( string 
num_s tr) 
{ 
Answers to Checkpoints 
1189 
for (i nt k = O; k < numeral s .size(
); k++) 
{ 
) 
if (numerals[k
] == num_s tr) 
{ 
} 
} 
ret urn k; 
return 
- 1; 
string 
operator() 
(i nt i, int 
j) 
{ 
string 
concat _values; 
for (i nt k = i; k <= j; 
k++) 
{ 
concat _values 
= concat _values 
+ numerals[k ] ; 
} 
return 
concat _values; 
) 
) ; 
int main(int 
argc, 
char** argv) 
{ 
) 
Trans trans; 
II Output some values 
cout << "seven ·• << trans["seven"] 
<< endl; 
cout <<"three:"<< 
trans["three"] 
<< endl; 
II Output concatenat
i ons of item s 3 .. 7 
cout << trans(3, 
7) << endl ; 
return 
O; 
An rvalue reference is a reference to a temporary object or memory location. 
The type is immediately followed by the double ampersand &&. 
Move assignment transfers a resource from the source to the target of the 
assignment, while copy assignment creates a copy of the resource at the target. 
A function object is an object of a class that overloads the function call 
operator . 
The function call operator. 
A lambda expression denotes an object of a class whose only member is the 
function call operator. 
Objects are automatica lly converted to other types. This ensures that an 
object's data is properly converted . 

1190 
Appendix C 
Answers to Checkpoints 
11.38 
They always return a value of the data type they are converting to. 
11.39 
Bl ackBox: : operator 
int() 
11.40 
Big: :Big (Small sm) 
11.41 
The is-a relation 
11.42 
Because derived class objects can be considered as forming a subset of the set 
of base class objects. Hence we can think of the base class as a "upe rset" or 
superclass of the derived class. 
11.43 
The base class access specification determines how members inherited from 
the base class will be accessed in the derived class. 
11.44 
A typist is a special case of an employee. 
class 
Employee 
{ 
i nt yearsOfService; 
} ; 
class Typist 
: public Employ ee 
{ 
i nt wordsPerMinute ; 
} ; 
11.45 
Other than to friend functions, private members are only accessible to mem-
ber functions of the same class. Protected members are accessible to member 
functions of the class as well as member functions of all derived classes. 
11.46 
Member access specificat ion determines how a class member is accessible 
to code outs ide of the class . Base class access specification determ ines 
how members inherited from a base class will be accessed through the 
derived class. 
11.4 7 
A) a is inaccessible; the rest are private . 
B) a is inaccessible; the rest are protected. 
C) a is inaccessible; b, c, and setA are protected; setB and setC are public. 
D) Private 
11.48 
Derived class constr uctors can assume members of the base class object have 
already been initialized. 
11.49 
Declarations are for typechecking, definitions are for code generat ion . The 
compiler needs the arguments to the base class constructor when it is gener-
ating code. 
11.50 
The same situation arises with compos ition when an outer class object needs 
to pass arguments to a constr uctor of an inner class object . The same syntax 
is used. 
11.51 
Entering t he base. 
Entering t he camp. 
Leavi ng the camp. 
Leavi ng the base . 
11.52 
This base is secure. 
The camp is secluded . 
Leavi ng the camp. 
Leavi ng the base . 

Answers to Checkpoints 
11 91 
Chapter 12 
12.1 
strlen 
Accepts a C-string as an argument. Returns the length of the 
string (not including the null terminator). 
strcat 
Accepts two C-strings as arguments . The function appends the 
contents of the second string to the first string. (The first string 
is altered, the second string is left unchanged.) 
strcpy 
Accepts two C-strings as arguments . The function copies the 
second string to the first string. The second string is left 
unchanged. 
strcmp 
Accepts two C-string arguments . If string1 and string2 are 
the same, this function returns 0. If st ri ng2 is alphabetically 
greater than stri ng1, it returns a negative number. If st ri ng2 
is alphabetically less than stri ng1, it returns a positive number. 
12.2 
4 
12.3 
Have a nice day 
nice day 
12.4 
st rcpy (composer, 
"Beethoven") ; 
12.5 
#include 
<cstdl i b> 
12.6 
#include 
<iostream> 
us i ng namespace std; 
i nt main(int 
argc, 
char** argv) 
{ 
} 
A) 
B) 
C) 
D) 
// Read a l ine of input 
char input (80 ] ; 
cout << "Enter a line of input: 
"; 
cin .getline(input
, 81); 
II Count number of es 
int e_count = O; 
for (int 
k = O; input[k] 
!= '\O'; 
k++) 
{ 
if (inpu t [k] == 'e') 
{ 
} 
} 
e_count+ +; 
cout << "Number of occurrences 
of the le tte r 'e': 
"; 
cout << e_count; 
return 
O; 
negative 
negative 
negative 
positive 

1192 
Appendix C 
Answe rs to Checkpoints 
12.7 
i f (st rcmp( i ceCrea m, "Chocola t e")== 
0) 
12.8 
12.9 
12.10 
12.11 
12.12 
12.13 
cout << "Chocolate: 
9 fa t grams.\n"; 
else 
if 
(strcmp(iceCream, 
"Vani lla") 
== 0) 
cout << "Vanilla: 
10 fat 
gra ms . \ n"; 
else 
if 
(strcmp(iceCream, 
"Pralines 
and Pecan") 
== 0) 
cout << "Pralines 
and Pecan: 
14 fat 
gra ms . \n"; 
else 
cout << "That's 
not one of our flavors!\
n"; 
st oi 
Converts a string to an integer. 
st od 
Converts a string to a value of type double . 
to _string 
Takes a numeric value as parameter and returns a string. 
num = st oi ("10"); 
num = st ol ("10000"); 
num = st od("?.
2389"); 
st oi ( "21201", 
nullptr
, 3); 
Tom Talbert 
Tried 
Trains 
Dom Dalbert 
Dried Dra i ns 
Chapter 13 
13.1 
i stream, 
istr
i ngstream, 
and i fs t ream 
13.2 
ostream, 
ostr i ngstream, 
andofs
t ream 
13.3 
To specify a file open mode. 
13.4 
Closing the file sooner than later frees up operating system resources and pre -
vents loss of data written to the file in the event of an abnorma l termination . 
13.5 
i OS: 
: app 
13.6 
i os: : t runc 
13. 7 
A new file of the given name is created and opened for output . 
13.8 
The contents of the file are discarded and the file is opened for output . 
13.9 
i nt a, b; 
cou t << "Enter 
two octal 
numbers" 
ci n >> oct >>a>> 
b; 
cou t << "The octal 
sum is"<< 
oct <<a+ 
b; 
13.10 
i nt a, b; 
cou t << "Enter 
hexadecimal 
numbers" 
; 
ci n >>hex>> 
a>> 
b; 
cou t << "The hexadecimal 
sum is"<< 
hex<< 
a + b << endl; 
cou t << "The decimal 
sum is"<< 
dee<< 
a+ 
b; 

13.11 
fstream 
fileObj 
("myfile.txt", 
io s: :in}; 
13.12 
#include 
<cstdlib> 
#include 
<iostream> 
#include 
<ioman i p> 
us i ng namespace std ; 
i nt main(int 
argc, 
char** 
argv) 
{ 
const 
int SIZE= 
5 ; 
Answers to Checkpoints 
1193 
string 
names[SIZE] 
= {"Alfonso", 
"Bella", 
"Clinton", 
"Dave'' "Elaine"}· 
' 
' 
int 
numbers[SIZE] 
= {12, 56 , 23, - 45, 9}; 
for 
(int 
k = O; k < SIZE; k++) 
{ 
cout <<left<< 
setw(20} 
<< names[k ] 
<<right<< 
setw(10) 
<< numbers[k] 
<< endl; 
} 
return 
O; 
} 
13.13 
#include<iostream> 
#include 
<fstream> 
us i ng namespace std ; 
i nt main(} 
{ 
fstream 
outF il e; 
outFile.open(
"outpu t.txt"
, ios: :out); 
outFile 
<< "Today is the first 
day\n"; 
outFile 
<< "of the rest 
of your life.\n"
; 
return 
O; 
} 
13.14 
It reports when the end of a file has been encountered . 
13.15 
Run 
Spot 
run 
See 
Spot 
run 
13.16 
The >> operator considers whitespace characters as delimiters and does not 
read them. Th e get l i ne (} member function does read whitespace characters. 
13.17 
Th e get line function reads a line of text; the get function reads a single 
character . 
13.18 
Writes a single characte r to a file. 
13.19 
1 e+002 
1. 7 
8.6 
7.8 
5 .1 

1194 
Appendix C 
Answers to Checkpoints 
13.20 
#include 
<cstdl i b> 
#include 
<iostream> 
#include 
<fstream> 
#include 
<cctype> // Needed for toupper 
us i ng namespace std ; 
i nt main() 
{ 
} 
cout << "This program allows you to add names and phone \ n"; 
cout << "numbers to phones.dat.
\n"; 
fst ream names File (·p hones. dat • , i os: : out Ii os: : app) ; 
i f (!namesFile
){ cout <<"Error"; 
return 
1;} 
string 
name, phone; 
char add ; 
do 
{ 
cout << "Do you wi sh to add an entry?"· 
cin >> add; 
ci n. ignore()
; 
if (toupper(add) 
== 'Y') 
{ 
cout << "Name: ''; 
getline(cin, 
name); 
namesFile 
<<name<<• 
.. 
cout << "Phone Number: "· 
getl i ne(cin, 
phone ); 
namesFile 
<<phone<< 
endl; 
} 
} while 
(to upper (add) == 'Y'); 
namesFile.close
(); 
return 
O; 
13.21 
#include 
<cstdl i b> 
#include 
<iostream> 
#include 
<fstream> 
us i ng namespace std ; 
i nt main(int 
argc, 
char** argv) 
{ 
fstream 
data1 ("da ta1 .txt", 
ios: :in); 
fstream 
data2 ("da ta2.txt"
, io s: :in); 
fstream 
data3 ("da ta3.txt"
, io s: :out); 
if ( ! data1 
11 ! data2 
11 ! data2 ) 
{ 
} 
cout << "Trouble open i ng files."
; 
return 
1; 
for (char ch= 
data1 .get(); 
ch != EOF; ch= 
data1 .get()) 
data3.put(ch); 
data1. close(); 

Answers to Checkpoints 
1195 
for (char ch= data2 .get (); ch != EOF; ch = data2.get
()) 
data3.pu t (ch); 
dat a2.close(); 
dat a3.close(); 
ret urn O; 
} 
13.22 
Character representation: "479" 
ASCII codes: 52 55 57 
13.23 
The << operator writes text to a file. Th e write member function writes 
binary data to a file. 
13.24 
The first argument is the starting address of the section of memory, which is 
to be written to the file. The second argument is the size, in bytes, of the item 
being written . 
13.25 
The first argument is the starting address of the section of memory where 
information read from the file is to be stored. The second argument is the 
size, in bytes, of the item being read. 
13.26 
A filed is an individua l piece of informat ion pertaining to a single item. A 
record is made up of fields and is a complete set of information about a sin-
gle item. 
13.27 
file.write
(r einterpret_cast<char> 
(&cust ), sizeof(cust)); 
13.28 
seekg moves the file's read position (for input ) and seekp moves the file's 
write position (for output) . 
13.29 
tell g reports the file's read position and tell p reports the files write 
position. 
13.30 
i os: : beg The offset is calculated from the beginning of the file 
i os: : end The offset is calculated from the end of the file 
i os: : curr The offset is calculated from the current position 
13.31 
0 
13.32 
file.seekp
(100L, io s: :beg ); 
Move s the write position to the one hundred first byte (byte 100) from the 
beginning of the file. 
file.seekp
(- 10L, io s: :end ); 
Move s the write position to 10 bytes before the end of the file. 
file.seekp
(-25L , io s: :cur); 
Move s the write position 25 bytes backward from the current position . 
file.seekp
(30L, ios: :cur); 
Move s the write position 30 bytes forward from the current position. 
13.33 
file.open
(" i nfo.dat", 
ios: :i n 
io s: :out); 
Input and output 
file. open (" i nfo. dat" , i os: : in I i os: : app ) ; 
Input and outp ut. Output will be appended to the end of the file. 

1196 
Appendix C 
Answe rs to Checkpoints 
file.open("
i nfo.da t ", ios: :i n I i os: :out 
I i os: :ate); 
Input and output . If the file already exists, the program goes immediately to 
the end of the file. 
file.open("
i nfo.da t ", ios: :i n I i os: :out 
I i os: :binary); 
Input and output, binary mode 
Chapter 14 
14.1 
A simple case of the problem that can be solved without recursion . 
14 .2 
The function calls itself with no way of stopping. It creates an infinite recursion. 
14.3 
10 
14.4 
In direct recursion, a recurs ive function calls itself. In indirect recursion, 
function A calls function B, which in turn calls function A. 
Chapter 15 
15.1 
Let p be a pointer pointing to an object ob of a class that is part of an inher-
itance hierarchy. In general, p will be a pointer to some base class 8, and the 
object ob will be an instance of a class D derived from 8. Let f be a member 
function of 8 that is overridden in D. If the call p- >f () is being made, static 
binding will call the version of f that is in the class 8. Static binding will 
select the function to call based on the type of the pointer and will do so at 
compile time. Dynamic binding will wait until runtime and will select the 
version of f that is in D, the class of the object . 
15.2 
Dynamically 
15.3 
1 
5 
15.4 
2 
2 
15.5 
2 
1 
15.6 
2 
15. 7 
The body of the function is replaced with = O; 
15.8 
It cannot be used to instantiate objects. 
15.9 
A) Inaccessible 
B) Protected 
C) Protected 
D) Inaccessible 
E) Protected 
F) Public 
G) Private 
H) Protected 
I) 
Public 

Answers to Checkpoints 
1197 
Chapter 16 
16.1 
The try block contains one or more statements that may directly or indi-
rectly throw an exception . The catch block contains code that handles, or 
responds to an exception . 
16.2 
The entire program will abort execution. 
16.3 
Each exception must be of a different type. The catch block whose parame-
ter matches the data type of the exception handles the exception. 
16.4 
With the first statement after the try/catch construct 
16.5 
By giving the exception class a member variable, and storing the desired 
information in the variable. The throw statement creates an instance of the 
exception class, which must be caught by a catch statement . The catch block 
can then examine the contents of the member variab le. 
16.6 
When it encounters a call to the function 
16.7 
template 
<class 
T> 
i nt minPosition(
T arr[], 
i nt s iz e) 
{ 
) 
i nt minPos = O; 
for (int 
k = 1; k < siz e; k++) 
{ 
} 
if (arr[k
] < arr[m i nPos]) 
minPos = k; 
re t urn mi nPos; 
16.8 
That the operator has been overloaded by the class object 
16.9 
First write a regular, nontemplated version of the function . Then, after test-
ing the function, convert it to a template. 
16.10 
Lis t <in t > myli st; 
16.11 
template 
<class 
T> 
class 
Rect angle 
{ 
} ; 
private: 
T width; 
T lengt h ; 
T area; 
public: 
void setDa t a(T W, TL) 
{widt
h = W; length= 
L;} 
void cal cArea () 
{area= 
width* 
length; 
} 
T getWi dt h () 
{ return 
width; 
} 
T getlength() 
{ return 
leng t h; ) 
T getArea () 
{ return 
area; 
} 

1198 
Appendix C 
Answe rs to Checkpoints 
Chapter 17 
17.1 
A data member contains the data stored in the node. A successor pointer 
points to the next node in the list. 
17.2 
A pointer to the first node in the tree 
17.3 
The successor pointer in the last node will have a value of NULL. 
17.4 
A data structure that conta ins a pointer to an object of the same data 
structure type 
17.5 
Appending a node is adding a new node to the end of the list. Inserting a 
node is adding a new node in a position between two other nodes. 
17.6 
Appending 
17. 7 
We need a pointer to the previous node so we can set its successor pointer to 
the new node. 
17.8 
A) Remove the node from the list without breaking the links created by the 
next pointers . 
B) Delete the node from memory. 
17.9 
Because there is probably a node pointing to the node being deleted. Addi-
tionally, the node being deleted probab ly points to another node. These links 
in the list must be preserved. 
17.10 
The unused memory is never freed, so it could eventually be used up. 
Chapter 18 
18.1 
Last-in-first-out. The last item stored in a LIFO data structure is the first 
item extracted . 
18.2 
A static stack has a fixed size and is implemented as an array . A dynamic 
stack grows in size as needed and is implemented as a linked list. Advantages 
of a dynamic stack: There is no need to specify the starting size of the stack. 
The stack automatically grows each time an item is pushed and shrinks each 
time an item is popped . Also, a dynamic stack is never full (as long as the 
system has free memory ). 
18.3 
Push: An item is pushed onto, or stored in, the stack. 
Pop: An item is retrieved (and hence, removed) from the stack. 
18.4 
Vector, linked list, or deque 
Chapter 19 
19.1 
A standard linked list is a linear data structure in which each node has at 
most one successor. A binary tree is nonlinear, because each node can have 
up to two successors. 
19.2 
The first node in the tree 
19.3 
A node pointed to by another node in the tree 
19.4 
A node that points to no other nodes 

Answers to Checkpo ints 
1199 
19.5 
A collection of nodes of the binary tree that consists of some node X, 
together with all the descendants of X. An empty collection of nodes is also 
a subtree . 
19.6 
Information can be stored in a binary tree in a way that makes a form of 
binary search possible. 
19. 7 
1. The node's left subtree is traversed . 
2. The node's data is processed. 
3. The node's right subtree is traversed. 
19.8 
1. The node's data is processed. 
2. The node's left subtree is traversed . 
3. The node's right subtree is traversed. 
19.9 
1. The node's left subtree is traversed . 
2. The node's right subtree is traversed. 
3. The node's data is processed. 
19 .10 
The node to be deleted is node D. 
1. Find node D's parent and set the child pointer that links the parent to 
node D, to NULL. 
2. Free node D's memory. 
19 .11 
The node to be deleted is node D. 
1. Find node D's parent . 
2. Link the parent node's child pointer (that points to node D) to node D's 
child. 
3. Free node D's memory. 
19.12 
1. Attach the node's right subtree to the parent, and then find a position in 
the right subtree to attach the left subtree. 
2. Free the node's memory. 

This page intentionally left blank 

Chapter 1 
1. programmed 
3. arithmetic logic unit (ALU) and control unit 
5. operating systems and application software 
7. programming language 
9. High-level 
11. portabi lity 
13. programmer -defined symbols 
15. Punctuation 
17. variab le 
19. input, processing, output 
21. Output 
23. Main memory, or RAM, is volatile, which means its contents are erased when 
power is removed from the computer. Secondary memory, such as a disk or CD, 
does not lose its contents when power is removed from the computer. 
25. A syntax error is the misuse of a key word, operator, punctuation, or other part 
of the programm ing language. A logical error is a mistake that tells the computer 
to carry out a task incorrectly or to carry out tasks in the wrong order. It causes 
the program to produce the wrong results. 
27. Account Balance High Leve1 Pseudocode 
Have user input starting 
balance 
Have user input tota1 deposits 
Have user input tota1 withdrawals 
Ca1cu1ate current 
balance 
Display 
current 
balance 
1201 

1202 
Appendix D 
Answers to Odd-Numbered Review Questions 
Account Balance Detailed 
Pseudocode 
Input startBa1ance 
Input tota1Deposits 
Input tota1Withdrawa1s 
II with prompt 
II with prompt 
I I with prompt 
currentBa1ance 
= startBa1ance 
+ tota1Deposits 
- tota1Withdrawa1s 
Display 
currentBa1ance 
29. 45 
31. 28 
33. Th e error is that the program performs its math ope rat ion before the user has 
entered values for the variables wi dth and length. 
Chapter 2 
1. semico lon 
3. mai n 
5. braces {} 
7. 9.7865E14 
9. A) valid 
B) invalid 
C) valid 
11. A) valid 
B) invalid (\n must be inside a string.) 
C) valid, but it prints the contents of variab le He 11 o, rather than the string 
"Hello" . 
13. A) 11 
B) 14 
15. double temp , 
wei ght , 
height ; 
17. A) d2 = d1 + 2 ; 
B) d1 = d2 * 4 ; 
C) C = 'K'; 
D) i = 'K' ; 
E) i = i -
1 ; 
C) 3 (An integer divide takes place. ) 
19. cout << "Two mandol i ns like 
creatures 
in the\n\n\n"; 
cout << "dark\n\n\n"; 
cout << "Creating 
the agony of ecstasy.
\n\n\n"; 
cout << " 
- George Barker\n\n\n"; 
21. Input weeks 
days= 
weeks
* 7 
Display 
days 
23. Input speed 
Input time 
distance= 
speed 
Display 
distance 
* time 
I I with prompt 
I I with prompt 
I I with prompt 

25. A) 
B) 
C) 
0 
100 
8 
2 
I am the i ncred i blecomputing 
machine 
and I 
amaze 
you . 
wi 11 
Answers to Odd-Numbe red Review Questions 
1203 
27. Th e line 1 comment symbols are reversed . 
On line 2 i os t ream shou ld be enclosed in ang le brackets. 
On line 5 there should be no semi-colon afte r int mai n () 
Th e curly braces on lines 6 and 13 are reversed. 
On line 7 the variable definitions should end with a semi-colon . 
Also on line 7 the comment symbol slashes go the wrong way . 
Lines 8, 9, and 10 each need to end with semi-colons . 
On line 11 cout and the var iable c shou ld not be capitalized. 
Also line 11 needs stream insertion operators << (not >> operators) . 
Chapter 3 
1. A) cin >> description; 
B) getline(c
i n, description
); 
3. A) cin >> setw(25) 
>> name; 
B) cin .ge tline(name, 
25); 
5. io stream and io manip 
7. string 
city ; // Any valid 
i dentifier 
name may be used. 
// Notice that 
no size 
declarator 
is needed. 
9. A) a = 12 * x; 
B) z = 5 * x + 14 * y + 6 * k; 
C) y = pow ( x , 4) ; 
D) g = (h + 12) / (4 * k); 
E) c = pow(a, 3) / (pow(b , 2) * pow(k, 4 )); 
11. 8 
13. const 
int RATE= 12 ; 
15. east= 
west
= north= 
south
= 1; 
17. i nt sum = O; 
19. cout <<fixed<< 
showpoint 
<< setprecision(2); 
cout << setw(8) 
<< divSales; 

1204 
Appendix D 
Answers to Odd -Numbered Review Questions 
<) 
21. A) cmath 
B) i ostream 
C) i omani p 
D) cstdl i b 
NOTE: 
Now that you understand that user inputs should always be preceded by 
prompts, the I I with 
prompt comment can be omitted from the pseudocode. 
Beginning with Chapter 3, we have begun omitting it. 
23. Input score1 
Input score2 
Input score3 
average= 
(score1 
+ score2 
+ score3) 
I 3.0 
Display 
average 
25. Set PI= 3.14 
Set cost12In 
= 12.00 
Set cost14In 
= 14.00 
area12 = PI • {12/2) 2 
area14 =PI• 
{14/2) 2 
pricePerin12 
= cost12In 
I area12 
pricePerin14 
= cost14In 
I area14 
27. A) Hello George 
B) Hello George Washington 
29. A) The variables in line 1 shou ld not be defined as constants. 
The prompt does not say that the numbers entered must be integers . 
The final line should include a string explaining what the number displayed 
means. 
B) The=* symbol should be *= 
The string in the final cout statement needs to end with a blank . 
Chapter4 
1. relational 
3. false, true 
5. true , false 
7. false 
9. 
11. && 
13. block (or local) 
15. break 
17. i f (y == 0) 
X = 100; 
19. i f (score>= 
90) 
cout << "Excellent"; 
else if (score>= 
80) 
cout << "Good"; 
else 
cout << "Try Harder"; 

21. i f(x < y) 
q = a+ 
b ; 
else 
q = X * 2; 
23. T, F, T 
Answers to Odd-Numbered Review Questions 
1205 
25. i f (grade> = 0 && grade<= 
100) 
cout << "The number is val i d."; 
27. i f (hours< 
0 I I hours> 
80) 
cout << "The number is not val i d."; 
29. i f(sales 
< 10000) 
commission = .10; 
else if (sales<= 
15000) 
commission
= .1 5; 
else 
commission = .20; 
31. It should read 
i f (!(x 
> 20)) 
33. It should use 11 instead of&&. 
35. A) The first cout statement is terminated by a semicolon too early. 
The definition of score1, score2 , and score3 shou ld end with a semicolon. 
The following statement: 
if (average= 
100); 
needs an == sign instead of an = sign, and should not end with a semicolon. 
perfectScore 
is used before it is declared . 
The final if statement should not be terminated with a semicolon and the 
conditionally executed block following it should be enclosed in braces . 
B) The conditionally executed blocks in the if I else construct should be enclosed 
in braces. 
The following statement: 
cout << "The quotient 
of•<< 
num1 << 
should end with a semicolon, rather than with a <<. 
C) The trailing else statement sho uld come at the end of the if I else construct . 
D) The variable or expression to be tested in a switch statement must be an integer 
or characte r, not a double. 
The constant value or expression for each case can only be tested for equality 
with the swit ch variable or expression . Relational operators cannot be used. 
This swit ch statement is missing its needed break statements. 
Chapter 5 
1. increment 
3. prefix 
5. body 
7. pretest 

1206 
Appendix D 
Answers to Odd -Numbered Review Questions 
9. infinite (or endless) 
11. running total 
13. sentine l 
15. do-while 
17. initialization , test , update 
19. break 
21. fstream 
23. It will be erased and a new file with the same name will be created . 
25. It mark s the location of the next byte to be read . When an input file is opened, its 
read position is initially set to the first byte in the file. 
27. i nt num; 
ci n >> num; 
num *=2; 
whi le (num < 50) 
{ cout << num << endl; 
num *=2; 
} 
29. for 
(in t x = O; x <= 1000; x += 10) 
cout << x; 
31. for 
(in t row= 
1 ; row<= 3; row++} 
{ 
for 
(int 
star= 
1; st ar<= 
5; st ar++) 
cout 
<< '*'; 
cout << endl; 
} 
33. char doAgai n ; 
i nt sum= O; 
cout << 
do 
"Thi s code will 
increment 
sum 1 or more t i mes.\n"; 
{ 
su m++ ; 
cou t << "Sum has bee n i ncre mented. 
• 
<< "Increment 
it agai n(y/n}? 
"; 
cin 
>> doAgai n; 
} whi le ((doAga i n == 'y'} 
II (doAgain --
'Y'}); 
cout << "Sum was i ncre mented•<< 
sum<<• 
times . \n"; 
35. for 
(in t count= 
O; coun t < 50; count ++) 
cout << "count i s•<< 
cou nt << endl; 
37. for 
(in t num = 1 ; num <= 50; num++) 
out file 
<< num << • .. 
' 
39. Nothing will print. The erroneous semicolon after the while condition causes the 
whi le loop to end there . Because x will continue to remain 1, x < 1 O will remain 
true and the infinite loop can never be exited . 
41. 2 4 6 8 10 

Answers to Odd-Numbered Review Questions 
1207 
43. A) The statement result 
= ++(num1 + num2); is invalid. 
B) The while loop tests the variable again before any values are stored in it. 
The while loop is missing its opening and closing braces. 
45. A) The expression tested by the do-while loop should be choice == 1 instead of 
choice = 1. 
B) The variable total is not initialized to 0. 
The while loop does not change the value of count, so it iterates an infinite 
number of times. 
Chapter6 
1. header 
3. showValue(5); 
5. arguments 
7. value 
9. local 
11. Global 
13. local 
15. return 
17. last 
19. reference 
21. reference 
23. parameter lists 
25. Arguments appear in the parentheses of a function call. They are the actual values 
passed to a function . Parameters appear in the parentheses of a function heading. 
They are the variables that receive the arguments. 
27. Function overloading means including more than one function in the same pro-
gram that has the same name. C++ allows this providing the overloaded functions 
can be distinguished by having different parameter lists. 
29. You want the function to change the value of a variable that is defined in the call-
ing function . 
31. Yes, but within that function only the local variable can be "seen" and accessed. 
33. double half(double 
value) 
{ 
return value/ 
2; 
} 
35. voi d timesTen(int 
num) 
{ 
cout << num * 10; 
} 

1208 
Appendix D 
Answers to Odd-Numbered Review Questions 
37. void getNumber( i nt &number) 
{ 
cout << "Enter an integer 
between 1 and 100): "; 
cin 
>> number ; 
while (number < 1 11 number > 100) 
{ 
cout << "This value i s out of the allowed range. \n" 
<< "Enter an integer 
between 1 and 100): "; 
} 
} 
39. A) The data type of val ue2 and val ue3 must be declared . 
The function is declared void but returns a value. 
B) The assignment statement should read: 
average= 
(value1 
+ value2 
+ value3) 
/ 3 .0; 
The function is declared as a double but returns no value. 
C) widt h shou ld have a default argument value. 
The function is declared void but returns a value. 
D) The parameter shou ld be declared as: 
int &value 
The ci n statement should read: 
cin >> value; 
E) The functions must have different parameter lists. 
Chapter 7 
1. Abstract Data Type 
3. procedural and object-oriented 
5. data and procedures (i.e., functions ) 
7. instantiating 
9. member variab les 
11. encapsulation 
13. member variab les, member functions 
15. mutator 
17. class 
19. return 
21. destroyed 
23. default 
25. constr uctor, destructor 
27. public 
29. False. It can be both passed to a function and returned from a function . 
31. separate (i.e., each in their own file) 
33. Canine. cpp 

Answers to Odd-Numbe red Review Questions 
1209 
35. public 
3 7. initialization list, constructor 
39. Inventory 
trivet= 
{555, 
110}; 
41. struct 
TempScale 
{ double fahrenheit; 
double celsius; 
} ; 
struct 
Reading 
{ 
int wi ndSpeed; 
double humi dit y; 
TempScale temperature; 
} ; 
Reading today; 
today .windSpeed = 37; 
today .humidi ty= 
.32; 
today .temperature.fahrenhe
i t = 32; 
today .temperature.celsius 
= O; 
43. voi d inputReading(Reading 
&r) 
{ 
cout << "Enter 
the wind speed: 
". 
' 
cin 
>> r.w i ndSpeed; 
cout << "Enter 
the humi dity: 
". 
' 
cin 
>> r.hum i dit y; 
cout << "Enter 
the fahrenheit 
temperature: 
". 
' 
cin 
>> r.temperature.fahrenhe
it ; 
cout << "Enter 
the celsius 
temperature: 
". 
' 
cin 
>> r.temperature.cels
i us; 
} 
45. A) valid 
B) invalid 
C) invalid 
D) valid 
47. Inventory(string 
id= 
0, string 
descrip 
= "new", int qty= 
0) 
{ prodID = id; prodDescript
i on = descrip
; qtylnStock 
= qty; 
} 
49. A) Th e structure declaration has no tag. 
B) Th e semico lon is missing after the closing brace. 
51. A) Th e Names structure needs a constructor that accepts 2 strings. 
B) Structure members cannot be initialized in the structure declaration . 
53. A) The semicolon sho uld not appear after the word DumbBel l in the class 
declaration. 
Even though the weight member variable is private by default, it should be 
preceded with the private 
access specifier. 
Because the setWei ght member function is defined outside the class declaration, 
its function header must appear as: 
void DumbBell: :setWeight(
i nt w} 
Th e line that reads: 
DumbBel l. setWeight (200}; 
should read: 
bar. set Weight ( 200 ) ; 
Because the weight member var iable is private, it cannot be accessed outsid e 
the class, so the cout statement cannot legally output bar.weight
. Th ere 
needs to be a public get Weight (} function that the main program can call. 

1210 
Appendix D 
Answers to Odd-Numbered Review Questions 
B) Constr uctors must be public, not private. 
Both constr uctors are considered the default constructor. This is illegal since 
there can be only one default constr uctor. 
All the parameters in the Change function header should have a data type. 
55. A) The nouns are 
Bank 
Account 
Customer 
Savings Account 
Checking Account 
Money market account 
Money 
Balance 
Interest 
Interest rate 
After eliminating dup licates, objects, and simple values that can be stored in 
class variab les, the potential classes are: Bank, Account, and Customer . 
B) The only class needed for this particular problem is Account. 
C) The Account class must know its balance and interest rate . 
The Account class must be able to hand le deposits and withdr awals and cal-
culate interest earned . It is this last capab ility, calculating interest earned, that 
this app lication will use. 
Chapter8 
1. size declarator 
3. subscript 
5. size declarator, subscript 
7. initialization 
9. initialization list 
11. subscript 
13. value 
15. multidimensional 
17. two 
19. columns 
21. A) 10 
23. A) 3 
B) o 
B) o 
25. All 5 are valid. 
27. A) 8 
B) 10 
C) 9 
C) so 
D) 40 
D) sales(?
] [9] = 3.52 ; 
29. Car forSale [35] = { Car("Ford", 
"Taurus", 
2006, 21000), 
Car("Honda", "Accord", 
2004, 11000), 
Car("Jeep", 
"Wrangler",2007, 
24000) }; 
31. for (int 
index= 
O; index< 
25; i ndex++) 
array2 [i ndex] = array1 [i ndex] 

Answers to Odd-Numbe red Review Questions 
1211 
33. struct 
PopStruct 
{ string 
name; 
long 
populat ion ; 
} ; 
PopStruct 
country[12]; 
i fstream 
dataln; 
dataln.open("pop.dat
"); 
for (int 
index= 
O; index< 
12; index++ ) 
{ getline(dataln, 
country[index
] .na me); 
} 
dataln 
>> country[index
] .population; 
dataln
.ignore(); 
data In. close () ; 
35. i nt i d[10]; 
double grossPay[10]; 
for (int 
emp = O; emp < 10; emp++) 
cout << id[emp] << • 
• << grossPay[emp] 
<< endl ; 
37. A) The size declarator cannot be a variable. 
B) The size declarator cannot be negative. 
C) The initialization list must be enclosed in braces. 
39. A) The parameter should be declared as i nt nums [] . 
B) The parameter must specify the number of columns, not the number of rows. 
Also, a second parameter is needed to specify the number of rows. 
Chapter9 
1. linear 
3. linear 
5. N/2 
7. first 
9. 1/8 
11. ascending 
13. one 
15. there were no number exchanges on the previous pass 
17. Bubble sort normally has to make many data exchanges to place a value in its 
correct position . Selection sort determines which value belongs in the position 
currently being filled with the correctly ordered next value and then places that 
value directly there. 
19. 
Array Size -, 
Linear Search 
(Average Comparisons) 
Linear Search 
(Maximum Comparisons) 
Binary Search 
(Maximum Comparisons) 
100 
1000 
10,000 
100,000 
1,000,000 
Elements 
Elements 
Elements 
Elements 
Elements 
50 
500 
5,000 
50,000 
500,000 
100 
1000 
10,000 
100,000 
1,000,000 
7 
10 
14 
17 
20 

1212 
Appendix D 
Answers to Odd -Numbered Review Questions 
21. A) Map directly from the desired ID to the array location as follows: 
index= 
desiredID 
-101 
B) Do a linear search starting from the last array element and working back-
wards unti l the item is found or unti l a smaller ID is encountered, which 
means the desired ID is not in the array . Here is the pseudocode: 
index= 
299 
II start 
at the last element 
position= 
- 1 
found = fa 1 se 
While index>= 
0 and array[index].customerID 
>= desiredID 
and not found 
If array[index].customerID 
= desiredID 
found = true 
position= 
index 
End If 
Decrement index 
End Whi7e 
Return position 
Chapter 10 
1. address 
3. pointer 
5. pointers 
7. new 
9. null 
11. new 
13. Sending *iptr 
to cout will display 7. Sending iptr 
to cout will display the 
address of x. 
15. You can increment or decrement a pointer using++ and ·· , you can add an integer 
to a pointer, and you can subtract an integer from a pointer . 
17. 8 
19. If new fails to allocate the requested amount of memory, it throws the bad_al l oc 
exception . In programs compiled with older compilers, new returns the value 0. 
21. delete is used to deallocate memory allocated by new. 
23. const int *p; 
25. Smart pointers keep track of the owners of a resource and automatically deallo-
cate the resource when the last owner goes out of scope. 
27. The managed object is deallocated . 
29. shared _ptr 
31. make_shared has lower overhead than the shared _ptr constructor . 
33. change(&i); 
35. voi d exchange(i nt *p, in t *q) 
{ 
) 
i nt t emp= *p; 
*p = *q; 
*q = temp; 

37. A) 30 
B) 30 
C) 0 
D) 0 
E) 20 
F) 10 
G) 10 
H ) 20 
Chapter 11 
1. static 
3. static 
5. friend 
7. Memberwise assignment 
9. this 
11. postfix increment ( or decrement) 
13. has-a 
15. copy constructor 
overloaded = operator 
overloaded = operator 
copy constructor 
Answers to Odd-Numbered Review Questions 
1213 
17. Place the static keyword in the function's prototype. Calls to the function are 
performed by connecting the function name to the class name with the scope 
resolution operator. 
19. In object composition, one object is a nested inside another object, which creates 
a has-a relationship. When a class is a friend of another class, there is no nesting. 
If a class A is a friend of a class B, member functions of A have access to all of B's 
members, including the private ones. 
21. If a pointer member is used to reference dynamically allocated memory, a mem-
berwise assignment operat ion will only copy the contents of the pointer, not the 
section of memory referenced by the pointer. This means that two objects will exist 
with pointers to the same address in memory. If either object manipulates this area 
of memory, the changes will show up for both objects. Also, if either object frees 
the memory, it will no longer contain valid information for either object. 
23. If an object were passed to the copy constr uctor by value, a copy of the argument 
would have to be created before it can be passed to the copy constr uctor. But then 
the creation of the copy would require a call to the copy constructor with the 
original argument being passed by value. This process will continue indefinitely. 
25. Dollars 
Dollars: 
:operator++(
); 
// Prefix 
Dollars 
Dollars::operator++(int); 
// Postfix 

1214 
Appendix D 
Answers to Odd-Numbered Review Questions 
27. ostream &operator<<(ostream 
&strm , Length obj); 
29. The overloaded operators offer a more intuiti ve way of manipulating objects, 
similar to the way primitive data types are manipulated. 
31. members 
33. Pet 
35. private 
3 7. inaccessible, private, private 
39. inaccessible, protected , public 
41. last 
43. A) The first line of the class declaration should read 
class 
Car : publ i c Vehi cle 
Also, the class declaration should end in a semicolon. 
B) The first line of the class declaration should read 
class 
Truck: 
publ i c Vehicle 
Chapter 12 
1. C-string 
3. string 
literal 
5. null terminator 
7. ostr i ngstream 
9. concatenate 
11. strcpy 
13. strcmp 
15. atoi 
17. atof 
19. char lastChar(const 
char *str) 
{ //g o to nul l terminator 
at end 
whil e (*str 
!= 0) 
} 
21. h 
23. 9 
str ++; 
//ba ck up to last 
character 
str--
; 
ret urn *str; 
25. Most comp ilers will print "not equa l". Some compile rs store only one copy of 
each literal string: such compi lers will print "eq ual" because all copies of "a" will 
be stored at the same address . 
27. abrasion 

Answers to Odd-Numbe red Review Questions 
1215 
29. A) This is probably a logic error because C-strings should not be compared with 
the == operato r 
B) atoi converts a string to an integer, not an integer to a string. 
C) The compiler will not allocate enough space in stri ng1 to accommodate both 
strings. 
D) strcmp compares C-strings, not characters . 
Chapter 13 
1. file name 
3. close 
5. i fstream,ofstream, 
fstream 
7. i fstream 
9. ofstream 
people("people.dat"); 
11. fstream places("places
.dat"); 
13. pets.open
(" pets.dat", 
ios:: in); 
fstream pets("pets
.dat", 
ios: :i n); 
15. null or 0 
17. cout 
19. getl i ne 
21. put 
23. text, ASCII text 
25. structures 
27. read 
29. sequential 
31. seekg 
33. tellg 
35. io s: :beg 
37. io s: :cur 
39. Open the file in binary mode, seek to the end, and then call tellg to determine the 
position of the last byte: 
if stream 
inFi7e(fi7eName, 
ios: :binary); 
inFile.seekg(OL, 
ios::end); 
long 
Jen = inFi7e. 
te77g (); 
41. Open the two files in binary mode, the first file for input and the second file for 
output. Seek to the end of the first file, and then keep backing up in the first file 
while writing to the second. 
fstream 
inFi7e(fi7e1name, 
ios::in 
I ios::binary); 
fstream 
outFi7e(fi7e2name, 
ios: :out 
I ios: :binary); 

1216 
Appendix D 
Answers to Odd-Numbered Review Questions 
char ch; 
II seek to end of source 
fi1e 
II and then position 
just 
before 
that 
1ast 
II character 
inFiJe.seekg{OL, 
ios::end); 
inFiJe. seekg{ - 1, ios: :cur); 
whiJe (true) 
{ 
} 
II we are positioned 
before 
a character 
we need to read 
inFiJe.get{ch); 
outFi1e.put{ch); 
II back up two characters 
to skip the character 
just 
read 
II and go to the character 
before 
it. 
inFi Je. seekg( -2, ios: :cur); 
if {inFi7e.fai7()) 
break; 
43. A) File should be opened as 
fstream f i le("info.dat", 
ios: :in 
I i os: :out); 
or 
fstream f i le; 
file.open("info.dat", 
i os:: in I ios: :out); 
B) Should not specify i os: : in with an ofst ream object. Also, the if statement 
should read 
if ( !File) 
C) File access flags must be specified with fstream objects. 
D) Should not write to a file opened for input . Also, the << operator should not 
be used on binary files. 
E) The while statement should read 
while(!dataFile.eof()) 
F) The input stream member function get that takes a single parameter requires 
a single character parameter . There is a version of get that reads a string of 
characters, but that function should be avoided. Use the global getl i ne func-
tion if you need to read a string. 
G) The get member function that takes a single parameter cannot be used to 
read a string: it can only read single characters . 
H ) The file access flag should be i os: : i n. Also, the put member function cannot 
be used to write a string. 
I) The file access flag should be i os: : out. Also, the last line should read 
dataF i le .write(&dt, 
sizeof(date)); 
J) The seekp member function should not be used since the file is opened for input. 
Chapter 14 
1. Indirect recursion. There are more function calls to keep up with. 
3. When the problem is more easily solved with recursion, and the recursive calls do 
not repeatedly solve the same subproblems. 

Answers to Odd-Numbe red Review Questions 
1217 
5. direct 
7. A) 55 
B) ********** 
,.,. 
,. 
C) evE dna madA 
Chapter 15 
1. abstract class 
3. abstract 
5. compile 
7. polymorphism 
9. Inheritance 
11. Inheritance 
13. final . 
15. yes 
17. yes 
19. pAnimal = new Dog; pDog = stat ic_c ast<Dog *>(pAnimal); 
21. A pure virtual function cannot have a body, and the function myFun has no return 
type. 
Chapter 16 
1. throw point 
3. catch 
5. template prefix 
7. vector, list, or any sequence container 
9. iterators 
11. This solution uses recursion to perform the reversal. It needs the inclusion of the 
STL algorithm header file to allow use of swap. 
template<class 
T> 
void reverse(T 
arr[ 
J, i nt size) 

1218 
Appendix D 
Answers to Odd-Numbered Review Questions 
{ 
if 
(s iz e>= 
2) 
{ swap (ar r [O] , arr[size-
1] ); 
reverse
(a rr+ 1, size-2
); 
} 
} 
13. Th e stiring of characters sto red in the array will be reversed . 
15. A) Th e try block must appear before the catch block. 
B) Th e cout statement shou ld not appear between the try and catch blocks . 
C) Th e return statement should read return 
number * number; 
D) Th e type parameter, T, is not used . 
E) Th e type parameter, T2 is not used. 
F) Th e declaration sho uld read Si mpl eVector< i nt> array (25); 
G) Th e statement shou ld read cout << val ueSet [2] << endl; 
Chapter 17 
1. head pointer 
3. NULL or 0 
5. Inserting 
7. circular 
9. void printF i rst(L is tNode *ptr) 
{ 
} 
if 
(!p tr ) { cout << "Error"; 
exit (1);} 
cout << ptr->value
; 
11. double 
lastVal
ue(Lis tNode *ptr) 
{ 
} 
if 
(!p tr ) { cout << "Error"; 
exit (1);} 
if 
(pt r->next 
== NULL} 
return 
ptr - >value; 
else 
return 
lastValue
(ptr->next
); 
13. ListNode 
*Li stConcat(
ListNode 
*list
1, ListNode 
*list2
) 
{ 
} 
if 
(list1 
== NULL} 
return 
list2
; 
// Concatenate 
list2 
to end of list
1 
Lis tNode *pt r = list
1; 
whi l e (ptr - >next 
!= NULL) 
ptr = ptr ->ne xt; 
ptr -> next = list2
; 
ret urn l i st1; 
15. 56.4 
17. A) Th e pr i ntL is t function should have a return type of void. Also, the use of 
the head pointer to walk down the list destroys the list: use an auxi liary 
pointer initialized to head instead . 

Answers to Odd-Numbe red Review Questions 
1219 
B) Eventually the pointer p becomes NULL, at which time the attempt to access 
p- >next will result in an error. Replace the test p->next in the whi le loop 
with p. Also, the function fails to declare a return type of voi d. 
C) The function shou ld declare a return type of voi d. Also, the function uses p++ 
erroneously in place of p = p- >next when attempting to move to the next 
node in the list. 
D) Replace nodeptr->next 
= NULL; with delete 
nodeptr; 
Chapter 18 
1. Last In First Out 
3. A static stack has all its storage allocated at once, when the stack is created. A 
dynamic stack allocates storage for each element as it is added . Normally, static 
stacks use array -based implementations, whereas dynamic stacks use linked lists. 
5. It takes an existing container and implements a new interface on top of it to 
adapt it to a different use. 
7. First In First Out 
9. the front of the queue 
11. lists and deques 
13. 
Top of Stack 
19 
8 
Bottom of Stack 
15. Assuming a circular array buffer: 
10 I 
9 I 12 I 
rear 
front 
17. Use two stacks, a main stack and an auxiliary stack . The main stack will store all 
items that are currently enqueued. 
• To enqueue a new item, push it onto the main stack. 
• To dequeue an item, keep popping items from the main stack and pushing 
them onto the auxiliar y stack until the main stack is empty, then pop and store 
the top element from the auxiliary stack into some variable X. Now keep pop-
ping items from the aux iliary stack and pushing them back onto the main 
stack till the auxiliary stack is empty. Return the stored item X. 
• To check if the queue is empty, see if the main stack is empty. 
Chapter 19 
1. root node 
3. leaf node 

1220 
Appendix D 
Answers to Odd -Numbered Review Questions 
5. inorder, preorder, and postorder 
7. st ruc t TreeNode 
{ 
i nt value; 
TreeNode *lef t , *middle, 
*r i ght ; 
} ; 
9. To traverse a ternary tree in preorder, visit the root, then traverse the left, middle, 
and right subtrees . 
preorder(ternarytree) 
If 
(ternarytree 
!= NULL) 
visit 
the root 
preorder 
left 
subtree 
of ternarytree 
preorder 
middle subtree 
of ternarytree 
preorder 
right 
subtree 
of ternarytree 
End If 
End preorder 
11. We must decide whether to visit the root right after the traversal of the left sub-
tree or right after the traversal of the middle subtree. 
13. int 
largest(TreeNode 
*tree) 
Set a pointer 
p to the root node of tree 
While node at p has a right 
child 
Do 
Set p to the right 
child 
of the node at p 
End While 
return 
value in the node at p 
End largest 
15. int smallest(TreeNode 
*tree) 
Set a pointer 
p to the root node of tree 
While node at p has a left 
child 
Do 
Set p to the left 
child 
of the node at p 
End While 
return 
value in the node at p 
End sma 11 est 
17. 3 7 9 10 12 14 18 20 22 24 30 
19. 3 10 9 7 14 20 18 30 24 22 12 

Symbols and Numerics 
# (preprocessor directive symbol), 11, 
28, 30. See also preprocessor 
directives 
% (modulus operator), 62-63 
%= See combined assignment 
operators 
& (address operator), 645-647 
& (reference variable), 368- 369 
&& (logical AND operator), 189- 191 
• (indirection operator), 647 
• (multiplication operator), 15, 
62- 63 
• (pointer variab le), 647 
+ (addition operator), 62-63 
+ (string concatenation operator), 
123- 124 
++ (increment operator), 253- 257 
+= See combined assignment 
operators 
( ) , parentheses, 29, 30, 86- 88 
: : (scope resolution operator), 417 
; (semicolon), 30 
< (less than relational operator), 156 
<= (less than or equal to relationa l 
operator), 156- 157 
<> (header file brackets), 28 
« {stream insertion operator), 32 
= (assignment operator), 15, 38, 167 
== (equal to relational operator), 
156- 157, 167 
{} (braces), 29- 30 
. (dot operator), 415 
I (forward slash) 
I (division operator), 62-63 
It (single-line comment), 28, 30, 66 
I= See combined assignment 
operators 
1 • • 1 (multi-line comment), 66-67 
[) (array subscript), 509- 510 
[ J (size declarator) , 124-125, 
508- 510 
I (escape sequence), 34- 36 
10 (null terminator), 54 
- (negation operator), 62 
- (subtractio n operator), 62- 63 
-> (structure pointer operator), 
680-681,684 
-- (decrement operator), 253-257 
~ See combined assignment operators 
· · (character literal symbol), 52 
• " (string literal symbol), 29, 30, 40 
> (greater than relationa l operator), 
156 
>= (greater than or equal to relational 
operator), 156-157 
» (stream extraction operator), 78-79 
! (logical NOT operator), 189, 
193- 194 
! = (not equa l to relational operator), 
156- 157 
? : (conditional operator), 209-212 
- (destructor), 429 
I (pipe operator), 893 
11 (logical OR operator), 189, 
191- 193 
11! (factoria l notation), 922 
20 (two-dimensional) arrays, 
553- 559 
30 (three-dimensional) arra ys, 
560-562. See also arrays 
A 
la (alarm escape sequence), 35 
abs function, 130-131 
abstract class, 963 
abstract data type (ADT), 407-408 
abstract function, 963 
abstraction, 407-4 08 
access specification 
base class, 784, 787, 790- 791 
members of base class versus 
derived class, 790-791 
private, 783- 784, 790 
protected, 787- 790 
public, 783-784, 790 
access specifiers, 413 
accessors (get functions), 416,419 
accumulator, 260- 263 
Ackermann's function, 94 7 
actua l arguments, 335 
actua l parameters, 335 
addition operator(+), 62-63 
address operator(&), 645- 647 
address. See also pointers 
defined, 5, 645 
operator (&), 645- 64 7 
memory allocation, 646 
AOT. See abstract data type 
Advanced Software Enterprises case 
study, 842- 843 
aggregation 
composition and, 779- 781 
defined, 776 
has-a relation, 776, 781 
object lifetime and, 779- 781 
through pointers, 778- 779 
algorithm header file, 931, 1003 
algorithms. See also ana lysis of 
algorithms 
defined, 8, 627 
recursive functions for, 927- 932 
search, See search algorithms 
sorting, See sorting algorithms 
Standard Temp late Library (Sil), 
1022- 1029 
ALU (arithmetic and logic unit), 4 
American Standard Code for 
Information Interchange. 
See ASCII 
ampersand (&) 
address operator, 645- 647 
reference variab le, 368- 369 
analysis of algorithms, 627-634 
basic step, 628 
big O notation, 632-634 
1221 

1222 
Index 
ana lysis of algorithms (continued) 
comp lexity of, 629-634 
computational problems, 62 7-629 
efficiency of, 627, 630, 633 
introduction to, 627 
space and time criteria, 627 
AND logical operator(&&), 189- 191 
defined, 189 
precedence of, 196 
short circuit evaluation, 190 
truth table, 190 
app lication frameworks, 974- 976 
app lication software, 7 
arguments 
actua l, 335 
defau lt, 364- 367 
defined,88,333 
formal, 335 
library functions, used with 
88- 89 
parameters as variab les for, 
333- 335 
passing arrays as, 543- 549 
passing by reference, 368- 376 
passing by value, 338- 340 
passing C-strings as, 820, 
837- 839 
passing objects as, 435-441 
passing structures as, 462-463 
passing to base class constructors, 
794- 796 
pointers as, 661-665 
arithmetic and logic unit (ALU), 4 
arithmetic operators 
assignment operators combined 
with, 105 
associativity, 87 
binary, 62- 63, 86 
introduction to, 62-65 
overloading, 738- 741 
precedence of, 85- 86 
table of, 62 
unary, 62, 86 
array subscript operator ( [ I) 
accessing array elements with, 
509- 510 
overloading, 747- 750 
two-dimensional arrays, used 
with, 553 
vectors, used with, 564 
arrays, 507-602 
accessing elements, 509- 511 
assignment statements for, 
510- 511, 518- 524 
bounds checking, lack of, 515-517 
brace notation ( { } ) for, 524 
C-strings, used to store, 124- 125, 
817- 818 
circular, 1102 
comparing, 530-531 
const function parameters, 549 
copying one to another, 530 
defined, 507 
displaying contents of, 511- 517 
elements in, 508- 511 
finding average value in, 549- 551 
finding highest or lowest value in, 
549- 551 
function argument, as, 543- 549 
function parameter, as, 544- 545 
implicit sizing, 524 
initialization, 518- 524, 555- 556 
inputting data, 511- 517 
linked list, compared to, 
1037- 1038 
memory requirements, 508- 509 
of objects, 575- 580 
off-by-one error, 517 
parallel, 539- 541 
partial initialization, 522- 523 
partially filled, 522- 523, 534-535 
passed as arguments to functions, 
543- 551,556 - 558 
pointers and, 651-655 
processing contents of, 528- 538, 
553- 555 
range-based for loop, used with, 
525- 528 
reading data from a file into, 
513- 514 
searching for an element in, 
610-612 
size declarator ( [ J ), 508- 510 
sorting data in, 621-624 
string processing, 538- 539 
of structures, 581- 584 
subscript, 5 09- 510 
summing values in, 531- 532 
three-dimensiona l (3DJ, 560-562 
two-dimensional (2D), 553- 559 
typedef statement used with, 543 
unique pointers to, 689 
use of and reasons for, 535- 537 
vectors and, 563- 574 
writing contents of to a file, 514 
ASCII (American Standard Code for 
Information Interchange) 
character encoding and storage, 
52- 54 
character set table, 1155- 1157 
character values, 203 
assignment operator(=), 15, 38, 
59-60, 84 
equality(==) versus, 167 
move, 753- 761 
overloading, 730- 736 
assignment statement, 37- 38 
arithmetic operators in, 105 
combined operators in, 102- 105 
initialization versus, 59-60 
!value, 60 
multiple, 102 
operands, 59- 60 
rvalue, 60 
associative containers, 564, 1016-1017. 
See also containers 
associativity 
of arithmetic operators, 87 
of the assignment operator 
of logical operators, 196 
of relationa l operators, 156 
asymptotic comp lexity, 632-634 
attributes 
class, 476-477 
defined, 409,476 
object, 409 
structure, 4 5 9 
auto key word, 61 
average-case comp lexity, 632 
B 
lb (backspace escape sequence), 35 
backslash (1), 35 
backslashes ( 11 ), 35, 290 
bad_alloc exception, 997 
base case, 918, 920 
base class 
abstract, 693-695 
access specification, 784, 787, 
790-791 
constructors, 792- 796 
defined, 782 
derived class members versus, 
790-791 
destructor , 792- 794 
inheritance, 782- 784, 963 
overriding functions, 797- 800 
passing arguments to 
constructors, 794- 796 
pointers, 950-955 
protected members 787- 790 
type casting pointers, 953- 955 
virtual functions, 693-695 
basic step, 628 
big O notation, 632-634 
binary digits (bits), 5 
binary files, 287, 877- 881 
binary numbers, 8 
binary operators, 62-63, 86 
binary predicate, 762 
binary search 606-609 
efficiency of, 609 
recursive functions for, 92 7- 928 
worst -case comp lexity, 630-631 

binary search trees 
concept of, 1129 
creating, 1129- 1132 
defined, 1126- 1127 
deleting elements, 1137- 1139 
inorder traversal, 1133-1135 
inserting elements, 1132- 1133 
operations, 1129- 1132 
postorder traversal, 1133- 1135 
preorder traversa l, 1133- 1135 
removing elements, 1136-1145 
searching, 1135- 1136 
templates, 1145 
binary trees, 1125- 1128. See also 
binary search ere.es 
app lications of, 1126- 1128 
defined, 1125 
genealogy trees as, 1145- 1149 
implementation of, 1126 
linked list versus, 1125 
subtre.es, 1126 
terminology, 1125 
binding functions, 960 
bit flag, 861- 864 
bit patterns, 44 
bit (binary digit), 5 
block, defined, 163 
block (local) scope, 201 
body 
of a block, 200-201 
of a function, 324- 326 
of a loop, 244-245 
of an if statement, 163 
bool data type, 57- 58 
Boole, George, 57 
Boolean expressions, 57- 58, 156 
Boolean value, returning from a 
function, 349- 351. 
Boolean variables, 57- 58, 195- 196 
bounds checking. See arrays 
braces ( { } ), 29- 30 
alignment in code, 68 
in array initialization, 524 
in conditional statements, 164, 166 
in loops, 244, 24 7 
placement error, 166,247 
branching. See decision structures 
break statement 
in a loop, 281- 283 
in a nested, 282-283 
in a switc h statement, 214-215 
bubble sort, 613-617, 634 
buffer 
file, 290 
flushing, 84 5, 860 
keyboard (input), 79- 82 
overrun, 12 7 
business operations software, 286 
byte, 5 
C 
C++ programming language 
data types, 43- 55, 57- 59 
identifiers, 41--42 
key words, 14-15, 41 
program parts 27- 31 
portability, 11 
C-strings 
assigning a value to, 126 
buffer overrun, 12 7 
characters in, 815- 820 
comparing, 822- 823 
converting st ri ng objects to, 297 
defined, 124, 815 
displaying, 125 
functions, writing, 833- 839 
library functions, 820-827 
memory allocation, 127- 128 
null terminator (\0), 297, 538 
pointers to char, 816, 819- 820 
reading input, 129 
size declarator ( [ J ), 124- 125 
storage, 5 38 
versus st ri ng object, 815 
string literals (constants), 
816- 817 
calling functions. See function call 
capture clause, 769 
case sensitivity, 29 
case statement, 213- 214 
case studies 
Advanced Software Enterprises, 
842- 843 
Centra l Mountain Credit Union, 
304- 308 
Crazy Al's Computer Emporium, 
231 
Creating an Abstract Array Data 
Type, 587, 635 
Demetris Leadership Center, 635 
General Crates, Inc., 141 
Green Fields Landscaping, 
138- 141, 227- 231 
High Adventure Travel Agency, 
391 
Home Software Company, 
469--475 
Lightening Lanes, 308 
Little Lotto, 387- 391 
Nationa l Commerce Bank, 
585- 586 
Online Friendship Connections, 
898- 903 
Reliable Software Systems, Inc., 
1071- 1074 
Set Intersection, 5 87 
cast. See typecast expressions 
catch block, 988 
cctype header file, 207- 208 
Index 
CD (compact disc), 6 
cell, 487 
cell coordinates, 487 
Centra l Mountain Credit Union case 
study, 304- 308 
centra l processing unit (CPU), 3--4 
char data type, 52- 55 
characters 
ASCII, 52- 54, 203-204 
Cstrings, 815- 820 
comparing with relationa l 
operators, 203- 205 
character testing functions, 
195- 196,207 - 208 
data types, 43, 52- 55 
functions for strings and, 116- 129 
inputting, 119- 123 
litera ls, 52 
memory storage, 52- 53 
single quotes (' ') for, 52 
string literals versus, 53- 55 
testing functions, 207- 208 
whitespace, 117- 119 
working with, 116- 117 
cin object 
Cstring input, 125- 129 
ci n member functions, 119- 122, 
127- 129 
defined, 77 
entering multiple values, 80-83 
input operations, 17, 77- 83 
inputting characters, 119 
inputting strings, 117- 119 
keyboard (input) buffer, 79- 82 
prompt for, 78 
reading input, 77- 80 
stream extraction operator(»), 
78- 79, 117 
whitespace characters and, 
117- 119 
cin.g et function, 119- 122 
c in. get 1 i ne function, 129 
cin. ignor e function, 122 
cin.wid th() function, 127- 128 
circular arrays, 1102 
circular linked list, 1068 
class 
abstract, 963 
access specifiers, 413, 787, 
790-791 
aggregation, 776, 778- 781 
attributes, 476--477 
base, 782- 800 
behaviors, 4 77 
client program/code, 446, 
449--450 
composition, 779- 781 
constructors, 423--429, 773- 776, 
792- 796 
1223 

1224 
Index 
class (rontim,e d) 
convert constructors, 773- 776 
C++ use of, 56-57, 411-413 
creating, 412 
declaration, 412,414, 446-447, 
453-454, 470-471 
defined, 411 
derived, 782- 784, 790- 800 
destructor, 429-430, 792- 794 
dynamic, 1093-1096, 1106- 1109 
exception handling with, 
990- 992 
friends, 715- 719 
function objects, 761- 770 
has-a relationship, 776, 781 
identifiying, 476 , 479-482 
implementation (. cpp) files, 446, 
447-449 
implementing, 472-475 
inheritance, 782- 787, 792- 796 
instantiation, 414, 792- 796 
interface, 471-472 
is-a relationship, 782- 784 
lambda expressions, 761, 769-770 
member functions, 123- 124, 
411-412,416-423
, 446 , 
447-449 
member initialization lists, 
776- 778 
name, 412 
objects, See objects 
overview, 411 -4 12 
pointers to, 680-681 
pr iv ate members, 413, 
432-434,469 
protected members, 787- 791 
public members, 413,415,470 
relationships, 477 -4 78 
responsibilities, 482-4 85 
separate storage in files, 446-452 
specification file, 446-44 7 
static, 1087- 1091, 1103- 1106 
string , 56-57 , 123-124, 411-412 
type conversion operators, 
770- 772 
class template, 1007- 1015. See also 
function template 
concept of, 1007 
declaring, 1007- 1008 
exception to list type parameters, 
1009 
inheritance and, 1012- 1015 
member functions, 1008- 1009 
name, 1008 
type parameters, 1008 
c 1 ear () member function 
st ri ng class, 841 
vector class, 572, 574 
client program/code, 446, 449 -4 50 
close() function, 290 
cmath header file, 89, 130 
code 
alignment and indentation, 68, 
187- 188 
blocks of, 200-203 
combined assignment operators, 
102- 105 
c.01nments 
defined, 66 
multi-line {i • • i), 66-67 
single-line(/ i), 28, 66 
compact disc (CD), 6 
compi le-time errors, 21 
compi ler 
defined, 11 
default operation implementation, 
761 
dynamic binding, 960 
errors, 728 
functions, 67-68 
move operations for, 760 
static binding, 960 
compi ling process, 11 
complexity of algorithms, 629-634 
composition 
aggregation and, 776, 779- 781 
defined, 776 
has-a relationship, 781 
inheritance versus, 969- 973 
object, 442-445 
object lifetime and, 779- 781 
computationa l prob lems, 627- 629 
computer 
hardware, 3-6 
software, 2, 6- 7 
systems, 3- 7 
uses of, 1-2 
concatenation operator(+), 123- 124 
condition expressions, loops, 244 
conditiona l execution, 161- 164. See 
also decision structures 
conditiona l expression, 209- 212 
conditiona l operator{? : ), 209 - 212 
console 
cin object, 77 
cout object, 31 
defined, 31 
input, 77 
output, 31 
const array parameter, 549 
const key word, 100-101 , 438 -4 39, 
549, 706- 707 
const pointers, 665-670 
constant member functions, 706-708 
constant reference parameters, 
438-439 
constant time, 634 
constant variable, See named 
constant 
constants. See also literals; named 
constants; strings 
global, 358- 361 
passing argument into a pointer 
to, 667-668 
pointers to, 665-666 
pointers, 668-670 
constructor 
base class, 792- 796 
class, 423-429 
convert, 741, 773- 776 
copy, 721- 729 
default, 426, 428-429, 761 
defined, 423 
inheritance and, 792- 796 
initialization list and 777- 778 
move, 753- 760 
naming, 423 
overloading, 426-428 
passing arguments to, 794-796 
structures, 457-458 
container adapter, 1097 
containers. See also Standard 
Template Library (STL) 
adapters, 1097, 1111 
associative, 564, 1016- 1017 
defined, 1016 
deque, 1016, 1097, 1109- 1111 
linked lists and, 1068- 1070 
list, 1016, 1068- 1070, 1097 
map, 1017 
mult il i st , 1017 
mult imap, 1017 
queue, 1109, 1111- 1112 
sequentia l, 564, 1016 
set, 1017 
stack, 1097- 1098 
vecto r, 1016, 1020-1021, 
1097- 1098 
cont inue statement, 283-284 
control structures. See decision 
structures; loops 
control unit, 4 
control variab le, 246 
conversion 
algebraic expressions to C++, 
87- 90 
data type, 92- 97 
floating-point to integer, 51 
number to strings 40 
type casting, 94- 97 
type coercion, 9 3 
type conversion operators, 
770-772 
convert constructor, 741, 773- 776 

copy constructor, 721- 729 
count -controlled loops, 271- 273 
counter 
defined, 258 
for loop, 271- 273 
whil eloop,258 - 260 
cout object 
console output, 31 
formatted output and, 106- 116 
<iost ream> header ftle and, 28, 36 
output, 17- 18, 31- 36, 117 
stream insertion operator(«), 
29, 32, 79 
stream objects, 29, 31- 34 
. cpp (class implementation ) files, 
446, 447-449 
CPU (central processing unit), 3-4 
Crazy Al's Computer Emporium case 
study, 231 
Creating an Abstract Array Data 
Type case study, 587, 635 
cstdl i b header file, 133, 383 
cst ri ng header file, 820 
ct ime header file, 134-135 
cursor positioning, 486-489 
D 
dangling pointer, 672-674 
data abstraction, 407-4 08 
data hiding, 410 
data types 
abstract (ADT), 407-408 
bool, 57- 58 
char, 52- 55 
character, 43, 52- 55 
conversion, 92- 97 
defined, 43 
demoted values, 9 3 
doub 1 e, 49- 50 
doub le-precision, 49 
enumerated, 222- 225, 465-469 
fl oat, 49- 50 
floating-point, 43, 48- 51 
fst ream, 289 
ifstream,289 - 290 
i nt, 44-46 
integer, 43-48 
l ong int, 44-47 
l ong double, 49 
l ong long int, 47 
numeric, 43 
ofstream, 289, 290-293 
programmer -defined, 563- 564 
promoted values, 93 
selection of, 43-44 
short int, 44 
size of, 44, 58- 59 
st ri ng class used as, 56- 57 
unsig ned int , 44-45, 93 
unsig ned long i nt , 44-45, 93 
unsig ned long long i nt, 44-45 
unsig ned short int , 44-45 
debugging 
creating good resr data, 301- 303 
hand tracing a program, 136-138 
validating output results, 
225- 227 
decimal notation, 48, 50, 112 
decision structures, 161- 181, 
185- 188,213 -220 
defined, 161 
if statement, 161- 169 
if/else 
if statement, 175- 181 
if/else statement, 170-174 
nested, 185- 188 
switc h statement, 213-220 
declaration 
class, 412, 470-471 
structure, 453-454 
decrement operator(--) 
defined, 253 
prefix/postfix modes, 254- 25 6 
decryption, 973- 976 
defau lt arguments, 364- 367 
#defi ne directive, 447 
definition. See function definition; 
variab le definition 
delete operator, 672- 674, 676-678 
Demetris Leadership Center case 
study, 635 
deque container, 1016 
dequeue operations, 1099- 1101 
dereferencing a pointer, 649 
derived class, 782- 784 
base class members verst1s, 
790-791 
constructors, 792- 796 
defined, 782 
destructor, 792- 794 
inheritance specialization and, 
782- 784 
member functions, 783-784, 790 
overriding base class member 
functions, 797- 799 
pointers, 950- 953 
deserializing an object, 899 
design 
object-oriented, 476-485 
program, 2, 18- 22 
rop-down, 19 
desk-checking, 21-22 
destructor, 429-430 
base class, 792- 794 
defined, 429 
derived class, 792- 794 
inheritance and, 792- 794 
linked lists, 1046 
tilde character(-) for, 429 
digital versatile disc (DVD), 6 
direct access files, 287. See also 
random access files 
direct recursion, 921 
Index 
directives. See preprocessor directives 
disk drive, 5-6 
divide and conquer approach, 
323- 324 
divide-by-zero error, 242- 243 
division operator (t), 62-63. See also 
integer division 
do-while loop. See also loops 
defined, 243, 265 
flowchart, 265 
format, 265 
iteration, 266 
menu selection using, 268- 2 70 
as post-resr loop, 265- 267 
termination, 265 
when ro use, 278 
whi 1 e use versus, 265 
. doc extension, 288 
dot operator (. ), 415 
double data type. See data types, 
floating-point data types 
doubly linked list, 1067- 1068 
driver, 385- 387 
dummy function, 385 
dummy name, 339 
dummy parameter, 743 
DVD (digital versatile disc), 6 
dynamic binding, 960 
dynamic memory allocation 
class objects, 681-682 
dangling pointers, 672-674 
defined, 670 
memory leaks, 672-674, 
676-678 
ownership of, 686 
returning a pointer from a 
function, 674-676 
throwing an exception, 671- 672 
smart pointers for, 686-694 
dynamic queues, 1099, 1106-1109 
dynamic stacks, 1086, 109 3-1096 
E 
£ notation, 48, 50 
element. See arra ys 
else, 171 
trailing, 180-181 
empty member function, 572- 573 
1 i st container, 1068 
stack container, 1097 
stri ng class, 841 
vecto r class, 572- 574, 1020 
1225 

1226 
Index 
encapsulation, 409 
encryption, 973- 976 
end of file (EOF), 297- 299 
#endif directive, 447 
endl stream manipu lator, 33-34 
enqueue operations, 1099- 1101 
[Enter] key, 81 
enum class, 467-469 
enum statement, 222, 465-466 
enumerated data types, 222- 225, 
465-469 
declaration, 222 
defined, 222 
loop contro l using, 467 
output values using, 466-467 
purposes of, 223 
strongly typed, 467-469 
symbolic names, 222-223 
values, 222-223 
enumeration algorithm, 936- 940 
equal to relationa l operator ( == ), 
156- 157 
overloading, 738 
verslls assignment(=) confusion, 
167,247 
error. See also debugging 
bit flags for, 861- 864 
buffer overrun, 127 
compile-time, 21 
correcting, 21 
desk-checking for, 21- 22 
doub le deletion, 686 
exceptions testing for, 987- 988 
file open, 299- 300 
flags, 856 
infinite loop, 246- 247 
logical, 21 
memory leak, 672-674, 
676-678,686 
off-by-one, 517 
pointer, 672-674, 686,693 
round -off, 173- 174 
run-time, 21, 1049 
syntax, 11 
testing for stream conditions, 
861- 864 
throwing exceptions, 988, 
1088- 1089, 1092- 1093 
escape sequences (1), 34-36 
exception class, 991 
exceptions 
bad_alloc, 997 
catch block, 988 
class members, 994- 996 
defau lt action, 672 
defined, 671- 672, 987 
dynamic memory allocation, 
671-672 
handling, 988- 994, 997, 
1091- 1093 
multiple, 992- 994 
object-oriented handling with 
classes, 990-992 
overflow, 1088- 1089, 1092, 
1105- 1106 
queues, 1105- 1106 
rethrowing, 998- 999 
stacks, 1088- 1089, 1091- 1093 
throw statement, 988 
throwing, 671, 988, 997 
t ry block, 988- 989, 998 
try/catch construct, 988- 990 
uncaught, 990 
underflow, 1088- 1089, 
1092- 1093, 1105- 1106 
unwinding the stack, 997- 998 
executab le code, 11- 12 
executab le file, 11, 21 
exhaustive algorithm, 936- 940 
exit function, 382- 383 
expression 
F 
algebraic, 87- 90 
Boolean, 57- 58, 156 
case statement, 213- 214 
conditiona l, 209- 212 
converting postfix to infix, 
1117- 1119 
defined, 84 
initialization, 271- 272, 274- 276 
mathematical, 84- 90. See also 
arithmetic operators 
relational, 156- 160 
test, 271-272, 274 
type cast, 94-97 
update, 271- 272, 274, 275- 276 
factori a 1 function, 922- 924 
factoria l notation {n!), 922 
false condition 
interna l representation, 158 
false key word, 57- 58 
fetch/decode/execute cycle, 4 
Fibonacci numbers, 925- 926 
Fibonacci sequence, 925- 926 
field 
defined, 881 
key, 610 
field width. See also 1/0 
manipulators 
cin object for, 127- 128 
defined, 107 
for input, 107, 127- 128 
for output, 107, 112 
setw stream manipulator for, 
107- 109 
file access methods 
random, 287 
sequentia l, 287 
file buffer, 290 
file error flags 
ios:: badbit, 862 
ios:: eofbit, 862 
ios::fa ilb it, 862 
ios: goodbit, 862 
ios: :hardfail , 862 
file name extensions, 288 
file names, 288, 296-297 
file open modes 
ios:: app, 856 
ios:: ate, 856 
ios:: bi nary, 856 
ios:: i n, 856 
ios:: out, 856 
ios:: trunc, 856 
file positioning modes, 
ios:: beg, 888 
ios:: cur, 888 
ios:: end, 888 
file stream objects, 288, 
289-290, 297. 
See also fst ream class; i fst ream 
class; of stream class 
files 
access methods, See file access 
methods 
advantages of multiple, 451-452 
binary, See binary files 
class implementation (.cpp) files, 
446, 447-449 
class specification files, 446-44 7 
client code for, 446, 449-450 
closing, 290 
.cpp,446,447-449 
data storage, 285- 300 
direct access, 287 
end of file (EOF) detection, 
297- 299 
error flags, See file error flags 
executable, 11, 21 
.h, 446 
header, See header files 
1/0 operations, 853-914 
1/0 stream classes, 854- 856, See 
also I/0 stream member 
functions 
input, 286 
ios flags, 887- 888 
iostream, 28- 29, 449 
multi-file projects, 446,451 
naming, See file names 
open error testing, 299- 300 
open modes, See file open modes 
opening, 289-290, 893- 898 

output, 286 
passing to functions, 374-376 
positioning modes, See file 
positioning modes 
processing, loops and, 285- 300 
purpose of, 285-286 
random access, See random 
access files 
read position, 29 5- 296 
reading data from, 286-287, 
294- 297 
rewinding, 873- 875 
seek operations, 887- 891 
sequential access, 28 7 
source code, 12, 21 
stream object, 288- 290 
text, 287 
types of, 287 
writing data to, 286, 290-293 
fill character, 860 
f i na 1 key word, 961- 962 
first-in-first-out (FIFO) order, 1099 
fixed-point notation, 48, 50, 112 
flags 
bit, 862- 864 
file open modes, 856 
file positioning, 887- 888 
state bits that act as, 861- 862 
flash memory, 6 
fl oat . See data types; floating-point 
data types 
floating-point. See also floating-point 
numbers 
arguments, 88 
assigned to integer variable, 51 
data types, 43, 48- 51 
doub le-precision, 49 
E notation representation, 48, 50 
1/0 manipulators used with, 
109- 111, 116 
literals (constants), 50 
output, 109- 111 
representations, 48-50 
single-precision, 49 
floating-point numbers 
comparing, 173- 174 
defined, 48 
flowchart, 19- 20 
for loop. See also loops 
defined, 24 3, 2 71 
format, 272 
flowchart, 272 
header, 271- 272 
initialization expression, 
271- 272, 274-276 
omitting expressions or body 
of, 276 
pretest -loop process, 274 
range-based, 525- 528 
situations for use of, 278 
test expression, 271- 272, 274 
update expression, 271- 272, 274, 
275- 276 
formal arguments, 335 
formal parameters, 335 
formatting 
defined, 106 
I/0 streams, 107- 116, 857- 860 
number to string conversion, 878 
output, 106- 116, 119- 114, 
857- 860 
freeing memory, 672 
friend classes, 715- 719 
friend functions, 715- 719, 1116 
fstream class 
constructor, 854, 857 
getli ne function, 866 
member functions, 854, 869, 873, 
879- 880 
open member functions, 854, 893 
fstream header file, 289, 85~55, 
893 
function call. See also functions 
arguments, 333-338 
defined, 324, 326 
syntax, 338 
value-returning functions, 
345- 348 
function definition 
body,32 4- 325 
class member functions, 416--422 
defined, 324 
inline functions, 417 
name, 324-325 
parameter list, 324- 325 
return type, 324- 325, 344 
scope resolution operator (: : ), 417 
value-returning functions, 
344- 345 
function header, 325, 326 
function objects, 761- 770 
function prototype, 327, 332- 333 
function signature, 379 
function templates, 999- 1007 
algorithm header file, 1003 
concept of, 999 
declaring, 999- 1001 
defining, 1006- 1007 
multiple types in, 1005 
operators in, 1004-1005 
overloading, 1005- 1006 
template prefix, 1000 
type parameters, 999 
functiona l notation, 96- 97, 524 
functions. See also member functions 
abstract, 963 
arguments, 333-338, 364- 367 
G 
Index 
arra ys passed as arguments to, 
543- 551,556-558 
body of, 324-325 
binding, 960 
calling, See function call 
C++ runtime library, 130- 132 
data values sent into, 333- 338 
default arguments, 364-367 
defined, 29 
defining, See function definition 
friend, 715- 719, 1116 
header, 325 
inline, 417 
library, See library functions 
local variab les, 355- 356, 
361- 363 
main,29 - 30,325 - 327,333 
in menu-driven programs, 
351- 354 
modular programming, 323- 324 
name, 324- 325 
overloading, 378- 382 
overriding, 797- 800, 961- 962 
parameters, 333- 340, 364- 376 
passing arguments by reference, 
372- 373,438 -4 39 
passing arguments by value, 
338- 340,435 -4 38 
passing arra ys to, 
passing files to, 
passing objects to, 435--441 
passing two-dimensiona l (2DJ 
arrays to, 556-558 
pointer parameters, 661- 665, 
682-684 
prototypes, 327, 332- 333 
pure, 963- 965 
recursive, See recursive 
algorithms; recursive 
functions 
return statement, 342- 343 
return type, 324- 325, 344 
returning objects from, 439--441 
returning pointers from, 674-678 
returning values from, 342- 343 
signature, 379 
static local variab les defined in, 
362- 363 
static member, 711- 714 
stub 385- 387 
value-returning, 343- 351 
virtual, 955- 962 
void, 325 
gcd (greatest common divisor) 
function, 924- 925 
General Crates, Inc., case study 141 
1227 

1228 
Index 
get functions (accessors), 416,419 
getline function, 118- 119, 
866- 869 
global constants, 358- 361 
global variab les. See also variab les 
defined, 355 
initialized to zero, 357 
prob lems using, 358 
with same name, 361- 362 
greater than or equal to relationa l 
operator(>=), 156- 157 
greater than relational operator(>), 
156 
greatest common divisor (gcd) 
function, 924-925 
greedy strategy, 937 
Green Fields Landscaping case study, 
138- 141, 227- 231 
H 
. h files, 446 
hand tracing a program, 136- 138 
hand le creation, 486 
handling exceptions. See exceptions 
hardware 
components, 3 
CPU, 3-4 
input devices, 6 
main memory, 5 
output devices, 6 
secondary storage, 5-6 
has-a relationship, 776, 781 
header files 
algor ith m,931, 1003 
brackets ( < >) for, 28, 30, 
449,564 
cctype, 207- 208 
cmath, 89, 130 
cstd l ib, 133,383 
cst ri ng, 820 
ct ime, 134- 135 
current project directory(" "), 449 
defined, 28 
fst ream, 289, 853-855 
. h, 446 
ifstream,289 - 290,853 - 855 
#inc 1 ude directive, 36 
include guard for, 447 
iomanip, 108, 110 
i ostream, 28, 29, 36, 77, 80 
ofstream, 289, 290-293, 
853- 855 
preprocessor directives and, 
28,449 
st ri ng, 56,411 
vector, 564 
heap, 671 
hexadecima l integer literals, 47 
hierarchical (layered) function calls, 
330-331 
hierarchy chart, 19- 20 
High Adventure Travel Agency case 
study, 391 
high-level programming language, 
9- 11 
high-order bit, 98 
Home Software Company case study, 
469-475 
I 
1/0 (input/output) See also input; 
output 
manipulators, 33- 34, 108- 116 
1/0 stream. See also files 
1/0 stream member functions 
get, 869- 871 
get 1 i ne, 866-869 
peek, 871- 873 
put, 873 
IDE (integrated development 
environment), 12- 13 
identifier 
defined, 41 
legal names, 42 
if statement 
conditional execution of, 161- 164 
defined, 161 
flowchart, 161- 162 
format, 162 
if /el se statement versus, 171- 173 
nested, 185- 188 
programming style and, 164-165 
if/e l se statement 
defined, 170 
flowchart, 170 
format, 170 
if statement versus, 171- 173 
nested, 185- 188 
if/e l se if statement, 175- 181 
defined, 175 
flowchart, 176 
format, 176 
trai ling el se, 180-181 
#ifndef directive, 44 7 
i fstream class, 289- 290, 853- 855 
image maps, 1074-1080 
implementation file, class (. cpp), 
446, 447-449 
#inc 1 ude directive, 28, 36 
in multi-fileprograms, 446-449 
include file directory( < >), 449 
include guard, 44 7 
increment operator(++) 
defined, 253 
in mathematical expressions, 
256- 257 
num++ contro l variab le, 253, 
255-256 
pointers using, 656 
prefix/postfix modes, 254-256 
in relationa l expressions, 257 
indirect recursion, 921 
indirection operator(•), 647-650, 
663,680-681 
infinite loops, 246- 247 
infix expressions, 941- 944 
converting postfix to, 1117- 1119 
inheritance 
base class 782- 784, 787, 790-791, 
794-796,953-955 
base class access specification, 
784, 787, 790-791 
class templates and, 1012- 1015 
composition versus, 969- 973 
constructors and, 792- 796 
defined for OOP, 782 
derived class, 782- 784 
desrructors and, 792- 794 
generalization and specialization 
of, 782 
hierarchies of, 949- 950 
is-a relationship, 782- 784 
multiple, 787 
passing arguments to 
constructors, 794- 796 
pointers, 785- 786, 953-955 
private members, 783- 784, 790 
protecte d members, 787- 790 
public members, 783- 784, 790 
superclasses and subclasses, 787 
type compatibility in, 949- 955 
virtua l functions, 957- 960, 963 
initialization 
arra y, 518- 524 
assignment versus, 730- 731 
brace notation ( { } ) for, 524 
constructors, with, 423-4 24, 
457-458 
copy constructors, with, 721- 722 
defined, 59 
global variab les set to zero, 357 
local variab le, 356 
member lists, with, 776- 778 
named constants, with, 100 
object, 423-424, 456-458 
partial arra y, 522- 523 
pointer, 656-658 
structure, 456-458 
two-dimensiona l (2DJ arra y, 
555- 556 
variab le, 60-61 
vector, 564-565 
initialization expression, See for loop 
initialization list, 456-457 

initialization value, 100 
inline member function, 417, 422 
inner loop, See loops 
inorder traversal, See binary 
search trees 
input 
characters, 119 
console, 77 
defined, 17 
devices, 6 
entering multiple values, 80-83 
keyboard buffer, 79- 82 
program data, 17 
reading data, 77- 80, 129, 
513- 514 
rest data, 21 
validation, See input validation 
input file, 286 
input/output (1/0). See I/0 
(input/output ) 
input-output stream library, 36 
input stream, 851 
input validation 
defined, 198 
while loop, with, 250-252 
i nputFil e object, 290, 294 
instance 
of a class, 414 
members, 704, 711 
instantiating a class, 414 
int. See data types; integer data types 
integer 
data types, 43-48 
literals, 39, 46-47 
size, 44 
values, 29, 43-48 
variables, 38, 45 
integer division, 63, 95 
integrated development environment 
(IDE), 12- 13 
iomani p header file, 108, 110 
ios class, 856, 874 
iostream header file, 28, 29, 36, 77, 80 
is-a relationship, 782- 784 
i st ri ngstream class, 829- 830, 853 
iteration. See also loops 
defined, 244 
recursion versus, 940 
stopping, 274, 281- 284 
iterators. See also Standard Template 
Library (STL) 
begin() , 1018- 1019 
defined, 1016 
end(), 1018- 1019 
pointer -like behavior, 1017, 1018 
types, 1017 
use of, 1018- 1019 
vector use of, 763 
J 
. j pg extension, 288 
justified output, 103- 109, 
114-115 
K 
key field, 610 
key words 
C++ list of, 41 
keyboard (input) buffer, 79- 82 
L 
lambda expressions, 761, 769- 770 
last-in-first-out (LIFO) structure, 
1085- 1086 
leaf node, 1125 
left-to-right associativity, 87, 156 
less than or equal to relationa l 
operator(<=), 156- 157 
less than relational operator(< ), 156 
library functions 
call to, 88 
C-string, 820- 82 7 
defined, 88 
mathematica l, 88- 90, 130-132 
numeric conversion, 829- 833 
pointer, 687-694 
return value of, 88- 89 
st rin g class, 815, 839- 842 
lifetime 
local variable, 356 
object, 779- 781 
Lightening Lanes case study, 308 
linear (sequentia l) search, 
603-606 , 634 
comp lexity of, 630 
inefficiency of, 606 
linear time, 634 
line, 15 
lines versus statements, 15- 16. 
linked list, 1037- 1084 
abstract data types (ADT), 
1037- 1043 
adding elements to, 104 5- 1046 
advantages of, 1037- 1038 
binary trees versus, 1125 
building, 1041 
choosing pointers, 1070 
circular variation, 1067- 1068 
constructor initialization, 
1040-1041 
C++ representation, 1038- 1040 
destroying, 1046- 1048 
displaying, 1046 
doubly linked variation, 
1067- 1068 
inserting nodes, 1049- 1052 
Index 
introduction , 1037- 1043 
1 i st container, 1068-1070 
member functions, 1062- 1069 
nodes, 1037, 1040- 1043, 
1049- 1052 
operations, 1043- 1055, 
1059- 1060 
pointers for, 1038- 1042, 
1044-1046, 1049- 1052 
recursion approach for, 
1059- 1060 
recursive functions for, 
1060-1067 
removing elements, 1052- 1055 
sorted order, 1048- 1049 
Standard Temp late Library (Sil), 
1068- 1070 
structure, 1038 
template, 1055- 1059 
traversing, 1041- 104 3 
linker, 11 
linking, 12, 21, 1058 
1 ist container , sn, 1016, 
1068- 1070 
literal. See also named constants; 
string literals 
character, 52- 55 
comparison of string and 
character, 53-55 
defined, 39 
floating-point, 50 
hexadecimal integer, 4 7 
integer, 39, 46-47 
named constant, 99- 102 
numeric, 39 
octal integer, 47 
string, 39-40 , 53- 55 
Little Lotto case study, 387- 391 
local variable 
defined, 355 
initializing with parameter 
values, 356 
lifetime, 356 
shadowing global variab le of the 
same name, 361- 362 
Static, 362- 363 
logarithmic time, 634 
logical error, 21 
logical operators , 189- 197 
AND {&&), 189- 191 
associativity, 196-197 
Boolean variab les and, 195- 196 
defined, 189 
NOT {!), 189, 193- 194, 826 
numeric ranges checked with, 197 
OR (1 I), 189, 191- 193 
precedence of, 196-197 
short-circuit evaluation, 190, 193 
1229 

1230 
Index 
long int. See data types; integer data 
types 
long double. See data types; floating-
point data types 
loops, 243- 322 
arra y iteration using, 525- 528 
body of, 244, 272-273, 276 
braces and, 244, 247 
breaking out of, 281- 283 
condition, 244 
conti nue statement, 283- 284 
contro l variab le, 246 
count -controlled, 271-273 
counters , 258-260, 271-273 
defined, 24 3 
do-while, 243, 265-270,278 
for, 243, 271- 276,278 
header, 244, 271- 272 
infinite, 246- 247 
inner, 279- 281 
iteration , 246, 274, 281-284 
nested, 279-281, 282-283 
outer, 2 79- 281 
post-test, 265, 266, 278 
pretest, 246, 271, 274, 278 
range-based for loop, 525- 528 
sentinel-contro lled, 263- 264 
situations for use of, 277- 278 
user contro lled, 259- 260 
whi le,243 - 252,278 
low-level programming language, 
9- 10 
!value, 60, 751- 753 
M 
machine language, 8 
main function, 29- 30, 325- 327, 333 
main memory, 5 
manipulators. See stream 
manipulators 
mantissa, 48 
map container, 1017 
mathematical expressions 
algebraic, 87- 90 
assignment statements for, 84- 86 
associativity, 87 
C++ library functions, used in, 
88- 90, 130-132 
converting to programming 
statements, 87- 90 
decrement operator (--) in, 
256- 257 
evaluating, 84-85 
grouping with parentheses ( ( ) ), 
87 
increment operator(++ ) in, 
256- 257 
operator precedence, 85- 86 
mathematical library functions, 
88- 90, 130- 132 
cmath header file for, 89, 130 
member access specification, 
790-791 
member functions 
accessors (get functions), 
416,419 
bit flag testing, 862- 864 
calling, 409-410 
class implementation (. cpp) files, 
446, 447-449 
constant , 706-708 
constructors, 423-429 
defining, 416-422 
destructors, 429-430 
dot operator (.) for, 415 
inline functions, 417, 422 
mutators (set functions), 416,419 
naming conventions for, 419-422 
operator overloading, 741- 742 
overridden, 800, 962 
passing objects as arguments to, 
435-441 
pri vate,413,432
-4 34,469 
protected , 787- 790 
publ ic, 413, 415-4 16, 470 
for reading and writing files, 
865- 873 
recursive, 1062- 1067 
scope resolution operator (: : ), 
417 
stale data avoidance, 422 
smart pointers, 690-691, 694 
stat ic, 711- 714 
virtual, 962 
member initialization lists, 776-778 
member variab le, 409, 411-413, 
1087 
members 
instance, 704, 711 
object, 409-412 
pointers as, 684-685 
static, 708-714 
structure, 454-458 
memberwise assignment, 720-721 
memory 
flash, 6 
main, 5 
random -access (RAM), 5, 16 
secondary storage, 5-6 
memory allocation 
address, 646, 651-652 
array, 508-509 
C-string, 127- 128 
class object, 681-682 
dangling pointer, 672-674 
delete operator for, 672-674 
dynamic, 670-674, 681-682 
exception, 671-672 
freeing memory, 672 
heap,671 
new operator for, 671- 674 
pointers and, 646, 670-674 , 
681-682 
si zeof operator, 44, 58- 59 
throwing exceptions, 671 
memory leaks, 672-674 , 676-678 , 
686 
menu, defined, 183 
menu-driven programs 
clearing the sere.en, 354 
defined, 183 
functions in, 351- 354 
switch statement in, 219- 220 
menu selection, 268-270 
method, 409 
microprocessor, 4 
millisecond, 487 
mode flags, 887- 888 
modular programming, 323- 324. See 
also functions 
modulus operator (%), 62-63 
move assignment operator, 732 
move operations , 733, 751, 
753- 761 
assignment operators , 753- 760 
compiler use of, 760 
constructors , 753-760 
copy assignment verslls, 733 
default operations, 761 
defined, 751 
move() function, 687-689 
multidimensiona l arra y, 560-562 
multi-file program, 446,451 
multi-line comment (I• • I), 66-67. 
See also comments 
multil i st container , 1017 
multi map container , 1017 
multiple assignment, 102- 105 
multiple inheritance, 787 
multiplication expressions, 87- 88 
multiplication operator (· ), 15, 
62-63 
mutator (set function), 416,419 
N 
In (newline escape sequence), 34- 35, 
292, 869 
named constant 
cons t key word, 100-101 
declaration, 100 
defined, 99 
global , 358- 361 
initialization value, 100 
namespaces, 28 

naming 
dummy names, 339 
functions, 324- 325, 339 
member function conventions, 
419-422 
name identifiers, 41-42 
same (duplicate) name given, 
202- 203 
symbolic names, 222-223 
variables, 41-4 2, 202-203 
Nationa l Commerce Bank case study, 
585- 586 
negation operator (- ), 62 
nested if statements, 185- 188. See 
also if statements 
defined, 185 
flowchart, 185 
nested loops, 279- 281, 282- 283. See 
also loops 
break statement in, 282-283 
defined, 2 79 
illustration, 279- 281 
inner and outer loops, 279- 281 
nested objects 
object composition, 442-445 
nested structures, 458-4 60 
nested t ry blocks, 998 
new operator, 671-674, 676-678, 
997 
11 log II time, 634 
nodeptr pointer, 1046, 1049- 1052 
nodes (binary ere.es). See also binary 
trees; binary search trees 
child, 1125 
defined, 1125 
deleting, 1137- 1139 
leaf, 1125 
left child, 1125 
left subtree, 1126 
parent, 1125 
pointer, 1126 
predecessor, 1125 
right child, 1125 
right subtree, 1126 
root, 1125, 1131, 1132 
search value, 1128 
successor, 1125 
value storage in, 1126, 1128, 
1132 
nodes (linked lists). See also linked 
list 
building a list, 1041 
constructor initialization, 
1040-1041 
declaracion,1039 
defined, 1037 
deleting, 1052- 1055 
dynamic allocation of, 1037 
head of the list, 1038 
illustrated, 1038 
inserting, 1049- 1052 
ListNode structure, 1039- 1041 
nodept r pointer, 1046, 
1049- 1052 
nul 1 pt r value, 1038- 1039, 
1049 
successor pointer, 1038 
not equal to relationa l operator ( ! =), 
156- 157 
NOT logical operator{!), 189, 
193- 194 
Boolean variables and, 195 
defined, 189 
precedence of, 196 
truth cable, 189- 190 
NULL character, 357 
null characters, 815- 816 
null pointer, 657 
null statement, 165 
null terminator (10), 54,297, 538 
null ptr value, 1038- 1039, 
1049, 1126 
numbers 
binary, 8 
converted co strings, 40 
floating-point, 43, 48-51 
hexadecimal, 47 
integer, 43-47 
octal, 47 
pseudorandom, 133 
random, 132- 136 
real, 17 
scored as strings, 40 
whole, 17 
numeric arrays, 531- 534 
averaging values in, 532 
finding highest and lowest values 
in, 532- 535 
summing values in, 531- 532 
numeric data, 16-17 
numeric data types, 43 
numeric literals, 39 
0 
object code, 11- 12 
object composition, 442-445, 
779- 781 
object file, 11 
object-oriented ana lysis and design, 
476-485 
class and object identification, 
476, 479-482 
class attributes, 476-477 
class behaviors, 4 77 
class relationships, 477-4 78 
defined, 4 76 
Index 
identify class responsibilities, 
482-485 
object reusabilicy, 485 
prob lem domain, 479 
object-oriented programming (OOP) 
class declaration, 470-471 
class implementation, 472-4 75 
class interface, 4 71-4 72 
data hiding, 410 
defined, 409 
introduction , 409 
member variables, 409,469 
member functions (methods), 
409-412, 435-4 41, 
470-471 
object-based programming 
versus, 485 
object serialization 
defined, 898 
deserializacion and, 899 
designing classes for, 899 
member functions, 899 
scheme determination , 900-903 
objects. See also function objects 
accessing members, 415-4 16 
accessors, 416,419 
as arguments, 4 35-441 
arra ys of, 575- 580 
attributes , 409 
composition, 442-445 
creating (class instantiation ), 414 
defined, 414 
dynamic allocation of, 681- 682 
encapsulation, 409 
identification of, 476, 479-4 82 
input/output (l/0 ) in, 452 
inst a nee, 414 
lifetime, 779- 781 
member functions, 409-4 12 
member variables, 409-410 
mutators, 416,419 
passing co functions, 435-441 , 
682-684 
pointers as members of, 684-685 
pointers co, 681- 684 
private members, 413, 432-4 34, 
469 
public members, 413, 415-4 16, 
470 
reruming from a function, 4 3 9-441 
reusabilicy, 485 
stri ng, 56,123,297, 
411-4 12 
octal integer litera ls, 4 7 
off-by-one error, 517 
of stream class, 289, 290-293, 
853- 855 
Online Friendship Connections case 
study, 898- 903 
1231 

1232 
Index 
OOP. See object-oriented 
programming (OOP) 
opening files 
constructors for, 857 
for input, 856-857 
for output, 856-857 
for both input and output, 
856- 857,893 - 897 
for structure storage, 882 
operands, 59- 60 
operating systems, 7 
operator overloading, 730-750 
approaches to, 737- 735 
arithmetic operators, 738- 741 
arra y indexing ( ( ]), 747- 750 
assignment(= ), 730- 732 
built-in operators, 736 
general issues, 736- 737 
member-function, 741- 742 
operators capable of, 737 
overriding verslls, 799- 800 
prefix/postfix(++ ), 742- 743 
relationa l operators, 738- 741 
return values, 732 
stand -alone, 741- 742 
stream insertion and extraction , 
743- 747 
operators 
arithmetic, 62- 65, 86- 87, 105, 
655-656 
address, 64 5-64 7 
assignment, 15, 84- 86, 102- 105 
associativity, 87, 1159 
binary, 62- 63, 87 
combined assignment, 102- 105 
conditiona l, 209-212 
decrement(--) , 253-257, 656 
defined, 15 
dot, 415 
increment(++), 253- 257, 656 
indirection, 647-650 , 663, 
680-681 
logical, 189- 197 
overloading, 730-750 
pointers using, 655- 656, 
659-661 
precedence, 85- 86, 159- 160, 1159 
prefix/postfix modes, 254-256 
relationa l, 155- 160, 203- 207, 
257, 659-661 
scope resolution, 417 
stream extraction (») , 78- 79, 
117- 118 
stream insertion («) , 32, 79, 
290- 291 
ternary, 62 
type conversion, 770-772 
unary, 62, 87 
OR logical operator (11), 189, 
191- 193 
defined, 191 
precedence of, 196 
short circuit evaluation , 193 
truth table, 192 
ost ri ngstream class, 829- 830, 853 
outer loop. See loops 
output 
buffer, 845, 860 
console, 31 
cout object, 29, 31- 36, 106- 116 
defined, 17 
devices, 6 
display, 29, 33- 34 
endl stream manipulator , 33- 34 
escape sequences (1), 34- 36 
field width, 107- 109, 128 
floating-point numbers, 109- 114 
formatting , 106-116, 857- 860 
I/0 streams for, 857- 860 
justified, 107- 109, 114- 115 
stream manipulators, 33- 34, 
108- 116 
validating, 225- 227 
output file, 286. See also files 
output stream classes, 851, 853- 860, 
873 
overflow, 98- 99 
overflow exception 
queue, 1105- 1106 
stack, 1088- 1089, 1092 
overloaded operators, 730- 750 
overloading 
constructors , 426--428 
function objects, 761- 770 
functions, 378- 382 
with function templates, 
1005- 1006 
overriding 
base class functions, 797- 799 
default arguments , 365 
overloading versus, 799- 800 
virtual functions, 961- 962 
ownership. See also composition 
class, 478 
p 
dynamic memory allocation, 
686-694 
padding, 107 
pa lindrome, 947 
para llel arrays, 539- 541. See also 
arra ys 
parameter list, 324 
parameters 
actua l, 335 
const key word, 438--439, 549 
constant reference parameters, 
438--439 
default arguments passed to, 
364- 367 
defined, 333 
formal, 335 
function objects as, 763 
function template type, 
999- 1002, 1005 
number, order and type of, 334, 
336- 338 
pointers as, 661- 665 
pointers to class objects as, 
682-684 
reference, 368- 376 
reference variab les as, 368- 372 
scope, 356 
storage location, 340 
types of, 334-335, 999- 1002 
parent node, 1125 
parsing, 878 
partitions, 929- 9 31 
passing. See also passing by 
reference; passing by value 
arguments to constructors, 
794- 796 
arguments to functions, 33 3- 340, 
435--441, 667-668, 
794- 796,820 
arra ys to functions, 543- 551 
Cstrings to functions, 820 
into a constant reference 
parameter, 438--439 
default arguments, 364-367 
files to functions, 374-376 
into a pointer to a constant, 
667-668 
objects to functions, 435--441 
structures to functions, 462--463 
two-dimensiona l (2DJ arra ys to 
functions, 556- 558 
passing by reference, 368- 376, 
438--439,462 --463 
comparing to by value, 
372- 373 
passing by value, 338-340, 
435--438,462 
comparing to by reference, 
372- 373 
pipe ( I) operator, 893 
pivot elements, 929- 9 31 
plain text, 973 
pointers, 645- 702 
address operator (&), 645-64 7 
aggregation through, 778- 779 
arithmetic, 655-656 
arra ys and, 651-655 
base class, 950-955 

choosing between raw and smart, 
1070 
class or structure members, 
684-685 
combined assignment operator 
(·=) for, 662 
comparing, 659-661 
constant, 668-670 
dangling, 672-674 
declaring, 648 
defined, 64 5 
dereferencing, 649, 684-685 
derived class, 950-953 
dynamic memory allocation, 
670-674,681-682, 
686-694 
function parameters, as, 661-665 
indirection operator(•), for, 
647-650,663,680-681 
inheritance and, 785- 786 
initializing, 656- 658 
linked list, used with,1038 - 1042, 
1044- 1046, 1049- 1052 
memory allocation, 646, 
670-674,680-684 
notation and precedence, 
652-653 
null ptr value, 1038- 1039, 1049 
returning from functions, 
674-678 
shared, 686, 691-694 
smart, See smart pointers 
structure pointer operator( - >) 
for, 680-681, 684 
successor, 1038 
t hi s, 703- 706 
to char, 816, 819- 820 
to a class object, 681-684 
to a constant, 665-668 
to a structure, 681- 684, 685 
type casr assignment of, 950-953 
type casting, 953- 955 
unique, 686, 689 
variables, 646, 648- 650 
polymorphism, 955- 962 
composition verws inheritance, 
969- 973 
defined, 955 
dynamic binding and, 965 
po lymorphic behavior, 955- 957 
static binding and, 960 
virtual functions and, 955- 962 
post-resr loops, 266 
postfix expressions, 941- 944 
converting ro infix, 1117- 1119 
postorder tree traversal, 1133- 1135 
pow function, 88- 90, 131- 132, 
333,343 
precedence 
associativity and, 1159 
arithmetic operators, 85- 86 
logical operators, 196- 197 
relational operators, 159- 160 
precision of floating-point data, 109 
predicates, 762- 763 
prefix expressions, 941- 944 
prefix notation , 96 
prefix/postfix operators(++) 
modes, 254-256 
overloading, 742- 743 
preorder traversa l, 1133- 1135 
preprocessor, 12 
preprocessor directives 
#defi ne, 447 
defined, 11 
#endif, 447 
#ifndef, 447 
#inc l ude, 15, 28, 36, 446-450 
pretest loops, 246,271,274 
private class members 
access specification, 783- 784 
base class versus derived class, 
790 
class functions, 432-434 
class variab les, 469 
placement of, 413 
prob lem domain, 479 
procedural programming, 409. 
See also programming 
processing program data, 17 
program 
language elements, 13- 15 
parts of, 8- 13 
statements, 15- 16, 69 
variab les, 16-17 
program -defined data types, 563-564 
programmer, 2 
programming. See also programming 
style; program 
modular , 323-324 
object-oriented (OOP), 409-4 11, 
469-475 
procedural, 409 
process, 18-23 
programming languages, 8- 11, 
13- 15 
BASIC, 10 
C, 10 
C++, 8- 9, 10 
C#, 10 
COBOL, 10 
defined, 8 
elements of, 13- 15 
FORTRAN, 10 
high-level, 9 
Java, 10 
JavaScript, 10 
key words, 14- 15 
low level, 9 
Pascal, 10 
Python, 10 
Ruby, 11 
Visual Basic, 11 
Index 
programming style 
C++, 67-69 
code alignment and indentation, 
68, 187- 188 
defined, 67 
if statements, 164-165 
while loops,248 -249 
promoted data type conversion, 9 3 
prompt, 78 
protected class members, 787- 790 
prototype. See function prototype 
pseudocode, 20 
pseudorandom numbers, 133 
pub 1 i c class members 
access specification, 783- 784 
accessing, 415-416 
base class versus derived class, 
790 
class variab le examp les, 470 
dot operator (.) for, 415 
placement of, 413 
punctuation, 15 
pure virtual functions, 963- 965 
Pythagorean theorem, 131 
Q 
quadratic time, 634 
queue container, STL, 1109, 
1111- 1112 
queues, 1099- 1116 
abstract data type (ADT), 
1099- 1106 
application of, 1099 
circular arrays for, 1102 
defined, 1099 
deque container, 1109- 1111 
dequeue operations, 1099- 1101 
dynamic, 1099, 1106- 1109 
empty, 1102 
enqueue operations, 1099- 1101 
first-in-first-our (FIFO) order, 
1099 
front/rear pointers, 1100-1101, 
1106 
full, 1102 
linked lisr Implementation, 
1099, 1106 
operations, 1099- 1102 
overflow exceptions, 1105- 1106 
queue container, 1109, 
1111- 1112 
1233 

123 4 
Index 
queues (continued) 
Standard Template Library (STL), 
1109- 1112 
static, 1099, 1103- 1106 
underflow exceptions, 
1105- 1106 
value adjustment operator {%), 
1102 
Quicksort algorithm, 634, 929- 933, 
1112- 1116 
R 
\r (return escape sequence), 35 
RAM (random-access memory), 
5, 16 
ran d() function, 133, 135- 136 
random access files, 866- 893 
defined, 886 
file positioning flags, 887- 888 
1/0 (input/output ), 886- 893 
mode flags, 887- 888 
seekp and seekg member 
functions, 887- 891 
sequential access files versus, 
886- 887 
tellp 
and te ll g member 
functions, 891- 893 
random -access memory (RAM), 
5, 16 
random numbers, 132- 136 
limiting range of, 135- 136 
pseudorandom numbers, 133 
seed value, 133- 135 
range-based for loop, 525- 528, 567 
raw pointer, 687. See also pointers 
rea d member function, 880 
reading data 
binary files, 880-881 
c i n object for, 77- 83 
defined, 286-287 
files, 286- 287, 294-297 
from a file into arrays, 513- 514 
input file, 286 
i nputFil e object, 290, 294 
member functions for, 865- 873 
multiple values, 80- 83 
program input, 77- 83 
read position, 29 5- 296 
stream extraction operator(») 
for, 78- 79, 294 
user-specified filename for, 
296- 297 
records 
creating using structures, 
881- 882 
defined, 868 
end of (\n), 869 
fields in, 868, 881- 882 
recursion, 915- 948 
binary search algorithm using, 
927- 928 
depth of, 916 
direct, 921 
eliminating, 1112- 1116 
enumeration algorithm using, 
936- 940 
exhaustive algorithm using, 
936- 940 
Fibonacci numbers problem, 
925- 926 
functions for, 915- 925, 927- 933 
indirect, 921 
iteration versus, 940 
linked list operations, 1059- 1060 
prob lem solution using, 919- 921, 
925- 926,933 - 940 
QuickSort algorithm and, 
929- 933, 1112- 1116 
Towers of Hanoi prob lem, 
933- 936 
recursive functions 
add(), 1063-1064 
base case, 918, 920 
binary search algorithm, 927- 928 
calling process, 915- 921 
defined, 915 
factorial, 
922- 924 
gcd (greatest common divisor), 
924- 925 
linked lists, 1060-1067 
list members, 1062- 1067 
QuickSort algorithm, 929- 933 
remove(), 1064- 1067 
recursive implementation, 1132 
reference count, 686 
reference parameters, 438-4 38, 726, 
728,732 
reference values, 60, 751- 753 
reference variables 
ampersand(&) for, 368- 369, 
527- 528 
array range modification to, 
527- 528 
comparing to passing by value, 
372- 373 
defined, 368 
function parameters as, 368- 3 72 
passing arguments by reference, 
368- 376 
passing files to functions, 
374- 376 
pointers, 370 
prototype for, 368-369 
reinterpret
_cast expression, 
879- 880 
relationa l expression, 156-160 
relational operators, 155- 158 
associativity, 156 
comparing characters using, 
203-205 
comparing strings using, 205- 207 
defined, 15 5 
overloading, 738- 741 
precedence of, 159- 160 
Reliable Software Systems, Inc., case 
study, 1071- 1074 
remainder, 63 
rethrowing exceptions, 998- 999 
ret urn statements 
defined, 342 
function ending process, 342- 343 
multiple values from functions, 
344 
objects from functions, 439-441 
value-returning functions, 
343- 351 
rewinding files, 873- 875 
right-justified output, 103-109 
right stream manipulator, 
114- 116, 859 
root, binary trees, 1125, 1131, 1132 
roun d function, 131 
round -off error, 173- 174 
running total, 260-262 
accumulator, 260-261 
defined, 260 
flowchart, 261 
run-time error, 21, 1049 
run-time library, 11, 130- 132 
rvalue, 60, 751- 753 
s 
scie ntific 
manipulator, 859,860 
scientific notation, 48 
scope of a variable, 61-62, 200-203 
scope resolution operator (: : ), 41 7 
screen contro l 
cell coordinates, 487 
clearing the sere.en, 354 
cursor position, 486-489 
hand le creation, 486 
input form creation, 489-491 
search algorithms. See also 
algorithms; binary search 
trees 
array of objects or structures, 
610-612 
binary, 606-609, 634 
defined, 603 
linear (sequential), 603-606, 634 
search key, 610 
vectors, 624-626 
search key, 610 
search values, nodes, 1128 

secondary storage, 5-6 
Secure Encryption Systems, Inc. case 
study, 973-976 
seed, 133- 135 
selection sort, 617- 621, 634 
self-documenting programs, 223 
sentinel values, 263- 264 
sequentia l access files, 287. See also 
binary files; 1/0 streams; 
text files 
sequentia l containers, 564, 1016. See 
also containers 
serialization of objects, 899. See also 
object serialization 
set container, 1017 
set functions (mutators), 
416,419 
Set Intersection case study, 5 8 7 
shared pointers, 686, 692- 693 
shared_ptr class 
doub le dipping danger, 693 
dynamic memory allocation 
using, 691-694 
make_share d<T> () function, 
693-694 
member functions, 694 
vector types in, 694 
short-circuit evaluation, 190, 193 
short i nt. See data types; integer 
data types 
significant digits, 109 
single-line comments (i /), 28, 66 
single-precision data types, 49 
size declarator ( 11 ), 124- 125, 
508- 510 
size() member function, 569- 570, 
1097 
si zeof operator, 44, 58-59 
slash misuse, forward ( /) versus back 
(1), 35 
smart pointers, 686-694 
choosing between raw and, 1070 
contro l blocks, 691-692 
arrays and, 689 
defined, 686 
dynamic memory allocation 
ownership, 686-694 
linked lists, 1070 
shared pointers, 686, 692-693 
shared_ptr class, 691-694 
unique pointers, 686, 689 
unique_ptr class, 687-691 
vector types and, 694 
software 
app lication, 7 
defined, 2 
system, 6- 7 
software developer, 2 
software development 
abstraction in, 408 
tools, 7 
software engineering, 22 
sorting 
C-string lists, 826-827 
function objects for arrays and 
vectors, 763 
linked lists in order, 1048- 1049 
ranges, 1112- 1113 
stacks for, 1113- 1116 
sorting algorithms. See also algorithms 
array of objects or structures, 
621-624, 763 
bubble sort, 613- 617, 634 
defined, 613 
pass, 614 
Quicksort , 634, 929- 933, 
1112- 1116 
recursive functions for, 929- 933 
selection sort, 617-621, 634 
vectors, 624-626, 763 
source code, 11- 12 
writing and compiling, 21 
space criterion, 62 7 
special characters, 30 
specification files, class, 446-447 
spreadshe.ets, data storage of, 286 
sq rt function, 131 
stack container, sn, 1097- 1098 
stacks, 1085- 1098 
abstract data type (ADT), 
1085- 1093 
applications of, 1086 
defined, 422, 1085 
dynamic, 1086, 109 3- 1096 
eliminating recursion, 1112- 1116 
handling exceptions, 1091- 1093 
IntStack class, 1087- 1091 
isEmpty function, 1087, 1093, 
1095 
last-in-first-out (LIFO) structure, 
1085- 1086 
linked list implementation, 1086, 
1093- 1095 
member functions, 1087, 1097 
operations, 1086- 1086 
overflow exception, 1088- 1089, 
1092 
pop and push member functions, 
1087- 1089, 1092- 1093, 
1095 
Quicksort algorithm and, 
1112- 1116 
Standard Template Library (STI) , 
1097- 1098 
static, 1086- 1091 
templates, 1093 
Index 
underflow exception, 1088- 1089, 
1092- 1093 
stale data, 422 
stand -alone operator overloading, 
741- 742 
Standard Template Library (STL) 
algorithms, 1022- 1029 
associative containers, 564, 
1016-1017 
containers, 564, 1016-1017, 
1020-1021, 1097- 1098 
data types, 563- 564 
deque container, 1109- 1111 
iterators, 763, 1016, 1017- 1019 
linked lists, 1068- 1070 
1 i st container, 1016, 1068- 1070 
member functions, 1020- 1021, 
1068- 1069, 1097, 1110 
queue container, 1109, 1111- 1112 
sequentia l containers, 564, 1016 
stack container, 1097- 1098 
vecto r container, 1020-1021 
statements 
assignment, 59-61, 102- 105 
break, 281- 283 
case, 213-214 
cont inue,283 - 284 
double, 17 
do-whil e loop, 265- 270 
for loop, 271- 276 
function calls, 325- 331 
header expressions, 2 71- 2 72 
if, 161- 169 
if/else, 
170- 174 
if/else 
if, 175- 181 
#i nclude, 21 
length of, 69 
mathematica l expressions 
converting to, 87- 90 
multiple, 275- 276 
programming, 15- 16, 69 
repeating, 244 
switch, 213-220 
while loops,243 -252 
static binding, 960 
stat ic_cast expression, 94- 97, 951 
static classes 
IntQueue, 1103- 1106 
IntStack, 1087- 1091 
stat ic key word, 709 
static local variables, 362- 363 
static members 
defined, 708 
functions, 711- 714, 1087 
stack class, 1087 
variab les, 709- 711, 1087 
static queues, 1099, 1103- 1106 
static stacks, 1086- 1091 
1235 

1236 
Index 
std namespace, 28 
STI. See Standard Template Library 
(STI) 
storage. See data file storage; files; 
memory 
strcat function, 820, 827 
strcle n function, 820,827 
strcmp function, 823- 827 
strcpy function, 126, 822, 827, 835 
stream extraction operator(») 
cin object, 78- 79, 117- 118 
data flow to variables, 78- 79 
defined, 78 
numeric conversions, 829 
parsing numeric output, 878 
operator overloading, 743- 747 
reading data using, 78- 79, 294 
whitespace and, 117- 118 
stream insertion operator(«) 
C++ use of, 29, 32 
cout object, 29, 32, 79 
data flow from variables, 79 
defined, 32 
formatting numbers, 878 
numeric conversions, 829 
of stream object, 290-291 
operator overloading, 743- 747 
writing data using, 32, 290- 291 
stream manipulators 
descriptions of, 858-859 
endl, 33-34 
fixed, 112 
formatting output using, 107- 116 
1/0 streams and, 857- 860 
1 eft, 114-115 
right, 114- 115 
setprec isi on, 109- 112 
setw, 107- 109, 127 
showpoint, 113- 114 
stream objects 
cin, 77- 83 
cout, 29, 31- 36 
defined, 32 
file, 288, 289- 290, 297 
string class 
C-string relationship to, 815- 816 
C++ use of, 56-57, 839- 842 
combined assignment operator 
(·= ), 123-124 
concatenation operator ( + ), 
123- 124 
constructors, 840 
creating stri ng objects, 411-412 
header file, 5 6, 411 
#inc 1 ude directive, 56, 411 
member functions, 123- 124, 
411-412, 841- 842 
operators, 840 
st ri ng objects 
c_strng function for, 297 
class functions and, 123- 124 
creating, 411-412 
defining, 564- 565 
member functions, 123-124, 
411-412 
numeric conversions, 829- 831 
strings 
ASCII values, 205 
backslash (11) for litera l output, 
35,290 
binary files, 877- 879 
blank spaces in, 123 
character -by-character processing, 
538- 539 
character literals versus, 53- 55 
class library functions for, 815 
comparing, 205- 207 
concatenation operator ( + ), 
123- 124 
escape characters in, 35- 36 
functions for, 116-129 
inputting, 117- 119 
literals, 39-4 0, 53- 55 
null characters, 815- 816 
null terminator (/0), 54, 538 
nwnbers converted to, 40, 877-879 
processing arrays of, 538- 539 
quotation marks(· 
") for, 29, 
35,40 
relational operators for 
comparison of, 205- 207 
storage of objects, 538 
writing Cstring handling 
functions for, 833- 839 
st ruct key word, 453 
structure pointer operator( - >), 
680-681,684 
structures 
accessing members, 454-456 
arrays of, 581- 584 
constructors, 457-458 
data members, 454-458 
declaration, 453-454 
defined, 453 
dereferencing pointers to, 684-685 
fields in, 881- 882 
initializing, 456-458 
nested, 458-4 60 
passing to functions, 462-463, 
682-684 
pointers as members of, 684-685 
pointers to, 681-685 
records created with, 881- 885 
returning from functions, 463-464 
search algorithms for, 610-612 
sorting algorithms for, 621-624 
variable display and comparison, 
456 
variable definition, 454 
stubs, 385- 387 
subclass, 787 
subscripts, 509- 510 
subtraction operator (- ), 62-63 
subtrees, 1126 
successor nodes, 1125 
successor pointer, 1038 
superclass, 787 
swap function template, 1002- 1003 
switch statement, 213-220 
break statements, 214-215 
case statements, 213- 214 
default section, 215- 216 
defined, 213 
fall-through capability, 216-218 
syntax, 14, 67- 68 
syntax errors, 11 
system software, 6-7 
T 
It (horizonta l tab escape 
sequence), 35 
r· get() member function, 694 
tan function, 131 
tel lp and tellg member functions, 
891- 893 
template prefix, 1000 
templates 
binary search trees, 1145 
class, 1007- 1015 
function, 999- 1007 
linked list, 1055- 1059 
stack, 1093 
ternary operators, 62 
test data, 21, 301- 303 
test expression 
defined, 2 71 
for loop header use, 2 71- 2 72 
loop termination using, 274 
testing. See also debugging 
application frameworks, 974- 976 
bit flags for, 861- 862 
Boolean variables, 194- 195 
characters, 207-208 
creating good test data, 301- 303 
exceptions for, 987- 988 
file open error, 299- 300 
1/0 streams, 861- 864 
member functions for, 862- 864 
output validation, 225- 227 
text 
cipher, 973 
editor, 11 
files, 287, 878 
plain, 973 

th is pointer, 703-706 
three-dimensional (30) arrays, 
560- 562. See also arrays 
throw point, 988 
throw statement, 988 
throwing exceptions 
dynamic memory allocation, 671 
error hand ling, 988 
new operator for, 997 
rethrowing, 998- 999 
stack underflow/overthrow, 
1088- 1089, 1092- 1093 
tilde character(-), 429 
time criterion, 627 
time function, 134- 135 
to_stri ng() function, 690-691 
top member function, 1097 
top-down design, 19 
toupper function, 267- 268 
Towers of Hanoi problem, 
933- 936 
traversing 
binary search trees, 1133- 1135 
lists, 1041- 1043 
trees. See binary trees; binary search 
trees 
true/false 
values 
binary search trees, 1135- 1136 
if statement, 167- 169 
relationa l operators, 156- 160 
returning from a function, 
349- 351 
variables, 57- 58 
whil eloops,244-245 
truncated value, 51, 94 
try block, 988-989, 998 
try/catch construct, 988- 990 
two-dimensional (20) arrays, 
553- 559 
defined, 553 
initialization, 555- 556 
passing to functions, 556-558 
processing contents, 553- 555 
subscript operator (I]), 553 
summing columns of, 559 
summing elements in, 558 
summing rows of, 558- 559 
type cast expressions 
assignment, 950-953 
base class pointers, 950-955 
C- and C++-style, 96- 97 
data type conversion using, 
94-97 
defined, 94 
derived class pointers, 950-953 
functiona l notation, 96- 97 
inheritance hierarchy 
compatibi lity, 949- 955 
integer division, 9 5 
prefix notation, 96 
rei nterpret _cast, 879- 880 
static _cast, 94- 97, 951 
value demotion and promotion, 
92- 96 
type coercion, 9 3 
type compatibi lity, 950- 953 
type conversion operators, 770-772 
type parameters, 999, 1005 
typedef statement, 543 
. txt extension, 288 
u 
UML class diagram, 409,412 
unary functions, 766- 767 
unary operators, 62, 86 
unary predicate, 762 
uncaught exceptions, 990 
underflow exception 
queues, 1105- 1106 
stacks, 1088- 1089, 1092- 1093 
underflow, 98- 99 
unique pointers, 686, 689 
unique_ptr class 
array deallocation using, 689 
dynamic memory allocation 
using, 687-691 
member functions, 690-691 
unsigned int value, 44-45, 93 
unsigned long int values, 44-45, 93 
unsigned short i nt value, 44-45 
unwinding the stack, 997- 998 
update expression 
defined, 272 
for loop header use, 271- 272, 
274 
multiple statements in, 275- 276 
USB flash drive, 6 
user interfaces, object-oriented 
programming, 410-411 
user specifications 
counter loop control, 259- 260 
errors from, 185, 198- 200 
filename, 296- 297 
input validation, 185, 198-200 
loops, 259- 260 
user-controlled for loops, 2 7 5 
using namespace std statement, 28 
utility programs, 7 
V 
validation 
debugging, 225- 22 7 
input, 185, 198- 200, 250- 252 
menu-driven programs, 185 
output, 225- 22 7 
Index 
user specifications, 185, 198- 200 
whi 1 e loops for, 250-252 
value. See also true/false 
values; 
variables 
ASCII comparisons, 203- 205 
assignment statements, 37- 38, 
59-61 
assignment to C-strings, 126 
binary trees, 1126, 1128, 1132, 
1135- 1136 
Boolean, 57- 58, 195- 196, 
349- 351 
integers, 38, 43-48, 51 
litera l assignment, 39-40 
node storage, 1126, 1128, 1132 
nullptr, 1038- 1039, 1049, 
1126 
numerical, 16-17 
passing arguments by, 338- 340 
reference, 60, 751- 753 
root node, 1132 
stored in function objects, 
765- 766 
truncated, 51, 94 
vector storage and retrieval, 
565- 566 
value ranking, 92- 93 
value-returning functions, 343- 351. 
See also return statements 
calling, 345- 348 
defined, 343 
defining, 344- 345 
prototype, 345 
variab le definition 
defined, 16- 1 7 
enumerated data types, 465 
forloops,274-275 
initialization expressions, 
274-275 
initialization, 60-61 
integers, 38, 45 
modification and, 274- 275 
one statement for declaring 
and,465 
semicolon (;) ending for, 46 
structures, 4 54 
variab les 
accumulator, 260-261 
address, 646 
assignment statements, 37- 38, 
59-61, 103 
auto key word declaration, 61 
avoiding modification, 274 
Boolean, 19 5- 196 
counter, 258- 260, 271 
cout object, 38 
data types, 16- 17, 58- 59 
defined, 16 
1237 

1238 
Index 
variables (co11ti11ued
) 
display and comparison of, 456 
enum,465-466 
enumerated data types, 465 
false values, 57- 58 
floating-point data types, 48- 51 
function-defined, 355- 363 
globa l, 355, 356- 362 
indirection operator(•), 647- 650 
initialization, 59-61 , 274-275 
integer values, 38, 43-48, 51 
literal value assignment, 39-4 0 
local, 355- 356, 361- 363 
logical operators and, 195- 196 
loop contro l (num), 253, 
255- 256,259 
memory location, 16 
name identifiers, 41-42 
numerical values, 16-17 
object members, 409-410 
pointer, 647-650 
reference, 368- 376 
same name given to, 202- 203, 
361- 362 
scope of, 61-62 , 200-203 
selection of data types, 43-44 
sizeof operator, 58- 59 
stack class members, 1087 
static local, 362- 363 
static members, 709- 711 
structures , 453-464 
true values, 57- 58 
values changed by assignment, 
102- 103 
vector container , sn, 1020-1021, 
1097- 1098 
vector member functions 
at(), 574 
capacity(), 574 
clear() , 572, 574 
empty, 572- 573, 574 
pop_back,570-571,574 
push_back,567 - 569,574 
resize , 574 
reverse, 574 
size, 569- 570 
summary, 574 
swap, 574 
vectors, 563- 574 
angle brackets(< >) for, 564 
array subscript operator ( [) ), 
564,566 
arrays and, 563- 574 
clearing, 572 
defining, 564- 565 
detecting empty, 572- 573 
function operators for, 763- 765 
header file, 564 
initializing, 564-565 
iterators for, 763 
linked list advantages over, 
1037- 1038 
range-based for loop with, 567 
removing elements from, 
570-571 
removing objects from, 764- 765 
search algorithms for, 624-626 
sequence container data type, 564 
shared pointers to, 694 
sorting algorithms for, 624-626 , 
763 
sorting elements in, 763 
value storage and retrieval, 
565- 566 
virtual functions 
abstract base classes and, 
693-695 
abstract, 963 
defined, 955 
dynamic binding, 960 
inheritance of, 957- 960, 963 
overriding, 961- 962 
polymorphism and, 955- 962 
pure, 963- 965 
static binding, 960 
void functions, 325 
w 
weak pointers, 686 
web browsers, data storage of, 286 
whi 1 e loops. See also loops 
body, 244 
condition expressions, 244- 245 
counters, 258- 260 
flowchart, 244 
header, 244, 271 
infinite loop causes, 246- 247 
input validation using, 250-252 
iteration, 246 
pretest loop process, 246 
programming style and, 248- 249 
repeating statement or block, 244 
situations for use of, 278 
true/false conditions , 244-245 
whitespace characters , 117- 119, 865 
wi dt h function, 127- 128 
with draw member function, 471 
word processors, data storage 
of, 286 
worst-case complexity, 630-632 
write member function, 879- 880 
writing Cstring handling functions, 
833- 839 
writing data 
arra y contents to files, 514 
cout object for, 31- 36 
defined, 286 
escape sequences and, 34- 36, 
291, 292 
files, 286, 290-293 
member functions for, 865- 873 
of stream header file objects for, 
289, 290-293 
output file, 286 
output Fi 1 e object, 290-291 
program input, 31- 36 
stream insertion operator («) for, 
32,290-291 
writing function templates, 
999- 1002 

C++ Quick Reference 
Commonly Used C++ Data Types 
Data Tvne 
cha r 
int 
sho rt int 
short 
unsigned 
int 
unsigned 
lo ng int 
lo ng 
f l oat 
doub l e 
Descrintion 
Character 
Integer 
Short integer 
Same as s hort 
int 
Unsigned integer 
Same as unsig ned int 
Long integer 
Same as l ong int 
Single precision floating point 
double precision floating point 
Forms of the if 
Statemen t 
Simple if 
if 
(expression) 
s tatem
en t; 
if/else 
if 
(expression) 
s tatem
en tl; 
else 
s tatem
en t2; 
if/else if 
if 
(expressionl) 
s tatem
en tl; 
else 
if 
(expression2) 
s tatem
en t2; 
else 
sta tement3; 
Example: 
i f 
(x < y) 
x++; 
Example: 
i f 
(x < y) 
cout 
<< x; 
e l se 
cout 
<< y; 
Example: 
i f (l etter 
--
'A ' ) 
cout 
<< "apple"; 
e l se if 
( l ette
r - -
' B') 
cou t < < ''banana'' 
; 
else 
cout 
<< "'orange
"'; 
To conditionally execute more thon one statement, 
enclose them in braces: 
Form: 
Example: 
if 
(expression) 
i f (x < y) 
{ 
{ 
s tatementl; 
cout 
<< x; 
... 
x++; 
s tatementn; 
} 
} 
Formatting Output Wi th Stream Manipulators 
Requires the iostream 
and iomanip header files 
Name 
Description 
endl 
advances output to the beginning 
of the next line. 
fixed 
outputs values in fixed point notation 
left 
left justifies subsequent outputs 
right 
right justifies subsequent outputs 
setprecision 
sets the number of significant digits 
setw 
sets field width of the next output 
showpoint 
Example: 
forces decimal point & trailing zeros 
to display 
cout 
<< setprecision(2) 
<< fixed 
<<left<< 
x << endl; 
Some Commonly Used Library Functions 
Name 
Description 
(The following require the cmath header file) 
pow 
Raises a number to a power 
sqrt 
Returns square root of a number 
(The following require the cstdlib 
header file) 
rand 
sra nd 
Generates a pseudo-random number 
Sets seed value for random numbers 
(The following require the cc type header file) 
toupper 
Returns a character's uppercase equivalent 
tolower 
Returns a character's lowercase equivalent 
The while 
Loop 
Form: 
whi l e (expression) 
{ 
} 
s tatement
; 
s tatement
; 
The do - whi l e Loop 
Form: 
do 
{ 
s tatement
; 
s tatement
; 
}whil e (expression); 
The for Loop 
Form: 
Example: 
while 
(x < 100) 
{ 
cout 
<< x << endl; 
x++; 
} 
Example: 
do 
{ 
cout 
<< x << endl; 
x++; 
}while 
(x < 100); 
for 
(initialization; 
te s t; 
update) 
{ 
} 
s tatement
; 
s tatement
; 
Example: 
for 
(int 
count= 
O; count< 
10; count++) 
{ 
} 
cout 
<< "The va l ue of count 
is
" ; 
cout 
<<count<< 
endl; 
Reading Keyboard Input 
cin requires the iostream 
headerfile 
getline 
requires the string 
header file 
Name 
Description 
ci n >> 
Reads in a numeric value, a character, 
or a string with no whitespace 
Example: ci n >> le ngth 
>> width; 
getline 
Reads in an entire line of input 
Example: getline 
( ci n , address); 
ci n. get 
Reads in a single character 
Example: nextChar 
= cin . get(); 
ci n. ig nore 
Ignores (i.e. skips) the next character 
in the input buffer 
Example: ci n. ig nore(); 
ci n. ig nore(n, 
c) lgnores(i.e. skips)ncharacters 
or until the character c is encountered 
Example: ci n. ig nore ( 10, ' \n' ) ; 

